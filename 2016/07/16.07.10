00:08:20 <NeverDie> petercommand: Like this? $ stack setup 8.0.1
00:10:07 <dysfun> NeverDie:what are you trying to achieve though?
00:10:23 <dysfun> because stack releases pin to a specific ghc
00:10:55 <NeverDie> dysfun: To install 8.0.1
00:11:05 <NeverDie> I put that exact command and it seems to be installing at the moment.
00:11:19 <dysfun> and it will. but what do you want to do with it?
00:11:29 <NeverDie> To program in Haskell?
00:11:55 <dysfun> are you just learning?
00:12:00 <NeverDie> I don't have a specific project in mind at the moment if that's what you're getting at.
00:12:02 <NeverDie> And yeah.
00:12:13 <dysfun> then don't try and download the latest ghc, use stack normally
00:12:26 <NeverDie> Why not?
00:12:27 <dysfun> they pin to releases because they need time to make sure everything works
00:12:43 <petercommand> NeverDie: yes
00:12:49 <NeverDie> I see. Well I went ahead and did it anyways lol.
00:12:59 <NeverDie> Kind of late for that now.
00:13:28 <dysfun> well you can always blow it away
00:13:50 <dysfun> the reason we recommend stack is because it makes dependency problems a lot less likely
00:14:10 <NeverDie> Well it seems I had 7.10.3 installed with Stack already.
00:14:19 <NeverDie> dysfun: You're one of the core contributors of it?
00:14:27 <dysfun> no, not at all
00:14:42 <NeverDie> How do I change the default GHC version on Stack?
00:14:47 <dysfun> i just mean the community of haskell newbie helpers
00:14:55 <dysfun> the GHC version is pinned to the release
00:15:10 <dysfun> if you open your stack.yaml you'll see a release number. like e.g. lts-6.3
00:15:16 <NeverDie> I see.
00:15:41 <NeverDie> I deleted my previous GHCI install, seems I can only run GHCi now by doing  $ stack ghci
00:15:49 <dysfun> yes
00:15:55 <NeverDie> And that's recommended?
00:16:19 <dysfun> yes. it isolates compilers on a per-project basis
00:16:50 <dysfun> reliable builds is what it's about
00:17:11 <dysfun> if it builds on my machine, it should build on yours
00:17:21 <NeverDie> I see.
00:20:16 <NeverDie> dysfun: If I wanted to build a project, should I have a .cabal file?
00:20:22 <dysfun> yes
00:20:39 <dysfun> the stack template will generate one
00:20:55 <dysfun> stack new myproject
00:21:08 <NeverDie> Oh yeah.
00:21:57 <dysfun> if it's something you don't intend to release to hackage, like an end application, you can remove the package bounds in your cabal file
00:22:19 <dysfun> because stack already pins versions
00:22:57 <NeverDie> dysfun: Package bounds?
00:23:03 <NeverDie> I don't see anything related to that.
00:23:14 <dysfun> when you declare your dependencies, you can optionally provide package bounds
00:23:22 <dysfun> i.e. a condition for versions that are acceptable
00:23:42 <NeverDie> dysfun: Ah, what if I wanted to install this lib with Stack? http://www.serpentine.com/wreq/tutorial.html
00:23:49 <NeverDie> And Aeson as well?
00:24:03 <dysfun> find your dependencies in the list (build-depends) and add them
00:24:13 <NeverDie> Just manually in the file?
00:24:14 <dysfun> er in the cabal file
00:24:17 <dysfun> yes
00:25:05 <dysfun> and when you stack build again, it'll fetch them
00:25:15 <NeverDie> dysfun: For both the library and executable section?
00:25:28 <dysfun> just the library is best
00:25:44 <dysfun> the executable should just be a thin shim around the library for most projects
00:26:10 <dysfun> makes it easier to test things
00:26:37 <NeverDie> dysfun: Separated with commas orrr?
00:26:41 <dysfun> yes
00:27:18 <NeverDie> dysfun: So basically like this? build-depends:       base >= 4.7 && < 5, aeson == 0.8.0.2, wreq == 0.3.0.1
00:27:39 <dysfun> i'd split it over multiple lines, but yes
00:27:49 <dysfun> and given you're learning, i'd remove the conditions
00:28:07 <dysfun> just base, aeson, wreq
00:28:12 <dysfun> stack will fill in the versions
00:28:48 <dysfun> (particularly i'd never have an == constraint)
00:28:49 <NeverDie> Andd it's building.
00:29:11 <NeverDie> Ahh.
00:29:19 <NeverDie> Missed checking back here before doing so.
00:30:01 <NeverDie> dysfun: If I wanted to serve a React project with Haskell as the backend, how could I serve the static files with Haskell?
00:30:41 <dysfun> three are many projects that will offer you a way to serve requests and several ways to use that to serve files
00:30:46 <dysfun> there*
00:31:20 <dysfun> as a beginner, snap is pretty easy to get things like that going with
00:31:42 <NeverDie> dysfun: What about Spock?
00:31:59 <dysfun> i understand it's a reasonable choice, but i've never used it
00:32:21 <NeverDie> I see. I'll try out Spock perhaps.
00:33:44 <dysfun> which reminds me, i should probably hack on my routing thing
00:34:17 <NeverDie> dysfun: Going to try making a simple currency converter that pulls API data from here: fixer.io
00:34:46 <dysfun> i see
00:35:08 <NeverDie> Aeson & wreq should be enough to get the basics down at least?
00:35:20 <dysfun> i'd imagine so. assuming it's using json of course :)
00:35:37 <NeverDie> Yeah, it is.
00:36:22 <Cortland> :)
00:37:36 <NeverDie> dysfun: So in the Main.hs, I just put import Network.Wreq ?
00:37:52 <dysfun> the Main.hs is your executable wrapper
00:37:55 <NeverDie> Or is it already imported when it says import Lib?
00:38:04 <dysfun> it should just call your main in your library
00:38:08 <dysfun> which is currently called Lib
00:38:42 <NeverDie> dysfun: Oh. So I write all of my stuff in the src/Lib.hs file?
00:38:55 <dysfun> yes. except i'd rename it and update Main.hs to reflect that
00:39:01 <dysfun> and i'd split it out into more files
00:39:06 <dysfun> where it made sense
00:39:08 <NeverDie> Yeah that would be ideal.
00:40:02 <dysfun> the other thing I normally do is move Main.hs into the top directory and update cabal.hs's source-paths for the executable build
00:40:15 <dysfun> but that's optional
00:40:40 <NeverDie> Yeah, seems rather redundant to have it in its own /app directory if it's meant to be a standalone. 
00:40:45 <dysfun> uhuh
00:40:52 <dysfun> but not everyone treats it like me
00:41:05 <dysfun> and some projects have quite a few executables
00:41:11 <NeverDie> dysfun: So if I want to test things out, I load the Main.hs file with ghci?
00:41:32 <dysfun> no, you load the library file
00:41:39 <dysfun> because the Main.hs is just your entry point
00:41:51 <dysfun> if all three lines of it compile, you're good
00:42:03 <NeverDie> I see. So within the Lib.hs I put import Network.Wreq ?
00:42:06 <dysfun> yes
00:42:17 <dysfun> but find a better name than 'Lib' :)
00:42:29 <NeverDie> Yeah, it's just so that we're on the same page lol.
00:42:34 <dysfun> sweet :)
00:44:05 <NeverDie> All the modules needs to be capitalized?
00:44:32 <dysfun> yes. haskell is capitalisation sensitive
00:45:08 <dysfun> module and type names must start with an uppercase, 'variable' and function names must start with a lowercase (or e.g. _)
00:46:02 <kosmikus> constructors are uppercase too
00:46:10 <dysfun> indeed. and typeclasses
00:46:15 <NeverDie> dysfun: I see. I figured as much for the latter.
00:46:29 <NeverDie> So my imports go below the module declaration?
00:46:36 <dysfun> yes
00:48:41 <NeverDie> Now it's starting to get interesting.
00:56:37 <NeverDie> dysfun: Currently have this but I'm not sure what type signature to use for my API call: https://gist.github.com/RecursiveLogic/7057394949494d0d0881ea06a8590453
00:57:07 * dysfun waits for firefox to wake up
00:57:28 <dysfun> heh
00:57:49 <dysfun> that would be String -> IO String
00:57:52 <dysfun> String == [Char]
00:58:09 <dysfun> i'm guessing. i haven't used wreq
00:58:26 <dysfun> String -> String -> IO String
01:00:25 <NeverDie> dysfun: Got this https://gist.github.com/RecursiveLogic/6c879b2e3377c1288504cb33eab5d964
01:00:36 <NeverDie> When I changed it to getRates :: [Char] -> [Char] -> IO String
01:01:00 <dysfun> right, well it doesn't return a string heh
01:01:24 <dysfun> firstly, you need to parenthesis the string concatenation
01:01:26 <NeverDie> It returns an IO ()
01:01:43 <dysfun> try that and get me a clearer error :)
01:01:55 <NeverDie> After the get?
01:02:06 <dysfun> yes. the parameter to the get is a string
01:02:15 <dysfun> you need to parenthesis it
01:02:19 <dysfun> haskell won't guess what you mean
01:03:43 <NeverDie> dysfun: Tried this: https://gist.github.com/RecursiveLogic/104b32f03f0c703f6fce88711c5f1633
01:04:34 <NeverDie> Tried to also do it with ("," ++ y)
01:04:40 <dysfun> right, the last type in the sig should be IO (Response ByteString)
01:04:52 <dysfun> the ++s will chain fain
01:05:18 <dysfun> fine
01:05:40 <dysfun> you will need to import Data.ByteString.Lazy (ByteString)
01:06:19 <NeverDie> Exactly as import Data.ByteString.Lazy (ByteString) ?
01:06:36 <dysfun> i'm just checking now :)
01:06:49 * dysfun is still waking up and has a very slow machine
01:07:17 <NeverDie> dysfun: Actually this is everything I have: https://gist.github.com/RecursiveLogic/350d8d5b4fde0b4f4467b494709bad05
01:07:18 <Greezler> I am trying to use errorExit in my code and getting: Not in scope: ‘errorExit’ ... I can't find anything about it via Google
01:07:24 <NeverDie> How would you rewrite that?
01:09:01 <dysfun> Greezler: hoogle doesn't know it either, so it doesn't exist
01:09:19 <dysfun> Greezler: well i'd only have the one set of parens
01:09:23 <dysfun> ++s compose nicely
01:10:23 <saurabhn_> hey, I'm completely stuck with hamlets, and widgets, & handlers in Yesod. Can anyone help me with http://stackoverflow.com/questions/38289927/how-to-do-io-in-a-widget-hamlet-referenced-by-defaultlayout ?
01:11:28 <dysfun> i think i'm the only person who knows much haskell who is awake and i don't use hamlet, sorry
01:12:11 <saurabhn_> dysfun: thatnks for trying :)
01:12:26 <dysfun> np. good luck
01:14:28 <NeverDie> dysfun: I did it without a type signature and the then :t getRates
01:14:39 <NeverDie> And this is what I got as the inferred type: (Response bytestring-0.10.6.0:Data.ByteString.Lazy.Internal.ByteString)
01:14:50 <dysfun> oh sorry yes, i was looking that up for you
01:14:54 <NeverDie> Where do I even import that from lol.
01:14:56 <dysfun> import Data.ByteString (ByteSTring)
01:15:05 <dysfun> er, tr/T/t
01:16:01 <NeverDie> dysfun: Could not find module ‘Data.ByteString’ It is a member of the hidden package ‘bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6’.
01:16:10 <dysfun> add bytestring to your build-depends
01:18:48 <idnb> is there any implementation of j-bob in haskell?
01:19:43 <NeverDie> dysfun: Can't build.
01:19:44 <dysfun> idnb: it's a bit quiet in here at the moment, i'd suggest googling
01:20:06 <dysfun> NeverDie: details are good :)
01:21:57 <NeverDie> Not sure if this is correct but I put bytestring >= 0.10.6.0
01:22:21 <dysfun> you know i can't help you unless you tell me the error, right?
01:23:26 <NeverDie> Yeah, one sec.
01:23:35 <NeverDie> I almost feel like doing all of this without type signatures lol.
01:24:14 <NeverDie> dysfun: https://gist.github.com/RecursiveLogic/bc82d9ad0556d759822f60848f303180
01:24:16 * dysfun will quite often write them without, put the emacs cursor over them and let haskell suggest a type signature, then tidy up the suggestoin
01:25:52 <dysfun> but explicit type signatures are there to catch errors in your thought process
01:26:34 <NeverDie> Yeah but right now it's killing my momentum in the first place.
01:26:51 <dysfun> no, it just appears like that
01:26:54 <NeverDie> If I were any less persistent, I'd have stopped an hour ago.
01:27:05 <dysfun> haha
01:27:08 <JuanDaugherty> what emacs pkg/mode does that?
01:27:12 <NeverDie> But I understand its purpose.
01:27:17 <dysfun> unfortunately what it takes to learn a language is persistence
01:27:28 <dysfun> JuanDaugherty: haskell-mode
01:27:34 <dysfun> with flycheck
01:27:35 <NeverDie> Not really, learning Haskell is almost like learning how to program again.
01:27:43 <JuanDaugherty> ah thx
01:27:48 <NeverDie> Picking up other procedural languages doesn't take much persistence.
01:27:59 <NeverDie> It's all downhill after the first one lol.
01:28:05 <dysfun> you'd be surprised
01:28:40 <NeverDie> dysfun: Any clues from the errors?
01:28:54 <NeverDie> If not, I'm just going to not use type signatures for now.
01:29:07 <dysfun> oh sorry
01:29:16 <dysfun> well, i probably gave you the wrong bytestring
01:29:39 <dysfun> just change the import to what it says
01:30:06 <dysfun> it does after all know what it returns
01:31:04 <dysfun> but i think you should persist. because it'll help you learn to understand the errors
01:31:34 <dysfun> and you can't go too far in haskell without learning to do that. or do quite a lot of things, actually
01:38:00 <NeverDie> dysfun: Yeah but right now I want to just see some data.
01:38:10 <NeverDie> I'm really sleepy at this point and I'm surprised I'm still at it lol
01:38:18 <dysfun> haskell is going to take thought
01:38:21 <dysfun> do it when you're less tired
01:38:21 <NeverDie> It's 4AM here.
01:38:37 <NeverDie> Yeah but I don't want to sleep and I feel compelled to get somewhere with this before I sleep lol.
01:38:54 <dysfun> well update the import to the module ghc suggest and it should compile
01:39:03 <dysfun> and then you should be able to use it from ghci
01:40:42 <NeverDie> dysfun: I did and I still get errors lol.
01:40:51 <dysfun> then show me
01:40:56 <NeverDie> import Data.ByteString.Lazy.Internal.ByteString right?
01:41:22 <dysfun> not .ByteString , (ByteString)
01:41:28 <dysfun> with a space before the (
01:41:53 <dysfun> you are importing ByteString (the type) out of D.B.L.I (the module)
01:43:26 <NeverDie> Holy shit I got it.
01:43:36 <NeverDie> And it wasn't that.
01:44:15 <NeverDie> dysfun: It was this: https://gist.github.com/RecursiveLogic/3eb5ccd566e2eeb1159eb36ed5fe9f6c
01:45:00 <pavonia> Why do you import the internal module?
01:45:13 <NeverDie> pavonia: Because I don't know any better.
01:46:00 <pavonia> "import qualified Data.ByteString.Lazy as LBS" and then "IO (Response LBS.ByteString)" is my suggestion
01:46:02 <dysfun> pavonia: because i only really use strict bytestrings and i don't know where the best place to get the lazy bytestring type from is
01:46:16 <dysfun> NeverDie: what you've done there imports all the public things in the module
01:46:44 <dysfun> some of which might overlap with already imported things in prelude. that's a common thing with bytestrings
01:46:49 <NeverDie> pavonia: Why?
01:46:58 <NeverDie> Ahh.
01:47:14 <dysfun> well, the qualified method allows you to have both strict and lazy bytestrings
01:47:27 <pavonia> To get all the functions for the ByteString you might need at some point
01:48:00 <dysfun> you will need bytestring functions soon, yes
01:48:11 <dysfun> well actually aren't you just going to pump it into aeson?
01:48:28 <NeverDie> Beats me lol.
01:48:37 <NeverDie> I'll figure more of it out later when I wake up or something.
01:49:11 <dysfun> well next up you need to pattern match on the response
01:49:50 <dysfun> but if you try it out in ghci, you should see what it is
01:50:18 <bollu> quick question
01:50:22 <bollu> what exactly does this syntax do?
01:50:23 <bollu> data AnyWidget = forall w. Widget w => AnyWidget w
01:51:10 <NeverDie> dysfun: I'll try to keep that in mind.
01:51:10 <bollu> like, is it saying that forall types w that can be a Widget, I provide a constructor for AnyWidget?
01:51:15 <dysfun> that looks like existential quantification
01:51:15 <bollu> if so, why not write it like this:
01:51:38 <bollu> data Widget w => Anywidget
01:51:49 <dysfun> the explicit purpose is to hide that w
01:52:01 <dysfun> for why, i can't say
01:52:04 <bollu> dysfun: yeah, it seems that the constructor is witnessing a AnyWidget w, but the type itself does not have the w right?
01:52:13 <dysfun> yes
01:53:26 <bollu> so if I was going to rewrite this GADT style, it would be: data AnyWidget where AnyWidget :: Widget w => w -> AnyWidget
01:53:35 <bollu> dysfun: ^ does that GADT signature look correct?
01:55:02 <dysfun> no clue :)
01:55:18 <pavonia> It does
01:58:14 <bollu> pavonia: was the "it does" to me?
01:58:21 <pavonia> Yep
01:58:40 <bollu> pavonia: cool, ty!
01:59:18 <bollu> pavonia: I'm a little new to GADTs, are there any references that I can read up on to see potential uses? I now understand the "how", but not really then "when to use them"
01:59:54 <dysfun> do you see the overlap with type families?
02:00:00 <bollu> dysfun: not reallyno
02:00:03 <pavonia> Ther are many tutorials/blog posts out there about GADTs
02:00:20 <bollu> pavonia: I tried looking, most of them seem to explain the ideas, but not the usecases
02:00:26 <bollu> dysfun: enlighten me please? :)
02:00:34 <dysfun> there was a good piece, let me see if i can find it
02:00:37 <mniip> overlap with type families?
02:00:55 <mniip> having worked with GADTs for a long time I didn't notice one
02:01:05 <ggVGc> man, I wish ghc-mod was faster
02:01:23 <bollu> mniip: do you have like, a cheat sheet of use cases or something?
02:01:36 <bollu> mniip: "Haskell design patterns with 10 GHC extensions" :)
02:02:02 <dysfun> bollu: jesting aside, there is this https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html
02:02:34 <bollu> dysfun: yep, that I have seen. It was a bit too short IMO. I liked the 24 days of libraries because you can show off a library in a blog post
02:03:26 <mniip> bollu, existential quantification, type-controlled data invariants, data witnesses of type invariants
02:04:22 <dysfun> i can't find an article, but what i meant by the overlap is how the two interplay. with GADTs and type families, you can do some quite powerful things
02:04:24 <bollu> mniip: I know 1. don't know what 2 and 3 are referring to. 
02:04:58 <bollu> dysfun: ah, I see. I don't fully grok type families. From what I've seen, you can use it to attach "satellite" types to a "main" type that you have to become a "type family", correct?
02:05:20 <mniip> bollu, well, consider
02:05:36 <dysfun> i think mniip is more qualified than me to answer
02:05:49 <mniip> data List a (b :: Bool) where Nil :: List a False; Cons :: a -> List a b -> List a True
02:06:29 <mniip> (forall b. List a b) is isomorphic to [a]
02:06:45 <mniip> yet 'List a True' is always a non-empty list
02:07:07 <mniip> so if needed, you could write a function that only accepts non-empty lists
02:07:15 <mniip> and applying such function to an empty list wouldn't typecheck
02:07:23 <bollu> mniip: ah. So this falls under #2 right? because you're expressing a data invariant in a type?
02:07:29 <mniip> yews
02:07:32 <mniip> yes
02:07:49 <bollu> I see.
02:08:10 <bollu> mniip: I did something like this to encode the length of the list in the datatype by using the usual inductive Nat definition. That also falls under 2, correct?
02:08:13 <bollu> and what's 3?
02:08:35 <mniip> yes
02:08:48 <mniip> now, say, you have data BoolS (b :: Bool) where TrueS :: BoolS True; FalseS :: BoolS False
02:09:10 <bollu> mniip: okay
02:09:42 <mniip> pattermatching on a value of type 'BoolS b' will determine what 'b' is
02:10:05 <bollu> right
02:10:16 <bollu> isn't this isomorphic to data Bool = True | False though?
02:10:20 <bollu> I don't see the difference
02:11:10 <mniip> bollu, BoolS is *indexed* by Bool
02:11:26 <mniip> BoolS True is inhabited only by one value: TrueS
02:11:47 <bollu> mniip: hm, okay, so where/how? would we use this?
02:12:18 <mniip> if you have some computation, that results in a Bool
02:12:22 <mniip> er
02:12:25 <mniip> some type computation
02:13:03 <mniip> how would you observe the result of this computation at term level
02:13:31 <bollu> mniip: "term level" as in "type level"?
02:13:44 <mniip> value level
02:14:07 <bollu> um, like, pattern match on it?
02:14:24 <mniip> you can't pattern match on types
02:14:31 <mniip> at least, while DependentHaskell is unfinished
02:14:48 <bollu> mniip: wait, can we take a concrete example of what you're asking for? I'm mixing up the type and value level :)
02:17:23 <bollu> mniip: ? please?
02:17:27 <mniip> one moment
02:17:32 <bollu> mniip: sure
02:21:18 <lpaste> mniip pasted “gadts” at http://lpaste.net/169442
02:21:25 <mniip> bollu, consider the null' above
02:22:47 <mniip> you can write the function because the internal structure of the List datatype provides enough information to reconstruct what 'b' is from a value of the type 'List a b'
02:23:06 <mniip> but what if it wasn't
02:23:19 <mniip> how would you write, forall p (b :: Bool). p b -> Bool
02:24:05 <mniip> well, you can't write that function exactly, not with a 'forall', as it wouldn't be uniform
02:24:20 <bollu> ohh, I get the problem now. It's the fact that we want to (ideally) pattern match on the "b" at the _type_ level, but you can't do that
02:24:25 <mniip> yes
02:24:31 <bollu> mniip: dependant types would let you do this right?
02:24:33 <bollu> Data
02:24:36 <bollu> DataKinds ?
02:24:39 <mniip> no
02:24:57 <mniip> dependent types would let you do this, but then the function has type forall p. pi (b :: Bool). p b -> Bool
02:25:05 <mniip> which is still not forall
02:25:19 <mniip> anyway
02:25:21 <mniip> what you can do is
02:25:36 <mniip> introduce a minimal datatype that has just enough structure to tell you what 'b' is
02:25:40 <mniip> i.e BoolS above
02:25:55 <bollu> mniip: so with BoolS, what would this look like?
02:26:07 <mniip> what would what look like
02:26:47 <bollu> if I were to use BoolS
02:26:52 <mniip> oh I didn't finish
02:26:56 <bollu> oh, okay
02:27:07 <mniip> next you introduce a typeclass: class KnownBool (b :: Bool) where boolSing :: BoolS b
02:27:15 <mniip> instance KnownBool False where boolSing = FalseS
02:27:20 <mniip> instance KnownBool True where boolSing = TrueS
02:27:33 <mniip> then what you can write is
02:27:38 <mniip> KnownBool b => p b -> Bool
02:27:41 <bollu> what does "boolSing: stand for?
02:27:47 <mniip> singleton
02:27:51 <bollu> I see
02:28:01 <mniip> BoolS is a singleton type
02:28:16 <mniip> presumably because for any fixed choice of b, BoolS b is inhabited by one and only one value
02:28:53 <cocreature> there is not really a need for KnownBool, you can just write a function BoolS b -> Bool
02:29:17 <mniip> cocreature, what about p b -> BoolS b
02:29:18 <bollu> mniip: once again, can you lpaste this please?
02:29:36 <cocreature> mniip: what about it?
02:29:45 <mniip> can't write that without KnownBool
02:30:07 <cocreature> well ofc not, but why do you want a typeclass for things that pretend to be booleans
02:30:20 <mniip> ?
02:33:26 <bollu> mniip: could I look at all of it at once? the "BoolS" part
02:34:27 <lpaste> mniip annotated “gadts” with “gadts (annotation)” at http://lpaste.net/169442#a169443
02:35:36 <mniip> asPhantomOf is just some type trickery because I hate scoped tyvars
02:35:52 <bollu> instance KnownBool False <- this is using False as a Type. so.. DataKinds is being used right?
02:36:10 <mniip> yes
02:36:16 <mniip> see LANGUAGE
02:36:28 <bollu> ah right
02:36:40 <bollu> okay, so this is a technique that is built on top of dependant types and GADTs?
02:37:00 <mniip> dependent types aren't involved
02:37:06 <mniip> they aren't in haskell yet even
02:37:34 <bollu> mniip: DataKinds* sorry
02:37:47 <mniip> yes
02:37:56 <Ashy> is there a good example of cookie auth with servant somewhere?
02:38:26 <bollu> mniip: there are 3 moving parts here: 1. Bool     2. BoolS     3. KnownBool
02:38:40 <mniip> yes
02:38:47 <bollu> :t asPhantomOf
02:38:49 <lambdabot> Not in scope: ‘asPhantomOf’
02:38:55 <mniip> it's defined in a where-clause
02:38:59 <bollu> oh I see
02:39:13 <mniip> similar to isTrue, consider
02:39:21 <mniip> :t GHC.TypeLits.natVal
02:39:23 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
02:39:34 <mniip> where n :: GHC.TypeLits.Nat
02:39:41 <bollu> you're using it to "cast" an x into a boolSing?
02:40:12 <mniip> no
02:40:25 <mniip> just saying boolSing :: BoolS b, where b is the same b as in x
02:40:41 <eklavya> hi, I can't seem to find an up to date Cassandra driver, has anybody used cassandra in production?
02:41:12 <bollu> mniip: right, so you're using it to convert the "p b" whose structure we don't know into BoolS b so we can pattern match on it right?
02:41:30 <mniip> no
02:41:46 <mniip> the value of type 'p b' is discarded
02:41:56 <mniip> see, the implementation of asPhantomOf is const
02:42:51 <bollu> mniip: so we need the asPhantomOf to propogate the "b" into the boolSing?
02:42:56 <mniip> yes, kinda
02:43:04 <mniip> the same could be achieved using scopedtyvars
02:43:23 <mniip> this is the same mechanism as, say
02:43:29 <mniip> > pure 123 `asTypeOf` []
02:43:31 <lambdabot>  [123]
02:43:40 <mniip> asTypeOf :: a -> a -> a
02:43:43 <mniip> asTypeOf = const
02:43:44 <bollu> wait what?
02:44:56 <bollu> oh right, okay, you're forcing the pure :: f a to [a]
02:44:59 <bollu> neat
02:45:07 <bollu> > pure 123 `asTypeOf` Nothing
02:45:09 <lambdabot>  Just 123
02:45:13 <bollu> hahah, that is so cool
02:45:33 <bollu> :t asTypeOf
02:45:34 <lambdabot> a -> a -> a
02:45:44 <bollu> mniip: I don't understand the type
02:45:51 <mniip> of?
02:45:52 <deank> :t const
02:45:54 <lambdabot> a -> b -> a
02:45:55 <bollu> asTypeOf
02:46:01 <bollu> shouldn't it be something like:
02:46:12 <deank> > asTypeOf 10 20
02:46:13 <lambdabot>  10
02:46:20 <deank> > asTypeOf 10
02:46:21 <bollu> f a -> g a -> g a?
02:46:23 <lambdabot>  <Integer -> Integer>
02:46:33 <bollu> asTypeOf :: f a -> g a -> g a ?
02:46:44 <mniip> bollu, no, why?
02:46:54 <mniip> 1468143799 [12:43:19] <mniip> asTypeOf :: a -> a -> a
02:46:54 <mniip> 1468143802 [12:43:22] <mniip> asTypeOf = const
02:46:55 <bollu> because I'm converting a "pure" (f a) into a (List a) or a (Maybe a)
02:47:04 <mniip> you're not converting anything
02:47:06 <pavonia> > (pure 123 `asTypeOf` succ) 456
02:47:08 <lambdabot>  123
02:47:26 <bollu> :t Nothing
02:47:27 <lambdabot> Maybe a
02:47:29 <mniip> pavonia, could just say
02:47:31 <bollu> :t pure 123
02:47:32 <lambdabot> (Num a, Applicative f) => f a
02:47:33 <mniip> > pure 123 456
02:47:36 <lambdabot>  123
02:47:38 <bollu> mniip: tell me how the two unify
02:47:45 <mniip> bollu, f ~ Maybe
02:47:48 <mniip> a ~ a'
02:47:56 <mtesseract> Hi
02:47:57 <pavonia> Oh, right
02:48:15 <bollu> mniip: right, so I need to have two different types that can be unified right? not the "same type" ?
02:48:36 <bollu> :t pure
02:48:38 <lambdabot> Applicative f => a -> f a
02:48:45 <bollu> > pure 123 456
02:48:47 <lambdabot>  123
02:48:55 <bollu> ^ how the hell does that work? o_O
02:49:04 <mniip> f ~ ((->) e)
02:49:13 <bollu> ah okay
02:49:34 <bollu> oh my god, pure for applicative is const? right, that makes sense
02:49:34 <mniip> bollu, I'm not really sure what your question is
02:49:41 <bollu> but it's something I've never noticed
02:49:46 <bollu> okay, my question is this
02:50:30 <bollu> I don't "get" how asTypeOf works / what its doing
02:50:34 <bollu> intuitively yes
02:50:37 <bollu> but formally I don't get it
02:50:55 <deank> @src asTypeOf
02:50:55 <lambdabot> asTypeOf = const
02:51:07 <mniip> the two arguments to asTypeOf are inferred to be the same type
02:51:14 <mniip> via unification
02:51:30 <bollu> right, so why does it not work if I say
02:51:35 <bollu> > pure 123 `const` Nothing
02:51:37 <lambdabot>      No instance for (Show (f0 a0))
02:51:37 <lambdabot>        arising from a use of ‘show_M526986842148677710115440’
02:51:37 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
02:51:44 <deank> const has different
02:51:45 <bollu> but
02:51:51 <bollu> oh, a -> b -> a
02:51:54 <deank> const has different type
02:51:58 <bollu> argh, what. that's so bizzare
02:51:59 <deank> yes
02:52:00 <mniip> const has a more general type
02:53:14 <bollu> > [123] `asTypeOf` (Just 123)
02:53:16 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘Maybe Integer’
02:53:16 <lambdabot>      In the second argument of ‘asTypeOf’, namely ‘(Just 123)’
02:53:16 <lambdabot>      In the expression: [123] `asTypeOf` (Just 123)
02:53:18 <maerwald> @type pure 123 `const` Nothing
02:53:20 <lambdabot> (Num a, Applicative f) => f a
02:53:26 <bollu> [123] `asTypeOf`Nothing
02:53:31 <bollu> > [123] `asTypeOf`Nothing
02:53:33 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘Maybe a0’
02:53:33 <lambdabot>      In the second argument of ‘asTypeOf’, namely ‘Nothing’
02:53:33 <lambdabot>      In the expression: [123] `asTypeOf` Nothing
02:53:35 <petercommand> > pure (123 :: Int) `const` Nothing
02:53:37 <lambdabot>      No instance for (Show (f0 Int))
02:53:37 <lambdabot>        arising from a use of ‘show_M279535921187404596515511’
02:53:37 <lambdabot>      The type variable ‘f0’ is ambiguous
02:53:51 <bollu> right okay
02:53:51 <petercommand> > pure (123 :: Int) `asTypeOf` Nothing
02:53:53 <lambdabot>  Just 123
02:53:59 <bollu> so I need the free type variable from pure
02:54:05 <bollu> which gives me an "f a"
02:54:12 <bollu> so it can unify with Just / List / whatever
02:54:13 <bollu> I see
02:54:17 <bollu> that's really powerful
02:54:33 <bollu> mniip: be back in like 15, gonna grab some lunch. I have some real food for thought now
02:54:41 <petercommand> asTypeOf has a more restrictive type than const
02:55:22 <bollu> petercommand: yeah, got that. const :: a -> b -> a. asTypeOf :: a -> a -> a
02:55:30 <petercommand> yep
03:02:59 <lpaste> jhk pasted “fold in function arguments with $” at http://lpaste.net/169444
03:03:21 <jhk> hey guys, i have this question about ^
03:03:32 <jle`> nowadays we have explicit type application, so we won't be needing `asTypeOf` as much anymore :O
03:04:17 <jle`> jhk: yeah, you can't relaly do that with a fold, because every step of the accumulator would have a different type
03:04:54 <jhk> hmm
03:05:00 <jhk> do i need to put it inside a monad or osmething?
03:05:03 <jle`> with foldl/foldr, the accumulator has to stay the same type the entire time
03:05:27 <jle`> besides, how are you expecting things to work out, type-wise?
03:05:31 <jle`> what if you passed in a 4-item list?
03:05:36 <jle`> a 2-item list
03:05:40 <jle`> would that be a type error?
03:05:44 <jle`> or a runtime error?
03:05:55 <jhk> either I guess? 
03:06:06 <jle`> what would the type of `foldl ($) arith` be?
03:06:14 <jhk> well you are right, I need to rethink the strategy
03:06:16 <jle`> er, `\xs -> foldl ($) arith`
03:06:27 <jle`> `\xs -> foldl ($) arith xs`, that is
03:06:35 <jle`> would it return an Int?  an Int -> Int?
03:06:37 <jle`> an Int -> Int -> Int?
03:06:44 <jle`> would the type it return depend on how long the list is?
03:06:57 <jle`> doesn't really quite make sense
03:07:03 <jhk> yep
03:08:12 * hackagebot math-functions 0.2.0.1 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.2.0.1 (AlexeyKhudyakov)
03:13:28 <sbrg> is there something about printf from Text.Printf that makes it non thread safe?
03:13:52 <sbrg> because it seems that trying to use it to format log messages read from a TQueue doesn't work, while replacing the value with a constant string seems to work fine
03:17:47 <HoloIRCUser3> Does this work?
03:18:05 <pavonia> sbrg: Doesn't work in what sense?
03:18:45 <saurabhnanda> Can anyone help me with http://stackoverflow.com/questions/38289927/how-to-do-io-in-a-widget-hamlet-referenced-by-defaultlayout#
03:19:07 <sbrg> pavonia: It seems to simply hang. 
03:19:40 <sbrg> i really cba setting up a minimal reproducible test case right now, but I might later
03:19:45 <sbrg> not sure if the error is elsewhere anyway
03:19:54 <saurabhnanda> I've spent a day reading and re-reading the docs but don't seem to be making any headway. Can't seem to do simple IO in a widget
03:20:33 <saurabhnanda> Does anyone know how to inspect the final type of a TH expression?
03:21:03 <sbrg> -ddump-splices? or some such
03:21:38 <saurabhnanda> sbrg: I meant in the IDE, like emacs
03:21:51 <sbrg> ah
03:25:51 <saurabhnanda> Not possible?
03:26:24 <saurabhnanda> Type inspection results in Q something or QuasiQuotes or something like that
03:40:12 <free_beard> hi guys, I'm going trough the haskell programming book, and I hit this excercise in Applicative
03:40:14 <free_beard> http://lpaste.net/90272885347713024
03:40:28 <free_beard> I'm supposed to use <$>, <*> or pure to make summed typecheck
03:41:04 <free_beard> I don't understand how i could get (,) x y to get a Foldable f => f Integer
03:41:59 <free_beard> i could do (,) <$> x <*> y and get Just (5, 6), but then i can't sum over it
03:42:39 <free_beard> if i do (,) x y i get a (Just 5, Just 6) which I can't figure out how to alter to feed into sum
03:42:55 <free_beard> Am I missing something obvious
03:49:55 <lyxia> free_beard: you want to sum just two elements, so try to use (+).
03:50:40 <notdan> :t (+) <$> Just 5 <*> Just 6
03:50:42 <lambdabot> Num b => Maybe b
03:50:44 <notdan> > (+) <$> Just 5 <*> Just 6
03:50:46 <lambdabot>  Just 11
03:50:50 <notdan> > (+) <$> Just 5 <*> Nothing
03:50:52 <lambdabot>  Nothing
03:51:02 <sbrg> :t liftA2
03:51:04 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:51:13 <sbrg> > liftA2 (+) (Just 3) (Nothing)
03:51:17 <sbrg> > liftA2 (+) (Just 3) (Just 4)
03:51:17 <lambdabot>  Nothing
03:51:21 <lambdabot>  mueval-core: Time limit exceeded
03:51:27 <sbrg> uh...
03:51:31 <sbrg> > liftA2 (+) (Just 3) (Just 4)
03:51:33 <lambdabot>  Just 7
03:51:38 <sbrg> thought so
03:51:49 <free_beard> lyxia: that's nice and all, but I'm not sure what the exercise is trying to point out, it appears I'm supposed to use sum there
03:52:07 <free_beard> and just find a way to insert <$> <*> or pure to make it typecheck
03:52:34 <sbrg> free_beard: that's strange
03:52:49 <notdan> :t sum
03:52:51 <lambdabot> (Num a, Foldable t) => t a -> a
03:53:01 <notdan> hm
03:53:06 <sbrg> > sum (3, 4)
03:53:08 <lambdabot>  4
03:53:16 <notdan> :t pure sum
03:53:18 <lambdabot> (Num a, Applicative f, Foldable t) => f (t a -> a)
03:53:31 <free_beard> notdan: oh
03:53:39 <lyxia> free_beard: can you show us the exercise
03:54:48 <free_beard> lyxia: this is the code http://lpaste.net/90272885347713024 . let me do another paste for the instructions
03:55:12 <notdan> > sum (2,3)
03:55:14 <lambdabot>  3
03:55:25 <free_beard> http://lpaste.net/1065169322680254464
03:55:36 <notdan> oh that's the stupid product instance
03:56:25 <notdan> free_beard: where is this exercise from?
03:56:29 <notdan> if you don't mind me asking
03:56:31 <free_beard> the haskell book
03:56:45 <free_beard> haskell programming
03:56:45 <notdan> Ah, from haskellbook.com?
03:56:48 <free_beard> yeah
03:57:36 <notdan> Yeah, idk. If the goal is just to make this typecheck you can just put 'summed = fmap sum $ (,) <$> x <*> y '
03:57:56 <notdan> > fmap sum $ (,) <$> Just 3 <*> Nothing
03:57:59 <lambdabot>  Nothing
03:58:01 <notdan> > fmap sum $ (,) <$> Just 3 <*> Just 2
03:58:03 <lambdabot>  Just 2
03:58:21 <notdan> but it uses this weird foldable instance for the product type
03:58:25 <notdan> so idk
03:58:41 <bollu> mniip: ping
03:58:50 <free_beard> notdan: yeah, that should be it, I'm going to look more into it to see how you figured out that's what you should do to make it typecheck
03:58:53 <free_beard> notdan: thanks
03:58:59 <free_beard> notdan: that's surely it
03:59:06 <Gurkenglas> Is there an asAppliedTo that preserves type aliases?
03:59:20 <bollu> mniip: what is the exact goal of our example isTrue :: KnownBool b => p b -> Bool?
04:01:09 <jle`> free_beard: does the excercise really ask you to use the 'sum' function to sum over a Foldable?
04:01:15 <maerwald> :t liftA2
04:01:15 <maerwald> :t \f x y -> f <$> x <*> y
04:01:17 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:01:17 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
04:01:24 <maerwald> free_beard: it's a common idiom
04:01:57 <jle`> free_beard: using sum on a tuple is literally always the wrong thing to do
04:02:27 <mniip> bollu, downgrading a type computation to a value?
04:03:00 <jle`> free_beard: the exercise might be referring to the idea of summing two numbers, where the sum of x and y is x + y
04:03:04 <bollu> mniip: like, I'm confused about the usecase. where would we use something like isTrue?
04:03:07 <jle`> not the literal 'sum' function in Prelude
04:04:16 <mniip> bollu, null' = isTrue, for example
04:04:21 <maerwald> jle`: the exercise is about stuff typechecking
04:05:07 <bollu> mniip: but we already have an implementation of null'? what is this gicing us?
04:05:10 <bollu> giving*
04:09:50 <bollu> mniip: as far as I understand
04:09:54 <shachaf> jle`: The exercise is using the function "sum".
04:10:08 <shachaf> I suspect that it's just sloppy or badly written.
04:10:13 <bollu> mniip: the isTrue function is letting us "extract" the value of the boolean-like type "b" in (p b) right?
04:10:28 <shachaf> Just like many other things in that book.
04:10:53 <bollu> shachaf: isn't the book well written? a lot of people seem to be raving about i
04:10:54 <bollu> it*
04:11:06 <mniip> bollu, extract in the form of a value
04:11:24 <bollu> shachaf: I was actually think of picking it up (preordering) as a gift for a friend who wants to get into haskell.
04:11:28 <bollu> mniip: right
04:11:43 <shachaf> bollu: I don't recommend it, based on everything I've seen of that book.
04:12:23 <bollu> mniip: can't I do something like class Booleanable b  where booleanable :: b -> Bool. Then say is True :: Booleanable b => p b -> Bool??
04:12:27 <bollu> mniip: why do I need the singleton type?
04:12:42 <bollu> mniip: oh wait, I just re-created 2/3 of your solution
04:12:52 <bollu> okay, but I don't get why we need the singleton type
04:12:57 <bollu> shachaf: oh okay, thank you!
04:13:15 <shachaf> It's at best sloppy and wrong in many places.
04:17:15 <mniip> bollu, but then b :: *
04:17:17 <mniip> not Bool
04:18:32 <bollu> mniip: okay, so we're using the singleton to restrict the kind of b?
04:18:38 <bollu> can't datakinds do that already?
04:23:14 * hackagebot gloss-rendering 1.10.3.1 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.3.1 (BenLippmeier)
04:43:58 <sbrg> wish I had known about brick earlier, makes writing TUIs really easy!
04:48:54 <srhb> sbrg: Isn't it really new?
04:49:59 <sbrg> srhb: is it? I have no idea. I haven't seen it before, so you may be right
04:53:23 <cocreature> it’s at least a few months old
04:56:25 <ggVGc> that's pretty new I'd say
05:07:25 <saurabhnanda> Any  help with http://stackoverflow.com/questions/38289927/how-to-do-io-in-a-widget-hamlet-referenced-by-defaultlayout# please?
05:19:09 <newcomer> Quick question, can't one use let expression inside a do block? (not the special let statement in do notation)
05:20:32 <barrucadu> You can use normal lets inside a do block
05:21:13 <barrucadu> But "do ...; let foo = bar in baz; ..." is equivalent to "do ...; let foo = bar; baz; ...", so what's the point of using the normal form?
05:21:38 <barrucadu> No, it's not equivalent. Ignore me.
05:21:45 <barrucadu> Scope for 'foo' is way different.
05:25:49 <newcomer> barrucadu, The thing is that I want to define a function foo with scope including identifiers defined on previous lines inside the do block.
05:25:54 <newcomer> "where" doesn't help.
05:26:25 <srhb> newcomer: Yes, how is that causing you troubles? :)
05:27:15 <newcomer> srhb, "where" at the end of the do block doesn't "see" identifiers defined in the do block.
05:27:27 <srhb> newcomer: Right, but why not just use another let for the function?
05:27:30 <srhb> Or the same let block
05:29:00 <srhb> >  do { let { a=2; f x = x*a}; f 42 }
05:29:02 <lambdabot>  84
05:29:07 <srhb> Is this what you're asking?
05:29:17 <newcomer> srhb, yes, got it.
05:29:22 <srhb> :)
05:45:11 <newcomer> So I'm learning how to use IORef, so I wrote this. Is there a better way to do it? Code critique please.
05:45:12 <newcomer> http://lpaste.net/169446
05:46:35 <magneticduck> newcomer: the best way to use IORef is to silently not use it
05:47:11 <magneticduck> there are a few hundred better ways to write that code without IORef
05:47:33 <magneticduck> in Haskell a good rule of thumb is to keep as much code as you can pure
05:47:45 <magneticduck> express your program as a set of coordinated pure functions
05:47:54 <magneticduck> have you learned about Monads and MTL yet?
05:48:51 <newcomer> magneticduck, I wanted to exercise using IORef. So it was intentional.
05:50:15 <newcomer> magneticduck, I wouldn't have wrote those lines if I hadn't learned about Monads. I'm sure there're better ways to do it. I'm not sure what they are :)
05:51:08 <magneticduck> maybe you should exercise your understanding of IORefs by finding a situation where they're necessary
05:51:26 <magneticduck> right now you built a house out of jello and are asking if there is a better way of doing it ^^
05:51:49 <newcomer> Haven't heard of MTL module, although I'm sure I used some of its modules before.
05:52:07 <newcomer> magneticduck, OK.
05:52:12 <Clint> newcomer: line 15 looks nicer as n <- read `fmap` getLine
05:52:36 <newcomer> Clint, right! :)
05:52:49 <magneticduck> if we're just talking about code style, I'd also suggest using a seperate definition for doit
05:52:59 <lyxia> I'd write doit with for_
05:53:16 <newcomer> lyxia, will look into it.
05:53:38 <magneticduck> also you should restrict the scope of 'a'
05:53:56 <lyxia> putStrLn . show is print
05:53:56 <magneticduck> you're using variables like a C programmer!
05:54:01 <newcomer> magneticduck, yes, maybe the first version of doit. The second version needs to be in scope.
05:54:18 <newcomer> lyxia, OK.
05:54:39 <lyxia> read `fmap` getLine is readLn
05:54:42 <magneticduck> right, I had already mentally shifted doit to the outer scope
05:57:53 <newcomer> lyxia, Clint: Thanks for the fmap and readLn hints.
05:58:27 <newcomer> magneticduck, How would I do the same thing purely?
05:59:50 <magneticduck> newcomer: basically, change IORef Int to Int
06:00:11 <magneticduck> instead of modifying it and passing it, just pass a modified version of it
06:00:18 <magneticduck> instead of returning its read value, just return it
06:00:34 <magneticduck> that's the first pass
06:01:32 <magneticduck> then you might consider using a monad transformer -- a single iteration of doit is a function (State, Input) -> (State, Output), which is isomorphic to the RWS monads
06:02:34 <magneticduck> I'd also suggest encapsulating the idea of user interaction in construct more concise than IO'
06:02:46 <newcomer> magneticduck, Oh, I learned that trick (passing the "mutable" variable as an argument) from SICP. It just skipped my mind.
06:03:11 <magneticduck> it sounds like you need to forget about IORefs for a little bit ^^
06:03:33 <magneticduck> they're really only useful for some complex asynchronous programming .. sometimes not even then
06:03:45 <magneticduck> (perhaps there are other use cases, I can't think of any currently)
06:05:08 <newcomer> magneticduck, LOL, yes. It's just in my attempt to survey Haskell, I decided to go through all mutability/state techniques. The plane was to go through IORef, State Threads (ST) monad, State monad and those TVar and Mvar (not sure what the latter couple of things are).
06:05:22 <newcomer> s/plane/plan
06:06:07 <magneticduck> as a 'newcomer', the only mutable state techniques you should be concerned with are ones that you can express purely
06:08:10 <newcomer> The word pure is confusing to me in this context. I thought all functions in Haskell are pure, even those returning IO actions. Since they are returning those actions and not actually executing them.
06:08:47 <maerwald> newcomer: yeah, all haskell functions are pure during evaluation. Some think of "evaluation AND execution" when they talk about purity
06:08:52 <maerwald> which I find a moot point, but well
06:09:04 <magneticduck> right, by 'pure' I mean, not having anything to do with IO or ST
06:09:32 <magneticduck> under the other definition of pure, every function in Haskell is pure -- so it's a useless term
06:09:43 <magneticduck> naturally I'm going to use the definition that confers more information to my words ^^
06:12:25 <newcomer> maerwald, magneticduck: Got it.
06:13:45 <magneticduck> even when your program is dealing with databases and missle launches and flux capacitors, the logical core of your program should be 'pure' -- its execution should not inherently have side-effects 
06:14:23 <magneticduck> as a general rule, you should always use the weakest constructs that satisfy the expressive needs of each part of your program
06:14:39 <magneticduck> this makes code easier to understand, test, manipulate, optimize, and express clear ideas about
06:14:44 <maerwald> How can execution be pure anyway? You shove stuff into the RTS which may do kernel calls you don't even know about during stuff or write to temporary files, mess with internal memory or whatnot.
06:14:57 <magneticduck> well technically no execution is pure
06:15:32 <magneticduck> a 'pure process' is something that has very little observable impact on other parts of the code 
06:15:44 <magneticduck> (and absolutely no observable impact on other pure parts of the code)
06:15:50 <maerwald> I think "pure" is a wildly misused term, when it's really about the ability of reasoning about functions in general. Whether IO is pure or not doesn't matter. It's hard to reason about IO code.
06:17:14 <magneticduck> I'd say purity is a property of a construct
06:17:26 <magneticduck> an IO process can potentially be as pure as a pure function -- but the idea of IO is not pure
06:17:32 <magneticduck> that sounds reasonable
06:18:17 * hackagebot lambdacube-gl 0.5.1.0 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.1.0 (CsabaHruska)
06:19:38 <ertes> intuitive vs. formal
06:19:41 <maerwald> magneticduck: I think purity mainly is something the compiler is interested in, so it knows what can be done and what not. You can achieve similar things in C even with some compiler macros like __pure__.
06:19:42 <magneticduck> hm, formally a 'pure' algorithm or programming language is something rather different
06:20:10 <ertes> formally it isn't really anything, or at least nothing interesting in haskell terms
06:20:10 <maerwald> it just happens that __pure__ is the default in haskell, unless you use evil things like unsafePerformIO
06:20:33 <maerwald> so the compiler just assumes stuff and does it
06:21:32 <magneticduck> I think I'll stop saying pure and start using more general terms like 'restricted' or 'weak'
06:22:31 <enthropy> "lack of side effects" / "allowing equational reasoning"?
06:22:41 <ertes> i think purity is a marketing term, and the fact that you're trying to give it meaning is proof that it works =)
06:22:43 <maerwald> We can write 10k LOC of haskell where every function ends with "-> IO foo" and call our program pure. But that isn't really useful.
06:22:57 <notdan> pure-ish
06:23:13 <notdan> "n computing, an algorithm, data structure, or programming language is called purely functional if they guarantee the (weak) equivalence of call-by-name, call-by-value and call-by-need evaluation strategies." https://en.wikipedia.org/wiki/Purely_functional
06:23:43 <notdan> https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps
06:25:09 <maerwald> yeah, I think it's a rather scientific term that isn't that useful for the regular programmer to describe stuff
06:26:10 <notdan> hm, yeah, in addition to the fact that call-by-value and call-by-name are observationaly different in Haskell
06:26:48 <alercah> notdan: what do you mean?
06:27:15 <enthropy> strictness?
06:27:27 <magneticduck1> notdan: I wouldn't say that definition is 'too formal' for Haskell programmers
06:28:07 <maerwald> maybe not, but if you'd follow that definition, you'd use the term "pure" a lot les ;)
06:28:20 <magneticduck1> the issue with my usage of the term is that, since in Haskell everything is pure, I judge a sort of corrupted purity
06:28:41 <magneticduck1> IO is 'impure' because, if you unwrapped IO in normal code, it would in fact be impure 
06:29:03 <maerwald> > return 3 :: IO Int
06:29:05 <lambdabot>  <IO Int>
06:29:08 <maerwald> is that pure or not?
06:29:36 <maerwald> sure, it must be executed, but...
06:30:38 <magneticduck1> the program is impure; the language is pure; 'putStrLn "hello" >> putStrLn " world"' would be impure if it were allowed to be evaluated arbitrarily at any point of the program
06:31:11 <maerwald> well, then there are exactly 0 haskell programs that are pure, because main is always IO
06:31:43 <magneticduck1> by 'program' I mean the compiled program
06:31:53 <magneticduck1> heh
06:32:10 <magneticduck1> anyway this seems fairly pointless
06:32:32 <magneticduck1> we agree on what pure formally means, and I haven't been able to find a good formulation of what my corrupted idea of 'purity' meant
06:32:34 <maerwald> exactly, what is not pointless however is to say "it's rather hard to reason about IO code in general"
06:32:51 <ertes> magneticduck1: the usual notion of purity makes only stuff like unsafePerformIO impure
06:33:03 <ertes> even getLine is pure by that one
06:33:12 <notdan> alercah: i mean if you pass an undefined value, then cbv & cbn strategies yield different results
06:33:15 <magneticduck1> yes, I agree on the formatl definition of purity
06:33:36 <magneticduck1> which defines Haskell minus things like unsafePerformIO to be a pure language
06:33:39 <notdan> alercah: but that wikipedia page is not that well-written, i think. the article i linked to elaborates on the matter 
06:33:40 <ertes> note: i said "notion", not "definition"…  purity is hard to define
06:34:04 <maerwald> ertes: you'd need a pure language to define it xD
06:34:22 <magneticduck1> I think the wikipedia page did a pretty good job
06:34:53 <notdan> well, as i said, it omits some important stuff - like non-termination
06:35:14 <notdan> under the formulation on that page, a programming language with non-termination basically cannot be 'pure'
06:35:37 <magneticduck1> my connection blipped out, I might have missed what you said
06:35:39 <magneticduck1> that's interesting
06:36:45 <notdan> Amr Sabry's paper gives a concrete definition of purity that seem to work somewhat better than the conventional ones http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps
06:50:18 <BorisA> hi, all
06:58:19 * hackagebot lambdacube-gl 0.5.1.1 - OpenGL 3.3 Core Profile backend for LambdaCube 3D  https://hackage.haskell.org/package/lambdacube-gl-0.5.1.1 (CsabaHruska)
07:08:32 <daey> why does ++ require the element to be wrapped into [] but : doesnt? i.e. 1:[] vs [] ++ [1]
07:09:57 <lipkab> daey: ++ concatenates two lists while : prepends an element to a list.
07:10:24 <lipkab> By wrapping an element in [], you make it a list, concatenatable by ++.
07:10:39 <daey> so even though their effect is similar, they are something totally different?
07:10:47 <lipkab> Yes.
07:13:18 <oherrala> :t (:)
07:13:19 <lambdabot> a -> [a] -> [a]
07:13:22 <oherrala> :t (++)
07:13:23 <lambdabot> [a] -> [a] -> [a]
07:14:09 <daey> that syntax still bothers me. i view it more like ([a] [a]) -> [a] two inputs being merged into one*
07:14:22 <bjs> daey: so (:) prepends an element to the list
07:14:37 <daey> yes i know what it does
07:14:50 <oherrala> daey: In Haskell, the function can take only one parameter at a time :)
07:14:58 <daey> ah i see
07:15:33 <oherrala> :t (:) 1
07:15:34 <lambdabot> Num a => [a] -> [a]
07:15:42 <daey> i stumbled across the question when i tried to match all but the last of a list. e.g. i can match the first with head' (x:_) but how would i match, all but the last?
07:16:45 <oherrala> > init [1,2,3]
07:16:47 <lambdabot>  [1,2]
07:16:56 <oherrala> like that?
07:16:59 <daey> well if i wanted to write it myself :p
07:17:12 <daey> but yes, lik ethat
07:17:15 <oherrala> use pattern match like (x:[])
07:17:24 <oherrala> x is the second last element and [] being end of list
07:18:20 <oherrala> ah, sorry (x1:x2:[]) where x1 is second last, x2 is last
07:18:21 <ertes> x is the last element there
07:18:32 <bjs> daey: i mean you can match like [x, y, _] if you know the length
07:18:35 <oherrala> I got myself confused with cons cells =)
07:19:10 <bjs> daey: in pattern matching anyway
07:19:19 <ertes> to match all but the last:  f xs | PATTERN <- init xs  -- but note that 'init' is unsafe
07:19:22 <ertes> i think
07:19:25 <ertes> > init []
07:19:27 <lambdabot>  *Exception: Prelude.init: empty list
07:19:29 <daey> well i was thinking init' (x++[_]) = x
07:19:29 <ertes> yeah, unsafe
07:19:32 <daey> which doesnt work
07:19:54 <ertes> daey: haskell has no logic solver like prolog, so you can't do that
07:20:08 <ertes> but you can get pretty far with pattern guards as above
07:20:17 <ertes> f [] = _emptyCase
07:20:36 <ertes> f xs | PATTERN <- init xs = _nonEmptyCase
07:21:25 <barrucadu> Oh neat, I didn't know about pattern guards
07:21:44 <bjs> barrucadu: me neither
07:22:39 <daey> aren head, tail also unsave?
07:22:48 <ertes> they are
07:22:51 <daey> ok
07:23:25 <bjs> daey: yeah, there are a few partial functions in prelude
07:23:27 <bjs> :t head
07:23:29 <lambdabot> [a] -> a
07:23:31 <boj`> there's a library named "safe" which gives better alternatives
07:23:57 <ertes> you can just use 'foldr' most of the time
07:24:16 <ertes> > foldr (\x _ -> show x) "none" [1,2,3]
07:24:18 <lambdabot>  "1"
07:24:20 <ertes> > foldr (\x _ -> show x) "none" []
07:24:21 <lambdabot>  "none"
07:25:15 <barrucadu> listToMaybe is also very handy
07:25:39 <barrucadu> > (listToMaybe [], listToMaybe [1,2,3])
07:25:41 <lambdabot>  (Nothing,Just 1)
07:30:28 <saurabhn_> can anyone help me grok this type? Control.Monad.IO.Class.MonadIO ((->) t) => t -> Text.Blaze.Internal.MarkupM ()
07:31:21 <saurabhn_> here's the function which is resulting in this type, if it helps: 
07:31:23 <saurabhn_> nav = do
07:31:23 <saurabhn_>   globalStat  <- liftIO $ A2.getGlobalStat NWT.ariaRPCUrl
07:31:23 <saurabhn_>   $(hamletFile "templates/navbar.hamlet")
07:31:56 <dysfun> (->) is the type of a function, which is applied to t and is MonadIO
07:33:20 * hackagebot HGE2D 0.1.6.0 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.6.0 (I3ck)
07:34:31 <ertes> saurabhn_: it probably means you're missing an argument somewhere
07:35:01 <saurabhn_> ertes: I'll be damned!
07:35:48 <saurabhn_> ertes: so much of grokking for a missed argument!
07:36:49 <ertes> show sin  -- no instance for Show ((->) a), because the compiler thinks you're trying to "show" a function
07:37:05 <ertes> when in reality you probably just failed to write "show (sin 3)"
07:38:50 <saurabhn_> hmm, not so simple in my case, I guess. Lot of type inference going on with bootloads of monad transformers involved
07:39:55 <saurabhn_> there should be an easier way to see TH output. On the lines of macro-expand in Lisp
07:40:38 <saurabhn_> nav = $(hamletFile "templates/navbar.hamlet")  // nav :: t -> Text.Blaze.Internal.Markup
07:41:12 <ertes> the trouble is, firstly, that liftIO (the only function of MonadIO) *results* in something that looks like a function
07:41:19 <ertes> so it may well be an argument *too much*
07:41:33 <saurabhn_> and when 
07:41:33 <ertes> the second trouble is, you don't see all the code, because some of it is hidden by TH
07:41:36 <saurabhn_> nav = do
07:41:37 <saurabhn_>   globalStat  <- liftIO $ A2.getGlobalStat NWT.ariaRPCUrl
07:41:37 <saurabhn_>   $(hamletFile "templates/navbar.hamlet") 
07:41:54 <saurabhn_> nav :: Control.Monad.IO.Class.MonadIO ((->) t) => t -> Text.Blaze.Internal.Markup
07:42:31 <saurabhn_> ertes: I tried -ddump-splices but the output is too low-level. Don't know how to grok it. Seems like some intermediate language to me
07:42:40 <ertes> you should probably ask in #yesod
07:42:56 <saurabhn_> let me try
07:43:22 <ertes> it's been a very long time since i last used yesod, but the usage of hamletFile there looks wrong to me…  i'm pretty sure it results in a function
07:43:50 <saurabhn_> ertes: what are you using instead of yesod now?
07:44:06 <ertes> i don't do much web dev now, but when i do, i use snap
07:45:57 <saurabhn_> hmm, I should probably look at it. Yesod seems to be too complicated. i'm not sure what all these types and monad transformer stacks are really buying me in terms of program correctness.
07:46:15 <saurabhn_> is michael snoyman on IRc?
07:48:20 * hackagebot mono-traversable 1.0.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.0.1 (MichaelSnoyman)
07:53:27 <the_2nd> Can someone tell me, why this build on hackage fails? : https://hackage.haskell.org/package/HGE2D-0.1.6.0/reports/1
07:55:08 <oherrala> the_2nd: because base < 4.9 restriction
07:55:35 <the_2nd> but why do the tries on base 4.8 after that fail too?
07:55:46 <the_2nd> looks to me like the server tried those as well
07:56:05 <oherrala> base is part of GHC so it probably can't downgrade it
07:56:30 <the_2nd> so should I try to port to ==4.9 ?
07:57:21 <oherrala> just lift the restriction and see what happens
07:59:39 <the_2nd> now I get the same error as the server locally
08:00:12 <the_2nd> 4.8.2 gets rejected, afterwards all other are rejected as well (including 4.9)    [when setting base ==4.9]
08:01:56 <glguy> The isn't a base 4.9
08:02:02 <glguy> There*
08:02:21 <glguy> There is only a 4.9.0.0
08:02:32 <the_2nd> rejecting base 4.9.0.0     but i'll try >= 4.9 < 5.0
08:03:04 <glguy> In the magic of Haskell version numbers X is less than X.0
08:05:51 <glguy> Similarly there isn't a base-4.8.2
08:06:50 <hpc> doesn't 4.9 = 0.0.4.9?
08:06:59 <glguy> No
08:07:06 <the_2nd> seems like im running on base 4.8.2.0
08:07:07 <hpc> oh, they're just totally different
08:07:11 <the_2nd> how can I upgrade?
08:07:31 <glguy> You upgrade base by installing a different version of GHC
08:15:01 <ontop> Is the best way to clean up a gigantic nested list comprehension do syntax?
08:15:40 <hpc> there is an automatable translation between do-notation and list comprehensions, so it could potentially be a good first start
08:15:50 <hpc> it might make it easier to see how you can refactor things
08:16:03 <ontop> The line is just super long
08:16:07 <ontop> And I have to add more crap to it
08:16:15 <oherrala> hmmh, GHC doesn't work with OpenBSD's W^X protection
08:17:04 <oherrala> ontop: you can also write list comprehension in multiple lines
08:17:14 <ontop> Yeah. But it's so awful looking if I do that :(
08:17:18 <ontop> Unreadable even.
08:17:57 <ontop> Also, can someone tell me why Haskell programmers put , in front of everything instead of behind like everything else? Is there a good reason for it or is it a curly braces on the next line sort of thing?
08:18:24 <hpc> i believe it's for line editing
08:18:27 <hpc> if you do something like
08:18:30 <hpc> ( x
08:18:31 <hpc> , y
08:18:32 <hpc> )
08:18:33 <Hafydd> ontop: (1) not all Haskell programmers do that, and (2) because they have bad taste.
08:18:42 <hpc> you can copy-paste the ", y" line over and over
08:18:52 <hpc> it's... not worth uglying your code for
08:18:54 <ontop> Hafydd: lol.
08:19:25 <ontop> I thought it was a convention because I see it in the .cabal file.
08:19:27 <Hafydd> (And I've seen it in other languages besides Haskell.)
08:19:56 <mjrosenb> IMO, it makes *perfect* sense when talking about the '|' that lives between guard patterns, and ctor definitions.
08:19:57 <hpc> i personally prefer the perl way, where you can just put trailing commas on everything
08:20:05 <hpc> (
08:20:08 <hpc>  x,
08:20:09 <hpc>  y,
08:20:10 <hpc> )
08:20:19 <hpc> or something like that
08:20:20 <ontop> hpc: Go does the same, I really appreciate it. lol.
08:20:40 <Ashy> i like the leading commas for the lazy copy/pasting mentioned above
08:20:40 <maerwald> first time I see that perl does something right
08:21:12 <mjrosenb> Is there any library to generate graphs in a window? kind of like matplotlib.
08:21:13 <maerwald> Ashy: you get mixed results for sorting in your editor though
08:21:16 <hpc> perl also has better lexical scoping than python and javascript
08:21:19 <hpc> :P
08:21:25 <Hafydd> ontop: unfortunately, it's quite deeply rooted; for example, this is the "official" style guide of haskell.org: https://github.com/chrisdone/haskell-style-guide
08:21:30 <mjrosenb> maerwald: it breaks tuple sections though :-(
08:21:33 <ontop> http://lpaste.net/5809810546291113984 <- How can I rewrite this with do syntax? I can't figure out where to put my actual function calls there.
08:22:23 <hpc> tuple sections aren't standard, and i imagine it wouldn't be hard to restrict trailing commas to just the syntactic lists
08:22:31 <hpc> tuple sections require parens so they're easy to distinguish
08:23:37 <hpc> it's probably not really the right thing to add to haskell anyway though
08:23:49 <hexagoxel> ontop, hpc, Hafydd: http://lpaste.net/169461
08:24:20 <hpc> 3
08:24:49 <Hafydd> Nobody would actually write code like that.
08:24:54 <newcomer> This is the best I can do, is there a more elegant way to do it? http://lpaste.net/169462
08:25:37 <ontop> hexagoxel: My face hurts :D
08:25:43 <hexagoxel> Hafydd: s/nobody/hexagoxel/
08:26:00 <hpc> hexagoxel: was i right?
08:26:09 <Hafydd> hexagoxel: didn't you change the positions of the commas to make your point?
08:26:46 <hexagoxel> annotated how the code really looks. with "prefix" commas.
08:26:50 <hexagoxel> Hafydd: yes.
08:26:54 <ontop> IMHO the appropriate thing to do here is not to change comma positions. But refactor this code completely.
08:26:56 <ontop> Sorry :D
08:26:59 <Hafydd> hexagoxel: then you don't write code like that.
08:27:02 <ontop> ^
08:27:31 <Hafydd> It would probably be better written as: [item1, item2, item3] where item1 = ...; item2 = ...; item3 = ...
08:27:53 <Hafydd> (If it's in a context where "where" is legal.)
08:28:16 <hexagoxel> Hafydd: i was assuming you referred to the code beyond the prefix/postfix comma modification, which was my entire point.
08:28:21 * hackagebot atom-conduit 0.3.1.2 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.3.1.2 (koral)
08:28:47 <ontop> Any help with http://lpaste.net/5809810546291113984 from list comprehensions to do syntax? :(
08:28:55 <ontop> I'm stumped.
08:29:19 <Hafydd> hexagoxel: I was referring to the exact code you posted, which was part of a straw man argument.
08:30:23 <Eduard_Munteanu> ontop, what about it?
08:30:30 <Rotaerk> hmm is there a good way to learn the gtk, webkitgtk, and ghcjs-dom libraries?
08:30:36 <int-e> newcomer: that will look odd when it asks for the 11th, 12th or 13th number. but I think the last version is quite Haskell-ish.
08:30:46 <Rotaerk> the documentation is just this giant soup of functions and types, and it's hard to know where to start
08:31:16 <ontop> Eduard_Munteanu: I don't actually know how to do it. I want to rewrite it using do syntax, but because of the functions in there I don't know how.
08:31:37 <Rotaerk> it took me a while just to figure out how to use the events (found a stray example that uses `on`, but that doesn't appear to even be defined in gtk3 ...)
08:32:14 <Eduard_Munteanu> @undo [ f x | x <- xs, c x ]
08:32:14 <lambdabot> concatMap (\ x -> if c x then [f x] else []) xs
08:32:48 <hexagoxel> Hafydd: sure, declare my perhaps weak reasoning for my usage of prefix comma as straw man. it is all opinion. nevermind. you win.
08:33:21 * hackagebot HGE2D 0.1.6.1 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.6.1 (I3ck)
08:34:50 <Eduard_Munteanu> ontop, do you understand the list monad? Start by rewriting the inner list, e.g. row <- rows; ...
08:35:06 <ontop> Eduard_Munteanu: I think I don't understand it. I think I should understand it better :(
08:35:35 <Eduard_Munteanu> > do { x <- [1,2,3,4]; return (x * 2) }
08:35:36 <lambdabot>  [2,4,6,8]
08:36:02 <Eduard_Munteanu> > do { x <- [1,2,3,4]; guard (odd x); return (x * 2) }
08:36:04 <lambdabot>  [2,6]
08:36:38 <Eduard_Munteanu> > [ x * 2 | x <- [1,2,3,4], odd x ]
08:36:40 <lambdabot>  [2,6]
08:36:45 <quisquous> @Rotaerk I came across this the other day, not sure if it helps: https://www.stackbuilders.com/tutorials/haskell/gui-application/
08:36:45 <lambdabot> Unknown command, try @list
08:37:12 <Rotaerk> quisquous, hmm, thanks
08:37:27 <Eduard_Munteanu> ontop, does the above make sense to you?
08:39:47 <ontop> Somewhat, yes. Except for the guard thing.
08:40:07 <Eduard_Munteanu> :t guard
08:40:08 <lambdabot> Alternative f => Bool -> f ()
08:40:36 <ontop> Returns a unit wrapped in an Alternative?
08:40:43 <Eduard_Munteanu> guard checks the condition and fails the monadic computation if it's false.
08:40:45 <hpc> > guard False :: [()]
08:40:47 <lambdabot>  []
08:40:49 <hpc> > guard True :: [()]
08:40:51 <ontop> Ah.
08:40:52 <lambdabot>  [()]
08:41:29 <Eduard_Munteanu> Alternatively, guard :: MonadPlus m => Bool -> m ()
08:42:11 <newcomer> int-e, Thanks. I'll just modify showOrdinalInt. Anyway, is there another way to do it using replicateM, forM, sequence_, for_ ? It's that all those sequencing functions are confusing.
08:42:44 <newcomer> what's the difference between forM and mapM. can one say that mapM = flip forM?
08:42:55 <Eduard_Munteanu> newcomer, yes
08:43:26 <newcomer> Eduard_Munteanu, Thanks.
08:43:32 <Eduard_Munteanu> newcomer, it's just more convenient for do syntax, e.g.  forM xs $ \x -> do { ... }
08:45:00 <Eduard_Munteanu> (it looks like a for loop)
08:45:12 <ontop> Eduard_Munteanu: I'm going to have to desugar into lambda syntax to figure out how that's working. <- really messes me up.
08:46:06 <Eduard_Munteanu> > [1,2,3,4] >>= \x -> guard x >> return (x * 2)
08:46:08 <lambdabot>      No instance for (Num Bool) arising from the literal ‘1’
08:46:08 <lambdabot>      In the expression: 1
08:46:08 <lambdabot>      In the first argument of ‘(>>=)’, namely ‘[1, 2, 3, 4]’
08:46:28 <Eduard_Munteanu> Er.
08:46:33 <Eduard_Munteanu> > [1,2,3,4] >>= \x -> guard (odd x) >> return (x * 2)
08:46:35 <lambdabot>  [2,6]
08:47:28 <ontop> Hm.
08:47:32 <ontop> Intense.
08:47:49 <ontop> I find it interesting that it can "cancel" the monadic computation
08:47:52 <ontop> But continue the rest of them
08:48:21 <Eduard_Munteanu> Yeah, it's something more than just a monad, it's a monad with failure.
08:48:36 <ontop> "Alternative" you mean?
08:48:55 <Eduard_Munteanu> Alternative is for Applicative, it's MonadPlus for Monad.
08:50:16 <Eduard_Munteanu> ontop, might be simpler to consider Maybe.
08:50:26 <Eduard_Munteanu> mzero :: Maybe Int
08:50:29 <Eduard_Munteanu> > mzero :: Maybe Int
08:50:31 <lambdabot>  Nothing
08:50:55 <Eduard_Munteanu> > Nothing `mplus` Just 3 `mplus` Just 5
08:50:57 <lambdabot>  Just 3
08:51:33 <Eduard_Munteanu> > guard (5 < 2) :: Maybe Char
08:51:34 <lambdabot>      Couldn't match type ‘()’ with ‘Char’
08:51:35 <lambdabot>      Expected type: Maybe Char
08:51:35 <lambdabot>        Actual type: Maybe ()
08:51:42 <Eduard_Munteanu> > guard (5 < 2) :: Maybe ()
08:51:44 <lambdabot>  Nothing
08:51:57 <ontop> Ah, maybe also has an Alternative instance?
08:52:07 <Eduard_Munteanu> Yeah.
08:52:21 <Eduard_Munteanu> :t mplus
08:52:23 <lambdabot> MonadPlus m => m a -> m a -> m a
08:52:29 <Eduard_Munteanu> :t (<|>)
08:52:30 <lambdabot> Alternative f => f a -> f a -> f a
08:53:22 * hackagebot servant 0.8 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.8 (SoenkeHahn)
08:53:24 * hackagebot servant-server 0.8 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.8 (SoenkeHahn)
08:53:26 * hackagebot servant-client 0.8 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.8 (SoenkeHahn)
08:53:28 * hackagebot servant-docs 0.8 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.8 (SoenkeHahn)
08:53:30 * hackagebot servant-foreign 0.8 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.8 (SoenkeHahn)
08:58:32 * hackagebot servant-js 0.8 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.8 (SoenkeHahn)
08:58:34 * hackagebot servant-mock 0.8 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.8 (SoenkeHahn)
09:02:55 <maerwald> I just realized how difficult imperative index-based for-loop code is, after looking at some algorithmic code again. I feel like haskell made me unlearn that.
09:04:15 <monochrom> yes usually imperative code needs more comments to tell you apart the purpose from the accidental details
09:04:49 <monochrom> plus they have to do loop fusion by hand, so they need comments to tell you that, too.
09:04:50 <unclechu> maerwald, anyone who says that functional code is hard to understand just didn't write enough function code to realize that imperative code stronger than just helloworld is completely ununderstandable
09:08:35 <kqr> does anyone know of a really good tutorial on conduit? I always forget how it works, because I don't use it enough, because I don't quite know it well enough to know when to use it...
09:16:05 <catsup> is there a library that contains something like the MVar example code 'skip channel' ( https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-MVar.html ) ?  because basically i need exactly that code but i'd prefer not to paste it if unnecessary
09:28:23 * hackagebot generic-deriving 1.10.6 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.6 (ryanglscott)
09:30:50 <Herzschlag> :D
09:33:23 * hackagebot ref-tf 0.4.0.1 - A type class for monads with references using type families.  https://hackage.haskell.org/package/ref-tf-0.4.0.1 (GeoffreyMainland)
09:36:50 <Herzschlag> Hey
09:37:17 <Herzschlag> Is there anybody here ? : D  any active individual 
09:37:21 <Herzschlag> : D
09:38:23 * hackagebot dead-code-detection 0.8.1 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.8.1 (SoenkeHahn)
09:42:08 <kaol> Herzschlag: Many are, but there's not much to say unless someone starts a Haskell discussion.
09:43:15 <Herzschlag> Kaol, Ehem forgive my ignorance what is a haskell convo
09:43:25 <Rotaerk> a conversation about haskell?
09:43:41 <Herzschlag> This channel was recommended by ops
09:44:05 <Rotaerk> ops?
09:44:09 <Herzschlag> Rot ehem I'm totally lost
09:44:20 <Herzschlag> What's hashkell
09:44:22 <kaol> Haskell is a programming language.
09:44:24 <magneticduck1> enter '/topic'
09:44:42 <Xe> what you used to get in until stack was written
09:44:51 <monochrom> I disbelieve "recommended by ops".
09:45:37 <Herzschlag> Mono.. Sir I don't really care about your beliefs 
09:45:44 <Herzschlag> Magnetic thank you 
09:51:30 <magneticduck1> (I'm curious how that conversation with the 'op' went)
09:57:19 <geekosaur> at a guess that means they asked in #freenode and someone did a channel list
10:19:30 <isberg> How would I pretty print the structure  of value on haskell? Currently, show is just printing everything on one line
10:19:47 <benzrf> try :f
10:20:32 <isberg> :f?
10:21:50 <EvanR> isberg: ive had success with this package https://hackage.haskell.org/package/GenericPretty
10:22:49 <EvanR> :f doesnt seem to do anything
10:23:25 * hackagebot HGE2D 0.1.6.2 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.6.2 (I3ck)
10:23:52 <monochrom> :f could mean: :forward, :force
10:24:16 <isberg> EvanR Thanks!
10:26:58 <isberg> I would be enough if it was possible to tell "show" how deep it should go when applying it to a value
10:27:56 <troydm> I have some rly huge lazy list and I use mapM_ which iterates over that list inserting data into database
10:28:11 <troydm> now the problem is that memory usage of the application goes very high 
10:28:20 <troydm> and the subsequently goes lower 
10:28:32 <isberg> I.e:  "type CDecl = CDeclaration NodeInfo", "show value 1" would only render "CDecl value" 
10:28:38 <EvanR> isberg: thats a pretty specific refinement to Shows awful functionality... I would just shoot for a better pretty printer entirely
10:28:38 <isberg> Is this possible some show? 
10:28:50 <troydm> mapM_ call is the last call inside a monadic block so I guess previously read values aren't save
10:28:54 <troydm> *saved
10:29:01 <EvanR> isberg: it is if you write your own show function based on show
10:29:16 <troydm> how can I optimize memory usage as clearly this application shouldn't use so much memory
10:29:33 <troydm> do hugeList <- action
10:29:36 <isberg> EvanR How can I deconstruct the value without having to mach against every possible constructor? 
10:29:42 <troydm>    mapM_ saveToDb hugeList
10:29:53 <troydm> something like that
10:30:06 <EvanR> troydm: so your list doesnt seem that lazy...
10:30:12 <monochrom> "hugeList <- action" doesn't strike me as a way to create a lazy list
10:30:30 <isberg> EvanR I mean, I can do "customShow MyConst value = show "MyConst value" and then mach on everything else
10:30:33 <monochrom> all confusions are caused by wrong assumptions
10:30:45 <troydm> well it's aeson decode out of huge lazy bytestring
10:30:58 <monochrom> actual code?
10:31:13 <isberg> EvanR But that would require me to match against every constructor there is
10:31:43 <troydm> monochrom: code is quite complex so copy/pasting it will take a lot of time
10:32:02 <monochrom> actually any parsing is likely to kill all laziness.
10:32:15 <EvanR> isberg: i changed my mind. use GenericPretty
10:32:37 <monochrom> simply because asking for "is there a syntax error lurking somewhere?" here and now
10:32:45 <EvanR> troydm: monochrom: its possible to stream tokens of json, which might work for this situation
10:33:08 <EvanR> errors will have to be handled later
10:33:29 <troydm> EvanR: well application works tho
10:33:33 <EvanR> streaming json tokens is how you can possible do json in C
10:33:42 <monochrom> sure, but do you think the actual code does that?
10:33:48 <EvanR> no
10:34:00 <troydm> EvanR: it's memory usage goes up to 90% and subsequently it goes lower to 60% when a garbage collector hits in
10:34:01 <EvanR> troydm: well, youre asking about optimization so 
10:34:26 <EvanR> when you load a lot of json data, you have to use a lot of memory, usually
10:34:34 <troydm> 62.7 already
10:34:35 <EvanR> im suggesting ways to still use json but optimize memory usage
10:34:44 <EvanR> another way is not use json
10:34:45 <isberg> EvanR I'm just curious, Is there a deconstruct without knowing the constructor? 
10:34:52 <EvanR> isberg: Generic
10:34:56 <troydm> well apparently it's lazy but garbage collector is not as frequent as it should be I guess
10:35:06 <EvanR> it doesnt sound lazy whatsoever
10:35:12 <monochrom> no, you have killed all laziness.
10:35:32 <monochrom> (should I write a loop to keep reminding you that?)
10:35:35 <troydm> EvanR: how can you explain memory usage going over 90% and then going lower to 60%?
10:35:50 <EvanR> a sufficiently lazy processor would do it all in like kilobytes rather than gigabytes
10:36:34 <EvanR> troydm: sounds like you have an odd version of "laziness" ?
10:36:38 <EvanR> what is laziness to you
10:36:58 <troydm> EvanR: well you are right
10:37:02 <troydm> EvanR: I'm not sure
10:37:07 <EvanR> welp
10:37:10 <troydm> I just have lazy bytestring of data
10:37:16 <troydm> from http-client's httpLbs
10:37:21 <EvanR> aeson is consuming the entire thing and giving you all the data 
10:37:30 <troydm> and I use decode over it to get [Value] which I process using mapM_
10:37:36 <monochrom> that doesn't mean the consumer will play along with the laziness
10:37:55 <EvanR> monochrom is referring to aeson as the consumer, not your mapM
10:37:56 <troydm> well the whole thing is not more than 175mb
10:38:02 <troydm> yet memory usage is over 6gigs
10:38:36 <EvanR> im not surprised by this, do you want help reducing the memory usage?
10:39:03 <troydm> hmm
10:39:19 <troydm> let me think about it
10:39:42 <dmj`> troydm: why decode as [Value] ?
10:39:44 <troydm> so what you are saying is that aeson just parses entire thing withing 10-15 seconds
10:39:58 <troydm> dmj`: I need to manually parse it
10:40:25 <troydm> dmj`: converting to bson format so I could save it into MongoDB
10:40:26 <EvanR> i... didnt say that
10:40:32 <EvanR> but you just did
10:41:34 <EvanR> 175M of data plus 3 slow inefficient techniques sounds like a disaster
10:42:10 <EvanR> (full parsing, mongodb, and iterating doing 1 database call per item)
10:42:15 <dmj`> troydm: you might want to consider stream parsing, w/ conduit and attoparsec
10:43:33 <isberg> EvanR I'm I close? "customShow :: CDecl x => x -> String". I'm getting "‘CDecl’ is applied to too many type arguments", so guess I*m doing something wrong
10:43:53 <EvanR> isberg: im not sure what youre trying to do
10:44:24 <EvanR> i thought CDecl was a data type
11:03:00 <daey> when i install a pacakge via 'cabal install packagename' i should be able to load it via :m +Packagename right? 
11:03:06 <daey> i installed this package https://hackage.haskell.org/package/cassava
11:03:17 <daey> and am trying to load it with :m +Data.Csv
11:07:05 <eklavya> hi, I am new to haskell, I have been trying to write a project to learn haskell
11:07:22 <eklavya> after playing a little, I can't seem to get this to work
11:07:23 <eklavya> http://pastie.org/10903447
11:07:45 <eklavya> I can't make sense of the compiler errors here
11:07:54 <dysfun> what error do you get?
11:08:19 <eklavya> there seem to be ambiguous instance errors, but I have a hunch there is something else that is wrong
11:08:24 <aoeu_> Is it possible to have types like "PositiveNumber", "UppercaseString", "Between10and100", "DarkerThanRed", "LargerThanNYC", "Afternoon", "MoreThanAnHour", "NoSpaceString", "NotEmptyString", "VowelsOnlyString", etc?
11:09:02 <monochrom> I don't understand "LargerThanNYC".
11:09:10 <monochrom> but no for the rest.
11:09:25 <aoeu_> monochrom: Larger than New York City
11:09:31 <EvanR> aoeu_: the simplest way would be to use newtypes and smart constructors, there are also more advanced tricks. but haskell is pretty limited in this sort of area
11:09:51 <aoeu_> EvanR: Ok, I'll look into languages with dependent types maybe.
11:10:10 <EvanR> dependent types could do it but is sort of an overkill
11:10:33 <EvanR> another AOL keyword is refinement types
11:10:36 <eklavya> dysfun: http://pastie.org/10903451
11:11:05 <monochrom> well, I don't understand Larger Than New York City either. the problem is I don't know the domain (or universe of discourse), i.e., an issue with open world.
11:11:14 <sm> (0::Int) will probably fix it
11:11:20 <eklavya> tried that
11:11:26 <eklavya> didn't work
11:11:36 <dysfun> did it at least fix the second bit?
11:12:11 <eklavya> oh man
11:12:19 <eklavya> I had to add brackets too
11:12:25 <eklavya> it should have been (0::Int)
11:12:30 <eklavya> and not 0::Int
11:12:42 <sm> yeah, otherwise you're saying the whole expression is Int
11:13:06 <eklavya> and I wasted so much time on it :(
11:13:20 <eklavya> thank you so much sm, dysfun :)
11:13:23 <aoeu_> monochrom: Well, let's say you have an Area type, and you have some instance/value. You want to see if the area is larger than NYC. You would encapsulate that constraint into LargerThanNYC and just check if your value respects that constraint.
11:13:35 <sm> part of learning.. np
11:13:35 <EvanR> eklavya: you can minimize issues like this by always putting top level type signatures
11:13:37 <dysfun> :)
11:13:40 <aoeu_> And you could have functions that only accept input that is larger than NYC
11:14:00 <eklavya> EvanR: what do you mean?
11:14:11 <eklavya> can you please give an example?
11:14:12 <aoeu_> this is probably not a good example, since I can't think of a function that couldn't do something for areas smaller than NYC, but I can imagine other scenarios where it would be important.
11:14:25 <EvanR> i mean... if you put top level type signatures, then you will get fewer cases where your code is ambiguous to the compiler
11:14:38 <EvanR> foo :: Foo
11:14:40 <monochrom> yes I respect the want of predicate subtypes
11:14:42 <EvanR> foo = <foo>
11:14:45 <daey> are some modules not loadable in ghci?
11:14:58 <dysfun> daey: what does the error say?
11:15:01 <daey> doing import Data.Csv works fine within a haskell file
11:15:18 <daey> but :m +Data.Csv in ghci fails with 'it is not a module in the current program...'
11:15:24 <monochrom> modules containing foreign exports are not loadable in ghci
11:15:28 <EvanR> aoeu_: you can statically guarantee that a boolean test has been done at runtime, in various ways
11:15:42 <monochrom> but Data.Csv is not this case
11:15:46 <eklavya> EvanR: maybe I am not understanding it, but I am calling a third party API, how do I give a top level type signature there?
11:15:57 * geekosaur is going to guess that it's a case issue
11:16:13 <EvanR> dependent types can go farther and allow you to not have to do the boolean test at all (or you can also gaurantee the test is done at runtime but thats not all you can do)
11:16:17 <monochrom> also ":m +Data.Csv" works for me
11:16:20 <EvanR> aoeu_: ^
11:16:36 <EvanR> eklavya: then what i said may not apply
11:16:45 <monochrom> also ":m" has nothing to do with "loadable"
11:16:46 <geekosaur> ...oh dear, both exist in the ecosystem. /o\
11:16:47 <EvanR> but it still might
11:16:55 <daey> now it works :/
11:17:49 <eklavya> EvanR: I think I understand, thanks :)
11:18:29 <monochrom> geekosaur: what are the two thinks you found to exist?
11:18:34 <monochrom> s/thinks/things/
11:18:37 <EvanR> eklavya: if your third party API has (tricky...) type CoolConstraint a => IO a, then you have to specify what a is at some point. one way is at the use-site, another way is through inference by putting the type at the top level of whatever action youre using it in, and using functions which arent as ambiguous
11:19:08 <geekosaur> I did a completion in hayoo and got shown separate Data.CSV and Data.Csv hierarchies. I didn't drill down to see what packages correspond to which
11:19:25 <monochrom> nice
11:19:32 <EvanR> that great thing about CSV libs is
11:19:41 <eklavya> EvanR: understood, here it's part of a monad chain so I think the only way to do it was at use -site?
11:19:56 <EvanR> that has no bearing on it
11:20:08 <EvanR> type inference works through do notation
11:20:51 <eklavya> EvanR: but that's what was ambiguous, no? It didn't know whether I was talking about an Int8/16/32/64, Int or Integer, no?
11:21:17 <EvanR> there are plenty of ways for it to know which
11:21:34 <EvanR> one way is top level type sigs
11:22:26 <monochrom> there is a defaulting rule that could default to Integer when Num is involved. But it probably also counts on not involving other classes. If Expr is also involved, the defaulting rule is suppressed.
11:22:36 <eklavya> EvanR: I am not able to get you. Can you please modify the code here? http://pastie.org/10903447
11:22:56 <monochrom> > 0 <> 0
11:22:57 <lambdabot>      No instance for (Show a0)
11:22:58 <lambdabot>        arising from a use of ‘show_M801656939652687240324818’
11:22:58 <lambdabot>      The type variable ‘a0’ is ambiguous
11:23:24 <monochrom> yeah, like that. I'm involving all of: Num, Show, Monoid. the Monoid part kills it.
11:23:49 <monochrom> whereas "> 0" alone would default to Integer because it only involves Num and Show
11:24:16 <eklavya> ok
11:24:23 <EvanR> no i cannot
11:24:29 <isberg> Is there a way to get who called a function in haskell?
11:24:31 <monochrom> the defaulting rule basically has a short whitelist of classes it likes
11:25:13 <isberg> I.e "a = b, b = show __caller" #=> a
11:25:24 <eklavya> EvanR: ok, thanks anyways :)
11:26:08 <EvanR> eklavya: in this case you have so little code, all of which is polymorphic, there is not enough information it seems
11:26:19 <monochrom> {-# LANGUAGE ExtendedDefaultRules #-} relaxes that whitelist
11:26:27 <EvanR> in real life, as long as you put top level sigs and have a lot of different functions, you will not need as much inline annotations
11:27:16 <isberg> or is this reduced/removed by the precompiled? 
11:27:16 <eklavya> I think I understand
11:27:20 <isberg> *precompiler 
11:27:29 <eklavya> thanks EvanR, monochrom :)
11:28:43 <EvanR> isberg: youre asking for runtime information, so it cant be removed by a compiler
11:28:59 <EvanR> you can look into the profiler to get something like that
11:29:29 <isberg> EvanR Okay, so there's not "global" function/value for this? 
11:30:02 <EvanR> im not sure a caller makes sense in haskell
11:30:07 <slemonide> I have a program that prompts the user to type a number. What is a good way to check if the input is really a number?
11:30:34 <maerwald> parse?
11:31:07 <EvanR> try to convert it into a number (readMaybe maybe), if it doesnt work, its not a number
11:31:40 <monochrom> yeah, use readMaybe
11:31:50 <monochrom> it's in Text.Read
11:32:34 <monochrom> https://www.youtube.com/results?search_query=cookie+monster+share+it+maybe
11:33:07 <slemonide> thank you, that should work
11:52:17 <Iceland_jack> @ask bollu Yes they are the same, quantification (forall) is implicit in GADT syntax
11:52:17 <lambdabot> Consider it noted.
11:52:22 <troydm> how do I specify more newer package that in LTS?
11:52:31 <troydm> when using stack
11:53:23 <troydm> nvm
11:54:14 <EvanR> @tell Iceland_jack is that really a question?
11:54:14 <lambdabot> Consider it noted.
11:57:26 <Iceland_jack> ;)
11:57:48 <Iceland_jack> EvanR: I forgot the syntax, searched up and only found '@ask's, Googled it and found the source https://github.com/jwiegley/lambdabot/blob/master/Plugin/Tell.hs
11:58:08 <Iceland_jack> If I could go back in time I would have done this differently
11:58:23 <EvanR> too bad time is a monoid and not a group
12:03:49 <aoeu_> I know it's not specific to Haskell, but what would you consider to be the best high-level language if performance, compatibility and ecosystem maturity wasn't a concern?
12:04:17 <hpc> turbo pascal
12:04:22 <hpc> because it has "turbo" in the name
12:04:48 <aoeu_> 2fast2furious
12:04:55 <EvanR> if performance, compatibility, and ecosystem were a concern... id have to go with haskell
12:05:01 <EvanR> otherwise not sure
12:05:01 <jmcarthur> EvanR: What kind of group? It's at least an additive group. I can't think of a reasonable way to consider it a multiplicative group, but it is at least a vector space.
12:06:02 <hexagoxel> ecosystem includes any compiler whatsoever, right? so i'd go for some imaginary perfect language that i'd always wanted to write a compiler for.
12:06:10 <jmcarthur> Oh, this was in the context of time travel. Well, it's an additive group, which is what I think you meant.
12:06:35 <jmcarthur> We just can't take advantage of this fact for the purposes of traveling backward in time.
12:06:36 <EvanR> jmcarthur: i think itll take a leap of faith to be ok with this joke
12:06:47 <EvanR> in various ways
12:07:28 <EvanR> time as a manifold isnt a group, but the real numbers can be the "difference group" for that manifold
12:07:57 <aoeu_> Basically, I'm looking for the best "language", not the best implementation. Let's assume that all languages as rich ecosystem with a bunch of reliable third-party libraries, helpful community, etc. The language can run on any platform. All hardware execute the language instantly (no performance concern). What would the best language look like, given these conditions?
12:08:27 * hackagebot QuickCheck 2.9 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.9 (NickSmallbone)
12:08:40 <EvanR> for the joke, time is a monoid. mempty is "right now" and (x++) is "wait x"
12:08:53 <EvanR> you cant unwait
12:11:00 <pykno-paron> great summer song !   https://www.youtube.com/watch?v=ysb3TZ-YrKU&feature=youtu.be
12:11:01 <hexagoxel> when someone asks you what the time is, just say identity.
12:12:16 <Jinxit> aoeu_: highly subjective
12:12:45 <aoeu_> Jinxit: We all know that C wouldn't be one of them, would you agree?
12:12:56 <aoeu_> Not Assembly either.
12:13:06 <Jinxit> aoeu_: ask an embedded dev and they might say C
12:13:16 <EvanR> the best language ever is on topic in #haskell
12:13:51 <EvanR> Jinxit: also realtime audio
12:14:53 <aoeu_> Jinxit: But they would be wrong.
12:14:56 <Iceland_jack> What is the best colour? Haskell.
12:14:56 <Iceland_jack> What is the best dish? Haskell.
12:15:01 <Iceland_jack> aoeu_: It's always Haskell
12:15:11 <jmcarthur> aoeu_: I don't see how a language with your criteria could exist. "runs on any platform" and "executes instantly" each seem problematic.
12:15:14 <aoeu_> Iceland_jack: I think Agda/Idris might be better.
12:15:18 <aoeu_> Iceland_jack: Or Liquid Haskell.
12:15:35 <EvanR> runs on all platforms, executes instantaneously, has nice syntax. pick 2
12:15:48 <Iceland_jack> Liquid Haskell is closer to a preprocessor / typechecker
12:15:52 <jmcarthur> EvanR: More like "pick the third one"
12:16:18 <EvanR> well ULC, turing machines
12:16:45 <daey> is it correct to claim that monoids are groups that do not fullfill the rule of an inverse element?
12:16:57 <EvanR> no
12:17:01 <ertes> add another criterion: "can implement useful programs"
12:17:05 <EvanR> all groups are monoids
12:17:07 <ertes> (a.k.a. "pacman-complete")
12:17:30 <ertes> daey: those are often called "proper monoids"
12:17:34 <daey> EvanR: yeah but they are still monoids without the inverse
12:17:37 <ertes> a monoid that isn't a group
12:17:51 <latro`a> daey: people know what you mean but what you're saying is not really correct, since a group by definition satisfies all the properties
12:17:57 <EvanR> you mean groups without inverse? a contradiction
12:18:19 <ertes> daey: but even proper monoids have at least one invertible element
12:18:34 <jmcarthur> daey: It would be correct to say that a group is a monoid with an inverse element.
12:18:50 <EvanR> an inverse operation
12:18:56 <jmcarthur> yes that
12:18:59 <jmcarthur> sorry
12:19:04 <latro`a> ertes: the identity always has an inverse but it could be that nothing else does
12:19:34 <latro`a> (for example the nonnegative integers under addition)
12:22:22 <dolio> It could even be that only one thing doesn't have an inverse.
12:22:43 <MrDetonia> if the default length function returns an Int, why does it work for values over the int size? e.g. 'length [1..3000000000]' works correctly
12:22:48 <dolio> Like ratios of integers under multiplication.
12:23:25 <ertes> MrDetonia: 3000000000 is within Int on 64 bit platforms
12:23:51 <MrDetonia> ahhh
12:23:52 <MrDetonia> ofc
12:24:02 <MrDetonia> so it would crash or overflow if I tried to go above that limit?
12:24:17 <MrDetonia> for my own twisted reasons
12:24:26 <ertes> MrDetonia: it would restart from 0
12:24:38 <mirpa> it will overflow for big list, yes
12:24:48 <MrDetonia> okay, thanks
12:25:22 <ertes> MrDetonia: but i doubt that you have hardware that can count to 2^63 within a lifetime and not collapse to a black hole =)
12:26:08 <MrDetonia> ertes: well, not right now...
12:26:14 <Welkin> > 2^63
12:26:16 <dysfun> actually i did some maths
12:26:16 <lambdabot>  9223372036854775808
12:26:34 <EvanR> > length ([0..1000] :: [Word8])
12:26:36 <lambdabot>  233
12:26:51 <dysfun> i figured you can overflow it in about a hundred years assuming the hardware isn't fucked by then
12:27:02 <dysfun> (which, y'know...)
12:27:08 <Welkin> 233? lol
12:27:08 <ertes> MrDetonia: note that counting is sequential, and our CPUs probably won't get much faster, unless we develop some kind of new transistor
12:27:11 <EvanR> 233.
12:27:25 <Welkin> > 2^7
12:27:27 <lambdabot>  128
12:27:31 <Welkin> > 2^8
12:27:32 <lambdabot>  256
12:27:35 <MrDetonia> ertes: yeah
12:27:40 <EvanR> > 1000 `mod` 256
12:27:42 <lambdabot>  232
12:27:43 <MrDetonia> just wondering how haskell was handling it
12:27:49 <MrDetonia> but I can't count
12:28:21 <Welkin> oh
12:28:24 <Welkin> I see
12:28:38 <ertes> dysfun: 68-136 years according to my estimation, so yeah, black hole was a bit exaggerated =)
12:29:16 <dysfun> ertes: that's holding the base10 of graham's number in your head
12:29:26 <ertes> hehe
12:29:32 <dolio> I think your machine still won't last for 130 years with a CPU pegged constantly.
12:29:37 <ertes> dysfun: actually that one is easy: G
12:29:45 <dysfun> dolio: yeah, that is exactly what's gonna happen
12:30:09 <dysfun> ertes: LALALALALALALALALALALAA
12:30:47 <ertes> dolio: if you save the counter every few hours…
12:30:59 <ertes> doesn't increase counting time that much
12:31:13 <Jinxit> just parallelize it tbh
12:31:17 <dolio> Even getting more parallel won't really help.
12:31:26 <ertes> Jinxit: how do you parallelise counting?
12:32:00 <EvanR> ill start at 0, you start at 1000000000. ill tell you top stop if i get to the end first
12:32:04 <dysfun> simply lose the serialisation requirement and experience web scale today!
12:32:40 <ertes> or experience haskell magic
12:32:43 <ertes> > maxBound :: Int
12:32:45 <lambdabot>  9223372036854775807
12:32:49 <ertes> see that?
12:33:04 <dysfun> i'm gonna save a lot of cpu cycles here
12:33:20 <dysfun> (maxBound::Int) + 1
12:33:24 <dysfun> > (maxBound::Int) + 1
12:33:26 <lambdabot>  -9223372036854775808
12:33:42 <EvanR> > minBound + maxBound :: Int
12:33:45 <lambdabot>  -1
12:33:45 <nitrix> ertes: If I understand properly, space (time) leaks in reactive-banana can only happen if there are inputs fed to the network with no consumer to output (with reactimate presumably) ?
12:34:02 <nitrix> ertes: Then the events just grows and grows more samples?
12:34:37 <ertes> nitrix: i don't think you can have time leaks in reactive-banana, unless you introduce them deliberately through laziness
12:35:05 <nitrix> Ah. I thought I had to be more cautious..
12:35:05 <ertes> about space leaks: i'm not sure whether r-b keeps stuff that isn't actually used
12:35:40 <ertes> in any case i wouldn't expect the actual event payloads to be kept at all, if there is no listener
12:35:50 <nitrix> Mhh, you're right. The graph probably gets reduced by the garbage collector if there's no outputs tied to some branches.
12:35:54 <ertes> i'd expect fired events to simply disappear
12:36:02 <nitrix> Makes sense.
12:36:15 <ertes> i think, r-b does that algorithmically, not through GC
12:36:21 <ertes> reflex uses GC to get rid of stuff
12:36:28 <nitrix> Oh. Very cool.
12:40:14 <epsilonhalbe> hey i have a question - if i do a migration with persistent for a in memory db (for testing) can I suppress the actuall sql statements - somehow?
12:41:14 <epsilonhalbe> i tried to do `runSqlite "WAL=off :memory:"` - but it stayed - is this supposed to be this way?
13:07:11 <davidkart> hey, I want to do math to understand functional programming with Haskell better. Is it mandatory ? Where should I start ?
13:08:12 <Welkin> no, it is not mandatory
13:08:13 <Zekka> davidkart: I don't think math is that important to learning haskell, fwiw -- I'm also not qualified to tell you what math you would need to learn
13:08:17 <bjs> davidkart: you really don't need math to understand haskell functional programming
13:08:18 <Welkin> and it will not really help you
13:08:26 <Zekka> I am a tolerable Haskell programmer, but also a very bad mathematician
13:08:29 * hackagebot irc-client 0.4.2.1 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.2.1 (barrucadu)
13:08:46 <Zekka> A lot of the theory seems pretty irrelevant to actual programming -- at least the parts I know
13:08:52 <bjs> davidkart: really, the part of math that'll help you is the basic logic component -- not specifically learning about Monoids or Semigroups
13:09:04 <Welkin> understanding some basic category thoery might help you understand functors, applicatives, monads, monoids, etc.
13:09:09 <davidkart> well so can you tell me what is a monoid, what is a functor, what is a monad, as a haskell programmer and not as a mathematician ? How are the mathematical concepts related to FP with haskell ?
13:09:22 <maerwald> Welkin: no, it just opens more question
13:09:25 <maerwald> +s
13:09:36 <Welkin> davidkart: they are just typeclasses, nothing more and nothing less
13:09:41 <maerwald> it's easier if you don't know anything about CT ;)
13:10:10 <Zekka> I'm not sure the category theory is useful to programming
13:10:12 <daey> [1..10] < that is a monoid in haskell isnt it?
13:10:25 <maerwald> Zekka: it can be, if you do esoteric stuff
13:10:26 <Zekka> daey: It's a value whose type is a monoid
13:10:33 <bjs> davidkart: a functor is a thing with a fmap function, a monad is a thing with a (>>=) and a return function
13:10:38 <Welkin> daey: lol, no
13:10:58 <maerwald> > [1..10] <> [2]
13:11:00 <bjs> davidkart: just think of them as typeclasses with those functions and learn what those functions do, there's really not any required math
13:11:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,2]
13:11:07 <Welkin> unless you mean that List has an instance defined for Monoid, then yes
13:11:08 <maerwald> daey: yes
13:11:23 <maerwald> not sure what "lol, no" means in that context
13:11:31 <daey> cool three different opinions ;D
13:11:48 <maerwald> daey: people are just nitpicking sometimes here
13:11:49 <Welkin> maerwald: because a list from 1 to 10 itself is not a monoid
13:11:51 <bjs> maerwald: i think they meant that [1..10] isn't a monoid, but there is a monoid instance for [] ?
13:12:00 <maerwald> Welkin: I don't think he cares or that it's what he meant.
13:12:03 <daey> Welkin: its not just a list
13:12:14 <daey> it also contains the operation +1, doesnt it?
13:12:19 <maerwald> a little bit less nitpicking would sometimes be nice
13:12:52 <maerwald> daey: what does that mean?
13:12:59 <Welkin> he means this
13:13:03 <Welkin> > enumFromTo 1 10
13:13:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:13:11 <daey> [1,10] != [1,3..10]
13:13:20 <davidkart> maerwald: Zekka: so why use names from category theory if it's not useful ?
13:13:23 <maerwald> daey: [1..10] is syntactic sugar, basically
13:13:25 <daey> [1..10]
13:13:29 * hackagebot stack-run 0.1.1.0 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.1.0 (yamadapc)
13:14:05 <davidkart> Well, why are not you giving meaningful name to this objects then ?
13:14:09 <bjs> maerwald: they are useful concepts but you don't need to understand the theory behind them to understand how to use them
13:14:14 <bjs> davidkart: ^
13:14:16 <davidkart> ok
13:14:30 <davidkart> bjs : do you understand that theory ?
13:14:34 <Welkin> davidkart: the names are very emaningful
13:14:36 <Welkin> meaningful*
13:14:40 <bjs> davidkart: i'm okay with the theory, but i'm not a category theorist
13:14:52 <Welkin> for example, a Monoid is something that has a combining operation and an identify value
13:14:54 <EvanR> davidkart: the categorical terminology was chosen to scare people off, the motto was "avoid success at all costs"
13:15:00 <davidkart> so if they are meaning ful, I should learn what they mean independantly of the language, right ?
13:15:02 <EvanR> i think that plan is failing
13:15:03 <Welkin> (+) and 0 form a monoid
13:15:07 <bjs> davidkart: i can get by with seeing the word monoid in a paper used in its mathematical sense and that's about it :)
13:15:07 <barrucadu> davidkart: It is better to use the proper names that will be of use to people in the know, than to make up new names which are meaningful to nobody.
13:15:32 <EvanR> it has the opposite effect, people are curious what these names go to
13:15:33 <Welkin> barrucadu: haha
13:15:38 <Welkin> you mean like "flatMap"?
13:15:41 <davidkart> EvanR: are you serious ? 
13:15:42 <maerwald> I think you already lost him with all that nitpicking and terminology foo.
13:15:47 <Welkin> that always bothers me when I see that in some languages
13:15:52 <Welkin> wtf is a flatMap?
13:15:53 <EvanR> now some people are interested in category theory that wouldnt have been before
13:15:57 <bjs> EvanR: that's a good thing though
13:15:58 <Welkin> just call it "bind"
13:16:21 <EvanR> dont call it anything
13:16:27 <EvanR> unless youre using scala then call it flatMap
13:16:32 <systemfault> Welkin: Well... bind can be defined as a map(fmap) operation followed by a flatten operation (join)
13:16:40 <davidkart> EvanR: that's my problem. I'm not really interested by CT but I'm intersted by Haskell. But I suppose if Haskell is that much interesting to me, I should learn how to use the terminology properly.
13:17:03 <Welkin> @where typeclassopedia -- davidkart 
13:17:04 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:17:07 <EvanR> davidkart: well, pretend CT doesnt exist. pretend these are haskells names for things and they have no meaning otherwise
13:17:13 <Welkin> that's all you need to know about CT for haskell
13:17:17 <bjs> davidkart: using the terminology propery in a Haskell program comes down to putting the right name for the typeclass, it's good to be interested in it and you can learn about it later
13:17:26 <bjs> but you don't need CT to learn about Functors in Haskell or how to use them
13:17:53 <EvanR> Functor vis a vis Mappable
13:17:55 <bjs> > (+1) <$> [1,2,3] -- requires no category theory.
13:17:58 <lambdabot>  [2,3,4]
13:18:01 <EvanR> Monoid vis a vis Fusable
13:18:09 <Welkin> EvanR: what is that from?
13:18:13 <EvanR> i made it up
13:18:30 <davidkart> So in your opinion, if I learn Haskell well, and then move on to CT, is it going to be easier to learn CT ?
13:18:44 <Welkin> no...
13:18:46 <bjs> davidkart: *actual* CT is quite different from haskell to be fair
13:18:50 <Welkin> if you want to learn CT, then learn CT
13:19:04 <barrucadu> The category which is relevant to Haskell is pretty simple
13:19:04 <davidkart> (but if I learn CT, is it going to help me in understanding Haskell ?)
13:19:15 <EvanR> Monad vis a vis Flattenable
13:19:46 <bjs> davidkart: haskell has borrowed some names and design patterns just because mathematicians thought about it long and hard and decided they were a good design pattern that give you certain properties
13:20:22 <bjs> davidkart: really the names are just there to pay homage to that fact, you don't need to know the maths that they did to show that these abstractions are nice
13:20:35 <tomleb> Are there any good tutorial on using react-flux ?
13:20:38 <systemfault> As if the classic OOP design patterns were any better... visitor/factory/builder/singleton/command/memento/flyweight
13:20:41 <davidkart> I think I start to understand the problem I have
13:21:01 <dolio> Of course it will be easier to learn category theory if you know Haskell first.
13:21:04 <EvanR> systemfault: you need a ThingThinger pattern
13:21:08 <Welkin> tomleb: that is not haskell
13:21:14 <systemfault> EvanR: Right :)
13:21:36 <daey> dolio: and then right into automated theorem proving :P
13:21:39 <EvanR> MoverShaker, an ObjectVerber
13:21:48 <tomleb> Welkin: Well, there is the package react-flux, so yeah, it is.
13:22:04 <Welkin> Enemy inherits from MovableObject, and then we have an AbstractEnemyFactoryManager
13:22:06 <EvanR> a VaguenessManager
13:22:11 <systemfault> lol
13:22:15 <dolio> Just like it will be easier if you know set theory, or any of several other mathematical theories.
13:22:23 <dolio> Having background makes it easier.
13:22:43 <davidkart> Well The problem is that to be honest, mathematics are quite powerful. So why not learn the good concepts from a mathematical POV (even if the definitions are quite simple) and then work toward Haskell.
13:22:46 <Welkin> tomleb: that is a binding
13:22:55 <Welkin> go find a tutorial on react, which isn't haskell
13:22:56 <davidkart> I think I'll try to do that. Eventually going back and forth.
13:23:24 <davidkart> And basically , I understood Java OOP system much better since I did some of Haskell.
13:23:25 <Welkin> tomleb: https://bitbucket.org/wuzzeb/react-flux
13:23:29 <tomleb> Welkin: I'm having trouble using haskell with it, not with react in itself
13:23:30 <EvanR> davidkart: in that case, youll find haskell is like a gateway drugs to a whole universe of things
13:23:49 <tomleb> Welkin: I can't even do a simple hello, world page
13:23:54 <EvanR> and you wont be limited to traditional programming
13:24:11 <Welkin> tomleb: you may want to try Elm instead
13:24:18 <Welkin> I have been learning it recently and it is very simple
13:24:27 <Welkin> much simpler than using ghcjs or react
13:24:42 <Welkin> it is a replacement for react and friends
13:25:14 <Welkin> https://bitbucket.org/wuzzeb/react-flux
13:25:16 <tomleb> Welkin: Yeah, heard of it, I might look into that if I can't figure out react-flux in some time
13:25:16 <Welkin> er
13:25:26 <Welkin> http://elm-lang.org/
13:25:40 <Welkin> tomleb: lol, hello worls is one line
13:25:44 <Welkin> world*
13:26:22 <ARM9> what about purescript
13:26:32 <tomleb> Welkin: With react-flux my code compiles, but I get a javascript error lol
13:26:44 <Welkin> tomleb: that won't happen with elm
13:26:47 <Welkin> just try it
13:26:56 <tomleb> Says react is undefined, I think I need to add react in a <src> tag..
13:27:00 <davidkart> EvanR: o: Let's do it then ^^
13:27:06 <davidkart> ok thanks
13:27:19 <alesaico> hi
13:27:25 <Welkin> ARM9: purescript is more complicated than elm and is really just a compile-to-js language, not a framework
13:28:04 <ARM9> does elm still not have higher kinded types?
13:28:13 <Welkin> it doesn't need them
13:28:22 <Welkin> it was made for a specific purpose
13:28:26 <Welkin> it's not a general purpose language
13:29:01 <tomleb> Then I don't know why it's giving me an error
13:39:22 <Welkin> tomleb: fun tetris clone in elm http://unsoundscapes.com/elm-flatris.html
13:42:38 <still_learning_h> Hey guys, need some help with my monad stack. Currently I have ExceptT on top of WriterT (on top of IO), and I'm having a hard time figure out how to keep the error propagating functionality of ExceptT while still being able to tell to update my WriterT
13:43:33 <ReinH> Do you mean that 'tell' doesn't work?
13:44:03 <still_learning_h> Well, let me upload a short snippet
13:44:08 <still_learning_h> on pastebin or something
13:44:11 <ReinH> @where lpaste
13:44:11 <lambdabot> http://lpaste.net/
13:45:15 <still_learning_h> something like this: http://hastebin.com/gumesodipa.rb
13:45:49 <jmcarthur> still_learning_h: What are your imports?
13:46:08 <ReinH> So what's the issue?
13:46:23 <jmcarthur> still_learning_h: And what are the types of loadSettings and doStuffWith?
13:46:42 <still_learning_h> They both return ExcepT
13:47:10 <ReinH> If ExcepT is on the outside of your transformers, yes
13:47:13 <ReinH> why is that an issue?
13:48:00 <still_learning_h> Hmm, need a few to rephrase myself
13:48:15 <jmcarthur> I'm going to assume you are using mtl. If that is true, tell should "just work".
13:49:43 <still_learning_h> Yes of course, it all works and that, but my main goal is that if doStuffWith or loadSettings return a Left from a throwError, I want that to propagate all the way through my do
13:50:03 <jmcarthur> I would expect that to happen already.
13:50:21 <ReinH> if (say) loadSettings throws, nothing after it should be evaluated
13:50:31 <jmcarthur> @unmtl ExceptT e (WriterT o IO) a
13:50:32 <lambdabot> ExceptT e (WriterT o IO) a
13:50:34 <ReinH> Do you have an example where that is not the case?
13:50:35 <jmcarthur> bleh
13:50:40 <still_learning_h> jmcarthur: You would? Hmm maybe then I'm just doing it wrong. 
13:50:48 <ReinH> jmcarthur: it doesn't know about ExceptT, use ErrorT
13:50:57 <jmcarthur> @unmtl ErrorT e (WriterT o IO) a
13:50:57 <lambdabot> IO (Either e a, o)
13:50:58 <still_learning_h> Thanks guys, if that is the case I'll try some more then
13:51:14 <still_learning_h> and return if things turn to shit ;-)
13:51:49 <jmcarthur> still_learning_h: In the case of an error, do you still want the things you are logging with WriterT?
13:52:02 <jmcarthur> @unmtl WriterT o (ErrorT e IO) a
13:52:02 <lambdabot> IO (Either e (a, o))
13:52:08 <jmcarthur> note the difference
13:52:12 <still_learning_h> jmcarthur: Yes, all the way up until the error
13:52:20 <jmcarthur> okay
13:52:27 <jmcarthur> then it sounds like you are doing it correctly so far
13:52:54 <still_learning_h> thanks, the point is to do some simple logging and then print to CLI
13:53:07 <still_learning_h> but i'll test some more
13:56:54 <Welkin> I've been playing that game too much today
13:56:55 <Welkin> haha
13:57:07 <Welkin> after staring at those tetris blocks so long, everything else looks weird
13:58:47 <nitrix> I'd never imagined writing a game in Haskell would be so hard.
13:59:33 <maerwald> some people even wrote GUIs in prolog :P
13:59:54 <still_learning_h> maerwald: those people are batshit insane 
14:01:06 <still_learning_h> maerwald: Even though Prolog is a handy language whenever you need to do some logic-programming or clpfd, I'would never in my life attempt to write a GUI in prolog lol
14:01:23 <Welkin> I have seen a game written in sed
14:01:27 <maerwald> still_learning_h: I feel similar about writing games in haskell ;)
14:01:29 <Welkin> I think it was a chess solver actually
14:02:41 <maerwald> although, depends what kind
14:02:55 <maerwald> there is a go implementation in haskell, I think that somewhat makes sense (board games)
14:03:18 <maerwald> then a simple gtk gui on top of it, done.
14:03:44 <maerwald> @hackage goatee
14:03:44 <lambdabot> http://hackage.haskell.org/package/goatee
14:03:55 <jmcarthur> I don't think writing games in Haskell is fundamentally harder than in any other language. My main point of grief is the lack of awesome libraries for it.
14:04:16 <maerwald> jmcarthur: writing useful engines in haskell is definitely fundamentally harder
14:04:22 <jmcarthur> And that the GC isn't always so great for games...
14:04:33 <jmcarthur> maerwald: Why do you say that?
14:05:59 <maerwald> because engines are usually full of destructive updates, inplace mutation, memory tricks and so on... in addition, you usually want predictable performance, which gets a lot trickier with haskell
14:06:09 <maerwald> and then, how do you escape the IO hell?
14:06:56 <jmcarthur> Engines don't necessarily require those things. And where they do, you can just... do it? I prefer writing C in Haskell than writing C in C, to be honest.
14:07:22 <maerwald> yeah, as said: you can also write GUIs in prolog.
14:07:52 <jmcarthur> I also don't find performance to be all that difficult to predict, although it's often that my (correct) prediction is that the GC will bite too hard to do that thing I want to do.
14:08:42 <maerwald> pretty sure we will not see an industry-grade graphics engine in haskell in the next 20 years :P
14:09:07 <jmcarthur> Depends on how you define industry-grade. Do you mean it must be capable of supporting high-end AAA games?
14:09:12 <maerwald> yes
14:09:18 <jmcarthur> Then I agree with you.
14:09:28 <jmcarthur> But that doesn't make Haskell a bad choice for games, broadly.
14:09:47 <maerwald> yeah, as said, depends on the kind of game. It's probably fantastic for board games with simple GUIs.
14:11:59 <still_learning_h> jmcarthur: Quick question, lets say I have a ExceptT MyError IO String. How do I use that string in a tell? 
14:12:33 <jmcarthur> still_learning_h: Supposing that value is bound to foo, you could say   do x <- foo; tell x
14:13:02 <jmcarthur> still_learning_h: But I should stress that "that string" doesn't exist just because you have a value of type ExceptT MyError IO String.
14:13:17 <jmcarthur> still_learning_h: It only exists once the "x" in my code is in scope.
14:13:43 <still_learning_h> ofcourse, and hence I wanted to make use of the error-propagation stuff
14:15:11 <still_learning_h> but using a do creates a type error, since it expects foo to be a WriterT and not an ExceptT
14:16:40 <jmcarthur> still_learning_h: Then you must not be using mtl, which was an assumption I stated earlier.
14:17:27 <still_learning_h> I am actually using mtl, here i'll lpaste my whole current file. Sorry for the inconvenience
14:18:16 <travism> can someone help me understand sequence_ and why it's needed here? I am not sure what it is actually 'evaluating' hoogle says evaluate each monadic action in the structure. Why does sequence_ have to be here to print it out. sequence_ [putStrLn (x ++ " - " ++ y) | (x, y) <- xs] 
14:19:20 <mjrosenb> travism: because [putStrLn ... | (x,y) <- xs] has type [IO ()], which is a list of things that can be done.
14:19:35 <mjrosenb> noplace does that say to actually do anything.
14:20:09 <travism> Sorry, still really new to this. So what is seqence_ actually doing then?
14:20:17 <maerwald> :t sequence_
14:20:17 <travism> shouldn't putStrLn just immediately print it out?
14:20:18 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
14:20:24 <still_learning_h> jmcarthur: http://lpaste.net/5204621917385916416
14:20:43 <maerwald> travism: no :) because you can pass around IO actions without them being executed
14:20:57 <still_learning_h> I do fully understand why it does not work, but I need some help in figuring out a way to achieve what i want :-)
14:21:04 <travism> Ah
14:21:15 <bjs> travism: what do you mean immediately? they get passed around like anything else in haskell, lazily
14:21:53 <maerwald> travism: imagine you have a list of 10 IO actions, but only want to execute the last one. How would that work if they already "get executed inside the list"?
14:21:54 <travism> bjs: Well I initially had it written with out sequence because I thought for each value in the tuple in the comprehension it would print it out..
14:22:27 <Welkin> travism: that is a key feature of haskell: referential transparency
14:22:47 <Welkin> all of your IO can only ahppen if your function is in IO
14:23:00 <travism> So if I am understanding correctly the comprehension is creating a list of io actions then sequence is executing each one?
14:23:07 <Welkin> no
14:23:11 <Welkin> sequence does not execute anything
14:23:21 <Welkin> it is just turning t m a into m t a
14:23:36 <Welkin> it can turn [IO String] into IO [String]
14:23:47 <travism> :|
14:24:07 <jmcarthur> still_learning_h: Where does getsetting come from?
14:24:10 <benzrf> travism: haskell is pure
14:24:18 <maerwald> meh, that discussion again :P
14:24:24 <benzrf> evaluating expresions cant cause things to happen
14:24:30 <benzrf> besides your computer heating up :)
14:24:36 <Welkin> travism: your entire program is just one big math equation that gets evaluated when you run main
14:24:42 <athan> Is there a Char that's... empty?
14:24:52 <Welkin> IO actions are just data that you pass around
14:25:02 <jmcarthur> athan: define "empty"
14:25:09 <Welkin> lol athan 
14:25:13 <Welkin> you mean /NUL? 
14:25:17 <Welkin> \NUL
14:25:23 <jmcarthur> > '\NUL'
14:25:25 <athan> hm, isPrint?
14:25:26 <lambdabot>  '\NUL'
14:25:30 <athan> cripes
14:25:37 <athan> thanks guys :)
14:25:40 <still_learning_h> jmcarthur: http://lpaste.net/5288046318466367488 In this case it will return m String, where m is ExceptT HattisError IO
14:25:41 <travism> Yeah, I understand that so how come in main if I put putStrLn "Blah" iit prints out but in the comprension it doesnt?
14:25:51 <Welkin> travism: because main is in IO
14:25:55 <Welkin> main has type IO ()
14:25:58 <bjs> travism: because main has type IO ()
14:26:01 <travism> Ah
14:27:13 <jmcarthur> still_learning_h: I disagree. It looks like it needs to be returning a Hattis String here, instead. Maybe you just need to add an Ini instance for Hattis?
14:27:15 <maerwald> travism: you can do something like: let sequenced = sequence [my IO actions] -- and it will now be ONE IO action instead of a list of IO actions, evaluated in order, so when you executed it, they will be executed in order
14:27:15 <Welkin> flatris broke on me
14:27:19 <jmcarthur> *instance of Ini for Hattis
14:27:41 <jmcarthur> still_learning_h: Alternatively, you could use the Hattis constructor to wrap it.
14:28:31 <mjrosenb> bah, plot doesn't want to install with cabal
14:28:38 <travism> This probably going to make more since when I get to Monads ?
14:28:42 <mjrosenb> maybe stack will be able to install it?
14:28:51 <mjrosenb> *plot-gtk
14:29:27 <Welkin> travism: yes
14:30:02 * mjrosenb tries Chart-gtk instead
14:30:21 <travism> Ah ok good
14:30:29 <travism> Thanks for the help, appreciate it!
14:31:13 <still_learning_h> jmcarthur: Hmmm, thanks, i'll have to think about it
14:31:22 <Welkin> haggis?
14:32:08 <athan> Woah woo wee wah, check out this strage compile error: http://lpaste.net/169487
14:32:21 <Welkin> athan: your wife?
14:32:34 <athan> Welkin: She is my sister, very nice
14:32:47 <athan> wait I'm being lame
14:32:48 <athan> nevermind
14:32:50 <Welkin> and this is prostitute?
14:50:07 <plugyn> 4/wc
14:57:26 <davidkart> n
15:00:30 <athan> Baby's first parser/printer isomorphism!
15:15:33 <davidkart> Hello. It's not working : http://pastie.org/10903558. Why ?
15:16:31 <pavonia> davidkart: You are defining three different func's there
15:16:45 <davidkart> ah problem with type I see
15:16:48 <hpc> multi-line definitions in ghci is awkward
15:16:50 <mjrosenb> and only the last one remains bound.
15:16:54 <hpc> *are
15:17:19 <monochrom> Not a type problem. A shadowing problem.
15:17:36 <hpc> the easiest way to avoid the quirks of ghci's repl while learning is to write your code in some foo.hs
15:17:38 <davidkart> so whats the problem ? I should use guards instead ?
15:17:40 <hpc> run ghci foo.hs
15:17:49 <hpc> and then when you make changes in the file, type :r
15:17:58 <monochrom> OK, you need to do the following experiment to see the problem.
15:18:16 <mjrosenb> hpc: doesn't that get rid of any local bindings you've made in the repl outside of the file?
15:18:18 <monochrom> enter "let x = 3". then enter "let x = True". what is x now?
15:18:27 <davidkart> x a boolean
15:18:47 <hpc> mjrosenb: that's honestly probably better than keeping them around
15:18:55 <monochrom> Does the first line "let x = 3" matter to your answer?
15:19:20 <mjrosenb> hpc: it gets kind of annoying when the types + values don't depend on anything defined in the file.
15:19:21 <hpc> if you have some local definition hanging around that depends on an older module definition, you have to stop and think about which it is using
15:19:30 <davidkart> mmh yeah I see now
15:19:33 <davidkart> I was stupid.
15:19:37 <pavonia> davidkart: Each new let hides the previous one, you should define your function in a module and load that int GHCi
15:20:03 <davidkart> how would you do it in GHCi ?
15:20:20 <monochrom> There is a trick. You can enter "let { f 0 = 0; f x = f (x-1) }". that will do what you want.
15:20:24 <hpc> davidkart: see what i wrote above
15:20:33 <monochrom> But I still recommend putting it all in files.
15:20:44 <monochrom> entering code at the REPL does not scale.
15:21:14 <monochrom> and it is not just ghci. any language's repl.
15:21:35 <Rotaerk> reading about stream fusion ... is that in the GHC base/prelude now, or does it still require a stream fusion package
15:21:36 <monochrom> a repl is not an IDE. you can't even edit a line you entered 5 minutes ago.
15:21:52 <monochrom> and a repl is not going to save your code for future use.
15:21:57 <hpc> you can't even edit a line you entered 5 seconds ago
15:22:14 <davidkart> ok monochrom
15:22:30 <mjrosenb> monochrom: well, there's no reason that a repl can't just they don't. (probably for  a good reason, since a repl is /not/ a replacement for an ide)
15:22:37 <monochrom> entering code at the repl is reserved for a robot who never makes mistakes, in fact who also can predict the future.
15:23:10 <monochrom> you wouldn't call the Racket nice environment a REPL, would you?
15:23:15 <mjrosenb> davidkart: I personally recommed using emacs, since it lets you run ghci as an inferior process, and reloading code is trivial.
15:23:16 <davidkart> it's weird.
15:23:31 <davidkart> I can do x=2 in GHCi without the let
15:24:14 <davidkart> Well a fact is that good tools that make easy work are important to developpers.
15:24:20 <monochrom> if you have a nice environment that quadruples as editor, saver, executioner, and visualizer, you no longer call it "repl". you call it "Dr. Racket"
15:25:06 <monochrom> "repl" is by definition this transient thing you can do a few tests with a few short commands and nothing more.
15:25:39 <sm> repls are not only for robots.. in a good one, eg in emacs, you will have excellent history and editability, making them good for exploration
15:26:43 <davidkart> but racket is for lisp ?
15:26:55 <monochrom> I'm sure you can read and send email in emacs, too.
15:27:00 <mjrosenb> sm: the editability is still suspect, since you still need to go and propagate any changes through all uses since then.
15:28:00 <monochrom> in fact, I once did exactly that, using the gnus package.
15:28:35 <sm> mjrosenb: I don't see that
15:28:38 <monochrom> doesn't mean that I suddenly revisionist-redefine "editor" to mean: "a nice editor should let you read and send email"
15:28:57 <adu> monochrom: like emacs?
15:29:28 <mjrosenb> sm: are you talking about just editing definitions in the repl, or editing definitions in a file, then reloading the file?
15:31:05 <sm> neither, no matter
15:34:28 <Profpatsch> Huh?
15:34:40 <Profpatsch> What’s the difference between haskell.org and haskell-lang.org ?!
15:34:50 <monochrom> different authors
15:34:53 <hpc> absolutely nothing, except for all the differences
15:35:02 <Profpatsch> It looks like FP Complete is doing the -lang one
15:35:11 <monochrom> all human problems can be explained by human factors
15:35:18 <hpc> one of those websites is both the same
15:35:43 <davidkart> it's not working : http://pastie.org/10903565 why ?
15:36:08 <monochrom> what does "not working" mean?
15:36:17 <sm> I wouldn't use a repl to enter a large program either, now. But I remember doing it a lot back in the 80s
15:36:33 <rmutt> line 2 looks like it should be x==y
15:36:39 <hpc> sm: that wasn't a repl, it was ed :P
15:36:42 <Profpatsch> Is that FP Complete undermining the community?
15:36:43 <rmutt> rather than x=y
15:36:47 <sm> it was commodore basic! :)
15:36:50 <monochrom> have you written software for other people to use, and provide tech support to those users?
15:37:08 <sm> typing in games from magazines
15:37:10 <monochrom> when they tell you "not working" about your software, what do you do?
15:37:12 <davidkart> rmutt: ok
15:37:36 <davidkart> monochrom: I hit them with a keyboard until they stop telling « not working » but they are in fact not working themselves.
15:37:55 <rmutt> also you need to uncomment the base cases (matchingpairs [] [] etc), but put them before the general case
15:37:59 <monochrom> ok, so should I hit you with a keyboard?
15:38:05 <davidkart> Then I just relax
15:38:13 <davidkart> monochrom: it may help
15:38:29 <davidkart> I was just not sure if == was the right comparison operator
15:38:34 <rmutt> yeah ==
15:38:40 <sm> Profpatsch: no
15:38:58 <rmutt> actually i'm dumb the order of the function definitions is fine, but you'll get an error if the base cases are commented out
15:39:07 <Profpatsch> I don’t see a great difference between the two sites, though.
15:39:20 <sm> read the big reddit thread for more details
15:39:28 <Profpatsch> It’s very confusing, though.
15:39:30 <hpc> Profpatsch: oh, just remembered this was discussed in -offtopic this morning, there was a dispute about haskell.org using a theme that was made for it
15:39:40 <sm> not really
15:39:51 <hpc> oh this is different?
15:40:27 <sm> (Profpatsch)
15:40:32 <Profpatsch> sm: Can‘t find it https://www.reddit.com/r/haskell/search?q=haskell-lang.org&restrict_sr=on
15:40:49 <sm> https://www.reddit.com/r/haskell/comments/4ruqbl/new_haskell_community_nexus_site_launched/?sort=new
15:41:19 <monochrom> if you don't accept that this is about a power struggle between humans, you will be confused.
15:41:50 <davidkart> if it helps you relax
15:42:04 <davidkart> rmutt: the rest I worked out
15:42:09 <Profpatsch> Since the content is now mainly the same, it’s kind of moot.
15:42:10 <davidkart> it is fine 
15:42:22 <Profpatsch> I wonder what SPJ thinks about this. He probably doesn’t care.
15:42:34 <rmutt> davidkart: sounds good :)
15:43:25 <davidkart> many thanks rmutt
15:43:47 <davidkart> I would like to know if it is possible to have some dumb unit test checking in a program ? 
15:44:01 <davidkart> Like to check that sum [1..3] = 6
15:44:09 <davidkart> actually sum [1..3]==6
15:44:14 <monochrom> yes, write a function that does the test.
15:44:29 <monochrom> or sometimes s/function/definition.
15:44:40 <davidkart> but how would I have the compiler throw me an error if my test goes wrong ?
15:44:49 <monochrom> define "x = sum[1..3]==6". then you can evaluate x in the repl.
15:45:03 <monochrom> no, compiler won't do that
15:45:06 <kadoban> There's also some helpers to make that nice, such as quickcheck (for more interesting checks) and hspec, etc.
15:45:59 <davidkart> ok, Ill keep that in mind.
15:46:21 <Gurkenglas> How do I tell stack to turn some package into a local project? (so i can play with its examples)
15:46:25 <monochrom> there is a way you can set things up so that "cabal test" runs your tests.
15:47:08 <kadoban> Gurkenglas: stack unpack you mean?
15:47:09 <mgsloan> Gurkenglas: Run "stack unpack pkg-name", and then add the dir to your list of "packages"
15:48:21 <Gurkenglas> Thanks. 'list of "packages"'?
15:48:46 <hpc> it's a field in stack.yaml
15:49:27 <Gurkenglas> Ah you mean make a project, go in there, stack unpack, then modify the stack.yaml
15:49:44 <hpc> er
15:49:54 <hpc> oh
15:50:08 <Gurkenglas> Why not just stack unpack, then go in there and ghci the example .hs files?
15:50:17 <hpc> can you maybe download the package with cabal, then "stack init" or something?
15:50:21 <mgsloan> Gurkenglas: Yeah, or "stack unpack pkg-1.0; cd pkg-1.0; stack init"
15:50:21 <mgsloan> yeah
15:50:33 <hpc> i know "cabal init" figures out a bunch of stuff on existing code
15:51:22 <mgsloan> Yeah, stack init picks a stack.yaml configuration. It can even call out to cabal-install's solver, if need be
15:52:33 <Gurkenglas> "stack ghci Composition.hs" "Error parsing targets: Directory not found: Composition.hs" hmmm why would that take a directory?
15:53:15 <mgsloan> Gurkenglas: It's planned https://github.com/commercialhaskell/stack/issues/1361
15:53:32 <mgsloan> The reason is that "stack ghci" takes targets just like "stack build" to determine the configuration which is loaded
15:53:58 <mgsloan> It is not exactly trivial, but certainly doable, to figure out which components to use for configuration given a particular filepath
15:54:07 <Gurkenglas> so ill put the .hs in a directory and run stack ghci on that?
15:54:28 <mgsloan> You might just want "stack exec ghci" and then ":load Composition.hs"
15:55:27 <mgsloan> If you do want to use some configuration, do "stack ghci TARGET --no-load --no-build" and then  ":load Composition.hs"
15:56:14 <mgsloan> It's definitely on the agenda at some point hopefully soon to make --no-build entirely unnecessary, and also allow loading a filepath.  "stack ghci" still has a little ways to go before it's super user friendly
15:56:18 <Gurkenglas> It says it cant find a module (which is from that project), i did "stack install quickspec" (that project) before doing the stack unpack thing, is that not enough?
15:56:43 <hpc> oh man, if stack ghci worked perfectly
15:56:46 <mgsloan> Try "stack ghci --package quickspec --no-load --no-build"
15:57:04 <mgsloan> hpc: Soon (ish)! :D
15:57:31 <mgsloan> Of course, there is no such thing as it working 100% perfectly, not without ghc changes allowing ghci to load multiple packages 
15:57:43 <hpc> heh
15:58:21 <Gurkenglas> "C:\Users\Gurkenglas\quickspec-0.9.6\examples>stack ghci --package quickspec --no-load --no-build" lists stack's usage
15:58:38 <hpc> from the perspective of deving on windows stack is already really good, too (my linux box is a 2006 craptop and sometimes i need the hardware)
15:59:39 <mgsloan> Gurkenglas: Do you have an old stack version?  Latest is 1.1.2
15:59:50 <Gurkenglas> Probably
16:00:04 <Gurkenglas> 0.1.5.0
16:00:18 <mgsloan> :O How did you get that?  Just installed it a long time ago?
16:00:29 <mgsloan> We gotta add some stuff to check for new versions
16:00:34 <Gurkenglas> ya havent touched it in a while i usually dont do that interface stuff
16:00:43 <Gurkenglas> letlpaste+lambdabot is usually enough
16:02:06 <davidkart> mmh, could you tell me why my program is not working ? http://pastie.org/10903583
16:02:23 <mgsloan> Gurkenglas: Btw, "stack upgrade" should be sufficient to get the latest
16:02:35 <davidkart> ha no it is working actually sorry.
16:03:39 <Gurkenglas> btw davidkart line 6 is superfluous
16:04:14 <Gurkenglas> Also you can write that without recursion. Hint: t <- ts
16:04:36 <davidkart> ok
16:04:42 <davidkart> wo recursion ?
16:05:02 <davidkart> ha yes you mean as a comprehension list
16:05:23 <davidkart> it's not good to do recursion ?
16:05:46 <mjrosenb> davidkart: there is absolutely nothing wrong with recursion.
16:05:52 <Gurkenglas> recursion is very powerful. Each time the reader sees recursion, he has to mentally prepare for eldritch magics. (Seen the ackermann function?)
16:06:30 <Gurkenglas> If you can write your code in less powerful ways, the experienced reader grasps it more quickly.
16:07:00 <mjrosenb> Gurkenglas: personally, I like the q function from G.E.B.
16:07:30 <mjrosenb> Gurkenglas: mostly because it isn't even immediately obvious that the function is well defined.
16:09:16 <mjrosenb> > let {q 0 = 1; q 1 = 1; q n = q (n - (q(n-1)) + q (n - q(n-2))} in map q [1..15]
16:09:18 <lambdabot>  <hint>:1:62: parse error on input ‘}’
16:09:22 <mjrosenb> bah.
16:09:28 <Gurkenglas> you mean total?
16:09:47 <mjrosenb> > let {q 0 = 1; q 1 = 1; q n = q (n - (q(n-1))) + q (n - q(n-2)))} in map q [1..15]
16:09:49 <lambdabot>  <hint>:1:63: parse error on input ‘)’
16:10:33 <mjrosenb> > let {q 0 = 1; q 1 = 1; q n = q (n - (q(n-1))) + q (n - q(n-2))} in map q [1..20]
16:10:36 <lambdabot>  [1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12]
16:12:00 <mjrosenb> Gurkenglas: probably?  it'll always terminate, just it isn't obvious that you'll never attempt to calculate q(-1), which is never given in the definition.
16:12:24 <Gurkenglas> Surely easily induced.
16:13:33 <mjrosenb> here's the first 30, lambdabot likely would have timed out: [1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,20]
16:14:18 <hpc> what a weird series
16:14:41 <Gurkenglas> What how could that possibly time out
16:14:47 <mjrosenb> Gurkenglas: I'm all eyes if you can write one.
16:15:06 <mjrosenb> Gurkenglas: because it takes time 3^n or so?
16:15:33 <Gurkenglas> butbutbut each recursive step adds one to the total at least
16:15:57 <mjrosenb> with n=30
16:16:05 <geekosaur> "time out" does not imply "recurses endlessly"
16:16:10 <mjrosenb> granted, you can write it much more efficently, but I did not.
16:16:16 <geekosaur> it can just be very expensive to compute
16:16:32 <mjrosenb> > let {q 0 = 1; q 1 = 1; q n = q (n - (q(n-1))) + q (n - q(n-2))} in map q [1..30]
16:16:35 <hpc> > [1..] !! 1982346981723469871236491827 -- timeout, but obviously terminates
16:16:37 <lambdabot>  mueval-core: Time limit exceeded
16:16:39 <lambdabot>  mueval-core: Time limit exceeded
16:16:57 <Gurkenglas> oh lol it didnt memoize and you make multiple recursive calls
16:17:07 <Gurkenglas> thats like saying computing fibonacci times out
16:17:14 <mjrosenb> Gurkenglas: I make /lots/ of recursive calls.
16:17:27 <Gurkenglas> no more than naive fibonacci
16:17:31 <mjrosenb> and there isn't a simple memoizing definition like there is for fibonacci.
16:17:41 <Gurkenglas> hmm lemme see
16:17:45 <mjrosenb> Gurkenglas: yes? it makes 4 recursive calls rather than 2.
16:17:51 <hpc> it's not obvious just from the structure of the definition which previous elements get used
16:18:09 <Gurkenglas> <insert O notation>
16:18:23 <tnks> I just realized that I've not yet read anything to help explain the pre-existing module names in Haskell.
16:18:37 <hpc> (though you can certainly memoize out the n-1 and n-2 calls)
16:18:59 <tnks> to help people navigate and contribute.
16:19:14 <hpc> tnks: you mean like what goes under Data vs Control vs System?
16:19:23 <tnks> hpc: yeah.
16:19:35 <tnks> something like a filesystem hierarchy guide.
16:19:43 <hpc> it's a very fuzzy distinction that you really just deduce with experience
16:19:45 <tnks> I tried looking at the wiki, but must have missed it if it's here.
16:19:57 <hpc> it's not terribly formal and there's a lot of things that could go in either Data or Control
16:20:12 <tnks> hpc: right, even that one simple distinction is confusing.
16:20:47 <tnks> there's an inclination to just keep things really flat with a "project name"
16:21:07 <mjrosenb> tbf, Data vs Control is probably the /most/ confusing distinction.
16:21:13 <tnks> but I'll follow the hierarchy if I can understand it.
16:21:24 <Gurkenglas> > let qs = 1 : 1 : map (\n -> ((qs !! (n - (qs !! (n-1)))) + (qs !! (n - (qs !! (n-2)))))) [2..] in qs
16:21:27 <lambdabot>  [1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,...
16:21:28 <tnks> is there even a good list of what's all out there?
16:22:10 <Gurkenglas> > let qs = 1 : 1 : map (\n -> ((qs !! (n - (qs !! (n-1)))) + (qs !! (n - (qs !! (n-2)))))) [2..] in qs !! 1000
16:22:12 <lambdabot>  533
16:22:43 <mjrosenb> Gurkenglas: nice.  certainly more complicated than let fibs = 1:1:zipWith (+) fibs (tail fibs) :-p
16:23:12 <hpc> tnks: i expect the basic idea behind Data vs Control was that things in Data are for how you would store information, and Control is for writing ways to structure your code
16:23:18 <mjrosenb> let qs = 1 : 1 : map (\n -> ((qs !! (n - (qs !! (n-1)))) + (qs !! (n - (qs !! (n-2)))))) [2..] in drop 2000 qs
16:23:28 <hpc> tnks: but laziness complicates that a bit, even with something obvious like Data.List
16:23:32 <hpc> @quote waiting.to.happen
16:23:32 <lambdabot> Cale says: You should think of lists as being like loops which are waiting to happen.
16:23:33 <mjrosenb> > let qs = 1 : 1 : map (\n -> ((qs !! (n - (qs !! (n-1)))) + (qs !! (n - (qs !! (n-2)))))) [2..] in drop 2000 qs
16:23:35 <lambdabot>  [1046,1052,1032,944,983,1010,1162,827,1075,1067,966,994,1060,977,979,1092,95...
16:24:00 <hpc> like... that actually
16:24:13 <hpc> qs :: [Int], but it's definitely not being used as data
16:24:23 <hpc> it's an infinite stream of numbers following some computation
16:24:39 <hpc> which is the kind of usage which you might logically put in Control
16:25:23 <tnks> hpc: yeah, I'm unimpressed by the distinction.
16:26:09 <hpc> /usually/ what actually ends up happening is that type classes and their associated functions go in Control, data definitions and their associated functions go in Data
16:26:19 <hpc> but not always
16:26:47 <hpc> so you just memorize some module names and get a very fuzzy feel for what is named what
16:26:54 <Gurkenglas> > let qs = 1 : 1 : zipWith3 (\n p pp -> qs !! (n - p) + qs !! (n - pp)) [2..] qs (tail qs) in qs -- better
16:26:56 <lambdabot>  [1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,...
16:26:56 <hpc> and do your own thing for code that doesn't end up on hackage
16:30:45 <Gurkenglas> > let qs = 1 : 1 : zipWith3 (\n -> on (+) $ (qs !!) . (n-)) [2..] qs (tail qs) in qs -- less namesy. the n has grandfather rights i guess
16:30:47 <lambdabot>  [1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,...
16:31:31 <hpc> that n looks really hard to @pl out
16:33:45 <Gurkenglas> > let qs = 1 : 1 : zipWith3 (on (+) . ((qs !!) .) . (-)) [2..] qs (tail qs) in qs -- nah
16:33:47 <lambdabot>  [1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,...
16:35:56 <hpc> sections of (.) fall under "really hard" ;)
16:37:39 <mjrosenb> Gurkenglas: anyhow, still feel up to proving that it is a total function?
16:52:49 <athan> Anyone here know if it's feasible for unordered-containers' HashMap to allow for an optimized `deleteMany :: HashSet k -> HashMap k a -> HashMap k a`?
16:52:58 <athan> s/feasible/worth while
17:05:26 <Gurkenglas> Oh hey not easily induced, the growth of q is just slow enough to keep itself sublinear, i see the problem now
17:09:53 <heebo> hello whats a good date library to use
17:13:36 <pavonia> heebo: "time" is the standard one
17:14:25 <heebo> thanks im looking at it now, seems  a little thin on documentation
17:18:24 <Gurkenglas> http://lpaste.net/4769041495460151296 -- mgsloan, thats after the upgrade
17:34:37 <sm> heebo: tis, it's good though
17:38:48 <sm> tnks: you're right, I don't think such a doc has been written either
17:39:05 <sm> good idea
17:40:11 <nitrix> Am I breaking things if using reactive-banana within a `MomentIO ()` do block, I'm doing a `reactimate` that `fire` (Handler a) more values to another Event?
17:40:56 <nitrix> I think the docs says the reactimate aren't guaranteed to be ordered, but other than that, it's supposedly still okay. But is it idiomatic?
17:47:17 <miscyb> What would be a good way to make a simple download manager? I want to be able to have a list of asynchronous IO actions that I can communicate with (send them commands like pause and ask about download status, etc.). So basically a bunch of two way channels between the main thread and a list of async IOs. My idea is to make some kind of two way channel out of MVars and then forkIO over a list. Does anyone
17:47:20 <miscyb> have examples of something like this or an idea to get started?
17:49:38 <nitrix> Second question, I currently have one (AddHandler SDL.EventPayload, Handler SDL.EventPlayload) for my entire game, which is fed SDL events as inputs. All the other r-b events are created and combined in the game's network description based off that. Is that too idiomatic? I was expecting way more inputs to be fed to that network graph, but I suppose SDL is taking care of the bulk of the work for me because
17:49:41 <nitrix> it has its own event system too.
17:50:37 <nitrix> Supposedly I'd need a second fromAddSource if I had a new external sources?  (e.g. TCP/IP networking, etc)
17:50:47 <nitrix> I'm just surprised that that's all that's needed ._.
18:01:02 <tnks> beginner question:  you can't make a type class instance for a type alias, right?  It has to be defined with `data` or `newtype`?
18:01:44 <geekosaur> there's an extension to enable it, but it's disabled to remind you that it *is* an alias --- it will not get its own typeclass instance
18:02:05 <Cale> tnks: that's correct
18:02:23 <tnks> Cale: thanks, I thought so, but it's hard to Google affirmation.
18:02:29 <Cale> and yeah, you can enable the extension, but it doesn't let you do anything you couldn't do without the extension just by unfolding the type synonym
18:02:51 <tnks> what's the name of the extension?
18:03:00 <tnks> if you don't know, it's fine.
18:03:18 <Cale> TypeSynonymInstances
18:03:23 <tnks> cool, thanks.
18:11:36 <tnks> actually, it just occurred to me that doesn't this introduce an instance in kind of an orphaned way?
18:12:04 <Cale> tnks: It introduces whatever instance you obtain by rewriting the type synonym away
18:12:27 <tnks> right, got it.
18:12:30 <Cale> So, it's not necessarily an orphan, it could very well be that either the actual type or the class are defined in the module
18:12:33 <tnks> in my case, it will be orphaned.
18:12:39 <tnks> so maybe a newtype is best after all.
18:12:58 <Cale> Which class?
18:13:11 <Velizar> Is there a function to turn [(a, b)] into ([a], [b])? Like so: [(1, 10), (2, 20), (3, 30)] will become ([1, 2, 3], [10, 20, 30])
18:13:18 <tnks> for me a specialization of ReaderT over a Validation.
18:13:40 <tnks> I'm pretty sure I can make a valid Arrow instance for that.
18:14:31 <Cale> You mean MonadReader?
18:14:37 <Cale> ReaderT isn't a class
18:15:02 <Cale> Velizar: unzip
18:15:15 <Cale> > unzip [(1, 10), (2, 20), (3, 30)]
18:15:17 <lambdabot>  ([1,2,3],[10,20,30])
18:15:17 <Velizar> great!
18:16:10 <tnks> Cale: ah sorry, that's the data structure, the classes I'm interested in is Arrow and Applicative.
18:16:21 <tnks> where the Applicative instance collects errors.
18:16:25 <tnks> with the Validation.
18:16:51 <Cale> You should generally be newtyping anything you get from a monad transformer
18:17:14 <tnks> Cale: right, makes sense to me (pretty sure); I was kind of brainstorming as I typed it out.
18:23:39 <mjrosenb> I'm using ghci on OSX, and I've noticed that ^Y and ^Z have the same behaviour
18:23:51 <mjrosenb> I've also heard that this is ghci-specific
18:23:55 <mjrosenb> is there a fix for this?
18:26:18 <geekosaur> I would be surprised if that is ghci-specific. it *is* specific to OS X and *BSD
18:27:10 <geekosaur> (^Y is dsusp --- like ^Z except it takes effect when the program reads it instead of immediately on being pressed. this is sufficiently useless that non-BSDs never bothered with it.)
18:28:54 <geekosaur> well. it may be ghci specific to the extent that readline libraries rarely bother to recognize ^Y and emulate the line-mode behavior. (but I would expect editline to do so because it's from BSD, and Apple's "readline" is BSD editline)
18:29:21 <Welkin> I had to install readline just now to get Love working
18:29:21 <Welkin> :D
18:29:24 <sm> interesting
18:31:12 <geekosaur> (I don't know haskeline internals well enough to know if it recognizes a BSD system with dsusp and handles ^Y accordingly; it sounds like it does, though)
18:32:42 <tnks> is non-empty a good package to get a non-empty list in Haskell?  or is there another one worth considering?
18:32:51 <athan> tnks: Semigroups!
18:32:59 <dibblego> tnks: http://hackage.haskell.org/package/semigroups
18:33:17 <tnks> dibblego: ah, I didn't realize semigroups had that data structure.
18:33:18 <tnks> thanks.
18:34:46 <geekosaur> mjrosenb: in any case, sufficiently recent haskeline has configurable keybindings, see http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
18:43:43 <mjacob> i'm trying to understand why `foldr1 (&&) (repeat False)` terminates, but `foldl1 (&&) (repeat False)` doesn't
18:43:49 <mjacob> isn't `foldl1 (&&) (repeat False)` the same as `False && (foldl1 (&&) (repeat False))` (which terminates)?
18:45:09 <geekosaur> > foldl1 (&&) [a,b,c,d]
18:45:12 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Expr’
18:45:12 <lambdabot>      In the expression: a
18:45:12 <lambdabot>      In the second argument of ‘foldl1’, namely ‘[a, b, c, d]’    Couldn't ma...
18:46:07 <jle`> mjacob: check the definition of foldl1
18:47:03 <Welkin> > foldl1 f [a,b,c] :: Expr
18:47:08 <lambdabot>  mueval-core: Time limit exceeded
18:47:13 <Welkin> > foldr1 f [a,b,c] :: Expr
18:47:17 <lambdabot>  f a (f b c)
18:47:42 <jle`> @src foldl1
18:47:42 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:47:42 <lambdabot> foldl1 _ []     = undefined
18:48:17 <jle`> foldl1 (&&) False = foldl (&&) False (repeat False)
18:48:28 <jle`> mjacob: i think you might be looking at the wrong definition of foldl1
18:48:40 <jle`> foldl1 (&&) (repeat False) is not False && foldl1 (&&) (repeat False)
18:48:49 <jle`> it's foldl (&&) False (repeat False)
18:49:13 <jle`> @src foldl
18:49:16 <lambdabot> foldl f z []     = z
18:49:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:49:33 <jle`> foldl (&&) False (repeat False) = foldl (&&) (False && Fase) (repeat False) = foldl (&&) False (repeat False)
18:49:44 <jle`> it basically evaluates to itself
18:49:47 <jle`> it's an infinite loop
18:49:53 <Welkin> wait
18:49:58 <Welkin> so what is the point of foldl1?
18:50:12 <jle`> it uses the first item of the list as the starting accumulator
18:50:26 <jle`> > foldl1 max [7,1,9,4,0,1,10,6]
18:50:28 <lambdabot>  10
18:50:41 <Welkin> why did it time out when I tried it then?
18:50:44 <Welkin> with Expr
18:50:51 <jle`> lambdabot times out every once in a while, it's an IO thing
18:51:12 <jle`> mjacob: but yeah, if you try evaluating foldl (&&) False (repeat False) by hand, you'll see that it keeps on evaluating to itself...it's an infinite loop
18:51:38 <jle`> foldr (&&) False (repeat False) doesn't, tho ... it evaluates to False && foldr (&&) False (repeat False) = False, so it terminates right away
18:52:02 <mjacob> jle`: yes, it's probably easier to consider foldl instead of foldl1
18:52:37 <jle`> well, you get to foldl if you try to consider foldl1
18:52:42 <jle`> becuase foldl1 is literally defined in terms of foldl
18:52:43 <mjacob> yes
18:56:45 <mjacob> i'll think a bit about this during dinner and come back for further questions
19:08:40 * hackagebot qtah-generator 0.1.0 - Generator for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-generator-0.1.0 (khumba)
19:13:40 * hackagebot qtah-cpp-qt5 0.1.0 - Qt bindings for Haskell - C++ library  https://hackage.haskell.org/package/qtah-cpp-qt5-0.1.0 (khumba)
19:13:42 * hackagebot qtah-qt5 0.1.0 - Qt bindings for Haskell  https://hackage.haskell.org/package/qtah-qt5-0.1.0 (khumba)
19:13:44 * hackagebot qtah-examples 0.1.0 - Example programs for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-examples-0.1.0 (khumba)
19:38:32 <tnks> all right, I've been noodling over this for a while, and couldn't think of a concise way to make this function:  ReaderT r (Compose m (Validation e)) a -> ReaderT r (Compose m (Either e)) a
19:39:17 <tnks> I can do it the crazy slow way, but I thought maybe I could do something like hoist.
19:39:32 <tnks> but hoist requires a monad instance that Validation doesn't have.
19:43:33 <tnks> maybe mapReaderT.
19:51:52 <tnks> (okay, I got it. . . but it bumped me to my next problem)
20:42:58 <jle`> tnks: how about 'coerce' ?
20:43:21 <jle`> if Validation is a newtype wrapper over Either
20:50:48 <dmj`> jle`: coerce? always trying to break the rules I see :] 
21:26:10 <saurabhnanda> Call to help for http://stackoverflow.com/questions/38289927/how-to-do-io-in-a-widget-hamlet-referenced-by-defaultlayout again
21:33:34 <tnks> another begineer question.  I got a Strong Profunctor instance made just fine, but I thought I'd make an Arrow too.
21:33:55 <tnks> but Category annoyingly has it's composition operator named (.).
21:34:49 <tnks> do I have to make all my normal composition calls into GHC.Base..?
21:35:27 <shachaf> Why not (.)?
21:35:37 <shachaf> (Control.Category..), I mean.
21:35:39 <shachaf> (->) is an instance of Category.
21:39:12 <tnks> shachaf: I keep on getting "Qualified name in binding position" when trying to define the instance of (.) for Category.
21:39:44 <tnks> I can't figure out how to import from Category so that I can define (.).
21:40:15 <shachaf> Just use an unqualified name.
21:41:15 <tnks> shachaf: but then I have a conflict with (.)
21:41:34 <tnks> do I have to move (.) to another name?
21:41:47 <tnks> sorry, I mean GHC.Base..
21:45:04 <dibblego> tnks: can you show the code you are trying to write?
21:45:50 <tnks> dibblego: yeah, no problem.  just a moment.
21:47:43 <pavonia> tnks: You import (.) from Prelude qualified
21:48:55 <shachaf> tnks: You don't have to import it unqualified.
21:49:31 <shachaf> You can import Category qualified, and still use unqualified . in the insurance declaration.
21:49:34 <shachaf> instance
21:50:07 <tnks> shachaf: pavonia: dibblego: I'll have a Gist soon; playing around with this and getting it stable.
21:51:45 <pavonia> shachaf: Does this even work if you have two functions with the same name from different typeclasses?
21:52:26 <alphonse23_> does anyone here know yesod well?
21:53:08 <alphonse23_> how would one get a type ‘[Char]’ to convert to ‘HandlerT App IO Text’
21:53:09 <alphonse23_> ?
21:53:33 <dibblego> probably with return and {-# LANGUAGE OverloadedStrings #-}
21:53:43 <athan> blast dibblego beat me!
21:53:53 <alphonse23_> example?
21:54:02 <dibblego> return
21:54:05 <athan> return "foo" :: HandlerT App IO Text
21:54:15 <dibblego> :: [Char] -> HandlerT App IO Text
21:54:16 <alphonse23_> can I use a let instead?
21:54:19 <shachaf> pavonia: Yes.
21:54:26 <shachaf> @where yesod
21:54:26 <lambdabot> Web Framework - #yesod - <http://yesodweb.com/>,<http://www.yesodweb.com/page/quickstart>,<http://www.yesodweb.com/book>
21:54:37 <shachaf> Probably the people in that channel would know more.
21:54:47 <athan> where only the string literal is converted to Text, if you already have a String, then you'd have to use Data.Text.pack or something
21:54:56 <alphonse23_> I've asked in there, but it's not very active.
21:55:01 <shachaf> OverloadedStrings won't make return have that type.
21:55:18 <dibblego> return . Text.pack
21:55:34 <alphonse23_> does return have to be associated with a function?
21:55:44 <athan> alphonse23_: Use hoogle!
21:55:45 <nshepperd_> note everything you can do with OverloadedStrings you can also do with fromString
21:55:48 <nshepperd_> :t fromString
21:55:50 <lambdabot> IsString a => String -> a
21:55:55 <athan> alphonse23_: return _is_ a function
21:55:59 <athan> @type return
21:56:00 <lambdabot> Monad m => a -> m a
21:56:08 <athan> it creates a pure monadic value
21:56:22 <athan> er a monadic value out of a plain, pure data type
21:56:36 <athan> so in your case, `return :: Text -> HandlerT App IO Text`
22:12:42 <tnks> dibblego: I got tired playing around with arrows. . . strong profunctors are enough pretty sure.
22:12:48 <dibblego> heh
22:15:12 <shachaf> If your think is a category, it would be good to give it a Category instance.
22:15:20 <shachaf> I wouldn't worry about Arrow.
22:16:55 <tnks> shachaf: yeah, I'm thinking the same.
22:18:32 <tnks> the real DSL I want is (>>>) and (<<<)
22:22:04 <dibblego> (<<<) is just (.)
22:32:23 <tnks> dibblego: right, but that means I need to define the Category at least.
22:32:27 <tnks> even if not the Arrow.
22:32:47 <tnks> but the good part is that I figured out my hiccup with qualified imports.
22:32:49 <tnks> so that's fine.
22:32:53 <dibblego> yes, I agree with shachaf, define the Category (care little about the Arrow)
22:33:12 <dibblego> FWIW, I always use {-# LANGUAGE NoImplicitPrelude #-}
22:33:29 <tnks> dibblego: yeah, I'm doing that too.
22:33:58 <tnks> I'm using Stephen Diehl's Protolude project, because it seems in good taste.
22:41:23 <travism> if I do xs <- getArgs then try to convert them to a list of ints doing "map read xs" why would prelude say no parse? but if do read "1" :: Int it prints it fine? It cant infer that "1" is a Integer?
22:42:38 <dibblego> without a type, read is likely to be defaulting
22:42:56 <dibblego> to ()
22:42:57 <liste> travism: the type isn't infererred from the context `read' is used in, not the content of the string
22:43:06 <liste> is inferred from*
22:43:19 <phanimahesh> travism: read alwaays needs a type. The same stringcan be interpreted in many ways.
22:43:30 <travism> Ah I see
22:43:59 <travism> So how would you properly convert them to a list of ints?
22:44:01 <phanimahesh> "1" can be considered a string, or an Integer, or a Double, or whatever you want it to be.
22:44:08 <phanimahesh> Just add a type annotation.
22:44:21 <phanimahesh> xs :: [Int] works
22:44:43 <phanimahesh> or, use xs in some way so that the type system can infer its type as [Int].
22:45:04 <travism> doing  sort $ map read xs :: [Int] errors
22:45:30 <phanimahesh> sorry, not xs. map read xs.
22:46:07 <phanimahesh> read's output should have an annotation. It's argument is always a string.
22:46:43 <phanimahesh> use a temporary variable to store map read xs, and annotate it.
22:47:16 <phanimahesh> I hope I'm not confusing you. :P
22:47:25 <travism> I am jut a bit lol
22:47:29 <travism> I appreciate the help though
22:50:47 <phanimahesh> I'll try again. read can take a string and return any type for which Read has been derived or implemented.
22:51:38 <phanimahesh> so if the return tupe of read is not known to the compiler, it can not pick which implementation of read to use.
22:52:19 <phanimahesh> We can either use the result of applying read in some way so that type inference knows unambiguously that we need Ints,
22:52:41 <phanimahesh> or we can add an explicit type annotation.
22:53:24 <travism> Oh so the way in which we use read will determine it and in my case it wasn't able to
22:53:54 <phanimahesh> if ys = sort $ map read xs, adding ys :: [Int] will be sufficient, because sort works on [a] -> [a], and
22:55:02 <phanimahesh> travism: Yep. Exactly.
22:55:06 <travism> I basically did it as map (\x -> read x :: Int) xs
22:55:10 <travism> worked finally :)
22:55:36 <phanimahesh> Cool.
22:55:40 <travism> Thanks again
22:55:46 <phanimahesh> You're welcome. :)
23:02:40 <jle`> in real life you usually don't use read with a type annotation
23:02:53 <jle`> type inference usually kicks in
23:03:18 <jle`> > False || read "True"
23:03:20 <lambdabot>  True
23:24:11 <bollu> > ("123", "456") & _1 <%~ length
23:24:14 <lambdabot>  (3,(3,"456"))
23:24:20 <bollu> now, assuming I only want the result
23:24:35 <bollu> what's the right lens combinator?
23:24:50 <bollu> I want to extract the _1, run length on it, and discard the structure itself
23:24:53 <bollu> just want the result
23:25:18 <bollu> I'm looking for some kind of infix fmap in lens
23:26:42 <bollu> I'm stupid, I got it
23:26:51 <bollu> ("123", "456") ^ _1 &  length
23:26:59 <bollu> I can use the getter and then chain the function call
23:28:13 <bollu> :t (#)
23:28:14 <lambdabot> parse error on input ‘)’
23:28:19 <adarqui> do any of you ever get 'depressed' when your haskell projects becomes very large, and then compile times are just so slow that it becomes painful?
23:28:46 <bollu> how does lens # work? and, well, can I convert a lens-like function that uses # down to a regular function?
23:29:07 <shachaf> :t ( # )
23:29:09 <lambdabot> AReview t b -> b -> t
23:29:21 <shachaf> (#) is also called review.
23:29:27 <bollu> I'm using Lens-Aeson, and want to "drop" the _String setter down to value level
23:29:33 <bollu> down to a regular function*
23:29:34 <bollu> https://hackage.haskell.org/package/lens-aeson-1.0.0.5/docs/Data-Aeson-Lens.html
23:29:50 <bollu> shachaf: okay, but.. how do I read the type?
23:29:59 <shachaf> :t (^.)
23:30:00 <lambdabot> s -> Getting a s a -> a
23:30:10 <shachaf> The same way you read that type, more or less.
23:30:16 <bollu> shachaf: I'm muddling along by brute forcing lens and trying to fit the parts. I've read a lot of tutorials, but I still don't get it
23:30:55 <bollu> shachaf: is there like, some kind of structured way to learn lens?
23:31:18 <shachaf> Lucky for you, I came up with this representation for Review. So I can probably answer questions.
23:31:39 <shachaf> I don't know if there's a guide or anything like that.
23:31:40 <bollu> shachaf: neat! Okay, so, I "get" how Getting works (loosely)
23:31:51 <bollu> shachaf: by using "const" to allow no mutation but simply peeking
23:32:16 <shachaf> Well, there's never any mutation.
23:32:19 <bollu> so what's the underlying Review type? 
23:32:28 <bollu> shachaf: right, like, "pretend mutation"
23:32:43 <shachaf> There's as much mutation as there is in e.g. mapM.
23:32:50 <bollu> the Lens library seems to say this: type Review s t a b = forall p f. (Profunctor p, Bifunctor p, Settable f) => Overloaded p f s t a b
23:33:01 <shachaf> Anyway, you might be best off thinking about pure profunctor lenses first.
23:33:36 <shachaf> lens represents lenses and traversals and so on as (a -> f b) -> s -> f t
23:33:49 <shachaf> Where you can do various things for various choices of f.
23:33:54 <bollu> shachaf: okay, um, can you give me a crash course? Profunctor = covariant in first, contra in second argument right?
23:34:01 <shachaf> The other way around.
23:34:05 <bollu> ah okay
23:34:09 <shachaf> (But really there are only two or three choices of f that the library uses.)
23:34:12 <bollu> shachaf: any intuition for the order?
23:34:18 <shachaf> It's the same order as (->)
23:34:22 <dibblego> (->) is an instance
23:34:31 <shachaf> Profunctor is a generalization of (->)
23:34:40 <bollu> oh, hm. right.
23:34:46 <bollu> shachaf: that makes sense :)
23:35:08 <shachaf> Let's talk about Iso before Prism/Review.
23:35:29 <shachaf> You want to represent an isomorphism -- i.e. a pair of functions :: (s -> a, b -> t) -- as an optic.
23:35:30 <bollu> okay, sure
23:35:54 <shachaf> Iso s t a b = forall f. ... f => (a -> f b) -> s -> f t obviously won't work, no matter how you constrain f.
23:36:07 <bollu> shachaf: um, I always forget what s, t, a, and b are
23:36:17 <bollu> which one is the "larger" part and which is the "smaller" part
23:36:17 <bollu> ?
23:36:30 <shachaf> Oh. Then maybe it's better to talk about lenses and traversals a bit first. :-)
23:36:38 <bollu> sure :)
23:37:05 <shachaf> Well, in the case of a lens, s "contains" an a (and some other data).
23:37:18 <shachaf> Lens s t a b = s -> (a, b -> t)
23:37:49 <shachaf> This isn't the place I would start if I was talking about lens from scratch.
23:38:14 <bollu> shachaf: I've seen the transformation into the costate comonad bit
23:38:19 <bollu> shachaf: that was really cool
23:38:21 <shachaf> I think that's a red herring.
23:38:44 <bollu> shachaf: really? >_< oh damn. I was hoping that would be used
23:38:48 <bollu> shachaf: okay, go on 
23:39:01 <shachaf> Well, I don't know how much you've seen.
23:39:18 <bollu> shachaf: I've seen that you can rewrite a getter/setter pair into a costate comonad
23:39:24 <bollu> and how that can somehow be used as a "general setting"
23:39:40 <shachaf> Forget about store comonads. I don't think it'll help you here.
23:39:41 <bollu> plus I've seen the formalization by taking fmap (a -> b) -> f a -> f b
23:39:48 <bollu> and then killing the f
23:39:58 <shachaf> Yes, that's probably a good intuition.
23:39:59 <bollu> to get (a -> b) -> s -> t? I'm not sure of the order
23:40:03 <shachaf> That's the order.
23:40:14 <bollu> oh, okay, cool
23:40:25 <shachaf> Setter s t a b = (a -> b) -> s -> t
23:41:00 <bollu> hm, all right. so it's saying that "s" has a smaller part "a", which when you transform to "b" gives out "t"?
23:41:07 <shachaf> And Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
23:41:15 <shachaf> I.e. it's a generalization of traverse (or mapM).
23:41:23 <bollu> shachaf: that's existential over the f right?
23:41:29 <shachaf> No, it's universal.
23:41:53 <bollu> um, but the type "Traversal" does not witness the f at all?
23:41:58 <shachaf> ?
23:42:35 <bollu> like, for something to be existential, you need to use a type t during construction, but not have the "t" encoded in the actual type signature of the produced type, correct?
23:42:38 <shachaf> If trav :: Traversal s t a b, i.e. trav :: forall f. Applicative f => (a -> f b) -> s -> f t, then trav works for any f you like (as long as it's Applicative).
23:42:53 <bollu> so something like a -> b -> Proxy a is existential because Proxy does not see the "b"
23:43:28 <shachaf> I don't understand what you mean but I don't think it's what existential means.
23:43:40 <bollu> shachaf: okay, this is what I understand of existential
23:43:46 <bollu> shachaf: shall I write it in GADT syntax?
23:43:51 <shachaf> Fortunately existentials are mostly irrelevant here.
23:44:01 <bollu> shachaf: um, can we actually clear up existentials first?
23:44:13 <bollu> shachaf: I'm somewhat new to them, and I'd like to understand them properly :)
23:44:25 <shachaf> GHC doesn't support first-class existentials.
23:44:46 <bollu> shachaf: correct, so we "fake" existentials by using the forall to exists conversion right?
23:44:58 <shachaf> You probably mean that the other way around.
23:45:04 <bollu> right, sorr
23:45:05 <bollu> sorry*
23:45:16 <shachaf> Sometimes we do that. But not in this context.
23:45:21 <bollu> ohh, I see
23:45:28 <bollu> I thought this was also an existential
23:45:37 <bollu> shachaf: Proxy is existential right?
23:45:41 <shachaf> No.
23:46:03 <bollu> shachaf: hmm, why not?
23:46:22 <shachaf> By default. It did nothing to deserve being called existential.
23:46:22 <bollu> shachaf: oh, wait, wrong example.
23:46:31 <bollu> shachaf: let's say I have a type like this:
23:46:40 <bollu> data Existential where create :: a -> Existential
23:46:41 <shachaf> I'm going to paste my paste buffer: Anyway, given a function :: (a -> f b) -> s -> f t, you can't possibly construct a function :: (b -> t)
23:46:42 <athan> shachaf: I've been wondering for some time what first class existentials are. Is it less opaque than `(forall a. a) -> ..` or something?
23:46:46 <bollu> this is existential?
23:47:20 <bollu> shachaf: right, with you so far (can't convert part)
23:47:24 <shachaf> No, it's a syntax error.
23:47:29 <bollu> shachaf: GADT?
23:47:31 <shachaf> With a capital C that would be an existential.
23:47:38 <bollu> right, C
23:47:55 <shachaf> You can also write: data Existential = forall a. Existential a
23:47:58 <shachaf> Same type.
23:48:25 <bollu> shachaf: so this is existential, because the constructor uses an "a" which the type does not know of
23:48:34 <bollu> shachaf: so, you know that "a" exists when you're handed an Existential
23:48:40 <bollu> shachaf: but you don't know which "a" was used
23:48:44 <bollu> shachaf: correct so far?
23:49:03 <shachaf> Types don't know anything.
23:49:05 <shachaf> But sure.
23:49:23 <shachaf> The perspective you should have is probably "who chooses?".
23:49:23 <bollu> okay, now consider the Traversal
23:49:40 <shachaf> data T = T (forall a. a) is also not existential.
23:49:41 <bollu> shachaf: okay, go on
23:49:47 <shachaf> Lots of things aren't existential.
23:50:21 <bollu> shachaf: okay, please explain the "who gets to choose" bit?
23:50:37 <shachaf> "a type appears on the right side of = but not on the left side" isn't a good definition for "existential".
23:51:09 <shachaf> I don't know the best way to approach it.
23:51:12 <shachaf> Let's say you were learning Haskell from scratch.
23:51:24 <bollu> sure
23:51:37 <shachaf> You don't know about polymorphism. You define idChar :: Char -> Char; idChar x = x; idBool :: Bool -> Bool; idBool x = x
23:51:57 <bollu> shachaf: all right
23:51:59 <shachaf> You get tired of that pretty quickly because it's all the same code.
23:52:26 <shachaf> So you learn about a new feature called "forall". You can write "id :: forall a. a -> a; id x = x"
23:52:34 <bollu> correct
23:52:38 <shachaf> And then, anyone who uses id gets to choose which a to use.
23:52:54 <bollu> hm, okay, makes sense. the caller gets to pick, right?
23:52:59 <shachaf> So they can choose a=Int or a=Bool
23:53:02 <shachaf> Yes.
23:53:22 <shachaf> There are always two parties playing a game with each other. You can call them "producer" and "consumer".
23:53:45 <bollu> all right. In this case, who's the producer and who's the consumer?
23:54:00 <shachaf> The producer of id, the person who's writing it, doesn't know what a is. She has to make it work for any choice of a.
23:54:19 <shachaf> The consume of id is in a good position: He can choose a=Int or a=Bool.
23:54:22 <shachaf> consumer
23:54:50 <bollu> right, okay
23:54:52 <shachaf> Let's use an extreme case.
23:54:57 <shachaf> foo :: forall a. a
23:55:24 <bollu> shachaf: okay
23:55:33 <shachaf> The producer of foo has to create a value of type a for any choice of a. The consumer can choose a=Int, a=Bool, a=Void, and she can always make a value for me.
23:55:55 <shachaf> This is an impossible task, of course. So there's no implementation for foo (other than nontermination, in Haskell).
23:56:19 <bollu> shachaf: okay, with you so far
23:56:26 <shachaf> Now look at the other extreme: bar :: exists a. a
23:56:47 <shachaf> That means: The producer has chosen some type a. She doesn't tell us what it is.
23:56:56 <foob> when i type "def f n | n < 1 = 1" at ghci, i get a "parse error on |". is my syntax wrong?
23:57:24 <bollu> shachaf: okay, right, so the consumer should be okay with _whatever_ choice of a
23:57:27 <shachaf> foob: The syntax in ghci is "let def f n | n < 1 = 1; def ... = ..."
23:57:34 <shachaf> So maybe bar = 'a', or bar = True
23:57:44 <foob> shachaf: thanks
23:57:57 <shachaf> But this value is useless to the consumer. He can't do anything with it.
23:58:02 <bollu> shachaf: right
23:58:44 <shachaf> You can represent these types in Haskell with data Foo = Foo (forall a. a), and data Bar = forall a. Bar a
23:58:49 <shachaf> foo :: Foo, bar :: Bar
23:59:17 <shachaf> data T = T Int means that, if x :: Int, T x :: T
23:59:30 <bollu> shachaf: I don't grok that syntax.
23:59:34 <shachaf> data T = forall a. T a means that, for all types a, if x :: a, T x :: T
