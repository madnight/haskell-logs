00:00:09 <Koterpillar> milesrout: stack is www.haskellstack.org, and is better than cabal sandbox for most tasks
00:00:41 <ertes> for some value of "better" =)
00:00:58 <Athas> Most values!  Stack is awesome.
00:01:09 <dysfun> can we please not have this argument again? stack is great but some people hate it
00:01:40 <milesrout> dysfun: pretty sure everything I’ve ever seen you say here is an attempt to be diplomatic about disagreements in the haskell community. respect+
00:01:56 <milesrout> okay i installed stack
00:01:57 <dysfun> really?
00:02:03 <adarqui> my life has gotten easier since using stack.. cabal before sandboxes was real brutal.. that's when i was just starting to learn haskell ;f
00:02:04 <Koterpillar> dysfun: I was just trying to summarize it; if you have a better one-line explanation please share
00:02:53 <dysfun> Koterpillar: easier for beginners, provides per-project isolation and stable package sets to avoid dependency issues
00:02:54 <ertes> i'm not a huge fan of this "must… use… stack" trend
00:03:19 <dysfun> yes, but on the other hand, do you really want to guide someone through cabal hell?
00:03:21 <milesrout> okay but assuming I want to use stack
00:03:29 <milesrout> how do I? best doc source?
00:03:38 <Koterpillar> milesrout: the official stack doc which I linked
00:03:49 <ertes> dysfun: i don't think cabal hell is something everybody encounters…  sandboxes should work for most people, and deployment is not a concern for many people
00:03:50 <dysfun> yeah, the stack docs have great installation instructions
00:04:03 <ertes> dysfun: in other words: for most people stack is just extra complexity
00:04:07 <Koterpillar> ertes: agree, I was trying to only provide facts
00:04:09 <dysfun> but it's not
00:04:15 <Koterpillar> err, not with the last sentence :)
00:04:20 <dysfun> time and time again people have difficulties
00:04:29 <dysfun> it's like you just dismiss everyone else because it worked for you
00:04:53 <Koterpillar> ertes: how would you summarize what stack is doing?
00:04:55 <ertes> dysfun: are you sure you're not doing the exact opposite?
00:04:57 <adarqui> milesrout: there's a big guide: https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md .. but in general, stack init project, cd project, stack build, stack test
00:05:00 <adarqui> etc
00:05:05 <adarqui> but need to learn about stack.yaml
00:05:12 <ertes> Koterpillar: reproducible builds and deployment
00:05:12 <alpounet_> well, stack has its quirks too, there is no perfect solution here
00:05:13 <dysfun> ertes: on average, people have fewer difficulties with stack than the alternatives
00:05:24 <dysfun> especially beginners
00:05:53 <adarqui> <- beginner, stack has definitely been smoother
00:05:54 <Koterpillar> ertes: that disregards "stack init" though
00:05:56 <milesrout> i have a massive hard-on for build tools
00:06:42 <ertes> dysfun: that may be true, but if cabal sandboxes are already working for someone, why would the answer to, "how do i list installed packages", be "must… use… stack!!111"?
00:06:51 <ertes> that's just fanboy/-girlism
00:06:59 <dysfun> well i arrived late to the discussion
00:07:14 <Koterpillar> ertes: the answer to that question was given before everyone jumped to stack
00:07:36 * hackagebot coordinate 0.1.0 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.1.0 (TonyMorris)
00:07:36 * hackagebot coordinate 0.1.1 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.1.1 (TonyMorris)
00:08:02 <dysfun> anyway, either use stack or don't. this is the joy of open source
00:08:13 <milesrout> ertes: given that I have typed exactly one command starting with ‘cabal sandbox’ into my terminal *ever*, getting started with a more modern build system seems like a good idea
00:08:34 <dysfun> milesrout: well, stack uses cabal
00:08:46 <milesrout> i’m going to read the guide
00:08:50 <milesrout> then decide for myself.
00:08:51 <ertes> milesrout: you have at least two options then =)
00:09:10 <Koterpillar> let's throw Docker into the mix, now you have three
00:09:11 <dysfun> and fwiw, i used cabal sandboxes until stack got usable
00:09:13 <Koterpillar> oh wait, Nix
00:09:19 <Koterpillar> dysfun: ++
00:09:21 <adarqui> ertes: how active is the ghcjs/haskell web community from your experience? just wondering, in general. i guess it's subjective but just wondering..
00:09:23 <dysfun> Koterpillar: but stack can do docker *and* nix
00:09:35 <dysfun> (okay, that was pure trolling)
00:11:05 <dysfun> hrm, maybe i can add guix support to stack
00:12:46 <ertes> nerdgasming about stack, but making fun of nix…  welcome to the wonderful world of double standards
00:13:17 <adarqui> one thing with purescript.. it's strictness.. i bet i have soooo many performance issues because i code 'lazy'.. even still, the purescript generated code runs really fast in my browser and on my OLD kindle paperwhite
00:13:34 <dysfun> ertes: i'm using nix, i think that entitles me
00:13:58 * dysfun is gradually replacing NixOS with guix
00:14:24 <ertes> adarqui: to be honest i don't know…  at least GHCJS seems to be widely used
00:14:46 <ertes> adarqui: the haskell community definitely is large and active today, including the haskell web community
00:15:10 <adarqui> ya.. haskell community in general is great. love it
00:15:15 <ertes> GHCJS is still new and has its share of problems, but it's in active development
00:15:30 <adarqui> cool
00:15:55 <ertes> (well, it's "new" compared to GHC in general)
00:20:14 <quchen> Is there a place I can read about the IO implementation in GHC, or is it something only found in the source?
00:20:52 <quchen> Since the STG has a well-defined execution order, I would imagine certain thunks have effects when entered
00:21:30 <ertes> quchen: look at the definition…  it's pretty straightforward:  it's basically the strict counter idea, but without counting
00:21:47 <ertes> quchen: functions that strictly pass a value around
00:22:09 <quchen> That would be the "State RealWorld" picture.
00:22:40 <ertes> yeah…  in fact IO = ST RealWorld#
00:22:47 <ertes> or RealWorld?
00:22:49 <quchen> But I remember shachaf mentioning that that’s not right, and then there’s also the question why it uses state# and what that is
00:22:52 <ertes> something like that
00:23:18 <ertes> it's questionable to *interpret* IO like that
00:23:47 <ertes> but as an implementation detail it's fine, because you're not passing the state of the universe around
00:23:49 <quchen> Ah, maybe that’s what he meant. RealWorld has no values, so it’s not really a state.
00:23:53 <ertes> you're really just enforcing order
00:24:21 <ertes> @src IO
00:24:24 <lambdabot> Source not found. Abort, Retry, Panic?
00:24:25 <quchen> Which also solves the concurrency issue: when there’s no shared state, there’s no aliasing between threads.
00:24:46 <quchen> How do exceptions fit into this picture?
00:24:58 <ertes> they are just effects
00:25:14 <quchen> Effects as in primops that do certain things?
00:25:51 <ertes> effects as in Nothing and Left
00:25:53 <milesrout> haskell is so good
00:26:19 <quchen> ertes: Huh?
00:26:35 <quchen> I don’t see that kind of behaviour anywhere in IO’s definitions
00:26:35 <ertes> quchen: i'd try not to read anything into IO…  it's a language for arbitrary effects
00:26:50 <adarqui> ok im off.. thanks very much ertes
00:26:53 <adarqui> gn!
00:27:03 <ertes> adarqui: have fun
00:27:23 <quchen> Well, I’m interested in the implementation, not so much in what the actual IO type means in a program
00:27:32 <quchen> I’m not looking for an IO tutorial ;-)
00:27:44 <ertes> quchen: the implementation is just strict functions together with some RTS peculiarities
00:28:16 <ertes> exceptions are an RTS feature…  you don't find them in the definition of IO
00:28:18 <quchen> Ultimately I’m wondering whether (and if, how) to add IO to my STG implementations
00:28:34 <quchen> At least that’s my rabbit hole :-
00:28:35 <quchen> )
00:29:11 <ertes> in principle you could make exceptions a direct IO feature
00:29:38 <milesrout> is there a stack plugin for vim
00:31:39 <quchen> ertes: Sure, IO could be some stack with BasicIO at the bottom.
00:32:11 <ertes> quchen: semantically the simplest way (i think) to add IO is to create an actual DSL and make your RTS an interpreter that performs the effects…  while that sounds simple, it would get very complicated very fast =)
00:32:25 <ertes> i'd just do what GHC does: use strict functions
00:32:47 <Athas> The interpreter approach is elegant, but I think it breaks down in the presence of concurrency.
00:33:36 <ertes> whether you'd want exceptions to be an IO or an RTS feature depends on whether you want different systems for pure exceptions (undefined) and IO exceptions
00:34:24 <jle`> @tell merijn any comments on the difference between your broadcast-chan package and the split-channel package?
00:34:24 <lambdabot> Consider it noted.
00:37:17 <jle`> i wonder what the best way to encode a sum type in yaml/json is
00:43:30 <milesrout> if I want free monads, I want to install free, is that right?
00:43:38 <milesrout> not transformers-free or something
00:43:40 <liste> jle` maybe tags for YAML?
00:44:18 <jle`> milesrout: yeah, free provides the most commonly used implementations/api
00:44:28 <jle`> liste: hm maybe
00:44:35 <jle`> i ended up sidestepping the issue for my own purposes tho
00:44:42 <liste> http://www.yaml.org/spec/1.2/spec.html#id2783797
00:44:43 * dysfun has grown to prefer Freer monads
00:44:46 <milesrout> jle`: thanks
00:45:11 <milesrout> dysfun: i can’t tell if this is a ‘monoid in the category of endofunctors’ style joke
00:45:13 <milesrout> or not
00:45:26 <dysfun> no, though the name obviously puns on Free
00:45:40 <dysfun> The Freer monads is Free-er than Free
00:46:00 <jle`> liste: oh interesting
00:46:01 <dysfun> see extensible-effects or freer
00:46:10 <jle`> i wonder if the aeson-based yaml library supports these
00:47:26 <milesrout> dysfun: isn’t the point of Free that it is in a sense maximally free
00:48:31 <dysfun> no, it is not free of the Functor :)
00:48:45 <mniip> does anyone have a link to the video about the presentation of CReal handy?
00:49:39 <Axman6> there was one given as the brisbane FP group not too long ago...
00:49:42 <liste> jle`: it does, at least if you use Data.Yaml.Parser
00:49:45 <dysfun> milesrout: http://okmij.org/ftp/Haskell/extensible/exteff.pdf
00:49:49 <jle`> :o
00:49:55 <jle`> thanks!
00:49:56 <liste> jle`: though not sure about mapping to sum types
00:50:13 <liste> you may need to do it manually
00:50:19 <jle`> mhm
00:51:04 <Axman6> mniip: this might be useful, not sure if you were after another specific talk: https://www.youtube.com/watch?v=LJQgYBQFtSE
00:51:10 <jle`> wow this is my first time returning an IO (IO something)
00:51:19 <mniip> yes that
00:51:28 <jle`> feels weird but that's the magic of IO-as-data i guess
00:51:35 <mniip> thanks
00:52:27 <mniip> jle`, I've had an idea of a threading library with an interface akin to 'startThread :: IO a -> IO (IO a)'
00:52:29 <milesrout> someone said to me the other day that Haskell programmers start with purely functional programming then spend all their time writing syntactic sugar to make it more imperative. I pointed out that that’s like saying that mathematicians start with set theory and then spend all their time trying to make it more like intuitive mathematics, and that both of those miss the point that going from unrigorous intuition to rigorously backed intuition i
00:52:30 <milesrout> extremely useful, and that in the same way it’s pretty damn useful to be able to reason about the imperative programming you’re doing in a reasonable way.
00:53:38 <milesrout> imperative programming in an imperative language is like doing mathematics without a rigorous theory underneath. you can do it, people did it for ages, but that doesn’t mean that it’s a good idea.
00:53:57 <liste> jle`: for sum type encoding for JSON, check out https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:Options
00:54:05 <jle`> mniip: nice
00:54:07 <dysfun> for someone who's only just started haskell, you've got "irritating non-haskell programmers" leveled up to 100
00:54:08 <jle`> liste: thanks!
00:54:24 <liste> jle`: especially, https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:SumEncoding
00:54:46 <jle`> i guess smart people have already thought of this :O
00:54:48 <milesrout> dysfun: rofl
00:55:07 <milesrout> max level is 99, you only get 100 temporarily when you activate your skillcape
00:55:28 <merijn> milesrout: I just don't bother arguing and shake my head while sighing
00:55:34 <dysfun> pretty sure the max level keeps increasing
00:55:42 <milesrout> merijn: i think they probably get annoyed even more
00:55:44 <milesrout> when you do that
00:56:29 <dysfun> i note that merijn has been writing C this week and I've written clojure
00:56:46 <merijn> jle`: boardcast-chan is WAY simpler than split-channel looking at the implementation
00:57:15 <merijn> jle`: I'd say it's much lower overhead, but with less functionality
00:58:01 <merijn> jle`: i.e. broadcast-chan can't do atomic batches. The only thing it really changes from ordinary Chan is the space leak if you want a Chan that, temporarily has no listeners
00:58:53 <merijn> jle`: Imagine you have a UI thread posting updates to a Chan and you want to be able to have 0 through N listeners receiving broadcasts. The problem with an ordinary Chan is that, if there's no reader, the Chan slowly fills up and never gets emptied
00:59:22 <merijn> jle`: So broadcastchan is basically Chan, with the change that if you never dupChan it just drops all data on the floor
00:59:34 <jle`> oh i see
00:59:54 <jle`> is that really hte only operational difference?
01:00:07 <merijn> jle`: Whereas split-chan tries to be fancier with atomic stuff, etc.
01:00:28 <merijn> jle`: It should be, the implementation is lifted wholesale from the Chan source :p
01:00:35 <merijn> If it's not I'd consider that a bug :)
01:00:46 <jle`> implementation of broadcast-chan, or split-chan?
01:01:02 <milesrout> do I need PatternSynonyms to do:
01:01:08 <merijn> jle`: broadcast-chan
01:01:16 <milesrout> pattern Bottom = Proposition “\x22A5”
01:01:28 <milesrout> pattern (Not f) = Implication f Bottom
01:01:46 <merijn> hmm, I just noticed I never pushed my simplified version
01:01:57 <jle`> split-channel's docs suggests that writes to channels with no listeners are also immediately garbage collection
01:07:33 * hackagebot broadcast-chan 0.1.1 - Broadcast channel type that avoids 0 reader space leaks.  https://hackage.haskell.org/package/broadcast-chan-0.1.1 (MerijnVerstraaten)
01:08:27 <merijn> Right, so that's fixed :p
01:09:02 <dysfun> :)
01:09:03 <merijn> jle`: Anyway, it depends about what you care about/need. If you need none of the extra functionality of split-chan I would say mine is probably as efficient as you can get
01:09:47 <milesrout> they’re called free functors because the forgetful functor totally forgets to charge them, right?
01:09:48 <milesrout> :P
01:10:09 <merijn> I simply wanted something that could replace the broadcast version of TChan but without the STM since that doesn't do well with contention :)
01:10:33 <jle`> yeah, i already started writing half of my project with broadcast-chan, i don't quite need any of split-chan's extra functionality heh
01:10:38 <jle`> thanks :)
01:12:14 <merijn> jle`: Incidentally, it's only like 40 lines of code if you wanna see how it works/differs from Chan :p
01:12:25 <merijn> It's actually kinda neat how Chan is implemented :)
01:12:33 * hackagebot solga-swagger 0.1.0.0 - Swagger generation for Solga  https://hackage.haskell.org/package/solga-swagger-0.1.0.0 (PatrickChilton)
01:12:48 <jle`> it's similar to how simon marlow implements it in his book, right?
01:15:34 <dysfun> merijn: what's the high level? i'm just curious how it compares to clojure core.async
01:16:35 <dysfun> merijn: core.async has two queues, for push and pop and uses CAS
01:21:24 <merijn> jle`: I think it might be exactly like in his book
01:21:42 <merijn> dysfun: It's a linked list of MVars with MVar's pointing to the read and write ends
01:22:16 <dysfun> ah
01:22:31 <dysfun> that's quite tidy :)
01:25:24 <merijn> dysfun: You can make it broadcast by just keeping another reference to the start of the Chan, that if one reader reads ahead the other one keeps the unread part alive
01:25:42 <merijn> dysfun: I'd recommend Simon's book (and just reading the very simple source) for details :)
01:25:49 <dysfun> :)
01:25:54 <dysfun> simon's book is on my list
01:25:58 <dysfun> but it's a very long list
01:26:47 <merijn> dysfun: Better get good at prioritising, then ;)
01:27:09 <dysfun> but so many shiny things to play with!
01:27:30 <merijn> Anyway, time to go stare at assembly
01:27:39 <dysfun> have fun
02:03:47 <javjarfer> hi! anyone knows why when you use the forall keyword from RankNTypes in a data constructor, parenthesis need to be closed at the end of the expression? So you can't do "newtype test = (forall b. b -> String) -> String"?
02:11:22 <dibblego> do you mean, newtype Test = Test ((forall b. b -> String) -> String)
02:12:14 <Cale> javjarfer: Type constructors have to start with an uppercase letter, and newtype requires you to specify the name of a data constructor as well (which also must start with an uppercase letter)
02:18:06 <jle`> javjarfer: if you really don't want to use parentheses, you can use record syntax -- newtype Test = Test { test :: (forall b. b -> String) -> String }
02:18:26 <jle`> same deal as newtype Test = Test (Maybe Int) vs. newtype Test = Test { test :: Maybe Int }
02:20:17 <hwkng> how does lambda-pi, pi-forall differ in terms of dependent type implementation?
02:20:21 <hwkng> (both seems to be implemented in haskell)
02:22:35 * hackagebot http-client-session 0.1.2 - A simple abstraction over the "http-client" connection manager  https://hackage.haskell.org/package/http-client-session-0.1.2 (NikitaVolkov)
02:25:26 <merijn> hwkng: pi-forall is based on/builds on the LambdaPi tutorial
02:25:35 <merijn> hwkng: So the answer is probably "not a lot"
02:26:53 <javjarfer> Cale, I know that was a typo
02:28:59 <javjarfer> jle`, thanks you, I was making a typo all the time and I didn't notice, I think it was the place of the first parenthesis... I rewrote the exression and its fine now
02:41:41 <gabbiel> @src sin
02:41:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:41:55 <gabbiel> @src getLine
02:41:56 <lambdabot> getLine = hGetLine stdin
02:45:10 <Cale> sin is a class method of Floating, and it's implemented specifically for each type that supports it -- for Float and Double, in terms of a compiler primitive that usually turns into a machine instruction.
03:02:36 * hackagebot morph 0.1.0.1 - A simple database migrator for PostgreSQL  https://hackage.haskell.org/package/morph-0.1.0.1 (thoferon)
03:03:33 <daey> whcih package do i need to run ghci?
03:04:04 <daey> i cant seem to find a proper package when searching for ghci. and ghc doesnt seem to contain it
03:04:34 <maerwald> daey: not? https://github.com/ghc/ghc/tree/master/libraries/ghci
03:04:45 <daey> maerwald: i mean in the debian repos
03:04:53 <daey> and im certain its in there
03:05:06 <maerwald> I don't understand. It's part of ghc.
03:05:21 <daey> :/ and its invoked with 'ghci' ?
03:05:27 <demize> As in, ghci is literally a symlink to ghc.
03:05:50 <maerwald> if debian does not install the symlink, then their ghc package is broken
03:05:56 <daey> i obviously tried 'ghc' as well. which exists with "no input"
03:06:30 <demize> `ghc --interactive` to force an interactive shell directly.
03:06:32 <maerwald> https://packages.debian.org/jessie/ghc it is part of ghc
03:06:33 <daey> maerwald: well its not debian per se. im on raspbian
03:06:38 <maerwald> aha
03:07:03 <daey> ok. the package isnt build for interactive use~
03:07:22 <daey> i couldnt find anything in the man file either... even tried 'ghc -i'
03:07:55 <maerwald> daey: https://ghc.haskell.org/trac/ghc/wiki/Building
03:13:30 <LKoen> hello
03:23:05 <daey> does anyone use haskell as a  scripting language?
03:23:19 <daey>  / interpreter language
03:23:56 <Clint> yes
03:24:26 <daey> just wanting to make sure i pick the right thing, as i dont need a C replacement
03:24:46 <daey> but rather something that could be used instead of python
03:27:37 <liste> daey: are you planning to embed Haskell into your program, or just using it for developing stand-alone apps?
03:27:48 <liste> "scripting" can mean many things
03:27:51 <daey> liste: later
03:28:17 <maerwald> haskell instead of python is an odd choice tbh
03:28:34 <maerwald> but it's a general purpose language, so *shrug*
03:29:48 <liste> what's the best way to embed Haskell into an non-Haskell app for scripting, btw?
03:30:05 <liste> now that Hugs is dead
03:30:23 <maerwald> calling haskell from non-haskell language isn't nice afair
03:31:05 <Clint> not as nice as lua
03:31:16 <maerwald> yeah, lua is commonly used for embedded stuff 
03:32:37 * hackagebot bitcoin-payment-channel 0.2.0.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.2.0.0 (runeks)
03:56:27 <woffs> a haskell "script" with #!/usr/bin/runghc in the first should work :-)
03:59:45 <luite> woffs: i've used haskell this way, but it tends to break down quickly, since so many things depend on the right packages being installed. I wonder if stack has some alternative, something like #!/usr/bin/env runstack ltsversion [listofpackages], where it'd automatically prepare (and cache) the packages
04:03:27 <dibblego> I just use executable in the .cabal file
04:06:05 <luite> dibblego: that's more heavyweight though, or do you have a neat way to get everythign in a single file, and runnable with a single command? (does "cabal run" require configure first?)
04:06:06 <osa1> luite: yes, add something like `-- stack --resolver lts-6.0 --install-ghc runghc --package parsec --package wl-pprint` right after #!/usr/bin/env stack line
04:06:28 <dibblego> luite: I don't have anything special; it's just preferable to dealing with the consequences otherwise.
04:06:33 <luite> osa1: oh neat :)
04:07:06 <osa1> running example https://github.com/osa1/analyze-ghc-timings/blob/master/analyze_timings.hs#L2
04:09:50 <luite> osa1: tnx, i think i'll use it for some ghcjs scripts that I use infrequently :)
04:12:57 <merijn> liste: You can use GHC
04:13:12 <merijn> liste: As in, as a library
04:13:21 <merijn> That's what hdevtools does
04:14:45 <nilof> is u <*> (v <*> w) different from  (u <*> v) <*> w ?
04:15:10 <merijn> nilof: Operationally or semantically?
04:15:25 <nilof> operationally, for general instances of applicative
04:15:38 <merijn> nilof: Might have slightly different performance
04:15:53 <nilof> but they are semantically the same?
04:15:54 <liste> merijn: cool! is it easy to use from C?
04:15:54 <merijn> nilof: The order of effects and semantics are guaranteed by the applicative laws, though
04:16:04 <merijn> liste: As easy as any other Haskell is
04:16:26 <merijn> liste: Do note that GHC as library is still pretty darn big if you plan to embed it
04:17:35 <merijn> liste: GHC is developed in a pretty nice way with the entire compiler being a library and the executable just calling into the library(ies).
04:44:35 <qinusty> Looking at setting up some persistent data for my project, any suggestions on how to approach this? Preferably a method with good documentation and examples
04:46:08 <merijn> qinusty: So, like, persistent for a daemon?
04:46:12 <merijn> *persistent state
04:47:39 * hackagebot data-sword 0.1 - Shorter binary words  https://hackage.haskell.org/package/data-sword-0.1 (MikhailVorozhtsov)
04:49:57 <magneticduck> qinusty: just looking for serialization, or some persistence framework?
04:50:17 <qinusty> merijn: Ok, more details might help I realise :P So I have an IRC bot which stores data in a Map (Nick, data) How should I approach storing this data persistently so that if the bot goes down/offline etc, everything isn't lost
04:50:43 <qinusty> I was thinking Postgres/MariaDb, but I've heard good things about acid state. I just can't find too many examples on it
04:51:24 <merijn> acid-state is good, but personally I feel it's not great for "Map Foo Bar" data storage
04:51:31 <merijn> qinusty: Why not SQLite?
04:51:31 <qinusty> Okay
04:52:01 <qinusty> I'll take a look
04:52:26 <merijn> qinusty: SQLite is basically an SQL database designed to be embedded as library so that you don't need a separate server
04:53:16 <qinusty> Got any packages to suggest? 
04:53:22 <qinusty> There seems to be a few
04:53:52 <merijn> qinusty: tbh, no, I was looking for one myself, but that project is on hold :)
04:54:56 <qinusty> :P
04:55:27 <cocreature> sqlite-simple is pretty okay imho. it’s just at thin layer around sql that does the serialization from and to haskell values for you
05:01:25 <qinusty> Okay, Coming from C#/Java/Python I'm quite familiar with the exception handling and was wondering how i would perform a finally style operation in haskell?
05:01:45 <merijn> qinusty: Using 'finally'? :p
05:01:51 <qinusty> Waiiiiit
05:01:59 <merijn> :t Control.Exception.finally
05:01:59 <cocreature> or bracket if you also want to initialize something
05:02:00 <lambdabot> IO a -> IO b -> IO a
05:02:03 <qinusty> :O
05:02:13 <merijn> Assuming you're referring to IO exceptions
05:02:17 <qinusty> Yeah
05:02:36 <merijn> bracket, finally, onException, etc.
05:02:39 * hackagebot binary 0.8.4.1 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.4.1 (LennartKolmodin)
05:02:56 <cocreature> Control.Exception is the module you want to look at
05:36:36 <balor> Hmm...stack is telling me `Did not find .cabal file for wreq-0.4.1.0 with Git SHA of 76d8ca4c0629b0e0bec9e23d699f16799f4bc1d2` and similar.  What do I have to nuke for stack to rebuild these indexes?
05:39:29 <quchen> ~/.stack is what you nuke to nuke Stack.
05:41:02 <balor> thanks
05:41:55 <balor> ah, I was missing a good old `stack setup` before `stack init`
05:42:44 <quchen> Heh. :-)
05:42:51 <quchen> It would be nice if it at least warned about that.
05:47:33 <nkaretnikov`> is it possible to type the result of a splice expansion like it's done for embedFile here https://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html ?
05:48:04 <nkaretnikov`> (but instead of assigning the result to some constant, make it a function)
05:51:13 <quchen> You mean add type annotations to TH-generated expressions? Sure
05:51:29 <quchen> You can also use TH to generate the type sigs in the first place if you want to
05:52:40 * hackagebot data-flags 0.0.3.2 - A package for working with bit masks and flags in general.  https://hackage.haskell.org/package/data-flags-0.0.3.2 (MikhailVorozhtsov)
05:55:48 <nkaretnikov`> quchen: i can use quoteFile like this [quoteFile|path-to-file|] :: MyType, i'd like to have a th-wrapper around that that'd always return MyType, so I can omit the signature
06:00:56 <nkaretnikov`> quchen: ah, i cannot do this in the current setting, i think, since i'm relying on parseExp from haskell-src-meta, which accepts arbitrary haskell exps
06:01:13 <nkaretnikov`> quchen: and i can't think of a quick-n-dirty way to type that
06:14:41 <gothos> some conferences don't care too much tho and you can run your own if it's not too awful
06:15:09 <gothos> oh sorry, ssh connection died
06:21:29 <balor> byorgey: is it reasonable to describe diagrams as a DSL for diagrams with support for most of the RCC-8 operations? (https://en.wikipedia.org/wiki/Region_connection_calculus)
06:22:42 * hackagebot fasta 0.10.4.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.10.4.0 (GregorySchwartz)
06:23:09 <sdx23> Hi. Working with hmatrix, I can't make sense out of this: https://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra-Data.html#t:Build - why is the generating function (e -> e -> e) and not (Int -> Int -> e)?
06:26:23 <sm> quchen: it does
06:27:24 <quchen> sm: Ah, what it didn’t do was download the compiler right away then
06:45:28 <c_wraith> sdx23, that's baffling to me, too. why would you ever want the indices given in the same type as the element? 
06:47:10 <c_wraith> sdx23, but the constraint on the instances provided means you will only ever be able to use that class when e is some sort of numeric type anyway. 
06:47:44 <c_wraith> sdx23, so I guess it was done that way to avoid fromIntegral calls. 
06:48:31 <c_wraith> (a poor reason in my opinion, but I can understand the impulse) 
06:49:16 <merijn> c_wraith: To be fair, all those fromIntegral calls would end up rather expensive for large matrices
06:50:28 <c_wraith> would they really? 
06:51:43 <merijn> If your matrices are containing millions of elements, 2 fromIntegrals per element...
06:51:57 <sdx23> well, in my case I want to use them as indices actually - so I'll round that Doubles to Int or something :(
06:52:22 <sdx23> actually rather implement this myself directly, it seems to use fromList / toList anyways
06:52:43 * hackagebot diversity 0.8.0.1 - Quantify the diversity of a population  https://hackage.haskell.org/package/diversity-0.8.0.1 (GregorySchwartz)
06:52:45 * hackagebot modify-fasta 0.8.2.1 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.2.1 (GregorySchwartz)
06:53:33 <dsub> I'm I right in that bioinformatics is taking hold in haskell?
06:54:43 <c_wraith> there is certainly a growing number of libraries for bioinformatics
06:54:54 <c_wraith> I don't know if that means more than two or three people are using it for that, though. :)
06:59:56 <maerwald> dsub: doubt it
07:01:43 <dsub> Hmm... wishful thinking from me then... I always get a little excited when I see hackagebot telling me about bioinfo packages being uploaded, since I would be much happier if haskell was the goto language instead of python/perl for bioinformatics people.
07:02:40 <dsub> Or pure shell-scripting, which is even worse
07:03:56 <maerwald> haskell isn't a "goto" language for anything. The industry penetration is very low, even for the primary domains it is used for.
07:07:24 <buglebudabey> maerwald could it eventually be?
07:07:35 <maerwald> I doubt it
07:07:47 <buglebudabey> what makes you say that?
07:08:40 <maerwald> for a lot of people it's hard to learn and takes a lot of effort to write even simple programs. The usual "just do stuff and learn as you go" does not work when learning haskell. You need to familiarize yourself with a lot of concepts and be able to understand real abstraction.
07:08:51 <maerwald> that's too much for a lot of programmers
07:09:11 <maerwald> and I'm not even saying "too much" wrt intellectually
07:09:16 <maerwald> but just the time you need to spend
07:10:38 <dsub> It's very abstract because programmer are usually already familiar with other ways of solving problems. If functional programming get taought to a greater degree in CS, perhaps the step to using haskell might not be such a great leap. (?)
07:10:46 <quchen> I’ve seen contrary evidence. A colleague got up to pretty great heights within a month of fiddling and talking with me. He’s the academic likes-to-learn kind, yes, but that’s besides the point.
07:11:06 <maerwald> quchen: most programmers are not the academic likes-to-learn kind
07:11:26 <quchen> That doesn’t mean there aren’t sufficiently many anyway.
07:11:29 <buglebudabey> dsub it wasn't such a great leap for me because my university started off with functional programming
07:11:32 <maerwald> and even under those that are, they rarely get interested in haskell, because they are already C cracks or something
07:11:40 <maerwald> and don't want to bother with a completely new way of programming
07:11:48 <quchen> Lots of people don’t like mountainbiking, yet I have no trouble finding some to ride with.
07:12:22 <maerwald> quchen: well, there are currently zero jobs in haskell in my whole country (at least in 3 job platforms I've looked at), probably no coincidence.
07:12:32 <quchen> There’s more to this than absolute numbers. Sure, you’ll always find more Java programmers than Haskell programmers, but we don’t need relatively many, all we need is enough.
07:12:34 <buglebudabey> i think amongst the fp community haskell isnt so bad, and since fp popularity is gaining i suppose haskell will as well
07:13:25 <quchen> Besides, Haskell has already been hugely influential. Half of Rust is “finally someone looked at a ML language before designing an imperative one”, for example.
07:13:41 <maerwald> sure, it's still not going to take over anywhere
07:13:55 <quchen> People get upset when things don’t have generics nowadays, and generics are parametric polymorphism.
07:14:31 <quchen> Elm is gaining traction a lot.
07:14:46 <maerwald> quchen: no elm jobs in my country either
07:14:46 <aupiff> quchen: why do you say that?
07:14:59 <maerwald> you are really talking about a _tiny_ fraction of the industry
07:14:59 <buglebudabey> maerwald what country?
07:15:05 <ajf> how do I conditionally return from a monad?
07:15:14 <aupiff> I see that NoRedInk is using it, but I haven't seen much Elm adoption elsewhere
07:15:25 <ajf> I want to check if something is Nothing, and if so, return early
07:15:29 <ajf> otherwise continue execution
07:15:35 <maerwald> some experimental stuff facebook, google or other entrepreneurs do, but not the industry in general
07:15:36 <buglebudabey> ajf use a case expression
07:15:44 <buglebudabey> ajf and pattern match
07:16:00 <ajf> well, yes, I can do that, but that means the rest of the function is indented
07:16:19 <aupiff> ajf: work in a Maybe monad do block
07:16:19 <maerwald> the rest is just wishful thinking I hear a lot in the haskell community, but most of that doesn't hold up in reality. People write "haskell" in their job description just to make it look nicer, not because they actually want to develop in haskell
07:16:42 <quchen> maerwald: Facebook’s rules engine (Sigma) is hardly experimental.
07:16:49 <aupiff> this is useful is you have multiple Maybes that you're checking have a Just _ value.
07:17:03 <ajf> hmm
07:17:05 <aupiff> this will avoid indentation.
07:17:07 <dsub> maerwald: I think most people who write haskell in their job description would like to use it, but doesn't expect that to be the case. 
07:17:18 <dsub> become*
07:17:20 <ajf> how do I do this inside an IO do block?
07:17:23 <quchen> Google doesn’t do much Haskell as far as I know, their only Haskell project being a lucky coicidence.
07:17:24 <maerwald> dsub: I've had 3 cases where they wrote haskell and none of them develop in haskell
07:17:33 <aupiff> ajf: MaybeT IO, it's a monad transformer
07:17:46 <maerwald> one did Erlang only and they thought "oh, haskell sounds close enough, so lets just write that too"
07:17:56 <aupiff> ajf: https://wiki.haskell.org/Monad_Transformers_Tutorial
07:18:12 <dsub> maerwald: lol :) sounds like a wierd way to present your job descriptions... 
07:18:16 <aupiff> the first few examples should be exactly what you're looking for.
07:19:04 <ajf> aupiff: I see, but isn't this only useful if we ultimately want a Maybe value?
07:19:06 <quchen> Haskell, Pascal … sounds similar, let’s just add both
07:19:40 <aupiff> ajf: yes, then you should unwrap at the end just once.
07:19:55 <aupiff> ajf: using something like fromMaybe or a case expression
07:20:06 <buglebudabey> ajf if you're worried about the rest of the code being indented then just have the code you execute when the value is "Just _" be defined separately
07:20:31 <ajf> buglebudabey: well, I could do that, but there'd be a bunch of such definitions
07:20:45 <buglebudabey> ajf could you abstract over them?
07:20:56 <maerwald> dsub: there are some people who even would consider to develop in haskell, but don't because they are afraid they don't find enough developers. Which is also true.
07:22:33 <ajf> the particular case I have here is I'm writing a registerUser routine returning IO (Either Text Int). if it succeeds, it produces a Right with a user ID. if it fails, it produces a Left with an error message
07:22:35 <aupiff> ajf: I sense that you're trying to avoid boilerplate, ugly indentation  and include some safety. generous use of monads is the solution, but there has to be an unwrapping of the safe maybe or either value at some point.
07:23:01 <buglebudabey> ajf then fromMaybe could work since it returns an Either value
07:23:03 <aupiff> ajf: That's a perfect spot to apply `EitherT Text IO`
07:23:16 <ajf> aupiff: hmm. I'll look into it
07:23:21 <aupiff> there are ways to automatically convert from MaybeT to EitherT
07:23:53 <aupiff> then you're working in a big EitherT block, mixing in the occasional Maybe value that is "error annotated" and converted to an EitherT.
07:24:16 <aupiff> ajf: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Maybe.html#v:maybeToExceptT
07:25:03 <ajf> aupiff: if I'm doing that I might as well just conditionally raise an exception
07:25:39 <dsub> maerwald: So it's like a "the egg or the chicken" thing. There are no jobs for haskellers, so people wont learn it. And those who knows haskell and would like to use it don't look for haskellers because there are too few...
07:26:05 <maerwald> dsub: haskell is not a mediocre language and requires specials skills
07:26:21 <maerwald> that's why there will never be a massive amount of people who are proficient with it
07:27:21 <aupiff> ajf: That's also handled nicely by EitherT. check out this function: `syncIO` https://hackage.haskell.org/package/errors-2.1.2/docs/Control-Error-Util.html
07:27:29 <dsub> maerwald: partly true. You probably learned a programming language like C/Java first, and trained your mind in that kind of problem solving. Nowadays functional programming is gaining reputation. So perheps in the far future?
07:27:56 <ajf> aupiff: I think I see.
07:27:56 <dsub> If you would learn a functional programming as the first language, going to haskell wouldnt be such a mind-bend'
07:28:00 <ajf> Thank you for your help.
07:28:06 <aupiff> ajf: also note that we call EitherT "ExceptT" when we're using it specifically catch errors and exceptions. They are totally identical and don't let this confuse you.
07:28:15 <ajf> ah
07:28:16 <maerwald> dsub: I don't believe in the "because you didn't learn it as your first language" argument
07:28:16 <aupiff> ajf: no problem
07:28:52 <aupiff> ajf: use of `catch` and `catchE` with will also help
07:29:01 <dsub> maerwald: the first language-thing was more to point at how people will tend to solve problems - how their mind operate first. 
07:29:03 <ajf> though I can't help but imagine there's a simpler way to do what I want here
07:29:22 <ajf> essentially, I want to conditionally return early
07:29:32 <maerwald> dsub: no, I don't think the first programming language is able to shape your mind in such a way. It's more the other way around.
07:29:38 <aupiff> ajf: exceptT does that. Left values fall through the rest of the computation
07:29:48 <maerwald> you naturally look for a language which matches how you think
07:29:56 <maerwald> and lets you express your thoughts in that way
07:29:57 <dsub> hmm
07:30:02 <dsub> perhaps
07:30:08 <ajf> maerwald: that sounds about right
07:30:12 <maerwald> just because you learned java first and hated it doesn't mean you know solve everything in an OOP way
07:30:21 <ajf> a lot of things in Haskell are things I wanted to add to my own language
07:30:24 <ajf> which I hadn't seen done
07:31:18 <ajf> aupiff: so ExceptT lets you use any exception type?
07:31:26 <mizu_no_oto_work> maerwald: Do you think some people, during their first class in C, will start using C in an OO or functional way if that's how they think?
07:31:30 <ajf> so I could use a String or a Text, say?
07:31:39 <aupiff> ajf: you can use any type yes.
07:31:59 <ajf> ah, cool
07:32:04 <aupiff> ajf: I like to define my own exceptions and use the gereral exception type "SomeException"
07:32:07 <buglebudabey> maerwald most people don't have a choice in the first language they learn, or how they learn
07:32:07 <ajf> well, I'll try this later, thank you :)
07:32:09 <aupiff> ajf: https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Except.html#Except
07:32:21 <buglebudabey> maerwald university students anyway
07:32:32 <maerwald> buglebudabey: yes, but I think that's not an important point for the problem
07:32:35 <aupiff> ajf: look at the monad instance of ExceptT and everything will make sense. the boiler plate you're trying to avoid is baked into the bind definition
07:33:04 <maerwald> even if more universities forced haskell as the 1st language on their students, not much would change imo
07:33:16 <buglebudabey> maerwald it is because when you are taught C in their first class, and the rest of your classes revolve around C based languages, and you grow comfortable with it, why choose anything else?
07:34:09 <buglebudabey> maerwald i would not have chosen haskell as quickly as i did had it not been for my university which teached racket/fp first
07:34:13 <bergmark> ajf: I'd advise against using String/Text as the exception type since that doesn't tell the user anything about what the actual exceptions are
07:34:17 <buglebudabey> which taught*
07:34:18 <maerwald> mizu_no_oto_work: I don't know. C allows that somehow, so maybe. But a good teacher should try to teach the "idiomatic" way of the language first.
07:34:57 <marchelzo> it's almost impossible to use C in a functional style
07:35:17 <maerwald> buglebudabey: I learned haskell before it came up in my university. And there were exactly 0 people who had interest in haskell after that course.
07:35:40 <buglebudabey> maerwald was haskell the first language taught at your university?
07:35:48 <maerwald> no and again: it doesn't matter
07:36:20 <buglebudabey> i believe it does, because if you have never programmed before university, the environment in your first programming class is going to shape you
07:36:32 <dsub> ^
07:36:39 <maerwald> I think it does not matter, because you already have your way of thinking and haskell either matches that or not.
07:36:47 <mizu_no_oto_work> merwald: Do you think think that being taught idiomatic C as your first language doesn't have any effect on how you'd approach programming, at least initially (i.e. before you're exposed to Java, Lisp, Haskell, Prolog, etc.)
07:36:50 <maerwald> and for most programmers, it seems it doesn't 
07:36:56 <raichoo> buglebudabey: No it doesn't. At my local university they teach Haskell first, nobody is interested in it after that.
07:37:23 <marchelzo> raichoo: probably because they are already somewhat familiar with other languages
07:37:31 <buglebudabey> raichoo are the subsequent classes taught with fp concepts in mind, or do they switch to oop based stuff
07:37:37 <raichoo> marchelzo: some are, some aren't
07:37:40 <dsub> raichoo: Perhaps haskell is initially too far away for anything useful at first. Scala might be a better first language for learning fp
07:37:41 <LKoen> raichoo: do you have actual stats on the "nobody"?
07:37:51 <marchelzo> or are at least aware of the fact that languages like C++ and Python are vastly more popular in industry
07:38:14 <maerwald> You don't need to manipulate people that much with language teaching order for them to pick something up. That's also somehow underestimating people. If they find a language they are good at thinking in, they will stick with it. If not, they will look for something else.
07:38:31 <dsub> true
07:39:07 <buglebudabey> maerwald i agree with that, but i also believe that the way people think can change in accordance to how they learn, especially if programming is new to them
07:39:29 <raichoo> buglebudabey: They now have. Friends of mine have started an advanced FP course after I have infected them with my love for functional programming ;)
07:39:29 <hodapp> oh, dang, https://hackage.haskell.org/package/colour hasn't been touched since 2012 and I was wanting to do a PR on something
07:39:43 <hodapp> raichoo: infected them with your love?! O_O
07:39:50 <marchelzo> i think strict, imperative languages are a better fit for the traditional CS curriculum, which may be why haskell and racket are not so popular in universities. The pseudocode in most algorithms texts, for example, is written in an imperative style.
07:40:14 <raichoo> hodapp: Don't be jealous.
07:40:14 <maerwald> buglebudabey: haskell and prolog were both languages that frustrated most of my colleagues
07:40:31 <marchelzo> and most algorithms that are taught are easier to express imperatively (e.g., Quicksort)
07:40:34 <maerwald> and when you experience such frustration, there is little chance you will look at it again
07:41:01 <maerwald> doing those as the first language would have been even worse
07:41:07 <buglebudabey> maerwald colleagues in university? what kind of previous experience did they have
07:41:07 <maerwald> discouraging people in the 1st semester
07:41:40 <maerwald> I don't know what experience they had. And I don't think it matters much.
07:41:59 <hodapp> Scala for teaching FP? A whole lot of FP made no sense to me when learning Scala, and suddenly made sense with Haskell.
07:42:48 <buglebudabey> maerwald someone who is trained in something but has a mindset suited for something else may not want to go to that something else because their mind is already accustomed to the first skill
07:42:59 <maerwald> meh
07:43:00 <hodapp> I feel like Scala has too much else mixed in and too many other problems it has to solve in the process.
07:43:05 <maerwald> I don't believe that
07:43:05 <buglebudabey> maerwald already skilled in that first skill
07:43:10 <buglebudabey> *
07:43:57 <maerwald> we are talking about students who learn a crapload of very different stuff, not a 20 years javascript developer who is now forced to look at haskell
07:44:00 <buglebudabey> maerwald so you like to program, how did you get into it?
07:44:01 <maerwald> those are completely different things
07:44:48 <buglebudabey> maerwald if your mind was better suited for baseball, would you drop programming because you had better hand eye coordination than analytical skills, or would you stay with programming?
07:45:19 <maerwald> I have no idea where these questions lead to
07:45:34 <hodapp> (steroids and scandals, mostly)
07:45:51 <Hakey> hi, I tried to install a package with stack and got this : "Missing dependency on a foreign library: Missing C library : curl"
07:45:57 <Hakey> how can i solve this?
07:46:10 <maerwald> the way you think about students almost sounds like infants who massively get shaped by their early-life experiences
07:46:13 <mirpa> install curl
07:46:38 <maerwald> I don't think about students that way.
07:47:09 <merijn> Hakey: By installing said C library?
07:47:15 <buglebudabey> maerwald my point is that if you have built up a level of skill in something, most people wouldn't find it worth it to switch to something their mind was better suited for after putting time into something they are now good at
07:47:42 <maerwald> If someone hates haskell in the 5th semester, it's very unlikely he would have liked it in the 1st semester. I don't see any logical reason for that.
07:47:52 * woffs needs a new programming language every 7 years
07:48:11 <maerwald> if you are into FP but don't know it yet... haskell will blow your mind, no matter when you discover it
07:48:15 <maerwald> it literally doesn't matter
07:48:21 <buglebudabey> maerwald someone may hate haskell in their 5th semester because they don't want to go through the effort of learning such a thing
07:48:26 <woffs> it saves me drugs
07:48:27 <maerwald> meh
07:48:35 <maerwald> buglebudabey: no, I don't think so
07:48:40 <hodapp> This is sounding like a whole lot of hand-waving about what "most people" would do
07:48:42 <Hakey> merijn: i should already have it :/
07:49:38 <mirpa> Hakey: including dev files?
07:52:19 <Hakey> mirpa: not sure
07:52:45 * hackagebot data-sword 0.1.1 - Shorter binary words  https://hackage.haskell.org/package/data-sword-0.1.1 (MikhailVorozhtsov)
07:53:08 <mirpa> Hakey: on linux, header files for library are usually in separate package eg. libcurl-dev
07:54:34 <Hakey> mirpa: okay it should be done, thx
08:02:10 <buglebudabey> is there a function like repeat n a but with two elements instead of one? like repeat 10 [1,2]
08:02:20 <suppi> maerwald: is it ok to ask where you are from?
08:02:43 <suppi> maybe cycle?
08:02:52 <suppi> @t cycle
08:02:53 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
08:03:10 <suppi> > :t cycle
08:03:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:03:38 <woffs> :t cycle
08:03:40 <lambdabot> [a] -> [a]
08:04:17 <suppi> > take 10 $ cycle [1,2]
08:04:18 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
08:04:38 <suppi> woffs: thanks
08:04:53 <buglebudabey> perfect, thank you
08:05:00 <suppi> np
08:05:02 <Hakey> i love this bot
08:08:15 <mniip> buglebudabey, perhaps concat + replicate
08:08:34 <mniip> > concat $ replicate 10 [1, 2]
08:08:36 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
08:21:01 <merijn> cycle is better, I think
08:21:07 <merijn> cyle ties the not
08:21:12 <merijn> *knot
08:21:30 <merijn> So should be constant memory. I don't think "concate .replicate" is
08:21:43 <mjrosenb> replicate can theoretically tie the knot.
08:21:58 <merijn> eh, no?
08:22:04 <merijn> Because replicate is finite
08:22:04 <mniip> merijn, what about 'take'
08:22:07 <mjrosenb> but it'll get untied.
08:22:14 <mjrosenb> mniip: take will untie the knot.
08:22:23 <mjrosenb> since it needs to clone the tied-knot underneath.
08:22:29 <merijn> mmm, true
08:22:50 <bernalex> I still don't even understand the original question. sounds like they just wanted replicate.
08:23:19 <merijn> bernalex: No, replicate takes only a single element
08:23:28 <merijn> Wait
08:23:31 <merijn> :t replicate
08:23:32 <lambdabot> Int -> a -> [a]
08:23:37 <merijn> right
08:23:55 <mniip> is replicate a good producer?
08:23:59 <merijn> No clue
08:24:11 <bernalex> merijn: they wanted to do "like repeat 10 [1,2]". that sounds like replicate 10 [1,2]. but I don't know what they really wanted, because they didn't post a type.
08:24:18 <mniip> I know take is a good consumer and cycle is a good producer
08:24:55 <buglebudabey> bernalex i wanted someting that would repeat a list
08:25:12 <bernalex> buglebudabey: repeat does that.
08:25:27 <buglebudabey> repeat takes an element
08:25:28 <buglebudabey> not a list
08:25:30 <mniip> > repeat [1,2]
08:25:31 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
08:25:33 <bernalex> :t repeat
08:25:34 <lambdabot> a -> [a]
08:25:35 <bernalex> repeat takes anything.
08:25:39 <bernalex> it can be a list if you want.
08:25:48 <buglebudabey> bernalex it does but i don't want to concat afterwards
08:26:02 <mniip> @src cycle
08:26:02 <lambdabot> cycle [] = undefined
08:26:02 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:26:05 <buglebudabey> > take 10 $ cycle [1,2
08:26:07 <lambdabot>  <hint>:1:21:
08:26:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:26:08 <buglebudabey> > take 10 $ cycle [1,2]
08:26:09 <bernalex> see, this is why posting a type would be useful. you clearly want more than you let on.
08:26:09 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
08:26:15 <bernalex> types don't lie.
08:26:32 <buglebudabey> bernalex i got the answer i wanted right away, clearly i provided enough information
08:26:35 <maerwald> bernalex: depends
08:26:40 <bernalex> yes, I'd use cycle [1, 2].
08:26:57 <mniip> buglebudabey, heuristics
08:27:03 <mniip> the question was simple enough to only have two answers
08:27:10 <maerwald> bernalex: type FilePath = String -- quite a lie ;)
08:27:20 <bernalex> maerwald: how is that a lie?
08:27:23 <mniip> consider doing otherwise in the future as it might be confusing for all people involved
08:28:06 <maerwald> bernalex: because filepaths are not lists of haskell Chars
08:28:37 <simg> Hi, I have a function which take a function as parameter with a type of (a -> IO b),  but I'm running it inside a monad transformer, so I want to pass it a function of type :: String -> App () where App is my monad transformer. (In this case, a ReaderT). If I wanted to lift an IO function into my transformer I would use liftIO. How do I go about doing the reverse?
08:29:45 <bernalex> maerwald: you are missingthepoint.png. if I do int God = 5;, that doesn't make God, should he exist, the number 5. God is just an identifier. FilePath up there is just a synonym for String which is a synonym for [Char].
08:30:07 <maerwald> bernalex: then your point is moot
08:30:30 <bernalex> maerwald: no it is not. [a] -> [a] is very different from a -> [a].
08:34:19 <pavonia> simg: What's the base monad of your ReaderT?
08:34:21 <Cale> simg: App just looks like a monad rather than a transformer there.
08:35:28 <Cale> If you have a ReaderT r IO action, and you want an IO action, then you might just want to runReaderT and supply the argument of type r.
08:37:46 * hackagebot cookie 0.4.2.1 - HTTP cookie parsing and rendering  https://hackage.haskell.org/package/cookie-0.4.2.1 (MichaelSnoyman)
08:37:48 * hackagebot css-text 0.1.2.2 - CSS parser and renderer.  https://hackage.haskell.org/package/css-text-0.1.2.2 (MichaelSnoyman)
08:37:50 * hackagebot clientsession 0.9.1.2 - Securely store session data in a client-side cookie.  https://hackage.haskell.org/package/clientsession-0.9.1.2 (MichaelSnoyman)
08:41:55 <S11001001> simg: Can you change the function you're trying to call?  Because in this case it should probably read MonadIO m => (a -> m b) -> ... instead of (a -> IO b)
08:42:02 <Philonous> I'm getting a package version conflict between zip-archive and Cabal with stack init --solver even though both packages are in lts 6.6, what am I doing wrong? 
08:42:34 <S11001001> simg: There's no need to make functions that "return" IO (i.e. have it in covariant position) use MonadIO, because you can always just liftIO.  But the function you're talking about has it in contravariant position, and can probably be written in terms of MonadIO itself, instead.
08:42:59 <simg> pavonia  | cale | S11001001 - thanks, just copying something to lpaste.net to make it clearer what I'm trying to do ...
08:47:35 <simg> I think this paste covers the salient code  though I doubt it would compile. http://lpaste.net/169237 . limitMap is the (a -> IO b) function and I'm trying to pass in runName on line 23
08:49:03 <simg> S11001001 : can I change the function? I don't know ! 
08:51:25 <mnoonan> just out of idle curiosity; say I have some Ast type that I defined as the fix point of a functor AstF, and I constructed a term t :: Ast that shares some subtrees
08:51:54 <mnoonan> e.g.  let x = ...; let t = Fix (PairF x x)
08:52:23 <mnoonan> if I do a catamorphism on t, does it repeat the work for both instances of x?
08:52:35 <S11001001> simg: yes you can change limitMap
08:52:46 <mnoonan> and assuming so, is there a way to make it smarter re: sharing?
08:52:48 <S11001001> simg: can you :t it in your repl and update the paste with its type sig?
08:53:26 <S11001001> OIC.  Hmm, bracket_ might cause you problems simg 
08:53:54 <S11001001> simg: the problem is, what does it mean to bracket your App
08:55:53 <simg> S11001001: the bracket_ in combination with QSEM is creating a "rate limiter" for the mapConcurrently so that only "n" threads run at the same time
08:55:59 <schmittr> Hi guys, it would be great if somebody could help me with this: https://paste.fedoraproject.org/388706/67906860/
08:57:28 <simg> S11001001: limitMap type signature added.
08:57:47 * hackagebot math-functions 0.2.0.0 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.2.0.0 (AlexeyKhudyakov)
08:57:49 * hackagebot data-elf 0.1 - Executable and Linkable Format (ELF) data structures.  https://hackage.haskell.org/package/data-elf-0.1 (MikhailVorozhtsov)
09:01:35 <S11001001> simg: your two problems are with mapConcurrently, and bracket_
09:02:36 <simg> S11001001: why?
09:06:04 <S11001001> simg: I suggest that Cale's approach is probably the easiest to get this to work.  You run both levels, supplying the Options from the MonadReader method and passing the resulting version of 'runName' to the current limitMap.  You will then get back an IO (t (Either AppError b)), and can use fmap sequence to get something that can be rewrapped in ExceptT,
09:06:04 <S11001001> and go from there.
09:06:47 <S11001001> simg: The problem is that both mapConcurrently and bracket_ are putting your IO in contravariant position, and there's not really a MonadIO-generic way to go App ~> IO.
09:08:13 <S11001001> simg: since you *can* write (a -> App b) -> Options -> a -> IO (Either AppError b), that's a good start.
09:08:52 <simg> S11001001: I believe you, but it's going to take me a little thinking to understand what you're saying :)
09:24:29 <woffs> Hi. I have an AMQP Timestamp (which is Word64). Is there a less ugly way to display it than posixSecondsToUTCTime $ fromInteger $ toInteger t ?
09:25:36 <schmittr> Y is a function not accepting a variable of type Object as Value, although Object is also part of Value, as described there: https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#t:Value
09:28:07 <geekosaur> woffs, fromIntegral
09:29:23 <sleblanc> woffs, Data.Time.Clock.POSIX.posixSecondsToUTCTime
09:29:29 <sleblanc> oh
09:29:34 <sleblanc> derp
09:29:51 <woffs> geekosaur, yeah
09:33:09 <geekosaur> oh. looks like realToFrac is the recommended one. (there's a Data.Fixed in there...)
09:42:26 <schmittr> got it, problem solved
09:42:48 * hackagebot feed-gipeda 0.1.0.2 - Simple project template from stack  https://hackage.haskell.org/package/feed-gipeda-0.1.0.2 (sgraf812)
09:46:23 <iphy> is it possible to pass double-dash flags to ld-options in cabal?
09:46:51 <iphy> hm, apparently "--flag" works
09:59:10 <simg> S11001001: I get it now, thanks. May I just ask, since this may be an easy question for you: I'm looking at the code for mapConcurrently and it doesn't seem like it would be *that* hard to write (cut/paste) my own version that uses my Monad transformer rather than IO. I wonder if you can see any obvious problems with this approach?
10:00:35 <S11001001> simg: Instead, I challenge you to write a version of mapConcurrently that replaces IO with App in its type signature, by *wrapping* the existing mapConcurrently :)
10:02:51 <simg> S11000001: how would that work? since I would ultimately need to pass "App" through an IO shaped hole ...?
10:03:41 <S11001001> simg: indeed, you would not need to do so; your limitMap wrapping is essentially solving this same problem
10:05:06 <simg> S11001001: in which case, I'm sure I must be fundamentally misunderstanding something. (which is not surprising)
10:06:59 <S11001001> simg: well, you should be able to write a variant of your own limitMap function that replaces IO with App everywhere in its signature, but otherwise just calls the IO-only limitMap to do the rest of the job
10:07:05 <S11001001> simg: perhaps best to start there
10:08:29 <GLM> If I have two IO actions in a do block, can I guarantee that they're being executed in the order I wrote them?
10:09:17 <lyxia> I think so GLM 
10:11:20 <cloudhead> yes, however nothing guarantees what happens after that GLM, but the actions will be "dispatched" in order
10:12:49 * hackagebot ip 0.8.3 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8.3 (andrewthad)
10:15:10 <geekosaur> ensuring execution order is pretty much the entire point of IO being a monad
10:15:57 <simg> S11001001:hmm, yes but ultimately mapConcurrently requires a function of type (a -> IO b) and I need to pass (a -> App b). I don't see how any amount of wrapping can change that?
10:16:23 <maerwald> geekosaur: would be scary if not xD
10:16:27 <maerwald> just imagine
10:21:27 <Cale> geekosaur: wh... no
10:21:40 <monochrom> no, would be magically fantastic if not. just imagine: putStrLn "hello" can be skipped if you are not watching.
10:21:42 <Cale> geekosaur: It would do that anyway, even if we didn't have a monad instance for it
10:21:54 <maerwald> monochrom: lol
10:22:00 <Cale> IO actions would still describe the order in which things were going to occur
10:22:05 <Cale> even if it wasn't a monad
10:22:08 <maerwald> monochrom: thats truly lazy...
10:22:53 <monochrom> yeah! it is my answer to simple people's slogan "haskell is lazy"
10:23:01 <S11001001> simg: So, it's true that you cannot write (a -> App b) -> a -> IO b.  Luckily, that's not the problem you have to solve.
10:23:38 <S11001001> simg: If you were able to write (a -> App b) -> Options -> a -> IO (Either AppError b) earlier, then this is a good first step
10:23:55 <ggVGc> can I automatically derive a Binary instance from a type like this? https://gist.github.com/8cf78b9ee7134e745f6632df7000d484
10:24:58 <S11001001> simg: you might notice that this is a slightly extended version of App b -> Options -> IO (Either AppError b).  So if you're having trouble with the one that adds 'a ->', try starting there.  (You can even use that as part of the solution to the version with 'a ->'.)
10:25:40 <Cale> The reason for IO to be a monad is that the operation for expressing what should happen next based on the result of the first action (and the operation which constructs an action that does nothing except to produce some constant result) just happens to fit the mould of a Monad instance, and once we have an instance of Monad, we get a bunch of other things for free in terms of that.
10:26:37 <Cale> Basically, libraries whose API contains appropriate operations to have a Monad instance ought to actually give a Monad instance, just because it's convenient and really for no other reason.
10:27:09 <Cale> It means we don't have to reimplement stuff like mapM and liftM2 and so on every time.
10:28:09 <dmwit> ggVGc: Have you tried?
10:28:10 <Cale> and it means that techniques such as monad transformers can be applied, and that Traversable operations work, and so on.
10:28:34 <S11001001> simg: The thing that you're shooting for is that the little problem (turning App to IO) is unsolvable, but your real problem is much more structured than that.  So by avoiding focusing on one part, the impossible App ~> IO, we can find a solution by considering the whole signature of limitMap.
10:28:43 <simg> S11001001: how would the state contained in my Reader monad (ie App) get passed through IO to runName? Bear in mind that runName is the tip of the iceberg. I could easily extract the state from the reader in mapLimit and pass it in as normal parameters, but that would be defeating the object of using the readerMonad in the first place?
10:29:00 <dmwit> ggVGc: Side note: why the inconsistent names? (e.g. why not `IntervalOO` instead of `OpenInterval`?)
10:29:19 <S11001001> simg: reader is there for your convenience; when it's not convenient, you can flip away from it
10:29:59 <S11001001> simg: Pretty much you're destructuring your whole transformer stack because it's not suited to bracket_ and mapConcurrently, but then after you're done you have sufficient structure to wrap everything back up.
10:30:27 <ggVGc> dmwit: its not my library. I'm just trying to get an IntervalTree that I can serialize
10:30:54 <dmwit> ggVGc: `deriving (..., Binary)` Just Works here.
10:31:05 <ggVGc> dmwit: and, yeah, I tried but I don't understand the automatic deriving so well. I just tried `instance Binary Interval` which doesn't work sinceit's the wrong kind
10:31:15 <dmwit> ggVGc: If you can't add it at the `data` definition site, the `StandaloneDeriving` extension may interest you.
10:31:20 <simg> S11001001: OK, that's what I wondered. which makes me think it would make more sense just to write my own version of mapConcurrently?
10:31:36 <S11001001> simg: and that's where my challenge came in :)
10:32:01 <S11001001> simg: Because you can use this technique to just wrap the existing mapConcurrently with your own version that speaks App instead
10:32:06 <ggVGc> dmwit: I get that Binary is not a derivable class?
10:32:13 <dmwit> ggVGc: `instance Binary a => Binary (Interval a)` works here.
10:32:26 <dmwit> ggVGc: Oh, right, I also enabled `DeriveAnyClass`
10:32:32 <ggVGc> ah, thanks
10:32:35 <ggVGc> that works
10:32:40 <ggVGc> thanks a lot
10:32:49 * hackagebot data-endian 0.1.1 - Endian-sensitive data  https://hackage.haskell.org/package/data-endian-0.1.1 (MikhailVorozhtsov)
10:32:51 * hackagebot keenser 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/keenser-0.1.0.0 (jdabbs)
10:46:10 <simg> S11001001: hmm, ok I think I get it. So you're suggesting de-structure my transformer stack in limitMap, pass it through mapConcurrently as normal parameters and then re-constitute it in runName? If so, I can see that's a useful idea but wouldn't it make more sense just to either a) initialise multiple instances of my transformer in runName  (and not bother with a top level transformer)  or b) just handle threads myself using ForkIO?
10:46:31 <S11001001> simg: you don't have to reconstitute it in runName
10:46:43 <simg> S11001001: why not :) ?
10:47:58 <simg> S11001001: you realise there's LOTS of code (mostly as yet unwritten) below runName that needs the data in the ReaderT
10:48:19 <S11001001> simg: because you can write Traversable t => Int -> (a -> App b) -> t a -> App (t b)
10:49:05 <S11001001> simg: which can be implemented by calling your existing limitMap, and also doing other stuff
10:51:24 <S11001001> simg: this means that runName can continue to simply think in terms of App; all transformery stuff is in this wrapper function around limitMap
10:51:58 <simg> S11001001: I wonder if I am missing something fundamental. how does the "App" get through mapConcurrently into runName ?
10:55:10 <S11001001> simg: I think the problem is that you're focusing too narrowly on this one aspect
10:55:30 <S11001001> simg: if you try to solve that as a simple, context-free function, you'll fail
10:56:14 <S11001001> simg: let's try to solve just one layer
10:57:31 <S11001001> simg: Can you write this, by calling your existing limitMap?  Let's call it limitMap2 :: Traversable t => Int -> (a -> ReaderT r IO b) -> t a -> ReaderT r IO (t b)
11:00:40 <simg> S11001001: given enough time, I think possibly yes :) 
11:01:06 <S11001001> simg: go for it then :)
11:03:20 <simg> S11001001: "enough time" is numerous hours or possibly days at this point :/. I know pretty much what ReaderT is and what it's for, but I'm cutting and pasting from this tutorial at the moment : https://robots.thoughtbot.com/refactoring-to-a-monad-transformer-stack
11:05:28 <S11001001> simg: now might be time to pay off that learning debt then :)
11:07:50 * hackagebot hedis-namespace 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/hedis-namespace-0.1.0.0 (jdabbs)
11:09:54 <simg> S11001001: yes, might be. but I wonder if we're talking at cross purposes? I very much appreciate your help but I wonder if 2 days from now when I finally work out how to destructure my monad stack etc I'm going to think; "yeah, I should have just re-written mapConcurrently" or "I should have just instantiated multiple transformer stacks in runName" ?
11:14:00 <Cale> simg: I think it helps not to think about it as a "stack" -- if you have to care about all the monads you got on the way to the one you constructed, you're using monad transformers incorrectly. (I hate the term "monad transformer stack" for that reason)
11:14:48 <Cale> In fact, you should try as much as possible to avoid having it be apparent throughout most of your library or application that you're using monad transformers at all
11:16:20 <Cale> You construct the monad that you want by applying some transformers, then you newtype that, and hide the newtype's data constructor at a module boundary, and define enough operations inside that module that the stuff outside needn't know or care that the monad is defined using transformers.
11:17:39 <johnw> Cale++
11:18:20 <simg> Cale: seems reasonable. which is pretty much what I have with "App"? problem is I don't see how to pass App through a function that works with IO.
11:18:53 <Cale> If the function takes an IO action, then you simply can't pass an App action to it.
11:19:55 <Cale> This is a good reason that you shouldn't take the process of throwing a ReaderT over IO lightly -- there are a bunch of really useful higher order functions involving IO, such as forkIO and catch, which become less convenient to use.
11:20:53 <Cale> So you want to be certain that you're getting paid back for the extra inconvencience in some way. ReaderT in particular doesn't buy you very much on its own -- it's just passing a parameter around, and not only that, but you've traded writing the parameter name for writing liftIO everywhere.
11:23:18 <simg> Cale: part of the payback for me is understanding monad transformers, but yes I'm already wondering if for this particular program the benefits of using a monad transformer are worth the inconvenience.
11:23:41 <johnw> Cale: he can if App can be made an instance of MonadBaseControl, of course
11:23:48 <Cale> yeah...
11:23:52 <ertes> evolution of a haskell programmer: IO ("i hate this thing!") → ReaderT ("wow, i love this one!") → ReaderT ("this is getting inconvenient") → MonadIO ("ah, slightly better, but still not quite") → MonadBaseControl ("finally a good solution…  i think…") → ("there has to be a better way!") → Eff ("hah! finally! … i think…") → ("hmm…") → IO ("i love this thing!")
11:23:57 <dfeuer> MonadBaseControl is ... weird.
11:23:59 <johnw> I usually end up with a set of "embed" functions that allow me to pass App in places that expect IO
11:24:05 <Cale> ertes: yes, exactly
11:24:15 <Rembane> ertes: It's a loop, right?
11:24:26 <ertes> Rembane: i don't think it is =)
11:24:31 <johnw> MBC takes getting used to, for sure, but I think I use it in every module I write these days that uses transformers
11:24:31 <Rembane> ertes: Sweet! :D
11:24:35 <Cale> If MonadBaseControl is the solution to your problems, then you've probably gone off the rails already somewhere ;)
11:24:37 <Rembane> ertes: DAG-fest 2016! :D
11:24:44 <johnw> Cale: hah, fair enough!
11:25:02 <c_wraith> at this point, I prefer to work entirely in domain specific models that never explicitly mention IO
11:25:10 <dfeuer> c_wraith++
11:25:27 <Rembane> All the run functions!
11:25:30 <c_wraith> and then put all the hairy IO code in one spot. 
11:26:14 <ertes> the only thing worse than having to use MonadBaseControl is to have to write an instance of it
11:26:35 <johnw> ertes: that is so true
11:26:43 <johnw> ertes: I have a bunch of templates for writing different flavors of MonadBaseControl instances
11:27:02 <johnw> with/without state, based in IO vs. based in MonadBase b, etc.
11:27:03 <ertes> not that monad-control is a bad library, it's actually pretty neat…  but i prefer not to have the problem it solves =)
11:27:25 <c_wraith> you mean someone other than the creator implemented MonadBaseControl successfully? 
11:27:56 <johnw> I reimplemented MonadBaseControl from scratch once, in order to finally understand it
11:28:10 <johnw> that resulted in a tutorial that's on school of haskell
11:28:10 <dysfun> did you succeed in understanding it?
11:28:13 <johnw> yes
11:28:17 <dysfun> :)
11:28:27 <johnw> the concept is very clear underneath, there's just a lot of syntax around it
11:28:31 <ertes> dysfun: it's really just a fancy delimited state monad abstraction
11:28:39 <hpc> now you can write a fancy tutorial for it
11:28:39 <johnw> it also resulted in several new functions that I got merged into monad-control
11:28:44 <hpc> MonadBaseControl is like tapas
11:29:20 <ertes> "delimited" in the sense that you can get the current state as a first class value, and later you can feed it into a new action
11:29:25 <ertes> to "continue" it
11:29:32 <hpc> https://youtu.be/4T1RMuoQnKo?t=64
11:29:57 <Rembane> Is it some continuing passing style shenanigans?
11:30:06 <Rembane> *continuation
11:30:07 <ertes> if you look at the API with that in mind, it may make a bit more sense…  or it may make even less sense, and i'm falling for the monad tutorial fallacy once again
11:30:30 <shapr> johnw: do you have a link to that tutorial?
11:30:31 <ertes> well, it's CPS without the C =)
11:30:44 <Rembane> Passing away in style?
11:30:49 <shapr> johnw: oh, I found it: https://www.schoolofhaskell.com/user/jwiegley/monad-control
11:32:20 <johnw> yes
11:32:51 * hackagebot pinchot 0.18.2.0 - Write grammars, not parsers  https://hackage.haskell.org/package/pinchot-0.18.2.0 (OmariNorman)
11:37:51 * hackagebot monad-abort-fd 0.5 - A better error monad transformer  https://hackage.haskell.org/package/monad-abort-fd-0.5 (MikhailVorozhtsov)
11:57:42 <buglebudabey> does anyone have a trick for remembering what order the accumulator and value go in a foldr vs  foldl? for instance which function takes in (\acc x -> x .. acc) vs (\x acc -> x .. acc)
11:58:36 <shapr> buglebudabey: isn't it always the last argument?
11:58:37 <buglebudabey> where acc is the base
11:58:47 <shapr> er, accumulator is last?
11:58:52 <shapr> maybe I'm wrong :-(
11:59:00 <buglebudabey> foldr and foldl have them switched, i just have trouble remembering which is which
11:59:15 <hpc> the way i remember it is foldr (:) [] = id
11:59:26 <buglebudabey> > foldr (\acc x -> x:acc) [] [1,2,3,4]
11:59:27 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
11:59:28 <lambdabot>      Relevant bindings include
11:59:28 <lambdabot>        x :: [a] (bound at <interactive>:1:13)
11:59:38 <buglebudabey> > foldr (\x acc-> x:acc) [] [1,2,3,4]
11:59:39 <lambdabot>  [1,2,3,4]
12:00:08 <buglebudabey> > foldl (\acc x-> x:acc) [] [1,2,3,4]
12:00:09 <lambdabot>  [4,3,2,1]
12:00:34 <buglebudabey> ok accumulator is on the right on foldr, on the left for foldl (thumbs up)
12:12:44 <lukenels> @buglebudabey Another way of thinking about it is that the folds walk over the list "replacing" each cons with some operator
12:12:44 <lambdabot> Unknown command, try @list
12:12:56 <lukenels> if you associate to the right as with foldr
12:13:09 <lukenels> the left element has to be a member of the list, so the second is the accumulator
12:13:19 <lukenels> if you associate to the left, the exact opposite is the case
12:13:37 <buglebudabey> lukenels that's a good way of thinking about it
12:14:35 <lukenels> ex: foldr (+) 0 (1 : 2 : 3 : []) = 1 + (2 + (3 + (0))
12:14:44 <lukenels> each : becomes +
12:14:46 <lukenels> and [] becomes 0
12:14:58 <lukenels> it's a cute way to think about folds
12:15:28 <buglebudabey> ill take anything to cement my understanding
12:21:34 <ertes> buglebudabey: here is the ultimate way to remember it: memorise it
12:21:40 <ertes> it's arbitrary
12:21:49 <maerwald> ertes: why? the compiler will tell you anyway if you do it wrong :P
12:21:50 <shapr> @hoogle Arbitrary
12:21:52 <lambdabot> Test.QuickCheck.Arbitrary class Arbitrary a
12:21:52 <lambdabot> Test.QuickCheck class Arbitrary a
12:21:52 <lambdabot> Test.QuickCheck.Arbitrary module Test.QuickCheck.Arbitrary
12:22:01 <ertes> =)
12:22:12 <buglebudabey> ertes hence the trick ;)
12:24:03 <ertes> buglebudabey: here is how i memorised it: it's usually the wrong order for the transform you're writing, and because 'flip' makes it even worse, you end up writing local definitions
12:24:19 <ertes> works even better for foldl'
12:24:27 <buglebudabey> ertes i noticed that too
12:24:34 <buglebudabey> its a pain
12:25:28 <ertes> @let daRealFoldr z f = foldr (flip f) z
12:25:29 <lambdabot>  Defined.
12:26:23 <shachaf> The order of arguments to foldr's function isn't arbitrary.
12:26:33 <shachaf> It's defined such that foldr (:) [] is id
12:27:28 <fr33domlover> Here's how I remember it: I think of a fold as a "wave" that washes the list. foldr does it from right to left, to the list item comes before the accumulated result
12:27:35 <fr33domlover> Same for foldl, in reverse
12:27:45 <tippenein> anyone sufficiently experienced in Persistent to know what this error is caused by>? http://lpaste.net/169104
12:27:52 <tippenein> SQLite3 returned ErrorRange while attempting to perform bind text.
12:28:36 <maerwald> fr33domlover: I find that problematic, because it sometimes make people think foldr traverses the list from the right, which it doesn't
12:29:13 <maerwald> so I usually avoid anything that sounds like "from the right"
12:29:16 <ertes> shachaf: i'm just being cynical…  but there is still the question why it's not foldr [] (:) = id, and for foldl' it's indeed completely arbitrary
12:29:40 <fr33domlover> maerwald, agreed, it should be accompanied with an explanation how it really works
12:29:55 <fr33domlover> It's just the way I remember it :P
12:29:58 <shachaf> I don't think foldl' is arbitrary, though it's slightly more so.
12:30:40 <shachaf> foldr f z vs. foldr z f is indeed something you have to memorize.
12:30:41 <fr33domlover> tippenein, I don't know the error but issus I see are: (1) mak sure "persons" is the right name of the table
12:30:43 <ertes> yeah, i guess there is some point in flipping there:  it reinforces the "fold direction" confusion =)
12:30:59 <shachaf> I don't know why there's confusion.
12:31:14 <fr33domlover> (2) I don't remember exactly how the LIKE operator works, make sure the syntax there is correct, tippenein
12:31:22 <maerwald> foldR -> recursion on the right argument, foldL -> recursion on the left argument
12:31:24 <shachaf> foldr (*) 1 [a,b,c] = a * (b * (c * 1))
12:31:36 <shachaf> foldl (*) 1 [a,b,c] = ((1 * a) * b) * c
12:31:54 <shachaf> Seems pretty reasonable to me.
12:32:33 <ertes> it's really arbitrary…  why not foldr (*) [a,b,c] 1?
12:32:47 <dolio> Because that order is worse.
12:33:23 <ertes> of course it is, but my point is that "reasonable" is subjective
12:33:27 <dolio> The order it's in is the best order most of the time.
12:33:39 <johnw> ertes: in Coq, the order of those arguments is flipped between fold_right and fold_left, and it's just annoying
12:33:45 <maerwald> I don't like the order of (.) ;)
12:33:47 <shachaf> I agreed that those two arguments -- f z vs. z f -- are a choice that you have to memorize. But that wasn't what the question was about, and anyway I don't think people have trouble remembering that.
12:36:17 <ertes> not that it bothers me much, but my point is that the argument orders there are arbitrary and work better for some and worse for others
12:36:28 <ertes> i never had real trouble memorising them
12:37:06 <fishythefish> I prefer f z to z f because I'm more likely to decide on the folding function before the nil value
12:37:26 <dolio> Exactly.
12:37:52 <ertes> but most of the time, i'd wish that foldr was exactly in the opposite order
12:38:45 <johnw> I like to use: foldr ?? z xs $ \x rest -> ...
12:39:09 <nitrix> If GHC encounter two type signatures with the same type variables in there, can I predictably guess which of the two will be assigned what number?
12:40:01 <ertes> usually i start like (f = foldr _f _z), then refine to (f = foldr go _z where go x r' = _r)
12:40:01 <glguy> johnw: You like to or would like to?
12:40:08 <johnw> I like to
12:40:08 <dolio> That's when you have all arguments to apply to, though.
12:40:14 <johnw> right, true
12:40:47 <dolio> There are a lot of situations where you can define things by partially applying foldr.
12:41:04 <glguy> johnw: To use ?? like that you'd have to use: foldr ?? z ?? xs $ \x rest ->
12:41:23 <nitrix> length = foldr (\x _ -> x + 1) 0
12:41:34 <nitrix> err, foldl
12:41:36 <dolio> And when you do that, the list is the most likely thing to not be present, and the zero case probably next-so.
12:41:39 <fishythefish> foldl'
12:42:01 <johnw> glguy: I would?  it works here
12:42:09 <nitrix> fishythefish: Irrelevant for the problem description and the example.
12:42:31 <glguy> johnw: It'll typecheck if you leave out the second ?? but it won't do what the names you picked sugests
12:42:51 <fishythefish> nitrix: arguably, so is the list example - since we're arguing about f z vs z f
12:42:52 <johnw> ah
12:42:53 <fishythefish> but let's not get into it
12:42:57 <fishythefish> length example*
12:42:57 <dolio> Well, it might not type check.
12:43:21 <glguy> foldr f z xs  === foldr ?? z ?? xs $ f
12:43:28 <nitrix> fishythefish: It was in regard to "19:40:24            dolio | There are a lot of situations where you can define things by partially applying foldr."
12:43:45 <dolio> It'd be pretty surprising if it did typecheck assuming `foldr ?? z ?? xs $ f` is expected to type check.
12:43:59 <johnw> the double ?? version is the right one, after writing the type signature
12:44:20 <johnw> i guess I was misreading ??, since what I usually write is (\f -> foldr f x zs) $ \x rest -> ...
12:44:21 <glguy> :t foldr ?? ?z ?xs $ ?f
12:44:22 <lambdabot> (Foldable t, ?f::a1 -> a -> a, ?xs::t1, ?z::t1 -> a) => t a1 -> a
12:44:54 <tippenein> fr33domlover: persons is the right table and this sql query works in the sqlite3 console select * from persons where name like '%Don%';
12:45:22 <tippenein> I think it has something to do with the ?? not inferring the correct type?
12:48:53 <fr33domlover> tippenein, you're missing a % there though
12:49:02 <fr33domlover> not sure if that's the reason though
12:49:24 <tippenein> nope, just tried that too. Tried it without the parens as well
12:49:52 <tippenein> very bizarre
12:50:27 <fr33domlover> tippenein, maybe toPersistValue doesn't do what you expect
12:50:39 <fr33domlover> because you use in inside the LIKE, which isn't the usual usage
12:50:48 <fr33domlover> try to concat it into the query
12:51:15 <fr33domlover> "LIKE '%" <> query <> "%'"
12:51:46 <tippenein> this mentions the error - https://hackage.haskell.org/package/direct-sqlite-2.3.17/docs/src/Database-SQLite3.html#bindSQLData
12:52:02 <tippenein> fr33domlover: mmk, lemme try that
12:52:15 <fr33domlover> tippenein, also btw you have a LIKE operator in esquqleto
12:52:26 <fr33domlover> so you can write that query without raw SQL
12:52:35 <fr33domlover> *esqueleto
12:52:36 <tippenein> O_O o rly
12:54:03 <tippenein> the <>query<> idea doesn't work either
12:54:23 <tippenein> good idea nonetheless
12:54:48 <johnw> has anyone given thought to State raised to a Kleisli multicategory?  That is, going from arrows s -> a -> (b, s) to s -> (a1, a2, a3, ..., an) -> (b, s)?
12:56:53 <dfeuer> johnw, I have no idea, but that reminds me of the great annoyance of dealing with  ST s (a,b,...), which GHC doesn't always manage to unbox.
12:56:58 <johnw> it's sad when googling for something only has a total of two pages of hits
12:58:40 <johnw> dfeuer: the reason I'm asking is that it seems like abstract data types can be generalized as a Multistate category, whose arrows are its methods.  The monad for such a category seems to be akin to creating a tree showing how arguments to one method call arise from the results of calling preceding methods, etc., back to the moments of initial construction.  I'm just wondering if thinking about these structures gives me any useful tools
12:58:40 <johnw> for working with ASTs.
13:03:12 <edwardk> tuning in because i was asked
13:03:43 <edwardk> you should be able to make a multicategory out of any kleisli category on hask
13:03:47 <edwardk> because we have products
13:04:07 <edwardk> and they lift to something 'product-like' under an Arrow
13:04:22 <edwardk> and there is a Kleisli Arrow
13:04:27 <johnw> what benefits does that give us?
13:04:34 <tippenein> fr33domlover: thanks for the tip on esqueleto. It worked perfectly
13:04:47 <johnw> since there is nothing multido, I can't imagine multibind constructions remaining tractable for long
13:04:52 <johnw> nothing like*
13:04:52 <edwardk> it has the usual problems of ListT that it isn't always a nice multicategory, but state works
13:04:58 <dolio> johnw: It seems like it might not actually be a multicategory.
13:05:00 <edwardk> it gives no benefit
13:05:08 <johnw> dolio: please continue!
13:05:16 <edwardk> hrmm
13:05:39 <dolio> It's not clear to me that associativity doesn't reorder how you thread the state.
13:05:55 <johnw> oh, that's very true
13:06:05 <edwardk> the associativity thing is what i was concerned with by the ListT analogy
13:06:06 <dolio> Breadth first vs chunked.
13:06:09 <johnw> the answer is very much dependent on order
13:07:27 <johnw> the reason I lookup up edwardk's library is that I'm working with a library right now that's all about ASTs, and there are some patterns I'm starting to notice in dealing with proofs about method calls, which made me wonder if there were ways to generalize.  Not any patterns I've identified specifically, just code that's been feeling mechanical lately.
13:07:58 <edwardk> you could make one that goes backwards, a -> s -> [(b, s)]
13:08:00 <johnw> there are times I'd just like to say "connect these two methods calls", without caring about arity
13:08:26 <johnw> (or rather, connect these n methods call with this method call)
13:08:27 <edwardk> where the 'b's are the inputs to the 'multiarrow'
13:08:46 <edwardk> that lets you fan out the state separately down each path
13:08:50 <edwardk> and avoids reuse issues
13:09:01 <edwardk> its the same sort of backwards multicategory as the tictactoe stuff
13:09:41 <johnw> edwardk: how does that relate to something like a sequence of method calls, though?
13:09:44 <edwardk> er. a -> s -> Vec n (b, s)
13:10:16 <edwardk> it doesn't, basically you're getting a branching tree of computations that in the end generates n distinct results, sharing some startup
13:10:24 <johnw> right now I have this data type: methodType rec dom cod, where dom is a list.  It's effectively a multiarrow, if I'm reading it right
13:10:55 <edwardk> didn't say the thingi mentoined was useful to you, just that it was a legal multicategory =)
13:11:00 <johnw> ah, ok :)
13:14:47 <acowley> johnw: You can do something like that kind of chaining with machines, can't you?
13:15:04 <acowley> johnw: I know I was aiming towards something like that at some point but I don't know where it stands now
13:15:14 <johnw> chaining with machines?
13:15:25 <johnw> do you mean the machines library? or just any Mealy machine?
13:15:45 <acowley> The library
13:17:58 <seyt> hi
13:18:20 <seyt> In    calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
13:18:33 <seyt> what does (RealFloat a) mean ?
13:18:42 <seyt> the return type ?
13:19:11 <johnw> it means that the type chosen by the caller is be anything that supports the RealFloat interface
13:19:16 <johnw> can be*
13:19:43 <seyt> johnw: ok () define the interface right ?
13:20:02 <johnw> for RealFloat you shouldn't need to.  Just pick something like Double
13:20:50 <seyt> I see thanks johnw 
13:28:29 <khumba> Why would calling "cabal install --extra-lib-dirs=..." for a library work but injecting (emptyBuildInfo {extraLibDirs = ["..."]}) via HookedBuildInfo in preConf, preBuild, preTest, preCopy, preInst hooks not?
13:29:10 <khumba> By "not work", I mean that building a program that uses this library fails, because it can't find the extra .so the library needs ("<command line>: can't load .so/.DLL ...").
13:30:18 <khumba> The build logs show no difference.
13:32:39 <khumba> And the extra library dir is missing from the library's package.conf file, with --extra-lib-dirs.
13:33:53 <dolio> johnw: So, I talked with xplat, and we both don't think that's an actual multicategory.
13:34:18 <johnw> dolio: ok, you had me mostly convinced already
13:34:33 <johnw> thanks for thinking about it more
13:34:42 <dolio> Or, alternately, State s isn't a monad on the multicategory of normal arrows, if you can figure out how to even define what such a monad is.
13:35:04 <dolio> For similar reasons.
13:36:06 <dolio> And arrows would display similar defects.
13:38:08 <dolio> Like, `(f1 *** f2 >>> f3) *** (g1 *** g2 >>> g3) >>> h` is not the same as `(f1 *** f2) *** (g1 *** g2) >>> (f3 *** g3) >>> h`.
13:40:14 <khumba> Aha, needed a preReg hook.
13:41:15 <dfeuer> Why does http://stackoverflow.com/a/38254568/1477667 change anything (GHC 7.10)? Is this a compiler bug, or am I misinterpreting something?
13:44:38 <dolio> It is a bug that it works in 7.10.
13:45:32 <dfeuer> dolio, which bit's a bug? 
13:46:14 <dolio> That id is a valid implementation of those functions.
13:46:45 <khumba> instHook never seems to run though; cabal install runs copyHook...  Is instHook something that's only used for global installs?
13:47:11 <dfeuer> dolio, ah, well, that's not even my question, which has to do with the fact that I need to manually expand the type synonyms and float out the contexts to make the rewrite rule compile.
13:53:38 <dfeuer> dolio, do you have any thoughts about the type synonym aspect?
14:05:12 <Ero__> greetings fellow haskelletors
14:06:21 <Stalkr^> Hi, this might be very Haskell specific but I'm playing around with a toy language using Haskell, Alex and Happy. I'm having trouble building up the environment as I traverse the AST though. Should my signature for evaluating look something like "Env -> Exp -> (Env, String)", where String is the output (build a transpiler/compiler) and Env = [(String, Exp)]
14:06:57 <ggVGc> am I missing something or is there no way to edit or remove an interval here? https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-IntervalMap-FingerTree.html
14:07:33 <Stalkr^> I have a let binding like `Let String Exp` where I want to expand the env with String pointing to Exp, so I can later lookup and see if some `Var String` should be defined
14:08:44 <lyxia> Stalkr^: The representation is simplistic but you can do it that way indeed.
14:09:56 <Stalkr^> lyxia: Do you have a better representation? Right now I try to keep the language very simple for learning purposes, but would love some input
14:10:20 <lyxia> Stalkr^: I'd use a Map instead of an associative list
14:11:00 <lyxia> Stalkr^: and try State
14:11:19 <Stalkr^> lyxia: State monad?
14:11:42 <Clint> State functor
14:11:59 <lyxia> yes. State Env a is Env -> (a, Env)
14:13:32 <Stalkr^> Oh boy, getting into some new territory here. Did a "compiler" course using F#, but trying to teach myself some Haskell by writing a simple compiler/transpiler. Monads are new, so I'll have to read up on it
14:13:39 <lyxia> Using State hides the boilerplate of threading an Env in your program, only mentioning it where it matters, when you're modifying or reading the environment.
14:13:49 <enthropy> ggVGc: looks like you can't delete to me
14:14:08 <ggVGc> :(
14:14:18 <ggVGc> I'm not sure how this implementation is intended to be used
14:14:38 <Stalkr^> So what do my signature look like? State -> Exp -> State?
14:14:56 <Stalkr^> Map -> Exp -> State?
14:15:10 <lyxia> Stalkr^: Exp -> State Env String
14:15:44 <Stalkr^> Thanks, I will try playing with that
14:19:24 <ertes> ggVGc: that implementation seems to be incomplete…  use the IntervalMap library instead
14:19:40 <ertes> ggVGc: (or, if you're brave, implement your own IntervalMap on top of FingerTree)
14:20:45 <ThreeFx> @pl \n -> read.(=<<)(\x->filter(==x)$show n)"8549176320"
14:20:45 <lambdabot> (read .) . ("8549176320" >>=) . flip (filter . (==)) . show
14:21:09 <glguy> ThreeFx: You can play with lambdabot in /msg
14:21:24 <ThreeFx> Alright, sorry.
14:50:59 <daey> why does 'repeat' exist when you can use cycle? e.g. repeat 5 == cycle [5]
14:51:17 <mauke> convenience
14:52:57 * hackagebot yesod-worker 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/yesod-worker-0.1.0.0 (jdabbs)
14:56:09 <dmwit> repeat is total; cycle is not.
14:56:23 <daey> total?
14:56:50 <dmwit> Fully defined inputs produce fully defined outputs.
14:56:59 <dmwit> > cycle []
14:57:01 <lambdabot>  *Exception: Prelude.cycle: empty list
14:57:26 <daey> and repeat is not total because?
14:57:43 <daey> the input is fully defined. right?
14:57:49 <dmwit> Why do you say repeat is not total?
14:57:57 * hackagebot replicant 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/replicant-0.1.0.0 (jdabbs)
14:58:39 <daey> dmwit: you said that
14:58:43 <dmwit> Where?
14:58:47 <koala_man> < dmwit> repeat is total; cycle is not
14:58:51 <daey> cycle i mean*
14:59:07 <daey> well i wrote it as a question, so it was kinda obvious i mixed it
14:59:08 <dmwit> > cycle [] -- fully defined input; but undefined output
14:59:10 <lambdabot>  *Exception: Prelude.cycle: empty list
14:59:41 <daey> because you cant predict where its cut of?
14:59:56 <dmwit> What does "cut off" mean?
14:59:56 <daey> like cycle [5] should be total right?
15:00:13 <dmwit> "total" is a property of functions. `cycle [5]` is not a function.
15:00:32 <daey> hm
15:00:58 <daey> if i were to limit the input to said function to only single numbers, would it then be total?
15:01:17 <koala_man> if you defined repeat2 x = cycle [x], then repeat2 would be total
15:01:19 <dmwit> Right. And that is what repeat does -- and that is (in my opinion) a good reason to have it.
15:01:39 <daey> ok
15:05:43 <ertes> also 'repeat' has a very useful relationship with 'zipWith'
15:07:20 <pavonia> What relationship?
15:07:56 <ertes> pavonia: zipWith f (repeat x) ys = map (f x) ys;  zipWith f xs (repeat y) = map (`f` y) xs
15:08:05 <ertes> pavonia: 'repeat' is 'pure' of ZipList
15:09:36 <pavonia> Hhm, there's clearly some pattern in the types of repeat, map and zipWith
15:10:44 <dmwit> Yes. repeat = map0; map = map1; zipWith = map2
15:11:00 <dmwit> zipWith + repeat are sufficient to construct mapn for any n
15:12:06 <ertes> i would miss 'repeat' more than 'cycle'
15:12:47 <ertes> not that i use either much, but i definitely use 'repeat' more often…  and cycle is easy enough to express
15:12:52 <ertes> :t concat . repeat
15:12:53 <lambdabot> [a] -> [a]
15:16:29 <c_wraith> ertes, but, but.. you just lost sharing! all that extra allocation! 
15:20:04 <daey> these  explanations above function declarations, are they optional? it seems to work without them 'sayHello :: String -> IO ()' 
15:20:56 <c_wraith> daey, they usually can be inferred, and are provided as documentation. 
15:21:08 <pavonia> You may run into problems if typeclasses are involved sometimes
15:21:29 <daey> wasnt planning to skip them, was just wondering
15:21:48 <c_wraith> also, they're *really* good documentation. the compiler checks them, and they actually say a lot. 
15:21:55 <ertes> c_wraith: fix (xs ++)  -- it's shorter anyway =)
15:22:57 * hackagebot webrtc-vad 0.1.0.3 - Easy voice activity detection  https://hackage.haskell.org/package/webrtc-vad-0.1.0.3 (PatrickChilton)
15:23:16 <ertes> daey: interestingly in haskell type signatures are not declarations, but rather claims…  the compiler checks whether you got them right =)
15:24:00 <daey> enforced correct documentation. soudns like something python4 might be interested in
15:24:28 <c_wraith> daey, Oh yeah. sometimes it helps the compiler generate better error messages when you annotate the types with what you think they should be, and it disagrees. 
15:27:58 * hackagebot clang-pure 0.1.0.1 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.1.0.1 (PatrickChilton)
15:30:48 <lpaste> none pasted “blah.hs” at http://lpaste.net/6815133506906095616
15:31:19 <umib0zu> hey. anyone want to help me out with this ^^^
15:31:46 <shachaf> With what?
15:31:49 <umib0zu> I’m trying to define a Category using Control.Category. But I’m confused at the type level at what the type constructor means.
15:33:54 <umib0zu> looking at https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Category.html, cat a b appears to be the type of morphisms, and in this case, a and b are the source and target.
15:34:01 <umib0zu> especially when looking at (.)
15:34:48 <umib0zu> but it’s odd because what if my src and targets are values. am I supposed to have values at the type level, and how do I do this anyways?
15:35:36 <c_wraith> yep, you're getting confused about what level things are operating on. 
15:37:18 <c_wraith> a category doesn't necessarily denote a transformation operation at the value level. 
15:37:42 <c_wraith> categories that act like functions do imply that. 
15:38:24 <c_wraith> but you can have categories over types that contain no ->
15:38:30 <umib0zu> sure, but what if I want that. by value I’m assuming we’re talking about “concrete types”. types of kind (*).
15:39:19 <shachaf> c_wraith: I,I What's a category action? A functor?
15:40:15 <umib0zu> like for example, what if I wanted to define a monoid using category. in it, there’s only one object, so a morphism better only go from a type of a kind (*) to a type of a kind (*), and it better be a single value.
15:40:18 <c_wraith> like, M x N matrices form a category with matrix multiplication as (.) and the N x N identity matrix as the identity 
15:40:56 <shachaf> Why "a type of a kind (*)"?
15:41:14 <umib0zu> cause that’s a monoid. it’s a category with only one object
15:41:29 <shachaf> Maybe I don't understand what you mean.
15:41:53 <umib0zu> well look at (.)
15:42:15 <umib0zu> it says cat b c -> cat a b -> cat a b
15:42:29 <umib0zu> but cat is a type constructor
15:42:34 <c_wraith> the Category class is specific to types with kind (k -> k -> *). (well, on new enough versions of base) 
15:42:42 <umib0zu> yes
15:42:50 <c_wraith> I suppose there are kinds with only one type. 
15:42:59 <c_wraith> but * isn't such a kind. 
15:43:03 <umib0zu> so it seems like, in the language of category theory, cat a b is “a morphism from a to b"
15:43:35 <umib0zu> so now what if I want to restrict myself to a category with one object and only instantiate (.) from cat () () to cat () ()
15:43:43 <johnw> I wouldn't say "in the language of category theory", but in the syntax of the Hasell Category class
15:43:46 <umib0zu> here () is a value
15:43:53 <shachaf> () isn't a value.
15:43:56 <umib0zu> sorry I’m not sure how to describe this
15:43:58 <shachaf> Oh, I see.
15:44:10 <shachaf> I guess you mean a promoted value.
15:44:18 <umib0zu> I think this is second order lambda calculus since there are values in the type
15:44:30 <shachaf> There are no values in the type.
15:44:31 <umib0zu> but I haven’t really read up on second order lambda calculus
15:44:46 <umib0zu> well isn’t () a value? it’s a naked tuple
15:44:51 <c_wraith> () is a type, too
15:44:58 <pavonia> :t ()
15:44:59 <lambdabot> ()
15:45:00 <Enigmagic> :t ()
15:45:00 <lambdabot> ()
15:45:02 <Enigmagic> doh :p
15:45:13 <dedgrant> heh
15:45:14 <umib0zu> yea but isn’t that what second order lambda calc is about?
15:45:19 <umib0zu> I want to have values in my type
15:45:24 <umib0zu> do I just say cat () ()
15:45:26 <umib0zu> ?
15:45:33 <c_wraith> Haskell doesn't do that. 
15:45:47 <c_wraith> Haskell separates types and values. 
15:46:04 <umib0zu> there is a way to turn it off though
15:46:09 <c_wraith> no. 
15:46:15 <umib0zu> it’s some pragma if I remember correctly
15:46:45 <shachaf> You're probably thinking of DataKinds.
15:46:49 <c_wraith> you can promote types to kinds, but that still doesn't mix types and values. it just creates new kinds 
15:47:00 <shachaf> And new types.
15:47:17 <c_wraith> well, yes. new types to inhabit the new kinds. 
15:47:25 <c_wraith> but they're still not values. 
15:47:29 <shachaf> Yes.
15:47:31 <Enigmagic> :k '()
15:47:33 <lambdabot> ()
15:47:53 <ertes> :t Maybe
15:47:54 <lambdabot>     Not in scope: data constructor ‘Maybe’
15:47:54 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
15:48:56 <umib0zu> ah ok. so I’m slowly piecing together this
15:48:58 <umib0zu> maybe this helps
15:48:59 <umib0zu> https://en.wikibooks.org/wiki/Haskell/Polymorphism
15:49:19 <pavonia> Enigmagic: That () after the apostrophe, is that a type or a value?
15:49:43 <c_wraith> it's a value promoted to a type. 
15:49:58 <umib0zu> I want to be able to make a monoid, so I sort of want my (cat a b) in (.) to be (cat () () ) how do I do that?
15:49:59 <Enigmagic> :k 'True
15:50:00 <lambdabot> Bool
15:50:20 <umib0zu> wait what???
15:50:24 <c_wraith> umib0zu, doesn't work within haskell. 
15:50:26 <shachaf> It doesn't work that well anyway because of Any.
15:50:37 <shachaf> c_wraith: Why not?
15:50:46 <pavonia> :k '(*)
15:50:48 <lambdabot>     Identifier ‘*’ used as a type
15:50:48 <lambdabot>     In a type in a GHCi command: (*)
15:51:06 <umib0zu> well i have to go. I’ll ask about this later!
15:51:06 <umib0zu> Thanks for the help!
15:51:39 <shachaf> I mean, other than Any.
15:52:05 <asdf01> Hello, could somebody please help a newbie? I'm wondering what's the proper way to handle invalid argument values in Haskell functions. Like if I have a function that only works for positive integers, what do I do if I receive a negative argument? Just `error` a message? Seems "not in the spirit". Return `Nothing`? Seems very cumbersome to make users pattern-match or anything on every simple call of my function.
15:52:07 <asdf01> So what should I do instead of throwing something like `InvalidArgumentError` like in the languages I'm used to?
15:52:41 <c_wraith> shachaf, hmm. newtype Monoidish (a :: ()) (b ::()) =... 
15:52:59 <c_wraith> shachaf, OK, yes, it does work. 
15:54:52 <ertes> asdf01: depends on whether and how you want to handle failure
15:55:22 <ertes> asdf01: for example floating-point types like Double have failure built-in and they just carry it along as you compute
15:55:38 <ertes> > 25 * (0 / 0 + 17) ** 400
15:55:40 <lambdabot>  NaN
15:55:58 <asdf01> ertes: me? Nope. The user? He might at least want to know that a failure happend and, I don't know, fail gracefully? Print a pretty message? Something.
15:56:08 <c_wraith> asdf01, there are really good tools for working with types like Maybe and Either that let you skip the pattern matching while working with them.
15:56:12 <ertes> asdf01: if you want to handle failure, use Maybe or Either
15:56:35 <ertes> asdf01: in any case 'error' is probably not the right choice, unless an invalid argument should be considered a *bug* rather than just an error
15:57:20 <c_wraith> asdf01, the tools have unusual names, though. they often end up scaring people away. things like Functor. or the M-word. 
15:57:23 <ertes> but the line between "bug" and "run-time error" is very blurry
15:57:51 <asdf01> ertes: so is saying "only pass positive integers" to this function a common practice?
15:58:08 <asdf01> ertes: so that the user must check this himself
15:58:26 <c_wraith> > []!! (-1)
15:58:28 <lambdabot>  *Exception: Prelude.!!: negative index
15:58:49 <c_wraith> it happens occasionally 
15:59:02 <asdf01> c_wraith: you mean like chaining with `>>=` and friends? yeah, i know... just feels a bit weird to return `Nothing` if an argument is not fit
15:59:18 <ertes> asdf01: generally we try to avoid interfaces that even allow invalid inputs, but that's not realistic all the time…  in general you should use Maybe/Either, unless you have a very good reason not to
15:59:50 <maerwald> ertes: because they suck for IO :(
15:59:53 <ertes> asdf01: ask yourself whether passing an invalid argument should be considered a run-time error or a programmer error
15:59:54 <maerwald> I want better exceptions
16:00:30 <ertes> asdf01: Maybe handling is convenient enough in haskell…  we have loads of tools to make it a breeze
16:00:50 <ertes> (same for Either and other Alternatives)
16:01:18 <asdf01> ertes: what would you recommend in case of a function that should fail if an `Integral` is negative? returning `Nothing` or maybe `Left` with a message?
16:01:23 <asdf01> ertes: the function is really simple
16:02:06 <ertes> asdf01: good question…  if all else fails, provide two variants
16:02:13 <ertes> isqrt :: Integer -> Maybe Integer
16:02:27 <ertes> unsafeIsqrt :: Integer -> Integer  -- fails on negative integers
16:03:09 <ertes> unsafeIsqrt = maybe (error "isqrt: Negative argument") id . isqrt
16:03:22 <asdf01> ertes: that's a very good suggestion, thank you, i like that
16:04:39 <c_wraith> it would be nice if liquid haskell was a bit easier to use, and a bit less buggy. it has a much more satisfactory solution to this class of problem. it's just not mature yet. 
16:04:53 <johnw> c_wraith: it will improve, surely
16:05:06 <johnw> there was a GSoC project to integrate it with Haskell's type system
16:05:07 <c_wraith> johnw, I look forward to it. 
16:05:15 <johnw> I haven't heard the results from that yet
16:05:17 <asdf01> one more simple question, if you guys don't mind. Why are the functions from `Prelude` specialized to `Int`s? Like `take`, `replicate`, things like that. Seems like a waste of a perfectly good opportunity to operate on the real domain, all the `Integral` numbers. Is it the performance?
16:05:25 <c_wraith> yes, it works as a type checker plugin now. 
16:06:18 <crough> asdf01: Their real domain is Natural. I assume it's because of the Haskell Report, when GHC still cared about that.
16:06:26 <ertes> asdf01: history probably, and the fact that it's unlikely that you exhaust Int on modern platforms =)
16:07:08 <geekosaur> and that performance of Int is noticeably better than Integer which is what defaulting gets you
16:07:22 <ertes> asdf01: also it's not always useful to generalise…  it doesn't really generalise the algorithm, but may save you from having to write fromIntegral from time to time
16:07:37 <c_wraith> yeah, good luck processing 2^64 elements before your computer crashes. 
16:07:51 <johnw> darn, I was up to 2^37 and thinking it was going so well so far
16:08:08 <asdf01> crough: yeah, i meant natural numbers, of course, thank you for your correction
16:08:16 <c_wraith> > 64 - 37
16:08:18 <lambdabot>  27
16:08:20 <ertes> interestingly lazy Text uses Int64
16:08:31 <c_wraith> johnw, only 27 more to go! 
16:08:48 <shachaf> Halfway there.
16:08:50 <dysfun> c_wraith: i recently found out graham's number is literally unfathomable for a human. to hold it in your head would mean it had so much mass it would collapse to form a black hole :)
16:08:56 <ertes> square-root-way there
16:10:41 <shachaf> That's not really true.
16:10:58 <shachaf> Well, it's not really truer about Graham's number than it is about e.g. 2^256.
16:11:12 <ertes> uhm
16:11:16 <ertes> > 2^256
16:11:18 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639936
16:11:37 <shachaf> Sure, you can hold logBase 10 (2^256) digits in your head.
16:11:46 <johnw> whoa, I just heard a sucking sound inside my...
16:11:47 <shachaf> But not the number 2^256. That's huge.
16:11:48 <asdf01> so does that mean that stuff like `length $ take (2^32 + 1) $ repeat 1` would only give a single `1` on a 32-bit machine? I might have gotten the numbers wrong, but you know what i mean
16:12:11 <ertes> shachaf: what does it mean to hold the number in your head?  you always hold a *representation* of it
16:12:14 <geekosaur> `take` also has an Int parameter :)
16:12:15 <shachaf> asdf01: Yes.
16:12:27 <shachaf> ertes: Right. Just like you hold a representation of Graham's number.
16:12:37 <ertes> good point
16:12:47 <ertes> i can easily hold it in my head:  G =)
16:12:49 <dysfun> yes, but that representation is not so tiny
16:13:03 <geekosaur> > read 1000000000000000000000000000000000 :: Int
16:13:04 <lambdabot>      No instance for (Num String)
16:13:04 <lambdabot>        arising from the literal ‘1000000000000000000000000000000000’
16:13:04 <lambdabot>      In the first argument of ‘read’, namely
16:13:05 <geekosaur> er
16:13:10 <geekosaur> > read "1000000000000000000000000000000000" :: Int
16:13:11 <lambdabot>  4089650035136921600
16:14:04 <geekosaur> > read "1000000000000000000000000000000000" :: Int32
16:14:05 <lambdabot>  0
16:14:18 <asdf01> ok, thank you guys. I'm always paranoid about the smallest issues, like integers overflowing and stuff, though it doesn't really matter 99% of the time.
16:14:43 <dysfun> just wait til you discover what a mess floating point is :)
16:14:46 * ertes finds it interesting that if you can construct a computer that counts to 2^512 before the sun dies, you effectively constructed a black hole
16:14:49 <dmwit> Most folks here are sympathetic to paranoia.
16:15:31 <asdf01> dysfun: i know, not even touching those until i really have to
16:15:32 <ertes> dysfun: i don't think floating-point is a mess…  it just has a bunch of caveats one should be aware of
16:15:55 <ertes> dysfun: and if you think, you can have fractions without caveats, try using Rational for anything serious =)
16:16:53 <dysfun> i didn't say Rational was a good alternative either :)
16:17:07 <dysfun> i do know to put currencies in fixed point by now though :)
16:17:16 <c_wraith> shachaf, have you seen Scott Aaronson's complexity-based definition of knowledge? 
16:17:16 <c_wraith> (it's one of the first examples in https://www.google.com/url?q=http://www.scottaaronson.com/papers/philos 
16:17:17 <c_wraith> gah, lost the .pdf at the end
16:17:38 <ertes> dysfun: i find that interesting, as floating-point types are actually more precise
16:18:08 <dysfun> not if you consider that you can't actually represent 0.02 accurately
16:18:12 <shachaf> c_wraith: I've seen that PDF before but I haven't read it.
16:18:18 <shachaf> Maybe I should read it.
16:18:22 <Maxdamantus> The issue isn't fixed vs. float.
16:18:23 <ertes> dysfun: that's not the fault of floating point types, but of Float and Double
16:18:33 <Maxdamantus> It's binary vs. decimal.
16:18:43 <ertes> dysfun: with a base-10 fixed type you can't represent 1/3
16:18:47 <dysfun> oh you want decimal floating point back?
16:18:51 <Maxdamantus> There is no binary fixed point that can represent 0.1
16:19:04 <ertes> dysfun: i think, floating decimal is a good idea for monetary calculations
16:19:49 <dysfun> Maxdamantus: citation needed
16:20:20 <ertes> dysfun: 0.1 = 1/(2*5)…  not representable by binary fixed-point
16:20:53 <ertes> you need decimal to represent 0.1, regardless of fixed or floating
16:21:17 <Koterpillar> decimal or some exotic system
16:21:27 <ertes> any system with prime factors 2 and 5
16:21:41 <ertes> so base 30 and 210 would work, too
16:21:43 <dysfun> what scheme am i thinking of if not fixed point? the one that slices off the last 7 bits for the cents?
16:21:58 <ertes> dysfun: you're thinking of decimal =)
16:22:11 <ertes> dysfun: Float and Double are binary, and that's the reason why they can't represent 0.1
16:22:20 <Maxdamantus> dysfun: you're thinking of decimal fixed point.
16:22:23 <ertes> not that they are floating-point
16:22:33 <Maxdamantus> dysfun: but decimal floating would also suffice.
16:22:53 <dysfun> ah right
16:22:57 <dysfun> it's been a looong time
16:24:14 <dysfun> anyway, bedtime i think
16:44:07 * dmwit . o O ( base-510510 fixed-point arithmetic )
16:44:40 <Koterpillar> :q
16:44:43 <Koterpillar> sorry
16:46:45 <koshmar> if I have something simple as http://lpaste.net/169273 and I can derive Show/Read for Nucleoid which will create one for DNA with "[A,C,A]" format, but I want "ACA". I read http://stackoverflow.com/questions/12378502/overload-show-for-list andseems that I can write everything by myself writing show, read, showList, readList. But Can I derive only show/read and write showList/readList like in second answer on stackowerflow. but  OverlappingInstance
16:46:45 <koshmar> s is depricated
16:51:30 <sleblanc> In ~/.ghci, how can I alias a module import? e.g. I would like to import Data.Char as C
16:51:33 <geekosaur> why does everyone think making Show and/or Read do their custom format is obviously the right answer?
16:52:07 <Koterpillar> geekosaur: because everything looks like a nail
16:52:09 <EvanR> koshmar: dont use Show / Read for this
16:52:19 <sleblanc> geekosaur, probably because it's easier. lazy programming
16:52:45 <EvanR> its clearly not easier
16:52:50 <koshmar> eh
16:53:02 <Koterpillar> it was easier for something simple -> reinforcement
16:53:32 <hwkng> is there a way to say "typeclass MagicClass a = HasFoo a, HasBar a, HasBit a"
16:53:46 <hwkng> i.e. instead of writing "HasFoo a, Has Bar a, HasBit a =>" I can just write "MagicClass a"
16:53:47 <EvanR> make specific encode and decoder functions for your DNA data types
16:53:49 <hwkng> i.e. instead of writing "HasFoo a, Has Bar a, HasBit a =>" I can just write "MagicClass a =>"
16:53:54 <koshmar> ok then. could you comment why it is a bad practise?
16:54:08 <sleblanc> EvanR, well, I don't mean it's easier in all cases, especially if you need to encode or decode in multiple formats and flavours
16:54:26 <Koterpillar> hwkng: type Magic a = (HasFoo a, HasBar a)
16:54:36 <EvanR> Show and Read arent conveniently customizable enough to do anything except quick and dirty debugging
16:56:45 <hwkng> Koterpillar: whoa, was notaware that is valid haskell
16:56:47 <hwkng> Koterpillar: thanks!
16:57:44 <EvanR> wait... tuples of constraints are constraints?
16:57:58 <geekosaur> hwkng, technically it isn't, but ghc has ConstraintKinds (an extension you might need to enable for that to work, come to think of it)
16:59:07 <EvanR> hmmm, Either (HasFoo a) (HasBar a)
17:05:13 <ertes> sleblanc: GHCi supports regular import lines
17:05:21 <ertes> both in .ghci and on the REPL
17:06:59 <sleblanc> ertes, oh well, I should have tried that. Works! Thanks
17:14:57 <hwkng> why does Data.Map have lookup, findWithDefault, but not lookupWithDefault
17:16:31 <Koterpillar> hwkng: is your question about naming or do you want a function distinct from both of those?
17:16:53 <sleblanc> hwkng, wouldn't lookupWithDefault do the same thing as findWithDefault?
17:17:07 <hwkng> Koterpillar sleblanc : I find the naming inconsistent
17:17:18 <hwkng> I'm curious "why is findWithDefault" not called "lookupWithDefault"
17:18:38 <sleblanc> Good question. Or why isn't "lookup" called "find"?
17:18:53 <hwkng> That too, it should be either "lookup + lookupWithDefault" or "find + findWithdefault"
17:18:56 <hwkng> but not how it's currently named.
17:19:01 <sleblanc> I suppose it's because "find" has the implications that it _will_ return something
17:19:23 <sleblanc> as opposed to "lookup" which is closer to "search" than "find".
17:22:24 <Cale> I am guessing it is not something that a lot of thought was put into initially, but which it is almost certainly too late to change now.
17:26:46 <ertes> they want you to read the docs from time to time
17:29:54 <tomleb> I'm getting bunch of errors when trying to create a stack project with the ghcjs template. "ghcjs-base not found"
17:34:13 --- mode: ChanServ set +o shachaf
17:34:26 --- mode: shachaf set -bo isocliff!*@* shachaf
17:34:37 <shachaf> Hmm.
17:34:39 --- mode: ChanServ set +o shachaf
17:35:00 --- mode: shachaf set -b isocliff*!*@*$##fix_your_connection
17:35:09 --- mode: shachaf set -o shachaf
17:35:34 <tomleb> Is stack supposed to work with ghcjs ?
17:36:01 <Cale> tomleb: I believe it is, but I don't have first-hand experience trying it
17:37:09 <Cale> (I mostly use the try-reflex script from https://github.com/reflex-frp/reflex-platform)
17:37:34 <Cale> (which uses nix)
17:38:51 <hwkng> how do I translate the following ocaml line to haskell? "type context = (Syntax.variable * (Syntax.expr * Syntax.expr option)) list"
17:39:31 <Cale> It'll look something like  type Context = [(Variable, (Expr, Maybe Expr))]
17:40:39 <hwkng> Cale: I can work with that. Thanks!
17:51:22 <nineonine> hi there
17:51:34 <nineonine> is there lifted if-then-else version ?
17:52:07 <hwkng> liftM2
17:52:43 <nineonine> example ?
17:52:55 <Koterpillar> when?
17:53:05 <hwkng> ite t x y = if t then x else y; liftM3 ite
17:53:07 <nineonine> :t when
17:53:08 <lambdabot> Applicative f => Bool -> f () -> f ()
17:53:24 <nineonine> but i want 
17:53:34 <nineonine> f Bool -> f () -> f ()
17:54:03 <hwkng> ite t x y = if t then x else y; liftM3 ite
17:54:11 <nineonine> yeah that should work
17:54:12 <nineonine> thanks
17:54:14 <Koterpillar> nineonine: Hayoo says whenM
17:54:23 <Koterpillar> in classy-prelude
17:54:24 <nineonine> will check it now
17:54:42 <Koterpillar> and in ten other places
17:55:42 <Cale> Yeah, but eh, you're way more likely to see someone just use when
17:56:00 <Cale> Or just execute the action which produces the Bool, and then use if directly.
17:56:15 <Koterpillar> or b >>= when
17:56:16 <nineonine> yeah I was thinking of doing it this way
17:56:45 <Koterpillar> :t \mb -> mb >>= flip when
17:56:46 <lambdabot> Applicative f => (Bool -> f ()) -> Bool -> f ()
17:56:52 <Koterpillar> err, wrong
17:57:04 <Koterpillar> :t \mb f -> mb >>= flip when f
17:57:05 <lambdabot> Monad m => m Bool -> m () -> m ()
17:57:13 <nineonine> gg !
18:00:25 <sleblanc> @src when
18:00:26 <lambdabot> when p s = if p then s else return ()
18:01:44 <Koterpillar> @src whenM
18:01:44 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:04:24 <sleblanc> whenM mbool action = mbool >>= flip when action
18:08:50 <tomleb> Shouldn't just stack new ghcjs <name> work ?
18:09:14 <Koterpillar> tomleb: it doesn't because ghcjs didn't make a formal release
18:13:52 <tomleb> Koterpillar: So what are the options ?
18:14:57 <Koterpillar> tomleb: last time I tried, there was a stack docs page listing the options, which included random gists off Github. Unfortunately, those didn't work for me in the end, I gave up and played with PureScript instead.
18:15:26 <tomleb> Koterpillar: Damn alright.. maybe I should use cabal instead
18:47:29 <reinh> Koterpillar: Here's an example using ghcjs that built with stack last time I tried it, at least rn2kb1r/ppp1n1pp/4Qp2/4p3/2B1q3/8/PPP2PPP/RNB2RK1 w kq - 0 9
18:47:45 <reinh> It probably still builds, although ghcjs may have had releases since it was created
18:48:15 <Koterpillar> what was that?
18:48:32 <reinh> An alternative to stack new ghcjs <name>
18:48:52 <Koterpillar> I see what looks like garbage starting with rn2kb1r
18:48:58 <reinh> Uh, yeah
18:49:05 <reinh> my clipboard is being awful, sorry
18:49:22 <reinh> I'm... probably going to have to restart.
18:50:25 <reinh> https://github.com/reinh/reflex-dom-stack-demo
18:50:29 <reinh> There. That was awful.
18:50:31 <reinh> Sorry.
18:51:12 <Koterpillar> reinh: thanks, I might check it out if I try ghcjs again
19:02:05 <sleblanc> My function has a constraint on Num a => a, yet GHC complains that it cannot deduce (Ord a) from (Num a); doesn't Num a imply Ord a?
19:02:16 <glguy> It doesn't
19:02:23 <glguy> It used to
19:02:51 <glguy> err, actually it might never have
19:02:56 <glguy> Maybe I'm just thinking of Show
19:03:20 <sleblanc> Is there a rationale? Is it only to relax constraints so that an instance of Num does not need to implement Ord? From my understanding, all Num(erals) should be Ord(erable), no?
19:03:47 <glguy> Complex numbers have a Num instance
19:03:54 <sleblanc> Oh, yeah.
19:07:12 <rgrinberg> Any way to skip ascii space around a bytestring?
19:11:02 <saurabhnanda> on spacemacs/emacs/intero, what's the best way to get API documentation for a symbol/keyword?
19:12:57 <pavonia> rgrinberg: ByteString has break/span and breakEnd/spanEnd function that you could use
19:19:29 <saurabhnanda> any help, please?
19:21:13 <lpaste> sleblanc pasted “Parsec bounded integer” at http://lpaste.net/4176082523937308672
19:21:16 <rgrinberg> pavonia: thanks, that will do
19:22:00 <sleblanc> is this the proper approach? testing with @ parse (integer haskell >>= is100M) "" "1005" gives me garbage-y error messages
19:22:28 <geekosaur> glguy, Num had Show and Eq. It never had Ord because of Complex
19:23:06 <sleblanc> it will properly filter out-of-range numbers, but it says "unexpected end of input, expecting digit", which is slightly confusing
19:23:40 <sleblanc> in other words, what is a proper, parser-level approach to restrict the range of a parsed number?
19:24:40 <geekosaur> sleblanc, what does it do with :  parse (integer haskell) "" "1005"
19:24:54 <geekosaur> (because I thinlk this is just parse being upset you didn't match end of input somehow...)
19:26:13 <sleblanc> geekosaur, it works fine
19:26:25 <sleblanc> it works as expected, it's just the error message that's wrong/misleading
19:27:12 <HountedTavern> does yesod compare to rails and django?
19:28:02 <SparkySquirrel> why would my long time Java dev friend say Haskell, Python, and Ruby are useless pieces of junk?
19:28:04 * hackagebot indexed-extras 0.2 - Indexed functors, monads and comonads that require extensions to Haskell98  https://hackage.haskell.org/package/indexed-extras-0.2 (ReinerPope)
19:28:08 <saurabhnanda> HountedTavern: in terms of solving the same problem, yes. In terms of using a similar approach, most probably not.
19:28:17 <SparkySquirrel> I like his Java but I can't stand the attitude
19:28:24 <itnex> lol
19:28:31 <SparkySquirrel> :O
19:28:41 <SparkySquirrel> bye guys this is a bad thing talking like this
19:29:27 <sleblanc> SparkySquirrel, bigotry
19:29:32 <glguy> sleblanc: Try using unexpected instead of fail
19:29:50 <HountedTavern> what i mean by that is can yesod do everything lets say rails or django can
19:30:16 <SparkySquirrel> sleblanc: ah, well then um...I would love to code with him, at least
19:30:23 <SparkySquirrel> in Java no less
19:30:25 <glguy> sleblanc: unexpected "big integer"
19:32:33 <sleblanc> HountedTavern, I worked extensively with Django, and did some Rails; while Django and Rails are similar, Yesod is a whole 'nother beast. I like it a lot, but the learning curve is steep, especially if you do not have much experience with Haskell
19:32:57 <saurabhnanda> HountedTavern: probably the incorrect question. "Can" it do everything, yes. "Can" it do it in a way that you're familiar with, no.
19:33:15 <HountedTavern> perfect answer thanks!
19:33:17 <sleblanc> glguy, well, it kind of just moved the "confusing" error elsewhere… it still spews "expecting integer"
19:33:53 <glguy> sleblanc: Well, I can't very well debug the code you didn't paste, but in isolation using unexpected works out
19:34:00 <sleblanc> Its type safety is probably the most touted feature. Type-safe HTML templates are a nice approach
19:34:26 <HountedTavern> how much javascript do you need to know for yesod
19:34:39 <HountedTavern> would knowing haskell be enough
19:36:08 <lpaste> sleblanc annotated “Parsec bounded integer” with “Parsec bounded integer (annotation)” at http://lpaste.net/4176082523937308672#a2929283617039319040
19:36:13 <sleblanc> ^glguy
19:36:30 <sleblanc> HountedTavern, no js at all
19:38:59 <sleblanc> the Yesod approach is way different though. Django and Rails come with many batteries, Yesod has but a few. No admin page, no ORM, no nothing
19:39:31 <sleblanc> Yesod is basically type-safe URL routing and dispatching, and templates
19:41:54 <HountedTavern> theirs a good o'reilly book it seems on it
19:58:05 * hackagebot json-api 0.1.0.3 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.0.3 (toddmohney)
19:58:08 <umib0zu> hey all. does anyone have experience with the Control.Category library? I’m trying to instantiate some basic categories but I’m having some trouble. http://lpaste.net/6268022082907406336
20:09:14 <geekosaur> @tell umib0zu in `id = id` it is using Prelude.id which requires actual (->). note however that the type-correct version `id = Cats.id` will be an infinite loop. you must use something like `id a = a`.
20:09:14 <lambdabot> Consider it noted.
20:09:37 <glguy> geekosaur: even worse, the type in question can't be an instance of Category
20:10:07 <geekosaur> probably, but I'm not very well versed in Category. it is striking me as wrong but I can't say why :/
20:12:34 <geekosaur> (might leave that for them as well)
20:12:40 <glguy> It's going to be hard to implement: id :: Arrow a a
20:12:57 <glguy> which would be isomorphic to,   id :: (a,a)
20:13:27 <c_wraith> That does seem like an unlikely type
20:15:22 <shachaf> glguy: Certainly it's going to be hard if you don't believe in yourself.
20:16:48 <shachaf> geekosaur: Well, you can say that the function id :: a -> a doesn't type-check as a value :: Arrow a a, no matter how you produce it.
20:17:19 <shachaf> Well, maybe I misunderstood what you were saying. Not sure now.
20:19:01 * geekosaur is not sure what is even going on there tbh
20:22:02 <glguy> shachaf: Would it be sufficient if you believed in me?
20:22:39 <glguy> and if so I have a follow-up question
20:22:59 <glguy> umib0zu: Bad news, data Arrow a b = Arrow a b, isn't going to be able to make an instance of Category
20:24:44 <glguy> pfft
20:29:13 <tnks> if LTS is a snapshot of Nightly in Stackage, is there as way to see which Nightly corresponds to an LTS?
20:29:42 <tnks> or is LTS not really as simple as a snapshot of a Nightly?
20:32:11 <glguy> No, it's not the case that each LTS existed as a nightly, afaik
20:33:01 <shachaf> glguy: It would be sufficient if I believed in you, I believe.
20:33:07 <shachaf> glguy: But unfortunately I don't.
20:33:21 <glguy> which of those two things don't you belive in?
20:33:38 <shachaf> Which two things?
20:34:10 <shachaf> Your ability to implement id I certainly don't believe in.
20:34:21 <glguy> I guess you unconditionally added "I believe" at the end, I misread it at first
21:03:07 * hackagebot wai-app-file-cgi 3.1.3 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.3 (KazuYamamoto)
21:08:07 * hackagebot mighttpd2 3.3.3 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.3.3 (KazuYamamoto)
21:08:09 * hackagebot http2 1.6.1 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.6.1 (KazuYamamoto)
21:10:55 <TheIdeaMan> test
21:11:56 <Koterpillar> :t test
21:11:57 <lambdabot>     Not in scope: ‘test’
21:11:57 <lambdabot>     Perhaps you meant one of these:
21:11:57 <lambdabot>       ‘text’ (imported from Text.PrettyPrint.HughesPJ),
21:12:30 <nshepperd> is there a word for the category that just contains one morphism for every pair of objects
21:13:31 <tieTYT> i read LYAH all the way through and liked it.  This was 1-2 years ago and haven't used haskell since.  Can anyone recommend a good refresher?  I'd especially like a book/site with exercises
21:15:47 <TheIdeaMan> I have a non haskell related question. Its an idea for a bbs-ish style website. I need some help with a rounding the edges of the ideas
21:16:04 <TheIdeaMan> if anyone is willing to help/add input it would be greatly appreciated
21:16:05 <shachaf> TheIdeaMan: If it's not Haskell-related, you should ask it elsewhere.
21:16:19 <TheIdeaMan> im asking in git along with networking
21:16:25 <dmj`> tieTYT: the typeclassopedia
21:16:31 <shachaf> TheIdeaMan: I saw.
21:16:40 <shachaf> TheIdeaMan: So you certainly shouldn't ask here.
21:16:54 <TheIdeaMan> Do you have a suggestion where to ask?
21:17:07 <TheIdeaMan> somewhere i could get a response?
21:17:09 <shachaf> No. But this isn't the place.
21:17:14 <dmj`> @google haskell typeclassopedia
21:17:15 <lambdabot> https://wiki.haskell.org/Typeclassopedia
21:17:44 <shachaf> tieTYT: If you already have a general grasp on the concepts and you just want to read some specifics, maybe the Gentle Introduction.
21:17:52 <shachaf> I'm not sure whether it's good for that purpose...
21:17:55 <shachaf> @where tutorial
21:17:56 <lambdabot> http://www.haskell.org/tutorial/
21:18:01 <shachaf> At least it's short.
21:21:13 <nshepperd> umib0zu: data Arrow a b = Arrow a b doesn't work as a category
21:21:32 <umib0zu> I saw nshepperd
21:23:42 <tieTYT> shachaf: what about exercises?
21:24:12 <shachaf> I don't know a good source of exercises.
21:24:31 <tieTYT> ok thanks for the help
21:24:31 <dmj`> typeclassopedia has exercises
21:24:49 <shachaf> Aha, then you should use that.
21:25:01 <dmj`> tieTYT: http://www.seas.upenn.edu/~cis194/lectures.html
21:26:00 <shachaf> nshepperd: It doesn't work as a category, but it does work as a semigroupoid.
22:08:09 * hackagebot http-client 0.5.0.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.0.1 (MichaelSnoyman)
22:30:24 <jaarod> #haskell is second most popular programming channel on freenode. haskell is 38th on the list of most used programming languages in TIOBE index. how to explain that difference
22:30:41 <shachaf> It must be a conspiracy.
22:32:02 <systemfault> Freenode doesn't reflect the real world.
22:32:07 <systemfault> It's as simple as that.
22:32:52 <jaarod> that doesn't explain why interest in haskell is so significant on freenode but so insignificant overall
22:33:43 <dmj`> jaarod: industry is fickle
22:34:52 <glguy> I guess we have to assume TIOBE index is flawed
22:35:38 <johnw> jaarod: a lot of people come to other languages out of necessity, but I'd say they mainly come to Haskell out of interest, so it's not unreasonable that this a channel where people would spend some of their free time
22:39:24 <saurabhnanda> back now... can anyone help me with these yesod questions?
22:40:01 <dmj`> jaarod: popular is also a nebulous concept
22:42:14 <jaarod> dmj actually their index has been pretty consistent since 2002. top 2 remained the same and swapped places (C and Java), and top 10 too
22:42:28 <sleblanc> jaarod, "tightly-knit" community
22:42:43 <jaarod> what is nebulous about concept of popularity?
22:42:56 <sleblanc> in my experience, Java folks tend to stay away from computers on evenings and weekends
22:43:22 <sleblanc> (citing Java as an example)
22:44:37 <dmj`> jaarod: depends on how you define it
22:45:14 <jaarod> "The ratings are based on the number of skilled engineers world-wide, courses and third party vendors"
22:45:51 <dmj`> so popularity == usage
22:45:54 <jaarod> g
22:45:58 <jaarod> sleblanc that is likely true
22:46:39 <systemfault> Freenode is an alternate dimension where the average developer is an exceptional one IRL... That's what I found over the years.
22:47:14 <KaneTW> selecting "people who use irc often" is already a bias
22:47:23 <sleblanc> Hacker culture
22:53:05 <dmj`> 'popular' seems to infer that something is enjoyeable, liked, etc. not something I'd associate with java
22:54:18 <sleblanc> Business types like Java
22:55:21 <sleblanc> 'cuz it's business-this, enterprise-that
22:55:54 <systemfault> Java is "comforting" to the business side. All the big companies use it.
22:56:58 <jaarod> it is interesting that C is the second most used language
22:57:04 <systemfault> You know.. it's the neverending classic FUD "Nobody ever got fired for buying/using <insert widely known brand here>"
22:58:08 <jaarod> will we live to see haskell in the top 10?
22:58:40 <woffs> haskell is too crazy. (wait, java is crazy, too)
22:58:53 <sleblanc> apache tomcat definitely helped java's popularity
22:58:59 <sleblanc> jaarod, per line-of-code?
22:59:07 <woffs> we need apache_mod_haskell
22:59:28 <sleblanc> woffs, I'll stick to Yesod + nginx proxying
22:59:53 <jaarod> sleblanc among top 10 most used languages
22:59:57 <johnw> we're not here to distinguish ourselves from Java, but to enjoy Haskell
23:01:53 <systemfault> We should create, Haskell EE and try to retrofit all the GoF book design patterns into it.
23:02:08 <KaneTW> aaaaaa
23:02:16 <KaneTW> <incoherent screaming>
23:02:29 <KaneTW> {-# LANGUAGE IncoherentScreaming #-}
23:02:52 <sleblanc> {-# LANGUAGE DesignPatterns #-}
23:08:20 <jaarod> are most programmers too stupid to use haskell
23:09:14 <srhb> jaarod: Haskell doesn't require a higher intelligence than most other languages, afaik.
23:10:40 <M2tias> most programmers are too stupid to be programmers
23:10:59 <srhb> Nonsense.
23:11:09 <jaarod> he is right
23:11:25 <srhb> Also, this seems like an offtopic discussion, even though it would be much nicer to just _not_ say offensive stuff about random people. :)
23:12:11 <johnw> we're not here to look down on anyone, but to reflect on what we don't understand yet and move forward
23:12:29 <sleblanc> this^
23:12:32 <johnw> the intelligent or stupidity of others is simply unrelated
23:12:45 <systemfault> ramen.
23:14:37 <orion> GoF?
23:14:45 <dmj`> gang of four
23:15:32 <systemfault> That thing https://en.wikipedia.org/wiki/Design_Patterns?oldformat=true
23:16:06 <saurabhn_> can anyone help me with http://stackoverflow.com/questions/38260036/how-to-read-yesod-error-messages-effectively
23:16:08 <orion> GoF design patterns don't even make sense to me in a functional language.
23:16:56 <KaneTW> they don't
23:16:57 <johnw> we make use of the Actor pattern fairly often, via threads and queues
23:17:11 <KaneTW> design patterns are designed for oo languages (or at least that's my impression)
23:17:25 <KaneTW> there surely are equivalents to them in pure functiona languages
23:17:43 <KaneTW> but you can't/shouldn't copy them 1:1
23:17:45 <johnw> even objects themselves have equivalents in pure functional languages, just not the same syntactic conveniences
23:18:00 <KaneTW> saurabhn_: post your code
23:18:11 * hackagebot pinboard 0.9.6 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.6 (jonschoning)
23:18:13 <systemfault> Design Patterns are mostly anecdotal... I mean, they don't have math to back them up
23:18:53 <saurabhn_> KaneTW: here or on stack overflow?
23:19:09 <KaneTW> so if you asked your question there
23:19:11 <KaneTW> both is fine
23:19:30 <saurabhn_> KaneTW: actually it's not about the code. Read the note below
23:19:37 <saurabhn_> I'm working with a simple scaffolded site (no DB) and have purposely messed up with homepage.julius. In this particular instance I know exactly what the error is, but how can one know just by looking at the error message?
23:19:41 <KaneTW> oh sorry
23:19:53 <KaneTW> i'm a bit tired so i just go through the usual routine
23:19:59 <KaneTW> sec
23:20:35 <saurabhn_> basically, yesod is pointing me to the place in the .hs file where the code is being spliced by TH. But what I need is the spot in the julius file which is causing the error. Else debugging in large complicated projects is going to be a nightmare.
23:21:11 <KaneTW> hm
23:21:25 <KaneTW> that is kinda annoying that it odesn't tell you the line annotation of the corresponding julius code
23:22:22 <saurabhn_> theoretically, shouldn't it be possible to do that with TH? or is it a TH limitation
23:22:33 <KaneTW> definitely with compiler pragmas
23:22:37 <KaneTW> lemme see if it's possible w/ th
23:22:38 <saurabhn_> If I understand this correctly, the compilation is failing in the TH phase, right?
23:22:51 <KaneTW> yeah
23:23:14 <KaneTW> it doesn't really tell you that but fully qualified names are usually a decent hint
23:23:39 <dmj`> saurabhn_: trying putting 'rawJS' in front of that string
23:23:39 <dmj`> saurabhn_: there is not isntance of 'ToJavascript' for 'String', so you need to convert it to RawJavascript using the rawJS function
23:23:39 <dmj`> there is no instance*
23:24:11 <saurabhn_> dmj`: I know what the error is. I've put it there -- #{show "abcdef"} 
23:24:29 <saurabhn_> dmj`: my question is different. How to look at the error message and get to the line causing the error.
23:24:40 <KaneTW> the Dec type has a constructor PragmaD Pragma
23:24:47 <KaneTW> so it's possible to include {-# LINE pragmas
23:25:16 <saurabhn_> KaneTW: what's that extension, again?
23:25:24 <KaneTW> templatehaskell
23:25:38 <KaneTW> {-# LINE num file #-} is just a pragma telling the compiler
23:25:50 <KaneTW> if there's an error here tell the user it happened at that linenum in that file
23:26:08 <KaneTW> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#line-pragma
23:27:58 <saurabhn_> KaneTW: that doesn't look like something I can turn on. My Snoyman will have to sprinkle it liberally within shakespeare, right?
23:28:04 <saurabhn_> *Mr Snoyman
23:28:12 <KaneTW> yeah
23:28:24 <KaneTW> i bet there's already a feature request for that already
23:30:01 <saurabhn_> hmm... irritating... seems like going back in time wrt tooling.
23:34:17 <saurabhn_> also, if a particular HS file has lots of handlers and even one of them changes, it will trigger a compile of the ENTIRE file along with all the whamlets/widgets. Pretty expensive. The develop-debug cycle is seeming too long in the scaffolded site, right now.
23:35:52 <saurabhn_> should "yesod devel" be using some sort of ghci to make the develop-debug cycle faster?
