00:00:06 <gfixler> sending them over a socket to Maya's "CommandPort"
00:02:53 <nshepperd_> pikajude: I think writeChan and writeTChan are equally atomic (provided that you don't go opening up the Channels and messing with their internals manually)
00:04:03 <nshepperd_> the general rule seems to be you need STM if you are dealing with multiple concurrent objects
00:07:58 <nshepperd_> ie. you get the benefits of not having to think about races and deadlocks when your 'atomically' blocks contain multiple dependent instructions
00:13:15 <smorele> do you know easy haskell projects to start contributing ?
00:17:47 <rydgel> smorele: maybe Spock the web framework
00:18:16 <liste> Spock has a lot of type family "magic" though
00:18:23 <liste> Scotty doesn't
00:18:38 <smorele> thanks rydgel i didn't know this project, I use Hakyll for my website
00:47:02 <pikajude> i'm trying to write an application using Pipes. would it make sense to fork inside a Consumer? the instances don't seem to be there
00:47:07 <pikajude> for MonadBaseControl IO
00:47:32 <pikajude> but, i'm not sure how to write a program where only some of the logic is inside a chain of pipes
01:14:05 <srhb> How do people handle complex argument validation in optparse-applicative? Shell out to attoparsec or something afterwards and just keep everything about positions and names in optparse?
01:18:38 * hackagebot werewolf 1.4.0.1 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.4.0.1 (hjwylde)
01:43:39 * hackagebot wavefront 0.7.0.1 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.7.0.1 (DimitriSabadie)
02:00:59 <marrrk> (disclaimer: I want to do this in Scala). Can lenses help me modifying the values of tree structures? I think I understand that zippers are used for moving around subtrees. I really only want to modify (i.e. replace) them. I don't know in advance where the child is so I don't see a straightforward lens there. I think the most basic thing would be a lens that modifies a list element if it matches a predicate. Is that possible or a go
02:03:40 * hackagebot hw-json 0.2.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.2.0.1 (haskellworks)
02:13:40 * hackagebot luminance 0.11.0.2 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.11.0.2 (DimitriSabadie)
02:14:52 <liste> marrrk: there's `filtered', but you need to be careful to make it obey the laws
02:14:56 <liste> :t filtered
02:14:57 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
02:15:14 <marrrk> hmm
02:31:58 <sdx23> is any of the plot libraries capable of dynamic updates?
02:37:50 <dickbarends> ?
02:38:41 * hackagebot tianbar 1.1.0.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.1.0.0 (AlexeyKotlyarov)
02:39:47 <sdx23> everything I've seen is static. As in it's not possible to plot something and update it (add some points or whatever).
02:40:06 <liste> sdx23: does gloss count as a plot library?
02:40:10 <liste> @hackage gloss
02:40:10 <lambdabot> http://hackage.haskell.org/package/gloss
02:40:44 <liste> it's not exactly plotting graphs but...
02:41:26 <sdx23> well, I've got coordinates of points to be plotted
02:41:43 <liste> it can do points fine
02:42:05 <liste> maybe plot them as little circles
02:43:11 <sdx23> ok, this may be working for my current problem.
02:44:26 <sdx23> liste: thanks
03:08:42 * hackagebot ghc-typelits-natnormalise 0.4.5 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4.5 (ChristiaanBaaij)
03:18:43 * hackagebot emailparse 0.2.0.6 - An email parser that will parse everything  https://hackage.haskell.org/package/emailparse-0.2.0.6 (mkawalec)
03:35:58 <Myrl-saki> Is there a TH for $(f [x, y, z]) == [("x", x), ("y", y), ("z", z)] ?
03:37:27 <thewormkill> depending on the type, Myrl-saki, you might just use something like:
03:37:44 <thewormkill> map ((,) <$> show <*> id)
03:37:55 <thewormkill> and I'd assume the compiler would optimize that
03:38:09 <thewormkill> (however, I am not entirely sure)
03:38:26 <thewormkill> it's a much simpler solution, and ofc you can use something different from show
03:38:31 <maerwald> show? err
03:38:37 <thewormkill> and I'd say it's sufficient in many cases
03:38:48 <merijn> thewormkill: "show x" is not "x"
03:38:48 <thewormkill> as I said, show is mostly an example
03:38:50 <maerwald> how is show guaranteed to make an arbitrary x into "x"?
03:39:01 <thewormkill> merijn: depending on the type obv :)
03:39:09 <maerwald> what type would that be
03:39:09 <merijn> thewormkill: He wants a string of the name
03:39:17 <thewormkill> if you have something like data A = AA | BB | CC | DD
03:39:20 <merijn> thewormkill: not a string of the content
03:39:22 <thewormkill> ah, the variable name
03:39:26 <Myrl-saki> :P
03:39:30 <Myrl-saki> yeah. the variable name.
03:39:31 <thewormkill> hm, think I misread ^^
03:40:06 <merijn> Myrl-saki: I'm pretty sure you can write that, but I wouldn't bet on it already existing somewhere obvious
03:40:20 <Myrl-saki> merijn: weird. i can think of many reasons for using it.
03:41:39 <maerwald> it sort of looks like a substitute for index numbers
03:43:09 <Myrl-saki> index numbers?
03:43:35 <maerwald> yes
03:44:11 <Myrl-saki> What are those?
03:45:27 <maerwald> I don't know how to explain something that basic.
03:46:05 <Myrl-saki> hahaha. can you just show an example? I'm not sure exactly what you mean.
03:47:41 <maerwald> > findIndices (const True) [undefined,undefined,undefined]
03:47:43 <lambdabot>  [0,1,2]
03:48:11 <Myrl-saki> maerwald: oh. lol.
03:50:34 <thepingles> @pl (show . \(rows, wordlens) -> solve (makeGrid rows) ptree wordlens) (games !! 10)
03:50:34 <lambdabot> show (solve (makeGrid (fst (games !! 10))) ptree (snd (games !! 10)))
03:51:28 <Myrl-saki> woah.
03:51:56 <Myrl-saki> thepingles: didn't know that you could do that without grouping the lambda func.
03:52:53 <thepingles> Myrl-saki: yeah look there's a reason i'm asking lambdabot
03:53:11 <thepingles> Myrl-saki: i can't remember how it got to that :)
03:54:46 <Cale> That's a terrible refactoring though
03:54:59 <merijn> Word
03:55:14 <thepingles> agreed
03:55:18 <merijn> I think it's horrifically slower too? Seems to me like it'd recompute games !! 10
03:55:21 <Cale> Instead of doing !! once, which is bad enough, let's do it twice
03:55:22 <Cale> yeah
03:55:33 <thepingles> however it just has to solve one puzzle
03:56:05 <thepingles> (games !! 10) is minuscule compared to the search to solve it
03:56:10 <Cale> yeah
03:56:24 <maerwald> most @pl "refactorings" are terrible
03:57:08 <Myrl-saki> Why do people consider FRP fine but not event+callbacks and state mutation?
03:57:45 <maerwald> Myrl-saki: because it's new and shiny and difficult to learn
03:57:46 <Myrl-saki> A bit of a joke-ish question since there are really some things that are better in FRP.
03:57:50 <Myrl-saki> maerwald: lol
03:57:55 <maerwald> I'm being serious
03:58:03 <Myrl-saki> But in a way, it really boils down to the same thing.
03:58:14 <maerwald> the way you organize your code is very different
03:58:18 <maerwald> that's the main thing imo
03:58:37 <Myrl-saki> maerwald: Yeah. Instead of defining your events to mutate x. Your defining x in terms of the events.
03:58:39 <maerwald> but until you get there with all the type foo...
03:59:07 <Myrl-saki> I guess one thing nice about FRP is the fanout.
03:59:26 <Myrl-saki> And the implied syncing.
04:00:04 <maerwald> The thing is, I always liked callbacks, even in C. It's simple and not even that hard to organize. The problem is however, it feels somewhat odd to do in C.
04:00:07 <maerwald> err, haskell
04:00:52 <merijn> maerwald: What's difficult to learn about FRP?
04:01:06 <maerwald> merijn: the types
04:01:10 <Myrl-saki> People seem to talk about callback hell though.
04:01:23 <maerwald> Myrl-saki: yeah, complexity is hard to govern
04:01:47 <SAL9000> callback hell -> promises, state machines, etc.
04:01:50 <Myrl-saki> merijn: I'd say it's because it's functional.
04:01:57 <maerwald> Myrl-saki: no
04:02:10 <Myrl-saki> maerwald: Just my opinion. :P
04:02:42 <maerwald> it's because no one has been able to come up with a simple API yet, similar to the lens problem
04:02:43 <Myrl-saki> I don't think I had typing problems with Reflex. Of course, I didn't use the internals.
04:03:09 <maerwald> you get powerful stuff, but you also get the type foo
04:03:28 <merijn> Myrl-saki: callbacks have all the problem of shared mutable state, except now you also don't know when things get executed
04:03:58 <Myrl-saki> merijn: Eh. That last clause, isn't that the whole point of async?
04:04:14 <Myrl-saki> "Proper" async, that is.
04:05:59 <merijn> Myrl-saki: That's why it's hell
04:06:07 <merijn> Myrl-saki: Have you tried debugging code like that?
04:06:26 <Myrl-saki> merijn: Yes. I normally look at a variable's "dependencies".
04:06:34 <maerwald> it's not that hard, actually
04:06:38 <merijn> Myrl-saki: FRP is the complete opposite, in that it has an explicit denotational semantics that says when things can change and why
04:06:49 <merijn> maerwald: Only if you have trivially small callbacks and not a lot of them
04:07:15 <maerwald> merijn: I've written a lot of non-trivial gtk+ apps and I've never had major problems with the shared gui state.
04:07:40 <maerwald> but that depends on coding style, probably, nothing the type system is gonna help you with
04:07:46 <merijn> I don't have experience with GUIs
04:08:28 <maerwald> It's a technology that's used basically everywhere today. It's not "impossible" to handle.
04:08:29 <merijn> My experience is implementing concurrent runtime systems in C where we needed callbacks, because well, how else are you going to do async code. Debugging that stuff nearly impossible
04:09:39 <merijn> maerwald: If you don't consider it impossible, then most likely your callbacks are still trivial, imo
04:09:56 <maerwald> merijn: no.
04:10:03 <Myrl-saki> merijn: Anything that isn't impossible should really be trivial. :P
04:11:53 <maerwald> merijn: maybe your code organization can be optimized, which is why you get that impression of callbacks?
04:12:26 <maerwald> but now we are just guessing, which isn't very useful
04:13:02 <Myrl-saki> Anyways, I still think FRP is better.
04:13:21 <maerwald> Myrl-saki: I wouldn't be so broad. I'd say it depends on the implementation there.
04:13:32 <Myrl-saki> maerwald: True. I find reflex nice.
04:13:54 <tdammers> FRP is a beautiful abstraction, but it's costly, and implementation is tricky, especially if you want it to be performant
04:14:09 <quicksilver> there is a world of difference between a single-threaded execution model with lots of callbacks (node.js for example is in this style; so is lots of C code)
04:14:20 <quicksilver> and a genuinely multithreaded model with callbacks.
04:14:54 <merijn> quicksilver: If you're singlethreaded I don't see the point of callbacks in the first place
04:14:57 <quicksilver> the latter model suffers from extremely subtle timing interactions which can be hard to reproduce.
04:15:08 <quicksilver> there is plenty of point :)
04:15:18 <tdammers> merijn: the trick is that the runtime is threaded, but user code is not
04:15:29 <merijn> quicksilver: On the bright side, I learned that gdb has a "freeze background threads" command :p
04:15:38 <quicksilver> I would have thought that callbacks are the dominant way to handle asynchrony in single-threaded systems.
04:16:04 <merijn> quicksilver: That doesn't make them a good solution for that problem :)
04:16:23 <tdammers> e.g., when you read a file asynchronously in node.js, the actual file reading happens in a separate thread, the main execution thread (which runs your code) doesn't block
04:17:02 <tdammers> you just don't get to spawn your own threads, and callbacks you pass around run on the same thread as the rest of your code
04:17:28 <maerwald> tdammers: async io in nodejs doesn't actually mean multi-threaded
04:18:03 <tdammers> maerwald: not necessarily, but there's no reason for the runtime to not implement it that way
04:18:16 <maerwald> tdammers: javascript runtime is single-threaded afaik
04:18:21 <tdammers> hm
04:18:28 <tdammers> lemme check
04:19:10 <maerwald> libuv probably allows to do what you mean, but that's the low-level C thing for async
04:21:28 <cloudhead> yeah it's single threaded since js code isn't thread-safe
04:22:32 <tdammers> cloudhead: you don't have to write the runtime in JS
04:22:44 <cloudhead> it spawns a thread to do file i/o on linux, but that's about it afaik
04:22:51 <tdammers> cloudhead: in fact, you *can't* write the runtime in JS, unless you have a JS -> native compiler
04:23:16 <cloudhead> I'm not saying you should write the runtime in js
04:23:41 <cloudhead> just that the js code that is run can't be multithreaded
04:23:42 <tdammers> no, but since the runtime isn't written in JS, it doesn't have to be single-threaded either
04:23:50 <tdammers> indeed
04:23:55 <maerwald> tdammers: err?
04:24:05 <tdammers> ok
04:24:11 <tdammers> so JS itself isn't thread safe
04:24:39 <cloudhead> but the runtime is running js code for the most part
04:24:49 <cloudhead> even if it's written in c++
04:25:20 <tdammers> it's running JS code, and that JS code can call into the runtime, triggering things that are written in C++
04:25:39 <tdammers> and those things can be multi-threaded, as long as they don't violate the single-threaded semantics of the JS parts
04:25:51 <cloudhead> yes
04:26:12 <cloudhead> but you'll always only have one js thread
04:26:16 <tdammers> so it's perfectly fine for a file reading API to spawn a thread, read the file in parallel, and then when data is available, append a callback invocation to the execution queue
04:26:24 <cloudhead> yeah
04:26:24 <tdammers> indeed
04:26:39 <tdammers> but the "node.js cannot possibly scale because everything is single-threaded" is just false
04:26:50 <tdammers> not everything is single-threaded, only the JS code is
04:27:00 <cloudhead> but the js code is your application
04:27:11 <cloudhead> it's not a "small part"
04:27:16 <cloudhead> it's the main thing
04:27:18 <tdammers> yes, but most of the execution time is spent in library function calls, not in your application code
04:27:29 <cloudhead> if you're i/o bound, yeah
04:27:29 <tdammers> so in terms of performance and scalability, the JS part is not the main thing
04:27:48 <tdammers> most likely, you *are* I/O bound
04:27:56 <maerwald> that's a lot of guessing now
04:28:28 <merijn> If you are not IO bound, you need to doubly question why the hell you are using JS
04:28:28 <tdammers> if you're not I/O bound, then the single-threadedness is just one of many problems you're facing with JS
04:29:06 <tdammers> and the sane answer is to implement the performance critical parts that aren't I/O in something that isn't JS, and then maybe use JS to glue them together
04:29:30 <maerwald> tdammers: nodejs uses libuv as I indicated earlier for that
04:29:57 <merijn> Anyway
04:29:58 <maerwald> and libuv is the "real" thing
04:30:04 <merijn> This is all way off topic
04:30:37 <Myrl-saki> I'd just like to say that js scares me.
04:31:31 <tdammers> agree with merijn, this should go in -blah or -offtopic
04:38:33 <kosc_> Hello. stack can't find my file app/Math.hs for hspec-testing: http://pastebin.com/kCyWCnXJ
04:38:38 <kosc_> What am I doing wrong?
04:42:09 <tdammers> kosc_: does the test suite depend on the subproject that contains app/Math.hs? And does that subproject list Math in the exposed-modules?
04:51:00 <kosc_> tdammers: I can't find out what exactly do you mean, but here is full project: https://drive.google.com/file/d/0B1-axckkKfTcZlB6QTNaWHV4akE/view?usp=sharing
04:51:23 <verrlara> Anyone familiar with Hakyll?
04:51:34 <verrlara> The static blog generater?
04:55:19 <maybefbi> if i have a Network.Socket.Socket -> IO () how can make servant use that socket?
04:56:48 <maybefbi> if i have a Network.Socket.Socket -> IO () how can make wai/warp use that socket?
04:57:52 <maybefbi> its ok i solved it
04:58:20 <maerwald> thanks for letting us know how
04:58:29 <maybefbi> lol oops
04:58:40 <maybefbi> this is the solution
04:58:46 * hackagebot string-convert 3.0.1 - Universal string conversions  https://hackage.haskell.org/package/string-convert-3.0.1 (TobiasDammers)
04:59:01 <maybefbi> http://hackage.haskell.org/package/warp-3.2.7/docs/Network-Wai-Handler-Warp.html#v:runSettingsSocket
04:59:37 <maybefbi> The Application type in that function can be created in servant's serve
05:02:52 <tdammers> kosc_: too lazy to deal with google right now, could you maybe paste your .cabal in lpaste or some such?
05:08:45 <kosc_> tdammers: ok: https://bpaste.net/show/7902366d7669
05:12:47 <thepingles> kosc: not to steal tdammers' thunder, but you need to add "hspec-learn-exe" under "build-depends" in "test-suite hspec-learn-test"
05:12:56 <thepingles> kosc_: not to steal tdammers' thunder, but you need to add "hspec-learn-exe" under "build-depends" in "test-suite hspec-learn-test"
05:14:59 <kosc_> thepingles: Could not find package hspec-learn-exe in known packages
05:15:10 <kosc_> When trying to do stack test.
05:16:11 <thepingles> kosc_: ah yes, my mistake - you can only depend upon libraries
05:16:12 <tdammers> code you want to link into your test suite must be in a library project, not an executable
05:16:31 <tdammers> which means that you cannot test Math.hs that way
05:16:45 <kosc_> Oh, ok, thank you both. :)
05:17:04 <tdammers> the easiest solution is to move all but a trivial stub out of your executable and into the library
05:17:39 <tdammers> but if you insist on testing the code inside the executable, I think you'll have to actually call the executable as a subprocess from within your test suite or something like that
05:20:13 <kosc_> tdammers: No, moving into a library is a good solution for me, if that is a right way.
05:28:47 * hackagebot hw-json 0.2.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.2.0.2 (haskellworks)
05:32:11 <srhb> Has anyone seen a "parse database strings" parser in the wild?
05:33:54 <srhb> I've rewritten one like twenty times, and it's still ugly with notChar x `someTill` char x ... etc.
05:35:05 <srhb> I suppose I can rip off some uri mechanism.
05:36:38 <pavonia> srhb: What database strings?
05:37:09 <srhb> pavonia: Like postgresql://user:pass@host:port/database
05:37:27 <srhb> pavonia: I guess I can just use network-uri, really.
05:37:37 <pavonia> Yeah, I think so too
05:37:59 <srhb> But parsing it nicely made me stumble into that notChar x `manyTill` ... parsing problem again, which bothered me.
05:38:11 <srhb> Perhaps it just _is_ aesthetically displeasing to parse strings like that :P
05:39:43 <t0by> Um, sorry. I have a String IO I got from System.Environment.readFile. I would like to replace some chars in it, but map repl $ readFile (lfilename) doesn't type. Why, though?
05:39:49 <t0by> *typecheck
05:39:55 <verrlara> Cale: Are you around?
05:40:03 <Cale> hi
05:40:08 <srhb> t0by: readFile ... is not a String
05:40:14 <verrlara> do I have to choose between having stack or cabal?
05:40:21 <maerwald> t0by: you mean fmap?
05:40:26 <tdammers> verrlara: no, stack supersedes cabal
05:40:41 <verrlara> Should I get rid of cabal then?
05:40:43 <tdammers> no
05:40:46 <verrlara> ok
05:40:46 <t0by> maerwald, I mean map, but fmap doesn't seem to work.
05:40:51 <tdammers> stack depends on cabal
05:40:52 <t0by> srhb, I know
05:40:56 <verrlara> Ok
05:41:00 <t0by> srhb, but *how* would I go at it, then?
05:41:05 <maerwald> t0by: fmap works with IO
05:41:06 <srhb> t0by: Usually with a do block..
05:41:09 <srhb> t0by: Or fmap
05:41:09 <t0by> I tried fmap and <$>
05:41:16 <t0by> srhb, I'm inside a do block
05:41:17 <t0by> uh
05:41:19 <srhb> t0by: You probably want (map repl) `fmap` ...
05:41:22 <verrlara> So If I build someting with cabal, then bild something else with stack will I have doublicate repos of depends?
05:41:24 <t0by> D'oh
05:41:25 <maerwald> show your actual code
05:42:09 <Cale> verrlara: stack generally manages its own copies of whatever stuff is being used to build projects
05:42:11 <tdammers> verrlara: it depends, but most likely, yes. cabal maintains a user-global repository, but this means that everything you install must have consistent dependencies across projects, unless you use sandboxes
05:42:24 <tdammers> verrlara: but if you use cabal sandboxes, you will have duplicates
05:42:32 <maerwald> > fmap (++ "abc") (return "def" :: IO String) -- produces "defabc"
05:42:34 <lambdabot>  <IO [Char]>
05:42:49 <tdammers> verrlara: stack is a bit smarter, maintaining its own package cache which it shares between projects, but doesn't require consistent dependencies
05:42:50 <verrlara> Alright. Thank you. 
05:42:56 <t0by> maerwald, http://pastebin.com/raw/6BHFax0v
05:43:48 <maerwald> (map repl) `fmap` readFile ("test.txt")
05:45:48 <maerwald> to me it looks like you need to do some do-desugaring to know why your stuff does not typecheck
05:52:25 <Guest6342> I'm trying to write code like this: http://pastebin.com/10rg6Dxq how can I force the application of f, instead of returning f itself?
05:52:49 <notdan> judging by the type signature, f itself is not a function, but an integer
05:53:33 <Guest6342> notdan: right, my bad. The actual type is: integer :: Parser Integer 
05:54:07 <notdan> well then you should use runParser or something like that
05:54:32 <maerwald> yeah, we don't even know the library you use
05:55:05 <notdan> Guest6342: see http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec-Prim.html#v:runParser and other functions there
05:55:09 <notdan> assuming you are using parsec
05:55:26 <notdan> Parser Integer = Parsec String () Integer
05:56:16 <Guest6342> Actually megaparsec. Maybe I should have presented the actual code from the start. :) The problem is, that http://pastebin.com/iQ4gkMFW works fine. But I'd like to get rid of the intermediate variable and just return the result of the single assignment operator.
05:56:28 <t0by> maerwald, I see. Why does (map repl) `fmap` source not work?
05:56:47 <hydraz> Guest6342: fromIntegral <$> integer
05:58:03 <hydraz> LitInt <$> fromIntegral <$> integer and you can remove the entire do-block
05:58:29 <merijn> hydraz: That simplifies to "LitInt . fromIntegral <$> integer"
05:59:02 <hydraz> right, I'm not very good at pointless I mean point-free style.
05:59:11 <orion> In general, do many people find value in Haskell binaries statically linked against musl, so that that the executables are portable?
06:00:16 <Guest6342> ahh, I was missing the link to LitInt. Many thanks! :)
06:00:18 <merijn> orion: "in general"? Probably not. Is there people that'd value that? Yes.
06:01:05 <maerwald> t0by: check the type of "source"
06:02:11 <orion> merijn: Static builds are hard. Do you think there would be any profitability in a build farm business which automates the process?
06:04:00 <merijn> orion: Probably not, the people who want something like that are probably able to build it themselves :)
06:04:17 <merijn> But then, I'm a probably a poor substitute for market research :p
06:08:49 * hackagebot board-games 0.1.0.5 - Three games for inclusion in a web server  https://hackage.haskell.org/package/board-games-0.1.0.5 (HenningThielemann)
06:09:42 <pollz> Hello. Are there any monadic versions of "take" and "drop" for IO Lists?
06:10:09 <srhb> pollz: fmap take and fmap drop
06:10:15 <thewormkill> just do take <$> action
06:10:24 <thewormkill> damn, I'm slow today
06:10:34 <pollz> You mean literally put "<$>" after the take?
06:10:47 <srhb> pollz: Yup. It's just an infix synonym for fmap
06:10:51 <thewormkill> take <$> yourActionHere
06:10:57 <pollz> Roger That.
06:10:58 <thewormkill> or fmap take yourActionHere
06:11:04 <thewormkill> or infix fmap
06:11:20 <pollz> Is there any single resource you could quote for such haskell ninja skills?
06:11:32 <thewormkill> hackage and hoogle
06:11:34 <pollz> I am preparing for competitive programming interviews.
06:12:06 <thewormkill> then I'd try to grok the concepts. knowing the common libraries comes after some usage
06:12:07 <pollz> Yes I know about them, but rather the basics.
06:12:22 <pollz> I do not understand what you mean by "grok" 
06:12:36 <thewormkill> ah, understand throughly
06:14:54 <pollz> I am sorry but the <$> is not working. My program returns a list of lines from a file as an IO [String] type.
06:15:01 <LKoen> pollz: https://en.wikipedia.org/wiki/Robert_A._Heinlein#Words_and_phrases_coined
06:15:06 <srhb> pollz: lpaste.net
06:15:13 <pollz> Sure. Just a minute.
06:15:15 <srhb> pollz: Given the information your provided, you've got the right answer. :)
06:15:19 <srhb> you've*
06:16:01 <lpaste> pollz pasted “No title” at http://lpaste.net/170774
06:16:24 <pollz> Forgot title. Apologies.
06:17:00 <srhb> pollz: And what's the problem?
06:17:11 <pollz> I would like to select the 20th line of this file. But the "take" and the "drop" do not work on the returned "list"
06:17:32 <srhb> pollz: Yes, they do. Can you amend your paste to include the (non-working) conceptual attempt?
06:18:49 * hackagebot hw-mquery 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-mquery-0.0.0.1 (haskellworks)
06:18:59 <srhb> pollz: The current paste is functional (if useless. :-))
06:19:10 <maerwald> pollz: what's wrong with: return $ take 20 list -- ?
06:19:12 <srhb> Perhaps it's better to say "it type checks" :-P
06:19:17 <lpaste> pollz revised “No title”: “Attempt” at http://lpaste.net/170774
06:19:50 <maerwald> I start to feel this is some sort of exercise
06:19:56 <maerwald> it looks similar to the previous question
06:19:56 <pollz> The function getTheseLines works on [String] -> [String]
06:20:00 <thewormkill> pollz: that works on pure lists, and that's fine.
06:20:05 <pollz> Yes.
06:20:07 <srhb> pollz: What's the type of `list` ?
06:20:22 <pollz> List is [String]
06:20:23 <thewormkill> if you want it to work with things that are in IO, what do you do?
06:20:29 <maerwald> are we doing homework here?`:P
06:20:35 <srhb> pollz: Sounds good, no?
06:20:41 <srhb> pollz: That's exactly the type you needed.
06:21:26 <pollz> I am confused. So, I understand that for my function to work on the return value I have to modify it to work on the IO monad.
06:21:49 <srhb> pollz: That is true, but you don't need to use it on the return value (and certainly not the return value of main)
06:21:53 <pollz> This is not homework. I need a template Haskell script to run on input files given during competitive programming competitions.
06:21:59 <srhb> pollz: You can just apply your function to list _in_ main
06:22:30 <pollz> You mean the take and drop routine works fine as long as it is inside the do loop?
06:22:50 <srhb> pollz: The point is that lines has the right type for your function to work on it.
06:23:06 <srhb> pollz: So much wrong terminology in one sentence though, I think you'd benefit from some beginner reading materials :-)
06:23:07 <maerwald> pollz: do you know what do-notation actually does?
06:23:57 <pollz> Okay. Apologies. I will try figuring this out on my own.
06:24:35 <maerwald> https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_bind_operator
06:24:36 <srhb> pollz: No, it's fine. It's just that some of these things are only confusing because you don't have the prerequisites yet (I'm guessing)
06:26:28 <hamsterdam> Hi, I’m a new package author and just uploaded my first one. I uploaded docs using Edward Kmett’s script, but the links to module documentation are not shown. Any ideas what I did wrong?
06:26:42 <pollz> I just need a script which can read a data file and give me the required lines in a [String] list than a IO [String].
06:26:59 <pollz> I am not a Haskell programmer per se. I have started using this half a month ago. 
06:27:02 <srhb> pollz: You already have it. :)
06:27:16 <srhb> pollz: Just use your function in the do block in main. And print the result or something.
06:27:25 <pollz> I am trying it. 
06:27:32 <pollz> I think I get what you're saying.
06:28:14 <srhb> pollz: For instance, `putStrLn (list !! 20)`
06:31:22 <pollz> I used take 5 list after the list <- getlines "case.dat" line and it still shows a type error.
06:31:34 <pollz> Is there some special syntax that I am missing?
06:32:06 <pollz> I know I sound extremely dumb but I want to get this sorted anyhow.
06:32:11 <ongy> pollz: are you returning the `take 5 list=?
06:32:13 <srhb> pollz: The type of every line in that do block must be IO
06:32:29 <srhb> pollz: So literally try: print (take 5 list)
06:33:23 <pollz> sorted.
06:33:30 <pollz> Yeah. So I had to return it.
06:33:37 <srhb> pollz: Then it won't be printed.
06:33:58 <pollz> I changed it to return(take 5 list)
06:34:31 <pollz> So if I need to use this new list I just need to bind it as a <- take 5 list and work with a, is that correct?
06:34:51 <suppi> hamsterdam: cabal-install 1.24 has a feature to build and upload documentation to hackage. cabal upload --doc
06:34:52 <ongy> pollz: the "return"
06:34:54 <srhb> pollz: It would be easier to just keep it as [String] rather than putting it back in IO all the time.
06:35:03 <srhb> pollz: As long as you stay in that do block, that is.
06:35:03 <pollz> I get
06:35:04 <ongy>  is not the same as for imperative languages though
06:35:12 <pollz> Sure. Thanks.
06:36:40 <hamsterdam> Thanks suppi. I'll give it a try.
06:37:06 <suppi> np
06:41:06 <pollz> srhb: One clarification. Whenever the function returns from the do block it returns the value as an IO [String]?
06:41:51 <pollz> But when I bind it it becomes a [String]?
06:42:28 <pollz> So if a <- *something that returns IO [String]* then a :: [String]?
06:42:41 <daniel-s> Hello
06:42:43 <heebo> hello ppl
06:42:52 <maerwald> pollz: you should really start with understanding monads and bind operator instead of do-notation
06:43:17 <heebo> can someone look at my github gist and tell me why my traversable instance isnt passing its quickcheck tests?
06:43:18 <maerwald> it's harder to start with do-notation
06:43:24 <heebo> https://gist.github.com/gregnwosu/ef6fefa42bf2862d57df301aead022fb
06:43:27 <pollz> maerwald: What is your favorite monad resource?
06:43:36 <maerwald> pollz: I posted a link above
06:43:58 <pollz> maerwald: Going thru. 
06:44:09 <maerwald> on the same site there is also https://en.wikibooks.org/wiki/Haskell/Understanding_monads
06:44:53 <pollz> maerwald: Wilco.
06:59:59 <sdx23> heebo: take a careful look at your Foldable instance.
07:01:42 <Guest6342> Maybe I'm not seeing the wood for the trees but is there any way to access the fields from a datatype? I've so far only done it with patternmatching in parameters... http://pastebin.com/30pjJ3Cg
07:03:33 <lyxia> Guest6342: case x of A y -> doStuffWith y
07:03:58 <lyxia> Guest6342: let A y = f 5 in ...
07:04:10 <lonokhov> So, there is no way to implement StateT Applictive instance with only Applicative m ?
07:04:37 <Guest6342> lyxia: hm, that looks a bit verbose. But I guess it has to do. Thanks! :)
07:05:21 <heebo> thanks sdx23
07:06:35 <lyxia> lonokhov: indeed
07:17:50 <lonokhov> lyxia: Yeah, I've figured that out. Sad.
07:20:15 <hamsterdam> Hi, when doing `cabal haddock`, I get "Warning: The documentation for the following packages are not installed. No links will be generated to these packages:". How can I install docs for my deps?
07:21:54 <sm> stack haddock
07:22:50 <hamsterdam> sm, I wanted to use cabal because I am intending to do a cabal upload --documentation afterward
07:24:16 <sm> hamsterdam: well, for that you don't need to install docs for your deps
07:24:49 <sm> installing docs for your deps is only for your local convenience, and to silence that warning, and stack haddock is the easy way to do that
07:25:11 <hamsterdam> ok, so I can ignore the warnings for no links to dependency docs after cabal haddock?
07:25:16 <sm> yup
07:25:27 <hamsterdam> Cool, thanks for the clarification
07:25:38 <sm> no problem
07:26:07 <hamsterdam> I wish I could stack exec cabal
07:26:47 <sm> there is some trick for doing that, setting the ghc pkg paths, but I don't remember where it's written down
07:27:02 <hamsterdam> yea, I couldn't get it to work
07:27:25 <hexagoxel> when you upload after `cabal haddock` with that warning, the uploaded docs won't contain links either. i'd say that is more than a local inconvenience at that point.
07:27:41 <sm> hexagoxel: huh, interesting
07:27:42 <hexagoxel> not that missing links are the end of the world.
07:28:38 <cocreature> sm: you actually do need to install docs for your deps. otherwise haddock sometimes fails to set the links correctly
07:28:46 <sm> good to know
07:29:03 <sm> hamsterdam: some discussion of mixing stack & cabal: https://www.reddit.com/r/haskell/comments/3bw95a/using_cabal_and_stack_together/
07:29:55 <sm> I'm curious, why are you having to upload docs ? hackage's haddock is too old to build them or something ?
07:30:49 <hamsterdam> Thanks, all
07:31:35 <tdammers> hackage is often offensively slow at building docs
07:31:37 <hexagoxel> a) because hackage's doc-building-bot is too slow and you want docs quicker than 24h after upload b) because your package does not compile with ghc-8, which is what the buildbot uses.
07:31:38 <hamsterdam> I read on bregriffs blog to use kmetts script to upload docs
07:32:04 <hexagoxel> haddock version is not an issue in my experience.
07:32:06 <cocreature> hamsterdam: these days the script just calls cabal upload --documentation under the hood
07:32:27 <cocreature> there is also the problem of your package requiring some c library which is not available on hackage
07:32:28 <hamsterdam> Gotcha. So I uploaded docs, but they are not showing on Hackage...
07:32:43 <cocreature> hamsterdam: is it showing old docs or no docs at all?
07:32:44 <hexagoxel> hamsterdam: probably caching, wait a few minutes.
07:32:50 <hamsterdam> No docs
07:32:56 <hamsterdam> Ok, will wait
07:33:10 <cocreature> I had it show old docs which you can mitigate by appending a ? at the end of the url, not sure if that works when there are no docs as well
07:33:25 <hamsterdam> I did it the first time more than 24 hours ago and nothing ever showed up
07:34:12 <hamsterdam> Ok, I see the docs :)
07:34:25 <hamsterdam> This has been quite the rigamarole!
07:37:08 <heebo> thanks i fixed the issues , good spot to look at my foldable instance 
07:37:57 <hamsterdam> Should package authors specify "Stability" these days?
07:38:05 <hamsterdam> for Hackage
07:40:20 <maerwald> I don't know what "stability" means in haskell
07:40:26 <maerwald> stuff is either correct, or not
07:40:57 <cocreature> I see stability as an indicator for how stable the api is
07:41:10 <cocreature> as in how often does it change dramatically
07:41:16 <kadoban> Stability would likely refer to API stability, or possibly amount of testing something has undergone.
07:41:34 <maerwald> API stability is encoded in the version semantics
07:41:55 <heebo> but you can fix your version in cabal, i guess having apis changing lots is pretty annoying
07:42:01 <hamsterdam> Yea SO answers seem to think it's legacy baggage that it's included in Hackage
07:45:48 <yamadapc> Has anyone used jmacro-rpc on a real-world application? (https://hackage.haskell.org/package/jmacro-rpc)
07:48:25 <maerwald> there are 3 kinds of "stability: 1. ABI: zero in haskell, 2. API: encoded in version semantics, 3. runtime: which in haskell mostly means "it typechecks"
07:48:33 <maerwald> so I don't really see how that would be useful
07:53:40 <yamadapc> Also interested if anyone has used https://github.com/ku-fpg/sunroof-compiler
07:54:08 <bernalex> the "stability" field in cabal is actually for maturity.
07:54:31 <bernalex> the expected values are alpha, experimental, provisional, or stable.
07:55:06 <bernalex> the latter should arguably be named "mature". but nobody really uses these things any longer.
07:55:26 <Xandaros> All you ever see, more or less, is ‘exprimental’
07:57:05 <tdammers> the stability field is kind of pointless imo
07:57:09 <hexagoxel> "base: Stability: Unknown"
07:57:33 <tdammers> looking at the actual indicators of package maturity is a much more useful thing to do
07:57:55 <tdammers> (last uploaded, # downloads, state of haddock, coding style, test suite, etc.)
07:58:49 <yamadapc> There're votes too, though people aren't using them very much
07:59:34 <hexagoxel> (has proper upper bounds)
07:59:49 * hexagoxel runs before the argument starts :D
08:00:04 <tdammers> (is in stackage)
08:00:10 * tdammers seeks cover
08:00:17 <hexagoxel> ;)
08:00:17 <Xandaros> lol, fuck stackage
08:00:47 <kadoban> Why?
08:01:15 <codedmart> Is there something wrong with stackage? Getting this `FailedConnectionException2 "www.stackage.org" 443 True getProtocolByName: does not exist (no such protocol name: tcp)`
08:01:26 <Xandaros> They require me to upload it there, don't they? The central repo is hackage - uploading there ought to be enough.
08:02:17 <bernalex> Xandaros: random people uploaded stuff I made to hackage, so I don't think you need to do it.
08:02:18 <kadoban> Xandaros: Your package? You don't have to upload it there, but you have to signify that you're willing to maintain your package in a buildable state with the rest of stackage. Which pretty much just means you get notified when/if it breaks it seems. So ... no not really.
08:02:20 <codedmart> just noticed Xandaros comment above :) Is that in relation to my error as well?
08:02:30 <slack1256> I want a Data.Map that I can `lookup` by two different types, let say Int and String
08:02:47 <Xandaros> them pings, lol
08:02:53 <slack1256> would be `Map (Either Int String) a` a good approach?
08:03:01 <Xandaros> kadoban: That's alright, I guess
08:03:08 <slack1256> I don't even know if Either has a Ord instance
08:03:46 <fr33domlover> :i Either
08:03:55 <fr33domlover> ah need ghci for this
08:04:00 <kadoban> slack1256: One way to find out :) But it sounds sane if that's what you want to do.
08:04:06 <lyxia> > Left () < Right ()
08:04:07 <lambdabot>  True
08:04:11 <tdammers> Xandaros: stackage doesn't replace hackage, it just indexes it and provides a curated list of "probably works" package versions from hackage
08:04:41 <kadoban> It also manages to have docs that work most of the time, instead of ... essentially never.
08:04:43 <bernalex> tdammers: can you use stackage with cabal?
08:04:49 <bernalex> i.e. cabal-install
08:04:55 <kadoban> bernalex: Yeah
08:05:12 <kadoban> That was the old way before stack came around, and it still works AFAIK.
08:05:13 <bernalex> I seem to recall that being a viable option. that's useful.
08:05:38 <tdammers> bernalex: yes. stackage publishes a cabal config that pins everything to the stackage-blessed versions
08:05:47 <slack1256> Cool, although I probably wrote that wrong. I would want a `Map (Int, String) a` and something like `lookup `on` fst`
08:05:48 <tdammers> bernalex: you can just dump that in your project and keep using cabal
08:06:21 <kadoban> slack1256: You probably just want two Maps, one by Int and one by String
08:07:18 <kadoban> slack1256: Also a possibility is a relational database, like sqlite or something more involved.
08:07:24 <slack1256> they would point to the same result but with different keys.
08:07:33 <slack1256> !!
08:07:41 <slack1256> You're right, this looks kind of relational
08:08:07 <kadoban> slack1256: Yes, the two Maps could have the same content. You'd likely want to wrap it up behind something so they don't get out of sync if you go that way. There may already be some package to do something like this, but I dunno.
08:08:35 <maerwald> bernalex: you should only use stack, because it solves all your problems etc
08:08:53 * tdammers drinks the stack kool-aid
08:09:35 <bernalex> maerwald: you've got it the wrong way around. first you need to try to convince me that I am using cabal-install wrong, since I don't have any problems with it.
08:09:52 <maerwald> bernalex: you must be the only one!!
08:09:57 <kadoban> maerwald is just being a strawman asshole, I'm quite sure.
08:09:57 <bernalex> maerwald: then you need to point out that I *have* problems, even if I don't think so. only *then* you make teh stack sales pitch.
08:10:24 <maerwald> kadoban: I'm not sure if it's appropriate to call people a**holes here.
08:10:25 <bernalex> he's probably had too much 9'er these past few weeks
08:10:29 <maerwald> haha
08:13:13 <orion> I wish stackage didn't depend on cabal.
08:13:20 <Xandaros> makeLenses from microlens generates a `Traversal' A [A]`, to get the children of my datatype. The type has two constructors, so it's a Traversal instead of a Lens (really should be a Prism). How would I go about getting a `Traversal' A A`, instead? (Instead of matching nothing or a list of A, match any number of A)
08:13:55 <maerwald> I wish we hade more random build systems that are completely disconnected from one another, so things are as bad as in C where you basically need a full-blown package manager that abstracts over 200 build systems to do anything remotely useful.
08:14:05 <glguy> makeLenses is from lens (and copied into microlens)
08:14:16 <glguy> Also, compose your traverseal with "traverse" to do what you wanted
08:14:44 <kadoban> codedmart: It seems to be working fine for me. Network issues possibly? Maybe TLS cert issues?
08:15:19 <lambdafan> maerwald : Then we can get meta and have more random full-blown package managers completely disconnected from each other until we have to have ...
08:16:15 <codedmart> kadoban: Hmm… I am trying to run this command from a docker `Dockerfile` `stack update && stack upgrade && stack --resolver nightly-2016-07-05 setup`
08:16:38 <maerwald> lambdafan: sounds reasonable, and then we can define common interfaces like pkg-config only half of the projects use... and the other half is wrongly added by random distros, so you get more unpredictable results
08:16:54 <kadoban> codedmart: Hmm, I don't use docker :-/
08:17:14 <glguy> codedmart: Failing to resolve the protocol name is interesting, maybe it needs access to /etc/protocols when calling getProtocolByName
08:17:34 <bernalex> maerwald: lambdafan: and then take a minute to reflect on how this is the by far most sane and successful approach to date.
08:17:49 <codedmart> glguy: Well this exact command worked yesterday in my Dockerfile. Stile investigating.
08:17:56 <codedmart> Still not stile.
08:18:09 <maerwald> bernalex: duplicating work always works... not sure if that's sane though
08:18:16 <maerwald> you might as well call java a sane programming language
08:18:47 <bernalex> I said "most sane", which means that it is comparatively sane. 
08:19:04 <Xandaros> glguy: That worked, thank you :)
08:19:33 <Xandaros> Next question: Can I make a uniplate-y Traversal, which will get all sub-children, as well?
08:20:18 <glguy> Xandaros: Yeah, that's what this module is about http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Plated.html
08:20:25 <glguy> You can use Generics to derive the implementation, too
08:20:59 <Xandaros> Well, I don't really want to bring in the lens dependency
08:21:03 <glguy> bummer :(
08:21:32 <Xandaros> It's fine for an app, but imposing it on people in a (small) library, feels wrong :D
08:24:54 <kadoban> Xandaros: Make the library bigger? ;)
08:25:27 <tdammers> implement the subset of lens that you need yourself :x
08:26:27 <Xandaros> That would require me to actually know what I'm doing
08:26:58 <fragamus> howdy i need a mutable array that is way hipster fast - any ideas
08:27:31 <glguy> fragamus: array and vector both have mutable variants
08:27:54 <kadoban> hipster fast, that's a new one
08:28:07 <Xandaros> I like it
08:28:33 <orion> maerwald: Could you please elaborate on your statement, " you basically need a full-blown package manager that abstracts over 200 build systems to do anything remotely useful"?
08:29:08 <fragamus> but I want unboxed speed
08:29:36 <nshepperd_> fragamus: array and vector both have unboxed mutable arrays
08:30:01 <fragamus> oh okay buddy that is powerful buju
08:33:45 <maerwald> orion: that's basically one of the main purposes of a package manager
08:39:44 <Guest6342> I'm trying to show the remaining input of my megaparsec parser upon failure. So I do "inp <- getInput" followed by "print $ show inp". GHC keeps telling me there are several potential instances. I can't find samples on how to achieve this either. Anybody having any experience with this?
08:41:17 <sdx23> Guest6342: print $ show is redundant. Adding a type signature helps with the instances.
08:41:49 <bernalex> @src print
08:41:49 <lambdabot> print x = putStrLn (show x)
08:43:25 <Guest6342> sdx23: alright, fixed that at least. That doesn't fix the problem though. I'm just upright lost at how to use the getInput. https://www.haskell.org/hoogle/?hoogle=getInput I would have assumed that this returns a string I can just print. But it doesn't seem like it.
08:44:36 <maerwald> bernalex: is show . show even the same as show?
08:44:48 <dolio> No.
08:45:06 <bernalex> > show "hallo"
08:45:07 <lambdabot>  "\"hallo\""
08:45:10 <dolio> There's an extra level of quotes and escaping.
08:45:10 <glguy> Guest6342: We can help better if you put the broken code on http://lpaste.net
08:45:10 <bernalex> > show . show $ "hallo"
08:45:11 <lambdabot>  "\"\\\"hallo\\\"\""
08:45:14 <maerwald> heh
08:45:20 <hpc> > fix show
08:45:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
08:45:34 <glguy> hpc: If it ain't broke, don't fix it
08:45:35 <bernalex> show escapes things.
08:45:57 <hpc> > fix error -- if it's broke, also don't fix it
08:45:58 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
08:46:27 <Guest6342> glguy: sure thing. http://lpaste.net/170802
08:46:56 <glguy> Guest6342: You can't use getInput outside of the parser
08:47:56 <glguy> Guest6342: All the parser stuff goes to the first argument of "parse", in this case that's "whileParser"
08:49:52 <Guest6342> glguy: ah, that makes sense, I guess. Let me see if I can fix it with that in mind...
08:49:54 <glguy> I'm not sure that it even makes sense to get the "remaining" portion of the input on failure in general due to parsec supporting backtracking
08:50:43 <glguy> But you could write a specific parser that returns either the desired result or the unparsed remaining string
08:50:58 <Guest6342> glguy: well, as is I am just getting something along the lines of "unexpected 'p', expected '('", which is - unsurprisingly - not helping. Any way to show where the parsing went wrong would help
08:51:50 <glguy> Guest6342: Parse errors contain "errorPos :: NonEmpty SourcePos", so you should be able to see where the unexpected ( is in the input string
08:52:21 <c_wraith> it's true, though, that parsec isn't the greatest for error messages. 
08:52:58 <c_wraith> but the parser library designed for great error messages is rather underdocumented
08:53:17 <Xandaros> Which library is that?
08:53:27 <c_wraith> trifecta 
08:54:05 <Xandaros> Ah yes, I remember looking at it and dismissing it for lack of docs
08:54:21 <Xandaros> Although it seems to be a bit better now
08:55:34 <Guest6342> aah! errorPos helps at least a bit. That should do. For now. Thank you! :)
09:02:41 <Guest6342> btw I've noticed that most tutorials on parsers use literal constants in all the code. Coming from OOP, I tend to make constants for all tokens. Is that deprecated?
09:03:07 <maerwald> what is a "constant"?
09:03:30 <Guest6342> a... value that doesn't change over the course of the program?
09:03:41 <maerwald> you mean like basically all "variables" in haskell?
09:03:54 <Guest6342> yes.
09:03:56 <maerwald> ...
09:04:20 <tdammers> it's quite common for parser-combinator parsers to not have an explicit tokenization step at all
09:04:51 <chpatrick> Guest6342: I wouldn't bother giving them a separate name
09:04:57 <chpatrick> for parsing
09:05:00 <tdammers> so instead of defining a constant that represents the "open parens" token, you just write a parser that parses an opening parens
09:05:00 <chpatrick> it doesn't really add anything
09:05:31 <Guest6342> tdammers: ah, that makes sense
09:06:01 <tdammers> you *could* add a constant (i.e., a top-level variable), but the added value would be small, if any
09:06:19 <Guest6342> maerwald: the point of constants is not just to have the values immutable but to be able to modify all occurances in one place. But with the explanation of tdammers it makes sense
09:07:17 <tdammers> well, yes, "all the occurrences" will be all the invocations of your openParens parser
09:08:35 <mnoonan> Guest6342: it's more common to give a name to the small operations, which is much easier with partial evaluation
09:09:05 <mnoonan> so instead of "#define PAREN ')'" and "parse(PAREN, etc)", you could have "p_paren = parse ')'" and use p_paren directly
09:09:14 <Guest6342> mnoonan: I guess partial evaluation comes in handy here. It's just me getting used to the concepts of fp
09:09:34 <tdammers> parenthesized inner = openParens *> inner <* closingParens -- this is as descriptive as it gets, isn't it?
09:10:27 <tdammers> and it doesn't even matter whether the building blocks are functions or parsers or IO actions or constants; what matters is that you have an expressive yet readable DSL for building parsers
09:11:08 <maerwald> Guest6342: if you are doing encoding sensitive stuff with e.g. bytestring, you might want to actually use something like the word8 that has safe variables for ASCII chars, because using literals instead would involve using OverloadedString, which depends on GHC behavior which is not that safe
09:11:18 <maerwald> *word8 package
09:11:42 <maerwald> e.g. https://hackage.haskell.org/package/word8-0.1.2/docs/Data-Word8.html#v:_nul
09:11:56 <maerwald> that's the only case I know where this kind of thing is done
09:11:59 <Guest6342> the current version should be unicode compliant but thanks for the hint I will keep it in mind
09:18:35 <gottharsys> @pl h a (p:ps) = h (10*a + p) ps
09:18:35 <lambdabot> h = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . (. ((+) . (10 *))) . (.))
09:27:25 <Guest6342> http://lpaste.net/170806 this somewhat breaks the concept of parsing literals in their own small functions. Can this be rewritten to comply to that anyway?
09:28:08 <divVerent> @pl fib n = if n <= 2 then 1 else fib (n-1) + fib (n-2)
09:28:09 <lambdabot> fib = fix (ap (flip if' 1 . (<= 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
09:28:18 <tdammers> you could factor out the `char '"'` part
09:28:19 <divVerent> way more readable ;)
09:29:02 <mniip> divVerent, because it's a lame implementation :P
09:29:15 <lpaste> tdammers revised “No title”: “No title” at http://lpaste.net/170806
09:29:27 <tdammers> Guest6342: ^^
09:29:36 <gottharsys> @pl fn x = x !! 1 == 5
09:29:36 <lambdabot> fn = (5 ==) . (!! 1)
09:29:40 <maerwald> more LOC, more to read
09:29:48 <Guest6342> ah, I see. Thanks, tdammers 
09:30:01 <divVerent> @pl ack m n = if m==0 then n+1 else if n==0 then ack (m-1) 1 else ack (m-1) (ack m (n-1))
09:30:02 <lambdabot> ack = fix (ap (ap . (. (1 +)) . if' . (0 ==)) . ap (ap . ((ap . flip (if' . (0 ==))) .) . flip flip 1 . (. subtract 1)) (ap (ap . ((.) .) . (. subtract 1)) (flip flip (subtract 1) . ((.) .))))
09:30:02 <tdammers> maerwald: TIL "readability" refers to how much there is to read
09:30:30 <divVerent> nice code expander
09:30:39 <maerwald> tdammers: in a sense, yes
09:30:49 <mniip> :t fst . (iterate (snd &&& uncurry (+)) (0, 1) !!)
09:30:51 <lambdabot> Num b => Int -> b
09:31:05 <mniip> > map fst $ iterate (snd &&& uncurry (+)) (0, 1)
09:31:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:31:39 <mniip> divVerent, ^
09:32:20 <c_wraith> > fix $ (0:) . scanl (+) 1
09:32:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:32:28 <fr33domlover> :t if'
09:32:29 <lambdabot>     Not in scope: ‘if'’
09:32:29 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
09:32:32 <quchen> :t \(a,b) -> (b, a+b) -- here, let me golf your &&& to unreadability
09:32:32 <mniip> ah right
09:32:33 <lambdabot> Num t => (t, t) -> (t, t)
09:32:34 <mniip> I forgot
09:33:02 <divVerent> mniip: sure, I know :)
09:33:05 <divVerent> but teach that to pl
09:33:18 <mniip> pl won't optimize your algorithm
09:33:44 <quchen> bgamari: Hooray :-)
09:33:57 <quchen> (For Zürich)
09:34:18 <divVerent> mniip: sure
09:34:23 <divVerent> also having fun with blunt :P
09:34:33 <bgamari> quchen, indeed
09:34:38 <bgamari> very much looking forward to meeting you all
09:34:39 <mniip> all it can do is replace 'const (<*>) <*> const' with '(.)'
09:34:56 <mniip> and similar
09:35:08 <divVerent> hehe, blunt's conversion back to pointful is even more cryptic
09:35:12 <divVerent> fib = fix (\ k b -> ((return ((\ ac ah e -> (ah >>= \ ad -> return ((\ ao -> (+) (ac (subtract 1 ao))) e ad)) e) k ((\ h av -> h (subtract 2 av)) k)) k) >>= \ l -> return ((\ d -> if' (d <= 2) 1) b l)) b)
09:35:22 <divVerent> looks I found a nice code obfuscator
09:35:33 <maerwald> yes, that's the main purpose of those tools
09:35:44 <divVerent> too bad the fix ... (substract 1 ... (subtract 2 ... is kinda giving it away
09:36:13 <mniip> I wonder if ackermann can be folded cleverly
09:36:23 <c_wraith> nope. 
09:36:35 <c_wraith> it's not primitive recursive 
09:36:41 <mniip> so?
09:36:43 <c_wraith> that's the whole point of it. :) 
09:36:57 <c_wraith> folds correspond to primitive recursion 
09:37:04 <mniip> oh no I don't mean literal folds
09:37:22 <c_wraith> Oh, whoops 
09:37:24 <mniip> I mean more in the golfing sense
09:38:05 <clarkenciel> I'm playing around with Megaparsec and I've got an attempt at parsing nested, balanced parenthese, but it fails and I'm not totally clear on why: http://lpaste.net/170808
09:41:37 <c_wraith> clarkenciel, that has.. a number of issues. just to point one out.. I think "(()" would pass. 
09:42:46 <c_wraith> clarkenciel, basically, I'd say collectUntil' is just completely solving the wrong problem. 
09:43:44 <c_wraith> clarkenciel, it needs to be able to call balance again to handle nesting. 
09:44:06 <clarkenciel> I don't think "(()" passes
09:44:31 <c_wraith> I'm on my phone, but and actually test. did you check it? 
09:44:38 <clarkenciel> yeah
09:44:43 <clarkenciel> failure on unexpected open paren
09:44:56 <clarkenciel> or actually unexpected closed paren
09:45:29 <c_wraith> Oh, that's yet another issue. 
09:46:03 <c_wraith> in that collectUntil' doesn't consume the closing token. 
09:50:12 <amf> is there a mtl-like library but for RST (aka no WriterT)? 
09:50:26 <clarkenciel> hm, something like http://lpaste.net/170814 should fix the consumption issue right?
09:50:35 <mniip> well here's a hyperoperation function
09:50:38 <mniip> (iterate ((. flip replicate) . (.) . foldr1) (+) !!)
09:51:03 <mniip> hmm
09:51:18 <mniip> (iterate ((. flip replicate) . (.) . foldr1) (*) !!) -- corresponds to knuth's up arrow notation
09:53:33 <c_wraith> clarkenciel, it may or it may not. but it's kind of going down the wrong path to fix that problem first. the lack of nesting in there is the bigger issue. so long as you say everything until the closing token, you won't detect an opening character. 
09:54:00 <c_wraith> clarkenciel, and you need to detect opening characters to handle nesting. 
09:54:52 <clarkenciel> mm yeah thanks c_wraith 
09:57:23 <hator>  /buffer 7
09:57:31 <hator> sry
09:58:57 * hackagebot exceptions 0.8.3 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.8.3 (ryanglscott)
10:13:36 <DzyubSpirit> Am I here?
10:13:49 <Welkin> is you real life?
10:13:54 <fishythefish> is you just fantasy?
10:13:58 * hackagebot hgeos 0.1.0.1 - Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.0.1 (rcook)
10:14:19 <bernalex> is you wearing green?
10:14:47 <fishythefish> is you done or is you finished?
10:15:12 <DzyubSpirit> No, I am woman in red
10:15:32 <Welkin> last night I was reading some terribly old thread (from 8 years ago) where someone was asking about if they can use lisp for "developing games using functional programming", and inevitably, some commenters mentioned haskell and how it is "purely functional, so you can't do imperative programming with it" and "it is not practical"
10:15:37 <Welkin> I loled
10:16:00 <sm> is you loling now in the cold light of day ?
10:16:12 <Welkin> eh?
10:16:23 <bernalex> Welkin: there's only two ways of programming. imperative programming and impractical programming.
10:19:07 <hiptobecubic> :)
10:29:59 <Profpatsch> Does anyone have experience with the dbus package?
10:30:10 <Profpatsch> I wonder how to define out parameters.
10:30:33 <Profpatsch> In my case I want to call the inhibit function https://www.freedesktop.org/wiki/Software/systemd/inhibit/
10:30:48 <Profpatsch> And the last argument is a file descriptor.
10:35:10 <schell> when running with RTS+ -N1 the productivity of my app bumps up to 65.3% (from 15%) - does that smell like anything to you guys?
10:36:50 <hiptobecubic> lots of sparks that are getting garbage collected, maybe?
10:37:22 <bgamari> schell, what were you running with previously?
10:37:29 <schell> -N8
10:37:41 <bgamari> schell, sounds like you are being bitten by GC synchronization
10:37:51 <bgamari> schell, all threads need to stop before GC can commence
10:37:57 <hiptobecubic> oof
10:38:15 <bgamari> schell, so if you are allocating a lot in a parallel application you will need to block quite often and for a long timme
10:38:23 <bgamari> schell, try -N8 -A64m
10:38:25 <schell> i guess the cost of threading isn’t worth it at this point
10:38:39 <schell> hmm - okay, i’ll try that
10:38:46 <bgamari> schell, -A sets the initial heap size
10:38:57 <bgamari> schell, making it larger means that you don't need to GC as often
10:39:26 <bgamari> schell, at the expense of the data you are GCing not fitting quite as well into cache
10:39:32 <bgamari> schell, how many physical cores do you have>
10:39:47 <schell> i have 8
10:39:51 <bgamari> schell, is there any parallel work to be done in your program?
10:40:20 <schell> not really at this point - i’m just experimenting with profiling
10:41:31 <bgamari> schell, ahh, I see
10:41:36 <schell> changing the heap size doesn’t seem to have too much effect
10:41:42 <bgamari> schell, then right, it's probably not worth using threading
10:41:49 <schell> so i think you’re right about the sync'ing
10:41:50 <bgamari> schell, what is your allocation rate?
10:42:12 <bgamari> schell, you can test that by looking at the eventlog with threadscope
10:42:17 <bgamari> schell, compile with -eventlog
10:42:22 <bgamari> schell, run with +RTS -l
10:42:26 <schell> okay, on it
10:42:26 <bgamari> schell, look at the resulting log
10:42:33 <bgamari> it will show GC events
10:44:09 <schell> i have quite a large number of deps so this may take a while
10:46:31 <schell> bgamari: i guess i can either profile OR do RTS event logging?
10:46:37 <schell> not both it seems?
10:47:19 <bgamari> schell, that will be fixed in 8.2
10:47:29 <bgamari> where you will also be able to log heap profile data to the eventlog
10:47:35 <schell> all good, just want to make sure i’m not misunderstanding
10:48:41 <fragamus> hey do we like repa
10:48:51 <schell> well bummer - i can’t seem to get threadscope installed
10:49:13 * schell finds a binary
10:51:05 <Welkin> there's always a binary :D
11:00:01 <schell> bgamari: thanks for the tips
11:01:01 <bgamari> schell, sure
11:04:27 <schell> lots to learn and benchmark
11:05:21 <bgamari> indeed
11:14:42 <Squarism> fmap for either maps the right element. is there an fmap for the left element also? 
11:14:59 <benzrf> Squarism: you can certainly write a function like that easily
11:15:30 <Squarism> i could, but i thought it could be part of base(?)
11:15:45 <lyxia> first / second from Bifunctors
11:15:54 <benzrf> @hoogle (a -> b) -> Either a c -> Either b c
11:15:57 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
11:15:57 <lambdabot> Data.Graph.Inductive.Graph nemap :: DynGraph gr => (a -> c) -> (b -> d) -> gr a b -> gr c d
11:15:57 <lambdabot> Data.Graph.Inductive.Graph labfilter :: DynGraph gr => (a -> Bool) -> gr a b -> gr a b
11:16:10 <benzrf> lyxia: i thought it was lmap and rmap
11:16:17 <kadoban> Squarism: Yeah, you want 'first' from BiFunctor
11:16:22 <Squarism> ah ok
11:16:23 <benzrf> oh, that's profunctor
11:16:24 <kadoban> Bifunctor? Whatever
12:14:41 <Squarism> in a : a >>= b expression, is "a" allways evalutated before b?
12:14:57 <gottharsys> @pl f x = 2 * x ^ 2 - x
12:14:58 <lambdabot> f = (-) =<< (2 *) . (^ 2)
12:15:29 <Squarism> "a >>= b" i mean
12:15:57 <Welkin> it should be
12:16:02 <Welkin> bind and sequence imply an order
12:17:34 <Squarism> id hoped it didnt! 
12:18:05 <the_2nd> I'd like to use seq on a function which updates my state
12:18:17 <the_2nd> but it seems like the state isnt updated at all if i use it
12:18:33 <the_2nd> newState = f oldState   -- works
12:18:56 <the_2nd> newState = seq f oldState -- nope
12:18:58 <monochrom> what does your "state" mean?
12:19:04 <Welkin> Squarism: applicative does not have an order
12:19:24 <the_2nd> monochrom, a data with multiple fields
12:19:37 <monochrom> are you sure you know "seq"?
12:19:50 <the_2nd> im sure I dont
12:20:20 <ski> why do you want to use `seq' on a function ?
12:20:29 <hpc> :t seq
12:20:31 <lambdabot> a -> b -> b
12:20:40 <monochrom> OK, "seq aaa bbb" means the answer is still bbb (may have nothing to do with aaa), but has the side effect of evaluating aaa (which may also have nothing to do with bbb)
12:21:00 <monochrom> So if you say "seq f oldState" surely the answer is just oldState again.
12:21:16 <the_2nd> monochrom, ah thanks
12:21:25 <the_2nd> so how can I force f to be evaluated?
12:21:42 <ertesx> Squarism: there are edge cases when 'a' is not evaluated first
12:22:05 <ertesx> Squarism: trivial example monad:  data Unit a = Unit
12:22:22 <ertesx> Squarism: but for most common monads (>>=) is strict in the first argument
12:22:25 <monochrom> I think you have total misconception based on math teachers' lousy wording "evaluate a function"
12:22:58 <monochrom> in most cases, "evaluate f" doesn't do anything.
12:23:01 <gottharsys> @pl f x = x * (3*x - 1) / 2
12:23:01 <lambdabot> f = (/ 2) . ap (*) (subtract 1 . (3 *))
12:23:12 <the_2nd> monochrom, I dont want just thunks, I want them to be evaluated
12:23:23 <monochrom> instead, it is "evaluate (f oldState)" that does something good
12:24:08 <Welkin> you want them in normal form then?
12:24:15 <the_2nd> yep
12:24:27 <Squarism> ertesx, oh ok. Im experimenting with some chain of Either centric validation here. Probebly easy but i dont master the types i guess
12:25:06 <stouset> Given a function f :: a -> a -> a, is there a way to transform it to take an arbitrary number of parameters? As an example, to do something like `(-) a b c d`
12:25:13 <ski> the_2nd : i think the question is, *what* do you want to evaluate/reduce ? reducing the function `f' is different from reducing an application of `f' to something, perhaps `oldState'
12:25:33 <ertesx> Squarism: with monads that allow failure (Maybe, Either e, [], …) you can assume that (>>=) will evaluates its first argument first…  *however*: it only evaluates to the outermost constructor
12:25:35 <Welkin> stouset: use a list
12:26:17 <the_2nd> ski applying f to oldState should update all fields of oldstate instead of saving thunks
12:26:32 <ertesx> Squarism: so with Maybe if you have (mx >>= f), then the result will be strict on whether 'mx' is a Just or a Nothing, but not on the value in the Just case
12:27:16 <Squarism> get it!
12:27:21 <stouset> Welkin: Out of curiosity, is there a sane way of doing it without a list?
12:28:16 <ski> the_2nd : and is `f' defined to do that ?
12:28:25 <the_2nd> ski, no
12:28:25 <ertesx> stouset: nothing that won't be equivalent to some form of list
12:28:37 <ski> the_2nd : simply using `seq' outside the definition of `f', if `f' isn't correctly defined, won't help with that
12:28:58 <the_2nd> ski, f does what I want, but lazy
12:29:08 <ski> (it's not clear here whether `f' is "correctly defined", for this purpose, or not)
12:29:18 <monochrom> you should speak of evaluated newState instead of evaluating f.
12:29:23 * ski suggests the_2nd paste some code
12:29:31 <ski> (also what monochrom said)
12:29:33 <monochrom> s/evaluated/evaluating/
12:29:43 <Welkin> stouset: if `a` is a Monoid, then you can fold over a list of `a`, apply `f`, and then combine the results
12:29:43 <monochrom> and not just speak of, also think of
12:29:49 <ski> stouset : not really
12:30:09 <the_2nd> ski, https://github.com/I3ck/HGE2D/blob/master/src/HGE2D/Engine.hs#L182
12:31:01 <Squarism> so is this sound:  expr1:Either Err () , expr2: Either Err SomeResult, result = expr1 >>= (\() -> expr2 ) ? Or just clumsy?
12:31:19 <ertesx> stouset: the usual way to approach this is to write the binary function first (like (+)) together with a base element (like 0), then just fold a list
12:31:23 <the_2nd> ski, where moveTime can be quire expensive
12:31:26 <Welkin> from what I have seen, any other language that has some kind of `spread` operator (such as (...)), ends up basically using a list of parameters
12:31:27 <the_2nd> quite
12:31:31 <Welkin> so, it's all lists
12:31:52 <ertesx> stouset: foldl' (+) 0, foldl' (*) 1, foldr (++) [], etc.
12:32:09 <enthropy> Squarism: there's result = do () <- expr1; expr2 -- and if you leave off the () <- I think it's pretty much the same
12:32:39 <glguy> It's about the same, but strict in the unit
12:32:41 <enthropy> > (do () <- Just undefined; Just (), do Just undefined; Just ())
12:32:43 <lambdabot>  (*Exception: Prelude.undefined
12:32:44 <stouset> ertesx: I get that's the usual way. I'm just playing around with different approaches to solving problems, and I thought it might be interesting to have some function that you could do something like `repeat 4 (-) 8 4 2 1`
12:32:45 <Welkin> lol
12:32:58 <Welkin> if you are going to ignore the result, just use >> instead of >>=
12:33:06 <enthropy> > snd (do () <- Just undefined; Just (), do Just undefined; Just ())
12:33:08 <lambdabot>  Just ()
12:33:21 <Squarism> Welkin, im a noob ok! =D
12:33:36 <ertesx> stouset: i'll end up with something equivalent to a list anyway
12:33:43 <ertesx> s/i'll/you'll/
12:33:58 <stouset> I get that.
12:34:19 <ertesx> stouset: there are some edge cases though like 'id', which can have any arity
12:34:29 <Welkin> stouset: you can write that yourself as a DSL if you want
12:34:35 <Welkin> but underneath it will be using lists :P
12:34:44 <stouset> For the sake of argument, I want a resulting function signature of f :: a -> a -> a -> a -> a (for some `n` iterations)
12:34:59 <ertesx> stouset: can you express the type of that?
12:35:07 <stouset> I... thought I just did?
12:36:03 <geekosaur> you can't express "(for some `n` iterations)" as such in a type signature...
12:36:08 <stouset> (f 4 (-)) :: (Num a) => a -> a -> a -> a
12:36:09 <Welkin> you are just creating a list, but making it more work for yourself
12:36:14 <stouset> (f 5 (-)) :: (Num a) => a -> a -> a -> a -> a
12:36:27 <stouset> Look, I get that there's really a list under the scenes.
12:36:30 <Welkin> you can tag the list with a length n
12:36:34 <stouset> I'm interested in this for the sake of learning Haskell.
12:36:36 <Welkin> by making your own newtype
12:36:59 <ertesx> stouset: that's not the point…  what would be the type of that?
12:37:09 <ertesx> stouset: not of (f 4) or (f 5), but of f
12:37:13 <stouset> Not just for learning the idiomatic way. But to learn about different ways of approaching problems.
12:37:23 <ertesx> stouset: if you want to be able to express f, it must have a valid type
12:37:57 <glguy> stouset: types in Haskell don't depend on values, so the type can't depend on which Int you give to this function
12:38:06 <stouset> ertesx: Ah, I see your point.
12:38:14 <stouset> glguy: Yep.
12:38:19 <bernalex> glguy: (yet ;)
12:38:20 <ski> the_2nd : `gs' is `oldState' ? where is `getTime',`setTime',`moveTime' defined ?
12:38:32 <shachaf> glguy: But you could probably make "f @5" work.
12:38:34 <glguy> Hopefully not soon, either
12:38:56 <ertesx> stouset: there are facilities to hack your way to such a function, but it's not going to be pretty, and the implementation will be complicated and awkward using all sorts of type/class trickery
12:38:58 <bernalex> glguy: wouldn't be on by default, I'm sure.
12:39:03 * hackagebot feed-gipeda 0.1.0.3 - Simple project template from stack  https://hackage.haskell.org/package/feed-gipeda-0.1.0.3 (sgraf812)
12:39:09 <shachaf> Or you could just make it work by giving the type explicitly, without a number argument.
12:39:15 <the_2nd> ski, theyre all of type   f :: something -> a -> a   where a is gamestate
12:39:39 <stouset> Yep, that's fair. The fact that such fn can't be represented in the type system is a totally fair point. :)
12:39:48 <the_2nd> ski, see datas.hs   EngineState a
12:39:51 <shachaf> ertesx: It isn't really that bad.
12:40:45 <ertesx> shachaf: to us, but a few years ago as a beginner i found it terrifying (and compelling)
12:43:23 <ski> the_2nd : and the `es' argument to `idle' is coming from (only) `runEngine' ? where is `runEngine' called ?
12:44:20 <ertesx> ("few years"…  almost ten years now…  holy shhhhhamble…)
12:44:53 * EvanR gives ertesx a gold walking cane
12:45:30 <shachaf> I should get GHC 8 sometime.
12:46:05 <kadoban> I finally got around to making stack install it for me ... haven't really used it though. The stuff I was trying to use isn't updated yet, apparently. Or at least it's not in stackage nightlies.
12:46:06 <glguy> You're old school
12:50:42 <ertesx> when was 6.4 released?
12:50:47 <ertesx> (GHC)
12:55:58 <fragamus> how does one store a single element of a repa DIM1 array 
12:56:10 <fragamus> for the love of god
12:57:21 <fragamus> I guess that's not what repa is about
12:58:48 <ertesx> fragamus: "store"?
12:59:04 <fragamus> write
12:59:15 <ertesx> fragamus: you want to change a single element?
12:59:26 <fragamus> yup
12:59:41 <ertesx> fragamus: you can make a D array with the element changed
12:59:44 <fragamus> repa is not the right tool i see that now
13:00:10 <fragamus> i am implementing a cache
13:00:27 <fragamus> i need mutable array 
13:00:33 <ertesx> fragamus: changing a single element on an array is generally an expensive operation, but with a D array it's cheap enough, as long as you don't do it to often in a row before going back to U
13:00:44 <ertesx> fragamus: yeah, repa is probably not the right tool
13:29:50 <ARM9> is it possible to override a function from a superclass in a subclass?
13:30:05 <quchen> No.
13:30:07 <kadoban> ARM9: No
13:30:12 <dmj`> No
13:30:42 <quchen> The existence of a subclass has no influence whatsoever on the class itself.
13:31:19 <ARM9> no, overriding the function only in the subclass
13:31:31 <ARM9> I don't want the subclass to change anything in the superclass
13:31:39 <quchen> Still no.
13:32:22 <Welkin> lol
13:32:26 <hpc> this question sounds really OO
13:32:27 <Welkin> this is not oo
13:32:42 <hpc> haskell doesn't strictly speaking have subclasses or superclasses
13:33:16 <hpc> in that there's no inherent relationship between something like Monad and Applicative that comes out of their definitions
13:33:34 <hpc> @src Monad
13:33:34 <lambdabot> class Applicative m => Monad m where
13:33:34 <lambdabot>     -- Note: Applicative wasn't a superclass before GHC 7.10
13:33:34 <lambdabot>     (>>=)  :: m a -> (a -> m b) -> m b
13:33:34 <lambdabot>     (>>)   :: m a -> m b -> m b
13:33:34 <lambdabot>     return :: a -> m a
13:33:36 <lambdabot>     fail   :: String -> m a
13:34:08 <ARM9> if you say so Welkin 
13:34:11 <hpc> specifically the "class Applicative m => Monad m where" line, all that means is to write "instance Monad m where", there must exist "instance Applicative m"
13:34:27 <hpc> they can't alter each other or anything like that
13:34:34 <Welkin> ARM9: I meant haskell is not oo
13:34:49 <ARM9> insightful
13:35:02 <maerwald> Welkin: why not?
13:35:38 <maerwald> Welkin: https://arxiv.org/pdf/cs/0509027.pdf
13:36:20 <maerwald> if it wasn't an Oleg paper, I'd take it as a joke, but ;P
13:36:21 <geekosaur> you can encode OOP in Haskell, but typeclasses aren't going to do it
13:36:44 * ski thinks that perhaps a subclass should be able to repeat a method of a superclass, but with a more general signature
13:36:54 <koz_> I think Gabriel Gonzales even had an article on OO being represented by comonads.
13:37:04 <rrradical> I'm getting an error trying to build a GHC 8.0.1 iPhone/Arm64 cross compiler: http://lpaste.net/170838 Has anyone seen this before? strnlen is defined in the string header that the error references, but it's behind a flag that I guess is not being set correctly
13:37:20 <ertesx> ARM9: i think what you need is a type, not a class
13:37:57 <ertesx> ARM9: abstract classes in OO translate mostly to types in haskell, and non-abstract classes translate to values
13:38:53 <johnw> isn't OOP in Haskell usually just a record of functions?
13:39:12 <ski> sometimes with a facility of open recursion
13:39:14 <ertesx> johnw: that's overly specific
13:39:26 <agrue> rrradical: I always had tons of trouble trying to build a cross-compiling GHC on OS X. I think I was only ever able to do it inside a docker container
13:39:28 <mizu_no_oto_work> johnw: that doesn't quite give you subtyping
13:39:38 <ski> @where object-oriented
13:39:39 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
13:39:53 <johnw> why is that?
13:40:01 <ARM9> perhaps ertesx, I'm trying to simplify my problem to avoid asking another XY question
13:40:18 <ARM9> since my current approach obviously seems like a dead end
13:40:31 <agrue> I don't have a solution to your specific issue. I remember I needed to patch up the build files pretty extensively, but don't think I ever fully succeeded
13:40:34 <ertesx> mizu_no_oto_work: it does give you subtyping…  abstract sub-classes translate to types with the base class being a field
13:41:12 <ertesx> johnw: there is no need to exclude sums
13:41:40 <ertesx> ARM9: i don't know your application, but my first instinct would be: don't use type classes =)
13:42:40 <rrradical> agrue: ah bummer... I actually got pretty far with GHC 7.10.3, but then in the end it tries to link with the llvm library and there's no ARM64 slice in there. not sure why it's not included in llvm 3.5.2, but it's not. so then I moved up to GHC 8 and got different problems :\
13:42:45 <mizu_no_oto_work> ARM9: typeclasses are fundamentally different from OO classes.  Typeclasses separate data from implementation.
13:42:53 <ertesx> ARM9: as a general rule of thumb you need type classes when you: 1. have at least two instances, 2. have at least one generic function implemented in terms of that class
13:43:02 <ARM9> that's what I'm trying to do, separate the data from the implementation
13:43:51 <ARM9> yes, I have at least 2 instances, and defining my protocol in one place would reduce duplication immensely (and as a minor aside for now, help a lot with cache locality in the long run)
13:44:05 * hackagebot ltext 0.1.2.1 - Parameterized file evaluator  https://hackage.haskell.org/package/ltext-0.1.2.1 (athanclark)
13:44:14 <mizu_no_oto_work> ARM9: what I mean is, OO classes bundle data and implementation together, into the same record.  Typeclasses separate the implementation out into a separate record that's *just* for implementation.
13:44:19 <ARM9> the problem is said "protocol" has at least 2 versions, one which is a superset of the other
13:44:57 <mizu_no_oto_work> This means that, for example, it's easy to provide conditional implementation of typeclasses, like saying that Lists are orderable if their elements are orderable.
13:45:09 <ertesx> ARM9: that may qualify as a use case for type classes
13:45:10 <mizu_no_oto_work> which isn't something most OO languages let you express
13:45:51 <ertesx> ARM9: there is one very strong indication that you can make use of a type class:
13:46:57 <ertesx> you have properly abstracted out similar-looking functions (like going from sum and product to foldl'), and what you pass to that abstraction follows from a type used
13:47:38 <agrue> rrradical: yes, that sounds familiar (different problems building different versions of GHC) ;)
13:47:44 <josuf107> ertesx: what's your policy on when to use a typeclass rather than just a type that has all the functions
13:47:59 <agrue> my disappointed conclusion was that GHC cross-compiler support on OS X is pretty bad
13:48:03 <mizu_no_oto_work> ARM9: What kind of protocol do you have?
13:48:23 <agrue> there are all sorts of special cases in the build system for OS X that don't seem to have cross-compilation in mind
13:48:41 <ertesx> josuf107: the above
13:49:47 <agrue> my guess is that not many people try to do it
13:49:49 <josuf107> that the right implementation depends only on the type
13:51:57 <josuf107> :t unfoldr
13:51:59 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:52:11 <josuf107> I wrote a monadic version of that because I needed it
13:52:24 <josuf107> is there an equivalent somewhere in a library?
13:53:19 <ertesx> josuf107: you could just use a streaming abstraction
13:53:37 <ertesx> a monadic unfoldr would be rather inefficient
13:54:05 * hackagebot feed-gipeda 0.1.0.4 - Simple project template from stack  https://hackage.haskell.org/package/feed-gipeda-0.1.0.4 (sgraf812)
13:55:03 <divVerent> Why not (b -> (Maybe a, Maybe b)) -> b -> [a]? You can then either output and continue, output and stop, not output and continue, not output and stop
13:56:00 <divVerent> but basically it indeed looks like a mix of Writer monad and "early return"
13:59:48 <ertesx> a "monadic unfoldr" sounds more like this:  (s -> m (Maybe (a, s))) -> s -> m [a]
14:02:21 <josuf107> yes (s -> m (Maybe (a, s))) -> s -> m [a] is what I wrote
14:03:35 <ertesx> josuf107: you can have an efficient variant of that by simply using a stream abstraction like pipes
14:05:08 <ARM9> mizu_no_oto_work, it's a virtual machine, where the base version contains some functionality that later versions inherit, in addition to new functionality
14:06:28 <texasmynsted> which intellij plugin do you use, if you use intellij?  Intellij just updated and the one I was using is not longer useable.  Just wondering if it is time to try a different one.
14:06:52 <bernalex> texasmynsted: sounds like intellij is telling you to try emacs.
14:07:11 <maerwald> bernalex: next time you tell people to use nix when they have cabal problems? :P
14:07:47 <bernalex> thankfully, I don't really see a lot of people having cabal problems lately. but, depending on the problem, nix might actually be a good answer.
14:11:04 <texasmynsted> lol
14:11:32 <texasmynsted> yeah I used emacs for like 15 years
14:12:06 <texasmynsted> It is fine, it just started taking more effort to keep it up-to-date and the way I wanted than my OS
14:13:30 <maerwald> texasmynsted: the haskell wiki leads me to this https://rikvdkleij.github.io/intellij-haskell/
14:14:24 <maerwald> yeah, emacs is a great time sink
14:17:34 <anemecek> long time listener, first time caller. i wrote a blog post and i'm interested in your guys' opinion https://medium.com/@atnemecek/the-scan-function-is-the-core-of-all-programming-5f5085df76e7#.wr0ozs8eg
14:17:45 <texasmynsted> yep that is the one I use that is now not compatible
14:18:12 <maerwald> texasmynsted: https://github.com/rikvdkleij/intellij-haskell/issues/44 ?
14:18:25 <josuf107> ertesx: Yeah that turned out not to be what I wanted to do. I'm using pipes but I wanted to buffer my producer and pipes-async isn't in the stack lts I'm using, nor does it play nicely with my other deps
14:18:48 * texasmynsted facepalm
14:18:50 <texasmynsted> thank you
14:19:08 <josuf107> ertesx: but I just made a thread that writes to a bounded queue and a producer that reads from that queue
14:20:44 <ertesx> josuf107: yeah, stream abstractions only give you a coroutine structure…  if you need concurrency, you should use concurrency =)
14:33:14 <josuf107> ertesx: does pipes-async break the pipes abstraction then? It combines a consumer and a producer into a pipe that runs them in separate threads with bounded queue between them,
14:34:44 <ertesx> josuf107: i've never used pipes-async
14:36:01 <josuf107> ertesx: yeah it has surprisingly few downloads for what seems like a really handy functionality
14:36:30 <ertesx> josuf107: maybe…  i just never needed it
14:37:02 <ertesx> the use cases for stream abstractions and concurrency don't really overlap for me
14:38:29 <josuf107> I guess it's only relevant if you have a producer and a consumer that are both kind of slow, so that there's time for the producer to actually buffer values and it takes long enough to produce them that it's worth buffering
14:40:16 <josuf107> but pipes async makes it super easy, you just replace >-> with >&> and it will insert a buffer into your pipeline there
14:53:51 <tenniscp25> Why isn't MinLen a functor?
14:56:49 <shachaf> What is MinLen?
14:58:33 <tenniscp25> Data.MinLen from mono-traversable
14:58:41 <tenniscp25> but never mind. i think i got it.
15:09:09 * hackagebot pipes-network 0.6.4.1 - Use network sockets together with the pipes library.  https://hackage.haskell.org/package/pipes-network-0.6.4.1 (RenzoCarbonara)
15:10:55 <Jackal__> Hello
15:11:18 <Jackal__> How are you
15:12:35 <byorgey> hi Jackal__, welcome
15:24:10 * hackagebot diagrams-postscript 1.3.0.7 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.7 (BrentYorgey)
15:49:11 * hackagebot hw-prim 0.0.3.3 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.3 (haskellworks)
15:53:59 <rotty> I'm having an issue understanding a type system error regarding typeclasses; the example is fairly short (5 lines, excluding type declarations and empty lines). would be cool if someone could have a look:
15:54:08 <rotty> https://gist.github.com/rotty/2742b5c058898527d607cea27bb61c71
15:55:09 <Welkin> rotty: in your function you are applying `f` to somthing of type IPV4 a
15:55:18 <glguy> rotty: The type "(Addr a) => (a -> b) -> IP -> b" suggests that ipMap should work for all Addr types
15:55:22 <Welkin> if you mean to apply it to `a`, then you need to fmap over it
15:55:31 <glguy> and that the user gets to pick which type 'a' is
15:56:16 <Welkin> oh yeah, ignore what I said
15:56:17 <Welkin> haha
15:56:37 <glguy> rotty: So you don't get to assume that 'a' was IPv4 like this
15:57:31 <rotty> I thought that a and IPv4 would match up, because IPv4 is an instance of Addr
15:57:52 <glguy> I could write another instance Addr IPv6
15:58:00 <rotty> and "a" is restricted by the constraint "Addr a"
15:58:02 <glguy> and use ipMap :: (IPv6 -> b) -> IP -> b
15:58:10 <glguy> and ipMap would have to be able to deal with that
15:59:51 <glguy> All you get to assume is that whatever 'a' happens to be that it's an instance of Addr
16:00:01 <glguy> you don't get to pick which 'a' that is when implementing ipMap
16:02:35 <rotty> ah, so the pattern match is the issue?
16:02:59 <glguy> The issue is that you applied f to an IPv4, but f might not want an IPv4 argument
16:03:52 <rotty> but IPv4 is an instance of Addr, and the first argument of f is constrained to be an instance of Addr
16:04:09 <rotty> (by the type signature of ipMap)
16:04:23 <rotty> but probably I'm being dense about some aspekt here
16:04:26 <glguy> or it could be another instance of ADdr
16:04:27 <kadoban> rotty: Right, but the caller of ipMap should be able to choose what Addr instance, you don't get to choose for them. And you're choosing IPv4.
16:04:41 <glguy> Using an extension you can write this type for ipMap: ipMap :: (forall a. Addr a => (a -> b)) -> IP -> b
16:04:48 <glguy> That's called RankNTypes
16:05:10 <glguy> But it's more likely that you can structure the code better once you understand what's going on
16:05:25 <glguy> rather than venturing down that path
16:10:11 <kadoban> rotty: What's this function supposed to do? It seems ... pretty questionable at the moment.
16:10:25 <rotty> glguy: my original problem was eliminating a bit of redundancy out of this code: <https://r0tty.org/git/haskell/dn42-hrtk/tree/src/DN42Hrtk/Zone.hs?h=wip/rdispatch&id=7457d78377fa017406de77927da4829c6eb55a74>
16:11:15 <rotty> specifically, abstracting the following application: "ipDispatch f f"
16:11:46 <rotty> which, by itself, works, but I'd like to capture that pattern by a separate function
16:12:48 <rotty> erm, s/glguy/kadoban/ -- sorry
16:13:47 <kadoban> Hmm
16:14:34 <rotty> kadoban: if you have a look at the code, that's the only way ipDispatch is used, and I'd like to remove the duplication in the arguments
16:15:41 <kadoban> I don't think you can, though maybe I'm missing something.
16:16:40 <glguy> rotty: You can use the RankNType extension like I show above to make that work as written
16:16:57 <rotty> well, i'll put it aside for now -- maybe there will be some enlightement down the road. thanks for your support guys/gals, anyway!
16:19:35 <nitrix> If I want to provide a Monad that allows specific I/O but not all of them; is my only solution a newtype wrapper of some monad transformer over IO, and to implement a given set of effectful operations by lifting them to that type?
16:20:11 <ReinH> nitrix: You can use a free monad
16:20:28 <ReinH> where the free monad captures the restricted IO actions
16:20:43 <ReinH> @hackage operational
16:20:43 <lambdabot> http://hackage.haskell.org/package/operational
16:20:47 <ReinH> is a nice approach
16:21:02 <nitrix> ReinH: Checking. I'll come back with questions.
16:21:34 <ReinH> Here's an example from the free package https://github.com/ekmett/free/blob/master/examples/Teletype.lhs
16:21:44 <nitrix> Heinrich Apfelmus, why am I not surprised :P
16:21:47 <ReinH> of a basic free monad that evaluates to IO
16:23:59 <maerwald> freer looks less cryptic
16:24:45 <nitrix> So, the free monad requirs GADTs ?
16:25:00 <maerwald> https://gitlab.com/queertypes/freer#example-teletype-dsl
16:25:12 <ReinH> For non-trivial stuff, usually
16:27:07 <jle`> operational is still one of my favorite examples of gadt usage
16:28:15 <nitrix> Am I wrong that this wouldn't be possible without GADTs ?
16:28:23 <nitrix> Or potentially, really awkward?
16:28:47 <shachaf> Operational is just Free . Coyoneda
16:31:12 <cloudhead> can someone explain why hlint recommends to swap my liftM for an fmap?
16:31:27 <hpc> fmap is less specific
16:31:31 <maerwald> cloudhead: just ignore it if liftM is easier to understand in the context
16:31:35 <maerwald> hlint is full of useless stuff
16:31:39 <hpc> but yeah
16:31:43 <cloudhead> hmm
16:31:51 <cloudhead> ok
16:31:52 <jle`> i don't think there's any case where i'd use liftM over fmap
16:32:05 <jle`> i guess there might be specific cases
16:32:05 <cloudhead> I guess in that case there wouldn't be a case where hlint would be ok with a liftM?
16:32:24 <jle`> well, there's the case of defining a Functor instance in terms of the Monad instance
16:32:31 <ReinH> nitrix: Any functor can be made a free monad, that's what free means. It's just that encoding interesting operations in the functor generally requires GADTs.
16:32:38 <maerwald> hlint also tries to randomly suggest pointfree code while it's not even the same
16:32:45 <cloudhead> haha
16:32:46 <jle`> but i can't imagine liftM improving readability
16:32:53 <jle`> hlint is pretty sily sometimes though, yeah
16:32:58 <jle`> silly, sly
16:33:11 <maerwald> I don't even know why I have hlint enabled, tbh
16:33:17 <cloudhead> jle`: I feel weird using fmap for monadic lifts
16:33:22 <ReinH> At this point there's no reason to prefer liftM over fmap.
16:33:23 <jle`> what is a monadic lift
16:33:27 <Welkin> I just use haskell-mode without anything fancy
16:33:36 <maerwald> maybe it was because of the "unused imports" thing? that's useful
16:33:44 <ReinH> cloudhead: well, it isn't a monadic lift. It's an fmap by the wrong name.
16:33:45 <hpc> ghc warns about that itself now
16:33:47 <hpc> iirc
16:33:49 <maerwald> ah
16:33:50 * geekosaur pretty much dumped liftM for fmap years before AMP actually got onto the radar
16:33:53 <cloudhead> jle`: I mean when lifting to a monad
16:33:58 <hpc> i know it warns for overlapping imports
16:34:09 <hpc> or maybe just Control.Applicative from the AMP
16:34:13 <Welkin> liftM is like the cousin you always forget about
16:34:18 <cloudhead> haha
16:34:21 <hpc> but i have seen importy warnings before
16:34:22 <Welkin> I forgot it existed until you brought it up
16:34:28 <jle`> cloudhead: you feel awkward using fmap for things that are Monad instances?
16:34:35 <cloudhead> yeah exactly
16:34:36 <ReinH> At this point liftM is just a misspelled fmap.
16:34:37 <maerwald> I also tend to overuse fmap, but I still find it wrong to complain about sth like that linter-wise
16:34:38 <geekosaur> on the grounds that liftM was just reconstructing fmap from >>= because there wasn't a Functor prerequisite in place
16:34:54 <Welkin> isn't it because haskell had monads before functors?
16:34:56 <maerwald> assuming you always want the most general form of stuff is simply incorrect
16:35:00 <maerwald> there is also readability
16:35:00 <Welkin> so there was no fmap, only lift<
16:35:03 <cloudhead> jle`: I guess because other monadic functions are suffixed with 'M'
16:35:08 <Welkin> liftM*
16:35:15 <cloudhead> ie mapM, forM etc
16:35:24 <cloudhead> when I see fmap, I don't think monad
16:35:35 <Welkin> well, all monads are functors
16:35:37 <jle`> maybe becuase you're not supposed to :o
16:35:47 <jle`> it's liberating to be able to think of IO, List, Map, etc. as functors
16:35:55 <jle`> er, maybe Map didn't belong there
16:36:06 <ReinH> cloudhead: Stop thinking of it as a "monadic function". Monads are Functors now and monads have always been functors.
16:36:07 <maerwald> still waiting for a proper linter that can be easily configured
16:36:17 <jle`> thinking of IO as a functor helps you use IO better
16:36:26 <geekosaur> worth noting that outside of Haskell, monads are defined in terms of fmap and join, not bind
16:36:28 <Welkin> I fmap all the things
16:36:30 <martinium> I've read about haskell's GC "Stopping the World" with long pauses. Is there any work underway with GHC to lower this substantially?
16:36:38 <maerwald> geekosaur: which I find more natural
16:36:46 <cloudhead> jle`: can you elaborate?
16:36:57 <cloudhead> ReinH: yeah, I think it's just unlearning I need to do
16:37:01 <jle`> monomorphic functions can help with readability and type checking in a lot of cases, especially if they're more recognized.  i still use 'map' over fmap, '(.)' over fmap, etc.
16:37:06 <shachaf> You don't need a GADT for Operational of a Functor.
16:37:24 <shachaf> You only need that sort of thing in the case that it isn't a Functor.
16:37:58 <cloudhead> jle`: you wouldn't consider than an argument for liftM over fmap though, since liftM isn't monomorphic, right?
16:38:01 <jle`> cloudhead: what does fmap for IO is like a program transformation that transforms the output.  a lot of normal things you do with IO every day is pretty much just fmap
16:38:07 <maerwald> anyway, let's agree hlint is just an opinionated unflexible linter, that's not meant to be easily configured
16:38:08 <jle`> treating IO as as functor
16:38:13 <jle`> like you'd treat lists, etc.
16:38:25 <cloudhead> right, I think I see
16:38:41 <Welkin> cloudhead: are you going to start a song and dance for us now?
16:38:43 <jle`> cloudhead: yeah, liftM doesn't really help with typechecking, and it also is probably less familiar to most people than fmap
16:38:59 * Welkin is imagining this entire conversation as a musical happening on stage
16:38:59 <jle`> cloudhead: there's also the fact that liftM for some types is less efficient than fmap
16:38:59 <cloudhead> Welkin: ?
16:39:11 <jle`> (.)/map etc. are identical to fmap, performance wise
16:39:18 <jle`> but liftM for some types can be less performant than fmap
16:39:29 <jle`> so like, why bother
16:39:33 * geekosaur thimks immediately of Hamilton --- and then of actors upstaging themselves >.>
16:39:37 <maerwald> jle`: -O2 should do that! if not? make it a bug report
16:40:02 <jle`> maerwald: it works for a lot of types, but not for some specific types, right?
16:40:08 <cloudhead> jle`: cool. guess I should take the hint from hlint then in this case :)
16:40:08 <jle`> unless there's a specific rewrite rule in GHC or something
16:40:16 <hpc> you know what they say, in this economy it's hard for an actor to lift themselves up by their own stage
16:40:28 <ski> if i already have a `Monad m' constraint for the relevant `m', then i'm more likely to use `liftM' than `fmap'
16:40:29 <maerwald> jle`: I don't know. I am lazy and want the compiler to think about such crap.
16:41:08 <jle`> i can construct a contrived type where liftM is always faster than fmap without a straight rewrite rule optimization
16:41:10 <kadoban> ski: Why? For older GHC, or?
16:41:20 <koz_> ski: I use fmap because it's easier to type.
16:41:30 <ski> kadoban : for specificity. like `map' instead of `fmap', for lists
16:41:31 <jle`> s/always faster/always slower
16:41:36 <koz_> (and in most cases, I use the superman operator anyway)
16:41:52 <cloudhead> ski: that was my thinking (specificity)
16:42:12 <Welkin> :t (<$>) . (<$>)
16:42:13 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:42:15 <Welkin> :D
16:42:19 <maerwald> actually, I don't use map :P ...makes it easier when I switch the data structure
16:42:21 <jle`> map/(.) help with typechecking and are familiar idioms, too, though
16:42:21 <ReinH> Welkin: pls, fmap fmap fmap
16:42:42 <jle`> although at this point i'm making post-hoc justifications
16:43:05 <ReinH> jle`: s/this point/all points/ s/i'm/we're/
16:43:14 <ski> (e.g. if i already have a `Functor f' in scope, where `Monad f' is not known to be the case, i think it can help readability to use `fmap' for that, but `liftM' for the `Monad m')
16:43:33 <Welkin> I still wonder why so many people use that regex search-and-replace syntax on irc
16:43:36 <Welkin> o.o
16:43:39 <Welkin> it is very hard to read
16:43:59 <jle`> they forget that they aren't in vim/sed
16:44:03 <jle`>  /vi
16:44:04 <ReinH> you must not use sed very often
16:44:10 <ReinH> yes, or vim
16:44:14 <Welkin> emacs :D
16:44:21 <Iceland_jack> ed
16:44:28 <maerwald> ReinH: yeah, it's mostly incorrect sed syntax
16:44:37 <ReinH> Iceland_jack: hey, I've actually used ed in anger.
16:44:51 <Iceland_jack> Is there any other way? :)
16:44:59 <ReinH> lmao
16:45:33 <jle`> also i don't know anyone who actually uses vim that way
16:45:42 <ReinH> jle`: I use a lot of ex commands in vim.
16:45:48 <jle`> "i typed that line wrong?  better :s/foo/bar"
16:45:57 <jle`> usually i go back and enter insert mode
16:45:59 <jle`> or aw
16:46:01 <jle`> *cw
16:46:12 <Sonolin> I use :%s on a regular basis
16:46:18 <Sonolin> but :s is quite rare
16:46:30 <jle`> i'd use it as a find-and-replace, but not to fix typos
16:46:35 <jle`> from the last line i wrote, heh
16:46:56 <jle`> i can imagine it being useful if we were back in the day when edits didn't show up until after you exited insert mode
16:47:04 <ReinH> Don't forget :'<,'>s
16:47:33 <cloudhead> s/..// syntax also worked in HipChat which a bunch of companies use(d)
16:47:46 <maerwald> works in gitter too
16:47:50 <wamaral> slack too
16:48:06 <maerwald> but there is no haskell gitter channel afaik
16:48:11 <cloudhead> oh never tried it there
16:48:15 <ReinH> I don't think most vim users actually realize that you can use the commands with manually entered ranges, e.g., :10,20s/foo/bar
16:48:18 <cloudhead> there's a slack channel
16:48:22 * geekosaur thinking might be shorthand of !!:s/...
16:48:34 <geekosaur> since the real shorthand for that confuses even more people >.>
16:48:41 <geekosaur> (csh-isms)
16:49:06 <geekosaur> althought he !! form works in bash if you haven't disabled histchars
16:49:06 <ReinH> geekosaur: Hey, at least I don't use ^foo^bar, basically no one knows that one these days
16:49:13 * hackagebot cassava-conduit 0.3.2 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.2 (domdere)
16:49:15 <wamaral> just yesterday I had to use :g/foo/s/bar/baz/
16:49:19 <geekosaur> that was what I was hinting at :)
16:49:56 <glguy> wamaral: You find yourself using a lot of foo bar and baz in your projects?
16:50:18 <Welkin> I keep forgetting
16:50:27 <Welkin> I should write an entire program using only chinese
16:50:47 <Welkin> define synonyms for library functions too
16:51:06 <maerwald> too complicated... write a haskell DSL that does it for you
16:51:09 <geekosaur> ...aren't uppercase ideographs difficult?
16:51:11 <Welkin> that will be fun with the IME giving me the wrong characters all the time
16:51:33 <wamaral> glguy: whenever I can
16:52:36 <ReinH> Welkin: I once made a pig latin fork of Rails.
16:52:42 <ReinH> And gave a talk about job security.
16:54:41 <mgsloan> I've always wanted a PL where scope errors are comments
16:54:50 <mgsloan> And if it doesn't typecheck, it tries adding parens till it does XD
16:55:07 <kadoban> lol
16:55:08 <cloudhead> martinium: last I checked, there is no work in something like a real-time GC like erlang has, which is to my knowledge the only thing you can do to substantially improve it
16:56:03 <mgsloan> In this PL, the following would all be equivalent: map (+1) [1]; (+1) map [1]; etc
16:56:03 <ReinH> cloudhead: real-time GC for functional languages is a reasonably warm topic of research
16:56:25 <cloudhead> ReinH: yeah, I just don't think anyone is working on that for haskell
16:56:49 <ReinH> Well, you don't need to work on it specifically for Haskell.
16:57:32 <cloudhead> martinium was asking if anyone was working on improving the gc substantially, that's what I'm referring to
16:57:55 <martinium> cloudhead oh okay. thx
16:58:23 <Welkin> > let (加人) = (:); (加) = (+); 草木 啊 不 = 啊 `加人` 草木 不 (啊 `加` 不) in 草木 0 1
16:58:25 <cloudhead> martinium: there are "solutions" to gc problems though
16:58:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:58:33 <cloudhead> increasing available memory for one can help
16:58:47 <cloudhead> and the profiling tools haskell has are pretty solid
16:58:59 <jle`> i'm just happy my terminal font rendered that properly
16:59:06 <ReinH> cloudhead, martinium: improvements could be made to Haskell's current GC short of making it an RTGC
16:59:12 <Xnuk> 入人
16:59:33 <ReinH> e.g., https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Immix
16:59:59 <cloudhead> yeah for sure, I just don't know if those will be big improvements
17:00:54 <martinium> nice
17:01:17 <martinium> this language is very nice to code in and I like the little I've learned and seen so far.
17:01:37 <jle`> me too! :D
17:01:39 <martinium> only thing that was bothering me was that the GC causes issues for real-time applications
17:01:46 <ReinH> GHC's GC is actually quite good already.
17:02:11 <ReinH> martinium: Haskell is not a good fit for hard real time applications
17:02:27 <martinium> ReinH due to the GC or so I have read
17:02:35 <Welkin> martinium: you can use haskell as a DSL to compile to many different things though
17:03:10 <ReinH> For soft real time, you can do pretty well if you are quite careful
17:04:20 <ReinH> Frag was a successful soft-realtime application of Haskell over a decade ago
17:04:29 <ReinH> before the modern changes to GC
17:04:42 <ReinH> And IIRC it wasn't even heavily optimized
17:04:52 <hpc> imo GHC's GC is the best production GC in the world
17:04:59 <hpc> close second in some ways is the JVM GC
17:05:06 <cloudhead> :o
17:05:41 <ReinH> hpc: YEah ,it's probably between GHC and hotspot
17:05:47 <cloudhead> hpc: any particular things that make it so good? Haven't heard that high praise for it before
17:06:09 <nitrix> The GC is extremely good, even with all the challenges we throw at it, like stable pointers.
17:06:35 <ReinH> nitrix: then again, immutable garbage is easier to clean
17:06:57 <cloudhead> there's much more of it though
17:07:03 <hpc> cloudhead: it's designed to exploit a lot of quirks of the execution model
17:07:13 <ReinH> cloudhead: but most of it is short lived, so generation GC is quite effective
17:07:14 <cloudhead> the Go GC for ex has a pretty easy task because the stdlib is designed to create minimal garbage
17:07:19 <ReinH> *generational
17:07:38 <cloudhead> I see
17:07:44 <hpc> ghc allocates a far higher portion of data manipulation than you would do in something like C
17:07:54 <cloudhead> by execution model you mean purity/laziness etc?
17:07:59 <hpc> where you mutate a blob of heap memory or whateve
17:08:02 <ReinH> cloudhead: https://www.quora.com/How-does-garbage-collection-work-in-Haskell
17:08:14 <hpc> but most of it is short-lived, so what ReinH said
17:08:43 <hpc> the generational aspect is that ghc allocated block-aligned chunks of "nursery" memory
17:08:47 <cloudhead> cool, will check that out
17:08:48 <hpc> which it fills from start to end with data
17:08:55 <hpc> allocating that way is just incrementing a pointer
17:09:04 <nitrix> cloudhead: One example that's counter intuitive is, the more garbage there is, the faster the collection will be, since the only thing the GC needs to check is the nurture area (it's generational).
17:09:19 <hpc> when the pointer reaches the end of the block, that block is garbage collected and whatever survives moves out of the nursery and into general memory
17:09:23 <ReinH> cloudhead: Morlow, who wrote most of the GC, links to the papers that he also wrote about the GC
17:09:27 <ReinH> *Marlow
17:09:47 <cloudhead> nice
17:10:01 <hpc> the result is if you look at profiler output of some code, you'll find ridiculous numbers like gigs of memory allocated per second
17:10:07 <ReinH> Also I interviewed him for the podcast a while back, although we only talked about GHC internals briefly
17:10:21 <ReinH> http://www.haskellcast.com/episode/004-simon-marlow-on-parallelism-and-concurrency/
17:10:33 <ReinH> oh that reminds me, need to schedule the next one
17:10:47 <hpc> there are some places where the JVM comes up ahead, like in keeping multiple threads running concurrently with a GC pass
17:11:12 <ReinH> hpc: thread-local heaps might help with that
17:11:23 <hpc> but ghc has minimized those cases fairly well and it's close to a totally non-blocking GC
17:11:29 <cloudhead> really interesting, thanks
17:11:37 <hpc> or at least a non-global-blocking GC
17:11:39 <ReinH> "mostly-concurrent", as they say
17:11:49 <hpc> heh, that's a nice term
17:12:05 <ReinH> :)
17:12:08 <ReinH> I think I stole it from Simon
17:12:09 <hpc> contrast with languages like python, which have a global interpreter lock on almost any operation
17:12:14 <hpc> garbage collection, foreign calls
17:12:14 <cloudhead> ReinH: oh hah, I think I listened to that a few years ago
17:13:40 <hpc> iirc there's some subtle stuff in ghc that exploits the typical uses of thunks, but i don't remember enough to actually explain it
17:14:33 <hpc> it was something weird like being able to statically determine when it's safe to convert them to mutations or something
17:15:34 <martinium> I saw some amazing stats for yesod and warp
17:15:52 <ReinH> IO on GHC is prettttttty fast
17:16:01 <hpc> was just about to mention that
17:16:07 <Welkin> warp is as fast as nginx
17:16:07 <martinium> old but it blew away all other servers and web frameworks
17:16:19 <hpc> it's not GC-related per se, but if an IO call can be made asynchronous, it is
17:16:25 <hpc> even the stuff that's ultimately synchronous
17:16:31 <ReinH> Why it's so fast: ttp://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
17:16:31 <martinium> rps was out of this world
17:16:43 <ReinH> Although actually those benchmarks predate the new IO subsystem iirc
17:16:44 <alercah> martinium: other Haskell frameworks or all frameworks in general?
17:17:06 <hpc> there's some really weird logic behind it, but the end result is that the right kind of (async run X, then wait for it to be done) is faster than (run X)
17:17:07 <ReinH> The new IO subsystem is so fast it exposed a kqueue bug in the linux kernel.
17:17:10 <martinium> all the popular ones from other languages
17:17:11 <Welkin> alercah: compared to other popular ones
17:17:22 <alercah> cool
17:17:23 <Welkin> yeah, but most languages seem to have really crappy web servers
17:17:27 <alercah> yeah
17:17:34 <Welkin> so... people think that node is the best
17:17:40 <Welkin> because it is better than crap
17:17:48 <Welkin> but it's at the bottom compared to better ones
17:17:49 <ReinH> That's my favorite bit of GHC trivia: it's so fast the linux kernel couldn't keep up.
17:18:00 <hpc> ReinH: i need to remember that one
17:18:01 <martinium> most use interpreted languages running on old tech like apache and better with nginx
17:18:15 <alercah> yeah, and the design is really solid
17:18:18 <martinium> but the yesod/warp numbers were off the hook
17:18:21 * hpc quite likes apache
17:18:27 <ReinH> GHc was like "I'm ready for things" and the kernel was like "Ok I have things no wait I lied sorry I have no things"
17:18:29 <ReinH> true story
17:18:32 <hpc> it's a fat monster, but a familiar one
17:18:33 <martinium> apache is legit
17:18:38 <martinium> tried and true
17:18:49 <ertesx> martinium: tried perhaps
17:18:50 <hpc> and i trust the apache process to produce good code
17:19:29 <hpc> (over a sufficiently long timescale, it can be rough for a project to fully get absorbed by the apache way of doing things)
17:19:30 <alercah> I don'
17:19:33 <alercah> t*don't
17:19:34 <alercah> *don't
17:19:45 <ertesx> apache is one of the most terrible pieces of engineering i know
17:19:51 <alercah> ^
17:19:51 <ReinH> hpc: apache has eaten most of the cool new open source systems work
17:19:55 <ReinH> I'm pretty ok with this
17:20:23 <ReinH> Want a fancy new distributed key value whatever? Ask Apache.
17:20:35 <ertesx> i'm almost showing it in a better light that i intended to by calling it "engineering"
17:20:42 <ertesx> s/that/than/
17:20:57 <cloudhead> ReinH: since when has MIO been part of ghc?
17:21:07 <ReinH> 7.something iirc
17:21:49 <hpc> ertesx: how much of that is apache itself and how much of that is the server model it follows?
17:22:04 <ertesx> hpc: what?
17:22:22 <cloudhead> hm a couple years then
17:22:34 <hpc> ie, it not being the purpose-built server model that something haskelly would follow
17:22:44 <hpc> and instead being cgi / fastcgi / mod_foo
17:23:16 <ertesx> hpc: apache actually has multiple "server models"…  they call them "MPMs"
17:23:20 <ertesx> and all of them are terrible
17:23:52 <ertesx> the binding to the application language is a different matter
17:25:01 <cloudhead> I think apache server is probably the best thing under the apache umbrella
17:25:50 <ertesx> is it?  i had some success with apache cordova in the past
17:26:15 * hpc swears by spamassassin
17:26:21 <cloudhead> ah yes, didn't realise they were apache :)
17:26:45 <ertesx> i don't think apache projects are bad…  i think the apache web server is bad
17:26:47 <ertesx> terribly bad
17:27:14 <cloudhead> I knew it as PhoneGap
17:27:31 <cloudhead> well, there's Zookeeper which is pretty bad too
17:27:49 <cloudhead> and Hadoop is not great either
17:28:14 <cloudhead> I guess I haven't had to use apache server since nginx appeared
17:29:02 <Welkin> haha
17:30:21 <avalokite> ReinH: I thank you for conducting these interviews. Never have I heard anyone talk practically of Haskell, and here lies a new experience. :)
17:31:50 <mniip> is there an unordered pair datatype?
17:32:07 <mniip> somewhere close to the standard libraries
17:32:31 <crough> mnipp: I don't think so, outside of `Either (a,b) (b,a)`
17:33:47 <mniip> I fail to see how that either makes any sense
17:34:17 <jle`> what sort of operations would be supported on an unordered (heterogeneous) pair datatype?
17:34:43 <mniip> construction, field access, eq, ord
17:35:15 <mniip> I guess you can get away with just a wrapper around (,)
17:35:22 <jle`> (,) / swap
17:35:26 <jle`> :p
17:35:31 <mniip> pair x y = (min x y, max x y)
17:35:32 <jle`> where are my quotient types
17:35:37 <mniip> lesser = fst; bigger = snd
17:35:41 <ertesx> mniip: i don't think such a type is possible without type-level hackery
17:35:51 <ertesx> mniip: -XCombinatorialSpecies
17:36:02 <jle`> (,) `quot` swap should work
17:36:15 <jle`> mniip: it looks like your pairs are homogeneous, so that makes a bit more sense
17:36:24 <jle`> otherwise lesser/bigger would have weird types
17:36:32 <mniip> ah indeed
17:36:37 <mniip> that's an important aspect
17:37:43 <EvanR> if its unordered then you cant operate on either one alone
17:37:51 <EvanR> you have to operate on both at once
17:37:57 <jle`> the only thing i can really imagine is the same as a tuple but an Eq/Ord instance that respects swappability
17:38:04 <EvanR> swapping doesnt do anything
17:38:15 <jle`> s/tuple/vector
17:38:42 <mniip> hmm yes that sounds better
17:45:38 <sm> ReinH: yay next one. Going to talk to simon marlow some more ?
17:46:43 <sm> you could go into GHC internals in more detail, and get his ideas on fixing the dev process
17:56:57 <Squarism> does Eq for Set care about order? 
17:58:18 <alercah> Squarism: Set is an ordered container
17:58:51 <Squarism> Im thinking java here i confess. Isnt there a Set implementation that doesnt care about order? 
17:59:42 <Squarism> or some operator that check that 2 sets have the same elements
18:00:38 <mniip> does anyone else sort their imports alphabetically :o
18:00:45 <nitrix> mniip: I do.
18:00:59 <mniip> hmm lexicographically that is
18:01:00 <Welkin> I just space them all nicely
18:01:12 <nitrix> mniip: I also divide them into two blocks. Dependencies on top, then the import that belongs to the application below.
18:01:14 <Welkin> are haskell programmers OCD?
18:01:21 <mniip> hmm
18:01:22 <Welkin> everything must be aligned
18:01:44 <mniip> I don't think I've actually ever written a multi-module *program* in haskell :o
18:01:59 <Welkin> what does that mean?
18:02:19 <nitrix> mniip: e.g. http://lpaste.net/170887
18:02:36 <mniip> Welkin, only libraries
18:02:38 <Welkin> oh yeah nitrix 
18:02:41 <Welkin> I do that too
18:02:56 <ertesx> Squarism: technically all of them care about order in one way or another
18:03:08 <Welkin> but I will also group them logically sometimes, like all the stuff for monads/applicatives, then all the modules for lists
18:03:24 <ertesx> Squarism: but not necessarily the Ord order…  for example HashSet orders by the hash
18:03:39 <nitrix> Welkin: The only one that gets its own block sometimes is Debug.Trace for me.
18:03:40 <ertesx> Squarism: (it uses a radix tree instead of a regular binary search tree)
18:03:47 <nitrix> Welkin: To visually stand out so I know to remove it.
18:04:07 <Squarism> ertesx, ok... so that would yeild equality for any 2 sets containing same elements
18:04:09 <Squarism> ?
18:04:32 <ertesx> Squarism: Set does that already
18:04:44 <ertesx> > S.fromList [1,2,3] == S.fromList [3,2,1]
18:04:45 <lambdabot>  True
18:05:24 <Squarism> i created two sets using fromDistinctAscList ... then [Legio9,Legio7,Navis1,Legio14,Legio11] != [Legio7,Legio9,Legio11,Legio14,Navis1] 
18:06:06 <Squarism> elems dont have an Ord instanance though
18:06:32 <Squarism> elements
18:06:41 <nitrix> Squarism: You're breaking the contract of fromDistinctAscList.
18:06:56 <nitrix> You're supposed to supply it a list of elements already ascending.
18:07:21 <Squarism> i probebly do. Its just its not a very important operation.. just wanna se that 2 lists have the same elements.. and i thought Set was the route there 
18:07:22 <nitrix> It's a function available as an optimization if you happen to know the list is already sorted.
18:07:59 <Squarism> basically.. just want the simplest way to check that
18:08:08 <ertesx> Squarism: don't use Set like that…  you're basically going for trouble
18:08:32 <Squarism> ok.. i just did what i did in java (and scala)
18:08:33 <ertesx> s/going/asking/
18:08:51 <ertesx> Squarism: what is it that you want to check?
18:09:11 <ertesx> just that two collections are equal?
18:09:21 <Squarism> that two lists contain the exact same elements - regardless of order
18:09:42 <nitrix> > S.fromList [1,2,3,4,7] == S.fromList [1,3,7,2,4]
18:09:43 <lambdabot>  True
18:09:46 <nitrix> > S.fromDistinctAscList [1,3,7,2,4] == S.fromList [1,3,7,2,4]
18:09:47 <lambdabot>  False
18:09:51 <nitrix> Again, you're breaking a contract.
18:10:19 <EvanR> Squarism: sort them then ==
18:10:23 <EvanR> simplest way
18:10:45 <Squarism> ok
18:10:52 <ertesx> i'd convert to Set (using regular fromList, not fromDistinctAscList), then compare
18:11:08 <EvanR> well... why?
18:11:09 <Welkin> I love using Set :D
18:11:17 <Welkin> it is so simple
18:12:04 * EvanR imagines the amount of concrete code difference between them
18:12:13 * EvanR tries to compute the performance difference
18:12:33 <Welkin> there should be none
18:12:38 <Welkin> they are the same
18:12:48 <EvanR> i doubt they are the same
18:13:15 <nitrix> Meh. It's the whole "why do useless work if you happen to know what you're doing". Similar to fromJust.
18:14:16 <Squarism> deriving Ord made the trick
18:14:27 * EvanR stops at why do useless work and tries to figure that out first
18:14:55 <Welkin> he means don't waste your time or resources pre-optimizing for things that won't give you a decent return on your investment
18:15:14 <Squarism> What type of sorting is used when just deriving Ord wo defining it for the data type?
18:15:33 <EvanR> the sorting algorithm is the same regardless of Ord
18:15:44 <Welkin> merge sort
18:15:57 <nitrix> I didn't mean anything by it other than Data.Set's API is clear that there are different smart constructors from varying use cases (which have performance aimplications)... as well as semantic apparently.
18:15:57 <Welkin> Data.List.sort is a bottom-up merge sort
18:16:02 <Welkin> at least
18:16:25 <Squarism> oh.. i meant - what heuristic so to speak? hashcode? 
18:16:37 <EvanR> definitely not
18:16:53 <Squarism> order of declaratation? 
18:17:24 <Welkin> if you derive ORd automatically for your custom sum type, then it is the order they are written
18:17:39 <Welkin> you can manually define it though and make it whatever order you want
18:17:40 <EvanR> unless they are the same ctor
18:17:40 <Squarism> good to know!
18:17:48 <EvanR> then it tries the components
18:17:58 <KaneTW> order of definition then lexicographic
18:17:59 <KaneTW> iirc
18:18:00 <Squarism> clarity
18:18:24 <EvanR> (that one feature, deriving Ord, has saved so much code over ex. ruby)
18:19:10 <nitrix> Squarism: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#line-841
18:21:04 <nitrix> The anchor doesn't smeem to work. I pasted it on lpaste here (http://lpaste.net/170890). The beauty is that you can just see what it's doing yourself ;)
18:30:54 <Squarism> http://pasteboard.co/1oxJOin9Q.png <- what i use all stupid questions for. Aesthetics hasnt been an priority
19:01:58 <Hello> Absolute noob here. Could someone paste a really simple haskell program which I can run and play around with. TIA
19:04:16 <dmj`> module Main where; main :: IO (); main = putStrLn "hello world"
19:04:32 <ertesx> Hello: main = do x <- getLine; y <- getLine; putStrLn y; putStrLn x
19:14:48 <Xnuk> > 'H':'e':'l':'l':'o':',':' ':'w':'o':'r':'l':'d':'!':[]
19:14:49 <lambdabot>  "Hello, world!"
19:16:36 <Xnuk> > text $ 'H':'e':'l':'l':'o':',':' ':'w':'o':'r':'l':'d':'!':[]
19:16:38 <lambdabot>  Hello, world!
19:18:41 <jakeehrlich> is there anyway I could alter what versions a package requires in stack? I want to use this: https://hackage.haskell.org/package/llvm-general-quote 
19:18:59 <jakeehrlich> but it demands base 4.7.* but I want to use base 4.8
19:19:12 <jakeehrlich> and I doubt that 4.8 will mess the application up
19:20:30 <kadoban> jakeehrlich: You can download it (possibly with stack unpack), modify the cabal file, and point to your local version as an extra-dep in the stack.yaml file where you want to use it.
19:24:04 <jle`> jakeehrlich: you can also fork it and modify the deps on github
19:24:05 <jakeehrlich> kadoban: awesome, I unpacked it locally and change the requierment. how do I use that in my project instead of the non-local version?
19:24:42 <jle`> jakeehrlich: https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
19:24:43 <jakeehrlich> jle': could I still add it into my stack project?
19:24:48 <jle`> yup
19:24:55 <jle`> you can add local directories or github commits
19:24:57 <jakeehrlich> I'm guessing you just linked me to that
19:24:57 <jle`> *git commits
19:25:04 <jle`> they're abstracted under the same interface
19:25:27 <jakeehrlich> awesome, that link answers both questions it would seem
19:27:11 <jle`> yup, you'd have to scroll up a bit for the local package format
19:27:18 <jhance> Attoparsec has a function with type `match :: Parser a -> Parser (Text, a)` doing exactly what you expect. I can't seem to find the Parsec equivalent (with `[s]` presumably), does it not exist?
19:28:04 <jle`> jakeehr: remember to add extra-dep: true for sane behavior in ghci etc. :)
19:29:18 * hackagebot QuickCheckVariant 0.1.0.1 - Generator of "valid" and "invalid" data in a type class  https://hackage.haskell.org/package/QuickCheckVariant-0.1.0.1 (sanjorgek)
19:32:55 <jakeehrlich> jle`: ah crap I didn't add that and I'm build now
19:33:08 <jakeehrlich> well I'll see if works and change if I have problems I suppose
19:34:12 <jakeehrlich> actually curiously I already can't use 'stack ghci' on my project
19:34:21 <kadoban> Sorry, got distracted, sounds like you got taken care of though.
19:34:31 <jakeehrlich> yup, thanks!
19:39:19 * hackagebot casr-logbook 0.1.2 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.1.2 (TonyMorris)
19:39:21 * hackagebot QuickCheckVariant 0.1.0.2 - Generator of "valid" and "invalid" data in a type class  https://hackage.haskell.org/package/QuickCheckVariant-0.1.0.2 (sanjorgek)
19:39:52 <ReinH> avalokite: you're quite welcome, sorry for the high-latency response :)
19:40:12 <ReinH> jle`: sooooo whatcha doin with FRP-likes these days? Still auto?
19:40:42 <ReinH> jle`: I have a notion to hook Reflex up to ncurses.
19:42:05 <kadoban> ReinH: That sounds kind of awesome and weird
19:43:37 <ReinH> I really wish 256 color terminals were a real thing
19:43:55 <ReinH> or that sdl2-ttf had a haskell port and I could just make my own
19:55:31 <EvanR> ReinH: that exists
19:55:34 <EvanR> for what its worth
19:55:52 <ReinH> EvanR: orly
19:56:09 <ReinH> nice
19:56:52 <geekosaur> 256 color terminals do exist. getting curses to use them is a bit more interesting, since it predefines only the colorpairs supported by ANSI X3.64
19:57:30 <nshepperd_> xterm supports full 24-bit, though it doesn't work with anything because it's not in terminfo
19:57:36 <ReinH> geekosaur: They exist, they are just poorly distributed.
19:57:43 <ReinH> As is support for them.
19:57:51 <nshepperd_> and/or I just have no idea how to configure it
19:57:59 <geekosaur> and the way they hooked it into the attribute system is pretty horrid too
20:00:27 <geekosaur> the xterm-256color terminfo here (mint 17.2, roughly ubuntu 14.04) looks correct here re colors
20:01:17 <boj`> here is an interesting snippet about it: https://gist.github.com/XVilka/8346728
20:05:20 <geekosaur> and yes, terminfo is limited in how it can describe color so there's no way to specify 24 bit colors
20:39:42 <shachaf> In GHC 8, are type-level "strings" still atomic symbols, or can you do string operations on them?
20:40:04 <shachaf> The new type application syntax might make a convenient compile-time-checked printf possible.
20:40:39 <jle`> i believe they are still atomic, and Char is not promotable still
20:40:46 <shachaf> Scow.
20:41:14 <glguy> shachaf: If I mail you a copy of GHC 8 will you install it?
20:41:16 <ianbloom> hello
20:41:28 <shachaf> glguy: Sure.
20:42:42 <jle`> it's not too tricky to simulate promotable Char's with reflection-like techniques.  and you can probably turn a Symbol into a list of them
20:43:01 <jle`> maybe with a FromString type family
20:43:10 <jle`> but yeah, the haskell isn't going to help you at all
20:43:14 <shachaf> You can?
20:43:19 <shachaf> How can you take a Symbol apart?
20:43:57 <jle`> reflection/singletons-like stuff.  you can move a list of Bool's or Integer's to the type level, after all
20:44:12 <jle`> so it'd probably be reflecting it to a string and reifying the string as a [CustomChar]
20:44:30 <shachaf> That doesn't sound compile-time checkable?
20:44:38 <glguy> shachaf: You just make a type family Head and Tail and provide billions of instances for all the different Symbols
20:44:50 <shachaf> Oh, good point.
20:45:04 <jle`> yeah, but that's no different than using 'reflections'
20:45:07 <jle`> hm
20:45:10 <jle`> oh yeah, i see your point
20:46:01 <mniip> oooohhh
20:46:06 <mniip> you could have
20:46:13 <mniip> FromString :: Symbol -> * -> Constraint
20:46:27 <jle`> i can just imagine a TH library that ejects a billion type family instances, heh
20:46:47 <mniip> fromString :: FromString s a => p s -> a
20:46:59 <glguy> A type checker plugin is probably a more reasonable approach
20:49:45 <shachaf> https://ghc.haskell.org/trac/ghc/ticket/11342
20:51:26 <jle`> i wonder why it lost steam
20:52:10 <dmj`> that is so cool
20:54:05 <dmj`> maybe since you can just do ( "a" ': '["b","c"] ) it might not be worth it
21:04:17 <Welkin> hi dmj` 
21:07:27 <dmj`> hi Welkin
21:07:51 <Welkin> are you makin bacon pancakes?
21:08:11 <dmj`> Welkin: ask me in #haskell-offtopic
21:20:43 <glguy> Is it that case that throwTo blocks until the exception is delivered, but that after throwTo stops blocking that the killed thread can still be executing cleanup via finally and onException?
21:21:06 <glguy> The blocking behavior is that it blocks until normal execution is interrupted, right?
21:24:38 <ertesx> glguy: correct
21:25:17 <ertesx> glguy: i use the async library (cancel t >> waitCatch t)
21:25:32 <ertesx> that actually waits for the thread to exit
21:59:24 * hackagebot lifted-base 0.2.3.8 - lifted IO operations from the base library  https://hackage.haskell.org/package/lifted-base-0.2.3.8 (BasVanDijk)
22:05:26 <tnks> if you have a test file of inputs, what's the recommended way to thread the filepath within the project to a test?
22:06:17 <tnks> everything I found just advises to test pure functions.  I totally get that advice, but there's time when reading a file is the right thing to do in a test.
22:08:48 <ertesx> tnks: most test frameworks support IO testing
22:09:16 <Welkin> http://hackage.haskell.org/package/tasty
22:09:20 <Welkin> try tasty
22:09:32 <Welkin> I've never used any testing frameworks, but I always hear about this one
22:09:49 <ertesx> tasty is a meta-framework though…  you need to use an actual test framework
22:10:00 <ertesx> like HUnit, QuickCheck, smallcheck
22:10:04 <tnks> I was looking at hunit, but didn't find it.
22:10:13 <tnks> cabal knows about the source directories.
22:10:25 <tnks> just not sure how that variable threads through.
22:10:45 <ertesx> tnks: you probably have a main action somewhere that starts the tests
22:11:10 <ertesx> your test suite is just a regular program, so you pass file paths around like any other piece of configuration:  as function arguments
22:11:45 <tnks> ertesx: oh, it's just a variable, makes sense.
22:11:52 <tnks> comes in as an argument, right?
22:16:45 <gestone> hey all, so i'm using the haskell stack build tool and i was wondering if there's a way to split my tests into different files
22:17:07 <bernalex> gestone: what's the problem?
22:17:39 <kadoban> gestone: Sure, several. You can have multiple test-suites, or you're allowed to build your test program up from whatever modules you want, that can be organized however you want really.
22:17:50 <bernalex> you can have a bunch of test files, and call it all in a main-test.hs, or you can have a bunch of different test-suites, whatever you want.
22:17:56 <gestone> how would i specify that in my cabal file?
22:17:58 <bernalex> eh, yes, what kadoban wrote.
22:18:05 <bernalex> gestone: just specify more than one test-suite
22:18:27 <gestone> oh i see
22:18:36 <bernalex> I frequently have a test-suite spec, and a test-suite prop, where the former is unit tests and the latter property tests.
22:19:13 <gestone> so i would have a section called test-suite "moduleA" and another called test-suite "moduleB" and when i run "stack test" it would go through and run the tests?
22:19:25 * hackagebot case-insensitive 1.2.0.7 - Case insensitive string comparison  https://hackage.haskell.org/package/case-insensitive-1.2.0.7 (BasVanDijk)
22:19:27 <bernalex> I don't know how stack works, but I assume so.
22:20:39 <bernalex> but for testing different modules, I would think that inevitably you would want to reuse code. in that case, I suggest having a main test file where you do all the testing.
22:20:41 <jhance> I recommend using tasty when using multiple frameworks
22:20:53 <jhance> as the glue code to tie them together under a common driver
22:20:55 <bernalex> I use different test-suites only when the tests themselves are inherently very different.
22:21:07 <bernalex> I've never used tasty, but it looked good the last time I looked at it.
22:21:30 <kadoban> gestone: Yeah.
22:21:33 <jhance> its nice to be able to abstract away whether or not you are using property tests or unit tests
22:21:38 <bernalex> using hspec it's very easy to compose things. you just have a spec :: Spec; spec = do { moduleASpec ; moduleBSpec ; etc ; }
22:21:43 <kadoban> In terms of tests, stack works ... pretty much how cabal-install does AFAIK.
22:21:44 <bernalex> and then main :: IO (); main = hspec spec
22:22:19 <Welkin> I tend not to write tests
22:22:23 <Welkin> not even quickcheck
22:22:37 <Welkin> I should at least do quickcheck I suppose
22:22:45 <gestone> bernalex: if i'm testing module A and module B, what use cases would i have for reusing code?
22:23:23 <bernalex> Welkin: it depends on the type of software you are writing. I was dealing with things that needed to be formally correct on one side (quickcheck), and things that needed to never break api stuff on the other (hspec/hunit).
22:23:35 <gestone> where would there be a scenario for which i could reuse code between the two modules? i'm just trying to figure out whether i should split my tests or not
22:23:54 <bernalex> gestone: maybe they use the same data type, and you need an Arbitrary instance for said data type. there could be many reasons.
22:24:18 <bernalex> gestone: you can split the tests, but that doesn't mean you need to have separate suites. most testing frameworks compose very elegantly.
22:24:38 <bernalex> as mentioned, with hspec, it would just be spec = do { thisSpec ; thatSpec ; etcSpec }
22:24:44 <gestone> yeah, currently i'm trying to use hspec
22:25:40 <gestone> so is "thisSpec" ; "thatSpec" ; "etcSpec" specs from other files?
22:25:56 <bernalex> if you want
22:26:04 <bernalex> they can be from wherever.
22:26:09 <Welkin> http://hspec.github.io/
22:26:13 <Welkin> the manual
22:26:44 <bernalex> with QuickCheck, it's also very easy. there you just have [Test], and do defaultMain $ theseLaws <> thoseLaws <> etcLaws.
22:27:14 <bernalex> testing frameworks in haskell are so much nicer than in other languages I've done tests.
22:28:01 <EvanR> dont try to test float arithmetic though
22:28:01 <gestone> also, is there a way to export testing modules?
22:28:02 <Welkin> you could just leave it at "haskell [...] so much nicer than other lanuages"
22:28:31 <EvanR> ghci needs color tho
22:28:34 <bernalex> gestone: export where? how do you mean?
22:28:47 <gestone> so i'm using stack
22:29:01 <bernalex> gestone: test-suites can have exposed-modules like anything else, afaik, if that's what you mean.
22:29:03 <gestone> and i noticed in my .cabal file there's a library section where i can expose modules
22:29:12 <Welkin> your tests would all be imported to your /tests/Main.hs
22:29:57 <gestone> ah really? i'll give that a shot
22:30:30 <bernalex> do you mean you just want to access test modules inside of the test-suite? you would use other-modules for that.
22:30:49 <kadoban> A test-suite is just an executable really, cabal-install/stack doesn't really care what code you build it up out of, it's very flexible.
22:30:59 <gestone> i want to be able to access my other test modules inside of test-suite
22:31:46 <gestone> yeah i can't have "exposed-modules" on test-suite
22:31:54 <bernalex> I don't really understand the problem. if you have Foo.Tests.A and Foo.Tests.B, just put them in other-modules. then you can import them wherever you want, and in main-is, and so on.
22:32:16 <bernalex> I might have misremembered that then. but you can definitely use other-modules, which should be what you want.
22:33:30 <bernalex> you'll have e.g. test-suite spec; type: exitcode-stdio-1.0; main-is Spec.hs; other-modules: MyProgram.Spec.ModuleA; MyProgram.Spec.ModuleB; hs-source-dirs: test; default-language: Haskell2010;
22:34:02 <bernalex> then you have tests/Spec.hs and test/MyProgram/Spec/{ModuleA,ModuleB}
22:34:55 <bernalex> sorry, tests/MyProgram/Spec/{ModuleA,ModuleB}, of course, not test/...
22:36:46 <gestone> ahh i got it thanks so much. "other-modules" did the job
22:37:00 <gestone> i thought you had to explicitly expose the module to use it in another file
22:37:21 <bernalex> test-suite mostly works the same way as executable.
22:47:20 <gestone> also, what's the recommended way to connect to a postgres database using haskell?
22:47:23 <gestone> i tried using opaleye
22:47:45 <gestone> but i got lost in the documentation and i found it to be... not the most intuitive as a newbie
22:48:29 <gestone> is raw SQL the way to go with haskell?
22:49:11 <bernalex> I used persistent.
22:49:21 <bernalex> with esqueleto.
22:51:43 <gestone> huh il'l take a look into it. why the usage of both?
22:53:36 <bernalex> I don't understand the question. they do different things.
22:53:52 <bernalex> esqueleto is made for persistent.
22:55:02 <gestone> ah it's for type safe joins?
22:55:32 <bernalex> oh, wow. wtf is this shit? snoyman has begun to not put up documentation on hackage now, instead using it as a space for advertising stackage? how incredibly lame.
22:55:43 <bernalex> gestone: yes, amongst other things. please see https://hackage.haskell.org/package/esqueleto
22:56:37 <Welkin> lol what?
22:57:22 <bernalex> Welkin: all his packages just say crap like «Hackage documentation generation is not reliable. For up to date documentation, use stackage»
22:57:35 <bernalex> and there's no haddock for anything any longer
22:57:41 <Welkin> oh lol
22:57:49 <Welkin> he's done that for a long time now
22:57:52 <EvanR> better build the docs locally
22:58:03 <EvanR> save the bandwidth
22:58:11 <bernalex> I never had any problems with hackage in that regard, but I heard there was a problem at some point.
22:58:31 <EvanR> if you upload your docs manually its great
22:58:48 <bernalex> then I don't see the problem.
22:59:12 <bernalex> at least he uploads it to hackage at all, I guess. -_o_-
23:00:28 <ongy> do older (<= 7.8) versions of GHC not have unicode support?
23:01:53 <tdammers> ongy: which part? String and Char have been unicode strongs for about forever
23:02:34 <ongy> Char, I have a parse error on 7.6, 7.8 "lexical error in string/character literal at character '\128425'", works on 7.10 and 8.0
23:49:28 * hackagebot wai-http2-extra 0.0.2 - WAI utilities for HTTP/2  https://hackage.haskell.org/package/wai-http2-extra-0.0.2 (KazuYamamoto)
