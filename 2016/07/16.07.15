00:07:37 * hackagebot fgl 5.5.3.0 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.3.0 (IvanMiljenovic)
00:07:37 * hackagebot fgl-arbitrary 0.2.0.2 - QuickCheck support for fgl  https://hackage.haskell.org/package/fgl-arbitrary-0.2.0.2 (IvanMiljenovic)
00:34:18 <srhb> Digit: It seems to me the easiest solution is to change the Show instance, even if that's sort of icky. But that's what ghci uses to print the values.
00:44:53 <jle`> Digit: when you want to view a number, you can just use printf
01:17:34 <ertes> this is the first time i made it to the bare OpenGL hello world triangle without a single segfault
01:23:49 <jle`> congrats ertes 
01:26:12 <ertes> ok, i exaggerated a bit, but OpenGL has to be the most complicated and convoluted API in existence
01:26:43 <ertes> if you think, haskell is hard, try OpenGL
01:35:52 <cocreature> ertes: if you want it extra hard, try haskell with opengl. now you can‚Äôt even properly debug your segfaults
01:37:54 <maerwald> ertes: I did opengl in C and I never got a segfault 
01:38:03 <maerwald> but that was just very slow programming
01:40:54 <ertesx> cocreature: that's what i did‚Ä¶  it was a bit easier in C/C++, because i could get away with less conversion/casting
01:41:36 <maerwald> yeah, gtk is a similar mess. C bindings just suck
01:42:56 <ertesx> but i'm not sure with which one i'd get shorter code‚Ä¶  i used functional abstraction in at least one occasion
01:43:40 <ertesx> genNames :: (Storable a) => Int -> (GLsizei -> Ptr a -> IO r) -> IO (Vs.Vector a)
01:43:40 <ertesx> genNames n gen = do namesArr <- Vsm.new n; Vsm.unsafeWith namesArr (gen (fromIntegral n)); Vs.unsafeFreeze namesArr
01:43:45 <ertesx> stuff like that is very valuable
01:44:45 <maerwald> I prefer predictable performance and good debugging when I do opengl over abstraction
01:45:36 <cocreature> I prefer not doing opengl ;)
01:45:55 <ertesx> i have a love/hate relationship with it =)
01:46:06 <maerwald> well, then you might end up losing your job if you only want to code stuff that haskell is good at :P
01:46:38 <ertesx> i hate OpenGL until it finally draws stuff and it looks cool‚Ä¶  then i love it again
01:46:54 <cocreature> my problem is not that haskell is not good at it, I‚Äôm fine with some C. I just hate graphics
01:47:01 <maerwald> ertesx: there is this new OpenGL alternative thing no?
01:47:04 <maerwald> I forgot the name
01:47:54 <maerwald> Vulkan?
01:48:01 <maerwald> yeah
01:48:22 <int-e> maerwald: have you tried looking at its specs?
01:48:29 <maerwald> https://www.khronos.org/registry/vulkan/
01:48:52 * int-e got lost in the object types... didn't try very hard though.
01:49:44 <maerwald> but it's even more low-level it seems
01:50:07 <maerwald> we definitely need more low-level crap in 2016
01:51:31 <cocreature> maybe some people get payed by the number of segfaults they fix so they push very hard for low-level crap
01:51:44 <int-e> maerwald: well, even Khronos writes that Vulkan isn't really meant to be targeted directly, but should be used by higher level frameworks. It's a very shallow abstraction from modern GPUs.
01:53:28 <maerwald> the problem is... the target audience are those who write their base64 implementation from scratch instead of using a library. Doubt we will see a high-level framework around it
01:53:36 <ertesx> at least it seems to be self-conscious‚Ä¶  OpenGL had an identity crisis for a long time (until the core profiles came)
01:53:48 <ertesx> "am i high level or low level?"
01:53:49 <cocreature> maerwald: well game engines are high level frameworks
01:54:05 <maerwald> cocreature: depends
01:54:22 <ertesx> i'd say vulkan is doing the right thing, giving maximum control‚Ä¶  frameworks will abstract it away as they see fit
01:54:22 <maerwald> OpenMW is not a high-level framework. They basically failed at it.
01:55:17 <ertesx> remember when every OpenGL hello world triangle looked like a bunch of glColor* and glVertex* calls?
01:55:22 <maerwald> And I don't want a full engine, I want an simple API that I can gradually replace with more details as I go. That's what a good API is about.
01:55:26 <maerwald> we don't have that
01:56:28 <maerwald> "I have this defaults for you, you need more? Then use function XY instead"
01:57:10 <ertesx> another thing i like about vulkan (according to wikipedia) is that it seems to be more than just a graphics API‚Ä¶  it seems to provide access to compute as well
01:58:57 <ertesx> the press release also indicates that
02:18:29 <dysfun> ertesx: yes, it's at a lower level than Open[CG]L
02:18:36 <statusfailed> Can somebody recommend me one of the kanren variants to use as a DSL? Preferably one that has a tutorial, I've not really done much logic programming
02:18:48 <statusfailed> (doesn't have to be a *kanren actually)
02:21:42 <peddie> statusfailed: there is a nice video of a minikanren workshop by Will Byrd https://www.youtube.com/watch?v=zHov3fKYqBA https://www.youtube.com/watch?v=nFE2E91VDAk 
02:22:27 <peddie> statusfailed: minikanren also has an amazing textbook called The Reasoned Schemer
02:23:04 <statusfailed> peddie: ah the reason I was avoiding that is because I don't know any lisps well, so I thought it might be a bit of overhead to learn two languages at once
02:23:07 <statusfailed> but maybe not!
02:23:30 <statusfailed> I'll check those workshops out for sure, thanks!
02:23:34 <peddie> statusfailed: do you know haskell?
02:23:44 <statusfailed> Yep
02:23:52 <peddie> statusfailed: scheme is pretty simple by comparison, I think you'll have no trouble
02:25:20 <statusfailed> I've done a bit; it's more that there's a bit of overhead when I read/write it because it's unfamiliar. I'll give it a shot though :-)
02:43:38 <superlinux> hi. I have installed gtk2hs. I am on the hello world  tutorial. but the code is not compiling. I am getting this: Failed to load interface for ëGraphics.UI.Gtkí . I have a working sandbox
02:44:03 <superlinux> please help
02:44:56 <nmdanny> in acid-state, how can I access the state as a pure object in the IO monad?
02:45:18 <nmdanny> e.g, If I issue a query, how do I get the query result?
02:46:06 <puregreen_> nmdanny: er, just ‚ÄúqueryResult <- query SomeAction‚Äù
02:46:12 <puregreen_> or have I misunderstood you?
02:46:40 <nmdanny> query :: QueryEvent event => AcidState (EventState event) -> event -> IO (EventResult event) 
02:46:49 <nmdanny> that gives me an EventResult
02:47:09 <nmdanny> but how do I unwrap an EventResult?
02:47:20 <puregreen> EventResult is a type family
02:47:38 <puregreen> i.e. ‚ÄúEventResult SomeEvent‚Äù is going to be the type that SomeEvent returns
02:48:08 <puregreen> okay, this was a bad explanation
02:48:46 <puregreen> a sec
02:49:03 <merijn> nmdanny: Looks like the result type is just whatever the last parameter of your query type is
02:49:08 <merijn> nmdanny: See https://github.com/acid-state/acid-state/blob/master/examples/HelloWorld.hs
02:49:32 <nmdanny> ok, lets say that I have the following query:
02:49:32 <nmdanny> queryDbState :: Query Db Db
02:49:50 <puregreen> then EventResult QueryDbState is going to be just ‚ÄúDb‚Äù
02:50:04 <puregreen> it behaves as a type synonym, not as `data`
02:50:09 <puregreen> you don't have to unwrap it
02:50:59 <nmdanny> ok, lets say that my app uses "Db" for its acid state
02:52:19 <nmdanny> and I have the following function queryAcid :: (MonadReader Config m,MonadIO m,QueryEvent event,MethodState event ~ Db) => event -> m (EventResult event)
02:52:59 <puregreen> and if you have a query like ‚ÄúgetInt :: Query Db Int‚Äù, then your ‚ÄúqueryAcid GetInt‚Äù will return ‚Äúm Int‚Äù
02:54:04 <puregreen> because thanks to type family magic, ‚ÄúEventResult GetInt‚Äù gets translated to ‚ÄúInt‚Äù
02:54:26 <nmdanny> ok
02:55:52 <nmdanny> now, I am trying to integrate acid-state with a servant server,
02:56:19 <merijn> nmdanny: Out of curiosity, what data are you gonna be storing in acid-state?
02:57:06 <nmdanny> data Db = Db { _persons :: Vector Person , etc... }, collections of ADTs basically
02:57:22 <nmdanny> i'm trying to make a very basic CRUD app
02:57:37 <merijn> I'm not sure I would recommend acid-state for that
02:57:41 <superlinux> hi. I have installed gtk2hs. I am on the hello world  tutorial. but the code is not compiling. I am getting this: Failed to load interface for ëGraphics.UI.Gtkí . I have a working sandbox
02:57:42 <superlinux> please help
02:57:47 * merijn gets out his acid-state is not a database soapbox
02:58:48 <nmdanny> I know, but still, I'm trying to use it as a db for learning purposes
02:58:54 * maerwald slips on the soap
02:58:55 <merijn> nmdanny: Any specific reason for using acid-state over, say, sqlite?
02:59:36 <nmdanny> I want to deal with pure haskell types, and not have to deal with transforming sql/persistent entities to pure haskell types etc
03:01:44 <verement> nmdanny: you might have a look at vcache also
03:02:09 <nicksoline> ciao haskell
03:03:02 <nmdanny> anyway, so for example I have the following function, which im trying to make work
03:03:46 <lpaste> nmdanny pasted ‚ÄúNo title‚Äù at http://lpaste.net/169905
03:04:56 <lpaste> nmdanny revised ‚ÄúNo title‚Äù: ‚Äúacid state, trying to make a basic query‚Äù at http://lpaste.net/169905
03:05:41 <nmdanny> basically, according to GHC the return type is "EventResult (Query Db Db)", but I want it to be "Db"
03:06:00 <merijn> nmdanny: EventResult is not a datatype
03:06:06 <merijn> nmdanny: It's a type level function
03:06:16 <merijn> nmdanny: "EventResult (Query Db Db)" = "Db"
03:06:35 <merijn> As you can see in the example I linked earlier
03:06:55 <nmdanny> you mean, a function that operates on types?
03:08:31 <nmdanny> either way, my intention is to somehow run a query and get the query result as a normal, typed value
03:09:25 <nmdanny> if that's possible?
03:09:56 <nmdanny> basically if I have some query, of type "Query Db res", I want a function of type Query Db res -> IO res
03:32:38 * hackagebot hindent 4.6.4 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.6.4 (ChrisDone)
03:40:23 <undreren> Hi all
03:41:01 <undreren> I have a question about password security, and I wondered if any of you knew anything about that
03:42:42 <puregreen> geekosaur: look at the awful thing I did (about stripping unnecessary digits in when displaying floating-point numbers): https://gist.github.com/neongreen/af16c46b2cee1bbb10363d6e9698c7ff
03:43:16 <puregreen> (there are some cases when it won't work, but, umh, should mostly work kinda)
03:50:35 <maerwald> undreren: we don't, since there is no question yet
03:51:11 <maerwald> unless you want to recruit people based on their skills
03:55:02 <Axman6> undreren: what's your question?
03:55:56 <pavonia> > let isSecurePassword = not . flip elem ["password", "test", "testtest", "test1234"] in isSecurePassword "test1234"  -- the ultimate test for secure passwords
03:55:59 <lambdabot>  False
03:56:36 <Axman6> pavonia: huh, that's cool, all I see is "********", try it with another password
03:57:41 <pavonia> Does it hide it because it's your password?
03:58:22 <Axman6> not sure, try it with yours
03:58:23 <Axman6> :P
04:00:37 * Axman6 was refrencing http://bash.org/?244321 in case anyone missed the joke
04:01:55 <pavonia> lol
04:08:15 <undreren> maerwald, Axman6: I've been watching myself some Computerphile lately, and I thought it was a good idea to make a program that could generate strong passwords
04:08:43 <undreren> But It's not ideal to store the passwords on my computer
04:08:59 <Athas> undreren: why not, if they are encrypted?
04:09:20 <undreren> Because not storing is better, if feasible
04:09:52 <undreren> What I thought would be a good idea, would be to use a deterministic algorithm to make the passwords.
04:10:04 <undreren> Step 1: Make a master password
04:10:43 <undreren> Step 2: Choose an id for your generated password (Eg, "Facebook")
04:11:09 <undreren> Step 3: Compute a RNG (StdGen in haskell) from the ID and the Master Password
04:11:27 <Axman6> you could store them in a password manager, but they usually have a strong password generator anyway
04:11:32 <undreren> Step 4: Use that RNG to generate a password
04:11:58 <puregreen> the ‚Äúmaster password‚Äù thing has already been invented several times
04:12:00 <Athas> Why is that better than random passwords that are encrypted with a master password?  It just creates an additional attack vector, as now people can get your passwords without access to your machine, if they have the master password.
04:12:15 <puregreen> also, encrypting IDs with a master password is exactly the same actually
04:12:16 <Athas> I have encrypted passwords on my machine.  People need both access to those and my master password.
04:12:28 <undreren> I am not encrypting anything
04:12:53 <puregreen> did you know that lots of RNGs work like ‚Äúencrypt number 1, encrypt number 2, etc‚Äù?
04:12:55 <undreren> The ID's are stored, maybe hashed, but the Master Password is used as a random seed
04:13:15 <undreren> puregreen: What do you mean?
04:14:01 <puregreen> to generate a stream of random bytes: 1. pick a seed; 2. encrypt "1" with AES using that seed as the key; 3. encrypt "2" with AES using that seed as the key; ...
04:14:41 <puregreen> encrypting anything *is* computing a RNG, with the additional property that the RNG is guaranteed not to produce repeating blocks
04:14:43 <puregreen> that's all
04:14:56 <Axman6> IIRC that's pretty close to how AES-XTS works right?
04:15:29 <puregreen> no idea, to be honest
04:18:00 <puregreen> anyway, in the case of having a RNG, your passwords are known to anyone who knows the ID and the master password; in the case of using encryption, your passwords are known to anyone who knows the master password. Given that IDs are supposed to be easily guessable (‚ÄúFacebook‚Äù, etc) there's no difference I can see.
04:42:40 * hackagebot sproxy 0.9.7 - HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy-0.9.7 (ip1981)
04:50:43 <Mr_Phreak> hello , i wanted to use scripts with nmap to crack a router Huawei HG532e and it didn't work, can anyone give some advice here?
04:52:41 * hackagebot hspec-stack-rerun 0.1.0.2 - Simple project template from stack  https://hackage.haskell.org/package/hspec-stack-rerun-0.1.0.2 (MarkWotton)
04:54:56 <bennofs> Mr_Phreak: this is #haskell. Does your question have anything to do with the Haskell programming language?
04:54:57 <sbrg> Mr_Phreak: does this look like the right channel?
04:55:19 <sbrg> lol
04:55:24 <sbrg> > root
04:55:26 <lambdabot>      No instance for (Typeable f0)
04:55:26 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
04:55:26 <lambdabot>        arising from a use of ‚Äòshow_M810149369165756681419144‚Äô
04:55:29 <sbrg> oops
04:56:06 <hpc> :t root
04:56:08 <lambdabot> Functor f => (a -> f a) -> Tree a -> f (Tree a)
05:17:41 * hackagebot extra 1.4.11 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.11 (NeilMitchell)
05:22:42 * hackagebot hspec-stack-rerun 0.1.0.3 - Simple project template from stack  https://hackage.haskell.org/package/hspec-stack-rerun-0.1.0.3 (MarkWotton)
05:32:52 <reactormonk> I'm trying to build https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=elm-platform - but the cabal install command gives me failures to install some packages that work well when I install them directly via cabal install. E.g. tagged 0.8.4 before, now zlib 0.6.1.1 - and it doesn't even create a logfile. I'm kinda short on ideas.
05:33:09 <reactormonk> There should be enough space on the device.
05:43:08 <reactormonk> https://gist.github.com/reactormonk/1e4789d40e06d9cb2ce07b291b1cb8eb
05:47:10 <hexagoxel> reactormonk: how ironic
05:48:11 <reactormonk> https://gist.github.com/reactormonk/7774e50d74598af0aa1f12de952864ec :-/
05:48:40 <hexagoxel> reactormonk: try -j1 flag
05:49:05 <reactormonk> now it works.
05:49:46 <fProgrammer> Quick question: I am working Data.Matrix, I want to store it in a database as serialized bytestring. What is the best way to serialize (Data.Matrix.Matrix a) type? Any other libraries which have this capability
05:50:13 <hexagoxel> reactormonk: you should also change the -j -j1 in the aur script just to get useful error messages
05:50:45 <reactormonk> did so, running that now
05:51:53 <fProgrammer> anyone?
05:58:00 <Axman6> fProgrammer: I assume there isn't a Binary instance for it?
05:58:01 <fProgrammer> Turns out, Data.Matrix.Matrix doesn't have an instance of Serialize, so can't use cereal package for binary serialization.. what may be the better way?
05:58:21 <fProgrammer> Axman6: correct sir.
05:58:47 <reactormonk> fProgrammer, write your own?
05:58:56 <reactormonk> ... instance of Serialize
05:58:57 <Axman6> there's almost certainly a way to get access to a pointer, you could store the dimensions and the type of a and then make a bytestring from the pointer
06:00:13 <fProgrammer> reactormonk: Umm.. I can write one, it will be sub-optimal, I am sure someone else must have faced this problem before and may have a superior solution? I am dealing with several matrices of size  1000x1000
06:01:28 <reactormonk> fProgrammer, probably wrote his own too. Google around.
06:03:19 <fProgrammer> reactormonk: yep I asked before checking 5 pages of search result. Never mind, I will think of something else..
06:04:34 <reactormonk> fProgrammer, see how other, similar instances of Serialize are implemented.
06:07:43 * hackagebot sproxy 0.9.7.1 - HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy-0.9.7.1 (ip1981)
06:07:45 * hackagebot strive 3.0.0 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-3.0.0 (fozworth)
06:07:57 <reactormonk> text-1.2.2.1 failed while downloading the package. The exception was:
06:07:59 <reactormonk> user error (Failed to download
06:08:01 <reactormonk> http://hackage.haskell.org/package/text-1.2.2.1.tar.gz : HTTP code 400)
06:08:21 <reactormonk> Works under manual install, but not inside the sandbox
06:08:47 <tsahyt> Is there a function that sort of acts like when but without the monad restriction? i.e. when' :: Bool -> (a -> a) -> a -> a; when' p f = if p then f else id
06:09:47 <tsahyt> other than flip flip id . if', because that's kinda ugly
06:11:23 <liste> :t bool
06:11:24 <lambdabot> a -> a -> Bool -> a
06:11:41 <fProgrammer> reactormonk: ok thanks
06:12:06 <Axman6> :t bool id
06:12:07 <lambdabot> (a -> a) -> Bool -> a -> a
06:12:31 <Axman6> > bool id (*3) True 7
06:12:33 <lambdabot>  21
06:12:39 <Axman6> > flip bool id (*3) True 7
06:12:41 <lambdabot>  7
06:13:11 <tsahyt> thanks!
06:13:24 <Axman6> huh, I thought that was backwards... hadn't realised bool was bool false true 
06:14:37 <tsahyt> from the docs: This is equivalent to if p then y else x; that is, one can think of it as an if-then-else construct with its arguments reordered.
06:14:49 <tsahyt> for bool x y p
06:15:10 <Axman6> yeah. I'd assumed it was the same order as if' (and if)
06:15:32 <Maciek545> Hi!
06:16:57 <Maciek545> Hi
06:17:13 <liste> hi Maciek545 
06:18:36 <hexagoxel> Axman6: it is arguments reversed: else-then-cond
06:20:04 <Axman6> it makes sense as the catamorphism of Bool
06:22:44 * hackagebot human-readable-duration 0.2.0.2 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.2.0.2 (yogsototh)
06:22:45 * hackagebot ratel 0.3.0 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.3.0 (fozworth)
06:27:44 * hackagebot human-readable-duration 0.2.0.3 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.2.0.3 (yogsototh)
06:27:47 <tsahyt> @djinn (a -> Bool) -> (a -> a) -> Bool -> a -> a
06:27:47 <lambdabot> f a b c d =
06:27:47 <lambdabot>     case c of
06:27:47 <lambdabot>     False -> d
06:27:47 <lambdabot>     True -> case a d of
06:27:47 <lambdabot>             False -> b d
06:27:49 <lambdabot>             True -> d
06:43:09 <Zemyla> edwardk, what exactly are the semantics of try in Text.Parsing.Combinators? Is it just a general "improve backtracking" function, or does it do a specific thing?
06:52:44 * hackagebot DAV 1.3 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.3 (ClintAdams)
06:54:40 <tsahyt> what are the strictness properties of foldlM?
06:58:56 <Myrl-saki> What haskell db interface should I use?
06:59:44 <dysfun> what kind of database and what do you want to do with it?
07:00:31 <Myrl-saki> dysfun: no idea. I don't normally use DBs.
07:01:05 <dysfun> i see. well can you give us any more information that might help us to help you?
07:01:18 <dysfun> are you learning?
07:01:43 <Myrl-saki> dysfun: Yes. I want to use a DB with Spock for a project.
07:01:46 <nicksoline> anyone good in mptcp simulation ?
07:01:54 <oherrala> Myrl-saki: DB is a tool so you want to select correct DB for the data and usage
07:02:17 <Myrl-saki> I was planning to use only maps, since it's not a big project. But I figured I might as well use this as a learning experience.
07:02:26 <dysfun> if you have literally no clue, postgres and persistent aren't bad choices
07:02:45 <dysfun> but they're also quite confusing
07:04:25 <Myrl-saki> Basically, I want to be able to do ?k=v on a server running Spock and it will match every entry where k is v. I'll probably get more fancy with timestamps, but that's it.
07:05:06 <Clint> uh
07:05:38 <Maciek545> Bots?
07:06:06 <Myrl-saki> pyon: hai
07:06:17 <Maciek545> hi
07:06:23 <nicksoline> ciao
07:07:08 <Myrl-saki> So, yeah. That's what I need. I know I can do this purely in Haskell but I figured out I'll need to use DBs on a larger project so I might as well use it now.
07:07:10 <tsahyt> Maciek545: or just normal users lifted into a monad
07:07:42 <dysfun> well postgres is a sane go-to database
07:07:45 * hackagebot hpio 0.8.0.3 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.3 (dhess)
07:07:59 <Myrl-saki> dysfun: Okay. How about the Haskell interface?
07:08:06 <dysfun> persistent is probably the most recommendable way
07:08:49 <Myrl-saki> Checking now.
07:08:55 <dysfun> (
07:09:01 <dysfun> https://www.schoolofhaskell.com/school/advanced-haskell/persistent-in-detail
07:09:49 <dysfun> probably want this one first https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db
07:11:06 <Myrl-saki> dysfun: how would that translate to postgres?
07:14:18 <dysfun> try this http://gettingsharper.de/2014/01/24/babysteps-in-using-persistent-to-interact-with-postgresql/
07:19:10 <hodapp> blah blah blah profiling blah blah blah GC
07:19:13 <hodapp> "320,915,547,664 bytes copied during GC" wait what
07:19:22 <dysfun> lol!
07:21:03 <Myrl-saki> lol
07:21:17 <Myrl-saki> 320 gigs.
07:21:20 <Myrl-saki> that's more than my ssd.
07:21:54 <hodapp> active memory - if I'm reading the plot right - only tops maybe 60 MB
07:22:09 <hodapp> still probably higher than it should be, but I'm definitely doing something wrong here
07:41:48 <travism> omw
07:45:09 <hodapp> wha?
07:45:57 <Welkin> hodapp: did anyone try to catch you yet?
07:46:55 <hodapp> what?
07:51:03 <nicksoline> cddddddddddddddddddddddddddddddddddddddddddd; 0Mo..........':ldkO0KKXXKK0kxoc,..........kMd 0Ml......;d0WMMMMMMMMMMMMMMMMMMMWKx:......kMd 0Ml...cOWMMMMMMMMMMMMMMMMMMMMMMMMMMMWO:...kMd 0Ml.lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNc.kMd 0MdKMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM0OMd 0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd 0MxcxWMMMMMNXXNMMMMMMMMMMMMMMMNXXNMMMMMWkcKMd
07:51:08 <nicksoline>  0Md..lMKo.,'...:kWMMMMMMMNx;...',.;dXMMl.'XMd 0Mx'.,O;dXMMMXl....:dWMNo;....oXMMMKd;0,.'KMd 0MO;.,NMWMMMMMMWk;...XMK...:OWMMMMMMWMN,.cNMd 0MxxNMX;KMMKdcclkWN0WMMMN0WNxc:lxXMMk;WMXdKMd 0MMMMMO;MMl.......KMXOMNkMk.......xMM.NMMMMMd 0MMMMMMXKoclddl;.oWMdkMN,MN:.:ldolcdXNMMMMMMd    0MMMMMMWXMMMMMMMW0KdoNMMdox0MMMMMMMMXMMMMMMMd 0MMMMXc'WMMMMMMMMkcWMMMMMMkcMMMMMMMMN'lXMMMMd 0MMMd..cMMMMMMMMNdoKMMMMM0x:XMMMMMMMM:..kMMMd
07:51:14 <nicksoline>  0MM0...d0KKOd:.....c0Kx'.....: d0NX0l....NMMd 0MMO.....................................WMMd 0Mdkc...................................0kOMd 0Ml.:Ol;........';;.......;,........':oX:.kMd 0Ml..,WMMMMWWWo...';;:c::;'...:WWMMMMMW;..kMd 0Ml...dMMMMMMMMKl...........c0MMMMMMMMd...kMd 0Ml...cMMMMMMMMMMMXOxdddk0NMMMMMMMMMMM'...kMd 0Ml....KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMO....kMd 0Ml.....OMMMMMMMMMMMMMMMMMMMMMMMMMMMK.....kMd
07:51:20 <nicksoline>  0Ml.....:XMMMMMMMMMMMMMMMcMMMMMMMMNl......kMd 0Ml........lXMMMMMMMMMMMMMMMMMMMKc........kMd 0Ml..........:KMMMMMMMMMMMMMMM0,..........kMd oO:............xOOOx:'';dOOOOd............lOc
07:51:25 --- mode: ChanServ set +o Cale
07:51:29 --- mode: Cale set +b *!*@generic-nat1.unisi.it
07:51:29 --- kick: nicksoline was kicked by Cale (nicksoline)
07:51:47 <erisco> darn, I only caught the tail end of what must have been something special
07:51:56 <sevsp> Hello, is there another link for this page https://hackage.haskell.org/package/fgl-5.5.3.0/docs/Data-Graph-Inductive-Tree.html ?
07:51:59 <tsahyt> erisco: it really wasnt
07:53:06 <pyon> Myrl-saki: Sorry, I wasn't paying attention. Hai~.
07:53:25 <Myrl-saki> pyon: hai~
07:53:56 <Cale> sevsp: you can go back one version: https://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Tree.html
07:54:19 <Cale> sevsp: someone needs to give the doc generating process a kick or something, it seems
07:54:24 --- mode: Cale set -o Cale
07:55:24 <Welkin> hodapp: pokemon go
07:56:03 <Welkin> lol
07:56:09 <LKoen> Welkin: I'm actually surprised by the success of this thing. the idea is faaaaaar from new, and neither is the technology
07:56:14 <Welkin> I often have to go one version back to see the docs for packages
07:56:37 <LKoen> in fact I would bet a fair amount that there already is, somewhere on github, an amateur project that does exactly the same thing as pokemon go
07:56:41 <tzaeru_> I was pretty surprised too, and in a way I think it's a shame that it required a huge franchise and a google-startup to success.
07:56:47 <tzaeru_> but ah well, it creates room for future ideas
07:56:56 <Welkin> what google startup?
07:56:57 <tzaeru_> by making players more used to the AR concept
07:57:19 <tsahyt> oh my god, my code seems to work
07:57:27 <tzaeru_> Welkin, Niantic started as an in-company startup at google.
07:57:29 <tsahyt> that took way longer than expected
07:58:26 <LKoen> also when I was 7 year old and reading comics, augmented reality was a recurrent joke, and pokemon has just started and was very popular, so i'm pretty sure I've already seen a comic about catching pokemon in augmented reality 20 years ago
07:59:12 <tzaeru_> I've seen a lot of half-finished AR games and concepts by various local indie developers and small game companies
07:59:54 <tzaeru_> some closer to pokemon go, some further.
07:59:59 <nmattia> hey guys, is there a way to deriving the monoid instance for a newtype-wrapped list?
08:00:19 <tsahyt> nmattia: GeneralizedNewTypeDeriving
08:00:27 <tsahyt> or Newtype, not sure about the capitalization
08:00:35 <notdan> LKoen: you shouldn't be surprised by the success of Pokemon Go. It's not about technology
08:00:44 <maerwald> tsahyt: RemindsMeOfJava
08:00:47 <byorgey> tsahyt: Newtype
08:00:55 <nmattia> tsahyt: yeah, but GHC complains that there are no explicit implementations
08:01:03 <nmattia> tsahyt: which I find weird, because it's the point
08:01:10 <LKoen> notdan: that's also what I figured. but still, the concept itself is old
08:01:26 <byorgey> nmattia: can you paste the exact code and error?
08:01:41 <erisco> few buy AR to ogle at the hardware and algorithms
08:01:48 <nmattia> byorgey: I'll try to make it minimal
08:02:37 <tsahyt> okay my code does not work
08:02:46 <sevsp> thanks Cale
08:03:01 <tsahyt> apparently I run into some sort of infinite loop at some point
08:03:10 <hodapp> LKoen: the age of a concept rarely makes any difference to its commercial success.
08:03:12 <tsahyt> that'll be fun to track down...
08:03:13 <nmattia> byorgey: alright, problem comes from having DeriveAnyClass enabled as well
08:03:52 <nmattia> byorgey: and I'm getting a warning saying that it's defaulting the deriving strategy to DeriveAnyClass'
08:04:01 <nmattia> thanks everybody :)
08:04:06 <mizu_no_oto_work> LKoen: And I'd be surprised if pokego's success could be replicated by anything else
08:04:16 <LKoen> hodapp: well, this was something I heard about way before it was actually possible. when it become possible and no one did it (or rather, no one did it and became popular) I figured it was just not something people were interested in
08:04:22 <byorgey> nmattia: yeah, see https://ghc.haskell.org/trac/ghc/ticket/10598 , https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#InteractionwithGeneralizedNewtypeDeriving
08:04:43 <LKoen> and then nintendo says "hi, we did it and we're nintendo, so you just buy it ok"
08:04:52 <LKoen> they're about fifteen years late
08:05:04 <LKoen> okay I'm exaggerating a little
08:05:07 <LKoen> ten years late
08:05:08 <lpaste> tsahyt pasted ‚ÄúGND‚Äù at http://lpaste.net/169919
08:05:19 <tsahyt> nmattia: ^ see the paste. this compiles just fine for me
08:05:45 <dolio> LKoen: Maybe you should learn from this occurrence, about how it might apply to other things.
08:06:02 <maerwald> what's this talk about nintendo and pokemon?
08:06:11 <maerwald> -offtopic?
08:06:12 <LKoen> probably
08:06:15 <nmattia> tsahyt: thanks for this, it was DeriveAnyClass clashing with GNC
08:06:30 <nmattia> GND*
08:06:34 <nmattia> byorgey: thanks for the links
08:11:30 <nmattia> byorgey: considering those, what's the nicest way to handle the problem at the moment?
08:16:23 <hodapp> LKoen: The execution is more than a single concept.
08:17:00 <hodapp> Reducing it to "AR, the same thing as all other experimental AR that's been around for awhile" rather ignores that.
08:18:21 <LKoen> well, I've had a couple of friends who played it, and I looked at it while they played, and it really looks like it's nothing more than what I would have answered twenty years ago if someone asked me to describe what a simple augmented reality pok√©mon game would be like
08:18:45 <LKoen> it's actually somewhat less, because I probably would have included a scenario
08:18:49 <Welkin> lol
08:18:50 <SAL9000> I'd like to read a lazy list of JSON structures from a Handle; I'm currently using Data.ByteStream.Lazy and Data.JsonStream.Parser; is there a better way? My current solution seems to require some uncouth hackery with the internals of both of those packages, especially the former.
08:19:07 <Welkin> I remember in the 90s there was this kind of AR game where you scanned the barcode on food
08:19:18 <Welkin> the advertisements showed kids running around the grocery store and battling monsters
08:19:59 <glguy> Discussion about AR games is best for #haskell-offtopic
08:22:18 <buglebudabey> i have a stack project with main.hs in the app folder and the rest of my files in the src folder. how can i add these other files as dependencies?
08:23:26 <Cale> SAL9000: That sounds like it might actually be a use-case for pipes or conduit, since doing the management of the strict chunks by hand is likely to be quite tricky, with the JSON being of somewhat unpredictable length.
08:23:27 <lpaste> SAL9000 pasted ‚Äútest of i3status json parser‚Äù at http://lpaste.net/169920
08:23:53 <glguy> buglebudabey: You'll manage that in the .cabal file for your package
08:24:03 <glguy> buglebudabey: Are you trying to have a separate library and executable?
08:24:32 <buglebudabey> i'm not sure about the library but an executable would be good. this is honestly my first time making a stack project
08:24:51 <buglebudabey> or any package manager for that mater
08:24:54 <Cale> Oh, I see, the JSON parser you're using is already resumable, so that's a good start
08:24:58 <SAL9000> Cale: The "problem" is that the JSON comes in bursts, and ByteStream.Lazy reads in it's favored chunk size, which rarely lands on a JSON boundary -- so, information is 'delayed' by at most one burst
08:25:03 <buglebudabey> matter*, i'm following along the stack user guide
08:25:10 <zxtx> hey, if as part of my library I install a C library and C header files, where do those get written and do I have any control over it?
08:25:21 <glguy> buglebudabey: Stack just manages the building of packages. What you're trying to do is configure a cabal package
08:25:44 <glguy> buglebudabey: You can list your module directory in the hs-source-dirs
08:26:01 <glguy> buglebudabey: and you can list your main file as,  main-is: path/to/Main.hs
08:26:52 <buglebudabey> glguy by module directory do you mean just the src folder in my package or the entire root folder
08:27:21 <glguy> buglebudabey: Yeah, the src directory. All of the paths are relative to the .cabal file
08:27:35 <buglebudabey> thank you very much
08:27:47 <glguy> buglebudabey: Here's an example https://github.com/glguy/Ninjas/blob/master/Ninjas.cabal#L18
08:27:47 * hackagebot retry 0.7.4.1 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.4.1 (MichaelXavier)
08:28:31 <SAL9000> Cale: my current somewhat-horrible solution is a copy-pasted internal D.BS.L function (hGetContentsN) which then lets me read in chunks of 1 byte
08:29:09 <buglebudabey> glguy is the Main.hs in relation to the cabal file as well? so in my case since it's in the app folder would app/Main.hs be the proper path for main-is?
08:29:19 <glguy> buglebudabey: yeah
08:29:26 <buglebudabey> thanks
08:30:17 <Cale> SAL9000: yeah, that's less than ideal...
08:31:39 <dustmote> if you include a *.y (happy parser) file in your project, cabal handles it properly when compiling the project, but ghci can't load it.. any workarounds?
08:31:51 <dustmote> currently i compile the file manually with happy..
08:31:53 <buglebudabey> glguy my project requires a file to be piped in when run, how do i account for this?
08:31:58 <glguy> dustmote: You can use "cabal repl" to open GHCi with the file processed
08:32:13 <glguy> buglebudabey: Pipe in the file when you run it
08:32:32 <buglebudabey> glguy so when the executable is created that is what i pipe it into?
08:32:41 <SAL9000> Exactly. The i3bar standard "recommends" newline-terminated bursts but I'd rather not rely on that. I've done some trivial performance testing, which seems to imply that my 1 byte chunks are a non-issue at this scale -- so the solution WORKS, but I hate having to subvert library boundaries (and I'm not looking forward to keeping up with breaking internal changes)
08:32:46 <SAL9000> Cale: ^
08:34:14 <glguy> buglebudabey: Yeah.
08:34:24 <buglebudabey> thank you again
08:34:57 <hodapp> profiling just segfaulted, that's not good...
08:37:01 <dustmote> glguy: that works, except i'm using stack so i found `stack ghci` also works .. ty
08:38:53 <hodapp> I would totally track down this segfault deeper and file a bug report, but it's really not the thing I should be working on...
08:46:47 <justatech> please help me out of this problem http://termbin.com/ug0y
08:49:05 <glguy> justatech: This channel is for discussion of Haskell programming
08:49:07 <LKoen> justatech: that's... c
08:49:20 <Welkin> lol
08:49:41 <LKoen> justatech: the scanf is wrong though
08:49:59 <Welkin> haha
08:50:34 <dustmote> is there a parsing framework that supports pretty-printing and random generation?
08:50:55 <dustmote> i guess if (as glguy indicated) the AST and the parse tree aren't the same, then this wouldn't be easy to automate.
08:51:13 <lpaste> lambdafan pasted ‚ÄúClass Contraint Conundrum‚Äù at http://lpaste.net/169922
08:53:07 <nitrix> justatech: do { a <- ord <$> getChar; b <- ord <$> getChar; putChar $ chr $ a + b }
08:53:55 <LKoen> nitrix: why getChar?
08:54:16 <nitrix> I glanced too quickly.
08:56:01 <Welkin> should be: (d1, d2) <- fmap (read :: String -> Int) . lines <$> getLine
08:56:03 <LKoen> rosettacode proposes:    print . sum . map read . words =<< getLine
08:56:05 <Welkin> er
08:56:23 <Welkin> should be: d1:d2:_ <- fmap (read :: String -> Int) . lines <$> getLine
08:56:26 <justatech> LKoen you are such a nice guy thanks 
08:56:26 <Welkin> :P
08:56:37 <Welkin> oh, words, yes
08:56:39 <Welkin> not lines 
08:56:39 <Welkin> haha
08:57:04 <Welkin> dmj`: your favorite show started a new season
08:57:36 <nitrix> LKoen: Welkin It's not enough though. Looking at it, there's no lines and I suspect a[1] has an undefined value?
08:57:52 <nitrix> Pretty hard to reproduce in Haskell.
08:58:05 <LKoen> nitrix: my guess the code is wrong and he meant to input two numbers
08:58:24 <nitrix> LKoen: I'm trying to translate that to Haskell :P
08:58:30 <nitrix> It's a Haskell channel afterall.
08:58:39 <nitrix> There he left.
08:58:41 <LKoen> nitrix: in fact with this code a[0] is undefined as well, and it should result in a bus error because he tried to affect a
08:59:28 <nitrix> Oh I see what he's doing, trying to print `c`. Yeah this reaks someone playing with UB/
09:00:32 <Welkin> UB?
09:01:12 <nitrix> Welkin: Common lango in C for Undefined Behavior.
09:03:32 <nitrix> Maybe it isn't UB actually, I don't know.
09:03:59 <nitrix> I resigned from op on ##c few years ago and tried to forget as much as possible of the language ;)
09:04:09 <Welkin> lol
09:04:15 <Welkin> you were an op in ##C?
09:04:20 <Welkin> I've never been in there :P
09:06:02 <nitrix> A lot of places. ##programming being the most recent, but my interest has switched to Haskell now so I spend a lot more time on here and #haskell-beginners as well :)
09:07:34 <nitrix> The Haskell community is on a completely whole other level.
09:07:44 <nitrix> It's been quite enjoyable so far.
09:09:22 <Welkin> I agree
09:09:36 <maerwald> nitrix: you like all the nitpicking? :P
09:11:45 <Iceland_jack> <nitrix> The Haskell community is on a completely whole other level.
09:11:45 <Iceland_jack> Care to elaborate?
09:12:13 <dysfun> it's because we huff kittens
09:12:19 <Iceland_jack> Damn
09:12:30 <Iceland_jack> That was the 90's dysfun 
09:12:38 <nitrix> maerwald: I think being pedantic is very valuable. C and ##c taught be that. On the other hand, cognitive load should be as minimal as possible. Things in a language should just make sense and the community contribute to the evolution of the language & libraries, distribute their expertise, papers (like FRP) or similar.
09:13:27 <LKoen> I'm guessing #haskell is more representative of the haskell community than ##c is of the c community
09:13:37 <Iceland_jack> You have to choose your battles with pedantry
09:13:50 <dysfun> it's self-selecting. these are the people who choose to be here
09:14:22 <Iceland_jack> Should be a means to an end, not and end in and of itself
09:15:41 <nitrix> maerwald: Point is, it was a lot of time dedicated to learning all kinds of little details that amounts to nothing. For the same brain scratching, you can learn a useful generalization in Haskell.
09:16:28 <maerwald> nitrix: I find there is a lot of stuff to learn in haskell that I don't care about and are forced to because other people think it's cool
09:16:39 <nitrix> The nitpicking is also more relevant. e.g. It's not "the IO monad", it's "the IO type, used as a monad".
09:17:19 <maerwald> "the IO monad" is perfectly fine
09:17:36 <Iceland_jack> Even SPJ uses 'IO monad' :)
09:17:42 <Hafydd> Although that's true, I don't think it's a very useful thing to point out, because IO would not be useful without its monadic operations.
09:17:46 <Cale> I tend to use the words "the IO monad" when referring specifically to the monad structure
09:18:07 <Cale> Hafydd: If it didn't have the monad instance, it could be just as useful with some other operations
09:18:20 <Cale> Well, nearly so
09:18:22 <Hafydd> Cale: yes, hence "monadic operations".
09:18:25 <nitrix> maerwald: Only when referring to it used as a monad, not as if IO is always a monad. When I hear it from the mouth of a beginner, I tend to always point it out. I think it's a useful nitpicking.
09:18:34 <nitrix> maerwald: I casual lingo I'll obviously overlook it.
09:18:38 <Cale> Obviously, we do gain a bunch of benefit from having all the stuff in Control.Monad for free
09:18:52 <Cale> and e.g. having stuff like Traversable interact nicely with it
09:19:03 <Hafydd> If it used some other abstraction, it would no longer be the same type.
09:19:14 <Cale> No, it would be the same type.
09:19:23 <acowley> Not the same type if you removed an instance?
09:19:28 <maerwald> nitrix: IO is always a monad
09:19:40 <Cale> IO need not be a monad if we don't care to make it one.
09:20:16 <Cale> We can forget the fact that it's a monad, and put in some other operations for gluing actions together with similar expressiveness.
09:20:17 <nitrix> maerwald: It's not _the_ "IO monad" as if IO is that and only that.
09:20:40 <maerwald> nitrix: you are intepreting stuff that is not there
09:20:47 <dysfun> oh, do we have another IO monad?
09:21:04 <nitrix> maerwald: It's because you haven't seen it misused/taught badly recently.
09:21:15 <maerwald> because it's rarely misused
09:21:22 <Hafydd> Yes, I suppose it could remain the same type... but it seems likely that the underlying representation would change.
09:21:31 <maerwald> and just because it's misused, doesn't make the term less correct
09:21:41 <nitrix> maerwald: Spend more time on #haskell-beginners :)
09:21:42 <Cale> Maybe is an instance of Traversable, but you don't always say "the Maybe traversable"
09:21:47 <maerwald> "IO is only a monad" != "the IO monad"
09:21:48 <lambdafan> hmm, could my question be asked in a better way? Nonsensical, vague?
09:22:03 <maerwald> nitrix: again, that's irrelevant, the term is correct
09:22:13 <nitrix> maerwald: It's not that the term is incorrect, it's that beginners associate the expression "IO monad" as in "IO being only a monad".
09:22:14 <Cale> lambdafan: did you have a question?
09:22:27 <Iceland_jack> <lpaste> lambdafan pasted ‚ÄúClass Contraint Conundrum‚Äù at http://lpaste.net/169922
09:22:27 <Iceland_jack>  
09:22:30 <Cale> oh
09:22:41 <maerwald> nitrix: that misunderstanding needs to be fixed when it happens, not by nitpicking on "the IO monad" every time
09:22:48 <marrenarre> Is there any generalisation of concatMap?
09:23:00 <nitrix> maerwald: They'll do   read <$> readLine and still talk about it as the IO monad.
09:23:02 <Iceland_jack> :t concatMapOf
09:23:03 <lambdabot> Profunctor p => Accessing p [r] s a -> p a [r] -> s -> [r]
09:23:06 <nitrix> marrenarre: Which is wrong.
09:23:10 <nitrix> maerwald: *
09:23:31 <Profpatsch> What‚Äôs the nicest way to mute an Exception?
09:23:44 <Cale> lambdafan: That's probably not worth the trouble it'll take...
09:23:47 * Clint squints.
09:23:51 <nitrix> maerwald: Because they only know about IO as a monad so everytime they refer to IO, they say IO monad.
09:24:06 <Profpatsch> catchJust (guard.isAlreadyExistsError) <io> (pure ())
09:24:09 <Iceland_jack> > concatMapOf id show [[1..4], [10,20], [100,200,300]]
09:24:10 <lambdabot>  "[[1,2,3,4],[10,20],[100,200,300]]"
09:24:15 <Iceland_jack> > concatMapOf folded show [[1..4], [10,20], [100,200,300]]
09:24:16 <lambdabot>  "[1,2,3,4][10,20][100,200,300]"
09:24:19 <Iceland_jack> > concatMapOf (folded.folded) show [[1..4], [10,20], [100,200,300]]
09:24:20 <lambdabot>  "12341020100200300"
09:24:39 <maerwald> nitrix: it's not useful, unless you know there is a misunderstanding
09:24:46 <Cale> lambdafan: One thing you could do is to make the '2' and '3' into arguments to BBox and Vector. You could also make a separate type class for expressing which BBox type goes with which Vector type, and then add a superclass constraint to your KdTreeRegional type
09:24:53 <maerwald> which is why these kind of terminology debates waste a lot of time
09:25:07 <nitrix> maerwald: There's a misunderstanding most of the time, but of course.
09:25:19 <maerwald> that's just an assumption
09:25:34 <nitrix> I'm experiencing it every single day on #haskell-beginners.
09:25:35 <Iceland_jack> lambdafan: If you do what Cale suggested (make the numbers arguments to BBox and Vector) you can write
09:25:35 <Iceland_jack>     instance ... => KdTreeRegional (BBox n) (Vector n) where
09:25:37 <maerwald> if you assume misunderstandings generally, you have to nitpick on a lot more
09:25:41 <maerwald> nitrix: we are in #haskell here
09:25:53 <nitrix> maerwald: I don't nitpick on #haskell, obviously.
09:25:54 <Cale> maerwald: It's not so much a misunderstanding as I see it, as that there's a more optimal way that we can use words to shift the emphasis a bit.
09:26:12 <maerwald> Cale: which might make sense IF there is an actual misunderstanding
09:26:19 <Cale> maerwald: hm?
09:26:21 <Hafydd> The Maybe Show.
09:26:29 <maerwald> I see people nitpick on termonology while there is no misunderstanding whatsoever. And that quite frequently.
09:26:50 <maerwald> and there are not many programming language channels I have experienced that in
09:27:26 <Cale> Yeah, well, even when everyone understands things reasonably well, changes in notation and terminology can be important to structuring the way we think about them.
09:27:29 <nitrix> maerwald: If anything, it makes the two person ensure they're talking about the same thing. If that happens here, it's probably solved very quickly as the two parties are almost guaranteed to know equally as well the subject.
09:27:44 <maerwald> Cale: or it just wastes time ;)
09:27:58 <Cale> Even in cases where there's no misunderstanding, it can often be worthwhile to nitpick about terminology.
09:28:23 <Iceland_jack> lambdafan: Maybe associated type families or functional dependencies are useful (this could be of interest if you have the latest version of GHC https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilyDependencies)
09:28:59 <nitrix> maerwald: I could've chosen any other example. Functors being referred to wrappers for values or monads as burrito or whatever. Those can be usefully nitpicked as well.
09:29:08 <maerwald> nitrix: if you want to make sure you are really talking about the same thing always you have to talk about a LOT of terminology.
09:29:21 <Cale> In this particular case, I think a little too much weight is often placed on the fact that IO has a monad instance, whereas the thing which is actually important most of the time isn't so much that, as the fact that we have such a type for describing I/O actions at all.
09:29:25 <nitrix> maerwald: I don't know if we'll get to a conclusion with this kind of discussion, but I'm still sharing my experience.
09:29:46 <maerwald> that is not useful. We assume a context. And when we see discrepancy, we go deeper into terminology. Everything else is just useless nitpicking that people like to do out of intellectual fun
09:30:11 <nitrix> maerwald: Yeah. Sure. Being as pedantic as possible just makes communication less prone to misunderstanding.
09:30:19 <maerwald> I don't agree with that
09:30:20 <nitrix> maerwald: If you teach a lot, like on #haskell-beginners, it's important.
09:30:28 <puregreen> nitrix: the type of nitpicking I see here often produces the opposite ‚Äì in particular, when someone misuses the terminology and it's obvious that they meant something else, but people decide to interpret them literally
09:30:37 <maerwald> this is about spoken languages, not a formal language
09:30:47 <Iceland_jack> puregreen++
09:30:50 <Cale> It's not just intellectual fun though -- having clear definitions that put the focus in the right place is important -- even nitpicking your *own* use of terminology in private can be a productive thing, I think.
09:30:56 <nitrix> Mhhh.
09:31:06 <maerwald> puregreen: yeah, I sometimes do that too, tbh. But we should do less.
09:31:23 <nitrix> Well, I don't like where this discussion is going and the amount of people involved in it so I'm just going to withdraw myself.
09:31:46 <maerwald> nitrix: I think it's useful to talk about discussion culture.
09:32:21 <Cale> puregreen: Well, there's no need to be rude, but helping people learn the correct terminology can be really useful.
09:32:25 <hodapp> blugh. profiling is segfaulting still :(
09:32:33 <hodapp> perhaps nuking the build from orbit will magically help
09:33:09 <maerwald> Cale: terminology is not just "correct" or "not correct". There are grey areas which can be ok. There are metaphors and so on
09:33:20 <maerwald> it has to be evaluated when it happens
09:33:21 <puregreen> Cale: I agree, but then I suspect there are better ways to teach people the correct terminology ‚Äì if you're willing to sacrifice some fun that everybody else has when incorrect terminology gets mocked
09:33:23 <Cale> Sure...
09:33:36 <Cale> puregreen: heh, yes
09:34:07 <Cale> puregreen: There are times when I honestly don't understand what someone means, and they're using weird terminology
09:34:41 <Cale> Like, every time someone starts talking about "contexts" in a discussion regarding monads and they don't mean the things before the => in types.
09:34:53 <nitrix> maerwald: Yeah, we see a lot of these kind of "culture discussion" everywhere. My opinion on the subject is that it's a meta discussion. I'd much prefer show by example and strive to be an ideal communauty member than talk about what works and what doesn't in the community. There are the people that talks, and the people that do.
09:35:01 <nitrix> maerwald: Which is why I'm withdrawing from it.
09:35:34 <Cale> and I suspect that often those cases betray some sort of misunderstanding about what monads are, or how things work -- maybe not always, but usually by the time people have it figured out, they tend to prefer using different words.
09:35:37 <maerwald> and there are the people that do both
09:36:37 <maerwald> next time someone talks about an impure function he wrote, I won't say anything :P
09:37:05 <Squarism> Id hoped that : over ( boardParts.parts_deps ) (\x -> filter (\y -> y^.dep_pips > 0 ) x ) board ... would remove all items from list parts_deps that dont have property dep_pips <= 0 ? Obviously it doesnt 
09:37:09 <Cale> maerwald: what if it's not even a function? ;)
09:37:53 <glguy> Squarism: filter keeps the elements that satisfy the predicate
09:38:15 <Squarism> glguy, exactly
09:38:19 <Cale> Also, you should always put spaces around function compositions
09:38:31 <hpc> or any inline operators in general
09:38:56 <Squarism> glguy, i want to keeps all with dep_pips > 0
09:38:57 <hpc> with a veeeeeery tenuous exception for (+) and (*) if you really just want to write some math maybe
09:39:41 <Cale> But compositions especially, because while it doesn't actually matter here, Foo.bar can mean both "bar from the module Foo" and "the composition of the data constructor Foo and function bar"
09:39:49 <hodapp> Cale: oh gawd, the number of times I've seen foo.bar.baz and, without thinking, tried to parse it like field access is Java/C/C++/Python/whatever
09:40:19 <hpc> oh yeah, that's a good point
09:40:32 <Squarism> glguy, oh.. I meant to write " would remove all items from list parts_deps that dont have property dep_pips > 0 ? 
09:40:42 <Cale> hodapp: Well, to some extent, that punning is intentional in this case, but I still think it's not a great plan.
09:41:10 <Cale> (the functions in this case act like field accessors, and composition really does chain them in the way you'd expect from Java or whatever)
09:41:17 <glguy> Squarism: Did you have a question or were you just stating something you'd learned? (either is fine, I just wasn't sure)
09:42:22 <hodapp> Cale: in the cases I was thinking of, it wasn't really helping as it wasn't really like field access
09:42:33 <Cale> right
09:43:31 <hodapp> okay, I think I found my horrible space leak. I was running an iterative numerical algorithm, and I wanted a list of its error values from each iteration, so I was building up a list.
09:43:53 <Squarism> glguy, i have  types Board ( boardParts :: Parts, ..  ), Parts ( parts_deps::[Deployment], .. ), Deployment ( dep_pips::Int, ..) - i wonder why my expression :  over ( boardParts.parts_deps ) (\x -> filter (\y -> y^.dep_pips > 0 ) x ) board
09:44:20 <hodapp> and it looks like it was delaying evaluation of every single one of those errors, since I didn't need them until the very end... thus causing it to keep several large matrices around at each iteration.
09:44:34 <radoye> hey guys! what is the standard way to propagate KnowNat constraints through type families? can anyone recommend a particularly good example code showing this?
09:44:52 <glguy> Squarism: We can help you the best if you paste some loadable code to lpaste
09:44:53 <Squarism> isnt working in that it should keep Deployment's in parts_deps that satisfy dep_dips > 0
09:45:22 <zxtx> hey, if as part of my library I install a C library and C header files, where do those get written and do I have any control over it?
09:46:41 <maerwald> I didn't know cabal does that
09:46:49 <maerwald> that's usually something you do on distro-level
09:47:08 <maerwald> cabal then just picks it up e.g. the pkg-config file
09:47:14 <glguy> zxtx: Maybe give us more detail about what you're trying to do
09:48:27 <pikajude> hey, so i've been messing with the code in this blog post http://www.parsonsmatt.org/2016/07/14/rank_n_classy_limited_effects.html
09:48:32 <pikajude> and for the life of me, I cannot get it to typecheck
09:48:44 <hodapp> hmm. Let's see... 125 states times 25 actions times 2 agents times 1,000,000 iterations is... 6,250,000,000 doubles that don't need to be in memory.
09:48:57 * hodapp shakes fist at laziness
09:49:14 <pikajude> see: http://lpaste.net/169928
09:49:28 <pikajude> and I mean, logically, I can see that it wouldn't typecheck
09:49:33 <Squarism> glguy, http://lpaste.net/169926
09:49:33 <pikajude> so I'm not sure what i'm missing from that post
09:49:51 <Squarism> glguy, should keep all elements ins parts_deps
09:49:57 <Squarism> but it doesnt
09:50:17 <zxtx> glguy, maerwald, so basically I am writing a language which compiles into C
09:50:19 <glguy> Squarism: Can you make some code that loads in GHC and has the behavior you've described?
09:50:29 <zxtx> and I am I have some helper code written in C
09:51:01 <zxtx> when I emit the C code I'd like to include a header file which has this helper code
09:51:12 <eklavya> wow, just 3 days and I am in love with Haskell
09:51:19 <eklavya> it's like I have super pwers
09:51:26 <zxtx> instead of what is currently happening where the C code is stored as a giant string in Haskell
09:51:33 <eklavya> it's definitely a 10x multiplier 
09:51:37 <hodapp> eklavya: what background are you coming from?
09:51:48 <eklavya> professional in Scala
09:52:18 <pikajude> i'm confused because in order to make it typecheck I have to `lift` runHttp
09:52:24 <hodapp> I learned Scala before Haskell, and a whole lot of things didn't make sense until Haskell
09:52:51 * hackagebot safe-exceptions 0.1.3.0 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.3.0 (MichaelSnoyman)
09:54:09 <eklavya> hodapp: I barely know haskell and I am already productive in it, I wonder what's in store :P
09:54:37 <Welkin> eklavya: I find that programming in anything other than haskell ispretty much a nightmare now
09:55:09 <Henson> pikajude: what module is the runHttp function from?
09:55:18 <LKoen> hmmm the first two factorial examples at https://en.wikipedia.org/wiki/Haskell_(programming_language)#Code_examples are the same??
09:55:19 <pikajude> Henson: it's part of the MonadHttp typeclass
09:55:21 <Henson> Welkin: ha ha
09:55:29 <pikajude> Henson: if you check the blog post, you can see this is basically the first example given verbatim
09:55:53 <Welkin> and all these people I talk to have nevr heard of haskell
09:55:59 <Welkin> they think java is the state-of-the-art
09:56:06 <Welkin> ...
09:56:10 * Clint shudders.
09:56:22 <eklavya> poor souls, they don't know how good it can get
09:56:46 <eklavya> well actually in a way it's better
09:57:00 <eklavya> if they knew how good it was and still had to write Java !
09:57:25 <Welkin> ignorance is bliss
09:57:27 <Welkin> haha
09:57:33 <LKoen> I've had a roommate whose job was to write php, he actually hadn't heard about javascript
09:57:44 <eklavya> but
09:57:45 <eklavya> but
09:58:00 <glguy> The horrors of non-Haskell are offtopic in #haskell
09:58:01 <LKoen> I do not know how he could find clients
09:58:29 <eklavya> glguy: sorry, just shared my excitement :P
10:03:20 <Henson> pikajude: I think solving your problem is beyond my current understanding of Haskell :-) sorry
10:06:50 <Squarism> glguy, oh, i found it. It was actually an earlier use of "filtered" in an "over" evaluation that made it go bananas
10:07:20 <glguy> pikajude: Your example doesn't work because you defined a different Services type
10:07:26 <pikajude> did I? whoops
10:07:36 <glguy> pikajude: The one in the blog post under the heading "Abstracting the implementations
10:07:52 * hackagebot test-fixture 0.4.0.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.4.0.0 (lexi_lambda)
10:08:04 <pikajude> well, mine is a more general form of that
10:08:16 <glguy> No, yours fixes the type to IO
10:08:25 <glguy> or some other concrete "eff"
10:09:01 <glguy> 03data Services 07= Services { runHttp 07:: forall eff07. eff `InterpreterFor` MonadHttp }
10:09:12 <pikajude> If you scroll down, that's what's defined later in the post
10:10:01 <glguy> pikajude: You have to keep reading
10:10:03 <glguy> 03type Application 07= forall m07. ReaderT (Services m) m
10:10:10 <glguy> The change doesn't stand on its own
10:10:52 <pikajude> My code is just instantiating m to IO
10:11:02 <pikajude> if I define Application as that, I get an error about impredicative polymorphism
10:11:27 <Cale> This is all a really awkward way to construct the van Laarhoven free monad
10:11:36 <pikajude> but I mean, that's beside the point...runHttp cannot possibly typecheck the way he's written it
10:11:43 <pikajude> because it'll be m a, not ReaderT (Services m) m a
10:13:04 <pikajude> glguy: also no, eff is a type argument to Services
10:15:26 <glguy> pikajude: I don't know, then. It seems like the author might not have tried loading the code described
10:16:08 <Myrl-saki> How do I store passwords?
10:16:29 <Myrl-saki> Postgresql + persistent.
10:16:53 <johnw> you store a hash
10:17:01 <Myrl-saki> johnw: Yes. What should the type be?
10:17:39 <pikajude> use pwstore
10:17:43 <pikajude> it generates a ByteString
10:17:52 * hackagebot smerdyakov 0.0.0.0 -   https://hackage.haskell.org/package/smerdyakov-0.0.0.0 (jkarni)
10:17:54 <Myrl-saki> Okay.  Thanks.
10:18:25 <Myrl-saki> Oh, right. I need help on designing this.
10:20:23 <Myrl-saki> Not sure if this is the right place to ask since it's more of architecture design. So, only a few people will be able to login and you can't register through the site. My plan is to add new "users" through the command line. This generates a secret key which I will send to other people. Is this a good idea or not?
10:21:05 <liste> Myrl-saki: do they set their password with the secret key?
10:21:09 <Myrl-saki> Also, there will be no user field. Just either a file upload or a base64/hex key.
10:21:26 <Myrl-saki> liste: No. The secret key will be their permanent password.
10:21:45 <hpc> what makes it a "key" and not just an auto-generated password?
10:21:54 <Myrl-saki> hpc: Nothing.
10:22:28 <hpc> in that case, i think that scheme is a bit too weird for no benefit
10:22:35 <johnw> Myrl-saki: that's usually called "a shared secret"
10:22:35 <johnw> it's as safe as your transport medium
10:22:42 <Myrl-saki> johnw: Right.
10:22:50 <int-e> "permanent password" just sounds like a bad idea.
10:22:50 <liste> Myrl-saki: I'd prefer the users having their own passwords, then even if the key is compromised they'll be safe
10:22:53 * hackagebot clash-prelude 0.10.10 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.10 (ChristiaanBaaij)
10:22:54 * hackagebot clash-lib 0.6.18 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.18 (ChristiaanBaaij)
10:22:56 * hackagebot clash-systemverilog 0.6.7 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.7 (ChristiaanBaaij)
10:22:58 * hackagebot clash-verilog 0.6.7 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.7 (ChristiaanBaaij)
10:23:00 * hackagebot clash-vhdl 0.6.14 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.14 (ChristiaanBaaij)
10:23:11 <liste> (if the key is one-use only)
10:23:19 <Myrl-saki> liste: int-e: How about allowing it to be regenerated?
10:23:43 * hpc has debated using encryption and "encrypt/decrypt this text" as authentication in the past, but it requires users to have some technical skill
10:24:01 <hpc> if nothing else, they need to be told how to use GPG
10:24:25 <Myrl-saki> I don't think they cba for a toy-ish project.
10:25:21 <hpc> i think the best fir for you would be a totally normal user system as most sites have, and then you just turn off public registration
10:25:24 <hpc> *fit
10:25:46 <Myrl-saki> hpc: I see.
10:25:52 <int-e> Myrl-saki: I'd still ask why the users cannot provide their own password, but that may be fine. The problem with permanent passwords is that there's no fallback when a password gets compromised, other than disabling the account.
10:25:53 <liste> or limit registration to certain emails and send a confirmation email
10:26:03 <hpc> the process of creating users is the same, you make a user and send them a password out of band
10:26:14 <hpc> but they can still change it, forget it, reset it, and all those other nice things
10:26:18 <Myrl-saki> hpc: Right.
10:26:34 <Myrl-saki> hpc: Actually, I'm pretty sure that I've seen that used in a website.
10:26:50 <hpc> it's very common
10:27:30 <Myrl-saki> hpc: You register only with a username, they send an OTP through email, you login and you get sent to a password prompt.
10:28:03 * hackagebot clash-ghc 0.6.20 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.20 (ChristiaanBaaij)
10:28:26 <Myrl-saki> I get the general idea though, thanks.
10:34:07 <telmich> good evening! I'm trying to implement show for my data type (data Interval a = V a a) and tried the following definition: show (V a b) = (show a) ++ (show b), which results in No instance for (Show a) arising from a use of ‚Äòshow‚Äô error
10:34:23 <lambdafan> Iceland_jack : thanks :)
10:34:48 <glguy> telmich: You need: instance Show a => Show (V a) where
10:35:10 <Henson> Myrl-saki: I don't know if this would be useful to you, but the Yesod web framework has some examples of doing web-based authentication and authorization: http://www.yesodweb.com/book/authentication-and-authorization
10:35:13 <glguy> telmich: Also, it's better to use the default Show instance you get from "deriving Show" than to make a custom one like this
10:35:22 <glguy> Show is for debugging, not for custom formatting
10:35:50 <telmich> glguy: I understand that it's better to derive, but I'm trying to understand this part; I've instance Show (Interval a) where before my definition
10:36:08 <glguy> telmich: You need: instance Show a => Show (Interval a) where -- correction
10:37:14 <telmich> Ahhhhhh! That totally makes sense
10:38:56 <telmich> glguy: thanks a lot...grr..could have spotted that earlier
10:55:53 <Myrl-saki> So, errr..
10:56:08 <Myrl-saki> In persistent, if you make something unique, that means no two keys can be the same?
11:08:50 <Henson> Myrl-saki: yes
11:10:07 <marrenarre> Hi. I'm using GHC through Stack, on Ubuntu MATE. I'm trying to enable "warn unused imports". I tried "stack runghc -- -fwarn-unused-imports dyslectionary.hs", but I'm getting "runghc: warn-unused-imports: rawSystem: runInteractiveProcess: exec: does not exist (No such file or directory)".
11:13:05 <mekeor> marrenarre: and "stack runghc dyslectionary.h" works fine?
11:14:29 <marrenarre> mekeor: Yep. Getting the expected output from the program and everything.
11:16:51 <glguy> marrenarre: use two --
11:16:52 <mekeor> marrenarre: i'm actually also quite new to stack. i'd try out "stack -- runghc -fwarn-unused-imports dyslectionary.h"
11:17:33 <glguy> stack runghc -- -- -fwarn-unused-imports Main.hs
11:17:43 <mekeor> glguy: explanation?
11:17:54 * hackagebot qtah-generator 0.1.1 - Generator for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-generator-0.1.1 (khumba)
11:18:34 <marrenarre> It works!
11:18:52 <marrenarre> Thanks glguy.
11:18:56 <marrenarre> I'm also curious as to why.
11:19:11 <glguy> marrenarre: -- is the standard flag for ending flag interpretation and passing the flags through as an argument
11:19:24 <glguy> in this case there are a couple of layers of argument interpreters
11:19:45 <marrenarre> So there's one more layer that I didn't realise.
11:20:08 <glguy> there's stack, there's stack's runghc command, there's the actual runghc
11:21:08 <marrenarre> Oh right those two are separate. That's why stack runghc has a much shorter help message than you'd expect.
11:21:25 <glguy> marrenarre: If you wanted to pass an argument to your main program it'd be something awesome like this 
11:21:26 <glguy> stack runghc -- -- -fwarn-unused-imports -- Main.hs -wow
11:21:52 <marrenarre> Well that is quite a lot indeed.
11:22:34 <Henson> wow
11:22:54 * hackagebot ltext 0.1.2 - Higher-order file applicator  https://hackage.haskell.org/package/ltext-0.1.2 (athanclark)
11:24:48 <RyanGlScott> I need some English help. What is an adjective/word that describes what Functor, Foldable, and Traversable have in common?
11:26:15 <dmwit> RyanGlScott: What is a phrase or sentence that describes what they have in common?
11:26:32 <agrue> "abstractness" ;)
11:26:48 <RyanGlScott> dmwit: The context is that I'm deriving classes of kind * -> *, and I have to bake in a special case for those three classes.
11:27:08 <RyanGlScott> So I need some succinct way to refer to them as a group.
11:27:16 <dmwit> RyanGlScott: built-in
11:27:47 <RyanGlScott> dmwit: Hm... perhaps. The problem is that another * -> * class (Generic1) is also built-in...
11:27:51 <dmwit> There are a few other built-in classes on (* -> *) kinds, though.
11:27:55 <dmwit> indeed
11:28:15 <RyanGlScott> The best I've been able to think of is "functor-like", which is a bit vague.
11:28:23 <dmwit> RyanGlScott: So, I ask again: what is a phrase or sentence that describes what they have in common (but what Generic1 and Monad do not have)?
11:28:43 <RyanGlScott> Well, this is a bit contrived, but here goes...
11:29:14 <RyanGlScott> "When deriving Functor, Foldable, and Traversable, you need to inspect function argument types for contravariance. For other classes, you don't."
11:30:20 <dmwit> I think I would just take the key words from that, and add a comment with a fuller explanation.
11:30:29 <dmwit> e.g. ContravariantArgument or something.
11:30:42 <RyanGlScott> Well, it's not the _only_ thing that sets them apart...
11:30:53 <RyanGlScott> But yeah, I'm having a tough time coming up with something catchy.
11:31:20 <dmwit> The comment with the fuller explanation can include all the precise details that are glossed over in the short version.
11:31:36 <RyanGlScott> Alright, "functor-like" it is :)
11:32:16 <mgsloan> glguy: Clever!  For clarity one could also do "stack exec -- runghc --", it is equivalent
11:42:56 <buglebudabey> if i want to include Data.Map in my cabal dependencies is it 'containers' i have to put?
11:43:32 <glguy> buglebudabey: Yes. In general you can use the "ghc-pkg find-module" command to help you with that question
11:43:57 <glguy> (if you already have the package installed)
11:47:55 * hackagebot DAV 1.3.1 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.3.1 (ClintAdams)
11:50:04 <noffle> hi. it is likely elementary, but why does the expression "[x | x <- [1..5]]" have type "(Num t, Enum t) => [t]" and not just "[Num]"?
11:50:21 <noffle> is it because it hasn't yet been evaluated?
11:50:31 <buglebudabey> thanks, glguy. i actually put that containers and stack still cannot find it
11:51:06 <monochrom> [Num] is nonsense.
11:51:13 <glguy> noffle: Num is a constraint constructor, t is the type, Num t is a constraint
11:51:26 <mgsloan> buglebudabey: What does "stack exec -- which ghc" say?
11:52:10 <SAL9000> noffle: It's (Num t) => [t] because it's a number, and (Enum t) => [t] because it's sufficiently similar to an enumeration -- you can get previous and next elements (pred/succ)
11:52:13 <buglebudabey> .stack/programs/x86_64-osx/ghc-7.10.3/bin/ghc mgsloan 
11:52:18 <SAL9000> a list of numbers*
11:52:27 <monochrom> This is why classes are not "like Java interfaces". A Java interface can be used as a type; a class cannot.
11:52:33 <mgsloan> glguy: On closer inspection, I don't think the extra "--" is needed.  Why would it be?  There is just stack and the runghc, no middle layer
11:52:38 <bollu> hey guys
11:52:48 <bollu> I just came to gush about how I'm _loving_ coq
11:52:58 <bollu> oh my god, software foundations is so much fun to solve
11:53:04 <bollu> Coqide is buggy on mac os though
11:53:08 <bollu> does anyone have any replacements?
11:53:12 <merijn> bollu: Coqide is crappy as hell
11:53:15 <merijn> bollu: vim or emacs?
11:53:16 <shapr> bollu: I just heard about SF recently, it does look like fun
11:53:21 <glguy> mgsloan: try running a hello world module without it
11:53:22 <bollu> merijn: vim please?
11:53:41 <merijn> bollu: lemme lookup the plugin
11:54:01 <mgsloan> glguy: Ahh I see, I forgot how runghc works, good point!
11:54:19 <bollu> merijn: thanks a lot! Out of curiosity, is the emacs plugin tactics general?
11:54:26 <bollu> it was ... meh 
11:54:29 <mgsloan> buglebudabey: What you actually want is "stack runghc -- hello.hs -- -fwarn-unused-imports"
11:54:35 <merijn> bollu: Proof General, yes
11:54:46 <buglebudabey> mgsloan  i do?
11:54:49 <merijn> bollu: I was looking for a replacement for that for vim and found Coquille: https://github.com/the-lambda-church/coquille
11:54:49 <EvanR> bollu: theres a channel for coq
11:55:02 <mgsloan> buglebudabey: Yeah, or what glguy suggested, this is slightly shorter
11:55:02 <bollu> merijn: thank you :)
11:55:09 <merijn> bollu: Note, it depends on https://github.com/let-def/vimbufsync (else you'll wonder for 15 minutes why it doesn't work, like me)
11:55:26 <bollu> EvanR: I've been told, but Cale (I think) told me that most Coq people hang out on #haskell anyway, plus there's more people
11:55:44 <buglebudabey> mgsloan it finds it now, but now i have a new problem which ill try to fix then get back to you
11:55:44 <merijn> bollu: And here's some useful shortcuts: https://github.com/merijn/dotfiles/blob/master/dotfiles/vim/ftplugin/coq.vim
11:55:46 <EvanR> ok but thats a slippery slope
11:55:47 <bollu> merijn: many thanks :')
11:55:57 <bollu> EvanR: in the sense?
11:55:58 <Cale> Well, you can still probably talk about Coq in #coq
11:56:01 <glguy> bollu: Coq is offtopic in #haskell whether or not there is community overlap
11:56:17 <EvanR> bollu: not many people in #beer... lets just use haskell
11:56:31 <bollu> EvanR: haha, I see.
11:56:37 <noffle> SAL9000: since "(Num t, Enum t)" is stronger than "(Num t)", why can't I say "c :: (Num t) => [t]" if "c = [x | x <- [1..10]]"?
11:56:39 <merijn> tbh, I talk about type theory and coq stuff in here too if it's quiet >.>
11:57:02 <EvanR> isnt there a type theory channel
11:57:13 <noffle> does it need to care whether I got a list via a comprehension or via just writing [1..10]?
11:57:15 <hpc> the subtlety there is that general type theory is on-topic if it can come around to being relevant to haskell in some way
11:57:17 <merijn> EvanR: Not one that was half as constructive/informed as #haskell :)
11:57:27 <hpc> which is why you see a lot of theory talk happening here
11:57:33 <bollu> merijn: I really think I'll stay up tonight doing the book till like, chapter 3 or something. It's addictive
11:57:43 <bollu> merijn: it's all the fun of math with all the tooling of programming
11:57:44 <hpc> but "i like coq and this is the ide i use" isn't theory ;)
11:57:52 <bollu> hpc: fair enough :)
11:58:13 <buglebudabey> mgsloan http://lpaste.net/169944 here is my new problem, my project successfully ran before this
11:58:29 <bollu> merijn: can you encode the theory of sets in Coq?
11:58:50 <bollu> merijn: I want to do "normal" math in Coq maybe. Prove group theory stuff?
11:58:54 <merijn> bollu: I think it shouldn't be too hard
11:59:08 <glguy> noffle: (Num t) isn't strong enough to write [1..10] which requires *both* Num t, and Enum t
12:00:22 <monochrom> "1" requires Num. "[x..y]" requires Enum. And they don't imply each other. I don't understand the "stronger" attempted-argument.
12:00:24 <merijn> hpc: To be fair, CoqIDE is really freaking terrible and the fact that something other than Proof General (i.e. Coquille for vim) exists is really hard to find, so I can understand the frustration leading to that question :)
12:00:46 <hpc> heh, fair
12:00:52 <merijn> hpc: I mean, CoqIDE doesn't even have a "jump to beginning/end of line" shortcut key...(home and the osx binding don't work...)
12:00:53 <hpc> it'd probably be a good question for -offtopic in any event
12:01:17 <noffle> hm. I guess I figured since [1, 2, 3] is (Num t) => [t], you could consider a range that produced a list to be the same
12:01:28 <noffle> I'm new at this :)
12:01:50 <mgsloan> buglebudabey: Glad the issue is resolved! I've got stuff to do, though, I imagine someone here might be keen on helping you with type errors 
12:02:10 <buglebudabey> alright thank you mgsloan 
12:02:16 <hpc> :t [1, 2, 3] -- noffle
12:02:17 <lambdabot> Num t => [t]
12:02:22 <hpc> :t [1 .. 3] -- noffle
12:02:23 <lambdabot> (Enum t, Num t) => [t]
12:02:31 <hpc> they're almost the same
12:02:53 <hpc> usually any types that are instances of Num that you encounter will also have an Enum instance
12:02:53 <noffle> hpc: right. so a function that accepted "(Num t) => [t]" couldn't accept the latter?
12:03:01 <hpc> it could
12:03:10 <noffle> ah
12:03:18 <hpc> maybe you're having a different issue?
12:03:23 <hpc> @where lpaste
12:03:23 <lambdabot> http://lpaste.net/
12:03:49 <noffle> multiple issues, it would seem :)
12:04:56 <noffle> hpc: Q was partially related; trying to print a cartesian product of lists to stdout (http://lpaste.net/2600383778949955584)
12:05:11 <buglebudabey> glguy  would you mind helping me with this? http://lpaste.net/169944, I'm getting a type error even though in my Types file I define "type Name = String", it happens when i build my project in stack
12:05:19 <monochrom> > [1 .. 2] :: [Complex Double]
12:05:21 <lambdabot>      No instance for (Enum (Complex Double))
12:05:21 <lambdabot>        arising from the arithmetic sequence ‚Äò1 .. 2‚Äô
12:05:21 <lambdabot>      In the expression: [1 .. 2] :: [Complex Double]
12:06:03 <ReinH> buglebudabey: did you read the error?
12:06:04 <noffle> hpc: updated /w what I'm trying to run on those defs
12:07:06 <monochrom> the error message does not impeach Name and String. it impeaches two different types both called Expr.
12:08:51 <buglebudabey> monochrom I only define Expr in one place though, but its polymorphic
12:09:25 <buglebudabey> data Expr a = ...., type CoreExpr = Expr Name
12:09:27 <monochrom> yet there is a second version in package "core-compiler-0.1.0.0"
12:10:01 <hpc> noffle: when you use map like that, you end up with a value of type [IO ()], which ghci can't show
12:10:07 <hpc> you should use mapM or similar
12:11:14 <glguy> buglebudabey: CoreProgram and [(String, [String], Expr String)]   don't seem to match from that error message, should they?
12:11:17 <noffle> hpc: ah, mapM did the trick
12:11:34 <noffle> not sure I understand what it's doing though
12:11:38 <hpc> :t map putStrLn
12:11:39 <lambdabot> [String] -> [IO ()]
12:11:56 <buglebudabey> a CoreProgram is [(Name, [Name], Expr Name)], and type Name = String -- glguy 
12:12:00 <hpc> map applies a function to every value of a list
12:12:03 <hpc> :t putStrLn
12:12:04 <lambdabot> String -> IO ()
12:12:06 <hpc> :t map
12:12:07 <lambdabot> (a -> b) -> [a] -> [b]
12:12:19 <hpc> when you apply something show-y (putStrLn as an example)
12:12:23 <hpc> a = String, b = IO ()
12:12:29 <glguy> buglebudabey: Oh, then the problem is probably that Expr doesn't match
12:12:38 <hpc> :t mapM
12:12:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:12:39 <glguy> buglebudabey: and the package qualifier is probably there because you have two different Exprs
12:13:00 <hpc> noffle: when you do the same with mapM, a = String, m = IO, b = (), t = []
12:13:17 <buglebudabey> glguy is it because i defined Expr as a parametric type? I only define Expr once parametrically, but again in a concrete context of Expr Name
12:13:21 <hpc> noffle: and you get mapM putStrLn :: [String] -> IO [()]
12:13:29 <hpc> :t mapM_
12:13:29 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
12:13:52 <buglebudabey> glguy this is the relevant portion http://lpaste.net/169947
12:14:01 <hpc> noffle: there's also a variant that discards the accumulated results, so ghci doesn't spit out a bunch of [(), (), (), (), (), (), (), ...]
12:14:27 <glguy> buglebudabey: This usually happens when you installed a library that defined a type and then you also have that module in the search path when loading your file
12:14:37 <glguy> so you have two different types with the same name
12:15:21 <glguy> buglebudabey: When this happens GHC tries to distiguish the two overlapping names with a package qualifier
12:15:23 <noffle> hpc: thank you for explaining. trying to wrap my head around that.
12:16:00 <glguy> buglebudabey: If you have an executable and library in the same .cabal file they can't use the same hs-source-dirs:
12:17:16 <buglebudabey> glguy this is my cabal http://lpaste.net/7496799457355235328
12:17:29 <glguy> buglebudabey: OK, then that's the likely problem
12:17:51 <glguy> you need *separate* directories for your  executable and library sections' hs-source-dirs: , they can't both be src
12:17:58 <buglebudabey> is it from including Lexer and Parser in the same place as Lib under exposed-modules?
12:18:08 <monochrom> yeah please don't use "hs-source-dirs:      src" for both. pretty please. this is an order.
12:18:47 <glguy> As it is you're building all the modules twice and incompatibly
12:19:06 <buglebudabey> ah ok this was generated from the template, i've only added the dependencies and alex, happy stuff
12:20:52 <buglebudabey> is this better monochrom glguy http://lpaste.net/169948
12:21:08 <buglebudabey> i made a new folder and put my main in that so i don't compile src twice
12:21:33 <monochrom> maybe. I cannot test it.
12:24:17 <buglebudabey> monochrom it can no longer find the modules i import from main because they are in the src folder. do you know what would be best practice in order to get those? just add them as build dependencies in the executable section?
12:25:04 <monochrom> do you know that "package" and "module" are different?
12:26:35 * yyyyy is happy to find `f <.$.> xs = parMap rpar f xs` is enough to get a free boost on cpu utilisation.
12:28:33 <buglebudabey> yes monochrom 
12:28:44 <buglebudabey> monochrom but i am new to stack
12:28:50 <monochrom> do you know that "build-depends:" lists packages not modules?
12:29:14 <buglebudabey> that i missed
12:29:44 <monochrom> this is why stack is not easier than cabal on beginners, despite all the enthusiastic experts.
12:30:41 <monochrom> if you use stack, you are forced to be a package author, not just an end-user of other people's packages. there is a big difference. a package author actually has to know what "package" means.
12:31:05 <monochrom> cabal does not force that.
12:31:11 <EvanR> a roving band of enthusiastic experts
12:31:20 <buglebudabey> i thought cabal was a package manager as well?
12:31:51 <monochrom> once again, experts' favourite methods and opinion leaders' recommendations are utterly inapplicable to the rest of us.
12:32:20 <EvanR> buglebudabey: cabal isnt a package manager
12:32:29 <EvanR> its a build system
12:32:39 <buglebudabey> ah ok
12:32:42 <monochrom> I wouldn't argue what cabal is. but it does not force you to packagize your project.
12:32:57 * hackagebot cmark 0.5.3 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.3 (JohnMacFarlane)
12:33:12 <buglebudabey> i'm not opposed to using cabal, i only thought stack was easier, but i guess it's not :P
12:33:20 <buglebudabey> or at least not necessary in my situation
12:33:32 <buglebudabey> i simply wanted to build my project for others to use
12:33:33 <maerwald> buglebudabey: exactly, its not
12:34:02 <buglebudabey> if i wanted to put my project on hackage i wouldnt need stack either, would i?
12:34:04 <EvanR> buglebudabey: like, a binary distributable?
12:34:28 <buglebudabey> EvanR probably not, it's just a simple core compiler
12:34:30 <travism> How do i get correct the ambigious interface .. it was found in multiple packages?
12:34:31 <maerwald> buglebudabey: no you dont need it
12:34:50 <monochrom> there are a lot more to learn about package authoring before you can share your package.
12:35:13 <EvanR> buglebudabey: cabal install can download and install binaries hosted on hackage, which is a weird feature to me
12:35:26 <buglebudabey> alright, i'll back up and try to make this a cabal build instead
12:35:27 <hexagoxel> monochrom: interesting point. new-build will force people to write packages as well, so cabal actually loses one potentially important use-case?
12:35:31 <monochrom> at this point I don't know which one is your learning objective: to learn FPL implementation; to learn package authoring.
12:35:42 <marchelzo> hello. is there an option for ghc or runhaskell so you can specify the source code as a program parameter? like sh -c
12:35:53 <EvanR> buglebudabey: cabal-install being a separate program of its own
12:36:54 <buglebudabey> can i install cabal from stack?
12:37:06 <buglebudabey> don't even have cabal set up anymore after getting rid of my haskell platfom
12:37:07 <woffs> marchelzo, such a wrapper would be handy for one-liners :-) but I don't know such a tool yet
12:37:10 * EvanR goes to find a synopsis of stack's advantages, since most of the opinion in here is negative
12:37:24 <mgsloan> That's just the vocal opinion
12:37:31 <mgsloan> The rest of us are, you know, getting things done
12:37:58 <EvanR> actually, good point
12:38:08 <monochrom> oh stack has a lot of advantages. for experts. for example multiple GHC installations that don't know of each other.
12:38:22 <monochrom> (why would a beginner need it?)
12:38:25 * EvanR buries head in paperwork
12:38:27 <mgsloan> buglebudabey: You can!  Btw you should not install stack via cabal.  It might pick dependencies that cause bugs, this has happened in several issues on the stack tracker
12:38:28 <merijn> monochrom: GHC already does that by itself, though?
12:38:37 <maerwald> monochrom: yeah, but he asked if he needs it to maintain a package on hackage, and the answer is no
12:38:45 <yyyyy> i find stack really invaluable to shipping things here, specially if a project is using different versions of packages than others. before that i was using cabal sandbox and the build times were awful, since it wouldn't use previous artifacts from other projects.
12:38:46 <merijn> monochrom: GHC databases are per version, so you can just switch versions by having them on different paths
12:38:48 <mgsloan> monochrom: The reason is that cabal encourages you to mutate state that breaks things.  It also does not help you with your ghcs
12:39:04 <mgsloan> It can be really hard for newcomers to get there environment setup, stack solves that
12:39:07 <buglebudabey> mgsloan i downloaded stack on its own, not with cabal. how can i install cabal from stack?
12:39:07 <merijn> mgsloan: How does cabal need to help you? It just uses whatever GHC is on your path?
12:39:42 <monochrom> for example a better project story if you already know how to be a package author. (why would a beginner already know how to be a package author?)
12:39:45 <merijn> Anyway, I've long ago concluded I just don't "get" stack, so I just avoid judging either way :)
12:39:53 <yyyyy> buglebudabey: you already have cabal-the-library with stack.
12:39:53 <mgsloan> merijn: I regularly use 3 or 4 different ghc versions, and I expect all the related ghc based binaries to also use those ghc versions.  Stack supports this workflow very nicely
12:40:15 <buglebudabey> yyyyy i dont have the cabal commands though such as cabal install
12:40:16 <mgsloan> It is really really convenient that all your binaries are the right versions
12:40:18 <yyyyy> if you want to have the `cabal-install` executable then i suppose `stack install cabal-install` will work.
12:40:42 <mgsloan> yyyyy: No, that will crash because cabal doesn't know how to handle GHC_PACKAGE_PATH
12:41:06 <mgsloan> ERrr sorry I misread
12:41:08 <mgsloan> You can do that
12:41:10 <yyyyy> mgsloan: i never tried it from stack. i have been using stack exclusively for a while now.
12:41:14 <mgsloan> I thought it was "stack exec cabal"
12:41:53 <mgsloan> Actually, stack does invoke the cabal-install executable.  You can do "stack init --solver" to determine a stack.yaml based on a combination of snapshot and solver results
12:41:55 <yyyyy> i suppose once it installs under `.local/bin` it will setup `.cabal` after its first run by itself.
12:42:17 <mgsloan> But it only runs cabal-install when we want solver results, which isn't all that often.  When I do want it, very handy!
12:42:26 <bollu> hm, I didn't realize it had changed under FTP
12:42:35 <monochrom> mgsloan, today I'm exactly challeging the claim of easier beginner setup, by the empirical evidence we see today. stack forces packagizing your project. you need to learn a lot of distracting meta-knowledge, such as "package vs module", such as "build-depends lists packages not modules", such as "your exposed-modules list has to be long enough", such as etc etc. How is it easier to set up for beginners?
12:43:18 <bollu> monochrom: but the knowledge is a one time thing. But stack as a tool is brilliant to actually build things
12:43:31 <mgsloan> monochrom: Fair point, stack indeed could use refinement for the non-package caser
12:43:34 <bollu> monochrom: I personally hated dealing with cabal and sandboxes as a noob
12:43:35 <monochrom> oh sure, learning all of Haskell is also a one-time thing.
12:43:38 <buglebudabey> this is all getting very convoluted, if i simply want to create a cabal project, what should i do if all i have is stack?
12:43:40 <bollu> monochrom:  :)
12:43:52 <maerwald> monochrom: yeah and I also have a problem with that false advertisement that it solves "all your cabal problems"
12:43:55 <mgsloan> buglebudabey: "stack new" is probably a good start
12:44:04 <woffs> for me, there are 3 steps: (1) using the ghc and libraries my OS brings along. (2) get missing libraries with cabal. (3) escape from the cabal dependency hell with stack.
12:44:04 <mgsloan> maerwald: Who said that?
12:44:07 <buglebudabey> mgsloan i've done this, i'm on the stack build step
12:44:12 <maerwald> mgsloan: most stack users in here
12:44:17 <bollu> monochrom: I started around four months before stack launched I think. I would have to either sandbox every project and recompile everything, or allow cabal hell to creep up
12:44:30 <bollu> monochrom: stack really really helps.
12:44:58 <mgsloan> maerwald: Ok, well, their experience is coming from somewhere.  Stack has no equivalent of the productivity killing cabal hell
12:45:07 <monochrom> sandboxing is a good idea, but it should not imply packagizing.
12:45:15 <maerwald> mgsloan: lol
12:45:29 <yyyyy> bollu: you should have seen it before cabal sandbox. i nuked my ghc packages every once in a while. even had a script to do it.
12:45:32 <monochrom> and I feel that "packagizing" is not long enough. maybe "packagification"
12:45:43 <mgsloan> maerwald: Seriously, I've spent waay too much time, years ago, scratching my head looking at solver errors.  It's miserable
12:45:53 <maerwald> mgsloan: and I have the opposite experience, so.
12:46:03 <mgsloan> maerwald: That's because you know how to use cabal well
12:46:08 <bollu> monochrom: also, stack has docs that are informative. I'm sorry, but the cabal docs are sorely lacking. They read like git documentation
12:46:15 <maerwald> mgsloan: no, it's because the dependencies are less incorrect these days
12:46:42 <mgsloan> Because hackage trustees, build matrix, and stackage, I imagine
12:46:52 <bollu> yyyyy: I can imagine
12:47:35 <mgsloan> monochrom: Thing is, stack does support package-less environments quite nicely.  It's just not as up-front in the docs and cli.  I'll consider how to address this
12:47:54 <mgsloan> (package-less env == just deps for running code / ghci)
12:48:38 <noimnotninevolt> hey, perhaps semi-offtopic, but does anyone know of a good learning resource for learning functional programming coming from a long, strongly-ingrained imperative programming background?
12:49:01 <yyyyy> mgsloan: you can use the global package database and just `stack ghc`, no?
12:49:12 <yyyyy> if you mean one-off scripts.
12:49:16 <Unicorn_Princess> using stack to build a project, i have to add the .hs modules i write to the exposed-modules of the 'library' field in the .cabal file, right? but, following learnyouahaskell, i made the Geometry.Cuboid and .Cube modules, and only added Geometry.Cube to exposed-modules. and it compiled, despite .Cube depending on .Cuboid, which i didn't add! why?
12:49:22 <mgsloan> yyyyy: Yeah, that'll use your global project, which can have more than just the global DB
12:49:35 <mgsloan> But your global project indeed usually won't have local packages
12:49:41 <noimnotninevolt> is there a haskell analogue to 'k&r the c programming language' or something?
12:50:01 <bollu> noimnotninevolt: maybe LYAH (learn you a haskell)
12:50:10 <noimnotninevolt> yea, that's what's been recommended to me...
12:50:10 <monochrom> yes, The Gentle Introduction to Haskell is analogous to K&R
12:50:14 <maerwald> bollu: wat???
12:50:16 <yyyyy> mgsloan: true. but they can be added without issues. the person just has to look into their `stack.yaml` file.
12:50:17 <woffs> noimnotninevolt, just what https://www.haskell.org/documentation says
12:50:22 <bollu> maerwald: oh wait, I didn't see the K&R part
12:50:31 <yyyyy> arguably a beginner wouldn't know where to look, but the documentation is quite ok, i think.
12:50:37 <maerwald> bollu: my blood pressure, please :D
12:50:44 <bollu> maerwald:  :)
12:50:47 <EvanR> really, K&R is almost universally recommended for C beginners whereas Gentle Introduction is not
12:51:04 <mgsloan> Unicorn_Princess: It usually warns about that.  Yes, it's weird.  Leaving modules out of hidden / exposed modules often doesn't cause compilation issues, instead linking issues
12:51:09 <buglebudabey> noimnotninevolt i'd recommend LYAH for a subset of the syntax but that's as far as that book goes, definitely not the K&R book. people keep trying to make one but nothing is the goto
12:51:22 <noimnotninevolt> hrm.
12:51:23 <EvanR> bird's book...
12:51:24 <noimnotninevolt> fair enough.
12:51:27 <monochrom> I do not actually recommend K&R to most beginners
12:51:44 <Unicorn_Princess> mgsloan: thanks
12:51:50 <buglebudabey> noimnotninevolt i'd try to soak up as much as you can and stay in this channel
12:52:01 <monochrom> there is a book by King I recommend for learning C
12:52:01 <noimnotninevolt> but but but haskell makes my head hurt :P
12:52:27 <monochrom> I myself learned C from K&R, and Haskell from Gentle, and I did find them alike.
12:52:28 <agrue> noimnotninevolt: #haskell-beginners may also be helpful to you
12:52:37 <noimnotninevolt> sweet, thanks.
12:52:47 <agrue> feel free to ask questions there
12:52:59 <noimnotninevolt> yea, i'll definitely be better off there. i'm beyond noob :P
12:52:59 <Unicorn_Princess> is there a way to tell the .cabal file to just expose as modules all the .hs files in some directory?
12:53:19 <monochrom> no, I think you have to list them explicitly
12:53:39 <monochrom> alternatively, simply don't write a *.cabal file
12:53:40 <Unicorn_Princess> also, will i for sure get an error if i leave some out accidentally  - no chance of like undefined behaviour happening, right?
12:54:07 <Unicorn_Princess> i didn't know not having a cabal file was an option
12:54:14 <monochrom> you, the package author, won't get an error. your users will run into problems.
12:54:34 <Unicorn_Princess> (i'm using stack to build, as i understand is The Way)
12:54:45 <Welkin> what is Gentle?
12:54:55 <monochrom> The Gentle Introduction to Haskell
12:55:11 <Welkin> Unicorn_Princess: no, it is one way
12:55:19 <Welkin> there is no single way to do anything in haskell
12:55:35 <Welkin> you don't even need to use monad transformer stacks any more with Free/Freer
12:55:40 <maerwald> it's the opposite of python philosophy
12:55:52 <bollu> Welkin: hm? what's the bit about monad stacks?
12:56:11 <bollu> I have a question about free monads actually
12:56:11 <monochrom> stack -> monad transformer stack -> monad
12:56:24 <bollu> since a free monad is, well, "free"
12:56:33 <bollu> is there a well defined way to "quotient" it to get any other monad out?
12:56:44 <bollu> the way group presentations work?
12:56:46 <Iceland_jack> bollu: foldFree
12:56:53 <bollu> is there a similar "monad presentation" or something?
12:56:56 <Iceland_jack> Then compare 'foldFree' to 'foldMap'
12:57:02 <Iceland_jack> And notice it's basically the same thing
12:57:02 <monochrom> I think writing an interepreter is a quotienting
12:57:03 <bollu> Iceland_jack: I'll check that out
12:57:16 <bollu> monochrom: in what sense?
12:57:38 <bollu> Iceland_jack: oh, nice. 
12:57:54 <Iceland_jack>     foldFree :: Monad  m => (f ~> m) -> (Free f ~> m)
12:57:54 <Iceland_jack> v
12:57:54 <Iceland_jack>     foldMap  :: Monoid m => (a -> m) -> ([a] -> m)
12:58:12 <bollu> Iceland_jack: because monad is a monoid at heart?
12:58:26 <bollu> monoid of endofunctors but still
12:59:13 <Welkin> Iceland_jack: what's with the ~> ?
12:59:26 <Iceland_jack>     type f ~> g = forall xxx. f xxx -> g xxx
13:02:29 <Iceland_jack> bollu: I'm not sure that's why
13:02:50 <Iceland_jack> They're both free objects
13:03:13 <Iceland_jack> [a] is generated by a, 
13:03:13 <Iceland_jack> 'Free f a' is generated by the functor 'f'
13:04:12 <bollu> Iceland_jack: ah, I see
13:04:20 <Iceland_jack> Given any function (forall x. f x -> m x) there is a unique function (forall a. Free f a -> m a)
13:04:31 <Iceland_jack> that is a monad homomorphism iirc
13:06:57 <nitrix> Are there people that dislike FRP?
13:07:03 <johnw> wouldn't you need a Monad m constraint for it to be a monad homomorphism?
13:07:16 <nitrix> I "get" it, but it still always leaves me frustrated.
13:07:30 <Iceland_jack> johnw: there is
13:07:41 <Iceland_jack>     foldFree :: Monad m => (forall x. f x -> m x) -> (forall a. Free f a -> m a)
13:07:48 <johnw> ok
13:07:48 <nitrix> My main complaint with reactive-banana is that states are scaterred all over the application, and cannot be saved/loaded easily.
13:09:55 <nitrix> Also, having side effects only at the input or outout end is maddening at times.
13:10:09 <maerwald> nitrix: did you do GUI programming with it?
13:10:14 <nitrix> maerwald: Video game
13:10:29 <nitrix> The game also has a minimal UI.
13:10:33 <maerwald> ok, I was once considering to use FRP for GUI stuff, but stopped when I realised there are barely any bindings
13:10:57 <maerwald> and that the creator told me I'd probably need a few months to get his types
13:11:39 <maerwald> I guess it's too early to have a simple solution on that end yet
13:12:00 <nitrix> I'm wondering if I'm still just not in the right state of mind to fully grasp FRP or if it's just how things are, experimental and not guaranteed that the pros outweights the cons.
13:12:21 <nitrix> You sure hear a lot about it, but how many people use FRP vs. doesn't use it for games, in Haskell?
13:12:31 <nitrix> "Games in Haskell" is already very niche.
13:13:05 <johnw> how would we know that?  I don't think there's anywhere here conducting surveys among all Haskell developers
13:13:21 <nitrix> johnw: We tend to know by asking.
13:13:24 <nitrix> I'm asking.
13:14:07 <johnw> I'm wondering how you can ever get an accurate answer
13:14:55 <maerwald> nitrix: I think FRP is often more complicated than the problem you are trying to solve. The solution might be "elegant" in a way, but that's not enough for me.
13:15:21 <nitrix> A global sentiment would be sufficient. How it's perceived theorically and in practice is more valuable to me than doing complex evaluations about the accuracy.
13:15:41 <maerwald> johnw: join #haskell-games and ask
13:16:08 <nitrix> I'll take that advice. Maybe #haskell-games have hints on the matter.
13:16:32 <schell> maerwald, nitrix: #haskell-game ;)
13:16:39 <maerwald> oh, thanks
13:16:42 <nitrix> maerwald: It's my experience so far. The promise is great, but Haskell seems to have already most of what's needed in the form of monads, monad transformers and similar.
13:16:48 <schell> let‚Äôs chat - i‚Äôm in there
13:17:58 * hackagebot PathTree 0.1.0.0 - A tree used to merge and fold paths  https://hackage.haskell.org/package/PathTree-0.1.0.0 (pjrt)
13:19:30 <maerwald> nitrix: but then again, haskell is not a very practical language (compared to e.g. java), so people also try stuff that at first sight might seem odd to try
13:19:32 <maerwald> which is good
13:20:24 <maerwald> it's like haskallers are always half researchers :P
13:22:21 <maerwald> which (sometimes) is also the reason you don't see too much KISS lovers
13:22:29 <Iceland_jack> Games in Haskell:
13:22:29 <Iceland_jack>   1. Create an EDSL that generates x86
13:22:29 <Iceland_jack>   2. Write game in EDSL
13:22:36 <Iceland_jack> obviously
13:22:48 <sm> nitrix: another way is to review published software (hackage games category, github projects etc.). IIRC no non-trivial games using FTP exist except frag
13:23:01 <sm> FRP. Not even frag uses FTP :)
13:23:16 <maerwald> sm: was it not AFRP?
13:23:39 <sm> maerwald: probably
13:24:04 <sm> IIRC roguestar also uses some *FRP
13:24:24 <Welkin> ocharles wrote a 3d doom clone using frp I think
13:24:26 <Welkin> netwire?
13:25:27 <sm> here's a simple research project: annotate the hackage games list with interesting info: architecture, lines of code, buildability, platform compatibility, completedness
13:26:29 <maerwald> would be surprised if frag still builds 
13:27:04 <maerwald> someone should probably curate that
13:27:05 <sm> key libs used
13:36:53 <hsk3> hugeMap :: Data.Map.Map Integer Integer
13:36:54 <hsk3> hugeMap = <construct huge map. takes a while>
13:36:55 <hsk3> otherFunc :: Something
13:36:56 <hsk3> otherFunc = <code that uses hugeMap many times>
13:36:57 <hsk3> Does Haskell automatically make sure that hugeMap is computed only once?
13:37:05 <hsk3> assuming hugeMap and otherFunc are global functions.
13:40:30 <Welkin> yes, because you named it
13:41:09 <buglebudabey> i just ran stack build and it had a fuck ton of warnings and the second build there were none, how can i view them again?
13:41:17 <mniip> if hugeMap isn't getting inlined that is
13:41:36 <sm> buglebudabey: stack clean; stack build
13:41:43 <buglebudabey> thanks sm
13:46:06 <hsk3> Welkin: thanks
13:47:01 <koomi> hsk3, Welkin: there is no guarantee that hugeMap won't be inlined by the compiler
13:47:32 <Welkin> can't you use a pragma {# NOINLINE #} or something?
13:47:40 <koomi> you can
13:47:57 <koomi> with GHC at least
13:48:05 <Welkin> lol, what else does anyone use?
13:48:48 <koomi> nothing really, just being clear
13:49:11 <koomi> knowing what is standard and an extension can become important
13:49:17 <Welkin> I see
13:49:43 <koomi> but appearently NOINLINE is even in haskell98
13:49:43 <EvanR> hsk3: Map is subject to laziness
13:49:53 <EvanR> so it might not get totally constructed right now
13:50:10 <Welkin> Use Data.Map.Strict
13:50:30 <EvanR> even then you still would have to force it to get it to construct now
13:50:36 <EvanR> with a bang pattern or something
13:51:05 <EvanR> strict map just means the values wont be thunks
13:52:05 <codh> hello, I have trouble to understand the unit/counit law of adjunction,
13:52:46 <codh> https://en.wikipedia.org/wiki/Adjoint_functors. what is the meaning of eF in the article? e for epsilon.
13:53:04 <codh> is this a composition, application?
13:53:30 <shachaf> codh: See https://en.wikipedia.org/wiki/Natural_transformation#Operations_with_natural_transformations
13:54:03 <EvanR> snd (Data.Map.Strict.singleton 'a' undefined, 4) ==> 4
13:54:20 <shachaf> eF is a natural transformation. (eF)_A = e_F(A)
13:54:49 <shachaf> There's also Ge: (Ge)_A = G(e_A)
13:57:21 <codh> shachaf: thanks. so it's a compostion. F applied to A first, get a new type, then e application to FA.
14:04:02 <buglebudabey> where can i get the build-passing buttons that are common on github
14:05:31 <liste> buglebudabey: depends on your CI server
14:06:30 <geekosaur> many github projects use travis-ci's FOSS service
14:06:39 <buglebudabey> ah alright
14:06:48 <liste> buglebudabey: for travis, it's right next to the project name on the project page
14:06:48 <buglebudabey> what is that server used for
14:06:58 <buglebudabey> or what is travis used for
14:07:07 <liste> buglebudabey: building your project automatically
14:07:27 <geekosaur> it's a continuous integration ("CI") service. someone commits to your project, travis detects it and runs a build on platforms you specifyt
14:08:13 <shachaf> What is discrete integration? Just summation?
14:08:39 <liste> shachaf: :D
14:08:58 <geekosaur> *eyeroll*
14:10:58 <buglebudabey> thanks liste and geekosaur 
14:12:12 <buglebudabey> also thank you lots for earlier everyone else for helping me with stack maerwald monochrom mgsloan yyyyy EvanR glguy :P 
14:12:57 <puregreen> buglebudabey: also see http://shields.io/ for actual button images that are all consistent in style
14:13:04 <jle`> hsk3: btw, hugeMap is not a function
14:13:13 <puregreen> (and there are buttons for Hackage, license, Travis-CI, and lots of other things)
14:13:17 <hsk3> hehe ok
14:14:02 <buglebudabey> is there a way to supress warnings when people downloading my project want to build it with stack?
14:14:09 <buglebudabey> thanks puregreen 
14:14:19 <jle`> buglebudabey: what warnings?
14:15:38 <buglebudabey> jle` such as this: http://lpaste.net/169954
14:19:33 <buglebudabey> jle`  i have to run now if you don't mind, ill ask you when i come back :P
14:31:05 <jle`> is there any way i can pipe two conduits in parallel Arrow-Choice style?
14:31:07 <jle`> :t (|||)
14:31:08 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
14:32:10 <jle`> i want to have items from the same producer be written to two different files
14:32:20 <jle`> depending on contents i'm popping out
14:33:07 <jle`> i suppose I could just use the Applicative instance
14:33:18 <jle`> and instead of passing (Either b c), pass (Maybe b, Maybe c)
14:33:50 <jle`> > (x+1) * (y+1)
14:33:51 <lambdabot>  (x + 1) * (y + 1)
14:34:02 <jle`> i'm not sure what i expected
14:34:47 <hpc> haha
14:35:07 <hpc> i know that feeling
14:42:32 <jle`> i wrote one from scratch using the Monad instance
14:42:48 <jle`> monadic iteratees are weird
14:42:57 <jle`> i wonder if this is offered as a standard library function anywhere
14:47:54 <jle`> nvm my monadic implementation was incorrect
14:48:51 <ReinH> jle`: I think you can use just use Concurrently or similar
14:49:10 <jle`> what library/module has that?
14:49:28 <ReinH> async
14:49:56 <ReinH> jle`: e.g., https://www.schoolofhaskell.com/user/snoyberg/library-documentation/data-conduit-process
14:50:19 <buglebudabey> paging jle` 
14:50:38 <jle`> hi!
14:51:02 <buglebudabey> did you see my earlier question about the warnings and the code i pasted?
14:51:41 <jle`> buglebudabey: yeah, i'm not sure how to suppress warnings, i was just asking you to show your warnings so people can have more information to potentially answer your question :)
14:51:58 <jle`> but the path i'd recommend myself is to actually fix the warnings in your code...there's no reason any of those warnings should be left in your codebase
14:52:29 <jle`> ReinH: hm, i'll try to adopt it
14:52:45 <buglebudabey> fair enough, but what would you do in the case of an unused variable on pattern matching for example, that's the bulk of the warnings
14:52:59 <jle`> but my issue right now is that the Applicative/etc. instances work on the return type, not the output
14:53:02 <jle`> buglebudabey: use a wildcard
14:53:23 <buglebudabey> like _?
14:53:29 <jle`> > case find even [1..10] of Just _ -> "found"; Nothing -> "not found"
14:53:30 <lambdabot>  "found"
14:53:35 <jle`> yes
14:53:52 <buglebudabey> i didn't know that would surpress the warnings
14:53:53 <buglebudabey> alrighty
14:54:10 <jle`> yeah, the warning is that you named it but never used it
14:54:20 <jle`> which is often the source of many bugs
14:54:45 <jle`> so not naming things you don't intend to use is a good way to tell the compiler that you know what you are doing
14:55:12 <mgsloan> buglebudabey: By default stack does not show warnings for packages that are dependencies
14:55:30 <orion> jle`: DO you think Arrows are useless?
14:55:49 <jle`> do you mean specific arrow instances?
14:55:53 <buglebudabey> mgsloan these warnings are for local modules, does that change anything?
14:55:58 <jle`> or ... writing Arrow-polymorphic code?
14:56:03 <joe9>  I want to use the inotify mechanism from haskell to run process when a file is created in a directory. I read that there is : kqueue, hinotify, system.linux.inotify packages. Just want to check which is recommended?
14:56:05 <mgsloan> Yes, in that case they will see those
14:56:09 <buglebudabey> mgsloan local from my standpoint
14:56:11 <joe9> I use linux, btw.
14:56:19 <mgsloan> If you don't want that, don't include -Wall in the config.  Instead pass it via "--ghc-options"
14:56:34 <mgsloan> ("--ghc-options -Wall")
14:56:42 <jle`> arrows themselves are certainly not useful, people use arrow instances in pretty much all haskell code they write
14:56:46 <jle`> *not useless
14:57:29 <jle`> almost all haskell projects and scripts i've ever written have used an Arrow instance! :o
14:57:47 <mniip> I bet it's the -> instance
14:58:22 <hpc> there sure aren't very many other useful Arrow instances ;)
14:58:22 <jle`> def one of my favorites
14:58:43 <buglebudabey> mgsloan is that what i put in the cabal file?
14:58:44 <mniip> Cokleisli Identity ?
14:59:22 <mgsloan> buglebudabey: "stack build --ghc-options -Wall".  If you don't want to have warnings by default, then omit it from "ghc-options: .." in your cabal file
15:00:03 <buglebudabey> thanks
15:00:03 <mniip> jle`, btw, that NFData instance on Finite, did you need it for something?
15:00:32 <jle`> mniip: yeah, i needed to NFData a strut that had a Finite in it, and was lazy and wanted to use generic deriving
15:00:38 <jle`> s/strut/struct
15:00:53 <mniip> should I update the hackage package?
15:01:37 <buglebudabey> right now my project is only an executable, if i want to make a library out of it so that people can use certain functions and have it on hackage, what can i do?
15:01:52 <jle`> mniip: according to your own schedule! :)  i'm using a local fork anyways so it's not a big deal/urgent
15:02:04 <mgsloan> buglebudabey: Add a library stanza
15:02:25 <buglebudabey> it's that simple?
15:02:28 <mgsloan> Take a look at the cabal file from an existing hackage package
15:02:33 <mniip> jle`, by the way, I was thinking about making a package with induction witness singletons
15:02:53 <mniip> but I don't think I see a good way to overcome the 0-basedness of Nat
15:02:56 <jle`> oh, let me know how that goes :)
15:02:58 <mgsloan> buglebudabey: Oh, well then you need to have a hackage account and then use "stack upload ."
15:03:03 <mniip> I need design advice
15:03:06 <jle`> 0-basedness?
15:03:18 <mniip> well imagine binary induction
15:03:23 <mniip> every number is either 2n or 2n+1
15:03:26 <mniip> the base case is 1
15:03:47 <jle`> mhm
15:03:49 <buglebudabey> alright sounds good. and if i want only some functions to be available then all i need to do is update module main (function1, function2, ...) where?
15:03:49 <mniip> but Nat is 0-based, not 1-based
15:04:00 <mniip> how do we encode Nat in such scheme, or how do we adapt the scheme to fit 0
15:04:06 <jle`> you're not going for the classic peano structure?
15:04:14 <mniip> well that's obvious
15:04:19 <mniip> but not the only induction method that exists
15:04:34 <mniip> so far the only solution I've come up with 0, n->2n+1, n->2n+2
15:04:45 <mniip> +is
15:04:50 <mniip> but that's kinda ugly
15:05:23 <jle`> hm, this sounds like a general problem people might have had to deal with before
15:05:46 <jle`> but yeah, the ugliness might be unavoidable for that specific induction method
15:05:48 <mniip> unlikely it has been addressed in math
15:05:57 <mniip> because there you can just use different set of naturals
15:05:58 <nicksoline> im back
15:06:06 <nicksoline> ;)
15:07:35 <jle`> ah, yeah
15:08:01 <jle`> can't think of anything too much nicer at the moment, but i'll keep on thinking about it today
15:08:54 <int-e> I think 0, 2n+1, 2n+2 (binary numbers with digits 1 and 2) is pretty.
15:13:53 <joe9> anyone knows of any sample code using linux-inotify package
15:14:17 <maerwald> joe9: you mean the hinotify package?
15:14:24 <glguy> mgsloan: Have you considered having stack search the current path for "ghc-VERSION" when looking for a particular GHC version instead of using whatever "ghc" points to and doing a version check?
15:14:26 <maerwald> I think that's the one you want
15:14:34 <mniip> int-e, how do you implement it in base n
15:14:41 <mniip> you need 1-based finites
15:14:49 <mgsloan> glguy: I don't think we have considered that.  Interesting idea!
15:15:19 <glguy> mgsloan: That would save me a bunch of effect, personally, when working on systems that already have GHCs installed
15:15:23 <glguy> of effort*
15:15:51 <int-e> mniip: you could use digits 1 to n in base n
15:16:02 <joe9> maerwald: it appears that linux-inotify > hinotify when I am using linux and ghc 7.10
15:16:29 <travism> Is there a book or site that kind of explains the process of developing software using FP? IE: Thinking of all the types first, separating pure functions from IO etc...
15:16:34 <mniip> well yes
15:16:35 <mgsloan> glguy: Yeah, that's a really good idea
15:16:41 <maerwald> joe9: I think it's the other way around
15:16:54 <maerwald> but well, I only have an example for hinotify
15:17:01 <maerwald> which is properly maintained
15:17:02 <EvanR> travism: im reading Type Driven Development with Idris, which goes over a lot of the haskell way of thinking in the first few chapters
15:17:24 <EvanR> it has heavy emphasis on types, however it quickly starts to exploit dependent types, which haskell doesnt have
15:17:53 <travism> EvanR: Oh cool, thanks I'll look into that.
15:17:57 <joe9> maerwald: oh, cool. let me check out hinotify. Can you please post your example.
15:18:05 <mgsloan> glguy: One minor issue is that sometimes we specify "ghc-8.0.0".  "compiler-match" defaults to match-minor.  This means that in order for ghc-8.0.0.20160205 to be used to satisfy ghc-8.0.0, we'd need to search all of PATH, which could be rather expensive
15:18:26 <mgsloan> One option would be to fall back on the current "ask ghc for version + use that" strategy if the exact ghc-VERSION executable isn't found
15:18:27 <EvanR> another thing is theres less emphasis on laziness
15:18:31 <maerwald> joe9: https://git.io/vKzTu
15:18:43 <maerwald> it's a real-world example though
15:18:46 <joe9> maerwald: Thankes
15:19:27 <maerwald> I dynamically add inotifies, so I need to make sure they are properly killed too
15:19:49 <mniip> jle`, ultimately I'm looking for a set of primitives like 'KnownNat n => p 0 -> (forall m. KnownNat m => p m -> p (m + 1)) -> p n'
15:19:53 <maerwald> it's basically just initInotify and addWatch
15:25:10 <glguy> mgsloan: I'd be OK with only exact matches being used for the ghc-VERSION mode of operation, but I wouldn't be surprised if there were a number of other considerations
15:26:32 <nicksoline> hello everyone
15:26:35 <joe9> maerwald: ok, Thanks. yes, it does appear that hinotify has more examples and docs.
15:28:53 <glguy> mgsloan: In lieu of that is there a way to tell stack explicitly where to find each version of GHC that it might need?
15:30:36 <mgsloan> glguy: Via extension of PATH.  If "ghc" exists and its version matches, it gets used
15:32:46 <glguy> mgsloan: Instead of using ghc-VERSION executables it might be useful to support a map of version numbers to paths in the ~/.stack/config.yaml
15:33:00 <greenbagels> Value constructors, being functions, can surely be curried, right?
15:33:40 <glguy> greenbagels: Not all *data* constructors have fields and therefore can't be used as functions
15:33:50 <greenbagels> Ah
15:34:09 <jle`> greenbagels: data constrcutors with more than one "argument" are actually provided curried
15:34:11 <glguy> but if you had a data T = C (Int,Bool), you could then write   curry C
15:34:50 <jle`> `data Foo = Foop Int Bool` gives you the conveniently pre-curried Foop :: Int -> (Bool -> Foo)
15:35:02 <glguy> greenbagels: Are you asking about currying, or partial application?
15:35:21 <mgsloan> glguy: Thing is, we also want to use the ghc-pkg, haddock, ghci, etc associated with the ghc.  Would be a lot of paths! 
15:35:21 <greenbagels> Uhm, partial application I suppose
15:35:37 <mgsloan> Well, "ghci" is a bad example because it's just ghc --interactive
15:35:37 <greenbagels> What is the difference again?
15:35:54 <jle`> greenbagels: currying is the process of turning a (a, b) -> c function into an (a -> (b -> c))
15:35:56 <glguy> Currying is taking a function  (a,b) -> c, and making one   a -> b -> c
15:36:25 <mgsloan> But it wouldn't be hard for people to write the paths.  If there's a compelling enough use case, then sure
15:36:38 <greenbagels> Ah, so partial application is what I want
15:36:43 <mgsloan> In the meantime, you can create a folder with symlinks or hardlinks and add it to your PATH :D
15:36:55 <jle`> greenbagels: in Ocaml, for exmaple, data constructors aren't provided curried
15:37:03 <jle`> you have to manually curry them yourselves
15:37:12 <glguy> mgsloan: I'm trying to avoid having to mess with PATH when I switch between projects that use different resolvers
15:37:14 <mgsloan> glguy: But I realize that's not so appetizing, since part of the point of stack is avoiding needing to manage your PATH
15:37:17 <mgsloan> yeah
15:37:22 <jle`> you can only write data Foo = Foop (Int, Bool), which gives you Foop :: (Int, Bool) -> Foo
15:37:25 <jle`> but you can just curry Foop, as well
15:37:32 <jle`> curry Foop :: Int -> Bool -> Foo
15:37:37 <glguy> and it's on a build system that already has the various GHCs installed in /usr/local
15:37:46 <mgsloan> Maybe we just need to add PATH extension to config.yaml!
15:38:00 <greenbagels> So there's an actual curry keyword builtin to the language?
15:38:08 <jle`> curry is just a user-defined higher order function
15:38:12 <jle`> @src curry
15:38:12 <lambdabot> curry f x y = f (x, y)
15:38:17 <greenbagels> Yeah
15:38:24 <jle`> not a keyword, just a normal fucntion :)
15:38:33 <jle`> @data Foo = Foop (Int, Bool)
15:38:34 <lambdabot> Unknown command, try @list
15:38:39 <jle`> @let data Foo = Foop (Int, Bool)
15:38:40 <lambdabot>  Defined.
15:38:41 <jle`> :t Foop
15:38:42 <lambdabot> (Int, Bool) -> Foo
15:38:44 <jle`> :t curry Foop
15:38:45 <lambdabot> Int -> Bool -> Foo
15:39:09 <greenbagels> Take a small break from learning and you forget everything ;)
15:39:11 <jle`> :t \x y -> Foop (x, y)
15:39:12 <lambdabot> Int -> Bool -> Foo
15:39:58 <jle`> so yeah, you probably meant to ask, originally, "data constructors with more than one field, being curried functions, can be partially applied, right?"
15:40:20 <jle`> and the answer would be yes -- currying a function is a method of allowing partial application
15:40:35 <lilred> hello beautiful people
15:42:26 <greenbagels> jle`: gotcha
15:42:34 <greenbagels> Thank you
15:44:18 <jle`> np!
15:45:10 <greenbagels> Right, I read about how to partially apply functions that are curried by default
15:45:14 <greenbagels> Makes sense
15:46:21 <buglebudabey> does anyone use any packages for ML, AI, NLP related things or has a recommendation? Maybe for bayesian analysis?
15:47:42 <greenbagels> Wait jle`, then any time you write a function like f :: x -> y ->z, you're already currying them
15:47:54 <jle`> greenbagels: yup
15:48:05 <jle`> f :: x -> y -> z is really f :: x -> (y -> z)
15:48:15 <greenbagels> Yeah because right associativity
15:48:18 <jle`> f x y z = ... is just sugar for f = \x -> \y -> \z -> ...
15:48:29 <jle`> so f x y z = ... syntax is sugar for defining curried functions
15:49:28 <jle`> it's a lot more convenient than in other languages, where you have to write out each returned function manually, or use a higher order currier
15:49:37 <greenbagels> Yeah
15:50:12 <jle`> foo = function(x) { return function(y) { return function(z) { ... } } }
15:50:16 <jle`> in javascript ;_;
15:53:05 <maerwald> <3 javascript :o
15:53:17 <julianleviston> Using GHC, I‚Äôve got some code that calls runInterpreter from Language.Haskell.Interpreter, and I‚Äôm loading modules that I generate to disk from a database of code just before I run the interpreter. I can do this because the loadModules function loads these modules from disk. I‚Äôd like to do the same sort of thing without actually having to write the files to disk. Is this possible?
16:00:05 <julianleviston> I suppose I could write my own loadModules, actually‚Ä¶ see if I can do that.
16:05:47 * hodapp stabs linear programming libraries in the face
16:06:47 <johnw> as long as you stab along a straight line
16:09:21 <hodapp> johnw: http://lpaste.net/1632372706768846848 ignoring the bad practice, take a look at line 29 particularly, and tell me what possible behaviors this function might exhibit...
16:10:26 <buglebudabey> where can i learn to read lambda calculus like this http://www.aosabook.org/en/ghc.html#s:core
16:10:53 <johnw> hodapp: why am I looking at this?
16:11:17 <hodapp> johnw: as a sanity check or something.
16:12:00 <johnw> it doesn't mean anything to me as it is
16:12:01 <hodapp> I observe output from that trace statement, and then somehow the function still manages to return a value, despite calling itself with exactly its same arguments.
16:13:22 <shachaf> buglebudabey: You should probably look up "System F".
16:13:31 <buglebudabey> awesome, thank you
16:14:10 <shachaf> Ah, and https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType has some explanations.
17:02:21 <Rotaerk> is there anything closely resembling a ... community choice for FRP?
17:02:33 <Rotaerk> I was trying reflex earlier, but it looks like it's fallen a bit behind in maintenance
17:03:59 <julianleviston> how has it fallen behind?
17:05:03 <julianleviston> because the last commit was 6 weeks ago?
17:06:21 <julianleviston> or are you not talking about reflex-dom? Just reflex proper?
17:06:37 <Rotaerk> hmm I'm looking at reflex-dom in particular
17:06:58 <Rotaerk> it doesn't work with the current stackage because it depends on aeson < 11.0, but the current stackage has > 11
17:07:12 <julianleviston> Ah I think there‚Äôs a PR in for that.
17:07:20 <Rotaerk> ah
17:07:41 <julianleviston> https://github.com/reflex-frp/reflex-dom/pull/70
17:08:28 <Rotaerk> err yea 0.11, not 11.0...
17:08:39 <julianleviston> oh‚Ä¶
17:08:41 <Rotaerk> okay, 
17:08:59 <julianleviston> I‚Äôm confused then.. 17 days ago‚Ä¶ 
17:10:25 <Rotaerk> I guess I'll figure out how to use an older ... snapshot, or whatever they're called in stackage
17:10:29 <Rotaerk> until they fix that
17:10:34 <julianleviston> I think you *mean* 0.11 when you say 11
17:10:44 <Rotaerk> yes
17:11:10 <julianleviston> Oh‚Ä¶ you were self-correcting, not correcting me ! LOL miscomuncation. Sorry :)
17:11:21 <Rotaerk> ah, sorry; I see what you mean
17:11:46 <julianleviston> Rotaerk: if you install reflex as it suggests, you don‚Äôt need to worry about that, do you? 
17:12:21 <julianleviston> Rotaerk: I did this about 4 days ago last: https://github.com/reflex-frp/reflex-platform
17:12:22 <Rotaerk> oh, didn't notice it had special installation instructions
17:12:41 <Rotaerk> or rather, forgot
17:12:47 <julianleviston> It‚Äôs super easy to set up. Takes a while, but it‚Äôs good :) 
17:13:12 <Welkin> it's funny you mention that
17:13:18 <Welkin> I am trying to get my first elm app up and running
17:13:45 <Welkin> and have a very basic question, but the elm channel, despite having over 200 idlers, is always dead
17:13:45 <Rotaerk> I wonder if they'll remove the need for this special installation eventually
17:13:53 <julianleviston> Welkin: Oh I‚Äôve done that before...
17:13:59 <Welkin> so... fuck
17:14:01 <julianleviston> Welkin: you‚Äôre better off using their slack TBH...
17:14:19 <Welkin> I'll just ask here if anyone knows
17:14:23 <Welkin> what is `main` even for?
17:14:28 <julianleviston> Welkin: there are *ALWAYS* about 20 people on their slack.
17:14:32 <Welkin> can I use it to initialize anything?
17:14:47 <julianleviston> Welkin: main is the entry point, same as Haskell.
17:14:50 <Welkin> read a json file from disk and parse it into a Dict
17:14:55 <Welkin> that is what i/ want to do
17:15:12 <julianleviston> Welkin: what is ‚Äúfrom disk‚Äù  in the context of the browser?
17:15:22 <julianleviston> Welkin: (because that‚Äôs where elm runs mostly)
17:15:24 <Welkin> oh, this is just a static application
17:15:35 <julianleviston> Welkin: so you‚Äôre running it in node?!
17:15:39 <Welkin> lol no
17:15:46 <julianleviston> Welkin: where is it running?
17:15:50 <Welkin> it is just html/js running in the reactor
17:15:53 <Welkin> in the browser
17:16:00 <julianleviston> Welkin: then see my first question :)
17:16:26 <Welkin> well, that is partly what I am unsure about
17:16:41 <julianleviston> Welkin: if it‚Äôs running in the browser, your main context is in the browser‚Ä¶ so you can use FFI to punch through to JS if you want, or use the many ways to interact with files from the browser‚Äôs POV
17:17:19 <julianleviston> Welkin: if you were developing a JS app, how would you read a file from the disk? (this is a leading question - I know how I would do it)
17:17:37 <Welkin> it should just load "dict.json" like it would load a css file or anything else
17:18:06 * hackagebot PathTree 0.1.1.0 - A tree used to merge and maintain paths  https://hackage.haskell.org/package/PathTree-0.1.1.0 (pjrt)
17:18:07 <julianleviston> Welkin: the browser loads CSS files when it parses the HTML‚Ä¶ unless you‚Äôre saying how JS would load files...
17:18:23 <Welkin> well, I would host the json file on a server in a real app
17:18:32 <Welkin> but I am just developing it right now
17:18:46 <julianleviston> Welkin: you probably want something like http://package.elm-lang.org/packages/maxsnew/IO/1.0.0 but I don‚Äôt know if that will work with latest Elm.
17:18:49 <Welkin> actually, that doesn't even matter now that I think about it
17:18:54 <Welkin> it can load it from localhost
17:19:28 <Welkin> okay, so I confused my own question
17:19:41 <Welkin> what I really want to know is how I can have the file loaded before the rest of the program starts
17:19:49 <Welkin> I don't see a way to do that in `main`
17:20:59 <julianleviston> Welkin: From my understanding, main is just the expression that is your program (like in Haskell). You would need to load files through a port or something via JS, I think.
17:21:20 <dmwit> Welkin: There is some TH on Hackage for loading a file as a ByteString at compile time.
17:21:26 <julianleviston> JS has FileReader which you could use to read the file off disk, and then send the data through to Elm via a port.
17:21:40 <dmwit> (...or are we not talking about Haskell here?)
17:21:41 <julianleviston> dmwit: he‚Äôs actually talking about Elm :(
17:21:46 <julianleviston> which is silly
17:21:49 <Welkin> dmwit: Elm
17:21:52 <julianleviston> It‚Äôs incredibly OT.
17:22:04 <julianleviston> Welkin:  go ask in Slack, I recommend! :)
17:22:18 <dmwit> Perhaps you should continue the conversation in #elm...?
17:22:32 <julianleviston> Welkin: http://elmlang.herokuapp.com
17:24:01 <Welkin> dmwit: yeah, that channel is dead
17:26:53 <Rotaerk> julianleviston, thanks for noticing that PR; ryan apparently had missed it
17:26:56 <Rotaerk> he's merged it
17:27:07 <julianleviston> Rotaerk: well that‚Äôs good news! :)
17:29:01 <julianleviston> Rotaerk: Did you ping ryan?
17:29:19 <Rotaerk> I just mentioned it in #reflex-frp, and he responded
17:29:31 <Rotaerk> and suggested that I submit a PR, to which I replied with your link :P
17:30:13 <EvanR> all conversation in dead channels should take place in haskell (no effect)
17:30:35 <Welkin> well... the slack channel is dead too
17:30:42 <julianleviston> sweet. :) maybe would be good to remark on the PR next time :) helps everyone‚Ä¶ unless there‚Äôs too much noise
17:30:51 <julianleviston> Welkin: it‚Äôs probably just a timezone thing.
17:30:54 <Welkin> and slack is just as annoying as I thought it would be
17:31:19 <Rotaerk> just need to figure out what to do in the meantime, until the next nightly stack snapshot comes out
17:31:20 <julianleviston> Welkin: slack has the added advantage of notifying you when someone replies to your comments ;-)
17:31:38 <julianleviston> Rotaerk: you didn‚Äôt have any luck with ./try-reflex ?
17:31:50 <julianleviston> Rotaerk: or do you need aeson 0.11?
17:32:10 <Rotaerk> well, that's more of a sandbox for ... trying reflex; but I also want some other packages, and would like to use stack for that aspect
17:32:36 <julianleviston> Ah fair enough.
17:33:09 <julianleviston> Rotaerk: can you punch through specific versions to use git? (just curious here - it‚Äôs interesting)
17:33:28 <julianleviston> Rotaerk: as in ‚ÄúI know what I‚Äôm doing here, use this repo‚Äôs git-sha‚Äù ?
17:33:36 <Rotaerk> I suppose I should figure that out :)  I've only got a basic understanding of stack right now... time to go through the user guide
17:36:04 <julianleviston> ttyl
17:58:07 * hackagebot monad-logger-syslog 0.1.2.0 - syslog output for monad-logger  https://hackage.haskell.org/package/monad-logger-syslog-0.1.2.0 (dysinger)
18:09:51 <vctr> hi all
18:13:08 * hackagebot BiGUL 1.0.0 - The Bidirectional Generic Update Language  https://hackage.haskell.org/package/BiGUL-1.0.0 (joshko)
18:22:01 <Welkin> athan
18:22:10 <athan> Welkin
18:23:08 * hackagebot quickcheck-combinators 0.0.1 - Simple type-level combinators for augmenting  QuickCheck instances.  https://hackage.haskell.org/package/quickcheck-combinators-0.0.1 (athanclark)
18:57:42 <cloudhead> anyone got intero master working on os x?
19:23:50 <Rotaerk> when you add a package to extra-deps in stack.yaml, where does it get information about that package from? hackage? and if so, what causes it to get-latest from hackage?
19:24:10 <Rotaerk> I don't see how to get it to see that the required-version-bounds on this package changed in hackage
19:28:58 <Rotaerk> is it perhaps expecting that because the version of the package itself hasn't changed, that the dependencies haven't been changed?
19:30:04 <Denommus> I wonder if something like ocsigen is doable in Haskell with template haskell wizardry 
19:30:48 <hodapp> I haven't used Servant but I get the idea that it's similar in a lot of ways
19:31:15 <Denommus> hodapp: not in the ways that matter the most, sadly 
19:31:48 <hodapp> like what?
19:32:46 <Denommus> The main attractive thing in ocsigen is that your application, both backend and front-end, is a single module. And client variables can be easily created in the backend, or backend variables can easily be used on the front-end
19:33:20 <Denommus> That specifically allows you to create a message bus in the backend, and then send and receive stuff to and from it on the front-end 
19:33:46 <Denommus> So you have seamless communication between both ends 
19:34:07 <Denommus> You can even use FRP signals instead of this message bus 
19:36:27 <hodapp> huh...
19:38:46 <Denommus> hodapp: to be clearer: you create the bus in the backend, and the front-end can reference it and read or write things from it 
19:39:31 <Denommus> You don't need to serialize this bus and somehow make the front-end receive it with a request 
20:03:11 <significance> Hello all! Complete noob here - is it possible to have a type constructor implement a type class, but only for certain type parameters to the type constructor? (i.e. have Maybe implement Functor, but only for Int?)
20:04:41 <jle`> significance: not for Functor, at least
20:04:43 <shachaf> significance: No, Functor requires instances to be completely parameteric in the argument.
20:05:05 <jle`> note the type of fmap -- it only makes sense if it works for all a's:
20:05:07 <jle`> :t fmap
20:05:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:05:35 <jle`> the Functor f has to be able to take any type 'a' the user of fmap desires
20:05:37 <hodapp> significance: what are you trying to accomplish with this?
20:06:55 <significance> jle`, shachaf: thanks!
20:07:08 <significance> hodapp: I'm just curious - reading through LYAH and wondered
20:07:20 <hodapp> ahh, okay
20:07:22 <significance> what's the syntax for when you can do it (not Functor)?
20:07:35 <significance> I get that that would be a terrible design idea :P
20:07:46 <jle`> well, there are a lot of ways you could write a typeclass that had that sort of behavior
20:08:05 <jle`> class Foo f where foomap :: (Int -> Int) -> f Int -> f Int
20:08:36 <jle`> or you could use a multi-parameter typeclass and let people define different behavior for all sorts of combinations of things to apply the type constructor to
20:08:52 <significance> jle`: ahh, gotcha - thank you!
20:09:17 <Voltz> Why isn't Monoid a subclass of Semigroup? 
20:09:23 <jle`> class Bar f a where barmap :: (a -> a) -> f a -> f a, and you could have instance Bar Maybe Int, and barmap :: (Int -> Int) -> Maybe Int -> Maybe Int
20:09:27 <Voltz> seems like a pretty obvious thing to me
20:09:41 <EvanR> maybe in a future burning bridges proposal
20:09:42 <jle`> significance: but yeah, what you are thinking of is an issue with the Functor typeclass in specific
20:09:42 <shachaf> Or instance a ~ Int => Bar Maybe a
20:09:57 <significance> jle`: that makes much more sense - thank you!
20:10:05 <significance> shachaf: sweet - thank you!
20:10:08 <jle`> Voltz: historical reasons for the most part
20:10:31 <jle`> i think we're heading in that direction, because Semigroup is finally in base as of the last GHC release
20:10:51 <jle`> there might be a proposal with a plan on the phab
20:10:54 <Voltz> Is that it? Or something I'm missing? A Monoid is just a Semigroup with an identity, idn't it?
20:11:06 <jle`> nope, it's completely for historical reasons
20:11:16 <Voltz> alllrighty then
20:11:16 <EvanR> Semigroup is defined, and it even is stealing the <> operation
20:11:22 <EvanR> its just not a requirement of Monoid
20:11:33 <jle`> once things are all sorted out, we can finally have the sensible Monoid instance for Maybe too
20:11:48 <jle`> s/the/a
20:11:48 <Voltz> What is it like now? 
20:11:57 <jle`> instance Monoid a => Monoid (Maybe a)
20:12:00 <jle`> but it never uses mempty
20:12:09 <jle`> so it really should/could be instance Semigroup a => Monoid (Maybe a)
20:12:21 <jle`> for the semigroup-lifting monoid behavior
20:12:41 <Voltz> ah
20:12:53 <jle`> Maybe is basically a way you can turn any semigroup into a monoid, for free
20:12:56 <Rotaerk_> how do you get stack to see the latest dependency information for a package on hackage?
20:12:57 <EvanR> you can think of Maybe as turning a semigroup into a monoid by adding an element
20:13:40 <EvanR> however! if your semigroup was already a monoid now you have the weird situation where you have 2 identity elements
20:13:47 <EvanR> which is impastable!
20:14:30 <jle`> not quite  -- in the monoid you construct, the extra element is the identity, not the identity of the original set
20:14:45 <EvanR> both will act like identities
20:14:51 <jle`> if you extend monoid (e,+) with e', then e' + e = e'
20:14:55 <EvanR> oh
20:15:07 <EvanR> its a different operation entirely
20:15:30 <jle`> yea, i probably should have used a different operator v.v
20:16:02 <EvanR> wait it actually will still work
20:16:20 <EvanR> Nothing does nothing, and Just e will do nothing
20:17:05 <jle`> Just mempty <> Nothing = Just mempty, so Just mempty is not an identity
20:18:23 <EvanR> ok so its masking
20:18:26 <jle`> In order for something to be an identity, x + e = e for all x.  for Just mempty, Nothing <> Just mempty /= Nothing, so Just mempty is not an identity
20:23:04 <Rotaerk_> hmm bleh, now I won't know, because the issue mysteriously disappeared
21:13:00 <Rotaerk_> is there an easy way to read source code from hackage such that I can go-to-definition for a function?  without explicit imports, it's sometimes tell which module a function came from
21:13:15 <Rotaerk_> sometimes hard to *
21:14:52 <Rotaerk_> best way I've found is to load the package into GHCI, and then :i the function, though that's not possible if it's in a hidden module
21:16:00 <Welkin> you mean in the docs?
21:18:11 <Rotaerk_> no, the source code
21:18:43 <Welkin> source code on hackage
21:18:57 <Rotaerk_> for instance https://hackage.haskell.org/package/reflex-dom-0.3/docs/src/Reflex-Dom-Internal.html#GuiEnv
21:19:03 <julianleviston> Rotaerk_: that‚Äôs something I kinda miss from clojure.
21:19:54 <Rotaerk_> this uses runWebGUI, and I see it's hidden in the GHCJS.DOM import, but it took me a bit to find it in Reflex.Dom.Internal.Foreign
21:19:57 <julianleviston> Rotaerk_: a lot of stuff you can pull up the source for‚Ä¶ or at least docs‚Ä¶ internally‚Ä¶ all you get in Haskell is the types‚Ä¶ which is often almost good enough, but doesn‚Äôt help with the semantics very much if you‚Äôre looking at a hidden type.
21:20:03 <Welkin> oh, some of them don't have the new clickable sourcecode
21:20:08 <julianleviston> ‚Äúopaque type‚Äù maybe
21:20:38 <EvanR> julianleviston: unless you need to read the java source...
21:20:52 <julianleviston> EvanR: sure :)
21:21:11 <Welkin> julianleviston: I was able to get Elm working the way I wanted to by placing the load operation in my initial model instead of Cmd.none
21:21:27 <julianleviston> EvanR: don‚Äôt get me wrong - I‚Äôm not saying clojure is much better or anything - I‚Äôm just saying it‚Äôs useful sometimes having source and docs in the REPL.
21:21:31 <Rotaerk_> this reflex library is interesting, but difficult to figure out; not very well documented yet, beyond getting something basic written
21:22:11 <julianleviston> Welkin: ah right, with a custom initialiser or whatever they‚Äôre called?(can‚Äôt remember the Elm name for it)
21:22:29 <Rotaerk_> and the types in it are scary
21:22:35 <Welkin> lol Rotaerk_ 
21:22:48 <julianleviston> Rotaerk_: aw :( scary types aren‚Äôt any good.
21:23:17 <julianleviston> Rotaerk_: meaning the phenomenon of being scared by types
21:23:37 <Rotaerk_> mainWidget is the entrypoint for reflex-dom, but its input type is:  Widget Spider (Gui Spider (WithWebView SpiderHost) (HostFrame Spider)) ()
21:23:45 <Rotaerk_> which isn't particularly informative
21:24:39 <Welkin> Rotaerk_: I'm sure you could ask Cale when he is around. He uses reflex-dom extensively
21:25:08 <Rotaerk_> I'm not stuck exactly, yet, just ... a little overwhelmed, but I'll chip away at it
21:25:39 <Rotaerk_> I'm trying to do something with it that's outside the box, with respect to the examples in the tutorial
21:26:27 <Welkin> there is always Elm as well
21:26:38 <Rotaerk_> for what?
21:26:45 <Welkin> it's sort of annoying at first, but they types are super simple and you get used to it fast
21:26:50 <Welkin> I mostly like it
21:26:57 <Welkin> Rotaerk_: for building in-browser apps
21:27:24 <Rotaerk_> ah, I don't intend to use a browser for this app; I'm just using the GHC compiler with it to make a desktop GUI app
21:28:09 <Rotaerk_> it may be easier to just drop down to the gtk3 level though, since this doesn't seem to support (out of the box) multiple windows each running a separate DOM
21:28:12 <Rotaerk_> within the same thread
21:33:20 <Cale> Rotaerk_: hi
21:33:25 <Rotaerk_> hey
21:33:39 <Cale> Rotaerk_: yeah, we really need to make some nice tutorials for reflex and reflex-dom
21:33:56 <Cale> (but we've been pretty busy with client work)
21:34:11 <Rotaerk_> tutorials are nice for simple things, but documentation of the gritty details would be nice too
21:34:39 <Cale> oh, indeed
21:34:57 <julianleviston> Isn‚Äôt it documented pretty well?
21:35:17 <Rotaerk_> https://hackage.haskell.org/package/reflex-dom-0.3/docs/Reflex-Dom-Internal.html
21:35:30 <Rotaerk_> there's very little information there apart from type signatures
21:35:31 <julianleviston> I feel like a bigger tutorial (meatier) would let you understand how it fit together better...
21:36:11 <Rotaerk_> also, the fact that this is called "Internal" should probably change, since it's the location of mainWidget which is not an internal thing...
21:36:58 <Cale> Well, also, a lot of this stuff has already been reorganised
21:37:23 <Rotaerk_> ah
21:37:35 <Rotaerk_> is there a planned date for the next version?
21:38:22 <julianleviston> I‚Äôm watching ‚Äúmodular web snippets with reflex‚Äù at the moment‚Ä¶ https://www.youtube.com/watch?v=8nMC2jL2iUY
21:38:23 <Cale> I don't think a specific date has been set, but it should be kind of soon.
21:38:31 <Cale> Soon (tm) :D
21:38:42 <Rotaerk_> Cale, can you think of a way for me to create windows and then attach reflex-dom to each, so that I can effectively have multiple "mainWidgets" in a single running process
21:38:48 <Cale> You can check out the functor-dynamic branch of reflex on github
21:39:00 <Rotaerk_> or should I just drop down to the gtk3 level for that
21:39:22 <Cale> and I think the branch for the new reflex-dom is called "refactor"
21:39:27 <Cale> ... yeah
21:40:34 <Cale> hmm
21:41:06 <Cale> I think that might work
21:42:04 <Rotaerk_> I do see that WebView is just a Window ... was just trying to find a way to start with one, and produce a widget from that
21:42:23 <Rotaerk_> so I was just going to dig into the implementation of mainWidget and try to build something custom from the ground up
21:43:34 <Rotaerk_> I see a runWithWebView, though it's not clear how to use that...
21:43:44 <Cale> attachWidget already does everything via postGUISync
21:44:41 <Cale> So it might actually work just to forkIO
21:45:09 <Rotaerk_> ah, so just use a separate thread for each mainWidget
21:45:15 <Rotaerk_> I'll try that
21:45:15 <Cale> Will the various windows need to communicate with each other though?
21:47:01 <Cale> Well, I dunno, if that works out (I have no idea, never really tried that), then I suppose we could work out ways to have communication between the threads.
21:47:02 <Rotaerk_> no, they're basically independent; there's going to be a non-GUI thread that's running and producing independent windows, and I think that thread will need to communicate with each of the windows potentially ... though I need to think through that
21:48:22 <Rotaerk_> the idea here is it's a background daemon that's controlled through commandline tools; the tools give a command to the daemon, which can respond to them by creating a window
21:49:19 <Rotaerk_> the daemon is going to be an IRC client, and I would have a commandline command like "show #haskell" or something, at which point a window pops up showing the current state of the (already connected) #haskell channel
21:50:36 <Welkin> if this is a desktop application, then how/why are you using reflex-dom?
21:50:40 <Rotaerk_> the main reason for the daemon is to centralize all the windows into a single process, rather than having a separate process for every channel (otherwise the "show" command could create its own window and leave it running)
21:50:49 <Welkin> some kind of electron thing?
21:51:14 <Rotaerk_> Welkin, reflex-dom is built upon GHCJS DOM, which can compile to a web application for the browser using GHCJS *or* to a desktop application via GHC
21:52:04 <Cale> Welkin: Because reflex-dom is not only for web applications.
21:52:05 <Rotaerk_> if the latter, it'll use webkitgtk3 to create a window that presents the web-GUI
21:52:31 <Rotaerk_> it's a neat alternative to using a desktop GUI framework directly
21:52:56 <Rotaerk_> one advantage is that if you build it a certain way you could easily change it back and forth between being a web application and being a desktop application
21:53:14 <Rotaerk_> (I will probably not be doing it that way though...)
21:55:06 <Rotaerk_> anyway, bedtime in a bit; I'll try out the forkIO approach tomorrow
22:44:09 <athan> What is the property of a language called where the type of an expression doesn't change when the expression is evaluated?
22:46:50 <Maxdamantus> athan: monomorphic?
22:46:52 <Myrl-saki> https://hackage.haskell.org/package/pwstore-purehaskell-2.1.4/docs/Crypto-PasswordStore.html
22:46:56 <Myrl-saki> Is this side channel safe?
22:47:06 <peddie> athan: not sure, but maybe "sane?"
22:47:36 <peddie> athan: something to do with normalization?
22:47:51 <Maxdamantus> athan: what do you mean by the type of an expression changing exactly?
22:48:04 <athan> peddie: I remember there being a specific name for it, but sane works :)
22:48:16 <athan> Maxdamantus: Well, solely through evaluation
22:48:36 <athan> but there are some semantics that may change the type of an expression through eta conversion if I remember right
22:48:46 <peddie> athan: can you give an example of an expression where this happens?
22:49:20 <athan> like for instance, if ($) = \f -> \x -> f x, through (unbounded) eta conversion that's eqivalent to ($) = \f -> f
22:49:26 <geekosaur> Myrl-saki, do you have a specific concern?
22:49:35 <athan> unless I'm just wigging out here
22:49:56 <Maxdamantus> Ah, there is a technical term for something like that.
22:50:19 <athan> Just like how hlint will warn you "Hey, there's an eta there you can get rid of!", however this one /kinda/ changes the type
22:50:24 <athan> (it makes it more general, but still)
22:50:25 <Maxdamantus> at least, for systems including reduction where a valid program contiues to type after each step of reduction.
22:50:32 <peddie> athan: '($) :: (a -> b) -> a -> b' vs. '($) :: (a -> b) -> (a -> b)'?  I'm not sure I get it yet
22:50:41 <geekosaur> it looks like a standard PBKDF1 implementation, which should be safe. I have not (and am not really qualified to) audited the source though
22:50:50 <athan> peddie: Yeah you get what I'm saying :)
22:50:58 <athan> inferred though, the latter would just be `a -> a`
22:51:04 <athan> not `(a -> b) -> (a -> b)`
22:51:21 <athan> so I guess I'm wrong, sorry about that
22:51:23 <peddie> I think it would be -> a -> b (i.e. the parens wouldn't be there) if it were inferred
22:51:42 <peddie> but I think they're the same type, unless I'm misunderstanding something
22:52:54 <shachaf> Myrl-saki: What side channel are you worried about?
22:55:14 <shachaf> I didn't know anyone used PBKDF1 these days.
23:09:47 <Myrl-saki> geekosaur: Nah. Just making sure that it's safe.
23:10:10 <Myrl-saki> shachaf: Probably timing attacks, because Haskell.
23:28:45 <ridecar2> Hi all
23:33:43 <julianleviston> ridecar2: hi
23:34:09 <julianleviston> (on behalf of all 1368 others in the channel) ;-)
23:35:07 <ridecar2> Does anyone have any recommendations for where to learn Haskell with real-world examples rather than all the talk of monads and other theoretical terms that make Haskell seem complicated?
23:35:40 <julianleviston> ridecar2: I guess that depends on what your definition of ‚Äúreal world‚Äù is :)
23:36:02 <julianleviston> ridecar2: it‚Äôs pretty difficult to learn how to build a web app without using things that seem complicated in any language.
23:36:07 <julianleviston> (for example)
23:36:26 <julianleviston> Also depends what your programming history/background is, a bit.
23:36:26 <ridecar2> I'm thinking simpler than that, just simple IO
23:36:44 <julianleviston> Is simple IO just outputting and inputting strings?
23:36:53 <ridecar2> Currently program in C# and F# mainly
23:37:00 <pavonia> @where rwh
23:37:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:37:35 <julianleviston> ridecar2: our tutorial doesn‚Äôt mention any complicated things: http://happylearnhaskelltutorial.com
23:39:00 <ridecar2> Thank you for the links - I'll have a play with them
23:39:28 <EvanR> ridecar2: good idea there should be a tutorial series on "just get simple stuff done now" 
23:39:51 <EvanR> which you can totally do, and would motivate understanding more of the things you end up doing in the process
23:39:59 <julianleviston> pavonia: FWIW, the first link doesn‚Äôt work for me at the moment‚Ä¶
23:40:03 <EvanR> not everyone wants to learn from the very bottom up
23:40:24 <ridecar2> I might have a crack at blogging this - or even live streaming my learning
23:40:46 <julianleviston> EvanR: isn‚Äôt that what RWH is?
23:40:58 <EvanR> you dont need to know anything about monads to use IO and write processing programs
23:41:09 <EvanR> julianleviston: from the name of the book, you would think
23:41:18 <julianleviston> EvanR: from reading it, I‚Äôd think :)
23:41:57 <julianleviston> EvanR: but fair enough‚Ä¶ it *is* getting *very* long in the teeth
23:42:04 <EvanR> i got more out of an ancient tutorial i cant find anymore that was "enough crap, this is how you do IO in haskell"
23:42:43 <julianleviston> Ah‚Ä¶ you don‚Äôt mean the hard fast intro the Haskell? I found that pretty nice
23:42:59 <EvanR> nah
23:43:07 <EvanR> it was short
23:43:08 <julianleviston> http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
23:43:18 <julianleviston> Just linking for ridecar2 ‚Äôs interest
23:45:18 <julianleviston> ridecar2: is polymorphism a complicated math term?
23:45:36 <ridecar2> Not at all - that's a word I do understand!
23:45:44 <julianleviston> ridecar2: (just digging you a little about your ‚Äúcomplicated math terms‚Äù jibe)
23:45:58 <ridecar2> I like the hard way style of learning too
23:46:45 <ridecar2> I was thinking of words like monad and monoid, things that you seem to grasp and then lose all ability to explain to those of us who don't understand them
23:46:48 <julianleviston> Just so you know, this wasn‚Äôt written by zed shaw or anything
23:47:10 <julianleviston> ridecar2: they‚Äôre super easy...
23:47:20 <julianleviston> ridecar2: so long as you understand their precursors...
23:47:28 <ridecar2> The closest I got with monads was that if you passed functions through other functions then magic happened and state would flow
23:47:56 <julianleviston> ridecar2: don‚Äôt even try for those until you understand what typeclasses are (they‚Äôre nothing like object classes) or what polymorphic values are...
23:48:00 <EvanR> ridecar2: the naming might be off putting... try translating Functor to Mappable, Monoid to Fusable, and Monad to Flattenable
23:48:14 <EvanR> i havent tried this on a real person yet though
23:48:28 <EvanR> but i have failed to explain monads before i just stopped trying
23:48:41 <julianleviston> Yeah, you‚Äôve used them all for years if you‚Äôve done other programming. Haskell just names the abstract thing, and lets you talk about them.
23:49:03 <EvanR> :t join
23:49:05 <lambdabot> Monad m => m (m a) -> m a
23:49:14 <ridecar2> So - Monad could be thought of as SelectMany?
23:49:15 <EvanR> > join [[1,2,3],[3,4,5]]
23:49:16 <lambdabot>  [1,2,3,3,4,5]
23:49:24 <EvanR> > join (Just (Just 3))
23:49:26 <lambdabot>  Just 3
23:49:30 <EvanR> > join (Just Nothing)
23:49:32 <lambdabot>  Nothing
23:49:59 <ridecar2> is lambdabot executing your haskell lambdas by any chance?
23:50:02 <julianleviston> yes.
23:50:07 <EvanR> its evaluating expressions
23:50:10 <EvanR> and showing types
23:51:19 <ridecar2> So Join flattens monads for me? I guess Map does what I would ordanarily expect it to do?
23:51:33 <EvanR> > fmap (+1) (Just 3)
23:51:35 <lambdabot>  Just 4
23:51:37 <EvanR> :t fmap
23:51:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:52:07 <julianleviston> > fmap (+1) [1,2,3]
23:52:08 <lambdabot>  [2,3,4]
23:52:39 <heebo> hello , I'm doing an exercise where I have to create a traversable instance of a ConsList datatype, Im quite sure my answer is correct and yet...... my checkers test fails
23:52:52 <heebo> does this look correct?
23:52:56 <EvanR> join (print (fmap ord getChar)) -- would be an IO action to get a single char input, convert it to a number, then print the number... a bit more complex example that might look better with do notation
23:52:56 <ridecar2> Ahhh - so a Functor is just anything that map knows how to work with?
23:53:04 <julianleviston> ridecar2: yep.
23:53:23 <EvanR> Functor is a fancy word for Mappable
23:53:27 <EvanR> fmap is the operation
23:53:28 <julianleviston> ridecar2: but trying to understand this without having studied typeclasses is ‚Ä¶ well, you should learn typeclasses first.
23:53:30 <heebo>   traverse f Nil = pure mempty
23:53:30 <heebo>   traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs
23:53:31 <heebo>  
23:53:33 <heebo> ?
23:54:28 <EvanR> my example i messed up...
23:54:37 * ridecar2 goes to look up typeclasses 
23:54:42 <EvanR> but enough shenanigans
23:54:44 <heebo> It feels so right, one thing i wondered was whether it would end up with a reversed list 
23:55:10 <shachaf> ridecar2: I suggest that you read the FAQ entry about monads.
23:55:13 <shachaf> @faq
23:55:13 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:55:30 <shachaf> ridecar2: https://wiki.haskell.org/FAQ#The_M-word
23:55:36 <shachaf> In particular 8.3.
23:56:27 <shachaf> Some people make a lot of fuss about monads, but really there are lot of more interesting Haskell features that you should learn about first.
23:56:37 <ridecar2> I think I get typeclasses - they seem to be what we really want when we have to use interfaces in another language, or to put it another way: a class of types?
23:56:50 <julianleviston> ridecar2: yep. :) 
23:56:58 <EvanR> a type class is a class of types, thats not saying much
23:57:30 <EvanR> and there are other patterns for doing interfaces that might be more appropriate
23:57:38 <julianleviston> ridecar2: but they also specify a set of functions that, when a type gets ‚Äúmarked as being an instance of that typeclass‚Äù, you must implement‚Ä¶ which means they will always have them...
23:57:38 <heebo> yep, they are a bit more flexible though - i would say interfaces are a good analogy however
23:57:57 <julianleviston> ridecar2: Silly robot picture of the Num typeclass here: http://www.happylearnhaskelltutorial.com/1/output_other_things.html#s7.4
23:58:14 <EvanR> oh jeez
23:58:27 <EvanR> battle of the ridiculous haskell tutorials ;)
23:58:36 <julianleviston> EvanR: why is it ridiculous?
23:58:38 <julianleviston> EvanR:  :)
23:59:08 <heebo> ok cheerio ppl Ill ask my question again another time
23:59:47 <cocreature> heebo: your instance looks fine
