00:07:40 * hackagebot sdr 0.1.0.8 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.8 (adamwalker)
00:07:40 * hackagebot llvm-ffi 3.0.0.2 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.0.0.2 (HenningThielemann)
00:54:24 <lkkkk> I was trying to run some of the unit tests in `haxl` test folder. 
00:54:53 <lkkkk> using REPL in emacs to load the file failed as it suggests `Haxl` is missing
00:55:09 <lkkkk> is that related to the folder level I am at ?
00:56:22 <lkkkk> how to run test in REPL ?
01:05:11 <sgronblo> Hey, guys I'm trying to get ghc-mod to show errors for me in vim. I used stack with lts-6.9 to install a global ghc-mod. It can show the expected errors when I run ghc-mod check from the command line. However my ghcmod-vim (I think, or is this syntastic?) doesnt seem to show the same expected errors.
01:12:11 <joe9> I am trying to represent this with Haskell Datatypes, Any suggestions, please?  http://bpaste.net/show/3eb1e1388f16 . A request can be one of 4 types (heartbeat, ordersubscription,marketsubscription,authentication)
01:12:24 <joe9> each of these different types have different fields
01:12:57 <joe9> when the request is being sent, the first field is a string that is "heartbeat" -- for the heartbeat message, "ordersubscription" -- for the order subscription message
01:12:59 <joe9> and so on.
01:13:37 <joe9> I could do: Request = Heartbeat String Int | OrderSubscription String Int Int Int | ..
01:13:40 <joe9> and so on,
01:14:33 <joe9> but, in the ToJson instance of Request, the first field should be hardcoded to a string based on the type of Request it is.
01:15:00 <Cale> That's okay, you can just write the instance manually.
01:15:37 <joe9> I would ideally like to have Heartbeat = Heartbeat {op :: String, id :: Int} and so on as I get the ability to use the field names when adding data.
01:16:44 <joe9> then it would be data Request, where Heartbeat message would have an instance for Request.
01:16:59 <joe9> Any suggestions or recommendations, please?
01:17:43 <joe9> or, I could represent them using GADT's, but, I am not sure if I gain anything by doing that.
01:18:25 <joe9> sorry, not "data Request", "Class Request with a method of ToRequest"
01:19:28 <Cale> You can use field names in the other case as well.
01:19:41 <Cale> It's possible to have field names and multiple constructors.
01:19:59 <joe9> Cale, ok, cool. I did not know about that.
01:20:15 <Cale> (Though you then need to be cautious about using the field extractor functions, because they're partial if the same field doesn't occur in all the cases)
01:20:55 <joe9> Request = Heartbeat {op:: String, id :: Int} | OrderSubscription ..
01:21:19 <joe9> Cale, that would be harder to define when using Type definition's correct.
01:21:50 <joe9> for op :: Request -> String, but, I have to be sure that the Request is only of Heartbeat type.
01:22:03 <joe9> in that typedefinition.
01:22:08 <Cale> Yeah
01:22:31 <Cale> (also, you probably should avoid naming fields id, since that's a Prelude function)
01:22:37 <joe9> Cale, Isn't it easier to have a typeclass Request? then, the type definitions would not get confusing.
01:22:52 <Cale> Well, it depends on what you need to do with these things
01:22:57 <joe9> Cale, yes, I agree about id, it is just an example.
01:23:05 <Cale> Also, what would the operations of the type class be?
01:23:18 <joe9> Cale, ToRequest is the only method of the class.
01:23:50 <joe9> In most cases , toRequest = toJson
01:24:11 <joe9> but, with the record name customized to be Request.
01:25:04 <sgronblo> Hmm, maybe this is because of this "ghc-mod 5.4.0 wants to run in the root directory of the project; syntastic can't cope with the resulting complications"
01:25:06 <joe9> for example, Heartbeat "heartbeat"  1 ==> "request":{"op":"heartbeat","id":1}
01:25:32 <joe9> this conversion would be defined in the toRequest method.
01:26:37 <Cale> Unless you need the TH/generic behaviour of toJson for the type, you could just write your own ToJSON instance
01:26:59 <Cale> which produces just the JSON that you need from the outset
01:27:17 <joe9> Cale, yes, I agree.
01:27:29 <joe9> Cale, So, you recommend the "Class Request " approach?
01:27:52 <Cale> Well, I don't really understand why there needs to be a new class.
01:29:23 <joe9> Cale, oh, I think I understand what you are saying. Just have "data Heartbeat = Heartbeat {op:: String, id:: Int}" and so on for the different requests.
01:29:42 <joe9> Cale, but, have custom ToJson instances for each.
01:29:46 <Cale> yeah
01:29:54 <joe9> makes sense. Thank.s
01:30:03 <joe9> Cale, Thanks a lot.
01:30:05 <Cale> Which data type or types you use to represent it is more of a concern on the Haskell side of things
01:42:27 <freeside> i dealt with a similar situation recently by saying `class Message where myid :: Int` and then inside `data Heartbeat = Heartbeat { heartbeatid :: Int }` and finally `instance Message Heartbeat where myid = heartbeatid`. that allows you to distinguish ids across different types of messages without colliding over the `myid` field name.
01:43:12 <freeside> i don't know if that's a good pattern or not though.
01:43:23 <freeside> it was just the first thing that came to mind, which tells you something.
01:44:19 <joe9> freeside: Thanks for the suggestion.
01:44:59 <joe9> freeside: Did you have a ToJson instance on Class Message?
01:46:49 <freeside> oh, i didn't do any JSON for this, in my case i am actually dealing with investment rounds, which contain tranches; i have roundName and trancheName so i have a nameOf accessor across all the types for output purposes, under a class NamedThing
01:47:24 <freeside> nameOf someRound = roundName someRound; nameOf someTranche = trancheName someTranche.
01:51:28 <freeside> in your case, analogous to class NamedThing, you might have class JSONThing, and each type would have an instance that outputs JSON as desired for the given type
01:52:37 * hackagebot hakyll-ogmarkup 1.0 - Integrate ogmarkup document with Hakyll  https://hackage.haskell.org/package/hakyll-ogmarkup-1.0 (lethom)
01:53:55 <freeside> but i don't know if this is The Right Way to approach your problem, it is just My Way With Less Than 10 Hours Flight Time With Haskell
01:54:54 <freeside> (wouldn't it be cool if an IDE could actually track hours logged with specific languages, libraries, etc)
01:59:57 <joe9> aeson defines the Value data type differently.
02:00:16 <joe9> it seems to use the data Value = Object Object | Array Array | ..
02:00:31 <joe9> instead of using the typepclass they go for the record approach.
02:00:50 <cocreature> I’m running an action like 'putStrLn "start" >> try action >>= \res -> print res' inside of uninterruptibleMask_ but nevertheless I never see the final print statement, so it looks like something in between ends up killing it. any ideas what could cause this?
02:01:38 <cocreature> the only thing that comes to mind is if action would call System.Exit but I am pretty sure that is not the case
02:02:35 <cocreature> fwiw the action is connectPostgreSQL from postgresql-simple
02:04:18 <joe9> Cale, freeside, what does the '!' signify in this data defintion? http://bpaste.net/show/7c0633a5ec9d
02:04:22 <adarqui> im getting wrecked by parsec.. (well web-routes which uses parsec to parse urls).. shouldn't "try (..)" protect me from a parser resulting in Left? I keep getting an error like: but got: Left "[\"1\",\"2\",\"3\"] (segment 3 character 1): \nunexpected \"2\"\nexpecting end of input" .. yet, it's wrapped in try .. and i want it to fall through to the next parser
02:04:48 <joe9> It is cool that they have the Constructor with the same name as the value. How is that possible?
02:05:11 <lyxia> adarqui: can you show some code
02:05:20 <adarqui> ya lyxia: https://github.com/adarqui/ln-ui-core/blob/master/src/LN/UI/Core/Router/Route.hs#L212
02:05:59 <adarqui> it's not that exact line, but that series of try's ..  For example, i'm doing: fromPathInfo "/ln/f/community/_new"      `shouldBe` (Right $ OrganizationsForumsBoards "ln" "community" New)
02:06:08 <joe9> For example, in "= Object !Object", there can be a constructor with the same name as a type?
02:06:41 <mniip> because one is a name in the type namespace and other is a name in the value namespace
02:06:47 <adarqui> and right now, my code is parsing like this:
02:06:48 <adarqui>     <|> (try (OrganizationsForums <$> str1 <*> (segment "f" *> (fromPathSegments :: URLParser CRUD))) <?> "OrganizationsForums failed")
02:06:51 <adarqui>     <|> (try (OrganizationsForumsBoards <$> str1 <*> (segment "f" *> notCRUD) <*> (fromPathSegments :: URLParser CRUD)) <?>
02:06:54 <adarqui> "OrganizationsForumsBoards failed")
02:06:56 <adarqui> sorry
02:07:03 <adarqui> im trying to just get that first parse to fail, so it falls through to the second one
02:07:09 <adarqui> but, it's failing completely in that first one
02:07:14 <mniip> the two never intersect
02:07:22 <mniip> except for DataKinds where you have ' to disambiguate
02:07:23 <adarqui> i've been changing up the code a bunch trying to get it to work so, i'm all over the place right now
02:08:24 <adarqui> i just thought that first try, that i pasted just above.. i figured if that failed for any reason, it would fall through to the next parser
02:08:30 <adarqui> but it's causing everything to completely fail
02:09:59 <adarqui> for example, if i change that first try (OrganizationsForums .... segment "g" ...), it'll fail correctly and the next parser will succeed
02:10:22 <joe9> mniip: Thanks, What does the ! signify?
02:10:29 <mniip> strictness
02:10:35 <adarqui> but once i change it back to segment "f" .. I getthat error: Left ... expecting end of input.
02:11:01 <mniip> joe9, whenever you have a WHNF of "Object x", x will be in WHNF too
02:11:05 <joe9> mniip: ok, Thanks.
02:11:16 <mniip> iow, the 'Object' constructor is strict
02:11:24 <freeside> joe9: https://www.vex.net/~trebla/haskell/strict-field.xhtml
02:11:24 <joe9> mniip: What is WHNF?
02:11:30 <mniip> weak-head normal form
02:11:31 <joe9> freeside, Thanks.
02:11:36 <adarqui> reading this right now http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
02:15:01 <lyxia> adarqui: I missed something. If you put try, "it'll fail correctly and the next pasrser will succeed"? Isn't that expected behavior?
02:16:10 <adarqui> nah, it only succeeds if i make the first parser fail by writing segment "g" for example. my routes have segment "f" .. i was just saying, as an experiment, by changing "f" to "g" in the first try.. i can get it to hit the second parse successfully
02:16:40 <lyxia> adarqui: Have you tried making try range over the whole alternative?
02:17:02 <lyxia> ... no nevermind that's what you did
02:17:10 <adarqui> ya
02:27:11 <adarqui> well this has taught me something so far, even tho i havent fixed it... i got rid of some try's inside CRUD's fromPathInfo instance
02:27:15 <adarqui> which is really cool
02:27:29 <adarqui> i bet once i get rid of all of them.. (the try's), ill get a better error message
02:27:55 <lyxia> indeed.
02:28:08 <adarqui> hmm .. i think now i might have more power, by removing these try's
02:28:18 <adarqui> <-- feels the power
02:28:19 <lyxia> I have no idea why your code didn't work though.
02:28:30 <adarqui> cool! why?
02:28:40 <lyxia> I said I have no idea :D
02:29:10 <adarqui> oh. . it's nearly 6 am and my brain is fried
02:29:21 <adarqui> so i "incorrectly parsed", "no" for "an"
02:29:26 <adarqui> so my brain parser is broken
02:30:30 <adarqui> lyxia: thanks alot though for looking at it and trying to help
02:34:06 <mrCyborg> I have a question about how lazy haskell is, if I run `take 3 (quicksort [5,4,7,2,8,5,2,7,3,8,4,8])` and halfway thou the sorting it already got the first 3, does it stop and not calculate the rest?
02:36:04 <mniip> depends on the implementation of quicksort
02:36:05 <dibblego> that depends on the definition of quicksort
02:36:08 <mauke> I don't think quicksort can do that
02:36:38 <mrCyborg> as taken from learnyouahaskell:
02:36:40 <mrCyborg> quicksort :: (Ord a) => [a] -> [a]  
02:36:40 <mrCyborg> quicksort [] = []  
02:36:40 <mrCyborg> quicksort (x:xs) =   
02:36:40 <mrCyborg>     let smallerSorted = quicksort [a | a <- xs, a <= x]  
02:36:40 <mrCyborg>         biggerSorted = quicksort [a | a <- xs, a > x]  
02:36:41 <mrCyborg>     in  smallerSorted ++ [x] ++ biggerSorted  
02:37:07 <mniip> > take 3 ([5,4,7,2] ++ undefined)
02:37:10 <lambdabot>  [5,4,7]
02:37:38 * hackagebot pia-forward 0.1.0.2 - Set up port forwarding with the Private Internet Access  VPN service.  https://hackage.haskell.org/package/pia-forward-0.1.0.2 (EchoNolan)
02:37:40 <mniip> quicksort is strict in all list elements though (and so the list spine too)
02:37:52 <ggole> There are special purpose algorithms for partial sorting
02:39:14 <mrCyborg> ok, tnx
02:39:15 <shachaf> > take 2 $ sort [(2,5),(1,2),(2,undefined),(1,3)]
02:39:17 <lambdabot>  [(1,2),(1,3)]
02:39:19 <shachaf> > take 3 $ sort [(2,5),(1,2),(2,undefined),(1,3)]
02:39:22 <lambdabot>  [(1,2),(1,3)*Exception: Prelude.undefined
02:40:26 <ggole> Isn't that laziness of the comparator, and not of sort?
02:43:09 <mniip> both
02:43:37 <mniip> if at least one thing is strict then the entire thing is
02:44:51 <ggole> I'm not sure I understand that. When a comparison of (say) (1, 2) and (2, undefined) is made, the calculation is finished before the second element is inspected.
02:45:22 <ggole> The sorting algorithm doesn't have any bearing on that, surely.
02:46:18 <mauke> yes, but comparing (2,5) and (2,undefined) will inspect the second element
02:46:43 <Xnuk> > (1,5) > (5,1)
02:46:45 <lambdabot>  False
02:46:54 <ggole> Yes, this is what I thought I meant by the (in retrospect, awfully vague) phrase 'laziness of the comparator'
02:47:15 <ggole> I don't think we are actually disagreeing here.
02:47:35 <mniip> if sort was strict we wouldn't see the first 2 elements
02:48:04 <ggole> Oh, I see
02:49:13 <mrCyborg> thanks guys, haskell is even more awesome that I thought.
02:56:43 <adarqui> lyxia: here's how I did it without try.. it's absolutely atrocious but i just wanted to see if it would work: https://github.com/adarqui/ln-ui-core/blob/master/src/LN/UI/Core/Router/Route.hs#L222     .. HEH
02:58:04 <adarqui> actually i left out some tests.. it doesn't work
02:58:20 <adarqui> just brought back the unit tests .. broken . think i might give up for tonight
03:21:15 <dominik> Hi, for creating a website with basic cms capabilities, what Haskell web framework would be the best choice?
03:21:39 <dominik> wrt ease of use and implementing basic CMS features done quickly?
03:22:27 <liste> dominik: why not use clkwrks?
03:22:44 <liste> well, I guess it's too early in development
03:23:19 <liste> dominik: Yesod is the most out-of-the-box framework
03:23:48 <dominik> hmm, ok. I'd try to avoid Template Haskell though, if possible
03:23:56 <dominik> isn't yesod heavily based on that?
03:24:04 <liste> yes
03:24:44 <dominik> hmm, then I would rather go with Scotty or servant, I think.
03:24:55 <maerwald> dominik: you can also look at Snap
03:25:10 <liste> Spock is a safer brother of Scotty
03:25:21 <dominik> ok, but all of those seem to me pretty low-level in the sense that I'd have to implement all the CMS functionality from scratch
03:25:46 <dominik> so I'm wondering if there is something that already gets me halfwhere to a cms.
03:26:01 <dominik> maybe its clkwrks indeed.
03:35:58 <cocreature> iirc there is also something called lambdacms but I have no idea what the status of that project is
03:45:34 <dominik> ok, thanks. I'll have some further looks!
04:03:37 <ongy> is anyone here using ghcmod-vim with ghc-8.0?
04:06:05 <freeside> emacs 4ever!!!1111  \m/
04:06:41 <piyush-kurur> freeside: +1
04:07:21 <piyush-kurur> although I would be interested in yi becoming the de-facto editor
04:09:38 <freeside> oh, neat. i've actually been quite productive (as a beginner) using Haskell for Mac, because with auto-revert-mode on in emacs, there's seamless roundtripping between the two -- i can have a file open in both at the same time and edit in either, and the other will autoreload if it sees an updated timestamp.
04:10:57 <freeside> well, yi looks cool. i didn't know about that. thanks!
04:13:24 <maerwald> the guy asked about vim, not emacs
04:14:06 <ongy> maerwald: mentioning either one usually get's the other one mentioned...
04:14:43 <maerwald> which is not particularly helpful
04:18:50 <hexagoxel> > let in equal 14
04:18:51 <lambdabot>  Defined.
04:19:22 <hexagoxel> > in
04:19:24 <lambdabot>  <hint>:1:1: parse error on input ‘in’
04:19:55 * hexagoxel giggles
04:21:10 <dysfun> is there an already existent function \f -> f l ?
04:21:19 <dysfun> where you'd give it l
04:21:49 <Maxdamantus> ($ l)
04:21:55 <dysfun> oh yeah :)
04:21:56 <dysfun> thanks
04:22:31 <Maxdamantus> @pl \f -> f l
04:22:31 <lambdabot> ($ l)
04:22:40 <petercommand> @unpl \f -> fl
04:22:41 <lambdabot> \ f -> fl
04:22:50 <petercommand> @unpl ($ l)
04:22:51 <lambdabot> (\ a -> a l)
04:23:01 <dysfun> :)
04:23:54 <Maxdamantus> @unpl const . id
04:23:54 <lambdabot> (\ e _ -> e)
04:26:50 <freeside> @pl \(a,b) -> a:b:[]
04:26:50 <lambdabot> uncurry ((. return) . (:))
04:28:21 <osfameron> freeside: ooo, Haskell for Mac looks quite cute
04:28:54 <osfameron> I'm always a bit skeptical about that sort of programming environment, but then I've not really tried it for serious coding
04:29:15 <dysfun> oh hello osf', long time no see
04:29:21 <osfameron> guess it's great for learning though, like Scratch
04:29:23 <osfameron> hey hey ;-)
04:30:19 <ongy> :t const
04:30:20 <lambdabot> a -> b -> a
04:31:27 <freeside> mostly i keep haskell for mac on the RHS of my screen and emacs^H^H^H^H^H^H my editor on the left, and i watch the output / errors automatically appear every time i save
04:35:27 <osfameron> I'd have suspected emacs could do that by itself?  flymake or such?  (not that I have much experience with emacs, but did play with flymake some time back)
04:35:48 <dysfun> intero?
04:36:01 <dysfun> (which definitely does not 'just work' here)
04:36:31 <osfameron> fair enough.  Tooling Is Hard ;-)
04:36:46 <dysfun> yes. and they try to be very clever and then only test it on major distros
04:36:56 <maerwald> ongy: you didn't really ask a question. Try not to ask for people
04:37:16 <freeside> or you will get a type error
04:37:19 <ongy> I mainly wanted to know if someone is using it, since it's not working for me
04:37:37 <maerwald> "not working for me" is too unspecific to help
04:37:57 <ongy> but (if I did my testing right) it also doesn't work with 7.10
04:38:09 <ongy> where "doesn't work" is GhcModType fails with cannot guess type
04:39:47 <mniip> :t uncurry (++) . bimap return return
04:39:49 <lambdabot> (a, a) -> [a]
04:40:03 <ongy> :t bimap
04:40:05 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
04:40:47 <maerwald> ongy: that functionality is part of ghcmod-vim, not haskell-vim
04:41:19 <ongy> maerwald: yes? That's why I asked about ghcmod-vim
04:41:47 <maerwald> oh, I misread then
04:41:54 <maerwald> https://github.com/eagletmt/ghcmod-vim/issues/34 this is the only thing that sounds familiar
04:42:41 <ongy> I can use ghc-mod binary, it's the ghcmod-vim part that fails
04:43:02 <maerwald> as in: you probably have an error for the file, so it then cannot guess the type
04:45:53 <maerwald> should probably try :GhcModCheck first
04:47:02 <ongy> ghc-mod check: No errors found (and as I said, binary works so ghc-mod has no problems)
04:47:39 <ongy> but I have ghc-mod 5.6, since the one on hackage didn't build with ghc-8.0
04:47:45 <ongy> so maybe something changed
04:48:13 <cocreature> what can cause an action inside of a try inside of an uninterruptibleMask_ to fail? I have something like uninterruptibleMask_ $ putStrLn "start" >> try action >> putStrLn "end", but for some reason something seems to break in action (it’s not an infinite loop) and I never get to the the final putStrLn
04:48:25 <freeside> argh, i went to check out intero which means i needed stack which got me to a cabal error "The following packages are likely to be broken by the reinstalls" and that is one yak too far to shave
04:48:43 <cocreature> I can only come up with System.Exit which doesn’t make sense or a segfault which could be the case but would be quite surprising
04:49:09 <freeside> cocreature: if you have a try, shouldn't you have a catch?
04:49:53 <cocreature> freeside: try is an alternative to catch, why would I need a catch in addition to that?
04:53:46 <ongy> ahh, I think I found my problem
04:53:59 <ongy> maerwald: thanks for the help
04:54:12 <freeside> cocreature: well, i mean, are you looking at the Right/Left values that are being returned by the try?
04:54:17 <maerwald> it's rude to say "I found the problem" and then disappear...
04:54:48 <ongy> I'm not gone. And I still have to try if it's really the problem
04:54:54 <maerwald> like... I'm looking for a solution to a weird problem and find a forum thread from 2003... where one guy ends up saying "found the problem" (which is the last response) :D
04:55:12 <freeside> yes, we like our error Q&As to be strictly evaluated with values verbosely returned, please
04:56:34 <ongy> ok, so I used the haskell-vim-now script to set everything up, and it installed ghc-mod (5.5) in ~/.local/bin, which fails because my system compiler is ghc-8.0. Since my vim session ignored path and used that ghc-mod, the ghc-mod 5.6 I installed with cabal (which worked) was never used in vim
04:57:10 <cocreature> freeside: well my actual code is looking at the Right/Left values, and changing the final putStrLn, but that’s not important. what I want to know is what causes my action (which is connectPostgreSQL from postgresql-simple) to fail. it can’t be an exception because async exceptions are hidden by uninterruptibleMask_ and sync exceptions are caught by the try
04:57:15 <freeside> ongy: heh, this sounds like it's shaping up to be a classic case of https://www.youtube.com/watch?v=lKXe3HUG2l4
04:57:24 <maerwald> never used haskell-vim-now, which is just a few shell scripts and an ominous vim configuration
04:57:53 <cocreature>  I sadly don’t have a minimal example yet
04:58:10 <cocreature> it only seems to occur if I am using it in the cleanup part of a bracket
04:58:19 <ongy> maerwald: it is, but it was easy to get a nice couple of plugins. maybe I'll extract what I need at some point
04:59:05 <adarqui> anyone here use hindent? thinking of using it. my coding style isn't that "standard" .. i like the "cramer" style in hindent
04:59:11 <adarqui> hindent --style cramer ;f
04:59:18 <cocreature> adarqui: I use it all the time
04:59:21 <osfameron> given you can start vim with an arbitrary .vimrc, I don't even understand why haskell-vim-now feels the need to overwrite your default one (and have to go to the faff of backing up your old one etc.)
04:59:25 <cocreature> I’m way too lazy to format my code
04:59:36 <adarqui> cocreature: cool! im not too lazy but it's starting to get annoying
04:59:40 <adarqui> why waste that time
04:59:56 <adarqui> do you have your own style? or do you use one of the existing ones?
05:00:04 <cocreature> I use the chrisdone style
05:01:09 <maerwald> imo, strict coding style doesn't make too much sense. There are various cases where you should manually align code so that it reads easier
05:01:18 <maerwald> at least in haskell
05:01:19 <adarqui> nice. i think i might want to make my own style.. a mix between chris-done and cramer. for example, i like one functions/class/data type per line, in the export list
05:02:31 <cocreature> maerwald: sure I still manually indent & align code sometimes, but in a lot of cases it’s good enough so it saves me time
05:04:47 <maerwald> What I find more important wrt coding style are questions like "when to use pointful or pointfree style". If you look at tools like hlint, they do the most poor job at it, by _always_ suggesting one (which can even be outright wrong, since they are not the same).
05:05:22 <adarqui> ya lots of the stuff hlint recommends for me, i dont like it.. come back to my code a week later and can't figure it out
05:05:26 <adarqui> don't use it that much
05:05:31 * ongy uses pointfree when he can think of a easy version
05:05:38 <maerwald> so that's something that should be a) removed from hlint and b) decided by the developer/project
05:05:40 <ongy> which makes it easy to read for me, but others? I have no idea
05:06:52 <Shockk> hello, I have a quick question about lens stuff;
05:07:59 <adarqui> ok cool thanks folks. gn!
05:08:12 <Shockk> I have a data type called SysState with a lens called "systems" that gets a [System] from the SysState
05:08:38 <Shockk> the data type System then has a lens called "tick" that gets a Sys () from the System
05:08:51 <Shockk> I'm trying to map over these in the following way:
05:09:02 <Shockk> sequence_ =<< use (systems . tick)
05:10:02 <Shockk> in other words, trying to perform the tick action for each system in the list, but I don't think this line of code is correct
05:10:30 <Shockk> does anyone have any ideas of how I'd do this?
05:13:52 <Shockk> I think I just managed it using the following
05:13:58 <Shockk> sequence_ . fmap (view tick) =<< use systems
05:14:18 <Shockk> it's kind of ugly though, I don't know if there's a more lens-y way to do it, but it works
05:14:37 <bennofs> Shockk: you can do: get >>= sequenceOf (systems.folded.tick) i think
05:15:31 <Shockk> oh I see
05:15:40 <Shockk> that looks a lot better
05:15:54 <Shockk> should it be folded or something more like mapped (if that exists)?
05:16:06 <bennofs> Shockk: definitely folded or traverse
05:16:11 <Shockk> ah right
05:16:14 <Shockk> I'll try
05:16:29 <bennofs> Shockk: oh, and sequenceOf_ instead of sequenceOf
05:16:35 <Shockk> ah yep
05:21:01 <Shockk> that did work
05:21:51 <Gurkenglas> Wait why would you want to do that line, it does a sideeffectless retrieval of information, then throws it away
05:22:12 <bennofs> Gurkenglas: it executes each Tick action
05:22:35 <Gurkenglas> "view tick"
05:22:49 <bennofs> Gurkenglas: sequence_ afterwards
05:23:16 <Gurkenglas> Yes, it views each tick, then throws them all away
05:23:28 <bennofs> Gurkenglas: no, it aggregates them all into one Tick and executes the aggregated action
05:23:51 <bennofs> Gurkenglas: use systems >>= traverse_ (view tick) would be them same
05:24:37 <Gurkenglas> void (view x) does nothing for any x
05:24:51 <Gurkenglas> (I mean (void $ use x))
05:26:19 <Gurkenglas> Oh, you mean that systems actually contains an action in its tick field, and view retrieves that action
05:26:33 <Shockk> exactly
05:26:56 <Shockk> data System = System { .. .. .. , _systemTick :: Sys () }
05:28:22 <Shockk> bennofs: I'm going to need to get my head around how this folded thing works now lol
05:28:29 <Shockk> it looks very useful
05:29:00 <Gurkenglas> And he actually explained that up there, shame on me
05:29:11 <bennofs> Shockk: 'systems . folded . tick' is a 'Fold' of 'Sys ()'. A fold is like a getter but instead of only one result it may return any number of results (even 0)
05:29:27 <Shockk> ohhh I see
05:29:59 <bennofs> Shockk: If a Getter s a is a function s -> a, then a Fold is like a function s -> [a] (not quite, because of some associativity differences for infinite structures I think, but almost)
05:31:04 <Shockk> hmm, so using folded with [a] acts sort of like a lens into each item of the list?
05:31:14 <bennofs> Shockk: sequenceOf_ takes a fold of a structure 's' and then sequences all the actions it gets by applying the fold to the structure 's'
05:31:28 <bennofs> Shockk: yes. sequenceOf_ folded === sequence_
05:31:42 <Shockk> that's pretty interesting
05:31:45 <bennofs> (or more like a Getter, because you cannot set with a Fold)
05:31:52 <Shockk> ah right
05:31:52 <Shockk> yes
05:32:14 <bennofs> Shockk: if you want something that acts like a Lens that focuses on multiple locations, that would be a Traversal
05:32:15 <Shockk> is there a way to write this without the extra `get >>=`?
05:32:29 <bennofs> Shockk: i don't think lens provides a function for that, no
05:32:34 <Shockk> ah okay
05:33:04 <Shockk> but, so, I could rewrite something else such as sequence_ =<< use tickFunctions, like the following?
05:33:12 <Shockk> sequenceOf_ tickFunctions =<< get
05:33:32 <bennofs> Shockk: well tickFunctions is probably a lens for a list field, right?
05:33:42 <Shockk> yep
05:33:45 <bennofs> Shockk: then you would need to write sequenceOf_ (tickFunctions . folded) =<< get
05:33:50 <Shockk> ohh I see
05:33:57 <Shockk> that makes sense
05:35:02 <Shockk> so in the case of systems.folded.tick, composing the fold (systems.folded) with tick produces another fold right?
05:35:55 <bennofs> Shockk: yeah, composing a Lens with a Fold gives a Fold (since that is the "common denominator", you might say, as a Lens is also a Fold of exactly one element)
05:36:09 <saurabhnanda> ===> Drawing attention to http://stackoverflow.com/questions/38644779/how-to-use-quickcheck-to-test-database-related-functions <====
05:36:11 <Shockk> right
05:36:41 <saurabhnanda> Have started a bounty as well. Don't know why the QuickCheck and Persistent types won't compose
05:39:29 <Shockk> Rainb: fancy seeing you here
05:42:08 <Shockk> anyway, thanks very much for the help bennofs 
05:44:34 <saurabhnanda> bennofs: thanks for looking at the stackoverflow link
05:52:15 <Gurkenglas> @karma+ bennofs
05:52:15 <lambdabot> bennofs's karma raised to 10.
05:55:33 <maybefbi> how do i share a value between two IO monads? i do not have the luxury of giving the value as arguments to both monads because one of them IO monads exist inside a heterogenous list managed by the servant's serveWithContext function.
06:02:53 <bennofs> Does stackage still host documentation for packages? Some packages are missing docs on hackage
06:06:58 <maybefbi> bennofs, try pressing older version numbers on the hackage page
06:07:34 <bennofs> maybefbi: yeah but then links between packages don't work and it is all quite annoying. stackage used to host documentation for the packages that it includes, but I can't find that anymore
06:08:19 <maybefbi> can you show me an example of what you need?
06:08:50 <bennofs> ah, it still does: https://www.stackage.org/haddock/lts-6.9/abstract-deque-0.3/Data-Concurrent-Deque-Class.html
06:09:57 <maybefbi> bennofs, ok
06:10:26 <carado> what’s the best way to report something that looks like a mistake in the haskell documentation ?
06:11:34 <bennofs> carado: in what package is it?
06:12:07 <carado> it’s in containers
06:12:55 <carado> oh right, there’s a link to the issue tracker on the hackage page, nevermind
06:12:57 <bennofs> carado: I think https://github.com/haskell/containers/issues would be best then
06:13:02 <carado> thanks
06:13:15 <mnjot> Hi. I'm using GHC version 7.10.3 (actually haskell stack from apt-get) and I can't get Data.Heap to work.
06:14:00 <mnjot> I tried "stack install heap", which seemed to do something but didn't, and "cabal install heap"  which just freezes.
06:17:44 * hackagebot decimal-arithmetic 0.3.0.0 - An implementation of Mike Cowlishaw's  General Decimal Arithmetic Specification  https://hackage.haskell.org/package/decimal-arithmetic-0.3.0.0 (RobLeslie)
06:17:54 <newhoggy> Hello, I'm getting an exception with in my code that uses vectors.  I was hoping that call stacks in ghc 8.0.1 would help me, but unfortunately, the call stack is rather shallow:
06:18:19 <newhoggy> https://gist.github.com/newhoggy/cd00a9b6353acc2b8bdd8735f1be61c1
06:19:09 <maybefbi> mnjot, what is the error you see?
06:19:53 <mnjot> Could not find module 'Data.Heap', perhaps you meant Data.Map
06:20:27 <newhoggy> Line 107 of LoadJson.hs does not contain any vector code, that code is much deeper, but doesn't appear in the callstack.
06:20:30 <newhoggy> https://github.com/haskell-works/hw-mquery/blob/0.0-branch/src/HaskellWorks/Data/LoadJson.hs
06:20:46 <newhoggy> Anything I can do to make the callstack more details?
06:20:50 <otulp> mnjot: did you fire up ghci using "stack ghci"?
06:20:59 <mnjot> ah. let me try that.
06:21:30 <mnjot> great, now I get other errors (which is good). Thanks!
06:21:43 <otulp> Goodie.
06:21:59 <mnjot> my problem is fixed, thanks everyone.
06:23:16 <maybefbi> newhoggy, use Debug.Trace if you can. call stacks are too new to allow for deepness i think
06:24:55 <newhoggy> I was afraid, you'd say that.  It's going to be difficult because I can only reproduce this with a 15MB JSON file.  I guess that will have to be what I do.  
06:28:07 <maybefbi> newhoggy, even if you find an error originating deep inside the call stack inside some standard vector code, it wont change the fact that index is out of bounds as the error says
06:34:20 <newhoggy> That's true.  But I'm looking for a bug in another library I wrote that uses vectors.
06:35:03 <newhoggy> As in, the bug is in hw-rankselect, but I can only reproduce it from hw-mquery.
06:37:44 * hackagebot llvm-tf 3.0.3.1.2 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.2 (HenningThielemann)
06:41:15 <ertesx> newhoggy: i haven't used call stacks myself, but note that GHC has some very aggressive optimisations
06:41:40 <ertesx> not only built-in ones, but also library-provided rewrite rules, especially for a library with stream fusion like vectors
06:42:20 <ertesx> so the first thing i would do is to use the interpreter instead of the compiler, or at the very least disable optimistations
06:43:07 <ertesx> newhoggy: also granular tests may be better to catch such edge cases than manual call tracing
06:43:55 <newhoggy> That could be it.
06:48:45 <saurabhnanda> yet another wall I'm hitting with simple webapp development in Haskell: https://www.reddit.com/r/haskell/comments/4vh4sg/recommended_way_of_dealing_with_db_associations/
06:57:08 <newhoggy> ertesx: You were right!
06:57:32 <saurabhnanda> what is the recommended way of dealing with DB-level associations in Haskell?
06:57:41 <newhoggy> I dropped the code from hw-rankselect into hw-mquery and I got a more comprehensive stack trace!
06:58:29 <ertesx> saurabhnanda: there is recommended way…  it depends on your abstraction
06:58:58 <saurabhnanda> ertesx: please, please give me pointers. I have spent enough brain cycles trying to get to the answer
06:59:12 <saurabhnanda> ertesx: I'm talking about one-to-many, many-to-many associations
06:59:13 <newhoggy> This will be a big time saver.  Thanks so much ertesx!
06:59:21 <ertesx> newhoggy: you're welcome
06:59:27 <saurabhnanda> ertesx: complete question at https://www.reddit.com/r/haskell/comments/4vh4sg/recommended_way_of_dealing_with_db_associations/
07:00:09 <ertesx> saurabhnanda: i can only tell you how i do it:  i don't use a DB abstraction, but instead write an application model (usually as a type, sometimes as a type class)
07:00:25 <ertesx> saurabhnanda: in implementations of the model i tend to use SQL directly
07:00:30 <saurabhnanda> ertesx: possible to share sample code?
07:00:57 <saurabhnanda> ertesx: probably years of ORM-level thinking is clouding my brain. If there is a pattern more suitable to FP, I want to learn it
07:01:53 <ski> maybefbi : hard to give advice without knowing more about the context. paste the code ? (also, you probably meant "two IO actions", not "two IO monads". the type `IO' itself is what is equipped with a monad structure, a value of type `IO T', for some type `T' is not a monad, it's a monadic action)
07:02:05 <ertesx> saurabhnanda: not right now, but the idea is rather simple:  data MyModel m = MyModel { newUser :: UserData -> m UserId, getUser :: UserId -> m (Maybe UserData), … }
07:02:43 <saurabhnanda> and UserData is probably coming from a JSON or HTML Form?
07:03:03 <saurabhnanda> ertesx: okay, what about associations? User's posts? or User's orders/
07:04:01 <ertesx> saurabhnanda: then you have, say, a PostgreSQL implementation:  withPgModel :: ByteString -> (Model IO -> IO r) -> IO r
07:04:34 <ertesx> saurabhnanda: the types are regular haskell types…  you can attach them to specific representations by using libraries like aeson (JSON) and digestive-functors (HTML forms)
07:04:49 <maybefbi> ski, it is ok, i solved it. i realized i could pass arguments to servant Context
07:05:03 <ski> ok
07:06:12 * ski . o O ( `Codensity IO (Model IO)' )
07:06:20 <ertesx> saurabhnanda: bottom line:  i don't use ORM, but domain-specific abstractions…  don't model "databases", model your application!
07:06:37 <maybefbi> ski, i understand some of those words
07:07:24 <maybefbi> which haskell like language can be easily transpiled in our heads to javascript?
07:07:45 * hackagebot knead 0.2 - Repa array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.2 (HenningThielemann)
07:07:47 * hackagebot knead-arithmetic 0.0 - Linear algebra and interpolation using LLVM JIT  https://hackage.haskell.org/package/knead-arithmetic-0.0 (HenningThielemann)
07:08:34 <saurabhnanda> ertesx: i need to learn HOW
07:09:25 <saurabhnanda> ertesx: lot of people discourage ORMs but that's like thrown the baby out with the bathwater. ORMs make certain things easy/fast. What is the alternative approach?
07:09:29 <ertesx> saurabhnanda: say you don't abstract over the database at all…  you certainly write functions that talk to the database
07:09:35 <codedmart> What does this all mean? https://gist.github.com/codedmart/885a8ff33bcd9d573939166196476a7d
07:09:42 <codedmart> Do I have something configured wrong?
07:10:15 <saurabhnanda> ertesx: possible, to take some time out and write a longish answer on Reddit itself? Or a blog post?
07:10:40 <ertesx> saurabhnanda: i have neither a reddit account nor a blog right now =)
07:10:57 <saurabhnanda> ertesx: Gist will also do
07:11:31 <saurabhnanda> ertesx: btw, Persistent hardly abstracts the database. It's really not an ORM, but a DSL to map DB rows to haskell records. That's it. It doesn't do much.
07:11:54 <saurabhnanda> ertesx: from a modelling perspective, it's referentially transparent to a function that executes an SQL query and returns a tuple.
07:12:01 <ertesx> saurabhnanda: if you're patient, i can write a mini-example after lunch
07:12:20 <saurabhnanda> ertesx: yes, please. that would be really great.
07:12:54 <bennofs> saurabhnanda: btw, http://stackoverflow.com/a/38684717/2494803
07:17:27 <mpickering> Is there a way to check if GHC unboxes fields in a small product type? 
07:17:46 * hackagebot llvm-ffi 3.1.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.1.0 (HenningThielemann)
07:17:58 <mpickering> I know it is meant to do it automatically for "small"  strict products but I want to be sure
07:18:42 <bennofs> not sure, but don't the types show up as Int# etc in core if they get unboxed?
07:19:14 <bennofs> if it is not Int#, then you will see the fields of the thing that is unboxed inline iirc
07:19:27 <ertesx> … and now they're gone
07:22:46 * hackagebot llvm-tf 3.0.3.1.3 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.3 (HenningThielemann)
07:25:09 <Gurkenglas> ertesx: From http://ircbrowse.net/browse/haskell?q=saurabhnanda it looks like that guy will be visiting again, you could @tell him a paste link
07:25:33 <int-e> is there a sane way to link to a type in haddock, when there is a constructor of the same name?
07:26:36 <Gurkenglas> int-e, https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-State-Lazy.html#t:StateT https://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-State-Lazy.html#v:StateT
07:27:59 <int-e> Gurkenglas: I want a replacement for `Foo.Bar`, and "Foo#t:Bar" gets the module name Foo as the link text instead of the type name.
07:28:00 <ertesx> Gurkenglas: not that i take it personally, but i'm not a background thread (for free) =)
07:30:38 <Gurkenglas> @karma- Gurkenglas
07:30:38 <lambdabot> You can't change your own karma, silly.
07:30:47 <Gurkenglas> Ah, looks like I'm having a bad day.
07:35:17 <int-e> oh,  https://github.com/haskell/haddock/issues/375 is relevant... I was referring to it by a name that wasn't in scope. When I don't do that, haddock prefers the type.
07:42:56 <x1f577> how can i make a conduit out of two handles, representing stin and stout of a process? 
07:43:11 <dinnu93> I'm not getting type-level programming ?
07:43:24 <dinnu93> Can somebody point me to some good resources
07:43:56 <dinnu93> I tried a couple of blogs but they left me more confused than I already was
07:45:15 <saurabhnanda> bennofs: thanks a lot. Aren't these three completely different approaches?
07:45:21 <saurabhnanda> bennofs: the three answers?
07:45:33 <freeside> dinnu93: https://www.youtube.com/watch?v=SWTWkYbcWU0&feature=youtu.be&t=32m55s
07:46:27 <dinnu93> freeside: I'll check it out right away thank you 
07:49:35 <freeside> also try a few minutes after  https://youtu.be/SWTWkYbcWU0?t=20m38s
07:49:49 <bennofs> saurabhnanda: ErikR's approach is basically the same as mine, but it requires that you manually pass around the SqlBackend and use run $ runSqlPersistM query backend to do a query
07:50:19 <bennofs> saurabhnanda: while my approach runs in Property (SqlT IO) a, so you can directly do run query
07:50:54 <saurabhnanda> bennofs: hmm.. actually I don't want to manually pass around the connection pool. Defeats the purpose of composability
07:51:04 <saurabhnanda> bennofs: feels like a code-smell
07:51:23 <bennofs> saurabhnanda: my approach only requires you to pass the connection at the place where you run the property
07:51:31 <bennofs> saurabhnanda: the property itself need not be aware of the connection
07:51:41 <saurabhnanda> bennofs: correct. That's what I'd want.
07:52:20 <saurabhnanda> bennofs: wow! I didn't even know of ioProperty. *THAT* was what I was missing.
07:52:26 <saurabhnanda> bennofs: how did you get to it? have you used QuickCheck before?
07:53:06 <bennofs> saurabhnanda: basically, the difference between mine and ErikR's code is that ErikR uses PropertyM IO and manually runs the SqlT at each "run", while I use PropertyM (SqlT IO) such that you can run actions of type 'SqlT IO' and then translate SqlT IO -> IO using monadic
07:53:44 <saurabhnanda> bennofs: I would prefer your solution, but are you sure it won't have any gotchas due to laziness?
07:53:50 <bennofs> saurabhnanda: I went to http://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck-Monadic.html#v:monadicIO, and clicked on "source"
07:54:00 <bennofs> saurabhnanda: what does laziness have to do with any of this? :o
07:55:09 <saurabhnanda> bennofs: don't know. just my hunch... I hope all IO actions will actually get executed.
07:55:42 <saurabhnanda> bennofs: ErikR's approach is not that great. Too much of type boilerplate.
07:56:02 <saurabhnanda> bennofs: what do you think of Gurkenglas?
07:56:14 <bennofs> saurabhnanda: btw, I just noticed that runSql = flip runSqlPersistM connection in my code
07:58:15 <fleeceface> I'm looking for some help with a stack/emacs issue. I didn't get any response last night in #haskell-stack or #haskell-emacs so I'm trying here although it's not a Haskell language question as such.
07:58:25 <fleeceface> I have a project for which `stack build` and `stack test` work fine but `haskell-stack-ghc` reports an error via flycheck.
07:58:36 <saurabhnanda> bennofs: why didn't you use runSqlPool
07:58:43 <fleeceface> I have created a new project from a template using `stack new scotto scotty-hspec-wai`. The project is using lts-6.9. I'm using spacemacs with the default haskell-mode setup.
07:58:53 <fleeceface> The error is "No instance of aeson-0.11.2.0...ToJson Value" full message : http://pastebin.com/GfqDxe9Z code : http://pastebin.com/Naxhd9s2
07:59:08 <saurabhnanda> bennofs: withSqlPool & runSqlPool
07:59:20 <saurabhnanda> bennofs: any particular reason?
08:00:44 <bennofs> saurabhnanda: a pool is only useful if you need multiple connections, no? this just always uses the same connection
08:00:57 <bennofs> saurabhnanda: tbh, I am not very familar with persistent itself
08:01:38 <saurabhnanda> bennofs: hmm, I'm not sure if you need so many run* in runSql
08:01:50 <bennofs> "saurabhnanda: btw, I just noticed that runSql = flip runSqlPersistM connection in my code"
08:01:52 <saurabhnanda> bennofs: I think all of that can be replaced with (runSqlPool pool dbAction)
08:02:01 <bennofs> that is just one run then
08:02:43 <bennofs> yeah you could probably also use a pool, but that should be easy to adapt
08:02:51 <bennofs> (just use a pool instead of connection etc)
08:03:07 <saurabhnanda> bennofs: btw, isn't the property supposed to simply return True/False
08:03:16 <saurabhnanda> bennofs: whey are you using assert?
08:03:24 <bennofs> saurabhnanda: not with monadic properties, there you use assert
08:03:25 <geekosaur> fleeceface, usually when it has a package-qualified instance name like that, it means you have a version conflict. in this casem it probably means haskell-stack-ghc is running from the wrong place so it's not seeing/using your stack.yaml
08:04:23 <saurabhnanda> bennofs: how many times does QuickCheck run the test, in that case?
08:04:34 <bennofs> saurabhnanda: i think 100 is the default
08:04:55 <bennofs> saurabhnanda: right now the test fails on the second iteration because I have no implemented any DB cleaning code
08:06:29 <saurabhnanda> okay
08:06:32 <saurabhnanda> let me implement this approach in my code
08:07:06 <fleeceface> geekosaur: It was my instinct when I saw that ToJson was version qualified but Value was not, but I'm not sure where to start looking to find why it is picking up the wrong version. The fact that it is using haskell-stack-ghc suggests haskell-mode has detected this is a stack project
08:08:02 <fleeceface> geekosaur: thanks for confirming that though, I will poke-around again and have another think about it
08:09:23 <saurabhnanda> bennofs: what's with the MonadLogger requirement?
08:09:32 <bennofs> saurabhnanda: where's that?
08:10:11 <saurabhnanda> bennofs: here's what I'm trying http://lpaste.net/173145
08:10:47 <saurabhnanda> bennofs: check again -- http://lpaste.net/edit/173145 -- added the error
08:12:15 <c_wraith> bah.  I was asked a question mid-day on friday, but I haven't been able to answer it yet, since the asker has been gone since.
08:12:46 <bennofs> saurabhnanda: use runSqlPersistMPool instead of runSqlPool
08:13:56 <bennofs> saurabhnanda: also, you will need to change your NwApp type to NwApp = SqlPersistT (NoLoggingT (ResourceT IO))
08:14:21 <saurabhnanda> actual type NwApp = SqlPersistT IO
08:14:36 <fleeceface> geekosaur: ah right `Aeson` is imported directly, whereas `json` and the corresponding `ToJson` comes via Scotty. I thought Haskell didn't allow different versions of the same module to appear in a project, and if not stack/lts should prevent it. Hmmm, ok
08:15:01 <saurabhnanda> bennofs: can we try a solution that *doesn't* involve a complicated monad transformer stack? I'm having a tough time as it is :)
08:15:01 <bennofs> saurabhnanda: yeah you need to change that as I said
08:15:18 <bennofs> saurabhnanda: it's more complicated if you don't change NwApp
08:15:46 <bennofs> saurabhnanda: as far as I can see, persistent *requires* that you have a ResourceT and a logging monad in your stack
08:15:55 <bennofs> saurabhnanda: SqlPersistT does not provide resource management nor logging
08:15:58 <geekosaur> there are arguments over that; sometimes it's a legitimate thing to do (and sometimes a necessary thing given that things like ghc-api and TH use various packages internally that you might have in different versions; iff they are not exposed, this works)
08:16:00 <saurabhnanda> bennofs: I have a *lot* of code in my app that is working with NwApp -- I'm pretty sure other stuff will refuse to compile if I do that.
08:16:15 <bennofs> saurabhnanda: I don't think it should refuse to compile if you do that
08:16:40 <bennofs> saurabhnanda: all persistent functions will continue to work fine, and you had to use liftIO to execute IO functions even before introducing two additional layers because you already had one layer
08:17:06 <saurabhnanda> okay, let me try
08:17:09 <bennofs> saurabhnanda: the only change you might need to make is to replace "lift" with "liftIO" if you used "lift" to execute io actions before
08:17:12 <saurabhnanda> but that means one more Stackoverflow post
08:17:35 <saurabhnanda> what the hell are all those monads for
08:18:00 <bennofs> saurabhnanda: NoLoggingT is for satisfying the "logging" requirement
08:18:14 <bennofs> saurabhnanda: ResourceT is for resource-cleanup support
08:19:49 <bennofs> saurabhnanda: do you even have any idea how to implement the cleanup code yet? otherwise earlier tests will affect the results of tests run after them, as all tests share the same db :(
08:19:59 <saurabhnanda> where are these defined? ResourceT & NoLoggingT?
08:20:16 <bennofs> saurabhnanda: ResourceT: package resourcet, module Control.Monad.Trans.Resource
08:20:28 <saurabhnanda> bennofs: worst comes worst, raw SQL for the cleanup code
08:20:36 <saurabhnanda> bennofs: list all table and truncate them
08:20:45 <bennofs> saurabhnanda: NoLoggingT: package monad-logger, module Control.Monad.Logger
08:21:34 <bennofs> saurabhnanda: do you think that re-using a connection will really speed things up? Shouldn't setting up a new database in memory be quite fast, and not much slower than executing a query each time to clean the db?
08:22:18 <bennofs> hmm, you do avoid the overhead of creating the tables again each time though...
08:22:22 <saurabhnanda> bennofs: final target is not sqlite
08:22:27 <saurabhnanda> bennofs: final target is postgres
08:22:37 <saurabhnanda> bennofs: this is POC code to understand how things are done in Haskell
08:23:13 <saurabhnanda> bennofs: Rails has transactional fixtures. Each test runs in a master txn, which is rolled back at the end of the test
08:24:48 <bennofs> esaurabhnanda: hmm, can't you your tests against sqlite and then switch to postgres for production? at least for QuickCheck tests. If you run your tests against a postgresql database, what happens if someone concurrently executes your test suite multiple times at the same time? Can you ensure that that scenario does not happen?
08:25:04 <saurabhnanda> bennofs: ah, found my old code which sidestepped this transformer stack: https://github.com/vacationlabs/nightwatch/blob/haskell/Main.hs
08:25:38 <saurabhnanda> bennofs: final try is to get to transactional fixtures -- they handle all these problems
08:25:57 <saurabhnanda> bennofs: also, if production is in PG, I'd want to test on PG as well. The actual project has a lot of PG specific stuff.
08:26:02 <bennofs> ah ok
08:26:10 <bennofs> i had thought this could be a problem
08:26:27 <saurabhnanda> bennofs: seems to be typechecking
08:26:32 <saurabhnanda> bennofs: holding my breath!
08:26:38 <saurabhnanda> loading into repl
08:27:19 <saurabhnanda> btw, I know the next problem I'm going to hit
08:27:23 <saurabhnanda> instance (Monad a) => MonadThrow (PropertyM a)
08:27:23 <saurabhnanda> instance (MonadThrow a) => MonadCatch (PropertyM a)
08:27:57 <bennofs> saurabhnanda: why do you need those?
08:28:17 <bennofs> MonadCatch in particular feels like it might eveb be impossible to implement
08:28:30 <saurabhnanda> bennofs: for ensuring correct behaviour of smart constructors
08:28:41 <saurabhnanda> bennofs: when passed impossible values, they need to throw a runtime error
08:28:48 <bennofs> saurabhnanda: why would you run smart constructurs inside propertyM?
08:29:03 <bennofs> saurabhnanda: just put all your non-property related code in a run $ ... block
08:29:08 <saurabhnanda> bennofs: okay, I don't really know what smart constructors mean
08:29:14 <saurabhnanda> bennofs: but something like createDownload
08:29:27 <saurabhnanda> bennofs: anything that's interacting with DB, can throw a validation error
08:29:42 <saurabhnanda> bennofs: for example, a uniqueness constraint
08:29:57 <saurabhnanda> bennofs: have I gotten the core concept of quickcheck wrong?
08:30:18 <bennofs> saurabhnanda: yes, but those things won't run in PropertyM NwApp 
08:30:29 <saurabhnanda> bennofs: why?
08:30:34 <bennofs> saurabhnanda: you'd use run :: NwApp a -> PropertyM NwApp a to run these
08:30:56 <bennofs> saurabhnanda: so they actually run in NwApp a
08:31:08 <saurabhnanda> bennofs: why?
08:31:18 <bennofs> saurabhnanda: because if you use run, the action you pass runs in NwApp?
08:31:27 <saurabhnanda> bennofs: that would mean that I wouldn't be able to create the Property in the first place
08:31:50 <saurabhnanda> bennofs: how do I write a test that ensures that a uniqeness constraint on the DB works as expected?
08:32:00 <saurabhnanda> bennofs: if the constraint fails, the underlying function throws an error
08:32:15 <bennofs> saurabhnanda: no, you'd do it like:     do result <- run someActionInNwAppThatComputesSomeValue; assert someStuffInvolvingResult
08:32:15 <saurabhnanda> bennofs: and a runtime error *is* the expected behaviour, FWIW
08:32:52 <bennofs> saurabhnanda: you write your test as an action 'test' of type 'NwApp Bool', and then use 'ok <- run test; assert ok'
08:33:42 <saurabhnanda> bennofs: and do the catching inside 'test'?
08:33:42 <bennofs> saurabhnanda: you can then catch and throw exceptions in your test action
08:35:47 <saurabhnanda> bennofs: okay
08:35:51 <saurabhnanda> bennofs: let me try to run what I have
08:36:05 <saurabhnanda> let's see if the saying hods true -- if it compiles, it runs :)
08:36:44 <saurabhnanda> Exception: /Users/saurabhnanda/projects/nightwatch/test/DBCheck.hs:25:10-51: No instance nor default method for class operation catch
08:36:54 <saurabhnanda> hmm...
08:37:01 <bennofs> saurabhnanda: do you have instance MonadCatch somewhere explicitly defined?
08:37:45 <saurabhnanda> warning: no explicit implementation for Control.Monad.Catch.catch
08:38:14 <bennofs> saurabhnanda: is this for your 'instance Catch (PropertyM m)' ?
08:38:18 <saurabhnanda> bennofs: let me try the approach you were suggesting
08:38:28 <saurabhnanda> bennofs: yep
08:38:30 <saurabhnanda> bennofs: just a blank instance
08:38:35 <saurabhnanda> bennofs: no function inside
08:38:42 <bennofs> saurabhnanda: well, that obviously wont work, as you saw :)
08:38:44 <saurabhnanda> bennofs: wrote it to get the code to compile
08:39:07 <saurabhnanda> bennofs: let me try to catch in NwApp itself
08:43:25 <saurabhnanda> bennofs: problem again
08:44:19 <x1f577> hey all, i need some help with conduits. given a stream of X's, how can i produce a stream of unigrams, bigrams, and trigrams of those X's? for example [1, 2, 3, 4] -> [[1], [1, 2], [1, 2, 3], [2], [2, 3], [2, 3, 4], [3], [3, 4], [4]]
08:44:40 <saurabhnanda> bennofs: http://lpaste.net/173148
08:45:10 <bennofs> saurabhnanda: remove run in line 23
08:45:14 <bennofs> saurabhnanda: line 12*
08:45:39 <saurabhnanda> bennofs: ah okay, got it
08:45:46 <saurabhnanda> bennofs: because of that it was inferring a different type
08:46:18 <saurabhnanda> bennofs: well, tests seem to be running
08:46:25 <saurabhnanda> bennofs: assertion failed after 2 test
08:46:40 <bennofs> saurabhnanda: yeah that's because you don't have a cleanup code right now probably
08:47:06 <saurabhnanda> bennofs: I don't think my test depends on that
08:47:20 <saurabhnanda> bennofs: btw, between the runs, it seems to be recreateding the in-memory db on its own
08:47:32 <bennofs> saurabhnanda: lpaste full code pls
08:47:36 <saurabhnanda> bennofs: question is, how do I debug this now
08:48:49 <bennofs> saurabhnanda: you could add some 'print' or 'putStrLn' to show the values of the things your are comparing / reading out of the DB and find out why they do not match 
08:49:22 <bennofs> (you'll need to use liftIO $ print / liftIO $ putStrLn actually because of the transformer stack)
08:50:18 <saurabhnanda> bennofs: http://lpaste.net/173151
08:51:52 <saurabhnanda> bennofs: oay
08:51:55 <saurabhnanda> bennofs: it seems the test is doing the right thing
08:52:01 <bennofs> saurabhnanda: "Like createSqlitePool, this should not be used with :memory:."
08:52:06 <saurabhnanda> bennofs: my "smart constructor" isnt' actually that smark
08:52:15 <bennofs> saurabhnanda: says the documentation for "withSqlitePool"
08:52:23 <saurabhnanda> bennofs: it's not throwing an error when it should be
08:52:55 <bennofs> saurabhnanda: I think you should use my code instead of the pool code as long as you use ':memory:', since ':memory:' seems to not support connection pooling
08:53:07 <bennofs> "Note that this should not be used with the :memory: connection string, as the pool will regularly remove connections, destroying your database. Instead, use withSqliteConn."
08:54:59 <saurabhnanda> bennofs: hmm, I've use the pool count as '1'
08:55:21 <bennofs> saurabhnanda: the documentation says that pools dont work with :memory:
08:57:05 <saurabhnanda> okay
08:57:10 <saurabhnanda> let me get the code to compile again
08:58:23 <saurabhnanda> bennofs: trying again
09:00:01 <Zemyla> Is there an infinite stream type with O(1) cons and O(lg n) random access?
09:00:27 <saurabhnanda> bennofs: same problem, seems to be an actual problem with the code that the test is catching
09:00:50 <alercah> Zemyla: skip lists?
09:02:35 <ski> > log (1/0)
09:02:37 <lambdabot>  Infinity
09:02:53 <saurabhnanda> bennofs: the test is workign fine now. my code is buggy
09:03:07 <saurabhnanda> bennofs: would you like to also include the catch-related discussion we had in your answer
09:03:12 <Zemyla> > log (-1)
09:03:13 <saurabhnanda> bennofs: it might help someone else
09:03:14 <lambdabot>  NaN
09:03:20 <saurabhnanda> bennofs: I'll mark it as correct tomorrow
09:04:39 <mniip> anyone have a 7.8/7.10 at hand?
09:05:07 <bennofs> mniip: what do you need?
09:05:38 <mniip> a tiny ghci bug check
09:06:56 <bennofs> mniip: i have ghc7.8/7.10 in a moment, what should I check?
09:07:28 <mniip> :print print
09:07:31 <mniip> _t1 "foo"
09:08:18 <mniip> I have 7.6 on my server and 8.0 and HEAD on my laptop, and switching between major versions is a pain
09:08:37 <bennofs> mniip: panic on 7.10.3
09:09:07 <mniip> no skolem info?
09:09:33 <Gurkenglas> x1f577: In that order?
09:09:42 <bennofs> mniip: http://lpaste.net/173160
09:10:01 <mniip> bennofs, what's :t _t1
09:10:03 <mniip> say
09:10:07 <bennofs> mniip: same on 7.8.4
09:10:16 <mniip> hmm weird
09:10:19 <bennofs> mniip: same panic
09:10:25 <mniip> 8.0.1 produces a different panic
09:10:31 <mniip> and :t doesn't make it panic, just 
09:10:35 <bennofs> tcTyVarDetails a{tv at4} [tv]
09:10:36 <hpc> i get the same, 7.10.2
09:10:39 <mniip>     No instance for (Show a) arising from a use of ‘it’
09:11:26 <mniip> I see, thanks
09:11:27 <x1f577> Gurkenglas: preferably
09:11:44 <x1f577> Gurkenglas: but not a big deal as long as its lazy
09:20:15 * mniip writes a ticket
09:24:29 <Gurkenglas> x1f577: *learns conduits from haddock and github readme* http://lpaste.net/173165 looks like a start, but Im not sure how to output the last singleton once the upstream terminates in lines 7 or 12
09:26:01 <Gurkenglas> Note that as [a] -> [a] this'd just be concatMap (take 3) . tails
09:26:27 <Gurkenglas> :t take 3 <=< tails
09:26:29 <lambdabot> [c] -> [c]
09:27:12 <Gurkenglas> No wait.
09:28:38 <Gurkenglas> > sequenceA [take 1, take 2, take 3] <=< tails $ [1,2,3,4] -- working on the end part
09:28:41 <lambdabot>  [[1],[1,2],[1,2,3],[2],[2,3],[2,3,4],[3],[3,4],[3,4],[4],[4],[4],[],[],[]]
09:30:40 <Gurkenglas> @let import Safe.Exact
09:30:41 <lambdabot>  Defined.
09:30:47 <Gurkenglas> > catMaybes . traverse takeExactMay [1..3] =<< tails [1..4]
09:30:48 <lambdabot>  [[1],[1,2],[1,2,3],[2],[2,3],[2,3,4],[3],[3,4],[4]]
09:32:50 * hackagebot hakyll-convert 0.2.0.0 - Convert from other blog engines to Hakyll.  https://hackage.haskell.org/package/hakyll-convert-0.2.0.0 (AlexanderBatischev)
09:32:53 <mniip> bennofs, and if you :print id
09:32:58 <mniip> and then query its type
09:33:54 <bennofs> mniip: that works without panic (:print id  and then :t _t2) on GHC 7.8.4
09:34:13 <mniip> and if you -fprint-explicit-foralls
09:34:20 <mniip> is the forall missing on _t2
09:34:49 <bennofs> mniip: with -fprint-explict-foralls:
09:34:51 <bennofs> Prelude> :print id
09:34:53 <bennofs> id = (_t1::a -> a)
09:36:27 <mniip> and :t _t1
09:36:31 <mniip> no forall?
09:36:37 <bennofs> mniip: _t1 :: a -> a
09:36:51 <glguy> `/users
09:37:08 * mniip scribbles
09:38:28 <Gurkenglas> This'd be much easier if conduit had ([a] -> [b]) -> Conduit a m b
09:39:22 <Gurkenglas> (which unsafely calls awaits whenever the given function evaluates the [a] one step further)
09:39:28 <Gurkenglas> *await
09:41:27 <mniip> bennofs, https://ghc.haskell.org/trac/ghc/ticket/12449
09:43:43 <lpaste> Gurkenglas revised “No title”: “x1f577, added one that doesn't screw up at the end, but bumps yields sideways by up to a constant.” at http://lpaste.net/173165
09:45:28 <Gurkenglas> An Alternative instance for ConduitM i o m would also help.
09:49:08 <Gurkenglas> (Actually the ([a] -> [b]) -> Conduit a m b wouldnt make it easier because the end of [a] still terminates the Conduit.)
09:49:26 <Gurkenglas> Would do much shortening tho x)
09:52:00 <mvr_> is there a canonical constraint with a single instance?
09:52:19 <bennofs> mvr_: single instance for what? everything?
09:52:50 * hackagebot haskell-src-exts-simple 1.18.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.18.0.0 (BertramFelgenhauer)
09:53:12 <mvr_> maybe I mean, canonical typeclass with a single instance
09:53:19 <mniip> like
09:53:23 <mniip> class Foo a | -> a ?
09:53:52 <int-e> mpickering: see hackagebot :)
09:54:15 <Gurkenglas> Is unsafeInterleaveIO (m >> return undefined) guranteed to never run m?
09:54:25 <mvr_> wow, I'm surprised that's even valid
09:54:29 <runeks> How do I go about encoding optional properties in type classes? If I, for example, have a IsHTTPRequest type class, it maybe have an optional "body" and "parser" property if the request is a POST or PUT request. So I could create a HasReqBody class, but since it's optional, wouldn't I need two different functions to execute the request? One for
09:54:29 <runeks> IsHTTPRequests that are not instances of HasReqBody and one for IsHTTPRequests that are also instances of HasReqBody?
09:54:41 <bennofs> mniip: well, there is NullaryTypeClasses GHC extension
09:54:57 <mpickering> int-e: Did you read my message? I don't think people will be able to use it as a drop-in replacement as-is if that's what you intend
09:55:06 <int-e> mpickering: I do not.
09:55:14 <bennofs> mvr_: see https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html
09:55:36 <merijn> mvr_: What do you need it for?
09:55:53 <mpickering> bidirectional pattern synonyms were actually released in GHC 7.8 btw
09:56:04 <int-e> mpickering: https://github.com/int-e/haskell-src-exts-simple/blob/master/COMPATIBILITY.md
09:56:12 <mpickering> I just read that
09:56:31 <int-e> hmm, I had trouble building with ghc-7.8, let me check.
09:56:50 <Gurkenglas> runeks, couldnt you just do "class IsHTTPRequest where body :: Maybe Body; parser :: Maybe Parser", and then your functions have different behavior depending on justice?
09:59:08 <int-e> mpickering: I thought about full compatibility, but I really didn't want to emulate the now missing SrcLocs.
09:59:24 <mpickering> good point, they always were a bit weird 
09:59:47 <int-e> mpickering: as you also wrote, there's the issue of bundling types and constructors, but it's a bit early to require ghc 8.0
10:00:37 * int-e might add a flag to use that feature though, for adventerous people.
10:01:24 <mniip> int-e, so, what was the issue with mueval and ghc 8.0 again?
10:02:06 <int-e> mniip: the maintainer left the community, probably.
10:02:43 <mniip> I see
10:03:11 <x1f577> Gurkenglas: whoa, thanks for all that effor my friend!
10:03:17 <int-e> mpickering: the thing that fails with ghc 7.8 is the   pattern Foo <- Foo _ where  Foo = Foo someDefaultValue   variant of pattern synonyms.
10:03:24 <x1f577> Gurkenglas: ive been distracted working on another part of the project
10:03:27 <int-e> mpickering: which I used for literals
10:03:37 <mpickering> Right, that was only implemented in ghc 7.10
10:03:59 <int-e> mpickering: what are they called properly, if not "bidirectional"?
10:04:10 <mpickering> explicitly bidirectional
10:04:22 <mpickering> and with an  = they are called implicitly bidirectional
10:05:19 <runeks> Gurkenglas: Right, I could, but then it can fail it a user specifies a Just body but a Nothing for the parser. They depend on each other, that's what I'd like to encode somehow.
10:05:23 <mvr_> merijn: it's a bit hard to explain, but the `class Foo a | -> a` seems to do what I want
10:05:31 <runeks> it=if
10:06:02 <mniip> mvr_, seems equivalent to a nullary typeclass + type synonym
10:06:36 <runeks> I'd like to make the user interface unambiguous, if possible
10:07:29 <mpickering> int-e: the paper is here if you are interested in all the details - http://mpickering.github.io//pattern-synonyms-final.pdf
10:08:18 <mvr_> mniip: I'm hoping for an actual type that is an instance of Foo, which a nullary typeclass doesn't seem to give me
10:08:51 <mniip> hmm
10:08:54 <mniip> inference doesn't work
10:10:13 <mniip> class Cls where type family Fam; foo :: Fam
10:10:13 <mniip> instance Cls where type Fam = Int; foo = 3
10:16:33 <Gurkenglas> runeks, Maybe (Body, Parser)
10:18:11 <Gurkenglas> (If your functions weren't supposed to do default things when no body and parser is provided, I'd suggest two classes instead, one without, one with and a superclass of the first.
10:18:37 <dariush> hi all
10:23:03 <Gurkenglas> Is unsafeInterleaveIO (launchRockets >> return undefined) safe?
10:25:19 <bennofs> Gurkenglas: safe in what way?
10:26:24 <Gurkenglas> Could it ever launch rockets?
10:26:34 <Gurkenglas> *Would it never
10:27:27 <merijn> Gurkenglas: unsafeInterleaveIO is slightly safer than unsafePerformIO
10:27:45 <Gurkenglas> Right, but certain applications of it are safe, and I'm asking if this is one of them
10:27:48 <merijn> Gurkenglas: As in, it doesn't remove the IO-ness from something, but it does change (operationally) when that IO actually executes
10:27:51 * hackagebot http-reverse-proxy 0.4.3.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  https://hackage.haskell.org/package/http-reverse-proxy-0.4.3.1 (MichaelSnoyman)
10:28:08 <ski> Gurkenglas : when you force the monadic result
10:28:09 <merijn> Gurkenglas: That would launch rockets, yes, afaik
10:32:51 * hackagebot language-webidl 0.1.4.0 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.4.0 (izgzhen)
10:33:47 <eklavya> I have a ByteString that I need to convert to a record type that a user will provide, is there anyway to avoid that boilerplate (that the user would have to write) without using template haskell?
10:35:10 <merijn> eklavya: Which boilerplate?
10:35:11 <phanimahesh> usecase? that doesn't sound like a good idea
10:35:23 <eklavya> actually there is a Map String -> ByteString
10:35:30 <eklavya> where string is the column name
10:35:35 <eklavya> and ByteString it's value
10:35:51 <eklavya> I want to return results as Records
10:36:12 <eklavya> and not have the user write boilerplate for that conversion
10:36:14 <phanimahesh> how do you know how to create the record from bs?
10:36:21 <eklavya> I don
10:36:30 <eklavya> that will depend on the user program
10:37:05 <phanimahesh> then ask the user to provide a function to do it, or implement a typeclass instance
10:37:12 <Gurkenglas> Why would "take 5 <$> many (unsafeInterleaveIO getChar)" hang
10:37:17 <eklavya> yeah, I want to automate that
10:37:26 <implementation> or rely on the Serializable class from cereal
10:37:26 <eklavya> like in case of aeson
10:37:47 <eklavya> I do not that write a ToJSON FromJSON instance myself
10:37:51 * hackagebot attoparsec-csv 0.1.1.0 - A parser for CSV files that uses Attoparsec  https://hackage.haskell.org/package/attoparsec-csv-0.1.1.0 (RobinBateBoerop)
10:37:54 <merijn> Gurkenglas: Buffering on stdin
10:38:37 <phanimahesh> ekalavya: it is necessary, because the same record can be serialised into bs in many ways
10:39:10 <eklavya> well, the serialization is not arbitrary
10:39:23 <eklavya> I know how to interpret all basic types it has
10:39:35 <eklavya> it's just that I don't know what the records will have
10:40:06 <eklavya> and making the user write that much boilerplate should be avoided I think
10:41:12 <eklavya> > data Test = Test { a :: Int, b :: Int, s :: String }
10:41:13 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:41:31 <eklavya> >data Test = Test { a :: Int, b :: Int, s :: String }
10:42:00 <implementation> @let data Test = Test { a :: Int, b :: Int, s :: String }
10:42:03 <lambdabot>  Defined.
10:42:13 <eklavya> > :t Test
10:42:16 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:42:23 <eklavya> @:t Test
10:42:23 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
10:42:32 <implementation> :t Test
10:42:33 <lambdabot> Int -> Int -> String -> Test
10:42:34 <implementation> ;)
10:42:57 <eklavya> phanimahesh: the order of args is defined, right?
10:43:05 <eklavya> It can only be Int -> Int -> String
10:43:39 <eklavya> so if I could somehow get this info I could create their records from the bytestring map
10:43:54 <eklavya> and even the ordering is not necessary 
10:44:01 <eklavya> since I have name -> value map
10:44:23 <eklavya> if I could get the field names, I could make the record, no matter the order
10:45:01 <eklavya> I think json serialization is the closest example I can give of what I am trying to say
10:45:36 <eklavya> but everybody seems to suggest that I should exhaust all available abstractions before heading towards metaprogramming
10:45:57 <eklavya> so I need to know if I can make a record from that Map name -> value
10:46:16 <EvanR> heard of extensible records?
10:46:28 <eklavya> nope, let me look them up
10:47:52 * hackagebot llvm-ffi 3.2.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.2.0 (HenningThielemann)
10:47:54 * hackagebot llvm-tf 3.0.3.1.4 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.4 (HenningThielemann)
10:47:54 <EvanR> a package for it is vinyl
10:48:03 <EvanR> dunno if itd be appropriate
10:50:01 <eklavya> there isn't much info in hackage :(
10:50:19 <eklavya> let me check if there is any other resource on vinyl
10:50:28 <eklavya> although it looks very complex :(
10:53:16 <EvanR> well thats because haskell
10:53:43 <EvanR> haskell doesnt have extensible records so advanced type system stuff can fake it
10:54:13 <EvanR> eklavya: this is a big topic and i only found information on it scattered about
10:54:46 <Zekka> fwiw when it comes time to introduce anything like Vinyl I immediately wonder if what you're getting from it could possibly be worth the extra complexity
10:55:00 <eklavya> EvanR: while searching I came across HList and it mentioned the words "database row" !!
10:55:02 <EvanR> the idea is that theres a family of record types parameterized in different ways by the records schema
10:55:10 <Zekka> imho if your initial reaction is "that looks horribly complex" you should not use it, because that's how you and your friends will feel when exposed to it later
10:55:25 <cocreature> Zekka++
10:55:26 <eklavya> Zekka: yup
10:55:34 <eklavya> let me look up HLIsts
10:55:39 <EvanR> Zekka: well, in this case maybe, but in other cases it might just be a lack of experience
10:55:48 <eklavya> if anybody knows a good link for it, please share :)
10:55:56 <eklavya> for HList
10:55:56 <Zekka> I think it really just comes down to whether the extra complexity is buying your something good
10:56:04 <ertesx> there is also dependent-map, just to throw one more TH-less abstraction in there
10:56:05 <Zekka> buying you*
10:56:07 <ertesx> @package dependent-map
10:56:07 <lambdabot> http://hackage.haskell.org/package/dependent-map
10:56:08 <EvanR> HList is the same idea, the type of elements is represented in the type of the list
10:56:22 <EvanR> which is "horribly complex" too
10:56:39 <eklavya> if it hides it well, I will have no problem with that :P
10:56:45 <EvanR> you cant hide it
10:56:49 <EvanR> thats the point
10:56:56 <Zekka> promises are strictly speaking a pretty complicated abstraction, but they let you write asynchronous code without a whole lot of gotchas
10:56:58 <cocreature> one difference is that in vinyl all elements have the same functor type only the argument changes
10:57:03 <Zekka> so are promises worth learning? Probably yes
10:57:04 <eklavya> plus I have seen usages of HList in shapeless, so it looks promising
10:57:06 <cocreature> whereas hlists typically have completely different types
10:57:24 <EvanR> promises kind of dont have any semantics
10:57:31 <monochrom> Promises hold much promise in languages other than Haskell.
10:57:44 <EvanR> guarantees about list contents is a concrete concern
10:58:14 <Zekka> EvanR: "kind of dont have any semantics"? A given promises implementation makes pretty concrete guarantees about what happens in a variety of cases
10:58:19 <monochrom> In the Haskell community we have had much simpler solutions long before promises became a thing.
10:58:38 <Zekka> but it's not really my point -- I wanted to pick a non-contentious example of an abstraction that was complicated but people picked it up because it still had perks
10:59:01 <EvanR> thats the sort of abstract as "it does something" and "heres how to use it by example"
10:59:06 <EvanR> i.e. vagueness
10:59:14 <Zekka> monochrom: As a guy who used Haskell for a long time I'm a little skeptical, but I'm gonna have to claim ignorance because I'm not a concurrent programming expert
10:59:58 <Zekka> I'm willing to believe that if you frame the concurrency problem a totally different way, a different model falls out
11:00:49 <Zekka> EvanR: I'm not actually sure what you think is missing -- usually the stipulations I see are the same as you'd expect for any library -- "if you call X under Y conditions, you get Z -- if you call X under Q conditions, you get W" and so on
11:01:04 <monochrom> Put it this way. In languages like C, promises are the least worst solution.
11:01:09 <Zekka> and a strong effort gets made to cover starting conditions pretty exhaustively
11:01:16 <Zekka> But I think we've kinda diverged from my point
11:01:27 <Zekka> it's not that certain abstractions are overly complicated and certain abstractions just "need experience"
11:01:35 <Zekka> some abstractions buy you something for your problem, and other ones don't
11:01:57 <EvanR> guarantees about data structures arent nearly as simple as "heres a way to do IO, dont ask what happens if something goes wrong"
11:02:02 <Zekka> and I would guess that Vinyl, for the amount of complexity it introduces, usually doesn't buy you very much. (I'm saying this as a user of Elm, which also has a model of extensible records, and as someone who dabbled with Vinyl a few years ago)
11:02:21 <Zekka> EvanR: Most promise implementations explicitly stipulate what happens in failure cases too?
11:02:35 <Zekka> That's kinda the reason they're used over callbacks.
11:03:03 <ertesx> what are promises?
11:03:12 <ertesx> something like the async library?
11:03:23 <EvanR> theres async, and theres javascript
11:03:32 <Zekka> FYI I am not advocating javascript
11:03:33 <EvanR> among others
11:03:43 <maerwald> concurrency is something that requires a fair amount of intellectual capacity to do right and proper, so it's an annoying detail which should be hidden by proper frameworks
11:03:45 <Zekka> I don't know what the async library provides because I haven't used it
11:03:46 <maerwald> e.g. haxl
11:03:54 <Shockk> hello, I have a quick question about Typeable/TypeRep
11:04:13 <ertesx> Zekka: and i can't tell you, because i honestly don't know what promises are
11:04:46 <Zekka> ertesx: I didn't want to get onto this because I figured "promises are useful for concurrent programming for people in imperative languages" would be taken as given, because they're a super popular model based roughly on borrowing from the FP community
11:04:50 <phanimahesh> Shockk: make it quick, you have 30 seconds. :P
11:04:55 <Shockk> :(
11:05:01 <phanimahesh> 31?
11:05:14 <Zekka> I can try to give you a rigorous descrpition but they're also a little bit complicated -- they're basically a particular type that has an approximate monad interface that lets you do asynchronous programming
11:05:15 <Shockk> well, I have the following function defined, which calls another function that returns a Dynamic value
11:05:24 <Shockk> retrieve :: (StorePolar m, Typeable a) => String -> m (Maybe a)
11:05:25 <Shockk> retrieve k = fromDynamic <$> retrieveDyn (typeRep ???) k
11:05:25 <EvanR> thats why i reacted that way, because in js the "abstraction" is not incredibly impressive
11:05:46 <ertesx> Zekka: is there a reasonably short description of them somewhere?
11:05:50 <Zekka> the reason I don't want to just give you a rigorous description here is that (a) it's super off-topic, both to the channel and to my point about "is an abstraction actually buying you anything?" (b) it would take a lot of text
11:05:58 <maerwald> ertesx: instead of doing nested callback weirdness, you can use the actual "return values" with Promises (because that's what you get back: a promise)
11:06:05 <zlens> is there a way to get 'stack test' to run doctests ?
11:06:13 <EvanR> ertesx: force :: Promise a -> IO a
11:06:14 <Shockk> the other function, retrieveDyn, needs to do a lookup in some data structure based on a TypeRep, but I can't figure out how to actually get a TypeRep into it, from this function
11:06:19 <maerwald> the old way was that you register a callback in a callback in a callback...
11:06:24 <ertesx> maerwald: ah, thanks
11:06:24 <EvanR> Promise is a functor and a monad
11:06:33 <Zekka> ertesx: Let me check. Usually they vary a little bit between languages. But what I'm worried about happening is people are going to say "oh, Zekka is advocating Javascript!" (I am *incredibly not doing this*) or "but is that the *true* Promise implementation?"
11:06:34 <mniip> retrieve k = let result = fromDynamic <$> retrieveDyn (typeRep ((undefined :: m (Maybe a) -> a) result)) k in result
11:06:47 <ertesx> Zekka: i think i got it from maerwald's explanation
11:06:49 <mniip> might want to move that into a where-clause
11:06:50 <Zekka> I'm kinda watching my actual point getting massively derailed in front of me because people have a justified hate for Javascript
11:07:04 <mniip> with ScopedTypeVariables you might have a nicer shortcut
11:07:38 <EvanR> Zekka you need a coffee
11:07:54 <Shockk> mniip: hmm, I just want the TypeRep to be for the type variable `a`, but I can use undefined for that too right?
11:07:57 <Zekka> EvanR: I probably do, it's a little early in the morning for me
11:08:00 <mniip> yes
11:08:10 <Shockk> great, thanks
11:08:21 <Shockk> out of interest is undefined the best solution for it?
11:08:26 <maerwald> https://github.com/facebook/Haxl -- this is what concurrency should look like (although the scope is very specific, but that's the whole point)
11:08:32 <mniip> I don't know
11:08:41 <mniip> it's a trick I have independently discovered
11:08:47 <Shockk> hmm okay
11:08:48 <mniip> and abused as much as possible
11:08:51 <Zekka> fwiw the impression I'm being given is that concurrency is a more interesting topic than "is this design needlessly complex" so I will probably make a quick exodus
11:08:51 <maerwald> don't expose concurrency complexity to the programmers, it's too hard 
11:09:01 <ertesx> Zekka: i think they may be worth learning, but probably not so much in haskell
11:09:04 <Zekka> because I like complaining about needless complexity and I am not an expert on concurrency
11:09:15 <maerwald> Zekka: and one shouldn't be
11:09:18 <Zekka> my goal was absolutely not to talk about concurrency
11:09:49 <Shockk> I mean I guess undefined/some other bottom is kind of the only thing I can use if I want to have a value of any type that's passed in
11:09:58 <Shockk> thanks mniip 
11:11:45 <phanimahesh> that's both clever and crazy. I wouldn't have thought of abusing undefined like that
11:12:05 <Shockk> the value isn't evaluated when getting the TypeRep, right?
11:12:08 <Shockk> I mean, I assume it's not
11:12:40 <phanimahesh> yep. thanksto laziness
11:12:58 <phanimahesh> you don't need to evaluate something to get its type
11:13:19 <phanimahesh> I guess/expect
11:13:20 <Shockk> right
11:13:21 <Shockk> makes sense
11:25:10 * acrofus
11:27:08 <Shockk> mniip: I just realized, typeRep takes a (Proxy a),
11:27:15 <Shockk> so I can just use typeRep (Proxy :: Proxy a)
11:27:33 <mniip> only if you have scoped tyvars
11:27:39 <Shockk> yep
11:28:30 <Shockk> anyway, thanks again
11:45:55 <jonkri> Is anyone aware of any academic research which analyzes package metadata (Cabal information) and/or code (AST)? I'm looking for an empirical master thesis topic.
11:47:57 <athan> jonkri: What do you mean by analyze? Like statistics or something?
11:48:06 * athan isn't academic fair warning :x
11:48:47 <athan> jonkri: Building a server to fetch cabal information is actually pretty easy
11:48:56 <athan> s/server/client
11:50:34 <jonkri> athan: Yes, exactly - statistics. Perhaps also an experiment/hypothesis testing down the road.
11:51:38 <athan> jonkri: So something like the trends of most packages that people submit to hackage?
11:51:41 <maerwald> jonkri: I would actually be interested in the amount and frequency of API breakage in haskell libraries. I think it's a lot more than in other languages, but I don't have data to back it up.
11:51:45 <jonkri> One thing I thought could be interesting to look at is the different kinds of exception/error primitives that are used, using ASTs.
11:51:47 <athan> I'm sure the hackage people would know a tremendous amount
11:52:14 <jonkri> maerwald: I love that. Reasons why packages are breaking.
11:52:43 <jonkri> athan: That's one thing you could look at too, for sure.
11:53:09 <jonkri> Different trends between packages and technologies, patterns of usage, etc.
11:54:25 <carado> how come in Data.Vector.Mutable vectors can be resized, but their size can be accessed outside of a monad ? doesn’t that create different results at different times for purely functional calls ?
11:54:42 <jonkri> maerwald: Aha, you meant just the extent/frequency.
11:55:29 <maerwald> jonkri: yeah, sort of... I think that would be extremely useful data if you can come up with a reliable way to gather and interpret data
11:55:51 <bennofs> maerwald: you would also need that data for other languages though
11:55:56 <maerwald> it might involve actually setting up a CI system etc, but you could start with examining version constraints
11:56:07 <maerwald> which basically is just cabal metadata
11:56:16 <mniip> carado, what functions are there to resize them
11:56:26 <bennofs> maerwald: also breaking at compile time vs breaking at runtime makes it difficult to compare to other langs
11:56:38 <carado> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Mutable.html#v:grow
11:56:46 <maerwald> jonkri: e.g. you can gather data on how tight version contraints on libraries are and the related timeframe, when they changed etc
11:57:05 <mniip> carado, that creates a new MVector
11:57:06 <maerwald> bennofs: yeah, I'd only do compile-time actually
11:57:07 <carado> ooh, it creates a new vector. nevermind
11:57:25 <maerwald> run-time is too complicated and unreliable
11:57:29 <bennofs> maerwald: kind of expected that haskell's "compile time breakage" is higher then though :)
11:57:38 <athan> jonkri: Actually I'd bet the stackage people and trustees know a lot about this
11:57:45 <maerwald> bennofs: I don't think so
11:58:41 <athan> I've been wanting to do stuff like this, but the amount of weight needed to lift just isn't feasible for me right now. Also, haskell-src-exts parser isn't the same as GHC's parser, so you can get errors
11:59:08 <jonkri> athan: Ah, good to know.
11:59:09 <athan> like you don't need -XMultiParamTypeClasses with a constriant like `(Foo a b) => ...` in GHC, but you do according to the Haskell report
11:59:35 <athan> Please let me know if you start a project, I'd love to help where I can :)
12:00:19 <jonkri> athan: Thanks, mate! Could you PM me your e-mail address perhaps, or do you prefer that I write you here?
12:17:54 * hackagebot llvm-ffi 3.2.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.2.1 (HenningThielemann)
12:21:09 <cloudhead> anyone writing haskell in neovim?
12:23:00 <thewormkill> me
12:26:40 <cloudhead> thewormkill: is the haskell support better than vanilla vim?
12:27:57 <thewormkill> it's not much different, as far as I am concerned, because I use the same plugins after the switch that I used before. However, there is a syntax highlight + indent plugin especially designed for neovim that I am pretty fond of, but which works in vim as well
12:28:22 <mitchty> ghc-mod+nix = pita, what other options besides ghc-mod are there
12:28:57 <cloudhead> hmm I see
12:29:11 <cloudhead> there's an intero plugin, but it doesn't look maintained
12:29:12 <thewormkill> I actually don't integrate anything more fancy than that into vim
12:29:16 <cloudhead> and doesn't make use of the async functionality
12:31:13 <mitchty> think its time to just call ghc-mod a lost cause, can never seem to get it to work with stack and nix or cabal for that matter
12:31:33 <maerwald> ghc-mod is a perfect example of an ever-breaking API
12:31:47 <ertesx> mitchty: which editor?
12:31:55 <mitchty> ertesx: emacs
12:32:08 <ertesx> mitchty: i use haskell-mode + haskell-interactive-mode + nix
12:32:16 <lpaste> Shockk pasted “No title” at http://lpaste.net/6426995267962142720
12:32:29 <cloudhead> maerwald: why does this happen though?
12:32:38 <cloudhead> how is it that ghci doesn't break
12:32:40 <Shockk> I have another quick question; is there any way for me to tidy up this function definition in some way?
12:32:45 <maerwald> partly because of ghc itself, partly because of the dev
12:32:53 <Shockk> I was thinking about the fact that Maybe is a monad,but I don't know how to do this 
12:32:59 <mitchty> ertesx: https://github.com/mitchty/dotfiles/blob/master/emacs.org search for ghc-mod, thats the current config, but it'm going to rip out any ghc-mod stuff now, don't need it that bad
12:33:00 <Shockk> see my lpaste above for the code
12:33:39 <ertesx> mitchty: that's an interesting way to configure emacs =)
12:33:40 <cloudhead> it's kind of unfortunate that the best way to integrate with ghc is via a stdin/stdout and a modded ghci
12:34:07 <mniip> retrieveDyn rep k >>= (>>= fromDynamic)
12:34:10 <mitchty> ertesx: :) its a wip yet, but i can have org export my config kinda like a nix generation and rsync it
12:34:11 <mniip> fun
12:34:15 <mniip> hmm, need pure
12:34:22 <hexagoxel> needs double fmap
12:34:32 <Shockk> hmm
12:34:32 <mitchty> it needs a bit more work and there are sharp edges yet
12:34:46 <Shockk> where would the pure go?
12:35:01 <mniip> retrieveDyn rep k >>= (pure . (>>= fromDynamic))
12:35:08 <Shockk> oh I see
12:35:15 <mniip> actually
12:35:19 <Shockk> hm that's a bit messier than I imagined but it would work I guess
12:35:21 <mniip> what's the point of that >>=
12:35:30 <mniip> (>>= fromDynamic) <$> retrieveDyn rep k
12:35:41 <Shockk> oh right
12:35:46 <hexagoxel> ah, yeah oops, just one fmap. :D
12:35:52 <Shockk> that looks nicer
12:36:15 <mniip> might want to use 'maybe Nothing fromDynamic' instead
12:36:29 <ertesx> mitchty: anyway, to use nix with haskell-intearctive-mode you need a wrapper script, if you want per-project environments…  mine is here: http://hub.darcs.net/esz/config/browse/bin/nix-ghci
12:36:32 <Shockk> on the left side of the <$>?
12:36:36 <mniip> yes
12:36:59 <Shockk> that might be nicer yes
12:37:07 <mitchty> ertesx: #! /usr/bin/env zsh don't see that too often
12:37:56 <mitchty> well i'll give it a go, i have all my old dotfile configs so not like i'll lose out on anything
12:38:16 <ertesx> mitchty: note that the script regenerates your default.nix and shell.nix
12:38:40 <mitchty> ertesx: yeah no worries there, long as it keeps the stack.yaml as is its fine
12:39:04 <ertesx> yeah, it doesn't assume stack
12:40:14 <ertesx> mitchty: if you write long-running applications you may want to launch and run in the background, you may also be interested in this: http://hub.darcs.net/esz/config/browse/emacs/ertes-haskell.el
12:40:28 <toogley> hello. why does http://paste.fedoraproject.org/399016/69993893/ throw that error: http://paste.fedoraproject.org/399017/14699939/ ?
12:40:30 <ertesx> mitchty: see lines 46-54
12:41:16 <toogley> the exact same line works in ghci
12:42:02 <jonkri> maerwald, bennofs, athan: Thanks for your help. :)
12:42:29 <ertesx> toogley: that doesn't look like an error to me
12:43:23 <toogley> ertesx: aah, sry. http://paste.fedoraproject.org/399019/94174146/ 
12:43:32 <ertesx> toogley: perhaps you missed a 'print'?
12:43:42 <ertesx> toogley: 'main' has to be an IO action
12:43:49 <ertesx> main = print (2 + 3)
12:44:11 <mitchty> ertesx: cool will have a look, thanks!
12:44:56 <toogley> ertesx: aah, thanks
12:44:57 <ertesx> toogley: the interpreter does not treat 'main' specially, but the compiler does…  it needs your code to define what "the program" is by naming a certain IO action "main"
12:45:21 <Shockk> great that worked perfectly, thanks mniip and hexagoxel 
12:53:25 <toogley> ertesx: ah, okay. thx
13:22:56 * hackagebot encoding 0.8.1 - A library for various character encodings  https://hackage.haskell.org/package/encoding-0.8.1 (DanielWagner)
13:34:14 <danilo2> Hello guys! I've got a small question regarding (I think) new pattern synonyms. I've got datatypes (called atoms): `data A=A; data B=B, ...` and `data family Symbol atom` with instances `data instance Symbol A = S_A Int; data instance Symbol B = S_B Char Char; ...`. I would love to allow users to both pattern match and create the Symbol values using some kind of syntax like: `a1 = Symbol2 A 5; a2 = Symbol2 B 'x' 'y'` . Is it possib
13:34:37 <ski> cut off near ". Is it possib"
13:35:01 <danilo2> Is it possible to define such `Symbol2`?
13:35:20 <danilo2> ski: ^^^. Interesting. My client displayed the full message :.
13:35:22 <danilo2> :/
13:38:36 <ski> you could also try <http://web.student.chalmers.se/%7Emd9slj/msx/Frontier.zip>, which is from "Frontier: Elite II", the sequel to the space flight&combat&trade game "Elite"[B
13:38:39 <ski> ECHAN
13:40:19 <geekosaur> clients often will, they just show what you entered and not what happens when the server truncates
13:40:53 <geekosaur> (max message size 512 bytes, some of which is taken by your nick, channel name, and other protocol overhead)
13:41:24 <danilo2> :)
13:42:19 <danilo2> Anyway, do you guys know if something like what I've described above would be possible using any mechanisms allowed by ghc?
13:46:57 <lyxia> you can define a type class with a symbol2 method
13:47:31 <danilo2> lyxia: but I want to pattern match on it 
13:47:32 <lyxia> hmm type inference might be difficult still
13:48:12 <lyxia> oh with pattern match... I don't think pattern synonyms allow that currently.
13:48:19 <geekosaur> bidirectional patsyns are a thing
13:49:18 <danilo2> lyxia, geekosaur : yeah, I've been looking at bifdirectional ones, but I cannot get them to do what I want. geekosaur if you've been using them - would you be so nice, look at the above description and tell if you see a way to use them to do it ?
13:49:29 <geekosaur> no, I haven
13:49:32 <geekosaur> t used them, sorry
13:49:41 <geekosaur> I know they
13:49:57 <geekosaur> re there, don't know a lot of details. and apparently can't type today >.>
13:50:45 <danilo2> geekosaur: heh :) Ok, thank you :) 
13:52:28 <lyxia> Now I think it may be possible with pattern synonyms + view patterns
13:54:15 <lyxia> oh no, you want polyvariadic patterns...
13:54:40 <danilo2> lyxia: do you see any proof it is / isnt possible? 
13:55:54 <danilo2> by proof I mean - any explanation that is based on any ghc-valid assumptions, so I will not have to look longer for any solution and know it simply doesnt exist? :)
13:56:41 <lyxia> AFAICT pattern synonym definitions have fixed arity
13:56:56 <danilo2> lyxia: ok, that would be a proof
13:57:16 <lyxia> my idea was to define a pattern synonym for a view pattern that leverages a typeclass
14:00:27 <monochrom> yeah, that may work better
14:02:24 <athan> Anyone here good with css? ahahaha just kidding
14:02:58 * hackagebot bioinformatics-toolkit 0.2.1 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.1 (kaizhang)
14:03:01 <athan> D: what happened to #haskell-blah?
14:03:10 <EvanR> it exists
14:03:16 <athan> Wait... I thought I'm connection via SSL..? :(
14:03:18 <athan> sorry
14:03:51 <danilo2> lyxia: ok, you are right. We cannot define pattern synonyms for non-fixed arities. Tahnk you for your help! :)
14:05:29 <lyxia> Does having a tuple count as "close enough for your purposes": Symbol2 (A, 5) / Symbol2 (B, 'x', 'y')
14:05:45 <lyxia> I wonder why you think this is a good idea in the first place
14:06:16 <ski> athan : there's now also an #haskell-offtopic
14:06:35 <athan> ski: Hrm, what for? Oejet reigning terror? :P
14:06:43 <navilan> Hello everyone. Is it possible to write a function p0 :: (a -> Producer x m ()) -> Pipe a x m ().
14:09:40 <navilan> More generally, been trying to compose a producer and a function that takes the produced value and returns another producer to create a pipe without success.
14:16:15 <jellyCode> Has anyone here ever written a wrapper library for a REST API?
14:17:07 <ertesx> navilan: p0 f = forever (await >>= f)
14:18:19 <navilan> ertesx: oh nice.  Let me check it out. Many thanks :)
14:19:25 <ertesx> navilan: a producer is a specialised pipe, so you can use producers within pipes
14:19:29 <monochrom> jellyCode: does http://hackage.haskell.org/package/rest-core help?
14:19:46 <monochrom> also api-builder
14:20:02 <monochrom> I know nothing about them. I just went to hackage and searched for "api"
14:21:20 <danilo2> lyxia: no, I wanted thisto have clear API. The atoms I've described are used in many places. It would be very convenient to be able to ue them like `Symbol A 5`. An alternative for it, that I'll be using right now is just `Symbol.A 5`, but it is more convenient to declare distinct datatypes (atoms) and have just one "keyword" changing their meaning to symbols
14:22:12 <Shockk> hello, I'm trying to use lens to insert a value into a nested map, like so:
14:22:39 <Shockk> storage . at (dynTypeRep dyn) . non M.empty . at k ?= dyn
14:23:27 <jellyCode> monochrom, i found that already, it might help a little, thank you.  I was looking for examples to model after, this really isn't that exactly
14:23:53 <Shockk> so this should insert a Dynamic value into the `storage` map in the current State, at the TypeRep key, creating that key/value if it doesn't already exist, and then insert the actual value at key `k`
14:24:11 <Shockk> but when I try and build this, I get a no instance for (Eq Dynamic) arising from `non` error
14:25:07 <Shockk> my guess is that non does an equality check of the specified value and the current value in the map,
14:25:15 <glguy> Shockk: non :: Eq a => a -> Iso' (Maybe a) a
14:25:27 <navilan> ertesx: My problems arose when I tried to compose producers +  (some value transformer) + some other producer.  The resulting function turned out to need a Producer type.  Looks like I need to read and develop more intuition about pipes.   `forever` is definitely an eye opener.
14:25:33 <Shockk> if that is the case, is there then a function similar to non, except takes a function rather than a value?
14:25:49 <Shockk> so that I could pass in M.null for example, instead of M.empty
14:26:01 <glguy> What about: non' _Empty
14:26:02 <Shockk> glguy: ah so it is as I thought
14:26:16 <Shockk> hmm, what's the difference between non and non'?
14:26:26 <glguy> the type
14:26:35 <Shockk> oh right
14:26:55 <Shockk> I should be using hoogle more
14:27:16 <glguy> even better would be to use the haddocks for the package directly
14:27:16 <Shockk> I can't find any documentation on _Empty
14:27:47 <Shockk> ah now I do
14:28:14 <c_wraith> wow, haddock's representation of default signatures is wonky.
14:28:31 <c_wraith> I decided to look up _Empty.  That's..  weird.  https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Empty.html#v:_Empty
14:29:06 <Shockk> glguy: huh, _Empty worked
14:29:10 <Shockk> great
14:30:15 <glguy> Shockk: You can use the "index" to find documentation for a name in a package https://hackage.haskell.org/package/lens-4.14/docs/doc-index.html
14:30:30 <Shockk> ahh, thbanks
14:30:32 <Shockk> thanks*
14:30:36 <Shockk> I didn't actually know that existed
14:30:54 <c_wraith> I wish there was a link to it from the package description page
14:31:08 <c_wraith> instead of having to click on a module first.
14:31:24 <glguy> The front index? There is. It's at the bottom of the modules list as  [Index]
14:31:26 <Shockk> looks like there's one at the bottom
14:31:55 <c_wraith> oh, that's an awkward location.  I'll only ever find it by searching.  Still, good to know.
14:31:57 <glguy> Not that that's convenient, or where I'd like it to be
14:34:37 <fsestini> Hi guys. I was reading the haskell 2010 report about the monomorphism restriction.
14:34:37 <fsestini> At some point there are examples where it is stated that
14:34:37 <fsestini> a function binding like f x y = x + y generalizes in the expected way,
14:34:37 <fsestini> whereas the pattern binding f = \x -> \y -> x + y doesnt.
14:34:37 <fsestini> The rationale behind this, according to the report, is that in the first version there is no danger of recomputation.
14:34:39 <fsestini> I fail to see the point here. I always thought that the two
14:34:43 <fsestini> declarations above were semantically equivalent, apart from slight
14:34:45 <fsestini> syntactic details. Can somebody explain why it is not so?
14:34:59 <c_wraith> modern versions of GHC dropped the monomorphism restriction
14:35:21 <glguy> c_wraith: How modern are we talking? Unreleased?
14:35:34 <c_wraith> Oh, only in ghci, right
14:35:51 <fsestini> ok but how is f x y = x + y different from f = \x -> \y -> x + y ?
14:36:12 <glguy> fsestini: The goal is that if you see a value binding that you should be able to expect that it won't be recomputed if used multiple times
14:36:27 <glguy> but if you see a function binding you should always assume it will recompute when used
14:36:40 <c_wraith> note that ghc uses the number of arguments provided explicitly in other weird ways, too, like deciding when to inline.
14:36:55 <c_wraith> Seriously, why does ghc still choose to inline based on explicit argument count?
14:41:10 <fsestini> glguy, ok, so the point is that pattern-bound variables are expected to be values that are not recomputed, and without the MR they would get more general types that would force them to be recomputed even if it's not the intended behaviour
14:41:19 <glguy> Yeah
14:41:44 <c_wraith> The issue is especially pernicious with dictionary-passing implementations of classes.
14:41:51 <glguy> but if you want them to be recomputed you can add an explicit type signature so that it's clear to the reader that they will be
14:41:52 <c_wraith> It replaces a constant with an implicit function
14:42:22 <glguy> or at least that they might be
14:42:43 <c_wraith> Well.  GHC might optimize that back out, and often will in simple cases.
14:44:01 <fsestini> c_wraith, is that because, say, a value of type Num a => a is actually an implicit function receiving a dictionary as input?
14:44:31 <c_wraith> fsestini: yep.
14:44:41 <fsestini> got it
14:45:09 <c_wraith> In some cases, that can make something that would be O(n) if it's monomorphic O(2^n)
14:45:14 <c_wraith> It's rare, but it happens sometimes.
14:50:57 <jakeehrlich> is anyone aware of weather or not there is a competitive SAT or SMT solver written in pure haskell (without making calls to an external solver)
14:52:26 <geekosaur> I doubt it? they're in the class of things that are hard enough to get right that anyone with any sense links to an existing one that's already gotten the bugs out instead
14:53:48 <hpc> there's probably some naive ones out there, if being pure haskell is more important than being fast
14:54:40 <jakeehrlich> yea it is more important. I implemented a DPLL solver but that's about it. I didn't want to implement a full CDCL algorithm
14:55:03 <jakeehrlich> I'd really like to be able to get unsatisfiable cores
14:55:24 <jakeehrlich> which my current system dosn't do
14:59:03 <jmcarthur> Does there exist a Haskell-level interface for overwriting a node in GHC with an indirection to another node?
15:00:31 <c_wraith> are you looking for a better solution to the mapM problem?
15:01:50 <chindy> can someone explain this operator overloading: someFoo . concat $! f
15:01:57 <jmcarthur> No, I want to do far dirtier things.
15:02:09 <c_wraith> chindy: what overloading?
15:02:14 <glguy> chindy: There's no overloading there, . and $! are just two normal operators
15:02:16 <c_wraith> chindy: that's just function calls
15:02:29 <chindy> the  ".", and "$" in connection with the ! in this case
15:02:35 <c_wraith> There's no overloading
15:02:37 <glguy> . has higher precedence than $! so that parses as   (someFoo . concat) $! f
15:02:38 <EvanR> :t ($!)
15:02:40 <lambdabot> (a -> b) -> a -> b
15:02:42 <jmcarthur> chindy: $! is a different operator from $
15:02:42 <EvanR> :t (.)
15:02:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:02:59 * hackagebot intricacy 0.6.2 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.6.2 (mbays)
15:03:38 <jakeehrlich> ok different question: does ghcjs get a performance boost when ST is used?
15:03:52 <c_wraith> jakeehrlich: performance boost as opposed to?
15:03:58 <glguy> intricacy looks interesting: http://mbays.freeshell.org/intricacy/
15:04:02 <jmcarthur> c_wraith: I don't remember how that mapM thing worked, but since my question reminded you of it, it makes me think I should refresh my memory. But I don't remember who did it, and my Google-fu seems weak right now. Do you know how I can find that blog post?
15:04:22 <c_wraith> jmcarthur: I think jaochim breitner was involved, but that's not a lot of help
15:04:30 <c_wraith> Joachim.  I can spelll
15:04:38 <jakeehrlich> c_wraith: you can implement efficent algorithms with benign effects in haskell using ST. I'm wondering if the same kinds of optimizations carry over
15:05:28 <c_wraith> jakeehrlich: ultimately, it depends on how IORef/STRef (same data structure underneath) are implemented.  But I can't imagine they aren't implemented the obvious way
15:05:38 <ski> (s/benign/no/)
15:05:47 <c_wraith> jakeehrlich: and the obvious way means that it gets the performance properties
15:05:56 <jmcarthur> c_wraith: That helped, thanks. http://neilmitchell.blogspot.com/2015/09/making-sequencemapm-for-io-take-o1-stack.html https://www.joachim-breitner.de/blog/620-Constructing_a_list_in_a_Monad http://www.joachim-breitner.de/blog/684-Constructing_a_list_in_a_monad_revisited
15:06:08 <c_wraith> jmcarthur: nice find
15:06:21 <jakeehrlich> that makes me feel good. thanks c_wraith
15:08:29 <jmcarthur> c_wraith: Ah, and this must have been what you were actually thinking of: http://twanvl.nl/blog/haskell/unsafe-sequence
15:09:17 <c_wraith> jmcarthur: yeah, that's what your question reminded me of
15:21:01 <ski> jmcarthur,c_wraith : that post looks like TCMC (and those holes reminds me of `IVar's, and of <http://www.ps.uni-saarland.de/alice/manual/futures.html#promise>)
15:21:37 <c_wraith> ski: the comments talk about ivars quite a bit
15:22:32 <jmcarthur> ski: Yeah, but I need to be able to update multiple times.
15:23:01 <jmcarthur> ski: (value-preserving, but representation optimizing)
15:23:43 * ski nods
15:24:31 <ski> what are you implementing ? splay heaps ? improving intervals ?
15:24:53 <chindy> can someone explain what in:  someFoo !xs = listToMaybe [ x | [x] <- xs ]   , the [...] syntax is all about ?
15:25:12 <ski> (s/heap/tree/)
15:25:52 <ski> c_wraith : that's a list comprehension. `[ x | [x] <- xs ]' is : the list of all `x's, where `[x]' is drawn from the list `xs'
15:25:55 <jmcarthur> ski: I'm currently looking at Kaplan, Okasaki, Tarjan, "Simple Confluently Persistent Catenable Lists", but having this in my toolbox would be useful for many other things.
15:25:55 <ski> er
15:25:57 <ski> chindy ^
15:27:10 <ski> > [x | [x] <- [[1],[2,3],[4],[5,6,7],[8],[9,10],[11],[12,13,14,15]] ]
15:27:12 <lambdabot>  [1,4,8,11]
15:27:39 <ski> > [x^2 | x <- [0,1,2,3,4,5,6,7,8,9]]
15:27:40 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
15:28:14 <chindy> ski, so basically its a combination of drop_if and a function 'a -> bool ?
15:28:15 <ski> chindy : in your case, only the lists in `xs' that are actually singletons will be considered (because only those match the pattern `[x]')
15:28:55 <ski> list comprehensions are more powerful than that, but in this case, yes
15:28:56 <chindy> or a map function
15:29:31 <ski> (is `drop_if' in F# or something ?)
15:29:37 <chindy> ocaml
15:29:53 <chindy> nvm ... its drop_while
15:29:55 <chindy> i think
15:29:56 <chindy> ...
15:31:33 <jmcarthur> An annoying thing is that I actually need to update two fields at a time, atomically. I could avoid this by putting an extra box around it so I just have one field to update, but then I have more indirections and allocations, which is exactly what I'm trying to avoid. I guess I could do some compare-and-swap magic somewhere.
15:31:37 <ski> there's `List.filter' in O'Caml, but no `drop_if' (i checked just before) it seems .. at least not in the version i tested
15:31:47 <ski> (nor `drop_while')
15:31:49 <toogley> why is this code here wrong? it can't read the fibonacci function. https://paste.fedoraproject.org/399143/00423814/
15:32:00 <jmcarthur> ski: The Core library has that stuff.
15:32:20 <ski> ok
15:32:35 <glguy> toogley: Change the first line to:   module Main where
15:32:44 <glguy> toogley: and then the second line to:   main=print take 10 ( fib 1)
15:32:53 <ski> toogley : `main' and `fib' don't start in the same column
15:32:54 <glguy> (you're going to get a new error, but this is the first step)
15:33:04 <dolio> ski: It occurred to me the other day that IVars are basically a less disciplined, special case of ⅋.
15:33:20 <ski> dolio : mhm ?
15:33:23 <ReinH> toogley: that's not how you use the where clause in a module declaration
15:33:26 <ReinH> put main on its own live
15:33:46 <ReinH> there where clause in a module declaration is for listing exports
15:34:01 <ReinH> or rather, separates the export list from the module source
15:34:06 <ski> (no, `where' includes the whole module)
15:34:39 * ski normally indents the whole module body two spaces ..
15:34:41 <geekosaur> so the problem is that that indentation gives you the definition of fib "outside" of the module declaration, which is an error
15:34:41 <ReinH> so basically you're saying that the main function is the entire module
15:34:46 <ReinH> ski: really?
15:34:48 <ski> yes
15:34:51 <dolio> !A ⅋ (!A -o ⊥), but you can still do races on the write end, because the linearity isn't checked, except by throwing exceptions on multiple writes.
15:34:51 <ReinH> huh
15:35:35 <ReinH> So you can just write: ``module Main where'' on its own line, and then the source of your module.
15:35:50 <ReinH> (most people don't indent the rest of the file)
15:35:55 <glguy> ski: To what end?
15:36:07 <geekosaur> consistent handling of indentation of where clauses?
15:36:21 <geekosaur> (that kind of consistency strikes me as a hobgoblin, but...)
15:36:22 <ski> toogley : anyway, `take 10 ( fib 1)' looks confused. where's the list ?
15:36:25 <ski> glguy : consistency
15:36:43 <dolio> I suppose that also assumes you're forking something to write to your IVar.
15:37:43 <toogley> ski: hm, right. that was the cause.
15:38:33 <x1f577> is there a way to automatically detect the http content type of a lazy byte stream? 
15:38:34 <ski> toogley : perhaps you intended something like `main = print (take 10 [fib n | n <- [0 ..]])' .. perhaps something else
15:38:39 <jmcarthur> http://twanvl.nl/blog/haskell/unsafe-sequence insists that you can only safely overwrite with an indirection node once due to pointer tagging, but I suspect that could be loosened to "you can only replace a node with a node having the same constructor"
15:39:02 <jmcarthur> where by "overwrite once" I mean "overwrite a *hole* once"
15:39:07 <toogley> ski: yeah, i just noticed that. thanks
15:39:22 <toogley> thanks also glguy and ReinH 
15:39:39 <jmcarthur> it should probably be evaluated if the original was evaluated, too
15:39:45 <ski> dolio : am i to assume an implicit wrapping `!' ?
15:41:23 <ski> (and i'm not quite sure why the `A's are annotated with `!'s here. to enforce the value being copyable ?)
15:47:19 <dolio> What gets wrapped in !? And yes, the !A is there because you can get the contents of an IVar as many times as you want.
15:47:54 <dolio> Because the only real linearity requirement is in the writing.
15:48:58 <ski>   !(!A ⅋ (!A -o ⊥))
15:49:12 <ski> otherwise you can only write once, no ?
15:50:28 <ski> (or should it rather be `!A ⅋ !(!A -o ⊥)' ?)
16:01:09 <dolio> Yes, but you can only really write to an IVar once. It just isn't statically checked.
16:07:22 <dolio> Truthfully, I was thinking of an even more limited case, where you use IVars to explain unsafeInterleaveIO, where it's obvious there's only one write.
16:26:28 <dolio> In that case it also doesn't matter if an IVar write is supposed to return.
16:33:04 <ski> dolio : .. i was wondering what you meant by "you can still do races on the write end", but now i see that you meant on the `IVar' side of things
16:33:18 * ski is reminded of Wadler's session types paper
16:33:32 <dolio> Yeah. That's the 'less disciplined' part.
16:38:04 <trippy_> hi to all :D
16:58:03 * hackagebot hw-rankselect 0.0.0.6 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.6 (haskellworks)
17:03:03 * hackagebot singleton-bool 0.1.0.0 - Type level booleans  https://hackage.haskell.org/package/singleton-bool-0.1.0.0 (phadej)
17:10:41 <codebam> can someone help me understand this "let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]" in http://learnyouahaskell.com/starting-out. I don't understand how it is generating all triangles
17:11:37 <hpc> codebam: it's a list comprehension that generates all possibilities of (a, b, c) where all three of them are elements of the list [1..10]
17:11:51 <monochrom> There is no triangle. Only triples.
17:12:23 <hpc> "var <- list" in the comprehension means consider each possibility in list to be named var
17:12:28 <monochrom> And you could use a smaller example like [ (a, b) | b<-[1..3], a<-[10..12] ]
17:13:01 <monochrom> Or even going back to basics, [ a*a | a<-[10..12] ]
17:13:20 <hpc> you should experiment with list comprehensions in ghci a bit as you learn them
17:13:42 <hpc> LYAH isn't very good for exercises, so you'll need to do some of that legwork yourself
17:13:52 <codebam> oh I see
17:14:00 <codebam> so they arent actually working triangles
17:14:03 <hpc> write something, think about what you expect it to be, see what it is, and adjust your understanding
17:14:33 <hpc> and yeah, the triangles it talks about are just the lengths of the three sides
17:14:53 <hpc> but later in the chapter it points out that you're generating invalid combinations of sides, and how to remedy that
17:15:06 <hpc> you might discover that yourself though
17:16:58 <codebam> okay cool, thanks. I'm really enjoying learning this
17:18:07 <codebam> honestly though, do you think this language is very practical? Considering that no other programmers will understand your code.?
17:18:18 <codebam> that's to anyone who knows haskell
17:18:32 <codebam> I'm just curious what your opinion is
17:18:34 <Koterpillar> codebam: I found that it's easy to explain other languages using Haskell analogues
17:20:30 <Koterpillar> codebam: so, point one is you don't have to _write_ haskell for it to be advantageous
17:21:02 <codebam> so are you trying to say that some things in haskell that are super simple are good for explaining complex code in other languages?
17:21:20 <ski> > imagPart (heron 1 2 5)
17:21:22 <lambdabot>  4.898979485566356
17:21:55 <Koterpillar> codebam: and not writing the complex code in the first place! If you can recognize an abstraction, that can save you time/etc.
17:22:21 <codebam> like recursion like recursion like recursion like recursion
17:22:23 <codebam> :)
17:23:02 <Koterpillar> well, recursion made it everywhere by now
17:23:44 <codebam> well yeah true
17:24:26 <codebam> but I can see the advantages of Haskell, it's just that writing functionally I feel like no one will understand my code
17:25:27 <monochrom> I write all practical programs in Haskell.
17:25:35 <Koterpillar> if you are writing functionally in e.g. Python, that is true
17:26:04 <monochrom> I only write toy programs in Python.
17:26:29 <monochrom> Did you know: ghci is a better repl than python's.
17:26:51 <monochrom> ghci can forget everything and do a clean reload. python's can't.
17:27:13 <codebam> I like how it has tab completion, not sure if python's has that
17:27:13 <Koterpillar> how is that better than a restart?
17:27:38 <Koterpillar> IPython 5 does
17:27:46 <Koterpillar> and syntax highlighting
17:28:21 <codebam> that's pretty cool
17:28:34 <codebam> does haskell have an equivalent of the python PEP?
17:28:42 <monochrom> yeah, there was some reason I did not want a restart, and I forgot what.
17:28:57 <fragamus> im using ListT for nondeterminism in a game tree search and now i want to put in alpha beta -  my question is : should I use state monad to propogate alpha and beta back up the tree to affect peer branches? does this violate any law - does it assume order of execution in ListT where such order is not guaranteed?
17:29:37 <monochrom> OK here is one. "python xxx.py" is not a simple reload, it also runs main.
17:30:01 <Koterpillar> that won't get you a shell
17:30:08 <Koterpillar> do you mean ipython?
17:30:11 <monochrom> So suppose I only want a reload. Then it's several steps. Restart but only say "python", then a lengthy command or two for loading.
17:30:18 <monochrom> Just python.
17:30:21 <codebam> I was talking with someone the other day about how pointers would work in functional programming, we finished with saying that it's non-functional and not really practical in functional programming
17:30:42 <Koterpillar> why do you want pointers?
17:31:04 <codebam> I don't, but if I did I couldn't use them.
17:31:04 <monochrom> I'm sure ipython solves all the world's problems.
17:31:15 <Koterpillar> monochrom: ihaskell exists
17:31:55 <ski> codebam : have you seen `IORef' yet ? or how about `Int's referencing into an `IntMap' ?
17:32:12 <Koterpillar> codebam: rephrase: pointers are an implementation detail; what do you _actually_ want?
17:32:25 <codebam> not at all, I'm on part one of LYAH
17:32:50 <Koterpillar> keep reading then, there are more nice things ahead. MVars are a bit like pointers, btw
17:32:57 <monochrom> Koterpillar, I'm sure codebam means there was a discussion and the conclusion is what you're saying now.
17:32:59 <ski> also, there's
17:33:02 <ski> @type Foreign.Storable.poke
17:33:03 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
17:33:04 * hackagebot purescript 0.9.3 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.9.3 (PhilFreeman)
17:33:04 <ski> @type Foreign.Storable.peek
17:33:05 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> IO a
17:33:33 <codebam> yes I never said I wanted them, no idea how I would use them in functional programming either
17:34:05 * ski just read a paper about continuations and pointer reversal
17:45:00 <joe9> I am writing a haskell streaming client. I am getting a stream of continuous data from the server. Just want to check if there are any libraries that can help me?
17:45:08 <sbrg> joe9: yep
17:45:12 <sbrg> conduit, pipes and friends
17:45:18 <sbrg> I am personally pretty fond of conduit
17:45:25 <joe9> Most haskell web libraries such as servant seem to be geared towards request -> response
17:45:37 <sbrg> oh, you want websockets?
17:45:39 <joe9> sbrg: yes, I am using http-conduit too.
17:45:41 <sbrg> there's also libraries for that
17:48:04 * hackagebot singleton-bool 0.1.1.0 - Type level booleans  https://hackage.haskell.org/package/singleton-bool-0.1.1.0 (phadej)
17:49:23 <joe9> sbrg: Thanks.
18:16:04 <athan> joe9: You can just embed a WAI application
18:16:10 <athan> which is embedded with wai-websockets
19:40:25 <joe9> The streaming application uses CRLF json protocol, That is not websockets, is it?
19:40:57 <Koterpillar> joe9: nope
19:42:45 <joe9> Koterpillar: Do you know of any haskell libraries that can help with "CRLF json protocol" ? Do I have to worry about headers, etc.? is http-conduit httpLbs good enough for taking care of this protocol?
19:43:29 <Koterpillar> "CRLF json protocol" doesn't sound like HTTP to me
20:08:59 <dfeuer> Huh.
20:09:44 <anohigisavay> hi
20:09:55 <anohigisavay> is it possible to add constraints to type families?
20:10:02 <dfeuer> Interesting. It seems the rebalancing functions in Data.Set can handle two-element imbalances as well as single-element imbalances.
20:10:12 <dfeuer> anohigisavay, no, but maybe you don't need to.
20:11:07 <dfeuer> anohigisavay, explain (preferably in a gist or on lpaste) what you are actually after.
20:13:08 <anohigisavay> dfeuer: please see http://lpaste.net/173260
20:13:55 <ikkarus> Hello world
20:14:50 <dfeuer> anohigisavay, you can't constrain the type family, but you can constrain the JIRAAuth class if you like. Or you can use ConstraintKinds to write type synonyms for those numerous constraints for convenience.
20:16:44 <anohigisavay> dfeuer: that'll make an * -> * -> * -> Constraint i suppose?
20:17:42 <dfeuer> anohigisavay, something like that?
20:17:43 <glguy> class SomeC (AuthResponse auth) => JiraAuth auth
20:18:19 <dfeuer> What glguy gives was my first suggestion. And is often the right one.
20:20:00 <anohigisavay> i don't think i understand. could you please elaborate a bit further?
20:20:24 <anohigisavay> what might SomeC be?
20:20:34 <dfeuer> anohigisavay, whatever class you like.
20:20:34 <glguy> the constraint
20:22:00 <anohigisavay> Oh! i see
20:22:10 <anohigisavay> great solution
20:22:37 <ski> should `class JiraAuth auth where {type AuthResponse auth; instance SomeC (AuthResponse auth)}' mean the same as what glguy said ?
20:23:04 <ski> or more generally, should `class B a => C a' mean the same as `class C a where {instance B a}' ?
20:25:16 <anohigisavay> no wait. That'll make AuthResponse a * -> * i.e. a single data type
20:25:53 <ski> anohigisavay, is that a problem ?
20:25:56 <anohigisavay> i probably want to split BasicAuth and OAuth2 as separate data types
20:26:02 <anohigisavay> oh sorry, nvm
20:26:28 * ski sees no `BasicAuth', nor `OAuth2' in the paste
20:26:56 <glguy> ski: i suppose that it should
20:27:28 <anohigisavay> http://lpaste.net/173260
20:27:45 <anohigisavay> this is what i get so far (although OAuth2 not implemented yet)
20:28:32 <anohigisavay> too much OO for me i think :(
20:33:35 <anohigisavay> when should one pick multiple class instances over a single data type with multiple constructors actually?
20:35:39 <ski> do you want third parties to be able to make (e.g. new types into) new instances of the class ?
20:37:04 <anohigisavay> ski: it would be great if they can. JIRA api is kinda stable with only two auth methods. but who can tell
20:37:54 <anohigisavay> no performance concern
20:38:12 <anohigisavay> it's trivial compared to network IO
20:38:13 <ski> glguy : .. i suppose one nice(?) thing with the other syntax would be that it would invite you to (want to) say stuff like `class C f where {instance A a => B (f a)}', meaning `class (forall a. A a => B (f a)) => C f'
20:41:16 <anohigisavay> ski: i have never seen such syntax. instance inside class decl?
20:41:27 <anohigisavay> oh, sorry
20:41:38 <ski> it's imagined syntax
20:42:18 <ski> anohigisavay : another approach might be to try an OO approach, by which i mean a record data type `data JIRAAuth authMethod = forall authOptions authResult. MkJIRAAuth {auth :: (JIRAAuthOptions authOptions,JIRAAuthResult authResult) => authMethod -> authOptions -> String -> IO authResult}'
20:42:59 <ski> .. though probably(?) you really mean `data JIRAAuth authMethod = forall authOptions authResult. (JIRAAuthOptions authOptions,JIRAAuthResult authResult) => MkJIRAAuth {auth :: authMethod -> authOptions -> String -> IO authResult}'
20:43:08 <ski> which corresponds to what glguy suggested
20:46:22 <ski> (the difference here is that what you said in your paste (corresponding to my first version) lets the "caller" ensure that `AuthOptions authMethod' is in `JIRAAuthOptions', and that `AuthResult authMethod' is in `JIRAAuthResult' (the "callee" being any `instance JIRAAuthOptions BlahAuth where ...', and a "caller" then is someone who ends up using a member definition of that instance ..)
20:46:29 <dfeuer> I don't understand INLINABLE properly. Can someone explain?
20:48:25 <anohigisavay> xD my english sucks. i'll need some time to digest your words
20:48:32 <ski> (.. while in the latter version of what i wrote, corresponding to glguy's suggestion, the *caller* itself (the maker of the instance) is the one who'll have to make sure that the types they pick for `AuthOptions authMethod' and `AuthResult authMethod' for a particular value of `authMethod', say `BlahAuth' *actually* also has to make sure that they are in fact instances of `JIRAAuthOptions' respectively `JIRAAuthResult')
20:48:45 <glguy> It ensures that the definition of INLINABLE thing is added to the .hi file so that it's possible to inline later
20:48:49 <glguy> from another module
20:48:57 <glguy> but it doesn't mark the definition as something that must be inlined
20:49:48 * ski didn't notice this distinction between the two versions, before considering it from the POV of a record datatype corresponding to the class (and record values corresponding to the instances)
20:49:59 <dfeuer> glguy, the confusing bit is that it looks like in 7.8 (in my case), it *inhibits* inlining within the defining module, but doesn't in 7.10. Very weird.
20:50:24 <dfeuer> glguy, what if any effect does INLINABLE have on a non-exported binding?
20:50:46 <dfeuer> (sometimes you want to export an unfolding without the binding, for when an exported thing inlines)
20:51:45 * ski . o O ( hygiene )
20:52:43 <dfeuer> glguy, actually, my problem's not inlining per se, but worker/wrapper. I guess. It's all very confusing.
20:53:07 <glguy> dfeuer: I'd be guessing if I answered, I don't know
20:53:07 <dfeuer> I feel like I'm trying to take out a screw with a mallet using the pragmas.
20:53:16 * ski str seeing dfeuer (long ago) on c.l.s
20:53:35 <dfeuer> ski, yes, you've mentioned this, I think. You've also definitely seen me here many times.
20:54:11 <dfeuer> You going to Hac Boston? If so, you can see me there too :-)
20:54:21 <ski> (i only mentioned it because i was thinking about hygiene, and that possibly you'd see what i thought of)
20:54:57 <dfeuer> ski, you mean the record stuff you were talking about that I wasn't following, or the pragma question?
20:56:03 <ski> no "what if any effect does INLINABLE have on a non-exported binding?" reminds me of hygiene
20:56:05 * dfeuer should go back to stripping that horrid hedge crud out of Data.Set and Data.Map. Divide and conquer is much simpler for unions, intersections, and differences, its performance characteristics are much better understood, and it's also a lot faster in the benchmarks :-)
20:56:16 <ski> (or rather, "sometimes you want to export an unfolding without the binding, for when an exported thing inlines")
20:57:11 <dfeuer> ski, ah... I don't quite see the relationship to macro hygiene. Can you draw the line?
20:59:16 <ski> one manifestation of macro hygiene is that if you have a macro which you pass an expression to, and which will expand to something involving that expression, but possibly wrapped inside a binding introducing an identifier `foo', then occurances of `foo' in that expression will refer to whatever it referred to in the context of the macro application, not to the local (private) binding the macro introduced
20:59:49 <ski> (unless you explicitly ask for hygiene to be breaked, i.e.)
21:01:15 <ski> (in ungygienic(-by-default) macro systems, they'd typically say you should use `gensym' to simulate this)
21:01:56 <ski> another manifestation is that you can have a macro, defined in a module, expand to an expression involving identifiers that were not exported by that module
21:02:07 <ski> (this one is harder to simulate)
21:02:39 <ski> it seemed to me that your `INLINABLE' issue was a bit related to this kind of situation
21:02:40 <dfeuer> ski, ah, I think I see.
21:04:50 <ski> (in either case, it's about lexical scope. identifiers inside an expression passed to a macro should refer to the bindings made in the *lexical* scope the macro was called from, not the scope in which it was defined. and vice versa, identifiers in an expression being the result of a macro expansion should refer to the bindings in the lexical scope of the definition of the macro, regardless of whether they're exported or not. that's the idea)
21:05:08 <ski> (er, cut off near ".., regardless of whether they're exported or not. that's the idea)")
21:05:15 <dfeuer> Yah.
21:06:22 <dfeuer> I wonder if someone can help me upgrade my GHC at Hac Boston next week, and re-set-up my GHC development tree....
21:06:26 * ski was btw happy to realize that `LiberalTypeSynonyms' could be thought of as allowing type synonyms to be "*higher-order* type macros"
21:07:15 <dfeuer> Except that it's not as good as that.
21:07:35 <dfeuer> LiberalTypeSynonyms, as far as I can tell, is sufficiently limited as to be almost useless.
21:08:30 <ski> limited in what sense ?
21:10:01 <dfeuer> ski, it doesn't let you pass a family to another family, does it?
21:10:40 <dfeuer> I want to be able to map a type family over a type-level list, for instance.
21:10:54 <ski> i don't know how (if) it interacts with type families at all
21:11:11 <dfeuer> So what do you use it for?
21:11:24 <ski> .. though i'm not sure why it would be an obstacle, on first thought
21:14:48 <joe9> need some advice, please? http://blogs.operationaldynamics.com/andrew/software/haskell/http-streams-introduction I just send a simple http post message with some json and I get back a continuous stream of data. The sendRequest talks about sending a request with a body. I do not need a stream to send the data. It is just a simple json message.
21:15:36 <joe9> It appears that the http-streams package sendRequest is expecting an inputStreamBody.
21:16:01 <joe9> Is there a way to convert a string to a stream? Is there a different approach to this problem?
21:16:11 * anohigisavay still has difficulty in understanding RankNTypes and ExistentialQuantification
21:16:34 * anohigisavay owes ski, dfeuer and glguy a beer
21:17:24 <dfeuer> :)
21:19:56 <ski> dfeuer : ok, i see why. because they want to be able to expand away type synonyms statically, and locally. but no such requirement for type families
21:20:37 <dfeuer> ski, if it doesn't work with type families, what use is it?
21:21:12 <dfeuer> I tend to see type synonyms as *almost* useless. lens makes a good case for them, but I'm not sure I've seen another.
21:21:13 <ski> type synonyms can be (somewhat) useful to give more intelligble names to stuff
21:21:14 <tnks> what's the time window for these counts?  https://hackage.haskell.org/packages/top
21:21:30 <ski> i agree that it's basically convenience
21:21:45 <ski> (being able to export a type synonym abstractly would be nice, as in the MLs)
21:21:47 <glguy> tnks: 30 days
21:22:14 <dfeuer> Type synonyms are also really good for confusing beginners, who are particularly likely to expect them to be more useful than they are :-/.
21:22:52 <tnks> glguy: good to know.
21:22:57 <ski> anohigisavay : i'm not sure you need `RankNTypes' here ..
21:23:10 * hackagebot glirc 2.2 - Console IRC client  https://hackage.haskell.org/package/glirc-2.2 (EricMertens)
21:23:10 <dfeuer> ski, if we had ML functors .... (or Agda's module system, which smells particularly nice).
21:23:14 <ski> (also, i don't drink beer .. but ty, anyway)
21:23:54 <dfeuer> I occasionally drink beer, but I usually prefer coffee-based drinks, or pinot noir, or chocolate egg creams, or chocolate milkshakes.
21:24:13 <dfeuer> But that's off-topic.
21:26:18 <ski> anohigisavay : `ExistentialQuantification' was only required in the translation here, because you had associated types in your class
21:30:01 <ski> anohigisavay : an instance of `JIRAAuth authMethod', for a particular `authMethod', "contains" a type `AuthOptions authMethod', and a type `AuthResult authMethod'. to model that in the data type setting, i used existentials. though one difference is that existentials are opaque, while associated types in a type class are "translucent"
21:36:10 * ski idly wonders whether there's a connection to opaque vs. translucent signature ascriptions in the MLs
21:36:16 <ski> (and translucent sums ?)
21:53:13 <joe9> just stumbled upon this: https://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html just want to check if there is something better than this for interfacing with sockets?
21:54:18 <glguy> I like using https://hackage.haskell.org/package/connection . It abstracts over using SOCKS proxies, TLS, both, or neither
21:54:29 <joe9> glguy, Thanks
21:54:43 <glguy> Of course that's only a feature if you were planning on using any of that
22:00:54 <joe9> glguy: it would be good to be able to use tls. so, that is a plus. Thank.s
22:02:31 <joe9> glguy: what is the Int value that you generally use for connectionGet?
22:02:37 <joe9> the size argument value.
22:03:13 <glguy> joe9: That would depend on how many bytes you needed
22:03:37 <glguy> If you don't care for some reason, then connectionGetChunk is probably better
22:04:03 <joe9> glguy: I understand that. makes sense. connectionGetChunk seems better.
22:04:09 <joe9> I just plan on reading line by line.
22:04:22 <glguy> OK, then keep reading the documentation for the next definition
22:04:33 <joe9> connectionGetLine?
22:04:40 <glguy> Yeah, is that what you need?
22:05:31 <joe9> yes, but, what is a safe value to use for Int? Max number of bytes.
22:05:35 <joe9> 8092?
22:07:05 <glguy> 8192 is the power of 2 fwiw, but there's no value I could give you that's just good enough for all circumstances
22:08:12 * hackagebot type-spec 0.1.0.0 - Type Level Specification by Example  https://hackage.haskell.org/package/type-spec-0.1.0.0 (SvenHeyll)
22:08:57 <joe9> glguy:  yes , 8192 . just a general measure normally used. not meaning to put you on the spot.
22:09:08 <joe9> glguy: just an industry standard.
22:09:17 <glguy> I'm not feeling spot-lighted, there just isn't an industry standard for this
22:10:39 <zlens> besides doctests, are there any other testing frameworks that are INLINE ?
22:10:46 <zlens> I don't like separate files, as I want the tests to drive my development
22:10:50 <zlens> hspec is separate file
22:10:55 <zlens> tasty appears to also be seprate file
22:11:00 <zlens> quickchecks looks like seprata file
22:11:28 <Koterpillar> zlens: do you want doctests?
22:11:50 <zlens> no, I'd preer something that I can fire off from ghci
22:12:02 <zlens> instead of a separate call (which is much slower when amodule has many dpeendencies)
22:12:18 <glguy> You don't have to put your QuickCheck properties in a separate file
22:12:23 <Koterpillar> in any case, no one is stopping you from putting hspec, etc. in separate files
22:12:38 <zlens> I want it to be in the same file, not in separate files
22:12:53 <zlens> I want it to drive the dev of the software, so I want the unit tests to be in teh same file; hspec, however, tends to be separate files
22:12:55 <Koterpillar> zlens: so put it all in the same file
22:13:05 <Koterpillar> it's not forcing you
22:13:14 <zlens> hmm
22:14:36 <glguy> zlens: There's even some template Haskell for aggregating all your quickchecks in the module https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html#v:quickCheckAll
22:16:40 <dfeuer> I don't believe in Template Haskell yet.
22:16:51 <glguy> bummer
22:16:51 <dfeuer> I also don't understand it, but that's another story.
22:16:55 <dfeuer> :P
22:17:19 <dfeuer> glguy, someone (E.Z.Yang?) blogged about what Racket gets right and TH gets wrong; he's right.
22:17:34 <Koterpillar> https://xkcd.com/154/
22:17:35 <dfeuer> The syntax also leaves much to be desired, and the documentation more.
22:17:45 <zlens> dfeuer: what is his main argument?
22:17:48 <glguy> It's certainly too useful to avoid because Racket is different
22:17:51 <dfeuer> zlens, staging.
22:18:12 <dfeuer> glguy, of course. It would be good to fix that though.
22:18:21 <dfeuer> Might happen, even... we'll see.
22:23:12 * hackagebot enummapset-th 0.6.1.1 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  https://hackage.haskell.org/package/enummapset-th-0.6.1.1 (LiyangHu)
22:29:04 <LettuceThree> Is there something in the pipes library equivalent to "(a -> b) -> Pipe a b m ()"?
22:29:15 <LettuceThree> I.e. it lifts a function to a pipe
22:30:36 <LettuceThree> Nvm, it's "map" in Pipes.Prelude
22:45:05 --- mode: ChanServ set +o glguy
22:45:06 --- mode: glguy set -bbbb *!*@64.56.124.97$#haskell-ops *23!~*21@*$#haskell-ops gerg*!*@*$#haskell-ops *!*@5.254.104.*$#haskell-ops
22:45:46 --- mode: glguy set -bo jollygood!*@*$#haskell-ops glguy
23:36:29 <dudeeee> what is a good tutorial on Monad transformers?
23:54:36 <freeside> http://book.realworldhaskell.org/read/monad-transformers.html
23:55:57 <dudeeee> @freeside Thank you!
23:55:57 <lambdabot> Unknown command, try @list
