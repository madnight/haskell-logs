00:11:55 <Velizar> Why does `fix (mconcat mempty)` work? It shouldn't even type check. Fix is (a -> a) -> a, (mconcat mempty) is a
00:12:06 <shachaf> "work" means "type-check"?
00:12:14 <coppro> :t mconcat mempty
00:12:16 <lambdabot> Monoid a => a
00:12:18 <Velizar> it doesn't raise any error
00:12:25 <Velizar> it returns () in GHCi
00:12:32 <coppro> > fix $ mconcat mempty
00:12:33 <shachaf> If fix :: (a -> a) -> a, and mconcat mempty :: Monoid b => b, then b must be equal to a -> a
00:12:34 <lambdabot>  ()
00:12:42 <coppro> ^
00:12:56 <Velizar> ah. oops :D
00:12:58 <EvanR> and its defaulting to a = () ?
00:12:59 <Velizar> yeah 
00:13:33 <EvanR> this is a bizarre confluence of things happening which would make a good haskell exercise
00:16:20 <enolan> this is a wacky one
00:16:31 <enolan> mconcat mempty is mconcat []
00:16:56 <enolan> and the function is from the monoid instance for (a -> b)
00:17:09 <EvanR> er what...
00:17:22 <EvanR> Monoid b => Monoiad (a -> b) ?
00:17:28 <EvanR> Monoid*
00:17:42 <enolan> wait maybe not
00:19:33 <Velizar> that's right - (mconcat mempty) = mempty
00:19:53 <EvanR> > fix mempty
00:19:55 <lambdabot>  ()
00:20:07 <Velizar> apparently it's just a function's mempty of Monoid. also see:
00:20:10 <enolan> > mempty "hi"
00:20:11 <Velizar> > mempty 4
00:20:11 <lambdabot>  ()
00:20:12 <lambdabot>  ()
00:20:15 <Velizar> yep
00:20:23 <enolan> mempty is const then?
00:20:37 <EvanR> wth instance is this
00:20:55 <pavonia> enolan: const ()
00:21:02 <Velizar> looks like it's `const nothing`, I'm not sure what precisely is in place of `nothing`
00:21:07 <EvanR> > mempty
00:21:09 <lambdabot>  ()
00:21:22 <EvanR> > mempty mempty
00:21:24 <lambdabot>      Could not deduce (Monoid a0) arising from a use of ‘mempty’
00:21:24 <lambdabot>      from the context (Monoid t)
00:21:24 <lambdabot>        bound by the inferred type of it :: Monoid t => t
00:21:37 <EvanR> gotcha
00:22:29 <enolan> it's Monoid b => Monoid (a -> b)
00:22:32 <enolan> where b is ()
00:22:49 <EvanR> ok
00:23:15 * hackagebot phoityne-vscode 0.0.6.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.6.0 (phoityne_hs)
01:01:32 * Iceland_jack . o O ( instance a ~ a' => Monoid (a -> a') where mempty = id; mappend = (.) }
01:01:50 <Iceland_jack> Don't tell me I closed that with a '}'
01:10:54 <adarqui> im looking through the guide but can't find it.. is it possible to 'stack install' a specific executable listed in the package.cabal file? ie, i have 2 executables in there.. and i'd like to only 'install' the second one
01:13:17 * hackagebot witness 0.4 - values that witness types  https://hackage.haskell.org/package/witness-0.4 (AshleyYakeley)
01:28:53 <osager> What is the best approach to Josephus problem? Is there a so-called circular programming in Haskell?(I've seen it on the haskell wiki)
01:31:04 <phnx> Hi all
01:31:28 <phnx> Is this expression in Weak Head Normal Form or does g have to be applied to the function?
01:31:28 <phnx> c (\x y -> x) g
01:31:55 <EvanR> c can be applied to the argument
01:32:02 <EvanR> so its not weak head yet
01:32:52 <EvanR> parens like this (c (\x y -> x)) g
01:34:20 <phnx> But assuming c is a constant or an unknown variable i could not reduce this any further?
01:35:11 <EvanR> if its well typed then c is a function
01:35:31 <EvanR> and you have to know what it is or it would be an undefined variable error
01:35:48 <phnx> its just an arbitrary example I made up
01:36:43 <EvanR> well, its not in weak head normal form, c cant be a (non-function) constant, and you cant apply g first
01:37:05 <phnx> okay, I see that
01:37:26 <phnx> would this be different if this was a lambda calculus expression?
01:38:03 <EvanR> if this is all there is, nothing to put there for c, then it would be stuck
01:38:31 <EvanR> in LC
01:38:55 <phnx> mhm I think I understand
01:38:57 <phnx> thanks a lot
02:21:51 <troydm> in which package is liftIO defined?
02:22:03 <troydm> and can I use it to convert IO (Maybe a) into Maybe a?
02:22:46 <cobreadmonster> :source liftIO
02:22:57 <cobreadmonster> I forget the lambdabot commands.
02:23:01 <cobreadmonster> :t liftIO
02:23:02 <lambdabot> MonadIO m => IO a -> m a
02:23:36 <troydm> I guess since it expects MonadIO I can't convert it right away 
02:25:16 <Cale> troydm: Control.Monad.Trans, and no
02:25:44 <Cale> There's no meaningful way to convert a value of type IO (Maybe a) into Maybe a
02:26:11 <Cale> Unless you count just executing the action
02:29:10 <cobreadmonster> unsafePerformIO
02:29:31 <dramforever> troydm: No. No.
02:29:50 <dramforever> (1) It won't work for (2),
02:30:05 <dramforever> and (2), It entirely defeats the purpose of IO
02:30:38 <dramforever> You were supposed to combine IO things together using library functions, not getting rid of the IO wrapping
02:31:07 <troydm> dramforever: I know right, just keep forgetting things, sorry
02:31:44 <dramforever> Don't worry, it's normal
02:33:35 <Cale> troydm: Inside a do-block for an IO action, you can write v <- x, when x :: IO t, and then v :: t
02:33:54 <Cale> It means "execute the action x, and call whatever its result was v"
02:34:24 <Cale> and then the do-block as a whole is itself an expression for another IO action
02:34:52 <Cale> (which, when executed, will cause x to be executed as part of what it does)
02:35:16 <Cale> Note that execution is a completely separate process from evaluation though
02:37:01 <troydm> Cale: nvm I've already decided to rewrite code to use ReaderT
02:37:26 <Cale> troydm: I don't see how that will help at all
02:38:00 <troydm> Cale: well I can wrap my configuration into ReaderT Config IO 
02:38:10 <troydm> call it ConfigT 
02:38:21 <troydm> and use ConfigT everywhere I need to have IO and Config
02:38:57 <Cale> I don't know, I would tend to just pass the Config as a parameter.  ReaderT over IO is more trouble than it's worth.
02:39:13 <Cale> Sure, you don't have to pass around the one parameter explicitly any more
02:39:23 <Cale> But in exchange, you have to liftIO everywhere
02:39:31 <Cale> and it's not like it makes the types any simpler
02:39:44 <Cale> and you give up easily using things like forkIO and catch
02:40:22 <haskell515> How can I replace error in ExceptT?
02:40:23 <Cale> Sometimes, with enough planning, in a setting where there are a fairly restricted number of basic IO actions you'd be using anyway, it can be okay
02:40:40 <Cale> You can lift those in one place and then build things out of them and forget about liftIO
02:41:02 <Cale> haskell515: I don't understand that question
02:42:34 <haskell515> Cale: I use `throwError "some error"` in one place and I want to check this error message and replace it in another place
03:40:31 <vavans> hi there
03:41:02 <vavans> i have a question regarding the usage of Foldable
03:42:56 <srhb> vavans: Ask away.
03:43:02 <troydm> what's the name of the function that converts [Monad a] -> Monad [a] ?
03:43:06 <troydm> I can't seem to find it
03:43:21 <srhb> @hoogle Monad m => [m a] -> m [a]
03:43:24 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:43:24 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:43:24 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
03:43:28 <srhb> troydm: ^
03:43:46 <troydm> ahh thx
03:43:48 <vavans> i have a fonction with types signature func :: (Foldable f) :: String -> IntMap String -> f String, the implementation is func str intmap = IntMap.filter (== str) intmap
03:43:54 <srhb> troydm: Searching by types is pretty nifty.
03:44:13 <vavans> and i get a type error saying that it couldn't match type f with IntmMap
03:44:45 <srhb> vavans: Look at the type of IntMap.filter
03:45:22 <maerwald> vavans: you are going from a specific to a general type, how does the function know what to produce?
03:45:28 <vavans> what i don't get is that IntMap is instance of Foldable IntMap
03:46:13 <Saizan_> vavans: the type of func is promising to be able to return any Foldable f that the caller wishes
03:46:18 <srhb> vavans: Regardless, the type of the return value is not Foldable f => f a, it is IntMap a.
03:46:39 <Saizan_> vavans: so func doesn't get to decide that f is actually IntMap
03:47:43 <vavans> i wanted to change IntMap for another datastructure at anytime without touching fonctions that do filter on this datastructure
03:48:17 <vavans> how can i achieve that
03:48:25 <ggVGc> you don't..
03:48:27 <vavans> maybe i need to use a more generic filter ?
03:49:03 <ggVGc> vavans: well, you could "import Prelude hiding (filter)" and then "import Data.IntMap(filter)"
03:49:06 <ggVGc> but that's not great
03:49:31 <vavans> filter only need a foldable structure to work on no ?
03:49:34 <ggVGc> I've also wanted a type class for "Maps"
03:49:38 <ggVGc> but I don't think there is one
03:49:43 <ggVGc> yeah, sure
03:49:56 <ggVGc> well..
03:49:57 <vavans> the type class for map is Traversable no ?
03:50:14 <ggVGc> depends on what of Map you use
03:50:22 <ggVGc> but there's a lot of duplication in the Map types
03:50:26 <ggVGc> that are not covered by a type class afaik
03:50:31 <vavans> okey
03:50:57 <vavans> as for zip
03:51:04 <vavans> there is no generic zip function
03:51:47 <srhb> vavans: fold is basically it.
03:51:51 <ggVGc> vavans: afaik, there is no generic filter, defined in terms of some type class
03:52:08 <vavans> ah yes fold yes
03:52:13 <ggVGc> data.list defines filter in terms of list
03:52:20 <ggVGc> IntMap.filter defines it in terms of IntMap etc.
03:52:24 <ggVGc> they are all concrete
03:52:30 <vavans> ggVGc:  yes :(
03:52:47 <vavans> ok, i'll stick to concrete types here so
03:52:50 <vavans> thant you
03:52:51 <srhb> Even if there were a "generic filter" (fold, again, probably) one would expect it to be f a -> f a
03:52:55 <ggVGc> vavans: but then you have things like filterWithKey, that could be generic over all Maps, but not over lists
03:52:59 <srhb> When you choose that one f is IntMap, the other is too
03:53:00 <ggVGc> but there is not type class for "Maps"
03:53:20 <srhb> Otherwise it's certainly something other than a filter.
03:53:21 * hackagebot optparse-text 0.1.1.0 - Data.Text helpers for optparse-applicative  https://hackage.haskell.org/package/optparse-text-0.1.1.0 (passy)
03:53:38 <srhb> Ie. the discussion about "generic" is really a red herring here.
03:53:48 <srhb> The supposed filtering typeclass does not solve the issue at hand.
03:55:21 <vavans> as a newbie it's strange to see extrem genericity most of the time, and default functions like map wich operates on concrete types only
03:55:53 <srhb> vavans: Understandable. It's been debated for many years. But that really isn't the issue you're having.
03:56:05 <ggVGc> vavans: when you think about it, it's not very often you could actually write a generic function mapping over a Map
03:56:09 <ggVGc> it ends up pretty concrete
03:56:43 <vavans> as i'm testing datastrctures, it's pretty convenient not to change all my tools fonctions
03:56:48 <vavans> when i'm testing a new one
03:57:49 <ggVGc> as srhb said, if you write things more in terms of fold, you get more genericness
03:57:54 <ggVGc> but it's not as nice obviously
03:57:58 <vavans> but i'll do the filtering with fold yes :)
03:59:17 <troydm> can I somehow cheat and convert IO a into a ?
03:59:31 <ggVGc> that makes no sense
03:59:47 <ggVGc> you don't "convert" moadic values into non-monadic ones
04:00:00 <ggVGc> troydm: what's your use case?
04:00:10 <ggVGc> you're proably thinking about somethign a bit wrong
04:00:23 <troydm> well I'm implemmenting FromJSON instance for my custom type 
04:00:28 <troydm> and some of the parsing needs IO 
04:00:56 <troydm> but since parseJSON method expects output Parser a 
04:01:11 <srhb> ggVGc: What's "monadic" about IO a that isn't "monadic" about Maybe a?
04:01:15 <vavans> srhb ggVGc, thanks guys
04:01:55 <ggVGc> srhb: what do you mean?
04:02:12 <srhb> ggVGc: That calling IO a "monadic" is nonsense.
04:02:14 <ggVGc> the way I think of it is that you have to execute the monadic value to get whatever it hold without the context
04:02:27 <srhb> ggVGc: Or at least misleading. :)
04:02:30 <ggVGc> okay, sorry
04:03:07 <ggVGc> troydm: try to identify what actually reall needs IO, and write functions in terms of the data you get within IO. Those functions will be pure, and not carry the IO context
04:03:20 <troydm> ahh I can use unsafePerformIO 
04:03:26 <srhb> troydm: No :-P
04:03:27 <ggVGc> troydm: so, you need to run the parser in IO, but the functions processing your data don't need to be IO
04:04:02 <srhb> troydm: Or you can, but you're going to be very surprised by the semantics of your program in a very short while. It's an enlightening experience for sure. :-P
04:04:04 <troydm> ggVGc: well the thing is I want some arbitary IO during parsing since it's using database as reference data
04:04:39 <ggVGc> troydm: if yuo start doing things like this, you basically shouldn't be using haskell. You're making your life hard, and missing the benefits of using a language like haskell
04:05:02 <troydm> ggVGc: I understand your point but there are some edge cases well
04:05:08 <ggVGc> troydm: can you paste some minimal code of what you're doing?
04:05:44 <maerwald> troydm: does the IO really have to happen _during_ parsing or can you just "prefetch" stuff from the DB?
04:06:01 <ggVGc> the only edge cases of this case I can think of is when you call some exteral functionality that you 100% know is actually pure, and hence want to tell haskell that "THis actually isn't IO"
04:06:02 <maerwald> then you could wrap the parser in another function that does both db query and then pure parsing
04:06:30 <troydm> ggVGc: too bothersome, imagine u have custom data type and u want to implement FromJSON instance for it using aeson, and during parseJSON u optionally need to access mongoDB for data normalization
04:06:56 <maerwald> troydm: do normalization afterwards?
04:07:05 <maerwald> as in: 2-step process
04:07:21 <troydm> maerwald: would have to introduce  unnecessary fields to my custom data type for it
04:07:37 <troydm> maerwald: which is extra complexity 
04:07:47 <ggVGc> troydm: this is the whole reason we use haskell. We do "bothersome" things because it makes us model our problems in better ways, and give us much more security in knowing which parts of our code are doing side effects
04:07:53 <ggVGc> we pay this price for greater benefits
04:08:03 <maerwald> ggVGc: meh
04:08:07 <ggVGc> well, I do
04:08:17 <maerwald> there are reasons where it's fine and reasonable to have a lot of IO
04:08:25 <troydm> hahaha I know all about Haskell fanboyism okey
04:08:26 <maerwald> we can't just always write "the perfect haskell code"
04:08:29 <ggVGc> maerwald: yes, but not faking "This is not IO" when it actually is
04:08:48 <maerwald> no one proposed that
04:08:51 <ggVGc> maerwald: sure, then I'd just stay in IO and live with it
04:08:55 <maerwald> yes
04:08:55 <ggVGc> but I wouldn't hide that it's in IO
04:09:16 <ggVGc> troydm: well, then the answer is unsaefPerformIO I guess
04:09:22 <troydm> yes
04:09:22 <ggVGc> but it's probably not gonna be great in the end
04:09:25 <maerwald> hm, I wonder if that's really true
04:09:31 <maerwald> is there not some sort of Parser monad transformer
04:09:32 <troydm> ggVGc: it'll work
04:09:34 <maerwald> which lets you add IO?
04:09:43 <troydm> ggVGc: most of the program will be typesafe
04:10:27 <ggVGc> troydm: for anyone reading your code, and for yourself in the future, unsafePerformIO means "I assure you, the compiler, this function is actrually pure and hence it is not actually IO"
04:10:32 <ggVGc> that's not the use case you use it for
04:10:50 <troydm> maerwald: aeson Parser type isn't http://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:Parser
04:11:13 <troydm> so u can't implement instance of FromJSON if you have IO 
04:11:31 <troydm> I know it's an edge case
04:11:40 <troydm> but real world problems tend to be complex sometimes
04:12:02 <maerwald> exactly, that's the annoying thing about haskell
04:12:21 <maerwald> you can't just add effects when you need them
04:12:24 <troydm> and introducing 2-step processing will make whole code 2x more complex than it should be
04:12:40 <troydm> which is not something I want to do if I want to remain sane
04:13:02 <srhb> You're really just pretending to remove complexity if you go the unsafePerformIO route here
04:13:04 <srhb> Which may be fine
04:13:07 <troydm> maerwald: esp when using libraries other ppl have written
04:13:10 <srhb> But the DB _might_ still be gone.
04:13:33 <srhb> Or it _might_ have values that change over time.
04:13:37 <troydm> srhb: I'm fine with getting parser error in that case
04:13:46 <srhb> That's not what you're going to get though.
04:13:55 <troydm> srhb: why not?
04:14:08 <srhb> troydm: Imagine you do a dblookup "foo" once
04:14:10 <ggVGc> probaly a crash?
04:14:13 <srhb> Then later, you do dblookup "foo" again
04:14:25 <maerwald> troydm: now I'm curios if I can write a reasonable parser API with extensible effects
04:14:33 <troydm> ggVGc: no, I have IO (Maybe a) to all my db routines
04:14:40 <ggVGc> maerwald: see you in a few months
04:14:42 <troydm> if db is down I get Nothing
04:14:46 <maerwald> ggVGc: heh
04:15:02 <troydm> which makes the parsing fail 
04:15:15 <srhb> troydm: The value might have changed between these two times. But since you've pretended to not do IO, you're not necessarily going to get the new value.
04:15:28 <ggVGc> maye I'm being dumb. Seems to me this is a scenario that is common enough that there is a way to do it that doesn't include using unsafePerformIO
04:15:29 <troydm> so I do typeMismatch error for parser
04:15:36 <maerwald> troydm: personally, I really would choose the 2-step process
04:15:48 <troydm> srhb: I'm fine with values changing since it's reference data from db that should change
04:15:58 <ggVGc> troydm: yeah, by telling the compiler "it's not IO" it might cache it, or optimize the whole thing away etc.
04:16:24 <maerwald> I've done that when I was visualizing algorithms too... e.g. ofc you don't want to draw stuff _during_ the algorithm, because that would just be awful. So I had to come up with data structures that express the result of the algorithm and then use that to visualize it in the next step.
04:16:46 <srhb> troydm: Try writing a simple program that "cheats" at getting the time with unsafePerformIO
04:16:49 <troydm> guys this is all hypothetical but I'm sure in real world sometimes you need to sacrifice clarity for better ease of development
04:17:15 <ggVGc> I don't think this is about clarity
04:17:19 <srhb> troydm: What we're saying is that you seem to be going down a path that makes your program _wrong_ -- not aesthetically unpleasing or unclear.
04:17:24 <ggVGc> I think it's downright incorrect usage of unsafePerformIO
04:17:31 <srhb> troydm: But I think at this point it's easier that you just try it out for yourself.
04:17:39 <srhb> troydm: We can explain it more clearly after you've seen the results. :)
04:17:44 <troydm> okey I get it I get it 
04:17:47 <maerwald> troydm: sure, but unsafePerformIO is more than just an "escape hatch", it's hard to reason about it and may not do what you think it does
04:17:56 <troydm> 2-step processing for better program 
04:18:09 <troydm> 1-step + unsafePerfomIO for me
04:18:28 <srhb> troydm: You should write a blog post about the process. ;-)
04:18:45 <Yuras> troydm: just don't use FromJSON, that is it
04:18:47 <troydm> srhb: ahh, maybe, sure :)
04:18:49 <Yuras> troydm: it is evil anyway
04:19:09 <troydm> Yuras: yeah well I'm thinking in that direction actually
04:19:38 <troydm> because if I get rid of it I won't have to use unsafePerfomIO
04:21:05 <ggVGc> troydm: if you do your unsafePerformIO thing this might happen(qutie likely at some point). You call dbGet "foo", db is down and you get Nothing. THen later you call dbGet "foo", database is up, but you still get Nothing, becayse haskell has cached the value, because you've told the compiler it isn't IO
04:21:10 <maerwald> wait
04:21:10 <ggVGc> is that correct?
04:21:26 <maerwald> https://hackage.haskell.org/package/parsec-3.1.1/docs/Text-Parsec-Prim.html#t:ParsecT
04:21:31 <maerwald> this _is_ a monad transformer
04:24:14 <troydm>  okey I got rid of FromJSON and now everything compiled and I'm not using unsafePerformIO 
04:24:19 <troydm> all is fine life is good
04:29:29 <maerwald> seems attoparsec is the only one that doesn't expose a transformer
04:30:22 <Yuras> maerwald: Parser in parseJSON has nothing to do with attoparsec
04:30:30 <maerwald> I know
04:31:05 <maerwald> I'm looking at parsing libraries like parsec, attoparsec, megaparsec only
04:31:34 <Yuras> maerwald: then, Parser in attoparsec is not a transformer for performance reasons
04:31:56 <maerwald> which makes it pretty limited
04:33:10 <Yuras> maerwald: not really, just less convenient in some cases
04:33:35 <maerwald> Yuras: sure it is more limited, because you simply cannot add _any_ effects.
04:33:56 <nmattia> does anyone know if it's safe to rsync .stack_work/ to a different machine?
04:35:45 <Yuras> maerwald: it is like saying that you can't add any effects to pure functions. yes, you can't, but it you can use it with any effects
04:36:09 <Yuras> maerwald: and attoparsec Parser is just a pure function: https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/src/Data-Attoparsec-Internal-Types.html#Parser
04:36:09 <nmattia> looks like a lot in .stack_work/ uses absolute paths, so probably not
04:37:39 <maerwald> Yuras: that doesn't make any sense. You cannot add any effects to attoparsec parser that are available _during_ parsing. That has nothing to do with purity. It's pure either way.
04:39:00 <maerwald> and that's not really a "minor limitation"
04:39:14 <maerwald> I can see that it might have been a performance choice though, although I'm not really sure about that.
04:42:12 <Yuras> maerwald: you can't add effect to parser, but you can use parse inside effectfull context
04:42:29 <maerwald> that's not the same as we just discovered
04:42:46 <Yuras> e.g. you can run parse, then perform an effect based on the result, then run parser again for the rest
04:42:54 <maerwald> yes, but it's not the same
04:43:51 <Yuras> the only limitation that is hard to workaround, it that you can't use parser continuation twice, and it is a result of impure internals of attoparsec
04:44:12 <Yuras> (and it is why it is fast)
04:44:39 <Yuras> so you it'd be hard to perform an effect and then backtrack
04:46:04 <maerwald> so, you want to log certain events during parsing which may include stuff that is _not_ part of the parsed result (consumed text), how would you do that with attoparsec?
04:47:18 <Yuras> "Note: if you get a Partial result, do not call its continuation more than once." here: http://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Internal-Types.html#v:Partial It is the reason for attoparsec Parser not being a transformer
04:47:48 <maerwald> or even simpler: you need IO during parsing (that's what the previous discussion was about), how do you add that functionality to attoparsec?
04:47:49 <Yuras> maerwald: just run parser, perform effect and run continuation.
04:48:00 <maerwald> Yuras: huh?
04:48:06 <maerwald> you cannot log stuff you have no knowledge about
04:48:07 <dramforever> Question: Is it safe to call fork(2) from a Haskell FFI call?
04:48:12 <Yuras> maerwald: you can't add it to parse, but you can use parser inside IO
04:48:21 <maerwald> Yuras: dude, it is not the same -.-
04:48:25 <maerwald> for the 3rd time
04:48:30 <Yuras> maerwald: it is the same :)
04:48:37 <maerwald> sorry, that's bs
04:48:51 <Yuras> (module continuation that you can't run multiple times)
04:49:10 <Yuras> as you wish
05:36:17 <Normen> At http://lpaste.net/168053 I've two implementations of `sequence_`. In both the accumulator is ignored. Well, in the first implementation not really ignored but untouched. Why does the second implementation (sequence_') not execute all actions as demonstrated in the GHCi session (also at http://lpaste.net/168053)?
05:44:03 <hpc> doing stack builds in a dropbox directory on windows is annoying
05:44:22 <hpc> windows has pretty garbage file locking to begin with, and then dropbox tries to snag every file as it's modified
05:44:29 <hpc> so stack can't strip executable build targets
05:44:30 <geekosaur> because an IO action can only happen if it is sequenced. you only sequence the first thing in the list; the rest are in `acc` and you ignore them instead of sequencing into them as with the first definition
05:44:59 <geekosaur> s/into them/with them/
05:45:21 <geekosaur> this is not the same "sequence" as the function, it's really >> or >>=
05:46:02 <hpc> perhaps a better verb there is "stepping through IO execution"?
05:46:06 <geekosaur> so I guess I should say "bind them" except that ends up sounding wrong since the point is to do them in order
05:46:18 <hpc> for what (>>=) does
05:46:33 <geekosaur> but they have to be reachable from main. when you ignore acc, you ensure that the actions in acc can never be reached from main
05:47:43 <troydm> how do I get Value without parsing it in aeson?
05:53:49 <geekosaur> that question does not make sense; you don't have a value unless you parse something to get it. perhaps you mean you want to not force it to be a particular type? in which case see http://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#g:3 and maybe  http://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#g:5
05:56:23 <obadz> is there an equivalent to BoundedChan but that drops older messages when queue gets full rather than newer ones?
06:14:08 <nmattia> obadz: I don't believe they're dropped, rather you block on it until you can write again
06:14:30 <nmattia> obadz: oh you mean something like tryWrite
06:14:33 <obadz> nmattia: with the try*write function, they're dropped
06:14:35 <obadz> yes
06:15:04 <nmattia> obadz: what about a priority queue?
06:15:12 <nmattia> there are a few packages
06:15:40 <nmattia> do you need it to be concurrent?
06:15:48 <obadz> isn't that a bit overkill? isn't there a simple concurrent queue that pushes old packets off when full?
06:15:51 <obadz> yes
06:16:10 <nmattia> well you could wrap a ring buffer in an MVar
06:16:26 <nmattia> but you lose the STM
06:16:43 <obadz> no STM in BoundedChans anyway
06:16:53 <obadz> or Chans for that matter
06:17:49 <nmattia> right, my bad
06:18:24 <obadz> I suppose this could work
06:18:58 <nmattia> it'll be a bit fiddly because you have to write in one direction and read in the other, making sure you're not reading elements that don't exist yet
06:19:20 <obadz> I suppose I could just put a Sequence in an MVar
06:20:33 <troydm> what's the easiest way to handle ctrl-c and just TERM signal in general?
06:21:01 <nmattia> troydm: UserInterrupt
06:21:17 <nmattia> you can catch it as you'd catch any other AsyncException
06:21:27 <nmattia> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#t:AsyncException
06:21:37 <nmattia> obadz: let me know if you find a nice way
06:21:55 <obadz> nmattia: I was hoping there would just be a Chan like interface :)
06:22:32 <nmattia> obadz: do you need to also implement `read` or just `tryRead`?
06:22:46 <nmattia> I believe `read` might be a bit of a pain
06:23:24 <obadz> both would be good if I could find a proper chan-like structure
06:23:33 <obadz> but I'll live with tryRead if I jerry rig it
06:24:51 <nmattia> obadz: btw I believe you mentioned the wrong haskell meetup in your binary-serialise-cbor PR :)
06:25:46 <obadz> correct :) will fix
06:31:34 <mettekou> In Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire the authors say they consider types as ω-complete partial orders. I assume the partial order they refer to is achieved through repeated application of constructors (~ introduction rules?) for a type?
06:32:27 <mettekou> E.g. given data IntList = Nil | Cons Int IntList: Nil < Cons ... Nil < Cons ... (Cons ... Nil) < ...?
06:38:26 * hackagebot hopenpgp-tools 0.19.1 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.19.1 (ClintAdams)
06:40:42 <Prutheus> Hello! I am working with CLASH (haskell vhdl compiler) and wrote this code: http://ix.io/XgW
06:41:36 <Prutheus> when I try to load this code in the CLASH interactive console, this works fine, but generating the vhdl code from it via »:vhdl«, i get this error:
06:42:05 <Prutheus> http://ix.io/XgX
06:42:10 <Prutheus> any ideas what went wrong?
06:43:22 <Boomerang> Prutheus: Try to ask on #clash-lang :)
06:44:53 <Prutheus> okay, thanks, didn't know this channel ^^
06:45:34 <Boomerang> Prutheus: But it looks like it's an error with recursion. If I recall correctly clash doesn't support recursive functions (recursion can only be used on values (registers) I think)
06:46:49 <Prutheus> Boomerang: i am new to clash and also no pro in haskell yet. so what exactly do you mean and how could i fix this? why is recursion not allowed?
06:50:10 <Boomerang> Recursion is not synthesisable as is (without having explicit loops in hardware). Recursion for function might be supported in the future but I am not too sure what it would mean in terms of hardware. I just glanced at your code, try to replace lists by Vecs and then you can use head, drop and take from the clash prelude. (I realise this isn't a recursion problem, more the fact that it's not a fixed length list, but the compi
06:50:10 <Boomerang> ler seem to think it's a recursion error...)
06:51:38 <Prutheus> sorry, I don't know Vec yet, could you gimme an example please?
06:51:42 <Boomerang> So [BitVector 3] becomes Vec 5 (BitVector 3)
06:51:58 <Boomerang> 5 because that's what you put in your ram_data
06:52:25 <Prutheus> okay, i am shortly afk, try it soon, y
06:52:27 <Prutheus> ty
06:59:28 <Prutheus> Boomerang: I have changed my code to following: http://ix.io/Xhe
07:00:14 <Prutheus> But getting an error (at loading the file, not at :vhdl only): http://ix.io/Xhf
07:00:17 <Prutheus> whuuut?
07:02:00 <Boomerang> Prutheus: instead of head . drop _ $ take _ you could use (!!)
07:03:22 <Boomerang> Prutheus: to create a Vec from a list the easiest way is to use the template haskell function v (provided as part of the clash prelude)
07:04:21 <Boomerang> Prutheus: ram_data = $(v [0b000, 0b011, 0b101, 0b110, 0b111 :: BitVector 3])
07:11:59 <dramforever> Hello
07:12:19 <Boomerang> Hello! :)
07:12:33 <Prutheus> Boomerang: thanks, worked, but where can I get more info about v ?
07:12:39 <Prutheus> (the function)
07:12:55 <dramforever> If a FFI import calls execl and on failure raises a signal to kill the process, is it safe to foreign import it as "unsafe"?
07:13:02 <Welkin> Prutheus: http://hackage.haskell.org/package/clash-prelude-0.10.9/docs/CLaSH-Sized-Vector.html#v:v
07:13:08 <Welkin> in the docs
07:13:22 <Boomerang> ^
07:13:34 <dramforever> I'm quite a bit worried about doing exotic linux calls from FFI, but I could be plain wrong
07:15:22 <obadz> http://man7.org/linux/man-pages/man7/netdevice.7.html specifies that ifr_flags should be a short (16bits) but then goes on to list 19 flags! how is that possible?
07:15:50 <Prutheus> ty Boomerang , you were perfect, byebye
07:16:00 <Boomerang> You're welcome :)
07:16:01 <dramforever> Use case: I'm trying to call another program, but with seccomp.
07:16:35 <dramforever> I assume that if I call forkProcess and then FFI into a C function, where I restrict the system calls, I won't accidentally mess up with the GHC runtime
07:17:01 <dramforever> (the GHC runtime does a lot of unusual system calls, as you know)
07:17:59 <dramforever> The docs say that only one thread is copied by forkProcess: http://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Process.html
07:34:10 <jophish> Is there a function in Text which takes a byte offset and converts it into a character offset for a given text?
07:35:52 <jmcarthur> dramforever: If you're only forking to run some C code then you may want to consider just forking from C to avoid issues with the Haskell RTS.
07:37:41 <jmcarthur> dramforever: Forking in any non-trivial multithreaded environment is usually pretty tricky to get right, and one tends to keep discovering bugs for a long time. :\
07:38:08 <liste> jophish: I don't think that makes sense for Text that abstracts away the encoding (UTF-8/UTF-16/etc)
07:38:29 <liste> for UTF8 bytestrings it might
07:38:39 <jmcarthur> To be clear, the problem I'm thinking this may solve is weird things like invoking the GC after forking or something. I have no idea how that is supposed to work.
07:46:20 <RedNifre> I only used interpreted code before, how do you compile Haskell code for your server? Currently, I compile it on the server itself, which is not ideal.
07:46:43 <RedNifre> My server uses OpenBSD and my desktop has Ubuntu.
07:47:13 <thoughtpolice> dramforever: You should almost never ever call a foreign function that does something like 'exec' as "unsafe", in any case. "unsafe" foreign calls can stall the productivity of your Haskell program, because the Haskell runtime can't GC until all "unsafe" calls have returned.
07:47:28 <RedNifre> Also, how "portable" are binaries? Which changes would require recompiling?
07:47:34 <idev> does the 'haskell school of music' stuff work on OSX?
07:47:35 <thoughtpolice> You can basically think of an unsafe call as one big "large instruction" that's inserted into the binary.
07:48:34 <Welkin> RedNifre: you compile locally and push the binary to the server
07:48:39 <Welkin> RedNifre: it is extremely simple, I do it all the time
07:48:48 <jmcarthur> Welkin: Doesn't work for RedNifre's case.
07:48:48 <thoughtpolice> RedNifre: You should compile on a system that is the same as your deployment target, i.e. run a copy of OpenBSD locally (in a VM or something or on another server) and ship it to the target. I don't know what you mean by 'portability', but in general GHC is going to behave like a regular elf executable.
07:48:59 <jmcarthur> Welkin: Entirely different OSes.
07:49:02 <Welkin> RedNifre: don't compile on your server, it's a waste of resources
07:49:04 <Welkin> that's okay
07:49:06 <thoughtpolice> That means it's going to have dynamic links to libc, to libgmp, etc.
07:49:07 <Welkin> compile it in a VM
07:49:46 <Welkin> plsu ghc need at least 1 GB of memory to compile the base libraries anyway
07:50:22 <thoughtpolice> RedNifre: So, roughly speaking, the answer is "it depends on the system you're using". On some Linux systems that are all statically linked like Alpine Linux, you can obviously just copy statically linked binaries anywhere, for example. So the answers here all depend on OpenBSD and how it behaves, really.
07:50:25 <Welkin> I either compile on my linux machine, or inside a linux VM on osx and push to the server
07:51:10 <Welkin> another option is to have a compile server that you run only when you need to compile changes, then use that to push to your production server
07:51:13 <RedNifre> Well, I know nothing about binaries or "regular elf binaries". By "portable" I meant "which changes require a different binary?" e.g. does a different processor require a recompile, or only the difference between 32 vs 64 bit? Does a new major version of the OS? Will the same binary work on all linux or only one distro or only one version of the distro?
07:52:34 <thoughtpolice> "It depends". A completely different processor? Yeah, obviously you must recompile. If you're just upgrading from like, an Intel processor to a new Intel processor? Probably not. A major new version of the OS? "It depends", because major OS upgrades may do things like push new, incompatible library versions.
07:52:58 <thoughtpolice> Will the same binary work on all Linux machines? It depends! If it's statically linked, then sure. If it's dynamically linked, it depends on a lot of factors, namely, compatible dynamic libraries.
07:53:46 <RedNifre> "statically linked" means all libraries are inside the executable, right? Is this the default with Haskell?
07:54:23 <thoughtpolice> Yes, it means there are no dynamic libraries needed. But this is not the default; it's also not something GHC can necessarily control, either.
07:54:36 <thoughtpolice> If you use Ubuntu for example, your Haskell applications will dynamically depend on libc.so, libgmp.so, etc
07:55:21 <thoughtpolice> On Alpine Linux, the *entire* system - all applications - are configured to be statically linked. Even GHC programs, and programs produced by GHC. But that's because that's a specific toolchain choice, enforced and configured by the distribution.
07:55:37 <thoughtpolice> So, if you use Alpine Linux, GHC will produce binaries that even have libc linked in.
07:56:36 <thoughtpolice> (I'll avoid all the really stupid technical details, but another point is that with 'glibc', static linking is effectively impossible. So yeah, this is really a choice that depends entirely on how the distribution has configured the compiler and system toolchain. Alpine Linux, etc does not use glibc)
07:57:26 <RedNifre> Okay, I'll see if I can create a virtualbox that is as similar to the home server as possible...
07:57:52 <maerwald> thoughtpolice: not the entire system, some things break when statically linked
07:57:55 <thoughtpolice> RedNifre: Right, that's your best bet. I imagine OpenBSD should work very well inside any regular virtual machine, so if you're familiar with it, probably shouldn't be difficult at all.
07:58:20 <thoughtpolice> maerwald: Ah, interesting.
07:58:23 <Welkin> RedNifre: no need, just use Vagrant and it will do it all for you
07:58:27 <RedNifre> Ah, I just remembered that OpenBSD was notorious for not working well with VMs. I hope that changed...
07:58:42 <Welkin> RedNifre: easier than messing with virtualbox directly and taking time to install a linux distro
07:58:55 <maerwald> in addition, some programs dlopen libs
07:58:57 <RedNifre> *install an OpenBSD distro.
07:58:59 <thoughtpolice> I think OpenBSD just doesn't have all the cool gadgets that some people care about, like virtio integration. Which means it works fine, it's just a bit slower.
07:59:04 <Welkin> RedNifre: you can run it headless and ssh into it like a server
07:59:33 <RedNifre> Thanks, I'll look into Vagrant.
07:59:35 <thoughtpolice> maerwald: Ah yeah, I guess there are some plugin based apps people want too.
08:00:22 <thoughtpolice> I'm guessing the overwhelming majority of things are static, though?
08:01:08 <maerwald> I don't really know what alpine does
08:01:22 <maerwald> I don't remember it having a static-only policy
08:01:29 <RedNifre> I'm just playing around with my amateur haskell program on my toy server, nothing serious (yet). How do professional setups look like? Do you have two identical servers, one for production and one for Jenkins that compiles it and puts it on the other server?
08:02:54 <liste> maerwald: alpine uses musl which is designed to be statically linkable
08:03:04 <liste> glibc isn't
08:03:09 <thoughtpolice> I might be thinking of something else, possibly.
08:03:32 <thoughtpolice> RedNifre: Yes, lots of people set up a pipeline like that for continuous deployment, obviously the specifics sort of depend on the application itself and what it needs. But yeah, that's the right idea.
08:03:49 <maerwald> liste: that doesn't mean they statically link everything
08:03:56 <maerwald> afais there are static versions of some packages
08:07:08 <maerwald> https://pkgs.alpinelinux.org/packages?name=*static&branch=&repo=&arch=&maintainer=
08:13:11 <maerwald> and I just checked a few random programs, they are dynamically linked
08:14:03 <Ohso_> Is there a way to make a module span multiple source files (for organization purposes)?
08:14:14 <liste> maerwald: but that doesn't mean that you can't statically link the libraries if you want to, right?
08:14:30 <liste> Ohso_: re-exports
08:14:32 <maerwald> liste: the .apk files are usually dynamically linked
08:14:57 <maerwald> unless you want to use alpine as a source distro (which I don't recommend)
08:15:26 <liste> I mean using Alpine for building statically linked binaries to be deployed somewhere else
08:16:19 <maerwald> the question is if they always provide static libs
08:17:10 <maerwald> which doesn't seem to be the case
08:17:32 <maerwald> http://dl-cdn.alpinelinux.org/alpine/v3.3/main/x86_64/ffmpeg-libs-2.8.5-r0.apk download and check for '*.a' files
08:18:24 <maerwald> (it's a plain tar archive)
08:19:48 <Ohso_> I think I am going to give up on my project. I just don't seem to have the right mindset for Haskell. I really like the strong type safety and lack of side-effects, but the type system just seems more and more like a straight-jacket everytime I try to make something extensible.
08:19:51 <maerwald> you're probably better off using a real source distro if you want to do such things
08:20:58 <maerwald> Ohso_: indeed, did you read on extensible effects? They are not really popular, but I find it promising
08:21:40 <maerwald> http://okmij.org/ftp/Haskell/extensible/
08:21:55 <maerwald> packages that implement it are 'freer' and 'extensible-effects'
08:23:46 <maerwald> http://okmij.org/ftp/Haskell/extensible/more.pdf
08:25:53 <Ohso_> maerwald: I just skimmed a bit of that. I don't understand a lot of it, but open unions sounds like it might be useful to me.
08:26:57 <maerwald> afais the idea is that you can add effects without all your types suddenly breaking and without requiring a whole API refactoring just because
08:27:07 <maerwald> which is the reason for the Eff Monad
08:27:57 <Ohso_> I've been trying to write a z-machine bytecode interpreter, but handling the various versions of the machine in a clean and extensible way seems impossible (to my admittedly limited experience with haskell)
08:28:48 <maerwald> also note how it is more efficient than MTL
08:30:03 <jmcarthur> It's only more efficient than MTL for huge stacks, iirc.
08:30:57 <maerwald> jmcarthur: you're probably talking about old ee, not about freer
08:30:57 <jmcarthur> And I believe the reason is just that GHC isn't really aggressive enough with MTL for whatever reason. Eff is structured in such a way that optimizations are just not as necessary for "reasonable" performance.
08:31:03 <jmcarthur> I am talking about freer.
08:31:11 <jmcarthur> I understand how it works.
08:31:36 <maerwald> page 7-8 suggest it is consequently more efficient
08:32:58 <jmcarthur> maerwald: If you add a SPECIALIZE pragma here and there, transformers gain a lot.
08:33:36 <maerwald> then make another benchmark
08:41:48 <hsk3> What module should I use if I want to download a file from a URL and act on the received file bytes in chunks, e.g., 32 bytes at a time?
08:42:06 <hsk3> (Use case: verify hash on the chunks as they come in.)
08:43:49 <myfreeweb> hsk3: http-conduit I guess
08:44:37 <hsk3> holy moly
08:44:44 <hsk3> that could work
08:46:22 <hsk3> hmm
08:46:39 <hsk3> not sure how i'd process the received data in 32-byte chunks
08:47:47 <Welkin> can't you take ByteString n bytes at a time
08:48:27 <Welkin> :t Data.ByteString.take
08:48:28 <lambdabot> Int -> Data.ByteString.Char8.ByteString -> Data.ByteString.Char8.ByteString
08:48:41 <coppro> there should be a conduit combinator for that
08:48:45 <myfreeweb> https://stackoverflow.com/q/25428065
08:48:51 <coppro> although if you're trying to do this
08:48:56 <coppro> it sounds like HTTP may not be the protocol for you
08:53:02 <hsk3> Welkin: If I write a pure function like this:   ByteString -> Bool   (outputs true if hashing succeeded and false if hashing failed)    and I plug the downloaded data into this function, will Haskell's laziness magically make sure that
08:53:02 <hsk3> * it won't download more data than necessary (if hash checks fail early on in the large file)
08:53:03 <hsk3> * it will keep memory usage limited.
08:53:04 <hsk3> ?
08:53:30 * hackagebot tzdata 0.1.20160614.0 - Time zone database (as files and as a module)  https://hackage.haskell.org/package/tzdata-0.1.20160614.0 (MihalyBarasz)
08:55:47 <myfreeweb> you can do it with Lazy ByteStrings, but lazy I/O kinda sucks
08:55:56 <Welkin> just use conduit or pipes
08:55:58 <myfreeweb> conduit gives you deterministic resource handling
09:03:30 * hackagebot shelly 1.6.8 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.8 (GregWeber)
09:03:59 <hsk3> Welkin: which do you prefer? conduits vs pipes
09:05:14 <dramforever> Oh my god
09:05:20 <saurabhnanda> erikR: are you around?
09:05:24 <dramforever> I accidentally wrote Monad instead of Mode
09:05:40 * dramforever feels that he needs to stop writing Haskell for a while </joke>
09:07:04 <saurabhnanda> hi, can anyone help me with http://stackoverflow.com/questions/38035534/how-to-build-a-custom-reader-monad-along-with-a-custom-typeclass/38036014 ?
09:08:11 <saurabhnanda> how do I "extend" a monad to also behave like a reader, WITHOUT using a ReaderT?
09:08:29 <hpc> write an instance of MonadReader
09:09:32 <saurabhnanda> hpc: this one? https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html
09:10:05 <saurabhnanda> In "class Monad m => MonadReader r m | m -> r where" what happens if "| m ->r" is omitted?
09:10:21 <hpc> you lose the ability to infer r from m
09:10:28 <nmattia> saurabhnanda: it means you can only define one r for m
09:11:21 <saurabhnanda> what does that exactly mean?
09:11:37 <saurabhnanda> type Reader r = ReaderT r Identity
09:11:58 <saurabhnanda> here m = Identity. Infer one 'r' for 'm' would mean what, exactly here?
09:11:58 <nmattia> that means that GHC won't allow you to define MonadReader Double MyMonad if you have already defined MonadReader Int MyMonad
09:12:15 <saurabhnanda> hmm, across the app or inside a single module?
09:13:14 <nmattia> someone smarter might have to correct me, but I'd say whenever your instance for MonadReader Double MyMonad is imported (in "scope") you won't be able to define MonadReader Int MyMonad
09:14:11 <saurabhnanda> I"m missing some intuition here. How exactly does 'ask' work without an params?
09:14:24 <nmattia> what hpc meant is that if you know that there is only one instance of MonadReader x MyMonad for MyMonad, and that there is an instance MonadReader Double MyMonad, whenever you use MyMonad you can infer that ask will give you a Double
09:14:25 <saurabhnanda> *any params
09:14:40 <nmattia> it actually doesn't, so to speak
09:14:46 <nmattia> wait, what do you mean?
09:14:51 <nmattia> param that would do what?
09:15:28 <saurabhnanda> as in, how does it just "generate" the environment
09:15:44 <saurabhnanda> it needs something input to generate the environment from
09:15:59 <nmattia> the same way you're not passing the current time to getCurrentTime when you're asking for the time
09:16:39 <saurabhnanda> royally condused
09:16:39 <nmattia> you won't be able to call "ask" unless you're current code is contained in a "runReaderT" call
09:16:48 <saurabhnanda> *confused
09:16:50 <nmattia> it's quite alright
09:17:11 <saurabhnanda> so Monad is basically a bunch of function calls and laws that a type, and therefore values of that type, need to satisf
09:17:14 <saurabhnanda> *satisfy
09:17:41 <nitrix> Not quite.
09:17:48 <saurabhnanda> nitrix: please explain.
09:17:50 <nmattia> rather a bunch of functions that must be implemented for a type
09:18:03 <nmattia> and laws that *should* be staisfied
09:18:07 <saurabhnanda> nmattia: right
09:18:21 <nitrix> You're right about the laws, there are rules that determines what is and isn't a valid monad, but the "bunch of function" and "type" part is what typeclasses do.
09:18:29 <saurabhnanda> nmattia: now, for function to be implemented for a type, USUALLY a value of that type should be an input to the function, right?
09:18:30 * hackagebot secp256k1 0.4.6 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-0.4.6 (xenog)
09:18:43 <nmattia> not exactly
09:18:44 <saurabhnanda> a type cannot maintain internal state. It's not an OOPs class/object.
09:18:53 <nmattia> that's the trick
09:18:57 <dramforever> jmcarthur, thoughtpolice: Thanks for those advice :P
09:19:09 <dramforever> (Just saw them)
09:19:25 <nmattia> have you tried writing a monad instance for Maybe?
09:19:27 <nitrix> saurabhnanda: It's not the type that is maintaining it, it's the operations on the type that allows the implicit chaining to occur.
09:19:30 <saurabhnanda> nmattia: what's the trick?
09:19:48 <saurabhnanda> nmattia: it seemed straightforward, so didn't write by-hand.
09:20:04 <nmattia> well that might be interesting to do
09:20:35 <nitrix> Implement (>>=) for the instance Monad Maybe, you'll see the chaining in action :)
09:21:11 <saurabhnanda> hang on
09:21:14 <saurabhnanda> doing on lpaste
09:21:27 <saurabhnanda> right from functor, applicative onwards?
09:21:35 <nmattia> nope, derive those
09:21:45 <nmattia> you can if you really have time
09:21:56 <dramforever> derive Applicative?
09:22:06 <nmattia> is that not a thing?
09:22:11 <dramforever> Oh did you mean (<*>)=ap, pure=return?
09:22:15 <nmattia> I don't think I've ever written one
09:22:52 <nitrix> GHC cannot currently derive applicatives.
09:22:58 <nmattia> I'm confused all of a sudden
09:23:05 <nmattia> oh my bad
09:23:22 <nmattia> yeah, <*>=ap  and pure = return
09:23:56 <nitrix> The "deriving" you might have experienced is for newtypes and the extension GeneralizedNewtypeDeriving, but you still need a base instance.
09:24:02 <nmattia> yeah indeed
09:24:06 <saurabhnanda> i can use pattern matching to destructure a Maybe. Is that allowed?
09:24:14 <nmattia> it sure is
09:24:20 <dramforever> Hmm...I'm still a bit confused
09:24:45 <saurabhnanda> what about this? http://lpaste.net/168083
09:24:54 <nmattia> dramforever: if I'm correct what nitrix means is that you can GeneralizeNewtypeDerive your newtype wrapper
09:25:03 <Iceland_jack> saurabhnanda: You need parens around >>=
09:25:14 <dramforever> If I call forkProcess, in what cases I will get into trouble?
09:25:25 <nmattia> dramforever: and so if the wrapped "thing" is an applicative, then you're good
09:25:26 <saurabhnanda> Iceland_jack: ignore the syntax please. Just for understanding the concept. I didn't compile it.
09:25:30 <dramforever> "forkProcess comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent."
09:25:34 <Iceland_jack>     (>>=) :: MyMaybe a -> (a -> MyMaybe b) -> MyMaybe b
09:25:34 <Iceland_jack>     Nothing >>= _ = Nothing
09:25:35 <Iceland_jack>     Just x  >>= f = f x
09:25:35 <dramforever> What is a shared resource?
09:25:39 <Iceland_jack> saurabhnanda: then yes
09:25:58 <dramforever> saurabhnanda: You don't need line 2 at all
09:26:13 <saurabhnanda> nmattia: nitrix: that exercise didn't seem to help
09:26:15 <dramforever> but yeah, it's more clear
09:26:20 <nitrix> saurabhnanda: I'll explain. Notice how the Maybe monad has a very specific behavior.
09:26:24 <Iceland_jack> dramforever: I strongly recommend line 2 :) go InstanceSigs!
09:26:41 <nmattia> saurabhnanda: ask yourself how you can call 'maybe' and use an 'a' in the function you pass it
09:26:41 <dramforever> :)
09:26:54 <nmattia> (without ever passing an 'a')
09:27:00 <nitrix> saurabhnanda: It short-circuits on Nothing, but allows to apply more transformation where the monadic value is a Just.
09:28:10 <nitrix> do { x <- Just 5; y <- Nothing; return $ x + y }
09:28:20 <dramforever> Clearly forking is a difficult bussiness :P
09:29:03 <saurabhnanda> nmattia: still don't understand how this leads to the problem I have with 'ask'
09:29:18 <saurabhnanda> the input is clearly there
09:29:22 <nmattia> well with 'ask' it's kind of the same
09:29:28 <saurabhnanda> Maybe a >>= (\a -> Maybe b)
09:29:44 <saurabhnanda> there's a *right* there. Before the bind operation
09:29:54 <nmattia> nope
09:29:56 <nmattia> there's Maybe a
09:30:11 <dramforever> In (Maybe a) a is not the value
09:30:14 <nmattia> what would it look like with 'ask'?
09:30:35 <saurabhnanda> where can I read the source code of 'ask'?
09:30:44 <nitrix> saurabhnanda: That is, Maybe encodes the potential existance of the value.
09:30:56 <nmattia> sorry, what would the signature of (>>=) look like for a Reader?
09:30:59 <nitrix> saurabhnanda: ReaderT hides and implicitly lets you manipulate an environment.
09:31:29 <saurabhnanda> nmattia: is that for me?
09:31:33 <nmattia> yes, sorry
09:31:39 <saurabhnanda> okay let me type it out on lpaste
09:31:49 <nmattia> saurabhnanda: just the signature
09:32:02 <saurabhnanda> nmattia: for Reader or ReaderT?
09:32:03 <nmattia> saurabhnanda: so the types involved in (>>=)
09:32:13 <nmattia> saurabhnanda: well let's start with Reader
09:32:15 <nitrix> saurabhnanda: Start with Reader.
09:32:22 <RedNifre> Sorry, I haven't been following the discussion, what's the question?
09:32:45 <saurabhnanda> RedNifre: http://stackoverflow.com/questions/38035534/how-to-build-a-custom-reader-monad-along-with-a-custom-typeclass/38036014
09:33:13 <nitrix> (>>=) :: Reader r -> (r -> Reader r2) -> Reader r2
09:33:20 <saurabhnanda> (>>=) :: Reader r -> (r -> Reader b) -> Reader b
09:33:22 <nmattia> RedNifre: how come you can use ask :: Reader a, and it will return some value without you passing an argument to it
09:33:49 <nitrix> saurabhnanda: Do you see how each monadic action have type (r -> Reader b) ?
09:34:00 <saurabhnanda> ah
09:34:01 <saurabhnanda> aaah
09:34:04 <nmattia> saurabhnanda: so : (Reader a >>= (\a -> Reader a))
09:34:04 <saurabhnanda> aaaaaaaah
09:34:14 <saurabhnanda> ask is never used in a let
09:34:16 <saurabhnanda> right
09:34:22 <saurabhnanda> it's ALWAYS used in a monadic bind
09:34:24 <saurabhnanda> is that it?
09:34:27 <nmattia> yup
09:34:28 <EvanR> huh this is weird
09:34:30 <saurabhnanda> r <- ask
09:34:30 <nitrix> saurabhnanda: They receive the environment `r` and returns another reader, to which you can ask for even more things.
09:34:41 <RedNifre> nmattia what's the problem with ask :: Reader a?
09:34:45 <EvanR> (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b
09:34:47 <saurabhnanda> hi EvanR I was looking for you earlier
09:34:52 <nmattia> I don't think there's a problem anymore :p
09:35:10 <saurabhnanda> so that is actually.... 
09:35:13 <saurabhnanda> no, hang on
09:35:19 <saurabhnanda> still back to square 1
09:35:26 <nitrix> EvanR: Err, you're right.
09:35:29 <nmattia> saurabhnanda: it's alright, it'll happen a few times
09:35:34 <saurabhnanda> ask >>= (\r -> Reader b)
09:35:38 <nitrix> Reader r has kind :: * -> *, my bad.
09:35:46 <EvanR> ask :: Reader r r
09:36:07 <saurabhnanda> how is ask "holding" any value?
09:36:11 <EvanR> its not
09:36:13 <nitrix> saurabhnanda: It isn't,
09:36:26 <nmattia> it's not holding anything, it's passed to it from the previous function (the left side of >>=)
09:36:54 <nmattia> what the type of ask say is "I return a value of type 'MyReader a', so be prepared to receive it"
09:36:56 <EvanR> saurabhnanda: chaining a bunch of Reader r a together just setups up a huge function which you can pass an r to
09:37:01 <saurabhnanda> nmattia: the left side itself is ask
09:37:55 <nmattia> saurabhnanda: potentially, or anything that has type 'MyReader a'
09:37:58 <saurabhnanda> EvanR: right, that I can understand. Because in the end, everything is put in a runReaderT and over there I can easily spot the environment. I'm confused about how deep within the function stack can 'ask' get hold of the environment
09:38:19 <RedNifre> saurabhnanda what do you know about Maybe and would you ask how IO String is "holding" a value?
09:38:20 <EvanR> saurabhnanda: well thats a issue of implementing >>=
09:38:26 <nmattia> saurabhnanda: at the very top you have a 'runReader' which feeds this whole chain with your value of type 'a'
09:38:46 <nmattia> RedNifre: you just missed the Maybe implementation
09:39:31 <EvanR> saurabhnanda: start with Reader r a = r -> a, then make fmap, return, ask work, then do >>=
09:39:33 <RedNifre> I'm asking because not all monads work the same: A Maybe truly "holds" a value inside (or not), while an IO does not.
09:39:36 <nitrix> saurabhnanda: With do notation, you're just conveniently having a syntax sugar build a chain (>>=) of such monadic values of type `Reader r`. At the very end, you need runReader / runReaderT to feed the left-most value to this chain.
09:41:10 <EvanR> left most? top most? outer most?
09:41:13 <EvanR> only most
09:41:14 <lpsmith> Hmm, is there any data regarding which versions of GHC people are using these days?
09:42:14 <saurabhnanda> what's the closest that I can get runReader and ask? is there a single line of code to demonstrate how they're linked?
09:42:14 <nitrix> saurabhnanda: Maybe it helps to think of the Reader monad as a way to chain functions to which an argument is passed implicitly?
09:42:38 <EvanR> saurabhnanda: did you see my exercise above
09:42:48 <EvanR> runReader would just be passing the r to the r -> a
09:42:53 <EvanR> now implement the other stuff
09:43:14 <saurabhnanda> nitrix: I understand that intuition, and can get stuff to work if I use it mechanically. But in the SO question, I tried building on that intuition and understanding, and got royally stuck. Pointing to a flaw in my understanding. Therefore I'm revisiting everything.
09:43:29 <saurabhnanda> EvanR: sorry, missed that.
09:43:38 <nitrix> > runReader (do { x <- ask; return $ 2 + x }) 5
09:43:40 <lambdabot>  7
09:44:18 <Welkin> is there a good resource on mutable vectors and what PrimState and PrimMonad are?
09:44:26 <EvanR> saurabhnanda: implementing Reader this way is pretty good for getting how to make Writer, State, and transformers work
09:44:49 <EvanR> Welkin: its either IO or ST
09:44:53 <saurabhnanda> EvanR: this? start with Reader r a = r -> a, then make fmap, return, ask work, then do >>=
09:44:57 <Welkin> I know it runs in ST or IO
09:45:06 <EvanR> saurabhnanda: yes
09:45:09 <nitrix> > runReader (return (2+)) 5
09:45:11 <lambdabot>  <Integer -> Integer>
09:45:19 <saurabhnanda> okay, let me get to lpaste and try to implement Reader myself.
09:45:25 <nitrix> Whoops ._.
09:45:33 <EvanR> saurabhnanda: keep the types in mind... itll help
09:46:26 <nitrix> Interesting, I just built const accidently.
09:46:31 <Prutheus> Hi. How can I create a »Vec 256 Int« with all the same elements, so 256 times 0?
09:47:13 <saurabhnanda> EvanR: can I use pattern matching to de-structure the Reader?
09:47:23 <EvanR> saurabhnanda: no since its a function
09:47:31 <Prutheus> Or how to do that with a list?
09:47:31 <EvanR> in real life you have a newtype so yes
09:47:50 <saurabhnanda> EvanR: can you help me with the data/newtype of Reader?
09:48:09 <EvanR> the exercise i gave you just takes Reader r a to be a synonym for r -> a
09:48:12 <EvanR> worry about newtypes later
09:48:30 <EvanR> it doesnt change the mechanism at all, just proves more type safety
09:48:38 <saurabhnanda> okay
09:48:38 <EvanR> provides
09:49:01 <saurabhnanda> is this type correct? fmap :: (a -> b) -> MyReader r a -> MyReader r b
09:49:02 <EvanR> the other classic monads have similar synonyms
09:49:12 <EvanR> yes
09:49:55 <nitrix> fmap (+1) (do { x <- ask; return $ 2 + x })
09:50:44 <saurabhnanda> i seem to be stuck with fmap itself!
09:50:52 <EvanR> think really hard!
09:50:57 <saurabhnanda> how do I get access to the 'r' and 'a' if I don't know the constructor
09:51:00 <EvanR> its a function that takes two args
09:51:10 <EvanR> both are functions
09:51:25 <Prutheus> [0..256] would create a list with 256 elements, but they are not all 0, so how to make them all to 0?
09:51:33 <EvanR> > replicate 256 0
09:51:34 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:51:47 <saurabhnanda> what if I change the type to -- fmap :: (a -> b) -> (r -> a) -> (r -> b)
09:51:52 <EvanR> thats fine
09:52:09 <Iceland_jack> saurabhnanda: There you go
09:52:24 <benzrf> saurabhnanda: that's exactly the type you're *supposed* to write :)
09:52:50 <benzrf>  = r -> a
09:52:57 <benzrf> er, MyReader r a = r -> a
09:53:45 <Welkin> wow this is not working for me
09:53:46 <Welkin> haha
09:53:49 <saurabhnanda> I'll have to use a point-free form. Because I don't have 'r' yet
09:53:59 <Iceland_jack> saurabhnanda: Unsolicited advice, I write it first as a *regular* function with a type synonym like benzrf listed
09:53:59 <Iceland_jack>     type READER = (->)
09:53:59 <Iceland_jack>     myFmap :: (a -> b) -> READER r a -> READER r b
09:53:59 <Iceland_jack> and then you see the essence
09:53:59 <Welkin> I am getting all kinds of weird shit trying to use mutable vectors
09:54:11 <EvanR> saurabhnanda: if you want, you can introduce an r like this \r ->
09:54:15 <Welkin> an extra element added from nowhere that looks like a number wrapped around?
09:54:20 <EvanR> or you can use point free
09:54:32 <nitrix> saurabhnanda: The "I don't have `r` yet" is the whole point of the reader monad.
09:54:36 <EvanR> theres a few ways to write it
09:55:02 <saurabhnanda> http://lpaste.net/168083
09:55:18 <Iceland_jack>     fmap f rdr = f . rdr
09:55:18 <Iceland_jack> :) nice
09:55:18 <EvanR> sweet
09:55:47 <Iceland_jack> @pl fmap f rdr = f . rdr
09:55:47 <lambdabot> fmap = (.)
09:56:01 <Iceland_jack> Would you look at that
09:56:32 <saurabhnanda> now what would be the type sign of return?
09:56:41 <EvanR> :t return
09:56:42 <lambdabot> Monad m => a -> m a
09:56:49 <saurabhnanda>   return :: a -> (r -> a)
09:56:49 <saurabhnanda> ?
09:56:52 <Iceland_jack> saurabhnanda: Replace "m" with "Reader r"
09:56:54 <EvanR> m = (r ->)
09:56:54 <Iceland_jack> exactly
09:56:56 <nitrix> saurabhnanda: Return will give you a partially applied function.
09:57:07 <Iceland_jack> :t return :: a -> (r -> a)
09:57:08 <lambdabot> a -> r -> a
09:57:23 <EvanR> saurabhnanda: the next two are actually really easy...
09:57:32 <saurabhnanda> what does 'return' even mean in this context?
09:57:42 <EvanR> it doesnt matter
09:57:47 <EvanR> just fill in the function
09:57:55 <EvanR> a -> r -> a
09:58:01 <Iceland_jack> hard truths
09:58:01 <saurabhnanda> nothing functional right. Because I alraedy have an 'a' which is fine and dandy, making it depend on 'r' is just to make composition easier, right?
09:58:03 <EvanR> you dont have many options
09:58:38 <EvanR> return takes a value, and creates a Reader r which always returns that value no matter what
09:58:52 <EvanR> and r can be anything
09:58:53 <saurabhnanda> i don't know 'r' yet
09:59:05 <Iceland_jack> saurabhnanda: Exactly, so 'return' must ignore it
09:59:05 <EvanR> well you can use \r -> like i suggested earlier to get one
09:59:27 <saurabhnanda> :t id
09:59:28 <troydm> suggest good thread pooling package
09:59:28 <lambdabot> a -> a
09:59:38 <nitrix> :t const
09:59:40 <lambdabot> a -> b -> a
09:59:52 <Welkin> what is the best way to use mutable vectors?
09:59:52 <EvanR> > const 'x' [1,2,3]
09:59:53 <lambdabot>  'x'
10:00:01 <EvanR> Welkin: look for IOVector
10:00:10 <saurabhnanda> this doesn't seem right, but : return x = (\_ -> x)
10:00:13 <Welkin> work mainly in Vector and thaw/freeze when necessary?
10:00:16 <EvanR> saurabhnanda: that is right
10:00:22 <saurabhnanda> what's the point
10:00:30 <EvanR> its pretty important
10:00:47 <saurabhnanda> ask :: (r -> a)
10:00:53 <saurabhnanda> on to this one now
10:01:03 <EvanR> that sig doesnt look right
10:01:16 <EvanR> ask :: Reader r r
10:01:27 <EvanR> its a reader action that returns the environment
10:01:30 <nitrix> saurabhnanda: `return` lets you create a context that can be combined with other contexts that reads the environment, but this one specifically isn't influence by it.
10:01:46 <Boomerang> :t pure
10:01:48 <lambdabot> Applicative f => a -> f a
10:01:50 <saurabhnanda> ah
10:02:00 <saurabhnanda> its a reader action that returns the environment
10:02:10 <saurabhnanda> ask :: (r -> r)
10:02:17 <EvanR> not many choices for that one either
10:02:19 <nitrix> saurabhnanda: Because they all have the same form (->), aka Reader, you'll be able to chain them.
10:02:25 <troydm> people is there a point of doing resource pooling at all? 
10:02:33 <troydm> by resource I mean
10:02:36 <troydm> thread pooling
10:02:40 <EvanR> ghc green threads?
10:02:42 <saurabhnanda> :t id
10:02:43 <lambdabot> a -> a
10:02:44 <EvanR> make as many as you want
10:02:49 <saurabhnanda> ask = id
10:02:52 <saurabhnanda> is that it?
10:02:54 <troydm> I'm just wondering if i should thread pool or not
10:02:54 <EvanR> yeah
10:03:06 <EvanR> no, this isnt java
10:03:34 <Welkin> lol
10:04:01 <nitrix> saurabhnanda: Correct.
10:04:06 <EvanR> you may want a database connection pool though, if your database cant handle a lot of connections
10:04:09 <nmattia> troydm: maybe if you're abusing forkOS...
10:04:09 <saurabhnanda> (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
10:04:23 <nitrix> saurabhnanda: type Reader r = ReaderT r Data.Functor.Identity.Identity :: * -> *
10:04:41 <EvanR> saurabhnanda: yeah, that is the last one to implement, and is what do notation will translate to, so... 
10:04:42 <nitrix> saurabhnanda: Later you'll discover that this is because of the Identity monad, Reader is a simpler version of ReaderT.
10:04:51 <nitrix> saurabhnanda: But ignore that for now :P
10:04:55 <EvanR> please ignore that
10:05:29 <EvanR> ReaderT is an unenlightening monstrous version of Reader ;)
10:05:44 <nitrix> Slightly more practical though.
10:05:49 <EvanR> yeah
10:06:02 <EvanR> ReaderT is one of the most useful transformers 
10:06:09 <nitrix> He's doing so good o:
10:06:18 <saurabhnanda> ReaderT is the one I hate the most, for now.
10:06:33 <nitrix> saurabhnanda: Baby steps c:
10:06:36 <EvanR> saurabhnanda: also implement runReader for good measure
10:06:46 <EvanR> but >>= first
10:07:22 <saurabhnanda> I might end up using point-free for >>= because I don't have 'r' yet. Or I could us a lambda
10:07:31 <EvanR> you do have r
10:07:36 <EvanR> you always had it
10:07:37 <saurabhnanda> because finally I need to return a one argument function
10:07:39 <EvanR> if you open a lambda
10:08:22 <nitrix> saurabhnanda: \r -> ...
10:08:26 <EvanR> you also dont need a lambda, since
10:08:33 <EvanR> f x y = \z ->
10:08:34 <EvanR> is the same as
10:08:37 <EvanR> f x y z = 
10:08:59 <saurabhnanda> currying?
10:09:10 <EvanR> hell if i know what its called ;)
10:09:21 <nitrix> I know the term! :D
10:09:39 <EvanR> functions defined with equations will be translated into lambdas
10:09:55 <EvanR> f = \x -> \y -> \z ->
10:10:03 <EvanR> i just did it backwards
10:10:41 <nitrix> saurabhnanda: Currying is `curry` and `uncurry`. This one is called extensionality.
10:10:47 <saurabhnanda> ah okay
10:11:01 <EvanR> its the meaning of the function definition syntax
10:11:46 <saurabhnanda> Neither of these seem right
10:11:50 <saurabhnanda> (>>=) rdr f = rdr . f
10:11:51 <EvanR> knowing that when youre trying to return a function, that you do have access to that argument is probably a more important lesson here than monads
10:11:52 <saurabhnanda> (>>=) rdr f = (\r -> f $ rdr r)
10:11:58 <EvanR> saurabhnanda: ^
10:12:34 <EvanR> that works
10:12:43 <saurabhnanda> which one?
10:12:54 <nitrix> EvanR: This is more for you since you asked for the term. Extensionality is preserving the external property of a function, as opposed to intensionality, which is concerned about the internal definition.
10:12:59 <monochrom> types can rule out one of them
10:13:28 <saurabhnanda> monochrom: is that for me?
10:13:31 <monochrom> yes
10:13:36 <sidraval> i3lock
10:13:39 <saurabhnanda> the lambda one seems incorrect based on types to me
10:13:50 <saurabhnanda> the return type is actually r -> (r -> b)
10:14:01 <EvanR> it is?
10:14:04 <monochrom> is that true?
10:14:10 <saurabhnanda> the type of the lambda is -- (r -> (r -> b))
10:14:18 <monochrom> @type \rdr f -> (\r -> f $ rdr r)
10:14:19 <lambdabot> (r1 -> r2) -> (r2 -> r) -> r1 -> r
10:14:51 <monochrom> ok I see, both are wrong
10:14:55 <saurabhnanda> :t (\r -> f $ rdr r)
10:14:57 <lambdabot> Not in scope: ‘rdr’
10:15:02 <EvanR> true
10:15:14 <EvanR> back to the drawing board
10:15:19 <nitrix> Where is he at? >>= ?
10:15:22 <saurabhnanda> both, are wrong, is it?
10:15:25 <Iceland_jack> ghci> :t (>>=) @((->) _)
10:15:25 <Iceland_jack> (>>=) @((->) _) :: (t -> a) -> (a -> t -> b) -> t -> b
10:15:25 <EvanR> yeah
10:15:27 <monochrom> yes and yes
10:15:45 <Iceland_jack> ghci> :t return @((->) _)
10:15:45 <Iceland_jack> return @((->) _) :: a -> t -> a
10:15:45 <Iceland_jack> tec.
10:15:48 <Iceland_jack> *Etc
10:15:53 <saurabhnanda> 'r' is not available to me. How do I think about it?
10:15:59 <EvanR> it is available
10:16:12 <benzrf> Iceland_jack: whoa, what's the @
10:16:15 <benzrf> is that new?
10:16:20 <Iceland_jack> benzrf: TypeApplications from GHC 8
10:16:28 <benzrf> niiiiiiiiiiiiice
10:16:32 <Iceland_jack> It's so nice
10:16:35 <benzrf> so when will haskell finally be dependently typed :>
10:16:36 <saurabhnanda> EvanR: how?
10:16:40 <nitrix> saurabhnanda: \r -> ...
10:16:42 <saurabhnanda> EvanR: via a lambda?
10:16:46 <saurabhnanda> nitrix: lambda, right?
10:16:46 <dolio> Is it nice?
10:16:47 <EvanR> you can open a lambda
10:17:20 <nitrix> saurabhnanda: You must return a function which takes this `r`, suddently it also gives you the `r` to call other functions with.
10:17:23 <EvanR> (>>=) :: (r -> a) -> (a -> (r -> b)) -> r -> b
10:17:31 <EvanR> the third argument isnt special
10:17:33 <Welkin> finally
10:17:37 <EvanR> its just the third argument
10:17:45 <monochrom> (>>=) rdr f = (\r -> in this space you have access to r and you can use it many times)
10:17:48 <Welkin> I got my matrix rotation program to work on mutable vectors
10:17:49 <Welkin> but wtf
10:17:52 <Welkin> this code looks like shit
10:17:57 <Iceland_jack> saurabhnanda: It sounds like you should focus on writing functions of the type ((a -> b) -> (r -> a) -> (r -> b), (r -> a) -> (a -> r -> b) -> (r -> b), a -> r -> a, ...) ignoring Monads or Applicatives
10:18:05 <EvanR> Welkin: why on earth are you using mutable vectors for that
10:18:06 <Welkin> nested forM_ that give parse errors unless I wrap it all in parens
10:18:14 <Welkin> EvanR: just an exercise
10:18:15 <saurabhnanda> (>>=) rdr f = \r -> return (f (rdr r) r)
10:18:24 <Welkin> is there a better way to do it using vectors?
10:18:31 <Welkin> I just copied what I wrote in C
10:18:37 <monochrom> delete "return"
10:18:39 <EvanR> Welkin: there are better ways to write multiline forM_'s
10:18:57 <nitrix> saurabhnanda: I can't easily work out the types in my head, but you shouldn't need return 
10:19:16 <saurabhnanda> (>>=) = return . fmap ?
10:19:22 <monochrom> delete "return"
10:19:32 <Welkin> here it is http://lpaste.net/5939608211777650688
10:19:35 <saurabhnanda> ah sorry
10:19:37 <Welkin> what can I improve about that?
10:19:40 <Welkin> it is so ugly
10:19:50 <saurabhnanda> (>>=) rdr f = \r -> (f (rdr r) r)
10:19:52 <EvanR> Welkin: you can remove the parens by doing $ \i ->
10:19:58 <EvanR> $ \i -> do
10:20:07 <Welkin> ah, of course I forgot about that
10:20:26 <nitrix> saurabhnanda: That seems right. Someone wants to confirm :) ?
10:20:27 <EvanR> saurabhnanda: you successfully passed this r around to every place that needs it
10:20:37 <EvanR> now you know how it works, time to get a sandwich
10:20:44 <monochrom> use compiler to confirm.
10:21:17 <saurabhnanda> is there any reason it's not being written like a lambda?
10:21:26 <saurabhnanda> hang on
10:21:29 <nitrix> saurabhnanda: Are you starting to see how the (>>=) is doing the implicit work of passing `r` implicitly ?
10:21:29 <EvanR> no because you wrote it like a lambda
10:21:30 <saurabhnanda> let me digest
10:21:33 <monochrom> you wrote a lambda.
10:21:46 <Welkin> http://lpaste.net/5939608211777650688
10:22:02 <EvanR> Welkin: you just wrote (nicer) C in haskell
10:22:02 <Welkin> is there a better way to operate on vectors/matrices than this?
10:22:05 <Welkin> lol
10:22:06 <Welkin> yes
10:22:15 <Welkin> I have never worked with mutable vectors in haskell
10:22:21 <EvanR> yeah, dont use mutable arrays for matrices
10:22:25 <Welkin> what then?
10:22:28 <Welkin> not lists
10:22:29 <EvanR> immutable
10:22:37 <saurabhnanda> boy, I still don't comprehend the try nature of 'ask'
10:22:40 <Welkin> how can I do that nicely?
10:22:47 <EvanR> saurabhnanda: that was the easiest one!
10:22:55 <EvanR> Welkin: look at the linear package
10:22:57 <Welkin> without having to carray around the new vector in State and asking for it every time
10:23:14 <Welkin> if I want to swap elements, that will be a huge pain
10:23:17 <EvanR> do you carry around integers are ask for it every time? they are immutable
10:23:25 <saurabhnanda> EvanR: let me think hard again
10:24:01 <nitrix> saurabhnanda: `ask` is the easiest `Reader r` you can find. It's just `id`.
10:24:19 <nitrix> saurabhnanda: When you start chaining readers with >>=, it'll just accept the value and pass it along.
10:24:25 <saurabhnanda> now I'm confused how does ask compose
10:24:28 <EvanR> low dimensional linear algebra objects for computer graphics are a lot like machine ints and doubles, its way more convenient to think of them as immutable values instead of data structures
10:24:33 <saurabhnanda> everything else is Reader r a, ask is Reader r r
10:24:33 <EvanR> same with complex
10:25:01 <nitrix> saurabhnanda: :: (r -> r)
10:25:06 <EvanR> saurabhnanda: did you implement runReader
10:25:07 <saurabhnanda> well, it composes because of >>=
10:25:13 <Welkin> EvanR: I'm wondering about performing many modify operations on the same vector
10:25:18 <saurabhnanda> EvanR: not yet
10:25:19 <saurabhnanda> doing now
10:25:26 <Welkin> if I want to access it by index
10:25:40 <Welkin> I could make it a recursive function I suppose
10:25:50 <EvanR> Welkin: modifying a rotation matrix a lot might even be slower in ghc due to write barriers
10:26:08 <Welkin> EvanR: this is just an exercise for learning
10:26:10 <EvanR> for garbage collection to function properly
10:26:11 <Welkin> I'm not using it for anything
10:26:14 <saurabhnanda> runReader env rdr = rdr env
10:26:24 <EvanR> Welkin: oh i read "performing" as performance
10:26:29 <saurabhnanda> EvanR: nitrix: runReader env rdr = rdr env
10:26:39 <EvanR> :t runReader
10:26:40 <lambdabot> Reader r a -> r -> a
10:26:44 <EvanR> backwards
10:27:02 <Welkin> EvanR: I just don't want to have to manually pass the vector around after every `modify`
10:27:06 <saurabhnanda> runReader rdr env = rdr env
10:27:12 <EvanR> so runReader = ($)
10:27:16 <saurabhnanda> yep
10:27:36 <EvanR> saurabhnanda: this is also an exercise in thinking hard about stuff that is incredibly simplistic, almost to the point of not being anything ;)
10:27:40 <Welkin> or have to put it into State
10:28:08 <EvanR> saurabhnanda: now that you implemented all these parts, write some Reader code with do notation, and understand how it works in terms of >>=
10:28:15 <EvanR> and return
10:28:27 <saurabhnanda> EvanR: doing
10:28:34 <EvanR> the key being that your whole do is a big r ->
10:28:41 <saurabhnanda> EvanR: what is reader, finally. Reader r OR Reader r a
10:28:51 <EvanR> :t reader
10:28:53 <lambdabot> MonadReader r m => (r -> a) -> m a
10:28:59 <EvanR> i dont know what you mean
10:29:23 <EvanR> use do notation to define a MyReader r x for some x
10:29:23 <nitrix> Oh I think he's asking about what is the monad in `Reader r a`.
10:30:04 <EvanR> Welkin: if you just want to simulate a rotation matrix solution to a DE or something, you can use iterate
10:30:23 <nitrix> saurabhnanda: In `(Reader r) a`, `Reader r` is the part that has a monad instance. (If I understood the question right?)
10:30:44 <saurabhnanda> nitrix: hang on, let me show some coe
10:30:45 <saurabhnanda> *code
10:30:47 <exio4> the monad is "Reader r" plus the functions defined in the typeclass, return and (>>=)
10:30:51 <monochrom> Welkin: consider "transpose v = V.generate 9 (\i -> let {(x,y) = quotRem i 3} in v ! (y*3 + x))
10:31:02 <nitrix> Sorry, the parens were there to put emphasis.
10:31:07 <nitrix> That could've been misleading.
10:31:07 <Welkin> V.modify (\v -> MV.write v 1 42) $ V.modify (\v -> MV.write v 0 12) $ V.generate 9 (+1)
10:31:10 <Welkin> is very messy
10:31:27 <EvanR> yes it is
10:31:39 <EvanR> only resert to mutable vectors if you really have a good reason to
10:31:42 <EvanR> resort*
10:31:57 <exio4> Welkin: V.modify $ \v -> do { MV.write v 0 12; MV.write v 1 42; }
10:32:01 <saurabhnanda> here's what I have till now
10:32:03 <saurabhnanda> http://lpaste.net/168083
10:32:43 <EvanR> saurabhnanda: yeah so otherFunc could benefit from do notation
10:33:07 <EvanR> oh you already wrote it with do notation
10:33:43 <saurabhnanda> EvanR: I'm trying to desugar everything, even function application
10:33:46 <saurabhnanda> EvanR: stuck now at http://lpaste.net/168083
10:33:48 <nitrix> saurabhnanda: I don't know if it'll help you or not, but fmap and ask doesn't belong in that instance.
10:34:11 <saurabhnanda> nitrix: because one is a functor and the other is over & above monad?
10:34:11 <EvanR> yeah move fmap to Functor and ask is just a utility function
10:34:21 <saurabhnanda> EvanR: nitrix: got it
10:34:30 <Welkin> exio4: I see, that gives me an idea
10:34:54 <saurabhnanda> EvanR: seem to have reached a dead-end here. types don't match: otherFunc = (ask >>= \secret -> return $ 20 + 30 + secret) 10
10:34:56 <Welkin> I could move my entire doubly-nested forM_ block inside of the function passed to `modify`
10:34:59 <EvanR> Welkin: you can also pass the accumulator matrix around with recursion
10:35:03 <nitrix> saurabhnanda: instance Monad (MyReader r) where
10:35:11 <nitrix> saurabhnanda: No `a` there :P
10:35:39 <EvanR> saurabhnanda: whats the 10 doing there
10:36:07 <saurabhnanda> EvanR: I'm de-structuring from line 35 onwards. Substituting every expression.
10:36:10 <EvanR> oh well... ask is your code has repeated definitions
10:36:19 <EvanR> youre on your own now ;)
10:36:34 <exio4> Welkin: anyway, if your return type is on ST s - why don't you take a mutable vector directly?
10:36:40 <EvanR> *as it is* your code has repeated defs
10:36:50 <saurabhnanda> EvanR: I'm not compiling this.
10:37:03 <EvanR> huh, then why do you say its a type error
10:37:08 <saurabhnanda> EvanR: look at line 37-39... i'm dry-running with substitution
10:37:13 <saurabhnanda> EvanR: mentally
10:37:15 <Welkin> exio4: did you see my paste? http://lpaste.net/5939608211777650688
10:37:16 <exio4> Welkin: then you have Data.Vector.Mutable.STVector s a -> ST s () functions
10:37:27 <exio4> yes
10:37:33 <EvanR> oh , old version of the paste
10:37:55 <EvanR> doesnt look wrong, but i would put a top level type sig
10:38:03 <saurabhnanda> runReader 10 $ myFunc 20 30 (is equivalent to) (myFunc 20 30) 10 
10:38:16 <nitrix> saurabhnanda: runReader has the wrong type.
10:38:18 <saurabhnanda> which is equivalent to ((\x, y -> (ask >>= \secret -> return $ x + y + secret)) 20 30) 10
10:38:26 <nitrix> saurabhnanda: The arguments are swapped ._.
10:38:29 <EvanR> true its backwards, i mentioned that
10:38:52 <saurabhnanda> nitrix: EvanR: I got that. I'm working out a runReader usage manually. dry-running. line 29 onwards.
10:38:55 <EvanR> saurabhnanda: yep
10:38:58 <saurabhnanda> I'm stuck at line 39
10:39:17 <EvanR> it looks right to me, and to be sure you should compile it ;)
10:39:22 <saurabhnanda> can you check the substitutions on line 37, 38, 39 -- is something wrong?
10:39:36 <monochrom> where is MyReader defined?
10:39:58 <nitrix> saurabhnanda: I'm confused why runReader is gone.
10:40:02 <EvanR> monochrom: in the comment
10:40:04 <EvanR> heh
10:40:24 <nitrix> saurabhnanda: You should've expanded the inner function as much as possible before doing the final runReader evaluation.
10:40:36 <saurabhnanda> nitrix: let me try
10:40:42 <monochrom> ok I guess this is not machine-readable code
10:40:51 <EvanR> i suggest no one look at this paste as it is since its not supposed to actually work, saurabhnanda is in magicant right now
10:41:02 <nitrix> saurabhnanda: You're really working for nothing though.
10:41:10 <nitrix> You're trying to understand off of code that wont compile.
10:41:22 <EvanR> the part youre trying to understand would compile
10:41:26 <EvanR> so its confusing
10:42:14 <EvanR> i do recommend writing all this down in a file that will compile
10:42:28 <saurabhnanda> EvanR: yes, I understood now
10:42:33 <EvanR> open ghci and do :r every time you change something
10:42:49 <monochrom> OK, after line 39, use your definition of >>=
10:43:02 <monochrom> "xxx >>= yyy" means "(>>=) xxx yyy"
10:43:18 <saurabhnanda> otherFunc = (\r -> ((\secret -> return $ 20 + 30 secret) (ask r) r)) 10
10:44:06 <EvanR> heh, and ask r = r... and a whole lota nothing going on ;) no wonder its hard to explain monads ;)
10:45:05 <EvanR> at least in the case of Reader... its \env -> "on acid"
10:45:05 <monochrom> that is only the tip of the iceberg.
10:45:21 <EvanR> function wrappers everywhere
10:46:03 <monochrom> the whole of Haskell (at least the non-I/O part) is just a lot of function applications and plugging in parameters, not unlike simplifying otherFunc.
10:46:31 <saurabhnanda> VICTORY: http://lpaste.net/168083
10:46:59 <monochrom> it's a lot of nothing going on (apart from plugging in).
10:47:08 <EvanR> saurabhnanda: on line 41 you didnt drop the outer 10
10:47:18 <monochrom> so it's probably hard to explain functional programming too
10:47:32 <EvanR> "its a paradigm about nothing"
10:47:36 <saurabhnanda> EvanR: I got confused there. It has to hang around because of the 'return'
10:47:41 <saurabhnanda> to unwrap the 'return'
10:47:49 <EvanR> saurabhnanda: no... you dont, and to keep it is wrong
10:47:50 <saurabhnanda> 'unwrap'
10:48:10 <EvanR> like doing 3 + 3 = 6 + 3
10:48:27 <nitrix> I this point, I must really ask why the stubborness of not using the compiler.
10:48:29 <saurabhnanda> EvanR: you're right
10:48:55 <monochrom> nitrix: because "instance Monad MyReader r a" is a kind error :)
10:49:10 <nitrix> monochrom: There's so much more than that.
10:49:39 <saurabhnanda> if this is the case -- http://lpaste.net/168083 -- then the type of otherfunc won't be int, it will be r -> Int
10:49:41 <nitrix> It'd do 90% of the work for you, especially, it'd let me introduce you to type holes.
10:49:53 <monochrom> "instance Monad ((->) r)" is already in Prelude, it is hard to do this exercise on the compiler.
10:50:40 <EvanR> saurabhnanda: you missed a spot on line 41
10:50:48 <EvanR> you didnt apply the ending 10
10:50:58 <saurabhnanda> not using the compiler because I need to make my intuition and understanding stronger. What I'm going to attempt next http://stackoverflow.com/questions/38035534/how-to-build-a-custom-reader-monad-along-with-a-custom-typeclass/38036014 should be workable in my head.
10:51:00 <nitrix> saurabhnanda: Personally, you're on your own from now on.
10:51:07 <EvanR> you went from ) (ask r) r to ) 10
10:51:08 <EvanR> er
10:51:12 <EvanR> you went from ) (ask r) r to ) (ask 10)
10:52:03 <EvanR> yeah i think youre good enough to fix the rest of the mistakes yourself
10:52:11 <EvanR> just be honest with yourself about what you already know
10:52:20 <saurabhnanda> thanks, EvanR. http://lpaste.net/edit/168083
10:53:18 <Welkin> is there a better way to work with "imperative" array manipulation?
10:53:21 <Welkin> this is just stupid
10:53:44 <saurabhnanda> okay, making another mental leap here, but the way this works, I don't think there is a way to pass this environment around by "extending" IO 
10:54:13 <Welkin> the way I had it before was working with immutable vectors, but using thaw/freeze inside of the operation functions (e.g. transpose, reverse)
10:54:18 <Welkin> which seems like an okay tradeoff
10:54:48 <monochrom> reverse is already in Data.Vector
10:54:52 <saurabhnanda> my original idea was to to not deal with monad transformers at all, but to have my typeclasses and make IO an instance of that typeclass. And through the typeclass I wanted to pass this environment around, because most of my app is already in IO.
10:55:08 <Welkin> monochrom: well, this is for reversing "rows" in a one-dimensional vector
10:55:15 <Welkin> a flattened matrix
10:55:29 <Welkin> so yeah... I just translated my C into haskell
10:55:56 <Welkin> can anyone take my paste and show how you would do it?
10:55:57 <monochrom> transpose is already solved by me right here, but you didn't want to see it.
10:56:26 <Welkin> monochrom: I saw it, but it generated a new matrix instead of taking an existing one
10:56:32 <Welkin> I'm not sure how that solves anything
10:57:23 <monochrom> it satisfies "stick to immutable"
10:57:48 <Welkin> that's not what I meant though
10:57:51 <Welkin> let me check again
10:58:05 <monochrom> there can only be two meanings of "immutable".
10:58:05 <Welkin> it looked like it always generated a matrix with the index as the value
10:58:22 <Welkin> instead of taking any arbitrary square matrix
10:58:34 <monochrom> one is "the transpose has to be a new immutable matrix", which is what I did
10:59:15 <monochrom> the other is "the transpose has to overwrite the original immutable matrix", which is a self contradiction.
11:00:34 <saurabhnanda> thanks EvanR nitrix monochrom for the help
11:00:37 <monochrom> do you see the "v !" part?
11:01:25 <monochrom> I am not going to explain my code like you're 5.
11:01:43 <Welkin> monochrom: yes, I looked closer at it and see what you did
11:01:55 <Welkin> there is no need to be rude about it
11:02:13 <monochrom> yes there is every need. you wasted my time.
11:02:28 <monochrom> and dare I say it is rude to waste someone's time
11:03:10 <Welkin> if it's a waste of your time to help people, then why are you answering questions?
11:03:20 <nitrix> Enough.
11:04:28 <saurabhnanda> whoa! what happened here...
11:05:17 <nitrix> Something you rarely see on #haskell and hope doesn't stay in our minds very long :)
11:05:47 <nitrix> saurabhnanda: Was the implementation of MyReader enlightning?
11:06:30 <nitrix> Do you see how it's neither the type `Reader r a`, nor (>>=) that "holds" a value?
11:06:39 <saurabhnanda> nitrix: yep
11:06:56 <saurabhnanda> nitrix: an i'm also beginning to understand the **need** for monad tranformers
11:07:13 <saurabhnanda> nitrix: because you can't simply "extend" a monad how I was imagining
11:08:07 <nitrix> runReader receives it and from then on, it's just chained. Hence why they're all lambda. `Reader r a` being `(r -> a)`, the monad instance on `Reader r` is `((->) r)`. You're working with partial functions all along.
11:09:33 <nitrix> They're partially applied functions over the `r`, the `r` is missing, but it'll be threaded later on.
11:10:05 <nitrix> `\r -> ...`   and  `r <- ask` are doing the same thing, as far as Reader is concerned.
11:10:51 <Welkin> this quotRem function is very useful
11:10:53 <Welkin> I forgot about it
11:11:31 <saurabhnanda> nitrix: right... now I'm still doing my mental gymnastics to see if I can get this approach to work -- http://stackoverflow.com/questions/38035534/how-to-build-a-custom-reader-monad-along-with-a-custom-typeclass/38036014
11:12:06 <nitrix> saurabhnanda: Those are using ReaderT though.
11:12:16 <EvanR> saurabhnanda: typeclasses... damn
11:12:38 <EvanR> saurabhnanda: another exercise to continue on with is to implement Applicative for YourReader r
11:13:19 <EvanR> > runReader ((,,) <$> asks even <*> asks chr <*> ask) 99
11:13:20 <lambdabot>  (False,'c',99)
11:13:44 <mcuramen> Guys, I'm loving Haskell. Java is ruined forever.
11:13:50 <saurabhnanda> EvanR: you're not ErikR on stackoverflow, by any chance, are you?
11:13:53 <EvanR> no
11:14:10 <EvanR> Java is dead. Long Live Java
11:14:16 <nitrix> mcuramen: That's great. How far are you in your learnings?
11:15:03 <monochrom> don't be in love with any language. it's just a programming language.
11:15:10 <mcuramen> nitrix: not that far, I am going through Learn Yourself and I'm just finishing the chapter on Syntax in Functions
11:15:18 <mcuramen> I love recursion
11:15:26 <saurabhnanda> what's GND?
11:15:33 <Iceland_jack> GeneralizedNewtypeDeriving
11:15:34 <EvanR> to love recursion you must first love recursion
11:15:44 <saurabhnanda> Context: where Config is a record containing our application’s configuration, and we derive MonadIO and MonadReader using GND.
11:16:44 <Iceland_jack> saurabhnanda: Int is a number, if you have a newtype 'newtype Age = MkAge Int' it can also be a number
11:16:54 <EvanR> saurabhnanda: there is no need for transformers. they are just a way to make new monads.
11:17:02 <Iceland_jack> You just need to derive
11:17:02 <Iceland_jack>     newtype Age = MkAge Int 
11:17:02 <Iceland_jack>       deriving (Show, Num, ...)
11:17:19 <EvanR> you can hide them behind the scenes and expose a proper monad for your app or library
11:17:33 <saurabhnanda> EvanR: "you can hide them" -- what's "them"?
11:17:38 <EvanR> the transformers
11:17:41 <saurabhnanda> ah okay
11:17:51 <Iceland_jack> ghci> newtype Age = MkAge Int deriving (Show, Num)
11:17:51 <Iceland_jack> ghci> 17 + 1 :: Age
11:17:51 <Iceland_jack> MkAge 18
11:17:59 <EvanR> its not important for users of your code to know about and have to deal with your transformers
11:18:24 <EvanR> users of your code = you
11:18:32 <EvanR> get schizo
11:20:05 <saurabhnanda> he he
11:21:36 <saurabhnanda> ah okay
11:21:42 <saurabhnanda> so one more thing I was trying to solve is the nesting
11:22:17 <saurabhnanda> actually not
11:22:23 <saurabhnanda> let me write some code with this understanding now
11:23:42 <balth> hey does anyone know if its possible to easily compare functions with quickcheck or something like it?
11:24:08 <balth> ive been following some tutorials that have me implement things like "any" and "all", and i want to easily test them against the real functions
11:24:33 <Iceland_jack> balth: If you have two functions f/g you can test them with
11:24:34 <Iceland_jack>     prop_test a b c = f a b c == g a b c
11:25:00 <balth> Iceland_jack: thanks!
11:25:21 <Iceland_jack> ghci> quickCheck (\xs -> drop 0 xs == id xs)
11:25:21 <Iceland_jack> +++ OK, passed 100 tests.
11:25:35 <saurabhnanda> :t runReaderT
11:25:36 <lambdabot> ReaderT r m a -> r -> m a
11:25:38 <Iceland_jack> a, b and c must have Arbitrary instances
11:26:09 <Iceland_jack> balth: You can even test higher-order functions, automatically generate functions and even show them! https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck-Function.html
11:26:15 <saurabhnanda> why does runReader & runReaderT have the "tougher/longer" param as the first one
11:26:25 <saurabhnanda> need to use flip
11:26:28 <saurabhnanda> :t flip
11:26:29 <lambdabot> (a -> b -> c) -> b -> a -> c
11:26:43 <saurabhnanda> :t flip . runReaderT
11:26:44 <lambdabot> ReaderT a ((->) b) c -> b -> a -> c
11:27:00 <saurabhnanda> :t flip runReaderT
11:27:02 <lambdabot> r -> ReaderT r m a -> m a
11:27:37 <balth> Iceland_jack: cool stuff. i knew this was something that had to exist!
11:27:58 <Iceland_jack> You can also test IO 
11:28:00 <Iceland_jack> https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck-Monadic.html
11:29:24 <balth> are there any good tutorials you could recommend for quickcheck?
11:30:13 <Iceland_jack> balth: This video series is completely integrated with QuickCheck http://www.cse.chalmers.se/edu/year/2015/course/TDA452/FPLectures/Vid/ but there are also written tutorials
11:30:47 <Iceland_jack> balth: this one is a bit old, but it's somewhat exhaustive http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
11:30:58 <monochrom> saurabhnanda: there are two causes. first one: this is the order you get if runReaderT is a record accessor. second one: few people actually inline the long thing at the runReaderT use-site.
11:31:42 <balth> i'll check them out. ive always had a bit of trouble finding good resources
11:32:25 <Iceland_jack> balth: I recently added examples to the QuickCheck manual, but it's good to read through the second link 
11:32:52 <Iceland_jack> balth: an underused function is also
11:32:53 <Iceland_jack>     suchThat :: Gen a -> (a -> Bool) -> Gen a
11:33:34 * hackagebot http-dispatch 0.5.0.2 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.5.0.2 (owainlewis)
11:34:01 <saurabhnanda> monochrom: inline=?
11:34:15 <balth> are you a dev on quickcheck?
11:34:30 <Iceland_jack> No although I've contributed patches
11:34:30 <Iceland_jack>     
11:34:50 <saurabhnanda> type NwConfigApp = ReaderT NwConfig ; askNwConfig :: (MonadIO m) => NwConfigApp m NwConfig  -- that will let me use askNwConfig inside an IO monad without lifint?
11:35:01 <monochrom> inline = you put the code at the use-site.
11:35:31 <balth> thats still awesome. ive heard a lot of good things about the haskell irc channel, and so far they have been right :)
11:35:35 <Iceland_jack> balth: I used 'suchThat' as a sanity check when I was writing a compiler, I needed to test what my compiler did on expressions that evaluate to "0"
11:35:35 <Iceland_jack>     zero = suchThat arbitrary (\exp -> eval exp == 0)
11:37:16 <jmcarthur> maerwald: Sorry, was away, but I produced a microbenchmark for you. http://lpaste.net/168131
11:37:33 <balth> so for refactoring code, the ideal situation is that you have all your tests in place and then you start changing code? you wouldnt develop two functions and compare them directly for equality?
11:37:34 <Iceland_jack> balth: (that's a wasteful check since it generates many expressions that don't eval to 0, but it helped me find a bug and automatically shrink the expression: quick and dirty but works)
11:37:55 <jmcarthur> maerwald: The MTL version crushes the Freer version.
11:38:06 <Iceland_jack> balth: When you refactor a function, copy it to "function_old"
11:38:07 <maerwald> jmcarthur: can you make a proper paper for that?
11:38:50 <Iceland_jack> balth: And then you can keep the old version around as a "test oracle": prop_function a b = function a b == function_old a b
11:39:05 <jmcarthur> maerwald: That's a joke, right?
11:39:23 <maerwald> jmcarthur: no, you are basically claiming the performance tests from oleg are wrong
11:39:50 <jmcarthur> maerwald: No, I'm claiming that they were (probably) written in a style not typical of most programs.
11:40:04 <balth> Iceland_jack: ah i see, than then once you have verified it is "correct", you can remove the old one
11:40:08 <jmcarthur> To be fair, mine isn't really typical either.
11:40:19 <jmcarthur> So my benchmarks don't prove this particular claim.
11:40:30 <Iceland_jack> balth: yes, or keep it if you can afford it
11:40:38 <jmcarthur> Well, the claim being that mtl performs fine for realistic programs.
11:40:41 <Iceland_jack> You can do the same for efficiency, write a *slow* function that obviously works
11:41:10 <Iceland_jack> and then write a test that the fast version does the same
11:41:11 <Iceland_jack>     prop_sort xs = sort_slow xs == sort_fast xs
11:41:31 <Iceland_jack> These are basic ideas, but they are powerful
11:41:55 <balth> that doesnt hurt your overall performance/binary size right? those unused functions would be stripped? it would only be code maintanibily/readibility issue
11:42:31 <saurabhnanda> when using a ReaderT Config IO a is there any way to NOT lift IO code?
11:42:54 <EvanR> you can NOT lift MonadIO code
11:43:04 <EvanR> which most standard IO actions arent
11:43:39 <Iceland_jack> Usually you keep the testing as a separate module
11:43:48 <EvanR> in practice its not bad because *drum roll* you will be exposing a monadic API to your users with nice utility functions that dont involving messing with transformers
11:44:14 <EvanR> internally you might use liftIO to implement some of the actions
11:44:57 <balth> Iceland_jack: so in your example, sort_fast would be in the main module, and sort_slow would be in the testing module?
11:46:00 <Iceland_jack> Yeah 
11:46:23 <Iceland_jack> It will always be a tradeoff
11:46:57 <balth> Iceland_jack: story of my life :P
11:47:05 <saurabhnanda> how do I deal with this? 
11:47:07 <saurabhnanda> startAria2_ = do
11:47:07 <saurabhnanda>   nwConfig <- askNwConfig
11:47:07 <saurabhnanda>   liftIO $ putStrLn "==> Starting Aria2"
11:47:21 <EvanR> looks like you just did
11:47:38 <saurabhnanda> as-in, i don't want to liftIO everywhere
11:47:45 <exio4> define your own "log" function
11:47:46 <EvanR> then make a print function for your monad
11:48:00 <exio4> log str = liftIO (putStrLn ("==> " ++ str)) 
11:48:02 <EvanR> and make it easier to type than putStrLn
11:48:17 <saurabhnanda> whoa!
11:48:27 <saurabhnanda> do that for every single standard IO function
11:48:34 <EvanR> you can even arrange for your monad to be unable to do any IO except what you allow
11:48:48 <EvanR> though that might suck depending on the application
11:48:53 <EvanR> saurabhnanda: no.
11:49:06 <EvanR> what would be the point of that
11:49:11 <EvanR> just do everything in IO 
11:49:25 <saurabhnanda> EvanR: every single standard IO function that my app is currently using?
11:49:32 <EvanR> not necessarily
11:49:35 <begriffs> Reminds me of https://hackage.haskell.org/package/lifted-base
11:50:01 <saurabhnanda> which brings me to my original question -- can I get IO to behave like a reader. That's what I guess I'm trying to do.
11:50:14 <EvanR> yes, you can just pass the config to whatever functions need it
11:50:18 <saurabhnanda> basically get the reader and IO to compose without lifting
11:50:20 <EvanR> forget the reader
11:50:33 <saurabhnanda> EvanR: aaaargh! that's what I just did. I want to try the other approach now.
11:50:38 <EvanR> another pattern you can do is
11:50:50 <EvanR> = liftIO $ do
11:50:54 <EvanR>    a bunch of IO code
11:51:16 <saurabhnanda> https://github.com/vacationlabs/nightwatch/commit/59cd34a5dbaf019ecc457fd28ad261d14c5a6fc7
11:51:35 <EvanR> instead of passing the config everywhere you can also pass specifically what each function needs, then its even more convenient to write the routine
11:51:46 <saurabhnanda> passing NwConfig as an arg to a lot of functions
11:51:50 <EvanR> but youll need to have a preamble to unpack the parts 
11:52:05 <EvanR> well, you might have an architectural issue 
11:52:18 <saurabhnanda> EvanR: already tried the explicit config everywhere, but even that's not elegant
11:52:19 <EvanR> everything certainly doesnt need everything all the time everywhere, i dont believe it
11:52:45 <EvanR> functional programming is about passing what your code needs into a function as an argument
11:52:57 <EvanR> if you have a host of things not being passed in, then whats really going on
11:53:17 <saurabhnanda> EvanR: no, the problem is that one of the lowest level function needs the config. And everything is built on top of it. Most functions are not doing anything with the config. Just passing it along one layer to the other, till finally it comes to sendMessage, which needs it.
11:53:37 <EvanR> it needs one thing?
11:54:01 <EvanR> show me where the lowest level function is
11:54:06 <saurabhnanda> EvanR: one lower level function needs the telegram bot-token. Another lower-level function needs the oauth tokens.
11:54:13 <saurabhnanda> https://github.com/vacationlabs/nightwatch/commit/59cd34a5dbaf019ecc457fd28ad261d14c5a6fc7#diff-82470d2863ca3e5bed32f7aae585da79R88
11:54:14 <EvanR> a 9 page github diff isnt telling me anything
11:54:56 <saurabhnanda> https://github.com/vacationlabs/nightwatch/blob/haskell/Nightwatch/Telegram.hs#L88
11:54:57 <Yuras> saurabhnanda: use dependency injection
11:55:18 <EvanR> saurabhnanda: at the very least, you can easily do
11:55:21 <EvanR> do
11:55:29 <EvanR>   token <- getAuthToken
11:55:33 <EvanR>   liftIO $ do
11:55:35 <saurabhnanda> EvanR: what, dependency injection?
11:55:36 <EvanR>     IO code
11:55:58 <monochrom> no no, Yuras is the one suggestion dependency injection
11:55:59 <EvanR> that is the kind of goal youre shooting for with ReaderT Config IO
11:56:24 <monochrom> on that tangent, I think we should hijack the term "dependency injection" to mean mimicking dependent types.
11:56:45 <monochrom> for example "Vec 5 Int" is a dependency injection.
11:56:49 <saurabhnanda> EvanR: right...
11:56:50 <EvanR> dependently typedness injection
11:57:27 <saurabhnanda> any way whatsoever to "unify" IO and Reader into a SINGLE monad so that they compose **withou** lifting. Which is where I threw typeclasses into the mix.
11:57:57 <EvanR> its not even IO thats the issue here, its whatever IO your framework is allowing you to use, which if its MonadIO, you dont have to lift
11:58:03 <Cale> Reader is just a function parameter
11:58:14 <EvanR> and frameworks like MonadIOing, so
11:58:19 <EvanR> framework away
11:58:29 <EvanR> you can also download MonadIO version of the standard IO actions
11:58:33 <Cale> If your only monad transformer is ReaderT, you're probably not getting enough out of it to justify using a monad transformer.
11:58:51 <EvanR> ^
11:58:58 <Cale> ReaderT can be a useful ingredient in a more complicated mixture of monad transformers
11:59:05 <Cale> but it's not really very good on its own
11:59:18 <Cale> You're usually better off with just a plain function argument
11:59:29 <EvanR> saurabhnanda said he already did it by passing parameters, and didnt like it
11:59:34 <Cale> hmm
11:59:42 <saurabhnanda> I'm unable to use a single monad throughout because of the forkIO boundary
11:59:49 <Cale> right
12:00:10 <Cale> The ability to easily forkIO is one of the things you immediately give up when you apply a monad transformer to IO
12:00:10 <EvanR> you can wrap whatever utilities you need, including forkIO running another monad, in other functions
12:00:16 <dmj__> monad control lifts forkIO
12:00:20 <saurabhnanda> otherwise my monad would be ReaderT NwConfig (SqlPersisT IO)
12:00:22 <Cale> But yeah, you can do it
12:00:36 <EvanR> saurabhnanda: like i was saying earlier, with transformers you will be making a lot of small utility functions to make using the transformer not suck. i hope you now believe me
12:00:39 <Cale> (Particularly with ReaderT, it's easy to have a specialised forkIO)
12:00:46 <EvanR> saurabhnanda: your monad is MyApp
12:01:21 <dmj__> saurabhnanda: lifted-base gives you 'fork', you can fork threads while retaining your reader.
12:01:36 <EvanR> MyApp code will look ok as long as you have an array of MyApp actions made nicely for MyApp
12:01:38 <Cale> Yeah, usually monad transformers work out in sort of more-structured settings where you can capture all or most of the IO actions you really wanted to perform in a library of actions in your new monad.
12:01:46 <saurabhnanda> otherwise my monad would be ReaderT NwConfig (SqlPersisT IO)/
12:01:49 <Cale> and then outside of that library, you don't need to lift
12:01:58 <saurabhnanda> sorry
12:02:10 <saurabhnanda> EvanR: Cale: what's the specialized forkIO you're referring to?
12:02:20 <EvanR> liftIO forkIO ... ?
12:02:41 <Cale> saurabhnanda: I mean, you can write something like  forkApp :: App a -> App ThreadId
12:02:46 <saurabhnanda> EvanR: I tried doing that 4 weeks ago, but it didn't work for some reason
12:02:53 <EvanR> well, it can work
12:03:03 <EvanR> you can make as many utility functions for MyApp as you need
12:03:38 <Cale> Which is something like  forkApp x = do r <- ask; liftIO (forkIO (runApp x r))
12:03:49 <EvanR> at that point i kind of feel like haskell failed
12:03:52 <saurabhnanda> sorry
12:03:57 <EvanR> which is why i avoid it and suggest not going that way
12:04:16 <saurabhnanda> here's what I was trying
12:04:32 <Cale> EvanR: Well, it *can* be good -- if you can sufficiently capture all the stuff you want to be able to do
12:04:40 <EvanR> you *can*
12:04:42 <Cale> If you have a domain specific language in mind, that is.
12:04:53 <EvanR> how much typing will it take to restore C++
12:05:00 <Cale> ?
12:05:08 <saurabhnanda> runSqlite $ forkIO $ (function in SqlPersistT IO)
12:05:14 <Cale> I mean, maybe you don't even want to allow arbitrary IO actions
12:05:17 <saurabhnanda> that didn't compose at all due to forkIO boundary
12:05:24 <EvanR> Cale: saurabhnanda's idea was to make forkIO wrappers for every IO action there is
12:05:26 <Cale> Maybe you don't want your new monad to even be an instance of MonadIO
12:05:41 <EvanR> Cale: i mentioned that, but as your scope creeps slowly toward "doing any IO you want"
12:05:52 <EvanR> which is where saurabhnanda seems to be
12:06:32 <EvanR> saurabhnanda: well, its possible, but you also need to be careful about modifying SQL's one connection from multiple threads
12:06:36 <EvanR> its not made for that
12:06:37 <saurabhnanda> this is the reason why I can't use a single monad throughout -- runSqlite $ forkIO (function in SqlPersistIO) -- does not compose
12:06:37 <Cale> saurabhnanda: Is SqlPersistT also a ReaderT?
12:06:52 <saurabhnanda> Cale: yes
12:07:07 <Cale> Well, then you can do the same thing I showed with forkApp above
12:07:25 <saurabhnanda> when I hit that problem, #haskell suggest lifted-base, which seemed overkill at that point. Also I was confused whether the connection pool would work well across fork boundary.
12:08:02 <Cale> Well, that wouldn't help. MonadBaseControl can help, but if you have to use MonadBaseControl, something has already gone horribly wrong I think :)
12:08:24 <EvanR> saurabhnanda: it will probably create a new connection pool
12:08:31 <saurabhnanda> so, I went with -- runSqlitePool $ \pool -> forkIO $ runSqlPool (function in SqlPersistT IO) pool
12:08:56 <EvanR> so were back to my original suspicion, you have an architectural problem
12:09:11 <saurabhnanda> probably
12:09:15 <saurabhnanda> how do I deal with this problem
12:09:17 <TimWolla> I have a function returning an Either a b inside an ExceptT monad transformer. Is there an easier way to get it to typecheck than using `ExceptT $ return $ ...`? This is my code: http://lpaste.net/515392137034989568
12:09:23 <Cale> Doesn't SqlPersistT provide you with a way to get the existing pool?
12:09:24 <saurabhnanda> the fork boundary?
12:09:33 <Cale> Let me look
12:10:04 <EvanR> saurabhnanda: its not really an issue with forking, its whether the transformer gives you access to stuff to do things, and whether its correct in letting you do that
12:10:09 <EvanR> or incorrect in not letting you do that
12:10:14 <saurabhnanda> Cale: would that help? the problem is that forkIO :: IO () -> IO ThreadId won't compose with "SqlPersistT IO a"
12:10:24 <Cale> saurabhnanda: You can make it compose
12:10:34 <EvanR> :t liftIO . forkIO
12:10:35 <lambdabot> Not in scope: ‘forkIO’
12:10:39 <Cale> If you have a way to get the pool, and you have a way, given a pool, to run a SqlPersisT
12:10:52 <EvanR> Cale: but this is not safe really
12:11:04 <EvanR> you cant have multiple threads using the same pool
12:11:07 <Cale> Oh, yeah, maybe the connection isn't threadsafe?
12:11:13 <Cale> Right, okay
12:11:19 <EvanR> maybe it is, but SQLite isnt multithreaded
12:11:48 <saurabhnanda> liftIO . forkIO :: MonadIO m => IO () -> m ThreadId 
12:11:53 <EvanR> and if it was locked and safe for what youre trying to do, there would be an action for it
12:11:57 <EvanR> i would hope
12:12:05 <Cale> So what you really want is a way to ship a SqlPersistT action off to another thread which will run it.
12:12:29 <saurabhnanda> EvanR: I read about it -- the sqlitepool handles concurrent access of the pool
12:12:31 <EvanR> saurabhnanda: well more like liftIO .: forkIO or .:: depending on how many arguments to run there are
12:12:45 <EvanR> saurabhnanda: how does it handle concurrent access if you cant even fork threads?
12:13:05 <saurabhnanda> EvanR: explicitly passing the pool around
12:13:12 <EvanR> oh well then do that
12:13:20 <saurabhnanda> EvanR: doing that -- which has lead to this problem
12:13:25 <EvanR> pool <- getExplicitAccessToThePool
12:13:29 <Cale> Wait, what was the problem?
12:13:34 <saurabhnanda> ha ha
12:13:37 <saurabhnanda> round and roun
12:13:39 <Cale> What problem did you run into while passing the pool around
12:13:41 <saurabhnanda> alice in wonderland
12:13:49 <EvanR> welcome to web programming
12:13:58 <Cale> Sorry
12:14:02 <saurabhnanda> no no
12:14:06 <saurabhnanda> just amusing
12:14:06 <Cale> I missed the start of the discussion
12:14:18 <Cale> Can you describe what the problem was that you had originally?
12:14:19 <EvanR> i came in just figuring out Reader
12:14:29 <Cale> Because you can't do anything with ReaderT that you couldn't also do passing parameters
12:14:33 <saurabhnanda> problem = haskel newbie trying to punch above his weight
12:14:43 <Cale> So you might as well solve the problem in a parameter passing way
12:14:56 <Cale> and then figure out what you did, and *maybe* use ReaderT after
12:15:12 <saurabhnanda> Cale: actually multiple problems. EvanR believes it's an architectural issue which lead to this forkIO discussion
12:15:37 <EvanR> well, if you can get access to the pool, you can execute the persist action in another thread with the same pool
12:15:40 <saurabhnanda> Cale: already solved with param passing, but too many functions needed to be modified. So, not happy with the solution. Trying to "unify
12:15:41 <EvanR> but you said there was a problem
12:15:50 <Cale> Generally, monad transformers are going to make your architecture more rigid, and you want to apply them only once you're sure you have the right idea.
12:15:56 <saurabhnanda> Truying to "unify" ReaderT & IO to mix & match code without lifting
12:16:11 <EvanR> ah well, youre not going to get very far in haskell not wanting to rewrite bad code
12:16:18 <Cale> saurabhnanda: So it was a problem not with the way that the code worked, but with how it appeared?
12:16:23 <EvanR> it doesnt give you enough stupid hacks to monkey patch things
12:16:51 <saurabhnanda> Cale: philopsophical problem actually
12:17:05 <EvanR> ReaderT Config IO and IO are two different monads, they cant "match"
12:17:06 <saurabhnanda> Cale: lowest level function needs the config. Every single function on top is just involved in simply passing the parameter down.
12:17:31 <Cale> But they're not just "passing the parameter down" if it ultimately affects their result
12:18:02 <Cale> If you wanted to test any particular thing, the configuration parameter would be important to what it was that you expected
12:18:24 <saurabhnanda> Cale: yes, it does. So, I was thinking, most of my functions are anyways in a monad, either IO or SqlPersistT IO, why not use the monad to pass-in the Config.
12:18:35 <EvanR> i think testing a ReaderT SqlPersistT IO is out the window anyway
12:18:47 <saurabhnanda> which lead to the "grand unification of monads" idea ==> IO + Reader ===> profit!
12:18:55 <Cale> saurabhnanda: This is possible to do, it's just that building a nice interface is lots of hard work.
12:19:19 <Cale> and you have to balance whether that work is worth the trouble vs. just passing a parameter
12:19:47 <Cale> You absolutely can create a monad which passes the config around at the same time as doing other stuff
12:19:49 <saurabhnanda> i thought with typeclasses it would be easy
12:20:00 <saurabhnanda> both the monads are instances of a unified typeclass
12:20:02 <EvanR> philosophically the ReaderT is a large burden, for what you now know is basically the exact same thing, its just pass a parameter inside the datatype
12:20:02 <saurabhnanda> and magic
12:20:12 <Cale> It's not magic
12:20:21 <Cale> ReaderT is just parameter passing, packaged up
12:20:25 <EvanR> saurabhnanda: thats not how monads work, every action in a do notation sequence has to be the same monad
12:20:40 <EvanR> you cant use actions from different monads because they are in the same class
12:20:50 <EvanR> but you can lift actions from one monad to another
12:20:52 <Cale> Well, if the actions are polymorphic
12:20:59 <Cale> you can get away with a lot
12:21:06 <saurabhnanda> EvanR: which is another thing I have to remember. In my head I'm intuiting typeclasses as super-classes
12:21:21 <Cale> You can defer the decision about which monad you're constructing an action of until the very last moment
12:21:24 <EvanR> Cale, you mean actions that work for all monads?
12:21:35 <Cale> I'm talking about the mtl-style
12:21:43 <EvanR> then its really one monad in the end
12:21:46 <Cale> Where you have MonadFoo classes
12:21:47 <Cale> right
12:21:49 <Cale> it is
12:21:58 <Cale> but you defer the decision about which monad until the end
12:22:12 <saurabhnanda> then I saw something in this post http://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/ which got me trying
12:22:13 <EvanR> which is the same as saying, make a giant MyApp monad
12:22:29 <EvanR> and modify it as it grows leggs
12:22:33 <saurabhnanda> no, the mtl approach suffers from lifting
12:22:35 <saurabhnanda> it's not the same monad
12:22:39 <saurabhnanda> it's an onion of monads
12:22:45 <saurabhnanda> I'm talking about actual unification
12:22:55 <Cale> saurabhnanda: Well, you only have to lift the IO actions because they are not polymorphic
12:22:58 * EvanR repeats, your MyApp monad will necessarily have a host of lifting utility actions
12:23:02 <saurabhnanda> ==> I should sleep <==
12:23:06 <saurabhnanda> I think I've stopped making sense
12:23:09 <Cale> If you have something that was (MonadIO m) => m Result
12:23:13 <EvanR> IO will never unify with ReaderT Config IO
12:23:16 <Cale> then you'd be able to just use it
12:23:32 <Cale> However, this doesn't really buy you a whole lot
12:23:44 <Cale> It saves you one liftIO
12:23:57 <Cale> by making you write a liftIO somewhere else
12:24:06 <EvanR> liftIO is kind of like griping about not being able to use Ints as Doubles
12:24:14 <EvanR> without a fromIntegral
12:24:31 <Cale> kinda
12:24:53 <saurabhnanda> okay, I hate lifting stuff. It's just type boilerplate for me. It's like Java's verbose type signatures. Just cruft which gets in the way.
12:25:20 <EvanR> you also hate passing parameters ;)
12:25:22 <Cale> saurabhnanda: But yeah, if you dislike boilerplate, you're going to hate monad transformers.
12:25:43 <EvanR> you also hate rewriting badly written code
12:25:58 <Cale> It's best to think of monad transformers are a means to constructing a particular monad as part of a coherent plan for a complete library
12:26:10 <Cale> and they save you only a little bit of time
12:26:13 <saurabhnanda> I was thinking of making every function a closure inside a global function which makes the environment variables available as locals.
12:26:35 <Cale> and you don't really want to expose the monad transformer usage to the clients of that library
12:26:49 <Cale> saurabhnanda: Yeah, but how do you test that?
12:27:11 <saurabhnanda> EvanR: I'd be more than happy to have code review. This is my first haskell app, I'm sure the code stinks. But right now, I don't know enough to know what's bad and what's not. Is there anyone who can do a code review?
12:27:13 <Cale> saurabhnanda: The nice thing about having things be in a function parameter is that you know what you need to provide in order to test
12:27:36 <EvanR> saurabhnanda: well people are just going to suggest one of several things youve heard already and have rejected
12:28:08 <Cale> saurabhnanda: One thing that I like to do with mutable state is to split up the read and write end into separate parameters
12:28:13 <saurabhnanda> actually, at some level monad transformers seem very inelegant to me. Does OCaml have them as well?
12:28:29 <saurabhnanda> something just seems incomplete or not-quite-right due to mtl
12:28:34 <maerwald> saurabhnanda: check out extensible effects, e.g. freer
12:28:37 <Cale> Monad transformers have a place
12:28:40 <EvanR> ocaml is probably more likely to do the parameter passing, and so is C++
12:28:56 <EvanR> which is ironic
12:29:02 <Cale> They're just not an acceptable substitute for thoughtful API design
12:29:04 <Cale> nothing is
12:29:24 <hexagoxel> Cale: but you know what you need to provide in order to test with a ReaderT as well.
12:29:44 <maerwald> saurabhnanda: sadly, extensible effects are not really accepted in the haskell ecosystem yet
12:29:48 <Cale> There are all sorts of related techniques for constructing monads (or applicatives, arrows, what have you) in which to express your computations
12:29:53 <saurabhnanda> hexagoxel: Cale was referring to my earlier idea. One giant closure.
12:29:54 <maerwald> mtl and monad transformers are still more popular
12:30:08 <hexagoxel> Cale: ah, nevermind, sorry.
12:30:34 <EvanR> saurabhnanda: youve certainly been suggesting methodologies that end up being way more work
12:30:35 <Cale> but they don't actually solve the real problem which is to design a good library interface
12:30:44 <EvanR> and harder to maintain
12:30:49 <Cale> They just help you implement the interface once you know what it is
12:30:50 <saurabhnanda> anyways... I guess i'll stick with param passing for now. Any pointers about how to solve the forkIO boundary problem?
12:31:05 <EvanR> see Cale's forkApp 
12:31:13 <saurabhnanda> in this chat?
12:31:16 <EvanR> yes
12:31:17 <Cale> Okay, so, right we should deal with *that* before worrying about any of the more structural aspects here
12:31:32 <Cale> My forkApp idea may or may not work, as EvanR pointed out
12:31:45 <Cale> If you're not allowed to do DB communication from more than one thread
12:32:01 <EvanR> i find it odd that SqlPersist would make the connection pool thread safe while not giving you a way to fork or access the thread pool, so somethings not right with this picture
12:32:13 <saurabhnanda> Cale: doesn't matter. IF two threads write to Sqlite one will block momentarily. If two threads read, they'll work.
12:32:32 <Cale> saurabhnanda: Okay, so long as you already know that
12:32:33 <EvanR> saurabhnanda: not on the same connection...
12:32:56 <EvanR> the same fd basically
12:33:19 <Cale> I really hate how almost all non-Haskell software sucks when it comes to threads
12:33:32 <saurabhnanda> EvanR: I think that's the reason why it's not allowing me to unify two threads in a single SqlPersistT action
12:33:41 <EvanR> you can open the sqlite database again (on not windows) and itll work
12:33:44 <saurabhnanda> but it's fine with passing the ConnectionPool around to separate threads.
12:33:48 <EvanR> for reading at least
12:34:12 <EvanR> saurabhnanda: it sounds like its not designed for async
12:34:14 <Cale> saurabhnanda: If you think it'll work you can just pass the ConnectionPool over to the other thread.
12:34:27 <Cale> I can't say for sure whether it'll work or not
12:34:27 <saurabhnanda> Cale: that's what I'm doing right now
12:34:36 <Cale> okay, if it works it works
12:34:48 <EvanR> if it doesnt, its not going to be pretty
12:34:51 <saurabhnanda> Cale: wrt Sqlite it's a design decision.
12:35:11 <saurabhnanda> Cale: not supporting concurrent writes. To keep things simple. Sqlite's use case is primarily single user applications.
12:35:35 <saurabhnanda> well, an sqlite pool can't be too useful it multiple threads can't share it
12:35:54 <EvanR> i think your library is designed for many different kinds of databases
12:35:56 <saurabhnanda> and if multiple threads are sharing a *pool* it'd be dumb to not give each thread a seaprate connection.
12:35:58 <EvanR> Sqlite is the least concurrent
12:36:07 <Cale> saurabhnanda: yeah, good point
12:36:19 <EvanR> whats the point of the pool then
12:36:21 <saurabhnanda> I'm assuming since Michael Snoyman has written it, it can't be too bad.
12:36:24 <EvanR> just make a new pool
12:36:45 <EvanR> on another note, this sounds like a hugely overflow system to just use an Sqlite database
12:36:49 <EvanR> overblown
12:36:53 <Cale> EvanR: It's a pool of connections to be used by multiple threads
12:37:07 <Cale> and yeah, this isn't just for Sqlite
12:37:22 <Cale> You can swap out the DB backend for postgres or something
12:37:26 <Cale> if you want
12:37:33 <EvanR> that adds another aspect to the decision here
12:37:50 <EvanR> if youre using sqlite for serious, you can simplify your life a lot
12:38:15 <Cale> It is nice to be somewhat independent of your storage layer though
12:38:25 <Cale> (especially since they're all terrible)
12:38:42 <EvanR> its nice to be independent of storage layers ;)
12:38:48 <EvanR> i.e. just use postgres only
12:39:19 <saurabhnanda> EvanR: new info -- I want to FINALLY run this on a raspberry pi. So Postgres is out
12:39:43 <EvanR> well if you are intending to use sqlite, that simplifies everything
12:39:44 <EvanR> potentially
12:40:05 <saurabhnanda> so, it looks like the same pool can be passed to multiple threads, right?
12:40:06 <Cale> I don't entirely hate the idea of using persistent
12:40:30 <EvanR> im not sure what raspberry pi has to do with it
12:40:33 <Cale> I use groundhog all the time at work, and it's basically the same library as persistent (it was forked from a common ancestor)
12:40:38 <EvanR> its designed to run whatever the hell you want like a PC
12:40:46 <Cale> It's not great if you ever need to do a JOIN
12:40:58 <EvanR> need to do a join?
12:41:03 <Cale> but if all you want to do is stash a bunch of records and get them back later
12:41:09 <EvanR> i thought all these layer layers compiled into joins for performance
12:41:12 <Cale> It's pretty convenience
12:41:18 <Cale> convenient*
12:41:42 <saurabhnanda> EvanR: not using postgres (targeting raspberry pi -- limited resources)
12:41:46 <Cale> EvanR: nope, they don't even let you express anything which would involve a JOIN
12:42:05 <saurabhnanda> Cale: esquelato built atop persistent
12:42:07 <saurabhnanda> I think
12:42:09 <Cale> So you often end up writing SQL by hand anyway
12:42:18 <Cale> well, yeah, one way or the other :)
12:42:30 <EvanR> >_<
12:42:35 <saurabhnanda> I get the general feeling that #haskell doesn't use Persistent much
12:42:43 <EvanR> its very popular it seems
12:43:07 <Cale> We should actually look into using something like esqueleto
12:43:41 <saurabhnanda> EvanR: Cale: both of you work at the same place?
12:43:44 <Cale> But really we're just going to do something much much better once we get a chance to revisit this
12:43:48 <Cale> no
12:44:06 <Cale> I'm referring to the company I work for, Obsidian Systems
12:44:15 <saurabhnanda> ah, was guessing that
12:44:21 <saurabhnanda> does jle` also work there?
12:44:35 <EvanR> classified
12:44:43 <Cale> I don't think he does...
12:44:52 <Cale> Unless we just hired him or something
12:44:57 <Cale> and I didn't find out yet
12:45:03 <saurabhnanda> okay
12:45:22 <saurabhnanda> EvanR: if you don't mind my asking, where do you work? Are you using haskell professionally?
12:45:24 <EvanR> saurabhnanda: for resource limited, id definitely simplify the thing to not need transformers
12:45:46 <saurabhnanda> EvanR: mtl has resource overhead? compiler doesn't optimize it out?
12:45:47 <EvanR> not that its going to be that detrimental but i feel better about just using functions
12:45:55 <EvanR> with immutable data
12:46:17 <EvanR> transformers do introduce overhead
12:46:38 <EvanR> its point isnt to speed things up but to supposedly make your architecture more digestible
12:46:42 <saurabhnanda> EvanR: yup -- that code is already written, and if mtl is going to result in lifing, I'm sticking with params.
12:46:50 <Cale> Ryan has a plan which I don't completely understand yet to make a preprocessor which will compile Haskell code (or some sizeable fragment of pure Haskell expressions) into code which is polymorphic over a choice of Category instance (really need more structure than just Category of course)
12:46:54 <saurabhnanda> immutable data == company name?
12:47:11 <EvanR> Cale: ah yeah, like the lambda-ccc thing from conal
12:47:13 <Cale> and then to use that with an appropriate category for expressing database queries
12:47:30 <Iceland_jack> balth: check out https://www.youtube.com/watch?v=qNeRZS8ZCKw
12:47:44 <Cale> So that we can write what looks like Haskell code, and have it just make the queries we want with appropriate joins and whatnot.
12:48:12 <saurabhnanda> EvanR: Cale: thanks for the help. I need to go sleep now. 1.17am here. 
12:48:24 <Cale> In addition to *that* or even as a distinct project, what I really want is to hook up Reflex to the DB layer
12:48:53 <saurabhnanda> one last question, what would be the best way to get 1-2 hours of someone's time to review my code (I'm fine with compensating with money, as well).
12:48:59 <Cale> But this might involve just writing our own DB, because most databases don't really appear to have the notification machinery that we'd want.
12:48:59 <balth> Iceland_jack: thanks
12:50:11 <Cale> We'd want a way to register a set of queries with the DB, and whenever a transaction commits which would cause the rows in a registered query to change, you'd get a message back from the DB with what amounts to a diff.
12:50:36 <Cale> I also desperately want sum typed columns
12:51:25 <Cale> Because the lack of sum types at the DB layer is propagating to create all sorts of other problems throughout our architecture at present
12:52:05 <Cale> and even when it doesn't manage to do that, it's still really awkward
12:52:53 <EvanR> Cale: well, theres so much that could be done with databases... they just havent, in the non-commercial area
12:53:11 <EvanR> and nerds dont like commercial databases
12:54:01 <Cale> Oracle *kinda sorta* has this notification feature, but it seems to be somewhat incomplete -- might be usable.
12:54:14 <EvanR> Cale: i had success with SQL by using one column for the construct, then N columns, different for each ctor even if its the same sql type
12:54:17 <Cale> But the problem with Oracle is that in order to get it to perform well involves hiring a specialist
12:54:18 <EvanR> and the rest nulls
12:54:59 <rightfold> I'm using Alex and I want some tokens to be case-insensitive. For example, I currently have end { \_ _ -> return End }, but I also want to match END, End, eNd, etc, is there a neat way to do that? I only want this for some tokens, not all of them
12:55:02 <Cale> We're not really opposed to using commercial databases
12:55:10 <EvanR> like (leftOrRight, string foo nullable, integer bar nullable)
12:55:14 <EvanR> or two strings
12:55:21 <dolio> There are commercial databases with sum types?
12:55:34 <Cale> dolio: Yeah, that's the other thing, I don't think that even exists
12:56:06 <Cale> Which is really dumb, I don't know how the entire industry has missed this for so many decades
12:56:28 <Cale> It's not like relational algebra has nothing to say there
12:56:30 <dolio> I thought no one did them because they're against the Principles that everyone lives by with respect to databases.
12:56:45 <Cale> Which principle?
12:57:11 <dolio> Pretty sure there's one in the list that is basically, 'no sum types; use relations.'
12:57:12 <Cale> It seems like they solve problems wherein it's impossible to express the data you want without being unprincipled.
12:57:26 <EvanR> i will have to go back and find all these advanced databases that no one cares about
12:57:54 <Cale> People always end up using a pair of nullable columns
12:58:03 <EvanR> which works
12:58:17 <dolio> It's also wrong, though, I think. :)
12:58:20 <Cale> only in that (1 + A)*(1 + B) = 1 + A + B + A*B is an approximation to A + B
12:58:35 <EvanR> dolio: its dependently typed ;)
12:58:51 <EvanR> the proper form of a row is in your head, as usual
12:59:09 <EvanR> but at least by not collapsing nullables into one column you can practically do queries on the data
12:59:10 <dolio> Yeah. But you're supposed to not have null columns, and instead do the depending by indexing into completely different tables.
12:59:13 <dolio> Or something.
12:59:13 <EvanR> without checking the tag
12:59:29 <Cale> and then you end up in expensive situations where a bug has caused your application to write data which has both A and B filled in
12:59:32 <EvanR> dolio: well, most database techniques on that subject are just wrong
12:59:45 <Cale> and some poor guy has to go through every record by hand and work out which is the correct value
12:59:52 <EvanR> for this purpose were lucky they have null columns
13:00:42 <Cale> (which might involve, you know, phone calls and shit)
13:00:55 <ddellacosta> So, I'm doing the exercise : "Write a definition of (<*>) using (>>=) and fmap. Do not use do-notation." from https://en.wikibooks.org/wiki/Haskell/Applicative_functors.  I've come up with 'f a1 a2 = a1 >>= (flip fmap) a2'
13:01:05 <ddellacosta> but I'm curious if it's possible to make this point free?  I'm having trouble figuring out how to do so.
13:01:14 <Cale> @pl f a1 a2 = a1 >>= (flip fmap) a2
13:01:15 <lambdabot> f = (. flip fmap) . (>>=)
13:01:34 <ddellacosta> omg there's an automated thing to do that!?  haha
13:01:36 <Cale> "yes"
13:01:36 <ddellacosta> thanks Cale
13:01:37 <EvanR> Cale: this is an old lesson from php/rails, you better make sure your code is not wrong before accessing the database
13:01:51 <EvanR> its trick is knowing what it wrong
13:01:52 * ddellacosta goes to think about that for a bit
13:01:57 <Zemyla> ddellacosta: Start by removing the first variable, so f a1 = (a1 >>=) . flip fmap.
13:02:13 <ddellacosta> Zemyla: actually I got that far--the second one stumped me
13:02:40 <ddellacosta> I actually ended up with a flipped version, ff4 a2 = flip (>>=) $ (flip fmap) a2
13:02:43 <Cale> You could also solve that problem by using do-notation and then desugaring the do-notation.
13:02:49 <ddellacosta> but couldn't figure out how to get past that
13:03:00 <Zemyla> Rearrange it, so it's f a1 = (.) (a1 >>=) (flip fmap), which is (. flip fmap) (a1 >>=).
13:03:03 <ddellacosta> Cale: ah, didn't think of that as an option
13:03:15 <Zemyla> Which then becomes (. flip fmap) . (>>=)
13:03:19 <Cale> @undo ap mf mx = do f <- mf; x <- mx; return (f x)
13:03:19 <lambdabot> ap mf mx = mf >>= \ f -> mx >>= \ x -> return (f x);
13:03:26 <ddellacosta> neat
13:03:44 <Cale> @undo ap mf mx = do f <- mf; fmap f mx
13:03:45 <lambdabot> ap mf mx = mf >>= \ f -> fmap f mx;
13:03:45 <ddellacosta> although, the exercise asks me to use fmap, so I would have had to figure that out still I suppose
13:03:59 <ddellacosta> ah, okay
13:04:14 <ddellacosta> Zemyla: thanks for that too, that's helpful
13:04:16 <Cale> I honestly prefer this version with the lambda
13:04:29 <Cale> There's very little value in making this one points-free
13:04:32 <ddellacosta> yeah, the lambda makes it explicit I suppose
13:04:56 <ddellacosta> Cale --for me it was mostly an exercise to make it pointfree, I wanted to try to understand how to do it
13:05:01 <Cale> ah, okay
13:05:30 <ddellacosta> cool, as usual #haskell has lots of great feedback--thanks folks.
13:05:37 <Cale> Well, you don't have any variable duplication to contend with here, so it's all about sorting out how to get the last parameter to the end of expression
13:05:44 <Cale> and then cancelling it from both sides
13:05:48 <ddellacosta> Cale, right, makes sense
13:05:54 <ddellacosta> gotta keep practicing I suppose
13:07:34 <Zemyla> I need to figure out how long a list of characters needs to be before it's faster to check whether a value's in it with Set.member than with elem.
13:08:38 <EvanR> heh
13:09:11 <EvanR> id like to see benchmarks for that run on differnt computers
13:11:43 <EvanR> Zemyla: also IntSet of the char number
13:15:43 <Zemyla> EvanR: Or, if you want to use up to 136 KB of memory per character set, a full bitvector.
13:16:39 <EvanR> Zemyla: ah yeah... you can get a lot of traction out of bloom filters here
13:16:40 <Cale> btw, if you make a UArray of Bool values, it does bitpacking
13:16:47 <EvanR> oh wow
13:17:04 <Cale> So you could use UArray Char Bool
13:17:24 <Zemyla> Cale: Unboxed.Vector Bool doesn't, though.
13:17:35 <EvanR> so Array does have some nifty advantages
13:17:52 <Zemyla> However, it still has to check against a pair of bounds every time.
13:18:12 <Cale> There is unsafeRead...
13:18:13 <EvanR> every time what
13:18:16 <EvanR> ^
13:18:56 <Zemyla> Actually, there's another option if you don't want to use 136 full KB of memory.
13:19:10 <Cale> er, unsafeAt
13:19:56 <Zemyla> You use an array of 17 8-KB arrays, and have a special one for "empty" whenever there's no "yes" values in that plane.
13:19:59 <Zemyla> It enables reuse.
13:20:49 <EvanR> having flashbacks to C coding where this is a normal activity
13:21:40 <EvanR> IntSet
13:22:09 <Cale> Then again, are we sure this is a performance bottleneck?
13:24:11 <Zemyla> No, but it's an interesting thought exercise.
13:24:37 <EvanR> id be interesting in a race between [Int] and IntSet
13:24:48 <EvanR> but i need coffee first
13:25:49 <monochrom> haha
13:26:16 <EvanR> interested*
13:31:55 <jophish_> Hi all
13:42:52 <Zemyla> Okay, I obviously did something wrong.
13:43:49 <Zemyla> Parsing a 16 character string should not take 2.5 GB of memory.
13:44:16 <glguy> Maybe there were particular wide characters
13:44:54 <hpc> character U+91872634987162398576129387461982374
13:46:32 <glguy> It's the new UTF-2^30 encoding
13:46:56 <Iceland_jack> glguy: You're joking but..
13:51:26 * geekosaur wonders which emoji U+91872634987162398576129387461982374 is :p
13:51:59 <benzrf> how does garbage collection work in haskell?
13:52:05 <benzrf> er, in ghc really
13:52:13 <EvanR> very well thanks
13:52:44 <mniip> benzrf, it's a copying GC
13:52:45 <EvanR> </startrektechconsultant>
13:52:49 <hpc> benzrf: google "ghc trac commentary" for Far More Than You Ever Wanted To Know(TM)
13:53:38 * hackagebot vty 5.7 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.7 (JonathanDaugherty)
13:53:49 <hpc> some of it's really ingeniously simple, and some of it is just massively clever
13:54:18 <Peaker> benzrf, it's a generational collector.  I might get some details wrong: Has a nursery with 2 areas in it.  (small) allocations advance a ptr in the active nursery area.  When the active nursery hits its end, a minor GC is triggered, which copies the live parts of the nursery to the other area (or if copied multiple times, to a higher generation).
13:54:24 <hpc> like, one thing you can do is assume immutability for most things, and allocate in a way that you can efficiently determine if one thing is older than another
13:54:41 <hpc> and you can assume the older allocation doesn't refer to the newer allocation totally safely
13:55:19 <hpc> Peaker: that's how i undertand it too
13:55:24 <Peaker> benzrf, the idea is that older generations tend not to point to newer generations, and a "write barrier" is used to catch that when it happens (and promote the pointee to an older generation).  That way, when collecting, you can usually avoid traversing the old generation, and only traverse the young roots and objects
13:56:15 <Peaker> so a "minor collection" iterates the young objects, compacting them, and does not pay for traversal of old objects.  More rarely, a "major GC" happens, and then you iterate older generations too, and cry for your latency
13:56:33 <hpc> i don't think it hurts latency anymore
13:56:44 <hpc> but i might be mistaken
13:56:45 <EvanR> performMajorGC during a lul in your interactive program
13:56:56 <Peaker> hpc, it's not a concurrent GC, it also syncs up all threads
13:56:59 <luite> hpc: it still does for large heaps, it's parallel but not concurrent
13:57:00 <geekosaur> depends on how tight your timing needs to be
13:57:07 <hpc> ah
13:57:18 <EvanR> also ghc has different GCs
13:57:19 <hpc> i guess that's still the one thing jvm has over ghc
13:57:36 <Peaker> I had my background thread computing stuff completely ruin responsiveness for my GUI thread because it was syncing it up for frequent GCs as it was thrashing allocations in the background
13:57:42 <EvanR> im not sure if any have better latency-on-collecting-a-huge-heap than the default
13:58:33 <hpc> the big thing about the generational gc that ghc uses, is that it's really cheap to do lots of short-lived allocations
13:58:39 <hpc> which is what haskell code also tends to do
13:58:40 <Peaker> EvanR, Swift just uses refcounting, which is IMO a better compromise.  You have to be aware of it to avoid cycles explicitly -- but right now I have to be aware of much more subtle GC things, and tune the hell out of my GC which I find more difficult than breaking cycles
13:59:03 <c_wraith> The other thing to remember about GHC's GC is that collection time is proportional to the size of the live set.
13:59:15 <hpc> even after optimizing things into non-allocating assembly and whatnot
13:59:21 <c_wraith> Generating lots of garbage is less of an issue than retaining a huge amount of data.
13:59:22 <Peaker> hpc, I think the cheapness is overstated -- I've need large nurseries in many programs, and that thrashes the cache.  Stack/lifo allocations are much more cache friendly
14:00:04 <hpc> well yeah, you're still allocating a lot
14:01:25 <hpc> what have you needed large nurseries for?
14:02:11 <EvanR> Peaker: i havent seen it yet, but i wish there were a gc like GHCs but which had its own internal "compromise" for helping latency, which didnt involve knowing about referentially opaque details of the code. but... i get the feeling haskell doesnt like compromise
14:02:30 <EvanR> i really dont want to treat my data like swift data
14:02:35 <EvanR> or python or whatever
14:02:36 <Peaker> hpc, in buildsome, a nursery <8MB causes >75% GC time
14:02:50 <Peaker> hpc, >8MB reduces GC time to ~20% IIRC
14:03:37 <EvanR> i would prefer to be able to tune it than redesign my code, then pay a constant ref counting tax
14:03:55 <Peaker> EvanR, Traversing *all* data of the program seems like a no-go for me (I dislike tracing GCs).  Rust/Swift approaches make better compromises
14:03:56 <luite> Peaker: swift data stuctures are perhaps more mutable on average? maintaining the refcounts on otherwise immutable data structures would cause a lot of cache invalidation on multi-cpu systems. does the swift runtime have something to help that (and does it have compaction or other means of reducing fragmentation?)
14:04:24 <Peaker> luite, it's not a tracing GC, so I doubt it can compact
14:04:37 <EvanR> Peaker: yes, it doesnt seem like traversing all data is strictly necessary, but current gcs find it strictly necessary to ensure youll get enough memory back
14:05:03 <Peaker> EvanR, how can it be avoided in a non-refcounting GC?
14:05:35 <Peaker> luite, maintaining refcounts is also terrible, yes. But not as terrible as a program that pays O(data size) in computation repeatedly with time
14:05:52 <EvanR> i dont see anything standing in the way, and i dont see why reference counting is the only way
14:06:11 <EvanR> but i dont have a clear idea of how it would guarantee recover of enough memory
14:06:20 <EvanR> a gc which continues to leak unnecessarily isnt working
14:06:39 <Peaker> EvanR, leak because of cycles, you mean?
14:06:51 <EvanR> no because of not completing enough of the recovery now
14:07:07 <EvanR> like, only get 10% of memory back now, then continue running and youre not catching up
14:07:50 <EvanR> but the issue sounds like youre just struggling with allocating huge buffers of large objects and then disposal is a bitch, this seems like a special situation which warrants some kind of extra strategy
14:07:54 <Peaker> EvanR, partial traversals are basically what you do with newer generations, but eventually you're going to need to pay the full traversal
14:08:03 <EvanR> allocate huge objects yourself and manage them yourself outside the gc
14:08:09 <EvanR> Peaker: right
14:08:20 <Peaker> EvanR, I don't think it was huge objects, just a large heap made of ordinary sized objects
14:08:30 <EvanR> i am trying to figure out how to do partial on the full thing, which is why it might not make sense
14:08:56 <EvanR> but to me it doesnt make sense to mandate a full stop and full collection of everything at once
14:09:13 <EvanR> unless theres a proof that that is completely required by laws of physics
14:09:23 <Peaker> I think you will have to maintain some properties about the connectivity of the subset you're traversing (as aged generations do) or else you will have no information about untraversed data until you've traversed it all
14:09:43 <EvanR> sure fine, were kind of trying to lose performance
14:09:52 <EvanR> "take my money dammit"
14:09:55 <Peaker> EvanR, with read/write barriers you can do concurrent GC rather than stop the world
14:09:59 <EvanR> thats the compromise
14:10:18 <EvanR> again, does that ensure youll reclaim enough memory?
14:10:32 <EvanR> i havent looked into what ghc's other GCs do
14:10:39 <EvanR> i just know they dont feel good enough about them to make them default
14:11:21 <luite> Peaker: do you know of situations where the memory bandwidth becomes a limiting factor due to that? in recent cpu architectures total bandwidth to local memory scales more or less linearly with the number of corse. nonlocal memory not so much, but the GC should be able to optimize its access patters much more than a refcounting system
14:12:06 <Peaker> luite, GC is ptr-chasing, how does it optimize its access patterns?
14:12:34 <Peaker> luite, you might be able to BFS your access pattern a bit (AFAIK no GC does that, could be interesting), but in many cases you'll have a long list of ptrs to chase DFS-only
14:12:44 <EvanR> arrange objects that refer to each other closer in memory
14:13:03 <Peaker> EvanR, objects have a fanout > 1, that quickly becomes impossible
14:13:30 <Peaker> EvanR, for objects with fanout <= 1 that is a good strategy, and will indeed happen usually in ordinary DFS/compacting GC
14:13:33 <EvanR> is that typical
14:14:27 <Peaker> I am guessing most objects are probably leafs, requiring fanout of nonleaves to be >=2
14:14:52 <Peaker> otherwise you have a long chain of objects, which does not match my intuition for how a heap looks like :)
14:15:39 <EvanR> well the main concern is apparently lag on major GC for huge heaps
14:15:57 <luite> Peaker: I don't know anything about existing implementations in this space, but at least the GC can choose the traveral order. perhaps if something points to a nonlocal page it's cheaper to pass the work to another GC thread that runs on a core closer to that memory
14:16:31 <Peaker> EvanR, I think, though for larger nurseries (which I've needed) I am not sure the minor collections are cheap enough either. I happened not to care about latency in the specific cases I needed larger nurseries
14:17:06 <Peaker> luite, Even if you ignore NUMA for a sec, ptr chasing is very expensive
14:17:27 <EvanR> well if you dont care about latency you can use non generational and only collect when you run out of memory ;)
14:17:54 <Peaker> EvanR, nursery collections supposedly improve locality, so may be worth doing prematurely
14:17:55 <EvanR> Ur-web i heard doesnt do any GC and just collects when the request is over
14:18:13 <Peaker> no regions?
14:18:19 <EvanR> i dont know
14:18:39 <luite> EvanR: PHP too :p
14:18:43 <EvanR> lol
14:18:44 <luite> or at least it used to
14:19:14 <EvanR> i guess it makes sense for PHP?
14:20:49 <luite> oh no wait, i think I'm wrong here. I think it was something like PHP uses refcounting but there's some optional way to reclaim memory from circular refs during a request
14:21:21 <Cubesoup_> I'm having trouble building cabal 1.24.0 with ghc 8.0.1 on an armv7 platform: in particular, when running the bootstrap.sh script, many things compile, but I get a "failed to load interface for 'Distribution.Text'" error at some point. Does this ring any bells?
14:21:22 <luite> maybe that's not quite on-topic here though :)
14:22:01 <EvanR> if it helps PHP latency, then its on topic for possibly out-doing GHC haha
14:22:12 <EvanR> which would be embarassing
14:43:28 <tippenein> Has anyone attempted generating servant crud endpoints for a data type? It seems like I get a lot of boilerplate for each entity I have.
14:48:30 <Habib> Hey, does anyone know how arguments are supposed to be passed in to System.Plugin.Make.make from the `plugins` package? It's a function that takes an array of string arguments that are passed on to the `ghc` command.
14:48:58 <Habib> Using -outputdir doesn't redirect the output to the expected directory, though it does when manually invoking ghc from the command line.
14:58:41 * hackagebot opml-conduit 0.5.0.1 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.5.0.1 (koral)
15:07:10 <Mateon1> Hello, how do I resolve a relative FilePath to an absolute one? I can't find anything in hoogle
15:09:02 <Mateon1> Oh, I think I got it, getCurrentDirectory </> fp
15:25:42 <hhhv2> Hi 
15:28:07 <AleXoundOS> hi
15:28:22 <zeitgeist7> hello
15:29:20 <sidraval> th
15:42:12 <Welkin> ST is amazing
15:42:25 <Welkin> I finally realized how it can (should?) be used
15:42:55 <Welkin> completely pure functions with encapsulated mutations (if you like)
15:43:03 <Welkin> and just treat them like pure functions
15:43:40 <glguy> sounds like you get it. How does that differ from your previous understanding?
15:43:47 <Squarism> is there some simplification to concurrency libs available (commonly used data types and functions used). In parcon the seem to define alot helper functions that could be in some api i feel
15:43:49 <Welkin> I didn't have much previous understanding
15:43:58 <Welkin> it was just a vague concept about state threads
15:46:09 <Welkin> it finally sunk in once I wrote a program using ST just now
15:46:34 <slack1256> I wrote a lot of algorithms on the ST monad because I didn't know C.
15:46:45 <slack1256> It was tolerable
15:47:02 <Squarism> what is ST? 
15:47:05 <Squarism> not STM?
15:47:20 <EvanR> Squarism: parcon? seems like youre talking about parallel. one cool concurrency lib is async
15:47:24 <thimoteus> no, not STM
15:47:26 <Welkin> Squarism: it will blow your mind
15:47:39 <thimoteus> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-ST.html
15:47:46 <Welkin> https://wiki.haskell.org/Monad/ST
15:47:54 <Welkin> that is what made it clear to me
15:47:57 <slack1256> Squarism: it is like `IO` but pure in the sense that doesn't leak state
15:48:51 <Squarism> im a noob fumbeling in the dark. But i need concurrency for my program
15:50:11 <koz_> Squarism: Do you need concurrency, parallelism or distribution?
15:50:29 <Squarism> EvanR, Parts of the parconc book is talking about concurrency in general. 
15:51:04 <Squarism> koz_, concurrency only
15:56:34 <Squarism> i want to syncronize state on N number of 2 player games on a server with some M users. All users have a connection  
16:07:22 <Qqwy-WM> Squarism: Have you heard about the Actor Model?
16:07:37 <Qqwy-WM> I believe there is a library for Haskell that implements it
16:07:59 <Qqwy-WM> it is a very neat way of doing concurrency that mitigates many common problems that other approaches have
16:08:44 <Squarism> Qqwy-WM, i have used it in scala. But it received some critizism there? I thought it was a dead end?
16:10:36 <Qqwy-WM> There is no silver bullet, but I completely disagree with 'it is a dead end'. Erlang has used it for thirty years, with great success.
16:11:02 <geekosaur> maybe it's a dead end for scala for some reason
16:11:25 <slack1256> or the people that use erlang know that the actor model is a great fit for their problems
16:11:27 <Qqwy-WM> That might indeed be the case. I'd love to read about criticsim there :-)
16:12:36 <Qqwy-WM> But yes, what the best approach might be really depends on the problem you have at hand
16:12:53 <Qqwy-WM> Maybe you'd also like to look into State Transactional Memory
16:13:26 <Squarism> cant say i know much about it.. Overall. Im not very vetted in concurrency at all. i could be totally wrong. Just something i picked up
16:15:07 <Squarism> Qqwy-WM, where should i start if i want to learn about haskell actors?
16:18:18 <slack1256> or just take the "low effort/good power" option and just use MVars
16:18:20 <drem> hi! I'm trying to get to grips with monad transformers by making a small example app with scotty. my goal is to make a page that displays the number of times an endpoint has been visited: http://lpaste.net/168153
16:18:53 <Qqwy-WM> Squarism: I have only used them myself in Elixir, but I know that there are multiple packages on Hackage that provide similar functionality, such as: simple-actors, hactors, hactor, actor, nano-erl.
16:19:20 <drem> i'm trying to keep track of the number of times in the stateT monad, but I'm not exactly sure how it's supposed to look. anyone got any pointers? (i'm aware i'm not incrementing anything yet)
16:19:23 <Squarism> ok. Ill google around for what seems hot and not
16:20:18 <Welkin> drem: https://wiki.haskell.org/State_Monad
16:20:24 <Welkin> I found that helpful
16:21:43 <drem> Welkin, I read that. :) however, i'm not sure how I would use it together with scotty in a monad transformer stack
16:22:24 <jle`> drem: just use it like you'd normally use scotty
16:22:34 <jle`> except now you have 'modify', 'get', 'put', etc.
16:23:28 <jle`> (and you use 'lift' to use normal scotty actions)
16:24:19 * Iceland_jack . o O ( lift me up Scotty )
16:24:24 <jle`> you can turn a 'StateT s m a' action back into a normal m-action with runStateT :: StateT s m a -> s -> m (a, s)
16:24:25 <jle`> Iceland_jack: :P
16:26:15 <jle`> drem: so if your normal program is something that runs an 'm a', you can write a 'StateT s m a' and turn it into an 'm a' with evalStateT :: StateT s m a -> s -> m a
16:26:27 <drem> http://lpaste.net/168153 here I get an error telling me there's no instance for MonadState Int (ActionT T.Text IO). I would think that using get would get me the Int from LeviT?
16:26:38 <jle`> you can think of 'StateT s m a' as a fancy way to write an 'm a'
16:27:37 <jle`> drem: ah wait, you might be using 'get' from Control.Monad.State, from mtl
16:27:44 <jle`> instead of Control.Monad.Trans.State, from transformers
16:28:12 <drem> jle`, I am. is that not a good idea? what are the differences between the libraries?
16:28:23 <jle`> it's nice, but it depends on what you're trying to learn
16:28:26 <jle`> if this is for learning purposes
16:28:46 <jle`> using 'get' from mtl teaches you how to write generic stateful programs, instead of how to use monad transformers
16:28:53 <jle`> they're sort of unrelated
16:29:01 <jle`> except they happen to have the same identifier
16:29:31 <hpc> @unmtl StateT s m a
16:29:32 <lambdabot> s -> m (a, s)
16:29:41 <jle`> but yeah, one of the issues here is that Scotty.get takes a ScottyM, not a 'StateT s ScottyM a'
16:29:49 <hpc> it's not quite (m a), but you can get (m a) out of it with some wrangling
16:29:52 <Welkin> lol
16:30:11 <jle`> hpc: yeah, you can use it to write an 'm a', and use evalStateT to get the 'm a' out of it
16:30:15 <jle`> :t evalStateT
16:30:16 <lambdabot> Monad m => StateT s m a -> s -> m a
16:30:50 <hpc> oh, my scrollback got stuck, that was in response to "you can think of 'StateT s m a' as a fancy way to write an 'm a'"
16:30:59 <hpc> which is perilously burrito-sounding
16:31:07 <hpc> but yeah
16:31:19 <jle`> well, 'StateT s m a' really is a tool to specify an 's -> m a' that you might want
16:31:19 <Welkin> hpc: perpetually on steam, but never plays any games
16:31:36 <jle`> so it's an abstract way of writing an 'm a' that gives you extra state if oyu want
16:31:43 <jle`> i didn't say anything about its implementation
16:32:01 <jle`> the fact that it's implemented with an (s -> m (a, s)) underneath is an implementation detail, and is unrelated to its API/usage
16:32:59 <jle`> drem: but yeah, the way things are set up here, you can't quite use StateT to get your goal, because S.get takes a ScottyM, not a StateT s ScottyM
16:33:43 * hackagebot pipes-random 1.0.0 - Producers for handling randomness.  https://hackage.haskell.org/package/pipes-random-1.0.0 (fosskers)
16:33:46 <hpc> :t lift
16:33:47 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:34:15 <hpc> oh, that was mentioned above too
16:34:54 <drem> ok
16:36:27 <jle`> yeah, 'lift' helps you when the 'm a' is in the result of the function
16:36:36 <jle`> but it doesn't help you if the 'm a' is in one of the arguments of the function
16:36:51 <drem> yeah 
16:37:04 <drem> i kind of understand what I'm doing wrong
16:37:32 <drem> as I'm making a function Int -> ScottyM ((), Int)
16:38:19 <drem> is far as I understand
16:38:32 <hpc> \i -> lift (S.get i)
16:38:33 <jle`> yeah, StateT would help you write an Int -> ScottyM ((), Int) in potentially a more clean way
16:38:36 <jle`> a more composable way
16:39:35 <jle`> so, if something takes a ScottyM ((), Int), you can "write" it using StateT s m a.  but you have to get the Int from somewhere to get the ScottyM ((), Int) out of the StateT
16:40:54 <drem> yeah. it's not really what I'm trying to do though, I'm trying to keep the Int in a StateT so that when an action happens in Scotty, the StateT gets updated
16:41:05 <drem> so I'm trying to use StateT for some sort of persistence
16:41:09 <jle`> yeah, and that's not something that StateT is meant for
16:41:12 <jle`> or is capable of
16:41:16 <drem> oh
16:41:25 <jle`> if you think about it, doing something like that is a bit non-trivial
16:41:41 <jle`> because scotty is a concurrent web server, right?
16:41:48 <jle`> and what if multiple requests come at the same time
16:42:36 <drem> yeah that's true
16:42:37 <jle`> StateT isn't really magical...it's basically a way to write an `s -> m (a, s)` more cleanly
16:42:52 <jle`> something like what you're asking for would have to be able to handle parallel/concurrent requests across different threads, etc.
16:43:19 <Clint> only burritos are magical
16:45:57 <drem> okay, I guess using StateT to keep some sort of persistent state isn't the way to go then. how would you do persistence instead? not taking into account the possibility of multiple requests at the same time etc.
16:46:39 <jle`> for a simple way, you can use an MVar
16:47:16 <drem> jle`, okay. haven't looked at those yet, so I'll go read up on them :)
16:47:20 <jle`> which is a thread-safe reference to a container that you can read and modify in your request
16:47:33 <Welkin> lol
16:47:40 <Welkin> it's like a global variable
16:47:50 <jle`> it's not global :O
16:49:04 <jle`> drem: the docs for MVar are pretty nice, and i always liked simon marlow's chapter on them + threads: http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
16:49:29 <Welkin> I've been building crud web apps for so long, I haven't even dug into the best parts of haskell yet
16:49:42 <drem> jle`, thanks a lot!
16:49:54 <jle`> np!
16:50:15 <mauke> sometimes you can use an MVar as an implicit queue because it guarantees order
16:50:23 <Welkin> I notice there is no sort defined for Text
16:50:52 <hpc> if you're going to be using MVar as a queue though, just use Chan
16:51:02 <qinusty> Hey guys, I'm just trying to get into haskell development and learn the basics. I've been working on something today and was wondering if anyone knows anywhere to get code reviewed by others? Like a subreddit, forums etc
16:51:15 <hpc> the purpose is more obvious, the API is more pleasant, and you don't block quite so hard
16:51:16 <AbelianGrape> I'm going to be doing some text processing on a dictionary file. I'll take each entry, expand it into, say, 1000 more entries, concatMap that into one big list, and then filter through that. Are lists the most efficient thing to use here? Is there some stream library that will work better?
16:51:47 <Welkin> AbelianGrape: I have processed massive dictionary files using haskell before
16:51:48 <Cale> qinusty: Sometimes someone here might have a look at it
16:51:52 <Welkin> you can just use String
16:51:59 <Welkin> it rans in a few seconds
16:52:01 <Welkin> ran*
16:52:05 <Welkin> no optimizations at all
16:52:07 <Welkin> used parsec
16:52:09 <hpc> MVar's ordering is mostly just there as a "don't let anything starve" than as a piece of usable logic
16:52:20 <Cale> qinusty: There is a Haskell subreddit you could try. There are also mailing lists.
16:52:25 <AbelianGrape> Welkin: The question is what I should use to stream the billions of objects I'm generating *from* the dictionary
16:52:43 <Welkin> you could try pipes
16:53:03 <AbelianGrape> My concern here is that each Cons-list element will use a pointer deref, whereas some sort of more packed representation might not
16:53:10 <Cale> Lazy lists actually aren't typically that bad... there's logict which is a continuation-based implementation of nondeterminism
16:53:14 <AbelianGrape> I guess that's probably inevitable
16:53:41 <Cale> and the pipes package has its own "ListT-done-right"
16:54:00 <mauke> hpc: sometimes you want blocking behavior
16:54:01 <hpc> the lazy perspective on lists is that they are loops waiting to happen
16:54:20 <Cale> But my approach would be to write it with the list monad first, and then maybe replace the list monad with something else if it wasn't performing well enough
16:54:20 <qinusty> Oh alright Cale, I'll just leave this here, if anyone feels like looking at some beginner haskell code :P https://github.com/Qinusty/blackjack-haskell/tree/master/src
16:56:13 <Cale> qinusty: This looks alright to me -- are you aware that you don't really have to indent the body of the module?
16:56:33 <Welkin> lol qinusty, java habit?
16:56:33 <Cale> It's a little uncommon to see that, even if it is valid (and sort of consistent with the fact that it's all in one "where")
16:57:35 <Cale> Since you can't really define more than one module per file anyway, it doesn't really matter and you can just not indent, since there's no need to ever close the module block before the end.
16:58:09 <hpc> Cale: could be an agda habit ;)
16:59:43 <Cale> The other thing, layout-wise that's a little odd, is that it's not really necessary to start a new line after 'let' -- you just have to make sure that the subsequent lines that you want to be part of the let block start in the same column.
17:00:26 <qinusty> Welkin: Spent the last semester writing Java, so yeahhhh
17:00:29 <Cale> You might consider making drawCard produce a Maybe result
17:01:11 <qinusty> I'll look into it, Cheers for the feedback :)
17:01:17 <Cale> I suppose it's unlikely that the deck ever empties out though
17:01:55 <Cale> But erroring out (basically crashing the program) is sort of an ugly thing to have to do.
17:02:12 <Welkin> haha
17:02:23 <Welkin> maybe that is a design decision for the game
17:02:32 <qinusty> Any feedback of valueOfCard?
17:02:33 <Welkin> make the wrong move and... you loase your gamestate!
17:02:39 <qinusty> It feels very stretched out and hacked together
17:02:51 <Cale> Well, you might be able to do something clever with the Enum instance
17:03:52 <Cale> Handle the special cases at the top, and then have something like  valueOfCard (Card _ n) = (k+1, k+1) where k = fromEnum n
17:04:42 <Cale> er, if Joker was listed first in the type, that gets simpler
17:04:57 <Cale> oh, right, it's a card, not a value
17:05:02 <qinusty> Yeah
17:05:13 <Cale> Yeah, so it's always got to be special
17:07:20 <Zemyla> Okay, so I did some benchmarking.
17:11:59 <Cale> I should really install GHC 8 outside of a nix shell.
17:12:00 <Cale> heh
17:16:48 <qinusty> Thanks Cale, I've sorted the problems besides the Maybe, I've just decided to throw and error and have that be game over if you use all the cards...
17:16:51 <Zemyla> If you don't write your own elem function specialized for [Char], then the one from Data.Foldable is always going to be slower than a Set or IntSet.
17:18:07 <lpaste> Cale pasted “valueOfCard” at http://lpaste.net/168157
17:18:13 <Cale> qinusty: ^^
17:18:45 * hackagebot spatial-math 0.3.1.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.3.1.0 (GregHorn)
17:18:58 <Cale> qinusty: Also, it would be very natural to use lists for the values of cards
17:19:23 <Cale> qinusty: I don't know if you've seen the list monad or list comprehensions yet, but they basically let you make choices in all possible ways from lists
17:19:45 <Zemyla> And even if you do, it's very close.
17:19:49 <Cale> So then  valueOfCard :: Card -> [Int]
17:20:01 <Zemyla> So you should pretty much just always turn lists of characters into Sets.
17:20:05 <Cale> and the only exceptional case becomes  valueOfCard (Card _ Ace) = [1,11]
17:20:11 <Cale> all the others would have just one element
17:20:25 <qinusty> I've touched on list comprehensions, and your implementation of valueOfCard is nice, I didn't think of the min ... 10 addition to further simplify it 
17:20:42 <Cale> But what that lets you do is enumerate all the possibilities for a hand really easily
17:20:43 <qinusty> Yeah I see what you're getting at, I'll take a look at that now. Cheers
17:20:51 <qinusty> Yeah I can just max
17:25:39 <ElectricSolstice> Is there a map that can keep track of an index too? I'm trying to apply a function that outputs the element at the same position as the element that contains that element.
17:26:49 <Koterpillar> Map k (Int, v) ?
17:31:19 <ElectricSolstice> Koterpillar: is that (Int, v) the return type? I'm still kinda new to haskell.
17:31:35 <Koterpillar> that's the type of the map values
17:31:52 <Koterpillar> what's the signature of that function that you want to apply? I don't think I understand your use case welll
17:33:11 <ElectricSolstice> i'm trying to use gtk3 with sqlite3, and i have a column for each field in the database, so i'm trying to display all entries in the database except for the primary key
17:34:59 <ElectricSolstice> i'm in the middle of modifying the code quite a bit to try to make it so i can just easily add another field and the program would know how to display that field in a treeview
17:35:38 <ElectricSolstice> so, i might be going about it all wrong, as i'm having each row in the liststore as a list
17:37:05 <Squarism> apart from not updateing serverstate does this look sane? 
17:37:06 <Squarism> http://lpaste.net/168161
17:37:19 <ElectricSolstice> basically, i'm at the part where you add the columns to the tree view for gtk3
17:37:37 <Squarism> oh.. wrong
17:37:49 <Koterpillar> ElectricSolstice: so what's your structure currently?
17:38:05 <Koterpillar> I have only worked with gtk through gi-gtk
17:38:18 <ElectricSolstice> Koterpillar: The tree view is using a ListStore of []
17:38:47 <ElectricSolstice> Koterpillar: and currently, i have a constant for which fields are in the database
17:38:49 <Squarism> ok.. here 
17:38:49 <Squarism> http://lpaste.net/168162
17:39:10 <ElectricSolstice> Koterpillar: so, for the database i have the constant fields = ["BookID", "Title", "Description"]
17:39:42 <Koterpillar> and you want to insert or replace fields in the middle?
17:39:50 <ElectricSolstice> Koterpillar: so, i'm wanting to add columns to the tree view based on that constant
17:40:09 <Koterpillar> ah
17:40:17 <Koterpillar> and there already are some columns?
17:40:20 <ElectricSolstice> Koterpillar: just to display for now. Hoping that constant is the only thing i'd have to modify for new columns to pop up in the GUI
17:40:48 <Koterpillar> I'm still not sure what kind of a map you need
17:42:16 <Mateon1> Hello, I have a question regarding shared libraries, and whether it's possible to dynamically load them and call arbitrary functions within them. For example: A.hs and B.hs are compiled into shared libs A.dll and B.dll, they both define the function 'foo' with a known type signature. In C.hs I want to search for all the dlls in a certain folder and call the 'foo' function. Is that possible?
17:43:31 <Mateon1> Or in other words, FFI-like Haskell<=>Haskell modules, dynamically loaded and dynamically called.
17:44:37 <ElectricSolstice> Koterpillar: this is the code i currently have. It's a bit of a mess as it's in the middle of being changed.
17:44:47 <ElectricSolstice> Koterpillar:http://pastebin.com/rkLkH9RR
17:45:17 <ElectricSolstice> Koterpillar: so, basically, i'm trying to map to addColumn and it needs a function that selects which element to display for that column
17:45:38 <ElectricSolstice> Koterpillar: so i want to map over the fields constant to display that particular element in a row
17:45:54 <Koterpillar> with the index?
17:46:40 <ElectricSolstice> Koterpillar: well, with index i guess? I'm just wanting to display that element in that row of the database.
17:46:51 <Koterpillar> > map (\(itm, idx) -> "Item " ++ show itm + " is at position " ++ show idx) (zip ["BookID", "Title", "Description"] [1..])
17:46:52 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘+’
17:46:52 <lambdabot>      In the first argument of ‘(++)’, namely
17:46:52 <lambdabot>        ‘show itm + " is at position "’
17:46:55 <ElectricSolstice> Koterpillar: and with !! i need an index
17:46:58 <Koterpillar> > map (\(itm, idx) -> "Item " ++ show itm ++ " is at position " ++ show idx) (zip ["BookID", "Title", "Description"] [1..])
17:46:59 <lambdabot>  ["Item \"BookID\" is at position 1","Item \"Title\" is at position 2","Item ...
17:47:25 <Koterpillar> like this or no?
17:47:33 <ElectricSolstice> Koterpillar: Thank you!!!
17:48:40 <qinusty> If I have a list xss :: [[Int]] is there a way of me 'zipping' them all together to find all possible combinations of the values lists? A value from a list cannot be matched with a value from its own list.
17:49:05 <Zemyla> How reasonable would it be for an interface for creating, reading from, and writing to temporary files to be in ST instead of IO?
17:51:03 <QtPlatypus> Zemyla: It doesn't seem reasonable to me.  It interacts with the outside would so it should be in IO.
17:51:26 <Axman6> Zemyla: zit wouldn't be too hard to implement, but definitely does not give you a pure computation, which ST is supposed to guarantee
17:51:55 <Zemyla> Well, if the file is brand new and temporary, then it should be at least "pureish".
17:52:33 <Axman6> what if you can't create the file?
17:52:46 <Axman6> what if you fill the disk half way through the computation?
17:52:57 <Axman6> what if someone else deletes the file?
17:53:10 <Koterpillar> > mapM id [[1, 2], [10, 20]] -- qinusty
17:53:10 <QtPlatypus> Zemyla: What if someone modifies the file.
17:53:11 <lambdabot>  [[1,10],[1,20],[2,10],[2,20]]
17:53:39 <Zemyla> What if someone snoops in and modifies your program's memory?
17:53:49 <Zemyla> What if a thread dies?
17:54:02 <Zemyla> What if you run out of memory?
17:54:21 <qinusty> :t id
17:54:22 <lambdabot> a -> a
17:54:39 <Axman6> those are mostly problems internal to your program and would be considered bugs
17:55:08 <Axman6> the OS protects you from other programs modifying your memory, and you have bigger problems when it doesn't
17:55:49 <QtPlatypus> Zemyla: Also in a more general sense have you accounted for Temporary file race conditions?
17:56:04 <qinusty> :T mapM
17:56:11 <qinusty> :t mapM
17:56:12 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
17:56:15 <Koterpillar> > traverse id [[1, 2], [10, 20]] -- qinusty
17:56:15 <Zemyla> Aren't there OS-supported functions that create and open a unique temporary file, and also lock it?
17:56:17 <lambdabot>  [[1,10],[1,20],[2,10],[2,20]]
17:58:12 <Zemyla> :t traverse ($)
17:58:13 <lambdabot> Traversable t => t (a -> b) -> a -> t b
17:58:54 <jaarod> > sequence [[1, 2], [10, 20]]
17:58:55 <lambdabot>  [[1,10],[1,20],[2,10],[2,20]]
18:01:37 <Koterpillar> jaarod: thanks, I thought that ought to be easier
18:03:46 * hackagebot Plot-ho-matic 0.10.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.10.0.0 (GregHorn)
18:09:39 <Mateon1> Regarding my DLL question, I found 2 packages that look like what I'm looking for, but neither of them work. 'plugins' and 'dynamic-loader'. Both allow to dynamically load GHC compiled DLLs, but plugins doesn't work with GHC>8.0 and seems discontinued, and dynamic-loader installs properly, but doesn't seem to work on Windows.
18:29:16 <qinusty> Cheers for all the help tonight Cale, Koterpillar. I'm off
18:30:42 <MP2E> hey guys, just wondering if anyone could help me figure out what is causing this strange linker error message on windows http://lpaste.net/166024
18:31:03 <MP2E> using MSYS2, GHC 8.0.1
18:31:44 <MP2E> I thought maybe it was a mismatch of mingw toolchains causing it but I ended up checking out the ghc-8.0 branch and completely replaced the built-in gcc with the latest packages from MSYS2, and built it, then tried again
18:31:47 <MP2E> same exact error message
18:32:03 <MP2E> so i have no idea lol
18:32:20 <MP2E> i imagine maybe it's a bug? would love to help tackle it but i don't even know where to start
18:33:29 <iamanoob> hello
18:33:42 <iamanoob> can someone please explain how this makes sense: λx.λy.x^(47)y = 47
18:35:59 * EvanR tries to divide both sides by λx.λy
18:36:09 <Squarism> in ghci, what do i need to import to use "Int"
18:36:09 <Squarism> ?
18:36:16 <EvanR> nothing
18:36:30 <EvanR> > [1,2,3] !! 1
18:36:32 <lambdabot>  2
18:36:35 <EvanR> 1 is an Int
18:36:42 <thimoteus> :t length
18:36:43 <lambdabot> Foldable t => t a -> Int
18:36:46 <thimoteus> > length []
18:36:47 <lambdabot>  0
18:36:56 <EvanR> > maxBound :: Int
18:36:57 <lambdabot>  9223372036854775807
18:38:55 <chronon-io> iamanoob: What does the caret mean in this context? I don't know it as part of the lambda calculus
18:39:02 <Squarism> > liftA2 (,) (read "23") (Just 2)  :: Maybe (Int,Int)
18:39:04 <lambdabot>  *Exception: Prelude.read: no parse
18:39:16 <Squarism> what am i doing wrong there?
18:39:23 <thimoteus> i'd guess it's something like x x x ... x y
18:39:24 <EvanR> > liftA2 (,) (read "Just 23") (Just 2)
18:39:26 <lambdabot>  *Exception: Prelude.read: no parse
18:39:31 <Squarism> ah
18:39:34 <EvanR> > liftA2 (,) (read "Just 23") (Just 2) :: Maybe (Int,Int)
18:39:35 <lambdabot>  Just (23,2)
18:39:50 <Squarism> theres no readMaybe?
18:39:51 <Squarism>  =D
18:40:04 <EvanR> there is
18:40:16 <Koterpillar> Squarism: Text.Read
18:40:50 <EvanR> :t readMaybe
18:40:51 <lambdabot> Not in scope: ‘readMaybe’
18:40:54 <EvanR> uhg
18:40:55 <chronon-io> thimoteus iamanoob: Seems reasonable; would the expression then be equivalent to the Church numeral 47?
18:41:07 <chronon-io> That's the only sense I can make of it
18:41:13 <thimoteus> yeah, me too
18:43:32 <iamanoob> caret means exponent, or so I assume
18:44:08 <iamanoob> I found this problem here: https://www.hackerrank.com/challenges/lambda-calculus-evaluate-the-expression
18:44:48 <EvanR> so that is weird notation
18:45:02 <iamanoob> what is the unweird version?
18:45:03 <EvanR> for example sin^2 means sin . sin
18:45:24 <iamanoob> does it mean x applied to y 47 times?
18:45:41 <EvanR> however x^2y being (x x) y is something else
18:46:19 <EvanR> wait
18:46:28 <EvanR> sin^2 x means (sin x)^2
18:46:36 <EvanR> now im just lost
18:46:47 <Koterpillar> I've seen both notations used
18:46:50 <Koterpillar> just don't mix them
18:46:50 <chronon-io> iamanoob: Has that course covered Church encoding/numerals yet?
18:47:14 <EvanR> in x^2 = x*x its nice because * is assoc
18:47:15 <iamanoob> sin^2(x) doesnt follow normal maths notation though
18:47:24 <EvanR> x $ x isnt assoc
18:47:43 <EvanR> sin^2 is pretty typical
18:47:47 <iamanoob> its not a course chronon, just a series of challenges. I am using google (and now you) to learn :D
18:47:58 <rmutt> i've seen math texts write f^(5)(x) as f(f(f(f(f(x)))))
18:48:06 <EvanR> yeah thats what i was thinking of
18:48:15 <EvanR> f^5 is f . f . f . f . f
18:48:28 <iamanoob> so if thats the case.. how does it reduce to 47.. 
18:48:37 <thimoteus> usually it's something like repeated application of some monoidal operator, sometimes the operator is composition, sometimes it's something else
18:48:52 <EvanR> well $ is a pretty terrible monoid
18:49:01 <EvanR> or category
18:49:45 <rmutt> iamanoob: if you're living in lambda calculus land, you need to figure out how to represent counting numbers, because the only thing you can get your hands on is functions. a convenient way to do is to use the convention "a number X is represented by the function which applies a thing to another thing X times"
18:50:30 <QtPlatypus> iamanoob: https://en.wikipedia.org/wiki/Church_encoding#Church_numerals
18:51:30 <iamanoob> thanks QtPlatypus, mystery solved :) I was thinking about this as an exponent
18:53:08 <QtPlatypus> iamanoob: Typically with functions f^n means f self composed n times.
18:54:43 <Xnuk> > let f ^ n = foldl1 (.) $ replicate n f in ((+1) ^ 4) 3
18:54:44 <lambdabot>  7
18:55:06 <QtPlatypus> It also has the nice effect that  f^1 . f^-1 = id 
18:56:35 <iamanoob> is there some intuition for why λy.λx.x is defined to be 0?
18:58:29 <QtPlatypus> Because it is the application of λy zero times.
18:59:06 <iamanoob> so what is the significant of just this λx.x
18:59:12 <iamanoob> significance*
19:00:24 <EvanR>  :t significance
19:03:02 <QtPlatypus> iamanoob: That's the idenity function
19:13:05 <iamanoob> guys I gotta tell you.. learning programming has been like drowning in a sea of nonsense.. and functional programming is the first gasp of air upon resurfacing
19:14:06 <audio> iamanoob: nice, what is your math like?
19:14:16 <Iceland_jack> iamanoob: Stealing that :)
19:15:56 <EvanR> iamanoob: agreed
19:20:36 <mniip> 1466992111 [04:48:31] <EvanR> well $ is a pretty terrible monoid
19:20:40 <mniip> pretty sure the monoid is .
19:20:47 <EvanR> right
19:20:50 <mniip> or rather, Endo
19:20:59 <EvanR> but x^3 --> x x x would not be that
19:22:18 <EvanR> also unix time is creepy
19:22:29 <mniip> well it's x^47 y
19:22:40 <mniip> which is x(x(x(...y)))
19:22:43 <mniip> not x x x ... y
19:22:48 <EvanR> that answers a lot of questions from earlier
19:23:24 <mniip> I do second that this notation is confusing but it's not as irrational as it might seem
19:50:27 <thimoteus> yeah, i said "something like", not "it is" because i didn't want to think about it too much :p
20:21:39 <Iceland_jack> iamanoob: I makes more sense if you give them names
20:22:24 <Iceland_jack>     0 = λsuc. λzero. zero
20:22:24 <Iceland_jack>     1 = λsuc. λzero. suc zero
20:22:24 <Iceland_jack>     2 = λsuc. λzero. suc (suc zero)
20:22:24 <Iceland_jack>     3 = λsuc. λzero. suc (suc (suc zero))
20:27:23 <Iceland_jack> In Haskell it would just be
20:27:23 <Iceland_jack>     0 = \suc zero -> zero
20:27:24 <Iceland_jack> etc. with type 'forall a. (a -> a) -> (a -> a)' (wrapped in newtype for administrative purposes)
20:34:49 <nalin> hi
20:35:09 <nalin> need some help regarding connecting to haskell irc channel from emacs
20:35:23 <nalin> can I get some help?
20:35:56 <QtPlatypus> nalin: Do you have trouble connecting to other irc channels from emacs?
20:36:14 <nalin> This is for the first time that I am trying..
20:36:50 <nalin> I tried to follow the instructions on https://wiki.haskell.org/IRC_channel
20:37:02 <shachaf> nalin: Try #emacs for questions about Emacs.
20:37:06 <QtPlatypus> nalin: Try other channels.  If it doesn't work for other channels then it means that it is a problem with your emacs irc client and you should ask there.
20:37:25 <nalin> Thanks guys.. :-)
20:54:26 <nalin`> hi guys
21:17:51 <m1dnight_> I have a typechecker with session types in which I at some point have to generate a so-called fresh identifier.
21:18:17 <m1dnight_> I was first thinking about using unsafePerformIO but that will not work. Is there a way I could possibly hash an expression to still get a unique value? Not random per se.
21:18:33 <m1dnight_> Or any other ideas? I just don't want to wrap it in an IO monad, to be honest.
21:20:59 <m1dnight_> The reason being that my typechecker does not really depend on side effects. It can and should be referentially transparent.
21:21:22 <geekosaur> you only need IO to get an initial seed. after that you can keep the seed with the typechecker's internal data (often as a state monad transformer)
21:22:03 <m1dnight_> Hrm, then I could actually just use the same seed each time (at the start, that is). 
21:22:18 <m1dnight_> Well, That's a good idea. I'll fiddle a bit with that option. Thanks.
21:23:10 <geekosaur> ...or as RandT (http://hackage.haskell.org/package/MonadRandom-0.4.2.2/docs/Control-Monad-Random.html#t:RandT)
21:24:10 <geekosaur> that being just a state monad transformer with associated wrappers for random functions that maintain the state without you having to worry about it
21:25:33 <geekosaur> ...although in this case you may not even need random, just a counter in StateT and when you generate a fresh name you increment the counter (modify (+1))
21:27:40 <m1dnight_> Yeah, I think that's indeed th ecase. I was just hoping there might be a way to get away with it easier than a monad. But eh. It' just as well.
21:27:44 <m1dnight_> thanks for the brain cycles on it geekosaur 
21:27:49 <dmj`> > flip execState 0 $ replicateM_ 10 $ modify (+1)
21:27:53 <lambdabot>  10
21:28:00 <geekosaur> here the monad is just for convenience
21:28:16 <m1dnight_> Well, yeah :D But it'd be pretty weird to pass around a counter.
21:38:11 <shijinabraham> Hi, I am not able to selectively import Any,Sum or All from Data.Monoid 
21:39:29 <shijinabraham> http://lpaste.net/168170
21:39:41 <shijinabraham> Can someone explain why
21:40:01 <dmj`> :t Any is asking for the type of the data constructor
21:40:02 <lambdabot> parse error on input ‘type’
21:40:12 <dmj`> but you've only imported the type, not the constructor
21:40:28 <Hafydd> shijinabraham: you need to use the form "import Data.Monoid(Any(..))" to import the constructors.
21:40:30 <dmj`> try import Data.Monoid (Any (..))
21:41:00 <shijinabraham> thanks Hafydd and dmj
21:55:48 <mjrosenb> @hoogle IO a -> IO ()
21:55:52 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
21:55:53 <lambdabot> Control.Exception.Base block :: IO a -> IO a
21:55:53 <lambdabot> Control.Exception block :: IO a -> IO a
21:56:22 <mjrosenb> so close... yet so far
22:00:15 <MichaelBurge> How do you write a smart constructor that throws an error on invalid input as a bidirectional pattern synonym?
22:00:46 <MichaelBurge> Normally I'd use a case statement, but it looks like that's part of the expressiont syntax rather than the pattern syntax
22:04:01 <QtPlatypus> MichaelBurge: Why smart constructors and why pattern synonyms?
22:15:17 <hk238> hello ^^
22:30:55 <systemfault> Not necessarily a Haskell question but does any of you would know how to model the concept of cancellation for a Task monad?
22:31:50 <dmj`> systemfault: what is a Task monad
22:32:15 <dmj`> sounds like a .NET concept
22:32:49 <systemfault> dmj`: I don't use .net, it's some idea I had for a C++ app.. (Because C++ apps need more monads in their lives) 
22:33:00 <systemfault> It's basically a Either.
22:33:29 <systemfault> Hm.. A Either that does IO
22:34:09 <jle`> np!
22:34:10 <systemfault> And of course, because IO makes everything more complicated, I need to way to cancel it if required.
22:34:15 <geekosaur> not like C++ is pure
22:35:11 <systemfault> Anyway, It was more about knowing what you would do in Haskell for a similar case.
22:35:39 <systemfault> Let's say you start 5 HTTP connections at the same time... then when the first of them finishes, cancel the 4 others.
22:36:05 <Rotaerk_> someone in another IRC channel was asking me about whether his Task type was monadic a few days back...
22:36:24 <systemfault> Rotaerk_: That wasn't me, I promise
22:37:31 <Rotaerk_> systemfault, being a monad doesn't drive everything about a type; it's not at the core of what it is... monad just refers to one way of using the type
22:37:52 <Rotaerk_> and anything outside of the monadic behavior is going to be a separate problem altogether
22:38:32 <Rotaerk_> even if your Task type supports monadic bind, cancellation of isn't really ... relevant to that
22:39:07 <systemfault> Rotaerk_: Let's pretend we remove the word monad from everything I said... How would you represent cancelation?
22:40:27 <Rotaerk_> aren't you writing this in C++? is this the appropriate place to be asking about that?
22:41:24 <Rotaerk_> anyway, I'd look at preexisting examples; .NET has something called a cancellation token
22:42:10 <systemfault> Rotaerk_ Thanks...
22:50:56 <EvanR> systemfault: under what circumstances would you cancel what task
22:51:29 <systemfault> EvanR: In my real world scenario, the cancelation would be triggered by the user.
22:51:43 <EvanR> the user clicks on individual tasks to cancel? sounds tedious
22:51:53 <systemfault> EvanR: Just a "cancel all"
22:51:57 <dmj`> systemfault: sounds like you want to use the `async` package, or just use 'killThread' from control.concurrent
22:51:59 <EvanR> literally all tasks?
22:52:03 <systemfault> EvanR: Yes.
22:52:24 <systemfault> dmj`: I'll look at it :) Thank you
22:52:42 <EvanR> async and killthread are only applicable under specific circumstances which may or may not apply, but both are called "cancellation"
22:53:18 <systemfault> async is closer to what I need (I think)
22:53:53 <EvanR> async is good if youre talking about actual threads that need to be auto cancelled by explicit action or automatically because the parent died
22:54:20 <Squarism> i cant comprehend i managed to create a seemingly working multiplayer server handling 2 player games
22:55:57 <Squarism> i have only school level experiance in concurrency and aint no rockstar
22:56:12 <EvanR> school level... man thats pretty bad
22:56:21 <Squarism> haha
22:57:09 <Squarism> well there arent tons of jobs in concurrancy problems is there? 
22:58:15 <EvanR> thats kind of like "now hiring, arithmetic expert"
22:59:34 <Squarism> =D
22:59:55 <Squarism> you do alot of concurrency at work? 
23:00:03 <EvanR> it probably exists but youre a post doc who will be stationed in the basement for the rest of your life
23:01:25 <EvanR> Squarism: have you ever used javascript?
23:01:42 <Squarism> ive heard about it yes
23:02:04 <EvanR> many people use but dont know they are manually solving concurrency problems with it
23:02:04 <Squarism> its what the cool kidz use
23:02:24 <dmj`> for some definition of "cool"
23:03:09 <EvanR> cool kids on the non-block
23:13:19 <Squarism> most people on #haskell wouldnt be here if they knew about nodejs
23:13:30 * EvanR gets mad
23:13:32 <thimoteus> er wat?
23:13:44 <Squarism> that was joke
23:14:15 <bitemyapp> urbanslug: hi :)
23:17:35 <urbanslug> bitemyapp: Hello :)
23:23:15 <bitemyapp> urbanslug: how you been mate?
23:24:24 <urbanslug> Well I sadly haven't finished your book yet and my haskell skills have been greatly eroded by writing clojure (dynamically typed) at work but still all is great. It's functional and some things are lazy and everything is immutable.
23:24:51 <bitemyapp> urbanslug: 'long as you're happy and know where to learn more.
23:25:05 <bitemyapp> urbanslug: book's nearly done. It's in final editing now.
23:25:09 <urbanslug> bitemyapp: For sure :)
23:25:31 <Axman6> Squarism: you mean because they would've killed themselves already? =)
23:25:57 <Squarism> well something like that
23:26:03 <urbanslug> bitemyapp: Damn! I'm happy that you're succeeding and now you're a haskell celebrity.
23:26:17 <urbanslug> I be like "I knew him before he went mainstream"
23:26:31 <urbanslug> or famous
23:26:36 <urbanslug> :)
23:27:29 <bitemyapp> I don't know about that
23:30:27 <EvanR> urbanslug: laziness in clojure is kind of insane
23:30:41 <parsnipM_> dangit, i have `, hstats >= 0.3` in *.cabal file, but the import is failing. 
23:31:04 <parsnipM_> i did `cabal sandbox init` and `cabal install --only-dependencies`
23:31:46 <urbanslug> EvanR: LOL well it hits you when you least expect it
23:32:02 <urbanslug> bitemyapp: haha nobody sees their own achievements
23:32:03 <EvanR> you have to use lazy sequences to execute effectful for loops, and so they dont execute, since its lazy. and when you want it to be lazy, its not because asking for the first item evaluates 32 of them, any one of which could "bottom out" (crash)
23:32:22 <urbanslug> EvanR: I had a bug that I tracked down to map being lazy and me not having thought that out.
23:32:56 <bitemyapp> I've had Clojurians throw laziness at my feet as a reason not to use Haskell
23:33:17 <bitemyapp> which I thought was a bit funny because laziness and vectors being functions were probably my biggest irritations when I used Clojure (was my main lang before Haskell)
23:33:34 <bitemyapp> I really hated it when I accidentally used a collection as a function.
23:35:03 <ggVGc> I'm learnig to embrace laziness
23:35:06 <ggVGc> and now I quite enjoy it
23:35:16 <ggVGc> and it feels much more natural than strict eval
23:35:18 <EvanR> it seems that to do laziness right you need to be pure
23:35:22 <ggVGc> but I had a very different opinion a year ago
23:35:27 <EvanR> and ideally total too
23:35:32 <ggVGc> EvanR: definitely agree there
23:35:38 <ggVGc> laziness in non-pure code is terrible
23:35:51 <EvanR> because then it kind of doesnt matter that its lazy and you get performance for free
23:35:52 <ggVGc> well, in my experience
23:36:42 <EvanR> clojure isnt pure, total, or even really lazy where advertised
23:36:43 <urbanslug> bitemyapp: laziness is good when it's not random
23:36:57 <urbanslug> Like everything should be lazy or strict
23:37:06 <urbanslug> don't just drop things randomly
23:37:10 <urbanslug> but anyway they had great reasons
23:37:14 <ggVGc> is EvanR lazy where advertised?
23:37:16 <EvanR> haskell and idris both let you switch to the non-default when you want
23:37:38 <urbanslug> I only have like 2 years programming experience and only 3 months actual programming experience
23:37:43 <urbanslug> What do I know  :)
23:37:55 <ggVGc> what does actual mean?
23:38:33 <urbanslug> Oh man I'm kinda excited about learning Erlang but after learning haskell I'm not ready to learn anything else but I've heard great things about Erlang from alanz 
23:38:55 <urbanslug> ggVGc: professional :)
23:39:13 <EvanR> erlang is good for teaching you to ignore concrete syntax
23:39:38 <EvanR> which youll have to do because its so bad
23:41:23 <ggVGc> EvanR: you're lucky
23:41:34 <ggVGc> doing clojure as your first professional job seems pretty good
23:41:36 <ggVGc> comparativley
23:42:12 <bitemyapp> urbanslug: yeah.
23:43:03 <urbanslug> ggVGc: Yeah but you know it runs on the JVM and I know no Java debugging that stacktrace is death!
23:43:21 <urbanslug> * ...I know no Java so...
23:43:29 <EvanR> ggVGc: i started with PHP
23:44:12 <EvanR> and that was years after we were stomping around #sdl
23:45:02 <EvanR> but i was doing haskell on the side, biding my time until the php imploded
23:46:51 <EvanR> urbanslug: if youre feeling bored, maybe fire up frege
23:47:19 <EvanR> or haskell java-bridge
23:47:32 <EvanR> bored / morbidly curious
23:48:01 <urbanslug> bored? No, overwhelmed maybe
23:48:01 <urbanslug> *googles frege*
23:48:01 <urbanslug> OMG haskell on JVM
23:48:08 <urbanslug> https://github.com/Frege/frege
23:48:14 <EvanR> its a haskell like language
23:48:34 <EvanR> which means they changed some stuff for the better, afaict
23:50:17 <parsnipM_> oh, so hstats won't work with haskell2010 maybe
23:54:26 <karanlearnshaske> hello room.
23:54:36 <karanlearnshaske> 1 doubt please 
23:55:04 <karanlearnshaske> mconcat . map Any  [False,False,False,True]
23:55:10 <karanlearnshaske> doesnt work
23:55:19 <karanlearnshaske> but this below works :
23:55:25 <karanlearnshaske> mconcat . map Any $ [False,False,False,True]
23:55:29 <karanlearnshaske> why ?
23:56:07 <ggVGc> karanlearnshaske: because you need to tell GHC what precedence you are intending. Before you start using $ you should use prentheses
23:56:29 <karanlearnshaske>  map Any $ [False,False,False,True]  and  map Any  [False,False,False,True] both return the same thing
23:56:46 <karanlearnshaske> then why when i use mconcat .  
23:56:52 <thimoteus> :t (.)
23:56:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:56:54 <karanlearnshaske> precedence comes into play
23:58:06 <ggVGc> karanlearnshaske: because haskell can't know if you mean mconcat . (map Any [False]), or (mconcat . map) Any [False]
23:58:10 <ggVGc> etc.
23:58:58 <zeitgeist7> hi guys
23:59:16 <zeitgeist7> I am new to Haskell and having some issues with some installation 
23:59:28 <zeitgeist7> I need help please
23:59:29 <QtPlatypus> zeitgeist7: What problem are you having?
