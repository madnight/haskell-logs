00:07:36 * hackagebot relational-query 0.8.2.3 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.2.3 (KeiHibino)
00:07:36 * hackagebot relational-schemas 0.1.3.1 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.3.1 (KeiHibino)
00:12:31 * hackagebot relational-query-HDBC 0.6.0.2 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.0.2 (KeiHibino)
00:22:31 * hackagebot persistable-types-HDBC-pg 0.0.1.4 - HDBC and Relational-Record instances of PostgreSQL extended types  https://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.1.4 (KeiHibino)
00:26:51 <Zemyla> Oh, I have a question about the change to TypeRep in the future.
00:29:04 <Zemyla> Is there going to be a function like splitTypeRep :: forall k (a :: k) r. TypeRep a -> (forall k' (f :: k' -> k) (x :: k'). (f x) ~ a => TypeRep f -> TypeRep x -> r) -> Maybe r ?
01:17:37 <maybefbi> what is * -> *
01:18:14 <Cale> It's a kind
01:18:27 <Cale> The kind of types which take a type parameter of kind * and produce a type of kind *
01:18:48 <Cale> e.g. Maybe, IO, the list type constructor [], ...
01:19:20 <maybefbi> * is a kind too?
01:20:10 <maybefbi> Cale, what other kinds of kind are there other than ones involving * ?
01:23:26 <Cale> * is the kind of all ordinary types, the ones which have values in them
01:23:38 <Hascat> join haskell
01:23:39 <Cale> There's a kind # of unboxed types
01:24:08 <Hascat> Hey, anyone mind helping me with a question about using Parsec?
01:24:15 <maybefbi> Cale, ok.
01:24:18 <Cale> The kinds which are obtained from * and (->) are all there is in plain Haskell
01:24:19 <maybefbi> Hascat, I can try
01:24:31 <maybefbi> Cale, i see
01:25:07 <Cale> But with the DataKinds extension, you can lift types up to the kind level, and their data constructors become type constructors
01:25:28 <Hascat> I want to have a special token that closes all braces before it, so that "{ test { bla CLOSEALL" will be parsed just like "{ test { bla }}"
01:25:45 <Hascat> maybefbi, first thanks - and do you have any idea on how I can approach this?
01:25:51 <maybefbi> Hascat, use between combinator
01:26:19 <maybefbi> Hascat, https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Combinator.html
01:26:24 <Hascat> instead of using the Text.Parsec.Token?
01:26:30 <Hascat> *Text.Parsec.Token.braces
01:27:19 <maybefbi> yeah, Text.Parsec.Token.braces is when you are inventing a language definition
01:27:31 <Hascat> I mean I also want to allow using normal braces AND the special operator, so currently I'm using something like term =  parens expr <|>  ... <|> ...
01:27:59 <Cale> What about  "{ test { bla CLOSEALL }" ?
01:28:09 <Hascat> That would be an error
01:28:11 <Cale> okay
01:28:20 <Hascat> since the CLOSEALL should've closed all the previous braces
01:28:46 <Hascat> well I could change and allow it, what do you think would be less complicated to implement?
01:28:49 <Cale> Yeah, I was just wondering if there was supposed to be backtracking :)
01:28:52 <dramforever> What about moving this CLOSEALL checking to the lexer?
01:29:20 <Hascat> I thought about it, I wanted to do it in the parser because it felt more natural
01:29:59 <maybefbi> Cale, thanks for the pointer to DataKinds, servant seems to be full of it
01:30:12 <Cale> Servant is crazy
01:30:14 <Cale> :)
01:30:37 <maybefbi> Cale, why is it that some typeclass has type synonyms in them? is that allowed?
01:30:51 <Cale> Those are class associated types
01:31:02 <maybefbi> are those synonyms only available in the instance of the typeclass?
01:31:03 <Cale> It basically lets you define a type level function
01:31:20 <maybefbi> ok
01:31:38 <Cale> Where the instances of the class specify how that type level function acts for the instance
01:32:13 <maybefbi> i see
01:32:35 <maybefbi> whats the best resource for type level functions and kinds?
01:33:04 <Cale> https://wiki.haskell.org/GHC/Type_families is a good intro to associated types
01:34:27 <DangerousDav3> Hello, is there any way that monad structure is usefull which is not for the sequence interpertation of it?
01:35:34 <Cale> DangerousDav3: Well, there are certain instances where you can think of (>>=) as performing a kind of tree-substitution
01:35:43 <dramforever> Trees (in the data structures sense)?
01:35:49 <Cale> yeah
01:35:51 <dramforever> Ah
01:36:07 <shachaf> Cale: I think you can think of it as doing that in most instances. :-)
01:36:32 <Cale> But yeah, whether that is really distinct is a matter of how you're thinking about things
01:36:54 <DangerousDav3> well, ill read about it, because I dont understand how is it helpfull in special way for trees
01:39:02 <maybefbi> Cale, what is the difference between type variable/parameters and *
01:39:25 <Cale> :k Integer
01:39:26 <lambdabot> *
01:39:30 <Cale> :k Maybe
01:39:31 <lambdabot> * -> *
01:39:36 <Cale> :k Maybe Integer
01:39:37 <lambdabot> *
01:39:47 <maybefbi> wow
01:39:48 <Cale> Kinds are "the types of types"
01:40:00 <maybefbi> so the types of type variables is *
01:40:19 <Hascat> hey again! I tried using "between" so it will be 'term =  parens expr <|> between (reservedOp "(") (reservedOp "}") expr', but for some reason it fails even on simple expressions such as "(3}" (where "(3)" works fine)
01:40:34 <Hascat> (} symbolizes "ENDALL" operation)
01:40:48 <hawk78> http://pastebin.com/JGDJVT40 -- It looks me or the compiler are reading 'e' but understanding 'o'. Who is Wrong?
01:40:52 <Cale> maybefbi: Not all of them
01:40:59 <Cale> maybefbi: You can have type variables of any kind
01:41:14 <Cale> return :: (Monad m) => a -> m a
01:41:22 <Cale> Here, a :: * while m :: * -> *
01:42:03 <maybefbi> Cale, in data Maybe a = Nothing | Just a, the type of a is * ?
01:42:23 <Cale> yes
01:42:29 <Cale> The kind of a
01:42:47 <maybefbi> so in type level expressions the kind of variables is *, got it!
01:42:49 <maybefbi> thanks
01:42:54 <maybefbi> no
01:42:57 <hawk78> Every unexperienced developer finds lots of false compiler bugs... Is the link I posted above one of them?
01:43:11 <Cale> maybefbi: I just pointed out that this isn't true
01:43:11 <maybefbi> return :: (Monad m) => a -> m a is counter example
01:43:14 <Cale> right
01:43:19 <maybefbi> hmm ok
01:43:49 <hawk78> Are type families a "stable" language extension?
01:43:55 <maybefbi> so type variables in type definitions are always kinds
01:44:39 <Cale> hawk78: repasted your code here http://lpaste.net/166914
01:44:51 <Cale> So let's see
01:45:03 <Cale> maybefbi: No, they're always types
01:45:12 <Cale> maybefbi: They *have* kinds, because they are types
01:45:19 <pavonia> hawk78: Your class definition says the first parameter of handleEvent has to be an Event, but in that instance you say it's just "e"
01:45:21 <maybefbi> understood
01:46:25 <hawk78> pavonia: e is the Event type for that class instance, no?
01:46:26 <pavonia> Err wait, that's a type family
01:46:35 <hawk78> pavonia: yes
01:47:35 <hawk78> Cale: thanks for reposting lpaste is nicer!
01:48:23 <Cale> hawk78: Well, what about the inner handleEvent? Which type is it being used at?
01:48:28 <pavonia> I suspect the e in that type signature isn't the same as in the instance header
01:48:53 <Cale> fmap (handleEvent e) :: FSMMonad m s e o -> FSMMonad m s e o
01:48:59 <Cale> So handleEvent e :: o -> o
01:49:06 <hawk78> pavonia: you can omi the signature and still get the same error
01:49:12 <Cale> So e :: Event o
01:49:21 <Cale> but this is not the case, unless Event o ~ e
01:49:48 <hawk78> Cale I'm not following you
01:50:10 <Cale> Okay, I'll add more steps
01:50:27 <Cale> handleEvent :: e -> FSMMonad m s e o -> FSMMonad m s e o -- according to its explicit type signature
01:50:39 <Cale> thus, applying it to one argument, we get
01:50:46 <Cale> handleEvent e :: FSMMonad m s e o -> FSMMonad m s e o 
01:50:51 <hawk78> ok
01:51:07 <Cale> but now, according to the definition, we have   handleEvent e = fmap (handleEvent e)
01:51:25 <Cale> So this expression on the right hand side of the equation had also better have this type:
01:51:32 <Cale> fmap (handleEvent e) :: FSMMonad m s e o -> FSMMonad m s e o
01:51:46 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
01:52:20 <Cale> and here, we're applying fmap and obtaining a function of type  FSMMonad m s e o -> FSMMonad m s e o
01:52:31 <Cale> So we'd better have f = FSMMonad m s e
01:52:34 * hackagebot quickcheck-simple 0.1.0.1 - Test properties and default-mains for QuickCheck  https://hackage.haskell.org/package/quickcheck-simple-0.1.0.1 (KeiHibino)
01:52:36 <Cale> and a = b = o
01:52:43 <Cale> yes?
01:53:13 <Cale> So this  handleEvent e  which the fmap is applied to had better have type o -> o
01:53:13 <hawk78> I'm reasoning about it... seems to make sense.
01:53:27 <Cale> yes?
01:54:12 <Cale> and since  handleEvent :: (StateMachine a) => Event a -> a -> a
01:54:18 <Cale> we'd better have a = o
01:54:36 <Cale> and thus the e which this handleEvent is applied to had better have type Event o
01:54:56 <Cale> But it has type e
01:55:09 <Cale> (and we don't know whether e = Event o)
01:58:24 <hawk78> Cale: thanks I was really far from understanding what was going wrong!
01:58:37 <hawk78> Now I get it 100%
01:59:16 <Cale> btw, it's weird that your StateMachine class doesn't have any methods which don't use the State or Output types.
01:59:28 <Cale> s/don't//
02:00:30 <lpaste> Cale annotated “repaste of hawk's code” with “repaste of hawk's code (annotation)” at http://lpaste.net/166914#a166915
02:00:36 <Cale> hawk78: ^^
02:00:50 <Cale> That'll work, but I don't know if it's what you wanted :)
02:01:36 <Cale> Probably the Functor constraint will change to some constraint on m or something.
02:02:26 <Prutheus> Hello. Anyone here who can help me with a clash related question?
02:07:35 <Prutheus> i have following script, and I setup the input and output names in the annotations, but for some reasons they are not the same like i set in the pinplanner then: code: http://ix.io/Uyr pinnames in pinmapper: http://i.imgur.com/BLaRtAt.png what went wrong?
02:08:33 <hawk78> Cale: I wanted this         handleEvent e (FSMMonad m) = FSMMonad $ fmap (handleEvent e) m
02:08:58 <hawk78> Cale: thank you for helping me understand this
02:09:02 <Cale> ah, okay
02:09:05 <Cale> cheers
02:09:28 <hawk78> I forgot to deconstruct and reconstruct the wrapper type
02:10:08 <hawk78> My goal here is to develop an instance of my class that can apply an event into any functor
02:11:02 <hawk78> I had toy use a wrapper, but my first attempt was using typelasses and context constraint in a wrong way.
02:11:08 <hawk78> Cale: ^^
02:11:20 <hawk78> Cale: is this approach a good one?
02:12:13 <Cale> I haven't really understood what you're doing yet well enough to decide that :)
02:14:29 <Cale> Prutheus: Sorry I can't be more helpful, never really used that library...
02:14:55 <Cale> (and the problem you're having with it doesn't look like a general Haskell problem)
02:15:22 <Prutheus> true, but at ##fpga is noone who uses clash
02:15:24 <Prutheus> q.q
02:15:37 <Prutheus> (Cale, ik it is offtopic, but you know vhdl?)
02:16:23 <Cale> Not really, I know of it, and I've fiddled around with a few of the other hardware description libraries for Haskell (though somewhat pointlessly so, as I don't have an FPGA)
02:16:40 <Prutheus> okay, here is the generated vhdl from my script what i just asked some minutes ago, and can you tell me why there are the pin names at pinplanner like you see in the screenshot above? and not something like LED, CLOCK_50 etc? http://ix.io/Uyu
02:16:47 <Prutheus> you maybe have an idea what went wrong?
02:19:29 <Cale> Prutheus: I don't even know what pinplanner is
02:19:58 <Cale> Presumably software for configuring FPGAs?
02:21:10 <Prutheus> yeah, you need a software studio which does synthesizing, compiling and so on. and with a pin planner you can map input and output of your code with real pins
02:22:11 <liste> wow, that's some nice autogenerated code
02:24:13 <liste> Prutheus: test_topentity_inst in that vhdl code
02:24:49 <Prutheus> nono wait
02:24:52 <Prutheus> i got it working
02:24:58 <Prutheus> i set the wrong fiel as topentity xD
02:47:36 * hackagebot tianbar 1.0.3.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.0.3.0 (AlexeyKotlyarov)
02:52:37 * hackagebot hothasktags 0.3.7 - Generates ctags for Haskell, incorporating import lists and qualified imports  https://hackage.haskell.org/package/hothasktags-0.3.7 (LukePalmer)
03:31:26 <osager_> Selected resolver: lts-6.3
03:31:26 <osager_> Resolver 'lts-6.3' does not have all the packages to match your requirements.
03:31:26 <osager_>     ListZipper not found
03:31:26 <osager_>         - sed requires -any
03:31:34 <osager_> stack can not find listZipper
03:31:48 <osager_> what can i do ?
03:32:33 <maybefbi> Is there a runIO :: IO a -> a ?
03:32:38 <maybefbi> or something similar?
03:33:10 <maybefbi> never mind
03:33:15 <maybefbi> hayoo says it is unsafe
03:33:48 <ahihi> osager_: you can add it to your extra-deps in stack.yaml
03:34:06 <osager_> the stack.yaml can not be created by stack init
03:35:08 <maybefbi> :: IO a -> a is unsafe, but runMaybeT :: MaybeT IO a -> IO (Maybe a) is safe. why is that?
03:36:42 <osager_> ahihi, ok i copied one from another project
03:36:48 <osager_> ahihi, now it's building
03:37:16 <ahihi> cool :)
03:37:26 <ahihi> never used stack init myself, only stack new
03:38:45 <osager_> ahihi, i use it to turn a cabal project into a stack project
03:41:16 <HaskellCat> Hey! How do I concatenate terms in Parsec? Let's say I want number and then an operator ("+", "-") and then another number? furthermore, if I want a number OR a variable token, I'll use choice? Thanks!
03:41:48 <dibblego> HaskellCat: (>>=)
03:42:20 <puregreen> maybefbi: in the runMaybeT example both things are in IO
03:42:56 <puregreen> so there's no reason for it to be unsafe
03:43:08 <HaskellCat> dibblego: so It's number >>= operator >>= number? and afterwards I can replace both number with "choice"?
03:46:02 <Cale> HaskellCat: Well, if you're not going to use the result of the first parser, you only need (>>)
03:46:21 <Cale> HaskellCat: usually people use do-notation
03:46:59 <Cale> do x <- number; op <- operator; y <- number; ...
03:54:41 <maybefbi> puregreen, both things?
03:55:14 <puregreen> “MaybeT IO a” and “IO (Maybe a)” are both IO actions, the former is just wrapped
03:55:52 <puregreen> runMaybeT doesn't do anything apart from unwrapping it
03:56:14 <puregreen> can you explain why it seems like it could be unsafe?
03:58:07 * Prutheus wishes to get help at CLASH FPGA HASKELL PROGRAMMING - https://www.reddit.com/r/haskell/comments/4osr4s/cl%CE%BBsh_fpga_vhdl_programming/
04:03:15 <liste> Princess17b29a: that link is removed
04:03:19 <liste> Prutheus*
04:06:55 <Prutheus> arrr, yeah, i am also a prince(ess) xD
04:07:17 <Prutheus> for me the link works
04:07:50 <Prutheus> liste: are you sure it is not working for you?
04:08:13 <liste> Prutheus: http://i.imgur.com/mckplyB.png
04:13:10 <Prutheus> my question is commented in the first line
04:13:11 <Prutheus> https://bpaste.net/show/47eff469d8f3
04:13:25 <Prutheus> liste: but this is strange that for me it is not removed...
04:15:16 <JohnnyL> can someone tell me what this means? http://pastebin.com/YNgyUdYz
04:16:07 <Prutheus> JohnnyL: what do you want to install?
04:16:30 <Prutheus> JohnnyL: Sorry, I see
04:16:46 <Prutheus> you have not the right version of BASE module for it
04:17:09 <Prutheus> you wanna know how to fix that?
04:17:11 <maerwald> JohnnyL: ghcjs-webgl-lessons is not ported for ghc-8 it means
04:17:23 <Prutheus> you could use stack install <package>
04:17:34 <Prutheus> to build a supported platform
04:17:37 <maerwald> how is stack related to that?
04:17:47 <Prutheus> with stack he can get it working
04:18:05 <maerwald> I wish people would stop answering "stack" for every possible cabal problem
04:18:10 <Prutheus> i mean he also could install haskell 7, depends on his OS
04:18:27 <Prutheus> maerwald: stack is the answer, so what do you expect :D
04:18:45 <maerwald> no
04:19:30 <JohnnyL> maerwald: ok thanks.
04:19:41 <maerwald> https://github.com/jmillikan/webgl-lessons-ghcjs open an issue and port it to ghc-8
04:19:50 <maerwald> alternatively you can use --allow-newer
04:19:56 <maerwald> as cabal flag and see what happens
04:21:02 <JohnnyL> cabal --allow-newer install
04:21:03 <JohnnyL> cabal: failed to parse output of 'ghc-pkg dump'
04:22:09 <sdx23> I'm using Network.Socket to send udp packets. What influences encoding of the payload? Namely putting in "\0\xff" and the package content is "00c3bf" instead of expected "00ff".
04:23:09 <Prutheus> JohnnyL: which OS?
04:23:25 <dramforever> sdx23: use ByteString for binary data http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket-ByteString.html
04:24:05 <JohnnyL> Prutheus: nix.
04:24:10 <sdx23> dramforever: send is send :: Socket -> String -> IO Int
04:24:32 <sdx23> dramforever: ah, read the link only later.
04:25:08 <sdx23> dramforever: how is it encoded though? Did I miss it in the docs?
04:25:54 <Prutheus> JohnnyL: wanna try it with stack? you know stack?
04:26:08 <JohnnyL> no frankly i don't.
04:26:14 <Prutheus> liste: and? can you help me?
04:26:29 <maerwald> JohnnyL: uhm?
04:26:38 <Prutheus> JohnnyL: won't try or doesn't know?
04:26:55 <maerwald> stack is a tool for deployment, not for development
04:27:13 <dramforever> sdx23: yes, look at the paragraph just under the section "Sending and receiving data"
04:27:25 <JohnnyL> maerwald: sorry I'm sold out, i have enough of them. :)
04:27:30 <Prutheus> maerwald: i don't think this. I am using clash, and it also doesnt work for ghc8, so i just use stack to get a working environment
04:27:40 <dramforever> Do not use the send and recv functions defined in this module in new code, as they incorrectly represent binary data as a Unicode string. 
04:27:53 <dramforever> i.e. it's more or less deprecated
04:27:53 <Prutheus> JohnnyL: which DIST?
04:28:05 <MichaelBurge> sdx23: If you really want to know, it uses the encoding for your current locale.
04:28:21 <maerwald> JohnnyL: your error does not make sense
04:28:30 <maerwald> JohnnyL: you have cabal-install-1.24?
04:28:36 <sdx23> dramforever: ah, thank you. I even looked up if I got the escape sequence wrong, but no. Ok, this is quite counterintuitive behaviour.
04:29:09 <maerwald> --allow-newer is there since 1.24
04:29:19 <dramforever> actually, if you were sending text it's somewhat reasonable
04:29:21 <maerwald> it ignores upper bounds
04:29:52 <sdx23> (actually even led me to using an oscilloscope, since I first thought the firmware-part of my project was the reason)
04:29:56 <dramforever> > Data.Text.Encoding.encodeUtf8 "\0\xff" -- please... tell me I got it right
04:29:58 <lambdabot>  Not in scope: ‘Data.Text.Encoding.encodeUtf8’
04:30:38 <puregreen> dramforever: "\NUL\195\191"
04:31:01 <dramforever> puregreen: thanks for that manual lambdabot-ing :p
04:31:24 <dramforever> > (0xc3, 0xbf)
04:31:25 <lambdabot>  (195,191)
04:31:36 <mauke> dramforever: https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=0xff
04:31:58 <puregreen> maerwald: actually 1.22 seems to have it --allow-newer as well
04:31:59 <dramforever> ooh thanks!
04:32:29 <JohnnyL> maerwald: 1.22.9.0
04:32:51 <dramforever> anyway I was just trying to explain to sdx23 what was going on, but I think everything is clear now :)
04:32:57 <maerwald> JohnnyL: then update
04:33:06 <sdx23> ok, so I'll better forever remember 0xc3bf :) thanks guys, it's all clear now
04:33:08 <maerwald> seems you have a mixture of ghc-8 and ghc-7 libs
04:33:55 <JohnnyL> maerwald: ok
04:39:28 <JohnnyL> wow, this really shouldn't be rocket science.
04:40:01 <JohnnyL> http://pastebin.com/NcB2d0ks
04:41:47 <mauke> hold my beer, arch is upgrading me to ghc 8
04:43:58 * puregreen is glad but still wants to wait till 8.0.2 is out
04:48:41 <JohnnyL> save the pizza, then the bulldog with a pizza slice in his mouth upside down....in that order.
04:50:55 <mauke> don't forget to moonwalk
04:53:40 <JohnnyL> mauke: :D :D
04:53:54 <mauke> "GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help"
04:53:59 <mauke> surely nothing will go wrong
04:55:11 <JohnnyL> mauke: hair style tips such as spiking juniors hair is always 'timely'. :)
05:00:00 <JohnnyL> manually changing the cabal file was *not a good idea (TM).
05:00:54 <JohnnyL> i think I may either go javascript or c++ now. this is too becoming too codependent both socially and technically.
05:01:13 <JohnnyL> s/is too/is 
05:03:59 <quazimodo> I discovered haskell stack yesterday
05:04:14 <quazimodo> is this thing an upstart project or is it gaining acceptance among haskellers?
05:04:35 <tinco> definitely gaining acceptance
05:04:46 <tinco> possibly already defacto standard
05:04:57 <Jinxit> stack is love, stack is life
05:05:01 <tinco> I'm not super embedded in the community, but I wouldn't start a project without stack
05:05:21 <koz_> I'll have to learn stack sometime, it seems.
05:05:28 <koz_> (and just when I was getting the hang of Cabal...)
05:05:37 <Jinxit> it's pretty simple
05:05:40 <tinco> stack wraps around cabal, so not much wasted
05:05:40 <quazimodo> so, i googled for 'bundler for haskell' or 'rake for haskell'
05:05:58 <tinco> yup it's definitely bundler for haskell
05:06:02 <quazimodo> basically, something to init a new project, let me add dependencies and allow me to test/compile/ship
05:06:08 <koz_> Oh, I'm sure it's simple. It's just that I need to add it on to all the other Haskell stuff I need to learn.
05:06:18 <quazimodo> next question
05:06:39 <quazimodo> I quite like the RSpec style of testing, does haskell have a similar test framework?
05:06:44 <tinco> yes
05:07:00 <tinco> it's called hspec :P
05:07:04 <quazimodo> cool
05:07:20 <quazimodo> also
05:07:25 <quazimodo> what is the format of a .cabal file?
05:07:29 <quazimodo> looks like yaml only not
05:07:33 <tinco> I use it in my compiler here: https://github.com/tinco/nanc/blob/master/spec/Spec.hs
05:07:46 <mauke> quazimodo: it's cabal format
05:07:47 <Jinxit> quazimodo: stack for init/deps/etc
05:08:03 <mauke> https://www.haskell.org/cabal/users-guide/developing-packages.html
05:08:06 <quazimodo> I saw it was called test/Spec.h
05:08:14 <quazimodo> does stack init a new projcet with hspec?
05:08:19 <tinco> the cabal format is not something I'd bother learning about
05:09:12 <tinco> hm I don't know if stack init does any opinionated stuff, I'd say no, but I don't remember :P
05:09:31 <tinco> hspec definitely is not something that's standard across haskell
05:09:43 <maerwald> quazimodo: cabal init
05:09:56 <tinco> I use it because I'm also from the ruby world
05:10:08 <tinco> QuickCheck and related tools would be very Haskell-like
05:10:30 <koz_> As someone who's just learned QuickCheck, I can *definitely* vouch for its usefulness.
05:10:35 <quazimodo> tinco: there are 3 choices for me atm. 1) ultra specialize in ruby 2) get into elixir/phoenix (planning on) 3) learn hask more
05:10:47 <quazimodo> i'm thinking, learn haskell before diving into other functional things
05:11:18 <tinco> I always ultraspecialize in everything :P
05:11:56 <tinco> I'm not sold on elixir, but I don't think Haskell is a substitute for ruby per se either
05:12:13 <quazimodo> tinco: why not?
05:13:28 <tinco> well perhaps it's because I haven't got enough lines of Haskell in my fingers yet, but if I think 'ah let's relax and write a small web app or shell script' I dont go for Haskell usually
05:14:26 <JohnnyL> okay gents, well good luck with all that haskell deployment work.
05:14:30 <tinco> I pick Haskell for developing tools and systems where speed and reliability are of concern
05:14:47 <puregreen> tinco: Haskell is my primary language and 2 small webapps later I'm thinking that it'd have been faster to learn Node.js from scratch and write those apps in it
05:15:14 <tinco> what web framework did you pick?
05:15:17 <puregreen> Spock
05:15:29 <quazimodo> tinco: i meant with elixir
05:15:37 <quazimodo> i don't plan on using haskell for webapps
05:15:49 <quazimodo> i want to use it for fast as fuck processing of random things i'll need to process
05:16:02 <mauke> I miss the Perl test modules in Haskell
05:16:04 <tinco> quazimodo: oh haha :D because it's on the Beam vm and I don't buy into that for non-telephony related software :P
05:16:24 <quazimodo> tinco: web io and socket stuff is essentially ... that
05:16:31 <quazimodo> bouncing stuff around without much processing
05:16:46 <tinco> web applications are the opposite of distributed, they are embarassingly parallel
05:16:49 <tinco> usually
05:16:54 <quazimodo> and if processing's needed, socket it out to a program that processes well
05:17:25 <quazimodo> that's not the case with future tech
05:17:30 <quazimodo> 5 years ago webapps yeah
05:17:31 <quazimodo> now?
05:17:34 <quazimodo> nah
05:17:39 <quazimodo> give it a few more years
05:18:05 <quazimodo> anyway it does a buttload of sockets pretty easily and seems simple enough to use, i think it's a good step
05:18:17 <tinco> I don't see the case for web applications having to communicate with eachother much, maybe for games
05:18:38 <quazimodo> the apps to each other no, but the consumers of those apps to each other... yes... 100% definitive yes
05:18:43 <tinco> all other cases, just slap it on a nice reactive backend like perhaps RethinkDB, and it'll do most if not all distributedness for you
05:19:05 <quazimodo> havent used rethinkdb yet, good things?
05:19:24 <tinco> I haven't used it in production yet, but I've done some hobby things with it and I'm impressed
05:19:51 <tinco> it has streams out of the box with a nice syntax, so for example writing a websocket chat app will just work without any trouble
05:20:01 <mauke> if I'm reading this right, hspec doesn't support todo tests
05:20:08 <mauke> :-/
05:20:50 <quazimodo> iget the impression that rethinkdb takes care of receiving updates te records and pushing the updates out to subscribers
05:20:59 <mauke> https://github.com/tinco/nanc/blob/master/spec/Spec.hs#L41 wtf
05:20:59 <tinco> yes
05:21:06 <quazimodo> doesn't really do much processing etc, but rather does receiving/delivering of model data
05:21:19 <tinco> mauke: muahaha
05:22:06 <tinco> mauke: it maybe shows a little that I didn't know much about hspec :D I wanted the test to pass if it got to that line
05:22:15 <tinco> i.e. the line before it shouldn't throw an error
05:22:30 <mauke> your lets are no-ops
05:22:33 <tinco> there's probably a fn to do that a little more semantic..
05:22:41 <tinco> oh right
05:22:49 <tinco> maybe it's just a stub then
05:22:51 <mauke> probably needs some 'evaluate' in there
05:23:13 <hexagoxel> mauke: `before_ pending $ sometest`
05:23:29 <tinco> the test after it actually does the same thing, I want to refactor the suite to test all phases seperately
05:23:54 <quazimodo> puregreen: how'd your webapps get so slow to build?
05:24:15 <mauke> all of these haskell test frameworks seem to come with so much elaborate machinery
05:24:30 <mauke> and they all have their own special way of running tests
05:24:35 <mauke> or no way, in the case of hunit
05:25:24 <tinco> oh mauke above that line L41: 			pendingWith "This doesn't do anything.."
05:25:33 <tinco> so I did know what I was doing ;)
05:25:34 <mauke> hexagoxel: oh cool, an undocumented feature
05:25:36 <mauke> :-/
05:26:22 <mauke> hexagoxel: the documentation doesn't actually say what 'pending' does
05:26:29 <hexagoxel> it is documented in the bugtracker. don't you read that?
05:26:32 <mauke> heh
05:26:36 <hexagoxel> :p
05:26:59 <hexagoxel> (this is where i found out about it.. :D)
05:27:03 <mauke> why can't I just have https://metacpan.org/pod/Test::Simple#SYNOPSIS ?
05:29:00 <puregreen> quazimodo: “oh, I'll use acid-state, it's cool”; a month later – “migrations are the worst things ever, I hate changing my types”. Then, “I'll generate my HTML with this nice DSL”; a month later it becomes a mess with implicit dependencies everywhere. Currently I don't see any way to make it work nicely without something like React's server-side rendering, but I don't know how to combine that with Haskell.
05:31:20 <mauke> in perl, no matter what module you use for your tests, there's a simple tool ('prove') to run them
05:31:52 <mauke> you can start with some really bare bones tests, like a 5 lines test file using Test::Simple
05:32:24 <mauke> then you can switch to Test::More, which provides a couple of features on top
05:32:52 <mauke> such as the ability to mark tests as "todo" so they don't count as failures (but you'll get a notification if they unexpectedly succeed)
05:33:15 <mauke> or the ability to skip tests based on some condition
05:33:18 <quazimodo> puregreen: i've been investigating opal and react.rb specifically for that stuff
05:33:37 <mauke> but the best thing is, there's no weird DSL
05:34:03 <mauke> and you can combine all test modules that are based on Test::Builder and use them together
05:34:14 <quazimodo> puregreen: i think any web framework of today *must* accomplish server & client side widgets, as well as flawless & simple websockets & sse
05:34:16 <mauke> or write your own ad-hoc test helper
05:34:48 <quazimodo> any http webserver anyway, a server designed for ios & android api can be in whatever language 
05:34:50 <mauke> e.g. Test::Deeply can do some pretty fancy stuff with nested data structures and objects
05:35:05 <quazimodo> i think rails is fucking great for ios/android api
05:35:09 <mauke> or Test::Fatal for exceptions
05:36:21 <mauke> also, no overlyVerboseJavaNames (looking at you, hunit)
05:36:41 <mauke> you use 'is', not 'assertEqual'
05:42:43 * hackagebot th-data-compat 0.0.2.2 - Compatibility for data definition template of TH  https://hackage.haskell.org/package/th-data-compat-0.0.2.2 (KeiHibino)
05:44:23 <tinco> quazimodo: what are server & client side widgets?
05:45:08 <garay> how would I find the keys, given an elem in Data.Map?
05:45:39 <mauke> by searching all elements
05:45:45 <edwardxhaigh> Is every Haskell freelancer an Oxford PhD or something? I was looking at a couple on LinkedIn, and they all had superb credentials
05:46:10 <garay> mauke: Is there no better method?
05:46:38 <mauke> garay: use a better data structure?
05:46:44 <puregreen> edwardxhaigh: I'm a Haskell freelancer and I have no credentials whatsoever :)
05:47:06 <garay> mauke: haha, right
05:47:07 <puregreen> ...and no clients either :(
05:48:07 <edwardxhaigh> Haha Puregreen! Good to hear, just like me then (except I am not a freelancer). 
05:48:15 <edwardxhaigh> The last part, not so good to hear of course!
05:48:33 <edwardxhaigh> Do you reckon it's your location? Or is remote work hard to come by aswell?
05:52:05 <puregreen> probably just lack of finished projects to show (off)
06:02:44 * hackagebot crypto-multihash 0.3.0.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.3.0.0 (mseri)
06:02:46 * hackagebot cabal-debian 4.32.5 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32.5 (DavidFox)
06:05:56 <pii> i have a dependency that does not exist in stackage, is it possible to instruct stack to get this dependency from hackage?
06:07:33 <mettekou> What would be the easiest way to use uniplate with bound?
06:11:13 <hpc> does ghc have an option yet to strip an executable itself?
06:12:08 <puregreen> pii: I think that's what the extra-deps section is for
06:12:48 <pii> puregreen: yeah, i just figured it out, i had another problem in the stack.yaml that confused me, it works now!
06:13:22 <Axman6> pii: the error message from stack should have told you exactly the line to add to the stack.yaml too
06:13:30 <hpc> on windows it seems stripping executables is a compiler-specific operation
06:14:16 <pii> the error i got was: «Error parsing targets: The project contains no local packages (packages not marked with 'extra-dep')»
06:14:28 <pii> had to comment out the targets to fix it
06:16:17 <pii> eh, packages*
06:24:20 <quazimodo> tinco: um any data driven interactive 'view component' i guess
06:24:25 <quazimodo> eg a shopping basket view
06:24:52 <quazimodo> it's a bitch to write the html once to render server side,then have to either jquery touch it, reimplement as template or something like that for client side
06:25:13 <quazimodo> nicest approach is to declare it once, make it available to server & client side at the same time and have both 'just use it'
06:25:21 <quazimodo> react.rb does that nicely for ruby anyway
06:27:45 * hackagebot exp-pairs 0.1.5.1 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.1.5.1 (Bodigrim)
06:28:41 <osager_> what does the Monoid operator do <> ? does it chain two functions?
06:28:51 <hpc> (<>) = mappend
06:28:51 <osager_> let f = (+) <> (*)
06:29:07 <hpc> mappend is "an associative operation"
06:29:23 <osager_> :t f
06:29:24 <lambdabot> FromExpr a => a
06:29:37 <hpc> the only property it needs to obey is that mempty is an identity of it
06:30:02 <hpc> (beyond being part of an instance of Monoid that the compiler accepts)
06:30:11 <jchia> Hi, how do I make something like this work? I want to make a Functor instance for Two but apply the function to a.
06:30:11 <jchia> data Two a b = Two a b deriving (Eq, Show)
06:30:11 <jchia> instance Functor ((flip Two) b) where
06:30:11 <jchia>     fmap f (Two x y) = Two (f x) y
06:30:24 <jchia> This doesn't compile
06:31:11 <jchia> I know how to make it work if i just want to apply functions to b
06:32:21 <hpc> using flip like that is a kind error
06:32:41 <jchia> yes, but i should i express this?
06:32:45 * hackagebot fbmessenger-api 0.1.1.1 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.1.1 (mseri)
06:32:48 <jchia> but how should i express this?
06:32:58 <hpc> use Flip from Data.Bifunctor.Flip
06:33:13 <hpc> newtype Flip p a b = Flip (p b a)
06:33:36 <hpc> instance Functor (Flip Two a) where ...
06:33:47 <hpc> and you'll have to do some wrapping and unwrapping of the Flip newtype
06:34:34 <hpc> actually, an easier way:
06:34:54 <hpc> if that data type is exactly what you need
06:35:02 <hpc> use type Two = (,) or something
06:35:22 <hpc> (,) has a Bifunctor instance (basically, a functor on both a and b)
06:36:27 <hpc> and Flip has an instance that makes the ordinary functor on a if the type is also Bifunctor
06:36:33 <hpc> https://hackage.haskell.org/package/bifunctors-5.3/docs/Data-Bifunctor-Flip.html
06:36:40 <hpc> https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bifunctor.html#t:Bifunctor
06:37:35 <jchia> that was just to learn to use Functors. So I suppose there's no simple way and if I want a simple way I have to reorder a and b?
06:38:13 <hpc> correct
06:38:30 <osager_> how to understand this "chain" of function ?
06:38:31 <osager_> sortBy (comparing (!! (n-1)) <> compare) xs
06:38:43 <osager_> with the <>
06:38:57 <hpc> :t comparing
06:38:58 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
06:39:07 <hpc> :t compare
06:39:08 <lambdabot> Ord a => a -> a -> Ordering
06:39:16 <SrPx> Could anyone link me to that András Kovács post about implenting a dependently typed language efficiently with HOAS (or something like that)?
06:39:18 <hpc> hmm
06:39:38 <SrPx> Oh found it
06:40:40 <hpc> osager_: i assume the instance being used there means if the result of the first comparison is EQ, it tries the second comparison
06:41:09 <hpc> osager_: ah, yes
06:41:12 <hpc> osager_:  Monoid b => Monoid (a -> b)
06:41:33 <hpc> osager_: so Ordering is a Monoid, with (a <> b) = if a is EQ then b else a
06:42:08 <osager_> ?
06:42:17 <hpc> osager_: and a function that ends with Ordering is a Monoid with (a <> b) = apply the same parameters to a and b, then do resultA <> resultB
06:42:53 <hpc> basically it's a way to chain custom comparisons
06:43:12 <osager_> ok i will check how Ordering implements the MOnoid Class
06:44:00 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-302
06:44:51 <hpc> it's one of the niftier features of haskell
06:45:03 <osager_> thanks hpc 
06:45:10 <osager_> what is the y in the source?
06:45:27 <hpc> just the second parameter to mappend
06:45:50 <hpc> it's the same as "mappend EQ y = y"
06:46:22 <osager_> so it means that if the first is EQ, it compares uses the second 
06:46:24 <osager_> comparison
06:46:35 <hpc> yep
06:46:43 <osager_> it uses the second function
06:47:27 <osager_> ok great
06:47:30 <nitrix> Does GHCI lets you undefine something?
06:47:45 <nitrix> I'm playing with IORef and Weak.
06:48:19 <hpc> not possible sadly
06:48:42 <hpc> you can redefine things though
06:48:51 <hpc> which you might be able to use to the same result
06:48:53 <osager_> what about clear all ghci definitions?
06:48:57 <nitrix> hpc: Redefining is usually okay, but not for the purpose of testing Weak.
06:49:11 <hpc> ah, hmm
06:49:17 <nitrix> Although, I can try.
06:49:23 <nitrix> Will it redefine or shadow?
06:49:29 <hpc> shadow
06:49:44 <hpc> which i think removes the reference to the thing and makes it GC
06:49:50 <hpc> but you'll have to test it
06:50:01 <aisqwe> is the IO monad implemented low level or is it entirely in haskell itself?
06:50:10 <nitrix> Yup, it's shadowing the older IORef by the new one, the Weak is unaffected.
06:50:31 <hpc> aisqwe: there's many levels of answer to that question
06:50:37 <nitrix> aisqwe: IO is an Haskell type with perfectly valid definitions (functor, monad, and such).
06:50:43 <hpc> aisqwe: the highest-level answer is that IO is abstract - it has no definition, it merely exists
06:50:45 <nitrix> aisqwe: What's magical is how it's executed.
06:51:14 <aisqwe> nitrix: what makes IO monad execute different than other code?
06:51:35 <nitrix> aisqwe: Your `main` has type IO. Something has to run the IO eventually.
06:51:46 <hpc> aisqwe: the next level down is looking at GHC source, which says newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
06:51:51 <nitrix> aisqwe: Otherwise, you're just accumulating / combining side-effects without ever doing anything with them.
06:52:16 <hpc> aisqwe: but this is a bit of a lie, RealWorld is defined as a type that doesn't exist at all at runtime
06:52:23 <hpc> aisqwe: and State# is similarly defined
06:52:33 <nitrix> Yep, RealWorld is also magical just to make referential transparency work :P
06:52:35 <hpc> aisqwe: so those only really exist to enforce ordering of instructions, which are of type 'a'
06:52:45 <hpc> aisqwe: and side-effects happen in values of that type
06:53:03 <hpc> aisqwe: but wait! a can be anything!
06:53:27 <hpc> aisqwe: so when you run putStrLn "wut", it's actually a value of type () that does the printing
06:53:42 <hpc> and that's the story of how ghc haskell is "impure"
06:53:46 <aisqwe> so if we want to make something similar to IO that executes in a certain way without using IO, we cant do it purely in haskell?
06:53:51 <hpc> correct
06:54:08 <hpc> you can make a type that uses IO underneath and exposes a more limited interface
06:54:22 <nitrix> aisqwe: You'd have a similar contraption in all parts, except you'd need to use IO eventually, probably unsafePerformIO.
06:54:24 <hpc> give it an instance of Monad or whatever, then have runFoo :: Foo a -> IO a, or whatever
06:54:38 <nitrix> aisqwe: Depending what your goal is.
06:55:04 <hpc> unsafePerformIO can be valid if you can prove for super-seriously certain that what you're doing with IO is actually pure
06:55:33 <hpc> but if it's not you get very hard to debug misbehavior
06:56:09 <nitrix> I'd assume he knows about that if RealWorld is put on the table.
06:56:11 <hpc> and its mere existence affects a lot of invariants for reasoning about code, so it's discouraged
06:57:20 <hpc> but yeah, the main point is that IO is abstract, it could be defined in any which way as long as the interface to it stays the same
06:57:22 <maerwald> hpc: did you count the times ghc uses unsafePerformIO? ;)
06:57:55 <hpc> i avoid looking too closely at ghc if i can help it
06:58:13 <hpc> if nothing else, to not have to look at the heinous style in which it is written
06:58:33 <maerwald> I guess you can do it better :P
06:59:15 <hpc> merely prettier ;)
06:59:18 <maerwald> if you write something useful, it usually does not end up particularly pretty
06:59:25 <nitrix> maerwald: ghc has implemented GHC twice.
06:59:29 <nitrix> hpc*
06:59:42 <mauke> haskell pascal compiler
07:00:26 <nitrix> That's a mouthful.
07:02:15 <hpc> ew, stack's allow-newer makes it ignore version bounds in both directions
07:02:18 <nitrix> hpc: Anyway, for my question about GHCI, thanks.
07:02:31 <hpc> did it work
07:02:32 <hpc> ?
07:21:40 <hvr> hpc: that's stilly :-(
07:21:50 <hvr> silly
07:22:15 <hpc> ben stilly
07:22:29 <hvr> hpc: fwiw, in cabal there'll soon be an --allow-older (https://github.com/haskell/cabal/pull/3466)
07:27:47 * hackagebot singletons 2.2 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.2 (RichardEisenberg)
07:32:33 <osager_> how to can apply inttoDigit to Integer
07:32:34 <osager_> intToDigit :: Int -> Char
07:32:47 * hackagebot elerea 2.9.0 - A minimalistic FRP library  https://hackage.haskell.org/package/elerea-2.9.0 (GergelyPatai)
07:34:19 <Koen_> someone made a go program in haskell!
07:35:55 <osager_> ll
07:36:18 <srhb> osager_: You cannot.
07:36:45 <srhb> osager_: But you can convert your Integer to Int (if it's in the correct range)
07:37:47 <srhb> > intToDigit . fromInteger $ 9
07:37:48 <lambdabot>  '9'
07:38:08 <osager_> ok
07:38:10 <osager_> great
07:38:49 <joneshf-laptop> Koen_, what does that mean?
07:39:02 <Koen_> a program that plays the game of go
07:39:12 <Koen_> an artificial intelligence for a strategy game
07:39:29 <srhb> Koen_: Ah, confusing what with the "Go" programming language :P
07:39:34 <Koen_> :)
07:39:51 <Koen_> though in that case this program doesn't play so well
07:40:03 <MichaelBurge> Every type is inhabited by its defined values, and also bottom. Is the non-terminating bottom the same as the error bottom even though they have different behavior?
07:40:29 <mauke> MichaelBurge: yes
07:41:14 <joneshf-laptop> what would it mean to have different bottoms?
07:41:22 <joneshf-laptop> Is that a thing in another language?
07:42:34 <MichaelBurge> Well, practically speaking, you could at any time imagine casting a boxed value to a C pointer and manually inspecting the thunk to get some information about the loop
07:42:42 <MichaelBurge> While the error bottom eventually ends in a call to raise#
07:42:48 * hackagebot dow 0.2.6 - Dungeons of Wor  https://hackage.haskell.org/package/dow-0.2.6 (GergelyPatai)
07:43:26 <MichaelBurge> So there seems to be a difference in whether they terminate
07:46:48 <MichaelBurge> Does bottom have something concrete in the compiler(besides black-hole thunks) to represent it, or is it just an abstraction used to reason about behavior from the language?
07:57:32 <joneshf-laptop> wow `dow` is kind of fun
08:00:03 <geekosaur> MichaelBurge, it's abstract. Bottom is nontermination, it can't be represented in a concrete fashion
08:03:27 <monochrom> when you need to differentiate infinite loops from exceptions, you don't use the word "bottom".
08:04:03 <monochrom> bottom is when you don't need the distinction. when is that? when you just ask: do I get an answer?
08:04:23 <malice> Hey guys! What were the function used for [a..b] and other variations of this, underneath?
08:04:55 <monochrom> and when is that? when you figure out why recursion is well-defined.
08:05:24 <codedmart> How do I access the response body in wai? I want to modify the response body.
08:05:25 <MichaelBurge> malice: enumFromTo is the name, I think
08:05:33 <malice> yes, and other starting with enum
08:05:33 <malice> thanks!
08:09:34 <monochrom> my http://article.gmane.org/gmane.comp.lang.haskell.cafe/20686/ shows how bottom is used to explain recursion.
08:09:56 <monochrom> in a sense, you use bottom when at the end you won't have any bottom left.
08:11:29 <monochrom> actually, here is a better one: http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231/
08:13:57 <MichaelBurge> Is bottom a catch-all for literally any behavior that doesn't produce a standard Haskell value? Non-termination, runtime exceptions, CPU exceptions, kernel signals,
08:14:11 <MichaelBurge> kernel doing a context switch and never bothering to switch back to the process, etc.
08:14:21 <monochrom> no, I wouldn't do that.
08:17:00 <monochrom> firstly I would confine bottom to non-IO expressions. secondly I would confine it to no-answers caused by the expression itself, infinite loop or division by zero.
08:18:00 <monochrom> other exceptions and external interrupts are better off kept as exceptions and part of IO semantics rather than part of non-IO semantics.
08:19:28 <geekosaur> technically they are "bottoms" as well, but you can't reason about them. where bottom is useful is in reasoning about expressions, so in practice we talk about only the ones we can reason about
08:19:56 <osager_> when i add a Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +... how can i get more precision?
08:20:20 <monochrom> I am using bottom to explain recursion. I use it to explain x=0:x and s = 1 : scanl (+) 1 s. why should I worry about signals?
08:20:23 <fr33domlover> osager_, you could use Rational
08:20:25 <geekosaur> osager_, use a more precise type like Scientific or CReal
08:20:32 <geekosaur> or Rational for series, yeh
08:20:34 <fr33domlover> but it depends on how much precision you want
08:20:41 <osager_> Great
08:20:42 <osager_> thanks
08:21:00 <monochrom> and I certainly don't use bottom to explain openFile.
08:21:44 <osager_> so Rantional is more precise than float ?
08:22:01 <geekosaur> and there are those of us who think openFile throwing an exception instead of returning an Either is a mistake
08:22:42 <geekosaur> osager_, yes. Float and Double are inherently inaccurate by design, because you can't represent e.g. logarithms exactly except by building them into your representation
08:23:09 <osager_> sum . take n $ (zipWith (/) (repeat 1) [(n*3 - 3)+1 | n <- [1..]] :: [Rational]) :: Rational)
08:23:16 <osager_> doesn't seem to work
08:23:29 <geekosaur> Rational is Ratio Integer; as long as you can represent a value that way (which you can for series like that), it can represent exactly although it could take a lot of memory
08:24:05 <monochrom> also a lot of time
08:25:05 <monochrom> yeah, if you want "I mean I can get 100 bits, I still don't need the exact answer", then Scientific or CReal
08:26:19 <geekosaur> osager_, you'd have to define "doesn't seem to work". as written that expression is nonsense because you're trying to use a binding local to a list comprehension outside of that comprehension (n)
08:27:23 <osager_> let s n = sum . Data.List.take n $ (Data.List.zipWith (/) (repeat 1) [(n*3 - 3)+1 | n <- [1..]] :: [Rational])
08:27:49 * hackagebot elerea-examples 2.9.0 - Example applications for Elerea  https://hackage.haskell.org/package/elerea-examples-2.9.0 (GergelyPatai)
08:28:02 <osager_> SeriesSum(5) => 1 + 1/4 + 1/7 + 1/10 + 1/13 = "1.57"
08:28:08 <geekosaur> and if you treat the outside n as separate then the result you get is a ratio (Integer % Integer) which you would have to resolve yourself --- losing precision in the process, one way or another
08:28:19 <osager_> Im working on a exercise, and my program doesnt pass the test
08:28:25 <geekosaur> unless you use a CReal or Scientific and size it large enough
08:28:36 <osager_> ok
08:28:52 <osager_> how can i turn the ratio result to a 4 digit precision number
08:29:27 <osager_> just wnat 2 digits after .
08:29:47 <monochrom> look into the module "Numeric"
08:30:51 <osager_> great
08:30:53 <osager_> Thanks
08:32:04 <geekosaur> > flip (Numeric.showFFloat (Just 2)) "" $ fromRational $ (sum . take 5 $ (zipWith (/) (repeat 1) [(n*3 - 3)+1 | n <- [1..]] :: [Rational]) :: Rational)
08:32:05 <lambdabot>  "1.57"
08:32:25 <osager_> geekosaur, cool
08:44:21 <buttbutter> Is there any reason to use hGetContents over getContents when reading from a text file?
08:44:51 <geekosaur> when you're not reading stdin
08:45:05 <geekosaur> which is the only difference; getContents = hGetContents stdin
08:45:18 <buttbutter> Oh! That makes a lot of sense. 
08:45:20 <buttbutter> Thanks :D
08:45:38 <buttbutter> (my text only presented the stdin case so I didn't really consider the others...)
08:45:38 <monochrom> ?? have you read the docs?
08:45:38 <lambdabot> Plugin `compose' failed with: Unknown command: ""
08:45:52 <geekosaur> unless you've done something silly like import one from Prelude and the other from the text package, or something
08:48:58 <BW^-> what object databases are there?
08:50:30 <srhb> BW^-: What's an object database?
08:52:03 <mikail`> Hi, why are unsigned integer types called Word in Haskell?
08:53:06 <Cale> mikail`: I guess just computing tradition?
08:53:08 <srhb> mikail`: Someone named them thusly.
08:54:34 <srhb> mikail`: http://stackoverflow.com/questions/22544720/why-is-data-word-in-haskell-called-that -- but I don't think it's very enlightening. Ultimately, it's just a name.
08:54:47 <Jinxit> are there any pure functional languages meant for embedded systems?
08:55:03 <srhb> Jinxit: Atom?
08:55:06 <Jinxit> garbage collection usually doesn't play nice with realtime requirements
08:55:10 <Jinxit> I'll look at it
08:55:32 <srhb> Well, it's a bit cheaty
08:55:52 <geekosaur> atom's a bit different; it's a functional DSL for writing embedded programs which are themselves not functional
08:55:57 <srhb> Atom is an edsl for designing hard realtime applications
08:56:03 <geekosaur> nhc98 used to target embedded systems
08:56:18 <srhb> So you're leveraging one purely functional language to generate a decidedly not program.
08:56:40 <Cale> mikail`: It's related in sense to this: https://en.wikipedia.org/wiki/Word_(computer_architecture) -- the unqualified "Word" type is meant to be of whatever size your processor naturally operates on (as with Int), and then just as with Int8, Int16, Int32, Int64, there are Word8, Word16, Word32, Word64
08:56:41 <Jinxit> atom seems very limited as well
08:56:50 <Jinxit> from a brief glance
08:57:19 <Jinxit> I mean it's fine that the end result is not functional, just like ghc can use mutable memory for all I care
08:57:25 <Jinxit> as long as it looks immutable to the programmer
08:57:26 <geekosaur> hard realtime doesn't generally give you a lot fo flexibility
08:57:49 <mikail`> thanks - i'm making a mountain out of mole hill 
08:59:21 <Jinxit> essentially what I'm looking for is something between C and haskell
08:59:34 <Jinxit> since a lot of embedded stuff is still written in C apparently
09:00:05 <Jinxit> which seems strange to me, as a functional language would be much easier to reason about (when it comes to safety)
09:00:13 <geekosaur> not strange at all
09:00:35 <geekosaur> embedded systems generally have fairly tight realtime constraints. C can deliver on that. high level languages can't
09:00:54 <Jinxit> why not?
09:01:12 <geekosaur> the more abstract, the less precise the time constraint. but embedded systems need tight time constraints
09:01:17 <Cale> Well, fsvo "can't" -- I think metaprogramming using a high level language is a really interesting technique in that regard.
09:01:25 <Jinxit> ^
09:01:35 <Jinxit> that's basically what I was thinking as well
09:01:51 <Jinxit> there should be a sweet spot where you're not sacrificing performance
09:02:04 <mikail`> Cale: I'm still not grokking type families. I understand that they can be used in polymorphic functions to constrain the particular type of one of the type parameters but is that the only use of this facility?
09:02:07 <Jinxit> but through use of more strict types you can be more sure of the correctness
09:02:19 <Jinxit> (even though it's still not something like coq or idris)
09:02:40 <geekosaur> that's the space Atom is in. it's still not a very well developed field; if you are looking to use it in production, you're likely to be treading Ph.D. ground >.>
09:03:08 <geekosaur> (in the sense of, you're pushing the limits of what is known about it and likely to make new discoveries)
09:03:30 <Jinxit> seems more like an engineering thing to me
09:03:30 <Cale> mikail`: They're basically type-level functions
09:03:35 <geekosaur> unless you stick to the subset that things like Atom already provide, which as you saw was limited
09:03:51 <mikail`> Cale: I can't wrap my brain around that
09:03:56 <geekosaur> engineering is applied theory. the theory here is still lacking...
09:04:14 <mikail`> how is that different from normal functions?
09:04:32 <Cale> Well, you're computing a type rather than a value
09:05:08 <geekosaur> (that's on oversimplification, since there's feedback in both directions, but there's limits to what you can engineer without some understanding of how things interact, which leads to theory. or its opposite, as demonstrated by the Tacoma Narrows Bridge...)
09:05:14 <mikail`> I'm using a function to compute a type?
09:05:34 <mfukar> I suppose the idea is to replace run-time tasks with compile-time deduction, and then the next step is to offer certain latency guarantees on those tasks, at the end of which is a real-time application
09:06:03 <Jinxit> yeah you're probably more informed than me on this subject
09:06:12 <Cale> mikail`: Yeah, from another type as its input
09:06:20 <puregreen> is there any Emacs plugin for jumping to Notes (as in GHC source)?
09:06:21 <Jinxit> C just sounds like insanity when trying to write safe code
09:06:25 <Cale> mikail`: at compile time (types don't exist at runtime)
09:06:41 <mikail`> ok - that bit is understood
09:06:53 <mikail`> can you give me a simple example of when this would be useful?
09:06:53 <mfukar> Jinxit, there's a lot of mental overhead, but - as in every language - idioms & tools help
09:07:05 <Cale> mikail`: For example, you might compute the type of scalars for a vector type.
09:07:34 <Cale> So, you'd have some type family Scalar v
09:07:42 <Cale> perhaps as a class associated type
09:07:50 <Cale> class VectorSpace v where
09:07:54 <Cale>   type Scalar v
09:08:04 <Cale>   (.*) :: Scalar v -> v -> v
09:08:10 <Cale>   ... etc. ...
09:08:33 <mikail`> so this constrains the type of v in this typeclass?
09:08:47 <Cale> and then in the instances of the class, you say what Scalar does when matching individual type constructor that the instance is for
09:08:51 <Cale> no
09:08:56 <Cale> It doesn't constrain v
09:09:05 <mikail`> oh so in the instance I would say what v is
09:09:18 <Cale> Not only would you say what v is, you would say what Scalar v is
09:09:28 <mikail`> ok I get it
09:09:38 <mikail`> thanks for that
09:09:40 <Cale> In the instances you always say what v is, that's nothing to do with associated types or type families
09:09:51 <mikail`> yep
09:10:11 <mikail`> how does the word family come into?
09:10:39 <EvanR> if writing C code is like playing marble madness, then haskell is like entering in a cheat code for flying marble
09:11:22 <EvanR> (not guard rails)
09:11:45 <Cale> mikail`: That's just another name for "function" when you're looking at things in a particular way, compare for example "family of sets"
09:12:13 <Cale> Or, well, I suppose it would be an "indexed family of sets"
09:12:27 <Cale> https://en.wikipedia.org/wiki/Indexed_family
09:12:28 <EvanR> indexed family of sets 
09:13:45 <Cale> It's really just a funny name for a function, which puts a certain emphasis on the collection of things in the function's range
09:14:27 <Cale> Here, we have a family of types, indexed by types.
09:14:52 <mikail`> cool - that makes sense
09:17:00 * mikail` waves goodbye
09:19:26 <muzzle> hi
09:19:48 <muzzle> is there a difference in memory between (Vector a) and [a] if the list is fully evaluated?
09:19:57 <muzzle> memory usage to be precise
09:20:33 <EvanR> yep
09:20:35 <glguy> muzzle: Yes, the list case will use more
09:21:07 <EvanR> also the list may not have as good locality
09:21:54 <shirt> How can I detect if my program is being running interpreted or from a compiled version? getProgName? Is there a better way?
09:22:08 <Prutheus> Hello! I know that not everybody of you know how CLASH works, so first let me tell you: I have code, which gives to the function blinkerT (state data) input = (new state data) output     .... so with these infos, maybe you cann tell me how i can do it that when mode is false, the leds should be 0 (0b000) BUT when mode becomes True again, it needs to go on with the leds' computation of the leds before 
09:22:14 <Prutheus> they became 0b000, that the rotation continues .... if this all sounds crazy for you, here is the code: http://ix.io/UFB
09:22:19 <Prutheus> if you didn't understand something correctly, just ask please
09:22:34 <EvanR> shirt: compile in a True instead of a False using a directive?
09:22:57 <muzzle> I'm having trouble with MUT_ARR_PTRS_FROZEN showing up in my heap profile for an application that goes away when i substitute Vector with List, but I can't figure out why
09:22:59 <shirt> EvanR: what is a directive?
09:22:59 <muzzle> any pointers?
09:24:28 <EvanR> shirt: a defined flag... like ghc -DYEP_COMPILED
09:24:53 <EvanR> cpp can be use in the code to put a True or False at the top level
09:25:00 <shirt> EvanR: ah, I see. this is for a library though
09:25:33 <EvanR> then im not sure what youre checking
09:25:40 <mauke> shirt: why do you need to know?
09:26:23 <shirt> mauke: I need the program to copy itself to another machine and run it there
09:26:57 * EvanR looks for a virus package
09:27:19 <osager_> subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
09:27:24 <osager_> how can i get "ba"
09:27:35 <shirt> EvanR: =D
09:27:35 <osager_> and "ca"
09:27:52 * hackagebot twitter-conduit 0.2.1 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.2.1 (TakahiroHimura)
09:28:04 <mauke> isSuffixOf "/ghc" <$> readSymbolicLink "/proc/self/exe"
09:28:57 <muzzle> Is there anyone who has encountered a space leak of MUT_ARR_PTRS_FROZEN spaceleak caused by use of immutable vectors here?
09:29:21 <Prutheus> liste: are you here?
09:30:01 <EvanR> muzzle: are you making sure the evaluate expressions involving updates to vectors
09:30:06 <EvanR> sure to*
09:31:50 <jmcarthur> shirt: I came in to this conversation late, but I have done the thing you just asked about (having a program copy itself to another machine and run itself). What's the question I missed?
09:32:39 <shirt> jmcarthur: hi. my first issue it to detect whether the program is being run interpreted, so that I can raise an error
09:32:54 <jmcarthur> Ah, that particular issue is not one I dealt with.
09:33:23 <shirt> jmcarthur: would you mind briefly explaining your general approach?
09:33:26 <EvanR> whats the definition of being interpreted?
09:34:23 <Prutheus> noone here who wanna help me? :/
09:34:40 <srhb> Prutheus: I don't think your problem is clearly understood
09:34:53 <jmcarthur> shirt: All I did was scp /proc/self/exe to the remote machine and invoke it via ssh. That wouldn't work if being interpreted though.
09:35:11 <srhb> Prutheus: Is this even clash specific, or are you just asking how to "go back" to returning the next result instead of 0b000 when mode is True?
09:35:29 <Prutheus> srhb: i know, but the point is, i would like to find someone who thinks: yes, i am intelligent and logical, i could maybe help. like you for example. then i write you my problem more detailed in response to detailed questions from you
09:35:55 <EvanR> Prutheus: dont ask to ask, just ask
09:36:00 <Prutheus> srhb: i am not fully sure if this is correct, but your second statement sounds like my wish
09:36:19 <srhb> Prutheus: I think most people are more keen to respond to a very well designed question, rather than being baited into it. :-)
09:36:39 <shirt> jmcarthur: thanks. EvanR: in my case, being interpreted means running in such as way that the technique just described by jmcarthur will blow up
09:37:30 <srhb> Prutheus: So, is your quesiton essentially foo val flag = if not flag then 0 else (val+1) ?
09:37:33 <jmcarthur> shirt: Oh, sorry, there was some trickiness in the approach I just described that I forgot about.
09:37:54 <jmcarthur> shirt: If you do literally what I just said, you will just copy the scp executable to the remote machine.
09:38:08 <Prutheus> srhb, you see the block where leds' is defined?
09:38:14 <srhb> Prutheus: Yes.
09:38:20 <jmcarthur> shirt: You have to perform an appropriate syscall to copy /proc/self/exe to somewhere else without shelling out. Then you can transfer the copy.
09:38:38 <mauke> jmcarthur: or copy /proc/YOURPID/exe
09:38:50 <jmcarthur> mauke: 
09:38:53 <jmcarthur> oops
09:38:55 <jmcarthur> mauke: yes
09:39:04 <shirt> jmcarthur: ah, makes sense. what about using System.Environment.getExecutablePath ++ System.Environment.getProgName. Is there some pitfall with this?
09:39:38 <jmcarthur> shirt: You also should avoid using syscalls that behave differently when the file is a symlink. /proc/self/exe and /proc/PID/exe are exposed as oddly behaving symlinks.
09:39:59 <jmcarthur> shirt: getExecutablePath wouldn't have worked in my case because I needed it to work even if the exe was moved or deleted after starting it.
09:40:38 <jmcarthur> shirt: (And you might think that means symlinks wouldn't work, but like I said, /proc/self/exe is special and still works even when the orginal exe is moved or deleted.)
09:40:38 <Prutheus> srhb: so, what happens there is following: if mode is true, then the leds (1 is activated at the initalizing) are rotating, so it is like a moving light over my three led's, but when i press my switch, this rotation gets stopped, but the current lighting led stays ofc illuminated, what i dont want, everything should be  black then, you understand?
09:41:29 <Prutheus> srhb: but i can just say: if not mode then 0, because it is going to operate with the output as input again, what means if it is mode true again, it will rotate nothing because it is 0
09:41:34 <Prutheus> srhb: you understand?
09:41:40 <srhb> Prutheus: So "else leds" is wrong
09:41:44 <srhb> Prutheus: You want else 0b000?
09:42:14 <Prutheus> srhb: exactly not, then it happens what i described just above
09:42:21 <Prutheus> with the nothing gets rotated anymore
09:42:41 <jmcarthur> mauke: Ah, in fact, I now see that I did eventually end up switching to /proc/PID/exe. I guess that was easier than copying.
09:42:41 <Prutheus> srhb: let me tell you an example solution
09:43:34 <Prutheus> srhb: when mode becomes false, then i need to store the current leds and output 0, when it becomes true again, the stored leds must be reused as normal leds, you know?
09:44:13 <jmcarthur> shirt: Another reason not to use getExecutablePath is that sometimes arg0 (which I presume getExecutablePath uses?) might be changed or deleted. You may have enough control over your environment that this is not a problem though.
09:44:29 <jmcarthur> shirt: Sorry, not getExecutablePath... getProgName
09:45:52 <srhb> Prutheus: I don't know enough about clash to know how this "storage" would happen. In a pure Haskell program, you would probably recurse, generating some value or instruction, while keeping the value to return to as an argument
09:47:07 <Prutheus> srhb: nono, you dont need to think about restore, i just can append an other variable to the input (leds, mode, cntr) which can be used all the time and will be the same all the time. my problem is, how to implement such thing i just described?
09:47:29 <srhb> Prutheus: eg something like foo val flag = if not flag then 0:foo val flag else val:foo val flag
09:47:46 <srhb> Prutheus: Switching the flag as necessary by whatever logic you need.
09:48:45 <Prutheus> sorry, can you rewrite this into NOT one line please. i really can't understand it atm
09:49:07 <Prutheus> ah no
09:49:19 <Prutheus> srhb: jsut what is 0:foo val flag ?
09:49:38 <srhb> Prutheus: It's a list of zero followed by a recursive call to foo with arguments val and flag.
09:50:05 <Prutheus> wait, let me try to do something like this, okay?
09:50:36 <srhb> Prutheus: The key takeaway point is that in a recursive call, you can "store" both the value and the flag (and change them as necessary)
09:50:55 <srhb> Prutheus: I don't know how your function gets called when you say things like "when mode changes..." 
09:51:30 <srhb> The "when" makes it sound like there's something clash-specific going on. Clearly there's no simple recursive call. So I don't know how you would do this in clash.
09:52:27 <Prutheus> yeah, clash relating, but you gave me an good idea, i am just going to eat, then trying to do sth, ty
10:06:41 <codedmart> Is it possible to access the response body with modifyResponse from way?
10:06:52 <codedmart> wai I mean
10:12:53 * hackagebot reactivity 0.3.2.0 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.2.0 (JamesCandy)
10:21:31 <osager_> how to join a list of string
10:22:21 <osager_> found it
10:22:22 <osager_> sorry
10:22:45 <maerwald> > join ["abc", "def"]
10:22:46 <lambdabot>  "abcdef"
10:22:47 <maerwald> :P
10:27:26 <Prutheus> maerwald: this is really funny
10:28:42 <osager_> what should i import to use join?
10:28:45 <osager_> maerwald, 
10:28:53 <thimoteus> Control.Monad
10:28:55 <Pennyw95> Control.Monad
10:28:57 <osager_> ok
10:29:08 <osager_> but i see it is in GHc.BASE
10:29:32 <osager_> i thought it is imported by default
10:29:59 <maerwald> mind that join = concat for lists
10:45:30 <osager_> what does : maybe "" id 
10:45:31 <osager_> do
10:45:33 <osager_> ?
10:47:24 <thimoteus> :t maybe "" id
10:47:25 <lambdabot> Maybe [Char] -> [Char]
10:47:35 <thimoteus> note that [Char] is the same as String
10:47:51 <thimoteus> > maybe "" id Nothing
10:47:53 <lambdabot>  ""
10:47:57 <thimoteus> > maybe "" id (Just "abcd")
10:47:58 <lambdabot>  "abcd"
10:47:59 <geekosaur> maps a Maybe String to itself if it's a Just, or the empty string if it's Nothing.. (this is better written as: fromMaybe "")
10:55:16 <osager_> ok
10:55:28 <osager_> great
11:03:21 <Squarism> when you enable profiling in cabal configuration, i get complaints/errors about missing "profiling libraries" for different packages.
11:03:43 <Squarism> well.. after config and when i try to run stuff
11:04:07 <Squarism> is there some easy way i can install these?
11:04:22 <Squarism> ..or do i need to do it one-by-one
11:06:56 <nitrix> data Foo f = A Int | B Int f
11:07:22 <nitrix> Could this have a functor instance that always upgrades Foo that are `A` into Foos that are `B` ?
11:07:28 <nitrix> How does it breaks the law?
11:07:38 <geekosaur> Squarism: cabal install --reinstall world --enable-profiling-libraries
11:07:43 <nitrix> s/law/laws/
11:08:05 <nitrix> I think it'd break the `fmap id` once, right?
11:08:07 <nitrix> *one
11:08:27 <Squarism> geekosaur, is that "replacing" or "extending"?
11:08:55 <geekosaur> but! use --dry-run first and watch for it trying to install libraries that come with ghc itself; those libraries you *must* reinstall with the compiler. if you installed ghc from a Linux distribution package, check the package list for profiling packages (e.g. ghc-prof on debian/ubuntu)
11:09:19 <geekosaur> Squarism, it will replace. This is necessary, the way ghc works
11:09:22 <monochrom> nitrix: can you always upgrade A 5 into B 5 xxx? what xxx to use there?
11:10:45 <geekosaur> Squarism, ghc exports selected parts of the module source in the interface file for cross-module inlining, and the choice of what it exports can change in different ghc runs --- so rebuilding can invalidate existing libraries. Also, internal names are known to leak into the interface (and this is very hard to fix) and will be different between builds
11:11:15 <geekosaur> so if you rebuild part (to get profiling libs) you need to get all (to get compatible non-profiling libs)
11:11:46 <Squarism> geekosaur, sounds complicated!
11:11:51 <geekosaur> it's frustrating at times, but the price we pay to get decent performance --- cross-module inlining is more or less why ghc can compete with C for performance at all
11:14:16 <Squarism> geekosaur, ok, good to know!
11:25:45 <S11001001> nitrix: try implementing that
11:27:02 <S11001001> nitrix: wrt monochrom's question
11:27:50 <johnw> nitrix: what you asked really doesn't relate at all to what functors are
11:28:10 <nitrix> Great. Nevermind then.
11:28:43 <monochrom> it is more plausible to downgrade "B 5 xxx" to "A 5".
11:28:56 <nitrix> monochrom: I ended up with FunDeps.
11:29:01 <monochrom> but you are right that if fmap does that downgrade, it breaks fmap id.
11:29:33 <nitrix> Had to refactor a bunch of stuff.
11:29:42 <nitrix> The question was ill-thought and a little desperate.
11:33:34 <Squarism> geekosaur, did you mean that "--enable-profiling-libraries" as a switch to cabal configure? when passing the commandline you sent to cabal 1.22 it complains about that switch not beeing known
11:34:05 <monochrom> --enable-library-profiling
11:42:44 <Squarism> monochrom, geekosaur : ok.. after issuing a dryrun of reinstall i get this result : http://lpaste.net/166992
11:42:56 * hackagebot octane 0.11.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.11.0 (fozworth)
11:42:59 <Squarism> worth going through with it?
11:44:08 <monochrom> 70% chance yes
11:45:29 <Gurkenglas> Programming competitions that allow Haskell usually use the Haskell Platform, which doesn't contain lens. Is there a page that contains all the sourcecode of lens or microlens or a relative, that I can just paste into the single file that I am to write to gain lens functionality?
11:45:49 <puregreen> Gurkenglas: I'm not aware of any
11:46:12 <monochrom> I would not --force-reinstall. I would clean .ghc/x86_64-linux-7.10.3 or whatever version it is. then there would be no question about "reinstall" at all.
11:46:28 <kadoban> Gurkenglas: Would you be allowed to do that anyway? I thought you could only submit your own code.
11:47:03 <Gurkenglas> Not sure, I would ask. It's technically just like any other library, right?
11:47:46 <monochrom> you can copy-paste a small part of microlens that you actually use
11:47:56 <kadoban> Well, I've always avoided it. I've never been serious about competitive programming though either.
11:48:04 <monochrom> it is not like you handwrite your own very original Dijkstra code anyway
11:48:34 <monochrom> yeah, I don't see lens used so much in competitions
11:49:13 <monochrom> the kind of records you need for competitions are usually very shallow
11:49:35 <puregreen> people who participate in those challenges usually have templates that contain implementations of common algorithms, imports, macros like “#define sciii(x, y, z) int x, y, z; scanf("%d %d %d", &x, &y, &z);” (for C), and so on
11:50:02 <puregreen> I haven't heard of anyone actually copy-pasting a whole library, tho, and it might be forbidden by rules anyway
11:50:53 <monochrom> yeah. I was a coach, and my students kept a hundred pages of code they would type in
11:50:53 <kadoban> I know when I was messing around with it, I had a library file I built up by writing code myself. I certainly didn't get the feeling that copying and pasting would have been allowed. It seemed from the rules like it was whatever libraries they allow you to use + your own code.
11:51:03 <puregreen> here are the rules of Codeforces, for instance: http://codeforces.com/blog/entry/8790
11:51:12 <monochrom> (and we don't mean we type in all of it for every question)
11:51:30 <puregreen> tl;dr: copypasting is okay
11:51:41 <monochrom> well, we get philosophical. what is your own code? :)
11:52:11 <Gurkenglas> (I've now been twice through "okay and now 'x <- zoom asd $ StateT uncons', oh shit no Lens, ehhh cba" and dropped the attempt)
11:52:20 <monochrom> the gray area happens when you were author of that code but it was 10 years ago.
11:52:48 <monochrom> must you invent brand new code during the contest? how can it be enforced?
11:53:32 <Gurkenglas> try not to incentivize not writing code ten years ago while you're at it
11:53:41 <kadoban> monochrom: Well, it's my code if I wrote it at any point, was my feeling. Nothing seemed to say that I wrote it during the contest, I don't think.
11:53:48 <verement> Were you the same you as 10 years ago?
11:53:58 <monochrom> :)
11:53:59 <geekosaur> Squarism, looks reasonable aside from the hunit warning at the top (the correct package is HUnit)
11:54:06 <kadoban> I have no idea how it actually works though, I only ever played very briefly with online contests, and I'm terrible at it.
11:54:09 <geekosaur> which you probably have to reinstall manually
11:54:31 <Squarism> geekosaur, oh ok
11:54:40 <Gurkenglas> do you lose copyright when you start suffering from amnesia?
11:55:04 <Squarism> geekosaur, where does cabal get that info from? My system or the cabal file?
11:55:06 <geekosaur> also, after doing this, modify the cabal config (~/.cabal/config on unix) to specify:  library-profiling: True
11:55:15 <geekosaur> so you don't have to do this again in the future
11:56:15 <sooheon> Hey all. Hope I'm not interrupting. I want to try out haskell, and of course, I can't start without some emacs yak shaving. Mostly, I want to get structured-haskell-mode working, but `stack install structured-haskell-mode` is throwing some dependency errors. I've found this (https://github.com/commercialhaskell/stack/issues/1693) related issue, but it's no real help.
11:56:22 <geekosaur> from your system. the world file referenced is ~/.cabal/world
11:57:18 <monochrom> in fact I am also skeptic of the value of world.
11:57:43 <monochrom> it stands for everything you've tried in the past. it has little bearing on what you will use in the future.
11:58:48 <monochrom> and with cabal, do not think that it is harmless to install more than you used
11:58:52 <monochrom> s/used/use/
11:59:07 <monochrom> the more you install, the more they confuse cabal.
11:59:40 <geekosaur> it makes more sense with cabal 1.24 and backpacl
11:59:44 <geekosaur> *backpack
12:09:39 <Squarism> geekosaur, monochrom. Ok, am about to do this. It seems i need to add : --force-reinstalls to make it happen?
12:10:39 <Squarism> geekosaur, fixed that hunit problem now also. removed it and reinstalled the one with right case so the warning disappeared
12:10:43 <monochrom> yes
12:14:51 <Squarism> ouch.. looks as if it went FUBAR! http://lpaste.net/166995
12:15:06 <Squarism> any idea on a next step?
12:15:28 <kadoban> sooheon: I'm sure someone will know the actual answer to your question, but ... you don't need all that stuff to try out haskell of course.
12:17:53 <woffs> Hi. I have a strange problem with a TLS client and client certificate. It works with tls-1.2.9 and connection-0.2.4. It does not work with tls-1.3.8 and connection-0.2.5 - "bad certificate" on server side. Any hints?
12:17:58 * hackagebot dense 0.1.0.0 - Mutable and immutable dense multidimensional arrays  https://hackage.haskell.org/package/dense-0.1.0.0 (cchalmers)
12:18:17 <Squarism> monochrom, geekosaur? I have no clue on what to do next? http://lpaste.net/166995
12:18:25 <Squarism> a hint?
12:18:32 <kadoban> woffs: Well, is the certificate actually bad? Maybe the old code just wasn't picky enough.
12:20:58 <woffs> kadoban, which certificate, client or server? The haskell code (amqp consumer) is on the client side. The client certificate is accepted by the server with plain openssl s_client, too.
12:21:02 <geekosaur> Squarism, urgh. so it did n ot bother telling you that you need to do what I said earlier
12:21:09 <geekosaur> you need the profiling libraries *that come with ghc*
12:21:14 <geekosaur> how did you install ghc?
12:22:44 <kadoban> woffs: Whichever one it's saying is bad.
12:22:50 <Squarism> geekosaur, cant remember really but dpkg says i have : 
12:22:51 <Squarism> ii  ghc                                                         7.6.3-10                                            amd64        The Glasgow Haskell Compilation system
12:22:52 <Squarism> ii  ghc-7.10.3                                                  7.10.3-10~trusty                                    amd64        The Glasgow Haskell Compilation system
12:23:04 <monochrom> in an ideal world, "profiling libraries that come with ghc" is redundant. GHC already comes with them.
12:23:15 <geekosaur> you need one or both of ghc-prof and ghc-7.10.3-prof
12:23:30 <monochrom> but this is a non-ideal world full of do-gooders.
12:24:24 <monochrom> do-gooders who think it's a universally great idea to divide an indivisible set of compilers, libraries, profiling libraries, and docs.
12:25:13 <woffs> kadoban, when the server says "bad certificate" I assume the client certificate is meant. It's very difficult to guess which change is responsible because so much changed (x509, cryptonite, ...)
12:25:33 <Squarism> it seems stuff works as before though? 
12:29:13 <Squarism> cabal == global shared libraries, stack == per-project-libraries?
12:29:45 <dolio> No.
12:30:25 <geekosaur> Squarism, as long as you are not buuilding profiling stuff
12:30:35 <geekosaur> you need the profiling version of the base library
12:30:52 <Squarism> geekosaur, maybe i should wait doing that and do a complete reinstall a
12:31:06 <Squarism> of everything haskell/stack/cabal
12:32:45 <Squarism> geekosaur, ok so how do i get that ?
12:32:53 <monochrom> cabal is also capable of per-project libraries.
12:33:01 <geekosaur> [19 19:22] <geekosaur> you need one or both of ghc-prof and ghc-7.10.3-prof
12:33:04 <monochrom> and I don't know what stack is capable of.
12:34:48 <sm> heh, I don't think anybody does
12:34:54 <monochrom> haha
12:34:54 <Squarism> ok downloading
12:35:07 <monochrom> its author ought to know its capability and limitation
12:35:12 <sm> I keep forgetting stuff it does
12:36:04 <monochrom> this is what you get from evolution. you can't draw a tractible boundary. every dichotomy fails. every.
12:36:37 <monochrom> ok, the dichotomy "is it software or not?" probably doesn't fail. probably.
12:38:45 <geekosaur> intel upgradeable cpu microcode. >.>
12:39:14 <monochrom> yeah, isn't that great? CPUs have firmware upgrades, too.
12:39:26 <geekosaur> where does the hardware end and the software start?
12:40:02 <monochrom> 10 years ago I predicted "one day the screws on the chassis will have device drivers too". looks like we'll get there in time.
12:40:28 <johnw> geekosaur: in the "slightly firm"ware
12:40:46 <geekosaur> internet of things, baybee
12:42:58 <Squarism> ok... after installing ghc-prof and ghc-7.10.3-prof (through apt-get) i tried do that profiling reinstall again. Result : http://lpaste.net/166998
12:42:59 * hackagebot haskell-gi-base 0.18 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.18 (inaki)
12:45:04 <purgified> Hello
12:45:19 <purgified> Newbie question but, what do you guys use Haskell for?
12:45:33 <tdammers> purgified: programming :P
12:45:54 <tdammers> purgified: more seriously, building web applications
12:45:57 <geekosaur> you are missing more profiling libraries, which apparently are not part of your world. so you will need to manually reinstall with profiling at least: mtl hashable primitive regex-base 
12:46:10 <purgified> tdammers: haha. Oh cool, what kind of web apps?
12:46:18 <puregreen> purgified: desktop utilities, sites, and above all: GHCi is a good calculator
12:47:02 <purgified> Awesome. So do you consider Haskell as more of a mathematical language or a general-purpose one
12:47:10 <tdammers> purgified: right now, I'm working on a minimalist website thing; the idea is that you write a bunch of templates, and a configuration file that defines data sources and routes, and that's enough to create a functioning website
12:47:12 <puregreen> general-purpose one
12:47:19 <tdammers> general purpose, hands down
12:47:46 <purgified> tdammers: That sounds amazing
12:47:47 <tdammers> Haskell has a strong theoretical foundation, but you don't have to understand it or know anything about the theory to use it
12:47:58 <liste> purgified: I use it for desktop apps
12:47:59 * hackagebot haskell-gi 0.18 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.18 (inaki)
12:48:01 * hackagebot reactivity 0.3.2.1 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.2.1 (JamesCandy)
12:48:03 * hackagebot gi-atk 2.0.6 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.6 (inaki)
12:48:05 * hackagebot gi-cairo 1.0.6 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.6 (inaki)
12:48:07 * hackagebot gi-gdk 3.0.6 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.6 (inaki)
12:48:09 <liste> (and a bit for web apps too)
12:48:41 <tdammers> purgified: idk, I just looked at web frameworks I've used in the past, and web applications built with them, and I realized that the overwhelming majority of them really boils down to these three things: routes, data sources, templates
12:48:45 <purgified> This is all great. What made you use Haskell from any other language, like Nodejs?
12:49:20 <purgified> Definitely tdammers, it'll be a huge help if you can get the skeletons in place easily
12:50:06 <tdammers> purgified: well, that's the thing; it doesn't just write skeleton code, it implements the whole thing, in one binary - you just give it a bunch of route patterns, data source definitions, and templates
12:50:11 <tdammers> purgified: no coding required
12:51:07 <purgified> Ohhh, so just input the minor details you need to build a website and then start from there easily
12:51:27 <Squarism> geekosaur, ok.. on it
12:51:43 <puregreen> I wonder whether it's “start from there” or more like “start and finish there”
12:52:25 <liste> purgified: for me, the most important thing in Haskell is the easy reasoning about code
12:53:03 <liste> in other languages, I can never be sure that eg. something is not null or hasn't changed between two method calls
12:53:09 * hackagebot gi-gdkpixbuf 2.0.6 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.6 (inaki)
12:53:11 * hackagebot gi-gio 2.0.6 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.6 (inaki)
12:53:13 * hackagebot gi-girepository 1.0.6 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.6 (inaki)
12:53:15 * hackagebot gi-glib 2.0.6 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.6 (inaki)
12:53:17 * hackagebot gi-gobject 2.0.6 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.6 (inaki)
12:53:27 <tdammers> it's "start and finish"
12:54:13 <tdammers> I'm not trying to cater for the use case where you legitimately need custom programming work
12:56:20 <liste> purgified: in Haskell, I can be sure of many more things, which reduces the most time-consuming part of development, debugging
12:56:30 <tdammers> indeed
12:56:51 <tdammers> the degree of obvious certainty you can get from Haskell is unthought of in most other languages
12:57:17 <purgified> Woah
12:58:19 * hackagebot gi-gst 1.0.6 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.6 (inaki)
12:58:21 * hackagebot gi-gstaudio 1.0.6 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.6 (inaki)
12:58:23 * hackagebot gi-gstbase 1.0.6 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.6 (inaki)
12:58:25 * hackagebot gi-gstvideo 1.0.6 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.6 (inaki)
12:58:27 * hackagebot gi-gtk 3.0.6 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.6 (inaki)
12:58:59 <MichaelK> Hi, is there any way to extract a constraint from a type? Maybe something like `type family ConstraintOf a`?
13:00:35 <monochrom> I guess it comes down to: what will do you with an "extracted constraint" after you have extracted constraints?
13:01:23 <itnex> haskell is literally mental masturbation
13:01:38 <itnex> s/.*/hi
13:02:10 <johnw> type family ConstraintOf a :: * -> Constraint where ConstraintOf Int = Ord
13:02:12 <comerijn> MichaelK: What are you trying to do?
13:03:29 * hackagebot gi-gtkosxapplication 2.0.6 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.6 (inaki)
13:03:31 * hackagebot gi-gtksource 3.0.6 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.6 (inaki)
13:03:33 * hackagebot gi-javascriptcore 3.0.6 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.6 (inaki)
13:03:35 * hackagebot gi-javascriptcore 4.0.6 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.6 (inaki)
13:03:37 * hackagebot gi-notify 0.7.6 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.6 (inaki)
13:03:39 <MichaelK> monochrom, comerijn: I want to make a function with type `(Constraint b => a -> b) -> a -> (Constraint b => Maybe b), but that'd escape its scope. It's possible to do the application with dynApp, but then the result can't be extracted with the constraint afaik
13:04:25 <monochrom> what is the kind of b?
13:05:13 <MichaelK> *
13:05:32 <MichaelK> right?
13:05:48 <monochrom> I don't know. You are specifying your software. I am not.
13:06:12 <MichaelK> then yes, *
13:07:30 <monochrom> at present the type "(Constraint b => a -> b) -> a -> (Constraint b => Maybe b)" looks like a syntax error. is there a couple of "forall"s you need?
13:08:39 * hackagebot gi-pango 1.0.6 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.6 (inaki)
13:08:41 * hackagebot gi-pangocairo 1.0.6 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.6 (inaki)
13:08:43 * hackagebot gi-poppler 0.18.6 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.6 (inaki)
13:08:45 * hackagebot gi-soup 2.4.6 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.6 (inaki)
13:08:47 * hackagebot gi-vte 2.91.6 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.6 (inaki)
13:08:51 <shachaf> monochrom: Why is it a syntax error?
13:09:05 <shachaf> (k => a) is valid syntax.
13:09:26 <jmcarthur> It looks valid to me.
13:09:37 <jmcarthur> Constraints imply a forall.
13:09:48 <shachaf> They do?
13:10:01 <jmcarthur> 90% confident.
13:10:11 <MichaelK> well yes and I missed something, so "(Constraint b => a -> b) -> (forall c. c) -> (forall d. Constraint d => d)"
13:10:16 <comerijn> jmcarthur: Pretty sure they don't
13:10:18 <shachaf> The only place I know where they do/did that is in type synonyms, as in "type Lens s t a b = Functor f => (a -> f b) -> s -> f t"
13:10:18 <monochrom> see, I doubt the syntax because I doubt the semantics :)
13:10:25 <shachaf> Which I think is/was a bug.
13:10:37 <comerijn> shachaf: That needs forall now too, I think?
13:10:39 <shachaf> Yes, GHC turned it into a warning.
13:10:47 <shachaf> And I guess now an error.
13:10:54 <monochrom> "forall c. c" is not a very realistic type
13:10:54 <jmcarthur> I could have sworn...
13:11:04 <shachaf> As far as I know constraints are completely independent of forall and there's no reason to want otherwise.
13:11:12 <MichaelK> monochrom: oops, missed some Typeable's
13:11:27 <jmcarthur> shachaf: I agree that it's not especially desirable, but I could have sworn that at some point it had this effect.
13:12:03 <shachaf> jmcarthur: Which effect? What would the implicit forall quantify?
13:12:14 <MichaelK> "((Typeable b, Constraint b) => a -> b) -> (forall c. Typeable c => c) -> (forall d. (Typeable d, Constraint d) => d)"
13:13:46 <jmcarthur> I'm just crazy. Please disregard. :)
13:13:49 * hackagebot gi-webkit2 4.0.6 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.6 (inaki)
13:13:51 * hackagebot gi-webkit2webextension 4.0.6 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.6 (inaki)
13:13:53 * hackagebot gi-webkit 3.0.6 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.6 (inaki)
13:15:33 <monochrom> "forall c. Typeable c => c" is still not a very realistic type. do you have an example expression of this type?
13:16:13 <johnw> why is that not realistic?
13:16:35 <shachaf> See the next sentence.
13:16:56 <monochrom> call it my wrong intuitive feeling. please falsify my claim.
13:17:54 <MichaelK> monochrom: `fromJust (Data.Typeable.cast (0 :: Int))`
13:18:44 <monochrom> @type fromJust (Data.Typeable.cast (0 :: Int))
13:18:45 <lambdabot> Typeable a => a
13:19:16 <monochrom> wait a second. is it bottom?
13:19:36 <shachaf> It's bottom unless used as Int.
13:19:40 <monochrom> > (fromJust (Data.Typeable.cast (0 :: Int))) :: Bool
13:19:42 <lambdabot>  *Exception: Maybe.fromJust: Nothing
13:20:05 <monochrom> yeah, it is not very usable, only somewhat sparingly usable
13:21:29 <johnw> monochrom: you are believed
13:21:33 <shachaf> Of course, you can do better:
13:22:01 <shachaf> :t val
13:22:02 <lambdabot> Typeable a => a
13:22:03 <shachaf> > val :: Int
13:22:05 <lambdabot>  0
13:22:06 <shachaf> > val :: Bool
13:22:08 <lambdabot>  False
13:22:31 <shachaf> But it's still bottom for all but a finite number of types.
13:23:47 <dolio> You should fix that. :)
13:24:30 <shachaf> How?
13:30:10 <geekosaur> > val :: Vector Int
13:30:11 <lambdabot>  Not in scope: type constructor or class ‘Vector’
13:30:27 <geekosaur> probably for the best
13:30:50 <MichaelK> I got something close: (Typeable a, Typeable b, Typeable r) => (b -> r) -> a -> Maybe r
13:34:42 <Squarism> gah.. this reinstall is continuing deep into the rabbit hole
13:35:25 <johnw> is it trying to install a new rabbit?
13:35:49 <bydo> Squarism: did you change your mind on what you're installing yet
13:36:30 <Squarism> bydo, what do you mean? I persued the reinstall with profiling
13:37:31 <Squarism> keeps requiring me to manually install new packages again and again.. and every reinstall is taking like 10 minutes making my cpu super hot
13:37:51 <Squarism> funny.. my one and only project only has these dependencies : base,regex-pcre, regex-base, random, array, transformers, parsec, lens
13:37:57 <bydo> when something becomes too much of a pain and you change your mind on what you're trying to accomplish 
13:38:17 <dolio> shachaf: Polymorphic recursion.
13:38:37 <Squarism> well.. now ive got a non working haskell install... so i need to do something.
13:38:56 <Squarism> i wonder if i should just remove everything and start from scratch
13:38:57 <shachaf> dolio: Ah, fair enough.
13:40:00 <Gurkenglas> Is there a piece of Haskell code that'll tell me what version of the Haskell Platform the runner of the code is using?
13:40:07 <Squarism> how does one wipe haskell from a linux machine?
13:40:12 <Squarism> +cabal
13:40:17 <comerijn> Gurkenglas: That question makes no sense
13:40:27 <kadoban> Squarism: Depends how you installed them?
13:40:32 <kadoban> (and what distro)
13:40:45 <comerijn> Gurkenglas: What if I run a binary compiled from your source on a machine without a haskell compiler or haskell platform installation?
13:40:58 <kadoban> Squarism: If it were me, I'd just wipe everything out, install stack and let it install whatever else you need.
13:41:55 <Gurkenglas> ah, i see. Is there a piece of Haskell code that'll tell me what version of the Haskell Platform is used on the machine that compiled the code, which is only required to answer correctly if they are actually using the Haskell Platform?
13:42:09 <comerijn> Doubt it
13:42:26 <comerijn> That would require someway to reliably query the OS what is installed
13:42:41 <comerijn> Especially troublesome since someone could install from source
13:43:01 * hackagebot brick 0.8 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.8 (JonathanDaugherty)
13:43:06 <Squarism> i figure ive got it from haskell.org
13:43:58 <Squarism> either stack or the haskell platform
13:44:52 <Gurkenglas> comerijn, it would only require a library that has a major version for each version of the Haskell Platform, is included in the Haskell Platform, and exports a name whose behavior is changed for each version to output a string corresponding to the version of the haskell platform
13:46:05 <comerijn> Gurkenglas: At any rate, why do you care?
13:46:16 <Gurkenglas> (more generally, a set of libraries in the haskell platform whose behavior is testably functionally dependent on the haskell platform version)
13:46:50 <Gurkenglas> Because this code competition thingy is using the haskell platform and i wanted to check whether they're using the latest one, and can thus use stack to add lens
13:47:16 <comerijn> Would probably be easier to just ask the people running the site?
13:47:29 <Gurkenglas> at the rtt im expecting, ehhhh
13:47:41 <Squarism> kadoban, ill persue that path
13:48:27 <blank101010> Megaparsec succeeds on this input `parse "" alphaNumChar "4 $)(*"` with `Right 4`. Shouldn't it fail, since there is stuff left?
13:48:53 <puregreen> Gurkenglas: do they just let you run arbitrary commands?
13:49:35 <kadoban> blank101010: Only if you do   parse "" (alphaNumChar <* eof) "4 $()*" -- I believe
13:49:36 <Gurkenglas> dunno, i could try, that nobuffering thing and stdout/stdin/stderr are accessible at least
13:50:42 <Squarism> where does all packages installed through cabal reside?
13:50:53 <Squarism> ~/.cabal ?
13:51:45 <kadoban> Squarism: ~/.ghc
13:51:55 <comerijn> Depends on the OS
13:52:07 <puregreen> I think all modern competition platforms include a sandbox that doesn't let you just run `stack install lens` or, I don't know, `rm -rf ~/`
13:52:23 <buglebudabey> foldr (/) 1 [81,3]
13:52:24 <blank101010> kadoban: Thanks! :)
13:52:32 <puregreen> also, why'd you even need stack? you can do `cabal install lens` just as well
13:52:33 <kadoban> rm -rf ~/  would be not a good command ...
13:52:48 <buglebudabey> why does foldr (/) 1 [81,3] = 27, but foldr (/) 1 [81,3,3] is 81?
13:52:58 <buglebudabey> how can i divide fold a list correctly
13:53:00 <puregreen> kadoban: which is exactly why they don't let you do it
13:53:20 <kadoban> puregreen: Huh?
13:53:40 <kadoban> Oh I see, nevermind.
13:53:40 <Gurkenglas> Whats the way that is most likely to work to tell an admin to update their Haskell Platform? (optimally a single command :3)
13:54:54 <Squarism> kadoban, about persuing the stack path. Does that mean stop using cabal for installing packages ? 
13:55:33 <kadoban> Squarism: I would, but that's up to you. I don't like how cabal works, it's pretty tedious.
13:57:59 <comerijn> > foldr (/) 1 [81,3,3] :: Expr
13:58:01 <lambdabot>  81 / (3 / (3 / 1))
13:58:12 <comerijn> buglebudabey: There you go
13:59:02 <buglebudabey> foldl (/) 1 [81,3,3] :: Expr
13:59:11 <TommyC> buglebudabey: Need the '>'
13:59:17 <buglebudabey> ah
13:59:23 <buglebudabey> > foldl (/) 1 [81,3,3] :: Expr
13:59:25 <lambdabot>  1 / 81 / 3 / 3
13:59:47 <buglebudabey> > foldl (/) 81  [3,3] :: Expr
13:59:48 <lambdabot>  81 / 3 / 3
14:00:39 <buglebudabey> > foldl' (/) 81  [3,3] :: Expr
14:00:41 <lambdabot>  81 / 3 / 3
14:00:51 <buglebudabey> > foldl' (/) 81  [3,3]
14:00:52 <lambdabot>  9.0
14:00:53 <TommyC> buglebudabey: You can uh... also privmsg the bot I think. :3
14:01:08 <buglebudabey> shanks
14:02:58 <ertes> (what does ":3" actually mean?)
14:04:05 <NeverDie_> Madness.
14:15:57 <cobreadmonster> ertes: that doesn't typecheck
14:16:47 <comerijn> :3 is a smiley...
14:17:18 <Gurkenglas> search ircbrowse for :3 and run the neural network between your ears on what situations :3 tends to be used in :3
14:19:45 <cobreadmonster> lol
14:20:14 <cobreadmonster> "neural network between your ears"
14:20:36 <kadoban> I think it's supposed to denote cheekiness or something.
14:22:00 <Koen_> that took me way too long to understand :(
14:22:15 <buglebudabey>  
14:22:32 <buglebudabey> is there a way to pattern match on an entire list to make sure they are all of a certain type?
14:23:08 <buglebudabey> such as  function [Just x] = ... where all entities are Just ...
14:23:44 <monochrom> no. use the functions "all" and "isJust" instead.
14:23:47 <Cale> No, but perhaps sequence would be useful
14:24:00 <Cale> > sequence [Just 1, Just 2, Just 3]
14:24:02 <lambdabot>  Just [1,2,3]
14:24:05 <monochrom> also, this is not a type. this is a value.
14:24:06 <Cale> > sequence [Just 1, Just 2, Nothing, Just 3]
14:24:08 <lambdabot>  Nothing
14:24:18 <Cale> Yeah, Nothing and Just aren't types
14:24:45 <Cale> Maybe is a type
14:25:23 <ertes> :t not . null . sequence
14:25:25 <lambdabot> (Monad t, Foldable t, Traversable t1) => t1 (t a) -> Bool
14:26:58 <Cale> Well, sequence was with the intention that if you're going to go to the trouble of checking that all the elements of the list aren't Nothing, you might as well end up with a list of non-Maybe values at the end
14:27:29 <buglebudabey> alright, it's hard to explain what i'm trying to do but i essentially want to fold a list into an int, but the list can be something like [Number 4, NotNumber 'y', Number 5] and i'd want that to fail, but if the list was [Number 4, Number 5] then I'd want that to be added
14:28:28 <buglebudabey> all the things in the list will be of type Expr but not all Expr's can be added together
14:28:56 <buglebudabey> i want it to be efficient because i'm making a compiler
14:29:25 <kadoban> buglebudabey: I'd map a function over it to transform it into [Just Int], then use Cale's idea. (the map and then sequence is aka traverse unless I'm mistaken)
14:30:14 <kadoban> [Maybe Int], sorry.
14:30:17 <buglebudabey> I like that idea kadoban, thanks also Cale
14:31:54 <buglebudabey> kadoban would this be okay as well: exprToMaybe :: (Num a) => [Expr] -> [Maybe a]
14:32:11 <buglebudabey> if I want to include doubles
14:32:23 <johnw> just write Expr -> Maybe a
14:32:27 <buglebudabey> actually doubles arent part of num are that
14:32:32 <buglebudabey> they*
14:32:35 <johnw> you can always use fmap to lift it to operate on lists
14:32:42 <monochrom> what is the definition of Expr?
14:33:07 <buglebudabey> its a datatype that includes atoms, lists, lambdas, and function calls
14:33:12 <buglebudabey> making a lisp compiler
14:33:17 <Cale> buglebudabey: Note also that a list comprehension can work well here
14:33:32 <monochrom> my "definition" means actual code.
14:33:48 <Cale> Well, but that wouldn't do checking, so nevermind
14:34:00 <Cale> But sometimes you just want to select all the elements of a list which match a given pattern
14:34:08 <buglebudabey> monochrom http://lpaste.net/167017
14:34:15 <Cale> e.g. [n | Number n <- xs]
14:34:33 <buglebudabey> that's pretty much what I want to do
14:34:53 <monochrom> what happens to [Number 4, Float 5]?
14:35:13 <buglebudabey> a type error I guess until i figure it out
14:35:19 <Cale> That'll just get you [4], which isn't what he wanted.
14:35:20 <johnw> does this work: [ n | exprToMaybe -> Just n <- xs ]
14:35:32 <slemonide> Hello. What is an example of something that is in the Num class, but not in the Ord class?
14:35:39 <Cale> that should work, but I'd parenthesise the pattern at least :)
14:35:56 <ertes> slemonide: vectors
14:36:00 <Cale> slemonide: Complex Double
14:36:08 <Cale> Vectors wouldn't be in Num...
14:36:10 <kapral> hi. could someone answer me what the symbol '!' in the type declaration means ? 
14:36:14 <Cale> At least, not usually
14:36:17 <kapral> example : data KeyValue = KeyValue !(Map.Map Key Value)
14:36:42 <ertes> slemonide: however, usually they are still Ord, but the order is rather arbitrary and mostly useful for data structures
14:36:50 <kapral> or where I can read about it ? 
14:36:53 <glguy> kapral: That's called a "strictness flag"
14:37:04 <Cale> kapral: It means that field is strict. Any occurrence of the constructor KeyValue will be desugared to (\x -> KeyValue $! x)
14:37:10 <glguy> kapral: You can read about it in Section 4.2 of the Haskell 2010 report
14:37:21 <ertes> Cale: the vector types from 'linear' are all Num (with (*) being pointwise multiplication)
14:37:28 <kapral> Cale: glguy: Thanks
14:37:30 <Cale> ertes: Ah, hm
14:37:51 <Cale> ertes: I suppose you get a reasonable ring that way, it's just not a very nice one.
14:38:16 <Cale> (you can multiply two nonzero things and end up with 0, for instance)
14:38:25 <ertes> Cale: well, it's just an instance of the way you can turn any Applicative into a valid Num
14:38:37 <monochrom> zero divisors \∩/
14:38:45 <ertes> Cale: getting 0 for non-zero elements is quite common, e.g. modular arithmetic
14:40:27 <monochrom> oh! this ring is crucial in the Chinese remainder theorem.
14:42:04 <Cale> Yeah, nontrivial matrix rings are also not integral domains
14:43:21 <Cale> But yeah, it depends a bit on what Num means
14:43:48 <buglebudabey> can I have a data definition like this? data Expr = (Num a) => Number a | String String?
14:44:05 <Cale> You can, but you probably don't want it
14:44:06 <monochrom> no
14:44:23 <Cale> It's possible to do that with an existential
14:44:32 <buglebudabey> existential?
14:44:34 <geekosaur> with an existential or a GADT (which is an existential); it's usually more trouble than it's worth
14:44:50 <glguy> It' going to be particularly useless in the case of Num
14:44:51 <Cale> However, forgetting the type of number that you put in makes that thing useless when you get it back out again
14:45:04 <monochrom> it is not clear whether the intention is existential or universal.
14:45:11 <ertes> buglebudabey: you can do it, but the caveats usually make it rather useless…  for example if you get two Numbers, you can't add them
14:45:21 <buglebudabey> ah i see
14:45:23 <ertes> f (Number x) (Number y) = Number (x + y)  -- type error
14:45:24 <geekosaur> no, adding them is about all they can do
14:45:31 <glguy> to itself
14:45:42 <monochrom> but it is clear that the current form is a syntax error, and both existential and universal are useless for this
14:45:43 <geekosaur> Num covers (+) but not much else
14:45:44 <ertes> geekosaur: two existentials don't unify
14:45:54 <buglebudabey> well i'd like the create a datatype in my AST that will allow me to add doubles and ints when i evaluate
14:46:27 <ertes> buglebudabey: then make a constructor for each
14:46:29 <Cale> buglebudabey: You probably want a data type which has constructors for each of the types of numbers you want
14:46:39 <buglebudabey> Cale i have that
14:46:40 <monochrom> when you add a double and an int, what will you get, a double? int? complex?
14:46:42 <Cale> and then define operations on it by cases
14:47:06 <buglebudabey> Cale alright i was trying to take a lazier way out :P
14:47:07 <ertes> buglebudabey: you can save some effort by making a constructor for Rational…  that one covers almost any number you would want to represent
14:47:26 <monochrom> until you need square roots
14:47:32 <ertes> buglebudabey: but you also give up some efficiency that way, because it stores every number as two Integers (numerator, denominator)
14:47:50 <buglebudabey> ertes noted, thank you
14:48:02 <ertes> > realToFrac (sqrt 2) :: Rational
14:48:03 <lambdabot>  6369051672525773 % 4503599627370496
14:48:17 <ertes> monochrom: Rational can do that…  Double has limited precision
14:48:47 <monochrom> ok, I guess we can do Rational Trig too
14:49:19 <ertes> consider Rational a representation type, not a type you would use for actual arithmetic
14:50:24 <monochrom> ok, here is the thing. "sqrt (2 :: Rational)" will not make it. it has to be "realToFrac (sqrt (realToFrac (2 :: Rational))) :: Rational"
14:51:00 <monochrom> and of course replace 2 by a Rational variable in reality
14:51:46 <coppro> that makes sense
14:52:00 <coppro> you can't take the square root of a rational number without changing type or losing precisions
14:52:03 <coppro> *precision
14:52:15 <ertes> you can't really take the square root of a Double either
14:52:15 <adarqui> hey, with stack.. in my .cabal file, should I just go through all of my dependencies and make them the latest supported version for the lts release i'm using? or should I not put version numbers, and stack will pick the latest for that lts-<release>
14:52:25 <ertes> Rational is more precise than Double!
14:52:27 <coppro> ertes: true, but all Double operations are inexact anyway
14:52:32 <monochrom> instance Floating (Rational Integer) where sin = realToFrac . sin . realToFrac etc etc \∩/
14:52:39 <coppro> whereas the defined Rational operations are all exact
14:52:53 <monochrom> err, "Rational Integer" is redundant
14:53:12 <ertes> exactly…  so if you want to be lazy with your AST, you can use Rational as a "precise enough for most numeric types we care about" storage type
14:53:40 <monochrom> this is interesting
14:53:52 <ertes> (if you want dynamically typed numbers anyway, which buglebudabey seems to want)
14:54:03 <kadoban> adarqui: During development, you can just leave the version numbers out of the .cabal file. When you release though, you should probably put some bounds, based on what it's actually using, for people that aren't using stack.
14:54:09 <buglebudabey> alright, i'll let you know what i do :P, maybe i'll take the non-lazy way
14:54:46 <adarqui> kadoban: cool thanks.. it's a priv8 code base.. but, say i still wanted to do that, at that point I could do something like cabal freeze (or some stack equiv) to pin all of the versions im using?
14:55:27 <kadoban> adarqui: You probably could (I don't know cabal well), but likely you should do something manually, like just restricting it to the current major version, to give people some flexibility.
14:55:49 <kadoban> Requiring *exact* versions like unlikely to be necessary I would think.
14:55:56 <ertes> buglebudabey: you can also make a separate type Number that includes all the cases you care about
14:56:16 <ertes> buglebudabey: that one can have a Num instance with dynamic conversion
14:56:42 <ertes> buglebudabey: initial version:  newtype Number = Number { fromNumber :: Rational }
14:57:00 <ertes> buglebudabey: better version:  newtype Number = IntegerNum !Integer | DoubleNum !Double | …
14:57:03 <adarqui> kadoban: ah ok cool. i just want to try and attempt to use the latest versins for each lts-<rel> im building with.. instead of updating all of those versions by hand.. and if i need to specify something specific, i'd modify that one dep's version manually
14:57:08 <ertes> buglebudabey: oops
14:57:11 <ertes> buglebudabey: better version:  data Number = IntegerNum !Integer | DoubleNum !Double | …
14:57:25 <buglebudabey> ertes that better version is over my head, care to explain?
14:57:40 <buglebudabey> what's the !
14:57:48 <ertes> buglebudabey: the ! means "strict field"
14:59:25 <monochrom> one day I ought to revise my strict field article to perfection
14:59:33 <buglebudabey> alright ertes i will try thi
14:59:35 <buglebudabey> this*
14:59:55 <monochrom> for now it is a sorry mixup of operational semantics and denotatinal semantics I am ashame of
15:00:03 <ertes> buglebudabey: it means (IntegerNum undefined = undefined), which in english means that a Number is either fully evaluated (the type of number is known as well as the number itself) or not evaluated at all (the whole think is still pending for evaluation)
15:00:22 <ertes> s/think/thing/
15:00:34 <buglebudabey> ertes so does that mean ill have data Expr = Number Number | ..... and newtype Number = IntegerNum !Integer | ....
15:00:56 <ertes> buglebudabey: s/newtype/data/, but everything else yes
15:01:16 <monochrom> I wonder if you also want "Number !Number"
15:01:42 <ertes> for an AST non-strict fields usually make sense
15:02:06 <ertes> at least if you perform traversal-like transforms on it
15:02:34 <buglebudabey> i'm not really sure where I'd be transversing it
15:02:45 <ertes> buglebudabey: evaluation
15:03:02 <buglebudabey> so pattern matching each constructor of the type for my eval function?
15:03:56 <buglebudabey> right now what i'm doing is taking my current AST and evaluating anything that can be immediately evaluated like adding, subtracting, etc
15:04:32 <ertes> buglebudabey: a traversal visits the whole data structure, potentially rebuilding it along the way
15:04:42 <ertes> buglebudabey: for example 'map' on lists is a traversal
15:05:10 <ertes> you visit every list element and rebuild the list
15:05:41 <buglebudabey> but wouldn't any function on an Expr datatype have to visit every constructor or else it would be non-exhaustive?
15:05:55 <buglebudabey> basically how can i NOT transverse everything in some way
15:06:37 <ertes> buglebudabey: not just every constructor, but the whole structure – recursively
15:06:46 <buglebudabey> I see
15:07:01 <ertes> a 'map' does not just check whether a list is a cons or a nil, but it descends into it
15:07:15 <Tertain> why is it that something like, :{ let b = [1, 2, 3] ^? ix 1; c = [1, 2, 3] & ix 1 %~ (+1) :} works, but :{ let a = ix 1; b = [1, 2, 3] ^? a; c = [1, 2, 3] & a %~ (+1) :} doesn't?
15:07:26 <ertes> the reason why traversals are important is that in haskell you can easily compose them – that's the power of laziness
15:08:04 <ertes> but if you make your structure strict, you limit that composability
15:08:05 <puregreen> Tertain: maybe the monomorphism restriction
15:08:05 <Tertain> I feel like it has to do with when ghc converts typeclasses into concrete types.
15:08:20 <puregreen> try to do :set -XNoMonomorphismRestriction
15:08:42 <comerijn> Don't disable MMR for no good reason :/
15:08:55 <puregreen> nevermind, it's not it
15:09:51 <glguy> Tertain: When you tried it you probably got an error message
15:09:57 <puregreen> comerijn: sure, but it's easier to do the right thing when you know whether it's caused by MMR or not
15:10:38 <puregreen> http://lpaste.net/167023
15:10:48 <glguy> :t ix 1
15:10:49 <lambdabot> (Num (Index m), Applicative f, Ixed m) => (IxValue m -> f (IxValue m)) -> m -> f m
15:10:54 <Tertain> puregreen: thanks, right. It can't match instances of the identity functor, and the const applicative.
15:10:58 <glguy> Tertain: In order to write that type you need an extension
15:11:14 <Tertain> puregreen: its because i'm using 'ix 4' as both a setter and a getter
15:11:35 <glguy> Tertain: Additionally the monomorphism restriction kicks in
15:12:08 <glguy> and ix 1 doesn't get the polymorphic type you need to use it at both the types you used it at
15:13:34 <Tertain> glguy: is that because ghc is deriving a concrete type for 'a' instead of the polymorphic type? I haven't yet understood the monomorphic restriction. If I look into that, then I should understand it?
15:14:08 <glguy> Tertain: Yes, it's inferring a monomorphic type because a doesn't have any explicit function arguments
15:14:40 <Tertain> glguy: cool, thanks.
15:15:47 <glguy> If you annotated a :: Traversal' [a] a;  it would work out
15:16:09 <glguy> :t ix 1
15:16:11 <lambdabot> (Num (Index m), Applicative f, Ixed m) => (IxValue m -> f (IxValue m)) -> m -> f m
15:16:25 <glguy> Monomorphism restriction aside, that   Num (Index m) constraint needs an extension on its own
15:16:39 <glguy> if you were to write the fully general type for 'a'
15:17:27 <buglebudabey> does anyone know about NLP and haskell? also what about NLP and haskell not necessarily English related
15:17:46 <buglebudabey> or know of anything*
15:24:56 <nkaretnikov> am i the only one constantly redefining the new version of forM as flip fmap because the new implementation doesn't do what i want?
15:26:40 <Tertain> glguy: I think I've finally got my head around this error I've been dealing with for the past hour. I was trying to specify the type 'Lens s t a b' for a particular lens, but the monomorphic type restriction was trying to specify a particular 'Applicative', causing that to not work, which is why I removed the type signature. Specifying the full type signature like you suggested instead of the type signature
15:26:41 <Tertain> works. Thanks again.
15:27:10 <Tertain> Instead of the type synonym I meant.
15:30:02 <ertes> nkaretnikov: what?
15:32:59 <nkaretnikov> ertes: runIdentity $ Control.Monad.forM [1,2,3,4] $ (return . (+1))
15:34:37 <ertes> > runIdentity (forM [1,2,3,4] (return . (+ 1)))
15:34:39 <lambdabot>  [2,3,4,5]
15:35:10 <ertes> nkaretnikov: in what way does this not work?  (ignoring the weird use case for forM)
15:35:56 <buglebudabey> has anyone used harpy before? I'm thinking of using it in my compiler for code generation but im not exactly sure how
15:36:10 <puregreen> nkaretnikov: in case you didn't know already, “flip fmap” is defined in some places (e.g. lens) as <&>
15:36:57 <nshepperd_> forM being different from fmap has always been the case..
15:38:00 <ertes> nkaretnikov: in what way does this not work?  (ignoring the weird use case for forM)
15:40:54 <nkaretnikov> ertes: this works, i'm just saying that it's an overkill for a flip fmap alias, which i want quite often.  i'd like something like for = flip fmap to be in the stdlib, but i understand that people will never agree on the definition of something with such a short and convenient name
15:41:42 <ertes> nkaretnikov: especially since it's often convenient enough to use (<$>) sections
15:42:01 <puregreen> I often try to use “for” as “flip map”, but I still like “for = forM” more, yeah
15:42:23 <ertes> nkaretnikov: (<$> xs) f
15:42:34 <nkaretnikov> ertes: huh?  could you show an example?  the usecase i have in mind is when you have a list variable and a long chain of functions
15:42:36 <nkaretnikov> ertes: oh
15:42:44 <nkaretnikov> ertes: that's nice, but parens...
15:43:02 <ertes> nkaretnikov: i disagree with many haskellers on parens:  i don't think they are evil
15:43:19 <ertes> if you have layout to guide you, you can use ($):
15:43:27 <ertes> (<$> xs) $ \x -> ...
15:43:50 <nkaretnikov> ertes: anyway, i keep this in mind
15:44:00 <nkaretnikov> ertes: thanks for the hint!
15:44:06 <ertes> you're welcome
15:44:59 <EvanR> doing something like a . b . c . d $ x comes down to laziness i think
15:45:15 <EvanR> its not lisp so i forgot to open a parens before doing anything
15:45:55 <ertes> EvanR: i use that pattern, but only when x is either really short or an indented block starting on the next line
15:46:18 <EvanR> ive been factoring the x out
15:46:24 <EvanR> and not doing anything
15:46:34 <EvanR> who needs application
15:47:10 <ertes> yeah, just use arrows
15:47:35 <ertes> main = runKleisli f ()
15:48:42 <dolio> Complete with example of why you wouldn't use arrows. :)
15:49:04 <quxbam> Why does haskell use -> in lambdas and not a dot?
15:49:10 <ertes> in case you're wondering: arrows are just steroids in the category of endorockstars
15:49:12 <quxbam> \x. x
15:49:28 <nkaretnikov> ertes: btw, what are you working on these days?  if i'm not messing things up, i used to read your blog, which was quite interesting, but then you stopped updating it or something.  i also enjoyed reading your long emails to the nix-dev list...
15:49:57 <nkaretnikov> quxbam: because the dot is used for something else
15:50:32 <EvanR> quxbam: thankfully someone uses x -> x syntax for lambdas.... instead of ridiculous stuff like (-> x { x + x })
15:51:11 <EvanR> it seems like the most obvious thing...
15:51:30 <quxbam> I like the syntax, I was just wondering why it doesn't stay closer to maths
15:51:44 <EvanR> like x |-> x + 1 ?
15:51:54 <ertes> nkaretnikov: other than a bunch of open source projects i'm currently rather quiet in the haskell/NixOS communities…  i do release libraries from time to time though
15:52:01 <quxbam> like  id = \x. x
15:52:21 <quxbam> instead of id = \x -> x
15:52:40 <kadoban> quxbam: It'd be pretty hard to say what the rationale was exactly, I would think.
15:52:41 <EvanR> it was blantantly copied from ML languages im sure
15:53:04 <quxbam> I'm blatantly copying from wikipedia
15:53:15 <EvanR> wikipedia didnt exist at the time
15:53:28 <hpc> maybe the theory was that \ is the closest ascii to λ
15:53:39 <hpc> oh wait, wrong thing
15:53:43 <quxbam> wiki quotes literature from 1937
15:53:58 <quxbam> yes, \ is like the lambda
15:54:03 <EvanR> maybe you didnt exist at the time to remind them of that
15:54:17 <ertes> nkaretnikov: and thanks =)
15:54:21 <quxbam> Oh, how old is haskell exactly?
15:54:27 <nkaretnikov> ertes: :)
15:54:42 <EvanR> 1989 ish
15:54:54 <quxbam> Well, with 2 ...
15:55:20 <dolio> I don't think much math actually uses lambda calculus notation.
15:55:43 <dolio> Mathematicians just ignored it, mostly.
15:56:40 <arkeet> ↦
15:57:37 <dolio> They're always parenthesizing their function application, too. Even when it's not a function on tuples.
15:57:43 <ertes> well, when did haskell "start"?
15:57:45 <dolio> f(x)
15:57:52 <quxbam> dolio: that's kind of sad, because it allows to write combinators in a very nice way
15:58:02 <monochrom> I believe that \ is ascii-art for lambda
15:58:06 * hackagebot jsaddle 0.4.0.3 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.3 (HamishMackenzie)
15:58:12 <quxbam> monochrom: yes
15:58:13 <ertes> did it start with the begriffsschrift in 1879?  or with lambda calculus in 1936?  or as a programming language in the late 80s?
15:58:36 <dolio> Even as a programming language, you can go back before "Haskell".
15:58:42 <dolio> To Miranda, and earlier languages.
15:58:45 <monochrom> "begriffsschrift" sounds like an impressive word. I'll bet Haskell started with the begriffsschrift.
15:58:52 <quxbam> Or to Mr. Haskell
15:59:14 <quxbam> monochrom: That's even an impressive word for a german
15:59:21 <ertes> monochrom: in german it sounds just weird…  not impressive, just weird
15:59:22 <monochrom> (what does it mean?)
15:59:39 <dolio> Miranda is very similar to Haskell syntax-wise.
15:59:40 <ertes> monochrom: "script of terms"
15:59:46 <ertes> something like that
15:59:57 <ertes> or "book of terms", if you will
15:59:59 <quxbam> A treaty about terms
16:00:12 <quxbam> It sounds like a title from Hegel
16:00:16 <dolio> monochrom: Lambda is non-ascii art for putting hats on your variables. :)
16:01:02 <shachaf> ISO-8859-7 art
16:01:08 <kadoban> https://en.wikipedia.org/wiki/Begriffsschrift apparently
16:01:37 <dolio> shachaf: Can't be that, either.
16:01:48 <dolio> I guess Church had a typewriter with a lambda but not a caret?
16:01:52 <dolio> Or something?
16:02:42 <bitemyapp> dolio: came from Whitehead and Russell's notation for class abstraction
16:02:45 <ertes> church probably thought of using arrows, but unicode wasn't around
16:02:57 <bitemyapp> caret over x changed into lambda x
16:03:16 <dolio> So W&R had the weird typewriter?
16:03:33 <bitemyapp> http://www.users.waitrose.com/~hindley/SomePapers_PDFs/2006CarHin,HistlamRp.pdf I guess? I don't know. See page 3.
16:04:13 <monochrom> my thesis supervisor Hehner talked to someone who talked to Church about this. Initially it was a variable-length hat to indicate scoping. Then compromised for uppercase Λ at the front. Then ran out of Λ and compromised for λ.
16:04:39 <monochrom> (Then we went back to Λ for the type level.)
16:05:19 <hpc> "ran out of Λ"?
16:05:41 <ertes> i think, the "∀ … ." syntax was already around…  and lambda is kind of like "for all"
16:05:59 <dolio> Oh, also, some Church stuff has notation that looks a lot like logical framework stuff by Martin-löf.
16:06:18 <dolio> Where quantification/abstraction looks like: (x)E
16:06:32 <dolio> Where x is the quantified variable, and E is the body of the expresssion.
16:07:54 <dolio> Oh, I see. W&R were using variables with hats, and he wanted a similar but distinctive notation.
16:08:11 <dolio> So he wanted a hat that was as big as a variable, but there was no such thing, so he picked lambda instead.
16:09:03 <shachaf> I heard that Church also invented the "." used in ∀, ∃, λ, etc.
16:09:34 <ertes> wasn't it already around?  also i actually like that syntax
16:09:44 <ertes> (for ∀ and ∃)
16:09:49 <dolio> Could be. A lot of old stuff looks like: (∃x)P
16:09:56 <dolio> Instead of ∃x.P
16:10:22 <shachaf> I heard that "." originally meant something like $ in Haskell.
16:10:52 <dolio> Oh, there are also systems that have more elaborate parenthesis removal.
16:10:58 <dolio> Like, subscript squares of various types.
16:11:02 <ertes> at least it's better than (∃x)P, because that looks too much like application
16:21:15 <dolio> So there are notations where instead of "(P -> Q) -> R" you can write something like "P -> Q .-> R" 
16:21:45 <kadoban> dolio: That sounds kinda bad, haha.
16:22:26 <dolio> And there's also "P -> Q ->. R"
16:22:35 <dolio> Yeah, I'm not a huge fan.
16:23:07 * hackagebot flamingra 0.2 - FlameGraphs of profiling  https://hackage.haskell.org/package/flamingra-0.2 (AntonNikishaev)
16:26:44 <monochrom> hpc: There was a time a typesetter would keep only a few Λs, and only slightly more λs.
16:26:52 <monochrom> and yes, physically.
16:34:19 <Sinestro> Is there a way in repa to traverse a subset of an array? I've got a 2D array that could easily be 4000x4000 elements, but the actual operation that I'm doing is super local and would usually only touch probably a 20x20 (about) chunk of the array, although the actual size and shape of that chunk varies wildly with the other operand, so I can't really just say 'Okay, here's a regularly sized chunk' but I can easily calculate the
16:34:19 <Sinestro>  size of that chunk for a given operand.
16:36:04 <Sinestro> Yes I know that that's not very 'parallel' but it doesn't matter because the operations aren't ordered. (doThing arr x; doThing arr y; == doThing arr y; doThing arr x)
16:39:27 <slack1256> why use the tagged library instead of declaring phantom types?
16:40:04 <slack1256> didn't haskell98 have phantom types? I thought it had
16:41:11 <glguy> slack1256: Same reason as any other library, so you don't have to reimplement it
16:41:30 <slack1256> there is nothing to reimplement...
16:41:30 <glguy> It's got the type and some operations on it and a large number of relevant type class instances
16:41:40 <glguy> http://hackage.haskell.org/package/tagged-0.8.3/docs/Data-Tagged.html
16:41:46 <slack1256> mmm the instances!
16:43:18 <slack1256> Now I kind of see why it would be useful!
16:43:54 <slack1256> btw glguy do you have a moment? I got a question about irc-core
16:44:11 <Welkin> slack1256: how's the weather in chile?
16:44:29 <slack1256> chilly *badum tss*
16:44:47 <Welkin> any military coups going on?
16:45:11 <slack1256> nah, we offloaded that gob to the venezuelans and bolivians
16:45:16 <slack1256> *job
16:48:18 <unexisting> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
16:48:20 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:48:20 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
16:48:20 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:49:17 <unexisting> This. Is there a ternary analogue of >>=, or can it be expressed via common functions?
16:49:50 <Welkin> it is only defined using the operator
16:49:58 <unexisting> :t join . liftM2
16:49:59 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
16:50:10 <slack1256> A combination of <*> and join?
16:50:23 <unexisting> :t \a b -> join $ liftM2 a b
16:50:24 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
16:50:25 <lambdabot>     Expected type: m a2 -> m a2 -> a
16:50:25 <lambdabot>       Actual type: m a2 -> m a
16:50:44 <Welkin> slack1256: but <*> is not Monad
16:50:45 <unexisting> :t \f a b -> join $ liftM2 f a b
16:50:46 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
16:50:57 <unexisting> That. Thanks :o)
16:51:27 <nitrix> unexisting: (>>=) is \f -> join . fmap f
16:52:11 <Koterpillar> nitrix: but there's no ternary analogue of (.), is there?
16:52:26 <nitrix> Sorry, that's (=<<)
16:52:30 <nitrix> Flip it and you get (>>=)
16:52:41 <Welkin> what's the point of avoiding >>= ?
16:52:53 <nitrix> Koterpillar: Ternary?
16:53:07 <nitrix> @let (.:) = (.) . (.)
16:53:08 <lambdabot>  Defined.
16:53:11 <nitrix> :t (.:)
16:53:12 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:53:13 <mrsyn> Hi
16:53:14 <nitrix> Koterpillar: This?
16:53:23 <Koterpillar> ...yes :)
16:53:27 <mrsyn> I'm from #asciipr0n
16:53:37 <nitrix> mrsyn: Welcome on #haskell.
16:53:40 <mrsyn> I have a question for someone please help
16:54:04 <mrsyn> What level of dBm do i need to connect to a wifi
16:54:07 <Koterpillar> mrsyn: Look at the Lens library. It has lots of fancy... operators
16:54:16 <mrsyn> Sorry for the caps I'm on my phone
16:54:19 <nitrix> mrsyn: We welcome everyone. Just ask your question about Haskell and someone will help.
16:54:39 <Koterpillar> mrsyn: are you a Markov bot?
16:54:45 <mrsyn> I'm using open signal app
16:54:48 <mrsyn> No
16:54:55 <mrsyn> I'm a real person
16:55:04 <mrsyn> Teh-borg is my bor
16:55:06 <mrsyn> Bot
16:55:22 <mrsyn> I've been on freenode a longtime
16:55:23 <Koterpillar> then I suggest #android or something; this is not the place to ask about Wi-Fi
16:55:25 <nitrix> mrsyn: You may want to check with your distro and/or manufacturer. This isn't a Haskell problem.
16:55:31 <mrsyn> Probably since 99
16:55:51 <mrsyn> What channel would I use?
16:56:05 <mrsyn> I thought this might be a hacker #
16:56:15 <slack1256> #android
16:56:18 <nitrix> mrsyn: See #freenode or /q alis help, they'll guide you.
16:56:31 <mrsyn> I have only been on ascii
16:56:35 <Koterpillar> mrsyn: see the links in the title, "haskell" != "hacker"
16:56:37 <mrsyn> Ok cool thanks
16:56:51 <mrsyn> I have a hacked wii
16:56:58 <mrsyn> It's not working tho
16:57:01 <nitrix> glguy: ping.
16:57:07 <glguy> Hi
16:57:09 <mrsyn> I saw the files on the hd
16:57:23 <mrsyn> But the wii loader won't go
16:57:26 --- mode: ChanServ set +o glguy
16:57:26 --- mode: glguy set +q *!*@184.151.178.171
16:57:34 <nitrix> glguy: Appreciated.
16:59:48 <nitrix> Only pinged because he's been on "freenode for a longtime, since '99". The mistake and noise was unjustified.
17:00:41 <nitrix> Koterpillar: Do you see how (=<<) is join and fmap combined?
17:01:00 <nitrix> Oh, sorry, that was unexisting. Yours was the triple dot :)
17:01:30 <Koterpillar> is it defined somewhere?
17:01:44 <nitrix> No, but it's a common idiom.
17:02:13 <Koterpillar> :t join .: liftM2 
17:02:14 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
17:02:14 <lambdabot>     Expected type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a2 -> a
17:02:14 <lambdabot>       Actual type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a
17:02:15 <unexisting> nitrix: yay! Right, my desired combinator was more like ternary (=<<)
17:02:36 <Koterpillar> ...probably something along these lines, anyway
17:02:36 --- mode: glguy set -o glguy
17:02:48 <unexisting> Add one more piece of applicativeness and voila
17:04:52 <unexisting> :t \f -> join .: liftM2 f
17:04:53 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
17:05:30 <nitrix> :t (>>=)
17:05:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:05:40 <nitrix> :t (=<<)
17:05:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:05:53 <nitrix> unexisting: They are very similar, just two monadic values.
17:10:45 <slack1256> when people refeer that N-M scheduling is difficult, they mean at OS level right? the haskell rts with their capabilities looks like N-M to me
17:11:14 <slack1256> and looking at the code didn't seem ugly, or there are hacks I didn't see?
17:14:23 <geekosaur> they mean at the level of the N:M scheduler. the scheduler is not in your code; it is part of ghc's runtime
17:15:43 <Zemyla> Oh, I have a zipper question.
17:16:01 <slack1256> I don't want to push too much complexity to the rts, I can understand haskell, not the C/C-- that is the rts :-P
17:17:03 <Zemyla> Suppose I wanted to have a type-level red-black tree, like, a tree of type Tree color k v, which constrains red nodes to only have black nodes as children.
17:31:29 --- mode: ChanServ set +o glguy
17:31:30 --- mode: glguy set -qo *!*@184.151.178.171 glguy
17:45:56 <nitrix> Using Aeson, I'm faced with an encoding problem. I have two "types" in my game (lets says A and B) both represented as the same Z type (to make operations on Z more general and simpler).
17:46:36 <nitrix> The problem is that I can json encode A and B (which are in reality a record Z) with no problem, but the opposite, decoding, appears to be more or less impossible.
17:47:09 <coppro> can you show a quick example of the Haskell types?
17:47:26 <nitrix> I cannot dynamically on the fly pick the instance `FromJSON A` as far as I know, so I'm stuck decoding into the type Z, then having this giant case for all things in my game and their parseJSON implementation.
17:48:40 <Koterpillar> nitrix: why not define Z = Either A B?
17:49:32 <nitrix> Koterpillar: In practice, there's like 10 of those, but there'll be like 200.
17:49:42 <nitrix> They all represent each type of object in my game.
17:49:47 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Types/Object.hs
17:49:50 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Object/Player.hs
17:50:04 <coppro> nitrix: so Object is the Z
17:50:07 <coppro> what are A and B?
17:50:38 <nitrix> coppro: Z becomes Object, the very general type. Player is an example of A or B.
17:51:02 <coppro> nitrix: but what does Player look like in Haskell?
17:51:14 <coppro> because it looks to me like you're making it a completely distinct type
17:51:42 <monochrom> nitrix: is A a type? is B a type? is Z a type?
17:51:44 <Koterpillar> nitrix: is it data Player = MkPlayer { _playerHealth :: Int }?
17:51:44 <nitrix> coppro: For its own module, all operations are on a type Player; from the outside of the module, it appears as the record Object.
17:52:15 <coppro> nitrix: so presumably you have some conversions Object <-> Player and vice versa?
17:52:20 <nitrix> monochrom: Yeah, but we're moving to concrete examples for those letters.
17:52:34 <nitrix> coppro: I have a Player to Object conversion, not really the opposite.
17:52:47 <coppro> well it sounds like you need that
17:53:02 <nitrix> Which is probably what Aeson is hinting me that I'm doing wrong.
17:53:11 * hackagebot wikicfp-scraper 0.1.0.3 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.3 (debugito)
17:53:17 <coppro> yes, that seems very wrong since you're completely erasing the information that a Player is an Object
17:53:47 <coppro> sounds more like Object should be a typeclass to me, or at least a record which is aware of its contents
17:54:00 <coppro> (e.g. data Object a = )
17:54:02 <monochrom> nitrix: then Object has its own instance code, and Player has its own instance code. no?
17:55:21 <nitrix> coppro: I've been through the typeclass once, the problem is then you cannot have lists of objects, you need existantials.
17:55:37 <coppro> that's true of Object a too, yeah
17:55:41 <nitrix> coppro: Then it's also the same thing, you can't read the JSON into the existantial type easily, still need a giant switch case.
17:55:58 <coppro> nitrix: well if you're storing your data the way you seem to want to, that's unavoidable
17:56:16 <coppro> because it sounds like you're basically storing something which is not a sum type (Object) as a sum type
17:56:33 <nitrix> So, which leads me to another question then.
17:56:38 <nitrix> How does Aeson handles sum types?
17:56:46 <coppro> It's configurable
17:56:51 <coppro> see SumEncoding
17:56:53 <nitrix> data Foo = A a | B b  for example?
17:57:04 <nitrix> Checking.
17:57:18 <monochrom> if you use Either, a choice is made. you can make a similar choice yourself, but you have other choices. what coppro says.
17:57:24 <nitrix> Maybe it's time to refactor my game Object into a big sum type.
17:57:49 <monochrom> I do think people avoid sum types too much.
17:57:51 <coppro> I'd suggest either making Object into a sum type and making liberal use of lenses
17:57:58 <nitrix> data Object = Player PlayerData | Plant PlantData | ...
17:58:15 <coppro> or else making a sum type for serialization only
17:58:31 <coppro> but honestly, if you use lenses, you can avoid a lot of the nastiness of sum types
17:58:49 <nitrix> monochrom: I am slowly realising that a lot of fancy contraptions end up being just that in disguise.
17:59:08 <nitrix> coppro: I do have lenses, but I'm not a poweruser of it yet. Merely some lens and prism here and there.
17:59:28 <coppro> nitrix: the powerhouse here is has
17:59:34 <coppro> and folds generally
17:59:35 <coppro> let
17:59:57 <coppro> *you can make folds for all your common data
18:00:18 <coppro> e.g. if some objects have an owner, you can make an objectOwner traversal which points at the owner of the object, if any
18:00:35 <coppro> you can then do things like "has objectOwner object" to determine if you have an owner
18:01:50 <coppro> you need to spend some time writing the lenses as you need them, but you get a lot of freedom
18:02:55 <coppro> nitrix: thanks for inspiring me to go look at my game again :)
18:02:58 <nitrix> I see what's happening. The genericParseJSON has defaultOptions which can generate the conversion from and to the constructor.
18:03:09 <nitrix> I suspect this is why it needs GHC.Generics ?
18:03:24 <coppro> nitrix: GHC.Generics is to provide the default implemenation of fromJSON
18:03:54 <coppro> oh, that is genericParseJSON, yeah :)
18:04:26 <nitrix> Alright, I'll do some coding, see what I end up with.
18:04:44 <coppro> nitrix: 1 sec
18:05:03 <coppro> I'll show you an example from the board game I'm implementing
18:05:30 <coppro> check out Deed in https://github.com/scshunt/mage-knight/blob/master/Game/MageKnight/Type.hs and deedName and deedColour in https://github.com/scshunt/mage-knight/blob/master/Game/MageKnight/Lens.hs
18:29:13 * dmj` wonders if ghc-ios is in use
18:30:39 <nshepperd_> every time a new ghc comes out, I just want even more advanced features
18:30:56 <nshepperd_> where's my unlimited arbitrary type level computation
18:31:22 <coppro> in agda and idris
18:32:14 <Cale> Where's my computation with pattern matching on higher inductive types, and univalence?
18:47:33 <MichaelK> Are RankNTypes ever used to ensure that an arbitrary monad is pure?
18:50:10 <geekosaur> isn't the s in ST s a technically rank-2
18:50:11 <geekosaur> ?
18:50:35 <platz> can I not use a "derive makeArbitrary" TH template on a datatype with strict fields? http://lpaste.net/167047
18:51:15 <geekosaur> or, well, not the one in ST itself, but the one "injected" by runST --- thus making it untouchable
18:52:05 <MichaelK> geekoaur: I believe so, I just was looking at that but didn't make the connection, thanks
18:53:54 <ertes> type PureAction a = forall m. (Monad m) => m a
18:59:00 <Cale> geekosaur: runST's type is rank 2
18:59:25 <geekosaur> yeh, what I thought
18:59:45 <geekosaur> although I scrambled that discussion since runST is the field accessor >.>
19:00:41 <Cale> It's a little weird to think of runST as a field accessor...
19:01:21 <geekosaur> it is, but, well, technically it is :)
19:01:45 <geekosaur> all the runWhatsits are a bit weird that way
19:01:54 <Cale> runST :: (forall s. ST s a) -> a
19:01:54 <Cale> runST (ST st_rep) = case runRW# st_rep of (# _, a #) -> a
19:01:57 <Cale> ^^ kinda
19:23:59 <ggVGc> when I read about rank N polumorphism, I ususally get lost quite quickly..
19:24:13 <ggVGc> like this first SO answer for example, http://stackoverflow.com/questions/12031878/what-is-the-purpose-of-rank2types
19:32:01 <EvanR> it clicked for me when, after getting that to use a rank 1 (usual) polymorphic function, you have to pick monotypes for the variables, i realized that with a rank 2 type... you dont
19:32:18 <EvanR> you can pass a rank 1 polymorphic function into a function as is
19:32:37 <EvanR> i dont think ive ever seen rank 3
19:33:36 <MichaelK> EvanR aren't rank 3 undecidable in general?
19:34:09 <EvanR> type inference of rank N doesnt work... for some N
19:34:12 <EvanR> not sure the details
19:36:17 <ggVGc> I kind of get the use cases for rank 2
19:36:25 <ggVGc> rank > 2 I have no idea about
19:36:33 <EvanR> so the key is when and where you decide what the polytypes should be used as
19:43:15 * hackagebot deriving-compat 0.2.2 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.2.2 (ryanglscott)
19:46:14 <nitrix> Are there legitimate uses of ImpredicativeTypes?
19:46:16 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Types/Cache.hs
19:46:42 <nitrix> Or should I have the Types.Link module export an existantial type and avoid impredicative altogether?
19:48:59 <nitrix> I have a feeling this is going to be flawed, as there'll be no practical ways to deal with the `forall a. Link a` values later on.
19:51:37 <Cale> nitrix: There are probably legitimate uses of ImpredicativeTypes, but it's a moot point since that extension is perpetually in a broken state.
19:53:35 <Cale> nitrix: It would probably be better just to use a Seq Int
19:54:06 <Cale> nitrix: Since the impredicativity in this case rules out having properly filled in LinkRef values in the sequence
19:59:21 <platz> this is odd.. why would GHC interpret a !Text field as (Bang NoSourceUnpackedness SourceLazy,ConT Data.Text.Internal.Text)... SourceLazy implies ~Text, not !Text.. does it even make sense to bang Text fields?
20:00:38 <platz> Text is coming from import Data.Text (Text) , so it shouldn't be the lazy variant
20:01:56 <glguy> platz: You'll have to show us the code and output you're looking at. It certainly makes sense to have a strict-flagged Text field in a data type
20:03:22 <platz> glguy: thanks, it's not a big deal for me, just wanted a santiy check.. maybe it just a bug in the derive pkg
20:03:37 <glguy> http://lpaste.net/167054
20:04:17 <vxctr_> need to store a binarized version of a csv file. thiinking of using bson, is there something that would work better?
20:06:48 <platz> ah, that ghci trick is nice... ghc corrently reads the fields as "SourceStrict", yes
20:06:51 <glguy_> Platz: just to be clear I'm saying that GHC doesn't appear to do the thing you asked about
20:07:06 <platz> http://lpaste.net/167055 seems to be fine.. 
20:07:34 <kadoban> vxctr_: What about like a sqlite database?
20:09:17 <vxctr_> kadoban have only used postgres and mysql (a tiny bit) as far as sql goes..
20:10:26 <vxctr_> kadoban so sqlite is just a binary blob representation?
20:10:28 <systemfault> vxctr_: It's a database in a single file, no need for server database
20:10:59 <kadoban> vxctr_: It's SQL (obviously), so it'll feel somewhat familiar. To me it's kind of the next step up from a CSV file, but it might depend what you're using it for.
20:11:23 <kadoban> Yeah it stores everything in a single file, that's the whole DB. It's rather cool for quite a lot of uses.
20:11:32 <vxctr_> what handles the query if there's no server?
20:11:49 <Zemyla> StableNames have false negatives, but not false positives, right?
20:11:49 <systemfault> vxctr_: the sqlite library
20:11:57 <sm> it's linked into your app, you call it directly
20:12:41 <vxctr_> so the haskell sqlite takes care of the sql parsing and pulls data from the file as needed?
20:13:02 <vxctr_> so some internal library in your app is taking the place of the sql server
20:13:13 <kadoban> Sounds about right, yeah.
20:13:43 <vxctr_> that's pretty cool. had heard of it, but i figured it was another mysql-ish alternative..
20:14:48 <vxctr_> is this the package to use https://hackage.haskell.org/package/sqlite-0.5.3? or maybe https://hackage.haskell.org/package/sqlite-simple-0.4.9.0
20:15:36 <kadoban> I used persistent-sqlite I belive. Not sure that's the best thing to use though, there's a learning curve. I kinda liked it though.
20:16:15 <sm> the great thing about that is you can easily upgrade to a more powerful db later
20:17:49 <vxctr_> that is pretty appealing yeah.
20:22:55 <Zemyla> I have a question about Eq1 and Ord1.
20:23:37 <Zemyla> Wait, never mind.
20:28:59 <EvanR> vxctr_: im using sqlite right now for storing comments, it ended up being less of a pain in the ass than a new rdbms
20:29:20 <EvanR> it also has nicer string type than mysql, like most non-mysqls
20:30:19 <vxctr_> EvanR i'm a sql neophyte, but i don't understand why people use mysql over postgres...
20:31:20 <vxctr_> to close out my previous approach with bson, anyone know what lazy IO thing is biting me in the ass with this toy example?
20:31:21 <vxctr_> http://lpaste.net/167056
20:31:27 <sm> I guess it was more common on hosting providers or something ?
20:31:54 <vxctr_> if i run the code line by line in ghci it works just fine
20:31:58 <sm> and maybe easier to admin 
20:32:07 <vxctr_> but if I try to run it as x <- testBSon I get
20:32:11 <vxctr_> *** Exception: deleteme.bson: openBinaryFile: resource busy (file is locked)
20:33:21 <vxctr_> sm what do you mean by hosting provider? postgres support is pretty comprehensive with things like AWS RDS.
20:33:42 <Koterpillar> vxctr_: there's a reason why LAMP is a common word
20:33:50 <kadoban> vxctr_: Shitty web hosts tend to all have mysql, and not as many have postgres.
20:34:32 <sm> before AWS, you used whatever was installed on the machine where you hosted your website
20:35:16 <sm> and I guess it was more common on web hosting servers because it was lighter/easier for them to run 
20:37:03 <vxctr_> thanks... my background is as a scientist working with data on the stats/modeling side. my awareness of the history of these monolithic stats is incomplete.
20:38:14 <vxctr_> stacks
20:38:40 <Cale> vxctr_: That's odd, typically writes are not lazy. If it were the other way around, writing to a file you were at the time trying to read from, that might make more sense. Perhaps the OS still for some short time has the file locked?
20:39:17 <vxctr_> Cale I'm on OSX
20:39:50 <vxctr_> there's not some sort of "close file" i'm supposed to do here is there? or some bang pattern trick to enforce strictness?
20:39:51 <Cale> It's not uncommon to need to be careful about reading from and writing to the same file, in any setting (not just in Haskell). Typically the correct thing to do is to write to a different file, and then move it to the location where you want it to be all at once.
20:42:05 <Cale> vxctr_: Add some putStrLn's to the code, particularly between the writeFile and readFile, to see where the exception is happening
20:42:22 <Koterpillar> ...and see the effect disappear because of changed timing ;)
20:42:30 <Cale> hah, maybe!
20:42:47 <vxctr_> Cale wow refactored into separate read/write and playing around in ghci. behavior is _very_ inconsistent
20:43:07 <Koterpillar> so, I'd recommend strace; I hear it's called dtrace on macOS but not sure how to use that one
20:43:28 <Cale> If BL is Data.ByteString.Lazy, then you have to be aware that readFile is lazy
20:43:57 <Cale> This 'dat' you get back is a bit magic -- its evaluation causes the file to actually be read
20:44:22 <vxctr_> added some changes and example ghci output http://lpaste.net/167056
20:44:26 <Cale> and the file will only be closed at some point after you've finished evaluating the whole lazy bytestring
20:44:27 <vxctr_> pretty confusing ..
20:44:55 <Cale> But in this case, your lazy operation, the read, comes after a strict one, the write
20:45:13 <Cale> So in this case, I bet it's just a race condition where the OS keeps a lock on the file for a bit longer than you'd like
20:45:34 <Cale> (i.e. it has nothing to do with strict or lazy I/O)
20:46:01 <vxctr_> Cale BL is bytestring lazy. can i use bytestrings to force the readFile to be strict?
20:46:24 <Cale> Yeah, you could use the strict bytestring library
20:46:29 <Cale> I doubt it will help...
20:47:04 <Cale> writeFile will close the handle to the file that it opens
20:47:09 <vxctr_> Data.Binary.Put uses lazy bytestrings though
20:47:24 <Cale> You can make a lazy bytestring from a strict one
20:47:26 <vxctr_> oh meant to say bangpatterns to force the readFile to be strict
20:47:31 <vxctr_> not bytestrings
20:47:45 <Cale> bang patterns won't help
20:48:04 <Cale> toStrict :: BL.ByteString -> BS.ByteString
20:48:24 <vxctr_> one thing i noticed
20:48:27 <Cale> fromStrict goes the other way
20:48:36 <vxctr_> if I call testRead testWrite separately it's fine
20:48:41 <vxctr_> if I run testBSON by itself it's fine
20:48:42 <Cale> yes
20:48:49 <Cale> It's because you don't do it so quickly
20:48:55 <vxctr_> well testBSON does both
20:49:03 <vxctr_> the exception only manifests of i bind a variable with
20:49:04 <Cale> I suspect it's just your OS keeping the lock on the file for too long
20:49:06 <vxctr_> foo <- testBSON
20:49:24 <Cale> hmm
20:49:35 <Cale> oh
20:49:38 <Cale> Of course
20:49:51 <Cale> Yeah, the file won't be closed yet, if you're already reading it
20:50:10 <Cale> When you do the first foo <- testBSON2
20:50:21 <Cale> the file will remain open until foo is evaluated
20:50:27 <Cale> (fully)
20:50:33 <vxctr_> ah so
20:50:48 <Cale> Try something like length foo
20:50:48 <vxctr_> so if I put a bangpattern on foo or just use it that will fix it
20:50:59 <Cale> Only if you use it completely
20:51:14 <Cale> The bang pattern probably won't help, because that does the minimum possible amount of evaluation
20:51:26 <vxctr_> simply evaluating foo gets rid of the exception
20:51:32 <Cale> so it'll read the first chunk of the file
20:51:38 <Cale> (if the file is small, it might work...)
20:52:17 <vxctr_> what's the convention to "evaluate this thing so i don't have to worry about ownership"
20:52:26 <Cale> The more correct thing to do would be to use Data.ByteString.readFile
20:52:45 <vxctr_> yes that sounds right
20:52:53 <Cale> and then convert the strict bytestring to a lazy one if that's what you need
20:53:56 <vxctr_> yup that fixes it
20:54:51 <Cale> Lazy IO is really convenient for the sort of application where you're reading a bunch of input from a small number of files, and don't have to worry about whether the handles get closed
20:55:10 <Cale> But otherwise, it can be a bit fiddly
20:55:22 <vxctr_> yay this works http://lpaste.net/167056
20:55:47 <Cale> cool
20:56:25 <vxctr_> thanks
20:56:51 <vxctr_> now to scrap this and use sqlite instead :P
21:08:11 <vxctr_> ugh can't seem to find a way to safely deserialize bson
21:08:41 <vxctr_> Data.Bson valueAt, at, ... where are the Maybe functions?
21:10:36 <dmj`> vxctr_: aeson has Maybe functions :)
21:11:00 <vxctr_> dmj` aeson doesn't support bson does it?
21:11:16 <vxctr_> i've seen a couple adapter libraries but they all seem to be poorly maintained
21:12:45 <dmj`> vxctr_: why not use binary/cereal? Or the new store pkg
21:13:43 <vxctr_> dmj` well i'm using binary indirectly as it's needed for bson
21:14:14 <vxctr_> writing/reading. it sounds like i shouldn't be bothering with the bson format. does nobody use this crap? :P
21:14:27 <EvanR> mongo...
21:14:58 <dmj`> vxctr_: yea, I'd just cut out the middle man
21:15:13 <vxctr_> how is json so popular and bson is only used by mongo (which everybody hates)
21:15:18 <EvanR> it sounds like valueAt type stuff should only be used when you have proof it will succeed, due to some design choice of your format
21:15:38 <EvanR> otherwise use something else
21:16:30 <vxctr_> well i have a "proof" in that i'm the only one writing out this particular bson file.
21:17:00 <vxctr_> but yeah it sounds like i'm wasting my time with this lib..
21:17:12 <EvanR> and yourself is one of the most malicious/incompetent attackers of all!
21:17:37 <vxctr_> lol
21:20:46 <dmj`> vxctr_: yea, I'd just generic derive Serialize instances
21:21:01 <coppro> ahhhh, I was overcomplicating this design
21:21:08 <coppro> one last thing I need to figure out what to do
21:21:26 <vxctr_> dmj` is that with cereal-derive?
21:23:24 <vxctr_> or no, looks like cereal has it built in
21:23:28 <EvanR> vxctr_: apparently there is some hotness going on with cbor?
21:23:40 <dmj`> vxctr_: yea, built in
21:23:47 <EvanR> might be work a look if you are doing binary serializations
21:24:31 <EvanR> i think they want to use it to replace whatever Binary is doing now
21:25:00 <vxctr_> EvanR https://hackage.haskell.org/package/CBOR ? looks like it may be somewhat bleeding  edge for real-world use.
21:25:08 <roconnor> Why do I have lots of redudnent constraints?
21:25:23 <vxctr_> unless the performance is huuugely different to make it worth it
21:25:25 <roconnor> @paste
21:25:25 <lambdabot> Haskell pastebin: http://lpaste.net/
21:25:48 <EvanR> i would go with whatever is easiest 
21:26:19 <roconnor> http://lpaste.net/167065 <-- why redundant constraint?
21:27:39 <roconnor> oh, it's because I don't actually make use of the constraint in any way.
21:28:12 <roconnor> hmmm
21:37:08 <vxctr_> how bad of a code smell is it to use cereal-text? https://hackage.haskell.org/package/cereal-text-0.1.0.2
21:38:05 <vxctr_> need Text instances for serialization which aren't available, presumably because of this reasoning http://stackoverflow.com/questions/19365523/serialize-instance-for-data-text
21:38:13 <osager_> what is the precision of the sin function in haskell
21:38:21 <EvanR> :t sin
21:38:23 <lambdabot> Floating a => a -> a
21:38:25 <EvanR> it depends
21:38:36 <EvanR> > sin pi :: CReal
21:38:38 <lambdabot>  0.0
21:38:45 <osager_> can we ask for arbitrary precision?
21:39:11 <EvanR> there are a couple exact real libraries
21:39:40 <osager_> for 10 bit, i dont need an extra library no ?
21:39:49 <osager_> 10 decimals
21:40:00 <EvanR> you mean after the period?
21:40:03 <osager_> yes
21:40:03 <EvanR> or all together
21:40:15 <EvanR> > sin 3.14
21:40:16 <lambdabot>  1.5926529164868282e-3
21:40:23 <EvanR> > sin 10**100
21:40:25 <lambdabot>  3.643974206834171e-27
21:40:42 <EvanR> > sin 11**100
21:40:43 <lambdabot>  0.999021129681161
21:41:19 <osager_> coordinates d r = (r * cos(pi*d/180), r*sin(pi*d/180))
21:41:30 <EvanR> with Double, the first thing that happens is the argument is reduced to somewhere between -pi and pi
21:41:34 <osager_> for coordinates(90,1)
21:41:44 <osager_> it should give (0.0, 1.0)
21:42:03 <EvanR> oh, are your arguments always small?
21:42:11 <Koterpillar> > let coordinates d r = (r * cos(pi*d/180), r*sin(pi*d/180)) in coordinates 90 1
21:42:12 <lambdabot>  (6.123233995736766e-17,1.0)
21:43:38 <EvanR> you should get a lot of precision using sin on small arguments
21:44:20 <osager_> how can i get an exact 0 in my test case
21:44:21 <osager_> ?
21:44:45 <EvanR> > let coordinates d r = (r * cos(pi*d/180), r*sin(pi*d/180)) in coordinates 90 1 :: (CReal,CReal)
21:44:47 <lambdabot>  (0.0,1.0)
21:44:50 <EvanR> \o/
21:44:57 <osager_> wow
21:45:00 <osager_> why
21:45:10 <EvanR> because maf
21:46:05 <EvanR> because this CReal's Show instance decides on some arbitrary precision, and the value of sin pi is closer to zero than we can see
21:46:23 <EvanR> its actually closer to zero than any precise we pick
21:46:34 <EvanR> any uncertainty around zero
21:47:10 <EvanR> it would be nice if the numeric lib could also give you this uncertainty explicitly
21:47:30 <osager_> i will check the doc
21:47:34 <osager_> Thanks EvanR 
21:47:38 <osager_> a lot
21:47:41 <EvanR> see also the exact-real package
21:48:06 <EvanR> you can give it an explicit amount of precision 
21:48:24 <osager_> ok
21:49:03 <EvanR> of course you will be paying a performance cost by not using Doubles
21:55:15 <joneshf-laptop> What haskell "design" resources exist? Books, tutorials, talks, courses, etc? Looking for information about using haskell with large teams.
21:55:24 <johnw> defunctionalization is a neat trick
21:55:41 <johnw> joneshf-laptop: that's going to be hard to learn well from a book
21:56:09 <EvanR> defunctionalization?
21:56:14 <johnw> joneshf-laptop: It's hard to replace the value of having an experienced engineer, who has tried a lot of different approaches before, available to train your team
21:56:53 <johnw> EvanR: it's a way of turning higher-order functions into first order functions, but enumerating all the possible function arguments used in the program and substitute function passing for token passing, with an evaluator to correlate tokens back to functions
21:57:00 <johnw> s/but/by
21:57:14 <johnw>  and by function arguments here I mean arguments that are functions
21:57:48 <EvanR> is this to implement a runtime?
21:58:08 <EvanR> in a language that cant do it natively
21:58:26 <johnw> it's a whole program transformation for when your target "language" can't handle the higher-order constructs you're dealing with
21:58:33 <johnw> the singletons library uses the trick, for example
21:58:42 <johnw> I'm using it in Coq for an abstract data type library that doesn't deal with HOF
21:59:27 <johnw> it allows my interface to remain first-order, but without losing the functionality of higher-order that I want (such as providing a callback to an algorithm), so long as the number of instances of that callback can be known at compilation time
22:00:51 <johnw> so instead of foo : : (x -> r) -> a -> r, I have foo :: Lam -> a -> r, where Lam is a sum type with one constructor for every possible callback I might use
22:01:13 <EvanR> oh
22:01:39 <johnw> and then I need an evaluator apply :: Lam -> r -> r to tie it all together
22:13:49 <osager_> what does this code do with the numbers? fromIntegral (round (1e10 * v)) / 1e10
22:14:33 <EvanR> :t fromIntegral (round (1e10 * v)) / 1e10
22:14:34 <lambdabot>     Could not deduce (RealFrac Expr) arising from a use of ‘round’
22:14:34 <lambdabot>     from the context (Fractional a)
22:14:34 <lambdabot>       bound by the inferred type of it :: Fractional a => a
22:14:35 <osager_> > tr v = fromIntegral (round (1e10 * v)) / 1e10
22:14:37 <lambdabot>  <hint>:1:6: parse error on input ‘=’
22:14:41 <EvanR> looks wrong
22:15:18 <EvanR> oh well whats v
22:15:18 <osager_> > let tr v = fromIntegral (round (1e10 * v)) / 1e10
22:15:18 <lambdabot>  <no location info>:
22:15:18 <lambdabot>      not an expression: ‘let tr v = fromIntegral (round (1e10 * v)) / 1e10’
22:15:18 <EvanR> :t \v -> fromIntegral (round (1e10 * v)) / 1e10
22:15:18 <lambdabot> (Fractional a, RealFrac a1) => a1 -> a
22:15:53 <EvanR> :t 1e10
22:15:54 <lambdabot> Fractional a => a
22:16:18 <EvanR> osager_: constants like 1e10 are polymorphic in that you have to decide which Fractional youre talking about before any computation can begin
22:16:59 <osager_> it's double
22:17:50 <osager_> http://lpaste.net/167070
22:18:00 <EvanR> ok, then * is double multiplication, round will use ieee rounding (whatever that means, depends on your environment), and fromIntegral wont really have any effect
22:18:19 <EvanR> other than make the types match up
22:19:22 <EvanR> ... actually there might be some ambiguity of which Integral type it goes through during the round - fromIntegral trip
22:21:30 <EvanR> > round 259.0
22:21:32 <lambdabot>  259
22:21:36 <EvanR> > round 259.0 :: Word8
22:21:38 <lambdabot>  3
22:31:42 <platz> if something is a monad, I've heard `ap` should be the same as `<*>`.  Then is it also true that if we have a MonadPlus, then we should also have an Alternative, with `mplus` == `<|>` ?
22:33:02 <johnw> I've heard that `ap` is not guaranteed to always be the same as `<*>`
22:33:59 <coppro> not guaranteed, but it's unlawful for it not to be
22:34:18 <johnw> see https://elvishjerricco.github.io/2016/04/08/applicative-effects-in-free-monads.html for an instance where it has mattered
22:34:20 <osager_>  round' = ((/ 10.0^^10) . fromInteger . round . (* 10^10))
22:34:23 <osager_> sorry
22:34:24 <EvanR> some sort of applicative-monad cross laws?
22:34:25 <osager_> wrong place
22:34:54 <johnw> coppro: I'm not sure that is true either
22:35:33 <coppro> johnw: it's right in the Monad laws
22:35:44 <coppro> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Instances.html#t:Monad
22:36:49 <Zemyla> <*> and ap have to produce the same result, but they can be different internally. In particular, <*> can be more efficient.
22:36:53 <johnw> right
22:37:04 <Zemyla> Imagine you have a vector type without streaming.
22:37:13 <johnw> the denotational semantics of the two must be equal, but not operationally
22:37:16 <Koterpillar> In PureScript, MonadPlus requires Alternative
22:37:37 <Zemyla> Koterpillar: It does in GHC 7.10 and later.
22:38:16 <Zemyla> But yeah, (>>=) has to guess how big the vector it's going to produce will be, and if it fails, it needs to grow it.
22:38:38 <platz> in Data.Either.Validation, its an Applicative but has no instance for Monad, because a Monad instance would break ap == <*>
22:39:14 <Zemyla> <*>, on the other hand, can take an m-element vector and an n-element vector, and start calculating the result in an (m*n) element vector.
22:39:43 <coppro> Zemyla: True. The difference is an artifact of Monad having been not a subclass of Applicative
22:41:15 <platz> mm, so mplus should be semantically equal to <|> i take it
22:41:26 <platz> at least in in GHC 7.10 and later.
22:41:59 <Zemyla> coppro: No, the difference is because the (>>=) in ap doesn't know that each of its results will be a fixed size.
22:42:22 <coppro> Zemyla: Sure. But ap is only defined in terms of (>>=) for historical reasons
22:42:33 <coppro> ap *should* be defined as being <*>
22:42:43 <coppro> but that would break all the code that does the opposite
22:43:14 <kadoban> platz: I'm rather curious about the answer as well. I think it *should* be, I'm not sure that's reality though.
22:48:37 <Zemyla> coppro: ap is defined in terms of (>>=) for the people who don't want to write a separate (<*>).
22:48:54 <Zemyla> It's the same reason why liftA exists.
22:48:57 <Zemyla> :t liftA
22:48:58 <lambdabot> Applicative f => (a -> b) -> f a -> f b
22:49:15 <Zemyla> It lets you go "fmap = liftA".
23:59:49 <idev> does CPS style interpreters lose concurrency
23:59:56 <idev> since the args have to be evaluated in order rather than in parallel?
