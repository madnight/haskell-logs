00:07:37 * hackagebot smallcaps 0.6.0.3 - Flatten camel case text in LaTeX files  https://hackage.haskell.org/package/smallcaps-0.6.0.3 (StefanBerthold)
00:07:37 * hackagebot uri-bytestring 0.2.1.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.1.2 (MichaelXavier)
00:26:36 <Squarism> how is a typical receive-update loop constructed in haskell? foldM ? recursion?
00:28:28 <saurabhnanda> does anyone here use intero or flycheck? why does C-c C-t stop working? Or, under what conditions does it work?
00:43:35 <xtreak> I am a beginner in haskell with python background. Is there a book or some series of blogs to understand terms like algebraic data types, sum types, union types etc
00:45:17 <shachaf> I think any good introduction to Haskell will explain those terms.
00:45:33 <xtreak> I am using real world haskell. These terms always intrigue me as i don't have cs or math background.
00:45:58 <shachaf> I guess that book isn't quite meant as an introduction.
00:46:38 <athan> I've been seeing a new "Readme" field on some packages in hackage; is this build by hackage itself?
00:46:59 <shachaf> I'd recommend Hutton's _Programming in Haskell_, but it's a bit out of date and the second edition only comes out in a couple of months.
00:47:09 <xtreak> Is there a book that is recommended to teach haskell with emphasis on types
00:47:12 <athan> or more specifically, only created when Hackage builds the documentation on its own, and not uploaded
00:47:36 <athan> xtreak: Types and programming languages?
00:47:39 <athan> er no that's both
00:48:25 <athan> Are you looking for like a resource on type-level programming? Or just like, well-made expressions / types for different problem sets?
00:49:22 <xtreak> I am looking for resource on type level programing. I mostly used perl, clojure and python.
00:49:31 <athan> :|
00:49:47 <athan> then you're probably not thinking of type-level programming in haskell is my guess
00:50:05 <shachaf> Are you actually interested in type-level programming, as in code that does nontrivial things on the type level?
00:50:24 <shachaf> If you just want to learn about things like algebraic data types, that's a very different request.
00:50:36 <athan> xtreak: I highly suggest types and programming languages for the determined :)
00:51:02 <mauke> algebraic data types etc. is just using types as types. it's not programming at the type level
00:51:16 <xtreak> I just want to learn about algebraic data types. What those terms mean and how they improve my code.
00:51:31 <mauke> then you basically want a haskell tutorial
00:52:06 <mauke> short version: "algebraic data type" = the things you can define with 'data'
00:52:31 <xtreak> Sorry to be confusing. I had already been warned a lot about the difficulty in understanding type theory related things. Maybe I am mixing up things here.
00:53:02 <athan> xtreak: Haskell is a system of symbols, and sets of symbols, kinda. Recursive ones, too. Functions just case-match on the symbols and return a new one
00:53:08 <athan> like 1 is a symbol of the set Int
00:53:41 <athan> and + is a mapping between each side to a new symbol, that matches our intition about that stuff
00:54:01 <xtreak> Just wanted to give it a try. I lurk around haskell subreddit and those type level terms are wierd for me.
00:54:18 <mauke> "product type" means tuple
00:54:31 <mauke> "sum type" means alternative
00:54:47 <athan> xtreak: Just start small, make simple things, grow into your comfort level :)
00:55:20 <mauke> if that sounds weird, consider the number of possible values of the type
00:55:57 <mauke> e.g. if you have a type A with n possible values and a type B with m possible values, then (A, B) has n*m possible values
00:56:06 <mauke> similarly A | B has n + m possible values
00:58:38 <xtreak> When i say a type (int, int) then it can have (max value of int * max value of int) possible values?
00:58:46 <athan> mauke: I was actually talking with a friend about this, and he brought up a strange point: if you took all the exponential / function mappings from A -> B, and removed overlaps, then wouldn't that be equal to (A,B)?
00:58:58 <athan> xtreak: Not quite
00:59:18 <athan> that's more advanced than Haskell for the most part, "dependent types"
00:59:22 <mauke> xtreak: let's start with smaller numbers. consider (Bool, Bool) first
00:59:47 <mauke> also, Int has maxBound - minBound + 1 possible values
00:59:55 <athan> you could shuffle those values or make guards for assurance, don't get me wrong, but to actually prove that `n < m` at compile time is tricky
01:00:09 <mauke> athan: ?
01:00:35 <xtreak> Possible values are (True, True) (True, False), (False, True) and (False, False)
01:00:57 <mauke> 2 * 2 = 4
01:00:59 <xtreak> M*N number of values
01:01:25 <xtreak> So its a product type?
01:01:28 <mauke> yes
01:01:30 <mauke> > fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int) + 1
01:01:31 <lambdabot>  18446744073709551616
01:01:41 <mauke> ^ number of possible Int values
01:01:50 <mauke> slightly harder to count
01:02:57 <xtreak> How about a sum type?
01:04:14 <mauke> are you familiar with Either?
01:04:19 <mauke> @src Either
01:04:20 <lambdabot> Source not found. My mind is going. I can feel it.
01:04:22 <mauke> :-(
01:04:30 <mauke> data Either a b = Left a | Right b
01:05:08 <xtreak> I googled on this and had https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types which goes as per your methodology
01:05:14 <athan> @info Either -- ?
01:05:15 <lambdabot> Either
01:05:26 <xtreak> Yes I am aware of Either
01:05:35 <athan> Kaaaaaaan <extensions>!!!
01:06:52 <mauke> ok, Either is the quintessential sum type
01:07:24 <mauke> oh, right. Bool (and any enum type) is also an example
01:07:56 <mauke> but you could define Bool as Either () (), with False being represented by Left () and True by Right ()
01:08:58 <mauke> hah, the article already says that
01:09:00 * mauke shuts up
01:09:45 <xtreak> Then Int can also be sum type right? I imagine learn you a haskell defining int = -minbound value | value-1  and goes on increasing till maxbound int
01:10:00 <athan> stand down mauke!
01:10:27 * athan actually found OCaml's (+) and (*) syntax really intuitive >.>
01:10:38 <shachaf> Yes, you can think of Int that way (though the actual implementation is different).
01:11:06 <mauke> I thought ocaml used | and *
01:11:10 <shachaf> (I originally wrote "more efficient" but really there's no reason GHC couldn't compile something like that to effectively bthe same thing as Int.)
01:11:54 <athan> :x
01:12:17 <xtreak> Yes the book said its implementation is different but that it could be implemented like this too..
01:42:34 * hackagebot calendar-recycling 0.0 - List years with the same calendars  https://hackage.haskell.org/package/calendar-recycling-0.0 (HenningThielemann)
01:49:59 <hawk78> Hi does such a function exist?  j :: (Monad m) => (m a -> m b) -> m (a -> b) , does it make sense?
01:51:51 <Rembane> hawk78: That looks like an applicative fnuctor
01:52:00 <Rembane> :t (<*>)
01:52:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:52:11 <Rembane> Hm... nope. 
01:52:45 <hawk78> Rembane: theother way around
01:52:58 <pavonia> Such a function doesn't exist
01:54:00 <hawk78> pavonia: Rembane: I feared that
01:54:54 <pavonia> hawk78: What do you need that for?
01:55:07 <jle`> hawk78: are you looking for it for a specific type/instance?
01:56:06 <pavonia> @djinn (Maybe a -> Maybe b) -> Maybe (a -> b)
01:56:06 <lambdabot> f a =
01:56:06 <lambdabot>     case a Nothing of
01:56:06 <lambdabot>     Nothing -> Nothing
01:56:06 <lambdabot>     Just b -> Just (\ c ->
01:56:06 <lambdabot>                     case a (Just c) of
01:56:08 <lambdabot>                     Nothing -> b
01:56:10 <lambdabot>                     Just d -> d)
01:56:30 <jle`> f _ = Nothing ;)
02:01:32 <hawk78> pavonia: Actually I'm looking for (m e -> m s -> (m s, m o)) -> m (e -> s -> (s,  o))
02:02:40 <jle`> any specific 'm' in mind?
02:04:48 <pavonia> hawk78: Same question. That types doesn't make much sense to me
02:04:56 <pavonia> *type
02:05:15 <hawk78> jle`:  I would liek to be able to use IO, but also Maybe could be nice
02:05:38 <jle`> what sort of behavior do you want for Maybe?
02:05:45 <jle`> can you write the function specifically for Maybe?
02:06:46 <jle`> not even sure what it would do for Maybe, except for the trivial f _ = Nothing
02:07:15 <jle`> oh, heh
02:08:10 <jle`> @djinn (Maybe e -> Maybe s -> (Maybe s, Maybe o)) -> Maybe (e -> s -> (s, o))
02:08:11 <lambdabot> f a =
02:08:11 <lambdabot>     case a Nothing Nothing of
02:08:11 <lambdabot>     (b, c) -> case b of
02:08:11 <lambdabot>               Nothing -> Nothing
02:08:11 <lambdabot>               Just d -> case c of
02:08:13 <lambdabot>                         Nothing -> Nothing
02:08:15 <lambdabot>                         Just e -> case a Nothing (Just d) of
02:08:17 <lambdabot>                                   (f, g) -> case f of
02:08:19 <lambdabot>                                             Nothing -> Nothing
02:08:21 <lambdabot>                                             Just h -> case g of
02:08:23 <lambdabot>                                                       Nothing -> Nothing
02:08:39 * Clint squints.
02:12:13 <hawk78> Here is my mess :-)  http://lpaste.net/168006
02:14:19 <Cale> hawk78: Not sure it's any use to you, but I have some code here for constructing and manipulating NFAs http://cale.yi.org/share/Regular.hs
02:16:26 <pavonia> hawk78: Provided your type annotations are correct, that suggests there is no such instance you are trying to define
02:18:27 <saurabhnanda> okay, I’m stuck with monad transformers yet again! If I have a `(MonadLogger m, MonadIO m, MonadBaseControl IO m)` => m () AND a  `MonadIO m => Control.Monad.Logger.LoggingT m a -> m a` — how do I compose them? More importantly, how do I grok stuff like this? What’s the right way to think about such stuff?
02:19:28 <hawk78> I could remove the build function (and the handleevent default implementation) and it would be well defined.
02:19:52 <pavonia> Yes, without build
02:20:07 <hawk78> Then I can define build and handleevent per instance...
02:21:04 <saurabhnanda> anyone using intero? or flycheck? what's the emacs command (or keybinding) to start a full build? When I was using spacemacs+haskell-layer it was M-m m c b
02:21:15 <hawk78> Or... I could rewrite build and or handleEvent so that the following functions/types are possible to implement.
03:07:28 <wubba-lubba-lub-> Why doesn't Applicative subclass something like (class Default where pure :: a -> f a), and then tack on (<*>)?
03:07:46 <wubba-lubba-lub-> Is "Default" not interesting enough?
03:09:43 <wubba-lubba-lub-> Or is pure only interesting as a function-rasier, in which case we should go ahead and talk about (<*>) anyway?
03:13:04 <geekosaur> https://wiki.haskell.org/Why_not_Pointed%3F
03:14:11 <geekosaur> (Pointed being the usual name for what you call Default; see the Typeclassopedia)
03:16:27 <geekosaur> tl;dr: the only law it has that applies to all types is its free theorem, so you're complicating compilation for no benefit
03:43:27 <wubba-lubba-lub-> geekosaur: Complicating compilation? Is subclassing... expensive?
03:45:56 <wubba-lubba-lub-> Also how are laws determined/discovered for a typeclass? Or is it the other way round -- typeclasses being built around "sane" laws?
03:48:16 <coppro> wubba-lubba-lub-: "laws" are just a part of a typeclass's contract
03:49:09 <coppro> if you're thinking specifically about Functor, Applicative, Monad, or similar classes, then there is a mathematical foundation to the laws
03:49:26 <coppro> but ultimately they are whatever the typeclass authors think is required to make the types behave as desired
03:49:36 <maerwald> which may break the laws
03:49:49 <geekosaur> wubba-lubba-lub-, well, as far as compilation is concerned, you are making the typechecker do more work to get to the same place
03:50:18 <geekosaur> this can be worth it if you gain expressiveness or flexibility along the way... but you gain nothing from Pointed
03:50:23 <wubba-lubba-lub-> So how come there isn't a way to specify laws? Or is that too hard, too theorem-proovy?
03:51:03 <maerwald> people sometimes use quickcheck (property tests) for their monad instances
03:52:03 <geekosaur> it's doable but not really worth it; rather than making every program that uses your typeclass pay that cost, you'd do it once in a theorem prover
03:52:06 <wubba-lubba-lub-> Shouldn't specifying those laws be mandatory in, I dunno, the documentation of the typeclass?
03:52:11 <athan> maerwald: Imagine if we could do IO during constraint solving :|
03:52:32 <athan> class ShouldPass (forall x. Arbitrary x => x) ...
03:52:42 <athan> er...
03:52:48 <athan> sorry it's really late
03:53:05 <geekosaur> and, practically, we do expect laws to be documented. but not every typeclass has laws. (See for example Data.Default)
03:53:28 <maerwald> does doctest work with instances? I never tried
03:53:35 <geekosaur> so it can't be part of the general typeclass "contract"
03:54:48 <wubba-lubba-lub-> And if I instance a class in a way that doesn't respect those laws, what can I expect?
03:54:59 <maerwald> people getting angry at you
03:55:05 <wubba-lubba-lub-> ... that's it?
03:55:11 <maerwald> :o
03:55:23 <wubba-lubba-lub-> I mean... what part would anger them?
03:55:34 <wubba-lubba-lub-> Composition etc. not working idiomatically?
03:55:45 <geekosaur> well, if anyone uses it expecting it to obey the stated laws, they will get unpleasant surprises
03:55:53 <bernalex> wubba-lubba-lub-: if you break mathematical laws you break the whole point.
03:56:02 <geekosaur> which can be anything from compile errors to incorrect results
03:56:15 <bernalex> you lose all inference and understanding, and there cannot be any free theorems.
03:56:28 <wubba-lubba-lub-> yeah I guess, I'm basically asking "why those laws", for say functor/applicative/monad
03:56:33 <wubba-lubba-lub-> that sounds interesting
03:56:42 <wubba-lubba-lub-> no free theorems?
03:57:25 <athan> Imagine if I _was_ O....
03:57:31 <bernalex> if you had an illegal Functor implementation, how would you derive Functor for free? you couldn't. the laws guarantee that there be but one lawful instance of the type (a -> b) -> f a -> f b.
03:57:36 * athan shuts up
03:57:59 <geekosaur> one thing that someone can do is use the laws in a way a compiler can't (even if it knows about them) to define optimizations (e.g. RULES pragmas in ghc). if your instance is not law abiding, those RULES will break, sometimes in hard-to-diagnose ways
03:58:01 <wubba-lubba-lub-> Oh.
03:58:23 <geekosaur> (well, usually in hard-to-diagnose ways, because RULES are not visible to the programmer using your instance)
03:59:11 <wubba-lubba-lub-> Is that what all laws are doing (and only what they are doing), constraining each signature to a single definition?
03:59:15 <athan> What's an example of Contravariant data that _isn't_ a parameter to a function?
04:00:10 <bernalex> wubba-lubba-lub-: laws do many things. they are every bit a part of the definition of what e.g. a Functor is, as its associated types and code.
04:00:43 <bernalex> wubba-lubba-lub-: for e.g. Functor, the laws say that fmap f x does not change the structure of the Functor, only its elements.
04:01:34 <wubba-lubba-lub-> "structure of Functor"? A little more help, please?
04:01:52 <wubba-lubba-lub-> I really appreciate this, btw, thanks all.
04:02:13 <bernalex> wubba-lubba-lub-: if you e.g. have a list [1, 2, 3], doing (+1) <$> [1, 2, 3] is guaranteed to not change the context (i.e. that it's in a list). it *only* operates on the elements.
04:02:43 <wubba-lubba-lub-> Isn't that guaranteed by the type of fmap?
04:03:27 <wubba-lubba-lub-> also, should I be taking this to #haskell-beginners?
04:03:43 <shachaf> Beginner questions are fine in this channel.
04:03:46 <bernalex> sorry - I've got to run!
04:03:55 <wubba-lubba-lub-> damn it
04:04:00 <bernalex> but, yes, #haskell is the place for all questions -- introductionary as well
04:04:01 <shachaf> #haskell-beginners is just some channel someone made. It's not related to this channel.
04:04:10 <bernalex> someone will probably pick up the ball and explain laws better than me, don't worry
04:04:16 <bernalex> also maybe have a look at https://wiki.haskell.org/Typeclassopedia
04:04:19 <wubba-lubba-lub-> awesome
04:04:23 <geekosaur> it's easy to guarantee from the type for lists. tree structures are harder, for example.
04:04:25 <bernalex> but I got to run shopping, sorry
04:04:35 <shachaf> geekosaur: What's easy to guarantee?
04:04:44 <geekosaur> and this is a relevant example because you'll break a tree if you cjhange its ordering
04:04:53 <shachaf> A function with the type (a -> b) -> [a] -> [b] can certainly be something other than map.
04:04:55 <wubba-lubba-lub-> that "context" doesn't change
04:04:57 <wubba-lubba-lub-> I think
04:05:32 <wubba-lubba-lub-> I'm really unsure what break'
04:05:45 <wubba-lubba-lub-> I'm really unsure what 'break'/'structure'/
04:05:52 <wubba-lubba-lub-> ... context' mean
04:05:59 <geekosaur> shachaf: that you don;t change tis structure. mostly because lists don't have much structure to begin with
04:07:08 <wubba-lubba-lub-> Do you mean the skeleton of the ADT, when you say structure?
04:08:41 <shachaf> wubba-lubba-lub-: The question "why do we use some particular choice of laws" doesn't exactly have an easy mechanical answer.
04:09:04 <wubba-lubba-lub-> oh, it's one of those "experience" things, is it?
04:09:08 <shachaf> You use type classes when you have a lot of things that are similar in some ways. Just like other abstractions.
04:09:13 * geekosaur is supposed to be asleep (sinuses had other ideas), not the best time to be trying to explain this stuff.. or for that matter to keep it straight for himself. :/
04:09:17 <wubba-lubba-lub-> oh, it's one of those "experience" things, is it?
04:09:40 <wubba-lubba-lub-> or like asking about why a particular mathematical field is axiomatized the way it is?
04:09:54 <wubba-lubba-lub-> or like asking about why a particular mathematical field is axiomatized the way it is?
04:10:04 <geekosaur> sometimes. and sometimes it's that people are far better at this kind of abstraction than computers are, so the computer can't help you much if you get it wrong
04:10:13 <shachaf> You're posting every message twice.
04:10:26 <shachaf> Given a bunch of similar things, the decision of how to best capture their similarity in a way that generalizes well isn't necessarily obvious.
04:10:38 <wubba-lubba-lub-> shachaf: I am? Doesn't look that way from my end
04:10:41 <geekosaur> and it certainly can't do it for you
04:11:50 <shachaf> For example, if you want to generalize the way numbers behave, you might choose groups or monoids or rings or all sorts of other structures.
04:12:08 <shachaf> Most options you have are so ugly or arbitrary that no one ever talks about them.
04:12:23 <m0rphism> If I use a custom 'makeLenses' which creates for field 'f' a lens called 'fL' and only use 'fL' I get a defined but not used error for 'f'. I guess this is why the original makeLenses turns '_f' into 'f' because the '_' prefix avoids such warnings. However I'm not sure why this warning pops up in the first place: the identifier is clearly used in the derived code defining the lens for 'f'. Is this because of
04:12:26 <m0rphism> Template Haskell?
04:13:01 <shachaf> Anyway, in the case of Functor and Monad and so on, the definition and laws came way before Haskell.
04:13:57 <shachaf> And the style of homomorphism that Functor defines (F1 = 1, F(f.g)=Ff.Fg) is pretty standard in all sorts of maths. So that's one answer.
04:15:02 <shachaf> m0rphism: I don't know that much about the lens TH, but you might look at -ddump-deriv to confirm that the code you think is actually being generated.
04:15:08 <wubba-lubba-lub-> will reading category theory help?
04:15:21 <shachaf> (Also, exporting a lens but not the selector is kind of odd.)
04:15:24 <shachaf> Help with what?
04:15:48 <wubba-lubba-lub-> understanding how people came up with those laws, or bothered with them at all.
04:15:58 <wubba-lubba-lub-> s/bothered/are bothered
04:16:05 <geekosaur> wubba-lubba-lub-, not really. this is more basic. if anything, category theory would not make sense without these (and other) basics
04:16:12 <wubba-lubba-lub-> oh
04:16:18 <shachaf> If you want to know the origin of Functor and Monad and so on, sure.
04:16:25 <wubba-lubba-lub-> so what is "this" that I should be reading first?
04:16:32 <shachaf> But it's probably not that useful for most things you would do in Haskell.
04:16:41 <geekosaur> (it's hard enough to make sense of even *with* the basics; it's close to the limit of the kind of abstraction people can deal with)
04:16:43 <m0rphism> shachaf: I'm exporting neither the lens nor the selector. The data type is used inside the module only. But good idea looking at the derived code, I should probably use -ddump-splices instead, right?
04:17:18 <shachaf> m0rphism: Er, right, that's the one I meant.
04:17:39 <shachaf> I was thinking of the autogenerated code for a very particular traversal. :-)
04:18:35 <m0rphism> shachaf: been there ;-)
04:20:33 <geekosaur> wubba-lubba-lub-, I'm tempted to say that for your questions, the best thing to read is not the math itself but the history of math, in particular about the ill-fated _Principia Mathematica_. and that will tell you where to dig deeper if you want/need to.
04:20:54 <geekosaur> But, as far as the point of laws: when you are describing an abstraction, you need to specify when that abstraction is valid. The laws describe that
04:21:26 <wubba-lubba-lub-> geekosaur: you mean Godel's theorems?
04:22:18 <geekosaur> no, that's just where things fell over. I am pointing more at the reason mathematicians were working on _PM_ in the first place
04:23:32 <geekosaur> i.e. what laws do for you, as opposed to where laws can't help you
04:24:39 <m0rphism> shachaf: Ha, you were right! :D
04:24:49 <shachaf> About whom?
04:25:21 <m0rphism> shachaf: The derived code for the lenses doesn't use the selector at all, it pattern matches directly.
04:25:22 <wubba-lubba-lub-> geekosaur: any references/links in particular? Or just PM itself? 
04:25:29 <geekosaur> but, back to the laws themselves: we don't have the compiler verify the laws because that's getting into the kind of abstraction people can do but computers can't do very well, and even when they can you aren't gaining anything from their doing it. so you might use a proof checker once to validate your reasoning, but there's no point to having it around afterward
04:25:53 <m0rphism> shachaf: Hence, the warning is justified from the compiler's perspective.
04:26:10 <geekosaur> wubba-lubba-lub-, again, not _PM_ itself, but the history of _PM_. Meta-mathematics, or why mathematicians were working on _PM_
04:26:25 <shachaf> geekosaur: That reasoning sounds a bit fishy to me.
04:26:29 <geekosaur> but I'm unsure you'd gain much from it
04:26:35 <wubba-lubba-lub-> oh
04:26:36 <m0rphism> shachaf: But on closer look maybe it makes sense that template haskell usages of an identifier count as regular usages
04:27:18 <geekosaur> and I suspect shachaf if having the same qualms I am... I think it can be useful, but I'm not sure it can be helpful without the right background (or maybe the right approach...)
04:27:39 <geekosaur> but then that's why I started with "I'm tempted to say that..." when I brought it up
04:27:40 <shachaf> I mean "having the comptuer verify laws isn't worth it".
04:27:52 <geekosaur> shachaf, it's not worth doing on every compi;le
04:28:18 <shachaf> You could use similar reasoning to say, I don't know, having the computer prove that you don't dereference null pointers isn't worth it.
04:28:23 <geekosaur> it's worth doing when you are defining it the first time, but I don't think you then need to have that be part of the typeclas definition
04:28:28 <geekosaur> except as documentation
04:28:55 <shachaf> Is it worth having the compiler check types every time?
04:29:37 <geekosaur> I think ther analogy I want here is why ghc does not infer rank-2 types even though it's decidable?
04:30:45 <shachaf> I think you can only do "whole-program inference" for rank-2 types.
04:30:54 <shachaf> Which is a much better reason not to do it.
04:31:14 <shachaf> Anyway, I thought you were talking about checking, not inference.
04:31:47 <m0rphism> shachaf: Oh, I almost forgot to be polite: thanks for helping me :)
04:32:23 <shachaf> m0rphism: I wonder whether the TH *should* use the selectors.
04:32:40 <shachaf> I bet glguy has thought about it.
04:33:50 <geekosaur> in any case, I am thinking of the abstraction. my feeling is that this is less like typechecking and more like verifying my addition by deriving it from ZFC on the fly
04:35:13 <m0rphism> shachaf: me, too. I think I'm going to file an issue at the lens github project.
04:35:33 <shachaf> I'm not sure why you see verifying laws as fundamentally different from type-checking.
04:36:21 <shachaf> A type signature restricts the possible implementations that a function like map :: (a -> b) -> [a] -> [b] can have.
04:36:34 <shachaf> A law also restricts them.
04:37:17 <shachaf> Sometimes you can be clever and express "laws" by changing the type (e.g. represent two lists of the same length with [(a,b)] instead of ([a],[b])).
04:38:08 <shachaf> If you're saying that a compiler should only check the Functor laws when you compile a module that contains the instance, I agree with that. :-)
04:38:32 <shachaf> And if you want to put the proof in a separate module and compile it less often, as an optimization or something, I guess that's OK?
04:38:51 <geekosaur> that plus it seems to me that not all laws can be verified without extra machinery that wouldn't be of much use for anything else
04:52:40 * hackagebot xlsx 0.2.2.2 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.2.2 (KirillZaborsky)
05:42:42 * hackagebot merge-bash-history 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/merge-bash-history-0.1.0.0 (JiriMarsicek)
05:43:37 <reckbo> hi all, is there anyone here who can explain to me why '3 + Sum 3' typechecks?
05:44:30 <lyxia> reckbo: a literal number is polymorphic
05:44:57 <reckbo> even for Sum and Product types?
05:45:29 <KaneTW> :t Sum
05:45:30 <lambdabot> a -> Sum a
05:46:08 <KaneTW> Sum is a newtype for Nums with a Monoid instance Num a => Monoid (Sum a)
05:46:16 <KaneTW> it also has a Num a => Num (Sum a) instance
05:46:30 <lyxia> "3" is actually "fromInteger 3"
05:46:41 <KaneTW> so 3 + Sum 3 :: Num a => Sum a
05:49:00 <reckbo> so 'fromInteger' is implicitly there?
06:35:45 <saurabhnanda> does anyone know if Yesod.Static supports broken downloads? https://hackage.haskell.org/package/yesod-static-1.5.0.3/docs/Yesod-Static.html
06:37:18 <coppro> it doesn't appear to from a quick source inspection
06:40:54 <saurabhnanda> coppro: which file did you look at?
06:43:33 <idev> for haskell -> json, I know there's aeson
06:43:43 <idev> however, if I just want to write raw json, is there a hskell lib to help me with that?
06:43:54 <idev> (I need the json my haskell output to satisfy a particular strcture, instead of what aeson encodes as output)
06:46:30 <saurabhnanda> idev: say what?
06:46:39 <saurabhnanda> idev: what do you mean by "particular structure"?
06:46:49 <saurabhnanda> idev: do you mean a particular pretty-printed output?
06:48:07 <coppro> saurabhnanda: the one you linked
06:48:35 <saurabhnanda> coppro: I meant which file in the source code. Actually, let it be. I just cloned the repo.
06:49:46 <idev> saurabhnanda: the js library I am using wants json in a particular format
06:50:01 <idev> saurabhnanda: so I need aeson to output that format for me or to instead use something that lets me 'control' the format
06:50:09 <saurabhnanda> idev: what do you mean by particular JSON format? JSON is a standard which has one canonical "format
06:50:33 <saurabhnanda> any example of your "format"?
06:50:39 <idev> saurabhnanda: it's using json to encode particular nested data types
06:50:51 <idev> saurabhnanda: so I need my aeson to output json that are valid instances of that nested data type
06:51:21 <saurabhnanda> idev: I have a hunch all you need is to over-ride the toJSON method of the approriate type
06:51:30 <saurabhnanda> some examples would help clarify
06:51:43 <idev> saurabhnanda: looking at https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:ToJSON I think you're right
06:51:49 <idev> saurabhnanda: looking at https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-Types.html#t:ToJSON , you're right
06:52:11 <saurabhnanda> idev: great
07:02:38 <tippenein> what would I use to get a string representation of the bytes of a file?
07:03:10 <tippenein> like, given any .mp4 it would return a unique hash of the contents
07:05:35 <tippenein> I suppose an MD5 hash would be sufficient
07:08:58 <Lando> Hello! I have a question. The HList library is well known in the community, I guess. I have some doubts about the modern implementaton
07:09:33 <Lando> They are defining heterogeneous lists as a data family now 
07:09:44 <Lando> instead of a GADT
07:11:00 <Lando> I see some disadvantages, if I use the GADT definition I can define some recursive functions by pattern matching
07:11:42 <Lando> with the type family definition you have to use type classes everywhere
07:12:23 <Lando> So, what are the advantages of the Type family way? why do they do it that way?
07:13:26 <Lando> https://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-HList.html
07:13:53 <Lando> they explain something there, but I don't understand
07:14:36 <nmdanny> can someone explain me why the following code doesn't compile under GHC 8:
07:14:41 <lpaste> nmdanny pasted “issue with DuplicateRecordFields on GHC 8” at http://lpaste.net/168008
07:17:50 <Lando> type family HApp (l::[*]) (m::[*]) :: [*]
07:17:50 <Lando> type instance HApp '[] m       = m
07:17:50 <Lando> type instance HApp (x ': xs) m = x ': HApp xs m 
07:17:50 <Lando> lAppend :: HList l -> HList m -> HList (HApp l m)
07:17:50 <Lando> lAppend HNil m         = m
07:17:51 <Lando> lAppend (HCons x xs) m = HCons x (lAppend xs m) 
07:18:16 <Lando> this compiles only with the gadt definition
07:18:22 <Lando> for example
07:19:03 <Lando> so I do not understand when they say "The data family version (currently used) gives the same type constructor HList :: [*] -> * as the GADT, while pattern matching behaves like the algebraic data type."
07:19:09 <thomie_> nmdanny: see https://ghc.haskell.org/trac/ghc/ticket/11343
07:19:29 <thomie_> nmdanny: in short, use `name (a :: Person)`
07:20:22 <nmdanny> ok, but it seems redundant seeing as from the `compare a b` for instance Ord Person, it's clear that `a` and `b` are of type `Person`
07:35:31 <nmdanny> is it possible to provide several reader instances for a certain type, that are parameterized over different types?
07:37:38 <nmdanny> for example say I have :    Data Db = Db { cars :: Seq Car, people :: Seq Person },   Instance ReaderT (Seq Car) m a where ....   ,  Instance ReaderT (Seq Person) m a where ...
07:45:51 <hexagoxel> nmdanny: no; mtl-MonadReader includes the functional dependency m -> r which disallows such instances.
07:48:38 <shirt> How do I split a Text value into a pair (Text, Text), where the split location is the location of the 5th occurrence of the character "A"?
07:52:17 <jophish> Before I reinvent it, is there a library for applying updates to textual data. Taking the original string, some text to update, and the location of the span in the original text to replace
07:52:31 <jophish> a little like 'refact' and 'apply-refact' but not haskell only
07:57:46 * hackagebot slug 0.1.4 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.4 (mrkkrp)
08:07:52 <CalabiYau> pl \x y -> x y
08:23:14 <merijn> Any recommendations for SQLite bindings/libraries?
08:29:04 <tippenein> can I coerce a bytestring to an alphanumeric character set?
08:30:59 <ph88> hey there
08:32:03 <ph88> anyone know if there is an equivalent function in megaparsec for attoparsec's match?  http://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-Text.html
08:35:49 <merijn> tippenein: Note that ByteString has nothing to do with String so your question is a bit nonsensical
08:36:04 <merijn> tippenein: It should really just be Bytes, the name is just historical accident
08:37:33 <ggVGc> String is in itself a pretty weird term
08:39:45 <merijn> No one's used SQLite from haskell? >.>
08:40:28 <hpc_> i expect people have
08:40:33 <hpc_> nobody goes bragging about it though
08:40:35 <jxv> merijn, only used sqlite-simple and persistent
08:42:04 <ggVGc> merijn: I started thinking about a project last week that I was gonna use haskell and sqlite for
08:42:08 <ggVGc> does that count?
08:42:13 <merijn> hpc: Well, they don't have to, but I wanted recommendations for bindings/libs to access it :)
08:42:26 <merijn> ggVGc: No, because I'm at that stage too :p
08:42:55 <ggVGc> sqlite-simple looks okay
08:42:58 <ggVGc> judging from hackage
08:43:16 <ggVGc> would be nice with type safe queries
08:43:21 <ggVGc> is there something like that for haskell?
08:43:28 <jxv> persistent
08:43:31 <ggVGc> cool
08:43:43 <imalsogreg> tippenein: If the bytes are UTF-8 encoded characters, try Data.Text.Encoding.decodeUtf8
08:44:12 <merijn> Last I looked at persistent it seemed like a lot of boilerplate
08:44:42 <imalsogreg> ggVGc: My favorite thing here is groundhog.
08:46:14 <ph88> is there someone who can mentor me with haskell stuff ?
08:46:27 <ggVGc> ph88: this channel in general
08:46:32 <ggVGc> by you asking questions when you have problems
08:46:39 <ggVGc> community is the best
08:47:04 <ggVGc> people here often have a lot of patience, if you behave in a reasonable way
08:47:14 <ggVGc> no matter how "stupid" questions you have
08:47:33 <merijn> ggVGc: Well...if you come asking which key is the enter key I'm giving up... ;)
08:47:35 <ggVGc> there are some very knowledgeble and patient people in here
08:47:41 <ggVGc> merijn: which one is it?
08:47:49 <ggVGc> Been looking for the any key a long time
08:48:09 <ph88> ok but i was just getting comfy with attoparsec, but now i want to use megaparsec and everything is different. Dont know where to start
08:48:19 <ggVGc> ph88: one little step at a time
08:48:27 <merijn> ph88: Everything is different? Such as?
08:49:01 <ph88> functions that are available in attoparsec but not in megaparsec
08:49:36 <ph88> also attoparsec return  Parser Text  and megaparsec  m a
08:50:36 <ggVGc> ph88: take a simple example that you know how to do in attoparsec, paste the code to a paste site, link us in here, and someone can help you start writing it in megaparsec
08:52:45 <ph88> https://paste.fedoraproject.org/384647/86993514/
08:57:25 <ggVGc> I'd help but I've never used megaparsec.. Hopefully someone comes along who knows
08:57:31 <ggVGc> just hang around :)
09:00:21 <merijn> megaparsec is "basically parsec" so something like that should "just work" with the right imports
09:01:33 <merijn> ph88: What did you try and why didn't it work?
09:04:07 <ph88> merijn, didn't try anything because don't know where to start
09:04:55 <ph88> hhmm ill start with the tutorial
09:04:57 <merijn> ph88: Most of the stuff in Text.Megaparsec.Combinator is basically the same as the stuff in Attoparsec
09:07:38 <ph88> this is strange, the string function gives back a string even though it's in the Text package  https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html
09:08:01 <ph88> before with attoparsec if i was using the string function from the attoparsec Text package it yield a Text not a String
09:10:40 <merijn> Yeah, it's one of my main annoyances with (mega)parsec
09:10:49 <merijn> ph88: You can just
09:10:51 <merijn> :t fmap T.pack
09:10:53 <lambdabot>     Not in scope: ‘T.pack’
09:10:53 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
09:10:56 <merijn> wut
09:11:01 <merijn> :t fmap Data.Text.pack
09:11:02 <lambdabot> Functor f => f String -> f Data.Text.Internal.Text
09:11:15 <monochrom> but it has overhead
09:11:19 <merijn> Sure
09:11:31 <merijn> But if you want speed you want attoparsec anyway :)
09:11:54 <monochrom> "string" simply calls "tokens", and "tokens" is list-based.
09:12:46 <sm> https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html#v:string does seem fixed to Strings though
09:13:09 <merijn> sm: It is
09:13:33 <sm> maybe ph88 just needs a copy with a looser type signature ?
09:13:34 <monochrom> yeah, we're lamenting that it does
09:14:31 <merijn> sm: Won't work, it'll go through String anyway
09:14:41 <monochrom> no, we need a copy that rewrites "tokens" from scratch
09:14:41 <ph88> why does it go through String ?
09:14:41 <ggVGc> ph88: just out of curiosity, why are you going from attoparsec to megaparsec?
09:14:42 <merijn> If you want to directly blit Text you want attoparsec
09:14:51 <sm> ok, gotcha. https://github.com/mrkkrp/megaparsec/issues/106 seems to be about this
09:14:51 <merijn> ph88: Because that's how it was written
09:15:14 <monochrom> because "string = tokens (==)" simply.
09:15:24 <monochrom> and look at tokens, it's []-based
09:15:25 <ph88> ggVGc, because attoparsec missing some features, like get position
09:16:28 <ggVGc> alright
09:16:52 <ggVGc> I ask because usually attoparsec and other (mega)parsec are used for pretty different use cases
09:17:33 <ggVGc> afaik attoparsec is usually for parsing network traffic and data formats etc. While megaparsec and parsec is for text parsers for compilers etc.
09:17:38 <ggVGc> at least that's my understanding
09:17:53 <ggVGc> so it sounds strange to me to switch between them
09:18:08 <ggVGc> what is your application?
09:18:18 <merijn> ggVGc: (mega)parsec is for when you care about error messages, attoparsec is for when you wanna be fast and don't care about error messages
09:18:43 <ggVGc> what about when I want to be fast and care about error messages1
09:18:44 <ggVGc> !
09:18:56 <merijn> ggVGc: Trifecta, maybe?
09:19:20 <ph88^> sorry got disconnected
09:19:20 <ggVGc> cool never heard of
09:19:28 <ph88^> last message: <ggVGc> alright
09:19:40 <sm> in that issue, mrkkrp suggests a fast specialised version of megaparsec is possible
09:19:51 <ph88^> can someone pastebin last 5min ?
09:20:00 <ggVGc> ph88^: I just asked what your application was, since I was wondering why you were switching parser library
09:20:03 <merijn> sm: Sure, just don't use any of the current code and rewrite it to be like attoparsec ;)
09:20:36 <sm> I assume he was thinking of something less drastic :)
09:20:53 <merijn> Not quite, you have to write new primitives for that
09:21:09 <sm> ph88: the channel is logged, see /topic
09:21:30 <ph88^> maybe i can make two parsers, one with megaparsec and one with attoparsec. Try attoparsec first if it fails fall-back to megaparsec ?
09:21:40 <merijn> ph88^: Why would you do that?
09:21:48 <sm> sure, why not
09:21:51 <merijn> Crap...
09:22:05 <merijn> That moment I realise I once again need to learn more linear algebra...
09:22:09 <ph88^> because attoparsec is faster, but once it encounters an error i need to do a lot more
09:22:21 <sm> double the maintenance, but it's an option
09:22:40 <ggVGc> merijn: a vector is just a point in the matrix of endo-angles
09:23:02 <merijn> ph88^: Does the speed actually matter?
09:23:15 <merijn> ph88^: How much data are you parsing? kilobytes? megabytes? gigabytes?
09:23:16 <ph88^> not now .. but i was just exploring for the future
09:23:25 <ph88^> handful of source files
09:23:32 <merijn> ph88^: The speed won't matter
09:23:34 <sm> megaparsec will be fine
09:23:35 <glguy> It might be interesting to write your parser using the 'parsers' library so you could run the same parser with two backends
09:23:38 <merijn> Source code is tiny
09:24:35 <ph88^> so i should use T.pack everywhere ?
09:25:07 <sm> yep, for now
09:25:21 <sm> maybe it won't be as many places as you think
09:25:36 <ph88^> oki
09:32:11 <ph88^> hello world example works now :)
09:32:40 <ph88^> how do i customize the error message and include the line + position on line  ?
09:32:57 <merijn> Is there a name for higher dimensional matrices? Or are those still just called matrices?
09:34:05 <hpc> they're still matrices
09:34:32 <hpc> to some extent, 'matrix' just means the type of operations you apply to it
09:34:43 <merijn> hpc: Apparently the word I was looking for is tensor
09:34:57 <hpc> ah, or that
09:35:09 <merijn> hpc: Well, matrix multiplication doesn't really work for 3 or higher dimensional matrices, doesn't it?
09:35:26 <hpc> "tensor" is one of those words that makes my brain nope out
09:35:37 <hpc> too much math of a kind i never really got good at
09:35:43 <merijn> hpc: Same here
09:36:05 <jophish> wtf, It seems I have to write the Show1 instance myself?!
09:36:41 <merijn> But I understand how matrix factorisation is used in recommender systems and had a sudden epiphany that my dataset actually has a third axis beyond "person + rated object"
09:36:51 <ph88^> i see some types here, not sure how to use them   https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html#g:5
09:37:27 <merijn> hpc: i.e. all objects are tagged with categories, which adds a third dimension and you could compute things like "how closely do objects actually belong to certain categories"
09:37:36 <monochrom> "hello world you have a parse error"? :)
09:38:42 <monochrom> if you say "array" you will have covered all finite dimensions
09:38:51 <ph88^> monochrom, that be fine for a start :P
09:39:03 <merijn> monochrom: Yes, but I also won't be able to google the math I need
09:39:13 <glguy> jophish: Usually you can write it in terms of the generated Show instance
09:39:14 <monochrom> ah
09:39:36 <merijn> monochrom: I don't think I will find things on "generalising matrix factorisation to tensor factorisation" using the word "array" instead of matrix/tensor :p
09:42:33 <jophish> glguy: that doesn't seem to be that easy with the explicit dictionary passing in base 4.9
09:42:42 <jophish> I have found a deriveShow1 though
09:50:14 <mvaenska1> cheers, i am trying to create a simple "if x != 2 then abort, else commence" control flow but seem to be able to not do it in main without defining a new function to check for that
09:51:26 <mvaenskae> i am checking for the correct number of arguments passed in (i don't care for their content for now) just what the length is and i seem to be unable to do that using a "case X of" structure (as i don't understand how it would apply there)
09:51:36 <joneshf-laptop> deriving `ToJSON` for a newtype seems to just give me the underlying value as a json value. Is there a simple way I might have missed to have it be an object where the key is the record accessor.
09:52:24 <joneshf-laptop> e.g. `newtype Foo = Foo {foo :: String} deriving (Generic, ToJSON)` will give me something like `"This is a string"`, but I'd like `{"foo": "This is a string"}`.
09:52:35 <S11001001> mvaenskae: you can put [...] as a pattern in your case-of
09:52:36 <joneshf-laptop> I mean, aside from hand writing the instance.
09:52:56 <merijn> mvaenskae: "main = do { numArgs <- length <$> getEnv; when (numArgs != 2) doStuff; }" ?
09:53:09 <merijn> mvaenskae: I might have the getEnv name wrong, but other than that...
09:53:12 <glguy> Don't forget /=
09:53:18 <merijn> oh, right
09:53:24 <S11001001> joneshf-laptop: maybe not deriving ToJSON but instead writing instance ToJSON Foo where (with no impl, letting SYB do the heavy lifting) might work?
09:53:28 <merijn> glguy: I blame doing C++ all week during work :p
09:53:39 <mvaenskae> /= ???
09:53:43 <mvaenskae> why a list difference?
09:53:44 <glguy> merijn: or maybe mvaenskae actually defined an != operator :)
09:54:00 <S11001001> joneshf-laptop: IOW I don't think GND will use a DefaultSignatures instance from the class definition
09:54:37 <S11001001> s/instance/default method/
09:55:22 <mvaenskae> i will test it out and then i would like to do at some point a rewrite of my program using a new idea to get to the same result :)
09:55:23 <merijn> mvaenskae: /= is not equals
09:55:27 <merijn> mvaenskae: != isn't haskell
09:55:28 <S11001001> mvaenskae: /= is ≠
09:55:36 <merijn> > 1 /= 2
09:55:38 <lambdabot>  True
09:55:40 <merijn> > 1 != 2
09:55:41 <lambdabot>      Not in scope: ‘!=’
09:55:41 <lambdabot>      Perhaps you meant one of these:
09:55:41 <lambdabot>        ‘!’ (imported from Data.Array),
09:55:46 <merijn> > 2 /= 2
09:55:47 <lambdabot>  False
09:56:17 <elucidata> is lambdabot a live isntance of ghci?
09:56:52 <joneshf-laptop> S11001001, seems to work. Thanks!
09:57:35 <merijn> elucidata: Approximately
09:57:46 <merijn> elucidata: It doesn't allow a bunch of stuff, like IO, for obvious reasons
09:57:59 <mvaenskae> how could i do my logic with a case X of structure? something like here https://wiki.haskell.org/Keywords#case.2C_of
09:58:59 <mvaenskae> that is just a question of learning the syntax a lot better :) e.g. if argLen were 2 i would like to assign the first element to some variable and then the second element to some other variable
09:59:09 <S11001001> mvaenskae: do args <- getEnv; case args of [arg1, arg2] -> success; _ -> failure
09:59:31 <S11001001> but you know, with newlines
09:59:47 <mvaenskae> S11001001: is there a way to have the expression contain multiple assignments?
10:00:04 <S11001001> mvaenskae: what does that mean?
10:00:35 <mvaenskae> e.g. instead of success i would like to assign arg1 and arg2 to filename and format
10:00:46 <mvaenskae> where filename and format are my internal variables
10:00:48 <S11001001> mvaenskae: so call them filename and format instead of arg1 and arg2
10:01:09 <S11001001> mvaenskae: you can't "assign" them; you could return them as a 2-tuple and put the whole expression to the right of an <-
10:01:20 <mvaenskae> oh, that would already assign them and have them alive for the scope of my complete main function?
10:06:01 <osager> could anyone take a look at this graph usage ? https://www.codewars.com/kata/reviews/54fffe96bae8cd7e3a000cbc/groups/550fea7ad7585364e6000f48
10:06:18 <osager> i dont quite understand
10:06:33 <osager> he first construct the edges
10:06:40 <glguy> You'll have to post that somewhere, your link requires login
10:06:50 <osager> glguy, sorry
10:06:57 <osager> i will paste it on hpaste
10:07:31 <osager> http://lpaste.net/168012
10:08:53 <osager> so what is topSort ? topological sort
10:09:10 <osager> anyway, this is not quite related to haskell
10:09:52 <monochrom> yes, topological sort
10:11:09 <tomleb_> Hey guys, I just installed stack, and ran stack setup, and now I get a libtinfo error.
10:11:24 <mvaenskae> main = do { argv <- getArgs; let argc <- length argv; when (argc /= 2) { error "Invalid number of arguments" } let file = head argv; ... } <-- i get an error in 'when'; Not in scope: 'when'
10:11:53 <glguy> tomleb_: You can paste the error to lpaste.net
10:12:15 <geekosaur> @index when
10:12:15 <lambdabot> Control.Monad
10:12:19 <osager> tomleb_, i used to get that too. i remember it's a lib version problem. you need some symbolic link
10:12:34 <tomleb_> yeah I think it is
10:13:11 <osager> tomleb_, 
10:13:11 <osager> locate libtinfo.so
10:13:11 <osager> sudo ln -s /path/to/libtinfo.so /path/to/libtinfo.so.5 
10:13:13 <tomleb_> pacaur -S libtinfo did it I think
10:13:20 <tomleb_> which probably is the same thing
10:14:00 <glguy> osager is guessing that you had the wrong version, but if your command fixed the problem, then the problem was that you didn't have any version at all
10:25:07 <tsahyt> I've been wondering, what are comonads actually good for? Are there some toy examples for what they might be useful? Monads have started to make sense to me intuitively after just using them for a while, so I thought seeing some examples for how and why to use comonads I might develop some intuition.
10:28:21 <EvanR> tsahyt: there are functor types you can put a comonad interface on for a small part of their functionality, namely the extract and duplicate. 
10:29:07 <EvanR> but you cant really make comonad-generic utility routines
10:29:17 <EvanR> so its kind of silly
10:29:52 <EvanR> without knowing the specific data type youre dealing with, all you can really do is what you can do with functor
10:30:00 <ertes> tsahyt: example: comonads offer a nice mapping interface for array-like structures
10:30:04 <ertes> EvanR: careful with assumptions
10:30:20 <EvanR> ?
10:30:46 <tsahyt> ertes: mapping interface as in map? But how does that differ from Functors?
10:31:28 <ertes> EvanR: the fixpoint stuff doesn't use any assumptions other than Comonad
10:31:39 <EvanR> "the fixpoint stuff" ?
10:31:45 <ertes> tsahyt: a comonadic map allows you to look at neighbour values, not just the value in question
10:32:04 <ertes> EvanR: cfix, wfix
10:32:10 <tsahyt> ertes: like a list zipper then?
10:32:23 <ertes> tsahyt: yeah, similar
10:32:28 <EvanR> ertes: is that the one other function in the package besides the class?
10:32:51 <ertes> EvanR: two, but yeah
10:32:59 <EvanR> right so anyway
10:33:10 <ertes> and of course all the combinator styles are defined once you have a comonad
10:33:21 <EvanR> the what?
10:33:21 <ertes> (=>>), (=>=), etc.
10:33:56 <ertes> in other words…
10:34:03 <ertes> <EvanR> so its kind of silly ⇐ this statement is kind of silly
10:34:08 <EvanR> well, ill stop trying to give important information
10:34:14 <EvanR> since its being ignored
10:34:50 <EvanR> =>> =>= none of this means anything for a generic comonad, you have to know the specific type. basically comonadic code is (basically) necessarily monomorphic
10:35:12 <EvanR> when you say "lets you look at neighbors" comonad doesnt actually allow you to do this
10:35:19 <EvanR> its the specific types structure
10:35:56 <EvanR> such as array mentioned earlier
10:35:57 <ertes> the same is true for monads
10:36:05 <ertes> is defining Monad instances silly now?
10:36:22 <EvanR> the same is not true of monads, because monads dont have the notion of "lets you look at neighbors" first of all
10:36:32 <Shou> Is there a generic way to generate Aeson Values from a datatype? Or rather, I'm getting erroneous JSON http://lpaste.net/168013 when nesting a datatype in another somehow.
10:36:40 <maerwald> EvanR: so it basically provides an abstraction that you cannot really use in an abstract way?
10:36:52 <ertes> but it has the dual notion of "let's produce structure", but producing any non-trivial structure requires more knowledge than Monad gives you
10:36:52 <EvanR> maerwald: right
10:37:02 <ertes> maerwald: wrong
10:37:05 <EvanR> yes and you can produce structure
10:37:17 <ertes> EvanR: you can't:  all you have is 'return'
10:37:19 <EvanR> monad lets you set up actions in different ways generically
10:37:25 <ertes> anything you produce is trivial
10:37:37 <ertes> unless you use assumptions other than "monad"
10:37:42 <EvanR> no, Control.Monad has a lot of tools in it
10:38:01 <ertes> Control.Comonad has tools, too
10:38:05 <EvanR> not really
10:38:06 <ertes> but that's a different point
10:38:22 <ertes> Comonad and Monad on their own are both useless without type-specific knowledge
10:38:37 <EvanR> what... no
10:39:02 <ertes> but you can define generic functionality for both of them, even if it's something as simple as (=>=)
10:39:03 <EvanR> cale often brings up the polymorphic-in-any-monad pattern to do a form of free monad abstraction
10:39:36 <EvanR> the thing is that with only a Comonad constraint, you end up with something that might as well be a Functor constraint
10:40:34 <ertes> refutation: cfix, wfix, (=>=)
10:40:42 <EvanR> in the end Comonads end up being basically only for toy examples
10:41:00 <ertes> then how come i've used them productively for non-toys?
10:41:10 <EvanR> like what
10:41:15 <ertes> media processing
10:41:45 <EvanR> right, for specific data structures you can put the extract and duplicate on a couple of their combinators
10:42:00 <EvanR> and use that instead of using a specific one you named yourself
10:42:07 <EvanR> but its much more limited than e.g. monads
10:42:14 <ertes> yes, it's more limited
10:42:19 <ertes> but it's not useless
10:42:46 <ertes> even if Comonad alone is not that expressive, there are stronger constraints based on that
10:42:49 <EvanR> but youre not using any real abstraction here
10:43:00 <EvanR> you dont get anything out of it
10:43:39 <EvanR> its like the Pointed class
10:44:32 <ertes> we have much weaker classes that are much more popular
10:44:36 <ertes> like Default
10:44:41 <EvanR> Default is silly too
10:45:31 <ertes> but Comonad on its own, if anything, is at least an algebraic structure that i understand (from a programmer's view), and there are stronger abstractions built on top of it
10:46:37 <ertes> and again: you do get stuff from the library…  it's just not as worldshaking as the stuff you get from Monad
10:46:48 <EvanR> wfix ?
10:46:53 <ertes> nevertheless it's less code duplication and a common interface with useful laws
10:46:54 <ertes> no
10:46:57 <ertes> (=>=)
10:47:12 <ertes> 'duplicate' or 'extend', depending on the view
10:47:48 <wubalubadubdub> So I was thinking about this statement on sigfpe's blog - "We might want to work with a wide variety of mathematical 'containers' like tuples and sequences as well as more abstract objects. Can we generalise to all of these in one go?" - Is reasoning only through ADTs enough to generalize in one go?
10:48:12 <merijn> Hmmm, is there a way to combine the results of many different Axes in xml-conduit, or is it just a matter of separately applying each axis and combining the result?
10:48:31 <merijn> wubalubadubdub: Which blogpost?
10:48:49 <wubalubadubdub> http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html
10:49:25 <EvanR> i guess i was thinking of =>= and =<= as not essentially different from the extend operation
10:49:53 <merijn> wubalubadubdub: hmmm, I don't know how to answer that question :)
10:50:10 <ertes> EvanR: i would have to define those on my own…  and again and again for every comonad, especially in a comonad transformer stack (yes, there's that, too)
10:50:21 <ertes> EvanR: it's work
10:50:55 <EvanR> well when i tried to use comonads to do stuff i didnt feel like i was using the class for anything
10:51:17 <EvanR> i already had the extract operation named something else, and so extract = myExtract in the instance
10:51:26 <ertes> EvanR: you probably don't feel like doing that most of the time when you use something as strong as Monoid
10:51:45 <EvanR> however you can make generic code for monoids
10:51:55 <wubalubadubdub> merijn: darn
10:51:58 <ertes> EvanR: mconcat
10:52:15 <ertes> EvanR: times
10:52:17 <EvanR> no, in your library you can accept any monoid and it makes sense
10:52:37 <EvanR> but if you just accept any comonad then it doesnt get you anything
10:52:42 <EvanR> besides functor
10:52:56 <ertes> EvanR: actually it gets you 'extract'
10:53:30 <ertes> but beside that, you don't accept any comonad…  you accept any ComonadStore, ComonadEnv, etc.
10:53:32 <EvanR> but you cant construct the comonad in the first place to get anything
10:53:44 <EvanR> unlike monoid
10:53:51 <EvanR> or monad
10:53:54 <EvanR> or applicative
10:54:09 <ertes> comonads compose just like monad transformers, and that's genuinely useful, because now you can use comonadic effect classes
10:54:28 <ertes> there certainly aren't as many as for monads, but they are useful
10:54:41 <EvanR> coeffects?
10:54:51 <ertes> no idea what one would call them
10:54:58 <ertes> i just call them effects
10:56:41 <EvanR> a library that takes ComonadStore seems like it would at least be as "gutsy" as accepting a MonadReader
10:57:41 <ertes> i don't understand that
10:58:32 <EvanR> transformers dont say "common fabric of interfacing beween code" to me, if anything its "use them if you want but dont let anyone ever know"
10:58:38 <EvanR> but maybe comonad transformers are the opposite!
11:00:00 <ertes> to me it's just effect classes…  i don't have any intuitive interpretation
11:00:26 <ertes> i need something that allows 'ask' as well as 'peeks', so i require ComonadEnv and ComonadStore
11:01:24 <EvanR> ive felt very limited by the transformer interfaces, to the point that if i need to use them, i at least have a bunch of layers on top which make it actually useful
11:01:25 <Myrl-saki> I'm planning to use reflex again; this time for my personal webgape. Is there any good reason to dynamically create the whole DOM rather than have one HTML file and create DOM elements in certain places?
11:03:11 <merijn> Myrl-saki: You hate portability and people with JS disabled?
11:03:19 <merijn> That'd be a good reason :)
11:03:50 <maerwald> JS disabled... err
11:03:54 <ertes> EvanR: either it didn't fit your use case well, or you use the API the wrong way…  whatever it is, if you think that something is useless, consider whether it's your own bias or an actual defect before you tell people that something is silly
11:03:59 <Myrl-saki> merijn: lol
11:04:34 <EvanR> ertes: comonad is provably useless, transformers are just practically a bitch for exposing a library with
11:04:41 <ertes> Myrl-saki: one good reason to generate the DOM dynamically is to be lazy and just use reflex-dom's stuff =)
11:04:46 <maerwald> ertes: to me it was pretty clear that it's his opinion, what else would it be?
11:05:08 <maerwald> and yeah, transformers are annoying
11:05:35 <ertes> EvanR: i refuted that "provable" uselessness:  the fact that you define only 'extend' and get 'duplicate' and (=>=) for free is a refutation
11:05:55 <maerwald> EvanR: did you try 'freer' yet?
11:06:07 <Myrl-saki> ertes: I see.
11:06:28 <ertes> EvanR: i've also used CofreeT productively…  in fact both as a monad and as a comonad
11:06:38 <EvanR> ertes: what functions can you write with =>= without knowing anything about the type?
11:07:04 <ertes> EvanR: that's not the point…  i get (=>=) for free, that's the point
11:07:07 <EvanR> lol
11:07:08 <EvanR> ok
11:07:21 <EvanR> i get the operation, but i cant really use it for aynthing
11:07:38 <maerwald> ertes: did you consider the overhead you force on potential contributors for such a trivial thing? 
11:07:55 <maerwald> reading up on yet another abstraction
11:08:14 <ertes> EvanR: filter1 =>= filter2 =>= filter3  -- i can write that without having to define (=>=) first (and also give it some arbitrary name)
11:08:23 <ertes> and i'd need to define (=>=) for every stack i use
11:08:26 <EvanR> what is filter2 ?
11:08:56 <ertes> that doesn't matter…  i get one operation for free
11:09:09 <EvanR> if its polymorphic, you cant even write it
11:10:28 <EvanR> but youre right you do get one operation, which is a one line def over extract, which you also have to write yourself too
11:10:38 <ertes> EvanR: say that i'm using 5 different comonads…  you're basically suggesting that i come up with five different names as well as implementations for (=>=), along with the primitives 'extract' and 'extend'
11:10:49 <EvanR> its an entire half of category theory to get one operation
11:10:53 <ertes> EvanR: and those five comonads are really just recombinations of different transformers
11:11:02 <ertes> EvanR: sorry, but that *is* silly
11:11:26 <tsahyt> so I've now skimmed through a blog post on comonads and it mentions method notation
11:11:34 <tsahyt> is that actually implemented somewhere?
11:12:09 <EvanR> maerwald: no i dont know anything about freer
11:12:32 <nmdanny> Does there exist some kind of linter, something that shows types and various IDE-like tools for GHCJS, similar to GHC-Mod? (which unfortunately doesn't work with GHCJS)
11:14:21 <ertes> tsahyt: you should probably read multiple posts, and also you should write code to learn comonads
11:15:11 <EvanR> after writing code for 5 comonads, which have almost nothing in common, the question will be whats the point of the comonad class? and ertes will correctly point out you didnt have to define =>=
11:16:02 <ertes> EvanR: no, you're just not getting what i'm saying
11:16:04 * EvanR looks at the package deps for comonads
11:16:06 <Zemyla> EvanR: So you can comonad and conquer.
11:16:43 <EvanR> not that bad, contravariant, distributive, semigroups
11:17:00 <EvanR> surprised you dont need to install adjunctions
11:17:08 <ertes> EvanR: transformer stacks *need* a common interface anyway
11:17:40 <ertes> otherwise you're going to write an implementation of all the basic functions for every single combination of comonad transformers one might come up with
11:17:51 * hackagebot http-dispatch 0.5.0.1 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.5.0.1 (owainlewis)
11:18:13 <EvanR> i havent had that experience with non-co-monad transformers
11:18:35 <EvanR> im also not going to pretend any code i write will be polymorphic over any transformer
11:19:57 <ertes> EvanR: i'm tired of this discussion…  it saved a lot of time and effort for me, and i will continue to suggest people use it
11:20:01 <ertes> period
11:31:16 <osager> what's the use of ord ?
11:31:22 <osager> ord Char
11:31:35 <ertes> > ord 'A'
11:31:36 <lambdabot>  65
11:31:45 <osager> i've seen it used in topological graph search
11:32:09 <osager> to create directed edges
11:32:29 <osager> ok...i realized vetices are int
11:32:30 <osager> ok
12:12:53 * hackagebot freer 0.2.3.0 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.3.0 (alcabrera)
12:18:49 <jophish> Where is that 'opinionated' list of nice packages?
12:19:03 <hpc> cabal install acme-everything
12:19:19 <suppi> this? http://haskelliseasy.com/
12:19:52 <jophish> suppi: that might have been it, the page formatting has changed since I last looked
12:19:57 <jophish> thanks :)
12:20:18 <suppi> it's kinda looks the same, it might have been something else
12:20:20 <suppi> np
12:21:47 <EvanR> i didnt know my computer could produce that color of hot pink
12:22:30 <Phyx-> lol
12:22:57 <hpc> that website is a middle finger to calibrated monitors
12:23:32 <EvanR> yeah its different if i move up or down
12:23:34 <EvanR> trippy
12:24:34 <dmj`> this list is basically just http://hackage.haskell.org/user/BryanOSullivan
12:24:52 <dmj`> "haskell is easy... use bos's stuff"
12:25:26 <Phyx-> heh, though maintenance wise..
12:25:49 <hpc> maintainer for HTTP, that must be rough
12:25:58 <hpc> latest version 4000.3.3
12:26:10 <hpc> remember to follow the PVP people
12:27:15 <merijn> That says: "xml-conduit the usual caveats around streaming apply."
12:27:28 <merijn> I'm not quite sure what the "usual caveats around streaming" are supposed to be
12:28:05 <dmj`> merijn: you know... the usual ones
12:28:49 <dmj`> doesn't mention servant anywhere...
12:28:50 <EvanR> me neither
12:32:54 * hackagebot cndict 0.8.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.8.0 (DavidHimmelstrup)
12:55:46 <bluezone> eh this tutorial http://www.happylearnhaskelltutorial.com/ isn' tso great. I just like the pictures, keeps me from falling asleep hehe
12:56:54 <EvanR> lol
12:57:10 <EvanR> learn you a happy haskell
12:57:25 <maerwald> wow, even more silly than lyah?
12:57:32 <bluezone> yeahhhh 
12:57:42 <maerwald> achievement unlocked, I guess
12:57:54 * hackagebot fltkhs 0.4.0.9 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.9 (deech)
12:57:56 * hackagebot optparse-text 0.1.0.0 - Data.Text helpers for optparse-applicative  https://hackage.haskell.org/package/optparse-text-0.1.0.0 (passy)
12:57:57 <bluezone> I will move on from most silly to least silly
12:58:52 <bluezone> is there an official tutorial for haskell?
12:59:09 <EvanR> http://www.happylearnhaskelltutorial.com/1/haskell_love.png what... is haskell ?
12:59:20 <shachaf> Yes, at https://www.haskell.org/tutorial/
12:59:24 <bluezone> :D
12:59:41 <shachaf> Some people say it's too dense to be a good introduction, though.
12:59:44 <bluezone> argh from the year 2000
12:59:50 <bluezone> Is it ok?
13:00:37 <shachaf> It's probably fine. The important things haven't changed much.
13:01:06 <glguy> Were there computers back then??
13:01:51 <EvanR> i like the robot passed out after drinking a whole bottle of "pure theory"
13:01:53 <shachaf> Yes, but I think they mostly ran COBOL.
13:01:56 <bluezone> I was 6 years old we had windows 95 or some garbage hehe
13:02:45 <Phyx-> honestly, back in the day, was nice to be able to point to RWH on that question
13:04:16 <EvanR> on the subject of motivation, its interesting that many people were given an apple 2 or other ancient computer and "fascinated by their potential"... but so many people doing web programming now with a system seven million times more capable and are not
13:05:03 <shachaf> The second edition of Hutton's book will be released soon. The first edition is a bit out of date, but the new one will probably be a good way to learn Haskell.
13:05:25 <EvanR> this is the environment people are expected to learn haskell in today
13:06:21 <bluezone> I was working in web development for the past year, I quit two days ago
13:06:22 <Phyx-> EvanR: hah, i'm fascinated that smart phones exist, let alone work reliably..
13:06:34 <merijn> Phyx-: For some value of reliable
13:06:45 <bluezone> I did front-end javascript work, the applications would sometimes takes 1 full minute to load
13:06:59 <bluezone> Chrome would ask me if I wanted to kill the unresponsive page
13:07:00 <Phyx-> merijn: well, module weak signals
13:07:10 <merijn> Is there a lazy quick way to go from Text to Int (or whatever numeric type) or should I unpack to String and use read?
13:07:41 <shachaf> Data.Text.Read
13:08:24 <EvanR> :t decimal
13:08:25 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
13:08:29 <tsahyt> Has anyone had a look at http://haskellbook.com/ ? I'm occassionally getting questions about good textbooks for haskell and RWH is kinda outdated by now
13:09:52 <shachaf> I've had a look at it and it's very sloppy at best.
13:10:13 <merijn> shachaf: Thanks
13:10:25 <shachaf> And containing lots of actual wrong information and nonsense at worst.
13:10:39 <tsahyt> ah that's not good
13:10:59 <merijn> shachaf: Which chapter did you look at? Now I'm curious before I keep suggesting it
13:11:06 <EvanR> richard bird's haskell textbook is often recommended in here
13:11:28 <shachaf> I'm basing some of my information on early draft text that people sent me. Maybe it's gotten better since then, I don't know.
13:11:30 <tsahyt> EvanR: but it doesn't explain much of the ecosystem if I remember correctly
13:11:44 <EvanR> well that kind of transcends textbook economics
13:12:04 <tsahyt> EvanR: the great thing about RWH was that it handled many practical topics and demonstrated that haskell can be useful to write actual programs in
13:12:45 <EvanR> how to functionally program is sort of a topic you can write a book about, but not parser-library-of-the-week
13:12:58 <shachaf> merijn: E.g. the chapter on monads.
13:12:59 <shachaf> But even the sample PDF on their website is pretty sloppy.
13:13:35 <EvanR> tsahyt: and honestly some frameworks which are popular now, would be nice if there was something better, and there might be
13:13:47 <EvanR> and the book would then be in the way
13:14:27 <EvanR> and you really shouldnt need a book to use a library
13:15:07 <puregreen> EvanR: well, but if a book makes using a library easier, should I not write that book?
13:15:25 <EvanR> an entire book?
13:15:33 <tsahyt> there's a whole book on yesod after all
13:15:34 <EvanR> for something like yacc i can see
13:15:43 <puregreen> no, let's say a book is going to cover several libraries
13:15:46 <puregreen> would that be okay?
13:15:56 <dmj`> puregreen: that's more or less RWH
13:15:58 <EvanR> that would be interesting
13:16:24 <puregreen> okay, thanks, now I don't feel like my yet unwritten book would be entirely useless
13:16:25 <tsahyt> I'd actually like a book dissecting several libraries as examples for library design
13:16:40 <EvanR> but of all the libraries which are listed on haskelliseasy have documentation already
13:16:44 <tsahyt> covering things like designing and implementing DSLs for example
13:16:53 <EvanR> so if i bought a book like that, id like it would just list those libs
13:17:11 <EvanR> tsahyt: yeah that would be cool
13:18:01 <puregreen> EvanR: other than pipes, I've yet to see a library with good documentation, and actually I'm not that sure about pipes
13:18:14 <EvanR> really?
13:18:15 <bluezone> Are there good debugging tools for haskell?
13:18:33 <puregreen> libraries with 3 functions in them don't count
13:18:53 <tsahyt> bluezone: depends on what you're looking for. ghci has built in debugging capabilities
13:18:58 <hpc> bluezone: i have never seen a debugging tool i liked
13:19:14 <puregreen> libraries like containers don't count either because it's hard to see how its docs could be made particularly bad (other than including no docs at all)
13:19:15 <hpc> in any language
13:19:20 <bluezone> tsahyt: for example something with strength comparable to chrome devtools for javascript :)
13:19:37 <merijn> hpc: I have seen some, but yeah only marginally
13:19:50 <hpc> puregreen: i like Rasterific's docs
13:19:54 <EvanR> puregreen: specimen B https://downloads.haskell.org/~ghc/5.02.3/docs/set/finitemap.html
13:19:56 <dmj`> bluezone: you won't be debugging as much in haskell, as compared to say js/c#/python
13:20:07 <hpc> https://hackage.haskell.org/package/Rasterific-0.6.1.1/docs/Graphics-Rasterific.html
13:20:16 <merijn> dmj`: lolwut?
13:20:24 <merijn> It's just different kinds of debugging
13:20:26 <tsahyt> that's a bold statement
13:20:36 <EvanR> yeah haskell is never wrong, like HAL9000
13:20:46 <dmj`> merijn: I never like set breakpoints in my code like I had to do with visual studio and step through it
13:20:51 <tsahyt> I've found that just staring at the code until it tells me why it won't work helps most
13:21:04 <tsahyt> dmj`: I actually do that a lot for some things
13:21:08 <merijn> dmj`: I've spent countless time trying to debug parsers, odd crashes, etc.
13:21:25 <EvanR> * Exception: good luck
13:21:39 <tsahyt> -fbreak-on-exception and rerun with :trace in ghci
13:21:47 <bluezone> looks like we need to start a debugger project for haskell
13:22:31 <tsahyt> the main thing I'd need is to tell ghci to just evaluate the current expression and move on when I'm stepping through code
13:22:39 <tsahyt> instead of needlessly taking me for a ride through half the library
13:22:46 <EvanR> bluezone: there are many tools with different abilities to scope out the runtime environment
13:22:54 <tsahyt> I though that :force would help, but somehow it doesn't
13:22:56 <EvanR> would be nice to have them in a list somewhere
13:23:21 <quchen> merijn: Well, there's debugging as in running-a-debugger, and there's debugging as in eliminating bugs. The former is not very common in Haskell.
13:23:25 <bluezone> maybe we can just use haskellscript and use chrome devtools hehe
13:23:47 <tsahyt> quchen: then how do you diagnose bugs efficiently?
13:24:02 <merijn> tsahyt: Same way I do in C/C++
13:24:06 <merijn> tsahyt: Printf
13:24:11 <bluezone> lel
13:24:14 <EvanR> Debug.Trace
13:24:16 <quchen> Equational reasoning mostly, if that doesn't help trace it (aka printf)
13:24:34 <merijn> bluezone: I'm not even joking, my main tool for C++ debugging is printf
13:24:38 <quchen> And intuitional reasoning as well sometime ;-)
13:24:43 <quchen> s
13:24:57 <bluezone> merijn: yeah many people do it, I hate having to do that 
13:25:08 <EvanR> well theres no valgrind for haskell
13:25:10 <bluezone> maybe there is a tool that will just print every line for you
13:25:25 <tsahyt> I like using ghci for adhoc quickcheck properties
13:25:26 <merijn> bluezone: Most of the debuggers aren't very good at displaying C++ in a convenient way
13:25:36 <merijn> I used to use gdb with C a bit
13:25:49 <merijn> But with C++'s convoluted names I don't even bother
13:26:33 <EvanR> bluezone: the profiler allows you to get some representation of the context an exception occurs in
13:26:48 <dmj`> the gdb gui for debugging in emacs is *nice*
13:26:55 <bluezone> the compiler error message ?
13:27:21 <EvanR> compiler error messages are the best for debugging
13:27:37 <EvanR> but i assumed you meant during runtime
13:27:38 <merijn> dmj`: gdb upstream isn't merging the OSX patches, so I have to use lldb now anyway :\
13:28:41 <dmj`> merijn: that's no good :( 
13:28:44 <dmj`> http://www.inet.net.nz/~nickrob/gdb-ui.png <- gdb gui
13:28:52 <dmj`> for those interested
13:28:59 <bluezone> I don't know anymore, to be honest I need to get my hands dirty in haskell, I'm not a fan of reading for long periods of time
13:29:04 <merijn> dmj`: I don't use emacs either :p
13:29:11 <EvanR> bluezone: yep, switch to writing ;)
13:29:35 <dmj`> merijn: ah, you vim? 
13:30:06 <merijn> Yes. I can't even use notepad or similar anymore due to muscle memory >.>
13:30:28 <ggVGc> once I used vim
13:30:36 <ggVGc> then I spet 7 years setting it up
13:30:39 <maerwald> there's a gtk gui for gdb afair
13:30:39 <ggVGc> then I wrote one haskell program
13:30:44 <ggVGc> and that was my porogramming career
13:30:47 <EvanR> if any editor requires the mouse im out
13:30:53 <dmj`> merijn: :) there is evil-mode you know, never tried it personally
13:31:02 <merijn> ggVGc: See, that's why I only use a small set of not too obtrusive addons
13:31:19 <maerwald> ah, Nemiver it was
13:31:20 <ggVGc> merijn: I have written way too many vim plugins :(
13:31:26 <ggVGc> and I only still use 3 of them
13:31:26 <merijn> dmj`: Yes, but I haven't looked at it as switching would mean finding replacements for all the addons I use
13:31:28 <tsahyt> I ran :PluginUpdate in vim today. it took long enough to go get coffee in the meanwhile...
13:31:35 <tsahyt> I really need to clean my plugin list
13:31:45 <EvanR> bluezone: sorry, i doubt editor talk and gdb are going to be much help with debugging haskell
13:31:53 <ggVGc> I never update a plugin unless I have a problem
13:31:53 <merijn> dmj`: So even if it's perfectly vim compatible it's an extensive time investment replacing all the plugins in my environment
13:31:54 <ggVGc> ever
13:31:58 <tsahyt> bluezone: have you tried ghci's debugging capabilities?
13:31:58 <ggVGc> but mostly I write my own...
13:32:11 <jophish> Does anyone know a function which I can give a Text and a (Text, Pos, Pos) and it'll give me the first Text with the second Text spliced in between Pos and Pos?
13:32:27 <bluezone> no I haven't written more than 5 lines of haskell so far. I am just curious :)
13:32:35 <ggVGc> I hope I never have to debug haskell. I wouldn't know where to start
13:32:40 <ggVGc> I've only used the heap profiler
13:32:54 <ggVGc> but apparetly ghc 8 has stack traces
13:33:00 <dmj`> merijn: yea, that's tough. A good editor is one that gets out of your way. 
13:33:06 <EvanR> make sure not to put undefined in any code that has a chance of running, thats a start
13:33:15 <tsahyt> ggVGc: I've spent all of thursday and friday profiling and optimizing. it's really no worse than in any other language. at least the compiler screams at you when a change messes up something obvious
13:33:20 <ggVGc> EvanR: I never run any of my code, so that should be fine
13:33:24 <EvanR> lol
13:33:41 <merijn> dmj`: Stuff like file search, syntax highlighting, error checking. I'm sure emacs can do all that, but it'd probably take weeks to find replacements and configure everything
13:34:04 <ggVGc> I think 10 years programming and counting is too late in my career to start investing in another text editor
13:34:26 <EvanR> its really good to be able to continually increase your editor fu
13:34:46 <tsahyt> vim has endless possibilities for that
13:34:52 <EvanR> because since everything sucks, stopping will leave you stuck
13:34:54 <tsahyt> I'm sure that emacs does too
13:35:18 <EvanR> theres guides on how to get in the habit of continually increasing your editor fu
13:36:44 <dmj`> merijn: you may be pleasantly surprised, stock emacs has file search (albeit not fuzzy), haskell-mode would handle syntax highlighting, errors that popup in the ghci buffer can be navigated to directly, by just pressing enter on them. I really only use vanilla emacs + yasnippet. For managing git its nice too. Not trying to be a salesman here :) 
13:36:51 <jmcarthur> ggVGc: Not true at all. I have learned both vim and emacs, and it was worth it to me (I now use emacs with evil-mode).
13:37:14 <merijn> dmj`: You're assuming that I'd be happy with the standard colour scheme
13:37:28 <ggVGc> jmcarthur: yeah, I've been meanign to get into emacs with evil, but i can't find the space in my life for it
13:37:31 <ggVGc> so I don't think it'll happen
13:37:41 <ggVGc> I'd rather write software during te computer time I have
13:37:43 <ggVGc> or make music
13:37:59 <dmj`> merijn: haha, well that makes two of us :)
13:38:24 <dmj`> (load-theme 'tango-dark) ;;theme
13:38:24 <merijn> dmj`: And when I said file search I meant fuzzy search, of course
13:38:38 <jmcarthur> Spacemacs is a good way to jump into emacs without having to spend a ton of time configuring things.
13:39:01 <merijn> jmcarthur: Doesn't run in the terminal, no go
13:39:01 <maerwald> jmcarthur: that's not true from my experience
13:39:06 <jmcarthur> merijn: It does.
13:39:17 <jmcarthur> maerwald: Why not?
13:39:33 <dmj`> merijn: so I cheat and use 'ag' "the silver search", optimized for speed, the results shown in the buffer can be hopped to directly. Use this *all the time* when navigating ghcjs-dom's crazy module hierarchy
13:39:38 <maerwald> because I still ended up configuring a LOT of stuff and a LOT of stuff did not work and needed hacks and workarounds
13:39:38 <dmj`> searcher*
13:39:55 <merijn> jmcarthur: Anyway, spacemacs, to me, always seemed in the same category as "Oh My Zshell" being the "you don't have to do anything" setup
13:40:08 <merijn> dmj`: Oh, I didn't meant for grepping stuff, I use ag for that too
13:40:26 <jmcarthur> maerwald: Was it your first emacs experience? I wonder if maybe you don't realize what Spacemacs saved you...
13:40:26 <merijn> dmj`: I mean fuzzy file opening as in, type 3 letters open a file 5 levels deep in a hierarchy
13:40:33 <maerwald> well, spacemacs default config at least is not as dangerous (as in: repititive strain injury) as the stock emacs config
13:40:40 <maerwald> that's a plus, but other than that, it's a mess too
13:40:56 <dmj`> merijn: ah, for that I use fiplr, https://github.com/grizzl/fiplr
13:41:11 <dmj`> merijn: I think others use 'helm', but that's a big investment to learn from what I gather
13:41:13 <maerwald> jmcarthur: I don't really see how that is relevant
13:41:18 <merijn> And by "same category as Oh My Zshell" I mean "lots of bloat enabled I don't care about and a lot of stuff I want disabled"
13:41:28 <jmcarthur> merijn: I wouldn't say it's intended as a no-config sort of thing at all. It just comes with a lot of built-in goodies that would otherwise take many days to set up on your own.
13:41:50 <merijn> jmcarthur: Yes, but usually that also means tons of stuff I *don't* care about
13:41:59 <merijn> jmcarthur: I actually like my editor config fairly minimal
13:42:08 <maerwald> merijn: last I checked my spacemacs had ~1800 hotkeys or so? xD
13:42:11 <dmj`> merijn: agreed
13:42:17 <maerwald> so yeah, it's bloat.
13:42:22 <merijn> jmcarthur: Would my spacemacs setup work on a machine without spacemacs installed (just emacs)?
13:42:55 <jmcarthur> merijn: I once started making a fresh emacs config that included all the things I knew I cared about without Spacemacs and eventually realized just how much of Spacemacs I was really using, which was a lot.
13:42:55 * hackagebot vty 5.6 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.6 (JonathanDaugherty)
13:43:20 <jmcarthur> merijn: Would your emacs setup? I don't understand the question, because without transferring your configs you're hosed anyway.
13:43:36 <dmj`> merijn: the nice thing about emacs key config is that it works in any unixterminal as well (i.e. Ctrl-a puts your to the front of line)
13:43:40 <merijn> jmcarthur: Yes, but could I copy 1 dir to a remote machine with emacs and have it work?
13:43:46 <dmj`> s/your/you
13:43:48 <jmcarthur> merijn: Sure.
13:44:04 <merijn> dmj`: Ctrl-a is already taken for my nested tmux session anyway
13:44:36 <merijn> dmj`: Also, you realise that 1) ctrl-a is not part of the terminal, but readline and 2) you can config readline to support vi mode?
13:44:47 <dmj`> merijn: ah, yea, when I went to emacs I just adopted the "a buffer for everything" mindset, even terminals
13:45:03 <dmj`> run a new eshell in it's own buffer
13:45:21 <jmcarthur> merijn: Actually it's probably a two-step thing unless you do a little fudging to be able to include your .spacemacs in with your .emacs.d...
13:45:30 <jmcarthur> merijn: Copy your .spacemacs, clone the spacemacs repo, done.
13:46:11 <dmj`> merijn: sure, but default being Ctrl-A is nice when you ssh in to a new machine
13:46:58 <jmcarthur> Anyway, I don't mean to say Spacemacs is right for everyone, just that it has a pretty decent out of box experience relative to vanilla emacs.
13:47:55 * hackagebot clay 0.11 - CSS preprocessor as embedded Haskell.  https://hackage.haskell.org/package/clay-0.11 (seanparsons)
13:58:37 <bluezone> kind of hard to reason about big-oh efficiency
13:58:49 <coppro> why?
13:59:00 <ggVGc> because you don't know what the O is
13:59:16 <ggVGc> ?
13:59:17 <coppro> in what context?
13:59:27 <bluezone> For example let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]   
13:59:35 <bluezone> I guess that would be n^3?
14:00:02 <bluezone> ggVGc: no because I'm used to counting number of times statements are executed
14:00:09 <coppro> bluezone: ah!
14:00:29 <coppro> bluezone: to properly analyze it, you have to first desugar it, and also understand Haskell's evaluation semantics
14:00:58 <coppro> (or at least, to understand an expression at a basic level. At a more complex level, you can obviously build up from primitives)
14:01:43 <bluezone> if we replace 10 with some large number (n), would we be right in saying that it is n^3 in that case?
14:01:44 <coppro> your expression is equivalent to do { c <- [1..10]; b <- [1..10]; a <- [1..10]; return (a, b, c) } To understand this, you have to look at the source of >>= for lists
14:02:02 <coppro> I believe so, but I don't know for sure
14:02:10 <bluezone> hmmm
14:02:34 <bluezone> What are the curly braces for? ^_^ Sorry I am new
14:04:37 <Aruro> bluezone: its block marking , instead of indentation layout
14:04:52 <bluezone> oh
14:17:15 <jmcarthur> @check \xs ys -> length [(x, y) | x <- xs, y <- ys] == length xs * length ys
14:17:16 <lambdabot>  +++ OK, passed 100 tests.
14:17:19 <jmcarthur> bluezone: ^^
14:17:46 <jmcarthur> bluezone: If you know that property, it's pretty easy to determine the answer to your problem.
14:24:26 <bluezone> what library is it using for those unit tests jmcarthur 
14:25:00 <dmj`> @package QuickCheck
14:25:00 <lambdabot> http://hackage.haskell.org/package/QuickCheck
14:26:15 <bluezone> and xs and ys are lists? Why are they abbreviated to xs and ys. I see it in the books too
14:27:42 <ggVGc> yeah, it's just common practice
14:27:56 <ggVGc> I kind of dislike it when I see it in code
14:28:04 <ggVGc> because usually there's a better name for whatever it is
14:28:07 <jmcarthur> Whether xs and ys are good names depends on context.
14:28:09 <ggVGc> but writing xs is easier
14:28:24 <suppi> usually you'll find (x:xs) as a pattern
14:28:28 <bluezone> I see, I don't mind as long as people know. I prefer it to veryLongNamesLikeThis
14:28:35 <jmcarthur> In the case of a quickcheck test, there isn't really anything gained by calling them listOfThings1 and listOfThings2
14:28:39 <EvanR> since thingamajig and thingamajigs in the mungeThingamajings function which is 2 lines long is annoyingly redundant
14:29:01 <EvanR> and you see paterns like thingamajig:thingamjigs in several places gets old
14:29:25 <EvanR> when code is very short, this makes it harder to read
14:29:30 <Cale> Also, often there is not a better name,
14:29:32 <jmcarthur> One naming pattern I don't like all that much is x, x', x'', x''', x'''', etc.
14:29:46 <jmcarthur> I'd rather just use x0, x1, x2, x3, x4, etc.
14:29:55 <jmcarthur> Or a, b, c, d, e, f, etc.
14:30:03 <EvanR> xa xb xc xd... heh
14:30:05 <Cale> map functionToApply (firstElementOfList : restOfElementsOfList) = functionToApply firstElementOfList : map functionToApply restOfElementsOfList
14:30:17 <EvanR> at that point you might want a State
14:30:21 <jmcarthur> I like the numbers a bit better because they show that each one is related to the others in some way.
14:30:53 <jmcarthur> The state monad is so overused. And besides, when you need all bindings at once, State does nothing for you.
14:31:01 <Cale> It's actually harder to see that this is behaving in the correct way than the version with single letter variable names, where you can inspect what it's doing structurally.
14:31:04 <EvanR> pretty much
14:31:31 <jmcarthur> Cale: You forgot to call map applyFunctionToEachElementOfAList
14:31:36 <Cale> heh
14:32:06 <EvanR> long variable names makes more sense in a classic language procedure spanning 3 pages of text editor, where you have no idea what a variable is from just looking at the code
14:32:26 <Cale> We could also rename (:) to constructAListFromTheFirstElementAndRemainder
14:32:40 <Cale> Er, ConstructAListFromTheFirstElementAndRemainder
14:32:40 <jmcarthur> The optimal length of a variable is a function of scope and frequency of use.
14:32:46 <Cale> yeah
14:33:38 <EvanR> how long should it be if its global and used a helluva lot? ;)
14:33:40 <Cale> Variables should get longer as their scope becomes wider, and shorter as they occur more frequently within that scope.
14:34:09 <EvanR> indeterminate
14:35:26 <Cale> You could come up with some sort of information theory style formula involving a logarithm, but it would be a bit silly given that for anything longer than a couple letters, you probably want to actually choose a word
14:36:45 <Aruro> Cale: code text skins in separate file
14:37:34 <jmcarthur> Yeah, it's usually a choice among just a few letters, a single word, two words, or many words. Sometimes an operator is also a choice (which should be made very rarely!).
14:38:27 <jmcarthur> Though I do sometimes appreciate arguments which in the function definition are bound as operators.
14:39:50 <Qqwy-wm> Greetings!
14:40:08 <slack1256> Greetings
14:41:51 <dmj`> Qqwy-wm: o/ 
14:51:41 <Qqwy-WM> o/
14:52:01 <Qqwy-WM> It's nice to find out that the Haskell language has an IRC channel :-)
14:52:39 <Qqwy-WM> Right now, I am trying to wrap my head around Comonads. I've read multiple blog posts about them, but I still have trouble understanding them
14:53:16 <Qqwy-WM> Maybe, approaching them as 'its the dual/opposite of a monad' is not the most easy approach...
14:53:19 <slack1256> that's specialized knowledge. Do you know Functor and Monad?
14:53:19 <Qqwy-WM> Any tips?
14:53:34 <Qqwy-WM> I understand Functors, Applicative Functors, Monoids and Monads
14:54:03 <slack1256> Maybe the archetipal example of a Comonad, the `Store` comonad will help?
14:54:12 <slack1256> @where Store
14:54:12 <lambdabot> I know nothing about store.
14:54:54 <Qqwy-WM> This one? https://hackage.haskell.org/package/comonad-4.2.7.2/docs/Control-Comonad-Store.html
14:55:13 <slack1256> that one. Also this SO answer https://stackoverflow.com/questions/8766246/what-is-the-store-comonad#8766314
14:55:19 <Skami> What library would you recommend me for real-time audio generation? 
14:56:45 <Qqwy-WM> @Skami: What kind of audio generation are we talking about? Full-on wave synthesis? Or 'just' stitching together existing audio samples in interesting ways?
14:56:46 <lambdabot> Unknown command, try @list
14:57:01 <slack1256> Qqwy-WM: it also helps thinking that when people say dual, they mean reversed order of arrows
14:57:12 <Qqwy-WM> slack1256: Thank you. 
14:57:16 <Skami> I have an arrow generating a double between 0 and 1 and I want to play it
14:57:24 <Qqwy-WM> I've posted this question myself about a week back: http://programmers.stackexchange.com/questions/322431/what-is-a-comonad-and-how-are-they-useful?noredirect=1#comment684228_322431
14:57:33 <slack1256> on monad return :: a -> m a has a comonad dual called extract :: m a -> a which *gasp* extracts in a sense a value
14:57:39 <Skami> I tried piping to Sox, but it's not fast enough
14:58:05 <Qqwy-WM> unfortunately, even though I added a bounty, the answers until now haven't helped to understand them better
14:58:24 <Qqwy-WM> Sox would've been my first recommendation if you were only stitching audio samples.
14:58:47 <EvanR> Qqwy-WM: just like monads, first look at individual example data types, then see why you can assign extract and duplicate/extract to something they can do
14:58:55 <Cale> Qqwy-WM: Do you want a definition of a comonad?
14:59:30 <slack1256> you must think on the duality between monads join/return and comonads extend/extract
14:59:48 <slack1256> then the duality will be clear. Plus the Store example is a really good intuition
15:00:02 <Cale> Actually, your question seems to indicate that you misunderstand what the word "comonad" refers to
15:00:13 <EvanR> without understanding any examples, even instantly understanding duality wont answer the question "why do i care"
15:00:19 <Skami> Qqwy-WM: could I do this in openal? 
15:00:24 <Cale> The comonad is the type-level function
15:00:25 <Qqwy-WM> EvanR: I've had a lot of trouble doing that, since I was unable to find concrete examples of comonads myself so far. (with 'concrete' I mean an example that does not also do ten other things that have might nothing to do with comonads)
15:00:38 <Cale> (as is the monad -- monads aren't values)
15:00:45 <EvanR> Qqwy-WM: thats going to be tough, since comonad isnt doing very much
15:01:07 <EvanR> look at streams
15:01:16 <EvanR> data Stream a = MkStream a (Stream a)
15:01:20 <Cale> Qqwy-WM: Every nontrivial example of a monad is similarly going to do 10 other things which don't have much to do with monads.
15:01:22 <EvanR> its not doing much either
15:01:32 <Qqwy-WM> It's a bit like when someone tells you 'Let me explain Functors. Lists are functors.' And then they go on about how Lists are also monads, etc, distracting from what is going on.
15:01:36 <Cale> The only way to understand abstractions like this is to look at a bunch of examples.
15:01:43 <EvanR> Qqwy-WM: agreed
15:02:00 <Cale> Lists aren't functors, List (the type constructor) is a single functor.
15:02:24 <Cale> Lists are also not monads, List is a monad.
15:02:34 <slack1256> when those declarations are made, people who already understand functors nod and people who don't get more confused
15:02:40 <EvanR> it would be nice if the explanations stayed focued on the issue
15:02:48 <Qqwy-WM> Cale: Yes, you're right.
15:03:16 <Cale> In order to understand an abstraction of any sort, you need to see enough examples of it
15:03:49 <Cale> You can't understand the relationship between monads and programming without looking at least at half a dozen, probably more examples.
15:03:54 <Qqwy-WM> EvanR and Cale: The only online article with some examples about comonads was this article about Scala: http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/
15:04:15 <EvanR> i get the feeling anything scala is going to be very distracted
15:04:16 <Qqwy-WM> But it explains comonads like 'we have a Reader monad. we also have a Reader comonad.'
15:04:21 <elucidata> Cale: what's a good resource to start trying to understand monads fully? Any resource with a lot of examples?
15:04:27 <Qqwy-WM> So yes, it is very distracting
15:04:40 <Qqwy-WM> elucidata: I'd recommend the Learn you a Haskell book
15:04:41 <Cale> elucidata: Well, just the world of Haskell libraries -- you're bound to run into examples as you start using them.
15:04:54 <EvanR> Qqwy-WM: thats whats nice about haskell's theories... there is so little there after all the smoke clears ;)
15:05:03 <Cale> You don't need to understand what a monad "is" in some philosophical way to just use the API you're provided
15:05:05 <EvanR> but it can make it hard to understand when youre expecting a huge to-do
15:05:14 <elucidata> Cale: that's why I love lisp, actually
15:05:28 <elucidata> I think lisp and haskell are very spiritually complimentary languages
15:05:47 <elucidata> lisp is yin, haskell yang
15:05:50 <Cale> But make sure that you look at a parser combinator library
15:05:51 <EvanR> haskells predecessors definitely incorporated a lot of the "good parts" of the lisp world
15:05:56 <Aruro> Qqwy-WM: u dont need comonads, u dont even need monads. u need continuation.
15:06:06 <Qqwy-WM> EvanR: Very true. 'there is so little there after the smoke clears'. But on the other hand, I've tried to explain to my coworkers why Functors are awesome. Explaining this stuff is HARD
15:06:18 <EvanR> Qqwy-WM: ... pretty much
15:06:30 <Cale> One example of a comonad which I rather like, and which gives a pretty good idea of a general theme that various comonads provide is the comonad of functions out of a fixed monoid.
15:06:44 <Cale> i.e. w a = m -> a where m is a monoid
15:06:49 <Qqwy-WM> Aruro: Continuations? How come?
15:07:12 <EvanR> continuations... they can do anything!
15:07:20 <Cale> Qqwy-WM: Are you familiar with what a monoid is? The definition is pretty simple, but what I'm going to do won't make much sense without it
15:07:20 <EvanR> which ... should raise some red flags
15:07:36 <Aruro> Qqwy-WM: read on continuation "monad"
15:07:52 <EvanR> Aruro: speaking of getting distracted!
15:07:54 <Qqwy-WM> Cale: So say we have the sum monoid (0, (+)), how would you define something like above?
15:08:11 <Cale> Yeah, that's a good example, let's go with the integers
15:08:45 <Cale> So, to make this into a comonad, we have to define  extract :: w a -> a
15:08:57 <Cale> In this case, it's  extract :: (Integer -> a) -> a
15:09:04 <Aruro> Qqwy-WM: wiwkibook has stuff on continuations, also here : http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
15:09:15 <Cale> (note that you'll actually need a newtype wrapper if you want to write the instance, but I'm going to do without it for now)
15:09:32 <mvaenskae> is there a maximum number of guards in haskell?
15:09:48 <mvaenskae> per function that is
15:09:56 <Welkin> I don't think so
15:10:05 <Cale> mvaenskae: no
15:10:26 <Cale> (though there's probably some point at which GHC takes a really long time and a lot of memory to compile your module)
15:10:36 <Aruro> mvaenskae: im pretty sure there is, but its thechnicality of compiler
15:10:59 <mvaenskae> ah, i made a typo
15:11:01 <Aruro> mvaenskae: how many guards u need?
15:11:02 <Cale> Well, if it's Integer on its own, we might not have a natural choice to make, but given that we know that what matters is the additive monoid on Integer, there's a natural choice here -- to apply the function (Integer -> a) to the identity element
15:11:02 <Welkin> nothing is truly infinite
15:11:04 <Welkin> haha
15:11:08 <mvaenskae> keyConvert != keyconvert
15:11:10 <Welkin> there is a limit to everything, if that is what you mean
15:11:12 <Cale> So:  extract f = f 0
15:11:16 <Cale> Qqwy-WM: good?
15:11:33 <Cale> Qqwy-WM: and then we need  duplicate :: (Integer -> a) -> (Integer -> Integer -> a)
15:11:45 <mvaenskae> thanks for helping me out there guys :)
15:11:46 <Cale> duplicate f x y = ...
15:11:58 <Cale> Qqwy-WM: Can you guess what to do?
15:12:08 <Qqwy-WM> Good! Of course, the identity law helps you define what the extract function should be.
15:12:11 <Qqwy-WM> Hmm... let me see
15:12:53 <EvanR> Skami: so i wasnt able to find the lib i was thinking of.. maybe it doesnt actually exist.. but you might want to look at the package csound-expression 
15:13:03 <EvanR> you can use it to make sounds
15:13:03 <Welkin> Is there ever a reason to use Array over Vector? I can't think of any, unless for some reason you want to avoid the overhead of Vector.
15:13:25 <EvanR> but it relies on csound
15:13:30 <Cale> Welkin: Not *really*, though I'm still kind of sad that Vector doesn't use the Ix machinery
15:13:43 <Qqwy-WM> Hmm... `duplicate f x y = f $ x+y`? (i.e. use the summing from the monoid?)
15:13:45 <Skami> EvanR: Thank, I'll have a look at it
15:13:45 <EvanR> Welkin has suddenly become a finitist?
15:13:50 <Qqwy-WM> or am I thinking in completely the wrong direction here
15:13:50 <Cale> Qqwy-WM: yep!
15:14:02 <EvanR> Skami: theres actually few libs like this, look on hackage under "music"
15:14:21 <Cale> Qqwy-WM: We can sort of picture a function Integer -> a as being like an infinite array of values of type a, indexed by integers
15:14:36 <EvanR> Welkin: Array has more overhead i would assume, since it does index mapping for you
15:14:43 <Cale> Qqwy-WM: and then what extract is doing is it's picking out the element at the origin
15:14:51 <Skami> EvanR: Thanks, I'll notice if I find something useful
15:14:53 <Qqwy-WM> Mind = Blown. So we use 'extract' with the identity from the monoid, and 'duplicate' with the joining operation from the monoid?
15:15:05 <Welkin> EvanR: what do you mean? Vector provides the same kind of interface
15:15:09 <Cale> that's right
15:15:15 <Cale> Qqwy-WM: and what duplicate is doing is it's producing an array of all the ways of translating this array
15:15:18 <EvanR> Welkin: no, vector uses Int indexes only
15:15:23 <Welkin> oh
15:15:33 <Qqwy-WM> Wow
15:15:33 <EvanR> if you want a 2D vector you have to do stuff yourself
15:15:35 <Welkin> so in Array you can use another Num for the index
15:15:37 <Cale> such that the element at the origin in each is the corresponding element at that position in the original
15:15:44 <Cale> right?
15:15:51 <Cale> (that's a mouthful, but think about it)
15:16:19 <Welkin> EvanR: do you have an example?
15:16:23 <Qqwy-WM> So if you first use duplicate and then extract, you'll end up with the corresponding origin?
15:16:26 <EvanR> for what, a 2D vector?
15:16:38 <Cale> Qqwy-WM: you'll end up with the original function
15:16:49 <Welkin> you mean: v ! 4 ! 5 to access (5,4) in Vector?
15:16:56 <EvanR> that wont work
15:16:58 <Cale> extract (duplicate f) = f -- this is one of the comonad laws
15:17:09 <EvanR> im wrong, it would work
15:17:13 <Welkin> I have done it
15:17:18 <Welkin> I never used Array though
15:17:24 <EvanR> Welkin: thats if you put vectors inside vectors, another way is to map indexes
15:17:25 <Cale> Qqwy-WM: but not only that
15:17:33 <Qqwy-WM> Ah, of course. Wow!
15:17:34 <EvanR> multiply the first index by the width
15:17:39 <Cale> fmap extract (duplicate f) = f
15:17:45 <EvanR> and add the second
15:17:55 <Qqwy-WM> o.o Wait, what?
15:18:09 <Welkin> EvanR: yes, a common way of using "2D" arrays in game programming is to just use an accessor expression (row * numColumns + col)
15:18:10 <Qqwy-WM> how can you just put an fmap in front of there and have it still work?
15:18:18 <EvanR> Welkin: yes and that gives better locality
15:18:18 <Cale> Well, maybe we should think for a moment about what fmap is here, since I didn't mention that, but a Functor instance is required
15:18:32 <Cale> (it's part of the definition of a comonad)
15:18:35 <EvanR> but youre restricted to rectangular arrays
15:18:46 <Cale> fmap :: (a -> b) -> (Integer -> a) -> (Integer -> b)
15:18:55 <Cale> Can we write that?
15:19:02 <ken> hello!!
15:19:08 <Cale> hello
15:19:13 <Qqwy-WM> Hello!
15:19:37 <Welkin> so what do you mean about Array then?
15:19:41 <EvanR> Welkin: the class for indexes in Array is Ix not Num
15:19:45 <Welkin> you can use (5,4) as the index directly?
15:19:48 <EvanR> yes
15:19:52 <Cale> Qqwy-WM: So, this is just function composition, right? :)
15:19:53 <Guest38473> literally just downloaded haskell right now, and reading Learn you a haskell! I'm excited. I'm a junior javascript dev.
15:19:58 <Welkin> how about (5,4,2)?
15:20:01 <EvanR> instance (Ix a, Ix b) => Ix (a,b)
15:20:02 <EvanR> yes
15:20:11 <Welkin> that seems useful
15:20:16 <EvanR> it does...
15:20:21 <Qqwy-WM> It seems that way, but I need another few seconds of staring at it to comprehend it ^^'
15:20:36 <Welkin> so that vs using an index expression in Vector
15:20:38 <Cale> fmap f g x = f (g x)
15:20:47 <Welkin> but then you lost all the extra functions defined for Vector
15:20:57 <Qqwy-WM> yes, it's just function composition
15:20:59 <EvanR> Welkin: for some reason, Vector ends up being the array of choice... something about the Array API is off putting
15:21:05 <Cale> Another way to think of this, if we're picturing our functions  Integer -> a  as being arrays
15:21:17 <Cale> Is that we're applying our function (a -> b) to all the elements of the array
15:21:30 <Cale> (obtaining another array indexed by the integers)
15:21:35 * Qqwy-WM nods thoughtfully
15:21:59 <Cale> Qqwy-WM: So, thinking about the types, if we start with f :: Integer -> a, and we apply duplicate to it, we get  duplicate f :: Integer -> (Integer -> a)
15:22:16 <Cale> now, the elements of this array, are themselves arrays, and we can apply extract to each one
15:22:36 <Cale> fmap extract (duplicate f) :: Integer -> a
15:23:04 <Qqwy-WM> Wow, very nice
15:23:16 <Qqwy-WM> :D
15:23:16 <Cale> and that again is the identity
15:23:25 <Cale> because the arrays were translations of the original
15:24:47 <Qqwy-WM> I think I understand this example :-)
15:24:55 <Cale> So,  fmap extract (duplicate f) x = extract (duplicate f x) = extract ((\u v -> f (u + v)) x) = extract (\v -> f (x + v)) = (\v -> f (x + v)) 0 = f (x + 0) = f x
15:25:13 <Cale> We can also just calculate that we're obtaining the same function like this :)
15:25:26 <Qqwy-WM> :D
15:25:56 <Welkin> that is very good to know
15:26:03 <Cale> The final comonad law is that  duplicate . duplicate = fmap duplicate . duplicate... which is a bit tricky to think about, but it follows from the associativity of addition
15:26:25 <Welkin> if I ever want to use non-int indexing for arrays (which sounds like it could be useful for some cases), I'll use Array
15:26:36 <Welkin> I like the example in Data.Ix
15:26:49 <Welkin> indexing by a Color sum type
15:26:50 <EvanR> the requirement for Ix types is that they are somehow consecutive
15:27:15 <EvanR> so that lets you make a "table" with many kinds of keys, and itll be lookup efficient
15:27:29 <EvanR> but the issue with Array is how to munge various arrays into different shapes
15:27:59 <EvanR> the library support is kind of missing
15:28:52 <EvanR> for general lookup tables using weird keys, i would go with Data.Map
15:29:13 <Qqwy-WM> Wow
15:29:46 <Qqwy-WM> So what would a comonad like that (i.e. defined for the additive integer monoid) be useful for?
15:30:00 <Cale> Qqwy-WM: Many comonads will be *somewhat* like this one, in that duplicate is going to produce some structure which has a specially-identified value in it, and when you apply duplicate, you get a structure of structures, each of which is in some sense a translation of the original.
15:30:28 <Cale> (because of the comonad law, when you apply extract, you're going to get back the value which was at the corresponding position in the original structure...)
15:30:47 <Cale> Well, this is useful for cellular automata for one
15:31:16 <Qqwy-WM> Yes, I've seen https://github.com/kwf/ComonadSheet
15:31:44 <Qqwy-WM> (and the talk about it). But it prefixes a lot of words with `co-` while assuming it common knowledge how/why they work
15:31:44 <Cale> What does a cellular automaton have to do? Well, it's going to do the "same" computation at many places in an array, each of which depends on the values of positions relative to each point
15:32:08 <Cale> So if we start with some array of, say, Boolean values
15:32:16 <Cale> (Integer -> Boolean)
15:32:44 <Cale> then we can start by applying duplicate to get all the translations: Integer -> (Integer -> Bool)
15:33:16 <Cale> and now, our cellular automaton is going to apply some f :: (Integer -> Bool) -> Bool  at each of those positions
15:33:40 <Cale> i.e. fmap f . duplicate :: (Integer -> Bool) -> (Integer -> Bool)
15:34:29 <Welkin> Monad is like Mario, and W is Waluigi!
15:34:30 <Cale> and that's how we step the cellular automaton forward
15:34:30 <Welkin> er
15:34:35 <Welkin> Monad is like Mario, and Comonad is Waluigi!
15:34:44 <Cale> heh, not Wario?
15:34:50 <Welkin> oh, that too
15:34:53 <Welkin> yeah
15:35:08 <Aruro> Qqwy-WM: haskell is a "research" field, no need to take everything as blessing.
15:35:15 <Welkin> I haven't studied comonads yet, so this is a good discussion
15:35:22 <Welkin> taking a look at the typeclassopedia now
15:35:27 <Aruro> Qqwy-WM: most of this stuff will be soon forgotten
15:35:49 <Cale> Qqwy-WM: Now, you can repeat this entire discussion we just had, where we replace the monoid Integer with the monoid String
15:35:53 <Qqwy-WM> Aruro: That doesn't mean that it is a bad idea to learn the knowledge of today.
15:35:57 <Qqwy-WM> String + append?
15:36:00 <Cale> yep
15:36:26 <Cale> and if you go down that road, you might come to this: https://hackage.haskell.org/package/category-printf
15:36:35 <Qqwy-WM> So... extract f = f ""
15:36:55 <Qqwy-WM> and duplicate f x y = f (x ++ y)
15:36:58 <Cale> yep
15:37:42 <Cale> We didn't really talk about Kleisli and Cokleisli yet
15:37:52 <Cale> So there's an ingredient missing for me to be able to talk about printf
15:38:10 <Aruro> Qqwy-WM: im not gonna stop u wasting hours reading Cathegory theory "math" , but i warned you :)
15:38:20 <Cale> But it turns out that printf format specifications in some sense "are" arrows in the Cokleisli category for the comonad of functions out of a string type.
15:38:46 <Qqwy-WM> Aruro: I'm going to read about Continuations later. I've added it to my browser bookmarks :-)
15:39:06 <Cale> and you also get some fun stack-manipulation sort of stuff falling out of that naturally
15:39:21 <Cale> Which turns printf into a weird sort of interpreter for a typed forth-like language
15:39:43 <Cale> https://hackage.haskell.org/package/category-printf-0.1.1.0/docs/Control-Category-Printf.html (look at the examples toward the bottom)
15:39:51 <Qqwy-WM> Ah, so this lets you do `printf("the weather is %s", weather)` in a typesafe way?
15:40:03 <Qqwy-WM> (Without resorting to dependent types)
15:40:08 <Cale> yeah, though the %s has to be something a bit different
15:40:16 <Cale> and the string itself really isn't a string
15:40:35 <Cale> (but with the OverloadedStrings extension, we can make it look like one)
15:40:55 <Cale> You can write printf ("the weather is" . s) weather
15:41:06 <Cale> er, missed a space :)
15:41:20 <Cale> and that (.) is the one from Control.Category
15:42:03 <Qqwy-WM> wauw
15:42:40 <Cale> >>> printfLn (dup . s . " plus " . swap . dup . s . " equals " . apply2 (+) . s) 4 6
15:42:41 <Cale> 4 plus 6 equals 10
15:42:50 <mauke> dissenting opinion: all those "typesafe printfs" aren't really printf
15:42:51 <Cale> You can do stack manipulation and calculation
15:43:03 <Cale> heh
15:43:34 <Qqwy-WM> This is insane
15:43:39 <Qqwy-WM> In a good way :D
15:44:14 <mauke> printf is an ad-hoc DSL template thing. it's supposed to look compact
15:44:24 <Rembane> mauke: They are something else to convert stuff to a string?
15:44:34 <mauke> the format string is mostly literal text, with a few placeholders to be expanded
15:45:03 <mauke> I can easily see what "Hello, %s! Your score is %d." does
15:45:09 <Cale> So that duplicates the 4 (so we can use it again later in the addition), prints it out followed by the string " plus ", then swaps the stack so the 6 is on top, duplicates the 6 and prints it, and then the string " equals ", and then applies (+) to the top 2 elements of the stack, which are 6 and 4, pushing the result 10 on the stack, and finally prints that.
15:45:39 <mauke> it gets much harder with ("Hello, " . s . "! Your score is " . d . ".")
15:45:49 <Cale> only slightly
15:45:53 <mauke> it's visually cluttered
15:46:17 <Cale> Yeah, but this is just a concrete syntax thing
15:46:19 <shachaf> Use OverloadedStrings to make ("Hello"s"! Your score is "d".") work.
15:46:24 <mauke> at that point I might as well write "Hello, " ++ name ++ "! Your score is " ++ show n ++ "."
15:46:24 <Cale> heh
15:46:40 <mauke> concrete syntax is the entire point
15:46:54 <Welkin> lol string interpolations
15:46:57 <mauke> if you give up on that, it's not printf
15:47:04 <Welkin> I see so many different ways of doing it in many languages
15:47:05 <Cale> I see the point as being able to determine a function of the remaining arguments based on the thing we're splicing into.
15:47:06 <Welkin> it's a mess
15:47:29 <mauke> Cale: why is that a desirable goal?
15:48:19 <mauke> it seems like a "cool" feature with no practical use
15:49:11 <Welkin> I already ran into trouble using printf in c where I meant to print an unsigned int, but I use the wrong token and it implictly converted it into a signed int
15:49:12 <Cale> It is somewhat limited in usefulness with just strings, I'll admit -- writing things the (\x -> ... ++ show x ++ ...) way is not so bad
15:49:20 <Welkin> caused a lot of problems for me in later debugging
15:49:21 <ggVGc> I'd like a language that knows exactly what I want to do with the minimum amount of syntax in every situation
15:49:24 <ggVGc> please.
15:49:29 <ggVGc> including things like string interpolation
15:49:37 <Rembane> ggVGc: Perl!
15:49:42 <mauke> the right way to do printf may be [printf|Hello, %s!]
15:49:48 <ggVGc> Rembane: $okay
15:50:11 <mauke> actually ... that should be |], shouldn't it?
15:50:16 <Cale> mauke: We could do that, and have it construct a term in this Cokleisli category :)
15:50:18 <ggVGc> yep
15:50:22 <Cale> it should
15:50:36 <ggVGc> I'm not sure hwo I feel about quotations
15:50:45 <ggVGc> seems to be a lot of extra work for even simple things
15:50:48 <ggVGc> a lot of TH work
15:51:17 <Cale> ggVGc: You don't do the work, you grab a library off of hackage which did the work for you
15:51:25 <ggVGc> oh, well then
15:51:47 <Cale> But it does result in longer compile times eventually
15:52:00 <Cale> especially if you're using GHCJS and every TH splice fires up a node instance
15:52:26 <ggVGc> but, for example, that first class record library that was announced a while back. It apparently needed to implement its own parser for haskell syntax, in order to have haskell within quotations
15:52:31 <ggVGc> that seems redundant
15:52:35 <ggVGc> in a dumb way
15:52:39 <Cale> Another thing which I'm mildly excited about is the fact that with the new Reflex, we have an instance Monoid m => Monoid (Dynamic t m)
15:52:53 <Cale> or rather (Monoid m, Reflex t) => Monoid (Dynamic t m)
15:53:12 <Cale> and so I'll be able to do  printfWith dynText
15:53:28 <Cale> and use this very same machinery for formatting strings to format dynamically changing strings
15:54:32 <ggVGc> https://nikita-volkov.github.io/record/
15:54:48 <ggVGc> under "Project status" he says he needed to reimplement haskell syntax essentially
15:54:52 <ggVGc> that sems a but crap?
15:55:11 <Cale> Well, you're allowed to implement any notation that you like
15:55:58 <Cale> So if you want something which looks like Haskell but is not quite a fragment of Haskell that is exposed by some Haskell parsing library like haskell-src-exts, then you'll need to write a parser.
15:56:27 <mcuramen> Hello guys, other than Haskell, what other programming languages are you guys passionate in?
15:56:37 <ggVGc> there are others_
15:56:38 <ggVGc> ?
15:56:44 <Cale> mcuramen: Coq, Agda, Idris are all cool
15:56:51 <ggVGc> I wouldn't go as far as to call them proramming languages
15:56:56 <coppro> they totally are
15:57:01 <ggVGc> all the others that is
15:57:03 <mcuramen> Cale, I have never heard of those
15:57:09 <coppro> I use C# day-to-day
15:57:16 <Cale> mcuramen: They're dependently typed functional programming languages.
15:57:36 <ggVGc> mcuramen: I think lua is the best we have for dynamic programming, but it can be argued if we should have dynamic programming at all
15:57:50 <mauke> mcuramen: perl
15:57:52 <ggVGc> I think it has it's uses
15:57:59 * hackagebot data-default-class 0.1.2.0 - A class for types with a default value  https://hackage.haskell.org/package/data-default-class-0.1.2.0 (LukasMai)
15:58:01 * hackagebot data-default-instances-base 0.1.0.1 - Default instances for types in base  https://hackage.haskell.org/package/data-default-instances-base-0.1.0.1 (LukasMai)
15:58:27 <mcuramen> ggVGc, I don't know much about lua either
15:58:31 <Cale> mcuramen: Basically, they're exploring a space of type systems more powerful than Haskell's -- powerful enough to encode all of mathematics, where your programs really become proofs of theorems.
15:59:16 <mcuramen> I spent my time working on my algorithm skills and concentrating on the basics since I am still in school.
15:59:23 <ggVGc> mcuramen: if you need something that's fast, easily embeddable, runs on essentially anything where you can compile C, and want easy reload/run cycles, then lua is great. With luaJIT it's often faster than anyting that isn't well optimized C.
15:59:32 <ggVGc> and Lua as a language has pretty much no language warts
15:59:44 <Cale> (but of course, you're not compelled to make the proof any harder on yourself than you would in a traditional programming language -- you're just free to be more expressive in your types when you want to constrain the possible implementations further)
16:00:10 <mcuramen> Cale: that is very impressive
16:00:15 <ggVGc> for statically typed languages, I don't like anything that isn't haskell now..
16:01:10 <ggVGc> mcuramen: oh, actually, Nim is real nice, and also runs on many more platforms than Haskell, since it compiles to ANSI C, but it's much higher level than C and has a decent type system and nice language features
16:01:18 <mauke> ggVGc: 1-based arrays?
16:01:30 <mcuramen> ggVGc: I've been forced to write Java for my internship. I used to like it, but being exposed to Python and Lisp ruin Java for me. I can't stand it now.
16:01:31 <ggVGc> mauke: yeah, that's one of the pet peeves. But I wouldn't go as far as to say it's a language wart
16:01:45 <ggVGc> java really is not where you want to be
16:01:54 <ggVGc> I don't understand how anyone can be "passionate" about java
16:01:57 <ggVGc> it has a use and fills it
16:02:05 <ggVGc> but I don't hink anyone really likes it
16:02:25 <mcuramen> it's the language you use to pay the bills
16:02:29 <ggVGc> right
16:02:40 <ggVGc> I guess many people are passionate about paying their bills
16:02:41 <ggVGc> which is fair
16:02:56 <ggVGc> I use javascript to pay my bills :(
16:03:02 <ggVGc> well, I much prefer it to java
16:03:31 <ggVGc> Julia looks really cool to me, but I haven't actually written anyting in it
16:03:47 <ggVGc> it doesn't fit my everyday use cases
16:04:02 <ggVGc> but for the use cases it fits, it looks great
16:04:13 <ggVGc> hopeto use it some day
16:04:54 <mauke> ggVGc: http://blog.plover.com/prog/Java.html
16:06:04 <mcuramen> how about Scala?
16:06:12 <mcuramen> what are your thoughts?
16:08:00 * hackagebot data-default 0.7.1.1 - A class for types with a default value  https://hackage.haskell.org/package/data-default-0.7.1.1 (LukasMai)
16:10:31 <ggVGc> I did a small tool in scala
16:10:42 <maerwald> mauke: lol, nice
16:10:42 <ggVGc> it has pretty nice parts, but I recko you need to avoid about 60% of the language
16:11:13 <ggVGc> the weirdness of scala comes a lot from dealing with the java standard library
16:11:16 <Welkin> lol
16:11:25 <ggVGc> and FP with nulls is fairly awkward
16:11:31 <ggVGc> mauke: nice read
16:11:50 <ggVGc> but case classes are nice, and compared to java, scala is pretty amazing to work in
16:11:54 <ggVGc> if you need to be on the JVM
16:12:06 <ggVGc> I reckon scala is a very productive tool
16:12:08 <EvanR> NIL was a huge feature of lisp, arguably the inventor of FP!
16:12:10 <ggVGc> much more so than haskell
16:12:10 <Welkin> ggVGc: I have been looking at both lua and racket (or another scheme) to use as a scripting language for games (on top of a game engine)
16:12:24 <ggVGc> Welkin: you should really go with lua imo
16:12:30 <Welkin> but yeah... what's with the 1-indexed arrays ("tables") in lua?
16:12:37 <ggVGc> you get used to it in a few days
16:12:39 <dmj`> haskell is a good scripting language :)
16:12:52 <ggVGc> dmj`: even if you need to run on, say, android phones?
16:13:00 * hackagebot mongoDB 2.1.0.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.1.0.1 (VictorDenisov)
16:13:10 <ggVGc> and if you want to easily hot load code?
16:13:10 <maerwald> "With Haskell someone probably should have been fired in the first month for choosing to do it in Haskell." -- hahaha
16:13:13 <dmj`> ggVGc: sure
16:13:19 <EvanR> as i understand it, its a bitch to run anything but java on android so...
16:13:34 <EvanR> its interesting if lua has an advantage there
16:13:45 <ggVGc> EvanR: I wrote a small game engine in C and Lua and released a game on it. It was fine. ANdroid has the JNI, so you only need a little bit of java
16:14:03 <EvanR> and haskell has "java-bridge" ;)
16:14:19 <EvanR> so you only need a little JNI
16:14:38 <dmj`> ggVGc: https://github.com/keera-studios/keera-hails
16:14:40 <ggVGc> yeah, maybe it'd be good
16:14:44 <ggVGc> I didn't know any haskell at the time
16:15:30 <Welkin> dmj`: that's not for games, haha
16:15:37 <Welkin> I am writing my own game engine in C
16:15:40 <Welkin> like ggVGc 
16:16:03 <EvanR> im tending my own garden
16:16:40 <dmj`> Welkin: yes, it is
16:17:11 <mcuramen> Welkin: Have you heard of Icon? I believe it is also 1-indexed arrays
16:17:14 <ggVGc> Welkin: 1-indexed arrays is pretty much the only weirdness in lua imo, and it's a well defined one and has reasoning behind it. if we agree with that reasoning or not is beside the point. Most other languages I've used have a lot of "oh, it's like this because it just happened to become like that". Lua is very well defined, small, and efficient.
16:17:42 <ggVGc> racket is nowhere near as well reasoned as lua is
16:17:49 <ggVGc> and no dynamic language is as fast as luaJIT
16:18:01 <EvanR> can i has lua with better syntax, lazy evaluation, a type system...
16:18:09 <ggVGc> EvanR: I've started working on it
16:18:13 <ggVGc> well, not the lazy part
16:18:15 <ggVGc> that won't work
16:18:18 <maerwald> EvanR: no, but you get lots of end end end end
16:18:25 <EvanR> regular evaluation wont work ime ;)
16:18:37 <EvanR> you end up with iterators...
16:18:43 <ggVGc> maerwald: I used a slightly customized version of this for my game, http://moonscript.org/
16:18:44 <EvanR> which dont compose
16:19:05 <ggVGc> maerwald: here's a source file from my game, https://gist.github.com/64fa4c3189d01f41d275e814b02b12a6
16:19:41 <ggVGc> it compiles to standard lua, but has terser syntax
16:19:47 <Welkin> I've hardly started using racket yet, but it seems promising
16:20:04 <Welkin> there is also Guile Scheme, which is made for embedding, like Lua
16:20:04 <ggVGc> the whole class thing in moonscript is just crap
16:20:08 <ggVGc> but you can just ignore it
16:20:24 <Welkin> lol, yes, I got to the "class/object" part of the intro tutorial and skipped right past it
16:20:25 <ggVGc> Welkin: I think you underestimate the execution speed of lua and especially luaJIT
16:20:28 <ggVGc> compared to all those
16:20:41 <Welkin> perhaps you are right
16:20:49 <Welkin> I'm only exploring at this point
16:20:56 <ggVGc> luaJIT, if you don't generate much garbage, is essentially C
16:21:01 <ggVGc> often faster than C you would write
16:21:58 <Welkin> someone showed me this the other day
16:21:59 <Welkin> http://love2d.org/
16:22:11 <Welkin> a game framework for writing your whole game in lua
16:22:14 <ggVGc> yep, love is okay, but unfortunately not for mobile
16:22:16 <ggVGc> for some reason
16:22:22 <Welkin> and another one http://www.solarus-games.org/
16:22:46 <ggVGc> if you want to just make a game and have a decent script language, chec out GOdot
16:22:54 <ggVGc> if you want to write your engine for the fun of it, go with lua
16:22:57 <ggVGc> is my recommendation
16:23:12 <Welkin> I'm writing my engine in C, following along with Handmade Hero for the concepts
16:23:16 <ggVGc> my background is 5 years of professional game development and 7 or so released titles
16:23:50 <mcuramen> ggVGc: where did you work?
16:23:56 <Welkin> ggVGc: EA games?
16:23:59 <ggVGc> haha
16:24:19 <ggVGc> no, small companies in england and sweden
16:24:28 <ggVGc> and one of the titles was my own as I said
16:24:31 <Welkin> he programmed Madden 2007, Madden 2008, Madden 2009, Madden 2010, and Madden 2011
16:24:42 <ggVGc> a mobile game reaching an amazing 3000 downloads
16:24:45 <ggVGc> earning me 7 dollars
16:25:07 <ggVGc> Welkin: well, I worked for the studio that turned down making a mortal kombat game in the 90s...
16:25:13 <ggVGc> (I didn't work there then)
16:25:18 <ggVGc> was a fairly big mistake by them
16:25:34 <ggVGc> they made some basketball game instead I think
16:26:32 <EvanR> one person programmed all the maddens?
16:27:05 <ggVGc> my career is pretty humble. But imo the main thing if you actually want a game to release is to have tools for content. WHich essentially none of these game engines have. It doesn't matter what language you use. What matters is what you have available to create animations and scenes for your games
16:27:28 <ggVGc> my little engine used Flash as the content tool, exported through their HTML exporter to javascript, and transpiled to lua
16:27:31 <ggVGc> which I then ran in my engine
16:27:40 <Welkin> I'm doing it as a learning experience to know how it all works
16:27:40 <ggVGc> by porting the CreateJS library from javascript to lua
16:28:19 <mcuramen> ggVGc: So C++ isn't necessary? I don't know much about the game industry.
16:28:27 <ggVGc> Welkin: yep, same as me then. Even after releaseing games professionally, I wanted to bring something completely from scratch to market. SO I made that little engine and made sure I released a game
16:29:18 <ggVGc> mcuramen: no, C++ isn't the right choice for anything ever imo. But if you ask any game company they will probably say it is, and that they use it for most desktop and console games.
16:29:33 <ggVGc> but my first commercial game was C++...
16:29:37 <ggVGc> which wasn't my choice tbh
16:30:38 <ggVGc> mcuramen: but yeah, if you want to work for a big game company and make games for desktops or consoles, you'll most certainly be writing C++
16:30:47 <ggVGc> the nintendo SDK's are all C++
16:31:03 <ggVGc> Unreal engine is all C++
16:31:43 <ggVGc> pretty sure this is fairly off topic, sorry
16:31:47 <mcuramen> ggVGc: so why do big game companies love C++?
16:32:08 <ggVGc> mcuramen: join #haskell-offtopic
16:32:27 <mcuramen> ok
16:32:33 <jmcarthur> mcuramen: Because it gives them absolute control over memory layout while at the same time offering at least some sort of abstraction power, even if it's not very nice.
16:33:17 <jmcarthur> mcuramen: plus historical reasons
16:34:27 <ggVGc> mcuramen: ping me when you joined
16:34:33 <ggVGc> I just don't want to spam #haskell with gamedev talk
16:36:00 <mcuramen> ggVGc: sorry, I'm kind of stupid, I just started using IRC so it might take a while to figure out how to join it.
16:36:11 <ggVGc> mcuramen: just type /j #haskell-offtopic
16:36:41 <mcuramen> lol cool
16:36:53 <maerwald> mcuramen: imo, it's not so much about language features and stuff, but about development workflow. Incrementally and almost randomly adding effects to your codebase is not really that easy in haskell.
17:01:34 <troydm> is there a Maybe (Maybe a) -> Maybe a  function in standard library?
17:02:18 <mauke> join
17:04:10 <troydm> mauke: thx
17:05:09 <bluezone> Stack
17:05:22 <bluezone> they couldn't have come up with a more stupid, vague name, than stack
17:05:39 <bluezone> What were they thinking -.-
17:05:51 <bluezone> http://docs.haskellstack.org/en/stable/README/
17:08:09 <mvaenskae> so, i got my program now done :) thanks a lot guys \o/
17:08:18 <EvanR> "stack" is kind of overloaded to all hell
17:08:42 <bluezone> yeah
17:08:54 <mvaenskae> if anyone wants to check it out, i plan to write more haskell stuff in here: https://github.com/mvaenskae/haskell_snippets
17:09:09 <bluezone> it's become almost meaningless outside of the data structure 
17:09:55 <bluezone> mvaenskae: I may be interested but you are doing monads. I have to finish learning about lists lol
17:11:56 <EvanR> mvaenskae: awesome
17:14:11 <bluezone> by the way, an unsigned int just means you only deal with ints above 0? And consequently you can have larger positive int values than with a regular signed int
17:14:17 <bluezone> In general
17:14:25 <bluezone> (Don't know how it works in haskell yet)
17:14:26 <EvanR> yes, Int vs Word
17:14:50 <bluezone> Word?
17:14:53 <EvanR> > (minBound, maxBound) :: (Int,Int)
17:14:55 <lambdabot>  (-9223372036854775808,9223372036854775807)
17:14:59 <EvanR> > (minBound, maxBound) :: (Word,Word)
17:15:01 <lambdabot>  (0,18446744073709551615)
17:15:05 <bluezone> oh
17:15:14 <bluezone> so Word is signed int ?
17:15:19 <EvanR> unsigned
17:15:24 <bluezone> right
17:15:30 <EvanR> > 9223372036854775803 + 9 :: Int
17:15:31 <lambdabot>  -9223372036854775804
17:15:38 <bluezone> hehe
17:15:48 <EvanR> > 9223372036854775803 + 9 :: Integer
17:15:50 <lambdabot>  9223372036854775812
17:15:57 <EvanR> ^ huge mental burden gone
17:16:16 <bluezone> Would have hoped it threw an error instead in the first case
17:16:32 <EvanR> well it doesn't, and some clever algorithms exploit the behavior
17:16:48 <EvanR> you do have this though
17:16:55 <EvanR> > 5 - 8 :: Natural
17:16:56 <lambdabot>  *Exception: Natural: (-)
17:17:21 <obadz> there's a checked int library too
17:17:33 <obadz> https://hackage.haskell.org/package/safeint
17:22:04 <troydm> I have a list of maybe Bool  e.g. [Maybe Bool], what's the easiest way to turn it into [Bool]?
17:22:29 <mauke> :t catMaybes
17:22:30 <lambdabot> [Maybe a] -> [a]
17:23:31 <troydm> mauke: thx
17:23:46 <EvanR> @hoogle [Maybe Bool] -> [Bool]
17:23:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
17:23:50 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
17:23:50 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:23:51 <troydm> mauke: you are a Haskell type jungling magician afterall
17:23:52 <EvanR> \o/
17:24:02 <greyeax> hi i'm trying to implement oauth2 in something i'm working on, and i was wondering if there's a recommended library for dealing with that?
17:24:39 <mauke> welcome to the juggle
17:25:33 <EvanR> #haskell-juggalos
17:26:46 <Eduard_Munteanu> greyeax, I'd look at what Yesod uses
17:26:47 <shachaf> troydm: For what it's worth, if you'd replaced "Bool" with "a" (or even "A"), there would have been many fewer answer to your question.
17:26:54 <greyeax> Eduard_Munteanu: yesod?
17:26:57 <shachaf> Life is easier when you generalize.
17:27:06 <EvanR> Eduard_Munteanu: we had some issues groking wtf Yesod.Auth.GoogleEmail2 is doing...
17:27:14 <Eduard_Munteanu> greyeax, Yesod, the web framework
17:27:16 <bluezone> greyeax: omg lord save you :(
17:27:19 <troydm> shachaf: hahaha, true
17:27:22 <Welkin> Yesod just has a plugin written to work with the Yesod Auth module
17:27:38 <EvanR> greyeax: ime its easier to implement the different parts of oauth2 yourself, with libraries for those things
17:27:56 <EvanR> since the whole workflow is just a shitshow, libraries for it tend to be shitty
17:27:59 <Welkin> there may be an oauth library you can use though. Search hackage
17:28:43 <greyeax> oh thanks i searched hackage and found oauth2
17:28:46 <greyeax> hoauth2 i mean
17:28:52 <greyeax> looks like it'll do the trick i think
17:37:48 <obadz> in pipes, is there a way to split 1 producer into 3 based on guard conditions?
17:39:21 <mvaenskae> bluezone: i am not knowingly doing monads apart for IO
17:39:41 <ggVGc> using the monad instance of maybe is great
17:39:43 <mvaenskae> and i have no idea how monads really are supposed to work but i will get there :)
17:39:54 <EvanR> ggVGc: or the applicative instance
17:40:04 <ggVGc> I don't do that yet :(
17:40:38 <EvanR> > (,,) <$> Just 3 <*> Just 'a' <*> Just []
17:40:40 <lambdabot>  Just (3,'a',[])
17:40:46 <EvanR> > (,,) <$> Just 3 <*> Nothing <*> Just []
17:40:48 <lambdabot>  Nothing
17:40:48 <ggVGc> yeah, nice
17:40:53 <ggVGc> I'll try to do that more
17:41:05 <ggVGc> thanks
17:41:13 <EvanR> liftA3 is probably a shorter way to say that
17:41:34 <mvaenskae> stupid question, but is there a list of all haskell functions and a "how to read" them best? e.g. for cases i read "| i == 2 " as "if/when i==3" and that helps a lot with understanding the code
17:41:58 <EvanR> pronunciation is tricky in haskell
17:42:34 <mvaenskae> EvanR: did you just apply an empty triple to 3 elements?
17:42:45 <EvanR> | i === 2 syntax is actually used in the multi-way if extension so youre not far off with that one
17:42:46 <mvaenskae> and filled the triple with that? :o
17:42:59 <EvanR> (,,) is the constructor for the triple
17:43:07 <EvanR> :t (,,)
17:43:08 <lambdabot> a -> b -> c -> (a, b, c)
17:43:20 <EvanR> > (,,) 'a' True ()
17:43:22 <lambdabot>  ('a',True,())
17:43:34 <mvaenskae> omg
17:43:40 <mvaenskae> mind == blown
17:43:48 <EvanR> you can see that partially applying this can be useful
17:44:04 <EvanR> also theres an extension for using sections with this
17:44:11 <EvanR> > (2,) True
17:44:12 <lambdabot>  (2,True)
17:44:15 <EvanR> > (,2) True
17:44:16 <lambdabot>  (True,2)
17:44:17 <ggVGc> isn't the tuple constructor syntax a syntax special case though?
17:44:29 <EvanR> yes its sugary, like list
17:44:35 <mvaenskae> is there some good intuitive understanding to what a monad actually is and how it plugs into haskell?
17:44:40 <ggVGc> glad we have it
17:44:56 <ggVGc> mvaenskae: jsut write code using monads, and it'll come
17:44:58 <ggVGc> don't thiknk much about it
17:45:15 <ggVGc> mvaenskae: focus on what you want to get done, and you'll soon start seeing the abstraction
17:45:23 <mvaenskae> ggVGc: true, but for now it would help me understanding it as i see it as some collection of types
17:45:25 <bluezone> I don't even know what it is yet :O I blame the elephant in lyah
17:45:40 <ggVGc> mvaenskae: realy, don't, yet
17:45:46 <ggVGc> it's not helpful to you probably
17:46:08 <EvanR> mvaenskae: Monad is a type class yes, but check out Functor or Monoid first
17:46:14 <EvanR> see how those work
17:46:30 <Welkin> you don't need to understand any of the category theory
17:46:38 <Welkin> just know how to use >>= and return
17:46:40 <Welkin> and you are good
17:46:42 <mvaenskae> also when i see a function of type monad, e.g. "mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()" then i couldn't say what the second input can all be
17:46:44 <ggVGc> mvaenskae: you can treat IO as "a thing" and Maybe as another thing, but you won't get any use of understading what "a monad is" before you are comfortable in the use cases of for example IO and Maybe, and can start seeing how they might be similar
17:46:51 <dmj`> mvaenskae: when you gain experienc with a lot of monad instances (i.e. Maybe, List, State, Reader), how these all abstract into the Monad typeclass will become more clear
17:47:09 <EvanR> mvaenskae: heres a specialization of that, mapM_ :: (a -> IO b) -> [a] -> IO ()
17:47:17 <EvanR> i.e. a for loop
17:47:52 <mvaenskae> EvanR: yeah, that is what i intuitivly got then running and decuded that IO belongs to Monad
17:47:55 <ggVGc> mvaenskae: basically, when you've used these various different things, you will see which parts of them are actualyl similar, and then it'll become useful for tou
17:47:58 <ggVGc> you*
17:48:07 <Welkin> I had to actually use a lot of Monads by writing a real project (using Yesod) before I started to feel comfortable working with it
17:48:12 <ggVGc> mvaenskae: but monad is no more special than any other type class
17:48:15 <EvanR> mvaenskae: Foldable types basically act like lists
17:48:20 <ggVGc> like Functor for exampke
17:48:30 <Welkin> just the process of typing it out and reasoning about the types over and over make it clear
17:49:19 <mvaenskae> so for now i should treat is a sort of typeclass that can encompass different types?
17:49:27 <Welkin> mvaenskae: that is all it is
17:49:35 <mvaenskae> i wil check out monoid and functor
17:50:02 <mvaenskae> good, that is all i need to know then for now to be able to use monadic functions
17:50:13 <mauke> Show -> Eq/Ord -> Read -> Num -> Bounded -> Monoid -> Functor -> Applicative -> Monad
17:50:14 <Welkin> "a monad is just a monoid in the class of endofunctors!"
17:50:18 <Welkin> :D
17:50:22 <EvanR> mvaenskae: check this one out...
17:50:24 <mvaenskae> because if i cannot apply them then i might not be able to write code with them :)
17:50:26 <mauke> I think that' a reasonable order for learning typeclasses
17:50:30 <ggVGc> mvaenskae: think about this. If we do some math and learn we can add numbers togeter, and then do some string handling and learn we can concatenate strings to get "a string plus another string", you might start feeling. "Hm, adding thigns together to get a bigger thing that is made up of them seem similar" and then you're essentially talking about the type class Monoid. But you didnt need to know that to be
17:50:33 <Welkin> I love the feeling I got when I finally understand that it isn't a joke, but the truth
17:50:36 <ggVGc>  able to add numbers and concat strings
17:50:36 <Welkin> hahaha
17:51:20 <bluezone> > :t GT
17:51:21 <mvaenskae> what would an endofunctor be?
17:51:22 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:51:29 <bluezone> :(
17:51:33 <EvanR> mvaenskae: nvm, just take that (,,) examples from earlier and chew on that
17:51:36 <mauke> :t GT
17:51:37 <lambdabot> Ordering
17:51:39 <Welkin> class => category*
17:51:40 <Welkin> lol
17:51:43 <bluezone> i see
17:52:08 <bluezone> so those are automatically defined and accessible as part of the language i suppose
17:52:14 <bluezone> :t EQ
17:52:15 <lambdabot> Ordering
17:52:21 <mauke> they're in the standard library somewhere
17:52:23 <Welkin> mvaenskae: a more specific functor
17:52:24 <mauke> @index Ordering
17:52:24 <lambdabot> Data.Ord, Prelude, GHC.Types
17:52:25 <EvanR> bluezone: data Ordering = LT | EQ | GT
17:52:33 <mauke> bluezone: defined in Data.Ord
17:52:57 <ggVGc> mvaenskae: you really should ignore what an endofunctor is at this time
17:53:01 <ggVGc> (I barely know)
17:53:04 <ggVGc> and I write okay haskell
17:53:06 <ggVGc> I think
17:53:09 <ggVGc> at least it does stuff
17:53:18 <EvanR> ignore functors, also learn Functor and pretend its not called that? ;)
17:53:28 <bluezone> > putStrLn "I write okay haskell!"
17:53:30 <lambdabot>  <IO ()>
17:53:31 <ggVGc> I call all my functors EvanRs
17:53:34 <bluezone> fk you
17:53:41 <mvaenskae> Welkin: just for readability, how should i read >>= when i see it in code?
17:53:44 <EvanR> bluezone: it has a point
17:53:44 <mauke> lambdabot doesn't IO
17:53:49 <ggVGc> mvaenskae: "bind"
17:53:50 <Welkin> mvaenskae: bind
17:53:52 <bluezone> :(
17:53:54 <mauke> mvaenskae: >>=
17:54:17 <mauke> inb4 modem
17:54:26 <mvaenskae> :D
17:54:40 <EvanR> mvaenskae: its tough to give an alternative english skin to everything in haskell
17:54:45 <mvaenskae> so i bind what is left to the function on the right of the op?
17:54:59 <maerwald> mauke: and it's an incredibly ez way to disallow "code injenction" isn't it? I can't imagine how annoying that must be with other lambadbot-like programming language bots
17:55:17 <mvaenskae> ggVGc: then i shall google it if you don't tell me =p yeah, we live in a strange time :D
17:55:24 <mauke> maerwald: you basically chroot them off
17:55:29 <maerwald> urgh
17:55:34 <EvanR> > Just 3 >>= \i -> Just (i+1) -- mvaenskae 
17:55:34 <mauke> and impose resource limits
17:55:36 <lambdabot>  Just 4
17:55:39 <EvanR> > Nothing >>= \i -> Just (i+1) -- mvaenskae 
17:55:41 <lambdabot>  Nothing
17:55:45 <ggVGc> mvaenskae: it won't do you much good
17:55:48 <ggVGc> but feel free
17:55:53 <EvanR> (this is just the same thing as using fmap from the Functor class)
17:56:44 <EvanR> mvaenskae: Maybe's Functor, Applicative, and Monad behaves like a shortcircuiting failure on Nothing
17:56:46 <mvaenskae> i guess a lot of haskell functions are minor transformations or one step from the other
17:57:00 <mauke> oh, yes
17:57:16 <mauke> @src any
17:57:16 <lambdabot> any p = or . map p
17:57:34 <mauke> @src or
17:57:34 <lambdabot> or = foldr (||) False
17:57:34 <mvaenskae> EvanR: that is what i understood, the moment Nothing invokes the result will be Nothing
17:57:40 <EvanR> right
17:57:54 <EvanR> other types will implement Functor and Monad differently
17:58:10 <EvanR> and Applicative, which is now required for Monad
17:59:03 <mvaenskae> i think i made the right decision to give haskell a proper try :)
17:59:25 <mauke> :t try
17:59:26 <lambdabot> Exception e => IO a -> IO (Either e a)
17:59:58 <dmj`> mvaenskae: haskell is the gift that keeps on giving
18:00:07 <EvanR> in a good way?
18:00:12 <mvaenskae> and you guys in here are helping me with understanding it; thanks a lot for that guys and the patience you bring towards my stupid questions
18:00:17 <dmj`> EvanR: depends on who you ask
18:00:24 <dmj`> =)
18:01:08 <mvaenskae> no programming language is perfect, but some do some things better than others and i can somewhat put haskell now in the correct corner
18:02:10 <Cale> mvaenskae: Yeah, it's not perfect, but it sometimes manages to look that way by contrast...
18:03:11 <maerwald> mvaenskae: barely suited for production though, because you must think before you type
18:03:20 <maerwald> (I'm only half joking)
18:03:29 <mvaenskae> the way it was described to me the first time made it to me sound like it'll program itself like this: https://i.imgur.com/GcZFBaT.png
18:03:56 <mauke> ah, declarative programming
18:04:12 <mauke> "No."
18:22:04 <bluezone> as a first function I am attempting to implement mergesort lol
18:22:42 <kostmo> Looking for a GUI haskell IDE where "jump to definition" works properly.  Any success stories?  Could get neither Atom nor Leksah to work.
18:23:33 <Welkin> kostmo: use emacs and M-x imenu
18:27:06 <kostmo> Never used emacs before.  I would be willing to learn, but am trying to sell my team on using Haskell; a GUI would help
18:27:51 <Welkin> not sure what you need a gui for
18:28:07 <EvanR> kostmo: so theres an intelliJ plugin, haskforce IDE
18:28:21 <EvanR> havent tried it but the animated gifs look cool
18:28:36 <Welkin> haskell support on emacs is very good
18:28:43 <EvanR> but then you might have to sell them on intelliJ
18:30:11 <kostmo> I did give haskforce a try, but it was flaky; worse than Atom
18:31:03 <EvanR> vim and emacs both have GUIs but not sure how seriously anyone takes them
18:31:25 <Welkin> lol, not seriously at all
18:31:29 <Welkin> the emacs gui is just a facade
18:31:41 <EvanR> shouldnt that be what a GUI is ? 
18:31:42 <Welkin> it made me quit emacs in a rage many years ago
18:31:50 <Welkin> then I learned emacs the right way
18:31:57 <Welkin> by disabling the gui entirely
18:32:45 <kostmo> my teammates are still very attached to the mouse
18:32:54 <EvanR> kostmo: sublime haskell plugin?
18:34:17 <EvanR> that is very popular as far as mouse support goes
18:34:37 <EvanR> i feel like whatever the plugin does or doesnt do, people will like it because its sublime
18:37:53 * EvanR recoils in horror at sublime haskell plugins animated gifs showing non-monospace fonts 
18:37:54 <bluezone> is there a function I can use to split an array into two? For example 2 sub-arrays
18:38:03 <EvanR> :t breakAt
18:38:05 <lambdabot>     Not in scope: ‘breakAt’
18:38:05 <lambdabot>     Perhaps you meant one of these:
18:38:05 <lambdabot>       ‘break’ (imported from Data.List),
18:38:07 <EvanR> :t break
18:38:08 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:38:16 <bluezone> oh
18:38:18 <EvanR> :t splitAt
18:38:19 <lambdabot> Int -> [a] -> ([a], [a])
18:38:43 <EvanR> Vector has something like this too
18:53:58 <bluezone> this is quite difficult
18:55:08 <bluezone> Oh my god it compiled
18:55:27 <bluezone> :O :O :D
19:03:36 <EvanR> bluezone: uh oh
19:03:58 <bluezone> i am able to sort an array of 2 numbers now
19:06:29 <rom1504> amazing
19:08:33 <lpsmith> bluezone:  mergesort in Haskell is a lot easier from the bottom up
19:08:46 <bluezone> rom1504: ty
19:08:58 <lpsmith> Split the list into single element lists,  then merge those into two-element lists,  merge those into four-element lists, etc
19:09:07 <bluezone> i think I am doing something similar
19:09:22 <Welkin> bottom up is the only way to use mergesort! :O!
19:09:32 <Welkin> it is so simple
19:09:42 <Welkin> in fact, Data.List.sort is a mergsort
19:11:41 <bluezone> if I import Data.List
19:11:48 <bluezone> sort should be available to me right?
19:11:52 <Welkin> yes
19:11:57 <Welkin> but it only works on lists
19:12:03 <Welkin> of course
19:12:27 <bluezone> yeah I did _assort xs ys = sort xs ++ ys
19:12:55 <bluezone> wondering why hum.. probably my fault
19:13:25 <Welkin> > sort . take 20 $ randomRs (0,20) (mkStdGen 0)
19:13:27 <lambdabot>  [0,0,2,4,7,7,10,10,12,12,12,12,13,14,14,15,15,17,17,19]
19:13:29 <Welkin> :D
19:13:38 <bluezone> what is the dollar sign for
19:13:45 <Welkin> it is a shorthand for parentheses
19:13:54 <Welkin> has the lowest precendence
19:14:03 <bluezone> i see
19:14:08 <Welkin> it means "evaluate everything to the right before anything on the left"
19:14:28 <Welkin> > sort . take 20 (randomRs (0,20) (mkStdGen 0))
19:14:29 <lambdabot>      Couldn't match expected type ‘a -> [a1]’
19:14:30 <lambdabot>                  with actual type ‘[Integer]’
19:14:30 <lambdabot>      Possible cause: ‘take’ is applied to too many arguments
19:14:39 <Welkin> > (sort . take 20) (randomRs (0,20) (mkStdGen 0))
19:14:40 <lambdabot>  [0,0,2,4,7,7,10,10,12,12,12,12,13,14,14,15,15,17,17,19]
19:14:46 <bluezone> ew
19:14:48 <Welkin> just less typing
19:19:11 <bluezone> can I have nested guards?
19:20:42 <Welkin> you can use a comma to add more expressions I think
19:21:20 <bluezone> I'm so confused lol
19:21:55 <Welkin> > let f a | a > 0, a < 5 = 1 | otherwise = 0 in f 6
19:21:57 <lambdabot>  0
19:22:02 <Welkin> > let f a | a > 0, a < 5 = 1 | otherwise = 0 in f 2
19:22:03 <lambdabot>  1
19:22:32 <Welkin> it's like &&-ing them together
19:25:37 <bluezone> Okay starting with this example was a bit to ambitious, I don't even really know how to do it imperatively lol
19:25:53 <Welkin> don't think imperatively
19:26:14 <Welkin> think about transforming the data by running it through a pipeline of functions
19:47:26 <emmanuel_erc> Has anyone here ever used the C++ library linbox?
19:49:22 <bluezone> What is wrong with this? https://github.com/1337micro/haskell-practice/blob/master/tias/1to10/1.hs 
19:49:31 <bluezone> parse error (possibly incorrect indentation or mismatched brackets) at line 7
19:49:52 <EvanR> line 6 you missed the =
19:50:57 <bluezone> I see, I tried adding it and I got another error so I assumed it was syntactically incorrect haha
19:51:00 <EvanR> no help from the compiler there
19:51:24 <EvanR> if you have issues like this try pasting the error along with the code
19:51:40 <bluezone> ok
19:52:35 <montagy> print $ lastEle [3,2,4,2]
19:52:53 <bluezone> yeah I got that too
19:52:59 <bluezone> first problem, done!!
19:53:10 <Welkin> problem?
19:53:16 <Welkin> what is this? homework?
19:53:24 <bluezone> Welkin: https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
19:53:27 <Welkin> lol
19:53:29 <bluezone> 98 more lol
19:53:30 <Welkin> oh, that
19:53:32 <Welkin> never did it
19:54:28 <geekosaur> it's not very good and should probably be removed from the wiki
19:54:53 <geekosaur> it's a crude translation from lisp which was a crude translation from prolog
19:54:57 <geekosaur> or something like that
20:02:45 <mikail`> I noticed this class definition (https://github.com/ekmett/lens/blob/bdb7e9142e83ff92a3f914a7ffc7ea4f5582a6d9/src/Control/Lens/Internal/Review.hs). It defines a class called Reviewable but it does not declare any function types.
20:03:32 <mikail`> Is this simply to create a class definition in order to constrain the types that other class definitions can accept?
20:03:37 <glguy> It's an alias for two classes
20:03:53 <shachaf> mikail`: You get the property Reviewable needs (phantom in the first argument) from the two superclasses.
20:04:38 <mikail`> Is this an abuse of type classes?
20:04:54 <mikail`> or is it an accepted idiom?
20:06:17 <mikail`> the reason I am asking is that I am thinking of doing something similar in my own Haskell library I am implementing. I want to constrain the types that a particular class can accept.
20:07:36 <glguy> This is just making an alias for two classes. The more modern way to do that is probably with the constraint kinds extension and a type synonym
20:08:49 <mikail`> glguy: I will explain the design I am trying to go with below
20:10:24 <mikail`> Say I have some types A B C D and I want to implement ad-hoc polymorphism in the usual way for some function f: Say class Foo a where f :: a -> String
20:10:51 <mikail`> Now I want to constrain the types that Foo can accept
20:10:57 <mikail`> to just A B C D
20:11:36 <mikail`> so I was thinking of creating another class which I know these types have a property of (and which makes sense), say class Bar a 
20:11:46 <mikail`> and I make the instances
20:11:50 <mikail`> instance Bar A
20:11:55 <mikail`> instance Bar B
20:11:58 <mikail`> and so on
20:12:11 <mikail`> so now I can constraint class (Bar a) => Foo a
20:12:19 <mikail`> is that the right way to go?
20:21:34 <mcuramen> have you guys read Purely Functional Data Structures
20:21:36 <mcuramen> ?
20:24:34 <ggVGc> silico04:52 ��garrydang� [~garrydang@ppp121-44-220-58.lns20.syd7.internode.on.net] quits (Quit: garrydanger)
20:25:55 <pavonia> mikail`: Do you mean it shouldn't be possible to define a new type E which can also be made an instance of Bar?
20:28:00 <mikail`> pavonia: the idea is not able able to create instances of Foo which are not instances of Bar
20:29:15 <pavonia> Ah, that's the way to go then
20:29:51 <mikail`> it just seemed wierd to me that I am creating a class called Bar which has no function definitions
20:30:01 <mikail`> i was wondering if I was abusing type classes here
20:30:20 <mikail`> but then I saw the same in the Lens library
20:30:45 <nitrix> Isn't this a little redundant?
20:31:18 <pavonia> Yeah, why do you want the Bar constraint anyway?
20:31:26 <nitrix> Why not just have the instances Foo A, Foo B, and so on?
20:31:58 <mikail`> because I don't want anyone creating Foo Int instances
20:32:01 <mikail`> for example
20:32:07 <mikail`> that wouldn't make sense
20:33:10 <pavonia> And what prevents them to define Bar Int?
20:33:12 <nitrix> How do you prevent them from making Bar Int?
20:33:28 <mikail`> good point, I can't
20:33:42 <mikail`> so I guess there's no point enforcing it
20:34:00 <nitrix> If there's a solution to it, it wont be with an additional class layer, I think.
20:34:30 <nitrix> I think what you want is a frankenstein version of FunDeps.
20:34:41 <pavonia> It should be possible with closed type familes, I guess
20:35:04 <mikail`> i was thinking about type families but I couldn't wrap my brain around them
20:35:50 <nitrix> Writing generic libraries generally lead to even more generalization and things to learn :P
20:36:08 <mikail`> yup
20:37:06 <mikail`> with type families they kind of fit the problem I think because I can essentially say that for a fixed type, only the following set of types are applicable
20:37:30 <mikail`> i.e. the notion of indexing a set of types by some other type
20:38:12 <mikail`> I'm reading the GHC user guide and the haskell wiki trying to grok them 
20:54:50 <Iceland_jack> mikail`: It's possible to do this
20:57:09 <Iceland_jack> afk sorry
21:05:30 <dmj`> :t (<$)
21:05:32 <lambdabot> Functor f => a -> f b -> f a
21:10:16 <nitrix> > 3 <$ Just 5
21:10:17 <lambdabot>  Just 3
21:10:51 <Iceland_jack> > 3 <$ "hello world"
21:10:53 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3]
21:28:31 <lpaste> ali_bush pasted “Chapter26 Haskellbook” at http://lpaste.net/168042
21:29:34 <ali_bush> hey.   Im having trouble with this example about monad transformers from haskell book and would really appreciate some help on it
21:31:33 <dmj`> ali_bush: what is the type of runMaybeT
21:32:11 <ali_bush> the actual function,  or the actual type of embedded'?
21:34:19 <ali_bush> runMaybeT :: MaybeT m a -> m (Maybe a)
21:34:21 <dmj`> ali_bush: the issue is that the type of embedded' returns MaybeT, but the return type of runMaybeT is not 'MaybeT'
21:34:49 <dmj`> ali_bush: yes, you can think of this exercise like peeling layers off of an onion
21:35:37 <ali_bush> I think I got embedded' to have a type of MaybeT (ExceptT String (ReaderT () IO)) (Maybe Int)
21:35:44 <ali_bush> at some point :)
21:37:24 <pavonia> ali_bush: Start from the innermost layer, ReaderT () IO here, and build a value of that type. Then you can use that to add the outer layers
21:38:07 <pavonia> ReaderT () IO Int, that is
21:43:18 <ali_bush> pavonia: so (return 1) :: ReaderT () IO Int
21:43:38 <ali_bush> return (Just 1) :: ReaderT () IO (Just Int)
21:43:43 <ali_bush> etc, etc
21:46:05 <pavonia> ali_bush: Well, you could also use "return 1" for the whole monad stack, but I thought you were trying to build the value using the actual monad transformer constructors
21:46:44 <pavonia> Because you already have that for embedded
21:47:10 <ali_bush> yeah sorry the paste doesn't have a question in it
21:47:28 <ali_bush> embedded' = ??? (const (Right (Just 1)))
21:49:53 <pavonia> So how could you build a value of type MaybeT (ExceptT String (ReaderT () IO)) Int, given a value of type ExceptT String (ReaderT () IO) Int?
21:55:46 <ali_bush> thats a good question :)   but don't I already have a Maybe in there with the Just 1.   So its a ExceptT String (ReaderT () IO) (Maybe Int) ?
21:57:18 <ali_bush> maybe not,  doesn't type check
21:59:15 <pavonia> const (Right (Just 1)) doesn't really fit in there, it hasn't any monadic context in it
21:59:35 <pavonia> Note that the innermost value must be something of type IO
22:02:37 <ali_bush> yeah,  thats where the return from previously came from.   as thats the only way I can get into IO right (ignoring pure obviously)
22:03:29 <pavonia> There are mayn IO-related functions you could use
22:03:38 <pavonia> :t putStrLn
22:03:39 <lambdabot> String -> IO ()
22:03:42 <pavonia> :t getLine
22:03:43 <lambdabot> IO String
22:32:37 <greyeax> there are currently 1337 users in here
22:32:58 <greyeax> crap
22:35:17 <saurabhnanda> can anyone help me with http://stackoverflow.com/questions/38035534/how-to-build-a-custom-reader-monad-along-with-a-custom-typeclass
22:37:32 <mjrosenb> so... is there a way to interpret a ByteString as a series of Chars?
22:37:49 <coppro> saurabhnanda: why can't you use a ReaderT?
22:37:57 <mjrosenb> I need to do some hueristic text munging, and I only have a ByteString.
22:37:59 <coppro> SqlPersistT is implemented as a ReaderT internally but it doesn't expose MonadReader
22:38:21 <saurabhnanda> coppro: that's a simplified example. A lot of my code that depends on NwConfig is in the SqlPersistT monad, which itself uses a ReaderT
22:38:22 <Clint> mjrosenb: you'd have to pick a particular character encoding to convert it
22:38:58 <saurabhnanda> coppro: okay, I'll look into that. The other reason is to understand this stuff better.
22:38:58 <mjrosenb> Clint: I'm ok with that.
22:39:23 <mjrosenb> I don't see anything in Data.ByteSting that gives a Char or a String.
22:39:40 <mjrosenb> I'd *love* ByteString -> (String, ByteString)
22:40:05 <mjrosenb> well Encoding -> ByteString -> (String, ByteString)
22:40:26 <mjrosenb> which decodes what it can, and gives the rest when it reaches something it can't decode.
22:40:31 <Clint> mjrosenb: http://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html
22:42:36 <m1dnight_> Im trying to use QuickCheck for the sake of learning to use it. My use case would be an implementation of the STLC. That's not a good use case, right?
22:42:46 <m1dnight_> I think I can't enfore any invariants of randomly generated expressions.
22:42:47 <pavonia> mjrosenb: The text package has functions for exactly that
22:44:43 <mjrosenb> pavonia: converting between ByteString and String?
22:44:58 <Clint> if you use Text as an intermediary
22:45:09 <pavonia> ByteString and Text, but you can unpack the Text to String
22:47:18 <coppro> prefer Text to String wherever possible
22:47:33 <mjrosenb> is there a text function that reads all the data it can without blocking from an FD?
23:25:51 <mjrosenb> pavonia: I'm not seeing a function that can split a ByteString like that.
23:26:23 <pavonia> Splitting?
23:26:39 <pavonia> Data.Text.Encoding has conversion function
23:28:14 * hackagebot docvim 0.3.2.1 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.2.1 (wincent)
23:28:36 <mjrosenb> pavonia: yeah, and the With functions all have ways of converting invalid bytes into chars, but I'm not seeing something that will let me just keep the extra bytes as a ByteString (or a list of bytes)
23:37:14 <pavonia> Hhm, text doesn't seem to be the right package for that then
23:40:43 <mjrosenb> bah :-(
23:41:21 <mjrosenb> when I was told "this may be complex", I assumed that was because there would be some tricky logic involced
23:41:32 <pavonia> You could use decode from utf8-string in a loop
23:41:32 <mjrosenb> not because the functions needed simply don't exist.
23:42:06 <mjrosenb> pavonia: just append more characters until it decodes?
23:43:00 <pavonia> No, use decode to read a character. If it fails, retrun the rest of the input, otherwise drop the read number of chars from the bytestring and go on
23:47:36 <mjrosenb> decode? there are a bunch of decodeFORMAT functions, but they all return Text, not Char.
23:49:28 <geekosaur> check the GHC.IO.Encoding hierarchy
23:50:35 <pavonia> mjrosenb: Not from text, from the utf8-string package
23:50:59 <mjrosenb> pavonia: ahh.
