00:00:11 <zomg> it's DDR3 I'm fairly sure :P
00:00:40 <EvanR> wam
00:00:44 <Myrl-saki> zomg: Ah.
00:01:08 <Myrl-saki> Hmmm
00:01:17 <Myrl-saki> I'll probably be using windows to test out my builds.
00:01:34 <Myrl-saki> Hmmm
00:01:53 <Myrl-saki> The only thing I can think of is VMs and Emacs.
00:02:30 <zomg> well you can get 16 gigs of DDR4 for like 100 bucks
00:02:36 <zomg> so might as well?
00:04:50 <Myrl-saki> zomg: Actually, I'm planning to keep the total cost below $400 since I'm poor.
00:05:09 <Myrl-saki> zomg: Now I'm contemplating between 2x8GB and 2x4GB.
00:05:36 <Myrl-saki> But I remembered that I'll be running VMs, so I'll probably go with 16 GB.
00:05:46 <Myrl-saki> I hope there'll be 4-slot zens though.
00:06:01 <Adeon> I think 16 gigs is probably better here if you are going to do VMs
00:06:09 <zomg> My guess is there will be, considering they'll probably have dual channel ram
00:06:12 <Adeon> one particular thing for me is compiling lots of haskell dependencies on the 8gb machine
00:06:14 <Myrl-saki> Adeon: Yeah, that's what I'm thinking of.
00:06:18 <Adeon> some packages are big and need lots of memory
00:06:39 <Myrl-saki> Adeon: I was able to  compile all things Haskell(that I needed) on 1.5 GB of RAM.
00:06:52 <Myrl-saki> Well, I guess it was swapping so hard.
00:07:21 <Myrl-saki> Compiling Idris would probably have taken 24 hours, I stopped it at 12. On my laptop it took 1.5 hours.
00:07:55 <Myrl-saki> So I'll be going with a DDR4.
00:08:17 <Myrl-saki> Should I get an SSD or an HDD? There's no SSHD in my local places, which makes me quite disappointed.
00:08:52 <zomg> I've got a 256 gig SSD on my MBP which seems sufficient
00:09:04 <Myrl-saki> zomg: I'm planning to get a 120 gig one.
00:09:26 <zomg> That'll probably work at least for a while, but you might want to get a big HDD for storage later
00:09:28 <Myrl-saki> The only thing that I can think of that I'll be losing is muh animu, but I can just move that to my laptop(s).
00:09:32 <zomg> ...especially considering you did mention VMs :)
00:09:56 <Myrl-saki> zomg: Oh right... thanks for reminding me that I'm going to be using VMs. I forgot. ._.
00:10:00 <zomg> heh
00:10:15 <Myrl-saki> I'll be getting a 256 gb one. The 120 would have been disastrous lol.
00:10:21 <zomg> yeah I actually have my windows 7 installed on a 80 gig SSD :P
00:10:38 <zomg> but I have several TBs worth of HDDs and another slightly larger SSD as well
00:11:16 <zomg> Current free space on the OS drive 5 gigs or so, 80 is kidna pushing it with windows at least. I don't have any other extra stuff installed there
00:11:20 <Myrl-saki> How about the CPU? ofc. I'm going for a skylake.
00:11:55 <Myrl-saki> Looking at benchmarks, the i3 is way bad compared to the lowest end i5.
00:12:03 <Myrl-saki> For about only 50% more.
00:13:18 <Myrl-saki> Actually, not sure if it's the lowest end, but I'm talking about i5-6400 vs i3-6100.
00:14:29 <zomg> I'd go for the overclockable ones, other than that can't really comment since I have no idea :)
00:14:41 <zomg> Personally I'm eyeing the new Broadwell-E's :P
00:17:32 <Myrl-saki> zomg: I looked at the clock speeds.  4 GHz on an i7-6700k an 2.7 on an i5-6400. I might want to look into this since I want to save time since I might be compiling a lot of stuff.
00:18:19 <EvanR> cant wait until we get visible light frequency cpu
00:18:25 <EvanR> its be like tron
00:18:43 <xvilka> hi! I need to embed ability to run haskell scripts from C program. I've seen https://en.wikibooks.org/wiki/Haskell/FFI#Calling_Haskell_from_C but it require to add ghc-generated *.h file in the C program. Is it possible to add the ability to run any kind of haskell script? Like e.g. embedding python interpreter?
00:19:08 <zomg> Myrl-saki: if you get an i5 with the K suffix in the number then you can OC that
00:19:24 <zomg> my ancient Core i7 920 has base clock 2.4 and you can OC it to 4 GHz no problem
00:22:33 <Raiva> .
00:22:53 <Myrl-saki> EvanR: LOL
00:23:10 <Raiva> Hi
00:25:16 <Myrl-saki> Raiva: hallo
00:39:28 <Maxdamantus> xvilka: can you not just have your C program invoke GHC?
00:39:49 <Maxdamantus> xvilka: $ ghc -e 'putStrLn "hello"'
00:41:30 <xvilka> Maxdamantus: well, I can, but I want to export some C structs as Haskell objects
00:43:13 <Maxdamantus> You can write C code that generates the Haskell to describe them.
00:43:17 <Maxdamantus> what's the actual objective?
00:44:55 <Maxdamantus> also note that Haskell is usually compiled to native code. The normal Python implementation is one of the few popular language implementations that completely avoids that.
00:45:11 <Maxdamantus> CPython or whatever.
00:45:53 <xvilka> Maxdamantus: I want to add support to run r2pipe.hs from radare2, and RCore instanse (describing current session) from radare2 should be exported to haskell session
00:46:48 <xvilka> https://github.com/radare/radare2-bindings/tree/master/r2pipe/haskell - this is r2pipe.hs
00:47:16 <xvilka> and this is an example how it's done for python https://github.com/radare/radare2-bindings/blob/master/libr/lang/p/python.c
00:47:23 <xvilka> so I want to achieve the same
00:47:27 <xvilka> but for haskell
00:48:07 <EvanR> @pl \x -> a >>= \f -> f x
00:48:08 <lambdabot> (a >>=) . flip id
00:48:54 <EvanR> :t flip id
00:48:55 <lambdabot> b -> (b -> c) -> c
00:49:04 <EvanR> :t const
00:49:06 <lambdabot> a -> b -> a
00:50:09 <EvanR> flip :: ((b -> b) -> (c -> c)) -> (b -> (b -> c) -> c) ;)
00:52:10 <Maxdamantus> xvilka: I imagine you'd want to simply write something that can call into some C code, not something that lets you execute Haskell source code from C.
00:55:10 <xvilka> Maxdamantus: well, separate haskell module/app/whatever interacting with r2 is already done, I just want to run haskell scripts from radare2 itself
00:55:47 <xvilka> lemme show you
00:56:27 <xvilka> https://asciinema.org/a/16ko4jd1e6kdrqkqjxeu248hm - this is e.g. r2pipe.py + ipython
00:57:08 <xvilka> I want to add the same but for Haskell Prelude (or, at least interpret *.hs (or agda in future))
01:07:53 <offlink> http://espedito.homepc.it onehost..)
01:40:04 <Zemyla> GHC should, on April Fool's Day, if it finds a syntax error caused by a double colon where it shouldn't be, say "Unexpected T_PAAMAYIM_NEKUDOKAYIM".
01:40:30 <Zemyla> Oh, and if the error is being sent to stdout.
01:40:37 <Zemyla> *or stderr.
02:08:11 <kern_> I want to parse "base-4.9.0.0/GHC/Real.hs" with haskell-src-exts but it results in: ParseFailed (SrcLoc "<unknown>.hs" 286 42) "Parse error: `"
02:08:18 <kern_> > readFile "base-4.9.0.0/GHC/Real.hs" >>= (runCpphs defaultCpphsOptions "") >>= return.unlines.(drop 1).lines >>= return.parseModule
02:08:20 <lambdabot>  Not in scope: ‘runCpphs’Not in scope: ‘defaultCpphsOptions’Not in scope: ‘pa...
02:08:39 * hackagebot pulse 0.1.0.0 - Synchronize actions to a time pulse  https://hackage.haskell.org/package/pulse-0.1.0.0 (AlexanderThiemann)
02:10:45 <kern_> I read the file, pass it through cpphs to remove that stuff, then I drop the irst line becaus cpphs inserts some funny stuff and everything works fine utnil some '`' symbol 
02:12:03 <mauke> what's in base-4.9.0.0/GHC/Real.hs and what do you get from cpphs?
02:13:53 <kern_> actually I parse all *.hs files in the base package to find 'class' definitions, I just ignore the rest. 
02:14:24 <kern_> I need cpphs to remove the preprocessor makros, hse can't parse them
02:14:46 <mauke> ?
02:15:36 <kern_> cpphs only removes the #ifdef stuff, the rest stays the same (except it inserts a first line for whatever reason)
02:16:19 <mauke> ?
02:20:06 <kern_> I can manually remove the "#ifdef" stuff from Real.hs, then I can run: readFile "base-4.9.0.0/GHC/Real.hs" >>= return.parseModule
02:20:52 <mauke> are you talking to me?
02:23:03 <kern_>  i think so
02:24:20 <mauke> I'm confused because what you're saying seems to have no relation to what I asked
02:28:29 <kern_> I don't really know what is inside Real.hs, I want to parse it to find type class definitions and for what i get from cpphs, is a string, but if i remove the '#ifdefs' from Real.hs I don't need cpphs at all so I can skip that step and still get a ParseFailed
02:29:42 <kern_> to get the Real.hs file I run `cabal get base` and then it is in "./base-4.9.0.0/GHC/Real.hs"
02:35:10 * mauke goes back to debugging the perl lexer
02:48:51 <chipf0rk> test
03:03:57 <mikail_> Hi, please can some explain what type families are for in Haskell?
03:04:12 <mikail_> I know what type classes are for but not sure about type families
03:04:34 <pavonia> They are basically functions on the type level
03:04:53 <mikail_> is to group certain types of functions according to behaviour?
03:05:50 <pavonia> Not really grouping, more a mapping
03:05:53 <EvanR> you can use them whenever you want to write a polymorphic function involving two types where one of the types is a function of the other
03:06:16 <EvanR> cool :: f -> MyFamily f -> Result
03:06:35 <EvanR> will only type check if the second arg has type MyFamily f
03:07:21 <mikail_> but doesn't that type checking already happen ?
03:07:43 <EvanR> MyFamily f is a type expression evaluated at compile time, for example the rule might be
03:07:58 <EvanR> type instance MyFamily Int = Char
03:08:13 <EvanR> cool 3 'x' will type check
03:08:21 <EvanR> cool 'x' 3 wont
03:08:41 <EvanR> you can declare many instance rules for a given family
03:09:22 <mikail_> give me a sec to absorb that :) - I'm a noob
03:09:56 <EvanR> (the letter f is probably a bad choice for this example)
03:10:03 <EvanR> pretend like its t
03:10:12 <mikail_> is MyFamily a functor in your example?
03:10:20 <EvanR> no, its a type family
03:11:20 <mikail_> type instance MyFamily Int = Char - I don't get what the Char is doing there
03:11:23 <mikail_> please explain that
03:11:29 <EvanR> thats the result of the computation
03:11:57 <mikail_> oh I get it now
03:12:03 <mikail_> wowzers!
03:12:04 <EvanR> f 'x' = 3 -- this is a regular value level definition
03:12:11 <EvanR> similar
03:12:32 <mikail_> great - thank you for explaining that!
03:12:44 <mikail_> i tried to read a paper on it but got even more confused - lol
03:37:19 <haskell269> I am a bit new to haskell, but I think the problems with the negative litteral is because of lack of overloading in functions
03:38:04 <haskell269> so if (-) was defined with 2 definitions such as (-) :: Num a => a -> a -> a and (-) :: Num a => a -> a
03:38:22 <haskell269> and let the type system figure out which signature does not fail
03:38:33 <haskell269> then i do not see why this will not work
03:38:38 <haskell269> are there counter examples?
03:38:58 <haskell269> does it make type inference much harder?
03:39:13 <EvanR> unary minus is the only unary operator in the language, its not a type inferrence issue, its a parsing issue
03:39:19 <Rembane> I think it makes some certain bugs more common since negation and subtraction are two different beasts.
03:39:20 <haskell269> for this simple case at least it doesn't seem to be very hard
03:39:27 <haskell269> true
03:39:30 <haskell269> but this would solve it
03:39:33 <haskell269> no?
03:39:48 <EvanR> haskell doesnt allow unary operator functions... except theres that one built in, thats it
03:39:49 <haskell269> plus u'll be able to define unary operators this way too
03:40:35 <int-e> some people like having an instance  Num a => Num (b -> a)  that operates pointwise
03:40:45 <int-e> :t (-) 1
03:40:46 <lambdabot> Num a => a -> a
03:41:02 <int-e> haskell269: so that could also be point-wise negation with your proposal
03:41:28 <int-e> err, sorry, the pointwise constant function returning -1
03:41:33 <haskell269> yes
03:42:01 <int-e> but generally type-directed disambiguation is a very slippery road.
03:42:15 <haskell269> hmm
03:42:24 <EvanR> you can try it in idris, its helluva fun
03:42:44 <EvanR> youre free to have as many things of the same name as you want
03:42:58 <haskell269> but it's interesting to see that this problem arises because you can't do that in haskell
03:43:09 <haskell269> no one gets to  have unary operators :(
03:43:11 <int-e> EvanR: but do you get any useful error messages if you do that?
03:43:25 <EvanR> yes almost certainly get an error message
03:43:44 <int-e> EvanR: emphasis on *useful*
03:43:50 <EvanR> you get a list of alternatives and you get to disambiguate them yourself
03:44:04 <haskell269> if both cases gave errors you can list both in the error message
03:44:05 <haskell269> yes
03:44:20 <int-e> so if you overdo it you'll wait all day for the error message to finish printing, wonderful!
03:45:20 <haskell269> well it's better than not having unary operators
03:45:41 <haskell269> plus it could be done in an extension i guess
03:45:50 <EvanR> the parsing weirdness, the lack of unary operators, and type directed disambiguation are three different things
03:45:53 <int-e> (It can work to some extent. I've seen that Isabelle does this... but it already warns when parsing is ambiguous, even if only one alternative type-checks)
03:47:22 <haskell269> for the (-) case I can't immediately think of a case where issues would happen
03:48:44 * hackagebot pipes-lzma 0.1.0.0 - LZMA compressors and decompressors for the Pipes package  https://hackage.haskell.org/package/pipes-lzma-0.1.0.0 (BenGamari)
03:57:39 <int-e> haskell269: The (-) 1 ambiguity I pointed out is real: It could be subtraction and of type Num a => a -> a, or negation and of type Num (a -> a) => a -> a. It gets worse if thee is a Num instance for functions defined because then both types simplify to Num a => a -> a.
03:58:38 <int-e> I'm still getting this wrong; the second would be Num (a -> b) => a -> b. Tricky!
03:59:05 <EvanR> -XDoWhatIMeanNotWhatISay
03:59:29 <int-e> EvanR: I need that flag for my brain ;-)
03:59:36 <Rembane> Ah, the infamous INTERCAL runtime flag.
04:05:04 <EvanR> >_< gah if "when" and "forever" were in the prelude
04:05:09 <EvanR> or just when
04:09:02 <Rembane> Aren't they in Control.Monad?
04:09:46 <EvanR> its common that i need just when, so i need to import the whole module
04:10:14 <EvanR> maybe i need a new prelude
04:47:44 <siwica> I am getting a "parsing.hs:7:1: Parse error: naked expression at top level" exception when trying to compile the following: http://lpaste.net/165284
04:48:04 <siwica> Why is this? Has anything changed with ghc the causes this error?
04:48:09 <siwica> *that
04:48:23 <coppro> symbol oneOf "!#$%&|*+-/:<=>?@^_~"
04:48:27 <coppro> you don't have an =
04:48:48 <mikail_> Hi, I have written a HSpec test and the function I am testing returns a Double. Is there a facility in HSpec to say that the value is within a certain tolerance so that the tests pass? Currently I am getting:        expected: 4.76         but got: 4.759422392871535
04:49:13 <siwica> coppro: excuse me please, stupid me!
04:49:17 <siwica> thanks!
04:49:54 <EvanR> mikail_: it might make it harder to make a test that shows its still broken
04:50:25 <mikail_> ok good point EvanR
04:50:38 <mikail_> I'll just put the full precision in the test case
04:52:30 <EvanR> tests to prove floating point algorithms work ;_;
04:56:04 <suppi> https://github.com/purescript/purescript/issues/2151#issuecomment-223751677
04:56:08 <suppi> waai~!
04:56:18 <suppi> oops, wrong channel
05:13:47 * hackagebot pipes-s3 0.1.0.0 - A simple interface for streaming data to and from Amazon S3  https://hackage.haskell.org/package/pipes-s3-0.1.0.0 (BenGamari)
05:13:50 <EvanR> Cale: which primitive in reflex is the one that blocks an event when some dynamic/behavior is False
05:14:23 <Rembane> EvanR: Yes, you need a new prelude.
05:22:06 <arnold_schwarzen> How can I pipe a bytestring producer such that a value is yielded every (or every n) \n characters?
05:23:21 <arnold_schwarzen> i've got a producer working which decompresses and pipes a gzip file
05:24:18 <arnold_schwarzen> reading through the pipes-bytestring docs is a bit hard as I'm not that familiar with free monad transformers
05:25:51 <quchen_> arnold_schwarzen: There are functions in those modules to decompose those free monads
05:26:33 <EvanR> arnold_schwarzen: (Monad m, Integral n) => n -> Pipe ByteString ByteString m () ?
05:26:34 <quchen_> They look pretty scary, but you don't have to know much about them to use them. I remember having the same problem as you until I read a bit more about the API, and found functions handwavy-like "Free f a -> Producer a"
05:26:39 <EvanR> take ::
05:28:28 <DavidEichmann> Hi all, is there a convenient way to split a list by empty lists e.g. ["abc","","def","h","","j"] -> [["abc"], ["def","h"], ["j"]]
05:29:23 <arnold_schwarzen> quchen_ where's a good place to read more?
05:29:37 <mauke> > splitOn [""] ["abc","","def","h","","j"]
05:29:40 <lambdabot>  [["abc"],["def","h"],["j"]]
05:29:51 <quchen_> arnold_schwarzen: The Haddock documentation is what I was referring to
05:32:52 <mauke> \p -> for p (\bs -> mapM_ yield (lines bs)) ?
05:36:46 <maerwald> is there a library that provides size limited lists?
05:38:48 * hackagebot cgrep 6.6.10 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.10 (NicolaBonelli)
05:50:41 <zq> how to declare a polymorphic constraint in signature
05:52:55 <maerwald> :t (++)
05:52:56 <lambdabot> [a] -> [a] -> [a]
06:12:35 <cocreature> zq: what do you mean by “polymorphic constraint”?
06:16:41 <thyc> Hi
06:34:31 <thyc> I am new to haskell and I have been following this tutorial. https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
06:35:21 <oherrala> hi
06:35:30 <thyc> However, I'm having some trouble.
06:37:08 <thyc> When I use "haskell-do-process-type" in emacs, it shows proper type on "map" function, which does not require any import, but it does not show type on "toUpper" function, which requires import Data.Char
06:38:05 <thyc> Same for the "haskell-mode-jump-to-def-or-tag". When I use this on "map", it shows me it is defined in "GHC.Base", but shows nothing with "toUpper".
06:38:48 <luckyt> Question: can I have multiple returns in main :: IO ()? Like when (...) return()
06:39:44 <oherrala> luckyt: yes
06:41:10 <luckyt> simple example: http://ideone.com/uSgyoA (I want it to print just 1)
06:41:36 <mauke> luckyt: return () is a no-op
06:41:56 <thyc> Is this normal behavior? If not, how would I solve this? Thank you.
06:42:27 <luckyt> mauke: how would you do it then?
06:43:39 <mauke> if/else
06:43:45 <mauke> or exitSuccess
06:44:49 <oherrala> luckyt: ah, the return on line 5 returns from your do on line 3
06:44:58 <luckyt> ahh ok thanks, exitSuccess is what I needed
06:45:01 <oherrala> luckyt: and the value returned by when is then ()
06:45:45 <oherrala> luckyt; and that's why line 6 is also evaluated
06:47:00 <mauke> 'return' doesn't return
06:47:03 <mtesseract> Hi
06:47:11 <mauke> it builds a value
06:47:28 <mauke> :t when
06:47:29 <lambdabot> Applicative f => Bool -> f () -> f ()
06:47:38 <luckyt> oherrala: ok I see why this doesn't work, for my case exitSuccess is good, but in general what if I just want to return from this function, not exit the whole program?
06:52:27 <EvanR> luckyt: returning from the middle of a function doesnt really make sense, there isnt a notion of linear control flow going on
06:52:29 <oherrala> luckyt: write small functions, use pattern matching and if-then-else or case-of
06:52:44 <EvanR> but you can restructure your code in a way to get the result you want, using ^
06:53:04 <oherrala> and in monads you can use fail to bail out
06:53:35 <EvanR> > Nothing <|> Nothing <|> Just 3 <|> Just 9
06:53:37 <lambdabot>  Just 3
06:54:26 <EvanR> its essentially a case by case basis
06:54:48 <luckyt> :t <|>
06:54:49 <lambdabot> parse error on input ‘<|>’
06:54:54 <EvanR> :t (<|>)
06:54:55 <lambdabot> Alternative f => f a -> f a -> f a
06:56:22 <EvanR> > Just 3 >> Just 9 >> Nothing >> Just 10
06:56:24 <lambdabot>  Nothing
06:56:48 <zq> cocreature: if i have a function f :: (forall a. a -> b) -> a -> b, i wouldn't be able to apply f on a g :: Show a => a -> String, for instance
06:57:12 <EvanR> > Just 3 >> Just 9 >> Just 9.5 >> Just 10
06:57:13 <lambdabot>  Just 10
06:57:37 <zq> cocreature: i would like to f to be polymorphic about its constraints, something like f :: (forall a C. C a => a -> b) -> a -> b
06:59:35 <zq> also, it freakin blows chunks that ScopedTypeVariables requires an explicit forall
06:59:53 <zq> i have freakin four-line type signatures now
07:00:55 <cocreature> zq: I don’t think it’s possible but I don’t see how it’s useful either. if it has to be polymorphic over all constraints it can’t use the constraint so you can’t apply it to g either.
07:03:52 * hackagebot sproxy-web 0.4 - Web interface to sproxy database  https://hackage.haskell.org/package/sproxy-web-0.4 (ip1981)
07:04:23 <zq> cocreature: it'd be necessary to fold over a gadt
07:12:59 <miqlas-H> Hi Guys.
07:13:13 <miqlas-H> I'm just trying to get haskell compiled on Haiku.
07:13:41 <miqlas-H> But of course, i don't have any haskell to compile haskell, so it is a virgin field.
07:13:53 <miqlas-H> just reading the porting docs.
07:16:37 <kern_> ghc supports several backends, it can generate c code or asm, llvm code
07:19:46 <miqlas-H> Hmmm...
07:19:53 <miqlas-H> I had big expectations:
07:19:55 <miqlas-H>  checking for ghc... no
07:19:56 <miqlas-H>  configure: error: GHC is required.
07:20:42 <miqlas-H> Do i really need to cross-compile ghc for porting ghc to Haiku?
07:21:41 <EvanR> to compile ghc you must first compile ghc
07:22:18 <EvanR> just take the fixed point of that
07:22:51 <EvanR> if this has really not been done before maybe #ghc can help
07:23:30 <oherrala> heh, such small things to be proud of https://twitter.com/juliabwrites/status/739097029788438528 :)
07:24:21 <simpson> miqlas-H: Cross-compiling sounds like the easy way. It used to be that you could use Hugs, which is written in C, to bootstrap GHC, but I think that those days are gone.
07:25:09 <EvanR> would hugs even be fast enough 
07:25:30 <oherrala> EvanR: well, you need it only once? :)
07:25:52 <Cale> EvanR: gate
07:26:21 <geekosaur> check how it's done for ARM; I believe they use -fllvm, ship the LLVM IR over and lld it there
07:26:37 <geekosaur> that's assuming there's an LLVM for Haiku
07:26:38 <Cale> simpson: Wait, when was that ever the case?
07:27:49 <miqlas-H> geekosaur: i think there is LLVM for Haiku.
07:27:52 <geekosaur> if not then you need to build a ghc -funregisterised, run it on itself to generate ANSI C code, and copy that to the target and compile the C to get a bootstrap native ghc
07:28:34 <miqlas-H> geekosaur: i think, yes: http://termbin.com/xyt7
07:28:53 * hackagebot lzma 0.0.0.2 - LZMA/XZ compression and decompression  https://hackage.haskell.org/package/lzma-0.0.0.2 (HerbertValerioRiedel)
07:28:57 <geekosaur> in any case you migth do better asking in #ghc
07:29:07 <geekosaur> oh, I see you're there now
07:29:27 <simpson> Cale: I wasn't around for it; was Hugs never able to build GHC?
07:29:37 <geekosaur> nope
07:29:42 <simpson> TIL.
07:31:09 <Cale> The very earliest GHCs were built in Lazy ML, and at some point it was rewritten in GHC Haskell
07:31:13 <miqlas-H> should i try to get an old ghc (what is able to compile himself with gcc) to compiled on Haiku, and the compile the latest one with an old one?
07:31:53 <miqlas-H> if yes, wich version is able to get compiled with gcc?
07:32:45 <maerwald> any ideas on this http://lpaste.net/165315 ? I'm also not sure it follows all laws
07:32:53 <EvanR> its kind of scary if the old version cant compile the new version
07:33:51 <Cale> EvanR: That's actually typical. The language keeps changing and new language features get used by the subsequent versions of GHC.
07:34:36 <EvanR> i didnt know about the funregisterized trick, i guess thats the emergency exit to get off the cloud9 were on
07:35:43 <simpson> EvanR: It's not that uncommon. My side-project compiler has a script to fixed-point itself and generate the bootstrap artifacts, so I can always check in code that is known to compile itself.
07:36:20 <EvanR> so you can compile the new version, or cant
07:37:14 <simpson> I have an artifact which can rebuild itself. That's what ends up happening in day-to-day stuff; somebody runs some sort of fixed-point script to generate GHC or GCC, and checks the resulting artifact into Debian or whatnot.
07:38:17 <simpson> GHC and GCC actually both have three-stage builds for a similar reason, to be sure that the final compiler is correct. Or something. ISTR that even though they both build themselves multiple times, there was some sort of distinction between the overall build process.
08:08:55 * hackagebot cgrep 6.6.11 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.11 (NicolaBonelli)
08:13:27 <categoryTheoreti> I have a question about a data type syntax maybe someone could help me understand:  data Foo m n r where I :: Foo m n r  Z :: {-#UNPACK#-}!(Baz n r) -> Foo m n r
08:13:55 * hackagebot cgrep 6.6.12 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.12 (NicolaBonelli)
08:14:29 <miqlas-H> Bye Guys!
08:14:37 <categoryTheoreti> I'm not exactly sure how it works, could someone gloss?
08:17:06 <Cale> categoryTheoreti: which part of the syntax? There's GADT syntax there, as well as a strict field, and an unpacking of that strict field.
08:18:12 <Cale> However, I'm not sure that the {-# UNPACK #-} actually does anything in that context
08:19:15 <categoryTheoreti> Well, I'm still trying to sort out all the haskell type declarations, so I guess, the I and Z are something like OOP attributes? and the signitures qualify them?  I also don't understand the unpack pragma
08:19:21 <geekosaur> I'm not sure that's any different from: data Foo m n r = I | Z !(Baz n r)
08:19:21 <emertens> If
08:19:37 <Cale> Oh, then you picked a horrible example to start with
08:20:00 <Cale> I and Z are the names of the data constructors for the type
08:20:19 <glguy> If Baz has a single constructor its fields will be packed into Z
08:20:30 <Cale> glguy: ah
08:21:01 <categoryTheoreti> ok, that's making some sense give the actual context
08:21:32 <Cale> categoryTheoreti: Did you take a real datatype and replace stuff with Foo and Baz so that it would be harder for us to explain?
08:21:38 <HHH> how can I repeat a takeWhile within a pipe
08:21:40 <HHH> ?
08:22:47 <categoryTheoreti> for clarification, Foo is a Matrix and Baz is a vector
08:26:02 <Cale> categoryTheoreti: There should be more constructors, shouldn't there?
08:26:16 <HHH> for example, I have something like newlinePipe = takeWhile(\w -> w /= newline)
08:26:37 <HHH> wrapped in ... PP.toListM $ decompress fileProducer >-> newlinePipe
08:27:02 <HHH> this grabs the pipe of bytestring up to the first newline
08:28:55 * hackagebot cgrep 6.6.13 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.13 (NicolaBonelli)
08:36:00 <Cale> HHH: I don't really understand what program you want to write, but perhaps you want to replace the takeWhile with a do-block that uses takeWhile and then does some stuff afterward?
08:37:59 <HHH> Cale I'm trying to effectively achieve the following behavior
08:38:17 <HHH> have a pipe that takes a bytestring up to a particular character
08:38:26 <HHH> effectively do a "yield" for that chunk
08:38:41 <HHH> then take another chunk up to the specified character
08:38:44 <HHH> then yield that chunk
08:39:09 <HHH> so the toListM should effectively look like string splitting
08:41:44 <HHH> Cale does that make snese?
08:42:16 <Cale> Yeah, let me see if I can work this out, I almost never use pipes
08:48:07 <HHH> gotta run
08:48:24 * monochrom DDoS'es Cale. Do you normally use reflex for this? :)
08:48:30 <Cale> lol
08:48:33 <HHH> will check ircbrowse if anyone has any thoughts
08:48:38 <HHH> sorry
08:48:45 <HHH> (on transportation and gotta get off now)
08:59:37 <zinking> any help on http://lpaste.net/165321 ?
08:59:59 <zinking> types don't check but supposed to work 
09:01:31 <Cale> zinking: Well, you definitely don't want fromJust there
09:01:57 <zinking> but that checks type 
09:02:01 <Cale> Wait, why ErrorT over Identity rather than just Maybe?
09:02:09 <Cale> Or Either, rather
09:02:39 <Cale> Yeah, it typechecks, but if the variable isn't in the environment, your evaluator crashes.
09:02:59 <Cale> When presumably what you wanted it to do was report an error
09:03:57 * hackagebot bloomfilter-redis 0.1.0.3 - Distributed bloom filters on Redis (using the Hedis client).  https://hackage.haskell.org/package/bloomfilter-redis-0.1.0.3 (hesiod)
09:03:58 * hackagebot aws 0.13.1 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.13.1 (AristidBreitkreuz)
09:03:59 <Cale> Well, we could use ErrorT just fine, I suppose
09:04:11 <zinking> Quote: The next is that the Var case does not need a fromJust call anymore: The reason is that Map.lookup is defined to work within any monad by simply calling the monad’s fail function – this fits nicely with our monadic formulation here. (The fail function of the Maybe monad returns Nothing, whereas the fail function in the Identity monad throws an exception, which will lead to different error messages.)
09:04:36 <Cale> case Map.lookup n env of Nothing -> throwError ("variable " ++ n ++ " not in scope"); Just x -> return x
09:04:54 <Cale> Oh, that's not true
09:05:03 <Cale> At one point I think it was
09:05:14 <Cale> but then Data.Map stopped abusing Monad in that way
09:05:47 <Cale> :t lookup
09:05:48 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
09:05:50 <Cale> :t Map.lookup
09:05:51 <lambdabot>     Not in scope: ‘Map.lookup’
09:05:51 <lambdabot>     Perhaps you meant one of these:
09:05:51 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
09:05:53 <Cale> :t M.lookup
09:05:54 <lambdabot> Ord k => k -> Data.Map.Map k a -> Maybe a
09:07:19 <Cale> zinking: ah, the paper you're reading is from a decade ago :)
09:07:29 <zinking> guess so 
09:07:45 <maerwald> why can't the minimal definition of Monad not be 'join'? That feels arbitrary that I have to do '(>>=)'.
09:07:50 <zinking> so it no longer holds ?
09:08:07 <zinking> so we have to expand like you suggests ?
09:08:10 <Cale> zinking: Yeah, Data.Map's API has changed
09:08:25 <zinking> but what's the scenario makes it work at that time ?
09:08:28 <EvanR> maerwald: hopefully at some point join is added to Monad
09:08:34 <Cale> maerwald: Usually >>= is more natural to define for the kinds of monads we work with in Haskell.
09:08:57 * hackagebot http-types 0.9.1 - Generic HTTP types for Haskell (for both client and server code).  https://hackage.haskell.org/package/http-types-0.9.1 (AristidBreitkreuz)
09:09:00 <maerwald> Cale: I find join more natural, as in: 'join (fmap f x)'
09:09:03 <ggVGc> what do people usually use phantom types for_
09:09:04 <maerwald> so I just want to define join
09:09:32 <EvanR> ggVGc: bondage and discpline ;)
09:10:10 <maerwald> ggVGc: the reflection package for example
09:10:43 <EvanR> with singleton types you can enforce more at compile time
09:11:04 <Cale> ggVGc: If you have a type of expressions for some language you're interpreting, you might want to annotate them with the type of values they're eventually going to evaluate to, even though the expression itself may not contain a value of that type.
09:11:06 <ggVGc> I'm trying to get a grip on the uses cases of phantom types, GADTs, multiparam type classes, and functional dependencies, and it's all becoming a blur
09:11:20 <Cale> It is a blue
09:11:23 <Cale> blur*
09:11:37 <Cale> The use cases of those things overlaps to a large extent
09:11:55 <ggVGc> it seems to me that multiparam type classes are essentially completely superceded by GADTs
09:12:01 <ggVGc> but I may be wrong
09:12:09 <Cale> I strongly disagree
09:12:09 <ggVGc> also, I don't completely get GADTs yet
09:12:17 <ggVGc> that's good to hear
09:12:26 <Cale> Which GADT would you use to replace, e.g. MonadState?
09:12:35 <ggVGc> I can not answer these questions yet :)
09:12:47 <ggVGc> I am still trying to get my head around all these more advanced type features
09:13:16 <ggVGc> I need to do something where I use GADts in my own code to really get it I think
09:13:25 <ggVGc> gonna try implementing a small eDSL with GADTs
09:13:27 <ggVGc> as a start
09:13:37 <ggVGc> generating lua
09:13:52 <Cale> GADTs are one of those things which you don't really use very often
09:13:59 <Cale> but it's really nice to have them when you do
09:14:17 <ggVGc> right
09:14:19 <EvanR> what i use GADTs all the time
09:14:26 <ggVGc> and I feel I'd like to understand them in practice
09:14:39 <ggVGc> because I tink I have uses for them, but can't see it yet
09:14:53 <Cale> It probably depends somewhat on what type of programs you like to write
09:15:04 <ggVGc> my current program has essentially a small DSL for composition of execution modes now, but it's kind of brittle and not very well implemented
09:15:19 <EvanR> if haskell is a language construction kit, GADTs are like ... 
09:15:27 <EvanR> the resistors or something
09:15:46 <ggVGc> I don't want any resistance in my programming"
09:15:48 <ggVGc> !!
09:15:58 <EvanR> they stop your circuit from exploding
09:16:03 <Cale> It often ends up being a better fit just to use a "finally tagless" style encoding than a GADT in the end.
09:16:19 <ggVGc> Cale: what does "finally tagless" style mean?
09:16:21 <EvanR> finally tagless ?
09:16:28 <Cale> But sometimes it's nice, before you've implemented any functionality, to be able to write down a GADT for your language and build terms of it.
09:16:36 <ggVGc> sounds like type arasure for DSLs?
09:16:40 <ggVGc> erasure*
09:16:41 <Cale> http://okmij.org/ftp/tagless-final/JFP.pdf
09:17:03 <Cale> oh, that paper is in ML, I forgot :)
09:17:03 <ggVGc> what uses are there for GADTs that are not language implementations?
09:17:57 <Cale> http://okmij.org/ftp/tagless-final/#in-fin -- here, this section
09:18:21 <Cale> Usually the type class is what you really want
09:18:27 <glguy_> Here's an example of a "non-language" GADT http://hackage.haskell.org/package/hoopl-3.10.2.1/docs/Compiler-Hoopl.html#t:Pointed
09:18:30 <Cale> But it's nice to have the GADT sometimes
09:18:53 <EvanR> glguy_: you can use GADTs to make a hetero-typed list
09:18:57 * hackagebot debian-build 0.9.2.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.9.2.0 (KeiHibino)
09:21:44 <shirt> why is regular expressions stuff in IO monad? https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Regex.html
09:22:26 <Cale> shirt: Because that's a binding to a regex library written in C.
09:22:57 <EvanR> and apparently they couldnt figure out how ot make it pure
09:23:57 * hackagebot haskell-player 0.1.3.2 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.3.2 (potomak)
09:27:21 <Cale> Most regex-related stuff in Haskell is a bit awkward, because most self-respecting authors of libraries to do parsing want their parsers to parse non-regular languages, so restricting to just regular expressions is silly. Also, despite what goes on in some languages, regex notation is a pretty bad notation for parsers of non-regular languages (it's arguable that it's not a good notation for parsers of regular languages either...)
09:28:57 * hackagebot aws 0.14.0 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.14.0 (AristidBreitkreuz)
09:30:21 <aristid> bgamari: can you try if aws 0.13.1 works with ghc 8? i don't have a ghc 8 install right now
09:31:16 <bgamari> aristid, ahh, great
09:31:17 <bgamari> sure
09:31:19 <bgamari> one moment
09:36:19 <cocreature> shirt: regex-applicative is a pretty nice library if you want something more “haskelly”
09:36:28 <bgamari> aristid, indeed I'd be happy to help out
09:36:57 <aristid> bgamari: i must admit i'm not the best maintainer lately, so help would probably be quite useful
09:37:17 <hpc> that still sounds kind of akward, as Applicative has the power to parse CFGs
09:38:03 <shirt> cocreature: cool thanks
09:43:58 * hackagebot bitcoin-payment-channel 0.1.1.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.1.1.0 (runeks)
09:44:42 <runeks> Is there a way to figure out why Hackage doesn't build the documentation for this package ^?
09:45:12 <quchen_> runeks: Yes, there's some endpoint that gives you the logs I think, hold on
09:45:25 <runeks> quchen_: Awesome!
09:46:05 <quchen_> runeks: https://hackage.haskell.org/api#reports-core
09:46:20 <bergmark> runeks: check the Status, it has links to build reports
09:46:54 <Zemyla> hpc: I think it's a regex by the fact that earlier regexes can't refer to later ones, because then it causes an infinite loop.
09:47:13 <maerwald> mh, is there no: asLong :: Monad m => (a -> Bool) -> m a -> m () -- as in, a specialced version of 'forever'
09:47:20 <runeks> quchen_ bergmark: Thanks! found it
09:47:45 <quchen_> maerwald: monad-loops probably has it (because it has everything).
09:47:49 <Zemyla> maerwald: It should really be (a -> Bool) -> m a -> m a, and return the failing value.
09:56:41 <aristid> bgamari: now i have ghc 8 installed and lo and behold 0.13.1 does not work. 0.14 does. i'll make a fix for 0.13.x though
10:03:59 * hackagebot aws 0.13.2 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.13.2 (AristidBreitkreuz)
10:12:34 <mjrosenb> what do I need to import to get (^.)?
10:12:58 <aristid> :t (^.)
10:12:59 <lambdabot> s -> Getting a s a -> a
10:13:06 <aristid> mjrosenb: Control.Lens i think
10:23:59 * hackagebot octane 0.6.2 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.6.2 (fozworth)
10:53:41 <Big_G> Is there a term to show the similarities between two types (i.e. Bool and "data MyBool = Foo | Bar")?
10:54:00 * hackagebot pandoc-citeproc 0.10 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10 (JohnMacFarlane)
10:55:29 <monochrom> we usually say "they are isomorphic"
10:55:53 <Big_G> Is that any different from saying they're alpha reductions of eachother?
10:56:10 <monochrom> but I think "ismorphic" is over-used and under-specified. I usually say "equivalent", which is at least widely understood to be over-used and under-specified.
10:57:13 <maerwald> lol :D
10:57:19 <monochrom> "isomorphic" is best reserved for precise math and prefixed with eg "order-isomorphic" to say what exactly is being preserved (and therefore what is not)
10:57:44 * simpson is equivalent up to unique isomorphism
10:57:57 <monochrom> "equivalent" is the go-to English word for not wanting to say much
10:58:15 <Big_G> I was hoping for a more precise word than equivalent 
10:58:56 <monochrom> the problem is that "ismorphic" alone, i.e., without prefix, is no more precise than "equivalent".
10:59:15 <simpson> Big_G: I think that the "more precise" route involves defining a binary relation.
11:00:28 <mjrosenb> I usually say some subset of 'invariant under alpha equivalent'
11:00:49 <Big_G> simpson, I'm looking for something not specific to binary types but something more generic like them having the same "shape" (arity)
11:01:15 <monochrom> ok, if you're hoping for something more precise, then you ought to first tell us what more you want to say
11:01:25 <Big_G> mjrosenb, Do alpha conversions count for types? I thought that was just for variables
11:01:50 <monochrom> if you stay at the level of "you know what I mean" then "equivalent" exactly means "you know what I mean" already.
11:02:44 <Big_G> monochrom, I want to say that the types can be represented by the same ADT if the names were changed 
11:03:35 <monochrom> then mjrosenb's idea is good. the "alpha" thing there refers to renaming.
11:03:50 <simpson> Big_G: Oh, no, I mean, the relation is binary because it's between two types.
11:04:31 <Big_G> simpson, In that case, it would. I just don't know what to call that binary relation
11:04:39 <monochrom> "alpha-equivalent" means "the same except for names"
11:05:08 <monochrom> I am wondering if "bijection" works.
11:05:12 <Big_G> Would that still hold if one implemented typeclasses the other didn't?
11:05:24 <simpson> Big_G: "We define the binary relation HmmTheseTypesLookSuspiciouslySimilar : Ty x Ty ..."
11:05:59 <monochrom> yes. we usually don't expect both to implement the same typeclasses, or even implemented the same way
11:07:15 <monochrom> when we say "types X and Y are <whatever equivalent or isormorphic here>", we still acknowledge that they are two distinct types and do not have to share anything class-wise.
11:07:55 <Novax265> Hello. I'm new to Haskell. I've read that Haskell's IRC is very generous. Can I know what it is like, what's it used for and how can I learn it?
11:07:58 <monochrom> in fact we don't even expect them to have the same name. and Haskell pretty much practices nomimal typing not structural typing. different names already means different.
11:08:22 <simpson> Novax265: Haskell's a general-purpose programming language. It's used in many different scenarios and situations.
11:08:47 <simpson> I have no idea which tutorials we are recommending these days.
11:09:01 * hackagebot subwordgraph 1.0.1 - Subword graph implementation  https://hackage.haskell.org/package/subwordgraph-1.0.1 (adambak)
11:09:55 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html are some pretty good course materials
11:10:42 <grumpy_nolrai> Can I talk out how to represent something?
11:11:54 <grumpy_nolrai> So, I have a matrix of columns, where each column contains some number of size two "swaps" or size three "franklens".
11:12:44 <grumpy_nolrai> But also contains a fair bit of just pass through.
11:13:22 <mjrosenb> Big_G: right, but those are just names that you've given the types, and as usual, the name that you call something doesn't really matter.
11:14:33 <grumpy_nolrai> So I can just keep track of the top edge of the "swaps" and "franklens" but is there a good way to keep them from overlaping?
11:15:27 <grumpy_nolrai> Like if a franklen is 2, then nothing else in that column can start at 2,3, or 4.
11:15:33 <grumpy_nolrai> * is at
11:16:48 <grumpy_nolrai> Isn't isomorphism the generic name for "same except for some lables"?
11:17:54 <monochrom> no, there is no isomorphism unless and until you specify, for example, a category.
11:18:03 <erisco> grumpy_nolrai, A and B are said to be isomorphic if there exists f :: A → B and g :: B → A such that f . g = id and g . f = id
11:18:51 <monochrom> no, erisco's ismorphism is only when the category is that of sets and functions. in which case you should simply say "bijection" and screw category theory.
11:19:56 <grumpy_nolrai> Well if f and g are proper morphisms on what ever you are talking about then it is an isomorphism isn't it?
11:20:25 <monochrom> yes, but only when you and your correspondence have agreed upon which category you're talking about
11:20:32 <erisco> well, maybe that is more specific than necessary, but I don't see how it is restricted to sets and functions
11:20:37 <grumpy_nolrai> Fair.
11:21:03 <monochrom> IMO throwing around "isomorphic" without acknowledging where it came from is cargo cult.
11:21:10 <grumpy_nolrai> But using isomorphism as a generic term for that kind of relasionship seems cromulent to me.
11:21:52 <monochrom> it is a good generic term for two parties who know they're talking categories
11:21:59 <erisco> monochrom, how is it specific to functions and sets?
11:22:17 <grumpy_nolrai> Why do you need to know your talking categories?
11:22:17 <monochrom> it is a cargo cult term if you're talking to someone who do not expect that you're talking categories
11:22:36 <monochrom> because it means nothing outside
11:23:01 <grumpy_nolrai> Like all mathmatical terms?
11:23:17 <monochrom> yes
11:24:03 <Myrl-saki> I went with an i5-6400, 16 GB DDR2-2133 WAM and 256 GB SSD
11:24:19 <erisco> DDR3?
11:24:21 <monochrom> there is already "equivalent" for generic, does-not-need-to-bring-up-categories purposes
11:24:27 <Myrl-saki> erisco: DDR4*
11:24:46 <grumpy_nolrai> Okay. I mean loots of people just use it too mean "Isomorphic as types upto some fudging with strctness", but while that is ..naive its not worthy of being called Cargo Cult, IMO.
11:24:47 <erisco> didn't know they made that yet… does it use a new chipset?
11:24:48 <Myrl-saki> erisco: Wow. I feel so bad for myself. I've been using DDR2 for like 2 years already that I auto-typue DDR2.
11:24:48 <monochrom> so the correct question is "why bring up isomorphic, if it doesn't do more than equivalent?"
11:24:55 <Myrl-saki> erisco: Yeah.
11:25:16 <shachaf> monochrom: But "equivalent" means something else when you're talking about categories.
11:25:16 <grumpy_nolrai> Equivalent is /too/ generic.
11:25:21 <Myrl-saki> erisco: The only supporting series is Intel Skylake. AMD will get into the sweet DDR4 action in AMD.
11:25:30 <Myrl-saki> in Q1'20178
11:25:46 <Myrl-saki> I think that sentence means that "I need to go to sleep"
11:25:51 <monochrom> if you say "ismorphic" to someone who doesn't already know it, does it do anything more than "equivalent"?
11:26:00 <grumpy_nolrai> In the 201th century? :P
11:26:15 <glguy> Myrl-saki / erisco: sweet computer specs are better for #haskell-offtopic
11:26:23 <grumpy_nolrai> Yes, it means you are using a big mathy word.
11:26:35 <erisco> best in #haskell-blah
11:27:04 <grumpy_nolrai> Which is sometimes useful, ie. when you want to comunicate that their is a theory behind what you are saying.
11:27:49 <grumpy_nolrai> And..actually types can be totes isomorphic without being equivalent.
11:28:24 <Ohso_> Hello, could someone help me find a better way to write this function?  http://pastebin.com/MNC404bD
11:28:57 <Myrl-saki> glguy: Ah. Thanks.
11:29:02 * hackagebot hakyll-filestore 0.1.1 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.1 (aergus)
11:29:12 <Ohso_> The nested cases are pretty hideous to look at.
11:29:12 <erisco> Ohso_, formatting it well would help
11:29:52 <grumpy_nolrai> Integer is isomorphic to (bool, nat) but good luck calculating 100! using the second.
11:30:01 <Clint> Ohso_: do postStepAState <- stepA; ...
11:30:33 <erisco> Ohso_, I think you want to use do-notation and the Either Monad, but also I am not sure where some things are bound, such as "lowWrite"
11:31:16 <EvanR> grumpy_nolrai: in the sense of bijection, its isomorphic to all types that arent finite
11:31:37 <monochrom> grumpy_nolrai, I would like to see the isomorphism you just said.
11:31:50 <lpaste> mjrosenb pasted “misleading error” at http://lpaste.net/165330
11:31:57 <hsk3> Here: https://s3.amazonaws.com/f.cl.ly/items/3K0G1W26103u1C3l021X/func.png?v=225fc695
11:31:58 <hsk3> foldr is taking a lambda with THREE arguments. How is that possible?
11:32:11 <Ohso_> I feel like I must be overlooking some simpler way of writing it.
11:32:25 <erisco> it is not a pretty isomorphism
11:32:32 <mjrosenb> can someone see what message that snippet gives in a compiler newer than 7.10.3?
11:32:37 <erisco> a 1's complement sort of thing maybe
11:32:38 <lpaste> glguy pasted “rearranging foo” at http://lpaste.net/165331
11:32:45 <grumpy_nolrai> : EvenR: well not internally, because some types are uncountable, but externally yes. (I might not be using internal/external right.)
11:32:50 <glguy> Ohso_: ^
11:33:12 <EvanR> which type is uncountable
11:33:15 <EvanR> (in haskell)
11:33:22 <Ohso_> ah, oops. lowWrite should just say stepB ---error while simplifying the code to paste example.
11:33:36 <EvanR> and if were doing bijections... on set-types... lets call it that!
11:33:49 <EvanR> lets me honest about the boringness
11:34:05 <monochrom> when I say "cargo cult" I do not have in mind people who play loose with bottom. I have in mind people who simply monkey-hear monkey-say without knowing why.
11:34:16 <simpson> Is CReal countable? I'm not sure.
11:34:30 <EvanR> yeah
11:34:34 <lpaste> glguy revised “rearranging foo”: “rearranging foo” at http://lpaste.net/165331
11:34:48 <grumpy_nolrai> "(b, n) -> if b then negate (to_integer (succ n)), else to_integer" seems pretty smple to me.
11:34:56 <Ohso_> I don't want to involve monads. Not ready for that yet.
11:35:07 <grumpy_nolrai> The other way is harder...but not that bad.
11:35:14 <glguy> Ohso_: OK, then you'll just have nested cases
11:35:57 <glguy> or you can recreate the Monad >>= operation under another name to manage passing the Right x to the next function
11:36:11 * Clint chuckles.
11:36:19 <grumpy_nolrai> Yes, I know what you mean Monochrome, I am just arguing that the problem is not with the word, and is not that big of a problem.
11:36:41 <grumpy_nolrai> Or rather a problem that all branches of knoledge have and humans have ways to deal with.
11:37:21 <monochrom> oh no problem is a problem with merely a word, or merely a program, or merely a system. every human problem is caused by humans.
11:37:33 <MP2E> hi, is there a way to get ghc to use a c compiler other than the gcc it's included with, on Windows?
11:37:40 <mjrosenb> Ohso_: can you paste a correct example?
11:38:04 <MP2E> reason I ask is because I'm trying to compile Yi and my life would be a lot simpler if it just used the gcc in my $PATH
11:38:26 <MP2E> : P
11:38:33 <geekosaur> you hope
11:38:49 <geekosaur> the reason it forces the issue is that your life could end up a lot harder (and this pretty much impossible)
11:38:51 <grumpy_nolrai> monochrom: fair.
11:39:18 <MP2E> well I suppose I can compile every C dependency I have manually with the built in gcc instead of using MSYS2's pacman
11:39:22 <MP2E> just seems like a pain
11:39:25 <Ohso_> http://pastebin.com/nJUsxXTJ
11:40:33 <Ohso_> The errors in both cases are identical.
11:41:16 <Ohso_> Basically it is gluing two actions (either of which can fail) into a single atomic succeed or fail.
11:43:38 <Ohso_> It works, it's just really ugly looking, so I figured I might be missing some obvious rewrite. Still really new to Haskell and just trying to get the basics down.
11:44:06 <mjrosenb> Ohso_: yeah, that is a pretty canonical use case for monads.. I can get it to be only one case statement, but I'm not sure it would be better.
11:44:34 <Ohso_> Hmm, what would it look like?
11:45:18 <lpaste> glguy annotated “rearranging foo” with “using case reformatted” at http://lpaste.net/165331#a165334
11:48:15 <mjrosenb> Ohso_: https://gist.github.com/anonymous/1a2bb14a568c3dea6bb4fc67c308d098
11:48:37 <mjrosenb> not quite as extreme as using monads... but also not particularly pretty
11:49:00 <mjrosenb> fwiw, you don't even need to use stepA in the case
11:49:14 <EvanR> action1 <|> action2
11:49:41 <EvanR> also not as extreme as using monads ;)
11:50:20 <Akii> :t (<|>)#
11:50:21 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:50:23 <mjrosenb> so one nice thing about using functors rather than monads is with the single value, you can tell which operation failed.
11:50:24 <Akii> :t (<|>)
11:50:26 <lambdabot> Alternative f => f a -> f a -> f a
11:51:02 <EvanR> > Left "crap" <|> Right 9999
11:51:03 <lambdabot>  Right 9999
11:51:12 <EvanR> hmm, nevermind
11:51:56 <EvanR> > Left "crap" >> Right 9999
11:51:58 <lambdabot>  Left "crap"
11:52:06 <EvanR> > Left "crap" <|> Left "dung"
11:52:07 <lambdabot>  Left "dung"
11:52:45 <Ohso_> Thanks. Maybe I'll stick with the nested case. While I like having just the one case, it seems a lot less clear what's going on there.
11:52:46 <hsk3> Here: https://s3.amazonaws.com/f.cl.ly/items/3K0G1W26103u1C3l021X/func.png?v=225fc695
11:52:46 <hsk3> foldr is taking a lambda with THREE arguments. How is that possible?
11:53:18 <EvanR> all functions take 1 argument actually
11:53:18 <mjrosenb> why is that links extension .png?
11:53:55 <ertes> hi there…  let's say:  class C a where m1 :: a -> a; m2 :: a -> Int
11:54:29 <ertes> can i unsafeCoerce a function of type (C a => X) such that i can pass it an explicit dictionary?  and how exactly do i pass it?
11:54:38 <ertes> i'm asking because the 'reflection' package does that
11:55:03 <shachaf> Yes, you can do it.
11:55:09 <schjetne> mjrosenb: probably because it's a PNG file
11:55:23 <shachaf> At least it works in GHC and Hugs. It's not guaranteed or anything.
11:55:27 <mjrosenb> hsk3: so, have you heard the term "CPS" before?  I suspect it will be easier to explain if you're familiar with it.
11:55:28 <shachaf> You can do it the same way that reflection does it.
11:55:42 <EvanR> hsk3: (\x y -> \z -> w) is now an equivalent lambda taking 2 args
11:55:52 <ertes> shachaf: note that C has two members…  how do i pass it?  just separate arguments?  a tuple?  …?
11:55:58 <bergey> hsk3: The type b returned by foldr, by the first argument to foldr, and the (const Nothing) is itself a function type.
11:56:05 <monochrom> hsk3: the code uses foldr to build a function. so "const Nothing" is a function. and so on.
11:56:12 <hsk3> ah nice
11:56:13 <shachaf> Oh, then C probably corresponds to a data type instead of a newtype.
11:56:13 <hsk3> i see
11:56:36 <shachaf> You can look at the generated code to figure out exactly what C is, though I doubt there are many guarantees about it.
11:57:20 <ertes> shachaf: ok, thanks…  what about associated types?  do they just follow from the dictionary i pass?
11:58:04 <mjrosenb> does anyone have an early release of ghc-8 that they can test a snippet of code on?
11:58:04 <ertes> example: class C a where type T a; m :: a -> T a
11:58:05 <shachaf> I don't know off-hand.
11:58:08 <ertes> ok
11:58:18 <shachaf> mjrosenb: Why an early release?
11:58:19 <ertes> that was helpful, thanks
11:59:45 <shachaf> If you can get away with using reflection instead of another class, that would be better, of course.
11:59:50 <mjrosenb> err, the current release
12:00:06 <mjrosenb> it isn't the final release yet is all that I meant.
12:00:57 <geekosaur> it's not?
12:04:08 <mjrosenb> the last announcement that I read was about a release candidate.
12:06:03 <mjrosenb> anyhow, does anyone have any version of ghc-8 installed to see if they still have a sub-par error message?
12:06:22 <geekosaur> 21 May 2016   GHC 8.0.1 Released! [download] - per https://haskell.org/ghc
12:06:40 <Zemyla> If a Haskell program were to do calculations using a GPGPU framework, would the calculations be done in the IO monad even when they're pure?
12:08:16 <Zemyla> Or would it be possible to wrap it in some ST-like monad that's an IO monad internally but can be called from pure code?
12:09:35 <geekosaur> Zemyla, you'd need IO to talk to the GPGPU (since it's usually done via FFI). but if it's truly pure, you could unsafeLocalState that
12:12:49 <ertes> is there a way to eliminate the run-time representation of a type or a specific function argument?
12:13:57 <jmcarthur> ertes: Could you be more specific?
12:15:39 <ertes> jmcarthur: can i write a function of type A -> B that acts like a value of type B at run-time?  this would be useful for proof terms of type A
12:17:08 <jmcarthur> ertes: If the function is inlinable and you only apply it to some statically known value, perhaps. I don't know of a way to guarantee that it works, though.
12:17:58 <blair__> Hey, dumb question: I have a function where I'm trying to use "handle" from control.exception, but it's complaining that I need to specify the exeption type. How do I do that though?
12:18:01 <jmcarthur> ertes: Though types are always erased in Haskell, we don't have an especially principled way to ensure erasure of some terms.
12:18:12 <tomw> Hi - I have a question about parsing with Megaparsec...
12:18:34 <blair__> This is the line of code causing problems: "unsafePerformIO $ handle (\_ -> return defaultTheme) theme'"
12:18:48 <ertes> jmcarthur: that's not realistic…  i'm going to use that for session and access proofs…  however, the actual terms are very simple, and i could even work with empty types in some cases
12:18:48 <shachaf> ertes: What sorts of proof terms? There's always the problem that they might be _|_.
12:18:59 <tomw> Text.Megaparsec.Expr lets me make a parser for expressions if I know the fixity of operators
12:19:27 <tomw> But if I am parsing a programming language then the fixity of custom operators might be defined later in a file.
12:19:50 <jmcarthur> ertes: For specific cases you may be able to do it, but it's difficult to make hard claims in general.
12:20:19 <EvanR> blair__: the heck... youre doing unsafePerformIO AND trying to catch all exceptions? ;)
12:20:26 <tomw> So what is the recommended way of parsing with this?  Do I do one pass of a file to find fixity declarations, and build up the expression parser after that?
12:20:29 <ertes> shachaf: fast and loose proofs, and usually nothing fancy…  in fact most of the time i'll work with what agda calls postulates
12:20:44 <jmcarthur> ertes: e.g. maybe A could be defined as   newtype A = A B   . Then your function is just id, and it is actually just that A is giving you a B for free.
12:21:05 <Cale> blair__: How did you end up in this predicament in the first place? Where is theme' defined? Can we change it such that it doesn't throw an exception?
12:21:43 <ertes> shachaf: let P :: T be the only inhabitant of T, but it's not exported
12:21:48 <EvanR> blair__: for an example of how to get this to work, and why its probably bad, see the catch section of Control.Exception
12:22:12 <Hijiri> how can I tell what GHCJS versions stack hosts?
12:22:17 <Cale> blair__: If you find yourself in the position of wanting to catch an exception from the evaluation of an expression (rather than from the execution of an IO action), then you usually want to change the program such that the exception just doesn't occur, by using types such as Either or Maybe
12:22:45 <ertes> jmcarthur: almost all of those are singleton types…  it's not too bad, but would be nice to save that cost
12:23:11 <jmcarthur> ertes: How about a really concrete example? Maybe we can write some code.
12:23:13 <dolio> ertes: When your logic is unsound, you are obligated to check that all your proofs are legitimate.
12:24:15 <ertes> simple example:  login :: SUserId u -> Password -> IO (Maybe (Session u))
12:24:39 <jmcarthur> ertes: Which of those things are the things that should have no representation at runtime?
12:24:41 <ertes> the implementation of (Session u) is uninteresting, but you can only get it via 'login'
12:24:46 <blair__> Hmm, ok. How can I use Maybe to handle reading files?
12:24:56 <ertes> jmcarthur: the session
12:25:07 <jmcarthur> wait, so now it's the *result* that should have no representation?
12:25:09 <Cale> blair__: Perhaps you can talk about what it is that threw the exception?
12:25:14 <jmcarthur> I thought it would be an argument.
12:25:21 <EvanR> blair__: im skeptical that you should be reading files in an unsafePerformIO
12:25:27 <ertes> jmcarthur: it will be
12:25:53 <blair__> Cale: Nothing has thrown an exception yet (but this is my window manager, so I'd rather not test that)
12:25:53 <Cale> Yeah, reading files is definitely not something to put inside unsafePerformIO
12:25:58 <ertes> jmcarthur: createPost :: Session u -> PostData -> IO PostId
12:26:02 <ertes> something like that
12:26:08 <tomw> Anyone interested?  If it's off topic, just tell me...
12:26:34 <Cale> In fact, just stay away from unsafePerformIO altogether.
12:26:40 <blair__> Oh yeah? I was trying to read a file and use a default config if the file failed to open or if it was unavailable
12:27:16 <EvanR> do it in regular IO code
12:27:41 <jmcarthur> ertes: The fact that you can construct a session this way seems to imply that there's going to be *something* there. If it doesn't actually have any useful data then I can imagine you could just use () as its representation, and then it is very likely to disappear in most places. Or is there actually some data inside it that you are using for internal proofs?
12:27:42 <ertes> jmcarthur: actually this isn't a good example, because the session actually includes user data and some other things, but think of access tokens:  getAccess :: Session u -> SPostId postId -> IO (Maybe (Access u postId))
12:28:16 <ertes> jmcarthur: the sole purpose of Access is to prove access to a certain resource
12:28:32 <jmcarthur> ertes: If it literally has no data then I would just trust the optimizer to remove the (). It might not do it always, but I doubt this will become any sort of bottleneck anyway.
12:29:20 <ertes> sounds reasonable…  what about empty data types?  does GHC optimise them away?
12:29:43 <ertes> (not going to use one, just interested)
12:30:05 <jmcarthur> ertes: You mean just passing undefined around?
12:30:10 <ertes> yeah
12:30:58 <jmcarthur> ertes: I don't think it will just remove that argument from the function, but it maybe it will make an inlinable wrapper that calls a helper which doesn't have that argument (or maybe you could just write that wrapper yourself).
12:31:17 <geekosaur> [04 19:25] <blair__> Cale: Nothing has thrown an exception yet (but this is my window manager, so I'd rather not test that)
12:31:33 <geekosaur> all user provided code is run in a catch
12:31:37 <jmcarthur> ertes: fwiw, I also don't think this is any different from any other argument that you don't use in the function.
12:31:52 <Cale> geekosaur: ?
12:31:57 <ertes> yeah, makes sense
12:32:38 <geekosaur> there's another window manager written in haskell, that they'd be trying to load images from pure code? I'm imagining a DynamicLog gone horribly wrong
12:34:04 * hackagebot pomodoro 0.1.0.0 - pomodoro timer  https://hackage.haskell.org/package/pomodoro-0.1.0.0 (zohl)
12:34:06 <geekosaur> but the point was more than they can't trash things by missing an exception, worst that happens is you end up with a default (for logHook no real effect, worst case is probably layoutHook which means you get Full)
12:34:10 <EvanR> jokes on us, everything is pure, one huge universal wave function
12:36:05 <lpaste> blair__ pasted “theme” at http://lpaste.net/165340
12:36:25 <geekosaur> unless blair__ is writing a window manager from scratch in which case they need to reexamine their life choices :)
12:37:10 <blair__> geekosaur: Haha, yeah, I'm trying to set up dynamic themes in xmonad
12:37:31 <geekosaur> unsafePerformIO is really not a good idea
12:38:06 <geekosaur> it is not an escape hatch to let you run impure stuff. if you treat it that way, it will do bizarre things (like not running when you'd expect it to)
12:38:27 <blair__> Is there a proper escape hatch?
12:38:45 <jmcarthur> There are only improper escape hatches.
12:38:56 <geekosaur> there is no escape hatch. you rephrase it so you can do the IO in IO, and use the result in a pure context.
12:39:04 * hackagebot haskoin-core 0.3.0 - Implementation of the core Bitcoin protocol features.  https://hackage.haskell.org/package/haskoin-core-0.3.0 (xenog)
12:39:06 * hackagebot haskoin-node 0.3.0 - Implementation of a Bitoin node.  https://hackage.haskell.org/package/haskoin-node-0.3.0 (xenog)
12:39:07 <geekosaur> since everything is ultimately in IO, there is usually a way to do this
12:39:21 <jmcarthur> Some libraries make this overly difficult, though.
12:40:14 <geekosaur> for a Theme I'd likely load it in main and pass it into the config, and make the user mod-q if they want to change it at runtime
12:42:46 <blair__> geekosaur, that would be less than ideal... I have a default theme in there in case anything goes wrong. So I'm happy to bail on the IO function at any turn and use the default. But I do want to somehow get this into my Config in the main function
12:44:04 <lpaste> blair__ pasted “xmonad config” at http://lpaste.net/165341
12:44:05 * hackagebot haskoin-wallet 0.3.0 - Implementation of a Bitcoin SPV Wallet with BIP32 and multisig support.  https://hackage.haskell.org/package/haskoin-wallet-0.3.0 (xenog)
12:45:34 <blair__> I might be able to side-step the unsafePerformIO, but I need to find someway to get my IO variables into that config. There is always a fallback set of values, so it seems like it should be reasonable to do
12:46:15 <ertes> blair__: theme :: IO ThemeConfig
12:46:50 <geekosaur> yoi don't need unsafePerformIO there
12:47:02 <ertes> your example doesn't even look like a case of "would be nice to have side effects here"
12:47:04 <geekosaur> theme <- getTheme after the spawnPipe-s, then use theme normally in the config
12:47:49 <geekosaur> (assuming your existing theme' is renamed getTheme)
12:49:05 * hackagebot postgresql-simple-bind 0.1.0.0 - A FFI-like bindings for PostgreSQL stored functions  https://hackage.haskell.org/package/postgresql-simple-bind-0.1.0.0 (zohl)
12:49:07 * hackagebot throttled-io-loop 0.1.0.1 - Loop over an action but throttle it to a certain rate  https://hackage.haskell.org/package/throttled-io-loop-0.1.0.1 (RobertFischer)
12:49:17 <geekosaur> you might want to find a Haskell tutorial and learn how IO works, and how you work with it. there's no need to "escape" here, you have everything you need right there
12:50:27 <ertes> it's an instance of the common "'IO X' means 'X with side effects'" misconception
12:50:34 <blair__> Beauty! Thanks folks!
12:50:45 <lpaste> geekosaur annotated “xmonad config” with “xmonad config (annotation)” at http://lpaste.net/165341#a165345
12:51:19 <geekosaur> well, except X is a bad choice there since it's the name of xmonad's monad
12:51:30 <ertes> oh, yeah
12:51:43 <ertes> it's an instance of the common "for all t, 'IO t' means 't with side effects'" misconception
12:51:54 <ertes> better?
12:54:05 * hackagebot throttled-io-loop 0.1.0.2 - Loop over an action but throttle it to a certain rate  https://hackage.haskell.org/package/throttled-io-loop-0.1.0.2 (RobertFischer)
12:54:51 <Berra> I am so lost, if someone wanted to help that would be very appreciated. http://lpaste.net/165347 
12:56:01 <mauke> Berra: what's unclear about the first error?
12:59:45 <Berra> mauke: Well it's my bad understanding about syntax and the ParseCombinator. See I'm unsure as to how I return the right value. Because of pComment :: Parser Comment must I seems to me that it must return a constructed value but it expects Text.Parsec.Prim.ParsecT s0 u0 m0 a0.
13:00:56 <mauke> Berra: no, it doesn't
13:01:11 <Berra> mauke: Well in that case I'm even more lost
13:01:20 <mauke> again, what is unclear?
13:01:40 <Berra> mauke: Sorry, never mind.
13:02:00 <Berra> mauke: Afraid I can't formulate my problems enough for you to help me.
13:02:04 <Zemyla> Okay, Berra, I have a way for you to visualize parsers.
13:02:18 <Berra> Zemyla: How is that?
13:02:47 <mauke> Berra: start at the beginning. point out the first thing that doesn't make sense, and why
13:02:47 <Cale> Berra: pDocComment is not a function -- you can't apply it to the argument 'value'
13:02:56 <Cale> It's a  Parser Comment
13:03:00 <geekosaur> Berra, the real point of that error is the line after the type error itself. the one talking about how you called pDocCOmment with an argument, but it doesn't take an argument
13:03:04 <Zemyla> Okay, let's start with the simplest parser type: newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }
13:03:26 <geekosaur> `Parser Comment` is not a parser with a Comment as an argument, it's a Parser that *produces* a Comment
13:03:42 <mmachenry> Berra: pDocComment should not be applied to an argument, but you apply it to value.
13:03:42 <geekosaur> (Comment is a type level argument, not a value parameter)
13:04:44 <Berra> Alright - so what's the correct course of action at the end of pComment to produce either a DocComment or a TextComment - given that I can't call pDocComment?
13:05:58 <mmachenry> What is the meaning of pComment? Is that document comments and one-line or just one-line?
13:06:06 <mmachenry> It looks like you have both in there.
13:06:46 <mauke> many anyChar
13:06:47 <mauke> oh wow
13:07:13 <glguy> That's a lot of characters
13:07:22 <EvanR> a language to nowhere
13:07:25 <mauke> Berra: what is the intended syntax for DocComments and TextComments?
13:08:24 <Berra> mmachenry: Yeah so pComment should parse one-line comments and a said comment can either be a text comment containing free text or a comment that describes the function it tries to document. So that's what I'm trying to do in pComment. Parse a comment and return which ever kind of comment it is.
13:09:07 <Berra> mauke: sig <- many (noneOf "\n") -- better right?
13:09:20 <mauke> I'd start by grabbing a line (you're already doing that in 'value') and then checking whether it contains " :: "
13:09:41 <mmachenry> mauke: That's probably not a good use of Parsec
13:10:05 <mmachenry> It would probably work but it's meant to be used differently.
13:10:08 <Berra> mmachenry: Right, my understanding is that it's better to try the parses that make sense in the context, right?
13:10:39 <mmachenry> Yeah, sadly I'm in the middle of another convo and on a milling machine atm :)
13:10:41 <mauke> mmachenry: then you have to left-factor or use 'try'
13:10:44 <baordog> What function do I need to concat a bytestring and a bytestring (not [bytestring] and [bytestring])
13:10:56 <baordog> ?
13:11:07 <mauke> baordog: <> might work, if it has a Monoid instance
13:11:07 <EvanR> mappend
13:11:21 <glguy> baordog: http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#g:3
13:11:27 <glguy> These will be useful functions to know
13:11:55 <EvanR> or BS.append
13:12:00 <EvanR> but <> is shorter
13:12:37 <mmachenry> Berra: So it's "// this is my func" as well as "// foo :: Int -> Int"
13:12:53 <Berra> mmachenry: Exactly 
13:13:17 <mauke> well, or just "// :: asdf"
13:13:44 <mmachenry> Berra, start off writing a parser that parses the name :: type
13:14:08 <mauke> done, in pDocComment
13:14:29 <mauke> the name syntax is slightly wrong, but that's what it does
13:15:02 <Berra> mauke: What's a better way to safely parse the name and invalidate it if missing?
13:15:08 <mmachenry> Call it pDocComment. Then pComment should be more like pComment = do string"//"; pDocComment <|> pRegularComment
13:15:35 <mmachenry> I need to focus on something else. bbl
13:15:37 <baordog> EvanR: GHC says <> is out of scope
13:15:40 <baordog> Not in bytestring module?
13:15:41 <Berra> mmachenry: Aaaaha
13:15:47 <EvanR> Data.Monoid
13:17:01 <mauke> Berra: depends on what exactly you want to allow in a name, but I'm pretty sure you don't want to allow newlines in names or names of length 0
13:17:32 <glguy> It'd be easy to accidentally apply a function with a name of length 0
13:17:38 <Berra> mauke: Sure, it's the disallowing length 0 I'm unsure about 
13:18:09 <EvanR> also it would be hard to apply a function with name matching many anyChar
13:18:37 <mikail_> Hi, in my project I have a function argument called price (it's the actual price of an item). I then created a typeclass and inside there I have a function called price which prices items. When I compiled my project with -Wall, I started getting messages saying that the price function is shadowing the price argument.
13:18:54 <mikail_> Are these not in different namespaces in Haskell?
13:18:54 <mauke> Berra: IIRC that's called 'many1' instead of 'many' in parsec
13:19:01 <Berra> mauke: Perfect
13:19:36 <EvanR> or many1 anyChar
13:22:47 <baordog> In errors what does t0 TYPE mean?
13:22:54 <baordog> Like could not match TYPE with t0 TYPE?
13:22:57 <geekosaur> mikail_, they're in different scopes, but the same namespace
13:23:53 <geekosaur> baordog, TYPE is a parameter to an unknown type constructor. t0 *might* mean a type constructor with a Traversable instance
13:24:06 * hackagebot boomerang 1.4.5.2 - Library for invertible parsing and printing  https://hackage.haskell.org/package/boomerang-1.4.5.2 (JeremyShaw)
13:24:11 <geekosaur> :t pure 5
13:24:12 <lambdabot> (Num a, Applicative f) => f a
13:24:32 <geekosaur> hm, bad example really
13:24:36 <geekosaur> :t pure 'a'
13:24:37 <lambdabot> Applicative f => f Char
13:24:51 <geekosaur> "f" there is doing the same thing as your "t0"
13:24:55 <mikail_> ok , so I should really name them differently
13:25:13 <baordog> My error is: "Couldn't match expected type ‘t0 BSL.ByteString’ with actual type ‘BSL.ByteString’
13:25:28 <baordog> I don't know what the compiler is trying to tell me...
13:25:29 <geekosaur> @paste actual code and full error?
13:25:29 <lambdabot> Haskell pastebin: http://lpaste.net/
13:25:56 <geekosaur> anyway there's not enough information here to know exactly what it
13:26:31 <geekosaur> s saying, but it's analogous to "you used a ByteString where it expected a list of ByteStrings" --- only it doesn't have to be a list, it could be some other thing
13:27:06 <geekosaur> and the nbad part of polymorphism is you can't generally tell what it's looking for in cases like this without seeing the code in question
13:27:09 <baordog> geekosaur: http://lpaste.net/165351 
13:27:16 <baordog> ^ I am likely doing this all wrong
13:27:32 <mikail_> In some Haskell projects I see programmers commenting their function parameters with "--^" - I can't find any information on what that does.
13:27:50 <mauke> :t BS.repeat
13:27:51 <lambdabot>     Not in scope: ‘BS.repeat’
13:27:52 <lambdabot>     Perhaps you meant one of these:
13:27:52 <lambdabot>       ‘BSL.repeat’ (imported from Data.ByteString.Lazy),
13:27:55 <mauke> :t BSL.repeat
13:27:56 <EvanR> mikail_: its haddock
13:27:56 <lambdabot> Word8 -> Data.ByteString.Lazy.Char8.ByteString
13:28:11 <mikail_> ok
13:28:43 <baordog> What I am trying to do is do something like print "a"* 1043 + "0xbeef" would be in python
13:28:45 <geekosaur> ok, it's defintely looking for a Traversable instance (polymorphic mapM_, which used to be on lists but is now on any Traversable)
13:28:50 <geekosaur> and it can't tell which one to use
13:29:04 <baordog> ok, so how do I fix that? Kinda new to haskel 
13:29:09 <mauke> baordog: BSCL.replicate 4061 'a'
13:29:28 <mauke> the first issue is that repeat/replicate take a single char, not a string ("a")
13:29:47 <baordog> confused
13:29:55 <mauke> 'a' is a Char, "a" is a String
13:30:04 <baordog> oh
13:30:09 <mauke> the second issue is that you're trying to mapM_ over something that's just a single string, not a collection
13:30:37 <mauke> third issue would be Word8 vs. Char
13:30:46 <baordog> Ok so what's stil a char?
13:30:59 <baordog> And what function should I use to print?
13:31:02 <mauke> huh?
13:31:15 <baordog> You said there's a char vs word8 issue. What's still stuck as a char?
13:31:32 <mauke> I don't understand
13:32:12 <mauke> let's start at the beginning. do you want to use strict bytestrings or lazy bytestrings?
13:32:17 <baordog> What did you mean when you said "the third issue would be word8 vs. char"
13:32:40 <baordog> I am using lazy bytestrings so I can use repeat
13:32:47 <baordog> I have no other reason to use them
13:32:57 <mauke> take/repeat can be replaced by replicate
13:33:53 <mauke> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#v:replicate
13:34:08 <mauke> replicate takes two arguments, a count and a byte value
13:34:13 <mauke> the byte value is a number
13:34:15 <Berra> Thanks for the awesome help. Now it compiles and all. But the part with p1 <|> p2 -- doesn'
13:34:27 <Berra> doesn't seem to try the second parser if the first fails
13:34:28 <Berra> http://lpaste.net/165353
13:34:35 <baordog> YAY it works
13:34:49 <Berra> If I switch order on the the pTextComment works -- it just never parses if it's in second position
13:34:51 <mauke> if you import the Char8 version, it takes a Char instead of a number
13:34:55 <EvanR> Berra: if p1 consumers any characters, then p2 wont see those characters. 
13:34:59 <EvanR> thats how parsec works
13:35:11 <EvanR> you can use try p1 to make failure put all the characters back
13:35:27 <Berra> EvanR: Aha
13:35:28 <mauke> s/wont see those characters/won't be tried at all/
13:35:44 <baordog> mauke: Thanks for the help
13:35:45 <Berra> EvanR: It works -- thanks!
13:35:48 <EvanR> oh
13:36:04 <EvanR> if p1 uses any characters, the <|> wont even go to the next parser
13:36:32 <EvanR> for maximum zen you have to use <|> parsers which make the decision based only on the next character
13:36:40 <EvanR> or use try
13:49:01 <hexagoxel> (why is there no String newtype wrapper called "ShowIsId"?)
13:49:38 <monochrom> good idea, maybe you should add it
13:50:21 <coppro> hexagoxel: IsId?
13:50:34 <coppro> ohhh
13:50:38 <monochrom> :)
13:51:08 <coppro> I'm not sure that would be useful
13:52:09 <monochrom> it is often useful. I agree it is not always useful.
13:52:30 <monochrom> approx 40% useful
13:52:47 <mauke> it is unlawful
13:52:48 <jmcarthur> I am 40% sure it is useful.
13:52:51 <monochrom> but 40% is high enough to add to a library if you ask me
13:53:21 <monochrom> afterall, head and tail are only 1% useful and that's enough to land them in a library :)
13:53:39 <jmcarthur> head and tail are totally worth using as precedent
13:53:50 <mauke> UnsafeShow
13:53:50 <monochrom> it could be made lawful if there is no Read instance
13:54:11 <jmcarthur> What is Read even fore?
13:54:13 <mauke> the idea is that show should be valid haskell syntax
13:54:13 <jmcarthur> *for
13:54:28 <monochrom> although, this is a vacuous situation, so you could also deduce that it is unlawful because there is no Read instance
13:55:16 <geekosaur> there is precedent for this. not very good precedent, but on the flip side encouraging people to use Show and Read for serialization is also a bad idea
13:55:20 <coppro> monochrom: no, the Show laws apply regardless of Read instances
13:55:35 <coppro> er... wait, nvm
13:55:42 <coppro> misread the docs
13:55:48 <geekosaur> if you think of Show as for debugging then it's not entirely terrible
13:56:04 <monochrom> perhaps the right approach is to create a fresh type class for producing strings for humans, which overlaps with but not identical to producing strings for debugging messages
13:56:08 <jmcarthur> "my law" for Show is that I should be able to paste the output into ghci and get back the original value
13:56:30 <jmcarthur> I've never used Read except for hacky Int->String conversions
13:56:40 <coppro> still, show as id is a poor interface
13:56:45 <monochrom> because if you have a number like 42, then "42" is the right string for both output and debugging
13:57:12 <coppro> I can think of all sorts of wonky things that strings like "undefined" might make you think you were looking at
13:57:15 <jmcarthur> String->Int I mean
13:57:42 <monochrom> but if you have a string like "a\nb\nc", then the two purposes differ
14:00:31 <monochrom> coppro, we have long lost fidelity ever since editors began to display tabs as a user-changeable amount of space.
14:03:44 <dolio> Meanwhile, over in Scala, toString on Strings is id. And I don't think it's ever been what I wanted.
14:04:24 <aristid> dolio: what else would toString do on a string? quote it?
14:05:15 <jmcarthur> If newtype F f a = F (forall m. Monad m => (forall x. f x -> m x) -> m a) makes free monads, what makes free monad transformers? newtype FT f m a = FT (forall (Monad (t m), MonadTrans t) => (forall x. f x -> t m x) -> t m a) doesn't feel right.
14:05:29 <hexagoxel> > take 50 $ fix show
14:05:31 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
14:05:31 <dolio> toString is all you have that is like show.
14:05:55 <dolio> And I have never used it for anything where it wouldn't have been better for the string to be quoted.
14:05:58 <monochrom> jmcarthur: the library "free" has an answer
14:06:03 <Zemyla> jmcarthur: A better free monad is newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r }
14:06:11 <jmcarthur> monochrom: I don't think it has free monad transformers in this style, does it?
14:06:14 <jmcarthur> looking again
14:06:27 <jmcarthur> Zemyla: I know of it, but why do you claim it's better?
14:06:47 <monochrom> in Control.Monad.Trans.Free.Church
14:06:49 <jmcarthur> monochrom: I think the free package only has that style for applicative and alternative.
14:06:55 <simpson> dolio: In Monte, which is kind of like Java, we have both .toString() and .toQuote(). The former's used to build strings with string interpolation, but the latter's used for display and whatnot. And I totally agree with you that that quoting behavior has to come builtin.
14:06:59 <jmcarthur> monochrom: That's not the same thing.
14:07:22 <jmcarthur> monochrom: Not the same style, I mean.
14:07:39 <Zemyla> jmcarthur: Because it is naturally right-associative and doesn't force it to take in a Monad dictionary when used.
14:07:45 <monochrom> I see
14:07:58 <aristid> i'm glad show is not called toString in haskell
14:08:11 <jmcarthur> Zemyla: But there's a trade-off. It's not always better.
14:08:14 <monochrom> could you translate from the library's style to your style?
14:08:30 <Zemyla> jmcarthur: Also, it can be translated into things that aren't necessarily monads.
14:08:46 <monochrom> ok, I don't know how to translate
14:08:46 <jmcarthur> Zemyla: No it can't. It just doesn't force you to explain why it's a monad.
14:09:08 <Zemyla> jmcarthur: If f is Foldable, then foldMap f (F m) = m f fold.
14:09:23 <jmcarthur> Zemyla: I understand the theory behind it.
14:10:55 <Zemyla> jmcarthur: I can't see how the forall m. (Monad m) => (forall x. f x -> m x) -> m a formulation is better.
14:10:59 <dolio> To get the answer, you figure out what the category of monad transformers is like, make a forgetful functor, and construct the left adjoint with a right kan extension.
14:12:02 <monochrom> :)
14:12:26 <dolio> That's what you always do. Now you don't have to ask. :)
14:12:26 <monochrom> I offer to do that for you for a research grant of cdn$1000 :)
14:16:26 <jmcarthur> Zemyla: Sometimes re-associating hurts more than it helps. My version allows you to opt in to that if you want it or not if you don't. Also, my version forces you to understand how your monad works while still allowing you to defer thinking about it until you write your "run" function.
14:23:06 <nitrix> Is there such thing as a monad that matches each element of a list respectively?
14:23:19 <nitrix> And if the list is empty, then the computation fails?
14:23:31 <nitrix> Sort of like MaybeT behavior to lists?
14:24:09 * hackagebot timeprint 0.1.0.0 - Prints timestamps after each line evaluated  https://hackage.haskell.org/package/timeprint-0.1.0.0 (leftparen)
14:24:10 <nitrix> do { first <- pick; second <- pick; third <- pick; return $ f first second third } ?
14:24:22 <nitrix> I know I can just pattern match but :/
14:24:37 <EvanR> yurg... liftA3 f pick pick pick
14:25:31 <EvanR> you might be thinking of the Supply monad
14:32:17 <Zemyla> nitrix: You can do that with StateT [s] Maybe.
14:33:19 <Zemyla> :t StateT uncons
14:33:20 <lambdabot> StateT [a] Maybe a
14:33:54 <mikail_> Can declarative programming be considered the same as functional programming?
14:33:59 <Zemyla> :t \f -> let pick = StateT uncons in liftA3 f pick pick pick -- nitrix
14:34:00 <lambdabot> (c -> c -> c -> d) -> StateT [c] Maybe d
14:34:14 <mikail_> or vice versa
14:34:31 <hpc> mikail_: on one level, functional programming is a set of features and declarative programming isn't that i know of
14:34:45 <hpc> mikail_: on another level, they're both styles of programming that do have a good deal of overlap
14:34:50 <hpc> so, sometimes ;)
14:35:08 <mikail_> from what i have read, it seems FP is a subset of DP?
14:35:14 <mikail_> would you agree?
14:35:39 <hpc> it's where the emphasis is
14:35:58 <hpc> if you consider declarative programming to be checking the box that says "i declared something", almost every language qualifies
14:36:26 <hpc> you can write functional-style code that gives very few things actual names
14:36:35 <hpc> or you can write highly declarative code in something like C
14:36:45 <geekosaur> declarative is more of a style, which can be applied to more than just functional programming (notably, logic programming --- Prolog is even more declarative than Haskell)
14:37:24 <mikail_> yeah that's my current understanding of it geekosaur
14:37:50 <hpc> declarative programming places emphasis on the use of definitions to express things, functional programming focuses on the many ways of using first-class functions
14:37:55 <Berra> So my Comment parses work fine now, so I'm trying to implement a parser to categories sections in a file. http://lpaste.net/165360 Example of outcome I'm looking for. I think I'm missing some idea or pattern on how to achieve this.
14:37:57 <mikail_> which is why i said FP can be "looked at" as a subset of DP
14:38:14 <hpc> > zip`ap`tail [1..] -- functional-style example that could hardly be said to be declarative
14:38:15 <lambdabot>      Couldn't match expected type ‘[Integer -> b]’
14:38:15 <lambdabot>                  with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
14:38:15 <lambdabot>      Probable cause: ‘zip’ is applied to too few arguments
14:38:20 <hpc> erp
14:38:24 <hpc> > zip`ap`tail $ [1..] -- functional-style example that could hardly be said to be declarative
14:38:26 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
14:38:27 <geekosaur> I wouldn't say subset, I would say they are partially overlapping sets
14:38:54 <augur> does anyone know of a video that discusses the origins of monads in haskell, including the evolution towards having monad transformers and mtl?
14:38:58 <hpc> it's very easy to construct examples that demonstrate either style without the other
14:38:59 <mikail_> sure
14:39:06 <hpc> meaning it can't be a subset
14:39:23 <geekosaur> they often do occur together, insofar as declarative style is considered good in many functional languages, but you don't have to use declarative style to write in a functional language
14:39:28 <mikail_> yep agree, wrong word for it
14:39:53 <hpc> every time you use a lambda instead of a named function, you're eschewing declarative style in functional code just a little bit more
14:40:34 <hpc> augur: that's pretty early history, a pretty niche topic for putting in the production effort
14:40:40 <jmcarthur> nitrix: That sounds like a parser combinator library to me.
14:41:16 <augur> hpc: i've SEEN a video tho. i remember seeing it. and i'd swear it was a talk by kmett, but i cannot find it for the life of me
14:41:17 <hpc> there might be slides somewhere, though i would have to google a bit to know for sure either way
14:41:23 <hpc> oh, huh
14:41:26 <augur> maybe it was a wadler talk but i dont know that, either
14:41:39 <adam1> whats the best way to represent a matrix as a data structure?  Ideally I would be able to encode the dimensions of the matrix as part of the type so that way when doing matrix multiplication I can prevent dimensionality mismatch at compile time 
14:41:43 * EvanR imagines "the good language", a high budget documentary about the origin of monads in haskell, with interviews with the early pioneers as they dreamily reminisce, like a shitty football documentary
14:41:43 <hpc> i have no idea then
14:41:55 <augur> and i distinctly remember that in the talk there was discussion of why monad transformers are superior to effect systems because they dont artificially force effect order
14:42:14 <Berra> EvanR: Kickstarter :>
14:42:43 <EvanR> it should have slow motion cut aways to SPJ typing on a late 80s keyboard
14:42:49 <adam1> data Matrix m n = Matrix [[a]]
14:43:07 <Berra> EvanR: Filming that would actually be a dream come true
14:43:09 <adam1> would that work? have m and n be phantom types
14:43:09 <geekosaur> lists are probably the worst way to do it, adam1
14:43:14 <hpc> adam1: have you looked at any of the existing matrix libs?
14:43:22 <geekosaur> since Haskell lists are singly-linked lists / cons cells
14:43:22 <hpc> or is this for a class or something and you can't?
14:43:27 <AlainODea> augur: Simon Peyton Jones has a talk with a quick review of the history of Haskell including the challenges of introducing type classes and monad
14:43:48 <augur> AlainODea: hm. which was that? maybe im mistaking people
14:43:51 <adam1> this is for my own personal project. not for school but i just want to really learn linear algebra well
14:43:57 <geekosaur> "wearing the hair shirt"?
14:44:05 <geekosaur> re history of haskell
14:44:11 <adam1> i made a similar project in c++ using mutable arrays and that worked fine
14:44:26 <AlainODea> It's on YouTube. I'll see if I can track it down. It has some funny graphs in it with things like valley of despair as annotations on them
14:44:38 <hpc> adam1: you'd probably do best to skip right past implementing matrices, because it's pretty tedious in any language
14:44:50 <adam1> but the problem was that I would have to check the dimensions of the matrix before doing computations which seems like something a richer typesystem would allow me to prevent
14:44:55 <shirt> geekosaur: eh?
14:44:57 <hpc> adam1: and go looking for ways to use them, with an existing library
14:45:06 <augur> AlainODea: oh maybe it was SPJ's lectures from OPLSS?
14:45:11 <adam1> yeah i guess thats not a bad idea
14:45:13 <augur> Adventures with Types in Haskell?
14:45:21 <adam1> i looked at hmatrix and accelerate
14:45:23 <hpc> adam1: maybe do a reverse dependency search on one of those libraries and then reimplement that
14:45:29 <hpc> @where reverse
14:45:30 <lambdabot> I know nothing about reverse.
14:45:31 <augur> if not, itll be good to watch this again anyway :)
14:45:33 <hpc> hmm
14:45:37 <hpc> @where reverse-hackage
14:45:37 <lambdabot> I know nothing about reverse-hackage.
14:45:41 <latro`a> adam1, even if you had type level integers, your constructor there doesn't actually guarantee that the size you're using is mxn, or indeed even that your list of lists is shaped like a rectangular array. to really put sizes in the type system, you kinda need polymorphic values, which is hairy
14:45:55 <adam1> hmm
14:45:59 <hpc> @where+ reverse http://packdeps.haskellers.com/reverse reverse deps
14:45:59 <lambdabot> Good to know.
14:46:07 <hpc> @where+ reversedeps http://packdeps.haskellers.com/reverse
14:46:07 <lambdabot> Nice!
14:46:12 <hpc> @where+ reversehackage http://packdeps.haskellers.com/reverse
14:46:12 <lambdabot> I will remember.
14:46:14 <geekosaur> shirt: title of an SPJ paper on the history of Haskell
14:46:33 <blair__> Hey folks, got xmonad to toggle everything properly. If you want to see the end result (since you helped) here you go https://github.com/blairdrummond/dots
14:46:39 <AlainODea> augur: I think he addresses it in "Adventures with Types in Haskell." https://youtu.be/6COvD8oynmI
14:46:45 <geekosaur> third link here http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/
14:46:51 <augur> AlainODea: :)
14:47:20 <geekosaur> btw blair__ we have #xmonad too :)
14:47:23 <adam1> latro`a: so there would be no way to force a matrix to be non jagged an of a certian size (m x n)
14:47:23 <AlainODea> geekosaur: you've got it! (augur)
14:47:36 <augur> :)
14:47:37 <AlainODea> Adventures with Types is really great as well
14:47:45 <adam1> that way i could say that multiplication is m x n  *  n x a 
14:47:58 <latro`a> adam1, there is, but it's harder than that
14:48:07 <blair__> geekosaur: Haha! Good point! Forgot about that channel!
14:49:24 <latro`a> http://stackoverflow.com/questions/8332392/type-safe-matrix-multiplication
14:49:28 <latro`a> @ adam1 
14:49:40 <adam1> well hopefully its better then what I was doing in c++ haha. I had an accumulator which started at the length of the first row of the matrix.  Then I ran down the rows and if there was ever a mismatch between the accumulator and the length of the ith row I could say it is jagged
14:49:43 <hpc> adam1: oh yes, a fun thing you can sort of notice in the type system is how matrices are a representation of mathematical functions
14:49:59 <hpc> adam1: and there's some stuff like multiplication being function composition, which you can see by the type
14:50:24 <hpc> mult :: (a `X` b) -> (b `X` c) -> (a `X` c)
14:50:26 <adam1> hpc that makes sense. isnt the reason we use dot operator for composition because it looks like multiplication
14:50:41 <adam1> and matricies are functions on vectors that return new vectors
14:50:58 <linoge> Any idea why the following would cause unespecified behavior: http://lpaste.net/165364 ?
14:51:00 <adam1> then multiplying matrices creates a new function which is the composition of the previous two
14:51:08 <hpc> we use (.) because it's the closest ascii thing to hollow middot, which is the mathematical function composition symbol
14:51:19 <hpc> i don't know how math came up with that
14:51:21 <adam1> well yeah but where did that symbol get its roots?
14:51:58 <hpc> hollow middot looks quite unlike multiplication in any event
14:52:55 <geekosaur> just beware of how much stuff came from "that's what the printer could do" >.>
14:53:05 <hpc> oh wait, i guess middot is a multiplication symbol too
14:53:07 <adam1> latro`a: thanks for the link, it looks like a good read
14:53:10 <hpc> it's not really used for matrices though
14:54:20 <hpc> yeah, before tex and after papers were typeset it was extremely frustrating to try and put any sort of symbols into a paper
14:56:59 <hpc> (this means publishing in math was extremely frustrating for most of the history of modern math)
15:01:55 <augur> what are some of the hot new ideas for the newest versions of haskell?
15:01:59 <augur> or at least of GHC?
15:04:24 <haskell017> hello, somone here?
15:05:10 <darkf> haskell017: yes?
15:05:40 <geekosaur> nope, 1500 zombies in the house
15:06:15 <haskell017> i have spent 3 hours for finding bug in my code..
15:06:17 <haskell017> http://ideone.com/Lh7NOe
15:06:39 <haskell017> somone could try help why there is divide by 0 exception?
15:08:12 <haskell017>  when i change line digits3 n = (n `div` 100, n `mod` 100) to digits3 n = (1 `div` 100, 1 `mod` 100) it seems to work ... 
15:08:47 <darkf> haskell017: I imagine the (`div` (10^k)) is being used with k<0
15:09:11 <geekosaur> ghc would fault that with negative exponent though
15:09:17 * geekosaur wonders if ideone still uses hugs
15:09:32 <geekosaur> nope, mouseover says ghc 7.8
15:09:55 <geekosaur> but that was the first thing I noticed too
15:10:20 <glguy> I think that it's probably that Int is being used instead of integer
15:10:39 <glguy> so the 10^k is overflowing to 0
15:10:46 <haskell017> Oh
15:10:47 <geekosaur> oh, that could do it too
15:10:54 <haskell017> k>0 100%
15:11:35 <geekosaur> right, and all the (!!)s are forcing Int
15:12:22 <haskell017> yeah ii think you are right
15:12:26 <haskell017> Couldn't match type ‘Integer’ with ‘Int’
15:12:40 <geekosaur> yeh, all the indices have to be wrapped in fromIntegral
15:13:11 <barrucadu> Or use genericIndex from Data.List
15:15:29 <haskell017> how to use genericIndex? I have never used it before
15:18:10 <EvanR> > genericIndex (1^100) [1..]
15:18:11 <lambdabot>      Could not deduce (Integral [t0])
15:18:11 <lambdabot>        arising from a use of ‘genericIndex’
15:18:11 <lambdabot>      from the context (Num [a])
15:18:20 <EvanR> not like that
15:18:45 <EvanR> > [1..] `genericIndex` (1^100)
15:18:47 <lambdabot>  2
15:18:54 <EvanR> > [1..] `genericIndex` (1^100 :: Inteeger)
15:18:56 <lambdabot>      Not in scope: type constructor or class ‘Inteeger’
15:18:56 <lambdabot>      Perhaps you meant ‘Integer’ (imported from Prelude)
15:18:59 <EvanR> > [1..] `genericIndex` (1^100 :: Integer)
15:19:00 <lambdabot>  2
15:19:15 * EvanR accepts that as correct
15:24:11 * hackagebot pandoc 1.17.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.1 (JohnMacFarlane)
15:26:50 <haskell017> works! thanks
15:32:01 <Tangerine> how do you and two functions together?
15:32:23 <Tangerine> suppose you have [Char] -> Bool
15:32:31 <Tangerine> and I want to check
15:33:04 <Tangerine> uhh
15:33:16 <Tangerine> notZeros :: [Char] -> Bool
15:33:28 <Tangerine> notZeros x = all (isDigit & != 0) x
15:33:43 <EvanR> :t All
15:33:44 <lambdabot> Bool -> All
15:34:02 <EvanR> (fmap All f) <> (fmap All g)
15:34:18 <glguy> Tangerine: You name your function's variable with a lambda or a new named function
15:34:26 <glguy> like: all (\x -> .... ) x
15:34:33 <glguy> like: all (\y -> .... ) x
15:34:42 <jmcarthur> :t all (liftA2 (&&) isDigit (/= 0))
15:34:43 <lambdabot>     Could not deduce (Num Char) arising from the literal ‘0’
15:34:43 <lambdabot>     from the context (Foldable t)
15:34:43 <lambdabot>       bound by the inferred type of it :: Foldable t => t Char -> Bool
15:34:49 <jmcarthur> :t all (liftA2 (&&) isDigit (/= '0'))
15:34:51 <lambdabot> Foldable t => t Char -> Bool
15:35:11 <Tangerine> :t liftA2
15:35:12 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:35:13 <glguy> Let's teach Tangerine what a lambda is and then we can impress with our cleverness
15:35:28 <jmcarthur> :t liftA2 (&&) (all isDigit) (all (/= '0')  -- it distibutes, too
15:35:30 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:35:31 <Tangerine> I understand what a lambda is. This makes sense
15:35:34 <jmcarthur> :t liftA2 (&&) (all isDigit) (all (/= '0'))  -- it distibutes, too
15:35:35 <lambdabot> Foldable t => t Char -> Bool
15:35:38 <Tangerine> I think what I didn't know is how liftA2 works
15:35:53 <jmcarthur> @src liftA2
15:35:53 <lambdabot> liftA2 f a b = f <$> a <*> b
15:35:57 <shapr> any suggestions for improvement on http://lpaste.net/165369 ?
15:37:16 <jmcarthur> Tangerine: Once you figure out that the Applicative instance being used is ((->) a), you can resolve the definitions of (<$>) and (<*>) to learn that liftA2 f g h = \x -> f (g x) (h x)
15:37:53 <jmcarthur> Tangerine: (That was my attempt to both give you the answer directly and explain how you might figure it out on your own.)
15:38:56 <Tangerine> i'm getting
15:39:02 <Tangerine> not in scope 'liftA2
15:39:11 <jmcarthur> glguy: I may have misinterpreted the question. I interpreted "and two functions together" as a request to compose them somehow, as opposed to using a lambda.
15:39:31 <geekosaur> Tangerine, what version of ghc?
15:39:47 <jmcarthur> Tangerine: It lives in Control.Applicative. By the way, as glguy tried to point out, I may have misinterpreted what you were going for.
15:40:28 <Tangerine> 7.10.3
15:40:32 <jmcarthur> Tangerine: A simpler version for more of a beginner would be to use a lambda. And by the way, it's not even necessarily "worse" than what I proposed.
15:40:58 <Tangerine> lambba sounds like a good idea
15:41:12 <jmcarthur> :t all (\x -> isDigit x && x /= '0')
15:41:13 <lambdabot> Foldable t => t Char -> Bool
15:42:11 <glguy> shapr: I'd be likely to use fromListWith for that, and then if you only care how many you only need to keep a count http://lpaste.net/2194247256213815296
15:42:33 <jmcarthur> shapr: What is your goal to improve it? To be simple and easy to read? To be clever? To be short? To be efficient?
15:42:57 <glguy> jmcarthur: I think your simpler version is also what an expert would use :-p
15:43:50 <jmcarthur> glguy: Point free style comes very naturally to me, at least.
15:44:12 * hackagebot timeprint 0.1.0.1 - Prints timestamps after each line evaluated  https://hackage.haskell.org/package/timeprint-0.1.0.1 (leftparen)
15:44:33 <glguy> I'm not saying the expert wouldn't understand, just that they wouldn't put it in the file as an altnerative to the clearer version
15:44:40 <jmcarthur> glguy: Even when it's not shorter, I often like it more. Take this example. I was able to express the solution exactly as the question was worded.
15:44:57 <jmcarthur> I literally "anded two functions together"
15:45:55 <jmcarthur> It was the first thing I thought of, is the point.
16:00:19 <barrucadu> If there are multiple allowable versions of a package in a build plan, how does Cabal disambiguate? Just pick the newest?
16:03:42 <Vektorweg1> whats a simple, pure ram relational database lib?
16:04:27 <glguy> sqlite3
16:06:16 <Vektorweg1> is not pure.
16:08:10 <simpson> Vektorweg1: Oh, you didn't mean "pure ram". Did you want an embedded Prolog or something?
16:08:27 <Vektorweg1> yep
16:09:45 <Vektorweg1> simpson: something close to embedded prolog would be awesome. 
16:10:53 <jmcarthur> LogicT? Not sure what the requirements are.
16:11:57 <hpc> some kind of graph library?
16:13:40 <hexagoxel> barrucadu: there can be preferences, which affect choice but not what is "allowed". apart from that, mildly certain that newest is correct.
16:13:42 <Vektorweg1> tried graph library. however, its not really elegant to dangle with all those keys manually. its not exactly made for this. 
16:14:13 * hackagebot timeprint 0.1.0.2 - Prints timestamps after each line evaluated  https://hackage.haskell.org/package/timeprint-0.1.0.2 (leftparen)
16:14:13 <Vektorweg1> and i still can't tell if logicT can actually do that. its hell complicated for me. 
16:18:42 <hseg> Hi. Daniel Bergey on Haskell-beginners made me realize the following: For representable functors, the Applicative and Monad typeclasses are of equal power, as witnessed by join f = flip ($) <*> f
16:18:58 <hseg> Is this correct/well-known?
16:19:13 * hackagebot Shellac-haskeline 0.2.1 - Haskeline backend module for Shellac  https://hackage.haskell.org/package/Shellac-haskeline-0.2.1 (RobertDockins)
16:19:15 * hackagebot timeprint 0.1.0.3 - Prints timestamps after each line evaluated  https://hackage.haskell.org/package/timeprint-0.1.0.3 (leftparen)
16:20:27 <jmcarthur> :t \f -> flip ($) <*> f
16:20:27 <glguy> hseg: This is known: http://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html#g:7
16:20:28 <lambdabot> (a -> a -> b) -> a -> b
16:20:28 <glguy> bindRep 07:: Representable f 07=> f a 07-> (a 07-> f b) 07-> f b
16:20:50 <hseg> Ah, OK. Neat calculation, though.
16:21:49 <hseg> I suppose this is a consequence of -> and (,) being closely related?
16:25:09 <buttbutter> Hey. I just tried writing "foldl" in terms of "foldlr" as an exercise. I have the solutions, but feel like if I look at it I'll spoil it for myself if it's incorrect. Can someone simply tell me if what I've done is correct or not? http://lpaste.net/165385
16:25:32 <jmcarthur> shapr: With the discrimination package:    main = interact $ unlines . map unwords . (runSort . sortingBag) sorting . join zip . lines
16:25:45 <buttbutter> Or maybe there's a good way I can check for myself. Is there a way to check function equivalence in Haskell? 
16:26:02 <glguy> buttbutter: Generally when you're doing that exercise you don't use any outside functions
16:26:16 <jmcarthur> shapr: That's the problem as states in the blog post, not as written in your lpaste, since yours seems to just print the number of groups or something.
16:26:17 <buttbutter> What's an outside function?
16:26:21 <jmcarthur> *as states
16:26:24 <jmcarthur> **as stated
16:26:26 <glguy> buttbutter: reverse, in this case
16:26:28 <hseg> buttbutter: You could just inline definitions to check what runs.
16:26:30 <buttbutter> Oh. 
16:26:52 <glguy> buttbutter: It's OK to name some stuff in a where clause, but that stuff shouldn't be recursive
16:26:57 <buttbutter> Does that mean I should write my own reverse or there's a better way that doesn't need reverse at all?
16:27:06 <hseg> buttbutter: Moreover, your code is incorrect. It will compute (f (f (xn-1) xn) xn-2)...
16:27:10 <jmcarthur> There is a way that doesn't need reverse at all.
16:27:17 <buttbutter> Ah :(
16:27:24 <hseg> buttbutter: Instead of f (f x1 x2) x3 ...
16:29:21 <buttbutter> hseg: I thought the use of reverse fixes that.
16:29:33 <buttbutter> Oh, wait.
16:29:46 <buttbutter> Nevermind, I see what you're saying. That's introduced by the reverse. :C
16:30:08 <buttbutter> Okay, I need to think aobut this some more. Thanks for the help. :)
16:30:14 <hseg> np
16:30:48 <hseg> buttbutter: Actually, I think I may have miscalculated the result of your program.
16:32:48 <buttbutter> hseg: Do you think it's correct?
16:33:01 <buttbutter> I mean, if it can be done without reverse I'm not happy with it regardless :)
16:33:24 <glguy> buttbutter: The specific restriction is that you need to pass the list xs directly to foldr
16:33:38 <buttbutter> Okay.
16:33:39 <glguy> it doesn't get to go through any other function on its way there
16:33:52 <buttbutter> I see. So all the magic has to happen in the functio that I pass to foldr.
16:35:34 <hseg> ... Sorry, my mistake. Your code is indeed *behaviourally* correct, but as glguy points out, the exercise is to find g,w dependent on f,z such that foldl f z = foldr g w
16:36:09 <buttbutter> Cool. :D
16:36:17 <buttbutter> Okay, gonna figure that out now. Thanks, hseg and glguy.
16:36:19 <hseg> I was going to point out that your use of reverse makes the code incapable of dealing with infinite lists, but then realized that foldl can't either (due to such lists creating an infinite stack)
16:36:53 <buttbutter> Yeah. I read about that.
16:44:33 <jmcarthur> buttbutter: I think hseg's reformulation of the exercise is still misleading, but the only way I can think of to correct it seems like a big spoiler. :(
16:45:46 <buttbutter> That's okay. I'll figure it out!
16:46:05 <buttbutter> Although probably not tonight since it's my bedtime. Thanks for the help, though :)
16:58:17 <hpc> i just noticed the sdl2 package depends on itself
16:58:36 <hpc> oh, because of the examples lol
16:59:33 <koz_> hpc: [insert joke about recursion here]
17:00:14 <hpc> koz_: hpc: [insert joke about corecursion here]
17:00:21 <hseg> jmcarthur: 'Tis the peril of any who attempts to instruct. I will admit that my answer was hastily written and not well thought out
17:00:34 <koz_> hpc: Lol.
17:13:39 <ggVGc> so, I'm leaning to creating a DSL by just defining a AST as an ADT, some utility functions for creating the AST(which will be the DSL), and then just parse it, not using any advanced haskell type features
17:13:45 <ggVGc> does that seem reasonable?
17:14:23 <ggVGc> and then maybe start adding typing using haskell's type features to the helper functions later
17:14:30 <ggVGc> when I have a better understanding
17:14:47 <erisco> types are not optional
17:15:06 <ggVGc> what do you mean by that?
17:15:20 <hpc> ggVGc: if you mean just doing it with simpler types, then yes
17:15:29 <hpc> i think erisco is misreading that as you writing it in an untyped way
17:15:38 <erisco> all terms in Haskell must have a type. If you're referring to adding types to your own language, then okay that is something else and I misunderstood
17:16:08 <hpc> or like yeah, not having types in your language, or not having the types in your language be matched up with types that ghc would notice
17:16:11 <ggVGc> hpc: yeah, I mean just defining an ADT for the language constructs, and functions for building them in a nicer way, however with the possibility of creating an incorrect AST. Then have a compile function that parses the AST and detects incorrectness
17:16:16 <ggVGc> i.e getting less help from haskell
17:16:19 <ggVGc> but simpler implementation
17:16:56 <erisco> are you building an eDSL? you don't parse that usually, unless you're using TH
17:17:25 <ggVGc> I want to make a fairly simple language with essentially just records and functions, that I can compile to Lua
17:17:51 <ggVGc> I'd like the record accesses to be type safe, but I think I can add that afterwards when I have a better understanding
17:18:19 <erisco> if you're reading source code from a file, parsing it, and constructing an AST, the correctness of that AST is determined by the parser and your subsequent semantic analysis
17:18:31 <ggVGc> I've been reading the past days about GADTs and other ways of embedding  eDSL  types into haskell and have the haskell compiler sort it out, but I don't understand it well enough to know were to start
17:18:40 <ggVGc> no, no parser
17:18:43 <ggVGc> that's what I said
17:19:00 <erisco> you said "and then just parse it"
17:19:08 <ggVGc> rigt, parse the AST
17:19:14 <erisco> you don't parse ASTs
17:19:16 * hackagebot Frames 0.1.4 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.4 (AnthonyCowley)
17:19:23 <ggVGc> well, what word should I use then?
17:19:42 <erisco> parsing is the transformation of a linear structure, such as a list of tokens, into a tree
17:20:07 <ggVGc> and what is the transformation of an ADT into correct output, or rejected output?
17:20:12 <ggVGc> compilation?
17:20:55 <jmcarthur> code generation?
17:20:57 <ggVGc> either way, what I'm saying is that insterad of trying to make haskell understand my eDSL types and catch errors, I'll just make some functions for generating an AST, and then process that myself, detecting type errors myself
17:21:27 <ggVGc> because it seems like a huge job to figure out how to embed user defined types in haskell types correctly
17:22:17 <jmcarthur> As to your original question, yes, parsing a source file and constructing an AST is reasonable. It may or may not be the most efficient use of your time, but there's nothing fundamentally insane about it.
17:22:17 <erisco> you should understand GADTs to do that, but in the interim, yes, your approach sounds reasonable for an eDSL
17:22:40 <Welkin> erisco: LOL
17:22:45 <Welkin> just the person I was looking for
17:22:49 <ggVGc> yeah, I know I can use GADTs for it, but when I try to imagine what to do, it's like my mind isn't reachign far enough and the answer is beyond the horizon
17:22:55 <ggVGc> so I think I need to take a first simpler step first
17:23:01 <ggVGc> and then revisit it with GADTs
17:24:01 <ggVGc> jmcarthur: that's now what I meant. I've written parsers before. I worded it wrongly. I meant that I'll do the type checking myself rather than trying to get haskell to help me
17:24:04 <jmcarthur> You don't really need GADTs to make edsls.
17:24:07 <ggVGc> because that seems to actually be less work
17:24:27 <jmcarthur> Well, I disagree that it's less work to write a type checker than to use an existing one.
17:24:44 <jmcarthur> Unless you have type constraints that are very difficult to express in the host language's type system.
17:25:14 <ggVGc> yeah, but along the way it might click how to use GADTs
17:25:17 <ggVGc> and then I'll do that
17:25:20 <ggVGc> I feel stuck
17:25:35 <ggVGc> not sure where to start with GADTs, and I can't find any good resources that makes it click
17:25:44 <ggVGc> for my specific use case anyway
17:25:46 <jmcarthur> But hey, sticking with what you know can be pragmatic too, so I won't really argue that you are better off learning a bunch of stuff up front.
17:25:58 <jmcarthur> But again, you don't even really need GADTs to write DSLs.
17:26:18 <ggVGc> I want the user to be able to define custom types in the eDSL, and functions to act on those records in a type safe way. But I don't know how to model this in the haskell type system
17:26:30 <ggVGc> what's the simplest way to achieve this?
17:26:48 <jmcarthur> It's difficult to say without a language spec.
17:26:56 <ggVGc> I essentially only need structural typing
17:27:10 <jmcarthur> I tend not to make DSLs in which you define types in favor of just using Haskell type definitions instead.
17:28:03 <ggVGc> okay, that's fine, but how do I generate code from that later on?
17:28:14 <ggVGc> I've been struggling to find concrete examples of this type of thing
17:28:15 <jmcarthur> So for example I might make a function   tuple :: E a -> E b -> E (a, b)  to build tuples
17:28:52 <jmcarthur> For code generation, my type representation might be a String or whatever fancier type I need to be able to generate source code.
17:29:03 <patrice> hi all, i'm new to haskell, trying to do some work with regex, using Text.Regex.Posix, I can't manage to get both the matching text and the position, do I need to use another library for that?
17:29:14 <jmcarthur> I mean literally   newtype E a = E Builder   for some definition of Builder
17:29:38 <ggVGc> jmcarthur: do you have any somewhat complete or minimal example of this available somewhere?
17:29:41 <ggVGc> I'd love to read it
17:29:49 <jmcarthur> Not readily available, sorry. :\
17:30:15 <jmcarthur> This is something maybe worth a little blog post some time, but I've never gotten around to it.
17:30:47 <ggVGc> jmcarthur: if I now have a E (a,b), how do I define a function in the DSL that adds a and b and returns the result, in a way that I can generate that function body in an output language
17:31:03 <ggVGc> so, the output should be something like fun(a,b){return a+b}
17:32:04 <jmcarthur> ggVGc: What primitives do I have available to me in your DSL? Or are you asking me to suggest the primitives?
17:32:55 <ggVGc> jmcarthur: The primitives in the language are records, as I imagined it. I'm essentially trying to make a type safe subset of languages like Lua or javascript
17:33:05 <ggVGc> where the fundamental type is just a hash table
17:33:14 <ggVGc> and primitives like Int,Bool,String
17:33:34 <ggVGc> and I think structural typing is fine, i.e anything with {x:Int} is the same identity
17:33:44 <ggVGc> i.e not like haskel
17:35:10 <Clint> patrice: are you sure you want a regex?
17:35:45 <patrice> clint: yes I need it, trying to make a small template engine
17:36:14 <jmcarthur> ggVGc: I'd normally be inclined to model functions with lambda expressions, so I might define that function like:   lam (\a -> lam (\b -> a + b))   where  lam :: (E a -> E b) -> E (a -> b)
17:36:45 <jmcarthur> ggVGc: Or for an uncurried version I guess (+) would have to be different, or I'd need an uncurry primitive as well.
17:36:58 <Clint> patrice: well, there are a million regex libraries, maybe one of them isn't awful
17:37:26 <jmcarthur> ggVGc: This is difficult to explain without an example though. I'm sorry.
17:38:43 <patrice> clint: ah, is that why I haven't found any good template engines either, the lack of a good regex library?
17:39:06 <Clint> patrice: i dunno why you need regex for templates
17:39:57 <simpson> ggVGc: Write it out on paper first.
17:40:58 <ggVGc> simpson: not sure what I should write out on paper?
17:41:13 <patrice> clint: just for convenience, but definitely not a show stopper
17:41:36 <ggVGc> jmcarthur: yeah, thanks anyway. THis is why I think I need to start with whtever solution I understand right now, and the better implementation will come to me later
17:41:38 <Clint> patrice: i use shakespeare but there's also heist and hsp and stuff
17:41:53 <simpson> ggVGc: The AST and its nodes. Write out a couple example reductions; how does your language make progress?
17:42:51 <patrice> clint: I've seen them, but they all seem to be code -> html, which is a pita, i'd like something where I just put tags in an html document
17:43:19 <Welkin> patrice: hamlet
17:43:29 <Clint> patrice: http://hackage.haskell.org/package/ginger-0.2.5.0/docs/Text-Ginger.html ?
17:43:50 <Welkin> skip those
17:43:54 <Welkin> hamlet is the best one
17:44:01 <patrice> hamlet is not well formed html
17:44:15 <Welkin> why is that?
17:44:22 <patrice> yes, ginger looks good
17:44:36 <Welkin> oh, because it omits the closing tags in the source?
17:44:43 <patrice> welkin: yes
17:44:46 <Welkin> html itself is not "well-formed"
17:45:23 <patrice> welkin: for sure, but that we can't do nothing about lol
17:46:14 <patrice> clint: ginger is what I needed, thanks
17:47:11 * Clint nods.
18:09:42 <zennist> If I have a data type like:  data A a b c = A !(a -> b -> c), does the bang pattern there actually makes that a 'strict' function? i.e., all the arguments are evaluated to WHNF
18:10:30 <shachaf> No. It just makes A strict in its argument.
18:10:34 <shachaf> (And that's not a bang pattern.)
18:10:39 <ggVGc> this is really interesting to me, http://tom.lokhorst.eu/2009/09/deeply-embedded-dsls
18:10:51 <ggVGc> does anyone know of a more recent writeup that's similar?
18:10:55 <jle`> zennist: it means that the function is evaluated
18:11:11 <jle`> when the 'A' constructor is resolve
18:11:19 <jle`> @let data A a b c = A !(a -> b -> c)
18:11:20 <lambdabot>  .L.hs:167:16:
18:11:20 <lambdabot>      Multiple declarations of ‘A’
18:11:20 <lambdabot>      Declared at: .L.hs:160:18
18:11:22 <jle`> aw
18:11:30 <jle`> @let data AA a b c = AA !(a -> b -> c)
18:11:32 <lambdabot>  Defined.
18:11:46 <jle`> > let x = A undefined in case x of A _ -> "hello!"
18:11:48 <lambdabot>  "hello!"
18:11:53 <jle`> oh wait
18:12:11 <geekosaur> you had to rename...
18:12:11 <jle`> nvm >_>
18:12:19 <jle`> ah
18:12:27 <jle`> > let x = AA undefined in case x of AA _ -> "hello!"
18:12:28 <lambdabot>  "*Exception: Prelude.undefined
18:12:32 <pavonia> :t A
18:12:33 <lambdabot> String -> Dangerous
18:12:39 <erisco> lol
18:12:43 <geekosaur> heh
18:12:49 <zennist> I see - that's what I was afraid to hear
18:13:42 <zennist> so I guess I'd have to manually make sure the function is made strict beforing passing into the constructor then
18:13:53 <zennist> or use Strict pragma (but that changes too much)
18:14:13 <jle`> you can wrap the function, i suppose
18:14:26 <zennist> yeah - that's one solution
18:14:33 <jle`> @let mkStrict f = \x y -> x `seq` y `seq` f x y
18:14:34 <lambdabot>  Defined.
18:14:48 <jle`> > mkStrict (\_ _ -> "hey!") 1 undefined
18:14:49 <lambdabot>  "*Exception: Prelude.undefined
18:14:53 <nocturne777> for user input driven apps, is it a good idea to have types like EmailU and EmailV, where "U" stands for unvalidated and "V" stands for validated. This can be handled with GADTs as well. I wonder if this kind of approach would be excessive
18:15:09 <jle`> nocturne777: you don't reall need GADTs for that
18:15:18 <jle`> you can just have it as a phantom type
18:15:24 <jle`> data ValidStatus = U | B
18:15:26 <jle`> er, U | V
18:15:37 <jle`> and Email :: ValidStatus -> *
18:15:41 <nocturne777> I know, it can be solved with phantom types too
18:16:18 <jle`> not sure what GADT's would add?
18:16:34 <jle`> unless the type of the thing inside changes the ValidStatus state
18:16:55 <jle`> working with phantom types like these in a nice way is the purpose of the 'refined' library
18:17:02 <jle`> @hackage refined
18:17:02 <lambdabot> http://hackage.haskell.org/package/refined
18:18:07 <nocturne777> jle`: phantom types need a smart constructor, tho. 
18:18:51 <jle`> smart constructors aren't really a weird thing tho
18:19:01 <jle`> and the 'refined' library gives you smart constructors out of the box :)
18:20:21 <categoryTheoreti> I'm ghc is giving me an error on a module name, however, the module is in the correct place and matches the path and filename, is there anyplace else that may need to be notified about the file / module that could be causing this?
18:20:46 <categoryTheoreti> It complains that file name does not match module name
18:21:26 <shachaf> I bet you can think of a more useful way to ask that question.
18:21:36 <pavonia> And are you loading the module from the right path?
18:22:54 <categoryTheoreti> It should be loaded from the correct path, the path and naming convention matches the other modules in the same directory.
18:23:43 <geekosaur> last time someone had this, they miscapitalized on a case insensitive filesystem
18:24:05 <geekosaur> then copied to linux or something
18:24:10 <categoryTheoreti> ahhh, there's an idea, it complains about capitalization but when I change, it want's it capitalized
18:24:27 <geekosaur> it should be capitalized, yes
18:24:56 <geekosaur> it was an interior capital in this case
18:25:00 <geekosaur> (camelcase)
18:25:33 <categoryTheoreti> Well, the first error is MoDule.Name "expected Module.Name", but then when I change to Module.Name it "expected MoDule.Name"
18:26:04 <categoryTheoreti> all of the other modules are MoDule.Name and they don't have a problem.
18:26:22 <shachaf> I guess I was wrong.
18:26:43 <shachaf> If you want to help people help you, you should give the full actual module name and file name, at the very least.
18:29:33 <categoryTheoreti> Ok, I didn't realize the question was obscure.  The path is /src/SubHask/Algebra/Accelerate.hs.  The module in that file is SubHask.Algebra.Accelerate.  The error wants me to name the module Subhask.Algebra.Accelerate, but if I do that, then the error wants me to name the module SubHask.Algebra.Accelerate.
18:29:56 <shachaf> I bet the error was more precise than that.
18:30:13 <shachaf> You should include the actual code and the actual error (for both cases).
18:31:30 <geekosaur> check module name in the module itself, and in the import statement
18:33:35 <categoryTheoreti> I've made a gist here: https://gist.github.com/anonymous/1e406cee938deeb8c1b403c7c9998168
18:34:40 <shachaf> That's a good start, though it still doesn't include the complete error message.
18:34:54 <shachaf> And it doesn't include the full file name and path, or the import statement.
18:35:16 <categoryTheoreti> That is the complete error message, I'm using the Atom IDE, so if there's more, it's been truncated.  But in the past, I've received the full error message.
18:36:00 <shachaf> The error message doesn't include a file name?
18:36:45 <shachaf> OK, I'll put it differently.
18:36:58 <shachaf> You should give enough information to allow someone else to reproduce the problem on their computer from scratch.
18:38:01 <categoryTheoreti> It isn't a selectable field.  I can't give enough information to reproduce without forking and obtaining a list of my local commits.  I thought this might be a newbie haskell module-import problem, so I asked the question.
18:40:41 <shapr> glguy: thanks, that's a much simpler version
18:43:46 <shapr> jmcarthur: haven't looked at discrimination before, now reading
18:58:02 <ggVGc> if I have this, how would I go about adding the notion of a lambda? https://gist.github.com/076ac5b6fa0b46f90e222f8c4aff9638
19:02:03 <ertes> ggVGc: there are about a million ways to do it
19:02:26 <ertes> ggVGc: but they all involve that you introduce a constructor for variables
19:02:52 <ertes> here is a simple variant:  Lam :: Text -> ArithExpr -> ArithExpr;  Var :: Text -> ArithExpr
19:03:16 <ggVGc> I did this for now, Lam      :: String -> [String] -> Expr a -> Expr a
19:03:39 <ggVGc> which I guess is similar
19:03:50 <benzrf> ggVGc: what's the [String]?
19:03:55 <ggVGc> argumet names
19:04:09 <benzrf> also ive probably said this before but u should definitely be ggcG :)
19:04:11 <ggVGc> which is wrong
19:04:13 <ggVGc> but yeah..
19:04:20 <ggVGc> benzrf: http://ggvgc.com
19:04:40 <benzrf> bwahaha
19:04:40 <ertes> ggVGc: you can cascade lambdas
19:04:45 <ertes> \x -> \y -> …
19:05:08 <ertes> also you'd probably want an application constructor:  App :: Expr -> Expr -> Expr
19:05:41 <benzrf> ggVGc: use de bruijn indices, not string variables
19:05:45 <benzrf> they're MUCH easier to implement
19:05:50 <ggVGc> okay
19:05:55 <ggVGc> will have to read up on that
19:05:56 <benzrf> well - string variables are easier to implement incorrectly
19:05:57 <ertes> raw de bruijn indices aren't easier to implement
19:06:06 <benzrf> de bruijn indices are easier to implement correctly
19:06:24 <benzrf> ertes: "raw"?
19:06:38 <ertes> benzrf: substitution is a problem with them as well…  the only advantage is that you don't need a name source
19:06:44 <ertes> (when doing automatic things)
19:07:05 <benzrf> ertes: well, with names you have to reason about whether things are free & so on
19:08:02 <ertes> benzrf: you have to do that with indices, too
19:08:18 <ertes> here is a simple expression with a free variable:  0
19:08:30 <ertes> here is another one:  \ 1
19:08:45 <ggVGc> what I don't get, is how I will get type safety for my DSL function applications
19:08:54 <ggVGc> this is the thing I've been struggling with mentally for the past days
19:09:04 <ertes> ggVGc: i'd say, types are a matter for another day
19:09:06 <ggVGc> this implementing is just a small test to see how it can be solved
19:09:39 <ggVGc> ertes: well, the whole point of me making this DSL is to have type safe functions working on hashes(records)
19:09:48 <ggVGc> and I'd like to use haskells type system as much as possible
19:09:54 <ertes> ggVGc: a very simple way is to annotate lambdas and primitives (if you have any) with explicit types
19:10:08 <ertes> you need a separate type language for that (unless you want to do dependent types)
19:10:25 <ggVGc> hm, okay
19:10:30 <ertes> Lam :: Name -> Type -> Expr -> Expr
19:10:37 <ggVGc> so I'm gonna have to implement my tye checking manually either way
19:10:42 <ertes> yes
19:11:06 <benzrf> ggVGc: not necessarily
19:11:30 <ggVGc> I think vinyl might give me a lot of what I want?
19:11:32 <benzrf> ggVGc: you can use haskell's type system to make only well-typed ASTs be well-typed haskell terms
19:12:01 <ggVGc> benzrf: yeah, that's what I don't understand how to do
19:12:08 <ggVGc> I've been thinking about phantom types for it
19:12:12 <ggVGc> but tat's maybe completely off
19:12:19 <ertes> i think that's going *way* beyond what ggVGc should do in their first language =)
19:12:40 <ertes> it involves doing some fancy stuff in haskell
19:12:45 <ggVGc> it's not really my first language. But it's the first time in haskell, and the first time I attempt something typed
19:13:13 <benzrf> youd probably need GADTs :)
19:13:17 <ggVGc> right
19:13:20 <benzrf> if you dont know what that is, don't bother
19:13:25 <ertes> i recommend doing the simplest thing possible and also suffer from its shortcomings (yes, named variables are bad, as benzrf says, and yes, there are much better ways to do it)
19:13:37 <ggVGc> that's what I've been my understanding, but I don't feel I grasp GADTs yet
19:13:52 <benzrf> ertes: what i meant about free variables is -
19:14:09 <benzrf> ertes: if you substitute under a lambda, in de bruijn indices you just increment everything
19:14:18 <ggVGc> benzrf: the code I just posted actually uses GADTs but in a very simple way
19:14:19 <benzrf> with names, you have to manually check whether the bound name is free
19:14:42 <ertes> ggVGc: you're really only using GADT syntax
19:14:46 <ggVGc> right
19:14:50 <ggVGc> I know that
19:15:27 <benzrf> ggVGc: ah, well - you do something like this:
19:15:37 <ertes> ggVGc: unless you want your expressions to be annotated with a *haskell* type, there is really no need to use proper *G* ADTs
19:16:01 <benzrf> data Arr a b; data Term t where App :: Term (Arr a b) -> Term a -> Term b
19:16:14 <benzrf> (yes, datakinds is better - but ggVGc probably isnt familiar)
19:17:40 <ggVGc> what is Arr in this case?
19:18:39 <benzrf> ggVGc: arrow
19:19:12 <ggVGc> why are there no concrete examples of thigns like this anywhere?
19:19:15 <ggVGc> I've been looking for days
19:19:18 <ertes> benzrf: you are assuming that all terms are well-typed, which is a problem, if expressions come from the user
19:19:18 <benzrf> :\
19:19:38 <benzrf> ertes: yeah - i'm not trying to account for haskell-external users here
19:20:12 <ggVGc> this language will never be constructed from input other than haskell expressions
19:20:19 <ggVGc> there is no parser and will neve rbe one
19:20:46 <ggVGc> is that waht you were referring to?
19:20:59 <ertes> ggVGc: this means no dynamic construction whatsoever, except perhaps for literals with statically known types
19:21:38 <ertes> you couldn't even use a command line flag to decide what the type of any subexpression will be, unless you use some haskell extensions (like RankNTypes)
19:21:39 <ggVGc> hm, okay, yeah, that's not the case
19:23:00 <ertes> if that fits your use case, you can just reuse haskell's type system…  express a simple type language using DataKinds and annotate your expression type with it
19:23:49 <ertes> data Type = Func Type Type | IntType  -- a type language that can represent functions and integers
19:24:29 <ertes> in fact you can even just reuse haskell types
19:24:53 <ertes> Lam :: Name -> Expr b -> Expr (a -> b)
19:25:09 <ertes> App :: Expr (a -> b) -> Expr a -> Expr b
19:26:51 <ertes> variables are a bit more tricky…  you need a hack to make them well-typed with this approach…  otherwise you will need to carry around type contexts as well
19:27:04 <benzrf> what hack is there besides contexts?
19:27:24 <ertes> something like:  Var :: (Typeable a) => Name -> Expr (Maybe a)
19:27:35 <benzrf> eeeeeeeeeeeeek
19:27:46 <ertes> yeah, it's horrible =)
19:27:58 <ertes> but contexts are horrible, too, without dependent types
19:28:51 <benzrf> pish posh
19:28:56 <benzrf> just use nested lambdas :]
19:28:58 <benzrf> er
19:29:00 <benzrf> tuples
19:29:07 <benzrf> or even make a datakind
19:29:23 <benzrf> if you use de bruijn indices then indexing works gr8
19:30:03 <ggVGc> benzrf: you keep saying this, but my issue isn't that I don't believe these things. It's that it's incredibly difficult to find good information on this stuff
19:30:22 <ertes> only with the locally nameless approach, and it still has quite a learning curve (simply because locally nameless has)
19:30:24 <benzrf> ggVGc: er, that was aimed more at ertes :)
19:30:24 <ertes> do you see why i don't recommend doing this to ggVGc?
19:30:34 <benzrf> "locally nameless"?
19:30:38 <benzrf> not sure what that means
19:31:25 <ertes> Lam :: Expr (Maybe a) -> Maybe a  -- locally nameless…  bound variables are indexed by the level of Just nesting, while free variables have names of type 'a'
19:31:29 <ggVGc> ertes: how do I generate code from this? App :: Expr (a -> b) -> Expr a -> Expr b
19:32:10 <ertes> ggVGc: my recommendation is *not* to do that
19:32:24 <benzrf> ertes: uhh... i was thinking more like, introduce another argument to the type constructor
19:32:34 <ggVGc> but that's the point of the language. My goal is to implement a typed subset of essentially Lua, and generate lua from it
19:33:49 <ertes> benzrf: locally nameless is actually the best approach i know to deal with names…  no renumbering, no spare names, and it's user-friendly (use names for construction, but indices for computation)
19:34:21 * hackagebot th-data-compat 0.0.1.0 - Compatibility for data definition template of TH  https://hackage.haskell.org/package/th-data-compat-0.0.1.0 (KeiHibino)
19:34:23 * hackagebot chorale 0.1.4 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.4 (FranzBenjaminMocnik)
19:34:33 <benzrf> ertes: well, i've never seen it before myself
19:34:35 <benzrf> i wouldnt know
19:35:06 <ertes> ggVGc: if you want to embed the type information right into the AST, and if your type system is compatible with haskell's, then you will need to introduce a type-level context…  have you ever done type-level arithmetic?
19:35:19 <ggVGc> no, this is why I'm struggling
19:35:19 <ertes> benzrf: search for "i'm not a number, i'm a free variable"
19:35:52 <ertes> ggVGc: learn these things separately, because they both have learning curves
19:36:28 <ggVGc> ertes: here's the capabilities I want: User defined records, functions acting in a type safe way on these records, ability to bind record instances and functions to names, and generating lua from this AST representation
19:36:39 <ggVGc> my type system as I imagine it should be structurally types
19:36:40 <ggVGc> typed*
19:36:41 <benzrf> ertes: haaaaaaa
19:36:48 <ggVGc> i.e any record with the same names in it is the same type
19:37:23 <ertes> ggVGc: yeah, vinyl may actually help you with that
19:37:28 <ggVGc> yep
19:37:30 <ggVGc> that's what I figured
19:38:03 <ggVGc> ertes: but it seems to me that my best approach for now is to make my AST dynamic(not type safe), and then handle type checking manually when generating code
19:38:06 <ggVGc> does that seem reasonable?
19:38:12 <ertes> ggVGc: but please understand that you're climbing a steep mountain there…  nothing wrong with it, but expect to spend a few days learning and experimenting
19:38:18 <ggVGc> and use vinyl for the reord definitions
19:38:24 <ggVGc> oh definitely
19:38:25 <ertes> if not weeks
19:39:16 <ertes> manual type-checking is definitely easier to *understand*…  not easier to implement (it's difficult), but easier to understand
19:39:37 <ggVGc> for me right now it seems like the only path I can begin taking
19:39:40 <ggVGc> I don't have any other tools
19:39:59 <ertes> do an untyped AST first…  it's easy enought to add types later, as soon as you have a working code generator
19:40:05 <ggVGc> right
19:40:09 <ggVGc> that's what I was doing right now
19:40:12 <ggVGc> when I asked about the lambda
19:40:14 <ertes> and it'll be a lot more fun, too, because you can observe your results
19:40:50 <ertes> i'd recommend to following steps:
19:41:00 <ertes> 1. use simple named variables as explained earlier
19:41:12 <ertes> 2. switch to de bruijn indices
19:41:17 <ertes> observe the weaknesses of both
19:41:39 <ertes> 3. learn about the "locally nameless" approach (search for "i'm not a number, i'm a free variable")
19:41:41 <ggVGc> simple named variables like I was doing it? With a Lam :: String -> [String] -> Expr a -> Expr a?
19:42:18 <benzrf> whats the first string, ggVGc
19:42:24 <ggVGc> the name of the function
19:42:30 <ggVGc> but I should make that a variable binding
19:42:47 <ertes> 4. add a manually checked type system using a simple custom type language:  data Type = Func Type Type | IntType;  Lam :: Name -> Type -> Expr -> Expr  -- give each bound variable a type signature
19:43:05 <ertes> lambdas don't have names
19:43:09 <ggVGc> yeah
19:43:12 <ggVGc> I was being dumb
19:43:53 <ertes> 5. learn about singleton types, type-level computation and propositional equality
19:43:58 <ertes> 6. reuse haskell's type system
19:44:30 <ertes> by the time you reach number 6, you're going to be a master of haskell =)
19:44:40 <ggVGc> thanks :)
19:44:48 <ggVGc> and all I wanted was a type Lua :(
19:44:54 <ggVGc> I guess being a haskell master is also useful
19:45:03 <benzrf>  
19:45:16 <benzrf> ertes: im pretty sure propositional equality isnt a thing people care about in haskell
19:45:31 <benzrf> except for maybe edwardk, in his more out-there libs
19:46:44 <ertes> benzrf: type-checking is basically prop. eq.
19:46:54 <benzrf> no, that's the opposite of true
19:47:08 <benzrf> type-checking uses definitional equality
19:47:13 <shachaf> Lots of Haskell people care about propositional equality?
19:47:25 <benzrf> shachaf: i mean in the context of writing haskell programs
19:47:31 <shachaf> Yes, in that context.
19:47:45 <ertes> benzrf: i do that quite a bit…  and i only expect to do it more since GHC 8
19:47:55 <benzrf> er, my bad -
19:48:25 <ggVGc> so, would I have one AST constructor for binding a an expression to a name, and another for referring to a bound name?
19:48:47 <benzrf> i dont mean that propositional equality doesn't matter in writing haskell programs - i mean that knowing about propositional equality vs definition equality, and the finer details thereof, is not useful, as opposed to simply using algebraic reasoning which, in particular, shows propositional equality
19:49:09 <benzrf> ggVGc: that sounds about right to me
19:49:33 <ertes> benzrf: you need to understand type equality in order to reuse haskell's type system for an AST
19:49:48 <ertes> especially if you introduce dynamic terms
19:49:53 <benzrf> ertes: that's definitional equality
19:50:05 <benzrf> but it doesn't make a huge difference in haskell, unless you're using -XKitchenSink
19:50:09 <benzrf> and even then
19:50:16 <ertes> excuse my ignorance, but what is definition equality?
19:50:24 <ertes> +al
19:50:37 <benzrf> wait - if you don't know what definitional equality is, then why are you bothering say "propositional" in front of equality?
19:50:47 <benzrf> what do you understand "propositional equality" to mean beyond just "equality"?
19:51:01 <ertes> ggVGc: you also need a constructor for application
19:51:38 <ertes> benzrf: equal or unifiable normal forms + equivalence axioms
19:51:51 <benzrf> but what do you understand "propositional equality" to mean beyond just "equality"?
19:52:05 <shachaf> Arguments about words aren't even useful.
19:52:07 <benzrf> oh, wait - i see
19:52:19 <benzrf> ertes: fyi - that's literally "definitional equality"
19:52:41 <ertes> benzrf: seems like they are the same thing then
19:52:47 <benzrf> they aren't - you were using the wrong term.
19:52:58 <benzrf> definitional equality is the equality relation that lives at the level of judgements in a type theory
19:53:17 <ertes> benzrf: no, i'm actually referring to the explicit prop. eq. type
19:53:32 <benzrf> no you aren't - you just said "equal or unifiable normal forms + equivalence axioms"
19:54:13 <ertes> you are going to need it to express that context variables are of the proper type, unless there is a way to do it using unification that i'm overlooking
19:54:27 <ertes> benzrf: yes, the type that captures that
19:54:32 <ertes> not the concept itself
19:54:42 <benzrf> no it doesn't
19:54:50 <ertes> alright then
19:55:00 <shachaf> benzrf: Please don't assume that the people you're talking to are completely incompetent.
19:55:04 <shachaf> If you do, what's the point of talking?
19:55:04 <benzrf> if there are hypotheses of propositional equality in the context, you can build a proof of the equality of two non-definitionally-equal terms
19:56:14 <ggVGc> ertes: hm, I'm doing something wrong. THis doesn't seem to add up, https://gist.github.com/5838e08c9196d4f69d0361db65dfce71
19:56:21 <benzrf> for example - if i have a : nat, b : nat, a = b in my context, i can give S a = S b, even though S a and S b are not definitionally equal
19:56:23 <ggVGc> what am I doing incorrectly?
19:56:43 <ertes> ggVGc: what's the type variable for?
19:57:04 <ertes> your constructors are fine, but i don't see the purpose of the new type argument
19:57:29 <ggVGc> ertes: because I started out using that blog post, which uses a Num instance to get haskell syntax for addition etc.
19:57:56 <ertes> ggVGc: oh, and don't call it "Bind"…  there are many types of binders, and a lambda is just one of them
19:58:07 <ggVGc> what should I name it?
19:58:13 <ertes> you don't need the type variable for it
19:58:21 <ertes> i'd name it Lam
19:58:30 <ertes> it's a pretty standard name
19:58:52 <linoge> Is there a way to tell if some incredibly big number x is whole?
19:59:14 <ertes> linoge: what's the type of x?
19:59:45 <linoge> What would be the best type for it?
19:59:51 <Cale> Rational?
20:00:00 <arkeet> where is this x coming from
20:00:02 <Cale> Given that you want to be able to ask the question
20:00:12 <ertes> linoge: depends…  if it's Integer, then this function will tell you whether it's whole:  const True
20:00:26 <Cale> Integer if you want to make sure it has no fractional part statically
20:00:33 <linoge> (-1 + (sqrt $ fromIntegral $ (n * 8 + 1)  ) ) / 2
20:00:45 <Cale> Oh, square root
20:00:50 <arkeet> :t (-1 + (sqrt $ fromIntegral $ (n * 8 + 1)  ) ) / 2
20:00:52 <lambdabot> Floating r => r
20:00:55 <benzrf> ertes: in any case - i don't usually see people defining equality types in haskell - was there another reason you suggested learning about them?
20:01:02 <Cale> So really what you want to know is whether 8*n + 1 is a perfect square
20:01:03 <ertes> linoge: that's likely Double…  you can use the RealFrac class to check it in general
20:01:16 <arkeet> :t (-1 + (sqrt $ fromIntegral $ (?n * 8 + 1)  ) ) / 2
20:01:18 <lambdabot> (Floating r1, Integral r, ?n::r) => r1
20:01:33 <Cale> (well, a little more than that)
20:01:48 <Cale> Look in arithmoi for a function which will give you the integer square root
20:01:51 <linoge> But there is indeed a way to tell if it returns 4.0 or 4.2
20:01:54 <shachaf> linoge: Are you calculating the inverse of n*(n+1)/2 ?
20:01:57 <ertes> > properFraction (20.5 :: Double)
20:01:59 <lambdabot>  (20,0.5)
20:02:02 <linoge> shachaf: yes x)
20:02:10 <aupiff> I'm using stack for a ghcjs project. stack says it can't find the ghc executable while building happy and thus the build fails. I think the issue is that happy has a Setup.lhs that calls ghc via a `createProcess`. I've aliased ghc="stack ghc", but this hasn't done the trick. any ideas?
20:02:25 <jmcarthur> shapr: Make sure to read at least one of the papers linked. It's really cool stuff.
20:02:25 <benzrf> aupiff: alias is a shell thing
20:02:35 <shachaf> linoge: There might be a better way to that than going through Double. :-)
20:02:37 <aupiff> doesn't it set an env var?
20:02:43 <jmcarthur> shapr: In fact, I think that's the only way to understand it, as Ed's documentation in that library is pretty bad.
20:02:43 <benzrf> nope!
20:02:46 <ertes> linoge: note that floating point types (as instance that support 'sqrt' tend to be) have rounding errors that may make it difficult to construct a reasonable test
20:03:00 <benzrf> aupiff: if you wanna get really hacky, you could manually add a "ghc" script to your PATH
20:03:11 <ggVGc> ertes: so, currently I have this, does it seem reasonable in usage? https://gist.github.com/1b6786da68720837c28f9c32ca74de34
20:03:12 <aupiff> benzrf: that sounds like a great idea
20:03:17 <benzrf> :]
20:03:18 <linoge> Ok, ertes, shachaf, could you point me to some literature on the matter x)?
20:03:20 <ggVGc> ertes: I don't understand. I have both Lam abd Bind
20:03:29 <ggVGc> Lam is the lambda, and Bind binds it to a name
20:04:02 <shachaf> linoge: No, I don't know much about it. I just suspect Double won't be doing you many favors here.
20:04:08 <aupiff> benzrf: ghc withing a stack project already calls ghcjs so now I'm really confused.
20:04:10 <shachaf> You might prefer integer square root.
20:04:33 <ertes> benzrf: you can use prop. eq. to express that types of context variables need to be equal to the type of a bound variable…  there may be a way to use unification, but i've done it with prop. eq. a few years ago
20:04:37 <aupiff> before I'm pretty certain you had to use `stack ghc`, but I'm using a newer version of stack
20:04:40 <ertes> ggVGc: why do you have Bind?
20:04:50 <ertes> ggVGc: for lambdas you only need App, Lam and Var
20:05:09 <ertes> ggVGc: that gives you the full lambda calculus
20:05:18 <ggVGc> because I need to be able to define top level functions
20:05:22 <ggVGc> ad refer to them by name
20:05:39 <benzrf> ertes: how are context variables different from bound variables?
20:06:02 <ertes> ggVGc: i'd question that you *need* that, but if you feel that you do: a rather standard name for that is Let
20:06:07 <nilof> I want to write a function that can return something that is either of type a or of type [a], is "Either" the way to go?
20:06:16 <glguy> Yup
20:06:20 <ertes> ggVGc: Let :: Name -> Expr -> Expr -> Expr
20:07:08 <ertes> ggVGc: if you're going for minimalism, note that Lam can express it
20:07:26 <ertes> (let x = y in z) = ((\x -> z) y)
20:07:39 <benzrf> ertes: depending on the type system, there might be some restrictions
20:08:02 <benzrf> i think haskell '10 can do some things with let-exprs that lambdas can't
20:08:12 <ggVGc> ertes: why do you question I need name binding? All major languages I've used have it
20:08:14 <ertes> benzrf: lambdas introduce context, variables refer to them…  you need to unify the types
20:08:20 <ggVGc> and I'm generating lua
20:08:29 <benzrf> ertes: oh, "bound variable" as in an occurence, kk
20:08:45 <nilof> I'm getting errors of the kind     "Couldn't match expected type ‘Either (Integer, a1) a1’ with actual type ‘(Integer, a1)’" from the compiler
20:08:58 <ggVGc> but yeah, maybe things will be simpler if I just stick to lambdas
20:09:22 <ertes> ggVGc: you don't *need* it, strictly speaking…  one reason to have it is to give foreign code (i.e. lua code that isn't part of the AST) a way to call functions defined using your AST
20:09:34 <ggVGc> right, which is somethign I need to do
20:09:46 <ertes> ggVGc: if you want to do that, Let is useful…  however, you may want to introduce that at another level
20:09:56 <ggVGc> at which level?
20:10:19 <ertes> ggVGc: newtype Module = Module { fromModule :: HashMap Name Expr }
20:11:20 <ggVGc> ah, right
20:11:21 <ggVGc> cool
20:11:26 <ggVGc> yeah I changed it to Let now
20:11:35 <ggVGc> makes implemenattion a lot simpler I guess
20:11:48 <ggVGc> so now I have this, https://gist.github.com/18d12fbfa62e4ba41078a83e12e60bc4
20:11:53 <nilof> Is there anything I need to do in particular to construct an Either a b type from an a or b type?
20:13:16 <ertes> ggVGc: one thing i like to do is to make it an instance of IsString and use OverloadedStrings to refer to variables
20:13:26 <ertes> and since you have a Num language, you can also use integer literals
20:13:49 <ggVGc> yep, I know. But I'm trying to not think of the actual usage syntax right now
20:13:52 <ggVGc> so I'm just using the AST
20:13:59 <ggVGc> because I need to understand what I'm doing
20:14:17 <ggVGc> bascially, if I now add record creation and access, I think I have the basis of what I want
20:14:17 <ertes> nilof: just use the Left and Right constructors
20:15:27 <ertes> ggVGc: are you going to have named record types later?  or rather a full record type system?
20:16:04 <ertes> (interestingly the latter is easier to implement right now, while the former will be the easier one later when you add a type system)
20:16:07 <ggVGc> ertes: I think for my use cases(and for simpler implementation) I just want essentially static duck typing. So no names for record types, but checking that values exist upo access
20:16:14 <ggVGc> I'm not sure what that means for implementation yet
20:16:15 <nilof> When I try to use Left or Right, I get " Couldn't match expected type ‘a2’ with actual type ‘a1’  "
20:16:18 <benzrf> nilof: fyi - you're constructing a *value*, not a *type*. that's significant in haskell, because "type constructors" are a thing as well as data constructors
20:16:27 <ertes> ggVGc: there is no such thing as "static duck typing" =)
20:16:28 <Narfinger> hiho, i have a segfault in one of my haskell programs which i execute with stack, what is the best way to debug it?
20:16:37 <ggVGc> ertes: well, I mean structural typing
20:16:50 <benzrf> Narfinger: good lord
20:16:57 <ggVGc> ertes: I don't care about the identities of record types, other than that they should have the correct properties
20:17:17 <ggVGc> that seems easier to implement to me
20:17:18 <ggVGc> is that wrong?
20:17:22 <Narfinger> benzrf: ?
20:17:41 <ertes> ggVGc: in that case all you need is primitive operations to access records
20:17:55 <ggVGc> yeah#
20:17:55 <benzrf> Narfinger: just the thought of segfaults in haskell
20:17:58 <benzrf> D:
20:17:58 <jmcarthur> Narfinger: Segfaults are not very Haskelly types of errors. :)
20:18:01 <ertes> ggVGc: and the empty record as a literal
20:18:10 <ggVGc> ertes: where do I do my "member" checking?
20:18:15 <ggVGc> that's the part I'm not clear on yet
20:18:18 <Narfinger> yeah that is why i wonder what is going on
20:18:59 <ertes> ggVGc: i like to introduce a separate type for primitive operations:  Prim :: Prim -> Expr;  data Prim = Insert | Lookup | Member | ...
20:19:05 <nilof> As I understand it, Haskell wants to be too general - is there any way to specify that the types a1 and a2 are equal?
20:19:10 <Narfinger> i wonder if i can get stack to execute into a ghci with all debug options
20:20:23 <ertes> nilof: haskell just tries to infer types from context, and if it concludes that types don't match, it means that you have an inconsistency in your code…  we need more context to tell you where it is
20:20:29 <ertes> nilof: like a paste of your code
20:20:54 <nilof> encoderFunction ::  (Eq a) => [a] -> (Either (Integer, a) a)          encoderFunction (x:xs)             | xs == [] = Right x ::  Either (Integer, a) a             | otherwise = Left ( (myLength xs) + 1 , x ) :: Either (Integer, a) a
20:21:18 <nilof> ah, formatting got weird
20:21:21 <nilof> line by line:
20:21:22 <nilof> encoderFunction ::  (Eq a) => [a] -> (Either (Integer, a) a) 
20:21:30 <nilof> encoderFunction (x:xs)
20:21:36 <nilof>             | xs == [] = Right x ::  Either (Integer, a) a
20:21:36 <ertes> nilof: use http://lpaste.net/, please
20:22:07 <ertes> nilof: first note that you can pattern-match as deeply as you want:  encoderFunction (x:[]) = ...
20:22:09 <nilof> http://lpaste.net/165409
20:23:54 <ggVGc> ertes: hm, I'm not sure I understand completely. What do these constuctors represent? Do I use it like, RecordOp Member etc.?
20:23:55 <nilof> encoderFunction should just map a list with n identical elements x to a tuple (n, x)
20:24:02 <nilof> unless n = 1
20:24:08 <nilof> in which case it should just map to x
20:25:48 <ertes> nilof: myLength = length?
20:25:53 <nilof> ah yes
20:26:03 <nilof> it's just a Length which returns an Integer type
20:26:22 <nilof> instead of Int
20:26:41 <ertes> where is the [] case?
20:26:58 <ertes> ah, not required because of 'group'
20:28:13 <ertes> as far as i see, encoderFunction is fine, except that 'length' returns an Int, but you're stating that the left component should be Integer
20:28:24 <ertes> does your myLength return Integer instead of Int?
20:28:39 <nilof> yes
20:28:51 <nilof> myLength :: [a] -> Integer
20:29:12 <ertes> ggVGc: Prim Lookup `App` someKey `App` someRecord
20:29:51 <ertes> ggVGc: you probably want: infixl `App` 9
20:31:20 <ertes> nilof: can't find an error, but i've rewritten it a bit
20:31:51 <benzrf> :t toInteger
20:31:52 <lambdabot> Integral a => a -> Integer
20:31:55 <lpaste> ertes annotated “encoding function” with “encoding function (annotation)” at http://lpaste.net/165409#a165413
20:31:57 <benzrf> nilof: ^
20:32:24 <ertes> nilof: reload your paste to see my annotation
20:33:53 <nilof> huh, now it compiles
20:34:30 <ertes> nilof: are you doing run-length encoding?
20:34:49 <glguy_> nilof: The problem is that in each line the type 'a' is different 
20:34:50 <nilof> yep
20:34:53 <ggVGc> ertes: why does that give me a parse error on 9?
20:35:04 <nilof> ah okay
20:35:07 <glguy_> nilof: They aren't nesting
20:35:30 <glguy_> We have an extension to make it possible to use the type variables from an outer scope in an innerscope, but otherwise they are unique
20:35:41 <nilof> So, how does Haskell know what Left or Right to use from context?
20:36:12 <glguy_> There's an implicit import of the Prelude, and Left and Right are exported from the Prelude
20:36:26 <ertes> ggVGc: my bad:  infixl 9 `App`
20:36:49 <glguy_> nilof: Its specifically the type variables that are unique to each type signature
20:36:57 <glguy_> so if we have:   id :: a -> a;   id x = x :: a
20:37:05 <ertes> nilof: the types mostly follow from context…  in fact your code doesn't require *any* type signature
20:37:26 <glguy_> the "a"s in the type signature on "id" are different from the "a" in "x :: a"
20:37:34 <ertes> nilof: but leave the top-level type signature anyway…  it's useful documentation
20:37:38 <ggVGc> ertes: so, not like this? https://gist.github.com/6d82f91d5245b2e5281100d824f06cc1
20:37:40 <nilof> ok, so I tried changing my original code
20:37:42 <benzrf> nilof: what do you mean by "what Left or Right", exactly?
20:37:50 <glguy_> nilof: That's why you were getting an error about a1 not matching a2
20:38:10 <nilof> so the key change needed was removing the ::  Either (Integer, a) a
20:38:24 <nilof> from the Right x ::  Either (Integer, a) a statement
20:38:45 <benzrf> :t Right
20:38:47 <lambdabot> b -> Either a b
20:38:47 <ertes> ggVGc: i would treat the Member primitive like any other function, unless you have technical reasons not to do that
20:38:48 <benzrf> it's polymorphic
20:39:28 <nilof> but lets say I had three types a b c
20:39:33 <nilof> and Either a b
20:39:39 <ertes> ggVGc: Prim Member `App` Var "foo" `App` Var "bar"
20:39:40 <nilof> and Either a c
20:39:44 <nilof> showed up in my code
20:39:52 <nilof> and I typed Left
20:40:14 <ertes> ggVGc: that corresponds to 'member' applied to the key bound by the variable "foo" in the record bound by the variable "bar"
20:40:15 <nilof> how would it decide between the two Either types?
20:40:52 <benzrf> nilof: if you're using the Left in a context where the result of the application *must* be "Either a b" for the overall program to be well-typed, then it will infer the type as Either a b
20:41:00 <benzrf> otherwise, it will infer it as polymorphic
20:41:06 <nilof> ok
20:41:14 <benzrf> or rather - it will infer it as polymorphic in general, and then specialize it if necessary
20:41:33 <benzrf> "Left x" is polymorphic, just like "Left" is
20:41:56 <nilof> so generally giving it typing information will make it more restrictive when compiling?
20:42:03 <ggVGc> ertes: ah, thanks! this is much better
20:42:05 <benzrf> there isn't any runtime difference, though - "Left 3" is the same value at runtime regardless of whether you are using it as "Either Int String" or "Either Int [Int]"
20:42:15 <ertes> nilof: constructors act like functions:  Left :: a -> Either a b
20:42:16 <benzrf> nilof: yeah - but that can be something you want
20:42:37 <ertes> nilof: if you apply Left to an Integer, the result is of type 'Either Integer b' for some type 'b'
20:43:04 <nilof> Yeah, I can see how you can use the restricted compiler to prevent future headaches
20:43:17 <ertes> nilof: "restricted"?
20:43:19 <nilof> if you have some future function in mind but haven't implemented it yet
20:43:37 <nilof> restricted as in you specified a type
20:43:46 <nilof> in response to benzrf
20:46:52 <nilof> but yeah, I'm solving some of the problems in https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems to build some experience
20:47:16 <nilof> these are more general purpose programming challenges though
20:47:27 <ggVGc> ertes: so, I have a technical issue now. in Lua application is done by, foo(arg), but property access can only be done by "foo.bar" and "foo.(bar)" is not valid. So if i re-used the App constructor, I get the latter result
20:47:31 <ggVGc> what is the best solution?
20:47:39 <ertes> nilof: a run-length encoder should probably have this type:  (Eq a) => [a] -> [(a, Int)]
20:47:44 <nilof> are there any public problem sets that encourage doing stuff like defining your own monads?
20:47:56 <ertes> nilof: the Either doesn't seem to serve any purpose here
20:48:05 <nilof> yes, I know
20:48:10 <nilof> I did that in the previous problem
20:48:29 <nilof> but problem 11 has that as a requirement ^^
20:48:29 <ertes> ggVGc: your compiler should handle primitives specially
20:48:53 <ggVGc> ertes: I've got this, https://gist.github.com/2cf90a7298d5c81955a697f7c45bc459
20:48:58 <ggVGc> which gives me the wrong result
20:49:02 <nilof> which is good, since I learned stuff abough Either when working on it
20:49:04 <ggVGc> what special handling can I add?
20:49:35 <ertes> ggVGc: that's not going to work in general, because you don't know what the argument to 'lookup' might be
20:49:45 <ggVGc> so what do I do?
20:49:48 <ertes> ggVGc: lookup (f x) r
20:50:08 <ertes> ggVGc: you can wrap lookups by a function in more complicated cases
20:50:16 <ertes> since i'm not familiar with lua, i can't really help you there
20:50:35 <ggVGc> I think it's a more general code genertion issue
20:50:55 <ertes> ggVGc: you need to understand how you map constructs in your language to constructs in lua
20:50:58 <ggVGc> ertes: wen you say "Should handle primitives specially", I'm not sure what the implies
20:51:24 <ertes> ggVGc: 'member' is a regular builtin function in your language, but it's actually a language construct in lua
20:51:38 <ertes> ggVGc: one way to deal with it is to compile it to a function that does the member access
20:51:50 <ggVGc> yeah, that's what I figured
20:52:28 <ertes> also make sure that lua supports some way to define anonymous functions with closures…  otherwise your project is going to be a pain
20:52:33 <ggVGc> ertes: I was thinking of adding a configuration argument to the `gen` function which decides if parentheses should be added when doing application. is that stupid?
20:53:00 <ertes> ggVGc: i think it would be best if you wrote a second AST type that models lua
20:53:03 <ggVGc> oh, lua has very good language semantics as a target platform. It has great lexical scoping and tail recursion
20:53:16 <ertes> it's really difficult and error-prone to compile to a string right away
20:53:22 <ggVGc> right, that's fair
20:53:23 <ggVGc> thanks
20:53:52 <imh> Hey all, if I have a GADT "data Foo where Foo :: Expr a -> Foo" there's no way to get the "Expr a" back out, with anything like "unFoo (Foo x) = x" right? The a in Expr a is a phantom type to keep me from shooting myself in the foot, so I can discard it but I'd rather not.
20:53:58 <ertes> it doesn't have to be fancy…  model the constructs that you need and write a renderer for it that spits out correct lua code
20:54:07 <ggVGc> actually... https://hackage.haskell.org/package/language-lua
20:54:14 <coppro> imh: Foo is a constructor, so you can pattern match on it
20:54:41 <coppro> imh: in that case, the declaration is exactly the same as data Foo = Foo (Expr a)
20:55:02 <imh> i thought i could, but then maybe I'm doing something wrong becuse I get a type mismatch error
20:55:15 <imh> Couldn't match expected type ‘a’ with actual type ‘a1’
20:55:18 <glguy> imh: You can't get the 'a' back, this is Existential Quantification
20:55:23 <glguy> (rather than a phantom type)
20:55:35 <glguy> If you want you can remember stuff about the a in the form of type class constraints it satisfies
20:55:43 <coppro> yeah, the problem here is that you don't have any information about a
20:55:58 <ggVGc> ertes: what would be the conceptual difference of lookup and member in your definition?
20:56:01 <ggVGc> to me it seems the same
20:56:04 <coppro> you'd need to parameterize Foo (the type) on a if you wanted to keep that information around
20:56:28 <ertes> ggVGc: by haskell conventions 'member' is just a membership test, while 'lookup' actually returns the value
20:56:45 <ertes> ggVGc: but since you're going to make everything statically typed later, you probably don't need 'member' anyway
20:56:46 <ggVGc> hm, not sure it's useful for me to make that distinctio
20:56:50 <ggVGc> I'll have to think about it
20:57:18 <ertes> ggVGc: because in a static record system a lookup of a member that doesn't exist isn't well-typed
20:57:35 <ertes> and the 'member' test would always return true
20:57:36 <ggVGc> ertes: Im also not sure about "Insert" in this scenario. The way I see it my records will be created with the member they have, and that's it from that point on
20:58:06 <imh> glguy: can you expand on what you meant about using the constraints? I don't understand
20:58:10 <ertes> ggVGc: if you have a static record system, you can easily construct records by inserting into the empty record
20:58:41 <ggVGc> doesn't that make it a dynamic record system?
20:58:46 <ertes> ggVGc: nope
21:00:02 <ggVGc> ertes: ah, right, because when a new member is added to a record, it's now a new type
21:00:14 <ggVGc> it's not runtime addition of members
21:00:15 <ggVGc> I get it
21:00:27 <ertes> yeah
21:00:43 <ggVGc> and you reckon this is the simplest way to model records?
21:00:46 <glguy> imh: https://imgur.com/yn7sn5k
21:00:47 <ggVGc> makes sense
21:00:49 <ertes> ggVGc: the reason i'd prefer this approach is that it doesn't bloat your core language
21:00:59 <ertes> all you need is new primitives
21:01:17 <ertes> specifically the empty record, insert and lookup
21:01:44 <ertes> and potentially a fold over key/value pairs, if you need it
21:03:15 <imh> ooh, that makes tons of sense. So i can still get the data out, I just have to be careful how i use it. Thanks!
21:03:42 <ertes> imh: more like: you can get the data out, but you don't have full type information about it
21:04:01 <ertes> imh: you know that it's an Expr, but you don't know what 'a' is
21:05:24 <ertes> imh: here is an extreme example:  data T :: * where C :: a -> T
21:06:24 <ertes> using C with a value of any type you can construct a T
21:06:36 <ertes> when you pattern-match on it, you have absolutely no information about the 'a'
21:06:54 <ertes> so you get the value out, but you can't do anything with it
21:07:35 <ggVGc> ertes: hm, I'm stuck again.. Should "Insert" take an argument also?
21:07:44 <ggVGc> I'm not sure how to implement the code generation of Insert
21:07:55 <ggVGc> seems like there's information missing if I try to do it similar to Member
21:08:32 <ertes> ggVGc: my guess is that it needs three arguments
21:08:43 <ertes> a key, a value and a record
21:09:37 <ertes> and it translates to *pure* record update…  most imperative languages have impure record update as in field assignment
21:09:54 <ggVGc> ertes: does this look right? https://gist.github.com/17e2edbe083c2813b769d5213bf4b421
21:10:18 <ertes> nope
21:10:29 <ertes> data Prim = EmptyRec | Insert | Lookup
21:10:40 <ggVGc> so where do the arguments come from?
21:10:57 <ertes> Prim Insert `App` myKey `App` myValue `App` myRec
21:11:24 <ertes> unless you want to restrict the key to static strings
21:11:31 <ggVGc> yeah, but what I don't get is how to implement `gen (App Insert)`
21:11:53 <ggVGc> ehh, App (Prim Insert)
21:12:01 <ertes> again, you probably need a wrapper function
21:12:12 <ertes> just like for lookup
21:12:51 <ertes> compile it using the most straightforward way you can think of…  later you can implement an optimisation step to translate certain known patterns to more reasonable lua code
21:13:17 <ggVGc> I guess my issue is that I need to translate curried functions into non-curried ones
21:13:22 <ggVGc> well, maybe I don't actually
21:13:26 <ertes> you do
21:13:46 <ertes> and it will be a recurring theme =)
21:14:18 <ggVGc> but I can see how it's sensible
21:14:25 <ggVGc> to keep the core representation simple
21:14:31 <ertes> the easiest way is to just implement a lua counterpart of the *curried* function
21:14:43 <ggVGc> yeah
21:14:45 <ggVGc> that makes sense
21:15:07 <ertes> then all you really need to do is to translate 'insert' and 'member' to calls to those functions…  it's very straightforward
21:15:52 <ggVGc> yeah this makes sense now
21:15:58 <ggVGc> that's the thourhg error I was doing
21:16:05 <ggVGc> ertes: thanks for all the help!
21:16:06 <ggVGc> really
21:16:22 <ggVGc> I know this is pretty simple stuff, but it's still a hurdle thinking about it correctly
21:16:32 <ertes> you're welcome…  and it's not simple stuff =)
21:16:43 <ggVGc> without your help my core representation so far would have been much more coplex
21:16:50 <ggVGc> and I would've had to regress a lot
21:16:52 <ertes> as said, you're climbing a steep mountain, and it will only get steeper…  be brave ;)
21:17:05 <ggVGc> yeah but it's already making a lot more sense
21:17:14 <ggVGc> I'm starting to guess how I could start adding some basic typing
21:17:21 <ggVGc> which yesterday was ust a brick wall
21:18:20 <ertes> yeah, adding a type system isn't actually too difficult, but you will have to make it expressive enough for the record system
21:18:29 <ertes> you need membership propositions, etc.
21:18:49 <ggVGc> I have a feeling it's gonna be a rough ride
21:19:41 <ertes> now you know why most popular language designers love dynamic typing =)
21:20:04 <ggVGc> sure, it's obviously easy
21:20:14 <ggVGc> I've written several interpreted toy languages before
21:20:21 <ertes> and they implement their languages in C ;)
21:20:38 <ggVGc> which I do not understand
21:20:47 <ggVGc> ML is as old as C
21:21:35 <ertes> i don't know why…  two popular reasons seem to be speed and portability…  while the former is clearly wrong, the latter holds some truth
21:21:57 <ggVGc> I'd say portability really is the thing
21:22:05 <ggVGc> and the times I've resorted to C, it's been because of that
21:22:11 <ggVGc> because ANSI C really does run anywhere
21:22:12 <ggVGc> which is nice
21:22:17 <ertes> but then i don't really care whether my watch or my toaster can run my compiler =)
21:22:19 <ggVGc> but writing ANSI C is not very good fun
21:22:45 <ggVGc> it's a mystery to me why ML didn't get more traction
21:22:57 <ggVGc> but I wasn't around at the time
21:23:03 <ertes> one reason definitely is marketing
21:23:18 <ggVGc> and unix..
21:23:19 <ggVGc> probably
21:23:43 <ertes> ML had that academia flavour…  and i'm sure back in the day it was a very difficult language to learn
21:24:09 <ggVGc> sure
21:24:16 <ggVGc> it's not exactly easy for most people nowadays either
21:24:25 <ggVGc> first time I looked at F# it was a mouth full
21:24:44 <ertes> well, we have lots of material on very similar languages these days
21:24:56 <ertes> basically if you can understand ocaml, you can understand standard ML, too
21:24:59 <ggVGc> right, and it's still not really easy
21:25:06 <ggVGc> if you're the general programmer
21:25:46 <ertes> my own experience was:  i loved PHP when i first learned it
21:25:55 <ertes> immediate success, easy to teach, easy to learn
21:25:56 <EvanR> brigadier general joe programmer
21:26:14 <ertes> so i can see how people are drawn to these terrible languages
21:26:29 <EvanR> (offtopic: what makes PHP so easy)
21:26:41 <EvanR> if thats even true
21:26:48 <ertes> EvanR: PHP isn't easy…  it's easy *to learn*
21:26:53 <EvanR> is it?
21:27:16 <EvanR> or does it have a built in "you feel like you learned something" trick
21:27:31 <ertes> no, it is
21:27:40 <EvanR> if you see a blank white screen, you dont feel like youre misunderstanding something
21:27:43 <ertes> it's easy to learn, but hard to use
21:27:48 <ertes> haskell is the exact opposite
21:28:00 <EvanR> if you see error messages, then you feel dumb
21:28:04 <EvanR> its hard
21:28:27 <ertes> i guess, that's why PHP went out of its way never to produce an error message back then
21:28:32 <ggVGc> so, the naive way to use this little language now, is that a program is just one huge let binding right?
21:29:04 <ertes> ggVGc: depends on what your program does, and even what a program *is*
21:29:22 <ertes> is it an expression?  a function?  do you have first-class actions like in haskell?  …?
21:30:09 <ertes> i guess you're not going to implement first-class actions, because that's genuinely difficult…  more likely you're going to make your language strict by default and side-effecting
21:30:13 <ggVGc> It's meant to be an extension language, like lua is, i.e essentially each program is one function I guess, which does some logic and returns a result to the host program
21:30:33 <ertes> an expression, you mean?
21:30:37 <ggVGc> not sure about side effecting right now, but I think so yeah
21:30:41 <ggVGc> yeah, an expression
21:30:55 <ggVGc> isn't this how ML is actually? A long nested let binding?
21:31:05 <ertes> well, you can add an IO type, but that requires lazy evaluation
21:31:16 <ggVGc> yeah, that's too much for now
21:31:34 <EvanR> gotta love side effects of evaluating expressions ;)
21:31:36 <ggVGc> I basically just want something more type safe than lua, but not anywhere near as rigid and strict as haskell(because it's too much implementation work)
21:31:45 <EvanR> especially when its out of its way to look like let bindings
21:32:02 <EvanR> let x = [3, 4, launchMissiles]
21:32:11 <ertes> ggVGc: isn't there a javascript-to-lua compiler?  because there is a haskell-to-JS compiler =)
21:32:13 <ggVGc> EvanR: well, what do you do when you're a naive and inexperiences language implementator and want something useful?
21:32:21 <EvanR> hell if i know
21:33:07 <EvanR> i never learned ML. in scheme and JS you have a syntactic clue that your executing something
21:33:19 <EvanR> [3, 4, launchMissiles()]
21:33:32 <EvanR> '(3 4 (launchMissiles))
21:33:45 <EvanR> as opposed to non executing versions
21:33:46 <ertes> EvanR: that's actually just a sublist =)
21:33:54 <ggVGc> ertes: kind of, but I haven't found anything that's useful in the context I want it. But maybe I should look some more
21:33:59 <EvanR> dangit
21:34:17 <ertes> EvanR: that's why i never really liked lisps
21:34:40 <ertes> it's confusing as it is, and it only gets worse once you have macros
21:34:58 <EvanR> it definitely takes a shit on "different things should look different"
21:35:12 <ggVGc> ertes: JS and lua aren't as similar as they might seem at first glance though. For example Lua actually has real tail call optimization, so it's much more suitable as a target for a functional language
21:35:20 <ggVGc> and I'd like to try to exploit that somehow
21:35:36 <ertes> ggVGc: not that implementing a language isn't a fun exercise to waste some time with…  but if you want something that is actually useful, you should allocate 6-12 months
21:35:36 <parsnipM_> huh? isn't '(3 4 (launchMissiles)) syntax taht launchMissiles is a function that will be eval'd? 
21:35:56 <EvanR> its (quote (3 4 (launchMissiles))
21:35:58 <simpson> '(3 4 ,(zeMissiles))
21:36:12 <parsnipM_> `(3 4 ,(zeMissiles))
21:36:24 <parsnipM_> at least in elisp
21:36:43 <ggVGc> ertes: yeah, that too. I really want to get some understanding on how type systems are implemented, and at some point write some kind of type inference
21:36:47 <ggVGc> because that seems really difficult
21:37:00 <EvanR> nah... algorithm W
21:37:23 <ertes> ggVGc: not if you do it like haskell…  it's really just a cookbook you have to follow
21:37:25 <EvanR> though still not sure how to get error messages to work
21:37:37 <ertes> yeah, good error reporting is difficult
21:37:39 <ggVGc> EvanR: neither are the GHC peple
21:37:42 <ggVGc> (heuheu)
21:37:56 <ggVGc> but to be fair they only had 20 years to work on it
21:37:57 <EvanR> idris error messages are pretty cool, if only for their uniformity
21:38:15 <EvanR> cant unify expr1 with expr2, you figure out why
21:38:26 <ertes> GHC actually has extremely good error messages…  you just haven't seen what they *could have* looked like =)
21:38:33 <ggVGc> ELm has great error messages, but the language is also designed around having good ones
21:38:57 <ertes> but if you're going to implement your own type system, and you want it to be powerful (polymorphism), you will =)
21:39:23 <ggVGc> who makes errors anyway
21:39:28 <ggVGc> seems overrated with error reporting
21:39:41 <EvanR> ggVGc: which is a good point actually... you might want to look at idris. because its eager, has a type system, and is pure. so might be worth seeing how they do side effects (its an IO monad of sorts, but not like haskell)
21:40:04 <EvanR> they also have an effect library
21:40:13 <ggVGc> I think this is very far in the future if anywhere for my language
21:40:21 <ertes> yourcode:1:1: Here or later there is a type error. Please fix and recompile!
21:40:23 <ggVGc> I'm happy if I can get type safe record accessing
21:40:23 <EvanR> which might be a thing you could reify into a static feature
21:40:57 <EvanR> ggVGc: on the subject of that... the scoped labels paper is really cool
21:41:07 <ggVGc> ertes: I imagine I won't want all these advanced features in my language, because I hope to be able to use haskell as a metaprogram to do most of that
21:41:20 <EvanR> it shows some extensive records, and extensible sums, and how to assign types
21:41:30 <ggVGc> EvanR: you got a link?
21:41:43 <ertes> ggVGc: polymorphism is easy enough…  all you need is a type system construct: "for all"
21:41:48 <EvanR> http://research.microsoft.com/apps/pubs/default.aspx?id=65409
21:41:57 <ggVGc> ertes: and before that all I need is "a type system"
21:42:13 <ggVGc> thanks
21:42:18 <k0n> can you help me build a nonprofit for black supremacist groups?
21:42:32 <ertes> ggVGc: for practicality of your language, you probably want polymorphism…  if you don't know why, try writing a C program =)
21:42:54 <EvanR> yes monomorphic code is sad code
21:43:01 <ggVGc> ertes: but will I not get that through my definition of identity? I.e "any record with members x,y,z are the same type"
21:43:04 <ggVGc> ?
21:43:17 <EvanR> thats still monomorphic
21:43:33 <ertes> ggVGc: you need polymorphism to implement something like sortBy
21:43:34 <ggVGc> hm
21:43:44 <ertes> ggVGc: algorithms that work over many types
21:43:46 <EvanR> you need polymorphism to make a length function
21:43:55 <ertes> or even just a list type
21:44:05 <ertes> unless you want IntList, DoubleList, StringList
21:44:10 <ggVGc> ah yeah, I see nw
21:44:11 <ggVGc> now*
21:44:12 <ertes> ListOfIntList…
21:44:13 <ggVGc> yeah, I'll want that
21:44:16 <ggVGc> will it be a hurdle?
21:44:17 <EvanR> or MyOneDynamicTypeList
21:44:25 * hackagebot language-webidl 0.1.1.1 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.1.1 (izgzhen)
21:45:16 <ertes> ggVGc: you can add a monomorphic type system first…  adding polymorphism shouldn't destroy anything
21:45:37 <ggVGc> I think it can be pretty useful without polymorphism too though
21:45:39 <ertes> however, you will have to consider how lua handles it
21:45:42 <ggVGc> but obviously it's not optimal
21:45:56 <EvanR> you kind of cant do FP without map
21:46:09 <ggVGc> this is not necessarily a functional language
21:46:10 <ertes> because either you use C++ style instantiation (which is really really ugly), or you make sure that your generated code is actually type-agnostic
21:46:17 <ggVGc> I'm not sure what it will look like in usage yet
21:46:24 <EvanR> sounds like C ;)
21:46:40 * EvanR begins writing another 6 line traversal
21:47:04 <ertes> ggVGc: it sure looks like a functional language to me =)
21:47:10 <ggVGc> yeah
21:47:16 <ggVGc> so far
21:47:23 <ggVGc> but maybe I'll realise that's not what I want
21:47:25 <ggVGc> but I think it is
21:47:41 <ggVGc> however, maybe it'll turn out that it maps really bad to Lua when I get to the detauils
21:47:57 <EvanR> lua is turing complete, it will map
21:48:06 <ertes> i don't think you want to make lua more practical by turning it into BASIC =)
21:48:09 <ertes> or COBOL =)
21:48:35 <ggVGc> I'm trying to get the fast lua development cycle, but with some extra type help so I can refactor easier
21:48:57 <ggVGc> I always have the situation that I can prototype and build things super fast in lua, mostly without errors, but when I need to refactor anything it's a mess
21:49:08 <ertes> are you using lua (as opposed to haskell) to get a fast development cycle?
21:49:10 <ggVGc> and starts exponentially slowing down development
21:49:13 <EvanR> .oO( shens sequent calculus on top of lua )
21:49:31 <ggVGc> ertes: yes because I have a small app framework in C and Lua that I wrote for making mobile games quickly
21:50:02 <ertes> ggVGc: perhaps you should work on improving your haskell development cycle instead =)
21:50:35 <ggVGc> I don't even know where to begin getting haskell to comile and run reliable on the various android platforms and iOS
21:51:12 <ggVGc> also I have an asset pipeline that spits out lua as a description of art and scene assets
21:51:17 <ertes> you can compile to android native applications these days…  i don't know about iOS
21:51:24 <ggVGc> so I'd still need a lua interpreter running and ways to interact with it
21:51:35 <ertes> if all else fails, GHCJS can produce code that works with apache cordova (a.k.a. phonegap)
21:51:44 <ggVGc> and runs terribly
21:51:52 <ggVGc> and has huge file sizes
21:52:18 <ggVGc> also, with a haskell workflow I don't get hot reloading of code, although that might not be that big of an issue in practice
21:52:35 <ertes> it does have large outputs, which is why you run it through the closure-compiler before release
21:52:49 <ertes> it doesn't run terribly though…  GHCJS-produced code is actually very fast
21:52:57 <ggVGc> yes, but phonegap is not
21:52:58 <ertes> you do get hot reloading
21:53:14 <EvanR> i want to experiment with "hot code reloading"
21:53:18 <ggVGc> making native apps with phonegap is a terrible experience
21:53:35 <ggVGc> maybe it's changed
21:53:40 <ggVGc> it's been several years since I did it
21:53:45 <ertes> ggVGc: that might be…  i haven't used "phonegap", but i've tried cordova
21:53:51 <ertes> it's reasonably fast
21:53:56 <ertes> not super-fast, but reasonably fast
21:54:20 <ertes> EvanR: emacs and haskell-interactive-mode can hot-reload running code
21:54:41 <ertes> it's nice for developing web apps, especially since you don't have to lose state
21:55:21 <ertes> see the 'haskell-process-reload-devel-main' function
21:55:38 <EvanR> er, im thinkin of reloading only part of the code
21:55:54 <ggVGc> ertes: I made this game using my pipeline, it's not terribly complex, but it has a lot of sprites and runs at 60fps on the oldest adroid phones I could find, going back maybe 4 years, https://www.youtube.com/watch?v=XyTYXYexfGc
21:56:00 <ggVGc> I don't think I could have done that with cordova
21:56:07 <ggVGc> and the file size of everything is less than 10mb
21:56:08 <ertes> EvanR: it runs an 'update' action, and that one can reload any part of the code you specify
21:56:19 <ertes> EvanR: using the 'foreign-store' library
21:56:31 * EvanR looks into this
21:56:32 <ertes> it allows values that persist through GHCi reloads
21:56:47 <EvanR> do they have to be serializable?
21:57:08 <ertes> EvanR: nope
21:57:17 <ertes> it's based on GHC's stable pointers
21:58:24 <EvanR> so you reload everything except some lifeboat of state
21:58:29 <EvanR> rather than one bit of code
21:58:58 <ertes> you reload everything, then you replace selected pieces of running code by the newly loaded code
21:59:23 <ertes> there is (currently) no way to select which code to reload
21:59:39 <ertes> but you can select which part of the running code to replace
21:59:48 <EvanR> what does that mean
21:59:50 <ertes> e.g. which threads to restart using the new code
22:00:07 <EvanR> oh hrm
22:00:35 <ertes> it's not as smooth as in smalltalk, but it works and is a real time saver
22:00:52 <EvanR> just foreign-store looks like it could help by itself
22:00:57 <ertes> change your code, press a key, code reloaded
22:01:19 <ertes> that's especially useful, if you do web templating in haskell =)
22:01:31 <EvanR> or anything really
22:01:40 <k0n> why are you such a cuck?
22:01:42 <EvanR> with a GUI
22:02:25 <ertes> yeah, you can reload the logic without recreating the GUI
22:02:43 --- mode: ChanServ set +o Cale
22:03:47 --- mode: Cale set -o Cale
22:04:12 <lpaste> ertes pasted “Snap application reloading using foreign-store” at http://lpaste.net/165418
22:04:37 <ertes> EvanR: this is how i reload a snap application…  i do a full restart there
22:04:40 <ggVGc> ertes: Im starting to think this will be quite useful almost in the state it is right no, just as a functional variant of lua
22:04:46 <ggVGc> wit haskell macros
22:04:50 <ertes> EvanR: but you could be more selective
22:05:14 <EvanR> actually this would work for me
22:05:46 <EvanR> i can save the state and reload everything then use original state as initial state
22:06:00 <EvanR> unless the type of the state changes
22:06:08 <EvanR> so nevermind
22:06:09 <ertes> EvanR: make sure you specify the type of your Store…  this stuff is really unsafe
22:06:47 <ertes> in my first trials i had a few GHCi crashes
22:07:05 <EvanR> i was thinking instead i could drop rules and close/reopn a plugin to get them back
22:07:19 <EvanR> and keep the system otherwise running normally
22:07:49 <EvanR> still cant change the type of state
22:08:41 <ertes> you can keep the type this updater sees constant by using serialisation
22:09:54 <ertes> for example make sure your 'update' sees only JSON…  a type that doesn't change during your development cycle
22:10:32 <EvanR> ouch
22:10:50 <ertes> well, you need some way to migrate your data
22:11:26 <EvanR> you could do State1 and State2
22:11:33 <EvanR> and migrate 
22:11:52 <EvanR> safecopy
22:11:55 <ertes> you would need to change 'update' to use State2
22:12:24 <ertes> better keep it as generic as possible…  i like never to touch DevelMain
22:12:50 <EvanR> "must be representable as json" isnt... that generic
22:13:29 <ertes> i've never actually reloaded data
22:13:39 <ertes> the only thing i do is restart threads
22:13:57 <ertes> so the only store type i use in DevelMain is Store (Async ())
22:13:59 <EvanR> so far i only have 1 thread
22:14:54 <ertes> i've had one web server thread and one background worker thread in one application
22:16:22 <ertes> but i just restarted both…  hasn't ever been a bottleneck for me
22:17:22 <awang> i
22:18:43 <EvanR> i just realized that Map/IntMap is already a priority queue
22:18:56 <EvanR> if the priorities are unique
22:19:44 <ertes> EvanR: Map prio (Set a)  -- or Seq or [] or …
22:20:07 <EvanR> im using []
22:20:21 <EvanR> and updating it with a linear search
22:34:11 <ggVGc> ertes: so, currently I have name binding by Let "name" expr. Would it be reasonable to make a monad for this, so I can bind names without quoting them?
22:34:24 <ggVGc> a "let monad"?
22:34:25 <ggVGc> :/
22:44:44 <EvanR> let monad the dogs of war
22:54:01 <phanimahesh> I didn't know hot code reloading is possible in haskell!
22:54:22 * phanimahesh queues this up in his ever growing reading list
22:54:47 <EvanR> look up haskell "live coding"
22:55:09 <phanimahesh> Will do.
23:00:33 <ggVGc> hm, how do I make this work correctly? https://gist.github.com/fa2b480f6866a302e7ec109eee427dc7
23:02:17 <EvanR> you need to allow Expr to be Num
23:02:47 <EvanR> the fact that not all Expr are valid arith is a typing problem
23:03:05 <EvanR> the easiest way to deal with that is dynamic typing
23:03:24 <ggVGc> is that my best option right now?
23:03:27 <EvanR> actually theres an easier way, invent an "error" expression which is the value of anything that doesnt make sense
23:03:42 <EvanR> its also the worst way
23:03:56 <ggVGc> well, what would you do in my position right now?
23:04:09 <EvanR> im not sure what youre trying to do
23:04:23 <ggVGc> I'm trying to incrementally build a language
23:04:37 <ggVGc> how would I do the error case that you described?
23:04:40 <EvanR> well you can simplify it by only have 1 expression type
23:05:00 <ggVGc> yeah, but I'd like to preserve this little bit ot typing if possbible
23:05:03 <ggVGc> but maybe I can't
23:05:11 <EvanR> its not well formed as is
23:05:16 <ggVGc> alright
23:05:49 <EvanR> you can add typing to your expressions so that every expression has a type
23:05:57 <EvanR> then you can specify when + is possible
23:06:06 <EvanR> when it isnt, you cant even build the sentence
23:06:52 <EvanR> add a phantom parameter to Expr which is the type
23:07:11 <EvanR> IntLit :: Integer -> Expr Number
23:07:31 <EvanR> Plus :: Expr Number -> Expr Number -> Expr Number
23:09:30 <EvanR> If :: Expr Bool -> Expr a -> Expr a -> Expr a
23:16:19 <texasmynsted> could somebody direct me to a very simple example of how to get hspec working with stack.  (with the understanding that I am new to haskell, stack and hspec)
23:19:29 * hackagebot hPDB 1.2.0.6 - Protein Databank file format library  https://hackage.haskell.org/package/hPDB-1.2.0.6 (MichalGajda)
23:19:31 * hackagebot hPDB-examples 1.2.0.6 - Examples for hPDB library  https://hackage.haskell.org/package/hPDB-examples-1.2.0.6 (MichalGajda)
23:29:29 <texasmynsted> ok, working.  Thank you
23:44:30 * hackagebot hPDB-examples 1.2.0.7 - Examples for hPDB library  https://hackage.haskell.org/package/hPDB-examples-1.2.0.7 (MichalGajda)
23:44:32 * hackagebot homplexity 0.4.3.3 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.3 (MichalGajda)
23:52:38 <texasmynsted> I am in ghci and for some reason it can not understand 'newtype'
23:55:02 <glguy> If you want help with that you should be more specific, for example we don't know what you mean by can not understand
23:55:32 <glguy> Pasting an example of what you tried with the error message would be best
23:55:33 <texasmynsted> It did not seem to understand the keyword
23:55:47 <glguy> And possibly the GHC version
23:56:09 <texasmynsted> yeah.  I see the problem.  It was bad indentation...
23:56:21 * texasmynsted facepalm
