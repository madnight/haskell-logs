00:07:38 * hackagebot hPDB-examples 1.2.0.7 - Examples for hPDB library  https://hackage.haskell.org/package/hPDB-examples-1.2.0.7 (MichalGajda)
00:07:38 * hackagebot homplexity 0.4.3.3 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.3 (MichalGajda)
00:12:33 * hackagebot wordpass 1.0.0.6 - Dictionary-based password generator  https://hackage.haskell.org/package/wordpass-1.0.0.6 (MichalGajda)
00:25:08 <shanemikel> err, what's the offtopic channel again?
00:29:17 <zomg> shanemikel: #haskell-blah ?
00:29:23 <shanemikel> thanks
00:30:53 <pavonia> or #haskell-offtopic
00:42:34 * hackagebot pomodoro 0.1.0.1 - pomodoro timer  https://hackage.haskell.org/package/pomodoro-0.1.0.1 (zohl)
01:02:26 <adarqui> d
01:03:38 <adarqui> oops. im compiling with profiling now, trying to figure out why my code to ingest a bunch of data is just blowing up.. i grab it from mysql, replace <br />'s to \n's via Data.Text.ICU replaceAll.. then post it via Wreq .. i get this 2.2M response back and it just spirals out of control. i think it's the replaceAll function
01:03:43 <adarqui> https://hackage.haskell.org/package/text-regex-replace-0.1.1.1/docs/Data-Text-ICU-Replace.html
01:03:46 <adarqui> from there ^^
01:03:50 <adarqui> anyone have any idea about that?
01:04:34 <adarqui> i can't tell yet because profiling is taking forever to build. i dno, it's either replaceAll or something internal to wreq
01:07:02 <adarqui> bd
01:07:05 <adarqui> sorry
01:09:32 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
01:09:32 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
01:19:35 <hc_> hi
01:19:50 <hc_> is it possible to restrict the memory usage per haskell green thread?
01:25:01 <EvanR> yes
01:25:08 <EvanR> sort of
01:25:20 <EvanR> https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Mem.html
01:26:05 <EvanR> it says that strict WriterT can do constant space usage... so im not sure whether strict or lazy writer is better, and what the deal is generally
01:26:11 <EvanR> any advice on choice of writer
01:34:59 <mauke> IIRC the best writer is State
01:35:24 <EvanR> whats the issue with writer?
01:35:33 <EvanR> i thought it was like state 
01:35:43 <shachaf> Why is State better than Writer of Endo?
01:35:53 <mauke> I don't remember the details
01:36:18 <EvanR> i meant to say, the docs say that strict writerT still cannot* do constant space usage
01:36:21 <EvanR> and it suggests state
01:40:02 <EvanR> is it a problem with the implementation of writer or its inherently a flawed idea
01:52:24 <EvanR> for a bytestring-trie that is to be used as a set of bytestrings, should the value type be (), or is there a more efficient payload
02:02:30 <linkon1> http://espedito.homepc.it/ Regards,
03:02:03 <ggVGc> why the hell is [x..y] inclusive in the ypper bound?
03:02:40 * hackagebot hPDB 1.2.0.7 - Protein Databank file format library  https://hackage.haskell.org/package/hPDB-1.2.0.7 (MichalGajda)
03:02:46 <bennofs> ggVGc: I didn't like it at first either, but you get used to it
03:02:50 <hvr> ggVGc: why shouldn't it? the lower bound is inklusive as well
03:03:00 <hvr> -k+c
03:03:10 <bennofs> ggVGc: I guess it is simlar to the interval closed notion used in math
03:03:24 <bennofs> s/interval closed/closed interval
03:03:25 <hvr> c.f. https://en.wikipedia.org/wiki/Interval_(mathematics)
03:03:28 <cocreature> we need [x..y) :)
03:04:02 <hvr> ggVGc: I suppose you're coming from Python? :)
03:04:38 <ggVGc> in my experience the upper bound is often a variable, and because of 0-based indexing you always end up going [0..(upper-1)]
03:04:41 <ggVGc> at least I do
03:04:45 <ggVGc> I've had multiple off by 1 so far
03:04:47 <ggVGc> because of it
03:05:20 <ggVGc> in all other languages I know, range functions are not inclusive in the upper bound
03:05:37 <hvr> ggVGc: then you don't know enough languages :-)
03:05:44 <cocreature> yeah I often do [0..n-1]
03:05:56 <ggVGc> hvr: which others are inclusive in the uper bound?
03:06:26 <ggVGc> I agree it makes mathematical sense, and is more "correct" in one sense. BUt in programming it's almost never what you want
03:06:33 <ggVGc> so the syntax is optimized for the uncommon case
03:06:59 <ggVGc> it makes sense if you have 1-based indexing, like lua for example
03:07:00 <bennofs> ggVGc: also, you wouldn't expect [0,1..10] to end at 9, would you?
03:07:22 <ggVGc> I kind of would
03:07:31 <ggVGc> but I agree it might not look as correct
03:07:33 <ggVGc> hm
03:07:40 * hackagebot hPDB 1.2.0.8 - Protein Databank file format library  https://hackage.haskell.org/package/hPDB-1.2.0.8 (MichalGajda)
03:07:47 <hvr> range(1,10)
03:07:48 <hvr> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
03:07:49 <bennofs> ggVGc: but how about 0,1..10? It looks like I just "omitted" some elements, and specified the end element, which is 10
03:07:52 <hvr> at http://mathjs.org/
03:08:22 <ggVGc> okay, I admit defeat
03:08:32 <bennofs> nix-repl> lib.lists.range 0 10
03:08:34 <bennofs> [ 0 1 2 3 4 5 6 7 8 9 10 ]
03:08:34 <ggVGc> anyway, it's got me several times now :(
03:08:40 <ggVGc> I need to pay more attention to this
03:08:52 <DavidEichmann> in C# you would use range with a start index and a count.... you can do the same with "take count [start..]"
03:09:27 <hvr> ggVGc: for a syntax which looks symmetric such as [n..m] it would be non-intuitive to be asymmetric in the inclusion
03:09:38 <ggVGc> yeah, fair
03:09:43 <hvr> ggVGc: for something like 'range(10)'
03:09:54 <hvr> it's less of an issue if it ends at 9
03:10:15 <hvr> although, if you're used to bash scripting, 'seq 10' would end at 10 ;)
03:10:24 <hvr> (and start at 1)
03:10:32 <bennofs> seq 0 10 is inclusive as well :)
03:10:45 <hvr> yeah
03:11:59 <hvr> too bad we don't have a proper '[n,m)' equivalent... otoh, our Enum Double is broken anyway as well
03:12:13 <hvr> otherwise we could say [n.. pred m] for Doubles
03:12:40 * hackagebot hPDB 1.2.0.9 - Protein Databank file format library  https://hackage.haskell.org/package/hPDB-1.2.0.9 (MichalGajda)
03:12:45 <hvr> (which may still suffer from rounding issues of 'pred')
03:20:55 <EvanR> ggVGc: programmers should know that "0 to n-1" is what you usually want
03:21:29 <EvanR> changing intervals so that they randomly dont include n isnt the way to go about that though
03:21:49 <EvanR> and also 1 based makes no sense
03:22:15 <EvanR> the tenth thing a list is numbered 11 o_O
03:22:26 <EvanR> oh no, its 10
03:22:43 <EvanR> but every tenth thing is 11 21..
03:23:05 <EvanR> you have to subtract in other weird places to get it to work
03:24:07 <EvanR> > let n = 10 in [0..n-1]
03:24:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
03:24:15 <EvanR> at least you dont need parens
03:27:02 <narendraj9> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
03:28:40 <henke> "Monads are for making effects explicit" -- but what is the defenition of an effect?
03:30:48 <narendraj9> henke: It varies with the Monad. For IO monad, it is almost anything IO, reading writing files, or to stdout, etc. For STM, it is writing or reading a transactional var.
03:31:59 <dramforever> Question: is there a tutorial for all those meta-information in GHC.Generics?
03:32:14 <EvanR> henke: "conceptually, they describe intensional information about what takes place during evaluation of the program"
03:32:14 <henke> narendraj9: Yes i understand effect as in side effect, but for example the Maybe monad is not dealing with sideeffect? Or maybe im not understanding side effect good enogh.
03:32:34 <EvanR> its not side effects, its main effects
03:32:40 <narendraj9> henke: Monads *can* /describe/ side effecting computations, but it is not necessary to do so. 
03:32:40 * hackagebot rvar 0.2.0.3 - Random Variables  https://hackage.haskell.org/package/rvar-0.2.0.3 (DominicSteinitz)
03:32:59 <EvanR> they happen right there in your face
03:33:06 <EvanR> example of a side effect
03:33:15 <EvanR> let xs = [1,2,launchMissiles,4]
03:33:33 <EvanR> assigning the list to xs (or something) causes missiles to launch
03:34:05 <narendraj9> EvanR: Laziness?
03:34:19 <EvanR> laziness?
03:34:58 <narendraj9> The value for `launchMissiles` won't be computed right away. Just an aside.
03:35:00 <dramforever> monads again? :P
03:35:22 <EvanR> the value of launchMissile is some number, you get it after missiles are launched
03:35:31 <EvanR> perhaps number of missiles successfully launched
03:35:51 <EvanR> side effects arent about laziness
03:36:08 <henke> So in one sentence how would you define effect as is meant by the word effect in Haskell?
03:37:19 <haskell543> hello, how to make something like that? 
03:37:20 <EvanR> there isnt anything special going on when you evaluate a monadic computation, so whats an effect there is subjective
03:37:20 <haskell543> http://lpaste.net/7327723298039529472
03:37:41 * hackagebot random-fu 0.2.7.0 - Random number generation  https://hackage.haskell.org/package/random-fu-0.2.7.0 (DominicSteinitz)
03:37:55 <EvanR> some monads dont do anything you would think is an effect
03:38:14 <EvanR> but you can argue anything
03:38:32 <narendraj9> EvanR: Okay. So you mean evaluation and execution are different? We can have [lanchMissiles, washClothes].
03:39:20 <EvanR> side effects are things that happen during evaluation
03:40:14 <EvanR> impure things! (time to get into a definitional tornado)
03:41:10 <EvanR> henke: you can understand it through example, the effect of Maybe is to bail out on the first Nothing, if any
03:41:13 <narendraj9> EvanR: But the type system won't allow that. IO values in a list of integers, even though it is (IO Int), it is different. 
03:41:34 <narendraj9> Once we get into IO, we can not get out.
03:41:35 <EvanR> the effect of list monad is to run the computation along many branches
03:41:49 <EvanR> youre not "in" IO
03:42:47 <EvanR> the effect of State is to read or write to the environment
03:44:22 <EvanR> the effect of IO depends on what the semantics of IO are, beyond the free monad semantics
03:44:51 <EvanR> which leaves it up to interpretation
03:47:22 <henke> EvanR: But lets say you are building some program for a domain x, what are an example of effect that is not coverd by the standasr monads already in Haskell, that is where i would have to make my own instances of Monad?
03:47:47 <EvanR> well, maybe examples of that are combinations of standard monads abilities
04:11:55 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
04:11:55 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
04:16:00 <zennist> yes, I've got RankNTypes on, but just couldn't get the type to unify
04:16:26 <zennist> let mylens :: forall f. Functor f => (_ -> f _) -> _ -> f _ = at "what" . non 3
04:17:15 <zennist> @let mylens :: forall f. Functor f => (_ -> f _) -> _ -> f _ = at "what" . non 3
04:17:15 <lambdabot>  Parse failed: Parse error: _
04:17:42 * hackagebot userid 0.1.2.6 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.6 (JeremyShaw)
04:17:46 <metl> is there somewhere to see how many packages are on hackage?
04:18:06 <zennist> @let mylens :: Lens' (Map String Int) Int = at "what" . non 3
04:18:07 <lambdabot>  .L.hs:156:18:
04:18:08 <lambdabot>      Not in scope: type constructor or class ‘Map’
04:18:08 <lambdabot>      Perhaps you meant ‘Data.Map.Map’ (imported from Data.Map)
04:18:46 <zennist> @let mylens :: Lens' (Data.Map.Map String Int) Int = at "what" . non 3
04:18:48 <lambdabot>  .L.hs:156:49:
04:18:48 <lambdabot>      Couldn't match type ‘(IxValue m0 -> f0 (IxValue m0))
04:18:48 <lambdabot>                           -> m0 -> f0 m0’
04:20:16 <zennist> @let mylens :: ALens' (Map String Int) Int = at "what" . non 3
04:20:17 <lambdabot>  .L.hs:156:19:
04:20:17 <lambdabot>      Not in scope: type constructor or class ‘Map’
04:20:17 <lambdabot>      Perhaps you meant ‘Data.Map.Map’ (imported from Data.Map)
04:20:29 <zennist> @let mylens :: ALens' (Data.Map.Map String Int) Int = at "what" . non 3
04:20:31 <lambdabot>  Defined.
04:22:16 <mikeplus32> @type non
04:22:18 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
04:23:11 <mikeplus32> @type view (non ())
04:23:13 <lambdabot> MonadReader (Maybe ()) m => m ()
04:25:50 <dramforever> zennist: /query lambdabot 
04:28:22 <mpickering> metl: There are about 9700
04:29:18 <mpickering> metl: "cabal list --simple-output | wc -l"
04:30:04 <mpickering> ah that doesn't work very well
04:57:05 <hsk3> Profiling gives me this:
04:57:07 <hsk3> total alloc = 792,055,448 bytes  (excludes profiling overheads)
04:57:11 <hsk3> but this is just the total memory use
04:57:31 <hsk3> I'm more interested in, the max RAM used at any one time
04:57:47 <hsk3> is that possible to get?
04:59:56 <EvanR> http://i.imgur.com/ugVI7yY.png
05:00:04 <EvanR> thats on the left axis
05:00:27 <EvanR> you can also get real time stats from GHC during runtime
05:00:38 <EvanR> GHC.Stats
05:01:05 <EvanR> also worth mentioning is the utility ekg for monitoring the running process
05:01:46 <EvanR> i made the chart with hp2ps
05:02:43 * hackagebot QuasiText 0.1.2.6 - A QuasiQuoter for Text.  https://hackage.haskell.org/package/QuasiText-0.1.2.6 (MikeLedger)
05:03:03 <hsk3> i get my GHC and GHCi from Stack
05:03:08 <hsk3> what's the best way to get hp2ps?
05:03:47 <EvanR> it thought it came with ghc
05:05:04 <hsk3> ah, you're right
05:05:09 <hsk3> it's right there
05:05:11 <hsk3> thanks
05:15:49 <Berra> I'm not really finding any simple way of implementing a show for a (newtype = Ex String) that doesn't add "" quotes around the finial String. Is there a good solution?
05:16:43 <Berra> I have a data type that is a recording containing Ex1 and Ex1 newtypes - I want to implement a show for the data type for some custom visualization. I just want Ex1 and Ex2 to become strings without the quotes.
05:19:32 <hsk3> EvanR: hmm my program uses only max about 40 kilobytes over only 0.3 seconds or so
05:19:45 <hsk3> but it still can add up to something big like 800 megabytes?
05:19:49 <hsk3> i guess so
05:19:54 <hsk3> computers being fast as they are
05:24:06 <incog> A famous local tradition in Dongyang is the virgin boy egg, an annual tradition in early spring time where the urine of prepubertal school boys preferably under 10 years is collected and boiled with eggs and then sold (for 1.50 yuan around twice the price of a regular boiled egg.) and eaten, it is said "it tastes like spring". In 2008, Dongyang recognized the eggs as "local intangible cultural 
05:24:06 <incog> heritage."
05:26:46 <dramforever> hmm...
05:27:44 * hackagebot pipes-lzma 0.1.1.0 - LZMA compressors and decompressors for the Pipes package  https://hackage.haskell.org/package/pipes-lzma-0.1.1.0 (BenGamari)
05:28:28 <hsk3> incog: that is some real profound haskell wisdom right there
05:28:33 <hsk3> thanks for sharing
05:28:38 <incog> np
05:29:48 <EvanR> hsk3: 800M is nothing
05:30:11 <hsk3> EvanR: it just sounds  alot because it' sonly alot of it's all used at the same time :)
05:31:15 <srhb> Berra: instance Show Ex where show = id ?
05:31:27 <srhb> Berra: Er, show (Ex s) = d
05:31:29 <srhb> s
05:31:43 <srhb> Berra: Typing is hard. :-)
05:45:55 <wilx> Hi there.
05:47:17 <wilx> So...
05:47:49 <wilx> For some reasons I was looking into how hs-bibutils works and I found out it is being shipped (its source) with embedded bibutils.
05:48:09 <wilx> I have also noticed that the embedded bibutils are old and that there are newer versions.
05:48:22 <wilx> I tried to contact the maintainer of hs-bibutils but I got no response.
05:48:53 <wilx> Also, the link for home page on https://hackage.haskell.org/package/hs-bibutils page lead to 404 page.
05:49:38 <wilx> After find out this much, I did update the embedded source of bibutils in hs-bibutils and put the result in https://github.com/wilx/hs-bibutils.
05:49:56 <wilx> It works for me when linked into pandoc-citeproc. 
05:50:37 <wilx> Now, I am not a Haskell coder. I am just a Pandoc user.
05:51:27 <wilx> I guess, my message is that I am looking for somebody to take over the hs-bibutils package and that I he/she can start from the above mentioned GitHub repository.
05:52:08 <wilx> I do not want to become a maintainer just to submit the update because I honestly do not know enough Haskell to deal with potential issues.
05:59:05 <Berra> srhb: That gives me: Couldn't match type ‘a0 -> a0’ with ‘[Char]’
05:59:27 <srhb> Berra: Uh, is it newtype Ex = Ex String?
05:59:57 <Berra> Hm, I might be wrong - one min
06:00:24 <hpc> wilx: the somewhat ridiculous solution would be to become a maintainer, submit the update, and then abandon the project again ;)
06:00:43 <Berra> srhb: It works - thanks!
06:01:20 <wilx> hpc: Yeah. I wanted to avoid that. :)
06:01:21 <srhb> Berra: Be advised that making show instances that don't obey read . show = id is bad form.
06:02:13 <hpc> really it's bad form to be not deriving them in the first place
06:02:45 <hpc> most things you would use a custom instance for are better served elsewhere
06:02:56 <hpc> like with a parsing library instead of Read
06:03:06 <Berra> srhb: I'm somewhat thinking that I'm working in the wrong direction implementing a show without quotes for it - because when I finally need to print it out functions like putStrLn would not have those quotes and would work on any newtype = Ex String -- right?
06:03:46 <Berra> srhb: No, it would still not work. I need the show for the data type to not contain quotes.. hm.
06:03:55 <srhb> Berra: I'm not sure I understand that concern.
06:04:08 <Jinxit> I have a sum type with many constructors, but I also need a plain "enum" for each of these constructors, is it possible to do something more clever than manually copying?
06:04:10 <srhb> Berra: The quoting for regular Show instances happens in show, it's not the data type.
06:04:26 <Jinxit> as in, one enum containing all entries in the sum type
06:05:48 <Berra> srhb: Yes, but I have a show for a data type that will use shows for two newtypes. If I show Ex1 in the show for my data type it will contain those quotes. For example the output would of show (MyData a) = show ex1 ++ " " ++ show ex2 -- would be  "ex1Text" "ex2Text"
06:06:31 <Berra> srhb: While I need it to be ex1Text ex2Text
06:06:45 <srhb> Berra: No, it would not. show ex1 is the show from the Show Ex instance
06:06:49 <Jinxit> so if I have "data Animal = Cat Int | Dog Float" I also need "data Animal' = Cat' | Dog'"
06:07:27 <Berra> srhb: Yes if I do show (Ex a) = a -- it does work. But without that (say deriving Show in the newtype) it would contain quotes.
06:07:47 <srhb> Berra: Yes. Which is why you generally do not use Show for this kind of thing.
06:08:10 <Berra> srhb: So what is a better solution?
06:08:22 <srhb> Berra: Having a separate pretty printer which obeys your rules.
06:09:03 <Berra> srhb: So derive show for my newtypes and data type and create functions taking the arguments I need that will pretty print is better?
06:09:26 <srhb> Berra: You probably won't need the Show instances at all, but yes.
06:09:34 <Jinxit> you can have a Pretty type class
06:09:44 <Berra> srhb: Sure I only need it while tinkering in ghci
06:09:50 <srhb> Yeah :)
06:10:11 <Berra> srhb: Great, thanks for the help! : )
06:11:15 <iamarto> hello everyone
06:11:31 <iamarto> i am not able to access freenode from my xchat
06:11:36 <iamarto> anyone knows why?
06:11:41 <iamarto> it says unreachable
06:11:50 <iamarto> what port is freenode?
06:13:25 <Berra> srhb: So I take it I'm wise to make use of Text.PrettyPrint -- how should I get around it requiring input of String and I have custom newtypes? I might think Text.PrettyPrint.text (show a) -- but then I'm back to the original problem?
06:14:01 <ongy> Is there a library that provides an easy way to draw into the X root window? I can fork out `feh --bg-tile' but I would like to do it without a helper programm
06:14:33 <Berra> ongy: https://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xlib.html ?
06:15:59 <srhb> Berra: Text.PrettyPrint is fairly nifty. How you convert your various values into String for use with the Text function is up to you, but yes, clearly NOT by using show, or you're back to scratch. :)
06:16:36 <ongy> Berra: that's mostly a translation of the X11 library to haskell code, it doesn't provide an easy way, at least none that I know
06:17:24 <iamarto> Guys are there any haskell programs written to run on android?
06:17:46 * hackagebot hint 0.6.0 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.6.0 (mvdan)
06:18:22 <Berra> srhb: Well this is where my understanding lacks. How would I convert (MyNewTyoe "Hello") into a String?
06:19:01 <srhb> Berra: exToString (Ex s) = s
06:19:43 <srhb> iamarto: http://keera.co.uk/blog/category/haskell-2/
06:19:56 <MichaelBurge_> Berra: let myNewType = MyNewType "Hello" in let (MyNewType string) = myNewType in string
06:20:13 <Berra> srhb: Ah, yes that works perfectly. 
06:20:33 <Berra> Thansk MichaelBurge_
06:20:36 <iamarto> thanks
06:27:47 * hackagebot hsx2hs 0.13.5 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.13.5 (JeremyShaw)
06:27:49 * hackagebot unlambda 0.1.4.2 - Unlambda interpreter  https://hackage.haskell.org/package/unlambda-0.1.4.2 (abbradar)
06:32:47 * hackagebot brainfuck 0.1.0.3 - Brainfuck interpreter  https://hackage.haskell.org/package/brainfuck-0.1.0.3 (abbradar)
06:33:38 <EvilMachine> Hey. I noticed that one can’t really abstract out pattern matching. Like matching on something that is given as a parameter, so you can write a higher-order function. Is there a solution for that? Template Haskell perhaps? Am I missing something?
06:34:01 <MichaelBurge_> EvilMachine: GHC 8 has the new pattern synonyms. Have you looked at those?
06:34:14 <Berra> srhb: if I want to define toS for both (Ex1 a) and (Ex2 a) shouldn't I be able to define those using pattern matching? I get error saying it can't match the types.
06:34:51 <srhb> Berra: If you're trying to overload the function name, you need a type class.
06:35:02 <srhb> Berra: Because toS can be either Ex1 -> String or Ex2 -> String
06:35:05 <MichaelBurge_> Berra: toS1 (Ex1 x) = x    and     toS2 (Ex2 x) = x
06:35:44 <Berra> srhb: How could I solve it using a typeclass? I tried doing just that. One sec I'll show how I failed.
06:35:59 <MichaelBurge_> Berra: There's the Data.Newtype typeclass. You could use 'pack' and 'unpack'.
06:36:14 <srhb> Berra: Think just like Show does it.
06:36:23 <srhb> Berra: You're basically reconstructing Show with custom quoting rules.
06:36:27 <MichaelBurge_> Berra: It'd look something like 'instance Newtype Ex1 where unpack (Ex1 x) = x     pack x = Ex1 x
06:37:10 <MichaelBurge_> Berra: There's also Data.Coerce, so you can just do '(coerce (x :: Ex1)) :: String'
06:38:08 <EvilMachine> MichaelBurge_: Ohk Sounds nice! I have to look into how to actually use them.
06:38:36 <Berra> MichaelBurge_: srhb Thanks -- I'll give both a try
06:39:40 <srhb> Berra: For the record, I recommend MichaelBurge_s solution, but I think there's value to trying the very basics of ad hoc overloading with type classes. :)
06:40:20 <Berra> srhb: Noted! I'll start there
06:47:12 <Berra> srhb: Is the idea to implement a typeclass similar to Show and derive that in my newtypes?
06:47:48 <srhb> Berra: I'd just make the instances manually, afterwards, when using coerce, you don't need them at all.
06:48:33 <Berra> srhb: How should I apply the instance? instance Ex1 a where toS (Ex a) = a ?
06:49:07 <srhb> Berra: instance YourClass Ex1 where toS (Ex1 s) = s
06:49:11 <srhb> Berra: Exactly as before.
06:49:51 <Berra> srhb: So I whould first create a class as well? class MyClass where toS :: a -> String ?
06:50:33 <srhb> Berra: toS :: MyClass a => a -> String, but yeah
06:51:10 <Berra> srhb: Is the MyClass => good form or doesn't it work otherwise?
06:51:55 <srhb> Berra: Oh, right, yours is the way to go
06:52:05 <srhb> Berra: You declared the type variable in the class definition. :)
06:53:11 <EvilMachine> MichaelBurge_: Can I pass pattern synonyms around? pattern Blah x = Somepattern x; let f pat x = case g x of { Just (pat y) -> actionA; Nothing -> actionB } in f (Blah) someval;
06:55:21 <Berra> srhb: Wonderful -- it works. Now say I have 4 newtypes that all just contain a String like Ex1. Is there a better way than writing instance 4 times?
06:55:48 <srhb> Berra: Deriving, or simply using coerce. :)
06:56:01 <MichaelBurge_> EvilMachine: I have to admit I've never actually used pattern synonyms before. But I think the syntax is 'let f (pat z) x = ...'
06:56:33 <Berra> srhb: Ok, I want to see how getting deriving to work will be. I failed that before. Than I'll finish with coerce.
06:57:24 <EvilMachine> MichaelBurge_: Well, I think need to be able to pass around partial patterns.
06:58:09 <Berra> srhb: So I want to derive my -- class Stringable a where toS :: a -> String -- and not write any instances, how does that work? How will newtype Ex1 = Ex1 String deriving (Show, Stringable) work?
06:59:43 <Berra> srhb: I get that Stringable isn't a derivable class.
07:00:21 <MichaelBurge_> EvilMachine: You're saying that you want to write something like 'data X = X Int Int; x = X 5 6; f pattern@(X 5) = case x of pattern 6 ->  True'
07:00:46 <EvilMachine> MichaelBurge_: I have a couple of boilerplate functions that all do the same thing, which I want to abstract: case f x of { Just (Somepattern a) -> case g y { Just (Otherpattern b) -> actionAB; Nothing -> actionA }; Nothing -> case g y { Just (Otherpattern b) -> actionB; Nothing -> noAction }; }
07:01:30 <EvilMachine> MichaelBurge_: without the @(X 5), yes. if I understood your code correctly…
07:01:49 <EvilMachine> MichaelBurge_: Now I understood it. Yes, I want to do something likethat.
07:02:27 <EvilMachine> MichaelBurge_: See my boilerplate function thing above.
07:02:57 <srhb> Berra: You would need GeneralizedNewtypeDeriving and some other extensions. It's probably a bit of a sidetrack for now. :)
07:04:14 <Berra> srhb: Alright so if I use GeneralizedNewtypeDeriving and implement an instance for String it should work. Alright, cool. Coercion now.
07:04:27 <srhb> Berra: Yeah exactly. :)
07:05:21 <EvanR> activated ImpredicativeTypes thinking it would make it convenient to do something like [forall a . Foo a]
07:05:27 <Berra> srhb: That gives me String data constructor not in scope. Is that because my matching is off?
07:05:40 <EvanR> but now it seems i can never append to this list
07:05:51 <Berra> instance Stringable String where toS (String a) = a
07:06:37 <srhb> Berra: Probably you need type synonym instnaces
07:06:42 <lpaste> EvilMachine pasted “Passing around patterns?” at http://lpaste.net/165446
07:06:47 <srhb> Berra: Since type String = [Char]
07:06:59 <Berra> srhb: Another extension?
07:07:02 <srhb> Berra: Yes
07:07:24 <merijn> Or just use [Char] instead of String
07:07:28 <srhb> Or that. :)
07:07:29 <EvilMachine> MichaelBurge_: I hope this makes what I want to do unambiguous: http://lpaste.net/165446
07:07:50 <EvilMachine> @Anyone: Can this be done?: http://lpaste.net/165446
07:07:50 <lambdabot> Unknown command, try @list
07:07:56 <srhb> And FlexibleInstances too I think.
07:09:56 <merijn> EvilMachine: Not in any direct way
07:11:52 <Berra> {-# LANGUAGE GeneralizedNewtypeDeriving, TypeSynonymInstances, FlexibleInstances, UndecidableInstances #-} -- instance Stringable String where toS (String a) = a -- It still complains that String constructor isn't in scope/
07:12:08 <EvanR> should i be able to pass an impredicatively typed forall a . Foo a to a function that takes Foo a as a param...
07:12:54 <EvanR> that would be cool
07:14:02 <merijn> Berra: There is no String constructor, what made you think there was?
07:16:13 <EvilMachine> Does anyone know how to do this?: http://lpaste.net/165446
07:17:06 <MichaelBurge_> EvilMachine: Your best bet is TemplateHaskell, passing the quasiquoted pattern to a function that emits Haskell according to your pattern.
07:17:09 <Berra> merijn: Well sure -- but I need to avoid that error so either I need to change how the pattern is written or add some more extension. I don't know which.
07:17:43 <merijn> Berra: Eh, how do you plan to avoid the error of "using something that does not exist"?
07:17:55 <merijn> Berra: The only way to avoid that error is "so don't do that then"
07:18:05 <EvilMachine> MichaelBurge_: Thought so… Hmm… Too bad patterns aren’t first-class in Haskell…
07:18:09 <merijn> Berra: It'd be a bit more helpful if you said what you were trying to accomplish :)
07:18:14 <merijn> EvilMachine: Nope, sadly not :(
07:18:31 <EvanR> Berra: did anyone mention the possibility of abusing TypeSynonymInstances yet? ;)
07:18:40 <srhb> Berra: toS = id
07:18:46 <merijn> EvilMachine: I should probably put that on my wish list of "things to implement for my fairy tail language"
07:19:01 <Berra> srhb: Perfect!
07:19:02 <merijn> EvilMachine: How does that help if he's using String as a data constructor in his pattern?
07:19:04 <Berra> srhb: That did it
07:19:08 <Berra> srhb: Now Coercion
07:19:16 <srhb> Berra: When there's nothing to pattern match on, get rid of the pattern match. :-)
07:19:17 <EvilMachine> merijn: A fairy tail sounds… colorful. :D
07:19:25 <merijn> EvilMachine: I'm tired!
07:19:45 <maerwald> hmm, I want documentation to be generated from my hspec tests :P
07:19:59 <merijn> EvilMachine: Also, I spell phonetically, something which English clearly wasn't designed for >.>
07:20:16 <merijn> Incidentally
07:20:17 * EvilMachine sings merijn a sleep lullaby. … An *evil* sleep lullaby. }:D
07:20:18 <MichaelBurge_> How big are your guys' Haskell codebases? I have this web application that's about 7000 lines of Haskell(and maybe 700 lines of JS & CSS).
07:20:27 <merijn> Isn't "Stringable" just "FromString"
07:20:43 <merijn> MichaelBurge_: Mine? Tiny? Other people's? Huge :p
07:21:01 <srhb> merijn: More like ToString.
07:21:15 <EvilMachine> MichaelBurge_: I thought the whole goal was, to reduce the amount of code… :D
07:23:15 * EvilMachine will design the AppleUI language. It will have only one reserved word “touch”, which does what the compiler tells you you want to do. Anything else is cut for being “confusing”, “too complicated” and “not KISS”.
07:23:18 <merijn> srhb: Oh yeah, that one
07:23:56 * EvilMachine thinks about alternatively “do”… or just “drool”.
07:24:08 <EvanR> don't
07:24:09 <merijn> EvilMachine: You clearly don't appreciate how well done Apple's UI framework is, automatically providing accessibility hooks and scripting hooks for the GUI components :)
07:24:29 <MichaelBurge_> EvilMachine: The biggest offenders are tests, and types used in writing serializers and deserializers.
07:24:34 <EvilMachine> merijn: I meant the user interface. Not the user interface interface. :D
07:25:03 <EvanR> fix interface
07:25:14 <EvilMachine> :D 
07:25:40 * EvilMachine should have started this in #haskel-blah, and not derail the topic in here.
07:25:46 <EvilMachine> +l
07:28:08 <idev> I'm writing an app taht is swift-frontend , haskell-basckend
07:28:15 <idev> I need to transfer a file from frotne end to backend
07:28:24 <idev> how should I structure the haskell part to make the swift part as easy a possible?
07:29:33 <MichaelBurge_> idev: I would probably write the Swift part first, giving it free reign to control the interface.
07:31:10 <MichaelBurge_> idev: Does it need to write directly to the Haskell backend? You could write to an S3 storage bucket instead, which would decouple the Swift from the Haskell here.
07:37:43 <Berra> srhb: Someone mentioned toString -- can a toString function be written that works on a newtype without a typeclass?
07:38:43 <MichaelBurge_> Berra: You can coerce it to a string. I think Coercion a b instances are automatically generated byt he compiler
07:39:52 <Berra> MichaelBurge_: If you mean Data.Coerion -- yes I'm looking into that. I was thinking if there could be something like -- toString a = id or similar that does what deriving a class with toS did.
07:40:30 <MichaelBurge_> toString :: Coercible a String => a -> String
07:40:33 <MichaelBurge_> toString = coerce
07:41:10 <Berra> MichaelBurge_: Alright -- it's only possible using a typeclass or importing Data.Coerce.
07:41:56 <MichaelBurge_> Berra: I mean, there's weirder things to try. Like unsafeCoerce can do it without a typeclass and works for newtypes, or Generics or TemplateHaskell.
07:42:42 <Berra> MichaelBurge_: I see. Now I'm going to write printer functions for my data types -- I'll use coercion in those.
07:43:32 <Berra> If I want one print function that I can define different expressions for I will need a typeclass right?
07:44:18 <MichaelBurge_> Berra: Correct, you'll need a typeclass. You may be able to automatically  or semi-automatically generate instances using Generics, TemplateHaskell, coercion, or deriving.
07:44:36 <Berra> MichaelBurge_: Awesome thanks for the help
07:44:42 <MichaelBurge_> Berra: Someone else may have written a standard printing typeclass too. So I'd look on Hackage.
07:45:04 <Berra> MichaelBurge_: I'd guess https://hackage.haskell.org/package/pretty-1.1.3.4/docs/Text-PrettyPrint.html
07:45:05 <MichaelBurge_> Berra: For example, there's Show for debugging, ToJSON/FromJSON for JSON, Binary for ByteString, etc.
07:45:57 <MichaelBurge_> Berra: Yeah, and in particular see the typeclass here: https://hackage.haskell.org/package/pretty-1.1.3.4/docs/Text-PrettyPrint-HughesPJClass.html
07:46:47 <Berra> MichaelBurge_: Oh, thansk. Seems perfect.
07:47:35 <puregreen> a purely hypothetical question: suppose that I were to write a book that would be useful for writing Haskell in production. Can I count on Haskell shops possibly buying it for their employees? Or such things don't really happen?
07:48:47 <MichaelBurge_> puregreen: One way to test that would be to write some blog articles or preview chapters and try to measure the interest
07:50:38 <MichaelBurge_> puregreen: The 'big' Haskell employers like Facebook or Standard Chartered that have big names might not need the book actually, since they have compiler developers
07:50:47 <MichaelBurge_> puregreen: I wonder how many medium or small Haskell shops there are?
07:52:30 <ertes> hi there…  since my update to GHC 8 "not in scope" errors have turned into warnings…  why is that?  and how would i turn them back into errors, if i wanted?
07:52:43 <mauke> ertes: example?
07:53:16 <ertes> mauke: i use 'void' without importing Control.Monad
07:53:43 <merijn> ertes: That sounds...wrong? o.O
07:54:02 <ertes> i have -fdefer-typed-holes on
07:54:12 <ertes> the "not in scope" error is now a run-time exception
07:55:37 <ertes> it's indeed because of that flag
07:55:53 <ertes> without it the "not in scope" error is an actual compile-time error
07:55:54 <merijn> ertes: Ah, I'm guessing someone screwed up somewhere
07:56:21 <ertes> merijn: well, it's not a hole exception, but a "not in scope" exception
07:56:26 <ertes> so i'm guessing this is a feature
07:56:31 <merijn> ertes: By reusing code somewhere that's only supposed to run for things starting with _
07:56:38 <ertes> hmm
07:57:16 <merijn> ertes: -fdefer-typed-holes is only supposed to turn an error into a runtime exception selectively when it is a hole
07:57:39 <merijn> ertes: I'm thinking missing name errors somehow changed to match holes in the AST
07:57:57 <ertes> yeah, there is nothing in the release notes
07:58:17 <ertes> i'll report it as a bug if necessary
07:59:52 <osa1> ertes, merijn: there's certainly some kind of bug http://lpaste.net/165447
08:00:56 <merijn> osa1: fyi, --make has been redundant for years
08:00:56 <ertes> it's a feature!
08:01:02 <ertes> https://ghc.haskell.org/trac/ghc/ticket/10569
08:01:30 <merijn> Implementors should've added a flag for that
08:01:34 <ertes> certainly feels like a bug…  but i guess it may be useful for "refer now, implement later" style of programming
08:01:43 <merijn> That's bs
08:01:49 <merijn> you'd use "_v" for that
08:01:53 <osa1> it shouldn't panic no matter what though
08:01:56 <ertes> personally i'd like to turn it off
08:02:06 <ertes> osa1: it doesn't panic…  it's a run-time exception
08:02:08 <merijn> You should reopen that so the behaviour only triggers when a flag is enabled
08:02:35 <osa1> ertes: it panics in my case, see my paste
08:02:38 <ertes> merijn: i guess the rationale is that it allows you to write the code, and then it magically works once you have implement everything it refers to without having to remove the underscores
08:03:15 <ertes> osa1: yours looks like an actual bug
08:03:20 <ertes> you should report it
08:12:16 <osa1> reported here https://ghc.haskell.org/trac/ghc/ticket/12156
08:18:31 <ertes> and i've reopened the feature request that introduced it
08:24:58 <ertes> that reminds me of another question: is there a way to move typed hole errors/warnings to the top?  i have other warnings enabled, and currently i have to skip a number of "defined, but not used" warnings to reach the hole warning
08:26:16 <merijn> ertes: Why? Because they spam your output?
08:27:25 <ertes> the other warnings do =)
08:28:07 <ertes> but i'd like to leave them enabled…  what i'm asking for is to make hole warnings have a higher priority, so they appear first
08:28:27 <ertes> warning priorities would be a nice feature to have
08:31:18 <merijn> ertes: I don't think that'd be hard to implement
08:37:39 <ertes> i'll create a feature request
09:07:10 <ertes> done: https://ghc.haskell.org/trac/ghc/ticket/12157
09:07:52 * hackagebot hpath 0.8.0 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.8.0 (maerwald)
09:10:57 <augur> AlainODea: geekosaur: i just finished SPJ's OPLSS course again, it wasnt there :(
09:11:35 <augur> im now on to watch geekosaur's suggestion, since that has a video too
09:12:09 <AlainODea> augur: pretty sure it's in hairshirt like geekosaur suggested
09:17:52 * hackagebot chorale-geo 0.1.0 - A module containing basic geo functions  https://hackage.haskell.org/package/chorale-geo-0.1.0 (FranzBenjaminMocnik)
09:20:07 <augur> AlainODea: perhaps! but that seems very long ago. i remember it being a more recent talk, i think, because i distinctly remember it mentioning the newfound interest in Eff, which is only the last five years or so I thin
09:20:09 <augur> k
09:20:51 <augur> also it was a video, and the only video there is, as geekosaur said, the third link (which isnt hair shirt, but rather Classes, Jim)
09:21:02 <augur> I am however watching that now :)
09:21:12 <augur> and if I still dont find it, thats ok :p
09:22:05 <AlainODea> augur: I will live in infamy forever if I have failed you in this :p
09:22:25 <infinity0> is there an extension of pipes that lets you reject an object, similar to how conduit lets you "push back" stuff?
09:22:47 <augur> AlainODea: dont worry, if this is where it is, i'll live in infamy, because I've been convinced that it was edwardk who gave the talk I'm thinking of! :p
09:23:18 <EvanR> at what point do you switch from a forest of where clauses and primes to... *shudder* a state monad
09:23:42 <augur> i must be misremembering, b/c I know ed has mentioned doing a Monads vs. the World talk, and what I remember of the talk I have in mind is that it had a lot of that feeling -- why monads (and monad transformers) are best
09:23:51 <EvanR> always feel like its more work than is worth it... but
09:24:15 <EvanR> augur: type classes vs the world?
09:24:22 <infinity0> oh wait sorry, you can basically do that with pipes using respond/request instead of yield/await
09:24:36 <augur> EvanR: i just watched that, and no, it's not in there :(
09:25:26 <augur> also nope, AlainODea, it's not in the Classes, Jim video either
09:25:30 <augur> wtf, this is super frustrating
09:25:52 <jmcarthur> infinity0: respond/request isn't really the same thing as conduit's leftovers. See the pipes-parse package for the pipe's equivalent to leftovers.
09:26:02 <jmcarthur> s/pipe's/pipes/
09:26:34 <infinity0> i see ok thanks. yes it's not exactly the same, but i thought you could emulate it by e.g. responding with True/False after receiving an object
09:26:47 <infinity0> and the other pipe would know you "accepted" or "rejected" it
09:26:51 <jmcarthur> infinity0: You could maybe emulate it, but it would be annoying.
09:27:23 <infinity0> ok, i'll take a look at pipes-parse thanks
09:27:24 <jmcarthur> infinity0: Note that the pipes version of leftovers still looks very different from the conduit version.
09:32:53 * hackagebot servant-auth-cookie 0.1.0.0 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.1.0.0 (zohl)
09:49:54 <tippenein> are there any places in core where DiffList's are used? I'm trying to gain an intuition about where they're useful
09:50:12 <tippenein> I guess not even necessarily in core
09:51:08 <jmcarthur> What do you mean by "core"?
10:03:03 <jmcarthur> There was a time many months ago that people were adding various hacks to their emacs configs to get haskell-mode to work with stack. Is there anything simpler now?
10:06:38 <tippenein> I guess I just mean, commonly used libraries
10:07:14 <tippenein> ooo, how do you search by dependency
10:08:08 <tippenein> http://packdeps.haskellers.com/reverse/dlist
10:08:10 <tippenein> v nice
10:08:27 <tippenein> looks like web 1.0 but it works
10:32:55 * hackagebot chorale 0.1.5 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.5 (FranzBenjaminMocnik)
10:51:42 <Berra> When using Parsec and i Parse the string "a -> b -> c" using sepBy myParser (string "->) -- Will myParser parse of  "a " , " b "  and " c\n" ?
10:52:07 <Berra>  Or will it receive "a -> b -> c" three times?
10:52:39 <Berra> Or will it receive "a -> b -> c" then "b -> c" then "c" ?
10:53:12 <EvanR> try it in ghci!
10:53:31 <EvanR> you can test parsers indepdently
10:53:45 <Berra> EvanR: I find it hard to try just that
10:53:54 <EvanR> its not hard
10:54:18 <EvanR> its much les than your questions length
10:54:46 <EvanR> and includes portions of your question hehe
10:55:04 <Berra> EvanR: Well, right you are.
10:56:59 <EvanR> a good workflow is to type definitions into your source file, then reload it in ghci with :r
10:57:26 <EvanR> that makes it easier to modify tests
10:57:55 * hackagebot chorale-geo 0.1.1 - A module containing basic geo functions  https://hackage.haskell.org/package/chorale-geo-0.1.1 (FranzBenjaminMocnik)
11:03:19 <turiya> hi
11:03:26 <suppi> oooh, i like this white top https://www.haskell.org/
11:03:30 <suppi> hello turiya
11:04:48 <turiya> hi suppi
11:05:49 <turiya> the IArray type class has two parameters a and e. CArray is defined to be an instance of IArray as Instance IArray CArray e but CArray is not a type, CArray is defined as data CArray i e and so it is a type constructor requiring two parameters
11:06:30 <turiya> is it possible to put type constructors without parameters in instance declaration?
11:09:13 <geekosaur> I would not expect that to work without MultiParameterTypeClasses extension
11:10:29 <geekosaur> ..and note that MPTCs are not sanely usable without either type families or functional dependencies (meaning, some way to be able to associate the multiple parameters; otherwise type inference is pretty much dead in the water)
11:12:18 <turiya> i am confused
11:12:56 * hackagebot chorale-geo 0.1.2 - A module containing basic geo functions  https://hackage.haskell.org/package/chorale-geo-0.1.2 (FranzBenjaminMocnik)
11:13:22 <turiya> without that extension, type classes need types for instance declation
11:13:53 <turiya> with that extension, instance declaration is possible using only type constructors?
11:14:17 <EvanR> you can define instances with only constructors normally
11:14:24 <EvanR> example monads
11:14:31 <EvanR> functors
11:15:36 <turiya> the monad type class goes something like "Monad m where ..." so here m should be a type
11:15:52 <EvanR> no, its not clear from just that what m is
11:15:54 <geekosaur> turiya, if a typeclass expects N arguments then the instance must specify N-1 arguments
11:16:58 <geekosaur> hm, I think I started that out wrong, let me think about this a moment
11:17:27 <EvanR> return :: a -> m a establishes m as :: * -> *
11:17:31 <geekosaur> maybe I should strt by asking why you want to be able to use CArray without parameters
11:17:41 <turiya> EvanR, i see
11:17:52 <turiya> the kind is * -> * so m is a type constructor
11:17:59 <glguy> turiya: Also, the CArray in "data CArray i e" *is* a type, it just don't have kind *
11:18:45 <turiya> i was just wondering if we can instantiate using only type constructors
11:18:55 <turiya> the CArray was just an example
11:19:18 <EvanR> yep type constructors are functors and monads
11:19:40 <EvanR> but not monoids
11:19:49 <benzrf> what's the point of things like `  (:&) :: (r ~ (sy ::: t)) => f t -> Rec rs f -> Rec (r ': rs) f` instead of `  (:&) :: f t -> Rec rs f -> Rec ((sy ::: t) ': rs) f`
11:19:58 <EvanR> unless we jump the shark and every is both a type and a type constructor
11:21:12 <glguy> Bool is a "type constructor", a is a "type variable"
11:21:37 <turiya> glguy, CArray has two parameters so isnt it a type constructor
11:21:49 <mjrosenb> benzrf: well, I can *almost* parse the latter.
11:21:54 <glguy> No, CArray itself is a type constructor like how Left and True are data constructors
11:22:01 <glguy> It's the capitalized name that is the "constructor"
11:22:40 <EvanR> also ctors 3 and 'x'
11:22:59 <benzrf> EvanR: Char is just a gigantic sum type ;)
11:23:15 <turiya> CArray is a type constructor which accepts two types as parameters, am I right?
11:23:24 <EvanR> afaict its an abstract type
11:23:35 <mjrosenb> benzrf: is it finite?
11:23:49 <geekosaur> > maxBound :: Char
11:23:51 <lambdabot>  '\1114111'
11:23:58 <geekosaur> Bounded suggests finite :)
11:24:11 <benzrf> mjrosenb: certainly - unicode is finite!
11:24:23 <EvanR> probability implemented with CReal however
11:24:25 <glguy> Yeah, "CArray" is a type constructor for a type with kind * -> * -> *, and you can apply such a type to two other types of kind *
11:24:33 <EvanR> or rational
11:24:42 <mjrosenb> benzrf: but they can always add more codepoints... I don't see a reason that they can't add an infinite number of them
11:25:10 <mjrosenb> granted, there may be some issues actually using them, but that's never stopped anyone before.
11:25:14 <turiya> the only constructors are, CArray !i !i Int !(ForeignPtr e), so probably it is intended to be used when intefacing with C
11:25:28 <EvanR> 21 bits is enough for anybody (tm)
11:25:42 <benzrf> EvanR: is that what unicode is at right now?
11:25:48 <EvanR> yes
11:26:02 <EvanR> the rest of the space "will never be used by anything"
11:26:10 <EvanR> to help detect invalid encodings
11:26:15 <benzrf> then why is there utf-32, instead of just utf-24
11:26:21 <benzrf> er, not utf
11:26:23 <benzrf> ucs i guess
11:26:26 <benzrf> blagh
11:26:27 <EvanR> see utf-9
11:26:42 <geekosaur> because modern computers don't have 24-bit built-in types
11:26:47 <geekosaur> (word sizes)
11:27:11 <benzrf> my knowledge of encodings: "ascii is smaller than unicode, latin-1 is some awful relic that's also not unicode, utf-8 is Good™, sometimes japanese ppl use shift-jis"
11:27:31 <turiya> thanks
11:28:10 <EvanR> and windows...
11:28:21 <EvanR> said FFFFUUUUU
11:28:59 <turiya> EvanR++
11:29:12 <turiya> glguy++
11:29:17 <turiya> geekosaur++
11:29:44 <Squarism> should one avoid to recurerse too deep? Right now, my whole program is a recursive function, in each invokation recurse(state) - creates a new state that is passed to recurse(newState) 
11:30:06 * geekosaur would imagine utf-9 was intended for dec mainframes
11:30:18 <geekosaur> Squarism, calling does not recurse in haskell
11:30:25 <Squarism> a nice
11:30:29 <geekosaur> what can recurse and get you in trouble is pattern matching
11:31:19 <geekosaur> but haskell is graph reduction, evaluation reduces nodes in the graph and "calls" are de facto implemented as jumps (everything is "tail recursive" as standard evaluation would see it)
11:32:05 <Squarism> geekosaur, is there some explaination on this issue available in digestible form for noobs?
11:32:12 <geekosaur> ..although that's an implementation detail of ghc's graph engine (STG machine)
11:32:33 <EvanR> you can imagine it visually using syntax alone
11:32:42 <geekosaur> most haskell papers are surprisingly readable. while some details have changed, the original STG machine paper is a decent introduction
11:33:02 <EvanR> by doing direct substiution of expressions
11:33:32 <EvanR> let blocks (which are recursive) can represent the graph structure
11:34:51 <EvanR> step 0 is to remember that evaluation applies functions before evaluating the arguments, and step 1 is that evaluation is to WHNF, not full normal form
12:03:31 <nitrix> https://github.com/nitrix/lspace/compare/master@%7B1day%7D...master
12:03:54 <nitrix> I've put so much work into my game today, I can move in the world, update stuff, handle keys properly, render properly...
12:04:02 <nitrix> And yet, only ~300 lines changed D:
12:04:55 <tdammers> 300 lines of haskell though
12:05:08 <tdammers> that's like the equivalent of 9000 lines of Java
12:05:51 <monochrom> 300 of lines do a lot
12:06:33 <tdammers> also, measuring code in number-of-lines is a bit silly IMO
12:07:15 <monochrom> I measure # of tokens
12:07:55 <buttbutter> Hi. I'm trying to write foldl using foldr. *Please* do not give me any hints. I think I've figured out how to do, but I'm unsure how to express it in haskell. Here is my attempt: http://lpaste.net/165498 . The compiler has a problem with (f inside outside). What am I doing wrong here and how can I fix it?
12:09:34 <monochrom> a decade ago, someone posted in the newgroup comp.lang.functional to complain how a 100000-line Haskell file would take half an hour to compile
12:10:14 <cocreature> buttbutter: you can’t pull function application apart by pattern matching on it
12:10:49 <monochrom> so I replied: (A) why do you put 100000 lines in one single file?  (B) if you have 100000 lines of Haskell, that already exceeds Microsoft Office functionality, I wouldn't say half an hour is a long time to build a whole office suite.
12:10:52 <buttbutter> cocreature: Why not :( 
12:13:11 <cocreature> buttbutter: imagine you had a function Int -> Int, if you could pattern match on function application you could handle (1 + 1) differently than 2 which is highly confusing. leaving the fact aside that it’s confusing and unclear how exactly it works, the runtime might simply have decided to evaluate your function call at which point the arguments are simply no longer available (they might have been gcd)
12:13:35 <buttbutter> Oh. I see. That makes sense.
12:13:40 <buttbutter> Well crap, then I'm back at square 1 ;_;
12:13:54 <cocreature> buttbutter: don’t worry if you can’t figure it out. that exercise is far from trivial
12:14:23 <buttbutter> I've spent like 4 hours on it so far
12:14:26 <buttbutter> I'm gonna figure it out >:C
12:17:29 <monochrom> buttbutter: I think it's extraordinarily hard to do foldl in terms of foldr. are you sure you don't need hints? because even I needed it when I did this.
12:17:56 <cocreature> even if you see the solution it takes a few minutes to realize it is correct
12:18:04 <buttbutter> I've noticed it's hard. I feel like I'm an idiot. 
12:18:14 <monochrom> s/even//
12:18:22 <buttbutter> But I've learned a lot in my struggle
12:18:23 <glguy> buttbutter: The key you need to consider is that foldr captures primitive recursive functions defined on lists, once you get that defining foldl with foldr will be easy
12:18:30 <glguy> but it's not something you're going to just stumble into
12:19:02 <buttbutter> "Captures primitive recursive functions defined on lists..."
12:19:23 <buttbutter> Can you dumb that down a bit?
12:19:34 <glguy> ?src foldr
12:19:34 <lambdabot> foldr f z []     = z
12:19:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:19:44 <ertes> buttbutter: implement foldr and foldl separately and compare their shapes…  see if you can fit foldl into the shape of foldr
12:19:53 <buttbutter> ertes: I've done that!
12:20:00 <ertes> buttbutter: well, can you?
12:20:15 <glguy> It's the functions where you always make a recursive call on the tail of a list, have a way to combine that with the head of a list, and have a value for the tail of a list
12:20:23 <glguy> ?src foldl
12:20:23 <lambdabot> foldl f z []     = z
12:20:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:20:36 <buttbutter> ertes: I mean apparently *I* can't
12:20:57 <buttbutter> glguy: Right, I know that. 
12:21:04 <buttbutter> But it's still not really clear to me.
12:21:28 <glguy> buttbutter: You might copy down this link, I break down how to get from foldl to foldr in 5 steps https://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b
12:21:36 <glguy> even if you don't read all or any of it yet
12:21:42 <buttbutter> Basically I need to take f x1 (f x2 (f x3 z))) and turn it into f(f(f z x1) x2) x3
12:21:46 <buttbutter> And it seems so hard :(
12:22:01 <ertes> buttbutter: you can try to do something simpler or at least less general first:  try to implement a left-associated sum in terms of foldr
12:22:25 <ertes> find f and z such that:  foldr f z = foldl (+) 0
12:22:26 <buttbutter> glguy: I'll look at that if I give up :)
12:22:49 <glguy> buttbutter: you might just look at the top of it, open the window at the bottom of your screen and slide it up a little
12:23:00 <glguy> each step is well separated
12:23:14 <buttbutter> Let me try ertes' exercise first
12:24:20 <monochrom> I second glguy's derivation. (yes, it's a derivation. the solution is produced, not divined.)
12:24:54 <buttbutter> Yeah...maybe I'll just look. 
12:25:00 <ertes> buttbutter: note that "it's impossible" is a valid answer
12:25:12 <buttbutter> I really thought I'd be able to figure it out. It doesn't seem hard but it's really, really hard :O
12:25:38 <ertes> buttbutter: "hard" is optimistic =)
12:27:22 <EvanR> is this more or less hard as defining foldl/foldr with fold
12:27:24 <idev> is Standard Chartered + Galois + Obsidian Systems the main successful haskell companies?
12:27:34 <idev> (was reading some news.yc about whether haskell is used in industry)
12:27:52 <jmcarthur> EvanR: I think it's about equivalent in difficulty.
12:28:03 <ertes> idev: "haskell company"?  "company that uses haskell"?  "company that is haskell-focussed"?
12:28:15 <idev> ertes: company that uses haskell
12:28:37 <jmcarthur> We use xmonad where I work. Does that count?
12:28:41 <idev> no
12:28:43 <ertes> idev: facebook uses it, and i think google also has a few haskell projects, but not sure about the latter
12:28:44 <merijn> idev: Don't forget facebook
12:28:47 <idev> I'm thinking company that writes haskell software
12:29:03 <tdammers> it's a continuum
12:29:06 <jmcarthur> Our xmonad configs are haskell software.
12:29:07 <merijn> Is there any way to combine code using Pipes and Conduit in an easy way?
12:29:10 <EvanR> a no name market research company i worked at has a haskell program still running
12:29:13 <monochrom> Facebook is a succesful Haskell company
12:29:14 <idev> oh right, FB has brian o sullivan
12:29:17 <EvanR> they probably never found out about
12:29:18 <ertes> idev: if i understood it right, every message you post on facebook goes through a massively deployed haskell program
12:29:19 <tdammers> there's companies like Galois / SC / ... that bet their operation on haskell
12:29:25 <merijn> idev: They hired Simon Marlow too
12:29:31 <ertes> idev: it's their abuse filter
12:29:38 <idev> ertes: I thought it was erlang
12:29:39 <tdammers> there's companies like FB, where Haskell is an important part of their operation, but not necessarily the centerpiece
12:29:44 <monochrom> let me try to think up a more surprising example
12:29:44 <idev> ertes: oh, their hand written spam filter, hmm
12:29:49 <tdammers> there's companies where Haskell is one of many tools
12:29:52 <jmcarthur> I'm not trying to be a smartass, though it may appear that way. Just trying to help you make your question more precise by providing examples that I doubt you really mean.
12:30:03 <ertes> merijn: pipes and conduit are not fully compatible…  you can convert any pipe into a conduit, but not vice versa
12:30:03 <glguy> Galois uses Haskell when it makes sense to, but other languages when it doesn't
12:30:13 <idev> jmcarthur: I do admit, I am being ambigious.
12:30:20 <buttbutter> glguy: What's the motivation behind the "-- Move non-recursive parameters to right side of =" step?
12:30:26 <phanimahesh> standard chatered? I heard they use haskell heavily
12:30:32 <merijn> ertes: I don't need full compatibility. I just have some pipes code that I wanna tie into http-conduit/xml-conduit
12:30:41 <idev> data HaskellCompanies = HaskellOnly | HaskellHeavily | HaskellSome | HaskellNone
12:30:46 <ertes> merijn: you can use 'next'
12:30:50 <monochrom> the standard chatter about Standard Chartered
12:30:51 <glguy> buttbutter: so that it's clear that aux only depends on the list argument
12:30:58 <ertes> merijn: for producers at least
12:31:04 <ertes> there is probably something similar for consumers
12:31:12 <glguy> buttbutter: foldr expects you to provide two cases, [] and (:)
12:31:23 <merijn> Semi-relatedly: What'd be the best way to rate limit outgoing requests?
12:31:24 <glguy> buttbutter: so moving them over we get exactly the code for those two cases 
12:31:44 <buttbutter> Ah, I see.
12:31:49 <ertes> merijn: if time is involved, i'd probably use concurrency
12:32:42 <jmcarthur> idev: Facebook also has Simon Marlow
12:32:53 <monochrom> buttbutter: functions implementable by foldr has a characteristic form (if you use recursion yourself). so you sometimes have to massage your recursion into that form for better recognition.
12:32:58 * hackagebot machines 0.6.1 - Networked stream transducers  https://hackage.haskell.org/package/machines-0.6.1 (EricMertens)
12:33:21 <ertes> merijn: for example a TBQueue with a thread that reads a value from it periodically…  that allows you to insert a limited number of values without blocking
12:33:27 <buttbutter> Right, I'm getting that now.
12:34:07 <monochrom> so it turns out the solution is from staring at the code rather than staring at an example like ((1+2)+3) :)
12:34:07 <buttbutter> (\a -> a) still confuses me, though. The base/initial value of the accumulator is an identity function?
12:34:38 <monochrom> yeah. the solution is to use foldr to build a function first, not a string.
12:34:54 <glguy> ?src foldl
12:34:54 <lambdabot> foldl f z []     = z
12:34:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:35:11 <glguy> foldl f z []     = z    --is like--    foldl f [] z = z   --- is like --- foldl f [] = id
12:36:30 <buttbutter> Why is foldl f z [] =z like foldl f [] z = z?
12:36:46 <monochrom> if you are allowed to change parameter orders
12:36:55 <buttbutter> Oh.
12:36:58 <glguy> just rearranging the arguments so you can see that there's basically an "id" case in normal foldl
12:37:09 <buttbutter> What's the mathematical name for functions where f x y = f y x, again?
12:37:23 <glguy> I'm not saying you can actually rearrange the arguments without any other changes
12:37:44 <ertes> buttbutter: commutative
12:37:46 <buttbutter> Okay, that makes more sense. 
12:38:39 <ertes> buttbutter: given lf and lz, there are no f and z such that foldr f z = foldl lf lz…  but there are f, z, g such that:  g . foldr f z = foldl lf lz…  in other words: strictly speaking it's impossible to define foldl in terms of foldr
12:39:03 <ertes> that's why i said: "hard" is optimistic
12:39:17 <EvanR> i bet Q could do it
12:39:23 <buttbutter> I see :)
12:39:25 <ertes> EvanR: which one?
12:39:41 <EvanR> define foldl in terms of foldr
12:39:49 <ertes> EvanR: no, which Q? ;)
12:39:53 <EvanR> duh
12:40:09 <buttbutter> Okay. So the basic idea of glguy's proof is to capture the recursive structure of foldl, and knowing that foldr captures the recursion pattern for lists, all he has to do is get the behavior of foldl into a function that he can use with foldr. Right?
12:40:47 <ertes> buttbutter: yeah, you don't fold the list into the result, but a function that produces the result given the initial value
12:40:53 <merijn> ertes: Why exactly whould I not want to block when rate limiting? That's the entire point of rate limiting, no?
12:41:05 <buttbutter> Man. I would've never figured that out. :)
12:41:15 <buttbutter> I think I mostly understand the proof but I still don't really have intuition for it. :(
12:41:18 <ertes> merijn: i meant: you may not want to block right away, but only rate-limit the output
12:41:46 <merijn> ertes: I want to rate-limit outgoing requests, anything local should run as fast as it can
12:41:56 <ertes> merijn: exactly
12:42:24 <ertes> you can use TQueue to have anything local run as fast as it can…  or you use TBQueue to set a bound on the queue
12:42:56 <merijn> How does bound help me rate-limit? I wanna, e.g., not have more than 5 request per second outgoing
12:43:25 <monochrom> buttbutter: this is one of those instances where you can't discover it yourself, but it's better to be taught, but once taught, you can go on build upon the dead bodies of the giants, so it's OK.
12:43:38 <ertes> merijn: that's why there is a periodic reader at the other end of the queue =)
12:44:18 <merijn> ertes: My point is that processing an outgoing request might take N seconds, so I need to have multiple parallel threads handling requests
12:44:46 <ertes> merijn: each with their own rate limit?  or a global one?
12:45:21 <EvanR> use a time semaphore
12:45:34 <EvanR> starts at 5, decrement when you execute a request, unless its 0
12:45:43 <EvanR> a 1/5 second thread increments it
12:46:05 <merijn> ertes: Global one
12:46:14 <monochrom> merijn: I think the issue is this. Suppose I have a chain of producers X -> Y -> Z -> A -> B. Now we have decided that B's output rate should be 1 byte or less per hour. The question is should we affect A too? Z? Y? X?
12:46:38 <buttbutter> I'm actually having trouble understanding "(\x rec a -> rec (f a x))" as well. What does it mean to have the "rec" in the lambda function like that?
12:46:46 <merijn> monochrom: It's rather simple in my case as the rate limit is remote requests which are the input to a local chain
12:46:57 <merijn> monochrom: The local processing isn't subjest to rate limiting
12:46:59 <maerwald> is there a better database than hoogle?
12:47:31 <geekosaur> @where hayoo
12:47:31 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
12:47:49 <monochrom> perhaps an unbounded buffer between A and B. so A may be outputting fast, but B dequeues 1 byte per hour. Does that sound good?
12:47:56 <michaelt> ertes: its a little ugly but Conduit -> Producer  could be e.g. \p -> hoist lift p $$ mapM_C P.yield
12:47:57 <ertes> merijn: requester writes into T(B)Queue, dispatcher reads periodically (e.g. each 0.2 secs) and writes into a TMVar, request workers read from the TMVar
12:48:14 <merijn> monochrom: So given a list of N requests to do, I want to limit myself to no more than X per second hitting the remote side
12:49:06 <merijn> ertes: You're assuming a single requester, but I'm not sure that makes sense?
12:49:17 <ertes> merijn: i'm not
12:51:31 <mauke> does anyone remember when the Package Versioning Policy was created?
12:52:35 * monochrom doesn't know, but bets its version number was 0.1 :)
12:55:36 <monochrom> buttbutter: I need to check whether you already know: "\x y -> 2*y+x" means the same as "\x -> \y -> 2*y+x", and both mean that my function has two parameters (morally), 1st is x, 2nd is y, so if I use it as "(\x y -> 2*y+x) 7 3" I get 2*3+7
12:56:28 <ph88^> hi guys
12:56:43 <merijn> hmmm
12:56:56 <michaelt> ertes: also, fwiw CL.unfoldM (fmap (either (const Nothing) Just) . P.next)  :: Monad m => P.Producer a m b -> ConduitM i a m ()
12:57:08 <merijn> For some reason installation inside a sandbox fails for me unless I first manually install "Cabal", any clues why that might be?
12:59:26 <buttbutter> monochrom: That's just currying, right?
13:00:57 <glguy> Currying has to do with the relationship between functions that take a tuple argument and ones that return functions
13:02:06 <buttbutter> Wait, so what monochrom is talking about isn't currying?
13:03:26 <geekosaur> people often confusing currying and partial application
13:04:00 <glguy> \x y -> .... === \x -> \y -> ...    is just about understanding the syntax of lambdas in Haskell
13:05:21 <buttbutter> glguy: Is there anything to understand beyond \x y -> simply being equivalent to \x -> \y ->?
13:05:32 <ertes> buttbutter: yes:
13:05:45 <ertes> 1. function types: X -> Y -> Z = X -> (Y -> Z)
13:05:53 <ertes> 2. application: f x y = (f x) y
13:06:00 <buttbutter> But 1. IS currying, right?
13:06:07 <ertes> both
13:06:28 <hpc> having either without the other would be rather a nightmare
13:06:32 <buttbutter> And f x y = (f x) y is just the left-associativity of function application, right?
13:06:53 <buttbutter> And what's "both"? Currying and ?
13:07:01 <nitrix> Hi, anyone knows how I could simplify this lens? http://lpaste.net/165500
13:07:10 <nitrix> I'm trying to remove the intemediary lambda.
13:07:13 <glguy> currying is turning a function:  (a,b) -> c    into    a -> b -> c
13:07:31 <buttbutter> Hency haskell's curry function :D
13:07:35 <buttbutter> Hence*
13:09:14 <puregreen> nitrix: hm, shouldn't you be able to say “zoom gameWorld $ do worldShips .= demoShips; ...”
13:09:40 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/165500#a165502
13:10:11 <ph88^> i want to capture the whitespace while parsing because i want to be able to reconstruct the original source, but i'm not sure where to capture whitespace
13:10:34 <nitrix> puregreen: That's impressive.
13:10:53 <nitrix> puregreen: Thanks a lot.
13:11:27 <glguy> nitrix: the paste annotation was for you
13:12:17 <nitrix> Yeah that would have been my last resort solution.
13:12:23 <nitrix> The zoom thing is amazing though.
13:12:32 <ph88^> if after parsing i have a tree, where should i introduce the nodes for the whitespace ?
13:12:59 * hackagebot skulk 0.1.3.0 - Eclectic collection of utility functions  https://hackage.haskell.org/package/skulk-0.1.3.0 (geekyfox)
13:13:29 <ph88^> be back later
13:23:00 * hackagebot haskell-player 0.1.3.3 - A terminal music player based on afplay  https://hackage.haskell.org/package/haskell-player-0.1.3.3 (potomak)
13:32:10 <idev> does haskell have a fold with state?
13:32:18 <idev> where instead of doing (a -> b) -> [a] -> [b]
13:32:29 <idev> the (a -> b) instead is ((s,a) -> (s,b))
13:32:31 <simpson> idev: mapAccumL, maybe?
13:32:34 <simpson> :t mapAccumL
13:32:35 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:32:38 <idev> so it's ((s,a) -> (s,b)) -> s -> [a] -> [b]
13:32:40 <begriffs> Is it good practice to build with -Wmonomorphism-restriction ?
13:32:49 <merijn> begriffs: No
13:32:57 <merijn> begriffs: Eh, wait, yes
13:33:08 <merijn> begriffs: But why would you need to? It's in -Wall I think?
13:33:14 <idev> :t mapAccumL
13:33:15 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:33:24 <idev> simpson: okay, that is what I want; thanks!
13:34:03 <begriffs> I'm porting code to GHC 8 and combined with Werror it's requiring me to annotate the types for things that seem like they shouldn't need it. (I am using -Wall so that must be what's enabling it)
13:35:46 <begriffs> Actually just tried removing "-Wmonomorphism-restriction" and leaving "-Wall" and it doesn't complain about some of this stuff so it seems like Wall does not contain that other option by default.
13:37:00 <monochrom> it is true that the semantics of -Wall changes per version
13:37:46 <mjrosenb> bah, the misleading error message is still there in ghc-8
13:38:21 <geekosaur> can't you make a stateful fold just by treating the seed as (s,a) and propagating it as such, then unwrapping at the end?
13:42:19 * mjrosenb will note that with mapAccumL, you end up with a list, so you can't reduce a list down to a single element.
13:45:14 <hexagoxel> merijn: you have a Cabal=installed constraint somewhere and it picks up your globally installed Cabal when the sandbox is clean?
13:46:08 <merijn> hexagoxel: I dunno, it fails on stuff like stm/text
13:46:56 <hexagoxel> "fails"?
13:48:00 * hackagebot cyclotomic 0.4.4.1 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-0.4.4.1 (ScottWalck)
13:48:02 * hackagebot learn-physics 0.6.0.1 - Haskell code for learning physics  https://hackage.haskell.org/package/learn-physics-0.6.0.1 (ScottWalck)
13:49:25 <merijn> hexagoxel: "user error (The package 'stm' requires Cabal library version -any && >=1.10 but no suitable version is installed.)"
13:49:57 <texasmynsted> I saw this —>  http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html  Is pattern matching and "if" statement truly syntactic sugar for case statements?
13:50:12 <ertes> texasmynsted: yeah
13:50:48 <texasmynsted> I am not sure why that surprises me but it does
13:51:32 <monochrom> I don't think standard-wise (eg Haskell 2010) requires it. but GHC certainly does it.
13:52:11 <mjrosenb> texasmynsted: IIRC, you can implement if/then/else using case in C as well.
13:52:18 <shachaf> texasmynsted: They behave the same way. Does it matter whether one is sugar for the other?
13:52:25 <monochrom> if you write any compiler, you certainly are inclined to do it again. since it's so convenient to translate everything to a thrift intermediate language.
13:52:41 <texasmynsted> ha
13:52:43 <texasmynsted> ok
13:53:01 * hackagebot hylolib 1.5.1 - Tools for hybrid logics related programs  https://hackage.haskell.org/package/hylolib-1.5.1 (GuillaumeHoffmann)
13:53:03 * hackagebot happstack-server 7.4.6.2 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.4.6.2 (JeremyShaw)
13:54:09 <mauke> case is an expression, not a statement
13:54:15 <mauke> pattern matching is what case does
13:55:49 <shachaf> In GHC, both Haskell "case" and Haskell "if" are translated to Core "case", which is different from either one.
13:56:08 <shachaf> I guess there are some cases where Haskell "case" isn't translate to Core "case", actually.
13:57:19 <hexagoxel> merijn: sorry, i have no idea. unless you cabal-install is way old.
13:57:44 <texasmynsted> I think the important thing was for me to know that case is the expression that is the result of the desugaring, so I should learn in better detail all the tricks for case
13:58:01 * hackagebot authenticate-oauth 1.6 - Library to authenticate with OAuth for Haskell web applications.  https://hackage.haskell.org/package/authenticate-oauth-1.6 (achirkin)
13:58:40 <ertes> texasmynsted: you can express haskell programs using a very small subset of the language
13:58:51 <ertes> haskell is small – semantically
13:58:53 <merijn> hexagoxel: What is way old? It's 1.22.6.0
13:59:24 <texasmynsted> ok
13:59:39 <hexagoxel> merijn: i'd guess it is the compiled-with-Cabal version that matters.
14:00:14 <merijn> hexagoxel: Compiled with Cabal 1.22.4
14:00:30 <ertes> merijn: GHC 8?
14:02:26 <merijn> 7.10
14:03:01 * hackagebot wai-transformers 0.0.5 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.5 (athanclark)
14:03:03 * hackagebot wai-middleware-verbs 0.3.0 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.3.0 (athanclark)
14:06:09 <tempeh> can someone eli5 overlapping instances? does it have some way of determining precedence? 
14:06:26 <monochrom> texasmynsted: I don't think you need to think in terms of desugaring for that, unless and until you ask about small changes in efficiency. the right level is "same answer", and Haskell 2010 addresses that.
14:06:48 <monochrom> if you're 5-year-old: I'll tell you when you grow up.
14:07:23 <monochrom> if you're willing to change 5 to 15, then we're game
14:08:01 * hackagebot happstack-server-tls 7.1.6.2 - extend happstack-server with https:// support (TLS/SSL)  https://hackage.haskell.org/package/happstack-server-tls-7.1.6.2 (JeremyShaw)
14:08:21 <tempeh> okay eli15
14:09:02 <texasmynsted> well I want to know exactly how guards work, how I can match against an expression rather than a value (guards, I suppose), etc.
14:09:37 <monochrom> there is a precedence based on how specific an instance is. "instance X [Char]" is more specific, and prefered to, than "instance X [a]", IIRC
14:10:31 <tempeh> ah, i see
14:10:54 <tempeh> so if one isn't strictly more specific then there's a problem
14:11:20 <monochrom> right
14:11:30 <tempeh> cool, sounds like what i need. thanks!
14:11:47 <monochrom> "instance X (a, Char)" vs "instance X (Bool, b)" is going to be neither-chosen
14:13:15 <mjrosenb> texasmynsted: there are at least two different levels of guards.
14:14:43 <mjrosenb> texasmynsted: namely, there are boolean guards, and pattern guards.
14:16:03 <mjrosenb> texasmynsted: boolean guards are PAT | EXPR = EXPR, and that case in the pattern is only chosen if the guard expression evaluates to true, so for example foo (h:t) | even (sum t) = h
14:16:33 <rockfruit> I have a question about the recursion used in this definition of fibonacci sequence: """ fibs = 1 : 2 : zipWith (+) fibs (tail fibs) """.    (I don't know about any stepping debugger to use with ghci).  It appears that "fibs" will return an endless list, however '(tail fibs)' somehow knows how to return the "current" tail.  In my mind, (tail fibs) would never return.  Can you help me understand this?  It
14:16:35 <rockfruit> seems really brilliant...
14:17:32 <merijn> rockfruit: Why would it never return?
14:17:46 <merijn> rockfruit: That seems to imply tail walks until the end of the infinite list, but why would it do that?
14:17:54 <rockfruit> because "fibs" is an "endless" list.  if I just type "fibs" it does not end....
14:18:14 <merijn> rockfruit: Why would tail stop working just because it's endless?
14:18:30 <rockfruit> maybe I am misunderstanding tail.  Yes, that's what I am doing.  "tail" does not mean "go to the end and give me an item", rather it means separate the top from the "rest".
14:18:49 <rockfruit> All better now!  Thanks for your patient help
14:18:50 <ertes> rockfruit: ask yourself what happens during pattern-matching
14:18:53 <merijn> rockfruit: :)
14:19:17 <rockfruit> ertes... I will now try answer myself that question.
14:19:27 <ertes> rockfruit: ones = 1 : ones  -- if you match that against x : xs, what is x?
14:19:34 <monochrom> rockfruit, "tail fibs" is not the current tail. it is, and always will be, the global tail.
14:20:16 <mjrosenb> @src sort
14:20:16 <lambdabot> sort = sortBy compare
14:20:19 <texasmynsted> boolean guards and pattern guards?
14:20:26 <mjrosenb> @src sortBy
14:20:26 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
14:20:26 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:20:38 <mjrosenb> sweet, mergesort.
14:20:57 <texasmynsted> you mean like
14:21:00 <rockfruit> ertes I understand. ta!
14:21:05 <texasmynsted> | exp = exp 
14:21:21 <texasmynsted> oops
14:21:23 <texasmynsted> I mean 
14:21:28 <texasmynsted>  | exp == exp
14:21:30 <texasmynsted> vs 
14:21:33 <ertes> mjrosenb: it is mergesort, but the lambdabot definition is not
14:21:37 <texasmynsted>   True | exp == exp
14:21:42 <merijn> Where is ZipList exported?
14:21:45 <ertes> rockfruit: well, x = ?
14:22:00 <texasmynsted> so without the boolean first, the expression in the guard will always be evaluated? 
14:22:06 <mjrosenb> ertes: I'm fine with that, since I usually don't use lambdabot for heavy computations :-p
14:22:48 <monochrom> texasmynsted: yes
14:23:10 <tippenein> how can I constrain a quickcheck property to positive ints
14:23:12 <mjrosenb> texasmynsted: but exp == exp is a pretty silly guard.
14:23:21 <texasmynsted> ha
14:23:52 * mjrosenb hopes it would either evaluate to true, diverge or fail to typecheck
14:23:55 <mjrosenb> and not much else.
14:23:58 <texasmynsted> Ok, is there a reference someplace to help with this?
14:24:11 <texasmynsted> I did not find what I was looking for at wiki.haskell.org
14:24:15 <rockfruit> ertes 1!
14:24:37 <ertes> rockfruit: and xs = ?
14:24:47 <monochrom> texasmynsted: I wonder if Haskell 2010 chapter 3 is good enough for you
14:25:17 <rockfruit> 1111.... there's a threshold I've yet to cross, I can `almost` parse haskell, not yet generate it properly....
14:25:31 <mjrosenb> texasmynsted: http://learnyouahaskell.com/syntax-in-functions has a section on guards.
14:25:55 * texasmynsted googles Haskell 2010 chapter 3
14:25:57 <ertes> rockfruit: match 'ones' against x : xs…  xs = ?
14:26:29 <texasmynsted> o_O 
14:26:33 <texasmynsted> Wow, this is great.
14:27:12 <monochrom> I prefer zero = 0 : zero
14:27:28 <ertes> rockfruit: (literally just read the definition)
14:27:30 <monochrom> and sometimes I prefer infinity = () : infinity
14:27:47 <rockfruit> x = 1, and xs = [1,1,1,1,1..] - ghci is weird
14:28:02 * hackagebot ircbot 0.6.5 - A library for writing IRC bots  https://hackage.haskell.org/package/ircbot-0.6.5 (JeremyShaw)
14:28:02 <texasmynsted> Thank you.  This is quite helpful
14:28:04 <rockfruit> took me a while to find out how to define a function in ghci prompt!
14:28:06 <ertes> rockfruit: can't you give a "simpler" answer?
14:28:11 <rockfruit> hm
14:28:34 <rockfruit> 1 : ones         :)
14:28:39 <ertes> even simpler
14:28:40 <rockfruit> not quite accurate
14:28:50 <ertes> it's correct, but there is an even simpler answer
14:29:17 <rockfruit> ones      that's 'simple' :/
14:29:23 <ertes> yeah
14:29:35 <ertes> ones = 1 : ones  -- matched against x : xs:  x = 1, xs = ones
14:30:05 <rockfruit> well     "1 : ones"      and     "ones"     they are really the same, are they not?  since both are infinite, having an extra leading '1' makes zero difference 
14:30:23 <ertes> did it take infinite time to figure x and xs out?  it doesn't matter whether the list is finite or infinite
14:30:40 <ertes> it's not about the data structure, but about the question you ask, i.e. the pattern you match
14:30:57 <ertes> that's laziness explained without talking about evaluation =)
14:31:32 <ertes> rockfruit: yeah, they are the same, and there is a simple reason why they are:  you *defined* them to be the same
14:31:41 <ertes> ones = 1 : ones  -- this is an equation
14:32:42 * rockfruit eats own tail. "ahaa. lightbulb."
14:32:50 <rockfruit> madness
14:35:04 <texasmynsted> is there an important difference between '_' and 'otherwise' ?
14:35:17 <ertes> texasmynsted: they are entirely different things
14:35:23 <hpc> using _ in a pattern match will say "ignore this"
14:35:23 <mitchty> anyone know of a good tutorial with setup of cabal+ghc for interaction with external c ffi? trying to know how you work around things like segfaults etc... aka external process that you isolate to do ffi and talk to via named pipes or whatever
14:35:27 <ertes> texasmynsted: otherwise = True
14:35:33 <hpc> using otherwise in a pattern match will bind the identifier 'otherwise' to that thing
14:35:45 <hpc> using otherwise where a Bool would go, what ertes said
14:35:53 <hpc> and in that case, _ is a syntax error
14:36:08 <ertes> it's more likely a hole in modern haskell
14:36:13 <texasmynsted> oh, I thought that _ was an always match
14:36:19 <hpc> oh right, or a hole
14:36:35 <ertes> texasmynsted: f _ = 5  -- a constant function
14:36:56 <ertes> texasmynsted: f otherwise = otherwise + otherwise  -- a doubling function, in which you just happened to name the variable 'otherwise'
14:37:08 <ertes> > let f otherwise = otherwise + otherwise in f 5
14:37:10 <lambdabot>  10
14:37:13 <texasmynsted> I mean as the entire matching expression in a case or guard 
14:37:28 <ertes> guards are just booleans
14:37:30 <texasmynsted> | otherwise = kajfdkajf
14:37:35 <ertes> and 'otherwise' is just True
14:37:35 <texasmynsted> | _ = asdkfjasdkfj 
14:37:44 <hpc> hmm, i thought i did something nefarious like that with otherwise in acme-php but i was mistaken
14:37:49 <ertes> in the latter the _ is a typed hole
14:37:56 <ertes> an expression you promise to fill in later
14:38:04 <texasmynsted> I do?  hmm
14:38:17 <texasmynsted> Ok, then I suppose I should be using otherwise
14:38:33 <ertes> 'otherwise' is really just True…  it's not a language construct
14:38:36 <ertes> > otherwise
14:38:37 <lambdabot>  True
14:38:50 <texasmynsted> but it might read better than simply putting True
14:38:52 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#otherwise
14:39:13 <texasmynsted> I did :info on otherwise
14:39:36 <texasmynsted> and it was Bool, and the only Bool that would make sense for it would be True
14:39:45 <ertes> @src otherwise
14:39:45 <lambdabot> otherwise = True
14:40:55 <mitchty> also, has anyone any experience with avoiding ffi entirely via https://hackage.haskell.org/package/inline-c say?
14:41:54 <geekosaur> as I understand it, it doesn't actually avoid ffi, it hides it
14:41:59 <mjrosenb> texasmynsted: the idea behind the guard is that you're restricting the set of input values that the case matches, most likely using external values (e.g. an equality function).
14:42:02 <geekosaur> it's using ffi under the covers
14:42:44 <geekosaur> and the fpcomplete folks use it a fair amount, apparently
14:42:47 <ertes> "… you can also think of inline-c as to Haskell what inline Assembly is to C — a convenient means to eke out a little bit of extra performance in those rare cases where C still beats Haskell."
14:42:48 <ertes> hehe
14:42:59 <mjrosenb> texasmynsted: it is *almost* kind of sort of like just having the expression for that branch of the case being an if statement... but it is actually more powerful, and useful.
14:43:34 <mitchty> ah, was a bit ambiguous, all I"m really needing here is an interface to an external c library that gets stuff (strings really) from a daemon
14:44:10 <mitchty> also wanting to make sure i properly put it into its own restraints so it can't segfault things as well
14:45:16 <geekosaur> the only way you're going to do the latter is to run it in a subprocesse
14:45:19 <geekosaur> -e
14:45:47 <mitchty> so my plan was fork/exec out the c ffi and have the main process handle it like erlang might actually
14:45:54 <texasmynsted> hmm
14:46:12 <texasmynsted> ok
14:49:14 <mrpat> hi all, tryin to connect to a mongo database, I can’t figure out the authentication part, here’s what I have: access pipe master “db_name” $ auth “user_here” “pass_here” do
14:49:54 <mrpat> pipe being: pipe <- connect (host “localhost”)
14:50:07 <ertes> mrpat: that looks like a syntax error
14:50:43 <mrpat> ertes: getting: Not in scope: ‘auth’
14:51:10 <ertes> mrpat: but 'access' is there?
14:51:37 <ertes> mrpat: could you paste your code to <http://lpaste.net/>?
14:52:36 <mrpat> ertes: http://lpaste.net/165509
14:53:03 * hackagebot bv 0.4.1 - Bit-vector arithmetic library  https://hackage.haskell.org/package/bv-0.4.1 (IagoAbal)
14:53:05 * hackagebot list-fusion-probe 0.1.0.6 - testing list fusion for success  https://hackage.haskell.org/package/list-fusion-probe-0.1.0.6 (JoachimBreitner)
14:53:25 <ertes> mrpat: it's (at least) a syntax error
14:53:50 <ertes> access p m n . auth u p $ do …
14:54:03 <ertes> not tested, but the types suggest that this is the way to write it
14:54:03 <texasmynsted> Ok so if pattern matching is sugar on case, how does the tuple unpacking work?  Like what would this de-sugar to as a case expression?  http://lpaste.net/6933168807452082176
14:54:24 <ertes> mrpat: oh, no
14:54:41 <ertes> mrpat: access p m n $ do auth u p; …
14:54:46 <ertes> this is the way
14:54:50 <geekosaur> texasmynsted, case is the primitive for pattern matching
14:54:54 <mrpat> ertes: ah!
14:54:58 <geekosaur> a pattern looks the same way in a case
14:55:37 <geekosaur> case someTuple of (a,b) -> ...
14:56:16 <geekosaur> when you're using it in a binding, it generates names to go in place of your patterns and then does case on those names
14:57:02 <ertes> texasmynsted: f = \p1 p2 -> case p1 of (a, b) -> case p2 of (c, d) -> ((b, d), (a, c))
14:57:11 <ertes> mrpat: you're welcome…
14:59:21 <texasmynsted> iteresting thank you
14:59:31 <texasmynsted> interesting rather.
14:59:49 <ertes> texasmynsted: the lambdas could be expanded further, too
14:59:49 <texasmynsted> The pattern matching version is much easier to read
15:00:05 <ertes> but i'll leave that as an exercise
15:00:17 <texasmynsted> heh thank you.  This is helpful
15:02:12 <cheater> :t ( (+) <$> (1, 1) <*> (3, 4))
15:02:13 <lambdabot> (Num b, Num t, Monoid t) => (t, b)
15:02:30 <cheater> can someone explain to me why t has Monoid?
15:02:46 <cheater> :t (+)
15:02:47 <lambdabot> Num a => a -> a -> a
15:02:51 <cheater> :t (<$>)
15:02:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:02:54 <cheater> :t (<*>)
15:02:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:03:01 <cheater> doesn't say monoid in either of those
15:04:15 <dibblego> because the Applicative instance for ((,) t) requires Monoid t
15:04:20 <cheater> oh
15:04:30 <cheater> OK
15:05:01 <cheater> what's the best way to add pairs of numbers pairwise?
15:05:59 <hpc> :t join . uncurry
15:06:00 <lambdabot> (a1 -> b -> (a1, b) -> a) -> (a1, b) -> a
15:06:23 <hpc> :t \f -> join . uncurry f
15:06:25 <lambdabot> Monad m => (a1 -> b -> m (m a)) -> (a1, b) -> m a
15:06:35 <cheater> i'm thinking something with arrows perhaps but not sure
15:06:47 <hpc> just write it ;)
15:07:30 <hpc> also i continue to be amazed at how little Arrow abstracts over
15:07:37 <hpc> it's pretty much used only for messing with tuples now
15:08:13 <cheater> :t (***) (+) (+)
15:08:14 <lambdabot> (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
15:08:17 <cheater> close. hmm
15:08:51 <cheater> yeah hpc it's like arrow was supposed to be great but then all interest in it died and it doesn't do anything now other than messing with pairs, as you say.
15:09:01 <cheater> sometimes i wonder if it was being oversold.
15:09:14 <hpc> it wasn't oversold, it was just bad
15:09:19 <hpc> all it needed to do is not have arr
15:09:29 <maerwald> I don't understand what the problem here is. Just write the function. Why waste so much time looking for obscure combinators that do the same?
15:09:44 <maerwald> you can always refactor later
15:10:20 <cheater> maerwald: i feel like this should be less problematic
15:10:49 <cheater> i'm not writing code i'll use later, i just whipped open ghci to use it as a calculator and i got stumped by the fact that there isn't a convenient combination of existing functions that do this
15:10:58 <cheater> so i'm wondering if i missed something obvious
15:11:06 <cheater> simplest i could find: \(x, y) -> (***) (+x) (+y)
15:11:43 <maerwald> please don't @pl it.
15:11:55 <exio4> @pl \(x,y) -> (***) (+x) (+y)
15:11:55 <lambdabot> uncurry ((. (+)) . (***) . (+))
15:12:00 <maerwald> -.-
15:12:21 <maerwald> I wish someone disabled @pl in lambdabot.
15:12:24 <dibblego> use Vector, then sum
15:12:40 <cheater> hmm
15:12:52 <hpc> wait, do you just need uncurry (+)?
15:12:54 <hpc> :t uncurry (+)
15:12:55 <lambdabot> Num c => (c, c) -> c
15:13:23 <cheater> i want to add pairs
15:13:47 <cheater> (1, 2) ++++ (3, 10) -> (4, 12)
15:13:50 <hpc> so like (a, b) + (c, d) = (a + c, b + d)
15:13:57 <cheater> yes
15:14:08 <cheater> oh i know
15:14:12 <hpc> @@pl djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
15:14:20 <hpc> @@ pl djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
15:14:20 <lambdabot>  pl djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
15:14:25 <hpc> >:(
15:14:34 <cheater> @hoogle [(a, b)] -> ([a], [b])
15:14:35 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:14:35 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:15:15 <ertes> > liftA2 (+) [1,2,3] [10,20,30]
15:15:16 <lambdabot>  [11,21,31,12,22,32,13,23,33]
15:15:22 <ertes> > zipWith (+) [1,2,3] [10,20,30]
15:15:24 <lambdabot>  [11,22,33]
15:17:13 <hexagoxel> hpc: @. pl djinn  or  @@ @pl @djinn
15:17:33 <cheater> :t (***) sum sum . unzip $
15:17:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:17:36 <cheater> er
15:17:51 <cheater> :t (***) sum sum . unzip $ [(0, 19), (7, 34), (7, 02), (7, 29), (11, 35)]
15:17:52 <hexagoxel> hpc: result is not pretty :p
15:17:52 <lambdabot> (Num a, Num b) => (a, b)
15:18:05 <cheater> (***) sum sum . unzip $ [(0, 19), (7, 34), (7, 02), (7, 29), (11, 35)]
15:18:13 <cheater> > (***) sum sum . unzip $ [(0, 19), (7, 34), (7, 02), (7, 29), (11, 35)]
15:18:15 <lambdabot>  (32,119)
15:18:20 <cheater> works ^
15:18:23 <hpc> hexagoxel: it's also probably wrong because it'll only use the first element of each tuple
15:18:32 <hpc> djinn likes to be as lazy as it can
15:19:58 <etatoby> hello. is there a style considered "better" between (foo . bar . baz $ x) and (foo $ bar $ baz $ x)?
15:20:41 <etatoby> or is there a difference deeper than style?
15:20:45 <mauke> the former has more valid subexpressions
15:21:08 <glguy> Don't forget about good old ()s
15:21:29 <etatoby> valid subexpressions?
15:22:32 <etatoby> what do you mean?
15:22:38 <glguy> etatoby: Neither is "better". People have lots of opinions.
15:22:55 <etatoby> right
15:22:59 <glguy> If you find yourself writing   f . g $ x, you're probably better off just writing   f (g x)
15:23:40 <glguy> "More valid subexpressions" means you can use your mouse to extract more valid substrings
15:24:02 <glguy> (foo . bar . baz $ x) ; foo . bar . baz ; baz $ x ; bar . baz
15:24:03 <shachaf> I don't think (g . h $ x) is a subexpression of (f . g . h $ x)
15:24:19 <shachaf> Not that it matters.
15:24:23 <glguy> nope!
15:24:34 <etatoby> I see
15:25:13 <cheater> you can equally manipulate the string f $ g $ h $ x
15:25:39 <cheater> it's just uglier because it doesn't separate the place you string functions together with the place you build your data
15:26:02 <glguy> cheater: The difference is that you wouldn't extract "f $ g" from that with your mouse
15:26:26 <cheater> whereas in f . g . h $ u x   you can see if there's a change of the form of data between the right side of $ and left side of it
15:26:36 <cheater> glguy: why not?
15:26:51 <cheater> oh, well if it's unapplied, yes
15:27:03 <cheater> you'd need to add $ x in the end
15:27:17 <glguy> OK, but now you're using your keyboard *and* your mouse
15:27:25 <cheater> i never use the mouse though
15:27:38 <glguy> Oh, then this isn't the conversation for you
15:27:53 <cheater> for me it's about readability though, i like to use $ as a delimiter as mentioned above to express my idea of what's going on in the code
15:28:51 <etatoby> I see, I have always been reasoning about data flow, that's why I preferred f $ g $ h $ x
15:28:56 <cheater> i see your point about using the mouse and keyboard too, it would be bad to have to switch between them
15:29:33 <etatoby> but the homework in CIS 194 uses (f . g . h $ x) and it got me wondering why
15:33:04 * hackagebot hailgun 0.4.0.5 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.0.5 (RobertMassaioli)
15:34:17 <monochrom> in "f $ g $ h $ x", there are 4 names. which one is different from the other three?
15:34:28 <cheater> i think it's because . is a different way of thinking than $. for me $ is purely syntactical, whereas . combines functions.
15:35:21 <cheater> . combines functions according to their type. $ doesn't combine functions.
15:35:23 <hpc> etatoby: the main point is that (f . g . h) is something you can reason about separately from it being applied to x
15:35:32 <root_> hello
15:35:32 <hpc> etatoby: f $ g $ h means something entirely different
15:35:39 <etatoby> sure
15:36:02 <cheater> \x -> f$g$h$x just happens to be the same thing as f.g.h
15:36:14 <etatoby> do they compile to the same machine code?
15:36:15 <etatoby> and how would I check something like that?
15:36:25 <cheater> you could have ghc spit out core
15:36:47 <monochrom> I think it's a bit premature to worry about machine code
15:36:51 <glguy> $ and . both get inlined
15:37:08 <glguy> This is purely a style conversation
15:38:02 <hpc> in any event, the hidden conclusion you should be drawing from the choice between f . g . h $ x and f $ g $ h $ x is that you are probably better off structuring your code better anyway
15:38:14 <hpc> since you've already hit the point of fighting against parens
15:39:04 <hpc> usually the way to go is thinking about what (f . g . h), (f . g), or (g . h) is
15:39:28 <bumpkin> is there any reason other than personal taste to prefer guards vs case in haskell?
15:39:42 <bumpkin> new to haskell but it looks like they basically do the same thing, is that true?
15:39:46 <hpc> bumpkin: they do different things
15:39:47 <cheater> you have -ddump-simpl and -ddump-asm
15:39:50 <cheater> for ghc
15:40:02 <hpc> pattern matching with case binds things to names
15:40:17 <hpc> > (case x of Just y -> y) (Just "like this")
15:40:19 <lambdabot>      Couldn't match expected type ‘Expr’
15:40:19 <lambdabot>                  with actual type ‘Maybe (Maybe [Char] -> t)’
15:40:19 <lambdabot>      In the pattern: Just y
15:40:31 <hpc> > (\x -> case x of Just y -> y) (Just "if i typed it right")
15:40:33 <lambdabot>  "if i typed it right"
15:40:52 <hpc> whereas with guards, you'd do | isJust x -> fromJust x
15:41:08 <hpc> and if that condition is something non-trivial, you now have a potential bug
15:41:16 <bumpkin> hpc, by bind things to names, you mean it binds something to the name x?
15:41:20 <dolio> I don't see why composing more than two functions together means you need to refactor your code.
15:41:21 <hpc> maybe you wrote the condition wrong and fromJust now fails
15:41:24 <bumpkin> hpc, in that example
15:41:54 <hpc> bumpkin: in that case, the pattern (Just y) matched on (Just "if i typed it right"), making y = "if i typed it right"
15:43:01 <hpc> dolio: not always, but if you can't justify picking one style over another you can most likely do better
15:43:25 <hpc> dolio: even if it's just as simple as not thinking as repeated function application and start thinking of it as a composition of functions
15:43:58 <bumpkin> hpc, not sure if I'm understanding fully.  Just is a monad right? do you have an example without monads (haven't learned much of them yet)
15:44:09 <bumpkin> hpc, or is that where you would typically want to use a case expression
15:44:14 <geekosaur> it has a Monad instance but it is not being used here
15:44:15 <hpc> i am not using anything monadic here
15:44:20 <etatoby> cheater: yeah I guess one should look at asm. I tried -ddump-prep but the $ and . are still there. but I guess I won't go further, hpc is right
15:44:32 <hpc> i picked Maybe because it's just the most convenient thing
15:44:50 <hpc> and demonstrates well the phenomenon of boolean blindness
15:45:08 <bumpkin> hpc and what does the \x do in that exapmle?
15:45:25 <hpc> it's a function that takes a parameter named x
15:45:30 <Jinxit> if I have "data Animal = Cat Int | Dog Float", and I also want an sum type of just the constructors like "data Animal' = Cat' | Dog'", is there a clever way to do that?
15:45:47 <hpc> bumpkin: i should have just written case (Just "if i typed it right") of Just y -> y
15:46:07 <hpc> it was a bit needlessly indirect
15:46:31 <cheater> i made a small test with $ vs . but unfortunately -ddump-asm seems to produce different identifier names for the two so it's difficult to diff the output
15:46:53 <bumpkin> hpc, okay.  I guess i still don't understand what case does differently from guards.  What names does it bind what things to?
15:47:06 <etatoby> bumpkin: when you say "prefer guards vs case", do you mean "prefer pattern matching vs case"?
15:47:20 <etatoby> guards are the conditions between | and =
15:48:02 <hpc> bumpkin: in that example, y = "if i typed it right"
15:48:14 <hpc> bumpkin: it's defined by the pattern (Just y)
15:48:55 <bumpkin> hpc, okay what scope is that binding of y valid?
15:49:01 <hpc> bumpkin: which basically says, "if the constructor is Just, then name the parameter to Just 'y' and then produce the expression after the arrow"
15:49:10 <hpc> and it's in scope just for the expression after the arrow
15:49:46 <hpc> another example:
15:49:50 <hpc> case x of
15:49:57 <hpc>   Left x -> "x is in scope here"
15:50:04 <hpc>   Right y -> "but not here"
15:50:20 <hpc> erp
15:50:27 <hpc> s/case x/case v/ or something
15:50:49 <mjrosenb> haskell still doesn't support disjunctive patterns, does it?
15:51:00 <hpc> disjunctive patterns?
15:51:05 <mjrosenb> other than using @
15:51:49 <bumpkin> hpc, ok i think i'm seeing it so if you wanted to use y after the -> operator in the second expression, you could do it but only because case binds that value to y there?
15:52:03 <hpc> bumpkin: indeed
15:52:08 <etatoby> mjrosenb: I don't think so
15:52:12 <mjrosenb> so like foo (Left(x,y)@Right(y,x)) = x++y;
15:52:33 <bumpkin> hpc, could do sort of the same thing with the | guard = way by using let?
15:53:02 <hpc> you could, but there's more stuff you have to do yourself, and more importantly more ways you can make a mistake
15:53:10 <hpc> and this is where the concept of boolean blindness comes in
15:53:17 <hpc> when you do something like
15:53:31 <hpc> if isJust x then fromJust x else something else
15:53:46 <hpc> inside the 'then' part you have this hidden assumption now that isJust x is true
15:53:57 <hpc> guards are ultimately sugar for if-then-else btw
15:54:25 <hpc> however, nothing is stopping you from writing that condition wrong
15:54:32 <hpc> if isJust x then fromJust y else something else
15:55:20 <hpc> or, if (isJust x) || (blah blah) then fromJust x else something else
15:55:45 <hpc> in the 'y' example, you're extracting information from a value you haven't checked
15:56:01 <hpc> in the '||' example, you're extracting information from something that you haven't properly determined has that information
15:56:17 <mjrosenb> hpc: I'm prettu sure it is rather hard to desugar guards into if statements
15:56:22 <bumpkin> hpc right, but that's just an error/typo right? checking x but then using y?  How does case prevent that?
15:57:08 <hpc> bumpkin: the test and the extraction of information are both happening at the same time
15:57:50 <hpc> if you write case x of Just v -> fromJust y, it's pretty obviously wrong
15:58:00 <hpc> or if you write case x of Just v -> y, that's a type error
15:58:12 <hpc> assuming x and y have the same type
15:58:34 <hpc> you also can't sneak any (|| blah blah) conditions into it
15:58:39 <hpc> it either matches or it doesn't
15:59:38 <etatoby> I think it's impossible to desugar guards into if statements in general, because an incomplete guard falls through to the next pattern (I just checked it) which I don't think an if statement can do
16:00:03 <hpc> it's not impossible, just not trivial
16:00:09 <hpc> foo | p = x
16:00:11 <mjrosenb> etatoby: yup.
16:00:14 <hpc> foo = y
16:00:29 <hpc> translates to foo = if p then x else case ... of ... -> y
16:01:08 <hpc> the point is that guards are boolean logic
16:01:20 <mjrosenb> hpc: and you still need to have foo = y afterwards
16:01:27 <mjrosenb> yay, exponential blowup!
16:01:30 <hpc> which is significantly weaker than pattern matching in the area of guaranteeing things are what they are
16:01:41 <hpc> mjrosenb: no you don't
16:02:24 <mjrosenb> hpc: you may, depending of if it is weaker or stronger than the guarded pattern.
16:02:25 * hpc looks for the relevant report section
16:02:46 <bumpkin> hpc, okay I think I see the main difference now, guards being only boolean logic and not pattern matching
16:03:18 <mjrosenb> so like foo (1:h:t) | h < 10 = t; foo (h:t) = [h]
16:04:03 <hpc> bumpkin: yeah
16:04:04 <mjrosenb> you'd need to duplicate foo(h:t) = [h], once for the case where h>=10, and once for the case where the first element was not 1.
16:04:08 <hpc> mjrosenb: oh yeah, i see now
16:04:11 <glguy> Introducing pattern guards
16:04:25 <hpc> wait, no i don't
16:04:53 <hpc> foo xs@(1:h:t) = if h < 10 then t else case xs@(h:t) -> [h]
16:05:00 <hpc> you repeat xs there, but meh
16:05:18 <mjrosenb> hpc: that'll give a pattern match failure on [3,4,5]
16:05:24 <mjrosenb> when it should evaluate to [3]
16:05:29 <hpc> oh right
16:05:43 <hpc> anyway you see my point
16:05:53 * hpc gtg though
16:06:09 <hpc> bumpkin: hopefully that makes sense, and you can google boolean blindness for a post that probably explains it better
16:06:43 <athan> ekg is friggin sweet
16:07:23 <bumpkin> hpc yeah i will, never heard of that before
16:07:52 <bumpkin> thanks
16:08:22 <athan> bumpkin: From what I understand, types should specify intention specifically, and bools are about as vague as can be
16:11:48 <etatoby> do guards force evaluation, in the same sense that pattern matching does?
16:12:13 <athan> Does anyone here know of any haskell implementations for voting algorithms?
16:12:29 <athan> etatoby: Yes, because the guarded data needs to be inspected
16:13:21 <athan> someProperty : Foo -> Bool; someProperty (Foo x) ... <- it needs to pattern match anyway;   doSomething x | someProperty x = ...
16:14:05 <etatoby> so it forces evaluation of the guard, which may or may not inspect its own anguments. right
16:26:19 <athan> If you were a tar archive, why in the heck would you be truncated? :|
16:28:01 <athan> http://lpaste.net/165516 and this is on version 1.24.0.0 of cabal-install
16:29:02 <athan> aaaaand now it works for some reason
16:30:48 <athan> nevermind
16:32:13 <monochrom> if I were a tar achive, I would be teleported many times around computers. Some teleporters may be faulty and truncate me.
16:32:56 <monochrom> but Gödel probably proved that I wouldn't know.
16:33:36 <monochrom> this is probably who Gödel prefers to use 2^a 3^b 5^c 7^d ... rather than use a tar archive.
16:34:12 <monochrom> s/who/why/
16:36:11 <glguy> Theorem — "Any consistent formal system F within which a certain amount of elementary arithmetic can be carried out is truncated"
16:36:50 <glguy> So maybe those library's tar files were able to express a certain amount of elementary arithmetic?
16:38:31 <monochrom> prove or disprove: the lens library in tar format expresses Peano arithmetic
16:45:05 <mrpat> hi all, still struggling with connecting to a mongodb database: http://lpaste.net/165518, it works as it is, besides that it returns an authentication error but I’m not sure how to call the “auth” (commented on the next line), any help appreciated
17:02:47 <lpaste> glguy annotated “mongodb test” with “mongodb test (annotation)” at http://lpaste.net/165518#a165520
17:03:00 <glguy> mrpat: Glancing at the documentation for the package it looks like that could work
17:05:23 <mrpat> glguy: it does, thanks!!!
18:07:33 <nilof> Is there a way to use ascii characters instead of unicode?
18:07:47 <shachaf> No.
18:08:46 <geekosaur> what does that even mean
18:09:37 <Koterpillar> https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Encoding.html#v:decodeASCII ?
18:10:20 * geekosaur is guessing someone has confused haskell with agda, or just assumes "unicode" means "requires codepoints >128"
18:10:56 <geekosaur> er, "requires codepoints >128 in order to write a program"
18:11:00 <nilof> ah
18:11:07 <nilof> bytestring was exactly the type I needed
18:11:08 <nilof> thanks
18:11:13 <geekosaur> o.O
18:11:37 <Koterpillar> nilof: what are you trying to do?
18:12:30 <nilof> Turning a very large dyck word in a .txt into a more efficient representation
18:13:16 <Koterpillar> one word?
18:13:59 <nilof> multiple actually so I can break it up, but in the original problem it can be seen as one word
18:15:07 <nilof> though really I should be generating it in Haskell
18:15:56 <nilof> but properly generating a truly random Dyck word is a PITA
18:17:33 <nilof> if you want it to have a particular distribution
18:18:57 <Koterpillar> I was just worried that you'd do something unicode-dirty. FYI if you only have codepoints <128, encoding in UTF-8 is as efficient as in ASCII.
18:19:49 <jmcarthur> Well, the encoding is as space efficient (identical), but if the code is design to support UTF-8 then it will still be less efficient than code specialized for ASCII.
18:19:56 <jmcarthur> *designed
18:20:35 <puregreen> also fyi, I haven't checked but https://hackage.haskell.org/package/bytestring-plain might be useful if you want to reduce memory consumption
18:20:42 <Koterpillar> doesn't look like encoding/decoding is the bottleneck here...
18:21:07 <jmcarthur> Koterpillar: How can you tell from what nilof said?
18:22:26 <Koterpillar> guessing, really
18:22:41 <Koterpillar> they could even compute the word (?) instead of reading it
18:23:10 * hackagebot neural 0.1.0.0 - Neural Networks in native Haskell  https://hackage.haskell.org/package/neural-0.1.0.0 (lbrunjes)
18:27:07 <nilof> I only need to recognize the characters  '(' and ')' , is Unicode just as fast as ascii for that?
18:27:36 <Koterpillar> nilof: use bytestring and match on their byte values
18:27:47 <nilof> ya, that was what I was going for
18:33:12 * pavonia wonders what the speed of Unicode even is
18:34:13 * geekosaur smells premature optimization
18:35:29 <shachaf> The speed of Unicode is probably U+1F684   HIGH-SPEED TRAIN     [🚄]
18:54:01 <pikajude> is there a hackage package for an in-memory key => value cache?
18:55:22 <Koterpillar> pikajude: MVar (Map key value) ?
18:55:30 <pikajude> yeah, like that
18:55:47 <pikajude> but more like MVar (Map key (MVar value)) so it can be read from multiple threads
19:06:02 <Cale> pikajude: Quite often it turns out that MVar (Map k v) is better even in cases where you'd think it would be useful for the values to be separate MVars, so try both if you're really concerned about performance.
19:07:13 <pikajude> well, my main reason for the extra layer of MVars is that I don't want a bunch of threads competing to be the seeder of the value
19:07:27 <pikajude> since seeding will be an expensive operation
19:11:00 <Koterpillar> pikajude: I wanted to make an argument about why it won't work, but I guess this is an argument for why you do need a package
19:15:12 <ertesx> pikajude: one way is:  TVar (Map k (Async a))
19:17:43 <pikajude> how is that different from my version
19:18:08 <ertesx> pikajude: it's likely easier to implement, and much easier to implement safely
19:18:30 <ertesx> also i'd expect it to be faster
19:18:44 <pikajude> but it restricts me to STM doesn't it
19:18:50 <ertesx> "restricts"?
19:19:05 <pikajude> so yes?
19:19:11 <pikajude> can't do arbitrary IO in STM
19:19:19 <ertesx> you don't need to
19:19:26 <pikajude> oh. ok
19:19:30 <geekosaur> "restricts me to safety"
19:19:44 <pikajude> almost any situation where i'd want to put a value in a cache, at least where i'm thinking
19:19:51 <pikajude> the value is fetched from a web service or something like that
19:20:01 <pikajude> so
19:20:08 <ertesx> however, you may need an extra variable to close the gap between figuring out that the value is missing, and inserting the Async
19:20:13 <pikajude> in order to save more calls to the web service which might be slo
19:20:15 <pikajude> w
19:20:40 <pikajude> right
19:20:47 <ertesx> a TVar (Set k) to hold all the keys that are currently locked for starting the async operation
19:21:37 <pikajude> hmm, i don't understand at all
19:21:50 <pikajude> mostly because i've never understood how STM could be of any use
19:22:03 <ertesx> to fetch a value, first you check whether it's already there and use 'waitSTM', if it is
19:22:19 <ertesx> if it's not there, then in the same transaction you lock using the second TVar
19:22:42 <ertesx> when that happens, you start the async thread and then remove the lock in a second transaction
19:23:00 <ertesx> (as well as inserting the Async)
19:24:59 <ertesx> be extra careful within that gap, because if an async exception is thrown at the thread, it may never reach the second transaction, keeping the key locked forever…  you can wrap the whole thing in a 'mask' to prevent that
19:28:17 <ertesx> oh, don't use waitSTM
19:28:26 <ertesx> finish the transaction and use 'wait' instead
19:29:10 <ggVGc> ertesx: I looked into the haskell->JS->Lua path yesterday. Found a way, but turns out lua has a restriction of 200 local variables max, and generated JS has more than that
19:29:13 <ggVGc> so failure
19:29:44 <pikajude> finish the transaction?
19:31:10 <pikajude> ertesx, could you write some sample code? i have no idea how to structure this
19:37:09 <ertesx> pikajude: skeleton:  mask $ \unmask -> atomically (Just <$> getAsync <|> Nothing <$ engageLock) >>= maybe (async expensiveAction >>= atomically . insertAndDisengageLock) (unmask . wait)
19:37:59 <pikajude> oh ok
19:38:02 <pikajude> so it's in and out of STM
19:38:36 <ertesx> yeah…  in fact i often use the 'STM (IO A)' pattern
19:38:42 <ertesx> :t join . atomically
19:38:44 <lambdabot> Not in scope: ‘atomically’
19:38:52 <ertesx> :t join . Control.Concurrent.STM.atomically
19:38:53 <lambdabot> GHC.Conc.Sync.STM (IO a) -> IO a
19:39:37 <ertesx> you still need 'mask', but it gets rid of the Maybe
19:41:03 <ertesx> ggVGc: good to know
19:41:32 <Squarism> just love how the required structure of haskell forces one to define what depends on what
19:43:40 <ertesx> pikajude: you may want to handle failure, too…  if expensiveAction throws an exception, it will be rethrown in every thread that tries to read the result
19:45:12 <ertesx> depending on your overall application there are a number of ways to do that:  for example when reading would throw an exception, you could discard the Async and restart a new attempt
19:47:30 <pikajude> wait, isn't Just <$> before getAsync redundant?
19:47:37 <pikajude> shouldn't getAsync be STM (Maybe (Async a))
19:47:47 <pikajude> to represent it not being in the map
19:47:58 <ertesx> since you're going to use M.lookup, yeah, it is redundant
19:48:13 <ertesx> the final 'unmask' seems to be redundant, too:  if 'wait' blocks, it's interruptible anyway
19:48:44 <pikajude> does readTVar make the TVar empty?
19:48:59 <ertesx> TVars can't be empty…  they behave like transactional IORef
19:49:00 <pikajude> oh, no, it's not
19:49:02 <pikajude> TVars can't be empty
19:49:04 <pikajude> ok
19:51:53 <ertesx> you can get some extra speed by choosing an appropriate data structure for your k
19:52:14 <ertesx> IntMap and HashMap will almost always outperform Map
19:52:53 <pikajude> what type would you expect insertAndDisengageLock to have
19:53:08 <ertesx> STM ()
19:53:13 * hackagebot diagrams-core 1.3.0.8 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.8 (BrentYorgey)
19:53:17 <pikajude> right
19:53:19 <pikajude> ok i'll paste
19:54:19 <pikajude> http://lpaste.net/165529
19:54:21 <ertesx> i forgot something: you actually need 'wait' at the end in both cases
19:55:48 <ertesx> engageLock must first check whether it's already locked
19:56:27 <ertesx> S.member k <$> readTVar myKeys >>= check >> modifyTVar' myKeys (S.insert k)
19:56:48 <pikajude> what does check do
19:57:02 <ertesx> check :: Bool -> STM ()  -- retries if False
19:57:44 <pikajude> oh, ok
19:57:46 <pikajude> cool
19:57:50 <ertesx> oh
19:57:57 <ertesx> s/check/check . not/
19:58:02 <Squarism> how do i make add hunit tests to my cabal project? (i guess i need to so i can load it with "cabal repl" 
19:58:13 * hackagebot diagrams-lib 1.3.1.3 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.1.3 (BrentYorgey)
19:58:50 <Squarism> or.. simpler. if i add a Hunit file, how do i execute the tests
19:59:07 <Squarism> ...a module with hunit dependency that is
19:59:39 <ertesx> pikajude: and as said, you need to wait in both cases
20:00:04 <pikajude> oh ok
20:00:31 <ertesx> (>>= maybe (async expensiveAction >>= \var -> atomically (insertAndDisengageLock var) >> wait var) wait)
20:01:29 <ertesx> or:
20:01:54 <pikajude> so atomically is never needed
20:02:02 <ertesx> >>= maybe (async expensiveAction >>= \var -> var <$ atomically (insertAndDisengageLock var)) pure >>= wait
20:02:09 <ertesx> it is needed
20:02:25 <ertesx> the thing that isn't needed is 'unmask'
20:02:43 <pikajude> ok
20:03:11 <ertesx> it's just getting messy to type everything into one IRC line =)
20:18:13 * hackagebot network 2.3.2.1 - Low-level networking interface  https://hackage.haskell.org/package/network-2.3.2.1 (dukerutledge)
20:50:15 <pikajude> ertesx: other than that, does my code look sensible
20:58:40 <echosystm> can anyone provide examples of apps that would be more suited to functional languages?
20:58:54 <echosystm> i've done a bit of research, but i don't really understand it
20:59:31 <echosystm> i'm interested in learning haskell but i'm struggling to find a hobby project to use it for
20:59:52 <mjrosenb> echosystm: any hobby project can be done in haskell
21:00:13 <mjrosenb> I'm currently building a cheap ripoff of xbmc.
21:00:27 <Koterpillar> haskell is very much a general purpose language; you don't have to limit yourself to some special areas
21:01:41 <echosystm> if you had to learn just one FP language and wanted to get maximum real world benefit from it, do you think haskell would be a good choice?
21:02:07 <echosystm> i'm not really interested in clojure and other such languages, because they're not strictly FP and i feel like i might as well just use rust or something else
21:02:25 <Koterpillar> yes, but I think the premise of question is flawed; why do you have to learn just one over learning bits of many?
21:02:44 <mjrosenb> #haskell may also be biased :-p
21:16:31 <nitrix> I'm personally working on a video game. It's 2D but I've seen some projects doing 3D as well. Gamedev isn't the most popular niche for Haskellers, but we're still a few.
21:17:26 <Koterpillar> I have a text game, a blog engine (everyone has a blog engine), a desktop (GTK... eww) application
21:17:48 <nitrix> It seems strange to me to approach a language by already imposing yourself arbitrary limits.
21:18:15 * hackagebot timemap 0.0.3 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.3 (athanclark)
21:18:21 <nitrix> "Java is too slow", and yet, Minecraft was a huge success.
21:19:10 <Revenarus> what does that have to do with self-imposing limits
21:19:52 <nitrix> Revenarus: You just joined the channel; you're missing a large chunk of the context I suppose.
21:20:09 <Revenarus> indeed
21:20:24 <Revenarus>    /msg NickServ VERIFY REGISTER Revenarus jwrkfwxculij
21:20:41 <benzrf> oops
21:20:45 <nitrix> Ah. One of those.
21:20:52 <Koterpillar> nice generated password though
21:20:59 <benzrf> no thats verify
21:21:03 <geekosaur> nd I thought I was having a bad night
21:21:04 <benzrf> you dont have control over it
21:21:06 <glguy> Fortunately I don't think that the email verification code is an important secret
21:21:18 <benzrf> echosystm: just learn haskell
21:21:19 <benzrf> it's fun~
21:21:41 <nitrix> 3 spaces?! Who indent with 3 spaces :P
21:21:57 <benzrf> maniacs
21:22:13 <benzrf> odd numbers are the sign of the devil
21:22:34 <glguy> My IRC client has syntax highlighting for / commands so that I know it's been recognized before I submit
21:46:39 <ggVGc> I'd just like to say, this is my favourite programming channel since I started using IRC 10 years ago
21:52:30 <dramforever> I played with unification for a bit, and this is what I got http://lpaste.net/165438 .
21:53:02 <dramforever> 1. It has a generic interface (You just define a functor F, and your AST would be Fix F, and your AST with variables would be Free F Var)
21:53:56 <dramforever> 2. It supports GHC.Generics (So you don't need to write instances to match structures manually (but you can anyway))
21:54:04 <dramforever> 3. It supports generic error messages
21:54:35 <dramforever> TODO: Comments :(
22:25:25 <lyndon1> Hey Haskellers, Is there a text-zipper that is efficient on single lines of text? 'text-zipper' seems to be more intended for an editor or something similar, but I'm just looking for a zipper that would serve well as a structure for generating intermediate levenstein edits.
22:40:38 <jle`> lyndon1: what kind of operations are you planning on?
22:53:20 * hackagebot pipes-key-value-csv 0.3.0.0 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.3.0.0 (mjmrotek)
23:02:30 <lyndon1> jle`: I'm looking to move forward, back, insert, delete, and substitute.
23:08:20 * hackagebot purescript-bridge 0.6.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.6.0.0 (eskimo)
23:08:22 * hackagebot pipes-key-value-csv 0.4.0.0 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.4.0.0 (mjmrotek)
23:13:35 <begriffs> While building the hackage-security package I'm getting a segfault in the linker. I've never seen a build error like this before, anyone familiar with it? collect2: error: ld terminated with signal 11
23:23:54 <Robert_Wiley> zeroed: do you mind if I pm you?
23:28:51 <lyndon1> begriffs: I think I've seen that when I've missed specifying a extra source module in my cabal file... Could be wrong though.
