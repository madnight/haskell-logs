00:00:39 <Axman6> you'd only get concurrency if you implemented it by hand anyway
00:08:25 * hackagebot vectortiles 1.0.0 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.0.0 (fosskers)
00:18:26 * hackagebot reactivity 0.3.2.3 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.2.3 (JamesCandy)
00:49:30 <gabbiel> @src foldM
00:49:30 <lambdabot> foldM _ a []     = return a
00:49:30 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
01:03:27 * hackagebot type-list 0.5.0.0 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.5.0.0 (mjmrotek)
01:48:29 * hackagebot hmatrix-svdlibc 0.4.0 - SVDLIBC bindings for HMatrix  https://hackage.haskell.org/package/hmatrix-svdlibc-0.4.0 (BenGamari)
02:02:15 <reqq456> would there be any difference between these two map functions? map f xs = [f x | x <- xs] // map f (x:xs) = f x : map f xs  
02:02:52 <merijn> reqq456: Functionally? No. Operationally? I'm not 100% sure, but not a lot
02:04:09 <shachaf> reqq456: Yes, the second one fails on finite lists.
02:05:15 <reqq456> there would be an edge case of course shachaf map _ [] = []
02:11:15 <reqq456> and is it possible to use ghci via vim? i mean like i press a button and it calls ':w:!ghci file' without exiting ghci instant? if I do it like this I get this: http://pastebin.com/xqc7Cvj7 -- vim is instant leaving ghci
02:11:56 <jm_c_> reqq456: I suggest tmux + slimux
02:11:57 <merijn> reqq456: I just use tmux to have multiple split-screen terminals and have vim on one side, ghci on the other
02:12:23 <jm_c_> reqq456: then hit a button, and send the line (or visual selection) to the other tmux pane
02:12:55 <jm_c_> reqq456: It automatically generalises to other interpreters...
02:15:37 <potatoe> stack on my linux box segfaults pretty frequently, is there a dedicated stack support chan:?
02:15:48 <potatoe> oh there is
02:22:28 <W4RH4WK> hey, i want to add some type constraints to a data definition (using gadts) but i encountered a strange issue when also using record syntax: https://gist.github.com/W4RH4WK/e9303a60a2b54c6e040d75896c15920a
02:23:29 <W4RH4WK> when using line 20 instead of 17, the type checker complains that there is no instance for (Integral c) regarding Factor
02:23:30 * hackagebot phone-metadata 0.0.1.4 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.4 (vijayanant)
02:23:35 <merijn> W4RH4WK: You need to pattern match to bring GADT constraints/refinement into scope
02:25:18 <W4RH4WK> merijn, okay, is there another workaround, just want to have 'c' being always an Integral in Factor, so i don't have to add that type constraint to _all_ functions taking a Factor
02:25:45 <merijn> W4RH4WK: The solution is to suck it up an add the constraint
02:26:03 <merijn> W4RH4WK: Also, why do ALL functions taking a factor need that constraint?
02:26:21 <merijn> W4RH4WK: Should be only the ones using Integral functions?
02:27:05 <W4RH4WK> thats basically all of the functions in that module right now, but you are right, Integral is obsolete for a prettyShow (for instance)
02:27:30 <W4RH4WK> nevertheless i don't really want an instance of Factor to exists where 'c' is not an integral
02:27:59 <merijn> W4RH4WK: You can't (sanely) avoid constraints on functions
02:28:24 <W4RH4WK> well then i have to suck it up ^^ thanks
02:28:27 <merijn> W4RH4WK: Don't export the constructor and add a smart constructor "mkFactor :: Integral c => c -> Factor c" (or whatever)
02:28:39 <merijn> W4RH4WK: Although I would recommend against that too
02:29:02 <merijn> For example, consider the fact that "Data.Set.singleton :: a -> Set a" despite most Set functions requiring Ord
02:29:11 <merijn> Because, why wouldn't you allow that?
02:29:47 <W4RH4WK> good point,
02:31:35 <potatoe> if anyone has encountered segfaults in stack, any idea what maybe happening here?
02:31:36 <potatoe> https://gist.github.com/spaghetti-/3dfe6dca87f19c19ccc4d76700c96fbc
02:31:55 <potatoe> other than the --verbose I'm not sure of how to generate even more verbose lossing
02:31:58 <potatoe> logging*
02:42:30 <ik`> hi, I'm was trying to run the examples from the sdl2 haskell bindings, but as soon as I put a loop in my code I get an exception from SDL http://lpaste.net/167077. The example is here: https://github.com/haskell-game/sdl2/blob/master/examples/lazyfoo/Lesson03.hs . Sometimes it works, sometimes I get the exception, and it only manifests itself when there is a loop in the main function. What could this problem be related to?
02:44:20 <muzzle\> what are algebraic datatypes actually written to RAM as (something like data Color = Red | Blue | Green)
02:44:22 <muzzle\> ?
02:44:29 <merijn> muzzle\: Unspecified
02:45:00 <muzzle\> I'm just interested for a rough estimate of memory use
02:45:00 <merijn> GHC is allowed to, and afaik DOES, use different representations for different datatypes
02:45:44 <merijn> muzzle\: Rough estimate: 1 word per constructor, 1 word per argument?
02:45:45 <muzzle\> if i have an algebraic datatype with ~ 20 alternatives in a list of about 10 milllion elements what would that approximately be ?
02:46:12 <muzzle\> so one word for the cons cell and one word for the datatype?
02:46:31 <muzzle\> merijn probably two for the cons cell
02:46:33 <merijn> Cons cell is 1 word for the cell, 1 word for the head, 1 word for the tail
02:47:00 <merijn> muzzle\: Keep in mind that lists are lazy, so if you're generating the list it's effectively streamed through memory
02:47:21 <muzzle\> merijn in my case I need to keep all of it in memory
02:47:43 <muzzle\> merijn i'm using it to implement a (somewhat) compressed large trie
03:01:49 <puregreen> muzzle\: you could try the weigh package if you want more precise estimates: https://github.com/fpco/weigh/blob/master/src/test/Maps.hs, https://www.fpcomplete.com/blog/2016/05/weigh-package
03:02:43 <HaskellCat> Hey ! I want to experiment with writing a kind of console with haskell and I ran into a small problem. I want to be able to "remember" old commands, so I tried using a list and adding elements, but anytime I try to access them it gets stuck. Any idea why? example code is here: http://lpaste.net/1448848436383186944
03:03:56 <muzzle\> HaskellCat the funcs list is infinitely long
03:04:09 <muzzle\> when you try to calculate its length it will therefore take forever
03:04:46 <HaskellCat> Why is it infinitely long? I mean, I only add one element at a time. I understand why it's not bounded, but when I ask for it's length can it stop after it finishes?
03:05:11 <muzzle\> let funcs = 1:funcs
03:05:15 <muzzle\> is an infinite list
03:05:29 <muzzle\> what you want to do is pass funcs as an argument to loop
03:05:30 <liste> > let funcs = 1:funcs in funcs
03:05:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:05:48 <HaskellCat> oh, I think I get it
03:05:51 <muzzle\> and do loop $ 1:funcs in the recursive call
03:06:11 <muzzle\> by using the let binding you aren't prepending to funcs
03:06:19 <muzzle\> instead you are overshadowing it by using let
03:06:32 <muzzle\> remember, stuff is generally immutable in haskell
03:07:36 <HaskellCat> It's working now :) Thanks for clarifying it for me!
03:18:00 <gio> \join english
03:30:16 <itnex> wow it really makes you think
03:39:05 <HaskellCat> Hey, another question: I've tried to work with some existing untyped lambda parser. I'm trying to convert existing function such that it will return another parameter I could add to my list, but anything I try doesn't work. I've tried declaring a new datatype and returning it instead of IO but couldn't use return. Any tips on what to do? http://lpaste.net/4289330606690533376
03:39:38 <HaskellCat> (Aiming for "process" to return an extra value)
03:41:43 <liste> HaskellCat: so "process :: String -> IO ExtraValue" ?
03:41:57 <HaskellCat> liste: Yep
03:42:19 <Xandaros> If you have a pure value that you want to return, you can use `pure` to add the IO bit
03:42:34 <liste> (or `return')
03:42:36 <HaskellCat> Tried declaring "data Result = Result IO String" but it kept erroring on the loop itself
03:43:16 <liste> HaskellCat: so you want to return a String?
03:43:25 <HaskellCat> liste: that would suffice, yes
03:43:29 <liste> then the result type should be "String -> IO String"
03:43:39 <liste> type of `process' *
03:43:43 <HaskellCat> why not String -> String?
03:43:47 <liste> so "process :: String -> IO String"
03:43:54 <liste> HaskellCat: because `process' does IO
03:45:00 <HaskellCat> liste: so I tried this: http://lpaste.net/8005551218468323328
03:46:57 <HaskellCat> (by the way - thanks for helping me)
03:47:45 <HaskellCat> sorry, a tab has slipped: here's the correct one: http://lpaste.net/5146016070724747264
03:53:41 <liste> HaskellCat: that's the right direction
03:53:50 <HaskellCat> yeh, I think I'm on it
03:54:03 <Xandaros> HaskellCat: You seem to still be mixing tabs and spaces. That's just waiting to blow up in your face, you may want to configure your editor to avoid this :)
03:54:32 <HaskellCat> Any recommended haskell editor beginners? currently using notepad++
03:54:45 <HaskellCat> Tried Leksah but it was too complicated for me =[
03:55:01 <Xandaros> I heard Atom is supposed to be pretty good
03:55:12 <Xandaros> Never used it myself, though
03:55:40 <Xandaros> Pretty sure notepad++ can do automatic tab->space conversion, though
03:56:19 <HaskellCat> You're right, changed the settings now
03:57:45 <HaskellCat> (In Settings->Preferences->Tab settings if anyone wonders)
03:58:17 <HaskellCat> Now I think I'm almost there. but I can't seem to figure out why it errors for me here: http://lpaste.net/1138447460524359680
03:58:31 <HaskellCat> Line 38: parse error on input `<-'
03:58:33 * hackagebot abnf 0.4.0.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.4.0.0 (Xandaros)
03:59:10 <Xandaros> indentation
03:59:21 <Xandaros> That line is part of the case, not part of the do
03:59:59 <HaskellCat> oh right
04:00:28 <Xandaros> Lines 20 and 21 still have tabs, btw :P
04:01:43 <HaskellCat> Fixed :) Do I need to use "let str = process input" or "str <- process input"?
04:02:27 <Xandaros> Try both, see which one works and then tell me why :P
04:03:07 <HaskellCat> Actually I did that before, and the let works, but I'm not sure why, because process does IO
04:04:24 <Xandaros> Err... it shouldn't
04:05:14 <unexisting> Has anyone here used Haskell in bioinformatics?
04:06:08 <HaskellCat> Xandaros: " let str = process input" works and as far as I can tell str's type is IO String
04:06:14 <Xandaros> Hackage takes far too long to delete documentation. Accidentally uploaded outdated docs and had to wait like 5 minutes for them to get deleted. (I could probably just replace them, but that seemed to take similarly long :/)
04:06:16 <nmattia> unexisting: I've used it to model DNA strands
04:06:35 <Xandaros> HaskellCat: Yes, str is of type IO String in that case. You shouldn't be able to use it like a normal string
04:09:28 <unexisting> nmattia: sorry, what does "to model" mean in this context?
04:11:43 <HaskellCat> Xandaros: yeh, so I understand I need to use the <- operand here, but it keeps saying "Couldn't match expected type `InputT m String' with actual type `IO String'"
04:11:58 <nmattia> unexisting: I was trying to model strand interactions, purely from theoretical level, so it didn't account for much of the bio stuff: http://www.tik.ee.ethz.ch/file/6681257c247653e21d8c316e5370285f/ISAAC2015-dna.pdf
04:12:26 <HaskellCat> which is weird because it is supposed to expect IO String
04:12:52 <Xandaros> :t outputStrLn
04:12:53 <unexisting> nmattia: wow, interesting, thanks
04:12:53 <lambdabot>     Not in scope: ‘outputStrLn’
04:12:53 <lambdabot>     Perhaps you meant one of these:
04:12:53 <lambdabot>       ‘putStrLn’ (imported from Prelude),
04:13:01 <nmattia> we didn't release the code, but it wasn't anything too crazy. it was mostly matching different String s together, but quickcheck turned out to help a lot for the testing of results and generation
04:13:06 <Xandaros> HaskellCat: outputStrLn :: MonadIO m => String -> InputT m ()
04:13:07 <nmattia> might not be your use case though
04:13:34 <Xandaros> HaskellCat: So, it returns an InputT monad transformer, but you're using it like IO. I suggest simply using putStrLn for now
04:14:34 <Xandaros> HaskellCat: Later on, you can use the InputT thingy and run it with runInputT, which takes a Settings and your InputT and turns it into the base monad. (IO in this case)
04:14:56 <unexisting> nmattia: I have a thought to use it instead of Python for scripting some stuff. Need some usual things to parse fastq etc., but the bioinformatics section on Hackage seems to be a scattered mess :(
04:15:25 <Xandaros> HaskellCat: See also the example at the top of the Haskeline documentation: http://hackage.haskell.org/package/haskeline-0.7.2.3/docs/System-Console-Haskeline.html
04:17:44 <nmattia> unexisting: well, Haskell is the nicest language if you "have" to write a parser :)
04:19:00 <nmattia> unexisting: just found an old repo with a first draft in Java, but that quickly became a mess. If you're just interested in "DNA is a chain of A, C, T, G" then Haskell is amazing; if you actually have to fit in some real parameters you'll probably need bindings to existing tools...
04:20:41 <Xandaros> Is there some combinator I'm missing to turn a List into an Either? Something like `a -> [b] -> Either a b`. Alternatively, the same thing with a Maybe (I'll use listToMaybe in that case)
04:20:52 <Xandaros> Hoogle claims there is no such thing, but I don't trust it
04:23:26 <HaskellCat> Xandaros: What do you mean by using putStrLn for now? can't I use something like liftIO instead?
04:24:16 <Xandaros> HaskellCat: You need to go back to IO at some point - the type of `main` is `IO ()`. Lifting it further away is not going to help you, you need to run it to go down a level
04:25:31 <HaskellCat> Haskell is really hard to grasp =[
04:25:38 <maerwald> Xandaros: https://hackage.haskell.org/package/data-easy-0.6.1/docs/Data-Easy.html#v:listToEither
04:25:57 <mniip> HaskellCat, doesn't that just make it more interesting?
04:26:57 <Xandaros> maerwald: Hmm, interesting. I actually just found errors, which seems to be a bit better suited for this, though
04:27:27 <Xandaros> I should get into the habit of also trying the hoogle on stackage. It seems to search a lot more packages
04:27:41 <maerwald> I used http://hayoo.fh-wedel.de/
04:27:58 <tdammers> HaskellCat: hard to grasp? No, but if you have a background in some other proglang, some things you may have learned there will make Haskell more confusing
04:28:06 <tdammers> some un-learning is required
04:29:43 <HaskellCat> it does make it more interesting, but really frustrating. I know languages like Python, Java, JavaScript, C/++ and they are all kind-of similar to each other, Haskell requires a different kind of thinking to get things done
04:31:30 <bjs> HaskellCat: it only feels hard to grasp because you're used to imperative thinking
04:32:24 <bjs> HaskellCat: and like with everyone else, i'm sure when you started with your Java, C/C++ you also found that hard to grasp too
04:32:25 <Xandaros> HaskellCat: Don't worry - most of us have been there :)
04:32:27 <bjs> so it just takes time :)
04:32:40 <blank101010> \join #haskell
04:33:01 <HaskellCat> I hope I won't give up before I'll pass that wall
04:33:46 <bjs> HaskellCat: if you've learned other languages and managed to overcome the problem of thinking imperatively, there's no reason you can't pass this wall of thinking functionally
04:34:15 <tdammers> I would argue that for many things, functional thinking is easier than imperative thinking
04:34:27 <tdammers> (once you have comparable fluency in both)
04:34:32 <Xandaros> It is, but it takes some getting used to
04:34:35 <tdammers> yes
04:34:40 <tdammers> both take getting used to
04:35:01 <Xandaros> I dearly miss my map when I use imperative languages :/
04:35:30 <airmac> 	https://www.eobot.com/new.aspx?referid=208540
04:35:31 <airmac> 	https://www.eobot.com/new.aspx?referid=208540
04:35:31 <airmac> 	https://www.eobot.com/new.aspx?referid=208540
04:36:38 <bjs> Xandaros: well luckily for you most of them now have something called map and it even works sometimes
04:37:00 <Xandaros> True, it's slowly getting adopted
04:38:19 <maerwald> rust's map is even lazy
04:40:26 <tdammers> I miss effortless currying/partial application
04:40:34 <tdammers> in pretty much everything
04:40:45 <tdammers> also, type-driven development in general
04:41:00 <maerwald> java has type-driven development even
04:43:46 <hpc> java has the purest form of type-driven development
04:44:07 <hpc> every file is a new type
04:44:30 <cow_2001> hpc is my type of troll <3
04:49:34 <tdammers> it's not a matter of "has", but one of "makes feasible"
04:50:08 <maerwald> that's highly subjective I'd say
04:55:26 <tdammers> yes, it is
04:55:39 <tdammers> still a more useful property than whether it is possible at all
04:55:51 <maerwald> I don't think it's a property at all
04:56:01 <tdammers> probably not, no
05:06:02 <Xandaros> “Docs uploaded by user”, yet no docs :(
05:06:26 <hpc> you're the user
05:06:29 <hpc> get uploading those docs, fool
05:06:45 <hpc> if you're not sure about something, just make it up
05:06:47 <Xandaros> I did upload them, that's the thing
05:06:52 <hpc> oh, lol
05:11:26 <Xandaros> Hmm, looks like it did indeed not build the docs. Just the source-view
05:23:36 * hackagebot inline-r 0.9.0.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.9.0.0 (MathieuBoespflug)
05:23:38 * hackagebot H 0.9.0.0 - The Haskell/R mixed programming environment.  https://hackage.haskell.org/package/H-0.9.0.0 (MathieuBoespflug)
05:33:22 <deni> I never thought I'd say this in a million years but I'm getting sick of Vim...support for haskell is virtually non-existent
05:33:56 <deni> which isn't the editors fault per say......but still it's borderline unusable compared to emacs (from what I hear)
05:35:31 <Xandaros> Yeah, the tooling isn't exactly the best when it comes to vim. But you get to use vim, which for me outweighs the tooling benefits emacs has
05:36:25 <maerwald> deni: good luck with getting even basic functionality going in emacs without 200 lines of lisp hacks
05:36:57 <maerwald> you'll probably end up using spacemacs which can be described as "I hope nothing breaks, because I have no clue how any of that works"
05:37:11 <maerwald> and then it breaks...
05:37:50 <maerwald> both vim and emacs are annoying for getting proper haskell support, in different ways though
05:38:08 <maerwald> pick your devil
05:38:28 <coppro> Zemyla: I'm not sure ap would still exist, defined as such, if Monad were completely rewritten. Maybe it would.
05:38:37 <ent> 200 lines? I think I have ~20. not ideal but still
05:39:13 <bergmark> setting up intero with emacs was super easy
05:39:17 <maerwald> ent: fixing line numbers properly (e.g. not breaking on font scaling, frame scaling and whatnot) is about 200 loc
05:39:21 <sooheon> I just looked at my my init.el--1427 lines
05:39:31 <maerwald> where in vim line numbers just always work
05:39:35 <Xandaros> intero was pretty nice. There's a neovim version, too
05:39:40 <coppro> Zemyla: but the current design certainly was no deliberate decision. It long predates the FAM propsal.
05:40:01 <deni> Xandaros: people i know swear by evil mode.... (previous vim users...so I thought giving that a try)
05:40:01 <ent> maerwald: line numbers? like linum-mode?
05:40:06 <maerwald> yes
05:40:12 <maerwald> which is also broken
05:40:16 <deni> maerwald: yaeah I was going to use spacemacs....and hope it doesn't break...
05:40:17 <Xandaros> deni: I tried evil mode for a month or so. It was… alright
05:40:26 <deni> maerwald: but then again I use a bunch of vim plugins that break all the time
05:40:29 <ent> yeah, linum isn't nice. I don't use it for that reason :P
05:40:32 <maerwald> then there is nlinum-mode, but it's also broken
05:40:45 <maerwald> then there are random lisp pastes you can use
05:40:56 <deni> maerwald: evil mode is broken how?
05:41:18 <maerwald> I didn't talk about evil mode (yet)
05:41:40 <deni> (btw I don't know if this conversation is considered spamming in this channel....I don't want to start a holy editor war just want stuff to work so I can write haskell)
05:41:46 <maerwald> but if you are comfortable with ~2000 key bindings (I think that's about the correct number) in default emacs... have at it
05:41:57 <maerwald> s/emacs/spacemacs/
05:42:15 <tdammers> vanilla vim works pretty well for me
05:42:17 <maerwald> and there's a stack of overwritten key bindings and reverse-fixing plugins
05:42:28 <ent> but yeah, if we were talking about emacs configurations and not just the haskell specific ones then 200 won't be enough :P
05:43:05 <Xandaros> I use a fairly plain vim, as well. (As-in barely any haskell related plugins) That's mostly because I'm using GHC 8, though
05:43:09 <Xandaros> It works
05:43:17 <deni> tdammers: most of the time for me to... I might have exagerated about using a lot of plugins..most of them do simple things and just work...it's the completion that's killing me. Any ghci/ghc-mod integration really
05:43:38 <tdammers> well, I prefer the dumb textual default completion that comes with vim
05:43:44 <deni> Xandaros: what does ghc8 have to do with it? (I'm not familiar with the changes)
05:44:09 <Xandaros> deni: Stuff like ghc-mod doesn't work with it yet
05:44:14 <tdammers> I'm considering doing something to make managing imports easier, but other than that, I'm not really missing anything
05:44:22 <maerwald> Xandaros: weird, why does it work for me then
05:44:38 <maerwald> https://github.com/DanielG/ghc-mod/tree/ghc-8
05:44:39 <Xandaros> Maybe it works now? Haven't checked in a while
05:45:17 <maerwald> right, I built the ghc-8 branch myself, which works
05:45:25 <maerwald> no release there yet I think
05:45:38 <deni> tdammers: I mostly want auto completion and stuff like find me where this function is coming from .... I mean I can (and do) use external tooling but it would be great if I could get that stuff from my editor
05:46:02 <deni> I don't want a full fledged IDE ... but closer to that rather than further
05:46:09 <maerwald> leksah can do all that, unfortunately its text editor just sucks
05:46:31 <deni> maerwald: yeah that's what I was afraid of
05:46:44 <deni> I want vim key bindings and word manipulation
05:46:51 <maerwald> it has an option to build it against yi... which would be pretty cool, but guess what... it doesn't build
05:47:10 <Xandaros> So… I upload documentation for 0.4.0.0, but it is clearly outdated. Lots of weird things happening… But - the local build is just fine. What is going on here?
05:47:14 <Xandaros> This is infuriating
05:47:42 <Xandaros> What are thos ‘#’? https://hackage.haskell.org/package/abnf-0.4.0.0/docs/Text-ABNF-Document-Operations.html
05:47:45 <Xandaros> *those
05:48:01 <coppro> hackage has seemd to get worse and worse at managing docs :(
05:48:45 <srhb> Xandaros: Hard to say, hackage appears to be down :-P
05:48:52 <Xandaros> The source buttons also don't appear to work for some of my packages
05:49:04 <Xandaros> srhb: Not for me
05:49:16 <srhb> Curious.
05:49:28 <deni> yeah I build everything locally and use scripts to search the local docs.... last few weeks none of the docs I looked up on hackage were built
05:50:32 <Xandaros> So, the Document data type is clearly outdated and clicking source ends in a 404. If I open the source for another package and follow a link there, it gets me the source and it's the correct version, too.
05:51:09 <coppro> the source links don't 404 for me
05:51:22 <Xandaros> coppro: Try in Data.ABNF.Document
05:52:00 <maerwald> deni: haha, which is why I push my docs to github pages too
05:52:11 <maerwald> (on CI travis build)
05:54:55 <coppro> Xandaros: oh, yeah, I see it now
05:55:00 <coppro> that looks more like a haddock bug?
05:55:12 <Xandaros> The funny thing is, locally it seems fine
05:55:59 <Xandaros> If I open doc-index.html and open up Text.ABNF.Document, I get the new Document type (I removed Content and turned Document into a proper tree)
05:56:02 <coppro> the issues is hyphens vs periods in the url
05:56:09 <Xandaros> So I have no clue why this doesn't appear on hackage
05:56:24 <coppro> who runs hackage?
06:00:09 <Xandaros> Here's another funny thing: The ‘contents’ button at the top redirects me to 0.3.1 in Text.ABNF.Document
06:00:43 <coppro> lol
06:00:45 <coppro> gg
06:16:29 <tdammers> deni: for "where is this function coming from", my current remedy is to just follow some import best-practices
06:16:49 <tdammers> i.e., use either qualified imports or explicit lists of identifiers to import
06:17:08 <tdammers> import Data.Text (pack) -- means that 'pack' comes from Data.Text
06:17:25 <tdammers> import qualified Data.Text as Text -- means that when I want to use 'pack', I need to write it as Text.pack
06:17:30 <tdammers> either way is explicit
06:17:52 <tdammers> but if I were to just import Data.Text, then I would have to know that that module exports 'pack'
06:17:57 <tdammers> so I avoid that
06:18:39 <maerwald> tdammers: that only works for your own project
06:23:44 <tdammers> maerwald: correct
06:24:14 <tdammers> maerwald: but code that isn't my own isn't something I am usually deeply involved with
06:24:21 <tdammers> it's either mine, or my team's
06:24:27 <maerwald> also, it's rather an annoying thing to do if you use e.g. the Gtk framework where you'd basically end up with 1000 LOC imports
06:24:53 <tdammers> I said "avoid"; it's a rule I do sometimes bend
06:25:20 <tdammers> e.g. when I'm writing a parser module, then I sometimes import Parsec or whatever unqualified, with the implicit assumption that all of Parsec is in scope
06:25:22 <Xandaros> http://tcp.mniip.com/u4_o - It's trolling me, isn't it?
06:25:47 <tdammers> Xandaros: learn2stack :(
06:25:52 <Xandaros> No.
06:26:02 <tdammers> seriously, have you given it a shot?
06:26:14 <Xandaros> I've tried it and couldn't get it to work
06:26:17 <Xandaros> cabal works
06:26:20 <tdammers> strange
06:27:12 <tdammers> I've tried stack on OS X, debian/x64 (using the deb source), debian/x86 (installing through cabal), and they all worked pretty much out of the box, no manual effort required
06:27:40 <tdammers> and it's not like stack replaces cabal; it sits on top of it
06:29:03 <Xandaros> That's another thing about stack - it seems to not solve any problems for me. It provides stable packages, but I couldn't care less. It solves “cabal hell”, but as far as I'm concerned, that's something cabal should fix (and they're doing it - cabal new-build works amazingly)
06:29:11 <bergmark> stack is easier to use if you stick with packages in the snapshot, or if dependency resolution works and you just need to add packages. If there are version conflicts I think cabal-install gives better output
06:30:56 <maerwald> Xandaros: I think stack is misused for development where it's really just a deployment tool. People should always run the latest stackage state when they develop, especially to have correct dependency version bounds.
06:31:02 <tdammers> I also like stack for testing my stuff against multiple GHC's
06:31:33 <maerwald> tdammers: I use travis for that
06:31:51 <deni> tdammers: I use that for my code...but if I'm looking at somebody else's code or at some examples that don't follow this practice (or don't list imports at all) I like to be able to find this quickly
06:32:02 <tdammers> maerwald: that, too, but sorting things out when the builds fail is easier when you can just switch GHC versions on the fly on your dev setup
06:32:13 <tdammers> deni: fair point
06:32:20 <Xandaros> How would you even do something like add-source with stack?
06:32:48 <bergmark> Xandaros: you can add a folder/archive/url/commit hash to the extra-dep section
06:32:57 <Xandaros> ah, alright
06:33:26 <Xandaros> Ah, that's another thing I don't like about stack: I need to keep two files describing my project, with some redundant data like dependencies
06:33:31 <Xandaros> And these resolvers or w/e
06:33:49 <quxbam> Is it possible to do the inverse of a constraint? Like  foo :: Not Num a => [a] -> a
06:34:21 <tdammers> Xandaros: the two-file thing is the price you pay for having a tool on top of cabal without breaking cabal itself
06:34:29 <tdammers> Xandaros: I don't see any other way to do this
06:34:38 <nmattia> quxbam: what's the use case?
06:34:46 <nmattia> quxbam: (I'm intrigued)
06:35:59 <quxbam> nmattia: I want to build a restricted monad, which allows only operations which are explicitely declared via constraints but some are mutually exclusive
06:37:38 <nmattia> quxbam: let me know if you find out :)
06:38:49 <quxbam> Perhaps I should just implement as well the functions which are excluded from a class in the same class with some impossible type, so the compiler would complain
06:40:04 <tero-_> quxbam: could you have default instance for all types to encode negation and then an overlapping instance to remove the negation?
06:43:01 <quxbam> tero-_: I may not understand you correctly, but this implies a *lot* of instances, no?
06:44:57 <quxbam> I'll experiment and report back later
06:44:57 <tero-_> quxbam: I'll experiment a bit. maybe I can express the idea in code :)
06:45:07 <quxbam> :)
06:48:39 * hackagebot abnf 0.4.1.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.4.1.0 (Xandaros)
06:55:13 <bsermons> is there a way to tell persistent to use snake case instead of camel case for it's json encoding?
06:57:42 <ironChicken> in cabal, if i create a sandbox, and some package is is a dependency only of a test-suite, does `cabal install --only-dependencies` install it?
06:58:06 <dcoutts> ironChicken: only if you --enable-testsuites
06:58:23 * dcoutts notes that the new cabal-1.24 replacement for sandboxes handles this nicer
06:58:28 <ironChicken> is that the same as --enable-tests
06:58:30 <ironChicken> ?
06:58:47 <dcoutts> oh, sorry, yes I'm probably just mis-remembering the flag name
06:59:10 <ironChicken> hmm, it doesn't seem to. i mean, i did that already
06:59:18 <Xandaros> coppro: Uploaded docs for 0.4.1 and they seem to work fine. I did nothing differently. Ah, well. Docs for an outdated version of a package that nobody uses are messed up/wrong. I can live with that :D
07:02:37 <synergistics> Is there any way to pattern match on [1,2] and [2,1] at the same time, pattern matching on what a list contains regardless of the order the items are in?
07:03:14 <bergmark> synergistics: you probably want a set, and then pattern synonyms
07:03:33 <bergmark> or use a view pattern: (sort -> [1,2])
07:03:53 <synergistics> Oh, never heard of those
07:04:23 <synergistics> So basically its matching on the result of sorting whatever the thing was to start with?
07:06:45 <dcoutts> ironChicken: cabal install --only-dependencies --enable-tests
07:07:00 <dcoutts> ironChicken: then, cabal configure --enable-tests
07:07:04 <bergmark> synergistics: right
07:07:21 <synergistics> bergmark: Alright
07:07:52 * dcoutts notes that in cabal-1.24 you can just "cabal new-build $the-test" and it'll build deps including any test suite deps needed
07:21:01 <deni> anybody using snaplet-persistent here?
07:22:00 <tero-_> quxbam: http://lpaste.net/5883824480752500736 that's the best I could come up with
07:22:58 <tero-_> quxbam: but it's not really negating the class constraint. just enumerating the positive cases and then making the rest false using a closed type family
07:23:40 * hackagebot yesod-ip 0.4.1 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.4.1 (andrewthad)
07:30:42 <ironChicken> dcoutts: thanks
07:33:41 * hackagebot yesod-core 1.4.21 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.21 (MichaelSnoyman)
07:43:41 * hackagebot smsaero 0.6 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.6 (NickolayKudasov)
07:46:28 <Squarism> yesterday i ended up never ending "cabal reinstall world" (to add profiling capabilities to my installation). My one and only project had only 7 dependencies, but ive now manually reinstalled tons of dependencies. 
07:47:06 <ics> I'm attempting to extract pieces of type signatures using Template Haskell, with two obstacles: I can't (or don't know how to) pattern match on names (e.g. ForeignPtr, ''ForeignPtr, GHC.Ptr.ForeignPtr, etc.) and Type doesn't seem to have F/T instances
07:47:33 <geekosaur> Squarism, one of those dependencies was lens
07:47:43 <geekosaur> which puulled in like half the ecosystem :/
07:47:45 <Squarism> Searching the internet it feels as if this is a common problem with cabal. So i wonder, what do people do when their cabal libraries goes fubar? Do you wipe some folder and start from scratch? 
07:48:02 <ics> Was looking at the CIS194 notes on TH which use map/foldl but I can't get them to work here
07:48:09 <Squarism> geekosaur, ah okej
07:48:38 <mauke> in those situations, I leave haskell for a few weeks and go back to perl
07:48:47 <ics> What I want: to take `foo :: T (a -> b) -> c` and get `T (a -> b)` out
07:48:49 <Squarism> geekosaur, but it feels like only having 8 dependencies, id be better of just starting from scratch. I wonder how can i start from scratch wo removing the platform so to speak?
07:48:52 <geekosaur> the big problem is you weren't just building prof libraries, it was also trying to upgrade everything at the same time. which is rarely a great idea, but also hard to stop without doing things in a very targeted way (and then having to go through it again with the next project)
07:48:58 <ics> Any tips?
07:50:01 <geekosaur> Squarism, you can wipe ~/.ghc which removes all locally installed libraries. then make the .cabal/config change I mentioned yesterday and profiling libs will be built for everything you install
07:50:14 <dcoutts> Squarism: I'm a bit of an outlier here, but I use the beta/feature-preview "new-build" in cabal-1.24 where it's simply a matter of saying cabal new-build --enable-profiling, all all the deps are rebuilt as required (installed in parallel with the normal ones, so you only have to build them once).
07:50:34 <Squarism> geekosaur, yeah.. i lack that knowledge to do targeted reinstalls
07:51:07 <geekosaur> targeted here just means you reinstall only things you need instead of "world" (which doesn't have enough information to avoid conflicting versions being installed; only your project has that)
07:51:08 <Squarism> dcoutts, thats the "sandbox" approach right?
07:51:21 <geekosaur> automatic sandboxing
07:51:26 <dcoutts> Squarism: it's the replacement for sandboxes
07:51:43 <geekosaur> everything is installed "globally" but only things your project needs are visible, and those only in the compatible versions
07:53:34 <geekosaur> reinstalling "world" can work very well, or it can work very poorly; the more stuff you have installed, the more poorly. you hit the latter, despite supposedly having only one project (which may mean the old cabal build style has warts; but then that would be why the new backpack stuff exists)
07:54:15 <geekosaur> at its root, you might recall my discussing ghc's dependencies. cabal is trying to fight with them, and losing :/
07:54:48 <Squarism> geekosaur, i guess i did.
07:54:50 <geekosaur> stack, and cabal new-build, use different ways to trick ghc into behaving itself
07:56:13 <Squarism> ill resort to stack for a while i guess. 
07:57:04 * geekosaur wishes ghc weren't so persnickety, even though understanding why it is
08:05:13 <fvh> how can I easily convert Aeson [Object] to [<MyData>] or [<MyData2>] ? I have an API that response in generalized Object with [Object] payload that different of requested method I have instances for MyData, MyData2 as well
08:06:08 <tdammers> fvh: I have trouble parsing your sentence
08:07:14 <dmj`> fvh: use polymorphism, specify your return type to be FromJSON a => a, then provide a FromJSON instance for <MyData> / <MyData2>
08:09:19 <fvh> tdammers I need to convert aeson objects list to my custom datatype list
08:10:12 <Ashy> ok, i have a datetime question... how do i go from "AEST" (sydney time) to a TimeZone value?   http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-LocalTime.html#t:TimeZone
08:10:24 <tdammers> ah
08:10:26 <tdammers> ok
08:10:39 <tdammers> fvh: you can exploit the FromJSON instance for lists
08:10:46 <tdammers> instance FromJSON a => FromJSON [a]
08:11:00 <tdammers> i.e., if MyData is an instance of FromJSON, then so is [MyData]
08:11:35 <nitrix> That's because there's an instance for [a] that becomes an aeson Value if I recall.
08:11:42 <nitrix> Namely, Array?
08:11:43 <Clint> Ashy: not easily; they're not unique
08:11:53 <Squarism> Just wanna say im VERY grateful for all help i get here!
08:11:56 <tdammers> nitrix: that would be the ToJSON side of things
08:12:14 <tdammers> nitrix: it works because [a] is an instance FromJSON iff a is an instance
08:12:48 <tdammers> nitrix: and what the list instance does is it expects a JSON array, converts elements individually, and puts them in a list
08:12:49 <Ashy> Clint: :( i know it's horrible in general...
08:12:52 <fvh> ok, I tried to map over list with parsing function, but failed
08:12:56 <fvh> maybe it's better
08:13:07 <tdammers> fvh: implement instance FromJSON MyData
08:13:10 <Ashy> Clint: i only have to deal with sydney time though luckly
08:13:13 <Ashy> luckily*
08:13:23 <Ashy> but i want to store UTCTime in the db 
08:13:26 <fvh> I have FromJSON MyData already
08:13:31 <Ashy> and in all the model types
08:13:46 <tdammers> fvh: OK, and what is your input? [Value] or Value?
08:14:02 <tdammers> fvh: i.e., do you need [Value] -> [MyData], or Value -> [MyData]?
08:14:04 <bergmark> fvh: i find the easiest way to write FromJSON instances to follow this pattern: parseJSON = fmap (toMyType :: Int -> MyType) . parseJSON
08:14:08 <fvh> [Object]
08:14:18 <Ashy> Clint: this looks helpful: http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-LocalTime.html#v:buildTime
08:14:32 <fvh> bergmark thanks, I'kk try that too
08:14:39 <fvh> *I'll
08:14:53 <tdammers> fvh: I see... so not Value, but Object
08:15:06 <tdammers> fvh: where does that list of Objects come from?
08:15:07 <fvh> yes, with Values
08:15:27 <tdammers> so [Value] -> [MyData]?
08:15:39 <geekosaur> Ashy, http://hackage.haskell.org/package/timezone-olson-0.1.7/docs/Data-Time-LocalTime-TimeZone-Olson.html might be helpful
08:16:37 <tdammers> the reason map doesn't work is because parseJSON isn't Value -> a, but Value -> Parser a
08:16:52 <tdammers> but since Parser is a Monad, you can use mapM instead
08:17:04 <fvh> no, Object equal to HM Text Value, my fromJSON instance making lookup by text/key  and convert to proper basic type and build MyData
08:17:30 <tdammers> in that case, a quick fix is to wrap your Objects in Aeson's Object constructor to turn them into Values
08:17:31 <fvh> yes, wrong types
08:17:54 <Ashy> geekosaur: ah cheers
08:18:52 <Ashy> what idiot invented daylight savings?
08:19:25 <Jinxit> the world should be on the same clock tbh
08:19:31 <Jinxit> fuck timezones
08:20:16 <tdammers> Ashy: some English king, apparently
08:20:42 <bjs> back from the times where we couldn't just press a button and fill our streets with artificial sunlight ;)
08:21:00 <tdammers> Jinxit: something can be said in favor of timezones; they make wall clock time align with average sleeping patterns
08:21:41 <tdammers> although I find it somewhat inconsistent to not have the calendar shifted by 6 months on the southern hemisphere
08:21:53 <tdammers> january in summer, wtf
08:22:32 <Ashy> hmm, maybe it's easier to make the code grab the local timezone from the system and always assume the system is set to the sydney timezone
08:22:57 <Ashy> which means i can't even test locally without setting my machine to the wrong timezone... hmm
08:23:00 <Ashy> haha
08:23:17 <puregreen> Ashy: I suspect that *if* timezones make life of an average person better by 1% (no idea whether they do or not in real life), it makes them totally justified no matter how hard it becomes for programmers to work with them
08:23:32 <geekosaur> on unix you can TZ=some_other_timezone ./myprog
08:23:55 <geekosaur> valid values are usually in /usr/share/zoneinfo or similar
08:24:22 <geekosaur> (yes, you can do that in scripts too)
08:24:49 <Ashy> ooh nice
08:24:54 <Ashy> TZ=Sydney date
08:24:57 <Ashy> works as expected
08:25:18 <tdammers> eh
08:25:18 <Ashy> can i make stack exec do that aswell?
08:25:42 <geekosaur> prepend that to the stack exec, or stack exec -- env TZ=... theprog
08:26:01 <Ashy> oh yeah im using it incorrectly
08:26:04 <tdammers> timezones should be used for presentation purposes, and for things where the timezone is a relevant part of your data
08:26:09 <tdammers> otherwise, just use UTC
08:26:17 <tdammers> and convert to/from local time in the presentation layer
08:26:48 <geekosaur> that's what they're trying tod o, as I understand it
08:26:52 <tdammers> i.e., if the meaning of your thing is "point in terrestrial time" (which is usually what date/time values are), then use UTC
08:26:55 <geekosaur> input data is Sydney tz, they want UTC in the db
08:27:08 <tdammers> if the meaning is "calendar date", use just the date without the time (Day in Data.Time)
08:27:10 <Ashy> im scraping dates and times that are Sydney local
08:27:26 <Ashy> and i want to turn them into UTCTimes to then use everywhere in code and store in the DB etc
08:27:52 <tdammers> so you take local dates without time zone information, then you tag them with the Sydney timezone, and then convert to UTC
08:28:04 * geekosaur btdt, is very grateful unix makes it easy to mock timezones
08:28:06 <Ashy> yes, it's the tagging with the sydney timezone that looks tricky
08:28:22 <Ashy> cos it's not just UTC+10 for the whole year
08:28:23 <mizu_no_oto_work> Which library are you using?
08:28:28 <Ashy> thanks to some long dead english king apparently
08:28:35 <Ashy> time
08:29:03 <tdammers> right
08:29:04 <Ashy> which i thought was the accepted one (although it's just the first one i came across) http://hackage.haskell.org/package/time
08:29:09 <tdammers> in that case, the problem is actually unsolvable
08:29:11 <geekosaur> it is the standard one
08:29:19 <fr33domlover> I have a (HashMap a b) and I'd like to build [(b, [a])] by gathering the keys used with each value. Is there an elegant way to do that?
08:29:24 <tdammers> because Local Time <-> UTC Time is not a 1:1 relation
08:29:34 <tdammers> some local times map to multiple UTC times
08:29:39 <coppro> and vice versa
08:29:41 <tdammers> no
08:29:41 <geekosaur> timezone-olson helps you interface the time library with standard zoneinfo files (the same thing used by the TZ=...)
08:30:00 <tdammers> or rather, for each time zone, there is only one valid local time for any given UTC time
08:30:10 <coppro> tdammers: oh wait, right. derr
08:30:14 <tdammers> but some local times don't exist at all, and some exist twice
08:30:19 <mizu_no_oto_work> Ashy: do you know what date the times are from?
08:30:25 <Ashy> mizu_no_oto_work: yes
08:30:35 <Ashy> it's asx announcements, they always have a date and time
08:30:51 <tdammers> so in order to make the conversion unambiguous and complete, you need to add error handling to report invalid inputs, and you need to add Daylight Savings information
08:30:54 <Ashy> at least for the current day and the previous business day anyway, the historical ones only have a date
08:31:23 <coppro> The time package is a very solid library. It doesn't have many advanced features, which are in other libraries, but what it does have is rocksolid
08:31:28 <tdammers> http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-LocalTime.html
08:31:31 <coppro> and it even has support for leap seconds
08:31:34 <tdammers> ^ this pretty much covers your options
08:31:55 <Ashy> tdammers: so it sounds way easier to use getZonedTime and make sure the system is set to sydney timezone
08:32:08 <tdammers> yes, it's easier, but it's also incorrect
08:32:18 <tdammers> because just "Sydney" isn't enough
08:32:31 <tdammers> you also need to know whether the given local time has daylight savings enabled or not
08:32:44 <Ashy> which should be handled by the system shouldnt it?
08:32:50 <tdammers> no, not really
08:32:54 <coppro> Ashy: No.
08:33:01 <Ashy> and then getZonedTime should know that currently sydney is UTC+11 or whatever
08:33:04 <Ashy> ah ok damn
08:33:10 <tdammers> the locale system gives you the current time zone including daylight savings
08:33:15 <coppro> if you go based off of system time, then you'll read things wrong in the other half of the year
08:33:16 <tdammers> but that's the situation *right now*
08:33:24 <tdammers> it doesn't cover historical timestamps
08:33:30 <coppro> e.g. right now it's June. If you read a time in December and assume it's in the same zone, you're wrong.
08:33:41 <coppro> also, DST has been known to change over time
08:34:03 <tdammers> indeed; future dates are completely impossible to do correctly
08:34:05 <Ashy> im only ever dealing with today and back possibly 3-5 days
08:34:11 <EvanR> make sure not to confuse "local time" with LocalTime
08:34:12 <mizu_no_oto_work> Ashy: If you're processing a historical date, you need a function (Day -> Timezone)
08:34:14 <Ashy> so "historical" doesnt go back very far
08:34:33 <tdammers> mizu_no_oto_work: that's not enough
08:34:50 <tdammers> the DST switch doesn't necessarily happen at midnight
08:35:01 <EvanR> ime you can solve your time date issues by thinking about your problem the right way, instead of forcing it into whatever conceptualization of time you happened to have come up with that morning
08:35:04 <tdammers> and even when it does, you have one hour of the day twice
08:35:07 <tdammers> once a year
08:35:14 <hpc> Ashy: is it impossible for you to deal internally with UTC+0 time, and then display it according to the current locale?
08:35:21 <EvanR> ime programmers are really bad at taking date times at face value, like other people do
08:35:31 <puregreen> fr33domlover: I don't know any
08:35:32 <coppro> for instance, looking at a copy of the time zone database
08:36:03 <quxbam> tero-_: sry, I was offline. I've edited your lpaste a bit. It works but...
08:36:05 <mizu_no_oto_work> Time is one of those things that seems simple until you realize that it's a mess
08:36:05 <Ashy> hpc: im scraping timestamps off a url that is displaying sydney times, so i have to work out what UTC time is for those first
08:36:13 <tdammers> EvanR: other people can afford to use a mental model that gets 98% of the cases right, and then manually correct the remaining 2% as they arise
08:36:15 <hpc> oh eek
08:36:22 <tdammers> EvanR: when you're programming, that just doesn't work
08:36:22 <coppro> The definition of DST used in Syndney has changed at least 8 times in the past 50 years
08:36:36 <mizu_no_oto_work> coppro: that's amazing
08:36:37 <EvanR> tdammers: im blaming programmers for doing that exact thing
08:36:40 <hpc> EvanR: other people tend to be late to work twice a year because of DST though ;)
08:36:52 <Ashy> my other option is to just store the date and to hell with the times
08:37:06 <hpc> or they forget about leap-years and schedule something for the wrong date
08:37:09 <Ashy> because im only going to have times from when i start scraping, the historical ones arent available
08:37:11 <tdammers> EvanR: ah, I think I read your statement with logic reversed :D
08:37:19 <mizu_no_oto_work> Ashy: what do you need to do with the times?
08:37:22 <EvanR> Ashy: if youre working with timezones (if you really need to) check out timezone-series package, the ZonedTime in Data.Time is not very sophisticated
08:37:30 <coppro> Ashy: use timezone-olson. use the Australia/Sydney time zone
08:37:32 <geekosaur> ob http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
08:37:52 <EvanR> and timezone-olson
08:37:55 <mizu_no_oto_work> Is it possible to just store the time as strings that you display to the user?
08:38:10 <tdammers> apparently the db demands UTC times
08:38:23 <coppro> storing data in UTC is 100% correct
08:38:38 <EvanR> it usually works but sometimes UTC gets in the way
08:38:38 <tdammers> coppro: except when there's no way to get the correct UTC value
08:38:42 <Ashy> it doesnt demand it, im just trying to "do the right thing"
08:38:53 <coppro> tdammers: why not just parse in Australia/Sydney?
08:39:12 <tdammers> coppro: because you don't know whether DST was active
08:39:28 <tdammers> coppro: and it's impossible to derive that information from the local time alone
08:39:32 <coppro> tdammers: oh sure
08:39:49 <Ashy> doesnt the combination of a date, time and "Australia/Sydney" by definition tell you if dst was active?
08:39:50 <coppro> but a) there's no way to solve that problem correctly at all, if the source data does not provide it
08:39:56 <tdammers> Ashy: no
08:40:02 <coppro> Ashy: no, because when the clocks shift back, the hours double up
08:40:17 <tdammers> anything within that repeated hour is ambiguous
08:40:30 <Ashy> oh ffs
08:40:35 <tdammers> vOv
08:40:35 <Ashy> people are the worst
08:40:48 <coppro> the standard disambiguation is to assume it's the first one
08:40:53 <EvanR> also note that some "local times" dont exist
08:40:57 <coppro> it's not always perfect
08:41:00 <EvanR> when the opposite dst change happens
08:41:02 <tdammers> EvanR: yes, I mentioned that
08:41:06 <coppro> but if that's the data you have, that's sort of what you have to do
08:41:15 <EvanR> however all LocalTimes exist
08:41:18 <tdammers> so, 00:30:00 might map to zero, one, or two UTC times
08:41:23 <EvanR> which is what databases usually work with
08:41:35 <coppro> depending on the data, you may be able to make other assumptions, like if the entries are all sorted by time, you might be able to detect the remapping by looking for a jump back
08:41:52 <tdammers> the situation is that for every given UTC time and timezone, exactly one local time exists
08:42:01 <EvanR> LocalTime is a "Y-m-d H:M:S" object
08:42:13 <tdammers> so UTC -> LocalTime is always possible and unambiguous (except for future dates, where we cannot know yet when DST will happen)
08:42:37 <tdammers> UTC -> TimeZone -> LocalTime, actually
08:42:48 <EvanR> TimeZoneSeries you mean
08:42:52 <tdammers> yes
08:42:53 <coppro> hmm
08:42:59 <tdammers> but you cannot reverse things
08:43:02 <EvanR> TimeZone is an offset, which is annoying
08:43:03 <coppro> apparently TimeZoneSeries actually disambiguates by choosing the *latest* option
08:43:07 <coppro> (see localTimeToUtC')
08:43:09 <coppro> *UTC'
08:43:17 <tdammers> yes, but that disambiguation is a guess
08:43:24 <coppro> yep
08:43:24 <EvanR> it should be able to also give a Nothing
08:43:26 <coppro> Ashy: basically
08:43:40 <coppro> EvanR: no, see the docs. it pretends the shift didn't happen to find the time
08:43:41 <Ashy> also this is stock market data
08:43:55 <tdammers> anyway, in this case, if *everything* is in the Sydney timezone, I'd just admit defeat and store local times after all
08:43:56 <coppro> Ashy: if you use Australia/Sydney, you'll get the Right Thing almost all the time
08:44:12 <tdammers> or, indeed, convert to UTC and accept a tiny bit of guesswork
08:44:16 <Ashy> yeah in this case everything is sydney
08:44:17 <coppro> for DST overlaps, you'll have to do your best to guess
08:44:27 <Ashy> at least until i add some other stock exchange...
08:44:29 <EvanR> coppro: you mean when its convert invalid or ambiguous times?
08:44:36 <EvanR> dont do that
08:44:39 <coppro> if you choose to store in local time, you're just handing off the responsibility to do the guess to a later point in the code
08:45:04 <mizu_no_oto_work> Alternatively, drop ambiguous datapoints if missing data is better than wrong data
08:45:07 <tdammers> coppro: that, or the guess might never be required, because the user wants to see Sydney time as well
08:45:13 <EvanR> tdammers: i would use something like localtime for store hours, since this is not affected by DST
08:45:17 <EvanR> while UTC is
08:45:27 <mizu_no_oto_work> like if you're trying to do some sort of analytics on this
08:45:41 <Ashy> missing data is not better, it's stock data, that missing point could have been a buy/sell signal
08:45:49 <tdammers> if you need to convert, another option is to fail loudly or ask for user input in case of ambiguities
08:46:00 <EvanR> store hours is constant across dst whiel your utc will have to be fixed regularly when politics changes
08:46:09 <Ashy> anyway it's late here and this has been even more eye opening than i knew it would be
08:46:19 <EvanR> tdammers: when getting localtime input from a user, the gui just shouldnt let you choose that time
08:46:22 <coppro> EvanR: localTimeToUTC', when it sees an invalid time (e.g. 2:30 on a day when 1:59 is followed by 3:00), it assumes the shift doesn't happen, so it would map to whatever 3:30 would map to. If it sees a redundant time (e.g. 1:30 on a day when the first 1:59 is followed by 1:00 again), it maps to the later of the two options.
08:46:25 <tdammers> with stock market data, you're pretty much fucked, and you cannot possibly do it right unless the stock market didn't trade at all during DST transitions
08:46:29 <Ashy> i'll check out timezone-series and timezone-olsen and see what i can do
08:46:44 <EvanR> coppro: that sucks but, you should validate the thing first
08:46:51 <coppro> EvanR: yeah. it provides validation methods
08:47:02 <tdammers> because if someone bought at 00:59 before the switch and then sold at 00:01 after the switch, you want to maintain that order
08:47:11 <tdammers> but all you have is 00:59 and 00:01
08:47:14 <EvanR> that should really be UTC
08:47:21 <tdammers> no way to tell which one has DST
08:47:40 <coppro> which is actually interesting
08:47:46 <tdammers> and in this case, guessing won't solve the problem either
08:47:52 <coppro> because iCalendar spec (RFC 5545) says to handle duplicates as the earlier time, rather than the later
08:47:55 <tdammers> but then, neither will sticking with local times
08:48:01 <tdammers> in fact, the information you want is lost already
08:48:06 <Jinxit> monotonic time
08:48:08 <Jinxit> thanks erlang
08:48:15 <tdammers> well, time to go
08:48:18 <EvanR> there are hundreds of permutations of how time and dates can be fucked up... lets concentrate on nice techniques plz
08:48:28 <coppro> EvanR: ever seen japanese era names?
08:48:37 <EvanR> no
08:49:15 <coppro> the counting system is based on the era (which nowadays coincides with the reign of an emperor). Each era counts from 1.
08:50:00 <coppro> So for instance, it's now June 20, Heisei 28. If the emperor were to die tomorrow, then tomorrow would be June 21, <new era name> 1
08:50:21 <coppro> and then January 1 would be January 1, <new era name> 2
08:51:00 <mizu_no_oto_work> EvanR: Sometimes things are really convenient for people, but become a nightmare centuries later
08:51:42 <mizu_no_oto_work> The Hebrew calendar has a simple rule for when days begin/end: sunset.
08:51:43 <EvanR> ive smashed my head on this wall for a while, and i advocate nice techniques that actually work, not things like that
08:51:57 <EvanR> calendars are skins on a count of days
08:52:04 <fvh> bergmark: thanks! fmap worked, but I needed to expose my parser function from module, so I'm using it in FromJSON instance and later fmap-ing over [Object] with parseMaybe function, I figured I can make wrapper for handling this but have around 30 different json reponses from API, so it's too much work for now
08:52:17 <EvanR> doing stuff with literally a calendar has the same fucked up results as doing stuff with a zoned time
08:52:43 <mizu_no_oto_work> Which is really nice if you live before clocks exist, but is awful for computers
08:52:58 <EvanR> its not really, as long as you have the right abstract objects
08:53:17 <coppro> EvanR: sunset where?
08:53:20 <EvanR> and a good understanding how what people expect, whats at stake with these data
08:53:23 * coppro drops the mic
08:53:34 <mizu_no_oto_work> coppro: sunset at your current location
08:54:00 <mizu_no_oto_work> Can you see 3 medium sized stars in the sky?  If yes, then it's a new day
08:54:18 <EvanR> and its not good if someone has a time question and anyone who knows how messed up it can be decides to make it that messed up
08:54:19 <mizu_no_oto_work> If it's cloudy, then make your best guess
08:54:44 <EvanR> for example sunsets have no bearing on most problems
08:55:26 <synergistics> What's the best way to compare a Maybe Int to a regular Int?
08:55:40 <Cale> To produce what sort of result?
08:56:20 <synergistics> Cale: Check for equality between the two Ints
08:56:26 <Boomerang> > compare 1 <$> Just 2
08:56:28 <lambdabot>  Just LT
08:56:32 <z64> hey all o/ anyone get their hands on haskellbook? thoughts?
08:56:38 <Cale> > fmap (== 1) (Just 2)
08:56:40 <lambdabot>  Just False
08:56:46 <Cale> > fmap (== 1) (Just 1)
08:56:48 <lambdabot>  Just True
08:56:52 <Cale> > fmap (== 1) Nothing
08:56:53 <lambdabot>  Nothing
08:57:03 <mizu_no_oto_work> > maybe False (> 3) $ Just 5
08:57:05 <lambdabot>  True
08:57:07 <synergistics> Boomerang: I could fmap it, but the goal is to get Bool results, not Maybe Bool
08:57:12 <Cale> Of course, you can also turn the first Int into a Maybe Int
08:57:17 <Cale> By applying Just to it
08:57:24 <Cale> and then compare the Maybe values for equality
08:57:30 <synergistics> Cale: I was thinking about that but I was afraid that would be bad practice
08:57:35 <Cale> Why would it?
08:57:46 <mizu_no_oto_work> > return 5 > Just 3
08:57:48 <lambdabot>  True
08:57:53 <Cale> heh
08:58:10 <synergistics> mizu_no_oto_work: Oh that's cool
08:58:23 <synergistics> Cale: Not sure, just being silly :I
08:58:37 <Boomerang> :t (\a b -> isJust b && a == fromJust b)
08:58:38 <lambdabot> Eq a => a -> Maybe a -> Bool
08:58:44 * hackagebot sparkle 0.2 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.2 (AlpMestanogullari)
08:58:56 <Boomerang> > (\a b -> isJust b && a == fromJust b) 2 (Just 3)
08:58:58 <lambdabot>  False
08:59:01 <Boomerang> > (\a b -> isJust b && a == fromJust b) 2 (Just 2)
08:59:02 <lambdabot>  True
08:59:03 <Cale> synergistics: It's just that return = Just for the instance Monad Maybe
08:59:08 <Boomerang> > (\a b -> isJust b && a == fromJust b) 2 Nothing
08:59:09 <fizruk> Boomerang: I think that's actually bad practice
08:59:09 <lambdabot>  False
08:59:11 <synergistics> Cale: Yea
08:59:29 <Cale> If you're using isJust and fromJust in the same line, it's probably bad practice
08:59:48 <fizruk> when is using fromJust a good practice?
08:59:49 <Boomerang> well the second one is never evaluated if the first one is False
09:00:03 <Cale> fromJust is only for those cases where you don't have to do an explicit check by construction
09:00:08 <Boomerang> I would usually keep the result of the comparaison as a Maybe
09:00:15 <Cale> If you had to do the check, you probably wanted to pattern match
09:01:01 <fizruk> Cale: I wonder if those cases follow from bad design
09:01:12 <Boomerang> :t (\a b -> case b of Nothing -> False; Just b' -> a == b) --like this?
09:01:13 <lambdabot> Eq t => Maybe t -> Maybe t -> Bool
09:01:26 <Boomerang> :t (\a b -> case b of Nothing -> False; Just b' -> a == b') --like this?
09:01:27 <lambdabot> Eq a => a -> Maybe a -> Bool
09:01:37 <hpc> for a good post that details the ways in which isJust/fromJust are bad in combination, see https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
09:02:13 <Cale> :t (\a m -> case m of Just b | a == b -> True; _ -> False) -- or perhaps this
09:02:14 <lambdabot> Eq a => a -> Maybe a -> Bool
09:02:45 <Cale> Usually you wouldn't write this at all though -- this is the same as comparing Just a with m
09:03:03 <Boomerang> True ^^
09:03:31 <fizruk> :t (==) . Just
09:03:33 <lambdabot> Eq a => a -> Maybe a -> Bool
09:03:44 * hackagebot servant-router 0.8.0 - Servant router for non-server applications.  https://hackage.haskell.org/package/servant-router-0.8.0 (willfancher)
09:03:50 <rfweenie> is there something like Data.Proxy but for type constructors? like, i want to hold a type constructor Foo{} in a proxy
09:04:19 <fizruk> rfweenie: isn't Proxy polykinded?
09:04:26 <Cale> Yeah, that's just Proxy
09:04:31 <Cale> :k Proxy
09:04:32 <lambdabot> k -> *
09:04:37 <Cale> :k Proxy Maybe
09:04:39 <lambdabot> *
09:04:50 <rfweenie> Cale: can i get the type constructor back out?
09:04:57 <Cale> What do you mean by that
09:05:06 <Cale> This is happening at the type level
09:05:10 <rfweenie> i want a safe way to represent a type constructor
09:05:14 <Cale> The value level is trivial
09:05:39 <rfweenie> the constructors have varying numbers of arguments, but are all for the same type
09:05:50 <Cale> wait what?
09:06:00 <Cale> Did you mean data constructor when you said type constructor?
09:06:10 <rfweenie> err yes
09:06:11 <rfweenie> oops
09:06:19 <Cale> But then what's the stuff about proxy?
09:06:35 <rfweenie> i don't think i mean to use proxy at all
09:06:53 <Cale> Anyway, there's Data.Data which has a way of representing data constructors...
09:07:05 <rfweenie> i know Data.Data has toConstr but it's hard to get the constructor safely
09:07:29 <rfweenie> if i had data A = A Int | B Int Int | C Int then i would have to do toConstr A{} which i don't think is that pretty
09:07:48 <fizruk> rfweenie: what is the (bigger) problem you're trying to solve?
09:07:57 <Cale> Yeah, let's take a step back from this
09:08:42 <rfweenie> fizruk: i need to have runtime information about what data constructor a value has, then check the data constructor against a set of allowed data constructors
09:08:44 * hackagebot unicode-transforms 0.1.0.1 - Unicode transforms (normalization NFC/NFD/NFKC/NFKD)  https://hackage.haskell.org/package/unicode-transforms-0.1.0.1 (harendra)
09:08:57 <Cale> ... so you want to pattern match
09:09:05 <rfweenie> i can't pattern match on them because the data constructors are specified by the user
09:09:11 <Cale> No they aren't.
09:09:20 <Cale> They're necessarily part of your program code.
09:09:34 <Cale> They can't be specified by the user.
09:10:21 <rfweenie> i mean, yes, but then i would have to manually convert their string input to the data constructor
09:10:49 <Cale> To which data constructor?
09:11:13 <Cale> Maybe it's best that you describe more of what your program is doing...
09:11:44 <maerwald> what's wrong with: toConstr A{} -- and why is it not pretty?
09:11:44 <Cale> Also, it's not uncommon to have to parse string input from users, so that sounds sensible
09:11:56 <Cale> maerwald: You're constructing a record with undefined fields...
09:12:12 <maerwald> yeah, but what's the problem wrt Data.Data?
09:12:29 <rfweenie> i have a type data Effect = EffectA { ... } | EffectB { ... } | EffectC { ... } and data Affectable = ... and the user can specify in their input "EffectA"/"EffectB"/"EffectC" to select an Effect to apply to Affectable
09:12:41 <Cale> It's a little unpretty in that an instance of the Data typeclass only needs to be too strict in order for that to result in a runtime exception.
09:12:47 <Cale> It probably won't be too strict
09:12:54 <Cale> But still, it looks spooky
09:12:59 <fizruk> maerwald: it's a bit weird? :p and it's hard to write instances manually
09:13:25 <maerwald> Cale: I've used Data.Data to compare constructors that way and it's perfectly safe for that
09:13:44 * hackagebot reactivity 0.3.2.4 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.2.4 (JamesCandy)
09:13:46 <maerwald> fizruk: that's true, if automatic deriving doesn't work, it's annoying
09:13:52 <Cale> maerwald: The GHC-generated instances certainly will be, so it's fair enough.
09:14:28 <maerwald> yeah, I'd go so far: if automatic deriving doesn't work, just do it more simple
09:14:32 <Cale> rfweenie: What do they do to determine the parameters of each of the Effects?
09:14:56 <rfweenie> Cale: it gets deserialized via aeson
09:15:02 <fizruk> i guess parameters come after it's been determined whether an effect is allowed
09:15:02 <Cale> rfweenie: You should probably parse enough of the input to be able to construct a complete value of type Effect
09:17:33 <fizruk> rfweenie: do you need to filter effects before parsing parameters or can you just read the whole effect (with parameters) and then just pattern match on it?
09:18:32 <rfweenie> fizruk: the latter, but then i'd still have figure out the data cosntructors from user input
09:18:49 <Cale> Yes, you have to do that
09:19:34 <fizruk> rfweenie: do you control the input format? maybe you can make it more comfortable?
09:20:10 <fizruk> rfweenie: e.g. you might be able to deserialize the whole Effect with aeson
09:20:54 <rfweenie> fizruk: hm, i think i just need to think about my problem again
09:21:00 <rfweenie> thanks anyway!
09:23:06 <Cale> Aeson does give you tools to try different possibilities and decide between various cases
09:23:17 <Cale> You can write the parser for each constructor, and then glue them together
09:23:36 <patrice_1> hi all, trying to use aeson to parse a json string, how is it supposed to work if we don't know what it contains, the documentation mentions "Once you have a value, you can write functions to traverse it..." but I can't find any example. 
09:24:49 <Cale> patrice_1: If you decode the thing as a value of type Value, then you'll get something which represents the JSON tree structure directly.
09:25:17 <Cale> You usually don't have to explicitly specify the type if you're just going to pattern match, like
09:26:17 <Cale> case decode foo of Nothing -> ... didn't parse as JSON ... ; Just (Object ob) -> ... ; Just (Array a) -> ... ; etc.
09:26:29 <Cale> But usually you have a better idea than that of what you're looking for
09:27:11 <Cale> Mostly you write instances of FromJSON for data structures which will reflect the data you expect to extract from the JSON
09:28:02 <Cale> (and in fact, you can leave the instance blank if you just want a generic version which is based on the structure of the type)
09:28:13 <patrice_1> Cale: so say if there can be anything, like value/pairs, is it possible to map the json to some sort of dictionary?
09:28:41 <Cale> If there can be anything whatsoever, then you want to use aeson's Value type
09:28:55 <Cale> https://hackage.haskell.org/packag
09:28:58 <Cale> oops
09:29:02 <Cale> https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#t:Value
09:29:17 <Cale> I have no idea how half of the URL ended up in my clipboard
09:29:21 <Cale> lol
09:29:44 <patrice_1> Cale: I've been reading that doc for 2 days pretty much lol, still can't make it work
09:29:46 <Squarism> geekosaur, what worked out well for me was. 1. Wiping ~/.ghc, 2. Adding "library-profiling: True" to ~/.cabal/config. 3. Installing my 8 dependencies. (in the meantime i could use stack to get on with work)
09:29:50 <Cale> type Object = HashMap Text Value
09:30:21 <Squarism> geekosaur, Thanks alot for your help. Even if it took some time i guess i learned a good lesson. =D
09:30:30 <Cale> So if it's an object, you get a data constructor Object applied to a value which is a HashMap from Text (the keys) to json Values
09:31:16 <Cale> https://hackage.haskell.org/package/unordered-containers-0.2.7.0/docs/Data-HashMap-Strict.html#t:HashMap -- and you can use this library of stuff to manipulate the HashMap in various ways
09:31:43 <Cale> (e.g. convert it to a list of key/value pairs so you can iterate over it, for instance)
09:31:43 <patrice_1> Cale: thanks, gonna try!
09:48:45 * hackagebot smtlib2 0.3.1 - A type-safe interface to communicate with an SMT solver.  https://hackage.haskell.org/package/smtlib2-0.3.1 (HenningGuenther)
10:02:05 <bitemyapp> deni: soup
10:02:41 <deni> bitemyapp: :)
10:03:12 <deni> bitemyapp: part of the problem might be because people don't have notifications set up for irc
10:03:19 <deni> or log history
10:03:46 * hackagebot shakespeare 2.0.9 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.9 (MichaelSnoyman)
10:03:53 <bitemyapp> deni: see me in query
10:10:24 <frew> hey guys, I'm trying to install some software through cabal (gitit) and getting this error: https://gist.github.com/frioux/1cf24025257c40f396c7625a019c066e
10:13:10 <buttons840> what is the name of (\a b -> a) ?
10:13:26 <buttons840> :t fst
10:13:27 <lambdabot> (a, b) -> a
10:13:51 <thimoteus> @src const
10:13:51 <lambdabot> const x _ = x
10:14:10 <merijn> buttons840: "\a b -> a" is short hand for "\a -> (\b -> a)"
10:14:56 <buttons840> merijn: i know, i'm about to write (\a _ -> a) in my code, but figured there's probably a common name for that i can use
10:15:13 <merijn> buttons840: oh, in that case "const", yeah
10:15:15 <buttons840> although the lambda is pretty straight forward
10:15:16 <merijn> :t const
10:15:17 <lambdabot> a -> b -> a
10:15:23 <srhb> frew: Can't reproduce. Perhaps you have some too old/too new version of ghc and cabal-install ?
10:15:25 <buttons840> :t flip const
10:15:27 <lambdabot> b -> c -> c
10:15:43 <merijn> buttons840: Also, note: you can take the type from "\a b -> a" and hoogle it
10:15:48 <merijn> @hoogle a -> b -> a
10:15:51 <lambdabot> Prelude const :: a -> b -> a
10:15:51 <lambdabot> Data.Function const :: a -> b -> a
10:15:51 <lambdabot> Prelude seq :: a -> b -> b
10:16:43 <buttons840> @hoogle ((a, b) -> a) -> (a -> b -> a)
10:16:43 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
10:16:44 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
10:16:51 <buttons840> nice, ty
10:17:06 <buttons840> so const = uncurry fst
10:18:04 <frew> srhb: yeah the version of ghc that comes with ubuntu 12.04
10:18:10 <frew> that's sad :(
10:18:50 <srhb> frew: Very few people use bundled OS versions anyway, get with the updates! ;-)
10:19:10 <frew>  if gitit had a binary or somethign I would
10:19:53 <Clint> frew: apt-get install gitit
10:20:20 <frew> yeah I'm trying to get a new gitit
10:20:25 <frew> that's why I'm doing this :(
10:20:26 <srhb> frew: Or use stack or nix to get it. :)
10:20:41 <Clint> your operating system is 4 years old
10:20:42 <frew> yeah stack works
10:20:53 <frew> it's just super heavy is all
10:21:25 <frew> coworker pointed out that I might be able to install an older mtl and still get the rest to build
10:21:27 <frew> so will try that
10:27:30 <minib00m> guys, do you know some example of closed expression that is not typable?
10:28:04 <Squarism> just learned about Elm and Purescript. Got me a big hyped here. Anyone experianced with both - and have some opinions? 
10:28:06 <minib00m> one i came up with was \x -> x x and ghci agrees it cannot construct infinite type t ~ t -> t
10:28:19 <Squarism> "Got me a bit..."
10:28:39 <srhb> Squarism: Both aren't Haskell, try ghcjs! :-)
10:28:52 <srhb> </opinion>
10:29:40 <EvanR> minib00m: ah, not typable in haskell, yeah that happens all the time
10:29:57 <Squarism> oh.. thought Purescript was atleast. Well ok.. ill try there
10:30:27 <minib00m> Purescript is just a small compiler that has similiar grammar to Haskell
10:30:28 <EvanR> heres another []:'x'
10:30:57 <shachaf> :t (\x -> x x) :: (forall a. a -> a) -> (forall a. a -> a)
10:30:59 <lambdabot> (forall a1. a1 -> a1) -> a -> a
10:31:54 <Cale> Squarism: Don't forget about GHCJS
10:31:54 <minib00m> :o 
10:31:55 <srhb> Squarism: Either of them might make you happy, I just like Haskell. :-P
10:32:07 <minib00m> Prelude> :t (\x -> x x)
10:32:11 <minib00m> <interactive>:1:10: error:
10:32:13 <minib00m>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
10:32:23 <minib00m> why there is a difference in answers? 
10:32:34 <Cale> Squarism: Personally, I really like GHCJS and reflex-dom in that space (which is good, since I use them every day for work)
10:32:49 <mizu_no_oto_work> Squarism: One of the big advantages to purescript is the simple bidirectional FFI to Javascript
10:33:40 <Cale> minib00m: The difference comes because type inference never instantiates a type variable with a polytype
10:34:15 <Cale> minib00m: While it's possible to do so, it results in too many programs which probably ought to be type errors becoming not-type-errors
10:34:19 <mizu_no_oto_work> I don't really have much experience with GHCJS's FFI, but I think that it's more difficult to have a project where a single component is written in Haskell and the rest are written in JS
10:34:57 <shachaf> There would also be no principal type for that expression, if you allowed rank-n types.
10:35:24 <Cale> Yeah, that's the other big reason: it would be a somewhat arbitrary choice
10:35:26 <buglebudabey> what is a good way to tell if something should be right associative, left associative, or non-associative? for example "case expr of value -> expr" what associativity should "->" be, right assoc?
10:35:36 <Cale> It's not possible to choose polytypes *uniquely*
10:35:38 <frew> anyone see the issue here? https://gist.github.com/frioux/e81814a08cfb6445c7a9294962b2b3e7
10:35:50 <frew> looks to me like both required versions of transformers are installed, but it still fails to configure
10:36:02 <Cale> buglebudabey: -> isn't an infix operator there, so it doesn't have any of the three
10:36:14 <Cale> It's a piece of punctuation which is part of the syntax of the case expression
10:36:21 <minib00m> Cale: thanks for explaination
10:36:44 <minib00m> im just trying to do simple tasks from lambda calculus and i thought haskell would be good if i can get answers right :) 
10:36:56 <minib00m> would be good checker*
10:37:18 <shachaf> Which lambda calculus?
10:37:22 <Cale> minib00m: If you're trying to play with the untyped lambda calculus, you'll run into lots of issues, especially when it comes to untyped lambda calculus terms which don't have a normal form.
10:37:36 <thimoteus> poor y combinator
10:37:45 <Cale> (Because the type system prevents you from writing those in a naive way)
10:37:49 <buglebudabey> Cale would that be the same for "in" in "let var = expr in expr"?
10:37:55 <Cale> buglebudabey: yes
10:38:33 <Cale> let <decls> in <expr>
10:38:47 * hackagebot http-trace 0.1.1.0 - Tracking http redirects  https://hackage.haskell.org/package/http-trace-0.1.1.0 (sigrlami)
10:38:50 <buglebudabey> Cale so in what cirumstance other than normal arithmetic would an associativity be necessary?
10:39:08 <Cale> buglebudabey: If you're going to chain multiple occurrences of the same operator
10:39:28 <buglebudabey> thank you
10:40:08 <Cale> <> is perhaps a good example, despite the fact that it's (at least by unenforced laws) required to actually be associative
10:40:30 <Cale> We define it to associate to the right, so that we can chain many of them together in the same expression
10:40:33 <buglebudabey> what about parenthesis?
10:40:42 <shachaf> Cale: But we define <*> to associate to the left. :-(
10:40:47 <Cale> Parentheses override any operator associativity
10:41:01 <eacameron> Is there a summary of how far the dependent haskell has come as of GHC 8?
10:41:08 <buglebudabey> Cale can that be defined in grammer of a Happy file?
10:41:12 <cheater> "how far"?
10:41:16 <Cale> The fixity and associativity of operators is just so that we can leave out parens.
10:41:17 <buglebudabey> grammar* cann't believe i did that
10:41:19 <srhb> eacameron: Phase 1!
10:41:52 <eacameron> srhb: as in https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1  ?
10:42:01 <srhb> eacameron: I believe so.
10:42:15 <srhb> Oh, that page has gotten messier since last I checked.
10:42:34 <minib00m> Cale: in fact task im trying to do "find expression e that is untypeable, expression e' that is typeable and e e' (beta reduction) that is typeable", using only simple lambdas (working with types t ::= int | t -> t)
10:42:57 <cheater> oh dependent haskell
10:43:02 <cheater> sorry, i misread your question
10:43:08 <Cale> minib00m: Perhaps something using the Y combinator would be easy
10:43:12 <netsu> clever: do you use musnix?
10:43:51 <Squarism> mizu_no_oto_work, FFI? Tried to google but came out short
10:44:16 <mizu_no_oto_work> Squarism: Foreign Function Interface
10:44:42 <Cale> minib00m: (\f -> (\x -> f (x x)) (\x -> f (x x))) (\fac n -> if n == 0 then 1 else n * fac (n-1))
10:45:02 <mizu_no_oto_work> e.g. Calling C functions from Haskell, Java from Scala (or vice versa), or Javascript from Purescript (or vice versa)
10:45:26 <Cale> This isn't typeable (I'll let you translate the second lambda at the top level into proper LC, but that's straightforward)
10:45:40 <Cale> It's the Y combinator at the start which is the issue with it
10:46:16 <Cale> But if we apply it to a number, we'll get a number.
10:47:01 <Cale> It's possible to sidestep the problem with typechecking the Y combinator in Haskell by moving the recursion up to the type level
10:47:20 <Cale> hm, do I have Rec in scope in lambdabot? :)
10:47:23 <Cale> :t In
10:47:24 <lambdabot> f (Mu f) -> Mu f
10:47:26 <Cale> :t InR
10:47:28 <lambdabot> (Rec a -> a) -> Rec a
10:47:38 <Cale> there we are
10:47:55 <Cale> So we have  newtype Rec a = InR { outR :: Rec a -> a }
10:47:58 <Cale> :t outR
10:48:00 <lambdabot> Rec a -> Rec a -> a
10:48:23 <Cale> (Rec a) is a type which is isomorphic to (Rec a -> a) via InR and outR
10:48:37 <Cale> and we can implement the Y combinator in terms of it like this:
10:48:53 <Cale> y :: (a -> a) -> a
10:48:53 <Cale> y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
10:49:04 <Cale> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
10:49:05 <lambdabot>  ghc: panic! (the 'impossible' happened)
10:49:06 <lambdabot>    (GHC version 7.10.2 for x86_64-unknown-linux):
10:49:06 <lambdabot>         Simplifier ticks exhausted
10:49:08 <Cale> haha
10:49:32 <minib00m> what the LOL
10:49:55 <geekosaur> typechecker gone recursive? :p
10:50:02 <Cale> Nope, it's the inliner
10:50:38 <ryantrinkle> is there any way to dynamically modify the cost center stack at runtime?
10:50:51 <shachaf> @let {-# NOINLINE y' #-}; y' = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
10:50:53 <lambdabot>  ghc: panic! (the 'impossible' happened)
10:50:53 <lambdabot>    (GHC version 7.10.2 for x86_64-unknown-linux):
10:50:53 <lambdabot>         Simplifier ticks exhausted
10:50:56 <Cale> ryantrinkle: That's an interesting idea...
10:51:02 <shachaf> some pragma
10:51:07 <Cale> ryantrinkle: I haven't seen anything to that effect though
10:51:09 <ryantrinkle> i've got a situation where attribution is not really meaningful
10:51:41 <Cale> ryantrinkle: I have hated cost centre stacks ever since they got "improved" in the middle of when we were working on BloodKnight
10:52:02 <shachaf> @let y' = let { {-# NOINLINE y'' #-}; y'' f = (\x -> f (outR x x)) (InR (\x -> f (outR x x))) } in y''
10:52:04 <lambdabot>  ghc: panic! (the 'impossible' happened)
10:52:04 <lambdabot>    (GHC version 7.10.2 for x86_64-unknown-linux):
10:52:04 <lambdabot>         Simplifier ticks exhausted
10:52:09 <Cale> It's too fine-grained now...
10:52:09 <shachaf> Oh well, enough in the channel.
10:52:34 <Cale> shachaf: Valiant effort though...
10:52:47 <ryantrinkle> Cale: yeah; they're still useful to some extent, though
10:52:48 <minib00m> well, i don't get something if Y is the Y combinator defined above
10:52:51 <ClaudiusMaximus> might still have the old version in the @let file
10:52:58 <bennofs> Cale: hmm, but you can still annotate manually, no?
10:53:06 <minib00m> then how come Y g = g (Y g) is typable?
10:54:41 <Cale> bennofs: The problem is that the old cost centre stack machinery used to do a better job of giving you summaries of different ways to get to the same point in the code -- the new one distinguishes the paths by which you reach any given point in the code now, which is "better" in the sense of providing you more detailed information, but worse in that it gives you a whole lot of "this thing is taking almost no time/space
10:54:41 <Cale> " hundreds of times over... and they might add up
10:54:46 <osager__> why this code doesn't add newline? "hello" ++ "\n" ++ "world"
10:55:18 <Cale> bennofs: and in large projects, you can end up with tremendously large .prof files now
10:55:41 <bennofs> Cale: ah, so the old one was more like the top10 summary you have now?
10:55:57 <kadoban> osager__: It does. How are you using it that it's not doing what you expect?
10:56:21 <Cale> -rw-r--r-- 1 cale cale   147185 Oct 30  2011 gameBenchmark-prepatch.prof
10:56:21 <Cale> -rw-r--r-- 1 cale cale 40788019 Mar  7  2012 gameBenchmark.prof
10:56:27 <Cale> ^^ this
10:56:32 <minib00m> kadoban: in fact it doesn't, at least ghci escapes the \n :P 
10:56:39 <bennofs> Cale: so to recover the old functionality, you wouldn't need any changes to GHC itself, just some way to aggregate the results differently?
10:56:48 <Cale> bennofs: Pretty much
10:57:11 <Cale> bennofs: Though it's hard to write that as an external tool, because the .prof truncates the stacks when they get long...
10:57:21 <Cale> and you'd have to parse it :P
10:57:32 <kadoban> minib00m: There is a newline in the String. What that newline looks like depends on how you look at it. In the Show instance, it's indeed escaped ... it's still there.
10:57:48 <bennofs> Cale: oh, right.  
10:58:02 <ryantrinkle> it would be very nice if the output of most of ghc's profiling-related stuff were machine-readable
10:58:06 <Cale> yeah
10:58:10 <minib00m> kadoban: oh... :)
10:58:35 <andreoss> can someboby give an example how to chain 'when' with >>=?
10:58:53 <andreoss> something >>= when >>= somthingelse
10:59:44 <bennofs> andreoss: something >>= \x -> when x somethingelse    ?
11:00:09 <kadoban> andreoss: Usually something like  something >>= \x -> (when blahblah $ a >> b >> c)  , which likely looks more natural in a do block, but still works I guess
11:00:11 <Cale> ryantrinkle: Yeah, all the nice tools that would enable... it should probably be a priority actually.
11:00:12 <andreoss> bennofs: is it possible with second >>=?
11:01:05 <Cale> Even if it was just the 'show' of some data structure internal to the GHC API, that would be quite usable.
11:01:06 <andreoss> kadoban: i wonder if something like "do x <- someThing ; when x someThingElse" can be written as as chain of >>=
11:02:13 <bennofs> andreoss: you *could* write something >>= flip when somethingelse, but i wouldn't recommend that
11:02:33 <kadoban> Well, sure.  someThing >>= \x -> when x someThingElse  ?
11:02:56 <kadoban> Or yeah, flip would work.
11:03:54 <andreoss> bennofs: thanks, but why not?
11:05:32 <jle`> readability, probably
11:05:47 <jle`> given the choice between two ways of writing something, you should probably prefer the more readable one :)
11:07:45 <tero-_> quxbam: ah, constraints are first-class citizens, too. nice
11:08:09 <tero-_> quxbam: but you're not happy with the solution you found?
11:09:52 <tero-_> I'm not quite sure how to apply it, though, because the parameter 'a' has the kind '* -> Constraint'
11:10:45 <hpc> extensible-effects may have won me over a little bit, just for checked exceptions
11:10:49 <hpc> runExc :: Typeable e => Eff (Exc e :> r) a -> Eff r (Either e a)
11:16:30 <pie__> ehehe http://thecodelesscode.com/case/143
11:18:48 * hackagebot vectortiles 1.1.0 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.1.0 (fosskers)
11:19:42 <Benzi-Junior> Question: when you have MultyParamTypeClasses can you declare the class to derive another class 
11:20:14 <merijn> Benzi-Junior: What does that mean?
11:20:58 <Benzi-Junior> so Foo a b  implies Bar a b 
11:21:36 <merijn> No, you can merely require a superclass has to be present
11:21:49 <Benzi-Junior> damn 
11:22:08 <minib00m> Benzi-Junior: im interested: what are you trying to do?
11:22:58 <Benzi-Junior> minib00m: declare a typeclass that is symmetric 
11:23:51 <Benzi-Junior> minib00m: typeclasses may not be the right tool for the job I'm trying to acheive ( this is part of exploratory research for my PhD)
11:24:31 <minib00m> oh wow, good luck with it! :) 
11:25:52 <Benzi-Junior> and by the way Why do type variables need to be unique when declaring class instances ?
11:26:59 <mizu_no_oto_work> Benzi-Junior: What do you mean, exactly?
11:27:44 <mniip> you mean why not 'instance Class a a' ?
11:27:51 <mniip> you need FlexibleInstances extension
11:28:02 <Benzi-Junior> mniip: exactly
11:29:11 <osager__> how to un import all packages in ghci
11:29:12 <osager__> ?
11:29:21 <osager__> unload
11:29:33 <mniip> Ctrl-D
11:29:45 <mniip> there isn't another way iirc
11:30:11 <dedgrant> ':m' on it's lonesome, perhaps?
11:30:39 <Benzi-Junior> mizu_no_oto_work: I wan't to ba able to declare a typeclass to be reflexive by just declaring a  "intsance ClassName a a where"
11:30:54 <mniip> oh well
11:30:59 <mniip> yes, apparently :m does  the job
11:31:26 <mniip> Benzi-Junior, 1466447250 [21:27:30] <mniip> you need FlexibleInstances extension
11:31:43 <mniip> that, or instance (a ~ a') => ClassName a a'
11:31:47 <mniip> which might need some more extensions
11:32:21 <shachaf> Of course those aren't the same instance.
11:33:26 <Benzi-Junior> mniip: FlexibleInstances causes problems
11:33:43 <mniip> oh yes, a ~ a' places some more restrictions on what you can do in other instances
11:43:47 <Zemyla> Hmm, is there a typeclass for monads that have an evaluate :: a -> m a function, such that evaluate undefined `seq` () = () and evaulate undefined >>= f = undefined?
11:45:23 <Zemyla> I know IO has it. Any MonadState has it:
11:45:36 <Zemyla> :t \a -> state $ \s -> a `seq` (a, s)
11:45:37 <lambdabot> MonadState s m => a -> m a
11:45:46 <Zemyla> Any MonadCont has it, too:
11:45:58 <Zemyla> :t \a -> callCC $ \c -> a `seq` c a
11:45:59 <lambdabot> MonadCont m => a -> m a
11:49:03 <osager_> mniip, great
12:15:55 <n0rp3d> o hai haskell
12:16:19 <Sinestro> Is it possible to write 'f :: (Storable a, Storable b) => (a -> b) -> (Ptr a -> Ptr b)'? If not or even if it is, what's the right way to pass some arbitrary function between two storable types into the FFI as a function pointer?
12:16:44 <Sinestro> All the examples online are 'double' or similar, where this is a pointer to struct jamboree
12:16:44 <Cale> Sinestro: IO needs to get involved there somewhere.
12:19:40 <Cale> Sinestro: You probably want a "dynamic wrapper", see http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html
12:20:20 <MichaelK> Hi, what's the most general typeclass with `put :: T f => a -> f a, get :: T f => f a -> a`? I think maybe this is somewhere in lens, but am having trouble sorting through it all
12:21:13 <Sinestro> I know I do
12:22:00 <kadoban> Applicative and Comonad I guess? Actually I guess Pointed and Comonad, but nobody uses Pointed I don't think.
12:22:11 * kadoban doesn't know lens, there might be a better answer there
12:22:41 <puregreen> I haven't seen such class in lens but it might be there anyway, who knows
12:22:44 <Sinestro> MichaelK: Iso a (f a)?
12:23:38 <MichaelK> Sinestro: hmmmm maybe
12:24:18 <Gurkenglas> Whats the correct way to arrange the *>/<*> here? http://lpaste.net/167151
12:24:51 <Gurkenglas> and <$>
12:25:05 <puregreen> regarding Iso: well, it's not a class, it's a value-level proof of such set of functions existing for your ‘f’
12:25:14 <puregreen> but if it works for you, sure
12:26:00 <Gurkenglas> (Oh wait many skip will just skip to the end because Maybe)
12:26:34 <puregreen> kadoban: there's also Copointed, so ultimately it's Pointed + Copointed, i.e. 2 classes that nobody uses :)
12:26:45 <Gurkenglas> there, better
12:27:25 <kadoban> puregreen: Heh, nice.
12:27:34 <MichaelK> puregreen: why don't people use them?
12:28:16 <kadoban> IIRC Pointed just nobody found much use for. Applicative comes up a lot and is a cool abstraction, but just 'pure' on it's own ... apparently not.
12:28:31 <puregreen> about Pointed: https://wiki.haskell.org/Why_not_Pointed%3F
12:39:40 <osager_> how to find prime numbers between an range a , b
12:40:13 <hguant> osager_ https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
12:40:46 <osager_> i mean in haskell with some lib hguant 
12:40:50 <osager_> hguant, 
12:45:59 <EvanR> osager_: maybe the arithmoi package
13:12:38 <roconnor> @quote StackCalculator
13:12:38 <lambdabot> StackCalculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
13:22:03 <mniip> looks suspiciously Cont-y
13:28:52 * hackagebot derive 2.5.26 - A program and library to derive instances for data types  https://hackage.haskell.org/package/derive-2.5.26 (NeilMitchell)
13:31:51 <kazagistar> @osager_: there are existing prime finder libraries. If you are trying to make a high performance one for some reason (?) you can use an STUArray or something
13:31:51 <lambdabot> Unknown command, try @list
13:32:17 <kazagistar> er sorry lambdabot, forgot you get touchy about that :P
13:43:53 * hackagebot HDBC-postgresql 2.3.2.4 - PostgreSQL driver for HDBC  https://hackage.haskell.org/package/HDBC-postgresql-2.3.2.4 (ErikHesselink)
13:45:40 <buglebudabey> would anyone be willing to help me with a shift/reduce conflict in happy?
13:48:38 <osager_> how to pattern match a list with one single element
13:48:46 <osager_> f (x:[])
13:48:50 <osager_> doesnt seem right
13:48:50 <EvanR> [x]
13:49:00 <EvanR> x:[] also works
13:51:07 <geekosaur> remember that x will be the single element, not the list
14:07:42 <osager_> in ghci , i can not define function parameters with pattern matching with let ?
14:07:49 <osager_> let f [] =...
14:07:55 <osager_> let f [x] = ..
14:07:58 <osager_> etc
14:08:22 <osager_> do they replace the previous definitions ?
14:08:24 <EvanR> > let f [x] = 3 in f [1]
14:08:26 <lambdabot>  3
14:08:43 <kadoban> osager_: You have to do some special syntax to do it all in one block, I think it involves :{ }: or something
14:08:43 <EvanR> > let f [x] = 3; f [x,y] = 4 in f [1,2]
14:08:45 <lambdabot>  4
14:08:56 <kadoban> Or just that maybe ...
14:09:23 <osager_> ok
14:09:29 <osager_> what about in a where clause
14:11:27 <lyxia> it's the same
14:12:39 <lyxia> let g = f where f [x] = x; f [x,y] = x + y in (g [3], g [1,2])
14:14:33 <ZelteHonor> If my program fail with < *** Exception: index out of bounds > how can I see wich line made the exception occur?
14:14:54 <ggVGc> heh...
14:15:03 <ggVGc> the eternal haskell question :(
14:15:19 <ggVGc> (I don't know the answer actually, off the to of my head)
14:15:36 <ggVGc> but it probably involved compiling without optimizations
14:15:54 <senoj> ZelteHonor: there is support for stack traces in GHC 8, that might help you locate the source of the exception
14:16:04 <ggVGc> ah, didn't know it was in yet
14:16:07 <ggVGc> yeah, look into that
14:16:22 <senoj> (keep in mind if might not actually be in your code, could be in a library you're using)
14:16:22 <ggVGc> ZelteHonor: the answer lies somewhre here, https://wiki.haskell.org/Debugging
14:17:27 <ZelteHonor> Trying to implement an algorithm from a paper is absolutly not easy. It's even worse if the algorithm canonical implementation use pointer.
14:18:04 <mauke> import Foreign.Ptr
14:19:44 <ggVGc> ZelteHonor: "pointer" is not something an algorithm uses. It's an exposed implementation detail in that case. Try to reformulate the "pointer" as something more abstract. Maybe a key into a lookup table?
14:19:46 <osager_> in this pattern matching, hasgap (a:b:xx), xx is a list while a and b are element right ?
14:20:04 <Rembane> osager_: Yes
14:20:10 <osager_> thanks
14:20:13 <mauke> it parses as (a : (b : xx))
14:20:35 <ggVGc> osager_: yes, and it's easier if you think of (:) as the list constructor, which is a more general concept. You can pattern match any constructors
14:20:49 <mauke> so at the top, a is the head and b : xx is the tail
14:20:58 <mauke> and b is the head of the tail and xx the tail of the tail
14:21:05 <ZelteHonor> That's what I said. The implementation use pointer. And I try not to use it. I use an HashMap instead of a pointer. But my data are moving. So I have to update the HashMap and the data.
14:21:07 <osager_> mauke, what's wrong with my code: http://lpaste.net/167175
14:21:18 <ggVGc> osager_: for example in Data.List.NonEmpty you have the :| constructor, and can pattern match on it just as you can on :
14:21:54 <EvanR> pointer is a thing in C-land
14:22:06 <mauke> osager_: why do you think something's wrong?
14:22:25 <ggVGc> ZelteHonor: well, that's immutability. You can hide that detail in a function if it makes it easier. But you can also use mutability by using ST, if the algorithm really is fundamentally mutable
14:22:33 <osager_> it's takes too long while it shouldnt
14:22:46 <kadoban> ZelteHonor: What algorithm is it? Is it well known?
14:22:49 <ggVGc> EvanR: but haskell is written in C!
14:23:13 <ZelteHonor> It's Sequitur. Here is a website about it.
14:23:19 <EvanR> no its not
14:23:20 <ZelteHonor> http://www.sequitur.info/jair
14:23:40 <ZelteHonor> THe "algorithm". http://www.sequitur.info/jair/table3.gif
14:23:54 * hackagebot http-trace 0.1.1.1 - Tracking http redirects  https://hackage.haskell.org/package/http-trace-0.1.1.1 (sigrlami)
14:24:19 <ggVGc> ZelteHonor: well, if you are having a hard time implementing it in an immutable way(and maybe it'll be a lot less efficient), you can try using ST
14:24:25 <senoj> the runtime is written in C, the compiler is written in haskell
14:24:28 <ggVGc> which should make the translation more direct
14:24:49 <ggVGc> well, technically my statement was very incorrect since haskell is not "implemented" in anything
14:24:54 <ggVGc> other than text
14:26:08 <EvanR> looks like the runtime system is a pile of C and C--
14:26:23 <ggVGc> a pile of s..C
14:26:32 * EvanR looks for the code
14:26:42 * ggVGc pulls EvanR back
14:27:19 <EvanR> https://github.com/ghc/ghc/tree/master/rts
14:27:26 <ggVGc> someone should implement a haskell compiler in C++ templates
14:27:36 <ZelteHonor> Well the algorithm isn't really that much mutable by design I think. I also often feel like the code I am writing is ugly. And I don't really know what to do about it. My main problem is not that much mutability. It's more clarity. My code become so compact that debugging it is pretty painful.
14:28:03 <ZelteHonor> Compact is not the right word.
14:28:09 <EvanR> wwow this stuff is so remote from haskell
14:28:15 <ZelteHonor> More like complex.
14:28:18 <ggVGc> ZelteHonor: the beauty of haskell is that you can write something that works, and then easily refactor it while the compiler usually guides you to not mess things up
14:28:25 <ggVGc> also, GHC has an amazing profiler
14:28:35 <ggVGc> you can even get a graph out of it quite easily
14:28:38 <ggVGc> which I find great
14:28:48 <maerwald> the profiler is not that great
14:28:51 <levi> It's difficult to write optimized language runtime systems in languages that themselves require substantial runtime systems. So C ends up being used a lot, as it allows the low-level data structure coding without requiring much of its own runtime.
14:28:51 <EvanR> ZelteHonor: so, you might have success using recursion and just passing the updated hashmaps or maps to the next stage when you loop
14:28:52 <ZelteHonor> Yes I use those a lot.
14:29:02 <EvanR> mutual recursion can simulate states or phases of the algorithm
14:29:07 <ggVGc> maerwald: it's nicer than anything I've used out of the box in any other language
14:29:10 <ggVGc> maybe I'm dumb
14:29:23 <itnex> ad
14:29:23 <itnex> fg
14:29:23 <itnex> asdfg
14:29:24 <itnex> sdf
14:29:26 <ggVGc> okay
14:29:28 <itnex> no
14:29:34 <ggVGc> okay
14:29:55 <maerwald> ggVGc: since haskell doesn't really have a call stack, the profiler simulates it and how deep it goes is somewhat arbitrary, often leaving you with little information what's really going on
14:30:08 <maerwald> so you end up rewriting stuff just to get meaningful profiler output
14:30:12 <ZelteHonor> By exemple now I have a index out of bound exception. But my code is so... unpleasently structured that it's hard to find where the problem came from.
14:30:15 <itnex> it doesn't?
14:30:23 <ggVGc> maerwald: tbh I've only used it for one project, but it helped me immensely
14:30:40 <ggVGc> but I only used it for allocation profiling
14:30:45 <itnex> i thought there was a stack and it only contained the call trace information
14:30:51 <EvanR> im ok with that especially if the cost of classic stack frames can be avoided somehow
14:30:58 <EvanR> its not like i want to be debugging stack frames
14:31:00 <Rembane> ZelteHonor: What happens if you enable the profiler and run the program again?
14:31:01 <itnex> i mean the ret addresses
14:31:03 <itnex> whatever
14:31:12 <maerwald> ggVGc: it's annoying if you want to know what function actually breaks your programs performance... and it might be a foreign library function. Happy hunting
14:31:27 <maerwald> since it might or might not go deep enough
14:31:39 <ZelteHonor> The profiler? I can't see how mesuring space or time would help with a Index out of bound?
14:31:41 <ggVGc> hm, well, it worked great in my case. BUt maybe I was lucky
14:31:56 <ggVGc> I found all the hot spots I needed to find and solved my performance problem within a day
14:31:59 <EvanR> ZelteHonor: there are runtime flags you can enable that might help
14:32:12 <maerwald> Gtk has an immense "call stack", so if you profile Gtk code, you usually get crap output from the profiler
14:32:43 <Rembane> ZelteHonor: Hopefully it says: "I tried to measure, this said boom" but I'm really hoping for the best there
14:33:20 <ZelteHonor> Wich option should I give to RTS?
14:36:53 <EvanR> ZelteHonor: -xc "This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. "
14:37:15 <EvanR>  /msg gribble https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-debugging
14:37:24 <EvanR> stupid phone
14:37:34 <EvanR> and default behavior of tab
14:39:37 <EvanR> -B Sound the bell at the start of each (major) garbage collection.
14:39:38 <EvanR> awsome
14:40:11 <ZelteHonor> I am not sure how to read the resut.
14:40:14 <ZelteHonor> result.
14:40:21 <ZelteHonor> Do I read it top-down?
14:41:05 <EvanR> i dont know what it looks like
14:41:48 <gabbiel> @src join
14:41:48 <lambdabot> join x = x >>= id
14:41:49 <ZelteHonor> It looks like this: http://lpaste.net/167183
14:42:09 <DavidEichmann> Any one know much about FRP and Switching (Reactive-Banana)?
14:43:57 <DavidEichmann> I'm trying to use a GUI to edit a polygon. I'm trying to add a point on mouse down and immediately enter a "dragging"  mode. then on mouse up stop dragging
14:44:18 <ZelteHonor> Oh my god. I was a really stupid mistake. Something like needing to replace a -1 with a -2.
14:45:16 <ZelteHonor> Damn... and my program seems to be working.
14:45:50 <EvanR> ZelteHonor: it looks like 3 different stacks
14:48:42 <EvanR> i have no idea
14:51:08 <MichaelBurge> Is there a common pattern for decorating the nodes of an AST with extra information as you deduce more and more of it?
14:51:24 <Cale> MichaelBurge: Add a type parameter for the type of annotations?
15:03:56 * hackagebot fbmessenger-api 0.1.2.0 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.2.0 (mseri)
15:41:48 <cheater> has anyone here tried implementing differential privacy in haskell?
15:46:38 <c_wraith> has anyone successfully implemented it in any language? 
15:46:55 <c_wraith> as far as I know, it's a goal, not an algorithm. 
15:47:25 <adarqui> hey.. so String is to be avoided but, I never understood why for example, something like 'wreq' uses String instead of Text
15:47:28 <Jinxit> isn't it basically just adding noise to data?
15:47:39 <adarqui> it's written by bos so obviously he's a serious haskeller
15:47:57 <adarqui> is there a reason? any idea?
15:48:28 <c_wraith> adarqui, because String isn't so bad, for small values. 
15:48:48 <puregreen> adarqui: (not only “a serious haskeller”, but also the author of text)
15:49:42 <c_wraith> Jinxit, yes, but I've yet to be convinced that it's actually possible. it's kind of like a pseudorandom function. not proven to actually exist. 
15:49:53 <adarqui> puregreen: ya exactly.. that's why i don't get it.. c_wraith ya, but then some of his functions use Text, like for params
15:50:16 <puregreen> adarqui: I think it's for the same reason why file paths are strings even for functions that return Text
15:50:27 <adarqui> ah, why's that?
15:50:37 <cheater> c_wraith: there's at least 3 companies i know of that have implemented it.
15:50:47 <puregreen> because, as c_wraith mentioned, for small values String isn't so bad :)
15:51:03 <cheater> anyways, why would "cabal repl" not start a ghci?
15:51:07 <cheater> i used to know that, but i don't.
15:51:24 <adarqui> puregreen: oh ok
15:51:31 <adarqui> gotcha
15:51:32 <cheater> i created a new "lib" cabal package, and inited a sandbox.
15:51:32 <dcoutts> cheater: if there was a failure in a component that the thing you're trying to repl depends on
15:51:34 <c_wraith> cheater, it's not an algorithm. you can't "implement it". it's a goal for a set of processes to achieve. 
15:51:40 <adarqui> i'm just trying to avoid String, so i made everything Text
15:51:46 <adarqui> but now I also have to do lots of T.unpack's etc
15:51:52 <cheater> dcoutts: there isn't a failure that i know of
15:51:53 <adarqui> which just seems counterproductive
15:51:54 <puregreen> when reading a file or requesting something over the network, the latencies involved are going to be orders of magnitude bigger than decoding strings
15:52:14 <cheater> it complained once about not having LICENSE but i did touch on that and now it compiles, or something like that
15:52:33 <adarqui> ya, but T.unpack'ing is also, ugly .. and i guess lots of those file name String's have to remain there because of so much existing code
15:52:36 <puregreen> adarqui: if you don't know when exactly String is bad, of course it's bound to be counterproductive in some cases
15:52:39 <cheater> anything else i am missing?
15:52:40 <adarqui> but not for a newer library, like wreq
15:53:28 <cheater> oh, i didn't add any exposed-modules
15:53:30 <cheater> that was it
15:53:58 * hackagebot jsaddle-dom 0.2.0.0 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.2.0.0 (HamishMackenzie)
15:54:39 <adarqui> cool thanks folks.. was just curious. pc!
15:57:36 <cheater> hmm... if i wanted to have a function that accepts a value that has the typeclass Random, I'd do something like f :: Random a => a -> (). But what if I wanted a to be specifically Bool? is there syntax for this?
15:58:22 <puregreen> f :: Bool -> () 
15:58:54 <puregreen> or I haven't understood your question
15:59:14 <puregreen> also you can write “f :: (a ~ Bool) => a -> ()” 
15:59:25 <cheater> i need to know that Bool has Random implemented
15:59:56 <itnex> why
16:00:10 <puregreen> what for? just use whatever methods of Random you need, and if Bool doesn't implement Random, you'll get a compile error
16:00:32 <puregreen> after all, when you write “x :: Int; x = 2+2”, you don't specify that Int has to implement Num
16:00:41 <puregreen> even if (+) is a method of Num
16:00:59 <cheater> i'll just let the typechecker come up with a type and i'll go with that
16:01:07 <cheater> too confused to think right now haha
16:01:25 <hjljo_> cheater: maybe you should lpaste the code you have
16:02:24 <buglebudabey> can someone help me with a shift reduce error in Happy? i'd be very grateful (permission to pm anyone who would)
16:02:37 <cheater> i don't have any code right now! i'm implementing the first function
16:03:05 <hjljo_> ok
16:03:06 <cheater> https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf
16:03:11 <cheater> trying to implement 2.3 here
16:03:16 <glguy> You can do crazy things like: demo :: C Bool => sometype; which would make a function that can't be called until *someone* makes a C isntance for Bool
16:03:29 <MichaelBurge> Is there a good example of using lens to manipulate syntax trees? I'd like to pattern-match against arbitrary sub-trees and replace them while updating AST annotations consistently.
16:03:43 <cheater> just look at the steps there (1, 2, 3), that's what i'm trying to do
16:04:14 <cheater> thinking i should probably have a function of the form doubleCoinFlip :: trueAnswer -> deniableAnswer
16:04:41 <itnex> no
16:05:02 <itnex> you need a nested monad stack transformer on those lens first
16:05:04 <cheater> however, it requires randomness, and i would like to be able to quickly swap out random generators, so i'd rather like something like doubleCounFlip :: rndGen -> TrueAnswer -> Random deniableAnswer
16:05:13 <itnex> then you throw in some arrows for good measure
16:05:23 <cheater> glguy: that sounds good
16:05:29 <pavonia> buglebudabey: Paste your grammar and the error message
16:05:31 <pavonia> @lpaste
16:05:31 <lambdabot> Haskell pastebin: http://lpaste.net/
16:05:37 <glguy> cheater: It's rarely what you'd actually want, though
16:05:43 <itnex> then you use peano arithmetic to encode array size in types
16:05:46 <cheater> do you think it's what i want right now?
16:05:54 <cheater> itnex: please stop
16:06:08 <itnex> only then do you have the right tools to be productive with haskell
16:06:11 <cheater> glguy: how do you think i should encode my situation in the type?
16:07:36 <glguy> No, you should just use Bool directly
16:08:33 <cheater> what's a good random source to use in haskell currently?
16:08:43 <buglebudabey> pavonia here's the happy file: http://lpaste.net/167196, the error is a shift/reduce error which means there's an ambiguity in the grammar, and it occurs after i've parsed an expression and a binary operation, see lines 752-818 here in the info file: http://lpaste.net/167198
16:09:25 <buglebudabey> pavonia if you've ever seen the dangling else problem that will help you with what i'm dealing with https://en.wikipedia.org/wiki/Dangling_else
16:10:22 <Squarism> glguy, you are the lens expert ive gathered. We talked about filtering collections in nested lists the other day. What was your best bet there? 
16:10:58 <Squarism> glguy, well.. just filtering lists nested in value structures i mean
16:11:30 <glguy> Squarism: over opticPointingToField (filter predicate)
16:12:12 <pavonia> buglebudabey: I don't think I can help you with that, sorry
16:12:42 <buglebudabey> :P it's really for people who've dealt with happy shift reduce stuff which isn't everyone, so i understand
16:13:07 <Squarism> glguy, worked fine!
16:13:34 <hjljo> cheater: if i understand correctly, you want True or False with even odds, how about using System.Random?
16:14:58 <hjljo> cheater: you can plumb a generator with StateT if you don't want to use IO
16:15:22 <glguy> buglebudabey: You'll need to inline your binop rule
16:16:05 <glguy> (if you want to rely on %left and %right and %nonassoc to resolve your ambiguities)
16:16:30 <buglebudabey> glguy is there a specific way to do that? when i add it to %left, right etc. it does not fix the problem
16:16:35 <buglebudabey> i'm trying to parse Core
16:16:54 <glguy> buglebudabey: You're going to have 12 productions in expr instead of the one binop production
16:17:09 <glguy> expr '/' expr; expr '*' expr; etc.
16:17:45 <glguy> and then happy will be happier
16:18:02 <buglebudabey> lol thanks, so no way to resolve without having that?
16:18:18 <buglebudabey> and to keep binop?
16:18:27 <glguy> You could refactor your grammar not not rely on %left and %right for disambiguation
16:19:36 <buglebudabey> for arithmetic operators i don't mind too much, but i'm trying to keep with what is in the book 'Implementing Functional Programming Languages'
16:19:58 <hjljo> cheater: for example, "RandomIO :: IO Bool" will give you a random boolean in ghci
16:20:05 <glguy> but those are the only two alternatives that I'm aware of
16:21:32 <buglebudabey> alright, thank's glguy :) if you're interested, this is what i'm trying to emulate http://picpaste.com/Screen_Shot_2016-06-20_at_8.19.50_PM-m8ogXyxM.png
16:31:34 <buglebudabey> thank you glguy! your first suggestion fixed it all
16:35:20 <cheater> i thought System.Random wasn't truly random
16:35:35 <johnw> I wonder if there's a name for this style of BNF that gives bounding numbers on repetitions...
16:35:52 <johnw> I think antlr allowed you to specify them too, IIRC
16:36:08 <cheater> https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/randoms   "While System.Random provides a random sequence of reasonably high quality, it is not a source for cryptographic quality random bits. The Crypto.Random module provides an interface similar to System.Random as well as functions better suited to cryptography purposes for such a source."
16:39:26 <hjljo> cheater: what do you mean by truely random?
16:41:47 <cheater> i thought System.Random was pseudorandom
16:42:15 <geekosaur> anything you use will be pseudorandom, except /dev/random on a system with good entropy sources
16:42:15 <johnw> I think he means, "not connected to a physical source of entropy"
16:43:10 <cheater> it may be connected, just not using enough entropy
16:43:15 <geekosaur> note that (a) good entropy sources are rare, and (b) as a result /dev/random is generally reserved for seeding cryptographic-quality PRNGs
16:43:31 <cheater> if you ingest 1 bit of entropy, and try to present 1000 bits, you're not going to be fully random
16:44:10 <johnw> I need to install a black hole in my server, so I can read bits from the radio decay
16:45:24 <bshelden> /dev/random is still pseudorandom.
16:45:33 <bshelden> sec, there's a good article on that.
16:45:57 <bshelden> http://www.2uo.de/myths-about-urandom/
16:46:23 <geekosaur> on linux it is, because too many people were reading it and using up the real entropy, yes. (and not enough sysadmins were breaking people's fingers for wasting good entropy on their games)(
16:47:24 <bshelden> You want true random at this point, I'd get an external device to pump it in.  Probably using radioactive decay.
16:47:42 <geekosaur> nevertheless, it is still a limited source of entropy --- limited in the sense that if you are reading from it all the time, other programs that need entropy for crypto will likely block on it
16:48:35 <bshelden> Sort of.  Both /dev/random and /dev/urandom use the same algorithm for generating numbers.  /dev/random simply blocks when the system guesses (yes, GUESSES) that it's out of entropy.
16:49:30 <hjljo> clearly you should make https requests to random.org
16:50:19 <johnw> order random bits to be mailed to you on a CD
16:51:50 <cheater> does anyone have an actual suggestion on how to get a good source of random numbers?
16:51:55 <johnw> cheater: http://openfortress.org/cryptodoc/random/
16:51:57 <bshelden> /dev/urandom
16:52:01 <argent0> cheater: RANDOM.ORG
16:52:11 <johnw> the link I just pasted says random.org isn't that great either
16:52:26 <johnw> in fact, the one constant about security anything is that whatever you find isn't good enough :)
16:52:28 <bshelden> If you have enough money on the line that you need actual true 100% random, get a hardware RNG based on radioactive decay
16:53:12 <EvanR> 100% true random
16:53:31 <EvanR> hardware actually is not good at this
16:53:39 <EvanR> you need software to clean up the ourput
16:54:02 <bshelden> Semantics.  Point is, use a source backed by quantum effects and you get the only known source of true randomness.
16:54:06 <EvanR> i meant to call into question the practical existence of 100% true randomness but forgot
16:54:34 <bshelden> If that gets broken, someone's getting a nobel price in physics.
16:54:56 <EvanR> even if quantum effects are random, its not necessarily high enough performance and your signal is definitely not uniformly distributed
16:55:12 <maks> what's the problem with using a stream cipher as your PRNG?
16:55:21 <cheater> wow
16:55:23 <EvanR> ^
16:55:29 <cheater> this is so extremely unhelpful
16:55:37 <fishythefish> cheater: Use Crypto.Random
16:55:47 <bshelden> Mrh, if you want to argue about actual 100% for reals reals, that cannot exist since NOTHING is true 100% reals reals.  And that's a philosophy question.  I only care about getting the time to crack past heat-death on current hardware.
16:55:57 <fishythefish> You most likely don't need true randomness, and Crypto.Random provides random bits good enough for crypto use, so they're probably fine for your needs
16:56:03 <maks> i mean just using AES256, say
16:56:17 <maks> if that's not random enough then you can probably break AES256 so good enough either way
16:56:22 <EvanR> cheater: your OS has secure random number geneartors, and there are bindings to them on hackage
16:56:23 <bshelden> cheater: You want a quick answer, and it straight up does not exist.  Welcome to crypto.
16:56:53 <fishythefish> Quick answer to which questions?
16:57:10 <bshelden> Every solution you get comes with caveats, and you /must/ understand them to get something that ends up secure.
16:57:21 <cheater> please don't tell me what i must
16:57:28 <bshelden> There's a reason why the "common wisdom" is "give up, you can't get it right" when it comes to crypto.
16:57:30 <EvanR> erm, was cheater even asking for crypto rngs?
16:57:41 * bshelden shrugs
16:57:45 <bshelden> Good luck, have fun.
16:57:46 <fishythefish> EvanR: he's doing differential privacy, so probably
16:57:47 <johnw> I guess we should ask: which haskell library uses /dev/urandom?
16:57:48 <cheater> fishythefish: do you mean from the crypto-api or crypto-random package?
16:57:49 <EvanR> oh
16:58:34 <argent0> johnw: because /dev/urandom is faster, if your application is not random-critical
16:59:01 <cheater> fishythefish: i've been looking at the crypto-api one but the only implementation of the rng that that has is using the random source from IO
16:59:10 <maks> argent0: i found in practice /dev/urandom to be quite crappy; for example it couldn't give me the right answer in monte carlo simulations...
16:59:12 <fishythefish> cheater: I was thinking crypto-random, but I'm sure there are alternatives
16:59:15 <cheater> which is not good because it comes with no guarantees
16:59:23 <cheater> let me look at the one in crypto-random, thanks
17:00:31 <cheater> EvanR: what bindings do you suggest?
17:01:01 <cheater> i'm on linux 4.4
17:01:02 <argent0> maks: I remember having good results using a PRNG for montecarlo, I don't actually remeber the inner workings of /dev/urandom
17:01:19 <EvanR> cheater: people are suggesting crypto-random
17:01:35 <cheater> OK, i thought you meant something different than what fishythefish suggested
17:01:41 <EvanR> nah
17:02:01 <fishythefish> cheater: crypto-random and crypto-api are the most popular, though I haven't worked with either enough to comment on quality
17:02:07 <fishythefish> I generally don't do cryptographic work in Haskell
17:02:45 <Axman6> I've been playing with cryptonite over the weekend, and it was quite nice to use
17:03:08 <maks> also more generally about crypto in haskell: http://www.leonmergen.com/haskell/crypto/2015/03/21/on-the-state-of-cryptography-in-haskell.html
17:03:13 <Axman6> https://www.stackage.org/lts-6.3/package/cryptonite-0.15
17:03:30 <fishythefish> Oh, I forgot about cryptonite - it provides a bunch of ciphers in addition to its own Crypto.Random
17:03:58 <argent0> maks: man urandom says: should  be  very  economical  in the amount of seed material that they read from /dev/urandom
17:04:08 <argent0> Users ...
17:04:14 <Axman6> having never done any crypto before, I found it pretty easy to use once I figured out how all the pieces fit together
17:04:47 <argent0> so /dev/urandom is for seeding only
17:05:09 <cheater> fishythefish: where does it say that crypto-random generates high quality random numbers?
17:05:37 <fishythefish> cheater: "This module is for instantiating cryptographicly strong determinitic random bit generators"
17:05:48 <fishythefish> admittedly those typos might not inspire confidence...
17:06:27 <fishythefish> Haskell doesn't have a standard CSPRNG, so you have to figure out which package you decide to trust
17:07:02 <fishythefish> Alternatively, you could maybe use the FFI to do the work in another language, or invoke a shell command via Haskell, etc.
17:08:04 <cheater> but that's crypto-api and that's not crypto-random which you and EvanR recommended using
17:08:38 <fishythefish> cheater: Whoops, wrong tab :P
17:08:39 <fishythefish> "Provide a safe abstraction for cryptographic pseudo random generator."
17:09:10 <cheater> yep i saw that but that doesn't exactly strike me as convincing
17:09:16 * fishythefish shrugs
17:09:19 <cheater> however, this package has been deprecated for cryptonite
17:09:24 <cheater> and that seems to be making the right claims
17:09:27 <fishythefish> You can always look at the source, I suppose
17:09:33 <fishythefish> cryptonite is likely a good choice
17:09:48 <cheater>  Cryptographic Random generation: System Entropy, Deterministic Random Generator 
17:10:02 <Axman6> I wish cryptonite had some more docs though. it's possible to follow the types (though you end up writing :: ByteString a lot)
17:10:24 <cheater> the types look fine at a glance
17:10:30 <fishythefish> cheater: In all cases, you're trusting the author's implementation
17:13:08 <cheater> yeah i am, that's good enough for me though
17:13:42 <cheater> not currently concerned with the possibility of someone having made an honest mistake, or being part of a conspiracy
17:14:25 <cheater> i think cryptonite looks fairly good. glad we tracked it down together, thanks for the pointers
17:14:35 <johnw> cheater: good luck!
17:34:02 * hackagebot th-reify-compat 0.0.1.1 - Compatibility for the result type of TH reify  https://hackage.haskell.org/package/th-reify-compat-0.0.1.1 (KeiHibino)
17:39:08 <cheater> so how do you suggest I use cryptonite, using getRandomBytes :: IO ByteString, or should i instead type it as :: MonadPseudoRandom SystemDRG ByteString? And should I be generating my own DRG using getSystemDRG?
17:42:17 <cheater> if i getSystemDRG, that obviously just stores one state of the random generator, so I have to manage that myself. It seems like the only way to use this generator value is using withRandomBytes, which then returns my random computation's value, and the new state of the DRG. but I don't really want to handle that state myself because that sucks.
17:42:35 <cheater> the other option, though, is to keep everything in IO, which isn't perfect either.
17:43:07 <crough> Why not just keep it as MonadRandom r => ... until you need to specialize it?
17:43:09 <johnw> only the part of the code that generates random numbers needs to be in IO, not everything
17:43:29 <johnw> I'd wager that a large part of your algorithm has nothing to do with the source of the random data it uses
17:43:39 <cheater> no it doesn't that's the point
17:43:50 <cheater> but the algorithm needs to get new random values
17:44:01 <johnw> continually?
17:44:15 <cheater> yes, it needs new ones
17:44:20 <crough> regardless, leaving it polymorphic is a good way to go
17:44:33 <johnw> if it has to be monadic, polymorphic is probably wise
17:44:34 <cheater> as in newly generated ones from whatever mersenne twister or whatever that package users
17:44:54 <cheater> the way to get new random values using MonadRandom is to use getRandomBytes
17:44:57 <johnw> but initially you could also just use lazy I/O to produce what appears as a list of random numbers, and then consume from this list
17:45:09 <cheater> but that has the type getRandomBytes :: ByteArray byteArray => Int -> m byteArray
17:45:13 <cheater> Source
17:45:24 <cheater> oops, disregard "Source"
17:45:38 <cheater> anyways, the m turns out to be IO, so i'm in IO again
17:45:46 <johnw> if it were me, I'd avoid making my algorithm monadic just because of random number generation; there should be a way to separate the pure from effectful code
17:46:00 <crough> cheater: I like what john is saying-- try `fix $ \rec -> (:) <$> getRandomBytes <*> rec` and then just pass in that list monadically a single time
17:46:06 <crough> you can read from it as many or as few times as you need
17:46:28 <cheater> johnw: i wouldn't like to make my algorithm monadic either, i'm just trying to figure out how best to do things here
17:46:44 <cheater> maybe making the algorithm respond to a list is a good idea indeed
17:46:52 <crough> that way you're just writing an algorithm that takes an infinite list of values
17:46:57 <johnw> exactly
17:46:57 <cheater> yes
17:46:58 <crough> that's actually very elegant johnw
17:47:09 <cheater> i wonder if it'll fuse properly
17:47:24 <cheater> what do you think?
17:47:37 <johnw> I'm unaware of how fusion interplays with lazy I/O, but it's a good question
17:47:44 <crough> as long as you use `fix` and not a recursive definition you should be fine
17:48:01 <cheater> why?
17:48:07 <crough> I think fusion is subject to the same rules as inlining, or at least similar ones
17:48:19 <crough> It could also just block forever the first time you try to access a value, as some IO does :P
17:48:24 <cheater> no, fusion has specific rewriting rules, some people remember them, i don't
17:48:26 <crough> you'd have to try it
17:48:54 <cheater> 7.14.4. List fusion      https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
17:49:01 <johnw> i'm pretty certain it wouldn't actually build a list, but Core is the answer
17:49:49 <cheater> is pattern matching a "good consumer"?
17:50:28 <cheater> i would assume yes but it's not mentioned there
17:50:54 <cheater> dcoutts: asleep?
17:50:59 <johnw> well, rewrite rules are based on eliding uses of functions
17:51:04 <johnw> but I wouldn't worry about this just yet
17:51:15 <johnw> write up a simple sample in this direction, check Core, then proceed if all looks good
17:51:47 <dcoutts_> cheater: the definitions of good produce and good consumer are pretty precise
17:51:57 <cheater> dcoutts_: oh hi
17:52:54 <cheater> dcoutts_: the only question was, if i have a lazy list constructed using fix and (:), and then have a recursive function that pattern matches on the head using the x:xs pattern, will that pattern be a good consumer?
17:53:10 <cheater> dcoutts_: if not, would you mind telling me why?
17:53:12 <dcoutts_> for foldr/build fusion, a good consumer is a list function that consumes its list argument with foldr
17:53:28 <dcoutts_> that's it
17:53:40 <cheater> i'm not folding
17:54:19 <cheater> i guess i'm mapping rather than folding, but really it's about the ability to have a source of randomness passed as a pure argument
17:54:32 <dcoutts_> so a "recursive function that pattern matches on the head using the x:xs pattern", no that will not be a good consumer for the foldr/build fusion system
17:54:39 <cheater> johnw and crough suggested generating a lazy list
17:54:45 <dcoutts_> because it's not literally consuming the list using foldr
17:55:04 <cheater> aha
17:55:15 <cheater> ok, it's clicking into place
17:55:40 <dcoutts_> fusion is not a "clever" optimisation, it's a rewrite rule
17:55:50 <dcoutts_> it's a rewrite rule on foldr and build
17:55:53 <cheater> yes, i've seen the rules
17:56:20 <cheater> i understand it's far from understanding anything one could come up with
17:56:49 <dcoutts_> cheater: if you want an intro to this stuff, see the first chapter of my thesis
17:57:24 <dcoutts_> it's actually fairly readable (if I do say so myself)
17:57:40 <jmcarthur> I'll vet the thesis. It's pretty readable.
17:58:11 <dcoutts_> I don't claim the whole thing is readable btw, just that the first chapter is :-)
17:58:24 <cheater> i've looked at the rewrite rules in the source.
17:58:33 <cheater> i can add my own rewrite rules post hoc, can't i?
17:59:16 <dcoutts_> cheater: yes
17:59:30 <dcoutts_> though you need to understand how they all interact
17:59:44 <dcoutts_> and interact with the rest of the optimiser passes
18:00:24 <jmcarthur> cheater: You can. The main clever thing about fusion is just that it involves rewrite rules for very general functions which can be used to implement a large number of other functions. You can also write more specialized rules, but as coming up with useful and safe rewrite rules can be tricky, very general ones tend to be more worthwhile.
18:00:36 <dcoutts_> cheater: but for a consumer it's almost certainly unnecessary, if you think it ought to fuse then it also ought to be able to write it as a foldr
18:01:00 <cheater> dcoutts_: writing as a foldr might be fairly unnatural though
18:01:13 <dcoutts_> that's true of course
18:01:19 <dcoutts_> depends what you care about
18:01:20 <cheater> i'll see about just using foldr though
18:02:35 <cheater> isn't "understand how they all interact" just limited to 1. coming up with a rule that only triggers on my code (e.g. specifically mentions the name of my new function or constructors) 2. finding the right compiler(?) pass by trial and error?
18:05:55 <cheater> oh it's called "phase"
18:06:09 <cheater> ok, i'm gonna go and code some stuff now, thank you
18:10:14 <monochrom> Here is the beauty of it. You write an explicit but natural recursion, like "f [] = []; f (x:xs) = [x]". Then you add a rewrite rule "f = foldr (\h _ -> [h]) []". You get the best of both worlds. Readable code that is not used, fusable code that is not read, and nothing says they are related in any way except human intelligence.
18:12:22 <cheater> human intelligence is not part of my belief system :-)
18:16:04 <Zemyla> Okay, is there a name for the typeclass on f with the operation <*< :: f (Either (a -> b) c) -> f a -> f (Either b c)?
18:17:06 <monochrom> I think Applicative suffices for it.
18:17:26 <monochrom> @djinn myop :: Either (a -> b) c -> a -> Either b c
18:17:26 <lambdabot> Cannot parse command
18:17:53 <Koterpillar> @djinn myop :: Either c (a -> b) -> Either c a -> Either c b
18:17:53 <lambdabot> Cannot parse command
18:18:24 <Zemyla> monochrom: No, it should only execute the second operation if the first is Left.
18:19:01 <zRecursive> @djinn Either c (a -> b) -> Either c a -> Either c b
18:19:01 <lambdabot> f a b =
18:19:01 <lambdabot>     case a of
18:19:01 <lambdabot>     Left c -> Left c
18:19:01 <lambdabot>     Right d -> case b of
18:19:01 <lambdabot>                Left e -> Left e
18:19:03 <lambdabot>                Right f -> Right (d f)
18:19:09 <monochrom> then probably Alternative can do it
18:19:53 <Zemyla> :t \fa fb -> fa >>= either (\f -> fmap (Left . f) fb) (return . Right) -- A definition of the desired operation in terms of Monads
18:19:54 <lambdabot> Monad m => m (Either (a -> a1) b) -> m a -> m (Either a1 b)
18:20:18 <Zemyla> No, Alternative can't, because it can't branch based on its contents.
18:20:39 <cheater> Zemyla: aren't you looking for a comination of <*> and <$>?
18:20:47 <glguy> Zemyla: and you don't want Monad?
18:20:54 <Zemyla> glguy: No, I don't.
18:21:24 <monochrom> next step up is ArrowIf :)
18:21:40 <Zemyla> Yeah, I'm looking for the Applicative equivalent of ArrowChoice.
18:21:57 <monochrom> yeah
18:22:15 <geekosaur> :exf "Either c (a -> b) -> Either c a -> Either c b"
18:22:15 <exferenceBot> (<*>)
18:22:31 <Welkin> O.o
18:22:33 <Welkin> exf?
18:22:35 <Welkin> :exf
18:22:38 <Welkin> :exf lolol
18:22:43 <Welkin> oh
18:22:46 <Welkin> not a trigger
18:22:55 <Welkin> wait
18:22:58 <Welkin> who is this!?
18:23:04 <exferenceBot> could not find expression
18:23:05 * Welkin pokes exferenceBot 
18:23:06 <geekosaur> https://github.com/lspitzner/exference
18:24:44 <zRecursive> geekosaur: "Either c (a -> b) -> Either c a -> Either c b" is <*> ?
18:25:12 <monochrom> yes, consider "instance Applicative (Either c)"
18:25:13 <geekosaur> if you use Rights instead of Lefts, yes, it's just fmap over Eitger
18:25:19 <geekosaur> *ERither
18:25:24 <geekosaur> damn, can't type >.>
18:25:27 <geekosaur> *Either
18:25:29 <Welkin> Erither!
18:25:31 <Welkin> what a good name
18:25:35 <Welkin> we should use it
18:25:47 <zRecursive> great!
18:26:31 <geekosaur> actually I am not sure that's true currently, as it was decided that Either should not privilege either leg. so now we have newtype-s
18:27:57 <zRecursive> I indeed am not sure "Either c" is an instance of Applicative.
18:29:25 <Zemyla> geekosaur: No, it isn't. It executes the effect in the second element whether the first one results in Left or Right.
18:29:48 <monochrom> sure. but exferenceBot is not about actual libraries in use. it's only about logical possibilities.
18:29:51 <geekosaur> Zemyla, I don't see anything impure here
18:30:04 <geekosaur> it's not EitherT IO
18:30:07 <Zemyla> That's because you aren't looking at the original signature.
18:30:21 <cheater> :t \(x :: (f (Either (a -> b) c))) (y :: f a) -> x <*> y
18:30:22 <lambdabot>     Couldn't match type ‘Either (a -> b) c’ with ‘a -> b1’
18:30:22 <lambdabot>     Expected type: f (a -> b1)
18:30:22 <lambdabot>       Actual type: f (Either (a -> b) c)
18:30:37 <Zemyla> :t \fa fb -> fa >>= either (\f -> fmap (Left . f) fb) (return . Right) -- It has this signature, but instead of Monad, it should be something descending from Applicative.
18:30:38 <lambdabot> Monad m => m (Either (a -> a1) b) -> m a -> m (Either a1 b)
18:30:41 <cheater> I know you have to use Data.Bifunctor.first somehow here but i'm too bored to figure out the last step
18:31:05 <Zemyla> See how fb isn't called if fa results in Right b?
18:31:21 <cheater> Zemyla: let me know if this helps you
18:33:09 <Zemyla> The reason I want this typeclass is because I have detected a way to detect loops in definitions of Applicative objects.
18:33:52 <Zemyla> And I want to use that in a parser. But it doesn't work for Monads, because any object can be defined on the fly inside them.
18:40:57 <Zemyla> I'll just call it "Choice".
18:41:55 <coppro> Zemyla: are you thinking Alternative?
18:41:58 <Zemyla> class (Applicative f) => Choice f where { (<*<) :: f (Either (a -> b) c) -> f a -> f (Either b c); (>*>) :: f (Either a (b -> c)) -> f b -> f (Either a c) }
18:42:18 <coppro> ohh
18:42:28 <coppro> hmm
18:42:32 <coppro> that looks very Arrow like
18:42:33 <Zemyla> There's no way for Alternative to fail based on what's inside it.
18:42:59 <Zemyla> coppro: It does. It looks a lot like ArrowChoice, but with only one parameter.
18:43:24 <coppro> Zemyla: what do you mean there's no way for Alternative to fail?
18:44:25 <Zemyla> There's no way to write a function evensOnly :: (Alternative f) => f Int -> f Int which only succeeds if the Int inside is even.
18:44:45 <cheater> :t \(x :: Functor f => (f (Either (a -> b) c))) (y :: Functor f => f a) -> (\u -> (Data.Bifunctor.first ($ u)) <$> x) <$> y
18:44:46 <lambdabot> Functor f => (Functor f => f (Either (a -> b) c)) -> (Functor f => f a) -> f (f (Either b c))
18:44:47 <coppro> what does "succeed" mean?
18:44:50 <cheater> there you go
18:44:56 <cheater> that's your function
18:45:29 <cheater> hope this helps Zemyla 
18:45:45 <Zemyla> cheater: No, the result is f (f (Either b c)).
18:45:58 <cheater> oh wait right
18:46:05 <coppro> Zemyla: I apologize, but I don't quite follow what you are trying to do
18:46:37 <cheater> well you can write something like concat or whatever i guess
18:46:57 <cheater> depending on what f you have
18:47:08 <Koterpillar> ...join?
18:47:14 <cheater> he doesn't want a monad
18:47:15 <coppro> he doesn't want Monad
18:47:19 <Koterpillar> I know
18:47:30 <cheater> unless you need to keep it polymorphic, in which case you might need to figure out something better
18:48:12 <jmcarthur> I think Koterpillar was trying to point out that "something like concat" is join.
18:49:01 <coppro> concat is just join anyway :P
18:49:26 <Zemyla> Let's say IO was an instance of this typeclass. You could say foo <*< putStrLn "Whee!", which would take a foo that's an IO (Either (() -> a) b), and only run the print "Whee!" if the result was Left (something).
18:49:32 <glguy> Zemyla: so the laws you're wanting are that choice (pure (Left f)) = fmap (Left . f); choice (pure (Right x)) = const (pure (Right x))
18:49:44 <glguy> or something similar, I didn't typecheck that
18:51:17 <Zemyla> Yeah. pure (Left f) <*< x = Left . f <$> x; pure (Right g) <*< x = pure (Right g).
18:52:08 <coppro> hmm
18:52:53 <coppro> isn't that just
18:53:49 <jmcarthur> I think more generally:    (Left <$ a) <*< b = Left <$> (a <*> b); (Right <$ a) <*< b = Right <$> a
18:54:40 <jmcarthur> The rule for Right feel more arbitrary than the one for Left.
18:55:02 <jmcarthur> *feels
18:56:43 <coppro> ok, I think I see what you're trying to do now
18:57:58 <Ankhers> Has anyone seen this error using stack http://lpaste.net/167219?
19:01:03 <geekosaur> what's "ulimit -n" return on that system?
19:01:19 <geekosaur> and in that environment?
19:01:38 <Ankhers> geekosaur: me?
19:01:43 <geekosaur> yes
19:01:50 <Ankhers> latest OSX, 256
19:02:32 <geekosaur> ...
19:02:53 <geekosaur> linux gives you 1024, I bet they never tested for that
19:03:38 <roboguy`> looks like there's an issue about that limit here https://github.com/commercialhaskell/stack/issues/1177
19:04:00 <geekosaur> damn, it really is that small on 10.11
19:04:00 <jmcarthur> Even 1024 just seems so low to me.
19:04:18 <geekosaur> bet they didn't think about that at all (and I bet soonish someone''s going to get a big enough project to hit it on Linux, yeh)
19:04:23 <Welkin> :t (<*>)
19:04:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:04:26 <Welkin> er
19:04:27 <Welkin> :t (<*<)
19:04:28 <lambdabot>     Not in scope: ‘<*<’
19:04:29 <lambdabot>     Perhaps you meant one of these:
19:04:29 <lambdabot>       ‘<*’ (imported from Control.Applicative),
19:04:36 <roboguy`> I'm on OS X 10.11 and it says 7168... an install script must have raised it automatically or something
19:04:42 <Welkin> jmcarthur: typo?
19:04:49 <jmcarthur> Welkin: It was from context.
19:05:11 <jmcarthur> Welkin: That is a speculative operator that Zemyla is working on.
19:05:27 <Welkin> ah
19:05:29 <Ankhers> Ehm not a huge deal. Simple enough fix. I was more worried about the "did not find cabal file for wai-extra..."
19:05:37 * geekosaur poked at work iMac and confirmed ulimit -n == 256
19:06:12 <Ankhers> But, rerunning build did indeed fix the issue.
19:06:15 <roboguy`> it sounds like you can change it with 'ulimit -n <new-number>'
19:06:19 <geekosaur> Ankhers, given that happened just before, I would guess that it hit the ulimit during that
19:06:27 <Ankhers> fair enough.
19:06:33 <geekosaur> and reported the failure of the high level operation, followed by the error message it got returned
19:06:45 <Ankhers> I'll just make a point of raising my limit tomorrow.
19:07:07 <Ankhers> roboguy`: I believe it is a little more involved than just that.
19:07:08 <riaqn> Hi, where can I find the impl of Instance Monad STM? or is it primitive in GHC?
19:07:12 <roboguy`> since so many things are represented as files in a unix-based OS like OS X, 256 does seem on the low side...
19:07:27 <roboguy`> Ankhers: how so?
19:07:36 <ggVGc> why is there even a ulimit_
19:07:37 <ggVGc> ?
19:07:45 <geekosaur> I tend to think ifyou're opening > 256 files at a time to look for stuff, you need caching
19:07:49 <geekosaur> and/or indexing
19:08:18 <Ankhers> roboguy`: Don't you have to edit /etc/launchd.conf if you want it to persist?
19:08:22 <jmcarthur> I disagree. There are many reasons to want a lot of file descriptors.
19:08:23 <geekosaur> servers handling lots of connections, yes. opening hundreds of tiny files looking for hashes, please consider a more rational design :)
19:08:23 <Welkin> lol
19:08:26 <jmcarthur> Ah
19:08:28 <Welkin> so bascially, osx is just crap
19:08:29 <jmcarthur> Well
19:08:32 <Welkin> like always
19:08:34 <jmcarthur> Welkin: Please.
19:08:47 <ggVGc> I don't understand artificial limits like this at all
19:08:50 <roboguy`> Ankhers: ahhh, you're probably right
19:09:14 <Ankhers> If I could find a laptop with similar build quality as my mac book, I would switch in an instant.
19:09:20 <geekosaur> ggVGc, the system has a fixed limit, generally. you don't want a badly behaved user process to consume the whole system file table
19:09:22 <Welkin> Ankhers: install linux on it
19:09:28 <roboguy`> ggVGc: at that level of OS thing, you probably need some sort of limit. Dynamically allocating that might not work too well
19:09:29 <Welkin> I haven't done that yet on mine
19:09:29 <geekosaur> so you set limits
19:09:37 <riaqn> Ankhers: how about dell xps developer edition? 
19:09:42 <ggVGc> roboguy`: why not?
19:09:50 <roboguy`> ggVGc: well, for the reason geekosaur mentioned
19:10:11 <ggVGc> I think I disagree
19:10:17 <geekosaur> (dynamically allocating the file table is possible, yes. it also adds considerable extra overhead to any operation that uses the file table, because of extra locking so it doesn't get resized out from under some other process reading it)
19:10:24 <roboguy`> also if you implement it as a dynamic array, you will need an expensive copy operation if you have to enlargen it
19:10:27 <Ankhers> riaqn: That appears to only be 13 inch. I like a 15 inch display :(
19:10:28 <ggVGc> there are tons of other things badly behaved processes can do that will mess up a system
19:10:36 <ggVGc> so I don't think this is helping much with that
19:10:37 <roboguy`> which can lead to totally unexpected pauses
19:10:53 <geekosaur> and of course the cost of aid resize, but one hopes that doesn't happen often
19:10:58 <geekosaur> *said resize
19:11:15 <Ankhers> Welkin: I've been meaning to. I haven't gotten around to installing refitt, or whatever it is called.
19:11:16 <ggVGc> I think these are hypothetical problmes in current times
19:11:19 <roboguy`> if you use a linked list, it will take up more space and have worse cache locality, which could be a major issue for something like file access
19:11:29 <geekosaur> ggVGc, you[ve never used a vps?
19:12:50 <geekosaur> (I am not justifying such a low limit on Macs though. 256 sounds like someone copied a number from the old Mach single-server and didn't consider whether it should be enlarged. WOnder how long before Apple hits it themselves...)
19:16:00 <ggVGc> well, either way I think something like this should be based on a percantage of how much ram the machine has or something
19:16:07 <ggVGc> rather than a global hard limit over all machiens
19:16:21 <ggVGc> even 1024 seems unreasonable
19:16:34 <ggVGc> why not 0.0001% of available ram, or 1024 minimu
19:16:34 <ggVGc> m
19:17:03 <ggVGc> running out of file descriptors seems like an unaccepable problem on a modern computer in 2016
19:17:17 <idev> I'm writing a DSL -> JS compiler. What's the quickest way to find a minimal set of JS useful for compiler output?
19:17:23 <ggVGc> so waht if a process opens a million file descriptors. I think the machine should handle that okay
19:17:45 <ggVGc> idev: probably get better answers in #javascript
19:18:09 <roboguy`> idev: is it a general JS DSL or something specific? If it's specific, you should go for what the DSL needs...
19:19:31 <dfeuer> Does this have a standard name?  newtype F p a = F {unF :: p (F p) a}
19:20:12 <chronon-io> idev: asm.js?
19:20:16 <dfeuer> ggVGc, I don't think the amount of RAM is the issue.
19:20:16 <geekosaur> ggVGc, at this point all I can recommend is that you go take an OS design/implementation course. doing that is a *lot* more expensive than you think...
19:20:45 <dfeuer> ping hexagoxel 
19:21:26 <geekosaur> how big and complex a process table entry is, how many redirects/pointers have to be followed at nonzero performance cost to do various operations, extra locking for mutable structures if you make the file table relocatable or resizable, ...
19:22:36 <geekosaur> (talking the per process file table here, not the system one --- which has its own complexities, and more of them than the per-process table)
19:34:05 <jasonkuhrt> Hi, I am learing about Readers and having a hard time finishing a task related to them. Specifically I am asked to refactor https://github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs to use ReaderT to manage access to the Redis Connection. Take saveURI for example. But I am a bit confused by the idea of a Reader with more than one argument as the type is always (?)
19:34:05 <jasonkuhrt> Reader Type1 Type2.
19:35:16 <geekosaur> do you understand what a Reader is?
19:36:53 <jasonkuhrt> geekosaur: Part of my understanding is that it acts like a wrapped function
19:37:05 <geekosaur> yes
19:37:14 <jasonkuhrt> Reader X1 X2 relating to X1 -> X2
19:37:34 <jasonkuhrt> If you have x1 -> x2 -> x3 ...
19:37:55 <roboguy`> there's another way to accept multiple arguments too
19:38:24 <geekosaur> hm
19:38:39 <geekosaur> my next question would be whether they understand partial application :)
19:39:23 <dfeuer> @tell hexagoxel I just got your message; I look forward to seeing what you came up with. Lennart Spitzner has also come up with something interesting, but it sounds like yours is probably different.
19:39:23 <lambdabot> Consider it noted.
19:39:40 <jasonkuhrt> back
19:39:58 <roboguy`> jasonkuhrt: you might want to consider the fact that you can change the order of the arguments. The connection doesn't have to be first
19:40:34 <jasonkuhrt> is the same as ... (-> x1 (-> x2 x3) 
19:40:41 <cheater> wow encoding everything in types and typeclasses really makes things more legible when reading a handwavy cryptography paper
19:40:51 <jasonkuhrt> so (Reader x1 (Reader x2 x3)
19:40:52 <jasonkuhrt> ?
19:40:54 <dmj`> jasonkuhrt: are you familiar with kinds?
19:41:21 <jasonkuhrt> dmj': Somewhat but only in the basic idea/descriptive not practice. Its types of types, curried etc.
19:41:50 <roboguy`> you really only need to carry the one argument in the Reader, in this case
19:42:11 <jasonkuhrt> roboguy`: Yeah just the Redis connection
19:42:42 <jasonkuhrt> Reader x1 (x2 -> x3)
19:42:44 <roboguy`> jasonkuhrt: yeah. why are you looking for multiple Readers/a reader with multiple arguments?
19:43:26 <roboguy`> that would be one way to approach it
19:43:28 <jasonkuhrt> roboguy`: I was musing that translation of function-to-Reader but you are right I think its certainly not my use-case
19:44:00 <dmj`> jasonkuhrt: so the exercise is to extract the redis connection out of the reader, and perform some IO operation, with the connection
19:44:14 <jasonkuhrt> dmj`: Yep
19:46:21 <dmj`> so you'll need to add IO to your Reader
19:46:43 <dmj`> let's assume your Connection type is of kind * (which it probably is)
19:46:50 <Welkin> hi dmj` 
19:46:55 <dmj`> @def type Connection = (() :: *)
19:46:56 <lambdabot>  Defined.
19:47:02 <dmj`> :k ReaderT
19:47:03 <lambdabot> * -> (* -> *) -> * -> *
19:47:18 <dmj`> :k ReaderT (Connection :: *) (IO :: * -> *) (() :: *)
19:47:20 <lambdabot> *
19:47:39 <dmj`> jasonkuhrt: notice how that last type yielded kind *, meaning this is a concrete type
19:48:04 <dmj`> Welkin: o/
19:49:18 <dmj`> jasonkuhrt: so `Reader` is actually defined in terms of `ReaderT` in mtl type Reader r a = ReaderT r Identity a :), and they are both instances of MonadReader, which gives you the `ask` function
19:50:26 <dmj`> so we can make the type more abstract actually
19:50:38 <dmj`> @def doTheRedisThing :: (MonadIO m, MonadReader Connection m) => m (); doTheRedisThing = ask >>= liftIO . print
19:50:39 <lambdabot>  Defined.
19:52:18 <jasonkuhrt> dmj`: Thanks, have to go but saving these thoughts for later.
19:52:19 <dmj`> instead of printing, `ask` will give you the Connection, but just substitute print for ask >>= \conn -> do liftIO $ runRedis con (get "foo")
20:08:51 <rubystallion> I'm compiling leksah for a few hours already now and I noticed that I forgot to enable parallel build. Could I just abort compilation with Ctrl-C and then restart with the right flags or would that recompile all the files?
20:10:38 <Koterpillar> if it's just a cabal/ghc build, yes
20:11:00 <Koterpillar> at least if you set the flags on the command line
20:28:00 <rubystallion> Koterpillar: Sorry, that didn't work, it's doing the whole compile again now :( Previous command was cabal install leksah, new command is cabal install -j leksah
20:29:02 <Koterpillar> sorry :( is it redoing the same packages?
20:30:33 <rubystallion> Koterpillar: yes, it is. 
20:30:57 <Koterpillar> stack won't
20:31:49 <rubystallion> Koterpillar: ok
20:44:08 * hackagebot lens-family-core 1.2.1 - Haskell 98 Lens Families  https://hackage.haskell.org/package/lens-family-core-1.2.1 (RussellOConnor)
20:44:10 * hackagebot lens-family 1.2.1 - Lens Families  https://hackage.haskell.org/package/lens-family-1.2.1 (RussellOConnor)
20:50:19 <idev> is ghc8 usable yet, or are most libraries / stack still broken?
20:51:14 <dfeuer> idev, there are probably still a lot of broken libraries.
21:04:05 <glguy> idev: It's not all or nothing; you have have multiple versions installed
21:05:42 <roconnor> sm: the KEX algorithms offered by SSH on hub.darcs.net den are sort-of obsolete.
21:06:02 <roconnor> sm: though I understand it isn't so easy to fix.
21:10:08 <mjrosenb> read x can't be polymorphic, can it?
21:11:00 <mjrosenb> like case (ty, read x) of (Int, x) -> x+2; (Str, x) -> x ++ ", nice try"
21:11:18 <shachaf> read x is polymorphic
21:11:47 <shachaf> But what you're trying to do is impredicative.
21:11:54 <shachaf> And also a type error.
21:12:29 <shachaf> read :: String -> (forall a. Read a => a)
21:12:35 <shachaf> show :: (exists a. Show a *> a) -> String
21:12:44 <glguy> Even without the impredicativity mandated by the use of a tuple there, case would make a monomorphic binding
21:12:50 <glguy> case read x of y ->
21:13:13 <shachaf> Well, yes.
21:13:24 <shachaf> But you could write let y = read x in case z of ...
21:13:27 <mjrosenb> right. so I can do it with nested cases, or pattern guards.
21:13:45 <shachaf> But you still need a type for the value of the whole case expression.
21:14:09 * hackagebot gogol-core 0.1.0 - Core data types and functionality for Gogol libraries.  https://hackage.haskell.org/package/gogol-core-0.1.0 (BrendanHay)
21:14:11 * hackagebot gogol 0.1.0 - Comprehensive Google Services SDK.  https://hackage.haskell.org/package/gogol-0.1.0 (BrendanHay)
21:14:14 * hackagebot gogol-discovery 0.1.0 - Google APIs Discovery Service SDK.  https://hackage.haskell.org/package/gogol-discovery-0.1.0 (BrendanHay)
21:14:16 * hackagebot gogol-deploymentmanager 0.1.0 - Google Cloud Deployment Manager SDK.  https://hackage.haskell.org/package/gogol-deploymentmanager-0.1.0 (BrendanHay)
21:14:18 * hackagebot gogol-maps-coordinate 0.1.0 - Google Maps Coordinate SDK.  https://hackage.haskell.org/package/gogol-maps-coordinate-0.1.0 (BrendanHay)
21:16:29 <reckbo> guys I have a quick question: why does ' (fmap . fmap) sum Just [1,2,3]' return 'Just 6'? It seems like it should work with only one fmap
21:17:23 <mjrosenb> reckbo: that looks like you're first mapping Just over [1,2,3]
21:17:52 <mjrosenb> :t (fmap . fmap)
21:17:54 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:18:14 <glguy> reckbo: Because fmap on functions is (.)
21:18:39 <lpaste> glguy pasted “for reckbo” at http://lpaste.net/167228
21:19:20 * hackagebot gogol-bigquery 0.1.0 - Google BigQuery SDK.  https://hackage.haskell.org/package/gogol-bigquery-0.1.0 (BrendanHay)
21:19:22 * hackagebot gogol-groups-settings 0.1.0 - Google Groups Settings SDK.  https://hackage.haskell.org/package/gogol-groups-settings-0.1.0 (BrendanHay)
21:19:24 * hackagebot gogol-appstate 0.1.0 - Google App State SDK.  https://hackage.haskell.org/package/gogol-appstate-0.1.0 (BrendanHay)
21:19:26 * hackagebot gogol-cloudmonitoring 0.1.0 - Google Cloud Monitoring SDK.  https://hackage.haskell.org/package/gogol-cloudmonitoring-0.1.0 (BrendanHay)
21:19:28 * hackagebot gogol-resourceviews 0.1.0 - Google Compute Engine Instance Groups SDK.  https://hackage.haskell.org/package/gogol-resourceviews-0.1.0 (BrendanHay)
21:21:06 <reckbo> ah ok I think I get it
21:21:19 <reckbo> an fmap is acting as composition?
21:21:46 <dibblego> "the thing to fmap over Maybe is fmap over []"
21:21:51 <mjrosenb> @src Id
21:21:51 <lambdabot> Source not found. Are you typing with your feet?
21:22:05 <mjrosenb> where is Id defined?
21:22:25 <Koterpillar> @src id
21:22:25 <lambdabot> id x = x
21:22:39 <glguy> 03instance Functor ( (07->) r ) 03where fmap 07= (07.)
21:22:56 <mjrosenb> no, newtype Id x = Id {unId :: x}
21:23:09 <reckbo> great, thanks glguy!
21:23:26 <mjrosenb> along with a Functor etc. instance
21:24:18 <Koterpillar> do you mean Identity?
21:24:21 <reckbo> and thanks mjrosenb
21:24:25 <mjrosenb> sure
21:24:30 * hackagebot gogol-dfareporting 0.1.0 - Google DCM/DFA Reporting And Trafficking SDK.  https://hackage.haskell.org/package/gogol-dfareporting-0.1.0 (BrendanHay)
21:24:32 * hackagebot gogol-admin-emailmigration 0.1.0 - Google Email Migration API v2 SDK.  https://hackage.haskell.org/package/gogol-admin-emailmigration-0.1.0 (BrendanHay)
21:24:34 * hackagebot gogol-plus 0.1.0 - Google + SDK.  https://hackage.haskell.org/package/gogol-plus-0.1.0 (BrendanHay)
21:24:35 <mjrosenb> reckbo: pretty supe my answer was wrong :-p
21:24:36 * hackagebot gogol-dataflow 0.1.0 - Google Dataflow SDK.  https://hackage.haskell.org/package/gogol-dataflow-0.1.0 (BrendanHay)
21:24:38 * hackagebot gogol-blogger 0.1.0 - Google Blogger SDK.  https://hackage.haskell.org/package/gogol-blogger-0.1.0 (BrendanHay)
21:24:40 <Koterpillar> mjrosenb: this? https://hackage.haskell.org/package/transformers-0.2.2.1/docs/Data-Functor-Identity.html
21:27:12 <mjrosenb> Koterpillar: looks like it
21:27:28 <mjrosenb> I'm kind of surprised that I need a non-base package for that.
21:28:06 <glguy> mjrosenb: It's in base now, Koterpillar is citing a pretty old version of transformers
21:28:06 <Koterpillar> if you need Functor, you can derive it
21:28:15 <Koterpillar> I blame Hoogle
21:28:31 <mjrosenb> glguy: still data.functor.identity?
21:29:40 * hackagebot gogol-play-moviespartner 0.1.0 - Google Play Movies Partner SDK.  https://hackage.haskell.org/package/gogol-play-moviespartner-0.1.0 (BrendanHay)
21:29:42 * hackagebot gogol-fitness 0.1.0 - Google Fitness SDK.  https://hackage.haskell.org/package/gogol-fitness-0.1.0 (BrendanHay)
21:29:44 * hackagebot gogol-games-management 0.1.0 - Google Play Game Services Management SDK.  https://hackage.haskell.org/package/gogol-games-management-0.1.0 (BrendanHay)
21:29:46 * hackagebot gogol-translate 0.1.0 - Google Translate SDK.  https://hackage.haskell.org/package/gogol-translate-0.1.0 (BrendanHay)
21:29:48 * hackagebot gogol-webmaster-tools 0.1.0 - Google Search Console SDK.  https://hackage.haskell.org/package/gogol-webmaster-tools-0.1.0 (BrendanHay)
21:33:56 <mjrosenb> how do I use the Type Constructor for lists?
21:34:02 <mjrosenb> rather, what is it called?
21:34:18 <EvanR> []
21:34:32 <EvanR> :k []
21:34:33 <lambdabot> * -> *
21:34:40 <EvanR> :k ([] Int)
21:34:41 <lambdabot> *
21:34:50 * hackagebot gogol-monitoring 0.1.0 - Google Monitoring SDK.  https://hackage.haskell.org/package/gogol-monitoring-0.1.0 (BrendanHay)
21:34:52 * hackagebot gogol-replicapool-updater 0.1.0 - Google Compute Engine Instance Group Updater SDK.  https://hackage.haskell.org/package/gogol-replicapool-updater-0.1.0 (BrendanHay)
21:34:54 * hackagebot gogol-tagmanager 0.1.0 - Google Tag Manager SDK.  https://hackage.haskell.org/package/gogol-tagmanager-0.1.0 (BrendanHay)
21:34:56 * hackagebot gogol-mirror 0.1.0 - Google Mirror SDK.  https://hackage.haskell.org/package/gogol-mirror-0.1.0 (BrendanHay)
21:34:58 * hackagebot gogol-resourcemanager 0.1.0 - Google Cloud Resource Manager SDK.  https://hackage.haskell.org/package/gogol-resourcemanager-0.1.0 (BrendanHay)
21:40:00 * hackagebot gogol-admin-datatransfer 0.1.0 - Google Admin Data Transfer SDK.  https://hackage.haskell.org/package/gogol-admin-datatransfer-0.1.0 (BrendanHay)
21:40:02 * hackagebot gogol-genomics 0.1.0 - Google Genomics SDK.  https://hackage.haskell.org/package/gogol-genomics-0.1.0 (BrendanHay)
21:40:04 * hackagebot gogol-apps-tasks 0.1.0 - Google Tasks SDK.  https://hackage.haskell.org/package/gogol-apps-tasks-0.1.0 (BrendanHay)
21:40:06 * hackagebot gogol-spectrum 0.1.0 - Google Spectrum Database SDK.  https://hackage.haskell.org/package/gogol-spectrum-0.1.0 (BrendanHay)
21:40:08 * hackagebot gogol-urlshortener 0.1.0 - Google URL Shortener SDK.  https://hackage.haskell.org/package/gogol-urlshortener-0.1.0 (BrendanHay)
21:45:10 * hackagebot gogol-apps-reseller 0.1.0 - Google Enterprise Apps Reseller SDK.  https://hackage.haskell.org/package/gogol-apps-reseller-0.1.0 (BrendanHay)
21:45:12 * hackagebot gogol-admin-reports 0.1.0 - Google Admin Reports SDK.  https://hackage.haskell.org/package/gogol-admin-reports-0.1.0 (BrendanHay)
21:45:14 * hackagebot gogol-admin-directory 0.1.0 - Google Admin Directory SDK.  https://hackage.haskell.org/package/gogol-admin-directory-0.1.0 (BrendanHay)
21:45:16 * hackagebot gogol-apps-licensing 0.1.0 - Google Enterprise License Manager SDK.  https://hackage.haskell.org/package/gogol-apps-licensing-0.1.0 (BrendanHay)
21:45:18 * hackagebot gogol-datastore 0.1.0 - Google Cloud Datastore SDK.  https://hackage.haskell.org/package/gogol-datastore-0.1.0 (BrendanHay)
21:45:33 <Koterpillar> hackagebot needs bundled updates :\
21:45:41 <mjrosenb> EvanR: thanks.  turns out, I had it correct, and another bug right next to it.
21:50:20 * hackagebot gogol-adexchange-seller 0.1.0 - Google Ad Exchange Seller SDK.  https://hackage.haskell.org/package/gogol-adexchange-seller-0.1.0 (BrendanHay)
21:50:22 * hackagebot gogol-pubsub 0.1.0 - Google Cloud Pub/Sub SDK.  https://hackage.haskell.org/package/gogol-pubsub-0.1.0 (BrendanHay)
21:50:24 * hackagebot gogol-latencytest 0.1.0 - Google Cloud Network Performance Monitoring SDK.  https://hackage.haskell.org/package/gogol-latencytest-0.1.0 (BrendanHay)
21:50:26 * hackagebot gogol-sqladmin 0.1.0 - Google Cloud SQL Administration SDK.  https://hackage.haskell.org/package/gogol-sqladmin-0.1.0 (BrendanHay)
21:50:28 * hackagebot gogol-replicapool 0.1.0 - Google Compute Engine Instance Group Manager SDK.  https://hackage.haskell.org/package/gogol-replicapool-0.1.0 (BrendanHay)
21:50:55 * EvanR gets washed away by gogol
21:51:29 <kadoban> You haven't ignored hackagebot yet?
21:51:53 <EvanR> i need to stay up to date with the latest left-pad package
21:51:53 <monochrom> I haven't. It's OK.
21:51:53 <kadoban> Seems like the only way to get by for now, until its announcements somehow get less spammy.
21:51:58 <Cale> You've got to let the waves of gogol crash over you
21:52:08 <Cale> it's sort of relaxing after a while
21:52:48 <cdsmith> If only all spam were caused by people writing too many high-quality practical Haskell libraries. :)
21:55:30 * hackagebot gogol-oauth2 0.1.0 - Google OAuth2 SDK.  https://hackage.haskell.org/package/gogol-oauth2-0.1.0 (BrendanHay)
21:55:32 * hackagebot gogol-youtube 0.1.0 - Google YouTube Data SDK.  https://hackage.haskell.org/package/gogol-youtube-0.1.0 (BrendanHay)
21:55:34 * hackagebot gogol-billing 0.1.0 - Google Cloud Billing SDK.  https://hackage.haskell.org/package/gogol-billing-0.1.0 (BrendanHay)
21:55:36 * hackagebot gogol-container 0.1.0 - Google Container Engine SDK.  https://hackage.haskell.org/package/gogol-container-0.1.0 (BrendanHay)
21:55:38 * hackagebot gogol-classroom 0.1.0 - Google Classroom SDK.  https://hackage.haskell.org/package/gogol-classroom-0.1.0 (BrendanHay)
21:55:52 <thimoteus> i was promised gogol-leftpad
21:57:43 <cdsmith> Google doesn't offer this functionality in its Cloud SDK.  However, there is http://left-pad.io/
21:57:54 <thimoteus> it'll do
21:59:28 <Axman6> yay, Brendan's making more awesome stuff!
22:00:40 * hackagebot gogol-gmail 0.1.0 - Google Gmail SDK.  https://hackage.haskell.org/package/gogol-gmail-0.1.0 (BrendanHay)
22:00:42 * hackagebot gogol-affiliates 0.1.0 - Google Affiliate Network SDK.  https://hackage.haskell.org/package/gogol-affiliates-0.1.0 (BrendanHay)
22:00:44 * hackagebot gogol-fonts 0.1.0 - Google Fonts Developer SDK.  https://hackage.haskell.org/package/gogol-fonts-0.1.0 (BrendanHay)
22:00:46 * hackagebot gogol-games-configuration 0.1.0 - Google Play Game Services Publishing SDK.  https://hackage.haskell.org/package/gogol-games-configuration-0.1.0 (BrendanHay)
22:00:48 * hackagebot gogol-useraccounts 0.1.0 - Google Cloud User Accounts SDK.  https://hackage.haskell.org/package/gogol-useraccounts-0.1.0 (BrendanHay)
22:05:50 * hackagebot gogol-android-publisher 0.1.0 - Google Play Developer SDK.  https://hackage.haskell.org/package/gogol-android-publisher-0.1.0 (BrendanHay)
22:05:52 * hackagebot gogol-freebasesearch 0.1.0 - Google Freebase Search SDK.  https://hackage.haskell.org/package/gogol-freebasesearch-0.1.0 (BrendanHay)
22:05:54 * hackagebot gogol-drive 0.1.0 - Google Drive SDK.  https://hackage.haskell.org/package/gogol-drive-0.1.0 (BrendanHay)
22:05:56 * hackagebot gogol-fusiontables 0.1.0 - Google Fusion Tables SDK.  https://hackage.haskell.org/package/gogol-fusiontables-0.1.0 (BrendanHay)
22:05:58 * hackagebot gogol-android-enterprise 0.1.0 - Google Play EMM SDK.  https://hackage.haskell.org/package/gogol-android-enterprise-0.1.0 (BrendanHay)
22:11:00 * hackagebot gogol-youtube-analytics 0.1.0 - Google YouTube Analytics SDK.  https://hackage.haskell.org/package/gogol-youtube-analytics-0.1.0 (BrendanHay)
22:11:02 * hackagebot gogol-compute 0.1.0 - Google Compute Engine SDK.  https://hackage.haskell.org/package/gogol-compute-0.1.0 (BrendanHay)
22:11:04 * hackagebot gogol-games 0.1.0 - Google Play Game Services SDK.  https://hackage.haskell.org/package/gogol-games-0.1.0 (BrendanHay)
22:11:06 * hackagebot gogol-taskqueue 0.1.0 - Google TaskQueue SDK.  https://hackage.haskell.org/package/gogol-taskqueue-0.1.0 (BrendanHay)
22:11:08 * hackagebot gogol-apps-activity 0.1.0 - Google Apps Activity SDK.  https://hackage.haskell.org/package/gogol-apps-activity-0.1.0 (BrendanHay)
22:16:10 * hackagebot gogol-debugger 0.1.0 - Google Cloud Debugger SDK.  https://hackage.haskell.org/package/gogol-debugger-0.1.0 (BrendanHay)
22:16:12 * hackagebot gogol-dataproc 0.1.0 - Google Cloud Dataproc SDK.  https://hackage.haskell.org/package/gogol-dataproc-0.1.0 (BrendanHay)
22:16:14 * hackagebot gogol-doubleclick-search 0.1.0 - Google DoubleClick Search SDK.  https://hackage.haskell.org/package/gogol-doubleclick-search-0.1.0 (BrendanHay)
22:16:16 * hackagebot gogol-people 0.1.0 - Google People SDK.  https://hackage.haskell.org/package/gogol-people-0.1.0 (BrendanHay)
22:16:18 * hackagebot gogol-maps-engine 0.1.0 - Google Maps Engine SDK.  https://hackage.haskell.org/package/gogol-maps-engine-0.1.0 (BrendanHay)
22:21:20 * hackagebot gogol-books 0.1.0 - Google Books SDK.  https://hackage.haskell.org/package/gogol-books-0.1.0 (BrendanHay)
22:21:22 * hackagebot gogol-storage 0.1.0 - Google Cloud Storage JSON SDK.  https://hackage.haskell.org/package/gogol-storage-0.1.0 (BrendanHay)
22:21:24 * hackagebot gogol-adsense-host 0.1.0 - Google AdSense Host SDK.  https://hackage.haskell.org/package/gogol-adsense-host-0.1.0 (BrendanHay)
22:21:26 * hackagebot gogol-apps-calendar 0.1.0 - Google Calendar SDK.  https://hackage.haskell.org/package/gogol-apps-calendar-0.1.0 (BrendanHay)
22:21:28 * hackagebot gogol-qpxexpress 0.1.0 - Google QPX Express SDK.  https://hackage.haskell.org/package/gogol-qpxexpress-0.1.0 (BrendanHay)
22:26:18 <phanimahesh> what's happening? So many packages at once, all related to google
22:26:30 * hackagebot gogol-storage-transfer 0.1.0 - Google Storage Transfer SDK.  https://hackage.haskell.org/package/gogol-storage-transfer-0.1.0 (BrendanHay)
22:26:32 * hackagebot gogol-adexchange-buyer 0.1.0 - Google Ad Exchange Buyer SDK.  https://hackage.haskell.org/package/gogol-adexchange-buyer-0.1.0 (BrendanHay)
22:26:34 * hackagebot gogol-firebase-rules 0.1.0 - Google Firebase Rules SDK.  https://hackage.haskell.org/package/gogol-firebase-rules-0.1.0 (BrendanHay)
22:26:36 * hackagebot gogol-customsearch 0.1.0 - Google CustomSearch SDK.  https://hackage.haskell.org/package/gogol-customsearch-0.1.0 (BrendanHay)
22:26:38 * hackagebot gogol-groups-migration 0.1.0 - Google Groups Migration SDK.  https://hackage.haskell.org/package/gogol-groups-migration-0.1.0 (BrendanHay)
22:31:40 * hackagebot gogol-appengine 0.1.0 - Google App Engine Admin SDK.  https://hackage.haskell.org/package/gogol-appengine-0.1.0 (BrendanHay)
22:31:42 * hackagebot gogol-siteverification 0.1.0 - Google Site Verification SDK.  https://hackage.haskell.org/package/gogol-siteverification-0.1.0 (BrendanHay)
22:31:44 * hackagebot gogol-sheets 0.1.0 - Google Sheets SDK.  https://hackage.haskell.org/package/gogol-sheets-0.1.0 (BrendanHay)
22:31:46 * hackagebot gogol-doubleclick-bids 0.1.0 - Google DoubleClick Bid Manager SDK.  https://hackage.haskell.org/package/gogol-doubleclick-bids-0.1.0 (BrendanHay)
22:31:48 * hackagebot gogol-prediction 0.1.0 - Google Prediction SDK.  https://hackage.haskell.org/package/gogol-prediction-0.1.0 (BrendanHay)
22:36:50 * hackagebot gogol-vision 0.1.0 - Google Cloud Vision SDK.  https://hackage.haskell.org/package/gogol-vision-0.1.0 (BrendanHay)
22:36:52 * hackagebot gogol-logging 0.1.0 - Google Cloud Logging SDK.  https://hackage.haskell.org/package/gogol-logging-0.1.0 (BrendanHay)
22:36:54 * hackagebot gogol-partners 0.1.0 - Google Partners SDK.  https://hackage.haskell.org/package/gogol-partners-0.1.0 (BrendanHay)
22:36:57 * hackagebot gogol-analytics 0.1.0 - Google Analytics SDK.  https://hackage.haskell.org/package/gogol-analytics-0.1.0 (BrendanHay)
22:36:59 * hackagebot gogol-shopping-content 0.1.0 - Google Content API for Shopping SDK.  https://hackage.haskell.org/package/gogol-shopping-content-0.1.0 (BrendanHay)
22:39:47 <roboguy`> the latest commit messages on github for those packages imply that a lot of the changes were automatically generated (I assume from changes to Google's API)
22:40:59 <jle`> a challenger has arrived to compete with amazonka
22:42:01 * hackagebot gogol-plus-domains 0.1.0 - Google + Domains SDK.  https://hackage.haskell.org/package/gogol-plus-domains-0.1.0 (BrendanHay)
22:42:03 * hackagebot gogol-proximitybeacon 0.1.0 - Google Proximity Beacon SDK.  https://hackage.haskell.org/package/gogol-proximitybeacon-0.1.0 (BrendanHay)
22:42:05 * hackagebot gogol-youtube-reporting 0.1.0 - Google YouTube Reporting SDK.  https://hackage.haskell.org/package/gogol-youtube-reporting-0.1.0 (BrendanHay)
22:42:07 * hackagebot gogol-civicinfo 0.1.0 - Google Civic Information SDK.  https://hackage.haskell.org/package/gogol-civicinfo-0.1.0 (BrendanHay)
22:42:09 * hackagebot gogol-kgsearch 0.1.0 - Google Identity and Access Management SDK.  https://hackage.haskell.org/package/gogol-kgsearch-0.1.0 (BrendanHay)
22:42:57 <roboguy`> so many different Google SDKs...
22:45:37 <jle`> and all going to be obsolete/deprecated this day next year, unfortunately :'(
22:47:11 * hackagebot gogol-pagespeed 0.1.0 - Google PageSpeed Insights SDK.  https://hackage.haskell.org/package/gogol-pagespeed-0.1.0 (BrendanHay)
22:47:13 * hackagebot gogol-adsense 0.1.0 - Google AdSense Management SDK.  https://hackage.haskell.org/package/gogol-adsense-0.1.0 (BrendanHay)
22:47:15 * hackagebot gogol-cloudtrace 0.1.0 - Google Cloud Trace SDK.  https://hackage.haskell.org/package/gogol-cloudtrace-0.1.0 (BrendanHay)
22:47:17 * hackagebot gogol-script 0.1.0 - Google Apps Script Execution SDK.  https://hackage.haskell.org/package/gogol-script-0.1.0 (BrendanHay)
22:47:19 * hackagebot gogol-dns 0.1.0 - Google Cloud DNS SDK.  https://hackage.haskell.org/package/gogol-dns-0.1.0 (BrendanHay)
22:52:21 * hackagebot gogol-identity-toolkit 0.1.0 - Google Identity Toolkit SDK.  https://hackage.haskell.org/package/gogol-identity-toolkit-0.1.0 (BrendanHay)
22:52:23 * hackagebot gogol-autoscaler 0.1.0 - Google Compute Engine Autoscaler SDK.  https://hackage.haskell.org/package/gogol-autoscaler-0.1.0 (BrendanHay)
23:00:18 <adarqui> jle`: why?
23:00:23 <adarqui> why obsolete
23:01:34 <jle`> google loves killing its platforms :)
23:01:48 <adarqui> o
23:11:18 <GGuy> Hi, does a more generic liftIO exist for Any monad? If not is it possible? something like "liftAny :: (MonadTrans t, MonadAny ma, Monad m) => m a -> t ma a".
23:12:28 <roboguy`> :t lift
23:12:30 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
23:12:44 <roboguy`> ^ GGuy
23:12:57 <GGuy> roboguy`: yeah lift only lifts one level
23:14:16 * hackagebot raaz 0.0.1 - The raaz cryptographic library.  https://hackage.haskell.org/package/raaz-0.0.1 (PiyushKurur)
23:14:30 <GGuy> I might not know the MonadTrans type upfront, only that i should contain a Monad somewhere up the chain
23:16:52 <Koterpillar> what is MonadAny?
23:19:15 <GGuy> Koterpillar: No idea. It's meant to be a monadtrans that eventually contains a Monad m. Like how MonadIO is a MonadTrans that eventually contains an IO.
23:20:57 <johnw> do you want MonadBase?
23:21:29 <GGuy> johnw: Probably... thanks!
23:24:17 * hackagebot aeson-coerce 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/aeson-coerce-0.1.0.0 (angerman)
