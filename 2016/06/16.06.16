00:00:42 <reqq456> ah
00:00:45 <reqq456> thats pretty cool
00:02:01 <koz_> Could someone advise me on this? http://lpaste.net/166394
00:02:47 <koz_> I feel like I'm inches away from actually being able to *use* traverse for the first time.
00:03:31 <reqq456> is there anything that is different between [Char] and String that i'm missing or it is really the same? and if so, which one should i use?
00:03:44 <sbrg> reqq456: they are literally the same thing
00:03:55 <sbrg> :info String
00:03:59 <koz_> reqq456: String is a type synonym for [Char]
00:03:59 <sbrg> @info String
00:03:59 <lambdabot> String
00:04:04 <sbrg> thanks lambdabot <.<
00:04:14 <koz_> @info Functor
00:04:14 <lambdabot> Functor
00:04:17 <koz_> ...
00:04:26 <Koterpillar> @info [Char]
00:04:26 <lambdabot> [Char]
00:04:35 <koz_> @info Doobie
00:04:35 <lambdabot> Doobie
00:04:35 <sbrg> Koterpillar: try :info String in ghci
00:04:38 <sbrg> type String = [Char]
00:04:41 <Xnuk> @hoogle String
00:04:45 <lambdabot> Prelude type String = [Char]
00:04:45 <lambdabot> Data.String type String = [Char]
00:04:45 <lambdabot> Data.String module Data.String
00:04:56 <koz_> @info 123
00:04:56 <lambdabot> 123
00:05:01 <reqq456> hehe
00:05:12 <sbrg> I guess @info = id for lambdabot or something
00:05:14 <sbrg> @info Monad
00:05:14 <lambdabot> Monad
00:05:16 <sbrg> <.<
00:05:22 <koz_> @info info
00:05:22 <lambdabot> info
00:05:25 <koz_> @info @info
00:05:25 <lambdabot> <unknown>.hs: 1: 1:Parse error: @
00:05:29 <koz_> Ah-hah!
00:05:40 <Koterpillar> @info 1 + 2
00:05:40 <lambdabot> 1 + 2
00:05:48 <koz_> @info \x -> x + 1
00:05:49 <lambdabot> \ x -> x + 1
00:06:01 <koz_> Wow, @info is so helpful...
00:06:01 <Koterpillar> @info do { x <- 1; x }
00:06:02 <lambdabot> 1 >>= \ x -> x
00:06:10 <Koterpillar> well, this is something at least
00:06:32 <koz_> @info do { x <- 1; y <- 2; return x + y }
00:06:32 <lambdabot> 1 >>= \ x -> 2 >>= \ y -> return x + y
00:07:13 <koz_> @info (,) <$> [1, 2, 3] <*> ['a', 'b', 'c']
00:07:13 <lambdabot> (,) <$> [1, 2, 3] <*> ['a', 'b', 'c']
00:07:31 <koz_> Koterpillar: Could you please help me out with this? http://lpaste.net/166394
00:07:46 <Xnuk> @undo do { x <- 1; y <- 2; return x + y }
00:07:46 <lambdabot> 1 >>= \ x -> 2 >>= \ y -> return x + y
00:08:16 * hackagebot phone-metadata 0.0.1.2 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.2 (raghuugare)
00:08:37 <Koterpillar> koz_: I want to confirm more things with lambdabot first...
00:08:48 <sbrg> lol
00:09:00 <sbrg> koz_: what do you want to do exactly?
00:09:01 <oherrala> reqq456: If you need to handle text, see Data.Text. 
00:09:52 <koz_> sbrg: It should all be explained there. I'm trying to make a subroutine for an Arbitrary instance for the Expr type.
00:09:58 <Koterpillar> koz_: \i -> elements [Var i, Neg $ Var i]
00:10:06 <Koterpillar> something like that?
00:10:08 <koz_> Koterpillar: Derp, thank you!
00:10:14 <koz_> I was overthinking it.
00:10:19 <Koterpillar> untested!
00:11:46 <koz_> Koterpillar: Untested?
00:12:02 <Koterpillar> as in, I'm not even sure that's the right type
00:13:21 <koz_> That *is* the right type.
00:13:48 <koz_> That makes a Gen Expr, that gets applied by traverse to form a [Gen Expr], then traverse pulls out the Gen to make a Gen [Expr].
00:14:01 <Koterpillar> so... traverse is mapM
00:14:09 <koz_> :t traverse
00:14:10 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:14:12 <koz_> :t mapM
00:14:14 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
00:14:19 <koz_> Yes.
00:14:39 <koz_> Except with a weaker constraint.
00:14:56 * koz_ likes Applicatives.
00:15:08 * Koterpillar needs to get more Applicatives.
00:16:25 <koz_> I use Applicatives whenever possible - I feel I get them a *bit* more than I do monads.
00:16:32 <koz_> (not that I claim to get them all that well)
00:16:40 <koz_> But I feel happy I got that I needed traverse here!
00:17:25 <platz> @djinn Either e (fa -> fb) -> Either e fa  -> Either e fb
00:17:25 <lambdabot> f a b =
00:17:25 <lambdabot>     case a of
00:17:25 <lambdabot>     Left c -> Left c
00:17:25 <lambdabot>     Right d -> case b of
00:17:25 <lambdabot>                Left e -> Left e
00:17:27 <lambdabot>                Right f -> Right (d f)
00:18:04 <koz_> @djinn Applicative f => f a -> f b -> f a
00:18:05 <lambdabot> Error: Class not found: Applicative
00:18:14 <koz_> @djinn Monad f => f a -> f b -> f a
00:18:15 <lambdabot> f a _ = a
00:18:24 <koz_> :(
00:18:29 <platz> doesn't do typeclasses unfortunately
00:19:02 <platz> it found `const` for you quite effectively though :)
00:20:07 <koz_> platz: Lol.
00:20:38 <koz_> @djinn (a -> b) -> (b -> c) -> [a] -> [c]
00:20:38 <lambdabot> Error: Undefined type []
00:20:44 <koz_> For realz...
00:20:57 <Koterpillar> map . (.)
00:21:02 <Koterpillar> :t map . (.)
00:21:03 <lambdabot> (b -> c) -> [a -> b] -> [a -> c]
00:21:15 <Koterpillar> oops
00:23:28 <platz> @djinn-names
00:23:28 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool
00:25:24 <koz_> Koterpillar: Is there a way to write this more concisely? elements [Conj one two rest, Neg . Conj one two $ rest]
00:27:02 <Koterpillar> elements [Conj, Neg . Conj], and apply the rest of the arguments afterwards
00:27:07 <Koterpillar> but!
00:27:17 <koz_> Koterpillar: I tried doing this using <*>, but it didn't like it very much.
00:27:43 <koz_> :t (<*>)
00:27:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:27:45 <Koterpillar> I have a feeling what you want is maybeNeg :: Gen (Expr -> Expr); maybeNeg = elements [id, Neg]
00:27:57 <Koterpillar> and then maybeNeg <*> stuff
00:28:17 <koz_> Koterpillar: That's a good point actually. I still wanna understand how I'm misusing <*> first, though.
00:28:35 <Koterpillar> :t liftA3
00:28:36 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
00:29:00 <Koterpillar> nope, not this
00:29:44 <Koterpillar> maybeNeg <*> pure one <*> pure two <*> pure rest
00:30:17 <koz_> Koterpillar: Tried that (or its equivalent) - still unhappy.
00:30:29 <Koterpillar> how unhappy?
00:30:53 <koz_> elements [Conj, Neg . Conj] <*> pure one <*> pure two <*> pure rest <-- what I wrote
00:31:16 <Koterpillar> :t elements [id, id] <*> pure 1
00:31:19 <lambdabot> Num b => Gen b
00:31:23 <lpaste> koz_ pasted “What it spewed” at http://lpaste.net/166397
00:31:47 <Koterpillar> ah,
00:32:01 <Koterpillar> you can't use . to chain functions of more than 1 argument
00:32:08 <koz_> So a lambda?
00:32:11 <Koterpillar> [yes, I know all functions are functions of 1 argument]
00:32:16 <Koterpillar> I would go with maybeNeg
00:32:32 <Koterpillar> because you needed it for Var already
00:32:36 <Koterpillar> and then Disj
00:32:53 <Koterpillar> in fact, are one, two and rest pure?
00:32:56 <koz_> Koterpillar: Yeah, you're right - will do that.
00:33:05 <koz_> Koterpillar: Yes - they all need pure-ing for this to work.
00:33:17 <Koterpillar> then you can do
00:33:29 <Koterpillar> elements [id, Neg] <*> (Conj one two rest)
00:33:38 <platz> @djinn-add type EitherC a b r = (a -> r) -> (b -> r) -> r
00:33:39 <Koterpillar> oh, sorry, pure
00:33:43 <platz> @djinn EitherC e (fa -> fb) r -> EitherC e fa r -> EitherC e fb r
00:33:44 <lambdabot> f a b c d = b c (\ e -> a c (\ f -> d (f e)))
00:33:48 <koz_> elements [id, Neg] == maybeNeg right?
00:33:56 <Koterpillar> yes
00:33:59 <koz_> What was the type of maybeNeg meant to be again?
00:34:13 <Koterpillar> maybeNeg :: Gen (Expr -> Expr)
00:34:18 <koz_> Koterpillar: Thanks!
00:37:16 <koz_> Wow, GHC's new duplication reduction analysis is *awesome*.
00:37:27 <koz_> I was like 'OK, time to refactor ... wait, what's that warning?'.
00:37:36 <sbrg> koz_: what is that? 
00:37:42 <sbrg> something new in ghc 8?
00:39:37 <koz_> sbrg: Yeah. If you have two very similar functions, it hints at you to combine them.
00:39:40 <koz_> (like it did with me)
00:39:46 <koz_> (just now)
00:40:01 <koz_> Although the type of the refactored function isn't too nice.
00:40:10 <koz_> genCombine :: (Expr -> Expr -> [Expr] -> Expr) -> Gen [Expr] -> Gen Expr
00:43:17 * hackagebot hasql-transaction 0.4.5.1 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.5.1 (NikitaVolkov)
00:44:11 <nomeata> koz_: Is that documented in the user guide? I must have completely missed it.
00:45:32 <koz_> nomeata: I don't think so - because I did too.
00:45:45 <koz_> Unless hlint got a *serious* upgrade while I wasn't looking and it's coming from that.
00:45:55 * koz_ uses Flycheck with both hlint and GHC as checkers.
00:46:51 <nomeata> koz_: it sounds more like something that hlint should do
00:47:15 <koz_> nomeata: Possibly? Well, wherever it's coming from, I'm fucking thrilled.
00:49:34 <koz_> OK, I have a Gen (Expr -> Expr) and an [Expr], and I wanna get Gen [Expr] from them both. Is this a case for traverse, or something else?
00:50:44 <merijn> What is "Gen"?
00:51:17 <koz_> merijn: It's a monad (and Applicative) from QuickCheck.
00:52:03 <nomeata> koz_: mapM?
00:52:13 <nomeata> (or is that too old-school :-))
00:52:47 <koz_> nomeata: So the answer is 'yes koz_, you should be using traverse', lol.
00:53:15 <merijn> "map <$> (foo :: Gen (Expr -> Expr)) <*> pure (bar :: [Expr])"
00:53:17 * hackagebot docvim 0.3.1.2 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.2 (wincent)
00:53:21 <merijn> mapM isn't right
00:53:34 <merijn> Neither is traverse?
00:53:45 <koz_> merijn: So you're mapping fmap into the Gen?
00:54:24 <nomeata> :t mapM :: Monad m => m (a -> a) -> [a] -> m [a]
00:54:25 <lambdabot>     Couldn't match type ‘m1’ with ‘(->) a1’
00:54:25 <lambdabot>       ‘m1’ is a rigid type variable bound by
00:54:25 <lambdabot>            an expression type signature:
00:54:41 <nomeata> ok, its too early, sorry
00:55:47 <merijn> koz_: No, I'm fmapping map into the Gen
00:56:15 <merijn> map <$> gen :: Gen ([Expr] -> [Expr])
00:56:37 <merijn> Since "map (foo :: Expr -> Expr) :: [Expr] -> [Expr]"
00:56:37 <koz_> merijn: You are also fmapping fmap into the Gen. And mapping map into the Gen as well. :P
00:56:50 <koz_> (or rather, they're equivalent here)
00:57:02 <koz_> Amusingly, this can be written (<$>) <$> ...
00:57:14 <merijn> "mapping map into the gen" <- no, because map can't be applied to Gen
00:57:20 <merijn> fmapping fmap works
00:57:34 <koz_> merijn: Ah, yes. I'm too used to basic-prelude fixing that issue.
00:57:39 <koz_> (it defines map = fmap)
00:57:54 <koz_> Although these days, I mostly just use <$>
01:00:03 <osa1> hmmmm I wish it'd be possible to use pattern guards in <- bindings like in let.
01:17:55 <koz_> Ermigawd, finally wrote it!
01:18:20 <koz_> Probably *significantly* uglier than it needs to be, but I wrote it!
01:19:08 <merijn> koz_: Write it first, refactor later :p
01:19:34 <merijn> koz_: My "first attempts" at writing anything in haskell are usually horrid. But it's so easy to refactor that it doesn't matter
01:20:21 <koz_> merijn: Would you mind taking a look and offering suggestions?
01:21:37 <merijn> koz_: I can take a look, but if it takes me more than trivial amount of time to come up with a suggestion I'll probably give up :p
01:22:09 <koz_> merijn: Lol, well, I'll paste it up and you can make your own decision on how nontrivial the time required to make suggestions for this is. :)
01:22:18 <lpaste> koz_ pasted “Data type with Arbitrary instance egads” at http://lpaste.net/166409
01:24:28 <reqq456> can I do smth like a /= b /= c /= d?
01:24:52 <koz_> reqq456: You'd need parentheses I think.
01:25:00 <koz_> :t 1 /= 2 /= 3
01:25:02 <lambdabot>     Precedence parsing error
01:25:03 <lambdabot>         cannot mix ‘/=’ [infix 4] and ‘/=’ [infix 4] in the same infix expression
01:25:09 <koz_> Yep, parentheses needed.
01:25:19 <merijn> koz_: I would avoid the if/then/else
01:25:26 <merijn> koz_: Especially when combined with length
01:25:35 <merijn> length is almost always bad
01:25:38 <koz_> reqq456: Actually, it wouldn't work, on second thought.
01:25:50 <koz_> merijn: How else could I do this? Pattern matching?
01:26:41 <merijn> koz_: Yes
01:26:45 <reqq456> how can i test a unlike b unlike c etc?
01:26:48 <koz_> merijn: OK, I'll dothat.
01:26:54 <merijn> "case expr of [x] -> pure x; _ -> other"
01:27:13 <koz_> reqq456: Are you asking 'is this bunch of things all mutually distinct'?
01:27:29 <merijn> koz_: Imagine exprs is 1,000 entries. Why compute length (walk and force the entire list) if you only need to check two to decide if it's length 1 :)
01:27:37 <koz_> merijn: You make a valid point.
01:28:08 <quchen> allDistinct = go Set.empty where go _ [] = True; go seen (x:xs) | Set.member x seen = False | otherwise = go (Set.insert x seen) xs
01:28:31 <quchen> I think this might be what you want instead of a /= b /= c.
01:28:45 <merijn> koz_: Same with genCombine, why not pattern match instead of head/tail
01:30:20 <lpaste> merijn annotated “Data type with Arbitrary instance egads” with “Data type with Arbitrary instance egads (annotation)” at http://lpaste.net/166409#a166413
01:30:46 <merijn> koz_: That way of doing genCombine seems way simpler?
01:31:45 <koz_> merijn: That's pretty brilliant. Thank you - I will make that change also.
01:32:37 <koz_> I keep forgetting how easy it is to disassemble lists with pattern matching.
01:33:18 * hackagebot phone-metadata 0.0.1.3 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.3 (raghuugare)
01:43:16 <reqq456> http://sprunge.us/YKSZ can i make this more efficent? it is a task where every char can stand for any number between 0 and 9, but every char is a unique number
01:43:19 * hackagebot aur-api 0.1.2.1 - ArchLinux AUR json v5 API  https://hackage.haskell.org/package/aur-api-0.1.2.1 (wangbj)
01:43:45 <reqq456> this is running ~ 5 - 10 mins and i didn't have a result until now
01:44:53 <merijn> > replicateM 5 [0..9]
01:44:54 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,2],[0,0,0,0,3],[0,0,0,0,4],[0,0,0,0,5],[0,...
01:45:14 <merijn> well, I suppose you'd need to still turn the 5 element lists into a single digit
01:45:24 <merijn> But that's just "map calculateSingleNumber"
01:48:59 <kstt> hi
01:51:27 <kstt> In what type of situation would you expect a pure haskell program (no IO) to block (or loop?) idefinitly without consuming CPU ?
01:52:09 <mniip> that's impossible
01:52:29 <mniip> the only way to not consume CPU is to be stuck in a system call which is IO
01:53:08 <kstt> This is happing to me at the moment
01:53:20 <srhb> kstt: Perhaps you mean you're not maxing cpu?
01:53:26 <srhb> kstt: And not _not_ performing cpu, period.
01:54:04 <kstt> Well, no showing up in 'top', 0% ...
01:54:32 <merijn> mniip: No it's not
01:54:47 <merijn> It's perfectly possible to have an infinite looping pure program
01:54:56 <srhb> merijn: That consumes no cpu?
01:55:09 <kstt> I have written a tiny parser librairy (~50 LoC), in the form "String -> Maybe String". I also wrote instances for Functor, Applicative, Alternative.  When using many (default definition) it behaves as described above.
01:55:10 <merijn> oh, yeah, that's not right
01:55:13 <srhb> merijn: Indeed.
01:55:24 <merijn> kstt: unsafePerformIO? :p
01:55:32 <merijn> kstt: ghci or compiled?
01:55:40 <kstt> ah, ghci !
01:55:46 <kstt> if that matters
01:55:50 <merijn> Try compiling?
01:56:04 <mniip> merijn, without consuming CPU?
01:56:40 <mniip> the only thing that comes to mind is executing a pause instruction which introduces a hardware delay, but your task will still come up as consuming 100% CPU
01:56:58 <merijn> mniip: No, I read over the no CPU part
01:57:02 <merijn> But GHCi is weird anyway
01:57:15 <mniip> yeah
01:57:20 <mniip> maybe it'd deadlocked or something
01:57:48 <mniip> never experienced that but considering the wonky beast that ghci is, I wouldn't be surprised
01:58:08 <rydgel> hi, does anyone know a lib for parsing and querying Geo data from ShapeFile (.shp)?
01:58:19 * hackagebot conduit-merge 0.1.1.0 - Merge multiple sorted conduits  https://hackage.haskell.org/package/conduit-merge-0.1.1.0 (cblp)
01:59:26 <rydgel> I'm currently using postgresql as proxy, converting those shapefile into gis table. But I want to remove that SQL part if possible
01:59:59 <rydgel> There seems to be TerraHS or something, but seems old and not very well documented
02:01:00 <kstt> merijn: mniip: okay sorry, looks like ghci-specific. Once compiled and run, I get : CalcApplicative: <<loop>>
02:01:39 <merijn> kstt: Basically, <<loop>> is when it detects that there's an infinite loop that will never terminate. (But it's not guaranteed to find that)
02:01:41 <mniip> kstt, you have a bottom
02:01:54 <merijn> GHC is usually better at detecting <<loop>> than ghci
02:03:30 <Hijiri> does ghci run threaded by default?
02:04:54 <Hijiri> if so, maybe the thread evaluating the bottom gets queued but the value is never evaluated? But then ghc compiles without threading by default, so instead blackholes
02:05:23 <mniip> ghci has at least 2 threads, yes
02:05:45 <sdx23> rydgel: http://hackage.haskell.org/package/readshp seems to be somewhat active
02:07:15 <idev> https://gist.github.com/anonymous/787955998e1fdbedf71369f9b5d8418a
02:07:18 <idev> how do I fix this
02:07:28 <idev> sorry, wrong channel
02:08:20 * hackagebot conduit-merge 0.1.2.0 - Merge multiple sorted conduits  https://hackage.haskell.org/package/conduit-merge-0.1.2.0 (cblp)
02:11:08 <rydgel> sdx23: thanks, will check it out
02:12:35 <sdx23> rydgel: well, "active" as in uploaded this year. But contributing there seems more sensible than the other two options.
02:13:52 <rydgel> sdx23: yeah. It seems to just parse the file. Still have to do my own interpretation of it after that.
02:14:26 <rydgel> sdx23: might be simpler to do a wrapper of a C lib or whatever already exists for that
02:14:47 <kstt> Thank you guys
02:21:31 <kstt> I found a minimal case to reproduce it in ghci : many (Just 1)
02:34:30 <rydgel> Actually a Haskell equivalent of Python's ogr is what I need
02:34:38 <unsafeHelloWorld> Hello! Has anyone had experience using server sent events in Servant? I've tried looking around but there doesn't seem to be a concrete example
02:43:30 <koz_> http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm <-- when I follow this advice, I error out on 'deriving (Data, Typeable)'. Am I missing something?
02:54:11 <koz_> OK, seems I need to import Data.Data. Is this a new thing?
02:54:41 <sshine> if it was taken out of Prelude?
03:04:40 <rydgel> Oh I found this https://github.com/ewestern/geos, I just need to convert the .shp into .wkb
03:08:49 <rydgel> I'm doing a toy project in Haskell, that will support various geo queries like get the country with latitude/longitude. Get nearest town around you and so on
03:12:07 <koz_> Could someone help me understand the correct way to use rewrite from uniplate?
03:12:17 <koz_> I'm a little confused how I would write a function to go with it.
03:12:38 <koz_> My *guess* is that it should Nothing-out on anything it can't rewrite?
03:21:23 <bergmark_> koz_: that seems like the logical behavior
03:22:35 <rydgel> what does mean /candidate in Hackage URL?
03:24:08 <rydgel> can I install a candidate with Stack directly?
03:24:38 <bergmark_> rydgel: point it to the url of the tarball
03:26:30 <rydgel> bergmark: ok thanks
03:27:41 <bergmark> candidates are described here https://hackage.haskell.org/upload
03:31:45 <osager> how to load un exported function of a module into ghci ?
03:32:01 <osager> i remember adding a * or something
03:54:20 <merijn> osager: Use ":load" instead of import
03:55:58 <koz_> 'Given two single transformations f and g, you can construct f mplus g which performs both rewrites until a fixed point.' <-- This is in reference to rewrite from uniplate. By 'transform', does it mean a function of type 'Uniplate on => on -> Maybe on', or something else?
03:56:38 <koz_> s/transform/'transformation'
03:58:56 <Xandaros> osager: You're thinking of :m +*module
04:10:43 <quicksilver> koz_: it means that, yes
04:11:05 <quicksilver> by 'transformation' it means 'first parameter to rewrite'
04:24:54 <unexisting> Hello guys. What's the current state of Haskell gamedev?
04:26:01 <maerwald> unexisting: nothing new there, nothing to be seen, move along :P
04:26:29 <Xandaros> -fdefer-typed-holes seems to also ignore undefined values that don't start with an underscore with GHC8. Is there some way to get the old behaviour, where only names starting with an underscore are considered holes?
04:26:43 <Xandaros> ocharles: Someone's asking about game dev again :P
04:26:50 <unexisting> What if I have an old dream of making some pixel-perfect retro thing, but allergic to low-level SDL/OpenGL stuff?
04:27:13 <maerwald> then you have to be the pioneer who writes the high-level libraries for that, gl
04:27:26 <squimmy> last time I checked (disclaimer: a long time ago) SDL was about as high-level as it got in haskell-land
04:27:27 <unexisting> Maybe there is more or less complete framework...
04:27:34 <maerwald> in idiomatic haskell? no
04:27:44 <Xandaros> unexisting: gloss is a very easy to use, high-level framework. Sucks with text or anything more complicated than geometric shapes, though :P
04:27:45 <unexisting> maerwald: okay :(
04:27:50 <maerwald> people use C++ and lua for gamedev
04:27:59 <Xandaros> the new sdl bindings are fairly high level
04:28:06 <Xandaros> Well, ‘new’
04:28:09 <maerwald> sdl is not an engine
04:28:25 <Xandaros> Nobody said “engine”
04:28:33 <maerwald> neither a game framework
04:28:49 <maerwald> sdl is used for non-game stuff even
04:28:54 <maerwald> it's fairly low-level
04:29:42 <maerwald> unexisting: there's also #haskell-game btw
04:30:13 <unexisting> maerwald: oh, shoulda visit that, thanks
04:45:04 <bernalex> unexisting: gloss is OK. very easy to use. but doesn't seem to easily scale beyond pong and asteroids.
04:46:29 <bernalex> unexisting: there are some new and shiny sdl2 bindings, but I do not know how high level they are. there's ogre3d bindings, but I have not used them. there's also hgamer3d -- see <http://www.hgamer3d.org/>. but basically, if you're not an engine programmer, you're not going to have a good time with haskell gamedev atm.
04:47:49 <magneticduck> unexisting: have you seem helm?
04:47:54 <bernalex> the hgamer space invaders example is quite nice (less than 300 SLOC). it would be great to have any actual middleware though.
04:48:08 <magneticduck> http://helm-engine.org/ -- the Haskell library, not the emacs package
04:48:18 <bernalex> I really wish we had "hsolarus". that would be amazing.
04:48:31 <magneticduck> I'm not sure how mature helm is, but it looks promising
04:49:10 <unexisting> bernalex: I used gloss for few little demos, but got entangled in complex nested states
04:49:46 <bernalex> magneticduck: helm looks cool, but it's got no examples or docs to speak of. I wouldn't write a game (beyond hangman or whatever) in it.
04:50:50 <unexisting> magneticduck: only a brief look. Experiencing some difficulties with FRP.
04:51:03 <magneticduck> oh right, it does require that you learn FRP
04:51:17 <magneticduck> but that's fun
04:51:52 <unexisting> I started with Game Maker as a kid and got imprinted with all that evil OO-stuff.
04:52:28 <unexisting> Now when I try to invert the control flow, it tries to invert my brain.
04:53:10 <tdammers> I don't think OO is inherently evil
04:53:15 <tdammers> it's just insufficient as a paradigm
04:54:00 <Xandaros> Yeah, the inverted control flow really takes a bit to wrap your head around
04:54:01 <bernalex> game maker has worse issues than OO. e.g. binary project files.
04:54:12 <locallycompact> No, it is inherent evilness
04:54:21 <Xandaros> I've personally only used gloss, both built on a state monad with lenses and with FRP. I much prefer the latter
04:54:33 <tdammers> locallycompact: it is in its popular manifestations
04:54:45 <tdammers> locallycompact: but I've done some OOP in Haskell that turned out pretty OK
04:54:54 <unexisting> magneticduck: er no, I've mixed up Helm with Elm. Though the former is the spiritual mate, I guess
04:55:39 <bernalex> saying that OOP is evil is merely dense hyperbole. the *holocaust* was an evil.
04:56:10 <tdammers> there are gradations of "evil", and it's contextual
04:56:24 <unexisting> bernalex: IMO the biggest issue of GM is its typing system. In some terms it's more fascinating than both JS and PHP.
04:56:58 <bernalex> tdammers: OOP was not designed with an intention to inflict harm on sentient beings. perhaps *using* it can be an evil.
04:57:01 <unexisting> bernalex: well, that was merely a hyperbola
04:57:37 <tdammers> bernalex: I think you know what people mean when they use the word "evil" in this context
04:57:45 <tdammers> bernalex: no point to go linguist on it
04:58:14 <bernalex> unexisting: I think that binary project files is by far the biggest issue. it prevents it from being used for anything serious. people use terrible languages for serious things all the time.
04:58:25 * hackagebot wai-extra 3.0.15.2 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.15.2 (MichaelSnoyman)
04:58:55 <bernalex> tdammers: if "evil" has suddenly began to signify "less productive than denotative programming", then I have not got that memo yet.
05:00:29 <bernalex> unexisting: in any event, it boils down to: what kind of gamedev do you want to do? if you are happy to hack on engines, then haskell is probably good enough for you. the rest of us would be incredibly keen on haskell middleware and game engines. if you want to use something like game maker middleware, then I'm afraid you're at least five years too early.
05:02:02 <tdammers> bernalex: it is generally taken to mean "exposes unexpected behavior that may lead to subtle yet unpleasant bugs"
05:02:42 <tdammers> e.g., in JS, "eval()" is considered "evil" because it may lead to unexpected code injection vulnerabilities
05:02:49 <tdammers> (and also because it's slow, but that's an aside)
05:02:54 <bernalex> tdammers: I got the memo that 'harmful' means that. I had not received the synonym appendix which stipulates that 'evil' is an acceptable alternative.
05:03:14 <tdammers> that's because it's informal
05:03:22 <tdammers> informal language doesn't have an RFC mechanism
05:03:23 <bernalex> personally I prefer to say that oop is poop. then again, I have a very sophisticated humour.
05:03:25 * hackagebot classy-prelude 0.12.8 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.8 (MichaelSnoyman)
05:03:27 * hackagebot classy-prelude-conduit 0.12.8 - conduit instances for classy-prelude  https://hackage.haskell.org/package/classy-prelude-conduit-0.12.8 (MichaelSnoyman)
05:03:29 * hackagebot classy-prelude-yesod 0.12.8 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.8 (MichaelSnoyman)
05:03:50 <tdammers> anyway, back to a more fruitful discussion
05:04:19 <tdammers> I think OOP has some ideas in it that are sometimes useful
05:04:36 <tdammers> but in the grand scheme of things, it's not usually a paradigm that solves more problems than it creates
05:04:44 <bernalex> that doesn't rhyme, so I prefer my sentiment.
05:04:45 <unexisting> bernalex: I wished for an engine where I could more or less declaratively describe some game entities, their time behaviour and IO response, and put them onto a scene.
05:04:57 <bernalex> unexisting: yeah. sorry about that. :)
05:05:49 <unexisting> Is it too hard to develop? Or nobody just had an interest?
05:05:59 <bernalex> unexisting: I would be incredibly happy to see something like solarus, but denotative and in haskell (or, really, any language without side-effects be better than now).
05:06:46 <maerwald> unexisting: FRP is young. Despite a lot of people telling that you should use it for purpose XY, most people don't know HOW to actually use it, except trivial examples.
05:06:47 <bernalex> unexisting: to make something like that, that's *really good*, typically takes people five years or so of hobby hacking in c++. so I guess maybe it would take three years in haskell. :) but a lot of haskellers apparently tend to have short attention spans
05:06:52 <maerwald> so you'd really be doing the groundwork here
05:07:53 <tdammers> for games, I still have a hunch that discrete-time reactive programming might be a more practical approach than FRP
05:08:13 <tdammers> i.e., model everything in terms of state objects and discrete state transitions, including time
05:08:25 * hackagebot http-client 0.4.29 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.29 (MichaelSnoyman)
05:08:27 * hackagebot http-client-tls 0.2.4.1 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.2.4.1 (MichaelSnoyman)
05:08:30 <bernalex> unexisting: I want to work full time on something like what you're describing. if my (soon to be founded) company puts out some smash hit game that makes me "rich" enough to buy food and pay rent for a year, I would definitely work on it. but alas. :)
05:08:33 <tdammers> then you can serialize your game into a stream of event occurrences and call it a day
05:08:54 <bernalex> unexisting: instead I'm stuck with c++ and lua, like the rest of the peasants. *sigh*.
05:09:12 <locallycompact> tdammers, you just popped my head
05:09:15 <locallycompact> tdammers, well done
05:09:40 <maerwald> that's all nice theory ;)
05:10:08 <unexisting> bernalex: IIRC, Game Maker started as a hobby project of some university professor and he managed to write something useful in Delphi in pretty short time.
05:10:10 <maerwald> and the theory is not the biggest problem here
05:10:17 <tdammers> well, the advantage of a time-as-discrete-event-occurrences is that you can apply much of traditional mutable state / main loop game programming as-is
05:11:20 <bernalex> unexisting: it might have been written quickly, as game maker was originally a tiny and simple program for making 2D animations.
05:12:35 <unexisting> bernalex: BTW, cool to meet a GM user here :)
05:12:44 <bernalex> unexisting: I'm not a game maker user. I do not use proprietary software.
05:13:43 <bernalex> in fact, my group (we were only two) were the only one at my bsc course in game design that wrote a game ourselves in python instead of using game maker, explicitly rejecting to use game maker. :)
05:14:39 <unexisting> bernalex: were you inventing an engine from a scratch?
05:15:31 <bernalex> unexisting: we used panda3d, although it would be almost as quick to write it from scratch given how small the game was. it was a tiny weekend project for first years students.
05:15:58 <tdammers> well, it's nice to have stuff like opengl setup boilerplate out of the way
05:16:00 <bernalex> I'm actually in the middle of starting a gamedev company and releasing a game based on that tiny prototype now, all these years later. :) but this is getting quite #-offtopic.
05:16:13 <bernalex> tdammers: yes, but pygame would have been a better choice.
05:16:20 <tdammers> probably
05:16:27 <tdammers> if only for support community size
05:16:38 <bernalex> writing the physics from scratch would have been easier than mucking about with panda3d nonsense.
05:17:54 <bernalex>         # Panda3D is brain damaged. This is a hack. I don't know why it works. Sometimes it doesn't.
05:17:57 <bernalex>         self.body.setR(90 - self.direction)
05:18:01 <unexisting> tdammers: could you provide with something to read about that discrete RP? Sounds interesting.
05:18:07 <bernalex> tdammers: case in point. :)
05:18:26 * hackagebot tianbar 1.0.2.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.0.2.0 (AlexeyKotlyarov)
05:18:44 <tdammers> unexisting: if only I could remember all the things I read on the topic... or any of them, really...
05:25:58 <mikail__> Hi, I have an issue with running tests on my Haskell code on different platforms. The HSpec tests are comparing Double values and I'm getting tests failing on one platform as the rounding on the Double values is producing different results. For example, on my mac os x a value is calculated as 0.32670213171825235 but on a Linux machine it is calculated as 0.32670213171825857. How can are tests written that compare Double
05:26:15 <unexisting> tdammers: googled that, found Elerea, which leads to the aforementioned Helm.
05:26:33 <bernalex> unexisting: talk to ertes in #haskell-game.
05:28:09 <unexisting> mikail__: floating numbers shouldn't be strictly compared anywhere
05:28:26 * hackagebot path 0.5.8 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.8 (ChrisDone)
05:28:31 <mikail__> but then how do I test my code?
05:28:45 <bergmark> mikail__: you should compare floats with equality, use `abs a b < epsilon`
05:28:56 <bergmark> should not* compare floats with equality
05:29:23 <mikail__> is there a tolerance function in HSpec you are aware of?
05:29:34 <mikail__> i am using shouldbe at the moment
05:30:00 <bergmark> also i mean `abs (x - y) < epsilon' :-(
05:30:31 <bernalex> bergmark: I spent a bit of time trying to parse wtf you just wrote. thanks for clarifying. :p
05:35:42 <merijn> mikail__: There's multiple rounding modes for IEEE754 floating point
05:35:56 <merijn> mikail__: Are you sure the linux and OSX machine are using the same rounding mode?
05:36:28 <merijn> bergmark: Depends on what you're testing
05:36:42 <merijn> bergmark: Comparing floats with equality is just fine for some things
05:37:09 <mikail__> how can i find that out merijn?
05:37:20 <merijn> mikail__: Low level voodoo, sadly
05:37:35 <merijn> mikail__: What exactly are you testing?
05:37:49 <mikail__> i have a function which calculates a price
05:38:08 <mikail__> i wrote some HSpec tests to make sure it calculates the right price for different items
05:38:22 <mikail__> but when I push the code onto the CI environment it fell down
05:38:23 <merijn> mikail__: Don't use Double for prices
05:38:27 <mikail__> due to the rounding
05:38:27 <merijn> Never ever
05:38:31 <mikail__> oh
05:38:31 <coppro> ^
05:38:43 <mikail__> should i use Decimal
05:38:44 <coppro> store your prices in cents
05:38:53 <merijn> Either use Integer or some fixed width type
05:39:02 <merijn> coppro: Fixed width Decimal is ok
05:39:21 <mikail__> ok i will try that
05:39:30 <coppro> Decimal would be ok
05:39:36 <magneticduck> coppro: finance application often need to deal with price precisions smaller than a cent
05:39:42 <merijn> coppro: cents might not be finegrained enough, Tarsnap does internal accounting in picodollars :)
05:40:17 <merijn> oh, no, attodollars
05:40:21 <merijn> https://www.tarsnap.com/picoUSD-why.html
05:40:24 <coppro> mikail__: the problem with binary floating-point numbers is that you can't represent any number which is not composed of inverse powers of 2 precisely
05:41:04 <coppro> e.g. 0.1 is not representable exactly
05:41:12 <coppro> it's like trying to represent 1/3 in decimal. you can't
05:41:18 <Hafydd_> This is a problem with positional notation in general.
05:41:22 <coppro> yep
05:41:27 <merijn> <3 Ratio
05:41:33 <merijn> > 1/3 :: Ratio Integer
05:41:34 <lambdabot>  1 % 3
05:41:47 <merijn> > let third = 1/3 :: Ratio Integer in third + third + third
05:41:48 <lambdabot>  1 % 1
05:41:59 <bernalex> I remember back when I used sbcl as my calculator how much I loved that it just groked fractions and automatically converted between fractions and decimals.
05:42:00 <tdammers> the reason why decimals are OK is because currency is by definition expressed, calculated, and rounded, in base-10
05:42:02 <magneticduck> uh, actually Rational might be a good choice for accounting
05:42:36 <tdammers> magneticduck: or not, because dividing a dollar by 3 should not produce 1/3 exactly
05:42:54 <tdammers> rather, it should produce two values of 33 cents and one value of 34 cents
05:43:26 <tdammers> (or three values of 33 cents and a remainder of 1 cent)
05:43:58 <bernalex> this is all just yet another reason why currency is evil. ;-)
05:44:01 <tdammers> decimals do this almost naturally, but with Rationals, you need a bit more juggling to get these things right
05:44:27 <tdammers> bernalex: currency isn't evil, people just don't understand precisely enough how it works and model it wrong
05:44:50 <tdammers> another common mistake is to store exchange rates as ratios (or pairs)
05:44:55 <Hafydd> Why not just represent currency as integer amounts of the smallest denomination?
05:45:09 <bernalex> tdammers: I indeed think that currency as a construct is an evil. although any reasoning for this is well into #-offtopic territory. :)
05:45:16 <mikail__> will using Decimal (https://hackage.haskell.org/package/Decimal-0.4.2/docs/Data-Decimal.html) slow down my code?
05:45:18 <tdammers> Hafydd: you can, but then you get in trouble when you need to mix smallest denominations
05:45:31 <Hafydd> tdammers: what do you mean?
05:46:28 <zomg> there's also the fact that some currencies use different amounts between units, you don't always have 1 large = 100 small
05:46:55 <zomg> and some currencies don't have that concept at all, and some do, but in practice it's never used..
05:47:38 <magneticduck> currency is more complicated than I expected
05:48:11 <zomg> yeah I had no idea until I worked on some software dealing with different currencies :P
05:48:17 <Hafydd> What does that have to do with representing an amount of money as an integer?
05:48:28 <bernalex> currencies programming is like diet time zones programming
05:51:00 <bernalex> my previous time/clock programming ended up with the idea of developing a DSL for converting between times. you stored 'clocks' (time specifications) in the database, and then each event was associated with a clock. each clock, in turn, had a function for converting values to terrestrial time. so all events could be indexed on terrestrial time, and seamlessly converted between clocks whilst retaining
05:51:02 <bernalex> precision down to planck time.
05:51:30 <bernalex> it was really cool actually. and then they pulled funding and now I'm broke and can't afford food. pls help.
05:51:43 * Hafydd . o O (Just store all times as the integer number of Planck periods since the beginning of the universe.)
05:52:27 <magneticduck> Hafydd: well sure, that's 'terrestrial time'
05:52:31 <bernalex> Hafydd: that's... not a very trivial thing to do. and not very efficient. or frontends.
05:52:32 <magneticduck> plus or minus precision and absolute offset
05:52:52 <bernalex> magneticduck: that's not TT.
05:53:01 <dolio> Hafydd: The smallest denomination of a currency is usually not the smallest piece people care about.
05:53:21 <bernalex> magneticduck: TT = (1 − LG) TCG + E.
05:53:29 <dolio> So you need a finer unit.
05:53:34 <tdammers> also, relativity
05:54:00 <magneticduck> bernalex: what you're describing is essentially the same as holding terrestrial times, and having a set of glorified show / read functions for various clocks, right?
05:54:02 <Hafydd> dolio: this is what I mean by "denomination", then. I know that in Canada, for example, there isn't a physical coin for less than 5 cents, but people still discuss quantities of 1 cent or less.
05:55:17 <magneticduck> Hafydd: the existence of physical denomination doesn't have anything to do with whether that value of currency can be held and transacted with, iiuc
05:55:28 <bernalex> magneticduck: sort of kind of.
05:55:40 <magneticduck> (people in the US are petitioning to remove the penny, by the way)
05:55:43 <bernalex> tdammers: we used TT, so Mars have been a problem.
05:55:58 <bernalex> tdammers: the Julian Calendar OTOH worked well. :)
05:56:04 * bernalex >>= food
05:56:10 <zomg> Euro is the same.. we have 1 cent coins, but technically they're not in circulation and nobody uses them
05:56:34 <Hafydd> magneticduck: yes, so it's best to make it clear that this isn't what is meant by "denomination".
05:56:35 <tdammers> zomg: some countries still use them
05:56:45 <zomg> Yen is an example of a currency where they have a smaller denomination which iirc was divided by 1000 instead of 100, but they actually never use it at all
05:56:57 <magneticduck> Hafydd: oh I misunderstood, my bad
05:57:13 <zomg> tdammers: kinda wonder why since you can't really do anything with 1 cent... :D
05:57:16 <tdammers> but anyway, it's not uncommon to use 4 decimal places for sub-euro amounts in trading and insurance
05:57:16 <dolio> There isn't even a name for 1/10 of a cent in US currency, but gasoline prices almost universally end in 9/10 of a cent.
05:57:17 <magneticduck> (apparently everybody was agreeing about that)
05:57:34 <tdammers> zomg: correctly handle transactions for items priced psychologically
05:57:40 <tdammers> zomg: 0.99€
05:57:48 <tdammers> zomg: Germany is big on this
05:57:57 <zomg> do people pay with cash a lot in germany?
05:58:04 <tdammers> zomg: yes
05:58:15 <zomg> in Finland people have pretty much stopped using cash these days I think
05:58:19 <zomg> mostly just old people :)
05:58:37 <tdammers> zomg: I live in the Netherlands, where cash is almost an exotic thing these days, and whenever I'm in Germany, I have to consciously remind myself to carry some cash in case I want to buy stuff
05:59:01 <zomg> heh
05:59:20 <zomg> wonder why that is
06:00:37 <dolio> Hafydd: Anyhow, yes, using an integer is basically the same as using a decimal with some finite precision.
06:01:00 <dolio> Fixed precision, even.
06:01:18 <dolio> That might even be how it's implemented.
06:02:56 <Hafydd> Provided that "1" differs from the smallest unit by a factor of a power of 10.
06:03:08 <Hafydd> Or 2, as the case may be.
06:03:27 * hackagebot distributed-closure 0.3.1.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.3.1.0 (MathieuBoespflug)
06:37:45 <tero-_> I'm trying to add a cookie/auth token servant combinators but the types are in the way http://lpaste.net/534166130575540224 . any tips?
06:42:16 <tero-_> solved at #servant (needed a type signature for ctx)
07:06:55 <codedmart> Is DuplicateRecordFields in ghc 8.0.1?
07:07:18 <dmj`> codedmart: yes
07:07:21 <codedmart> I am getting a multiple declarations error.
07:07:54 <codedmart> Sorry typo in pragma :)
07:08:35 <dmj`> :)
07:08:56 <dmj`> that extension is life changing
07:09:03 <codedmart> Ah that is nice to have.
07:18:30 * hackagebot inline-c 0.5.5.3 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.3 (FrancescoMazzoli)
07:27:23 <dunpeal> I read that Rust borrowed a lot from the Haskell type-system. What major features of Haskell did Rust not borrow?
07:27:48 <srhb> dunpeal: purity.
07:27:57 <c_wraith> Higher-kinded abstraction
07:28:16 <magneticduck> curried functions!
07:28:17 <dunpeal> c_wraith: do you mean high-order polymorphism?
07:28:25 <c_wraith> dunpeal: no
07:28:40 <c_wraith> I mean the ability to abstract over higher-kinded types.
07:28:47 <magneticduck> dunpeal: value : type :: type : kind
07:28:50 <c_wraith> All rust abstractions must be over concrete types.
07:29:31 <jstimpfle> hi, I want to parse a stream of Word8 as ansi keyboard codes. I think it's basically a Mealy automaton. How would I go about this in a clean way?
07:29:38 <dunpeal> OK, I guess I'll look it up, I don't know anything about "kinds".
07:29:40 <c_wraith> Rust could, in theory, still get higher-kinded abstraction.  It doesn't conflict with any language goals.
07:30:09 <c_wraith> The most notable thing GHC's type extensions provide that rust will never get is higher-rank types.
07:30:29 <c_wraith> Which makes me sad, since they're so incredibly powerful.
07:31:03 <c_wraith> But they directly conflict with the language goal that everything should be zero-cost.
07:31:23 <c_wraith> Since they require a uniform representation of all values.
07:31:27 <magneticduck> heh, well, all abstractions ^^
07:31:44 <c_wraith> Nah, rust found all kinds of things that can be made zero-cost abstractions.
07:32:43 <dunpeal> c_wraith: thanks. other than those differences, would you say the type systems are pretty similar?  are there any popular languages that have a type system more similar to Haskell than Rust's?
07:33:31 <merijn> Swift is supposed to get higher-kinded types
07:34:19 <c_wraith> dunpeal: higher-kinded abstraction includes things haskell represents as type classes like Functor, Applicative, Monad, Foldable, Traversable...  the list goes on and on.  I feel like Traversable is actually the most compelling example, but it also has one of the highest mental overheads to pick up.
07:35:12 <c_wraith> Actually, I wouldn't really say they're that similar. 
07:35:32 <c_wraith> I'd say that the ML family is closer, even though it also has large differences.
07:38:37 <codedmart> If I have have a func that reads a json file. When I decode I want to fromMaybe and either return the Config or just exit the app with an error. What is the best way to do that?
07:38:45 <codedmart> Haven’t dealt with errors much yet.
07:39:47 <tdammers> something like: maybe (fail "Invalid JSON") return =<< functionThatReadsAndParsesJSON
07:41:24 <dmj`> codedmart: use eitherDecode
07:42:20 <dmj`> result <- either error pure =<< eitherDecode <$> L.readFile "foo.json"
07:42:32 <dmj`> codedmart: ^
07:45:24 <codedmart> Thanks!
07:48:31 * hackagebot haskell-google-trends 0.0.1 - Simple library for accessing Google Trends  https://hackage.haskell.org/package/haskell-google-trends-0.0.1 (grzegorzgolda)
07:52:43 <dunpeal> c_wraith: thanks.
07:58:31 * hackagebot coin 1.1 - Simple account manager  https://hackage.haskell.org/package/coin-1.1 (piotrborek)
08:01:39 <haskell165> How easy/hard is it to find junior haskell work?
08:02:34 <tdammers> haskell165: it's a slow market
08:02:41 <tdammers> haskell165: few candidates, few positions
08:03:10 <tdammers> haskell165: additionally, the quality standard is high on both sides
08:03:35 <tdammers> haskell165: so I would say that if you're good, and looking for the better employers, then it's just as easy as with any other language, but may take a lot longer
08:04:32 <codedmart> Is there no From/To JSON instances for ByteString?
08:04:34 <haskell165> okay cool, how about for Scala? I noticed a lot more jobs on the functional programming job boards for Scala than Haskell
08:04:55 <codedmart> I am seeing this error `No instance for (FromJSON ByteString)`
08:07:13 <codedmart> I see the issue about it nvm
08:10:17 <maerwald> haskell165: this isn't really the right channel to afk for general job opportunities
08:10:22 <maerwald> s/afk/ask/
08:13:39 <mizu_no_oto_work> haskell165: FWIW, I was hired for a Scala position straight out of school without having used the language, on the basis of my Haskell experience.
08:14:43 <dmj`> codedmart: there isn't, since the json spec assumes utf afaik
08:16:44 <haskell165> maerwald: That was not what I was doing, I was simply wondering how common functional languages are found in industry and if it is worth spending x number of hours learning haskell if one of the reasons behind learning would be to find some form of work
08:17:48 <maerwald> haskell165: check the tiobe index
08:18:47 <chelfi> haskell165: AFAICT many companies tend to appreciate a functional programming experience, in both junior or senior hires, even though they do not maintain any significant code base in an FP oriented language
08:19:03 <dolio> Do people really hire 'junior' employees based on knowledge of particular programming languages?
08:19:17 <hiptobecubic> not of particular languages I don't think
08:19:39 <chelfi> dolio: some do
08:19:52 <hiptobecubic> But if you're the kind of junior that is plugged in enough to be investigating ocaml and scala and haskell for fun, then that's a good sign.
08:20:14 <hiptobecubic> What was it... i think paul graham called it the python paradox or something before
08:20:22 <hiptobecubic> back when learning python meant something
08:21:33 <chelfi> hiptobecubic: http://paulgraham.com/pypar.html ?
08:21:53 <hiptobecubic> yes
08:22:05 <hiptobecubic> replace "python" with "new fangled functional language"
08:22:21 <hiptobecubic> even if they aren't new, they are new to the pointy-haired bosses
08:22:35 <maerwald> Srsly, if you want to know which languages are used in industry, just google it. There are researches about it.
08:24:28 <dmj`> haskell165: I'd try to link your personality style and work habits. If you like consulting / freelancing. I'd learn servant + ghcjs and shop around your services
08:28:49 <cheater> hey guys
08:29:29 <cheater> if i have a rust or c program, and would like to run a persistent ghc in it, what do i need to do? will ghc run in a new thread? or does it need a new process?
08:30:04 <hpc> there's an api for calling haskell from c
08:30:11 <hpc> it involves starting the runtime yourself and some other stuff
08:30:18 <cheater> right
08:30:25 <hpc> somewhere on the wiki is a page about it
08:30:56 <cheater> i'm just wondering what's necessary to say, have a game where the low level real time parts of the engine are written in rust, but higher level stuff (like game scripting) is written in haskell
08:31:08 <cheater> obviously this works with a lot of other program types
08:32:35 <hpc> it might be feasable
08:32:54 <hpc> you might also try asking in #haskell-game
08:32:56 <Jinxit> can rust do C-style FFI?
08:33:12 <cheater> rust can be used as a C style library
08:33:35 <cheater> but for realtime you want rust to be the main loop and haskell to be whatever (thread, spawned process, etc)
08:34:20 <Jinxit> cheater: https://github.com/alexcrichton/rust-ffi-examples/tree/master/haskell-to-rust/src
08:34:23 <Jinxit> so yeah that part works
08:34:24 <cheater> anyways i'm just playing with the idea it's not super important or anything =)
08:34:26 <Jinxit> but threads? no clue
08:34:49 <cheater> yeah you'd want it the other way around than in that github link
08:34:53 <cheater> you'd want main.rs and Lib.hs
08:35:22 <codedmart> dmj`: Yeah I found the issue about it being removed, etc. Thanks!
08:43:33 * hackagebot data-transform 0.1.0.1 - Functions to transform data structures.  https://hackage.haskell.org/package/data-transform-0.1.0.1 (JonasScholl)
08:47:43 <c_wraith> hmm. looking at various packages for distributed computing.. it looks like serializing closures is still a giant pain. is any work ongoing to make that more natural? 
08:49:28 <c_wraith> hmm. with more thought.. Maybe it shouldn't be natural. I wouldn't want to accidentally serialize an unevaluated object graph that adds up to several megabytes when I don't mean to. 
08:50:41 <EvanR> this is an advantage of syntax-only stuff, instead of values you have expressions, which are syntactic
08:51:15 <codedmart> What does `stripes` mean in createPool?
08:51:20 <EvanR> then it is obvious how to move it over a socket
08:52:12 <c_wraith> codedmart, data structures designed for concurrent use are often striped.. meaning split up internally to reduce concurrent contention. 
08:52:20 <buglebudabey> if i want to do computations in a do block with IO String but also make inserts into a postgres database using persistent, how can i combine these two things in my main method
08:52:41 <codedmart> c_wraith: So for a database is that the number of connections?
08:52:57 <c_wraith> codedmart, you want to choose a number of stripes that reduces contention but doesn't waste memory. 
08:53:29 <codedmart> I am using it to create a connection pool to my DB not sure of good values to use.
08:53:53 <dmj`> buglebudabey: execute conn "INSERT INTO Table VALUES (?, ?)" =<< (pure ("john", "doe") :: IO (String, String))
08:53:56 <codedmart> Because there is this `The number of stripes (distinct sub-pools) to maintain. The smallest acceptable value is 1.` and then this `Maximum number of resources to keep open per stripe. The smallest acceptable value is 1.`
08:54:17 <codedmart> I assume the first one is number of connections to the db but I am not sure what the next option means.
08:54:37 <buglebudabey> not famliar with this =<< operator dmj` where can i learn about it
08:54:51 <c_wraith> codedmart, a good first guess for the number of stripes you want is the number of cores the program is using. 
08:55:11 <buglebudabey> also the insert looks like this : insert $ BlogPost "My fr1st p0st" i1
08:55:12 <mauke> @src =<<
08:55:12 <lambdabot> f =<< x = x >>= f
08:55:19 <codedmart> c_wraith: OK so it is not the number of connections to the db then?
08:55:51 <dmj`> buglebudabey: are you familiar with the Monad typeclass?
08:55:54 <buglebudabey> @src pure
08:55:54 <lambdabot> Source not found. It can only be attributed to human error.
08:56:08 <c_wraith> codedmart, not at all. it's about reducing contention within the bookkeeping structures in the pool itself, not the number of resources. 
08:56:46 <codedmart> c_wraith: So would the second option have anything to do with connections to the db -> Maximum number of resources to keep open per stripe. The smallest acceptable value is 1.
08:56:53 <puregreen> how much Haskell knowledge would someone need to be able to make something simple with Yesod?
08:56:55 <codedmart> Or am I still thinking of that wrong.
08:57:14 <buglebudabey> dmj` more or less, i know bind and do blocks, but i'm having trouble combining monads together so that i can take in a json value, decode it, and insert the new datatype into the database
08:57:33 <c_wraith> codedmart, the number of connections it keeps open would be the number of stripes * that minimum. 
08:57:46 <codedmart> OK thanks!
08:57:57 <codedmart> c_wraith: Thanks!
09:02:17 <buglebudabey> .
09:03:07 <buglebudabey> dmj` would you mind looking at this http://lpaste.net/166444
09:03:28 <buglebudabey> i want to take the contents, serialize them into my sql datatype, then inject it
09:04:51 <nitrix> Is there something similar to STRef that allows sharing the `s` and use multiple runST ?
09:04:56 <nitrix> I know this breaks referential transparency.
09:05:15 <EvanR> IORef ! ;)
09:05:23 <dmj`> buglebudabey: a few things
09:05:42 <EvanR> its very similar to STRef
09:05:47 <dmj`> buglebudabey: eitherDecode takes a lazy bytestring
09:06:21 <dmj`> let json = eitherDecode (Data.ByteString.Lazy.pack contents) :: Either String BotInquiry
09:07:59 <nitrix> EvanR: The thing is, I'd like it to behave like IORef, but remain pure. That's ill phrased actually. I want two references to the same element located in a data structure. Ideally, I'd obtain the value of said element in O(1) and in a pure way (presumably, by giving the reference and the data structure to some getter system).
09:08:09 <dmj`> case json of Right val -> insert val; Left err -> error err
09:08:16 <dot_asp> Hello. How can I know if a function will throw an exception? readFile logically will throw an exception if file does not exist, but it isn't mentioned in the source anywhere is it?
09:08:36 <EvanR> nitrix: hmm. would functional references be applicable?
09:08:40 <nitrix> EvanR: STRef almost does this, but the `s` aren't compatible so I can't have multiple of those.
09:09:01 <nitrix> EvanR: It's what I'm trying to achieve, although I don't know what functiona references refers to.
09:09:16 <nitrix> I'm struggling with relations. ixset doesn't cut it.
09:09:17 <mauke> dot_asp: it uses openFile, which throws
09:10:05 <EvanR> nitrix: its a thing which lets you update a target location in a data structure, but you sound like youre just talking about *getting* something, which... if you already had the reference why dont you just also have the value (lazy) ?
09:10:19 <nitrix> EvanR: Getting and updating.
09:10:22 <EvanR> ah
09:10:22 <buglebudabey> dmj` i need to convert that val into an Inquiry first
09:10:22 <buglebudabey> dmj` can i do that inside the do block without getting an error because im switching monad types?
09:10:28 <dot_asp> oh ok.
09:10:32 <nitrix> EvanR: I heavily use lenses for my game, is it the same concept?
09:10:36 <EvanR> yes
09:10:45 <nitrix> But does lenses give you O(1) ?
09:10:46 <EvanR> which isnt O(1) for a few reasons
09:11:00 <dmj`> buglebudabey: you would pattern match on it
09:11:18 <EvanR> you have to update a nested data structure
09:11:23 <nitrix> EvanR: If the data structure changes, then you have to create the new version of it, since it's immutable, right?
09:11:24 <EvanR> so reallocate the path to the point updated
09:11:31 <nitrix> EvanR: Right.
09:11:37 <slack1256> ghc 8 and yesod results in a "imposibility happened" when compiling the foundation
09:11:40 <slack1256> Anybody else?
09:11:45 <EvanR> but at least you dont have to search for the point
09:11:49 <EvanR> you have a reference
09:11:52 <nitrix> EvanR: Can we simplify my problem statement to no data structure at all, then ?
09:12:01 <buglebudabey> dmj` so - case json of Right (BotInquiry q a) -> insert $ Inquiry q a
09:12:10 <EvanR> nitrix: you want a big collection of named cells?
09:12:20 <dmj`> buglebudabey: (getContents :: IO ByteString) >>= \bs -> case eitherDecode bs :: Either String Inquiry of { Right (inquiry :: Inquiry) -> insert inquiry; Left (err :: String) -> error err
09:12:28 <EvanR> nitrix: do you want the names to form a hierarchy?
09:12:33 <nitrix> EvanR: Just shared references to a common record data type, presumably.
09:12:52 <nitrix> Read and update the record O(1) at will.
09:13:02 <EvanR> record or whatever
09:13:17 <EvanR> so IORefs ?
09:13:29 * EvanR reviews the convo to see why thats not right
09:13:34 * hackagebot diagrams-cairo 1.3.1 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.1 (BrentYorgey)
09:13:36 * hackagebot monad-par 0.3.4.8 - A library for parallel programming based on a monad  https://hackage.haskell.org/package/monad-par-0.3.4.8 (RyanNewton)
09:13:44 <EvanR> a pure IORef ...
09:13:47 <buglebudabey> dmj` do i need the two different types BotInquiry and Inquiry, or can I just work with Inquiry
09:13:55 <nitrix> EvanR: Haskell lets you do that already, the nuance is that, modifying one via one reference would modify obviously what the other reference is pointing at.
09:14:03 <nitrix> EvanR: This is starting to look like State X
09:14:10 <dmj`> buglebudabey: I don't see the definition of Inquiry, I assume you just meant BotInquiry
09:14:22 <EvanR> nitrix: so the deal is that State gives you one giant data structure but you want many small cells with refs
09:14:35 <nitrix> EvanR: I think I want to be able to newMutVar modifyMutVar inside State :/
09:14:40 <EvanR> so you can built this support into your monad, it exposes only IORefs not all of IO
09:14:41 <buglebudabey> it's above botinquiry
09:14:48 <buglebudabey> dmj` above botinquiry
09:14:58 <nitrix> EvanR: Correct.
09:15:00 <buglebudabey> dmj` the template haskell
09:15:07 <dmj`> Oh I see, it might generate and ADT for you w/ data families
09:15:10 <dmj`> s/and/an
09:15:16 <EvanR> and you can wrap the IORefs in something if you want
09:15:20 <EvanR> or not
09:15:25 <nitrix> EvanR: I want a stateful context which allows me to create and modify many cells at will.
09:15:51 <EvanR> i have never tried something like this, since i felt like it would get insane ;)
09:16:02 <nitrix> EvanR: State is just one giant type and building any cell system on it always brings be back to some O(log n)
09:16:17 <EvanR> yes State is also just inconvenient
09:16:24 <EvanR> you need a lot of helpers
09:16:27 <buglebudabey> dmj` i have no clue what you mean :P
09:16:28 <dmj`> buglebudabey: you might be able to make a FromJSON instance for the Inquiry type generated from TH
09:16:40 <buglebudabey> dmj` ill try that
09:17:03 <dmj`> buglebudabey: I'd break down your problem, do one thing at a time. Template haskell is advanced for those brand new to haskell
09:17:38 <EvanR> nitrix: is O(1)-ness really important?
09:17:45 <buglebudabey> dmj` i consider myself beginner/intermediate D:
09:17:47 <dmj`> first understand how to deserialize a ByteString into an algebraic data type, then try to insert a record into a db
09:18:03 <EvanR> ghc is optimized for reallocating a helluvalot, rather than mutating a lot of cells
09:18:07 <dmj`> buglebudabey: can you write the State monad instance for me
09:18:26 <buglebudabey> dmj` nope
09:18:39 <nitrix> EvanR: Yeah, it's the challenging part. It's interesting and I'd have real use cases for it. Otherwise I'd just fallabck to ixset or the "put eevrything in a giant stateful data type" solution with tons of lenses.,
09:19:01 <nitrix> I guess this is akin to asking for C pointers in a referentially transparent way.
09:19:33 <EvanR> nitrix: im not sure purity or RT is mattering here, you just want more convenient memory cells
09:19:44 <EvanR> without also just using IO everywhere
09:19:51 <nitrix> Correct.
09:19:56 <buglebudabey> dmj` actually let me try, instance Monade State s where State s >>= State s (s a)?
09:20:02 <EvanR> i suggested building this support into your monad
09:20:10 <EvanR> so its basically ST but with other abilities
09:20:20 <EvanR> i assume you do want to do some other IO
09:20:29 <nitrix> EvanR: If I try to break down the problem, having any kind of cells, does that immediatly imply IO ?
09:20:57 <nitrix> EvanR: I could try to implement it with unsafeness and hide it in a neat interface for a library but :S
09:21:07 <EvanR> the only way i know of doing that is ST
09:21:13 <EvanR> but its too limited for this
09:21:18 <dmj`> g >>= f = State $ \s -> let (a,s') = runState g s in runState (f a) s'
09:21:18 <nitrix> Correct.
09:21:23 <EvanR> and you use ST the same way as IO
09:21:27 <EvanR> so
09:21:30 <nitrix> What about State over ST's `s` ?
09:21:45 <nitrix> Oh you can't extract it, nvm.
09:21:48 <EvanR> no
09:22:02 <EvanR> it doesnt really make sense to want to go into ST to modfiy stuff, leave and come back
09:22:26 <EvanR> you might as well just use IO
09:22:34 <nitrix> How's ST implemented to obtain the cells? Smoke and mirrors with the compiler?
09:22:41 <EvanR> its using IORefs
09:22:59 <nitrix> And hiding them?
09:23:03 <EvanR> right
09:23:09 <EvanR> you cant take them out of the ST context
09:23:30 <nitrix> So, I'd have to implement a slightly more powerful ST.
09:23:42 <EvanR> right but it wouldnt need to be as extreme as ST
09:23:58 <EvanR> but you it would involve an IO core somewhere
09:24:06 <EvanR> your types dont have to allow arbitrary IO though
09:24:14 <nitrix> What about the `s` of ST, would I do similar?
09:24:19 <EvanR> i wouldnt
09:24:22 <EvanR> i wouldnt bother
09:24:28 <nitrix> But then you get problems, no?
09:24:52 <EvanR> this is like going out of your way to make a class singleton ... rather than just not making more than one of the objects of that class ;)
09:25:29 <EvanR> if you just want to use cells, and you dont care how or when they are used, you can literally install the following in your monad
09:25:36 <EvanR> newCell :: MyMonad (IORef a)
09:25:47 <EvanR> writeCell :: IORef a -> a -> MyMonad ()
09:25:53 <EvanR> etc
09:26:05 <EvanR> MyMonad doesnt allow arbitrary IO, just messing with IORefs
09:26:48 <EvanR> if you somehow export any of these IORefs to another part of the program and it uses them, then it uses them and you see the updates
09:27:02 <EvanR> is this really a problem? if so ... dont do that
09:27:36 <volhovm>  I'd like to use cloud haskell for my own study purposes, but I have a requirement that communication messages should be human-readable and in precise format. Can I achieve this with it?
09:27:56 <volhovm> Like, can I specify what exact information would be passed between nodes?
09:27:56 <EvanR> if you dont want to allow IO code to use the IORefs, then you can wrap them in a newtype
09:28:11 <EvanR> but other instances of your app engine can use them, is this a problem? is so dont do that
09:28:14 <EvanR> etc
09:28:31 <EvanR> ST has an extreme form of safety from these two things
09:28:34 * hackagebot twitter-types 0.7.2.2 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.7.2.2 (TakahiroHimura)
09:28:36 * hackagebot sentence-jp 0.1.0.0 - Easily generating message of japanese natural language  https://hackage.haskell.org/package/sentence-jp-0.1.0.0 (aiya000)
09:29:53 <EvanR> the benefit of ST is that you can enter into it from a world other than IO
09:30:01 <EvanR> but your game monad is probably entering from IO
09:30:33 <EvanR> so thats not an issue
09:31:38 <nitrix> EvanR: Oh I see. The MyMonad stuff is interesting.
09:31:51 <nitrix> EvanR: I would use the same idea, but as a monad transformer though.
09:32:04 <nitrix> To give "cell capability" without necessarily allowing IO, but not disallowing it either.
09:32:42 <volhovm> I know that CH uses serializable (obviously) to send data between nodes, but is there any other data sent? Can anyone give me a hint about it?
09:33:42 <codedmart> How do I ignore the Status in `Connection -> IO Status`? This is from hedis it is the quit command, but I need `Connection -> IO ()`? I feel like I should know this but my trials have failed so far.
09:34:28 <nitrix> EvanR: MyMonadT x m, where x is for the internal IORef x ?
09:34:34 <codedmart> OK
09:34:41 <codedmart> Sorry wrong channel :)
09:35:00 <nitrix> EvanR: This seems like scotty's ScottyM and ActionT.
09:35:04 <nitrix> EvanR: I like that.
09:35:19 <mikail__> Hi, if I have a value in an Either type like Right 10, how do addition with it?
09:35:28 <mikail__> Right 10 + 4
09:35:32 <dmj`> > (+1) <$> Right 10
09:35:34 <lambdabot>  Right 11
09:35:42 <mikail__> great!
09:35:45 <mikail__> thanks
09:35:51 <dmj`> mikail__: do you understand why though
09:35:54 <mauke> codedmart: (\f x -> f x >> return ())
09:35:58 <mikail__> no
09:36:00 <jimki_> codedmart: use 'void'
09:36:15 <dmj`> mikail__: are you familiar with typeclasses in haskell, specifically Functor
09:36:30 <nitrix> EvanR: Maybe this is it. Maybe I'm at the point where I need custom monads and transformers for my game.
09:36:31 <mikail__> oh right so we are mapping (+1) to Right 10?
09:36:43 <maerwald> <$> is infix of fmap, yes
09:37:23 <dmj`> mikail__: write fmap for Either for me
09:38:00 <mizu_no_oto_work> > second (+ 1) (Right 1)
09:38:02 <lambdabot>      Couldn't match type ‘(d, b)’ with ‘Either a0 Integer’
09:38:02 <lambdabot>      Expected type: Either a0 Integer -> (d, b)
09:38:02 <lambdabot>        Actual type: (d, b) -> (d, b)
09:38:39 <nitrix> mizu_no_oto_work: first and second are from arrows.
09:38:48 <mauke> s/from arrows/for tuples/
09:38:50 <dmj`> mikail__: fmap (f :: a -> b) (Right (z :: a)) = Right (f z :: b); fmap _ (Left k) -> Left k
09:39:08 <mizu_no_oto_work> nitrix: They're also in Data.Bifunctor
09:39:13 <nitrix> mauke: Control.Arrow
09:39:19 <kadoban> Yeah, it's starting to be more than a little unfortunate that lambdabot's ones are the Arrow ones.
09:39:23 <nitrix> mizu_no_oto_work: Yes but it's not the ones that lambdabot has loaded.
09:39:34 <mizu_no_oto_work> Right
09:39:49 <mikail__> ok got it
09:40:11 <mizu_no_oto_work> > bimap id (+ 1) (Right 1)
09:40:14 <lambdabot>  Right 2
09:40:31 <EvanR> nitrix: well transformers are how you can get to MyMonad
09:40:56 <nitrix> EvanR: Would you just newtype a transformer stack?
09:41:25 <EvanR> nitrix: no i wasnt intending you index the type by the ref type or anything, you can just making however many cells you want of any type
09:42:11 <EvanR> nitrix: im not sure what existing transformers do this but, just saying for whole-app monads i see transformers as a means to the end rather than a central tool of their own right
09:42:36 <nitrix> I'll try to implement a prototype during lunch.
09:42:49 <EvanR> i dont expect to be able to easily enter and leave the parts of a whole app monad
09:42:58 <EvanR> its kind of monolithic ime
09:49:13 <nitrix> I'll let you know how far I get, if you're interested.
09:50:20 <EvanR> with this technology you can make fantastic mutable data structures ! the doubly linked list, oo ah ;)
09:50:33 <EvanR> IORefs in your IORefs
09:50:44 * dmj` gasps
09:51:51 <cheater> some ago i have spoken with someone here about memory disclosure vulnerabilities in Haskell... due to the fact that if you, say, get a password as a string in your program, it might hang around forever. it's not possible to erase everything well. i was wondering if anyone knows a good way of taking care of this issue.
09:52:12 <kier> anyone else having trouble installing hakyll+pandoc via cabal?
09:52:15 <c_wraith> there's a package designed for that 
09:52:17 <EvanR> once you drop it, you can force a major GC ?
09:52:33 <maerwald> c_wraith: yes, but it's unknown what side effects that has, it may as well crash your program at some point afaik
09:52:35 <EvanR> guess FFI is better
09:52:44 <kadoban> cheater: I'd probably look into doing that small part in C and writing an interface for it.
09:53:26 <maerwald> I agree with kadoban, there also has been a small discussion on haskell-cafe wrt that (cryptography in particular)
09:54:52 <EvanR> .oO( when the user types a password, and its starts in driver memory, then goes to the jungle of OS buffering technologies ... then goes to your program...)
09:55:19 <EvanR> or goes to your toolkit first!
09:55:41 <EvanR> spooky
09:56:02 <maerwald> cheater: https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118059.html
09:56:20 <maerwald> @hackage securemem -- is the package
09:56:21 <lambdabot> http://hackage.haskell.org/package/securemem -- is the package
10:00:34 <osager> Can the r in ReaderT r m a be a State monad ? I want to be able to read some states all the time
10:01:20 <hpc> :k ReaderT
10:01:21 <lambdabot> * -> (* -> *) -> * -> *
10:01:25 <c_wraith> technically, yes, but I don't think it's what you want. 
10:01:29 <hpc> the r is some type of kind *
10:01:43 <c_wraith> I think you want m to be some State thing 
10:01:44 <hpc> so if you had r = State s () or something like that, you'd in effect have
10:01:48 <hpc> @unmtl State s ()
10:01:48 <lambdabot> s -> ((), s)
10:02:27 <hpc> which isn't a piece of state but a computation on a value of type 's' with a state-like interface
10:04:02 <mizu_no_oto_work> osager: Do you know how Reader (and ReaderT) is implemented?
10:04:46 <cheater> kadoban: but how do i make C get the password? the socket or keyboard input or the UI element would be in haskell somewhere.
10:05:06 <cheater> maerwald: can you find the thread on haskell-cafe?
10:05:13 <maerwald> cheater: I just linked it
10:05:17 <cheater> oh you linked it, thanks
10:05:28 <maerwald> the last response is actually the most interesting one
10:05:41 <maerwald> https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118213.html
10:05:48 <cheater> securemem is only for storing stuff but you can't e.g. make a socket go into securemem.
10:06:19 <kadoban> cheater: If it's actually important, I'd just do the whole input part in C myself. (note that just doing it in C isn't enough, you still need to go out of your way to make it secure) securemem looks interesting, though I haven't reviewed it.
10:06:33 <maerwald> I also asked the haskell-tor dev about this thing. I didn't find the answer particularly useful. But if someone knows, it's probably Galois, since they do that sort of stuff.
10:06:41 <cheater> so you'll have to go... socket -> say ByteString -> parse that -> parser output is ByteString or Text or whatever -> securemem
10:06:55 <cheater> kadoban: but you can't make the whole parser like this
10:07:07 <cheater> what if you get the password sent to you via http?
10:07:11 <mizu_no_oto_work> osager: 'ReaderT StateT Identity a' is basically 'r -> s -> (a,s)'.
10:07:22 <EvanR> wouldnt a GUI be totally out of question
10:07:22 <cheater> you have to parse this
10:08:19 <EvanR> unless OS window systems have some sort of security password popups
10:08:23 <EvanR> secure*
10:08:32 <EvanR> that you cna use
10:08:39 <maerwald> every gui framework has
10:09:21 <mizu_no_oto_work> osager: >>= for ReaderT takes a value for r and passes it to both computations.  It's generally used for 'read-only' state like user configs or database connections.
10:09:37 <osager> thanks!
10:09:39 <cheater> yeah i'm not even thinking about GUI right now
10:09:46 <mizu_no_oto_work> So that may or may not be what you're looking for
10:22:59 <osager> so in my case, what is the best way to implement it?
10:23:18 <osager> read some global state which keeps changing
10:29:40 <mizu_no_oto_work> osager: State
10:30:00 <coppro> by which mizu means the State monad :)
10:30:26 <mizu_no_oto_work> Everything that needs to see the global state should be in the state monad
10:30:36 <osager> mizu_no_oto_work, can this state be some really complicated structure ?
10:30:40 <coppro> yes
10:31:03 <coppro> although the State monad does not create global state, in only creates state in its own context. That context can, of course, be your entire program
10:31:04 <mizu_no_oto_work> The state monad is syntactic sugar for manipulating functions of the form 's -> (a, s)'
10:31:54 <osager> ok here's my use case: the application is to keep track of a language learner's ability. based on his ability(which keeps chaning)
10:31:59 <osager> i do some actions
10:32:10 <osager> and i need a structure to represent that ability state
10:32:32 <coppro> that sounds like it's actually state which should be persisted
10:32:49 <osager> and that state might comes from a data base
10:32:56 <mizu_no_oto_work> persisted between runs of the program, sure.
10:33:05 <osager> yes
10:33:28 <coppro> what sort of application is this? web application? desktop?
10:33:36 <osager> destop so far
10:33:43 <osager> for prototyping
10:33:45 <Cale> Well, if you're going to be getting it from and storing it to a database whenever it changes, you're pretty much necessarily in IO
10:34:10 <amf> without jumping to pipes, streaming, etc, is there an easy way to get partial results? e.g. System.Timeout.timeout 10 $ (sequence [readMVar v, readMVar v]) -- pretend each readMVar takes 10 us each, [], [1], [1, 2] are all exceptable
10:34:16 <Cale> but you'll likely want a pure representation of what the state is that you're marshalling to and from the DB
10:34:39 <Squarism> Using lenses, if i want to "filter" / remove-elements in a nested list of a data type - where should i start looking?
10:34:39 <Cale> which you can, e.g. just pass around as a function parameter to the various things that need it
10:35:06 <Squarism> Ex : A question about typical lens "transforms". Here http://lpaste.net/166193 i have some types + lenses + . I wonder, how would i remove an element in "ccc" when its value =="Ba" ... /c/quux/ccc[=="Ba"]
10:35:21 <osager> Cale, anyway,let me try some wrongs first :) thanks
10:36:18 <mizu_no_oto_work> Inside the program, you'll essentially have functions like askQuestion :: QuestionType -> UserAbility -> IO (Boolean, UserAbillity), aka askQuestion :: QuestionType -> StateT IO Boolean
10:37:00 <mizu_no_oto_work> Where UserAbility is some record or type that represents the users ability, that you can serialize to/from your data store
10:38:53 <mizu_no_oto_work> askQuestion someQuestionType >> askQuestion anotherQuestionType  will ensure that the UserAbility returned from asking the first question will be passed to the second question
10:40:02 <mizu_no_oto_work> geh - StateT IO Boolean should be StateT UserAbility IO Boolean
10:40:06 <Cale> I would tend to avoid using StateT until it really became apparent that I'm tupling the state up with the results of my actions all the time
10:40:49 <glguy> Squarism: To remove an element from a list you can use Data.List.delete
10:41:07 <Squarism> glguy, ok! good to know
10:41:13 <Cale> You pay a price in convenience for the first monad transformer -- it makes it much more awkward to forkIO and to catch exceptions, and perhaps even more importantly, you end up having to liftIO everywhere.
10:41:31 <Cale> So you want to make sure to be getting enough out of using the monad transformer to make up for that
10:44:40 <buglebudabey> could someone critique my code on github, i take a json file and parse it and inject it into a postgres db https://github.com/aneksteind/Chaskell/blob/master/main.hs
10:44:52 <osager> mizu_no_oto_work, thanks
10:45:24 <Cale> buglebudabey: looks reasonable
10:45:39 <dmj`> buglebudabey: does it compile?
10:45:47 <dmj`>     let json = eitherDecode $ B.pack contents :: Either String Inquiry
10:45:51 <dmj`> thats valid>
10:45:54 <dmj`> ?*
10:45:55 <lambdabot> Maybe you meant: v @ ? .
10:45:55 <buglebudabey> yeah it runs and does everything i want it to
10:46:06 <glguy> buglebudabey: Instead of using getContents and packing the string you can use bytestring's getContents directly
10:46:46 <glguy> buglebudabey: Instead of: putStrLn (show x), you can print x
10:46:51 <buglebudabey> dmj` is it bad that it's a lazy bytestring?
10:47:10 <buglebudabey> thanks glguy i'll do both of those, i'm open to more suggestions
10:47:15 <glguy> dmj`: The String is the error message
10:47:21 <glguy> maybe that's what you're asking about?
10:48:58 <Squarism> glguy, is that in combination with over?
10:49:06 <glguy> Squarism: yes
10:50:19 <SomeT> how do I uninstall haskell platform on mac os x?
10:50:53 <Pennyw95> weird... gvim has python and vim doesn't
10:51:05 <dmj`> glguy: yes, I thought he was trying to infer the type of pack :: String -> ByteString, to be FromJSON a => Either String a
10:51:57 <dmj`> but it seems :: accounts for everything on the rhs of the let binding
10:52:21 <buglebudabey> SomeT!
10:52:26 <buglebudabey> i just did this yesterday
10:52:33 <buglebudabey> let me get the script
10:53:32 <buglebudabey> SomeT http://lpaste.net/166453
10:54:00 <SomeT> thanks
10:54:46 <SomeT> how do I run t hat fil
10:54:47 <SomeT> e
10:54:54 <SomeT> theres a lot of instructions in it
10:55:02 <buglebudabey> copy and paste that text and save as a .sh file
10:55:25 <buglebudabey> then run the command: sh whateveryourfilenameis.sh
10:55:46 <SomeT> ok
10:58:07 <SomeT> it came up with rm: /usr/share/man/man1/ghc.1: No such file or directory?
10:59:25 <buglebudabey> if it doesn't exist i would take that line out after checking manually to see that it doesn't exist
10:59:54 <SomeT> wait
11:00:00 <SomeT> I typed ghci in terminal
11:00:04 <SomeT> it says command not found
11:00:09 <SomeT> that means its uninstalled right?
11:00:14 <SomeT> I should just ignore that message?
11:00:47 <buglebudabey> yeah your ghci will be gone
11:00:57 <SomeT> but its uninstalled from the system completly?
11:01:02 <Ankhers> Or just not on your PATH.
11:01:10 <buglebudabey> if the script ran completely it should be
11:01:11 <Ankhers> (I haven't really been following)
11:01:25 <SomeT> ok also will it uninstall all cabal libraries as well?
11:01:59 <buglebudabey> it should
11:02:04 <SomeT> many thanks!
11:02:09 <buglebudabey> no proble
11:02:44 <SomeT> is there a way to list installed packages in cabal?
11:03:25 <puregreen> SomeT: ghc-pkg list
11:03:46 <Xandaros> assuming he still has ghc-pkg
11:04:47 <SomeT> ok thanks
11:05:42 <sm> stack/cabal should have that built in
11:06:07 <SomeT> ok
11:06:36 <sm> (but they don't)
11:06:43 <buglebudabey> lol
11:07:33 <dcoutts> cabal does
11:07:38 <dcoutts> cabal list --installed
11:08:21 <puregreen> nice
11:08:56 <sm> nice!
11:09:18 <SomeT> anyone know of the haskell functional programming lab on mac os x?
11:09:24 <joncfoo> Does anyone use QuickCheck to generate "bad" records to ensure their validation logic works as intended?
11:12:08 <sm> with stack, I use: alias stack-pkg="stack exec -- ghc-pkg"; alias stack-list="stack-pkg list"
11:26:22 <glguy> dcoutts: Is hsc2hs supposed to be listed in build-tools in .cabal files?
11:26:36 <dcoutts> glguy: in theory
11:41:47 <AbelianGrape> Is there any theoretical reason it's bad to add structural record types to Haskell? Like does it break inference or something? I'm thinking along the lines of "foo :: (a::{x :: Int}) -> Int; foo a = x a"
11:42:53 <AbelianGrape> A la Elm. I'm sure other languages do this too, but that's the only one I've tried that does it like this
11:43:03 <monochrom> I don't know. But seems to be doable. SML does it without problems.
11:43:28 <AbelianGrape> Naively, it seems like unification and inference should be pretty simple, but I could imagine it interferes with stuff
11:43:53 <AbelianGrape> It would be a substantial improvement over the existing record system, as far as I can think
11:44:21 <AbelianGrape> I'm not sure how it would integrate with Lenses.
11:45:29 <AbelianGrape> I guess Lens already exports makeFields, which sort of does something like this
11:48:39 * hackagebot diagrams-canvas 1.3.0.5 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.3.0.5 (BrentYorgey)
12:08:39 * hackagebot diagrams-gtk 1.3.0.2 - Backend for rendering diagrams directly to GTK windows  https://hackage.haskell.org/package/diagrams-gtk-1.3.0.2 (BrentYorgey)
12:12:14 <Sinestro> Am I being a moran in how I'm using it, or is Data.Binary dog slow?
12:13:03 <bitemyapp> Sinestro: it's known to be dog slow
12:13:15 <bitemyapp> Sinestro: search "binary" "package" "Haskell" "slow" and see for yourself
12:13:47 <bitemyapp> Sinestro: https://github.com/fpco/store
12:14:55 <Sinestro> Because I just realized that my program is spending more time loading a texture from BMP than it is rendering the model it's texturing
12:39:57 <edwardxhaigh> Hey guys
12:40:08 <edwardxhaigh> New Haskell fan here! :)
12:41:38 <johnw> welcome edwardxhaigh 
12:45:10 <Cale> edwardxhaigh: Feel free to ask any questions you might have about the language as they come up. There are almost always people around who are happy to answer things :)
12:47:42 <suppi> And it's the quickest way to learn
12:49:19 <volhovm> Hi! Is there any possibility to discover other peers in Cloud Haskell? I mean, without spawning them inside the code.
12:49:53 <volhovm> I'd like to have a node per application, but I don't see any function that returns ProcessId from given host and port.
12:50:24 <volhovm> So I don't know how to build up ProcessId.
12:50:25 <volhovm> :(
12:52:10 <Cale> volhovm: I believe that will depend on which backend you're using
12:52:23 <Cale> There seems to be a peer-to-peer node discovery backend...
12:52:25 <volhovm> TCP. But I think i finally came to the solution.
12:52:44 <volhovm> http://haskell-distributed.github.io/tutorials/tutorial-NT2.html#writing-the-server
12:52:56 <volhovm> That's a last tutorial in their list.
12:53:05 <volhovm> I wonder why.
12:54:14 <Cale> The terminology they use is that TCP is a "transport", but there are various backends which use that transport
12:54:19 <Cale> http://hackage.haskell.org/package/distributed-process-p2p-0.1.3.2/docs/Control-Distributed-Backend-P2P.html
12:54:49 <Cale> http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.2/docs/Control-Distributed-Process-Backend-SimpleLocalnet.html
12:55:28 <miniBill> hello, I'm trying to build a package, but the build fails and I need pointers on how to fix it: http://dpaste.com/0J7PAFE
12:55:47 <miniBill> full repo here: https://github.com/miniBill/entangle
12:58:06 <Cale> miniBill: What command are you using to build?
12:59:25 <geekosaur> miniBill, it needs the superdoc package installed. It can't tell that because it's not a known tool and it has to exist *before* it determines dependencies
12:59:47 <geekosaur> (the Setup.hs stuff is a bit dumb currently. I understand work i sbeing done ona new ackage configuration system that should help)
13:00:43 <geekosaur> at leats, I think that's why it didn't catch it as a dependency...
13:02:46 <miniBill> Cale: stack build
13:03:10 <Cale> okay, well, I think I agree with geekosaur about what's missing
13:03:25 <miniBill> so I need to stack install superdoc ?
13:03:43 <Cale> yeah... I think so. I haven't used stack much, but that sounds right :)
13:04:12 <geekosaur> yes, and you might need to do something to the cabal file so it knows to make the package visible --- like Cale, I haven't done much with stack
13:04:30 <geekosaur> bu if stack doesn't know about superdoc then it might not make it visible to your package while configuring 
13:04:52 <geekosaur> that is, if it doesn't know this package requires it during the configure phase as opposed to being a normal build dependnecy
13:09:26 <miniBill> I've added superdoc to stack.yaml, but it doesn't seem to work
13:10:47 <sm> you also need to add it to the dependency list(s) in your cabal file
13:13:35 <miniBill> sm: added it to the cabal file, but still giving the same error
13:14:51 <sm> for quickest resolution, maybe paste the stack file, cabal file, command and error
13:16:03 <miniBill> sm: https://github.com/miniBill/entangle
13:16:15 <miniBill> and I'm running stack build
13:16:30 <miniBill> [cabal build fails too, but that's for a bug in the code]
13:16:46 <sm> interesting, I haven't seen this "-any" before
13:17:05 <sm> I would remove those
13:17:20 <miniBill> let me try
13:18:05 <miniBill> nope, changes nothing
13:18:19 <sm> and what's the current error message ?
13:20:00 <maerwald> I can't install because easyrender doesn't seem to have ghc-8 support
13:21:15 * geekosaur reminds that this appears to be a Setup.hs extra dependency (supported by the fact that Distribution.Superdoc hooks the cabal haddock machinery), and those are known to be handled poorly currently. I'm not sure you can specify the dependencies well enough for sandboxes to work since neither cabal nor stack supports Setup.hs extra deps
13:21:37 <sm> ack
13:22:06 <hexagoxel> cabal _does_ support setup-depends afaik
13:22:08 <mgsloan> Stack does support a "explicit-setup-deps" flag.  It is a bit of a hack, though
13:22:27 <mgsloan> We'll add support for the new cabal 1.24 setup-depends stuff at some point
13:22:38 <mgsloan> I'd rather we just ditch Setup.hs files.  They suck
13:22:44 <geekosaur> indeed
13:23:13 <mgsloan> So the "explicit-setup-deps" flag lets you specify that certain package's Setup.hs should be built against the same deps as the package + Cabal
13:23:15 <geekosaur> they're a notion borrowed from python, where they can work sensibly
13:23:15 <sm> yeah! could we do that ? 
13:23:54 <mgsloan> I think we could, but we'd need to have something which fills their role.  I think this ought to look like hooks that have some simple protocol
13:23:59 <sm> anyway, curious: what's the solution for miniBill ?
13:24:27 <geekosaur> sounds like use explicit-setup-deps and add superdoc to the package deps?
13:24:39 <geekosaur> the latter was done but isn't effective without the former
13:27:09 <augur> why might i be getting this error only when the type in question is wrapped in []?    Illegal polymorphic or qualified type: Lens' s [(a, ABT f)]
13:27:30 * sm tries explicit-setup-deps but fails
13:28:02 <mgsloan> sm: Huh, that really should do the trick
13:28:15 <sm> oh there it goes, I just don't really understand it
13:28:54 <sm> I added explicit-setup-deps:\n  "*": true\n  superdoc:false\n to stack.yaml, now it builds  <- miniBill
13:29:13 <mgsloan> Usually Setup.hs are compiled in a rather fuzzy way.  "Use this Cabal version + whatever else you want from the snapshot DB"
13:29:24 <glguy> augur: Lens' is a type "schema", you can't put it in a list. If you want to put lenses into a list you can use ReifiedLens or ALens
13:29:38 <puregreen> but here the lens isn't in a lis
13:29:39 <puregreen> *t
13:29:40 <mgsloan> This is because before setup-deps there was no principled way to build Setup.hs files 
13:29:58 <augur> glguy: ?
13:30:06 <mgsloan> explicit-setup-deps is a hack that pretends like your library deps == explicit setup-deps
13:30:14 <sm> mgsloan: and that way is still the default with stack ? 
13:30:19 <puregreen> augur: did you mean “[Lens' s [(a, ABT f)]]” or “Lens' s (a, ABT f)” as the other type?
13:30:36 <puregreen> i.e. can you say exactly what 2 types you've got?
13:30:37 <mgsloan> sm: Yes, because Cabal-1.24 was only released recently
13:30:37 <augur> puregreen: the problem only occurs with the first. the second by itself is fine
13:30:46 <mgsloan> Also, we don't really rely very heavily on Setup.hs files
13:31:05 <sm> so when you set e-s-d false for a package, that package's Setup.hs can use only the package's explicit deps
13:31:09 <mgsloan> As far as I know, none of our projects require "explicit-setup-deps"
13:31:32 <mgsloan> sm: It's when you set it to true, but yes
13:31:38 <sm> ..and more importantly in this case, can also use the package's extra-deps
13:31:56 <mgsloan> Yes, more importantly is that now it can use the local package DB packages
13:32:02 <glguy> 03newtype ReifiedLens s t a b 07= Lens {runLens 07:: Lens s t a b}
13:32:09 <glguy> augur: You can put those in a list
13:32:14 <mgsloan> Why don't we allow that by default?  Because the local package DB is mutateable in freakier ways than the snapshot DB
13:32:30 <augur> glguy: i dont get it tho. Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
13:32:37 <mgsloan> You could have old stuff in the local package DB that gets used when compiling the Setup.hs, if we don't lock it down to specific package-ids
13:32:39 <sm> mgsloan: huh, I'm probably still using it wrongly then. What would you write to make just superdoc package use explicit deps for setup ?
13:32:48 <glguy> augur: see the "forall f." part?
13:32:54 <augur> glguy: yes
13:33:04 <mgsloan> sm: For use with stack, do what you're doing.
13:33:07 <glguy> augur: You also can't have this: [forall a. a -> a], you can only have: forall a. [a -> a]
13:33:15 <augur> glguy: wait, really?
13:33:20 <geekosaur> that's a "type", right? so the forall isn't actually at the top level, it's nested when expanded into another type
13:33:26 <glguy> augur: No, I'm totally joking
13:33:27 <geekosaur> which makes it an illegal polymorphic type
13:33:37 <augur> .. why on earth is that the case :(
13:33:42 <nitrix> :t [undefined]
13:33:43 <lambdabot> [t]
13:33:54 <sm> mgsloan: soo.. false means use explicit deps ?
13:34:04 <nitrix> :t [(\_ -> undefined]
13:34:05 <lambdabot> parse error on input ‘]’
13:34:08 <nitrix> :t [(\_ -> undefined)]
13:34:09 <lambdabot> [t -> t1]
13:34:13 <augur> it probably has to do with type inference, doesnt it
13:34:20 <geekosaur> because you dont want it to map the f inside the "type" to an unrelated "f" you happened to be using in the same type signature you used the "type" in
13:34:29 <nitrix> t and t1 !?
13:34:36 <mgsloan> sm: No, when it's true.  Here's the docs http://docs.haskellstack.org/en/stable/yaml_configuration/#explicit-setup-deps
13:34:38 <nitrix> Oh it makes so much sense.
13:34:45 <augur> what type is   [id],    [forall a. a -> a]   or   forall a. [a -> a], both are valid
13:34:47 <augur> i bet thats it
13:36:28 <Cale> augur: [forall a. a -> a] requires the ImpredicativeTypes extension, which is perpetually broken
13:36:48 <Cale> (since nobody really uses it, and it's tricky to maintain)
13:37:10 <maerwald> then it should probably be removed
13:37:23 <augur> Cale: so it says. :)
13:38:21 <sm> mgsloan: the example from there, with replaced "entropy" replaced by "superdoc", makes it work. Before that I tried just superdoc: true, which didn't work
13:39:18 <geekosaur> maerwald, there's just enough stuff relying on it that there's always an outcry when someone goes to remove it
13:39:47 <sm> not a big deal, I'm just giving UX feedback and figuring it out for my own future reference
13:39:52 <nitrix> What does impredicativetypes do?
13:40:03 <nitrix> All I see is monomorphism and polymorphism there :/
13:40:07 * geekosaur thinks one of these peopel that needs it so badly should take over maintaining it, since nobody else seems to be able to...
13:40:08 <mgsloan> sm: Right, thanks!  That's odd, though, that means that you're enabling it for all packages but superdoc
13:40:16 <maerwald> geekosaur: I think it's generally a bad idea to ship broken ghc extensions. If you can't do it right, don't do it.
13:40:20 <sm> just superdoc:false also works
13:40:26 <geekosaur> an impredicative type is a nested polymorphic (forall) type
13:40:40 <edwardxhaigh> Do people recommend using VIM for Haskell, or is there a preferred tool?
13:40:54 <nitrix> geekosaur: What's the other forall nested?
13:40:58 <maerwald> edwardxhaigh: you can use any editor you want
13:41:41 <geekosaur> ?
13:41:42 <sm> it feels like the flag's meaning is flipped
13:41:50 <Cale> edwardxhaigh: any editor which has the feature that automatically converts tabs to spaces should do
13:42:05 <mgsloan> sm: Spooky, could be a regression, but I don't see anything in the code that would cause that
13:42:28 <mgsloan> Yeah, the default is definitely False
13:42:39 <sm> here it seems true by default, and this means no explicit package deps
13:42:42 <shachaf> geekosaur: In particular nested inside something other than (->).
13:42:50 <mgsloan> What's your stack version?
13:42:59 <sm> 1.1.2
13:44:20 <mgsloan> Yeah, I doubt much of the code for this has changed between 1.1.2 and HEAD.  Here's where the default is declared: https://github.com/commercialhaskell/stack/blob/7f7f1a5f67f4ecdd1f3009495f1ff101dd38047e/src/Stack/Types/Config.hs#L1697
13:44:49 <sm> miniBill: see if adding this to your stack.yaml solves the issue: http://lpaste.net/166479
13:44:57 <mgsloan> and here's where it's used: https://github.com/commercialhaskell/stack/blob/7f7f1a5f67f4ecdd1f3009495f1ff101dd38047e/src/Stack/Build/Execute.hs#L838
13:45:29 <mgsloan> So if you think "miniBill: False" is fixing things, I think something else is probably going on
13:45:43 <mgsloan> "-v" is useful, to see how Setup.hs is getting built
13:46:13 <geekosaur> hm, the one cited earlier was *: True, superdoc: False. I wonder if the first one is matching so the second isn't tried...
13:46:45 <mgsloan> Nah, it's an unordered map.  Scroll up in my first source code link to see the logic
13:54:49 <sm> edwardxhaigh: vim, emacs, atom, intellij are all somewhat popular options
13:55:58 <edwardxhaigh> Vim does look very cool - though also pretty tough I imagine to use?
13:57:04 <Cale> I recently switched from Vim to Sublime Text and have been reasonably happy with that.
13:57:59 <kadoban> edwardxhaigh: It's not very tough. There's a tutorial that's decent, and you don't need to know much at all to have it be a decent text editor.
13:58:04 <Cale> yeah
13:58:28 <kadoban> I joke that <Esc>:wq is enough to make it as good as just about any text editor out there, but it's not too far off.
13:59:00 <edwardxhaigh> Okay, thanks Kadoban
13:59:12 <Cale> Basically, use a text editor that you're comfortable with
13:59:25 <edwardxhaigh> So how long has everyone here been programming in Haskell for?
13:59:32 <edwardxhaigh> Cale: thanks :)
13:59:34 <Cale> I've been programming in Haskell since around 2001
13:59:39 <kadoban> Yeah, it's not required either. I like it, but the list of editors I consider "good" is quite long.
14:00:14 <edwardxhaigh> I was mainly asking as a lot of the popular youtubers tend to use vim - I assumed it was perhaps the goto editor 
14:00:29 <Cale> A lot of programmers use either vim or emacs
14:00:44 <sm> I would guess the most common choice among haskellers is emacs
14:00:46 <kadoban> I think emacs might be more popular than vim in the haskell world, though I'm not sure.
14:00:46 <nitrix> Quick question.
14:00:47 <Cale> They were the two main choices for a very long time.
14:01:06 <kadoban> That's just including #haskell as the haskell world too though, which isn't quite correct.
14:01:10 <Cale> Most of the Haskell people I've interacted with use vim
14:01:11 <nitrix> I'm told type inferring for high ranks than 2 is undecidable and that it has been proven.
14:01:18 <sm> huh
14:01:27 <nitrix> higher*
14:01:54 <nitrix> I want to know, is it because of a constrediction in logic or simply not enough information for the type inferrer to work with?
14:02:20 <sm> Cale: why sublime text ? I thought I read it was discontinued, or atom was a successor or some such
14:02:36 <Cale> sm: It's not discontinued -- there are still updates being released for it
14:03:03 <sm> I see
14:03:30 <mgsloan> It seems like emacs is the most popular choice when it comes to having something closer to an IDE
14:03:41 <mgsloan> Vimscript is just too much of a pain to get anywhere close
14:03:56 <geekosaur> lime text wants to think it's the successor to sublime text. I get the impression it's not very successful at it though
14:04:05 <Cale> I dunno, I just wanted something which wasn't vim mostly, and I'd used emacs in the past, and the multiple cursors thing seemed nice (and turns out to actually be kinda useful)
14:04:24 <sm> so I guess sublime text might be a bit faster than atom
14:04:39 <kadoban> I never actually looked much at the features of sublime. It's proprietary, which kind of rules it out for me.
14:04:43 <geekosaur> heh. watching paint dry is a bit faster than atom >.>
14:04:51 <mgsloan> From my experience with it, sublime text is very well written with a lot of attention to detail.  Cloning it is a high mountain to climb
14:04:58 <Cale> Sublime text is pretty instantaneous actually
14:05:28 <kadoban> Yeah, atom has some performance issues in weird cases, and it used to be a tad laggy in general. Not sure if that's improved.
14:05:28 <mgsloan> Yeah, sublime is blazing fast, pretty, and seems to have decent scriptability
14:05:37 <edwardxhaigh> I write a bit in Sublime, and recently Atom. Sublime has always worked well for me and Atom, while it used to be slow and crashed a lot, has improved massively
14:05:39 <mgsloan> But I use emacs due to network effects of plugins and such
14:06:13 <mgsloan> If I were to switch away from emacs I'd probably still use it for "magit"
14:06:15 <Cale> Like, I can close my project which has hundreds of files in it and dozens of tabs open, and then open it again, and it puts my state back exactly as it was when I closed it, down to the location of my cursor, in a few hundred milliseconds
14:06:16 <kadoban> That's good, I kind of want to like atom.
14:06:30 <sm> edwardxhaigh: if you're already living in atom, that's a pretty good choice for haskell hacking too
14:07:33 <edwardxhaigh> Ok - I will stay on Atom, I guess it makes more sense than learning Haskell AND vim :P
14:08:06 <Sonmi> i have enjoyed what time i have spent with atom so far
14:08:09 <kadoban> Yeah if you already know/use a decent editor, no reason to switch really.
14:08:14 <Cale> The multiple cursors thing provides a bit of consolation for the fact that no editor actually really understands Haskell layout
14:08:33 <Cale> (though there's that emacs mode which will get the layout correct by basically not letting you manipulate it :P)
14:08:34 <Sonmi> the only thing that is annoying to me is the somewhat subversive telemetry
14:08:44 <sm> I love multiple cursors
14:08:52 <edwardxhaigh> You can get Haskell add-ons for Atom which are pretty good
14:09:17 <edwardxhaigh> Though I don't know what to compare it too I guess
14:09:54 <sm> they are good, when ghc-mod works. Emacs/vim aren't much better
14:10:42 <sm> I was enjoying atom haskelling, but I must say intellij IDEA feels so much more refined
14:12:29 <mgsloan> I really like Sublime's multi-file find.  Haven't find anything comparable in emacs
14:13:09 <sm> with a live preview, like in intellij ?
14:14:00 <Zemyla> Hmm, is a conduit, in its simplest formation, simply a free monad on ConduitF i o a = Take (i -> a) | Yield o a?
14:14:41 <Zemyla> Well, free monad transformer, generally.
14:16:41 <johnw> Zemyla: yes, exactly that
14:16:53 <johnw> well, of pipes that is exactly true
14:16:59 <johnw> conduit adds two additional "features"
14:17:07 <Zemyla> Oh?
14:17:17 <johnw> notification of upstream termination, and putbacks
14:17:47 <johnw> so, Yield (Maybe o) a, I believe, and then | Leftover l a, adding l to your type list
14:20:48 <edwardxhaigh> Is there a way to filter out the join/quit messages?
14:21:13 <jle`> edwardxhaigh: that's usually handled by your irc client
14:24:47 <geekosaur> freenode's web client is minimal. dedicated irc clients can filter them
14:25:41 <hgaunt> http://wiki.xkcd.com/irc/Hide_join_part_messages
14:27:29 <Edd_> hi
14:28:16 <Sonmi> hi
14:35:15 <buglebudabey> hi
14:40:44 <Edd_> List comprehensions are so cool
14:40:52 <MetalOn> Hey, I'm new at Haskell, and wrote a Monte Caro simulation today to get the hang of it, but for some reason it keeps filling the RAM, until my laptop freezes
14:40:58 <Edd_> I just love how compact they are!
14:41:58 <MetalOn> http://pastebin.com/rmECNVEb So this is the code, could anyone please tell me what's wrong here? Is it the infinite list domehow being completely evaluated?
14:45:12 <cheater> MetalOn: compile it with limited stack size, then wait for it to stack overflow, and look at where it got triggered
14:45:51 <cheater> you should make Pos an unboxed pair of unboxed ints
14:46:50 <cheater> you shouldn't be doing recursion, if you do recursion by hand you're probably doing something wrong. in your case prep_pos should just be fmap
14:47:43 <cheater> same with mainLoop, instead use forever $ do
14:48:41 <ClaudiusMaximus> MetalOn: the code is too lazy, ie, it builds up a huge computation and tries to do it all at the end (which might not be reached before running out of RAM) instead of evaluating it strictly step by step - for example you have a huge (...(n+1)...+1)+1 possibly, because you never pattern match or seq on n
14:50:33 <johnw> ClaudiusMaximus: I wouldn't call that "too lazy"
14:51:05 <MetalOn> Thanks! I'm pretty new to functional programming, still find some consepts kind of hard to grasp
14:51:07 <johnw> it's more like an unfortunate combination of lazy in some ways, strict in others
14:51:23 <Cale> cheater: I don't really agree with that in general... obviously it's nice to be able to write things without explicit recursion, but it's not always possible to do so easily.
14:51:28 <cheater> it's ok MetalOn you're doing typical beginner steps everyone has to do this :)
14:51:42 <cheater> Cale: in his case it is though
14:52:01 <Cale> prep_pos is not just fmap
14:52:01 <cheater> in general, if you're doing something complicated code will become complicated
14:52:02 <ClaudiusMaximus> johnw: thanks for the clarification
14:52:26 <Cale> It's pairing the even and odd elements of the list
14:52:28 <cheater> yeah it's something like fmap + zip
14:52:44 <cheater> or even just zip
14:52:48 <Cale> uhh
14:52:53 <Cale> hm?
14:53:05 <Cale> It's not zipWith Pos xs (tail xs)
14:53:27 <cheater> hmm.. true
14:53:29 <johnw> maximally lazy should just give you a single thunk, and each time you evaluate part of it, you get a thunk for the rest.  maximally strict goes straight to the final answer.  An unfortunate max creates a strict "spine" of an expression or structure with lots of thunks hanging off it, as in this case.
14:53:42 <cheater> but this is good enough and you can then drop every second one
14:53:44 * hackagebot shellmate 0.3.2 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.2 (AntonEkblad)
14:53:45 <johnw> s/max/mix
14:53:46 * hackagebot shellmate-extras 0.3.2 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3.2 (AntonEkblad)
14:53:48 * hackagebot monoid-extras 0.4.1.1 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.1.1 (BrentYorgey)
14:53:59 <MetalOn> So I should zip two lists of random Ints, and then instead of the mainloop do something like forever $ do if time >= maxtime then ... else .... ?
14:54:11 <cheater> MetalOn: yes
14:54:16 <cheater> that would probably be a good idea
14:54:52 <cheater> also read up on how to force evaluation
14:55:10 <cheater> but generally, you should be trying this: 23:44 <   cheater > MetalOn: compile it with limited stack size, then wait for it to stack overflow, and look at where it got triggered
14:56:26 <cheater> http://stackoverflow.com/questions/14163072/how-to-force-evaluation-in-haskell
14:56:39 <ClaudiusMaximus> MetalOn: i don't know what cheater is going on about (sorry), to exit 'forever' you'd need to raise an exception, and also mutable references to pass the state to the next iteration - imo recursion is the idiomatic way to do this, just be careful about what is evaluated and when
14:57:09 <cheater> http://neilmitchell.blogspot.co.at/2015/09/detecting-space-leaks.html
14:57:13 <cheater> read those two links MetalOn 
14:57:33 <cheater> esp the 2nd one
14:57:47 <cheater> i wish i knew that technique a long time ago already
14:57:58 <cheater> would've earned me some money at work :)
14:58:37 <MetalOn> Thanks! Oh man, this is really a lot of new stuff, I'm just happy it even compiled :D
14:58:44 * hackagebot monoid-extras 0.4.1.2 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.1.2 (BrentYorgey)
14:59:48 <cheater> back when i was a huge newbie with haskell i had to shelve a project that was space leaking which would have earned me XXXX $currency. it wasn't a lot of money but still a sad moment in history
15:00:27 <cheater> and this was precisely what i was missing
15:02:55 <MetalOn> Yes, there really are some pitfalls, but still, the language is really fascinating
15:06:51 <ClaudiusMaximus> MetalOn: also you should use foldl' instead of foldl - see https://wiki.haskell.org/Foldr_Foldl_Foldl'  and around that area you use randomRs and later reuse the generator, so things won't be independent - you could better split the generator and use one for randomRs and the other for the rest
15:09:18 <MetalOn> Thanks! Yes I also tried foldl', but pastebin screws up the syntax highlighting and highlights anything between two apostrophes as a String/Char, so thought it would be better to use an easier to read verssion :p
15:09:24 <ClaudiusMaximus> ah ok
15:09:41 <ClaudiusMaximus> there's lpaste.net which is better all around
15:12:45 <Welkin> @lpaste
15:12:45 <lambdabot> Haskell pastebin: http://lpaste.net/
15:13:44 * hackagebot bitcoin-payment-channel 0.1.1.3 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.1.1.3 (runeks)
15:17:41 <MetalOn> Yes, this really looks better :) One more question, I'm trying to reinstall some modules with the -p flag to be able to profile the simulation, but it keeps failing for the Data.Matrix module, there are warnings about redundant imports and then errors about missing profiling libraries
15:18:28 <MetalOn> But when i try to reinstall those using the -p flags, it aborts with a warning that reinstalling could break the Data.Matrix module
15:19:26 <MetalOn> Is it safe to just use --force-reinstalls?
15:22:00 <ClaudiusMaximus> MetalOn: not sure what the quickest fix would be - possibly wiping installed packages (cabal sandbox delete; harder if not using sandboxes), adding  library-profiling: True  to ~/.cabal/config  (first thing i do when setting up a new dev system...) and retry, making sure to use sandboxes (cabal sandbox init)
15:22:55 <ClaudiusMaximus> MetalOn: maybe it would work to install all the dependency chain of packages including matrix and random with one command, with profiling
15:25:57 <mikail__> Hi, in the REPL this code works: (< 0.001) <$> (abs <$> (subtract 1) <$> Right 10)
15:26:16 <mikail__> But when I stick into a HSpec scenario it does not compile
15:26:23 <MetalOn> Thank you so much! It's getting pretty late, but I'm going to do this tomorrow, maybe just completely delete and reinstall cabal
15:26:28 <mikail__> I get : <interactive>:38:2: error:     • Couldn't match expected type ‘Bool -> b’                   with actual type ‘Either a0 Integer’     • Possible cause: ‘(<$>)’ is applied to too many arguments       In the first argument of ‘(<$>)’, namely         ‘(abs <$> (subtract 1) <$> Right 10)’       In the expression: (abs <$> (subtract 1) <$> Right 10) <$> (< 1)       In an equation for ‘it’: 
15:26:55 <mikail__> ((< 0.001) <$> (abs <$> (subtract 1) <$> Right 10)) `shouldBe` Right False
15:26:57 <sm> MetalOn: stack is also quite useful, and I think handles that situation
15:27:12 <glguy> mikail__: use a pastebin instead of pasting into channel
15:27:33 <mikail__> ok, do you still need me to do it?
15:28:50 <mikail__> http://lpaste.net/166486
15:29:39 <glguy> mikail__: Right False :: Either a Bool. Try annotating the type of the expected value
15:29:42 <MetalOn> sm: But limiting stack size only works when profiling libraries of the packages are installed I thought
15:29:50 <glguy> (Right False :: Either () Bool), perhaps
15:29:59 <mikail__> ok, will try that now...
15:30:03 <volhovm> Can anyone help me out with cloud haskell? I've spent around 6 hours trying to understand how to work with nodes with manual discovery, but didn't come to anything.
15:30:08 <sm> MetalOn: I mean http://haskellstack.org
15:30:28 <volhovm> Is it true at least that you can't get a ProcessId out of NodeId?
15:30:54 <ClaudiusMaximus> MetalOn: cabal exec -- ghc mc.hs -O2 -rtsopts    # this should be enough to let you   ./mc +RTS -M1G -RTS   to limit it to 1GB ram, no need for profiling
15:31:13 <ClaudiusMaximus> no need for -O2, but optimisation is generally recommended
15:31:14 <mikail__> nope, i couldn't get it work
15:31:20 <mikail__> i'm going to paste my code
15:31:43 <Cale> volhovm: I believe that is true
15:31:51 <mikail__> i think i am doing things wrong
15:31:52 <volhovm> That sucks so much. 
15:32:03 <Cale> volhovm: Well, which ProcessId would you want?
15:32:11 <mikail__> i am trying to compare two doubles and subtracting them and seeing if they are within a tolerance range.
15:32:20 <volhovm> What's the point of building distributed library if the distinction between local and remote processes is so huge...
15:32:33 <mikail__> but one of the values is a Right Double
15:32:38 <volhovm> Cale: I'm trying to set up a farm of N separate executables running on distinct ports
15:32:40 <mikail__> it's causing me problems
15:33:05 <Cale> mikail__: pattern match?
15:33:08 <volhovm> So there are very convenient functions as `send` or `expect`
15:33:17 <volhovm> But I think I can't apply them to my case.
15:33:28 <Cale> case foo of Left e -> ... handle exceptional case; Right x -> ... compare ...
15:33:36 <MetalOn> sm: Oh yes, this looks easier than trying to fight cabal, going to read up on it!
15:33:57 <Cale> volhovm: Each node may be running many processes
15:34:15 <volhovm> Yes, but there is no function that would get me the [ProcessId] list of node.
15:34:17 <MetalOn> ClaudiusMaximus: I just ran it, but it just crashes saying the heap is exhausted
15:34:51 <volhovm> All discovery modules are doing something different -- like suggesting me to use other send functions. 
15:34:51 <MetalOn> Thanks everyone for your help! Going to bed now, trying again tomorrow
15:34:56 <MetalOn> Good night :)
15:35:08 <Cale> volhovm: Well, various backends will give you ways to get lists of ProcessIds
15:35:34 <Cale> Like, simplelocalnet has  findSlaves :: Backend -> Process [ProcessId]
15:35:46 <volhovm> But it doesn't allow me to specify the host
15:35:58 <volhovm> simplelocalnet works with UDP discovery & broadcasting.
15:36:05 <volhovm> My point is to have static farm.
15:36:14 <volhovm> Where everybody know host:port for every node.
15:36:24 <volhovm> and p2p library doesn't allow me to do it.
15:36:45 <nitrix> Does the Identity monad adds overhead or gets completely eliminated?
15:37:05 <volhovm> Cale: http://goo.gl/WEPIBE
15:37:09 <volhovm> I'm talking about this one.
15:37:19 <nitrix> As in, a transformer over Identity for example.
15:37:25 <Cale> nitrix: Mostly it gets completely eliminated
15:37:26 <mikail__> http://lpaste.net/166487
15:37:31 <Cale> nitrix: It's a newtype
15:37:39 <mikail__> that's the simplified version
15:37:41 <nitrix> Great. Thanks.
15:39:06 <mikail__> is that the best way to compare two doubles?
15:40:36 <Cale> mikail__: uhhhh
15:40:53 <mikail__> yeah
15:40:56 <Cale> mikail__: You're applying Right... why do all the fmaps?
15:41:05 <jle`> nitrix: newtypes in general get eliminated at runtime, but there are some artifacts that persist
15:41:07 <glguy> mikail__: My original suggestion makes that code compile, fyi
15:41:22 <mikail__> giguy i didn't see it
15:41:44 <Cale> Why not just write  not (abs (10 - 1) < 0.001) ?
15:41:47 <glguy> Annotating the type of (Right False)
15:41:50 <jle`> nitrix: for example, 'map Identity' or 'map runIdentity' should be a no-op, but ghc might actually go and traverse the structure and apply 'id' to all the items
15:42:09 <mikail__> because the 10 is a Right 10 in my real code
15:42:26 <lpaste> glguy annotated “Compile error” with “Compile error (annotation)” at http://lpaste.net/166487#a166488
15:42:28 <lpaste> glguy annotated “Compile error” with “Compile error (annotation)” at http://lpaste.net/166487#a166489
15:42:46 <dunpeal> c_wraith: looks like higher-kind types are actually on Rust's roadmap: https://github.com/rust-lang/rfcs/issues/324
15:43:10 <jmcarthur> ooh
15:43:27 <jmcarthur> That and polymorphic recursion would make rust much more appealing to me.
15:43:29 <glguy> Cale: or perhaps write: True ?
15:43:30 <jxv> dunpeal, is anybody trying to tackle it? Last I heard, that wasn't the case?
15:43:35 <jmcarthur> I think polymorphic recursion is long shot though.
15:43:37 <mikail__> giguy it work
15:43:42 <jmcarthur> Because it messes with specialization, which they like.
15:43:43 <mikail__> thanks
15:43:45 * hackagebot shellmate 0.3.2.1 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.2.1 (AntonEkblad)
15:44:57 <dunpeal> jxv: not sure about right now (just found this thread), but a lot of people want it, and it's not averse to any of the language goals.
15:44:58 <c_wraith> jmcarthur, I think polymorphic recursion has the same odds as rank-n types. 
15:45:26 <c_wraith> dunpeal, the main issue is that no one has formalized a design for it. 
15:46:41 <jmcarthur> c_wraith: Sounds about right to me.
15:46:45 <dunpeal> c_wraith: sure, but contrary to previous claims, it's not something that Rust will definitely not have because it's antithetical to Rust's design principles.
15:47:16 <c_wraith> dunpeal, I said that about higher-rank types. totally different. 
15:47:43 <c_wraith> dunpeal, also known as rank-n types
15:48:18 <c_wraith> dunpeal, those are the ones that are incompatible with rust's goals. 
15:56:14 <pikajude> Is it possible to define a datatype that has a field of type forall m. MonadIO m => m Bool?
15:56:32 <glguy> Yes, you'd use the RankNTypes extension
15:56:53 <glguy> But in this particular case it'd be better to put an IO Bool in that field
15:57:48 <pikajude> i'll do the latter
15:57:55 <pikajude> I can write the datatype, but I can't define a FromJSON for it
16:00:49 <Cale> pikajude: Well, of course.
16:01:18 <Cale> oh, FromJSON?
16:01:23 <pikajude> yeah
16:01:27 <Cale> You might be able to write one by hand
16:01:28 <pikajude> it won't typecheck
16:01:38 <Cale> You'll have to decide how to translate the JSON into IO actions
16:02:09 <pikajude> i'll paste
16:03:32 <dylan_1> Is stack's GHCi messed up or something? For some reason when I try to import a little module in the same working directory, and then load up the file with the import, it doesn't work out, giving me this message: https://bpaste.net/show/b372912d0205
16:05:09 <pikajude> here we go http://lpaste.net/5082840847012069376
16:05:17 <pikajude> I don't totally understand the error though
16:05:54 <pikajude> if I change fmap to liftM, it tells me it can't match "forall m. MonadIO m => m Bool" with "m0 Bool"
16:05:56 <glguy> pikajude: <*> type can't contain the awesomeness of your isExpired field type
16:06:02 <pikajude> rats
16:06:19 <mvaenskae> cheers :) does haskell have some form list element manipulation where, given a list of strings i can transform those strings in-place (e.g. remove the last N characters) and work with that? or have it use the n-th word if possible?
16:06:21 <pikajude> I can't write it in the Parser monad either, it doesn't typecheck there
16:06:33 <benzrf> :t liftM
16:06:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:06:36 <glguy> pikajude: If this was a good idea you could could work around this
16:06:42 <benzrf> pikajude: are you sure it's the same liftM in scope
16:06:43 <mgsloan> dylan_1: It can't find the modules that LogAnalysis depends on.  This is probably because there are no target packages
16:06:51 <glguy> but it's not better to use MonadIO here than IO
16:07:05 <pikajude> no?
16:07:07 <dylan_1> mgsloan, so I need to do some weird stuff in yaml files for it to work?
16:07:11 <mgsloan> Lol
16:07:33 <mgsloan> You're funny!  No, you you can do ":set -i ." probably
16:07:35 <Koterpillar> ^^ stack README in one sentence
16:07:39 <Cale> pikajude: If something is an m action for all instances of MonadIO m, then it's an IO action.
16:07:40 <dylan_1> My brother installed Haskell Platform and has had no issues loading files that import modules that are within the same working directory
16:07:50 <Cale> pikajude: So its type might as well just be IO t
16:07:55 <glguy> pikajude: You can always write a new function: isExpired' :: MonadIO m => m Bool
16:08:02 <glguy> isExpired' = liftIO . isExpired
16:08:13 <mgsloan> dylan_1: Ok, I don't see how that is relevant
16:08:14 <pikajude> I know, I just didn't want to have to stick liftIO everywhere I use it
16:08:17 <glguy> No reason to complicate things with RankNTypes here
16:08:25 <mgsloan> dylan_1: Please don't expect tools to work perfectly if you haven't RTFM
16:08:29 <dylan_1> mgsloan, the relevance is, is stack messing with things?
16:08:32 <mgsloan> No
16:08:35 <dylan_1> alright
16:08:37 <mgsloan> Try "stack exec -- ghci"
16:08:42 <mgsloan> It is probably more what you want
16:08:46 * hackagebot shellmate 0.3.2.2 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.2.2 (AntonEkblad)
16:08:49 <mgsloan> "stack ghci" has a lot of extra magic for cabal packages
16:09:00 <dylan_1> Thank you. I see. I am certain this would work better for bigger projects.
16:09:26 <dylan_1> stack exec -- ghci did the trick!
16:09:29 <pikajude> Aside, turning on explicit foralls and Unicode syntax in messages has been very nice
16:09:31 <dylan_1> mgsloan, thanks!
16:09:33 <pikajude> I wish somebody had told me about that earlier
16:09:38 <mgsloan> dylan_1: Welcome!
16:10:08 <mgsloan> dylan_1: Thanks for bringing it up.  I think "stack ghci" without any packages should behave the same as "stack exec -- ghci"
16:10:38 <mgsloan> It doesn't work that way, because well, I + the other stack developers don't work that way very often
16:10:48 <mgsloan> Nearly all of our projects have at least one package
16:11:03 <dylan_1> mgsloan, as do I. This is quite strange for newcomers like me. I got stack because this page: https://github.com/bitemyapp/learnhaskell warned me of the evils of the Haskell Platform
16:11:16 <dylan_1> Right, and that does make sense.
16:12:09 <mgsloan> Rightly so, particularly with the old incarnations of HP.
16:23:43 <pikajude> has anyone here been able to get intero and neovim working together?
16:27:14 <dunpeal> c_wraith: forgive my ignorance, but are higher kinded types the same as higher kinded types?
16:29:58 <Koterpillar> dunpeal: higher kinded types are definitely the same as higher kinded types
16:29:58 <acowley> Is this a question about extensional equality?
16:32:33 <dunpeal> haha
16:32:47 <dunpeal> c_wraith: I meant higher ranked types
16:35:54 <adelbertc> rank refers to the depth of a forall quantifier. e.g. forall a b. a -> b -> a vs fora ll a -> forall b. b -> a
16:36:03 <adelbertc> kind refers to the ability to abstract over type constructors
16:41:50 <dunpeal> adelbertc: thanks, I should catch up on my type theory
16:42:19 <dunpeal> I started with languages like C++, so I always thought of typing as something that gets in my way, and moved on to Python and similar dynamic languages
16:42:39 <johnw> run, rabbit, run; dig that hole, catch the sum
16:42:56 <dunpeal> now I look at modern rich typing systems, and starting to think it's one of the most important features a language can have.
16:43:48 * hackagebot fraxl 0.1.0.0 - Cached and parallel data fetching.  https://hackage.haskell.org/package/fraxl-0.1.0.0 (willfancher)
16:44:19 <johnw> dunpeal: yay, achievement unlocked
17:23:49 * hackagebot rtcm 0.1.7 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.7 (markfine)
17:32:55 <thimoteus> :t ($!)
17:32:56 <lambdabot> (a -> b) -> a -> b
17:43:50 * hackagebot relational-query 0.8.2.2 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.2.2 (KeiHibino)
17:53:50 * hackagebot dns 2.0.3 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.3 (KazuYamamoto)
17:58:50 * hackagebot relational-query-HDBC 0.6.0.1 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.0.1 (KeiHibino)
17:58:52 * hackagebot neural 0.3.0.0 - Neural Networks in native Haskell  https://hackage.haskell.org/package/neural-0.3.0.0 (lbrunjes)
18:09:52 <Koterpillar> how do I find the version of a particular package I have inside ghci, or with a stack command?
18:11:06 <pavonia> Doesn't it tell which packages it's loading at the start?
18:12:25 <Koterpillar> sorry, I mean a library package
18:12:28 <acowley> Koterpillar: stack exec -- ghc-pkg list particularpackage
18:13:05 <acowley> Does anyone have a recommendation on an indexed monads package?
18:14:03 <Koterpillar> acowley: thanks, that's what I needed!
18:22:50 <hodapp> wow. I accidentally did something like attempt 'cabal build' on a library where I'd added a module with a 'main' function, and this made the build fail in completely unspecified ways that didn't point to anything remotely close to 'main' being the problem
18:24:06 <Koterpillar> where does Stack store the downloaded modules' tarballs (or sources)? I have the same (library package) function having different types on different machines
18:28:02 <sm> different lib versions installed ?
18:28:56 <Koterpillar> I'm using stack with the same resolver; stack exec -- ghc-pkg list <that package> shows the same version
18:29:56 <Koterpillar> let's blame system libraries
18:30:18 <sm> Koterpillar: that's odd then
18:31:31 <sm> stack stores in ~/.stack and ./.stack-work, stack path shows some details
18:32:19 <Koterpillar> confirmed, system libraries
18:32:40 <sm> is it some kind of C-integrating lib ?
18:33:00 <Koterpillar> gi-gtk; compare: <return-value transfer-ownership="none" nullable="1"> <return-value transfer-ownership="none">
18:34:20 <Koterpillar> this results in Maybe a vs. a for some a
18:34:25 <sm> ah.. *generated* functions have a different type ?
18:35:07 <Koterpillar> yes
18:35:17 <sm> that's more reasonable
18:35:46 <sm> not very nice though
18:35:51 <Koterpillar> yes, but I still have to deal with this
18:35:56 <Koterpillar> fake typeclass or something
18:36:16 <Koterpillar> instance MaybeMaybe (Maybe a) where toMaybe = id; instance MaybeMaybe a where toMaybe = Just
18:36:30 <sm> require the latest version of the system lib ?
18:36:59 <sm> GTK, I guess
18:38:19 <Koterpillar> well, I'll just need to find a distro that has a nice Docker image and the latest version
18:38:24 <sm> seems worthy of a bug report in haskell-gi
18:38:50 <Koterpillar> how is that a bug?
18:39:00 <Koterpillar> your Gtk is not my Gtk, it turns out
18:40:17 <sm> a feature request perhaps, the readme could mention this and suggest how to deal with it
18:40:49 <sm> pretty much every gi-gtk user will hit it
18:43:30 <Koterpillar> ah, already fixed in master: https://github.com/haskell-gi/haskell-gi/blob/master/bindings/Gtk/Gtk.overrides#L823
18:45:02 <sm> these bindings seem pretty comprehensive, I wonder how many haskell GTK apps are out there
18:45:42 <Koterpillar> they are comprehensive by definition since Gtk is introspectable
18:46:13 <sm> http://hackage.haskell.org/package/coin is one, it had a release today. I guess it uses another set of bindings
18:46:38 <Koterpillar> it depends on the hand-rolled (?) gtk3 package
18:46:48 <Koterpillar> gi-* are generated
18:47:22 <Koterpillar> this is what I'm doing: http://hackage.haskell.org/package/tianbar
18:47:48 <sm> nice
19:17:52 <Zemyla> I have a parsing question.
19:18:35 <Zemyla> There are two main kinds of parsers in Haskell: Parser generators like Happy, and parser combinators like Parsec.
19:19:11 <Zemyla> The main problem with the generators is you have to run a separate program on them; the main problem with the combinators is that they're mostly assembled at run-time, making them ineligible for a number of transformation.
19:19:55 <Zemyla> Is there a parser library where the language to be parsed is assembled using Template Haskell quasiquoters?
19:34:11 <nitrix> mkWeak :: k -> v > Maybe (IO ()) -> IO (Weak v)
19:34:18 <nitrix> "Establishes a weak pointer to k, with value v and a finalizer."
19:34:28 <nitrix> I'm not sure what the `key` and `value` refers to concretely.
19:36:22 <nitrix> If I have the value 5, then what is the key? Vice-versa, It's saying a weak pointer to `k`, with value `v`, so let's point to 5 as `k`, then what's `v` ?
19:36:41 <nitrix> mkWeakPtr is simpler but doesn't solve the mystery for me.
19:38:14 <dolio> nitrix: I think the value won't get collected as long as a reference to the key is still retained, or something of that sort.
19:38:32 <nitrix> dolio: Oh so it's like `seq`.
19:38:39 <dolio> So it's more general than just having to retain a reference to the value.
19:38:41 <nitrix> The operands have semantics.
19:38:53 <kahn> does anybody know where Hakyll rewrites mailto links/a tags, and how to disable this?
19:39:10 <nitrix> dolio: I'll go with that definition in mind and re-read the description, see if I get it.
19:40:37 <nitrix> dolio: Oh I see what it's doing. You are correct.
19:41:06 <nitrix> dolio: Weak v represents the value `v`. The value `v` is user-defined when the pointer is created and exists as long as `k` doesn't get garbage collected.
19:42:18 <dolio> Yeah. So you can build something where you hand out a 'reference' to v that contains a k to prevent the v from getting collected, but once all of those references disappear, v gets collected.
19:43:11 <nitrix> dolio: Thank you. I'll see how far I'm getting.
19:43:43 <nitrix> I'm building a relational library out of frustration from ixset, STRef and IORef.
19:45:01 <nitrix> STRef doesn't allow to re-use the `s`, ixset isn't O(1) and IORef contaminates the application with IO all over the place.
19:45:42 <nitrix> EvanR helped me figure out a way, it's safe, it's neat, but now, the relation is maintained even when I explicitly destroy it :P
19:46:19 <nitrix> So, reading the weak stuff. Hopefully I don't have to touch finalizers, it seems that's what makes them dangerous :P
19:48:13 <nitrix> Oh and StateT is over one giant type; mine allows multiple small cells.
19:58:00 <glguy> Zemyla: I think there's a library for running a happy parser inside a template haskell quasiquoter
19:59:40 <glguy> The mkWeak stuff is tricky because it's not always easy to guess when something is going to be garbage collected. The orignal reference can be GC'd even if the value is preseved via reconstruction or unpacking, etc
20:00:55 <glguy> mkWeakIORef is less unpredictable because it attaches to the mutvar# which was allocated by newIORef
20:03:14 <nitrix> glguy: That's comforting.
20:03:37 <nitrix> I'll be using solely mkWeakIORef for this proof-of-concept idea of mine.
20:04:51 <nitrix> glguy: So I accidently saved myself nightmares apparently. Thanks for the insight.
20:05:20 <glguy> The normal weak stuff is just for caching/optimization, not for guarantees
20:06:24 <nitrix> Noted.
20:13:57 <Sinestro> Using the fancy new `store` library, is there a way to just say "Okay, I'm done" and skip everything else in the bytestring?
20:28:55 * hackagebot pinboard 0.9.5 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.5 (jonschoning)
20:38:18 <anohigisavay> hi
20:38:34 <anohigisavay> how do i debug an Illegal instruction (core dumped) error?
20:38:57 <anohigisavay> i'm trying to deploy a yesod app to a digitalocean ubuntu 14.04 droplet
20:39:21 <Koterpillar> did you compile for x64 and run on x86, or similar?
20:39:50 <linoge> Hi, I was wondering if MFlow is dead?
20:39:58 <linoge> Like, not maintained?
20:41:25 <anohigisavay> Koterpillar: no, both are x86_64
20:42:55 <glguy> If you compiled the program on a computer that had the AES-NI instruction set and ran it in a virtual environment that didn't you might get that (throwing out a guess)
20:50:05 <glguy> anohigisavay: In the past it was the case that DigitalOcean didn't have this instruction enabled, if it still is I expect that that is the problem
20:52:01 <anohigisavay> glguy: thanks for your hint :D i guess there might be some compile time settings that can tweak these options?
20:52:29 <anohigisavay> i'll look it up thanks man :D
20:55:09 <glguy> anohigisavay: yesod transitively depends on cryptonite, cryptonite has a flag for disabling aes-ni support
20:55:33 <glguy> anohigisavay: I don't know if any of the other 136 packages use that instruction, though
22:57:53 <wilornel_> Hey guys! Some languages are considered low-level (assembly or C), others, high level (Python, Java). I know that Haskell is definitely not a low-level language. However, some people have written operating systems and video games using it. So, I was wondering, how low-level should Haskell be used? Is it a good idea to go as low level as writing an OS in Haskell? To me it seems like not only is it a functional language, 
22:58:12 <wilornel_> What shortcomings does Haskell have in this regard?
22:58:56 <ent> your sentence seems to have been cut short
22:59:10 <ent> ... not only is it a functional language,
22:59:15 <wilornel_> What were my last few words?
22:59:27 <M-Shrike> He probably hit , instead of .
22:59:27 <wilornel_> not only is it a functional language, but since it can work like a procedural language at times, it could be used almost anywhere!
22:59:33 <wilornel_> voila!^
22:59:49 <M-Shrike> Fixed!
22:59:56 <ent> :)
23:00:04 <wilornel_> s/get that/fixed/gc willya?
23:00:28 <Koterpillar> wilornel_: you are mixing two concepts: "low level" as "close to OS", and "low level" as "not having advanced abstractions". Haskell can work as the former (with some limitations), but definitely isn't the latter
23:00:31 <wilornel_> I don't know why irssi does not deal with sending long messages in multiple parts
23:00:36 <Koterpillar> s/close to OS/close to hardware/
23:01:10 <ent> low/high level is a pretty confused term. isn't c traditionally called a high level language
23:01:13 <wilornel_> Hmm I didn't mean to say that it does not have advanced abstractions 
23:01:41 <wilornel_> C is higher level when you're dealing with software closer to the hardware
23:01:59 <ent> but these days it seems that not having a garbage collector is enough to be called low level
23:02:07 <wilornel_> But when it comes to the application level, C is pretty low-level (well that's how I see it)
23:02:26 <wilornel_> It's just that so many things compile down to C
23:02:32 <Koterpillar> wilornel_: you can definitely write an OS in Haskell, but you are going to have troubles with libc; see that haskell unikernel for examples
23:02:33 <wilornel_> Or will work on top of C
23:03:51 <wilornel_> hmmmm I see
23:04:00 * hackagebot ld-intervals 0.1.0.0 - Data structures for representing arbitrary intervals  https://hackage.haskell.org/package/ld-intervals-0.1.0.0 (savannidgerinel)
23:04:46 <wilornel_> I would like to think it could be applied to everything
23:05:37 <wilornel_> can't find anything about issues with libc
23:06:30 <wilornel_> Ah, here: http://sylvain-henry.info/blog/posts/2014-04-01-libc-considered-harmful.html
23:06:44 <wilornel_> So there is a lot of state (errno, for example)
23:07:07 <wilornel_> But I do not see why errno would be a problem. I think that Haskell is supposed to be able to deal with state, no?
23:07:13 <wilornel_> (I am still learning about it)
23:07:54 <platz> I think I broke ghc http://lpaste.net/166502
23:09:00 <Koterpillar> wilornel_: I can't find it now, but the issue is, ghc assumes you are using a sane libc, which in turn relies on syscalls into an OS
23:09:23 <Koterpillar> wilornel_: if you are writing an OS, you have to write a libc first or replace parts of haskell stdlib
23:10:03 <Koterpillar> wilornel_: here's some reading: http://uhsure.com/halvm3.html
23:10:28 <wilornel_> Thanks Koterpillar !
23:24:01 * hackagebot docvim 0.3.1.3 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.3 (wincent)
23:36:30 <f-a> is there a simple way to check if a key is down?
23:37:02 <Koterpillar> f-a: context? Gtk, Windows, ncurses, etc.?
23:38:21 <f-a> Koterpillar: sorry. I am experimenting with a barabone roguelike, as now I have no curses no anything, just ANSI.Terminal. Of course when I press 'j' and keep it pressed it will act as 'normal' in terminal (outputting j once and after a second a 'stream' of those)
23:39:03 <f-a> so I wondered: how do I get to print 'j' x times per second when it is pressed? I don't know if I explained myself clearly.
23:39:29 <Koterpillar> clear enough, but unfortunately I don't know the answer for ANSI.Terminal
23:40:13 <f-a> Koterpillar: any answer will do
23:40:29 <Koterpillar> the answer for Gtk will not help you
23:40:39 <Koterpillar> or, say, Windows
23:41:03 <chronon-io> cd ../
23:41:10 <chronon-io> oops
23:41:12 <f-a> xD chronon-io 
23:41:56 <chronon-io> f-a: I've been doing that non-stop for the last two days; I don't know what changed to bring it on...
23:42:37 <chronon-io> Clearly I'm not responsible enough to own an IRC client
23:42:50 * f-a fetches a cup of coffee and offers it to chronon-io 
23:43:32 * chronon-io accepts gratefully
