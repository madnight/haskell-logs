00:03:37 <EvanR> pavonia: ... Word32 -- store index, if in doubt, use 0 ;)
00:05:08 <EvanR> pavonia: i have a feeling it works by creating a hetero map of names-to-values, and putting that in index 0
00:06:09 <pavonia> If that Word32 represents a pointer, I don't think this is going to work
00:07:10 <pavonia> Ah no
00:07:35 <EvanR> no its an index into a vector of stores
00:08:41 <EvanR> so far this all sounds pretty clunky unless you do what rapid has set up, which is to auto run an action to store your programs state, then reload it after the code reloads
00:14:14 <pavonia> This is just for testing some functions while trying to avoid reparsing the test data, so maybe this is a bit of unnecessary overhead anyway :p
00:18:13 * hackagebot cryptohash-md5 0.11.100.1 - Fast, pure and practical MD5 implementation  https://hackage.haskell.org/package/cryptohash-md5-0.11.100.1 (HerbertValerioRiedel)
00:18:16 * hackagebot cryptohash-sha1 0.11.100.1 - Fast, pure and practical SHA-1 implementation  https://hackage.haskell.org/package/cryptohash-sha1-0.11.100.1 (HerbertValerioRiedel)
00:20:17 <volothamp> Hello everyone, I'm using xmonad libs to spawn xmobar with this spawnPipe http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-Run.html#v:spawnPipe but sometimes the redirect of Stdin is not working properly. Does anyone here have an idea on how to inspect a GHC Handle, to trace the execution of it?
00:21:37 <Koterpillar> volothamp: spawnPipe is unreliable, see taffybar and tianbar [disclaimer: I'm the author of tianbar]
00:21:51 <volothamp> thank you Koterpillar, that helps
00:21:53 <Koterpillar> s/unreliable/hard to get right when you restart things/
00:22:52 <volothamp> From what I see taffybar and tianbar are substitues for xmobar, but you still have to run them at startup
00:24:14 <Koterpillar> yes, but they can run independently
00:24:19 <Koterpillar> i.e. I just run tianbar & xmonad
00:24:40 <volothamp> ok thanks
00:48:26 <minib00m> hey guys, i was wondering with what can i practice my haskell skills
00:48:52 <volothamp> minib00m: what's your current haskell level? Have you been reading/read already a book about it?
00:49:00 <Axman6> we really should have a wiki page with some projects and requirements for people to practice with. 
00:49:06 <oherrala> minib00m: Do some Project Euler and/or Codewars challenges?
00:50:09 <minib00m> i did some pascal interpreter (not full) in haskell, it had around 1k lines, so my experience is not great
00:50:37 <minib00m> and i'm searching for something that could be next step in my education, but i don't want to choose some overkill
00:51:14 <minib00m> Project Euler etc are great, but i'd prefer to write something little bigger :) 
00:51:21 <minib00m> i hope you get me :D 
00:51:31 <volothamp> Ok so you're searching for a project to contribute to?
00:53:26 <minib00m> preferably start myself
01:02:25 <volothamp> Then I guess your imagination is your only limit :)
01:03:23 <minib00m> yeah, i thought about little game that has central LAN server and two people can join to this server and play real time tetris-like game
01:06:31 <minib00m> but it seems like it's huuuge thing to do... :p
01:07:38 <volothamp> you could separate the two parts: the server/client join and sending message and the tetris like game
01:08:00 <volothamp> In this way it seems smaller and probably less intimidating
01:09:19 <minib00m> you are right
01:10:09 <minib00m> correct me if i'm wrong - i was thinking about communication in this server in such manner:
01:11:31 <minib00m> client 1 tells server that he needs some partner, client 2 comes and server that he needs some parter. Then server realises that there are 2 people unmatched and he sends them unique ID of their game room
01:12:13 <minib00m> then if client 3 comes and then client 1 again starts app and connects to server then they get tottaly new game room ID. 
01:12:46 <minib00m> and communication is always via server via messages in form [game room ID] message
01:13:31 <minib00m> would this work/is it effecient? I'm pretty newbie in network communication
01:15:05 <volothamp> You're doing two things together: joining a server and auto-discovery of empty rooms
01:15:17 <volothamp> I'll stick with a simpler idea: one server with one room, and clients join it
01:15:45 <volothamp> If there's a two player maximum, then simply avoid letting the client connect to the server if it's already full
01:16:32 <minib00m> ok, i will stick with that :)
01:17:11 <volothamp> remember not to trust the clients in a multiplayer game... that's a typical error that even major software houses do
01:17:34 <volothamp> It's the server the stores the state of the game, and it should always double check for invalid position/moves
01:18:58 <volothamp> i.e. in a checkers game, if a player is in 1,1 and wants to move to 6,6 it shouldn't allow that
01:19:14 <volothamp> even if the client tells the server to do so
01:19:56 <minib00m> got you :)
01:20:15 <volothamp> perfect, have fun
01:20:40 <puregreen> what are examples of types that are Num but not Enum?
01:20:42 <minib00m> i think simple chat room to begin with sounds to be cool idea
01:20:55 <minib00m> volothamp: thanks for you help :)
01:24:02 <seivan_> What is Parsec Prim?
01:24:10 <seivan_> How is different from regular parsec?
01:29:10 <quchen> seivan_: It's the internal part of Parsec. "Regular Parsec" makes use of the Prim modules.
01:29:13 <volothamp> no prob minib00m 
01:30:49 <seivan_> quchen: And permutations?
01:36:59 <merijn> puregreen: Float (of course an Enum instance exists, but it is vile and evil)
01:37:05 <merijn> puregreen: Also, Complex numbers
01:37:48 <puregreen> okay, thanks
01:38:51 <Squarism> so you cant use constructors as a type? 
01:39:37 <quchen> Value constructors, such as Just or True, cannot be used as types.
01:39:59 <Squarism> ok.. that was what i was trying
01:42:52 <Squarism> so are there any trick to group a set of data types under some umbrella? 
01:43:18 <Squarism> type classes? 
01:44:49 <quchen> Sum types group different data types under an umbrella. For example, "Either Int Char" groups Int and Char together to a new type.
01:47:56 <Squarism> Either X (Either Y (Either Z ..))
01:48:03 <Squarism> !! nooo
01:48:14 <quchen> For example, yes. Although I recommend that if you have many fields you define your own type.
01:48:41 <quchen> data MyStuff a b = A a | B b | Str String | Tuple (Int, ())
01:49:29 <quchen> Squarism: Similarly, if you needed a 4-tuple, you wouldn't write (X, (Y, (Z, W))). You would define your own type with 4 fields for it.
01:49:45 <Squarism> ok.. good to know
01:50:13 <quchen> Like pairs (x,y) can be thought of as the 2-element product type that is built-in, Either x y is the 2-alternative sum type.
01:51:04 <quchen> "Maybe a" is also a sum type, for example. data Maybe a = Nothing | Just a
01:51:59 <quchen> Lists are both,  data List a = Nil | Cons a (List a) -- Sum "|" and product because Cons has multiple fields
01:53:47 <quchen> If you think about how many different values "Either a b" can have, it's "number of values a can have PLUS number of values b can have".
01:54:09 <quchen> Similarly for products: (a,b) has "number of values in a TIMES number of values in b"
01:54:27 <quchen> If you're wondering where those names come from, or how to remember them. :-)
01:54:51 <seivan_> How come Parsec only have commonly used parsers for char, and not for every type?
01:55:04 <seivan_> Why wouldn't oneOf be for arrays, ints, etc?
01:55:10 <Squarism> i dig the haskells typesystem, its just that you've gotten used to subclasses and interfaces
01:55:40 <quchen> seivan_: There are more generic functions for that, such as <|>, asum
01:55:57 <quchen> asum [parser1, parser2, parser3]
01:56:07 <quchen> … will try the 3 parsers in order, taking the first matching one
01:57:15 <quchen> Squarism: Sum types often take the place of subclasses of a common superclass. But it's a *very* sloppy comparison.
01:58:55 <seivan_> quchen: Good point.
01:59:00 <seivan_> Trying to map my head around this
01:59:14 <seivan_> I guess everything is generic, except those methods on top of char
01:59:25 <seivan_> choice and many1 can work with any types
01:59:36 <seivan_> but noneOf is only for char
02:01:37 <quchen> It's very useful to know what Applicative, Alternative and Monad do for parsers.
02:01:44 <quchen> asum, sequence, traverse, …
02:02:55 <merijn> seivan_: Yeah, a lot of the combinators (many, some, asum, etc.) are just reexports of Alternative/MonadPlus
02:03:39 <merijn> seivan_: Alternative is a lot like Monoid with a different kind
02:04:27 <merijn> "class Alternative f where empty :: f a; (<|>) :: f a -> f a -> f a" where empty is the left and right identity for <|>
02:06:56 <seivan_> Trying to figure out if I should make duplicates of e.g oneOf for both String and Character
02:07:01 <seivan_> or figure out a common protocol
02:07:05 <seivan_> Trying to port Parsec to  swift
02:07:53 <merijn> I forget, does Swift have typeclasses?
02:09:25 <seivan_> merijn: Ehm, sure?
02:12:27 <dysfun> not quite
02:13:36 <seivan_> Parsec seems heavy focused on Char types.
02:13:42 <seivan_> But once in a while I see string
02:16:28 <dysfun> String is just [Char] ?
02:16:41 <seivan_> also why can't case-insensitivty be another parser. Like oneOf("adsad").caseInsensitive()
02:17:23 <dysfun> it's more that it isn't, than that it couldn't be
02:17:23 <seivan_> dysfun: Yeah but you'd want oneOf to work with both "a string" and ["a", "r", "aay"] and 
02:17:39 <seivan_> dysfun: I am sorry?
02:17:40 <dysfun> "a" and "r" are strings
02:17:47 <dysfun> 'a' and 'r' are characters
02:18:13 <seivan_> Ok, just curios over how Haskell solves avoiding two methods
02:18:20 <merijn> seivan_: Because not all characters have a case?
02:18:56 <merijn> seivan_: Char is proper unicode and not all unicode characters have cases, so I'm not sure if "case insensitive" always makes sense?
02:19:17 <dysfun> that's a fair point. unicode doesn't just deal in alphabetic chars
02:19:58 <dysfun> now you have to decide how to handle those chars (don't convert them?)
02:19:58 <merijn> dysfun: Random fun fact: It's a "bug" that GHC accepts https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
02:20:38 <dysfun> what are the 'eyes', some sort of grapheme?
02:20:38 <Akii> lol
02:20:48 <merijn> Why? Because currently the report specifies that identifiers MUST start with a lowercase letter, but 'ಠ' is from the kanada alphabet which doesn't have a case
02:20:59 <Akii> merijn: what have you done showing this to me
02:21:03 <merijn> Which means that it's not lowercase and technically not a legal part of haskell identfiers
02:21:06 <seivan_> What about arrays?
02:21:14 <seivan_> oneOf[1,2,3]
02:21:18 <seivan_> an array with ints
02:21:19 <dysfun> those are lists
02:21:21 <seivan_> Why wouldn't you want that?
02:21:31 <seivan_> Just trying to figure out why it's tightly set to chars only
02:21:40 <merijn> Akii: You should browse the entire ACME section of hackage :p
02:21:53 <dysfun> merijn: Akii: also the Acme:: namespace on cpan
02:22:04 <Akii> wow
02:22:40 <dysfun> seivan_: you could spend a long time trying to understand how parsec does things. perhaps you should start with attoparsec instead? it's much easier to understand the model
02:24:54 <seivan_> dysfun: That's not the issue
02:25:03 <seivan_> I am just trying to understand if I should make it generic, or hard code to Char
02:25:19 <seivan_> it seems dumb to hard code to char (but parsec does that) since String would work just as well
02:25:34 <dysfun> there are quite a few combinators though
02:25:39 <merijn> seivan_: Parsec doesn't hard code to Char
02:25:54 <seivan_> merijn: https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html
02:25:54 <merijn> seivan_: Parsec picks a 'token' based on stream type
02:26:07 <merijn> seivan_: "Text.Parsec.Char" <- note the last word
02:26:13 <seivan_> Yeah, it's on char
02:26:16 <merijn> seivan_: Parsec uses Char for Text/String
02:26:26 <merijn> seivan_: You can implement custom streams with custom tokens
02:26:27 <seivan_> all those functions, letter, lower, oneOf
02:26:44 <seivan_> but then they would have to implement oneOf themselves
02:27:00 <merijn> Well, yes,
02:27:02 <dysfun> what do you think typeclasses do?
02:27:11 <merijn> oneOf works for all streams that have Char as token type
02:27:34 <seivan_> Does a char have itsel as a token type?
02:27:41 <merijn> seivan_: Char is not a stream
02:38:06 <ij> Something blocks via STM and program crashes, though it's not exactly my code that does this, even though I probably am to blame. Is there anything better than print-debugging in this case?
02:39:43 <tsahyt> what exactly happens when I put a bangpattern before something that is a function type?
02:40:15 <tsahyt> say I have map !f (x:xs) = ... for example
02:40:45 <merijn> tsahyt: Do you know what WHNF stands for?
02:40:48 <tsahyt> yes
02:41:02 <tsahyt> but I'm not sure how to understand WHNF on a function
02:41:03 <merijn> tsahyt: bang pattern just says "force this to WHNF"
02:41:16 <tsahyt> maybe my understanding of whnf is flawed to begin with
02:41:46 <merijn> tsahyt: Well, suppose I have a Map of function and I do "myMap ! key" as argument to map
02:41:46 <luite> ij: how does it crash?
02:42:10 <ij> luite, With "thread blocked indefinitely in an STM transaction".
02:42:10 <merijn> tsahyt: You want to force the lookup to evaluate immediately
02:42:21 <seivan_> I am gonna try this, a CollectionType with where c.SubSequence == c, c.Iterator.Element == Characte
02:43:02 <luite> ij: perhaps with ghc 8 and profiling enabled you'll get a more informative stack trace
02:43:41 <tsahyt> merijn: but this won't build the resulting list immediately, will it?
02:43:58 <Akii> isn't there like a step debugger for Haskell?
02:44:03 <tsahyt> Akii: yes, ghci can do this
02:44:37 <merijn> tsahyt: No, it just forces the lookup of the function to WHNF
02:45:41 <tsahyt> ah so basically instead of passing the function that returns the function from the Map, the lookup is "already done" as far as map is concerned?
02:46:41 <merijn> tsahyt: See also https://hackhands.com/guide-lazy-evaluation-haskell/
02:52:01 <luite> ij: I wonder if these things could be made more informative by keeping track of a few more things in the rts. with profiling enabled, it's already known where all TVars were allocated (cost centre stack). if it also kept track of the stack where each thread was forked and where each TVar (or MVar) was last modified (and by whom), it'd probably already be quite helpful
02:52:54 <luite> the exception would then print which TVars the transaction is blocked on
02:53:40 <ij> 7.10 is too old?
02:54:49 <luite> 8.0 has improved error reporting with implicit parameter based stacks
02:56:10 <seivan_> Why is satisfy only on Character?
02:57:01 <ij> Everything is being rebuilt for profiling, this will take a while... ehh
02:57:19 <luite> ij: i think profiling will give you stack trace prints with 7.10 as well... but I don't remember if that has also been improved with 8.0, haven't used 7.10 much since december :)
02:57:40 <ij> I'm a lazy updater.
02:58:09 <luite> I don't recommend updating that early, it's a pain :)
02:58:20 * dysfun updates his stack version periodically and lets it decide when i get a new ghc
03:00:19 <luite> ij: I only updated to port GHCJS to the new version, to make sure that I'd spot breakage requiring changes in GHC itself before the 8.0.1 release
03:01:03 <dysfun> ah, ghcjs is where i recognise your name from! i was wondering
03:01:27 <tsahyt> So I am working on a library that is to be used by a solver written in C++ as a plugin, which makes profiling a massive pain. So I have functionality to log all calls from the solver to a file, and then replay it in a separate haskell application for profiling purposes. Letting the GHC runtime output stats while running with the solver reports a memory usage of about 20M. Doing the same from the replay
03:01:29 <tsahyt> application reports about 230M. According to heap profiling, memory accumulates linearly in the replay version, but the size of all data structures should be constant, and indeed when used through the solver it seems that this does work. What's more is that heap profiling shows that it's not the reading of input data that lets memory accumulate like that but it points to cost centres manipulating data
03:01:31 <tsahyt> structures in the library itself. What is going on here?
03:01:33 <fvh> I have snap app which runs fine locally, but running in docker in cloud gives "A web handler threw an exception. Details: thread killed" snap logs don't give much info, how can I pinpoint issue?
03:03:32 <luite> dysfun: if you were wondering why it still doesn't work on GHC 8... almost done, for real now :)
03:06:17 <tomjaguarpaw> Is there some tool for inspecting large heap objects, and in particular, seeing what names they are bound to?
03:06:28 <ij> I really wish to try it out someday. It would be cool to make an actual app with hs and browser as UI.
03:06:37 <dysfun> luite: :)
03:06:49 <dysfun> actually stack is still on 7.10.3
03:06:57 <dysfun> well, stable stack is
03:07:14 <geekosaur> yes. likely some things in stackage have not been updated yet
03:07:53 * geekosaur actually has a bug report for xmonad from stackage nightly build... but no 8.0.1 here yet
03:08:18 * hackagebot safe-exceptions 0.1.0.0 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.0.0 (MichaelSnoyman)
03:08:20 <dysfun> yeah, i'm going to wait it out. i don't think i have the patience to adopt 8 yet
03:08:49 <geekosaur> usually you want to wait for .2 anyway
03:09:29 <dysfun> for the first time in my life, i'm actually tracking haskell releases
03:18:02 <ij> If I `stack build --executable-profiling', then it doesn't delete the old non-profiling builds for libs?
03:33:18 * hackagebot boring-window-switcher 0.1.0.0 - A boring window switcher.  https://hackage.haskell.org/package/boring-window-switcher-0.1.0.0 (debugito)
03:35:41 <quchen> ij: I don't know, but in general I assume that Stack doesn't delete anything.
03:37:09 <tsahyt> is there some way to find code by its cost centre number? foo.\.\ isn't very helpful sometimes
03:37:24 <quchen> geekosaur: Trifecta is still missing from nightly, for example. And with Trifecta comes e.g. Idris.
04:15:09 <tsahyt> is it worrysome to have a growing amount of data in lag state? as far as I understand that's just data that hasn't been GC'd yet, right?
04:20:31 <merijn> tsahyt: That depends, are you running out of RAM? :p
04:21:07 <tsahyt> merijn: not anymore since I switched my monads to strict versions. But almost all of the memory consumption is now in lag state, and that's on small examples. It might very well make me run out of RAM eventually
04:21:45 <merijn> tsahyt: GC only runs after a certain amount of garbage (why waste CPU on running GC if you're not using much memory)
04:21:57 <merijn> tsahyt: If you're running small examples it might not allocate enough to trigger GC
04:22:33 <tsahyt> okay. so my understanding is somewhat correct that this is just data that has been generated, used, and now waits for collection
04:22:45 <tsahyt> now I just need to figure out whether I want to generate that in the first place
04:23:10 <merijn> I'm not sure it's that, but I do now GC only runs after your allocation exceeds some amount of date
04:23:20 * hackagebot hspec-megaparsec 0.2.1 - Utility functions for testing Megaparsec parsers with Hspec  https://hackage.haskell.org/package/hspec-megaparsec-0.2.1 (mrkkrp)
04:23:35 <tsahyt> can I force the GC to run earlier with some RTS options?
04:23:40 <tsahyt> just to test things
04:23:51 <merijn> tsahyt: Yes, consult GHC manual for details :)
04:34:32 <EvanR> tsahyt: you can also trigger GC cycles yourself with code
04:35:04 <tsahyt> EvanR: That does sound interesting indeed as I'm often waiting for the solver to do something and have some free cycles inbetween. How would I do that?
04:35:32 <EvanR> System.Mem
04:36:09 <EvanR> if youre looking at a memory usage profile and memory is growing but you think youre only using constant amount, then it might be a leak
04:36:31 <EvanR> memory which is used and quickly dropped should be recovered pretty fas
04:36:51 <EvanR> thats the whole generational thing
04:37:08 <tsahyt> but a leak shouldn't be in lag state I think
04:37:32 <tsahyt> at least not a classic space leak due to too much laziness
04:38:03 <tsahyt> oh no wait, I've got it the wrong way round
04:38:18 <tsahyt> I was thinking of drag state
04:38:53 <tsahyt> so memory is being allocated and not used until very much later. that's a bit surprising.
04:39:14 <EvanR> yeah lag state is before you use it
04:39:20 <dysfun> and you're not allocating e.g. a huge vector?
04:39:31 <tsahyt> nope
04:39:45 <EvanR> tsahyt: especially for examples, you might be generating a bunch of aux data thats not being checked by anything
04:39:58 <EvanR> in record fields
04:40:19 <tsahyt> EvanR: but if it's never used it would be in void state I think
04:40:46 <EvanR> i dont really get the void state
04:41:08 <tsahyt> "An object which is never used is said to be in the void state for its whole lifetime." from the GHC manual
04:41:12 <EvanR> but that is an issue i had with recursive game loops where data is simulated but never looked at
04:41:34 <EvanR> it just kept chaining on top of itself and never reducing
04:41:41 <tsahyt> I definitely do have some data that is never looked at, but I can't tell in advance which part of the data that is so I need to store it anyway. however, it's still just a constant amount
04:42:06 <EvanR> if youre forgetting it promptly, shouldnt matter
04:42:35 <EvanR> i dont get void because, how does it know its never used... of its lag, sounds like it thinks it might be used at some point (and then you dont)
04:43:11 <tsahyt> as far as I understand, the fact that it's actually never used is inferred afterwards
04:43:18 <tsahyt> by whatever magic the profiler does
04:43:52 <EvanR> the two ways i could have dealt with it is actually look at the data, which would eventually happen later in development, or use strict fields everywhere
04:44:28 <tsahyt> right now all this lag is piling up in (>>) of all things according to profiling
04:44:42 <EvanR> >> in a writer?
04:45:05 <tsahyt> there is a writer involved, yes
04:45:36 <tsahyt> well there's a writer monad involved, but I never use tell
04:45:45 <tsahyt> it's a relic really, I should probably refactor that anyhow
04:46:19 <ironChicken> i can't work out how to use the Language.Java.Parser.parser function
04:46:24 <tsahyt> RWS to be exact. and it's the strict variant.
04:46:24 <EvanR> i would bet this magic void after-the-fact redaction ust isnt wokring like you think
04:46:52 <tsahyt> EvanR: even if it doesn't, my problem isn't data being in void but in lag.
04:47:00 <phanimahesh> there's a java parser in haskell? never knew!
04:47:04 <EvanR> ... thats what im talking about
04:47:19 <EvanR> it just sounds like a memory leak
04:47:39 <tsahyt> memory leak or space leak?
04:48:00 <merijn> tsahyt: Those two things are the same
04:48:29 <EvanR> youre generating data, its piling up in thunks and never evaluated
04:48:31 <EvanR> or dropped
04:49:29 <EvanR> if you execute the gc manually and it doesnt go away, thats gotta be it
04:49:49 <tsahyt> merijn: what's the point in having two different terms then? a memory leak usually denotes a leak due to not freeing memory and throwing the pointer away. this is not something that can happen in haskell as far as I know, at least not without abusing the FFI
04:50:08 <tsahyt> EvanR: I'll give it a try
04:50:14 <EvanR> memory leak comes from C world, space leak comes from haskell world, we dont have memory leaks like C, so shrug
04:51:23 <merijn> tsahyt: You can't "not free" in GC'ed languages like haskell/C#/Java/etc.
04:51:39 <merijn> tsahyt: So memory leak means the only thing it can "preventing memory from being leaked"
04:52:04 <EvanR> memory leak sounds worse so maybe its a bad term for haskell
04:52:31 <ironChicken> aha, worked it out
04:52:31 <tsahyt> merijn: that's precisely my point, you can't really leak memory in the classical sense, so the term space leak just seems more applicable
04:52:38 <quchen> Memory leak sounds bad because it is bad :-þ
04:52:42 <tsahyt> at least it's less confusing
04:52:45 <tsahyt> to me anyhow
04:52:53 <merijn> tsahyt: Yeah, but people from Java/C# will be used to using memory leak terminology
04:53:02 <merijn> (And JS, I suppose?)
04:53:07 <EvanR> yeah, js
04:53:42 <tsahyt> but it denotes a different thing, so it should imo have a different name too
04:54:02 <EvanR> haskell is weird because you get this annoying space *usage* but youre not really doing anything wrong most of the time to cause it
04:54:31 <tsahyt> aggressively invoking the GC did not seem to help
04:54:35 <EvanR> some wrong, imo, would be like creating an infinite top level list and consuming it like a stream
04:54:46 <quchen> EvanR: Well, you can still leak by forking off indefinitely running threads and forgetting all references to them, for example.
04:55:22 <EvanR> quchen: i dunno! those indefinitely running threads have a reference somewhere
04:56:07 <quchen> If I cannot access that somewhere as a user, it's a leak.
04:56:22 <EvanR> isnt there a list of all threads thing
04:57:20 <merijn> EvanR: No
04:57:24 <merijn> That'd be a nightmare
04:57:29 <tsahyt> when did retainer profiling stop working?
04:57:37 <merijn> User code could arbitrarily throw async exceptions to library threads
04:58:07 <quchen> acme-towel: throw exceptions to random thrads
04:58:09 <EvanR> sounds useful
04:58:27 <EvanR> threads have to be prepared for async exceptions anyway
04:58:36 <merijn> EvanR: If you want your code to die in a blaze of concurrent inconsistency and broken invariants
04:58:43 <merijn> EvanR: Eh...why?
04:58:58 <merijn> EvanR: Writing async safe code in haskell is ridiculously hard
04:59:02 <EvanR> "ill never get an async exception, even without blocking them" doesnt sound like a common invariant
04:59:20 <EvanR> the async library does it ok
04:59:40 <merijn> EvanR: By spawning a new thread with hidden threadid so user code can't throw async exceptions to it
04:59:50 <merijn> EvanR: async's solution is exactly what you're proposing to break
05:00:02 <EvanR> if the "hidden" thread got an exception, whcih it can, the parent will know
05:00:29 <merijn> EvanR: By carefully controlling masking and when threads spawn and installing handlers yes
05:00:35 <EvanR> yep
05:00:51 <merijn> EvanR: Consider the discussion last year on the mailing list on making cleanup handler async masked
05:00:59 <EvanR> so its not relying on not getting an exception, its prepared for it
05:01:24 <merijn> EvanR: Oh? What happens if things get excepted before the handler is finished installing?
05:01:39 <EvanR> eh? you said its masked
05:02:11 <merijn> EvanR: I've tried to write async safe library code multiple times for networking it's HARD
05:02:22 <merijn> EvanR: Expecting every library to support that is insane
05:02:26 <EvanR> i do not doubt it
05:02:41 <maerwald> merijn: why do people even bother about async in haskell when we have green threads?
05:02:44 <merijn> EvanR: I don't even trust my code to be not broken and I've been doing concurrent runtime systems for ages now
05:02:45 <EvanR> but random asshole doing throwTo isnt the only source of async exceptions
05:02:54 <merijn> maerwald: I don't understand the question
05:03:05 <maerwald> ok
05:03:11 <merijn> maerwald: Rather, I think you are confusing terminology
05:03:15 <maerwald> no
05:03:25 <merijn> EvanR: There's only 2 other async exceptions that don't originate from throwTo
05:03:32 <merijn> EvanR: (Or maybe one?)
05:03:38 <merijn> EvanR: And that's "out of memory"
05:03:38 <EvanR> that dont originate from random assholes doing throwTo ?
05:04:04 <merijn> EvanR: And out of memory is rather predictably controllable
05:04:07 <merijn> EvanR: Yes
05:04:29 <EvanR> if you say so
05:04:46 <merijn> maerwald: I don't see how green threads existing has any relation whatsoever to async exceptions?
05:05:06 <merijn> EvanR: All other IO exceptions are explicitly thrown
05:05:45 <EvanR> i rather expect that when im writing a concurrent situation, that threads can die at any moment, and that if youre not doing something too complicated that its ok
05:06:11 <EvanR> but something complicated comes up a lot if youre trying to make a new primitive
05:06:17 <EvanR> so now you need to mask
05:06:25 <merijn> What sort of concurrent stuff do you usually write?
05:06:32 <EvanR> servers?
05:06:36 <merijn> EvanR: Note that mask doesn't fully stop async exceptions
05:06:51 <merijn> EvanR: Yeah, but are threads actually communicating or just trivially handling one connection?
05:07:13 <EvanR> the answer to your question is handled by the premise
05:07:34 <EvanR> its either something not too complicated or it isnt
05:08:00 <EvanR> just checking, what isnt stopped by mask?
05:08:14 <merijn> EvanR: Mask is lifted on any blocking operation
05:08:21 <EvanR> right yeah
05:08:26 <merijn> EvanR: i.e. reading from/writing to any MVar, etc.
05:08:26 <EvanR> understood, good
05:08:37 <EvanR> that behavior is good
05:08:46 <merijn> EvanR: So if you need to do initialisation where you're not sure MVar's are used you're fucked
05:08:54 <EvanR> and im factoring that into what youre supposed to know when dealing with this
05:09:46 <EvanR> sounds like theres some sorts of primitives involving arbitrary IO as an argument that you just cant do then
05:09:57 <EvanR> which sort of sounds right anyway
05:10:25 <EvanR> haskell didnt solve many of the insane concurrency questions C didnt
05:10:43 <merijn> EvanR: So you're saying "everything should be able to handle async", I say "that's impossibly hard, because you can't do X", and your solution is "well, never write code that needs to do X then"?
05:11:02 <merijn> Whereas the simpler solution would be "just stop random assholes from throwing exceptions"
05:11:14 <merijn> Now you can just write whatever you want
05:11:21 <EvanR> well, everything should handle the impossible-to-handle. yeah thats got a lot going against it
05:11:23 <merijn> Explain to me how your approach is prefeable
05:11:45 <merijn> If I want random assholes to throw async exceptions anyway I can simply expose my ThreadIds
05:12:12 <quchen> I think we should just conclude that there's no `getAllThreads :: IO [ThreadId]` before there's blood in here.
05:12:33 <merijn> quchen: I was just arguing for that never changing
05:12:46 <EvanR> im convinced that there are impossible to write concurrency primitives with the technology we have
05:12:54 <merijn> EvanR: Sure
05:13:05 <EvanR> so i dunno what else there is to live for
05:13:06 <merijn> EvanR: I started working on a saner Haskell inspired language
05:13:08 <quchen> The discussion is has become pretty hostile regardless of the topic :-(
05:13:29 <merijn> EvanR: One with actual first class concurrency, but it's sort of on indefinite hold
05:13:31 <codedmart> How would you zipWith n amount of arrays? Example 5 arrays? If I have a list of lists `[[1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7], [5,6,7,8]]` and I want to end up with one list `[15, 20, 25, 30]`
05:13:44 <quchen> codedmart: ZipList
05:13:52 <quchen> It has a zipping Applicative instance
05:14:15 <EvanR> well id be interested in the paper on that, akin to concurrent haskell
05:14:15 <ziman> you could also transpose the list of lists and map fold
05:14:45 <merijn> EvanR: Basically, the notion of threads not being followed in the type system needs to go
05:15:00 <codedmart> ziman: Do you have an example?
05:15:09 <codedmart> quchen: I will look into that thanks!
05:15:18 <merijn> EvanR: My current idea is that you want a hierarchy (similar to processes) and the ability to share things with children/siblings and have access to things from your ancestors (type safely)
05:15:45 <ziman> > map sum . transpose $ [[1,2,3],[4,5,6]]
05:15:47 <lambdabot>  [5,7,9]
05:16:00 <merijn> EvanR: For example, you wanna do pass-by-reference with siblings, but "pass-by-value" with unrelated parts of the hierarchy (like erlang) so you can decouple GC for different parts
05:16:04 <mniip> :t foldr (zipWith (+)) (repeat 0)
05:16:08 <lambdabot> (Num b, Foldable t) => t [b] -> [b]
05:16:15 <EvanR> that sounds like it could work, though it stops some shapes of concurrency usage
05:16:15 <merijn> EvanR: And have typed channels that only allow pass-by-value when crossing boundaries, etc.
05:16:36 <mniip> codedmart, ^
05:16:38 <merijn> EvanR: You'd need some FRP-like type system to deal with events/async exceptions
05:16:44 <ziman> > map sum . transpose $ [[1,2,3,4], [2,3,4,5], [3,4,5,6], [4,5,6,7], [5,6,7,8]]
05:16:46 <lambdabot>  [15,20,25,30]
05:16:56 <merijn> EvanR: What sorta thing are you thinking off that it'd stop?
05:17:16 <merijn> EvanR: It's not fully CSP, but then I think CSP/pi-calculus is a bad base to start from
05:17:34 <merijn> EvanR: It's hard to program and you want some single point of control as a programmer to keep things tractable
05:18:52 <EvanR> can everything at the same level in the tree communicate with each other?
05:19:08 <merijn> EvanR: I think you'd want to be able to restrict that at the parent level
05:19:10 <codedmart> Thanks guys!
05:19:22 <EvanR> at least can you set it up that way
05:19:27 <merijn> EvanR: i.e. parents can restrict/specify the communication of their children
05:19:50 <merijn> EvanR: Yes, but things in separate branches need to go up to a common ancestor to arrange that
05:19:51 <EvanR> ok, as long as it supports "classic crap concurrency" as a specal case
05:20:29 <merijn> EvanR: Basically a parent controls all access below it, so two unrelated nodes in the tree can run GC separate from eachother
05:20:35 <EvanR> then its expanding in power rather than restricting
05:20:44 <merijn> EvanR: So global (root) GC would only need to manage a tiny amount of globally shared info
05:21:36 <merijn> EvanR: Classic crap concurrency would simply be a tree of depth 1 with everything running as child of the root
05:21:43 <EvanR> right 
05:21:45 <merijn> EvanR: So everything is managed globally
05:22:34 <merijn> EvanR: But you'd want to have like one child for library Foo's threads and one child for library Bar's threads and any communication between threads from those two would have to go through their parent to the global root for synchronisation
05:22:52 <merijn> EvanR: By not allowing references to go from Foo to Bar it means the GC of both could run independently
05:24:47 <EvanR> that can be good or bad for performance depending
05:24:58 <merijn> EvanR: Sure
05:25:16 <EvanR> erlang and haskell made two extreme decisions on that
05:25:16 <merijn> But Erlang does everything pass-by-value without too much effort
05:26:00 <merijn> EvanR: Basically if you wanted to pass-by-reference from Foo to Bar you'd have to alloc in Global instead of in Foo (means slower, but pass-by-reference)
05:26:03 <dysfun> erlang solutions that aren't just passing out to C also tend to be slower
05:26:12 <merijn> EvanR: Otherwise you could allocate local to Foo which'd be faster
05:26:17 <EvanR> whats the point of being slower and pass by ref
05:27:15 <dysfun> i'd like to see something based on regions for GC
05:27:30 <merijn> EvanR: Passing becomes cheaper
05:27:44 <EvanR> ... ok so ... not slower
05:27:46 <merijn> EvanR: i.e. if you allocate a large vector that's modified via IO that you wanna share
05:27:55 <merijn> EvanR: allocation would be slower
05:27:59 <merijn> EvanR: Sharing would be cheaper
05:28:10 <merijn> or faster, because pass-by-reference
05:28:24 <merijn> But allocating in global bracket means more synchronisation
05:29:11 <EvanR> simpson also has his own concurrency model for monte
05:29:48 <EvanR> but i think hes got it easier by trying to optimize for "obviously rightness" than performance
05:30:36 <merijn> Sadly no one is paying me to implement/develop this stuff >.>
05:40:16 <lione_1> http://espedito.homepc.it/
05:48:51 <minib00m> guys, i'm thinking about server that accepts only two connections and allows those two connections to send messages to each other via server
05:49:24 <minib00m> but whenever new connection comes it should be placed in "wait for it" queue
05:50:13 <minib00m> so when those two reserved places are freed then i should update state that some space has freed
05:50:39 <mniip> "A helpful analogy to understand the value of static typing is to look at it as putting pieces into a jigsaw puzzle. In Haskell, if a piece has the wrong shape, it simply won't fit. In a dynamically typed language, all the pieces are 1x1 squares and always fit, so you have to constantly examine the resulting picture and check (through testing) whether it's correct."
05:50:43 <mniip> haha
05:51:18 <EvanR> all pieces being 1x1 square is very charible
05:51:40 <minib00m> but problem i'm having is that when one of the paired connection has disconnected
05:51:44 <minib00m> then second one should be too
05:51:47 <EvanR> they are all 0x0 points on top of each other
05:53:09 <EvanR> minib00m: depending on your strict requirements for this protocol, it could be a much simpler implementation to get it to work
05:53:29 <EvanR> you might not need any extra state to update, beyond the threads themselves
05:54:39 <minib00m> evanR: is it elegant to keep threadIds and whenever one thread terminates then send "killThread" to both of those ids? It doesn't seem the best soltuion
05:56:54 <EvanR> minib00m: nope.
05:57:08 <EvanR> look at the async library, it features a cancel operation
05:57:47 <EvanR> you can easily wait for two connections, then wait for one of them to end, then cancel the other
06:00:26 <isochronia> Hi, can I ask, if I write an instance for something as a monad, is there a way to automatically derive instances for functor and applicative, too?
06:01:21 <reqq456> can someone ELI5 what is the difference between map and fmap? I get that map is a special case of fmap, but didn't get what is so special about fmap?
06:01:38 <merijn> reqq456: Who ways there's anything special about fmap?
06:01:53 <EvanR> isochronia: you can automatically derive Functor, DeriveFunctor extension
06:02:17 <EvanR> but you have to write the Applicative instance, which is boilerplate: pure = return, (<*>) = ap
06:02:25 <merijn> EvanR: To be fair, if his custom Monad uses whatever tricks for efficiency he may want to implement it anyway
06:02:34 <reqq456> i really don't know merijn, map :: (a -> b) -> [a] -> [b], but fmap :: (a -> b) -> f a -> f b
06:02:55 <reqq456> for f a / f b i have to insert concrete types afaik
06:03:00 <isochronia> Yes, I see. Okay. How do you write fmap in terms of pure monad functions, like you can for applicative?
06:03:07 <merijn> isochronia: liftM
06:03:09 <merijn> :t liftM
06:03:09 <lyxia> fmap :: Functor f => (a -> b) -> f a -> f b
06:03:10 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:03:29 <EvanR> @src liftM
06:03:29 <lambdabot> liftM f m1 = do
06:03:30 <lambdabot>     x1 <- m1
06:03:30 <lambdabot>     return (f x1)
06:03:36 <merijn> reqq456: That mean's it works for any type 'f' that's an instance of Functor
06:03:48 <merijn> :t fmap even `asAppliedTo` Nothing
06:03:48 <lyxia> reqq456: fmap is an overloaded function and its implementation for lists is map.
06:03:49 <lambdabot> Integral a => Maybe a -> Maybe Bool
06:04:15 <EvanR> isochronia: if you want to write out the Functor instance, fmap = liftM
06:04:18 <merijn> isochronia: Or "liftA2"
06:04:21 <merijn> :t liftA2
06:04:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:04:27 <merijn> eh
06:04:31 <merijn> liftA maybe?
06:04:33 <merijn> :t liftA
06:04:34 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:04:45 <EvanR> really.. liftA
06:04:53 <EvanR> how many of these do we need!
06:04:57 <merijn> EvanR: Millions!
06:07:13 <minib00m> EvanR: thanks, this async cancel looks cool :) 
06:08:14 <isochronia> EvanR, merijn, thank you.
06:10:50 <Morgawr> Is there a way to pervent haskell from optimizing out a "no-op" let statement that exists only for the purpose of being debug traced and printed? I need to investigate a value that I am generating but I am not using the value anywhere else in my code (yet) and Haskell seems to optimize it away
06:11:01 <Morgawr> I am using 'trace' to debug print it  but nothing happens.
06:11:14 <EvanR> let !x = trace something
06:12:11 <EvanR> but it might be easier to make a wrapper that trace prints the argument and returns it, and stick that in the line of fire
06:12:17 <Morgawr> It asks me to add a compile flag... that sounds extermely bothersome (I'd have to go change my makefile and everything and recompile everything which takes a while). Is there a way to do it without introducing an extra global compile-time flag?
06:12:58 <lyxia> how are you using trace
06:13:00 <Morgawr> I have a function called debug x = trace (show x) x
06:13:07 <Morgawr> so I have a bunch of stuff like
06:13:27 <Morgawr> let _myvalue = debug . f3 . f2 . f1 $ someValue
06:13:34 <EvanR> you just need to make sure the traced expression is evaluated, using seq or $! or bang patterns or strict fields or... 
06:13:47 <Morgawr> but nothing is printed out because (I assume) _myvalue is never used anywhere else
06:13:47 <lyxia> BTW this already exists as traceShowId
06:14:08 <EvanR> Morgawr: let !_myvalue = ...
06:14:47 <lyxia> indeed you should apply trace to parts of your program that will be used.
06:14:48 <Morgawr> EvanR: And then it asks for the extra flag, as I said. Is my only option to recompile my entire codebase and change the makefile?
06:14:55 <EvanR> oh
06:14:58 <EvanR> at the top of the file
06:15:06 <EvanR> {-# LANGUAGE BangPatterns #-}
06:15:18 <EvanR> or what lyxia said
06:15:55 <Morgawr> Yeah I can't apply it to a part that will be used because the rest of the program is not implemented yet (it's a big change) so I just want to make sure I am getting the proper results for the moment.
06:16:02 <Morgawr> I'll try with the BangPatterns statement at the top, thanks.
06:17:53 <EvanR> its not really optimizing that out, necessarily, its just that haskell is lazy, debug trace only does impure magic when expressions are evaluated, and expressions are only evaluated on demand
06:18:29 <EvanR> and even then only to the extent necessary, i.e. weak head normal form
06:26:01 <tippenein> any recommendations how to do persistent migrations?
06:28:32 <EvanR> http://www.yesodweb.com/book/persistent#persistent_migrations
06:30:10 <tippenein> yes, I've read that. printMigration seems to be my only option..
06:31:10 <EvanR> runMigration?
06:32:08 <tippenein> runMigration doesn't know how to deal with the change
06:42:36 <mniip> type families are dependently kinded in modern haskell, right?
06:43:01 <c_wraith> not really.
06:43:20 <c_wraith> You still need singletons to get types that depend on values.
06:43:22 <itnex> what is a type family?
06:43:25 <itnex> what is dependently kinded?
06:43:30 <itnex> what is modern haskell?
06:43:34 <c_wraith> oh, wait.  dependently *kinded*.  yes.
06:43:42 <c_wraith> TypeInType gives dependent kinds.
06:44:08 <itnex> c_wraith
06:44:11 <itnex> could you please explain to me
06:44:21 <itnex> what dependently kinded means?
06:44:31 <itnex> also what type families are
06:44:36 <itnex> also why these two things are relevant
06:44:44 <c_wraith> Type families are essentially functions from types to types.
06:45:39 <c_wraith> dependently-kinded would mean that the kind of a type family is allowed to depend on the types of its arguments.
06:45:54 <mniip> c_wraith, I'm nowhere near values right now
06:45:55 <c_wraith> err.  Allowed to depend on the *kind* of its arguments, I suppose.
06:46:34 <itnex> ty
06:47:52 <mniip> oh, apparently
06:48:08 <mniip> you can bind kind variables in type families now?
06:48:19 <c_wraith> Yeah, that would be necessary.
06:48:54 <c_wraith> I think the whole point of TypeInType is flattening the hierarchy so that you can treat kinds and types as the same thing.
06:49:04 <mniip> I was worried about being unable to write KindOf :: (a :: k) -> Type
06:50:27 <mniip> or rather
06:50:31 <mniip> KindOf :: k -> Type
06:51:07 <EvanR> the kind of a kind
06:51:12 <EvanR> wtf
06:51:39 <EvanR> is that the type of a sort
06:51:41 <merijn> That's what TypeInType did
06:51:50 <merijn> EvanR: Not quite
06:52:02 <merijn> EvanR: There's two ways to tackle the consistency problem with higher kinded types
06:52:44 <merijn> EvanR: 1) stratify kinds so that the "kind of a kind" is on a higher level, resulting in an infinite hierarchy of kinds (this is what Calculus of Constructions and thus Coq&Agda (and Idris?) do
06:52:48 <merijn> )
06:53:13 <merijn> 2) say "fuck-it" and collapse everything to the same level and throw consistency out the window
06:53:27 <mniip> well not really "out of the window"
06:53:36 <merijn> If you're already Turing complete on the type level it doesn't matter anyway
06:53:38 <EvanR> (Idris?) indeed
06:53:40 <mniip> it doesn't introduce any more logical inconsistencies than, say, undefined
06:54:11 <merijn> mniip: Right, but then undefined ALSO throws all consistency out the window :p
06:54:24 <EvanR> there is an explanation on trac why TypeInType is not inconsistent by itself
06:54:31 <mniip> so there's nothing to throw out the window then :p
06:54:38 <EvanR> it doesnt involve undefined, which isnt a type afaik
06:55:45 <jstimpfle> hi - I have an Monad+Applicative instance where NOT ap = (<*>). The Applicative can "fail in parallel" and collect failures, while the Monad fails sequentially, and returns only the first error. I am inconclusive if this should be invalid since AMP. What would you say? https://gist.github.com/jstimpfle/a08b0f62e4c5583e88be260be10b0939
06:56:15 <mniip> jstimpfle, that's an unlawful monad/applicative
06:56:21 <mniip> as ap=<*> follows from the laws
06:56:44 <merijn> mniip: Not true
06:56:58 <merijn> mniip: Counter example: list monad and ziplist applicative
06:57:16 <mniip> ah yes
06:57:17 <merijn> mniip: Applicatives are not unique, therefore not all lawful applicatives correspond to lawful monads
06:57:19 <mniip> only if return=pure
06:57:36 <mniip> but in this case that is so
06:57:38 <merijn> But for sanity reasons types with lawful monads SHOULD have the same applicative
06:59:21 <EvanR> * : □, □ : △
06:59:56 <mniip> △ : _
07:00:09 <mniip> should've gone the other way
07:00:18 <EvanR> : : _
07:00:29 <jstimpfle> mniip, why return=pure => (<*>)=ap ?
07:01:54 <mniip> hmmm
07:03:03 <jstimpfle> personally I think it would be nice if (f <$> a <*> a')=(flip f <$> a' <*> a) was allowable, but that would break (<*>)=ap
07:03:17 <mniip> yeah both of these instances are valid
07:03:48 <mniip> in fact, ap = <*> if we fix e to the 'First' monoid
07:04:05 <mniip> so they agree in a sense
07:04:45 <mniip> (actually a semigroup, since identity is not used anywhere and makes little sense here)
07:05:15 <jstimpfle> mniip, true - lists are just easier on the eye to use :-)
07:06:36 <minib00m> guys i'm a little confued by async 
07:06:38 <minib00m> http://lpaste.net/168307
07:07:04 <minib00m> this is simple - wait for two connections and then greet them with their number
07:07:17 <jstimpfle> mniip, do you mean ap=<*> *for my ParFallible example* for the First Monoid? Because that's not true
07:07:37 <minib00m> in fact, first telnet that connects displays "Hello there! connection number 2"
07:07:45 <minib00m> instead of 1
07:07:55 <mniip> jstimpfle, why not
07:07:57 <minib00m> why in hell is that reversed? :D
07:08:16 <jstimpfle> mniip, sorry, taking it back, have to think through it
07:08:53 <glguy> Minib00m, you don't know which thread is going to execute first
07:09:08 <glguy> Both are running, 2 happened to go first
07:09:50 <minib00m> glguy: oh... you seem to be right
07:10:19 <minib00m> glguy: i was confused cause i got multiple reversed orders in a row... :D
07:10:32 <minib00m> but thanks, it's clear now :)
07:10:33 <EvanR> minib00m: dont wait for two connects at the same time
07:10:40 <EvanR> do one then the other
07:11:06 <EvanR> c1 <- accept
07:11:09 <EvanR> c2 <- accept
07:11:18 <EvanR> rock on
07:11:45 <EvanR> javascript eat your heart out
07:13:04 <minib00m> not only heart... :P
07:13:07 <minib00m> thanks
07:15:06 <tsahyt> how can I inspect derived instances?
07:19:03 <tsahyt> ok nvm, everything's just done via coerce
07:19:52 <tsahyt> so how can it be that (>>) leaks space? The concrete monad I'm using is defined as newtype Driver a = Driver { unDriver :: RWST Comms Log DriverState IOChan a }
07:19:58 <mniip> hmm
07:20:11 <mniip> the fix in GHC HEAD finally lets me write some interesting stuff
07:20:21 <tsahyt> where Comms is a small data structure holding two Chans, Log is just Text, and IOChan is a newtype around IO restricting actions to readChan and writeChan
07:20:35 <lpaste> mniip pasted “forceType” at http://lpaste.net/168311
07:21:18 <coppro> tsahyt: a >> b is implemented as a >>= \_ -> b
07:21:27 <EvanR> tsahyt: whats Log
07:21:38 <coppro> it's possible you're never forcing a, so you leak thunks
07:21:39 <tsahyt> EvanR: type Log = Text
07:22:01 <EvanR> try looking at the empty text result of the runRWST
07:22:08 <EvanR> evaluate it, or whatever
07:22:25 <coppro> oh yeah that would do it too
07:22:40 <coppro> if youre writer thunks are building up
07:22:44 <coppro> *your
07:22:59 <tsahyt> EvanR: well I am printing it eventually
07:23:17 <EvanR> oh really... nvm then
07:23:26 <tsahyt> I could probably just get it rid of it altogether though
07:23:50 <EvanR> even if you dont tell, it has to <> each thing
07:23:52 <tsahyt> Writer isn't well suited for logging to begin with since I need to wait for execution to finish until I get anything out of it
07:24:15 <coppro> indeed
07:24:50 <EvanR> RWST over IO kind of is overkill
07:25:03 <tsahyt> restricted IO technically
07:25:06 <EvanR> but that shouldnt mean its broken
07:25:16 <jstimpfle> mniip, I think because (return f `ap` Fail e `ap` Fail e')=(f <$> Fail e <*> Fail e')=(flip f <$> Fail e' <*> Fail e)=(return (flip f) `ap` Fail e' `ap` Fail e) is a contradiction
07:25:34 <tsahyt> EvanR: In what way is it overkill?
07:26:00 <EvanR> IO provides mechanisms to do all of the above, except possibly ReaderT
07:26:02 <mniip> jstimpfle, f <$> x <*> y = flip f <$> y <*> x is not a law
07:26:10 <EvanR> and more, like exceptions
07:26:15 <mniip> > (,) <$> [1, 2] <*> [3, 4]
07:26:17 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
07:26:24 <mniip> > flip (,) <$> [3, 4] <*> [1, 2]
07:26:26 <lambdabot>  [(1,3),(2,3),(1,4),(2,4)]
07:26:44 <EvanR> and is simpler than RWST over IO
07:26:46 <jstimpfle> but it holds for my instance
07:28:02 <tsahyt> Nice, changing Log to () really did fix it
07:28:19 <EvanR> huh...
07:28:36 <EvanR> () <> () is still a thunk though
07:28:48 <EvanR> not nearly as large probably
07:29:06 <tsahyt> I'll get rid of RWST altogether I suppose
07:29:19 <tsahyt> in favour of reader and state
07:29:25 <EvanR> watch out for Writer-like monads
07:29:36 <EvanR> i think you can implement them to not leak, but not sure
07:29:37 <tsahyt> but using plain IO for everything just seems wrong imo
07:29:41 <cheater> EvanR: did you expect () <> () to be something else?
07:30:16 <tsahyt> do ReaderT and StateT commute?
07:30:29 <EvanR> i wouldnt expect () vs Text to strictyl evaluate, so im going to chalk it up to sheer size of empty texts
07:30:34 <hk238> what does the <> do? Sorry I'm beginner. ^^
07:30:43 <EvanR> :t (<>)
07:30:44 <lambdabot> Monoid m => m -> m -> m
07:30:47 <EvanR> > () <> ()
07:30:49 <lambdabot>  ()
07:30:52 <tsahyt> hk238: monoid operation of whatever monoid you're working with. For Text it's concatenation
07:30:53 <EvanR> for (), not much
07:31:01 <EvanR> > "abc" <> "123"
07:31:03 <lambdabot>  "abc123"
07:31:12 <tsahyt> > [1,2,3] <> [4,5,6]
07:31:13 <lambdabot>  [1,2,3,4,5,6]
07:31:20 <tsahyt> for lists it's list concatenation, etc.
07:31:25 <tsahyt> > Sum 10 <> Sum 20
07:31:27 <lambdabot>  Sum {getSum = 30}
07:31:38 <hk238> hmm interesting, and thanks for explaining too 
07:31:56 <EvanR> also know the other Monoid operation, mempty
07:31:58 <EvanR> :t mempty
07:32:00 <lambdabot> Monoid a => a
07:32:05 <EvanR> mempty :: String
07:32:09 <EvanR> > mempty :: String
07:32:11 <lambdabot>  ""
07:32:30 <EvanR> mempty <> x = x <> mempty = x
07:32:33 <tsahyt> that's the important one anyhow, otherwise it's just a semigroup
07:34:24 <hk238> hmm
07:34:38 <Ashy> where can i read more about :~>  (as seen here: https://github.com/parsonsmatt/servant-persistent/blob/master/src/Api.hs#L34-L40 )
07:34:41 <Ashy> ?
07:35:28 <EvanR> hk238: the relevance here is that Writer is parameterized over any Monoid, the choice of monoid is the choice of the output log
07:35:34 <mniip> is it possible to pattern match on a type family application?
07:35:45 <EvanR> :t tell
07:35:45 <mniip> in type families?
07:35:45 <tsahyt> Is there any difference between wrapping ReaderT around StateT and the other way round?
07:35:46 <lambdabot> MonadWriter w m => w -> m ()
07:35:55 <EvanR> hrm
07:36:03 <hk238> Just hoping to learn each bit of terminology that goes by :D
07:36:41 <Welkin> there is far too much to learn
07:36:48 <EvanR> yeah just give up now
07:36:52 <EvanR> NOT
07:37:12 <Welkin> you don't need to know very much to write useful haskell though
07:37:28 <hk238> it's interesting though 
07:37:30 <EvanR> tsahyt: not practically i dont think... but you can always do weird things with local and state
07:37:36 <c_wraith> tsahyt: those two commute with each other.
07:37:41 <hexagoxel> Ashy: it is defined at http://hackage.haskell.org/package/servant-server-0.7.1/docs/Servant-Server.html#t::-126--62-
07:37:42 <maerwald> Welkin: but it's considered cool, so people stuff their APIs full of things and enable as many GHC extensions as possible
07:37:58 <hk238> and I just recently have started learning some math too so that makes haskell even more interesting, unfortunately I dont have a sufficient background, but it's still fun to think about, if you happen to run into something you can learn anyway
07:38:00 <tsahyt> good. I just hope there's no weird performance side effect of one over the other again
07:38:38 <c_wraith> @unmtl ReaderT r (StateT s) m a
07:38:38 <lambdabot> Plugin `unmtl' failed with: `StateT s m' is not applied to enough arguments, giving `/\A. s -> m (A, s)'
07:38:50 <c_wraith> @unmtl ReaderT r (StateT s m) a
07:38:51 <lambdabot> r -> s -> m (a, s)
07:38:55 <hexagoxel> Ashy: note that you can find it via hoogle, http://hayoo.fh-wedel.de/?query=%28%3A~%3E%29
07:39:08 <c_wraith> @unmtl StateT s (ReaderT r m) a
07:39:08 <lambdabot> s -> r -> m (a, s)
07:39:09 <maerwald> in haskell, you also code for your ego... always remember that
07:39:17 <hk238> so to clarify the `<>`monoid operation means an operation that preserves three properties, namely associativity and identity and closure, where as a semigroup would be lacking the identity element?
07:39:20 <cheater> hexagoxel: "hoogle it on hayoo"?
07:39:27 <c_wraith> tsahyt: as you can see, the only thing that changes in the underlying representation is the order of the arguments.
07:39:27 <Welkin> maerwald: I am still confused by a lot of the extensions I see some people use
07:39:34 <hexagoxel> eh.. yeah :D
07:39:55 <EvanR> hk238: its the same sort of operation either way, but monoids have an identity element
07:39:59 <hexagoxel> s/hoogle/hayoo/, thanks
07:40:02 <maerwald> Welkin: I think have of them should simply be removed from GHC, the rest that is useful should be incorporated into the language.
07:40:04 <tsahyt> c_wraith: oh nice. thanks! I didn't know about @unmtl
07:40:06 <jstimpfle> mniip, finally caught my mistake, thanks
07:40:28 <EvanR> hk238: oh, i see you included identity as a <> law, thats weird
07:40:31 <hk238> in other words if you have "a" <> "b" <> "c" , it doesnt matter what precedence you choose, as in a(bc) is the same (ab)c under the operation? :d
07:40:44 <hk238> I just browsed through wikipedia after what you said
07:40:45 <tsahyt> finally! Getting rid of the writer altogether fixed it completely
07:40:48 <Ashy> hexagoxel: thanks, it's not making much sense but that's a step forward...
07:40:50 <nitrix> What is the flag that was added to see the full type signatures with levity?
07:40:59 <hk238> and the difference betwee na monoid and semigroup is apparently the identity
07:41:02 <hk238> ^^
07:41:07 <mizu_no_oto_work> hk238: Every monoid is also a semigroup
07:41:16 <mizu_no_oto_work> but there are some semigroups that aren't monoidal
07:41:33 <mizu_no_oto_work> similarly, every group is also a monoid
07:41:34 <hk238> would that be those that are missing an identity element?
07:41:48 <mizu_no_oto_work> hk238: yes
07:41:57 <hk238> like the empty string?
07:42:07 <mizu_no_oto_work> A group is basically a monoid where every element has an inverse
07:42:36 <mizu_no_oto_work> For example, (Z, +, 0) is a group, because x + -x = 0
07:42:48 <hk238> oh yeah ^^
07:42:51 <mizu_no_oto_work> (Z meaning the set of the integers)
07:42:53 <tdammers> nonempty lists are a semigroup under concatenation, but not a monoid
07:43:05 <hk238> so each element i nthe integers has an inverse, meaning if you use the same operation to take the inverse element, you can verse the operation
07:43:06 <tdammers> positive (nonzero) integers under addition
07:43:19 <hk238> *reverse
07:43:25 <mizu_no_oto_work> But ([a], ++, []) is a monoid but not a group
07:43:27 * hackagebot distribution-nixpkgs 1.0.0.1 - Types and functions to manipulate the Nixpkgs distribution.  https://hackage.haskell.org/package/distribution-nixpkgs-1.0.0.1 (PeterSimons)
07:43:29 <c_wraith> (N,+,0) is a monoid.  (N+, +) is a semigroup.
07:43:57 <mizu_no_oto_work> Since there's nothing that you can concatenate onto [1,2,3] to get back to []; there are no anti-lists
07:44:10 <hk238> that's interesting too :d
07:44:17 * EvanR adds anti-lists
07:44:24 <EvanR> there, now lists are groups
07:44:26 <hk238> mizu_no_oto_work should there be anti-lists? ^^
07:44:33 <nitrix> Sorry to re-ask in the amount of signal: What is the flag that was added to see the full type signatures with levity?
07:44:35 <tsahyt> Perfect, it took all day but now memory usage finally scales the way it is supposed to
07:44:37 <hk238> that would be kind of cool wouldnt it :d
07:44:47 <c_wraith> a list-antilist reaction might destroy the universe.  Please don't invent antilists.
07:45:09 <EvanR> how about left-infinite lists
07:45:13 <hk238> it's too late, everyone wants antilists now ^^
07:45:39 <EvanR> ...5, 4, 3, 2, 1, 0]
07:45:45 <srhb> EvanR: D:
07:45:56 <Akii> is there something like a colist?
07:45:57 <EvanR> lol
07:45:59 <mizu_no_oto_work> hk238: At any rate, for mathematicians, groups are interesting because there's a lot more interesting things you can prove about them.  
07:46:00 <barrucadu> What would an antilist be? A natural number of values to remove from the list it's combined with? :p
07:46:18 <c_wraith> barrucadu: order would have to matter. :)
07:46:28 <mizu_no_oto_work> hk238: So they tend to focus on groups, rings, and fields.
07:46:29 <hexagoxel> i always wanted to delete stuff from my output stream.
07:46:49 <hk238> mizu_no_oto_work oh yeah I've been reading some about it, it was nice to see this example though that tsahyt gave as it was tangible and made it easy t othink what it means in concerete terms whether there is an identity, or if there is an inverse, and so on. ^^
07:47:11 <hk238> do I remember correctly that ring was something like a.. hmm group under one operation and a semigroup under a second operation? 
07:47:24 <hk238> I might remember that wrong 
07:47:25 <hk238> :D
07:47:26 <c_wraith> hk238: that sounds right.
07:47:35 <mizu_no_oto_work> hk238: For Haskellers, monoids are interesting because there's a lot of interesting types that are monoidal but not groups (like lists and sets and whatnot)
07:47:35 <c_wraith> hk238: but there are some rules about how the two interact
07:47:41 <c_wraith> hk238: like distributive laws
07:48:12 <mizu_no_oto_work> hk238: the prototypical ring is (Z, +, *)
07:48:18 <EvanR> mizu_no_oto_work: theres also a lot of groups, but we dont have standard recogniztion
07:48:37 <EvanR> and Num is sort of a bastarized ring ;)
07:48:49 <c_wraith> The thing is, as you add more structure, you get more options.  Classes with many options on how to implement them are harder to reason about.
07:48:59 <hk238> oh right.. like let's say o is operation and x is another operation, and a, b, c are elements then a x ( b o c ) and a x b o a x c ?
07:49:05 <hk238> although that looks superconfusing
07:49:22 <mizu_no_oto_work> EvanR: sure.  I think that part of it is also that inverses tend not to be quite as computationally useful as associativity and identity
07:49:40 <EvanR> really? 
07:50:01 <hk238> mizu there might be uses ^^ at least it's interesting
07:50:08 <EvanR> carmacks inverse sqrt, two inverses at once!
07:51:09 <EvanR> i would find a partial inverse to sha256 kind of useful
07:51:43 <tsahyt> lots of people would like to have an inverse to sha256 I suppose
07:51:46 <hk238> :D
07:51:56 <mniip> nitrix, it's supposed to be -fprint-explicit-runtimerep
07:52:04 <mniip> but it's not functioning over here
07:52:22 <tsahyt> ah this is beautiful, not only did this help tremendously with memory consumption, it also gave a slight speedup
07:52:44 <EvanR> memory usage directly impacts speed in haskell, thanks to the gc
07:52:55 <nitrix> mniip: I see. And to use Levity, it's the extension TypeInType?
07:53:31 <mizu_no_oto_work> EvanR: how many algorithms require associativity and identity, and how many require inverses?
07:53:37 <nitrix> I want to play with it a little. I find it fascinating that there's no kinds anymore.
07:54:32 <EvanR> no kinds will definitely help when explaining haskell
07:54:46 <EvanR> because you dont have to use the word kinds
07:54:49 <mniip> EvanR, just say the magic word: * :: *
07:54:54 <phadej> EvanR: cryptographic hash functions by their nature don't have easily computable inverses
07:55:16 <phadej> otherwise they won't be useful where they are used
07:55:26 <nitrix> EvanR: I believe the devs on GHC have mentioned they'll still keep that terminology in diagnosis messages.
07:55:33 <mizu_no_oto_work> hk238: you might find http://blog.functorial.com/posts/2015-12-06-Counterexamples.html interesting
07:55:42 <mniip> "hello" :: String, String :: TYPE Lifted, TYPE Lifted :: TYPE Lifted
07:55:47 <nitrix> I totally agree though.
07:56:45 <Akii> tail-call elimination http://cdn.iflscience.com/images/5dc7a217-f224-53c7-8a22-91e87f1825fb/extra_large-1464355421-828-stressed-out-snake-eats-itself.jpg :D
07:57:02 <EvanR> * :: *, is MyLiftedType :: * ?
07:57:16 <EvanR> or BOX or
07:57:25 <mniip> EvanR, * :: *
07:57:31 <mniip> the type of types is a type
07:57:41 <nitrix> Akii: Not very relevant, but for the information, snakes don't do this when they're stressed. They become like this when unable to regulate their body temperature.
07:57:58 <EvanR> mniip: aksing about MyLiftedType (DataKinds)
07:58:03 <Akii> nitrix: but they die :o
07:58:07 <EvanR> er, promoted type
07:58:15 <sm> poor snakes 
07:58:22 <Akii> (according to the source "internet")
07:58:50 <mniip> EvanR, what about them
07:58:58 <EvanR> Akii: do you have an article for that
07:59:14 <EvanR> mniip: what is the type of those types
07:59:43 <mniip> well, if data Ty = Con
07:59:49 <mniip> then 'Con :: Ty
07:59:58 <mniip> and Ty :: * still
07:59:59 <EvanR> Ty :: ?
08:00:02 <EvanR> ok
08:00:04 <Akii> EvanR: nope, just thought about how it bites itself; also doesn't look like it can easily just let go again.
08:00:13 <Akii> (but that's off topic :D sry)
08:01:11 <nitrix> :t forever
08:01:13 <lambdabot> Monad m => m a -> m b
08:01:23 <nitrix> Akii: Monads are now Snakes, not burritos.
08:01:39 <Akii> nitrix: I knew it, let me set up wordpress right away!
08:01:50 <Akii> SnakeT
08:02:01 <EvanR> BurritoT
08:02:08 <Akii> and now, compose!
08:02:09 <nitrix> Akii: How's the monad transformer learning going, btw?
08:02:22 <nitrix> If I may ask.
08:02:49 <Akii> nitrix: I finished the Applicative chapter but got stuck on defining an instance for Constant
08:03:06 <Akii> and it seems like I need to evaluate the Monad chapter as well
08:03:13 <Akii> and the Foldable/Traversable
08:03:20 <dolio> EvanR: I think the point of type-in-type is that BOX is completely gone.
08:03:21 <Akii> all the Thunks :D
08:03:28 * hackagebot list-tries 0.6.2 - Tries and Patricia tries: finite sets and maps for list keys  https://hackage.haskell.org/package/list-tries-0.6.2 (MattiNiemenmaa)
08:03:30 * hackagebot Glob 0.7.6 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.6 (MattiNiemenmaa)
08:04:09 <nitrix> Akii: The monad chapter most likely. Seems pretty important if you're going to do transformers. Foldable/Traversable is just a nice addition but not necessary to get transformers, afaik.
08:04:17 <EvanR> so some types :: *, and some types :: Something :: *
08:04:29 <EvanR> and thats it
08:04:31 <Akii> nitrix: just had hoped I can get away with what I already know :D
08:08:58 <mniip> well that's interestin
08:10:11 <lpaste> mniip pasted “seqT” at http://lpaste.net/168326
08:10:38 <tomjaguarpaw> Does anyone know a ballpack figure for Integer operations per second, or a benchmark I can run to deduce them for my machine?
08:13:37 <hexagoxel> after giving up on an implementation using Data.Data.Data, i just noticed that the problem is even simpler. When i try create two instances "instance Data (Foo Identity); instance Data (Foo Maybe)" there are errors already. is this not supposed to work?
08:15:18 <hexagoxel> (i.e. when deriving those instances using DeriveDataTypeable)
08:16:46 <nitrix> Is there any monad transformers that works on two monads?
08:17:06 <tsahyt> s
08:17:16 <tsahyt> tmux is acting weird :/
08:17:24 <nitrix> Sorry, rephrasing that, you can actually ahve a monad transformer stack or multiple monads, how come I can't implement a monad that combines two other monads?
08:18:06 <nitrix> I tried and it was impossible to implement. Googling about it resulted in a discussion about the free monad and how the composition of two monads isn't necessarily a monad.
08:18:14 <nitrix> Could someone guide me?
08:19:36 <Akii> nitrix: the chapter on transformers hinted that this was discussed in the chapter on monads
08:23:11 <Skami> Data.Data.Data is the best qualified name I have seen
08:24:57 <nxv> sup dog, heard you like Data
08:25:19 <nxv> at what point does this become.. Big Data?
08:25:58 <dysfun> when it doesn't fit in an excel spreadsheet?
08:25:59 * dysfun hides
08:26:12 <Athas> Is the Data.Big name taken yet?
08:26:29 <nxv> Athas: if it is, try Data.Data.Data.Big
08:26:32 <Athas> I wonder how long until "bigger data" becomes a buzzword.
08:26:53 <nxv> Such Data. Much Big
08:27:10 <Athas> Very Synergy.
08:27:21 <nxv> wow
08:27:36 <maerwald> Athas: it doesn't matter whether it's "taken"
08:27:40 <maerwald> there are package imports
08:29:07 <mniip> int-e, what ghc version is lambdabot running?
08:29:18 <mniip> regardless of the answer, why is it so old
08:29:21 <hexagoxel> hmm i guess i can add newtype wrappers for Foo Identity and Foo Maybe, then add manual instances for the two which just coerce-forward to the automatically generated newtype instances
08:29:28 <hexagoxel> uuugly
08:30:35 <monochrom> I think FlexibleInstances allows you to write "instance John (Foo Identity)" and "instance John (Foo Maybe)", no?
08:31:04 <mniip> you can get away witout that
08:31:38 <Welkin> instance Targaryen JonSnow
08:31:39 <mniip> instance JohnFoo f => John (Foo f); class JohnFoo f ...; instance JohnFoo Identity; instance JohnFoo Maybe
08:32:22 <hexagoxel> my approach does of course not work, because the newtype-instance requires the raw instance, and does not actually implement anything.
08:33:12 <nitrix> mniip: Are you allowed constraints in instances?
08:33:48 <mniip> of course
08:34:18 <Welkin> > compilerVersion
08:34:20 <lambdabot>  Version {versionBranch = [7,10], versionTags = []}
08:36:11 <hexagoxel> code for what i try, for those interested: http://lpaste.net/168332
08:39:57 <hexagoxel> (tested with ghc-7.10.3 and 8.0.1; not much difference)
08:40:59 <hexagoxel> ah, but i _could_ define the instances in distinct modules to work around the conflicting module-level declarations..
08:48:06 <monochrom> nitrix: "instance Show a => Show [a]" is an example in Prelude. Also "instance (Show a, Show b) => Show (a,b)"
09:02:38 <Skami> Welkin: When you say there is GOT spoilers everywhere
09:03:55 <monochrom> there is #haskell-offtopic for GOT spoilers
09:08:02 <ironChicken> can i create a single cabal file that specifies one target to be compiled with ghc and one target to be compiled with ghcjs?
09:15:24 <int-e> mniip: lambdabot's on ghc 7.10.2; 7.10.3 didn't seem to add anything meaningful, and ghc 8.0.1 is still not supported by mueval (though there's a patch on the corresponding ticket on github that I should try... real life keeps interfering though)
09:15:36 <mniip> I see
09:30:23 <Gurkenglas> let lines in do statements should have their indentation block begin at the let, not the following name :I
09:30:45 <Gurkenglas> Perhaps just leave out the let, = should be enough for the parser right
09:31:45 <Gurkenglas> desugar "=" to "<- return $"
09:37:35 <nmattia> hey guys, any good lib around for working with git?
09:38:00 <nmattia> I'm discovering gitlib and libgit, but I can figure out how to perform a git pull to save my life
09:38:21 <nmattia> I'm afraid I'm missing something
09:41:38 <dysfun> heh, no, it's just difficult to get started
09:42:09 <dysfun> it doesn't help that the api has changed completely since the tutorial module was written
09:51:30 <dysfun> hrm, it does seem like push isn't implemented by any of the libraries though
09:51:39 <dysfun> er pull, rathre
09:51:52 <nmattia> yes, Tutorial looks... unfinished
09:52:05 <nmattia> I guess I'll just 'checkout'
09:52:16 <nmattia> don't wanna do any discrimination
09:52:54 <Morgawr> What's the best way to map some values over a list of elements while retaining the original elements? For example I have a list of some data structure and I want to apply a series of functions to each element to calculate some kind of "weight" and then sort that list based on that weight for each element and return the original sorted list of elements.
09:53:29 <nmattia> use sort and compareOn
09:53:59 <elucidata> Is anyone here using a full stack for web architecture in Haskell in production?
09:54:04 <nmattia> compare `on` will take a function that it calls on the elements, and sorts on the result
09:54:41 <nmattia> Morgawr: I believe 'on' is in Data.Function
09:55:02 <Morgawr> nmattia: Thanks
09:55:38 <nmattia> Morgawr: complete answer here: http://stackoverflow.com/questions/2788195/haskell-sorting
09:58:40 <elucidata> Is Haskell ready for fullstack development vs. say node+react or not quite yet?
09:59:18 <nitrix> Define fullstack?
09:59:59 <dmj`> elucidata: You could probably get "fullstack web development" with reflex-dom + servant.
10:01:21 <elucidata> dmj`: how performant would that be client side?
10:01:49 <nitrix> The same? The client has no processing to do.
10:02:34 <elucidata> I'm assuming you'd have to compile to JS somewhere in that stack to get it to do anything on the client
10:02:42 <elucidata> besides basic html
10:03:29 <nmattia> dysfun: do you have some experience with libgit then?
10:03:53 <dmj`> elucidata: it depends on the code you write, there are virtual-dom bindings, and there is an Om library in haskell
10:04:02 <nmattia> dysfun: I'm performing an action that should definitely not work (checkout outside a repo) but libgit doesn't complain at all
10:04:25 <dysfun> heh, that sounds about right
10:04:31 <dmj`> elucidata: people do use reflex-dom for work, so there's probably more maturity there
10:04:41 <dysfun> yes, i've been trying to use libgit to build a github clone in haskell
10:05:13 <nmattia> dysfun: how's that going?
10:07:51 <dysfun> well i can examine branches
10:08:13 <dysfun> and the commits they are composed of
10:09:10 <nmattia> so libgit does the job, right?
10:09:13 <dmj`> elucidata: in general I'd say pretty performant
10:13:32 * hackagebot test-fixture 0.3.0.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.3.0.0 (lexi_lambda)
10:14:54 <hwkng> what's good software for keeping track of what code you wrote on a daily message
10:15:02 <hwkng> something like git log; but shows it in a calendar
10:15:10 <Jinxit> git
10:17:06 <nxv> hwkng: use git for version control of your code. use something like github/gitlab/bitbucket/whatever for nice gui
10:18:00 <nxv> or make a script that would process git log -1 output into a calendar entry and make it alias to git commit
10:18:02 <sm> hwkng: github's contribution activity (on user page) is nice
10:18:21 <nxv> or maybe even process git log output, scoped for todays date and update your calendar. alias to git push
10:18:32 * hackagebot avwx 0.1.0.0 - Parse METAR weather reports  https://hackage.haskell.org/package/avwx-0.1.0.0 (hc)
10:19:04 <nxv> sm: agreed :) much easier too 
10:20:00 * sm wonders if on a daily message means "send me a daily email digest"
10:21:45 <dysfun> nmattia: between gitlib and gitlib-libgit2, i can do this, yes
10:22:16 <dysfun> but trying to figure out how to drive it was... "fun".
10:30:02 <mikail`> Hi, I've started reading Okasaki's book. I've done the first exercise and implemented the simple suffixes function (see here http://lpaste.net/168349). However, I am not sure how to reason over the asymptotics of it. In particular the book says to show that the list generated by this function can be done in O(n) time and represented in O(n) space.
10:30:20 <mikail`> I need some pointers on how to analyse this program.
10:32:54 <elucidata> I read something about a guy using GHCJS and then running it through the Clojure compiler to gain about a 30% improvement in code size and speed but I can't find any instructions on using the Closure compiler with GHCJS
10:33:33 <josephle> mikail`: I'm not so sure about O(n) space, but let's do O(n) time analysis
10:33:43 <josephle> mikail`: do you know how to do induction?
10:33:46 <mikail`> great
10:33:52 <mikail`> yeah a little bit
10:34:16 <kadoban> elucidata: There's nothing really magic about it, I just run the all.js file through closure compiler like usual. I think you can do something more clever with the individual files, but I haven't bothered. Code size goes down more than 30% I believe, it's a huge drop.
10:35:00 <elucidata> kadoban: ok thanks. sounds easy enough
10:35:21 <josephle> mikail`: ok, so the way you defined your function makes it easy for us to reason about its time via induction :)
10:35:22 <elucidata> just makes me look forward to WebAssembly more though
10:35:43 <johnw> dysfun: if you run into problems, just ask in #gitlib btw
10:35:48 <mikail`> brill
10:36:06 <elucidata> If some enterprising genius writes a Haskell compilation module targeting WebAssembly we're going to see some serious shit
10:36:17 <dysfun> johnw: oh cool, thanks!
10:36:37 <josephle> mikail`: so your first two cases, [[]] and [a], can you prove that suffixes runs in O(n) time for them?
10:37:20 <mikail`> for the [[]] this will run in constant time
10:37:30 <josephle> yep
10:37:52 <mikail`> for the [a] this will run in constant time i guess as well
10:38:03 <lwerdna> any link or resource explaining what happens behind the scenes of "infinite list tricks" like numbers1 = 1 : map (+1) numbers1 ? yes many sites explain that it's recursive and yadda yadda, but is there like a sequence diagram of what happens when I first declare this, when I access numbers!!2, or when I access numbers!!1000 ?
10:38:05 <mikail`> there will be a one step recursion here
10:38:39 <josephle> mikail`: actually your second case is extraneous because the third case, the induction step, actually covers it :)
10:38:50 <josephle> but it is constant time
10:39:06 <mikail`> oh right 
10:39:10 <josephle> so for the 3rd case (a:as)
10:39:28 <josephle> if your list is size N
10:39:37 <mikail`> this will take time proprotional to the length of the list
10:39:37 <mikail`> i guess
10:39:42 <josephle> yep :)
10:40:10 <mikail`> so it does have O(n) time
10:40:13 <mikail`> great
10:40:35 <mikail`> thanks for that - I wasn't sure how to go thinking about it
10:43:06 <mnoonan> lwerdna: I don't think it supports infinite lists, but lambda bubble pop might be useful to you
10:43:33 * hackagebot avwx 0.1.0.1 - Parse METAR weather reports  https://hackage.haskell.org/package/avwx-0.1.0.1 (hc)
10:44:08 <srhb> mnoonan: Why wouldn't it?
10:47:49 <mnoonan> srhb: maybe it does! but it doesn't seem happy with [m..n] syntax, and I didn't dig deeper
10:48:01 <srhb> mnoonan: Ah. :)
10:51:17 <dmwit> mnoonan: Perhaps it's just a syntax thing -- maybe `enumFromTo m n` would work better.
11:03:29 <yamadapc> On "Optimising Garbage Collection Overhead in Sigma", Simon Marlow says "there're load-balancing tricks that could be used to avoid sending requests to machines about to GC". Does anyone have an example or idea of that?
11:04:25 <cheater> yamadapc: you can invoke GC yourself. that means you know when it'll happen. Take the machine out of the balancer right before GC and put it back in right after.
11:05:13 <yamadapc> I was looking at that now... http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Stats.html#v:getGCStats and http://hackage.haskell.org/package/base-4.9.0.0/docs/System-Mem.html#v:performGC
11:05:47 <yamadapc> Can you know when the collection finishes through stats? Is there precedent? Could it be in a library? (sorry, I'm just wondering about this)
11:06:15 <yamadapc> Well, I guess you can know when the GC happens
11:06:46 <yamadapc> I'd be interesting to have this in a module
11:06:52 <yamadapc> *It would be
11:08:06 <dysfun> the .net framework implements a "going to gc soon" hook
11:08:28 <dmwit> yamadapc: I suspect Simon Marlow's suggestion involves changes to the RTS.
11:08:46 <dmwit> yamadapc: He understands the RTS so well that changing it doesn't seem like a big project to him. =P
11:09:22 <yamadapc> dmwit: I'm not sure if on this case that's what he means, because it's on a bullet mark being opposed to "custom GC strategies"
11:09:41 <yamadapc> I think the manual GC trigger is more likely what you should be able to do
11:09:50 <yamadapc> I mean, something that could work well
11:10:13 <yamadapc> A hook would be nice too
11:12:16 <yamadapc> Has anyone implemented this?
11:12:28 <yamadapc> For GHC or other platforms?
11:12:53 <dmwit> Possibly, but I don't believe anybody has released an implementation of it.
11:14:11 <m1dnight_> https://www.refheap.com/120885
11:14:22 <m1dnight_> Could it be that, a function that is supposed to throw an error gets ignored or something in a foldr?
11:14:43 <m1dnight_> The last command should throw an error that the key is not found..
11:16:04 <c_wraith> m1dnight_, nah. laziness. error returns a value. 
11:16:29 <c_wraith> m1dnight_, extractSet ignores that value, so it doesn't blow up. 
11:17:08 <c_wraith> m1dnight_, specifically, the call to snd discards the error value without ever evaluating it. 
11:17:27 <yamadapc> seems there's a paper "Load Balancing of Java Applications by Forecasting Garbage Collections"
11:17:30 <luite> yamadapc: does it mention anything about minor vs major gc?
11:17:38 <m1dnight_> Oh, that kind of makes sense
11:17:42 <m1dnight_> foldl' it is
11:17:48 <m1dnight_> thnx c_wraith 
11:17:58 <c_wraith> m1dnight_, that actually won't change anything. 
11:18:02 <dmwit> m1dnight_: `foldl'` won't change anything
11:18:09 <m1dnight_> Isn't that strict?
11:18:18 <dmwit> m1dnight_: The error is already gone by the time the strictness appears.
11:18:26 <c_wraith> it'll force the (,) constructor 
11:18:33 <dmwit> it won't
11:18:35 <dmwit> snd does that
11:18:36 <c_wraith> well, no, it won't even do that. 
11:18:45 <dmwit> it'll force the constructor resulting from `filter`.
11:19:23 <dmwit> m1dnight_: If you want `extract` to be strict, make it strict!
11:20:06 <yamadapc> luite: Sounds like it's a different idea than cheater's "force a manual GC"; but they mention avoiding pauses from major GC passes. Just found it, I've to read it
11:20:55 <luite> yamadapc: oh i meant Simon's thing with GHC
11:20:56 <dmwit> m1dnight_: ...but why do you want `extract` to be strict?
11:22:25 <m1dnight_> I want it to fail when I try to extract one set from another.
11:22:30 <dfeuer> Hi people.
11:22:36 <m1dnight_> I know I can do it in a nicer way, but I want to keep the code compact.
11:23:21 <m1dnight_> extractset [x,y,z] [x,a,z] should fail.
11:23:24 <dysfun> yamadapc: got a url?
11:23:46 <yamadapc> Sigma's article is https://simonmar.github.io/posts/2015-07-28-optimising-garbage-collection-overhead-in-sigma.html
11:23:48 <dfeuer> GHC doesn't implement tail recursion modulo cons for strict data, does it?
11:23:53 <dysfun> no, the paper
11:24:02 <yamadapc> I'm not sure if it's restricted to one or the other
11:24:17 <dmwit> > let extract key env = case partition (\(k,v) -> k == key) env of {([(_,v)], rest) -> (v, rest); _ -> error "key not found or ambiguous"}; extractset env env' = foldr (\(k,v) acc -> snd $ extract k acc) env' env in extractset [(1,"a"), (2,"b"), (3,"c")] [(1,"a"), (2,"b"), (4,"d")]
11:24:18 <lambdabot>  *Exception: key not found or ambiguous
11:24:25 <dmwit> m1dnight_: ^^
11:24:25 <yamadapc> The Java paper is at http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=6900210&abstractAccess=no&userType=
11:24:41 <dfeuer> So ... I may be able to work some magic by building the list backwards ....
11:24:52 <mnoonan> m1dnight_: why not use some nicer model of failure, like Either SomeErrorType or Maybe?
11:25:05 <dysfun> ty :)
11:25:08 <dmwit> mnoonan++
11:25:19 <m1dnight_> mnoonan: I know. But I'm implementing a formal semantics and I want (for didactic purposes) stay as close to them as possible.
11:25:37 <dmwit> I would be shocked if your formal semantics did not include failure.
11:25:45 <mnoonan> I'd argue that my suggestion is closer to the formal semantics, since it doesn't mix your model of semantics with Haskell's runtime semantics :)
11:25:47 <dmwit> At the very least as stuck terms.
11:25:51 <m1dnight_> Yes, stuck terms.
11:26:02 <m1dnight_> But you need to bend to the type system a little bit, right.
11:26:13 <dmwit> No, I don't see why you would.
11:26:22 <dmwit> You have a step function which either takes a step or gets stuck.
11:26:30 <dmwit> That's `step :: Term -> Maybe Term`.
11:27:00 <dmwit> Or possibly `step :: Term -> Term -> Bool` if your semantics is really a relation between terms.
11:27:58 <m1dnight_> Hrm, maybe I should do it that way.
11:33:34 * hackagebot Glob 0.7.7 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.7 (MattiNiemenmaa)
11:35:10 <fr33domlover> What's the recommended way to select elements of tuples? I found the 'tuple' package, seems good but it not in Stackage for some reason
11:35:29 <Rembane> fr33domlover: Pattern matching or lenses.
11:35:51 <kadoban> fr33domlover: Just add it as an extra-dep if you need it, it's not very hard. (assuming you're using stack)
11:36:13 <fr33domlover> kadoban, yeah sure, can do that easily. Just wondering
11:39:10 <fr33domlover> Rembane, hmmm so (g . (^. _2) . f) ? from the little I know about lenses :P with the tuple package I can do (f . sel2 . g)
11:42:17 <crough> fr33domlover: sometimes the non-operator versions of common lens operators are nicer. (^. _2) can be rewritten `view _2` without the need of a section
11:42:28 <Rembane> fr33domlover: I have no clue. :)
11:42:57 <dmwit> fr33domlover: There's nothing wrong with the `tuple` package. Have you considered not using a tuple, though?
11:42:58 <crough> also, `f . sel2 . g` is `f . view _2 . g` -- they don't get reversed
11:43:49 <dmwit> fr33domlover: See also http://stackoverflow.com/q/19072930/791604 for some discussion (by me) of why you might want to avoid pervasive use of tuples and `Either`.
11:44:18 <fr33domlover> dmwit, I get these tuples from an FGL graph
11:44:28 <fr33domlover> so it's not really my decision :P
11:44:35 * dmwit nods supportively
11:45:22 <dmwit> If you want to skip a dependency, I often define `frst`, `scnd`, and `thrd` for the selectors on 3-tuples. They're each one-liners.
11:45:48 <dmwit> This convention scales okay to 4-tuples as well, but not 5-tuples. =P
11:46:37 <c_wraith> it's OK. 5-tuples cause insanity and should not be used. :) 
11:46:56 <fr33domlover> It's for a web app which is probably high level enough to use any tool,and there's probably an indirect dependency on lenses somewhere there anyway :P
11:47:02 <c_wraith> (more seriously, if your tuples get that big, a proper record is probably worth it) 
11:47:06 <fr33domlover> e.g.I could use microlens
11:47:34 <c_wraith> I'm not sure microlens would have _1
11:47:53 <Cale> fiirst second thiird fourth fiifth
11:47:59 <c_wraith> since one of its goals is to not have all the classes that enable things like that. 
11:48:35 <dmwit> Cale: =)
11:48:40 <crough> microlens-platform has everything but prisms iirc
11:49:20 <fr33domlover> microlens does have _1 ... _5
11:49:41 <fr33domlover> (but not sure about the instances required for these to work on tuples, will check)
11:50:55 <c_wraith> if it has the name, I'm sure it'll have those instances 
11:51:15 <c_wraith> the names are only really useful with the instances. :) 
11:53:20 <dmwit> Pfft, if it doesn't have _64 it's not even worth bothering with. (GHC spelunkers will understand this joke.)
11:55:15 <fr33domlover> I already use 'diagrams' which depends on 'lens'
11:55:19 <fr33domlover> so I'm fine :P
11:56:21 * fr33domlover thinks Haddock should have syntax for linking to packages, much like "X.Y.Z" links to a module
12:25:45 <shanemikel> what's up guys?
12:25:52 <dmj`> shanemikel: sup
12:50:03 <codedmart> Is there something I am doing wrong with this that has the extra empty strings? `Data.Text.split (`elem` "['[',']']") (Data.Text.pack "related[favorites][user]”)` -> `["related","favorites","","user",””]`?
12:51:07 <seivan_> Why does Parsec have separate string and char parsers?
12:51:38 <Cale> seivan_: convenience, and the fact that 'string' can be implemented more efficiently than mapM char for some string types
12:51:38 <geekosaur> codedmart, it's doing exactly what you told it. split isn't really the tool for that usage; you probably want a simple parser
12:52:11 <Cale> codedmart: Well, one thing that's weird is the string you're passing to elem has repeated characters in it
12:52:21 <Cale> But yeah, it's doing exactly what you asked for
12:52:38 <codedmart> So I should use a parser?
12:52:50 <geekosaur> oh
12:53:00 <seivan_> Why cant it just work with strings?
12:53:07 <seivan_> What's the point of separating those two?
12:53:10 <geekosaur> yes, I think you wanted without the double quotes in that `elem` part
12:53:17 <seivan_> oneOf("asd") could just return a string, instead of a char type?
12:53:18 <EvanR> a string is conceptually a sequence of chars
12:53:26 <Cale> https://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html -- you could perhaps be looking for wordsBy from this library
12:53:31 <EvanR> chars fit in 1 Int, strings dont
12:53:39 <EvanR> the basic unit of text parsing is the character
12:54:02 <EvanR> to consider a sequence of strings, some other parser would have to precede the original stream to chunk it
12:54:02 <geekosaur> but changing that won't change the result, since multiples count as one
12:54:16 <Cale> seivan_: Why should it produce a String if the string will always have exactly one element?
12:54:24 <codedmart> I am trying to figure out how to handle a query string in haskell. I have this query and this is what I get in javascript -> https://gist.github.com/codedmart/f5cda744ee172aec493059cb8b54005c#file-query-L1
12:54:26 <Cale> That just loses information about what's going ong
12:54:27 <Cale> on*
12:54:46 <seivan_> Cale: Oh, fair enough
12:54:47 <EvanR> yes, a String of length 1 is more conveniently modeled as a Char
12:55:23 <EvanR> unless its APL
12:55:46 <sm> codedmart: passing "['[',']']" to elem doesn't really make sense, it's equivalent to "[]',"
12:56:13 <geekosaur> I am suspecting that the original example was [
12:56:13 <geekosaur> [
12:56:15 <geekosaur> er
12:56:23 <codedmart> sm: OK thanks!
12:56:35 <geekosaur> I am suspecting that the original example was ['[',']'] but that won't work with Text, only with String
12:57:30 <codedmart> Any ideas on how to handle that query string to get back some kind of foldable (list, map, etc)?
12:57:32 <geekosaur> but instread of using pack on it, they assumed the list has to be passed in as a string representing the list
12:58:15 <geekosaur> (or, more sensibly, writing it as "[]")
12:58:21 <sm> codedmart: since you already have a list (the original string, why not use the much more capable split package)
12:58:34 <sm> er, move that parenthesis
12:58:36 * hackagebot binary-orphans 0.1.5.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.5.0 (phadej)
13:00:01 <sm> or maybe yes, a quick parser is easiest
13:00:07 <codedmart> It is QueryText -> [(Text, Maybe Text)] -> which from that query is something like this -> [("related[user]","true"),("related[favorites][user]","true"),("related[comments][user]","true"),("related[comments][orderBy][]","asc"),("related[comments][orderBy][]","createdAt")]
13:00:10 <geekosaur> hm, actually both of those may be wrong, I have to look at the type of Text's split... that said, this still seems like the wrong way to go about it, and the failure mode that started this is not related (yet. try it with a string with ' or , in it...)
13:01:18 <sm> actually, the quick and dirty fix is to just filter out the null strings 
13:01:29 <codedmart> sm: That is what I did.
13:01:45 <sm> I like it
13:01:51 <EvanR> practice quickly setting up a parser 
13:02:06 <EvanR> then youll be badass
13:02:06 <codedmart> But I would really like to try and come up with a way to get back a map or something that resembles the object I get in js so I can fold over it.
13:02:21 <codedmart> Just above my head right now.
13:02:22 <geekosaur> yeh, that "works" here but technically it's losing information (try it with "related[favorites]user")
13:02:34 <EvanR> codedmart: you mean convert json text into a json object?
13:02:35 <sm> oh, well use one of the json libs then
13:02:38 <EvanR> aeson
13:02:59 <EvanR> it has a type Value which corresponds to json data directly
13:03:22 <codedmart> EvanR: Doesn’t have to be son -> I have this query that comes in. -> https://gist.github.com/codedmart/f5cda744ee172aec493059cb8b54005c#file-query-L1
13:03:45 <EvanR> well its already json so
13:03:52 <codedmart> EvanR: In that gist there is a js representation of what I get on my node server.
13:04:11 <codedmart> But in haskell I don’t care what it is as long as I can recursivly fold over it.
13:04:30 <sm> ok.. so your input is that special custom query format, and you want to convert it to a traversable json value
13:04:45 <EvanR> well, json is still a good default for structured-ish data that can be written out as text
13:04:48 <sm> definitely sounding like you need to write a parser 
13:05:11 <codedmart> EvanR: I get QueryText :: [(Text, Maybe Text)] -> which the results in this [("related[user]","true"),("related[favorites][user]","true"),("related[comments][user]","true"),("related[comments][orderBy][]","asc"),("related[comments][orderBy][]","createdAt")]
13:05:13 <EvanR> it sounds like codedmart is able to pick what the format is before even having to figure out how to parse it
13:05:25 <codedmart> So I should write a parser?
13:05:27 <EvanR> codedmart: yeah no... thats not doing enough
13:05:45 <codedmart> What is not doing enough?
13:05:55 <EvanR> that "result" you have
13:06:07 <codedmart> That is what the wai/servant gives me.
13:06:14 <EvanR> what... i dont believe it
13:06:34 <EvanR> change your content type or decoder or something
13:06:44 <seivan_> Would it be weird to implement oneOf, spaces, etc as instance methods to be called on self instead of global public functions? 
13:06:48 <codedmart> This is a query param not a body.
13:07:02 <codedmart> I don’t have control of that do I?
13:07:07 <EvanR> still it looks like its half way process it for you
13:07:08 <seivan_> self.oneOf("abc") <|> many("asd")
13:07:28 <nitrix> seivan_: Two points to address. The latter, it isn't actually global.
13:07:37 <codedmart> EvanR: Yeah is basically splits it at the `=`
13:07:51 <seivan_> nitrix: Yeah but the implementations of it in Swift (the various ones I've looked at) make it global :)
13:08:02 <seivan_> I would like to keep it contained so it's easy to discover
13:08:05 <sm> codedmart: where does this query format come from ? 
13:08:05 <nitrix> seivan_: The scopes is restricted to the module, which you can import in other modules and even re-export.
13:08:09 <seivan_> self.combinators.many(...)
13:08:14 <codedmart> EvanR: Actually you are right I can use the base bytestring that has not been processed.
13:08:25 <EvanR> *thumbs up*
13:08:54 <codedmart> But it looks the same as the linked query params.
13:09:04 <codedmart> So is the recommendation to write a parser?
13:09:13 <EvanR> where is the original post coming from?
13:09:29 <codedmart> It is a query string from a get request.
13:09:33 <EvanR> s/post/get/
13:10:03 <EvanR> its kind of shitty encoding of request params
13:10:12 <EvanR> if you can change it i would
13:10:16 <codedmart> So I would have a bytestring of `related[user]=true&related[favorites][user]=true&related[comments][user]=true&related[comments][orderBy][]=asc&related[comments][orderBy][]=createdAt`
13:10:19 <nitrix> seivan_: As for the former question, instances in Haskell refer to type class instances. We don't have this OOP attachment of operations to data. You can mimick similar with Existantial quantification and records, but it wont be pretty.
13:10:34 <codedmart> EvanR: How would you change it if I had the option?
13:10:47 <sm> codedmart: I asked where does this format come from, because there's probably a specification and a parser in some other language, which you could copy
13:10:47 <EvanR> you know what i mean, maybe
13:11:13 <seivan_> nitrix: I am only looking at Parsec because it originated there(?), writing Swift.
13:11:19 <codedmart> sm: I am using nodejs now so I could look at that.
13:11:26 <EvanR> sm: its the standard x-www-form-data format, which would become a php array in php
13:11:43 <nitrix> seivan_: Parsec leverages type classes and carefully designed combinators.
13:11:43 <seivan_> But I am curious why somethings only exist on Char
13:11:46 <seivan_> but not Int or other stuff
13:11:59 <seivan_> like... anyOf() why doesn't it work with ints?
13:12:07 <nitrix> :t anyOf
13:12:08 <lambdabot> Profunctor p => Accessing p Any s a -> p a Bool -> s -> Bool
13:12:23 <seivan_> say I am parsing from Double to Int
13:12:25 <nitrix> seivan_: Because of the constraint, most likely.
13:12:27 <sm> EvanR: http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1 ? Is that defining the brackets etc. ?
13:12:29 <seivan_> I am not longer working with strings
13:12:31 <EvanR> seivan_: btw, any Parser Char can be converted to Parser Int with fmap ord myParser
13:12:41 <geekosaur> parsing from Double to Int???
13:12:48 <seivan_> geekosaur: loosly worded..
13:12:48 <geekosaur> that does nto sound like parsing...
13:13:08 <seivan_> geekosaur: Yeah I know but the work from char to a number value is "done", then the next step is to make it into a double because various other rules. Just go with me.
13:13:10 <EvanR> sm: im not sure where its formally defined, but its a defacto standard and theres probably lots of conversions for it
13:13:14 <EvanR> implemented
13:13:14 <seivan_> EvanR: Example?
13:13:22 <sm> ok
13:13:36 * hackagebot hs-popen 0.1.0.0 - Bindings to C pipe functions.  https://hackage.haskell.org/package/hs-popen-0.1.0.0 (deech)
13:13:44 <geekosaur> in any case it s not very meaningful to have a basic combinator for "int" because --- whose "int"?
13:13:47 <EvanR> seivan_: fmap ord myParser
13:13:57 <sm> if we knew the correct name, we could see if it's already on hackage
13:14:01 <geekosaur> Haskell syntax with its weird unary minus? C? APL?
13:14:05 <seivan_> All these methods https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html
13:14:08 <seivan_> Why aren't they generic?
13:14:14 <seivan_> Why are the implemented over Char?
13:14:23 <EvanR> seivan_: but its probably not that relevant to your question, if you have a bunch of Parser Int, then you can definitely do a choice, or process the Ints however you want
13:14:35 <seivan_> EvanR: It is very relevant. 
13:14:46 <seivan_> EvanR: Thanks. You got any code sample to explain it?
13:14:52 <EvanR> sm: i think each web framework has implemented the parser separately... but yeah i would expect a separate package for this
13:14:56 <seivan_> Also, what's a stream? Is it a string? 
13:15:10 <seivan_> oneOf takes a stream and makes it into a char (or [char]? )
13:15:11 <geekosaur> a notional string, which may be String or Text or ByteString
13:15:15 <EvanR> seivan_: the stream is the implicit source of all the data into the parser
13:15:16 <seivan_> geekosaur: Cool.
13:15:30 <EvanR> it could be a stream of Char or anything else, tokens
13:15:30 <seivan_> EvanR: Yeah So it's the input type, what does it need to conform to?
13:15:41 <geekosaur> I am now suspecting that you are using "parse" in a very general way that doesn't fit what "parse" means in programming
13:15:49 <seivan_> geekosaur: Yes, I was open with that :)
13:16:15 <geekosaur> (not just in Haskell; you wll not find your "Int parser" in yacc/bison/byacc either)
13:16:17 <EvanR> you just need to define the type of elements, a dequeue, and a way to know if the stream is done
13:16:29 <seivan_> I don't understand the documentation headline. Correct me if I am wrong: oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char   this takes a stream and returns a Char? 
13:16:42 <seivan_> it also takes [Char] and returns a Char
13:16:48 <codedmart> EvanR am sorry stepped away. So I should figure out what node is Doug and write a similar parser?
13:17:07 <codedmart> sm ^^
13:17:09 <Gurkenglas> Suggest an operator alias name for flip (.)!
13:17:11 <EvanR> codedmart: this has been solved so many times, i would feel silly doing it, ... which ive done
13:17:25 <geekosaur> this takes a Stream which produces tokens of type Char, and a list of Char-s, and returns a Char within the parser (you can read that as: a parsed Char)
13:17:37 <codedmart> EvanR: is there a package already for this?
13:17:49 * EvanR searches for the package as well
13:18:08 <codedmart> I am not sure what it would be called.
13:18:34 <nitrix> Gurkenglas: >>>
13:18:58 <Gurkenglas> Right, I know that name and its stupid (and the wrong precedence :/)
13:19:16 <seivan_> geekosaur: So you might say it takes a Stream and returns a char, and leave it at that? 
13:19:18 <nitrix> Gurkenglas: .> ?
13:19:26 <Gurkenglas> (  Perhaps ༼ノಠل͟ಠ༽ノ-︵-˙  )
13:19:33 <geekosaur> and "parser" in programming refers to a function that converts a textual representation of something to a syntax tree
13:19:47 <Gurkenglas> Yea that sounds ok though </> sounds like applicative stuff)
13:19:56 <seivan_> geekosaur: Yeah but isn't Parsec used to convert between types as well?
13:20:01 <geekosaur> no
13:20:14 <seivan_> geekosaur: Isn't String to Int a type conversion in its own?
13:20:24 <EvanR> codedmart: its a folklore format. its also shitty, many apis use something else now which is why i asked
13:20:36 <EvanR> if you can change it
13:21:11 <geekosaur> seivan_, that is parsing, because String to Int is not quite trivial. consider: negative numbers, alternative input bases.
13:21:20 <EvanR> codedmart: https://www.reddit.com/r/haskell/comments/3sxcsp/status_of_percent_encoding_and_xwwwurlencoded_in/
13:21:26 <seivan_> geekosaur: Yeah, first a sign, fixed, fraction and then exponent 
13:21:30 <seivan_> All in parsec
13:22:20 <geekosaur> but (fromIntegral :: (Integral a, Num b) => a -> b) does not involve parsing, often it's just a CPU instruction to convert between CPU-specified number formats
13:22:48 <seivan_> geekosaur: Yeah I mean it's literally Int(myString) and returns an optional Int.
13:22:53 <EvanR> codedmart: for your purpose you can also convert the list of (string, maybe string) into another form using groupby
13:23:04 <geekosaur> String to pretty much anything almost always requires extra work to handle special cases, which is why parsing is a thing
13:23:06 <fr33domlover> In 'diagrams' how do I insert a hyperlink into a diagram (I use SVG backend)
13:23:12 <seivan_> geekosaur: But the "parsec" combination would have to be implemented to get that in a simple run()
13:23:34 <EvanR> explicitly group and take each key like "foo[bar][baz][]" and thats a list, for "foo[baz]" it will be one item, so unlist
13:23:49 <EvanR> thats the manual way to do it
13:25:17 <nitrix> Gurkenglas: https://hackage.haskell.org/package/compose-ltr-0.1.3/docs/Data-Function-Compose-LeftToRight.html
13:25:35 <seivan_> geekosaur: What I am trying to say, is that why doesn't oneOf exist for Ints?
13:25:50 <nitrix> Gurkenglas: Existing libraries suggests that .> is the right name, but this one is clashing $> and <$ which belongs to functors.
13:26:04 <nitrix> So to take with a grain of salt.
13:26:08 <EvanR> seivan_: you could write a oneOf for any Eq type actually...
13:26:20 <geekosaur> seivan_, what you are trying to say is, why did programming go with its current definition of parsing 70+ years ago instead of one that you think makes more sense
13:26:21 <nitrix> Gurkenglas: Just a warning, (.) seems inverted but it is "correct".
13:26:37 <geekosaur> Parsec is using the standard definition of parsing
13:27:03 <seivan_> geekosaur: No I am just trying to figure out why it didn't make them generic for input
13:27:10 <geekosaur> ... I just told you
13:27:14 <seivan_> geekosaur: Ah ok.
13:27:16 <geekosaur> [28 20:26] <geekosaur> Parsec is using the standard definition of parsing
13:27:18 <EvanR> seivan_: youre probably looking specifically at the Char version of parsec
13:27:42 <EvanR> warning, there is no explicit Int version, but theres a generic version
13:27:44 <seivan_> EvanR: Yeah I am. But I could only find Char and String
13:27:50 <seivan_> https://hackage.haskell.org/package/parsec
13:27:57 <EvanR> yeah you can use token stream of any type
13:27:59 <geekosaur> you can make one, if you really want it for some reason
13:28:15 <geekosaur> you just don't get one predefined for you like you do with the cases that are actually used
13:28:22 <Gurkenglas> nitrix, I want it for "mx >>= f .> do --several lines after this"
13:28:23 <seivan_> You mean https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Token.html ? 
13:28:27 <EvanR> no
13:28:31 <EvanR> thats something else
13:28:36 <Gurkenglas> Umm, \case, not do
13:28:36 * hackagebot beam-th 0.1.0.0 - Template Haskell utilities for beam  https://hackage.haskell.org/package/beam-th-0.1.0.0 (hesiod)
13:28:41 <geekosaur> there are very, very few int-token parsers. the only one I can think of offhand is ASN.1, and it's an utter nightmare
13:28:51 <seivan_> I don't want an int parser
13:28:57 <geekosaur> er, I should say languages defined with int tokens
13:29:03 <seivan_> I am just trying to wrap my head around how Parsec is designed.
13:29:21 <EvanR> theres a token stream, your primitive parsers deal with those
13:29:24 <nitrix> Gurkenglas: Control.Monad solves this with forM and mapM
13:29:29 <EvanR> other parsers are built on top of the primitives
13:30:00 <EvanR> parsecs most common token type is Char so that has its own convenient module
13:30:01 <seivan_> If I were to guess. I could have generic Parsec, that takes a Stream (input) type and Output (result)  GenericParser<String, Char> (takes a string, outputs a char) this would be what Parsec has, and oneOf() would work as usual.
13:30:12 <seivan_> EvanR: Ah...
13:30:16 <seivan_> EvanR: "convenient module"
13:30:21 <seivan_> That's what I was guessing.
13:30:22 <Gurkenglas> nitrix, how is that written in terms of forM/mapM?
13:30:23 <EvanR> convenience module
13:30:35 <Gurkenglas> (and i meant the \case thing)
13:30:51 <seivan_> Parsec.char would return a Parsec<String, Char> 
13:31:01 <seivan_> Parsec.char.oneOf("åöl")
13:31:15 <seivan_> Does that look good?
13:31:16 <sm> codedmart, EvanR: http://stackoverflow.com/questions/30261513/is-there-a-spec-for-nested-urlencoded-params talks about this format, and https://secure.php.net/manual/en/function.parse-str.php. I suspect it's a PHP invention.
13:31:43 <sm> coincidentally it was just asked about on #php
13:31:44 <nitrix> Gurkenglas: What do you think ((*2) .> (+5)) 1 yields?
13:31:57 <Gurkenglas> 7
13:32:07 <EvanR> seivan_: i dont see it in the docs, but often you see type Parser a = ParsecT Char () Identity a
13:32:46 <EvanR> do you see how thats configuring parsec to specialize the way you want
13:32:54 <nitrix> Gurkenglas: And you manage to do the mental gymnastic of jumping around to see how that composes?
13:32:55 <seivan_> EvanR: Yup.
13:32:59 <seivan_> EvanR: I take it 'a' is the generic result?
13:33:07 <seivan_> EvanR: Btw thanks, that made it clearer.
13:33:12 <nitrix> Gurkenglas: What if `1` was more of these .> expressions?
13:33:13 <EvanR> a is the result type, if parsing succeeds
13:33:20 <kadoban> nitrix: I'm not convinced that (.) is in the correct order for actually coding, re your above.
13:33:21 <EvanR> you get an a
13:33:28 <kadoban> It's … kind of awkward, honestly.
13:33:30 <seivan_> EvanR: Yeah, a generic type.
13:33:36 <Gurkenglas> I do but maybe Ive been in this too long (I too would usually write that in terms of ., but not introducing names is more important :D)
13:33:57 <EvanR> seivan_: common terminology is that a is a type variable, universally quantified (implicitly)
13:33:58 <seivan_> hexcolor = GenericParser<String, UInt>
13:33:59 <Gurkenglas> nitrix, I would look up what absolute madman included a num instance for functions :P
13:34:03 <EvanR> also its polymorphic
13:34:04 <geekosaur> EvanR, Parser is defined in the modules for the canned stream types Text.Parsec.{String,Text,ByteString}
13:34:16 <seivan_> geekosaur: and char
13:34:16 <EvanR> ok
13:34:28 <geekosaur> seivan_, no, Char is not a stream type
13:34:28 <codedmart> sm EvanR I think the api I am rewriting is abusing query parameters.
13:34:36 <geekosaur> it's a token type
13:34:42 <seivan_> geekosaur: I think I see where you coming form
13:35:10 <EvanR> sm: yes, its become supported in many frameworks
13:35:14 <nitrix> kadoban: Function application is left-to-right, that is, what is to be applied on the left, it makes perfect sense to me that function composition is also left to right, in the sense that, what is to be composed is on the left.
13:35:17 <seivan_> How would I write a combinator(correct wording?) for taking my strings of #343 and making them into a UInt ?
13:35:24 <geekosaur> a stream is composed of tokens. since streams generally hold textual representations of things, the most basic token type is Char
13:35:25 <seivan_> or at the very least, identify them and return them?
13:35:40 <seivan_> geekosaur: Yup, so in our case it would be String and [Char] or CharacterView (Swift)
13:36:07 <seivan_> Essentially a CollectionType whos items are Character (char/token)
13:37:03 <EvanR> not any collection
13:37:03 <Gurkenglas> nitrix so youre saying that function application should be right to left
13:37:06 <EvanR> its a stream
13:37:11 <seivan_> What's the difference between https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec-Char.html and https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html
13:37:38 <kadoban> nitrix: Practically, the order that (.) forces me to write strings of functions in is extremely rarely the way that I think of it. So having to do    someFunc (move left a word, make a space, move left, make a ., move left, make a space, move left, do nextFunc is … kind of ridiculous.
13:37:39 <nitrix> kadoban: f $ g, function application, f applied to g;  f . g, function composition, f composed to g.
13:37:41 <EvanR> backwards compatability reexports
13:37:53 <hexagoxel> nitrix: for consistency, you of course write: 1 & (*2) .> (+5)
13:37:53 <nitrix> kadoban: I know it's not convenient to write, but it is to read.
13:38:13 <seivan_> EvanR: Was that for me?
13:38:15 <seivan_> EvanR: So no difference?
13:38:15 <EvanR> yes
13:38:16 <geekosaur> yes
13:38:19 <kadoban> nitrix: I don't think it's all that great to read either. It's just not as bad because you can just move your eyes more easily than it is to type it.
13:38:21 <geekosaur> parsec2 used the longer names
13:38:24 <seivan_> Ah ok
13:38:25 <geekosaur> parsec3 shortened them
13:38:43 <nitrix> kadoban: Do you write function application with & all the time too?
13:38:50 <nitrix> kadoban: It's essentially the same complaint.
13:38:54 <geekosaur> but re-exports the longer ones so stuff expecting parsec2 will still work
13:39:08 <nitrix> It write easier but reads better left to right with $
13:39:35 <EvanR> f(x) or 1234 ordering seems fixed in culture
13:39:47 <nitrix> (And that's coming from an advocate of RPN and concatenative languages)
13:39:49 <EvanR> but once it becomes f . g . h or h . g . f its like, whats the diff
13:39:49 <kadoban> nitrix: No, I don't. Somehow it doesn't come up, probably largely because I use the   a . b . c . d $ e    pattern a lot
13:39:54 <EvanR> dyxlexia sets in
13:40:35 <seivan_> When calling flatMap/bind on a combinator, so you get the value? 
13:40:37 <EvanR> you will find category theory books using both directions
13:40:47 <EvanR> hopefully not at the same time
13:41:11 <nitrix> Regardless. Point is, (.) seems reversed but it is "correct" if you're only looking at the operator itself and asking the question of "function composition" the same way you approach "function application".
13:41:17 <seivan_> string("#fff") >>= { return UIColor.whiteColor() }
13:41:44 <EvanR> nitrix: the same way application works in js? x.h().g().f() :D
13:42:02 <kadoban> I'm not really looking at any question except "which is better to write and read" and I'm not sure how you end up with (.) being correct from that.
13:42:11 <nitrix> EvanR: f $ g, f applied to g; f . g, f composed to g.
13:42:19 <hexagoxel> one counter-argument to left-to-right is the that the bindings you finally "assign to" (let, where) are on the left, not the right.
13:42:21 <EvanR> yes "f o g"
13:42:50 <EvanR> f . g . h = x let
13:43:02 <EvanR> :D
13:43:04 <hexagoxel> :D
13:43:11 <EvanR> i support this
13:43:20 <glguy> f . g's order makes particular sense in Haskell where evaluation happens from the outside in
13:43:35 <hexagoxel> too bad leksah is taken already.
13:43:42 <EvanR> lets take backwards seriously
13:43:47 <seivan_> EvanR: https://gist.github.com/seivan/99c15832dc0694ddd109b62a0616ff0f
13:44:25 <EvanR> omg leksah is haskell backwards
13:45:09 <nitrix> Almost.
13:45:11 <cocreature> EvanR: wait what? why did I never notice this before
13:45:23 <kadoban> Hah, wow
13:45:28 <nitrix> cocreature: Because one L is omitted.
13:46:17 <nitrix> Lleksah would probably give it away much sooner.
13:46:29 <EvanR> yeksah
13:46:37 <cocreature> nitrix: yeah but still I feel like I should have noticed this years ago :)
13:46:53 <seivan_> EvanR: Did that make sense?
13:47:09 <EvanR> seivan_: not really, swift kind of hurts my soul
13:47:30 <EvanR> though it is better than other fad languages of the day
13:48:09 <seivan_> EvanR: flatMapping a matching string into a color
13:48:22 <EvanR> do you understand how to write this in haskell
13:49:05 <seivan_> EvanR: Sorta..
13:49:13 <EvanR> not good enough
13:49:34 <seivan_> Parsec.string "hello" >>= UIColor.whiteColor() :)
13:49:38 <seivan_> Almost?
13:50:03 <EvanR> i dont really know if thats the same or not
13:50:29 <EvanR> do you want to convert a string result to a colo
13:51:29 <seivan_> a string result to a completly different type
13:51:45 <seivan_> Say a hex string to whatever a color is in whatever UI framework haskell uses
13:53:03 <EvanR> start by writing a parser to get a hex character
13:53:13 <EvanR> then replicateM 6 to get 6 hex characters
13:53:24 <EvanR> then apply the decoder to it to get a Maybe Color
13:53:34 <EvanR> if its Nothing, then fail
13:53:37 <EvanR> else return the color
13:53:39 <seivan_> EvanR: Yup :)
13:53:48 <seivan_> I just went a shorthand to show what I am doing
13:53:54 <seivan_> (e.g string to color directly)
13:53:56 <EvanR> haskell IS the shorthand!
13:54:49 <EvanR> actually, 6 hex characters is always some color
13:54:56 <EvanR> so you dont really need the maybe
13:57:00 <seivan_> EvanR: We're also using 3, 4 and 8
13:57:03 <seivan_> (Alpha)
13:58:00 <EvanR> you also need a 4th color channel for synesthete gamers
13:58:24 <EvanR> with bad ass monitors
13:59:51 <seivan_> ;)
13:59:55 <seivan_> But.. I think I got it.
14:00:30 <seivan_> Parsec<InputStream, State, Result> where Parsec<String, Void, Char> would have the "char based" methods oneOf(), etc.
14:00:51 <EvanR> the important part is that getting a hex character, and getting 6 of something can all fail, so its a pain in the ass to put this same check in between every "get X" command
14:00:52 <seivan_> Parsec.char -> (returns a) Parsec<String, Void, Char>
14:01:19 <EvanR> decoding isnt part of the parsing, its just a normal (total in this case) function
14:01:56 <EvanR> i highly suggest learning haskell
14:02:05 <seivan_> EvanR: I just like Parsec :) sorry
14:10:49 <athan> Do sections `foo` have a default fixity?
14:10:58 <phadej> yes, 9
14:11:05 <athan> Like wide & left associative?
14:11:07 <phadej> non-assoc
14:11:10 <athan> ahh, thanks phadej
14:11:12 <athan> oh wow hmm
14:11:16 <athan> how does that work?
14:11:29 <glguy> no, they are infixl
14:11:36 <athan> ahh thanks glguy
14:11:41 <phadej> ok, then i remembered wrong.
14:12:29 <phadej> > [] `mappend` [] `mappend` []
14:12:31 <lambdabot>  []
14:12:33 <phadej> :i mappend
14:12:44 <phadej> says no infix declration. TIL
14:13:10 <glguy> You can set an infix declaration on a back-ticked operator, see `mod`, `elem`, etc.
14:13:31 <glguy> :t \x -> x `x` x . x
14:13:32 <lambdabot>     Precedence parsing error
14:13:32 <lambdabot>         cannot mix ‘x’ [infixl 9] and ‘.’ [infixr 9] in the same infix expression
14:14:00 <glguy> Even if you explicitly declare an operator to be infixl 9, GHCi will still neglect to print that in the :info output
14:14:08 <glguy> (because it's the default)
14:15:41 <ertesx> > let f = (+); infixl 9 `f` in 2 * 3 `f` 4
14:15:42 <lambdabot>  14
14:16:27 <glguy> > 2 * do 3 + 4
14:16:29 <lambdabot>  14
14:16:36 <ertesx> i never realised that you can do that locally
14:20:02 <athan> Is there a `when` for `a -> a`? s.t. `when foo bar` == `if foo then bar else id`
14:21:09 <ertesx> :t \p f -> if p then f else id
14:21:10 <lambdabot> Bool -> (a -> a) -> a -> a
14:21:44 <ertesx> i don't think so
14:21:44 <EvanR> why stop there! church encode the bool
14:21:56 <glguy> :t bool
14:21:57 <lambdabot> a -> a -> Bool -> a
14:21:58 <athan> heh, thanks :)
14:22:15 <EvanR> :t bool f id
14:22:16 <lambdabot> (Show a, FromExpr a) => Bool -> a -> a
14:22:25 <athan> O_O
14:22:29 <athan> FromExpr?!
14:22:35 <ertesx> :t f
14:22:35 <lambdabot> FromExpr a => a
14:22:39 <EvanR> f is an expression
14:22:40 <athan> -.-
14:22:44 <athan> wat
14:22:45 <ertesx> athan: lambdabot peculiarity
14:22:50 <ertesx> > f x
14:22:51 <lambdabot>      No instance for (Show a0)
14:22:51 <lambdabot>        arising from a use of ‘show_M25910821551502096294507’
14:22:51 <lambdabot>      The type variable ‘a0’ is ambiguous
14:22:51 <athan> ertesx: free variable?
14:22:54 <EvanR> lambdabotskell
14:22:59 <athan> rofl
14:23:02 <ertesx> athan: no, it's a library for ASTs
14:23:09 <glguy> It's from the simple-reflect package
14:23:19 <ertesx> > map f [x, y, z]
14:23:20 <lambdabot>      No instance for (Show b0)
14:23:20 <lambdabot>        arising from a use of ‘show_M38387643969542360894517’
14:23:20 <lambdabot>      The type variable ‘b0’ is ambiguous
14:23:31 <ertesx> lambdabot: yeah, whatever
14:23:38 <glguy> > f x :: Expr
14:23:40 <lambdabot>  f x
14:23:40 <EvanR> > bool (+1) id True 99
14:23:42 <lambdabot>  99
14:23:45 <EvanR> > bool (+1) id False 99
14:23:46 <ertesx> > map f [x, y, z] :: Expr
14:23:47 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[b0]’
14:23:47 <lambdabot>      In the expression: map f [x, y, z] :: Expr
14:23:47 <lambdabot>  100
14:23:50 <athan> glguy: !! wow!
14:23:53 <athan> that is too cool
14:23:54 <ertesx> > map f [x, y, z] :: [Expr]
14:23:55 <lambdabot>  [f x,f y,f z]
14:23:56 <glguy> ertesx: no, it'd be a [Expr]
14:24:16 <athan> glguy: It can partially evaluate ASTs?
14:24:40 <athan> friggin awesome
14:24:46 <athan> it's like inline templateHaskell
14:24:55 <ertesx> it's really nothing fancy
14:25:44 <glguy> http://hackage.haskell.org/package/simple-reflect
14:25:54 <glguy> It's not magic; you can check it out if you're curious
14:26:21 <athan> thanks everyone :) you guys are from space I swear
14:28:18 <Cale> athan: It's like one step away from doing tricks like this:
14:28:52 <Cale> > foldr (\x xs -> concat ["(f " ++ show x ++ " " ++ xs ++ ")"]) "z" [1..5]
14:28:54 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
14:29:36 <ertesx> :t \x0 -> ContT (\k -> let l x = ContT (\_ -> k (l, x)) in k (l, x0))
14:29:38 <lambdabot> t -> ContT r m (t -> ContT r m a, t)
14:30:16 <Cale> athan: Where we implement instances of Num and such for our Expr type, which is little more than a newtype of String (actually a function of the precedence level so that the parens can be done nicely)
14:36:54 * ertesx fails to define this in terms of callCC
14:37:09 <dmwit> athan: If you want magic, you should look at SBV instead.
14:37:48 <qinusty> Does anyone have a solution to how I can somehow allow a set amount of time for an IO action to complete?
14:38:02 <codedmart> EvanR sm Sorry I stepped away again for a bit, what was the consensus? Is there a package? Should I write something or see if I can change the query params?
14:38:16 <ertesx> qinusty: like System.Timeout?
14:38:46 <EvanR> codedmart: one out of one dr EvanR recommend not using that format, it was invented by PHP (maybe) and has just been copied out of indifference
14:38:56 <Denommus> I'm going to be hired to work with Haskell and/or OCaml :D
14:39:13 <EvanR> thats the consensus
14:39:31 <codedmart> EvanR: Hmm… not sure how to restructure the query params to get the information I need.
14:39:41 <dmwit> One hardly seems like a quorum. Can you have a consensus without a quorum?
14:39:52 <dmwit> I'm going to need somebody to check the rules.
14:39:56 <EvanR> codedmart: paste the example json again?
14:39:56 <qinusty> ertesx: I'll take a look cheers
14:40:28 <codedmart> EvanR: https://gist.github.com/codedmart/f5cda744ee172aec493059cb8b54005c
14:41:04 <EvanR> codedmart: this particular information can be flattened 
14:41:11 <EvanR> into a 1 level record
14:41:24 <EvanR> it doesnt even have arrays
14:41:44 <EvanR> maybe you have other examples
14:42:00 <codedmart> This one is the most complex right now.
14:42:08 <EvanR> excellent
14:42:48 <EvanR> for the record, more complex queries in popular APIs right now will opt for a POST instead so you can structure the data in something like json
14:43:06 <EvanR> but the query has to be really complex
14:43:27 <codedmart> EvanR: A`POST` seems weird to me when you really are just `GET`ing information.
14:43:38 <EvanR> yeah but you cant use a post body for GET
14:43:45 <EvanR> weird or not, APIs do it
14:43:48 <codedmart> Yeah I know that.
14:44:08 <EvanR> when you dont want to do it, you should really simplify your query language to be flatter
14:44:28 <codedmart> Should I try to see if I can switch things to do that, or do you have a suggestion of formatting my current query params.
14:44:31 <EvanR> another issue with query strings is the URL length
14:44:39 <codedmart> I am not seeing the flattenting I guess.
14:44:45 <EvanR> firefox on osx used to just barf if it was about 800 chars
14:44:54 <codedmart> EvanR: That is a valid point.
14:45:45 <EvanR> whats the point of "related" here?
14:46:46 <ertesx> codedmart: data with no recursion can always be flattened to a sum of products using the laws of type algebra
14:47:25 <EvanR> in this case just a product
14:47:29 <codedmart> So basically what this query params says is -> Get related(relation) users -> also get related favorites (as well as the users for those favorites) -> also get related comments (as well as related users and order by  asc createdAt).
14:51:02 <codedmart> EvanR: Does that make sense? I also just read something about a REPORT method. Hadn’t heard of that one.
14:55:42 <EvanR> codedmart: youre trying to make a language to do basically SQL?
14:56:10 <EvanR> if not, then a specifically configurable thing for each query is probably better
14:56:26 <codedmart> EvanR: I guess so, but not trying. This is a working example from my nodejs server I a trying to rewrite.
14:56:42 <codedmart> What do you mean specifically configurable?
14:57:17 <EvanR> for feature x, make  get endpoint with a few obvious arguments, and the type of the arguments arent entire database programs, they are just simple criteria
14:57:40 <EvanR> rather than /api/query?sql=...
14:58:51 <EvanR> if you want favorites with comments, make /api/user/3/favorites
14:59:40 <codedmart> EvanR: Oh right so different routes per relation. But doesn’t that cause more work lag on the browser because it is making more requests?
14:59:46 <EvanR> then see if its worth adding some query params to change the ordering of the comments for some reason
15:00:37 <EvanR> codedmart: its vastly not in vogue anymore to put literally everything at http://mysite.com/?codeToExecute=....
15:00:47 <EvanR> you want real url paths
15:00:54 <EvanR> for a lot of reasons
15:00:58 <EvanR> example googlability
15:02:59 <codedmart> True, and fair enough, but that seems like a lot of http requests that are avoided now. For instance if I query /api/tasks and get 40 tasks and also want the comments for each task, bit I need to make 40 more requests per task to get the comments?
15:03:11 <ertesx> (ironically google's websites are terrible examples of good route schemes)
15:04:06 <codedmart> ertesx: Thanks for your response. My algebra knowledge is way rusty. I will have to look it up.
15:04:12 <EvanR> codedmart: no, if you want comments for 40 tasks, go to /comments/byTask?tasks=1,2,3,4,5,6
15:04:24 <EvanR> where 6 = 40
15:04:58 <EvanR> make optimized endpoints when you end up getting latency problems for making too many requests
15:04:59 <codedmart> Ah so two requests then or possible more if I am getting other relations.
15:05:11 <codedmart> But one request per relation.
15:05:20 <EvanR> i dont think of it in terms of relations
15:05:35 <EvanR> these end points are going to certain entity sets
15:05:52 <EvanR> unless its a specialized report, which collects many different sets together
15:06:04 <EvanR> which you can make and special endpoint for when it comes up
15:06:08 <ertesx> > let 6 = 40 in 6 + 6
15:06:10 <lambdabot>  80
15:06:11 <codedmart> Well right, but I mean if a task has comments, subtasks, and tags. I would have endpoints for all those with byTask if I needed right?
15:06:18 <codedmart> That is what you are suggesting?
15:06:38 <EvanR> if youre really trying to get just comments alone? i guess?
15:06:48 <EvanR> arent trying to get comments along with other stuff
15:07:01 <EvanR> go to the one that give you all the shit nested
15:07:28 <codedmart> Yeah, I will have to ponder this and see what I can come up with.
15:07:48 <EvanR> but yes implement the ones that suit the particular thing youre trying to do, rather than a ad hoc bug ridden thing to try to do any sql
15:07:59 <ertesx> codedmart: personally i wouldn't mind a small query language for internal use (for example from JS), but keep it minimal, composable and secure
15:08:28 <codedmart> ertesx: What constitutes small?
15:08:40 <codedmart> EvanR: Thanks for your help and insight!
15:08:56 <ertesx> codedmart: small often follows from composable, but also means not being able to ask for things that clients aren't supposed to know
15:09:43 <EvanR> codedmart: this is just my experience with real web service practice, you can of course endulge in language design, but this is even trickier than normal when dealing with http query strings
15:09:47 <ertesx> but users should never see that language, so no links to queries using it…  you should only ever use it from JS
15:10:10 <ertesx> otherwise all the bad stuff happens:  bad searchability, bad UX, etc.
15:10:16 <codedmart> EvanR: Yeah I have done a few different api’s before. This one is the strangest so far.
15:10:38 <EvanR> codedmart: keeping it targeted also makes it easier to validate the input
15:10:38 <codedmart> ertesx: Yeah right now it is only used in js and users don’t see it.
15:11:13 <ertesx> codedmart: but usually there is no reason to have such a language:  you have a bunch of object types with certain options most of the time
15:11:33 <ertesx> "gimme these tasks (the object type) with comments enabled (option)"
15:11:51 <ertesx> that's a lot easier to model and implement (though usually harder to reason about)
15:11:59 <EvanR> /tasks?commentsEnabled=true
15:13:12 <codedmart> Right, I think I might have the opportunity to change the params. So I will try your suggestions.
15:13:46 <EvanR> assuming commentsEnabled is a flag in the task.. otherwise i would just default to returning all the related comments in the result
15:13:58 <codedmart> Most of them are fairly straight forward to implement with your suggestions I think. Just a few that I might need to rethink a bit.
15:14:44 <codedmart> EvanR: That is a good suggestion.
15:15:20 <codedmart> I mean in all reality this api in it’s current state is not public and never should be. But they want to open a public api so might as well make a smart change now.
15:18:41 <codedmart> EvanR ertesx Thanks again!
15:18:52 <codedmart> Thanks to anyone that responded and gave suggestions.
15:29:38 <athan> Anyone here mess with wai-websockets at all?
15:30:07 <qinusty> Can someone how to get the value of something in the Just monad without fromJust?
15:30:13 <qinusty> does <- work? Like IO?
15:30:33 <texasmynsted> So y combinator can not be defined in haskell via ghc?
15:30:46 <Skami> qinusty. What do you mean?
15:30:51 <ertesx> qinusty: pattern-match on it
15:31:07 <ertesx> qinusty: also it's not the Just monad, but the Maybe monad, though i recommend you just say "Maybe type"
15:31:09 <qinusty> I have used lookup, received a Maybe value
15:31:21 <kadoban> qinusty: do {a <- ma; … some stuff with a …}  is a possibility, sure
15:31:30 <Skami> or just using case 
15:31:34 <mniip> texasmynsted, it can, but differently
15:31:43 <texasmynsted> how?
15:31:51 <ertesx> > case lookup 5 [(5, "blah")] of Just x -> "yes: " ++ x; Nothing -> "no"
15:31:53 <lambdabot>  "yes: blah"
15:31:57 <ertesx> > case lookup 6 [(5, "blah")] of Just x -> "yes: " ++ x; Nothing -> "no"
15:31:58 <lambdabot>  "no"
15:32:06 <mniip> fix f = let x = f x in x
15:32:08 <qinusty> filtering out bad human input in haskell is quite annoying :/
15:33:04 <texasmynsted> :-)
15:33:19 <ertesx> qinusty: you mean: "having to filter out bad human input in programming is quite annoying, and now i noticed how terrible other languages are for just sweeping the problem under the rug" =)
15:34:01 <ludat> it's just because haskell makes it more strict, in C/Python/whatever you would just explode some other time
15:34:04 <kadoban> qinusty: You get used to it quickly, and yeah there's a little bit of ^
15:34:12 <qinusty> Also, say I have a Map of (String, SomeTupleType). Can I modify a specific value within the list based on it's key. I know I'd have to return a new list all together but....
15:34:41 <mniip> why not use an actual Map
15:35:00 <qinusty> Sorry, let me explain myself better
15:35:10 <qinusty> I have a type 
15:35:11 <qinusty> type Player = (String, (Int, Hand, PlayerState))
15:35:21 <qinusty> type MPGameState = (Deck, Hand, [Player]) 
15:36:08 <Skami> Change MPGameState to (Deck,Hand, Map String (Int, Hand,PlayerState))
15:36:16 <qinusty> Okay
15:36:31 <Skami> It'll probably be faster too
15:36:49 <ertesx> qinusty: first of all, there is no need to work with ugly and error-prone type aliases…  define real types instead:  data Player = Player String Int Hand PlayerState
15:37:02 <ertesx> you can even give those fields names for easier access
15:37:06 <glguy> qinusty: You can't modify the list, but you can make a new list based on the old list where you update the target element in the process of making the new list
15:37:22 <ertesx> data Player = Player { playerName :: String, playerSomething :: Int, playerHand :: Hand, … }
15:37:24 <glguy> where update means you make a new element
15:37:27 <qinusty> glguy: That's what I'm after. I get Immutable things.
15:37:44 <qinusty> I just want it to look clean, which is where my issue lies :P
15:38:29 <Skami> Inserting a new element in a map replaces it if it already exixts
15:38:35 <ertesx> qinusty: however, the player name is probably not intrinsic to the player, so i'd go with Skami's suggestion:  data Player = Player Int Hand PlayerState;  data MGGameState = MPGameState Deck Hand (Map String Player)
15:39:00 <qinusty> Actually while I'm here, anyone want to throw me a bone as to why Data.Text is better than String / [Char]
15:39:10 <Skami> Lists are slow
15:39:29 <qinusty> Okay
15:39:34 <qinusty> And what is Data.Text?
15:39:38 <rmutt> Data.Text does unicode better too i think
15:39:40 <ertesx> qinusty: it's not "better", it's just more appropriate most of the time, if only because it's a lot more compact and (because of that) a lot faster
15:40:03 <hwkng> is there a simple list of exercises for implementing ever more complicated type systems in haskell?
15:40:36 <glguy> Incidentally, Data.Text surprises people with some of its operations. index is O(n), for example
15:41:10 <ertesx> i wonder why it doesn't just use UTF-32
15:42:06 <ertesx> seems weird to make indexing O(n) without going for the most compact representation…  might as well choose the representation that gives O(1) indexing
15:44:17 <qinusty> The serious question is. Do I get into databasing for storing player data ? Or just whack it into a json file
15:44:55 <qinusty> Like I'm loving Haskell and things are becoming more natural as the days go on, however some things still seem a lot more complicated and harder to hack together
15:45:50 <ertesx> qinusty: there are many ways to save state:  acid-state, an online database (like postgresql), a file database (like sqlite) or even something as simple as a JSON file using aeson
15:46:43 <ertesx> each with a set of advantages and caveats
15:46:54 <qinusty> I mean, I'm making an IRC bot which runs blackjack on a set channel. I just need to store balance to a nick
15:47:11 <ertesx> do you care about security?
15:47:27 <qinusty> I'm working on the grounds of get it working -> Then make it work well
15:47:30 <qinusty> right now
15:47:32 <qinusty> so not 100%
15:47:38 <qinusty> I realise people can change nick etc
15:47:57 <ertesx> acid-state is probably the most convenient option
15:48:42 <ertesx> that's an in-memory database with persistent storage with ACID guarantees similar to databases and transactional memory
15:49:00 <qinusty> I'll look into it cheers! 
15:49:26 <ertesx> caveat: it's haskell-only, and you get little control over on-disk format
15:49:32 <qinusty> Ah well
15:49:38 <qinusty> That doesn't matter too much
15:49:53 <qinusty> Its only a project for me to get familiar with Haskell
15:50:06 <qinusty> It started with a simple terminal Blackjack game which I finished the other day
15:50:32 <ertesx> also acid-state has the potential to ruin you for databases =)
15:50:40 <qinusty> ruin me? :P
15:51:04 <srpx> Please refresh my mind in how I install a package in a fresh new Haskell project. I ran `cabal init`, then `stack init`, then added `idris >= 0.12 && < 0.13` to `build-depends`, then created a `Main.hs` file importing Idris, then ran `stack build`. After this, I get an error: "At least the following dependencies are missing: idris ==0.12.*". I was expecting stack to install idris, not complain it is not there. So, am I missing somethin
15:51:45 <ertesx> qinusty: yeah, writing SQL transactions after you used acid-state can be a bit of a pain
15:52:00 <fr33domlover> But there's the "persistent" library
15:52:16 <dgpratt> noobish question: it is possible to reuse a bunch of imports by placing them in a module, correct? how is that done?
15:52:17 <fr33domlover> With it, things are much saner
15:52:27 <qinusty> Ah well ertesx I've used MySQL and I'm gonna be doing a module of Postgres in september so... Should be fun
15:53:01 <ertesx> qinusty: postgresql is very convenient in haskell…  i hear that mysql is also getting some love, but not as much
15:53:07 <dmwit> dgpratt: `module Exports (Foo.Bar, Foo.Baz) where import Foo.Bar; import Foo.Baz`
15:53:11 <Skami> srpx : with cabal I use something like : cabal install --only-dependencies
15:53:15 <ertesx> fr33domlover: never been a big fan of persistent to be honest
15:53:23 <dgpratt> thanks dmwit
15:53:28 <dmwit> dgpratt: ...actually, the export syntax may be `(module Foo.Bar, module Foo.Baz)`.
15:53:40 * hackagebot servant-github 0.1.0.3 - Bindings to GitHub API using servant.  https://hackage.haskell.org/package/servant-github-0.1.0.3 (finlay)
15:53:42 <dgpratt> ok
15:53:47 <fr33domlover> ertesx, what other options are there? (besides esqueleto, which I use too)?
15:53:53 <glguy> srpx: idris-0.12 probably isn't in the stack resolver you're using
15:54:01 <ertesx> fr33domlover: plain postgresql-simple
15:54:13 <glguy> srpx: You'll have to pick a version that is or add that package to your extra-deps section in your stack.yaml
15:54:42 <Skami> glguy: Is stack worth it over plain cabal?
15:55:04 <glguy> Skami: I only use stack for particularly complicated project workspaces, but not as a default
15:55:18 <srpx> glguy: or instead update things, right? It has been a while. What GHC/Stack version do I need to install to have idris-0.12? Where do I find that information?
15:55:31 <Skami> glguy: Ok thanks
15:55:44 <fr33domlover> ertesx, does it have the type safety though? (assuming one is fine with specifically depending on PostgreSQL)
15:55:45 <srpx> My GHC version is 7.10.2, and stack is 0.1.7.0. I assume that is old. Right?
15:56:17 <glguy> srpx: You should update your stack and probably your GHC, but neither is really relevant to getting idris going
15:56:33 <ertesx> fr33domlover: when i write a storage-backed application, i tend to write a storage model first, which is a type class most of the time…  then everything backend-specific is in the postgresql implementation
15:56:34 <kadoban> srpx: That version of stack is pretty old, yeah. 1.1.2 seems to be current.
15:56:49 <ertesx> fr33domlover: it gives you reasonable type safety, but not the level of persistent
15:57:10 <srpx> Okay, could anyone link me to the correct way to update those?
15:57:22 <glguy> srpx: idris-0.12 is neither in stackage's "lts" nor "nightly"
15:57:31 <ertesx> fr33domlover: the advantage of this approach is that i can tune the database a lot with little headache (no need to unwrap abstractions to do it the way i had to with persistent)
15:57:36 <srpx> which one is?
15:57:54 <glguy> srpx: You can browse them at https://www.stackage.org/lts and https://www.stackage.org/nightly
15:58:11 <fr33domlover> ertesx, persistent has rawSql though
15:58:13 <glguy> you can also use packages from hackage with stack, but you have to list them in extra-deps
15:58:59 <ertesx> fr33domlover: if you use views and expression indices, you end up using that all the time
15:59:34 <fr33domlover> ertesx, ah I see. For my use, I rarely need rawSql
15:59:58 <fr33domlover> maybe that's why I enjoy using persistent most of the time :P
16:00:10 <ertesx> fr33domlover: it really just got in my way, partly because it's designed to be backend-agnostic
16:01:10 <ertesx> so it ends up not mapping will to any particular backend, because the lowest common denominator is really really really low =)
16:01:15 <ertesx> s/will/well/
16:03:38 <ertesx> and seriously, i've *never in my life* migrated from one DBMS to another, so i don't care much about backend-agnostic…  the reason why i write a storage model class is that i usually start with an STM-based backend for testing before i go to the on-disk backend
16:04:31 <ertesx> (and because the class is a nice way to document semantics and assumptions)
16:04:44 <ertesx> ok, i'm done =)
16:08:08 <geekosaur> backend agnostic is not necessarily about migrating between backends, so much as letting someone using your program/library integrate with their existing database
16:09:34 <Aruro> data Point = Point Int deriving (Show, Read) , what is the easiest way to make read parse string like "point 5" ? lower case p.
16:10:15 <kadoban> Aruro: Use something other than 'read' in that case I'd say.
16:10:38 <Aruro> i like read for its global scope
16:10:54 <Aruro> im sad it has no generalizations
16:11:19 <geekosaur> so "why isn't a full parser built into the Prelude?"
16:11:25 <mgsloan> srpx: "stack install idris-0.12 --resolver lts-6" finds a build plan
16:11:27 <kadoban> There's not a lot to like at all about read, in general, for serious purposes … you should get to like something else.
16:11:50 <Aruro> kadoban: because its broken, idea is brilliant.
16:11:51 <mgsloan> (or should I say, directly determines a build plan ^_^)
16:11:51 <srpx> mgsloan: hey cool, thanks :) I'm upgrading stack now
16:12:05 <Aruro> geekosaur: so why? :)
16:12:36 <kadoban> Aruro: Idea itself is kinda broken, except for debugging and toys.
16:12:58 <EvanR> except Read outperforms some Binary serializations somehow ;)
16:12:59 <Aruro> kadoban: what is broken about deriving read parser?
16:13:03 <geekosaur> because (a) Prelude belongs to ghc and ghc is not the maintainer of every library someone might happen to want to use (b) the community already voted with its feet to consider batteries-included (the Platform) to be Satan
16:13:06 <ertesx> geekosaur: that's fine with me…  my applications are compatible with any backend that supports the semantics
16:13:47 <kadoban> Aruro: It imposes one particular format on the input that's kinda funky, and the interface is wonky, particularly 'read' being a partial function.
16:14:02 <geekosaur> also the ReadS stuff it's based on is rather low performance
16:14:12 <ertesx> geekosaur: the reason i bring this up is because i don't like "lowest common denominator" designs…  i had much better experience with "application-specific semantics" designs
16:14:16 <Aruro> kadoban: maybe can fix that, and there are tons of situation where funky format is ok
16:14:25 <geekosaur> (if you really insist that it has to be something in Prelude you can use ReadS)(
16:14:49 <EvanR> Aruro: why do you want to lowercase the P ?
16:14:52 <geekosaur> (you'll likely find out why people use real parser libraries, the hard way)
16:14:53 <Aruro> geekosaur: any good tutorial on that?
16:15:02 <Aruro> EvanR: because i want it to be more flexible
16:15:32 <EvanR> like HTML 4 ? ;)
16:15:35 <Aruro> its sad to see how little its missing to become truly useful
16:16:02 <cheater> i have just stumbled upon this: http://david-peter.de/cube-composer/
16:16:21 <Aruro> EvanR: for example it can easily parse (Int,Int,Int) but horribly fails to parse any other separator like : for example.
16:16:35 <EvanR> Aruro: i gave up on the preludes global usefulness, its just missing too much common stuff. i recommend dumping it for your own prelude
16:16:57 <Aruro> EvanR: so you dont use deriving?
16:17:12 <EvanR> deriving ? i thought we were complaining about Read
16:17:14 <geekosaur> actually, scratch that; ReadS is what uses the Read instances, so you're still stuck with what they do unless you newtype everything to heck
16:17:27 <ertesx> Aruro: an easy way out is to use aeson and go to and from JSON
16:17:47 <Aruro> ertesx: yeah, that deriving mechanics seems far more general?
16:18:21 <kadoban> Aruro: What are you actually trying to use it for? Is this for user input? In that case you should probably write an actual parser. If it's not, yeah there's other options.
16:18:26 <ertesx> Aruro: deriving is not the only way to get automatic instances: aeson can compute instances from Generic
16:18:40 <Aruro> kadoban: i want to parse config file, or any structured text input
16:18:48 <glguy> Read is not for parsing arbitrary formats, it's for parsing Haskell sourcecode-like format
16:18:51 <EvanR> parser then
16:19:23 <Aruro> ertesx: yes, i kinda mixed both concepts in same pot
16:19:28 <kadoban> Aruro: JSON would probably be a good choice then, if you're able to choose it and if your users would be okay with it.
16:19:29 <ertesx> Aruro: data MyType = … deriving (Eq, Generic, Ord, Show);  instance FromJSON MyType  -- note that i don't write an instance body…  the actual instance is computed using Generic
16:20:16 <ertesx> Aruro: consider Show to be mostly for debugging and error-reporting, and Read really only for debugging
16:20:19 <Aruro> ertesx: ty, i will look into that
16:20:19 <Koterpillar> YAML > JSON for human editability
16:20:49 <EvanR> data MyType = ... deriving (Generic), then TH to implement everything ever
16:21:24 <ertesx> EvanR: no TH required
16:21:35 <EvanR> well aeson uses it behind the scenes
16:21:46 <EvanR> i was suggesting a mother of all scenes
16:21:50 <ertesx> does it?  i doubt it
16:22:05 <ertesx> there is a legacy TH deriver AFAIK, but the generic stuff shouldn't use it
16:22:07 <glguy> aeson can use either TH or Generics, up to you
16:22:56 <EvanR> hmm right generics and TH are kind of parallel technologies for the same thing
16:23:00 <Aruro> so deriving Read is basically abandoned?
16:23:11 <EvanR> Read is for debugging
16:23:14 <EvanR> like Show
16:23:15 <glguy> Aruro: No, it's fine to derive read, just not to use it for your user-facing configuration language
16:23:15 <ertesx> Aruro: i don't even derive it for most types
16:23:18 <Aruro> as at least mediocre parser
16:24:21 <ertesx> Aruro: only in libraries for user (= programmer) convenience, because deriving Read is surprisingly expensive for GHC
16:24:44 <ertesx> (understandably so, because it has to write a full parser in a terrible combinator language)
16:25:20 <crupizkas_> Hey everyone, can someone please someone help me to understand this little function? How is it working?
16:25:25 <crupizkas_> inSphere xs r = (<= r^2) . sum . map (^2) $ xs
16:25:51 <crupizkas_> this  (<= r^2)
16:25:56 <crupizkas_> and this map (^2) $ xs
16:26:14 <crupizkas_> Why we not write  map (\x -> x^2) $ xs
16:26:19 <Aruro> ertesx: wouldnt it be a great idea to write good read parser for haskell summer of code projects?
16:26:30 <kadoban> crupizkas_: You could, but (^2) is shorter
16:26:38 <glguy> crupizkas_: (^2) is just a few characters shorter than (\x -> x^2) is all
16:26:58 <EvanR> Aruro: i dont think so because of the scope of read, for quick and dirty debugging
16:27:00 <glguy> crupizkas_: also consider that that could be better written as:   sum (map (^2) xs) <= r^2
16:27:34 <ertesx> Aruro: i think Read started as a great idea, but it never really went anywhere
16:27:35 <crupizkas_> ahh so <= r^2 apply to full right part&
16:27:44 <crupizkas_> yeah so cool
16:27:46 <Aruro> EvanR: why just debuggin? data Config = Time Int | Lock Bool etc. deriving Read , seems as ok solution?
16:27:48 <EvanR> it would be like a summer of code to make Show into a pretty printer (because somehow you dont want to download existing pretty printer packages)
16:27:51 <glguy> f . g . h $ x    is    f (g (h x))
16:28:10 <crupizkas_> thanks. Just started learn today. Awesome
16:28:12 <EvanR> (which use generic, which parsers can also do)
16:28:34 <glguy> . has a higher precedence than $, so that groups like this:    (f . g . h) $ x
16:29:29 <ertesx> Aruro: it's easy enough to copy what aeson does and do it for a regular parser library using Generic
16:29:44 <ertesx> Aruro: so if you really need that (you don't very often), you can do it
16:29:58 <ertesx> the reason nobody has done it apparently is that it's probably not that useful =)
16:30:29 <Aruro> ertesx: yea sounds interesting, i think its useful, i dont want to write parser if it can be done for me :)
16:30:49 <EvanR> Aruro: aeson, done
16:31:02 <EvanR> easier, more compatible
16:31:05 <EvanR> more popular
16:31:10 <EvanR> more capable
16:31:15 <Aruro> EvanR: yes, ty :) i liked that part about aseon when i read some tutorial
16:31:38 <ertesx> Aruro: there are at least two conditions on when that would be useful:  1. you want a text parser, 2. you want haskell syntax with all its complexity like fixity
16:31:40 <EvanR> theres also an ini file package i think
16:32:03 <ertesx> 3. you can't just use your haskell compiler for parsing (e.g. an EDSL)
16:32:34 <ertesx> the probability that all three of these are true is so small that you should probably just take aeson and go on =)
16:32:43 <Aruro> :)
16:33:29 <ertesx> if you want haskell syntax, better write an EDSL instead of a text parser
16:33:46 <ertesx> examples:  hakyll, xmonad
16:34:17 <Aruro> RIP read, i go take a look at aeson 
16:34:28 <Aruro> ertesx: how do i interpret EDSL?
16:34:45 <ertesx> Aruro: you know how xmonad is advertised as a "window manager"?
16:34:54 <Aruro> sure
16:35:04 <ertesx> Aruro: in reality it's not a WM, but a library, and your "configuration" is actually a program using that library =)
16:35:16 <Aruro> i see :)
16:35:58 <ertesx> same with hakyll:  it's not a static site generator…  it's a library to write static site generators
16:36:12 <ertesx> same with shake:  it's not a build system…  it's a library to write build systems
16:36:48 <EvanR> fix (a library to write _)
16:37:26 <ertesx> Found hole: _ :: Library
16:39:38 <EvanR> thank Filippo Brunelleschi for limits
16:40:09 <Aruro> fromJSON . toJSON $ ty guys for help
16:40:41 <Welkin> "GameMaker is designed to allow its users to easily develop video games without having to learn a complex programming language such as C++ or Java through its proprietary drag and drop system.[6][7]"
16:40:46 <Welkin> lol
16:41:18 <EvanR> i prefer the free software drag and drop system
16:41:30 <Aruro> :D "proprietary drag and drop" , patent trolls are printing letters
16:41:36 <EvanR> also not haskell
16:41:50 <Koterpillar> you get drag for free, purchase a separate license for dropping
16:42:03 <ertesx> "Haskell is designed to allow its users to easily develop programs without having to learn a complex programming language such as C++ or Java through its amazing abstract-algebraic abstractions."
16:42:28 <Koterpillar> abstract abstractions?
16:42:36 <ertesx> abstract algebra
16:42:37 <EvanR> recursive abstract recursion
16:42:54 <ertesx> amazing (abstract-algebraic) abstractions
16:43:05 <EvanR> algebraic abstraction algebra
16:43:16 <athan> What are some popular alternative compilers other than GHC? So far I
16:43:20 <ertesx> amazing algebra maze
16:43:24 <athan> I've got UHC and JHC on my list
16:43:30 <ertesx> athan: GHCJS =)
16:43:35 <athan> heh ertesx
16:43:50 <Koterpillar> athan: frege?
16:44:02 <kadoban> Frege isn't a haskell compiler I don't think.
16:44:05 <ertesx> athan: jokes aside, there aren't any…  you can probably get hugs to work, but you won't run any modern haskell code on it
16:44:17 <Koterpillar> in my defence, athan missed "haskell" from the question
16:44:26 <kadoban> Hmm, true.
16:44:26 <ertesx> athan: there are haskell compilers, but none of them are "popular" or even "alternative"
16:44:34 <Koterpillar> mu-something?
16:44:43 <Koterpillar> > fix id
16:44:46 <lambdabot>  mueval-core: Time limit exceeded
16:44:53 <Koterpillar> ^^ what's that mueval?
16:45:13 <ertesx> Koterpillar: interactive GHC
16:45:22 <EvanR> ertesx: do we have evidence about hugs working?
16:45:32 <ertesx> EvanR: don't think so
16:45:51 <kadoban> Well, I mean it hasn't changed, I'm sure you can still use it on old code. It's not exactly been updated for anything recent at all though.
16:46:09 <EvanR> is huges written in haskell?
16:46:19 <EvanR> HUGS
16:46:23 <Koterpillar> "Mu Haskell Compiler" which is something quite closed so I can't even find a link
16:46:25 <ertesx> in C i believe
16:46:42 <EvanR> ok, then it still works ;)
16:46:54 <ertesx> EvanR: ok, i have evidence
16:46:59 <ertesx> just installed hugs and it works =)
16:47:12 <dolio> mueval is a wrapper around GHC.
16:47:17 <EvanR> C will probably be supported on arthur C clark monoliths 
16:48:41 <dolio> Hugs is available in fedora's package repos.
16:48:42 * hackagebot test-fixture 0.3.1.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.3.1.0 (lexi_lambda)
16:48:46 <dolio> So I suspect it still works.
16:48:53 <ertesx> it's also available in nixpkgs
16:49:09 <kadoban> Someone should fork GHC and just give it a different name, just so there's another answer to the compiler question, heh.
16:49:13 <kadoban> It'd make the conversation more interesting.
16:49:43 <ertesx> Hugs> :t foldr
16:49:43 <ertesx> foldr :: (a -> b -> b) -> b -> [a] -> b
16:49:45 <ertesx> nostalgia
16:49:55 <ertesx> (not because of Hugs, but because of [])
16:50:04 <EvanR> ikr
16:50:18 <EvanR> throwback
16:50:21 <Koterpillar> purely theoretic interest, can we redefine [] to be a typeclass name?
16:50:46 <ertesx> @let import Prelude ()
16:50:47 <lambdabot>  .L.hs:144:14: Not in scope: type constructor or class ‘Integer’
16:50:47 <lambdabot>  
16:50:47 <lambdabot>  .L.hs:144:23: Not in scope: type constructor or class ‘Double’
16:50:51 <ertesx> @undef
16:50:51 <lambdabot> Undefined.
16:51:00 <ertesx> @let import Prelude hiding ([])
16:51:00 <lambdabot>  Parse failed: Parse error: [
16:51:01 <EvanR> you have to wear tie dye and bell bottoms to appropriately get that type for foldr
16:51:14 <Koterpillar> class [] where traverse :: ...
16:51:49 <ertesx> Koterpillar: try -XNoImplicitPrelude…  i don't see why it wouldn't be possible technically
16:52:54 <Koterpillar> Malformed head of type or class declaration: [a]
16:53:12 <ertesx> perhaps this way:  class [] a
16:53:29 <EvanR> "malformed head" error, hate it when that happens
16:53:40 <Koterpillar> error: Illegal binding of built-in syntax: []
16:53:42 * hackagebot servant-github 0.1.0.4 - Bindings to GitHub API using servant.  https://hackage.haskell.org/package/servant-github-0.1.0.4 (finlay)
16:53:57 <ertesx> Koterpillar: try -XRebindableSyntax (just guessing)
16:54:42 <Koterpillar> does not help for either [x] or [] x
16:54:49 <ertesx> then no =)
16:58:17 <athan> ertesx: IIRC UHC has a different typeclass resolution mechanism, without dictionaries or something
16:58:23 <athan> (actually that might be JHC)
16:58:29 <dolio> That's JHC.
16:58:37 <athan> thanks dolio!
16:58:51 <athan> Also, there's something about existentials in one of them that's different from GHC
16:58:54 <athan> I'm just exploring
16:59:01 <dolio> That one's UHC.
16:59:04 <ertesx> what does it do?  does it instantiate like C++?
17:00:06 <athan> thanks again dolio!
17:01:02 <dolio> JHC passes around a representation of the type, and does case analysis on them.
17:01:31 <dolio> Instances are compiled to big case analysis functions, I imagine. It can do that because it's doing whole program compilation.
17:02:56 <ertesx> i wonder if JHC actually manages to produce faster code than GHC…  hard to imagine
17:04:59 <srpx> "stack install idris-0.12 --resolver lts-6" ... results in ... "Error parsing targets: Specified target version 0.12 for package idris does not match local version 0.1.0.0"
17:05:04 <srpx> Why?
17:06:53 <glguy> srpx: Did you make a local idris.cabal with version 0.1.0.0 in the current directory?
17:07:34 <srpx> ... oh
17:10:42 <hwkng> I am using snap + websockets. I know how to use sendDataMessage. I know about receiveDataMessage. However, how do I handle the following: -- I want to be able to simltaneously wait on (1) the client via receiveDataMessage and (2) getting a notification of some sort from my haskell server side
17:19:04 <Squarism> ertesx, man, right now i im adding a network interface to "what was Hangman"
17:25:53 <hwkng> if I have (a1 :: IO a), (a2 :: IO a) -- is there a way to say "get the first one of the finishes of these two" ?
17:26:10 <Koterpillar> :t race
17:26:11 <lambdabot> Not in scope: ‘race’
17:26:17 <hwkng> so I have two 'waiters' -- one is waiting on one thing, and one is waiting on another
17:26:20 <hwkng> and I wnat the first one that finishes
17:26:33 <Koterpillar> http://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#v:race maybe?
17:26:55 <hwkng> this is part of the core concurrent libraries right?
17:27:42 <Koterpillar> it's in async, if that's what you are asking
17:27:49 <hwkng> weird it does not show up in https://www.haskell.org/hoogle/?hoogle=IO+a+-%3E+IO+b+-%3E+IO+%28Either+a+b%29
17:27:59 <Koterpillar> http://hayoo.fh-wedel.de/?query=IO+a+-%3E+IO+b+-%3E+IO+%28Either+a+b%29
17:28:34 <hwkng> Koterpillar: thanks
17:31:28 <hwkng> Koterpillar: in the context of async, what does it mean when an async is 'cancelled' ?
17:31:43 <Koterpillar> http://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#v:cancel
17:31:45 <Gurkenglas> What's wrong here? http://lpaste.net/8069710646821781504
17:32:19 <Gurkenglas> Appended error.
17:32:26 <hwkng> Koterpillar: touche
17:32:49 <pavonia> Gurkenglas: It tells you
17:33:40 <Gurkenglas> It tells me that I can't make an instance of HasXY for anything that doesn't contain type variables? That doesn't make sense, so I came here.
17:33:48 <geekosaur> Gurkenglas, the Haskell standard only accepts the restricted form that the error message describes. I *think* you can force that here by saying (,,) Int Int
17:34:02 <Koterpillar> no, you have to enable that extension
17:34:06 <geekosaur> and yes, also type vars, so you need FlexibleInstances anyway\
17:34:33 <Koterpillar> without it, you'll only be able to say: instance HasXY (a, b)
17:34:38 <geekosaur> FlexibleInstances is one of the safe extensions
17:34:55 <KaneTW> ry
17:34:58 <KaneTW> whoops
17:39:18 <lpaste> texasmynsted pasted “No title” at http://lpaste.net/4822433153039728640
17:39:51 <texasmynsted> whoa, lpaste automatically pasted in here. Heh
17:40:15 <texasmynsted> I am trying to learn Y combinator and at the same time how to best format haskell code
17:40:31 <texasmynsted> would somebody take a look at this and provide suggestions?
17:41:15 <texasmynsted> I tried guards rather than if than else for factorial.  That did not seem much improved.
17:41:48 <Gurkenglas> Huh, looks like that flexible instance makes passing unannotated (1,2) to things that take HasXY disallowed.
17:42:19 <Gurkenglas> (Because (1, 2) is (Num, Num) and it doesn't know to restrict to (Int, Int) Im guessing)
17:42:51 <Koterpillar> why wouldn't you permit that though?
17:43:08 <Gurkenglas> I would, how do I make it
17:43:18 <Koterpillar> instance (Num a, Num b) => HasXY (a, b) where getxy (x, y) = (fromIntegral x, fromIntegral y)
17:43:26 <Gurkenglas> :t fromIntegral
17:43:27 <lambdabot> (Integral a, Num b) => a -> b
17:43:37 <Koterpillar> > fromIntegral 1 :: Int
17:43:39 <lambdabot>  1
17:43:48 <Gurkenglas> Oh, Integral is a superclass of Num?
17:44:00 <ertesx> Squarism: and now i have to go like: man, you ruined hangman!  it's nothing like it what it used to be!
17:45:24 <Squarism> ertesx, haha
17:45:33 <Gurkenglas> No, its the other way round. why would (1 :: Num) go into fromIntegral? Monomorphism?
17:45:47 <Koterpillar> :t 1
17:45:48 <lambdabot> Num a => a
17:46:18 <Squarism> ertesx, but it now has sexy Elm ui, websockets, STM-Mvar soup threading
17:46:24 <EvanR> Num is a superclass of Integral
17:46:33 <seivan_> Hmm
17:46:42 <seivan_> What part of Parsec states occurences?
17:46:57 <seivan_> 6 occurences f hexDigit
17:47:37 <Gurkenglas> yup works with "instance (Integral a, Integral b) => HasXY (a, b) where getxy (x, y) = (fromIntegral x, fromIntegral y)" works because hax
17:48:08 <EvanR> seivan_: replicateM
17:48:14 <EvanR> :t replicateM
17:48:15 <lambdabot> Monad m => Int -> m a -> m [a]
17:48:17 <Gurkenglas> (Not Num though, in that case it notices the wrong superclass order)
17:48:30 <Koterpillar> so what's the type of 1 in fromIntegral 1?
17:49:15 <EvanR> without further context, Integeer
17:49:37 <seivan_> Also is parserReturn supposed to create a reply with unknownError?
17:50:00 <EvanR> what is the type of parserReturn
17:50:25 <seivan_> EvanR: Can't find replicate here? https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html
17:50:34 <seivan_> parserReturn :: a -> ParsecT s u m a
17:50:38 <EvanR> its in Control.Monad
17:50:46 <Squarism> can you match a contstructor wo stating all it arguments (w/o holes)
17:51:03 <EvanR> then it sounds like parserReturn always succeeds producin that `a' value and cant fail
17:51:09 <EvanR> and consumes no input
17:52:21 <seivan_> EvanR: Yeah but it also creates an unknownError?
17:52:52 <EvanR> really?
17:52:56 <Squarism> w/ or w/o  i mean
17:53:00 <Koterpillar> Squarism: why?
17:53:25 <seivan_> EvanR: Yeah I guess it's the default state.
17:53:40 <Koterpillar> Squarism: case v of (Just _) -> True; _ -> False
17:53:54 <EvanR> seivan_: youll have to link to code
17:54:40 <Squarism> Koterpillar, if your constructor has 5 arguments i feels tedious stating them when they are of no interrest. Even using holes leads to harder to refactor code
17:54:53 <Squarism> Blaha _ _ _ _ _ 
17:55:07 <EvanR> you can make a helper like isBlaha which does that once
17:55:16 <EvanR> or produces another more convenient view
17:55:17 <Koterpillar> Squarism: with some extensions, you can do case v of Blaha@(..)
17:55:19 <Koterpillar> I think
17:55:30 <Squarism> ok
17:56:02 <Koterpillar> RecordWildCards
17:56:11 <Koterpillar> case v of Just{..} -> True
17:56:17 <Squarism> nice
17:56:19 <Koterpillar> https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
17:56:30 <seivan_> parseReturn is also the same as map, right?
17:58:05 <EvanR> probably not
17:58:10 <EvanR> :t return
17:58:11 <lambdabot> Monad m => a -> m a
17:58:14 <EvanR> :t fmap
17:58:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:59:36 <seivan_> You sure?
17:59:42 <seivan_> I would have guessed it has the same function
17:59:46 <EvanR> why?
17:59:51 <seivan_> because it just maps a value and returns it
18:00:04 <EvanR> it doesnt make anything
18:00:08 <EvanR> it doesnt map anything
18:00:29 <EvanR> link to code youre having trouble with if you want
18:01:06 <seivan_> Mostly trying to understand what everything is when porting 
18:01:13 <seivan_> Could have sworn it was a map
18:01:28 <EvanR> did you check the types?
18:02:53 <seivan_> EvanR: https://gist.github.com/seivan/2e289cddb8982e61b417b640e3064f82
18:03:45 * hackagebot heredocs 0.1.3.1 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.3.1 (KatsutoshiItoh)
18:03:52 <EvanR> what is WHATWOULDTHISMETHODBECALLED supposed to do?
18:04:22 <EvanR> theres absolutely no information to base a guess on here
18:04:33 <Squarism> Koterpillar, how do you find extensions in that manner? 
18:04:45 <Squarism> Koterpillar, seems you had no trouble finding it? 
18:04:56 <Koterpillar> Squarism: I remembered that it existed from somewhere
18:05:03 <Squarism> oh ok
18:05:33 <seivan_> EvanR: It's supposed create the object in a closure
18:05:37 <Koterpillar> this works: http://symbolhound.com/?q=%7B..%7D+haskell
18:05:45 <seivan_> EvanR: Which is why I think map would have worked
18:06:02 <Koterpillar> this was my first idea: http://symbolhound.com/?q=%28..%29+haskell
18:06:08 <EvanR> seivan_: if youre just trying to return the $0 value as is, then you dont even need the >>= {..... part at all
18:06:19 <EvanR> extrapolating how it works from haskell
18:06:54 <EvanR> string("0") <|> many1(digit()) is a parser that outputs a string, thats it
18:07:17 <texasmynsted> hmm. my "y combinator" is doing nothing
18:07:22 <seivan_> EvanR: No, they are Characters
18:07:29 <EvanR> string("0") <|> many1(digit()) >>= \s -> return s  does nothing further, thats a monad law
18:07:52 <EvanR> seivan_: many1(digit()) outputs 1 char? i wouldnt think so, neither does string
18:08:09 <seivan_> EvanR: No, several chars
18:08:13 <seivan_> which is why we map them to string.
18:08:28 <EvanR> at this point i suggest asking #swift
18:10:07 <seivan_> EvanR: Yup, it's a collection returned
18:10:14 <seivan_> which is why we map them to a string
18:10:20 <seivan_> How would haskell Parsec do that?
18:10:57 <seivan_> From the looks of it, Parsec also returns [Result] (array of results) could be array of chars?
18:11:04 <EvanR> string returns a String, many1 digit returns a [Char] which is what String is
18:11:31 <Koterpillar> Scala has flatMap; maybe you are confusing that with map?
18:11:34 <dibblego> there is also many :: NonEmpty Char in semigroups iirc
18:12:24 <EvanR> semigroups and Scala probably arent helping right now, seivan_ is attempting to get parsec-swift help in #haskell
18:12:31 <seivan_> Yeah, 
18:12:39 <seivan_> Not sure where else ot find help on parsec to be honest.
18:12:53 <EvanR> maybe #clojure 
18:12:54 <NeverDie> Anyone hiring for Haskell devs?
18:13:18 <seivan_> EvanR: But I appreciate you bringing up that the method might be unecessary and many should output a string
18:13:22 <dibblego> NICTA/course has some exercises that demonstrate concepts in parsec. They are typically done on day 3. Programming in Haskell, Graham Hutton also has some examples iirc.
18:13:36 <EvanR> it shouldnt output a string
18:13:40 <EvanR> it should output a list
18:13:41 <seivan_> EvanR: assume it outputs an array of chars, would the "right" procedure be to map it into a string? 
18:13:48 <seivan_> EvanR: Yup. a list of chars
18:14:10 <EvanR> something like pack <$> many1 digit
18:14:27 <EvanR> assuming String != [Char]
18:14:31 <seivan_> So I am not completly wrong here then
18:14:41 <seivan_> my "method" would be necessary if I wanted to output a string
18:15:02 <EvanR> except >>= \s -> return (f s) is still more verbose than necessary
18:15:09 <seivan_> string("0") <|> many1(digit()) >>= { someMethod(String($0)) }
18:15:26 <seivan_> EvanR: Fair enough, any ideas?
18:15:56 <EvanR> action >>= \x -> return (f x) is the same as fmap f action
18:16:40 <ertesx> Squarism: you don't need to list all fields when matching:  Constr{} matches Constr, ignoring its fields
18:16:59 <texasmynsted> Would somebody help me close the loop on this? I am not understanding Y combinator.  This is surly wrong.   http://lpaste.net/4822433153039728640
18:17:05 <ertesx> Squarism: and this variant doesn't require extensions and doesn't pollute your namespace with identifiers like RecordWildcards does
18:17:24 <texasmynsted> Types seem to be getting in the way
18:17:27 <ertesx> > case Just 3 of Just{} -> "yes"; Nothing{} -> "no"
18:17:28 <lambdabot>  "yes"
18:17:33 <Koterpillar> ertesx: good to know, thanks!
18:18:19 <Squarism> ertesx, thanks!
18:18:37 <texasmynsted> Like if I understand Y combinator I should be able to define that y, then use it in place
18:19:59 <Mateon1> Hello, I'm wondering about the state of graphical libraries in Haskell. I need a basic GUI for my project, but I find that all libraries listed on the wiki are a pain in the ass to install. I've so far tried: GTK, wxHaskell, qtHaskell and HTk. In all of those, something breaks on Windows. (I haven't been able to even install any of them, and the instructions on the wiki are obsolete)
18:20:05 <Mateon1> Is there anything that works, at all?
18:20:15 <Squarism> talking about type tricks. Theres no way to create a type that groups a set of other types? 
18:20:18 <EvanR> texasmynsted: Y combinator as such cant be typed in haskell
18:20:19 <Koterpillar> Mateon1: make it an html server? :)
18:20:25 <EvanR> but it can be encoded into newtypes
18:20:26 <Cale> texasmynsted: That code works for me
18:20:48 <Mateon1> Koterpillar: Honestly Haste/GHCJS is less of a pain in the ass than these libs
18:20:49 <Cale> texasmynsted: Though, that isn't really the Y combinator, it's just another fixpoint combinator using Haskell's recursion.
18:21:06 <Cale> texasmynsted: The actual Y combinator won't typecheck indeed.
18:21:32 <Koterpillar> Mateon1: Gtk is one of the nicest of them but I don't use Windows; it should work fine though, see, e.g. Pidgin
18:21:32 <texasmynsted> The code "works" but it does not seem to do anything that I can tell
18:21:42 <Cale> texasmynsted: hm?
18:21:45 <Mateon1> Koterpillar: On the other hand, browser code has no filesystem, which is essential for my app
18:22:09 <Cale> texasmynsted: If you apply the factorial function to 10, what do you get?
18:22:09 <Koterpillar> Mateon1: no, make it an executable which runs as a web server, locally
18:22:16 <Mateon1> Koterpillar: I've most recently tried GTK, but in order to install the dev packages on windows, you have to use MSYS, since they stopped distributing bundles
18:22:31 <Cale> texasmynsted: You should get 3628800
18:22:32 <Koterpillar> Mateon1: cf. NWjs
18:23:12 <texasmynsted> So there is really no way to create a Y combinator that type checks in Haskell
18:23:22 <Mateon1> But with msys there are some issues while installing the packages. I've painstakingly setup the pkg-config properly, but pango fails to install because "/mingw64/include is a relative path, which makes no sense"
18:23:36 <EvanR> texasmynsted: you can fake it with data types
18:23:57 <Cale> texasmynsted: Well, you can define a fixed point combinator, like you just did
18:24:00 <Koterpillar> Mateon1: as they say, you can either throw your computer out of the window, or vice versa
18:24:03 <texasmynsted> What I mean by does not work is, that all the work that I see being done is via regular recursion.   The y thing just makes things difficult for me to work out type wise
18:24:09 <Cale> texasmynsted: fix f = x where x = f x
18:24:23 <texasmynsted> yes but to what end?
18:24:31 <Cale> I don't understand that question.
18:24:34 <Mateon1> Koterpillar: I'm saving that one
18:24:52 <Cale> It gives you the least-defined fixed point of a function.
18:25:00 <EvanR> fix f = f (fix f) -- :D
18:25:11 <Cale> Yeah, that will also work, but less efficiently.
18:25:17 <mniip> they want an untyped lambda calculus term that would typecheck in haskell
18:25:26 <mniip> (I don't think one exists)
18:25:37 <Cale> One does exist, pretty much
18:25:38 <EvanR> maybe you can use unsafe coerce?
18:25:43 <Cale> Though there's not a whole lot of point to it
18:25:47 <Cale> data Rec a = In { out :: Rec a -> a }
18:25:47 <Cale> y :: (a -> a) -> a
18:25:47 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
18:26:04 <mniip> can you church-encode Rec?
18:26:06 <texasmynsted> I wanted to understand y combinator and do so from haskell.  It seems that this is just added complication. 
18:26:13 <Cale> This is sort of the standard trick for recovering recursion at the value level from recursion at the type leve.
18:26:13 <Cale> l
18:26:48 <texasmynsted> hmm
18:27:10 <Cale> So, given a type Rec a such that the type (Rec a -> a) is isomorphic to Rec a, (via the isomorphisms In and out)
18:27:26 <mniip> 1467163543 [04:25:43] <mniip> can you church-encode Rec?
18:27:40 <Cale> you can insert those isomorphisms into the definition of Y to make it typecheck
18:27:57 <EvanR> mniip: final jeopardy, going with no
18:28:03 <Cale> and this y will actually work, but sometimes it will make GHC's inliner flip out
18:28:05 <EvanR> $1699.99
18:28:07 <texasmynsted> oh this looks like something to try
18:28:19 <texasmynsted> Could learn something by the attempt I think
18:28:29 <Cale> (which is a bug with no intention of ever being fixed, since it only shows up in highly contrived cases like this)
18:28:46 <EvanR> mniip: typed lambda calculus alone cant do the Y combinator
18:28:52 <mniip> yes
18:29:01 <texasmynsted> oh
18:29:07 <mniip> that was the base for my proof
18:29:22 <texasmynsted> I guess this something to try later 
18:29:27 <EvanR> and i was under the impression you need a Mu type or something to encode recursive types
18:29:31 <mniip> you have to either use some features of the haskell syntax, or datatypes that don't have a church encoding
18:29:42 <Cale> The original impetus for adding a type system to the lambda calculus in the first place was to prohibit Y.
18:29:43 <mniip> (features of the haskell syntax = letrec)
18:31:29 <Cale> Church was attempting to define a logic which could be used as a sort of computable foundation of mathematical logic. The original lambda calculus was actually pretty funny-looking compared to what we now think of as the classical untyped lambda calculus -- it had an explicit negation operator, for instance.
18:32:36 <Cale> The Y combinator was a killing blow for the untyped lambda calculus, as (Y not) was a problem.
18:32:59 <Cale> At least, for its use as a sort of logic.
18:33:43 <mniip> EvanR, oh actually
18:33:47 <mniip> church-encoding Rec is no issue
18:33:51 <mniip> it's similar to Identity
18:33:52 <shachaf> Hmm, the whatever encoding for types with negative recursion doesn't work very well in general.
18:34:05 <mniip> it's the typechecking and the occurs check that is the problem
18:34:06 <shachaf> But in thi case it would come out looking something like forall r. ((r -> a) -> r) -> r.
18:35:16 <shachaf> callCC-style.
18:35:57 <shachaf> But of course that's not sufficient for writing Rec.
18:36:25 <mniip> how did you derive that?
18:36:40 <Squarism> ok.. real noob question : Why doesnt these 4 lines compile?
18:36:41 <Squarism> http://lpaste.net/168418
18:37:01 <mniip> because * is a kind
18:37:32 <mniip> (unless you're using a modern GHC with TypeInType in which case it should compile)
18:37:39 <Koterpillar> you want "instance Musk a" but even then you'll have to please GHC with a lot of extensions
18:37:53 <Koterpillar> why do you want them to compile?
18:38:07 <Cale> Squarism: What are you attempting to express here?
18:38:09 <Squarism> really i want a "marker interface"
18:38:21 <dibblego> woah there
18:38:51 <shachaf> Rec A = Fix F, where F = (-> A)
18:39:11 <shachaf> Well, if you think of Nu F = exists x. (x, x -> x -> A), that one doesn't make sense at all.
18:39:57 <Cale> Squarism: I don't understand that
18:40:01 <Squarism> i have a hard time accepting i need to resort to Sum types to group a set of types under one umbrella
18:40:23 <Cale> What's the actual problem that you're trying to solve?
18:40:52 <mniip> does GHC offer an interface for introspecting the metadata of a constructor other than GHC.Generics.Rep?
18:41:09 <Cale> Generally if there are a bunch of things that you want to regard as having the same type for some reason, they must have something in common.
18:41:10 <Squarism> data A = A {.. }, data B = B { ... }, functionTakingAorB :: ? -> Bool
18:41:27 <dibblego> Either A B
18:41:29 <Squarism> but the problem is i have 13 types 
18:41:30 <mniip> which is problematic because I have a type constructor on its own, of whatever kind it is
18:41:45 <Cale> If you can determine what it is that they have in common, and define *that* type, then you can presumably define functions which project out this information from the other types you're working with.
18:41:48 <Koterpillar> Squarism: do you have 13 implementations?
18:41:53 <Squarism> think "Messages types"
18:42:05 <Koterpillar> what's that function? be concrete
18:42:11 <mniip> Squarism, what operations unify these types
18:42:12 <Cale> Squarism: So the problem is that you want to put all the messages in some sort of container?
18:42:25 <Cale> What were you planning on doing with them when you took them out again?
18:42:34 <Cale> Perhaps put *that* in the container instead?
18:42:38 <Squarism> handleMessage SomeState MessageType
18:42:50 <Koterpillar> ^^ description of every OO system ever
18:42:53 <Squarism> handleMessage :: SomeState ->  MessageType -> SomeState
18:43:08 <Cale> So, why isn't the answer to your problem: SomeState -> SomeState?
18:43:14 <mniip> why not put (`handleMessage` msg) in the list
18:43:18 <Squarism> and MessageType should group my 13 datatypes
18:43:38 <Koterpillar> so you really want A -> SomeState -> SomeState, B -> SomeState -> SomeState, C -> SomeState -> SomeState
18:43:44 <Cale> Yep, MessageType = SomeState -> SomeState, handleMessage s f = f s
18:43:47 <mniip> assuming handleMessage is typeclass-polymorphic
18:44:26 <Cale> -- there could indeed be a reason why this is insufficient, but it's the very first thing to think about
18:44:44 <Squarism> ok.. ill see what i can do with your ideas
18:45:22 <Cale> If you need to be able to do other things with values of type MessageType, then you'll have to figure out what all of those are.
18:45:24 <Squarism> MessageType needs to be serializable also
18:45:33 <Cale> Yes, okay, so you need more
18:46:31 <Cale> If it *only* needs to be serialisable and not also deserialisable, then this is trivial:
18:47:06 <Cale> data Message = Message { handle :: SomeState -> SomeState, serialise :: ByteString }
18:47:12 <Squarism> and the values approach is hard.. beacuse some function signatures already use the different "message types"
18:47:40 <Cale> However, deserialisation is going to require some omniscience about the possible things that can be serialised
18:47:54 <Squarism> Cale serializable and deserializable
18:47:56 <Cale> It will need to know about all the cases.
18:48:08 <Cale> (there's basically no way around that)
18:48:46 <ertesx> Squarism: i think, you're still confusing "type" with "kind of object"…  question whether having those 13 types is the solution in the first place, and no, i'm not suggesting that you make one type with 13 constructors
18:48:50 <Cale> So at least for the purposes of serialisation, you're going to end up with 13 different tags
18:49:19 <Cale> It's just that, following this design, those tags will be some initial bit of the ByteString
18:49:43 <Cale> (to be parsed out and used to determine which message parser ought to be used to reconstruct the Message)
18:50:03 <ertesx> Squarism: take inspiration from the game type you invented:  a type in haskell is not strictly a "data type", a container for data, but more like a "behaviour" or a "semantics"
18:50:38 <ertesx> sure some, if not most, types are boring containers for data, but the more interesting types are very different
18:51:18 <Cale> Note that lazy evaluation helps a little bit here -- you don't necessarily pay the cost of computing the serialise field of every Message, if it is never observed.
18:51:21 <Squarism> To make it more concrete... its the *Action types i want to send over the wire ... then deserialize and affect the game state : https://github.com/gurgl/julius-caesar/blob/master/src/Board.hs
18:52:55 <Cale> I sort of think that in this case, you're best off honestly making a type with as many constructors as there are actions, because it means that the code for handling serialisation and deserialisation will complain about incomplete pattern matches if you later add another case.
18:53:18 <Cale> and/or you might be able to automate a lot of it with TH stuff
18:53:25 <Cale> e.g. Aeson's TH stuff
18:54:39 <Cale> You're not just defining a type to be used abstractly, you're also defining a communication protocol, and it sort of has as many cases as it has.
18:54:39 <Squarism> i have got an aeson haskell <-> Elm ser/dersialize functionallity in place. So that part is done
18:55:37 <Squarism> Cale, ok. ill persue that approach
18:55:56 <Cale> But yeah, once you're removed from the need to do that, there's nothing stopping you from defining something more abstract, like just using the function type, or an "object" type with a few function fields.
18:56:16 <Cale> (based on what things you need to be able to do with messages from that point onward)
18:56:46 <Cale> The need to handle all 13 cases doesn't need to propagate through the whole game, that is.
18:57:19 <mniip> does GHC offer an interface for introspecting the metadata of a constructor other than GHC.Generics.Rep?
18:57:19 <Squarism> no ill just pack the 13 cases in a sum type of sorts for the networking part
18:57:25 <Cale> yeah
18:58:01 <Cale> mniip: There's the Data.Data way
18:58:22 <Cale> :t toConstr
18:58:24 <lambdabot> Data a => a -> Constr
18:58:55 <mniip> oh yes, forgot to specify
18:58:58 <mniip> tycon, not datacon
18:59:11 <Cale> TH?
18:59:14 <mniip> no
18:59:21 <mniip> type magick
18:59:27 <mniip> oh
18:59:30 <mniip> you mean that
18:59:34 <Cale> I mean reify
18:59:45 <mniip> can't really use TH in type magick
18:59:59 <Cale> I don't really understand what you want
19:00:02 <mniip> not in the middle of a type family
19:02:19 <mniip> Cale, I'm just exploring the possibilities of type introspection using type families
19:05:14 <tank144> i read this article on monads http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:05:31 <tank144> where does >> come into this?
19:05:57 <Koterpillar> @src (>>)
19:05:57 <lambdabot> m >> k = m >>= \_ -> k
19:06:10 <Koterpillar> tank144: >> is just >>= that ignores the result of the left side
19:06:33 <tank144> so its still bind?
19:06:55 <EvanR> its what happens when you use do notation and dont save the result to a variable
19:07:04 <EvanR> it gets dropped on the floor
19:08:26 <tank144> well m >>= k and bind m k are different aren't they?
19:08:33 <tank144> no i mean
19:08:38 <EvanR> > Just 3 >> Just 'a' >> Just False >> return "complete!"
19:08:40 <lambdabot>  Just "complete!"
19:08:46 <tank144>  m >> k and m >>= k are different
19:08:46 <EvanR> > Just 3 >> Nothing >> Just False >> return "complete!"
19:08:48 <lambdabot>  Nothing
19:08:57 <tank144> ignore the prev
19:09:06 <tank144>  m >> k and m >>= k are different right?
19:09:08 <Cale> tank144: x >> y is the same as x >>= (\r -> y)
19:09:20 <Koterpillar> tank144: m >>= k says: give m's result to k
19:09:30 <Cale> and yes, those are not only different, the k in each has a different type
19:09:37 <Koterpillar> tank144: m >> k says: do m, throw the result away, do k
19:09:58 <EvanR> they are different, you can tell by looking at the type of >> and >>=, the types are different
19:10:02 <Squarism> ertesx, (just feedback on what you said) i understand that.. but in this case i would like to be old school concrete as its networking / threads involved. But i see what you mean from what you learned me
19:10:07 <tank144> also the order of evaluation
19:10:23 <tank144> m >>= k  k gets evaluated and the result goes to m?
19:10:38 <Koterpillar> m >>= k  m gets evaluated and the result goes to k
19:10:44 <tank144> but m >> k the m is evaluated first and then k
19:11:01 <EvanR> ****** m >>= k, the >>= gets evaluated. then something
19:11:10 <Koterpillar> the order of _actions_ is the same; order of evaluation is tricky
19:11:24 <EvanR> (>>=) m k
19:11:29 <EvanR> f x y
19:11:32 <tank144> so m >>= k = bind k m?
19:11:38 <Koterpillar> ^ correct
19:11:47 <Koterpillar> @src bind
19:11:48 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:11:55 <tank144> is that the same as the article?
19:12:16 <Koterpillar> :t (=<<)
19:12:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:12:24 <Koterpillar> you can generally flip them around
19:16:11 <tank144> i read the article wrong
19:16:23 <tank144> it does say that So bind f x is normally written as x >>= f.
19:16:43 <EvanR> `bind' is actually not commonly spelled out like that, its not defined in Control.Monad
19:17:08 <tank144> EvanR, well this is a tutorial
19:18:00 <EvanR> even better, they reversed the arguments when they gave it a name
19:18:08 <EvanR> to be especially clear?
19:18:18 <tank144> so what type does k have in m >> k
19:18:26 <EvanR> :t (>>)
19:18:27 <lambdabot> Monad m => m a -> m b -> m b
19:18:30 <tank144> () -> IO a?
19:18:31 <EvanR> m b
19:19:05 <EvanR> you wouldnt use k probably, instead m1 >> m2
19:19:45 <EvanR> k wouldnt be a handler function when using >>
19:19:57 <tank144> what are you talking about?
19:20:06 <EvanR> about "m >> k"
19:20:54 <tank144> is k's type () -> mb ?
19:21:03 <EvanR> m >>= k, and m >> k might confuse you because the two k's are totally differnent kinds of things
19:21:06 <EvanR> no its not
19:21:23 <tank144> why is it just mb?
19:21:30 <EvanR> the type says so
19:21:34 <EvanR> :t (>>=)
19:21:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:21:36 <EvanR> :t (>>)
19:21:37 <tank144> no i am asking why
19:21:37 <lambdabot> Monad m => m a -> m b -> m b
19:21:48 <EvanR> why is it useful?
19:21:55 <tank144> what?
19:22:01 * EvanR stops
19:22:18 <tank144> why is k's type mb instead of () -> mb?
19:22:21 <Koterpillar> where have you got "() ->" from?
19:22:27 <EvanR> because of the type signature of >>
19:22:30 <tank144> because k is a function isn't it?
19:22:37 <EvanR> nope
19:23:16 <tank144> ok i am lost why is k not a function?
19:23:40 <tank144> your chaining 2 functions using bind usually
19:23:45 <EvanR> nope
19:24:00 <EvanR> > Just 3 >>= \x -> Just (x+1)
19:24:01 <lambdabot>  Just 4
19:24:07 <EvanR> Just 3 isnt a function
19:24:17 <EvanR> > Just 3 >> Just 'x'
19:24:18 <lambdabot>  Just 'x'
19:24:22 <EvanR> Just 'x' isnt a function
19:25:15 <DiCablo> hello guys I am a newbie here since I haven't done any programming before but I am thinking to learn a new programming language I was thinking about to learn haskell so I wonder if there is any good books for newbie programmers that have not done any sort of programming before
19:25:20 <tank144> oh your chaining a object with some context into a function that takes just the object?
19:25:32 <tank144> and passing the context through
19:25:32 <Koterpillar> tank144: that's >>=
19:25:45 <tank144> yes i am talking about bind
19:25:46 <EvanR> tank144: a function that takes the action result, not the object
19:26:30 <tank144> what action result ? are we talking about Just 3 >>= \x -> Just (x+1)
19:26:31 <EvanR> getChar >>= \c -> putStrLn [c]
19:26:41 <zRecursive> DiCablo: <<Real World Haskell>>, <<Learning haskell for great good>>, etc.
19:26:51 <EvanR> > Just 3 >>= \i -> Just (i+1)
19:26:53 <lambdabot>  Just 4
19:27:18 <tank144> Just 4 is the action result?
19:27:24 <EvanR> no, i
19:27:28 <EvanR> i=3
19:27:51 <tank144> thats where is said " oh your chaining a object with some context into a function that takes just the object?"
19:28:02 <tank144> action result = object + context?
19:28:03 <EvanR> the function does not take the object
19:28:15 <EvanR> getChar >>= \c -> putStrLn [c]
19:28:22 <tank144> i*
19:28:23 <EvanR> getChar isnt being passed in here
19:28:54 <tank144> ok now your binding 2 functions
19:29:05 <EvanR> getChar isnt a function
19:29:23 <EvanR> :t getChar
19:29:24 <lambdabot> IO Char
19:29:25 <tank144> i am lost again, why is getChar not a function?
19:29:33 <EvanR> it just isnt
19:29:42 <EvanR> it takes no argument
19:29:42 <dibblego> it is a value of type IO Char, which is not a function
19:29:46 <Ralith> values that have type a -> b for some a and b are functions
19:29:50 <Ralith> no other values are functions
19:30:02 <tank144> why isn't getChar () -> IO Char?
19:30:12 <dibblego> () is redundant
19:30:20 <EvanR> its better the way it is
19:30:50 <EvanR> IO Char is the type of a program you can give to some machine which will wait for a keystroke and then return the Char typed
19:30:53 <tank144> dibblego, well every function has 1 input and 1 output so if getChar was a function then it would have type () -> IO Char
19:30:58 <dibblego> () -> x is the same as x to the power of 1, which is x
19:31:04 <EvanR> you can also put it in a data structure or a closure
19:31:08 <dibblego> tank144: correct, so it's not a function
19:31:32 <tank144> dibblego, but why? why is it just a type?
19:31:39 <dibblego> it's not a type, it's a value
19:31:39 <tank144> a value of type IO char
19:31:41 <EvanR> evaluating function applications in haskell doesnt cause side effects
19:31:44 <dibblego> the type of that value is IO Char
19:31:54 <tank144> dibblego, but why? why is it just a value?
19:32:05 <Ralith> for the same reason that "foo" is just a value.
19:32:08 <dibblego> what else might it be?
19:32:23 <EvanR> tank144: why should it be a function?
19:32:31 <Ralith> it's a value because the spec says it is
19:32:32 <dibblego> it's simply impractical/redundant to start putting () value in function argument position
19:32:32 <tank144> well like i said why isn't it a function that takes no input and produces a value of type IO CHar
19:32:49 <EvanR> its not, why do you think it is?
19:32:50 <tank144> getChar :: () -> IO Char
19:32:54 <dibblego> do you want to start writing (\() -> 2) + (\() + 2) to get () -> 4?
19:32:58 <EvanR> why do you want it to be like that
19:33:10 <Ralith> any value of type () -> IO Char can be converted into a value of type IO Char for free, and is more convenient to work with in that form
19:33:15 <dibblego> all functions take one input, like you said, so "a function that takes no input" is not a thing
19:33:40 <EvanR> tank144: if you applied a () -> IO Char to a () value, it wouldnt do anything, its a pure function
19:33:47 * hackagebot Delta-Lambda 0.2.0.0 - A demonstration interpreter for type system delta-lambda (of N.G. De-bruijn)  https://hackage.haskell.org/package/Delta-Lambda-0.2.0.0 (listofoptions)
19:33:51 <tank144> dibblego, so its why would you have to type (\() -> 2) + (\() + 2) to get () -> 4?
19:34:05 <tank144> dibblego, why would you have to type (\() -> 2) + (\() + 2) to get () -> 4?
19:34:09 <dibblego> tank144: because that would be impractical, it would serve no benefit
19:34:30 <dibblego> for the same reason getChar :: () -> IO Char would be impractical.
19:34:47 <EvanR> saying its impractical is not getting at tank144's source of confusion
19:34:53 <tank144> what? no i am saying why not just type 2 + 2 = 4
19:34:55 <EvanR> which could be a variety of reasons
19:34:57 <tank144> to get 4
19:35:00 <parsnipM_> i have an image of several folds, scans and mapaccums, but i can't find the website where i downloaded it from
19:35:12 <dibblego> tank144: exactly, so why not type getChar instead of (\() -> getChar)
19:35:23 <dibblego> EvanR: socratic
19:35:26 <tank144> because getChar is not like 2
19:35:32 <dibblego> Yes. It very is.
19:35:36 <EvanR> dibblego: this is not getting anywhere
19:35:42 <dibblego> EvanR: Yes. It very is.
19:36:05 <tank144> no its not like 2 because for one thing the value getChar returns can be different every time
19:36:20 <Ralith> tank144: the value of getChar is the same every time, just like the value of 2 is the same every time.
19:36:27 <dibblego> tank144: It's exactly like 2, because getChar is the same value every time.
19:36:38 <EvanR> confirmed
19:36:40 <tank144> no the type is same every time
19:36:49 <EvanR> > getChar
19:36:49 <dibblego> tank144: the same value, every time
19:36:50 <lambdabot>  <IO Char>
19:36:51 <EvanR> > getChar
19:36:52 <lambdabot>  <IO Char>
19:36:53 <tank144> the value can be 'a' and then 'b' next time
19:36:59 <EvanR> its ^ every time
19:37:02 <parsnipM_> ah, made by Cale Gibbard, i think i found a sufficient version for my purpose
19:37:04 <tank144> no the type is same every time
19:37:09 <tank144> not the value
19:37:16 <EvanR> hehe, the value is the same every time too
19:37:22 <tank144> IO Char is a type
19:37:22 <EvanR> confirmed
19:37:32 <Cale> parsnipM_: http://cale.yi.org/share/Folds.svg ?
19:37:36 <dibblego> tank144: the value is the same every time and you can confirm this by replacing that value, or an expression containing that value, with another value assigned, and observe that the program has not changed.
19:37:53 <tank144> IO Char is a type is it not?
19:37:53 <dibblego> Yes. The value is the same every time.
19:37:58 <dibblego> Yes, IO Char is a type.
19:38:04 <dibblego> it is the type of the value, getChar
19:38:14 <tank144> ok so the type is same every time
19:38:18 <dibblego> as is the value
19:38:24 <tank144> like 2 is a Int everytime
19:38:30 <EvanR> the type and value are the same... every time
19:38:34 <dibblego> and getChar is a IO Char every time, the same IO Char I might add
19:38:36 <tank144> but unlike 2 getChar can be 'a' and then 'b'
19:38:40 <tank144> the value changes
19:38:40 <dibblego> No, it can't
19:38:41 <Cale> getChar is the same value of type IO Char every type
19:38:47 <Cale> every time*
19:38:54 <Ralith> tank144: 'a' is a value of type Char, not IO Char.
19:38:54 <EvanR> tank144: 'a' cant equal getChar, they have different types
19:38:57 <Cale> It's a description of how to get a character on input
19:39:18 <dibblego> 'a' :: Char, getChar has a completely different type. Emphasis on the adverb, completely.
19:39:19 <EvanR> the program ls cant equal a list of files
19:39:25 <Cale> getChar doesn't contain a Char any more than /bin/ls contains a list of the files in your home directory
19:39:33 <tank144> but unlike 2 getChar can be ('a', Context1) and then ('b', Context2)
19:39:47 <dibblego> No. It can't. Try to unify this in a program and observe a type-error.
19:39:57 <Cale> (if you stretch your definition of "contain" far enough, perhaps it could be the case for both, but it would happen with the same amount of stretching)
19:40:06 <EvanR> try to slow down long enough to give tank144 time to think
19:40:23 <Cale> tank144: You can regard IO as being defined something similar to:
19:40:25 <dibblego> code needs to be written at this point, we do it in NICTA/course
19:40:29 <dibblego> getChar is not a suitable example
19:40:34 <dibblego> readFile is a better example
19:40:43 <Cale> data IO a = Return a | GetChar (Char -> IO a) | PutChar Char (IO a) | ...
19:41:00 <Cale> where each constructor determines some first step to take
19:41:04 <dibblego> 1. replace expressions with values 2. observe no program difference 3. Conclude, it's the same value, every time
19:41:08 <tank144> dibblego, so if getChar appears twice in a expression, both of those will have ('a', Context1) ?
19:41:19 <Cale> and also the action to be performed next (perhaps as a function of the result of that first action)
19:41:19 <tank144> so it gets user input only once?
19:41:27 <dibblego> tank144: no, as earlier, it *never* has that; it's a type-error
19:41:33 <EvanR> getChar != ('a', anything) anything
19:41:38 <Cale> So then getChar would be defined something like  getChar = GetChar (\c -> Return c)
19:41:59 <dibblego> Free monad, as Cale is describing, is another good way to come to terms with this
19:42:02 <Cale> this is simply a piece of data describing something to be done
19:42:05 <tank144> dibblego, so if getChar appears twice in a expression, it will only get user input once?
19:42:08 <Cale> It doesn't have a character in it
19:42:23 <dibblego> tank144: maybe, that's not the point. The point is, is it the same value?
19:42:34 <tank144> what do you mean maybe?
19:42:35 <Cale> tank144: The number of times you get a character has nothing to do with how many times it occurs in the expression.
19:42:43 <dibblego> The answer is, Yes, it is. Construct an experiment to attempt to falsify this (and fail).
19:42:48 <Cale> tank144: Expression evaluation never causes IO actions to occur.
19:42:56 <dibblego> > const 7 getChar
19:42:58 <lambdabot>  7
19:43:01 <Cale> (it just determines which IO action you have)
19:43:02 <dibblego> that asked me zero times
19:43:07 <dibblego> > const 7 (getChar >> getChar)
19:43:08 <lambdabot>  7
19:43:10 <dibblego> still, zero times
19:43:13 <EvanR> > const getChar getChar
19:43:14 <lambdabot>  <IO Char>
19:43:25 <tank144> thats because your not using the value of getChar
19:43:36 <Cale> That also asked 0 times, but resulted in an IO action which if it were executed, would ask once.
19:43:46 <dibblego> > const 7 (getChar >>= \useit -> getChar)
19:43:47 <lambdabot>  7
19:44:08 <tank144> ffs your still not using it
19:44:09 <Cale> tank144: Did you read what I said above? Perhaps you missed it, but I think it's helpful.
19:44:15 <dibblego> define "use it"
19:44:25 <Cale> You should think of IO as being defined something like this: data IO a = Return a | GetChar (Char -> IO a) | PutChar Char (IO a) | ...
19:44:30 <tank144> try printing out getChar's value
19:44:33 <EvanR> no, dont define it. everyone let him rest for a minute
19:44:38 <Cale> > show getChar
19:44:40 <lambdabot>  "<IO Char>"
19:44:41 <dibblego> show the program that demonstrates the thesis, even if that thesis is incorrect (getChar is a different value), to observe why it is incorrect
19:44:46 <EvanR> repeating everything he already ignored isnt helping
19:45:10 <tank144> EvanR, theres a difference between ignoring and not understanding
19:45:25 <EvanR> youve ignored pretty much everything after "getChar is not a function"
19:45:31 <tank144> no
19:45:34 <dibblego> Please stop.
19:45:48 <EvanR> agreed!
19:45:53 <tank144> i have read it and not understood why
19:45:59 <Cale> Let me explain :)
19:46:17 <tank144> omg i am asking why and your asking me to explain
19:46:19 <dibblego> tank144: try to best construct your understanding, so that any misunderstanding can be filled.
19:47:15 <Cale> tank144: So, IO actions are values which describe stuff to be done. Evaluation, the process of turning expressions into values for the purposes of pattern matching, doesn't cause the things described by IO actions to occur.
19:47:19 <tank144> as i understand it, if i tried to print the value you get from getChar, it would evaluate getChar and ask for user input
19:47:36 <Cale> Evaluating getChar doesn't cause any user-visible I/O to occur.
19:47:45 <dibblego> just to be clear, "the value from getChar" has the type IO Char, and cannot be printed
19:47:47 <Cale> It merely warms up your CPU ever so slightly
19:48:08 <Cale> while putting getChar into some sort of internal normal form which we can't really say what it is, since IO is an abstract type
19:48:27 <tank144> does getChar get user input at any point?
19:48:29 <Cale> I was going to define IO as a concrete data type so that we could perhaps observe what evaluation would do in some cases
19:48:42 <Cale> *Execution* is a process separate from evaluation
19:48:47 * hackagebot LambdaCalculator 0.2 - A basic lambda calculator with beta reduction and a REPL  https://hackage.haskell.org/package/LambdaCalculator-0.2 (ThomasDuBuisson)
19:48:57 <Cale> Executing getChar will cause a character to be read from the terminal
19:49:09 <Cale> and the result of that action will be a value of type Char
19:49:28 <Cale> In a compiled program, there is a sense in which main is the only action which is ever executed.
19:49:38 <Cale> in turn, it will be built up from many other IO actions though
19:49:43 <tank144> Cale, the result of the action is a value of type IO Char?
19:49:46 <tank144> not char?
19:49:49 <Cale> No
19:49:58 <Cale> getChar is itself a value of type IO Char
19:50:05 <Cale> the result of executing it will be a Char
19:50:32 <Cale> In general, if x :: IO t, then the result of executing x will have type t
19:50:39 <tank144> so your telling me if i try to print a getChar it does nothing?
19:50:53 <dibblego> λ> print getChar
19:50:55 <Cale> Well, there isn't even by default a Show instance for IO to let you do that
19:50:59 <dibblego> No instance for (Show (IO Char)) arising from a use of print
19:51:35 <Cale> However, even if you were to write one, evaluating the String (show getChar) couldn't possibly cause any execution to occur
19:51:38 <tank144> well i am completly lost then
19:51:41 <Cale> and in particular it won't cause a Char to be read
19:51:54 <Cale> Evaluation never causes execution to occur
19:52:06 <Cale> However, execution may result in some evaluation occurring.
19:52:08 <geekosaur> getChar is a pointer to a program that tells the runtime to read a character. We manipulate these programs by chaining them together with >>=, and ultimately the chain that is produced by (main :: IO a) is what the runtime does
19:52:10 <dibblego> I have coached hundreds out of this situation, and there are various ways of doing it, all involving writing code. Once I wrote the free monad in C# to do so,.
19:52:23 <Cale> heh
19:52:39 <Cale> dibblego: That's got to be some pretty interesting code
19:52:44 <tank144> dibblego, at what point would it be forced to start executing stuff?
19:52:53 <tank144> instead of doing nothing
19:53:00 <EvanR> :exec main
19:53:21 <Cale> tank144: In a compiled program, the first (only?) thing which happens is that main is executed
19:53:27 <dibblego> Cale: https://gist.github.com/tonymorris/7817335
19:53:30 <tank144> right so you put main = getChar >>= println
19:53:44 <Cale> tank144: In turn, main will generally be built up from many other IO actions
19:53:48 <EvanR> which doesnt print the getChar, it prints the Char result
19:54:01 <dibblego> it creates another IO value
19:54:04 <tank144> EvanR, right which is what i want
19:54:05 <Cale> and in order to decide what IO action main is, the executor will have to evaluate main too
19:54:11 <dibblego> it doesn't print anything
19:54:15 <Cale> (so that it can pattern match and work out which action it is)
19:54:17 <tank144> i want to print the user input not IO Char
19:54:18 <EvanR> right so you need to use >>= to use any results from actions
19:54:26 <EvanR> but youre not passing the action itself into the function
19:54:38 <dibblego> printing only occurs under interpreting or "execution" as Cale is using. We programmers do not access that interpreter, we only invoke it.
19:54:56 <tank144> i want to print the user input not IO Char, what would that look like if  main = getChar >>= println does nothing
19:54:56 <Cale> tank144: So, yeah, x >>= f means the action which, when executed, will first execute x, getting some result v, and then it will execute (f v)
19:55:10 <dibblego> it creates a IO (), that's not nothing
19:55:17 <EvanR> "getUserInput();" >>= printLn does not print "getUserInput();"
19:55:18 <Cale> So in this case,  getChar >>= putChar
19:55:36 <Cale> will first get a Char from the terminal, and then it will print it back out
19:55:43 <Cale> :t putChar
19:55:45 <lambdabot> Char -> IO ()
19:55:48 <Cale> :t getChar
19:55:50 <lambdabot> IO Char
19:56:26 <Cale> tank144: *evaluating* main won't do anything too interesting or noticeable
19:56:38 <Cale> tank144: but *executing* main will cause the described effects to take place
19:56:40 <tank144> Cale, please no
19:56:58 <tank144> your just confusing me more
19:57:02 <Cale> It is vitally important to understanding this to separate these two ideas
19:57:12 <dibblego> pick a language, write an example using the free monad
19:57:17 <tank144> yes main gets evaluated first and then executed?
19:57:17 <glguy> tank144: It's the difference between making a todo list and doing the items on your todo list
19:57:24 <EvanR> first class actions like this is actually a really good idea to have in your toolbelt, in any language
19:57:47 <tank144> yes main gets evaluated first and then executed?
19:57:58 <Cale> There is a difference between evaluation, which determines the values of expressions and which has no user-visible effects at all
19:58:05 <EvanR> main gets evaluated enough to begin
19:58:05 <Cale> and execution, which can do anything your computer can do
19:58:17 <EvanR> its lazy like that
19:58:26 <tank144> yes main gets evaluated first and then executed???
19:58:27 <dibblego> time to write some code imo
19:58:44 <EvanR> tank144: not completely, but enough to get the first IO action in the chain
19:58:48 <Cale> Yeah, main will get evaluated -- just enough to determine what's the first action to take, and that action will be taken, and things will proceed from there
19:59:00 <tank144> it gets evaluated, sees theres a IO action in there, which gets executed?
19:59:22 <Cale> It doesn't have to see that there's an IO action, main is required to be one.
19:59:30 <tank144> right
19:59:33 <Cale> But it'll see which
19:59:42 <tank144> main has type IO()?
19:59:58 <Cale> It can have type IO t for any particular t you like (the result is ignored)
20:00:13 <Cale> but yeah IO () works
20:00:59 <Cale> Have you seen the state monad before?
20:01:15 <tank144> yeah
20:01:27 <tank144> dibblego, i think code would help
20:01:36 <dibblego> pick a language
20:01:38 <Cale> I want to present a somewhat unusual version of the state monad which will help understanding IO
20:01:49 <tank144> what does the code look like if you want to print user input
20:01:49 <dibblego> go with Cale for now
20:02:01 <tank144> C? it has the simplest syntax
20:02:05 <dibblego> you can emulate IO in just about any reasonable programming language
20:02:22 <dibblego> one which has sums, or can simulate them without too much problem (not C)
20:02:51 <tank144> well C would be the easiest for me to understand
20:02:58 <EvanR> haha
20:03:00 <tank144> C++, java, javscript
20:03:03 <EvanR> use javascript
20:03:04 <tank144> python
20:03:07 <monochrom> but C doesn't have the suitable semantics
20:03:11 <tank144> sure javascript
20:03:14 <Cale> tank144: The idea we're going to use is that every action of type State s a either just returns some value of type a immediately, or it reads the current state of type s, and then does some other State s a action based on the value of type s
20:03:16 <dibblego> I have written IO in java before.
20:03:17 <Cale> or
20:03:19 <monochrom> syntax is a lie without semantics.
20:03:28 <Cale> it sets the current state to some particular value of type s
20:03:35 <dibblego> follow Cale for now
20:03:40 <Cale> tank144: So we can represent these three cases like this:
20:04:00 <Cale> data State s a = Return a | Get (s -> State s a) | Put s (State s a)
20:04:42 <Cale> Usually the representation of the State monad is designed to make runState trivial to implement
20:05:00 <tank144> wait we are doing it here?
20:05:22 <Cale> But here runState :: State s a -> s -> (s,a) is going to be a little more involved than usual
20:05:51 <Cale> However, there are advantages to a representation like this -- we're going to understand IO as being kind of like this in a moment
20:06:12 <Cale> Does it make sense how the data type works here?
20:06:39 <Cale> The Get constructor is applied to a function of the state of type s that we obtain, to say what ought to be done next, depending on what the state was.
20:06:43 <tank144> Cale, https://jsfiddle.net/#&togetherjs=itTQK1Q8SC
20:07:53 <Cale> If it makes at least a little sense, we'll write runState, and hopefully it'll become totally clear
20:09:10 <Cale> nope
20:09:21 <Cale> runState is analogous to the thing which is going to execute main, perhaps
20:09:32 <tank144> ok
20:09:34 <Cale> However, unlike that, it doesn't need to carry out any real effects
20:09:53 <Cale> It only needs to keep track of what the current state is (in the parameter to runState)
20:10:06 <Cale> and determine, from the action, and the initial state
20:10:11 <Cale> what the final state and result should be
20:10:47 <Cale> So (Return v) is supposed to be an action that doesn't affect the state, and merely produces v as the result
20:11:04 <Cale> hence, if the initial state is s, then the final state will be as well in that case
20:11:05 <Squarism> I thought this guide took me over the IO Monad mystery/paradigm. Even if i heard its lie/non-fair. https://wiki.haskell.org/IO_inside 
20:11:14 <Cale> and the result will be v of course
20:11:27 <Cale> So we have  runState (Return v) s = (s, v)
20:12:06 <Cale> Now, let's try Get --
20:12:12 <Cale> runState (Get f) s = ...
20:12:15 <Cale> here, we have
20:12:23 <Cale> f :: s -> State s a
20:12:26 <Cale> and s :: s
20:12:42 <Cale> and we need to produce the final state and result of executing this action
20:13:07 <tank144> is return the javascript return or haskell return?
20:13:12 <Cale> Well, the idea is that we take the current state, and apply the function to it to determine what to do
20:13:21 <Cale> It's actually neither in this case
20:13:29 <Cale> It's a constructor of the data type we defined
20:13:34 <Cale> Note the uppercase R
20:13:49 <tank144> i thought we were going to write this is javascript
20:13:52 <Cale> no
20:13:54 <monochrom> yeah, we haven't done the lowercase "return" yet
20:14:00 <Cale> I never had any intention of writing javascript
20:14:10 <tank144> or in another language
20:14:20 <monochrom> javascript also doesn't have the suitable semantics.
20:14:31 <Cale> If you want to write some javascript, someone else would be better for that, but I'd be happy to explain this to you by writing Haskell.
20:14:39 <Cale> I think writing this in any other language will just be a headache
20:14:54 <Cale> and even if you kind of understand it, translating it back into Haskell will be even more of a headache
20:15:05 <tank144> well writing it in haskell isn't helping to understand haskell in the first place
20:15:12 <monochrom> even writing this in any of the ML family will require jumping through hoops
20:15:25 <Cale> Well, ask questions if the meaning of anything we're doing is not clear
20:15:32 <tank144> whats return
20:15:42 <Cale> In general, or in our case here?
20:15:50 <dibblego> I can't find a java version, so I will write it in a bit, even if just for fun.
20:16:02 <tank144> in general? no in the case your explaining
20:16:15 <Cale> Okay, so we have a data type with three data constructors
20:16:21 <Cale> data State s a = Return a | Get (s -> State s a) | Put s (State s a)
20:16:40 <EvanR> tank144: are you struggling to understand IO and monads at the same time, without first understand the more basic aspects of haskell via tutorials or exercises? all functions are pure, what does that mean? expressions are evaluated lazily, what does that mean? etc
20:16:44 <Cale> If you're not familiar with this syntax, this is a crazy first example to get started on
20:16:58 <EvanR> all data is immutable, what does this mean
20:16:59 <Cale> Maybe we should look at other examples of data types in Haskell if you haven't seen data declarations before
20:17:10 <tank144> EvanR, no i know the basics
20:17:12 <EvanR> algebraic data types, how does this work
20:17:33 <tank144> pure as in the function always returns the same output for the same input
20:17:34 <EvanR> tank144: in that case, i recommend learning about Functors next and forget monads for now
20:17:34 <Cale> tank144:  data Tree a = Tip | Branch a (Tree a) (Tree a) -- is it totally clear how this defines a type of binary trees?
20:17:43 <tank144> and the function has no sideeffects
20:17:59 <Cale> tank144: ?
20:18:01 <monochrom> dibblego: will you use exception catching for pattern matching? XD  http://www.vex.net/~trebla/humour/Nightmare.java
20:18:18 <Squarism> IO a :: (RealWorld) -> (a, RealWorld) , made it click for me. 
20:18:28 <EvanR> i was looking for that java snippet...
20:18:36 <EvanR> Squarism: oh god no
20:18:39 <Squarism> haha
20:18:39 <Cale> Squarism: I don't like that attempt at a model, because there is no type RealWorld that will make it work.
20:19:13 <Cale> Squarism: But there are perfectly good ways to define an IO type directly that would work
20:19:26 <Cale> Squarism: I'm going to introduce a way, after this State monad example.
20:19:39 <dibblego> monochrom: lol no, a different trick
20:20:04 <Cale> tank144: Still here?
20:20:07 <tank144> yeah
20:20:16 <tank144> data Tree a = Tip | Branch a (Tree a) (Tree a)
20:20:25 <Cale> question about that?
20:20:53 <tank144> i thought i understood that but maybe not
20:21:02 <tank144> like i thought i understood monads
20:21:20 <Cale> So, this defines a new (parametric) type, Tree, such that every value of type Tree a is either Tip, the empty tree, or it is of the form Branch x l r, where x is a value of type a, and l and r are other values of type Tree a
20:21:21 <EvanR> to understand monads you must first understand functors, for several reasons
20:21:25 <Cale> (the left and right subtrees)
20:21:35 <dibblego> understanding IO and understanding monads are two, separate, unrelated, activities
20:21:48 <EvanR> yes and all of the above have not much to do with IO
20:22:41 <Cale> tank144: Maybe, just to avoid having too many interspersed comments which will make this presentation harder to follow, we should go to #haskell-overflow or something.
20:23:10 <Cale> I'll leave it up to you :)
20:23:16 <tank144> whats haskell overflow?
20:23:22 <Cale> Just another IRC channel
20:23:26 <tank144> oh like stack overflow? ok
20:23:29 <Cale> no
20:23:37 <Cale> It's just... overflow discussions from #haskell
20:24:18 <tank144> Cale, yeah i am there
20:24:36 <Squarism> Well before understansding the point of monads it atleast says: 1, this function takes something more as input. 2. And learning you can only get a new copy of a RealWorld by transforming another, it atleast sold me the concept. 3. Then you are learn that monads can accomplish it all. 
20:24:56 <Squarism> Then you can learn ...
20:26:24 <EvanR> Squarism: thats sort of a poor mans State monad
20:26:35 <texasmynsted> I think if you take things to too much of a tangent you will get suggested to go to haskell overflow
20:26:42 <EvanR> and this isnt really what IO is about
20:26:52 <benzrf> Squarism: RealWorld is a cheap hack and it has little to do with how IO is done
20:27:15 <EvanR> haskell-tangential
20:27:51 <texasmynsted> ha
20:27:57 <monochrom> RealWorld -> (a, RealWorld) is a respectable monad. However, it doesn't do anything interesting, for the critical thinkers.
20:28:44 <monochrom> especially if you define it by "data RealWorld = RealWorld" which is even more useless than Proxy.
20:29:01 <monochrom> (and how else could you possibly define it anyway?)
20:29:04 <EvanR> if RealWorld is totally abstract, what can you hope to accomplish with it
20:29:48 <EvanR> if its (), then...
20:30:06 <EvanR> thats not enlightening
20:30:18 <dibblego> (a * 1) ^ 1
20:30:47 <Squarism> monochrom, sure.. but it can be a good way illustrating the idea. Instead of jumping directly into bind/applicative/pure to write "hello world". 
20:30:56 <EvanR> which idea?
20:31:01 <Squarism> IO 
20:31:22 <EvanR> that would imply the idea of IO is RealWorld -> (a, RealWorld)
20:33:21 <EvanR> that must have originated from an ancient person showing up and consider IO and state being part of the same bag of ideas that haskell is weird about
20:33:40 <monochrom> I have a strong opinion that will likely offend you greatly, so I will just say it once and drop the topic. The RealWorld story is at the level of the Tooth Fairy story for getting a dentist-fearing person to feel comfort and understanding.
20:33:57 <EvanR> so might as well try to explain it all at once
20:34:29 <monochrom> On some night I may simply get drunk and go delete that article altogether.
20:35:00 <EvanR> oh, you wrote the RealWorld article??
20:35:04 <monochrom> No.
20:35:05 <EvanR> i remember that one
20:35:11 <Squarism> Ok.. i feel i have no right saying whats right and wrong. But my understanding was that modelling IO as a Monad was to make explicit state transitions. But i am a noob so dont listen to me.
20:36:23 <monochrom> yeah EvanR, the IO_inside article on haskell wiki
20:36:52 <monochrom> And I have just thought up a much better idea. I'll get drunk and s/RealWorld/SantaClaus/
20:37:17 <EvanR> oh its an article about ghc
20:38:48 <monochrom> Santa Claus is how you explain why a non-deterministically chosen gift appears overnight. And so Real World^W^W Santa Claus is how you explain why getChar gives you a Char that I will enter tomorrow so even I don't know which Char it will be so why would Santa Claus be a container that has it.
20:38:53 <Squarism> well thanks anyway. Even if im apparently missinformed. It worked for me as accepting the concept. =D
20:40:29 <EvanR> i wonder if everything can be reworded to arise from the ghostly effects of state, sort of like the container craze
20:41:17 <athan> lambda fight 2016 GO! Which is better, `do _ <- foo` or `() <$ foo`?
20:42:35 <monochrom> neither. I have a better idea. which is better, "void foo" or "foo"?
20:42:58 <EvanR> foo, with the corresponding consumer polymorphic 
20:43:25 <monochrom> also where is the lambda in either "do _ <- foo" or "() <$ foo"?
20:43:38 <monochrom> shouldn't it be "foo fight 2016"?
20:44:55 <athan> fooey
20:55:04 <dibblego> Squarism: it is an analogy that is limited in how helpful it is, because it is inaccurate, and the consequences of that inaccuracy manifest very early on.
21:01:09 <angerman> Say I have some TrasT (StateT s m a0) a1, is there an easy way to run the eval the stateT and obtain TransT m0 a1?
21:02:16 <glguy> angerman: That would depend on what TrasT and TransT are, and you probably havea kind error in your example after fixing spelling
21:03:36 <angerman> glguy umg. right. They are the same.
21:03:44 <Squarism> dibblego, i cannot object to that cause i dont know the finer print. For me it was a way to get on with things. I atleast felt i could see the purpose of using a monad for IO. Not fair/false - may be. Im sure, now that im alot more invested in the eco system, I will take the time and have the motivation in understanding the underlying mechanism of IO in haskell.
21:04:37 <Koterpillar> angerman: is TransT a monad? then use fmap runStateT
21:05:13 <angerman> Koterpillar can it really be that simple, and I just failed so badly? Yuck.
21:05:17 <angerman> I'll give that a shot.
21:05:33 <glguy> Koterpillar: No, that won't work, that would work if he had TransT _ (StateT s m a)
21:06:01 <monochrom> It may be necessary to know the definition of TransT.
21:06:11 <Koterpillar> oh, right, sorry
21:06:17 <Koterpillar> monochrom is right
21:06:24 <glguy> monochrom is copying glguy!
21:06:54 <angerman> Ok. I'm trying to use Lucid's HtmlT.
21:06:59 <Koterpillar> angerman: is your TransT an instance of MonadTrans?
21:07:02 <monochrom> Yes, but we need to explicitly use the wording "definition" and "actual code"
21:07:14 <glguy> fine, you win
21:07:24 <angerman> Koterpillar yes.
21:08:02 <Koterpillar> oh, and you want the opposite... sorry
21:08:03 <monochrom> In fact there was a time I used the word "definition" and the other person still stayed at the level of handwaving.
21:08:55 <EvanR> keep your hand waving at the level of your eyes!
21:09:37 <angerman> I'm tryint to thread some state through `toHtml`. `toHtml :: a -> HtmlT m ()`, but the last call to `toHtml` expects `HtmlT Identity ()`.
21:10:04 <glguy> ?lpaste
21:10:05 <lambdabot> Haskell pastebin: http://lpaste.net/
21:11:31 <monochrom> @src ContT
21:11:31 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
21:14:32 <monochrom> I know how to do "ContT r (State S) a -> S -> ContT r Identity a", but it's specific to ContT.
21:14:48 <glguy> That's probably what angerman needs
21:15:37 <angerman> monochrom yep that looks pretty much like what I'm looking for. How is it specific to ConT?
21:16:16 <monochrom> oh Lucid is a product of chrisdone!
21:16:26 <glguy> angerman: If you have some code that doesn't work you should paste it to the pastebin so we can help with it
21:17:26 <monochrom> newtype HtmlT m a = HtmlT (m (HashMap Text Text -> Builder, a))
21:18:11 <monochrom> ah this one is probably even easier.
21:19:33 <monochrom> HtmlT is an instance of MFunctor. It has method "hoist". Do you think it will be useful?
21:21:08 <glguy> I think the solution will be easier than pulling out MFunctor
21:21:14 <monochrom> hoist :: Monad m => (forall a. m a -> n a) -> HtmlT m b -> Html n b.  Plug m = State S, n = Identity. (Or keep n general.)
21:21:33 <monochrom> No, I worry that HtmlT is kept an abstract type
21:22:38 <monochrom> Ah, it is not abstract, it is exposed.
21:23:02 <glguy> What type class has the foist method?
21:23:10 <monochrom> MFunctor.
21:24:10 <glguy> I meant foist, though; not hoist
21:24:31 <monochrom> sorry, I don't know.
21:27:48 <monochrom> f :: Monad m => HtmlT (StateT s m) a -> s -> HtmlT m a
21:27:54 <monochrom> f (HtmlT p) s0 = HtmlT (evalStateT p s0)
21:30:03 <glguy> Instead we could just get rid of Identity altogether if we knew where that requirement was coming from
21:30:21 <glguy> and then just use execHtmlT to run the Html layer, and runState on the result
21:31:19 <monochrom> but I begin to like MFunctor. it is so monad-morphism. :)
21:32:19 <monochrom> solution using hoist: f2 h s0 = hoist (flip evalStateT s0) h
21:34:26 <monochrom> There is also the prospect of starting with "StateT S (HtmlT Identity) a" instead.
21:41:29 <angerman> glguy: so I write ToHtml instances for my types (which in turn might call other toHtml on other types). Now the the library finally calls renderBS on the top-most datatype. Hence, the topmost's datatype ToHtml Instance must return HtmlT Identity ().
21:42:28 <glguy> angerman: OK, use this instead: renderBST :: Monad m => HtmlT m a -> m ByteString
21:42:40 <glguy> http://hackage.haskell.org/package/lucid-2.9.5/docs/Lucid.html#v:renderBST
21:42:40 <angerman> glguy: but when calling toHtml on nested types, I could potentially get back HtmlT (StateT s Identity) (), where I'd like to collapse the StateT layer.
21:42:44 <monochrom> I agree.
21:44:37 <angerman> glguy then I need to break open the calling library :-/
21:44:48 <monochrom> i.e., renderBST then runState
21:46:03 <glguy> OK, let me know if you end up pasting the code in question
21:46:34 <angerman> glguy I'm in the process of tyding it right now.
21:55:22 <seivan_> type CharParser st a    = GenParser Char st a
21:55:46 <seivan_> Could you say CharParser is a typealias of GenericParser that uses Char as inpit and a as output?
21:56:25 <Koterpillar> that uses Char as input, everything else is the same
21:56:54 <glguy> seivan_: You could even write: type CharParser = GenParser Char, in this case
21:57:20 <glguy> except that GenParser is itself a type synonym with two arguments
21:57:52 <glguy> So... you could even write: type CharParser st = GenParser Char st
22:01:34 <seivan_> thanks!
22:01:49 <seivan_> I found this, it has been helpful http://www.grammaticalframework.org/~hallgren/gf-experiment/browse/pfe.cgi?Text.ParserCombinators.Parsec.Prim
22:05:05 <dibblego> tank144: https://gist.github.com/tonymorris/06e9a700740cf6482aad6e57af0f64a8
22:15:20 <mjrosenb> I've been looking for a tutorial showing how to use the haskell charts library to render to a window, rather than saving to a file that needs to be displayed externally.
22:15:28 <adarqui> hey, does anyone here use -Werror? if so, how would I go about using it with something like yesod, which generates random template haskell variable names? those trigger a fatal error, ie: Defined but not used: ‘userId_aM9e’
22:18:48 <adarqui> actually.. i think it might be some unused bindings in my hamlet files which are triggering it
22:25:28 <Squarism> dibblego, had to look at it also as im missinformed. Impressive effort. I somehow missed the recursive nature of it all. 
22:36:38 <Squarism> but io doesnt have to be recursive right? As this seems to work : main = putStrLn "asdf" >> ( return ()) >> putStrLn "qwer" >> ( return ()) >> getLine >>= (\x -> return ())
22:37:24 <EvanR> indeed thats not a recursive program, it doesnt need to be
22:38:18 <Squarism> ok, just wanted it clear to me
22:38:31 <EvanR> but if you were doing a free monad-like IO facsimile, you need a recursive type
22:39:10 <Squarism> i need to learn free / cofree / comonad  meanings
22:39:30 <Squarism> right now its chinese to me
22:39:57 <EvanR> in this case, simply data IO a = Pure a | GetChar (Char -> IO a) | PutChar Char (IO a)
22:43:20 <Squarism> ok ill read up on that
22:44:18 <EvanR> you see, knowing nothing about monads, how IO programs can be represented with that, like PutChar 'x' (PutChar 'y' (GetChar (\c -> PutChar c (Pure ()))))
22:45:31 <Squarism> nice example
22:46:00 <EvanR> something, a computer, your dog, god would be responsible for handling each layer appropriately and continuing, in the case of GetChar youd also have to provide some Char to continue
23:09:19 <dwynwen_ddlleyw> Hello haskellers 
23:28:38 <hulahoof> /msg NickServ VERIFY REGISTER hulahoof klwzrmsqfcgo
23:28:49 <geekosaur> "whoops"
23:41:44 <phanimahesh> oops
