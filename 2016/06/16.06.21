00:07:41 * hackagebot raaz 0.0.1 - The raaz cryptographic library.  https://hackage.haskell.org/package/raaz-0.0.1 (PiyushKurur)
00:07:41 * hackagebot aeson-coerce 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/aeson-coerce-0.1.0.0 (angerman)
00:08:37 <johnw> raaz is a cute name for a crypto lib
00:13:55 <hamid> johnw, im not sure but i guess it's a Farsi word
00:14:24 <johnw> correct
00:14:27 <johnw> means "secret"
00:15:13 <hamid> johnw, yeah but apparantly the writer is Indian, so it's a borrowed word.
00:15:20 <hamid> anyway :))
00:15:26 <johnw> he could be pakistani and speak Urdu
00:16:02 <hamid> johnw, yes
01:47:41 * hackagebot idris 0.12 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.12 (EdwinBrady)
01:58:57 <mniip> how can I prevent the typechecker from folding folding constraints by substituting ~-ed variables?
01:59:02 <mniip> -folding
02:03:09 <pyon> Is there any library of data structures that makes a typed distinction between non-empty and possibly empty containers?
02:03:19 <pyon> In Hackage.
02:04:36 <merijn> pyon: I don't think so?
02:05:45 <bennofs> pyon: there is http://hackage.haskell.org/package/mono-traversable-0.10.2/docs/Data-MinLen.html
02:05:58 <pyon> Checking.
02:07:22 <pyon> Mmm, representing Nat constructors using empty types is quite nasty. What's preventing me from doing “Succ Int” somewhere else in the program?
02:07:57 <pyon> (Of course, “Succ Int” is completely meaningless. That's precisely the kind of thing that should be impossible in a typed language like Haskell!)
02:22:43 * hackagebot hakyll 4.8.3.2 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.3.2 (JasperVanDerJeugt)
02:23:59 <nmattia> pyon: depending to the use case you could stick to comonads
02:25:52 <nmattia> s/to/on
02:47:44 * hackagebot leancheck 0.4.0 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.4.0 (rudymatela)
02:57:44 * hackagebot fitspec 0.2.1 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.2.1 (rudymatela)
02:59:27 <idev> 'stack build' builds -- what runs ?
03:00:20 <Akii> stack exec your-thing?
03:00:32 <idev> ah
03:00:34 <idev> worked; thanks!
03:00:37 <Akii> nice
03:04:15 <Phyx-> hrm.. since when does haskell-blah require SSL?
03:05:59 <Xandaros> My library generates a tree with named nodes and I now want to find a specific node in it. This kind of reminds me of what xml-conduit does, so I've been thinking. What do I do now? Implement my own system? Copy xml-conduit as much as makes sense? Provide a conversion function to xml and require the user to use that instead? (The xml thing is strictly more powerful. I don't have attributes, for example)
03:16:39 <bernalex> Phyx-: a long time. there's #haskell-offtopic now, which doesn't.
03:28:34 <Phyx-> bernalex: oh, ok. thanks :)
05:01:09 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
05:01:09 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
05:01:49 <netsu> >>> hello. What can cause such error? haddock: internal error: --read-interface=HUnit-1.3.1.1,HUnit-1.3.1.1/HUnit.haddock: openFile: does not exist (No such file or directory)
05:05:30 <cheater> HUnit has no haddock?
05:18:31 <tero-> Xandaros: childrenBi gives direct children of a type
05:20:23 <tero-> Xandaros: so you could have: let f k xs = [ n | n@(Node k' _) <- childrenBi xs, k' == k ] and then apply the function multiple times
05:20:55 <Xandaros> :/
05:21:59 <tero-> Xandaros: ah those are not direct successors?
05:22:41 <Xandaros> They usually are
05:22:45 <Xandaros> I'll figure something out
05:24:57 <tero-> Xandaros: maybe then a transformation "everywhereM (mkM f) ast" where 'f' is a monadic query 
05:26:45 <Xandaros> I think using biplate is a bit overpowered, to be honest. I only have one datatype with two constructors, after all
05:27:16 <Xandaros> I'll go with my second approach, I think. Basically copying xml-conduit and, maybe, xml-lens
05:29:13 <tero-> whatever gets the job done within the budget and is maintainable should be okay
05:31:04 <R0B_ROD> Hello world
05:31:51 <R0B_ROD> I want to learn this language so it can help me improve my life
05:32:59 <R0B_ROD> I am just always stuck b4 I even begin for lack of ideas. like if I had friends to help with their projects I'm just so useless
05:37:01 <linduxed> R0B_ROD: i have a hard time figuring out what your problem is
05:37:28 <linduxed> do you feel like you don't know what project to start on?
05:37:28 <linduxed> do you not know what material to read?
05:37:28 <quxbam> How can I define mutually exclusive constraints?
05:37:38 <linduxed> do you need some advice on how to start learning the language
05:37:40 <linduxed> ?
05:37:44 <quxbam> I guess I could use Constraintkinds and use a type family for that
05:38:58 <quxbam> like   foo :: MyConstraints '[Monad, Monoid] a => a
05:39:30 <quxbam> In this case, I could prevent the use of Monad and Monoid in the constraints, but the user could easily write
05:39:36 <R0B_ROD> linduxed I can find many free resources and have had almost every book pdf but it's lack of ... that keeps me from playing
05:39:44 <quxbam> foo :: (MyConstraints '[Monad] a, Monoid a) => a
05:39:57 <quxbam> Or ignore entirely my construct
05:40:56 <fizruk> quxbam: where are mutually exclusive constraints in that example?
05:41:31 <quxbam> quxbam: Well, it was just an example for if I'd like to exclude the constraint of Monad and of Monoid
05:41:32 <R0B_ROD> linduxed thanks for inquiring
05:41:56 <linduxed> R0B_ROD: "it's lack of ... that keeps me"
05:42:04 <R0B_ROD> don't know what project to start on
05:42:11 <linduxed> R0B_ROD: should we understand that as a lack of inspiration?
05:42:12 <quxbam> fizruk: My real usecase is that I'm writing a lib to explicitly restrict the power of IO
05:42:20 <R0B_ROD> lack of time energy inspirarion
05:42:38 <quxbam> putStr :: WriteOnly io => String -> io ()
05:42:40 <linduxed> R0B_ROD: have you tried solving exercises on http://exercism.io/?
05:42:50 <R0B_ROD> yes does r not fun
05:43:00 <quxbam> So the WriteOnly constraint should exclude the ReadOnly constraint
05:43:10 <linduxed> R0B_ROD: https://projecteuler.net/ ?
05:43:21 <R0B_ROD> I'm highly creative but not when it comes to making something out of nothing
05:43:45 <linduxed> R0B_ROD: i'm not sure how i am to interpret that
05:43:53 <R0B_ROD> I end up thinking its not as cool as anything everyone else is making
05:44:01 <fizruk> quxbam: ah, I am not sure it'll work with constraints
05:44:24 <linduxed> R0B_ROD: i don't think you should care about that when you don't know the language yet
05:44:25 <fizruk> quxbam: rather that WriteOnly, you can implement CanWrite constraint
05:44:34 <quxbam> fizruk: That's already done
05:44:38 <linduxed> R0B_ROD: instead, try to solve some problem you have with haskell
05:44:40 <quxbam> :)
05:44:52 <linduxed> R0B_ROD: some text that needs to be transformed? write a script
05:44:54 <fizruk> quxbam: the limiting part is on the other end
05:44:58 <R0B_ROD> u have a point
05:45:03 <quxbam> fizruk: But, how could I in this case allow the function interact?
05:45:12 <quxbam> It needs CanWrite and CanRead
05:45:14 <linduxed> R0B_ROD: some very simple web page to create? write it with haskell if you can
05:45:29 <linduxed> R0B_ROD: some data you need to parse? write another script
05:45:31 <R0B_ROD> linduxed thanks again for ur time
05:45:38 <linduxed> np
05:46:00 <R0B_ROD> I enjoy folks that r friendly and helpful
05:46:13 <R0B_ROD> been on irc for more than half of my life
05:46:20 <linduxed> there's a few of those in this channel!
05:46:23 <quxbam> fizruk: I've got for every IO function a class, and the CanRead class has as superclasses all classes which contain a IO function which can read
05:46:37 <quxbam> fizruk: And everything has got an instance of IO
05:47:19 <R0B_ROD> I've been here b4 and everyone is great
05:47:20 <quxbam> So it can be just used normally with an IO signature to allow everything, or with an CanRead constraint to allow only a subset
05:47:31 <fizruk> quxbam: to limit users you have to use different type, not IO
05:47:34 <R0B_ROD> some tougher than others but hey hacking is about doing
05:47:49 <fizruk> quxbam: e.g. ReadIO or TeletypeIO or NetworkIO
05:47:49 <quxbam> fizruk: It works without flaw
05:47:52 <R0B_ROD> I didn't know I could make a Web page
05:47:58 * hackagebot casr-logbook 0.0.12 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.12 (TonyMorris)
05:48:22 <R0B_ROD> it would be cool to make me an weight lifting log for Android 
05:48:23 <quxbam> fizruk: The user has to provide a typesignature and that's all
05:49:09 <quxbam> myIO :: (PutStr io, getChar io) => io ()
05:49:17 <quxbam> GetChar
05:49:34 <quxbam> So in this case, the user can only use this two io functions in the function definition
05:49:53 <quxbam> but myIO can be used in every IO case, for example in main
05:50:32 <quxbam> Every function forces a constraint, so the compiler complains about a too general typesignature.
05:51:01 <fizruk> quxbam: ok, so why again do you need exclusive constraints?
05:52:12 <R0B_ROD> linduxed does Alex Meijer sound familiar?
05:52:15 <tero-> quxbam: would extensive effects be relevant for your use case?
05:52:23 <linduxed> R0B_ROD: no, i don't think so
05:52:32 <tero-> extensible
05:53:31 <quxbam> fizruk: So that it's less probable that someone messes up the Constraint of the signature
05:54:00 <quxbam> fizruk:  myIO :: (ReadOnly io, PutStr io) => io ()  should be a type error
05:54:20 <quxbam> tero-: never heard about that, I'll read a bit
05:54:43 <R0B_ROD> Erik Meijer linduxed he's has videos for haskell
05:55:09 <linduxed> ah
05:55:33 <dramforever> quxbam: Why ReadOnly instead of Read?
05:55:48 <lpaste> quxbam pasted “restricted io” at http://lpaste.net/167254
05:56:05 <dramforever> if they don't specify PutStr it's read-only
05:56:36 <quxbam> dramforever: Yes, I'd like just the extra security or foot-shootage avoidance
05:56:45 <quxbam> I'll be back in 30 min
05:56:56 <tero-> quxbam: I'm not sure whether this is what you're after but PureScript has Eff monad and extensible records/effects http://www.purescript.org/learn/eff/ . this doesn't solve the mutual exclusion of constraints, though
05:57:16 <tero-> quxbam: and I'm trying to figure out if http://okmij.org/ftp/Haskell/extensible/ achieves the same
05:58:05 <dramforever> quxbam: doesn't really help, you see. If you want to restrict, make a newtype ReadOnlyIO a = ROIO (IO a)
05:58:18 <drdo> Can anyone recommend a SAT library?
05:58:22 <dramforever> make it an instance of Read but not Write
05:58:22 <quxbam> away (30')
06:02:39 <dramforever> @tell quxbam Make a newtype ROIO a = ROIO { runROIO :: IO a }, make it an instance of Read but not write, then runROIO will automagically force its argument to be read-only.
06:02:39 <lambdabot> Consider it noted.
06:06:33 <dramforever> @tell quxbam You don't avoid shooting the foot by making people write certain signatures. You make your functions take arguments that must satisfy certain properties.
06:06:34 <lambdabot> Consider it noted.
06:28:00 * hackagebot multirec 0.7.6 - Generic programming for families of recursive datatypes  https://hackage.haskell.org/package/multirec-0.7.6 (AndresLoeh)
06:40:57 <quxbam`> @messages
06:40:57 <lambdabot> You don't have any messages
06:43:03 <Boomerang> What does @messages do?
06:43:49 <Phyx-> it's like a voicemail service for the channel
06:44:04 <Phyx-> if someone leaves you a message when you weren't around you can retrieve it
06:44:14 <Phyx-> @tell Boomerang Hi hi
06:44:14 <lambdabot> Consider it noted.
06:44:23 <Boomerang> Oh I see :)
06:44:24 <bernalex> it's for lambdabot, not the channel, afair.
06:44:29 <Boomerang> @messages
06:44:36 <Boomerang> Thanks
06:44:37 <Phyx-> but but.. lambdabot is the channel! :)
06:44:49 <bernalex> lambdabot is in a bajillion chans.
06:45:07 <Boomerang> quxbam`: messages were left for you as quxbam I think not quxbam` 
06:53:01 * hackagebot leancheck 0.4.1 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.4.1 (rudymatela)
06:58:36 <quxbam`> Boomerang: And how can I retrieve these? Reconnect with the old nic?
06:59:05 <Boomerang> I copy-paste the two, I've seen (there might be more
06:59:16 <Boomerang> <dramforever> @tell quxbam Make a newtype ROIO a = ROIO { runROIO :: IO a }, make it an instance of Read but not write, then runROIO will automagically force its argument to be read-only.
06:59:24 <Boomerang> <dramforever> @tell quxbam You don't avoid shooting the foot by making people write certain signatures. You make your functions take arguments that must satisfy certain properties.
06:59:31 <quxbam`> Thank you!
07:00:04 <Boomerang> There might be more from before I connected :)
07:00:29 <fizruk> quxbam`: note that you can also expect (forall io. Read io => io a) as an argument
07:02:00 <quxbam`> fizruk: What does the forall exactly?
07:02:38 <fizruk> quxbam`: it ensures that user can't supply e.g. (Read io, Write io) => io a
07:03:04 <quxbam`> Ahh
07:08:23 <dfeuer> Ping hexagoxel 
07:08:39 <codedmart> What is the best function to use if I want to check if some Text is within some other Text. i.e. contains “random" “Some random string”?
07:08:56 <mauke> is there an isInfixOf function?
07:09:05 <quxbam`> yes, in Data.Text
07:09:16 <Morgawr> Is there a way to match on a data constructor type without caring about its parameters? I have a something like Data = MyDataType1 a b c d | MyDataType2 a b | NoData
07:09:17 <mauke> there you go
07:09:28 <Morgawr> Right now I do something like myFunction MyDataType1 _ _ _ _ = ...
07:09:32 <codedmart> Ah missed that one. Thanks!
07:09:33 <dfeuer> There's probably even a package of text search functions.
07:09:34 <fizruk> codedmart: Text.isInfixOf
07:09:36 <dfeuer> Somewhere.
07:09:36 <Morgawr> myFunction MyDataType2 _ _ = ...
07:09:36 <mauke> Morgawr: MyDataType1{}
07:09:44 <Morgawr> mauke: Oh, thanks!
07:09:51 <dfeuer> I hope there's one, anyway.
07:10:00 <dfeuer> Because no one search function rules them all.
07:10:18 <mauke> > case Just 42 of Nothing{} -> "Nothing"; Just{} -> "Just ???"
07:10:20 <lambdabot>  "Just ???"
07:10:33 <Morgawr> mauke: It works perfectly, thanks a lot :)
07:12:42 <barrucadu> Morgawr: That syntax is one of the suggests `hlint` gives you; if you're not using it already, I recommend it.
07:12:56 <dfeuer> I find the type of Data.Functor.Fixedpoint.ymap in unification-fd deeply unsatisfying. Is there a generalization of Fix that supports a similar operation with a more informative type?
07:13:02 <Morgawr> barrucadu: Good point, I will, thanks.
07:17:37 <mettekou> So if I understand correctly, Uniplate cannot handle substructures of a different type. Which is where Multiplate comes in?
07:28:03 * hackagebot fitspec 0.2.2 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.2.2 (rudymatela)
07:34:31 <dfeuer> Aha!
07:34:33 <dfeuer> Now I see!
07:50:36 <nitrix> I'm sad. My game had a clear division of IO and non-IO, but recently, I had to make the map dynamically load chunks, add relational IORef gizmos, a cache system for textures... bunch of stuff that hooks pretty deep.
07:50:42 <Habib> hey, does anyone know how i can get the man pages for a specific version of ghc?
07:50:43 <nitrix> And now, like 80% of the game is in IO :/
07:51:13 <nitrix> Granted there's no much content yet so maybe I'll be able to grow the non-IO part bigger again, but I'm really sad about it.
07:51:20 <nitrix> Is it common?
07:52:01 <Habib> I don't know if it's common, but speaking as a beginner, when I made a small console game, IO was a bit of an issue for me to try and separate.
07:52:11 <hc> nitrix: what's your game?
07:52:37 <c_wraith> It's common for IO to take over your logic unless you're careful to use patterns known to beat it back.
07:52:37 <nitrix> hc: 2D real-time strategu (procedural) sandbox
07:52:47 <hc> is it on github/hackage?
07:53:02 <nitrix> Yes but it's pretty much unusable at the moment.
07:53:19 <nitrix> You'll just get a parallax space starfield.
07:53:32 <bernalex> my games haven't been very IO heavy, really.
07:53:43 <bernalex> sure, the interfacing parts with threads etc have been.
07:54:07 <bernalex> it's hard to talk to the network or listen to mouse input outside of IO. :)
07:54:08 <c_wraith> the main way to reduce IO use is to reify more manipulations of the game state.
07:54:29 <merijn> I'm playing around with the idea of just not doing the engine in haskell but using Unreal Engine and just use Haskell to do non-physics game logic and IO
07:54:56 <hc> why not implement an engine in haskell and design a DSL for the game logic? ;]
07:55:14 <Habib> does anyone know why the man pages for GHC aren't bundled with the source tarball?
07:55:15 <c_wraith> That is, instead of issuing "play sound" or "draw image" commands directly (or whatever), you generate a list of commands that do that later.  This is where free monads often come into play.
07:55:16 <merijn> hc: Because doing proper netcode is a bitch
07:55:19 <bernalex> hc: I'm still waiting for someone to pay me to make hsolarus. :)
07:55:36 <hc> merijn: netcode as in networking code?
07:55:41 <merijn> hc: Doing proper local simulation/extrapolation to compensate lag, etc.
07:55:44 <merijn> hc: Yeah
07:55:45 <hc> oh yeah
07:55:54 <hc> but one could try to replicate the unreal approach
07:56:01 <hc> which has worked pretty well since unrealengine 1 iirc
07:56:02 <merijn> hc: Yes, but why?
07:56:03 <bernalex> there's a huge portion of games where networking isn't even applicable in the first place though.
07:56:12 <hc> merijn: because it's fun?
07:56:15 <merijn> bernalex: I only care about multiplayer games :)
07:56:19 <hc> but i agree that the unreal engine is awesome
07:56:44 <merijn> bernalex: I've got plenty of games I can play alone, what I'm lacking is games I can play with friends :)
07:56:46 <bernalex> it would be great to have a free software unreal engine equivalent thing in haskell.
07:56:57 <hc> oh yeah it would
07:57:01 <bernalex> merijn: try DnD.
07:57:37 <merijn> bernalex: As in, in-person? That doesn't meet my criterium of "can be played with my friends abroad"
07:57:50 <merijn> I already play boardgames with the friends that are physically close
07:58:01 <bernalex> merijn: you never said they were abroad.
07:58:05 * hackagebot Agda 2.5.1.1 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.5.1.1 (AndresSicardRamirez)
07:58:29 <buglebudabey> what's a good way to pattern match a list of triple touples?
07:58:30 <merijn> bernalex: I wasn't aware I was supposed to give a comprehensive listing of reasons of why I only care about multiplayer games ;)
07:58:38 <c_wraith> Hmm.  I remember reading about a library for packing data into self-contained contiguous memory, in a way that GHC's GC optimized.  What was that called, and what's the release schedule for it?
07:59:48 <bernalex> buglebudabey: what do you mean? also, why do you have one? stop that.
08:00:24 <nshepperd_> you can play DnD over video chat :)
08:01:35 <bernalex> nshepperd_: many people I know play using something called roll 20. I do not know much about it, but I think it is proprietary, so unfortunately I must reject their invitations to use it. but anyway, I think DnD is much more fun in person without the distraction of electronics pleasant, so I can certainly understand why many people prefer it in person, being one of those people myself.
08:02:13 <c_wraith> ah.  compact regions!
08:02:22 <c_wraith> and it's targeting 8.2
08:02:30 <buglebudabey> bernalex I have a data constructor that is "ECase (Expr a) [Pattern a], where "type Pattern = (Int, [a], Expr a)", I am trying to pretty print an ECase and I want to map over the list of Patterns while accessing it's parts
08:02:32 <c_wraith> I was hoping to play with them sooner. :(
08:03:39 <bernalex> buglebudabey: I've got to go, but have you considered using a datatype instead of a triple tuple? that way, you could access them more easily using e.g. record syntax.
08:03:40 <buglebudabey> bernalex "case {expression} of {int a a a} -> {expression}"
08:04:06 <buglebudabey> no i haven't considered that, i'll think about it
08:04:08 <hguant> DnD over skype and IRC can be fun. Use one for in character chat and another for out of character bs'ing
08:04:57 <wraithm> Does "type family Id a = a" (or something roughly equivalent to that) exist in base or alternatively on hackage somewhere?
08:07:13 <barrucadu> What would the use of it be? (not berating you, genuinely curious)
08:08:07 <wraithm> I'm messing with some opaleye stuff, and it might be useful. I'm experimenting.
08:08:27 <wraithm> Trying to reduce type-level boilerplate stuff
08:09:55 <glguy`> Wraithm: you can't pass a type family as an argument without saturating its arguments
08:10:17 <wraithm> glguy`: Ah, okay, cool. Thanks.
08:10:26 <wraithm> That does put a damper on my plan
08:10:27 <wraithm> lol
08:11:39 <wraithm> Is that a thing that would ever make sense? Like a "higher-order type family"
08:12:10 <dolio> It makes sense, but it breaks useful properties of the type system.
08:12:24 <wraithm> Interesting. I haven't thought about that at all.
08:12:34 <recursion-ninja> I used `getArgs`, and it removed double quotes from the command line arguments. How can I get the command line arguments with the quotes?
08:12:40 <quxbam`> Why doesn't GeneralizedNewtypeDeriving derive superclasses?
08:12:52 <dolio> What if you want to write them explicitly?
08:13:07 <quxbam`> good point
08:13:20 <nmattia> recursion-ninja: I think it's done before the arguments are passed to your program
08:13:39 <recursion-ninja> nmattia: At the OS level?
08:13:52 <nmattia> recursion-ninja: the OS actually calls your program with each arg that's somehow delimited
08:13:56 <nmattia> recursion-ninja: 
08:14:00 <nmattia> recursion-ninja: yeah
08:14:24 <barrucadu> More shell-level than OS-level
08:14:39 <nmattia> recursion-ninja: it's like asking to receive the spaces as well
08:14:43 <nmattia> barrucadu: thanks
08:14:52 <recursion-ninja> barrucada: Yeah, I guess that's what I ment
08:15:07 <glguy> recursion-ninja: You'll have to escape the quotes if you want your shell to consider them part of the argument
08:15:08 <geekosaur> recursion-ninja, the shell parses the quotes and your program never sees them
08:15:22 <geekosaur> you can't override this, except by additional levels of quoting
08:15:57 <recursion-ninja> barrucada, nmattia:  Makes using `readMay :: Maybe [String]` a non-option, have to actually parse I guess...
08:15:58 <nmattia> recursion-ninja: try `my prog '""""'`, that should work
08:15:58 <Rryy> recursion-ninja: try ./haskell-program 'thing with "doublequotes" here'
08:16:46 <Rryy> recursion-ninja: also, if you are on linux, experiment with echo, and see what it prints
08:17:26 <nmattia> recursion-ninja: same as Rryy, baring in mind that it'll intercalate spaces between each args
08:17:51 <recursion-ninja> namattia: echo '""' seems to work, I'
08:18:01 <recursion-ninja> namattia: echo '""' seems to work, I'll try to use shell escaping...
08:19:06 <recursion-ninja> namattia: ./my-prog '["quoted","strings","here"]'   seems to work.
08:19:52 <nmattia> recursion-ninja: good, I didn't actually understand why you mentioned readMay
08:20:35 <recursion-ninja> namattia: I was trying to do as little work as possible when processing the arguments...
08:21:12 <bdesham> can anyone answer this question about Wreq? https://github.com/bos/wreq/issues/82
08:21:20 <bdesham> does it not do ssl certificate validation right now?
08:22:15 <recursion-ninja> namattia, Rryy, geekosaur: Thanks for all your help guys! It would have taken me a lot of time to figure out that it was happening at the shell level.
08:23:06 * hackagebot tai64 0.2.0 - Tai64 Labels for Haskell  https://hackage.haskell.org/package/tai64-0.2.0 (KimAltintop)
08:24:50 <R0B_ROD> what's a good pdf to start with? other than the most popular...perhaps a Web page 
08:25:15 <quxbam`> If I've got a lib Foo which provides functionality for a lot of other modules, which hierarchy is better Foo.Data.Text or Data.Text.Foo
08:25:47 <quxbam`> With the first version, one can easily browse the supported libs via tab-completion
08:26:40 <bdesham> quxbam`: it seems like the Data.Text.Foo form is much more common
08:26:46 <R0B_ROD> personal choice I guess
08:30:06 <hc> Hi, I'm currently using Data.Sequence for a pure haskell implementation of the deflate algorithm... but it's pretty slow... can you recommend which array/data structure i should be using instead? Data.Array.ST unboxed?
08:33:08 <dfeuer> hc, what operations are you using?
08:39:19 <hc> dfeuer: basically append elements to the array, or small parts that are already part of the array
08:40:19 <dfeuer> hc, and what else? Coming up with a full list of the operations you need will help you choose a more specialized sequence type.
08:40:40 <hc> that's all
08:40:50 <hc> i'm using that array to build the decompressed stream from the compressed stream
08:41:03 <dfeuer> hc, you must eventually inspect the sequence. How do you inspect it?
08:41:17 <glguy> takes the temperature of the computer?
08:41:40 <hc> dfeuer: convert it to a bytestring
08:41:47 <dfeuer> Aha!
08:41:54 <hc> in the end, i need the whole contents of the array
08:42:02 <dfeuer> You might want to look into the bytestring package and find the builder.
08:42:18 <hc> can i backreference with the builder?
08:42:37 <hc> lzh basically says: go back 5 bytes, and take three bytes, and append that to the end
08:42:46 <dfeuer> Nope, not with the builder.
08:43:54 * dfeuer has to run.
08:43:57 <dfeuer> SOrry.
08:49:34 <andreoss> i'm looking for a function which returns number of virtual cpu on machine (like nproc)
08:52:26 <josephle> andreoss: http://stackoverflow.com/questions/8041813/how-to-find-the-number-of-cores-at-runtime-in-haskell
08:52:36 <josephle> that should be a good place to start looking
08:53:07 * hackagebot pipes-attoparsec 0.5.1.4 - Attoparsec and Pipes integration.  https://hackage.haskell.org/package/pipes-attoparsec-0.5.1.4 (RenzoCarbonara)
09:07:33 <shirt> I am using optparse-applicative, with hsubparser. How can I split the help output of "Available commands:" into groups (just for visual clarity)?
09:07:35 <Gurkenglas> Can you make "hSetBuffering stdout NoBuffering" default?
09:24:17 <Geraldus_> o/ Hi friends!
09:25:31 <Geraldus_> I see that latest Pandoc package have `if impl` conditions in cabal file.  However when I tried to upload to Hackage one of my GHCJS packages it complained because of such conditions.
09:25:54 <Geraldus_> I wonder is there a way to bypass this check?
09:25:59 <dcoutts> Geraldus_: what did the error message say?
09:26:45 <Geraldus_> dcoutts: it says that my package have duplicate modules
09:27:15 <dcoutts> Geraldus_: can you point to your .cabal file?
09:27:50 <Geraldus_> dcoutts: surely, here it is https://github.com/geraldus/ghcjs-perch/blob/master/ghcjs-perch.cabal
09:28:26 <Geraldus_> Looking at it now I see that in both cases modules list is the same, I can try to workaround this. 
09:28:34 <Geraldus_> How can I missed that?
09:29:12 <Geraldus_> Let me try
09:29:13 <dcoutts> Geraldus_: so restructure it so that only the bits that are different are inside the "if .. else ..." block
09:29:23 <glguy> Geraldus_: Since your module list is the same in both cases couldn't you just factor those out
09:29:40 <dcoutts> this will also make it much easier for you to read/edit/maintain
09:29:45 <Geraldus_> surely pals
09:30:37 <dcoutts> if impl(ghcjs >= 0.1)
09:30:45 <dcoutts>   build-depends: ghcjs-base
09:30:48 <Geraldus_> dcoutts: oh, nice 
09:30:56 <dcoutts> is all you need for the different bits as far as I can see
09:32:00 <Geraldus_> dcoutts: I believe this condition was introduced not by me, and I have simply overlooked that redundant duplication
09:32:10 <Geraldus_> dcoutts: glguy: thank you
09:49:29 --- mode: ChanServ set +o dcoutts
09:58:10 * hackagebot yaml 0.8.18 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18 (MichaelSnoyman)
09:59:00 <AndChat|335225> Hi
09:59:45 <AndChat|335225> Are there any tutorials to understand how HList is implemented?
10:00:40 <peddie> AndChat|335225: there is a paper at http://okmij.org/ftp/Haskell/HList-ext.pdf
10:01:52 <AndChat|335225> Yes, but nowadays the library uses much more modern stuff
10:02:33 <AndChat|335225> For example in 2004 Datakinds didn't exist
10:06:03 <peddie> AndChat|335225: you're completely right, the paper is just the only thing I know of
10:08:22 <peddie> AndChat|335225: maybe if you dig into the code and ask specific questions people will be able to answer them
10:12:13 <gehmehgeh> hi
10:16:45 <aisqwe> why doesnt this code work  :      newStdGen >>= (\x -> return $ random x) >>= (\(aa,bb) -> return $ random bb)
10:17:35 <Habib> >newStdGen >>= (\x -> return $ random x) >>= (\(aa,bb) -> return $ random bb)
10:18:27 <srhb> aisqwe: Depends, what goes wrong? Is the type ambiguous?
10:19:04 <aisqwe> yes i think the type is ambiguous  i get "Could not deduce (Random a0) arising from a use of ‘random’     from the context (Random a)"
10:20:14 <aisqwe> but how would you resolve it?
10:22:07 <srhb> aisqwe: First off, I wouldn't do the needless extra step. You're discarding aa completely. If you were not, it would probably not be ambiguous to begin with
10:23:19 <srhb> aisqwe: Consider for instance: newStdGen >>= (\x -> return $ random x) >>= return . (\(a,s) -> (a,random s))
10:23:26 <aisqwe> can you transform it somehow so that aa is inferred? or explixitley mention the type?
10:23:56 <srhb> aisqwe: It's probably still ambiguous (if not done in ghci) if no further programming uses it.
10:24:06 <srhb> aisqwe: And if no further part of the program uses it, I would cut it out. :)
10:24:26 <aisqwe> oh, thanks , but can you tell me by what thought process you were able to find the error? :D
10:24:45 <srhb> aisqwe: I noticed that you were throwing away a value, and that means that nothing ever constrained it.
10:25:22 <aisqwe> is there anyway to explicitly give the type like :: (Int, stdGen) something?
10:25:53 <srhb> aisqwe: Yes, for instance you could just give the type of random x like (random x :: (Int, StdGen))
10:25:56 <srhb> Or something like that
10:26:28 <srhb> aisqwe: There's numerous ways to do it more prettily, say with let or where bindings. It all depends what you're doing. But you should probably just get rid of the extra step.
10:27:11 <srhb> aisqwe: It looks like your original version was basically going to be equivalent to `fmap random newStdGen`
10:27:22 <Zemyla> I have a question about GHC's string compilation.
10:27:35 <aisqwe> I'm just trying to understand the monad concepts it is not a real world project
10:28:50 <srhb> aisqwe: Ok. :)
10:30:29 <Zemyla> Does GHC turn, say, indexInt8OffAddr# "foo"# 0# into 70# at compile-time?
10:30:34 <srhb> aisqwe: Perhaps make a function randomInt :: RandomGen g => (Int, g); randomInt = random
10:30:38 <srhb> Er
10:30:43 <srhb> aisqwe: Perhaps make a function randomInt :: RandomGen g => g -> (Int, g); randomInt = random
10:31:42 <Zemyla> Wait, I can solve this on my own.
10:32:54 <Zemyla> I mean, I have a copy of GHC.
10:33:31 <amf> in Control.Concurrent.forkIOWithUnmask what am i supposed to do with the unmask from the example? i couldnt find a better full example
10:35:12 <c_wraith> amf, you unmask the action in which you want to allow asynchronous exceptions to be received.
10:35:46 <c_wraith> (or actions, plural, depending on the use case) 
10:36:52 <amf> ha! so catch (unmask $ someFunc arg1) ?
10:37:49 <c_wraith> that's the basic idea, yeah. though of course catching a potential exception is optional.. :) 
10:38:53 <amf> gotcha. thanks! (now to find out why my silly program stalls out)
10:45:36 <Zemyla> No, sadly, it doesn't. D:
10:52:41 <oherrala> Is this guy on IRC: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/121092 ?
10:56:31 <gehmehgeh> "One reason that right-associative folds are more natural in Haskell than left-associative ones is that right folds can operate on infinite lists." <---- Hi. Isn't it left-associative ("foldl") folds that work on infinite lists rather than what they say in that quote?
10:56:54 <shachaf> No.
10:57:06 <gehmehgeh> That's from here https://en.wikibooks.org/w/index.php?title=Haskell/Lists_III
10:57:12 <glguy> No, since left-folds start applying the given function to the last element in a list (and there isn't a last element) they don't work on infinite lists
10:57:28 <glguy> > foldl f z [a,b,c]
10:57:30 <lambdabot>  f (f (f z a) b) c
10:57:58 <glguy> Notice that the outermost use of f applied to c
10:57:59 <gehmehgeh> foldr f z [a,b,c]
10:58:15 <glguy> > foldr f z [a,b,c]
10:58:17 <lambdabot>  f a (f b (f c z))
10:58:35 <glguy> But here the outermost f is applied to the first element of the list, so it can work on infinite lists
10:59:18 <geekosaur> point here is that if f can produce a partial result just using a, the right fold can proceed; the left fold always starts by evaluating f on the next item which evaluates f on the next item ... and this will diverge if the list is infinite
11:03:19 <glguy> > foldr f z [0::Integer ..]
11:03:23 <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f ...
11:04:13 <gehmehgeh> Got it. Thanks :)
11:05:15 <EvanR> foldr-ing a list can also diverge
11:05:24 <EvanR> depending on what you do with f
11:05:34 <EvanR> at least it has a fighting chance of not
11:05:46 <geekosaur> whch is the "if f can produce a partial result just using a" I mentioned
11:06:09 <geekosaur> if it needs more than that first list element to produce even a partial result, then the right fold will also diverge
11:06:10 <EvanR> ok... im just not clear what a partial result is
11:06:30 <geekosaur> [21 18:03] <lambdabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f ...
11:07:07 <geekosaur> the partial result for 0 is "f 0 ("; for 1 is "f 1 ("; ...
11:07:13 <EvanR> haha
11:07:14 <shachaf> i,i if it needs more than that first list element to produce even a partial result, then the fold will be partial
11:07:35 <EvanR> f 0 ( could diverge
11:08:03 <geekosaur> followed by the next invocation of f, so you get infinite output for an infinite list --- except that if whatever's consuming the result doesn't finish (as with lambdabot chopping by length and adding "…" at the end), your fold doesn't diverge
11:09:37 <geekosaur> this is because of laziness; it doesn't actually compute a partial result until that result is demanded by something. if the thing consuming the result of the fold demands all of it, of course, it will diverge regardless
11:10:17 <monochrom> gehmehgeh: If you see a persuading piece of writing that would get an A+ from an essay teacher, and an empirical experiment, and those two things disagree with each other, which one do you believe and which one do you call "BS"?
11:11:02 <monochrom> because you can test empirically "foldl (||) True (repeat True)" and "foldr (||) True (repeat True)"
11:11:27 <gehmehgeh> monochrom: hold on...
11:11:48 <gehmehgeh> aaahh
11:11:49 <gehmehgeh> Thanks
11:13:11 <monochrom> me, if I see any persuading essay that concludes the opposite of the empirical observation, I'll call the essay BS and throw it away. I won't even waste time finding out where it goes wrong. life is too short to debug every essay written by random strangers on the internet.
11:13:59 <shachaf> Speaking of writing, Hutton is publishing a second edition of _Programming in Haskell_.
11:14:51 <gehmehgeh> monochrom: I'm splitting hairs here, but is there "nonempirical observation"? ;)
11:15:08 <gehmehgeh> ;-)
11:15:09 <koala_man> I can easily see the mistake. If you're not used to fp or lazy eval, you might think that folding from the right would mean finding the end and going backwards
11:15:25 <gehmehgeh> Thanks for the help
11:16:36 <shachaf> The first edition was good but outdated at this point; I'm glad that there'll be an up-to-date version (which will hopefully still be good).
11:16:49 <monochrom> gehmehgeh: I guess my redundant wording is for emphasis only. don't worry, I also wrote http://www.vex.net/~trebla/humour/tautologies.html #9
11:17:08 <shachaf> Finally I'll have a recent book to recommend to people who want to learn Haskell.
11:17:37 <koala_man> would hallucinations count as nonempirical observations?
11:19:06 <gehmehgeh> shachaf: I want to learn Haskell :>
11:19:39 <gehmehgeh> monochrom: interesting :D
11:19:42 <geekosaur> observations can be partial too :) I expect an empirical observation to be explicit about any partiality (e.g. observed X, but not how X came about)
11:20:37 <geekosaur> in fact that's a large chunk of the difference between a science article for popular media vs. a scientific research paper
11:24:27 <EvanR> gehmehgeh: unempirical observation... perhaps a euphemism for "talking out your ass"  ? ;)
11:25:13 <glguy> monochrom wrote monochrom's list of tautologies?
11:25:20 <monochrom> yes!
11:25:27 <monochrom> hehe
11:25:51 <EvanR> koala_man: thats a mixup of arbirary descriptions... foldr folds *to* the right...
11:26:12 <glguy> no, foldr associates the function applications to the right
11:26:45 <EvanR> and the string of applications proceeds right
11:26:52 <EvanR> due to laziness
11:26:58 <glguy> OK, (I probably didn't need to say "no")
11:28:00 <koala_man> if you implemented it imperatively, it would start on the right. 
11:28:17 <EvanR> i wouldnt implement it like that
11:28:20 <glguy> imperatively doesn't mean strictly
11:28:38 <glguy> if you wrote it imperatively you'd also "start from the left"
11:29:02 <glguy> and it's a linked list, you always "start from the left"
11:29:17 <EvanR> well if you had an array
11:29:22 <glguy> or a dog
11:29:39 <EvanR> reading into what imperative would imply
11:30:06 <EvanR> > foldr (:) [] [1,2,3,4]
11:30:08 <lambdabot>  [1,2,3,4]
11:30:16 <EvanR> hmm
11:30:46 <EvanR> head explode
11:31:03 <koala_man> I would probably have done T sum = z; for (auto it = list.end(); it != it.begin(); it--) sum = f(sum, *it); 
11:31:27 <koala_man> just off by less
11:32:43 <EvanR> > foldl (flip (:)) [] [1,2,3,4]
11:32:45 <lambdabot>  [4,3,2,1]
11:33:12 <EvanR> i guess everything i know is wrong
11:34:23 <geekosaur> confusion can be the beginning of enlightenment :)
11:38:40 <mjrosenb> does anyone use haskell on freebsd? cabal is segfaulting on me :-(
11:38:58 <glguy> Yes, Haskell can be used on FreeBSD
11:40:11 <R0B_ROD> bored at the movies with the kids...finding dory...oh lord
11:41:29 <gehmehgeh> mjrosenb: you could ask here: #haskell-Freebsd 
11:42:00 <koala_man> R0B_ROD: don't use cell phones in the theater! 
11:42:17 <glguy> mjrosenb: and you can ask here, too
11:42:49 <R0B_ROD> at very back and in previews thanks
11:43:09 <mjrosenb> so, has anyone fixed the issue of cabal segfaulting on freebsd?
11:43:13 <koala_man> does the movie theater serve beer? that helps a lot
11:44:05 <glguy> Lamenting time with the family and rules about cell phone use in theaters are better for #haskell-offtopic
11:45:32 <EvanR> cant wait for a haskell movie
11:45:47 <Phyx-> oh, Who will play the Simons?
11:45:56 <Rotaerk> it's what hackers use to program viruses
11:46:28 <glguy>  /mode +qqq EvanR Phyx- Rotaerk
11:46:29 <EvanR> hollywood OS will be replaced with animated diagrams or gloss demos
11:54:36 <johnw> EvanR: a haskell movie: the same viewer will always have the same experience watching it
11:56:00 <EvanR> dejavu same topic previously about statefulness is video games like stanley parable
11:56:19 <EvanR> statefulness in movies
11:58:49 <merijn> Ya ever get that feelin' o' deja vu?
11:59:10 <ggVGc> man, just got deja vu. I could swear someone was 
11:59:13 <ggVGc> JUST talkinga bout it
12:08:17 * hackagebot pcg-random 0.1.3.4 - Haskell bindings to the PCG random number generator.  https://hackage.haskell.org/package/pcg-random-0.1.3.4 (cchalmers)
12:13:17 * hackagebot ghcjs-perch 0.3.2 - GHCJS version of Perch library.  https://hackage.haskell.org/package/ghcjs-perch-0.3.2 (geraldus)
12:27:12 <malice> Hi! I've got a question. Haskell has its lists look like this: [1,2,3].
12:27:21 <malice> Why are there commas?
12:27:30 <malice> Why not use (white)spaces instead?
12:27:32 <byorgey> hi malice!
12:27:38 <malice> Hello, byorgey!
12:27:42 <geekosaur> :t 1 2
12:27:43 <lambdabot> (Num a, Num (a -> t)) => t
12:27:45 <byorgey> malice: because Haskell uses space for function application.
12:27:50 <jle`> malice: [x y z] is potentially interpreted as the application of the function 'x' to the values y and z
12:28:11 <geekosaur> ...and it is possible to make Num instances fo rwhich that is valid. and even useful, for some definition of useful
12:28:23 <jle`> > [negate 1]
12:28:25 <lambdabot>  [-1]
12:28:48 <dmj`> malice: also, what if you forgot a whitespace, [12 3] ? that would be valid
12:28:48 <malice> Oh, that's why. Thanks for info!
12:29:35 <byorgey> dmj`: I dunno, the same argument applies to forgetting a comma, which would imply we need more than just commas to separate list elements, because what if you forget one?
12:29:53 <thimoteus> >[12,3]
12:31:47 <geekosaur> guess someone's having "fun" with freenode again :/
12:32:27 <thimoteus> huzzah for ignoring joins, parts and quits
12:33:00 <dmj`> byorgey: yes, I guess that argument doesn't hold too well :)
12:34:52 <senoj> act
13:25:07 <fr33domlover> diagrams question: How do I draw text inside a box, such that the box size depends on the text size? Should I use SVGFonts for the text, query its size, use this to set the box size? or is there some elegant wrapping API?
13:25:22 <fr33domlover> (I'm just starting to use diagrams)
13:27:08 <byorgey> fr33domlover: with the default text API, text has no size, so yes, if you want the size of the box to depend on the size of the text, you have to do something a bit different
13:27:59 <byorgey> fr33domlover: options include (1) SVGFonts (pro: backend-agnostic; con: it is very slow) (2) using the Text module of the Cairo backend, or (3) using the PGF backend, which lets you typeset text using LaTeX and query it for the size
13:30:08 <byorgey> fr33domlover: also, feel free to join us in #diagrams
13:30:22 <fr33domlover> byorgey, currently I generate the diagram in a web app upon HTTP request. Currently using the SVG backend. Would SVGFonts make things too slow for this use case?
13:30:29 <fr33domlover> (cool, joining)
13:30:59 <byorgey> fr33domlover: it depends how much text you have
13:31:58 <byorgey> fr33domlover: also, there is no particular reason SVGFonts must *necessarily* be slow, we just haven't been able to figure out how to optimize it.  There must be some low-hanging fruit there to speed things up dramatically, we just don't know what it is yet
13:32:27 <fr33domlover> byorgey, diagram with usually less than 20 boxes with one-word text in each, connected with arrows (Hasse diagram)
13:34:22 <GLM> What are the uses of Hasse diagrams? I saw them in Kmett's talk but don't know how they're used
13:35:17 <byorgey> GLM: a Hasse diagram is just a way to visualize a partially ordered set
13:35:20 <buglebudabey> i want to make a chat robot that deals with portuguese, is there an easy way to generate alex and happy files to deal with the top 1000 words without entering each word manually?
13:36:08 <merijn> buglebudabey: Write some code to generate the code? ;)
13:36:41 <buglebudabey> too easy i'm looking for the wrong way
13:36:44 <buglebudabey> thanks :P
13:37:12 <merijn> Whenever you are faced with writing repetitive boilerplate code it can always be turned into less repetitive and less boilerplate code that generates said code :p
13:37:27 <RedNifre> Hi.
13:39:23 <RedNifre> I have this function that I believe to be total, yet my server log shows an error "Non-exhaustive pattern in function foo". How can I get better debug output? (I can't reproduce it so I want to recompile with a more helpful output for when it happens again).
13:39:47 <RedNifre> Is there something like 'foo a b c = crashAndLog a b c' ?
13:40:14 <quchen> RedNifre: Compile with -Wall and the compiler will tell you which pattern cases are missing.
13:40:44 <RedNifre> ah, just cabal build -Wall ? Thanks, I'll try that...
13:40:57 <byorgey> RedNifre: quchen's advice is the best, but to answer your question, you can add a catch-all case at the bottom of foo,  foo a b c = error $ "incomplete pattern match: " ++ show (a,b,c)     or something like that
13:41:00 <quchen> GHC has an option to show missing pattern cases.
13:41:10 <quchen> -Wall includes that warning
13:41:22 <RedNifre> Thanks as well.
13:41:23 <quchen> I forgot what the specific flag was. -Wincomplete-patterns or something.
13:43:22 * hackagebot octane 0.12.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.12.0 (fozworth)
13:46:00 <fr33domlover> byorgey, the way I see is to use the 'width' function (which queries the size of an Enveloped) to get the size of the text. Is that the way?
13:46:16 <merijn> You should generally always use -Wall and selectively disable things
13:46:35 <merijn> Some surprisingly important things are not warned about by default
13:47:33 <RedNifre> hm, it's been over a year since I last did anything in Haskell, I only remembered that I compile the package with 'cabal build'. Wasn't the regular compiler only for self contained code that only used the standard library? Or how do I compile my package with -Wall?
13:48:13 <glguy> You can set additional ghc options at configure time: cabal configure --ghc-options=-Wall
13:48:17 <glguy> or you can put them in your .cabal file
13:48:24 <byorgey> fr33domlover: if you use SVGFonts to generate the text, yes.  If you just use the 'text' function you will get a width of 0.
13:48:30 <glguy> In that case you add them to your ghc-options: section
13:48:58 <RedNifre> which option do you recommend?
13:49:19 <fr33domlover> byorgey, thanks.Yeah I use SVGFonts because 'text' doesn't know the width
13:49:22 <RedNifre> I guess putting it in the .cabal makes more sense so I won't forget about it if I compile it on a different machine, huh?
13:49:23 <glguy> one is more permanent than the other, so use the one that does what you want
13:52:59 <RedNifre> Alright. There's no ghc-options section so I guess it's just "ghc-options: Wall"... or is it "ghc-options: -Wall"? 
13:53:14 <RedNifre> or ghc-options: "-Wall" ?
13:53:24 <RedNifre> (I'm googling in parallel, feel free to ignore my questions ;)
13:53:38 <geekosaur> ghc-options: -Wall
13:53:45 <RedNifre> Thank you.
13:56:13 <slack1255> I am interested in modeling brownian motion. Is there any useful packages lying around?
13:56:26 <slack1255> Or should I do a combination of hmatrix + statistics + opengl?
13:56:54 <peddie> slack1255: possibly accelerate, for stochastic PDE type things?
13:57:29 <slack1255> It would be good also. But mainly I want to see if somebody already did the work for me
14:02:58 <RedNifre> how can i check whether I'm in a sandbox or not?
14:04:07 <quchen> RedNifre: Checking whether there's a .cabal-sandbox directory is a good first order approximation.
14:04:27 <suppi> RedNifre, cabal sandbox? use `ls` to see if theres a cabal.sandbox.config
14:04:35 <suppi> file
14:04:54 <joncfoo> Does anyone have experience with `logging-effect`?  I'm trying to understand how to use MonadLog in a transformer stack & I'm a bit confused by the kind of MonadLog
14:05:52 <dmj`> joncfoo: logging-facade is a good library
14:05:59 <dmj`> @package logging-facade
14:05:59 <lambdabot> http://hackage.haskell.org/package/logging-facade
14:06:37 <RedNifre> okay, so my main package is in a sandbox but the other package of mine that has the error in it is not. Adding ghc-options to both did not print any warning when compiling the main package so I'll put the library package in a sandbox as well and compile it directly...
14:06:37 <joncfoo> I am not smort
14:06:43 <joncfoo> I answered my own dumb question
14:06:47 <RedNifre> the ghc-options go in the executable/library section, right?
14:06:59 <joncfoo> I was confusing MonadLog with LoggingT =\
14:07:26 <fr33domlover> RedNifre, yes
14:07:41 <joncfoo> dmj`: one reason I like logging-effect (at least from the docs) is that it allows you to log types & also purely get them out
14:08:00 <joncfoo> so I don't have to write to disk or /dev/null during testing
14:09:22 <dmj`> joncfoo: what do you mean 'log types'?
14:09:35 <fr33domlover> monad-logger allows that too, there's even an instance that uses a Chan to send the log messages
14:09:59 <joncfoo> dmj`: you can log data structures
14:10:02 <fr33domlover> (and then you can read from the Chan in a dedicated thread and do whatever you like with the logs)
14:10:07 <reqq456> can someone explain me or give me a good link to read why 'Data.Set.insert 4 $ Data.Set.fromList [9,3,8,1]' is working, 'Data.Set.insert 4 (Data.Set.fromList [9,3,8,1])' too but 'Data.Set.insert 4 . Data.Set.fromList [9,3,8,1]' not, even it should be the same - at least what i've thought - like the middle method because it would be fog = f(g x), what is wrong in my mind?
14:10:31 <glguy> reqq456: f . g x means:     f . (g x)
14:10:35 <dmj`> joncfoo: when wouldn't it be possible to log data structures
14:10:56 <Squarism> anyone use atom for haskell?
14:11:06 <glguy> Squarism: lots of people, probably
14:11:09 <joncfoo> fr33domlover & dmj`: I didn't know that you could log types in monad-logger
14:11:22 <RedNifre> Squarism not yet, but that sounds like an interesting idea.
14:11:22 <Squarism> just wondered if its recommended
14:11:23 <fr33domlover> reqq456, it will work if you use "f . g $ x"
14:11:53 <fr33domlover> i.e. put an $ there, or enclose (f . g) in parens
14:11:55 <joncfoo> in any case I like that logging-effect comes built in with the async part of outputting logs so I don't have to build my own (however trivial that might be)
14:12:01 <RedNifre> Haven't used Haskell in over a year, I'd like to get back into it. Back then I only used it very amateurishly in vim. I heard there's an Atom-based Haskell IDE, is it any good?
14:12:32 <reqq456> i've used it but i just switched to vim Squarism 
14:12:50 <suppi> i heard atom is at least decent for haskell
14:12:55 <fr33domlover> joncfoo, what do you mean by logging types?
14:13:00 <suppi> but I use emacs
14:13:10 <reqq456> atom is in my opinion the best gui editor i've ever used
14:13:11 <RedNifre> I'm currently on OpenBSD. THere's a Haskell plugin for vim but when I open a .hs file I get an error because "the compiler is not supported" =/
14:14:16 <RedNifre> There's vim mode for Atom so I think I'll look into using it for Haskell.
14:14:24 <reqq456> i dont use any plugins
14:14:31 <reqq456> i just made my own keymappings
14:14:47 <suppi> RedNifre, why not evil-mode for emacs? :)
14:14:59 <RedNifre> I strongly recommend using plugins, there's a plugin for everything in Atom.
14:15:21 <reqq456> i meant vim
14:15:29 <RedNifre> I haven't tried Emacs yet, my understanding is that Atom and Emacs are kinda the same except that you write emacs plugins in elisp and atom plugins in coffeescript.
14:15:40 <joncfoo> fr33domlover: sorry, incorrect jargon. I meant data structures
14:16:25 <sm> RedNifre: both the atom plugins are pretty good as long as ghc-mod can handle your project (it has trouble with eg multi-package stack projects)
14:16:46 <RedNifre> What do all the Haskell experts use? Emacs?
14:17:26 <fr33domlover> joncfoo: you can log anything that has a Show instance, and even if some library just takes String or Text, use 'show' in your own code
14:17:35 <crough> RedNifre: that or vim, really
14:17:45 <kadoban> Emacs and vim are popular. I don't think there's anything approaching a consensus amongst haskellers.
14:17:51 <fr33domlover> Unless you mean some smart pretty printing, logging ADTs is trivial
14:17:54 <suppi> some people use atom, some vim, some emacs, some sublime, some something else
14:17:54 <dmj`> RedNifre: haskell-mode is just so good
14:17:59 <fr33domlover> (if they have Show instance)
14:18:00 <suppi> just pick your poison
14:18:03 <kadoban> (not that those are the only two even, by a long shot)
14:18:05 <crough> leksah as well if you want an ide
14:18:32 <RedNifre> what do you mean by multi-package stack projects? Haven't looked at stack yet, it's a better cabal, right? I guess I'm currently doing "multi package projects", since I have about 5 package folders, 4 of them are libraries, 1 is an executable that I build by having cabal sandbox add-source theOther4Packages...
14:18:37 <suppi> I felt that haskell-mode (emacs) had the best haskell support so i moved from vim to emacs
14:19:53 <RedNifre> I only used vim and atom so far (haven't looked at emacs or sublime) so maybe I'll give emacs a try next.
14:20:24 <fr33domlover> Why is Yi not catching some attention?
14:20:42 <fr33domlover> Just curious, anyone has experience with it?
14:21:12 <RedNifre> What's Yi?
14:21:19 <sm> RedNifre: intellij also works well
14:21:23 <fr33domlover> @hackage yi
14:21:23 <lambdabot> http://hackage.haskell.org/package/yi
14:21:27 <itnex> a text editor written in haskell
14:21:28 <fr33domlover> RedNifre, ^
14:21:37 <fr33domlover> and extensible in Haskell
14:21:45 <fr33domlover> (like Emacs is in ELisp)
14:21:57 <RedNifre> Urgh, building my package with -Wall gave me 18 pages of warnings, guess I'll have work to do :)
14:22:21 <itnex> i tried it but i think i ran into some performance issues vs vim
14:22:27 <itnex> i dont really remember though
14:23:05 <kadoban> RedNifre: Nice :)
14:23:47 <RedNifre> Well, an editor that is extensible in Haskell sounds fun in theory, but given that Atom is extensible in CoffeeScript/Javascript I expect it to become the most powerful editor eventually.
14:24:27 <magneticduck> it's difficult to imagine an editor more powerful than emacs to come about within a reasonable timeframe
14:25:09 <magneticduck> to be considered an OS, it probably just needs slightly better support for threading
14:25:49 <magneticduck> just being extensible in a language doesn't mean a whole lot
14:25:55 <RedNifre> Well, Javascript is the most popular language in the world. My Atom editor has plugins for vim-mode, an integrated terminal, compiling latex, viewing the resulting pdf, a browser, parinfer which places clojure parens based on indentation...
14:26:24 <itnex> isn't it slow though?
14:26:27 <magneticduck> have you used emacs?
14:26:29 <RedNifre> extremely.
14:26:43 <RedNifre> haven't tried emacs, maybe I should.
14:26:48 <kadoban> atom? It's kind of laggy here and there, it's not bad though. It's improved a lot compared to how it first was.
14:26:51 <magneticduck> it's not just atom with a different extension language
14:26:56 <magneticduck> it's a whole .. world
14:27:07 <itnex> i dont understand why people love emacs so much
14:27:20 <RedNifre> For me it takes a couple seconds to start but is fast enough once it's running.
14:27:31 <RedNifre> how is emacs more a whole world than atom?
14:27:34 <glguy> Generic editor discussion will be better in #haskell-offtopic
14:27:42 <RedNifre> sorry
14:28:04 <glguy> And #haskell-offtopic isn't a penalty box, no harm in joining
14:29:48 <sm> RedNifre: there's also #haskell-ide for this topic
14:30:21 <RedNifre> Here's another haskell question: Until a moment ago only my executable package was in a sandbox, the 4 library packages it depends on weren't. I couldn't figure out how to print warnings though (there's a non-exhaustive pattern match in one of the library packages) so in order to see those warnings I created another sandbox for that library package. Since this gave me 18 pages of scary warnings I think I
14:30:22 <RedNifre> should check the other 3 library packages for warnings again. Is there a simpler way to do that than creating more sandboxes? Why don't I see warnings for the dependencies when I compile the main executable?
14:30:58 <RedNifre> sm thanks for the hint
14:33:38 <platz> so aparrently I found a bug in Data.Derive on ghc 8.0.1 yesterday. https://github.com/ndmitchell/derive/issues/17. in my quest to understand "Bang NoSourceUnpackedness SourceLazy", apparently the issue was "I suspect the constructors are either strict, lazy or default. Within a module they are default, but once they leave a module they get given explicit values."
14:34:57 * RedNifre waves at pyon
15:08:58 <joncfoo> if I want to carry around a function (A a -> B a) in a Reader without binding 'a' to a specific type, what are my options?
15:09:26 <joncfoo> oh and the function would be in a Record
15:09:37 <johnw> you'd need ImpredicativeTypes
15:09:43 <glguy> joncfoo: with RankNTypes extension you can do that
15:09:57 <johnw> data Foo = Foo (forall a. A a -> B a)
15:10:04 <glguy> 03newtype AtoB 07= AtoB (forall t07. A t 07-> B t)
15:10:11 <joncfoo> ah!
15:10:34 <joncfoo> this is my first time running across a use case for RankNTypes without realizing it
15:10:36 <joncfoo> :)
15:10:45 <johnw> if it's in a record, it will be more than RankNTypes
15:11:19 <glguy> No, it would be the same there. The ImpredicativeTypes requirement is if you have a generic record and you wanted to instantiate it to a polymorphic type
15:11:36 * joncfoo goes and tries RankNTypes first
15:11:53 <glguy> Like data MyRecord a = MkMyRecord { this, that, theother :: a }, and then tried to use:  MyRecord (forall t. A t -> B t)
15:12:00 <Cale> Which is a good thing, since ImpredicativeTypes is always janky and broken, and this ability to have polymorphic record fields is pretty important.
15:12:11 <RedNifre> That's odd, I added a catch-all match `foo a = error $ "No match for " ++ show a`, but that doesn't seem to go into the executable. I also added some more empty lines before foo to see if that changes the line number of the error; it didn't. I also increased the version number of my library package in both cabal files, why does the executable seem to include the old library source code?
15:12:12 <johnw> ah, ok, thanks glguy 
15:12:49 <kadoban> RedNifre: What are you building with?
15:13:03 <RedNifre> cabal build
15:13:14 <kadoban> :-/ I don't know cabal very well
15:13:32 <RedNifre> the executable is in a cabal sandbox and it has cabal sandbox add-source ../thelibrarypackage
15:13:39 <RedNifre> well, how do you build?
15:13:48 <kadoban> stack
15:14:12 <RedNifre> I heard it's the better cabal, is it mainstream yet?
15:14:33 <kadoban> It's pretty commonly used, yeah.
15:14:57 <RedNifre> guess I should switch to it then. But not today.
15:15:09 <RedNifre> Is there a cabal justrecompilethewholethingdammit command?
15:15:31 <kadoban> I'm fairly sure there's a relatively easy answer in cabal to this, I just don't know it :-/
15:15:36 <peddie> RedNifre: cabal clean && cabal build ?
15:15:54 <peddie> if cabal build doesn't work
15:17:09 <RedNifre> well, cabal build seems to work, it's just that the resulting binary seems to use an outdated version of my local library package.
15:18:11 <RedNifre> after cabal clean, cabal build no longer works because it doesn't find the local library package anymore. Does cabal clean remove the 'cabal sandbox add-source ../mylibrary' as well?
15:18:25 <peddie> shouldn't . . .
15:18:30 <hexagoxel> does not
15:19:58 <RedNifre> strange... should I throw in a cabal install --dependencies-only? Or should cabal build cover that?
15:20:44 <RedNifre> Can I list the current sources that I added with cabal sandbox add-source ?
15:21:13 <hexagoxel> but the add-source may have get lost somehow before, with the old install of your local lib remaining in the sandbox.
15:21:36 <senoj> cabal sandbox list-sources
15:22:05 <hexagoxel> explaining the not-updating behaviour, but not that it is now broken..
15:22:17 <senoj> RedNifre: cabal sandbox --help for help
15:22:22 <hodapp> achievedment unlocked: free-monad'ed a... thing
15:22:30 <hodapp> Chobbes would be proud
15:22:39 <RedNifre> hm, the dependency is listed...
15:23:45 <RedNifre> hexagoxel but shouldn't it update if I change the dependency version? Hm, I guess only changing the fourth version digit isn't enough, huh?
15:24:33 <hexagoxel> no, it should reinstall. but i have seen updates breaking before too, stuff is not very reliable.
15:25:04 <hexagoxel> throwing `install local-dep` at it fixes it normally.
15:26:25 * geekosaur wonders if new-build works better
15:26:28 <geekosaur> (1.24 only)
15:26:36 <idev> what happened to the liskell project? has it become believed that haskell semantics with lisp syntax is a bad idea?
15:27:57 <johnw> I'm not sure syntax really matters that much; it probably died because just no one else really cared enough
15:29:57 <kadoban> I would think that the union of the set of people who really care about syntax much and the set of people who are into haskell isn't huge
15:30:24 <idev> I'm strugglig to figure out how to deal with both (+ 1 2 3) and partial application
15:30:41 <RedNifre> I guess people who want functional programming and lisp syntax are already using Clojure.
15:31:08 <kadoban> Or scheme or racket or ...
15:32:38 <thimoteus> last commit on the repo i'm looking at is 7 years ago
15:32:55 <ics> I vaguely call watching or reading something by a blind (I think) haskeller who said they ended up using a ton of braces and semicolons
15:33:07 <ics> which worked but looked funny to coworkers obviously
15:33:35 <RedNifre> hexagoxel Thanks a lot, that got it to compile with the new code :)
15:33:35 <ics> lispy haskell might be much nicer there
15:42:40 <joncfoo> glguy, johnw: turns out I only needed Rank2Types for what I was trying to do
15:42:42 <joncfoo> thanks!
15:43:04 <Gurkenglas> How much would type inference be broken by treating a, () -> a, ((),a) and (a,()) as the same type?
15:43:41 <Gurkenglas> (In the sense of, would type inference leave P?)
15:43:44 <crough> Gurkenglas: almost all of it, I think, because of the case of just 'a'
15:43:54 <glguy> joncfoo: Rank2Types isn't a thing any more, it turns on RankNTypes
15:44:23 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XRank2Types
15:44:36 <Hijiri> I think type inference is already not in P
15:44:55 <Hijiri> just in most cases you get much better than worst case time
15:45:23 <josephle> Grukenglas: you should be thinking about whether or not type inference becomes undecidable
15:45:29 <josephle> erm Gurkenglas^
15:46:07 <joncfoo> glguy: oh I didn't know that
15:47:17 <R0B_ROD> Well I slept almost the entire movie
15:47:29 <R0B_ROD> finally home and had breakfast
15:48:11 <R0B_ROD> Ive installed haskell-platform for my OpenBSD system. Now I have to start playing with it
15:48:51 <enthropy> Gurkenglas: what happens if `a` is already a function or a tuple?
15:49:01 <koz_> R0B_ROD: Must have been a fascinating movie.
15:49:05 <Gurkenglas> The same, of course.
15:49:15 <Gurkenglas> () -> a -> b = a -> b = a -> () -> b
15:49:55 <Gurkenglas> a = () -> (() -> (), (a, ()))
15:50:42 <enthropy> I mean if you're interpreting them as an implicit conversion, this means that (a,b) might be `a` or `b` depending on whether one is ()
15:50:42 <R0B_ROD> koz_: well...for the kids it was... Finding Dory.. but I had onlt 3 hrs of sleep so thats why
15:50:45 <glguy> koz_ R0B_ROD: The movie chat is still off-topic in #haskell
15:51:11 <kadoban> Is there a recommended basic introduction to rankntypes? I feel like I should at least know what I'm missing.
15:51:21 <dmj`> kadoban: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
15:51:40 <Gurkenglas> enthropy, well they wouldn't be syntax sugar for a or b, i can see how nonworking that would turn out
15:51:42 <kadoban> Thanks
15:51:43 <R0B_ROD> Forgive me. I forget that we are being logged and recorded
15:51:44 <johnw> kadoban: if you're familiar with functions as values, then rankntypes is polymorphic functions as values
15:52:09 <enthropy> Gurkenglas: it might work, after all there's numeric defaulting, but I think "treating them the same" is a bit vague
15:52:14 <johnw> R0B_ROD: that's not why; this is a channel for discussion of Haskell, it's not just a social space
15:52:26 <koz_> glguy: Sorry about that. I didn't actually think I'd get more than a 'lol' response.
15:52:48 <kadoban> johnw: I can read that sentence, and I know every part of it, but together it just doesn't seem to click, I can't quite wrap my head around what it lets me do somehow :-/
15:53:22 <johnw> kadoban: take a function type (forall a. a -> a) -> b -> b
15:53:40 <johnw> if I pass 'id' as the first argument to that function, I'm not passing a particular instance of 'id' fixed at certain types inferred by the compiler
15:53:52 <johnw> I'm passing the fully polymorphic definition of id, which that function is then free to use to apply to 'b'
15:54:02 <johnw> but (a -> a) -> b -> b is not implementable
15:54:10 <johnw> well, sorry, bad example, it is
15:54:16 <johnw> but not by using it's function argument
15:54:24 <kadoban> Ohhh. Oh okay, that made sense.
15:54:36 <kadoban> Yeah, the only non-bottom is just  const id  or whatever, right?
15:54:58 <kadoban> s/non-bottom/total/ probably
15:55:30 <johnw> foo k x = k x is one implementation of the first type
15:55:41 <johnw> foo _ x = x is the only implementation for both types or the second type
15:55:56 <Gurkenglas> josephle, yea thought about asking it that way but decided P cuts closer to the joint of should-i-give-this-idea-up instead of UNDECIDABLE's can-i-prove-this-property
15:56:03 <johnw> I'd suggest palying around with this in a Haskell file
15:56:10 <kadoban> Right, thanks. That's pretty cool.
15:56:27 <kadoban> I'll read the blog post and then play some. Your example I completely understand though, that helps.
16:01:35 <johnw> it should also be pointed out that rankntypes relates to polymorphic values, not just polymorphic functions, aka (forall a. Foo a), etc.
16:02:38 <shachaf> I prefer Kelvin types to Rankine types, personally.
16:02:55 <glguy> shachaf: The topic of #haskell is Haskell programming
16:02:59 <glguy> not funpuns
16:03:09 <glguy> ^_^
16:07:27 <glguy> > rot13 "shachaf: I prefer Kelvin types to Rankine types, personally."
16:07:29 <lambdabot>  "funpuns: V cersre Xryiva glcrf gb Enaxvar glcrf, crefbanyyl."
16:09:20 <mniip> funpuns
16:23:29 * hackagebot cron 0.4.1.2 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.4.1.2 (MichaelXavier)
16:30:11 <dolio> The secret's out.
16:37:47 <pikajude> is there a package that could automatically define an Arbitrary instance for some datatype I have of the form data Foo = A | B | C | ... | Z
16:37:57 <pikajude> i.e. all normal constructors with no arguments
16:38:27 <kadoban> pikajude: Is it Enum and Bounded?
16:38:29 <johnw> pikajude: yes
16:38:35 <johnw> pikajude: there's a package on hackage that does that
16:38:42 <pikajude> I could make it enum and bounded
16:38:47 <pikajude> johnw: what is it?
16:38:56 <johnw> don't remember, but it's there :)
16:39:00 <pikajude> neat
16:39:03 <Koterpillar> derive makeArbitrary ''Foo
16:39:22 <Koterpillar> 'derive', Data.DeriveTH
16:39:31 <pikajude> wow, derive is a really big package
16:39:51 <kadoban> pikajude: It's a one-liner if it is even without a package, though I think there's some assistance somehow too. Oh I didn't know about that one.
16:39:51 <pikajude> but it doesn't have many dependencies, so it looks good
16:40:55 <Enigmagic> pikajude: also http://hackage.haskell.org/package/generic-random
16:41:51 <codebje> hm, how could it be that ghci will load a file fine, but ghc will spit a parse error at me?
16:41:58 <Enigmagic> newer, not sure how good it is.. but the idea is interesting https://www.reddit.com/r/haskell/comments/4dyrqq/a_library_of_boltzmann_sampling_for_generic/
16:42:16 <codebje> ah, I get the error in ghci now, had to restart it
16:42:43 <kadoban> pikajude: I can't find the package I was thinking of :-/
16:45:08 <kadoban> This rankntypes blog post thing is really mind-bending. I've never seen these alternate formulations for lists before.
16:46:13 <EvanR> frankentypes
16:46:25 <EvanR> ^ ghc halloween extension
16:46:39 <kadoban> Hehehe
16:47:16 <kadoban> Now I'm always going to read it as frakentypes. You've ruined my mind.
16:50:28 <geekosaur> neh, rankntypes are just the enabler. the real frankentypes are impredicativetypes :p
16:51:39 <hpc> incoherent types are an eldrich horror
16:52:20 <glguy> More specifically "incoherent instances"?
16:52:27 <hpc> er, that
16:53:03 <hpc> i meant to write instances and it came out as types, not even sure how that happened
16:53:29 <EvanR> expressions have a new form too
16:53:43 <EvanR> abby-normal form
17:00:51 <athan> so `callCC` is lets you run your continuation monad from within the monad itself?
17:01:09 <johnw> I don't understand that question
17:01:12 <athan> Wait nevermind
17:01:28 <athan> you're still in the continuation monad after you use it
17:02:04 <EvanR> it executes a "functional goto"
17:02:22 <EvanR> er, it executes a functional setjmp
17:02:24 <johnw> callCC gives you a binding for the continuation
17:02:25 <athan> EvanR: Where there's only one goto though,r ight?
17:02:54 <EvanR> you can setup as many "current continuations" as you want
17:03:00 <johnw> where the continuation is whatever comes after the callCC itself
17:03:02 <athan> but using multiple callCCs would choose the first one, right?
17:03:11 <johnw> callCC doesn't do anything
17:03:17 <johnw> it just provides you with access to the continuation
17:03:28 <johnw> if you never use it, it's equivalent to never calling it
17:03:49 <EvanR> yeah the goto is to use the k it gives you later on
17:04:41 <athan> > flip runCont show $ callCC (\show' -> show' 1) >> callCC (\show' -> show' 2)
17:04:43 <lambdabot>  "2"
17:04:46 <athan> hrm
17:05:14 <johnw> think of a sequence of Cont actions as a series of functions, where the end of each function calls the next; callCC is giving you a binding to the next function in that series, a function you can call again (from within Cont) at a later time
17:05:19 <athan> right on, thank you EvanR & johnw, judiciously helpful as always :)
17:05:53 <athan> johnw: Okay wow that's nuts
17:06:20 <athan> > flip runCont show $ callCC (\show' -> pure "3") >> callCC (\show' -> show' 2)
17:06:21 <lambdabot>  "2"
17:06:48 <athan> I'm not sure how this first use of `callCC` does this johnw
17:07:03 <johnw> your first use of callCC is equivalent to its not being there
17:07:14 <johnw> since you don't use its result value, nor do you use the continuation its providing you
17:07:34 <Koterpillar> > flip runCont show $ do { show' <- callCC; pure "3"; show'' <- callCC; show'' 2 }
17:07:35 <lambdabot>      Couldn't match expected type ‘ContT String Identity t0’
17:07:35 <lambdabot>                  with actual type ‘((a0 -> m0 b0) -> m0 a0) -> m0 a0’
17:07:35 <lambdabot>      Probable cause: ‘callCC’ is applied to too few arguments
17:07:52 <Koterpillar> oops. sorry :)
17:08:54 <athan> johnw: Are you saying that the continuation itself is mutable through callCC?
17:09:00 <johnw> not mutable
17:09:09 <johnw> I think you're overthinking exactly what Cont is
17:09:10 <athan> ahh okay
17:09:15 <athan> this makes sense then
17:09:18 <athan> sorry :)
17:10:02 <athan> > flip runCont show $ do {one <- callCC (\show' -> show' 1); callCC (\show' -> show' 2 ++ one)}
17:10:03 <lambdabot>      Couldn't match type ‘ContT String Identity’ with ‘[]’
17:10:03 <lambdabot>      Expected type: [a0]
17:10:03 <lambdabot>        Actual type: ContT String Identity a0
17:10:06 <athan> :x
17:10:30 <athan> > flip runCont show $ do {one <- callCC (\show' -> show' 1); callCC (\show' -> liftM (++ one) $ show' 2)}
17:10:32 <lambdabot>      No instance for (Show a0) arising from a use of ‘show’
17:10:32 <lambdabot>      The type variable ‘a0’ is ambiguous
17:10:32 <lambdabot>      Note: there are several potential instances:
17:10:35 <athan> >.>
17:10:41 * glguy points to /msg
17:10:42 <johnw> Cont is an abstraction of the difference betwen (f . g . h) x and \k -> h x (\y -> g y (\z -> f z k))
17:11:22 <athan> dang, thanks guys
17:11:27 <athan> (sorry glguy)
17:11:49 <athan> johnw: I'm going to have to go through this some more, but this is really enlightening, thank you!
17:11:53 <evincar> Is there a straightforward way to enumerate the rooted subtrees of a rose tree?
17:11:57 <evincar> E.g., given "data Tree a = Leaf a | Branch [Tree a]"
17:12:26 <athan> evincar: Like an arbitrary instance you mean?
17:12:30 <evincar> I would like subtrees (1 2) = (), (1), (2), (1 2)
17:12:33 <athan> That's like asking how you enumerate lists
17:12:42 <athan> oh okay the power set of the tree
17:12:59 <athan> I think that's its monad instance
17:13:17 <evincar> And subtrees (1 (2 3)) = (), (1), (()), ((2)), ((3)), ((2 3)), (1 ()), ...
17:13:39 <evincar> athan: Yeah, power set / all subsequences.
17:14:08 <athan> evincar: That will get pretty large btw
17:14:11 <athan> in memory
17:14:33 <athan> but it should be possible
17:14:36 <siwica> Being a haskell beginner I am wondering why the data cunstructor of Piece is not exported yet the data constructor of Field (http://lpaste.net/167363) 
17:15:10 <EvanR> you want the constructors exported?
17:15:22 <EvanR> you cant HANDLE the constructors exported
17:15:23 <siwica> only for Piece
17:15:25 <kadoban> siwica: That's a pattern the purpose of which is to prevent you from creating an invalid Field
17:15:43 <siwica> I know I wrote it myself
17:15:55 <kadoban> Then I don't understand the question.
17:16:15 <glguy> siwica: You wrote "Piece(..)", so all of Piece's data constructors are exported. You wrote "Field", so none of Field's data constructors are
17:16:28 <siwica> But in ghci ":t Field" yields "Field :: Char -> Int -> Field"
17:16:50 <siwica> And I thought I wouldn't export the data constructor of Field
17:17:11 <siwica> glguy: thats what I expected
17:17:13 <glguy> siwica: Presumably you're "inside" that module.
17:17:22 <EvanR> ghci can see everything in the current module
17:18:05 <geekosaur> also anything which ghci loads as bytecode will be visible even if not exported
17:18:17 <glguy> siwica: If the GHCi prompt has an asterisk next to the module name your scope is internal for that module, e.g. "*Module>" 
17:18:21 <siwica> I did :l Entities.hs in ghci which probably is not the correct way then?
17:18:39 <glguy> siwica: Try this now:  :m Entities
17:20:06 <siwica> this does not work although I start ghci from the directory that contains Entities.hs
17:20:15 <siwica> anything I am missing?
17:20:23 <glguy> Well, maybe you hadn't loaded the module yet
17:21:05 <glguy> :m just changes the modules that are in scope, it doesn't load them. You still have to use :l to load them
17:22:10 <siwica> ok, then that's what I was missing
17:22:12 <siwica> thank you!
17:35:48 <ski> athan : `callCC . const = id', `callCC . flip ($) = id'
17:36:35 <ski> er, sorry. `callCC . flip ($) = return', for the latter one
17:36:35 <athan> O_O
17:36:45 <athan> thanks ski!
17:36:47 <ski> athan : hence both  callCC (\show' -> pure "3")  and  callCC (\show' -> show' 1)  are trivial uses of `callCC'
17:37:15 <ski> not using the captured current continuation is the same as not capturing it
17:38:00 <ski> using the captured continuation immediately to "return" (via `return'/`pure') a value, but not otherwise using it, is the same as not capturing it (using `return'/`pure' instead)
17:38:35 <ski> continuations allow non-trivial control flow
17:40:12 <ski> they can allow you to transfer control from within one action to within another one, without the first one terminating execution by (monadically) returning a value to its calling context. then later you can "jump" back inside the first action, e.g. resuming execution from where you stopped
17:41:20 <ski> you can implement coroutines (or iterators, if you feel like) in this way. if you have some kind of timer-interrupt, you can implement time-slicing / multi-tasking concurrency (SML/NJ does this, iirc)
17:42:18 <ski> the simplest non-trivial use is probably to jump out of an action, using an earlier captured continuation, not jumping back in, thus effectively aborting that action
17:43:24 <ski> the difference between this and exceptions is that exceptions use dynamic scope, in the sense that you "jump" to the (dynamically) nearest exception handler (that can handle your exception). while with continuations, you jump to a statically determined place/position in the program
17:44:01 <acowley> Has anyone used the constraints package with GHC-8.0.1?
17:44:22 <ski> (you can implement exceptions with continuations plus some affordance for dynamic scope. i think Racket does this, though using a variant of continuations that are single-shot, and exit-only, for efficiency)
17:44:25 <acowley> I'm having some trouble at a use site, and not sure how hard I should think about it.
17:45:29 <ski> however, the strangest use of `callCC' is probably to capture a continuation, and then jump to it *more* than once, making (the same single invocation of) an action (monadically) return more than once !
17:48:52 <roboguy`> if I remember right, continuations can essentially be used to implement any form of control flow
17:49:30 <roboguy`> (of course in Haskell, you are limited to the inside of a Cont action, but at least within that)
17:50:28 <hpc> correct
17:50:58 <hpc> in that respect, Cont is the type of delimited continuations, with the delimiting being done by runCont
17:51:30 <hpc> (though internally there's one "global" continuation, making it a lot like State's "global state" behavior)
17:51:37 <hpc> er, not internally
17:51:41 <lpaste> acowley pasted “Why no refl?” at http://lpaste.net/167369
17:51:53 <acowley> That's the error I'm looking at
17:52:08 <hpc> at the level of writing Cont values, meant to say
17:52:57 <acowley> I want to use :=> as a constraint with a type function on one side, but it's boiling down to a refl, which doesn't have an instance
17:53:06 <acowley> as far as I can tell
17:54:31 <acowley> And I can't write an extra overlapping instance due to the fundep
17:54:47 <roboguy`> acowley: what is the code? You can't have instance for both '() :=> (Num Int)' (which exists already) and '(Num Int) :=> (Num Int)' because of the functional dependency saying the right argument determines the left one
17:55:20 <acowley> roboguy, right, but what I want is a constraint that says (TF x a :=> Num a) for some type family TF
17:55:20 <roboguy`> you should be able to weaken that precondition though
17:55:32 <acowley> And in this test case, TF x a = Num a
17:55:55 <acowley> But in teh function I'm interested in, x is unknown
17:56:11 <acowley> Maybe I should be more explicit
17:57:34 <acowley> Yeah, if I manually plumb the :- it's okay
17:57:37 <roboguy`> acowley: you can't just use (:-) values?
17:57:38 <acowley> But that kind of stinks
17:57:39 <roboguy`> ah
17:57:50 <acowley> I feel like a sucker writing my own values
17:58:50 <acowley> It's also quite tricky plumbing actually
17:59:39 <roboguy`> acowley: I don't suppose the unifier can solve it for you with just "Sub Dict"?
18:03:10 <roboguy`> or maybe the unifier could at least solve part of it like that (or something similar)?
18:05:36 <acowley> I added my own class that produces the necessary entailment
18:06:17 <acowley> The fundep really limits how usefulness of the :=> constraint former
18:06:43 <acowley> Also, I couldn't figure out how to use type applications for so many type parameters and just used proxies
18:06:49 <acowley> Blech
18:08:03 <ski> athan : see above for some more info on continuations
18:09:13 <ski> here's some perhaps not so trivial examples of using `Cont'/`ContT' :
18:09:28 <ski> @let argFC :: MonadCont m => m (a -> m a); argFC = callCC (\k -> return (\a -> k (\_ -> return a)))
18:09:29 <lambdabot>  Defined.
18:09:55 <athan> ski: Oh wow that's brilliant
18:09:57 <ski> `argFC' will generate a function which will always (monadically) return the argument that is first passed to it
18:10:22 <ski> for convenience (cf. `evalState',`evalWriter'), i also define
18:10:28 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
18:10:30 <lambdabot>  Defined.
18:10:35 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
18:10:36 <lambdabot>  Defined.
18:10:47 <ski> here's an example of `argFC'
18:10:55 <ski> > evalCont $ do f <- argFC; mapM f [0,1,2]
18:10:57 <lambdabot>  [0,0,0]
18:12:01 <ski> each execution of (the action returned by calling) `f' on a number in the list yields `0', because that's the argument of the first call (and execution) of `f'
18:15:21 <ski> the behaviour of `argFC' looks similar to using a mutable cell to record the argument of the first call. however, plain `callCC' can't express state, so one can't do full state effects with it (however, one can with *delimited* continuations (which you can express if you use `cont'/`ContT' directly, instead of just `callCC'). those are equal in power to continuations together with state (a single mutable cell, like `State s' suffices, so one can use `callCC
18:15:38 <ski> (er, cut off near ".. those are equal in power to continuations together with state (a single mutable cell, like `State s' suffices, so one can use `callCC' with `ContT o (State s)'))")
18:16:25 <ski> next example is a "twist" on `twice :: (a -> a) -> (a -> a); twice f = f . f'
18:16:35 <ski> @let twiceCC :: MonadCont m => (a,a -> m o) -> m (a,a -> m o); twiceCC (a,c) = callCC $ \k -> return (a,\a -> k (a,c))
18:16:36 <lambdabot>  Defined.
18:17:57 <ski> you can conceptually think of `a -> m o' here as `Not a'. with that reading, we have the type `(a,Not a) -> (a,Not a)', which by contraposition is `Not (a,Not a) -> Not (a,Not a)', which corresponds to `(a -> a) -> (a -> a)'
18:20:10 <ski> (contraposition says that `X -> Y' is equivalent to `Not Y -> Not X'. variants are that `Not X -> Y' is equivalent to `Not Y -> X' and that `X -> Not Y' is equivalent to `Y -> Not X'. these holds classically. constructively, the last equivalence holds, the middle doesn't hold, and the first only holds in the forward direction)
18:21:17 <ski> (logically speaking, continuations have to do with a computational interpretation of negation, including classical reasoning principles for it, like double-negation-elimination / proof-by-contradiction / law/principle-of-excluded-middle)
18:21:41 <ski> here's some variants of an example of using `twiceCC'
18:21:51 <ski> > evalCont $ liftM (fmap (10 :)) $ callCC $ \k -> do ((n,ns),k) <- twiceCC ((0,[]),k); k (n + 1,n:ns)
18:21:53 <lambdabot>  (2,[10,1,0])
18:21:57 <ski> > evalCont $ liftM (fmap (10 :)) $ callCC $ \k -> do ((n,ns),k) <- (twiceCC <=< twiceCC) ((0,[]),k); k (n + 1,n:ns)
18:21:59 <lambdabot>  (4,[10,3,2,1,0])
18:22:02 <ski> > evalCont $ liftM (fmap (10 :)) $ callCC $ \k -> do ((n,ns),k) <- (twiceCC <=< twiceCC <=< twiceCC) ((0,[]),k); k (n + 1,n:ns)
18:22:03 <lambdabot>  (8,[10,7,6,5,4,3,2,1,0])
18:24:08 <ski> the call to `twiceCC' here (using the earlier captured continuation `k') causes the part of the computation *after* `twiceCC' (up to the call of the (distinct) continuation `k' (monadically) returned by `twiceCC') to be repeated (iow executed twice)
18:24:44 <ski> the other argument to `twiceCC' is the initial value of the first result of `twiceCC'
18:26:11 <ski> calling the `k' continuation returned by `twiceCC' will jump back with the passed value as the subsequent value of the first result of `twiceCC'. next time, it will be the final result of the `callCC' call
18:27:47 <ski> so, in the first example, we start with `0' and the empty list. then after the `twiceCC' call `n' is `0' and `ns' is `[]', and we add one to `n' and add `n' in front of `ns'
18:28:27 <ski> so, the second time the (same !) `twiceCC' call returns, `n' is now `1' and `ns' is `[0]'. again we add one to `n' and add `n' in front of `ns'
18:29:14 <ski> this time, we don't jump back to `twiceCC', but instead jump to the (initial) `k', from `callCC', causing it to return `n' as `2' and `ns' as `[1,0]'
18:29:52 <ski> the `liftM (fmap (10 :))' is just to show that execution outside `callCC' is not affected by `twiceCC' : we add a single `10' in front of the list
18:30:57 <ski> in the next variant above, we use `twiceCC' two times, and so we repeat `2 ^ 2 = 2 * 2 = 4' times. in the last variant, we use it three times, so we reepat `2 ^ 3 = 2 * 2 * 2 = 8' times
18:32:13 <ski> for fun, i also made a version of this where you specify as an argument how many times you want to repeat
18:32:20 <ski> @type replicateCC
18:32:21 <lambdabot> (Integral i, MonadCont m) => i -> (a -> m Void, a) -> m (a -> m o, a)
18:32:30 <ski> > evalCont $ liftM (fmap (10 :)) $ callCC $ \k -> do (k,(n,ns)) <- replicateCC 3 (k,(0,[])); k (n + 1,n:ns)
18:32:31 <lambdabot>  (3,[10,2,1,0])
18:32:41 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- replicateCC 3 (k,1); k (10 + n))
18:32:42 <lambdabot>  131
18:32:49 <ski> > evalCont $ (100 +) <$> callCC (\k -> uncurry (. (10 +)) =<< replicateCC 3 (k,1))
18:32:50 <lambdabot>  131
18:33:28 <ski> it seems i need to use `Void' there in the type, making it assymetric, because i also wanted to handle the case where one repeats zero times
18:33:35 * hackagebot docvim 0.3.2.0 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.2.0 (wincent)
18:33:53 <ski> if we ignore that case, then we get the nicer-looking type
18:34:09 <ski> @type replicateCC1
18:34:11 <lambdabot> (Integral i, MonadCont m) => i -> (a -> m o, a) -> m (a -> m o, a)
18:34:20 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- replicateCC1 0 (k,1); k (10 + n))
18:34:21 <lambdabot>  *Exception: /tmp/mueval10252023621350490027.hs:(186,1)-(189,71): Non-exhaust...
18:34:35 <ski> (but it doesn't work for `0' then ..)
18:34:43 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- replicateCC1 1 (k,1); k (10 + n))
18:34:45 <lambdabot>  111
18:34:56 <ski> (otherwise, the functionality is the same)
18:35:02 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- (replicateCC 3 <=< replicateCC 2) (k,1); k (10 + n))
18:35:04 <lambdabot>  161
18:35:42 <Sinestro> What causes a Haskell program to segfault inside shutdownHaskellAndExit (and then a bunch of lovely unnamed functions)?
18:35:51 <ski> (if you're curious about how `replicateCC' and `replicateCC1' are implemented, i could show it)
18:36:19 <siwica> I am trying to parse entities of the form: [foo "bar"] and wrote the following (probably naive) parser: http://lpaste.net/167373
18:37:24 <siwica> However I am getting "*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string."
18:37:36 <siwica> Do you know why this is?
18:38:24 <benzrf> siwica: Parsec.spaces can match ""
18:39:00 <siwica> benzrf: so what would you use instead?
18:39:10 <benzrf> as i understand it, it's basically intended for you to scatter throughout your parser when you want to write something whitespace-insensitive
18:39:25 <evincar> athan: Got a basic (probably inefficient) solution with Traversable: subtrees = concatMap catMaybeTree . traverse (\x -> [Just x, Nothing])
18:39:33 <benzrf> like "identifier >> spaces >> leftBracket >> index >> rightBracket"
18:39:45 <ski> athan ^
18:39:46 <benzrf> siwica: do you care about "whitespace" in general, or just literal ' '
18:39:53 <evincar> athan: Thanks for the tip about Monad instances, it put me on (or closer to) the right track.
18:40:26 <siwica> benzrf: let's talk about both cases since I am trying to learn parsec
18:41:05 <siwica>   Parsec.many1 (Parsec.char ' ') for the latter case I guess
18:41:05 <siwica>  
18:41:23 <benzrf> yeah
18:41:34 <benzrf> in the former case... let me see
18:41:59 <ski> my "looping (iteration) with no parameters, looping with continuations (non-iterative & iterative)" in 2016-04-29 at <http://lpaste.net/161743> paste shows some examples of using continuations (rather than recursion or other iteration facilities) to loop, not using state (except the first example). has Scheme and Haskell versions of each example
18:42:14 <benzrf> siwica: it looks like `space' matches a single whitespace character, so you could do `space >> spaces'
18:42:25 <benzrf> or just `many1 space', but i'm not sure if that's better
18:42:46 <benzrf> oh, it looks like the definition is:
18:42:49 <benzrf> spaces              = skipMany space        <?> "white space"
18:43:02 <benzrf> so if there's a "skipMany1", that'd be the obvious solution here :)
18:43:15 <ski> for a final example, something that can't be done with `callCC', needs delimited/composable continuations. also this example may be easier to understand
18:43:20 <ski> @type cont . flip all
18:43:21 <lambdabot> Foldable t => t a -> Cont Bool a
18:43:38 <siwica> skipMany1 does not consume input?
18:43:44 <ski> (and similarly for `any'. if you prefer, remove the `Foldable t =>', and replace `t a' by `[a]')
18:43:55 <ski> @type sequence [cont (`all` [2 .. 9]),cont (`any` [2,3,5,7])]
18:43:56 <athan> ski: I'm going to have to save this for later :) You've given me some gold here
18:43:56 <lambdabot> (Enum a, Num a) => ContT Bool Identity [a]
18:44:05 <ski> @type do [n,p] <- sequence [cont (`all` [2 .. 9]),cont (`any` [2,3,5,7])]; return (n `mod` p == 0)
18:44:06 <lambdabot> ContT Bool Identity Bool
18:44:14 <ski> > (`runCont` id) $ do [n,p] <- sequence [cont (`all` [2 .. 9]),cont (`any` [2,3,5,7])]; return (n `mod` p == 0)
18:44:15 <lambdabot>  True
18:44:19 <ski> > (`runCont` id) $ do [n,p] <- sequence [cont (`all` [2 .. 9]),cont (`any` [2,3,5])]; return (n `mod` p == 0)
18:44:21 <lambdabot>  False
18:44:22 <ski> > (`runCont` id) $ do [n,p] <- sequence [cont (`all` [2 .. 11]),cont (`any` [2,3,5,7])]; return (n `mod` p == 0)
18:44:24 <lambdabot>  False
18:45:17 <ski> the first of these three checks : is it the case that for all `n' in `[2 .. 9]', there is any `p' in `[2,3,5,7]' such that `p' divides `n'
18:45:35 <ski> similarly for the other two, except that the particular lists have changed
18:45:48 <ski> another way to express the first, without `sequence', is
18:46:02 <siwica> benzrf: anything else you would write differently/better in my case?
18:46:05 <ski> > (`runCont` id) $ do n <- cont (`all` [2 .. 9]); p <- cont (`any` [2,3,5,7]); return (n `mod` p == 0)
18:46:07 <lambdabot>  True
18:46:50 <benzrf> siwica: um, not sure - i have to go, sorry!
18:46:51 <ski> conceptually, each `cont ...' here corresponds to a nesting level of a loop (/iteration)
18:46:53 <benzrf> good luck though
18:47:10 <siwica> benzrf: thanks for your help anyway!
18:47:46 <ski> if we only had `all', or only `any', then we could instead use the list monad to generate a list of `Bool's, and check whether all of them are `True' (using `and') respectively at least one of them is `True' (using `or')
18:48:52 <ski> however, the version with `sequence' shows more clearly that you could e.g. factor out the two "nested loops" into a separately named action, leaving a single call to it here, followed by the call with `mod'
18:49:56 <ski> iow, we can, conceptually speaking, factor out "loop nestings" without factoring out the body of the loop. (this is of course just an elaborate way of using higher-order functions)
18:51:58 <ski> in case we wanted to so something similar ("factoring loop nestings") with `map', then we'd need to use the "indexed continuation monad". instead of `Cont o a'/`ContT o m a', we'd have `ICont o0 o1 a'/`IContT o0 o1 a', where the "final result type" `o' changes from `o0' to `o1' as we execute an action ("enter a loop")
18:53:15 <ski> one could then write `collect :: [a] -> ICont [o] o a' and `collectT :: Monad m => [a] -> IContT [o] o m a'
18:54:20 <ski> btw, `ICont' and `IContT' would be defined as `newtype ICont o p a = MkICont ((a -> p) -> o)' and `newtype IContT o p m a = MkIContT ((a -> m p) -> m o)'
18:55:36 <ski> (hm, actually the argument order of `IContT o0 o1 m a' should be `IContT m o0 o1 a', in order to make `IContT m' an instance of `IndexedMonad')
18:56:39 <ski> where that class would be `class IndexedMonad im where ixreturn :: a -> im i i a; ixbind :: im i j a -> (a -> im j k b) -> im i k b'
18:57:34 <ski> (if you use the language extension `RebindableSyntax', then you could instead use the names `return' and `(>>=)', and thus use `do'-notation, expanding to uses of the latter)
18:57:50 <ski> athan : i'll stop here
18:58:20 <athan> Thank you ski :)
18:58:36 <ski> yw
19:00:58 <ski> (hm, i should perhaps also say that `newtype IState s t a = MkIState (s -> (a,t))' can also be made an instance of `IndexedMonad'. similarly for `IStateT'. also these (`ICont',`IContT',`IState',`IStateT',`IndexedMonad',`ixreturn',`ixbind') are not standard names)
19:02:32 <ski> (oh, i also forgot to say before that, classically speaking, `X -> Y' is equivalent to `Not (X,Not Y)' (and also to `Either (Not X) Y', though i've not used that here))
19:19:28 <athan> Guys... how is a function an "exponential"?
19:19:34 <athan> s/guys/peeps
19:19:47 <Koterpillar> complexity-wise, perhaps
19:19:57 <athan> I understand how set-wise, a sum type is union and a tuple is cartesian product
19:20:04 <athan> Koterpillar: That's where I'm lost
19:20:22 <athan> isn't the set of all functions `A -> B` just `(A,B)`?
19:21:09 <roboguy`> ski: Are you sure that only holds in classical logic? I at least proved the '(X -> Y) -> Not (X, Not Y)' direction in Coq
19:21:19 <Koterpillar> athan: that's not right
19:21:21 <roboguy`> athan: no
19:21:53 <athan> How is it not correct?
19:21:57 <roboguy`> athan: there are |B|^|A| number of functions of the type A -> B (where |A| and |B| are the number of values in the type A and the type B respectively)
19:22:15 <athan> Oh wait okay
19:22:16 <roboguy`> for instance, there are 4 possible functions from Bool -> Bool
19:22:37 <kadoban> (Bool doesn't work so well for this, because 2 + 2 = 2 * 2 = 2^2
19:22:42 <roboguy`> right, ha
19:22:52 <Iceland_jack> @define data ABC = A | B | C
19:22:53 <lambdabot>  Defined.
19:22:55 <Iceland_jack> ;)
19:23:07 <roboguy`> I was trying to think of a better example. Bool -> Maybe Bool would be 3^2 (= 9)
19:23:52 <ski> roboguy` : the *equivalence* doesn't hold constructively. that direction of it holds, though
19:23:59 <roboguy`> hmm
19:24:12 <kadoban> That would work, or just a manual sum type like ABC. I think bytemyapp's book just uses some fake like, T | F | Neither thing.
19:24:22 <roboguy`> ha, out of curiosity, I'll try the other way and then trying to prove it's an iso
19:24:28 <ski> athan : the number of functions from a finite set `M' to a finite set `N' is `N^M'
19:25:31 <ski> well, is `|N| ^ |M|', if `|A|' expresses the number of elements of `A'
19:25:48 <athan> ski: Given that the functions may be partial?
19:25:55 <athan> If N and M are sets?
19:26:12 <athan> erp
19:26:15 <athan> sorry my brain hurts
19:26:18 <kadoban> athan: For every input, every element of A, there's |B| different choices of what the input should map to. Since there's |A| inputs, that means there's |B| * |B| * |B| ...    possibilities, or |B|^|A|
19:26:25 <ski> athan : iow, the number of inhabitants of `M -> N', i.e. `|M -> N|' is `N^M'. similarly we have `|(M,N)| = |M| * |N|' and `|Either M N| = |M| + |N|'
19:26:30 <roboguy`> athan: a function is generally considered to be total (non-partial) unless you specify it as partial
19:27:17 <roboguy`> athan: it might help to run through an example, like implementing the different functions of type Maybe Bool -> Bool
19:27:38 <kadoban> So, if you have :: ABC -> ABC, as above, Then  A could map to A or it could map to B or it could map to C.  Then B could map to A or it could map to B or it could map to C, etc.
19:27:43 <roboguy`> (there are 3^2 = 8 of that type)
19:27:46 <ski> (where `*' is really a cross symbol, ⌜×⌝)
19:27:49 <roboguy`> err, 2^3=8
19:28:18 <ski> note that the set/type of functions `A -> B' is usually written as `B^A' in math
19:28:37 <kadoban> Is it really? That's ... direct, heh.
19:29:19 <ski> (and `(A,B)' is usually written `A * B' (really ⌜A × B⌝). and `Either A B' is sometimes written as `A + B', pronounced "disjoint union/sum of `A' and `B'")
19:30:16 <ski> athan : "Given that the functions may be partial?" -- no, this was assuming total functions
19:30:25 <vxkr> hi all
19:30:43 <kadoban> Hello
19:31:02 <vxkr> is there a way to wrap all of these unsafe partial functions into a sequence of operations in a maybe monad? http://lpaste.net/167380
19:31:32 <ski> (oh, and obviously `B^A' is usually written as `B' with `A' as a superscript to the right. `^' is an ASCII notation for that)
19:31:36 <siwica> How can I convert Char to Int?
19:31:46 <ski> @type Data.Char.ord
19:31:47 <lambdabot> Char -> Int
19:31:55 <ski> @type Data.Char.chr
19:31:56 <lambdabot> Int -> Char
19:31:59 <athan> wait hold up
19:32:11 <kadoban> ski: Ah, yeah I wasn't sure. I guess I never got that far into set/type theory, I've seen cartesian product and union/sum, but that's it.
19:32:38 <pertain> disconnect haskell
19:32:40 <kadoban> I grabbed a copy of TaPL ... not sure how well that's going to go though, heh.
19:32:53 <ski> (well, plain union is not the same as the disjoint union / sum)
19:32:55 <athan> A -> B = sum (forall a : A. \a -> (forall b : B. b)) right?
19:33:04 <athan> it's the union of the different implementations case matching on A?
19:33:35 <athan> like it can't be _both_ one of the implementations or the other
19:33:37 <ski> that notation makes little sense to me. (perhaps elaborate on it ?)
19:33:41 <athan> therefore it's the sum, not the product
19:33:41 <kadoban> Oh, yeah.
19:34:15 * ski isn't sure what `sum' means there
19:34:29 <ski> (e.g., what would be the type of `sum' there ?)
19:34:29 <siwica> ski: '1' -> 1, '2' -> 2
19:34:34 <athan> replace "forall" with "for every" heh
19:34:35 <ski> siwica, oh
19:34:43 <ski> @type digitToInt
19:34:44 <lambdabot> Char -> Int
19:34:46 <ski> @indexd digitToInt
19:34:46 <lambdabot> Data.Char
19:34:52 <kadoban> athan: Think about just writing down lines for the type  f :: ABC -> ABC.  You write the first line.  f A = ...    how many things can you fill in for ...?  (data ABC = A | B | C), we're talking about a total function here.
19:35:23 <siwica> ski: thanks!
19:36:08 <ski> athan : sometimes people would write something like `B^A = {f | forall a : A. exists b : B. f(a) = b}' .. but i'm not convinced it makes that much sense either ..
19:36:09 <athan> okay so, if the param / domain is the set A = ..., and the range is B = ..., then we can say that the parameter can case match on either every instance of A
19:36:22 <ski> athan : perhaps you had something like that in mind
19:36:58 <athan> that makes sense to me ski
19:37:13 <athan> but notice that you're taking the union of the different As
19:37:18 <athan> not the product of them
19:37:20 <ski> perhaps because you're used to (basic) set theory
19:37:36 <athan> therefore it's just |B| + |B| + |B|... |A| times
19:37:37 <ski> whereas i've had my mind remolded a bit by type theory
19:37:43 <monochrom> it makes as much sense as tautologies, i.e., sure all tautologies are true, but does it education me?
19:37:52 <roboguy`> athan: well, a (disjoint) union is a product...
19:38:02 <monochrom> s/education/educate/
19:38:15 <ski> athan : "therefore it's just |B| + |B| + |B|... |A| times" -- "it" here being ?
19:38:19 <athan> roboguy`: No it's not
19:38:26 <roboguy`> oh right, that's a sum
19:38:26 <athan> it's not a cartesian product
19:38:48 <athan> ski: "it" being the total number of implementations for A -> B
19:39:04 <ski> roboguy` : if you're thinking of the dependent formulation, then i'm not sure it'd help the discussion here much ..
19:39:19 <ski> athan : ok. in that case it's incorrect
19:39:24 <roboguy`> ski: no not that, I just got mixed up for a second
19:39:41 <athan> okay, third time is the charm:
19:39:51 <ski> athan : it should be "therefore it's just |B| * |B| * |B| ... * |B|, with |A| factors"
19:40:05 <athan> A = a1 | a2 | a3 | ... | an, B = b1 | b2 | b3 | ... | bm
19:40:20 <roboguy`> athan: alright, so your claim is that the number of implementations of a function is |A| * |B|, not |B|^|A|? I can disprove that with an example...
19:40:22 <athan> OH
19:40:25 <athan> Thank you ski!
19:41:05 <benzrf> ski is turing complete! but you really only need sk
19:41:45 <monochrom> no, ski is what you need to win in Winter Olympics
19:42:02 <roboguy`> ha
19:42:09 <augur> if a lens is a way to look into one place in a piece of data, what is a way to look into multiple places?
19:42:24 <ski> a function `f : A --> B' defined as `f(a1) = b_i1; f(a2) = b_i2; ...; f(an) = b_in' corresponds to an `n'-tuple of `B' values `(b_i1,b_i2,...,b_in)', where each of the indices `i1',`i2',...,`in' are allowed to independently be selected between from `1',`2',...,`m', thereby selecting one of `b_1',`b_2',...,`b_m' as a component of the `n'-tuple
19:42:24 <athan> can you show me that example roboguy` ?
19:43:33 <ski> athan : so, we have multiple choices to make, which are independent, so by the multiplication principle (in combinatorics), we multiply the number of possibilities for each choice. in this case, `m * m * ... * m', with `n' `m's, which is `m^n'
19:44:04 <ski> augur : possibly a traversal, iiuc
19:44:55 <ski> @type traverse
19:44:56 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:45:20 <ski> @type both
19:45:21 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
19:47:50 <augur> ski: hm
19:48:06 <augur> ski: the type is indeed very similar to a lense
19:48:30 <augur> but i have in might something somewhat different. not `t a`
19:48:55 <augur> Lens s t a b = Functor f => (a -> f b) -> s -> f t
19:49:15 <augur> i want that, but with the "all a's" interpretation instead of the "some a" interpretation
19:49:41 <augur> actually maybe that's consistent with the all-a's interpretation too! hm!
19:50:00 <roboguy`> athan: http://lpaste.net/167384
19:50:15 <roboguy`> athan: I like using Bools as an example of this, because it's like counting in binary
19:51:28 <augur> aha Traversal is basically that, ski :)
19:51:33 <augur> you're right!
19:51:41 <augur> modulo capitalization :)
19:54:40 <argent0> Hi, how could I write a Foldable instance for a Vector :: Nat -> * -> *? (a.k.a: why is this code failing?) http://lpaste.net/167382
19:54:48 <argent0> ghc 8.0.1
19:58:59 <glguy> argent0: Write one instance for both the Z and S cases
19:59:55 <argent0> glguy: isn't that line 22?
20:00:06 <glguy> No, that's two instances
20:00:31 <glguy> I mean "write one instance that covers both the Z and S cases"
20:00:40 <ggVGc> I think I've asked before, but where is Rank > 2 types used?
20:00:50 <ggVGc> I don't think I've ever seen it
20:01:10 <glguy> ggVGc: Any time you want to take a rank >= 2 typed argument
20:01:16 <ggVGc> oh, wait, Lens is rank 4 eh?
20:01:21 <glguy> no
20:01:28 <ggVGc> rank 2?
20:01:41 <glguy> no
20:01:48 <glguy> 1
20:01:57 <ggVGc> okay I obviously don't know at all what I'm asking then
20:01:59 <ggVGc> ignore me
20:02:03 <ggVGc> I'll read up more on this
20:02:34 <glguy> Lens s t a b is a polymorphic type, however. If you put it in an argument position of a function then the resulting function type has rank 2
20:02:44 <ggVGc> ah, that's why I got confused
20:02:46 <roboguy`> ggVGc: if you want to take an argument that is a rank-2 type, that will be a rank-3 type
20:02:53 <argent0> glguy: Thanks that worked!
20:02:54 <ggVGc> ah, I get it then
20:03:03 <ggVGc> thanks
20:03:52 <ggVGc> a rank-2 function depends on a type which is in itself also polmorphic eh
20:04:05 <ggVGc> so it's polymorphic over something that is polymorphic?
20:04:10 <ggVGc> etc. up to N
20:05:20 <roboguy`> yeah. An example of a rank-2 type would be (forall a. [a] -> [a]) -> Bool
20:05:36 <roboguy`> well, maybe that fits what you said. Not fully sure
20:05:41 <ggVGc> yep, I understand then
20:05:55 <ggVGc> I don't think I worded it well
20:06:03 <ggVGc> but yeah
20:06:32 <roboguy`> so, in that example, the function must be polymorphic (it cannot know anything about the type in the list. That type is chosen by the overall function returning Bool)
20:08:18 <roboguy`> > let checkId3 :: Eq a => (forall a. [a] -> [a]) -> Bool;    checkId3 f = f "abc" == "abc"    in checkId3 reverse
20:08:20 <lambdabot>  False
20:08:55 <roboguy`> oops, that Eq bit wasn't necessary and it was shadowed anyway
20:09:06 <roboguy`> > let checkId3 :: (forall a. [a] -> [a]) -> Bool;    checkId3 f = f "abc" == "abc"    in checkId3 reverse
20:09:07 <lambdabot>  False
20:10:44 <aisqwe> does anybody know what the (# ... #) notation in state monad source code means?
20:11:49 <roboguy`> aisqwe: it is an unboxed tuple
20:12:24 <aisqwe> is an unboxed tuple mutable?
20:12:33 <roboguy`> no
20:13:23 <EvanR> grumble... 
20:13:42 <EvanR> can i cabal build and install any two things without them clobbering each other
20:13:52 <EvanR> guess not
20:13:59 <ggVGc> aisqwe: nothing is mutable unless it's in IO or STR
20:14:00 <ggVGc> ST*
20:14:01 <ggVGc> afaik
20:17:16 <aisqwe> is ST monad implemented with the same magic of IO? i think ST is implemented entirely in haskell itself
20:17:35 <aisqwe> thought* :D
20:17:53 <roboguy`> aisqwe: it secretly does actual mutation (but in a way that cannot escape the ST value)
20:17:58 <EvanR> its behind the scenes stuff is hidden and safe because of the rank 2 phantom type there
20:18:05 <roboguy`> it is prevented by the type system
20:18:17 <roboguy`> (prevented from escaping)
20:18:43 <EvanR> the behind the scenes stuff uses IO, but not for I/O
20:19:13 <aisqwe> how much of haskell is implemented in this behind the scene way?
20:19:37 <EvanR> how much of ghc ? or wild haskell code
20:20:45 <aisqwe> how many other implementations are there besides ghc?
20:20:47 <roboguy`> for the base libraries, I suspect not much more than ST and some internal IO functions (not fully sure)
20:21:35 <EvanR> NHC, UHC, JHC...
20:21:42 <roboguy`> the source of the base libraries is generally pretty browsable on Hackage
20:24:26 <EvanR> "Are you fed up waiting for ghc to compile your programs? nhc98 can be pretty quick at compiling, even though it is not as fast as hbc."
20:24:38 <EvanR> This page last updated: 28th Feb 2007
20:25:11 <EvanR> generally other haskell implementations are kind of like big foot
20:25:47 <EvanR> everyones heard of them but 
20:26:11 <EvanR> evidence that they exist is circumstantial
20:26:17 <roboguy`> ghc is the most popular by a pretty wide margin (and the most actively maintained)
20:28:53 <roboguy`> hugs is probably the second most popular (which is unfortunate, because it hasn't been updated in 10 years)
20:29:24 <roboguy`> but hugs would be a very distant second, popularity-wise
20:32:46 <kadoban> Can't even remember the last time I heard anyone talk about using hugs for anything.
20:34:20 <roboguy`> kadoban: I see it come up on stackoverflow sometimes. I think some teachers still use it
20:35:58 <roboguy`> kadoban: I know I've heard at least one teacher say he was switching to teaching using Hugs because of FTP (which I can kind of understand. Although, ultimately, I think it would be best to not shield the students from the new directions that the field is taking)
20:36:28 <kadoban> roboguy`: Hmm, I guess that makes sense.
20:37:00 <thimoteus> i guess i should use hakyll instead of jekyll for github pages
20:37:14 <kadoban> Yeah, it seems a bit unnecessary to use a totally different compiler just because of that. Though the "newbie mode" that's come up in conversation seems like it'd be kind of a nice idea too.
20:37:44 <roboguy`> kadoban: it's a tough issue IMO. Definite difficulties teaching with FTP, but at the same time it is pretty important to not keep students in the dark about such things (not to mention all the other features GHC has over Hugs)...
20:38:09 <sullyj3> so, Just saw quicksort implemented in learnyouahaskell (http://learnyouahaskell.com/recursion#quick-sort) which was pretty pretty. However, I remember when learning C, my professor told me to randomise pivot selection to avoid worst case behaviour for already sorted lists. But non-determinism is super unfunctional! Is there any way to avoid this worst case behaviour without resorting to randomness in haskell? In 
20:38:09 <sullyj3> particular, any way which preserves the famous elegance of the haskell implementation?
20:38:11 <roboguy`> I think a newbie mode would be a good idea
20:38:48 <roboguy`> that way, you can introduce those ideas when you want (or not introduce them at all, I suppose, if you're so inclined)
20:39:42 <roboguy`> sullyj3: randomness isn't really an issue... (pseudo-) random number generators are deterministic once they are seeded
20:39:46 <kadoban> sullyj3: There's a bunch of strategies. One simple one is the "median of 3", where you take the median of 3 different elements, I think often the first, the middle and the last.
20:39:52 <roboguy`> just need to pass it a seeded random number generator
20:40:17 <roboguy`> also, yeah median of 3 is good. Median of medians is good as well
20:41:09 <sullyj3> Oh, cool. That's pretty simple! Thanks!
20:46:42 <kadoban> Isn't there a name for the variant of quicksort that does the median of medians thing that guarantees O(n lg n) worst-case behavior? I thought that was introsort for some reason, but ... it's not obviously.
20:47:44 <c_wraith> I don't think there's a special name for that variant
20:48:22 <kadoban> Hmm
20:54:13 <Velizar> Is liftA2 the same as liftM2?
20:54:30 <c_wraith> Other than the constraint, yes
20:56:44 <c_wraith> and now that Applicative is a superclass of Monad, liftA2 is strictly more general.
21:08:14 <ski> augur :)
21:08:22 <ski> you can also ask #haskell-lens
21:08:27 <ski> ggVGc : "it's polymorphic over something that is polymorphic" is inaccurate. with `foo :: (forall a. [a] -> [a]) -> Bool', `foo' is not polymorphic. but it expects its argument to be polymorphic
21:09:10 <ski> ggVGc : a value is polymorphic if and only if it has a type of the shape `forall a. ..a..' (what i tend to call a "universal type")
21:09:13 <jmcarthur> foo :: (forall a. [a] -> [a]) -> Bool   is actually less polymorphic than   foo :: ([a] -> [a]) -> Bool
21:09:32 <ski> yes (because it's not polymorphic at all)
21:09:35 <jmcarthur> It accepts fewer values.
21:09:56 <jmcarthur> My first statement was really just the buildup to the latter statement.
21:09:57 <Koterpillar> ski: what about something like a -> forall b. b?
21:11:04 <ski> Koterpillar : that would be logically equivalent to `forall b. a -> b', and so normally one'd also think of it as polymorphic. i think GHC automatically hoists such "result `forall's" to the "top level", like that
21:12:36 <EvanR> yeah a few blog posts trying to explain rank N start with that one
21:12:49 <ski> if a (possibly polymorphic) function has an argument with a rank `n' type, then the function itself has at least rank `n+1'
21:12:58 <EvanR> "as you already know... forall a . a -> forall b . b is really forall a b . a -> b"
21:13:09 <EvanR> thus beginning already confused
21:13:10 <ski> a value with a type not involving `forall' is said to have rank `0'
21:13:51 <ski> a polymorphic value, whose type doesn't involve any `forall' except the toplevel one, is said to have rank `1'
21:14:48 <EvanR> so a type can "be rank 2" without being polymorphic?
21:15:21 <ski> yes
21:15:46 <ski> (and hence i think "rank-2 polymorphism" isn't a good term to use in such cases)
21:16:18 <ski> (i'm not sure whether there's an accepted way to define rank in case there occurs `forall's impredicatively (here : i.e., inside other type constructors than `(->)') in the type)
21:17:36 <EvanR> (forall a . Maybe a) -> Char ?
21:17:50 <ski> yes. or `foo' above
21:18:35 <EvanR> well, forall a . Maybe a is a rank 1
21:18:48 <roboguy`> if you wrap it up in a new type, it becomes an existential: data Exists = forall a. Exists a
21:18:50 <EvanR> and the argument to the -> type is rank1 so
21:19:00 <EvanR> the whole thing is rank 2
21:19:03 <ski> the least (natural number) rank possible, consistent with the above constraints, is the rank that is assigned
21:20:13 <ski> by which i mean that e.g. `(forall a. Maybe a) -> Char' not only has at least rank `2', but actually *has* rank `2' (and not `3', or `4', or ...), since there's nothing in the type "raising" the constraint any further than `2'
21:20:36 <ski> you could also define the rank by a recursion on the type, if you prefer
21:20:52 <ski> EvanR : yes
21:21:09 <ski> roboguy` : if you wrap what up in a new type ?
21:21:54 <roboguy`> ski: well, I guess that's not a good way of explaining it. I just meant that you can use forall to get existential quantification if you put it into a data type like that
21:21:56 <ski> (your `Exists' is iso to `exists a. a' (ignoring bottoms))
21:22:01 <roboguy`> yeah
21:22:10 <joncfoo> If I create a newtype with mtl I'm stuck with the transformers in my type, yes? e.g. StateT is fixed to whichever one I imported - newtype X a = X { getX :: StateT Y IO a }
21:22:48 <joncfoo> and I use it in a function, e.g. foo :: X Int
21:22:56 <ski> with `data Exists = forall a. Wrap a', we get the type signature `Wrap :: forall a. (a -> Exists)' for the data constructor, which is logically equivalent to `Wrap :: (exists a. a) -> Exists'
21:23:01 <roboguy`> a more fun type is data DPair f g = forall a. DPair (f a) (g a)
21:23:47 * EvanR wonders how this is useful
21:24:00 <roboguy`> you can use it to put GADTs into containers
21:24:14 <roboguy`> (if you have singletons as well, at least)
21:25:14 <roboguy`> EvanR: there's an example here (although not really of the GADT-in-a-container thing): https://github.com/mokus0/dependent-sum/issues/6
21:25:18 <ski> with `data DPair f g = forall a. MkDPair (f a) (g a)', we'd get `MkDPair :: forall f g a. (f a -> g a) -> DPair f g', which is `MkDPair :: forall f g. (forall a. (f a -> g a -> DPair f g))', which is equivalent (currying, ignoring bottoms) to `MkDPair :: forall f g. (forall a. ((f a,g a) -> DPair f g))', which is equivalent to `MkDPair :: forall f g. ((exists a. (f a,g a)) -> DPair f g)'
21:25:24 <ski> (extra brackets for emphasis)
21:27:02 <roboguy`> you can use DPair+singletons to package up an indexed type along with the type it's indexed by (sort of like a dependent pair)
21:27:50 <EvanR> NatS stands for Nat singleton?
21:28:07 <ski> roboguy` : yes, i'd like a `Map1 :: forall k. (k -> *) -> (k -> *) -> *' with e.g. `insert1 :: Ord1 k => k i -> v i -> Map1 k v -> Map1 k v', where `class Eq1 f => Ord1 f where compare1 :: f i -> f j -> Either (Equal i j) Bool' in the libraries
21:28:46 <EvanR> why is this type called a singleton
21:29:24 <ski> (and `class Eq1 f where eq1 :: f i -> f j -> Maybe (Equal i j)'. where `data Equal :: k -> k -> * where Refl :: Equal a a')
21:29:57 <ski> EvanR : because for each `n', `Nat n' has a single (total) inhabitant
21:30:02 <roboguy`> EvanR: It has a single value for each type (there is only one value of type NatS 0, one value of NatS 1, etc)
21:30:13 <ski> er, s/Nat n/NatS n/
21:30:31 <roboguy`> EvanR: it helps you bring type-level things into the value world
21:31:08 <EvanR> oh
21:31:14 <roboguy`> if we could get rid of the need for the boilerplate of singletons, it would be nice though...
21:31:19 <EvanR> so its like data X = MkX
21:31:36 <osager> What is the usage of  (&&&)
21:31:40 <roboguy`> EvanR: not exactly. The important part is that it has a parameter
21:31:40 <osager> in Arrow
21:31:52 <ski> roboguy` : well, i think it is useful in general, not just for singleton "key/tag" types
21:31:56 <osager> :t (&&&)
21:31:57 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:31:58 <roboguy`> EvanR: and, for each type that is given as a parameter, there is only one value of that type
21:31:59 <EvanR> but if you defined data X = MkX, data Y = MkY , etc 
21:32:11 <EvanR> you can use X and Y and etc as tags in the type system
21:32:24 <EvanR> but the NatS also gives you arithmetic
21:32:36 <roboguy`> EvanR: you can use data constructors as types when you enable DataKinds
21:32:45 <roboguy`> so that isn't really necessary a lot of the time
21:33:01 <EvanR> well ive done that, and it works, and then it doesnt :(
21:33:06 <ski> roboguy` : namely, as soon as you want a heterogenous finite map, where the value of the key determines the type argument for the value, possibly different for each pair in the finite map
21:33:11 <kadoban> > map (head &&& length) . group . sort $ ["A", "B", "A", "C"] -- osager
21:33:13 <lambdabot>  [("A",2),("B",1),("C",1)]
21:33:18 <EvanR> when standard classes require kind *
21:33:31 <ski> roboguy` : however, there's no need to insist that there can be at most one key for a give type argument
21:34:17 <osager> kadoban, thanks
21:34:36 <ski> (but if you want to simulate a dependent pair, then it would seem you have to use singletons like that, yes. .. or perhaps one can do something like the `reflection' package, not sure)
21:36:16 <ski> (so i think this would be useful also without using `DataKinds', e.g.)
21:38:44 * hackagebot ghcjs-dom-webkit 0.3.1.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-webkit-0.3.1.0 (HamishMackenzie)
21:38:46 * hackagebot ghcjs-dom-jsaddle 0.3.1.0 - DOM library that supports both GHCJS and WebKitGTK using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.3.1.0 (HamishMackenzie)
21:38:48 * hackagebot ghcjs-dom-jsffi 0.3.1.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.3.1.0 (HamishMackenzie)
21:38:50 * hackagebot ghcjs-dom 0.3.1.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.3.1.0 (HamishMackenzie)
21:46:20 <joncfoo> Suppose I have a mtl stack newtype'd with LoggingT (from monad-logger). If I want to run a function [say, in testing] under NoLoggingT what are my options?
21:47:57 <Axman6> so ideally your code doesn't tie you to a specific monad, but only a set of constraints, such as (MonadLogging m, MonadReader MyEnv m) => m Foo
21:48:39 <joncfoo> Axman6: thanks for the confirmation! That was my line of thought but I wasn't sure
21:48:52 <glguy> joncfoo: You can parameterize your newtype by the logging layer you want to use, otehrwise
21:49:16 <Axman6> then you can swap m for which implementation you want when you actually execute the stack, so you could swap runFoo . runLoggingT myLogger with runFoo . runNoLoggingT
21:49:52 <joncfoo> Axman6: yes that's what I was hoping to hear
21:49:52 <Axman6> yeah that too, you could use type MyMpnad log m a = log (m a) or something
21:50:14 <joncfoo> glguy: that seems too easy :P
21:50:21 <joncfoo> I'm going to try that out right now
21:54:26 <joncfoo> glguy: when you get a chance could you please give an example of the parameterized newtype?
21:55:14 <glguy> newtype MyNewtype loggerT a = MkMyNewtype (StateT This (ReaderT That (loggerT IO)) a)
21:57:19 <joncfoo> ok that's what I had - the deriving part is what is not working
21:57:35 <joncfoo> makes sense as to why it's not working since there is no implementation to go off of
21:58:01 <glguy> You'd have to paste what you're trying to the pastebin
21:59:19 <joncfoo> http://lpaste.net/5637941644620726272
21:59:38 <joncfoo> I'm using logging-effect but the principal is the same
22:00:24 <idev> how do I tell "stack repl" to -v for "list of files searched for"
22:00:29 <idev> it's not being able to find modules I expect to see
22:03:35 <zRecursive>  /msg lambdabot 
22:04:16 <joncfoo> I don't think newtype with a parameterized transformer + deriving is going to work
22:04:52 <kadoban> idev: 'stack repl -v' ?
22:06:19 <glguy> joncfoo: Yeah, if you're going to use the generic constraints like this with parameterization you'll need to write out the instances
22:06:56 <glguy> It's usually better to write the specific operations your type supports, possibly using the various MonadThis or MonadThat classes as internal implementation helpers
22:07:14 <glguy> Exposing a MonadReader constraint isn't great
22:07:17 <glguy> for example
22:08:10 <joncfoo> thanks glguy
22:08:43 <joncfoo> I think I'll go down the route that Axman6 suggested - my types are going to get a lot longer but that's ok :)
22:13:58 <glguy> joncfoo: Even going the constraint way you shouldn't see "MonadReader" constraints in your code outside of the implementation of the DB type
22:14:16 <glguy> If you need a constraint specific to your application you should make a class that has the relevant operation in it
22:15:53 <roboguy`> ski: hmm, I never considered reflection for dependent pairs...
22:16:21 <ski> roboguy` : i was thinking for your natural number ..
22:16:25 <roboguy`> ahh
22:16:46 <joncfoo> glguy: sorry I don't quite follow - could you give an example?
22:16:51 <ski> it was just a vague idea that it might be possible. i don't know
22:16:54 <idev> 'stack repl' seems to be ignoring my 'hs-source-dirs' in my *.cabal file; do I need to put this directly into stack.yaml ?
22:17:22 <roboguy`> dependent pairs are something I miss from Coq in Haskell (especially when working with GADTs). Hopefully someday a less boilerplate-y dependent pair-type thing will be possible
22:18:43 <glguy_> idev: no, something else is likely wrong
22:18:46 * hackagebot countable 1.0 - Countable, Searchable, Finite, Empty classes  https://hackage.haskell.org/package/countable-1.0 (AshleyYakeley)
22:18:48 * hackagebot gi-gtk-hs 0.3.1.0 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.3.1.0 (HamishMackenzie)
22:19:28 <idev> glguy: is thre a way to ask ghci "show me all paths you're searching for modules" ?
22:21:13 <glguy> idev: build with -v getting to GHC and look for -i flags?
22:22:17 <idev> "stack build; stack exec fname" runs ifne
22:22:23 <idev> *fine*
22:33:44 <idev> how do I tell stack repl to not generate *.dump-hi files in the same location as the *.hs files?
22:36:14 <Geraldus_> Hi friends! 
22:36:17 <osager> how to use case .. of on a value that could be positive, negative or zero
22:36:34 <osager> case v of:...
22:36:51 <Geraldus_> Does anyone knows is it possible to build Haddock from master with GHC 7.10.3?
22:36:55 <Koterpillar> osager: case signum a of?
22:37:10 <osager> hummm.. i dont know signum
22:37:20 <Koterpillar> :t signum
22:37:22 <lambdabot> Num a => a -> a
22:37:27 <EvanR> signum will just give you a number, and you still have to use guards
22:37:28 <Koterpillar> > signum 15
22:37:31 <lambdabot>  1
22:37:37 <EvanR> osager: one way is to use 3 guards
22:37:40 <EvanR> for < == and >
22:37:49 <EvanR> another way, is to use a "view" type
22:38:05 <EvanR> which returns a 1-of-3 constructor type for positive negative or zero
22:38:06 <osager> view?
22:38:12 <Koterpillar> since you have _zero in your type_, you have Eq
22:38:14 <EvanR> for an integer
22:38:39 <Koterpillar> :t case (signum x) of { 1 -> "positive; 0 -> "zero" }
22:38:40 <lambdabot>     lexical error in string/character literal at end of input
22:38:50 <EvanR> data SignView = Pos Integer | Zero | Neg Integer
22:38:56 <osager> signum is great
22:39:00 <osager> Koterpillar, 
22:39:15 <EvanR> it will work, but you will have warnings about not checking for 2 etc
22:39:15 <osager> Thanks both
22:39:29 <Koterpillar> well
22:39:35 <Koterpillar> case cmp x 0 of
22:39:43 <Koterpillar> :t cmp 0
22:39:44 <lambdabot> Not in scope: ‘cmp’
22:39:44 <EvanR> a view type would be nicer ;)
22:39:49 <Koterpillar> :t compare 0
22:39:50 <lambdabot> (Num a, Ord a) => a -> Ordering
22:39:59 <osager> let me check out the view type too
22:40:04 <osager> both are new to me
22:40:12 <EvanR> its just not conveniently available in the standard lib
22:40:25 <osager> where is view defined ?
22:40:33 <Koterpillar> looks lensy
22:40:35 <EvanR> nowhere
22:40:44 <osager> ok
22:40:45 <EvanR> youd have to define the type and the view yourself
22:40:47 <osager> you defined it
22:41:01 <EvanR> then do case myView n of
22:41:22 <Koterpillar> this is not that far from compare 0
22:41:30 <EvanR> anyway this is cool for other types and other partitions of your types, for this simple case you can use 3 guards
22:41:40 <EvanR> thats more idiomatic i think
22:42:07 <osager> yes, to make a new data for a one time thing is not worth it
22:42:18 <EvanR> | n < 0 = ...
22:42:24 <EvanR> | n > 0 = ...
22:42:31 <EvanR> | otherwise = ...
22:42:49 <ski> should `myView (-3) = Neg 3' ?
22:42:56 <EvanR> dunno
22:43:23 <EvanR> or just dont return the value, and it will be like Ordering
22:44:04 <ski> @type ap (,) (compare 0)
22:44:05 <lambdabot> (Num a, Ord a) => a -> (a, Ordering)
22:44:40 <EvanR> nice
22:45:08 <EvanR> :t (,) <*> compare 0
22:45:09 <lambdabot> (Num a, Ord a) => a -> (a, Ordering)
22:45:44 <EvanR> instaview
22:45:58 <EvanR> if the view is a tag
22:46:08 <Koterpillar> http://codepad.org/CFtYlRLI
22:48:46 <ski> @type ap (,)  -- sometimes called `graph'
22:48:46 <jp_rider> hi
22:48:47 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
22:48:47 * hackagebot yandex-translate 0.1.0.0 - Bindings to Yandex translate API  https://hackage.haskell.org/package/yandex-translate-0.1.0.0 (johhy1313)
22:48:48 <jp_rider> does anyone have experience setting a CA using HsOpenSSL? 
22:49:22 <jp_rider> I'm attempting to use `contextSetCAFile`, but every connection fails with:
22:49:23 <jp_rider> TlsExceptionHostPort (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa)))
22:49:25 <EvanR> this usage of the word graph is weird ;)
22:50:11 <jp_rider> you can see my attempt here: https://github.com/jprider63/docker-hs/commit/f7d7e884d5bda7c6073e0b5db5dd61c436783d66
22:55:15 <idev> okay, got my stack env working
22:55:22 <idev> does hasell have anything close to row types?
22:55:36 <idev> I'm doing an SQL like DSL in haskell, and I need rowtypes for projection
22:56:37 <EvanR> maybe the library vinyl
22:56:42 <EvanR> will work for you
22:57:22 <idev> https://hackage.haskell.org/package/dependent-map
22:57:29 <idev> how about that or is that unrelated
22:58:47 * hackagebot warp-tls 3.2.2 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.2 (KazuYamamoto)
22:59:10 <EvanR> that might work
22:59:59 <EvanR> you can have fields with different types
23:00:26 <EvanR> but the type of the whole map doesnt tell you whats in it
23:00:41 <idev> that's not good
23:00:46 <idev> i need it to be like the row of a table
23:00:54 <idev> i need the type to tell me the field names and field types
23:01:53 <EvanR> look at vinyl
23:03:44 <idev> https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs does look impressive
23:04:19 <EvanR> a vinyl record type contains a way to go from labels to types, and also the list of labels
23:04:33 <Koterpillar> then also this? http://hackage.haskell.org/package/record
23:04:38 <EvanR> the data is the corresponding values in each field with the proper types
23:06:06 <EvanR> only instances up to 24-ples ? lame
23:08:22 <EvanR> (kidding you probably wouldnt use tuples...)
23:48:50 * hackagebot mongoDB 2.1.0 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.1.0 (VictorDenisov)
23:51:45 <Ashy> hackagebot: it's a trap! 
23:51:58 * Clint squints.
23:52:19 <Ashy> (mondoDB is a trap...)
23:53:09 <systemfault> My name is systemfault and I approve this message.
