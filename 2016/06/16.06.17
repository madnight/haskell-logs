00:07:37 * hackagebot ld-intervals 0.1.0.0 - Data structures for representing arbitrary intervals  https://hackage.haskell.org/package/ld-intervals-0.1.0.0 (savannidgerinel)
00:07:37 * hackagebot docvim 0.3.1.3 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.3 (wincent)
00:15:31 <maybefbi> when i create API clients, i need types that (de)serialize from/to JSON. and the problem is most of these types share fields. how do you solve the duplicate records problem in pre-GHC8 without using template-haskell?
00:16:46 <sbrg> maybefbi: Why not template haskell? You can use functions that modify the record accessor names so that, say, "fooBar" becomes "bar" when serialized and "bar" and the other way around.
00:18:31 <Cale> maybefbi: Aeson's TH stuff can arbitrarily modify the field names when constructing the JSON names to use.
00:18:47 <sbrg> ^
00:18:50 <Cale> maybefbi: You can give it a String -> String function which will strip a common prefix, for instance.
00:19:34 <maybefbi> can i use sbrg's TH solution with Cale's autoprefixer aeson solution?
00:19:47 <Cale> https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson-TH.html
00:19:58 <sbrg> maybefbi: I was referring to the same thing as Cale 
00:20:00 <Cale> I'm talking about the standard Aeson TH stuff
00:20:04 <Cale> and so is he
00:21:25 <sbrg> Cale: since you're here and it seems you're well-versed in dealing with ghcjs: I'd like to implement a simple 2d game using the ghcjs gloss backend. what would be the simplest way for me to start with ghcjs(i.e. least painful)? Just use the stack template? or start with some "starter project"?
00:21:44 <Cale> I would use try-reflex
00:22:22 <Cale> It's a script in the reflex-platform repo that will get you an environment that has ghcjs set up nicely inside of it
00:22:41 <Cale> and it'll download it as a binary so you don't need to spend a lot of time compiling it
00:22:45 <sbrg> so this https://github.com/reflex-frp/reflex-platform 
00:22:48 <sbrg> ?
00:22:59 <sbrg> and that sounds good, since my machine is pretty weak
00:23:07 <Cale> yeah
00:23:22 <sbrg> thanks
00:32:32 * hackagebot once 0.2 - memoization for IO actions and functions  https://hackage.haskell.org/package/once-0.2 (KAction)
00:37:08 <kamog> an "official" https client?
00:38:23 <oherrala> kamog: https://haskelliseasy.readthedocs.io/en/latest/#http-clients
00:57:48 <frosty_ghost> Can someone please help me understand what the fuck the code in exercise 2.42 of SICP does specifically before I fucking lynch myself? I am getting fed up with this shit, and if I can't be a programmer, I refuse to live. I am not trolling; if I can't solve problems like these, I don't deserve to live.
01:00:16 <Edd_> Frosty, can you pastebin the question/code?
01:01:00 <frosty_ghost> Edd_: https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.42
01:02:36 <Edd_> Hmm, I am too new to functional programming to understand that I'm afraid
01:05:36 <Cale> frosty_ghost: Is there anything in particular I can help you understand about it?
01:05:51 <aleator> frosty_ghost: Could you solve this exercise if you had chess board that had only one column of squares?
01:06:10 <frosty_ghost> I suppose so.
01:06:14 <Cale> btw, the exercise isn't to write that code...
01:07:12 <aleator> frosty_ghost: Can you make procedure to check if two queens are threatening each other? 
01:09:42 <frosty_ghost> Yes. My problem is that I don't know how the main procedure works to even formulate solution(s) to the exercises - I don't know what I'm ultimately working on to make the required procedures.
01:10:23 <Cale> So if k = 0, we produce an empty board
01:10:30 <frosty_ghost> I can neither digest wtf Abelson is talking about when describing the recursive solution or his given code, the flatmapping part in particular.
01:11:10 <frosty_ghost> Yeah, that's about the only part I understand when it comes to the queens procedure.
01:11:36 <Cale> Otherwise, we filter a list of lists of potential positions for queens by checking whether the queen in the kth column is safe with respect to the others
01:13:17 <Cale> and this list is constructed by taking the list of solutions to placing k-1 queens safely in the first k-1 columns, and mapping over it a function which produces from such a solution all the ways that you could place a queen in the kth column
01:13:31 <Cale> (and then concatenating all these lists of results)
01:13:55 <Cale> This would be much easier to follow if it were written using either the list monad or a list comprehension
01:17:26 <lpaste> Cale pasted “Same thing translated into Haskell” at http://lpaste.net/166511
01:17:32 <Cale> frosty_ghost: ^^
01:17:37 <Cale> I think that's a bit easier to read
01:26:58 <Cale> frosty_ghost: making any sense?
01:27:08 <frosty_ghost> Hell fucking no.
01:27:40 <Cale> oh, sorry, that should be [emptyBoard]
01:27:49 <lpaste> Cale revised “Same thing translated into Haskell”: “Same thing translated into Haskell” at http://lpaste.net/166511
01:28:11 <frosty_ghost> I'm not blaming you, by any means. *I* just can't wrap my retarded head around the logic of it all; it's not clicking in my head at all.
01:28:41 <Cale> Well, you should just assume that queenCols (k-1) works, first of all
01:28:41 <frosty_ghost> Will the substitution model help with this, or is that out of the question?
01:29:26 <frosty_ghost> Is that the key to understanding recursion of this caliber - assuming it works?
01:29:37 <Cale> In order to understand that queenCols works for any k, you only need to see that queenCols 0 works, and that queenCols k works, given that queenCols (k-1) does.
01:30:20 <Cale> yes, you should always assume that the recursive applications of the function do the thing they are supposed to do when applied to smaller arguments
01:33:03 <frosty_ghost> That's something I'll have to get used to. I'm constantly trying to verify, mentally, that it works on larger procedures too, which, now that I think about it, is fucking stupid, seeing as how its recursion. Yeah, I'm new to this degree of abstract thinking/programming.
01:33:21 <frosty_ghost> s/procedures/inputs
01:33:34 <lpaste> Cale pasted “complete program in Haskell” at http://lpaste.net/166513
01:33:45 <Cale> frosty_ghost: ^^ there, I finished it so you can try it out :)
01:35:50 <athan> Anyone here know of efficient instances of cereal.Serialize for Data.HashMap.Strict/Lazy?
01:36:05 <athan> They've got IntMap and Data.Map already, so I can't imagine it to be too hard
01:37:11 <Cale> athan: Is there a way to take apart a HashMap which breaks its abstraction?
01:37:36 <Cale> (so you could serialise the tree structure directly)
01:39:46 <maybefbi> Cale, I understand Data.Aeson.TH can create ToJSON and FromJSON automatically, but what if two types use to make JSON have fields with the same name, how do you deal with that?
01:40:01 <maybefbi> sbrg, ^
01:40:16 <frosty_ghost> Cale: So, "wishful thinking" is actually a thing? People actually employ it when dealing with recursion?
01:40:37 <athan> ahh good point Cale, thank you
01:40:40 <Cale> maybefbi: I... I thought I told you about the answer to that question like an hour ago :)
01:41:09 <Cale> maybefbi: There's a configuration parameter to the TH stuff which is a String -> String function to apply to the Haskell field names to obtain the JSON ones
01:41:12 <maybefbi> you said String -> String can (un)do prefixing
01:41:30 <Cale> maybefbi: So you can stick in a function that strips off the common prefix on your record field names
01:41:44 <maybefbi> but that means i need to name them fields with the same prefix
01:41:47 <sbrg> maybefbi: Rename the fields so they have different names in haskell, fix them so they have the same name in JSON
01:41:56 <Cale> frosty_ghost: It's mathematically sound -- think about trying to prove by induction that the thing works
01:42:04 <sbrg> maybefbi: no, you can just do stuff like "drop 3" 
01:42:15 <maybefbi> sbrg, ok
01:42:18 <maybefbi> makes sense
01:42:31 <Cale> frosty_ghost: If something is true for 0, and, under the assumption that it's true for k, it is also true for k+1, then it is true for all natural numbers.
01:42:36 <athan> Cale: So ordering / a preservation of static structure to data is almost necessary for serialization?
01:43:12 <Cale> athan: Well, you asked for an efficient way, I'm assuming just converting the thing into a list and serialising the pairs of elements isn't doing the job? :)
01:43:14 <maybefbi> sbrg, what is the best practice prefix you use to name fields
01:43:26 <athan> Yeah ._.
01:43:30 <maybefbi> sbrg, what convention do you use to minimize typing
01:43:38 <athan> I'm just trying to work through what a good model might be
01:43:39 <Cale> maybefbi: You can stick the whole type name on there if you want to
01:43:48 <Cale> Or any sensible abbreviation
01:44:02 <Cale> Just think about what you'd call the function that extracts each field
01:44:06 <frosty_ghost> Cale: Ah, okay... I don't know why I was trying to understand it with k = 8 only. It's becoming a bit more clear as I look at it this way. ... Guess I wasn't thinking abstract enough?
01:44:07 <maybefbi> Cale, hmm ok :( i wish i did not have to type yet more
01:44:11 <sbrg> maybefbi: I don't really have one. I solve the problem on a case by case basis.
01:44:19 <maybefbi> sbrg, ok
01:45:07 <Cale> frosty_ghost: Well, if k was 8 to begin with, then the function applies itself to 7, so you're forced to think about that a bit
01:45:19 <Cale> frosty_ghost: But you should just assume that it works for 7
01:46:21 <Cale> (well, really, you should assume that it works for k-1, and think in terms of filling in an arbitrary column k, not necessarily the very last one)
01:49:33 <Cale> frosty_ghost: So the thing hands you a bunch of partial solutions with queens already placed in the first k-1 columns, and you need to produce a list of all the ways to safely put a queen in the kth column
01:50:15 <Cale> frosty_ghost: So, you try all the possibilities, and check that each one is safe -- and when you do the check to see if it's safe, you only need to consider the new queen -- the others you already know aren't attacking each other.
01:57:35 * hackagebot language-javascript 0.6.0.7 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.7 (ErikDeCastroLopo)
01:57:37 * hackagebot haskell-google-trends 0.0.2 - Simple library for accessing Google Trends  https://hackage.haskell.org/package/haskell-google-trends-0.0.2 (grzegorzgolda)
02:06:29 <andreasd> whois BONUS
02:28:46 <cheater> can someone tell me why this tryAny completes? I thought the takeMVar would block indefinitely and the tryAny would never exit? https://github.com/mitchellwrosen/enclosed-exceptions/pull/1/files#diff-4a2490ac43fb282f0cd922f4edeb0a3eR85
02:35:36 <mauke> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar
02:41:41 <cheater> yeah but how come this ever gets caught
02:41:50 <cheater> i don't understand how tryAny ever completes in this case
02:42:10 <cheater> or does something in that code create another thread?
02:46:00 <Cale> cheater: it catches the exception which is thrown at it because it's blocked indefinitely on an MVar
02:46:32 <Cale> The RTS generates that exception when you get blocked reading from or writing to an MVar which no other thread has a reference to
02:53:57 <tero-_> can I customize instance FromJSON a when using Generic deriving? I'd like to use the field name "data" but it's a reserved word in Haskell  
02:55:39 <quchen> tero-_: No, you cannot influence that. You'll have to write that particular instance yourself.
02:56:08 <tero-_> quchen: ok. I'll use Data.Aeson.TH then. it has fieldLabelModifier
02:59:14 <cheater> Cale: ahh, thanks
03:00:24 <Cale> tero-_: yes, that's the thing to do
03:21:00 <Reite> Does GHC.Generics have something similiar to the everything function from SYB? https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html
03:26:32 <Reite> I want to traverse all values of some type inside a type, like in this blogpost : http://expressiveprogramming.com/presentations/syb_talk.html
03:32:38 * hackagebot irc-client 0.4.1.1 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.1.1 (barrucadu)
03:35:13 <srhb> When does readMVar throw the indefinitelyblocked exception? Not under which circumstances, but how is the check scheduled?
03:37:38 * hackagebot haskell-proxy-list 0.0.1 - Simple library for retrieving proxy servers info from https://proxy-list.org  https://hackage.haskell.org/package/haskell-proxy-list-0.0.1 (grzegorzgolda)
03:39:21 <Cale> srhb: well, here's where it throws it: https://github.com/ghc/ghc/blob/ghc-8.0/rts/Schedule.c#L2848
03:40:39 <Cale> "resurrectThreads is called after garbage collection on the list of threads found to be garbage.  Each of these threads will be woken up and sent a signal: BlockedOnDeadMVar if the thread was blocked on an MVar, or NonTermination if the thread was blocked on a Black Hole."
03:40:41 <srhb> I guess the question then becomes "when is my thread considered garbage"
03:40:43 <srhb> Yeah.
03:52:14 <srhb> It would seem that's "whenever gc happens and the ThreadID has no references"
03:52:21 <srhb> Quite interesting.
03:52:42 <srhb> But that explains the existence of mkWeakThreadId
04:02:29 <Xandaros> Reite: If you figure something out, I'd also be interested in that
04:32:41 * hackagebot http-trace 0.1.0.0 - Tracking http redirects  https://hackage.haskell.org/package/http-trace-0.1.0.0 (sigrlami)
04:35:34 <ggVGc> I used haskell and now I hate all other programming even more
04:35:34 * Zemyla snuggles everyone nini~
04:35:36 <ggVGc> please help
04:35:42 <Zemyla> Wait, wrong channel for that. Ah well.
04:35:57 <Sinestro> It's not like we mind the snuggles.
04:36:14 <puregreen> what's nini? 
04:37:11 <meditans> quick question: how do I find out which extensions imply another? (I'm mainly interested in which ones enable the ExplicitForAll extension)
04:37:41 * hackagebot haskelzinc 0.1.0.0 - CP in Haskell through MiniZinc  https://hackage.haskell.org/package/haskelzinc-0.1.0.0 (klara_mar)
04:39:19 <jmcarthur> meditans: I made this a little while ago and never did much with it. http://i.imgur.com/drL9wnc.png
04:40:52 <meditans> jmcarthur: thanks, that looks very useful!
04:42:35 <Hafydd> Zemyla: it's impressive to snuggle all 1455 people here. You'll surely be tired enough to go to bed after that, if you weren't already.
04:47:42 * hackagebot http-trace 0.1.0.1 - Tracking http redirects  https://hackage.haskell.org/package/http-trace-0.1.0.1 (sigrlami)
04:51:24 <cheater> is there a list of all ghc rewrite rules in base + the most commonly used packages?
04:53:51 <Reite> Xandaros: I found a solution that works for me, the tinplate function from lens: https://hackage.haskell.org/package/lens-4.14/docs/Generics-Deriving-Lens.html#v:tinplate
04:56:26 <Xandaros> Reite: Ah, nice. Thanks. I unfortunately don't use lens in this particular project, but I'll keep it in mind.
05:01:42 <meditans> jmcarthur: just for reference, where did you find the data for that graph? Is there an authoritative source for those dependencies?
05:05:15 <magneticduck> ggVGc: how about lisp?
05:06:04 <magneticduck> it's difficult to compare to Haskell, so you should be safe from those constant pangs of "oh god I could be doing this more correctly / more expressively / with concepts from category theory"
05:12:35 <fizruk> magneticduck: I've used Clojure at my previous work and it was not very pleasant comparing to Haskell (which I use now)
05:12:43 * hackagebot mywatch 0.1.1 - View MySQL processes  https://hackage.haskell.org/package/mywatch-0.1.1 (ip1981)
05:13:23 <fizruk> magneticduck: partially because lazy sequences do not play well with Java exceptions
05:13:50 <magneticduck> oh that must be fun
05:16:13 <fizruk> magneticduck: partially because there are no types and you have to look at function implementation to understand what it does (because documentation is wrong or is missing) and more importantly, what it does not do
05:16:34 <fizruk> magneticduck: and also there are macros
05:17:31 <magneticduck> I'd never consider using lisp for an actual project without some sort of type control
05:17:36 <magneticduck> luckily there are a few solutions now
05:17:55 <magneticduck> you can actually do some pretty cool stuff down that avenue, thanks to macros ^^
05:17:58 <fizruk> and then there is a problem of enforcing these otherwise optional solutions
05:18:31 <magneticduck> well it's not Haskell for sure
05:18:44 <fizruk> yes, it feels that way (that you can do some amazing stuff with macros)
05:19:05 <magneticduck> there should be examples of things you can do in lisp that have no obvious correspondence in Haskell
05:19:37 <fizruk> polyvariadic functions/macros
05:20:34 <fizruk> no obvious correspondence, but we have lists and mconcat, foldMap, traverse, etc.
05:21:10 <fizruk> but maybe you had something bigger in mind?
05:25:19 <Xandaros> You can actually have varargs in Haskell, though it's a bit more difficult than in other languages
05:27:00 <maerwald> yeah, it's a typeclass trick
05:27:31 <tdammers> Text.Printf
05:32:44 * hackagebot morph 0.1.0.0 - A simple database migrator for PostgreSQL  https://hackage.haskell.org/package/morph-0.1.0.0 (thoferon)
05:32:46 * hackagebot haskelzinc 0.1.0.1 - CP in Haskell through MiniZinc  https://hackage.haskell.org/package/haskelzinc-0.1.0.1 (klara_mar)
05:39:28 <danza> Ethereum is being hacked and transactions are frozen. Maybe someone now is regretting the rush they used for developing the infrastructure https://www.reddit.com/r/ethereum/comments/4oimok/can_we_please_never_again_put_100m_in_a_contract/
05:44:31 <danza> also the other posts in that subreddit now are quite interesting
05:44:53 <Xandaros> I like how all the comments are like “meh, don't need no proofs”
05:45:08 <danza> despite what is happening right now ... :D
05:46:09 <akegalj> there is atomicModifyIORef, and atomicWriteIORef for thread safe operations. Why there isn't atomicReadIORef also ? Isn't it possible that at the time that one thread is trying to read IORef, another thread is writing to that IORef ? 
05:46:46 <akegalj> or is this solved in a way that if some thread is using atomic modify/read, it aquires a lock, so ReadIORef will block ?
05:48:44 <fakedrake> hello, I am trying to find the definition of all the instances listed here but greping through regex-tdfa yields nothing particularly useful http://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexContext
05:48:46 <fizruk> akegalj: isn't atomicReadIORef just readIORef?
05:48:58 <fakedrake> can someone point me to the right direction
05:48:59 <fakedrake> ?
05:49:54 <akegalj> fizruk: well name doesn't say that. It maybe is. I am trying to figure out reading the source or readIORef. Maybe it is, I didn't deal with IORef's much before so I wan't to be sure
05:50:13 <Cale> You're only ever reading a pointer, it can't be half-written
05:50:53 <fizruk> akegalj: I mean, how an atomic read is different from just read? unless you read multiple variables
05:51:38 <maerwald> Cale: but you may read an old pointer, no?
05:51:51 <merijn> maerwald: Define old
05:52:11 <merijn> maerwald: IORef, afaik, merely guarantees sequential consistency between threads
05:52:15 <mauke> pointers absolutely can be half-written
05:52:52 <maerwald> merijn: I don't know how to define old. It's just "old". As in: something has written to that IORef and you are not reading that one, but a previous pointer.
05:53:29 <maerwald> not going to define time here
05:53:34 <merijn> mauke: He's saying pointers inside an IORef can't be half-written since IORef are updated atomically
05:54:02 <mauke> merijn: that alone doesn't protect against half-reads
05:54:10 <akegalj> merijn: hm, couldn't figure out that from the code (atomicity of readIORef)
05:54:28 <Cale> Even if you weren't using atomicModifyIORef, you'll never read a half-written IORef
05:54:40 <merijn> maerwald: Like I said, IORefs only guarantee sequential consistency, that is: There is a global order of events that explain the observed behaviour of individual threads
05:54:45 <mauke> Cale: is that documented?
05:54:56 <maerwald> merijn: so the answer is simply "yes"
05:55:05 <merijn> maerwald: This order might not correspond to the actual order of things happening operationally
05:55:24 <merijn> maerwald: No, because what does it mean for a thread to read "after" another thread writes?
05:55:50 <merijn> maerwald: From the consistency perspective in your example the reading thread simply read before the write happened
05:56:39 <akegalj> merijn: I think I got it. So if one thread starts read, atomic modify/read of another thread will block until this thread finishes the read. So it should be safe (ie atomic)
05:57:12 <Cale> mauke: I don't know if it's documented explicitly anywhere, but if it happened, your program would almost surely segfault the moment it tried entering the thunk, and this doesn't happen in practice.
05:57:26 <maerwald> akegalj: that's not how I understood that
05:57:32 <mauke> Cale: that's not very satisfying
05:57:38 <mauke> particularly where threads are involved
06:05:53 <akegalj> maerwald: by reading your comments you are refering to old or new pointer in IORef. So I would read either slightly old value or new value, depending on ordering of operations
06:18:26 <mikail__> Hi, I have written a small function to implement Euler's Phi Function (https://en.wikipedia.org/wiki/Iverson_bracket). I would like to some advice on whether it is idiomatic way to write this mathematical function in Haskell. Code is here: http://lpaste.net/166518
06:19:12 <mikail__> The general pattern is summing only when some predicate is true
06:20:20 <codedmart> Why is this a redundant pattern match -> https://gist.github.com/codedmart/84bbd5068cafb82f7953efa577f402b4#file-main-hs-L1-L3
06:20:23 <lyxia> move the function that maps x to a Bool to the filter predicate mikail__ 
06:20:44 <lyxia> filter (\x -> gcd i x == 1) [1..x]
06:20:57 <lyxia> maps i to a Bool actually, filter (\i -> ...)
06:21:02 <mikail__> wow that's great
06:21:03 <mauke> codedmart: what's the full error message?
06:21:33 <lyxia> mikail__: it's very rare to have a filter with a Bool -> Bool predicate.
06:21:36 <mikail__> I guess your implementation will be faster as well
06:21:46 <lyxia> and (== True) is just id
06:22:20 <lyxia> whereas (== False) is not
06:22:31 <fizruk> and (== True) is just and id
06:22:40 <mikail__> yeah I wasn't sure how to go about it as I had a list of Bool and I wanted to count only the number of True values
06:22:45 <codedmart> mauke: It is not an error but a warning.
06:22:54 <mauke> codedmart: what's the full warning message?
06:22:59 <merijn> codedmart: Well, does WriteResponse have more than one constructor?
06:23:40 <lyxia> mikail__: as for speed, I wouldn't be sure. GHC can optimize list operations pretty well.
06:23:48 <codedmart> https://www.irccloud.com/pastebin/Fhk7sIlY/
06:23:53 <codedmart> mauke: ^^
06:24:33 <mauke> codedmart: what's line 37?
06:24:36 <codedmart> merijn mauke could it be because writeResponseChanges is a Maybe [Change]>
06:24:39 <codedmart> ?
06:24:59 <merijn> codedmart: The _ is part of the match against 'r'
06:25:06 <merijn> codedmart: Which is a WriteReponse
06:25:13 <merijn> Which I'm guessing has only one constructor
06:25:25 <codedmart> mauke: line 37 is line 11 in my previous gist.
06:25:44 <mauke> codedmart: what's the definition of WriteResponse?
06:25:57 <mikail__> lyxia: I can't it to compile: let phi x = filter (\x -> gcd i x == 1) [1..x]
06:26:03 <mikail__> says variable i is not in scope
06:26:09 <codedmart> merijn mauke -> https://github.com/AtnNn/haskell-rethinkdb/blob/a1ad0cd6d30c3a40e6bcdbf90b595ee76ad43b0a/Database/RethinkDB/Driver.hs#L260
06:26:20 <codedmart> That is WriteResponse
06:26:26 <mauke> codedmart: ok, then what merijn said
06:27:40 <codedmart> mauke: Which thing that merijn said?
06:27:48 <mauke> everything
06:27:49 <codedmart> Sorry trying to make sure I understand.
06:28:12 <ocramz> hullo!
06:28:43 <fizruk> codedmart: WriteResponse does not have any other options except WriteResponse, so you don't need "_ -> ..." case
06:29:06 <fizruk> codedmart: where by options I mean constructors
06:29:27 <ocramz> Does anyone here use `hpc`? Also, anyone tried `hpc-coveralls`? I'd like to run hpc after every commit but I'd rather be sure it works as advertised first
06:29:37 <ocramz> every push, I mean
06:29:45 <codedmart> OK I get it now. Thanks mauke merijn fizruk 
06:32:50 <mikail__> got to compile now: let phi n = length $ filter (\x -> gcd x n == 1) [1..n]
06:32:57 <mikail__> *it*
06:39:22 <divVerent> mikail__: correct, and at the same time probably a lot slower than it should be
06:40:14 <mikail__> thanks - I was just thinking about the implementation and it doesn't really follow the math formula
06:40:23 <mettekou> When implementing a dependently-typed (evaluation and typing are interwoven) programming language in Haskell, what is the preferred way of trying to separate both steps as much as possible?
06:40:50 <mikail__> it gives the correct answer but the reason why I implemented it is to see how closely Haskell models maths
06:40:59 <divVerent> ah, I see
06:41:14 <divVerent> maybe this is closer to math notation:
06:41:17 <mikail__> in the math formula if the predicate is true, it is assign a 1 and if not then 0
06:41:23 <mikail__> then the 1's are summed
06:41:44 <mikail__> implementing it the way the maths formula does would be more operations
06:41:48 <mikail__> so slower
06:41:58 <mikail__> it's interesting
06:42:27 <divVerent> let phi n = length [x | x <- [1..n], gcd x n == 1]
06:42:33 <divVerent> is probably closer to usual math notation
06:42:48 <mikail__> yes this was close to my first implementation
06:42:58 <mikail__> but you see that that maths formula involves a summation
06:43:05 <merijn> mettekou: You're familiar with the LambdaPi paper?
06:43:05 <mikail__> we have substituted that with length
06:43:12 <divVerent> mikail__: not the one I was used to in discrete math :P
06:43:15 <mikail__> length is much faster than sum i expect
06:43:45 <mettekou> merijn: The one by Löh et al.?
06:43:45 <mikail__> :)
06:43:45 <Xandaros> I don't think there's a big difference tbh
06:43:55 <divVerent> let phi n = sum [if gcd x n == 1 then 1 else 0 | x <- [1..n]]
06:43:59 <merijn> mettekou: Yeah
06:44:12 <mikail__> yeah I was following the formula on this wiki page: https://en.wikipedia.org/wiki/Iverson_bracket
06:44:37 <mikail__> yeah that is exactly following the wiki formula
06:44:55 <mikail__> that must be slower than the previous impl using length
06:45:46 <divVerent> mikail__: I doubt you can even measure that though
06:45:52 <divVerent> as the gcd is what dominates anyway
06:46:36 <merijn> mettekou: Stephanie Weirich also gave lectures based on LambdaPi at OPLSS in 2014
06:46:42 <mettekou> merijn: Just skimmed to it. They take the separate data type for a value approach and call applications which cannot be evaluated further (free variable in the function position) neutral terms?
06:46:45 <merijn> mettekou: repo + videos are here: https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html
06:46:45 <mettekou> through it **
06:47:02 <merijn> https://github.com/sweirich/pi-forall/tree/2014
06:47:21 <mikail__> yeah good point
06:47:41 <mettekou> merijn: Been through pi-forall and the most recent version of her lectures on YouTube, but haven't checked out the evaluator (or forgotten about it).
06:47:53 <merijn> mettekou: Gym time for me now, hope any of that helps :)
06:52:46 * hackagebot smsaero 0.5 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.5 (NickolayKudasov)
06:59:44 <kmelva> In this code ( https://gist.github.com/kmelva/75f0078383cc3efa71fb0a0610e2389f ) is it possible to skip giving name for label/entry, and just use them in `gridAttach`?
07:01:24 <kmelva> I think I could do it something like `createLabel label_name >>= (\x -> Grid.gridAttach......` but is there a syntacticaly simpler way?
07:01:27 <reabT> Hello, noobie here.. If if I have State that is [a], is there a way to keep doing things with the state until that list is empty?
07:02:47 * hackagebot static-canvas 0.2.0.3 - DSL to generate HTML5 Canvas javascript.  https://hackage.haskell.org/package/static-canvas-0.2.0.3 (jeffreyrosenbluth)
07:03:21 <EvanR> reabT: maybe you want to try the Supply monad
07:03:34 <c_wraith> kmelva: there's the <=< operator in Control.Monad
07:03:39 <c_wraith> :t (<=<)
07:03:40 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:04:01 <ahihi> you
07:04:13 <ahihi> *you're still creating names with the lambda though
07:04:18 <c_wraith> kmelva: it's basically function composition, except for functions returning monadic results
07:05:24 <kmelva> ahihi: so no way to skip the name creation?
07:05:37 <kmelva> c_wraith: thnx, I'll try that one for exercise :)
07:06:05 <lyxia> kmelva: https://gist.github.com/Lysxia/f5e31a527810556c15ae98c688354f8c
07:06:38 <ahihi> ^ I was about to suggest something similar :)
07:06:47 <reabT> EvanR: Will check it out, thanksl
07:06:53 <kmelva> lyxia: thnx! if i understand correctly, that replaces the lambda with a named function to make it more readable
07:07:07 <kmelva> lyxia: but there's no syntax to skip all of that? 
07:07:21 <lyxia> I don't think it's that much better, but it's dryer.
07:07:31 <kmelva> so that its `Grid.gridAttach grid {{whatever}} idx 1 1`?
07:07:58 <lyxia> not really no
07:08:03 <kmelva> {{ and }} standind for some syntax, of course :)
07:08:13 <lyxia> You could define a function that moves around the arguments
07:08:34 <ahihi> @pl \idx x -> gridAttach grid x 0 idx 1 1
07:08:34 <lambdabot> flip flip 1 . flip flip 1 . flip (flip (gridAttach grid) 0)
07:08:40 <lyxia> so that the ones that vary the most move to the end, kind of a generalized flip
07:09:00 <kmelva> ah wow, this flip flip flip thing is a  treat :D
07:09:11 <lyxia> but it hurts readability IMO
07:09:24 <cheater> i haven't been following algebraic effects for some time. are they becoming more practical and useful for haskell than they were a year or two ago?
07:09:31 <kmelva> cool, thnx guys, that settles it!
07:18:00 <codedmart> Can I write this without the case but still have access to w? https://gist.github.com/codedmart/37ab71220b5b6c8994dc918d1dc80321
07:18:43 <dmj> writeResponse w@WriteResponse { .. }
07:19:35 <codedmart> Ah right, couldn’t remember the syntax. Thanks dmj` 
07:20:08 <suppi> but cases are nicer :)
07:20:40 <c_wraith> yes, you can use as-patterns.  But that code is probably better like that.
07:20:58 <codedmart> suppi: You are right, just don’t program haskell enough and want to keep upping my foo.
07:21:09 <EvanR> haskell-foo
07:21:15 <EvanR> kung-foo
07:21:40 <EvanR> if youre not careful "foo" will lose its meaninglessness
07:21:42 <c_wraith> > let f m@(Just x) = show m ++ " " ++ show x ; f _ = "Nothing" in f (Just 10)
07:21:44 <lambdabot>  "Just 10 10"
07:22:25 <c_wraith> The reason being you'd need to bind the same as-pattern in each equation.
07:24:22 <suppi> also, you have to write the name of the function again and again
07:24:42 <suppi> so if you want to change the name one day, you need to change it more times
07:25:15 <suppi> also, adding more arguments to the function will mean adding them in more than one place
07:25:59 <suppi> it's not bad, it's just inconvenient and less good for git diffs and stuff
07:39:16 <EvanR> suppi: but but... miranda style
07:39:27 <suppi> EvanR, ?
07:39:45 <EvanR> repeating the name of the function for each case
07:40:05 <EvanR> looks more like equational 
07:40:22 <EvanR> but yeah a pain in the ass for long names
07:40:43 <suppi> I stated why I prefer the case version. you can choose you own way :)
07:40:53 <fizruk> EvanR: unless you can autocomplete long names
07:41:05 <joncfoo> is there a way to have QuickCheck generate a string of a fixed size containing only digits?
07:41:09 <EvanR> control N in vim
07:41:34 <fizruk> exactly
07:41:50 <EvanR> one thing case cant do is multiple things at once
07:41:52 <EvanR> unless its a tuple
07:43:09 <fizruk> or 2nd thing is a condition
07:43:31 <EvanR> case can do guards
07:43:38 <suppi> case can do anything! :D
07:43:48 <EvanR> but multiwayif is nicer if you only have conditions
07:44:08 <suppi> guards are fine too
07:44:18 <fizruk> yes, I mean I don't think I ever needed to pattern match more than 1 thing, but I've used case with guards
07:44:29 <codedmart> Is there a haskell lib that I can use to get random id’s of specific length?
07:44:30 <fizruk> (in a case)
07:44:35 <EvanR> i have, but i use a where clause new function
07:44:39 <ClaudiusMaximus> joncfoo: you can combine  vectorOf  and  choose  to get a  Gen [Char]
07:45:03 <fizruk> EvanR: hm, I probably do the same without thinking about it
07:45:30 <fizruk> codedmart: what's an id?
07:45:43 <fizruk> codedmart: uuid?
07:45:57 <joncfoo> ClaudiusMaximus: thank you! that helps so much!
07:46:04 <EvanR> presumably the library lets you explain what an id is ;)
07:46:12 <joncfoo> I don't know how I missed that in the docs
07:46:16 <codedmart> fizruk: I would use uuid in general, but I only want it to be a length of 10.
07:46:31 <codedmart> But yes id’s to generate for database entries.
07:47:10 <EvanR> sounds like a good library idea
07:47:33 <EvanR> configurable format, deals with random for you, and protects against generating the same id twice somehow
07:48:11 <joncfoo> codedmart: use a uuid, it will save you all sorts of trouble
07:48:18 <EvanR> example, increment a counter, do a random-like (fixed) permutation between the counter and maxBound :: Word64, then format with cipher
07:48:49 <codedmart> joncfoo: I agree but that is not an option at this point in time. It is a strict requirement that id’s are only a length of 10
07:48:57 <EvanR> or 10^10
07:49:21 <fizruk> codedmart: you can cut uuid, but I'm not sure that's wise
07:49:35 <codedmart> fizruk: That is my fear with doing that.
07:50:21 <fizruk> codedmart: is your ID alphanumeric?
07:50:50 <fizruk> codedmart: is it just some text of length 10? if so you could fit uuid there
07:51:00 <EvanR> let prime = 10795634417041 in 1*prime `mod` 10^10
07:51:05 <EvanR> > let prime = 10795634417041 in 1*prime `mod` 10^10
07:51:07 <lambdabot>  5634417041
07:51:12 <EvanR> > let prime = 10795634417041 in 2*prime `mod` 10^10
07:51:13 <lambdabot>  1268834082
07:51:19 <EvanR> > let prime = 10795634417041 in 3*prime `mod` 10^10
07:51:21 <lambdabot>  6903251123
07:51:22 <EvanR> hmm
07:52:09 <codedmart> fizruk: yes alphanumeric is fine
07:52:10 <EvanR> "random" 10 digit ids ;)
07:52:25 <codedmart> fizruk: I could use uuid with length of 10?
07:52:38 <codedmart> No dashes as well is a specific requirement :(.
07:53:11 <romildo> Can the expression   (map (\xs -> f (map g xs)) xss)    be written without two explicitly call to map? Maybe with a higher order function from the library.
07:53:19 <fizruk> codedmart: yes, because uuid is normally encoded with only 16 symbols (apart from dashes which are there only for readability), but you can encode uuid with e.g. base64
07:53:26 <EvanR> > let gen i = i*10795634417041 `mod` 10^10 in map (show . gen) [1..]
07:53:28 <lambdabot>  ["5634417041","1268834082","6903251123","2537668164","8172085205","380650224...
07:53:33 <fizruk> codedmart: I think I have the code for you...
07:53:56 <codedmart> fizruk: Ah interesting, would appreciate that.
07:58:49 <fizruk> codedmart: here's a YouTube style encoding for UUIDs I use (not for DB, but for URLs) https://gist.github.com/fizruk/0b049254874bba5f3ccc0cf2e4c5663d
08:00:21 <mikail__> hi, what are some good resources for doing scientific/numerical computing in Haskell?
08:00:56 <dmj> @google vector tutorial haskell
08:00:57 <lambdabot> https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial
08:01:08 <codedmart> fizruk: Thanks I will try it out.
08:02:00 <dmj`> @google vector school of haskell
08:02:01 <lambdabot> https://www.schoolofhaskell.com/user/commercial/content/vector
08:02:58 <romildo> :type \f g xss -> map (\xs -> f (map g xs)) xss
08:03:59 <romildo> @type \f g xss -> map (\xs -> f (map g xs)) xss
08:04:00 <lambdabot> ([b1] -> b) -> (a -> b1) -> [[a]] -> [b]
08:05:03 <romildo> @pl \f g xss -> map (\xs -> f (map g xs)) xss
08:05:03 <lambdabot> (map .) . (. map) . (.)
08:08:33 <puregreen> does anybody know a library to merge changes done to a strings? basically I have a piece of text (original version), version A, version B, and I want to produce a version that combines changes made in A and in B
08:10:09 <byorgey> @type \f g -> map (f . map g)
08:10:10 <lambdabot> ([b1] -> b) -> (a -> b1) -> [[a]] -> [b]
08:10:17 <byorgey> romildo: ^^^ how about that?
08:10:34 <puregreen> in particular, are there any keywords to look up on Hackage other than “diff”, “patch”, and “operational transformation”?
08:10:50 <byorgey> puregreen: http://hackage.haskell.org/package/diff3 ?
08:11:50 <romildo> byorgey, nice
08:12:16 <codedmart> fizruk: Where does Arbitrary come from? I haven’t done anything with that.
08:13:01 <fizruk> codedmart: just ignore it, I have a local Arbitrary instance for UUID (Arbitrary class comes from QuickCheck)
08:13:51 <fizruk> codedmart: I've removed unused classes from that paste
08:14:17 <codedmart> fizruk: OK thanks again!
08:14:50 <puregreen> byorgey: okay, thanks, I'll look at it and at patches-vector
08:14:57 <romildo> byorgey, what would be nice name for such a function? Any suggestion?
08:16:00 <byorgey> romildo: no idea.  To me it doesn't seem simple/generally useful enough to warrant its own name.
08:21:45 <buglebudabey> for those who are using a mac, what irc clients are you using
08:22:53 <mikail`> i use CIRC
08:22:55 <ahihi> irssi, but this seems more relevant to ##mac or #macosx
08:22:57 <mikail`> via Chrome
08:23:29 <buglebudabey> noted ahihi 
08:24:06 <dmj`> buglebudabey: glguy has a sweet clien
08:24:08 <dmj`> https://github.com/glguy/irc-core
08:26:18 <buglebudabey> thanks im checking it out now
08:26:42 <hguant> irssi as well
08:27:04 <fizruk> buglebudabey: colloquy
08:41:17 <codedmart> fizruk: in your replace func. Are + / the only symbols that could be present?
08:41:56 <fizruk> codedmart: yes, those are the only offending symbols in base64 encoding for URLs
08:42:50 * hackagebot yesod-auth-ldap-native 0.2.0.0 - Yesod LDAP authentication plugin  https://hackage.haskell.org/package/yesod-auth-ldap-native-0.2.0.0 (mkazulak)
08:42:54 <codedmart> Are those considered alphanumeric? I mean would I need to worry about any others if I just want characters and numbers.
08:43:59 <codedmart> fizruk: ^^
08:45:06 <fizruk> codedmart: no, all others are latin characters and digits (see https://en.wikipedia.org/wiki/Base64)
08:45:27 <codedmart> Sorry lazy question I guess I could have looked at that. Thanks!
08:46:11 <fizruk> codedmart: 26 small + 26 capital + 10 digits = 62 symbols, so you need 2 extra for base 64
08:46:38 <codedmart> Ah makes sense :)
08:47:57 <kritzcreek> when parsing with the Earley library, should I prepend a lexing stage?
08:48:53 <kritzcreek> and given that I want to parse a lisp... is there something like a "languageDef" from parsec which just lexes into Tokens?
09:06:48 <codedmart> Is there a function in haskell already similar to merge/assign in js. As in if I have a data Design, defaultDesign, and a Design can I merge defaultDesign and Design rather then having to manually do each attr like defaultDesign { id = ..., title = …, ... }
09:07:11 <fizruk> codedmart: that's mappend
09:07:12 <osa1> codedmart: <> from monoid
09:07:36 <fizruk> codedmart: there's a genericMappend somewhere in edwardk's packages for product types
09:08:32 <fizruk> codedmart: however that might not help you depending on what your fields are
09:08:43 <codedmart> Makes sense
09:10:46 <EvanR> where is <+> defined
09:10:54 <EvanR> if at all
09:10:56 <codedmart> fizruk: any good examples you can point me to for Monoid instances with custom data
09:10:58 <EvanR> :t (<+>)
09:10:59 <lambdabot>     Ambiguous occurrence ‘<+>’
09:10:59 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
09:10:59 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:43:1-20
09:11:07 <EvanR> isnt there a mplus operator
09:11:28 <fizruk> EvanR: don't you want <|>?
09:12:06 <KaneTW> @more
09:12:20 <fizruk> codedmart: perhaps you stack's config types
09:13:14 <codedmart> fizruk: Not sure I understand what you just said.
09:13:18 <fizruk> codedmart: https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/Config.hs
09:13:34 <codedmart> Ah ok, looking...
09:13:51 <EvanR> fizruk: roit
09:14:09 <fizruk> codedmart: seems they have developed their own generic implementation
09:14:15 <EvanR> coulda sworn <+> existed
09:15:24 <fizruk> codedmart: https://hackage.haskell.org/package/generic-deriving-1.10.4.1/docs/Generics-Deriving-Monoid.html
09:16:18 <fizruk> I wish they specified which monoid instance they derive...
09:17:05 <codedmart> fizruk: Well I will see if it helps
09:17:29 <fizruk> codedmart: this instance example might help more: https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/Config.hs#L1623
09:18:25 <codedmart> Ah that does. Thanks! 
09:21:38 <dunpeal> There was a book published 2004 called The Haskell Road to Logic, Math and Programming
09:22:13 <dunpeal> It taught Haskell together with logic, math, and the basics for type theory.
09:22:26 <dunpeal> Is there any other recommended book like this, perhaps more recent / up to date?
09:25:04 <Cale> dunpeal: I don't really know of one, but I don't imagine that there's much in that book which is very time-sensitive either. It didn't really bother with the practical details of Haskell so much...
09:27:16 <dunpeal> Cale: would it be your top recommendation for this type of a book?
09:27:26 <Cale> It was a bit of an awkward book, because if you were primarily interested in Haskell, it would be unsatisfying in that it didn't really teach you enough Haskell to be useful for ordinary programming, but then if you were primarily interested in mathematics, I'm not sure how helpful mixing a bit of Haskell in with everything else is.
09:28:51 <dunpeal> Cale: what else would you recommend for someone who wants to learn Haskell, but also the mathematical, logical, and type-theory fundamentals behind it?
09:28:53 <Cale> But if you just happen to both be learning Haskell and the bits of discrete mathematics, number theory and logic that it has at around the same time, then I'm sure it does a good job :)
09:29:48 <Cale> The mathematics it discusses is not really the mathematics behind Haskell.
09:30:36 <Cale> If you're interested in learning the fundamentals of type theory, Types and Programming Languages by Pierce is good (but it doesn't use Haskell)
09:32:39 <dunpeal> Cale: How about learning discrete math, or algorithms, with Haskell?  Are there books that do that?
09:33:33 <Cale> Well, the one you mentioned.
09:35:17 <Cale> I dunno. Haskell isn't a great programming language in which to do mathematics, since its type theory is inconsistent (as a logical theory), so you can't really use it very effectively to prove theorems, like you could with Coq or Agda.
09:35:50 <dunpeal> Cale: OK, and finally, which resource would you recommend for someone wanting to learn and use Haskell as a practical programmer with plenty of programming experience (especially with dynamic languages) but no knowledge of type theory or math?
09:36:05 <EvanR> does anyone know what "flatmap" refers to?
09:36:09 <EvanR> in other languages
09:36:13 <Cale> EvanR: concatMap
09:36:32 <kritzcreek> bind :P
09:36:32 <ahihi> or >>=
09:36:35 <EvanR> really?
09:36:47 <dmwit> really
09:36:49 <Cale> dunpeal: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html is a good free resource
09:36:51 <glguy> but seriously?
09:37:02 <dmwit> EvanR: It's not a terrible name if you think of `flat` = `join` and `map` = `fmap`.
09:37:02 <EvanR> list >>= ?
09:37:15 <EvanR> right
09:37:31 <EvanR> is it just for lists or any monad
09:37:36 <EvanR> like Option
09:37:54 <dmwit> I expect that depends on the language and possibly even the library it comes from.
09:37:54 <kritzcreek> elm uses "andThen" for other monads
09:37:56 <ahihi> scala uses it for several monads
09:38:06 <ahihi> and almost-monads
09:38:12 <Cale> dunpeal: bitemyapp is writing a huge book on Haskell here: http://haskellbook.com/ -- I haven't really had the chance to go over much of it, but I've heard people who were quite happy with it
09:38:19 <EvanR> near-nads
09:38:27 <dmwit> less-nads
09:38:29 <cjay> even java Optional has flatMap
09:38:39 <EvanR> ah hah
09:39:17 <codedmart> I am not sure I understand this error: https://gist.github.com/codedmart/682f5265dfcc0a5bae5393b02efba875
09:39:54 <Cale> dunpeal: http://www.cs.nott.ac.uk/~pszgmh/book.html -- this book is perhaps a little limited in scope with respect to getting you to the point of practical software development, but it's good for what it covers
09:40:04 <dmwit> codedmart: Perhaps you meant `id r <> id l`.
09:40:25 <dmwit> codedmart: `<|>` is for `Alternative` instances, and `Text` has the wrong kind to be an `Alternative`.
09:41:03 <codedmart> dmwit: No I meant <|>, I want the take id r if it is resent otherwise use id l.
09:41:15 <dmwit> codedmart: What does "resent" mean?
09:41:24 <codedmart> SOrry typo.
09:41:31 <Cale> dunpeal: If you're interested in mathematics, I would generally recommend sticking to books that are specifically written about the mathematics that you're interested in learning -- if there's a topic in particular, I might even be able to recommend something more specific.
09:41:38 <codedmart> dmwit: If it is present not resent
09:41:48 <Cale> dunpeal: But you don't need a strong mathematics background to program in Haskell.
09:41:59 <dmwit> codedmart: What does "present" mean?
09:42:01 <edwardxhaigh> Haskell is GREAT for Project Euler
09:42:15 <dunpeal> Cale: I'm mostly interested in algorithms, and understanding the mathematical basis for analyzing and designing them.
09:42:28 <Cale> dunpeal: Perhaps Okasaki's book would be good
09:42:53 <Cale> https://www.amazon.ca/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
09:42:58 <codedmart> dmwit: I have a defaultDesign that will be l and I want to merge a Design with default design. So if the id is present in the r Design use that id otherwise use the id from the l Design (which is the default one)
09:42:58 <verement> :t (<|>)
09:42:59 <lambdabot> Alternative f => f a -> f a -> f a
09:43:18 <dunpeal> Things like recursion, induction, and other topics in combinatorics and discrete math...
09:43:20 <dmwit> codedmart: Again: what does "present" mean?
09:43:35 <Cale> dunpeal: It's an extension of his thesis, which you can read here: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:43:50 <codedmart> dmwit: Ah I see what you mean.
09:44:09 <codedmart> I am being silly. I only need to do that on the Maybe's
09:44:55 <dunpeal> Cale: thanks. have you seen the "Introduction to Functional Programming" course by Erik Meijer?  It uses the Hutton book apparently
09:45:18 <glguy> codedmart: You're going to need more "Maybe" fields for this to work or you won't have a Monoid. mempty needs to be the identity element for mappend
09:45:37 <glguy> codedmart: so you need to make sure that combining it with something doesn't detroy the "id" field, for example
09:47:29 <dmwit> codedmart: To pop up a level: are you sure you want to merge two designs?
09:47:38 <dmwit> codedmart: Perhaps you really just want to override some fields on a single design.
09:48:09 <dmwit> codedmart: e.g. maybe the syntax `defaultDesign { slug = foo, description = bar }` already meets your needs without the definition of further functions.
09:48:37 <dmwit> codedmart: That syntax defines a new `Design` which is just like the default one everywhere, except that the `slug` and `description` fields are different.
09:49:50 <codedmart> dmwit: That is the goal is to take a Design and override some things.
09:50:23 <dmwit> Personally I would skip the `Monoid` instance, then. Just use the built-in record syntax, or if you plan to have nested records *maybe* look into using lenses.
09:51:02 <dmwit> Since it seems like this is an early Haskell project for you, I would probably recommend avoiding lenses for now.
09:51:17 <dmwit> (First get a firm grip on the language. Then use the exciting stuff. ;-)
09:52:52 <codedmart> dmwit: I have used lenes some before. Surprisly I can get a fair amount done in haskell, with my knowledge where it is at. I just don’t understand a lot of underlying things very well yet or forget things that I have seen/done before.
09:53:58 <codedmart> Whether a monoid instance or a function that uses the record syntax I just want to be able to merge some defaults into the Maybe attrs if they are Nothing.
09:54:24 <dmwit> codedmart: Why write a function?
09:54:43 <dmwit> Like, why write a function at all? I'm not objecting to the name `mappend`, I'm objecting to the need for further code.
09:55:08 <codedmart> Because I will end up using that override in a few other places. I don’t want to duplicate that.
09:55:36 <codedmart> dmwit: Am I missing something you are trying to hint at?
09:55:39 <Cale> dunpeal: Is this the course he's teaching using Hugs for some inexplicable reason? (a very obsolete Haskell interpreter which hasn't seen an update in about a decade)
09:55:58 <dmwit> codedmart: I hope not. I was trying to be as blunt as possible.
09:56:53 <glguy> codedmart: Maybe you could show an example of some code where you thought it was a good idea to structure things in this way and then some concrete code could be discussed/improved?
09:56:55 <dmwit> codedmart: I guess what I'm getting at is: you're going to have to provide arguments to this function, however it's defined. What syntax do you plan to use for providing those arguments? Perhaps you can show an example, and we can see whether the built-in syntax will actually be worse.
09:56:59 <dunpeal> Cale: not sure, but there appears to be a modern version of the Upenn CIS 194 you recommended, using Stack to check the assignments: https://github.com/laser/cis-194-winter-2016
09:57:08 * dmwit high fives glguy
09:57:13 <glguy> Up top!
09:57:46 <Cale> dunpeal: Every season, the course is different, and the one I linked is generally regarded as good, but feel free to poke around.
09:57:48 <codedmart> glguy dmwit Fair enough, when I finish with my ideas I will ask for feedback. I appreciate everyones help and insights.
09:58:30 <dunpeal> Cale: I really like the idea of being able to "submit" assignments and have them checked
09:59:20 <dunpeal> Cale: I don't think the EdX course is using Hugs - its Resources page links GHC at the top: https://courses.edx.org/courses/course-v1%3ADelftX%2BFP101x%2B3T2015/wiki/DelftX.FP101x.3T2015/resources-and-links/
10:01:39 <dunpeal> Cale: actually, you're right - it's using Hugs (even though GHC is mentioned frequently for some reason)
10:02:48 <siwica> I want to use the <|> operator from Text.Parsec but I am also
10:02:49 <siwica> 	 importing Control.Applicative which also contains a <|> operator. How
10:02:49 <siwica> 	 do I make sure that the former operator shadows the latter?
10:03:27 <EvanR> arent they the same?
10:03:32 <puregreen> siwica: “import Text.Parsec hiding ((<|>))”
10:03:35 <puregreen> EvanR: no :(
10:03:40 <EvanR> >_<
10:03:42 <puregreen> they have different fixity, too
10:03:46 <Profpatsch> P.<|>
10:03:48 <puregreen> slightly different but still
10:03:56 <Profpatsch> Or do you have to still wrap it in ()?
10:04:01 <puregreen> that's one of the things that megaparsec fixes, among others
10:04:15 <dmwit> I think parsec defining (<|>) is mostly historical accident.
10:04:29 <dmwit> Feel free to hide parsec's version of it with impunity.
10:05:07 <dmwit> Oh, actually, you say you want to prefer parsec's version. Why is that?
10:06:20 <siwica> puregreen:thank you!
10:12:53 * hackagebot crypto-multihash 0.1.0.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.1.0.0 (mseri)
10:19:28 <mniip> I feel like "process z (x:xs) = let z' = f z x in z':process z' xs" is a common pattern, does it have a name?
10:20:21 <dmwit> > scanl f z [a,b,c]
10:20:22 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
10:20:27 <mniip> seems similar to scanl yes
10:20:29 <mniip> but not quite
10:20:50 <mniip> oh actually
10:20:54 <mniip> it might be scanl after all
10:20:56 <crough> paramorphism?
10:21:31 <dmwit> > let process z (x:xs) = let z' = f z x in z' : process z'; process z [] = [] in process f [z,a,b,c]
10:21:33 <lambdabot>      Couldn't match expected type ‘[a1]’ with actual type ‘[t] -> [a1]’
10:21:33 <lambdabot>      Relevant bindings include
10:21:33 <lambdabot>        z' :: a1 (bound at <interactive>:1:28)
10:21:59 <dmwit> > let {process z (x:xs) = {let z' = f z x in z' : process z'}; process z [] = []} in process f [z,a,b,c]
10:22:00 <lambdabot>  <hint>:1:25: parse error on input ‘{’
10:22:23 <ClaudiusMaximus> > let process z (x:xs) = let z' = f z x in z' : process z' xs; process z [] = [] in process f [z,a,b,c]
10:22:24 <lambdabot>      No instance for (Show a0)
10:22:24 <lambdabot>        arising from a use of ‘show_M3320730148850658399159’
10:22:24 <lambdabot>      The type variable ‘a0’ is ambiguous
10:23:04 <mniip> > let process f z (x:xs) = let z' = f z x in z' : process f z'; process f z [] = [] in process f z [a,b,c]
10:23:09 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘[t] -> [a]’
10:23:10 <ClaudiusMaximus> > let process z (x:xs) = let z' = f z x in z' : process z' xs; process z [] = [] in process z [a,b,c] :: [Expr]
10:23:12 <lambdabot>      Relevant bindings include
10:23:13 <mniip> damn
10:23:17 <lambdabot>  [f z a,f (f z a) b,f (f (f z a) b) c]
10:23:19 <lambdabot>        z' :: a (bound at <interactive>:1:30)
10:24:28 <dmwit> So, yeah, scanl.
10:25:19 <glguy> > tail (scanl f z [a,b,c])
10:25:21 <lambdabot>  [f z a,f (f z a) b,f (f (f z a) b) c]
10:31:21 <dmwit> > scanl1 f [z,a,b,c] -- sometimes
10:31:23 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c]
10:32:01 <dmwit> I'm not sure I've ever used `scanl` without `tail` or an equivalent.
10:32:53 <Alxandr> Hi. I need some help trying to figure out what's wrong about a presumption I have. In my mind, foldr (<|>) empty [a, b] should equal to empty <|> b <|> a, shouldn't it?
10:33:38 <mniip> well here I'm using "scanl nextState base (init $ tails xs)"
10:34:24 <mniip> trying to get rid of the special-casing now
10:35:03 <S11001001> Alxandr: reverse it
10:35:16 <Alxandr> So it should be equal to a <|> b <|> empty?
10:35:33 <S11001001> Alxandr: you might be confused because the order of args to the HOF arg to foldr is backwards from how it is for foldl (a -> b -> a instead of b -> a -> a)
10:35:36 <S11001001> Alxandr: yah
10:35:41 <dolio> > fix . (1:) $ scanl (+) 1
10:35:42 <lambdabot>      Couldn't match type ‘[Integer]’ with ‘c -> c’
10:35:42 <lambdabot>      Expected type: [Integer] -> c -> c
10:35:42 <lambdabot>        Actual type: [Integer] -> [Integer]
10:35:43 <dmwit> Alxandr: Yes, modulo the caveat that it is `a <|> (b <|> empty)`.
10:35:49 <dolio> Oh, whoops.
10:35:59 <S11001001> @info <|>
10:35:59 <lambdabot> <unknown>.hs: 1: 1:Parse error: <|>
10:36:17 <dolio> > fix $ (1:) . scanl (+) 1
10:36:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:36:31 <dmwit> Alxandr: You may like the diagrams in https://wiki.haskell.org/Fold#List_folds_as_structural_transformations
10:36:56 <dmj`> foldr (<|>) empty (a:[b]) = a <|> (foldr (<|>) empty [b]) = a <|> b <|> (foldr (<|) empty []) = a <|> b <|> (foldr f empty []) = a <|> b <|> empty
10:37:40 <dmj`> duplicated one step in there
10:37:45 <S11001001> > foldr (<|>) z [a,b,c]
10:37:46 <lambdabot>      Couldn't match expected type ‘f a’ with actual type ‘Expr’
10:37:46 <lambdabot>      In the second argument of ‘foldr’, namely ‘z’
10:37:46 <lambdabot>      In the expression: foldr (<|>) z [a, b, c]    Couldn't match expected ty...
10:37:50 <S11001001> eh
10:37:50 <Alxandr> Could I get some help looking at ~6 lines of code and see where my thinking is wrong then, cause I think that's one of the cases I've tested.
10:37:54 * hackagebot diagrams-html5 1.3.0.6 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.6 (BrentYorgey)
10:38:04 <dmj`> @src foldr
10:38:04 <lambdabot> foldr f z []     = z
10:38:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:38:05 <dmwit> ?hpaste some code, Alxandr!
10:38:06 <lambdabot> Haskell pastebin: http://lpaste.net/
10:38:15 <dmwit> Oops, I guess it's lpaste now.
10:38:18 <dmwit> I've been out of the loop a bit.
10:38:19 <lpaste> Alxandr pasted “Wrong in parsers” at http://lpaste.net/166555
10:38:53 <Alxandr> Yeah. I figured. Was just looking up where you did your pastings
10:39:15 <Alxandr> The parsers on the top works as expected
10:39:16 <S11001001> Alxandr: first, legally, there's no difference between the outcomes of asum and bsum
10:39:20 <Alxandr> The ones on the bottom does not
10:39:36 <Alxandr> No? One uses foldl and the other foldr
10:39:44 <dmwit> S11001001: That doesn't sound right. There's nothing that says `a <|> b = b <|> a`.
10:39:54 <Alxandr> I figured one was from left to right, the other was from right to left
10:40:01 <Alxandr> No. I know.
10:40:05 <Alxandr> Obviously
10:40:10 <Alxandr> But, the first two work
10:40:13 <S11001001> dmwit: the only change from foldl to foldr for <|> is associativity
10:40:17 <Alxandr> And the 3rd and 4th works
10:40:26 <Alxandr> Ah
10:40:28 <Alxandr> It is?
10:40:32 <dmwit> S11001001: You're right.
10:40:42 <Alxandr> So they all go right to left?
10:40:50 <Alxandr> *left to right
10:41:02 <Alxandr> As in string ">>>" get's invoked first
10:41:05 <S11001001> also the empty will go on the other side.  But...it's empty
10:41:25 <Alxandr> Actually, p5 also works, the comment there is wrong
10:41:38 <Alxandr> Yeah, I just added empties to see if it affected the restuls
10:41:41 <Alxandr> It doesn't seem to
10:41:55 <S11001001> that is, for asum vs bsum
10:41:55 <Alxandr> I was just trying to figure out where my presumptions were wrong
10:42:13 <Alxandr> But if the difference between foldl and foldr is only associativity, then it makes sense
10:43:18 <Alxandr> And I learnt how to (sort off) haskell for this single goddamn problem D:
10:43:23 <S11001001> Alxandr: I should clarify that the empty will change sides too; for foldr it's at the end, for foldl at the beginning.  But that doesn't change the results, because empty is empty
10:43:25 <dmwit> Alxandr: Can you say what is wrong about (say) `p6`?
10:43:44 <Alxandr> It shortsircuits on return
10:43:54 <Alxandr> So the string parser is never invoked
10:43:57 <dmwit> Why is that wrong?
10:44:08 <mniip> @pl \x y z -> f x
10:44:08 <lambdabot> const . const . f
10:44:13 <Alxandr> Cause the point of it is to generate better error messages
10:44:29 <Alxandr> So parsers (even if they pass) produce hints, in case composed parsers fail
10:44:47 <Alxandr> So in p1->p5 you get error that "expected bar or end of input"
10:44:55 <Alxandr> But on the rest you just get "expected end of input"
10:45:12 <Alxandr> Whereas idealy they'd be the same
10:45:18 <Alxandr> But it'd require me running all parsers
10:45:25 <dmwit> Okay. Well, `a <|> b` and `b <|> a` simply aren't the same in parsec.
10:45:34 <Alxandr> This isn't parsec
10:45:36 <Alxandr> It's megaparsec
10:45:48 <Alxandr> Which is supposed to deal with some of that stuff
10:45:52 <Alxandr> But apparently not all of it
10:45:56 <dmj`> mega!!
10:45:59 <Alxandr> Yes
10:46:04 <Alxandr> Don't care for the name
10:46:12 <Alxandr> But it does generally make good errors
10:46:14 <S11001001> I believe that it's required for <|> that return x <|> p ignore the p
10:47:01 <Clint> what would it do otherwise?
10:47:19 <S11001001> never mind, that's more of a MonadPlus thing; <|> should admit a flipped dual like applicative
10:47:25 <Alxandr> Now I just have to figure out how to model the difference between assosiativety in foldl and foldr into f#...
10:47:42 <dmwit> I doubt `a <|> b` and `b <|> a` are the same in megaparsec, either.
10:47:49 <Alxandr> No, they're not
10:48:01 <Alxandr> But they are (in theory) mostly supposed to give the same error messages
10:48:12 * Clint squints.
10:48:13 <Alxandr> Cause if all of them fail, then you expected one of them
10:48:32 <dmwit> Alxandr: But the failure isn't coming from `a <|> b`.
10:48:32 <Alxandr> But in some cases, it's really impractical to do so
10:48:47 <dmwit> Alxandr: So it's not true that "all of them failed".
10:48:50 <S11001001> Alxandr: does megaparsec's parser type also provide MonadPlus?
10:49:01 <Alxandr> I don't know what MonadPlus is :P
10:49:12 <dmwit> S11001001: Yes, and it's the same as its Alternative instance.
10:49:24 <Alxandr> No reference to MonadPlus in the source it seems
10:49:34 <Alxandr> @dimwit, yeah I got that
10:49:34 <lambdabot> Unknown command, try @list
10:49:41 <Alxandr> I just read one of the tests fail
10:49:46 <glguy> alx741: @ is for bot commands
10:49:53 <glguy> Alxandr, rather
10:49:53 <dmwit> Alxandr: It is referenced in the source: http://hackage.haskell.org/package/megaparsec-5.0.0/docs/src/Text-Megaparsec-Prim.html#line-447
10:49:56 <Alxandr> Cause I thought foldr was right to left whereas foldl was left to right (same assoc)
10:50:48 <Alxandr> @dmwit oh right, I was searching through the test file, not the implementation file
10:50:48 <lambdabot> Unknown command, try @list
10:51:12 <glguy> Alxandr: @ is for bot commands, not addressing people
10:51:17 <dmwit> The usual IRC style is to post-fix a nick with `:` or `,` rather than prefixing it with `@`.
10:51:19 <Alxandr> Oh
10:51:22 <Alxandr> Sorry
10:51:31 <Alxandr> I've not been on IRC much for years
10:51:31 <lpaste> mniip pasted “scanl” at http://lpaste.net/166557
10:51:54 <Alxandr> These days it's all slack and gitter.im and such
10:52:07 <rom1504> gitter does @pseudo
10:52:16 <Alxandr> I mean, I'm currently on webchat.freenode.net :P
10:52:27 <S11001001> I guess they are trying to adhere to "left catch" https://wiki.haskell.org/MonadPlus , but it seems more like a design decision than a necessity
10:53:10 <Alxandr> What bummed me was the following: https://github.com/mrkkrp/megaparsec/blob/master/tests/Prim.hs#L392
10:53:32 <EvanR> slack? IRC... obviously AIM is the best
10:53:36 <Alxandr> Cause I read that as "we get the same error independent on order"
10:53:51 <Alxandr> EvanR: I don't believe I ever was on AIM
10:53:55 <letters> Hi, noobie question. For some reason I've been hearing quite a lot about a package unordered-collections. However, it has no documentation whatsoever. Is it in a beta or something? Should I not use it yet?
10:54:12 <Clint> letters: do you mean unordered-containers?
10:54:27 <letters> Clint: Yes, my mistake.
10:54:41 <dmwit> letters: Seems the docs just didn't build. Look at one older version.
10:54:45 <EvanR> letters: HashMap works for Hashable keys, regular Map works for Ord keys
10:54:47 <dmwit> letters: e.g. 2.7.0 docs are available.
10:55:04 <EvanR> [(k,v)] works for Eq keys ;)
10:55:15 <dmwit> http://hackage.haskell.org/package/unordered-containers-0.2.7.0
10:55:23 <EvanR> k -> v works for any keys
10:56:57 <letters> dmwit: Thanks.
10:57:38 <dmwit> "docs pending" for more than a week seems odd, I will admit.
10:58:00 <dmwit> I wonder if Hackage's build infrastructure is still working properly.
10:59:24 <EvanR> maybe its building in a queue and the queue is growing without bound
10:59:28 <letters> Hm, I don't know how Hackage upload procedure works, so I thought "docs pending" line meant that the docs for the package in general are not written, rather than just it failed to build for one version.
10:59:35 <EvanR> explaining hackage dying randomly
11:00:10 <dmwit> letters: Ah, yeah, that is quite deceptive UI for the uninitiated.
11:00:31 <glguy> pending  means it hasn't even tried yet, it can also say failed
11:01:08 <letters> Yeah, I see now. Anyways, thanks for the answer.
11:06:12 <Alxandr> Would anyone of you be capable of creating the foldl and foldr functions in another language (like javascript or something), cause I'm still apparently doing it wrong in my F# :-/
11:06:51 <EvanR> @src foldl
11:06:52 <lambdabot> foldl f z []     = z
11:06:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:07:17 <EvanR> you can write it just like this, but many languages explode when you try to use recursion
11:07:45 <mikail`> lol
11:07:48 <S11001001> Alxandr: if you join the ##fsharp channel and post a paste there, might be worthwhile
11:08:27 <Alxandr> The problem is the foldl and foldr function source I've found in haskell is really short. But I'll give it a go, after another shot.
11:09:00 <EvanR> a more efficient version would use a loop and an accumulating variable
11:09:12 <EvanR> (in language blub)
11:10:41 <S11001001> stack consumption probably isn't a problem in this use case, even with strictness and without TCO
11:11:03 <EvanR> eh?
11:11:22 <EvanR> "error too much recursion"
11:13:12 <Cale> Alxandr: It should really look very similar to the Haskell version in F# I would think.
11:13:23 <Alxandr> Yeah
11:13:30 <Alxandr> So, I'm trying to write it in haskell now :P
11:14:19 <lpaste> Alxandr pasted “foldl/foldr” at http://lpaste.net/166577
11:14:30 <Alxandr> Does that seem about right?
11:14:49 <Alxandr> (for lists only)
11:15:09 <EvanR> foldr' seems ... just wrong ;)
11:15:31 <Cale> foldr' you have the arguments to f swapped from their usual one, but otherwise, that's fine
11:16:07 <Alxandr> They are normally the other way around?
11:16:10 <Cale> yeah
11:16:33 <rainnnnnnnnnnnnn> hello
11:16:45 <Alxandr> So it's b -> b -> a?
11:16:45 <Cale> The expectation is usually that the elements of the list remain in the same order when you write out the expression which is produced
11:16:52 <Cale> b -> a -> a
11:16:55 <Cale> er
11:17:01 <Cale> a -> b -> b
11:17:02 <Alxandr> Right
11:17:06 <Alxandr> No, you were right
11:17:13 <Alxandr> I have 2 a's and one b
11:17:49 <Cale> Oh, you also left out the type of the result in these signatures
11:18:00 <Cale> foldr' and foldl' certainly don't produce a list
11:18:11 <Cale> Hello rainnnnnnnnnnnnn 
11:18:19 <Cale> that's quite a lot of n's you have there
11:18:20 <Alxandr> Oh, lol :P
11:18:24 <Alxandr> That's true :P
11:18:54 <rainnnnnnnnnnnnn> my 'n' key got stuck so i went with it @Cale
11:19:20 <Alxandr> It woooooorrks!
11:19:27 <Welkin> hola como estas?
11:19:28 <Alxandr> Holy crabs I've been at this for so long!
11:20:07 <Alxandr> Cale: Thank you so much. That last piece of information was basically all I needed
11:20:18 <Alxandr> To realize that I've been incredibly stupid :P
11:20:42 <EvanR> you have to get the type sigs right to have any hope of the type system helping you!
11:20:47 <Alxandr> But let's ignore the stupid part for now, it still (finally) works!
11:21:34 <Alxandr> 79 tests passed out of a total of 79 :)
11:21:50 <Welkin> 79.5 tests passed out of 79
11:22:18 <Alxandr> Wait wut?
11:22:20 <Alxandr> :P
11:22:43 <rainnnnnnnnnnnnn> are you doing the koans? 
11:23:28 <rainnnnnnnnnnnnn> Alxandr are you doing the koans? 
11:23:45 <Alxandr> koans?
11:23:50 <Welkin> rainnnnnnnnnnnnn: are you related to opraaa?
11:23:59 <Alxandr> ???
11:24:06 <Welkin> Alxandr: programming koans
11:24:13 <Alxandr> I don't know what those are
11:24:13 <Welkin> a satire on zen koans
11:24:19 <Alxandr> But I'm translating megaparsec to F#
11:24:19 <Welkin> from zen buddhism
11:24:19 <rainnnnnnnnnnnnn> Alxandr https://wiki.haskell.org/Koans
11:24:22 <Alxandr> With tests
11:25:30 <Welkin> is there a way to calculate rem in one pass without losing precision?
11:26:30 <crough> how do you mean?
11:27:13 <Alxandr> But seriously, thank all of you so much.
11:27:24 <Alxandr> I'm so high on endorfins now, you wouldn't believe it
11:27:43 <Alxandr> Cracking a problem you've banged your head into for a week feels so good
11:27:54 <Alxandr> Even though the conclusion was that I was just plain old stupid :P
11:28:24 <edwardxhaigh> I worked https://projecteuler.net/problem=48 out by doing [ x^x | x <- [1..1000]], can anyone think of a better way?
11:28:52 <dunpeal> Cale: Any idea why the latest version of the NICTA course specifically moves away from Stack?  https://github.com/NICTA/course/commits/master
11:29:08 <Cale> edwardxhaigh: A better way would be to do all the arithmetic modulo 10^10
11:29:27 <Cale> edwardxhaigh: That way, you never need to work with numbers larger than 10^10 - 1
11:29:41 <dunpeal> Cale: also, do you think there's any language that's more mainstream (for example, more commerically viable) that teaches most of the lessons Haskell has?
11:29:54 <Welkin> dunpeal: no
11:30:01 <Welkin> haskell is used commercially a lot already
11:30:01 <EvanR> i was told yesterday that haskell is too mainstream
11:30:07 <EvanR> so they arent going to learn it
11:30:12 <Clint> hahaha
11:30:33 <EvanR> if that isnt success at all costs i dont know what is
11:30:36 <dunpeal> language hipsters
11:30:38 <Welkin> dunpeal: there are languages like scala, ocaml, f#, etc. but they are not the same as haskell
11:30:46 <Welkin> they are very different
11:30:52 <mgsloan> dunpeal: Well, dibblego recently said some rather inflamatory things on twitter
11:30:56 <Welkin> even if they are supposed to be "functional", whatever that means
11:31:05 <Welkin> lol mgsloan 
11:31:20 <Cale> dunpeal: I dunno, I'm working for Obsidian Systems, and we're developing web applications for various clients entirely in Haskell.
11:31:21 <Alxandr> F# is very different D:
11:31:24 <mgsloan> So I think it is probably some sort of emotional reaction rather than a technical decisions
11:31:33 <Cale> dunpeal: It's pretty commercially viable for us at least :)
11:31:53 <EvanR> if commercially viable means someone is willing to throw VC at it, then haskell should work
11:32:11 <Cale> The nice thing is we don't even need to secure the VC
11:32:13 <dunpeal> EvanR: more like, get a job writing it
11:32:13 <mgsloan> dunpeal: Oh never mind, the commits were 20 days ago
11:32:15 <Cale> other people do that
11:32:25 <EvanR> dunpeal: hmmm oh
11:32:31 <Cale> (our clients)
11:32:56 <EvanR> dunpeal: well you can always use haskell to teach the lessons then go get rich with PHP
11:33:28 <mgsloan> Cale: Awesome!  I met Ryan at ICFP last year and was pretty darn impressed by reflex
11:33:30 <dunpeal> EvanR: not sure if anyone "gets rich" with PHP, but I do get paid to write Ruby / Python JS
11:33:39 <Cale> mgsloan: Yeah, it's really nice
11:33:44 <EvanR> a lot of people do, maybe not the coders
11:34:00 <Cale> mgsloan: I actually enjoy doing frontend development more than backend at this point, just because of reflex.
11:34:09 <mgsloan> Happily I am also currently writing an industrial GHCJS app on reflex :D
11:34:21 <mgsloan> Yuup, it's pretty amazing, FRP that actually works
11:34:21 <Cale> We really need to get some sort of backend solution leveraging reflex going at some point.
11:34:29 <Alxandr> Btw; you guys seen this? http://imgur.com/z0PavmZ
11:34:30 <Cale> I would love to have an FRP interface to the DB layer
11:34:46 <EvanR> transactional please
11:34:46 <mgsloan> Indeed, having it all the way through the stack would be pretty
11:35:00 <dunpeal> what's reflex?
11:35:08 <EvanR> hmm continuously varying database
11:35:43 <dunpeal> I suppose it's  this: https://hackage.haskell.org/package/reflex
11:35:47 <mgsloan> Cale: Perhaps I should discuss in the reflex specific channels, but as long as we are discussing it, I have some reflex design questions.  What if I need to do a rather global plumbing of events?
11:35:54 <Cale> dunpeal: It's a functional reactive programming library: it gives you data types which represent values that change over time, and means of combining those together, and it handles making sure that everything stays up to date.
11:36:06 <Cale> dunpeal: yeah, that's it
11:36:28 <dunpeal> anyway, I'm just wondering what the chances are of me getting paid to write Haskell if I learn it
11:36:58 <dunpeal> it seems like a really fun language, but I'm not sure I can use it professionally
11:37:29 <magneticduck> wow, you seem pretty optimized towards making a profit
11:37:30 <mgsloan> I know modals are gross, but lets say I have a dyn widget under the body to implement modals, and I want to combine these modal events from many sources.  Should I wrapper my monad in some variety of WriterT or something?
11:37:36 <luite> gah more ghcjs users, now even more people will be disappointed every day longer it takes me to finish the ghc 8 port ;)
11:37:44 <dunpeal> magneticduck: s/profit/a living/
11:37:53 <Cale> luite: :D
11:38:44 <magneticduck> dunpeal: I don't believe that you're going to fall behind by learning Haskell, and if you like it you should learn it -- you'll become a better programmer by knowing more ways of doing things
11:38:59 <Cale> mgsloan: sorry one sec
11:39:09 <magneticduck> that being said, if you want to bootstrap yourself immediately into a programming job, you should learn as many mainstream languages as you can
11:39:10 <EvanR> dunpeal: im not sure you can even define a cost to "learning haskell" since you never fully learn it, you just keep learning more and more stuff
11:39:14 <magneticduck> Haskell is still a bit of an outlier
11:39:32 <mgsloan> Cale: No rush!  I've already hacked around this, it's more just a question of how it should be done in theory.  Reflex is great for making everything local and explicit
11:39:38 <EvanR> but theres a definite drain constantly tolerating rubyism
11:39:39 <magneticduck> EvanR: the cost for him is apparently time and mind-space
11:39:51 <EvanR> no because you never finish the job
11:39:54 <EvanR> no price tag
11:39:56 <dunpeal> magneticduck: sure, I won't starve to death learning Haskell in my free time. but I'll only really understand it if I can use it a lot, and not being able to get paid for it (like I do for most other languages) does make things a lot more difficult
11:40:11 <mgsloan> But the plumbing can get gnarly when you have more intangled components.  Thing is, your code has to follow the DOM structure while plumbing the event info
11:40:15 <magneticduck> dunpeal: what languages are you currently familiar with?
11:40:37 <dunpeal> magneticduck: Python, Ruby, and Javascript mostly. I do know some Java and a bit of C++.
11:40:45 <Welkin> dunpeal: to work as a software developer, you will need to know ots of languages and systems
11:40:55 <Welkin> also, why wouldn't you want to?
11:40:57 <Cale> EvanR: There is a point at which the pace at which you can honestly say you're learning new things about *Haskell* slows, though the things you can do with it...
11:41:00 <magneticduck> dunpeal: just keep adding things to your curriculum
11:41:00 <dunpeal> Welkin: yeah, I already do.
11:41:01 <Welkin> it would become borig doing the same shit every day
11:41:10 <magneticduck> make sure it's fun
11:41:24 <dunpeal> Welkin: sure, but I'd be more excited to learn a language I can actually use professionally.
11:41:34 <Welkin> dunpeal: you can use haskell professinally
11:41:35 <EvanR> Cale: yeah 
11:41:40 <Welkin> I used it in my first job
11:41:47 <Welkin> because I just chose to use it
11:41:54 <dunpeal> for instance, Rust is apparently not quite as interesting as Haskell, but it probably has more potential for me to write professionally
11:41:54 <EvanR> i also used haskell at my php job
11:41:57 <EvanR> dont tell anyone though
11:41:58 <Welkin> I also had to use javascript and swift/iOS though, too
11:42:19 <Welkin> dunpeal: you are looking at it wrong
11:42:21 <magneticduck> heh, I actually got *offered* a job when I was 17 because apparently there are very few Haskell programmers in Portugal
11:42:31 <Welkin> you are looking for something that doesn't exist
11:42:38 <Welkin> every company uses lots of languages
11:42:55 <EvanR> dunpeal: you need to know techniques, ways of thinking and learning, not languages. but learning how different languages do stuff is a means to that end
11:43:09 <Welkin> learning an obscure language to get a job -- trying to find a compromise, is a bad idea
11:43:14 <dunpeal> Welkin: sure. I've used 3-5 languages of the above list in every position I worked for the past 10 years
11:43:36 <edwardxhaigh> Is it realistic to think you could find a job if Haskell was your primary language?
11:43:45 <edwardxhaigh> If you were Oxford/London based
11:43:48 <Welkin> edwardxhaigh: you can do it, yes
11:43:49 <Cale> mgsloan: I was about to suggest something, but apparently it's not released, which makes sense, because it'll probably would have become outdated as soon as the new version of reflex gets released soon.
11:43:57 <Welkin> standard chartered uses haskell
11:43:58 <EvanR> and you might get more out of doing programming in your free time than treating it just as what i do at work then go home
11:44:01 <Welkin> facebook uses haskell
11:44:11 <Cale> mgsloan: Anyway, yeah, you could use some form of WriterT
11:45:18 <edwardxhaigh> Ok
11:45:33 <edwardxhaigh> I enjoy Haskell more than any other language, so I want to use it primarily
11:45:38 <edwardxhaigh> At least I will outside of work
11:46:28 <mgsloan> Cale: Cool, thanks I look forward to it!  Glad y'all are considering it.  I suppose ReaderT (IORef a) could also do, I actually like that better than Writer or State TBH, even if it's messier
11:46:28 <Welkin> using it *at work* might make you like it less
11:46:31 <Welkin> that is true of anything though
11:46:38 <Cale> mgsloan: We had a special WriterT for Dynamic specifically, but soon there will just be (Monoid m, Reflex t) => Monoid (Dynamic t m)
11:46:44 <Welkin> it's not about the language, really, but what you are doing with it
11:47:16 <EvanR> Welkin: well i tried doing haskell in elixir, and it wasnt so great ;)
11:47:22 <mgsloan> Cale: Snaps, the constraints on m got moved to the Dynamic data constructor?
11:47:22 <EvanR> in this case its about the language
11:47:28 <mgsloan> Makes sense
11:47:33 <mgsloan> maybe :)
11:47:37 <Cale> er, m is just a monoid there
11:47:40 <Welkin> EvanR: that's erlang though
11:47:46 <Welkin> totally not haskell
11:47:47 <mgsloan> Cale: Ohhh
11:47:47 <EvanR> sort of
11:47:56 * hackagebot wedged 1 - Wedged postcard generator.  https://hackage.haskell.org/package/wedged-1 (ClaudeHeilandAllen)
11:48:01 <EvanR> there could be a haskell for erlang
11:48:07 <mgsloan> Cale: Dunno how I misread that, parsed as a function not a constraint
11:48:10 <Cale> mgsloan: Dynamic is getting Functor, Applicative and Monad instances
11:48:37 <Cale> So we'll just be able to write liftA2 mappend
11:48:42 <Cale> and stuff
11:48:49 <mgsloan> Wow!!  I remember ryan saying that should be possible but he hadn't figured out how to do it efficiently yet last year
11:48:53 <EvanR> Welkin: elixir adds some features from haskell, like pattern matching, just not others, like monads
11:48:53 <mgsloan> That'll be so convenient
11:49:58 <mgsloan> Just the other day I got a very confusing type error that turned out to be using "tagDyn" as an action, because I'm so used to the *Dyn functions being actions
11:50:14 <Cale> yeah
11:50:17 <Cale> haha
11:50:22 <mgsloan> Also, have y'all noticed that the type errors for recursive do notation can get pretty bad?
11:50:24 <Cale> I've done that a couple times myself
11:50:41 <Cale> Yeah, it just tells you "something is wrong in this big rec here"
11:50:43 <mgsloan> I think it's because the type error happens in the desugared code, and GHC doesn't know very well how to talk about it
11:50:53 <mgsloan> I am starting to switch to explicit fixpoints due to it
11:51:13 <Cale> Oh, that's interesting, I didn't know it was any better at handling that
11:51:22 <Cale> But it makes sense
11:53:47 <Cale> mgsloan: But yeah, I would generally try to avoid having too much global plumbing of Events -- it obviously sucks a bit to do manual plumbing, but it's really beneficial to be able to look at the definition of something and see all the things that influence it.
11:54:24 <Cale> But yeah, for certain kinds of things, you really just want that I suppose.
11:54:42 <dunpeal> Are there any efforts to port Haksell to LLVM as a major platform?
11:55:56 <Cale> The thing we used our WriterT-specialised-to-Dynamic for is collecting up information about what data our frontend is interested in, so that we can observe how that changes and have the backend intelligently compute patches to send to the frontend
11:56:10 <Cale> dunpeal: That is done
11:56:23 <Cale> -fllvm will use the LLVM backend in GHC
11:56:29 <geekosaur> well.
11:56:58 <geekosaur> ghc can use llvm, but it doesn't use it very well --- mostly because there are some severe impedance mismatches between llvm's model and ghc's
11:57:01 <mgsloan> Cale: Oh, interesting, so lazy fetching based on demand?  Makes sense that an approach like that would make you want to plumb reflex all the way through to the DB
11:57:13 <Cale> mgsloan: yes... hahaha
11:57:33 <Cale> mgsloan: The backend's job is pretty... interesting.
11:58:22 <Cale> I'd really love to be able to just have  Dynamic t (Query a) -> m (Dynamic t (Rows a)) or whatever.
11:58:55 <Cale> (maybe the latter really needs to be an Event of diffs)
11:59:22 <mgsloan> We've got something like that.  Months ago I asked how to keep the request paired with the response and you pointed out that you can use Traversable with the xhr stuff :D
11:59:44 <mgsloan> But it's not for a DB, much more just request -> response
12:00:03 <Cale> We need a DB that we can register queries with and have it notify us with a diff whenever a commit causes the result of a registered query to change.
12:00:34 <Cale> Also, pls columns with sum types
12:00:37 <Cale> pls
12:00:44 <mniip> does anyone see anything to improve in this code: http://lpaste.net/166557
12:01:09 <Cale> Yeah, convert the tabs to spaces
12:01:16 <mniip> besides
12:02:10 <Cale> did you see http://www.twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell ?
12:02:19 <mgsloan> As for the plumbing thing, at first it feels wrong that DOM structure would cause the need for plumbing structure.  However, in the presence of "dyn", it makes a lot of sense.  You can't have interdependency of DOM that may or may not exist
12:02:39 <Cale> mniip: It takes a bit of a different approach to representing the "table"
12:03:22 <mniip> well wouldn't that only work for substring search
12:03:23 <mgsloan> Having a datatype of reflex state per logical "context" makes sense
12:03:24 <Cale> mgsloan: Yeah, dyn is the main cause of needing the interesting higher-order combinators
12:03:33 <Cale> switch in particular
12:03:42 <mgsloan> Right!
12:05:52 <mniip> Cale, actually I'm thinking of publishing an article describing this algorithm, do you think that makes sense
12:06:06 <mgsloan> One thing that's occurred to me, is that it would be very interesting to have a debug print or visualization of the reflex graph.  Dunno how feasible this would be.  Might require putting (f?callStack :: CallStack) all over the place :/
12:06:46 <mgsloan> Alternatively, it would be interesting to have labeled variants of some combinators, to allow user annotation of such debug info
12:07:34 <mgsloan> Particularly awesome if it's like traceEvent and lets you see the values (and maybe manipulate them?!)
12:07:57 * hackagebot proto-lens 0.1.0.0 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.1.0.0 (JudahJacobson)
12:09:09 <Cale> mgsloan: I don't usually care much for fancy editors, but I think it would be really cool to have an editor where you could mouse over any Behavior or Dynamic and see its value changing live, and the Events would visually ping when they fired, etc.
12:10:04 <mgsloan> Yep, something like that!  I'm more imagining something like realtime graphviz, but there could be a variety of ways to present the info
12:20:36 <Squarism> i get error : ERROR: Maybe.fromJust: Nothing . 
12:20:37 <Squarism> Can i somehow get some info on where this is happing like file-row?
12:21:32 <geekosaur> not currently, unless you're using ghc8 (and even then I don't think it's been changed to use the HasCallstack stuff yet)
12:22:13 <Squarism> hmm
12:22:41 <geekosaur> it's still experimental so to date only error and undefined use it
12:22:48 <mgsloan> You can get profiling stack traces, but it's a little messy.  Build with profiling and pass in "+RTS -xc -RTS"
12:22:57 * hackagebot mustache 1.0.1 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-1.0.1 (justus)
12:23:18 <mgsloan> If you're using stack, you can just do "stack build --trace" to get exception stack traces
12:23:33 <Squarism> ok, good to know!
12:23:39 <hc> hey folks, I'm using the unix package to set file permissions... How can I get my code to compile on windows? I don't need to set file permissions there
12:24:19 <mgsloan> Squarism: By a little messy, what I mean is that it prints out traces for every exception thrown.  In most simple cases this is sufficient
12:24:43 <mgsloan> But when you have an application with lots of async exceptions and exceptions during normal operation, -xc becomes essentially useless..
12:25:19 <Squarism> mgsloan, when you say "build with profiling" what do you mean? I use cabal to run/build
12:25:33 <geekosaur> hc, there is a unix-compat package, but I don't think it will help here. so your options will be (1) use CPP and compile conditionally by OS, or (2) isolate the file mode changes to a separate module, probably by using a wrapper function to do it, and then compile different versions of that module on POSIX vs. Windows using cabal file conditions
12:25:41 <mgsloan> Squarism: Look up how to build with profiling with cabal, I do not remember the incantations
12:25:46 <mgsloan> With stack it's just "stack build --profile"
12:25:53 <geekosaur> with a dummy version of the mode change function for Windows
12:25:58 <Squarism> mgsloan, ok.. ill google it
12:26:17 <hc> geekosaur: okay, how do I get stack to ignore the .cabal dependency?
12:26:25 <hc> geekosaur: CPP is a good option otherwise :)
12:26:32 <geekosaur> again, using cabal file conditions
12:26:48 <hc> okay, didn't know about that. thanks!
12:26:59 <ClaudiusMaximus> hc: you can use  if(os(...))  in the .cabal file, to include different hs-source-dirs and build-depends (etc)
12:27:01 * geekosaur looking up the docs yet again,.. should leave them in a window
12:27:30 <hc> thank you guys!
12:27:50 <geekosaur> https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations see "Conditionals"
12:28:01 <geekosaur> sorry "Conditions"
12:31:25 <hc> it's working :)
12:31:28 <hc> thanks again for your kind help
12:31:41 <hc> most awesomest channel
12:39:10 <compman> I am finding HAskell too hard to understand. What should I do? It's mind bending. I am beginner level, reading learn you  a haskell for great good
12:41:14 <levi> Try some different books, write some simple programs, keep working at it. I don't think there's a magic formula besides persistence.
12:41:41 <compman> levi: What are some other good books?
12:41:46 <Cale> also feel free to ask questions here about what things mean
12:42:01 <compman> Learn you a haskell is actually great, I think I have been procrastinating
12:42:18 <compman> Suggest me some simple haskell projects
12:43:44 <ahihi> http://bitemyapp.com/posts/2014-12-31-functional-education.html has a review of learning materials
12:44:22 <henceforthingly> Perhaps try some of the projects on project euler
12:44:36 <rhovland> compman: do easy problems on hackerrank
12:44:55 <compman> rhovland: Nice idea. Thanks
12:45:08 <compman> Can I ask for some resume advice? 
12:45:18 <compman> I have done some good projects now, and I have done some simple projects long back, is it worth putting the simpler ones on the resume.?
12:45:37 <compman> They are still good. I mean they are basic from the point of view of a grad. They were done in my second year! They are good from the point of view of a second year,
12:45:50 <compman> (When they were made)
12:46:22 <siwica> What is the canonical amount of new lines between function definitions? 1 or 2?
12:47:02 <roconnor_> I'm thinking of trying out finally-tagless for my DSL.  I'm hoping it will "preserve" sharing better than GADTs.  Anyone have any thoughts or experiences with finally-tagless?
12:48:14 <compman> Will someone help me ??
12:48:25 <compman> Please anwser my question
12:49:21 <adelbertc> roconnor_: i've done finally tagless in scala and its gone very well for me
12:49:34 <adelbertc> i like that it has fewer moving parts than Free
12:50:30 <adelbertc> its pretty much MTL (https://www.youtube.com/watch?v=JxC1ExlLjgw) so you get the usual benefits (and downsides) of MTL-style code
13:01:49 <roconnor_> I'll check out the video.
13:07:59 * hackagebot proto-lens-protoc 0.1.0.0 - Protocol buffer compiler for the proto-lens library.  https://hackage.haskell.org/package/proto-lens-protoc-0.1.0.0 (JudahJacobson)
13:08:01 * hackagebot proto-lens-arbitrary 0.1.0.0 - Arbitrary instances for proto-lens.  https://hackage.haskell.org/package/proto-lens-arbitrary-0.1.0.0 (JudahJacobson)
13:14:28 <hexagoxel> foldMap on map does not guarantee to fold in Ord(er), does it?
13:15:02 <glguy> Ord doesn't feature in Foldable
13:16:34 <rrradical> Has anyone here had trouble with `stack test`? It's compiling my test file but not running
13:16:42 <shachaf> If you mean on Data.Map.Map, I suspect that it is.
13:16:45 <shachaf> fsvo guarantee
13:17:20 <mgsloan> rrradical: Does your test have a main module?  "main-is:" field in your cabal description?
13:17:37 <rrradical> mgsloan: yep
13:17:52 <hexagoxel> shachaf: fsvo?
13:17:53 <mgsloan> Strange!  I was suspecting https://github.com/commercialhaskell/stack/issues/1846
13:18:02 <shachaf> for some values of
13:18:36 <mgsloan> rrradical: Perhaps you have multiple packages / tests / etc, and it's sending the output to the logs not stdout?
13:18:48 <mgsloan> Take a look in .stack-work/logs/my-pkg-...
13:19:30 <rrradical> mgsloan: that's it! how does it decide whether to do stdout?
13:19:42 <shachaf> I don't know that the library actually guarantees it, but I'd be pretty surprised if it ever changed.
13:19:59 <nitrix> fmap f x = Cellular $ fmap (fmap f) $ runCellular x
13:20:08 <nitrix> Surely this can be written more nicely?
13:20:43 <crough> nitrix: yeah sure, {-# language DeriveFunctor #-} :)
13:21:20 <nitrix> crough: Wew! Thanks :)
13:21:57 <rrradical> mgsloan: oh I see. I have to specify my package directly to see the results. ok thanks a bunch!
13:22:16 <crough> nitrix: in all honesty, that's about as nice as a manual definition gets 
13:22:36 <crough> nitrix: you can store it as a "Data.Functor.Compose"
13:22:59 * hackagebot proto-lens-optparse 0.1.0.0 - Adapting proto-lens to optparse-applicative ReadMs.  https://hackage.haskell.org/package/proto-lens-optparse-0.1.0.0 (JudahJacobson)
13:30:26 <hexagoxel> (ah, the Map.foldr is ~ foldr . elems, and elems guarantees order. and Foldable laws provide the rest. good enough of a guarantee i guess.)
13:52:01 <Achilles> .
14:08:01 * hackagebot streaming-eversion 0.3.0.0 - Translate pull-based stream folds into push-based iteratees.  https://hackage.haskell.org/package/streaming-eversion-0.3.0.0 (DanielDiazCarrete)
14:08:03 * hackagebot streaming-eversion 0.3.0.1 - Translate pull-based stream folds into push-based iteratees.  https://hackage.haskell.org/package/streaming-eversion-0.3.0.1 (DanielDiazCarrete)
14:23:01 * hackagebot homoiconic 0.1.0.0 - Constructs FAlgebras from typeclasses, making Haskell functions homoiconic  https://hackage.haskell.org/package/homoiconic-0.1.0.0 (MikeIzbicki)
14:35:25 <hexagoxel> a type variable introduced in a type signature inside a pattern has automatic scope over the respective RHS?
14:36:54 <hexagoxel> (it seems to.. is that effected by ScopedTypeVariables?)
14:37:09 <glguy> hexagoxel: It's part of scoped type variables, you can't do that otherwise
14:38:28 <hexagoxel> i didn't expect it to do that without any "forall", as that seems to "trigger" ScopedTypeVariables in other type signatures.
14:38:49 <edwardxhaigh> Why is the Fibbonacci sequence when done like this "fibbonacci n = fibbonacci (n - 1) + fibbonacci (n - 2)"
14:38:49 <edwardxhaigh>  so slow?
14:39:15 <glguy> edwardxhaigh: Because it's doing a number of function calls that grows exponentially in n
14:39:35 <hexagoxel> because lazy /= automatic memoization
14:40:18 <dmj`> edwardxhaigh: it's O(2^n)
14:40:37 <Zemyla> edwardxhaigh: Try doing fibonnaci 5 by hand, and see how many times you wind up calling fibonacci 0 and fibonacci 1.
14:41:53 <edwardxhaigh> well that would explain why I am stuck at 2178309
14:42:21 <monochrom> eh? you got "fibbonacci 2178309" to work? your computer is fast.
14:42:57 <edwardxhaigh> You're kidding? I thought my command window had broken 3 times and restarted the program - I can't believe how inefficient it is! :P
14:43:02 * hackagebot cql 3.1.0 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-3.1.0 (ToralfWittner)
14:44:00 <edwardxhaigh> Oh Monochrom, I did not run 'fibbonacci 2178309', that is simply one of the earlier fobbonacci numbers (n20 or something)
14:44:09 <monochrom> heh
14:44:30 <shachaf> fibonacci 8675309
14:46:25 <mettekou> Is fibonacci 2178309 even possible before the heat death of the universe with the naive algorithm?
14:46:49 <dmj`> > let fibs = (0 : 1 : zipWith (+) fibs (tail fibs)) in fibs !! 2178309
14:46:51 <lambdabot>  *Exception: stack overflow
14:47:10 <edwardxhaigh> Haha - I don't know better yet I'm afraid!
14:47:30 <dmj`> @def fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:47:31 <lambdabot>  Defined.
14:47:35 <dmj`> > take 10 fibs 
14:47:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:47:59 <mettekou> fst $ drop 2178308 fibs
14:48:17 <mettekou> >	fst $ drop 2178308 fibs
14:48:18 <Cale> That's a rather large number, even if you manage to compute it
14:48:26 <hexagoxel> s/fst/head
14:48:36 <mettekou> Oh damn.
14:48:38 <dmj`> > fibs !! 21783
14:48:39 <lambdabot>  1067290301799664969038619435543027688358592341913502625459355759225099995632...
14:48:42 <mettekou> Yeah, it's getting late.
14:49:08 <mettekou> When you go from wrangling monad transformers with ease to mixing up head and fst.
14:56:44 <kakadu> Folks, I heard that llvm have some `issues` with functions arguments. For example, It puts everything onto stack and when we do tail recursion we kind of cannot left arguments on _registers_ to reuse them. How haskell llvm backend deals with it?
14:57:13 <hexagoxel> > let ind 0 (x:_) = x; ind i (!x:xs) = ind (i-1) xs in ind 100000 $ 0 : 1 : zipWith (+) fibs (tail fibs)
14:57:17 <lambdabot>  mueval-core: Time limit exceeded
14:57:22 <hexagoxel> stack overflow resolved!
14:58:38 <geekosaur> kakadu, that question is probably best asked in #ghc or maybe the ghc-devs mailing list
14:58:53 <kakadu> geekosaur: thanks
14:58:58 <mgsloan> kakadu: I don't know all that much about it.  However, I believe that LLVM uses an SSA IR (single-static-assignment).  So, the stack is really just a way of providing a semantics for plumbing the arguments
14:59:11 <mgsloan> LLVM is free to do tail call elimination, and probably does when you ask it to
14:59:22 <ElectricSolstice> I'm having a runtime error using gtk3. Trying to get a value from a column of a selected row. Not sure how to do that.
14:59:47 <kakadu> mgsloan: Yes, it does but it doesn't allow to left arguments on registers, I beleive
15:01:26 <mgsloan> Hmm, "left arguments"?  Perhaps "leftover arguments"?  Yeah, sounds like the GHC mailing list would be a good way to go
15:02:05 <ElectricSolstice> Anyone here familiar with using gtk3 with haskell?
15:02:48 <kakadu> mgsloan: maybe left behind :) Sorry for my english
15:03:31 <mgsloan> No problem :)  Yes, "leftover" ~ "left behind"
15:07:25 <shirt> Is there a way to pause all other haskell threads?
15:08:24 <EvanR> with runtime option -N1
15:08:32 <EvanR> only one thread runs at a time
15:08:45 <mgsloan> shirt: You can block threads via MVars or STM
15:09:10 <hpc> if you want an arbitrary and instant "hey thread, you stop now", i don't think it exists
15:09:28 <hpc> for one, it'd have complicated interactions with the FFI
15:09:34 <shirt> i am printing some debug stuff to stdout, but it is being interleaved with all the other output of the program
15:10:01 <EvanR> debug to stderr and redirect?
15:10:38 <EvanR> also a good reason to have threads send to a dedicated outputter
15:10:43 <hpc> you could go full-on silly and have out and err Chans and a dedicated outputter
15:10:44 <hpc> yeah
15:10:47 <shirt> can't quite do that, i'm using existing functions that already write to stdout
15:10:54 <mgsloan> shirt: It's a hack, but one option is to do something like "do { tid <- myThreadId; appendFile ("logs/" ++ show tid) "My loggg!" }"
15:11:26 <shirt> mgsloan: yeah, good idea, but can't do that either for the reason i just mentioned :|
15:11:35 <EvanR> you cant do nothing!
15:12:27 <EvanR> do you have control over any non existing functions or are you stuck
15:12:33 <shirt> no way to force the scheduler to not preempt my thread until i tell it?
15:12:48 <hpc> aha!
15:12:49 <hpc> https://hackage.haskell.org/package/silently-1.2.5/docs/System-IO-Silently.html#v:capture
15:13:03 * hackagebot homoiconic 0.1.0.1 - Constructs FAlgebras from typeclasses, making Haskell functions homoiconic  https://hackage.haskell.org/package/homoiconic-0.1.0.1 (MikeIzbicki)
15:13:12 <EvanR> oh geez
15:13:32 <hpc> use hCapture twice, separately for stdout and stderr
15:13:35 <EvanR> with this we can do PHP output shenanigans 
15:13:36 <hpc> and you'll have them as strings
15:14:04 <mikail`> Hi, what is the best way to convert a Double to a Decimal?
15:14:05 <shirt> hpc: thanks! maybe that will work..
15:14:06 <mgsloan> I'm rather surprised that this would work in a concurrent setting, I thought stdout and stdin were process global
15:14:21 <EvanR> yes how the heck
15:14:35 <EvanR> mikail`: realToFrac? 
15:15:43 <EvanR> Real types can be injected into the rationals (toRational), Fractional types can be constructed from a Rational (fromRational), wonder twin powers activate to become realToFrac
15:16:09 <mikail`> I'm using the mwc-random package
15:16:40 <mikail`> The normal 1 0 gen returns a m Double
15:16:52 <hpc> mgsloan: take it up with POSIX, who say it's possible at all
15:16:53 <mikail`> where m is a PrimMonad
15:17:14 <mikail`> doing realToFrac didn't convert it to a Decimal
15:17:40 <mikail`> λ> :t realToFrac <$> (normal 0 1 gen) 
15:17:40 <mikail`> realToFrac <$> (normal 0 1 gen)
15:17:41 <mikail`>   :: (PrimState f ~ RealWorld, PrimMonad f, Fractional b) => f b
15:17:54 <EvanR> if Decimal is Fractional, should work
15:18:03 * hackagebot cql-io 0.16.0 - Cassandra CQL client.  https://hackage.haskell.org/package/cql-io-0.16.0 (ToralfWittner)
15:18:08 <EvanR> b = Decimal would be valid
15:21:09 <EvanR> has anyone heard of unison 
15:21:13 <EvanR> http://unisonweb.org/2016-06-17/node-containers.html
15:21:17 <mgsloan> hpc: Well, stdout and stdin are just special file descriptors, they can still be used with dup2 - http://man7.org/linux/man-pages/man2/dup.2.html
15:21:20 <EvanR> is it sort of like a urweb sort of thing
15:23:19 <mgsloan> hpc: Oh I see, you were probably saying that POSIX makes this possible and it's a dubious choice
15:23:26 <mgsloan> (POSIX does specify dup / dup2)
15:29:16 <geekosaur> mgsloan, on the one hand yes, they're process global. on the other hand, if you have multiple threads doing things with stdout and stderr, well.
15:29:21 <geekosaur> "you have a problem and you decide to use threads. nonw owy ou  yoauv e hatwvo e ptrowbo plerombsle imns teinrtleearlveeda.ed."
15:30:12 <mgsloan> Haha, well, that's exacerbated by lazy IO
15:30:18 <geekosaur> (or stdin, especially stdin)
15:30:23 <mgsloan> putStrLn with strict Text does not intersperse
15:30:37 <mgsloan> (other than line interspersals)
15:30:52 <mgsloan> Well, maybe not an issue with lazy IO
15:31:16 <mgsloan> Also an issue of buffering approach
15:31:39 <mgsloan> Err, nah, it's just the lazy IO
15:32:46 <geekosaur> actually I think it has more to do with I/O strategy. String, being based on lists of Char, turns into individual putChar calls. Text likely uses higher level operations, because it can and it's more efficient
15:33:15 <geekosaur> lazy Text I/O may also degenerate to Char just to make it lazier
15:33:42 <geekosaur> but for strict Text or ByteString, you'd use hPut because it's much more efficient
15:34:01 <geekosaur> sorry hPutBuf
15:35:44 <mgsloan> Yep, and the reason for doing putChar was laziness
15:36:03 <mgsloan> Otheriwse you cannot print an infinite string, and you cannot print the prefix of something that has a bottom
15:37:01 <mgsloan> In other words, "putStrLn = T.putStrLn . T.pack" could be used
15:37:30 <mgsloan> And this is one of those reasons that we need to excise String from modern Haskell
15:37:38 <shachaf> Isn't stdout output buffered anyway?
15:38:18 <geekosaur> it is, and the interleaving is happening at the buffer level
15:38:35 <geekosaur> which is why hPutChar vs. hPutBuf changes the behavior
15:39:13 <mgsloan> Yep.  Changing the buffering policy can lead to less interleaved output, but does not fix it
15:39:17 <shachaf> Oh, you were talking about this above.
15:39:44 <mgsloan> (because NoBuffering goes right to output, and that takes longer, so you get more interspersal)
15:39:58 <mgsloan> Whereas if you are filling the buffer, you're more likely to be able to fill consecutive chars
15:40:15 <shachaf> mgsloan: Well, sure it doesn't fix it, but neither does T.putStrLn.
15:40:24 <mgsloan> It doesn't?
15:40:40 <mgsloan> You will get line interspersal, sure, but that is a rather fundamental issue of concurrent logs :)
15:41:04 <shachaf> Well, I don't know how it writes text exactly.
15:41:42 <shachaf> write() isn't necessarily atomic.
15:42:08 <bikeshedr> I'm trying to install Craft3e from hackage as it's the code that goes along with http://www.haskellcraft.com/ -- but a dependency (mtl <2.2) cannot be resolved. any ideas how to progress?
15:42:25 <fr33domlover> Doxygen generates class inheritance diagrams using graphviz. Is there a Haskell equivalent for that (preferrably to use as a library that lets you describe some boxes and arrows, and generates HTML)? I found several graphics related packages, not sure which one would work best
15:42:50 <fr33domlover> (maybe some has experience and can recommend)
15:43:04 * hackagebot homoiconic 0.1.1.0 - Constructs FAlgebras from typeclasses, making Haskell functions homoiconic  https://hackage.haskell.org/package/homoiconic-0.1.1.0 (MikeIzbicki)
15:43:36 <fr33domlover> 'diagrams' looks cool
15:43:38 <mgsloan> shachaf: Oh my... hPutStrLn h t = hPutStr h t >> hPutChar h '\n'
15:43:59 <mgsloan> I think this explains a bug in stack text output that I've been scratching my head about for a long while
15:44:04 <glguy> mgsloan: In the past I've written: hPutStrLn' h xs = hPutStr h (xs ++ "\n") because of that
15:44:16 <mgsloan> That's so bad..
15:44:22 <mgsloan> WTF
15:44:35 <mgsloan> I guess I see why
15:44:44 <mgsloan> Avoids an entire memcpy to add a char
15:44:53 <mgsloan> oof
15:46:45 <shachaf> Is that Text or String hPutStrLn?
15:46:51 <glguy> String
15:47:06 <glguy> (at least)
15:47:44 <mgsloan> Also Text
15:47:47 <nitrix> Hi
15:47:49 <glguy> (or at least it used to be, looking now)
15:47:50 <nitrix> newtype Cellular m a = Cellular { runCellular :: IO (m a) }
15:47:57 <geekosaur> was last time I looked too
15:48:10 <nitrix> I seem unable to implement the instance `Monad (Cellular m)`
15:48:19 <mgsloan> shachaf: https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-IO.html#hPutStrLn
15:48:34 <dmj`> mgsloan: foldr system call, ran into that w/ some logging thing
15:48:42 <quchen> Is there some library to convert ANSI-coloured text to HTML in some way?
15:48:48 <shachaf> mgsloan: Well, hPutStr uses buffering.
15:48:58 <nitrix> Can someone confirm it's do-able? Somehow, I end up with one `do` block needing something from the external `do` block. Maybe I'm just a little lost.
15:49:32 <mgsloan> shachaf: Not if you set NoBuffering
15:49:45 <shachaf> Yes, not if you set NoBuffering.
15:49:55 <dmj`> use LineBuffering, only one system call
15:50:00 <dmj`> NoBuffering is default w/ stderr
15:50:10 <mgsloan> Which we do indeed do in stack, in an attempt to avoid such bogosity
15:50:54 <dmj`> such bogosity indeed
15:50:57 <dmj`> mgsloan: https://github.com/sol/logging-facade/pull/13
15:51:17 <dmj`> System.IO.hPutStrLn performed just as well as hPut/hPutBuilder
15:51:40 <nitrix> Nevermind, done.
15:53:08 <mgsloan> dmj`: Right, but that performance hit only affects String, which we avoid as much as possible
15:53:20 <mgsloan> All of our output goes via Text
15:53:34 <mgsloan> Even if it means packing a lot of strings
15:53:35 <ClaudiusMaximus> quchen: there's http://hackage.haskell.org/package/Ansi2Html but it's a program and 5 years old with an absent homepage, still might be something to start from
15:54:01 <mgsloan> (since packing strings is basically the same as buffering a bunch of hPutChar)
15:54:07 <mgsloan> modulo UTF-8 vs UTF-16
15:54:31 <quchen> ClaudiusMaximus: Thank you, I'll have a look at that!
15:55:56 <dmj`> yes String is foul, I'd have to check benchmarks again, but I believe T.hPutStrLn sderr performed similarly to System.IO.hPutStrLn (w/o buffering)
15:57:59 <Sinestro> Ugh I'm having one of those 'brain no work' moments.
15:58:03 <dmj`> well, w/o buffering Data.Text.IO.hPutStrLn seems to have a similar definition
15:58:04 <dmj`> http://lpaste.net/3420768458571251712
15:58:11 <dmj`> to System.IO.hPutStrLn
15:58:37 <Sinestro> It feels like it should be possible to do this, but I don't see anything out there that would work, and it seems basic enough that having to roll my own is a bad sign. 
16:03:10 <Sinestro> http://lpaste.net/166674
16:04:26 <Ptival_> is there a cabal command that will try to install only if the package is not already installed?
16:04:44 <Ptival_> or do I have to do the check ahead of calling cabal?
16:05:16 <nitrix> EvanR: Turns out, two monads don't necessarily compose into a new monad.
16:05:28 <nitrix> EvanR: I'm redesigning my relational library around free monads :(
16:05:52 <EvanR> i didnt think you could combine two monads at all
16:06:27 <EvanR> but yeah the transformer version of two monads may not exist or may not work together
16:06:28 <quchen> Sinestro: "Doesn't balloon as hard" is not a very useful description.
16:07:00 <nitrix> EvanR: Got stuck implementing the monad instance of newtype Cellular m a = Cellular { runCellular :: IO (m a) }
16:07:07 <Sinestro> I guess it doesn't matter, huh.
16:07:53 <Sinestro> There won't be enough to make the tuple unwrapping a big performance deal (I hope not, at least), and I'll never need to write the type of a composed Thing myself
16:08:01 <nitrix> EvanR: It seems the `do` blocks are mutually needing each other. I tried wrapping my mind around it with no success.
16:11:30 <EvanR> nitrix: that newtype doesnt seem right
16:13:50 <EvanR> blah monad transformers
16:15:35 <ElectricSolstice> anyone here familiar with gtk3?
16:16:51 <puregreen> ElectricSolstice: I am
16:17:29 <ElectricSolstice> cool, I need help. I'm getting a run time error trying to use treeModelGetValue
16:17:57 <ElectricSolstice> trying to grab a value from a column of the selected row and not sure how to do that.
16:19:11 <Squarism> can you turn off Debug.Trace messages per file or with some configuration flag?
16:20:29 <quchen> Squarism: No. You could hack that in with CPP if you really want to though.
16:20:59 <quchen> But you should probably not have enough traces in your program to require that in the first place.
16:21:20 <dmj`> Squarism: you could wrap Debug.Trace in another function that references a boolean that you can switch on and off, debug = False
16:21:24 <Squarism> well.. i feel traces are my only option debugging
16:21:34 <Squarism> dmj`, smart!
16:21:42 <dmj`> if debug then Debug.Trace.traceShow etc
16:22:04 <dmj`> #realworldhaskell
16:22:41 <mgsloan> Could even have that function have a `(?callStack :: CallStack)` constraint, and check which module is invoking
16:22:51 <mgsloan> If you're using >= ghc-7.10
16:23:26 <mgsloan> Also nice to give the callstack with your trace ^_^
16:23:39 <mgsloan> (well, the lexical implicit callstack)
16:26:01 <puregreen> ElectricSolstice: sorry, I haven't ever used TreeModel
16:26:26 <puregreen> I'd suggest looking at examples and checking whether there are any obvious differences
16:27:23 <puregreen> e.g. here: https://github.com/gtk2hs/gtk2hs/tree/master/gtk/demo/treelist
16:27:28 <ElectricSolstice> puregreen: thanks anyways. So far, I haven't noticed anything, but i'm having to look at an example in c code as i don't know where or if tree selection is used in the haskell demo code.
16:32:22 <puregreen> it looks like you're supposed to get selection with treeViewGetSelection, then treeSelectionGetSelected to actually get the TreeIter, and finally treeModelGetValue on that iterator
16:33:14 <ElectricSolstice> puregreen: that's what i did and i get a run time error
16:33:38 <puregreen> does it fail at treeModelGetValue, or at some other step? can you get at least *some* column, or does it always fail? what error do you get?
16:35:18 <puregreen> is this relevant? https://sourceforge.net/p/gtk2hs/mailman/message/24101916/
16:35:21 <ElectricSolstice> puregreen: i also have it print the TreeIter before the error http://pastebin.com/CnaJw4Ht
16:35:28 <ElectricSolstice> error is in the link
16:37:05 <ElectricSolstice> puregreen: that might have something to do with it. i'll have to look closely at that
16:38:39 <Squarism> mgsloan, even better. Sadly im on 7.10
16:39:36 <mgsloan> Squarism: >= :)
16:39:59 <Squarism> oh
16:40:54 <u0_a208> test
16:53:27 <koz_> What would be the best way to represent 'ordered set with at least two elements'?
16:54:05 <EvanR> as an ordered set with a property?
16:54:25 <EvanR> properties being a thing you do with type class hacks
16:55:15 <koz_> EvanR: I don't *quite* follow.
16:55:48 <EvanR> one of the operations youd expect to be able to do with such a set is... MySet a -> (a,a,[a])
16:56:13 <EvanR> with a regular set theres no way to guarantee that wont crash
16:56:27 <koz_> EvanR: Correct.
16:56:45 <koz_> So do I newtype over the normal Set or something and only work with that + smart constructors?
16:56:52 <EvanR> but if you put a constraint on that operation which entails having at least two elements, then the type checker will ensure it doesnt crash
16:57:06 <EvanR> smart constructors would also work, thats the kernel of trust way
16:57:52 <koz_> EvanR: I guess that's what I'll do then. I was just wondering if someone wrote a library to make this less painful or something.
16:58:09 <koz_> ('this' meaning 'making a set with such a constraint', not 'making smart-constructored newtypes' obviously)
16:58:46 <EvanR> heres a package for checked properties
16:58:56 <EvanR> https://hackage.haskell.org/package/data-checked-0.3
16:59:54 <koz_> EvanR: It seems a bit old - is it still OK?
17:00:06 <EvanR> it basically lets you separate the place you use the fact it has at least 2 elements from the place you generated the set, which is where you should be doing the guaranteeing
17:00:10 <EvanR> im not sure
17:00:12 <koz_> (also, will this play nice with GHC.Generics?)
17:00:17 <Squarism> Someone eager for some friday night code review of a raging noobs first project? https://github.com/gurgl/julius-caesar/tree/master/src (GameLogic.hs, Board.hs, Model.hs in particular)
17:00:27 <koz_> Squarism: I'll give it a shot
17:00:49 <Squarism> koz_, Im ever thankful!
17:00:53 * koz_ looks at Board.hs and sees 'FlexibleInstances' and 'TemplateHaskell'.
17:01:01 <koz_> Are you *sure* you're a raging noob, Squarism? :P
17:01:16 <Squarism> well on haskell. 
17:01:17 <EvanR> FlexibleInstances is harmless!
17:01:23 <EvanR> and recommended on many error messages
17:01:26 <Squarism> i am definently
17:02:20 <koz_> Squarism: First thing I can suggest - if you have 'FlexibleInstances' in your .cabal as an extension, you don't have to slap it into a LANGUAGE pragma in your sauce files as well.
17:02:29 <koz_> (you do this in Board.hs)
17:02:46 <Squarism> oh ok. Which is recommended?
17:02:50 <Squarism> file or cabal?
17:03:34 <koz_> Squarism: If you're gonna use it everywhere, put in in your .cabal.
17:03:37 <koz_> It's easier and saves typing.
17:03:45 <koz_> Near as I can tell, you use FlexibleInstances everywhere.
17:04:00 <Squarism> cant be too flexible
17:04:12 <Squarism> ok.. ill fix that directly
17:04:56 <koz_> Squarism: pathToSteps confuses me a bit - you seem to Maybe-wrap something just to immediately unwrap it again in the same function.
17:08:37 <Squarism> well, 2 points arent a valid "step" if they dont exist in "locationConnections".. but point taken. Hard to read i guess
17:09:47 <Squarism> i often feel like "this should probebly be easier if you knew the api's"
17:10:39 <Squarism> ../could be more concise
17:13:07 * hackagebot bowntz 1 - audio-visual pseudo-physical simulation of colliding circles  https://hackage.haskell.org/package/bowntz-1 (ClaudeHeilandAllen)
17:19:49 <Squarism> koz_, any other reflections? Layout? Deviant-from-Haskell-traditional-style? Naming? 
17:20:04 <idev> I find ":r" in ghci to be too slow
17:20:08 <idev> is there a way to "code interactively in ghci"
17:20:14 <idev> or is haskell not built for interactive coding inside ghci ?
17:20:34 <idev> I'd (1) need a mini editor of sorts inside ghci and (2) need a way to store the things I type inside ghci
17:22:29 <peddie> idev: you can define functions and data types inside GHCI; is that what you want?
17:22:46 <idev> I'd like a mini inline editor of sorts
17:22:52 <idev> is there a way where I can fire up vim inside ghci
17:22:55 <idev> it'll write to a temporary file
17:23:03 <idev> and when I save the file/quit from the editor, the string/file gets sent back to ghci ?
17:23:09 <EvanR> you can fire up ghci inside vim
17:23:20 <EvanR> which is a better editor than ghci will ever be
17:23:22 <EvanR> i hope
17:24:47 <idev> EvanR: can you point me to a blog post for this?
17:24:52 <idev> my current setup involves tmux windows
17:24:57 <idev> which is not quite ghci "inside" vim
17:25:24 <coppro> I just use :!stack ghci
17:25:37 <idev> does that fire up a new ghci?
17:25:43 <idev> which can be quite slow is there's quiate a few modules
17:25:59 <EvanR> http://www.stephendiehl.com/posts/vim_2016.html
17:26:22 <peddie> idev: http://chrisdone.com/posts/making-ghci-fast may help?
17:26:46 <idev> EvanR: is that ghci or is that ghc-mod+hdev ?
17:27:09 <EvanR> it doesnt seem to be ghci at all
17:27:24 <EvanR> looks like they just have ghci open in a different pane
17:27:45 <EvanR> idev: i keep ghci open and do :r
17:27:50 <EvanR> its pretty fast
17:58:10 * hackagebot snowglobe 3.0.0.3 - randomized fractal snowflakes demo  https://hackage.haskell.org/package/snowglobe-3.0.0.3 (ClaudeHeilandAllen)
18:08:25 <ClaudiusMaximus> i find it a slight annoyment that code importing pattern synonyms needs to know that what it is importing is a pattern synonym, and using the import syntax requires enabling an extension
18:11:05 <ClaudiusMaximus> and writing "pattern " so many times is tedious too..  why not  import Foo(Bar, Baz)  instead of  {-# LANGUAGE PatternSynonyms #-} import Foo(pattern Bar, pattern Baz)  seeing that  import Foo  just works without any extension needed (but also imports everything else from Foo)
18:13:10 * hackagebot stratux-types 0.0.8 - A library for reading JSON output from stratux  https://hackage.haskell.org/package/stratux-types-0.0.8 (TonyMorris)
18:13:38 <mgsloan> ClaudiusMaximus: So pattern synonyms work without the extension, but importing them explicitly requires it?
18:13:53 <ClaudiusMaximus> yes, as far as i can tell
18:13:54 <mgsloan> Oh darn, needed when using them too
18:14:07 <mgsloan> But not needed to re-export them, that does feel a little wacky
18:14:19 <mgsloan> I would prefer you not need to have the extension to use them
18:14:28 <mgsloan> That way they can be used as an upgrade path
18:14:41 <mgsloan> Oh WOOT
18:14:46 <geekosaur> I think there's been a general decision made that extensions are never automatically enabled any more?
18:14:47 <mgsloan> I was looking at 7.8 docs not 7.10
18:15:05 <ClaudiusMaximus> i see something on ghc trac about "bundling" pattern synonyms with a type, maybe that changes things
18:15:07 <geekosaur> although, for compatibility wedges that is kinda bad
18:15:08 <mgsloan> 7.10 specifies the ext is not required to use
18:15:38 <mgsloan> geekosaur: If I am importing a module that uses them, then we already know the compiler supports it
18:15:44 <mgsloan> Why would I need to declare the ext again?
18:16:11 <geekosaur> I did say general decision.
18:16:36 <mgsloan> Got a link? I'm curious!
18:16:38 <geekosaur> I am not in a position to say whether you can determine that from outside the module that uses them without module source
18:16:39 <ClaudiusMaximus> https://ghc.haskell.org/trac/ghc/ticket/11959 shows a way to bundle with a type so you can  import Foo(Quux(..))  and get its pattern synonyms presumably without needing an extension for the "pattern " syntax
18:17:05 <athan> Is a right-bracket operator, with less fixity than ($) possible? Say it's called (#), where (#) :: (a -> b) -> a -> b, just that it's left-associative and with wider fixity than ($)
18:17:21 <athan> so something like `f $ x # y` is just `f x y` if that makes sense
18:17:38 <mgsloan> Yeah, my point is that they act like normal constructors.  May as well allow use of them and make it a dependency detail whether they are used or not
18:17:44 <geekosaur> the point is more that for many extensions you can get into a situation where an explicit type requires them but an implied type doesn't; this doesn't apply to pattern synonyms, but I had understood the decision about extensions to be generally applicable and not just when an extension affects an explicit type signature
18:18:03 <mgsloan> That said, I can see the case for wanting to avoid knowing that something more than a plain constructor could be happening
18:18:08 <mgsloan> (view patterns etc)
18:18:10 * hackagebot stratux-websockets 0.0.8 - A library for using websockets with stratux  https://hackage.haskell.org/package/stratux-websockets-0.0.8 (TonyMorris)
18:18:12 * hackagebot stratux-http 0.0.8 - A library for using HTTP with stratux  https://hackage.haskell.org/package/stratux-http-0.0.8 (TonyMorris)
18:18:14 * hackagebot stratux 0.0.8 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.8 (TonyMorris)
18:18:29 <geekosaur> I think there's also a general feeling about things that behave like action at a distance.
18:18:38 <geekosaur> But... that's kinda the *reason* for patsyns...
18:18:44 <mgsloan> Ah, right, yes, if inference needs an extension then that extension should be required
18:18:53 <geekosaur> so I can see an exception being made there
18:19:10 <mgsloan> kinda, the other reason is fast c ffi enums
18:19:17 <mgsloan> Rgiht
18:23:10 * hackagebot wai-transformers 0.0.5.1 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.5.1 (athanclark)
18:29:08 <ElectricSolstice> puregreen: I don't know if you're still on, but thanks. I finally figured it out.
18:31:51 <athan> wow so monad-control is like continuations for monad morphisms
18:33:11 * hackagebot docvim 0.3.1.4 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.4 (wincent)
18:33:16 <bitemyapp> athan: pithy
18:36:01 <athan> bitemyapp: I think you're still locked into knowing the shape of the stack though
18:38:10 <athan> it's the same problem mtl addresses, but now composing the monadic profunctor of runs and restores
18:43:11 * hackagebot docvim 0.3.1.5 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.5 (wincent)
18:45:00 <bitemyapp> athan: you're right about the shape
18:45:20 <bitemyapp> athan: well, mostly. That's what base is for. Zoomy zoom.
18:49:47 <incog> https://www.youtube.com/watch?v=VDzeXqlVi5A
18:56:14 --- mode: ChanServ set +o glguy
18:56:15 --- mode: glguy set +b INCOG!*@*
18:56:15 --- kick: incog was kicked by glguy (spam)
19:00:00 --- mode: glguy set -bo INCOG!*@* glguy
19:43:35 <srpx> Would anyone remember me the name of that dependently typed language that looked almost like C, and produced very, very fast machine code?
19:43:59 <srpx> It didn't look like a functional programming language; it looked terrible, actually. But I remember hearing great things about its efficiency.
19:44:51 <zRecursive> srpx: D ?
19:45:10 <srpx> D has dependent types...?
19:45:21 <zRecursive> not sure
19:49:09 <dmj`> srpx: F* ?
19:55:42 <nextgenresearch> anyone here like linux?
19:55:56 <monochrom> why?
19:55:56 <ElectricSolstice> yep
19:55:57 <athan> bitemyapp: Holy wut, so every step is the base of its successor?
19:56:16 <nextgenresearch> having trouble deciding on a good os to use
19:57:05 <monochrom> are you related to nextgenhacker101?
19:57:18 <nextgenresearch> no, whose that?
19:57:35 <monochrom> he made https://www.youtube.com/watch?v=SXmv8quf_xM
19:58:31 <athan> nextgenresearch: Gentoo :|
19:58:57 <nextgenresearch> I was pretty interested in gentoo, right now I'm sticking with debian based
19:59:08 <nextgenresearch> I've got knoppix, and I tried mint
19:59:11 <bitemyapp> athan: you probably misunderstood me
19:59:38 <armlesshobo> netbsd ftw
20:00:02 <kadoban> Gentoo is really only useful as a learning exercise IMO. Other than that ... so tedious.
20:00:04 <ElectricSolstice> nextgenresearch: how about just debian itself?
20:00:26 <nextgenresearch> probably, not a bad idea
20:01:30 <athan> nixos! :D
20:01:45 * athan 's voice cracked while saying this
20:01:58 <Sonmi> apt has been a convenient pain in the ass to work with from my time with debian
20:01:59 <dmj`> athan: :)
20:02:20 <Sonmi> i'm using arch right now, pacman seems nicer to me so far
20:03:02 <nextgenresearch> You don't like apt ? but, its so convenient for upgrades
20:03:16 <athan> bitemyapp: Given a stack `AppT a = FooT (BarT (BazT Base a))`, isn't `BazT Base` a base of `AppT`?
20:03:24 <Sonmi> although arch IS a bit of a pain for breaking shit like netctl all the time
20:03:31 <glguy> Discussion about various operating systems will be better for #haskell-offtopic
20:03:37 <ElectricSolstice> arch was nice, but too bleeding edge. I had problems with it after a few updates, but was on an old pc that had hardware problems.
20:03:48 <athan> oh wait, monomorphic functional dependencies :(
20:03:52 <bitemyapp> athan: Base is the base
20:04:00 <bitemyapp> typically, IO
20:04:11 <athan> bitemyapp: So you still need to traverse the whole thing? poo
20:04:18 <ElectricSolstice> arch broke the boot... image thing. I don't remember what it's called.
20:04:23 <athan> all your base...
20:04:27 <Sonmi> yeah apt is convenient sure, but it fucked up my system more than once with some weird dependency problems
20:04:42 <ElectricSolstice> i haven't had troubles with apt
20:04:47 <ElectricSolstice> except for software that's too old
20:04:52 <ElectricSolstice> but i use debian stable
20:04:56 <bitemyapp> athan: I think it's tantamount to MonadTrans but I can't speak to what the CPS'ing does perf-wise. I think it's supposed to be quite fast becaues of it but I haven't measured.
20:04:58 <Sonmi> well i'm not sure how much of those fuckups was my fault
20:04:59 <athan> apt stinks when you mess with sources >.>
20:05:02 <Sonmi> i could just be an idiot
20:05:23 <ElectricSolstice> for anything too old, i do end up having to compile it myself on debian
20:05:35 <Sonmi> i'm probably less of an idiot now but pacman is nicer anyway imo
20:06:33 <athan> thanks bitemyapp this helps a lot
20:09:16 <nextgenresearch> is it just me, or do a lot of programmers look the same?
20:09:19 <ElectricSolstice> ah, it was initramfs i think that arch broke or something like that.
20:11:18 <glguy_> It's just you, nextgenresearch.
20:11:30 <nextgenresearch> Yah, you're probably right
20:11:39 <glguy_> The topic for #haskell is Haskell programming
20:11:58 <nextgenresearch> You use an IDE?
20:14:17 <dmj`> nextgenresearch: haskell-mode for emacs is a good "ide" for haskell programming
20:18:11 <nextgenresearch> Do you ever code in lisp?
20:18:15 * hackagebot gearbox 1.0.0.5 - zooming rotating fractal gears graphics demo  https://hackage.haskell.org/package/gearbox-1.0.0.5 (ClaudeHeilandAllen)
20:21:44 <gabbiel> @src (<<)
20:21:44 <lambdabot> Source not found. Just try something else.
20:22:03 <gabbiel> is there no (<<), i know there's (=<<)
20:22:36 <athan> @src (>>)
20:22:36 <lambdabot> m >> k = m >>= \_ -> k
20:23:12 <EvanR> theres no <<
20:23:49 <gabbiel> \_ -> k =<< m
20:23:54 <gabbiel> ok, ill do that
20:23:55 <gabbiel> thanks 
20:24:22 <athan> @let y << x = x >> y -- :D
20:24:23 <lambdabot>  Defined.
20:24:36 <athan> Just 2 << Just 1
20:24:43 <athan> > Just 2 << Just 1
20:24:45 <lambdabot>  Just 2
20:24:50 <athan> ayoo
20:24:53 <athan> @undefine
20:24:53 <lambdabot> Undefined.
20:25:05 <gabbiel> i know  I could of done that, but then it'd contaminate my code
20:26:25 <koz_> If my .cabal has multiple targets, but they all have the same dependencies, do I need to write a separate build-depends for each of them?
20:26:33 <koz_> Keeping them synched is annoying as hell.
20:26:45 <dmj`> koz_: yes, you do, but the executables can depend on the library
20:26:55 <koz_> dmj`: Ah, I see.
20:26:57 <koz_> That makes sense.
20:27:42 <dmj`> so there is incentive to have your own API, consumed by your executables
20:31:45 <gabbiel> how do I tell ghc developers to make (<<) a thing? do you think they'll actually do it?
20:32:29 <dmj`> gabbiel: what would that do
20:32:37 <dmj`> what is (<<)
20:32:58 <gabbiel> like =<< but for >>
20:33:39 <dmj`> @def (<<) = flip (>>)
20:33:40 <lambdabot>  Defined.
20:34:12 <gabbiel> i know, but so that I wouldn't have to do that everytime
20:35:50 <dmj`> gabbiel: might be a hard sell
20:35:52 <gabbiel> and also something like (od) "reverse do", aka IO gets done bottom up
20:36:10 <dmj`> gabbiel: you could probably come close to that with rebindable syntax
20:36:33 <gabbiel> explane
20:36:47 <EvanR> whats the reason against <<
20:36:51 <EvanR> if any
20:37:08 <gabbiel> this, its pretty useful
20:37:41 <gabbiel> they'd just have to type flip (>>), but (od), I don't know if they'd take seriously
20:40:32 <idev> is there any relation between System F and Dependent Types? If so, what ?
20:40:50 <EvanR> they are two corners of the lambda cube
20:41:39 <EvanR> in system F, types can be parameterized by other types (polymorphic types)
20:41:41 <dmj`> gabbiel: http://lpaste.net/166712
20:41:52 <EvanR> in DT types can be parameterized by values
20:42:16 <EvanR> in addition to other types
20:42:53 <dolio> F is values parameterized by types.
20:43:39 <dolio> Like, Maybe is not an entity in System F.
20:43:47 <gabbiel> ll have to look more at that pragma
20:43:51 <EvanR> huh
20:44:11 <idev> EvanR , dolio : so is one "more powerful" than the other?
20:44:18 <dmj`> @google 
20:44:19 <lambdabot> Empty search.
20:44:19 <dmj`> 24 haskell rebindable
20:44:24 <idev> are there certain constraints expressible in one but not in the other ?
20:44:26 <dmj`> @google 24 haskell rebindable
20:44:27 <lambdabot> https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html
20:44:29 <dolio> You can define a type that is the same as `Maybe A`, though.
20:44:38 <dolio> For any given A.
20:44:59 <EvanR> would a -> a be a type
20:45:02 <EvanR> wouldnt it
20:45:42 <EvanR> ADTs are like a convenience thing added to system F
20:46:11 <athan> Is omega-ness just type-level recognizability?
20:46:14 <dolio> forall a. a -> a is a closed type. a -> a is a type in an open context with a variable a, I guess.
20:46:26 <athan> like if systemFw adds kinds to systemF
20:46:28 <EvanR> yeah i meant forall a . a -> a
20:47:09 <dolio> Anyhow, 'more powerful,' is hard to say.
20:47:30 <EvanR> dependent types power level is over 9000
20:47:32 <dolio> If you add dependent types to the simply typed lambda calculus, it's a conservative extension.
20:47:33 <nitrix> Oh my gosh.
20:47:37 <dmj`> gabbiel: wouldn't recommend it in general tbh
20:47:38 <athan> kilowaits
20:47:50 <nitrix> The free monad is so powerful.
20:47:54 <dolio> If you go to System F, it's not a conservative extension, and you can now encode data types.
20:48:01 <dolio> So, which is more powerful?
20:48:12 <EvanR> conservative extension?
20:49:07 <dolio> Anything you can write in simple types + dependent types can be written in simple types by repeating things.
20:49:20 <dolio> Basically.
20:49:46 <dolio> This is just talking about lambda cube type stuff.
20:50:15 <EvanR> where is martin-lof in all this
20:50:27 <dolio> It's pretty different than the lambda cube.
20:50:59 <EvanR> was that discovered around the same time or later, making the lambda less cool
20:51:11 <EvanR> lambda cube
20:51:22 <dolio> I don't know history very well.
20:51:44 <EvanR> then were doomed to repeat it!
20:53:17 * hackagebot wai-transformers 0.0.6 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.6 (athanclark)
20:54:10 <gabbiel> i love code aesthetics so much
20:59:30 <koz_> I know of the listOf and listOf1 combinators in QuickCheck for Gen. What would be the most sensible way of writing the equivalent of listOf2? Would it be some combination of arbitrary and listOf1?
20:59:44 <koz_> (I *assume* that's the best way, but I was wondering if there was some other magic I could work for this)
21:00:46 <koz_> I guess I could also combine arbitrary for Int, suchThat and infiniteListOf...
21:01:49 <athan> @hackage quickcheck-combinators --:D
21:01:49 <lambdabot> http://hackage.haskell.org/package/quickcheck-combinators --:D
21:02:01 <koz_> athan: There's more? Damn.
21:02:22 <athan> warning: I made it
21:02:34 <koz_> athan: Are you planning on doing serious API breakage on this thing?
21:02:34 <athan> and there's no tests ironically
21:02:37 <koz_> LOL.
21:02:42 <koz_> Yes, very ironically.
21:02:57 <koz_> So I could use atLeast to do what I want? Awesome.
21:03:04 <athan> koz_: I don't think so. If there will be, it wil be a hard version
21:03:07 <athan> will*
21:03:13 <athan> :)
21:03:18 <dolio> EvanR: Another thing is, you can add polymorphism in two ways.
21:03:22 <athan> Only if it's an unfoldable though!
21:03:56 <dolio> EvanR: One is that when you add the type 'forall a. a -> a' the a is ranging over simple types, which were already in the theory.
21:04:11 <dmj`> koz_: listOf2 gen = sized $ \n -> flip replicateM gen =<< choose (2, n `max` 2)
21:04:16 <dolio> This is usually called predicative.
21:04:42 <EvanR> uh huh
21:04:53 <dolio> And I think predicative polymorphism is a conservative extension. It doesn't let you do anything really new, it just lets you repeat yourself less.
21:05:22 <dolio> But, System F is impredicative, and the a ranges over all types, including all the new types System F has added.
21:05:30 <dolio> And that lets you do fundamentally new things.
21:06:06 <koz_> OK athan - I need to use your stuff + QuickCheck to try and glue together orderedList and atLeast to get an ordered list of at least length 2.
21:06:09 <koz_> How would I do that?
21:07:43 <dmj`> koz_: did you see listOf2 above?
21:07:44 <athan> koz_: newtype OrderedList a = [a] -- make your ordering part of the arbitrary instance
21:07:57 <athan> make an unfoldable instance for it, probably deriving it
21:08:03 <koz_> dmj`: I did - but athan's got me convinced to try his library.
21:08:18 <dmj`> athan is good at that :)
21:08:19 <athan> then just do `arbitrary :: AtLeast 2 OrderedList a`
21:08:32 <athan> >.>
21:08:37 <athan> IT'S BAD probably
21:08:39 <athan> maybe
21:08:56 <athan> see I can't even spell ordered
21:08:59 <athan> er whatever
21:09:07 <koz_> athan: Hold on a sec there.
21:09:27 <dmj`> athan: this package is pretty swanky
21:10:06 <koz_> athan: I'll give that a go - I'm pretty sure [a] is already an Arbitrary if a is an Arbitrary.
21:10:19 <athan> :) thanks dmj`
21:10:48 <athan> you're right koz_
21:11:11 <athan> Now if only I could metaprogram in some kind of dependently typed way
21:11:36 <athan> existential constraints! >:(
21:12:25 <koz_> athan: I already have an OrderedList from QuickCheck with an arbitrary instance.
21:12:35 <koz_> So I guess I can just jump right the fuck ahead to the last step. :)
21:12:38 <athan> :x
21:12:50 <athan> what about unfoldable though?
21:12:54 <koz_> s/arbitrary/Arbitrary
21:13:07 <koz_> athan: UnfoldableR, right?
21:13:17 * hackagebot homoiconic 0.1.2.0 - Constructs FAlgebras from typeclasses, making Haskell functions homoiconic  https://hackage.haskell.org/package/homoiconic-0.1.2.0 (MikeIzbicki)
21:13:18 <athan> Yessir!
21:13:31 <athan> To note the potional restriction on the children or something
21:13:31 <koz_> Where does *that* live?
21:13:38 <athan> it's like a higher order typeclass
21:13:43 <athan> really painful
21:13:53 <athan> unfoldable-restricted I think :s
21:14:03 <koz_> athan: I think that it kinda belongs in your library - I'd be happy to write it for you.
21:14:45 <athan> koz_ Ordered? Ok hmm
21:14:51 <koz_> OrderedList.
21:14:53 <koz_> Do you want a link?
21:14:57 <athan> Yeah definitely I mean if you get something rolling feel free to submit a PR
21:15:21 <koz_> athan: https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck.html#g:14 <-- in here is OrderedList
21:15:23 <athan> I can't divert my focus right now, but please open an issue or something and we can connect there :)
21:15:29 <athan> my computer is just borking hard right now
21:15:42 <koz_> So I reckon that quickcheck-combinators should contain an instance for UnfoldableR for OrderedList.
21:15:44 <athan> oh! Nice!
21:15:54 <athan> I agree too
21:16:02 <koz_> No wait, it's not there.
21:16:07 <koz_> Let me find where it actually is,s orry.
21:16:28 <koz_> Wait, no, it *is* there - right after Fixed.
21:16:50 <koz_> athan: Could you give me a sorta overview of wtf unfoldRestrict is meant to do?
21:17:06 <athan> Okay I'm going to have to get a chisel and probably ducktape
21:17:55 <athan> koz_: Check oiut `pred` in the type signature of `unfoldRestrict`
21:18:41 <athan> basically, a HashSet is only unfoldable if the children are also Eq and Hashable
21:18:45 <koz_> athan: Where does 'pred' come from?
21:18:51 <athan> same with Set
21:19:03 <athan> http://hackage.haskell.org/package/unfoldable-restricted-0.0.2/docs/Data-Unfoldable-Restricted.html
21:20:12 <ics> If I wanted to scan the type signatures in one hs source file and use those to generate class instances in another... is haskell-src-exts the thing I should be reading about?
21:21:07 <ics> (assuming I didn't want to non-native, e.g. bash, stuff into the build process)
21:21:08 <athan> ks: It's a nice parser, but not the exact one ghc uses
21:21:32 <athan> so there may be subtle balding
21:21:45 <koz_> athan: Could you please tell me in what libraries the 'pred' and 'Unfolder' types live so I can send you a pull request. :P
21:21:48 <athan> and/or twitching
21:22:03 <gabbiel> why doesn't https://0x0.st/TMi.hs work
21:22:08 <athan> koz_: pred is a variable :)
21:22:19 <athan> CONSTRAINT KINDS DAWG
21:22:32 <koz_> athan: Oh, *that* is what we're on about, right.
21:22:32 * athan emphasises the face melting
21:22:41 <koz_> So where does Unfolder live?
21:22:49 <athan> unfoldable :)
21:23:05 <koz_> athan: OK, time to read and shave yaks.
21:23:16 <athan> :)
21:23:29 <glguy> gabbiel: Is this a quiz or is the actual error message forthcoming?
21:24:10 <glguy> gabbiel: You can't use writeFile on a file that you've already opened
21:24:38 <benzrf> athan: "balding"?
21:25:02 <athan> just mear cheese allover yourself, it's the new thing
21:25:07 <athan> smear*
21:25:15 <athan> alright I'm out
21:25:24 <glguy> gabbiel: You shouldn't use hClose on a file that you've used hGetContents on, and you can't writeFile a file that you have opened already
21:27:13 <gabbiel> glguy, but its on ReadWriteMode
21:27:31 <glguy> gabbiel: writeFile is trying to open it again, which you can't do
21:27:44 <lpaste> glguy pasted “for gabbiel” at http://lpaste.net/166718
21:27:46 <gabbiel> so how do I write without opening
21:29:00 <glguy> gabbiel: Ignore the pragmas at the top, I pasted your code in an existing demo file
21:30:41 <gabbiel> let me go over it real quick
21:32:13 <gabbiel> oh I see, so u close the thing before writing
21:32:27 <gabbiel> but then, whats the point of ReadWriteMode, shouldn't it write because it's on that mode?
21:32:36 <glguy> If you wanted to open the file once like you had you could, but then you need to stop using "writeFile"
21:33:12 <glguy> and use hSeek to move back to the beginning of the file, possibly do something to truncate it (not sure) and then hPutStrLn to write to it
21:37:03 <gabbiel> hanks glguy
21:37:06 <gabbiel> *thanks
21:37:24 <lpaste> glguy annotated “for gabbiel” with “for gabbiel (annotation)” at http://lpaste.net/166718#a166719
21:37:31 <glguy> gabbiel: There's some code that opens just once
21:38:08 <glguy> Doesn't handle the case when the file is empty, though
21:40:47 <gabbiel> thanks very much glguys, I understand now
21:42:38 <glguy> we're happy to help
21:44:35 <gabbiel> ok, so I have a keybinding for exectuing this binary, but if I press the keybinding (twice or more) in a quick succession, it's going to give an error (because the first executuion was doing stuff), is there any way to check if a file's handle is open, so that I can maybe do some "ifHandlisOpenOf h `catch` doThis"
21:48:19 * hackagebot bmp 1.2.6.1 - Read and write uncompressed BMP image files.  https://hackage.haskell.org/package/bmp-1.2.6.1 (BenLippmeier)
21:53:19 * hackagebot repa-scalar 4.2.3.1 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.3.1 (BenLippmeier)
21:57:13 <glguy> gabbiel: You can attempt to create a lock file when your program starts and exit early if the lock file is already created
21:57:59 <glguy> gabbiel: Open "whatever.lock" using http://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO.html#g:3 and an exclusive create mode
21:58:28 <glguy> and then delete it at the end of your program
21:58:53 <glguy> maybe write the pid of your program into that file to give a debugging hint later
22:01:11 <gabbiel> give me a sec, I'm reading the documentation
22:01:57 <gabbiel> is file descriptor just the handle?
22:07:04 <geekosaur> a file descriptior is an Int which is what the POSIX system call returns. on POSIX OSes, a Handle wraps a file descriptor, a buffer, and some other stuff. (on Windows it's more complex, because Windows socket handles are not in the same namespace as file descriptors)
22:08:20 * hackagebot repa-stream 4.2.3.1 - Stream functions not present in the vector library.  https://hackage.haskell.org/package/repa-stream-4.2.3.1 (BenLippmeier)
22:08:21 * hackagebot repa-eval 4.2.3.1 - Low-level parallel operators on bulk random-accessble arrays.  https://hackage.haskell.org/package/repa-eval-4.2.3.1 (BenLippmeier)
22:09:34 <geekosaur> System.Posix.IO provides fdToHandle and handleToFd functions. you should be *very( careful about mixing these, in the same way (and for the same reason) that mixing file descriptors and FILE* in C is a bad idea
22:10:49 <geekosaur> but for this use, it's safe to use the POSIX open with O_CREAT|O_EXCL, fdToHandle to make a normal Handle out of it, and then just drop the fd on the floor (the created Handle will have its own copy of it)
22:11:25 <gabbiel> im a newbie, I shouldn't dabble withat that then, ill stick to creating a temp file and checkoing if it exists or not
22:11:57 <geekosaur> you probably should learn this if you need to worry about it. otherwise you're just creating a race condition
22:12:37 <gabbiel> race condition/
22:12:39 <gabbiel> *?
22:13:20 * hackagebot repa-convert 4.2.3.1 - Packing and unpacking flat tables.  https://hackage.haskell.org/package/repa-convert-4.2.3.1 (BenLippmeier)
22:13:22 * hackagebot repa 3.4.1.1 - High performance, regular, shape polymorphic parallel arrays.  https://hackage.haskell.org/package/repa-3.4.1.1 (BenLippmeier)
22:13:25 <geekosaur> it's surprisingly easy for two processes to interleave such that the first checks if the lockfile exists, then gets task-switched to the second which creates the lockfile, then back to the first which creates the lockfile
22:13:36 <gabbiel> O isee, i googled it
22:13:50 <geekosaur> which is why the POSIX create options exist, and why Haskell exposes them in System.Posix.IO
22:14:21 <geekosaur> (things work differently on Windows, and the win32 package has equivalent but incompatible mechanisms to accomplish the same end)
22:23:20 * hackagebot repa-array 4.2.3.1 - Bulk array representations and operators.  https://hackage.haskell.org/package/repa-array-4.2.3.1 (BenLippmeier)
22:33:20 * hackagebot repa-flow 4.2.3.1 - Data-parallel data flows.  https://hackage.haskell.org/package/repa-flow-4.2.3.1 (BenLippmeier)
22:43:21 * hackagebot repa-io 3.4.1.1 - Read and write Repa arrays in various formats.  https://hackage.haskell.org/package/repa-io-3.4.1.1 (BenLippmeier)
22:44:29 <pplorins> hello
22:44:34 <pplorins> Is anyone there ?
22:45:03 <Welkin> no
22:45:11 <johnw> I'm not here either
22:45:22 <Welkin> pink floyd?
22:46:28 <pplorins> what’s floyd ?
22:48:21 * hackagebot repa-algorithms 3.4.1.1 - Algorithms using the Repa array library.  https://hackage.haskell.org/package/repa-algorithms-3.4.1.1 (BenLippmeier)
22:49:10 <Welkin> o.o
22:49:19 <Welkin> pplorins: is anybody out there?
22:49:36 <Welkin> pplorins: look them up on youtube, you won't regret it
22:52:10 <Ashy> anyone using the protolude in their projects?
22:52:46 <ijp> is there a monoid instance for Maps whose values are monoids?
22:53:21 * hackagebot repa-examples 3.4.1.1 - Examples using the Repa array library.  https://hackage.haskell.org/package/repa-examples-3.4.1.1 (BenLippmeier)
22:54:01 <Axman6> ijp: there's an instance for instance Ord k => Monoid (Map k v)
22:54:05 <Axman6> so no
22:54:14 <ijp> bah
22:54:17 <Axman6> but it should be as simple as unionWith (<>)
22:54:34 <Welkin> ijp: black sheep?
22:54:40 <ijp> ?
22:54:42 <gabbiel> how come I can't do {f = 3; v = 9} in a script?
22:55:07 <ijp> https://ghc.haskell.org/trac/ghc/ticket/1460
22:55:09 <Axman6> gabbiel: where are you trying to use that?
22:55:50 <ijp> seems wrong to me to mark it as "fixed"
22:56:37 <gabbiel> in just a line
22:57:13 <Axman6> gabbiel: you can write that without the braces
22:57:16 <gabbiel> so that instaed of doing "f = a\n v = 9", it'd be in a single line
22:57:31 <Axman6> f = 3; v = 9 should work fine
22:58:04 <gabbiel> nice
23:03:22 * hackagebot gloss-rendering 1.10.2.1 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.2.1 (BenLippmeier)
23:03:24 * hackagebot gloss 1.10.2.1 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.10.2.1 (BenLippmeier)
23:03:26 * hackagebot gloss-algorithms 1.10.2.1 - Data structures and algorithms for working with 2D graphics.  https://hackage.haskell.org/package/gloss-algorithms-1.10.2.1 (BenLippmeier)
23:08:22 * hackagebot gloss-raster 1.10.2.1 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.10.2.1 (BenLippmeier)
23:22:13 <osager_> stack ghci complains: <no location info>:
23:22:13 <osager_>     Could not find module ‘Data.HashMap.Strict’
23:22:13 <osager_>     It is a member of the hidden package ‘unordered-containers-0.2.7.0@unord_2BLx4faR35mFWLJj5xiBgm’.
23:22:20 <osager_> what's wrong here
23:23:09 <athan> osager_: Is it a library?
23:23:30 <athan> that you're currently working on, with a .cabal file I mean. Like the project you're working on
23:23:37 <osager_> yes
23:23:44 <osager_> there is a .cabal
23:23:45 <athan> if it built fine, ghci should load fine
23:23:51 <athan> is there an executable too?
23:23:54 <osager_> yes it loads fine
23:24:00 <osager_> yes with an exe
23:24:07 <athan> hmm
23:24:10 <koz_> athan: Sent the PR through.
23:24:23 <osager_> PR ?
23:24:29 <athan> Thanks koz_ :)
23:24:31 <koz_> osager_: It's not about the current issue.
23:24:40 <silverjam> Are numeric constants treated differently in source files than they are in the interpreter?
23:24:42 <koz_> athan: Hope you don't mind the mild cleanup I also did of my own initiative.
23:24:49 <athan> osager_: Can you load ghci with just `ghci`?
23:25:01 <athan> Gladly taken :)
23:25:24 <silverjam> > :t (*5) 9
23:25:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:25:34 <osager_> i did put in .cabal a lot of libs that i dont actually use in the code
23:25:37 <athan> silverjam: As literals, no.
23:25:40 <athan> @type 1
23:25:41 <lambdabot> Num a => a
23:25:51 <silverjam> @type (*5) 9
23:25:52 <athan> For any type that implements "Num"
23:25:52 <lambdabot> Num a => a
23:26:31 <silverjam> athan: if I type that into a source file, and load it in ghci, the type is Integer, not (Num a)
23:27:06 <athan> siloxid: I think this deals with the monomorphism restriction? I'm not sure
23:27:20 <athan> but I think it's about storing the code to binary or something
23:27:45 <athan> but basically, GHC will choose an arbitrary instance for I think just the Num class
23:27:56 <athan> Double for Floating, Fractional etc
23:28:06 <athan> (Maybe Rational for Fractional?)
23:28:11 <athan> and Integer for Integral
23:28:23 * hackagebot gloss 1.10.2.2 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.10.2.2 (BenLippmeier)
23:28:51 <athan> silverjam: Watch what happens if you build it, but with an explicit polymorphic type
23:28:58 <athan> and not let type inference take over
23:29:34 <gabbiel> anybody wanna rate my final code? (which has race condition prevention now)
23:30:27 <koz_> athan: When you get the chance, please merge my changes (it includes a version bump) and upload to Hackage?
23:30:32 <koz_> No rush though.
23:31:46 <silverjam> athan:  if I give it an explicit type, it stays as Num a
23:32:06 <athan> koz_: Sure let me just dig through it. I'm sorry I'm working on a different project right now
23:32:29 <athan> If you're using stack, you can include clones easily with '../foo'
23:32:32 <koz_> athan: No worries - didn't mean to rush you. :)
23:33:01 <osager_> how can i get a list of random Int with  getStdGen >>= return . randoms
23:33:04 <athan> silverjam: It's strange, right? I think it's an optimization
23:33:13 <koz_> osager_: Type annotation.
23:33:36 <osager_>  getStdGen >>= return . randoms :: IO (Int)
23:33:39 <osager_> is wrong
23:33:40 * athan thinks someone should check him on his understanding of -XNoMonomorphismRestriction
23:34:01 <koz_> osager_: getSrdGen >>= return . randoms :: IO [Int] might work better. :)
23:34:12 <koz_> You're trying to get a list, not a single value.
23:34:16 <osager_> zut...
23:34:18 <osager_> thanks
23:34:32 <koz_> osager_: No worries - I made that mistake a thousand times, and will likely make it a thousand more.
23:35:16 <osager_> :)  we can perhaps put this in ghci or ghc source code
23:35:17 <silverjam> athan: hmm, ok
23:36:52 * slack1256 started to love TypeHoles
23:37:23 <slack1256> but if somebody has a better way to test closures it's welcome
23:39:14 <andrewhn> hello, would someone be able to help me understand the following error from stack: --  Failure when adding dependencies:           optparse-applicative: needed (>=0.12 && <0.13), 0.11.0.2 found (latest applicable is 0.12.1.0)
23:41:03 <kadoban> andrewhn: Pretty sure that's what you get when the resolver has an older version of the package than you're requiring in the build-dep bounds in the cabal file. You can either add it as an extra-dep in stack.yaml or loosen your requirements, if that's possible.
23:41:26 <kadoban> (or a package you're depending on could be requiring that version range, that's probably more likely)
23:42:21 <andrewhn> kadoban yeah it's a dependency
23:43:03 <andrewhn> so the latest applicable message refers to a package with a different resolver
23:43:13 <andrewhn> is that right?
23:43:32 <kadoban> I believe that refers to the latest one it knows about from hackage.
23:45:01 <andrewhn> gotcha
23:45:06 <andrewhn> thanks
23:48:23 * hackagebot gloss-examples 1.10.2.1 - Examples using the gloss library  https://hackage.haskell.org/package/gloss-examples-1.10.2.1 (BenLippmeier)
23:58:24 * hackagebot buildbox 2.1.9.1 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.9.1 (BenLippmeier)
