00:04:56 <Xnuk> :t [Nothing, Just Nothing, Just $ Just Nothing, Just . Just $ Just Nothing, Just . Just . Just $ Just (Just $ Just Nothing)]
00:04:57 <lambdabot> [Maybe (Maybe (Maybe (Maybe (Maybe (Maybe (Maybe a))))))]
00:18:39 <nilof> yay
00:18:51 <nilof> that feeling when the entire concept of maps and currying "clicks"
00:19:11 <nilof> like in this line: zeroHamiltonian n = map ($ (listOfDyckPaths n) ) ((map map) (map pathsConnected $ listOfDyckPaths n)) 
00:19:12 <begriffs> lyndon1: I found that once I updated ld by installing a new binutils package the segfault went away.
00:20:39 <Axman6> nilof: just use lambdas, that's really unclear
00:23:15 <nilof> it's mostly a really roundabout way, to map a linear map on a tensor product space
00:23:32 <nilof> to an element which is a tensor product of vector spaces
00:24:08 <nilof> or rather, to construct the matrix corresponding to the map
00:26:51 <nilof> ah right
00:27:00 <nilof> using a lambda did simplify that a lot
00:28:02 <nilof> I got  zeroHamiltonian n = map (\x -> map (pathsConnected x) $ listOfDyckPaths n ) $ listOfDyckPaths n which is way clearer
00:28:43 <nilof> though playing with (map map) was fun and instructive
00:53:23 * hackagebot ltiv1p1 1.0 - Partial implementation of a service provider for LTI 1.1.  https://hackage.haskell.org/package/ltiv1p1-1.0 (achirkin)
00:58:18 <gfixler> If I type #2 in ghci, it just accepts it silently
00:58:20 <gfixler> what's going on there?
01:08:21 <tobiasBora> Hello,
01:09:06 <tobiasBora> I would like to be able to import functions from a file into another file, (like a module), but keep a function main :: IO () to run some test code to test my library
01:09:47 <tobiasBora> When I add the "module XXX where" on the top of my file, I can import it but not "runhaskell" it. Any other options that having to differents files ?
01:12:48 <quchen> tobiasBora: I think you can pass a flag like "main-is" to GHC (and by extension runhaskell).
01:12:56 <quchen> There you can specify which module to run as main.
01:14:16 <quchen> tobiasBora: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--main-is
01:15:00 <tobiasBora> quchen: It works, thank you !
01:19:44 <ertesx> pikajude: yeah, it looks fine, but only testing will tell
01:24:21 <ertesx> lyndon1: you could use two lists of Char, two Seqs or two finger-tree-ropes
01:25:08 <ertesx> all of them have O(1) operations at the edges and differ mainly in memory usage
01:26:56 <cocreature> gfixler: hm that‚Äôs interesting. a quick grep through the source doesn‚Äôt bring anything up
01:31:22 <netsu> Hello! Can I do something like that: ghci -ghci-script <<< `echo :show prompt`
01:31:51 <netsu> I mean, load ghci setup from command output, not from file?
01:32:39 <netsu> just eval something from ghci script and quit
01:32:46 <netsu> *show and quit
01:32:54 <koz_> netsu: You mean kinda like Perl's -e or whatever?
01:33:02 <koz_> runhaskell is probably what you seek.
01:33:30 <netsu> koz_: but I probably can't GHCi's prompt value from runhaskell?
01:33:38 <netsu> *isn't it?
01:38:30 <cocreature> netsu: you can set your ghci prompt from a .ghci file
01:38:59 <netsu> cocreature: it's fine, ok. And how can I get it into shell variable then?
01:43:08 <sdx23> netsu: why you want to do this?
01:43:21 <netsu> sdx23: https://github.com/haskell/haskell-mode/issues/1353#issuecomment-223824423
01:45:55 <cocreature> netsu: echo ":show prompt\n:quit" | ghci seems to do the trick
01:46:11 <cocreature> you still need to cleanup the output to get what you want
01:46:25 <zinking> anyone could invite me to #java channel ?
01:47:19 <zinking> let me ask here anyways. I have a java call stack  b->a, but in the source code there is no a at all. 
01:47:42 <cocreature> zinking: this channel is about the haskell programming language, not about java
01:47:53 <zinking> fine. 
01:47:59 <zinking> my apology 
01:58:36 <ertesx> interesting strategy:  you have a question about burritos?  just ask in the top 10 of freenode channels; statistically some burrito enthusiast somewhere will likely answer regardless of channel topic =)
01:58:49 <ertesx> (this isn't about monads)
01:59:33 <nomeata> ertesx: Burritos are usually made out of wheat flour.
01:59:34 <Akii> there should be a BurritoT
01:59:47 <tdammers> cabal install burrito-transformers
02:00:54 <lyndon1> ertesx: what's a good FT-Rope library?
02:03:25 * hackagebot persistent-redis 2.5.0 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.0 (PavelRyzhov)
02:03:40 <tobiasBora> I have a little problem :
02:03:58 <tobiasBora> I would like to compute a sum of doubles, and then take the log of the sum
02:04:40 <tobiasBora> the problem is that the sum can be huge before taking the log, so often I get "Infinity" instead of a good result
02:05:14 <tobiasBora> Is it possible to have arbitrary exposant in a double-like type ?
02:05:54 <merijn> tobiasBora: Do you need reals or is rational sufficient for you?
02:06:32 <merijn> oh, wait, rational isn't floating :\
02:07:34 <tobiasBora> Well I usually take power (**), so if I can do mytype ** mytype -> mytype, is may be ok
02:08:11 <tdammers> tobiasBora: would Data.Scientific be a good fit?
02:08:51 <merijn> tobiasBora: That doesn't help, ** still requires Floating
02:09:18 <merijn> Maybe the numbers package?
02:09:47 <merijn> tdammers: Scientific is not Floating so you can't take a log of it
02:10:14 <merijn> tdammers: It's merely fractional, at which point you might as well just use Ratio
02:11:22 <tdammers> merijn: ah, right
02:13:26 * hackagebot yarr 1.4.0.2 - Yet another array library  https://hackage.haskell.org/package/yarr-1.4.0.2 (DominicSteinitz)
02:13:28 * hackagebot cgrep 6.6.14 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.14 (NicolaBonelli)
02:16:09 <tobiasBora> merijn: I'm trying this package, but I can't see how to convert a Double into a BigFloat
02:18:22 <merijn> tobiasBora: realToFrac
02:23:26 * hackagebot neural 0.1.0.1 - Neural Networks in native Haskell  https://hackage.haskell.org/package/neural-0.1.0.1 (lbrunjes)
02:35:17 <ertesx> lyndon1: there is the rope package, but it's hard-coded to ByteString
02:35:26 <ertesx> lyndon1: i'd use the fingertree package with Text
02:36:46 <ertesx> tobiasBora: if the range of Double is not sufficient (that seems unlikely), you could use Data.Fixed with a custom precision type
02:37:21 <ertesx> nevermind
02:37:25 <ertesx> it's not Floating either
02:37:44 <ertesx> tobiasBora: try to scale your numbers down
02:38:57 <tobiasBora> ertesx: Well sometimes some numbers works, but I've 90% of them which are infinite
02:39:22 <ertesx> tobiasBora: how do those pop up?
02:39:49 <ertesx> the range of Double is huge
02:40:34 <tobiasBora> ertesx: Well, when you sum exp(45) n times, it can be also huge I think
02:40:46 <ertesx> > 50000000 * exp 45
02:40:47 <lambdabot>  1.7467135528742548e27
02:40:48 <ertesx> no
02:40:52 <ertesx> that's small for Double
02:41:08 <tobiasBora> > exp 500
02:41:11 <lambdabot>  1.4035922178528375e217
02:41:18 <tobiasBora> Hum.
02:41:18 <tdammers> > log $ exp 500
02:41:21 <lambdabot>  500.0
02:41:37 <ertesx> tobiasBora: what are you implementing?  softmax?
02:41:46 <tobiasBora> Maybe I've some division by zero that make it explode ^^
02:42:17 <tdammers> have you tried boiling it down to the minimum code snippet that still exposes the problem?
02:42:34 <tobiasBora> tdammers: Not yet, I may work on it
02:42:46 <ertesx> i'm asking because softmax is very limited with Double
02:42:55 <tdammers> because in my experience, half of the times you do that the actual source of the problem becomes obvious
02:42:58 <ertesx> @let softmax = log . sum . map exp
02:42:59 <lambdabot>  Defined.
02:43:05 <ertesx> > softmax [5, 20, 11]
02:43:07 <lambdabot>  20.00012370805425
02:43:15 <ertesx> > softmax [5000, 20000, 11000]
02:43:17 <lambdabot>  Infinity
02:43:41 <tdammers> > exp 11000
02:43:43 <lambdabot>  Infinity
02:43:50 <tdammers> so, that
02:45:59 <ertesx> i think you can expand the range by using a different base
02:46:01 <ertesx> @undef
02:46:01 <lambdabot> Undefined.
02:46:16 <ertesx> @let softmax = logBase 1.0001 . sum . map (1.0001 **)
02:46:19 <lambdabot>  Defined.
02:46:22 <ertesx> > softmax [5000, 20000, 11000]
02:46:26 <lambdabot>  24884.41752714786
02:46:30 <ertesx> but it also makes it less accurate, as you see
02:46:40 <tdammers> that's always the tradeoff with floats
02:46:52 <tdammers> s/always/often/
02:47:17 <ertesx> one way to get around it is to model using a very hard softmax and then in code just use regular 'max' to approximate it
02:47:37 <ertesx> @let hardsoftmax = logBase 100 . sum . map (100 **)
02:47:39 <lambdabot>  Defined.
02:47:50 <ertesx> > hardsoftmax [10, 10.5, 9]
02:47:52 <lambdabot>  10.520893659485875
02:48:27 * hackagebot ltiv1p1 1.0.0.1 - Partial implementation of a service provider for LTI 1.1.  https://hackage.haskell.org/package/ltiv1p1-1.0.0.1 (achirkin)
02:48:29 * hackagebot persistent-redis 2.5.1 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.1 (PavelRyzhov)
02:48:31 <netsu> is there any extension to do let (str, rest):_  = reads li :: [(String, String)]; (chr, rest):_ = reads li :: [(Char,   String)] in .... -- rest have same name and same type in both tuples?
02:48:37 <Koen_> > hardsoftmax [0.1, 1, 10]
02:48:39 <lambdabot>  10.0
02:49:09 <merijn> netsu: Why do you want the same name in both tuples? When you use "rest", which should it use?
02:50:02 <ertesx> netsu: haskell has no way to unify pattern variables, if that's what you're asking‚Ä¶  unification would involve equality testing
02:50:21 <ertesx> if you need that, use a guard:  | rest == rest' = ‚Ä¶
02:54:41 <netsu> merijn: http://lpaste.net/165573 seems like duplication of logic
02:55:49 <merijn> netsu: Which rest is rest supposed to refer too?
02:55:50 <ertesx> netsu: it isn't‚Ä¶  you're applying two different functions
02:56:23 <ertesx> they are just named the same (reads) by virtue of class-based ad-hoc polymorphism
02:56:25 <tobiasBora> ertesx: Indeed my function looks like softmax : it's something like log (sum_i pi^alpha * qi^(1-alpha))    (renyi divergence if you know that)
02:56:34 <netsu> http://lpaste.net/165574
02:57:35 <netsu> but here I should twice write almost the same (reads li)
02:57:42 <tobiasBora> With BigFloat I do not have Infinity anymore...
02:57:46 <tobiasBora> Thank you !
02:58:13 * tobiasBora will leave because it doesn't have battery anymore. Thank you for your help !
02:58:23 <ertesx> tobiasBora: you should probably try to rewrite your formula instead‚Ä¶  but of course you can't get rid of the sum below the log
03:02:00 <netsu> ertesx: merijn: couldn't do I something like http://lpaste.net/165575 ? Because it's just a local binding, so, maybe, some syntax extension?
03:02:29 <ertesx> netsu: you can, but you need a type signature in that case
03:02:41 <ertesx> at least for c
03:02:55 <netsu> ertesx: c may be or Char or String
03:03:03 <netsu> ertesx: dependent on case
03:03:56 <ertesx> > let c :: (Read a) => a; (c, d) = (read "15", ()) in c :: Int
03:03:58 <lambdabot>      No instance for (Read t0)
03:03:58 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
03:03:58 <lambdabot>      When checking that ‚Äòd‚Äô has the inferred type
03:04:10 <ertesx> ah, doesn't work that way
03:04:55 <ertesx> > let (c, d) :: (Read a) => (a, ()); (c, d) = (read "15", ()) in c :: Int
03:04:57 <lambdabot>  <hint>:1:5:
03:04:57 <lambdabot>      Invalid type signature: (c, d) :: (Read a) => (a, ())
03:04:57 <lambdabot>      Should be of form <variable> :: <type>
03:05:13 <netsu> nice bot)
03:05:16 <ertesx> nope‚Ä¶  can't do it below a pattern match
03:05:29 <ertesx> > let cd :: (Read a) => (a, ()); cd = (read "15", ()) in fst cd :: Int
03:05:31 <lambdabot>  15
03:05:42 <ertesx> > let cd :: (Read a) => (a, ()); cd = (read "15", ()) in (fst cd :: Int, fst cd :: Double)
03:05:44 <lambdabot>  (15,15.0)
03:06:16 <ertesx> in any case you need an explicit type signature to keep local things polymorphic
03:07:50 <ertesx> also note that characters and strings can fail to parse‚Ä¶  the pattern you bind there is wrong
03:13:28 * hackagebot sproxy 0.9.6 - HTTP proxy for authenticating users via Google OAuth2  https://hackage.haskell.org/package/sproxy-0.9.6 (ip1981)
03:16:41 <ReaTb> If you call the same function with the same arguments from the same scope multiple times.. is the function evaluated every time, or will the compiler realise what you're doing and keep the result from the first call in memory?
03:17:18 <ertesx> ReaTb: sharing is used, if you name the result
03:17:29 <ertesx> shared:  let y = f x in y + y
03:17:37 <ertesx> likely not shared:  f x + f x
03:17:43 <dredozubov_> ReaTb: the result will be used if you use the same local binding
03:18:09 <hpc> basically the same way other languages work
03:18:10 <ertesx> ReaTb: anything that introduces a name (let, lambda, pattern variables, etc.) also introduces sharing
03:18:23 <ertesx> hpc: other languages often do CSE, but haskell doesn't in general
03:18:35 <hpc> they do?
03:18:52 <hpc> i would expect it to be even less frequent in other languages due to them being impure
03:18:53 <ertesx> sure, if f is known to be pure, and you write f(x) + f(x) in C, it will likely use sharing
03:19:12 <tdammers> hpc: I'm pretty sure the major C and C++ compilers do it
03:19:25 <tdammers> hpc: industry-strength JS implementations too
03:19:26 <dredozubov_> But how is that became known to the gcc? Never thought about it.
03:19:50 <dredozubov_> not necessarily gcc, but you get the point
03:19:54 <ertesx> dredozubov_: either by inference or by explicit annotation (there is a weird syntax for it that i could never memorise)
03:20:11 <ReaTb> Why doesn't ghc do this too? I would have thought it would be easier to do with the functional paradigm?
03:20:11 <dredozubov_> so it's never used in practice
03:20:30 <ReaTb> Note: I've never written a compiler
03:20:45 <ertesx> ReaTb: because of haskell's laziness it's impossible to know whether the CSE-ed variant will perform better, and in most cases it will perform worse
03:21:00 <ReaTb> 'CSE'?
03:21:06 <ertesx> ReaTb: in particular sharing can hold stuff in memory that would otherwise be quickly garbage-collected
03:21:08 <tdammers> Common Subexpression Elimination
03:21:09 <hpc> common subexpression elimination
03:21:14 <dredozubov_> ReaTb: common subexression elimination
03:21:20 <hpc> @quote stereo
03:21:20 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
03:21:28 <hpc> :(
03:21:37 <tdammers> 2.1, actually
03:21:39 <ertesx> hehe
03:21:53 <dredozubov_> tdammers: i can't do it that low :(
03:21:53 <ReaTb> Think I've got a handle on it, thanks
03:22:17 <pantsman_> if #haskell did CSE, hpc and dredozubov_ could just have said, "what tdammers said"
03:22:18 <ertesx> ReaTb: here is an example:  let xs = [1..1000000] in sum xs * sum xs
03:22:26 <hpc> i still don't like the idea of C compilers doing CSE
03:22:49 <hpc> it seems like it would be extremely easy to have it accidentally eliminate effects
03:22:51 <tdammers> hpc: why not? they do a truckload of fairly hardcore optimizations, why not CSE?
03:23:00 <tdammers> you have to be conservative about effects
03:23:05 <ertesx> ReaTb: the list has a name, and it is referred to twice, so it becomes an actual list in memory, even though the computation doesn't need it
03:23:17 <dredozubov_> hpc: what's the problem if it's explicit enough?
03:23:22 <tdammers> but I believe at the nitty-gritty level, it is perfectly reasonable to optimize those cases where inferring purity is trivial
03:23:26 <dredozubov_> you have to do some sort of annotations
03:23:29 <ertesx> ReaTb: counter-example:  let xs _ = [1..1000000] in sum (xs ()) * sum (xs ())
03:23:37 <ertesx> ReaTb: this time the list doesn't have a name
03:23:44 <ertesx> everything runs in constant time
03:23:54 <hpc> constant space, anyway
03:23:55 <ertesx> uhm
03:23:59 <ertesx> yeah, constant space
03:24:02 <dredozubov_> tdammers: i'm not super sure it's trivial
03:24:06 <ertesx> and assuming a good 'sum'
03:24:08 <dredozubov_> but it can be done
03:24:21 <hpc> (the sum in Prelude is not a good one either, iirc)
03:24:53 <tdammers> dredozubov_: "trivial" might not be the right word
03:24:56 <ReaTb> Sorry for my ignorance.. but isn't sum quite a simple operation, how can you do it better?
03:25:15 <ertesx> ReaTb: you'd think, yeah =)
03:25:23 <tdammers> depends what it is you're summing
03:25:24 <ertesx> bad implementation:  foldl (+) 0
03:25:29 <ertesx> good implementation:  foldl' (+) 0
03:25:36 <hpc> ReaTb: because haskell is lazy, there's a way to write it that uses constant space instead of keeping the whole list in memory
03:25:37 <tdammers> oh, that too, yes
03:25:52 <ReaTb> I'm still a junior really, and Haskell is the language we use at work.. maybe that's a bad combination :p
03:25:56 <tdammers> but also, when it comes to floating-point numbers, precision can be a problem
03:26:26 <hpc> ReaTb: that's a combination i bet 90% of this channel is jealous of
03:26:27 <ertesx> ReaTb: haskell is a good language, but some aspects of it need getting used to‚Ä¶  in particular laziness
03:26:38 <tdammers> so a better sum implementation for floats would first sort the list and *then* add them, smallest first
03:26:43 <ertesx> especially if you have experience in other languages
03:26:44 <ReaTb> Probably somewhat biased, eh!
03:27:08 <tdammers> also, once you're comfortable with Haskell, most other languages will feel dirty and limited
03:27:11 <hpc> tdammers: lol, i hadn't even thought about that one
03:27:12 <ReaTb> I was intermediate in C# before starting on Haskell
03:27:17 <ReaTb> I'm about 6 months in to Haskell
03:27:30 <tdammers> C# is not a bad starting point
03:27:52 <ReaTb> Tell me about it.. Using Haskell along side Javascript
03:27:56 <ReaTb> complete opposites
03:28:09 <ertesx> ReaTb: i'd prefer to compile haskell to javascript =)
03:28:11 <hpc> ReaTb: to some extent, the reason ghc's memory model isn't very easy to grasp is that haskell does such a great job of making you not care at all about it
03:28:16 <tdammers> nah, JS isn't the opposite
03:28:18 <tdammers> PHP is
03:28:19 <dredozubov_> you just have to compile haskell to js, hehe
03:28:26 <tdammers> dredozubov_: ghcjs much?
03:28:36 <ertesx> tdammers: i'd argue that there is little difference between JS and PHP
03:28:41 <dredozubov_> tdammers: tbh i tried to use it and it was a minefield
03:28:51 <dredozubov_> but i like the idea very much
03:28:51 <hpc> ReaTb: so you don't have an easy entry point like pointer equality or the call stack
03:29:06 <ertesx> except that each time i have to prefix a variable name by "$", i can feel a brain cell of mine die
03:29:09 <tdammers> ertesx: js has useful first-class functions, saner scopes, actual closures
03:29:09 <dredozubov_> currently trying to convert our frontend dev to purescript
03:29:24 <ertesx> tdammers: PHP has all of those
03:29:25 <dredozubov_> it has a copypaste-level integration with haskell
03:29:29 <dredozubov_> (not really)
03:29:36 <tdammers> ertesx: yes, but in PHP they're all broken
03:29:42 <hpc> js and php are broken in entirely different ways
03:29:56 <tdammers> ^ this
03:29:59 <ent-> do people here have experience with elm? is that nice to use with haskell?
03:30:08 <tdammers> and php's breakage is far far worse
03:30:13 <dredozubov_> they're weakly typed, so i'd say they're broken in the same place at least once
03:30:18 <ertesx> tdammers: they are both broken, often in very similar ways, at other times in very diffferent ways (stuff like 'this', the entire lack of types in JS, etc.)
03:30:23 <bernalex> ent: what do you mean by "with haskell"?
03:30:28 <hpc> you see, while javascript is only broken at the syntax and library levels
03:30:36 <hpc> php meanwhile is broken at the syntax and library levels
03:30:50 <dredozubov_> ent: i'd go with purescript, but i think it's far better choice than pure js anyway :)
03:30:57 <tdammers> php is broken at the culture level
03:31:01 <ertesx> i don't think when comparing JS and PHP, you can really mark a winner
03:31:08 <ReaTb> hpc: There's usually multiple ways to achieve whatever it is I'm trying to do, and it's hard for me to decide on one because I worry that one way is better than the other, and my lack of indepth knowledge means I don't really know how to even determine which is better
03:31:08 <ent> bernalex: can you share data types between them for example
03:31:12 <bernalex> tdammers: eh js is *very* broken at the culture level. different type of breakage tho.
03:31:29 <hpc> ReaTb: ultimately the best way is the one you know how to do ;)
03:31:30 <ent> hmm, purescript seems interesting
03:31:37 <bernalex> ent: OK I haven't done this. if you need to do that I would suggest ghcjs.
03:31:38 <ertesx> ReaTb: flip a coin‚Ä¶  literally‚Ä¶  there is nothing wrong with knowing how to implement bad solutions =)
03:31:42 <tdammers> bernalex: js culture isn't anywhere near the level of dysfunctional that the php community exposes
03:31:55 <bernalex> ent: as a language, purescript is much nicer than elm imo.
03:32:02 <dredozubov_> ent: i'd say it's more flexible and modern than elm
03:32:27 <bernalex> elm doesn't have ad-hoc polymorphism or higher kinded ranks. enough said.
03:32:31 <tdammers> ent: my experience with Elm, in a nutshell: promising ideas, very good first impression, but ultimately disappointing and somewhat condescending
03:32:33 <ReaTb> But I do know that foldl is evil, so I've got that going for me, which is nice
03:32:39 <ertesx> tdammers: (i'd refrain from talking about people when comparing technologies‚Ä¶  it achieves nothing and only gets you hate)
03:32:45 <ent> condescending? O_o
03:33:15 <ertesx> ReaTb: foldl is not necessarily evil, but it's the wrong choice 99% of the time
03:33:22 <tdammers> ent: yes. the lack of proper typeclasses is an example of that
03:33:26 <ertesx> i think 'last' is the only example i know where foldl is more appropriate
03:33:31 <bernalex> tdammers: s/proper//
03:33:38 <ent> lack of typeclasses does sound a bit weird
03:33:55 <tdammers> bernalex: yeah, well, it has two or three built-in things that are practically typeclasses, but you can't add your own
03:34:01 <tdammers> or implement them
03:34:07 <hpc> foldl has one minor advantage over foldl' which is that if you pass it a sufficiently lazy function plus a list with bottom in it, foldl might yield a result while foldl' errors out
03:34:15 <dredozubov_> you can do ML-like modules w/o typeclasses, but elm doesn't do that too
03:34:22 <ertesx> :t foldl (const Just) Nothing
03:34:24 <lambdabot> Foldable t => t a -> Maybe a
03:34:26 <tdammers> so anyway, the reason there are no typeclasses is not because the authors found it too hard to implement, or didn't have the resources to do it
03:34:36 <bernalex> like I said, the lack of ad-hoc polymorphism is the problem. not the lack of typeclasses specifically.
03:34:47 <tdammers> it's because they think that typeclasses are too difficult a concept to learn for the users of their language
03:34:53 <hpc> this doesn't happen very often though, usually when you have an opportunity to take advantage of laziness you're doing a right fold anyway
03:35:09 <dredozubov_> tdammers: that's basically calling them all stupid
03:35:12 <bernalex> yes, elm is optimising for the first two weeks of the learning curve. which I don't think is a good way to design a programming language.
03:35:21 <tdammers> dredozubov_: in nicer words, but yes
03:35:29 <hpc> it's a good way to design a popular programming language :(
03:35:36 <dredozubov_> marketing-wise it's very good
03:35:38 <tdammers> *cough*python*cough*
03:35:50 <dredozubov_> so i'd say it's a good thing as a gateway drug
03:36:06 <bernalex> hpc: I guess I should have said that I don't think it results in a language that is very pleasant to use.
03:36:06 <ertesx> bernalex: many modern technologies do that
03:36:14 <tdammers> another thing that bothers me with elm is that it's a fast-moving target, but in a bad way
03:36:23 <hpc> sometimes i wish larry wall had given in to the masses of derpy webdevs and just shipped DBI with perl
03:36:27 <hpc> maybe then php wouldn't exist
03:36:30 <tdammers> elm code I wrote three months ago will no longer build
03:36:39 <tdammers> even though all I did was a clean checkout
03:36:55 <bernalex> tdammers: well it will build using the same compiler, so I don't think that's such a big problem.
03:37:29 <ertesx> sex sells‚Ä¶  and by sex of course i mean single-page-scrolling web "sites" that tell you how great the advertised technology is
03:37:32 <dredozubov_> bernalex: you'll get very similar issues with any fast-pacing compiler development
03:37:38 <dredozubov_> purescript won't be an exception
03:38:06 <tdammers> with haskell at least we finally have stack that takes care of these things with a rather brute approach
03:38:07 <bernalex> yeah. many times, sadly, regular js is just more viable.
03:38:17 <ertesx> usually when i see a "sexy" web page like that, i take a step back‚Ä¶  it's clear sign of overblown marketing
03:38:55 <dredozubov_> tdammers: they're some limited support to js infrastructure in nix nowadays iirc
03:39:00 <ReaTb> If you a list that's ~ 100-200 long, but consists of elements out of a set of say 5 possible things... if you want the original set back, is it better to convert to a hashset then back to a list, or use some kind of nub (I don't have the Ord instance to use nubBy)
03:39:04 <bernalex> although idk why I'm sitting here moping about js. I don't have to use js. :D better get back to work.
03:39:05 <hpc> the best part is the js framework that does that style of site is bootstrap
03:39:11 <hpc> which is itself a horrendous technology
03:39:17 <bernalex> oh wait, my work is in a language I dislike even more than js. >:(
03:40:01 <bernalex> hpc: I really "like" websites that don't load anything at all if you block javascript. i.e. it's just a blank page. "ok, guess they don't want me to read about their stuff then."
03:40:41 <dredozubov_> ertesx: marketing isn't bad conceptually, but the inability of tech guys to compare technologies adequately is depressing
03:40:50 <hpc> bernalex: i like knowing i can ignore those sites
03:41:09 <dredozubov_> of all people, i expect technical people to show some good judgement
03:41:15 <ertesx> ReaTb: if you use a good 'nub', it's going to be in terms of Set or HashSet anyway
03:41:35 <ertesx> ReaTb: so yes, just go through a Set/HashSet
03:43:26 <ertesx> dredozubov_: PHP is still one of the most popular languages‚Ä¶  and JS is slowly taking it over, while at the same time HashMap Text Dynam‚Ä¶  err‚Ä¶  python conquers our desktops
03:43:48 <ertesx> dredozubov_: all of that makes me wonder how you came to that thought
03:43:59 <dredozubov_> ertesx: i was a victim of a tech marketing myself :<
03:44:34 <dredozubov_> do you mean that the tech guys should show some judgement?
03:44:42 <ReaTb> cool, cheers ertesx 
03:44:46 <dredozubov_> idk
03:46:11 <ertesx> dredozubov_: i mean that tech people are still people, and judgement is more often than not biased, onesided and belief-driven
03:46:46 <ertesx> python can be summarised as HashMap Text Dynamic‚Ä¶  yet people praise it like it some kind of black magic
03:47:05 <dredozubov_> python tooling is out of this world
03:47:22 <dredozubov_> even js infrastructure looks ultra high-tech comparing to that
03:48:12 <dredozubov_> you can't even install a library without some crutches
03:48:31 <dredozubov_> i don't even
03:50:41 <ertesx> i mean:  the only judgements you can trust are the ones of logic‚Ä¶  tech people are not very trustworthy (and we haskellers aren't exactly innocent ourselves)
03:51:25 <ertesx> like everybody else we are highly biased
03:52:20 <dredozubov_> yeah, sure
03:52:37 <dredozubov_> it'd ridicuous how irrational people are
03:52:59 <Xandaros> Python gets really fin when you try to use python 2 and 3 at the same time
03:53:11 <dredozubov_> read an interesting book by Dan Ariely recently
03:53:35 <dredozubov_> it's compilation of tales of irrationality research
03:54:09 <dredozubov_> Xandaros: i don't know how they managed to screw the 2-3 transition this badly
03:54:21 <dredozubov_> it's beyond ridiculous
03:55:21 <ertesx> dredozubov_: bias doesn't have to be irrational though‚Ä¶  often bias is the consequence of experience, and often people build their bias on the experiences of others
03:55:32 <ertesx> it's natural to do that
03:55:59 <ertesx> why did i write my first web site in PHP?  because it worked for a friend of mine
03:58:25 <dredozubov_> It is irrational in some ways, but people use subconscious heuristics to make some fast decisions. It helps to save your life in a car accident and it will help you to choose your first programming languages.
03:58:51 <dredozubov_> you can't go for the phd in CS to make a first PL choice, so you go with a simple choice
03:59:23 <Xandaros> When I made my first website, PHP was the de-facto standard. It didn't even cross my mind that other options could exist
04:00:14 <dredozubov_> s/languages/language/
04:02:40 <Xandaros> Some actual Haskell talk: How do I do proper cross-linking in my hackage docs, when building docs manually? Currently, it... well... tries to find it in _my_ package... See the links to ‚ÄòParser‚Äô here: https://hackage.haskell.org/package/abnf-0.1.0.0/docs/Text-ABNF-Document.html
04:04:12 <nkaretnikov> i'm trying to patch HList, but the typechecker gives me an error about kind mismatch.  why does it complain?  https://gist.github.com/nkaretnikov/166000f2346a255fe0a66f770715a61f
04:05:07 <nkaretnikov> why can't t be of kind [*] as it's currently defined?
04:06:49 <ertesx> nkaretnikov:
04:06:51 <ertesx> :k (->)
04:06:53 <lambdabot> * -> * -> *
04:07:10 <ertesx> a function argument can't be of kind [*]
04:07:35 <ertesx> in particular types of kind [*] are uninhabitated
04:09:02 <nkaretnikov> ertesx: so the only way to mimic the current definition (as defined in the library) is to use data families, right?
04:09:24 <ertesx> what are you trying to do?
04:09:32 <nkaretnikov> ertesx: similar to how HList moved from aempty data decls to a data family
04:09:39 <nkaretnikov> ertesx: one sec
04:09:46 <ertesx> i'm not too familiar with HList
04:12:15 <nkaretnikov> ertesx: i'm trying to revive OOHaskell, which requires the RecordAdv module, which is currently broken in HList.  i somehow managed to patch bits of it, but i still need the definitions of nilLub and consLub for OOHaskell, hence my question.  my HList code is here: https://github.com/nkaretnikov/HList/commits/recordadv
04:13:55 <nkaretnikov> ertesx: the problem is that aavogt started rewriting HList, but that work is not complete
04:14:43 <nkaretnikov> ertesx: ah, and i can't just uncomment the consLub code because of LubNarrow, which also works with [*]
04:14:56 <shirt> i have a problem with cabal new-build --enable-profiling --enable-library-profiling. It started building all of the dependencies, and built most of them. but then it failed on bifunctors-5.3. In the log it says "Perhaps you haven't installed the profiling libraries for package ëcomonad-5@comon_BPwjoCtOoUPAMJakPkbNa0í?" But I see that it did in fact build that library just now
04:15:16 <shirt> (when i previously did "cabal new-build" without profiling, everything worked)
04:15:27 <ysny> hi guys 
04:15:54 <nkaretnikov> ertesx: i was trying to work around that by sticking (a ': '[]) whenever [*] is required, but hit the mentioned typeclass kind mismatch issue
04:16:22 <ysny> I'm need to do some serial port communication, does anyone know of any relevant libraries and some example code?
04:16:44 <ysny> specifically binary protocol related stuff, is haskell up to the task? 
04:17:02 <Xandaros> ysny: I just looked on hackage and found serial and serialport. Maybe those will work?
04:17:47 <ysny> they probably will but I was wondering if there is some example code that does that in a "haskelly" way 
04:18:40 <Xandaros> That depends entirely on your definition of ‚Äúhaskelly‚Äù :P
04:19:17 <ysny> also i have a very high data rate, and hoping if someone did it before and could warn if it's perhaps not the right tool for the job 
04:19:22 <Xandaros> It's IO, so you probably won't get around doing most everything related to the actual communication in IO
04:20:01 <ysny> well I'm mostly starting out with haskell, and looking for more "idiomatic" implementations 
04:20:56 <tdammers> separate the I/O stuff from the logic, write the logic in a pure fashion, do the I/O stuff in IO
04:21:48 <ertesx> nkaretnikov: if you could explain it with less references, it's more likely that we/i can help‚Ä¶  i'd prefer not to read up on OOHaskell (wasn't it O'Haskell?) and HList just to answer that =)
04:22:16 <nkaretnikov> ertesx: reading on OOHaskell is not required, okay, gimme a sec
04:22:54 <oherrala> ysny: just start hacking something and then ask for comments to improve your code :)
04:23:18 <ertesx> ysny: haskell can handle both binary and fast throughput very well, often close to C‚Ä¶  in particular when going through a serial port, haskell is extremely unlikely to be your bottleneck
04:24:28 <nkaretnikov> ertesx: basically, my goal is to expose nilLub and consLub while changing as little as possible.  (i read the relevant papers but still don't understand all the details.)  i don't really care how it's done as long i have the said definitions and don't miss any functionality
04:24:54 <nkaretnikov> ertesx: if you just clone my branch, uncomment the existing definitions, and try building, it won't work
04:25:07 <nkaretnikov> ertesx: that's probably it, not sure how to word it better
04:25:40 <nkaretnikov> ertesx: i guess i need to re-read on narrowing in the hlist paper and on [*] in the ghc manual
04:25:41 <Xandaros> ertesx: It's interesting how many people underestimate the speed of Haskell - some even claiming python is faster... How did this myth start?
04:26:02 <nkaretnikov> ertesx: i was just hoping that someone finds a quick solution for me :)
04:26:04 <ertesx> Xandaros: it started in the days when it was true
04:26:28 <tdammers> if anything, compare the speed of GHC against CPython
04:26:42 <cocreature> Xandaros: I think a lot of it is related to the fact that a lot of people don‚Äôt know how haskell code is executed so they assume that it‚Äôs magic and magic has to be slow
04:26:49 <tdammers> but even then, it's hard to write "equivalent" code between two languages that are so dissimilar
04:26:52 <ertesx> Xandaros: the code GHC produces today is leaps and bounds ahead of the code it used to generate 6-7 years ago
04:26:52 <nkaretnikov> ertesx: (going afk for a bit, but i'll read the backlog)
04:27:35 <ertesx> nkaretnikov: sorry, i can't answer it, because it's still reference-heavy‚Ä¶  if you could just explain what consLub and nilLub are, it would become more likely
04:27:47 <tdammers> in my experience the thing with haskell performance is that it's normally in the 'pretty damn fast' league, but there are cases when things are unexpectedly slowm usually due to excessive laziness
04:28:07 <tdammers> which can be fixed, but the cause of the slowness isn't always obvious
04:28:29 <ertesx> tdammers: the cause is often not your own code
04:28:47 <Xandaros> Well, that's when you do profiling. Which reminds me - I need to profile my library at some point :P
04:28:49 <tdammers> ertesx: but it's not usually the compiler or runtime either
04:30:15 <ertesx> today most popular libraries are written with efficiency in mind, but i'm super-cautious when introducing a dependency i don't know:  i check its data types first
04:30:34 <ertesx> 90% of neural networks (and there are quite a few) on hackage are still implemented with lists of lists
04:31:04 <merijn> ertesx: Even 6-7 years ago haskell was way faster than 90% of haskell
04:31:20 <merijn> ertesx: tbh, I don't think I'd implement a neural network in haskell anyway
04:31:30 <MasseR> merijn: haskell was faster than haskell?
04:31:37 <merijn> MasseR: Eh...python
04:31:39 <ertesx> merijn: i would‚Ä¶  haskell is great for ANNs, but lists aren't
04:31:56 <merijn> ertesx: Neural networks I'd probably do on GPU
04:32:12 <ertesx> merijn: there is 'accelerate'
04:32:32 <ertesx> vector-like interface, but computed on your GPU =)
04:32:38 <merijn> ertesx: Which isn't that useful for really squeezing everything out of your GPU :)
04:32:52 <merijn> One of these days I'll implement nice CUDA bindings for Haskell
04:33:14 <ertesx> it's fine for vector operations‚Ä¶  you don't get 100% of the GPU, but you get 90%
04:33:36 <merijn> I'm a bit worried about potential GC/overhead inside the bindings, though
04:33:54 <merijn> (The main reason why I didn't implement them yet)
04:34:06 <ertesx> that overhead could occur during compilation of the GPU code, but not during run-time
04:34:22 <ertesx> you just have to make sure they are truly separate
04:34:43 <merijn> ertesx: No, I mean GC pauses in the host code introducing jitter in my kernel measurements
04:35:06 <ertesx> ah‚Ä¶  you may take some inspiration from how criterion does it
04:35:12 <merijn> ertesx: I'm benchmarking GPU kernels atm, and I'm worried if I write the host code in haskell I might get jitter due to GC/etc.
04:35:26 <merijn> ertesx: So for now my host code is C++, but that's sucky for writing boilerplate >.>
04:35:43 <ertesx> merijn: you could disable GC for benchmarking
04:36:02 <merijn> ertesx: But writing C++ was easier then spending time to investigate the impact of GC/etc. and how to avoid it :)
04:36:46 <ertesx> but i doubt that it will make a huge difference, if you don't do any heavy computations intermixed with lots of IO *before* the benchmark
04:37:00 <merijn> ertesx: Sure, I doubt it too :)
04:37:27 <merijn> ertesx: But investing 2 months to write nice bindings only to find out that it DOES is not an effective use of my time :)
04:37:36 <ertesx> in fact i'd probably just use criterion =)
04:38:01 <ertesx> merijn: yeah, i can understand that =)
04:40:49 <dcoutts> shirt: can you report a ticket, and if at all possible try and make the case reproducible
04:41:22 <ertesx> i'd be happy if OpenCL would become more popular‚Ä¶  not that it sucks any less than CUDA, but at least it's an open standard
04:41:36 <ertesx> and not limited to nVIDIA
04:41:38 <merijn> "not that it sucks any less than CUDA"? <- huh
04:41:43 <merijn> CUDA is actually pretty awesome
04:41:55 <merijn> OpenCL is not even a serious potential competitor
04:42:31 <merijn> It's not going to become more popular, because no one who actually writes GPU code even thinks about OpenCL
04:42:50 <merijn> Not to mention that non-nVidia cards are pretty much no go for GPGPU anyway
04:43:08 <shirt> dcoutts: yeah, i'll try. thanks
04:43:28 <ertesx> merijn: if you use the inline C++ syntax that nVIDIA has developed, then it's fine to some extent
04:43:52 <merijn> ertesx: I don't, actually. And CUDA is still orders of magnitude better
04:43:59 <dcoutts> shirt: and label the ticket with the "nix-local-build" tag. If you can make something I can reproduce there's a good chance I can fix it quickly.
04:44:14 <merijn> ertesx: If you're curious I can tell you why, but better off moving that to -blah :)
04:44:15 <ertesx> merijn: AMD cards give you a huge speedup compared to CPU code for many vector algorithms, and they obviously don't support CUDA
04:44:24 <dcoutts> shirt: thanks for helping!
04:44:28 <ertesx> merijn: i'm curious, but not today =)
04:45:04 <merijn> ertesx: Oh, actually I already wrote that: https://news.ycombinator.com/item?id=11829210
04:45:22 <merijn> ertesx: AMD atomics are 2 or more orders of magnitude slower than NVidia under contention
04:46:12 <ertesx> merijn: i'll just believe that, but it's still orders of magnitude faster than CPU
04:47:11 <ertesx> let me just say that OpenCL sucks‚Ä¶  i'm willing to believe that CUDA is way better than OpenCL, but it's still not the idiom i want to write algorithmic code in
04:47:29 <nkaretnikov> ertesx: no worries, i'll try to figure on my own :)
04:48:26 <merijn> ertesx: sure :)
04:48:48 <ertesx> merijn: one thing you can do with OpenCL is to write cross-hardware parallel code in haskell =)
04:49:00 <ertesx> but then of course 'accelerate' is cross-technology, so it doesn't matter too much
05:02:14 <Ashy> [A
05:02:15 <Ashy> [A
05:02:25 <Ashy> oops
05:03:04 <ggVGc> nice one
05:05:20 <Ashy> was trying to up arrow /window move left a few times
05:25:43 <Xandaros> I still haven't gotten an answer about the docs thing, btw: How do I do proper cross-linking in my hackage docs, when building docs manually? Currently, it... well... tries to find it in _my_ package... See the links to ‚ÄòParser‚Äô here: https://hackage.haskell.org/package/abnf-0.1.0.0/docs/Text-ABNF-Document.html
05:36:36 <fr33domlover> Xandaros, when you build the docs with stack, I think it does the cross linking. IIRC it happens you tell haddock where the packages are and then it finds linked symbols and creates links
05:37:04 <fr33domlover> But I never tried myself, I just use `stack haddock` which builds the docs for all the packages and cross-links them
05:37:12 <Xandaros> ‚Ä¶
05:37:15 <Xandaros> I don't use stack
05:37:41 <nkaretnikov> ertesx: do you know why (->) doesn't have kind forall k. k -> k -> k?
05:37:48 <Xandaros> I did make links, that's not the issue. They're just wrong :D
05:37:51 <Xandaros> *It
05:38:06 <fr33domlover> When I learned about Haddock I remember there were examples for how to do it. Maybe in the Haskell wiki, I don't remember
05:38:19 <fr33domlover> Xandaros, maybe the base path you passed is wrong?
05:38:26 <Xandaros> nkaretnikov: Because that would require you to have values of a type with a kind other than *. (Wow, that sentence)
05:38:39 <fr33domlover> e.g. when you generate for Hackage you pass a base path http://hackage.haskell.org/... etc.
05:38:43 <ertesx> nkaretnikov: because only concrete types (*) can have values for a function to consume
05:39:19 <Xandaros> fr33domlover: I found many references, but they all didn't seem to work. Maybe they do, I'm not sure. Initially, there were no links and they now appeared
05:39:56 <Xandaros> Meh, I'll let hackage build the docs. Hoping it will eventually get to it - I see some packages still have ‚Äòpending‚Äô status after months :/
05:40:00 <fr33domlover> Xandaros, another option you could try is see how `stack haddock` works in stack's source code :P
05:40:11 <ertesx> nkaretnikov: the only function of type A -> B you could write, where A is of a non-concrete kind, is the empty function
05:40:12 <nkaretnikov> Xandaros, ertesx: ah, i guess i could use Proxy to make it work :)
05:40:36 <fr33domlover> Xandaros, https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
05:40:36 <Xandaros> nkaretnikov: probably
05:40:45 <fr33domlover> I was given that link recently
05:40:51 <fr33domlover> Didn't have a chance to try yet
05:40:52 <nkaretnikov> i always forget about proxy
05:41:07 <Xandaros> fr33domlover: That's exactly what I used :P
05:41:25 <Xandaros> Well, I didn't execute the script, but I did it manually
05:41:49 <ertesx> nkaretnikov: you use Proxy when there is no other way to communicate a type, because haskell still doesn't allow us to pass types explicitly
05:41:57 <ertesx> i think even -XTypeInType doesn't change that
05:42:24 <Xandaros> No, it doesn't
05:42:39 <Xandaros> TypeInType just says that kind=type
05:42:53 <ertesx> Xandaros: it also enables a bunch of new features
05:43:01 <ertesx> but passing types is not among them
05:43:17 <Xandaros> It will be possible eventually, I think
05:43:29 <Xandaros> but it'll take a ‚Äòwhile‚Äô
05:43:46 <ertesx> that eventuality will likely be the day when -XDependentTypes is finally there
05:44:06 <ertesx> we'll probably have to wait until GHC 9 or 10 for it
05:45:07 <Xandaros> fr33domlover: I just tried executing the script itself. Let's wait and see what happens :D
05:51:53 <Xandaros> fr33domlover: Nope, same issue
05:57:48 <fr33domlover> Xandaros, :-/
06:16:04 <statusfailed> How do I load the test executable modules in a stack project?
06:17:56 <statusfailed> I mean load them in the repl - `stack repl` only gives me the library modules, and using :l test/Test.hs complains about missing dependencies
06:23:34 * hackagebot funnyprint 0.0.3 - funnyPrint function to colorize GHCi output.  https://hackage.haskell.org/package/funnyprint-0.0.3 (netsu)
06:26:46 <Maerten> Hi, does anyone know how to automatically add indexes on Database.Persist entity fields?
06:33:34 * hackagebot arbtt 0.9.0.9 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.9 (JoachimBreitner)
06:39:24 <sm> statusfailed: stack test test:NAME or something
06:39:34 <sm> I mean, stack ghci test:NAME
06:41:24 <iphy> why is Foreign.Storable marked Trustworthy? I thought Safe Haskell was supposed to avoid the use of unsafe interfaces that can break type safety?
06:42:27 <quchen> statusfailed: Also try "packagename:testName" if sm's answer doesn't work
06:42:35 <quchen> This is quite poorly documented in Stack, unfortunately
06:42:35 <ertesx> iphy: not sure, but i don't think pointers leak from it
06:43:27 <merijn> iphy: Trustworthy means "this package promises not to break Safe Haskell guarantees"
06:43:35 * hackagebot jose 0.4.0.2 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.4.0.2 (frasertweedale)
06:44:11 <merijn> iphy: Of course, if you don't trust the package there's no point in believing it
06:44:33 <ertesx> iphy: i think, Foreign.Storable by itself should be safe‚Ä¶  Foreign.Ptr and Foreign.Marshal would be a different story
06:44:44 <ertesx> > nullPtr
06:44:46 <lambdabot>  Not in scope: ‚ÄònullPtr‚Äô
06:44:52 <ertesx> > Foreign.Ptr.nullPtr
06:44:54 <lambdabot>  Not in scope: ‚ÄòForeign.Ptr.nullPtr‚Äô
06:45:03 <iphy> ertesx: right, those are Unsafe
06:45:42 <iphy> ertesx: actually Foreign.Ptr is Trustworthy
06:45:47 <iphy> Marshal is unsafe
06:45:51 <ertesx> @let import Foreign.Ptr
06:45:53 <lambdabot>  Defined.
06:45:55 <ertesx> oh!
06:46:11 <ertesx> > peek (nullPtr :: Ptr Word)
06:46:12 <lambdabot>  Not in scope: ‚Äòpeek‚Äô
06:46:18 <ertesx> @let import Foreign.Storable
06:46:20 <lambdabot>  Defined.
06:46:21 <ertesx> > peek (nullPtr :: Ptr Word)
06:46:22 <iphy> > castPtr 3 :: String
06:46:23 <lambdabot>  <IO Word>
06:46:24 <lambdabot>      Couldn't match type ‚ÄòPtr b0‚Äô with ‚Äò[Char]‚Äô
06:46:24 <lambdabot>      Expected type: String
06:46:24 <lambdabot>        Actual type: Ptr b0
06:46:30 <ertesx> ah, it's still IO
06:46:34 <ertesx> phew!
06:46:41 <LiaoTao> For beginning to learn Haskell, is it recommended to go through both "Learn you a haskell" and "Real world haskell"?
06:46:48 <LiaoTao> Are there any other must-read resources?
06:47:03 <iphy> ah
06:47:16 <iphy> right, reading a pointer is IO
06:47:20 <ertesx> LiaoTao: i think these days LYAH is no longer a recommended resource
06:47:39 <LiaoTao> I see
06:47:55 <LiaoTao> What would then be a fair substitute?
06:48:04 <ertesx> LiaoTao: i think, people like this one:  https://github.com/bitemyapp/learnhaskell
06:48:09 <ph88> is it possible to put a shebang in a file and run haskell as script ?
06:48:23 <LiaoTao> ertesx, Thanks, I'll check it out
06:48:24 <ertesx> ph88: unfortunately no
06:48:29 <ph88> :(
06:48:40 <ph88> stack run   comes close
06:48:41 <ertesx> ph88: well, there is literate haskell
06:48:46 <sm> yes it is, see standalone script in the stack user guide
06:49:12 <iphy> what about runhaskell?
06:49:13 <ertesx> lhs is the only portable way
06:49:25 <iphy> ah portable
06:49:28 <ertesx> i.e. the one that doesn't require stack
06:49:50 <sm> runhaskell works fine, but doesn't install dependencies like stack
06:50:10 <ertesx> does it?
06:50:24 <sm> yes?
06:50:35 <ertesx> does it just ignore the hashbang, if it finds one?
06:51:33 <ertesx> in any case i'd prefer compilation
06:51:48 <sm> yes it does
06:51:58 <sm> ph88: http://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter is what I meant
06:53:35 * hackagebot funnyprint 0.0.4 - funnyPrint function to colorize GHCi output.  https://hackage.haskell.org/package/funnyprint-0.0.4 (netsu)
06:54:42 <Xandaros> LiaoTao: I saw this on reddit earlier: https://leanpub.com/happylearnhaskelltutorialvol1 - I haven't looked at it yet, so maybe you could look at it and give some feedback? :D
06:55:00 <LiaoTao> Xandaros, Sure, thanks
06:56:55 <Xandaros> LiaoTao: Looking at the comments, it seems to be targetted at people without any programming experience, though. Don't know if you fit that description
06:58:36 <makalu> I have multiple items in the 'packages' list of stack.yaml. Two of them have a module named Utils. stack repl will not start because there are two modules with the same name (although neither one is exported). Is there any workaround besides renaming the modules?
06:59:21 <makalu> basically, I have local libraries that are not in stackage, that's why I have multiple packages
07:00:11 <LiaoTao> Xandaros, I've got a few years with imperative languages. I'll check it out anyway
07:00:17 <bergmark> makalu: pass arguments, e.g. `stack ghci package-a'
07:01:04 <makalu> bergmark: thank you that works. I wonder if I could get it to work with intero as well.
07:03:35 * hackagebot funnyprint 0.0.5 - funnyPrint function to colorize GHCi output.  https://hackage.haskell.org/package/funnyprint-0.0.5 (netsu)
07:03:37 <ph88> hey guys, i would like to capture whitespace while parsing because i want to be able to reconstruct the original file .. any pointers ?
07:04:29 <EvanR> reversible parsing, interesting
07:10:47 <LiaoTao> Uh, how do I read definitions from .hs files into GHCI?
07:12:20 <Berra> LiaoTao: ghci -i file.hs
07:12:37 <Xandaros> Or, once you have ghci open: :l file.hs
07:12:43 <LiaoTao> Thanks
07:12:48 <Xandaros> (short for :load)
07:14:30 <Xandaros> LiaoTao: You can also quickly reload the file with :r. Probably handy to know :)
07:14:40 <LiaoTao> Very
07:14:43 <LiaoTao> Thanks a lot
07:18:36 * hackagebot abnf 0.2.0.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.2.0.0 (Xandaros)
07:19:04 <hexagoxel> ph88: ghc-exactprint.
07:19:32 <arianvp> ph88: you pinged me yesterday
07:19:36 <arianvp> waddup?
07:19:36 <ph88> hexagoxel, what's that gonna do ?
07:19:45 <arianvp> in PM
07:19:55 <ph88> ok
07:20:01 <ertesx> LiaoTao: and :r to reload
07:21:07 <hexagoxel> ph88: parse in a way that allows reproducing the exact input, including whitespace.
07:21:50 <ph88> hexagoxel, title/description doesnt really indicate that this library does parsing ^^
07:21:52 <Xandaros> fr33domlover: Just uploaded a new version of my package and cross linking works fine now. It was probably just a matter of deleting dist
07:22:18 <ph88> hexagoxel, also i'm not manipulating haskell source files ^^
07:23:38 <ertesx> ph88: to reproduce the source text exactly, you need to include source annotations in your AST
07:23:50 <ph88> what are source annotations ?
07:24:14 <ertesx> an extra field that specifies spacing and perhaps other things (like number formats, etc.)
07:24:44 <ph88> specify spacings = store the whitespace as String ?
07:24:52 <ertesx> data MyAst = ... | MyElem ElemInfo SourceInfo | ...  -- where SourceInfo includes stuff like spacing
07:25:54 <mizu_no_oto_work> ph88: could be a String, but it could also be some sort of text AST. 
07:26:33 <mizu_no_oto_work> Why do you want to be able to reconstruct the original file, though?
07:26:37 <ph88> and ElemInfo can also just be a String ?
07:26:37 <hexagoxel> ph88: i start making assumptions when i see vague questions :p and you might still be able to learn something from the approach taken by -exactprint.
07:26:56 <mizu_no_oto_work> Are you trying to give nicer error messages from the parser?
07:26:57 <ph88> mizu_no_oto_work, because i want to be able to reformat parts of a file and leave other parts as they were
07:27:10 <LiaoTao> Are patterns matched in the order they are written?
07:27:14 <ertesx> ph88: you could parse only the parts that you want to reformat
07:27:20 <ertesx> LiaoTao: yeah
07:27:25 <LiaoTao> Ok, thanks
07:27:38 <ph88> ertesx, it will be configurable by the user ^^
07:27:52 <ph88> i also need positioning information
07:28:05 <ph88> if a parsing error occurs to tell on which line and which position
07:28:09 <ertesx> LiaoTao: operationally not necessarily, but semantically yes
07:28:44 <pat1234> hi all, I installed haskell using install-haskell-platform.sh on ubuntu, I'm now trying to remove it to use stack instead but can't manage to find any info on how to do, anyone?
07:28:45 <mizu_no_oto_work> ph88: you might want to just include whitespace in the AST.
07:29:03 <ph88> i could do like   data SourInfo = MkSourceInfo WhitespaceString LenthInt LinesInt PosInt
07:29:04 <EvanR> ertesx: i always thought that was a weird defect in the semantics
07:29:21 <ertesx> EvanR: why?
07:29:24 <LiaoTao> ertesx, So if (x:y:xs) is written before (x:xs), then xs is the latter is guaranteed to be a list of length 1?
07:29:35 <EvanR> when you have a set of equations for a definition, they dont usually need an order because the cases dont overlap
07:29:40 <ph88> mizu_no_oto_work, well SourceInfo is already in the AST, no?   i thought ertesx just put it like that to have some sort of grouping about the information i want to store there
07:29:41 <ertesx> LiaoTao: yes
07:29:46 <LiaoTao> Okay
07:29:48 <EvanR> but they can overlap in haskell, and then you need this rule
07:30:01 <EvanR> which diverges from the more purely mathematical case
07:30:08 <ertesx> LiaoTao: but if you make that fact explicit, then GHC can warn you, if you missed a case:  [x]
07:30:15 <EvanR> in which case the result is ambiguous
07:30:49 <ertesx> EvanR: when they don't need an order, then the order doesn't matter, and in that case most likely operationally they will all be matched at the same time
07:31:06 <ertesx> i don't think it's really a problem‚Ä¶  if the order doesn't matter, it doesn't matter
07:31:10 <EvanR> LiaoTao: wait... how does that guarantee a list of length 1
07:31:11 <LiaoTao> ertesx, I'm not sure I understand. How to I make it explicit?
07:31:11 <mizu_no_oto_work> ph88: instead of data MyAst = ... | MyElem ElemInfo SourceInfo | ..., have something like data MyAst = ... | If Cond Whitespace Then Whitespace Else | ...
07:31:14 <mizu_no_oto_work> I meant
07:31:34 <LiaoTao> EvanR, It might be the empty list, too
07:31:35 <EvanR> ertesx: but the fact that order can matter at all adds an element of operationalism to it
07:31:37 <ertesx> LiaoTao: f (x1 : x2 : xs) = ‚Ä¶; f [x] = ‚Ä¶; f [] = ‚Ä¶
07:31:42 <LiaoTao> I was imprecise
07:31:51 <LiaoTao> Or maybe not
07:31:56 <ph88> mizu_no_oto_work, you can have if else in data ??
07:32:07 <EvanR> LiaoTao: x:y:xs means a list of at least 2
07:32:07 <fr33domlover> Xandaros, cool!
07:32:10 <nomeata> Hi. What is the best practice for a Cabal test suite to test the actual executables generated? Currently, I just run them in dist/build; but this breaks with Cabal snapshots or stack.
07:32:16 <ertesx> EvanR: i don't think so‚Ä¶  in math the order matters as well‚Ä¶  think of the recursive factorial
07:32:52 <EvanR> ertesx: no, f 0 = 1, f n = n * f (n-1) for n > 0
07:33:07 <ertesx> EvanR: if the order matters, it's not a weakness of pattern-matching semantics, but a weakness in the way the function is defined‚Ä¶  and it's usually nothing to frown upon
07:33:12 <LiaoTao> EvanR, Right
07:33:18 <LiaoTao> So xs might be the empty list too
07:33:35 <fr33domlover> nomeata, idk but it's worth checking the Paths_<packagename> file etc., get the bin dir from there and try using it in place of hardcoded dist/
07:33:41 <Xandaros> LiaoTao: xs is any list. (x:xs) is a list of length >= 1. [] is the empty list. [x] is a list of length exactly 1
07:33:44 <ertesx> EvanR: also i'm not sure how to make the orders *not* matter (without solving the halting problem that is)
07:33:52 <mizu_no_oto_work> ph88: should really be more like If Predicate Whitespace Expr Whitespace Expr - If is a constructor, Then and Else are types
07:33:57 <EvanR> ertesx: it makes sense to use this to make writing algorithms easier, or more efficient. and miranda-style is like this. but its algorithms not definitions
07:34:01 <Xandaros> LiaoTao: x:[] is also a list of length exactly 1
07:34:06 <LiaoTao> Oh
07:34:09 <nomeata> fr33domlover: I believe that gives you the installed path, not the path where the binary lies during building
07:34:09 <fr33domlover> nomeata, or the equivalent build path file that stack generates, if it has any
07:34:12 <EvanR> ertesx: well you could theoretically say no overlapping allowe
07:34:24 <ph88> mizu_no_oto_work, what's the If and Predicate for ?
07:34:33 <ertesx> EvanR: and remove guards from the language
07:34:41 <mizu_no_oto_work> ph88: they're nodes in your AST
07:34:46 <Xandaros> LiaoTao: You can read x:xs as "an element x" followed by any list
07:34:50 <mizu_no_oto_work> rather If is a node in your AST
07:34:51 <EvanR> yeah the Bool tests are their own defect ;)
07:35:00 <mizu_no_oto_work> representing an if statement in your source language
07:35:07 <ph88> oh ok
07:35:13 <ertesx> EvanR: i have a thousand complaints about haskell, but order-relevance is not one of them =)
07:35:23 <dcoutts> nomeata: I'm not sure there's a good solution at the moment. I think ideally the tests ought to get told somehow where the exes are so they can try running them. perhaps simply by getting run in the context of the right $PATH
07:36:09 <fr33domlover> nomeata, dcoutts, also check how `stack exec` works exactly
07:36:16 <fr33domlover> in case it has a relevant solution
07:36:32 <dcoutts> afak, it's more or less the same as cabal run
07:36:50 <EvanR> im not complaining, im just saying that theres some disengenuity (?) to suspect disbelief and think of these as equations
07:36:56 <EvanR> suspend*
07:36:58 <dcoutts> in that they know the dist dir, but the test suites do not themselves know it.
07:37:14 <dcoutts> nomeata: of course it's possible with a custom Setup.hs since the Setup.hs gets told the dist dir
07:38:03 <EvanR> the order dependence is like... telling the computer what order to do things in
07:38:08 <ertesx> EvanR: i don't even know a proof assistant that has order irrelevance
07:38:14 <LiaoTao> Xandaros, EvanR, If I've grasped this correctly, then after having exhausted the pattern (x:y:xs), the list is either empty or contains only one element, in which case [x] and [] should be sufficient to catch all. Right?
07:38:21 <EvanR> sure proofs are algorithms
07:38:35 <EvanR> LiaoTao: no
07:38:41 <LiaoTao> Gah
07:38:42 <ertesx> EvanR: in fact you're not telling the computer‚Ä¶  it's semantics‚Ä¶  operationally most likely it will be reordered aggressively
07:38:43 <EvanR> x:y:xs could be 9 long
07:38:46 <Xandaros> LiaoTao: yes
07:38:51 <ertesx> EvanR: or not ordered at all (think of outermost constructor matches)
07:39:17 <nomeata> Ah, someone defines HASKELL_DIST_DIR
07:39:20 <nomeata> is that stack or Cabal?
07:39:38 <Xandaros> LiaoTao: I think EvanR just didn't understand the question :P
07:39:42 <EvanR> ertesx: youre telling the abstract computer what to do
07:39:57 <ertesx> EvanR: i'm doing that every time i write x + y
07:40:05 <EvanR> oh if x:y:xs doesnt match
07:40:09 <EvanR> nevermind me
07:40:23 <ertesx> LiaoTao: (_:_:_), [_] and [] are exhaustive
07:40:38 <ertesx> two or more; one; zero
07:40:47 <LiaoTao> Right on
07:40:50 <LiaoTao> Thanks everybody
07:41:01 <ertesx> LiaoTao: enable -W to let GHC tell you when you have missed a case
07:41:01 <dcoutts> nomeata: appears that stack does, which really is a bad idea, it ought to be Cabal if anything.
07:41:02 <EvanR> ertesx: heh... x + y is just an expression
07:41:11 <ertesx> EvanR: ok, print (x + y)
07:41:25 <nomeata> dcoutts: well, the idea is good, just done by the wrong guys :-)
07:41:27 <EvanR> so is that ;)
07:41:30 <dcoutts> nomeata: right
07:41:47 <nomeata> dcoutts: but it‚Äôs good enough for me, and with a fallback of "dist/" even forward compatible, in case Cabal uses the same name
07:42:00 <dcoutts> nomeata: right, hooray for not pushing fixes upstream, or fixing things where the problem actually is.
07:42:00 <Xandaros> ertesx: I only use -W for non-exhaustive pattern detection. It's great :D
07:42:14 <Xandaros> And should be a default warning if you ask me
07:42:26 <dcoutts> nomeata: but it's not enough, it will not work for the new cabal build, nor for the existing cabal sandboxes, nor for many distro scripts
07:42:28 <nomeata> true, of course
07:42:55 <nomeata> right, in Debian we have a history of patching code to use dist-ghc/ instead of dist/ in tests and the like
07:43:19 <dcoutts> nomeata: a PR to fix this upstream would be great btw :-)
07:43:32 <ertesx> LiaoTao: note that you can enable/disable flags within a GHCi session:  :set -W
07:43:36 <dcoutts> or at least a ticket
07:44:10 * nomeata creates a ticke
07:44:16 <LiaoTao> Got it
07:45:04 <ertesx> there is also hlint, but i often disagree with it =)
07:45:16 <ertesx> very often‚Ä¶
07:45:30 <nomeata> https://github.com/haskell/cabal/issues/3483
07:45:35 <dcoutts> ta
07:46:03 <ph88> what's the (dis)advantage of using records instead of  data  for nodes in AST ?
07:46:43 <ertesx> ph88: advantage: field accessors; disadvantage: partial functions when you have multiple constructors
07:46:54 <ertesx> disadvantaige: terrible derived Show instance for the most part
07:47:15 <ph88> partial functions don't work anymore ?
07:47:22 <ertesx> they do, but they are partial
07:47:36 <EvanR> they dont totally work
07:47:41 <ertesx> @let data T = A { someInt :: Int } | B
07:47:42 <Xandaros> EvanR: :D
07:47:43 <lambdabot>  Defined.
07:47:48 <ertesx> > someInt B
07:47:50 <lambdabot>  *Exception: No match in record selector someInt
07:48:05 <ertesx> ph88: ^
07:48:17 <EvanR> wow thats a great way to explain it in a way to make someone not want to use it ;)
07:48:31 <EvanR> "why would i want to use something that doesnt totally work"
07:48:42 <ertesx> hehe
07:48:42 <EvanR> (if they arent paying attention, should work)
07:48:51 <ph88> weren't records improved lately ?
07:49:26 <ertesx> ph88: this has nothing to do with records‚Ä¶  if you have multiple constructors, but only one has a certain field, no record system on the planet can make the accessor total =)
07:49:30 <Xandaros> There were a few new ghc extensions regarding records, but nothing about this
07:49:56 <EvanR> i think of records as not being a sum
07:50:05 <Xandaros> ^
07:50:26 <ertesx> ph88: generally you should either avoid multi-constructor records, or you should make sure that all constructors have all fields
07:50:27 <ironChicken> should haddock 2.16 be able to parse documentation in GADT comments?
07:50:46 <ertesx> @let data T2 = A2 { someInt2 :: Int } | B2 { someInt2 :: Int }
07:50:46 <mizu_no_oto_work> ph88: have you looked into lens?
07:50:47 <lambdabot>  Defined.
07:50:58 <ertesx> > (someInt2 (A 5), someInt2 (B 7))
07:51:00 <lambdabot>      Couldn't match expected type ‚ÄòT2‚Äô with actual type ‚ÄòT‚Äô
07:51:00 <lambdabot>      In the first argument of ‚ÄòsomeInt2‚Äô, namely ‚Äò(A 5)‚Äô
07:51:00 <lambdabot>      In the expression: someInt2 (A 5)    Couldn't match expected type ‚ÄòInteg...
07:51:12 <EvanR> ertesx: which kind of defeats the point of the constructors, you might as well put it in the record as a tag
07:51:28 <EvanR> pattern matching doesnt reveal anything special
07:51:37 <mizu_no_oto_work> ph88: one nice thing about records and lens is that you can autogenerate lenses and prisms with template haskell
07:52:05 <ertesx> > (someInt2 (A2 5), someInt2 (B2 7))  -- this program is a proof that i can be very stupid sometimes
07:52:06 <lambdabot>  (5,7)
07:52:18 <Xandaros> OH
07:52:44 <agocorona> mizu_no_oto_work:  and another advantage is that you can take a coffe while the whole stuff compiles
07:52:56 <EvanR> haha
07:52:57 <ertesx> > concat (map (\x -> replicate 2 x) "blah")  -- and this is a social experiment
07:52:59 <lambdabot>  "bbllaahh"
07:53:04 <Xandaros> Yeah... I try to avoid lens because it's such a heavy dependency
07:53:11 <Xandaros> Maybe I should look into microlens some time
07:53:28 <ph88> ertesx, ok i'm not gonna do this:  generally you should either avoid multi-constructor records, or you should make sure that all constructors have all fields
07:53:49 <mizu_no_oto_work> In terms of the time it takes for 'cabal install --dependencies-only' to run?  Or general compilations of your code?
07:53:51 <ph88> mizu_no_oto_work, i have looked into lens but never used it, so i would need practise
07:53:52 <ertesx> ph88: there is nothing wrong whatsoever with single-constructor records
07:54:10 <puregreen> Xandaros: microlens works fine but doesn't give you prisms (I'm not sure whether you need them here or not)
07:54:14 <Xandaros> ertesx: Not sure what the point of your ‚Äúsocial experiment‚Äù is, but that non-eta-contracted lambda bugs me :P
07:54:33 <ertesx> Xandaros: tempting, isn't it?
07:54:57 <Xandaros> puregreen: In my case (which is not being discussed) I need traversals, but not prisms (I think)
07:55:03 <ertesx> i'm sure quite a few people have already rewritten it in their heads
07:55:15 <ertesx> and you were thinking about (>>=) right now
07:55:35 <ertesx> I CAN CONTROL YOUR THOUGHTS
07:55:39 <puregreen> Xandaros: then ping me if you end up trying it and stumble upon any problems
07:57:34 <Xandaros> puregreen: Tell me if this is even possible with a traversal: I have something similar to an AST and I want to execute a function on particular entries. The AST is heterogeneous, so if you have a node of a particular type, you have to go down quite a bit until you arrive at something of the same type again‚Ä¶ if that makes any sense‚Ä¶
07:58:05 <puregreen> sounds like ‚Äúupon‚Äù or whatever that generic thing from lens was called
07:58:20 <puregreen> no, not upon
07:58:25 <Xandaros> ertesx: I wasn't thinking about (>>=), actually. concatMap (replicate 2) "blah"
07:58:45 <puregreen> uniplate, maybe?
07:58:46 <ertesx> Xandaros: traversals need the individual "points" to be of the same type and the traversal not to "reshape" the structure
07:58:58 <pat1234> sorry, repeating: I've installed haskell using: install-haskell-platform.sh on ubuntu, any way to uninstall it cleanly?
07:58:58 <ertesx> if that's the case, then yes, a traversal would work
07:59:15 <ertesx> for example you can traverse all the free variable names in an AST
07:59:21 <Xandaros> ertesx: Hmm, both not true, I'm afraid :(
07:59:52 <ertesx> Xandaros: (>>=) could help you there‚Ä¶  in a tree structure with a distinguished leaf constructor, (>>=) acts as leaf substitution
08:00:03 <ertesx> if not, you need generic programming, i'm afraid
08:00:17 <ertesx> or you restructure your type to be more compatible with these patterns
08:01:27 <Xandaros> The type is more or less straight out of an RFC, and I hesitate to differ too much. But, I can do without this operation, it was just an idea
08:05:26 <puregreen> > (1,2,[(3,4),(5,6)]) & template %~ (succ :: Integer -> Integer)
08:05:28 <lambdabot>  (2,3,[(4,5),(6,7)])
08:06:07 <puregreen> anyway, this seems to be more about generics than about lenses, yeah
08:06:28 <puregreen> or I'm just not familiar with that part of lens
08:06:44 <Xandaros> :t template
08:06:45 <lambdabot> (Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
08:06:46 <puregreen> but microlens doesn't provide any generics combinators
08:06:48 <ertesx> Xandaros: as a last resort, you could come up with some kind of generic traversal yourself
08:06:54 <ertesx> with the help of GADTs maybe
08:07:15 <LiaoTao> When pattern matching, does [x,y] mean to match a list with two elements?
08:07:21 <Xandaros> LiaoTao: yes
08:07:29 <ertesx> Xandaros: something like this: subst :: (forall a. Subst a -> a) -> Tree -> Tree
08:08:26 <ertesx> example:  data Tree = IntLeaf Int | TextLeaf Text;  data Subst :: * -> * where IntSubst :: Int -> Subst Int; TextSubst :: Text -> Subst Text
08:09:05 <Xandaros> ertesx: The concrete data type I'm thinking of is this: https://hackage.haskell.org/package/abnf-0.2.0.0/docs/Text-ABNF-ABNF-Types.html#t:Rule
08:09:09 <EvanR> LiaoTao: the idea is the pattern looks like the data structure it is matching
08:09:12 <Xandaros> I think I'll pass on this one :P
08:09:23 <EvanR> with variables standing for "anything here"
08:09:50 <ertesx> Xandaros: that way 'subst' captures the recursion, and the substitution function (its first argument) can concentrate on the things to substitute
08:09:59 <ertesx> that's probably what i would do
08:10:41 <ertesx> LiaoTao: [x, y] is syntactic sugar for (x : y : []), so yes, exactly two elements
08:11:04 <EvanR> LiaoTao: a really dumb command line parser could use a pattern like ["-o",outputFile]
08:11:16 <LiaoTao> Xandaros, EvanR, ertesx Thanks
08:11:28 <EvanR> it would match ["-o","foo"], ["-o","bar"], etc
08:12:27 <EvanR> its a pretty amazing linguistic thing ;)
08:13:32 <EvanR> haskell gets a lot of attention for monads, but really its killer feature is pattern matching
08:13:36 <tdammers> the amazing part is how the human brain is fooled by a tiny little bit of syntax sugar
08:13:49 <ertesx> a not quite as dumb command line parser could use simple recursion to parse options
08:14:22 <ertesx> getArgs >>= foldr (\opt rest -> dealWithOpt opt >> rest) myMain
08:15:11 <ertesx> though explicit recursion could allow multi-argument groups like "-o stuff" instead of "-ostuff"
08:15:25 <Xandaros> EvanR: Say what you will, but I think monads are amazing. (Though, to be fair, even applicatives or just plain old functors are already pretty amazing)
08:15:53 * EvanR will say monads are over hyped
08:16:01 * ertesx ditto
08:16:20 <ertesx> why is IO so great?  not because it's a monad, but because we have first-class actions
08:16:35 <ertesx> that's why exception handling can be a library of regular functions
08:16:54 <ertesx> and why loops aren't a language feature, but regular functions, too
08:18:35 <nitrix> I find monads to be the "natural conclusion" of functors and applicative, even if they weren't added in this order.
08:18:48 <Xandaros> nitrix: yup
08:19:29 <ertesx> natural yeah, but conclusion‚Ä¶  not even close =)
08:19:50 <nitrix> :P
08:20:16 <Xandaros> We have `(a -> b) -> f a -> f b` and `f (a -> b) -> f a -> f b`. The missing thing is obviously `(a -> f b) -> f a -> f b`.
08:20:25 <nitrix> The common association that we see of the IO type with monads only happens when people approach the language with misconceptions.
08:20:33 <ertesx> and (f a -> b) -> f a -> f b
08:20:35 <Xandaros> (>>=) is the other way around, but meh
08:20:56 <EvanR> the difference between "lesser" DSLs to monads is like the jump from discrete to continuous, its the full monty, you can do anything
08:20:58 <nitrix> Now, how that misconceptions is spread, I'd die to know, but luckily, it gets dismantled fairly quickly by any good learning material.
08:21:20 <EvanR> so in that sense it seems like a less specific way to make a DSL
08:21:27 <EvanR> not as well targeted, maybe
08:21:39 <ertesx> and monads aren't even that generic
08:21:48 <ertesx> neither are they very special
08:22:04 <nitrix> magic :: a -> b
08:22:18 <nitrix> There we go :D
08:22:24 <EvanR> now thats just impossible
08:22:25 <Xandaros> *unsafeCoerce
08:22:25 <EvanR> ;)
08:22:35 <ertesx> i'd call it absurd‚Ä¶
08:22:43 <Xandaros> only if a ~ Void
08:23:09 <EvanR> if only i had a Void
08:23:19 <ertesx> you do
08:23:21 <ertesx> magic ()
08:23:40 <bumpkin> is anybody here employed as a haskell programmer?
08:24:21 <nitrix> bumpkin: I'd prefer not to write Haskell profesionally.
08:24:28 <ertesx> bumpkin: quite a few people these days
08:24:42 <EvanR> cool, right-arrow.net is useful enough as is
08:24:46 <EvanR> but now theres left-arrow.net! ;)
08:25:09 <nitrix> bumpkin: Just a matter of job security. I've found my Haskell programs to require very little maintenance.
08:26:36 <padre_angolano> nitrix: you could still write haskell and introduce intentional bugs
08:26:44 <ertesx> nitrix: you can make them require more: make sure you write programs that need to respond to market changes frequently
08:27:08 <ertesx> that gets you extra points for being exceptionally quick at those responses
08:27:15 <Berra> Can someone help me understand how to get this right? When sepBy parses an occurrence that returns Nothing it simple halts and nothing beyond that will be parsed: http://lpaste.net/8999793438337531904
08:27:17 <bumpkin> nitrix, ha great answer.  Javascript is probably better for job security then
08:27:45 <nitrix> padre_angolano: It's to take with a grain of salt. Just an observation. Some companies don't have the innovative power / leadership to work on R&D stuff. I'm sure with many devs that are doing nothing and an application that works, some managers would be temptated to do cleanup.
08:27:53 <ertesx> if you care about job security, don't write programs that aren't connected to the market =)
08:28:22 <Xandaros> Berra: You're probably missing a try somewhere in pOneLineComment
08:28:39 <Xandaros> *assuming this is parsec/megaparsec
08:29:07 <bumpkin> ertesx, that's cool there are jobs out there. I'm curious to know what sort of jobs people are doing with it.  I know it seems to be used a lot in financial stuff, what else are people doing with it?  was hoping to hear from some people who write it every day
08:29:27 <bumpkin> as a job
08:29:31 <nitrix> bumpkin: My biggest project is a neural network processing 15TB of tumblr images everyday.
08:30:11 <Berra> Xandaros: It is, but pOneLineComment is basically -- many space; string "//"; many space; choice [try p1, try p2, try p3]
08:30:38 <Xandaros> Berra: Wrap `many space; string "//"` in a try and see if it fixes it
08:30:44 <EvanR> nitrix: that sounds creepy
08:30:44 <nitrix> I'm not the best Haskell programmer out there, but I can still pull out nice things. My current fun side project is 2D tiled game. If it goes well, going for 3D for the next game.
08:30:54 <bumpkin> nitrix, very cool.  Is that for some kind of research, or a commercial application?
08:31:03 <nitrix> bumpkin: Yeah, deep learning.
08:31:32 <nitrix> It has a commercial application if it shows some successes :P
08:31:55 <nitrix> I could pitch it to the company where I work and hopefully have them buy the technology.
08:32:31 <nitrix> Essentially a startup without the financial risks :P
08:33:34 <bumpkin> nitrix, doesn't sound too shabby.  so that's a project you're doing independently if I understand right?  or paid research by someone else
08:33:52 <Berra> Xandaros: That doesn't seem to help
08:34:08 <nitrix> bumpkin: Yeah on my own. It's a hit or miss, but again, the risk is non-existant.
08:34:24 <ertesx> bumpkin: i've mostly done networking and data handling professionally:  gathering data, very simple machine learning, etc.
08:34:44 <bumpkin> nitrix, yeah definitely and sounds like an interesting project too.  do you have a CS or some other degree?
08:35:02 <nitrix> bumpkin: I dropped early in high school.
08:35:03 <bumpkin> ertesx, for what kinds of companies/organizations if you don't mind me asking?
08:35:39 <nitrix> bumpkin: One of those self-taught. English being my 3rd language :]
08:36:18 <bumpkin> nitrix, that's great.  have you ever found that to be an obstacle?  I dropped out of college (not technical degree) and am self-taught too
08:36:21 <Koen_> nitrix: may I ask how you learned haskell?
08:36:27 <nitrix> I'm at the stage (23 y/o) where I can tell it's requiring more work to cram stuff in my head, so I'm glad I discovered Haskell recently.
08:36:44 <bumpkin> nitrix, haskell and FP in general is really appealing to me but from the outside it looks like a lot of applications are academic
08:36:50 <ertesx> bumpkin: 99% in the branch of online marketing‚Ä¶  and in my spare time i've done game-related stuff and a bunch of abstractions
08:37:23 <nitrix> Koen_: Working on projects and struggling. Also, IRC. I haven't read any of the Haskell books, but I'm on #haskell-beginners helping people with their exercises so I'm learning indirectly.
08:37:40 <EvanR> bumpkin: its really good for understand programming better
08:37:46 <Koen_> hmmm
08:38:19 <ertesx> bumpkin: that used to be true, indeed, and there is still a lot of academic stuff going on:  language research, abstraction development, even type theory, etc.
08:38:38 * hackagebot diagrams-svg 1.4.0.2 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.0.2 (BrentYorgey)
08:38:41 <nitrix> Koen_: I ask myself the answer to almost every question asked in here. Then compare my personal answer with the answer proposed. It's a method of self-validation. If I'm confident enough, I'll participate more.
08:38:46 <tdammers> "academic" doesn't imply "useless" or "impractical" or even "wrong"
08:39:10 <ertesx> bumpkin: haskell is in a sweet spot:  academia and practical software engineering work very well together
08:39:16 <ertesx> they benefit from each other
08:39:21 <tdammers> at best, it means that one is simply not concerned with practicalities too much
08:39:42 <tdammers> but FP isn't just an academic exercise, it's a highly practical paradigm
08:39:50 <mizu_no_oto_work> bumpkin: Haskell is actually pretty good for web development.
08:39:56 <nitrix> Koen_: It reduces the amount of times I'm wrong to not mislead beginners, but it's still painful once in a while. You really have to turn your ego off :P
08:40:32 <bumpkin> ertesx, sounds nice.  I'm currently more qualified for web-dev type stuff (although fortunately employed at a company that has an interesting backend part)
08:40:38 <nitrix> Koen_: I'm missing lot of stuff though. Like I'm learning category and stuff on the side just because there are still gray areas left.
08:40:45 <ertesx> bumpkin: when i started with haskell it was more leaning toward academia‚Ä¶  it was practical, but lots of bindings and practical libraries were missing‚Ä¶  also documentation was scarce
08:40:55 <Berra> Xandaros: try on a parser means that it returns everything back if it fails, even if sub-parses didn't use try?
08:41:00 <bumpkin> mizu_no_oto_work, I'm hoping to eventually leave web development.  Although doing it with a functional lanugage does sound nice
08:41:11 <ertesx> bumpkin: we have quite a few web frameworks now, so go ahead =)
08:41:40 <mizu_no_oto_work> bumpkin: you should check out purescript.  It's a compile-to-javascript language that's essentially Haskell with a few modifications that make the impedance mismatch smaller
08:41:43 <statusfailed> sm: what is "test:NAME" supposed to be? I tried: "test:Test.hs", "tests:Test.hs", "tests", ... and a bunch more variations, but none work
08:41:46 <Xandaros> Berra: If it fails and has consumed input, subsequent parsers will also fail. If a parser in a try fails, no input will be consumes
08:42:03 <Xandaros> Berra: You should usually put a try around the part that ‚Äòidentifies‚Äô a part of the parser
08:42:04 <bumpkin> ertesx, ha yeah i've been looking.  Really, i'm only about 24 hours into checking out Haskell but liking it a lot so far.  
08:42:26 <Xandaros> Berra: In the case of comments, that is the ‚Äú//‚Äù, but the whitespace in front needs to be included, obviously :D
08:43:00 <mizu_no_oto_work> e.g. it's strictly evaluated, and uses 'row types' to model Javascript records.
08:43:02 <nitrix> bumpkin: The best tip I can give you is; don't expect to be able to transpose any existing knowledge to it 1:1.
08:43:05 <ertesx> bumpkin: web dev with haskell is quite nice, and you even have a number of options on how you want to abstract HTTP (and HTML and forms and databases and ‚Ä¶)
08:43:07 <bumpkin> mizu_no_oto_work, that sounds interesting.  I'm not actually opposed to Javascript though
08:43:15 <EvanR> bumpkin: one of my favorite things when i started with haskell (which was while I was doing PHP work) was that you could instantly tell what a function returned, and you wont be surprised by it randomly returning NULL or FALSE instead
08:43:35 <nitrix> bumpkin: People approach learning new languages like it's just a matter of new syntax. With Haskell, you'll genuinely have to learn new concepts and scratch your scalp a little.
08:43:42 <EvanR> many dynamic languages dont seem to think what a function returns is important enough to document or document correctly
08:43:43 <bumpkin> nitrix, thanks for the tip.  Yeah i started looking at it to learn some brand new things.  
08:44:03 <divVerent> speaking of web, I've got simple web side project to do that I might want to use Haskell for. It's a simple DB frontend.
08:44:04 <bumpkin> nitrix, I have messed with Lisp a bit and liked that a lot as well
08:44:06 <tdammers> EvanR: that must be my biggest gripe with clojure, actually - that culture of "whatever" style documentation
08:44:13 <ertesx> bumpkin: we're even starting to solve what we call "the javascript problem":  GHCJS is generating decent javascript from haskell
08:44:24 <bumpkin> EvanR, i know what you mean exactly
08:44:26 <divVerent> As I don't want to run an extra server, but rather run this via CGI/FastCGI, and also I don't want to spend years on an overengineered piece of crap
08:44:30 <ertesx> including all its features -- even including concurrency
08:44:34 <nitrix> bumpkin: On the flip side, it's very rewarding. The first months are tought while things "makes sense" but it's still trouble some to connect things together.
08:44:44 <Berra> Xandaros: But should just -- pLine = optionMaybe $ try pOneLineComment -- work then?
08:44:46 <divVerent> what's there that just does CGI/FastCGI, HTML templates, and basically that's all?
08:44:48 <Xandaros> I'm working on a web side project, as well. It's such a joy with Haskell; this is the first time I don't rip my hair out doing web stuff :P
08:45:05 <nitrix> bumpkin: After a while, the abstractions wins over you and it becomes entirely instinctive.
08:45:06 <Xandaros> Berra: Maybe, but you'll sacrifice error reporting accuracy
08:45:06 <ertesx> divVerent: i'd go with the server variant (FastCGI is a persistent process, too, anyway)
08:45:12 <tdammers> divVerent: there's (fast|s)cgi backends for wai
08:45:26 <divVerent> FastCGI doesn't open another port and requires me to set up reverse proxy and all that, though
08:45:34 <bumpkin> ertesx, just curious why it's called the 'javascript problem'
08:45:35 <Berra> Xandaros: Ok, but doing so doesn't solve anything though
08:45:36 <divVerent> I don't care much for performance, so even plain CGI would work
08:45:37 <ertesx> divVerent: it really makes your life easier, especially if you want to develop with rapid prototyping
08:45:41 <divVerent> it's for a single user after all
08:45:54 <bumpkin> ertesx, I know people like to kind of talk trash about it, but except for a few things I don't think it's so bad
08:45:59 <ertesx> bumpkin: the javascript problem = 1. JS sucks, 2. we can't avoid JS
08:46:02 <Xandaros> Berra: That's odd... which parser library do you use?
08:46:02 <tdammers> divVerent: cgi isn't worth it
08:46:04 <nitrix> bumpkin: e.g. the latest line of code pasted here was transforming "bleh" into "bblleehh", how would you write this in other languages?
08:46:10 <divVerent> running an extra server isn't worth it either
08:46:13 <ertesx> bumpkin: so our solution is to compile haskell to JS
08:46:17 <nitrix> bumpkin: concatMap (replicate 2) "bleh". Done :)
08:46:17 <divVerent> yet another piece of software to babysit
08:46:20 <tdammers> divVerent: running an extra server is easy
08:46:21 <mizu_no_oto_work> bumpkin: actually, one interesting application of Haskell is Facebook's automated spam detection system.
08:46:24 <Berra> Xandaros: Parsec
08:46:29 <divVerent> KEEPING it running is harder :P
08:46:40 <ertesx> bumpkin: write haskell code for six months, and then tell me again that you don't think JS is bad =)
08:46:52 <divVerent> the nice part about cgi/fastcgi is that once you configured it once, apache takes care of it
08:46:54 <Xandaros> :D
08:47:16 <tdammers> fastcgi isn't too bad
08:47:39 <divVerent> it's still zero maintenance after all
08:47:40 <EvanR> tdammers: right... the answer to what a given function returns is either "what do you mean, anything" or "its complicated"
08:47:49 <tdammers> what I like especially about the 'standalone server behind reverse proxy' approach is that you get really good isolation between processes
08:47:50 <divVerent> as in the typical config, apache will start the fastcgi server when needed
08:47:53 <bumpkin> ertesx, well you probably have a point there.  could be stockholm syndrome
08:48:13 <divVerent> tdammers: sure, in many cases it's a good thing
08:48:15 <tdammers> your application runs in a separate process, as its own user, and the only way for apache to talk to it is through the port it listens on
08:48:26 <bumpkin> mizu_no_oto_work, I read a snippet about that.  Is any of that open-source or written about?  I couldn't find much about it
08:48:26 <ertesx> divVerent: perhaps you should change your reasoning slightly:  1. you're going to have a long-running process anyway, 2. you're saving a lot of indirection by serving from haskell directly, 3. you can employ rapid prototyping
08:48:27 <divVerent> in this case I'd rather avoid that
08:48:34 <Xandaros> Berra: Well, I don't know either. It should work as you have it. One last thing you could try is putting a try around newline, but if that fixes it, it's a bug
08:48:52 <mizu_no_oto_work> bumpkin: https://github.com/facebook/Haxl
08:48:53 <divVerent> ertesx: but it'll go down for whatever reason and I'll notice only in six weeks when $user wants to use it once that it's gone
08:48:54 <tdammers> also makes deployments easy and predictable
08:48:57 <divVerent> and then have to fix it RIGHT NOW
08:49:11 <tdammers> ah, no, you do want some sort of watchdog
08:49:19 <divVerent> sure, I can add all sorts of complexity
08:49:19 <bumpkin> nitrix, that is nice.  Python isn't awful for that but I admit it isn't pretty: ''.join([i*2 for i in "bleh"])
08:49:21 <divVerent> but I'd prefer something simple
08:49:26 <divVerent> until now I went well with cgi/suexec
08:49:30 <divVerent> yes, I know it's slow
08:49:35 <divVerent> but for one-user apps, who cares
08:49:43 <bumpkin> mizu_no_oto_work, wow thanks.  don't know how I missed that
08:49:45 <divVerent> and all I have to monitor is the apache itself
08:49:47 <Berra> Xandaros: Doesn't solve it. Maybe you can see something obviously stupid I've done? http://lpaste.net/5775914960743825408
08:49:50 <tdammers> the slowness becomes worse when you have a lot of startup code
08:49:56 <divVerent> sure, I know that
08:49:58 <ertesx> divVerent: the thing is: CGI is *not* simple, and you'll immediately notice that when you start engineering ‚Äì neither is FastCGI
08:50:04 <divVerent> but I'm totally fine if it takes 5 seconds to load
08:50:06 <ertesx> divVerent: serving from haskell is indeed the *simplest* solution
08:50:09 <divVerent> ertesx: CGI is simple in Perl
08:50:13 <EvanR> tdammers: im on a long running github issue for adding return type annotations to julia, my suggestion was "if anything just let the syntax work, it doesnt even have to do anything"
08:50:14 <ertesx> divVerent: but not in haskell
08:50:20 <ertesx> perl is better for CGI
08:50:22 <tdammers> divVerent: it's easy, not simple
08:50:23 <divVerent> then Haskell is the wrong tool, apparently
08:50:28 <EvanR> input types are important, why not the return type
08:50:45 <ertesx> divVerent: if you insist on CGI, haskell may not be the right tool, yes
08:50:46 <divVerent> or is there something where I can let Apache take care of the babysitting with Haskell too?
08:50:46 <tdammers> EvanR: sheesh
08:51:00 <divVerent> mod_haskell? :)
08:51:02 <nitrix> bumpkin: Just wait until you learn about the Maybe type :)  data Maybe a = Just a | Nothing
08:51:04 <tdammers> lol
08:51:14 <tdammers> seriously though, CGI is pretty simple in Haskell too
08:51:14 <divVerent> not in Debian tho0ugh
08:51:16 <divVerent> but exists
08:51:20 <mizu_no_oto_work> bumpkin: see also https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
08:51:26 <tdammers> IIRC WAI even ships with a CGI backend
08:51:34 <tdammers> the challenge is to keep stdout clean
08:51:38 <ertesx> divVerent: generally haskell programs don't go down that easily‚Ä¶  and turning a haskell web app into a server is literally a one-liner
08:51:43 <nitrix> bumpkin: Which book are you using to learn ?
08:51:51 <EvanR> ertesx: but when they do...
08:52:04 <bumpkin> nitrix, yeah i'm reading about Maybe now.  working through Learn You A Haskell
08:52:06 <EvanR> its dos equis
08:52:08 <divVerent> and I suppose I can use the IO monad from a WAI application?
08:52:15 <tdammers> divVerent: of course
08:52:16 <divVerent> ertesx: I know the _program_ won't go down
08:52:21 <divVerent> the _process_ might, though :P
08:52:23 <tdammers> divVerent: both the monad and the IO part of IO
08:52:26 <bumpkin> also looking through the xmonad source since it's pretty small and digestible
08:52:31 <divVerent> you know I might forget to set it up somewhere, some connection issue, whatever
08:52:41 <tdammers> divVerent: in fact, plain WAI has most of its functionality in IO anyway
08:52:45 <divVerent> the less moving parts, the better
08:52:49 <ertesx> divVerent: you run your apache through a process manager, don't you?  you can use the same for your application =)
08:53:05 <divVerent> sure I can, and I'll still manage to screw it up :P
08:53:14 <divVerent> I want zero maintenance[tm]
08:53:18 <divVerent> not 1 day per year maintenance
08:53:27 <ertesx> divVerent: you're imagining an engineering cost that isn't there‚Ä¶  you're really just replacing one engineering cost (CGI) by another (reverse proxy)
08:53:27 <tdammers> if you can screw that up, I'm pretty sure you can also screw CGI up
08:53:41 <tdammers> i.e., what ertesx said ;)
08:53:52 <bumpkin> nitrix, actually a little confused about Maybe at the moment
08:54:19 <divVerent> ertesx: except that in the cases where I dealt with CGI, it never went down other than for database server issues
08:54:27 <nitrix> bumpkin: Can you switch over #haskell-beginners ?
08:54:28 <ertesx> divVerent: judging by my experience (i've never used perl) CGI is more costly; not because it's slower, but because you have to go through quite a few operating system concepts to get it right
08:54:36 <divVerent> in cases where I dealt with extra servers, all kinds of things can go wrong, so I first need to set up more complex monitoring
08:54:36 <bumpkin> nitrix, how exactly is it used?  for example if I type in ghci: :t Just 'h', I get Maybe Char returned
08:54:37 <nitrix> bumpkin: I'll write some code samples.
08:54:39 <glguy> nitrix: #haskell is find for beginner questions
08:54:40 <ertesx> files, file descriptors, executables, etc.
08:54:44 <bumpkin> nitrix, you got it
08:54:50 <tdammers> well, the thing with CGI is that when your process goes down, it's not a big deal, because you get a new process for the next request anyway
08:54:55 <divVerent> ertesx: well, it's the framework's task to deal with the OS mess
08:55:12 <nitrix> glguy: I'm aware, it's just to keep the noise low with the plentitude of lambdabot examples.
08:55:33 <ertesx> divVerent: sure, someone needs to take the responsibility‚Ä¶  with haskell+CGI i assure you that you'll be the one =)
08:55:57 <ertesx> CGI may be easy in perl, but in general it's hard
08:56:08 <tdammers> oh, and you don't really need much OS interaction for CGI, that's the beauty - you get a specially crafted environment that contains information about the HTTP request, a request body on stdin, and you're supposed to write HTTP to stdout
08:56:12 <divVerent> I'd even say it's an almost trivial interface if you don't want anything efficient
08:56:25 <divVerent> I mean, even shell scripts can "somewhat" handle it
08:56:47 <divVerent> (okay, parsing a QUERY_STRING from shell... ugh)
08:57:12 <tdammers> echo "HTTP/1.1 200 OK"; echo "Content-type: text/plain"; echo ''; echo "Hi!"
08:57:14 <tdammers> there, CGI
08:57:34 <divVerent> sure, part of it
08:57:37 <EvanR> FastCGI is better
08:57:38 <divVerent> add "env" and you've covered all ;)
08:57:49 <EvanR> but i guess now everyone wants to run the webserver in-process
08:57:49 <divVerent> tdammers: almost, actually
08:57:57 <divVerent> your CGI script is bad and you should feel bad ;)
08:58:00 <tdammers> anyway, the point is moot, because (assuming you use something like WAI) the interface from the application side is the same between either approach
08:58:02 <divVerent> the proper separator is CRLF, not LF
08:58:12 <divVerent> but Apache is nice enough to work with this anyway
08:58:17 <tdammers> divVerent: "I wrote that on Windows" :P
08:58:20 <divVerent> ;)
08:58:45 <tdammers> anyway, my point is that CGI isn't complex or anything
08:58:48 <divVerent> anyway, now looking at WAI
08:58:56 <tdammers> I just still think it's a bad choice
08:59:00 <divVerent> assuming I use that, what would I be using for connecting to MySQL and doing custom transactions?
08:59:08 <divVerent> like, I need some atomic transactions touching multiple rows
08:59:11 <divVerent> I know how to do them in SQL
08:59:14 <tdammers> divVerent: whatever you'd use either way
08:59:16 <divVerent> okay
08:59:22 <tdammers> divVerent: nothing to do with how you implement your HTTP server
08:59:36 <divVerent> so I don't have to use Data.Persistent for this
08:59:40 <tdammers> no
08:59:45 <tdammers> you can, but you don't have to
08:59:47 <divVerent> i.e. it's not an all encompassing framework like the Java guys do
08:59:54 <tdammers> certainly not
08:59:56 <divVerent> good then
09:00:02 <divVerent> from the code examples it seems to do what I need
09:00:05 <tdammers> database connectivity and HTTP are completely separate concerns
09:00:19 <tdammers> there are some frameworks that are designed as "batteries included" packages, e.g. yesod
09:00:27 <tdammers> but even there, you can mix and match parts
09:00:42 <ertesx> divVerent: i suggest you try the proxy variant first to get a feeling for how well it works before you prematurely decide on CGI/FastCGI
09:00:50 <ertesx> divVerent: it's really the easier route in haskell
09:00:52 <tdammers> for a straightforward SQL connectivity layer, try HDBC
09:00:57 <divVerent> oh, I did the proxy dance often enough
09:00:59 <ertesx> and really almost every language other than perl and PHP
09:00:59 <divVerent> and hate it
09:01:01 <divVerent> (with Python though)
09:01:15 <tdammers> try the proxy version anyway
09:01:22 <divVerent> because then I have to deal with systemd to keep that thing running
09:01:27 <tdammers> or rather, write your application to use a standalone server on a local port
09:01:29 <divVerent> and not start it too early etc.
09:01:31 <tdammers> and figure out deployment later
09:01:34 <divVerent> and not too late, etc.
09:01:35 <EvanR> mysql-simple postgres-simple
09:01:43 <divVerent> anyway, mysql-simple looks good
09:01:45 <ertesx> divVerent: i don't deal with systemd anymore‚Ä¶  i just dump it into a docker container
09:01:45 <divVerent> does the ? escaping too
09:02:28 <tdammers> extending a WAI+Warp web app to also support FastCGI, CGI, SCGI, or whatever, is relatively trivial
09:02:47 <ertesx> CGI is a problem, even with WAI
09:02:50 <ertesx> because of run-time state
09:03:00 <divVerent> how so?
09:03:09 <tdammers> state doesn't survive between requests
09:03:31 <divVerent> of course not
09:03:34 <tdammers> for example, I like to have some sort of mutable ref (MVar, IORef, whatever) in my application state to store sessions
09:03:52 <tdammers> it's blazing fast, because it's all in RAM, never need to hit I/O for sessions
09:04:10 <divVerent> in my design, there's a simple edit request that mutates the DB, and everything else just displays stuff from the DB
09:04:31 <divVerent> state outside the DB isn't needed, assuming I just use HTTP digest authentication instead of user login
09:04:33 <tdammers> no caching? no sessions?
09:04:39 <divVerent> there's only a single user
09:04:44 <divVerent> and if it takes 5 seconds it's fine
09:04:44 <ertesx> divVerent: generally haskell web apps look more like long-running programs that handle requests
09:04:48 <Xandaros> Berra: Right, I think I figured it out. optionMaybe tries to parse the line, but fails, not consuming any input. Which means you still have the INVALID line left, which nothing is able to parse
09:05:03 <tdammers> another thing I do routinely is precompile templates
09:05:06 <ertesx> divVerent: that has the advantage that you can use all of haskell's features, most notably concurrency (a.k.a. light-weight threading)
09:05:11 <Xandaros> Berra: So, you need to skip a line in the case it fails
09:05:22 <divVerent> sure, and that is useful
09:05:30 <divVerent> anwyay, I suppose I'll use the web server for testing/development
09:05:41 <divVerent> and deploy it as fastcgi if that's painless, separate server otherwise
09:05:48 <divVerent> WAI seems to let me do all that, so why not
09:06:07 <tdammers> yes, WAI is, by design, an abstraction layer that rids you of most of the differences between all those backends
09:06:21 <tdammers> you build an Application object, and pass it to whichever HTTP backend you want
09:06:27 <tdammers> the Application doesn't care
09:06:48 <divVerent> and yes, I know using state inside the process would behave differently based on the number of processes
09:07:01 <divVerent> I just won't need any to begin with
09:07:17 <divVerent> so now all I'm looking for is what WAI calls HTML templates
09:07:21 <tdammers> you could even leave the database connection open between requests :D
09:07:28 <tdammers> WAI doesn't do HTML at all
09:07:34 <tdammers> WAI just serves responses
09:07:39 <tdammers> it doesn't care about the contents of them
09:07:45 <divVerent> oh, okay
09:07:50 <tdammers> you have to set a suitable Content-type yourself, and send raw ByteStrings
09:07:54 <divVerent> then I'll find something
09:08:40 <divVerent> content aware HTML template systems would be best, i.e. one where the template is parsed so it knows how to escape each parameter
09:08:40 <tdammers> most libraries out there assume compile-time templates, i.e., your templates are compiled down to Haskell code and linked into the application
09:09:04 <ertesx> divVerent: we have that
09:09:17 <tdammers> actually, most HTML templating solutions in Haskell are like that
09:09:29 <tdammers> blaze-html is probably a good starting point
09:09:32 <ertesx> blaze-html, heist, lucid, shakespeare, ‚Ä¶
09:09:43 <ertesx> i tend to recommend lucid over blaze-html now
09:10:14 <divVerent> well, that'll work too
09:10:19 <ertesx> we also have a template system for CSS:  clay
09:10:20 <divVerent> i.e. HTML code encoded as Haskell code
09:10:34 <ertesx> heist is actually HTML
09:10:43 <ertesx> stored in template files
09:10:47 <tdammers> if you want runtime templates, I wrote Ginger for that
09:10:49 * EvanR shudders at idea of "html monad"
09:11:05 <ertesx> EvanR: it's just Writer really
09:11:07 <tdammers> it's somewhat compatible with Jinja2 (from Python)
09:11:07 <divVerent> lucid will also work
09:11:14 <EvanR> sounds like a monad
09:11:17 <divVerent> well, probably I'
09:11:17 <tdammers> anyway, try a bunch of them and see what you like
09:11:25 <divVerent> ll just take lucid, it's simple enough and I need nothing fancy
09:12:35 <divVerent> so, thanks, looks like I'll start implementing
09:13:23 <ertesx> divVerent: i use lucid and clay
09:13:29 <ertesx> and snap as the web framework
09:13:51 <ertesx> and digestive-functors for form handling, if that comes up
09:14:37 <ertesx> divVerent: you may not want to use WAI directly, because it is extremely low-level‚Ä¶  if you want something simple, have a look at scotty
09:14:46 <tippenein> is the state monad what I'm looking for to carry around a count for a monoid?
09:14:47 <ertesx> it's built on top of WAI, so you still get the flexibility
09:15:20 <ertesx> tippenein: sounds fine:
09:15:20 <EvanR> count for a monoid?
09:15:29 <ertesx> :t modify succ  -- if i got you correctly
09:15:29 <tippenein> If I do: count (Collection 1 <> Collection 2) => 2
09:15:30 <lambdabot> (Enum s, MonadState s m) => m ()
09:15:40 <ertesx> oh
09:16:05 <tippenein> I want to implicitly count how many things I've folded over
09:16:06 <EvanR> length ?
09:16:18 <ertesx> tippenein: then fold with the count
09:16:29 <divVerent> ertesx: but I suppose scotty enforces using the web server process
09:16:41 <ertesx> divVerent: nope, it's built on top of WAI
09:16:50 <divVerent> oh wait, no
09:16:55 <divVerent> just the scotty function does
09:16:58 <divVerent> scottyApp does not
09:17:07 <EvanR> tippenein: store a count in the Collection structure and <> adds?
09:17:42 <ertesx> tippenein: you want to mappend some things together and count how often you mappended?
09:18:13 <ertesx> tippenein: if that's what you need, there is a Monoid instance for product monoids:
09:18:23 <ertesx> > ("abc", Sum 5) <> ("def", Sum 7)
09:18:25 <lambdabot>  ("abcdef",Sum {getSum = 12})
09:20:27 <ertesx> though you may want to use a custom wrapper, because (<>) is non-strict on tuples:  data Count a = Count !Int a;  instance (Monoid a) => Monoid (Count a)
09:22:24 <EvanR> i love wrappers that add functionality like that ;)
09:23:14 <lpaste> tippenein pasted ‚Äúabstract par over any number of groups‚Äù at http://lpaste.net/165588
09:23:40 * hackagebot uri-bytestring 0.2.1.0 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.1.0 (MichaelXavier)
09:23:49 <tippenein> How can I avoid explicitly stating the a par b par c structure?
09:24:20 <phadej> does anyone know how to solve weird error: Could not deduce (GToEncoding * (Rep a)) arising from a use of `gToEncoding' from the context (Generic a, GToEncoding * (Rep a))
09:26:24 <Cale> phadej: That is... interesting.
09:26:35 <glguy> phadej: Might be worth posting some code
09:26:59 <ertesx> tippenein: first of all your pars don't do anything
09:27:10 <ertesx> tippenein: secondly this is a natural candidate for data parallelism
09:27:37 <phadej> well, the code is in: https://github.com/bos/aeson/pull/413 (7.8.3 failing)
09:28:04 <ertesx> tippenein: i recommend reading The Book: http://chimera.labs.oreilly.com/books/1230000000929/index.html
09:28:26 <ertesx> tippenein: in particular chapter three: evaluation strategies
09:28:58 <phadej> I remember seeing something similar, but then it was caused by some hidden parameters ghc don't print by default
09:29:09 <phadej> but I don't remember any flags to unreveal them
09:29:48 <glguy> phadej: It's possible that the 'a's are not actually the same somehow, which I've seen mixing instancesigs with default signatures
09:30:31 <phadej> no InstanceSigs here
09:30:32 <glguy> but that's not the case here I see because it's not even an instance :) 
09:31:08 <Berra> Xandaros: Sorry for the afk. Alright that does make sense. How do I tell the sepBy parse to skip one line though ?
09:32:18 <glguy> phadej: Also since the code is working on all but the oldest compiler this could just be a GHC bug
09:33:05 <phadej> glguy: yeah, but I just moved code around, so that's weird it stopped working
09:33:57 <phadej> though PolyKinds might be somehow broken on 7.4
09:34:03 <Xandaros> Berra: I was trying to figure that out, but lost interest. Sorry :P My attempt was using `when (isNothing x)` and then skipping the rest of the line using `void untilNewline`
09:35:14 <phadej> seems Tagged is polykinds on > 7.6 only, so maybe there is a reason for thar
09:35:27 <phadej> glguy: thanks for the pointer!
09:36:27 <Berra> Xandaros: Thanks for the awesome help. Now I have a great lead.
09:41:44 <Xandaros> I've turned these two types in a Functor: https://hackage.haskell.org/package/abnf-0.2.0.0/docs/Text-ABNF-Document-Types.html - My question now is: Are they applicative? For Content, I can easily find pure. <*> for Terminal is also easy, but I have trouble with NonTerminal
09:43:41 * hackagebot weigh 0.0.3 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.3 (ChrisDone)
09:44:00 <phadej> Xandaros: how they could be functors, they aren't * -> * kinded?
09:44:21 <Xandaros> phadej: They are now :P It's just not on hackage (or even committed) yet
09:44:47 <Xandaros> Just replace Text in Terminal with a and add a type argument to both Document and Content
09:45:48 <Xandaros> phadej: http://tcp.mniip.com/fi9t
09:51:19 <phadej> Xandaros: http://lpaste.net/628546129939660800
09:51:28 <phadej> and then applicative using that definition
09:51:37 <phadej> it's often easier to think Monad first, if it's only possibl
09:52:00 <phadej> I'm not sure if that instance is lawful, but at least types align :(
09:52:02 <phadej> :)
09:52:42 <Xandaros> It seems to do what I'd expect it to do, at last. (Or so I think :P)
09:53:42 <phadej> Xandaros: Content resembles http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Free.html#t:Free
09:54:31 <Xandaros> Hmm, it kinda does. But whenever I look at Free, my head kinda... does things :P
09:54:53 <phadej> with Document-ish (Docucument' Identifier [a]) as base functor
09:55:43 <bumpkin> mizu_no_oto_work, ertesx continuing my train of though from before, what is/are the most popular/practical Haskell web framework?
09:55:50 <Xandaros> Well, I'm gonna use your monad instance for now and hope it is lawful. I'll open an issue about proving it :D
09:56:13 <bumpkin> also, how does interacting with a database work with Haskell since it seems to me like that's decidedly un-functional?
09:56:20 <phadej> Xandaros: i.e. http://lpaste.net/628546129939660800
09:56:36 <phadej> now Content ~ Free
09:58:15 <Xandaros> I have a feeling Document ~ Free is a nice property to have. I'll keep it in mind
10:00:00 <Xandaros> That would mean I basically get the Monad instance for Document for free, doesn't it? :P
10:00:59 <Xandaros> Wait, Content ~ Free. That makes a lot more sense. I'm stupid
10:07:36 <phadej> bumpkin: popularity and practicality depends on the needs
10:07:47 <phadej> Yesod, servant, snap, happstack - there are many
10:07:54 <mizu_no_oto_work> bumpkin: depends on what you're doing.  Servant is great for something like a REST API.  Snap, Yesod and Happstack are more traditional frameworks
10:07:59 <phadej> :P
10:08:34 <Xandaros> bumpkin: I personally use servant to provide a REST API on the server side and reflex with ghcjs for the client side
10:08:52 <mizu_no_oto_work> I'm not a big fan of Yesod.  It uses a lot of Template Haskell to autogenerate boilerplate.  That's convenient, but it makes the docs hard to read.
10:08:53 <bumpkin> Xandaros, ghcjs is compiling haskell to JS right?
10:08:59 <Xandaros> yup
10:09:17 <Xandaros> And reflex is an FRP framework, which was developed for webdev
10:09:29 <Xandaros> (It can do other things as well, though. It's general purpose)
10:10:18 <bumpkin> Xandaros, what's FRP?
10:10:28 <mizu_no_oto_work> functional reactive programming
10:10:40 <bumpkin> mizu_no_oto_work, and what's that?
10:10:40 <mizu_no_oto_work> Essentially, modelling everything as functions on time
10:10:41 <Xandaros> Answering that question in detail is a book :P
10:10:55 <bumpkin> Xandaros, fair enough
10:11:14 <mizu_no_oto_work> so the mouse position, for example, can be thought of as a function from the current time to an (x,y)
10:12:06 <bumpkin> mizu_no_oto_work, okay what about a time in the past? I'm guessing it doesn't keep a history of all its previous values for all time?
10:12:07 <Xandaros> I usually view it like this: You can use time-changing variables as if they were static. (They are hidden in a monad) The result is, of course, time-varying, again (in the monad)
10:12:16 <Xandaros> This makes it a pleasure to work with these kinds of things
10:12:39 <Xandaros> bumpkin: Some frameworks do, but that's generally seen as a misfeature nowadays
10:13:39 <bumpkin> Xandaros, not to sound glib but that kind of sounds like cheating at being purely functional
10:13:53 <Xandaros> So, while you can't sample the past anymore, you can still work with past values. You just need to know about it at the time the value you need is available
10:13:56 <bumpkin> and I really don't mean that in a bad way
10:14:55 <Xandaros> Well, all the properties you gain from pure functional programming still hold, so I don't consider it cheating :P
10:16:51 <ertesx> bumpkin: it's more a question of tradeoffs, but ultimately you will find your framework by trying a few
10:17:14 <bumpkin> ertesx, thanks I'm going to check out the ones mentioned
10:17:37 <mizu_no_oto_work> bumpkin: pure functional programming isn't really about being effectless, per se.  It's about saying exactly when and where effects can happen, and handling them in a referentially transparent way.
10:17:38 <ertesx> bumpkin: personally i use snap, but i have servant in the corner of my eye, especially for frontend-heavy projects
10:18:02 <ertesx> bumpkin: and for the frontend i'm definitely going with FRP, most likely reflex
10:18:10 <bumpkin> ertesx, because it's easier to separate back- from front-end that way?  if you just need the API/databse backend?
10:18:44 <ertesx> bumpkin: you mean servant?
10:19:15 <bumpkin> ertesx, yeah didn't someone say that was a good choice for primarily a REST api?
10:19:21 <ertesx> because you can write a type-level description of the API and use it on both the client and the server side
10:19:40 <Xandaros> bumpkin: REST API is all servant can do. That's what it does and it's amazing at it :D
10:19:46 <ertesx> servant keeps servers and clients consistent
10:20:08 <bumpkin> mizu_no_oto_work, hm okay.  my grasp of what fp is all about is still pretty shakey.  Isn't one of the facets that the same inputs to a function should result in the same output every time?
10:20:15 <bumpkin> or is that an over-simplification?
10:20:21 <mizu_no_oto_work> bumpkin: yes.
10:20:40 <ertesx> for databases i don't use any library‚Ä¶  instead i write a semantics (manifested as a type class), and then i implement a backend for it
10:20:43 <EvanR> haskell takes "functions" very seriously, they are actual functions
10:20:51 <bumpkin> mizu_no_oto_work, so in the mouse position exapmle, there's time as an input, but I'm guessing there also has to be an implicit UI environment also as an input right?
10:21:14 <bumpkin> mizu_no_oto_work, because the same function with the same time input would obviously result in different outputs on different machines
10:21:15 <ertesx> my first backend is typically just an STM backend with no DBMS backing
10:21:17 <EvanR> not necessarily total functions though
10:21:24 <Xandaros> The time to mouse pos was a bit over-simplified, I think :P
10:21:28 <ertesx> because it's easy to change and test
10:22:12 <bumpkin> ertesx, Xandaros servant does sound nice.  the huge all-inclusive framework idea can be a little tedious sometimes
10:22:47 <ertesx> bumpkin: none of the haskell frameworks are all-inclusive actually, though yesod is close
10:22:50 <ertesx> they are more modular
10:22:52 <Xandaros> bumpkin: servant and yesod/snap solve different problems in my opinion. They both are accessible over HTTP in the end, but that's where similarities end
10:22:55 <lexi-lambda> Hey, I just tried registering an account on GHC‚Äôs Trac to report a bug, but I got rejected as ‚Äúpotential spam‚Äù. Am I missing something? It asked me to solve a captcha of some kind, which I think I did, but then it just seemed to give me an error.
10:23:23 <bumpkin> ertesx, that sounds appealing
10:23:55 <Xandaros> bumpkin: yesod/snap are traditional web frameworks, which generate a full web page. Servant just does REST. It's theoretically possible to serve rest with snap/yesod and full web pages with servant, but then you are really just abusing your tools :P
10:23:57 <EvanR> bumpkin: not everything is naturally modeled as a function, for example a user moving a mouse around isnt really a functional situation. but abstract models of interactivity might involve functions somehow
10:24:17 <ertesx> bumpkin: for example i use snap for general application structure, lucid for HTML, clay for CSS, digestive-functors for forms, my own project-specific database abstraction, etc.
10:24:35 <sm> lexi-lambda: I would report it  on #ghc
10:25:03 <ertesx> bumpkin: you can add many more components: for example there are frameworks for type-safe routing
10:25:08 <Xandaros> lexi-lambda: I see complaints about that all the time. The spam detection seems to be a ‚Äòbit‚Äô aggressive‚Ä¶
10:25:25 <ertesx> bumpkin: data Route = HomeR | PostR PostId | AboutPageR | ‚Ä¶
10:25:37 <bumpkin> ertesx, cool sounds a little similar to the flask approach in python where you put together the pieces you need
10:25:40 <lexi-lambda> sm: thanks, will do
10:25:45 <Xandaros> ertesx: By the way, does servant-server work with ghcjs now? I remember there being problems because of a dependency on network, but I don't see that anymore
10:25:53 <Xandaros> *servant-client, derp
10:25:54 <bumpkin> ertesx, where HomeR PostR, etc are types that you've decalred?
10:25:56 <ertesx> Xandaros: no idea
10:26:04 <ertesx> Xandaros: i haven't used servant yet
10:26:09 <Xandaros> Ah, I see
10:26:24 <ertesx> bumpkin: they are values of the type Route, and they correspond to web paths
10:26:36 <mizu_no_oto_work> bumpkin: without getting too deep into it, the Haskell approach is to have actions be a first-class thing.  getLine, for example, is an action that represents getting a line of input from stdin
10:26:41 <mizu_no_oto_work> :t getLine
10:26:43 <lambdabot> IO String
10:26:47 <Xandaros> Ah, it depends on network indirectly, via http-client
10:26:58 <ertesx> bumpkin: the idea is that you make your route type path-agnostic, so if you decide to rewrite your paths, your code doesn't change‚Ä¶  and you can't refer to invalid paths
10:27:04 <EvanR> in particular getLine is not a function
10:27:29 <bumpkin> ertesx, cool that makes sense
10:27:36 <bumpkin> EvanR, getLine is an action?
10:27:44 <EvanR> yes
10:27:50 <mizu_no_oto_work> you can put getLine into a list, and it doesn't do anything.  The only way to have it actually perform an effect is to use 'combinators' to build up a bigger action, and bind that bigger action to main
10:27:53 <ertesx> bumpkin: personally i stopped using it a long time ago, but it's there if that sounds like a good idea to you
10:28:32 <bumpkin> ertesx, why did you stop using it and what do you use for routes instead?
10:28:36 <mizu_no_oto_work> :t getLine >>= \name -> putStrLn ("Hello, " ++ name)
10:28:37 <EvanR> main :: IO () is the only action that gets executed
10:28:37 <lambdabot> IO ()
10:28:40 <Xandaros> I quite liked the typed paths when I used yesod
10:29:13 <bumpkin> mizu_no_oto_work, what is the >>= operator?
10:29:23 <mizu_no_oto_work> :t (>>=)
10:29:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:29:44 <ertesx> bumpkin: the benefit has so far evaded me‚Ä¶  and since it's not builtin like in yesod, i just stopped caring about it =)
10:30:00 <ertesx> routing has never been a source of engineering problems or bugs to me
10:30:19 <EvanR> launchMissiles >> turnOnTV >> makeEggs
10:30:31 <EvanR> is one big action
10:30:34 <mizu_no_oto_work> In this case, (>>=) :: IO a -> (a -> IO b) -> IO b.  Essentially, it creates a new action that runs the first action until it produces a value, then plugs that value into a function to create the next action to run
10:30:38 <Xandaros> ertesx: Looks like there is servant-js, which allows you to generate a ‚Äòlibrary‚Äô that queries your API. Seems a bit odd to me, but I guess it works
10:30:47 <Xandaros> EvanR: s/>>/*>/g
10:31:01 <EvanR> *> is harder to type ;)
10:31:25 <ertesx> Xandaros: i like the idea of servant, but i won't feel terrible not to be able to use it =)
10:31:26 <Xandaros> Excuses! Well, I guess if you never use <* anywhere, it's fine
10:31:57 <mizu_no_oto_work> Haskell has a bunch of different action types.  Some of them can be run and turned into a pure value.
10:32:30 <EvanR> actions are also pure values, so they already ... are pure values ;)
10:32:40 <EvanR> so not turning into anything different
10:33:09 <mizu_no_oto_work> In some cases, you can have a function  'm a -> a'
10:33:30 <mizu_no_oto_work> :t runSt
10:33:31 <lambdabot>     Not in scope: ‚ÄòrunSt‚Äô
10:33:31 <lambdabot>     Perhaps you meant ‚ÄòrunST‚Äô (imported from Control.Monad.ST)
10:33:32 <Xandaros> :t runIdentity
10:33:33 <lambdabot> Identity a -> a
10:33:35 <Xandaros> :P
10:33:38 <mizu_no_oto_work> :t runST
10:33:39 <lambdabot> (forall s. ST s a) -> a
10:33:48 <ertesx> :t flip runCont id
10:33:49 <lambdabot> Cont c c -> c
10:34:00 <bumpkin> mizu_no_oto_work, and runST is an action?
10:34:04 <EvanR> :t runReader
10:34:05 <lambdabot> Reader r a -> r -> a
10:34:14 <bumpkin> are all those actions?
10:34:16 <Xandaros> bumpkin: runST takes an (ST) action and runs it
10:34:18 <EvanR> they are functions
10:34:25 <mizu_no_oto_work> ST s a is an action that uses single-threaded mutable state
10:34:49 <ertesx> bumpkin: you said, this is your first day with haskell?  if yes, nevermind for now =)
10:34:58 <ertesx> the one important thing to understand is IO
10:35:10 <EvanR> > runReader ask 9999
10:35:12 <lambdabot>  9999
10:35:14 <mizu_no_oto_work> You can, for example, take an immutable array, thaw it into a mutable array, sort it in place, then freeze it into a sorted immutable array, using ST.
10:35:29 <EvanR> > runReader (ask >>= \x -> return (x+1)) 9999
10:35:31 <lambdabot>  10000
10:35:38 <EvanR> > runReader (return "foo") 9999
10:35:40 <lambdabot>  "foo"
10:35:58 <EvanR> Reader solves "the global variable" problem ;)
10:36:06 <EvanR> you can ask anywhere
10:36:16 <mizu_no_oto_work> since you're just mutating memory, you can run the final 'sort this array in place and freeze the result' action, and you'll get back a pure immutable array
10:36:30 <ertesx> solves?  i think Reader *introduces* the global variable problem ;)
10:36:31 <EvanR> i say this because Reader is probably the most useful monad besides IO
10:36:35 <ertesx> just to solve it in an awkward way
10:36:38 <bumpkin> ertesx, yeah it is.  proably getting ahead of myself :)
10:36:48 <EvanR> ertesx: true
10:36:55 <bumpkin> ertesx, too eager because I think it's cool
10:36:58 <Xandaros> asks is more useful than ask if you ask me
10:37:10 <EvanR> yes asks
10:37:19 <EvanR> or utility functions based on it
10:37:27 <EvanR> or utility actions
10:37:29 <ertesx> bumpkin: IO is cool all by itself‚Ä¶  once you have written your first IO combinator, you'll get a taste of first-class actions
10:37:43 <ertesx> bumpkin: here is one:  twice action = action >> action
10:37:50 <ertesx> main = twice (putStrLn "Hello world!")
10:38:08 <EvanR> heres another: don't action = return ()
10:38:19 <ertesx> oh, there is a package for that
10:38:20 <EvanR> main = don't (putStrLn "hello world!")
10:38:26 <ertesx> @hackage acme-dont
10:38:26 <lambdabot> http://hackage.haskell.org/package/acme-dont
10:38:28 <EvanR> yeah
10:38:37 <ertesx> still one of my favourite acmes =)
10:38:45 <bumpkin> ertesx, what does >> do in the twice example?
10:38:52 <ertesx> bumpkin: read it as "and then"
10:38:59 <bumpkin> ertesx, got it
10:39:10 <ertesx> (>>) :: IO a -> IO b -> IO b  -- the action that runs the argument actions in order
10:39:17 <EvanR> it depends on the monad what >> and >>= do
10:39:26 <EvanR> in IO, it does the left action then the right
10:39:27 <coppro> a >> b is just a >>= (\() -> b)
10:39:40 <EvanR> dropping the result of the first one
10:39:41 <bumpkin> ertesx, what about for example expanding twice to repeat the action any number of times? could you do something like map >> to it?
10:39:44 <tippenein> do prelude functions not take Integer because it may be too large?
10:39:53 <Xandaros> coppro: No, it isn't‚Ä¶
10:40:12 <Xandaros> a >>= (\_ -> b)
10:40:17 <EvanR> tippenein: no, its more of an arbitrary choice
10:40:19 <ertesx> bumpkin: there are a number of ways to write it‚Ä¶  one is the straightforward recursive way:  times 0 action = return (); times n = action >> times (n - 1) action
10:40:54 <ertesx> bumpkin: then you can write:  main = 15 `times` putStrLn "Hello world"
10:40:57 <EvanR> tippenein: but in any case you really want everything to agree, which is why we dont use Word for stuff that cant be negative
10:40:57 <bumpkin> ertesx, ok that makes sense
10:41:11 <EvanR> it would be a pain in the ass
10:41:30 <EvanR> (if half the prelude used Word)
10:42:29 <coppro> Xandaros: True. They're equivalent up to bottom, though.
10:43:36 <ertesx> bumpkin: by the way, do-notation is just sugar for (>>), so instead of "a >> b >> c" you can write "do a; b; c", the major difference being that you can use layout nicely
10:43:48 <guest`> is there a prefix lambda, something like "(\->)"?
10:43:50 <ertesx> (the basic do-notation without "<-")
10:44:04 <ertesx> guest`: what would the type of that be?
10:44:08 <coppro> guest`: what do you want it to do?
10:44:10 <Xandaros> > pure "x" >>= (\() -> putStrLn "a")
10:44:11 <lambdabot>      Couldn't match expected type ‚Äò[Char]‚Äô with actual type ‚Äò()‚Äô
10:44:12 <lambdabot>      In the pattern: ()
10:44:12 <lambdabot>      In the second argument of ‚Äò(>>=)‚Äô, namely ‚Äò(\ () -> putStrLn "a")‚Äô
10:44:14 <EvanR> guest`: a function that wraps something in a function?
10:44:15 <Xandaros> coppro ^
10:44:35 <coppro> Xandaros: ohhh. wow I'm tired today.
10:44:36 <EvanR> :t const
10:44:37 <lambdabot> a -> b -> a
10:44:57 <guest`> coppro: get a list of variables names and make a new environment
10:45:15 <coppro> guest`: there is not.
10:45:23 <ertesx> guest`: that doesn't translate well to haskell‚Ä¶  you can use a list though
10:46:22 <bumpkin> ertesx, okay it sounds similar to progn in lisp then
10:46:43 <ertesx> bumpkin: intially yeah
10:46:46 <coppro> guest`: Haskell is not a dynamic language, it can't access variable names, for instance, at runtime (except via debug information, of course)
10:46:59 <coppro> guest`: what are you actually trying to do?
10:47:40 <EvanR> the profiler might have these names somewhere ;)
10:47:48 <EvanR> but i dont know if you can access them at runtime
10:48:05 <ertesx> bumpkin: you'll find that 'do' is a lot more powerful than 'progn'‚Ä¶  later ;)
10:48:05 <coppro> profiler information is just a kind of debug information ;)
10:48:08 <guest`> coppro: alambda https://en.wikipedia.org/wiki/Anaphoric_macro#Defining_anaphoric_macros, with template haskell
10:48:21 <guest`> i already did afix
10:48:26 <bumpkin> ertesx, well I just assumed everything in Haskell is more powerful :)
10:48:53 <ertesx> bumpkin: not everything‚Ä¶  common lisp has more powerful macros
10:49:05 <Xandaros> ertesx: More powerful than TH? :P
10:49:06 <Cale> guest`: Well, this has to do with macros, which means that to do something analogous, you'd want to be using Template Haskell to begin with.
10:49:13 <ertesx> Xandaros: yeah
10:49:32 <guest`> Cale: i'm using it
10:49:33 <EvanR> to clarify you want the good kind of power, not the kind of shoots you in the foot like PHP double dollar signs
10:49:52 <Zemyla> ...fuck it, I'm going to get rid of the separate tokenizing stage of my compiler, and just operate on characters.
10:49:53 <coppro> template haskell is entirely compile-time. I doesn't have a way to enumerate all names in scope.
10:49:54 <Cale> Let me see if I can understand this well enough to get the idea
10:50:01 <coppro> *It
10:50:05 <Zemyla> It's a lot of complexity for probably not much gain.
10:50:08 <Cale> coppro: Well, these lisp macros are also entirely compile-time...
10:50:23 <EvanR> Zemyla: yeah, tokens are so passe
10:51:05 <coppro> Cale: have you used IfCxt?
10:51:11 <Cale> no
10:51:30 <ertesx> with TH there is a clearly distinct meta level‚Ä¶  in lisp there is no such distinction, so a program can invoke a macro, which can generate and run code that itself invokes macros, etc.
10:51:51 <Cale> So really, what we're doing here is just:
10:52:10 <ertesx> and i'm not going to say that this is a bad idea‚Ä¶  it would be a bad idea in haskell, but lisp is designed around that principle
10:52:11 <EvanR> ertesx: reader macros...
10:52:26 <Cale> alambda (...) -> fix (\self -> ...)
10:52:45 <Cale> I think this should be easy enough :)
10:52:46 <simpson> This isn't a Good Thing about Lisps, but rather a Bad Thing; meta-levels should be clearly marked.
10:53:14 <guest`> i have this working: factorial = $(afix [| \a-> if a == 0 then 1 else (*) a ($self (pred a))|])
10:53:42 <Cale> Yeah, that looks about right
10:53:56 <guest`> afix = \f->[| fix2 (\sel-> $f) |]
10:53:57 <ertesx> my experience with lisp is too limited to truly judge how well it works and what caveats there are
10:53:59 <guest`> self = dyn "sel"
10:54:27 <EvanR> reader macros are like TH, i think
10:54:31 <Cale> err... that's not quite how I expected it to look
10:54:36 <bumpkin> simpson, why is that?
10:54:51 <Cale> But depending on what fix2 is, perhaps fine
10:55:00 <Cale> Whatever works, of course
10:55:18 <guest`> you can use fix from Data.Function (fix) also
10:55:33 <Cale> > fix (\self -> (\n -> if n == 0 then 1 else n * self (n-1))) 10
10:55:35 <lambdabot>  3628800
10:55:53 <simpson> bumpkin: It's a long argument that I haven't made clean, but basically, when reading code, you establish a context in your head for the code that you're reading.
10:56:45 <simpson> bumpkin: And if you bump down a meta-level, you have to establish a meta-context. And for each meta-level, the precise nature of the meta-context varies with the macros used to create the meta-level, so you have a *jargon* problem where you must know the macros being used intimately before you can read the code at the original meta-level.
10:57:44 <bumpkin> simpson, ah okay so the issue is mainly making the code easier to read/understand?
10:58:07 <simpson> To fix this, meta-levels need to be clearly delineated, like TH brackets in Haskell, bangs in Rust, quasiquotes in Monte, etc. They also should be clearly marked with *which* kind of meta-level you're descending into; Haskell and Monte both allow for tagging quasiliterals to make it clear how they'll be parsed and interpreted.
10:58:20 <simpson> bumpkin: Yes. Readability's pretty important; code is usually written once and read many times.
10:59:03 <EvanR> bumpkin: instead of asking what some code does, it would be nice to get an answer for "what does this code mean"
10:59:16 <EvanR> which is made hard by stuff like runtime AST munging macros
10:59:20 <bumpkin> simpson, right I hadn't thought about macros effect on readability.  I'm not super familiar with Lisp aside from messing around with ithere and there
10:59:25 <bumpkin> EvanR, makes sense
10:59:37 <EvanR> because what it means can quickly devolve into explaining how the runtime system works
10:59:40 <EvanR> which sucks
11:00:32 <simpson> bumpkin: My server's down, so I can't link you to my full argument, but I generalize past macros and into *any* meta-system which is fully inside the larger system. In particular, C++ templates also have this meta-level, meta-context, jargon-inducing effect.
11:00:36 <EvanR> what sqrt does is not as interesting as ... "returns the square root of the argument"
11:00:38 <ertesx> i'm not a big fan of lisp, if only for the fact that the syntax is too overloaded:  (f (g x)) vs. ((f (g x))) vs. '(f (g x))
11:00:50 <ertesx> and either of those could literally mean anything when f or g are macros
11:01:10 <ertesx> the fact that there are no types to guide you don't make things better for me
11:01:35 <bumpkin> ertesx, sure, if you called your functions f and g.  descriptive names would make it a little better at least
11:01:51 <bumpkin> s/functions/macros
11:02:01 <EvanR> yes for having minimal syntax, real lisp tends to have a ton of tacked on extra syntax struggling to deal with itself
11:02:05 <ertesx> bumpkin: even if 'f' were clearly a macro you would have the problem that you don't know what the (g x) means
11:02:36 <Xandaros> bumpkin: I have used an undocumented function with an obscure name in haskell before. I still have no idea what it exactly does, but the types lined up and it happened to do exactly what I needed
11:02:40 <ertesx> lisp is not syntax-free as lispers like to claim‚Ä¶  it's just that the syntax is expressed through the lisp meta-syntax, which makes it highly indirect
11:03:05 <bumpkin> ertesx, yeah I'm starting to feel that way about types.  I'm coming from Python primarily where I liked the lack of types, but after working in a large sloppy code base where you have no idea what the funciton really needs as arguments, i'm starting to appreciate types
11:03:22 <Xandaros> I'm not saying undocumented functions with obscure names are a good thing, but types can go a long way
11:03:32 <bumpkin> Xandaros, I agree
11:03:38 <simpson> Xandaros: The key part there is not that the types lined up, but that it happened to do exactly what you needed; that's likely to be because functions tend to have common uses. The types are just reassuring you that you picked the right undocumented utility function.
11:04:10 <Xandaros> Found it: https://hackage.haskell.org/package/frpnow-0.18/docs/Control-FRPNow-EvStream.html#v:foldBs
11:04:11 <EvanR> sometimes you can guess what it does with just the types, which is awesome when possible
11:04:13 <simpson> bumpkin: Well, nobody uses zope.interface. You can build big codebases with Python, but for some reason most of the Python world doesn't really like using good tooling.
11:04:14 <ertesx> bumpkin: i think the main reason people like non-static languages is that most type systems are terrible
11:04:37 <Xandaros> So, it's not ‚Äòundocumented‚Äô... merely terribly so
11:05:18 <ertesx> bumpkin: and of course the usual friend/marketing bias
11:06:10 <simpson> ertesx: My main reason is that the network is fundamentally untyped and languages should bake in their networking support to a certain degree.
11:06:21 <bumpkin> simpson, yeah I've worked with Twisted a bit and liked the zope.interface there.  I think people consider that to be 'un-Pythonic' whatever that means
11:06:44 <simpson> bumpkin: I live on the Twisted arm of the Python galaxy, and from that POV, most of the Python world doesn't know how to write good code. :c
11:06:53 <bumpkin> and non-static languages are probably easier for beginners, because you don't have to first worry about what types are, what an int vs unsigned int vs long, etc is
11:07:09 <bumpkin> I know that really confused me starting out
11:07:21 <EvanR> simpson: can you elaborate on this idea of fundamentally untyped?
11:07:27 <ertesx> simpson: sometimes i'm bothered by the fact that haskell has so little builtin‚Ä¶  even Text is in a separate library‚Ä¶  but then i find that the extra effort boils down to adding a library dependency in my cabal file‚Ä¶  it's not too bad to have a minimal language
11:07:57 <simpson> EvanR: Sure. Let's say that you have a bytestring. That bytestring is semantically opaque; it could represent many different things, depending on the context in which it is interpreted.
11:08:15 <bumpkin> simpson, the more I see of things, I think you might be right.  but it might also be true to say that most programmers don't know how to write good code.  i'm trying to improve at least :)
11:08:21 <ertesx> simpson: that's true for most system resources
11:08:29 <EvanR> simpson: but, you have the same issue for the underlying runtime system
11:08:36 <simpson> EvanR: So the process of deserializing it into a live value requires that we infer some semantic meaning from that bytestring.
11:08:48 <bumpkin> also I'm starting to believe quality of open-source code is greater than closed-source (from what i've seen of closed source)
11:08:51 <ertesx> for example linux is fundamentally stringly typed‚Ä¶  a language with a good type system can help sort out this mess
11:08:59 <ertesx> if you decide to take what it offers, of course
11:09:07 <ertesx> you could just use a non-static language
11:09:33 <simpson> ertesx, EvanR: Sure, this happens on file formats as well. We have to make some sort of previously-informed guess as to the nature of the bytestring, and that guess is usually made by recursively examining and rediscovering the structure encoded within the bytestring.
11:10:34 <ertesx> i'd argue that non-static languages don't provide an advantage over static ones, except perhaps that they are easier to implement, but that's not my business
11:10:39 <EvanR> simpson: so theres an aspect of filesystems which involves ByteString blobs, and the payload of internet protocols is a ByteString
11:10:49 <simpson> ertesx, EvanR: Here's the thing: Haskell requires you to *know*, with absolute certainty, the type of the value that is being loaded. There's no room for extensibility, no dynamic reflection. Any kind of structure that is in the bytestring, but not in your type, must be manually added in by the programmers.
11:10:55 <EvanR> which is just another type
11:11:03 <ertesx> simpson: it doesn't require that
11:11:15 <EvanR> protocol details have structure, the file system itself has structures
11:11:16 <ertesx> i can *easily* use dynamic typing in haskell
11:12:13 <EvanR> simpson: juicy-pixels is a good example of a library that doesnt require you to know exactly whats being loaded
11:12:30 <EvanR> its pretty cool
11:12:39 <ertesx> but i use it only where it makes sense:  if i get a binary blob from the network that i could interpret in multiple different ways, then i do that, potentially with separate types‚Ä¶  that's dynamic typing
11:12:54 <EvanR> it boils down to what kind of logical statements you want to establish about the data
11:12:59 <Xandaros> ertesx: HashMap Text Dynamic? :D
11:13:05 <ertesx> ;)
11:13:16 <EvanR> it doesnt need to necessarily mean a parser successfully converts to a particular record
11:13:31 <EvanR> theres many kinds of assertions to make about a bytestring
11:13:35 <simpson> EvanR: Every time you disassemble a frame of meaning in JP, you've asserted that the thing that was framed was an image of a filetype that you recognized.
11:14:12 <EvanR> JP?
11:14:15 <EvanR> oh juicypixels
11:14:16 <simpson> JuicyPixels.
11:14:30 <ertesx> simpson: here is dynamic typing at work:  either f g . parse
11:14:45 <Squarism> how do i get started with hunit? Like i know how to load my "project" with cabal repl, but i dont know how i should add my tests to the .cabal file?
11:14:45 <EvanR> it exposes basically images of the raw data
11:15:16 <EvanR> it doesnt need to exactly match a format, all you care about is the pixels
11:15:44 <simpson> ertesx: Is it possible to write a useful Haskell action of type (forall a. Get a) or (forall a. Put a) in cereal or binary? I don't think so but am happy to be proven wrong.
11:15:57 <EvanR> this idea of "fundamentally untyped" = ByteString is interesting, i want to explore further
11:16:01 <ertesx> simpson: now, but what would be the use?
11:16:20 <ertesx> simpson: it's well possible to write Get (Either A B) and Put (Either A B)
11:16:26 <simpson> EvanR: Not BS.ByteString, but a string of octets. On the network. Or from any async source; the disk does just as well.
11:16:37 <ertesx> s/now/no/
11:16:48 <EvanR> simpson: yes byte string
11:16:55 <simpson> ertesx: So, that's what I'm saying; dynamic typing means having the power to read and write references to objects with types that you've never heard of.
11:17:13 <simpson> ertesx: You've already declared that your program will only handle things of type B.
11:17:46 <EvanR> simpson: theres a category of encodings, you can encode data of type A as type B, and data of type B as type C. but at no point do you run out of options and youre at the bottom, in which it cant be encoded in something further
11:17:49 <ertesx> simpson: that's possible in haskell as well, and the rationale is simple:  in a non-static language, while you don't know what type you get, you're making certain assumptions like what operations you can perform on them
11:17:56 <simpson> ertesx: It's fine that you dynamically, at runtime, checked to be certain that your input was of type B, but in the process of recovering that type information from the bytestring, you threw away the possibility that it might be something else.
11:17:57 <ertesx> simpson: the same is possible in haskell
11:18:41 <EvanR> the ByteString is encoded in disk-specific protocol, which is encoded in magnetic domains
11:18:55 <EvanR> the arrangement of domains can be encoded 
11:18:55 <Squarism> cant you just Define class UnheardOf and make all instances throw execptions when you try to regard them as something you understand?
11:18:58 <ertesx> simpson: here is an extreme example:  data Something = forall a. (Monoid a, Show a) => Something a
11:19:09 <simpson> ertesx: No, there exist dynamic languages with totally uniform calling conventions. In those languages, *all* possible operations are available on all values.
11:19:15 <EvanR> this picture seems far from fundamentally untyped ;)
11:19:44 <ertesx> simpson: what is "all possible operations"?
11:19:57 <simpson> EvanR: What's "fundamental" about it is that I can invent a very large number (somewhere between set and proper class) of values that cannot possibly be in any types that you know of.
11:20:14 <EvanR> simpson: i dont understand, what?
11:20:37 <simpson> ertesx: e.g. message-passing languages have one operation, the message pass, and it can be done on any object. If all values are objects (common in those languages), then all values can have all operations done to them.
11:21:08 <ertesx> simpson: we have that, too: IO
11:22:01 <ertesx> newtype Something = Something { call :: MethodName -> MethodArgs -> IO MethodResult }
11:22:02 <simpson> ertesx: Haskell has things, like functions, that cannot be applied to all values.
11:22:24 <simpson> ertesx: Yes, you can implement a dynamically-typed environment within Haskell. That's not what I'm talking about.
11:22:55 <EvanR> simpson: its clear that we have an unlimited ability to reencode (typed) data as data of another type, decoding can fail, but it doesnt seem like any particular level is the fundamental
11:22:59 <ertesx> simpson: then, please, what is it that you're talking about?  i have no idea‚Ä¶  you can implement smalltalk-style message passing in haskell
11:23:12 <simpson> ertesx: But you have to implement it. It's not part of how Haskell types work.
11:23:36 <ertesx> simpson: you have to implement forM_, too
11:23:39 <simpson> I'm saying that the network embodies this dynamically-typed way of thinking, and you're saying that it's possible to emulate that way of thinking in Haskell.
11:23:46 <ertesx> and that 'if' is a language feature is just a historical accident
11:24:12 <EvanR> no i dont think encoding and decoding implies dynamic typing
11:24:17 <ertesx> haskell allows you to build abstractions and makes it cheap to do so‚Ä¶  so if you want smalltalk-style dynamically typed message passing, you can do it
11:24:23 <simpson> My advocacy for dynamically-typed environments is based on the desire to have a *native* way to interact with the network, rather than emulating dynamic types.
11:24:43 <simpson> ertesx: I could also implement Haskell in Smalltalk. Would you consider that the same as adding static typing to Smalltalk?
11:24:53 <ertesx> simpson: no, because that would be difficult
11:24:54 <EvanR> why does octet streams imply dynamic typing? 
11:25:03 <ertesx> simpson: it wouldn't be a one-liner like my example
11:25:12 <simpson> ertesx: So why is implementing Smalltalk in Haskell the same as adding dynamic typing to Haskell?
11:25:22 <ertesx> it isn't
11:25:25 <simpson> EvanR: They're opaque and you have to discover their structure.
11:25:49 <EvanR> they dont have inherent structure beyond the bytes
11:26:08 <ertesx> i'm just telling you:  you can make a (small!) type Something and return that from a network parser
11:26:15 <EvanR> nevermind that point, i was asking about dynamic typing
11:26:27 <EvanR> i.e. data with a runtime type tag
11:26:30 <simpson> ertesx: But you still haven't recovered (forall a. Get a).
11:26:39 <ertesx> simpson: why would i?
11:26:42 <simpson> EvanR: Doesn't have to be that way. It might have *no* type tag.
11:26:55 <ertesx> simpson: the type doesn't make sense
11:27:00 <EvanR> dynamic type systems have to have that
11:27:11 <simpson> ertesx: Because dynamically-typed languages get to do that. They get to divine structure from values without knowing the type.
11:27:23 * EvanR shakes head...
11:27:26 <simpson> EvanR: No, they don't. Type tags do not have to be reflected across the wire.
11:27:34 <simpson> EvanR: Only *messages* have to be reflected across the wire.
11:27:44 <EvanR> sorry, im just trying to zero in on one thing at a time
11:27:55 <EvanR> youre bringin up a lot of different ideas at once
11:28:06 <ertesx> simpson: what's wrong with parserA <|> parserB <|> parserC?
11:28:19 <ertesx> each returning a Something on success
11:28:59 <Squarism> anyone, what is the proper way to add tests to your project (.cabal file?) and easily run the tests
11:28:59 <Squarism> ?
11:29:17 <ertesx> Squarism: look at the cabal file of any popular library like 'lens'
11:29:25 <Squarism> ok
11:29:25 <EvanR> simpson: it is possible for a system to have a component that requires data to be encoded in a certain type, such as JSON, a ByteString, XML, etc
11:29:30 <simpson> Squarism: http://stackoverflow.com/questions/1044555/how-can-i-set-up-a-simple-test-with-cabal appears to be a good jumping-off point.
11:29:38 <EvanR> so you have to do an encoding decode dance
11:29:47 <EvanR> but that doesnt mean its untyped
11:30:00 <simpson> EvanR: Sure. But in JSON and XML, there's this tree structure, right? And then the tree's elements have keys and expected types... so you've got these schemata which exist outside of the message.
11:30:04 <EvanR> or that one of those types is the fundamental
11:30:07 <simpson> EvanR: Those schemata are a sort of *type*!
11:30:45 <simpson> ertesx: Nothing's wrong, but you're still imposing a requirement about the structure of the value which might be too opaque for that kind of introspection.
11:31:10 <ertesx> simpson: i don't understand‚Ä¶  *somewhere* in your program it must be encoded as what the string might parse
11:31:49 <EvanR> simpson: JSON, XML, and ByteString has three different structures. you can encode as them, or encode them as each other. 
11:31:55 <ertesx> and i've presented you an extensible, least-assumptions method to add encodings as you learn about them‚Ä¶  apparently that still doesn't make you happy, so i don't know what will
11:32:03 <ertesx> seriously i do not understand what is missing
11:32:39 <simpson> ertesx: The ability to decode a value which cannot possibly be an inhabitant of any type that you know about but is nonetheless an implementor of the meta-object protocol which you speak.
11:32:54 <EvanR> all three are equally "opaque" and none of them are equal to your original
11:33:14 <EvanR> you have to decode, which could fail
11:33:17 <ertesx> simpson: you have issues with my approach because i have this concrete type Something‚Ä¶  but it does represent exactly what you're talking about
11:33:19 <simpson> Don't worry about "making me happy". I'm perfectly happy, just not with Haskell. And it's not like Haskell can fix this.
11:33:37 <ertesx> you're just insisting that there must be a haskell type i don't know about, and that a parser should be able to return something other than Something
11:33:41 <ertesx> but it will never need to
11:33:44 * hackagebot bytestring-progress 1.0.6 - A library for tracking the consumption of a lazy ByteString  https://hackage.haskell.org/package/bytestring-progress-1.0.6 (AdamWick)
11:33:46 <ertesx> because Something captures *everything*
11:33:51 <ertesx> i can't make this any clearer
11:34:25 <simpson> ertesx: I'm saying that, in Haskell, this particular arrangement is *not possible*. It's not a big deal, but it means that there's a certain kind of essential extensibility which can't be achieved.
11:34:49 <ertesx> simpson: to what can't you extend Something?  it covers *everything*
11:35:00 <EvanR> simpson: i would like to understand your second thesis statement, the first one i understood to be "network / filesystem is fundamentally untyped". is the second one "network / filesystem requires dynamic typing techniques" ?
11:35:10 <ertesx> any protocol you might ever come up with with any behaviour you might ever come up with can be encoded as a Something
11:35:15 <ertesx> yes, it will be a Something‚Ä¶  always‚Ä¶
11:35:29 <ertesx> but that Something can represent anything
11:35:55 <EvanR> i also didnt understand the infinite universe of values that are not in some type
11:35:58 <ertesx> like it has that implicit type tag you're insisting it must have (for whatever reason)
11:37:00 <simpson> ertesx, EvanR: There's more categories than just Hask out there.
11:37:12 <ertesx> so?
11:37:13 <EvanR> i wasnt implying haskell is necessarily good at anything
11:37:28 <EvanR> i am specifically considering the problem from outside haskell
11:37:36 <EvanR> just trying to understand what youre saying first
11:37:49 <simpson> ertesx, EvanR: Let's say that you have a system that acts only by encoding references. Objects are never on the wire, only references to them. Nonetheless, it's still possible to pass messages to objects by reference. In this scheme, what do you actually know, type-wise, about any object?
11:37:51 <ertesx> and i'm considering it from inside of haskell
11:38:09 <ertesx> simpson: it's an Object
11:38:13 <ertesx> nothing else
11:38:32 <EvanR> were talking about actors right
11:38:38 <simpson> ertesx: And yet there's definitely some sort of internal structure to objects which is opaque, right?
11:38:45 <ertesx> simpson: sure
11:38:47 <simpson> EvanR: Sure, when I say "object" you can think "actor".
11:39:11 <EvanR> alright, well in the only actor model i know they use a unityped message universe
11:39:18 <simpson> ertesx: There you go. Haskell's encoded `data Obj = Integer`, and can speak the lingua franca, but the type fails to reflect any information about the structure of the object.
11:39:24 <EvanR> you pick the universe and go with it
11:39:50 <EvanR> because actors can change their mind what they respond with, it seems hard to have different types
11:39:55 <ertesx> simpson: why does it have to reflect anything about the internal structure?
11:40:07 <EvanR> but what does this have to do with the previous discussion
11:40:14 <ertesx> all you need is the assumptions you make about objects
11:40:26 <ertesx> an Object might as well just hold an arbitrary IO action
11:41:02 <simpson> ertesx: Because that object might well be something structured, like an XML document or JSON blob. And those objects themselves might have schemata or other structures.
11:41:32 <simpson> But none of that can be reflected into Haskell at runtime without committing a finite number of types which can only cover a finite amount of the possibilities.
11:41:36 <EvanR> ertesx you are focusing too much on how things would be implemented in haskell to respond to simpson, who seems to be focusing on how things are implemented in some dynamically typed language
11:41:55 <ertesx> simpson: i need precisely one type to capture all of that‚Ä¶  i don't know why you insist that there must be multiple types
11:42:04 <ertesx> EvanR: yeah, i guess
11:42:07 <simpson> EvanR: No worries, we're working it out. That's what conversation is for: Not just talking, but learning to talk.
11:42:33 <ertesx> simpson: my point is that such a thing is possible and *easily* possible in haskell‚Ä¶  just the approach is different
11:42:50 <simpson> ertesx: Well, earlier we were talking about Either A B, where B's the types that you know how to handle and A is some error message.
11:43:17 <ertesx> simpson: yes, and that's limited to A and B
11:43:36 <ertesx> but there is no reason to have that limit
11:43:38 <simpson> My point is that if you pick B to be something like Integer or ByteString, you've gotten to the surface level and you can communicate, but you can't assign richer types to any internal structure that might be lurking.
11:43:44 * hackagebot diagrams-rasterific 1.3.1.7 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.7 (BrentYorgey)
11:44:04 <ertesx> there are ways to handle infinitely many types:  one is to capture their essence in a single type
11:44:10 <EvanR> so if you have actors that communicate with a single type, you have to encode and decode everything to from that type
11:44:17 <simpson> But if you pick B to be something really rich, like some XML doc with a schema, then you can recover the structure, but at the expense of giving up on being able to handle any other kind of object.
11:44:30 <Cale> ertesx: There is definitely value in identifying one of the types as "success" though.
11:44:42 <simpson> In a message-passing dynamically-typed language, you can have both, because you're not limited to compile-time type listings.
11:44:43 <ertesx> Cale: you can capture that as well
11:44:50 <ertesx> it just doesn't have to be a *haskell type*
11:45:08 <EvanR> simpson: perhaps were using different notions of type?
11:45:12 <Cale> Well, it's not even just one of the types, but one of the positions in which a type can occur, rather
11:45:44 <ertesx> you can have all of that‚Ä¶  the only difference is that you need something to encode all that information, which can be a type
11:45:51 <EvanR> simpson: are you thinking that a dynamic type is like (Tag, XML) ?
11:45:53 <ertesx> in languages like smalltalk all of this is builtin
11:46:06 <ertesx> but it's easy enough to implement in haskell if you need to
11:46:13 <Cale> If you want larger variants, they're quite doable, yeah
11:46:25 <simpson> EvanR: This works fine if we stick with type theory. (I personally prefer set-theoretic type systems for obvious reasons.) The idea is that there's some type, floating out there in Hask, which *would* work great for whatever value you're decoding, but which your program doesn't know about.
11:46:47 <Cale> The last type parameter being the one with respect to which the thing is a Functor/Applicative/Monad/Traversable/etc. is nice though, so you may still want the Either, and just put a larger variant in the first argument to it :)
11:47:12 <ertesx> simpson: i think your main problem is that you want to encode it as multiple *haskell types*
11:47:25 <Cale> There is also the approach taken by Control.Exception, using runtime type information for nicely extensible variants.
11:47:44 <ertesx> Cale: if you want to go all the way, you can even invent something like a recoding Dynamic that allows interpretation as multiple different types
11:47:57 <ertesx> personally i have never needed that, but i can see how in some scenarios that would be useful
11:47:58 <Cale> Well, that's kind of what SomeException is
11:48:04 <ertesx> yeah
11:48:13 <ertesx> in any case, it's possible and easily possible in haskell
11:48:22 <Cale> It's possible to implement new instances of Exception which filter and transform existing exception types
11:48:24 <maerwald> the question is if it's a good idea
11:48:35 <ertesx> but there will be an umbrella type like SomeException for exceptions
11:48:41 <simpson> ertesx: Well, yeah. The entire approach works great in Monte or any other Smalltalk descendant.
11:49:16 <simpson> ertesx: I'm not asking for how to build this sort of system in Haskell. I'm pointing out that this system works at the ground level in dynamically-typed languages, but that in statically-typed languages you have to build dynamic typing first.
11:49:16 <ertesx> simpson: don't get me wrong, it requires some initial engineering‚Ä¶  it's not *free* in terms of programmer time
11:49:31 <ertesx> but it's possible and cheap enough, if you need it
11:49:39 <Cale> simpson: Wait, what were the obvious reasons that you preferred set theoretical systems? Also, what is an example of such a system?
11:49:43 <EvanR> if actors agreed on (Tag, XML) you would still have to do encoding and decoding, either because you are haskell or because you are validating in a dynamic language... 
11:49:43 <EvanR> its equal to using ByteString, or anything as the one medium type
11:49:43 <EvanR> but heres a way out of this, if you consider the universe to have different regions where actors have a medium type local to that region, and they only convert at special boundaries (encoding or decoding as necessary), you recover non unityped stuff globally ;)
11:49:43 <EvanR> that models the network being ByteString, HTTP being HTTP, etc
11:49:43 <EvanR> and an application using JSON
11:49:59 <Cale> whoa, EvanR, 5 of your messages came through at once there
11:50:14 <ertesx> simpson: also this is one particular problem where this is useful‚Ä¶  most of your program doesn't look like that, and i'd argue that even most of your network code wouldn't look like that
11:50:26 <EvanR> you can imagine another region where they chose Integer, or Either Char (Int, Bool)
11:50:37 <simpson> Cale: It's just easier to work with "types" in my type system as being subsets rather than types. I know that it's not as cool at HoTT or whatever, but I'm not a very cool person.
11:51:19 <simpson> ertesx: Actually, *most* of the networking code is precisely the plumbing required to make the generic stuff work, transparently forwarding messages onto the network.
11:51:20 <Cale> simpson: Usually the trouble you run into is that type inference doesn't work out so well.
11:51:22 <pikajude> Semigroup is Monoid without mempty, right?
11:51:52 <ertesx> pikajude: Semigroup is Monoid with optional mempty
11:51:54 <Cale> Then again it also doesn't work terribly well for dependent type theories.
11:52:00 <simpson> Cale: Yep. The average Haskeller would be horrified at how loose the type inference and type annotations are for Monte.
11:52:01 <pikajude> is there a typeclass that represents just mempty?
11:52:23 <ertesx> pikajude: such a class would be highly arbitrary, but there is: in the 'default' library
11:52:23 <pikajude> class Empty f where empty :: f a
11:52:27 <EvanR> simpson: dang i had huge lag... i got left behind. a set theory-based type system is a subset of what im talking about, so it still applies. I'm not sure what the obvious reason is youre referring to ?
11:52:38 <maerwald> pikajude: not sure what you are looking for, but there is also "Default"
11:52:39 <simpson> Cale: FWIW even just recovering set-based rules for manipulating Monte types is above and beyond what the original E project did. I *want* to be rigorous. It's hard.
11:52:46 <Cale> EvanR: I think you still might have huge lag :)
11:52:55 <EvanR> :(
11:53:07 <Cale> okay, maybe not so much now
11:53:08 <maerwald> > def :: [Int]
11:53:09 <lambdabot>  []
11:53:23 <maerwald> > def :: Maybe Int
11:53:24 <lambdabot>  Nothing
11:53:34 <ertesx> pikajude: mempty is really meaningless, unless it is "empty" with respect to something‚Ä¶  it's just an arbtrary value (which is the reason i don't like Default)
11:53:40 <simpson> EvanR: In Monte, for any set of objects, I can write a *guard*, a type that precisely delineates the set. I can also, for any set of guards, produce an object that is in none of their sets. I don't think that type theory deals well with this.
11:54:20 <ertesx> simpson: it's not type theory that has to deal with it, but a library
11:54:26 <EvanR> simpson: im not familiar with how monte handles types, or what guard means
11:54:43 <simpson> EvanR: A guard's just an object that precisely delineates a set of objects.
11:54:54 <EvanR> simpson: but is there some common subtrate which objects are made of, like record of primitive types?
11:55:11 <EvanR> and guards check existence of fields?
11:55:29 <simpson> EvanR: There's the uniform message-passing operation, and that's it. The exact mechanism by which guards like Int work is unspecified.
11:55:49 <EvanR> they are like propositions on objects?
11:55:58 <ertesx> simpson: all of what you're saying comes with certain assumptions with respect to a certain type T:  1. there is a guard system for T, 2. values carry tags (you may call them "types"), 3. values can be *created* in some way, etc.
11:55:59 <simpson> The analogy in Haskell would be MagicHash, which exposes how *GHC* does stuff, but not necessarily other Haskell implementations.
11:56:08 <ertesx> simpson: in haskell all of these assumptions are explicit
11:56:20 <EvanR> simpson: you could have an object which is Int and Char ?
11:56:33 <ertesx> simpson: so T is basically a model of the language you're talking about right now
11:56:45 <simpson> EvanR: Well, those two are distinct.
11:56:49 <ertesx> and once you have T, writing a T program will not look much different from that language
11:56:58 <EvanR> simpson: .. then im not getting it yet
11:57:23 <EvanR> can two guards apply at once?
11:57:25 <ondrejs> hello. Anyone using the brick terminal UI library? Is it possible to make text use bold font?
11:57:37 <simpson> ertesx, EvanR: I'm gonna drop this. We've covered a lot of ground but nothing's sticking. If you're interested, there's #monte, but I'm gonna stop being so off-topic. Sorry.
11:58:37 <ertesx> simpson: alright, just one last remark: what you're really asking for is a DSL for monte, and i'm telling you that it's possible‚Ä¶  it may not be easy or even useful (you use different idioms in haskell), but it's possible and only needs to be done once
11:59:10 <ertesx> and in that DSL *monte types* will not map to *haskell types*
11:59:15 <EvanR> ertesx: yes but i think the point is to make something easy and useful ;)
11:59:26 <ertesx> because they have different ideas of what a "type" is
11:59:27 <simpson> ertesx: I'm afraid that you have completely missed the point of everything that I have said. I'm sorry that I misled you.
11:59:55 <ertesx> simpson: i don't think so‚Ä¶  i'm just failing to express myself properly
12:01:29 * EvanR is perhaps the only one who gained something from the dispute ;)
12:01:56 * EvanR goes to think about actors dealing with their 1 type
12:01:59 <Cale> I entered the discussion somewhere in the middle and missed most of it I think.
12:02:09 <EvanR> i missed the last chunk
12:02:09 <Cale> I don't even know what you were originally talking about :)
12:02:40 <ertesx> Cale: modelling dynamic choice
12:02:48 <EvanR> "what the bytestringed nature of filesystems and sockets has to imply about programming techniques, type systems"
12:02:56 <Cale> Some of the previous discussion sounded to me like "really wants Sigma types"
12:03:01 <ertesx> Cale: OOP basically, but the original
12:03:28 <EvanR> dynamic choice is kind of a vague descriptor for it
12:03:36 <Cale> i.e. the whole part about being able to restrict one's view to just those objects satisfying a given property
12:03:40 <ertesx> that's why i qualified =)
12:04:39 <EvanR> Cale: sounds like decoding
12:05:03 <ertesx> i think the main problem is that we had different ideas of what a "type" is‚Ä¶  apparently monte is computing with types and their properties at run-time
12:05:09 <Cale> It's just pairing the objects with proofs that they satisfy the property
12:05:15 <EvanR> ertesx: yes, monte is dynamically typed
12:05:21 <Cale> and then you get back the original things by discarding the proof
12:05:53 <ertesx> EvanR: yeah, but specifically in the smalltalk idiom with messages and everything
12:05:59 <Cale> and that "proof" may in general be quite an interesting piece of data in its own right
12:06:00 <ertesx> so basically the original OOP
12:06:04 <EvanR> yes, its meant for distributed programming
12:06:09 <EvanR> like erlang
12:06:15 <EvanR> actors
12:06:38 <ertesx> i'll disregard haskell's builtin concurrency, because this isn't really related
12:07:03 <Cale> Speaking of OOP and dependently typed languages, has anyone else seen the stuff on copatterns? It's pretty cute.
12:07:04 <EvanR> yah haskells built in concurrency doesnt work over the internet ;)
12:07:19 <Cale> http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
12:07:53 <EvanR> sigma types seems interesting
12:08:18 <ertesx> EvanR: sigma type = dependent sum
12:08:33 <ertesx> you've probably seen it before
12:08:35 <Cale> Basically the idea is that you get to define values of a coinductive type based on how the projections act on them. i.e. from an OOP point of view, to define an object it suffices to say how it responds to each message that it accepts
12:08:42 <simpson> Cale: A whitepaper! My one weakness! I guess that I am not eating lunch quite yet.
12:08:45 * hackagebot pgdl 9.3 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-9.3 (sifmelcara)
12:09:04 <Cale> So, they let you write cute things like
12:09:26 <ertesx> Cale: do you mean stuff like 'fst (swap (x, y)) = y'?
12:09:29 <dolio> Are functions OOP now?
12:09:34 <Cale> runState (x >>= f) s = let (s',v) = runState x s in runState (f v) s'
12:09:44 <Cale> ertesx: yeah
12:09:54 <shachaf> dolio: They're OP, that's for sure.
12:09:56 <EvanR> ertesx: oh duh
12:10:08 <Cale> dolio: coinduction is OOP
12:10:17 <ertesx> yeah, i've seen it before and thought it's nice, but i've never quite found myself in a situation when i thought it would be nice to have
12:10:18 <simpson> Cale: That's an interesting viewpoint. I like the projective analogy; I've heard of the object as pumpkin, where it is an opaque gourd but you can shine light on it from various angles to visualize various behavioral facets.
12:10:19 <dolio> So that's a yes?
12:11:11 <maerwald> burritos... now pumpkins, uh
12:11:13 <simpson> Cale: What's interesting is that, from that analogy, different Smalltalk flavors have different ideas of which kinds of "light-shining" introspection you can do on arbitrary objects.
12:11:19 <tnks> dolio: ‚ÄúOne conclusion you could draw from this analysis is that the untyped Œª-calculus was the first object-oriented language.‚Äù
12:11:39 <dolio> Haskell function definitions are geared toward allowing you to say how they behave when you apply them, which is how you 'observe' them. So functions are defined by the observations on them.
12:11:46 <Cale> Yeah
12:11:50 <dolio> Thus OOP.
12:12:14 <Cale> Functions are objects with a single method and vice-versa
12:12:18 <hpc> simpson: if an object is a pumpkin then what is a copumpkin?
12:12:27 <Cale> haha
12:12:28 <hpc> dang, he's not here right now
12:12:39 <EvanR> simpson: the light shining thing is the normal case of functions on types, each application of a function is some image of the object. but perhaps i dont know what "seeing their behavior" differently means
12:12:43 <tnks> that quote was from Cook's ‚ÄúOn Understanding Data Abstraction, Revisited‚Äù writeup, which is the only discussion of objects that I found useful.
12:12:50 <EvanR> behavioral facts from different angles
12:12:57 <shachaf> dolio: What isn't defined by the observations on it?
12:13:04 <tnks> largely because it was so minimal, there wasn't much to it.
12:13:04 <simpson> Ruby, Python, and Smalltalk all let you slice open objects and examine all of their parts; E and Monte only have a few designated introspective facets. One flashlight for printing/Show, one for sealed dispatch, one for concurrency management, but not one for e.g. getting the private closure.
12:13:07 <dolio> shachaf: Inductive things.
12:13:33 <Cale> shachaf: Well, inductive data are defined not by how you take them apart, but how you put them together.
12:14:11 <simpson> EvanR: I think that dolio said it best. "Functions are defined by the observations on them."
12:14:12 <dolio> And the coinductive things you're describing are products, so they're functions from the label set of projections. Just like inductive types are products with the constructor labels.
12:14:16 <Cale> In many cases there's overlap, and there might be both an inductive and a coinductive approach to defining the same thing.
12:14:38 <EvanR> simpson: yes from the purely functional perspective this makes sense
12:14:43 <dolio> Or, tuples, not 'products'.
12:14:45 <EvanR> but you dont "view" stuff like mutator methods
12:14:58 <EvanR> or email sending
12:15:18 <ertesx> simpson: that's basically what i was saying all the time =)
12:15:20 <simpson> EvanR: Right. There's no way to make "enough" observations of an object to be able to perfectly replicate the object without both the source code *and* the meta-context in which the object was created.
12:16:03 * EvanR likes precise characterizations of OOP
12:16:14 <EvanR> which i havent seen yet when its not purely functional
12:17:01 * EvanR goes to think about encodings and sigmas
12:17:44 <confuzedd> Can someone please explain to me the difference between a golang interface type (protocol) vs generic type parameter vs a haskell type class? The all provide parametric polymorphism, but I struggle to understand the differences between their implementation and power.
12:18:07 <EvanR> type classes are ad-hoc polymorphism, rather than parametric
12:18:11 <Cale> no
12:18:14 <Cale> pls
12:18:17 <Cale> no ad-hoc
12:18:22 <EvanR> lol
12:19:02 <Cale> They're not the same thing as ad-hoc polymorphism, this is a common confusion created by the jokey name of the paper which introduced them
12:19:08 <EvanR> "type classes let you define + on integers to mean addition, and + on strings to mean concatenation. this two thing dont have much to do with each other, which is why its called ad hoc polymorphism" ;)
12:19:11 <Cale> They have overlap in terms of what you'd use them for
12:19:32 <Cale> but anyway, let's answer the question... confuzedd: Type classes let you restrict the types over which type variables range
12:19:41 <Cale> If you have a type like  [a] -> Integer
12:19:45 <hpc> to some extent, type classes aren't polymorphism at all
12:19:50 <EvanR> in any case its not parametric polymorphism
12:19:53 <Cale> the type 'a' is allowed to be any type whatsoever
12:20:07 <Cale> But think about a function which sorts a list
12:20:15 <Cale> It can't quite have type [a] -> [a]
12:20:28 <Cale> because there are many types for which order comparison (<=) makes no sense
12:20:37 <Cale> e.g. functions, IO actions, etc.
12:21:18 <Cale> So we need a way to restrict the type variable 'a' such that it can only be types for which (<=) and the other ordering operations are defined
12:22:37 <Cale> Type classes let us do this: they're effectively predicates on types (something which may or may not be true of any given type), together with a bunch of methods which must be implemented in an "instance" to make the predicate true
12:22:41 <Cale> e.g. there is
12:22:54 <confuzedd> Cale: So type parameters and type classes are generics and protocols respectively? One let's you plug in a type, the other puts restrictions on what type can fit.
12:23:23 <baordog> Sup Haskellers
12:23:35 <Cale> I suppose... I don't know what protocols are, but type parameters are called generics in various other languages.
12:23:49 <Cale> (we also use the term 'generics', but for something else)
12:23:50 <ReinH> confuzedd: Go doesn't have parametric polymorphism.
12:24:03 <ReinH> I wouldn't suggest a one-to-one correspondence between those concepts.
12:24:09 <Cale> Yeah, from what I recall, Go has a serious deficiency in this regard.
12:24:23 <ReinH> I would suggest learning the haskell concepts on their own terms
12:24:27 <ReinH> rather than using faulty analogies
12:24:56 <epsilonhalbe> isn't that true for everything to not learn using faulty analogies?
12:24:58 <epsilonhalbe> ;-)
12:25:05 <confuzedd> Go has interface types, but they are actual types, not traits implemented on a type.
12:25:07 <ReinH> epsilonhalbe: yes, and it's true here too
12:25:12 <Cale> I couldn't work out how to write something analogous to  map :: (a -> b) -> [a] -> [b]  in go, and, well, if that's difficult, then code-reuse in general is going to be difficult, so that's where my interest in go sort of died.
12:25:26 <ReinH> Cale: You can't, because go doesn't have parametric polymorphism
12:25:30 <Cale> right
12:25:31 <ReinH> you have to write n maps for n types
12:25:45 <EvanR> brilliant
12:25:47 <tnks> the way god intended.
12:25:56 <ReinH> It also has nulls that you can't check
12:26:05 <epsilonhalbe> that's why it is called GOd
12:26:22 <tippenein> since there's no bounded instance for Integer, how can I get an identity for 'maximum'
12:26:26 <tippenein> ?
12:26:33 <confuzedd> Does Haskell have a run time cost associated with with type classes?
12:26:34 <ReinH> Cale: it also breaks extract method refactorings because defer breaks beta equivalence
12:26:41 <Cale> tippenein: you can't because there is none?
12:26:51 <hpc> confuzedd: sometimes maybe, but it's very situational
12:26:52 <tippenein> I wanted something like replicate 10 (minBound :: Integer)
12:27:01 <EvanR> > maxBound :: (Maybe Integer)
12:27:02 <lambdabot>      No instance for (Bounded (Maybe Integer))
12:27:02 <lambdabot>        arising from a use of ‚ÄòmaxBound‚Äô
12:27:02 <lambdabot>      In the expression: maxBound :: Maybe Integer
12:27:07 <ReinH> confuzedd: typeclasses are implemented by implicit record passing. It isn't more expensive than the alternative, which is explicit record passing.
12:27:09 <Cale> confuzedd: they never cost you more than a single additional function parameter would
12:27:15 <tnks> I'd hope the runtime cost of static dispatch is no worse than the runtime cost of dynamic dispatch.
12:27:17 <hpc> confuzedd: most times a use of a class method is going to be monomorphic and it'll have the right thing substituted in
12:27:26 <tippenein> I can get -Infinity, but it's a Fractional
12:27:39 <Cale> confuzedd: and sometimes, when the type is possible to determine statically, the compiler may specialise things
12:27:44 <EvanR> tippenein: you can use a newtype to add an artificial upper bound to any type
12:28:00 <EvanR> er... i guess it would have to be data
12:28:17 <Cale> confuzedd: However, it's not *always* possible to do this -- it's even possible to write programs which use a type class at infinitely many different types
12:28:25 <monochrom> tippenein: new GHC comes with Semigroup. maybe you just need that.
12:28:27 <confuzedd> Cale: Would that be the same as monomorphization?
12:28:33 <hpc> confuzedd: there are cases where polymorphism with a class constraint will result in recomputation, but that's very rare unless you go looking for it
12:28:36 <confuzedd> in haskell speak
12:28:41 <pyrtsa> tippenein: For example, https://hackage.haskell.org/package/reactive-0.11.5/docs/Data-AddBounds.html
12:28:53 <Cale> > let foo x 0 = show x; foo x n = foo (x,x) (n-1) in map (foo 0) [0..]
12:28:54 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ (t, t2)
12:28:55 <lambdabot>      Relevant bindings include
12:28:55 <lambdabot>        x :: (t, t2) (bound at <interactive>:1:27)
12:29:10 <hpc> :t fix show
12:29:10 <Cale> > let foo :: (Show a) => a -> Integer -> String; foo x 0 = show x; foo x n = foo (x,x) (n-1) in map (foo 0) [0..]
12:29:11 <lambdabot> String
12:29:12 <lambdabot>  ["0","(0,0)","((0,0),(0,0))","(((0,0),(0,0)),((0,0),(0,0)))","((((0,0),(0,0)...
12:29:18 <hpc> er not that
12:29:20 <Cale> there we go :)
12:29:23 <hpc> yeah that
12:29:40 <epsilonhalbe> @tippenein - the mathematical term for it is called one or two point compactification depending on if you have just infinity or +/- infinity
12:29:41 <lambdabot> Unknown command, try @list
12:29:47 <Cale> this uses arbitrarily many instances of Show, depending on how long you let the program run for
12:31:31 <Cale> confuzedd: Show is a type class which looks like  class Show a where show :: a -> String; ... other stuff ...
12:31:38 <Cale> :t show
12:31:40 <lambdabot> Show a => a -> String
12:31:47 <Cale> > show 5
12:31:48 <lambdabot>  "5"
12:31:51 <Cale> > show [1,2,3]
12:31:53 <lambdabot>  "[1,2,3]"
12:32:01 <hpc> Cale: on some level, it's using just two instances
12:32:11 <hpc> the one for a, and the one for Show b => (b, b)
12:32:13 <Cale> hpc: Right, but it has to use one of them arbitrarily many times
12:32:20 <hpc> yeah ;)
12:32:24 <Cale> It's the one for (Show a, Show b) => Show (a,b)
12:32:35 <Cale> and the one for Integer
12:32:42 <ertesx> > let f :: (Show a) => a -> [String]; f x = show x : foo (Just x) in unwords (f ())
12:32:44 <lambdabot>      Not in scope: ‚Äòfoo‚Äô
12:32:44 <lambdabot>      Perhaps you meant ‚Äòfor‚Äô (imported from Data.Traversable)
12:32:48 <EvanR> doesnt show [1..] "use something arbitrarily many times"
12:32:49 <ertesx> > let f :: (Show a) => a -> [String]; f x = show x : f (Just x) in unwords (f ())
12:32:51 <lambdabot>  "() Just () Just (Just ()) Just (Just (Just ())) Just (Just (Just (Just ()))...
12:32:51 <ReinH> tippenein: you can use a tropical monoid.
12:33:03 <ReinH> e.g., Maybe Integer where Nothing stands in for +Inf
12:33:13 <monochrom> all I know is that the chemistry word for this is polymerization
12:33:21 <Cale> haha
12:33:23 <ReinH> you'd have to use a newtype to give  your own monoid impl though
12:33:36 <Cale> monochrom: btw, when is next TO Haskell meetup?
12:33:45 <monochrom> let me check
12:34:28 <monochrom> Wednesday June 15 6:30PM
12:34:38 <monochrom> https://bentomiso.com/events/haskell-meetup-2016-june
12:35:24 <Cale> I still can't believe that place is not a Japanese lunch restaurant
12:35:56 <hpc> lol
12:36:16 <monochrom> I know right? the first time I went, I brought an empty stomach expecting to order food right there.
12:37:00 <hpc> including miso in bento sounds like a very quick way to spill miso everywhere though
12:37:08 <monochrom> these days I arrive nearby at 5:30PM, dine in a fancy restaurant, then go
12:38:46 * hackagebot diagrams-contrib 1.3.0.11 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.11 (BrentYorgey)
12:39:57 <confuzedd> I have another question, I want to migrate an Erlang app that does TCP routing and uses mnesia as it's datastore to Haskell. The datastore is for persistent routing information stored as erlaterms. What in the Haskell world would be a good choice for a replacement?
12:40:07 <confuzedd> erlang terms *
12:40:18 <EvanR> haha mnesia
12:40:47 <EvanR> confuzedd: acid-state
12:40:53 <EvanR> or a database
12:43:46 * hackagebot dpor 0.2.0.0 - A generic implementation of dynamic partial-order reduction (DPOR) for testing arbitrary models of concurrency.  https://hackage.haskell.org/package/dpor-0.2.0.0 (barrucadu)
12:43:48 * hackagebot dejafu 0.3.2.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.3.2.0 (barrucadu)
12:49:27 <Squarism> so now i have a hunit test up and running. If i have : f x -> IO (), how do write a test where i can verify "interactions" with io monad? Sorry, im new to this.. and this Monad isnt second nature yet
12:49:51 <Squarism> or "rebinds" ? 
12:52:54 <Squarism> i learned type I0 a = RealWorld -> (RealWorld,a). So i guess for a function that does one write and one readLine. I need to mock this behaviour or something 
12:52:55 <osa1> which one do you prefer, (:[]) or return ?
12:53:46 <Squarism> i havent gotten far enought to crate a preference  
12:53:56 <Squarism> ive used return but not (:[])
12:54:14 <EvanR> type IO a = RealWorld -> (RealWorld,a) ? where is this from
12:54:25 <EvanR> it seems wrong
12:56:03 <EvanR> you should be able to test IO actions directly
12:56:49 <Squarism> EvanR, could you examplify
12:57:25 <Squarism> EvanR, https://wiki.haskell.org/IO_inside
12:57:32 <Squarism> about the RealWorld
12:58:04 <hpc> that definition is an even bigger lie than "monads are like burritos"
12:58:20 <hpc> (though probably not quite as harmful)
12:58:31 <EvanR> on second thought, if you made more of your code not IO, you would get more benefits than just testing
12:58:49 <hpc> that definition is ghc-specific, and RealWorld# is a phantom type
12:59:14 <EvanR> Squarism: another way to test IO is to parameterize your code by any monad, then use a dummy IO in the test
12:59:20 <hpc> its only purpose is to make the ordering of actions explicit in a way that things that deal with source code can recognize
12:59:50 <EvanR> myGetPutLine :: Monad m => String -> m String
13:00:14 <Squarism> ah ok
13:00:56 <EvanR> but for many built in IO actions youll need wrappers to make them generic
13:02:06 <EvanR> for many IO actions in libraries, they are already constrained to MonadIO, so your DummyIO would just implement MonadIO class, and no-op everything
13:02:08 <Squarism> EvanR, are there any prexisting
13:02:26 <EvanR> honestly i dont know how well this is really testing anything though
13:02:28 <Squarism> ok
13:02:58 <EvanR> youre better off making as much of your program non-IO as possible
13:03:51 <Squarism> it isnt very io dependent. But the main "control" is done through io 
13:10:32 <Cale> Squarism: That "RealWorld" model of IO is very misleading... it's much better to think of IO as having constructors for the various things an IO action might do first, together with a function saying what to do next based on the result of the first thing...
13:12:05 <Cale> Squarism: for example,  data IO a = Return a | GetChar (Char -> IO a) | PutChar Char (IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...  would be one reasonable way to represent IO actions.
13:12:38 <ReinH> I wish RealWorld in GHC was called something more accurate.
13:12:41 <Squarism> Cale, ok.. ill keep that in mind. 
13:12:56 <EvanR> SequencingKludge
13:12:57 <Cale> ReinH: like Void
13:13:07 <Cale> It's pretty much Void
13:13:50 <Cale> The kludge is just to use "functions" of type Void -> (Void, a), but they're not really functions, they cause effects to occur when evaluated.
13:13:56 <bennofs> RealHack :D
13:14:32 <cschneid> Cale: that's basically the free-monad version of IO right? Where then the runtime is the interpreter?
13:14:41 <Cale> cschneid: yeah
13:15:06 <Cale> You could imagine extending that with some very expressive constructors which gave the details for an FFI call to be made
13:15:33 <Cale> (and then obviously GetChar and PutChar wouldn't need to be primitive)
13:15:34 <shachaf> GHC uses State# RealWorld, not RealWorld.
13:15:56 <ReinH> Cale: btw I might start working on that chess video series. I just used Richard Bird's alphabeta from Intro to FP on a basic evaluation and I can play chess now.
13:15:58 <shachaf> Which isn't uninhabited.
13:16:04 <Cale> shachaf: hm?
13:16:04 <ReinH> (working on it again)
13:16:23 <shachaf> Cale: realWorld# :: State# RealWorld
13:16:30 <Cale> ReinH: Oh, I... don't remember talking with you about that, but I'd be interested in watching it
13:16:37 <ReinH> State# doesn't actually contain state.
13:16:41 <shachaf> Of course not.
13:16:45 <shachaf> But it's more like () than Void.
13:16:49 <Cale> shachaf: Oh, well, it's uniquely inhabited, just like Void
13:16:56 <shachaf> Oh, well, OK.
13:17:07 <Cale> (Haskell Void :)
13:17:08 <shachaf> I'd say it's more like unlifted () than like Void.
13:17:08 <ReinH> Cale: We didn't, but I know you like that book and search algos
13:17:45 <cschneid> Cale: you're suggesting a function like `putChar = IODetailedFFI Void StringSomething` and so on? Where the hypothetical IO type has more generic constructors, and you can then make your traditional IO functions just refer to them?
13:18:35 <ReinH> Cale: I was hacking away on alphabeta and getting frustrated with translating an imperative approach to Haskell and then I remembered the book.
13:20:12 <Squarism> EvanR, so i rewrote my IO dependent function (from -> to) : 
13:20:13 <Squarism> juliusCaesarStdio :: GamePhase -> IO ()
13:20:13 <Squarism> juliusCaesarStdio :: MonadIO a => GamePhase -> a ()
13:20:14 <mauke> putChar c = PutChar c (Return ())
13:20:32 <Squarism> EvanR, right?
13:21:28 <Squarism> feels a bit wierd with that "()" type argument though
13:21:41 <EvanR> () is weird?
13:23:08 <Squarism> well i dont know.. everything is wierd about haskell (to me as a beginner)
13:23:53 <EvanR> theres a better way
13:23:55 <Squarism> it feels wierd to provide a value to a type argument of a type argument
13:24:12 <Squarism> but neglect what i think
13:24:14 <EvanR> if youre going to test the game, then why not make the game part non-IO
13:24:21 <EvanR> only use IO to get and send stdio to the game
13:24:34 <Squarism> https://github.com/gurgl/julius-caesar/blob/master/src/Controller.hs
13:24:37 <EvanR> stdio is known to work so isnt necessary to test
13:24:47 <Squarism> only io dependent code in game except main function
13:25:13 <EvanR> uhm. which part
13:25:27 <Squarism> Controller.hs
13:25:38 <EvanR> the whole file is IO?
13:25:55 <Squarism> or.. more spec.. the juliusCeasarStdio function only
13:26:09 <EvanR> ah, shuffling requires IO here
13:26:16 <Squarism> oh yes
13:26:17 <EvanR> it doesnt actually require IO
13:26:27 <EvanR> but this version uses IO for randomness
13:26:29 <Squarism> i would prefer keep the structure of the game as is
13:26:43 <EvanR> moving the RNG out of IO is a great way to increase testability ;)
13:27:05 <Squarism> sounds sound
13:27:47 <EvanR> theres a shuffle in a package that works by accepting a (infinite) list of numbers along with the shuffle
13:28:18 <EvanR> though manually threading an updated rng state is kind of tiresome
13:28:28 <EvanR> there are monads for that
13:29:02 <EvanR> https://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
13:29:23 <EvanR> oh thats not an infinite list
13:29:44 <EvanR> this is actually pretty cool
13:29:45 <ReinH> Don't use IO for generating randomness. Use IO for generating random seeds.
13:29:51 <Squarism> sorry... im not sure i want make a bigger change like that right now. Im like a lost desert wanderer focusing on getting home. Wont even do a 50 m detour even on hints of water
13:30:13 <EvanR> well youre kind of stuck
13:30:25 <ReinH> Then you have a pure, deterministic source of pseudo-randomness that doesn't require IO and can be tested, etc.
13:30:27 <EvanR> you dont want to improve the structure of the thing, and you also want to write good tests
13:30:59 <ReinH> Improving the structure of a thing is generally an important part of writing better tests
13:31:01 <Squarism> ok.. so its only the random part i need to change
13:31:07 <Squarism> not a total overhaul
13:31:11 <Squarism> ?
13:31:30 <EvanR> i was also going to suggest moving the game itself into a non-io monad
13:31:57 <EvanR> juliusCaesarStdio
13:31:59 <Squarism> well the game logic is quite decoupled
13:32:03 <EvanR> the messages can be Writer tells
13:32:24 <EvanR> then you dont have IO anymore accept at the very edge of the program
13:32:36 <EvanR> and the tests can even test that the messages are right
13:33:33 <EvanR> your JuliusCaesar monad can be an instance of MonadRandom to do the shuffle, and MonadWriter to tell messages
13:34:07 <EvanR> readCommand would be implemented with something else
13:34:16 <Squarism> this is CPS like and i do like that because it lets me model the game as series of states that trigger io interactions. Can support some sort of replay / rollback mechanics i want
13:34:28 <EvanR> i guess that would require a dialog-like continuation thing
13:35:43 <Squarism> i could easily just decouple the Controller.hs logic and test the GameLogic.hs wo it as is now
13:35:53 <Squarism> maybe ill take that route instead
13:37:50 <Squarism> EvanR, i thank you for you ideas, but i guess it could put me off track too much. 
13:38:26 <Squarism> they are prolly good but my motivation needs more progress on the gamepart
13:38:33 <Squarism> game part
13:50:52 <quxbam> What would you prefer 50% faster compile times or 10% faster runtimes?
13:52:07 <koala_man> quxbam: a -O[debug|prod] flag controlling it
13:53:33 <sbrg> Anyone here familiar with Alex that has any tips on how to count newlines properly? I'm thinking I can use the monadUserState wrapper, and just increment the newlines as I go. However, all the lexing rules become monadic, and have type: AlexInput -> Int -> Alex Token. this means the handler that just increments the newline counter, which returns (), doesn't typecheck. I can probably do some stuff using
13:53:36 <sbrg> Either or something, but this feels like it should be an obvious use case and I'm wondering if I'm missing something
13:55:43 <quxbam> koala_man: Well, I'd need other data structures
13:56:02 <koala_man> 10% faster runtime then
13:56:14 <quxbam> I'm using sets, but I'd need hashsets and the generics instances are exploding my compile times
13:57:41 <bitonic> Is it possible to set `+RTS -Vx -RTS` at runtime?
13:57:51 <bitonic> I'm stumbling on this https://bugzilla.redhat.com/show_bug.cgi?id=645528 which is very disconcerting
13:58:02 <glguy> sbrg: Typically you'd handle tracking your character position, line number, and column number outside of your token rules
13:58:37 <glguy> sbrg: Are you trying to do that inside the alex rules due to some custom need or because you didn't know there were other posibilities
13:58:51 <bitonic> Basically Haskell sends a signal every x milliseconds and that makes any syscall that takes more than x milliseconds to fail forever!
13:59:01 <bitonic> Because you're interrupting it
14:06:00 <glguy> bitonic: Does -with-rtsopts help? or is it important to change it at runtime? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=with-rtsopts#ghc-flag--with-rtsopts
14:06:22 <bitonic> glguy: it seems to fail with everything but `-V0`, but I don't want to run with `-V0`
14:06:33 <bitonic> (e.g. I don't want syscall to never be interrupted)
14:06:41 <bitonic> Otherwise I can be stuck forever on a thread on a syscall
14:13:49 * hackagebot texrunner 0.0.1.1 - Functions for running Tex from Haskell.  https://hackage.haskell.org/package/texrunner-0.0.1.1 (cchalmers)
14:14:21 <bitonic> glguy: also, with -V0 it's slower, I think because the context switches happen faster
14:23:50 * hackagebot diagrams-graphviz 1.3.0.1 - Graph layout and drawing with GrahpViz and diagrams  https://hackage.haskell.org/package/diagrams-graphviz-1.3.0.1 (BrentYorgey)
14:23:52 * hackagebot ascii-table 0.2.0.0 - ASCII table  https://hackage.haskell.org/package/ascii-table-0.2.0.0 (mitchellwrosen)
14:23:54 * hackagebot SVGFonts 1.5.0.1 - Fonts from the SVG-Font format  https://hackage.haskell.org/package/SVGFonts-1.5.0.1 (BrentYorgey)
14:25:39 <xvilka_> hi
14:25:45 <xvilka_> is there any mailing list?
14:25:51 <byorgey> hi xvilka_ 
14:26:23 <byorgey> xvilka_: yes, there is https://mail.haskell.org/mailman/listinfo/haskell-cafe
14:26:27 <xvilka_> to ask a question. Had no luck with it in irc, may be should try in 'slow mode'
14:26:30 <xvilka_> thanks!
14:26:48 <byorgey> xvilka_: stack overflow can also be a good place to ask questions
14:27:24 <xvilka_> byorgey: yeah, it's not very common one, so not sure if SO will fit/help
14:28:53 <byorgey> xvilka_: well, there are lots of Haskellers answer questions on stack overflow if the question is tagged #haskell
14:29:10 <byorgey> so it can be a good place to ask more obscure questions as well
14:29:23 <byorgey> but the mailing list is also good
14:30:54 <xvilka_> will try ML first, but will copy the question on SO too, even with ready answer, since it might be helpful for others too
14:31:06 <byorgey> sounds good
14:31:10 <xvilka_> it's about embedding haskell as interpreter in other programs
14:31:16 <glguy> xvilka_: Is that the question about embedding GHC in radare2?
14:31:46 <xvilka_> glguy: exactly!
14:31:57 <xvilka_> glguy: how did you know?
14:32:08 <glguy> Logs
14:32:51 <glguy> Anyway, I think what you're likely to want to do is make a Haskell library that has the API you want and uses a foreign export to expose entry points to your C code. You can use the "hint" package to load Haskell source modules
14:33:06 <glguy> you'll need to include the data interop stuff in your library for exporting data back to radare2
14:33:16 <glguy> once you have that you can link it to a C program
14:35:49 <xvilka_> glguy: yes, I thought that might be the solution, it's ok for me, as long as it exports C-compatible symbols
14:36:21 <glguy> xvilka_: The library you write that pulls this all together can use the FFI and "foreign export" declaration to export C-compatible symbols
14:41:11 <xvilka_> glguy: ok, that part I got, export FFI - thats documented
14:41:53 <xvilka_> glguy: any points on the opposite side of this 'middle-layer' - on embedding haskell interpreter in haskell program? Just use Prelude?
14:43:19 <xvilka_> or this https://hackage.haskell.org/package/mueval ?
14:44:23 <glguy> xvilka_: That will depend on how much you trust the code you're running / where you're getting it from
14:45:37 <xvilka_> well, it's for scripting of the app. And app is reverse engineering related -> user should be aware of what he is doing, so I suppose no additional sandbox is needed
14:55:23 <moredhel> hi all, newbie here trying to use stack to install some deps, I can't seem to figure it out. I have added the deps to my .cabal file, and they have installed, but they don't seem to be available to the build process.
14:55:46 <moredhel> eg. stack build gives:     It is a member of the hidden package ‚Äòsnap-server-0.9.5.1@snaps_FOuAo5S7AtCHreynBKAdwZ‚Äô.
14:57:01 <moredhel> but I can `stack ghci`, then import Stack.Core
14:57:05 <moredhel> with no issues
14:57:19 <suppi> moredhel, sorry, got to sleep. hope this helps:  http://howistart.org/posts/haskell/1 
14:57:39 <moredhel> thanks suppi, will have a read
14:58:05 <glguy> xvilka_: Example code https://github.com/glguy/example-embedded-haskell
14:58:24 <glguy> xvilka_: cabal build that and then you can "make main"
14:58:41 <glguy> tested on my computer, worked once, ymmv
14:59:35 <xvilka_> glguy: awesome, thanks a log
14:59:37 <xvilka_> *lot
15:02:45 <guest`> if someone got interested, i got a fixed arity/standardized names version of alambda
15:18:52 * hackagebot propellor 3.0.5 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.5 (JoeyHess)
15:24:47 <glguy> moredhel: If you need help after reading that document you can paste your .cabal file to lpaste.net
15:25:15 <glguy> including the exact pasted text of the error there will help, too
15:25:29 <moredhel> thanks glguy, I think I have it figured out now, just reading through warp/mighty documentation. seems snap may have been a little high level
15:25:46 <moredhel> not sure what the error was, but I nuked it and restarted with a 'simple' template, and it all worked
15:47:54 <dedgrant> Hmm anyone know of any recent attempts to implement LP simplex + interior point nethod solvers purely in Haskell?
15:48:53 * hackagebot haddock-api 2.17.3 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-api-2.17.3 (Helkafen)
15:48:55 * hackagebot haddock-library 1.4.2 - Library exposing some functionality of Haddock.  https://hackage.haskell.org/package/haddock-library-1.4.2 (Helkafen)
16:01:31 <Ralith_> Is there a good way to make a yesod form error page return HTTP 400 instead of HTTP 200?
16:13:53 * hackagebot haddock-test 0.0.1 - Test utilities for Haddock  https://hackage.haskell.org/package/haddock-test-0.0.1 (Helkafen)
16:14:09 <Welkin> Ralith_: set the status code to 400
16:14:13 <enthropy> are overlapping instances the only way to have soft constraints?
16:14:14 <Welkin> using WAI directly I think
16:14:56 <enthropy> surely there must be some nicer way to get that effect in the type system, while making sure the actual code executed is the same regardless of which instance is selected
16:15:19 <enthropy> hmm, maybe numeric defaulting is the thing
16:15:20 <RyanGlScott> enthropy: What is a "soft constraint"?
16:16:54 <enthropy> RyanGlScott: somebody asked me a question about HList today. I was thinking about how things break if you throw in a function/class method that permutes the record
16:17:51 <enthropy> that it would be nice if that wasn't the case. But I hesitate to go wild with overlapping instances because they do not have any guarantee that the "more specific signature" gives you the same implementation
16:18:39 * enthropy might be wrong about this property of overlapping instances
16:18:51 <RyanGlScott> Well, I have no idea how HList works, but there tricks for avoiding overlapping instances
16:19:19 <RyanGlScott> For example, there's different show output for [Int] and [Char]
16:19:56 <RyanGlScott> (or rather, for [a] and [Char])
16:20:31 <RyanGlScott> This is accomplished simply by having an extra Show method, showList, which you override if you need different behavior when your type is in a list
16:21:22 <RyanGlScott> Then you just make the Show [a] instance be such that show = showList (approximately)
16:24:10 <enthropy> RyanGlScott: thanks I didn't think of that technique but I'm not seeing a way to apply it to my scenario
16:43:41 <Ralith_> How do I set the response status code in yesod?
16:51:20 <Ralith_> ah, sendResponseStatus
16:58:08 <YellowOnion> how would one go about generating random list of numbers with Lens?
16:58:18 <Squarism> can you call local functions if you have access to a value in which they are defined .. like f x = g x where g y = y + y. can i somehow invoke g from (f 2)
16:59:01 <Koterpillar> Squarism: yes
16:59:24 <Squarism> nice
16:59:49 <enthropy> YellowOnion: do you already know System.Random which doesn't involve lens?
17:02:59 <YellowOnion> enthropy, Yeah I know there's a function randoms I'm just wondering if its possible to manually use "random" and say State with lens to build a list, this is more an exploration of Lens than anything.
17:03:16 <Koterpillar> why do you need lens here?
17:03:55 * hackagebot stm-conduit 3.0.0 - Introduces conduits to channels, and promotes using conduits concurrently.  https://hackage.haskell.org/package/stm-conduit-3.0.0 (ClarkGaebel)
17:04:12 <rhovland> what's involved in colorizing ghci? do I add HsColour to .ghci or something?
17:05:40 <YellowOnion> Koterpillar, I'm trying to learn / understand lens a bit more.
17:08:10 <YellowOnion> Lens.unfolded, and `use` (I think?) could be composed to generate a list, but I can't quite figure out how.
17:16:27 <mpickering> YellowOnion: what makes you think that using lenses is the right tool for the job? 
17:17:29 <YellowOnion> mpickering, how else am I going to learn lens?
17:18:17 <bennofs> YellowOnion: so you think using MySQL to perform addition would be a good way to learn MySQL?
17:18:46 <bennofs> YellowOnion: to learn lens, you need to actually have a use case that fits lens
17:19:08 <mpickering> The easiest way to learn lens is to understand what a lens/prism/iso/traversal are and then everything falls into place
17:19:36 <mpickering> Looking at the api is just confusing as it is very big and very general
17:21:45 <YellowOnion> Well none of you have said why using lens to generate a list of random numbers is bad, lens provides unfolded, and a bunch of operations that work on state, so I'm not sure how using random as said said is bad.
17:23:19 <YellowOnion> what better way to learn the state operations, than use something that is inherently stateful.
17:23:21 <bennofs> YellowOnion: lens is all about "focusing" parts of complex structures
17:23:32 <bennofs> YellowOnion: a list is not a complex structure where you need to focus on a small subpart
17:34:57 <c_wraith> I don't like the characterization of lists as too simple for lens. I do like the characterization of lens as not the only tool ever invented. 
17:35:08 <YellowOnion> bennofs, lens provides a bunch of operations on lists, most of the operations in the examples provided are trivial non complex examples, the entire point is to compose complex structures right? so why is this so far fetched? Why is a bad idea to understand how to thread state - using functions provide by the package, to build trival structure, so that I can later compose more complex structures? do I need to provide a complex 
17:35:08 <YellowOnion> enough structure before you guys will aprove of my usage?
17:35:54 <bennofs> YellowOnion: lens doesn't really have operations than lists that are relevant to understand lenses
17:36:06 <bennofs> YellowOnion: that would also be useful in your case
17:36:18 <c_wraith> lens is great for a lot of purposes. unfolding a list and consuming a lens piecemeal within the context of a stateful computation are not things lens makes easier. 
17:36:19 <bennofs> YellowOnion: really, lens does not make sense if you don't at least have nested state
17:36:39 <c_wraith> err, consuming a list. 
17:36:53 <Koterpillar> YellowOnion: what we're trying to say is: any solution using a lens will be more complicated than one without
17:37:14 <c_wraith> bennofs, lens has lots of uses without nesting. just not these ones. 
17:38:56 * hackagebot bson 0.3.2.2 - BSON documents are JSON-like objects with a standard binary  encoding.  https://hackage.haskell.org/package/bson-0.3.2.2 (GregWeber)
17:38:58 * hackagebot sbv 5.12 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.12 (LeventErkok)
17:39:42 <YellowOnion> I need to go now, thanks for your help I guess.
17:45:54 <ertesx> is there a context that expresses that i want a particular data family instance to exist?
17:46:52 <Axman6> (a ~ Int) => Foo a -> Bar?
17:47:37 <ertesx> that's just Foo Int -> Bar and does not require that it exists by itself‚Ä¶  this is about class/instance contexts
17:49:04 <ertesx> class (FamilyInstanceExists (Foo a)) => C a  -- instances of this class should be accompanied by a data family instance 'Foo a'
17:49:25 <ertesx> i'm not in control of Foo here, so i can't just make it an associated type
17:49:32 <c_wraith> most of the mechanisms there predate closed type families, and before them, you had the open world assumption 
17:50:20 <ertesx> c_wraith: note that this is specifically about data families
17:50:37 <c_wraith> Oh.  100% in open-world assumption land, then
17:50:47 <c_wraith> Someone else could always define the instance.
17:50:59 <ertesx> that's fine‚Ä¶  i want the instance to exist
17:51:33 <ertesx> just like you can request that class instances exist:  class (Functor f) => Applicative f
17:51:54 <Koterpillar> (Bar a ~ Int) => Foo a -> Bar?
17:52:08 <ertesx> not terribly important, because code will fail to compile anyway, but i thought expressing the dependency at the right point may save time and produce better error messages
17:52:35 <ertesx> Koterpillar: that's a kind error, and again:  this is about *data* families
17:53:32 <average> why doesn't everyone just write haskell
17:53:43 <c_wraith> Yeah, I don't see anything to do except just write the function and let it be a compile error if the instance doesn't exist.
17:53:56 * hackagebot sbvPlugin 0.7 - Formally prove properties of Haskell programs using SBV/SMT  https://hackage.haskell.org/package/sbvPlugin-0.7 (LeventErkok)
17:54:27 <ertesx> let me just be more specific:  class Model h where type SomeId h; ‚Ä¶
17:54:28 <c_wraith> average: primarily that it's different from what everyone learned, and different is scary.  (There are also cases where it's just not the correct language choice)
17:54:40 <average> c_wraith: oh really ?
17:54:54 <ertesx> i'd like to request that Sing (SomeId h) exists (-XTypeInType assumed here)
17:55:11 <ertesx> and Sing is from the singletons library
17:55:14 <average> How much money is Haskell exactly generating ?
17:55:17 <c_wraith> Sure.  I'd never ask that someone write an OS kernel in haskell.  Projects like HalVM notwithstanding.
17:55:21 <average> I really could not care less about academic pursuits
17:55:29 <Axman6> average: 7
17:55:29 <average> I'm interested in money, how much money is Haskell generating
17:55:34 <average> Axman6: great, thanks for that number
17:55:49 <average> Axman6: do you have other numbers ?
17:55:56 <ertesx> average: 8
17:55:58 <Axman6> 2.7?
17:55:58 <Koterpillar> ironically haskell is probably _generating_ a lot of money - I see it used a lot in finance industry
17:56:02 <average> pretty good
17:56:21 <Axman6> yeah there's a fairly large amount of haskell in finance
17:56:43 <average> Koterpillar: coincidentally, that's also an area where code is treated as throwaway
17:56:45 <Axman6> also pretty much everything written on facebool goes through a system written in haskell
17:56:51 <Axman6> so I guess they see some value in it
17:57:07 <average> and frankly, I can completely understand why someone would write throwaway Haskell
17:57:13 <ertesx> at facebook it doesn't generate money, but it prevents money loss
17:57:25 <Axman6> this is true
17:57:32 <c_wraith> bennofs: I can't run this in lambdabot, since it doesn't have Control.Comonad.Store imported, but..  map (peeks negate) . holesOf (traverse . filtered even)
17:57:34 <Axman6> but preventing money loss generates value
17:57:41 <Axman6> which generates investment
17:57:52 <average> so at FB someone wrote some linter in Haskell
17:57:52 <c_wraith> bennofs: That's something that'd be a lot more code writtend directly, and the input is just lists.
17:58:03 <c_wraith> average: no, facebooks entire spam-blocking system.
17:58:07 <c_wraith> *facebook's
17:58:14 <Axman6> a linter? no, their spam filter
17:58:14 <ertesx> average: an abuse detection system
17:58:16 <average> oh yeah, spam-blocking
17:58:35 <average> let me tell you something about FB and spam
17:58:37 <ertesx> there is a talk about it, if you're interested
17:58:38 <c_wraith> You know, high throughput, low latency, long-running, adjustable on the fly.
17:58:45 <average> when I was using FB, my news stream or whatever it was called
17:58:47 <c_wraith> A real system.
17:58:50 <average> was f***ing filled with bulls***
17:59:04 <c_wraith> Your friends being idiots isn't the same as spam.
17:59:05 <average> so whatever Haskell spam-blocking they have, f*** that, I gave up FB because of the lack of relevance of the entire news feed
17:59:18 <ertesx> average: sure‚Ä¶  stuff *you* would consider BS, but not FB
17:59:35 <average> I'm a user of FB, and I'm telling you for a fact that it was BS
17:59:38 <average> I do not care what FB thinks
17:59:48 <ertesx> anyway, this is getting off-topic
17:59:52 <average> I care what I think tho, because I was experiencing the results of their magic Haskell spam thing
17:59:59 <average> and it was bull-f***ing-s***
18:00:07 <Axman6> average: do you have any questions about writing in the language haskell? because this is getting off topic
18:00:15 <average> yes
18:00:22 <average> I'm interested in the monetary aspects of writing Haskell
18:00:59 <ertesx> average: in the chain from an idea over work to generating money, haskell sits in the middle:  it's your hammer
18:01:06 <ertesx> if you use it to generate money, you will generate money
18:01:33 <average> ok ertesx , that was obvious to begin with
18:01:39 <Axman6> all languages can be used to generate money, it's not a feature of a language, but a feature of its users
18:01:49 <average> when I came here, my expectation was that I would hear stories about people generating monetary value with Haskell
18:02:07 <average> FB was one of them, but my direct experience with FB leads me to discard that from my list
18:02:11 <average> are there other examples please ?
18:02:12 <Axman6> then go read about all the finance firms using haskell
18:02:27 <Axman6> standard chartered are probably the most well known
18:02:29 <average> so this is it ? finance firms and FB ?
18:02:45 <josephle> Target is using Haskell for supply-chain/operations optimization
18:02:51 <Axman6> well, I run several services for the Australian government written in haskell
18:02:57 <average> josephle: that sounds interesting
18:02:59 <ertesx> average: there is a wiki page on haskell in industry‚Ä¶  it's not exhaustive, but gives you a few data points
18:03:10 <average> josephle: but to my knowledge, all OR solvers are external to the Haskell eco-system
18:03:26 <average> josephle: that makes me wonder how exactly Haskell is being used there, except for being a glue language
18:03:48 <ertesx> also there is an important distinction:  we actually have "companies using haskell" as well as "haskell companies"
18:03:51 <average> is Haskell anything but a glue-language in real-world straight-up business projects ?
18:04:21 <simpson> average: The answer is "yes", but I suspect that you already know that.
18:04:30 <Koterpillar> average: what's not a glue language?
18:04:37 <ertesx> average: it's a general purpose language that with strengths in correctness, rapid prototyping and rapid refactoring
18:05:00 <Axman6> yeah, that's basically what all programs do, is glue other systems together to make larger systems/transform data
18:05:10 <average> Koterpillar: C is typically not a glue language, nor is C++, nor is Java, and Fortran is mostly definitely not a glue language
18:05:25 <josephle> C++ is most definitely a glue language
18:05:47 <average> I would have to disagree
18:05:58 <Axman6> they're no less glue languages than Haskell is
18:06:09 <Koterpillar> aside: whenever people mention "scripting languages" in an interview, I ask them what's a scripting language. It's a nice trap.
18:06:09 <average> and the reason is that projects involving actual heavy-lifting are written in C++
18:06:20 <Koterpillar> average: define heavy-lifting and glue
18:06:29 <Axman6> is the monitoring of real time systems NASA are doing with Haskell also considered a glue language situation?
18:06:32 <average> I will not define everything as if we're in 4th grade
18:06:35 <ertesx> "glue language"‚Ä¶  i don't know if this is a useful notion to begin with
18:06:45 <Axman6> ertesx: hint, it's not
18:06:52 <Koterpillar> average: it's hard to have a productive discussion otherwise
18:06:55 <average> we're software people, I'm expecting some level of understanding folklore terminology
18:07:00 <josephle> average, you're in a channel with logicians...definitions is the name of the game here
18:07:23 <lyndon1> average: I've used Haskell recently for it's parsing and query capabilities at a Power Utility. 
18:07:34 <average> lyndon1: Power Utility = ?
18:07:45 <average> lyndon1: expand..
18:08:06 <lyndon1> Companies who own substations/transformers/meters
18:08:18 <Koterpillar> lyndon1: ohai :)
18:08:45 <lyndon1> Koterpillar: hi :)
18:08:48 <average> lyndon1: so someone contracted you to do this job for them
18:08:55 <average> lyndon1: and you picked Haskell
18:09:10 <average> because of its parsing/query(what exactly do you mean "query" ?) abilities
18:09:16 <lyndon1> Yes, consulting. It was a tool I used for a small part of the project.
18:09:30 <lyndon1> Others were Python/Spark, AWS, etc.
18:09:44 <lyndon1> But it didn't feel like glue.
18:09:49 <average> lyndon1: and will anyone coming after you be able to modify/update/fine-tune/customize that tool you wrote ?
18:09:56 <average> or is that the whole point of writing it in Haskell
18:10:01 <Axman6> sure, all of us in here
18:10:03 <average> that nobody else will be able to except for a narrow pool of people
18:10:28 <ertesx> maybe not all =)
18:10:47 <lyndon1> average: I'm sure someone could get to grips with it, but anything like that will require a little thought before just trying to blindly change the code.
18:10:52 <Koterpillar> average: some people consider high entry level a feature, not a bug.
18:11:11 <average> Koterpillar: and I can perfectly see why that is
18:11:18 <ertesx> average: you were asking about money‚Ä¶  the truck factor certainly is a source of money ;)
18:11:18 <average> I was just asking him if it was on purpose
18:12:06 <average> ertesx: so you do agree that the truck factor is a good strategy employed in such projects
18:12:27 <Axman6> no
18:12:31 <lyndon1> I wish I could talk more about it, but I'm still waiting for the disclosure to be approved.
18:12:32 <ertesx> as a business strategy yes‚Ä¶  it's a widely used strategy in fact
18:12:39 <Axman6> man, you're really trying to get a rise out of us aren't you
18:13:07 <ertesx> (we sure are patient)
18:13:19 <Koterpillar> average: it _should_ be hard to make changes that violate assumptions previous developers had
18:13:46 <lyndon1> average: A company in my city recently used Haskell to power a backend search service.
18:13:48 <Koterpillar> average: and "# WARNING: never set this to null" is not a good strategy for that
18:13:52 <Ashy> I would love to come across some haskell code at work
18:14:13 <ertesx> Ashy: use darcs, pandoc, xmonad, ‚Ä¶
18:14:28 <average> Axman6: why are you a pest. listen man, I do not give a f*** about your fancy-pants logic Haskell. I'm here to talk about money and that's that. if you disagree with my thinking, there's a corner right there -> , go and sit there
18:14:33 <Ashy> I meant code that I maintain
18:15:03 <ertesx> Ashy: write your next static website using hakyll‚Ä¶  you won't write a whole lot of code, but what you write will be in haskell =)
18:15:03 <lyndon1> average: http://www.meetup.com/Melbourne-Haskell-Users-Group/events/229085351/
18:15:07 <Axman6> average: this is a Haskell channel, not a personal finance channel
18:15:22 <Koterpillar> average: This is a channel about Haskell, not money. If you want to have a discussion about other things, consider changing the venue.
18:15:23 <Axman6> lyndon1: you in Melbourne?
18:15:25 <Ashy> I do support maintenance for a consultancy so mostly get handed existing code bases to take over
18:15:30 <lyndon1> Axman6: yep :)
18:15:42 <Axman6> G'Day from CBR =)
18:16:08 <lyndon1> G'Day :D
18:16:13 <Ashy> Nice,  more aussies
18:16:25 <Koterpillar> not a wonder in the current time zone
18:16:33 <Ashy> True
18:16:34 <average> I think every time I come here, Axman6 is trying really hard to be this sortof painter renaissance man that looks at Haskell code as a thing of beauty and a monument of elegance
18:16:39 <average> Axman6: guess what, idgaf
18:16:40 <Ashy> Though I'm in saigon atm
18:16:52 <average> Axman6: I'm just telling you so you know
18:17:14 <lyndon1> average: beauty has value
18:17:28 <ertes-t6v> Ashy: one way to get some satisfaction is to translate haskell concepts when you see fit‚Ä¶  for example i've implemented 
18:17:40 <ertes> ‚Ä¶ iteratees in PHP
18:17:57 <average> lyndon1: ok fine, I would like to separate things. If I do want to see art, I will go to a museum or an exhibition
18:18:05 <average> if I want to write code, I'll write code
18:18:06 <byorgey> average: Please cut out the foul language.  I don't care whether it's abberviated or not.
18:18:14 <average> these are different things for me, so I will treat them separately
18:18:19 <Koterpillar> ertes: that's a great way to get frustration too - when you see a pattern but can't apply it
18:18:19 <byorgey> *abbreviated
18:18:29 <Ashy> I'm running an offshore dev team here at the moment so I've been spending most of my time in meetings and Outlook recently unfortunately
18:18:53 <Axman6> average: my day job is writing haskell as an engineer, I don't care about writing formally verified, beautiful, useless code. I write code to make money, so I have no idea where you're getting that opinion of me from
18:18:56 <lyndon1> An high-quality aesthetic leads to easier comprehension.
18:19:05 <ertes> Koterpillar: sure, you won't translate comonad transformers to PHP (it's possible, but you‚Ä¶  don't)
18:19:21 <ertes> Koterpillar: but you can get some concepts to work
18:19:30 <average> Axman6 ... then why are you behaving like such a ... pianist ?
18:19:56 <byorgey> average: also, please stop with the personal attacks
18:20:13 <average> what attack ? I called him a piano-man, how's that an attack ?
18:20:13 <Ashy> Personally my favourite feature of haskell is just the strong focus on types
18:20:19 <lyndon1> average: A pianist has expression at their fingertips.
18:20:32 <lyndon1> Easy expression is valuable right, so it's a good analogy.
18:20:50 <Ashy> It's amazing just ripping into code and knowing the compiler has your back properly
18:21:04 <simpson> average: Sorry, what's wrong with being a pianist?
18:21:19 <ertes> (stop feeding‚Ä¶)
18:21:24 <Axman6> Ashy: More than that, you can make types do work for you
18:21:25 <Ashy> Going back to dynamic languages afterwards feels like trying to build bridges with silly string
18:22:10 <average> I see Ashy is promoting Haskell with the classic propaganda that can be seen in all the places advocating it over anything else
18:22:22 <lyndon1> Axman6: Is there a Haskell community in CBR?
18:22:24 <average> that's fine, Ashy , you're doing an ok job..
18:22:34 <Axman6> lyndon1: yes, I run it, CanFP
18:22:40 <lyndon1> Ah awesome :)
18:22:46 <lyndon1> I run MHUG here
18:23:20 <Ashy> Heh, you sound jaded average
18:23:23 <average> simpson: why are you asking me ? i'm not a pianist
18:23:26 <Ashy> I know that feeling
18:23:55 <simpson> average: Oh. *I'm* a pianist! It's pretty awesome. Anyway, what's wrong with how pianists behave? Please, finish your insult. I'm interested now.
18:24:17 <Axman6> average: perhaps it would be easier for you to make money by asking your parents for payment for chores, that's usually how 12 year olds make money
18:24:20 <average> i maintain it was not an insult
18:24:31 <Ashy> Is there a HUG in Sydney?
18:24:37 <byorgey> average: you're not being very constructive.  If you are really interested in discussing Haskell, then by all means stick around.  But if you are just interested in trolling and insulting people, I will have to ask you to leave.
18:24:49 <Ashy> Gonna be moving there next year
18:24:50 <Axman6> Ashy: FP-Syd
18:25:05 <Ashy> Ah cool
18:25:27 <Axman6> it's pretty great, run by erikd and jedws 
18:25:41 <Axman6> Ashy: moving from where?
18:25:51 <average> byorgey: i think your assessment is flawed
18:25:54 <average> but anyway
18:26:19 <Axman6> byorgey: I thought it was abundantly clear what his intentions were
18:26:39 <average> Axman6: actually I think the opposite is more likely
18:26:47 <average> given the type of reactions that were generated
18:26:47 <byorgey> Axman6: I did too, I just like to give people the benefit of the doubt.
18:26:56 --- mode: ChanServ set +o byorgey
18:27:00 --- kick: average was kicked by byorgey (average)
18:27:04 --- mode: ChanServ set -o byorgey
18:27:07 <Axman6> <3
18:27:09 <Ashy> Axman6: I'm from qld originally but I've been living and working in Vietnam this year
18:27:13 <koz_> A few days ago, someone linked me to a very nice guide on GitHub about how to profile Haskell things. I can't seem to locate the link anymore - could someone help me out?
18:27:13 --- mode: ChanServ set +o byorgey
18:27:17 <lyndon1> Axman6: By the way, I'm putting together 'Compose :: Melbourne' at the moment, and we're looking for keynote speakers.
18:27:17 --- mode: byorgey set +b *!*average@unaffiliated/average
18:27:17 --- kick: average was kicked by byorgey (average)
18:27:25 --- mode: ChanServ set -o byorgey
18:28:13 <Axman6> lyndon1: yeah I saw, there's been some interest here. not sure what any of us would talk about though, we're all doing simple engineering, nothing particularly exciting
18:28:39 <Ashy> What industry if you don't mind me asking?
18:28:52 <Axman6> I work at Data61 (formerly NICTA)
18:29:26 <lyndon1> We were looking at getting Andrew Sorensen of Extempore fame to do the keynote, but he had a conflict unfortunately.
18:29:31 <Ashy> I have the probably flawed impression that only some finance sectors are really using haskell
18:29:56 <ertes> Ashy: that is really flawed
18:30:18 <ertes> haskell is widely used these days‚Ä¶  not PHP-widely, but widely
18:30:30 <Ashy> Axman6: Ah nice
18:31:22 <Ashy> ertes: That's good to know, I'd love to do some work with a haskell team at some point
18:31:53 <Axman6> there's literally dozens of us, DOZENS!
18:32:27 <ertes> Ashy: in my early days of haskell experience i had to pretty much sneak it in‚Ä¶  just deliver a solution in haskell, when you're not told to use a specific language
18:33:25 <caconym> ertes: I did that recently at work, no regrets
18:33:31 <caconym> on my end, at least ;)
18:34:09 <ertes> but it was also partly my mistake:  i was bad at selling technologies
18:34:14 <ertes> really bad
18:34:55 <ertes> when cornered i would start with: "well‚Ä¶  but‚Ä¶"
18:35:18 <Ashy> haha
18:35:38 <Axman6> "Hey look over there!"
18:35:46 <haskell_hobo> man the haskell.org website looks terrible since they removed the wallpaper
18:36:33 <ertes> haskell_hobo: it looks like‚Ä¶  wait‚Ä¶  what does it remind me of?
18:37:01 <ertes> docker?  ansible?  that JS library everybody uses?
18:37:09 <caconym> ertes: selling technologies is hard, agreed, i've kinda given up at my current position
18:37:11 <ertes> perhaps all of them‚Ä¶
18:37:12 <haskell_hobo> it looks like there's supposed to be a wallpaper there and they just removed it without redesigning it.
18:37:33 <haskell_hobo> which is probably what happened with the hask-lang dustup
18:37:43 <caconym> the advantage to my haskell solution was that i was able to deliver it 5x faster than anyone else would have been able to solve this particular problem
18:37:44 <Axman6> ertes: almost this: http://adventurega.me/bootstrap/
18:38:10 <ertes> caconym: it's not that hard, if you're prepared‚Ä¶  but it takes some time to get into the mindset of the *company*, not the engineers that work there
18:38:44 <haskell_hobo> true all the managers eyes glaze over when i start talking FP
18:38:55 <haskell_hobo> _even_ i go to great lengths to talk about productivity gains
18:39:05 <ertes> caconym: in particular they care less about speed (they have a time budget anyway‚Ä¶  you just have to fit into it), and more about business value
18:39:26 <haskell_hobo> ertes indeed. or rather, perceived business value.
18:39:42 <Ashy> I'm in a management role here pretty much and I can see the other side now
18:39:52 <ertes> caconym: if you increase their business value with haskell, you have sold haskell‚Ä¶  no further questions asked
18:40:03 <Ashy> You need to know you can hire replacement engineers easily
18:40:22 <haskell_hobo> haskell shoul actually make engineers more replaceable
18:40:25 <caconym> Ashy: yeah, that's the big thing
18:40:42 <haskell_hobo> because way more of the system invariants are explicit
18:40:48 <Axman6> haskell_hobo: That's why I write awful Haskell :P
18:41:06 <haskell_hobo> whereas in python or R, the invariants are in some person's head
18:41:26 <ertes> you don't have to write awful haskell‚Ä¶  you just have to use singletons and nix for building/deployment =)
18:42:25 <haskell_hobo> i've been pushing haskell as a tech at megacorp, but i think i'm about 3-5 years too early in multiple directions
18:43:40 <caconym> my job is meh from both the engineering and management fronts, but on the plus side it pays well and has a good work/life balance which frees me up to do stuff like learn Haskell and look for a *really* good job
18:43:56 <haskell_hobo> we'll see. part of it is a race to get productive in it myself and build an edifice of my own ecoystem on which unambiguous can be created fast
18:44:04 <ertes> and i've learned that something as benign as a deployment process can increase the truck factor to infinity
18:44:18 <ertes> so just deploy a docker container instead of cabal-building =)
18:44:40 <caconym> does anyone know of a nice write-up on deploying Haskell services in Docker containers?
18:44:58 <ertes> caconym: i use nix
18:45:01 <haskell_hobo> caconym i am looking for that as well. supposedly stack does it magically but i ahven't put that to the test.
18:45:03 <caconym> i was messing around with it recently but i think what i was doing was pretty suboptimal
18:45:12 <ertes> caconym: it generates containers for you on demand
18:45:23 <ertes> (needs a bit of code though)
18:45:37 <caconym> haskell_hobo: i got excited when i saw that in the stack docs but i feel like that integration is more about dev environments? not sure though
18:45:38 <haskell_hobo> what package is </> defined in?
18:45:41 <Ralith_> How can I force stack to rebuild an external library?
18:45:44 <caconym> ertes: i'll check nix out
18:45:53 <caconym> </> is uh System.Path? maybe?
18:46:03 <ertes> haskell_hobo: likely System.FilePath
18:46:06 <haskell_hobo> oh right
18:46:08 <caconym> oh yeah that's it
18:46:24 <ertes> but we have so many path libraries now that almost any module name with "Path" in it may be the one
18:54:25 <haskell_hobo> writing the front end piece of my haskell apps is getting annoying
18:54:57 <haskell_hobo> so much scaffolding
18:55:04 <haskell_hobo> must be a better way
18:55:09 <haskell_hobo> maybe i should try elm
18:56:35 <haskell_hobo> do any of the haskell solutions enable abstracting away the html / css, layout drudgery at all?
18:57:26 <ertes> haskell_hobo: client-side?
18:58:00 <haskell_hobo> ertes
18:58:12 <haskell_hobo> yeah, charting interaction mostly sucks in native haskell
18:58:31 <haskell_hobo> so i'm throwing up web interfaces for user interaction and data visualization
18:58:50 <ertes> haskell_hobo: are you aware of GHCJS?
18:59:04 <Koterpillar> and PureScript?
18:59:13 <sm> haskell_hobo: also, some people praise reflex-dom
18:59:22 <haskell_hobo> ertes yeah, i'm aware, but have only tried them in bits. one question i have
19:00:38 <haskell_hobo> can i avoid writing html/css or do i still have to wrap the js those generate in some html page? i'm trying to abstract away all the boilerplate stuff
19:00:52 <haskell_hobo> so i can put up these one-off front-ends more efficiently
19:01:08 <sm> +1
19:01:11 <koz_> OK, I managed to find my ridonculous memory use in one user-defined function. How can I 'zoom in' and profile just the stuff that function calls?
19:01:27 <ertes> haskell_hobo: reflex-dom is meant to produce markup as it goes
19:01:50 <ertes> you can basically start with an empty HTML page that only loads a GHCJS-generated script
19:02:39 <haskell_hobo> ertes i need to load up some templates like bootstrap though. i can't stand for my UIs to look so 90s.
19:02:55 <haskell_hobo> maybe i should just go the old fashioned route and write a couple blaze-html functions
19:03:23 <ertes> haskell_hobo: personally i'd probably just use reflex and write the logic myself, generating only dynamic elements via JS
19:03:40 <ertes> (note: reflex ‚â† reflex-dom)
19:04:00 <ertes> and of course you can use all the usual HTML/CSS packages available: blaze-html, clay, lucid, ‚Ä¶
19:04:21 <ertes> i like the clay+lucid combination
19:04:31 <adamCS> haskell_hobo: What ertes said.  You can definitely abstract away much of the html and css.  Though css is still...annoying.  I've been working on some form building code for reflex/reflex-dom and I find it quite pleasant.  But I don't have much experience with html or css so I find that painful sometimes.
19:04:43 <adamCS> Yes, Clay, definitely.
19:05:00 <sm> haskell_hobo: if you come up with a nice solution/template, please release it
19:05:17 <haskell_hobo> adamCS how about Cassius?
19:05:23 <adamCS> ertes:  How do you use Lucid with reflex?  Oh, you mean instead of (in some way) reflex-dom?
19:05:38 <ertes> adamCS: yeah, reflex without reflex-dom
19:05:41 <adamCS> I haven't tried cassius.  Should I check it out?
19:06:18 <haskell_hobo> adamCS it's pretty low tech. i don't use cassius but i do make use of julius.
19:06:20 <ertes> cassius introduces a quasiquoted syntax, which looks pretty much like CSS with access to haskell variables
19:06:42 <haskell_hobo> basically it's like type in your CSS. then abstract that away into a function that can render the text to be served up
19:06:44 <ertes> clay is more advanced and is just an embedded DSL
19:07:28 <adamCS> Ah.  I'll look at it.  Clay serves my needs pretty well so far.
19:08:09 <haskell_hobo> sm my current approach is to have a web/ directory with jquery/bootstrap/plotly. then i have a blaze-html that generates a scaffold + some wrappers around julius to make and render visualizations.
19:08:15 <ertes> it does get slightly inconvenient with certain things:  sym2 margin (em 1) (ex 2)
19:08:41 <ertes> that's the tradeoff
19:09:18 <ertes> haskell_hobo: BTW, reflex-dom just generates elements‚Ä¶  you can still use bootstrap
19:09:20 <adamCS> ertes: I do like how it handles the selectors via monad syntax.  That makes some things quite nice.
19:09:25 <ertes> all you need to do is to assign the classes it needs
19:09:38 <haskell_hobo> ertes ghcjs seems so heavyweight
19:09:46 <haskell_hobo> from my experience
19:09:56 <haskell_hobo> i have to clone a github project just to get it up and running
19:10:22 <ertes> adamCS: more generally the EDSLness makes it quite nice:  onWide = query screen [Media.minWidth (px 640)]
19:10:32 <adamCS> yes.
19:10:34 <ertes> onLarge (width (pct 100))
19:10:38 <haskell_hobo> then i have to rename the github project, editing the cabal file. not my idea of a smooth workflow
19:10:40 <ertes> s/onLarge/onWide/
19:11:10 <ertes> haskell_hobo: you mean getting GHCJS itself to run?
19:11:44 <haskell_hobo> ertes yes, but even just getting an empty project up and going. wish there was a stack template for it
19:11:46 <haskell_hobo> that worked
19:11:52 <ertes> yeah, i can see how that would be annoying‚Ä¶  for me nix handles everything
19:12:11 <ertes> i just tell it to use GHCJS instead of GHC
19:12:12 <adamCS> I've had pretty good luck with ghcjs and stack
19:12:45 <adamCS> just followed the instructions and used a tarball someone had already tried and had work.
19:14:04 <haskell_hobo> adamCS I got it to work with a github template + stack as well
19:14:25 <haskell_hobo> but then how do you go about a new project, git clone + editing the cabal file is tedious
19:14:51 <haskell_hobo> also, that template stopped working after a few weeks
19:14:53 <ertes> haskell_hobo: i really don't know what you mean‚Ä¶  i create a GHCJS project exactly the same way i create a native project
19:15:33 <haskell_hobo> hm i'm probably doing something wrong
19:15:55 <haskell_hobo> on a related but different note, can you have a stack project nested inside another stack project, or does stack get confused by that?
19:16:05 <adamCS> haskell_hobo:  Once I build the version of ghcjs I'm using, the rest is just like always.  Except I don't update my resolver in stack to get newer versions of libs.  That becomes sort of one shot when I want to update ghcjs versions.
19:18:01 <adamCS> haskell_hobo: You mean in a way so that the parent stack.yaml has a subdirectory in its packages list?
19:20:02 <haskell_hobo> adamCS i'd want the inner project to be pretty much independent, so i can have a ghcjs project for the frontend within my project directory
19:20:33 <ertes> nix really makes using GHCJS a piece of cake:  just pass '--argstr compiler ghcjs'
19:21:02 <adamCS> I think you could have it there but not have stack build it along with everything else.  It wouldn't switch compilers when it got to the subdirectory.
19:21:20 <adamCS> So you'd have an extra build step.  I think.
19:21:47 <ertes> it downloads (and, if necessary, compiles) GHCJS and all dependencies and then builds your project (or gives you a shell with the proper GHCJS environment in scope)
19:35:49 <haskell_hobo> how does one write FFI to js using ghcjs? is there a walkthrough somewhere?
19:36:52 <haskell_hobo> oh doesn't look too bad https://github.com/ghcjs/ghcjs-examples/blob/master/weblog/ffi/ffi.hs
19:37:01 <haskell_hobo> but i wonder how you, say, marshall json
19:59:54 * koz_ feels like an abject idiot for managing to introduce an off-by-one error into a Haskell program...
20:14:00 * hackagebot octane 0.6.3 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.6.3 (fozworth)
20:47:55 <williamyager> How does liquid haskell's termination checking work? The collatz function appears to freeze Liquid Haskell + Z3, presumably on termination checking
20:48:10 <williamyager> Does it actually try to be exact, and not just excessively conservative?
20:48:23 <williamyager> (e.g. "must have monotonically decreasing argument")
20:58:38 <maks_> what are some tips & tricks to reduce memory usage in haskell
20:58:58 <maks_> i find that my programs have satisfactory speed, but completely outrageous memory requirements
20:59:21 <maks_> so far switching from Lists to Sequences or Arrays was helpful, but I'm wondering if there are other things I should know?
21:00:14 <williamyager> maks_: Use strictness. Strict folds often help to alleviate memory consumption
21:00:35 <williamyager> In fact, that's really 99% of haskell memory issues
21:00:44 <williamyager> use foldl' instead of fold or whatever
21:00:53 <maks_> williamyager: that's very helpful!
21:00:55 <williamyager> instead of e.g. Data.Map, use Data.Map.Strict
21:01:20 <maks_> williamyager: would playing with $! instead of $ have the same effect?
21:01:49 <williamyager> maks_: Sometimes. I almost never use that combinator though
21:02:15 <williamyager> Mostly I use strict data structures and strict folds and it does the trick
21:02:24 <williamyager> Oh, and strict data constructors
21:02:41 <williamyager> Let's say you have a triple of three floats
21:02:47 <williamyager> data Foo = Bar Float Float Float
21:02:59 <williamyager> you can force all three floats to be evaluated when the "Bar" constructor is evaluated like this
21:03:09 <williamyager> data Foo = Bar !Float !Float !Float
21:03:19 <maks_> got it, thanks!
21:03:21 <williamyager> This also allows some nice optimizations by the compiler
21:03:36 <williamyager> It takes a bit to get your head around how haskell evaluation works, but it's not super complicated
21:03:42 <maks_> are there some generic tricks for turning lazy data structures into strict ones?
21:03:51 <williamyager> You don't usually want to
21:03:57 <Axman6> maks_: often making your datatypes strict and unpacked can provide a huge memory usage benefit. data Foo = Foo Int is a lot larger than data Foo = Foo {#- UNPACK #-} !Int
21:03:58 <williamyager> usually you want the *reduction* step to be lazy
21:04:37 <williamyager> So for example, if you have a lazy list but a strict fold, a huge list can use very little memory (because it hasn't been generated yet), and the fold takes constant memory (because you're accumiulating everything into an int or whatever)
21:04:55 <williamyager> So you can sum a billion-element list in a few bytes of memory
21:05:21 <pavonia> What is the difference between unpacked and strict?
21:05:46 <maks_> williamyager: thanks a lot, that cleared up some misunderstandings!
21:05:52 <Axman6> strict means it will be forced before constructing the data, unpacked means the data is stored inline
21:05:55 <williamyager> Strict means that it gets evaluated at the same time as something else. Unpacked means it's stored in a data structure directly instead of having to follow a pointer
21:06:28 <Axman6> so Foo with !Int would be a pointer to an evaluated Int, whereas {-# UNPACK #-} would have the Int# inside the Foo without a pointer
21:06:47 <maks_> One more thing I'm confused about: what is the difference implementation-wise between a lazy and strict fold?
21:06:52 <williamyager> (Note that GHC will automatically unpack small strict fields like floats or ints)
21:07:02 <pavonia> Ah, I thought strict data types already remove that extra indirection
21:07:04 <Axman6> @src foldl
21:07:04 <lambdabot> foldl f z []     = z
21:07:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:07:05 <Axman6> @src foldl'
21:07:05 <lambdabot> foldl' f a []     = a
21:07:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:07:20 <maks_> oh
21:07:33 <Axman6> at each stage of the loop, foldl' evaluated the intermediate a'
21:07:39 <Axman6> evaluates*
21:07:43 <williamyager> maks_: In other words, we force the reducing step to be evaluated *before* recursing
21:07:58 <maks_> Axman6: so can't I achieve the same effect by using force?
21:08:04 <maks_> (force as in deepseq)
21:08:52 <williamyager> maks_: No. Even if all the elements of the list are evaluated, "f a x" just creates a new unevaluated thunk. So "x" (the thing from the list) has been evaluated, but "f a x" won't be until it's forced to be.
21:09:21 <williamyager> When you go asking for the value of "f a x", the runtime is like "better evaluate this, huh", but it will defer until then
21:11:27 <maks_> williamyager: so if I understand correctly the strict version of fold, forces that f a x will be evaluated when we traverse the list (but not sooner), while the lazy version doesn't enforce evaluation during traversal (and so results in larger and larger thunks)?
21:11:41 <williamyager> so if you do "foldl f [a,b,c] d", you end up with "(f (f (f d a) b) c)" or something in memory
21:11:44 <williamyager> Yes, correct
21:12:13 <maks_> williamyager: and if I apply something like force/deepseq then I would be evaluating all f a x even before I need them, thus increasing memory usage?
21:12:14 <williamyager> You end up with a bunch of un-evaluated applications sitting around in memory. When you're done folding and try to evaluate the value, all those applications collapse and are actually evaluated
21:12:38 <rfw> does lens work with types with multiple constructors with named fields that have the same name between data constructors?
21:12:50 <glguy_> Yeah
21:12:56 <rfw> like data Foo = A { _fooBar :: Int } | B { _fooBar :: Int }
21:13:05 <rfw> hm ok
21:13:34 <williamyager> maks_: If you did "foldl f z $ force [a,b,c]", you would have forced the contents of the list to be evaluated, but you'd still end up with (f (f (f d a) b) c)
21:13:41 <williamyager> s/d/z
21:13:57 <williamyager> So a,b,c are already evaluated, but the thunks created by foldl aren't
21:14:02 * hackagebot versions 3.0.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.0.0 (fosskers)
21:14:08 <maks_> williamyager: so strictness prevents the accumulation of nested thunks
21:14:23 <williamyager> In this case, that's the effect it has
21:14:23 <glguy_> 03data Foo 07= A { _fooBar 07:: Int } 07| B { _fooBar 07:: Int } ; makeLenses ''Foo
21:14:24 <glguy_> fooBar 07:: Functor f 07=> (Int 07-> f Int) 07-> Foo 07-> f Foo
21:14:39 <williamyager> I wouldn't say it does that in general, but that's what happened when we added `seq` to the foldl definition
21:14:46 <williamyager> to make foldl'
21:14:59 <williamyager> It evaluates the thunks as it goes along, so they don't sit around un-evaluated
21:16:37 <maks_> williamyager: one more point of confusion, can I think of seq as getting rid of one-level of thunks (basically it wasn't clear to me what the WHNF is) 
21:17:05 <williamyager> Maks: If you have a data constructor "data Foo = Bar Int Float"
21:17:20 <williamyager> and "x = Bar a b"
21:17:46 <williamyager> Evaluating x to WHNF means that you evaluate x closely enough to realize that it's a "Bar" constructor
21:17:52 <maks_> ah!
21:17:56 <glguy_> rfw: The logic is actually smarter than that, you can merge fields with different types into the same lens as long as they can unify
21:18:00 <williamyager> perhaps a better example would be "data Foo = Bar | Baz"
21:18:05 <glguy_> data Foo a b = A { _fooBarA :: a } | B { _fooBarB :: b } ; makeLensesFor [("_fooBarA","foobar"),("_fooBarB","foobar")] ''Foo
21:18:10 <glguy_> foobar :: Functor f => (a0 -> f a1) -> Foo a0 a0 -> f (Foo a1 a1)
21:18:14 <williamyager> Err, "data Foo = Bar Float | Baz Int"
21:18:20 <maks_> williamyager: sure
21:18:20 <williamyager> if I have "x :: Foo"
21:18:34 <williamyager> evaluating x to WHNF is evaluating it far enouch to check if it's a Bar or a Baz
21:18:37 <williamyager> but not evaluating the contents
21:18:40 <rfw> glguy_: ah that's cool
21:18:49 <williamyager> On the other hand, if I had  "data Foo = Bar !Float | Baz !Int"
21:19:00 <rfw> glguy_: i'm just using makeFields though
21:19:10 <williamyager> evaluating "x :: Foo" far enough to tell if it's a Bar or a Baz would also force the evaluation of the Float or the Int field
21:20:10 <maks_> williamyager: is there a way to also enforce this without defining data Foo = Bar !Float | Baz !Int (i.e without the exclamation points)?
21:20:36 <williamyager> So the expression "a `seq` f a" forces "a" to be evaluated to WHNF before starting to evaluate the application of "f" to "a"
21:20:49 <williamyager> in the case of an Int or whatever, WHNF fully evaluates the number
21:20:58 <maks_> aha
21:21:20 <maks_> williamyager: so would doing a double seq have the same effect as defining data Foo = Bar !Float and doing a single seq?
21:21:39 <williamyager> maks_: You can do it a couple ways. There are a couple pragmas now that make the entire module strict in various ways. But usually you would use !
21:21:55 <Koterpillar> maks_: a seq a seq b === a seq b
21:22:16 <maks_> williamyager: thanks a lot!
21:22:26 <williamyager> maks_: If a value is already evaluated to WHNF, doing "seq" again won't do anything. Does that answer the question?
21:22:33 <maks_> yeah
21:22:48 <maks_> it does make sense
21:22:51 <williamyager> Cool. yeah the point of DeepSeq is that it goes all the way down and "seq"s everything
21:23:38 <williamyager> So when you evaluate the top-level constructor, it's forced to evaluate all the lower constructors first
21:23:50 <williamyager> (I think, I haven't used DeepSeq in a while)
21:26:12 <maks_> williamyager: i'll try these things out next time i write something
21:26:39 <maks_> williamyager: i.e the strict fold everywhere and data structures with ! and UNPACK
21:26:51 <williamyager> maks_: Cool. Like I said, judicious use of (!) is usually good enough. You can actually write foldl' using ! instead of `seq`. You just put a ! on the argument you want strictly evaluated
21:27:11 <Axman6> maks_: it's not a general rule of thumb, it's important to understand when you don't want these things (and there's a good reason they're not the defaults)
21:27:15 <williamyager> maks_: Cool. And this really only applies for high-perf/big structures, but yeah hopefully that helps
21:27:48 <maks_> williamyager: right. are there are any more intricate tricks I should be aware of, for memory reduction?
21:28:38 <maks_> williamyager, Axman6: yeah that's actually the setting I have I like to prototype some scientific computations in haskell first before going to C, and the data structures tend to get big, but even a 1Mb array in Haskell can sometimes get bloated beyond proportion
21:28:39 <williamyager> maks_: Nothing comes to mind
21:29:06 <williamyager> maks_: OK, well on that note
21:29:10 <maks_> williamyager: in any case thanks again, this is very helpful, as I've been struggling with this and didn't find much on-line on the subject...
21:29:12 <williamyager> Here are a few general tips
21:29:34 <williamyager> Use Vector (Unpacked vectors if you can) for storing lots of numbers, and use -O2 optimization
21:29:45 <williamyager> GHC can create some *really* tight code using Vector and -O2
21:29:55 <williamyager> doesn't work using -O
21:30:14 <williamyager> And if you're processing long strings of binary data, use Lazy ByteStrings
21:30:21 <williamyager> they are chunked up so they fit nicely in CPU cache
21:30:48 <williamyager> and that + fusion rewrite rules gives you some flaming fast binary data processing code
21:30:54 <c_wraith> Oh, hey, I totally forget that you can add imports to lambdabot..
21:31:00 <williamyager> But yeah, no problem. Good luck!
21:31:05 <c_wraith> > map (peeks negate) (holesOf (traverse . filtered even) [1..7])
21:31:07 <lambdabot>  [[1,-2,3,4,5,6,7],[1,2,3,-4,5,6,7],[1,2,3,4,5,-6,7]]
21:31:11 <c_wraith> woo!
21:33:04 <maks_> williamyager: just to check: fusion is a way to arrange the consecutive fmaps on a vector array, so that they execute only once at a final stage?
21:33:58 <williamyager> maks_: basically library authors specify functions that are "inverses" of each other and GHC gets rid of them, or specify tricks to lump work together
21:34:01 <williamyager> But yeah, that's the idea
21:34:19 <williamyager> so a library author can say "map f . map g = map (f . g)"
21:34:27 <williamyager> and the latter is more efficient because there's one less intermediate array
21:34:40 <c_wraith> *list.  :P
21:34:48 <williamyager> It's not a super smart system, but it works decently most of the time
21:35:09 <maks_> williamyager: thanks!
21:35:19 <c_wraith> a super smart system can be made.  It's only theoretically possible to make it fast and super smart at the same time. :)
21:35:38 <c_wraith> I mean, Is running your code 30% faster worth compile times going into several weeks? :)
21:35:46 <williamyager> Might well be :)
21:35:50 <williamyager> Depending on the job...
21:36:08 <Axman6> maks_: you're probably using the wrong arrays in that case, generally you'll be working with Doubles right? then you should be using something like Data.Vector.Unbox
21:37:48 <maks_> Axman6: What is the difference between unboxed, and normal Data.Vector
21:39:39 <williamyager> maks_: Normal Data.Vector stores pointers to raw double values. Data.Vector.Unboxed stores the raw doubles directly
21:39:53 <williamyager> Not everything can be stored directly, because it might have a non-fixed size
21:40:03 <williamyager> but fixed-size values can be stored directly, without a pointer to them
21:40:05 <c_wraith> stores pointers to thunks that may evaluate to a Double. :)
21:40:14 <maks_> williamyager: so basically unboxed is like adding the ! in the declaration of the data structure?
21:40:17 <williamyager> ^more accurate definition
21:40:21 <williamyager> Yeah, basically
21:40:25 <williamyager> Sorry, no
21:40:28 <williamyager> wasn't paying attention
21:40:38 <williamyager> If I have "data Foo = Bar !Baz"
21:40:47 <williamyager> That means that when I evaluate the constructor and see it's a "Bar"
21:40:55 <williamyager> I will also evaluate the Baz to WHNF
21:41:00 <maks_> oh
21:41:03 <williamyager> However, Baz can be a pointer
21:41:09 <Hafydd> "data Foo = Bar !Baz" sounds even sillier than it looks, when you read it aloud.
21:41:24 <Hafydd> "data foo equals bar bang baz."
21:41:37 <williamyager> If Baz is unpacked, its bits are actually stored right inside the Bar
21:41:50 <williamyager> as opposed to Bar having a pointer to a (thunk which can become a) baz
21:41:54 <Koterpillar> so unpacked => strict
21:41:55 <Koterpillar> ?
21:41:57 <williamyager> Yes
21:42:02 <williamyager> But strick => unpacked
21:42:19 <williamyager> *Does not
21:42:29 <williamyager> strict =/> unpacked
21:42:33 <maks_> aha
21:42:35 <maks_> ok thanks guys
21:42:38 <maks_> have a goodnight!
21:45:08 <adarqui> gn
21:55:47 <cobreadmonster> c_wraith: You can reduce running time by 30%?
21:56:17 <c_wraith> Me personally?  Nah.  I was just guessing there's lots of code that supercompilation could improve by that much.
22:03:33 <cobreadmonster> c_wraith: Isn't there like a hard limit on this stuff?
22:05:02 <williamyager> cobreadmonster: There are several. For example, there is no terminating algorithm to determine if two turing machines (or lambda calculus expressions) are equivalent
22:05:48 <cobreadmonster> williamyager: sure.
22:05:59 <williamyager> However, you can do pretty well. Cutting-edge supercompilation techniques for functional languages are pretty impressive
22:07:13 <williamyager> There's some cool stuff with compiling functional programs to large supercombinator expressions, which can be compiled to machine code free of branches, which means no branch prediction invalidation, which means fast execution
22:07:23 <williamyager> Stuff like that
22:08:46 <Axman6> that sounds like it would come at the cost of code locality, which can be just asd costly
22:12:08 <williamyager> True. But on modern multi-hundred-register tomasulo machines, the optimal point is closer to "huge branch-free procedures" than "tight locality"
22:12:35 <williamyager> Plus, most locality issues are caused by nonlinearity of code, but supercombinator expressions can be compiled to a straight-line machine code program
22:12:49 <williamyager> So you don't run into issues with cache eviction
22:13:01 <williamyager> The code is packed tightly, and you're going straight through it
22:13:09 <EvanR> how do you get rid of branches??
22:13:43 <williamyager> EvanR: You can't get rid of them, but you can lift them out so you get large swathes of branch-free code (according to what little I have read)
22:14:23 <EvanR> so like, sort of doing more work now and then deciding which of it you need?
22:14:46 <EvanR> at the end
22:14:55 <ggVGc> this is exacly how shaders work afaik
22:15:02 <slack1256> I got some IO code I would like to test.
22:15:08 <ggVGc> branching in a shader just means getting two different shaders
22:15:22 <slack1256> What is the go-to option? Blogpost alway speak about mock testing (idk what that is)
22:15:45 <EvanR> what sort of IO code
22:15:47 <Koterpillar> slack1256: does it have to be IO?
22:15:47 <ggVGc> slack1256: mock testing is when you create an imitation of your receiver and hook that yp
22:15:54 <EvanR> (i.e. can it be not IO)
22:16:04 <ggVGc> slack1256: so, instead of an actual database, you might have a function just printing "Accessed database"
22:17:17 <slack1256> Mmm seems useful in this case. It is code that implements the DCC handling of a irc client
22:17:59 <slack1256> But I wonder if even my "mock" would be correct in the first place. Testing with dubious code? I won't win anything
22:18:00 <EvanR> if you had a record type for the interface to an IRC connection, you can replace the one that does IO with one that doesnt
22:18:11 <EvanR> if you parameterize the record type by the monad
22:18:44 <Koterpillar> slack1256: if you want to test it end-to-end, no way but starting an IRC server as part of your tests :)
22:18:55 <EvanR> slack1256: i dont really know what people mean by "mock" but i had much more success in ruby by providing an object to the code that actually acted like an API instead of printing "accessed database"
22:19:06 <ggVGc> slack1256: mocking is usually to find out stuff like "Do things happen in the right order" or "Does this actually ever get called at all"
22:19:21 <fr33domlover> Can I have more than one library stanza in a .cabal file or do I have to use separate ones?
22:20:06 <c_wraith> fr33domlover: I believe you are restricted to a single library stanza, though you can add as many executables as you like
22:21:45 <williamyager> Isn't there some way to tell stack to switch to a different GHC version?
22:22:54 <kadoban> Yes, you can manually set the compiler if you like.
22:23:10 <slack1256> williamyager: nix does that for free
22:24:02 <kadoban> williamyager: Usually you'll want to pick a resolver that matches the compiler you want. Are you trying to play with GHC 8 or something? I don't think there's a resolver for that yet, library support wasn't up to snuff last I checked.
22:24:34 <mgsloan> The latest nightlies use ghc-8
22:24:45 <mgsloan> Also, "ghc-8.0" is a valid resolver
22:24:50 <fr33domlover> c_wraith, thanks. Actually I want an extra library :P i'll use a separate file then
22:25:40 <kadoban> Oh do they? Nice
22:27:22 <xecycle> hi, how to tell stack to use a socks5 proxy?
22:34:33 <mgsloan> xecycle: OS settings
22:44:56 <texasmynsted> I remember when learning scala I encountered something that challenged me to re-implement a bunch of functions as folds,  (can't find this)  Is there some kind of challenge like this for haskell?  Just to get good practice implementing folds?
22:45:17 <xecycle> tried https_proxy=socks5://host, https_proxy=socks://host, SOCKS_PROXY=host, SOCKS_PROXY=socks5://host, none worked
22:45:47 <mgsloan> Does it work for other commands?
22:46:02 <xecycle> as far as I know https_proxy=socks5://host works for curl
22:46:51 <EvanR> texasmynsted: haskell wikibook does have exercises iirc
22:47:11 <mgsloan> xecycle: Perhaps this is the issue https://github.com/commercialhaskell/stack/issues/1673#issuecomment-174947997
22:47:35 <EvanR> texasmynsted: cis 194 is a haskell course online
22:47:48 <EvanR> with homework ;)
22:48:48 <xecycle> mgsloan: https://github.com/snoyberg/http-client/blob/4aa8d575d5eda1fc73ff35aa87064e33c8411fb9/http-client/Network/HTTP/Client/Manager.hs#L527 looks like they only support http:// in env
22:49:15 <texasmynsted> oh nice
22:49:19 <texasmynsted> good ideas
22:49:24 <mgsloan> xecycle: yup
22:49:49 <xecycle> so let me see if downloading the tarball manually can get it working...
22:51:32 <mgsloan> Yeah, unusual system setups are liable to run into things like this
22:51:36 <mgsloan> PRs appreciated!
22:51:54 <mgsloan> It is hard for us to address problems like this promptly because they do not affect our use of stack
22:52:11 <mgsloan> So the onus of implementation rests upon those that it affects
22:52:15 <mgsloan> (usually)
22:52:36 <mgsloan> If something is affecting a ton of users, then I will try to fix it
22:52:56 <xecycle> i'm in china here, and downloading the GHC tarball is very slow
22:53:50 <xecycle> and i have some servers where downloading that is fast enough, so i'd like to jush ssh -D and download via those
22:58:05 <rfw> are people mostly discouraged from using lens's makeFields?
23:01:29 <glguy_> It's the least principled way to go, but I don't know about "discouraged"
23:02:01 <EvanR> whats wrong with it?
23:03:15 <glguy_> If anything that it's grouping things together simply to reuse a name rather than because there's necessarily any actual commonality
23:03:29 <glguy_> so it probably doesn't make sense to write things generically in terms of the resulting classes
23:03:41 <rfw> i see
23:04:00 <rfw> yeah it just seems a little janky
23:04:15 <rfw> but so is OverloadedRecordFields, i guess
23:12:33 <glguy_> makeFields exists because someone sent a pull request with it around lens-3.8. I integrated it into makeLenses in the rewrite to reduce duplication and preserve existing functionality
23:15:30 <LiaoTao> xecycle, Sohu and 163 have mirrors for some distributions such as Gentoo which may have your tarball
23:15:40 <LiaoTao> It's really fast from within China
23:22:20 <xecycle> LiaoTao: yes i am aware of many mirrors, but stack simply goes to github aws
23:22:56 <mgsloan> xecycle: You can tell it to use a different tarball url
23:23:05 <mgsloan> But you will need to do so for every ghc you want to use
23:23:15 <Koterpillar> you can install ghc for your system and set compiler-check: newer-minor in stack/config.yaml
23:23:24 <koz_> I'm having a bit of trouble parallelizing my code with `using parList`. I get the feeling I'm not picking my strategy right. Could someone advise me? http://lpaste.net/165635
23:24:08 <mgsloan> xecycle: Yeah, Koterpillar's suggestion is a good idea
23:24:17 <xecycle> Koterpillar: that's nice.  am on arch which has 7.10.3 and my project says 7.10.2
23:24:47 <mgsloan> xecycle: Then change your "compiler-match" settings
23:25:18 <Koterpillar> xecycle: that's exactly what newer-minor allows you to do
23:25:48 <xecycle> thank you, will try that next time.  this time i have already downloaded it manually
23:26:03 <mgsloan> Yeah, it's for the manual download.
23:44:07 * hackagebot wai-cors 0.2.5 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.5 (larsk)
