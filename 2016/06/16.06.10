01:07:16 <Xandaros> Squarism: I think what you were looking for earlier is `null`
01:07:19 <Xandaros> > null []
01:07:22 <lambdabot>  True
01:07:22 <Xandaros> > null [1]
01:07:24 <lambdabot>  False
01:12:01 <arcetera> @src foldr
01:12:01 <lambdabot> foldr f z []     = z
01:12:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:16:00 <Squarism> Xandros? 
01:16:17 <arcetera> :t fmap
01:16:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:16:28 <arcetera> can anyone explain `f a -> f b`
01:16:32 <arcetera> here
01:18:42 <mniip> jle`, logarithmic recursion witnesses
01:19:01 <Rotaerk> arcetera, f is a type constructor that takes a single type parameter
01:19:09 <merijn> arcetera: What exactly do you need understand?
01:19:11 <Rotaerk> "f a" is f applied to a parameter, a
01:19:14 <arcetera> type constructor?
01:19:15 <merijn> Rotaerk: 'f' is a type variable
01:19:21 <merijn> Rotaerk: Not a constructor
01:19:27 <arcetera> what
01:20:04 <Rotaerk> err, yea sorry
01:20:09 <merijn> arcetera: The way 'a' is a variable thatn can be "any type", so is 'f' a type variable that can be any type, except only those that take another type as argument
01:20:21 <merijn> arcetera: So where 'a' can be 'Int', 'f' can be 'Maybe'
01:20:27 <arcetera> oh ok
01:20:39 <merijn> Since Maybe takes a type as argument
01:20:56 <merijn> Similarly "data Either a b = Left a | Right b" means that 'f' can be "Either Int"
01:21:05 <arcetera> i don't know what `data` means yet
01:21:20 <arcetera> that's the next chapter
01:21:42 <merijn> heh
01:21:53 <shachaf> Then you should probably learn more Haskell first, or possibly learn from a better book.
01:21:55 <merijn> Sounds like an odd order of things
01:22:00 <arcetera> quite
01:22:08 <arcetera> i started with learn you a haskell and i'm regretting that a lot
01:22:11 <merijn> I don't see why anyone would teach "fmap" and Functor before teaching data types
01:22:14 <arcetera> but i'm rading it all the way through
01:22:17 <arcetera> merijn: they didn't
01:22:37 <arcetera> instead i was told by someone in this channel "fmap is more generic, always use fmap"
01:22:42 <arcetera> beats me as to why
01:22:49 <lemonxah> the more i see of haskell the more i like it
01:22:55 <Rotaerk> more generic than what?
01:22:58 <lemonxah> it feels extremely .. clean
01:22:59 <arcetera> map
01:23:02 <lemonxah> if i can call it that .. clean
01:23:05 <arcetera> lemonxah: the more i see of haskell the more confused i get
01:23:13 <merijn> arcetera: This channel has plenty of people that give...well-intentioned but poor advice occasionally
01:23:14 <arcetera> but hopefully that will change
01:23:15 <arcetera> maybe
01:23:18 <Rotaerk> there's no reason to use the more-generic function when you know the specific types involved
01:23:21 <arcetera> ok
01:23:24 <quchen> arcetera: That statement is very much debatable, and most certainly nothing an absolute beginner should have to worry about.
01:23:45 <merijn> arcetera: Such as telling someone to use "fmap" instead of "map" when they don't even know typeclasses, etc. :)
01:24:08 <arcetera> ok
01:24:38 <arcetera> i know typeclasses
01:24:42 <arcetera> that was chapter 2
01:24:52 <arcetera> but not how to create them
01:25:16 <Rotaerk> you might consider a different learning resource
01:25:23 <arcetera> yes
01:25:31 <quchen> What resource is that anyway
01:25:38 <arcetera> because so far this has all been a confusing painful mess
01:25:41 <arcetera> learn you a haskell
01:25:50 <arcetera> it's the only(tm) tutorial i was aware of and i regret starting with it
01:26:37 <Rotaerk> arcetera, https://github.com/bitemyapp/learnhaskell
01:27:05 <arcetera> ok
01:27:10 <quchen> Chapter 2 doesn't have typeclasses in LYAH.
01:27:27 <arcetera> oh no that was chapter 3
01:28:30 * hackagebot network-api-support 0.2.2 - Toolkit for building http client libraries over Network.Http.Conduit  https://hackage.haskell.org/package/network-api-support-0.2.2 (MarkHibberd)
01:28:42 <arcetera> Rotaerk: yeah, i'm aware
01:28:58 <Rotaerk> oh?
01:29:00 <Rotaerk> of? *
01:29:13 <arcetera> cis194
01:29:30 <arcetera> which i will do after finishing lyah
01:29:43 <arcetera> because i have a rule of thumb that if i start learning material then i finish learning material
01:30:19 <Rotaerk> even if the learning material isn't optimal?
01:30:24 <arcetera> yes
01:30:26 <Rotaerk> doesn't sound like a very agile strategy
01:30:35 <arcetera> yes
01:34:23 <tobiasBora> Hello,
01:34:32 <arcetera> @src Bool
01:34:32 <lambdabot> data Bool = False | True deriving (Eq, Ord)
01:34:58 <arcetera> @src Int
01:34:58 <lambdabot> data Int = I# Int#
01:35:03 <arcetera> wha-
01:36:14 <tobiasBora> A little question about monad : I would like to do "all f l", with f :: a -> IO Bool, and I would like to get in result a IO Bool. If it were "all l f", then I would run "all l <$> f" (I think), but in this order I don't know how to processed without changing the arguments order of all...
01:36:15 <arcetera> you know what screw this i'm just going to start cis194.
01:38:02 <lyxia> tobiasBora: all just won't work with this f
01:38:08 <lyxia> since f is not a -> Bool
01:38:36 <Rembane> tobiasBora: What's the type of the list you wanna run all on?
01:38:47 <lyxia> monad-loops has allM
01:38:59 <tobiasBora> lyxia: So how could I solve my problem without rewriting the all function ?
01:39:00 <Rembane> tobiasBora: Or: return $ all f xs
01:39:12 <tobiasBora> Rembane: The list is [a]
01:39:42 <tobiasBora> Rembane: Hum... return $ all f xs won't work since f is not a -> Bool right ?
01:39:50 <tobiasBora> lyxia: I will look at it, thank you
01:39:52 <Rembane> tobiasBora: Indeed, what is f?
01:40:11 <Rembane> tobiasBora: nvm
01:40:14 <tobiasBora> Rembane: f is a -> IO Bool as written above
01:40:14 <quchen> Step 1: write down the type signature of your "all".
01:40:39 <Rembane> :t all
01:40:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
01:40:43 <Rembane> :t and
01:40:44 <lambdabot> Foldable t => t Bool -> Bool
01:41:12 <bernalex> are people in here using intero?
01:42:02 <bernalex> i.e. intero.el. :)
01:42:14 <Rembane> tobiasBora: all fst <$> mapM (\x -> do x' <- f x; (x', x)) xs
01:42:33 <bernalex> it seems like it's not picking up basic things that ghc-mod are. which is odd.
01:43:03 <lyxia> :t \f -> fmap and . mapM f
01:43:04 <lambdabot> (Monad f, Traversable t) => (a -> f Bool) -> t a -> f Bool
01:46:00 <tobiasBora> Rembane: lyxia : Great, thank you !
02:07:32 <tobiasBora> Hum...
02:07:40 <tobiasBora> Really I don't understand this : http://paste.debian.net/733982
02:08:13 <tobiasBora> Quickeck tels me that my property is true while it's obviously false !!!
02:09:04 <Rembane> tobiasBora: No worries, good luck!
02:11:17 <tobiasBora> I just build a minimalist example : http://paste.debian.net/733984
02:11:25 <tobiasBora> hum
02:11:28 <tobiasBora> I'm stupid
02:11:34 <tobiasBora> I must use assert, and not return
02:13:13 <lemonxah> is there a why to messure how fast the repl is?
02:13:37 <lemonxah> how long it took to execute the last command
02:16:01 <merijn> lemonxah: Maybe, but ghci uses bytecode interpretation without much optimisation, so it's not a very good indication
02:16:09 <lemonxah> hmm is it possible to make :set +s be more precice?
02:16:18 <lemonxah> oh ok
02:16:35 <lemonxah> i was just interested in testing something vs jvm
02:16:42 <lemonxah> even if its not very optimized
02:17:10 <lemonxah> is it possible to make :set +s print out in nano seconds or ms instead of just seconds?
02:17:13 <Arguggi> (I'm using warp-tls) Switching from tlsSettings certPath keyPath to tlsSettingsMemory cert key (where cert and key are read strictly with Data.ByteString.readFile) breaks my server. Looking at the code they seem exactly the same though. errors: http://pastie.org/10871500
02:18:32 * hackagebot dunai 0.0.1.0 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.0.1.0 (IvanPerez)
02:19:05 <Arguggi> Context: I'm trying to upgrade a websocket application to a wai application with wai-websockets and I'm using warp-tls so that I can use wss . Any ideas?
02:23:30 <sshine> Arguggi, why are you not handling TLS through e.g. nginx? (just curious. I don't know what wss is.)
02:23:32 * hackagebot bearriver 0.0.1 - A Yampa replacement based on Dunai.  https://hackage.haskell.org/package/bearriver-0.0.1 (IvanPerez)
02:29:34 <Arguggi> sshine, I could, this was more of an experiment. But I also can't add subdomains to my dns records so just listening on a random port and using haskell to handle tls seemed simpler. BTW it works when using tlsSettings, just not when using tlsSettingsMemory.
02:30:43 <Arguggi> Since I have to read the root owned cert/key files I also need to start the server as root, but if I can read them in memory then I can drop privileges to a normal user, thats why I'm trying tlsSettingsMemory
02:33:32 * hackagebot hlint 1.9.35 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.35 (NeilMitchell)
02:37:20 <Arguggi> looking at the code (https://s3.amazonaws.com/haddock.stackage.org/lts-6.2/warp-tls-3.2.1/src/Network-Wai-Handler-WarpTLS.html#runTLSSocket) the only difference seems to be that when using tlsSettings TLS.credentialLoadX509Chain is called but when using tlsSettingsMemory TLS.credentialLoadX509ChainFromMemory is called instead.
02:48:33 * hackagebot threads 0.5.1.4 - Fork threads and wait for their result  https://hackage.haskell.org/package/threads-0.5.1.4 (BasVanDijk)
02:51:38 <ocramz> hi there
02:52:46 <Tekkkz> Hello! I like the programming language Haskell. I found a compiler (clash) which compiles vhdl code from haskell code. What do you think about it? should i start learning fpga with that, because I like haskell a lot, or would you not recommend it?
02:53:26 <ocramz> Tekkkz: why would you use Clash if you don't know vhdl?
02:54:36 <Tekkkz> ? because then i can program in haskell instead of vhdl?
02:55:17 <srhb> Tekkkz: Sounds completely reasonable.
02:55:46 <Tekkkz> srhb: ok. i also like this idea
02:56:18 <merijn> ocramz: Because the entire point of clash is not needing to know the mess that is vhdl? :p
02:57:22 <ocramz> sure, sure. There are different degrees of "knowing Vhdl", or anything else for that matter. Between typing in a whole CPU from memory to knowing how to interpret the output of Clash
02:57:33 <liste> Tekkkz: I'd still learn VHDL too, it can sometimes help with debugging when you can look at the output of Clash
02:57:55 <Tekkkz> okay
03:05:42 <arcetera> 3/3
03:05:45 <arcetera> oops
03:06:20 <lemonxah> wow criterion is cool
03:28:35 * hackagebot symengine 0.1.2.0 - SymEngine symbolic mathematics engine for Haskell  https://hackage.haskell.org/package/symengine-0.1.2.0 (bollu)
03:28:44 <bollu> how come my package doesn't show docs? https://hackage.haskell.org/package/symengine-0.1.2.0
03:29:10 <bollu> do I need to build and upload docs separately?
03:37:56 <Cale> bollu: It can sometimes take quite a while for docs to be generated
03:38:05 <bollu> Cale: oh, I see
03:38:20 <Cale> It says "Docs pending", so that means there wasn't some failure to generate them at least.
03:38:24 <bollu> Cale: any way I can package my build "with the docs" so to speak?
03:39:41 <Cale> Yeah, it's possible to put the docs in the tarball you send to hackage, or send them separately. Neil Mitchell's 'neil' program makes it easy to do that http://neilmitchell.blogspot.ca/2014/10/fixing-haddock-docs-on-hackage.html
03:40:03 <hexagoxel> cabal upload --doc, if you have cabal-install>=1.22.8
03:40:16 <Cale> oh, nice
03:40:22 <Cale> I didn't know they added that :)
03:42:19 <bollu> ooh, neat
03:42:23 <hexagoxel> also, my wrapper around cabal-install, iridium.
03:42:31 <hexagoxel> @hackage iridium
03:42:31 <lambdabot> http://hackage.haskell.org/package/iridium
03:43:06 <bollu> hexagoxel: I'm using stack - I'm assuming it has the same feature?
03:43:20 <bollu> nope, it doesn't :(
03:45:13 <bollu> Cale: do you have a few minutes? I had an adjunctions question
03:45:23 <hexagoxel> (hmm, i probably could support stack as a backend if the user provides multiple stack-ccc.yaml's for testing against multiple ghc versions..)
03:45:56 <Cale> bollu: What's the question?
03:46:25 <bollu> clearly, every adjunction yields a monad (by using Compose). However, does every monad recreate an adjunction?
03:46:35 <bollu> I've dabbled with the Kleisli category
03:46:42 <bollu> and I understand that it has something to do with the answer to my question
03:46:46 <bollu> but I don't really know what
03:47:07 <Cale> Every monad comes from at least two adjunctions, and yeah, one of them is an adjunction via the Kleisli category
03:48:08 <bollu> Cale: I can describe one of the functors in the adjunctions: C -> Kleisli M
03:48:21 <bollu> it takes objects in C to themselves, and arrows A -> B to A -> M B correct?
03:48:42 <bollu> (with arrow composition being the usual monadic >=> combination in the Kleisli category)?
03:48:56 <Cale> yeah
03:49:21 <Cale> That's the direction from the Kleisli category to the original one
03:49:44 <bollu> Cale: what? no, that's from the original to kelisli right?
03:49:53 <bollu> because I'm taking the more "basic" arrow A -> B
03:49:58 <Cale> Every arrow A -> B in the Kleisli category *is* an arrow A -> M B in the original category
03:49:59 <bollu> and I'm making it a A -> M B
03:50:03 <bollu> ohh
03:50:04 <bollu> oh
03:50:05 <bollu> wow
03:50:06 <Cale> so you just send each arrow to itself
03:50:09 <bollu> okay, that makes more sense
03:50:24 <Cale> er, sorry, no, that doesn't work
03:50:27 <Franciman> Hello, doesn't stack support ghc 8.0.1?
03:50:36 <Cale> We're acting inconsistently on the objects then :)
03:50:52 <bollu> wait, isn't the functor like F(o \in C) = o \in K (keep the objects the same
03:51:04 <bollu> F((a -> b) \in C) = (a -> m b) \in K
03:51:06 <bollu> right?
03:51:06 <locallycompact> Franciman, you can set resolver: ghc-8.0.1 in your stack.yaml
03:51:18 <Cale> However, we can send an arrow A -> B in the Kleisli category (which is an arrow A -> M B in C) to an arrow M A -> M B in C by precomposing with the unit.
03:51:32 <bollu> hmm
03:51:50 <Franciman> locallycompact, can resolver contain more values?
03:51:54 <Franciman> because now it has lts-6.2
03:51:57 <Cale> uhhh
03:52:11 <Cale> oh
03:52:17 <Cale> Apparently that's not what we want to do
03:52:22 <bollu> I'm confused now. I always thought you used "m" to go from the original category to the kleisli category
03:52:25 <Cale> here it is
03:53:10 <Franciman> oh, ok I solved by just replacing, thanks for help, locallycompact 
03:53:26 <Cale> So, F: C -> C_T has FX = X, and when a: X -> Y, then Fa = eta_Y . a
03:54:39 <Cale> and then G: C_T -> C has GY = TY, and for a: X -> Y in C_T, i.e. a: X -> TY in C, we have Ga = mu_Y . Ta
03:54:59 <bollu> Cale: eta_Y = return right?
03:55:02 <Cale> yeah
03:55:07 <Cale> and mu_Y = join
03:55:19 <Cale> So that's Ga = join . fmap a
03:55:58 <bollu> Cale: how does GY = TY work out? "T" is the monad right? so given an object "a", we create an "m a" ?
03:56:06 <bollu> that seems weird, but I'll roll with it
03:56:20 <bollu> I'm assuming the adjunction conditions force you to pick that?
03:56:29 <Cale> So from a Kleisli arrow X ~> Y, it has an underlying arrow X -> TY in C, and we turn that into an arrow TX -> TY in C
03:56:35 <Cale> which is basically what bind does
03:56:38 <Cale> :t (=<<)
03:56:39 <lambdabot> Monad m => (a -> m b) -> m a -> m b
03:56:49 <bollu> oh wow o_O
03:56:51 <Cale> (a -> m b) -> (m a -> m b)
03:56:55 <bollu> I'd never seen it that way
03:57:57 <merijn> I think =<< and >=> are more enlightening than >>= when it comes to seeing the theoretical picture
03:58:05 <merijn> It's just that >>= is more practical :)
03:58:18 <Cale> Or even =<< and <=<
03:58:24 <merijn> :t (<=<)
03:58:26 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
03:58:38 <Cale> :t (.)
03:58:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:58:44 <bollu> Cale: in G: C_T -> C, Y is an object in C_T right?
03:58:46 <EvanR> yes backwards is best
03:58:52 <Cale> yeah
03:59:08 <Cale> bollu: But C_T and C have the same objects
03:59:19 <Cale> So it's also an object of C
03:59:31 <bollu> Cale: exactly, so wouldn't you intuitively pick G: C_T -> C, G(Y) = Y?
03:59:41 <bollu> I don't see why I need a G(Y) = TY (intuitively)
03:59:49 <Cale> bollu: but then what do you do?
04:00:12 <Cale> So you have a Kleisli arrow a: X ~> Y, which has an underlying arrow X -> TY
04:00:20 <Cale> and now you need to get an arrow X -> Y
04:00:40 <bollu> Cale: ahh
04:00:42 <Cale> because your functor C_T -> C is supposed to act as the identity on objects
04:00:54 <Cale> So that doesn't work
04:01:30 <Cale> But if you pick GY = TY, then you only need to get an arrow TX -> TY, which is doable
04:01:34 <bollu> Cale: so the choice is to take a to "m x" and then take the arrow X ~> Y (which is x -> m y) to (m x ->  m y) ?
04:01:50 <Cale> take x to m x, you mean?
04:01:55 <bollu> yes, sorry
04:02:07 <Cale> yeah
04:02:38 <bollu> so, how is it that when you "remap" all objects from C_T to C (by taking "a" to "m a")
04:02:48 <bollu> my arrow from x -> m y just because m x -> m y?
04:02:56 <bollu> shouldn't it become m x -> m (m y) or something?
04:02:56 <Cale> and don't forget, our goal was to find an adjunction with F left adjoint to G such that GF = T
04:03:19 <bollu> correct, we want to retrieve the monad from the adjunction
04:03:24 <Cale> So if one of the two acts as the identity on objects, the other had better act as T on the objects.
04:03:34 <bollu> ah, I see
04:03:54 <bollu> so in this case, is it sensible to ask which is free and which is forgetful? or is this one of those adjunctions where it doesn't apply?
04:04:08 <bollu> and what about the question of  remapping objects: (the m x -> m (m y))?
04:05:35 <Cale> Free is left adjoint to forgetful
04:06:07 <Cale> The free/forgetful terminology is perhaps a little unhelpful here
04:06:08 <kmelva> Can someone help me fix this code: https://gist.github.com/kmelva/5369ba2a89d10523cb30203c2affdab2 ? I understand (kinda) the type error, but I don't get how to fix it...
04:06:46 <kmelva> I know I could change `baz :: a -> [String]` to `baz :: t a -> [String]`, but I don't want to do that...
04:07:03 <bollu> Cale: okay, I was just wondering if I could draw parallels
04:08:13 <bollu> Cale: I'm still bugged by the remapping thing. If our functor G: C_T -> C takes G(Y) = TY shouldn't it take G(X ~> Y = (X -> TY)) = TX -> T(TY)?
04:09:32 <Cale> bollu: There's a join in there
04:09:48 <Cale> kmelva: You're missing a type argument to Rep
04:09:58 <bollu> Cale: is the join only for cleanliness' sake, or do we join to keep the functor "proper"?
04:10:07 <bollu> Cale: I think the latter, right? to ensure it maps correctly?
04:10:10 <Cale> bollu: Well, it's just a type error if we don't have it
04:10:31 <bollu> Cale: why? T is an endofunctor, so T(TY) is still an object of C
04:10:48 <Cale> bollu: Well, how does G act on objects?
04:11:01 <Cale> We said GY = TY
04:11:03 <bollu> G takes Y to TY
04:11:39 <Cale> so given an arrow a: A ~> B, in C_T, G is supposed to give us an arrow GA -> GB in C
04:11:56 <Cale> but that's TA -> TB
04:11:56 <bollu> ohh
04:11:58 <bollu> right
04:12:12 <bollu> hm, I'd never noticed how "strong" the functor conditions are in that sense
04:12:13 <kmelva> Cale: Yup, I think I get that since Rep is `* -> * -> *`, but how do I fix the bazer type?
04:12:57 <bollu> Cale: right now I'm at this stage where Functor is too elementary but Kan extension is too much :P I think I get limits, colimits and adjunctions, and I sorta "intuit" kan extensions
04:13:34 <EvanR> Functor is misleadingly elementary
04:13:58 <bollu> Cale: I need exercises for this. MacLane draws from branches of math I don't have much of experience with (algebraic topology IIRC the last time I used it). Do you have any book recommendations?
04:14:29 <ocramz> a tooling conundrum: I just found out that ghc 7.10.3 has a bug with how it handles dyn.linking. Bouncing back to 7.8 means that the Stackage snapshot doesn't include some functions I need, and ghc 8 doesn't have an LTS snapshot yet. Any suggestions?
04:15:05 <EvanR> ghc 8 fixed it?
04:15:25 <ocramz> EvanR: that's what I'd like to find out
04:15:39 <EvanR> you could install it without stack
04:17:03 <ocramz> cabal sandboxes all over again?
04:17:18 <ocramz> but I kinda like the stackage idea
04:17:34 <ocramz> actually, it simplified my life quite a bit
04:18:07 <hvr> ocramz: what part did it specifically simplify?
04:18:09 <Cale> kmelva: Well, you need that for any x, there's an instance of Baz (Rep a x), but you can't write that
04:18:37 * hackagebot stylish-haskell 0.5.17.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.17.0 (JasperVanDerJeugt)
04:18:39 <ocramz> hvr: well, not having to think about mutually conflicting version bounds I guess
04:18:48 <ocramz> I import new libraries rather deliberately
04:18:54 <Cale> kmelva: There are some approaches to expressing that, but a simple one might be just to have a Baz1 class, which would have an instance for (Rep a) instead of (Rep a x)
04:21:06 <Cale> (analogous to how there's Generic1 and Rep1 ...)
04:21:09 <kmelva> Cale: I see, so that's why all the generic examples/tutorials have two generic classes, a private and public one? What would be the other approaches? I'm not trying to code anything specifically, it's all for learning purposes
04:22:10 <Cale> http://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint-Forall.html -- there's this, which uses unsafeCoerce internally, but it should be safe.
04:23:25 <kmelva> Oh wow, that's definitely too advanced for me right now :)
04:32:05 <hexagoxel> ocramz: but the nightly is on ghc-8.
04:41:36 <lpaste> Cale pasted “No title” at http://lpaste.net/165700
04:41:42 <Cale> kmelva: ^^
04:42:41 <Cale> kmelva: It would be nice if we could eliminate at least one of the explicit type signatures there, but I couldn't work out how
05:13:39 * hackagebot ttask 0.0.1.0 - This is task management tool for yourself, that inspired by scrum.  https://hackage.haskell.org/package/ttask-0.0.1.0 (outoftune)
05:21:14 <zoran119_> give a function like this: stuff xs = fun3 $ fun2 $ fun1 xs, can i use trace to print the length of the resulting list before the function returns?
05:22:01 <zoran119_> so like: stuff xs = trace("size: " ++ (show $ length _something_) fun3 $ fun2 $ fun1 xs
05:22:23 <zoran119_> missing one ) there...
05:23:57 <pavonia> You might want to use a lambda expression like (\list -> trace ... length list)
05:24:10 <merijn> zoran119_: What do you mean "before the function returns"?
05:24:25 <mauke> :t trace
05:24:26 <lambdabot> Not in scope: ‘trace’
05:26:03 <zoran119_> so, for a simple case, if i had a function add2 x = x + 2
05:26:10 <mauke> join (trace . printf "size: %d" . length)
05:26:13 <mauke> slightly evil
05:26:57 <zoran119_> i can trace like this: add2 x = trace("adding to " ++ show x) x + 2
05:27:29 <zoran119_> but if i want to trace the actual return value i have to repeat the function definition inside the trace call
05:28:00 <zoran119_> add2 x = trace("returning " ++ (show $ x + 2)) x + 2
05:28:30 <zoran119_> i don't want to repeat the function implementation
05:28:33 <zoran119_> is there a way?
05:28:53 <pavonia> Yes, lambda expressions or let-bindings
05:29:28 <mauke> zoran119_: add2 x = (\r -> trace ("returning " ++ show r) r) (x + 2)
05:30:02 <zoran119_> mauke: excellent, thanks!
05:33:11 <mauke> traceAs s f x = trace (s ++ " " ++ show (f x)) x
05:33:37 <mauke> stuff xs = traceAs "size:" length $ fun3 $ fun2 $ fun1 xs
06:06:52 <tobiasBora> Hello,
06:07:14 <tobiasBora> With Chart, is there a way to display a diagrams on screen faster than with this code http://paste.debian.net/734600 ?
06:07:34 <tobiasBora> (all the examples in the doc write it in a file=
06:12:51 <Pennyw95> Hi, could you help with an exercise with the state monad? the exercise is described here: https://en.m.wikibooks.org/wiki/Haskell/Understanding_monads/State and it's the first of the 5 given at the end of the "Dice and State" paragraph
06:13:43 <Pennyw95> here's what I've come up with... is this proper?  https://gist.github.com/DrBenway95/d09b757ac2d48e6be218d2bcc39e9f7e
06:16:22 <Pennyw95> also, can StateT be used wherever one would use State?
06:16:29 <sbrg> yes
06:16:55 <sbrg> type State = StateT Identity 
06:17:06 <Pennyw95> I noticed that they use State StdGen Int instead of StateT StdGen Int in the function type, although Control.Monad.Trans.State is imported instead
06:17:28 <Pennyw95> oh, neat
06:17:53 <sbrg> StateT StdGen Int is missing an argument. It takes an additional argument
06:18:11 <Pennyw95> that would be.... StateT StdGen Int Identity?
06:18:13 <sbrg> so if you wanted to be able to, say, do IO as well, you could do StateT IO StdGen
06:18:30 <sbrg> well, for State it would be StateT Identity StdGen Int
06:18:42 <sbrg> uh, let me just confirm that
06:18:44 <Pennyw95> sure...I was thinking about getting the gen inside main :: IO () and then pass the gen to a pure function though
06:19:00 <Pennyw95> to keep as simple as possible until the hang of this
06:19:07 <Pennyw95> until I get*
06:19:39 <sshine> Pennyw95, you're not really using 'gen' inside your do-block?
06:20:08 <Pennyw95> uhm
06:20:11 <Pennyw95> correct..
06:20:15 <sbrg> yes, that's also fine. but as for your solution, I don't think it's correct. does it typecheck? 
06:20:42 <Pennyw95> Couldn't match type `b0 -> (a0, b0)' with `[Int]'
06:21:20 <Pennyw95> so, the function is trying to solve this on its own instead of return a State I'd use with 'runState rollDice (mkStdGen 0)'?
06:22:15 <Pennyw95> uhm, maybe the signature should also be Int -> State [Int] StdGen... with the result before the state
06:23:16 <quchen> Just compared the canonical Quicksort-like function with Data.List.sort for sorting [1..100] - 260k vs 6k STG steps. Makes one appreciate the beauty of that algorithm even more
06:23:24 <Pennyw95> uhm okay so...I need to compose randomR n times, right? and each randomR should pass the state to the next one
06:23:59 <sbrg> Pennyw95: yes. you need to pass the new generator of each randomR to the next randomR, and keep the values that are returned as well(the random values). 
06:25:00 <Pennyw95> so, I need a small function that makes randomR work with State, compose that with "foldr (<=<) return (replicate n roll)" and then evalState?
06:27:25 <sbrg> Pennyw95: easiest way would be wrap randomR in a State function, yes
06:27:46 <sbrg> that 1. takes the gen from state 2. gets a random value 3. updates the gen in state 4. returns the value
06:28:05 <sbrg> then you can just do: replicateM 6 (yourRandomFunc (1, 6)) or some such
06:28:51 <sbrg> Pennyw95: but by then you're basically on your way to implement MonadRandom, heh. 
06:29:00 <Pennyw95> like, myRandomR = do { gen <- get; return $ randomR (1, 6) gen } ?
06:29:02 * hackagebot clckwrks-plugin-page 0.4.3.2 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.2 (JeremyShaw)
06:29:11 <Pennyw95> well, for learning purposes :)
06:29:41 <sbrg> Pennyw95: close, but you don't update the generator
06:29:43 <sbrg> :t modify
06:29:44 <lambdabot> MonadState s m => (s -> s) -> m ()
06:30:17 <sbrg> eh I guess just get and put would be easier
06:30:40 <sbrg> :t do { s <- get; (v, g) <- randomR (1, 6) s; put g; return v }
06:30:41 <lambdabot>     Occurs check: cannot construct the infinite type: s0 ~ (b, s0)
06:30:41 <lambdabot>     arising from a functional dependency between constraints:
06:30:41 <lambdabot>       ‘MonadState (b, s0) ((,) a)’
06:30:43 <rmk0> 'lo. when playing around in ghci with data structures, i find the string representations of values that have used "deriving Show" to be... hard to read: http://paste.lisp.org/display/318012
06:31:02 <rmk0> is there a pleasant way to get slightly more readable output? indentation, perhaps?
06:31:09 <rmk0> bear in mind that i don't control the definitions of the original types
06:31:33 <sbrg> rmk0: there's pretty-printing libraries thta can help with that
06:32:02 <rmk0> sbrg: would that require me to manually write new instances?
06:32:14 <sbrg> rmk0: I don't think so
06:32:24 <rmk0> hm!
06:32:29 <sbrg> :t do { s <- get; let (v, g) = randomR (1, 6) 6; put g; return v }
06:32:30 <lambdabot> parse error on input ‘;’
06:32:36 <sbrg> eh..
06:32:43 <Pennyw95> sbrg: like this? https://gist.github.com/DrBenway95/d09b757ac2d48e6be218d2bcc39e9f7e
06:33:28 <sbrg> Pennyw95: yes
06:33:38 <rmk0> sbrg: https://hackage.haskell.org/package/ipprint  <- is that what you were referring to?
06:33:50 <sbrg> does that typecheck? you can use replicateM, even simpler
06:34:19 <sbrg> rmk0: I guess that's one. I haven't used them very often and don't really have a recommendation
06:34:27 * rmk0 tries it
06:35:14 <jstolarek> does Yesod provide a DSL for handling SQL queries?
06:35:27 <jstolarek> meaning that I write them in Haskell nad they get executed on the database?
06:35:30 <Ankhers> jstolarek: It uses the persistent package.
06:35:34 <sbrg> jstolarek: there's esqueleto
06:35:53 <Ankhers> I really enjoyed using esqueleto.
06:36:14 <Pennyw95> Err.... I don't get why this happens..
06:36:21 <sbrg> persistent also has simpler functions that work for a lot of queries. those are translated to pretty efficient SQL afaik. then there's esequeleto that I think gives you the full power of sql
06:36:31 <Pennyw95>  No instance for (Random (m0 b0)) arising from a use of `randomR'
06:36:41 <Pennyw95> In the expression: randomR (1, 6) gen
06:36:59 <sbrg> Pennyw95: you're missing a let
06:37:07 <sbrg> let (v, g) = .. 
06:37:14 <jstolarek> ah, persistent guarantees types safety
06:37:43 <Pennyw95> nope, I did put that
06:37:45 <sbrg> jstolarek: im my experience, persistent and esqueleto are really, really nice. 
06:38:24 <jstolarek> I'm trying to figire out how they compareto  approaches like Links or Ur/Web
06:38:40 <jstolarek> I'm interested in theoretical differences in handling type safety and performance guaramtees
06:38:55 <Pennyw95> full log:  https://gist.github.com/DrBenway95/d09b757ac2d48e6be218d2bcc39e9f7e
06:38:56 <EvanR> i noticed that certain kinds of subtypes are subsets (theres an injective conversion to the supertype) and some subtypes are quotients (forget some of the fields of an interface)
06:39:13 <EvanR> but i did not notice that... subsetness and quotients are opposite notions
06:39:31 <EvanR> which makes subtyping seem even more arbitrary
06:39:59 <bergmark> jstolarek: we've done lots performance analysis of opaleye vs plain queries on postgres, most of the time the query plans are identical
06:40:13 <sbrg> Pennyw95: https://gist.github.com/19a8bcf4757ac99161019b6174e83747
06:40:47 <sbrg> oh, you can remove the "gen <- get" as well
06:40:52 <sbrg> in rollDice
06:40:56 <jstolarek> bergmark: who are "we"? :-) I mean, is this published somewhere?
06:42:23 <Pennyw95> sbrg: so, replacing "foldr (<=<) return (replicate n roll)" with "replicateM n roll" fixed it
06:42:40 <bergmark> jstolarek: www.silk.co, but no we haven't published anything about it unfortunately :-/ but we have the library we use on top of opaleye on github https://github.com/silkapp/silk-opaleye
06:43:11 <Pennyw95> maybe it was because my way didn't pass the state while replicateM does?
06:43:54 <sbrg> Pennyw95: yes. you could also have used: sequence (replicate n roll). 
06:44:17 <Pennyw95> so my way like, used >> to chain the functions while replicateM uses >>=?
06:45:46 <jstolarek> bergmark: thanks :-)
06:52:17 <codedmart> Is there a common name for a function with this signature? f g x = f x (g x)? So you have two functions that both take x, but f takes x and g x?
06:52:34 <arcetera> :t foldl
06:52:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:53:51 <codedmart> arcetera: That looks slightly different to me.
06:54:37 <EvanR> codedmart: S combinator?
06:54:47 <EvanR> :t (<*>)
06:54:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:55:31 <EvanR> :t \f g x -> f x (g x)
06:55:32 <lambdabot> (r2 -> r1 -> r) -> (r2 -> r1) -> r2 -> r
06:56:10 <EvanR> let the applicative be (r2 ->)
06:57:53 <Xandaros> cocreature: I might do something with dynamic module loading for the shits and giggles. Are you going to put the stuff you discovered in a library? (Since plugins doesn't seem to work… at all)
06:58:07 <EvanR> > (+) <*> (+3) 100
06:58:09 <lambdabot>      No instance for (Typeable a0)
06:58:09 <lambdabot>        arising from a use of ‘show_M201706134184522427119982’
06:58:09 <lambdabot>      In the expression:
06:58:33 <codedmart> Thanks!
06:58:37 <prannayk> Interesting projects one might undertake to get used to using Monads?
06:58:42 <cocreature> Xandaros: haven’t planned anything atm, need to do too much stuff right now. but someone mentioned in the reddit comments that with -rdynamic it also works with plugins directly
06:59:22 <Xandaros> Ah, good to know
07:00:27 <EvanR> > ((+) <*> (+3)) 100
07:00:29 <lambdabot>  203
07:00:58 <Xandaros> cocreature: Now all I need is a bloody tutorial for how to use the thing :P
07:01:17 <cocreature> Xandaros: iirc there are quite a few examples in the test suite
07:01:51 <Xandaros> Oh, yes. “Quite a few” is an understatement! o_O
07:02:12 <cocreature> it’s a makefile mess iirc so running the testsuite is not easy but the examples are still useful
07:06:01 <Xandaros> …yeah… it certainly is a mess
07:06:05 <Xandaros> Thanks for the hint, though :)
07:07:22 <Clint> @djinn (a -> m b) -> a -> m (a,b)
07:07:23 <lambdabot> -- f cannot be realized.
07:09:04 * hackagebot clckwrks-plugin-media 0.6.16 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.16 (JeremyShaw)
07:09:49 <cocreature> :t (pure &&&)
07:09:50 <lambdabot> Applicative f => (b -> c') -> b -> (f b, c')
07:09:53 <cocreature> ^ Clint 
07:09:59 <cocreature> oh no
07:10:01 <cocreature> sry
07:10:57 <Xandaros> So, loadFunctions looks up a symbol in a module? Weird name…
07:11:10 <Xandaros> Anyway, I'll see if I'm actually going to use it, but now I want to :P
07:11:27 <cocreature> :t \f -> uncurry (liftA2 (,)) (pure &&& f)
07:11:28 <lambdabot>     Couldn't match expected type ‘((c, a), c)’
07:11:28 <lambdabot>                 with actual type ‘a0 -> f0 a0’
07:11:29 <lambdabot>     Relevant bindings include
07:11:38 <cocreature> :t \f -> uncurry (liftA2 (,)) . (pure &&& f)
07:11:39 <lambdabot> Applicative f => (a -> f b) -> a -> f (a, b)
07:11:48 <cocreature> ^ Clint 
07:12:17 <Clint> cocreature: thanks
07:12:33 <hpc> that definition is horrendous
07:12:47 <cocreature> hpc: come on, let me have some fun code golfing :P
07:12:53 <Eduard_Munteanu> Hi. Any chance we can get a Haskell Platform flatpak? Or even a ghcjs flatpak?
07:13:25 <hpc> cocreature: a simple "thank you" would suffice ;)
07:13:58 <quchen> :t \f a -> do { b <- f a; pure (a,b) }
07:13:59 <lambdabot> Monad m => (t -> m t1) -> t -> m (t, t1)
07:14:15 <quchen> "Golfing"
07:14:20 <cocreature> heh
07:14:30 <hpc> cocreature: also consider this an invitation to apply your talents to acme-php
07:15:27 <hpc> cocreature: maybe you can someday top the golf masterpiece that is sortBy compare = head . head . dropWhile (isn't unsafeCoerce . drop 1) . group . iterate bubble
07:16:31 <cocreature> that’s going to be hard
07:16:58 <quchen> I think you two are mixing up golfing and obfuscation.
07:17:15 <Xandaros> Totally pointless
07:17:35 <quchen> > id id id id id id id id id id id id id id id id id id id id id id id id () -- Not golfing.
07:17:41 <lambdabot>  mueval-core: Time limit exceeded
07:17:41 <lambdabot>  mueval: ExitFailure 1
07:17:49 <quchen> Poor typechecker
07:17:53 <Xandaros> o_O
07:18:03 * hpc tries that
07:18:22 <quchen> Xandaros: What's the type of the leftmost `id`?
07:18:59 <Xandaros> Won't fit in an irc message, I'm pretty sure
07:19:11 <quchen> Let's see!
07:19:19 <quchen> > _ id ()
07:19:20 <lambdabot>      Found hole ‘_’ with type: (a0 -> a0) -> () -> t
07:19:20 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
07:19:20 <lambdabot>             ‘t’ is a rigid type variable bound by
07:19:22 <quchen> > _ id id ()
07:19:24 <lambdabot>      Found hole ‘_’ with type: (a0 -> a0) -> (a1 -> a1) -> () -> t
07:19:24 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
07:19:25 <lambdabot>             ‘a1’ is an ambiguous type variable
07:19:26 <quchen> > _ id id id ()
07:19:27 <lambdabot>      Found hole ‘_’
07:19:29 <lambdabot>        with type: (a0 -> a0) -> (a1 -> a1) -> (a2 -> a2) -> () -> t
07:19:31 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
07:19:42 * Clint waits.
07:20:01 <quchen> So the hole's type seems to grow linearly. But how do the a scale with n? :-)
07:20:43 <quchen> Let's use the asTypeOf trick!
07:20:47 <quchen> > (_ `asTypeOf` id) ()
07:20:49 <lambdabot>      Found hole ‘_’ with type: () -> ()
07:20:49 <lambdabot>      In the first argument of ‘asTypeOf’, namely ‘_’
07:20:49 <lambdabot>      In the expression: _ `asTypeOf` id
07:20:50 <quchen> > (_ `asTypeOf` id) id ()
07:20:52 <lambdabot>      Found hole ‘_’ with type: (() -> ()) -> () -> ()
07:20:52 <lambdabot>      In the first argument of ‘asTypeOf’, namely ‘_’
07:20:52 <lambdabot>      In the expression: _ `asTypeOf` id
07:20:55 <quchen> > (_ `asTypeOf` id) id id ()
07:20:56 <lambdabot>      Found hole ‘_’
07:20:56 <lambdabot>        with type: ((() -> ()) -> () -> ()) -> (() -> ()) -> () -> ()
07:20:57 <lambdabot>      In the first argument of ‘asTypeOf’, namely ‘_’
07:21:04 <hpc> it doubles each time
07:21:12 <quchen> Exactly.
07:21:38 <cocreature> let f x = (x,x) in f.f.f.f.f.f.f.f.f.f.f.f.f.f is also nice
07:22:07 <quchen> And since 
07:22:08 <quchen> > length (filter (== 'd') "> id id id id id id id id id id id id id id id id id id id id id id id id () -- Not golfing."
07:22:10 <lambdabot>  <hint>:1:119:
07:22:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:22:14 <quchen> > length (filter (== 'd') "> id id id id id id id id id id id id id id id id id id id id id id id id () -- Not golfing.")
07:22:16 <lambdabot>  24
07:22:44 <quchen> So that makes a lot of () in the type inferred for the first id. :-)
07:23:32 <quchen> cocreature: Better: let a x = (x,x); b=a.a; c=b.b; d=c.c in d ()
07:23:39 <quchen> Scales a bit quicker ;-)
07:23:45 <cocreature> heh
07:23:49 <Xandaros> > ((flip ((.) . (:)) .) . (. (flip (:) . return)) . (.) . (:)) 'o' 'f' 'g' 'l'
07:23:50 <lambdabot>  "golf"
07:24:13 <Xandaros> And yes, I cheated
07:24:24 <cocreature> looks like @pl
07:24:27 <magneticduck> (I bet other interpreters don't have to deal with this crap)
07:28:05 <magneticduck> if we continued with this line of thought we'd eventually reinvent the Busy Beaver Game 
07:28:48 <magneticduck> except in a much cooler way
07:39:05 * hackagebot hpack 0.14.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.14.1 (SoenkeHahn)
07:52:18 <Squarism> do people mix let-in and where? Or should one stick with one?
07:52:44 <EvanR> i use let in on one line for something short, and where for blocks
07:52:59 <EvanR> so in that sense i mix them
07:53:56 <EvanR> and never a block or sequence of let ins followed by a where
07:55:07 <asthasr__> Squarism: I use "let" in do notation. "where" in functions. I'm not a great Haskeller, though, so keep salt handy.
07:56:28 <runeks> Is there a function that is the inverse of foldl?
07:56:46 <puregreen_> Squarism: I use “let” primarily when a function returns several results (like “break”) that I want to do things with, and “where” for utility functions and “intermediate results” that aren't trivial to compute or that are used more than once
07:56:55 <runeks> Such that it produces a list of items from an initial state and a function that, from an initial state, produces a single item and a new state
07:56:56 <EvanR> you mean unfoldl, that doesnt work
07:57:03 <EvanR> theres unfoldr
07:57:09 <Cale> :t unfoldr
07:57:10 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:57:19 <Squarism> okej.. good to know. Sounds like there is no clear standard
07:57:20 <runeks> EvanR: cool!
07:57:33 <runeks> Looks like what I'm looking for.
07:58:04 <EvanR> but people have suggested to prefer takeWhile and iterate instead
07:59:17 <EvanR> which obviously wins when you want an infinite list
07:59:23 <c_wraith> Squarism, you're correct, there is no standard. my rule of thumb is to use let when a small scope is needed, and where otherwise 
08:00:22 <runeks> EvanR: I figured I would just generate an infinite list, and "take n" from that, but looks that won't work.
08:00:23 <c_wraith> Squarism, by the way, did you get anything useful out of my tic tac toe tree demo? 
08:02:50 <EvanR> runeks: why?
08:04:46 <ExcaliburZero> What is the proper way to convert a String into a ByteString from Data.ByteString? I've tried searching on Hoogle and Google for a function that would perform that conversion and I was able to find `packChars` in Data.ByteString.Internal. However, I am unsure if it is the correct function to use, as it appears to call an unsafe function `unsafePackLenChars`.
08:04:57 <rmk0> hrm, i have Data.Bits imported qualified as DB. how do i call the .|. function in DB? 
08:04:58 <runeks> EvanR: I assume the Maybe is to signal the end of the list. And also the docs say it won't work with an infinite list. But I only found the docs for unfoldl for the Seq type.
08:05:11 <puregreen> ExcaliburZero: utf8-string
08:05:19 <puregreen> @hackage utf8-string
08:05:19 <lambdabot> http://hackage.haskell.org/package/utf8-string
08:05:51 <EvanR> runeks: take n works with infinite lists, unfoldr can generate infinite lists, and iterate is like unfoldr only with a simpler interface and necessarily infinite
08:05:54 <puregreen> specifically the “fromString” function: http://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html#v:fromString
08:05:58 <rmk0> ghc won't accept, DB.(.|.), DB..|. (the former claims that the function isn't in scope)
08:06:42 <puregreen> ExcaliburZero: there's also “pack” in Data.ByteString.Char8, but it only works for ASCII and breaks for everything else and so it's most likely not what you want
08:07:05 <Squarism> c_wraith, actually i have quite a hard time seeing where the lenses happen?!
08:07:10 <EvanR> puregreen: ExcaliburZero instead of a new package you can do Data.Text.Encoding encodeUtf8 on the packed String
08:07:33 <ExcaliburZero> Can the ByteString in Data.ByteString.UTF8 be used in place of the ByteString in Data.ByteString?
08:07:55 <puregreen> it's the same type, just reexported
08:08:15 <Squarism> c_wraith, ...or where they are used. Im a haskell noob that no shocker
08:08:20 <Squarism> so that
08:08:21 <Squarism> s
08:08:23 <puregreen> (also, in some rare cases the other side expects a different encoding (not UTF-8) and then you need a different function))
08:08:42 <quchen_> ?tell dfeuer Nice find with the foldl' change! I was confused for quite some time why reverse-via-foldl' did not crash like it used to when there was a bottom in the list.
08:08:42 <lambdabot> Consider it noted.
08:10:19 <puregreen> ExcaliburZero: is it clearer now, or do you still not know what you want? if so, you should describe your usecase and we'll try to help
08:10:48 <ExcaliburZero> I think I understand it. I just need to test it out in ghci to see if it works.
08:12:22 <runeks> EvanR: great! Looks like I had looked at unfoldr instead.
08:13:33 <c_wraith> Squarism, ah. most use of lenses were in the comment, not the code. it used them heavily to examine the structure. 
08:13:49 <ExcaliburZero> puregreen: I tried it out in ghci and it worked as needed. Thanks for the help!
08:14:07 * hackagebot lambdatex 0.1.0.4 - Type-Safe LaTeX EDSL  https://hackage.haskell.org/package/lambdatex-0.1.0.4 (Norfair)
08:14:13 <c_wraith> Squarism, though I did use lenses in a minor way to implement the function that calculated all possible moves.
08:15:24 <Squarism> c_wraith, how can i find the uses? 
08:15:24 <dolio> quchen_: reversing with foldl' shouldn't crash from a bottom in the list regardless. Unless you mean a bottom tail, in which case it should always crash, I think.
08:16:40 <Squarism> c_wraith, like name(or symbols) of fkn?
08:17:22 <c_wraith> Squarism, the definition of boards inside of moves is heavily lensy 
08:18:18 <c_wraith> Squarism, also, everything from line 21 to line 64 is defining lenses for use in the interactive session. 
08:19:41 <quchen_> dolio: Well, it used to do that I'm pretty sure
08:20:08 <quchen_> But with the moved seq call it now forces the (:), not the list contents anymore
08:20:23 <dolio> You're talking about `reverse [1,2,undefined,3]` right?
08:20:57 <quchen_> Yes.
08:21:11 <dolio> Then the thing it forced was always guarded by a (:).
08:21:35 <dolio> The difference in behavior is whether foldl f z is strict in z or not.
08:21:40 <dolio> Er, foldl'.
08:22:11 <dolio> The current one in terms of foldr is strict in z, and the old version wasn't necessarily.
08:22:30 <quchen_> dolio: Hm. reverse used to be what people told me years ago as an example of where foldl is better than foldr. And I'm pretty sure I tried it out. But let me check the source
08:22:53 <dolio> You mean foldl better than foldl'?
08:23:26 <dolio> For reverse the foldl' just doesn't do much.
08:23:34 <dolio> A better example is last.
08:24:02 <ertes> 'last' can actually *only* be written properly using foldl
08:24:25 <ertes> (unless you use a wrapper)
08:25:29 <dolio> New foldl' will always blow up if you write it as `foldl' (\_ x -> x) (error "empty list")`, whereas old foldl' would not always blow up, but would blow up if there was a bottom in the list.
08:25:53 <ertes> dolio: it would still evaluate the element, which is not necessarily what one wants
08:26:07 <c_wraith> is this being treated as a bug that should be fixed in 8.0.2?
08:26:14 <ertes> foldl has proper strictness for 'last'
08:26:40 <hpc> i would categorize it under "who cares" myself ;)
08:27:16 <coppro> why is someone writing a list reverse that forces the elements?
08:27:18 <coppro> that's awful
08:27:20 <ertes> > foldl (const id) undefined [undefined] `seq` ()
08:27:21 <lambdabot>  *Exception: Prelude.undefined
08:27:26 <ertes> hmm
08:27:28 <ertes> oh
08:27:39 <ertes> > foldl (const id) undefined [error "blah"]
08:27:40 <lambdabot>  *Exception: blah
08:27:46 <c_wraith> hpc, I care whenever a function is strict without adding value with that strictness. it's a bug. 
08:27:56 <coppro> ^
08:28:58 <ertes> hpc: improper strictness is a source of bugs when you actually use haskell's semantics for composability
08:29:39 <c_wraith> I had code broken when Data.Map introduced unnecessary strictness for one version. 
08:29:43 <ocramz> Q: how do I point FlyCheck (Emacs) to a different Haskell installation? E.g. I have 7.8, 7.10 and 8 installed at the moment. I get a checker state warning since some flag inside Emacs is stuck at using 7.10 whereas I need to try out something with 7.8
08:30:01 <dolio> reverse doesn't force the elements, even if you write it with foldl'.
08:30:41 <hpc> ah, fair point
08:30:46 <c_wraith> this is part of why I despair at tibbe's "strict all the things!" campaign. it already has broken my code once, and will again as it keeps getting applied inappropriately 
08:31:30 <dolio> Yes, you need to think about what should and should not be strict, even in a '.Strict' module.
08:31:58 <osa1> does anyone know how to get a Int32# literal? apparently 123# syntax is only for Int#
08:32:21 <dolio> There is no Int32#, unless that's new.
08:32:30 <osa1> there is
08:32:37 <osa1> I don't know if that's new
08:33:00 <osa1> there's Int64# too
08:33:08 <nitrix> osa1: The type is I32# I believe.
08:33:12 <nitrix> osa1: Not Int32#
08:33:16 <ertes> osa1: it's all Int# internally
08:33:24 <ertes> Int32 ~ Int#
08:33:27 <osa1> data Int32#     -- Defined in ‘GHC.Prim’
08:33:31 <osa1> data Int64#     -- Defined in ‘GHC.Prim’
08:33:43 <c_wraith> so.. unsafeCoerce# ? 
08:33:47 <ertes> osa1: at least the lifted ones from Data.Int are all Int# as far as i see
08:34:05 <dolio> Huh, apparently it's not as new as I thought.
08:35:56 <dolio> osa1: Oh, was this only added as part of the SSE type stuff that is still only partially baked, though?
08:36:14 <osa1> hmmmm Int64 is not using Int64# internally though. this is annoying.
08:36:21 <osa1> dolio: no idea
08:36:32 <dolio> I think that may be the case.
08:36:56 <osa1> now that we have Int32#, Int64# etc. I'd expect Int32/Int64 to use those internally
08:37:07 <osa1> dolio: what SSE type stuff?
08:38:52 <dolio> There is a bunch of stuff in GHC.Prim like Int16X16# Int32X4# etc. And then there are ways to pack things, and some SSE instructions that operate on those packed integers, but they're still primops that aren't exposed anywhere.
08:39:08 <MichaelBurge> c_wraith: You can't unsafeCoerce an Int32# because it has the wrong kind.
08:39:18 <osa1> you can unsafeCoerce#
08:39:20 <dolio> I'm not sure if Int32# and Int64# were added only as part of all that.
08:39:29 <osa1> :t unsafeCoerce#
08:39:30 <lambdabot> Not in scope: ‘unsafeCoerce#’
08:39:39 <EvanR> nice, an unsafeCoerce worse than unsafeCoerce
08:39:49 <c_wraith> MichaelBurge, I was sure I put the # on it. :) 
08:40:12 <osa1> it's not worse actually, it's just for different kind I think
08:40:14 <dolio> osa1: I guess not, because those SSE types don't exist in 7.6, but Int32# and Int64# do.
08:40:31 <EvanR> oh i thought it meant "disregard kind"
08:41:06 <osa1> unsafeCoerce# :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). a -> b
08:41:13 <osa1> I think you're right, it's worse
08:41:51 <EvanR> nice
08:41:56 <dolio> I think Int64# might be used for Int64 on 32-bit GHC. Although I'm not 100% sure about that even.
08:42:03 <EvanR> at least they have to have runtime reps
08:42:06 <MichaelBurge> c_wraith: I tested with a newer GHC and it still doesn't look like you can. http://lpaste.net/165705
08:42:06 <osa1> hm interesting, this didn't work unsafeCoerce# (123 :: Int) :: Int#
08:42:28 <MichaelBurge> c_wraith: Although the error changes
08:42:31 <dolio> I don't know if Int32# is used anywhere, though.
08:42:56 <osa1> MichaelBurge: I think that's a GHCi bug, I just used that in my program
08:43:51 <glguy> MichaelBurge: Your error was about (5 :: Int32#), not unsafeCoerce#
08:44:20 <dolio> osa1: That's because you're trying to print it, if you did it in the REPL. Try: I# (unsafeCoerce# (123 :: Int))
08:45:01 <osa1> ahh right. yeah unsafeCoerce# is worse :-)
08:45:03 <osa1> λ> I# (unsafeCoerce# (123 :: Int) :: Int#)
08:45:09 <osa1> prints 8666421592
08:46:58 <c_wraith> that's because it's pretending the object header is an Int#
08:50:45 <osa1> [1]    21125 segmentation fault  ghci
08:52:44 <c_wraith> guess that doesn't work. :) 
09:04:30 <MichaelBurge> It's kind of a weird thing to unsafeCoerce between an Int# and a Double#, because they use different registers on the CPU. 
09:04:55 <MichaelBurge> If unsafeCoerce is simply stripping type information, who's responsible for shuffling the value into the correct registers, which incurs a runtime cost?
09:05:22 <EvanR> but loading float data into integer registers lets you do some pretty nifty hax
09:05:41 <quchen_> EvanR: Fast inverse square root? :-9
09:05:48 <EvanR> also logs
09:08:39 <coppro> MichaelBurge: the compiler backend will handle that. it's responsible for register allocation and will do whatever is best.
09:09:36 <EvanR> good point, i guess it doesnt make sense to assume unsafeCoerce has no runtime cost
09:10:31 <EvanR> when used on a Float it could be doing stuff
09:10:45 <EvanR> or a Float#
09:10:55 <glguy> unsafeCoerce without the hash coerces boxed types, so there's no representation change
09:12:15 <hpc> unsafeCoerce is implemented in terms of unsafeCoerce# isn't it?
09:13:53 <glguy> It is
09:21:19 <EvanR> is there a way to represent a X -> Type for some type X with haskells fake dependent types
09:22:09 <EvanR> assign a different type to each X in a way that can be used somewhere
09:23:07 <EvanR> datakinds and type families maybe
09:25:17 <coppro> EvanR: if X is a type, type families
09:25:21 <coppro> if err
09:25:31 <coppro> if X is a kind
09:25:47 <coppro> if X is a type, no
09:27:54 <EvanR> right well... X can be a kind with DataFamilies
09:28:01 <EvanR> er DataKinds
09:28:49 <MichaelBurge> It looks like the Cmm layer is the first one that knows which values belong to which registers: https://github.com/ghc/ghc/blob/master/compiler/cmm/CmmExpr.hs
09:29:02 <MichaelBurge> And I get an error like: 'Error: junk `naughty x86_64 register' after expression'
09:29:17 <MichaelBurge> And the -ddump-asm has a line like: movl $5,very naughty x86_64 register
09:29:28 <MichaelBurge> which I'm pretty sure isn't valid assembly
09:29:55 <osa1> that's next gen intel x86
09:31:57 <osa1> what did you do to get that assembly?
09:33:24 <MichaelBurge> osa1: http://lpaste.net/165707
09:34:44 <osa1> well I guess that's worth reporting.. that shouldn't happen no matter what syntactically valid Haskell code you compile
09:35:10 <MichaelBurge> osa1: Oh, I didn't realize it, but that is an error message and not a warning. So the objdump is a red herring.
09:35:16 <MichaelBurge> Because it fails to assemble
09:35:29 <osa1> MichaelBurge: error message is printed by as
09:35:40 <osa1> because GHC generated invalid assembly
09:35:49 <MichaelBurge> coppro: So, the compiler backend does not in fact do register allocation when you assign an int to a double with unsafeCoerce.
09:36:04 <Clint> what's the right way to make a Read instance fail?
09:36:06 <MichaelBurge> At least on GHC 8
09:36:10 <MichaelBurge> At least on GHC 7.8*
09:36:31 <glguy> Clint: returning []
09:36:48 <MichaelBurge> It also fails on GHC 8 too
09:36:54 <osa1> yeah, same error
09:37:29 <Clint> glguy: thanks
09:39:40 <coppro> MichaelBurge: lol, that's fun
09:39:54 <coppro> well, it's still the backend's responsibility
09:40:06 <coppro> imo
09:40:16 <coppro> though I don't know GHC's architecture that well
09:43:20 <osa1> reported it btw https://ghc.haskell.org/trac/ghc/ticket/12184
09:55:02 <EvanR> wasnt there an FRP channel?
09:55:11 <cocreature> is there some standard package to resolve ~ to the full path to the home directory and similar things (can’t come up with anything else)? ofc it’s easy to write that myself but it seems like something that could nicely be packaged up
09:57:06 <Cale> EvanR: There's #reflex-frp if that's what you're thinking of perhaps.
09:57:28 <EvanR> i thought there was something like #haskell-frp
09:57:44 <MichaelBurge> osa1: I don't have access to the file now, but my favorite compiler bug is a C++ source file I had that caused a kernel panic when compiled by g++.
09:58:42 <EvanR> thats some compiler bug
09:58:49 <EvanR> inducing kernel bugs at will
09:58:51 <osa1> lol
09:59:13 <osa1> good thing that you don't have access to the file
09:59:26 <osa1> you might accidentally compile it :p
10:00:08 <EvanR> how will you compile your files if you dont even have access to them? </agentsmith>
10:01:10 <MichaelBurge> It was on a shared system too. So of course when I send an email telling everybody, the machine periodically goes down over the next few days as people try it out
10:01:24 <osa1> hahah
10:02:44 <MichaelBurge> Oh, I remember what it was now. It wasn't just compiling it: It was setting a hardware breakpoint using a very new GDB using an old CentOS 4 kernel.
10:05:14 <geekosaur> have to admit I was wondering how what you described could be a compiler bug
10:05:46 <geekosaur> because there would be at least one kernel bug involving incorrect verification of userspace-provided data/addresses/whatever
10:07:09 <nkaretnikov`> is there something that reduces like type families but allows partial application like data families?
10:07:37 <geekosaur> (well, same true if it's gdb doing it, but those are at least *known* kernel/userspace pain points because hardware breakpoints)
10:07:46 <EvanR> partially applied type synonyms makes the type system turing complete right
10:12:10 <geekosaur> type system's already turing complete? but now typechecking requires solving the halting problem
10:12:49 <geekosaur> and forget about type inference
10:16:16 <geekosaur> (re halting problem, we already have turing completeness bit it's much more in your face about it with partial type function application)
10:17:23 <dolio> I don't think allowing partially applied synonyms automatically gives you Turing completeness. But it's problematic anyway, depending on their status.
10:18:37 <ideuler> Need the hostname of a client through a connected socket. From a SockAddr I can get  the HostAddress or HostAddress6, but how do I get the ipv6 hostname out of a Host byte order (HostAddress6)?
10:19:41 <dolio> Actually, I suppose the fact that synonyms can be recursive would do it.
10:19:58 <EvanR> you can format an ipv6 address as a string with inet_pton
10:20:06 <EvanR> im not sure if thats what you mean by hostname
10:20:07 <dolio> But Turing completeness isn't the only problem.
10:20:35 <geekosaur> or getAddrInfo more generally
10:20:57 <EvanR> i thought getAddrInfo takes strings
10:21:11 <geekosaur> sorry wrong one
10:21:12 <geekosaur> sigh
10:21:15 <EvanR> not 8 bytes
10:21:20 <EvanR> getNameInfo
10:21:29 * geekosaur hashes all of them to getaddrinfo()
10:21:47 <geekosaur> which gets you to the right family of apis but not the exact function
10:33:17 <cheater> hi
10:39:13 * hackagebot elm-hybrid 0.1.0.0 - Combine Elm with Haskell for data based applications  https://hackage.haskell.org/package/elm-hybrid-0.1.0.0 (matsrietdijk)
10:42:04 <JuanDaugherty> yello cheater 
11:38:52 <pikajude> so....can I include directories in data files in a cabal file or is that still impossible?
11:38:55 <saurabhnanda> hey anyone here using intero? Newbie question - how do I compile a project and see all compilation errors and warnings? It used to be 'M-m m c b' in spacemacs+haskell, what is it now?
11:53:51 <saurabhnanda> no one knows?
11:55:21 * tdammers has both feet firmly planted in his .vimrc
11:56:52 <bus000> @help
11:56:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:57:07 <bus000> @help list
11:57:07 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
11:57:16 <bus000> @list
11:57:17 <lambdabot> What module?  Try @listmodules for some ideas.
11:57:21 <bus000> @listmodules
11:57:21 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:57:26 <bus000> @list hoogle
11:57:27 <lambdabot> hoogle provides: hoogle hoogle+
12:00:16 <bus000> @pointfull constructAutomata :: [(String, a)] -> State a
12:00:16 <lambdabot> constructAutomata :: [(String, a)] -> State a
12:00:17 <bus000> constructAutomata strings =
12:00:17 <bus000>     let upper = map (\(str, res) -> (map toUpper str, res)) strings
12:00:17 <bus000>     in foldr (\(str, res) auto -> constructAutomata' str res auto) (ContState [])
12:00:19 <bus000>         upper
12:00:37 <nitrix> bus000: You might want to use lambdabot bot in private (\q lambdabot) if you're just learning to use it or trying things.
12:01:38 <bus000> yeah, i'll do that. First time here
12:10:59 <luite> hmm, has Data.Binary serialization of Data.Text switched to a lossy compression scheme? http://lpaste.net/165711
12:12:39 <luite> oh looks like this is a new problem with ghc 8.0.1
12:13:15 <saurabhnanda> if I have a function 'f :: a -> b -> c -> IO ()' and have a vale of type IO b, what's the shortest way to compose them?
12:13:43 <Clint> what
12:13:47 <saurabhnanda> is something on the lines of 'f a (=<< b) c' available?
12:14:34 <coppro> > Data.Binary.put ("foo" :: Text)
12:14:36 <lambdabot>  Not in scope: ‘Data.Binary.put’Not in scope: type constructor or class ‘Text’
12:14:44 <coppro> > import Data.Binary
12:14:46 <lambdabot>  <hint>:1:1: parse error on input ‘import’
12:14:49 <coppro> :import Data.Binary
12:16:17 <saurabhnanda> :t (=<<)
12:16:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:16:57 <dfeuer> Wow that's way lazier than it should be....
12:16:59 <saurabhnanda> :t (>>=)
12:17:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:21:49 <dfeuer> Wow.... I just majorly sped up Data.Sequence.partition :-)
12:24:09 <MichaelBurge> saurabhnanda: I'd probably use a utility function, but there's also this
12:24:11 <MichaelBurge> @pl combine3 f a b c v = f a b c >> v
12:24:11 <lambdabot> combine3 = ((((>>) .) .) .)
12:24:31 <saurabhnanda> MichaelBurge: what's a utility function?
12:24:53 <saurabhnanda> :t combine3
12:24:54 <lambdabot> Not in scope: ‘combine3’
12:25:19 <MichaelBurge> saurabhnanda: I would define 'combine3' as ' f a b c >> v', and use that in the project
12:25:56 <saurabhnanda> MichaelBurge: actually I want a shorter way to to this (\x -> f a x c) =<< b
12:28:01 <MichaelBurge> saurabhnanda: If x is frequently in that position, I'd move it to be the rightmost argument, so that you can do f a c =<< b
12:28:30 <saurabhnanda> MichaelBurge: hmm, probably a proposal for Haskell2020 then
12:28:58 <saurabhnanda> MichaelBurge: there should be syntactic sugar to deal with monadic boilerplate
12:29:09 <MichaelBurge> saurabhnanda: Oh if it's a built-in function, I agree they put their arguments in weird places.
12:29:36 <MichaelBurge> I always have to flip a map or concatmap
12:29:46 <MichaelBurge> or execStateT
12:30:12 <saurabhnanda> MichaelBurge: not even builtins, right now I need something as a middle argument of some string concatenation
12:31:48 <MichaelBurge> saurabhnanda: What monad is it? Is it a reader monad?
12:35:35 <saurabhnanda> IO
12:35:37 <saurabhnanda> MichaelBurge: IO
12:37:41 <MichaelBurge> saurabhnanda: I was going to suggest that I've had some success with Implicit Params allowing me to avoid extracting values out of the monad all over
12:37:58 <MichaelBurge> saurabhnanda: But it doesn't sound appropriate here
12:38:10 <saurabhnanda> MichaelBurge: what're implicit params?
12:39:16 <MichaelBurge> saurabhnanda: They're a parameter to your function that's hidden in a constraint. So if you have a website with a routes table somewhere you can do
12:39:19 * hackagebot hdevtools 0.1.3.2 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.3.2 (ch1bo)
12:39:42 <MichaelBurge> saurabhnanda: renderMenu :: (?r :: RoutesTable) => Html ()
12:40:10 <saurabhnanda> MichaelBurge: don't completely understand, but is is this somethng that Yesod does?
12:40:13 <MichaelBurge> and you can avoid explicitly passing in the routes table to every function th at needs it
12:40:35 <MichaelBurge> I don't think any of the web frameworks use it, although I do.
12:42:00 <MichaelBurge> saurabhnanda: I'm not sure they're appropriate for you, but you can see the definition in the GHC manual under 7.13.4: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/other-type-extensions.html
12:44:12 <MichaelBurge> saurabhnanda: I also use them to get callstacks for debugging: https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Stack.html
12:44:17 <saurabhnanda> MichaelBurge: interesting. Can these be used instead of app-wide Reader monads?
12:45:07 <dunpeal> Hi. Serious question: how much has Rust been influenced by Haskell?  I'm looking to learn a new language, and I liked a lot of what I saw in Haskell, but I want to learn something a bit more practical. Would Rust teach me many of the lessons I'd get from Haskell?
12:45:09 <MichaelBurge> saurabhnanda: Yes, that's what I used them for. I had to break a cyclic dependency on an application-wide constant without rewriting all the code to take it as a parameter.
12:46:01 <MichaelBurge> dunpeal: They serve different purposes I think. Rust is supposed to be a systems programming language for beginners, and Haskell is more for applications.
12:46:37 <verement> dunpeal: In what ways do you consider Haskell impractical?
12:47:08 <dunpeal> MichaelBurge: yup, but I know that Rust "borrowed" concepts from Haskell, like (parts of?) the type system and things like type classes. Question is, how much did it borrow?  How much of Haskell would I learn if I master Rust?
12:47:25 <dunpeal> verement: there's almost no commercial applications written in Haskell afaik.
12:47:59 <MichaelBurge> dunpeal: That was more true a few years ago, but not really today. There's been a lot of pickup on Haskell recently.
12:49:19 * hackagebot hashing 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/hashing-0.1.0.0 (wangbj)
12:49:24 <dunpeal> MichaelBurge: can you provide some examples?  Specifically, of professional programming work in Haskell
12:49:40 <MichaelBurge> dunpeal: Rust will probably give you more control over the operations your program does, while Haskell doesn't treat that as much of a priority
12:50:09 <MichaelBurge> So it will be easier to predict performance or memory usage with Rust, but Haskell has a lot of crazy type system features that come in handy on bigger projects.
12:51:12 <tdammers> dunpeal: Haskell is used quite a bit in finance, I believe, and there are a bunch of startups betting their operation on it
12:51:19 <MichaelBurge> dunpeal: I know there's a few banks that use Haskell to process a wide variety of documents; the FP Complete guys also seem to serve the finance industry
12:51:34 <tdammers> dunpeal: in the Netherlands alone, I know of two such startups who openly advertise as using Haskell
12:51:39 <dunpeal> tdammers: which startups would those be?
12:51:48 <dunpeal> and any in the US?
12:51:50 <tdammers> silk.co, and lumiguide
12:52:01 <tdammers> US, don't know, but I'm sure there's some there as well
12:52:02 <MichaelBurge> dunpeal: There's also Galois that takes a lot of government contracts. Janrain used to use it for their websites.
12:52:56 <sm> dunpeal: a nice blog post showing some of rust & haskell similarities
12:53:02 <sm> http://yager.io/programming/go.html
12:53:05 <dunpeal> fwiw I know a bit about finance, don't know of anyone using Haskell. I know of a couple of places using O'Caml
12:53:27 <tdammers> ocaml is pretty popular there, yes
12:53:35 <tdammers> quite similar too, imo
12:54:01 <dunpeal> not to be a wet blanket, but the vast majoiry of languages used in finance are the mainstream ones: Java, C++, etc.
12:54:16 <mgsloan> At FP Complete we do a lot of scientific computing stuff, more than finance actually, but that is one of our other domains
12:54:20 <thoughtpolice> dunpeal: I write Haskell every day. I've used it for web development, backend services, analysis tools, software security, tooling. Our clients have also had our company do finance work, large scale distributed analysis/"big data" things. Things like flight scheduling software for the UK. Research contracts with universities. Web 2.OMG apps. Lots of stuff.
12:54:36 <dunpeal> I know O'Caml is used as an exotic choice in some particular places, but nowhere near "popular". and I've never heard of Haskell used in production in finance.
12:54:58 <dunpeal> thoughtpolice: interesting.
12:55:06 <thoughtpolice> If you just want a literal example of some startup with a desktop app, Wagon is a good example: https://www.wagonhq.com/
12:55:12 <ArtfulDodger> Hello
12:55:32 <ArtfulDodger> I have a question about Haskell
12:55:40 <dunpeal> sm, thoughtpolice: thanks, looking at your links.
12:55:42 <ArtfulDodger> I've never used it before, could someone help me?
12:55:49 <tdammers> dunpeal: haskell is used in production, successfully so, but it's not very widespread. Make of that what you will.
12:55:50 <thoughtpolice> dunpeal: Standard Chartered bank is probably the biggest Haskell user in the world. They have a few million Haskell LOC, but they even have their own proprietary compiler for a Haskell variant, too.
12:56:03 <thoughtpolice> (But they consider themselves a Haskell shop without question, so I think it counts.)
12:56:49 <MichaelBurge> Facebook also uses it as the glue layer for their spam detection rules engine.
12:57:31 <ArtfulDodger> Will Haskell be easy to learn if you know assembly?
12:58:11 <dunpeal> MichaelBurge: yeah, that's one of the reasons I took another look at it. they wrote another interesting library in it: https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
12:58:20 <ArtfulDodger> dunpeal: Tell me about Haskell
13:01:26 <Gurkenglas> ArtfulDodger, I'd say C, Java, etc. help you no less with Haskell than Assembler does
13:01:44 <ArtfulDodger> Gurkenglas: What are the benefits of Haskell over other languages?
13:02:45 <pikajude> HM type inference
13:02:49 <MichaelBurge> ArtfulDodger: I find Haskell is a good glue-layer language for large projects, since the types help keep things organized
13:02:57 <c_wraith> Haskell's biggest benefit is that it really is different. it forces you to learn new things. 
13:03:00 <Gurkenglas> Very common question, relevant: http://ircbrowse.net/browse/haskell?q=What+are+the+benefits+of+Haskell
13:03:31 <tdammers> I'd say the type system, hands down
13:03:40 <c_wraith> also, despite some obvious warts, the language is well designed in a way very few are. 
13:03:48 <pikajude> reasonable performance given the power of the type system
13:04:00 <MichaelBurge> ArtfulDodger: You use a C or Rust if you need more control over what exactly the machine is doing, and scripting languages like Perl or Python have their places too
13:04:01 <c_wraith> it's good to learn a language that was designed well. so few are. :) 
13:04:08 <Gurkenglas> Beware the "Once you go Haskell" effect, though!
13:04:19 <tdammers> strict enough to pull its weight, expressive enough to be actually worth it
13:05:05 <tdammers> for me, this means I can keep moving fast while maintaining a high quality standard
13:05:35 <EvanR> uh oh hes gone full haskell
13:06:41 <sm> stand back!
13:06:52 <EvanR> i have a question, im at the point where my program has a large number of new data types, each one is not that complicated but i keep having to implement classes and helper functions for them and it feels slow, just because theres a lot, and i keep wanting to make more. what do i do?
13:07:11 <EvanR> TH?
13:07:14 <hpc> have you tried turning it off and on again?
13:07:18 <sm> EvanR: would lenses help ?
13:07:45 <MichaelBurge> EvanR: I've used Template Haskell to automatically derive XML parsers and serializers, and that saved a lot of trouble
13:07:48 <sm> and are you auto-deriving classes as much as you could ?
13:08:05 <EvanR> i have DeriveFunctor in every file and the pragma on hotkey ;)
13:08:50 <adamCS> EvanR:  Generics can also help here.  
13:09:15 <EvanR> ok i have seen use of generics in some libraries, maybe i need to look into that
13:09:43 <adamCS> my favorite generics library (though I've not tried much) is generics-sop
13:09:44 <EvanR> is that TH related
13:10:46 <adamCS> Is what TH related?  Generics?  No.
13:11:40 <kmelva> EvanR: I have a lot of types for wich I need to generate GTK widgets... my first pick was Generics, and it seems pretty OK for that
13:11:55 <kmelva> that being said, I'm still a newb, so maybe I'm wrong here :)
13:12:26 <thoughtpolice> adamCS: Good to hear people like generics-sop :) I haven't gotten a chance to use it much in anger myself (my colleagues wrote it)
13:12:29 <EvanR> in any case generics and generics-sop seems handy to know
13:12:33 <adamCS> Also, generics has changed some in GHC 8 but I think generics-sop has been updated.
13:12:59 <EvanR> i hope theres some leverage to be had
13:13:26 <ArtfulDodger> Thank you, friends :)
13:13:51 <adamCS> thoughtpolice: It's great.  The propagation of constraints was a little tricky but I figured it out.  
13:14:31 <EvanR> kmelva: generics-sop or
13:15:20 <kmelva> EvanR: just GHC.Generics, I think it's enough for my usecase. I try to limit the number of libs I'm using at the moment.
13:15:45 <saurabhnanda> :t (^.)
13:15:46 <lambdabot> s -> Getting a s a -> a
13:18:49 <adamCS> I had an easier time handling sum types with generics-sop.  But I since saw some ways to do that with the basic Generics.  But generics-sop can pleasingly succinct.
13:19:37 <EvanR> so this is a way to write functions on any generic data type, is there an expected performance cost?
13:19:50 <EvanR> seems obvious at least since it must inspect the data structure
13:21:06 <EvanR> and if the operation isnt really on any generic ...
13:21:55 <kmelva> I'm not 100% on performance, but I'm guessing there's both a compile time and run time penalty for Generics...
13:21:58 <adamCS> SOme of the work is at compile-time.  That's when the information about the structure is generated by deriving (Generic).  SO, I'm not sure what the runtime cost is.
13:23:50 <adamCS> Also, it's often used in conjunction with "DefaultSignatures" as a way to derive class instances for your data structures.  But if one can and should be optimized you can always write that one by hand.
13:24:03 * EvanR gives up on the docs for now and reads this https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html ;)
13:24:37 <MichaelBurge> EvanR: Personally, I found Template Haskell easier to write than generics; although I prefer using generics
13:24:39 <nitrix> saurabhnanda: (^.) can be easier to think of as :: s -> Lens' s a -> a
13:24:49 <adamCS> AS with TH, I found the learning curve a little steep at first.  
13:26:28 <c_wraith> generics have a very minimal compile time cost. some code is generated, but it's nice and simple. 
13:26:30 <EvanR> re DefaultSignatures seems like you can write a generic instance instead?
13:26:51 <nitrix> saurabhnanda: That is, if you're only working with lenses. `Getting` generalizes over Lens, Prism, Iso, Fold, Traversal, Getter and a few others.
13:27:00 <bergmark> unless you inline generics :-S
13:27:08 <c_wraith> the runtime cost isn't minimal, but it's often worth it to avoid writing instances manually. 
13:27:34 <c_wraith> very often, it's not a hot spot in the overall program execution. 
13:27:51 <EvanR> the idea of being able to bust your ass (wrists) more to make the code faster annoys me somehow ;)
13:28:02 <c_wraith> so all the run time it adds integrated over infinity still isn't that much. 
13:28:35 <adamCS> EvanR:  If you are interested, I have a library which does the same boilerplate generation via TH and Generics (via generics-sop).  I did it as a learning exercise as well as to build something I needed.  But it might give you an idea what they each look like doing the same thing.  https://github.com/adamConnerSax/dataBuilder
13:28:48 <c_wraith> EvanR, that's ever the way of it. most things can be improved along some axis with significant added work. :) 
13:28:54 <saurabhnanda> thanks nitrix. I just confused about the order of arguments.
13:29:38 <nitrix> saurabhnanda: the type that has lenses for it ^. the lens == the value the lens focuses on
13:31:47 <EvanR> c_wraith: i mean, if its menial or repetitive work...
13:31:55 <EvanR> feels stone age
13:34:29 <EvanR> adamCS: interesting, so you define new types with a bunch of strings?
13:34:31 <c_wraith> I feel like the haskell ecosystem is missing one important thing - a generally accepted tool that serializes TH output as part of a build process, allowing the build process to skip running TH if the generated code would still compile. 
13:34:55 <adamCS> EvanR:  Not sure what you mean...
13:35:22 <c_wraith> obviously the idea needs refinement, but it would be nice to have auto-generated code without the compile cost TH has on every compile. 
13:35:26 <EvanR> nevermind i just didnt grok the nature of this library
13:35:31 <EvanR> yet
13:35:46 <nitrix> c_wraith: cabal/stack kind of does this at the moment with the _Paths module or something.
13:35:48 <adamCS> EvanR:  dataBuilder?  That uses generics (or TH) to applicatively build anything if you can applicatively build the sub-parts.
13:36:08 <c_wraith> nitrix, true, but that's very limited. 
13:36:38 <nitrix> c_wraith: The structure is there, detecting file modification and stuff. It might not be too hard to pull off.
13:36:41 <c_wraith> nitrix, as its name implies, it really only contains path information. :) 
13:37:08 <EvanR> adamCS: ok so its not speeding up declarations... or its making the declarations unnecessary
13:37:51 <adamCS> EvanR: Unnecessary except for 3 bare instance declarations.  Or one TH splice.
13:38:45 <EvanR> so the ultimate manifestation of this is a new module contains a data type definition, deriving whatever, and the one TH line which configures to add the support you need ;)
13:38:57 <adamCS> right
13:39:07 <EvanR> i mean, the general idea, not necessarily buildering
13:39:07 <adamCS> or you can skip the TH
13:39:27 <EvanR> skip the TH?
13:39:38 <adamCS> The lib can do it both ways.
13:39:41 <adamCS> Just TH
13:40:18 <adamCS> or via deriving Generic, Generics.SOP.Generic , Generics.SOP.HasDataTypeInfo and DataBuilder.Builder f
13:40:33 <adamCS> I did it both ways just to compare the TH experience to the Generics
13:41:04 <EvanR> and what won
13:41:08 <adamCS> but yes.  Define your data type, then use the TH splice or the generic instance and you have a class instance for the "buildering"
13:41:23 <adamCS> without ever having to write it directly for your type
13:41:45 <adamCS> I liked the Generics better.
13:42:00 <EvanR> is it possible to have proper docs generated with the generated code
13:42:21 <EvanR> i guess thats another situation where generics wins
13:42:50 <adamCS> I don't think so.  You'd have to document the generic behavior.  But that would likely be enough, right?  Sort of like to/fromJSON
13:42:59 <EvanR> yes
13:43:22 <EvanR> and the generic functions gives you a place to do that
13:43:27 <adamCS> right
13:43:54 <adamCS> but you can also document the TH code. 
13:45:06 <fishythefish> How can I place a typeclass constraint on a phantom type?
13:46:27 <adamCS> EvanR: Generics felt a little more like writing haskell.  TH puts you in this odd place where you are trying to think both of the code you want and the syntax tree that you need to make that code from the inputs.  And it wasn't always clear to me, which parts I could handle which way.  And the transition between them was confusing.   
13:47:30 <adamCS> I still don't know how to handle higher-kinded types in the TH version.  If you want an instance for class C, like "instance C a=>C (Maybe a)"
13:48:25 <adamCS> that just works in the generic version.  In the template version, I needed something I couldn't figure out to handle that "a" 
13:49:26 <adamCS> But I was (and still am) a newbie at both.  so, obviously, YMMV.
13:51:41 <EvanR> fishythefish: same way you normally do... in the signature of whatever function youre writing
13:52:28 <fishythefish> EvanR: That's what I suspected. I don't suppose there's a way to state in one place that the phantom type can only be an instance of that class?
13:52:45 <EvanR> thats an instance of the "dont constraint the data type itself" rule
13:53:14 <fishythefish> Right, and GADTs will only let you get around that at the constructor level, and not the type level, yeah?
13:53:31 <EvanR> gadts or existentials... at least
13:54:02 <EvanR> i havent tried it but i foresee trying to utilize this phantom class hack without having the constraint visible to be tricky business
13:54:19 <EvanR> maybe you want to try reflection instead
13:54:33 <fishythefish> What do you mean by reflection?
13:55:11 <EvanR> its filed under implicit parameters, subsection values attached to types
14:08:39 <idev> for doing logging / monitoring, are there haskell solutions, or does this cros into the domain of erlang?
14:11:01 <ocramz> hi there
14:11:14 <ocramz> anyone uses flycheck in Emacs here?
14:11:49 <ocramz> I can't recall how to access a customization menu, and I can't find this on the manual either
14:13:31 <puregreen_> ocramz: maybeM-x customise-group [Enter] flycheck
14:13:35 <puregreen_> * space
14:17:03 <ocramz> puregreen_ : I'd like to change the path of the Haskell installation. I have 7.8, 7.10 and 8 , and Emacs doesn't simply shell out to `which` when looking for a binary. The paths are stored in some internal variable
14:18:07 <ocramz> I once saw this menu that let you input a list of paths, but now can't recall the incantation. I hate this
14:18:37 <EvanR> discoverable!
14:18:49 <ocramz> yes, given infinite time and patience
14:19:00 <EvanR> "eventually discoverable"
14:19:26 <ocramz> asymptotically discoverable
14:19:28 <EvanR> ... i guess eventually is better than not
14:19:32 <ocramz> yeah
14:19:38 <EvanR> or almost
14:20:17 <ocramz> I don't know, I surely can't find it in the manual
14:21:23 <diverdude> hello. I am new to functional programming. I have a fundamental question. As i understand functional programming its really good for problems where calculations may be done independently. But what if one calculation is dependent on other calculations...then i cannot solve this with functional programming. Is that correct?
14:21:48 <ocramz> diverdude: not at all
14:22:06 <diverdude> ocramz, ok i stand corrected. How is that normally solved?
14:22:34 <mauke> I don't see how that even is a problem
14:22:41 <EvanR> maybe youre thinking of parallel programming
14:22:46 <ocramz> FP is completely general purpose, in terms of dependency between computations. Functional simply means that functions have equal dignity as data
14:22:57 <mauke> > 2 + (3 * 4)
14:22:59 <lambdabot>  14
14:23:00 <ocramz> passed around, talked about, partially evaluated and such
14:23:08 <mauke> the + depends on the result of 3 * 4
14:23:20 <monochrom> "cos (sin 5)" is how the cosine computation depends on computing the sine of 5.
14:23:24 <osager> hi im using intero for emacs, how do i launch ghci from within emacs?
14:24:59 <diverdude> mauke, ok yes of course that makes sense. But isnt one of the big strengths of functional programming that it is better suited for parallel processing?
14:25:55 <monochrom> I think you're overthinking this.
14:26:41 <diverdude> monochrom, hmm ok
14:27:00 <mauke> just because it can doesn't mean it has to do everything in parallel
14:27:01 <ocramz> diverdude: the benefits for parallel processing come as a perk of being completely explicit in how "state" is modified
14:27:32 <diverdude> ok yes that makes sense
14:27:33 <ocramz> no variables are overwritten without the compiler knowing it
14:28:00 <monochrom> most Intel CPUs these days are actually extremely good at parallel processing, too
14:28:36 <diverdude> so if there are dependencies these are simply handled single threaded
14:28:45 <monochrom> if you issue the two instructions "write 1 to eax, then write 2 to address 145", they happen in parallel.
14:29:09 <monochrom> but no one takes this and go around and say "so Intel CPUs are bad at sequential processing?"
14:29:10 <diverdude> monochrom, yes
14:29:19 <EvanR> diverdude: there are ways you can make two expressions evaluate in different sparks, but thats not the normal way
14:29:20 <diverdude> true
14:29:39 <diverdude> i see
14:29:50 <EvanR> most of the time that would probably slow things down
14:30:00 <diverdude> sorry i know my questions are ignorant...i am still trying to grasp the concept
14:43:08 <diverdude> Does anybody in here know a good place with exercises in convert imperative programs to functional programs ?
14:46:00 <saurabhnanda> :t (^?)
14:46:01 <lambdabot> s -> Getting (First a) s a -> Maybe a
14:52:03 <Myrl-saki> How do I do case binding again?
14:52:13 <Myrl-saki> Or in guard
14:53:02 <Myrl-saki> Found it.
14:56:41 <Myrl-saki> https://wiki.haskell.org/Pattern_guard
15:01:25 <tippenein> I need to sort by the values of a STMContainer's Map. It is currently streaming into a ListT fold, but I'm not sure how to do this sort https://hackage.haskell.org/package/stm-containers-0.2.13/docs/STMContainers-Map.html
15:02:16 <tippenein> maybe a traverse_
15:02:24 <tippenein> I'm looking to do it as efficiently as possible
15:04:25 * hackagebot microlens 0.4.4.2 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.4.2 (Artyom)
15:05:10 <puregreen_> ugh. How to get bold text in package description? __x__ doesn't work.
15:09:19 <drostie> tippenein: is there any reason the obvious lazy idea of using toList, fmapping Data.List.sort over it, and then if you really need it as a ListT using fromFoldable or something, can't work?
15:12:55 <tippenein> drostie: I suppose. I think I need to have more faith in ghc
15:15:07 <tippenein> I suppose it would be a sortBy snd or something
15:20:20 <EvanR> :t sortBy (comparing snd)
15:20:22 <lambdabot> Ord a => [(a1, a)] -> [(a1, a)]
15:37:46 <terney> installing OpenGLRaw for Gloss with cabal is going to be the death of me
15:38:12 <terney> I am in gl.h hell
15:38:51 <terney> ...did it just work?
15:39:13 <drostie> TERNEY used COMPLAIN. It's super-effective!
15:40:20 <terney> ...I changed nothing and it worked on the nth try. I have been spared by the gods
15:40:35 <tgeeky> you must be new at this. that's an even more worrying situation :o
15:41:14 <terney> It means I don't have to look at it anymore, this is a win in my book
15:41:52 <tgeeky> algorithim question: suppose I have a user's XML document, and an XML specification. The document meets the specification except in one regard: the specification has an implicit ordering (of attributes and elements inside attributes) that needs to be maintained. What kind of structure/algorithim is this?
15:42:54 * dfeuer wonders whether he could write a really fast version of Data.List.Split.splitPlaces for Data.Sequence. Hmmmmmm.....
15:43:05 <tgeeky> so I just want to re-print/re-order the document by traversing throug the XML specification and inserting as appropriate
15:44:28 <drostie> tgeeky: I'd call it a "tree traversal" algorithm.
15:44:35 <dfeuer> TREEEEEE traversal.
15:45:00 <tgeeky> drostie: I was sort of afraid of that answer. OK.
15:45:12 <dfeuer> drostie, is it really a traversal, per se?
15:45:18 * dfeuer throws fish at tgeeky.
15:45:31 <tgeeky> (I am required to do this in Ruby, not haskell)
15:45:55 * EvanR throws instance_eval at tgeeky 
15:46:23 * tgeeky calls a proc inside a lambda inside the original instance eval, and dies
15:46:24 <drostie> @tgeeky: if the depth of the tree is not insane, a simple recursive descent will do well. In fact this sort of thing is a little easier in an everything-is-mutable language like Ruby.
15:46:24 <lambdabot> Unknown command, try @list
15:46:31 <dfeuer> tgeeky, that sounds horrible. Is there a Haskell-to-Ruby compiler yet?
15:46:57 <tgeeky> drostie: it's not that it's easier or harder, but I would be much more likely to trust my haskell solution to it than a ruby solution
15:47:03 <tgeeky> dfeuer: I don't know
15:47:22 <dfeuer> drostie, how's that? Such things tend to be easy in Haskell with pattern matching and record syntax and maybe even lenses....
15:47:35 <tgeeky> again, not about ease, it's about trust :)
15:47:53 <dfeuer> Then do it without mutation?
15:47:56 <EvanR> tree traversals are kind of especially simple in haskell
15:47:57 <dfeuer> Mutation is very wild.
15:48:21 <tgeeky> i have had the super fun experience in Ruby of writing in a bug, only to find out a week later (when I write some other code which activates a dormant code path) that a basic syntax error wasn't even caught.
15:48:42 <EvanR> -defer-syntax-error
15:48:45 <dfeuer> Where Haskell tends to hurt a bit is with *graphs*.
15:49:01 <tgeeky> EvanR: yeah, I want -fno-defer-syntax-error for Ruby, kthx
15:49:17 <hpc> "hurt" is a bit relative there ;)
15:49:21 <tgeeky> so what would I be doing at each node in the tree? I would be zipping?
15:49:49 <nkaretnikov> is there a way to get all versions of a package from hackage?
15:50:00 <hpc> it hurts by graphs not being amenable to the more obvious functional definitions and having to write them as any other language would, indexing sets of edges and nodes
15:50:10 <nkaretnikov> right now i just copy and paste them from the browser and use a script to cabal get each
15:50:36 <EvanR> whats a more obvious functional definition of a graph?
15:51:02 <hpc> EvanR: defining it as you would a tree, with loops being represented by tying the knot or something like that
15:51:03 <tgeeky> nkaretnikov: get the list from /package/packagename, then iterate over the version links and get each that way
15:51:15 <EvanR> if thats the case... you can do that
15:51:18 <hpc> (obvious in concept, not implementation)
15:51:27 <dfeuer> hpc, I just meant you tend to need to use a bunch of maps and things, because you can't just throw pointers around.
15:51:51 <EvanR> thats how i defined my maze for pacman
15:51:52 <hpc> EvanR: you can but it's a nightmare and if there's a loop in the graph you can't map over it, and stuff like that
15:51:58 <EvanR> a huge recursive node list
15:51:58 <hpc> mapping loses the knot-tying
15:52:11 <tgeeky> dependent types don't help there, do they?
15:52:27 <dfeuer> Dependent types?
15:52:28 <hpc> and you can't persist the graph without doing other stuff like giving each node an id anyway
15:52:29 <tgeeky> there is fgl, which I remember
15:52:29 <tgeeky> https://hackage.haskell.org/package/fgl
15:52:30 <nkaretnikov> tgeeky: do you fetch the page contents, grep that for versions, and work with that?
15:52:34 <maerwald> tying the knot only makes a knot in your brain
15:52:37 <tgeeky> nkaretnikov: yeah
15:52:46 <maerwald> I consider it one of haskells anti-patterns
15:53:06 <nkaretnikov> tgeeky: ah, that's what i do, too, except the first step
15:53:16 <drostie> tgeeky: you can always start with writing in Haskell; data XML = XML {name :: Text, attrs :: [(Text, Text)], children :: [Either Text XML]}, and then rewrite in Ruby.
15:53:19 <hpc> tying the knot has its place, though probably not enough of one to deserve having a name
15:53:25 <tgeeky> nkaretnikov: you might be able to assume that you can always get /package-<version>/package-<version>.tar.gz
15:53:25 <hexagoxel> nkaretnikov: while you are at it, could you write me a script to provide the list of exposed modules for each version of each package?
15:53:32 <nkaretnikov> tgeeky: i could probably do that via cabal info if i knew how to list all versions there
15:53:35 <tgeeky> nkaretnikov: making it much easier than finding the download link on each page
15:53:39 <tgeeky> nkaretnikov: indeed
15:53:48 <hexagoxel> (preferably in a caching, incremental way)
15:53:49 <nkaretnikov> hexagoxel: ;P
15:54:09 <hpc> and i am not a fan of how the usefulness of it depends on pointer equality
15:54:33 <tgeeky> maerwald: I thought tying the knot is integral to funpro doing complex data structures
15:54:46 <drostie> dfeuer: the basic reason why it might be easier in Ruby is because it can be decoupled into a generic function which walks a tree and runs a subroutine on every node, and a function which looks at the present node and orders its children into proper order.
15:55:11 <hpc> tgeeky: tying the knot is recursive data structures plus the thing in memory looping back on itself
15:55:22 <hpc> tgeeky: fix f = f (fix f) -- not knot-tied
15:55:27 <EvanR> drostie: you could do it like that in haskell, and learn its not that generic
15:55:29 <hpc> tgeeky: fix f = let x = f x in x -- knot-tied
15:55:39 <maerwald> well, those are simple examples
15:55:50 <maerwald> it gets funnier if you want to do more than that
15:56:04 <maerwald> and then it's "write once, never understand again" code
15:56:04 <drostie> dfeuer: with a functional language you'd need to look carefully at it because the lowest-level functions need to return new cells and you realize that you were skipping a step via impurity.
15:56:11 <hpc> tgeeky: knot-tying is extremely fragile too
15:56:18 <hexagoxel> nkaretnikov: you are aware of hackage.haskell.org/api ?
15:56:18 <hpc> let ones = 1 : ones in ones -- knot-tied
15:56:24 <hpc> map id ones -- not knot-tied
15:56:27 <drostie> It's not impossible; it's just harder.
15:56:28 <tgeeky> hpc: aren't there some pretty good algorithims that can't be done without it in haskell?
15:56:38 <maerwald> no
15:56:45 <nkaretnikov> hexagoxel: i may have used it, but i don't recall right now
15:56:49 <hpc> nothing is impossible without it, it just might use more memory
15:56:54 <hexagoxel> nkaretnikov: especially http://hackage.haskell.org/api#versions
15:57:03 <hpc> knot-tying might be a necessary part of those algorithms being "good" though ;)
15:57:11 <EvanR> drostie: that actually makes it easier, more often than not "cleverly using impurity" has exploded in my face, immutable not
15:57:19 <hpc> it has its place, specific as it is
15:57:20 <tgeeky> hpc: oh. ok. I had the wrong impression about that, then. I thought it was mandatory for some things.
15:57:24 <nkaretnikov> hexagoxel: anyway, i fetched what i wanted already, so this can wait until i need to do this again :)
15:57:28 <maerwald> hpc: only for simple stuff imo
15:57:33 <hpc> maerwald: yeah
15:57:36 <nkaretnikov> hexagoxel: thanks for letting me know, tho
15:57:42 <tgeeky> hpc: do you know if anyone has ever learned to generically rewrite knot tying out?
15:57:48 <hexagoxel> nkaretnikov: :)
15:57:49 <maerwald> for anything else people should use fgl
15:57:55 <EvanR> you can use equational reasoning to do tree processing, with mutable containers not
15:58:18 <hpc> tgeeky: don't think so - it's not a terribly interesting technique theoretically speaking
15:58:51 <tgeeky> ok
15:59:02 <hpc> tgeeky: as mentioned, map id /= id under knot-tying, and a bunch of other obvious stuff breaks too
15:59:12 <hpc> i certainly wouldn't want to try and generalize it
15:59:38 <EvanR> for some value of /=
16:00:00 <hpc> yeah
16:00:45 <hpc> "x /= y under knot-tying" meaning when you observe the knot-tying characteristics of x and y, they are different
16:01:02 <EvanR> oh map id /= id if its fmap and a cyclic structure
16:01:15 <EvanR> hmm
16:01:20 <EvanR> yeah it is envermind
16:01:31 <EvanR> if its lazy
16:01:46 <EvanR> still "dumb in real life"
16:01:57 <hpc> heh
16:02:25 <hpc> i suppose if you want to get a bit formal with it, suppose you have ones defined as above, unevaluated
16:02:49 <hpc> so ones is a thunk
16:02:59 <hpc> if you do rnf (head ones), ones is now in normal form
16:03:13 <hpc> if you do rnf (head (map id ones))
16:03:20 <hpc> ones is (1 : thunk)
16:03:54 <lethjakman> https://gist.github.com/lethjakman/8896558d09d80f02b95e174097bca688
16:03:58 <lethjakman> So, this is potentially a dumb question. 
16:04:10 <hpc> we'll try and give a dumb answer
16:04:41 <hpc> ah
16:04:45 <lethjakman> But these functions look like they should be equivelent
16:04:51 <hpc> line 6, return (getResponseBody response)
16:05:34 <hpc> wait no
16:06:14 <drostie> lethjakman: body is a program which produces some text when it is run..
16:06:35 <hpc> so in broken.hs, if we go with line 2 being correct, body :: Response ByteString
16:07:02 <hpc> er
16:07:15 * hpc just blew all of his smartness on knot-tying it seems
16:07:23 <hpc> so in broken.hs, if we go with line 2 being correct, body :: ByteString
16:07:28 <lethjakman> How knotty. 
16:07:28 <drostie> lethjakman: parseLBS is not expecting to get an argument which is a program, just a bunch of text.
16:07:36 <hpc> if we go with lines 4 and 5 being correct, body :: Response (???)
16:07:45 <lethjakman> drostie: But...it doesn't need any arguments
16:07:49 <lethjakman> Which measn it should execute, no?
16:07:54 <lethjakman> Or is it the do block?
16:08:08 <hpc> presumably getWebsiteCursor :: Response something
16:08:30 <hpc> so you want something like... /me lpastes
16:08:38 <lethjakman> -- getWebsiteCursor :: Request -> IO Cursor
16:08:40 <drostie> lethjakman: no. Haskell is a pure language and cannot do anything. Haskell expects you to write down a program called main which it produces as the executable which ghc creates. By itself in the pure mathematical world of Haskell, nothing happens.
16:09:08 <hpc> lethjakman: http://lpaste.net/7428895371570446336
16:09:34 <lethjakman> Oh.
16:09:41 <drostie> lethjakman: to help you, Haskell has data types for "a program which produces an x" and ways to combine a program which produces an x with a function which takes an x and produces a y, or produces a program which produces a y.
16:09:58 <hpc> lethjakman: body is a Response-y thing, the last line of the do-block for body :: Response something, and you use "foo <- bar" in the top do-notation to execute it
16:10:21 <drostie> lethjakman: the problem is that when you write body = do {...} you're then saying "hey, body is a program..." and parseLBS is not expecting a program.
16:10:47 <hpc> lethjakman: the distinction between referring to an action and executing it is extremely significant, because you can pass actions as parameters and have them maybe be executed zero or more times by something else
16:10:56 <drostie> lethjakman: you could for example fmap (fromDocument . parseLBS) body if you wanted those functions x -> y to operate on an m x to make an m y.
16:11:06 <hpc> for instance, fiveTimes action = do {action; action; action; action; action}
16:11:13 <hpc> fiveTimes (print "mmm, bacon")
16:11:53 <lethjakman> Ahhh
16:11:55 <lethjakman> That makes sense to me. 
16:11:59 <hpc> if it executed that print and passed the result of it to fiveTimes, that'd print "mmm, bacon" once, then run (fiveTimes ())
16:12:02 <hpc> which makes no sense
16:12:07 <lethjakman> drostie
16:12:19 <hpc> it's probably my favorite haskell feature
16:12:32 <lethjakman> hpc: That makes sense as well. 
16:12:46 <drostie> lethjakman: (fmap f x is, for the purposes of this, a shorthand for the block do { a <- x; return (f a) } . It is slightly more general and part of the Monad class instead of the Functor class.)
16:13:03 <drostie> er, part of the Functor class instead of the Monad class.
16:13:16 <drostie> But every monad is a functor.
16:14:44 <drostie> lethjakman: then when you get really good you'll start writing this stuff as httpLBS url >>= fromDocument . parseLBS . getResponseBody  ;-)
16:14:56 <hpc> lethjakman: once you're comfortable with the definition of Monad and how do-notation is desugared, you'll be able to do far crazy-cooler things than write fiveTimes :D
16:15:23 <lethjakman> drostie: Would you consider that syntax to be more clear?
16:15:28 <lethjakman> I can see how it's less verbose
16:15:47 <drostie> lethjakman: actually I'd consider that syntax to be probably broken, lol.
16:15:58 <lethjakman> hpc: I have an idea of how monad works...I just don't get much of a chance to work in haskell so I mess stupid things like this up. 
16:16:01 <lethjakman> Why broken?
16:17:05 <drostie> lethjakman: because it's probably incorrect. I think you instead want fmap (fromDocument . parseLBS . getResponseBody) (httpLBS url).
16:17:38 <drostie> you'd need to add a "return . " onto the front of that chain of things on the right for what I wrote to work.
16:17:46 <drostie> And then it's probably clearer to just fmap.
16:18:14 <hpc> the clearest definition is the one you understand ;)
16:18:28 <drostie> lethjakman: what hpc said ^
16:19:02 <drostie> I understand . and fmap very naturally; some people better understand it when it's written in do-notation.
16:20:07 <drostie> Man, I wasn't expecting Stack to have this large of a learning curve... I guess the people who use it are more used to packaging stuff whereas I'm more used to writing one-off executables.
16:21:00 * drostie has no idea what the difference between app/ and src/ is...
16:21:23 <lethjakman> Hm, so I have another question. It suddenly lost the ability to infer my types with the where syntax. 
16:21:53 <lethjakman> Thank you both, that helped a lot :)
16:22:06 <drostie> Might be the monomorphism restriction kicking in. Might just be that something changed between the two. :P
16:22:44 <lethjakman> Hrm. OK. 
16:23:57 <EvanR> what is monomorphism restriction talking about, not monomorphisms right
16:24:07 <EvanR> monomorphic types?
16:24:28 <EvanR> seems like a weird word (-ism) for that
16:24:50 <drostie> Yeah, it's that types are restricted to be monomorphic.
16:25:02 <drostie> or, not even restricted, that word's a lie too.
16:25:17 <drostie> types are implicitly assumed to be monomorphic.
16:25:39 <EvanR> except top level defs
16:25:42 <drostie> But "monomorphic implicit assumption" is harder to prefix with, "the dreaded."
16:25:52 <EvanR> and rankN
16:27:30 <EvanR> it coulda been "the monomorphic restriction"
16:28:18 <monochrom> this "ism" is as in "parametric polymorphism"
16:29:06 <drostie> it coulda been the Shao Kahn rule. "Your types... are mine!"
16:29:27 <monochrom> and in fact also "truism", i.e., it is just nounifying a thing
16:31:18 <EvanR> i just realized monomorphism restriction... had no meaning to me as literal words ;)
16:31:32 <EvanR> just symbol for the monomorphism restriction
16:43:27 <drbean> monomorphism assumption, monomorphic type assumption
16:47:36 <hpc> the monochrom restriction
16:51:14 <EvanR> the monochromicles
16:59:58 <rfw> @pf id
16:59:58 <lambdabot> Maybe you meant: pl bf
17:00:01 <rfw> @pl id
17:00:02 <lambdabot> id
17:00:16 <rfw> @pl \(a, b) f -> (f a, b)
17:00:17 <lambdabot> uncurry (flip . ((,) .) . flip id)
17:00:38 <rfw> @pl \f g x -> f x && g x
17:00:38 <lambdabot> liftM2 (&&)
17:00:44 <rfw> oh, neat
17:01:41 <rfw> @pl \f x y z -> not (f x y z)
17:01:41 <lambdabot> (((not .) .) .)
17:01:46 <rfw> not so neat
17:02:39 <maerwald> not
17:02:39 <Iceland_jack> rfw: (\f (a, b) -> (f a, b)) is first
17:02:45 <Iceland_jack> @ty Data.Bifunctor.first
17:02:46 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
17:02:51 <rfw> Iceland_jack: ah interesting
17:03:03 <rfw> thanks!
17:03:04 <Iceland_jack> @ty Data.Bifunctor.first :: (a -> a') -> (a, b) -> (a', b)
17:03:06 <lambdabot> (a -> a') -> (a, b) -> (a', b)
17:03:06 <Iceland_jack> np
17:03:20 <rfw> i was looking at Control.Arrow but i guess (,) isn't an arrow
17:04:02 <maerwald> :t (*** id)
17:04:03 <lambdabot> (b -> c) -> (b, c') -> (c, c')
17:04:12 <Iceland_jack> ghci> :t Control.Arrow.first @(->)
17:04:12 <Iceland_jack> Control.Arrow.first @(->) :: (b -> c) -> (b, d) -> (c, d)
17:04:32 <Iceland_jack> ghci> :t Data.Bifunctor.first @(,)
17:04:32 <Iceland_jack> Data.Bifunctor.first @(,) :: (a -> b) -> (a, c) -> (b, c)
17:04:48 <Iceland_jack> Note (->) vs (,)
17:05:19 <Iceland_jack> @ty [Data.Bifunctor.first, Control.Arrow.first]
17:05:20 <lambdabot> [(a -> b) -> (a, c) -> (b, c)]
17:05:24 <Iceland_jack> magic
17:05:31 <vklx> is there a consensus on using spacemacs & intero together?
17:05:40 <EvanR> ghci> "sup"
17:06:01 <EvanR> phooey no @ in lambdabot yet
17:06:24 <Iceland_jack> I'm glad I'm not the only one who talks to their ghci 
17:07:01 <Iceland_jack> > sup
17:07:03 <lambdabot>  Iceland_jack, hey buddy
17:07:10 <Iceland_jack> h-hey *blush*
17:09:01 <arcetera> @src intercalate
17:09:01 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
17:39:32 * hackagebot timemap 0.0.4 - A mutable hashmap, implicitly indexed by UTCTime.  https://hackage.haskell.org/package/timemap-0.0.4 (athanclark)
17:41:47 <hank1979> I feel like an ideot savant:
17:41:59 <hank1979>  -- comb 2 [1,2,3] = [[1,2],[1,3],[2,3]] comb:: Int -> [a] -> [[a]] comb 0 _ = [[]] comb _ [] = [] comb n (x:xs) = (fmap (x:) (comb (n-1) xs)) ++ (comb n xs)
17:42:52 <hank1979> I feel this is correct but I don't now why. Haha.
17:43:47 <hank1979> comb:: Int -> [a] -> [[a]]
17:43:55 <hank1979> comb 0 _ = [[]]
17:44:03 <hank1979> comb _ [] = []
17:44:10 <hank1979> comb n (x:xs) = (fmap (x:) (comb (n-1) xs)) ++ (comb n xs)
17:44:22 <geekosaur> @paste might be better
17:44:22 <lambdabot> Haskell pastebin: http://lpaste.net/
17:44:37 <arcetera> geekosaur: is lpaste still down?
17:44:46 <geekosaur> oh. don't know
17:44:58 <hank1979> Did not really tought about the edge cases but it just works.
17:45:03 <geekosaur> just loaded for me
17:45:05 <hank1979> like negatives and 
17:45:34 <hank1979> combinations wanted bigger than set.
17:45:35 <hank1979> LOL
17:45:47 <arcetera> geekosaur: try submitting a paste
17:45:48 <hank1979> Only in haskell
17:45:53 <hpc> lpaste is up
17:46:15 <lpaste> arcetera pasted “test paste” at http://lpaste.net/165734
17:46:19 <arcetera> oh it works again
17:46:47 <hank1979> http://lpaste.net/165735
17:47:01 <hank1979> The question is do I cover all edge cases?
17:47:16 <hank1979> I think I do but I don't now why.
17:47:43 <geekosaur> try it with an infinite list
17:47:47 <hank1979> This intuitive drunk coding is what makes haskell awesam
17:48:04 <hpc> ghc is always sober
17:48:16 <EvanR> or is it
17:48:29 <geekosaur> ghci is high on kinds >.>
17:48:34 <geekosaur> *ghc
17:48:35 <hpc> glorious guiness haskell compilation system
17:49:00 <hank1979> I think it diverges with an infinite list ... duh
17:49:33 <geekosaur> well, for infinite list but positive count, the count will limit it. negative count + infinite list diverges
17:49:43 <hpc> @let comb 0 _ = [[]]; comb _ [] = []; comb n (x:xs) = (fmap (x:) (comb (n-1) xs)) ++ (comb n xs)
17:49:45 <lambdabot>  Defined.
17:49:50 <hpc> > comb 3 [1..]
17:49:51 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,2,7],[1,2,8],[1,2,9],[1,2,10],[1,2,11],[...
17:50:03 <geekosaur> oh, maybe not
17:50:05 <geekosaur> sigh
17:50:24 <hpc> all those pesky non-bottoms
17:50:34 <hpc> how much simpler life would be if every program crashed unconditionally
17:51:18 <geekosaur> right, I didn't think through that first clause fully, sigh
17:51:21 <hank1979> Maybe more of a math question but should comb 0 [] be [[]]
17:51:33 <hank1979> Or do I have the order messed up.
17:51:34 <hank1979> ?
17:51:46 <hpc> no, you need both cases
17:52:15 <hank1979> Yeah but what should result comb 0 [] be? [] or [[]]
17:52:16 <hank1979> ?
17:52:21 <hpc> oh fair point
17:52:31 <hpc> > comb 3 [1, 2, 3]
17:52:32 <lambdabot>  [[1,2,3]]
17:52:37 <hpc> > comb 2 [1, 2, 3]
17:52:38 <lambdabot>  [[1,2],[1,3],[2,3]]
17:52:41 <hpc> @undefine
17:52:41 <lambdabot> Undefined.
17:52:52 <hpc> @let comb 0 _ = [[]]; comb _ [] = [[]]; comb n (x:xs) = (fmap (x:) (comb (n-1) xs)) ++ (comb n xs)
17:52:53 <lambdabot>  Defined.
17:52:55 <hpc> > comb 2 [1, 2, 3]
17:52:56 <lambdabot>  [[1,2],[1,3],[1],[2,3],[2],[3],[]]
17:53:14 <hank1979> That does not look right lol
17:53:23 <hpc> so here's a good exercise, figure out why that's different
17:54:07 <hank1979> It's the termination in the recursion 
17:55:44 <hank1979> But it's more like:
17:57:10 <monochrom> what is comb? (No, don't tell me to read the code. Because the very question is what code is right. So, what is considered right?)
17:58:17 <arcetera> @src comb
17:58:17 <lambdabot> Source not found. stty: unknown mode: doofus
17:58:19 <arcetera> huh
17:58:31 <hank1979> The possible combinations of lenght n of a set.
17:58:34 <arcetera> who broke lambdabot 
17:59:26 <monochrom> there is exactly one combination of length 0.
18:00:05 <hank1979> Ah yes. If you swap the edge cases it doesn't work anyway.
18:00:35 <hank1979> (Not much of a proof)
18:01:13 <hank1979> (My unconcious is so much more intelligent than me)
18:01:27 <hank1979> subconcious I mean
18:02:13 <hank1979> DOOFUS is an Linux errorcode
18:02:15 <hank1979> lol
18:04:58 <geekosaur> te @src command does not show what lambdabot knows, it shows fixed text from a fixed database
18:05:04 <geekosaur> and that database sometimes lies
18:05:06 <arcetera> oh
18:05:07 <arcetera> ok
18:06:01 <EvanR> let True = False in True
18:06:49 <EvanR> this code is false
18:09:14 <geekosaur> hank1979, re those messages... they're from sudo's insults mode, which is from openbsd
18:10:13 <hank1979> Yes EDOOFUS 
18:10:32 <hank1979> It's from BSD indeed
18:12:26 <hank1979> Haskell is so cool. You can type correct code you can't even barely comprehent yourself.
18:13:45 <EvanR> the exact opposite of many other languages
18:14:03 <EvanR> it is obviously correct to you only
18:16:22 <maerwald> hank1979: I usually stop typing when that happens.
18:24:34 * hackagebot khph 0.1.0 - Command-line file tagging and organization tool  https://hackage.haskell.org/package/khph-0.1.0 (khumba)
18:26:40 <MichaelBurge> hank1979: Sometimes after a few hours of slogging through compiler errors after a big change, my code will work but I won't know how anything fits together anymore.
18:30:47 <khumba> I'm always happy when I get to use <=<.  Sadly, by the time the code gets released it's usually been removed because I had to revert to do notation to add an error check or something...
18:36:32 <EvanR> kleisli is often a pipe dream (hyuk)
18:45:33 <dfeuer> Yee haw! Yeah, I cut the time for Data.Sequence.fromList for 10000 elements from 510 microseconds to 281 microseconds just now....
18:46:06 <dfeuer> Through an extremely simple change to remove useless laziness.
18:49:44 * nitrix thumbs up :)
18:51:02 <nitrix> Are there situations where using a lot of strictness would look great on benchmarks but actually impact programs that'd benefit from the lazyness instead?
18:51:04 <dfeuer> Who's recursion-ninja?
18:51:31 <nitrix> (For those kind of micro optimizations like dfeuer has)
18:52:26 <dfeuer> nitrix, not in this case, I don't think! It was suspending many many bits of work too small to be worth suspending.
18:52:53 <dfeuer> BUilding up big chains of thunks when it could have just done its job immediately.
18:53:19 <dfeuer> Basically building *thunks* instead of building *subtrees*, all recursively.
18:54:32 <dfeuer> There just isn't any *useful* laziness to be had there. All the pieces have to get stashed in memory; the only question is in what form they're stashed. It might as well be the one we want.
18:55:29 <dfeuer> nitrix, in particular, the Seq type is strict in both the beginning *and the end* of the sequence. So converting from a list *must* hit the whole list.
18:55:55 <nitrix> Gotcha.
18:56:22 <nitrix> But is there a risk that strictness optimization actually backfire even if benchmarks seems primarily positive?
18:57:21 <dfeuer> This one? I doubt it. There are two such changes I've made recently that have that potential, but I think the gain in predictability (as well as benchmark speed) is worth the potential loss in unusual circumstances.
18:57:36 <nitrix> I'm assuming, if the benchmark represent well a realistic usage (just on a bigger scale), then it's probably fine.
18:58:16 <dfeuer> The ones that could potentially hurt are a change in appending, which now performs O(log (min (i, n - i))) work immediately, instead of suspending all but O(1) of it,
18:58:20 <nitrix> dfeuer: (I'm learning more than questioning your work, btw ;)
18:58:22 <dfeuer> and adjust, which does similar.
18:58:53 <dfeuer> These operations are advertised as O(log ...), and that is their true amortized cost,
18:59:11 <dfeuer> but there are situations where being lazier could potentially be better.
18:59:26 <dfeuer> However, that previous laziness could lead to many thunks building up in the tree,
18:59:41 <dfeuer> causing a sudden badness at some point or other.
19:00:14 <dfeuer> My changes bring the thunk distribution in the trees much closer to the debits allowed in the amortized analysis.
19:00:46 <dfeuer> The big exceptions are "bulk" operations like map, <*>, replicate, ...., where being super-lazy is almost always the right thing.
19:01:27 <dfeuer> When forcing a thunk is going to create more thunks, building a tree, you generally don't want to force preemptively.
19:01:51 <dfeuer> That can *theoretically* cause trouble if someone maps over the tree a bunch of times, but it's almost always a win.
19:03:10 <nitrix> Very cool (:
19:04:21 <dfeuer> :)
19:09:36 * hackagebot th-data-compat 0.0.2.0 - Compatibility for data definition template of TH  https://hackage.haskell.org/package/th-data-compat-0.0.2.0 (KeiHibino)
19:12:03 <athan> I'm probably going to get some flack for this, but does anyone know if there are ToJSON / FromJSON instances for Cabal?
19:12:07 <athan> ...that work with hackage? :D
19:14:05 <athan> wait I'm silly, nevermind
19:25:32 <pikajude> how does the ordering of arguments with TypeApplications work, exactly?
19:25:56 <pikajude> in fromIntegral @Int, the "Int" appears to apply to the a in (Num b, Integral a) => a -> b
19:26:04 <pikajude> whereas in fmap @[], the [] appears to apply to the f in (a -> b) -> f a -> f b
19:32:31 <c_wraith> pikajude: if the declaration has an explicit forall, it uses the order specified there
19:32:39 <pikajude> and if it doesn't
19:32:50 <c_wraith> pikajude: otherwise it follows the order they appear in the type signature
19:33:08 <c_wraith> I *believe* context is ignored
19:34:16 <shelf> i have a patch for Cabal-the-library and I'm having trouble testing it. who should I talk to?
19:38:17 <c_wraith> pikajude: I was wrong.  The context does count.
19:43:56 <dfeuer> And I shaved off just a few more microseconds.
19:44:33 <dfeuer> In all ~twice as fast. Yay.
19:44:54 <c_wraith> Is a few microseconds a large change or a small one? :)
19:46:08 <dfeuer> c_wraith, a small change; I just used a totally strict list type to prevent GHC from forcing things that are already forced. The generally eager building I implemented just before that had a much bigger impact.
19:47:23 <dfeuer> athan, you still there?
19:47:49 <dfeuer> Hrmph.
19:48:54 <athan> dfeuer: whutup b
19:49:11 <athan> it's suprising I know
19:49:12 <dfeuer> athan, you submitted a PR to containers to add some Tree stuff a while back.
19:49:25 <athan> Yeah I just looked at the comment today actually
19:49:31 <dfeuer> And Milan asked you to raise the issue on the libraries list.
19:49:32 <athan> I haven't put much thought into it lately
19:49:39 <athan> :x
19:49:46 <dfeuer> Did you? Do you want to?
19:50:12 <athan> I haven't, I would have to co-age into my former self to remember what I was doing
19:50:50 <dfeuer> These are not the sorts of functions that are (to me) so obviously generally useful that they barely require discussion. That doesn't *at all* mean they're not valuable or even generally useful; they just need some support.
19:51:15 <athan> but yes, I would like to. How imperative do you feel I should be in raising the issue?
19:51:35 <athan> definitely, I'll build an argument
19:51:40 <dfeuer> However you like!
19:51:41 <athan> (and probably some revisions >.>)
19:51:46 <dfeuer> Whatever you think will be effective!
19:51:52 <athan> thanks dfeuer :)
19:52:04 <dfeuer> I love adding fun new stuff, as long as there's a reason to, and as long as it's fast!
19:52:36 <athan> I can sympathize with that; I don't think I included any form of benchmarks
19:52:45 <dfeuer> containers has a whole benchmark suite for ... I think everything *except* Trees and Graphs.
19:52:54 <dfeuer> You can probably copy structure from the others.
19:53:01 <dfeuer> We could really use some Tree benchmarks.
19:53:33 <dfeuer> In particular, there are some alternative implementations of monadic tree unfolds that I'd like to play with, but without a benchmark suite, that's not happening.
19:53:48 <dfeuer> Also a test suite.
19:53:57 <dfeuer> Data.Tree has been far too abandoned for far too long.
19:56:27 <athan> oh wow really? I made a rose-trees library a while back that had some naive benchmarks
19:56:43 <athan> sounds good :)
19:57:27 <dfeuer> athan, maybe you can adapt your benchmarks to Data.Tree!
19:57:40 <dfeuer> I am using too many! exclamation! points! today!
19:57:42 <dfeuer> Why?
19:57:45 <dfeuer> I don't know.
19:58:13 <athan> !*
20:05:49 <dfeuer> WAT
20:07:07 <dfeuer> Does anyone know anything about how Typeable worked in Hugs and/or nhc98? Yes, I'm actually asking.
20:09:07 <geekosaur> ...either of those had it?
20:09:56 <geekosaur> pretty sure nhc98 was dead by the time Typeable showed up, at least
20:10:51 <dfeuer> geekosaur, I'm looking at https://github.com/haskell/containers/blob/master/include/containers.h#L26
20:11:14 <dfeuer> Which says what the INSTANCE_TYPEABLE[0-3] macros mean for non-GHC compilers.
20:11:28 <dfeuer> And that's some pretty weird stuff.
20:12:06 <dfeuer> Which I intend to delete.
20:13:14 <dfeuer> In fact, I intend to gut almost all of that, leaving only  #define TYPEABLE0 Typeable, etc.
20:13:30 <dfeuer> or something.
20:17:04 <geekosaur> huh. there is indeed a Data.Typeable in the source distribution
20:17:38 <dfeuer> That's okay. The next major version of containers explicitly does not attempt to support NHC98 anymore :-)
20:17:47 <geekosaur> and it's ... interesting, from the looks of it
20:18:02 <dfeuer> Because we haven't been testing with it for years.
20:18:06 <geekosaur> (I'm looking at hugs. nhc98 was already dead when I started out in 2006)
20:18:14 <dfeuer> Ah, okay.
20:18:19 <dfeuer> Well, Hugs isn't supported either.
20:18:32 <dfeuer> Neither is GHC < 7.0.
20:18:53 <geekosaur> in any case I know base had all its nhc/hugs compat removed some versions ago
20:19:15 <dfeuer> I was just looking around to see what should be dropped next.
20:19:45 <geekosaur> so I'd imagine you can kill it in containers; if someone wants a newer containers in hugs that badly, they can start out by updating hugs past 2006 :)
20:20:05 <dfeuer> I don't think there's actually much cruft available to drop till we stop supporting 7.6, which could take a while.
20:20:29 <dfeuer> Oh, I doubt very much that containers has actually *worked* with Hugs or nhc98 in a long tim.
20:20:31 <dfeuer> time.
20:20:46 <dfeuer> I'm just trying to clean out the previous attempts to support them.
20:21:11 <dfeuer> There was a fun spot where a type signature had to be conditionally left out to handle some nhc98 type checker bug....
20:48:18 <athan> A Cabal package can specify multiple Categories, correct?
20:54:52 <athan> ah, here's an example of a package that falls under both Data and Time:   , author     :: String
20:54:55 <athan>   , maintainer :: String
20:54:57 <athan> :|
20:54:59 <athan> *re-cuts*
20:55:00 <athan> http://hackage.haskell.org/package/timemap
20:56:00 <athan> yet why is the `category` field a single `String` in the Cabal library? http://hackage.haskell.org/package/Cabal-1.24.0.0/docs/Distribution-PackageDescription.html#t:PackageDescription
21:06:52 <athan> ahh it's just a comma-separated value
21:06:55 <athan> ... :\
21:07:56 <geekosaur> if it's not used by ghc-pkg, it's probably just treated as a string, yeh
21:08:17 <geekosaur> or by cabal/stack to make a build plan
21:14:21 <athan> thanks geekosaur!
21:17:19 <athan> This is definitely a nit-pick, but is there a way to check if a particular version is preferred or not in a PackageDescription?
21:17:25 <athan> So far it doesn't seem so :\
21:19:38 <geekosaur> I don't know for certain but I don't think so. I don't think there are particular versions preferred, just some that are marked deprecated (and cabal-install at least keeps that as separate metadata)
21:20:38 <geekosaur> hm, well, I don't know if it's only in that metadata. it's stored in the package index as a separate piece of data but that may only be for speed
21:20:43 <athan> Yeah I saw the hackage api link `/packages/preferred-versions`, I might just parse that :)
21:38:30 <athan> crimeny, https://hackage.haskell.org/packages/downloads doesn't work for me :\
21:46:11 <lpaste> platz pasted “OneOf.hs” at http://lpaste.net/165745
21:47:19 <platz> ok, here something I've been thinking about... consider why people like tuples so much; isn't it because it lets one avoid having to name the shape of some data.. some things would be onerous to create a type for, if the type is only used once because the shape changes with each function call?
21:47:30 <platz> Now, the same situation to me can occur with sum types
21:47:43 <platz> you have some data passing through, but it isn't expressed properly as a product or record
21:47:56 <Cale> People like tuples?
21:47:57 <platz> would you create a one-off sum type for each usage? (see lpaste above)
21:48:11 <platz> maybe *like* is the wrong word
21:48:12 <Cale> You almost never see tuples much larger than a pair
21:48:24 <shachaf> What I'd like to have is unboxed sum types.
21:48:32 <platz> i'm not suggesting them as an architectural backbone.. but they are in the language
21:48:39 <shachaf> Those would probably have to be standard, like unboxed tuples.
21:48:47 <platz> it's the same reason we like Either, no?
21:49:07 <Cale> Yeah, (,) and Either are the important ones
21:49:30 <shachaf> Unboxed tuples are also used in n-ary form. :-)
21:49:54 <platz> but Either only accepts two two constructors.. what about a data type like OneOf (above) that could take more constructors, and isn't left-biased (w/ instances) like either
21:51:29 <platz> example motivation would be something that has one of three cases, but has only one use-site.. do you just declare a one-off sum type?
21:52:01 <platz> and hope the situation doesn't occur often littering your code with these one-off data types?
21:53:25 <athan> the odd thing for me is why /packages/downloads is protected; isn't that like... one of the simplest coinductive statistics ever?
22:00:09 <Cale> athan: What do you mean "coinductive statistics"
22:01:00 <shachaf> Statistics is often coinciductive.
22:03:59 <platz> the feeling i'm getting is that "anonymous" sum types isn't a well recieved idea.  Anything with 2 cases is served by Either, and anything with more than 2 cases should be a user-defined sum type with a name
22:05:08 <platz> the only thing i'm uneasy about Either is if it's not being used to denote failures.. then it's instances don't make sense
22:05:34 <shachaf> They make as much sense as the tuple instances.
22:05:43 <shapr> I wonder what's happened to The Monad Reader?
22:06:07 <platz> ok.. they make sense in a formal way, yes.
22:14:44 <athan> Cale, shachaf: I mean it's a running statistic, sorr
22:14:47 <athan> sorry*
22:15:05 <athan> something opposite to a statistic like `median`, for example
22:15:59 <athan> maybe a constant-space value? I'm not sure what the right word should be
22:19:49 <platz> athan: hyperloglog
22:20:20 <athan> platz: Yeah but that's still not exact >_>
22:25:08 <platz> with the bayesian approach you can choose any statistic you want, and the output is a posterior distribution you can update every time you get some new data
22:46:03 <koz_> What's the most Haskelly way to shuffle a list?
22:46:56 <athan> koz_: define shuffle :P
22:47:18 <kadoban> Off the top of my head, annotate with random keys, sort by the keys.
22:47:23 <kadoban> There's likely a better way.
22:47:39 <kadoban> (there's also got to be an already implemented one somewhere)
22:47:42 <koz_> athan: Reorder at random.
22:48:17 <simpson> https://wiki.haskell.org/Random_shuffle
22:49:16 <athan> koz_: You could be hipster and do it like the poker players, choose a random number between 0 and the length-1, split at that position, swap their positions, and re-iterate that a few times :)
22:49:39 <athan> or do like a `take n` from the head, and append it to the back in-order, where `n` is also random, but smaller
22:50:03 <koz_> simpson: Thank you - the Fisher-Yates implementation there is *perfect* for my purposes!
22:50:07 <dmj`> map fst . sortBy (compare `on` snd) . zip list <$> do replicateM 10 $ randomRIO (1,10)
22:51:01 * koz_ now needs to figure out how to use that damned State monad, at long fucking last.
23:03:23 <Squarism> i thought lenses where primarily for supplying get/set of nested data types? or am i wrong there?
23:03:39 <koz_> Squarism: Lenses can do that.
23:03:43 <koz_> but they can do plenty more besides.
23:03:55 <Squarism> like?
23:03:55 <koz_> :t iterateM
23:03:57 <lambdabot>     Not in scope: ‘iterateM’
23:03:57 <lambdabot>     Perhaps you meant one of these:
23:03:57 <lambdabot>       ‘iterate’ (imported from Data.List),
23:04:24 <koz_> Squarism: For example, lenses can be used to define isomorphisms (reversible 'property-preserving' functions on types).
23:04:43 <koz_> They can also do things similar to the stuff the mono hierarchy and the plate libraries do.
23:05:56 <Squarism> sometimes you sound like abstract algebraists
23:06:07 <koz_> Squarism: To some degree, we kinda are. :P
23:20:10 <Squarism> 1. I find beeing explicit in function arguments is a less bulky way of doing haskell. 2. In other languages, less so. Where i tend to rather use more coarse arguments types as it can be more descriptive. Now i have a "game board" class. in my game. But instead of passing that around (to avoid bulkiness), i pass around properties of it. That leads to not so intuitive argument lists. What are poeples tak
23:20:10 <Squarism> e on that?
23:20:39 <Squarism> "game board" type
23:24:14 <Cale> Squarism: Well, if you're passing the same collections of arguments around to many different places, that's a decent sign that maybe there's a datatype you should define
23:24:19 <lpaste> koz_ pasted “How can I haz parallelz for this sauce code?” at http://lpaste.net/165752
23:26:13 <Cale> Squarism: But I think it really is a good way to start out -- just start with plain function parameters rather than immediately going for some clunky monad transformer, and then figure out what's happening by looking at how the parameters get used.
23:28:27 <Squarism> Cale, good point about "should really be a type".
23:30:47 <koz_> Cale: Would you be willing to give me some advice on parallelizing my code using Control.Parallel?
23:32:53 <Cale> koz_: Well, maybe try replacing the map over cases with a parMap
23:33:16 <Cale> parMap rdeepseq (\gens -> ...) cases
23:33:31 <koz_> rdeepseq will work on this? OK.
23:33:44 <koz_> And I guess I have to pass some flags to GHC/the executable to make it happy?
23:44:25 <koz_> Also, it seems something isn't right with this shuffle code: https://wiki.haskell.org/Random_shuffle#Purely_functional
23:44:34 <koz_> I'm using it in my program, and it dead-ends on a call to !
23:45:36 <pavel1> link with -rtsopts, run with +RTS -N<number:2..>
23:45:48 <tuchel> Could someone help me understand forall?
23:45:53 <cocreature> you also need -threaded
23:46:03 <bphil> who has a vagina
23:46:15 <athan> Can anyone here manage a working example of haskell listing all the packages available in a distro? http://hackage.haskell.org/api#distro
23:46:21 <athan> It won't seen to route for me
23:46:25 <tuchel> Why is length :: forall a. [a] -> Int not the same as length :: [a] -> Int
23:46:47 <shachaf> It means the same thing.
23:46:52 <pavel1> it's same
23:46:53 <athan> Wait I'm silly, `distro` is meant to be singular, not plural
23:47:19 --- mode: ChanServ set +o shachaf
23:47:26 --- mode: shachaf set +b *!*41192543@*.com/ip.65.25.37.67
23:47:26 --- kick: bphil was kicked by shachaf (bphil)
23:47:29 --- mode: shachaf set -o shachaf
23:47:35 <tuchel> Huh, then why use forall?
23:47:48 <koz_> tuchel: If you wanna use higher-rank types, you have to make the forall explicit.
23:48:00 <koz_> Also, if you want existential types (I think).
23:48:13 <shachaf> tuchel: Because there are some cases where it doesn't mean the same.
23:48:43 <shachaf> "x :: T" has an implicit forall for every type variable mentioned in T.
23:48:53 <athan> koz_: IIRC there's a wonky `exists` keyword, but I might be wrong :)
23:49:05 <tuchel> shachaf : an example would be nice
23:49:16 <pavel1> data Hello = forall a. Hello a   (:set -XExistentialQuantification)
23:49:30 <athan> tuchel: Every free variable in a type signature has a forall, floated to the left
23:49:35 <athan> (potentially >.>)
23:49:49 <shachaf> That's an example, but I'm not sure it's a good one since it's a different syntactic use of forall from the one tuchel was talking about.
23:49:52 <athan> where the `forall` is like a binder, sortof like a lambda
23:50:30 <shachaf> tuchel: foo :: (forall a. a -> a) -> (Char, Bool); foo f = (f 'a', f False)
23:50:46 <pavel1> Data.Typeable.typeOf (Hello 1) == Data.Typeable.typeOf (Hello "asdasd")
23:50:53 <pavel1> True
23:51:49 <athan> Does setting -XRank2Types include the type inference too?
23:51:55 <tuchel> Ah, okay. That makes it clearer
23:52:11 <cocreature> athan: no Rank2Types is just a synonym for RankNTypes these days
23:52:22 <athan> shoot, no :\
23:52:47 <athan> hmm, thanks cocreature that's pretty sneaky
23:53:17 <cocreature> athan: at some point it actually did only rank 2 types but I’m not sure if it ever made any attempt to infer types
23:54:49 * hackagebot servant-purescript 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/servant-purescript-0.1.0.0 (eskimo)
23:55:19 <cocreature> since we have stack the number of packages with the description “Initial project template from stack” has increased dramatically
23:55:19 <drbean_> Can I depend on "ids <- mapM snd gfWords" and "let pos = map fst gfWords" returning the elements of gfWords in the same order, allowing me to zip the results?
23:55:20 <Cale> I think the reason that Rank2Types exists is that type inference is possible for Rank2Types, but hasn't actually been implemented.
23:56:09 <cocreature> also I think hugs supported Rank2Types but not RankNTypes so in some cases you could run your code in hugs if you use Rank2Types instead of RankNTypes
23:56:56 <athan> hmm wow okay, thank you
23:56:59 <cocreature> drbean_: I’m not sure I understand what you’re asking but in your code they already are in the same order
23:57:09 <cocreature> obviously nobody cares about hugs these days :)
23:57:28 <athan> uh oh, hackage's preferred versions route is incorrect I think :\
23:57:32 <koz_> Cale: Is type inference possible at ranks above 2, provided there's a ceiling of maximum rank?
23:57:35 <Rotaerk> moms sure care about hugs
23:57:55 <Cale> koz_: I don't know.
23:57:55 <koz_> Like, if we fix a rank x, can we infer types up to rank x for any x (potentially)?
23:57:56 <athan> curl https://hackage.haskell.org/packages/preferred-versions --header "Accept: application/json" | grep webdriver
23:58:30 <athan> and if you look at the webdriver package on hackage, you can see that 0.8.0 to 0.8.0.2 are specifically _not_ preferred
23:59:16 <athan> Or wait, shoot nevermind
23:59:37 <athan> I guess there's no value in between those exclusive inequalities my bad
23:59:49 * hackagebot servant-purescript 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/servant-purescript-0.1.0.1 (eskimo)
