00:00:42 <jle`> join (computeP <$> computeP x) should be safe, i think
00:01:00 <jle`> when you runIdentity it
00:05:20 <AbelianGrape> jle`: Were you going to explain what happens when you runIdentity it?
00:06:16 <jle`> ah that was meant to be ".... is safe, i think, when you runIdentity it"
00:09:15 <AbelianGrape> Doesn't that just boil down to regular function application though? I.e. nested calls to computeP?
00:20:14 <dwynwen_ddlleyw> Does haskell run on the JVM?
00:21:57 <Sinestro> oh my god ghc is doing horrible things to my computer trying to build libraries rn
00:22:26 <Sinestro> put together the parallel stack jobs and they're using 8 GB and would probably use more if it wasn't slowed down by swapping
00:22:47 <skrio> dwynwen_ddlleyw: No. There is a haskell project for this summer to port a small subset to target the jvm, and there is also Frege (haskell-clone for the jvm), but there is no current support for the jvm as target.
00:23:31 <dwynwen_ddlleyw> Aww
00:26:51 <banacorn> Is it possible to use GHC-8.0 or GHC-7.10 with base-4.7 (which comes with GHC 7.8)? 
00:27:05 <banacorn> We are preparing for a summer school (FLOLAC), and we want none of the scary "foldable" stuff when showing students the type of "foldr" which comes with newer base prelude
00:28:31 <koz_> Is there a way to make MonadRandom spit out a pair of Ints within a particular range, aside from 'manually make each one and pair them up'?
00:29:56 <jle`> koz_: it could if you wrote a Random instance for (Int, Int)
00:30:18 <jle`> there isn't one in the library but i don't see any reason why there couldn't be one
00:30:30 <koz_> jle`: But I still need to constrain both of the outcomes to a specific range.
00:30:34 <koz_> never mind, I'll write a subroutine.
00:30:36 <jle`> yeah, that's what randomR is for
00:30:46 <jle`> er, getRandomR
00:31:00 <jle`> getRandomR :: (MonadRandom m, Random a) => (a, a) -> m a
00:31:14 <jle`> so if (Int, Int) is an instance of Random, you can provide the upper and lower range
00:31:35 <jle`> getRandomR ((-10,-10), (10,10)) :: MonadRandom m => (Int, Int)
00:31:52 <koz_> jle`: Ah, I see.
00:31:59 <koz_> I guess I could cook an orphan instance just this once.
00:32:34 <jle`> in practice i'd probably just use replicateM or liftA2 or <*>/etc.
00:32:44 <koz_> replicateM gives me a list not a pair.
00:32:48 <koz_> But the lift idea is curious.
00:32:50 <koz_> Thank you.
00:32:55 <jle`> (,) <$> randomR (-10,10) <*> randomR (-10,10)
00:33:29 <jle`> or liftA2 (,) (getRandomR (-10,10)) (getRandomR (-10,10))
00:33:47 <jle`> it's also likely that you don't want the tuple itself, but are planning on using the results
00:33:51 <koz_> jle`: Yeah, I went with the first one.
00:33:54 <koz_> And yes.
00:33:56 <koz_> That's exactly the plan.
00:34:03 <jle`> in which case you can just directly use the function, f <$> getRandomR ... <*> getRandomR ...
00:34:10 <koz_> So I guess I could just do that straight-up, yeah.
00:34:20 <jle`> or liftA2 f, etc. :)
00:34:42 <jle`> hooray for applicatives
00:34:56 <koz_> Truly, applicatives solve all ills.
00:35:02 <koz_> World hunger? Applicative.
00:35:06 <jle`> remember that replicateM is no more than, say, (\x y z -> [x,y,z]) <$> blah <*> blah <*> blah
00:35:15 <koz_> Finanicial crisis? Applicative.
00:35:17 <jle`> except with a variable number of items
00:35:26 <koz_> jle`: Yeah, that makes sense.
00:35:37 <koz_> How long will it be before this becomes obvious to me *before* I have it explained?
00:35:39 <jle`> people do actually solve financial problems with applicatives, heh
00:35:46 <koz_> jle`: Edward Kmett, lol.
00:35:51 <koz_> (although he probably uses lenses)
00:36:12 <jle`> a lot of the lens library relies on applicatives
00:36:34 <jle`> applicatives go hand-in-hand with the theory of traversals.  they're great! :D
00:36:41 <jle`> can't believe it took us so long to think of them
00:36:51 <koz_> jle`: Amazing things take a while.
00:36:55 <jle`> we had to go thorugh embarassing things like Arrow first
00:37:01 <koz_> I'm starting to spot when I need traverse, lol.
00:37:15 <koz_> I think I spent the *longest* time trying to make sense of what it did, and now it just kinda ... fits.
00:37:27 <jle`> heh, yeah, that's often how it goes
00:37:41 <koz_> Although half the time, it's turning lists of Maybes inside out.
00:38:00 <jle`> i think the thing that finally made traversables click for me was traversals of Map's
00:38:12 <jle`> how i can turn a `Map k (IO a)` into a `IO (Map k a)`
00:38:36 <jle`> execute all of the IO actions each of the keys contain, and re-construct the map, assocating all of the keys to their results
00:38:58 <jle`> it was a moment where I was like "whoa this is power"
00:40:04 <koz_> Yeah - for me, that 'power moment' was when I had a bunch of constructor functions which Maybe'd out.
00:40:08 <koz_> And I had three layers of that shit.
00:40:22 <koz_> And then I was all like 'hmmm, traverse seems to fit ... oh woah, it actually does!'.
00:40:46 <jle`> :o
00:41:34 <koz_> jle`: This is a thing I had to write: 'return $ fromJust (xs >>= (traverse rowToClause >=> mkForm))'
00:41:40 <koz_> (ignore the fromJust noise)
00:43:02 <koz_> I don't ever recall having to use fish *and* traverse in the same pipeline before.
00:43:12 <jle`> heh
00:43:29 <koz_> Well, right fish I guess.
00:43:33 <koz_> As opposed to left fish.
00:45:06 <seivan_> Could someone help me figure out how IndentParser needs (State SourcePos) I thought it already had a SourcePos inside its State?
00:46:24 <lpaste> koz_ pasted “jle`: How would I write this?” at http://lpaste.net/168586
00:47:30 <whodisbe> :t (>>= (fromMaybe (return Nothing)))
00:47:32 <lambdabot> Monad m => m (Maybe (m (Maybe a))) -> m (Maybe a)
00:47:51 <jle`> koz_: you probably have to generate them one at a time, and adjust the boundary/range for the second one?  if i understand what you're trying to do correctly
00:48:11 <whodisbe> Okay, so that's join for MaybeT m a without the wrappers and unwrappers, how do I fix those?
00:48:48 <koz_> jle`: I'm not sure I got it across right. Basically, I wanna have a tuple (from, to) such that, if we do '(g from) <= (g to)', I get 'True', but still have them generated using ranI.
00:48:49 <jle`> whodisbe: fix?
00:49:02 <jle`> whodisbe: if you want to make it more clear, just use do notation and pattern matching :)
00:49:30 <whodisbe> jle`: Well, newtype MaybeT m a = {runMaybeT :: m (Maybe a))
00:49:35 <whodisbe> jle`: Well, newtype MaybeT m a = {runMaybeT :: m (Maybe a))}*
00:49:49 <jle`> koz_: without knowing more about 'g', i can probably only suggest that you repeat that operation until the condition is satisfied :P
00:50:02 <whodisbe> So I haven't really gotten it down, because I've left out the wrappers and unwrappers
00:50:18 <jle`> join :: MaybeT m (MaybeT m a) -> MaybeT m a
00:50:27 <jle`> join m = do
00:50:40 <jle`> er, join m = MaybeT $ do ...
00:50:42 <jle`> etc.
00:50:49 <jle`> the types should guide you :)
00:51:02 <jle`>   x <- runMaybeT m
00:51:07 <jle`>   case x of ...   etc.
00:51:52 <jle`> i might have messed up the types for that slightly, but hopefully you get the picture :)
00:52:03 <whodisbe> Wait, doesn't that already require MaybeT to be a monad? In case it wasn't clear, I'm trying to write the definitions of mu & eta for MaybeT
00:52:19 <jle`> that doesn't require MaybeT to be a monad
00:52:24 <jle`> it only requires 'm' is a monad
00:52:30 <whodisbe> oh
00:52:55 <whodisbe> ohh
00:53:07 <jle`> the 'do ...' block is in 'm'
00:53:17 <whodisbe> yeah, let me try it out, thanks
00:53:34 <jle`> because runMaybeT :: MaybeT m a -> m (Maybe a)    -- the result is an action in 'm'
00:56:53 <whodisbe> jle`: I feel like I have to rethink everything now, once I have "(>>= (fromMaybe (return Nothing)))" this down, isn't there a simple way to just tack on the wrapping?
00:59:04 <jle`> maybe if you're a mechanical computer
00:59:09 <jle`> probably not if you're a human :p
00:59:23 <jle`> `(>>= (fromMaybe (return Nothing)))` is barely readable/understandable
00:59:28 <jle`> and by barely i mean "not at all"
00:59:48 <whodisbe> but... it's so neat, and no pattern matching
01:00:01 <jle`> reminds me of read-only regex's i used to write for perl scripts
01:00:11 <jle`> so clean, so efficient...completely unmaintainble :)
01:00:59 <jle`> clever code tends to be the least readable/maintainble code
01:01:08 <jle`> and the most difficult code to edit/improve
01:01:24 <whodisbe> but if I end up pattern matching, doesn't that defeat the purpose of having monadic abstraction?
01:01:37 <jle`> the benefit is for the user of your MaybeT type
01:01:51 <jle`> the monadic abstraction benefits the user of MaybeT
01:01:53 <whodisbe> Oh right, I'm creating the abstraction here
01:01:55 <jle`> mhm.
01:02:09 <whodisbe> thanks a lot
01:02:12 <jle`> np!
01:11:31 <maybefbi> does ghc-mod look inside $(...) calls when resolving types of expressions defined inside $(...)
01:17:00 <lpaste> koz_ pasted “Can I write this more nicely?” at http://lpaste.net/168589
01:24:08 <lyxia> koz_: [from, to] <- sort <$> sequence [ranI, ranI]
01:34:33 <koz_> lyxia: That'll work - I'll just have to munge it into a pair afterwards.
01:34:40 <koz_> Or heck, not even that.
01:34:42 <koz_> Derp.
01:34:44 <koz_> Thank you!
01:43:23 * hackagebot stack-run 0.1.0.7 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.7 (yamadapc)
01:48:22 <tsahyt> When using -fprof-auto, are cost centres created for branches in a case statement? I've got names like foo.\ and foo.\.\ here. foo = bar >>= \case {...}. So I was thinking that foo.\ denotes the actual case statement and the .\.\s denote the individual cases. Is that correct?
01:49:02 <quchen> "-fprof-auto 	Auto-add SCCs to all bindings not marked INLINE"
01:49:16 <tsahyt> On a related note, can I somehow get GHC to output the code with the annotated SCCs?
01:50:12 <tsahyt> or alternativelty find bindings by their cost centre numbers retroactively?
01:50:36 <quchen> I don't think case has "bindings", but I'm not sure.
01:51:45 <tsahyt> so there wouldn't be an easy way to find out how much time is spent in each case?
01:52:01 <tsahyt> or more importantly how many allocations are made
01:52:03 <quchen> tsahyt: You could add cost centres manually.
01:53:46 <tsahyt> I think I'll have to. By far the biggest cost centre is still (>>), especially in terms of allocs. I suppose this means that the left hand side isn't evaluated eagerly enough. The problem is that I don't know *where*.
01:54:38 <jophish> @tell radoye sorry, I went home last night and didn't see your last message
01:54:38 <lambdabot> Consider it noted.
01:54:52 <jophish> @tell radoye PM me again when you're next about :)
01:54:52 <lambdabot> Consider it noted.
01:56:28 <tsahyt> it's still strange though because the monads should be strict enough. I'm using Control.Monad.State.Strict and IO, and all my IO functions that I actually use are strict in their arguments
01:59:34 <tsahyt> Also I've noticed that about half of my sparks get GC'd. I suppose my parallelism might be too fine-grained
02:09:53 <quchen> GC'd sparks should mean that you're forking things that you never need afterwards, no?
02:10:13 <quchen> So it's more a problem of redundant parallelism, and not granularity
02:12:07 <tsahyt> quchen: I'm evaluating a function on each element of a list and then sort it afterwards. I'd be surprised if the value wasn't needed in order to sort it.
02:12:39 <quchen> Hm.
02:12:49 <quchen> Okay, then I've got GC'd sparks wrong.
02:13:31 <tsahyt> I remember something about a stackoverflow answer that stated that the sparks can get evaluated through the normal (sequential) flow of the program before they're converted in parallel and will then get GC'd
02:13:42 <tsahyt> I'm not sure if I remember this correctly, or whether that was correct to begin with though
02:15:13 <ongy> I am trying to clean up some TemplateHS code and the main thing I want to do, is moving to the [||] notation. Now I have a situation where I have a variable of type Exp, but I can't use that in the quasi quotation. Is there a way to use an Exp built previously?
02:23:02 <fr33domlover> ongy, you mean something like using $() inside [||] ?
02:23:39 <ongy> fr33domlover: testing, just found the same syntax reading doc
02:24:10 <fr33domlover> ongy, iirc you can use $() and [||] inside each other recursively :P
02:33:24 * hackagebot ig 0.8 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.8 (cdepillabout)
02:35:49 <Tene> Hey, any chance there's a convenient way I can download all of a stackage snapshot in advance, for offline use?
02:38:25 * hackagebot http-client 0.4.30 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.30 (MichaelSnoyman)
02:48:25 * hackagebot http-conduit 2.1.11 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.11 (MichaelSnoyman)
02:53:36 <maybefbi> is there a f :: (Functor f) => Q [Dec] -> f [Decl] or  g :: Q [Dec] -> [Decl] such that Dec = Language.Haskell.TH.Dec and Decl = Language.Haskell.Exts.Annotated.Syntax.Decl
02:53:59 <maybefbi> my problem right now is pretting printing template haskell gives me unique names with integer suffixes
02:54:24 <maybefbi> if i can Q [Dec] to [Decl] then I can avoid the suffixes
03:02:14 <lyxia> maybefbi: if you don't want suffixes, shouldn't you use mkName?
03:02:50 <maybefbi> i didnt know this. where is mkName documented?
03:03:13 <maybefbi> lyddonb, 
03:03:16 <maybefbi> lyxia, 
03:04:28 <lyxia> maybefbi: http://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH.html#v:mkName
03:05:36 <maybefbi> hmm interesting
03:15:05 <nmattia> has anybody managed to derive an instance for a multi-param type class using GeneralizedNewtypeDeriving?
03:15:28 <nmattia> from the docs, it looks like you can, assuming that your newtype-wrapped type is the last param in the type class
03:15:55 <lyxia> right
03:15:58 <nmattia> in my case I'm trying to derive Field1, Field2, ... from lens for a newtype Foo = Foo (Bar, Baz)
03:16:31 <nmattia> but FieldX is of the form FieldX s t a b, where s, t are my wrapped type :(
03:17:30 <lyxia> indeed that's unfortunate
03:18:02 <nmattia> it sure is
03:18:26 * hackagebot instance-control 0.1.1.1 - Controls how the compiler searches for instances using type families.  https://hackage.haskell.org/package/instance-control-0.1.1.1 (lazac)
03:33:26 * hackagebot references 0.3.1.1 - Selectors for reading and updating data.  https://hackage.haskell.org/package/references-0.3.1.1 (lazac)
03:38:26 * hackagebot references 0.3.2.0 - Selectors for reading and updating data.  https://hackage.haskell.org/package/references-0.3.2.0 (lazac)
03:44:00 <ongy> hm, more template haskell: in [d||], can I somehow do [d| funName handle = ...|] where funName is some variable (String/Name)?
03:45:07 <lyxia> Nope.
03:45:52 <hawk78> http://lpaste.net/168595 Why isn't this code able to correctly sum of the user input?
03:46:23 <lyxia> what input did you give it and what output did you get
03:47:58 <ongy> lyxia: so I have to use the FunD constructor? What's the reason for this limitation?
03:49:02 <hawk78> lyxia: The output is "random" e.g. input is 1 -> 1 -> 1 -> 1 -> 1 -> 1   output is 1 -> 1 -> 2 -> 1 -> 2 -> 3
03:50:03 <lyxia> ongy: I'm not sure why either.
03:50:22 <hawk78> I think there is a problem in the recursive zipWith
03:50:35 <maybefbi> lyxia, thanks btw. it works now 
03:50:37 <lyxia> hawk78: ah I see what it does. There's a duplication of actions.
03:50:38 <maybefbi> runQ $ dataD (pure []) (mkName "B") [] [] []
03:50:42 <lyxia> maybefbi: yw
03:51:50 <lyxia> hawk78: your code is equivalent to return 0 >> (return 0 >>= action1) >> (return 0 >>= action1 >>= action1) >> (return 0 >>= action1 >>= action1 >>= action1) >> ...
03:53:07 <hawk78> lyxia: I see!!!
03:53:33 <hawk78> lyxia: tnx. I'll try to "fix my brain"
03:59:13 <Cale> hawk78: I think what you wanted to write was just to replace the  return $ x + y  at the end of the definition of action1 with  action1 (x + y)
03:59:26 <Cale> hawk78: and then just run  action1 0
04:01:18 <obihann> very noob question and I'm not even sure what to google, but given a list like this [('A', "ABC"), ('B', "BCD")] what is the actual type or structure being stored in the list?
04:01:40 <oherrala> :t [('A', "ABC"), ('B', "BCD")]
04:01:41 <lambdabot> [(Char, [Char])]
04:01:42 <obihann> I recognize the list, and of course the char and string/char-array, but the (A,B) structure
04:02:19 <Cale> obihann: that's a pair
04:02:29 <obihann> ahhhh, thanks so much!
04:02:39 <oherrala> or tuple
04:02:49 <oherrala> tuple of two elements aka pair
04:03:17 <obihann> perfect!
04:04:05 <oherrala> :t lookup
04:04:06 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:04:59 <obihann> so given a list of pairs, I could probably find a specific one perhaps by using a filter and either fst or snd depending on what part of the pair I am matching?
04:05:37 <oherrala> > lookup 'B' [('A', "ABC"), ('B', "BCD")]
04:05:39 <lambdabot>  Just "BCD"
04:05:48 <obihann> sweet
04:05:50 <obihann> thanks so much
04:05:56 <oherrala> np :)
04:06:48 <obihann> one more question :) I've been reading about if then else and how its considered "syntactic sugar", is it generally perferred to write something like if _ a : ... and use pattern matching?
04:07:06 <obihann> which from my very limited understanding is also a tyle of monad
04:07:18 <obihann> or is if then else safe / common to use 
04:07:22 <oherrala> use whatever you think produces cleaner result
04:07:46 <oherrala> sometimes it's pattern matching (maybe with case), sometimes it's if-then-else
04:08:19 <hawk78> Cale: can I fix it withpout changing action1?
04:09:22 <Cale> hawk78: Sure, you could write the loop separately.
04:19:10 <netsu> hello. Could you suggest, please, where in project most proper place for development tools haskell packages dependencies? Stack.yaml file, or separate target in cabal file, or somewhere else? And how to avoid installation of it by stack in production?
04:21:00 <rcat> not sure what you mean, but I always add the usual .cabal file listing all the dependencies and a stack.yaml with particular settings to make sure stack compiles as well
04:21:04 <rcat> netsu: ^
04:21:48 <oherrala> project should have .cabal. stack.yaml is secondary and just help with cabal.
04:22:27 <netsu> rcat: I mean tools like hoogle, ghc-mod, etc. It unnecessary in production, but I need it in stack bundle
04:23:09 <netsu> ping
04:23:13 <netsu> rcat: I mean tools like hoogle, ghc-mod, etc. It unnecessary in production, but I need it in stack bundle
04:23:48 <netsu> rcat: I mean tools like hoogle, ghc-mod, etc. It unnecessary in production, but I need it in stack bundle
04:24:05 <oherrala> you can have that kind of things in your global stack.yaml
04:24:56 <netsu> oherrala: so how to avoid installation those packages on prod. server?
04:25:37 <oherrala> netsu: are you familiar with $HOME/.stack/global-project/stack.yaml ?
04:25:46 <oherrala> just don't have that in your production server :)
04:27:37 <netsu> oherrala: hm, global project? Thanks. That's what I looking for. But just in case: how to do it for local per-project tools?
04:29:51 <netsu> oherrala: for example, for different project I could want to have tools from different lts
04:38:08 <lyxia> You can create a .yml file for each project
04:43:36 <netsu> lyxia: thanks, on #haskell-stack suggested me just use extra-deps and after stack install anyway it will not be installed
04:43:55 <dysfun> anyone know of a module for parsing length prefixed strings? that is 4 byte ints followed by a payload
04:44:41 <tdammers> dysfun: attoparsec?
04:45:12 <dysfun> that was my immediate thought too, but if it's there, i didn't see it
04:46:33 <tdammers> hmm, looks like you're right
04:47:01 <dysfun> it has the primitives for reading bytes, so maybe you know how to turn those into numbers?
04:47:41 <tdammers> http://hackage.haskell.org/package/attoparsec-binary-0.2/docs/Data-Attoparsec-Binary.html
04:47:44 <tdammers> this one looks promising
04:48:15 <tdammers> size <- fromIntegral <$> anyWord16le -- or -be as the case may be
04:48:17 <dysfun> aha, anyWord32?e look perfect
04:48:26 <tdammers> and then simply:
04:48:30 <tdammers> str <- take size
04:48:38 <tdammers> (from core attoparsec)
04:48:43 <dysfun> thanks :)
04:48:50 <tdammers> that gives you a bytestring, not a string, but I suspect that's what you want
04:48:58 <dysfun> indeed :)
05:09:10 <dysfun> tdammers: fmap AC.take $ fromIntegral <$> anyWord16le
05:09:17 <dysfun> pretty neat huh?
05:10:01 <tdammers> hehe
05:10:16 <tdammers> I'd actually prefer explicit do notation in this case
05:10:57 <dysfun> i follow the principle if it fits on a unix line (80 chars), it's probably simple
05:13:11 <fuzzy_id> how do i turn off that input gets "echoed" (to implement password queries)
05:13:25 <fuzzy_id> … on unix
05:13:31 <tdammers> :t (.) . (.) -- I rest my case
05:13:33 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:13:55 <srhb> fuzzy_id: hSetEcho, I think
05:14:09 <srhb> @index hSetEcho
05:14:09 <lambdabot> GHC.IO.Handle, System.IO
05:14:15 <srhb> fuzzy_id: ^
05:14:35 <fuzzy_id> yep, that's it
05:14:39 <fuzzy_id> thanks!
05:19:14 <dysfun> tdammers: okay, well turns out it was the header-inclusive length, so i had to write it out with the do to make it tidy again
05:26:20 <defined> So, I had a thought. If an image is a map from R2 to R4, then image is a function, right? If so, what about storing images not as pile of 4-byte chunks, but rather as partial function?
05:26:50 <tdammers> dysfun: strictly speaking, you could have thrown in something like (- 4) .
05:27:07 <earthy> defined: that is a well known representation, yes
05:27:26 <dysfun> tdammers: i tried that but it caused very strange errors so i just gave up
05:27:43 <seivan_> Does anyone know if you can replicate the Indentation parsers in Parsec?
05:27:48 <tdammers> dysfun: you have to compose it in at the right level of fmap :P
05:27:59 <defined> earthy: Are there any implementations?
05:28:48 <earthy> defined: yes, but I can't think up a name or ref at the moment
05:31:09 <earthy> http://conal.net/papers/bridges2001/bridges-highres.pdf
05:31:17 <earthy> see, I knew it was Conal :)
05:32:22 <earthy> http://www.acooke.org/pancito-code/
05:35:29 <defined> earthy: Thanks for the info
05:39:18 <defined> earthy: Yeah, Pancito is exactly what I imagined.
05:39:38 <defined> preflex: earthy++
05:40:04 <defined> it didn't seem like it did anything =\
05:47:43 <marrrk> Hey, I'm trying to do this in Scala but maybe you can still help me? Let's say I have an Either and I would like a lens for some nested thing in the right part that doesn't explode when the value is actually left?
05:49:22 <Boomerang> marrrk: I think Either is a Functor on right
05:49:32 <Boomerang> > (+2) <$> Left 2
05:49:34 <lambdabot>  Left 2
05:49:36 <Boomerang> > (+2) <$> Right 2
05:49:37 <bennofs> marrrk: you're looking for a Prism or a Traversal instead of a Lens (if you're talking about the lens package)
05:49:38 <lambdabot>  Right 4
05:49:40 <marrrk> (I would actually like the same for the left part)
05:49:54 <marrrk> bennofs: Which one then?
05:49:57 <marrrk> Prims or Traversal?
05:50:06 <bennofs> marrrk: any Prism is also a Traversal
05:50:16 <bennofs> marrrk: but not any Traversal is also a Prism. 
05:50:25 <marrrk> I see.
05:50:31 <bennofs> marrrk: Prism also lets you "construct" a value
05:50:41 <marrrk> So I guess I should try with Traversal and see if that's enough.
05:50:58 <bennofs> > Left 3 ^? _Left  -- this works for any "Traversal" 
05:51:00 <lambdabot>  Just 3
05:51:25 <bennofs> > review _Left 3 -- this requires prism, because it "turns the traversal around" and constructs a value instead of getting one out
05:51:27 <lambdabot>  Left 3
05:52:22 <marrrk> So you get a maybe?
05:52:36 <bennofs> marrrk: yeah because the value might not be a Left
05:52:47 <marrrk> Yeah, alright I see
05:53:03 <bennofs> > (over _Left (+3) (Left 3), over _Left (+3) (Right 3)) -- if you modify, only if it matches the value is modified
05:53:04 <lambdabot>  (Left 6,Right 3)
05:53:30 * hackagebot timelens 0.2.0.0 - Lenses for the time package  https://hackage.haskell.org/package/timelens-0.2.0.0 (OmariNorman)
05:53:53 <glaukon> {- > method 1  <interactive>:42:1:     No instance for (X a0) arising from a use of ‘method’     The type variable ‘a0’ is ambiguous     Note: there are several potential instances:       instance X Char -- Defined at ImplicitTypes.hs:10:10       instance X Int -- Defined at ImplicitTypes.hs:7:10     In the expression: method 1     In an equation for ‘it’: it = method 1  <interactive>:42:8:     No instance for (Num a0) 
05:54:19 <marrrk> bennofs: So wait over swallows the Maybe and just doesn't modify in case it's Nothing?
05:56:42 <bennofs> marrrk: yes, over works like fmap in that regard. 
05:56:49 <glaukon> I get "No instance for (X a0) arising from a use of ‘method’" error for the folllwing code: class X a where method :: a -> Int, instance X Int where method _ = 1, instance X Char where method _ = 2, method 1
05:56:59 <bennofs> marrrk: fmap (+3) (Left 4) also does not change the value in the Left, because fmap doesn't "match"
05:58:31 * hackagebot ghc-simple 0.4 - Simplified interface to the GHC API.  https://hackage.haskell.org/package/ghc-simple-0.4 (AntonEkblad)
05:58:33 * hackagebot timelens 0.2.0.2 - Lenses for the time package  https://hackage.haskell.org/package/timelens-0.2.0.2 (OmariNorman)
05:58:36 <marrrk> Okay, I think I get it.
05:58:54 <marrrk> Thank you so much. Now I need play with it!
06:00:26 <geekosaur> glaukon, (1) please use lpaste.net instead of jamming all of that into irc unreadably (2) typeclasses are not resolved based on what instances exist, so the polymorphic value (1 :: Num a => a) will not pick the Int instance. you must either specify (1 :: Int) or define an instance for (Num a => a) --- and the latter would overlap every other instance, so don't do it
06:02:53 <glaukon> geekosaur, sorry i am behind a firewall and cannot use lpaste.net or similar.
06:08:19 <glaukon> geekosaur, how do I make an instance for (Num a => a)?
06:09:03 <bartavelle> glaukon, you shouldn't, as geekosaur said
06:09:54 <glaukon> bartavelle: ok, but I would like to try it anyway.
06:13:19 <glaukon> bartavelle: or, is there any other way of forcing ghc to select one instance when it sees the value of bare 1?
06:14:51 <marrrk> bennofs: Is it possible to compose Lenses with Prisms?
06:15:01 <bennofs> marrrk: yes, the result will be a Traversal
06:15:24 <marrrk> As long as I can easily modify something deeply nested I am fine with that :)
06:16:20 <bennofs> > over (_1._Left._2) (+4) (Left (1,2), Nothing) 
06:16:21 <lambdabot>  (Left (1,6),Nothing)
06:21:00 <bartavelle> glaukon, I don't think there is a satisfactory solution to the problem you stated
06:21:22 <bartavelle> the simplest workaround is to annotate the type of your numerical value
06:23:00 <mtesseract> Hello
06:24:08 <phanimahesh> !hi
06:24:45 <phanimahesh> oops, no welcome-bot here. :P Wrong channel.
06:32:05 <glaukon> bartavelle: what about telling ghc to select the best match? is there such a pragma?
06:32:59 <bartavelle> not to my knowledge, but i am hardly an expert
06:34:14 <tomjaguarpaw> glaukon: This is destined for a big mess.  What exactly are you trying a achieve?
06:34:38 <hawk78> foldActions'' start actions = foldl (>>=) (return start) actions
06:35:16 <hawk78> ^^^ this does loop forever but 
06:35:19 <hawk78> foldActions' start (x:xs) = x start >>= flip foldActions' xs
06:36:21 <hawk78> ^^^ works, is the foldActions' function present in some library by a different name?
06:37:12 <hawk78> Cale: is this what you meant by "loop separately"?
06:37:30 <tomjaguarpaw> hawk78: Surely you can write that as a foldr
06:37:42 <Cale> I mean just write something like  loop x = do y <- action1 x; loop y
06:39:13 <hawk78> tomjaguarpaw: foldr does not work for infinite lists as well
06:39:19 <tomjaguarpaw> hawk78: Sure it does
06:40:15 <tomjaguarpaw> :t foldr (>=>) return
06:40:17 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
06:41:01 <tomjaguarpaw> :t let foldActions' start (x:xs) = x start >>= flip foldActions' xs in foldActions'
06:41:03 <lambdabot> Monad m => a -> [a -> m a] -> m b
06:41:12 <tomjaguarpaw> I wager these are the same thing
06:43:00 <Cale> hawk78: It might also be worth mentioning that 'fix' can sometimes be handy in this regard, if you were going to just define a recursive function simply to loop and use it once immediately after
06:43:41 <Cale> hawk78: You can instead write something like   fix (\loop n -> do ... loop (n+1)) 0
06:45:03 <dnadams> When would I want to use fgl vs Data.Graph?
06:47:37 <glaukon> tomjaguarpaw: edsl for an assembly language in haskell. would like for the syntax to match as closely as possible to the original asm syntax.
06:48:27 <ironChicken> dnadams: Data.Graph doesn't have weighted graphs
06:50:47 <FjordPrefect> ironChicken: Ah, okay. I don't think I'll need weighted graphs. Is there any other distinguishing factor? 
06:51:44 <bartavelle> glaukon, you want to write a generic "mov" function that would accept registers, memory addressing and direct values for exemple ?
06:51:47 <bartavelle> example
06:52:24 <ironChicken> FjordPrefect: actually i haven't used fgl so i can't really comment further
06:52:31 <hawk78> Cale: thank you, I did not know about fix. But why does foldActions'' loop forever (implemented as a left or right fold does not make any difference)
06:53:51 <bartavelle> glaukon, if so, mov could have type "mov :: MovOperand -> MovOperand -> Instruction" and you would write "instance Num MovOperand"
06:53:54 <tomjaguarpaw> hawk78: foldl does not terminate until it's consumed the whole input list.
06:54:14 <tomjaguarpaw> If your input list is infinite it will never terminate
06:54:24 <tomjaguarpaw> A foldr version should work though
06:55:07 <hawk78> tomjaguarpaw: it does hit the stack limit
06:56:30 <hawk78> I would like to generalize my foldActions over a foldable or traversable. Is it possible? 
06:56:46 <tomjaguarpaw> hawk78: Yes, I gave you the code above.
06:56:57 <tomjaguarpaw> :t foldr (>=>) return
06:56:58 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
06:58:06 <Cale> yep
06:58:42 <Cale> hawk78: foldl will never work on an infinite list
06:58:47 <Cale> @src foldl
06:58:47 <lambdabot> foldl f z []     = z
06:58:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:58:58 <tippenein> Any suggestions how to migrate from a Person column to a PersonId column with persistent? I cooked up a one-off migration thing, but it seems really hacky and I never want to do it again
06:59:06 <Cale> ^^ as you can see, it greedily applies itself to new arguments until it reaches the end of the list
06:59:10 <Cale> @src foldr
06:59:10 <lambdabot> foldr f z []     = z
06:59:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:59:22 <Cale> whereas foldr passes control to f in the nonempty list case
07:00:20 <hawk78> Cale: tomjaguarpaw: but neither termintes in my case, right?
07:00:32 <Cale> huh?
07:00:43 <Cale> The foldr version works in your case
07:01:33 <hawk78> GHC stack-space overflow: current limit is 33624 bytes.
07:02:00 <Cale> hawk78: You're using the  foldr (>=>) return  version?
07:02:18 <Cale> That shouldn't incur much stack usage...
07:02:36 <hawk78> foldActions''' start actions = foldr (=<<) (return start) actions
07:02:48 <Cale> no
07:03:03 <Cale> foldActions''' start actions = foldr (<=<) return actions start
07:03:56 <tomjaguarpaw> >=>
07:04:02 <Cale> er, yes, oops
07:04:06 <Cale> (>=>)
07:05:12 <Cale> and note that you still can use this to write things which perform poorly -- if you somehow avoid evaluating the function argument and accumulate large expressions
07:06:27 <Cale> e.g. foldr (>=>) return (repeat (\x -> return (x+1))) 0 -- is a bad idea, because you're going to accumulate an unevaluated expression in memory which looks like (...((0+1)+1)...)+1
07:06:40 <Cale> but if you print the number it's fine
07:06:55 <hawk78> Yup, I print it
07:07:57 <tomjaguarpaw> Note that 'foldr (=<<) (return start) actions' definitely can't work (well) because it has to walk to the end of the list before it starts running its actions.
07:08:07 <hawk78> Ok, I still don't understand why       foldActions''' start actions = foldr (=<<) (return start) actions            loops
07:08:30 <Cale> hawk78: Well, let's look at the expression which this generates
07:08:46 <Cale> suppose we have  actions = [f0, f1, f2, f3, ...]
07:09:14 <Cale> then the result of this is going to look like f0 =<< (f1 =<< (f2 =<< (...)))
07:09:42 <Cale> If the list is infinite, the return start is never going to get used
07:10:25 <Cale> and executing f =<< x involves first executing x
07:11:12 <Cale> So executing f0 =<< (f1 =<< ...) means we first have to execute f1 =<< (f2 =<< ...)
07:11:32 <Cale> but then similarly we can't begin to do that without first executing f2 =<< (f3 =<< ...)
07:11:38 <Cale> and so on
07:12:53 <Cale> moreover... well, let's see
07:13:08 <Cale> > (return =<< undefined) `seq` ()
07:13:09 <lambdabot>      No instance for (Monad m0) arising from a use of ‘=<<’
07:13:10 <lambdabot>      The type variable ‘m0’ is ambiguous
07:13:10 <lambdabot>      Note: there are several potential instances:
07:13:16 <Cale> > (return =<< undefined :: IO ()) `seq` ()
07:13:17 <lambdabot>  ()
07:13:30 <Cale> ah, okay, so it really isn't a problem with evaluation
07:13:37 <Cale> Just execution
07:18:01 <hc> Hi!
07:18:33 <hc> I'm looking for a printf library that can take inputs like "Hello %(what)s" and read the %(what)s part from a (Map :: (Text, Text))
07:25:44 <hawk78> Cale: I'm silent because I'm reasoning... thank you in the meanwhile.
07:26:22 <hawk78> I'm trying to do the same unfolding with the fish-using version
07:28:50 <sdx23> hc: as in Data.Text.Template?
07:31:06 <hawk78> Cale: The fish versoin gives             return ( >=> f1 (f2 >=> (...foo))) 0
07:31:53 <tomjaguarpaw> Not quite
07:31:56 <Cale> hawk78: huh?
07:32:00 <tomjaguarpaw> The return should be on the right hand side
07:32:06 <Cale> hawk78: The return goes unused in the infinite list case
07:32:30 <Cale> hawk78: foldr f z xs replaces every occurrence of (:) in xs with f, and any occurence of [] with z
07:32:47 <Cale> In an infinite list, there is no [], so you don't use z
07:33:18 <hawk78> Cale: nice mnemonic rule, thanks!
07:35:49 <hawk78> tomjaguarpaw: Cale: so it is             (f0 >=> f1 (f2 >=> (... return))) 0              ? Right?
07:37:05 <hawk78> or also             (f0 >=> f1 (f2 >=> (... (foo >=> return)))) 0              
07:39:05 <Cale> you missed a fish
07:39:13 <Cale> and there's no return
07:39:20 <Cale> unless the list is finite
07:39:43 <Cale> but yeah, the return is at the end in the finite case
07:39:52 <hawk78> foo == f_infinite
07:40:55 <hawk78> does that make sense? It is there but actually it will never execute
07:41:09 <Cale> no, there is no f_infinity :)
07:41:25 <Cale> Every element of an infinite list occurs at some finite index
07:42:40 <hawk78> Cale: ok
07:43:32 <hawk78> One more question, where is the help for using the lambdabot? What tool is it using behind the scenes?
07:43:53 <Cale> lambdabot has some built-in help
07:44:03 <Cale> but it's otherwise not very well documented
07:44:09 <Cale> (at least as far as I know)
07:44:19 <Cale> What tool is it using to do what?
07:46:57 <hawk78> I would like to have a "lambdabot" like shell running on my machine... can ghci do that?
07:47:25 <tomjaguarpaw> hawk78: Why not just use ghci?
07:48:30 <hawk78> tomjaguarpaw: How do enable the same features? like @src fix
07:48:50 <hawk78> @src fix
07:48:50 <lambdabot> fix f = let x = f x in x
07:49:06 <coda> so ...
07:51:12 <tomjaguarpaw> hawk78: Ah, GHC doesn't support that as far as I know.
07:52:53 <geekosaur> hawk78, there is the goa package which hooks lambdabot into ghci
07:53:03 <geekosaur> however, lambdabot is a beast to build at the best of times
07:53:50 <nitrix> Very few have succeeded :P
07:54:13 <nitrix> hawk78: @src pulls definitions from a local database on lambdabot's server.
07:54:22 <nitrix> hawk78: It's not even from the hackage source files.
07:54:43 <hawk78> :-(
07:54:48 <hawk78> What a pity!
07:55:07 <hawk78> no stack install lambdabot magic :-( :-(
07:56:17 <buglebudabey> i have a program that takes Core code and compiles it into instructions like pushint, mkap, unwind, etc. (I also have an evaluator) How can I take it a step further and translate it into native code so it compiles to that?
07:58:37 <buglebudabey> to generate a .o file maybe
08:00:57 <buglebudabey> or link with llvm
08:01:02 <buglebudabey> i'll take anything guys
08:04:32 <dysfun> buglebudabey: you have your own abstract instructions?
08:06:00 <buglebudabey> dysfun yes, the program is represented as a graph with each node being an application, and i have a stack of pointers that i run the instructions on
08:06:25 <buglebudabey> dysfun i have pushint, pushglobal, push, mkap, slide, and unwind as my instructions
08:06:42 <dysfun> and what do you want to compile to?
08:07:43 <buglebudabey> i guess as far as i can, this is my first compiler so i'm not exactly sure what is best. i'd like to be able to generate assembly, or bytecode and link it up to make an executable
08:08:38 <dysfun> well you have to pick a platform first. i'd recommend llvm over a specific architecture's assembler
08:09:18 <dysfun> but the problem is simple enough. you transform your AST for your lang into an AST for the target and then serialise it
08:09:32 <dysfun> doing it efficiently is quite another thing
08:09:59 <buglebudabey> dysfun i'm just kind of stuck between this IL stage and the rest, would choosing llvm make it any less of a compiler in terms of learning the process or having something to show?
08:10:32 <dysfun> not really. llvm is very low level. it's like a cross language assembler really
08:10:40 <dysfun> cross platform*
08:10:56 <buglebudabey> i don't need it to be too efficient the first time around. i'm following spj book implementing functional languages and just want to take it that extra step
08:11:08 <buglebudabey> the book does most of the work
08:11:20 <dysfun> well, choosing LLVM means it'll work out not too slow from the get-go
08:11:31 <dysfun> because it has a whole optimisation infrastructure
08:11:59 <buglebudabey> would llvm still be alright even though i keep all the pointers in a stack, and the whole thing is a state transition machine?
08:12:24 <buglebudabey> i don't do register allocation or anything like that
08:12:50 <dysfun> LLVM uses SSA form. basically everything looks like variable assignment
08:13:05 <dysfun> and then later in the process it does register allocation
08:14:03 <dysfun> i'd normally advise against it for a beginner, but haskell's llvm tools suck a lot less than most
08:14:29 <buglebudabey> alright, so if i can translate my IL into another AST and then to LLVM i should be all set? where does generating an executable come in?
08:14:54 <dysfun> once you've got llvm code generated, you just feed it into the llvm compiler
08:15:30 <dysfun> if you choose to not use llvm, you generate assembly language and feed it into an assembler
08:16:20 <buglebudabey> but i'd have to do a lot more work if i didn't use llvm, right?
08:16:43 <buglebudabey> all the stuff that llvm does i'd have to do by hand?
08:17:13 <dysfun> llvm does optimisation and generates platform specific machine code
08:17:53 <dysfun> so you're passing up on all that optimisation. which includes complicated things like register assignment
08:18:09 <dysfun> if you wanted to go down that path, you'd just use the stack for the first pass
08:18:22 <buglebudabey> first pass?
08:18:32 <dysfun> your first attempt at generating code
08:18:53 <buglebudabey> ah i see
08:21:07 <buglebudabey> dysfun right now what i do is generate the core program as AST1, then I generate an initial state for the st machine (which includes code, the pointer stack, a node heap with the names of things and their address, and a map of all the global functions and values), then i have a virtual machine that evaluates it all
08:21:27 <buglebudabey> where in this process would i link to llvm? after evaluation?
08:22:43 <dysfun> you're mixing up interpreter and compiler here
08:23:05 <saml> that's a good mix
08:23:54 <dysfun> what's the point of generating machine code if every cycle is going to be interpreted?
08:25:55 <buglebudabey> im not sure, the book says that the GCode can be translated into machine code, so i guess i don't need the evaluation step
08:26:43 <dysfun> no. you replace the 'evaluate' step with a 'transform' step
08:26:51 <mrd> if I have multiple executables defined in a cabal file and I only want to build a single one of them using "stack build target1", stack still seems to force me to build all of targets. Is there a way around this problem?
08:27:17 <mrd> (particularly annoying since the other targets take a very very long time to build)
08:27:21 <dcoutts> mrd: cabal build target1   (or cabal new-build target1)
08:27:31 <buglebudabey> transform into llvm IR?
08:27:56 <dysfun> and then into machine code
08:28:33 <buglebudabey> what does the llvm translate it into, or is that what it does
08:29:01 <dysfun> whatever you tell it to translate it into, but i'm guessing you're wanting "machine code for the machine i'm on"
08:29:44 <buglebudabey> yeah most likely, although i'd like it to be cross platform
08:30:15 <dysfun> if by that you mean 'x86 and arm, maybe mips', llvm has you covered
08:30:36 <dysfun> most of the other backends aren't well-maintained
08:31:10 <mrd> dcoutts: cabal isn't very happy -- complains about GHC_PACKAGE_PATH being incompatible. I'm not sure it's set up to be used independently of stack anymore.
08:31:57 <mrd> dcoutts: I assume the 'package database' it wants is somewhere under .stack-work/ ?
08:32:05 <dcoutts> mrd: right, it's set up to be used by itself
08:35:15 <buglebudabey> dysfun alright, thank you very much for the help
08:35:28 <dysfun> yw. take a look at the llvm-general package
08:37:13 <buglebudabey> dysfun i don't generate all of the instructions (GCode) at once. should I, now that i need to translate it to llvm? currently, i unwind the stack as i evaluate
08:37:34 <dysfun> ah, yes
08:38:06 <buglebudabey> thanks
08:38:22 <mrd> dcoutts: okay, it seems that stack is using a version of cabal that it has stashed away inside of ~/.stack/setup-exe-cache, the one that is installed globally is not going to work
08:38:33 <mrd> that is why I am getting weird error messages
08:39:11 <mrd> I am going to see if I can get it to switch over to using the system cabal
08:40:29 <dcoutts> mrd: I think we may be talking at cross purposes, stack does not use 'cabal' the program (it uses Cabal lib to compile the Setup.hs). I was just pointing out that the 'cabal' program does have the feature you want.
08:42:25 <mrd> when I toggle verbose mode for stack I see this: "....stack/setup-exe-cache/x86_64-linux/setup-Simple-Cabal-1.22.5.0-ghc-7.10.3 build target1 target2 target3 ..."
08:42:47 <mrd> so I can see that despite asking stack to only build 1 target, it still inserts all 3 into the cabal build command
08:43:27 <mrd> or the Setup.hs buikld command
09:33:38 * hackagebot ChasingBottoms 1.3.1 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1 (NilsAndersDanielsson)
09:38:41 <hwkng> if I have something like "data Foo = Foo { a :: Int, b :: String, c :: Int }, it's easy to store in a Relational DB. However, if I have something like "data Foo = Circle (Double, Double) Double | Rect Double Double Double Double" -- then it's not clear how to store union types as rows
09:38:47 <hwkng> is it even possible at all to store union types as rows?
09:39:20 <Cale> hwkng: This is just something which sucks about essentially all SQL databases.
09:39:41 <hwkng> Cale: even if we dropped "SQL", and just went back to 'pure relational theory', is there a way to handle it?
09:39:56 <Cale> yes
09:40:00 <hwkng> Cale: so I'm willing to drop postgres / mysql / sqlite -- and I'm curious, can *relational theory* dela with this?
09:40:03 <hwkng> Cale: cool, how so?
09:40:31 <hwkng> Cale: how do we 'map to rows' when the 'two branches of the union look different' ?
09:41:00 <Denommus> luite: ping
09:41:25 <Denommus> or even for everyone: which HTTP client library can I use in GHCJS?
09:41:26 <bjs> hwkng: possibly have multiple relations that match up the type, one for each union?
09:41:30 <Denommus> Wreq doesn't seem to work
09:41:46 <Rembane> hwkng: Could you turn it inside out and put each constructor in its own table?
09:41:50 <Cale> hwkng: You would want to make tables for each of the constructors Circle and Rect, and then a table for Foo with a column whose entries are drawn from the disjoint union of the rows of the Circle and Rect tables (i.e. it's a foreign key into one or the other and we know which)
09:42:48 <hwkng> bjs , Rembane , Cale : so the above would be somethin glike 3 tables, "Table Circle = (id :: Int), (x :: Double), (y:: Double), (r :: Double)", "Table Rect = x1 x2 y1 y2", and "Table Foo = pointers to either Rect or Circle" ?
09:43:04 <Cale> hwkng: yeah
09:44:06 <Rembane> hwkng: +1
09:44:18 <bjs> hwkng: yeah
09:44:33 <hwkng> thanks; I'll ponder more on this
09:44:50 <bjs> hwkng: it's not entirely pleasant but most things don't take as kindly to sum types as haskell does
09:44:53 <Rembane> hwkng: Or just put everything in a blob in one table like Wordpress does. :D
09:45:27 <Cale> hwkng: What people usually end up doing is approximating A + B with (1+A) * (1+B) = 1 + A + B + A*B
09:45:54 <Cale> i.e. instead of having one column whose type is the disjoint union of the foreign keys of Circle and Rect, you have two nullable columns
09:46:18 <Cale> and just hope that no bug ever puts something in both or neither
09:47:22 <Cale> This is a terrible solution because in the event of such a bug, the fix is very expensive, and involves arbitrarily large amounts of work (e.g. making phonecalls to sort out which thing was correct, to people who might not even know the answer)
09:47:46 <hwkng> yeah
09:47:51 <hwkng> I'd really like to do this in a typesafe way
09:48:38 * hackagebot ddate 0.1.0.0 - Discordian Date Types for Haskell  https://hackage.haskell.org/package/ddate-0.1.0.0 (hellerve)
09:49:22 <Cale> Another is just not to recognise that Circle and Rect have anything to do with each other at the DB level
09:50:35 <hwkng> so I'm writing an svg editor
09:50:41 <hwkng> and I'd like a table of 'shapes in this diagram'
09:59:23 <tommd> and...
09:59:48 <bus_nolrai> That would be a table where each row is a diagram? 
10:03:10 <bus_nolrai> Anyone mind if I muse out loud on some CS stuff? 
10:05:41 <glguy> Someone will let you know if it strays too far off topic
10:08:35 <bus_nolrai> Okay, so I was (starting to ) building a compiler from a typed linear language to Franklin gates, inspired by that never finished preprint about additive and multiplicative inverse types. 
10:11:45 <bus_nolrai> Only, I realized there can't be an actual way to interpret recursive types as a set of wires + interpretation because a given set of wires can only have a finite number of states, no? 
10:13:43 <bus_nolrai> Even if you have wires that go "backwards".
10:21:49 <bus_nolrai> So I guess I've just rediscovered that you need a tape to be Turing complete. X/
10:25:10 <bus_nolrai> So I guess I see two options, which I maybe want both, either add in a heap to my model or encode a finite "prefix" of a recursive type, and translate everything. 
10:25:43 <bus_nolrai> Okay, those are both doable I think. 
10:29:26 <bus_nolrai> Though if I add a heap, I think just making up some sort of reversible von Newman cpu and compiling to assembly for that might make more sense. Or I could take on a programming project with some sort of point. >_<
10:31:56 <dysfun> bus_nolrai: nah that would be selling out
10:32:36 <bus_nolrai> :p
10:42:02 <bus_nolrai> Okay, I think additive inverses are still encodable as just wires ruining left to right. (Wires don't actually have a direction, but we need to assign one to type them). But cycles don't actually cause iteration like we want them to. I think. 
10:45:07 <bus_nolrai> Wait, no..I think those are (counter the papers intuition) actually multiplicative inverses. 
10:48:40 <bus_nolrai> Yeah, both ends of a u turn exist at once. Additive inverses would only allow one or the other at once. So an additive inverse is a latch. 
10:53:40 <bus_nolrai> Of course we still have the issue that nat is 1 / 0. Which is wierd. 
10:53:59 <aaronm04> Hi, how do I fix an error like this from stack install: "ghc: out of memory (requested 2097152 bytes)"
10:54:18 <glguy> aaronm04: How much memory do you have?
10:54:24 <aaronm04> not sure, this is inside docker
10:54:30 <aaronm04> so it's not an internal ghc limit?
10:54:55 <monochrom> no
10:55:10 <aaronm04> could I work around it by making ghc and/or stack be more efficient with memory?
10:55:13 <monochrom> the message means ghc asks the OS for 2GB and the OS denies
10:55:24 <glguy> 2GB or MB?
10:55:25 <aaronm04> it's asking for about 2MB
10:55:29 <monochrom> err, 2MB
10:55:39 <glguy> That's the 2MB straw that broke the camel's back
10:56:00 <monochrom> I don't know docker
10:56:31 <glguy> aaronm04: It would be a pretty involved work around, but if you wanted to get involved in GHC development and start working on memory efficiency that's certainly one route
10:56:45 <RoboTrafficCop> Can I get some Repa help? I'm trying to write a simulator for a 2D environment with wave behavior. I tested the algorithm with numpy and it works great, but is slow. I decided to try Repa for performance. The way this environment works is I have two two-dimensional matrices. One contains the value field, the other is the velocity field. At each iteration, the value field changes the velocity field 
10:56:51 <RoboTrafficCop> (through e.g. surface tension as a physical example) and then the velocity field changes the value field (movement). So I have two separate Repa matrices, each DIM2, and at each step I generate two new matrices with the same shape. The type of the function is basically "step (Array D DIM2 Double, Array D DIM2 Double) -> (Array D DIM2 Double, Array D DIM2 Double)". If I call e.g. "computeP $ step $ 
10:56:57 <RoboTrafficCop> delay initial", performance is fine. But if I add more steps, a la "computeP $ step $ step $ step $ delay initial", performance gets *exponentially* worse. My suspicion is that somehow the delayed representation doesn't play well with multiple inter-dependent matrices. What should I do to get good performance here?
10:57:17 <rainnnnnnnnnnnn> hello I am trying to define a function in ghci for practice if I have a data type:
10:57:21 <RoboTrafficCop> THere should be a "::" after "step"
10:57:50 <aaronm04> glguy: well, I'm just trying to get hledger-web running on a VPS...
10:58:07 <buglebudabey> is there a way to give custom parse error messages / line numbers with happy?
10:58:28 <glguy> aaronm04: It's possible that stack is building multiple packages at once and that it would be able to succeed if you were building them serially
10:58:40 * hackagebot ec2-unikernel 0.9 - A handy tool for uploading unikernels to Amazon's EC2.  https://hackage.haskell.org/package/ec2-unikernel-0.9 (AdamWick)
10:59:01 <aaronm04> glguy: I think the solution is to add swap
10:59:10 <glguy> aaronm04: ok
10:59:20 <aaronm04> glguy: but how do I force stack to build serially?
11:00:06 <Zemyla> I have a question. How do I derive the catamorphism for a GADT?
11:00:37 <glguy> aaronm04: I don't know. With cabal it's the -j1 flag. You might check the docs or maybe someone else knows
11:00:39 <monochrom> should be similar to ADT
11:01:35 <glguy> buglebudabey: sure, you can make the error production do whatever you want, and you can also add extra productions to your grammar that are error cases and report a more interesting error there, to
11:01:49 <acowley> aaronm04: There is a #haskell-stack channel, too
11:01:59 <ClaudiusMaximus> RoboTrafficCop: afaik you should computeP each step into unboxed arrays, rather than computing a chain of steps - delayed representation is just that, you want to force the computation each step
11:02:18 <glguy> buglebudabey: I do both here: https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Parser.y
11:02:34 <buglebudabey> thanks glguy, i was looking for a good example ;)
11:06:01 <aaronm04> acowley: thanks!
11:06:16 <Zemyla> monochrom: Specifically, I'm trying to derive the GADT for the following type:
11:06:18 <aaronm04> glguy: the problem was fixed by adding 4 GB swap (which is probably overkill)
11:06:43 <glguy> aaronm04: oh, good news :)
11:06:51 <monochrom> does it thrash badly?
11:07:12 <glguy> Is there good thrashing?
11:07:26 <aaronm04> well, the build step for regex-tdfa-1.2.2 (the package with the problem) took a long time
11:07:28 <monochrom> no, but there is not-bad thrashing
11:07:31 <Zemyla> glguy: At a metal concert?
11:07:45 <aaronm04> so there probably was thrashing
11:07:48 <glguy> Can I respond with a question again?
11:08:16 <Zemyla> But anyways, this is the type I'm talking about: data FreeArrow p a b where { Arr :: (a -> b) -> FreeArrow p a b; ACons :: (a -> Either e (c, w)) -> p c d -> FreeArrow p (Either e (d, w)) b -> FreeArrow p a b }
11:08:54 <Zemyla> It actually winds up being a free ArrowChoice.
11:12:56 <monochrom> Zemyla: OK, what have you tried?
11:15:43 <monochrom> ok I see, "d" may get into the way
11:17:35 <monochrom> but only type-wise. it can probably be solved by rank-2 types.
11:18:52 <Zemyla> Well, I start with (forall e w u v x y. (u -> Either e (x, w)) -> p x y -> q (Either e (y, w)) v -> q u v) -> (forall x. (i -> x) -> q x y -> (y -> j) -> z) -> (a -> i) -> q i j -> (j -> b) -> FreeArrow p a b -> z.
11:20:28 <monochrom> no, not that many foralls
11:20:57 <Zemyla> I need that many in the cons.
11:21:55 <Zemyla> And I want to be able to use the catamorphism as a Church-encoded version so I can have O(1) (.).
11:26:35 <glguy> Zemyla: I think you'll need to do something like this: http://lpaste.net/168613
11:27:12 <glguy> Zemyla: the key being that you'd provide an operation to transform the cases where you've got polymorphic recursion in your types
11:27:22 <glguy> in this code that's h
11:27:54 <glguy> This is a smaller example but I think it suffers from one of the same complications
11:36:40 <Zemyla> glguy: Well, I admit I'm modeling it somewhat after this free applicative https://www.eyrie.org/~zednenem/2013/06/freeapp-2
11:48:08 <mnoonan> is fficxx the best option for generating bindings to a C++ library? or the *only* option?
11:51:41 <luite> Denommus: I'm not aware of any multi-backend HTTP libs. in a browser you'd have to go through XHR anyway, which would limit your functionality. are you using this in a browser or with node.js?
11:53:42 * hackagebot aeson-pretty 0.8.0 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.0 (FalkoPeters)
11:53:44 <acowley> mnoonan: There's hoppy, too
11:55:13 <mnoonan> acowley: thanks, I hadn't come across that one yet!
11:55:37 <acowley> mnoonan: I've not used it and am only aware of it because I saw the hackage update notice recently!
11:59:22 <Welkin> I keep running into errors like these
11:59:23 <Welkin> http://lpaste.net/831849076910718976
11:59:47 <Welkin> does the problem have something to do with my types being too general?
12:00:39 <Welkin> I could replace all the `a`s with Int and it would work
12:01:52 <lyxia> Welkin: you put (a :: a) in a queue, so it's a queue of a. But in go you're using this queue like a queue of Bin a.
12:02:33 <Welkin> thank you lyxia :)
12:02:48 <Welkin> although I ran into a similar problem before with another program I wrote
12:02:53 <Welkin> maybe I had the same issue
12:03:03 <lyxia> I guess that was it.
12:04:41 <Welkin> although the logic is wrong now
12:05:47 <Welkin> is there a better way to do this kind of recursion?
12:06:03 <Welkin> I've just been passing around a tuple with all the necessary data inside and then pulling out the result at the end
12:06:31 <lyxia> for this function the queue is overkill
12:06:33 <Welkin> I could use state I suppose
12:07:18 <Welkin> isn't a queue necessary for level order tree traversal?
12:08:31 <lyxia> ah nevermind I got confused
12:09:35 <lyxia> just replace the first two lines with levelOrder a = reverse ... ?
12:10:34 <lyxia> the empty case is incomplete, you're throwing away the remaining queue
12:11:28 <nshepperd_> Does anyone know if IVars (as in the ivar-simple package) have a more common name? I reached for them at work as my standard concurrency solution, but understandably my coworkers said "wtf is an Ivar". And i can't link them to the standard explanation of IVars because.. that name doesn't seem to be used anywhere?
12:12:53 <Cale> IVar is the standard name for what they are...
12:13:05 <nshepperd__> Ping
12:14:18 <Welkin> haha, I had Empty produce [] instead of `result`
12:14:58 <Welkin> thanks lyxia 
12:15:05 <Welkin> I'm out of it today
12:16:15 <Cale> nshepperd__: I guess you could call it a write-once (read many) variable?
12:16:29 <Cale> nshepperd__: but IVar is a pretty standard name
12:17:49 <Cale> nshepperd__: The "I" is for "Immutable"
12:18:38 <statusfailed> What do people generally use for (postgresql) database migrations?
12:19:00 <Zemyla> And I just realized, looking back over a pull request I made, that a type I made to store the intermediate results of a traversal is pretty much exactly the same as edwardk's Bazaar, except explicit instead of implicit.
12:19:21 <dolio> Where are the standard explanations of concurrency things?
12:19:29 <Cale> statusfailed: We've been using groundhog for that purpose at Obsidian.
12:19:49 <nshepperd__> Hmm, maybe *I* need to be the person to write "introduction to IVars" then
12:20:10 <Cale> statusfailed: It's pretty limiting when it comes to what queries it lets you express nicely, but it *is* pretty good for the automated migration stuff.
12:20:59 <Cale> I seem to recall that the names IVar and MVar came originally from Concurrent ML
12:21:39 <Cale> hmm
12:21:41 <Cale> maybe not?
12:22:12 <dolio> Do they really require an introduction or tutorial?
12:34:17 <AzureStigma> can haskell be used for webserver backend
12:34:23 <Welkin> yes
12:34:38 <Welkin> yesod, scotty, spock, servant, snap
12:34:58 <AzureStigma> so it can do everything ruby and ruby rails can?
12:35:10 <Welkin> yes
12:35:15 <Welkin> and more
12:35:27 <AzureStigma> wait your not pulling my leg are you
12:35:28 <maerwald> the ecosystem probably is not that big
12:35:38 <maerwald> well, it is definitely not that big
12:35:43 <Welkin> I have never run into trouble
12:35:49 <Welkin> there is always a library for what I need
12:36:09 <Welkin> if thee is no web API binding (for twilio, or mailgun for example) I write my own in a few minutes using servant-client
12:36:12 <nshepperd_> I don't know, i did think that a comment explaining what an Ivar is would be self explanatory
12:36:18 <AzureStigma> so is there anything ruby and rails can do that haskell get?
12:36:29 <Welkin> AzureStigma: no
12:36:46 <AzureStigma> sorry i meant cant* instead of get 
12:37:18 <jle`> no, but "the ability to do what ruby and rails can do" is probably not a good standard for how useful something is, heh
12:37:36 <jle`> literally any language can do that :p
12:37:41 <jle`> s/literally/nearly
12:37:46 <dysfun> any *turing complete* language
12:37:56 <Welkin> brainfuck can do it
12:37:57 <maerwald> AzureStigma: not sure, but some things are barely maintained/supported or just outright suck, because again: the ecosystem is not comparable
12:38:12 <Welkin> maerwald: that is not true
12:38:20 <maerwald> Welkin: it is.
12:38:21 <AzureStigma> no its not that its just im a sys admin and want to be well rounded and was wondering what languages i would need 
12:38:24 <Welkin> at least for the basics, everything is up to date and well-maintained
12:38:29 <Welkin> and being improved daily
12:38:33 <AzureStigma> to compliment each other mainly 
12:38:39 <maerwald> Welkin: I'm not talking about the basics. You seem biased.
12:38:40 <dysfun> why should a sysadmin be writing webservices?
12:38:57 <AzureStigma> no thats not it however i just want to be well rounded for my own interests
12:39:14 <Welkin> haskell is a great language to learn
12:39:23 <dysfun> well it's going to take a bit more than writing a few programs to be able to honestly claim that ;)
12:39:28 <Welkin> very fun and you will look at programming in ways you have never thought about it before
12:39:45 <AzureStigma> like if i learn assembly, c, and haskell is there anything else thats needed to learn?
12:39:51 <Welkin> you can use haskell for shell scripting too
12:39:53 <AzureStigma> and also sql i forgot that
12:40:19 <Welkin> assembly, c, and haskell pretty much cover everything, except a lisp perhaps
12:40:19 <dysfun> you should also learn a lisp and a math language (clojure and julia?)
12:40:27 <jle`> it depends on what you need to do! :D
12:40:31 <Welkin> lol dysfun not clojure
12:40:38 <Welkin> probably scheme or racket
12:40:38 <adarqui_> any idea why warnings aren't triggering an exit/error with -Werror enabled? pattern match inexhaustive, redundant imports etc.. tons of warnings, but, ghci/ghc isn't error'n
12:40:53 <adarqui_> it works on my other libraries
12:41:05 <dysfun> i'm actually quite fond of clojure, but the problem is it's dangerously production ready so noone will trust it
12:41:08 <AzureStigma> well there are so many languages to do stuff python ruby node.js angular etc..
12:41:27 <AzureStigma> so I want to just learn the bare minimum while mastering the ones i learn
12:41:35 <maerwald> AzureStigma: honestly, if you are not overly enthusiastic on learning a new FP language, don't bother with haskell, because it requires a lot of energy
12:41:48 <Welkin> AzureStigma: maerwald is just grumpy
12:41:53 <maerwald> Welkin: ?
12:42:00 <AzureStigma> but i need need guidance on the limtations of haskell so i can fill in the gaps of other languages to cover what haskell doesn
12:42:00 <maerwald> can you please stop making statements about me
12:42:25 <dysfun> you're not going to hit the limitations of haskell as a beginner
12:42:25 <dysfun> ]
12:42:56 <maerwald> AzureStigma: it's not something you can learn in a week or two, so it requires a lot of commitment
12:42:58 <AzureStigma> I was thinking of learning assembly, c, haskell, sql, ruby, rails but if haskell can do what ruby and rails can i can scratch those out
12:43:08 <AzureStigma> I agree and I plan on giving it all
12:43:19 <maerwald> if you're just diving through different languages, haskell is not a particularly good choice
12:43:31 <Welkin> I disagree with maerwald 
12:43:57 <Welkin> most languages people use are just a variation of C
12:43:58 <AzureStigma> but i want to learn haskell because its awesome and i want to be able to think differently then obj oriented programmers
12:44:02 <Welkin> haskell is very different
12:44:08 <kadoban> AzureStigma: Any language can do what all of the others can, as a general rule. The question is how suitable they are and what they'll teach you when you learn them. You should learn several languages, of different semantics, yes.
12:44:31 <bjs> AzureStigma: haskell is a fun, interesting but wildly different language from the other options in your list. Learn it if you want, or don't learn it if you don't want to
12:44:31 <maerwald> Welkin: weird, you basically gave an argument FOR what I said.
12:44:33 <dysfun> i'd be inclined to say learn FP before others if possible
12:44:36 <Jinxit> java, C, haskell, prolog
12:44:37 <Jinxit> have fun
12:44:41 <kadoban> AzureStigma: By the way, I wouldn't start with assembly or C, learn those later if you want to.
12:44:45 <dysfun> because then you don't have to untrain bad habits
12:44:46 <adarqui_> ??? can't use -Werror with ghci? The following GHC options are incompatible with GHCi and have not been passed to it: -Werror
12:45:16 <AzureStigma> but if haskell can do alot of the things i dont see a need to wasting time on java and ruby
12:45:20 <AzureStigma> perhaps javascript yes
12:45:49 <kadoban> AzureStigma: You're still focusing on what a language can do and not … all of them can do everything. You could just use assembly if you wanted to, for everything. You'd hate life, but you could do it.
12:45:50 <dysfun> you can generate javascript from haskell too
12:45:51 <bjs> AzureStigma: first off, it's never "wasting time" to learn other languages if you plan on doing a lot of programming
12:46:01 <adarqui_> odd, never noticed.. i guess ive always used Werror with stack build then
12:46:19 <Welkin> being able to read/understand a language is much easier than being able to write programs using it
12:46:28 <sm> DHH just gave a great interview on software engineering radio. "Ruby is clay, java etc. are iron"
12:46:37 <AzureStigma> well the thing with me is instead of learning a lot of programming i want to be really good in the ones i do learn
12:46:40 <sm> (and haskell must be steel)
12:46:42 <bjs> AzureStigma: all of these languages are general purpose and can do everything, they just have very different approaches to it -- with haskell probably being the furthest from the "norm" in your list
12:47:00 <maerwald> AzureStigma: is this just a hobby?
12:47:01 <RoboTrafficCop> AzureStigma: That's foolish. Being "good" at a language is the easy part. The hard part is the more generalizable theory.
12:47:29 <Welkin> @where learnhaskell -- AzureStigma start here
12:47:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:47:33 <RoboTrafficCop> The possible exceptions are languages like Haskell and Coq where being "good" at them boils down to learning math at some sufficiently advanced level
12:47:37 <Jinxit> AzureStigma: what's your end goal here?
12:47:46 <AzureStigma> well this initially started when my friend had said i was a janitor for programmers being a sysadmin
12:47:52 <maerwald> :D
12:47:54 <Welkin> lol
12:47:54 <RoboTrafficCop> Lol
12:47:54 <sm> ha!
12:47:57 <Welkin> never heard that one
12:48:04 <AzureStigma> so then i decided im going to learn and master languages 
12:48:06 <kadoban> RoboTrafficCop: Learning haskell requires almost no extra math compared to other languages.
12:48:19 <sm> put that friend in charge of something nasty
12:48:28 <RoboTrafficCop> kadoban: Being really good at haskell requires fairly advanced type theory, category theory, etc. Being proficient at it does not.
12:49:06 <dysfun> no, not really. it means know the concepts and match up types
12:49:13 <kadoban> RoboTrafficCop: "really good" must mean something odd then. I do well in haskell, as well as I do in any other language, and I know no essentially no CT and extremely little type theory.
12:49:13 <AzureStigma> like i do devops and ansible, puppet, chef were all except one of them written in ruby
12:49:17 <RoboTrafficCop> kadoban: Perhaps a better way of saying this is that being an intermediate haskell programmer involves roughly as much knowledge as being a master python programmer
12:49:27 <AzureStigma> why isnt alot of those written in haskell
12:49:28 <RoboTrafficCop> kadoban: Doing well is not the same as beign really goood.
12:49:28 <kadoban> RoboTrafficCop: I'd disagree with that as well.
12:49:30 <johnw> RoboTrafficCop: even SPJ knows relatively little about Category Theory.  It's not a requirement by any means for excelling at Haskell.
12:49:38 <kadoban> RoboTrafficCop: Okay … define "really good"?
12:49:43 <sm> AzureStigma: one of those has a piece being rewritten in haskell (puppet ?)
12:49:47 <maerwald> AzureStigma: haskell is not in the top10 of programming languages, really
12:49:51 <Welkin> AzureStigma: haskell is not mainstream
12:49:52 <AzureStigma> WHAT
12:49:53 <AzureStigma> REALLY
12:49:56 <AzureStigma> OMG
12:49:58 <dysfun> sm: and a lot being rewritten in clojure
12:50:03 <AzureStigma> haha you just made my day sm
12:50:13 <sm> http://hackage.haskell.org/package/language-puppet is what I mean
12:50:18 <AzureStigma> thats the thing i dont wnt to be mainstream
12:50:32 <maerwald> AzureStigma: so if you need something to put on your CV, haskell isn't a particularly good choice :P
12:50:34 <sm> s/rewritten/supported/
12:50:44 <AzureStigma> nah i have my red hat certs for that
12:50:47 <dysfun> are you sure? as being definitely anti-mainstream myself, wouldn't you rather be able to take money for working on things?
12:50:53 <sm> (but the guy blogging about it seemed to be talking about rewriting)
12:51:31 <mizu_no_oto_work> maerwald: mainstream and "good for your CV" aren't really the same thing
12:51:35 <RoboTrafficCop> kadoban: Someone who's really good can lecture me for hours about indexed bifunctors in the dual space of... and now I'm lost. Note that I'm not claiming to be really good, but I do know some people who are.
12:51:40 <maerwald> mizu_no_oto_work: haskell is neither
12:51:47 <sm> AzureStigma: http://hackage.haskell.org/package/propellor is another interesting haskell package in that space
12:52:00 <bjs> AzureStigma: how much programming have you done in the past?
12:52:16 <AzureStigma> 0 7 years ago i did java i remember nothing
12:52:17 <kadoban> RoboTrafficCop: You've just defined "really good at haskell" to be exactly people who are instead knowledgeable about CT and type theory. You're just begging the question with the definition.
12:52:25 <AzureStigma> was for a college class
12:52:29 <maerwald> you're lucky if your they even know what haskell is. Most add "haskell, ocaml" etc on their job description just to pull in more people, but have no idea what it is.
12:52:52 <maerwald> and the job isn't going to be haskell either, lol
12:52:56 <RoboTrafficCop> kadoban: You asked my for my definition, there it is. If you don't like it, that's fine
12:53:06 <AzureStigma> like ppl know what erlang is 
12:53:12 <maerwald> AzureStigma: they do
12:53:14 <bjs> AzureStigma: hmm, i'm going to be honest -- i've no idea how coming into haskell as your first big language would be like
12:53:20 <kadoban> No, I don't think it's a good definition of what it means to be good at haskell.
12:53:21 <bjs> AzureStigma: but if it's your first, it doesn't matter
12:53:21 <maerwald> erlang was created for a very practical purpose
12:53:26 <dysfun> AzureStigma: if you want to play with erlang, try lisp flavoured erlang :)
12:53:40 <kadoban> (since it says nothing about haskell)
12:53:56 <AzureStigma> but i wanted to learn haskell them assembly and c lol
12:53:59 <RoboTrafficCop> kadoban: How would you define it? one of Haskell's significant contributions to programming is its rigorous basis
12:53:59 <johnw> RoboTrafficCop: but those things aren't Haskell; I think the people you admire are computer scientists and mathematicians
12:54:21 <bjs> AzureStigma: those are 3 languages that could each take years to learn well
12:54:32 <RoboTrafficCop> johnw: And that's what it takes to be good at Haskell, a language that lends itself to manipulating such mathematical structures
12:54:33 <kadoban> RoboTrafficCop: I would define being really good at haskell as being able to write correct, efficient, maintainable programs in haskell for a variety of purposes.
12:54:50 <kadoban> Probably left out a few adjectives, but something like that.
12:54:54 <RoboTrafficCop> kadoban: That's just being a decent programmer. It's not haskell-specific or particularly impressive.
12:55:07 <kadoban> RoboTrafficCop: It's of course haskell specific … haskell is right in the definition.
12:55:30 <RoboTrafficCop> I think your bar for "really good" is much lower than mine is the issue here.
12:55:36 <bjs> AzureStigma: i'd recommend pick-one {haskell, python, java} to learn because they all have really good communities and usable fairly stable languages :)
12:55:42 <RoboTrafficCop> What you're describing sounds like "proficient".
12:55:57 <AzureStigma> i pick haskell
12:55:57 <dysfun> what you're talking about sounds like "lost in academia, can't write real code"
12:56:05 <johnw> RoboTrafficCop: I'd argue that it has nothing to do with "being good at Haskell", but since this isn't an objective criterion, there's really no reason to believe either of us :)
12:56:11 <RoboTrafficCop> Just because one knows theory doesn't mean they feel the need to always apply it.
12:56:20 <kadoban> RoboTrafficCop: Your bar strikes me as something like defining "really good at cooking" as being a master chemist.
12:56:25 <RoboTrafficCop> Well, yeah
12:56:28 <maerwald> kadoban: heh
12:56:33 <RoboTrafficCop> That sounds about right
12:56:34 <bjs> dysfun: lost in academia and inability to write real code merely have very strong correlation and i refuse to believe there's any form of causation happening here :p
12:56:40 <RoboTrafficCop> the cooks I respect the most are molecular gastronomists
12:56:46 <maerwald> errr
12:56:51 <kadoban> Okay, well at least I understand your position I guess. I *strongly* disagree, but I appreciate you sharing.
12:56:55 <AzureStigma> so knowing haskell, javacript, sql would make me well rounded?
12:57:07 <maerwald> no idea what "well rounded" means
12:57:12 <RoboTrafficCop> AzureStigma: Throw a low-level language like C in there
12:57:14 <dysfun> AzureStigma: no. studying those and another 30 languages for the rest of your life will make you well rounded
12:57:24 <bjs> AzureStigma: making you well rounded, whatever that means, will take years and you'll learn far more than 3 languages when you get there
12:57:31 <bjs> AzureStigma: and you're certainly not going to decide those languages today :)
12:57:42 <AzureStigma> i was hoping to bjs
12:57:48 <AzureStigma> your making life to complicated 
12:57:50 <dysfun> just start with one and you'll figure out what to do along the way
12:58:03 <bjs> AzureStigma: no i believe you are, just pick a language and run with it
12:58:05 <dysfun> heh, you're making life too simple
12:58:05 <jle`> AzureStigma: i think it's probably easier to focus on the journey instead of the destination
12:58:14 <jle`> AzureStigma: you will never be finished being well rounded
12:58:16 <bjs> AzureStigma: everything else will fall into place as you go, trust me, we've all done this journey before :)
12:58:17 <kadoban> AzureStigma: Yeah, you should just pick a language, get started and decide later what else to learn, when you have a better base of knowledge to go from.
12:58:23 <jle`> AzureStigma: but haskell, etc. are good steps in the process of making yourself well-rounded
12:58:34 <jle`> don't be too concerned about that hypothetical state where you will "finish" becoming well-rounded
12:58:35 <AzureStigma> well i choose haskell , assmebly, and c but if i know those i cant do anything with web using it
12:58:54 <dysfun> haskell can do web stuff too
12:58:54 <maerwald> I'd say well-rounded means you know a lot of different paradigms, not just the amount of languages.
12:59:12 <jle`> AzureStigma: when you want to do web stuff, you'll learn what you need to do web stuff
12:59:16 <kadoban> AzureStigma: Actually you can, there's GHCJS, which can turn haskell into javascript code.
12:59:21 <maerwald> and that's rather hard to do. Most people end up in one paradigm they are particularly good at thinking
12:59:27 <dysfun> kadoban: and haste and fay
12:59:38 <jle`> it's sort of impossible to learn things and be well-rounded for the hypothetical "anything".  just learn things as you need them
12:59:49 <AzureStigma> well pl/sql are extras
13:00:12 <dysfun> you're missing a major problem: by the time you've finished learning your three languages, the industry has moved on a few years
13:00:16 <luite> everone try the new ghc-8.0 branch of ghcjs and tell me all your bugs :)
13:00:23 <jle`> luite: :D
13:00:30 <AzureStigma> deleted my ruby books
13:01:01 <bjs> AzureStigma: seriously, getting so caught up over the languages today won't help. Just go start reading a haskell tutorial and writing some programs
13:01:17 <AzureStigma> i bought chris allens book
13:01:26 <AzureStigma> looked reallly nice
13:01:40 <dysfun> you might also like learn you a haskell
13:01:45 <luite> jle`: there are probably a few integer-gmp things not quite right yet, since i also updated the integer-gmp lib to 1.0 and dropped the jsbn library in favour of my own bignat lib (although a few things are based on jsbn)
13:02:07 <luite> all in all it's quite a big update
13:02:15 <jle`> congrats :)
13:02:43 <AzureStigma> so between haskell, c and asssembly can i get a order to learn them at?
13:03:03 <bjs> AzureStigma: you could have one of us throw you a random ordering, but since you're sat in #haskell and already own a haskell book
13:03:08 <bjs> AzureStigma: i'd say ... start there?
13:03:18 <AzureStigma> thanks my good man!
13:03:28 <AzureStigma> hope you get bjs lol
13:03:30 <dysfun> learn haskell for
13:03:34 <dysfun> first
13:03:48 <bjs> dysfun: do you think it's harder to learn haskell after an imperative language?
13:03:51 <dysfun> yes
13:04:09 <kadoban> I would think it's easier, just not much easier.
13:04:23 <dysfun> i've learned 10 languages in the last 3 years and i get convinced that it becomes harder every time, not easier, provided you're going to a sufficiently different language
13:04:27 <kadoban> It's not as easy as learning another imperative language, which is what most people compare it with.
13:04:39 <bjs> dysfun: just hard to break mindsets?
13:04:44 <johnw> bjs: I'd say it's harder to learn haskell after learning a language whose operational semantics are so much a part of the language that you stop thinking about what things mean, and you focus instead on how they are accomplished by the compiler; this is hard thinking to undo
13:04:54 <kadoban> Really? I've found it easier as time goes on to learn more languages.
13:04:55 <dysfun> i like to think of it as untraining bad habits when you're moving from imperative to fp ;)
13:05:16 <johnw> because there are "imperative languages" modelled on pure functional language, in the form of patterns like State, that are not injurious to thinking at all
13:05:22 <AzureStigma> wait can haskell really be used for scripting though?
13:05:27 <johnw> yes, it can
13:05:28 <bjs> dysfun: hmm, i find it hard to context-switch between languages
13:05:38 <maerwald> johnw: mhh, reasoning about performance, laziness and so on also requires quite some compiler knowledge in haskell, no?
13:05:50 <johnw> maerwald: yes, but that's optimization, which is always hard
13:05:57 <AzureStigma> and for haskell programming do i have to use windows?
13:05:58 <dysfun> bjs: i've tended to learn languages that are very different from the last one i learned. as a side effect, i seem now to be able to switch between languages pretty easily
13:06:04 <AzureStigma> because I only use linux
13:06:07 <dysfun> absolutely not
13:06:13 <kadoban> AzureStigma: If anything the tooling is better on linux
13:06:17 <bjs> AzureStigma: sure you can use it to write scripts, no you don't have to use windows ( i don't )
13:06:44 <AzureStigma> i remember reading somewehre that said the tooling for haskell linux was outdate or something and it mainly used windows i cant remember
13:06:53 <johnw> maerwald: sometimes the best construction is simply awaiting a better compiler to express it :)  but the most efficient construction is much more bound to the capabilities of the compiler
13:06:58 <jle`> AzureStigma: hm, i'm not sure if anyone has ever said that ever
13:07:02 <dysfun> sounds like rubbish
13:07:04 <kadoban> AzureStigma: Naw, doesn't sound correct at all.
13:07:05 <johnw> look at how functional languages themselves were unrealistic until recently
13:07:09 <jle`> windows tooling has traditionally lagged behind linux/osx tooling
13:07:15 <jle`> for haskell
13:07:26 <AzureStigma> thanks idk maybe it was my imagination lol
13:07:46 <maerwald> johnw: well, to me the "I use haskell, because I don't need to understand the compiler" argument is already broken, which is sad
13:07:48 <hwkng> is there a way to tell 'stack repl' to put .dump-hi files in some build directory instead of in the same dir with the *.hs files ?
13:07:53 <kadoban> johnw: Recently like, 1958? ;)
13:08:29 <dysfun> well to be fair, the last few years have seen massive improvements in functional languages across the board
13:09:04 <AzureStigma> who knows maybe in the future having haskell in ur cv can be an awesome oppurtunity  
13:09:07 <maerwald> I like to learn languages, I don't like to learn oddities and pitfalls of compilers, though.
13:09:50 <kadoban> AzureStigma: Haskell has a pretty good reputation, and seems to be growing more popular in industry. It's not too bad of a bet.
13:10:05 <kadoban> Even if you don't use it in your job, it should still teach you things that are useful.
13:10:14 <dysfun> i think haskell has reached the point where it's a good bet for production
13:10:22 <maerwald> in C you can just code against the standard and then fingerpoint at people doing things wrong and be funny about stuff breaking, because it's not your fault, haha :P
13:10:25 <kadoban> I reason using haskell's type system even in other lanugages, because it's quite a bit better than … just about all of them.
13:10:55 <bjs> kadoban: i think eventually languages will move to a ML/Haskell style type system with lots of type inference, but not just yet
13:10:59 <EvanR> i use idrises type system
13:11:19 <dysfun> EvanR: how do you find idris for practical work?
13:11:21 <kadoban> Yeah I haven't learned idris yet, I probably should sometime.
13:11:22 <AzureStigma> I have a dream.. to be a sysadmin that programs in haskell xD
13:11:38 <maerwald> AzureStigma: most programmers don't even get there :o
13:11:43 <AzureStigma> starting tomorrow 
13:11:44 <kadoban> AzureStigma: You can certainly achieve that. I already use haskell whenever people don't tell me I can't.
13:11:46 <bjs> EvanR: i've still not played with idris, how does its type system differ from haskell? dependant types?
13:11:47 <EvanR> dysfun: i dont, but you can use the type system in your head ;)
13:12:03 <AzureStigma> since my add meds are wearing off lol 
13:12:05 <dysfun> EvanR: heh. learning a bit of agda twisted my brain inside out
13:12:05 <kadoban> AzureStigma: By the way, http://haskellbook.com if nobody has pointed you to it yet, it's the way I wish I had learned.
13:12:07 <EvanR> bjs: its quite a bit different, you could say its heavily simplified
13:12:19 <AzureStigma> i bought that book yesterday
13:12:24 <AzureStigma> its by chris allen right
13:12:28 <kadoban> Ah, great. Yep
13:12:42 <AzureStigma> ya bought it yeseterday was a bit upset that it wasnt in epub
13:12:44 <maerwald> kadoban: always decreasing the bus factor, eh? :P
13:12:48 <AzureStigma> but w/e
13:13:02 <AzureStigma> like the ereader pdf is fine i guess
13:13:03 <dysfun> all of my haskell books are dead tree
13:13:12 <EvanR> bjs: theres a book about this, still being written, yet on sale anyway! type driven development with idris
13:13:24 <kadoban> maerwald: Heh, possibly.
13:13:57 <AzureStigma> however, i like bookerly font and you cant change it on pdfs without issues and i asked him and they dont plan on having a epub version ever
13:14:42 <bjs> dysfun: as books are meant to be!
13:16:40 <AzureStigma> this is a bit off topic but anyone think the web is dying and mobile apps will slowly replace it
13:17:02 <jrajav> Other way around
13:17:11 <AzureStigma> by apps i mean mobile though
13:17:22 <glguy> Yup, it's offtopic
13:17:35 <AzureStigma> off to haskell off topic
13:18:06 <jle`> i can see someone making that statement in 2008, but in 2016, things seem to be opposite :p
13:18:07 <fishythefish> Is "guarded recursion" a synonym for "corecursion"?
13:18:07 <EvanR> hats off topic to ya
13:18:17 <Jeanne-Kamikaze> what I see is the web and mobile apps dying and ads taking over them
13:18:26 <dysfun> death of ads is coming
13:18:36 <dysfun> we're going to see more customers blocking ads than not soon
13:18:43 <glguy> still offtopic
13:19:03 <EvanR> ad blocker discussion blocker
13:20:03 <AzureStigma> adblockers slow the web and so do ads so your screwd both ways
13:20:16 <fishythefish> still off topic
13:21:46 <fishythefish> Anyway, it seems like sometimes a distinction is made between recursion (on data) and corecursion (on codata) and sometimes it's made between structural recursion (on data) and guarded recursion (on codata)
13:21:52 <fishythefish> Are these synonyms or am I misunderstanding?
13:23:03 <benzrf_> hey
13:23:21 <benzrf|> is there a good library for simple type-level nats and arithmetic?
13:25:34 <benzrf|> including, ideally, some kind of "fake dependent typing"
13:25:59 <benzrf|> or, wait - ghc has some kind of built-in thing for this, doesn't it?
13:26:56 <fishythefish> benzrf|: Are you looking for DataKinds?
13:27:13 <benzrf|> yeah, i forgot about nats in it >.<
13:27:30 <EvanR> https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html
13:27:37 <benzrf|> "This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.
13:27:41 <benzrf|> "
13:28:23 <benzrf|> is that a lie?
13:28:31 <AzureStigma> another truly dumb question by me..
13:28:39 <AzureStigma> can haskell be used for web apps
13:28:44 <benzrf|> AzureStigma: of course!
13:28:50 <AzureStigma> ... figured
13:28:52 <EvanR> ive seen the types defined here used in a few places
13:28:54 <benzrf|> it's a general-purpose programming language, just like python or java :)
13:29:06 <AzureStigma> wait your seriously?
13:29:14 <AzureStigma> thought you were saying that sarcastically 
13:29:15 <maerwald> AzureStigma: web apps are one of the more commonly used domains of haskell
13:29:22 <AzureStigma> zomg
13:29:33 <fishythefish> AzureStigma: there are multiple frameworks for it too
13:29:35 <jle`> benzrf|: it is mostly a non-lie
13:29:37 <AzureStigma> ya def 110 percent doing haskell
13:29:45 <EvanR> web apps have several "embarassingly functional" aspects to them
13:29:48 <benzrf|> jle`: is there a better module to import, then?
13:29:58 <AzureStigma> however 1 more question do i need to know javascript for that?
13:30:12 <jle`> benzrf|: GHC.TypeLits is meant to be used with other modules providing functionality
13:30:20 <maerwald> if you do web frontends, you should always no javascript
13:30:23 <maerwald> *know
13:30:26 <dysfun> no. even if you want to do javascripty things you can still use haskell
13:30:30 <EvanR> always no javascript
13:30:34 <kadoban> AzureStigma: Mostly not, there's some things it would help with, but none I can think of where it's required.
13:30:35 <AzureStigma> nicee
13:30:42 <maerwald> EvanR: don't twist my words! heh
13:30:45 <jle`> benzrf|: 'singletons' has some nice arithmeticky stuff with it.  it lifts the entire 'Integer' inteface, more or less
13:31:04 <AzureStigma> hell the only thing haskell cant do is make ios apps haah
13:31:13 <AzureStigma> it seems like it can do everything else
13:31:16 <maerwald> even if you use haskell for your web app, there are a lot of cases where you'll want to do small functionality directly in javascript
13:31:16 <benzrf|> it can't?
13:31:21 <jle`> benzrf|: but often what you really want is scattered here and there across the ecosystem
13:31:21 <EvanR> it probably can
13:31:27 <AzureStigma> no way it can make ios apps >_>
13:31:28 <benzrf|> jle`: :(
13:31:28 <kadoban> AzureStigma: Wellll, you can do mobile apps as webapps.
13:31:34 <AzureStigma> thats true
13:31:35 <jle`> benzrf|: but, that depends on what you really want :D
13:31:37 <benzrf|> i mean
13:31:42 <fishythefish> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
13:31:50 <EvanR> AzureStigma: it can also make code for microcontrollers and FPGAs
13:31:52 <kadoban> There's stuff like sencha touch for making them look like native apps too.
13:31:53 <benzrf|> you can compile haskell to js... and surely you can use js on ios, given how popular it's become ;)
13:32:26 <jle`> benzrf|: this package is nice, it extends the type checker to be aware of equalities
13:32:28 <jle`> https://hackage.haskell.org/package/ghc-typelits-natnormalise
13:32:56 <AzureStigma> lol use haskell as low level programming instead of c 
13:33:04 <EvanR> yeah
13:33:09 <aatxe> fishythefish: I assume there aren't any libraries for Cocoa though?
13:33:25 <aatxe> fishythefish: So, at that point, you're stuck writing C in Haskell for all of your UI stuff.
13:33:30 <fishythefish> aatxe: no clue - I don't own an Apple device, let alone code for one
13:33:38 <dysfun> correct, basically
13:34:09 <EvanR> aatxe: you want "haskell objective-c bindings"
13:34:13 <AzureStigma> if you dont own an apple device you dont get laid common fact ..
13:34:14 <jle`> benzrf|: between singletons and typelits-natnormalise i have been able to do most things, actually.  and some random assorted things i've pulled out into my own package, typelits-witnesses. (some of typelits-witnesses is now obsolete/redundant with singletons too)
13:34:19 <AzureStigma> jk lol
13:35:13 <fishythefish> AzureStigma: don't mix up "laid" and "screwed"
13:35:26 <fishythefish> Anyway, that's drifting OT
13:35:34 <EvanR> you get participled
13:35:34 <aatxe> EvanR: The bigger point is that you don't get nice functional-style UI stuffs.
13:35:35 <dysfun> that was a class comeback though
13:35:43 <EvanR> aatxe: well.. who does
13:36:01 <aatxe> Elm users, kind of?
13:36:15 <AzureStigma> well learning haskell he can easily make classic comebacks that functional way of thinking
13:36:33 <EvanR> aiui that is the pub-sub dataflow style UI
13:36:55 <EvanR> which might be better
13:36:56 <dysfun> pretty much. but it works quite well
13:36:58 <zomg> AzureStigma: sup
13:37:25 <AzureStigma> meant zomg as excitment didnt mean to ping you lol 
13:37:34 <AzureStigma> didnt even know there was a zomg in this channel
13:37:41 <aatxe> EvanR: are there other common functional UI models?
13:37:49 <EvanR> there is reactive banana
13:37:50 <zomg> AzureStigma: yeah thought so ;)
13:38:17 <dedgrant> we're slowly constructing the library of babel in the #haskell user list
13:38:37 <maerwald> it took 1 year for the reactive banana guy to figure out the types of the core operators :o
13:38:43 <maerwald> gl learning that thing
13:39:05 <dysfun> yeah but it's good once you know how
13:39:07 <EvanR> 1 year starting after the library was written?
13:39:11 <EvanR> impressive
13:39:32 <AzureStigma> rewrite crysis 3 in haskell that would be epic 
13:39:33 <dysfun> elm has gone through a few iterations as well
13:39:45 <maerwald> AzureStigma: not sure that even makes sense
13:40:01 <EvanR> AzureStigma: well, we are trying to get there (#haskell-game)
13:40:27 <benzrf|> jle`: will singleton allow me to define simple functions like factorial at the type level?
13:40:56 <EvanR> not that i want to write or play crysis 3
13:41:21 <EvanR> video games in haskell is an interesting domain of exploration
13:41:23 <AzureStigma> never played it just heard its one of the most graphics intensive game out there
13:41:45 <EvanR> there are a few shader DSLs in haskell
13:42:09 <dysfun> i'm pretty sure most games aren't written in haskell, because otherwise i wouldn't find so many damn bugs ;)
13:42:29 <AzureStigma> dont know if thats a insult to haskell or not lol
13:42:35 <jle`> benzrf|: maybe. you've just nerdsniped me.  give me a sec
13:42:40 <dysfun> no, it was praise
13:42:52 <AzureStigma> could go either way
13:43:09 <aatxe> dysfun: instead you'd hit abysmal memory-related performance issues.
13:43:21 <EvanR> not necessarily
13:43:34 <dysfun> i'm not convinced that's guaranteed
13:43:35 <maerwald> AzureStigma: haskell has no to little penetration in the games domain, apart from a few toy projects and an interesting thesis implementing the quake engine.
13:43:39 <benzrf|> jle`: heh
13:43:50 <fishythefish> trying again: are corecursion (resp. recursion) and guarded recursion (resp. structural recursion) synonyms?
13:44:11 <AzureStigma> ya i heard that haskell does cause memory issues perhaps that is due to the person who writes it?
13:44:20 <EvanR> it sure is
13:44:32 <hpc> haskell is indirectly involved in eve online iirc
13:44:33 <benzrf|> jle`: i want to write something that lets you work in n dimensions, and i'd like the dimensions to be type-level enforced -
13:44:34 <EvanR> C has memory issues
13:44:34 <AzureStigma> the ones that dont really the theory and books
13:44:40 <hpc> though in a way that's much closer to finance than game code
13:44:41 <EvanR> because of the people who write C code
13:45:06 <maerwald> hpc: source?
13:45:12 <aatxe> Not necessarily, but if Bethesda can't get a game released without numerous crash-to-desktop bugs, I don't know that they could write something in Haskell without memory issues.
13:45:13 <benzrf|> jle`: and there's a couple of things that i need to constrain in terms of some function of the dimension
13:45:27 <AzureStigma> wait so writing c code makes writing haskell unproductive?
13:45:55 <dolio> fishythefish: No, not really.
13:46:05 <maerwald> I don't even think haskell is the way to go for game engines. Rust looks more suitable for that domain, but I doubt you'd want to base your engine on that language yet. Too much flux.
13:46:13 <EvanR> aatxe: i find this thought experiment hard to follow
13:46:16 <dysfun> maerwald: also a horrible stdlib
13:46:18 <hpc> maerwald: google's results for "eve online haskell" are pretty pants, so i might have been mistaken
13:46:32 <fishythefish> dolio: Okay, I thought I might be misunderstanding - is there a good reference for the distinction?
13:46:42 <dolio> I don't know.
13:46:47 <aatxe> EvanR: to clarify: I think most game programmers would find it very difficult to reason about memory performance in Haskell (because it's hard, in general).
13:46:50 <AzureStigma> being a league of legends players ill learn haskell and rewrite that in haskell ... haha jk
13:47:00 <EvanR> maerwald: they are talking about graphics intensiveness, and engines... and i wish they knew they were not talking about "games"
13:47:17 <aatxe> hpc: Might've been thinking of Erlang?
13:47:18 <dolio> 'Guarded recursion' might be 'corecursion' I suppose. But 'recursion' isn't 'structural recursion.' 
13:47:45 <fishythefish> dolio: Ah, yeah, didn't mean "general recursion" by "recursion" if that's what you're thinking
13:47:46 <AzureStigma> what do you mean by reason memory performance in haskell?
13:47:46 <EvanR> aatxe: well, minecraft makes a lot of money
13:47:54 <benzrf|> fishythefish: "corecursion", depending on the context, might refer to functions defined in terms of the coinduction principles for coinductive types
13:47:57 <EvanR> noone had to reason very much about memory performance there
13:48:04 <aatxe> EvanR: And is noted for horrible performance?
13:48:05 <dolio> Kind of trivially from your question, because presumably 'guarded recursion' is a type of 'recursion.'
13:48:12 <jle`> benzrf|: basic stuff is possible; look at hmatrix's Numeric.LinearAlgebra.Static
13:48:14 <dysfun> AzureStigma: because haskell is garbage collected and lazy, if you don't write it carefully, you can make the GC work harder
13:48:20 <EvanR> aatxe: i had to upgrade my computer yes, then it was ok
13:48:35 <EvanR> notably the ram
13:48:38 <fishythefish> dolio: That's what I would have thought, but guarded recursion is for ensuring productivity when dealing with codata, not data
13:49:09 <fishythefish> Er, am I correct in assuming that recursion is for dealing with data and corecursion is for codata?
13:49:10 <dolio> Right, but they're all special cases of general recursion.
13:49:18 <benzrf|> jle`: well, i know i can do arithmetic with TypeLits...
13:49:19 <AzureStigma> thanks dysfun
13:49:29 <fishythefish> Right
13:49:29 <benzrf|> jle`: maybe i will just do multi param typeclasses with fundeps >.>
13:49:29 <AzureStigma> well i suck at math lol 
13:49:41 <AzureStigma> i got a c+ in differtial equations lol
13:49:57 <dysfun> so do i. handily you don't actually need to be good at math to program, whatever people might tell you
13:49:59 <aatxe> EvanR: AFAIK, most of the performance improvements over the time that Minecraft was being made were related to memory performance.
13:50:29 <maerwald> dysfun: I've seen non-trivial code from real math people xD
13:50:30 <aatxe> EvanR: But I'm not so worried about GC. I'm more worried about when laziness + GC together leads to something awful.
13:50:35 <EvanR> im comparing the idea of writing a memory intensive video game in something like java.. to the hypothetical equivalent in haskell
13:50:49 <fishythefish> Maybe I just need to play around in Coq more to grasp these ideas
13:50:53 <AzureStigma> is haskell faster than java though?
13:51:02 <fishythefish> Is it more accurate to say that all types in Haskell are coinductive or that Haskell doesn't make a distinction?
13:51:05 <EvanR> aatxe: well ive been working on this stuff, and using the profiler i understand where my memory is going. it just took some realizing what i was doing
13:51:06 <benzrf|> dysfun: ehhh... imo math and programming take very similar skillsets... but by "math" i mean "pure, formal math focused on proofs" and by "programming" i mean "being able to think using programming languages' abstractions and design programs"
13:51:29 <benzrf|> fishythefish: i think i'd say that haskell doesn't make the distinction
13:51:29 <dolio> fishythefish: I mean, they're both inductive and coinductive, in a way.
13:51:40 <dysfun> maerwald: physicist code is the worst. i'm currently learning physics, so hoping i don't have to throw out the programming ability with the bathwater ;)
13:51:58 <benzrf|> fishythefish: if you define "coinductive" using universal properties, i think haskell's types might satisfy it, but i have no clue
13:52:01 <aatxe> AzureStigma: If you don't run yourself into a performance hole, Haskell is typically faster than Java.
13:52:18 <bjs> AzureStigma: why all the questions? but yeah, haskell is pretty fast, at least in comparison to languages like java
13:52:20 <fishythefish> dolio, benzrf|: This answer was what intrigued me: http://cs.stackexchange.com/a/30484
13:52:26 <dysfun> benzrf|: 'logical' maths, sure. solving things, not so much
13:52:28 <AzureStigma> sorry bout that
13:52:46 <dysfun> bjs: erm java is pretty fast these days
13:52:55 <bjs> AzureStigma: no i just mean, are you trying to use these as a method of picking a language to learn or out of curiosity about the language
13:52:59 <benzrf|> dysfun: one of my pet brands of snobbery is refusing to acknowledge the usage of computational techniques as "math" :>
13:52:59 <dolio> fishythefish: He's wrong, you can define finite lists.
13:52:59 <maerwald> benzrf|: the skill set is fundamentally different imo. The way a programmer designs stuff and thinks about a whole system (not just a function or an algorithm) is something you barely find in maths in that form.
13:53:02 <bjs> dysfun: so is haskell
13:53:09 <AzureStigma> for curiosity of the language
13:53:09 <fishythefish> dolio: Oh, phew
13:53:15 <EvanR> the codespeed velocity of an unladen language
13:53:15 <bjs> dysfun: i meant, in comparison to horribly optimised C :)
13:53:15 <fishythefish> This has been bugging me
13:53:23 <AzureStigma> i am 110 percent set on starting to learn haskell tomorrow
13:53:36 <AzureStigma> i just wanted to understand it lol
13:53:47 <jle`> benzrf|: hm i blew the typechecker's recursion stack
13:53:54 <benzrf|> jle`: bwahaha
13:53:56 <EvanR> AzureStigma: you will not be disappointed, haskell entails a lot of new ideas
13:54:14 <EvanR> new relative to the programming world of python
13:54:26 <bjs> EvanR: understatement of the year goes to
13:54:29 <benzrf|> maerwald: well, they're certainly not identical
13:54:39 <EvanR> the ideas arent actually new at all
13:54:44 <EvanR> except for Applicative
13:55:18 <dysfun> and semigroups?
13:55:33 <benzrf|> maerwald: but they're both founded on "formal thinking"
13:55:36 <EvanR> huh semigroups from 1910 abstract algebra?
13:56:05 <EvanR> year totally made up
13:56:21 <maerwald> benzrf|: well, "formal thinking" is rather vague to me
13:56:25 <fishythefish> EvanR: You're not far off
13:56:41 <fishythefish> 1904 or 1908 seems to be the earliest use of the term
13:56:47 <aatxe> EvanR: Well, applicative functors are, according to Wikipedia, equivalent to strong lax monoidal functors.
13:56:49 <jle`> hm my limited knowledge of the singletons library can't prevent the stack overflow.  i can't prove to the typechecker that my recursion will eventually finish v.v  i'll get back to you, i'm still learning this stuff myself :)
13:57:04 <aatxe> EvanR: Which date back to at least 1974.
13:57:14 <EvanR> aatxe: right, but applied to programming?
13:57:31 <benzrf|> maerwald: i mean that "thinking in terms of a programming language" and "thinking in terms of formal mathematics" are very alike
13:57:40 <dysfun> EvanR: well they definitely didn't apply semigroups to programming in 1910
13:57:58 <aatxe> EvanR: Well, if applying it to programming makes it new, the same could be said of basically everything in Caml and Haskell, no?
13:58:01 <EvanR> no but the form of semigroups isnt very different when youre programming
13:58:07 <EvanR> im not using strong lax monoidal functors in my code
13:58:10 <dolio> You mean, weaving?
13:58:31 <benzrf|> maerwald: for example, reading and understanding code is a similar mental activity to reading and understanding mathematical definitions and proofs
13:58:32 <dysfun> how would you know? i would have no idea if i was using a strong lax monoidal functor in my code unless i'd been in this conversation
13:58:58 <maerwald> uhm, not sure what kind of code you read
13:58:58 <EvanR> the applicative programming pattern is new
13:59:14 <benzrf|> maerwald: not in *every* way, but -
13:59:23 <maerwald> when I read code I usually think "omg, now I have to figure out all the odd errors in reasoning of that person"
13:59:27 <maerwald> which is usually what it boils down to
13:59:28 <aatxe> EvanR: so is the monoidal programming pattern, no?
13:59:32 <bjs> EvanR: "strong lax" sounds like one of them silly mathematical terms that should negate each other than "open closed sets"
13:59:40 <bjs> like*
13:59:52 <aatxe> bjs: I think the term lax there is redundant actually.
13:59:57 <dysfun> bjs: semiopen coclosed sets
14:00:00 <EvanR> monoidal programming is not new, (+ 1 2 3 4 5) in lisp
14:00:06 <fishythefish> dolio: finite/infinite lists are the least/greatest fixed points of the same functor, aren't they?
14:00:06 <benzrf|> bjs: actually it's "clopen"
14:00:09 <ertes> "‹using monoids›?  i'm just appending strings!"
14:00:15 <bjs> benzrf|: i know, i was avoiding using that term at all costs
14:00:19 <benzrf|> lol
14:00:24 <dolio> fishythefish: Not in Haskell.
14:00:25 <benzrf|> maerwald: i'm talking about things like...
14:00:25 <bjs> benzrf|: for deep philisophical reasons
14:00:44 <fishythefish> dolio: okay, because I know the fixed points coincide
14:00:51 <maerwald> benzrf|: as a programmer I feel more like a psychologist who reads the diary of a deceased crazy person
14:00:55 <benzrf|> maerwald: if you read a piece of code and then spot a bug in it without ever running it - your brain is doing something similar to if you read a proof and spot a hole in it without specifically finding a counterexample
14:01:15 <benzrf|> it's, like - interpreting something within a rigid, formal set of semantics
14:01:18 <fishythefish> dolio: how are finite lists specified?
14:01:19 <EvanR> open and closed are kind of badly named, if its supposed to make you think of opposites
14:01:36 <dolio> data FList a = Nil | Cons a !(FList a)
14:01:38 <EvanR> if its NOT supposed to make you think of opposites
14:01:40 <dysfun> benzrf|: by that logic, it's the same process as when you read philosophy and pick it apart
14:01:49 <benzrf|> dysfun: i'd say there's some similarity ;)
14:01:55 <benzrf|> math is closer though
14:02:12 <benzrf|> if anything i think coq convinced me of that
14:02:13 <dysfun> i'm not a mathematician, but i did study philosophy
14:02:14 <aatxe> dysfun: formal logic is a branch of philosophy just as much maths, so, there's that.
14:02:28 <benzrf|> i mean -
14:02:31 <maerwald> benzrf|: you're basically just saying "both is analytical"
14:02:34 <maerwald> which is not really much
14:02:41 <dysfun> aatxe: well the scientific method is philosophy if you want to go there
14:02:50 <hpc> they should take a cue from physics and name things after whoever formalized it
14:02:50 <benzrf|> maerwald: well, they're additionally both *formal*
14:02:55 <hpc> suddenly everything is named after euler
14:02:57 <EvanR> "is a branch of philosophy" isnt saying much ;)
14:03:01 <benzrf|> hpc: that's already true
14:03:06 <maerwald> there are a lot of things that are formal...
14:03:31 <benzrf|> maerwald: formal as in, reducable to symbolic manipulation
14:03:54 <dolio> fishythefish: The problem with that stack overflow answer is that you can still do induction in Haskell, you just have to use domain induction. Data types in Haskell are inductively defined domains.
14:03:57 <benzrf|> the semantics of a program are formal in the same way that a proof is, imo
14:03:58 <fishythefish> dolio: Ah, okay, this agrees with what I've read about regarding type theory in strict vs non-strict languages
14:04:13 <fishythefish> dolio: I'll have to read up on domain induction, but thanks for the help
14:04:24 <benzrf|> it's the same kind of, like, "there's an answer to this regardless of what *you* think"
14:04:44 <dolio> When the answer says that you 'can't reason by induction,' what it's really saying is that types aren't set, and implicitly assuming that 'induction' only means sets.
14:04:45 <benzrf|> that was a very loose statement, plz dont jump on me
14:04:52 <ertes> void swap_two_variables(Paste_Bin p, inout Int x, inout Int y) { paste_id = p->upload(x.toString); x = y; y = string_to_integer(p->download(paste_id)); }
14:05:57 <benzrf|> AbelianGrape: what's yellow and equivalent to the axiom of choice?
14:05:58 <dolio> But also, every set you'd want to do induction on can be seen as a flat domain, where domain induction will be almost exactly like set induction, and those types can also be defined in Haskell.
14:06:07 <hpc> zorn's lemon
14:06:11 <EvanR> math is something people do, it might even be silly to think that aliens will understand our "universal" math
14:06:17 <benzrf|> hpc: actually, it's the axiom of choice written in a yellow font
14:06:25 <hpc> what a twist!
14:06:36 <benzrf|> EvanR: i saaaaaaid "that was a very loose statement, plz dont jump on me"
14:06:44 <EvanR> i wasnt 
14:06:56 <dysfun> EvanR: if you look at number theory, mostly what you find is a series of choices that made sense once upon a time. we still use them because they still make sense but there are other consistent options too
14:07:16 <benzrf|> ach, i should get back to work
14:07:19 <benzrf|> ttyl
14:07:52 <EvanR> dysfun: even the fact that we want something consistent is just a function of humans doing math
14:08:00 <ertes> EvanR: aliens may not understand our math, but we can teach it…  i think something like natural deduction may actually be univeral
14:08:03 <ertes> universal
14:08:19 <EvanR> yeah you can teach it
14:08:19 <maerwald> at this point, I think we are offtopic ;)
14:08:22 <aatxe> benzrf: the axiom of choice written in a yellow font is not necessarily equivalent to the axiom of choice.
14:08:27 <fishythefish> dolio: True, but I took his statement to mean structural induction (or whatever the term should be), since he mentioned lists
14:08:28 <EvanR> and they might be like "you are odd"
14:08:30 * fishythefish shrugs
14:09:12 <mw> later/quit
14:09:15 <ertes> EvanR: but they wouldn't disagree =)
14:09:31 <EvanR> if theres one constant in the universe, its someone can always say "i disagree"
14:10:09 <dysfun> EvanR: actually i think it's the speed of light
14:10:29 <maerwald> >>= go to -offtopic?
14:11:10 <EvanR> #haskell-blah !
14:11:17 <maerwald> whatever you like best...
14:11:29 <hpc> -offtopic is the best -blah since -blah
14:11:34 <ertes> i like (>>= pure ()), i.e. let's just stop =)
14:11:45 <ertes> i like (>> pure ()), i.e. let's just stop =)
14:13:38 <aatxe> EvanR: I disagree.
14:15:02 <EvanR> called it
14:15:28 <ertes> i like the concept of a channel, where haskell programmers talk about other things than haskell…  problem is that the interesting discussions all seem to start here
14:15:38 <aatxe> ertes: more people here, right?
14:15:56 <ertes> and i started yet another OT discussion…  see?
14:16:15 <aatxe> Is metadiscussion about this IRC channel considered off-topic?
14:16:34 <hpc> aatxe: that kind of question belongs in #haskell-meta-meta
14:16:51 <glguy> ertes: The idea is you pre-join the offtopic channel so that the burden of having the discussion there is lower
14:17:09 <AzureStigma> are there frameworks in haskell that serve a similar function to angular
14:17:20 <dysfun> no
14:18:04 <dysfun> there are a few that might be usable soon
14:18:19 <AzureStigma> so angular is the only shortcoming 
14:18:20 <aatxe> AzureStigma: If you want a tierless web framework in a functional language, there's http://www.impredicative.com/ur/
14:18:25 <ertes> AzureStigma: FRP disconnects interaction logic from presentation
14:18:34 <EvanR> ertes: theres a serious fanout going on with haskell channels
14:19:12 <AzureStigma> thats awesome though so im guessing angular and node.js are the only two short comings
14:19:20 <aatxe> AzureStigma: It's not Haskell, but can maybe do the sort of thing you're looking for.
14:19:27 <ertes> AzureStigma: i have only very basic angular knowledge, but FRP is likely more generic, so you may be interested in it…  be prepared to climb a learning curve though…  for practical examples see reflex (the videos by ryan trinkle are enlightening)
14:19:32 <maerwald> AzureStigma: angular is horrible. I doubt there will ever be an MVC based haskell lib like that.
14:19:34 <dysfun> erm, why do you care about nodejs?
14:19:47 <ertes> EvanR: i wouldn't know…  i'm only in two of them
14:19:47 <lpaste> jle` pasted “No title” at http://lpaste.net/168623
14:19:54 <dysfun> i can understand the need to care about browser javascript, but why do you care at all about node?
14:19:56 <aatxe> AzureStigma: node.js is more-or-less a library to let you use JS as a backend language for the web.
14:20:08 <aatxe> AzureStigma: There are absolutely backend web frameworks in Haskell.
14:20:12 <jle`> @tell benzrf http://lpaste.net/168623
14:20:13 <lambdabot> Consider it noted.
14:20:14 <AzureStigma> i dont however once i start learning and if i get good enough i can help develop frameworks if i get to that level xD
14:20:36 <AzureStigma> and contribute to haskell
14:20:54 <maerwald> you should learn the language first
14:21:02 <AzureStigma> yea lol 
14:21:12 <ertes> AzureStigma: as a haskell programmer you will write frameworks all the time
14:21:42 <ertes> AzureStigma: but your frameworks my be as small as two lines of code =)
14:22:12 <ertes> (background: i'm not distinguishing between "framework" and "domain-specific language")
14:22:54 <AzureStigma> but isnt there a place were you guys make them contribute to the public?
14:23:01 <zomg> AzureStigma: if you're interested in something for frontend that's haskell-like, maybe look at Elm
14:23:04 <dysfun> https://hackage.org/
14:23:07 <maerwald> zomg: uagh
14:23:12 <maerwald> rather look at purescript
14:23:16 <zomg> sure
14:23:23 <ertes> AzureStigma: most of open source code ends up on hackage:  https://hackage.haskell.org/
14:23:24 <zomg> elm just has more of the "angular stuff" out of the box :)
14:23:28 <dysfun> elm is pretty nice
14:23:34 <zomg> certainly if you want a straight JS replacement, then purescript
14:23:42 <dysfun> needs more utility functions out of the box :/
14:23:46 <AzureStigma> i see thats like coffeescript 
14:23:53 <aatxe> zomg: Elm is made for this stuff.
14:23:55 <AzureStigma> but functional
14:24:03 <dysfun> elm is like 'haskell light'
14:24:06 <zomg> AzureStigma: only thing that is "like coffeescript" with that is that it compiels to JS :P
14:24:21 <AzureStigma> no i meant as in alternatives haha
14:24:26 <dysfun> it's very easy to get started with, but if you know haskell well, you find it a bit limiting
14:24:27 <aatxe> dysfun: no HKT though :(
14:24:27 <AzureStigma> bad example on my end
14:24:28 <ertes> elm feels more like purescript than haskell:  a high-level JS
14:24:29 <zomg> yeah :)
14:24:43 <ertes> especially since they are giving up "signals", it feels more like JS than ever
14:25:01 <dysfun> yes but they've replaced signals with returning ADTs
14:25:01 <AzureStigma> dysfun what do you mean limiting the elm or haskell?
14:25:14 <dysfun> AzureStigma: elm is not nearly as powerful as haskell
14:25:16 <ertes> dysfun: they basically brought back event handlers
14:25:22 <maerwald> dysfun: purescript is though
14:25:33 <dysfun> ertes: funnelled into one function per component
14:26:06 <dysfun> maerwald: is there anything FRP-y for it?
14:26:40 <maerwald> I don't know. I was thinking about the language only, not about libraries.
14:26:41 <ertes> dysfun: in other words, the main advantage of FRP is gone (it wasn't really FRP to begin with, but let's ignore that):  first-class events
14:27:01 <AzureStigma> all i know is most mobile websites i see are buggy or look like junk and when i saw haskell site it was beautiful and i had faith in haskell Xd
14:27:04 <AzureStigma> from the start
14:27:07 <EvanR> AzureStigma: coffeescript is like an alternative syntax for javascript, purescript is a different language
14:27:29 <ertes> now reflex with GHCJS gives you *real* FRP for web frontends…  therefore i don't see a reason to use elm anymore
14:27:33 <dysfun> ertes: honestly when it comes to javascript i just want to do the simplest thing that works because javascript breaks my brain. elm gives me enough
14:28:00 <aatxe> AzureStigma: The appearance of Haskell.org is just good design, not really the product of Haskell itself.
14:28:11 <ertes> dysfun: that's why i'm suggesting reflex…  no need for a different language, can share code between server and client, and you get full higher-order FRP
14:28:16 <AzureStigma> no but i have a feeling it was probably used using some form of haskell
14:28:17 <zomg> ertes: did they fix GHCJS generating gigantic files? :P
14:28:25 <zomg> if not then that's probably the remaining reason to consider elm... :D
14:28:31 <dysfun> ertes: hrm, i hadn't seen reflex before
14:29:10 <AzureStigma> the fact that awesome site i can put code in is just so cool
14:29:17 <AzureStigma> the try it lamda 
14:29:18 <ertes> zomg: nope, they are still huge, but honestly JS with all those extra libraries isn't that much smaller…  closure-compiler together with HTTP compression gets the size to acceptable levels, too
14:29:20 <EvanR> higher order FRP has a definition?
14:29:32 <zomg> ertes: true :)
14:29:47 <EvanR> is it like "FRP Reactive Programming" ?
14:29:48 <maerwald> ertes: and you have fun debugging that?
14:29:53 <dysfun> ertes: damnit, i'm going to have to figure out how to use ghcjs with stack now
14:30:05 <aatxe> AzureStigma: Ironically, that whole part is JS as far as I know. ;)
14:30:07 <ertes> EvanR: FRP implementations that can switch:  Behaviour (Event a) -> Event a
14:30:10 <AzureStigma> was erm used in haskell.org 
14:30:25 <AzureStigma> elm*
14:30:28 <aatxe> No.
14:30:28 <davidthomas> For SYB/generics, is there a good check against "I forgot to derive Generic somewhere..."?
14:30:33 <ertes> maerwald: i have GHCJS integrated into haskell-mode =)
14:30:36 <ertes> maerwald: so yes
14:30:43 <aatxe> Haskell.org uses Yesod for the backend, and as far as I know, all the frontend stuff is just normal JS.
14:30:45 <EvanR> ertes: what would first order be?
14:30:55 <ertes> EvanR: FRP without a switching combinator =)
14:30:58 <davidthomas> (/Data)
14:30:59 <EvanR> second order?
14:31:48 <maerwald> ertes: I don't particularly understand how that helps
14:32:17 <ertes> maerwald: you can do your usual prototyping in your editor
14:32:37 <maerwald> I was talking about debugging broken runtime behavior of the compiled js code
14:32:56 <AzureStigma> but if haskell can do all this why isnt it more popular the learning curve?
14:33:16 <EvanR> "haskell is too hard"
14:33:25 <EvanR> "haskell is too complicated to understand"
14:33:30 <kadoban> AzureStigma: Because everyone spends too much time in #haskell talking about it, without actually sitting down and learning the language ;)
14:33:31 <EvanR> actual people
14:33:35 <aatxe> "You need a PhD to understand Haskell"
14:33:37 <ertes> maerwald: like something bad happens, and you need to find the error in your code?
14:33:41 <AzureStigma> nice one kadoban 
14:33:48 <maerwald> ertes: code maps etc
14:33:56 <AzureStigma> im starting tomorrow my vyvanse wore off
14:34:03 <dolio> Because popularity has nothing to do with how good something is.
14:34:03 <zomg> the problem is haskell lingo is confusing to programmers who learned with something that isn't haskell
14:34:27 <AzureStigma> and since haskell will be my first it will be awesome lol XD
14:34:56 <ertes> AzureStigma: if you've got an hour to waste, peter sewell has a great answer:  https://media.ccc.de/v/31c3_-_6574_-_en_-_saal_1_-_201412301245_-_why_are_computers_so_and_what_can_we_do_about_it_-_peter_sewell
14:35:05 <dysfun> oh and don't read any of the monad explanations on the internet
14:35:27 <EvanR> dont read any monad explanations, and then dont write any monad explanations
14:35:35 <EvanR> in fact, men in black erase monads from history
14:35:43 <maerwald> read ALL monad explanations
14:35:44 <ertes> maerwald: sorry, i'm not sure what you're asking for…  there is no fancy debugger like in elm
14:36:02 <maerwald> ertes: so it will be a pain to map from the js code to your haskell code
14:36:06 <AzureStigma> do i need to know computer archtecture to be efficent in haskell or thats only useful for when learning assembly? 
14:36:08 <dysfun> "monads are like monads"
14:36:36 <ertes> maerwald: if there is, i don't know
14:36:36 <dysfun> i would'nt worry about that just yet, you have plenty of time to learn it
14:36:52 <maerwald> ertes: that's a pretty strong argument against ghcjs if there is not
14:37:04 <AzureStigma> by that what is that being referred to dysfun?
14:37:18 <ertes> maerwald: i don't know if there is, but GHCJS has an interactive mode, so i'm pretty sure it supports all the usual debug patterns
14:37:23 <dysfun> knowing too much about the architecture
14:37:27 <AzureStigma> kk thanks!
14:37:34 <EvanR> AzureStigma: its nicer to start with understanding evaluation of code in terms of its syntax only, imo. haskell is cool for actually letting you do this
14:37:36 <dysfun> you'll pick things up reading about the topics
14:37:40 <maerwald> ertes: uhm, usually the debugging starts in the browser and then you are thrown into the js code
14:37:49 <ertes> ah
14:37:50 <maerwald> if that's a huge pile of foo without code maps
14:37:52 <maerwald> then good luck
14:37:59 <dysfun> i think it would benefit you to work in the high level and ignore the low level for a bit
14:38:01 <AzureStigma> who is chris allen in irc?
14:38:02 <ertes> maerwald: yeah, i would imagine that that's not going to be practical
14:38:22 <maerwald> it's already annoying with node.js, but there are working code maps
14:38:26 <ertes> maerwald: you should write your code in such a way that you don't have to rely on the browser or the generated JS
14:38:33 <ertes> otherwise it's likely going to be a nightmare
14:38:43 <maerwald> ertes: you mean "don't write bugs"?
14:38:54 <AzureStigma> i bought his book on the site and it says his in irc but i dont know who he is lol the username
14:39:05 <ertes> maerwald: no, write in such a way that you can test on bare metal
14:39:21 <ertes> minimise the stuff that can go wrong once the JS is generated
14:39:53 <ertes> and yes, that may well turn off some programmers, because it doesn't fit their workflow
14:40:01 <ertes> it fits mine though…  i don't mind that much
14:40:38 <maerwald> I am pretty sure people just end up testing functionality at runtime and then manually look at their code, which is inefficient
14:42:06 <ertes> how do you test *not* at run-time?
14:42:19 <maerwald> I don't know
14:42:33 <ertes> maybe i'm not understanding the problem or your workflow
14:42:45 <maerwald> I mean, you can write your test all day long, in the end you need to fire up the browser.
14:44:08 <maerwald> that's not really a corner case in terms of frontend development workflow
14:44:18 <ertes> AzureStigma: chris allen is bitemyapp, i think
14:45:51 <aatxe> ertes: username is ~callen, so it checks out
14:46:18 <zomg> bite my shiny metal app
14:53:48 * hackagebot Euterpea 2.0.1 - Library for computer music research and education  https://hackage.haskell.org/package/Euterpea-2.0.1 (DonyaQuick)
14:55:08 <Welkin> I've been playing around with writing more generic functions, but it always seems to cause some kind of trouble
14:55:34 <Welkin> instead of using lists, use (Foldable t, Applicative t, Monoid (t a))
14:57:17 <Rembane> Welkin: And then the typechecker goes haywire?
14:57:31 <Welkin> haha
14:57:45 <Welkin> well, I have to supple a type annotation to apply the function
14:57:55 <Welkin> levelOrder testTree :: [Int]
14:58:20 <Welkin> even though I will always want lists for this toy program
14:58:46 <Welkin> I'm wondering how others handle making their functions generic, and when it is a good idea to do it
14:58:48 * hackagebot proto-lens 0.1.0.1 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.1.0.1 (JudahJacobson)
14:59:55 <Welkin> even needing to add (Ord a, Eq a) to many functions seems like a pain when prototyping
15:00:09 <Welkin> I wonder if I should always start with concrete types and later make it as generic as necessary
15:02:08 <Rembane> Welkin: I think that's a really good strategy. 
15:02:51 <Rembane> Welkin: Or maybe not use types until you must, unless they help you think of course. Using the typchecker and letting the implementations be undefined is a fun design method imo
15:03:00 <Welkin> I need the types :P
15:08:49 * hackagebot proto-lens-protoc 0.1.0.1 - Protocol buffer compiler for the proto-lens library.  https://hackage.haskell.org/package/proto-lens-protoc-0.1.0.1 (JudahJacobson)
15:08:51 * hackagebot proto-lens-arbitrary 0.1.0.1 - Arbitrary instances for proto-lens.  https://hackage.haskell.org/package/proto-lens-arbitrary-0.1.0.1 (JudahJacobson)
15:08:53 * hackagebot proto-lens-combinators 0.1.0.1 - Utilities functions to proto-lens.  https://hackage.haskell.org/package/proto-lens-combinators-0.1.0.1 (JudahJacobson)
15:13:49 * hackagebot proto-lens-optparse 0.1.0.1 - Adapting proto-lens to optparse-applicative ReadMs.  https://hackage.haskell.org/package/proto-lens-optparse-0.1.0.1 (JudahJacobson)
15:26:00 <Mateon1> Hi, I'm making a game in Haskell, and I'm wondering how to pack resources like audio and textures into the executable. Is it possible? If not, I can always make an external resource folder, but I'd prefer not to.
15:27:00 <Welkin> Mateon1: ask in #haskell-game
15:27:27 <ertes> Mateon1: it's possible using linker tricks, but i'd encourage you to make the directory instead
15:27:46 <ertes> Mateon1: it's just easier in every way
15:29:09 <dedgrant> There's also simply encoding via datatypes written as Haskell source code. You just need some generator to produce the data in a way that can be compiled. Being able to select the data source is handy, whether it comes from a file or is linked in.
15:30:36 <ertes> windows has a concept of "resources"…  stuff bundled with the executable that isn't necessarily read into memory at startup
15:31:03 <ertes> so it may seem natural to do that, but it really isn't
15:33:06 <dysfun> windows also has C:\Program Files, because in practice your assets are much bigger than your executable
15:41:28 <Mateon1> Well, in that case: 1) With the directory, the trouble moves to cabal: How to make it copy the directory into the build folder (and how to even make a build folder with cabal); 2) With hardcoding, how to make it easy to modify textures, what is an efficient encoding etc.
15:43:16 <Mateon1> A quick sidenote, how do I add compiler flags to a .cabal file?
15:44:28 <glguy> https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
15:44:58 <Mateon1> ghc-options, got it
15:45:00 <pyon> Are there any major libraries that depend on mtl's ListT being broken in the specific way in which it's broken?
15:45:21 <pyon> Or why hasn't it been fixed after so much time knowing it's broken?
15:46:36 <schell> can stack update cabal build-depends automatically?
15:46:41 <hexagoxel> (transformers' ListT)
15:46:55 <pyon> Errr, yeah, I mean, transformers' ListT.
15:47:19 <pyon> Since mtl is just a better API in top of transformers.
15:49:46 <hexagoxel> pyon: the types of all the functions change when fixing. that is probably sufficient for the predicate of "depend on the specific way it is broken".
15:51:34 <hexagoxel> so the question becomes "does anyone import Control.Monad.Trans.List"
15:51:53 <pyon> Does anyone, indeed?
15:59:23 <hexagoxel> pyon: looking at packages on stackage: amazonka bound conduit-extra constraints contravariant exceptions exception-transformers free git-annex GPipe haskeline ide-backend invariant lens lifted-base List logging-facade microlens-mtl mmorph MonadCatchIO-transformers monad-control monad-journal monadloc monad-logger monad-parallel monad-peel monads-tf mono-traversable mtl operational-class pointed primitive 
15:59:24 <hexagoxel> ref-fd resourcet semigroupoids shelly stack statestack transformers transformers-base transformers-compat transformers-lift unbound-generics webdriver yesod-core
16:00:20 <nshepperd_> Not since that terrible accident in 2013 where someone instantiated ListT IO and created hundreds of parallel RealWorlds
16:03:51 * hackagebot stratosphere 0.1.3 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.3 (jdreaver)
16:59:57 <texasmynsted> Is there some reference that describes structural sharing of typical data structures in Haskell?
17:04:43 <Welkin> structural sharing?
17:05:22 <xaviergmail> So I've run into a bit of a pickle
17:05:34 <pyon> Welkin: Like, when you insert an element into a tree, the only nodes that need to be recreated are those in the affected path.
17:05:41 <xaviergmail> Are there any debuggers / simple methods of debugging?
17:05:52 <Welkin> oh
17:06:05 <Welkin> texasmynsted: look at Okasaki
17:06:23 <Welkin> he has a paper (and a book) on purely functional data structures
17:07:09 <texasmynsted> The book is gianormous 
17:07:14 <Welkin> ?
17:07:19 <Welkin> it is a little over 200 pages
17:07:31 <texasmynsted> oh I am thinking of diff book I guess
17:07:35 <Welkin> I have only read parts of it
17:07:56 <Welkin> here is another good reference http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki
17:08:08 <Welkin> here is Okasai's paper http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
17:08:22 <Welkin> the book is the improved version of the paper with haskell source code
17:08:30 <pyon> The first 4 chapters of the book are relatively light reads.
17:08:34 <texasmynsted> THank you
17:08:51 <pyon> And structural sharing is covered in chapter 1.
17:09:05 <pyon> (Of the book, no idea about the thesis.)
17:12:08 <pavonia> xaviergmail: ghci has an integrated debugger
17:14:31 <xaviergmail> Right I completely forgot about that
17:17:14 <texasmynsted> What is a good reference for algebraic datatypes in Haskell?
17:17:56 <Welkin> there is this https://wiki.haskell.org/Algebraic_data_type
17:17:57 <c_wraith> what aspect? the basics, or advanced features and why they're called "algebraic"? 
17:18:00 <Welkin> not sure what else
17:20:05 <texasmynsted> I was thinking there might be papers or books or something
17:20:44 <Welkin> not sure what there is to know
17:20:54 <Welkin> but I haven't looked much into it beyond sum and product types
17:21:10 <texasmynsted> what about partially applied data types?
17:21:38 <Welkin> wikipedia has some information on it using haskell as an example
17:21:38 <Welkin> https://en.wikipedia.org/wiki/Algebraic_data_type
17:46:02 <Rotaerk> reading through http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:46:41 <Rotaerk> and my immediate reaction is ... it seems like free monads are solving a problem that could've been avoided by just defining:  data Toy b = Output b (Toy b) | Bell (Toy b) | Done
17:46:53 <Rotaerk> so ... why does he do it the way he does?
17:47:51 <pyon> hexagoxel: Wow, that's a lot.
17:48:37 <pyon> hexagoxel: Do those packages really use ListT, or just use transformers/mtl?
17:55:11 <pyon> Is there a performance cost to using large monad transformer stacks? That is, due to calling `lift` a lot of times. If I understand correctly, transformer-specific type classes (MonadState, MonadError, etc.) automate *writing* `lift`, but they don't eliminate the *runtime* calls to `lift`.
17:55:58 <dmj`> pyon: correct
17:59:51 <pavonia> Isn't that usually just a newtype wrapping, i.e. no runtime costs?
18:01:13 <hpc> Rotaerk: it's not terribly obvious from that post, but by CPS-transforming Toy a bit and deriving Functor on it, (Free Toy) automatically gives you a pretty useful Monad instance
18:01:23 <hpc> and there's a bunch of stuff that operates on Free which you don't have to write yourself
18:01:39 <hpc> you'd otherwise end up resorting to something weird with TH/Data/Typeable
18:01:49 <Rotaerk> ah
18:01:54 <hpc> to automate writing that stuff for each "free" type you write
18:03:13 <hpc> in some sense, Free lets you write control flow directly in ADT syntax
18:03:33 <pyon> pavonia: It's usually a newtype wrapping composed with a liftM/fmap call.
18:08:27 <dwynwen_ddlleyw> Y'all are great at monads 
18:08:35 <dwynwen_ddlleyw> Is jQuery monadic?
18:08:58 <shachaf> No.
18:09:09 <dwynwen_ddlleyw> Hmm
18:09:28 <dwynwen_ddlleyw> I thought monads returned a new version of themself 
18:09:47 <Koterpillar> that's not what monads are
18:10:19 <thimoteus> are burritos monadic?
18:10:28 <dwynwen_ddlleyw> Then I am at a loss for what a monad is 
18:10:41 <Koterpillar> if you define bind and return for burritos, yes
18:10:48 <pyon> dwynwen_ddlleyw: A monad is anything for which the monad laws can be verified to hold.
18:10:55 <Koterpillar> if you define bind and return for jqueries, yes
18:11:00 <dwynwen_ddlleyw> Okay but that doesn't make sense 
18:11:02 <pyon> Koterpillar: Don't forget the laws!
18:11:08 <dwynwen_ddlleyw> I don't understand these laws or whatever 
18:11:10 <pyon> If the laws don't hold, it isn't a monad.
18:11:33 <dwynwen_ddlleyw> I try but it doesn't really make sense 
18:11:36 <thimoteus> i'm gonna make a burrito so tasty the laws have to hold
18:11:54 <shachaf> Please take the burrito jokes elsewhere.
18:11:56 <pyon> dwynwen_ddlleyw: A good place to start is the Typeclassopedia.
18:12:47 <dwynwen_ddlleyw> Wow
18:12:53 <dwynwen_ddlleyw> Such help 
18:13:35 <pyon> Sorry, I mostly just lurk here. Don't take my lack of helpfulness as representative of the community. :-|
18:14:13 <Koterpillar> dwynwen_ddlleyw: what made you think jquery is monadic?
18:14:30 <c_wraith> There was a blog post that claimed it
18:14:39 <dwynwen_ddlleyw> I have looked at typeclassopedia before and it just gives cryptic haskell code for the efinition of a monad 
18:15:09 <Koterpillar> I personally like "Railway Oriented Programming" as a monad tutorial
18:15:34 <Koterpillar> actually, jQuery.deferred is close to a Cont monad
18:15:47 <Koterpillar> c_wraith: was is deferred() or something else?
18:17:03 <systemfault> jQuery 3.0's Promises are monad-like
18:17:57 <perryx> dwynwen_ddlleyw does it really matter if jquery is a monad or not? from a javascript programmer's perspective.. which i assume you are
18:18:35 <dwynwen_ddlleyw> It matters because I am trying to draw similarities between non-functional programming and functional programming 
18:18:39 <Koterpillar> dwynwen_ddlleyw: that blog post might have been right or wrong, share a link
18:18:43 <Rotaerk> dwynwen_ddlleyw, monad is an abstraction, and abstractions are best learned by understanding concrete instances of them, and *intuiting* the common pattern
18:18:50 <Koterpillar> ^^ ++
18:19:07 <dwynwen_ddlleyw> If I can't see some similarity and I can't understand the functional definitions of things then I can't learn functional programming 
18:19:16 <Koterpillar> that's not true
18:19:23 <dwynwen_ddlleyw> It is very true for me 
18:19:32 <Koterpillar> you learned [how?] imperative programming, with nothing to compare it to
18:19:33 <shachaf> That "jQuery is a monad" post is nonsense, and you're better off not reading it.
18:19:59 <Koterpillar> dwynwen_ddlleyw: try "Railway Oriented Programming", it has imperative examples
18:20:01 <dwynwen_ddlleyw> Imperative programming is rooted in steps and instructions which are executed one after the other 
18:20:07 <dwynwen_ddlleyw> That was easy enough to grasp
18:20:57 <dwynwen_ddlleyw> I came to the "jquery is monadic" conclusion myself
18:21:11 <dwynwen_ddlleyw> After seeing some example of monadic like stuff in JS
18:21:20 <systemfault> dwynwen_ddlleyw: How can you if you don't understand what a monad is?
18:21:31 <benzrf> jquery makes use of callbacks
18:21:31 <perryx> dwynwen_ddlleyw are you learning haskell?
18:21:37 <dwynwen_ddlleyw> Because someone was trying to explain it?
18:21:41 <benzrf> so does (>>=) when used with the IO monad
18:23:01 <benzrf> i guess there's also something to be said about how some of the jquery methods act kind of like map
18:23:03 <systemfault> dwynwen_ddlleyw: jQuery can be considered a functor.. but not really a monad
18:23:13 <benzrf> but it doesn't really work
18:24:07 <Rotaerk> dwynwen_ddlleyw, don't try to understand the definition or laws for monads, up front; revisit them *after* you have an intuitive grasp of the concept
18:24:22 <c_wraith> What jQuery doesn't give you is anything that acts like join
18:24:23 <benzrf> Rotaerk: hmm
18:24:23 <dwynwen_ddlleyw> that makes absolutely no sense 
18:24:30 <c_wraith> Because it always flattens any nesting automatically
18:24:33 <shachaf> I recommend the Haskell FAQ entry on this subject:
18:24:36 <shachaf> @faq
18:24:37 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:24:37 <c_wraith> Which means it's not a monad.
18:25:02 <systemfault> dwynwen_ddlleyw: Don't learn monad, learn functor... monad will come naturally after because it's basically the same thing.
18:25:09 <dwynwen_ddlleyw> Every time I go looking for answers I am told to look at something more abstract or something more concrete. Neither of which I can actually understand without knowing what the stuff I was looking for is
18:25:30 <c_wraith> dwynwen_ddlleyw: I will tell you something else.  Don't go looking for it at all.
18:25:52 <c_wraith> dwynwen_ddlleyw: trying to learn monads by studying hasn't worked in the history of learning haskell.
18:25:58 <dwynwen_ddlleyw> So essentially don't learn the language 
18:26:03 <c_wraith> No, learn haskell.
18:26:05 <shachaf> In particular, section 8.3:
18:26:07 <shachaf> https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
18:26:08 <c_wraith> Once you do, monads are obvious.
18:26:12 <benzrf> systemfault: holy shit no its not
18:26:25 <dwynwen_ddlleyw> How am I going to learn the language if I can't learn even a part of the language 
18:26:26 <systemfault> benzrf: Damn right it is.
18:26:49 <benzrf> monads are functors with specific properties
18:26:51 <pyon> dwynwen_ddlleyw: Monads aren't a part of the language. They're a part of the standard library. (Well, there's some syntactic sugar support.)
18:26:55 <c_wraith> dwynwen_ddlleyw: That's like asking how you can possibly learn java until someone teaches you what an Iterator is.
18:26:56 <xaviergmail> The google talk about monads helped me a bit dwynwen_ddlleyw 
18:27:01 <benzrf> they're only similar in the sense that every monad is a functor
18:27:21 <benzrf> dwynwen_ddlleyw: seriously, monads get talked up WAY too much
18:27:22 <c_wraith> dwynwen_ddlleyw: the fact is, it's not an important part of the language, in terms of learning the languag.e
18:27:27 <perryx> if you're not learning haskell knowing what a monad is won't help you much. most other languages' don't use monadic abstractions, and they can't even make a useful monadic abstraction because their type system isn't expressive enough
18:27:29 <benzrf> c_wraith++
18:27:40 <Koterpillar> dwynwen_ddlleyw: no haskell books/tutorials mention monads till about chapter 5
18:27:41 <Axman6> dwynwen_ddlleyw: how are you supposed to understand Java factories if you don't know what an object is? you need to learn the basics before learning the things build on them basics
18:27:57 <dwynwen_ddlleyw> Objects make sense though 
18:28:04 <benzrf> dwynwen_ddlleyw: what's an object, then?
18:28:08 <Rotaerk> dwynwen_ddlleyw, do you know what Maybe is?
18:28:12 <dwynwen_ddlleyw> They are so easy to explain to someone on the street it's not funny 
18:28:20 <c_wraith> dwynwen_ddlleyw: hahahahah.  no.  they don't.  Explain inheritence in a way that isn't hand-wavey.
18:28:25 <benzrf> "easy to explain" is not always the same as "useful"
18:28:28 <benzrf> they're orthogonal
18:28:30 <dwynwen_ddlleyw> An object is a description of something more or less 
18:28:39 <benzrf> dwynwen_ddlleyw: noooooooo that's way too general
18:28:44 <dwynwen_ddlleyw> It really isn't 
18:28:45 <benzrf> there's all kinds of descriptions that aren't objects
18:28:46 <Axman6> objects make no sense to someone on the street
18:28:57 <Rotaerk> an object is a thingy
18:29:11 <dwynwen_ddlleyw> You can use a car to explain an object 
18:29:24 <Rotaerk> dwynwen_ddlleyw, do you know what Maybe is?
18:29:30 <benzrf> dwynwen_ddlleyw: you can use a car as an example of an object, but you can't explain what an object is using a car
18:29:32 <c_wraith> Axman6: I feel like Iterator is a better example.  When people object that haskell gives special syntactic sugar for monads, you point out java gives out special syntactic sugar for Iterators, and it *still* doesn't make them an important part of learning the language.
18:29:33 <nshepperd> [swift]: if it's so easy then you'll have no trouble going away and learning all about data types and all the things in https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F before trying to learn monads
18:29:34 <pyon> dwynwen_ddlleyw: No, a car isn't an example of an object in computer programming.
18:29:41 <nshepperd> wtf
18:29:46 <nshepperd> dwynwen_ddlleyw: ^^
18:29:49 <pyon> dwynwen_ddlleyw: You'd be surprised - a proper definition of “object” is quite technical: http://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html
18:30:01 <Axman6> c_wraith: it was just an example of advanced topics being built on fundamental ones
18:30:41 <dwynwen_ddlleyw> http://image.slidesharecdn.com/introductiontoobjectorientedprogramming-141212062931-conversion-gate01/95/introduction-to-object-oriented-programming-24-638.jpg?cb=1448026569
18:30:54 <Koterpillar> dwynwen_ddlleyw: don't worry about definitions
18:30:58 <dwynwen_ddlleyw> If you want to be obtuse and completely technical that's your business 
18:31:06 <nshepperd> can we not get hung up on how to explain objects
18:31:07 <benzrf> dwynwen_ddlleyw: the real problem is that it's possible to use objects without fully understanding them
18:31:19 <nshepperd> this isn't event relevant
18:31:19 <benzrf> dwynwen_ddlleyw: but *feeling* like you more-or-less get it
18:31:28 <benzrf> with monads, you will not feel like you more-or-less get it unless you really do get it
18:31:37 <nshepperd> monads aren't like objects.
18:31:42 <Rotaerk> IMO mathematical/formal definitions are useful for rigorous reasoning, but not for learning
18:31:43 <nshepperd> monads are like Iterable
18:31:48 <dwynwen_ddlleyw> And the standard library is built on monads 
18:31:54 <benzrf> dwynwen_ddlleyw: no it's not
18:31:54 <systemfault> Rotaerk: Yup.
18:31:57 <Koterpillar> nshepperd: I think that put you back into burrito territory
18:31:59 <c_wraith> dwynwen_ddlleyw: it's really not.
18:32:22 <benzrf> dwynwen_ddlleyw: many of the types in the standard library are monads, but that's irrelevant to what the types are
18:32:23 <Rotaerk> dwynwen_ddlleyw, you gonna answer my question? :\
18:32:28 <nshepperd> Koterpillar: in the sense that it's an interface that happens to be in the standard library
18:32:28 <c_wraith> dwynwen_ddlleyw: The standard library has lots of types that happen to be monads, but you can ignore that for basically every type except IO, and then pretend do blocks are special for IO.
18:32:34 <benzrf> dwynwen_ddlleyw: just as many of the types in the java standard library are Iterable, but that's irrelevant to what the type is
18:32:37 <dwynwen_ddlleyw> How would I know what Maybe is
18:32:56 <c_wraith> dwynwen_ddlleyw: perhaps by having made an honest attempt to learn haskell?
18:33:00 <Axman6> dwynwen_ddlleyw: by reading any basic introductory text on Haskell >_<
18:33:06 <Axman6> how would you know what addition is?
18:33:07 <Koterpillar> dwynwen_ddlleyw: don't worry about monads if you want to learn functional programming. Worry about *functions* first
18:33:08 <systemfault> dwynwen_ddlleyw: The closest thing to a monad JS has is "Promise"
18:33:10 <benzrf> i feel like this is getting very dogpily and kind of hostile
18:33:13 <Axman6> how would you know what an if statment is?
18:33:15 <benzrf> i think we should all back down
18:33:16 <Axman6> same answer
18:33:20 <Koterpillar> benzrf: ++
18:33:31 <Rotaerk> dwynwen_ddlleyw, it's a very simple type in haskell; it also happens to be a monad, so getting an understanding of Maybe will be a good first step towards understanding monads
18:33:45 <Rotaerk> understand Maybe, then understand how >>= works with it in particular...
18:33:46 <pyon> dwynwen_ddlleyw: “How would I know what Maybe is” --> By reading the definition: “:i Maybe” in GHCi says “data Maybe a = Just a | Nothing”.
18:34:04 <systemfault> That's useless for a JS dev.
18:34:10 <Rotaerk> well you can also just google "haskell maybe" :P
18:34:17 <benzrf> seriously guys
18:34:19 <benzrf> back down
18:34:22 <systemfault> ^
18:34:24 <Koterpillar> ^
18:35:01 <Rotaerk> dwynwen_ddlleyw, once you understand Maybe, and how >>= works for it... move on to, say, lists, and understand how >>= works for them
18:35:31 <Rotaerk> and do the same for a few other simple instances of Monad... you should start to see a pattern
18:35:31 <Koterpillar> but even before all that, learn more about functions... which you know from JS and elsewhere
18:35:54 <benzrf> Koterpillar: haskell functions are pretty different from js functions
18:35:58 <benzrf> they're not really the same kind of thing
18:36:19 <Koterpillar> similar enough not to be intimidating
18:36:26 <benzrf> true
18:36:29 <Rotaerk> hmm isn't a JS function analogous-ish to a function that returns an IO
18:36:32 <nshepperd> Rotaerk: learning about data types and functions and laziness should probably come before even that
18:36:44 <DrEntropy> Maybe (pun?) you might enjoy http://haskellbook.com/
18:36:50 <Rotaerk> nshepperd, yea, I was addressing his original issue of ... learning monads
18:36:58 <systemfault> functions are either functions or procedures depending on how they're used, no?
18:37:01 <systemfault> (In JS)
18:37:06 <Rotaerk> but yea, he needs to learn the basics first
18:37:22 <systemfault> I mean, you can write a referentially transparent function in JS.
18:37:22 <benzrf> Rotaerk: do you know that "he" is the right pronoun
18:37:33 <Koterpillar> dwynwen_ddlleyw: pick a good book and start from the basics
18:37:39 <mayhew> I'm pretty new to Haskell, but can't you write useful programs with some basic knowledge of just the IO and Maybe monads?
18:37:56 <Rotaerk> benzrf, no, but I prefer to use "he" rather than littering everything with "he/she"
18:37:57 <Koterpillar> mayhew: you don't even need monads to write useful programs
18:37:58 <perryx> from what I gathered he wants to learn what monads are because he feels it will help his javascript coding
18:37:59 <nshepperd> there's a lot of mysticism about monads, isn't there
18:38:03 <benzrf> Rotaerk: that's kind of exclusionary
18:38:08 <perryx> not because he wants to be productive in haskell
18:38:08 <benzrf> mayhew: you don't need to even know the maybe monad_cat 
18:38:13 <benzrf> *monad
18:38:18 <Rotaerk> benzrf, blame English
18:38:22 <benzrf> mayhew: you can use Maybe without knowing about how it's a monad
18:38:25 <benzrf> Rotaerk: just say 'they'
18:38:34 <nshepperd> ('they' is valid english)
18:38:37 <Rotaerk> they works when you're talking about an abstract person, not a concrete one
18:38:38 <Koterpillar> benzrf: Rotaerk: other languages are even worse
18:38:43 <perryx> benzrf you said "guys" earlier
18:38:47 <benzrf> systemfault: i tend to prefer "pure" to "referentially transparent" - iirc, "referentially transparent" originally had a very different kind of meaning, and it's sort of ambiguous even now
18:38:53 <benzrf> perryx: true, i should probably work on that :\
18:39:05 <QtPlatyp1s> Rotaerk: They also works when talking about a singular person.
18:39:08 <Rotaerk> guys is very common as a gender-neutral collective
18:39:10 <systemfault> benzrf: Ah, well :P I'll use pure next time... wait shorter to write.
18:39:11 <benzrf> Rotaerk: that's very prescriptivist
18:39:16 <dwynwen_ddlleyw> I have been trying to learn haskell 
18:39:30 <systemfault> dwynwen_ddlleyw: Did you get functors?
18:39:33 <Rotaerk> benzrf, what is?
18:39:37 <dwynwen_ddlleyw> No
18:39:40 <benzrf> Rotaerk: "they works when you're talking about an abstract person, not a concrete one"
18:39:59 <Rotaerk> benzrf, oh, yes
18:40:05 <nshepperd> I haven't noticed any special difference between abstract and concrete people
18:40:07 <Rotaerk> I agree
18:42:17 <benzrf> dwynwen_ddlleyw: what have you been doing to learn haskell?
18:42:35 <benzrf> dwynwen_ddlleyw: if it involves trying to learn about monads first, it's probably not a very good approach :p
18:42:44 <coppro> XD
18:42:52 <dwynwen_ddlleyw> I have been trying to look at code that's already written and trying to understand it 
18:42:59 <benzrf> oh
18:43:11 <benzrf> to be frank, that's a little like trying to learn to program in the first place by reading code
18:43:20 <systemfault> dwynwen_ddlleyw: Won't work for Haskell, you have to relearn to program from scratch to learn it.
18:43:23 <Rotaerk> dwynwen_ddlleyw, that might work if you're coming from C++ to Java, or something
18:43:34 <Rotaerk> but haskell is a very different animal from most languages
18:43:51 <benzrf> yeah
18:44:39 <nshepperd> dwynwen_ddlleyw: You don't need to know about functors or monads until you've learned about data types, functions, polymorphic functions and typeclasses, in approximately that order
18:44:57 <nshepperd> apparently haskellbook.com is a good resource for learning??
18:45:04 <benzrf> doesnt that cost money
18:45:17 <systemfault> nshepperd: It's awesome but not cheap.
18:45:22 <nshepperd> oh
18:45:33 <systemfault> I'm canadian and... it hurts the wallet.
18:45:39 <Koterpillar> http://book.realworldhaskell.org/ http://learnyouahaskell.com/
18:45:42 <systemfault> (US/CA rates are bad)
18:46:22 <Axman6> try being Australian
18:46:33 <benzrf> so is it true that in ghc 8 the type level is fully dependent
18:46:38 <coppro> no
18:46:41 <benzrf> aww
18:46:48 <coppro> it's true in idris and agda though
18:46:51 <sm> dwynwen_ddlleyw: how's it going ?
18:47:11 <sm> the code reading
18:47:17 <dwynwen_ddlleyw> I am doing something that isn't going to overwhelm me atm
18:47:39 <benzrf> coppro: well of course it's true in idris and agda
18:47:49 <nshepperd> I don't really understand what TypeInType does but I gather that it's the bee's knees
18:47:52 <benzrf> they're dependently typed as a whole
18:48:43 <benzrf> nshepperd: i was under the impression that it turns the type level into a fully dependently typed system
18:49:20 <benzrf> well... i guess "fully dependently typed" can mean a lot of things
18:49:41 <benzrf> make that: i heard that it collapses all levels above the value level, so that types of types are just other types
18:49:57 <benzrf> like how in CoC-style languages, types are just other terms
18:50:18 <fishythefish> benzrf: AFAIK, it's step 1 in moving toward a fully dependent typed Haskell
18:50:25 <fishythefish> I have the paper open in a tab for later though :P
18:50:33 <benzrf> i didnt think there were plans to make haskell dependently typed
18:50:37 <benzrf> wouldnt you basically just get idris
18:50:44 <benzrf> oh, laziness i guess
18:51:07 <benzrf> does it let you promote functions or anything :>
18:51:12 <systemfault> benzrf: What are CoC-style languages?
18:51:30 <benzrf> systemfault: if you dont know type theory, just ignore my comment
18:51:47 <fishythefish> systemfault: it's the basis for Coq, if you've heard of that
18:52:02 <systemfault> benzrf: Can I at least have the complete name? :(
18:52:06 <benzrf> calculus of construction
18:52:07 <fishythefish> Calculus of Constructions
18:52:08 <benzrf> s
18:52:23 <systemfault> fishythefish: I heard of Coq, but I only know it's a theorem prover
18:52:27 <systemfault> Thank you :)
18:52:44 <benzrf> i was just contrasting with the style of system that has separate term and type levels but then has means for reflection between them
18:52:45 <foobard> with Control.Monad.Parallel is there a way to limit the number of parallel threads for mapM ?
18:52:49 <benzrf> e.g. vanilla MLTT, iirc
18:52:59 <fishythefish> systemfault: it allows you to do programming with dependent types as well - other proof assistants are also based on CoC
18:53:12 <fishythefish> systemfault: if you're interested, check out Software Foundations
18:53:25 <benzrf> fishythefish: it's not so much "as well" as "they're the same thing"
18:53:31 <systemfault> fishythefish: A book?
18:53:52 <systemfault> fishythefish: This?  https://www.cis.upenn.edu/~bcpierce/sf/current/index.html
18:54:05 <fishythefish> benzrf: true, although contrast with Agda - Coq's primary focus is on the proofs IMO, while Agda's is on the programming
18:54:09 <fishythefish> systemfault: yup!
18:54:19 <systemfault> fishythefish: Awesome, thanks :)
18:56:10 <fishythefish> anyway, as I understand it, the main points of type in type are to make types and kinds the same (so promotion is a no-op) and adding kind equality
18:56:20 <fishythefish> and it implies DataKinds, so you can promote constructors
18:56:25 <fishythefish> but I'm no expert
18:57:04 <benzrf> Tfw the halting problem is undecidable
18:57:20 <mike__> If I have a list and I want to concatenate it with itself x times, what's the simplest way to do that?
18:57:24 <benzrf> if only we could have dependently typed languages that can infer everything ;-;
18:57:52 <benzrf> mike__: you could do:
18:57:57 <benzrf> > concat (replicate 3 "abcd")
18:57:58 <lambdabot>  "abcdabcdabcd"
18:58:39 <Koterpillar> > take 12 (cycle "abcd")
18:58:41 <lambdabot>  "abcdabcdabcd"
18:59:21 <dolio> benzrf: You can already do stuff like, `f :: * -> * ; f x = x` in GHC 8.
18:59:49 <dolio> But f will not be in the same namespace as any element of *, so it's kind of useless.
19:00:08 <dolio> Except undefined, of course.
19:00:53 <benzrf> dolio: ooh, nice!
19:01:38 <benzrf> wait, so - does this mean types live at the same level as ordinary terms, now?
19:01:43 <benzrf> how does namespacing work then
19:01:52 <dolio> Same way as always.
19:03:11 <benzrf> erm
19:03:18 <benzrf> oh wait
19:03:35 <dolio> Kind and type levels became the same namespace, I guess.
19:03:44 <dolio> But value and type/kind are separate.
19:04:12 <dolio> Data types are replicated up to the type level, but type stuff isn't in the value namespace.
19:05:14 <benzrf> hold on.
20:11:31 <gaze__> Hey, if you were writing bindings to a c library right now, what would you use to do it?
20:11:40 <gaze__> bindings-DSL sems popular
20:12:15 <peddie> gaze__: I've had pretty good luck with recent versions of c2hs
20:12:20 <glguy> I default to hsc2hs
20:13:09 <koz_> What's the easiest way to reverse a sort order?
20:13:33 <koz_> (I need sortOn to sort in reverse order based on the values the function spits out)
20:15:45 <gaze__> peddie, glguy: How about inline-c?
20:16:02 <peddie> gaze__: not familiar with it; sorry
20:16:34 <marchelzo> koz_: consider using sortBy
20:16:36 <pavonia> koz_: sortBy (flip compare)?
20:16:38 <glguy> No, that looked like a lot more of a mess than I usually want
20:17:00 <pavonia> > sortBy (flip compare) [3,6,2,4,5,1]
20:17:02 <lambdabot>  [6,5,4,3,2,1]
20:17:32 <glguy> I don't think there is a sortOnBy in base
20:17:47 <pavonia> :t sortOn
20:17:48 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
20:18:13 <glguy> Project to a type where the sort order is reversed
20:19:01 <koz_> glguy: I'm projecting to Ratio Int.
20:19:08 <glguy> newtype ReverseOrd a = RO a, make an Order instance that works backward normal
20:19:26 <glguy> Then  sortOn (RO . whateverYouHad)
20:19:30 <pavonia> > sortOn negate [3,6,2,4,5,1]
20:19:35 <lambdabot>  mueval-core: Time limit exceeded
20:19:46 <pavonia> > sortOn negate [3,6,2,4,5,1]
20:19:47 <lambdabot>  [6,5,4,3,2,1]
20:20:05 <glguy> Yeah, negate will be good for Ratio Int
20:20:14 <glguy> Also never use Ratio Int
20:20:31 <glguy> Always Ratio Integer aka Rational
20:20:45 <koz_> glguy: How come?
20:21:11 <glguy> Ratio Int produces nonsense results, overflows very easily
20:21:23 <glguy> Even for seemingly small values
20:22:07 <koz_> glguy: OK, I'll use Rational then.
20:22:57 <glguy> (x:%y) <= (x':%y') = x * y' <= x' * y
20:23:45 <glguy> That's how less than or equal to its defined. And that multiplication can overflow and produce bad comparisons
20:25:04 <koz_> glguy: I see. Is there a nicer way to write this, then: 'fromIntegral (i - countRows t) % fromIntegral i' ?
20:25:13 <koz_> i and countRows t are both Ints, obviously.
20:25:26 <EvanR> > pi / (sqrt 2) :: Ratio CReal
20:25:28 <lambdabot>      No instance for (Floating (Ratio CReal)) arising from a use of ‘pi’
20:25:28 <lambdabot>      In the first argument of ‘(/)’, namely ‘pi’
20:25:28 <lambdabot>      In the expression: pi / (sqrt 2) :: Ratio CReal    No instance for (Inte...
20:25:42 <EvanR> > pi % (sqrt 2) :: Ratio CReal
20:25:43 <lambdabot>      No instance for (Integral CReal) arising from a use of ‘%’
20:25:44 <lambdabot>      In the expression: pi % (sqrt 2) :: Ratio CReal
20:25:53 <EvanR> shoot
20:26:41 <glguy> Koz_: looks right
20:26:50 <slack1256> Would you guys say having `where` closures with 5-6 interrelated definitions is an anti-pattern?
20:28:22 <glguy> What happens when anti patterns and patterns touch?
20:28:39 <slack1256> bikesheddin happens
20:29:37 <slack1256> sorry, maybe I am tired of reading picForState :^)
20:29:53 <koz_> glguy: No simpler way to write that? Goddamn that's a pain.
20:30:31 <EvanR> slack1256: i like putting everything in a where
20:31:16 <EvanR> which is sort of a pain in idris because order dependence and typical failure to infer the types
20:31:25 <EvanR> haskell is nice and smooth
20:31:41 <slack1256> when there are 2-3 definitions each calling the previous one is manageable
20:32:26 <EvanR> recursion is cool too
20:33:31 <slack1256> with 6+ definitions calling each other as if they where their own module and passing the final call to a common `continue` definition
20:33:47 <slack1256> well I don't see where we where going
20:49:33 <hwkng> let (myChan :: Chan a); is thread-1 is trying to read from myChan; and no one else has a reference to myChan, will haskell reason "no one else can write to myChan; therefore let me kill thread-1" ?
20:56:05 <EvanR> yep
20:56:25 <EvanR> its a special case of the "blocked indefinitely on an MVar" exception
20:57:48 <glguy> GHC might kill your thread, but it's not a promise
21:00:10 <EvanR> so basically arrange for this not to happen since its either garbage on your stderr or a resource leak
21:20:47 <koz_> Is there a way I can get a list of every nth item of another list, for some n?
21:22:15 <Koterpillar> map head . splitEvery
21:22:21 <kadoban> koz_: You could map head . chunksOf whatever
21:22:54 <koz_> Koterpillar: Where's splitEvery from?
21:22:58 <Koterpillar> Data.List.Split
21:23:10 <glguy> using   iterate (drop n)    will avoid making new lists
21:34:01 * hackagebot Glob 0.7.8 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.8 (MattiNiemenmaa)
21:41:41 <koz_> Is there a way to convert a Rational into its nearest Int (by rounding)?
21:42:15 <glguy> floor
21:42:20 <glguy> round, ceiling
21:42:27 <coppro> ^
21:42:47 <koz_> glguy: OK, should have checked the types more thoroughly.
21:44:47 <EvanR> is Int at least 30 bits wide?
21:45:01 <EvanR> or 31
21:45:07 <glguy> It's probably in the report
21:45:23 <EvanR> it says -2^29 to +2^29 - 1
21:45:49 <glguy> so 30 bits in total
21:46:31 <coppro> 30
21:46:48 <glguy> Int32 gets us 2^31-1
21:46:56 <glguy> and that's 32 bits in total
21:47:05 <coppro> I wonder why 30
21:47:11 <coppro> because it holds 1000000000?
21:47:22 <coppro> oh wait
21:47:26 <coppro> Int is 31 bits
21:47:30 <coppro> sign bit
21:47:38 <Koterpillar> there might be a marker bit, too
21:47:47 <c_wraith> GHC Int is 32 or 64 bits, depending on version
21:47:51 <glguy> Yeah, it's in case an implementation wants some bits for itself
21:49:41 <EvanR> has any implementation ever use those bits?
21:49:54 <coppro> *bit
21:50:05 <EvanR> 32 - 30 = 2
21:50:26 <EvanR> shave and a haircut
21:50:32 <coppro> wait I can't count
21:50:33 <coppro> lol
21:50:47 <coppro> wait...
21:50:49 <glguy> EvanR: iirc o'caml uses them (not Haskell but similar)
21:50:59 <coppro> yes ok
21:50:59 <EvanR> o'rly
21:51:12 <Koterpillar> afaik Ruby uses them
21:51:17 <Koterpillar> what's the right term for those bits?
21:51:44 <c_wraith> tag bits
21:51:48 <c_wraith> usually
21:51:54 <glguy> Googling it looks like o'caml uses one tag bit for GC
21:51:54 <EvanR> ruby essentially has Integer only
21:52:18 <EvanR> internally it may use machine int or bigint
21:52:24 <EvanR> like Integer does
21:52:42 <Koterpillar> ruby has Fixnum and Bignum
21:53:04 <Koterpillar> http://www.sarahmei.com/blog/2009/04/21/object-ids-and-fixnums/
21:53:07 <EvanR> theyre not really distinguishable... except by checking their class 
21:53:28 <EvanR> it auto converts
21:54:45 <EvanR> i wouldnt make a distinction in a ruby type system... which of course im forever working on
21:57:41 <Denommus> are you guys still awake?
21:58:04 <dmj`> Denommus: sup
21:58:17 <Koterpillar> Denommus: there are more than 5 timezones in the world
22:01:23 <hwkng> this is sorta off topic; but is there a 20-30 page, math heavy, concise definition of relational theory? (rather than books on SQL, or books by CJ Date which tend to go at 400+ pages) -- I just want the math theory behind relational theory, and nothing else
22:01:34 <Denommus> nevertheless
22:01:47 <Denommus> I'm trying to use a GHCJS app in Cordova
22:01:54 <Denommus> but I need to bundle CSS with it
22:02:17 <ertes> hwkng: the theory behind relational databases is called relational algebra
22:02:18 <Denommus> data-files puts CSS in a share directory on installation
22:02:45 <Denommus> is there any way I can get my CSS inside my .jsexe?
22:03:13 <ertes> hwkng: it's basically an algebra for product sets with named components
22:03:28 <hwkng> ertes: does it cover things like third normal form?
22:03:32 <hwkng> ertes: that's where I get tripped up
22:04:29 <ertes> hwkng: it's a formal semantics, so depending on the way you think it may be simpler or more complicated, but more likely simpler
22:06:20 <hwkng> ertes: I'm looking at https://en.wikipedia.org/wiki/Relational_algebra and I don't see third normal form
22:06:30 <hwkng> ertes: so are the normal forms part of relational algebra, relational theory, or SQL-junk ?
22:07:36 <ertes> hwkng: you can express normal forms in terms of relational algebra
22:07:52 <ertes> hwkng: they are not exclusive to any language
22:08:37 <ertes> hwkng: also note that most database systems don't implement RA exactly:  RA uses sets, whereas RDBMSes use multisets (you can have relations with non-unique rows)
22:09:22 <hwkng> ertes: I'm implementing a toy in haskell; i.e. a simpler variant of project M36
22:44:23 <lpaste> telmich pasted “pattern/guard” at http://lpaste.net/168647
22:45:40 <telmich> I am trying to write a function to split a string like "abc,def,xxx" to a list ["abc", "def", "xxx"] - however it looks like my guard/pattern matching combination doesn't work
22:46:36 <telmich> I was wondering 2 things: a) what's wrong with the pattern matching/guard combination? b) the code looks rather complicated - can you give me a hint on where to look to make it easier to read?
22:47:01 <Koterpillar> unless you are writing this as an exercise, it's Data.List.Split.splitOn
22:47:07 <shachaf> Your problem description doesn't work.
22:47:32 <Koterpillar> shachaf: I am stealing this phrase!
22:47:33 <telmich> Koterpillar: it actually is an exercirse, but thanks a lot for the hint!
22:48:52 <Koterpillar> telmich: If I'm reading it right, you should have got a hint from GHC that explains where are you wrong
22:49:05 <Koterpillar> something like "you're using [a] but it's a"
22:49:25 <Koterpillar> by the way, does your function have to be specialized on Char?
22:50:42 <telmich> Koterpillar: it has to be from the exercise, but otherwise, no
22:51:21 <telmich> Koterpillar: indeed, I get complaints about Char vs [Char], however I haven't seen it as the error message scrolled out of my window (50+ lines of errors)
22:52:05 <Koterpillar> you'll need a better terminal for Haskell...
22:52:12 <EvanR> yo I made a table of haskell's most popular (and some not so popular) numeric types https://github.com/haskellcats/haskell-numbers
22:53:03 <Koterpillar> telmich: hint: last line
22:53:46 <Koterpillar> what are the types of all the values there?
22:55:38 <telmich> Koterpillar: wow. I'm standing in front of a closed door. so I planned: found should be [String], current should be [Char]
22:56:10 <telmich> so can use found later for returning the list and current to append all characters until the next separator
22:56:28 <Koterpillar> there are more values in the last line
22:56:45 <Koterpillar> what are their types?
22:57:05 <Koterpillar> in fact, there are 7 values
22:58:25 <telmich> x is Char, xs is [Char], found is [String], current is [Char], [current] is [String]
22:59:03 <Koterpillar> do you see the error yet? if not, go through your expressions
22:59:11 <telmich> Koterpillar: with last line: ddi you refer to the last line of the errors or my code?
22:59:23 <Koterpillar> last line of your code, I didn't see your errors
22:59:47 <Koterpillar> I can give you another hint but it'll be really obvious afterwards
22:59:53 <telmich> ah. because according to ghc the error is in the line | x == s    = split' s xs (found ++ [current]) ""
22:59:56 <telmich> not in the last line
23:00:15 <telmich> Koterpillar: I'll double check my code first, thanks a lot
23:00:22 <Koterpillar> does it change if you annotate split' with a type you think it is?
23:00:29 <Koterpillar> ghc might have guessed wrong
23:02:04 <telmich> it actually changes quite a lot, will have a look at my new error
23:03:17 <Koterpillar> if you have type errors, either your or GHC's understanding of types is wrong
23:03:33 <Koterpillar> => more type annotations will help
23:03:38 <telmich> ok, found the first error
23:04:18 <telmich> split' _ [] found x  = found ++ x changed to split' _ [] found remaining  = found ++ [remaining]
23:04:44 <telmich> And now I get a hint for an error in the last line..yeah!
23:04:52 <Koterpillar> ^_^
23:05:33 <telmich> naaaaaarf
23:05:35 <telmich> [x]
23:06:51 <telmich> Koterpillar: thanks a lot
23:07:10 <Koterpillar> you're welcome
23:13:35 <LettuceThree> Repa question: I'm doing a stencil over an array and it's doing a *ton* of allocation. It's taking most of my program time. How do I ensure that the stencil does only unboxed computation?
23:13:58 <LettuceThree> The array is an unboxed double array
23:33:42 <Reshi> Has anyone used functionaljobs.com? Do you think applying through the employers direct website also is ideal? Or applying through mailing functionaljobs is enough?
23:45:58 <zomg> Reshi: usually you should apply using whatever method they want you to use because that's what the employer will be expecting them to come in from
23:46:25 <zomg> Of course that doesn't mean you shouldn't reach out to them to perhaps ask about it, or see if you know anyone who could refer you to them
23:47:44 <Reshi> zomg: the emplyer has an ad on functionaljobs, but the method to apply on the website is emailing someone@functionaljobs.com, on the employers website they ask you to email them. Does functionaljobs forward it or something? 
23:48:32 <zomg> dunno, if they have the ad on both and it says either email them or email @functionaljobs, then I'd imagine emailing them directly is just fine
23:48:35 <EvanR> email them directly sounds better than the alternatives, unless functionaljobs has a point system or something
23:53:21 <Reshi> zomg, EvanR: Thanks, I will ask them 
