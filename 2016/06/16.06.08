00:00:48 <crodjer> Hmm, Wayland doesn't have much adoption right now.
00:01:25 <Koterpillar> it's usable
00:01:28 <crodjer> `WayMonad` could be a nice project name if someone plans to start.
00:03:20 * hackagebot yi 0.12.6 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.6 (DmitryIvanov)
00:55:24 <tero-> I'm trying to design a type class for a Servant CRUD API, https://gist.github.com/tlaitinen/b37423c3c16b1c3590e78af603cfdc6b but I have a problem with type signatures
00:57:48 <tero-> I understand that ghc cannot deduce "a" if only Out a and Query a are given. would it work with a phantom type or is there a better trick?
01:03:06 <tobiasBora> Hello,
01:03:16 <tero-> e.g. if I return App [(a, Out a)] then it works
01:03:21 <tobiasBora> I'm trying to plot some graph with the haskell frontend of Gnuplot
01:03:33 <tobiasBora> However I cannot put accents in this file
01:04:24 <tobiasBora> I saw that usually you need to use iso_8859_1 encoding, and then run in the gnuplot file "set encoding iso_8859_1"
01:04:40 <tobiasBora> How could I do the same thing in haskell ?
01:24:10 <merijn> tero-: The problem is that "Query a" is replaced by it's result when type checking and not guaranteed to be unique
01:24:25 <merijn> tero-: Suppose "Query Int" produces Bool, but "Query Char" produces Bool too
01:24:50 <lemonxah> good morning 
01:25:06 <merijn> tero-: Then GHC sees "getAll  :: UserId -> Maybe Bool -> ..."
01:25:16 <merijn> tero-: Which means it doesn't know how to select the right instance
01:25:17 <lemonxah> could anyone suggest a good book that i could read to learn haskell?
01:25:42 <tero-> merijn: yes this I understood and I can help the type checker by adding "a" in the type signature to make the type function applications unique. but is there a more elegant way to do this?
01:26:20 <merijn> tero-: Usually you would use "Proxy" to add dummy arguments for instance selection
01:26:54 <merijn> tero-: There's not really a better way than "add a dummy argument to functions"
01:27:12 <merijn> lemonxah: https://github.com/bitemyapp/learnhaskell and http://haskellbook.com/
01:27:15 <tero-> merijn: is this related/relevant https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies ?
01:27:18 <dramforever> GHC 8 supports explicit type applications which may or may not help
01:27:33 <quchen> lemonxah: If you're looking for something you can read in bed, there's Learn You A Haskell, which is what sparked my interest. It covers only the very basics though.
01:27:53 <merijn> tero-: It's related, yes. The lack of injectivity of type families is what allows "Query Char -> Bool" and "Query Int -> Bool"
01:28:10 <merijn> tero-: Injective type families say that every argument type maps to a DIFFERENT result type
01:28:44 <lemonxah> thank you guys, i am trying to move from scala to haskell so i want to not try find similarities i want to start from scratch
01:29:12 <dramforever> lemonxah: that's a very good way to learn haskell imho
01:29:32 <lemonxah> yeah i found its the best way to learn any new language
01:29:43 <merijn> lemonxah: You *could* also try the tutorial. It's written for people with typed functional programming experience (specifically ML, etc.), but it's a bit harsh :)
01:29:45 <lemonxah> i know a few but only 1 functional langauge
01:29:53 <merijn> @where gentle
01:29:53 <lambdabot> http://www.haskell.org/tutorial/
01:30:21 <merijn> But...
01:30:25 <merijn> @quote Brend gentle
01:30:25 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
01:30:27 <lemonxah> which is best to use? stack of cabal?
01:30:38 <dramforever> if you try to find similarities, almost all people I've seen are just like, you know, "Hey Haskell is a piece of garbage because I have to emulate loops using this ununderstandable dirty recursion or whatever monads"
01:30:44 <hvr> lemonxah: depends whom you ask
01:30:49 <merijn> lemonxah: Wrong question, stack is a wrapper around cabal
01:31:01 <merijn> lemonxah: So the real question is "stack or use cabal directly"
01:31:14 <lemonxah> ok that makes it clear :) thank you
01:31:18 <dramforever> The problem, of course, is probably that they they did not start from scratch :P 
01:31:25 <quchen> Let's not explain the difference between cabal and cabal-install to a beginner.
01:31:47 <hvr> quchen: but the question is not easy to answer :-)
01:31:51 <lemonxah> i am not a beginner in programming just a beginner in haskell
01:31:59 <dramforever> lemonxah: stack takes care of installing the entire environment, so you might want to use that
01:32:18 <lemonxah> i have installed the environment manually allready
01:32:19 <hvr> quchen: as there's no clear winner, unless you have a specific use-case to use as metric
01:32:46 <quchen> hvr: It's very easy to answer. The question posed was "I'm a beginner what should I use". The question we should answer is "Here's a beginner, let's not make things complicated; use Stack".
01:32:56 <quchen> … question mark somewhere in there
01:33:09 <lemonxah> well when i say manually i followed a guide online
01:33:13 <dramforever> lemonxah: if it works it's good. I've found the transition into stack very easy, so you can use stack later 
01:33:34 <Rotaerk> stack makes package management easy
01:33:34 <quchen> I don't think any beginner ever wanted to start out worrying about package management and dependencies.
01:33:39 <Rotaerk> reminds me a bit of nuget
01:33:40 <tero-> merijn: it's an acceptable constraint. I'll try to use them
01:33:55 <dramforever> quchen: … and somehow this beginner already got GHC working
01:34:19 <quchen> It might be GHC 7.6 on Debian superold.
01:34:20 <merijn> tero-: A common technique is "class Foo a where foo :: proxy a -> Bar"
01:34:20 <lemonxah> quchen i actually do worry about that cause i am learning haskell to write production system in 
01:34:27 <hvr> quchen: I bet you, that Stack has enough confusing beginner unfriendly parts as well
01:34:45 <merijn> tero-: Because we have "data Proxy a = Proxy" which can be used as proxy argument to functions
01:34:58 <hvr> quchen: as soon as you start deviating from Stack tutorials 
01:35:10 <dramforever> lemonxah: Just keep going and remember that you have stack :) And don't forget to ask here, #haskell is probably the most friendly programming channel in the world
01:35:10 <merijn> tero-: (The lower case "proxy" instead of "Proxy a" is so that if you happen to have "Maybe Int" you can use that instead of "Proxy Int")
01:35:44 <Rotaerk> it's probably one of the most populated programming channels too >_>
01:35:55 <lemonxah> dramforever, i dont know :) ppl in here sometimes just expect you to know stuff already :)
01:36:00 <tero-> merijn: okay. actually I want to use ghcjs, too, so maybe ghc 8 is not an option
01:36:00 <hvr> quchen: anyway, I'm biased of course, as I'm contributing lots of my time to Hackage & cabal these days
01:36:26 <Rotaerk> lemonxah, you mean you don't know stuff? :-o
01:36:34 <dramforever> lemonxah: yeah but they'll definitely explain if you ask :)
01:36:45 <lemonxah> here is my useacse i need to connect to a rabbit server read requests from that then read data from a mongo db manipulate it and return that as a response ontot the rabbitmq
01:36:50 <tero-> merijn: thanks for the tip
01:36:59 <lemonxah> using haskell 
01:37:03 <quchen> hvr: Thanks for that :-) I'm not arguing against cabal(install) here!
01:37:38 <dramforever> lemonxah: if you're learning haskell from scratch I'm afraid it's going to take a while from 1 + 1 to rabbitmq/mongodb/etc. :P
01:37:39 <lemonxah> i can use hackage and cabal to get the depencies i need but i am unsure as how to structure a project so that i have multiple files and packages all compile into one app / library
01:37:49 <quchen> hvr: As for Stack, my main criticism would be that it makes people omit version bounds altogether, which isn't good even mid-term
01:38:11 <lemonxah> yeah ofc dramforever but i am sure i would get there soon :)
01:38:26 <lemonxah> might take me a week or 3
01:38:42 <Rotaerk> lemonxah, I kind of felt like I was learning programming all over again, when I learned haskell; unlike when I learned other languages
01:38:53 <dramforever> ...not to disappoint you but I'm really afraid it's too optimistic
01:39:17 <lemonxah> Rotaerk, i felt that way when i learned F# and then again learning Scala
01:39:27 <merijn> lemonxah: Oh, you know F#?
01:39:30 <lemonxah> so i am sure i will experience it again with haskell and that is part of the excitement
01:39:36 <merijn> lemonxah: Then definitely have a look at the tutorial
01:39:41 <lemonxah> yeah
01:40:00 <merijn> Since F# is basically .NET Ocaml 
01:40:17 <dramforever> lemonxah: unless you're quick, then you can jump into the wonderful world of Haskell directly
01:42:38 <hexagoxel> are there free arrows?
01:43:31 <merijn> hexagoxel: ?
01:45:33 <hexagoxel> like, free monads?
01:45:57 <hexagoxel> does the question not make sense?
01:46:28 <merijn> hexagoxel: I doubt it
01:46:37 <merijn> hexagoxel: Moreover, I wouldn't invest too much time in arrows
01:46:54 <hexagoxel> heh, ok.
01:47:06 <merijn> hexagoxel: Instead I would look at combinations of: Category, Profunctor and Applicative
01:47:41 <merijn> hexagoxel: Arrows are not quite the ideal abstraction they were thought to be at inception'
01:59:49 <dramforever> Because Arrow = Strong Category?
02:00:40 <merijn> dramforever: Also avoids the need to have "arr :: Arrow a => (b -> c) -> a b c"
02:01:12 <anewnewbie> Hello, I want to write a small *client-only* library for a REST/JSON API. I have looked at other API binding libraries and have noticed that very few of them use servant or wreq to help themselves out. Most use lower-level libraries (e.g. http-conduit) and make the request manually and parse the results manually. Is there any reaon for this? Should I avoid servant or wreq for this purpose?
02:02:11 <dramforever> anewnewbie: well, if everybody does what you think then nobody will use servant/wreq in bindings...
02:04:13 <anewnewbie> dramforever: so according to you it's a publicity issue? I actually think using servant would be better but I have no experience with it and was wondering whether there there are objective difficulties using it which make it not worthwihile
02:06:00 <dramforever> I think so, but the decision is still up to you.
02:06:13 <dramforever> If you don't know servant the learning it would take time
02:06:18 * geekosaur suspects it's more "don't want more dependencies"
02:07:08 <quchen> How does GHC's current GC differ from the 2008 paper on the subject? http://community.haskell.org/~simonmar/bib/parallel-gc-08_abstract.html
02:07:19 <quchen> Is it still generational, stop the world, copying?
02:07:29 <anewnewbie> dramforever: Thanks for the feedback. Well, since I don't know the other libraries as well (my nickname is quite literal) learning time is something I wouldn't avoid anyway :)
02:07:57 <dramforever> Good luck with your learning :P
02:08:26 <merijn> quchen: AFAIK yes
02:08:45 <merijn> quchen: There's a nursery in there somewhere too
02:09:03 <anewnewbie> dramforever: Thanks, have nice day!
02:09:46 <quchen> merijn: I'm assuming that's an idiom?
02:10:36 <merijn> quchen: nursery is before "generation 0" :)
02:11:05 <quchen> Oh, that sort of nursery. I thought you meant that the GC contains lots of different things or something. :-)
02:11:25 <dramforever> anewnewbie: you're welcome
02:11:54 <quchen> I haven't seen nursery being used to describe a GC at a high level ("generational nursery-containing copying")
02:12:53 <merijn> quchen: I'm just saying that I didn't know if that paper covered the nursery too
02:13:30 <quchen> Ah, gotcha.
02:14:32 <Squarism> ive added :   trace("yeah") $
02:14:32 <Squarism>           error("wooi" ) $
02:14:32 <Squarism>         
02:14:38 <quchen> Just wondering, how do you know these things? You're not using Haskell professionally (slash academically) if I remember correctly.
02:14:53 <Squarism> in a "then" stmt before "let"... nothing happens
02:15:05 <Squarism> compiler doesnt seem to see them
02:15:25 <quchen> Squarism: Seems to be dead code then
02:15:28 <merijn> There's no statements
02:16:08 <Squarism> quchen, what does that mean?
02:16:35 <quchen> Squarism: Your code is not evaluated, so it does not trace or error
02:16:57 <quchen> > snd (error "foo", "hello")
02:16:59 <lambdabot>  "hello"
02:25:24 <quxbam> What data structure is more efficient: data A = A B C   or  newtype A = A (B,C)
02:25:45 <merijn> quchen: Define efficient?
02:25:48 <merijn> eh
02:25:54 <merijn> s/quchen/quxbam
02:26:19 <quxbam> Well, time wise.
02:26:31 <merijn> time wise?
02:26:33 <quxbam> The newtype will get eliminated by the compiler
02:27:24 <quxbam> Let's say you've got a lot of functions which work on an A
02:27:38 <quxbam> to extract or modify B or C
02:28:10 <quxbam> Can they query or update these types with the same speed?
02:29:24 <quchen> I'd expect similar performance from both. There are very subtle pattern matching differences, but I don't remember them.
02:30:25 <quxbam> Perhaps the compiler knows more about tuples because they are so common?
02:31:08 <tero-> merijn: https://gist.github.com/tlaitinen/b37423c3c16b1c3590e78af603cfdc6b this is how I got it to work. In the end I wrap the result in "ProxyOut a" newtype
02:31:43 <osa1> quxbam: I don't think there's any special logic for tuples. they're just products with special type and constructor syntax. unless you have bangs in your `data A = A B C` they should behave the same in every way pretty much.
02:32:17 <osa1> if you had `data A = A !B !C` that would be different. code for pattern matching would still be the same though, only the constructor would be different.
02:32:58 <merijn> tero-: Interesting, I hadn't thought of that :)
02:33:25 * hackagebot ghc-heap-view 0.5.7 - Extract the heap representation of Haskell values and thunks  https://hackage.haskell.org/package/ghc-heap-view-0.5.7 (JoachimBreitner)
02:33:43 <quxbam> osa1: Ok thank you
02:38:25 * hackagebot gipeda 0.3.0.1 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3.0.1 (JoachimBreitner)
02:38:27 * hackagebot tasty-expected-failure 0.11.0.4 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11.0.4 (JoachimBreitner)
02:45:08 <argyris> hello, I don't understand why the following code takes a lot of memory http://lpaste.net/165672
02:45:27 <argyris> If I remove the 'map fst' in line 12 it doesn't take a lot of memory
02:45:58 <osa1> argyris: are you using -O ?
02:46:00 <argyris> It seems like it's keeping the entire list in memory but shouldn't the values that are already printed be garbage collected?
02:46:07 <argyris> Yes I've used -O
02:46:11 <merijn> argyris: Because rule1 isn't strict and with fst it's not forcing the second part of the tuple
02:46:25 <merijn> argyris: Basically the second part of the tuple is blowing up the space
02:46:46 <merijn> argyris: No, because tuple N+1 refers to an item in tuple N
02:46:54 <merijn> argyris: Because the addition is done
02:47:30 <argyris> right. so it keeps the unevaluated second parts of the tuple so it keeps growing 
02:47:33 <merijn> argyris: Try my annotation: http://lpaste.net/165672
02:48:02 <osa1> alternatively, use `data State = State !Int !Int`
02:48:06 <lemonxah> can you do active pattern matching (F#) in haskell?
02:48:15 <merijn> lemonxah: What's active pattern matching?"
02:48:17 <osa1> lemonxah: ViewPatterns I think
02:48:24 <lemonxah> in scala you can do it using extractors 
02:48:35 * lemonxah is googling virepatterns
02:48:51 <merijn> I don't know F# or Scala, so hard to say whether you can do that :p
02:48:59 <koz_> Man, I just found out about description logics.
02:49:03 <koz_> They are *so damn cool*.
02:49:10 <koz_> I have no idea why I never looked into them before.
02:49:58 <lemonxah> yes thankyou osa1 that is what i was looking for
02:50:07 <osa1> lemonxah: enjoy!
02:50:48 <argyris> Yes, making the tuple strict works. Thanks a lot!
03:18:26 * hackagebot intero 0.1.14 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.14 (ChrisDone)
03:22:55 <Xandaros> Hmm, I don't use view patterns, usually. Maybe I should…
03:23:39 <hpc> when you view the patterns, the patterns view back at you
03:28:03 <Squarism> anyone know how i can capture repeated capture groups in regex like "((A*)(B*)(C*))*"
03:28:13 <Squarism> seems it only finds last one
03:28:28 <Squarism> with PCRE that is
03:28:32 <mniip> why are you using regex
03:28:58 <glrh11> list
03:30:03 <Squarism> mniip, what is a better alternatie?
03:30:23 <mniip> an applicative parsing combinator library
03:32:03 <mniip> I'm not sure what's the "hip" one nowadays
03:32:11 <mniip> regex-applicative, parsec, attoparsec, megaparsec
03:32:24 <mniip> regex-applicative seems simple enough
03:32:35 <quxbam> but at least the last three are monadic
03:33:07 <quxbam> I'd really love to see some attoparsec-applicative
03:35:36 <Squarism> mniip, looked up parsec.. feels easier than in sounded.. ill give it a try 
03:35:42 <Squarism> it 
03:36:18 <quxbam> If you need speed, use the atto
03:36:33 <Squarism> i need ease of use
03:36:49 <Squarism> wo beeing limited
03:39:35 <Xandaros> Squarism: As I understand it, megaparsec is just parsec but developed further, so you may want to use that instead. That's what the megaparsec people say, anyway :P
03:40:01 <Squarism> oh ok
03:40:26 <Squarism> understand im new to haskell so dont throw me something you need a Ph D in FP to digest
03:40:30 <Squarism> =D
03:41:12 <Xandaros> Parsec parsers are what made me stick to haskell. I was never able to make a parser before and then it was suddenly a joy to write parsers :D
03:42:40 <Squarism> we talk LALR compliant parsers here? 
03:43:22 <Squarism> thats so hilariously overkill for my game commands =D But if its easy i wont complain
03:44:00 <Xandaros> Well, depending on how simple it is, maybe you can make do with pattern matching already :P
03:57:17 <Squarism> haskell feels a bit like comming to paradise. Away from the world of hacks, loose definitions and mostly underwhelmed. To a place were you can trust, be explicit and get impressed!
03:58:30 <Squarism> ..or im just a noob that gets charmed by a nice surface
03:59:29 <Xandaros> Haskell certainly has its dark spots, but in my opinion they are a lot brighter than other languages' dark spots :P
04:00:23 <bergmark> Welcome to Haskell. The first type you'll learn is String and the first function is head. Now never use them. - https://twitter.com/smdiehl/status/740194962264854528
04:01:44 <Xandaros> bergmark: +1
04:03:20 <ski> @karma bergmark
04:03:20 <lambdabot> bergmark has a karma of 3
04:03:27 <ski> @help karma+
04:03:27 <lambdabot> karma+ <nick>. Increment someone's karma
04:04:09 <ertes> hackage: deleting documentation doesn't work…  i need to reupload the docs for a package…  does anyone know how to do that?
04:04:19 <quchen> ertes: I remember you posting a very fast bitarray prime sieve, do you happen to still have the code?
04:04:37 <hexagoxel> and school children still learn how to do basic arithmetic by hand. and later we never use it, because it is slow and error-prone.
04:04:45 <ertes> quchen: when it comes back from maintenance: http://lpaste.net/101980
04:04:46 <quchen> It also included information about how GHC's evaluation model is particularly efficient in this case
04:05:00 <quchen> Thank you!
04:05:11 <ertes> you're welcome
04:05:25 <bergmark> wow how did i get 3
04:05:33 <ertes> quchen: the sieve from arithmoi is faster though…  it uses the sieve of atkin, i think
04:05:42 <Xandaros> @karma+ bergmark
04:05:42 <lambdabot> bergmark's karma raised to 4.
04:05:48 <Xandaros> Don't know, but now you got 4 :P
04:05:48 <ertes> unfortunately arithmoi doesn't work with GHC 8 yet
04:05:51 <quchen> The key argument for the efficiency was that function calls only jump forward, right?
04:06:13 <quchen> ertes: I'm not really interested in the actual algorithm, more in what makes GHC perform it well
04:06:29 <bergmark> ertes: looks like it works with GHC 8: http://matrix.hackage.haskell.org/package/arithmoi
04:07:22 <ertes> quchen: the key argument is that GC is extremely cheap and that control does not resemble source code
04:07:53 <quchen> Why is GC (particularly) cheap?
04:08:08 <ertes> bergmark: ok, last time i tried, it didn't
04:08:47 <ertes> quchen: because GC can do things stack frames and manual memory management can't do, like cleverly reusing already allocated space
04:09:59 <quchen> Like unifying equivalent closures?
04:10:23 <quchen> Copying lists into consecutive memory cells?
04:11:09 <ertes> you've allocated 64 bytes for a value…  now you no longer need that value, but you are going to construct these two 32-byte values
04:11:56 <ertes> GHC tries to keep everything compact, and as far as i've seen, statically reuse as much memory as possible
04:12:32 <quchen> Interesting. Although I don't understand the "statically" - isn't this a purely dynamical problem?
04:12:47 <ertes> nope: most of the GC is performed statically
04:12:58 <quchen> Huh?!
04:13:39 <ertes> it's still GC, but much of the work has already been done when you compiled your program
04:14:16 <quchen> I don't understand at all. What could you GC at compile time?
04:14:30 <quchen> Surely you're not talking about the static memory block, because that one is not GC'd, no?
04:16:05 <ertes> f x = print x >> f (x + 1)  -- the lifetime of the 'x' via a recursive call is statically known
04:16:54 <quchen> "lives as long as f is evaluated"?
04:17:26 <ertes> this analysis works particularly well when you use bang patterns
04:17:51 <quchen> This sounds more like smart lifetime analysis rather than GC
04:17:57 <ertes> f !x = print x >> f (x + 1)  -- 'x' is definitely no longer needed after the call
04:18:19 <quchen> So GHC can recognize a lot of use patterns statically, and add an explicit deallocation call then
04:18:33 <ertes> or decide to reuse the memory right away
04:18:59 <quchen> Within the same lifetime analysis block?
04:19:00 <lemonxah> how do you make a recursive function inside a function?
04:19:02 <quchen> Or in general
04:19:11 <quchen> lemonxah: `let` allows recursive definitions
04:19:23 <lemonxah> i dont want to define my outer function to have an accumalator
04:20:12 <ertes> quchen: you could say that the GC logically happened, but it's free at run-time
04:21:04 <jakub_> Hi, I have some amount of code that i try to profile, one thing that struck me is that `fmap` is accounted to take a lot of time for my monad (based on State) and I figured it could be due to laziness, I switched to strict state monad but it still attributes time to `fmap` is there anywhere a good read about this? All I found dealt with pure functions (in the sense: opposed to monadic)
04:21:24 <quchen> ertes: Ah, and I also overlooked that you don't need to collect anything in this static case, you can simply say "write there"
04:21:36 <quchen> So there isn't a separate call to free memory even
04:22:20 <quchen> ertes: Is this a speciality made possible by Haskell, or to what extent would this also apply to the ordinary other GC'd languages?
04:22:51 <ertes> quchen: it could be done in any GCed language
04:24:11 <ertes> remember how we say, "the compiler probably produces better machine code than you"?
04:24:20 <ertes> smart GC applies the same principle to memory =)
04:25:11 <ertes> and smart concurrency (a.k.a. lightweight threads) applies it to OS threading
04:25:14 <lemonxah> quchen do you have an example of said let?
04:26:26 <lemonxah> http://lpaste.net/165674
04:26:44 <ertes> a language like haskell can perform some very clever threading tricks that you can't do as easily using explicit threading…  i would not be surprised if warp and snap-server outperform nginx because of that
04:26:46 <lemonxah> that is what i have currently not the best fib thing i know
04:27:27 <ski> jakub_ : maybe it could be more efficient if you fused multiple `fmap' passes over your data structure into a single one. or maybe not ..
04:27:51 <mniip> lemonxah, that's like the worst (performance wise) :)
04:27:59 <quchen> > let fib = let fib' a _ 0 = a; fib' a b n = fib' b (a+b) (n-1) in fib' 0 1 in map fib [1..10] -- lemonxah 
04:28:00 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
04:28:14 <quchen> fib' is recursive, and contained entirely in fib.
04:28:28 * hackagebot chorale 0.1.6 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.6 (FranzBenjaminMocnik)
04:29:01 <mniip> > fix ((1:) . scanl (+) 0)
04:29:02 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
04:29:08 <lemonxah> oh ok
04:29:12 <mniip> oops, 0,1 not 1,0
04:29:56 <lemonxah> so my example of let loop n = and then the | 0 = 1; | 1 = 1 ...
04:30:00 <lemonxah> that wont work?
04:30:10 <lemonxah> that is pattern matching also right?
04:30:35 <mniip> no
04:30:37 <mniip> that's guards
04:30:45 <mniip> they are boolean expressions, not patterns
04:30:50 <lemonxah> oh ok
04:31:15 <lemonxah> so the only pattern matching is when using the function name and then the pattern?
04:31:30 <mniip> no, there's also case and let
04:31:52 <mniip> and toplevel definitions
04:32:02 <ph88_> anyone else have problems with attoparsec ?
04:32:12 <mniip> ph88_, define problems
04:32:27 <ph88_> error messages and positioning informatino
04:32:34 <ph88_> for me at least
04:33:42 <ertes> > let 0 = 1 in 0 + 0
04:33:44 <lambdabot>  2
04:34:41 <EvanR> haskell supports mutable literals
04:34:47 <Akii> wow
04:34:49 <EvanR> very semantic
04:34:55 <Akii> such Haskell
04:35:21 <Akii> (internet high-five)
04:35:39 <lemonxah> hmm i dont understand :/
04:35:52 <ertes> sorry, couldn't resist =)
04:35:56 <tdammers> mutable? I'd rather call them shadowable
04:36:10 <sshine> my GHCi doesn't do that. why is lambdabot different?
04:36:13 <tdammers> it's not like in Ruby, where 1 is an object that you can monkey-patch
04:36:27 <ertes> no, haskell doesn't support any of that…  i just overwrote (+) in /query =)
04:36:33 <ertes> > let 0 = 1 in 0 + 0
04:36:34 <tdammers> (disclaimer: I haven't done any significant amounts of Ruby)
04:36:34 <lambdabot>  0
04:36:35 <sshine> bah! :)
04:36:42 <lemonxah> sorry to bug again could you possible show me how to do it using this http://lpaste.net/165675
04:36:43 <EvanR> lol
04:37:03 <tdammers> well, you *can* define types with pathological Num / Integral / ... instances
04:37:06 <nilof> > let + = - in 1 + 1
04:37:08 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
04:37:11 <nilof> aww
04:37:18 <lemonxah> just trying to understand  really
04:37:23 <sshine> > let (+) = (-) in 1 + 1
04:37:25 <lambdabot>  0
04:37:28 <EvanR> it's not over yet until haskell / ruby has overloadable whitespace
04:37:28 <ertes> what really happens is that 1 is matched against 0 in an irrefutable pattern…  if you would force that pattern, it would crash
04:37:36 <ertes> > let !0 = 1 in 0 + 0
04:37:37 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
04:37:50 <tdammers> EvanR: at least we have programmable semicolons :P
04:37:51 <sshine> EvanR, or, at least, overloadable function application
04:38:05 <EvanR> C++ almost had both!
04:38:10 <lemonxah> so when you use let you have to specify the in?
04:38:15 <lemonxah> can the in be on a new line?
04:38:24 <ertes> lemonxah: yes, except in a do-block
04:38:25 <tdammers> lemonxah: yes. At least outside of layout sections
04:38:26 <sshine> lemonxah, not inside a do-block.
04:38:41 <tdammers> there's two flavors of let: inside do and outside
04:38:44 <ertes> lemonxah: you can also use 'let' without 'in' within GHCi
04:39:00 <tdammers> ertes: that's because GHCi puts you in an implicit do { }, sort of
04:39:04 <ertes> tdammers: they are really the same…  the 'in' is just implicit within 'do'
04:39:18 <tdammers> let without in is a syntax error outside of do
04:39:27 <tdammers> part of the desugaring rules
04:39:40 <tdammers> but yeah, other than that, they're the same
04:40:07 <ski> > [() | let]
04:40:08 <lambdabot>  [()]
04:40:21 <ertes> > do let; []
04:40:22 <lambdabot>  <hint>:1:11:
04:40:22 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:40:26 <ertes> > do let {}; []
04:40:27 <lambdabot>  []
04:40:31 <EvanR> > let let = let in let
04:40:33 <lambdabot>  <hint>:1:5: parse error in let binding: missing required 'in'
04:40:48 <ski> EvanR : try Scheme, perhaps
04:41:09 <EvanR> i might
04:41:29 <ertes> > [() | otherwise]
04:41:31 <lambdabot>  [()]
04:41:35 <EvanR> what is the ghc of scheme right now
04:41:55 <ertes> EvanR: chicken and racket, probably
04:42:08 <ertes> but there are a bunch of others that are active
04:42:19 <tdammers> guile? idk
04:42:22 <EvanR> radioactive?
04:42:39 <ertes> yeah, guile is also very active, but you can't compile it
04:42:45 <lemonxah> http://lpaste.net/165676 <-- having trouble to get this to compile
04:43:02 <ertes> lemonxah: fix your layout
04:43:03 <lemonxah> 4:3: error: parse error on input ‘fib'’
04:43:04 <tdammers> I assumed "the ghc of" to mean "the consensual go-to implementation", not necessarily "a compiler for"
04:43:18 * ski . o O (let ((let '`(let ((let ',let)) ,let))) `(let ((let ',let)) ,let))
04:43:18 <ertes> lemonxah: the two fib' clauses must be lined up
04:43:20 <EvanR> yes, the first obvious choice
04:43:21 <lemonxah> ertes i am sorry i dont know what layout you are talking about
04:43:31 <ertes> lemonxah: vertically that is
04:44:23 <lemonxah> oh ok
04:44:30 <lemonxah> i understand :) thank you
04:44:59 <lemonxah> not used to indentation being a thing again :) been doing scala for almost 1.5 years now 
04:45:09 <lemonxah> i feel stupid cause i should have knoen
04:45:11 <lemonxah> known even
04:45:44 <ertes> lemonxah: don't feel stupid…  it does need getting used to ;)
04:49:02 <ertes> anyone about my hackage problem?  i need to delete documentation for a package
04:49:07 <ertes> (to reupload it)
04:49:49 <ertes> not a big deal, i can upload a patch release, but it's still strange that deleting doesn't work on hackage
04:51:04 <bergmark> ertes: what happens if you just try to upload new ones?
04:51:57 <ertes> bergmark: nothing…  the old one stays in place
04:52:18 <freinn> hi bros! now my doubt is easy for you. I want to put on my linkedin profile that I'm looking only for Haskell jobs, how can I put that in correct english?
04:53:24 <locallycompact> "I am only looking for Haskell jobs"
04:53:30 <EvanR> you can replace the docs on hackage at will irrc
04:53:32 <EvanR> iirc
04:53:40 <EvanR> ertes: eh?
04:53:58 <freinn> thanks locallycompact
04:54:01 <ertes> EvanR: doesn't work…  i've tried
04:54:03 <EvanR> well PUT is idempotent, try another one ;)
04:54:21 <ertes> idempotent would be fine…  it's just idempotent in the wrong direction =)
04:54:24 <ertes> i'll try DELETE
04:54:59 <ertes> you know what…  nevermind, i'll just upload a patch release
04:55:33 <EvanR> i really want to get something like rapid up and running to impress my friends and family
04:55:54 <EvanR> ill be all the rage at the country club
04:56:40 <fractalsea> Anyone know how I can get something in haskell that support operations `wait` which blocks, and `wakeAll` which wakes up all threads blocked on `wait`? Basically like a "Monitor"
04:57:21 <EvanR> fractalsea: you can use a broadcast TChan
04:57:29 <EvanR> thats one way
04:57:38 <sdx23> or even just an MVar
04:57:42 <EvanR> er...
04:57:43 <fractalsea> EvanR, oh yeah good point
04:57:49 <EvanR> MVar sounds complex for that
04:58:06 <fractalsea> MVar would be tricky, because you would need to keep track of which threads to wake up
04:58:22 <fractalsea> EvanR, thanks
04:58:46 <sdx23> do the threads themselves decide to wait? Then I don't see the problem. Otherwise I misunderstood.
04:59:05 <fractalsea> Well the MVar would only be able to wake up a single thread
04:59:06 <EvanR> if you have multiple threads waiting on an MVar only one will wake up
05:00:32 <sdx23> no, there's readMVar: "readMVar is multiple-wakeup, so when multiple readers are blocked on an MVar, all of them are woken up at the same time."
05:01:07 <EvanR> ah right, the new version of readMVar
05:01:16 <EvanR> handy
05:02:00 <EvanR> (what the heck does readMVar do in combination of takeMVars...)
05:02:19 <EvanR> in combination with
05:03:02 <fractalsea> sdx23, but then how would you ensure subsequent threads block after all the threads that were blocked are woken up?
05:03:29 * hackagebot rapid 0.1.1 - GHCi background threads, hot reloading and reload-surviving values  https://hackage.haskell.org/package/rapid-0.1.1 (esz)
05:04:32 <ertes> EvanR: it works pretty much out of the box…  and emacs integration is a one-liner, if you already use haskell-interactive-mode
05:04:44 <EvanR> fractalsea: sdx23 ah right, readMVar doesnt take...
05:05:02 <EvanR> anymore
05:05:02 <Axman6> Anyone up for some really strange parser debugging? I can't for the lift od me get this to parse the file I have, but it fails in really strange places where one line is not substantially different from the previous one: http://lpaste.net/1083618973175513088
05:06:00 <EvanR> did you check your input for false friend unicode characters
05:06:02 <Axman6> for some reason, in sa2 it seems to parse the new line, and then complains that it expected a new line
05:06:41 <Axman6> EvanR: no, that doesn't seem to be the problem (I have been bitten by that with CSVs before, so good point)
05:07:12 <sdx23> fractalsea: ah, you're right. You can't atomically take after putting.
05:07:23 <fractalsea> Yeah. going to have to use a Chan I think
05:07:35 <ertes> fractalsea: are you communicating information to waiters?
05:07:40 <EvanR> im not sure if regular Chan can broadcast
05:07:49 <fractalsea> ertes, no, just unblocking them
05:08:13 <fractalsea> EvanR, you can use dupChan
05:08:22 <ertes> fractalsea: MVar seems fine…  just 'read' rather than 'take'
05:08:30 <ertes> alternatively a TVar Bool
05:08:38 <ertes> MVar () or TVar Bool
05:08:45 <EvanR> in that case i default to TChan when i needs chans because of unagi-chan's FUD bar chart ;)
05:09:00 <EvanR> ertes: no that wont work
05:09:02 <sdx23> ertes: after reading the mvar will still be full.
05:09:07 <fractalsea> Yeah
05:09:11 <EvanR> neither will TVar Bool
05:09:23 <ertes> yeah, waiters wait until the MVar gets a value
05:09:35 <ertes> wait = readMVar
05:09:39 <EvanR> but immediately after, waitings wake up at the wrong time
05:09:47 <EvanR> itll be double signalling
05:09:54 <fractalsea> But then it will still contain a value for when the next waiters call wait
05:09:58 <nilof> Question: what is Lens and why does everyone seem to dread it?
05:10:09 <EvanR> for each time you execute the signal, you might wake up threads in more than 1 round
05:10:16 <ertes> fractalsea: after fire, new waiters should again wait?
05:10:55 <ertes> one way to achieve that is with two TVar Int:  waiters increment one, waiting for the other to catch up
05:10:57 <EvanR> people are suggesting that the signal procedure is "putMVar () >> takeMVar"
05:11:09 <EvanR> ertes: ... or use a broadcast TCHan
05:11:10 <ertes> to fire a round means: atomically set the other one to the value of the first
05:11:15 <maerwald> nilof: it's powerful, but the types are dreadful for anyone who isn't deep into category theory. So there's some criticism there, yeah.
05:11:33 <ertes> EvanR: that's highly expensive though
05:11:38 <EvanR> no its not...
05:11:53 <ertes> TChan cloning is very expensive compared to just two TVar Int
05:11:56 <EvanR> youre basically implementing it 
05:12:05 <EvanR> you dont have to clone it when you wait
05:12:22 <ertes> you have, otherwise the other threads will take your value away
05:12:26 <ertes> and only one thread will wake up
05:12:27 <maerwald> nilof: so you either start studying that stuff if you want to understand it or you do what most people do: try to ignore the types and hope you never get a compiler error including lenses.
05:12:30 <EvanR> you only clone it once
05:12:31 <maerwald> neither of that is really optimal
05:12:32 <lemonxah> hmm why is not eq /= instead of != 
05:12:33 <EvanR> per thread
05:12:52 <fractalsea> I'm just going to use the broadcast TChan. It's conceptually the most intuitive to me
05:13:39 <EvanR> yes concurrency is one of those places where im hesitant to fuck around proving theorems (with possibility of error) in order to get (possibly misguided) % increasing in performance
05:14:02 <EvanR> but unagi-chan FUD does make me go for TChan
05:15:44 <ertes> wait = atomically (modifyTVar' waitVar succ) >> atomically (do waiters <- readTVar waitVar; slots <- readTVar fireVar; check (slots >= waiters); mapM_ (`modifyTVar` pred) [waitVar, fireVar])
05:15:56 <ertes> fire = atomically (readTVar waitVar >>= writeTVar fireVar)
05:16:22 <EvanR> this sort of feels like writing C code
05:16:50 <EvanR> theres an obvious commonly occurring problem, lets engineer a "system" to do it with highest performance, probably without benchmarking ;)
05:17:45 <EvanR> "why use malloc, just write your own memory manager"
05:17:46 <ertes> feel free to benchmark it…  starting with 3 threads this will outperform duped TChan by a factor that might make you reconsider =)
05:18:48 <ertes> if the only option is to use an unnecessarily expensive abstraction, it does not mean that it's an expensive operation…  it means that we should engineer a good solution
05:19:14 <ertes> you know why software gets slower more quickly than hardware can get faster?  that's the reason
05:19:39 <EvanR> have you actually tested these ?
05:20:26 <ertes> no, because i'm not using it myself, but i'm very confident as i'm a regular STM user
05:20:52 <EvanR> are you suggesting to use Int in the tvars
05:21:01 <ertes> yeah
05:21:17 * EvanR runs away to definitely going to work territory
05:21:25 <ertes> you can use Integer if that feels safer =)
05:21:48 <ertes> we need a lambdabot for IO
05:22:08 <ertes> or perhaps a safe IO simulator
05:23:11 <haskell-herbert> Hello everybody, someone can help me with a trivial exercise I struggle to solve
05:23:53 <merijn> fractalsea: I made a broadcast regular chan to get broadcast behaviour while avoiding the contention of TChan :)
05:24:23 <fractalsea> merijn, cool. That's what I'm trying too
05:24:40 <merijn> fractalsea: https://hackage.haskell.org/package/broadcast-chan
05:25:00 <merijn> fractalsea: It's literally just the implementation of Chan modified to support broadcast versions
05:25:08 <Ankhers> haskell-herbert: Feel free to just ask your question.
05:25:23 <merijn> fractalsea: I'm assuming your problem with Chan was the fact that it didn't drop values insert while there's no listeners?
05:26:13 <EvanR> how does Chan perform with 1 writer, many readers
05:26:23 <merijn> EvanR: Excellent
05:26:41 <merijn> EvanR: Read and write ends are completely orthogonal, so they don't contend with eachother
05:26:54 <EvanR> this chart says otherwise https://hackage.haskell.org/package/unagi-chan
05:27:24 <merijn> EvanR: That chart doesn't show single writer many readers
05:27:29 <EvanR> no
05:27:33 <haskell-herbert> Given a type declaration for my function co :: (b -> c) -> (a -> b) -> (a -> c) ... I should find an implemantion for this function
05:27:40 <EvanR> but read / write being completely orthogonal sounds suspect
05:27:58 <merijn> EvanR: It's trivially obvious if you look at the implementation
05:28:01 <Ankhers> :t (.) -- haskell-herbert
05:28:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:28:09 <fractalsea> merjin, oo yeah that's a good point
05:28:19 <merijn> EvanR: (I know, because I copied/reimplemented it for broadcast-chan)
05:28:39 <ertes> EvanR: TChan is very efficient, but it drops quickly once you have many *dupes*
05:28:59 <merijn> fractalsea: Basically, my version has an "In" chan to write to and "Out" chan's to read from. If you write while there are no read ends it drops writes on the floor
05:29:22 <fractalsea> oh that's cool :) thanks
05:29:24 <merijn> EvanR: Read and write ends are guarded by separate MVars, so you can write to the write end without impacting the read end at all
05:29:40 <ertes> EvanR: there are use cases when you genuinely need that, and then the performance is reasonable, but you shouldn't use it when there are other solutions
05:30:02 <Ankhers> haskell-herbert: What part of the function definition are you having issues writing?
05:30:06 <EvanR> unless you have to spent time writing verifying benchmarking yourself
05:30:36 <EvanR> unless you have a penchant for that sort of thing and nothing better to do ;)
05:30:42 <merijn> The STM channels are reasonably bad under high contention
05:30:51 <merijn> Since they suffer from thundering herd issues
05:30:59 <merijn> STM in general suffers from thundering herd
05:31:19 <haskell-herbert> Ankhers: My solution would be co (a,b) (c,d) = (a,c)
05:31:30 <ertes> it mostly happens when you refer to many primitives within a single transaction
05:31:52 <Ankhers> haskell-herbert: The type signature you gave me doesn't deal with tuples though.
05:31:52 <merijn> ertes: Thundering herd comes from large numbers of threads contending the same resource
05:32:06 <merijn> ertes: Large transactions make collisions during transactions more likely
05:32:12 <merijn> Both things are bad for STM performance
05:32:18 <merijn> But for different reasons
05:32:52 <infinity0> did they disable symbol search on hoogle?
05:32:56 <infinity0> https://www.haskell.org/hoogle/?hoogle=%3C%26%3E doesn't give me any results
05:33:43 <merijn> STM is best with fairly low contention and small transactions OR infrequent updates
05:33:43 <merijn> But in the end I'd say it boils down to understanding how STM works to make qualified decisions about what you're doing
05:33:44 <Xandaros> infinity0: https://www.haskell.org/hoogle/?hoogle=%3C*%3E works fine
05:34:19 <Ankhers> haskell-herbert: In the definition you gave me, (b -> c) is a function of its own. Not a tuple. Same with (a -> b).
05:34:50 <infinity0> sure, but <&> doesn't work even though it's defined in lens
05:34:55 <haskell-herbert> Ankhers: Oh, then I was misunderstanding
05:35:51 <ertes> yeah, my abstraction about might work better without the 'pred' step
05:36:03 <ertes> because in principle the final update is not necessary
05:36:26 <ertes> s/about/above/
05:37:05 <Ankhers> merijn: Just out of curiosity, would STM be well suited for 1 update every ~15 seconds, and hundreds of thousands of reads a second?
05:37:15 <haskell-herbert> Ankhers: thank you so far
05:37:19 <ertes> Ankhers: yes
05:37:35 <merijn> Ankhers: Reads are cheap in the absence of contention
05:37:43 <Ankhers> ertes, merijn: Thanks.
05:37:56 <Ankhers> haskell-herbert: no problem. Feel free to ask if you are having any more issues.
05:38:10 <ertes> Ankhers: if the reads are thrashing, the write might cause some of those transactions to repeat though
05:38:28 <haskell-herbert> Ankhers: Thank you very much, I'll do!
05:38:30 <Ankhers> ertes: I'm okay with that in a soft real time application.
05:38:42 <merijn> Ankhers: The two problems are 1) changing a TVar wakes up EVERY blocked transaction involving that TVar (thundering herd) 2) optimistic locking just executes a transaction and at the end it checks all TVars involved weren't changed since the start, if they DID then you abort and rerun the transaction
05:39:18 <merijn> Ankhers: 2) is too avoid locking, so assuming MOST transactions don't run during a mutation the transaction is REALLY cheap (at the price of a more expensive abort/restart)
05:40:03 <merijn> Ankhers: This basically means that 14.9s out of every 15s your read only transactions are free. Only the ones that happen DURING one of the updates abort and restart
05:40:35 <Ankhers> merijn: For the most part, I think I would be okay with that. Thanks for the insight.
05:40:50 <merijn> Ankhers: Also, I recommend reading the STM paper it's easy and enlightening :)
05:41:05 <Ankhers> I'll be sure to do that when I have some time.
05:41:47 <ertes> EvanR: BTW, i'm a very careful programmer, especially when concurrency is involved, so i agree that i shouldn't post untested code…  i was just being too lazy to come up with a reasonable application to test it in
05:41:50 <merijn> The big advantage MVar has over TVar is single wakeup. i.e. if 100 threads block on an MVar and it is updated, only 1 is unblocked
05:42:02 <ertes> EvanR: so don't get the wrong picture =)
05:42:14 <merijn> TVar wakes up all 100, after which 99 most likely have to block again. Wasting time/CPU :)
05:43:32 <ertes> another advantage of MVar is fairer distribution in the presence of many waiters
05:43:46 <merijn> That too
06:07:51 <ertes> is there a good alternative pastebin until lpaste comes back?
06:09:14 <bernalex> ertes: they're all pretty terrible really. I use bpaste atm.
06:09:16 <nkaretnikov> is there a way to inline a record selector?  inline doesn't allow that
06:09:29 <nkaretnikov> ertes: i used to use dpaste
06:09:38 <nkaretnikov> ertes: not sure what's the current status
06:09:40 <bernalex> dpaste is down afair.
06:09:49 <nkaretnikov> :\
06:09:52 <EvanR> ertes: theres codepad.org
06:10:13 <EvanR> its not that offensive
06:10:43 <bernalex> github gists don't suck I think
06:12:39 <ertes> i've used codepad now:  http://codepad.org/swYm7HYE
06:12:57 <ertes> EvanR, fractalsea: this code is actually tested and works
06:13:05 <mauke> http://fpaste.scsys.co.uk/
06:13:08 <ph88_> "We propose a convention where every lexeme parser assumes no spaces before the lexeme and consumes all spaces after the lexeme" why would they choose this convention over consuming spaces up front? https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec-Lexer.html
06:13:56 <absence> i tried doing stack upgrade outside a project, and it said "downloaded lts-5.17 build plan" and chugged along for quite some time. afterwards it's still using an older lts resolver however. what's the right way to upgrade? change stack.yaml in global-project as well?
06:14:34 <mauke> ph88_: possibly because then you can <|> them together and they don't have to skip spaces individually each
06:15:37 <EvanR> ertes: ok whats this, a wakeAll
06:16:36 <Ankhers> absence: `stack --help` for upgrade says "Upgrade to the latest stack (experimental)". That to me sounds more like it should be updating the stack executable, not the resolver it is using.
06:18:05 <ph88_> mauke, they still have to skip spaces at the back ^^
06:18:07 <ertes> EvanR: trackFire is wakeAll, except with a value
06:18:26 <ertes> i named it "track", because i was thinking of race tracks
06:18:43 <absence> Ankhers: ahh right, and 5.17 was the resolver needed for the new stack executable
06:19:57 <EvanR> so its like a matrioska doll
06:21:14 <mauke> ph88_: only one of them does, the one that wins
06:22:25 <ph88_> well backtracking might still be required in both solutions, no ?
06:22:46 <ph88_> maybe _less_ backtracking with spaces behind ^^
06:26:40 <unexisting> I installed the latest Haskell platform, but can't install ghc-mod via cabal ('dependencies can't be resolved' for transformers).
06:29:07 <nkaretnikov> could someone tell me why this doesn't work as expected?  (see the XXX mark for the actual question) https://github.com/nkaretnikov/OOHaskell-encodings/commit/fe73752c3475a581f9c38789075f43ef26443d17
06:29:23 <mauke> ph88_: oh, that's the other thing
06:29:31 <nkaretnikov> README.md has a link to the paper if you need more information
06:29:48 <nkaretnikov> the relevant section corresponds to the first line in the source file
06:29:48 <mauke> ph88_: parsec <|> doesn't try the second parser if the first one consumed any characters before failing, such as spaces
06:30:48 <ph88_> mauke, that's why there is try
06:31:20 <mauke> yeah, so you'd have to wrap every single lexer in 'try'
06:31:30 <mauke> which is slow
06:38:12 <maerwald> or use attoparsec?
06:38:32 * hackagebot xlsx-tabular 0.1.0.1 - Xlsx table decode utility  https://hackage.haskell.org/package/xlsx-tabular-0.1.0.1 (KazuoKoga)
06:38:57 <nkaretnikov> ah, lol, i guess i know what's going on
06:39:56 <nkaretnikov> getX in my code doesn't return a string
06:40:23 <nkaretnikov> it's similar to doing putStr "foo" >> return 42 >> putStr "bar"; 42 is not printed
06:40:56 <ph88_> mauke, yes cuz it backtracks
06:41:52 <EvanR> this code is awesome http://codepad.org/RRwsSwKl
06:42:37 * EvanR calculates how many joins this will take
06:43:56 <hexagoxel> unexisting: "GHC 8 isn't supported in any release yet, we've got a branch with partial support though. https://github.com/DanielG/ghc-mod/tree/ghc-8"
06:44:17 <Ankhers> EvanR: 2?
06:44:38 <EvanR> Ankhers: actually i think its sqrt 2
06:44:47 <EvanR> you need one more layer to use 2 joins
06:45:06 <EvanR> unless im wrong
06:45:29 <ski> @type join . join . join :: Maybe (Maybe (Maybe (Maybe a))) -> Maybe a
06:45:30 <lambdabot> Maybe (Maybe (Maybe (Maybe a))) -> Maybe a
06:45:35 <maerwald> > join . join $ Just (Just (Just "abc"))
06:45:37 <lambdabot>  Just "abc"
06:45:45 <EvanR> doh
06:45:51 <maerwald> sqrt 2, err wat
06:45:53 <ski> `y' there has type `Maybe a', for some `a'
06:45:54 <ertes> that's not quite right
06:45:58 <ertes> :t join . join . join
06:46:00 <lambdabot> Monad m => m (m (m (m a))) -> m a
06:46:13 <Ankhers> There are only 3 layers in that code.
06:46:25 <Ankhers> wait
06:46:27 <Ankhers> there are 4
06:46:41 <Ankhers> at least 4
06:46:43 <EvanR> there are four lights
06:47:22 <ski> exercise : find out how many different ways one can "associate" `join . join . join' (using the monadic associative law) (and explicitly list them)
06:47:29 <EvanR> isnt repeated joins supposed to be idempotent?
06:47:42 <Ankhers> 3 joins do the same thing as that case statement. I think...
06:47:59 <ski> Ankhers : yes
06:48:09 <ertes> > join . join . join $ Just (Just (Just (Just "abc")))
06:48:11 <lambdabot>  Just "abc"
06:48:14 <ertes> where y = Just "abc"
06:48:27 <mniip> ski, 6
06:48:35 <ski> mniip : and explicitly list them ? :)
06:48:37 <mniip> permutations of 123
06:49:19 <ertes> ski: two
06:49:34 <ertes> join . (join . join) and (join . join) . join
06:49:37 <mniip> no
06:49:43 <mniip> that's . associative law
06:49:47 <mniip> not monadic associative law
06:49:53 <ski> (also, `6' is the wrong answer. two is also wrong)
06:50:41 <arcetera> i'm reading this and have no idea what anyone's saying
06:50:43 <arcetera> welp
06:50:47 <arcetera> i'll figure it out eventually
06:51:05 <Ankhers> arcetera: Are you at all familiar with monads yet?
06:51:11 <arcetera> no
06:51:13 <maerwald> arcetera: don't worry, it's nothing really practical :P
06:51:24 <arcetera> i started learning haskell yesterday
06:51:31 <arcetera> so i have no idea what i'm doing yet
06:51:35 <mauke> arcetera: https://wiki.haskell.org/Zygohistomorphic_prepromorphisms
06:51:36 <ertes> ski: ah…  i found 5 so far
06:51:38 <Ankhers> I wouldn't worry about it at all right now then.
06:51:39 <maerwald> arcetera: nice, keep going
06:51:47 <arcetera> just want to be able to understand my xmonad config
06:51:54 <mauke> haha
06:52:00 <maerwald> heh, mission achieved
06:52:03 <mniip> join . join . join, join . fmap join . join, join . join . fmap join, join . fmap join . fmap join, join . join . fmap (fmap join), join . fmap join . fmap (fmap join)
06:52:29 <EvanR> mauke: wait, is this real
06:52:35 <quchen> Don't ask
06:52:41 <quchen> This is madness.
06:53:06 <arcetera> insert something something sparta here
06:53:42 <mauke> https://wiki.haskell.org/Real_World_#haskell
06:54:09 <locallycompact> fmap madness spartans
06:54:11 <Ankhers> "upcoming book"
06:54:16 <ertes> join . join . join = join . fmap (join . join) = join . fmap (join . fmap join) = join . fmap join . join = join . fmap join . fmap join = join . fmap join . fmap (fmap join) = join . join . fmap join
06:54:20 <ertes> 7 so far
06:54:30 <Ankhers> oh wait, it isn't the same book?
06:54:39 <arcetera> mauke: stunning
06:54:53 <EvanR> @quote
06:54:54 <lambdabot> hashendgame says: yes, let's put roconnor in the standard libs. Util.Roconnor?
06:55:02 <EvanR> @quote stereo
06:55:02 <lambdabot> shachaf says: I remember when I joined #haskell and everyone would @quote stereo.
06:55:20 <quchen> μ∘μ∘μ, μ∘μ∘Tμ, μ∘Tμ∘Tμ, μ∘Tμ∘TTμ, μ∘Tμ∘μ, μ∘T(μ∘μ), μ∘T(μ∘Tμ) -- now I'm out of ideas
06:55:53 <mniip> ertes, you repeated one
06:56:02 <mniip> quchen, you too
06:56:16 <quchen> mniip: Up to isomorphism, maybe
06:56:16 <maerwald> there probably should be a channel #haskell-real-world 
06:56:24 <maerwald> for more practical and less esoteric stuff
06:56:25 <mniip> μ∘T(μ∘Tμ) = μ∘Tμ∘TTμ  by functor laws
06:56:37 <ertes> then i'm back to 6
06:56:45 <mniip> it's really permutations of 123
06:56:46 <ertes> but ski says, that's wrong
06:57:08 <quchen> The point is that all of these are equal, so you can't say that two are equal because of some law and that reduces the number of equal things.
06:57:16 * ski is busy checking the suggestions
06:57:37 <ski> (i confess the question was a bit vaguely stated)
06:58:24 <ski> (also, i didn't figure out the answer until after i stated it here)
06:58:47 <quchen> Crowdsourcing your questions, eh?
06:59:07 <quchen> "Hey, I found out it's impossible to write the reverse function in Haskell!"
06:59:16 <ski> nah, i just thought others might find it fun to ponder, as well
06:59:33 <maerwald> quchen: it's a neat trick indeed ;P
06:59:50 <ertes> the algorithm to solve any problem: present it as an exercise to a large IRC channel and insist that all answers are wrong for at least 20 minutes =)
07:00:03 <maerwald> haha
07:00:18 <Ankhers> quchen: I feel like you wouldn't need to do that with the Haskell community. Most people I come across are more than helpful when you have a question.
07:00:33 <maerwald> ertes: there's no way to make a better search engine than google and become rich
07:00:44 <quchen> You'd think that, but it also has an evil counterpart.
07:00:51 <quchen> ?quote chrisdone socratic
07:00:52 <lambdabot> chrisdone says: It's actually impossible to employ the socratic method in here. Ask a newbie a question and it *will* be answered by someone else.
07:01:02 <ertes> maerwald: not sure about the bracketing in your statement ;)
07:03:33 * hackagebot hatex-guide 1.3.1.4 - HaTeX User's Guide.  https://hackage.haskell.org/package/hatex-guide-1.3.1.4 (DanielDiaz)
07:03:35 * hackagebot hatex-guide 1.3.1.5 - HaTeX User's Guide.  https://hackage.haskell.org/package/hatex-guide-1.3.1.5 (DanielDiaz)
07:04:25 <ertes> bitemyapp: BTW, you can post now, if you want
07:04:39 <ertes> i finally managed to upload docs properly
07:05:17 <arcetera> i'm not sure whether ocaml is a ripoff of haskell or whether haskell is a ripoff of ocaml now
07:05:33 <arcetera> (or they're just functional and that's how things should be)
07:05:50 <ertes> arcetera: neither
07:05:55 <arcetera> huh
07:05:58 <byorgey> arcetera: neither.  both have a long history, which diverged a long time ago
07:06:09 <arcetera> i barely know either lang
07:06:10 <arcetera> so
07:06:14 <ertes> arcetera: they are built on similar principles, but that's where similarities end
07:06:52 <quchen> Haskell is non-strict SML with typeclasses instead of SML-Functors, roughly.
07:06:54 <ertes> and i don't like the notion of "ripoff" in the context of programming languages
07:07:10 <arcetera> ertes: you fail to see the fact that i don't know what i'm saying yet
07:07:12 <quchen> ertes: Just like I'm not a ripoff of my dad ;-)
07:07:17 <maerwald> yeah, it's actually encouraged to "steal" ideas from each other
07:07:26 <ertes> hehe
07:08:04 <arcetera> by god i actually understand a tiny portion of my xmonad config now
07:08:07 <arcetera> legendary
07:08:14 <byorgey> =D congrats
07:08:29 <ertes> arcetera: no worries, that was more of a general statement
07:08:40 <ertes> because i consider stealing good ideas a good idea =)
07:09:29 <Anthony-NT> Er... I know nothing about Haskell. My xMonad configuration is fked after I upgraded because of another fkup I managed to do.
07:09:36 <Anthony-NT> :-(
07:09:46 <ski> mniip : `join . fmap join . join' is equal to `join . join . fmap (fmap join)' because of naturality of `join' (iow, `fmap f . join = join . fmap (fmap f)', with `f' here being taken as `join')
07:09:55 <dsub> Anthony-NT: What's the problem?
07:10:03 <osa1> Anthony-NT: time to switch to i3 ;-p
07:10:06 <ski> ertes : `join . fmap (join . join)' is equal to `join . fmap join . fmap join', by the functor distributing over composition law (`fmap (f . g) = fmap f . fmap g', with here `f = join' and `g = join'). also similarly `join . fmap (join . fmap join)' is equal to `join . fmap join . fmap (fmap join)'
07:10:11 <ski> quchen : ⌜μ∘Tμ∘Tμ⌝ is equal to ⌜μ∘T(μ∘μ)⌝, by functor law. also ⌜μ∘Tμ∘TTμ⌝ is equal to ⌜μ∘T(μ∘Tμ)⌝
07:10:12 <arcetera> literally i'm a highschooler with a laptop, openbsd, and too much free time
07:10:20 <quchen> osa1: The posterchild of configurability!
07:10:32 <maerwald> arcetera: perfect prerequisites for learning haskell
07:10:44 <Anthony-NT> I copy pasted my configuration... I can kind of figure out what is going on... but in all honesty I am confusing and I am stuck with Gnome right now which is awkward. Let me see if I can get some useful error message.
07:10:50 <ertes> ski: so my initial 5 was correct?
07:10:56 * ski notes mniip already spotted the equivalences by functor law
07:11:45 <osa1> quchen: well I use it for good defaults, I don't need a great deal of configurability
07:12:17 <ski> ertes : `5' is right, yes (it's `C_3', the third Catalan number, the number of binary trees with three internal nodes (iow four leaves))
07:12:22 <arcetera> personally i can't stand defaults in any wm
07:12:32 <arcetera> i have to change everything
07:12:35 <ertes> ski: mniip spotted one of them, which brought my list down to 6
07:12:47 <ertes> with your second one, i'm at 5
07:12:49 <quchen> osa1: It doesn't support my workflow of "switch this workspace to the current screen" though :-/ It's all about swapping things away from me, not to me. Not sure whether XMonad does this right. (Does it?)
07:12:50 <maerwald> quchen: you can configure it just fine
07:13:07 <osa1> arcetera: that just means you haven't seen a vm with default settings you like :)
07:13:11 <arcetera> (albeit my xmonad config is significantly smaller than my i3, herbstluftwm, cwm, dwm, or wmutils config)
07:13:12 * ski would like to hear the reasoning by mniip how permutations could enter the picture
07:13:36 <tdammers> wrt xmonad: s/configure/assemble/
07:13:37 <ertes> arcetera: i love defaults, but my notion of "default" is mempty =)
07:14:00 <tdammers> it's really more a box full of parts that you can use to build yourself a window manager
07:14:04 <osa1> quchen: I think you can move a workspace to a specific screen, I remember seeing something like that in forums. I don't need that so I'm not sure. (I fix workspaces to specific screens)
07:14:11 <ertes> if it's not an mempty, it's just an arbitrary value some person arbitrarily marked as this thing they called "default"
07:14:17 <arcetera> https://arcetera.moe/git/etc/file/xmonad/.xmonad/xmonad.hs.html i can mostly understand this i think
07:14:37 <arcetera> as for the tld: next year i'm gonna buy a .meme
07:14:46 <quchen> osa1: I'd like to have around 6 workspaces, each with a specific purpose (editor, browser, mail), and switch any of them to my current screen at will.
07:15:23 <maerwald> quchen: https://i3wm.org/docs/user-contributed/swapping-workspaces.html
07:15:27 <tdammers> same here, only I have 13 workspaces
07:15:41 <osa1> quchen: hmmmmm I'm not sure about that part. what I do is I fix desktops to screens, then move containers around.
07:15:50 <tdammers> super-1 through super-0 and super-`, super-dash, super-=
07:15:54 <ski> ertes : however, you (nor quchen) didn't mention `join . join . fmap (fmap join)', which mniip mentioned -- but which i counted as equal to `join . fmap join . join' (which you and quchen mentioned)
07:16:02 <Anthony-NT> This is my configuration: http://pastebin.com/gCcqGvZ1 There are some things I think I can fix... I can see updatePointer has changed. When I make the change suggested I get this: http://pastebin.com/cAzXBtrf
07:16:06 <tdammers> means switch the current screen to that workspace
07:16:10 <osa1> quchen: e.g. if I have a browser and documentation open in desktop 4, I do "move to desktop 4; select parent container; move selected to desktop 1" etc.
07:16:18 <tdammers> combined with shift, they mean "send the current window to that workspace"
07:16:18 <mniip> ski, but it's not
07:16:19 <ski> i'm not sure whether there would be any more similar duplictes, if we discount using naturality
07:16:33 <Anthony-NT> Bear in mind I know nothing about Haskell (wish I did). I don't even know what a ">>" is... but I reckon it's important :-)
07:16:36 <maerwald> "i3 already includes a way to move an individual workspace from one monitor to another."
07:16:48 <maerwald> just rtfm :P
07:16:49 <mniip> ok yes, maybe
07:16:49 <ertes> Anthony-NT: you could learn haskell
07:16:56 <mniip> if you count that as the same, then it's not permutations
07:17:02 <tdammers> xmonad, gateway drug to haskell
07:17:04 <mniip> then it's a list of all 3-trees
07:17:09 <ertes> Anthony-NT: that's probably why you're here and not in #xmonad ;)
07:17:12 <Anthony-NT> Yup. It's on my todo list... it's embarassing having to ask on here I can assure you :-)
07:17:17 <mniip> binary trees with 3 leaves I mean
07:17:28 <ski> mniip : of course not :) .. so i was wondering what your reasoning with permutations was
07:17:32 <ertes> tdammers: along with pandoc
07:17:45 <tdammers> yep
07:18:00 <arcetera> i'm learning haskell for xmonad
07:18:06 <ertes> i grew up without pandoc
07:18:16 <ertes> i grew up writing LaTeX
07:18:24 <arcetera> i use roff
07:18:25 <Anthony-NT> I have been using xmonad for years... I am surprised it has taken this long before my pasta.hs broke.
07:19:02 <arcetera> as my twitter bio says
07:19:06 <arcetera> "spaghetti code and meatballs"
07:19:09 <ski> my reasoning started with `m . m . m . m', and deciding to collapse two neighbouring `m's separated by a `.', with `join' (and some amount of `fmap's to reach the correct "spot). and then we want all different ways to do this, to end up with a single `m' at the end
07:19:23 <ski> and this is, as you say, binary trees (with four leaves, not three)
07:19:50 <Anthony-NT> I am unsure what to make of "No instance for (Fractional (a0 -> (Rational, Rational)))"
07:20:13 <quchen> Anthony-NT: You forgot an argument.
07:20:19 <quchen> (To a function)
07:20:20 <Anthony-NT> https://wiki.haskell.org/Xmonad/Notable_changes_since_0.11 I followed the instructions here.
07:20:56 <mniip> yes, 4 leaves
07:20:58 <arcetera> oh, huh
07:21:01 <arcetera> are they on 0.12 now?
07:21:05 <ski> mniip : clearly your reasoning didn't count applications of naturality as yielding (necessarily) equal solutions (the question was vague on which things counted as different and equal). can you explain your reasoning wrt permutations ?
07:21:26 <mniip> m . m . m . m
07:21:26 <arcetera> nope, i'm on 0.11.1, which is latest
07:21:26 <arcetera> good
07:21:29 <mniip> three compositions
07:21:35 <mniip> you can collapse them with join in any order
07:21:38 <arcetera> no wait they're on 0.12
07:21:41 <arcetera> ugh
07:21:46 <Anthony-NT> Yup. I got 0.12 through my package manager.
07:21:50 <ski> ok, i see
07:21:58 <Anthony-NT> I am half thinking about downgrading to 0.11 so I can go do some JIRAs
07:22:59 <arcetera> [~]── ─ xmonad --version
07:22:59 <arcetera> xmonad 0.11.1
07:23:05 <arcetera> and it's the latest in openbsd's repos
07:23:11 <arcetera> rip
07:23:26 <ski> so the difference with my version is that if you collapse the middle composition last, then i counted the left and the right composition collapses as independent of each other, while you held fast on the ordering
07:23:33 <mniip> yes
07:23:37 <mniip> exactly
07:23:51 <ski> ty
07:25:46 <arcetera> well now the question is
07:26:03 <arcetera> install xmonad via cabal or whatever, or deal with an old version and wait for it to be updated in ports?
07:26:12 <arcetera> the struggle is real
07:26:24 <tdammers> install via cabal
07:26:28 <tdammers> hands down
07:26:39 <arcetera> okay
07:26:42 <arcetera> let's hope this doesn't break my config
07:26:45 <arcetera> hold on
07:27:43 <ertes> depends on your distribution
07:27:57 <tdammers> fwiw, if your config is broken, xmonad will likely fail to compile, and you'll just keep running the old one
07:28:05 <Anthony-NT> What is the word for ">>"?
07:28:24 <ertes> Anthony-NT: depends on the context, but most likely "and then"
07:28:40 <ski> it is often pronounced "then", yes
07:28:43 <Anthony-NT> In context of: a = b >> c?
07:28:45 <maerwald> :t (>>)
07:28:46 <lambdabot> Monad m => m a -> m b -> m b
07:28:51 <tdammers> Anthony-NT: I like to think of it as "bind but ignore"
07:28:52 <ertes> Anthony-NT: that's not enough context
07:29:04 <Anthony-NT> haha I don't know what I am doing >:-)
07:29:05 <ertes> Anthony-NT: the type decides what it means
07:29:25 <tdammers> the problem with things this abstract is that most of the metaphors don't cover the abstraction fully
07:29:41 <ertes> Anthony-NT: main = putStrLn "Hello" >> putStrLn "world!"  -- here it means "and then"
07:29:41 <ski> for specific types, sometimes there might be a more accurate way to pronounce it
07:29:57 <tdammers> calling it "then", for example, suggests that the operands run in sequence, and with monads like IO, they do, but it doesn't have to be that way
07:30:05 <maerwald> you can think of it as: execute left-hand action, discard the result, execute right-hand action and return the result
07:30:32 <Anthony-NT> "logHook = dynamicLog >> updatePointer (0.95 0.95) (1, 1)" Means... bind dynamicLog (and then updatePointer) to logHook?
07:30:47 <ski> tdammers : well, from my POV, it expresses sequence also in list monad, continuation monad, environment/input/reader monad, parser monad, ...
07:30:54 <tdammers> ski: Maybe?
07:30:57 <ski> yes
07:31:08 <tdammers> for a very abstract concept of sequence, yes
07:31:09 <ertes> Anthony-NT: in xmonad configurations it's usually "and then" between two actions
07:31:13 <ski> (only not *evaluation* sequencing)
07:31:19 <tdammers> sequence as in "dependency chain" or something
07:31:31 <Anthony-NT> Is there anything odd about this "updatePointer (0.95 0.95) (1, 1)"?
07:31:37 <tdammers>  > Just 1 >> Nothing
07:31:41 <tdammers> > Just 1 >> Nothing
07:31:42 <lambdabot>  Nothing
07:31:43 <ski> sometimes i say that monads express "dynamic sequencing" and idioms (aka applicative functors) "static sequencing"
07:32:11 <ski> Anthony-NT : missing `,' in `(0.95 0.95)'
07:32:15 <Anthony-NT> YES
07:32:25 <tdammers> "the result of the thing on the right, unless the thing on the left fails"
07:32:33 <Anthony-NT> ski: w00t
07:32:36 <Anthony-NT> It compiles!
07:32:37 <arcetera> guys guys
07:32:44 <tdammers> anyway, sequence is probably as good a starting point as any
07:32:46 <arcetera> i upaded xmonad and it didn't break
07:32:55 <arcetera> what is this wizardry
07:33:02 <maerwald> well, it's not emacs
07:33:09 <Anthony-NT> Thank you... all... I will be back to this channel, with different intentions :-)
07:33:12 <Anthony-NT> Cheers!
07:33:21 <ertes> my emacs code tends to survive emacs updates more often than my haskell code survives GHC updates =)
07:33:32 <arcetera> i use vim
07:33:54 <arcetera> i don't know if there's anything i'm missing out with emacs
07:34:09 <arcetera> and i don't really care
07:34:28 <ski> (i agree that there's lots of ways to misinterpret "sequencing" wrt monads. but i still think that there is a real useful sense of sequencing involved, and that that is probably one source of why newbies seem to often think of it as sequencing, even when told not to)
07:35:09 <maerwald> people should be less afraid of metaphors that are not 100% correct. Because that's what metaphors are anyway.
07:35:19 <nilof> looking through the join & fmap formulation for monads
07:35:46 <nilof> so in the special case of the list monad, fmap = map and join = concatenation?
07:35:49 <ertes> i like the sequencing/dependency metaphor for monads
07:35:49 <WarDaft> If one of the packages in the latest stackage nightly isn't building due to unsatisfiable package constraints, where should that be reported?
07:35:58 <mnoonan> Is there any fun Haskell-related stuff getting presented at PLDI next week?
07:36:03 <ski> nilof : yes
07:36:09 <ertes> at least it tells something, while for example the "programmable semicolon" metaphor tells nothing
07:36:22 <ski> nilof : and `return' is singleton
07:36:24 <nilof> huh, that was quite intuitive tbh
07:36:34 * ski nods to ertes
07:36:42 <nilof> ya, I've seen the formulation in term of return and bind
07:36:52 <nilof> it feels less mysterious this way though imho
07:36:58 <ski> nilof : yes. but for the formulation in terms of `fmap' and `join' you also need `return'
07:37:28 <nilof> yeah
07:37:46 <ertes> nilof: join/fmap/pure are easier to digest, but (>>=) is usually more useful
07:37:47 <nilof> so really you are decomposing the Join into moire primitive parts
07:38:19 <maerwald> ertes: "programmable semicolon" is a useful metaphor for people who've been doing FP before haskell and are familiar with evaluation etc, imo
07:38:24 <ski> nilof : `join' can often be a bit easier to grasp than `(>>=)'. however often the latter can be a bit more efficient (unless the implementation manages to fuse away enough intermediate data structures)
07:38:30 <nilof> but the bind operators are of course what you use for composition
07:39:02 <ski> nilof : can you rephrase what you mean by "you are decomposing the Join into moire primitive parts" ?
07:39:36 <nilof> well, you write it as a product of fmap and join
07:39:43 <nilof> ah
07:39:45 <nilof> I meant bind
07:39:47 <nilof> sorry
07:39:58 <EvanR> bind is a combination of fmap and join
07:40:09 <nitrix> Hi. Does someone has any suggestions to represent relational data without handmade systems of ID and lookup tables?
07:40:14 <maerwald> and yet you cannot define Monad instance by join
07:40:17 <maerwald> which is odd
07:40:18 <nitrix> I'm going in circles for about a week now.
07:40:28 <srhb> nitrix: Did tables die?
07:40:37 <nitrix> srhb: What do you kmean?
07:40:45 <EvanR> ixset
07:40:59 <srhb> nitrix: Looks like it did... github.com/ekmett/tables
07:42:17 <nitrix> Imagine the relation `A -> B <- C`, I want to be able to change B and now further usages of A and C would use the newer B.
07:42:25 <ski> maerwald : i think `join' should probably be in `Monad', now that `Functor' is a superclass of it
07:42:40 <EvanR> nitrix: wait.. .that sounds like an odd sort of relation
07:42:46 <nitrix> Without having to indepedently change A and C. The ID thin creates an indirection, it's nice, but it gets ugly on a large scale.
07:42:49 <EvanR> a relation is between two sets
07:43:08 <quchen> ski: It would be, if not for technical difficulties
07:43:11 <ski> (a relation can have any arity, in relational algebra)
07:43:16 <nitrix> EvanR: Yeah, in my case, it's multiple records sharing a common field.
07:43:22 <EvanR> the simplest case is 2
07:43:26 <ski> quchen : with defaulting ?
07:43:39 <nitrix> EvanR: The example case I gave recently was multiple players of a game in the same guild.
07:43:43 <quchen> ski: No, it conflicted with the role machinery, and generalized newtype deriving
07:44:00 <ski> quchen : oh. tell/point me (to) more ?
07:44:07 <maerwald> ski: yeah and if join is defined, bind can be derived automatically. So one should be able to choose whether to define join or bind
07:44:12 <EvanR> nitrix: i would model it as a set of IDs pairs from both sets in question
07:44:19 <EvanR> with indexes
07:44:20 <ski> maerwald : that would be the ideal, yes
07:44:41 <maerwald> I personally find it more natural to implement join.
07:44:56 * ski isn't sure whether `B', or the arrows, in nitrix' diagram would be the relation of interest
07:45:17 <quchen> ski: I'm afraid I don't have the sources handy anymore, and I have to go for now. There's a talk by SPJ about roles, and he mentions this as a specific problem with then. It's from the end of last year.
07:45:34 <ski> ok
07:45:40 <EvanR> if theres "players in a guild" relation, then you ncan find all players in a guild using one of the indexes
07:45:43 <nitrix> I'll update the code today and have something concrete to show and demonstrate what in particuliar I'm stuck on.
07:46:02 <Welkin> guilds? players?
07:46:04 <EvanR> you can add and remove entries from that relation, or remove payers or guilds as long as you remove the relations they are linked with
07:46:04 <quchen> https://skillsmatter.com/skillscasts/5296-safe-zero-cost-coercions-in-haskell
07:46:05 <Welkin> are you making a game?
07:46:07 <quchen> ski 
07:46:13 <Welkin> or a tracker for a tournament?
07:46:19 <mnoonan> maerwald: is there a reason join can't be added to the Monad typeclass?
07:46:19 <nitrix> Welkin: Yes, but it has neither guilds nor players.
07:46:37 <Welkin> nitrix: :(
07:46:38 <mnoonan> I guess the way it is right now, you can't make a join that is incompatible with bind..
07:46:49 <Xandaros> A game without players? Sounds pretty boring
07:46:51 <mnoonan> too bad there isn't something like smart typeclass constructors
07:46:56 <dolio> ski: If you have something like `newtype NT m a = NT (m a)` then having `m (m a) -> m a` doesn't give you `NT m (NT m a) -> NT m a` via coercion unless you know that NT is representational regardless of m. But it actually can't be.
07:47:10 <ski> quchen : ty
07:47:21 <dolio> It must be nominal, because you don't know that m won't be nominal.
07:47:45 <dolio> And there are no higher-order roles.
07:47:58 <ski> mnoonan : "smart typeclass constructors" ?
07:48:12 <maerwald> mnoonan: can we say "must only implement either, not both"?
07:48:35 <EvanR> maerwald: its common in other classes to let you do both, if one has a more efficient way
07:48:39 <mnoonan> ski: e.g. for Monad, say "you can either give me an instance with (>>=) and return, or and instance with join and return"
07:48:58 <mnoonan> *an
07:49:01 <maerwald> EvanR: that doesn't fix the problem here
07:49:04 <EvanR> mappend vs mconcat
07:49:25 <EvanR> and you can use defaults to get the right impl in terms of the other
07:49:38 <ski> dolio : this whole role thing feels .. shady, to me
07:49:46 <dolio> Yeah, I don't like it.
07:49:55 <EvanR> join isnt in Monad because raisins
07:49:57 <arcetera> surprisingly enough i've already learned functions, cases, pattern matching, variables, typeclasses, types, etc
07:50:00 <EvanR> no reason it cant be
07:50:05 <arcetera> and yet i don't know hello world yet
07:50:08 <mnoonan> ski: and behind the scenes, Monad would have all of join, (>>=), return in its typeclass dict, but you hide the ability to set all three independently.
07:50:31 <EvanR> "Hello World"
07:50:32 <ski> mnoonan : there are default implementations of type class methods. however, afaik, you still can only give a single default implementation for a given method
07:50:33 <maerwald> mnoonan: I'd be tempted to not make a constraint on that. I mean, you can already define Monads that don't obey the monad laws.
07:50:43 <maerwald> so do things really get worse?
07:50:46 <EvanR> actually, you probably want to implement a fibonacci sequence instead
07:51:26 <mnoonan> maerwald: one fewer way to be unlawful, at least
07:52:07 <EvanR> might as well forget that since we dont have dependent types, and concentrate on being able ot write efficient overrides
07:52:19 <EvanR> let the code review deal with the monad laws
07:52:33 <ski> mnoonan : oh, i see. you meant not allowing one to give all three, because of proof obligations that might not be met ?
07:52:41 <mnoonan> ski: yes, exactly
07:52:56 <ski> mnoonan : but then, what maerwald said
07:53:29 <ski> arcetera : `main = putStrLn "Hello World !"'
07:53:40 <arcetera> well crap
07:55:16 <ski> EvanR : i think it could be useful to allow having more than one default implementation for a method. which one is chosen would depend on which methods are explicitly given
07:55:39 <EvanR> ok
07:55:51 * EvanR wonders how to say that on paper
07:56:15 <EvanR> how to specify
07:56:20 <ski> let's say that `foo' can be implemented in terms of `bar' and `baz', `bar' can be implemented in terms of `foo' and `baz', and `baz' can be implemented in terms of `foo' and `bar'
07:57:14 <ski> hm, no. actually that's too simple to display the problem i was thinking about
07:57:27 * ski can't recall the specific example atm
08:00:34 <lpaste> infinity0 pasted “keepTrying” at http://lpaste.net/165680
08:00:44 <infinity0> is there a general utility that basically already does this ^
08:04:09 <cheater> https://hackage.haskell.org/package/loop-while-1.0.0/docs/Control-Monad-LoopWhile.html
08:05:53 <infinity0> oh, i was hoping to have something that already takes advantage of the fact that >>= for Maybe short-circuts already
08:06:17 <infinity0> in the future i might conceivable change this to a Either, which short-circuits for Left
08:06:23 <cheater> you could do forever on the single monadic action, bind it with >>= and foldr, and use forM.
08:06:44 <infinity0> er, Right*
08:06:48 <infinity0> ok, i'll have a look at that, thanks
08:08:16 <ics> bitonic: I have a question about inline-c if you're around
08:08:17 <cheater> yw
08:08:33 <bitonic> ics: shoot
08:09:37 <ics> I'm trying to interface with a C library which uses function pointer callbacks all over the place
08:10:14 <ics> but I have little experience with C
08:11:01 <bitonic> ics: right, that's possible and should be fairly user friendly with inline-c: <https://github.com/fpco/inline-c#function-pointers>
08:11:11 <ics> my problem is segfaults
08:11:24 <bitonic> Ehe, that's typical
08:11:28 <ics> yep
08:11:41 <ics> see, I can get everything to work if I write one big C.block for every function
08:11:52 <ics> but that's no fun
08:12:48 <bitonic> ics: if you give me more concrete clues/examples I can try to help you
08:13:12 <ics> yes I'll try to gather my ideas/questions better in the next few minutes
08:13:56 <bitonic> ics: cool
08:13:57 <ski> @type runMaybeT . msum . map MaybeT  -- infinity0
08:13:59 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
08:14:37 <orion> How mature is inline-c?
08:14:41 <infinity0> ah very nice, thanks ski! will have to study that for a bit
08:15:32 <ski> infinity0 : the `MonadPlus' instance for `MaybeT m' (provided `Monad m') is for your kind of situation
08:15:37 <bitonic> orion: well it's pretty simple
08:15:58 <bitonic> I'd consider it pretty stable by now
08:16:12 <bitemyapp>  /lastlog bitemyapp
08:16:15 <bitemyapp> really
08:16:31 <lpaste> arcetera pasted “maximum'” at http://lpaste.net/165681
08:16:41 <arcetera> ^
08:16:53 <orion> bitonic: What are its limitations? Is it a complete replacement for foreign export/imports?
08:16:54 <arcetera> why does `maximum' [1,2,3]` in ghci
08:16:54 <bitonic> It doesn't pull any crazy tricks so I don't suspect any super subtle bugs. The most annoying thing about it is <https://github.com/fpco/inline-c/issues/21>
08:16:57 <arcetera> *** Exception: baby.hs:(93,1)-(94,16): Non-exhaustive patterns in function maximu
08:17:15 <glguy> arcetera: spelling error
08:17:15 <arcetera> where am i missing a pattern match
08:17:18 <bitonic> orion: I'd frame inline-c as very convenient sugar to interface with C libraries
08:17:26 <arcetera> oh
08:17:27 <arcetera> fuck
08:17:29 <glguy> maxmium' vs maximum'
08:17:39 <arcetera> argh
08:17:46 <arcetera> the worst kind of mistake
08:17:53 <glguy> arcetera: Yeah, those can be brutal
08:18:02 <bitonic> orion: it doesn't really impose a new "framework" that replaces normal foreign calls
08:18:11 <glguy> Helps when warnings are on and you get a strange warning about a top-level type signature missing
08:18:12 <bitonic> But if you use it you probably can avoid writing normal FFI
08:19:40 <tippenein> Has anyone worked on something like `go fmt` for haskell?
08:19:50 <tippenein> I think it's the only thing Go did right
08:19:55 <orion> bitonic: I see. Would it be well-suited as a way to expose a C interface to a Haskell library?
08:20:11 <bitonic> orion: No, it's the other way around
08:20:18 <orion> Ok.
08:20:19 <bitonic> It's only useful to use C from Haskell, not Haskell from C
08:20:42 <tdammers> bitonic: I can see a use case for exposing Haskell code as a C library
08:20:57 <bitonic> tdammers: yes, you can pass Haskell functions to C using inline-c
08:21:08 <bitonic> If that's what you're hinting at
08:21:14 <bitonic> Ah no, I misread your post :)
08:21:17 <glguy> You don't need "inline-c" to pass Haskell functions out to see, though you *can* use it
08:21:33 <glguy> But I haven't read all the context so that might not be relevant
08:21:33 <ski> infinity0 : should also generalize to `ExceptT' (re "in the future i might conceivable change this to a Either")
08:21:33 <tdammers> I'm hinting at stuff like linking pandoc as a C library, and then using it in C programs
08:21:42 <tdammers> apt-get install libpandoc-dev :D
08:21:48 <Ankhers> tippenein: https://github.com/jaspervdj/stylish-haskell I've never used it before though. So I really have no idea how well it works.
08:21:49 <infinity0> ah yes
08:21:53 <bitonic> tdammers: yes, it is very useful and supported by GHC, just not something inline-c help you do 
08:22:00 <glguy> tdammers: That's what my Lua debugger does
08:22:38 <Ankhers> tippenein: Based on the readme, it doesn't seem to do as much as go fmt though.
08:22:39 <bitonic> tdammers: see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#making-a-haskell-library-that-can-be-called-from-foreign-code>
08:23:14 <tdammers> bitonic: I think I read what you said out of context
08:25:56 <orion> I think the hardest part about creating a C interface to a Haskell library is dealing with advanced language features like GADTs.
08:27:54 <glguy> GADTs don't come up that much on average, and certianly aren't what makes a C API hard to manage
08:28:53 <glguy> You'll spend more time figuring out marshaling in general, tracking lifetimes across API calls, dealing with bound threads, various C world stuff
08:33:52 <Myrl-saki> My program just fails without doing anything...
08:34:40 <dmj> Myrl-saki: can you paste your code
08:35:00 <Ankhers> Myrl-saki: Can you define fails? Are you getting an error? Or is it just not outputting anything?
08:35:21 <Myrl-saki> Ankhers: The latter. It returns 1.
08:35:42 <Myrl-saki> The return code's 1*
08:35:50 <Ankhers> Myrl-saki: As dmj asked, would you show us code?
08:37:18 <ics> bitonic: https://gist.github.com/ianclarksmith/99e30cba0b7704f23f1dad8361cfad4f
08:37:26 <Myrl-saki> This is the shell. http://imgur.com/mhnROPh
08:37:31 <r444> getting all kinds of trouble with stack lately
08:37:42 <Myrl-saki> Give me some time to post the code.
08:37:50 <r444> fatal error: 'openssl/asn1.h' file not found
08:37:52 <r444> now this
08:37:54 <Myrl-saki> runghc works btw.
08:37:59 <Myrl-saki> But using ghc doesn't.
08:38:09 <Myrl-saki> runghc complains that not enough memory.
08:38:15 <r444> locate openssl/asn1.h | wc -l says 34
08:38:19 <r444> orz
08:39:02 <Ankhers> Myrl-saki: What is the content of Test.hs?
08:39:54 <maerwald> @hoogle [(m a, m b)] -> m [(a, m b)]
08:39:56 <lambdabot> No results found
08:40:11 <Myrl-saki> Ankhers: Errr... I shouldn't have called it test. | test was using the shell command test...
08:41:17 <Myrl-saki> Anyways, severe memory leak. Lol.
08:41:35 <Myrl-saki> It takes up more than 10 GB of RAM.
08:41:54 <ski> @type mapM (\(ma,mb) -> liftM (,mb) ma)  -- maerwald ?
08:41:56 <lambdabot> (Monad m, Traversable t) => t (m a1, t1) -> m (t (a1, t1))
08:42:53 <glguy> maerwald: sequenceAOf (traverse._1) :: Applicative m => [(m a, m b)] -> m [(a, m b)]
08:43:43 <bitonic> ics: I think the difference between those two _might_ be a red herring
08:43:59 <bitonic> The problem, I think, is that I create and free a fun ptr when the C block is executed
08:44:04 <maerwald> ski: I want: [(IO MenuItem, IO ())] -> IO [(MenuItem, IO ())] 
08:44:08 <ics> right
08:44:11 <maerwald> and no, I don't use lens
08:44:14 <ics> oh, I just added a comment on the gist
08:44:15 <bitonic> While I _think_, in your case, the callback might be called afterwards
08:44:44 <maerwald> the first action of the tuple creates the menuitem, the second is the callback and must not be executed
08:44:44 <bitonic> Basically with phe `$fun` antiquoter the assumption is that the function pointer is only used in the lifespan of the lbock
08:44:47 <bitonic> *block
08:44:56 <ski> maerwald : and presumably you don't want to execute any of the `IO ()' actions when the outer resulting action is executed ?
08:45:02 <ski> maerwald : right
08:45:02 <maerwald> yes
08:45:09 <ski> so, what i said
08:45:30 <ics> That's what I gathered, but I'm unsure of the best way to proceed without dealing with the FFI directly
08:45:33 <bitonic> ics: you can use `mkFunPtr` (as you kind of guessed) to do what you need directly
08:45:39 <bitonic> Or rather, explicitly
08:46:25 <bitonic> ics: `$(mkFunPtr [t| Ptr UIButton -> Ptr () -> IO () |]) doSomething` will get you the funptr that you want, and then you can (and should) free it explicitly
08:47:36 <bitonic> ics: using <https://s3.amazonaws.com/haddock.stackage.org/lts-6.2/base-4.8.2.0/Foreign-Ptr.html#v:freeHaskellFunPtr>
08:52:02 <bitonic> ics: then you can capture them in a C block using normal anti-quoting
08:53:06 <ics> bitonic: "normal antiquoting" -> that crazy what-now that I've been reading about the past few days
08:53:31 <ics> but thanks, now that I've got the FunPtr I'm gonna try some things out
08:54:13 <bitonic> ics: ehe, I mean that you can do `do fptr <- $(mkFunPtr [t| Ptr UIButton -> Ptr () -> IO () |]); [C.block| ... $(void (*f)(uiButton *b, void *d)), $(void *d)) |]`
08:54:25 <bitonic> Sorry, that *f is meant to be *fptr
08:54:33 <bitonic> (copy pasted from your example)
08:54:49 <bitonic> ics: I think the most complicated part of it all is C types syntax :)
08:55:00 <bitonic> It's a real headache
08:57:02 <ics> Muddling through it for sure, but the reward will hopefully be a decent Haskell interface to skate over all that
08:58:11 <bitonic> ics: note that when you're having trouble with sugar, at some point it might be worth it to understand what's going on behind the hood
08:58:19 <bitonic> If you find yourself unable to solve problems
08:58:32 <bitonic> E.g., what would you have to do to write that function with normal FFI?
08:58:56 <bitonic> If you have time to find out about that, it'll make everything much clearer :)
08:59:08 <ics> bitonic: as soon as I get past the segfaults, my plan was to at least try doing it all with FFI
08:59:26 <ics> but I ended up going in so many new directions at once to figure out what was happening
08:59:37 <bitonic> ics: yes, that might be a good idea. I wrote inline-c because writing quick FFI wrappers was really tiring after a while
08:59:56 <bitonic> It's kinda convenient but no substitute to understanding how the Haskell FFI works
09:09:17 <ics> bitonic: ...aaand it's working, huge thanks!
09:09:32 <bitonic> ics: be sure to free the ptr at some point
09:09:47 <bitonic> I once had a lovely bug where I didn't free them and GC gets a tiny bit slower each time you add a stable ptr :)
09:09:56 <bitonic> So GC would get slower and slower over days/weeks
09:10:00 <bitonic> That was fun to track down
09:10:13 <ics> It's as if you knew that I ignored the free just to get my example working
09:10:23 <bitonic> ics: ;D
09:10:29 <c_wraith> shocking! 
09:11:02 <c_wraith> Oh, always remember to free things the right way. ie, free them from whatever allocator allocated them. 
09:11:31 <c_wraith> it's surprising how many different allocators a program can have. 
09:12:08 <bitonic> It's surprising how hard resource handling is
09:12:56 <bitonic> An unfortunate side effect of GC is that you cannot tie resource allocation/freeing with the object lifetime
09:13:00 <bitonic> Like you do in C++/Rust
09:13:14 <bitonic> So resource management is _easier_ in C++ than it is in Haskell, which is sad
09:13:55 <c_wraith> you can implement region systems in Haskell, but.. they're painful in their own way. 
09:14:06 <tdammers> brackets anyone?
09:14:13 <bitonic> Yeah, I mean there's no reason we couldn't bake `bracket` into the language
09:14:30 <tdammers> the only reason, I think, is that it would amount to mere syntax sugar
09:14:36 <bitonic> All this to say that RAII is super convenient, and we should have some more convenient way of doing it
09:14:55 <bitonic> tdammers: well no, with RAII you can be sure not to use the dead object past its lifetime
09:15:09 <tdammers> same for bracket, really?
09:15:15 <bitonic> with bracketed style resource management you can escape the scope
09:15:35 <c_wraith> not if you take the ST route
09:15:46 <bitonic> tdammers E.g. `withPtr return`
09:15:50 <tdammers> you can escape RAII too, if you do stupid stuff like store pointers to stack variables
09:16:19 <bitonic> tdammers: not in Rust. But yes, in C++ you can. It's a bit less easy though
09:16:26 <tdammers> agree
09:16:37 <tdammers> but I'd say bracket is at least on par with C++ here
09:16:41 <tdammers> anyway, time to go
09:17:11 <bitonic> cya
09:18:51 <bitonic> c_wraith: right, Rust basically does that but it's baked into the language with inference and stuff
09:19:13 <bitonic> (in that case the `s` token in `ST` would be a lifetime variable)
09:19:21 <bitonic> It's not quite the same I guess, but similar
09:20:24 <udateprobs> hi
09:25:06 <divVerent> Anyone know about HDBC.Sqlite3?
09:25:27 <divVerent> I noticed it insists on keeping a permanent shared lock on the DB file, which is unnecessary - any way to turn this off? The sqlite command line client does not.
09:28:38 * hackagebot katip-elasticsearch 0.2.1.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.2.1.0 (MichaelXavier)
09:33:38 * hackagebot abnf 0.3.1.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.3.1.0 (Xandaros)
09:34:57 <dbushenko> Hi all
09:35:48 <dbushenko> What library is best for parallel processing?
09:36:42 <dbushenko> May be with task queue...
09:41:03 <schell> dbushenko: http://hackage.haskell.org/packages/search?terms=parallel
09:41:31 <schell> parallel is great, repa is great - other than that, i don’t know
09:42:30 <schell> dbushenko: you should definitely check out “the book”: http://chimera.labs.oreilly.com/books/1230000000929/pt01.html
09:43:09 <dbushenko> I have it, i just wanted to find the best option
09:43:31 <dbushenko> E.g. like with work stealing queue....
09:43:43 <schell> oh, sorry
09:53:39 * hackagebot biohazard 0.6.6.1 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.6.1 (ustenzel)
09:58:39 * hackagebot monads-tf 0.1.0.3 - Monad classes, using type families  https://hackage.haskell.org/package/monads-tf-0.1.0.3 (RossPaterson)
09:58:55 <dfeuer> What is this tasty thing and why does it need all the parsers?
09:59:32 <dfeuer> Could someone please ban udateprobs?
10:00:08 <benzrf> what tf is tf
10:00:21 <dfeuer> benzrf, type families....
10:00:23 <divVerent> as for my sqlite problem - seems like explicitly doing all selects in a transaction and rolling back when done works in a small test, but that's annoying
10:00:37 <divVerent> (and I wouldn't have to do this from C)
10:01:34 --- mode: ChanServ set +o glguy
10:01:34 --- mode: glguy set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.36.109.113
10:01:34 --- kick: udateprobs was kicked by glguy (udateprobs)
10:06:37 --- mode: glguy set -o glguy
10:14:07 <amf> is there a way to extend a sum type (from a package i dont control) with a few more constructors? e.g. data SomeoneElesesError = E1 | E2 | E3; data MyErrors = E4 | E5; i'd like a type that i can do case analysis on E1..E5
10:14:36 <geekosaur> no
10:15:08 <DanielDiaz> is it possible to specify flags for dependencies in the cabal.config file?
10:15:19 <geekosaur> unless you count something like data MyErrors = Theirs SomeoneElsesError | E4 | E5
10:15:50 <amf> geekosaur: yeah i might go with that
10:16:47 <nilof> ...how do you go from fmap, return, join to a monoid in the category of endofunctors exactly?
10:18:38 <nilof> or wait, no, I think I got it
10:18:50 <EvanR> first what is a monoid object in a category
10:19:09 <EvanR> riddle me that
10:20:28 <nilof> I see how you do it for the special case where the category you start with is generated by only a single type t, so contains t,Mt,M^2t... 
10:21:27 <divVerent> yes, solved the sqlite issue now - I need to run R/O queries in an explicit transaction too so the COMMIT at the end actually releases the locks
10:21:36 <divVerent> and I need to use the strict version of fetchAllRows
10:21:36 <nilof> wait no, I'm confused again
10:21:50 <divVerent> or it'll happily fetch again after the COMMIT, reopening the lock
10:22:30 <Squarism> so do haskell people rather use parser libs instead of regex? 
10:22:59 <EvanR> yes
10:24:32 <Squarism> if so, is megaparsec a good alternative for your day-to-day ad hoc tasks like "parse rows of 3 columns, separated by this and that with some small quirks"
10:24:37 <Squarism> ?
10:24:50 <ggVGc> wonder when I can call myself a haskell people
10:25:38 <Ankhers> ggVGc: Is that your way of saying you still prefer regex?
10:26:13 <ggVGc> nah, just don't feel in tune enough with haskell yet to be haskell people
10:26:27 <ggVGc> in other news, I don't understand the difference between megaparsec and parsec
10:26:32 <ggVGc> never heard of the former
10:26:51 <chelfi> last I checked megaparsec was advertised as parsec with better error messages
10:26:59 <DanielDiaz> ggVGc: it's a fork of parsec
10:27:07 <ggVGc> right
10:27:12 <ggVGc> but for what purpose
10:27:16 <ggVGc> trying to find out
10:27:22 <ggVGc> chelfi: ah, alright
10:27:24 <ggVGc> that's a fair reason
10:29:30 <DanielDiaz> ggVGc: so the author of megaparsec claimed that parsec was abandoned (or semi-abandoned), then created megaparsec
10:30:30 <geekosaur> better error messages, bug fixes, uses Applicative instead of inventing it (Applicative/Alternative's operators were more or less lifted from parsec and other parsers)
10:32:50 <geekosaur> and iirc what they claimed was that they'd tried multiple times to contact parsec's maintainer and failed. I do wonder if they were trying to contact the original author instead of the current maintainers though
10:33:03 <Habib_> Wassuuuuup.
10:33:08 <Habib_> Who took my name?
10:33:22 <geekosaur> if it wasn't registered with freenode, could be anyone
10:33:34 <Habib_> Goddamn it, I was sure I registered it.
10:33:40 <Habib_> I have no idea how this IRC thing works.
10:33:54 <Habib_> They say I'm good with computers.
10:34:56 <geekosaur> oh, it seems to think you're already on. perhaps you need to ghost it?
10:35:08 <Habib_> What's that?
10:35:38 <Habib_> I mean, I didn't close my IRC client, but I closed the window.
10:35:40 <geekosaur> if you got disconnected somehow, then the servers take some time to realize it and may show your dead connection as live still
10:35:50 <Habib_> Okay.
10:35:59 <Habib_> That makes sense, I usually just close the lid on my machine.
10:36:07 <geekosaur> so you can: /msg nickserv ghost Habib <yourpasswordhere>
10:36:19 <geekosaur> and it will disconnect the old session so you can reclaim the nick
10:37:11 <Habib_> Did that work?
10:37:15 <Habib_> I guess not.
10:37:55 <geekosaur> it won't automatically change your nick, if you got back a message saying ti was disconnected/ghosted then...
10:37:56 <geekosaur> sigh
10:38:14 <Habib_> Okay, second try.
10:38:18 <Habib_> Nope.
10:39:56 <Habib_> Final attempt.
10:40:03 <Habib_> Ah, never mind.
10:40:16 <tommd> freenode.net has information that can help you in navigating things.
10:40:25 <Habib_> Wait, is my IRC password the same as my freenode password?
10:40:39 <tommd> ... you are connected to a freenode irc server...
10:40:57 <Habib_> I've got my freenode password saved in my keychain, but I'm not sure that it's the password NickServ is asking for.
10:41:04 <coppro> try it and see?
10:41:21 <glguy> It might be better to work this out in #haskell-offtopic.
10:41:53 <Habib_> Can't really tell, NickServ tells me Habib has been ghosted, even if I deliberately enter a password I know to be incorrect.
10:42:01 <Habib_> Yeah, sorry.
10:42:25 <Ankhers> Maybe #freenode could be helpful too.
10:42:32 <Habib_> Anyway, the reason I came on here is to ask if anyone knows what the simplest way is to `exec` a command given a command name and [String] of arguments.
10:42:37 <EvanR> Habib_: remember, any time you type your password it shows up as ***** on everyones screen
10:42:58 <Habib_> I'm not falling for that one.
10:44:12 <Habib_> I've found plenty of functions that can run a command, but none that will do the equivalent of shell's exec
10:44:32 <Habib_> which lets the child process take control.
10:44:43 <geekosaur> not exactly
10:44:55 <Habib_> Go on…
10:45:01 <geekosaur> unless you're on windows, where it pretty much has no choice but to work that way
10:45:11 <Habib_> OS X
10:45:36 <geekosaur> on posix-ish operating systems, it replaces whatever your current process is with the new program
10:45:44 <geekosaur> the old one isn't there any more afterward
10:46:01 <Habib_> That's what I mean by letting the child process take control. Sorry, bad wording on my part.
10:47:31 <Habib_> The reason I'm asking is that I'm trying to support something like Git's custom subcommand feature where you can have a program named git-subcommand in the path and you can call it as git command.
10:49:44 <cocreature> stack does that iirc, you might want to look at how they do it
10:50:01 <Habib_> Oh, nice, thank you.
10:50:11 <nilof> > let (+1) = (*5) in 1+1
10:50:13 <lambdabot>  <hint>:1:6: Parse error in pattern: + 1
10:50:59 <nilof> > let (+1) = (*5) in (+1) 1
10:51:00 <lambdabot>  <hint>:1:6: Parse error in pattern: + 1
10:51:22 <Ankhers> I believe the issue is in `(+1) = (*5)`
10:51:24 <glguy> nilof: You can't use sections as patterns, you can write: let (+) 1 = (*5) in 1+1
10:51:29 <nilof> > let (+) = (*5) in 1 + 1
10:51:31 <lambdabot>      Could not deduce (Num a0)
10:51:31 <lambdabot>      from the context (Num a, Num (a -> t))
10:51:31 <lambdabot>        bound by the inferred type for ‘e_1511’: (Num a, Num (a -> t)) => t
10:51:54 <nilof> > let (+) 1 = (*5) in 1 + 1
10:51:56 <lambdabot>  5
10:52:15 <nilof> > let (+) 1 = (*5) in 1 + 2
10:52:17 <lambdabot>  10
10:52:36 <nilof> > let (+) 1 = (*5) in 2 + 1
10:52:37 <lambdabot>  *Exception: <interactive>:3:5-16: Non-exhaustive patterns in function +
10:52:41 <glguy> this is equivalent to writing: let f 1 = (*5) in f 1 1
10:52:56 <ertes> is there a lightweight GUI toolkit that doesn't insist on an uninterruptible main loop?  gtk, gtk3 and wx all do
10:53:08 <geekosaur> Habib_, I think you are looking for System.Posix.Process.executeFile
10:53:30 <glguy> You are defining a brand new function called (+) that has nothing to do with the normal addition functino
10:53:40 <ertes> i don't need anything fancy actually: all i need is a text area (for output) and a smaller text input (for input)…  like a shell
10:54:04 <EvanR> ertes: "you havent invented it yet" (alternatively, browser)
10:54:30 <nilof> so the infix syntactic sugar gets desugared before evalutation too
10:55:00 <sm> ertes: have you looked at fltkhs, or (text ui) brick ?
10:55:11 <geekosaur> ertes, https://developer.gnome.org/gtk3/stable/gtk3-General.html#gtk-main-iteration
10:55:21 <geekosaur> although I don't know if gtk2hs wraps it
10:55:30 <ertes> EvanR: browser would be wonderful, but i'd have to write client-side as well as server-side code, and my dev environment doesn't handle that well right now
10:55:41 <Habib_> geekosaur: ah, thanks, I already had that open in the dozen tabs I'm currently reading. Apologies for not telling you earlier, I had resolved to ask again the next day and had completely forgotten about some of the stuff I'd found.
10:55:52 <nilof> Also, if you have defined a function with two inputs, is there a way to get an infix version?
10:56:01 <Habib_> the problem I have with executeFile is that it claims that whether it behaves like exec is dependent on a few things.
10:56:06 <sm> nilof: a `thefunction` b
10:56:10 <ertes> sm: i've watched the video, but couldn't get it to work with GHC 8 yet
10:56:14 <nilof> ah ok
10:56:17 <Habib_> “depending on whether or not the current PATH is to be searched for the command, and whether or not an environment is provided to supersede the process's current environment”
10:56:18 <ertes> geekosaur: thanks, i'll have a look
10:56:18 <sm> ack
10:56:43 <nilof> if it isn't associative, does it start from the left or right?
10:56:46 <geekosaur> Habib_, actually that just means it's wrapping all the different exec variants
10:57:00 <geekosaur> PATH is execvp, env is execve
10:57:30 <nilof> > 1 - 1 - 1
10:57:32 <lambdabot>  -1
10:57:32 <geekosaur> otherwise it's execv (the execl* forms are C varargs hacks not relevant to Haskell)
10:57:35 <Habib_> I'm guessing that means the C family of functions, as opposed to the shell function I'm used to. Thanks for the pointer, time to do some C function reference lookup.
10:57:41 <geekosaur> yes
10:57:50 <ertes> geekosaur: indeed, it's there…  thanks a lot!
10:57:51 <nilof> okay, starts from the left
10:57:57 <glguy> nilof: By default infix things are "infixl 9"
10:58:34 <ertes> alternative: is there a way to use GHCi with the semantics of the threaded runtime?
10:58:42 <nilof> let f x y = x - y in 1 'f' 1 'f' 1
10:58:47 <geekosaur> and indeed the shell exec is not quite the same as any of the C functions
10:58:56 <nilof> >let f x y = x - y in 1 'f' 1 'f' 1
10:59:04 <glguy> no, not '   but   `
10:59:09 <nilof> ah
10:59:12 <geekosaur> ertes, ghci is always threaded, what you can't do is make it act like the non-threaded runtime
10:59:30 <nilof> >let f x y = x - y in 1 `f` 1 `f` 1
10:59:31 <Habib_> Oh, curious question: why does it claim to return a computation which wraps something of type a (which has no class constraint, so could be anything)? I would have expected IO () or something.
10:59:54 <ertes> hmm
11:00:00 <Habib_> It's not like you can use the monad's bind function to get at that value.
11:00:01 <geekosaur> (iirc ghci has a housekeeping thread, and past versions would sandbox command line computations in their own threads which will make X11-based stuff unhappy)
11:00:21 <Habib_> Ah, the ever-favourite historical reasons.
11:00:21 <geekosaur> :t undefined
11:00:23 <lambdabot> t
11:00:40 <coppro> Habib_: I can't find the context, but in general, a function which aborts computation in a monad has return type m a since it can be followed by any action
11:00:43 <geekosaur> a function producing an unqualified type does not return
11:00:51 <hexagoxel> DanielDiaz: yes, use "PACKAGE +FLAG" (or -FLAG) on a separate line/entry
11:01:26 <geekosaur> so in this case, the type IO a is telling you that either it throws an exception or it replaces the process so no further code from your program will run; in neither case does it do a normal return
11:01:59 <coppro> Habib_: this becomes important because suppose you want to include your function inside another IO action
11:02:03 <coppro> say, an IO String
11:02:05 <ertes> :t forever (print ())
11:02:06 <geekosaur> moreover, the type system *knows* that it means this and can tell you if you try to do something else afterward
11:02:06 <lambdabot> IO b
11:02:12 <coppro> if you just had IO (), you'd have to have some constant string to return
11:02:28 <Habib_> Hold on, I'm confused.
11:02:46 <geekosaur> coppro, the context is System.Posix.Process.executeFile. it never returns
11:02:50 <coppro> right
11:03:00 <Habib_> I've got two people talking and both are saying different things at me.
11:03:07 <coppro> but you might have an IO function which either returns a String or calls executeFile
11:03:28 <BlackCap> :t id id id
11:03:29 <lambdabot> a -> a
11:03:32 <BlackCap> :t succ succ succ
11:03:33 <Habib_> can you say “wraps a string” as I confuse return with an actual function instead of a computation?
11:03:33 <lambdabot> (Enum a, Enum (a -> a), Enum ((a -> a) -> a -> a)) => a -> a
11:03:34 <ertes> Habib_: if something has a type variable, you as the user get to decide which type it will be…  now the return type is an unconstrained type variable, so you as the user of the never-ending action can choose the type freely, as that action never has to produce it
11:03:35 <BlackCap> ^ Why is that; they both take one argument
11:03:46 <coppro> the IO a type is important so that you can validly use executeFile without having to do something like "executeFile >> return "this should never happen""
11:03:52 <Habib_> Ah, that makes sense, ertes.
11:03:53 <monochrom> geekosaur, ertes: it's true. in addition, the background housekeeping thread invokes GC when it detects idleness. you know how if you openFile, then forget about it, then no one will be around to hClose until GC time? well this thread will do that. it leads to file descriptors not leaking in ghci, whereas such leaking happens in standalone exes because you seldom use -threaded
11:04:14 <coppro> BlackCap: why is what?
11:04:21 <Habib_> The never-ending action, that's an interesting thought.
11:04:49 <ertes> geekosaur, monochrom: i see (actually i use -threaded all the time)
11:05:14 <monochrom> in fact I noticed that only after someone was puzzled by the observation on haskell-cafe. "my code works in ghci, breaks in exe, why oh why??!!!"
11:05:25 <BlackCap> the type of `id id id` is just a->a, while the type of three succ's is long and nasty
11:05:28 <ertes> Habib_: "never-ending" is a metaphor: of course the action will end, but it will not return in a sense that it would have a *return value*…  it's more likely to terminate the program in this case
11:05:40 <coppro> BlackCap: because of the type of succ
11:05:42 <coppro> :t succ
11:05:43 <lambdabot> Enum a => a -> a
11:05:45 <Habib_> No, I understand what you're saying, I just like to trip out.
11:05:55 <geekosaur> BlackCap, that looks like you asked for the type of a nonsense expression. the typechecker will happily infer nonsense because it has no idea that there can't be a type that fits all of those constraints
11:05:58 <coppro> the "long and nasty" that you're referring to is all in the constraints
11:06:06 <coppro> and if you decompose how you're using succ, it should make sense
11:06:15 <geekosaur> (it does not know what a constraint like Enum "means"; it's just shuffling type variables)
11:06:28 <Habib_> Chinese Room type inferer.
11:06:28 <monochrom> ertes: also, -fno-ghci-sandbox may help you
11:06:39 <ertes> Habib_: same with an infinite loop:  x = x  -- this value cannot be computed, so asking for it will never yield an answer…  therefore it lets you choose its type freely:  x :: a
11:06:48 <Habib_> Yes, I tried that the other day.
11:06:51 <Habib_> Very interesting.
11:06:52 <monochrom> isn't Haskell exciting!
11:06:52 <geekosaur> I thought that was only in ghc7.8 and they did it differently now
11:06:56 <BlackCap> but `id id id 1` is 1, but `succ succ succ 0` /= 3
11:07:10 <Habib_> you're giving 3 arguments to the first succ
11:07:17 <Habib_> I think you want succ . succ . succ $ 3
11:07:27 <Habib_> or succ $ succ $ succ $ 3
11:07:28 <coppro> or succ $ succ $ succ 3
11:07:37 <ertes> monochrom: i'm mainly trying to figure out a way to start a thread in GHCi that runs a GUI, but is interruptible using killThread
11:07:37 <Habib_> yes, or without the last dollar
11:07:38 <coppro> succ succ succ 3 is parsed as ((succ succ) succ) 3
11:07:50 <BlackCap> that's my issue, I want write a function in a way so that I don't have to use $ or .
11:07:57 <Habib_> use brackets
11:08:04 <coppro> yeah, that's the other option
11:08:08 <coppro> succ (succ (succ 3))
11:08:10 <Habib_> succ(succ(succ(3)))
11:09:05 <monochrom> ertes: it's best to forkOS for that (instead of forkIO). add "bracket" or "finally" stuff for finishing touch.
11:09:36 <ertes> monochrom: does it actually make a difference in GHCi?
11:09:44 <monochrom> it does
11:09:50 <ertes> good to know, thanks
11:10:01 <monochrom> when ghci creates a thread, it's just forkIO
11:10:09 <dmwit> ertes: You may like http://dmwit.com/gtk2hs
11:10:33 <ertes> dmwit: thanks, reading it
11:10:38 <monochrom> but you need forkOS for C libraries that say "I have thread-local state, please call all of my functions in the same thread"
11:11:25 <monochrom> you may like to know my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
11:11:26 <geekosaur> BlackCap, Haskell doesn't let you write it like succ succ succ 3 because then you couldn't write map myFunction someList --- which meaning would it use? (Trying to figure it out from the type is not a good idea; types can have surprises in them that makes it ambiguous. See Text.Printf module for an example.)
11:11:47 <dmwit> I don't know what `killThread` does to a thread that is currently in an FFI call. Probably it won't work until the call returns? But I don't know for sure. Possibly the source papers will have details on that.
11:11:57 <geekosaur> (using typeclasses to get something like C's varargs)
11:12:03 <monochrom> true, dmwit
11:12:41 <geekosaur> the ghc manual chapter covering FFI talks about it. it even specifies a nonstandard way to change the behavior
11:13:23 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#interruptible-foreign-calls
11:13:31 <infinity0> suppose i have a monad transformer stack with IO at the bottom, and normally this is used to "talk to the outside" - is there a standard way to create several of these components and make the IO parts talk to each other, purely inside the process instead?
11:13:48 <geekosaur> free monad?
11:13:52 <dmwit> IORef/MVar?
11:14:16 <dmwit> Conclusion: the question is not precise enough yet to answer in a meaningful way.
11:14:25 <infinity0> ah that sounds promising, i'll look at those
11:14:47 <infinity0> yes, i just wanted some general directions to explore by myself, thanks
11:17:56 <ertes> dmwit: unfortunately it says nothing about exceptions =/
11:18:59 <ertes> i'll just use mainIteration
11:23:41 * hackagebot bitcoin-payment-channel 0.1.1.2 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.1.1.2 (runeks)
11:24:10 <ertes> infinity0: more generally coroutines…  free monads (interlocked) and concurrency (not necessarily interlocked) are examples of that, and stream processing frameworks (conduit, pipes, etc.) are, too
11:25:14 <ertes> another question: is there a technical reason why the non-threaded runtime is still the default?  it seems like an odd choice
11:26:22 <geekosaur> performance, I think --- threaded gets you extra overhead in the garbage collector and the IO subsystem, at minimum
11:27:16 <geekosaur> that said, I have recently heard rumblings about how non-threaded is actually not well tested and some ghc devs might like to see it go away
11:28:20 <geekosaur> there should be no technical reasons; even the non-threaded runtime actually has threads (for FFI calls and for the IO manager, at least)
11:30:46 <ertes> does it?  i thought it doesn't use separate threads for FFI calls
11:32:26 <bitemyapp> ertes: posted it, thanks :)
11:33:53 <ertes> bitemyapp: thank you =)
11:35:00 <Athas> I have a nontrivial program that works fine in GHC 7.8 and 7.10, but stalls with an infinite loop in GHC 8.0.  I can get a stack trace that roughly tells me where things go wrong, but how would I go about debugging it further?
11:35:16 <Athas> What worries me is that this program doesn't do anything funky with IO, laziness, or threading.
11:35:41 <dmj`> Athas: can you show us your code
11:36:46 <Athas> dmj`: it's a 35k SLOC codebase, with the error occuring deep inside of it.  Reducing to a simplest reproducible case is very hard, I'm afraid.
11:36:48 <Guest25257> I'm looking for advice for working with zip archives on Windows.  I've found the zip package, but am unable to build it, or get it running from stackage, as there is an "unknown symbol `fileno' in the "cbits" portion.  I'm in a little over my head at that point.  Does anyone have experience and/or suggestions for getting my zip archive tasks done on Windows?  I need only to read and grep data from existing archive files.
11:37:56 <dmj`> Athas: can you isolate the error to a small section where its reproducible?
11:38:14 <dmj`> Athas: k, no worries then
11:38:23 <Ankhers> Guest25257: I've used zip-archive in the past. Not on windows though.
11:38:42 * hackagebot casadi-bindings 3.0.0.2 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.0.0.2 (GregHorn)
11:38:50 <geekosaur> probably need a specific posix-on-windows setup. is fpcomplete's minghc still a thing?
11:47:49 <Guest25257> Ankhers: thanks, that builds and runs in the repl
11:48:04 <Guest25257> Ankhers: even on Windows
11:48:13 <Ankhers> Glad to hear
11:53:48 <teurastaja> any neural network simulator requiring no programming? just a GUI with configs
11:54:07 <teurastaja> i want to simulate a 3x3 network
11:54:55 <hpc> i think you're in the wrong channel
11:55:39 <teurastaja> which channel should i use? haskell seems best for programming it so i guess theres some good programs out there
11:55:57 <Squarism> is parsec meant to accept full BNF syntax? Cant really remember if BNF can describe parsing in itself? 
11:57:15 <hpc> teurastaja: you asked specifically for no programming ;)
11:57:27 <monochrom> parsec does not know BNF
11:57:56 <hpc> Squarism: parsec is short for "parser combinators", so you're basically programming a parser
11:58:04 <ertes> teurastaja: there are quite a few neural network *libraries* on hackage, but no ready-made GUI i'm aware of
11:58:21 <ertes> teurastaja: also most of those libraries suck…  not all, but most
11:58:49 <hpc> Squarism: depending on which bits of parsec's api you use, you can parse regular, context-free, or context-sensitive
11:59:10 <hpc> i wouldn't be surprised if you can go fully turing-complete, just because it's embedded and haskell is turing-complete
11:59:37 <dolio> Yes, you can parse anything.
12:00:11 <teurastaja> i just want a simple 3x3 network i tried in scheme but it seems buggy so i thought i could learn from haskell programs but ideally id just start simulating then programming it later
12:00:13 <dolio> Any grammar that can be parsed in Haskell can be parsed using parsec.
12:00:48 <ertes> teurastaja: "simulating" and "programming" are almost the same thing with artificial neural networks
12:01:20 <ertes> it's just whether you use it through code or through buttons in a window
12:03:05 <teurastaja> its such a pain in the ass to program i had to read all those math symbols and now i get errors grrr
12:04:38 <EvanR> math symbols, how do they work
12:04:40 <Squarism> hpc, my problems is that i have a hard time finding clear examples.. its mixes of bnf, do block, haskell callouts and what not. 
12:04:43 <EvanR> its a miracle
12:06:57 <pikajude> ertes, are you the one that helped me with the in-memory TVar cache
12:13:06 <ertes> pikajude: i think so
12:14:19 <pikajude> it's using huge amounts of memory with this specific use case
12:14:21 <pikajude> and i can't figure out why
12:18:53 <ertes> pikajude: i have to leave now, but i can have a look at it in a few hours
12:19:13 <pikajude> ok, cool
12:21:12 <quxbam> Why doesn't Set got an Applicative instance?
12:21:49 <adelbertc> i don't even think it has a Functor instance because it's not forall a
12:21:52 <adelbertc> it has an Ord constraint right
12:21:55 <hpc> quxbam: so like, you can have Set String
12:22:11 <mizu_no_oto_work> quxbam: The better place to start from is "why doesn't Set have a Functor instance"
12:22:16 <hpc> quxbam: what's (pure hOpenFile) <*> (that set)?
12:22:28 <adelbertc> Functor says forall a. (a -> b) -> f a -> fb
12:22:30 <hpc> or rather, hOpenFile <$> (that set)
12:22:43 <pikajude> or even putStrLn <$>
12:22:44 <adelbertc> for Set it needs to have an Ord a => constraint, so it doesn't meet the requirements of fmap
12:22:47 <hpc> it's a bunch of IO actions, which you need to resort
12:23:15 <hpc> because Set uses a balanced binary tree implementation (at least in ghc)
12:23:44 <hpc> the more type-level argument is that (Functor f) defines fmap for all a/b
12:23:45 <hpc> :t fmap
12:23:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:23:48 <mizu_no_oto_work> adelbertc: that's a bit backwards.  Set can have "fmap :: Ord b => (a -> b) -> Set a -> Set b"
12:24:00 <hpc> but you can't have a valid (Set a) for all a
12:24:02 <sm> does microlens let you create lenses with TH, like makeLenses in lens ?
12:24:06 <hpc> which breaks things
12:24:37 <mizu_no_oto_work> i.e. you don't need the Ord a since you can just traverse the tree; you need an Ord b to rebuild the tree with.
12:24:49 <sm> ah, it's in microlens-th
12:27:18 <quxbam> So is it impossible to write a function which returns a singleton set or a singleton list?
12:28:09 <hpc> it's very easy to write a function that makes a list with one arbitrary element
12:28:12 <hpc> :t (:[])
12:28:13 <lambdabot> a -> [a]
12:28:27 <hpc> it's impossible to write one for Set, it has to have the constraint
12:28:40 <quxbam> Yeah, but one for both...
12:28:45 <hpc> the best you can do is Ord a => a -> Set a
12:29:14 <EvanR> quxbam: -> Either (Set a) [a] ?
12:29:34 <EvanR> or what do you mean
12:29:34 <quxbam> something like   a -> f a
12:29:40 <quxbam> pure
12:29:52 <quxbam> but, well, set isn't an applicative
12:30:02 <EvanR> a function like a -> Set a (unless it returns empty set) just cant be done
12:30:32 <dolio> @type S.singleton
12:30:33 <lambdabot> a -> Data.Set.Set a
12:30:34 <EvanR> so a -> f a cant be done
12:30:34 <joncfoo> if I want to 'newtype' an Integer and be able to use all the standard operators, what classes do I need to derive? (where can I find this info)
12:30:55 <hpc> dolio: quit confusing the argument with your /facts/ :P
12:31:02 <EvanR> what it has no constraint
12:31:14 <EvanR> go ahead and write a class for it then ;)
12:31:22 <dolio> Don't need ordering for a 1-element tree.
12:31:25 <hpc> EvanR: yeah, everything else in Set adds the constraint later though ;)
12:31:35 <mizu_no_oto_work> quxbam: See Pointed - https://hackage.haskell.org/package/pointed-5/docs/Data-Pointed.html
12:31:38 <hpc> :t S.fromList
12:31:39 <lambdabot> Ord a => [a] -> Data.Set.Set a
12:31:45 <mizu_no_oto_work> There's a Pointed instance for List and Set
12:31:50 <hpc> you can't even get the element back out of the set
12:31:59 <hpc> :t S.toList
12:32:00 <lambdabot> Data.Set.Set a -> [a]
12:32:03 <hpc> oh wait, you can
12:32:21 <hpc> anyway
12:32:39 <quxbam> Great! Thanks
12:32:54 <mizu_no_oto_work> quxbam: Pointed is basically pure factored into a class of its own
12:33:24 <quxbam> mizu_no_oto_work: Yes, it's exactly what I was looking for
12:36:36 <mizu_no_oto_work> quxbam: You might also want to read http://www.cs.rhul.ac.uk/home/ucac009/publications/constrained-monad-problem.pdf
12:37:03 <mizu_no_oto_work> If you end up wanting something a bit more powerful than pointed
12:38:21 <quxbam> Interesting paper, I'll digest it tonight
12:40:02 <roconnor_> Is Data.Vector.Unboxed.Vector Bool packed?
12:40:07 <emillen> Is happstack worth learning? I am learning haskell right now, and my friend wants to start a webproject (he is a designer). Just a small website for fun
12:40:20 <emillen> Are there any better alternatives 
12:40:27 <emillen> I really want to get better at haskell 
12:40:35 <Ankhers> emillen: Define better.
12:40:42 <Ankhers> What do you look for in a web framework?
12:41:11 <emillen> Sorry, i dont know anything about happstack! I want it to be worth learning, and hopefully teach me more about haskell 
12:41:37 <dolio> roconnor_: I don't think so.
12:41:41 <Ankhers> emillen: Have you do web development before?
12:41:52 <emillen> Yes! 
12:41:53 <hpc> at some very fuzzy metaphorical level, writing a website in happstack feels a lot like writing a website as an apache module
12:41:55 <dolio> Makaing it packed is on my to do list.
12:42:01 <quxbam> emillen: to start with a webapp is perhaps a bit hard
12:42:15 <maerwald> emillen: http://bitemyapp.com/posts/2015-08-23-why-we-dont-chuck-readers-into-web-apps.html
12:42:28 <Ankhers> emillen: What have you used in the past for web development?
12:43:06 <emillen> I took a course in web applications, where i learned laravel/php 
12:43:13 <emillen> i made a forum 
12:43:17 <Akii> oha
12:43:54 <Akii> fwiw go for it, but check out yesod and the other web frameworks
12:44:18 <Akii> snap is another one
12:45:15 <emillen> All right! thanks
12:46:18 <Akii> going from PHP to Haskell is a big step though
12:46:41 <emillen> Ah, i am a computer engeneering major 
12:46:42 <quxbam> emillen: Or servant if you feel brave
12:47:10 <Akii> well, then there should be no problem :D
12:47:19 <emillen> I learn haskell on my free time 
12:47:33 <emillen> Just wanted someone to put me in the right direction in terms of frameworks 
12:47:47 <emillen> so i dont get feet deep into a bad framework xD
12:47:52 <Akii> yesod is probably really good
12:47:54 <suppi> happstack probably have better documentation than snap? i don't know
12:48:03 <roconnor__> oh the bitvec package claims to be packed
12:48:19 <emillen> All right! Ill check out snap, and yesod 
12:48:23 <emillen> Thank you 
12:48:34 <Akii> with haskell you can go low level pretty easy if you don't like a particular framework
12:48:53 <Akii> so if you need WS just use the lib, kind of thing
12:51:03 <Akii> out of interest, what did you think of php/laravel emillen?
12:52:46 <emillen> I dont like php at all! Laravel made it bearable xD
12:53:03 <Ankhers> emillen: What don't you like about PHP?
12:53:11 <Akii> interesting
12:53:33 <Akii> also what did Laravel do to make it better
12:53:45 * hackagebot chorale 0.1.7 - A module containing basic functions that the prelude does not offer  https://hackage.haskell.org/package/chorale-0.1.7 (FranzBenjaminMocnik)
12:53:51 <Ke> this is haskell, and someone does not like php???
12:55:27 <emillen> So i have not much experience with object oriented programming. I mostly done C programs. PHP, without a framework made it real easy to make a cluttery mess 
12:55:37 <EvanR> anyone coming in here liking PHP is in luck, acme-php package
12:56:04 <EvanR> batteries included
12:56:22 <Akii> EvanR: sounds like a trap
12:56:42 <emillen> was a short course too xD 
12:57:22 <emillen> like i dont remember an instance, but two functions doing about the same thing had the parameters reversed
12:57:51 <emillen> doSomethingA(oneThing, secondThing)
12:57:51 <emillen> doSomethingB(secondThing, oneThing) 
12:57:54 <Akii> ye, PHP is a language created by many professionals that wrote many papers and put much thought into it
12:58:17 <maerwald> O.o
12:58:18 <Akii> sounds like array_filter and array_map
12:58:29 <Akii> I was being sarcastic, if it wasn't obvious
13:00:07 <EvanR> > fix (++ " HyperText Preprocessor")
13:00:11 <lambdabot>  mueval-core: Time limit exceeded
13:00:18 <EvanR> the world may never know
13:01:12 <EvanR> > fix (reverse " HyperText Preprocessor" ++)
13:01:13 <lambdabot>  "rossecorperP txeTrepyH rossecorperP txeTrepyH rossecorperP txeTrepyH rossec...
13:01:16 <EvanR> better
13:02:01 <EvanR> a glimpse of what things look like on the far side
13:04:06 <maerwald> EvanR: you can also pm lambdabot
13:08:45 * hackagebot diagrams-postscript 1.3.0.6 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.3.0.6 (BrentYorgey)
13:13:45 * hackagebot diagrams-pgf 0.1.0.4 - PGF backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-pgf-0.1.0.4 (BrentYorgey)
13:39:57 <Squarism> hey
13:40:22 <Squarism> how do i go from a String to a Value (data)
13:40:38 <Squarism> data ValueType = A | B
13:40:54 <Squarism> how to make "A" into A
13:41:08 <whittle> Squarism: read, from the Read typeclass. 
13:41:19 <whittle> :t read
13:41:20 <lambdabot> Read a => String -> a
13:41:29 <Squarism> ah
13:42:46 <whittle> I’m looking for advice on how to truncate a Data.Time.Clock.DiffTime to milliseconds. The complication is that I’m using time-1.5.0.1, so diffTimeToPicoseconds isn’t available. 
13:43:04 <EvanR> DiffTime is a Num and Fractional
13:43:46 * hackagebot not-gloss 0.7.7.0 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.7.0 (GregHorn)
13:43:50 <EvanR> though you usually want NominalDiffTime
13:44:05 <EvanR> anyway you can use * / floor and realToFrac to do anything
13:46:20 <whittle> EvanR: Thank you. Your advice made me realize that the constraint of being equal to or less than a day is on the utctDayTime field of UTCTime, not on DiffTime itself. 
13:47:03 <EvanR> sometimes its hard to know what the easier way to do something with time is
13:47:12 <EvanR> especially in the Data.Time library
13:47:43 <EvanR> its usually NOT operating on fractional seconds since 1970
13:48:47 * hackagebot neural 0.1.1.0 - Neural Networks in native Haskell  https://hackage.haskell.org/package/neural-0.1.1.0 (lbrunjes)
13:48:49 * hackagebot interruptible 0.1.1.1 - Monad transformers that can be run and resumed later, conserving their context.  https://hackage.haskell.org/package/interruptible-0.1.1.1 (marcosdumay)
13:49:02 <EvanR> maybe programmers naturally are out of step with the intuitive understanding of date/time issues, and so they invented these horrible interfaces ;)
13:49:38 <EvanR> (Data.Time is the best so far ive seen)
13:51:34 <whittle> EvanR: I’ll check out Data.Time. Thank you again for the advice. 
13:51:38 <ph88> hi guys
13:51:58 <ph88> i wanna parse some source code but anywhere a comment can appear .. any idea how to handle that in my parser ?
13:52:17 <nitrix> ph88: Are the comments anyway until the end of line?
13:52:27 <ph88> wut ?
13:52:28 <nitrix> *anywhere
13:52:31 <glguy> ph88: typically you do that by removing comments before you get to the parser
13:52:37 <ph88> yes
13:52:45 <nitrix> ph88: e.g., is it -- style or {- -} style?
13:52:49 <ph88> --
13:52:53 <ph88> only
13:52:56 <ph88> no block comment
13:52:56 <EvanR> let iden{- hmm... -}tified = 9 in identifier
13:53:04 <EvanR> s/d/r/
13:53:31 <ph88> capturing the comments in the syntax tree would be nice
13:53:37 <whittle> EvanR: irentifier? 
13:53:41 <ph88> lol
13:53:57 <EvanR> sub what i mean not what i say
13:54:05 <glguy> EvanR: If you let your lexer handle comments then iden and tified are likely to be two separate tokens
13:54:06 <whittle> Hahaha
13:55:21 <EvanR> glguy: that seems busted according to intuitive understanding of "comments do not matter"
13:55:33 <glguy> ok
13:55:51 <EvanR> but the identifier is still not connected either so....
13:56:07 <Squarism> woha.. wrote my first parsec parser!!
13:56:12 <Squarism> thanx helpers
13:56:21 <whittle> Squarism: Congrats! 
13:57:03 <quxbam> Is it possible to write infinity as Nat on the typelevel?
13:57:31 <quxbam> So that (x <= Infinity) is true for all nats x?
13:58:24 <quxbam> I tried:  type Inf = 1+Inf
13:58:36 <quxbam> but the compiler dislikes my cycle
13:58:37 <c_wraith> no, the type level is strict. 
13:58:56 <c_wraith> it always evaluates types fully. 
13:59:07 <quxbam> Why is this the case?
13:59:09 <ph88> but how can encode that there can be a comment in the syntax tree but after the comment has ended it should be looking again for the stuff it was expecting ?
14:00:16 <quxbam> At least I can make Infinity incomparable: type Inf = 0 - 1
14:00:28 <quxbam> But that's a bit a weird hack
14:01:07 <mauke> ph88: typically you'd skip comments as part of whitespace handling
14:01:14 <mauke> it gets a bit harder if you want to keep them in your AST
14:01:16 <Squarism> How could i complete this parsec parser with "detailed parse errors" when failing identifiers are passed to read?
14:01:23 <Squarism> http://pastebin.com/1q4tQRmQ
14:01:46 <ph88> mauke, yes i want to keep them :p
14:02:09 <mauke> do you also want to keep redundant tokens?
14:02:19 <Squarism> .../nonexiting values that is
14:02:35 <mauke> e.g. normally x + y, (x) + (y), (((x)) + ((y))) all parse into the same tree
14:03:25 <ph88> yes i want to keep everything
14:03:31 <EvanR> quxbam: its nice if the type system doesnt freeze up because you made a mistake
14:04:01 <quxbam> EvanR: Better the typesystem then the runtime
14:04:07 <EvanR> uh
14:04:07 <mauke> ph88: then I'd design my tree such that every token corresponds to some tree node
14:04:17 <mauke> ph88: and every node gets a list of associated (following) comments
14:04:26 <ph88> oh i see
14:04:44 <ph88> comment on every node
14:04:52 <mauke> e.g. do x <- identifier; comments <- skipWhitespace; return (Identifier x comments)
14:04:55 <EvanR> quxbam: better neither
14:05:06 <ph88> should i put the comments near the terminals or higher up the tree ?
14:05:43 <mauke> do you care where exactly the comments appear?
14:06:01 <quxbam> EvanR: You can already write 5 lines of typeclasses which nuke the compilation
14:06:40 <EvanR> quxbam: well, you can make your own types that includes a special term for a number greater than any other, or you can turn on some extensions to allow the type system to freeze up. 
14:06:52 <mauke> an alternative approach would be to keep some associated state in your parser
14:07:25 <mauke> then your skipWhitespace action could push any comments it finds onto a stack
14:07:33 <mauke> without affecting the AST
14:07:43 <quxbam> EvanR: {-# LANGUAGE LazyTypes #-}
14:07:51 <mauke> it could also record their position within the source document
14:08:00 <EvanR> quxbam: thats not really the right way to get Omega
14:08:09 <EvanR> that works on the value level... by freezing up
14:09:33 <ph88> mauke, well i think they would best appear after the node before it
14:11:02 <buttons840> I've been looking at purescript and see it's support for "row polymorphism" on record field (i'm new to FP, hopefully i'm describe this well enough); does haskell have any similar features?
14:11:26 <buttons840> *its*
14:11:39 <EvanR> theres a package called vinyl for extensible records, but i gather purescript is nicer
14:13:08 <acowley> buttons840: Yes! See Vinyl and Frames
14:13:47 * hackagebot shellmate 0.3 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3 (AntonEkblad)
14:13:49 * hackagebot shellmate-extras 0.3 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3 (AntonEkblad)
14:14:30 <dolio> Type classes are like row types.
14:16:08 <buttons840> dolio: I see "magic type classes" is part 3 of OverloadedRecordFields; is that related to extensible records?
14:16:40 <dolio> Kind of.
14:18:23 <sm> why is the lens operator .~ not called .= ?
14:19:16 <buttons840> so extensible records are implemented as libraries in haskell; is this by choice, or because of legacy reasons? i do see some logical problems with the way purescript does extensible records, mainly that they depend on field names happening to match up, just because 2 fields share the same name and type, doesn't mean they're interchangable
14:19:18 <dolio> Because .= is the one that is a state action.
14:20:28 <dfeuer> buttons840, the extensible record design space is still being explored. It's a lot easier to play with ideas in library space *to the extent possible* before pinning them down in the language.
14:20:54 <dolio> They are implemented as libraries because the authors found that easier than writing a GHC extension and getting it merged upstream.
14:20:57 <dfeuer> Not easier for the library designers or users, perhaps, but easier for the ecosystem.
14:21:00 <sm> ah, there is a .= eh
14:21:08 <EvanR> its nicer if your language can ever do that in a library
14:21:14 <EvanR> then you dont need a language feature
14:21:34 <EvanR> idris has extensible records with scoped labels with nice syntax through their syntax extension mechanism
14:21:42 <dfeuer> Language features can ultimately help with syntax and performance, sometimes, but it's good to know just *exactly* what you want first.
14:22:11 <EvanR> and now idris is opening up the elaborator monad to user space
14:22:22 <dfeuer> Idris is a giant pile of nuts and bolts of various sizes all stirred together in gorilla glue and covered in duct tape.
14:22:37 <buttons840> dfeuer: sounds like a case of too many good options, and it's unclear which to choose; i've heard of this happening in a few times in haskell?
14:22:45 <dfeuer> Sure.
14:22:51 <dfeuer> Could be.
14:22:56 <EvanR> buttons840: "when in doubt, do what miranda did"
14:23:45 <dfeuer> BLAST
14:23:48 * hackagebot xlsx 0.2.2.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.2.1 (KirillZaborsky)
14:25:04 <linoge> So I'm learning about combinators, but I don't get how B = S(KS)K I mean, S is applied to K, then K is applied to (KS) and then ((KS)K) is applied to S right?
14:25:16 <buttons840> idris looks good to me, but I keep getting stuck on a silly edge case that causes segfaults when try it out
14:25:41 <Cale> linoge: That is backwards...
14:25:46 <EvanR> buttons840: pull requests welcome ;)
14:26:04 <Cale> linoge: S is applied to (KS), and the result is applied to K
14:26:10 <Cale> (S(KS))K
14:26:15 <buttons840> EvanR: yeah... I think I would need to be pretty good at C to fix this one though
14:26:23 <EvanR> maybe
14:26:32 <linoge> What
14:26:33 <EvanR> use valgrind luke
14:26:39 <Luke> ?
14:26:51 <Luke> what are you talking about?
14:27:00 <c_wraith> star wars joke. 
14:27:15 <Luke> oh. funny.
14:27:20 <Cale> linoge: Well, first of all, functions are applied to arguments, arguments are not applied to functions. Secondly, by convention, function application associates to the left, so f x y means (f x) y
14:27:25 <c_wraith> unfortunate name conflict between you and Luke Skywalker 
14:28:42 <linoge> Cale: Ok I understand, just that my mind is blending a bit too much lately x)
14:29:14 <buttons840> EvanR: i barely know what valgrind is -- i have considered contributing to idris, but I would probably feel like spending a month learning C first, which would probably be worthwhile for other reasons
14:33:56 <ph88> mauke, i thought of a small algorithm to figure out if a comment belongs to a node higher in the tree
14:41:28 <linoge> Cale: what's my best shot at getting good with combinators? I mean, I can derive the whole (s(ks))k thing, but at first sight it's kind of difficult for me to know what it does.
14:41:32 <linoge> Just practicing?
14:41:56 <kmelva> Hi folks, Haskell newb here, trying to do something usefull with generics. Here is a super simple example: https://gist.github.com/kmelva/ea35b25b0c86530748e31c7b6b9b691b
14:42:24 <kmelva> I would like to get the name of the datatype and constructor... now I know I have to use datatypeName and conName functions, but don't know how to do that...
14:42:46 <kmelva> I guess it's something like `datatypeName (undefined :: ???`
14:43:01 <kmelva> but I don't know how to construct a type that fits with `datatypeName` ...
16:04:00 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
16:04:00 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
16:04:00 --- names: list (clog ldbrandy dfeuer jedws jutaro kzhang takle nkaretnikov argent0 sevas Sonderblade Johannes13_ LangeOortjes timrs2998 begriffs_ fkurkows1 atzz_ nomotif Xal fizbin joelburget jonaias kiranneo alf_ pat1234 lyuha nineonine ffej1 torgdor montanonic augur a3Dman binaryplease edvorg Sgeo_ enthropy roboguy` chenshen dsh cdg dwins Guest19 Koen_ athan _davek rhalff wolfcore lritter MorpheusB groscoe hiratara cyphase ziocroc rgrinberg systemfault avn rjnw bluepixel)
16:04:00 --- names: list (_paul0 Brando753-o_O_o kmelva andrewvic Nivim zariuq Philonous chidy nikolaMilj2 djapo buttons840 chlong mada Big_G idev Destol m1dnight_ roconnor__ sdothum asthasr__ aarvar schell kosorith cods irrequietus zero_byte albel727 cbm80 vili DTZUBDUB copy` raek cschneid AntiSpamMeta MrWoohoo huckleberry78 tristero jtcs prkc xvilka_ yqt mgsloan melancholia_ cyborg-one kazagistar LaT0rtue PennyNeko whaletechno unclechu martin-t darkf ph88 Wuzzy thc202 grouzen)
16:04:00 --- names: list (fractalcat Luke wraithm Jesin bug2000 ipuustin adelbertc cereal_killer_ alevy seangrove Voldenet obihann knutstrut aragorn123 Zekka tag UnlikeSuika slackircbot keix Boney_ HallaSurvivor desophos xkapastel Swizec ozgura amf jophish__ TxmszLou govg mimi_vx agocorona Ravana simukis__ Sixmsj demilux david_koontz texasmynsted djbeau asayers readmore pie__ trism _sjs Rotaerk r143552 urodna jomg noraesae burp araujo xinming glguy Sorella pfurla whiteline arcetera)
16:04:00 --- names: list (mjo akermu yoku goodboy codyw theorbtwo rembo10 skeet70 zerokarmaleft herzmeister kmicu Sornaensis circ-user-vkmXT Tristan-Speccy king_jah obadz kadoban lambda-11235 Khisanth ljhms __name__ aatxe cpup dario Hakey danthemyth qnikst caumeslasal Sose ikke Tene ByronJohnson Jaak dmwit aplund sujeet bennofs bjz moop marr dibblego Motoko11 YellowaphocusOni hackebeilchen donwilliam totte eliasr kr36 Taylor cow_2001 der-landgraf kosmikus zv levi gnusosa fyolnish)
16:04:00 --- names: list (lachenmayer erikd kritzcreek moei chirpsalot Chobbes juhp t0m0 davean dsantiago Lynxium xplat doomlord dedgrant_ CurryWurst danvet atomi crodjer m0rphism shookees mfukar XBoy armyriad kav chronon-io bydo jack_rabbit Shandy Guest30774 hexagoxel lspitzner exferenceBot Nik05 pelegreno Cale justanotheruser hucksy_ phileas darkbolt acertain Vektorweg1 markus1199 predator117 Blkt nakal imalsogreg joehillen Qommand0r canta pikhq nexraf pikpok Pastaf mda1 Black-Wolf)
16:04:00 --- names: list (prophile yusukesuzuki brixen shwouchk DigitalKiwi bitemyapp alx741 zaquest _6a68 vic_ Bane^ lowryder liyang chattered M-krsiehl M-Illandan M-mistake M-david radix M-davidar M-schmittlauch _kit_ emmanuel_erc erzar_ johtso M-Quora jcreekmore ajmccluskey aloiscochard aphprentice kfpratt al-damiri fengshaun ph88^ Myrl-saki zos case39 Kneiva jo`ve Amnez777 eldon tetralion sword_smith Yuras kakos benl23 goldfire hackagebot coeus shesek dpower pyon tdammers)
16:04:00 --- names: list (electrostat dolio pikajude OutlawStar otto_s toon cross ploop Sonmi drbean cdk minsky mrowe MK_FG Adios fr33domlover NeverDie schjetne mdarse asjo dkasak bsamorim JPohlmann mero cjay miklcct rotty zudov tristanp hyuke Ralith_ greeny sm potatoe Deewiant codebje Raynes simony drewdavis watersoul jokleinn sqrt2 iliastsi banjiewen Eiam joshc stelleg josephle prooftechnique machinedgod Ranhir mmaruseacph2 rodlogic saml troydm Ashy Majiir robogoat ortmage garphy`aw)
16:04:00 --- names: list (opios andyo mounty besenwesen Skuzzzy Jonno_FTW LnL t0mb0_ solatis lokien jameseb tekacs LiaoTao fryguybob cosban APic nshepperd fangs124 _ashbreeze_ Fubar^ Vq rossberg koz_ spaceships CaptainLex nick123_ danieli Nycatelos samgd mirsal rockfruit Tesseraction_d ahihi jdt tusj martingale chrzyki gothos bencryption PlasmaStar slick Reda {AS} catsup RaoZvorovski Uakh Nahra tsou amiri ChongLi thalleralexander potbelly hausdorff wilx Princess17b29a brezel moredhel)
16:04:00 --- names: list (killtheliterate alanz sLite SuperTux88 cbaines raid minad impure_hate codehero usr nemesit|znc krgn jnoah sisir__ iphy SoupEvil lambdabot joncfoo warc felher nille epitron eL_Bart0- jknick TRManderson ppnkk Internet13 lpsmith adamCS karls luzie strixy Xe squisher SegFaultAX gracjan nisstyre haasn divVerent nak nathyong xa0 Cerise anders0 greymalkin nitrix Edoxile Guest31006 mudfog_ statusbot SaidinWoT pmade ggVGc janne- barrucadu funfun_ vqrs_ jtobin_)
16:04:00 --- names: list (spwhitt_ jophish_ jotrk_ stevenxl magicman_ M2tias horatiohb jrslepak Ezku_ kuno erg osfamero1 jackhill ent XMunkki_ phadej fabianvf mpickering Quintasan Walther kjnilsson Lord_of_- Jaxan_ mvr_ valdyn brt1 integral Dykam_ bizarrefish bwe frelux brolin_empey deavidsedice Flaeme shennyg micmus LoganG stass niteria dud` sz0 zoran119 gienah acowley shirt jud Natch coppro leadingthenet gniourf wedens Igloo bjs ClaudiusMaximus cdidd omgfrak c9s buddhabrot_ mauke)
16:04:00 --- names: list (cyberlard isocliff ninegrid platz Thulsadum thetallguy Eagle_Erwin hpc RGamma Vorpal dtulig the193rd jle` darxun OnkelTem codebam dalmahal louispan JeanCarloMachado ryanpcmcquen tlevine paf31_ mrkrwtsn infinity0 TheVoid themagician hbar_ Xack croben sleblanc arw CosmicRay hive-mind Cxom joeyh trevorb demize Arch-TK abrar lonokhov abra0 DDR richi235 Athas truncate gseitz Frankablu seraphime mnoonan bbee dgonyeo codedmart jcp etcinit emiliocobos gornikm)
16:04:00 --- names: list (dwynwen_ddlleyw YP-Cloud__ qguv FMJaguar tomus pkogan_ pdgwien max-m zmanian__ yaknyasn mniip pootler_ stasku____ nbouscal nkpart incomprehensibly si14 strmpnk cnr Guest34040 aristid Scorchin etrepum Xorlev rstone cin ircbrowse nyuszika7h x1n4u fall_ abbe japesinator vpm froztbyte benjamincrom Gothmog_ Purlox zeroskillor davl spacebug_ nurupo mak` dustinm` int-e rofer _flow_ asm89 mt geekosaur tortal majoh lassulus okek cocreature nesqi borkdude zzz_nek0)
16:04:00 --- names: list (hyPiRion defanor coup_de_shitlord keteim tek0_ [BNC]clion Saizan_ hanDerPe1er BrianHV_ Liskni_si omilu_ lieven sbauman hc Simsonsan georgew BrAsS_mOnKeY Guest3280 yorick kyagrd monad_cat benonsoftware Wamanuz2 TabAtkins runeks hansihe ryoia jonrh robertk staticfox inr_ flux Freundlich pavlicek cjwelborn daph thebnq WizJin jgertm gauge keemyb Tinchos metaf5 dju Rodya Maerten angular_mike dixie libreman noam benwbooth tgeeky emmflo Soft ninedotnine etabot)
16:04:00 --- names: list (lambdayak l3france zyla naudiz trajing jessicah shans_ cstrahan dpn` phuu askarpo zero7 PotatoGim seanparsons coddinkn BlackYoup chishiki mkloczko bgamari hegge kantokomi mitch_ tobiasBora marmalodak andrewsw derpderp eddsteel bwbaugh condy rainbyte jeyraof thomie robot cgfbee Guest54896 dschoepe nullfxn tjbp Cetusx mach marsam euphoriaa c-rog nilOps shelf martinbjeldbak nekomune sleezd happy0 adarqui jrp6 Nimatek rfw Sigyn capisce Taneb riscool nwf jorj)
16:04:00 --- names: list (neshmi reem buoto mkurkov tippenein solidus-river S11001001 JackMc bitonic dkua stephe_ jlyndon pchiusano AlainODea dstockwell joedevivo kloeri caw tjpeden ericbmerritt spinda parsnip bkonkle andreypopp wyvern henriquev trevorriles sclv ocharles avdi zpconn__________ jroesch_ RevJohnnyHealey radge___ fuziontech zph_ amatecha nyandoge chriswk alphonse23_ bgyss yminsky katymoe dan64 lexi-lambda carter arrdem Bigcheese jfokkan__ lancetw OliPicard cantstanya)
16:04:00 --- names: list (sephiap Desu bigs spicydonuts briansmith reynir epta lyxia adamh sinopeus dicioccio phaskell wizonesolutions solidsnack julm edwtjo dcoutts oberstein SolarAquarion xacktm Elsi vigs abh_ Tiktalik Vbitz_ cschneid- acfoltzer Ulrar KorriX_ Cr8 petercommand Ferdirand Chousuke ion davidtho1as liif frontendloader squimmy mingc marens Guest54063 ixian dh gregf_ idupree jlengyel zxtx masquerade jlewis zimp1 aleator Hafydd sewilton Xnuk Jinxit eamelink mlhmwglt bounb)
16:04:00 --- names: list (Meow-J TheMystic lhynes StoneToad orion urdh ThePhoeron rork hot_Nolrai polux Plastefuchs IndigoTiger NemesisD Kavec Morgawr mendez_ RayNbow`TU Raptor8m3 ynyounuo Guest83419 mceier byorgey Moyst marcel mbrcknl mankyKitty harmchop xplat|work rom1504 betawaffle surtn henrytill kipras tnks przembot dilinger Lutin` hongminhee joeytwiddle thomas Matajon awal Maxdamantus unsymbol mudfog SLi hpd otterdam oelewapperke chelfi noplamodo padre_angolano jorendorff_ razi1)
16:04:00 --- names: list (MorTal1ty vikram_________ mno2 thoughtpolice CARAM__ zrl_ alem0lars beckyconning_ mindos_cloud____ irclogger_com bedouin peddie TimWolla vikraman jokester Akii Biohazard ggherdov stiell spion myfreeweb avocado jstolarek yodeler pyrtsa xnyhps tarcwynne_ jmct knyppeldynan noexcept mikeplus32 tessier_ kriztw Ke Slush- Eliel_ huonw mephx_ grol_ Ewout milessabin ebird monkeyiqde kipd shelling__ loopspace jre2 Hijiri Amadiro catern jb55 tomjaguarpaw jimki_ quuxman_)
16:04:00 --- names: list (sshine SHODAN PierreM_ angseus_ relrod isomorphismes lokydor mj12` swilsonau Zemyla siddhu clever tswett averell ao1ei8 zenzike Intensity igniting toure lanodan gridaphobe hjljo acro dxtr Baughn Geekingfrog marienz Neseth Desoxy jzl telser jbalint __main__ geppettodivacin mrshoe kier parsnipM_ fold4 `0660 funrep thorkilnaur_ tomku d3lxa AustinMatherne Yaiyan qic0de Axman6 Fylwind mokus ps-auxw SenpaiSilver ricardo82 b_jonas mitchty andjjj23 bogdanteleaga)
16:04:00 --- names: list (mathu pranz leftylink pdxleif xxpor vin-ivar tokik newsham xou luite cogrendel brisbin shapr aweinstock mw Elision marko__ mrd Guest78801 luis wamaral tolt theDon Vivek eyenx lattenwald [swift] RaitoBezarius worch baweaver Laney lstrano k3d3 swhalen cow-orker Clint arianvp hemite bananagram comstar arkeet Reyu quicksilver zuz_ trig-ger crank1988 kini c_wraith chaptastic RageD gpampara M-ou-se iross_ joco42_ capicue indiffernet_ bd__ edwardk jrib julmac posco)
16:04:00 --- names: list (pacak caasih fergusnoble bjobjo ndeine RazorX \u gbarboza mjrosenb luigy_ aaron7 zyoung_ freekevin logcat ollef sajith rbocquet obcode kalloc uwap wtw hxegon_ak ski_ Iceland_jack maerwald @ChanServ nxnfufunezn Mandus cjh` davesilva rieper n__dles EvanR zopsi pharaun tumdum dunj3 callumacrae vodkaInf1rno tsani lispy Factionwars Jello_Raptor MasseR simpson ec\ Belgarion0 ReinH monty Profpatsch fionnan_ fmapE irishsul1an ephemeron rvncerr acomminos Adeon)
16:04:00 --- names: list (ironChicken Xandaros owa armlesshobo Pucilowski Cathy tomaw Twey guios bernalex ft stux|RC-only octo- qnix_ tumdedum zomg niluje KaneTW statusfailed robtaylor Ov3rload marmoute pleiosaur tero- hodapp rtur ernst andreass scopedTV mads- ongy GGMethos glckr_ hiredman zhulikas_ supki SphericalCow kshannon gabiruh Watcher7 qz cursork nikola Ankhers Saimeidae noctux kyren Ornedan Rembane jinblack sohum icedev anoe sparr Boreeas sanitypassing joachifm sdboyer)
16:04:00 --- names: list (BigEndian dxld exio4 sdx23 lyddonb alpounet julienXX stomp Willis skarn cynick optocoup1er mrlase zymurgy jaaket kaol jstimpfl1 notdan yamadapc anachrome sgronblo koomi koala_man __rlp ario ephess_ geal bsermons sellout numberten lukky513 ddima_ maskd friden gargawel jkarni tych0 Atlanis deni tg bergmark karshan knittl amontez o`connor lenstr dasmith91 tzaeru DANtheBEASTman liste Erebe gratimax kennyp phz_ lnx PHO sleepynate low-profile yarou ahf honkfestival)
16:04:00 --- names: list (Drezil yeltzooo Starfire aparent eagleflo jlouis wayne Speed Ring0` so eikke sjl_ carter-znc bshelden quaestor Reisen CindyLinz eyck comboy obiwahn ManiacTwister sphalerite cYmen Tehnix da-x yude KeelOfSteel srcerer jgornick niko brennie kungp TommyC lpaste Tritlo benzrf staffehn orcus gsingh93 LeaChim amuck OH- a6a3uh schnizzle Diabolik pointfree sunfun drdo chris2 tazjin lin mikeizbicki wjm dfranke linduxed shahn srhb psacrifice bcoppens cmn dqd tv DrCode)
16:04:00 --- names: list (Unode Kruppe rcsgns nopf shachaf mek42 wolf_mozart negatratoron bind earthy suppi hvr u-ou kjanosz lucz Oxyd wedify hydraz swistak35 wting Bashmetim seliopou edmund_ taruti shellyssh earldouglas agrif larsen seagreen docnvk xaimus ireniko alang Horv Ariadeno_ wagle opqdonut klugez johnw fingerzam1 oherrala cic1 mtesseract pfoetchen jix ned dredozubov cheater boothead godel foo_ jcurbo Klumben saurik Caelum monochrom Ralith Paks guampa JRHaigh nathanic)
16:04:00 --- names: list (shutdown_-h_now meretrix ali_bush bartavelle heurist ski zolomon ziman LordDeath ElderFain ramatevish mgaare mattp_ mosh sizur Sam_ DustyDin1o esssing carc s4kashya elgot myme kishar whoops sbrg MitchW)
16:49:55 <codedmart> Is there a common name for this ? If I have a function that takes two functions and two variables and applies then like this -> f(g(a), b)
16:50:27 <geekosaur> looks vaguely Arrow-ish
16:50:34 <athan> yeah I'm calling `first`
16:51:26 <codedmart> I am not sure what to name it.
16:51:50 <codedmart> Seems like something that is present already.
16:52:41 <EvanR> @pl \f g a b -> f (g a, b)
16:52:41 <lambdabot> (. ((,) .)) . (.) . (.)
16:53:08 <EvanR> @unpl (. ((,) .)) . (.) . (.)
16:53:08 <lambdabot> (\ k q e h -> k (((,)) (q e) h))
16:53:17 <Koterpillar> @pl \f g a b -> f (g a) b
16:53:17 <lambdabot> (.)
16:53:35 <Koterpillar> ^_^
16:53:37 <EvanR> lol
16:54:06 <codedmart> What does that mean? It is (.)?
16:54:52 <Koterpillar> first of all, that's the same as \f g a -> f (g a)
16:55:11 <codedmart> Ah right
16:55:14 <Koterpillar> so, yes, it is (.)
16:56:44 <codedmart> Thanks!
17:03:54 * hackagebot unordered-containers 0.2.7.1 - Efficient hashing-based container types  https://hackage.haskell.org/package/unordered-containers-0.2.7.1 (JohanTibell)
17:18:55 * hackagebot bond-haskell-compiler 0.1.3.0 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.3.0 (blaze)
17:18:57 * hackagebot bond-haskell 0.1.3.0 - Runtime support for BOND serialization  https://hackage.haskell.org/package/bond-haskell-0.1.3.0 (blaze)
17:23:47 <codebje> :t (.)
17:23:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:23:53 <codebje> :t curry
17:23:54 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:23:55 * hackagebot hpio 0.8.0.2 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.2 (dhess)
17:24:00 <codebje> :t uncurry (.)
17:24:01 <lambdabot> (b -> c, a -> b) -> a -> c
17:24:58 <Squarism> what is the shortest way i can test an value is made from a certain constructor?
17:25:23 <Koterpillar> Squarism: case?
17:25:31 <codebje> case v of { Thing _ -> True; _ -> False }
17:25:32 <Squarism> test :: a -> Bool
17:25:46 <Squarism> ok
17:25:51 <codebje> test (Thing _) = True ; test _ = False
17:25:56 <Koterpillar> Squarism: codebje: why use a Bool?
17:26:02 <Squarism> partition
17:26:29 <codebje> Koterpillar: no clue here, working without context :-)
17:26:49 <Squarism> well i want to separate a list into 2 lists
17:26:56 <Squarism> thought partition would be the thing
17:27:02 <Koterpillar> ah, ok, just don't make it explicit - it might be hard to figure out later which one is true and which one is false
17:27:48 <codebje> if it's for a partition, I'd most likely call it "isThing" and stick it in a "where" so it's localised
17:28:18 <Squarism> good point
17:28:33 <codebje> or use a case lambad and do it inline
17:28:45 <codebje> partition (\case {Thing _ -> True; _ -> False}) ls
17:29:04 <hpc> :t partition
17:29:05 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:29:19 <hpc> handy
17:30:00 <EvanR> (except for the bool test)
17:30:58 <Squarism> you people work professionally with haskell?
17:31:08 <Squarism> like full time?
17:31:12 <EvanR> groupFromBeyond :: (a -> Dynamic) -> Map Dynamic (NonEmpty a)
17:31:42 <maerwald> Squarism: "you people"? errm. Some do, some not.
17:31:51 <codebje> Squarism: not me, I sneak it in professionally when no-one is looking
17:32:22 <hpc> i use perl, but i write it in more of a functional style than i do my haskell
17:32:39 <EvanR> more functional than haskell?
17:32:56 <systemfault> Haha
17:32:56 <codebje> haven't we established that haskell is a great imperative language already? :-)
17:33:03 <maerwald> I write imperative haskell and every other language functionally.
17:33:06 <codebje> whereas it's clear perl is a lousy imperative language
17:33:13 <Squarism> just curious what companies are that smart... and how many have scored such a dream job
17:33:18 <maerwald> codebje: not particularly even
17:33:42 <maerwald> exceptions in haskell are awkward, IO is awkward
17:33:43 <codebje> Squarism: check reddit.com/r/haskell, there's a job posting there once a month or so
17:33:47 * EvanR tries to image perl as an imperative language
17:34:25 <maerwald> imperative haskell is just like writing C, except there is a GC
17:34:32 <EvanR> its more like a declarative language with side effects as denotations
17:34:38 <systemfault> Can't be as bad as C.
17:34:40 <systemfault> Just no.
17:34:53 <codebje> imagine if C was statically typed, perhaps?
17:35:00 <systemfault> It is...
17:35:06 <maerwald> systemfault: it is if you really do imperative low-level stuff... e.g. filesystem, or using C bindings or whatever
17:35:07 <systemfault> It's just weakly typed..
17:35:21 <codebje> type or type not, there is no cast
17:35:28 <Squarism> codebje, good to know.. i guess its like tossing out meat in a crocodile farm
17:38:05 <divVerent> Is there any way to include a whole text file as a string at compile time
17:38:11 <divVerent> (ideally binary too)
17:38:12 <Squarism> im at a Java company where people in charge are very tired and think FP is a flavour of the month. "Remember to do you null checking"
17:38:30 <divVerent> I.e. something like bin2c, bin2obj
17:38:34 <Squarism> "cant do enough null checking"
17:38:43 <divVerent> (purpose: embed javascript code into the binary)
17:39:11 <systemfault> Squarism Optional<T> :P
17:39:16 <EvanR> you can link objects if you want and get the data with FFI
17:39:23 <EvanR> or put them in the haskell code with TH
17:39:40 <divVerent> right, FFI - but that gets nasty
17:39:55 <divVerent> TH - is there a way to set a custom end delimiter
17:40:04 <EvanR> embedding this sort of data in a binary is nasty
17:40:16 <divVerent> as I'm not sure if I can guarantee there is no |]
17:40:28 <divVerent> EvanR: well, I do it for the HTML code
17:40:36 <divVerent> by generating it using blaze-html
17:40:45 <EvanR> TH would load the file in, it wont re-run after that
17:40:53 <divVerent> but I also prefer HTML and JS to be together, so...
17:41:01 <EvanR> so |] in a string literal wont have any effect
17:41:17 <divVerent> oh, cool, need to look into that then
17:41:38 <EvanR> does it really need to be in the binary
17:41:52 <Koterpillar> divVerent: Hamlet?
17:42:12 <divVerent> EvanR: well, the HTML templates are
17:42:27 <EvanR> does that need to be in the binary?
17:42:35 <Koterpillar> divVerent: https://hackage.haskell.org/package/shakespeare-js-1.0.0.1/docs/Text-Julius.html#v:jsFile
17:43:15 <divVerent> not bad, so yes, that's the alternative
17:43:26 <divVerent> load both HTML templates and JS at runtime
17:43:30 <dolio> systemfault: Optional<T> just means you have to check for null twice.
17:43:31 <divVerent> just want the two consistent
17:44:10 <divVerent> btw the JS wouldn't be hand editable anyway
17:44:23 <divVerent> so I don't see how embedding is worse
17:44:47 <divVerent> (using closure compiler for static type checking and linking)
17:45:42 <divVerent> hehe, a haskell DSL generating JS...
17:45:51 <ElectricSolstice> newbie question. How does one curry a function to return a function that is just able to be callable without args? Like creating a callback function from a function.
17:46:17 <codebje> a function that's callable without args is just a value; given lazy eval, there's no difference
17:46:31 <ElectricSolstice> What if i need it to do IO
17:46:33 <EvanR> divVerent: sounds way better
17:46:34 <codebje> otherwise, you want unit: f :: a -> b -> () -> c
17:46:34 <ElectricSolstice> like for a button callback
17:46:45 <codebje> z :: IO ()
17:46:49 <koala_man> ElectricSolstice: then you just return an IO Foo 
17:46:52 <codebje> that's still just a value :-)
17:47:02 <Squarism> My current project is called Julius Caesar and it will need a Web interface. Ill have a look into shakespeare-js/Julius for sure!
17:47:05 <benzrf> ElectricSolstice: haskell is pure, or hadn't you heard? :p
17:47:16 <divVerent> EvanR: haha, sunroof
17:47:52 <ElectricSolstice> lol, it's pure, but still has to work with libs like gtk.
17:48:17 <EvanR> also a function without args isnt a function would be true even without laziness
17:48:33 <EvanR> idris
17:48:48 <benzrf> EvanR: actually...
17:48:59 <divVerent> how would it not be a function?
17:49:03 <benzrf> EvanR: () -> Foo in idris can be useful if you want to pass something around that might diverge
17:49:05 <EvanR> how would it be
17:49:11 <benzrf> iirc
17:49:21 <EvanR> benzrf: Lazy is a built in suspension so you dont need () ->
17:49:22 <divVerent> or do you mean in the syntax sense, where all functions have exactly 1 arg?
17:49:27 <benzrf> EvanR: eh, alrught
17:49:29 <benzrf> *alright
17:49:42 <EvanR> divVerent: in the math sense
17:49:53 <EvanR> functions map between two things
17:49:55 <divVerent> in the math sense it is possible though
17:50:05 <divVerent> no args means 1 value in the range
17:50:09 <EvanR> what is the sound of a function from .. no where to somewhere
17:50:18 <divVerent> it's a constant function
17:50:23 <EvanR> then it takes 1 argument
17:50:50 <EvanR> even function from empty set
17:50:53 <divVerent> mathematically, a function of 2 args is a function from e.g. R x R -> R
17:51:01 <EvanR> sure
17:51:17 <divVerent> of zero args would NOT be {} -> R though
17:51:17 <EvanR> (A,B) -> C
17:51:26 <EvanR> zero args makes no sense
17:51:30 <EvanR> that would be 
17:51:31 <EvanR> -> C
17:51:32 <divVerent> but {a} -> R for some a
17:51:41 <divVerent> as {a} x R is isomorphic to R
17:51:53 <divVerent> and {} x R is not
17:52:03 <EvanR> bijective maybe
17:52:07 <EvanR> the same thing no
17:52:09 <divVerent> so the "zeroth power" must have one element
17:52:45 <divVerent> well, I meant you can define the ops properly as homomorphous in both directions
17:52:46 <EvanR> the -> has two sides
17:53:14 <divVerent> using the "one element field" which only almost exists
17:53:25 <EvanR> ???
17:53:52 <divVerent> essentially, I just meant that {a} x R and R basically have the same algebraic structure
17:54:02 <EvanR> did we answer the original question or
17:54:09 <divVerent> well, sort of
17:54:25 <divVerent> function with no args = function from one element set
17:54:32 <divVerent> mathematically
17:54:43 <divVerent> an useless degenerate case
17:54:45 <EvanR> thats not a very nice =
17:54:46 <divVerent> but it does exist
17:54:49 <ElectricSolstice> Still having trouble with this. Basically, i'm wanting to create a callback for a gtk button that will modify things and I don't know how to do that in haskell.
17:54:59 <divVerent> unlike the function from the empty set
17:55:04 <EvanR> enough
17:55:09 <Koterpillar> ElectricSolstice: gi-gtk or gtk?
17:55:19 <ElectricSolstice> gtk3-0.14.2
17:55:47 <codebje> ElectricSolstice: let's say you want to print "hello" five times when the button is pressed: action :: IO (); action = replicateM_ 5 $ print "hello"
17:56:17 <codebje> ElectricSolstice: the IO action created won't print anything when it's defined, only when it's evaluated, and every time it's evaluated in the IO monad it'll print hello five times
17:56:23 <Koterpillar> ElectricSolstice: is your problem creating a callback or doing things in it?
17:56:41 <EvanR> the IO action wont print anything when its evaluated
17:56:48 <EvanR> but when its executed 
17:57:13 <codebje> sorry, used "evaluated" meaning "evaluated in a sequence of IO actions" which is better expressed as "executed" :-)
17:57:21 <ElectricSolstice> both? I'm wanting a call back that can modify the values in a row of a TreeView, but i'm keeping it simple by trying to just practicing on simpler things for now.
17:57:46 <ElectricSolstice> because i'm not sure how to pass in the TreeView or model or whatever it is to the callback
17:58:23 <ElMoloko>  
17:58:23 <ElMoloko>  
18:00:18 <ElectricSolstice> so the callback needs access to certain things. But I'm guessing the callback can not be called with args on the button click. So, it's doing things in the callback.
18:00:25 <codebje> mkCallback :: TreeViewClass t => t -> IO (); mkCallback tree = doSomethingNiftyWith tree
18:01:52 <EvanR> ElectricSolstice: when you have A -> B -> C -> D, you can pass in just the A, or the A and B, or all three arguments. 
18:01:55 <codebje> might be the model class you want, though
18:02:14 <EvanR> this is useful for giving a callback access to stuff later
18:03:08 <confuzed> Hi, I am new to Haskell, and I have a question that's been bothering me. It seems like a lot of the abstractions used in Haskell are built on Monads and Monad transformers, but it doesn't seem as though their aren't any real checks to ensure that a Monad instance is really monadic (checking that the laws hold for a given instance), and as monads do
18:03:08 <confuzed> n't compose easily, how are they a good abstraction?
18:03:20 <confuzed> there are*
18:04:18 <codebje> confuzed: Haskell programs can't be proven in Haskell, so there's no machine checking of the laws
18:04:50 <codebje> confuzed: other languages _can_ do that, but even then you usually have to help it out except for the most trivial of proofs
18:05:29 <codebje> confuzed: monads are a useful abstraction of effects, but their composability issues are an ongoing area of research
18:05:49 <codebje> monad transformers are a generally not-too-clumsy way to handle it
18:06:04 <ElectricSolstice> Thanks. Guess I was overthinking it.
18:06:53 <drostie> Looks like the only FRP packages still under active development are reactive-banana and yampa...
18:07:43 <mgsloan> drostie: Reflex is the new hotness
18:08:00 <drostie> mgsloan: thanks, that's good to know. :D
18:08:56 * hackagebot cache 0.1.0.0 - An in-memory key/value store with expiration support  https://hackage.haskell.org/package/cache-0.1.0.0 (hverr)
18:09:16 <drostie> I am basically trying to write a quick and dirty history for a shadowy corporation in a book; I know that I need a bunch of randomly-delayed sequences according to some probability distribution, and then those sequences need to trigger other probabilistic sequences as the objects that they bring in variously are subjected to random experiments and possibly explode or else are archived.
18:10:17 <drostie> I figured the timestreams stuff sounded FRP but it depends on how bad it's going to be to incorporate a StdGen state through each signal...
18:10:32 <mgsloan> unusual application of FRP!  Doesn't sound very interactive, though
18:10:39 <mgsloan> Some pure function should be sufficient
18:11:31 <drostie> Maybe. It's possible that I'm overthinking this and should just generate some big [[[[[(Time, Event)]]]]]] thing and then concat it down and sort it all.
18:12:40 <mgsloan> Yes, I think that will probably be closer to what you want
18:14:43 <benzrf> drostie: sounds to me like you want to generate a directed acyclic graph of events & then collapse it into a list whose ordering is compatible with the graph ordering
19:18:53 <Revenarus> Are there any resources online to serve as a followup to CIS194?
19:23:59 * hackagebot stratux-types 0.0.5 - A library for reading JSON output from stratux  https://hackage.haskell.org/package/stratux-types-0.0.5 (TonyMorris)
19:28:59 * hackagebot stratux-http 0.0.5 - A library for using HTTP with stratux  https://hackage.haskell.org/package/stratux-http-0.0.5 (TonyMorris)
19:29:01 * hackagebot stratux 0.0.5 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.5 (TonyMorris)
19:39:28 <kadoban> Revenarus: NICTA, kinda. It's not a direct followup though I wouldn't say. But it's really cool.
19:40:13 <Revenarus> Looks pretty interesting, thanks.
19:43:51 <Squarism> what web frameworks are worth checking in? Im gonna do some sort of onepage ajax negotation centric thing. More like a game ui than tables and form. Would prefer some type component "abstraction", but can live with brute html/js spagetti
19:44:20 <kadoban> Squarism: reflex-dom
19:44:21 <Squarism> type of component...
19:51:54 <Squarism> kadoban, is it above the rest (whatever they are)? 
19:52:33 <kadoban> I dunno, I think it's pretty cool. I haven't used much else I'd use for that.
19:54:19 <Squarism> i seems very "low level". manipulating div's and such. Theres no templating "system" there you define value's connected to "templates" and define a set of paramters for each "block of html" so to speak?
19:55:06 <kadoban> Naw, there's no tie-in with any of the templating things (yet?).
19:55:07 <mgsloan> Someone recently posted their reflex-based templating system
19:55:51 <mgsloan> https://www.reddit.com/r/haskell/comments/4l72ap/i_created_a_jsxlike_quasiquoter_for_reflex/
19:56:44 <mgsloan> One of the reasons that reflex-dom feels a bit low level is that it just ghcjs-dom.  This way, if you have no js deps, you can actually compile or interpret your reflex-dom app via regular ghc + headless webkit
19:56:54 <kadoban> Huh, that looks cool.
19:56:58 <mgsloan> *just uses ghcjs-dom
19:57:27 <mgsloan> Yeah, pretty nifty!  Not quite as powerful as full blown conditionals + loops templating
19:57:39 <mgsloan> But perhaps that is too much power for a templating thing anyway
19:57:47 <Squarism> mgsloan, thanx!
19:58:55 <EvanR> templating is super functional of a problem
19:59:17 <EvanR> looping and gotos within a template ... why
20:02:25 <Squarism> should be possible to define "functional" templates
20:03:26 <EvanR> im sure theres many 
20:03:41 <EvanR> for haskell at least
20:04:06 <Squarism> im not so sure about mixing haskell and html in same file though
20:04:39 <Squarism> or im sure its a bad idea
20:07:35 <EvanR> you wouldnt use html
20:08:03 <EvanR> it would be a combinator based unparser
20:08:15 <EvanR> since html is a tree, its very easy
20:08:45 <EvanR> you can rearrange and replicate subparts, or obviate them based on the passed in criteria
20:09:07 <EvanR> if HTML has this in its language already the world would be a different place right now
20:10:53 <EvanR> and i cant find a haskell package for this
20:12:02 <Squarism> id be if could map constructors to html files and do tree manipulation of the constructor values
20:12:08 <Squarism> id be happy...
20:12:24 <Squarism> for each sub part
20:12:58 <EvanR> well look at heist, it seems to have a lot going on
20:13:15 <EvanR> just not apparently what i was describing
20:14:36 <mgsloan> EvanR: template "looping" is closer to map.  Totally functional
20:14:40 <Squarism> MyPage (Menu ..) (Content [TodoList [TodoRow], TodoForm]])
20:14:46 <Squarism> sortof
20:14:50 <mgsloan> there is nothing non-functional about conditionals, where did  gotos come from?
20:15:09 <Squarism> ok.. ill check heist up
20:15:14 <mgsloan> You seem confused about the relationship between templates and the imperative paradigm
20:15:29 <Squarism> me?
20:15:36 <mgsloan> No, EvanR
20:16:11 <mgsloan> There are some within the community that don't think that TH is a good idea
20:16:16 <EvanR> you can choose to write your templates without side effects, but imperative control flow, "printing" each "line" of html is not that nice
20:16:34 <mgsloan> Somewhat due to implementation specifics that may change in the future (takes a while to load ghci)
20:16:36 <EvanR> it takes more space, and hurts my brain
20:16:51 <mgsloan> Excuses!
20:17:16 <Squarism> what is TH?
20:17:20 <schell> what about using Lucid or Blaze.HTML? maybe that’s already been mentioned?
20:17:40 <EvanR> ah i was thinking of Blaze
20:17:42 <mgsloan> Squarism: Template Haskell, it lets you generate code
20:18:07 <Squarism> schell, thanks.. ill check those out
20:18:23 <schell> i used to like blaze, now i use mostly lucid
20:18:36 <schell> they’re basically the same but lucid is a bit more consistent
20:18:47 <schell> the API, that is
20:21:45 <mgsloan> Ja, I've been meaning to write a lucid dsl for reflex one of these days
20:22:03 <mgsloan> I'll probably need to start a new reflex-dom project, though (not sure when that will happen)
20:22:30 <mgsloan> (too much effort to create it anew + refactor the entirety of current project)
20:22:50 <Squarism> i love Wicket on JVM. It has a very clean separation of presentation and behaviour/logic... you done need to see a world of html/js and can still create advanced interfaces
20:23:05 <Squarism> dont
20:27:07 <mgsloan> Overall reflex-dom has been really excellent for writing stuff that "just works".  A lot of this is from being so explicit about the flow of info
20:27:53 <mgsloan> One issue with this way of handling info flow, though, is that it means you can end up coupling a fair amount of the logic with the presentation
20:28:22 <mgsloan> And this gets tricky when you need to plumb info from one part of the DOM to a very different part of the DOM
20:28:47 <mgsloan> I suspect there is a good way to address this, I just haven't thought very hard about it yet
20:29:41 <mgsloan> In particular, the tricky case is having a modal dialog directly under <body>, and having that communicate with misc users of modal dialogs within the codebase
20:29:52 <mgsloan> (yes, modal dialogs == gross ;) )
20:30:45 <EvanR> what, they are awesome...
20:30:49 <EvanR> UI wise
20:31:00 <EvanR> if used correctly and not on a phone
20:31:16 <williamyager> How do I get Liquid Haskell to recognize that structural recursion counts as a "decreasing parameter"?
20:31:31 <williamyager> I have a binary tree "data T a = L | T a (T a) (T a)"
20:31:50 <williamyager> and Liquid doesn't seem to understand that by recursing into one of the branches, that's a decreasing parameter
20:32:26 <EvanR> liquid haskell is strict?
20:32:45 <williamyager> What do you mean by strict in this case?
20:32:53 <EvanR> the tree must be fully constructed
20:33:02 <ggVGc> after reading about liquid haskell, I still don't udnerstand what it is
20:33:29 <EvanR> if the tree can be infinite, then it makes sense that doesnt count as decreasing
20:33:38 <williamyager> EvanR: And how do I ensure that this is the case in a way that LH understands?
20:34:18 <ggVGc> is liquid types essentially something approaching dependent types?
20:34:21 <williamyager> In e.g. https://github.com/ucsd-progsys/liquidhaskell/blob/master/docs/slides/BOS14/hs/end/03_Termination.hs
20:34:34 <williamyager> They seem to have no problem with potentially corecursive data structures
20:34:43 <williamyager> ggVGc: Not quite. It's based on refinement types
20:35:00 <williamyager> ggVGc: It allows for some pretty rich computation to happen at the proof level
20:35:12 <ggVGc> hm
20:35:22 <williamyager> It's a different approach to proving correctness that can accomplish many of the same things as dependent types
20:35:30 <ggVGc> it seems strange to me to add extra type safety to a language like haskell that already has much stricter typing than most languages
20:35:33 <williamyager> it's called "refinement types" because you can "refine" haskell types with more information
20:35:39 <ggVGc> alright
20:35:41 <ggVGc> sounds cool
20:36:05 <EvanR> williamyager: i found... page 48 of this book! https://ucsd-progsys.github.io/liquidhaskell-tutorial/book.pdf
20:36:14 <ggVGc> williamyager: yesterday I wanted to embed "this number is always lower than this other number" in the type system, and couldn't do it in haskell. Could refinement types do that?
20:36:18 <williamyager> ggVGc: It's very hard to prove things like "this function always returns an integer that's a prime" even with dependent types, but I think not too bad with refinement types
20:36:23 <williamyager> ggVGc: Yes
20:36:30 <ggVGc> cool
20:39:07 <splanch> Does production Haskell use custom Prelude?
20:40:04 <williamyager> EvanR: I don't see where they're telling Liquid that their trees are finite
20:40:37 <EvanR> no... i mean its a tree example
20:40:46 <williamyager> ???
20:40:50 <EvanR> i have a feeling you need to add refinements somehow to get this to work
20:41:09 <EvanR> and that trees are just like haskell trees by default
20:41:45 <EvanR> im getting interested in liquid haskell now, but its too late tonight
20:42:12 <ggVGc> in haskell it's easy to get stuck writing a completely correct program, that doesn't do much..
20:42:15 <ggVGc> :(
20:42:22 <EvanR> haha
20:44:07 <EvanR> ggVGc: if you can take that back to ruby, and know that writing completely correct is even actually possible, then do it "way easier here" then... winning
20:44:49 <EvanR> it wasnt until i got into haskell that i thought "completely correct" even existed
20:45:00 <EvanR> prior wisdom was "there will always be bugs"
20:45:29 <Squarism> why o why do i get the result: "1 of 1 test suites (1 of 1 test cases) passed." when running "cabal test" where my test file looks like this : http://pastebin.com/gUhUuUQj
20:45:51 <Squarism> cleary 4 testcases in there
20:45:59 <EvanR> sorry pastebin is ...
20:46:20 <Squarism> lpaste is ... down
20:48:19 <glguy> Squarism: You'll still do well to find somewhere else to paste to; a lot of people won't open pastebin links
20:48:44 <Squarism> oh ok.. is it maffia owned?
20:49:17 <shachaf> If you want your pastebin.com links to be friendlier, use the "raw" link instead.
20:49:32 <shachaf> I'd open a raw link but probably not the regular kind.
20:49:52 * glguy doesn't know what "maffia" is
20:50:05 <Squarism> http://pastebin.com/raw/gUhUuUQj
20:50:46 <Squarism> mafia.. (maffia is swedish)
20:55:56 <glguy> Squarism: Looks like the problem might not be in your test file
20:56:31 <glguy> Maybe in your cabal file or project directory structure; maybe you're not running the version of the tests represented in this file
21:00:47 <glguy> Squarism: Oh, the problem is that you're expecting to see more output than a cabal exitcode-stdio can show
21:00:48 <Squarism> cabal file is here : https://github.com/gurgl/julius-caesar/blob/master/haskelltest1.cabal
21:01:14 <glguy> All that cabal knows is that it ran the test executable and it returned a success code
21:02:04 <Squarism> and the test file again https://github.com/gurgl/julius-caesar/blob/master/src/Tests.hs
21:03:36 <glguy> anyway, this is "working as usual"
21:03:48 <glguy> If any of your tests had failed you'd get more output about it
21:09:14 <Squarism> so that part of cabal/hunit is a bit buggy? 
21:10:23 <Squarism> well, not very important, but the testcase count is a metric that can motivate you. Dunno about you but such things make me happy =D
21:18:38 <confuzed> Do Haskellers consider Rust lang to be a good language? I see a lot stolen from ML and Haskell in Rust, but I'm too knew to either language to know if they stole the right stuff and if I should consider it for my system programming needs
21:20:12 <jxv> yup
21:29:03 * hackagebot monoid-extras 0.4.1 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.1 (BrentYorgey)
21:34:04 <Axman6> confuzed: having a type system that helps the programmer avoid programming errors definitely endears it to many Haskellers
21:44:40 <lispy> confuzed: Yes, I think it's a great systems languages.
21:45:07 <lispy> confuzed: it's not perfect, but it's also pretty new
21:48:36 <codebje> is there a simple way to batch a list up into sublists of <n> elements?
21:48:58 <glguy> > chunksOf 4 "There's a function in Data.List.Split"
21:49:00 <lambdabot>  ["Ther","e's ","a fu","ncti","on i","n Da","ta.L","ist.","Spli","t"]
21:49:36 <codebje> perfect :-)
22:04:04 * hackagebot parseargs 0.2.0.7 - Full-featured command-line argument parsing library.  https://hackage.haskell.org/package/parseargs-0.2.0.7 (BartonMassey)
22:54:45 <Squarism> in what release of haskell will the new record syntax appear? where field accessors were local to the constructor so to speak
23:03:22 <jle`> Squarism: new feature s are being phased in in stages, so what aspect are you talking about, exactly?
23:04:46 <ggVGc> when was the last time haskell got a new non-extension feature?
23:05:08 <mauke> when the last report came out, so 2010?
23:05:19 <Squarism> jle`, i heard you would be able to do : data A = A { id:: Int }, data B = B { id :: int }
23:05:44 <Squarism> where "id" would conflict as is now
23:06:26 <confuzed> Will haskell ever loose all the language extensions and fold them in? They are super annoying. The infinite varieties of haskell have made learning so hard
23:07:48 <glguy> Squarism: That's already in GHC 8 with DuplicateRecordFields
23:07:57 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields
23:09:05 <Squarism> ah ok
23:14:29 <Squarism> hmm.. im on GHC 7.10.. should one go up to 8?
23:45:18 <bollu> how does this work / what does this do: type family Element mono
23:45:23 <bollu> I've heard of "type families"
23:45:40 <bollu> but I'm not sure where they fit into the whole types/kind/typeclass thing that we have in Haskell
23:45:47 <bollu> could someone please explain them to me?
23:49:26 <Cale> It defines a type level function called Element, which for any type mono, you can specify which type  Element mono  ought to be using  type instance
23:49:43 <Cale> For example, perhaps you would want  type instance Element [a] = a
23:49:59 <Cale> and perhaps  type instance Element ByteString = Word8
23:50:16 <Cale> bollu: ^
23:50:59 <bollu> Cale: so a type level function is a f: Type -> Type?
23:51:07 <Cale> Yeah, that's the idea
23:53:31 <bollu> Cale: does it make sense to ask about it's kind?
23:53:36 <bollu> its*
23:53:43 <Cale> yes
23:53:52 <Cale> In this case, Element :: * -> *
23:53:57 <bollu> soo, it takes a type and returns a type, so it's kind is * -> *?
23:54:00 <bollu> neat
23:54:21 <bollu> hmm, so a "kind-level-type" is a "type-level-function"?
23:55:24 <bollu> Cale: so mathematically, a type family is is a function from type to type?
23:55:42 <bollu> Cale: or a set of types indexed by types?
23:56:36 <quchen> Isn't a function from a to b the same as a set of b indexed by a?
23:56:58 <bollu> quchen: yes, but it's a slightly different way of casting it in your head right?
23:57:26 <bollu> quchen: like, a function "transforms". Indexing is more of "I have this, what corresponds to this there"? at least for me, the connotation is different
