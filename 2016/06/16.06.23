00:07:39 * hackagebot string-conv 0.1.2 - Standardized conversion between string types  https://hackage.haskell.org/package/string-conv-0.1.2 (MichaelXavier)
00:07:39 * hackagebot persistent-iproute 0.2.2 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.2 (sickmind)
00:42:34 * hackagebot HPhone 0.0.1.1 - Phone number parser and validator  https://hackage.haskell.org/package/HPhone-0.0.1.1 (raghuugare)
01:32:35 * hackagebot located-monad-logger 0.1.0.0 - Location-aware logging without Template Haskell  https://hackage.haskell.org/package/located-monad-logger-0.1.0.0 (pavelkogan)
01:35:53 <tero-> is compiling Haskell inherently CPU-intensive or could (ghc-)compiling performance be still significantly improved?
01:37:03 <zomg> I can say it takes forever on CPU-limited systems, don't know how much there's room to optimize further :)
01:37:21 <zomg> Well, it *can take* forever, obviously depends on what you're compiling
01:37:45 <tero-> TH seems to be one of the silver bullets to maximize compiling times
01:38:42 <zomg> I should do a test. Compile something large on my i7 920, and then re-test when I get the 6900K I ordered :P
01:39:17 <zomg> (4 cores vs 8 cores)
01:39:18 <merijn> tero-: Compilation is generally very computationally intensive, not just Haskell
01:39:32 <merijn> tero-: C++ compilation for example also takes ages
01:39:33 <quchen> tero-: TH is evaluated as fast as GHCi, so if you're doing anything laborious it's a terrible choice
01:40:15 <merijn> tero-: Especially when compiling with -O2 GHC will do lots of inlining and specialisation, leading to blowups in the AST and making compilation costly
01:40:40 <merijn> tero-: I'm sure there's room for improvement in GHC's compilation speeds, but compilation resulting in optimised and fast code will generally stay expensive
01:41:05 <merijn> tero-: Although I should point out there's known cornercases (such as ADT with huge amounts of constructors) currently leading to exponential blowup in compilation time
01:41:18 <merijn> (huge being > 20-30)
01:41:24 <merijn> Especially when deriving instances for those
01:41:33 <quchen> Really, exponential!?
01:41:56 <merijn> quchen: It's really bad
01:42:00 <quchen> The GHC AST is pretty huge, but I guess it's not compiled with -O2
01:42:08 <merijn> quchen: Not sure if it's actually exponential
01:42:20 <merijn> quchen: But there's this pandoc dependency which is basically one file of 300 or so lines
01:42:29 <merijn> Takes like 40 minutes to compile last time I built it
01:42:37 <quchen> τ(n), the complexity class of things that scale terribly with n
01:42:43 <tero-> merijn: I guess C++ templates are to blame for slow compilation there
01:43:17 <merijn> tero-: Yes, templates have similar effects to inlining, but also just consider things like optimisation, lots of stuff going on out of sight
01:43:18 <quchen> merijn: I noticed that my modules with only types are often the slower ones to compile
01:43:37 <quchen> Never figured out why though
01:44:28 <merijn> quchen: There's a few tickets and some mailing list threads on compile time regressions
01:44:32 <merijn> So it's being looked at
01:44:48 <ggVGc> I'd like the Lens generation logic of the Lens package as a standalone tool, so it could be run on a file, and then not have TH in that file
01:44:52 <quchen> merijn: I'm aware of those, but I think types have always been strangely slow to compile
01:44:54 <ggVGc> actually, can you preprocess with TH like that?
01:44:56 <ggVGc> I guess not
01:45:02 <ggVGc> since it's not a text transformation
01:45:27 <tero-> can I tell stack to build a binary as fast as possible without changing .cabal?
01:45:27 <geekosaur> it used to be possible (zeroth package) but that package is now rather bitrotted
01:45:31 <quchen> ggVGc: TH does not guarantee that prettyprinted output is valid I think, so you can't really do that
01:45:41 <ggVGc> is there a "lens generation tool"?
01:45:45 <ggVGc> I might write one
01:45:58 <quchen> tero-: --fast
01:46:02 <ggVGc> I use lenses a lot now, and I think the lens TH is really slowing down my compilations
01:46:03 <tero-> quchen: thank you
01:46:10 <merijn> tero-: For what purpose? Just checking for errors?
01:46:23 <tero-> merijn: to deploy in staging environment for testing
01:46:26 <merijn> Because there's a couple of secret "make compilation superfast if you only want type errors" tricks
01:46:44 <ggVGc> what are those tricks?
01:46:48 <quchen> ggVGc: I always put my lens TH in their own modules that do nothing but lens TH. Those rarely change or need recompilation.
01:46:52 <ggVGc> does ghc-mod use them?
01:47:40 <tero-> zomg: that 6900K is a pricey thing
01:47:42 <merijn> ggVGc: "-O0 -fno-code"
01:47:59 <merijn> ggVGc: I dunno about ghc-mod, but with hdevtools you can specify additional GHC flags and that "Just Works"
01:48:12 <merijn> ggVGc: Basically, no optimisation and don't even bother generating code
01:48:22 <merijn> Both of which are expensive. Just typechecking is pretty cheap
01:48:51 <ggVGc> hm
01:49:03 <ggVGc> I'm pretty sure ghcmod doesnt do that
01:49:05 <ggVGc> becauase it's super slow
01:49:08 <ggVGc> at least for me
01:49:24 <merijn> ggVGc: If ghc-mod use cabal config you can just put those in GHC-options while developing
01:52:34 <zomg> tero-: haha yeah I may have splurged a bit :P
01:53:22 <Velizar> https://gist.github.com/VelizarHristov/833e6e81449a068a236702e77bbd5351 On lines 5 and 6, there is repetition between the left-hand and right-hand sides - `e2` and `r` on line 5; `e2` and `l` on line 6. Is there a way to refactor that? Do I need lenses?
01:55:02 <merijn> Velizar: Could use pattern guards
01:55:52 <lpaste> merijn pasted “pattern guard” at http://lpaste.net/167708
01:56:39 <merijn> But in general anything more than that is probably not even worth it
01:56:40 <tero-> stack build vs stack build --fast : 46.6s -> 19.9s
01:56:49 <merijn> Actually, the pattern guard is probably not even worth it
01:57:12 <Velizar> nice! but yeah I'd rather use lenses
01:57:39 <merijn> lenses seems a bit overkill, imo
01:58:12 <Velizar> it's just an exercise anyway
02:00:41 <lpaste> quchen annotated “pattern guard” with “case instead of pattern guard” at http://lpaste.net/167708#a167709
02:01:50 --- mode: ChanServ set +o Cale
02:01:51 --- topic: set to 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Offtopic discussion: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.h' by Cale
02:01:57 --- mode: Cale set -o Cale
02:02:23 <quchen> Cale: That looks like the end was chopped off
02:02:24 <geekosaur> topic now truncated
02:02:29 <Cale> ah, dang
02:02:31 --- mode: ChanServ set +o Cale
02:03:15 <quchen> (Maybe the channel should also state the topic of the channel, which is "the Haskell programming language". It's more a collection of links right now.)
02:04:00 <barrucadu> How come the offtopic channel in the topic is #haskell-offtopic, rather than #haskell-blah?
02:04:36 <quchen> It was never clear what #blah was about.
02:04:44 <geekosaur> #haskell-blah is actually operated by someone else, and a couple months ago they decided to set it so only users connected via SSL could /join
02:05:10 <Cale> Well, #haskell-blah was an unofficial offtopic channel for a long time. A while back, an op there decided to set a channel flag that disallowed clients without TLS from joining, so I started an official offtopic channel with the same moderators as #haskell.
02:05:12 <geekosaur> well, TLS
02:05:22 <quchen> And #blah regularly complained that it was not the dumpster of #haskell.
02:11:05 --- topic: set to 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org' by Cale
02:11:27 --- mode: Cale set -o Cale
02:36:44 <Velizar> What is the name of this property? set `insert` a `insert` b = set `insert` b `insert` a; reminds me of commutativity, but it's not the same
02:37:58 <merijn> Velizar: I don't think there's a name for it, since commutativity implies (usually?) that both sides are the same type
02:38:21 <merijn> Velizar: If asked to describe it, I would probably say "insertion is order invariant" (i.e. doesn't matter which order they occur in)
02:38:23 <Velizar> merijn: yeah, commutativity is just f(a, b) = f(b, a)
02:38:45 <Velizar> the case is more like f(a, b, c) = f(a, c, b)
02:39:10 <Velizar> where the types of b and c are the same, but the types of a and b are possibly different
02:39:54 <Cale> It is commutativity of the functions (`insert` b) and (`insert` a)
02:41:08 <Velizar> applyToSet(`insert` b, `insert` a) = applyToSet(`insert` a, `insert` b). yeah that works
02:54:43 <Cale> Or just  (`insert` b) . (`insert` a) = (`insert` a) . (`insert` b)
02:57:38 * hackagebot HPhone 0.0.1.2 - Phone number parser and validator - This is now DEPRECATED!  https://hackage.haskell.org/package/HPhone-0.0.1.2 (vijayanant)
02:57:40 * hackagebot phone-metadata 0.0.1.5 - Phonenumber Metadata - NOTE: this is now deprecated!  https://hackage.haskell.org/package/phone-metadata-0.0.1.5 (raghuugare)
03:01:45 <enthropy> when testing a package with multiple ghcs, does cabal-install have the brains to keep different .hi .o files separated by ghc version?
03:02:22 <hvr> enthropy: with new-build, yes
03:02:29 * enthropy guesses it isn't much trouble to make dist/ a symlink to dist-784; dist-801 etc.
03:06:56 <enthropy> hvr: I'm interested in testing with ghc-7.8.4. The cabal install that introduced "new-build" may not work with that ghc?
03:07:25 <merijn> enthropy: My experience so far is that cabal works perfectly well with older ghcs
03:13:29 <enthropy> seems like I had some nonsense PATH manipulation to match up cabal-install and ghc versions when I only need to do the latter
03:14:04 <enthropy> merijn: looks like it. Thanks!
03:17:39 * hackagebot data-named 0.6.1 - Data types for named entities  https://hackage.haskell.org/package/data-named-0.6.1 (JakubWaszczuk)
03:25:20 <tomjaguarpaw> Does ekg use standard profiling hooks?  i.e. you have to compile with profiling enabled?
03:32:39 * hackagebot persistent-redis 2.5.2 - Backend for persistent library using Redis.  https://hackage.haskell.org/package/persistent-redis-2.5.2 (PavelRyzhov)
03:47:40 * hackagebot creatur 5.9.13 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.13 (AmyDeBuitleir)
03:49:16 <Prutheus> I have written a numbergenerator script, which is giving me the numbes as output. I wanna pipe them to another application, but for some reason I get an error then: let me show you my script: http://ix.io/W6D
03:49:57 <Prutheus> »runhaskell Generator.hs 5 | echo« is giving me this error then: `<stdout>: hPutChar: resource vanished (Broken pipe)`
03:50:05 <Prutheus> why? how to solve? ^^
03:55:29 <jm_c_> Prutheus: pipe it through cat
03:55:31 <jm_c_> instead of echo
03:56:32 <Prutheus> hm, but when i wanna pipe it to an other program, then i still have this error o.O
03:56:45 <Prutheus> jm_c_: any idea for that?
03:56:46 <quxbam> Does anyone know what happened to reduceron?
03:57:39 <sigrlami> about a year ago was survey on Haskell in real-world and report published on Reddit with list of applied areas most interested for users. Can't find link, is it available somewhere?
03:58:26 <jm_c_> Prutheus: what happens if you don't pipe it?
03:59:11 <jm_c_> Prutheus: you might want to give 2 as argument, instead of 5
03:59:45 <Prutheus> jm_c_: when i don't pipe, it is doing well and print the numbers. why 2 as arg??
04:00:37 <jm_c_> I thought the list would get very long otherwise
04:01:10 <pyrtsa> sigrlami: Is it this report series you're looking for? https://wiki.haskell.org/Haskell_Communities_and_Activities_Report
04:01:27 <Prutheus> jm_c_: yeah, but it should work with such long lists
04:01:35 <jm_c_> Prutheus: also, let the list run from 10^(length-1)
04:01:45 <jm_c_> Prutheus: that saves you the fractionals and the rounding
04:02:40 * hackagebot creatur 5.9.14 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.14 (AmyDeBuitleir)
04:02:47 <jm_c_> Prutheus: which means you can just print $ numbergenerator (blabla)
04:02:54 <sigrlami> pyratsa: no, it was made by FPComplete people and related not to currently available products, but more about "I want this cool <library> in Haskell for <Application area>"
04:02:58 <jm_c_> instead of putting another list comprehension in there
04:03:01 <Prutheus> okay. anyway, i solved my problem now. i just write the output of my generator into a file and cat this file :D
04:03:06 <Prutheus> ty, cu
04:03:21 <sigrlami> i think it have some strange title, so I can't google it
04:03:43 <jm_c_> Prutheus: bleh
04:03:50 <Prutheus> bleh?
04:03:52 <jm_c_> Prutheus: then just stop using haskell at all
04:03:59 <Prutheus> what? why?
04:04:09 <jm_c_> Prutheus: you know the unix command seq?
04:04:35 <Prutheus> lol xD 
04:04:49 <jm_c_> I thought you wanted to do an exercise
04:05:40 <jm_c_> If you actually *need* a number generator, then you should just use seq
04:12:48 <maerwald> does any notable company use cloud haskell?
04:28:13 <Velizar> I'm implementing a tree which implements both Monoid and Foldable. However, (toList tree1) ++ (toList tree2) != toList (tree1 `mappend` tree2). Does this violate some law or otherwise lead to unexpected results? (this happens because mappend inserts the new elements in-order to keep it balanced, but fold does f (fold l) (fold r) to keep it parallelizable; toList comes from Foldable)
04:29:23 <psmmr> 'return 5' in ghci returns 5, though return should be of type (Monad m) a -> m a
04:29:38 <psmmr> I do not understand how can the result 5 be a Monad
04:30:20 <Velizar> [5] is return 5, for List's version of return
04:30:58 <psmmr> Velizar: I have not specified the return type, and the return value was not a list
04:31:07 <psmmr> just go and type "return 5" on ghci
04:31:11 <psmmr> the answer is 5
04:31:28 <puregreen> it might get defaulted to IO
04:31:40 <Velizar> I'm assuming that's Haskell's way of telling that it's an unknown monad
04:32:15 <Velizar> the thing it prints does seem weird, but the type is ok
04:32:19 <Velizar> :t return 5
04:32:20 <lambdabot> (Monad m, Num a) => m a
04:32:28 <puregreen> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/interactive-evaluation.html#actions-at-prompt
04:32:41 * hackagebot hscolour 1.24.1 - Colourise Haskell code.  https://hackage.haskell.org/package/hscolour-1.24.1 (MalcolmWallace)
04:32:45 <puregreen> “This works even if the type of the expression is more general, provided it can be instantiated to IO a”
04:33:12 <bernalex> maerwald: I suggest asking someone from well-typed. they've worked on it, probably for clients.
04:33:23 <psmmr> thank you puregreen!
04:33:27 <psmmr> :-)
04:33:36 <psmmr> damn ghci....
04:33:38 <psmmr> :-)
04:34:24 <psmmr> return 5 :: IO Integer
04:34:24 <psmmr> 5
04:34:39 <psmmr> :-)
04:37:23 <mettekou> Given newtype Fix f = Fx (f (Fix f)) and data ExprF a = Add a a | ... | Const Int as per: https://www.schoolofhaskell.com/user/bartosz/understanding-algebras, I don't see how applying the Fx :: f (Fix f) -> Fix f data constructor to (Const 12) :: ExprF a does not yield a type error. Could anyone please clarify this behaviour?
04:38:30 <mniip> Const 12 :: ExprF a
04:38:39 <mniip> Fx :: f (Fix f) -> Fix f
04:38:52 <mniip> f (Fix f) ~ ExprF a
04:38:56 <mniip> f ~ Exprf
04:38:59 <mniip> a ~ Fix f
04:39:24 <mniip> Fx :: Exprf (Fix ExprF) -> Fix ExprF
04:44:00 <mettekou> mniip: I don't see how f (Fix f) ~ ExprF a is true.
04:45:03 <mniip> it isn't
04:45:34 <mettekou> mniip: It isn't, but that's the point of the typing rule for type-level recursion is what you're saying?
04:45:45 <mniip> typechecking isn't about "true" or "false", it's about substituting type variables and flailing out in case of a failure
04:46:07 <mniip> mettekou, are you familiar with flip id?
04:46:30 <mettekou> Oh, I see, that's the same behaviour.
04:47:07 <mniip> all typechecking in haskell can be described with one behavior (unless rankntypes is used)
04:47:26 <mettekou> Well I have studied and implemented a toy version of System F⍵ (Pierce, 2002), but never with recursive types, which is where my confusion stems from I think.
04:47:26 <mniip> the behavior is called Hindley-Milner type system
04:47:55 <mettekou> Then again, Pierce's type systems assume fully annotated terms.
04:48:10 <mettekou> Which is why you never need to guess a type.
04:48:23 <mniip> mettekou, in order for (f :: a -> b) (x :: c) to typecheck we have to unify a and c
04:48:53 <mniip> that not only proves that a and c are "compatible" types but also finds substitutions that brings the two to the same type
04:49:21 <mniip> so
04:49:22 <mettekou> Yeah, which is the step you never need when you have type annotations everywhere.
04:49:31 <mniip> actually you do
04:49:41 <mettekou> Where exactly?
04:50:13 <mettekou> Well to check the type I guess, but then you already have the programmer's guess to go with.
04:50:23 <mniip> (head :: forall a. [a] -> a) (pure () :: forall f. f ())
04:50:33 <mniip> have to unify [a] with f ()
04:50:57 <mettekou> Ah yes, I see.
04:51:52 <mniip> this is the same situation
04:52:19 <mniip> (Fx :: forall f. f (Fix f) -> Fix f) (Const 12 :: forall a. ExprF a)
04:52:32 <mniip> you have to unify f (Fix f) with ExprF a
04:52:33 <mettekou> The reason why I didn't come across the last case in toy System F⍵ is that all type parameters need to be passed explicitly in the terms.
04:52:56 <mettekou> Whereas in Haskell they aren't anywhere to be found in terms, only in type signatures.
04:52:57 <mniip> both expressions are tycon applications, so you have to unify cons with cons and args with args
04:53:05 <mniip> i.e f with ExprF and Fix f with a
04:54:15 <mniip> the unification succeeds and yields substitutions: f ~ ExprF, a ~ Fix f ~ Fix ExprF
04:57:12 <mettekou> Yeah, I understand now. Thanks!
05:14:18 <Lisa1157> Hi, I am starting off trying to understand Type Indicies in Haskell, I am having some trouble understanding what the (b::Bool) is doing in this code https://dpaste.de/OcYK 
05:14:27 <rcat> I'm using the `linear' lib from kmett, and I have dynamic-sized matrices that at run-time I know the precise size they will have
05:15:13 <rcat> can I promote from a value to the types the size of the matrix?
05:15:23 <edwardk> rcat: yes
05:15:26 <rcat> I have my internal code with signatures like this: buildScoreProbMatrix :: Dim m => V n (V m Double)
05:15:50 <edwardk> Linear.V.reifyDim
05:16:10 <edwardk> will let you take an Int and build a type that acts as a Dim for it
05:16:20 <edwardk> reifyDim :: Int -> (forall n. Dim n => Proxy n -> r) -> r
05:16:51 <edwardk> there's also things like: reifyVectorNat :: forall a r. Vector a -> (forall n. KnownNat n => V n a -> r) -> r
05:16:57 <rcat> looking at it right now, thanks Edward!
05:19:43 <balor> byorgey, Fancy seeing you here :)  I'm a.k.a. Aidan Delaney
05:22:43 * hackagebot propellor 3.1.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.1.1 (JoeyHess)
05:53:35 <hc> int-e: say, instead of converting (STUArray s Int Word8) into a ShortByteString, is there an easy way to write its contents to disk directly using System.IO.hPutBuf?
05:54:30 <wildProgrammer> Hi, guys! How do i make my module visible for atom editor?
05:56:43 <merijn> hc: If you wanna write stuff to disk directly you might wanna have a look at using mmap and using Ptr CChar or something
05:57:37 <merijn> hc: How fast do you need to be? Have you already confirmed it's too slow?
05:57:38 <hc> merijn: I would like to separate the part that computes the bytes from the one that writes them to disk, though
05:57:44 * hackagebot semigroups 0.18.2 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.18.2 (ryanglscott)
05:57:49 <hc> merijn: C implementation needs 0.65s where my implementation needs 15s
05:58:01 <hc> I'm looking for ways to further optimize it ;)
05:58:25 <wildProgrammer> \q
05:58:39 <merijn> hc:  Do you have code? Did you profile it?
05:58:55 <merijn> If not, why are you optimising without knowing what you need to optimise?
05:59:01 <hc> merijn: yeah, code is here: https://github.com/VirtualForgeGmbH/hascar/blob/master/src/Codec/Archive/SAPCAR/FlatedFile.hs
05:59:09 <hc> and yes, i have profiled it already
05:59:22 <hc> and I know that for each block a memcpy happens which is unnecessary
05:59:23 <merijn> "{-# LANGUAGE ImpredicativeTypes #-}" <- ouch :(
05:59:40 <hc> merijn: improvement suggestions are always welcoem
05:59:43 <int-e> hc: You can in principle get the address of a bytearray and put that into a Ptr... but this is only safe if the bytearray is pinned, and is touched again after writing it out. I don't know how to test for pinned bytearrays though. Are you sure that this is a bottleneck?
06:00:15 <merijn> hc: ImpredicativeTypes is a recipe for misery, I would avoid using it
06:00:19 <int-e> :t GHC.Exts.byteArrayContents#
06:00:20 <lambdabot> GHC.Prim.ByteArray# -> GHC.Prim.Addr#
06:00:41 <int-e> :t Foreign.Ptr.Ptr
06:00:43 <lambdabot> Not in scope: data constructor ‘Foreign.Ptr.Ptr’
06:00:48 <hc> merijn: code works fine so far, anything specific I should avoid in that code?
06:00:55 <int-e> :t GHC.Exts.Ptr
06:00:56 <lambdabot> GHC.Prim.Addr# -> GHC.Ptr.Ptr a
06:01:38 <hc> merijn: here's the original btw ;-) https://github.com/CoreSecurity/pysap/blob/master/pysapcompress/vpa108csulzh.cpp
06:01:56 <merijn> hc: The problem with ImpredicativeTypes is that no one (and I mean literally no one) knows how it SHOULD work, so it's hard to determine whether the behaviour of code using it is buggy
06:02:15 <merijn> And it has broken across GHC versions in the past, iirc
06:02:28 <hc> merijn: as long as it doesn't do IO. the only reason I've reimplemented this code in haskell is to prevent buffer overflow attacks etc when decompressing untrusted data
06:02:54 <hc> because look at the cpp file -- it's pretty much obfuscated in the source code -- have fun auditing that ;]
06:02:57 <int-e> hc: cf. https://ghc.haskell.org/trac/ghc/ticket/12059
06:03:24 <hc> int-e: thanks!
06:04:23 <hc> Also I wonder just out of curiosity if it is possible to achieve near-C performance with that
06:06:32 <numee> Hi, I have a question about GADTs. Suppose that I have defined a GADT as: data Foo where Foo :: a -> b -> Foo
06:06:33 <numee> Is it possible to define a function extract :: Foo -> (a, b) ?
06:06:55 <hc> merijn: ah wait... I don't even need ImpredicaveTypes anymore... you can just remove it, it still compiles fine
06:09:21 <coppro> numee: yes. extract (Foo a b) = (a, b)
06:09:33 <coppro> you don't need GADTs for that though
06:09:38 <coppro> you could just write data Foo = Foo a b
06:10:14 <merijn> coppro: "data Foo = Foo a b" is wrong
06:10:30 <merijn> So you can't actually write that :)
06:10:35 <coppro> I assume you have concrete values for a and b here
06:10:50 <coppro> if you don't, then you can write that constructor, but you won't be able to write extract
06:14:11 <numee> coppro: If that were the case, why/how would the operational monad work in which values are extracted whose types do not appear in the monad's type
06:14:24 <numee> ?
06:15:03 <hc> merijn: ah wait... I don't even need ImpredicaveTypes anymore... you can just remove it, it still compiles fine (I said that already, but I think you didn't receive that because of your connection's timeout)
06:15:39 <merijn> hc: I expected you didn't :)
06:15:50 <hc> I was trying to embed ST inside StateT but gave that up quickly
06:16:02 <hc> I think that line was part of the attempt
06:16:25 <merijn> yeah, train wifi with 50% packet loss and latency ranging from 30 to 10k milliseconds >.>
06:16:30 <coppro> numee: because the operational monad works by extracting values by pattern matching
06:16:43 <idev> https://fsharpforfunandprofit.com/posts/recipe-part2/
06:16:47 <idev> is that just the Either monad ?
06:16:57 <hc> (and we're still using TCP instead of something mobile friendly)
06:17:00 <coppro> extract :: Foo -> forall a b. (a, b) can't be defined because the type shouldn't be universally quantified. The quantification would have to be existential:
06:17:12 <coppro> extract :: Foo -> exists a b. (a, b)
06:17:39 <hc> merijn: https://www.isoc.org/briefings/017/ would help i think
06:17:41 <coppro> Haskell does not directly support such types, however, so you have to work around that in other ways
06:19:05 <coppro> :t let data Foo where Foo :: a -> b -> Foo in case (Foo 1 "c") of (Foo a b) -> (a, b)
06:19:06 <lambdabot>     parse error in let binding: missing required 'in'
06:19:16 <coppro> :t let data Foo where { Foo :: a -> b -> Foo } in case (Foo 1 "c") of (Foo a b) -> (a, b)
06:19:17 <lambdabot>     parse error in let binding: missing required 'in'
06:19:23 <coppro> :t let { data Foo where { Foo :: a -> b -> Foo }} in case (Foo 1 "c") of (Foo a b) -> (a, b)
06:19:24 <lambdabot> parse error on input ‘data’
06:19:31 <coppro> oh right, can't define a type there
06:19:38 <coppro> :data Foo where {Foo :: a -> b -> Foo}
06:20:41 <coppro> numee: in any case, you'll see that that example I posted gives an error
06:23:55 <numee> coppro: I cannot comprehend why it should be an error. shouldn't the type be (Int, String)?
06:24:26 <merijn> numee: How do you know what was put in?
06:25:00 <coppro> the problem is that the expression (a, b) has a type that's quantified
06:25:08 <coppro> but the quantification only happens in the pattern binding
06:25:11 <chelfi> 1234
06:25:16 <chelfi> oups sorry
06:25:23 <coppro> to type that, GHC need to unify the type variables with Int and String
06:25:41 <coppro> but it needs to let the type variables escape out of their context
06:26:00 <coppro> if the case were split out into a function, you'd have dependent types
06:26:19 <coppro> in order for GHC to know the type of "extract", it would need to know what values were in the Foo
06:26:35 <coppro> that's a runtime decision, though.
06:27:19 <Lisa1157> Hi, I am starting off trying to understand Type Indicies in Haskell, I am having some trouble understanding what the (b::Bool) is doing in this code https://dpaste.de/OcYK
06:28:08 <Ashy> hmm, how do i re-export a module properly?
06:29:45 <numee> coppro: It seems like I don't know what is needed in order to understand what's going on here. Thanks for the gentle explanation anyway.
06:29:56 <merijn> Ashy: Add "module Foo" to your export list
06:30:06 <Ashy> or rather, why am i getting linking errors after moving some stuff into  a separate module and then re-exporting it?
06:30:15 <merijn> Assuming you want to re-export all things imported from module Foo
06:30:28 <puregreen> Ashy: maybe you haven't added it to your .cabal file
06:30:31 <puregreen> (if you have it)
06:30:34 <Ashy> OH, yeap
06:30:36 <Ashy> cheers
06:45:47 <brownjm> Hi, I have a question about cabal files and packaging best practices.
06:47:46 * hackagebot debian-build 0.10.0.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.10.0.0 (KeiHibino)
06:48:01 <brownjm> I am writing an executable for the commandline. When I look around at many other people's cabal files, I see that they always separate the parts into a library.
06:48:31 <brownjm> I don't really want to open up every functions in my program, but it looks convenient for testing. Any ideas what is considered best practice?
06:49:20 <tero-> Lisa1157: to me it seems it's used as a phantom type to distinguish the types of SFalse and STrue.  
06:52:19 <Rryy> brownjm: I do not know about general best practices, but thinking of examples: pandoc and xmonad export their internal libraries
06:52:29 <Rryy> (in the case of pandoc, it is an use case)
06:52:44 <Rryy> (I do not know whether that is true for xmonad)
06:53:55 <brownjm> Thanks Rryy. It just seems like overkill to export every module and function. But I do want to get others to contribute, so I want haddock to document everything. I'll check out the two libraries you mention!
06:54:05 <sm> brownjm: why not start simple, don't add a lib until you feel the need
06:55:00 <hexagoxel> brownjm: the main aspect is avoiding recompilation. if you build exe+tests from the same _source_ the source will be compiled twice. if you put most things in a lib, exe+tests can depend on that and you only need one compilation of lib. but lib needs to expose everything to be tested.
06:55:05 <Rryy> brownjm: you could choose to export only the most important functions (you can provide an option to cabal for it to hide some modules)
06:55:37 <Velizar> if I have `type A = [Int]`, but then I decided that A should be any Foldable of Int, not just list, how can I do that?
06:55:40 <sm> ah, what hexagoxel said
06:55:48 <brownjm> hexagonel: oh, I didn't think of this. Good point!
06:55:55 <Lisa1157> tero-: what is the significance of defining "::Bool" with it?
06:56:01 <sm> except, you can test without exporting using doctest, right
06:56:38 <balor> byorgey, We've finally released the programme for Diagrams 2016 http://www.diagrams-conference.org/2016/program
06:56:59 <tero-> Lisa1157: it seems that GADT must have free type parameters in the type, so you cannot write data SBool Bool. then again it works also with just SBool b because it can infer 'b' from the constructors 
07:07:00 <coppro> numee: what do you want Foo to do? To "hide" values of an arbitrary type?
07:07:46 * hackagebot clckwrks-theme-bootstrap 0.4.2 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.4.2 (JeremyShaw)
07:08:47 <tero-> Velizar: (Foldable a, HasInts a) => ... where you define instances for HasInts  ?
07:10:49 <Velizar> tero-: I think I decided to make it `type A f = f Int`
07:12:46 * hackagebot elm-hybrid 0.1.2.0 - Combine Elm with Haskell for data based applications  https://hackage.haskell.org/package/elm-hybrid-0.1.2.0 (matsrietdijk)
07:12:48 * hackagebot ip 0.6.2 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.6.2 (andrewthad)
07:13:51 <tero-> Velizar: ah that's neat
07:17:47 * hackagebot elm-hybrid 0.1.2.1 - Combine Elm with Haskell for data based applications  https://hackage.haskell.org/package/elm-hybrid-0.1.2.1 (matsrietdijk)
07:19:20 <tobiasBora> Hello,
07:20:10 <tobiasBora> I have an error with an exception and I would like to know if it is possible to have the chain of function call that leads to that exception. Is it possible ?
07:20:28 <tdammers> not with ghc 7, I believe
07:20:45 <tdammers> IIRC ghc 8 adds stack traces, but they are still of limited use
07:23:25 <tobiasBora> How could I install ghc 8 ? (I'm running debian testing)
07:24:49 <tdammers> https://www.haskell.org/ghc/
07:25:04 <Clint> tobiasBora: you can add experimental to your sources.list and grab it out of there
07:26:24 <tero-> stack's also good for installing ghc
07:27:03 <tdammers> ^ ++
07:27:11 <coppro> ^ ++
07:28:08 <tobiasBora> Clint: What do you mean by expérimental ?
07:28:24 <tobiasBora> tero-: I tried stack install ghc-8.0.1, but it doesn't work...
07:28:34 <tero-> tobiasBora: what does it say?
07:28:59 <coppro> well that won't work
07:29:05 <coppro> stack's interface is not at all like cabal's
07:29:32 <tero-> ah *that* command, oh I see
07:29:33 <Clint> tobiasBora: if you add "deb http://httpredir.debian.org/debian/ experimental main" to /etc/apt/sources.list or a file in /etc/apt/sources.list.d
07:30:09 <tobiasBora> Clint: Experimental is like above unstable ?
07:31:21 <tobiasBora> coppro: So how would I do do that ? I never understand how stack works...
07:32:10 <Clint> tobiasBora: yes, but more restricted
07:32:21 <tobiasBora> Clint: Hum I see.
07:33:09 <tero-> tobiasBora: stack.yaml with resolver: nightly-2016-06-21 and then stack setup
07:33:42 <tero-> tobiasBora: or even stack setup 8.0.1 
07:34:13 <tobiasBora> tero-: I cannot play with two global install of stack ? (because it will remove all packages already installed right ?)
07:34:56 <tero-> tobiasBora: you can have multiple ghc versions installed with stack
07:35:06 <tero-> tobiasBora: but it won't make a system-level installation for you
07:35:59 <tero-> tobiasBora: you can find the different ghc versions in ~/.stack/programs/ARCH/ghc-X.Y.Z/bin
07:36:46 <tero-> tobiasBora: but it's worth spending a few minutes how to build your projects with stack
07:36:51 <dominik> is there any way to speed up reading in a long input file in Haskell?
07:37:14 <c_wraith> dominik: don't use String
07:37:15 <dominik> Concretely, I profiled my program with -prof -fprof-auto and it says that 95% is spent in the function that reads in the input file
07:37:23 <numee> coppro: I'm trying to create a monad whose value might contain a value of ST s a without making `s` appear on the monad's type. I thought I can do this given the fact that the operational monad works
07:37:41 <c_wraith> dominik: Oh.  Well, that's likely to be inaccurate due to laziness.
07:38:23 <dominik> hmmm, ok
07:38:40 <c_wraith> numee: You can do it, but..  You will have trouble using the type.  ST is only safe because you can't do that (and later use runST on the value)
07:38:40 <dominik> what should I use instead of String? Text?
07:38:52 <c_wraith> dominik: yes, Text is a good choice.
07:39:03 <coppro> numee: ahh, yes.
07:39:12 <coppro> ST is weird
07:39:27 <c_wraith> ST isn't weird.  It's just IO with a different interface. :)
07:39:34 <c_wraith> Wait, IO is weird too.  Carry on. :)
07:40:00 <coppro> ST uses a type-level hack to ensure that you can't run things from one ST instance in another
07:40:32 <coppro> you could try to hide that parameter, but then you wouldn't be able to execute it at all
07:40:51 <c_wraith> It's not a hack in the negative sense.  I've used the same technique myself, for region-like things.
07:40:58 <XinhNguyen> hello
07:41:06 <dominik> c_wraith: Ok, thanks. But can I also read a file directly into a Text value?
07:41:19 <dominik> similarly to readFile?
07:41:48 <Clint> dominik: http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-IO.html
07:41:55 <c_wraith> dominik: yeah, see Data.Text.IO
07:42:04 <dominik> ah, ok. Thanks
07:42:08 <coppro> numee: operational works quite differently
07:42:34 <Velizar> why can't this compile? let a = [1] in case [q] of a -> q
07:42:37 <XinhNguyen> hello
07:43:00 <c_wraith> Velizar: I think you have the expression and pattern backwards in your case
07:43:06 <c_wraith> case a of [q]
07:43:14 <coppro> numee: perhaps just something lie type ST' = forall s. ST s ?
07:43:18 <coppro> (with RankNTypes enabled)
07:43:20 <Velizar> ah. right
07:43:27 <coppro> *like
07:43:33 <c_wraith> {-# LANGUAGE GADTs #-} data EscapedRef a where Escape :: STRef s a -> EscapedRef a
07:44:26 <c_wraith> You can smuggle an STRef out of ST with a type like that.  But then you can never use it. :)
07:47:00 <numee> coppro, c_wraith: I tried something like that, inserting the forall quantifier quite randomly
07:47:10 <numee> anyway, here is the actual code: http://pastebin.com/yTtEpR2p
07:48:08 <coppro> numee: what's the error you get?
07:48:13 <c_wraith> numee: ultimately, you can't use runST on an ST computation that isn't self-contained.  The type system prevents it.  That's how it's safe to use mutable references in a larger pure context.
07:49:26 <numee> I thought it would be useful to be able to break from loops when dealing with STUArray for efficiency
07:50:04 <c_wraith> Consider using FreeT over ST instead, maybe?
07:50:54 <numee> coppro: http://pastebin.com/j8DQhMV6
07:51:35 <coppro> numee: you didn't paste the whole code!
07:54:22 <numee> coppro: sorry for mismatched lines. I omitted imports and language pragmas. the code pasted was an excerpt from the original code's line 20-line69
07:54:56 <coppro> numee: eh? there's no extract in the first paste
07:57:05 <buglebudabey> silly question but i went through write yourself a scheme a while ago. on the front page of the project it says you'll be building an interpreter, but is it not a compiler?
07:57:07 <numee> coppro: so sorry ... http://pastebin.com/eSc9UTWc
07:57:35 <c_wraith> buglebudabey: the traditional distinction is that a compiler emits a standalone program that can be run without the interpreter's presence.
07:57:51 <c_wraith> buglebudabey: I haven't done that exercise, but I'm pretty sure it doesn't go that far.
07:58:06 <coppro> numee: oh!
07:58:39 <coppro> the problem there is you're universal quantification where what you need (and can't have, because it isn't supported) is existensial quantification
07:58:49 <buglebudabey> c_wraith it takes in a scheme file and evaluated the entire thing, but you also have the option of running a repl. both are evaluated using the same function
07:59:19 <c_wraith> buglebudabey: It sounds like neither one outputs a standalone executable.
07:59:20 <coppro> numee: basically, when you return a valute of type forall a . t, you're promising that that value can be made into t regardless of what a is
07:59:29 <coppro> and the consumer of the function can pick the value of a
07:59:33 <coppro> for instance, consider read
07:59:34 <coppro> :t read
07:59:35 <buglebudabey> c_wraith fair enough, thanks
07:59:35 <lambdabot> Read a => String -> a
07:59:44 <coppro> this implicitly has a quantification of forall a.
07:59:58 <coppro> it's saying "pick any a as lont as it has an instance of Read, and I can make the value into this type
08:00:42 <coppro> the return type of decons is promising that it can decons to *any *b
08:00:53 <tobiasBora> Ok great thank you,
08:00:54 <nitrix> coppro: Is forall a.t even possible without extensions?
08:00:58 <coppro> this fails, because your Bind constructor ends up binding a value of a single type
08:01:06 <coppro> nitrix: no, you can't explicitly specify it withour RankNTypes
08:01:08 <coppro> *without
08:01:14 <tobiasBora> Now I use ghc 10, so how could I see the trace of function call before exception ?
08:01:23 <nitrix> coppro: Because you need a `t` on the left hand side of the dot?
08:01:40 <coppro> nitrix: no, because forall is not standard Haskell
08:01:47 <nitrix> Well, that too.
08:02:02 <coppro> in my example, I was using t as a placeholder for a more complex expression
08:02:10 <nitrix> But for `t`, what else do you need? ExistantialQuantification I think?
08:02:12 <coppro> if you actually tried to write "forall a. t" it would complain at you that t doesn't exist
08:02:35 <coppro> yeah, ExistentialQuantification gives you ability to use forall at the top-level
08:02:40 <coppro> which is just a syntactic extension
08:02:46 <coppro> RankNTypes lets you write it inside types
08:03:43 <c_wraith> coppro: actually, they allow it in completely different places.  ExistentialQuantification allows it to be applied to a data constructor.  RankNTypes allows it to be put inside of function type arguments.
08:04:10 <c_wraith> Err.  The type arguments to the (->) type constructor.  That's better phrasing.
08:04:12 <buglebudabey> paging Cale, if you're there 
08:07:05 <numee> coppro: thanks now I might understand why `decons` doesn't work. So I need a GADT to represent the return type as done in operational https://hackage.haskell.org/package/operational-0.2.3.2/docs/src/Control-Monad-Operational.html#viewT ?
08:08:54 <coppro> numee: yes, I believe that would work
08:09:17 <Velizar> https://gist.github.com/VelizarHristov/a8ac55fbf9c786594b2bae8abaa7ea38 how can I rewrite lines 9-12 to use a fold rather than recursion? I'd like to use a Foldable instead of a List. It was easier to do for lines 4-7.
08:09:54 <numee> coppro: and this is the only way?
08:11:38 <coppro> numee: yes, you can do things with data types that you can't do directly
08:13:34 <numee> coppro: thank you. I'm going to make changes to see if it works ...
08:14:06 <coppro> I am heading out now so I won't be around to reply
08:14:10 <coppro> just so you know
08:15:25 <numee> coppro: right. thanks for helping me for a long time!
08:23:54 <tomjaguarpaw> I'm a bit confused about how cabal executable + library packages work.  The executable build does not pick up any changes that I make to the library.  What should I be doing?
08:24:22 <thimoteus> what are you doing?
08:25:05 <tomjaguarpaw> Running cabal build
08:25:37 <tomjaguarpaw> It builds both the executable and the library, but the executable must be linked against an old version of the library (somehow) because the changes I make to the library are not reflected in the executable. 
08:28:10 <acowley> tomjaguarpaw: Are you in a sandbox? Is (an older version of) your package installed in the sandbox?
08:28:33 <tomjaguarpaw> No, I'm not in a sandbox.
08:28:50 <tomjaguarpaw> This using vanilla cabal 
08:30:12 <tomjaguarpaw> Ah, I was mixing versions of Cabal
08:30:17 <tomjaguarpaw> Something got very confused
08:30:38 <tomjaguarpaw> Seems tobe fine now, thanks.
08:31:36 <acowley> tomjaguarpaw: I've run into the exact same problem with sandboxes, but it usually comes down to me doing something questionable (like installing the package)
08:32:19 <acowley> tomjaguarpaw: The nice thing about sandboxes is that, if you work on a few separate projects, blowing one away doesn't ruin (much of) your day.
08:32:27 <dfeuer> Kill da wabbit.
08:33:09 <dfeuer> I'm still stuck on that problem from yesterday. I started unboxing everything by hand, but it's just *horrible*.
08:39:39 <dominik> hmm, trying to use Data.Text.IO tells me: Could not find module ‘Data.Text.IO’ …
08:39:41 <dominik>     Perhaps you haven't installed the "dyn" libraries for package ‘text-1.2.2.0@text_5c7VCmRXJenGcMPs3kwpkI’?
08:40:20 <dominik> so I need to install something else besides the text package to use Data.Text.IO ? What are the dyn libraries?
08:41:35 <dcoutts> enthropy: new-build works with ghc 7.6+
08:45:28 <codedmart> In a Map keys do keys have to be unique?
08:47:49 * hackagebot lens-simple 0.1.0.9 - simplified import of elementary lens-family combinators  https://hackage.haskell.org/package/lens-simple-0.1.0.9 (MichaelThompson)
08:53:27 <tobiasBora> Hum...
08:53:34 <ironChicken> i'm working on some ffi code in which i need to marshall some data into a parameter with this declaration: `const float *const *buffers`
08:53:42 <ironChicken> the docs tell me that it expects an array of arrays
08:53:48 <tobiasBora> The error givent by haskell 8.0.1 is still less clear than the original error :
08:53:51 <tobiasBora>   Map.!: given key is not an element in the map
08:53:53 <tobiasBora>   CallStack (from HasCallStack):
08:53:55 <tobiasBora>     error, called at libraries/containers/Data/Map/Base.hs:489:16 in containers-0.5.7.1:Data.Map.Base
08:53:59 <ironChicken> previously with array marshalling i've used Data.Vector.Storable's `withForeignPtr`
08:54:17 <ironChicken> but if i now want to construct this 2D array and marshall it through the ffi, is there something more specific for handling that?
08:54:29 <tobiasBora> Why do I need to know that it's devined in containers/.../ line 489 ? I need the line in my own code...
08:54:34 <ironChicken> i mean, i guess in principle i could write a Storable instance for `S.Vector (S.Vector CFloat)`
08:55:41 <c_wraith> ironChicken, actually, you can't. Storable requires fixed size structures 
08:55:50 <glguy> dominik: You can generate "static" and "dynamic" libraries from a package, the "dyn" versions are dynamic
08:56:04 <ironChicken> c_wraith: oh yes
08:56:11 <glguy> What are you doing that's trying to use the dynamic versions?
08:57:29 <ironChicken> ultimately what i need to supply as an argument to the foreign function is a pointer to a float
08:57:46 <ironChicken> but i need to have made sure that that pointer points to an appropriate structure
08:58:07 <ironChicken> i guess i'm just asking if there's some existing library that makes that easy
09:14:57 <Morgawr> Is it possible to conditionally pattern match in a function declaration?
09:15:13 <Morgawr> Let's say I want f x = ... if x is 2 or 3
09:15:24 <Morgawr> I don't want to do f 2 = ... and then type again f 3 = ...
09:15:27 <glguy> f x | x == 2 || x == 3 = ....
09:15:47 <Morgawr> So I have to use guards?
09:18:08 <Morgawr> How would I do that if I'm matching on a constructor? In my code I have myFunction val@Opt1{} = ...  myFunction val@Opt2{} = ... 
09:18:21 <Morgawr> I want to have the same body for both Opt1 and Opt2
09:18:43 <glguy> You can write a function:  isOpt2 Opt2{} = True; isOpt2 _ = False
09:18:47 <glguy> and then put that in a guard
09:19:06 <glguy> or you can name the shared body and call it in both definitions
09:19:15 <Morgawr> mmm.. sounds convoluted but I guess that can work
09:19:19 <glguy> f Opt2{} = thing; f Opt1{} = thing
09:26:08 <Luke> hey guys is there a recent benchmark on hashmap/hashtable implementations?
09:26:12 <Luke> like a comparison?
09:27:16 <dfeuer> Luke, those aren't exactly comparable, since hashmaps are persistent.
09:27:30 <aoeu> would anyone like to take a stab at code-golfing/refactoring this function? http://lpaste.net/167764
09:27:39 <Luke> dfeuer: persistent in what way? on disk?
09:27:46 <monochrom> Morgawr: I would use shared body
09:27:51 * hackagebot react-flux 1.1.1 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.1.1 (JohnLenz)
09:28:03 <dfeuer> Luke, no. You can modify one and still have the old version.
09:28:07 <Luke> oh
09:28:21 <Luke> i guess hash table would be better for me then
09:28:48 <Luke> but is there a comparison of performance on hashtables then (I'm assuming they're faster since internally they can do distructive updates)?
09:28:57 <monochrom> mutable hash table is likely to be slower, simply because extra deferencing due to IORef/STRef is slower.
09:29:16 <Luke> I don't want something in IO
09:29:26 <Luke> or ST preferrably unless it's way faster
09:29:37 <monochrom> but it is likely way slower
09:29:43 <Luke> i'm looking for the thing with fastest lookups and inserts
09:30:06 <Luke> anyone know of any benchmarks? I feel like I saw a blog post comparing implementations but I can't find it
09:30:20 <monochrom> too bad I haven't benchmarked them, so I don't have hard evidence
09:30:25 <glguy> aoeu: Does that code load for you?
09:30:44 <monochrom> I only overheard a while ago someone disappointed at hash table low speed
09:31:07 <monochrom> (before hashmap existed)
09:31:32 <buglebudabey> in Miranda there is a Heap data structure from the utils library, is there anything like it in haskell?
09:31:42 <peddie> Luke, last time I tried to use mutable hashtables, it was about 8x slower for ~500k entries than Data.IntMap
09:31:50 <monochrom> there are many priority queues on hackage
09:31:55 <Luke> what about IntMap vs. Map?
09:32:09 <peddie> Luke: I didn't try, as my key was already an Int
09:32:25 <Luke> i thought I remember seeing that IntMap was actually slower than Map these days for some types of data
09:32:27 <Luke> even for Int keys
09:32:32 <peddie> maybe it's about the same modulo your Ord instance?
09:33:06 <peddie> sorry, I haven't tried
09:34:45 <Luke> anyone able to find any benchmarks online?
09:34:48 <Luke> that's what I'm really looking for
09:35:33 <aoeu> glguy: actually I get a parse error when `chase` is defined in the where clause. I edited the paste
09:35:47 <peddie> Luke: maybe you are the hero we have all been waiting for and can post some benchmarks online ;)
09:37:33 <ironChicken> it looks like i might be able to use Data.Array.Storable: (newArray ((0,0), (2,16384)) (0.0 :: CFloat)) :: IO (StorableArray (Int,Int) CFloat)
09:37:35 <monochrom> Luke: tibbe must have benchmarked things before he settled on implementations. I just don't know where he put it.
09:37:58 <Luke> monochrom: haha yeah. i feel like he had before
09:38:01 <Luke> google is failing me though
09:42:15 <Luke> i wonder if unordered-containers hashmap is faster than containers map or intmap
09:42:21 <tobiasBora> I would like to debug my code using Hat, how could I use it in an Hat project ?
09:44:55 <c_wraith> is hat currently maintained? 
09:46:04 <peddie> Luke: for this same application, IntMap was about twice as fast as HashMap.  but again, my keys were Ints
09:47:26 <c_wraith> IntMap is especially good when your keys don't share many bits of prefix. 
09:48:39 <peddie> c_wraith: in my case they did actually share plenty of bits (just primes in order), so maybe the gap could be even wider than I saw in some cases
09:52:51 <c_wraith> hmm. actually, they use a compressed trie.. there are only children where there are branches. a long common prefix wouldn't hurt things at all
10:00:17 <dfeuer> Yeah.
10:00:42 <lpaste> glguy annotated “takeWhile monoid accumulator” with “takeWhile monoid accumulator (annotation)” at http://lpaste.net/167764#a167771
10:01:46 <Luke> peddie: what about IntMap vs. Map
10:01:51 <Luke> peddie: my keys are ints too
10:02:10 <dfeuer> Anyone have any tips on getting GHC to unbox tuples in ST results? Someone told me yesterday that GHC often has trouble with that, but I'm hoping for maybe one last nice way before I continue the deep dive of hand-unboxing.
10:02:23 <dfeuer> The dive is very very deep.
10:02:38 <glguy> aoeu: I think that version is clearer
10:04:04 <peddie> Luke: I didn't test against Map, but it should be trivial to switch if you write the algorithm for one of them
10:04:15 <Luke> yeah we have benchmarks. we can switch i guess
10:04:19 <Luke> was hoping someone else did the work =)
10:04:30 <peddie> Luke: for me it was a question of importing a different module in one line
10:05:48 <xaviergmail> Does anyone mind looking over my self-inflicted "homework" while keeping in mind this is the first bits of Haskell code I've ever written? http://pastie.org/10888095
10:06:45 <mjrosenb> xaviergmail: normally, in haskell, you put the type immediately before the dfinition, not separated into separate sections.
10:06:48 <lyxia> xaviergmail: reverseList is slow
10:06:52 <mjrosenb> oh, you already commented about that.
10:07:25 <dfeuer> xaviergmail, you should put the type signatures above the definitions *before* you ask other people to look at it; it's much harder to read this way.
10:07:36 <dfeuer> Please fix it and then come back.
10:07:40 <xaviergmail> Yeah, I started out that way and then decided to keep it as a novelty
10:07:47 <c_wraith> damn it, lyxia beat me to the punch. but reverseList really is quite bad. 
10:07:51 <xaviergmail> Alright one sec
10:08:23 <dfeuer> xaviergmail, if doubleEveryOtherR is supposed to work from right to left (which I seem to remember it is), then it doesn't do what it's supposed to.
10:08:51 <mjrosenb> xaviergmail: also, I would probably not implement doubleEveryOther by reversing the list twice.
10:09:16 <xaviergmail> I call reverse before calling it because I don't know of any other way really to do it with this functional mindset just yet
10:09:42 <dfeuer> Oh, I see now.
10:09:50 <dfeuer> Yeah, you can do it a different way.
10:09:52 <monochrom> xaviergmail: the Haskell terminology is different from C's. "definition" is a special case of "declaration". (unhelpful comment)
10:09:56 <dfeuer> What's the R supposed to stand for?
10:10:15 <dfeuer> Reversed, I guess.
10:10:20 <xaviergmail> That's just my lack of vocabulary actually, but yes
10:10:42 <xaviergmail> same thing happened with sumDigitsX
10:11:13 <c_wraith> I think reverseList is the most important part here. it doesn't just have style issues, it has an important performance problem. 
10:11:22 <dfeuer> Yes.
10:11:30 <dfeuer> c_wraith is correct. THat is the biggest problem.
10:11:35 <dfeuer> Er...
10:11:44 <xaviergmail> Yeah, I've been wanting to ask about that since it's been mentioned
10:11:51 <dfeuer> Except I think toDigits may be bad for similar reasons.
10:12:13 <xaviergmail> I know there's a builtin reverse function now, but what exactly makes it slow?
10:12:18 <dfeuer> xaviergmail, the ++ operator has a deceptively similar appearance.
10:12:23 <dfeuer> er.
10:12:28 <c_wraith> dfeuer, nah, it's recursive on the right side. it's fine. 
10:12:31 <dfeuer> deceptively *symmetrical*.
10:12:58 <dfeuer> c_wraith, it appends on the wrong side of the recursion, no?
10:13:10 <c_wraith> Oh, whoops. I read it backwards. 
10:13:16 <c_wraith> yeah, it's the same problem. 
10:13:31 <dfeuer> xaviergmail, when you use ++ recursively, you will run into performance problems if you do something like (((a++b)++c)++d)++e
10:13:51 <xaviergmail> ah
10:13:54 <dfeuer> Because in the process of appending, it will run over the elements of `a` over and over and over again.
10:14:02 <dfeuer> once for each ++.
10:14:06 <tobiasBora> c_wraith: I don't know if hat is maintainted, but it doesn't compile... See this bug : https://github.com/luqui/hothasktags/issues/28
10:14:10 <dfeuer> And almost as many times for b, etc.
10:14:39 <dfeuer> The fast  way to reverse is the same as it is in, say, Scheme, if you've seen that.
10:14:58 <dfeuer> Use a helper function, reverseOnto, with an accumulating parameter.
10:15:06 <geekosaur> hat is extremely dependent on ghc internals. it last worked against ghc 6.6 iirc
10:15:13 <dfeuer> (Reverse a list onto the front of another list)
10:17:00 <xaviergmail> hmm not quite sure I understand yet
10:17:24 <xaviergmail> Let me oil up my brain real quick
10:18:10 <c_wraith> @src (++) 
10:18:10 <lambdabot> Source not found. Wrong!  You cheating scum!
10:18:26 <c_wraith> hmm. I expected that one to be there. 
10:18:34 <c_wraith> unless... 
10:18:40 <c_wraith> @src ++
10:18:40 <lambdabot> []     ++ ys = ys
10:18:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:18:40 <lambdabot> -- OR
10:18:40 <lambdabot> xs ++ ys = foldr (:) ys xs
10:18:53 <geekosaur> that said, hat's successor was hood, which I *think* is still reasonably current
10:19:19 <geekosaur> (also see GHood)
10:19:47 <c_wraith> xaviergmail, there. consider the definition of (++) as presented above. look at how it treats its arguments very differently. 
10:21:16 <Cale> buglebudabey: You were looking for me earlier?
10:21:22 <buglebudabey> I was!
10:21:30 <Cale> What's up?
10:22:13 <buglebudabey> Would you mind if I shot you a private message? although I may have to leave momentarily
10:22:32 <Cale> not at all, go ahead
10:24:44 <xaviergmail> I see c_wraith, thank you
10:26:46 <nmz787_i> edwardk: are you the ersatz person?
10:28:44 <sphinxo> I'm getting something odd when I try and use the brick library
10:29:13 <sphinxo> copying one of the examples is seems to fail on importing handleDialogEvent
10:29:29 <sphinxo> even though https://github.com/jtdaugherty/brick/blob/master/src/Brick/Widgets/Dialog.hs#L15
10:29:38 <sphinxo> it is quite clearly defined 
10:29:41 <dfeuer> nmz787_i, he's one of them...
10:30:38 <sphinxo> oh wait, it's probably because for some reason i downloaded a really old version?
10:33:41 <peddie> Luke: I did a quick Criterion run just for you <3  IntMap was about 8% faster for <100k keys and about 10% faster for <1M
10:33:59 <Luke> peddie: awesome thanks!
10:36:20 <lkj1> so i know this is wrong, but is there a way to do what i'm trying to do here: http://lpaste.net/167788
10:36:37 <lkj1> transform that IO into a Maybe..?
10:36:52 <glguy> No, that wouldn't make sense
10:37:25 <glguy> lkj1: While in your particular case you had an IO Int that was "pure 3", so it was obvious there was a number that you might want to get out, that isn't possible in general
10:37:58 <lkj1> glguy what am i not understanding?
10:38:21 <glguy> lkj1: an IO Int isn't a wrapped up Int, it's a thing that when executed produces an Int result
10:38:34 <geekosaur> @quote /bin/ls
10:38:34 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
10:38:47 <glguy> and the only way to execute something in Haskell is to make it part of "main"
10:39:00 <lkj1> i thought the point fo monad transformers was that there are specific instances where you can specify transformations between monads
10:39:11 <shachaf> That's a property of e.g. C as well.
10:39:31 <glguy> No, monad transformers aren't about transforming IO Int into Maybe Int
10:39:46 <lkj1> so what would be the canonical approach, replace Maybe with Maybe (IO Int)
10:39:47 <lkj1> ?
10:40:13 <glguy> lkj1: IO (Maybe Int) or Maybe (IO Int) depending on what you actually meant
10:40:33 <glguy> is it a program that when executed returns a Maybe Int? or is it maybe a program that when executed returns an Int
10:41:13 <lkj1> well this is a toy version of a real program
10:41:24 <glguy> (07do putStrLn 04"hi"; return Nothing) 07:: IO (Maybe Int)
10:41:26 <hk238> hm
10:41:31 <glguy> Nothing 07:: Maybe (IO Int)
10:41:50 <hk238> I've not really learned to do this monad stuff, but just happened to think about it looking at this conversation
10:41:50 <lkj1> the real program fetches data aeson with a client. i want to handle various errors in unwrapping that aeson data with a Maybe monad
10:42:46 <glguy> lkj1: If the decision to return Just or Nothing depends on the result of executing some IO action then your type will be: IO (Maybe Int)
10:42:50 <nitrix> hk238: If you're referring to glguy's snippet, this has very little to do with monad. It's just type reasoning.
10:42:53 <hk238> would it be plausible to think that there's some confusion about what monads are about, due to an ambiguity with the term? That it refers to two different, a way to create things, and the things, that are also called monads? 
10:43:22 <hk238> but nitrix arent monads about types though?
10:43:34 <hk238> or at least I thought so :o
10:43:37 <nitrix> hk238: The term isn't ambiguous. You probably just read ambiguous or low quality material on the subject that confused you.
10:43:47 <hk238> Oh 
10:43:58 <glguy> hk238: My example was just that there's a difference in IO (Maybe Int) and Maybe (IO Int), not about how the Monad class works
10:44:01 <hk238> so can you define it excatly?
10:44:19 <nitrix> hk238: Chainable computations.
10:44:27 <hk238> I dont think that's sufficient
10:44:40 <nitrix> hk238: Think what you like until you understand it.
10:45:07 <hk238> well it's pointless to argue about it, but it's pretty obvious that the definition you gave is not an exhaustive description
10:45:28 <nitrix> You would be surprised.
10:45:47 <hk238> no
10:46:00 <mjrosenb> glguy: how did you syntax highlighting in irc?
10:46:08 <nitrix> All you need is return to promote the computation and join to chain two computations.
10:46:23 <glguy> mjrosenb: I added a syntax highlighter to my IRC client
10:46:44 <mjrosenb> glguy: that sounds like a reasonable approach.
10:46:49 <lkj1> ok i've wrapped it in IO (Maybe ..))
10:46:59 <mjrosenb> reasonable *and* awesome.
10:47:02 <lkj1> how do I change this to do the exception handling as intended though?
10:47:18 <lkj1> as it is now bar is partial
10:47:43 <nitrix> hk238: Monads are defined by return and join in category theory. (>>=) and (>=>) are Haskell contraptions to facilite a more practical usage.
10:48:07 <lkj1> the intention is to fallback on Nothing without boilerplate if String blah doesn't match i'm not sure how to change this to accomplish that http://lpaste.net/167788
10:48:24 <glguy> lkj1: Use a case expression instead of matching directly with the pattern "String blah"
10:48:49 <nitrix> hk238: The sequencing and the strictness depend on the monad instance implementation which have nothing to do with the definition of monads themselves.
10:48:50 <lkj1> if it was within a maybe monad do block i *could* just match like that right?
10:49:15 <lkj1> it's less verbose / more elegant... but the way it's written the computation is of course in the IO monad and not the Maybe monad
10:49:43 <hk238> I thought that Monads are about wrapping data of different types
10:50:01 <hk238> and also about a proceadure that allows you to combine functions or producedures regardless of their differring types
10:50:11 <hk238> in such a manner that those `3 laws` are followed
10:50:11 <hk238> ?
10:50:18 <mizu_no_oto_work> nitrix: the problem with 'chainable computations' as a definition of monads is that you can define non-monadic chainable computations, and it doesn't mention anything about return.
10:50:24 <nitrix> hk238: Monads can go a lot further than that. The data and types is only because, in Haskell, monads are for the Hask category.
10:50:46 <hk238> so you've studied category theory?
10:51:47 <nitrix> I'm not sure if that question is leading anywhere.
10:52:04 <hk238> you've not managed to convince me so far
10:52:05 <hk238> :D
10:52:12 <hk238> which seems to be what you're trying
10:52:13 <nitrix> I'm not here to convince you.
10:52:24 <nitrix> You're mistaken.
10:52:29 <hk238> Or not ^^
10:52:35 <glguy> great conversation
10:52:47 <nitrix> glguy: I'm dropping it.
10:53:15 <nitrix> If you still have in interest in that definition, ask me for a PM.
10:53:24 <hk238> :D
10:54:03 <hk238> actually I'm interested in finding out things, but you dont seem like the correct person to talk to
10:54:12 <hk238> but let's not argue anymore :o
10:54:16 <joe9> need some help, please? I am trying to figure out how to get mapM functionality when using Data.Strict.Map.mapWithKey? I have a function that does (k -> a -> m b) and mapWithKey uses a function with this signature (k -> a -> b)
10:54:18 <hk238> It's my fault for keeping it up, anyway..
10:55:22 <glguy> joe9: You can sequenceA the result
10:55:24 <joe9> When using mapM : (a -> m b), it gets [a] -> m [b]. not sure howto get this when using mapWithKey though: (k -> a -> m b) -> Map k a -> IO (Map k b)
10:56:20 <glguy> (07\f m 07-> sequenceA (mapWithKey f m))  07:: Applicative f 07=> (k 07-> a 07-> f b) 07-> Map k a 07-> f (Map k b)
10:56:32 <nitrix> hk238: My answer used to be `Composable computation` but someone wrote an interesting proof using the Trivial monad that made me change my mind.
10:56:54 <joe9> glguy, Thanks a lot
10:56:55 <lyxia> joe9: traverseWithKey
10:57:16 <joe9> lyxia: spot on. Thanks a lot.
10:57:21 <glguy> Oh, I didn't know that traverseWithKey was there, that's more direct
10:57:50 <mizu_no_oto_work> hk238: sometimes people play a bit fast and loose with terminology.  Technically speaking, a monad is something like (fmap, pure, join), but people often say that a type m is monadic if a monad exists where pure :: a -> m a.  I don't think this is often terribly confusing, though.
10:58:37 <hk238> oh alright 
10:59:47 <hk238> I've been confused about it though ^^
11:01:23 <nitrix> Are you still confused about it?
11:01:36 <hk238> I think so
11:02:22 <hk238> I was looking into it at some point, and watched some speeches from youtube about category theory and monads, and was left off with the impression I have, it doesnt seem to match your definition
11:02:24 <nitrix> Which aspect? You seem to know about the monadic laws are a few other details. If you were to ask a more precise question, I could provide an answer that's of better quality.
11:02:52 <mizu_no_oto_work> Are you interested in seeing how the category theoretic definition maps to Haskell?
11:02:57 <hk238> but I suppose if there's no confusion about monadic types being monads, then the confusion existed just for me
11:03:17 <hk238> mizu_no_oto_work that would be interesting, maybe not sufficient so that I'd pick it up correctly, but interesting definitely
11:03:28 <nitrix> I for sure would like to see these videos. There's not many visual material around Hask.
11:03:51 <hk238> if you look up a channel called `catsters` on youtube, there's some nice videos
11:04:00 <hk238> especially there's an enthusiastic woman who is very nice to listen to
11:04:22 <hk238> and then some random speeches, I dont remember how to look them up
11:05:50 <nitrix> It's my understanding that `monadic` type/values/context only refers to the facilities Haskell provide to work with monads.
11:06:37 <mizu_no_oto_work> hk238: You might have heard that 'a monad is a monoid in the category of endofunctors'
11:06:40 <mizu_no_oto_work> https://en.wikipedia.org/wiki/Monoid_%28category_theory%29
11:06:41 <nitrix> e.g. A monadic context, could be a `do` block, which is also sugar around (>>=).
11:06:48 <hk238> yeah I've heard that expression ^^
11:07:28 <nitrix> Do you know about endofunctors?
11:07:39 <hk238> There was also a nice speech by an older gentleman with a hat, and a board
11:07:48 <hk238> I remember looking up the definition I'm probably not gonna get it right
11:07:54 <monochrom> I still haven't needed to think of the category of endofunctors
11:08:11 <mizu_no_oto_work> Before you look at monoids a la category theory, you should look at monoidal categories - https://en.wikipedia.org/wiki/Monoidal_category
11:09:12 <mizu_no_oto_work> When you consider the category of Hask endofunctors, the Bifunctor we'll use is the Compose type
11:09:30 <nitrix> I have a feeling hk238 is hiding that he knows more than he's wants to claim.
11:09:54 <nitrix> Being humble is great but it's not making it easy to assess which parts confuses you.
11:10:04 <mizu_no_oto_work> so if you have a functor f and a functor g, the monoid operation will give you back Compose f g
11:10:30 <mizu_no_oto_work> And the identity object is Identity, oddly enough
11:10:33 <monochrom> yeah, I solve that problem by not knowing monoidal categories of endofunctors. therefore no confusion.
11:10:42 <hk238> :D
11:11:04 <hk238> it would be pretty interesting to understand the theory properly.. But it seems really challenging.. at least for me 
11:11:33 <monochrom> it takes infinite time to understand "the" theory "properly"
11:11:40 <Cale> heh
11:11:59 <dhruvasagar> monochrom: you mean it is possible ?
11:11:59 <monochrom> if you don't believe me, stay on and hear it out.
11:12:13 <kmelva> is there a way to use GHC.Generics without having a value of the generic type? Lets say I just want to find out the record field names?
11:12:32 <glguy> kmelva: You can use a proxy argument for the type
11:12:38 <monochrom> let's start with the integers. sounds easy and you already know them, right? but no, you haven't known them.
11:13:11 <monochrom> the set of integers is a special case of rings, so ring theory is involved.
11:13:13 <kmelva> glguy: how would that look like? I've tried `(undefined :: SomeType)` but it doesn't work
11:13:25 <monochrom> rings are special cases of modules, so module theory is also involved.
11:13:36 <glguy> kmelva: Post what you tried to lpaste and I'll make an example for you
11:13:40 <mizu_no_oto_work> So a monoid object in Hask is a Functor for m, along with mu :: Compose m m a -> m a and eta :: Identity a -> m a
11:13:45 <monochrom> rings are also special cases of Cayley algebra. etc etc.
11:14:12 <mizu_no_oto_work> via the definition of compose, you can turn Compose m m a into m (m a), and Identity a is isomorphic to a.
11:14:20 <monochrom> there is no upper limit on generalizations and abstractions. "the" theory is an infinite hierarchy. you will spend forever climbing it.
11:14:33 <hk238> speaking of which I just set up my keyboard layout to write the greek alphabet yesterday.. or it was two days ago?
11:15:06 <monochrom> dhruvasagar: http://perl.plover.com/classes/OOPSLA/samples/slide067.html
11:15:10 <hk238> mu and eta would be... μ and η , is that correct? I mean not that it helps to use some less used symbols instead of plain english :D
11:15:22 <monochrom> yes
11:15:22 <Cale> yes
11:15:38 <mizu_no_oto_work> They're lowercase greek letters
11:15:59 <dhruvasagar> monochrom: does not compute
11:16:21 <monochrom> infinite time = impossible
11:16:38 <mizu_no_oto_work> Clearly, lowercase greek letters are the best variable names.
11:16:55 <dhruvasagar> monochrom: infinitye time = very long time, you just have to wait till you exhaust the memory space
11:16:57 <dhruvasagar> monochrom: :P
11:18:07 <lpaste> rcat pasted “Dynamically sized matrices with known size at run-time using `linear' package” at http://lpaste.net/167792
11:18:08 <monochrom> dhruvasagar, be sure to click "next" and see the next few slides after. in fact the whole set is worth seeing.
11:18:17 <mizu_no_oto_work> Why use f and g when you can use ϝ and γ?
11:18:28 <kmelva> glguy: thanks for the offer, I don't have the code at this computer. But I have a pretty vanilla generic code, that give a concrete value returns a list of field names for that type. It works just fine for my problem, but sometimes I'd like to use it without a concrete vaule fo some type
11:18:38 <rcat> I'm having issues trying to understand how to use `reifyDim' from `linear'
11:18:58 <rcat> not sure if I get the idea how it use this function, I just pased a small piece of code that shows what I want to do
11:19:06 <Cale> mizu_no_oto_work: ϝ is very atypical
11:19:16 <nitrix> I see ∀ and ∘ used here once in a while.
11:19:22 <rcat> but I can't find examples online about this, anyone has experience using `linear' with dynamiclaly sized matrices?
11:19:24 <Cale> φ
11:19:26 <kmelva> glguy: i tried passing in (undefined :: MyType)  but it breaks, I hoped that would work because I don't need the anything inside the record...
11:19:29 <mizu_no_oto_work> true.  They don't actually use digamma in modern greek
11:19:30 <monochrom> > (\λ -> λ+λ) 4
11:19:31 <lambdabot>  8
11:19:47 <nitrix> monochrom: Naughty.
11:20:04 <dhruvasagar> monochrom: interesting
11:20:09 <dhruvasagar> monochrom: how did you type those chars ?
11:20:59 <mizu_no_oto_work> Cale: I mostly used it since f came from digamma, which became widely used in Latin even though it disappeared in Greek
11:21:03 <monochrom> I installed fcitx on ubuntu
11:22:04 <hk238> you can use character map to copypaste them, or you can use numpad to compose characters, or you can use two keyboard layouts and set up a key to switch between them, or you can edit the current layout and swap some keycombinations with the ones you want, but at least with linux mint, with xkb, there's some issues. Also there's like a limit of 4 symbols per letter, but you can avoid that by using
11:22:19 <hk238> I think numpad? or you can use dead_keys to create new combinations
11:22:40 <hk238> which is what I did, I was actually trying to do it by making it so that winr + abc -> greek abc 
11:22:40 <hk238> :D
11:22:44 <Cale> Yeah, though if you're going to name generic functions with Greek letters in mathematics, perhaps the usual place to begin is with φ and ψ. :)
11:22:52 <hk238> but it didnt work out as number of letters ran out
11:22:56 <hk238> so  iwent with the dead key choice
11:23:03 <nitrix> Another option is text substitution. I have \ lambda becomes λ.
11:23:07 <monochrom> ideally in 10 years you plug a USB cable directly to your head so there is no keyboard to set up
11:23:18 <hk238> which I think actually pretty convenient... but there's also some problems with gnome applications, which have some hardcoded tables for that stuff
11:23:49 <hk238> but you can deal with that possibly by setting up an environment variable.. well nevermind, I was just struggling with this earlier, but now it works, but not in all applications unfortunately
11:23:57 <glguy> kmelva: http://lpaste.net/167793 here's some code that does it using Tagged instead of Proxy, but you can go either way (possible duplicate message)
11:24:05 <hk238> namely the gnome ones
11:24:07 <Cale> I like having it set so that my left Win key, while pressed, changes the layout to Greek.
11:24:11 <monochrom> oh! on IRC your IRC client may have user-defined auto-correct so you could define "please auto-correct 'moo' to µ"
11:24:34 <hk238> Cale yeah that seems like a good idea, however I only got into so that it toggles it, what OS are you using?
11:24:41 <Cale> Linux Mint
11:24:43 <hk238> oh me too
11:24:47 <hk238> how did you do that ? :d
11:24:57 <mizu_no_oto_work> dhruvaagar: there's also digraphs, in vim.  ctrl-k l* will give you a lowercase lambda
11:25:22 <kmelva> glguy: thanks, I'll take a look, hope it's not to advanced :)
11:25:38 <mizu_no_oto_work> dhruvasagar, rather
11:25:45 <Cale> Keyboard preferences -> Layouts, add the Greek layout, then go to "Options..." -> Switching to another layout -> Left Win (while pressed)
11:25:59 <hk238> oh you can do it like that.. oh that wouldv'e been so easy
11:26:03 <hk238> :D
11:26:43 <hk238> ohh.. Im such a moron ^^
11:26:52 <frew> anyone in here use gitit and plugins?
11:27:05 <frew> it seems to me that many of the bundled plugins are totally broken
11:27:19 <dhruvasagar> mizu_no_oto_work: that I am aware of
11:27:34 <hk238> oh well this works too, but that's more straightforward :d
11:27:47 <dhruvasagar> mizu_no_oto_work: but we're in an irc client, weechat specifically for me
11:27:51 <kmelva> glguy: oh wow, this is definitely beyond me for now :(. I'll save it and revisit it in a few weeks, for now I'll just create dummy values by hand or something like that. Thanks anyway!
11:29:40 <hk238> anyway I gotta go to bed, I'll try and read those wikipages later, mizu_no_oto_work ^^
11:29:55 <hk238> added them to bookmarks :d
11:29:58 <hk238> good night
11:30:12 <levi> frew: I use gitit a bit, but not regularly right now.
11:37:14 <frew> levi: well if interested, when trying to use the interwiki plugin I get this error: https://gist.github.com/frioux/448300924f806f0b51008e03167ac81c
11:37:24 <frew> this is with gitit 0.12.1.1
11:41:08 <frew> it looks like it might be an issue with using too new of a pandoc version
11:42:40 <frew> can anyone tellme how to install a specific version of a module in a stack?
11:42:48 <Zemyla> Also, it occurs to me that an arrow-based parser doesn't have the token type as the input argument.
11:42:50 <frew> my guess was stack exec cabal -- install foo=123
11:43:08 <Zemyla> Its type would be something like ParserA token a b.
11:47:14 <levi> frew: Looks like it just wasn't updated as the types changed. The 'Link' constructor now takes an extra first argument.
11:47:41 <frew> right
11:47:50 <levi> frew: The new argument is of type 'Attr' and you can make an empty one with the smart constructor 'nullAttr'
11:48:08 <frew> I'd rather downgrade pandoc than patch gitit right now
11:48:25 <frew> but that's good to know; I'll make a note
11:49:39 <levi> Well, the plugins aren't really integral parts of gitit and you'd only have to touch a couple of lines. But whatever works best for you.
11:50:20 <frew> yeah gitit is just such a small part of our infra
11:50:27 <frew> it's weird to me that the build-depends says
11:50:37 <frew> pandoc-types >= 1.12.3 && < 1.17
11:50:48 <frew> so clearly they know 1.17 is a problem
11:50:50 <frew> but not 1.16?
11:51:10 <levi> Probably none of the current users use that plugin, so it wasn't noticed.
11:51:17 <frew> Dot is broken too fwiw
11:51:19 <frew> but yeah IG uess
11:53:07 <levi> I'll bet some pull requests that make it work within the current pandoc-types version bounds would be accepted.
11:54:22 <levi> I don't think anyone's being paid to maintain pandoc or gitit, so it's up to the community of users to help keep things up to date; at least by reporting issues if not by contributing fixes.
11:55:31 <frew> yeah I get it
11:55:50 <hexagoxel> frew: pandoc-types-1.17.* does not exist yet. according to pvp, upper-bound has the semantics of "up to this bound, compilation works with (some) certainty", not "it is certain not to work with anything above this bound".
11:56:05 <frew> https://github.com/jgm/gitit/pull/534
11:56:15 <frew> that's probably good
11:56:32 <frew> oh doesn't fix plugins
11:56:34 <hexagoxel> that an upper bound exists does not automatically mean that any problem with certain versions is known.
11:57:19 <frew> well
11:57:35 <frew> I'm trying to modify the cabal file to get it to downgrade the version of pandoc / pandoc-types
11:57:43 <frew> but it is annoyed that it already has 1.16.1 installed
11:57:57 <frew> anyone know of a way to force it to rebuild (without just clearing out .stack?)
11:58:06 <hexagoxel> (and by the looks, "some certainty" did not mean too much in this case..)
11:58:21 <crough> ?: --force-dirty?
11:58:22 <lambdabot> Maybe you meant: v @ ? .
11:58:27 <frew> crough: will try
11:58:41 <frew> nah same thing
11:58:50 <crough> wha wag 
11:59:00 <crough> *wah... hmm, I would say something else is probably weird
11:59:00 <frew> `pandoc-types: needed (>=1.12.3 && <1.16.1), 1.16.1 found (latest applicable is 1.16.0.1)` is the error for those interested
11:59:22 <frew> well I'll probably just delete .stack and go to lunch.
11:59:38 <frew> prob won't take more than an hour.
11:59:58 <theseb> help! what is best free PDF to dip your toe into Haskell?
12:00:16 <theseb> i have a student who loves programming.....I want a great thing I can print now that will make him fall in
12:00:16 <theseb> luv
12:00:23 <rntz> can anyone explain to me why http://lpaste.net/167798 produces an error?
12:00:24 <geekosaur> frew, that makes me think you need to use an older resolver
12:00:45 <theseb> too many choices at https://www.haskell.org/documentation :(
12:00:51 <rntz> it says "Invalid type signature: Reify :: c => Satisfy c", but c is a Constraint, so shouldn't that be fine?
12:00:56 <xaviergmail> theseb: I'm currently learning from http://www.seas.upenn.edu/~cis194/spring13/lectures.html but learnyouahaskell.com seems to be pretty good too
12:01:00 <hexagoxel> i seriously doubt that deleting .stack will improve the situation.
12:01:30 <boek> [A
12:01:31 <theseb> xaviergmail: i saw that..it was 1st link...looked great
12:01:58 <frew> geekosaur: any idea what arg I should pass to --resolver ?
12:02:03 <xaviergmail> 'lectures.html' for lack of a better name is quite rough at first for me at least since I've never really used recursion
12:02:23 <geekosaur> frew, find one that includes an appropriate version of pandoc
12:02:40 <frew> ohhh so a resolver is not an algorithm, but more of a snapshot of packages
12:02:46 <geekosaur> you should be able to look up pandoc on stackage.org and find resolver versions that habve the version you need
12:02:49 <geekosaur> yes, exactly
12:02:50 <frew> ok
12:02:53 <frew> I didn't know that
12:03:01 <xaviergmail> Right now my plan is to learn from the lectures since it has quite challenging assignments and look at learn you a haskell whenever I get stuck
12:03:12 <frew> I don't really use haskell except for this one thing
12:05:34 <frew> ok well
12:05:44 <frew> I tried the lts-5.18 resolver
12:05:53 <frew> oh wait that's still too new
12:06:40 <rntz> er, oops, I wrote `class' when I should have written `data'
12:07:33 <rntz> it sill produes an error though: http://lpaste.net/167799
12:08:47 <rntz> if I leave off the (c :: Constraint) signature, it works, though! what in the world?
12:09:16 <rntz> oh, I see, Constraint is defined in GHC.Exts
12:09:45 <geekosaur> yeh, need to import it, it doesn't come into scope just because you enabled ConstraintKinds
12:11:13 <nitrix> frew: There's also the command `stack solver` that can figure out the right resolver/snapshot to use for your project automatically.
12:11:22 <nitrix> frew: That can save you some work.
12:13:39 <nitrix> It'll either propose changes to do to your stack.yaml file (like the most appropriate resolver and list of external/internal dependencies) or fail very verbosely; at which point, you're on your own.
12:19:28 <theseb> my studnet just found a vid on youtube from Simon called "Haskell is useless"
12:19:30 <theseb> lol
12:19:51 <mikail`> Hi, I'm using emacs haskell-mode to do my haskell development. Is there a good way to easily refactor code using it? For example, I need to change the definition of a data type. This is obviously going to impact the code I have written using it but also the hspec (there are many) unit tests. It looks like I'm going to have to do this manually which I rather not do.
12:20:32 <mikail`> theseb: it's click bait :)
12:21:52 <Cale> mikail`: Usually all I do is just change the type, and then immediately start running the compiler, and let GHC tell me what needs changing in response.
12:22:07 <xaviergmail> theseb: Updated version of what I've been following.. https://www.seas.upenn.edu/~cis194/lectures.html
12:23:16 <mikail`> Cale: yep that's my usual mode of operation but I was wondering if there were some nifty tricks I was unaware of that would help me speed up the refactoring.
12:23:27 <nitrix> mikail`: Doesn't GHC tells you everything you need to know?
12:23:48 <maerwald> mikail`: no, he actually says it, but it's a joke
12:23:52 <Cale> I think there's probably some way to get it to display the locations of the errors
12:24:19 <mikail`> nitrix: it does and that's great but wanted to avoid the manual effort if I could leverage haskell-mode in some nice way
12:24:24 <nitrix> mikail`: C-x M-c write-the-code-for-me :)
12:24:32 <Cale> But anything I know about the emacs Haskell mode is probably out of date, since the last time I used it was in 2004 or something
12:24:33 <monochrom> haskell-mode doesn't have refactoring
12:25:17 <monochrom> but it has "flag error locations in source file, and when you mouse-over, the humongous error message pops up"
12:25:29 <nitrix> In all honesty, I couldn't get vim nor emacs to play along nicely, I just defaulted to using GHCI and doing :r 
12:25:46 <monochrom> "but it disappears after a while. mouse-over again to see it again.)
12:25:51 <theseb> the minute i saw the cussing sun on that haskell book i knew it was the 1 4 mee
12:26:34 <Cale> I use sublime, but with none of its haskell-specific stuff (apart from syntax highlighting) -- I'm not sure how to get it to play nicely with nix anyway.
12:26:54 <mikail`> on another note, can anyone do case analysis using ghc-mod?
12:27:28 <mikail`> http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
12:27:39 <mikail`> at the bottom: case handling
12:28:16 <mikail`> so far haskell-mode, stack and emacs is working nicely for me
12:28:35 <mikail`> i did try atom but i gave up when i couldn't get it to talt to ghc-mod
12:28:47 <mikail`> *talk*
12:29:03 <monochrom> maybe I should try ghc-mod some time
12:29:19 <monochrom> is it compatible with emacs haskell-mode
12:29:27 <monochrom> err, is it compatible with emacs haskell-mode?
12:29:48 <mikail`> monochrom: it seems to work for me so far
12:29:55 <monochrom> ok, good to hear
12:30:01 <mikail`> except the case handling
12:30:12 <mikail`> that would be cool if it did that
12:30:18 <peddie> monochrom: I had years of battling ghc-mod with emacs and finally installed intero about 2 hours ago, and it's massively better
12:31:38 <cjay> hmm
12:31:47 <monochrom> w00t, it's on melpa too
12:31:49 <cjay> does intero work with evil?
12:32:04 <peddie> cjay: I have no idea
12:32:13 <monochrom> I don't want to use stack. Is that OK?
12:32:21 <peddie> monochrom: nope, you have to I think
12:32:23 <mikail`> peddie: intero looks good - i never heard of that before
12:32:40 <mikail`> monochrom: yes
12:32:54 <peddie> monochrom: in my experience it is easier to copy and paste a stack.yaml file for your project than to try to get ghc-mod to do anything
12:33:02 <mikail`> cabal install ghc-mod
12:36:54 <Profpatsch> I’ve got a type Entity = [Component]
12:37:34 <monochrom> does that mean the actual code is "type Entity = [Component]"?
12:37:48 <Profpatsch> How do I make it so that the implementation of Entity is hidden and it’s a Monoid?
12:37:59 <Profpatsch> monochrom: Conceptual, still.
12:38:18 <monochrom> I will only comment on actual code. I don't trust programmer's English.
12:38:33 <Profpatsch> Something like Entity a = ? deriving (Monoid)
12:38:38 <Profpatsch> newtype *
12:38:55 <Profpatsch> And then I export only a few functions that return an Entity.
12:39:04 <Profpatsch> But I’m not sure what ? should be then.
12:40:49 <nitrix> newtype Entity = { runEntity :: T }
12:41:12 <Profpatsch> Hm, I thought I can’t do newtypes without a type argument.
12:41:13 <nitrix> and the deriving clause, but then you'll need the NewtypeDeriving extension I think?
12:42:33 <monochrom> {-# LANGUAGE GeneralizedNewtypeDeriving #-}  newtype Entity = Ctor [Component] deriving Monoid
12:43:21 <nitrix> newtype Entity = Entity { runEntity :: T } deriving Monoid
12:43:35 <nitrix> Profpatsch: Not necessary, but you'll need a constructor for the syntax I used, my bad.
12:49:00 <enthropy> dcoutts: thanks that's good to know (that cabal-install 1.24 works with ghc-7.6)
12:50:23 <Profpatsch> nitrix:  monochrom thanks, that worked!
12:52:41 <glguy> aoeu: Are you still around?
12:53:38 <aoeu> glguy: yes, I did find your version more straightforward
12:54:00 <lpaste> glguy annotated “selector names with generics” with “selector names with generics (annotation)” at http://lpaste.net/167793#a167805
12:54:11 <glguy> aoeu: This one only works in GHC 8, but I think it's easier to follow
12:55:37 <glguy> acowley: You around?
12:56:48 <aoeu> glguy: which does? Your annotation on http://lpaste.net/167764 or the selector generics you just pasted?
12:56:56 <xaviergmail> Is there a good set of lectures or any free books on recursion? I feel like I should begin with that first
12:57:05 <glguy> the second paste uses TypeApplications, which is new in GHC 8
12:58:30 <aoeu> glguy: I think that was someone else's question, I never asked about generics. Mine was takeWhileAccum1
12:58:40 <glguy> Ooh, sorry about that
12:58:45 <aoeu> np
12:59:25 <glguy> kmelva: That was for you ^
13:01:14 <monochrom> xaviergmail: my http://www.vex.net/~trebla/haskell/recursion.xhtml has only begun writing, but maybe it helps you.
13:01:28 <Profpatsch> Okay, so now I’ve got newtype Entity = Entity { unEntity :: [Component] }
13:01:57 <Profpatsch> And   mempty = Entity []
13:01:58 <Profpatsch>   mappend c1 c2 = Entity $ unEntity c1 ++ unEntity c2
13:02:23 <Profpatsch> But I want to be able to say: „Every Component is also an Entity“
13:03:17 <xaviergmail> monochrom: I will have a look, thank you
13:03:49 <Profpatsch> Maybe I’m coming from a wrong angle.
13:03:54 <geekosaur> Profpatsch, Haskell generally doesnt let you say things like that
13:04:00 <Profpatsch> Yeah, I know.
13:04:19 <Profpatsch> comp1 <> comp2 :: Entity
13:04:20 <monochrom> Profpatsch: you didn't use GeneralizedNewtypeDeriving?
13:04:36 <Profpatsch> No, I wanted to make sure I understand what happens.
13:05:05 <monochrom> I see. Now for your question:
13:05:49 <monochrom> If you want "there are two cases, Entity could be an individual Component or a list", it is "data E = C1 Component | C2 [Component]"
13:06:25 <xaviergmail> ECS? :P
13:06:52 <monochrom> and then if you change your mind and say "scratch that, Entity could be an individual Component or a list of moar Entitys", it's data R = D1 Component | D2 R
13:07:22 <monochrom> But at some point you have to make up your mind what your model is.
13:07:23 <ski> s/D2 R/D2 [R]/ ?
13:07:45 <monochrom> And then code is an intelligent design according to your model. Not an evolution.
13:08:09 <monochrom> None of that "mutate my code until it is legal" crap.
13:08:57 <monochrom> I mean, sure it's your right to do evolution, but I won't try to understand the result, it is not meant to be explained.
13:09:32 <monochrom> yeah, D2 [R]
13:10:32 <Profpatsch> We had this construct in theoretical CS, where we said  q . empty == q, empty . q == q, q * (w1 * w2) == (q * w1) * w2, q in Q, w1, w2 in W, “W operates on Q”
13:11:29 <monochrom> is "q == q" a typo?
13:11:36 <monochrom> err misread
13:11:54 <Profpatsch> “The monoid W operates on Q”
13:12:02 <monochrom> I have problem type-checking "q * (w1 * w2)"
13:12:45 <ski> Profpatsch : perhaps they were talking about monoid actions ?
13:12:47 <Profpatsch> But it’s probably just a mathematical shortcut for  (qTow q) * (w1 * w2)
13:12:55 <c_wraith> that looks like what edwardk called a monoid action 
13:13:20 * ski . o O ( <https://en.wikipedia.org/wiki/Monoid_action> )
13:13:35 <c_wraith> (his blog is the only place I've seen it) 
13:13:56 <monochrom> but since Q and W are different types, you don't simply merge them and say "q is an entity, w1 is an entity too"
13:14:07 <Profpatsch> You are right: https://en.wikipedia.org/wiki/Semigroup_action
13:14:07 <shachaf> c_wraith: That's a standard term, isn't it?
13:14:18 <ski> (c_wraith : that WP page mentions it, at least)
13:14:31 <monochrom> in fact it is very important for group/monoid/semigroup actions to draw a line between them.
13:14:52 <ski> Profpatsch : i don't think there has to exist such a `qTow' function
13:14:57 <c_wraith> probably standard. I don't want specifying where I saw the term in case it wasn't. 
13:14:58 <monochrom> because W is being a monoid but Q isn't.
13:15:24 <reqq456> this seems pretty cool http://hangman-profile-56437.bitballoon.com/
13:15:30 <c_wraith> err.. I *was* specifying.. 
13:16:40 <puregreen> (for anyone who might be afraid to click on reqq456's link: it's slides for “Getting started with GHCJS dev”)
13:22:00 <ryantrinkle> is there a name for a monoid with a "top" value, such that forall a. top <> a == top == a <> top
13:22:01 <ryantrinkle> ?
13:22:16 <crough> that's an absorbing, or zero element
13:22:47 <crough> I don't know if there's a name for it, but it's just a semigroup with a zero just like a monoid is a semigroup with an identity
13:23:05 <crough> ring like structures require it for the multiplicative operation iirc though
13:23:17 <ryantrinkle> crough: ok, cool; i was able to find this package - perhaps it's useful :) https://hackage.haskell.org/package/zero
13:23:20 <ryantrinkle> thanks!
13:23:29 <crough> of course! glad I could help
13:24:21 <dmj`> crough: wouldn't zero be top <> a == a though, mempty <> a == a
13:24:27 <Profpatsch> monochrom: So far I’ve got this. http://lpaste.net/167808
13:24:33 <bitemyapp> dmj`: no that's identity or 1
13:24:46 <Profpatsch> Is this a good interface?
13:24:46 <crough> yeah, think of multiplication
13:24:50 <bitemyapp> dmj`: multiplication permits talking about "more stuff" than addition
13:25:05 <bitemyapp> dmj`: addition _only_ has an identity, no real zero (inverses are something else)
13:25:12 <bitemyapp> dmj`: multiplication has an identity (1) and a zero (0)
13:25:25 <crough> bitemyapp: unless you pull in surreal numbers and addition :)
13:25:27 <bitemyapp> dmj`: Consider Data.Void WRT Either and (,)
13:26:03 <bitemyapp> Void | Bool == Bool  whereas  (Void, Bool) == Void
13:27:40 <dmj`> bitemyapp: I see, I thought zero was being compared to identity, but it wasn't
13:29:09 <ski> whee
13:34:35 <berndl_> Is there a way to define a phantom type that is automatically validated by some function? For example, say I have a phantom type, data Color a = Color String and I only want to allow Color "blue", Color "red", Color "green" and everything else cause the compiler to complain.
13:35:59 <glguy> berndl_: If you only have 3 colors you support you can write: data Color = Blue | Red | Green
13:36:03 <monochrom> if there are only 3 cases, I would "data Color a = Red | Green | Blue"
13:36:26 <berndl_> I know. I was just using that as a toy example.
13:36:47 <glguy> The response you get is only as valid as your example
13:37:17 <Enigmagic> berndl_: if you want to restrict what types are valid for a phantom type take a look at the DataKinds extension
13:37:20 <glguy> monochrom: You got tricked, that wasn't real code!
13:37:34 <Enigmagic> however three constructors is better for that example :p
13:37:40 <glguy> berndl_: Are you aware in your example that the phantom type is the "a"?
13:37:42 <berndl_> Enigmagic: yes, how do I do that with DataKinds?
13:38:01 <glguy> berndl_: and that the string arguments are not related to it?
13:38:12 <berndl_> glguy: Yes.
13:39:00 <Enigmagic> berndl_: data MyColors = Red | Green | Blue; data Color (a :: MyColors) = Color; blue = Color :: Color 'Blue
13:39:02 <monochrom> guessing the non-toy example is a pin-in-haystack problem I won't solve.
13:39:03 <Enigmagic> something like that
13:39:16 <berndl_> Here's a more realistic example: data URI a = URI String. I only what to allow things like URI "http://example.com" to be accepted by the compiler.
13:39:48 <Enigmagic> the Symbol type isn't flexible enough to support that
13:39:57 <Enigmagic> kind
13:40:46 <monochrom> don't put a string there. put the decomposed fields there. data URI a = URI Protocol Host (Maybe Password) (Maybe [(Key, Value)])
13:40:59 <monochrom> and I forgot Port
13:41:19 <berndl_> monochrom: Yes, I could do it that way, but I want the flexibility of just writing URI "http://example.com".
13:41:33 <monochrom> then you aim too low.
13:41:55 <glguy> berndl_: You'll have the flexibliity of writing: parseURI "http://example.com", where parseURL :: String -> Maybe URI
13:42:12 <monochrom> how about turning on OverloadedString and writing the IsString instance so that you have the flexibility of just writing "http://example.com"?
13:42:22 <geekosaur> that still does the check at runtime though
13:42:40 <berndl_> glguy: I don't want to have to explicitly call parseURI.
13:42:42 <geekosaur> only way you're doing that at compile time is TH or quasiquotes
13:44:56 <berndl_> hmm...maybe TH is the way to go.
13:45:05 <Enigmagic> berndl_: https://hackage.haskell.org/package/network-uri-static
13:45:43 <berndl_> Nice. Let's see how they do it...
13:45:55 <aaronm04> Hi, I ran "stack setup" on opensuse and got this error: "Could not find module 'Distribution.Simple'". Any idea what's going wrong or how to fix it?
13:46:15 <berndl_> oh, they seem to be using quasiquotes
13:46:40 <berndl_> from TH
13:46:41 <Profpatsch> Is there a typeclass that contains filter :: Traversable t => (a -> Bool) -> t a -> t a ?
13:47:09 <KaneTW> what do you mean contains?
13:47:20 <KaneTW> oh
13:47:28 <glguy> Nothing standard, but there is a package called witherable http://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html
13:47:34 <Profpatsch> Oh, haddock sais MonadPlus.
13:47:53 <Profpatsch> *says; or Alternative for that matter.
13:48:16 <berndl_> Still to verbose though. Ideally, I just want to say exampleURI :: URI exampleURI = "http://example.com" and have the compiler automatigically figure out everything.
13:48:48 <aaronm04> please disregard my question. I fixed it by installing the ghc-Cabal-devel opensuse package
13:50:06 <geekosaur> berndl_, no, you say it that way and any "figure out everything" will be at runtime, not compile time
13:50:47 <geekosaur> like, you could do the OverloadedStrings thing, but then the URL gets checked by fromString at runtime, all the compiler does is insert the fromString call for you
13:51:07 <geekosaur> no, you can't use the extension to insert a quasiquoter or TH splice
13:51:57 <berndl_> Oh well...
13:52:59 * hackagebot libroman 3.0.0 - Use Roman Numerals as a Numeric Datatype (sort of)  https://hackage.haskell.org/package/libroman-3.0.0 (ahakki)
13:53:59 <Profpatsch> glguy: Ah, thanks.
14:03:28 <buttons840> i have a function of the form (a -> b), and it compiles just find without a type signatures, but when I try using the partial type signature f :: _ -> _ i get a compile error -- i must not understand partial type signatures?
14:04:01 <buttons840> i thought something like "f :: _ -> _"  was basically the same as having no type signature?
14:05:01 <lyxia> have you activated PartialTypeSignatures
14:05:47 <buttons840> with {-# LANGUAGE PartialTypeSignatures #-} ? yes
14:05:55 <shachaf> I don't know anything about _ in type signatures.
14:06:05 <shachaf> But in my experience the best thing to do when you get a compile error is to read it.
14:06:28 <puregreen> buttons840: please paste the actual error whenever you ask about an error in #haskell
14:06:30 <puregreen> @where lpaste
14:06:30 <lambdabot> http://lpaste.net/
14:06:45 <puregreen> (don't do it in channel itself unless it's one line)
14:06:53 <buttons840> yeah
14:08:52 <buttons840> http://lpaste.net/167812
14:09:39 <puregreen> buttons840: I think it happens because the inferred signature also has a type constraint
14:09:49 <puregreen> i.e. “MonadIO m => something -> m ()”
14:10:04 <puregreen> so the right partial signature for it would be “_ => _ -> _”
14:10:05 <buttons840> puregreen: oh, so it's not a function of the form (a -> b); it has that constraint
14:10:09 <buttons840> that makes sense
14:12:11 <buttons840> yeah "_ => _ -> _" works
14:22:36 <thimoteus> are the >>= and =<< glyphs used in category theory outside of haskell?
14:24:50 <dolio> No.
14:28:00 * hackagebot libroman 3.0.1 - Use Roman Numerals as a Numeric Datatype (sort of)  https://hackage.haskell.org/package/libroman-3.0.1 (ahakki)
14:36:01 <pikajude> is it in any way possible to use this function? http://hackage.haskell.org/package/logging-effect-1.0.1/docs/Control-Monad-Log.html#v:mapLoggingT
14:37:24 <cheater> thimoteus: i already suggested they be added to unicode
14:37:33 <cheater> i don't know what happened with that though
14:37:42 <thimoteus> ahh
14:37:48 <thimoteus> i'm just going to use the private use area for them
14:39:22 <fishythefish> They're kinda Unicode already, but two symbols: ≫ and =
14:39:40 <Hijiri> pikajude: If you have a function message -> message' and a function n () -> m () then you can go from Handler n message' to Handler m message
14:39:56 <Hijiri> and then you can apply the (Handler m message -> m x) to get an m x
14:40:06 <pikajude> i guess i need a natural transformation that goes both directions
14:40:08 <Hijiri> then finally you need some natural transformation to turn that into n x
14:40:23 <pikajude> i need n a -> m a and m a -> n a
14:40:29 <Hijiri> the n () -> m () doesn't necessarilly have to be a natural transformation
14:40:52 <Hijiri> not sure if it's meant to be used with something not one, though
14:42:31 <xaviergmail> `map :: (a -> b) -> [a] -> [b]` the parens in the first arg indicate a function of type a that returns type b, correct?
14:43:27 <glguy> ping a
14:43:47 <pikajude> right
14:43:52 <lyxia> a is the type of the argument
14:43:56 <pikajude> point being i can't define an MFunctor instance for this monad
14:44:16 <xaviergmail> err, a function that takes in an argument of type a and returns type b yeah that's what I meant
14:45:26 <lyxia> xaviergmail: yes
14:47:06 <xaviergmail> Right, and here we're using b because the type may change but it's also okay for it to stay the same?
14:47:57 <xaviergmail> This is all starting to make sense now, I didn't really understand map/filter and such in other languages
14:48:13 <lyxia> right
14:49:07 <xaviergmail> one thing I am acustomed to however, is passing functions as arguments which seems to be a reoccuring theme here. Love it!
15:01:50 <athan> I'm probably going to get blacklisted for this, but does GHC have any facilities for compile-time IO?
15:02:36 <luite> athan: template haskell allows IO
15:03:10 <athan> Hm! Okay, thanks luite
15:07:46 <Squarism> Say i want 2 main methods in my project.. one stdio and one webserver variant. How do i do this in a nice way?
15:08:14 <hpc> how do you want to distinguish between which to call on a particular execution?
15:08:23 <Squarism> i dont know
15:08:29 <hpc> write main1 and main2, both :: IO (), and then main = figure out which to execute
15:08:40 <hpc> is the general answer
15:08:43 <Squarism> ok
15:09:07 <hpc> you might want to use command-line arguments to determine which to use
15:09:25 <monochrom> perhaps have two exes
15:09:26 <hpc> which there's various libraries to make pleasant and some basic stuff in base
15:09:30 <athan> luite: How does it "allow" for it? Doesn't it just turn all your haskell into an AST, and force you to make an AST -> AST morphism or something?
15:09:33 <hpc> or yeah, two executables
15:09:35 <ski> an alternative could be what monochrom said
15:09:38 <hpc> which cabal can do
15:09:53 <hpc> with separate main modules
15:09:57 <ski> (two main modules, each with a `main')
15:10:01 <athan> so you could do `[|case $(some term) of ... |]` or something? Sorry it's been a while
15:10:19 <monochrom> athan, look for "runIO".
15:10:54 <luite> athan: the code executed by TH produces some AST result, but in the Q monad, you can lift IO actions into the Q monad with runIO and use whatever IO you need to produce your result
15:11:57 <athan> luite: Oh wow that's badass okay
15:11:59 <athan> thank you!
15:13:12 <bitemyapp> athan: I use this all the time
15:13:31 <bitemyapp> athan: for example, to bake git metadata into the binary so I can retrieve SHA1/etc.
15:16:44 <theseb> I have a student that loves python and i'm trying to convince him Haskell
15:16:52 <theseb> will be worth his time...What can I say
15:16:57 <theseb> to make him salivate over Haskell?
15:17:05 <theseb> convince him it is the "bees knees"?
15:18:02 * hackagebot atom-conduit 0.3.1.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.3.1.0 (koral)
15:18:22 <tinco> theseb: perhaps there's some field he is interested in?
15:18:39 <tinco> you could show him how to solve problems in that field with Haskell
15:20:22 <theseb> tinco: he want to be a programmer!
15:20:40 <tinco> yeah but everyone wants to program something specific, right?
15:21:01 <theseb> tinco: i have a chance because he likes functional programming
15:21:22 <tinco> well Haskell is the best functional programming language out there, isn't that enough? :P
15:21:26 <theseb> tinco: he cares deeply about security and i told him functional is good for mathematically verified software
15:22:08 <theseb> tinco: there is a chasm......on one side...he is intrigued by functional....on other side he's scared because haskell isn't like python
15:22:17 <tinco> I don't know if that's true, but Haskell is good for security because of how you can express very constraining types
15:22:19 <theseb> tinco: i don't know how to build a bridge
15:23:06 <theseb> tinco: what is the state of the art regarding provably correct programs?
15:23:27 <theseb> tinco: is there some url or paper that shows how haskell is awesome for that?
15:23:31 <tinco> well you'd have to use a language that explicitly supports it, like Coq
15:23:55 <roboguy`> you can extract Coq to Haskell, once it's been verified
15:23:59 <tinco> afaik you can't prove Haskell programs correct very easily, but I'm not an academic, maybe someone else knows more about that
15:24:08 <theseb> tinco: if provably correct isn't the main use case for Haskell what is?
15:24:10 <buglebudabey> does anyone use Data.Heap often, or is there a better option?
15:24:16 <roboguy`> HERMIT is a system that allows theorem proving about Haskell code
15:25:02 <theseb> roboguy`: how mature is this notion of proving software? 
15:25:21 <roboguy`> theseb: the notion itself? very, very mature. Coq has been around since the '80s
15:25:25 <tinco> :P
15:25:29 <theseb> roboguy`: i assume the "big boys" have a favorite toolchain for this..if you say they like compiling Coq to Haskell I'll believe you
15:25:32 <roboguy`> and Coq wasn't the first, certainly
15:26:21 <tinco> afaik compiling Coq to Java or C is more popular :P
15:26:22 <roboguy`> well, I use HERMIT some (I help maintain it sometimes) but I use Coq as well. Coq is probably the most popular way. HERMIT is usually more about custom, verified optimizations
15:26:52 <roboguy`> tinco: ha, pretty sure that isn't possible with any existing tool
15:26:59 <theseb> roboguy`, tinco: if i may...let me try another tack....suppose YOU wanted to design software to say....run a nuclear power plant, do surgery on your loved one, navigate your billion dollar spaceship.....How would YOU make damn sure the code was golden?
15:27:14 <roboguy`> I would use Coq
15:27:18 <tinco> jup me too
15:27:18 <roboguy`> and extract to Haskell
15:27:22 <augur> does anyone know of a good modern take on Plotkin's CBN/CBV work?
15:27:29 <theseb> roboguy`: awesome...thanks!
15:27:37 <roboguy`> Coq is a very reliable system
15:28:03 <theseb> tinco: thanks^2
15:28:04 <roboguy`> It's also kinda like Haskell (with dependent types)
15:28:32 <tinco> we had to do a little programming with Coq and related tools, but it wasn't much fun at all, there's very little room of expressing things before you run into walls
15:28:38 <wilhelmus> I just wanted to say chaining pointfree functions with bind in the Maybe-monad is the bomb!
15:28:56 <roboguy`> there's a nice free book about it called Software Foundations: https://www.cis.upenn.edu/~bcpierce/sf/current/
15:29:05 <tinco> you'll succesfully program a control software for a component of a nuclear reactor, but you won't easily program its interface with it I think :P
15:29:36 <roboguy`> tinco: it can definitely be tricky at times, but that is a price for verifying software
15:29:40 <theseb> roboguy, tinco: if you mechanically implement Coq stuff....then does it matter if you do that in Haskell or C or even Visual Basic?
15:29:53 <roboguy`> theseb: what do you mean?
15:30:17 <theseb> what i mean is the math of Coq is guaranteeing perfection...so what does it matter what language you realize your vision in?
15:30:33 <theseb> you could use Hermit to get Haskell but why is Haskell so important then?
15:30:36 <roboguy`> theseb: the Coq compiler can compile Coq code to Haskell, Scheme or OCaml code
15:30:40 <roboguy`> automatically
15:30:51 <theseb> ah
15:30:58 <roboguy`> that process is called extraction
15:31:47 <theseb> roboguy`: nice..thanks
15:32:03 <Griff`Ron> woah, very cool
15:33:08 <thoughtpolice> theseb: If you're talking about space ships, you're in luck, because there's some work out there describing how they did it. You should read about how NASA's on-board shuttle group developers software. http://www.fastcompany.com/28121/they-write-right-stuff
15:33:21 <tinco> theseb: all my knowledge of Coq is like 3 lectures and a practicum or two.. I didn't like working with formalisation tools very much at all so I didn't pursue the full track
15:34:13 <thoughtpolice> If you're going to be working on a nuclear reactor, I imagine your process will dictate more than your technology. Note that article was written 20 years ago - the JPL wasn't using Coq or anything at that time (at least, as far as I or anyone know. They probably used something like MISRA C or Ada perhaps with special toolchains.)
15:34:19 <tinco> I also like the defense in depth angle, where instead of making 100% sure your software is correct, you implement safe guards in your software that assume your software is not perfect
15:35:22 <Griff`Ron> woah, '96, this article is a relic 
15:39:24 <roboguy`> it helps quite a bit, in my opinion, that the basics of Coq are pretty similar to the basics of Haskell. Also, I have fun trying to prove theorems (well, sometimes) and playing with dependent types
15:39:47 <theseb> thoughtpolice: thanks
15:39:47 <Squarism> lol at javaland. 20 lines of code and you have a JSON capable webserver. Dito in java = gazillions of code + conf
15:40:13 <roboguy`> tinco: you might like Chlipala's approach a little more. He believes almost all proving itself should be automated
15:41:06 <roboguy`> He wrote the (also free) book Certified Programming With Dependent Types using Coq and a tactic he wrote called "crush" that can solve many (true) theorems, often with little assistance from the programmer
15:41:53 <theseb> roboguy`: well sure...we all believe that....I believe my dish washing should be automated also...doesn't make it happen.  ;)
15:42:27 <roboguy`> theseb: you'd be suprised... crush really can do a lot. Dishwashers do exist =)
15:42:46 <roboguy`> in Coq, you can write your own proof automation tactics
15:43:11 <roboguy`> so, at the very least, if you see a pattern that comes up again and again in your proofs, you can bring it out into a tactic and just use the tactic
15:43:46 <roboguy`> honestly, I'm still pretty consistently surprised by what is possible with Coq...
15:44:12 <theseb> to be continued..thanks all again..haskell 4 evar
15:44:42 <roboguy`> sorry to get on my Coq soapbox, everyone =)
15:48:03 * hackagebot werewolf 1.3.0.1 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.3.0.1 (hjwylde)
16:13:04 * hackagebot rts-loader 0.0.0.0 - Dynamically load Haskell libraries  https://hackage.haskell.org/package/rts-loader-0.0.0.0 (DanielG)
16:23:04 * hackagebot rts-loader 0.0.0.1 - Dynamically load Haskell libraries  https://hackage.haskell.org/package/rts-loader-0.0.0.1 (DanielG)
16:23:51 <Squarism> can i get around this error in any other way than create a new module? http://lpaste.net/167821
16:25:49 <theduke_> Hey there. Is there a package providing an efficient 64 bit UNSIGNED integer type? Google doesn't help me there
16:26:05 <glguy> Data.Word.Word64 in base
16:29:14 <theduke_> glguy: great, thanks!
16:32:17 <drw_> @pl \a b -> if f a thet a : b else b
16:32:17 <lambdabot> (line 1, column 31):
16:32:17 <lambdabot> unexpected reserved word "else"
16:32:18 <lambdabot> expecting variable
16:32:31 <drw_> @pl \a b -> if f a then a : b else b
16:32:31 <lambdabot> join . ap ((.) . if' . f) (:)
16:33:05 * hackagebot rts-loader 0.0.0.2 - Dynamically load Haskell libraries  https://hackage.haskell.org/package/rts-loader-0.0.0.2 (DanielG)
16:34:17 <fishythefish> Wadler defines least fixed point (approximately) as newtype Lfix f = Lfix (forall a. (f a -> a) -> a). What's the translation between this and newtype Mu f = In (f (Mu f))?
16:45:46 <johnw> fishythefish: I have the answer if you want it, figuring that out is a really excellent exercise
16:45:55 <johnw> but*
16:46:21 <fishythefish> johnw: Do you have hints? I'm a big fan of making this stuff click for myself.
16:46:42 <monochrom> don't use the same letter "f" for both.
16:47:10 <johnw> the only real hint I have is to never forget about functoriality
16:47:14 <fishythefish> monochrom: Ah, maybe that's the sticking point
16:47:55 <johnw> for bonus points, also prove the equivalence of those two forms to data Nu f = forall x. Nu x (x -> f x)
16:48:41 <fishythefish> johnw: That's what I'm working toward. :P Trying to keep data and codata separate while simultaneously observing that they're the same in Haskell is tricky for me
16:48:50 <johnw> yes, that's true
16:50:47 <roboguy`> Speaking of codata... I've heard that Coq's CoInductive doesn't quite work the way it should. What does it mean when people say that?
16:50:47 <johnw> fishythefish: most of the directions you'll be implementing aren't very hard, but there's one in particular that I think took me at least six hours
16:50:49 <monochrom> try to use LFix to get Peano numbers. try to use Mu to get Peano numbers. compare.
16:51:04 <johnw> roboguy`: that depends on how they think it's supposed to behave
16:51:29 <monochrom> one direction requires parametricity.
16:51:33 <johnw> roboguy`: it's more cumbersome in proof, and the guardedness condition is really strict, but otherwise I don't think it's unsound
16:51:44 <roboguy`> johnw: ahh... well, that's really all I know about that. Hmm...
16:51:59 <roboguy`> well, that's good at least
16:56:40 <fishythefish> monochrom: Why do you recommend not using "f" for both? Aren't they fixed points of the same functor?
16:56:46 <fishythefish> Or is there an isomorphism in there somewhere?
16:58:05 * hackagebot rts-loader 0.0.0.3 - Dynamically load Haskell libraries  https://hackage.haskell.org/package/rts-loader-0.0.0.3 (DanielG)
16:58:16 <monochrom> on second though, they are the same f.
16:58:29 <fishythefish> Okay, phew
17:09:10 <fishythefish> johnw: I think I might just be struggling with quantifiers. Lfix looks like the Scott encoding of Mu, but what's throwing me is the `forall` in Lfix, while In has type f (Mu f) -> Mu f
17:09:14 <fishythefish> Is this on the right track?
17:09:18 <monochrom> go completely wild and re-code Nu as: newtype Nu f = Nu (forall r. (forall a. a -> (a -> f a) -> r) -> r)  :)
17:10:15 <monochrom> no, Lfix is still Church or Böhm-Berarducci
17:10:32 <fishythefish> Okay, back to work, then :P
17:11:33 <shachaf> fishythefish: I would switch those names, by the way.
17:11:51 <shachaf> fishythefish: Mu is specifically the least fixed point, so I'd call the thing that you're calling Lfix "Mu".
17:11:56 <shachaf> And the other one I'd call "Fix".
17:12:57 <fishythefish> shachaf: Using Lfix because I'm reading Wadler's paper at the moment. I'm aware that Mu, Nu, and Fix are the same in Haskell, but I'm focusing on least fixed points for now
17:13:13 <shachaf> Right, they're the same in Haskell.
17:13:26 <shachaf> But "Mu" specifically means least fixed point.
17:13:41 <shachaf> Well, I haven't read that paper, so i don't know the names it uses.
17:14:05 <fishythefish> shachaf: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt if you're curious
17:14:45 <shachaf> OK, the names Lfix and Gfix are fine.
17:14:55 <shachaf> Just don't call the other one Mu.
17:16:10 <monochrom> fishythefish: Suppose I have "In (Just (In Nothing)) :: Mu Maybe". Do you know how to convert it to a value of type LFix Maybe? Do you know how to convert back?
17:16:26 <fishythefish> The other one? My understanding is Mu = Lfix = least fixed point, Nu = Gfix = greatest fixed point, and we happen to have Mu = Fix = Nu in Haskell. I'm just choosing names :P
17:16:45 <fishythefish> monochrom: Let me work through it :)
17:17:26 <Squarism> Is there any standard for describing datastructures "functionally". Like opposed to xml where all rules are static - a format that makes nested element X required if some other element Z has a date >= someDate or Y 's upper bound depends on K .. if you understand what i mean?
17:18:01 <Koterpillar> Squarism: sounds like definition of a compiler
17:18:05 <Squarism> haha
17:18:24 <Welkin> I have wondered for a long time now, why is there no standard implementation for a regular queue in haskell?
17:18:30 <Welkin> it should be in the containers package
17:18:44 <Welkin> even the simple queue as two lists from okasaki
17:18:48 <roboguy`> Squarism: hmm, sounds like you're looking for implementing that sort of stuff with types?
17:19:16 <Welkin> it looks like we have some nice heap implementations now, one of them from edward
17:21:20 <johnw> Welkin: I'd guess that patches are welcome
17:22:55 <Squarism> roboguy`, well i have no clue where we'll land. We've tried a "Rule's based - if-then" approach. Not too successful. I thought BPMN could be a good approach because of the nice graphical mapping. Would also let you intermediate values that arent part of the structure but needed in feedback
17:23:22 <Squarism> let you expose..
17:34:15 <fishythefish> monochrom: I see how Mu Maybe yields Peano numbers, but I still lack intuition for Lfix. On the other hand, that's the next example in Wadler's paper, so I'll keep reading.
17:35:00 <monochrom> OK, this last hint gets really close to being a spoiler.
17:35:14 <monochrom> Can you write a "foldr" for Mu Maybe?
17:35:40 <monochrom> (Yes you can. The point is, what is its type then? Ever seen that type? :) )
17:37:27 <fishythefish> Oh, derp
17:37:35 <fishythefish> I just realized catamorphisms are what Wadler keeps calling fold
17:37:45 <fishythefish> Thanks, monochrom :)
17:37:47 <shachaf> "fold" is a better name anyway.
17:37:56 <fishythefish> shachaf: agreed
17:38:22 <shachaf> But "Mu" isn't a good name for that type, and it appears nowhere in Wadler's text.
17:38:44 <monochrom> I would call it "Rec"
17:38:59 <shachaf> Well, it's an OK name in a general Haskell context, though I'd prefer "Fix". But it's a very confusing name in this particular context.
17:39:02 <monochrom> But I'm agnostic to names.
17:39:12 <fishythefish> We can agree to call it Fix - trust me, I'm not confused about the names
17:39:28 <shachaf> monochrom: Well, there's yet another type which people sometimes call Rec.
17:39:29 <shachaf> @src Rec
17:39:29 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
17:39:35 <monochrom> I would call the lot of them John, Jon, Johan.
17:40:37 <monochrom> that is a bizarre type
17:40:49 <shachaf> It's the type of Curry's paradox.
17:41:35 <monochrom> I agree to Fix.
17:42:08 <shachaf> It looks the same as the value-level fix.
17:42:36 <monochrom> yeah, and it doesn't say L or G, it just says "whatever your language gives"
17:43:06 <shachaf> Your language gives both.
17:43:07 * hackagebot text-ldap 0.1.1.8 - Parser and Printer for LDAP text data stream  https://hackage.haskell.org/package/text-ldap-0.1.1.8 (KeiHibino)
17:43:09 * hackagebot time-locale-compat 0.1.1.3 - Compatibility of TimeLocale between old-locale and time-1.5  https://hackage.haskell.org/package/time-locale-compat-0.1.1.3 (KeiHibino)
17:58:07 * hackagebot werewolf 1.3.1.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.3.1.0 (hjwylde)
18:12:33 <koz_> How do you pronounce the <$> operator? I know that <*> is read 'splat', but not <$>.
18:13:20 <roboguy`> koz_: fmap
18:13:55 <roboguy`> or do you mean the operator itself, as a piece of text?
18:14:05 <Iceland_jack> koz_: <*> is "ap"
18:14:08 <koz_> roboguy`: The operator itself, as a piece of text.
18:14:16 <koz_> Iceland_jack: Typeclassopedia says 'splat'.
18:14:23 <koz_> (although it does give several alternatives)
18:14:27 <Iceland_jack> Never heart that
18:14:37 <roboguy`> ah, dunno
18:14:41 <roboguy`> how about superman?
18:14:50 <koz_> Iceland_jack: https://wiki.haskell.org/Typeclassopedia#Definition_2
18:14:51 <Iceland_jack> "ap" or "apply", splat may be from the Idiom paper
18:15:01 <Iceland_jack> *heard
18:15:17 <Iceland_jack> The "ap" one is actually codified
18:15:19 <Iceland_jack> :t at
18:15:20 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
18:15:22 <Iceland_jack> :t ap
18:15:23 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:15:40 <koz_> Iceland_jack: Fair enough. I like roboguy`'s suggestion of 'superman'.
18:16:34 <Iceland_jack> But that's how programming languages get sued /s
18:16:51 <koz_> Iceland_jack: True.
18:16:55 <Iceland_jack> I like superman, especially since <*> is used to "lift" things
18:16:59 <Iceland_jack> :t liftA2
18:17:00 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:17:11 <Iceland_jack> @src liftA2
18:17:11 <lambdabot> liftA2 f a b = f <$> a <*> b
18:17:15 <Iceland_jack> I may use it from now on
18:17:50 <koz_> I basically don't use the 'liftA*' operators, because I find the mixture of superman and splat to be easier to both read and write.
18:18:00 <koz_> s/operators/functions
18:18:40 <Iceland_jack> In some situations I agree, when the arguments would need parens
18:19:08 <Iceland_jack>     f () <$> h 1 <*> h 2
18:19:08 <Iceland_jack> rather than
18:19:08 <Iceland_jack>     liftA2 (f ()) (h 1) (h 2)
18:19:24 <Iceland_jack> Most of the time I yearn for idiom brackets
18:19:35 <koz_> Iceland_jack: Well, maybe in GHC 9. :P
18:19:48 <Iceland_jack> koz_: A good reason to use liftA* is for partially applying
18:20:04 <koz_> Iceland_jack: You can partially-apply with superman and splat though...
18:20:10 <Iceland_jack> You end up writing this quite often
18:20:10 <Iceland_jack>     (+) = liftA2 (+)
18:20:10 <Iceland_jack>     (*) = liftA2 (*)
18:20:10 <Iceland_jack>     (-) = liftA2 (-)
18:20:12 <koz_> Honestly, I think it comes down to a matter of taste.
18:20:17 <Welkin> lol
18:20:24 <Welkin> never heard them called "superman" and "splat"
18:20:34 <Iceland_jack> and then
18:20:35 <Iceland_jack>     abs = liftA abs
18:20:36 <koz_> Welkin: 'splat' is from the Typeclassopedia.
18:21:01 <koz_> 'superman' is what Iceland_jack, roboguy` and I think we should call <$>.
18:21:25 <roboguy`> well, it looks like I got something accomplished today =)
18:21:48 <koz_> roboguy`: The Rumpelstilstkin (sp?!?!) Principle is alive and well on #haskell. :)
18:22:07 <Iceland_jack> Haskell also has the fishes (<=<), (>=>)
18:22:08 <Welkin> I just call it fmap o.o
18:22:12 <Welkin> but infix
18:22:21 <Welkin> haha, the fishes, yes
18:22:32 <roboguy`> ha
18:22:34 <koz_> Yeah - I call them 'left fish' and 'right fish' respectively.
18:22:41 <Iceland_jack> Welkin: This is 2016, we need hashtags for all of our operators
18:22:48 <idev> anyone have a 'how to implement apl in haskell' link?
18:23:10 <koz_> idev: https://wiki.haskell.org/APL ??
18:23:36 <Welkin> is that why Apple made their ticker symbol AAPL instead of APL?
18:24:08 <koz_> Welkin: It'd make more sense to make it 'APPL' honestly.
18:24:33 <Welkin> yes
18:24:45 <idev> I think APPLE would make more sense
18:25:09 <koz_> idev: You've clearly never worked on a UNIX. 'creat' is/was a thing there...
18:25:54 <idev> I do find my haskell var names to be quite verbose
18:26:15 <idev> two camelCase words is like 12 chars
18:26:31 <idev> which means on a 80 char wide screen, it means we can mention 6 vars
18:26:40 <koz_> idev: I think it depends on which ones. I've found Haskell to be relatively concise relative, say, Java.
18:27:01 <idev> java is : you can make a single function call per line
18:27:07 <Welkin> lol idev 
18:27:08 <koz_> Which is full of names like executeThingInContextNoThrowExceptionDoIOAsyncBuilderPatternIdiomSkeleton.
18:27:17 <Iceland_jack> Haskell is concise in the right places (imho)
18:27:17 <Iceland_jack>     id :: a -> a
18:27:17 <Iceland_jack>     id x = x
18:27:18 <koz_> idev: s/per line/per screen
18:27:22 <idev> but in haskell, with $ and ., I want to use more than one function name on a single line
18:27:26 <Welkin> that is not just java, that is cocoa/osx too
18:27:37 <koz_> Welkin: I can only speak for what I know.
18:28:00 <Welkin> I have been learning java recently, and it sure is ugly
18:28:07 <Welkin> and messy
18:28:12 <koz_> Welkin: I projectile-vomit at the sight of that language.
18:28:21 <johnw> this is really the Haskell channel, not the "we aren't Java" channel
18:28:26 <Welkin> it takes C and makes it worse :D
18:28:35 <Welkin> so I just went back to C
18:28:40 <johnw> this discussion should move to another channel now
18:30:40 <idev> johnw: is 'is it possible to a APL/array-style programming as a DSL in haskell' on topic?
18:30:41 <alunduil> Does anyone have a nice example of using milena (the kafka client)?
18:30:41 <Welkin> the problem when that happens is that there is nowhere for it to move to, so it just ends
18:32:59 <johnw> idev: certainly
18:33:03 <koz_> Is it sensible/sane/recommended to use QuickCheck to generate instances to run criterion benchmarks on?
18:33:23 <johnw> Welkin: I'm sorry, but that's not #haskell's problem :)
18:33:51 <johnw> koz_: why not, it's a data generation framework too
18:34:20 <koz_> johnw: I figured I'd ask in case there was something about that which was A Bad Idea (tm).
18:35:30 <idev> can we break down why APL appears more concise than haskell? I have a number of hypotheises: (1) APL only has data types of number, vector, matrix -- thus no selector/constructor names; (2) fuction names tends to be a 3 char subset of !@#$%^&*()_+-={}[]\|:;'"<,>.?/ , which tends to be shorter than English words, and (3) since we're only operating on vectors/matrices, there tends to be more builtins than user defined functions
18:36:14 <koz_> idev: Can't you just write a DSL which translates into calls to Vector or whatever?
18:38:37 <johnw> right, first identify if there is anything tricky about the semantics of such a DSL
18:38:49 <johnw> if not, then it's just about trying to match the syntax as closely as sanity will allow
18:39:02 <koz_> I think it's also worth asking what exactly you're trying to do here.
18:39:34 <idev> when I look at APL, haskell feels verbose, and I'm envious
18:40:47 <geekosaur> there's a balance between concision and readability
18:40:53 <Cale> I don't really feel very envious. The equivalent Haskell programs are not usually very different in terms of conceptual complexity. They might require more characters to express, but that's usually mostly due to the fact that things have sensible names
18:48:37 <idev> for things like representing a complicated mathematical formula
18:48:53 <idev> in terms of conciseness, I think we have math > apl > latex > haskell
18:50:04 <mgsloan> APL has a domain specific focus on vector and matrix manipulation, naturally some things will be very concise in it
18:50:40 <mgsloan> I'm guessing it would be a real pain in the ass to port any moderately complicated Haskell program that's actual useful to people
18:50:57 <mgsloan> Well, that is too broad of a criteria, but you get the picture
18:52:47 <mgsloan> Also, math is not a language, and can sometimes have poor concision.  I'd argue that for some algorithms, conventional mathematical notation loses out to Haskell (unless your definition of math includes all of Haskell, in which case ok)
18:53:22 <idev> by 'math', I'm only referring to discrete-math/probability/linera-algebra/statistics
18:54:26 <mgsloan> For example, "product", "sum", "map" can be quite a lot more concise than using indices in sigma sums or pi products (normal math, not type theory) 
18:56:12 <mgsloan> Especially if you are encoding that stuff in latex XD XD
18:57:34 <glguy> idev: If you find APL interesting you might find J even more interesting http://www.jsoftware.com/
19:05:20 <koz_> Yay, benchmarks written!
19:05:28 <koz_> Now to figure out wtf the results mean...
19:05:42 <Cale> Here's an example... In APL, you can write something like (2=+⌿0=(⍳X)∘.|⍳X)/⍳X←100 to compute the primes less than 100. The same computation in Haskell might look something like
19:05:50 <Cale> > (\xs -> [x | x <- xs, sum [fromEnum (mod x y == 0) | y <- xs] == 2]) [1..100]
19:05:51 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
19:06:33 <koz_> Cale: That APL is ... really ugly.
19:06:57 <hpc> it's okay, the algorithm is ugly too
19:09:06 <koz_> Could someone tell me how to pass the '--output foo.html' argument to criterion being called via 'cabal bench'?
19:13:10 <Cale> Well, to be fair, you'd probably prefer not to do the sum also
19:13:36 <Cale> > (\xs -> [x | x <- xs, length [y | y <- xs, mod x y == 0] == 2]) [1..100]
19:13:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
19:13:46 <Cale> and now the list comprehensions are just filters
19:14:20 <koz_> I tried to do 'cabal bench --benchmark-option="--output bench.html"', but it complained about '--output bench.html'. Help says that I should be passing a template, but I dunno what they mean by that.
19:14:25 <geekosaur> koz_, generally you need a -- to stop cabal itself from eating options (as with any gnu utility)
19:14:34 <geekosaur> oh
19:14:38 <koz_> geekosaur: --benchmark-option is a cabal thing.
19:14:49 <glguy> --output bench.html   might have been processed as a single argument
19:15:04 <glguy> what about: --output=bench.html?
19:15:09 <geekosaur> so, I think you can do that one with: cabal bench --benchmark-option=--output --benchmark-option=bench.html
19:15:19 <geekosaur> or maybe with = instead of space, yeh
19:16:01 <koz_> I'll give both a try.
19:16:31 <koz_> geekosaur: Thanks, that worked!
19:18:16 <koz_> geekosaur: Is there a way to 'burn in' those options when calling 'cabal bench'? Like, something I could add to the .cabal file?
19:20:25 <geekosaur> doesn't look like it
19:20:43 <koz_> geekosaur: Sadface.
19:20:47 <koz_> Oh well.
19:28:15 <nisstyre> So are there any Haskell web servers compatible with uwsgi?
20:08:11 * hackagebot clafer 0.4.4 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.4 (mantkiew)
20:16:16 <Zemyla> You know, the fact that liftEq uses a and b for parametricity, rather than just a, means that it can be used on Coyoneda-encoded functors without requiring a Functor instance.
20:18:12 * hackagebot claferIG 0.4.4 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.4 (mantkiew)
20:21:44 <athan> bitemyapp: That's extremely badass, compile-time IO
20:21:55 <athan> I've got a friend trying to make a yml file or something with Servent types
20:33:12 * hackagebot claferwiki 0.4.4 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.4 (mantkiew)
20:36:48 <xaviergmail> So umm, if every function is supposed to return the same result given the same input.. How do you handle I/O such as checking if a file exists? 
20:37:05 <glguy> xaviergmail: functions don't do IO
20:37:14 <glguy> They return actions that you can execute
20:37:41 <glguy> let sayHello = putStrLn "Hello" in hello >> hello
20:37:58 <glguy> applying putStrLn to "Hello" isn't printing anything, it's making an action
20:38:16 <glguy> the result of that expression is an action that executes sayHello twice
20:39:23 <glguy> You build up actions like this into a single action and call it main, executing your program causes that action to execute
20:41:11 <glguy> 07let sayHello 07= putStrLn 04"Hello" 07in return ()
20:41:26 <glguy> this makes an action that does nothing
20:41:44 <glguy> even though we applied putStrLn to "Hello"
20:41:58 <xaviergmail> hmm, haven't learned in & >> yet, but I was just wondering how (an action I presume?) could handle creating a configuration file if it doesn't exist then returning some data structure from that config file
20:42:17 <pikajude> so i looked into unexceptionalio this morning. it seems like it's not designed to be used in a monad transformer stack
20:42:30 <xaviergmail> I think I'll hold that thought until I read through the section on IO :P
20:42:34 <pikajude> because there are no Unexceptional m => Unexceptional (ReaderT r m) instances
20:42:47 <pikajude> have I misunderstood the point of that package?
20:43:01 <glguy> xaviergmail: If you have an action that loads a configuration file then it would either have a type like:  IO (Maybe ConfigurationFile)
20:43:02 <Koterpillar> pikajude: can you write those?
20:43:13 <pikajude> Koterpillar: well, sure
20:43:16 <glguy> or it might use exceptions in the case of failure
20:43:18 <benzrf> do you unerstand how IO is done in haskell, xaviergmail
20:43:21 <glguy> IO ConfigurationFile
20:43:22 <pikajude> but I'm used to them being bundled with, and it worries me that they aren't
20:43:36 <Cale> xaviergmail: There is a type IO a whose values are descriptions of actions to be executed. Execution of IO actions (carrying out the steps they describe) is a separate process from evaluation of expressions (reducing expressions to values largely for the sake of pattern matching).
20:43:37 <glguy> xaviergmail: No that these things aren't functions
20:43:40 <glguy> note that*
20:44:28 <mgsloan> pikajude: It'd be the base of your transformer stack.
20:44:29 <xaviergmail> not yet benzrf, was just a thought to help me understand this no side-effect dealio
20:44:45 <xaviergmail> glguy: Cale: Ah that clears things up slightly :)
20:44:46 <Cale> So, you can write IO actions which describe any effect that you like -- reading and writing configuration files, talking over the network, dealing with user input and writing to the terminal or opening GUIs...
20:44:47 <pikajude> mgsloan: so FooT (BarT (BazT UIO)) a
20:45:11 <mgsloan> pikajude: I have my own WIP library that does something similar.  Could potentially write something that did this via a transformer and depended on MonadBaseControl IO or similar
20:45:16 <pikajude> in which case, I'd need to write instances for FooT, BarT, and BazT
20:45:31 <xaviergmail> Sounds exciting!
20:45:54 <Cale> xaviergmail: IO actions have "results" -- a value of type IO t will return a value of type t whenever it is executed, provided that it terminates normally and doesn't e.g. go into an infinite loop or throw an exception.
20:46:16 <Cale> But a value of type IO t doesn't "contain" a value of type t any more than /bin/ls contains a list of the files in your home directory.
20:46:25 <benzrf> xaviergmail: practically speaking, you can think of it as being like - you can write a pure expression that says a thing to do, and gives a pure callback function
20:46:38 <Cale> (just to prevent a common misconception among beginners)
20:46:45 <mgsloan> pikajude: Yeah, but that's normal for when you want to use a class with transformers like that
20:46:55 <benzrf> xaviergmail: then the callback function takes the result of doing the thing, and, purely, computes what the next action and callback should be
20:46:58 <pikajude> mgsloan: I know, I'm just used to them being defined already, so it makes me think there's a reason they aren't
20:47:03 <mgsloan> I guess unexceptionalio author didn't want to give transformer instances
20:47:07 <pikajude> but I'm guessing it's because whoever wrote unexceptionalio doesn't want to depend on 15 packages
20:47:08 <benzrf> xaviergmail: it turns out that monads capture that kind of interface perfectly
20:47:11 <pikajude> which is fine
20:47:31 <mgsloan> Something like that might be the reasoning, or the author never used it in that context and so never realized they were missing
20:48:21 <EvanR> if you execute an IO t to try and get a t, it may throw an IO exception, go into an infinite loop, or just never complete for whatever reason 
20:48:24 <benzrf> xaviergmail: so IO is "driven" by stuff outside of your code, and calls into your code to figure out what to do - kind of.
20:48:32 <EvanR> the real world may not want to give you any result
20:48:44 <Koterpillar> or a different result each time
20:48:47 <benzrf> your code is pure, but it gets used by an impure system
20:48:59 <xaviergmail> great analogy
20:49:00 <Cale> I wouldn't think of values of type IO t as being callbacks...
20:49:13 <benzrf> Cale: i wasn't sticking to the actual api
20:49:46 <Cale> We could, for example, have a mock version of the IO type which looked something like:
20:51:00 <Cale> data IO a = Return a | PutChar Char (IO a) | GetChar (Char -> IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
20:51:12 <benzrf> wait, actually -
20:51:41 <Cale> i.e. each constructor describes the first thing which ought to be done, and most will contain some additional action to be performed after
20:52:08 <Cale> (which may be a function of whatever the result of that action is)
20:52:34 <benzrf> if an `Action a' consists of a "primitive" action - so Action itself is not a Monad - then you could define IO like `newtype IO a = IO (Action a, a -> IO b)'
20:52:40 <benzrf> which is the version i was describing
20:52:42 <Cale> and then e.g.  getChar = GetChar Return,  putChar c = PutChar c (Return ())
20:52:58 <xaviergmail> Oi my router
20:53:17 <xaviergmail> what did I miss
20:53:23 <benzrf> xaviergmail: not much :)
20:53:27 <Cale> We could, for example, have a mock version of the IO type which looked something like:
20:53:29 <Cale> data IO a = Return a | PutChar Char (IO a) | GetChar (Char -> IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
20:53:58 <benzrf> oh, i thought that was aimed more at me
20:54:28 <Cale> e.g. PutChar 'c' (PutChar 'a' (PutChar 't' (Return ()) would be the representation for an action that printed "cat" to the terminal
20:54:51 <Cale> and produced an empty tuple as its result
20:55:00 <Cale> Of course, the real IO type in Haskell is abstract
20:55:15 <Cale> and we have more sophisticated ways to glue IO actions together than this would suggest
20:55:24 <benzrf> oh wait crud, i miswrote - swap a and b there
20:55:29 <benzrf> i guess that involves an existential type
20:55:38 <Cale> yeah
20:56:32 <benzrf> existential types broke my brain for way too long
20:57:32 <benzrf> in retrospect i think the issue may have been that i was thinking of types as uniquely corresponding to the structure of values
20:57:50 <Cale> xaviergmail: Hopefully that makes it clear that *evaluating* an IO action doesn't do a whole lot -- it's just going to work out which data constructor the IO action is built with, causing no effects at all. (to continue the /bin/ls analogy, if you open /bin/ls in a hex editor to look at it, it doesn't cause it to be executed)
20:57:58 <benzrf> and of course you can't point to which structure of value produces an existential type
20:58:35 <Cale> xaviergmail: In the end, you define main to be one of these IO actions, and in a compiled program, it's what gets executed (and in turn, it'll be built up from other simpler IO actions)
20:58:43 <benzrf> Cale: i think the better continued analogy might be that *compiling* ls doesnt cause it to be executed
20:58:56 <Cale> yeah, that's perhaps better
20:59:14 <Cale> :t getLine
20:59:15 <lambdabot> IO String
20:59:19 <Cale> :t putStrLn
20:59:20 <lambdabot> String -> IO ()
20:59:31 <EvanR> the C preprocessor doesnt cause the C code to do anything
20:59:39 <EvanR> it just outputs other C code
20:59:53 <Cale> So, here, putStrLn is a function which constructs the IO action that, when executed, prints a particular String to the terminal
20:59:53 <EvanR> haskell is like C preprocessor on acid
21:00:08 <Cale> Given the same String, it will always produce the same description of what to do
21:00:19 <Cale> Similarly, getLine is a constant
21:00:32 <Cale> It's an IO action which will get a line of text from the user when executed
21:01:16 <Cale> But each time it's executed, it will produce a different String (due to the capriciousness of a typical user)
21:01:18 <benzrf> EvanR:
21:01:27 <benzrf> @google conal c preprocessor
21:01:39 <EvanR> yes C is a purely functional language ;)
21:01:50 <benzrf> oh huh, i guess @google was taken out
21:02:00 <EvanR> @where conal C preprocessor
21:02:12 <benzrf> who nerfed lambdabot D:
21:02:17 <lambdabot> Plugin `search' failed with: <<timeout>>
21:02:21 <benzrf> o wow
21:02:36 <EvanR> denial of service time
21:02:49 <bloodwire> damn can this be possible: num = [0..9999999999999999]?
21:03:11 <EvanR> > [0..9999999999999999]
21:03:12 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:03:14 <EvanR> works
21:03:28 <benzrf> bloodwire: why not?
21:03:43 <hk238> I heard google closed their API or something like that
21:04:03 <bloodwire> Thats alot lol 
21:04:09 <Cale> bloodwire: [0..] is even more
21:04:10 <hk238> Dunno about that, anyone following the British elections? Im not either :D
21:04:13 <EvanR> > [0..]
21:04:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:04:40 <xaviergmail> Is that part of the lazy evaluation I've been reading about?
21:04:41 <EvanR> > compare [0..9999999999999999] [0..]
21:04:45 <lambdabot>  mueval-core: Time limit exceeded
21:05:21 <EvanR> > compare [0..999] [0..]
21:05:22 <lambdabot>  LT
21:05:23 <Cale> xaviergmail: Well, yeah, the ability to work with infinitely long lists is due to lazy evaluation
21:05:26 <xaviergmail> as in indices in [0..] are only generated when accessed? 
21:05:30 <Cale> yep
21:05:33 <xaviergmail> nice
21:05:50 <Cale> For this reason, lists become more like a control structure than a data structure in Haskell
21:05:56 <EvanR> > compare [1..] [0..]
21:05:57 <Cale> They're effectively our loops
21:05:57 <lambdabot>  GT
21:06:01 <EvanR> > compare [0..] [1..]
21:06:03 <lambdabot>  LT
21:06:05 <EvanR> > compare [0..] [0..]
21:06:09 <lambdabot>  mueval-core: Time limit exceeded
21:06:17 <EvanR> its busted!
21:06:23 <Cale> EvanR: you know, lambdabot will respond to PMs
21:06:24 <EvanR> >:D
21:06:53 <Cale> Of course, comparing equal infinite lists for equality will take forever, because you'll just keep looking for a difference.
21:06:55 <EvanR> i figured comparing sizes of lists is instructive for xaviergmail 
21:07:39 <bloodwire> even = [2,4..950]
21:07:58 <xaviergmail> Wait, that's a thing?
21:08:07 <EvanR> > [0,2..]
21:08:08 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
21:08:11 <xaviergmail> woah
21:08:26 <EvanR> these notations are all syntactic sugar for the Enum operations
21:08:29 <EvanR> :t enumFrom
21:08:31 <lambdabot> Enum a => a -> [a]
21:08:44 <EvanR> :t enumFromTo
21:08:45 <lambdabot> Enum a => a -> a -> [a]
21:08:47 <EvanR> etc
21:08:53 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
21:08:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:09:00 <Cale> ^^ infinite list of primes
21:09:18 <hk238> when you as a person look at the string, you sort of interpret it the same way too. I think you cna easily miss some number, as you'll construct the rule which the numbers follow, and therefore skip reading it accurately
21:09:19 <hk238> :D
21:09:21 <EvanR> assuming there are infinite primes ;)
21:10:09 <roboguy`> that's been proven by Euclid
21:10:15 <Cale> > nubBy(((>1).).gcd)[2..] -- heavily golfed inefficient list of primes
21:10:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:10:20 <hk238> or so I thought.. nevermind gotta get going soon too :d
21:10:53 <hk238> oh 
21:12:01 <xaviergmail> :O
21:12:02 <hk238> hmm but that's also a counter-example to what I just said, as in `constructing a rule` implies you'll be able to figure out somekind of a function, where as it's more like having an idea of what to expect :d 
21:12:14 <hk238> well I guess I didnt mean that either
21:12:24 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:12:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:12:45 <Cale> > fix ((0:) . scanl (+) 1)
21:12:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:13:15 <hk238> what's scanl?
21:13:33 <Axman6> > scanl f x [1,2,3,4] :: [Expr]
21:13:35 <lambdabot>  [x,f x 1,f (f x 1) 2,f (f (f x 1) 2) 3,f (f (f (f x 1) 2) 3) 4]
21:13:45 <bloodwire> oo, I see, to do the odds, gotta put the comma odds = [3,5,39]
21:13:49 <Axman6> @src scanl
21:13:49 <lambdabot> scanl f q ls = q : case ls of
21:13:49 <lambdabot>     []   -> []
21:13:49 <lambdabot>     x:xs -> scanl f (f q x) xs
21:14:06 <bloodwire> [3,5..39]*
21:14:06 <Axman6> bloodwire: that's just a list of three odd numbers
21:14:11 <Cale> bloodwire: [3,5..39] might be more interesting
21:14:14 <Koterpillar> :t f
21:14:15 <lambdabot> FromExpr a => a
21:15:32 <Cale> > scanl (+) 0 [1,20,300,4000,50000]
21:15:34 <lambdabot>  [0,1,21,321,4321,54321]
21:15:58 <Cale> > foldl (+) 0 [1,20,300,4000,50000]
21:15:59 <lambdabot>  54321
21:17:08 <Cale> Unlike foldl, scanl works perfectly fine on infinite lists
21:19:01 <rrradical> Is there any setup of ghc-mod or hdevtools that works with a multi-package stack project?
21:34:35 <elucidata> what is the best haskell IDE? Is Leksah ready for prime time?
21:35:53 <benzrf> best use of scanl:
21:35:55 <benzrf> > fix$scanl(+)0.(1:)
21:35:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:35:58 <Cale> elucidata: It looks reasonable, but personally, I just recommend using whatever text editor you like best, alongside ghci running in a separate terminal window
21:38:39 <elucidata> well I'm coming to haskell from enterprise java, im quite addicted to having a fully featured IDE 
21:39:00 <glguy> You'll recover
21:40:38 <Axman6> you're out of luck then elucidata 
21:41:26 <elucidata> I find it hard to imagine Facebook et. al. adopting Haskell without a robust DE available
21:41:34 <elucidata> how do they manage large projects
21:41:48 <dmj`> elucidata: emacs can do enterprise, haskell-mode is very good, check out atom too if you're into guis
21:41:49 <lambda-11235> benzrf: lambda-fix$scanl(+)0.(1:)
21:42:05 <Koterpillar> I don't see how IDEs help managing complexity
21:43:18 <EvanR> i need an integrated environment to manage the complexity of IDEs
21:43:45 <EvanR> IIDEDE
21:44:11 <elucidata> heheh
21:44:25 <elucidata> haskellers and their recursion...
21:46:54 <Cale> elucidata: Well, having a language which isn't really bad at abstraction helps a lot ;)
21:49:24 <benzrf> lambda-11235: huh?
21:49:26 <Cale> You don't need complicated text-level macros, when you have concepts inside the language to help you factor out repetitive details
21:50:30 <lambda-11235> benzrf: My nick is lambda followed by fibonacci numbers.
21:50:45 <benzrf> aaay
21:51:35 <thoughtpolice> Yeah, but rarely do I care about my editors providing code generation features, even when I write C++ (rarely). I care about them providing things like easy auto-styling, code linting, suggestion support, and project management. TBF, .cabal files being human-consumable by design helps the project management aspect.
21:52:05 <benzrf> i don't think you need an IDE for auto-styling or linting :p
21:52:25 <thoughtpolice> I can do all that with Emacs, and wire it up, but I'm an old curmudgeony bastard, so I can survive anything.
21:53:23 <thoughtpolice> benzrf: Well, it's good I didn't say you did need it in order to do that. I said I wanted it to provide things like that easily. Like, automatically, out of the box. In practice that kind of stuff is hugely useful for long-term code you have to maintain.
21:53:43 <benzrf> hm
21:54:26 <thoughtpolice> Again, I can do that with Emacs. My point is that I, at least, rarely care about "Generate the word 'class { ... }' from some templated snippet and save me 5 keystrokes" as much as "Actual things that mean you don't have to break focus outside the editor very much to keep code self consistent and readable".
21:55:33 <thoughtpolice> I've been using Visual Studio recently. I never use it to generate code or do macro stuff. But its folding abilities, things like indexing 'TODOs', autocompletion, auto formatting and linting/styling automatically during build are things I use literally every time. Those are all things that are useful for my Haskell code, too.
21:56:02 <glguy> jumping to documentation, computing types of subexpressions, inlined type errors, automated lambda lifting (Haskell-like extract method refactoring)
21:56:21 <glguy> variable renaming that knows about scoping rules, there are lots of things a worth having integrated
21:56:45 <thoughtpolice> Yep. You can make it all sort of work if you shave enough yaks, at least. Far cry from what people want though, IME.
21:56:50 <thoughtpolice> Scope-aware renaming is a big one, too.
21:58:34 <Cale> I usually don't care about stuff like autocompletion, but when you're on a project where other people are using it, eventually it makes itself important, because everyone starts using really long names.
21:58:36 <thoughtpolice> Well, or use Leksah! Which is underrated, IMO. But again, I'm a curmudgeon, something something Emacs and lisp and extensibility, etc.
22:01:22 <Rotaerk> I'm a fan of long-as-necessary names
22:01:57 <glguy> Anyone used the IntelliJ plugin?
22:02:04 <Cale> I don't tend to use a linter, though I don't really get why it would have to be part of the IDE -- I have a tendency to think a lot of the things that hlint says when I post things on lpaste are dumb, so I wouldn't want them being applied automatically for sure.
22:02:37 <Cale> Being able to see the types of subexpressions would be nice
22:02:55 <lambda-11235> I'm loading a haskell file in emacs, but nothing is happening. Any ideas?
22:03:00 <thoughtpolice> I turn off tons of HLint stuff too, some just aren't useful.
22:03:03 <Cale> also, being able to see a heatmap of profiling data
22:03:21 <glguy> hlint use leads to the accumulation of annotations to turn off hlint stuff
22:03:22 <dmj`> using yasnippet for haskell module imports is nice too
22:04:21 <xaviergmail> Are there any cool vim plugins that a beginner like me could use ? Perhaps a linter would be nice, I would consider auto completion to be detrimental at this stage however
22:05:41 * xaviergmail didn't really read more than 2 lines above before asking his question
22:05:58 <Koterpillar> xaviergmail: syntastic uses haskell linters by default
22:08:49 <xaviergmail> Yeah syntastic seems to pop up quite often, just need to check if I can use it as my one and only linter for every other language because right now I have too many and it's a mess
22:21:07 <elucidata> <glguy> Anyone used the IntelliJ plugin?
22:21:25 <elucidata> I'm abandoning JetBrains-anything
22:21:50 <elucidata> they lost me as a customer when they started moving to turning their IDEs into SaaS garbage
22:21:53 <elucidata> fuck them
22:23:02 <elucidata> Right now, if you buy one of their products on an annual subscription, you get 12 months of updates, and then at the end of your subscription your IDE reverts to the version it was the day you bought it
22:23:13 <elucidata> can you imagine that?
22:24:00 <elucidata> you start using some features they introduced 8 months into your sub, then 4 months later, if you don't hand over more money, those features get ripped out of your IDE and you revert to a version 12 months ago
22:24:23 <elucidata> JetBrains can choke on their own vomit for all I care, and I was a customer for 8 years
22:24:54 <elucidata> never going to give them money ever again
23:20:38 <reqq456> why is this not possible? http://sprunge.us/dRYE
23:21:11 <glguy> reqq456: To parse a Maybe Int you'd need: "Nothing" or "Just 1"
23:21:35 <glguy> If you want to encode parse failure as a Maybe you can use Text.Read.readMaybe
23:21:39 <glguy> :t Text.Read
23:21:40 <glguy> .readMaybe
23:21:40 <lambdabot> Not in scope: data constructor ‘Text.Read’
23:21:44 <glguy> :t Text.Read.readMaybe
23:21:45 <lambdabot> Read a => String -> Maybe a
23:24:58 <reqq456> ah thanks!
23:24:58 <Sinestro> This is just me being dumb, probably, but is there a way to see the way that Stack is actually invoking ghc when I build my project? I'm on GHC 8 and I have -g in my cabal file, but there's no DWARF info in my executables.
23:26:05 <Koterpillar> Sinestro: sledgehammer solution: strace -f -e trace=process stack ...
23:30:10 <codebje> Sinestro: stack build -v
23:34:23 <Sinestro> codebje: it's not doing it directly, at least
23:36:16 <mgsloan> Sinestro: --cabal-verbose
23:37:31 <mgsloan> You need to use --disable-executable-stripping
23:37:53 <mgsloan> But that's a Cabal option, gotta add it to stack - https://github.com/commercialhaskell/stack/issues/1342
23:41:02 <slingamn> i can't `cabal install alex`: https://gist.github.com/slingamn/5a5335573a6a9b1509f8cc94331daf48
23:53:03 <glguy> Slingamn: what version of the are you using?
23:53:13 <slingamn> of what, sorry?
23:53:37 <slingamn> "cabal-install version 1.24.0.0"
23:53:45 <slingamn> "The Glorious Glasgow Haskell Compilation System, version 7.8.4"
23:54:36 <slingamn> i bootstrapped with `dnf install cabal-install` (this is on fedora), then `cabal install cabal-install`, then `~/.cabal/bin/cabal install alex`
23:57:12 <glguy> What does ghc-pkg list template-haskell 
23:57:18 <glguy> Say?
23:58:15 <slingamn> template-haskell-2.11.0.0
23:59:45 <glguy> It's says more lines than that
