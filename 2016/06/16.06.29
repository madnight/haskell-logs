00:05:59 <angerman> glguy, monochrom, sorry for the dealy: http://lpaste.net/8815081991746617344
00:07:40 * hackagebot Delta-Lambda 0.2.0.0 - A demonstration interpreter for type system delta-lambda (of N.G. De-bruijn)  https://hackage.haskell.org/package/Delta-Lambda-0.2.0.0 (listofoptions)
00:07:40 * hackagebot LambdaCalculator 0.2 - A basic lambda calculator with beta reduction and a REPL  https://hackage.haskell.org/package/LambdaCalculator-0.2 (ThomasDuBuisson)
00:07:48 <dysfun> hrm, i've added binary to my build-depends but trying to build tells me the binary package is hidden?
00:08:42 <dysfun> i'm trying to add to Binary constraint to a function
00:12:55 <quchen> Hidden means the function you're using is there (via transitive dependency), but you haven't explicitly declared it as a dependency.
00:17:51 <Squarism> Someone said a cofree monad could be used to turn a [(<parentId>,<childId>)] into a tree. Im curious to see this - wo spending alot of time! =D
00:18:16 <Clint> coffee monad
00:18:33 <Squarism> or is it just that Cofree is a tree?
00:19:56 <dibblego> Tree is a comonad, so is Cofree. Tree can be written in terms of Free.
00:21:28 <dibblego> type Tree a = Cofree [] a -- also
00:21:51 <Squarism> ok
00:22:48 <Axman6> is Cofree Maybe a ~ [a]?
00:29:03 <quchen> Axman6: There's no Nil
00:29:29 <quchen> Cofree Maybe a = a :< Maybe (Cofree Maybe a)
00:29:33 <quchen> So it's NonEmpty a
00:30:26 <Axman6> ah right
00:30:54 <Axman6> I hadn't seen the definition of Cofree. I assume it's Cofree f a = a :< f (Cofree f a)?
00:31:01 <quchen> Yes
00:31:07 <quchen> http://hackage.haskell.org/package/free-4.12.4/docs/src/Control-Comonad-Cofree.html#Cofree
00:42:40 * angerman wonders if it's really that uncommon that one would want to squash a monad in a monad stack.
00:45:20 <dysfun> quchen: there was some odd cacheing thing going on. it says Data.Binary.Class is a hidden module
00:45:56 <dysfun> as it happens, it needs to be Typeable too, so I can just make it serializable, but it raises the question of how do you actually use it if it's hidden?
00:46:24 <quchen> Hidden modules can't be used
00:46:43 <quchen> Maybe your definition is exposed from a userland module?
00:48:00 <dysfun> possibly
00:50:40 <quchen> dysfun: What are you trying to do anyway?
00:51:30 <dysfun> i'm playing with cloud haskell and the error messages guided me to putting on Binary and Typeable constraints. but flicking through the docs, Serializable implies both
00:53:44 <osa1> uh I'm having an annoying cabal bug.. cabal install hangs
00:55:25 <osa1> I don't understand why cabal update is taking forever. it's just downloading and parsing an index file, right?
00:56:10 <quchen> osa1: Which Cabal version?
00:56:16 <quchen> The old ones used to be terribly slow
00:56:18 <osa1> 1.24.0
00:56:24 <osa1> new versions are slow too
00:56:29 <osa1> or maybe I should say
00:56:40 <osa1> slow if it's doing what I think it's doing ;-)
00:56:42 <quchen> Took around 10 seconds here
00:57:06 <osa1> how long does it take if you download the index manually?
00:57:26 <quchen> How?
01:00:25 <seivan_> Why isn't https://github.com/orenbenkiki/yamlreference/blob/master/Text/Yaml/Reference.hs using parsec?
01:02:16 <osa1> quchen: I don't know yet but I'll try once I figure out what it's downloading.
01:04:17 <quchen> seivan_: Parsec doesn't allow incremental parsing, maybe that's one of the reasons.
01:07:19 <quchen> Apart from that, Parsec is pretty dated.
01:07:19 <Axman6> it's quite surprising it's not using some kind of parser combinator though
01:07:27 <tsahyt> what would be the best resource to learn about the GHC GC? Is there a paper about it?
01:08:06 <dysfun> what do you want to know? it's currently a stop the world system
01:08:22 <tsahyt> dysfun: what is this whole generational thing for example
01:08:35 <tsahyt> and what does "bytes copied" really denote. why is anything getting copied
01:09:02 <quchen> tsahyt: It's a generational copying parallel collector, and yes, there's information about that somewhere, hold on.
01:09:23 <dysfun> i recommend starting with wikipedia's page on Generational Garbage Collection
01:09:32 <seivan_> quchen: What? Dated? I thought it was new?
01:09:38 <seivan_> quchen: What is Parsec replaced with?
01:09:40 <osa1> tsahyt: for those concepts you can just read any GC resource really
01:09:41 <tsahyt> seivan_: Megaparsec
01:09:49 <seivan_> quchen: What does incremental parsing mean?
01:09:54 <quchen> dysfun: http://community.haskell.org/~simonmar/bib/parallel-gc-08_abstract.html
01:09:56 <osa1> tsahyt: generational, compaction, copying etc. are standard terms in GC literature
01:10:00 <tsahyt> osa1: Is there anything that is specific to GHC then?
01:10:11 <seivan_> tsahyt: Really? It's actually replaced Parsec? Looks the same.
01:10:26 <osa1> tsahyt: GHC wiki
01:10:27 <tsahyt> seivan_: Megaparsec is newer and imo nicer to use
01:10:48 <osa1> tsahyt: check this page as first thing to do when you wonder something about GHC https://ghc.haskell.org/trac/ghc/wiki/TitleIndex
01:10:53 <seivan_> tsahyt: Ah.. it's a taste thing? Or is it genuinly better?
01:11:02 <dysfun> tsahyt: this was a very good read btw https://simonmar.github.io/posts/2015-07-28-optimising-garbage-collection-overhead-in-sigma.html
01:11:07 <osa1> tsahyt: see Storage section in the index
01:11:19 <Axman6> trifecta and the parsers package make for really nice parser writing
01:11:24 <tsahyt> seivan_: genuiniely better. Parsec's lexer functionality was really unwieldy for example. Megaparsec is a lot more flexible in that regard
01:11:29 <Axman6> you get a lof of things for free which is nice
01:11:43 <seivan_> trifecta?
01:11:49 <seivan_> I like the Parsec *concept* more than Parsec
01:11:51 <seivan_> which is why I am porting it.
01:11:58 <seivan_> The high level functions are really easy to combine
01:12:01 <tsahyt> dysfun: this looks great, as I'm really fighting GC overhead myself here.
01:12:02 <Axman6> perting it to what?
01:12:10 <Axman6> porting*
01:12:11 <quchen> Trifecta and the Parsers package are really nice when you've learned to use them, but the documentation is terrible, so learning to use it is an awful experience.
01:12:21 <seivan_> Axman6: Swift
01:12:40 <seivan_> Apart form Megaparsec, are there other newer Parsec-likes I should look at?
01:12:42 <dysfun> quchen: yup. 100%. Why i'm still using attoparsec
01:12:43 <seivan_> I actually thought Parsec was new
01:12:46 <seivan_> Attoparsec..
01:12:53 <quchen> I recommend merijn's "lambda-except" source code as an introduction. It's the best resource I've seen so far. Not to say that it's good as an introduction, it's just not as bad as the alternatives.
01:13:01 <Axman6> quchen: the docs for parsers aren't too bad, and you don't really need any trifecta specific docs once you understand parsers
01:13:02 <tdammers> I wrote a parser-combinator lib in clojure at some point... it was a lot harder than it would have been in Haskell, and it ended up less robust, too
01:13:05 <dysfun> attoparsec is fast, does most of what parsec does
01:13:22 <dysfun> tdammers: yes, i found writing a parser in clojure tedious
01:13:25 <quchen> Axman6: You need Trifecta docs when you want to use the nice things Trifecta offers though.
01:13:29 <seivan_> Speed is not the issue
01:13:36 <seivan_> Just want to offer a nice API that's "standardized"
01:13:54 <Axman6> quchen: like what? parsers covered most of what I wanted
01:13:58 <quchen> Took me ages to implement the STGi parser with Trifecta.
01:14:02 <dysfun> well trifecta is very cool
01:14:03 <tdammers> dysfun: yes, and none of the popular libraries are anywhere near as nice as any of the big Haskell ones
01:14:04 <seivan_> Ok
01:14:08 <seivan_> So MegaParsec replaces Parsec? 
01:14:12 <quchen> Axman6: Pretty error messages with colours, for example.
01:14:14 <seivan_> Are both part of STD or?
01:14:16 <quchen> Understanding Delta.
01:14:19 <quchen> And all of that.
01:14:23 <Axman6> MegaParsec is an alternative to PArsec
01:14:35 <seivan_> Is there anthing like http://www.grammaticalframework.org/~hallgren/gf-experiment/browse/pfe.cgi?Text.ParserCombinators.Parsec.Pos for MegaParsec?
01:14:44 <Axman6> quchen: you get a lot of the highlighted error messages by default
01:15:08 <quchen> Axman6: Sure, but in order to understand how to influence that … eww.
01:15:19 <Axman6> yeah, that's true.
01:15:53 <Axman6> my usage was for parsing really strange CSVs which cassava wasn't really well suited for
01:15:56 <dysfun> tdammers: the least bad of the lot was parse-ez imo. it's never going to compete with haskell (which i think many people treat as a DSL for compiler-writing), but it wasn't awful
01:15:57 <tdammers> hmm, just reading up on megaparsec... I like how they use type families instead of multiparam typeclasses to model the stream/token relationship
01:16:23 <tdammers> dysfun: yeah, well, the state of the clojure parser ecosystem is why I wrote my own library
01:16:39 <tdammers> dysfun: it ended up pretty OK, but the dynamic nature of the language made it error prone
01:16:59 <quchen> flexible*
01:17:04 <dysfun> yeah, parsers are an area where types really shine
01:17:42 <Axman6> that yaml implementation is really strange
01:18:14 <tdammers> I've written parser-combinator stuff in many languages, but in every one of them except haskell, I had to make severe concessions, typically of the "model parsing failures as returning NULL, and then do the monadic combinator stuff ad-hoc" type
01:20:13 <thimoteus> ew
01:21:13 <tdammers> indeed
01:21:19 <tdammers> but the alternatives are equally ew
01:21:27 <tdammers> "implement your own monad library"
01:21:31 <seivan_> Hmm, MegaParsec has a different Error, State, Reply and Consumer
01:21:35 <dysfun> well parse-ez uses exceptions :)
01:21:36 <tdammers> "use exceptions to signal parsing failures"
01:21:40 <tdammers> :D
01:22:12 <tdammers> it's just super convenient to be able to leverage the type system to make the distinction between "this is a no-parse", "this is a successful parse that returns nothing", and "something went wrong"
01:22:13 <dysfun> srsly, can we just get maybe and either into every language now please?
01:22:37 <tdammers> it's not just maybe and either; many languages now have them, including C++
01:22:51 <dysfun> yup, i've been writing c++14 recently
01:22:55 <tdammers> but most languages don't have Functor / Applicative / Monad abstractions to go with them
01:23:19 <dysfun> baby steps. first we have to get people to abandon null
01:23:27 <tdammers> sure
01:24:01 <tdammers> actually, I don't really have a problem with a parser returning null in something like Clojure
01:24:09 <Axman6> seivan_: I'll be interested to see if Swift is flexible enough to be let you implement a decent parser cominator library without too much noise - I'm not convinced it can
01:24:31 <rydgel> I've got nullPtr nightmares
01:24:35 <dysfun> tdammers: well clojure has a lot of monoidal behaviour
01:24:55 <tdammers> dysfun: clojure has a lot of monad-like abstractions, but they're not unified in a generalized monad interface
01:25:15 <seivan_> Axman6: I'll let you know.
01:25:30 <seivan_> Axman6: Now I am stuck trying to map Parsec stuff to MegaParsec as they seem to have changed name and interface
01:25:33 <dysfun> tdammers: no, but clojure is a very different language and i think adding monads to it would destroy it
01:25:47 <seivan_> Where can I find Reply and Consumed documentation for MegaParsec?
01:26:07 <dysfun> tdammers: out of interest, have you ever been successful with one of the monad frameworks for clojure?
01:26:09 <tdammers> dysfun: not destroy; more like, monads turn out to be not very helpful in a language where everything is basically in RWST ExceptT IO already
01:26:23 <tdammers> I've never bothered with the monad frameworks
01:26:27 <tdammers> brb, standup
01:26:27 <dysfun> well i hated them
01:27:12 <Axman6> tdammers: RWST Any Any Any (ExceptT IO)?
01:27:33 <Axman6> uh, ExceptT Any IO, just for extra fun
01:29:05 <Axman6> seivan_: don't get too bogged down in the details, I would try and make something that work, and then add more advanced features later - if your combinators are well designed (which they mostly should be if you follow things like Parsec), you won't have to change code in too many places when you add things like location tracking
01:29:38 <Axman6> what works in Haskell is unlikely to work the same in Swift, particularly given the limitations reference counting place on you, even if it's automatic
01:29:55 <rydgel> does Swift have HKT?
01:30:00 <dibblego> No.
01:30:08 <seivan_> Axman6: Ugh? reference counting?
01:30:11 <rydgel> So how can you do monads?
01:30:12 <seivan_> Axman6: I am using valeu types, not classes
01:30:21 <Axman6> that probably help a lot then
01:30:28 <dibblego> rydgel: copy and paste
01:30:28 <seivan_> Axman6: (stack, not heap)
01:30:33 <seivan_> Axman6: Not sure that should matter
01:30:36 <rydgel> dibblego: I see
01:31:15 <Axman6> rydgel: you basically miss out on being able to write generic functions like mapM, and need to implement them for all your monad implementations
01:31:44 <dibblego> see functionaljava and xsharpx for examples of "copy/paste because no HKT"
01:32:59 <rydgel> indeed
01:33:14 <rydgel> still better than nothing I guess
01:35:08 <seivan_> Inside ErrorItem
01:35:11 <seivan_> Is that what Parsec calls Message?
01:35:23 <seivan_> It seems to have new properties, like Tokens, Label and EndOfInput?
01:40:28 <tdammers> Axman6: something like that, yes
01:40:41 <tdammers> but it's actually worse than that, because of live reloading
01:41:31 <tdammers> clojure allows you to do stuff like pass a function to another function, then reload the namespace that defines it; now you have the running code hold a reference to the old version, and any new code receive a reference to the new one
01:41:37 <tdammers> omfg
01:42:17 <tdammers> and if that's not bad enough already, you can also reload a namespace such that the new version no longer contains a certain function, which leads to the old version remaining in scope
01:42:56 <tdammers> things that depend on said function, even if they have been added in the new version of the namespace, will keep working until you stop and restart the program from scratch; only then will they notice that the function is no longer there
01:44:17 <quchen> Sounds like hot-swapping with a required restart.
01:45:00 <seivan_> What is Dec? 
01:45:48 <tsahyt> what's the cleanest way to require an additional library in a cabal file when some specified flag is true?
01:46:00 <tsahyt> I suppose I could duplicate the whole build-depends field but that seems rather messy
01:46:15 <dysfun> tdammers: tbf, erlang does this too (but at the whole-namespace level)
01:46:36 <seivan_> What is the different between Lexer and Char stuff?
01:46:43 <seivan_> It seems like they share the same domain?
01:47:06 <tdammers> dysfun: not overly familiar with erlang, but I believe they have better isolation between modules, and you swap out entire modules rather than treating them as dictionaries where you overwrite individual keys (or not)
01:47:25 <tdammers> seivan_: Dec is the default error type
01:47:27 <tsahyt> ahh nvm, I can just write an additional build-depends into the if clause
01:48:15 <rydgel> tsahyt: yep
01:48:20 <dysfun> tdammers: correct. there are a maximum of two concurrent versions and they have a means of specifically referring to 'the new one'
01:48:32 <rydgel> tsahyt: if flag(xxx)
01:48:54 <dysfun> tdammers: however, if you write your clojure in such a way, you can have this too
01:49:04 <tdammers> dysfun: the difference, I believe, is that Erlang was designed to do these things in a super reliable and well-defined way, whereas Clojure is just a bit too far out on the "keep it simple" axis
01:49:17 <tdammers> sane defaults and all
01:49:24 <rydgel> did you guys tried Halive?
01:49:26 <tsahyt> man the hoops I jump through not to write C++. Cabal still complains at configure every time because I need to link the rts manually and it somehow doesn't like that. This prevents me from using stack and thus I'm stuck on GHC 7.8.4 :/
01:49:37 <tdammers> and yes, I know that there are ways to deal with it and do it better in clojure, but they're opt-in
01:49:46 <dysfun> tdammers: yes. the erlang vm is properly immutable, there is no mutable data at all, for a start
01:50:03 <tdammers> I really should learn me some erlang
01:50:10 <tdammers> or maybe elixir
01:50:12 <dysfun> if you want mutability, you have to call into c libraries to do it. handily erlang ships with a load that make it easy to do it right
01:50:12 <tdammers> or both
01:50:20 <dysfun> i gave up on elixir, but i've been learning LFE
01:51:42 <tdammers> seivan_: the difference between Char and Lexer is that Char is specifically about parsing at the character level, whereas Lexer is aimed at writing, well, a lexer layer on top of which you can then write lexeme-based parsers
01:53:30 <seivan_> tdammers: Sure, but they sorta have the same underlying functonality, e.g match something, return a parser to combine 
01:53:45 <seivan_> https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Error.hs#L55 is this a list of strings, or a single string? Since it's called tokens (plural)?
02:01:10 <dysfun> does anyone know if https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes made it into ghc yet?
02:03:42 <osa1> dysfun: I'm working on it, see phabricator.haskell.org/D2259
02:04:01 <dysfun> i literally found that as you said that
02:05:28 <dysfun> how's it coming along? :)
02:07:15 <osa1> the implementation has been working for 2-3 months now, but we had problems with the implementation (implementation was not simple enough, generated code was not good enough etc.)
02:07:47 <quchen> osa1: Is this what Tibbe started to build before he left?
02:07:48 <osa1> I was hoping to merge it this week, actually, but Simon requested more changes as usual :p
02:08:05 <osa1> quchen: he only wrote the parser and even that part didn't survive
02:08:24 <dysfun> "there are a very large number of changes, so older changes are hidden" -- phabricator
02:08:25 <osa1> quchen: he initiated the discussions at ICFP and wrote the proposal (wiki page)
02:13:23 <Axman6> I was just wishing today for !(Maybe Int) to be unpacked
02:14:16 <Phyx-> hmm anyone seen this error before? "InstallPlan: internal error: configured package depends on a non-library package"
02:14:25 <Phyx-> get it when installing haddock
02:18:09 <Axman6> osa1: I have't read the whole wiki page yet, but it looks like the elements of each constructor won't be overlapping? as in, the unpacked Either Int Char would use |Int|+|Char| space instead of max(|Int|,|Char|)?
02:20:29 <Axman6> ah maybe not, seems to be cleared up later on
02:20:33 <osa1> Axman6: of course they will be! otherwise it'd be super inefficient
02:20:34 <osa1> :)
02:20:56 <osa1> Axman6: I have another patch that implements unpacking !(Maybe Int) etc. it's very small patch once we have this first one
02:21:43 <Axman6> I wrote this code today, which I really wanted to be fully unpacked if possible: http://lpaste.net/688587474930237440
02:21:51 <Axman6> (Spaced is a newtype)
02:21:57 <osa1> so this patch opens up lots of opportunities for some new optimizations that could be done on sum types
02:22:07 <Axman6> excellent =)
02:23:03 <osa1> Axman6: that example is a bit more tricky. in theory we will have all the tools we need for unpacking it but you want to first unpack Maybe in Spaced which should be done in Spaced
02:23:06 <quchen> Hooray for anonymous sums
02:23:34 <Axman6> osa1: even with Spaced being a newtype?
02:23:37 <quchen> _|| is a very strange operator though
02:23:43 <quchen> Letter-then-symbol
02:23:52 <Axman6> yeah, and conflicts with (||)
02:24:03 <Axman6> well, the syntax in general may
02:24:24 <osa1> Axman6: oh it's a newtype. it should just work then.
02:24:31 <Axman6> \o/
02:24:52 <osa1> syntax actually doesn't hijack any existing syntax because (at least currently) you have to put spaces between bars. so (# x | | | #) for example
02:25:04 <Axman6> ah right
02:25:09 <osa1> if we decide to allow more compact forms like (# x ||| #) it gets tricky
02:25:18 <Axman6> that's a little gross, but understandable
02:25:23 <osa1> becuase x ||| is a section for (\y -> x ||| y)
02:25:39 <quchen> Anonymous sums, like tuples, should probably never be larger than 3 entries.
02:26:06 <Axman6> except in compiler generated code
02:27:26 <osa1> yeah so the idea is that it's for optimziation purposes only and so compiler will be introducing those as a result of {-# UNPACK #-}s or worker/wrapper transformations
02:27:54 <osa1> in the user-written code you shouldn't be seeing those a lot. exceptions are high-performance libraries written by people who know what they're doing
02:50:18 <seivan_> Why did MegaParsec remove userState?
03:01:10 <hawk78> is there a better way to do this?
03:02:05 <hawk78> http://pastebin.com/uuJHdejY
03:02:37 <hawk78> basically I want something lik      rm :: Maybe (IO a) -> IO (Maybe a)
03:04:18 <Boomerang> :t sequence
03:04:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:05:11 <hawk78> Thank you Boomerang
03:05:41 <osa1> :t mapM id
03:05:42 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
03:07:57 <DawidLoubser> What's the latest with Haskell microkernels? Is HalVM "it" or is there something else worth looking into?
03:15:23 <angerman> Why would `toHtml :: Monad m => T -> HtmlT m ()`, complain with this: Expected Type: HtmlT m (), Actual type HtmlT (State Int) () with "could not match 'm' with 'State Int', 'm' is a rigid type variable? Is State Int no Monad?
03:15:37 <tsahyt> So I've got a State + Reader monad stack over IO. According to profiling, (>>) still makes up something like 20% of allocations and time. Is this an issue with (>>) or with profiling? Is it really that expensive to chain computations together? Performance is paramount in my case, I suppose I could do away with the State in favor of an IORef but that's somewhat ugly
03:16:33 <tomjaguarpaw> angerman: Probably because your implementation is specific to State Int and is not general over all monads.
03:18:29 <angerman> tomjaguarpaw, so, my body of `toHtml` forces toHtml to require m to be State Int, but the signature requries it to be valid for all monads, and hence my implementation clashes with the type signature?
03:18:50 <tomjaguarpaw> I guess so.  I'd need to see your implementation to be sure.
03:19:11 <tomjaguarpaw> Are you using State operations in the implementation of toHtml?
03:21:34 <angerman> tomjaguarpaw: this is what I'm toying with: http://lpaste.net/5218746467094626304
03:23:04 <tomjaguarpaw> Oh right.  Yes, toHtml is required to work for all monads m, but you've required m to be State Int, so it's not going to work.
03:23:09 <angerman> tomjaguarpaw the way it is, it complains about: Could not deduce (MonadState Int m) arising from a use of ‘modify’ from the context (Monad m) bound by the type signature for toHtml :: Monad m => Item -> HtmlT m (). So I tried to be explicit on the type signature.
03:24:16 <tomjaguarpaw> angerman: You almost certainly shouldn't be writing instances of ToHtml.
03:24:34 <tomjaguarpaw> What exactly are you trying to do?
03:25:20 <angerman> I'm playing around with servant and servant-lucid.
03:25:52 <tomjaguarpaw> You almost certainly should just be writing a function.
03:25:57 <tomjaguarpaw> No need to put it in a typeclass.
03:26:19 <seivan_> Hmm
03:26:46 <seivan_> I don't quite understand how ParseError works https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Error.hs does it fill all its error properties? errorUnexpected, errorExpected or is it just one at a time?
03:26:52 <angerman> And I wanted to try to inject some state. And their sample code (http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#case-studies-servant-blaze-and-servant-lucid) uses toHtml
03:26:55 <seivan_> Also, what's ErrorComponent ? 
03:29:39 <angerman> tomjaguarpaw, not sure. Maybe I've been missguided by the tutorial.
03:30:46 <tomjaguarpaw> angerman: That's interesting.  I certainly wouldn't recommend creating your own instances, but I don't know enough to comment.  If you really want to do it though, you can't use State-specific operations.
03:35:40 <seivan_> What is apos:|z
03:36:05 <seivan_> Oh, it's an apos function
03:36:23 <tsahyt> Could I change StateT s IO a to ReaderT IO a and write a MonadState instance around IORefs in the reader without breaking any of the MonadState laws?
03:37:04 <tsahyt> wait, does MonadState even have any particular laws?
03:37:13 <quchen> No.
03:37:22 <tsahyt> fair enough, so I can't break anything that way either I suppose
03:40:50 <tsahyt> @unmtl ReaderT r IO a
03:40:50 <lambdabot> r -> IO a
03:41:02 <tsahyt> well that was predictable enough
03:45:51 <tomjaguarpaw> Surely MonadState has laws around get and put.
03:47:07 <tsahyt> tomjaguarpaw: So I thought but I can't find any. At least things like get >>= put == return () should hold I think
03:47:38 <tsahyt> :t get >>= put
03:47:40 <lambdabot> MonadState s m => m ()
03:47:53 <tomjaguarpaw> Sounds reasonable.
03:49:54 <tomjaguarpaw> Basically it should obey all the laws obeyed by State.
03:54:57 <maerwald> you sound like a monad lawyer
03:57:15 <tomjaguarpaw> In Soviet monad laws are obeyed by State.
04:04:21 <petercommand> are there monad attorneys?
04:04:55 <quchen> MonadState has no laws.
04:05:35 <quchen> I don't know why.
04:06:13 <quchen> At least I can make up laws for it (put . get = id, put/get idempotent). But what would we do for Writer?
04:06:19 <quchen> Or Reader?
04:06:25 <tsahyt> how strange, using IORefs over State makes almost no tangible difference for me
04:06:51 <tsahyt> same memory usage, virtually identical GC times and execution times
04:09:51 <maerwald> tsahyt: and IORefs are more flexible
04:10:33 <tsahyt> yes but the whole point was to see whether they perform better and it seems like they actually do not in this case
04:11:07 <maerwald> yeah, I remember someone telling me that he speeded up his own parser by rewriting it in pure State code
04:11:30 <maerwald> which then should almost be as efficient as a similar parser written in C
04:12:02 <maerwald> (which doesn't hold true for parsec/attoparsec etc)
04:19:00 <dnadams> The acid state website points out that "Another potential solution is to create a special data-structure like IxSet which stores only the keys in RAM, and uses mmap and/or enumerators to transparently read the values from disk without loading them all into RAM at once." Any code samples I can lookup?
04:20:09 <seivan_> Is Text.Parsec.Indent
04:20:13 <seivan_> and Parsec the same thing?
04:32:35 <pavonia> seivan_: Indent provides functions for parsing indentation-sensitve grammars using Parsec
04:37:10 <seivan_> pavonia: Is it built on extended version of Parsec, or a whole diff library?
04:38:13 <pavonia> It's build on Parsec
04:38:17 <pavonia> *built
04:40:21 <seivan_> pavonia: Does it modify its source in anyway, or just adds a bunch of generic parsers?
04:40:27 <seivan_> trying to find the source
04:41:13 <pavonia> It's just a new package that provides additional functions. You can look at the source by clicking on the "Source" links at the right side
04:41:35 <seivan_> pavonia: Thanks.
04:42:18 <pavonia> Right side of the Haddock docs, that is ;)
04:42:59 <seivan_> pavonia: Thanks, how do I go up to index, so I can see all files?
04:43:29 <seivan_> nevermind, found contents
04:43:55 <pavonia> Yeah, that's the main page for packages
04:44:26 <seivan_> It seems like IndentParser adds another property(?) (State SourcePos)
04:44:32 <seivan_> Why didn't it use the UserState for that?
04:47:41 <pavonia> Because the user state is for the user. It hides it's state in an additional monad layer
04:48:33 <seivan_> I see.
04:49:06 <seivan_> How would you translate that to another language.
04:49:32 <seivan_> For me, I take it my protocol (interface) would be Parsec and I'd create a Struct that conforms to it, and add the missing indentation stuff there
04:50:24 <pavonia> What is Struct?
04:52:58 * dysfun is guessing ADT was meant
04:57:02 <seivan_> pavonia: Let me rephrase it, if you were to remake Parsec, you'd include the indentation stuff from the beginning?
04:58:50 <pavonia> seivan_: You mean integrate it into the parser core or just add the functions to the library?
05:00:13 <pavonia> I don't really see a reason for the former
05:01:16 <seivan_> I am thinking if I can port the indentation lexers from https://mrkkrp.github.io/megaparsec/tutorials/switch-from-parsec-to-megaparsec.html
05:02:12 <codedmart> EvanR: Just found a good alternative to what I would like. https://stripe.com/docs/api/curl#expanding_objects
05:02:44 * hackagebot spreadsheet 0.1.3.4 - Read and write spreadsheets from and to CSV files in a lazy way  https://hackage.haskell.org/package/spreadsheet-0.1.3.4 (HenningThielemann)
05:27:35 <ccapndave> Hey Haskellers
05:28:15 <ccapndave> I'm actually not a Haskell dev, but I'm doing some development in Elm and am interested in how you would approach the problem in Haskell
05:30:13 <ccapndave> The elemIndex function takes an `a` and a `[a]`, and returns `Maybe Int`, and I have `Maybe a` and `Maybe [a]` as parameters to give to it
05:30:53 <ccapndave> In Elm you can do `Maybe.map2 elemIndex maybeElem maybeList`, but this then returns a `Maybe (Maybe Int)` and you have to use another function to flatten out the Maybes.  Is there a stylish way to do this in Haskell?
05:32:27 <hpc> @let f = undefined :: a -> [a] -> Maybe Int
05:32:28 <lambdabot>  Defined.
05:32:48 <hpc> :t f <$> (undefined :: Maybe Int) <*> (undefined :: Maybe [Int])
05:32:49 <lambdabot>     Ambiguous occurrence ‘f’
05:32:49 <lambdabot>     It could refer to either ‘L.f’,
05:32:49 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:161:1
05:32:57 <hpc> @undefine
05:32:57 <lambdabot> Undefined.
05:33:01 <hpc> @let f' = undefined :: a -> [a] -> Maybe Int
05:33:02 <lambdabot>  Defined.
05:33:05 <hpc> :t f' <$> (undefined :: Maybe Int) <*> (undefined :: Maybe [Int])
05:33:06 <lambdabot>     Ambiguous occurrence ‘f'’
05:33:06 <lambdabot>     It could refer to either ‘L.f'’,
05:33:06 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:154:1
05:33:10 <hpc> >:(
05:33:25 <hpc> ccapndave: lambdabot is being a schlub, but basically Applicative is what you probably want
05:33:30 <hpc> :t liftA2
05:33:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:33:41 <hpc> or something
05:34:02 <quchen> ?undef
05:34:02 <lambdabot> Undefined.
05:34:17 <quchen> Oh, you undefined above already.
05:34:24 <quchen> Anyway, 'f' is taken by simple-reflect.
05:34:26 <quchen> > f
05:34:28 <lambdabot>      No instance for (Show a0)
05:34:28 <lambdabot>        arising from a use of ‘show_M137993942789045172420794’
05:34:28 <lambdabot>      The type variable ‘a0’ is ambiguous
05:34:30 <quchen> :t f
05:34:31 <lambdabot> FromExpr a => a
05:34:37 <quchen> > f :: Expr
05:34:38 <lambdabot>  f
05:35:11 <hpc> :t f'
05:35:12 <lambdabot> FromExpr a => a
05:35:21 <hpc> yeah, that was what got me
05:35:43 <hpc> i knew f was taken and used it in a moment of derpiness, didn't know about f'
05:35:57 <quchen> :t f'
05:35:59 <lambdabot> FromExpr a => a
05:36:01 <quchen> Hah.
05:36:14 <quchen> What a greedy module.
05:36:37 <hpc> ccapndave: actually, you'll probably end up needing join anyway there
05:36:44 <hpc> ccapndave: or something with (>>=)
05:36:52 <ccapndave> hpc: I looked at it, but how can Applicative flatten the Maybe (Maybe a)?
05:36:58 <hpc> :t join
05:36:59 <lambdabot> Monad m => m (m a) -> m a
05:37:02 <ccapndave> Right
05:37:08 <ccapndave> hpc: How would you actually write that?
05:37:13 <hpc> @let foo = undefined :: a -> [a] -> Maybe Int
05:37:15 <lambdabot>  Defined.
05:37:15 <hpc> :t foo
05:37:16 <lambdabot> a -> [a] -> Maybe Int
05:37:22 <quchen> Applicative cannot flatten things, that's precisely what Monad gives you over it.
05:37:55 <hpc> :t do {x <- (undefined :: Maybe Int); y <- (undefined :: Maybe [Int]); f x y}
05:37:56 <lambdabot> FromExpr (Maybe b) => Maybe b
05:38:00 <hpc> :t do {x <- (undefined :: Maybe Int); y <- (undefined :: Maybe [Int]); foo x y}
05:38:01 <lambdabot> Maybe Int
05:38:14 <hpc> @undo do {x <- (undefined :: Maybe Int); y <- (undefined :: Maybe [Int]); foo x y}
05:38:14 <lambdabot> (undefined :: Maybe Int) >>= \ x -> (undefined :: Maybe [Int]) >>= \ y -> foo x y
05:38:22 <hpc> @pl (undefined :: Maybe Int) >>= \ x -> (undefined :: Maybe [Int]) >>= \ y -> foo x y
05:38:22 <lambdabot> (undefined :: Maybe [Int] >>=) . foo =<< undefined :: Maybe Int
05:38:29 <hpc> er
05:38:46 <ccapndave> I must admit that I don't understand anything you or lambdabot are saying :)
05:38:54 <hpc> @pl \x' y' -> x' >>= \x -> y' >>= \y -> foo x y
05:38:54 <lambdabot> (. ((. foo) . (>>=))) . (>>=)
05:38:57 <hpc> lol
05:39:06 <ccapndave> I think I sort of want >>= but with two arguments
05:39:11 <ccapndave> Do I?
05:39:43 <hpc> :t \x' y' -> join (f <$> x' <*> y')
05:39:45 <lambdabot> (Monad m, Show a1, Show a2, FromExpr (m a)) => m a2 -> m a1 -> m a
05:39:50 <hpc> :t \x' y' -> join (foo <$> x' <*> y')
05:39:51 <lambdabot> Maybe a -> Maybe [a] -> Maybe Int
05:39:57 <hpc> @pl \x' y' -> join (foo <$> x' <*> y')
05:39:57 <lambdabot> ((join . (foo <$>)) .) . (<*>)
05:40:13 <hpc> yeah, there's no immediately available pretty thing that does what you need
05:40:29 <hpc> but that last one is probably the closest
05:40:47 <ccapndave> TBH that's pretty much what I had already
05:41:02 <ccapndave> I'm going to implement a flatMap2, flatMap3, flatMap4, etc function in that case
05:41:56 <hpc> if this was haskell, i would be pretty happy with it
05:41:59 <hpc> is it uglier in elm?
05:42:07 <ccapndave> Not particularly
05:42:22 <ccapndave> Maybe.map2 elemIndex maybeElem maybeList |> join
05:43:20 <hpc> that is quite a bit uglier, without (<*>) :(
05:44:12 <ccapndave> I think you just get used to the syntax
05:44:14 <ccapndave> It looks ok to me
05:44:25 <quchen> :t \x xs -> xs >>= elemIndex x
05:44:26 <lambdabot> Eq a => a -> Maybe [a] -> Maybe Int
05:44:30 <ccapndave> But better would be Maybe.flatMap2 elemIndex maybeElem maybeList
05:44:46 <quchen> >>= is often andThen in Elm, I think
05:44:56 <ccapndave> It is
05:45:22 <ccapndave> x is a maybe too though
05:45:37 <ccapndave> And elemIndex needs it unwrapped
05:45:49 <quchen> Oh. Well then I'd go with do nota...nevermind, Elm doesn't have that.
05:45:58 <ccapndave> It doesn't ;)
05:46:09 <quchen> join (liftA2 elemIndex x xs) -- not very readable
05:46:35 <ccapndave> I think flatMap2 is the most readable
05:58:13 <ccapndave> Thanks a lot for the help
06:03:53 <minib00m> hey there, i caught myself using StateT and ExceptT transformers in separate threads
06:04:11 <minib00m> is this package: https://hackage.haskell.org/package/concurrent-state meant for my purpose?
06:04:52 <minib00m> or should i just use locks when updating state? 
06:45:19 <iphy> is there a better way to write \x -> f x >>= g?
06:47:11 <zaquest> :t (>=>)
06:47:12 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:51:14 <black0range> Hello! Are there some type safe way to define a datatype that is a subset of a native datatype? Say a datatype that has a underlying value that must be an integer between 1 - 10
06:52:04 <buglebudabey> black0range newtype?
06:52:17 <buglebudabey> black0range i'm no expert but that's what i thought of
06:52:46 <black0range> Sure but then i do not know how to make typesafe limits :/ 
06:52:53 <maerwald> black0range: uhm, well... either you make your own type that only goes between 1 and 10 (annoying), or you use something like liquidhaskell
06:53:13 <maerwald> haskell doesn't really have dependent types (yet)
06:53:38 <mnoonan> black0range: I think the usual strategy is to define your type in a module, but do not export the type constructors. Then you export functions like makeMyType :: Int -> Maybe MyType for constructing values of that type.
06:53:44 <maerwald> liquidhaskell is experimental though, your experience might vary
06:54:00 <jophish> Does anyone know of a package for dealing with command line programs
06:54:04 <jophish> I need to call out to a repl
06:54:58 <black0range> mearwald: I'll have a look at it :)  
06:55:40 <tdammers> jophish: which part? writing CLI applications yourself? or shelling out to a CLI application?
06:56:01 <Rotaerk> maerwald, are there concrete plans to get dependent types into haskell?
06:56:27 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
06:57:05 <Rotaerk> huh, nice
06:57:59 <jophish> tdammers: I have a program I can only interface to via a repl. I'd like to use this program from haskell
06:58:04 <jophish> so shelling out to a CLI application
06:58:17 <tdammers> the process module then, I guess
06:58:18 <jophish> It shouldn't be too hard just to write to its stdin
06:58:50 <tdammers> create a process with pipe handles for stdin and stdout, and you can communicate with the child program through those
06:59:11 <jophish> yeah, I was hoping for something a little higher level. System.Process was a fallback :)
06:59:36 <tdammers> if the child program doesn't do isatty detection, it should be good enough
06:59:45 <tdammers> eh, the other way around
06:59:55 <jophish> well, things like detecting when the current command has finished
06:59:59 <tdammers> if it *does* TTY detection and keeps things clean if you're not a tty
07:00:08 <jophish> and grabbing output on a per command basis
07:00:09 <tdammers> that, yes...
07:00:13 <jophish> perhaps I should write this...
07:00:15 <tdammers> that's a bit trickier
07:00:34 <tdammers> but I'd argue that how you do that depends on the specifics of the child process
07:00:42 <tdammers> I doubt one could write a generic solution to that
07:00:52 <jophish> you're probably right
07:01:01 <jophish> I'm sure that there are shared parts for most repls though
07:01:23 <tdammers> if the repl behaves, then it should write a prompt to stderr and output to stdout
07:01:33 <tdammers> and do everything line-wise
07:01:36 <tdammers> kind of
07:01:45 <tdammers> so you could do something like read from its stdout until its stderr produces
07:01:48 <tdammers> but, ugh
07:01:55 <jophish> yeah, that's not nice :)
07:02:03 <tdammers> if you know more about the output format, you could exploit that information instead
07:02:27 <tdammers> or, if your client can afford to read output asynchronously, you could just decouple input and output entirely
07:02:47 <tdammers> but other than that, I doubt there's a generic solution
07:02:57 <tdammers> I ran into these exact issues when I wrote my phantomjs wrapper
07:03:19 <tdammers> in the end, I ditched the idea of communicating over pipes, and ran a local HTTP server inside phantomjs
07:05:51 <jophish> tdammers: thanks for your input :)
07:05:57 <tdammers> np
07:07:37 <ongy> is this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html 404 on purpose?
07:10:51 <tsahyt> I'm linking a library with the rts explicitly in order to use it from non-haskell code (C++). I have a configure script which adds extra-libraries: HSrts_thr-ghc with the appropriate GHC version suffix. cabal configure however throws an error about a missing C library (the same rts lib), but then cabal build runs without problems. Any ideas how to fix the error in the configure stage?
07:11:55 <dcoutts> tsahyt: I think you also need base & others that the rts & base link against, like ghc-prim
07:12:23 <tsahyt> dcoutts: it will link against those automatically
07:12:26 <tsahyt> the library works
07:12:29 <dcoutts> tsahyt: if you run configure with -v3 you can see the link command it tries, and then you can try that manually
07:12:36 <tsahyt> just as intended, it's just the build process that's weird
07:13:01 <dcoutts> tsahyt: sure, when the build links things it includes base
07:13:15 <buglebudabey> what's the stack command to do ghci for a specific file? stack ghci --? file.hs
07:13:18 <tsahyt> ah, with -v3 it lists a bunch of undefined references
07:13:24 <dcoutts> but the configure stage is thinking of this as being like a C lib, not a haskell lib
07:13:58 <glguy> https://github.com/GaloisInc/galua/blob/master/galua/Setup.hs
07:14:02 <dcoutts> tsahyt: btw, if you want to really do this properly in the longer term, you could help rebase the "foreign lib" support feature for Cabal
07:14:22 <glguy> https://github.com/GaloisInc/galua/blob/master/galua-c/build
07:14:35 <glguy> This is how I've been making my foreign static library
07:15:33 <Clint> dolio: what's the deal with a ghc8-compatible bytestring-show?
07:15:51 <tsahyt> dcoutts: I'll see if linking base etc. explicitly helps. I hope that this doesn't mean that I have to list all dependencies of my library explicitly though
07:16:12 <dcoutts> tsahyt: no, it's just that rts + base recursively depend on each other
07:16:23 <dcoutts> and base depends on a couple other things
07:16:30 <dcoutts> so it's just that cycle + closure
07:16:36 <slemonide> Hello. Is it really faster to weed out duplicates using sets? I tried running both "nub $ take 200000000 . concat . repeat $ [1..2]" and "Set.toList . Set.fromList $ take 200000000 . concat . repeat $ [1..2]" and the later turned out to be slower.
07:17:00 <tsahyt> dcoutts: so what is this foreign lib feature?
07:17:39 <dcoutts> tsahyt: it's direct support in cabal for producing libs with a C/native ABI, e.g. for integration into other projects
07:18:00 <tsahyt> that does sound very useful indeed
07:18:35 <dcoutts> tsahyt: there's a PR that me and colleagues did (for a client that needed it) but it needs rebasing and merging
07:18:37 <tsahyt> I suppose that creating static libraries for foreign languages is not included though, right? since that would require rebuilding everything with -fPIC
07:18:46 <bartavelle> slemonide, it's probably because there are only 2 distinct elements
07:18:56 <bartavelle> also I think that "concat . repeat" is cycle
07:19:06 <dcoutts> tsahyt: it only supports combinations that ghc supports on each platform.
07:19:41 <dcoutts> tsahyt: so that includes "mega dlls" on windows, but on linux it's fully static libs or per-package shared libs, not single "mega so"
07:19:53 <dcoutts> tsahyt: but if/when ghc supports that on linux, the design allows for it
07:20:10 <tsahyt> I think GHC *would* support it on Linux, but it'd require a special build
07:20:16 <tsahyt> I might be wrong though
07:20:20 <dcoutts> I think you're right
07:20:39 <dcoutts> iirc, someone was working on that recently in the ghc build system
07:20:48 <Axman6> slemonide: for small n it probably is faster, but if you had a few thousand elements it would likely be faster
07:21:00 <Phyx-> dcoutts: actually those mega dlls were a bug. they're much smaller now :)
07:21:24 <slemonide> Yeah, I just tried it on [1..100].
07:21:32 <dcoutts> Phyx-: heh. I just mean a single .dll, rather than a whole bunch of per-package dlls.
07:22:07 <Phyx-> dcoutts: ah ok :)
07:22:09 <glguy> To make a mega shared object on Linux I needed to recompile ghc to always use fPIC and to compile libffi pic
07:22:11 <tsahyt> huh, where did the integer-gmp dependency of base go with 4.8.0.0?
07:23:04 <slemonide> bartavelle: Why do you think that it is a cycle?
07:23:08 <chris___> Hello guys! =)
07:23:16 <slemonide> Hello!
07:23:19 <bartavelle> slemonide, cycle = concat . repeat
07:23:25 <bartavelle> > cycle [1,2,3]
07:23:27 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
07:23:27 <slemonide> oh
07:23:34 <slemonide> thank you
07:23:36 <bartavelle> np
07:24:40 <dxld> tsahyt: there is one really ugly hack I've been playing with in the past that might help you. If you build a regular executable with -no-hs-main you'll end up with something that actually a library but it'll have the RTS linked in already
07:24:46 <dolio> Clint: Is it broken?
07:25:45 <Axman6> cycle is actually defined differently though, you get a genuinely cyclic structure:
07:25:48 <Axman6> @src cycle
07:25:48 <lambdabot> cycle [] = undefined
07:25:48 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:26:00 <Clint> dolio: it's binary (<0.8) and ghc comes with binary 0.8.3.0
07:26:09 <dolio> Oh, I see.
07:26:34 <Axman6> > let c xs = let xs' = foldr (:) xs' xs in c [1,2,3]
07:26:36 <lambdabot>  <no location info>:
07:26:36 <lambdabot>      not an expression: ‘let c xs = let xs' = foldr (:) xs' xs in c [1,2,3]’
07:26:53 <tsahyt> dxld: that is ugly indeed. is that all that is needed? Just some dummy executable target and -hs-no-main?
07:26:54 <Axman6> > let c xs = let xs' = foldr (:) xs' xs in xs' in c [1,2,3]
07:26:55 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
07:27:36 <dxld> tsahyt: $ ghc -dynamic -shared -fPIC Plugin.hs -o libmain.so -no-hs-main   is what I always used
07:27:50 <tsahyt> dxld: does that work with cabal somehow?
07:28:13 <tsahyt> the main reason why I want to fix this is because stack refuses to build when cabal configure returns an error
07:28:16 <dxld> tsahyt: `ghc-options: -dynamic -fPic -no-hs-main` maybe?
07:28:33 <tsahyt> I might try that when everything else fails. specifying the rest of base worked so far
07:28:35 <dcoutts> tsahyt: I've made this work before with cabal, listing base etc
07:29:02 <dcoutts> tsahyt: but it's a bit of a hack, which is why we wrote the patch to support it properly
07:29:06 <hwkng> redis, redis-io, hedis -- which is the most mature haskell/redis binding?
07:29:43 <dolio> Clint: The real answer is that I don't think you should use bytestring-show. :) I don't know what to suggest as a replacement, though. Has someone made a show for Text?
07:30:02 <tsahyt> well now it works with cabal, but stack is complaining about the configure script
07:30:16 <dcoutts> tsahyt: I mean including cabal configure
07:30:58 <dxld> dcoutts: could you link me to that PR you mentioned?
07:31:36 <dcoutts> dxld: https://github.com/haskell/cabal/pull/2540
07:31:42 <Clint> dolio: well, it's not me; it's hedgewars
07:31:48 <dxld> ty
07:31:49 <dolio> Ah.
07:32:28 <dcoutts> dxld: there's broad agreement on it, no real problems remaining, just someone has to do the work to update it to the latest master, since it touched quite a bit of code.
07:32:48 <Clint> dolio: i'll try to suggest that they stop using it
07:33:15 <mjrosenb> I've been looking for a tutorial showing how to use the haskell charts library to render to a window, rather than saving to a file that needs to be displayed externally.  any suggestions?
07:33:48 <dxld> dcoutts: cool, next time my colleague complains about having to hack linking the rts into his CMake build system I'll have a look :)
07:33:53 <dolio> I'll fix the bound, too, since it compiles, and I don't see any binary changes that should affect the package.
07:34:22 <dolio> Really I should probably get rid of the binary dependency entirely, since it's just using it like a bytestring builder, I think.
07:44:02 <tsahyt> dcoutts: have you been able to use profiling with a library built this way somehow?
07:44:14 <dcoutts> tsahyt: no, never tried that
07:44:57 <dcoutts> tsahyt: but in principle it should be doable, picking the right set of C libs
07:45:30 <tsahyt> would that mean linking to profiling versions of libraries explicitly?
07:50:01 <buglebudabey> whenever I run this function "hAlloc (size, (next:free), cts) n = ((size+1, free, (next,n) : cts),next)" it runs infinitely, can anyone tell me why, im passing in (0, [1..], []) as my first argument and it's making the list [1..] strict, how can i stop this?
07:52:00 <buglebudabey> essentially if i have a function f (x:xs) = (x, xs) and i pass in f [1..] what can i do to not evaluate?
07:53:08 <coppro> that doesn't look like it should introduce strictness to me
07:53:56 <buglebudabey> coppro if you run that f function i gave what happens for you, it forces it to evaluate xs since that's what's snd, right?
07:54:15 <Skami> Hello. Is there an equivalent in Template Haskell's Q monad of IORefs ?
07:54:43 <bergmark> buglebudabey: the result expression contains `free', so prointing that should loop, no?
07:55:24 <tdammers> Skami: yes. IORefs.
07:55:50 <tdammers> Skami: to clarify: Q is an instance of Quasi, which means that you can call qRunIO to turn an IO action into a Q action
07:55:55 <tdammers> http://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#t:Q
07:56:06 <tdammers> and this, in turn, means that you can use IORefs from inside Q
07:56:10 <buglebudabey> bergmark you're right. what i'm trying to do is basically allocate space in a custom heap, and generate the next address which is simply +1 the last address. what can i do to assure the next address is +1 the last?
07:56:47 <Skami> tdammers, Wow I didn't tought that i'll be this simple. Thanks !
07:57:15 <bergmark> buglebudabey: what you can do is not return the infinite list :)
07:57:49 * hackagebot lucid-svg 0.7.0.0 - DSL for SVG using lucid for HTML  https://hackage.haskell.org/package/lucid-svg-0.7.0.0 (jeffreyrosenbluth)
07:57:58 <buglebudabey> bergmark thanks :) now how do i get the next item in this infinite list that i'm not returning
07:59:35 <bergmark> > let f x = if head x > 10 then [] else head x : f (tail x) in f [1..]
07:59:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:59:52 <iphy> is there a way to avoid the two (C and S) boilerplate functions here: http://lpaste.net/168518
08:00:57 <iphy> or to make them less code or more uniform?
08:01:21 <iphy> in particular, the S function repeats all the arguments, can I somehow get it to not repeat them?
08:01:40 <bergmark> you could write it point free style and not have to name it at all
08:01:40 <coppro> buglebudabey: free there isn't being forced, though
08:01:42 <buglebudabey> bergmark thank you, I changed the data type instead and made the function like so: hAlloc (size, address, cts) n = ((size+1, address+1, (address,n) : cts), address)
08:02:06 <buglebudabey> coppro i resolved it by just not returning the infinite list
08:02:09 <coppro> forcing only happens when you try to pattern match on a value
08:02:10 <coppro> that works
08:02:11 <iphy> bergmark: how would I write precomputeS in point free style?
08:02:14 <seivan_> Since ParsecIndent has two extra arguments in its closure, I take it it won't play well with the rest of Parsec?
08:02:26 <coppro> probably better in terms of space efficiency anyway
08:02:27 <seivan_> (Stream s (State SourcePos) Char)
08:02:33 <buglebudabey> true
08:02:33 <bergmark> @pl \sk pk -> return $ precompute sk pk
08:02:33 <lambdabot> (return .) . precompute
08:02:45 <seivan_> (State SourcePos) is missing in regular Parse, how can Parse and ParseIndent work together?
08:02:52 <bergmark> or... i think...
08:02:59 <bergmark> @type \return .: precompute
08:03:00 <lambdabot> parse error on input ‘.:’
08:03:08 <bergmark> @type return .: precompute
08:03:10 <lambdabot>     Not in scope: ‘.:’
08:03:10 <lambdabot>     Perhaps you meant one of these:
08:03:10 <lambdabot>       ‘.’ (imported from Data.Function),
08:03:23 <bergmark> @let (.:) = (.).(.)
08:03:24 <lambdabot>  Defined.
08:03:26 <bergmark> @type return .: precompute
08:03:27 <lambdabot> Not in scope: ‘precompute’
08:03:32 <bergmark> i'm silly :_(
08:03:46 <iphy> I see
08:03:54 <iphy> but it would still look different for each arity
08:04:10 <iphy> there is no way to just say "turn this function into a Server function"?
08:04:31 <bergmark> @type \precompute -> return .: precompute -- please lambdabot!!
08:04:33 <lambdabot> Monad m => (a -> a1 -> a2) -> a -> a1 -> m a2
08:05:10 <bergmark> iphy: one might also wonder if that is duplication that should go away, or if it's accidental duplication and makes sense to keep
08:06:02 <iphy> bergmark: basically, I want for (almost) every public function to have a Client and Server function
08:06:26 <iphy> I don't really need the Server function actually, I just need a Method containing it
08:06:30 <bergmark> if a module contains variables with the same name a bunch of times and they have the same type then it's probably easier to read the code
08:06:35 <iphy> https://hackage.haskell.org/package/msgpack-rpc-1.0.0/docs/Network-MessagePack-Server.html
08:10:45 <bergmark> iphy: might be overkill but template-haskell is also an option
08:11:14 <iphy> bergmark: yeah, I don't think I'll use that
08:11:53 <bergmark> or run a preprocessor before compiling...
08:22:49 * hackagebot beam-th 0.1.0.1 - Template Haskell utilities for beam  https://hackage.haskell.org/package/beam-th-0.1.0.1 (hesiod)
08:38:12 <buglebudabey> when I run stack ghci, then :load Main.hs, i get "t is not a module in the current program, or in any known package." then have to load each dependency by hand - is there a faster way to do this?
09:05:19 <seivan_> Why does IdentityParser require a State and Pos? I thought each parser had one already?
09:05:32 <seivan_> IndentedParsec*
09:11:15 <Sinestro> Why would changing the storable instance used for one type make the _info for a function that doesn't touch that type segfault?
09:11:31 <Sinestro> (I've confirmed it's not buffer overrun, it doesn't get near the end.)
09:13:51 <glguy> Storable instances use raw pointers, if changing that code is related to the problem, it probably won't be possible to guess how the pointers are being used incorrectly
09:13:57 <glguy> ?lpaste
09:13:58 <lambdabot> Haskell pastebin: http://lpaste.net/
09:27:51 * hackagebot ffmpeg-light 0.11.1 - Minimal bindings to the FFmpeg library.  https://hackage.haskell.org/package/ffmpeg-light-0.11.1 (AnthonyCowley)
09:29:39 <marchelzo> is there something like (a -> IO ()) -> Maybe a -> IO ()
09:29:59 <marchelzo> to save you from writing Just x -> ...; Nothing -> return ()
09:30:32 <ClaudiusMaximus> :t mapM_
09:30:32 <dwynwen_ddlleyw> What is the function of Maybe?
09:30:34 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
09:31:08 <monochrom> ah, mapM_ will do great. Maybe is an instance of Foldable, i.e., t can be Maybe there.
09:31:09 <marchelzo> oh, i didn't know mapM_ worked on any Foldable
09:31:32 <monochrom> recent generalization
09:31:57 <glguy> The more general function for this is traverse_
09:32:49 <glguy> traverse_ 07:: (Foldable t, Applicative f) 07=> (a 07-> f b) 07-> t a 07-> f ()
09:39:51 <kurt11> Is there a simple "startswith" type of function for strings or lists in the Haskell base library?
09:40:14 <glguy> :t isPrefixOf
09:40:15 <lambdabot> Eq a => [a] -> [a] -> Bool
09:40:38 <kadoban> kurt11: That stuff is in Data.List, yeah ^
09:42:12 <kurt11> kadoban: where in https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html
09:42:49 <kadoban> kurt11: Under Predicates, search fro isPrefixOf that glguy mentioned.
09:42:53 <kadoban> for*
09:42:58 <glguy> kurt11: You can use cmd-F or control-F in most clients to search
09:44:10 <kadoban> kurt11: You may also be interested in the 'split' package in the future, it has some stuff on lists that's quite commonly looked for (but not needed for this)
09:46:44 <black0range> Does order matter in MultiParamTypeClasses? I got this error message and I can't figure out why :/ https://lambda.sx/2NN#dr8irxhr 
09:47:56 <glguy> black0range: Did you make a new instance of that class?
09:48:09 <black0range> Convertible? yes 
09:48:16 <glguy> this one?   instance Integral n => Data.Convertible.Base.Convertible Status n
09:48:24 <black0range> yes i did that one 
09:48:27 <glguy> Yeah, delete that one
09:48:35 <glguy> it overlaps with most of the instances for this class
09:48:54 <black0range> But why? SqlValue isn't an instance of Integral? 
09:49:04 <glguy> That's not how class resolution works
09:49:14 <glguy> SqlValue unifies with 'n', so that instance matches
09:49:36 <glguy> because it matched now the compiler knows that n needs to be an instance of Integral
09:49:43 <glguy> You shouldn't make instances like this one
09:50:02 <glguy> or in this case it knows there are two possible matches and it fails
09:50:30 <black0range> :(
09:50:35 <black0range> Well thanks! :)
09:52:52 * hackagebot beam-th 0.1.0.2 - Template Haskell utilities for beam  https://hackage.haskell.org/package/beam-th-0.1.0.2 (hesiod)
09:53:34 <kurt11> glguy: wow. so I searched the page. skimmed through everything and didn't see anything like the startswith function that I was looking for. Since kadoban said this function was in Data.List I figured I would ask, where specifically.
09:53:55 <kurt11> kadoban: isPrefixOf. Thanks!
09:55:19 <glguy> You're welcome
09:57:17 <tmillc> despite really loving haskell, I stopped learning it a year+ ago because I hated the cabal/stack situation. Has there been any improvements on that front or is anything coming up?
09:58:06 <maerwald> tmillc: can you be more specific what situation you hate?
09:58:10 <glguy> What's the cabal/stack situation?
09:58:11 <monochrom> what is the cabal/stack situation that you hate?
09:58:14 <tommd> tmillc: I think I've been using it long enough that I'm blind to your issues.  Can you elaborate?
09:58:28 <srhb> I also want details. Engage.
09:58:28 <mnoonan> stack fixed just about everything unpleasant about cabal, from my perspective
09:58:30 <srhb> :-)
09:58:38 <tmillc> oh jeez... I hope I didn't kick a hornet's nest
09:58:39 <monochrom> I guess there is no "the".
09:58:47 <maerwald> stack does not fix cabal, stack is a deployment tool
09:58:53 <srhb> tmillc: Nah, it's fine :-)
09:58:58 <glguy> tmillc: I don't know that it's a hornets nest, we just don't know what the problem is
09:58:59 <monochrom> No no, I think you're just being ambiguous.
09:59:22 <glguy> Yeah, stack allows me to use cabal in peace, fewer cabal complaints
09:59:28 <srhb> Personally I think Stack is rather sucky, so I use Nix and cabal, which rocks.
09:59:50 <tmillc> it was probably entirely my fault, and I was a beginner though have experience getting toolchains in working order in other languages/etc but I just remember being met with constant frustration when trying to do anything with cabal, and I didn't like the "entirely new sandbox instance" perspective of stack
10:00:10 <srhb> tmillc: That's not what Stack did or what it does.
10:00:10 <maerwald> tmillc: if you don't do sandboxes for everything, cabal will be a pain, yes
10:00:23 <srhb> tmillc: Stack shares sandboxed builds whenever possible.
10:00:25 <srhb> afaik.
10:00:32 <maerwald> otherwise, it works fine... despite the claims of stack people telling me my cabal sandboxes dont work
10:00:32 <kadoban> tmillc: cabal-install is rather tedious IMO. stack is not perfect, but quite a big improvement.
10:00:33 <maerwald> they do
10:00:58 <tmillc> srhb: there was also the issue of only having access to the curated packages
10:01:10 <srhb> tmillc: That wasn't and isn't the case either.
10:01:17 <glguy> tmillc: It's still not the case that you're stuck with curated packages
10:01:19 <monochrom> OK, stack hasn't changed; cabal has changed incrememtally so I don't know whether it will frustrate you today.
10:01:32 <maerwald> tmillc: for development, you should use plain cabal sandboxes so you have access to the latest hackage state and know if your dependencies are correct
10:01:54 <bitemyapp> @karma+ kadoban
10:01:54 <lambdabot> kadoban's karma raised to 17.
10:02:35 <maerwald> if dependencies are incorrect... you should file a bug and fix it instead of installing stack to work around it
10:02:51 * srhb shrugs
10:02:57 <tmillc> maerwald: I love PoE btw
10:02:59 <srhb> It should be fun to work with, especially getting started.
10:03:02 <maerwald> tmillc: heh
10:03:03 <srhb> Stack really does help there, for sure.
10:03:23 <tmillc> I'm easily willing to believe that I was just doing both cabal and stack completely wrong
10:03:42 <maerwald> stick with cabal for now, until you actually have a reason to use yet another abstraction on top of it
10:04:18 <kadoban> stack is not an abstraction on cabal-install, it's a separate tool. It's also just plain easier out of the box, unless you're only doing trivially small things.
10:04:23 <tmillc> but moving to R and using CRAN... oh god it's just been a delight
10:04:48 <maerwald> kadoban: I disagree, I do non-trivial things with plain cabal and I've found it more tedious and annoying trying to get it going with stack
10:05:01 <kadoban> maerwald: Likely because you already know cabal-install well.
10:05:02 <maerwald> stuff is missing or the required version is not there => you are screwed
10:05:17 <maerwald> there's not really that much to know about it 
10:05:29 <maerwald> except "use sandboxes!"
10:05:30 <srhb> cabal was an absolute horror to use for a beginner even a year ago. I'm not sure it has improved much.
10:05:43 <srhb> cabal-install, that is.
10:06:14 <srhb> And yes, it's due to broken version constraints almost always.
10:06:30 <monochrom> stack : cabal-install :: iphone : android phone  <duck>
10:06:32 <maerwald> the only annoying bugs I know of are generation of haddock stuff for library AND executable at once and a few misleading error messages (e.g. on --dependencies-only)
10:06:50 <srhb> I haven't experienced any bugs with it either.
10:06:56 <tmillc> haskell is such a beautiful language, I wish cabal had the mindless ease of CRAN or apt-get. But maybe it's a problem intrinsic to haskell, maybe due to the type system?
10:07:06 <kadoban> maerwald: Even using sandboxes didn't fix it for me. It just improved it from having everything constantly broken to only having to nuke the world once every other week or so. I did get pretty good at reinstalling GHC though, I guess that's … something.
10:07:09 <srhb> tmillc: Doubtful.
10:07:24 <srhb> tmillc: But really, it is that easy with sandboxes.
10:07:32 <glguy> A good way to avoid broken situations and nuke the world is to stop using --force
10:07:44 <mnoonan> tmillc: I think it's more an issue of Haskell developers being more conservative about correctness (e.g. with version bounds)
10:07:58 <bennofs> tmillc: comparing cabal with apt-get is kind of unfair though. apt-get is a pretty curated package set compared to the "anything can push" of hackage
10:08:05 <tmillc> mnoonan: perhaps that alongside inconsistency with what versioning means?
10:08:15 <maerwald> mnoonan: exactly... the upper version bounds on base are often just plain wrong and I wish cabal would stop complaining if it's omitted
10:08:28 <bennofs> mnoonan, tmillc: cabal does have --allow-newer now though, which is a already a big improvement ;)
10:08:37 <tmillc> bennofs: maybe the "anything can push" approach is, well, flawed
10:08:45 <monochrom> it is due to GHC aggressive optimizations, so that dependency is ultimately based on binaries, not versions.
10:08:46 <bennofs> tmillc: well, then you can use stack :D
10:08:50 <bennofs> tmillc: with stackage
10:08:59 <tmillc> bennofs: fair :)
10:09:00 <maerwald> upper version bounds are NOT to say "maybe it doesn't build with a version that does not exist yet, so let's just restrict future versions"
10:09:25 <maerwald> it's misused that way though
10:09:28 <glguy> No one has ever verified that this works with the software that hasn't come out yet, so don't use it with that version until someone does
10:09:38 <glguy> and if you want to be that person you can --allow-newer
10:09:47 <maerwald> nah, that's just random assumptions
10:10:18 <bennofs> tmillc: btw, also the comparisation to R is bad because (correct me if I'm wrong) R is not a compiled language, and that makes installation of libraries much easier (a package manager can basically just fetch the source of the lib into the current project if compile is fast/nothing needs to be compiled)
10:10:52 <kadoban> tmillc: But yes, stack has improved, and cabal-install is slowly improving as well. Last I heard there was a development version of cabal-install that improved quite a few of the problems I've had with it in the past.
10:11:04 <tmillc> bennofs: that's correct and you're right. But just blindly from a new user perspective, fair or not the process is a world of difference
10:11:04 <kadoban> None of it is perfect, but it's usable enough.
10:11:09 <monochrom> yes, being interpreted helps. I sometimes say "use hugs to solve cabal hell", and it is not because fewer packages are compatible with hugs.
10:11:20 <glguy> some languages do well by duplicating dependencies aggressively and never exporting a dependent package's types in the package's API
10:11:59 <monochrom> it is because you can simply swap out and swap in packages, there is no binary-level compatibility to worry about, there is simply no binary level
10:12:20 <monochrom> whereas GHC is the most binary-level incompatible compiler in the whole world.
10:12:38 <maerwald> monochrom: and people celebrate that :D
10:12:54 <kadoban> monochrom: Is that simply the way it has to be, or is it something that could eventually change?
10:12:56 <monochrom> even if you rebuild a library you already have, same version, it can still mean binary-level incompatibility
10:13:37 <monochrom> I don't know. You inline code like there is no tomorrow in order for the other optimizations to be meaningful. Can you do it some other way?
10:14:15 <glguy> Maybe with JIT?
10:14:38 <glguy> do the optimizations at runtime intead of compile time
10:15:18 <monochrom> GHC is worse (better?) than GCC because code from the bytestring version you use, nay, you built, appears in libraries you built that use bytestring.
10:15:38 <monochrom> Yeah JIT will solve it, but who will do JIT?
10:15:51 <glguy> You're full of questions today!
10:16:19 <glguy> Move the optimization to link time? a la GCC
10:16:52 <maerwald> uhm, LTO breaks everything
10:17:11 <glguy> Wow, that sounds like a lot
10:17:47 <maerwald> well, as a source distro user for half a decade... I know a little bit about such experiences to rebuild stuff with lto enabled. It usually just breaks.
10:18:07 <maerwald> maybe there was a debian bug tracker about it, I don't remember
10:18:12 <maerwald> it's just too many packages breaking
10:18:51 <monochrom> Do you know why they break there?
10:19:54 <monochrom> "LTO breaks, it's an axiom" vs "they did LTO the wrong way" vs something I haven't thought of?
10:20:03 <buglebudabey> what's the proper way to indent this function if I want to break it up into two lines? "let run = putStrLn . showResults . eval . compile . parseTokens . scanTokens"
10:20:09 <maerwald> monochrom: nah, I'm specifically talking about gcc/clang here
10:20:36 <maerwald> isn't what ghc does already rather similar to LTO wrt cross-module inlining?
10:20:45 <iphy> is there a way to write "fun" instead of "fun2" or "fun3" in client code? http://lpaste.net/168529
10:21:06 <monochrom> yes, GHC does LTO at compile time.
10:21:09 <kadoban> buglebudabey: I usually drop one of the "." down to the next line and line it up with the equals sign, but I'm not sure that's actually a popular opinion.
10:21:23 <buglebudabey> thanks kadoban 
10:21:46 <maerwald> I don't know why gcc lto is broken though. I can't even find bug trackers about it on common source distros. Seems no one is really interested in testing.
10:22:18 <jophish> What's the idiomatic way of installing extra files in Setup.hs
10:22:27 <jophish> getting the installation directory seems to be a huge pain
10:22:40 <monochrom> The way people write C programs, LTO has only marginal benefit, so yeah I can understand that few people care.
10:23:29 <maerwald> monochrom: the question is... how much of a penalty would it be to disable that lto-like GHC behavior?
10:24:14 <monochrom> Whereas in Haskell you face the dilemma of writing idiomatic elegant Haskell and have GHC do evil things, vs writing C-like Haskell hand-optimized.
10:24:34 <monochrom> total loss.
10:26:24 <monochrom> all the list fusion, bytestring fusion, text fusion, vector fusion won't be triggered, simply because you have a crucial function not inlined because it is hiding behind a module boundary.
10:26:29 <divVerent> 13:17:26        maerwald | well, as a source distro user for half a decade... I know a little bit about such experiences to rebuild stuff with lto enabled. It usually just breaks.
10:26:34 <divVerent> that's just C++ being evil :P
10:26:49 <divVerent> with LTO double definitions of the same symbol finally get noticed
10:27:17 <maerwald> divVerent: well, I was actually talking runtime breakage, but yeah, most of the time you don't even get to compile successfully
10:27:21 <divVerent> the other thing that breaks is - the "linking" actually becomes almost a compile phase, and that means it'll suddenly try to compile the whole program at once, eating all your RAM, all swap, and running out of memory
10:27:28 <monochrom> yeah even C++ compilers know to "export internal code and put it in a 'pre-compiled header' so optimizations can actually happen"
10:27:38 <divVerent> yes, some C++ mistakes do cause runtime breakage with lto
10:27:44 <monochrom> GHC simply does that to an extreme.
10:28:10 <divVerent> well... GHC also is based on a slightly less insane language than gcc :)
10:28:12 <monochrom> (look at the content of *.hi files under -O1 or even -O2)
10:28:33 <divVerent> like, you don't suddenly start #including headers in Haskell, and getting subtly different behavior when you reorder the imports
10:28:41 <maerwald> divVerent: nah, you just said it breaks with C++ and now you blame C? :o
10:28:49 <divVerent> maerwald: I blame both
10:28:58 <divVerent> the issues are more common in C++ as C++ tends to be used for larger programs
10:29:14 <maerwald> uh, depends
10:29:38 <divVerent> but in C there is a similar equivalent to C++'s ODR too
10:30:35 <divVerent> and actually, reusing the same name in different compilation units is more likely in C due to lack of namespacing
10:30:54 <divVerent> just tends to have somewhat different symptoms in C that are easier to diagnose and fix
10:31:15 <divVerent> a typical issue e.g. is "my library works as a shared library but fails to link as a static one"
10:31:51 <maerwald> that has different reasons though
10:31:57 <maerwald> e.g. no proper pkg-config file
10:32:03 <maerwald> and people have an incomplete linker line
10:32:03 <divVerent> not quite :P
10:32:07 <divVerent> lack of internal symbols within .a
10:32:12 <divVerent> which is just an archive of .o files
10:32:26 <divVerent> so if they want to reference each other, the symbol must be exported, even to the outside
10:32:27 <maerwald> that's another one yes
10:32:45 <divVerent> while OTOH I'm actually impressed how well GHC solves this issue
10:32:53 * hackagebot cartel 0.18.0.0 - Specify Cabal files in Haskell  https://hackage.haskell.org/package/cartel-0.18.0.0 (OmariNorman)
10:32:57 <divVerent> you can even link multiple versions of the same library into a binary
10:33:09 <divVerent> and it almost always works :P
10:33:50 <divVerent> or rather, it works if it compiles, you may just have incompatible types if you try to pass an object from one to the other
10:38:27 <iphy> msgpack is infinite-looping in a function called msgpackzm1zi0zi0_DataziMessagePackziObject_zdwzdcfromObject_info
10:38:30 <iphy> what does this mean?
10:45:38 <tommd> so.... Data.MessagePack.Object.fromObject?
10:47:07 <dmwit> jophish: Did you ever get an answer?
10:47:38 <jophish> dmwit: nope 
10:48:04 <dmwit> jophish: Use the data-files: field in your package. In your code, there is a Paths_<pkgname> module with some functions that will help you find those files.
10:48:24 <jophish> dmwit: ah, we're using them for some things, but we need to install some generated files
10:48:31 <jophish> these files are generated in Setup.hs
10:48:34 <dmwit> jophish: See "Accessing data files" on https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/authors.html for details.
10:48:42 <jophish> we're trying to copy them in a postCopy hook
10:48:47 <dmwit> I see.
10:49:05 <dmwit> For more sophisticated usage, I may be of less help. If dcoutts is around and not doing anything else he may have some advice.
10:52:14 <jophish> ok, thanks anyway dmwit 
10:52:53 * hackagebot setlocale 1.0.0.4 - Haskell bindings to setlocale  https://hackage.haskell.org/package/setlocale-1.0.0.4 (Kritzefitz)
10:52:56 <dmwit> ?zdec  msgpackzm1zi0zi0_DataziMessagePackziObject_zdwzdcfromObject_info
10:52:56 <lambdabot> Unknown command, try @list
10:53:19 <tmillc> I got distracted but thanks for the interesting discussion on cabal/stack
10:59:16 <Zemyla> Okay, so is this actually a free ArrowChoice type?
11:01:18 <Zemyla> data ArrowF p a b where { AID: ArrowF p a a; ACons :: p a b -> (Either e (b, w) -> d) -> ArrowF p d c -> ArrowF p (Either e (a, w)) c }; data ArrowFree p a b where ArrowFree :: (a -> u) -> ArrowF p u b -> ArrowFree p a b;
11:02:54 * hackagebot data-accessor-template 0.2.1.13 - Utilities for accessing and manipulating fields of records  https://hackage.haskell.org/package/data-accessor-template-0.2.1.13 (HenningThielemann)
11:08:44 <minib00m> I'm new to lenses, and i can't find it on hackage... can i get i-th element from the list?
11:09:05 <glguy> You can use ix
11:09:18 <glguy> > preview (ix 4) "an example"
11:09:19 <lambdabot>  Just 'x'
11:10:22 <glguy> ix works for things that have indexes: lists, maps, vectors, text, etc
11:10:45 <glguy> http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-At.html
11:11:44 <minib00m> > [(0, 0)] & ix 4
11:11:45 <lambdabot>      Couldn't match type ‘[(Integer, Integer)]’
11:11:45 <lambdabot>                     with ‘IxValue m -> f (IxValue m)’
11:11:45 <lambdabot>      Expected type: [(Integer, Integer)] -> m -> f m
11:12:12 <glguy> & is reversed function application. You can't apply ix 4 to a list
11:12:18 <crough> > [(0,0)] & preview (ix 4)
11:12:20 <lambdabot>  Nothing
11:12:31 <MichaelK> Hi, is it possible to use PostfixOperators to have a postfix type function in a GADT? Something like: `(x%) :: a -> Term a'?
11:14:21 <glguy> MichaelK: What happened when you tried?
11:15:10 <tommd> glguy, asking the hard questions.
11:15:35 <MichaelK> glguy: parse error
11:15:45 <glguy> MichaelK: data constructor operators need a leading colon :
11:16:26 <glguy> (07:%) 07:: a 07-> Term a
11:17:40 <MichaelK> glguy: so that compiles, but doesn't work pre/postfix
11:17:47 <MichaelK> wait....
11:18:23 <MichaelK> Nope, still doesn't work if postfixops are enabled in ghci
11:18:52 <glguy> You'll have to show us what you're doing wrong then
11:18:58 <glguy> ?lpaste
11:18:58 <lambdabot> Haskell pastebin: http://lpaste.net/
11:20:25 <lpaste> MichaelK pasted “Postfix GADT” at http://lpaste.net/168535
11:21:14 <glguy> MichaelK: you still have to surround 1 :% with ()s
11:21:42 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=postfix#ghc-flag--XPostfixOperators
11:22:47 <MichaelK> Oh, well now it works fine. Thank you
11:23:40 <monochrom> that's hi-tech. the user guide URL can have ?highlight=xxx
11:24:30 <glguy> That hi-tech is leaking my clever search terms
11:24:45 <glguy> people are going to figure out how to use the guide themselves :(
11:25:03 <minib00m> glguy: how to compose preview with _Just?
11:25:15 <minib00m> i wanted to make
11:25:23 <monochrom> <very meta> is there a user guide for the user guide? </very meta>
11:26:06 <minib00m> > [(0, 0)] & _1 . _Just . preview (ix 0)
11:26:08 <lambdabot>      Couldn't match type ‘Maybe (Integer, Integer)’ with ‘a0 -> f b0’
11:26:08 <lambdabot>      Expected type: [(Integer, Integer)] -> a0 -> f b0
11:26:08 <lambdabot>        Actual type: [(Integer, Integer)] -> Maybe (Integer, Integer)
11:26:46 <sm> glguy: nice trick
11:26:56 <monochrom> oh! I didn't see the search box on the left.
11:26:56 <glguy> minib00m: I don't know what that's supposed to do, you can forget about & for now
11:27:05 * glguy is ruined
11:27:12 <monochrom> this is neato
11:27:29 <sm> noted in my book of secret tricks
11:27:39 <monochrom> err, s/left/right/
11:28:12 <monochrom> <moar feature request> can we make the menu on the right stick around when we scroll up and down? </moar feature request>
11:28:27 <glguy> > preview (ix 0 . _1) [(10,20)]
11:28:29 <lambdabot>  Just 10
11:28:47 <sm> +1, that would nice
11:28:49 <sm> be nice
11:29:59 <sm> could it be also have smaller text or be wider or something for a little less line wrapping ?
11:30:40 <monochrom> yeah, the reason I didn't see the menu on the right is precisely because when I use the user's guide TOC, first thing I do is scroll down to the really interesting part. (clearly, TOC for chapter 1 is really uninteresting.)
11:31:08 <sm> monochrom: though, if the toc doesn't scroll how are you going to use it.. it's huge
11:31:37 <monochrom> oh, I mean the right panel menu should be sticky
11:31:59 <sm> oh, sticky and independently scrollable ?
11:32:40 <sm> but this is dangerously close to heresy
11:32:45 <monochrom> my http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-1.xhtml shows an example. something scrolls, something sticks
11:33:01 <sm> (frames)
11:33:15 <monochrom> no, I don't need frames, that's the beauty of it.
11:33:33 <sm> monochrom: ok, what happens when that TOC is 5 screens high ?
11:33:43 <glguy> monochrom: The problem is that sometimes (due to having a copy of the TOC in it) the right side box is taller than the window
11:33:48 <monochrom> then I wouldn't do it
11:34:43 <monochrom> ah, I see, chapter 9 is an example
11:35:10 <sm> well, I'm sure there's some great js lib that solved these thorny questions long ago
11:35:41 <monochrom> oh! CSS can also do "two panels can scroll independently"
11:35:55 <sm> yeah chapter 9's TOC is actually 10 screens high here
11:36:05 <monochrom> heh 10 screens high
11:36:28 <sm> it's a scientific measurement technique
11:43:19 <minib00m> glguy: okay so preview (ix 0 . _1) $ myList is cool
11:43:30 <minib00m> now i would like to alter this element
11:43:40 <glguy> oops, you snuck in another operator
11:43:47 <minib00m> i found %~ does that
11:44:01 <minib00m> the dolar? :D
11:44:08 <glguy> Yeah, we're not giving out badges for operator use
11:44:24 <glguy> :-p
11:44:53 <glguy> > over (ix 0 . _1) (*3) [(10,20)]
11:44:54 <lambdabot>  [(30,20)]
11:46:44 <minib00m> that's great!
11:47:00 <minib00m> btw, why is ix 0 . _1 reversed
11:47:19 <minib00m> in normal function composition it the argument would be fed first to _1
11:47:21 <minib00m> then to ix 0
11:47:50 <glguy> In this context  _1 modifies a function that operators on Ints and makes one that operates on tuples
11:48:09 <glguy> ix 0 takes a function that works on tuples and makes one that works on lists of tuples
11:48:33 <glguy> Over puts that together with your function that works on Ints (*3)
11:48:47 <glguy> and makes a function that works on lists of tuples of Int and whatever
11:49:11 <glguy> It's backward if you try to think of _1 and ix 0 as accessors
11:49:16 <glguy> but they aren't that
11:50:15 <WzC> hmm is it possible to use something like '>=.' as a variable name in the definition of a function? I.e. something like: "f >=. x = <something>" instead of "f myGeq x = <something>" ? 
11:50:18 <minib00m> wow, lenses are so hard at first sight... :) 
11:50:22 <minib00m> thanks glguy
11:50:37 <maerwald> yeah, just remember to never look at the types :P
11:50:45 <glguy> > runIdentity (ix 0 (_1 (\x -> Identity (x*3))) [(10,20)])
11:50:46 <lambdabot>  [(30,20)]
11:50:52 <glguy> this is what it's expanding out to
11:51:22 <glguy> WzC: yes, use: f (>=.) x
11:52:17 <WzC> hmm ok thanks I'll try that 
11:54:00 <divVerent> why do we even HAVE infix operators? :)
11:54:05 <divVerent> e.g. why isn't (2 `id`) == 2
11:54:44 <divVerent> (in turn means, why isn't an "infix operator" just a postfix operator returning a function)
11:56:05 <c_wraith> mostly in that they don't make sense infix unless they take at least two arguments 
11:56:55 <divVerent> I mean, is this a deliberate restriction, or does it actually make parsing more regular/simpler?
11:56:57 <c_wraith> ah, I see the question. because that'd make precedences a nightmare. 
11:57:19 <divVerent> ah, I see
11:57:25 <divVerent> I did notice that in my case I need those parentheses
11:58:16 <c_wraith> consider making 2 + 3 * 4 work right without really calling them binary operators. 
11:58:25 <divVerent> so I suppose the deliberate restriction part (i.e. "(2 `id`)" being of the nonsense type Num (a -> b) => a -> b) is just to prevent nasty abuses?
11:58:34 <monochrom> > (2 `id`)
11:58:36 <lambdabot>  2
11:58:43 <divVerent> odd, it works there, but not in my ghci?
11:58:47 <divVerent> Prelude> :t (2 `id`)
11:58:50 <divVerent> (2 `id`) :: Num (t -> t1) => t -> t1
11:59:01 <c_wraith> there's an extension that allows postfix functions. 
11:59:10 <c_wraith> err, operators. 
11:59:13 <divVerent> ah, I see
11:59:30 <monochrom> @type (2 `id`)
11:59:31 <lambdabot> Num a => a
11:59:50 <c_wraith> but it punts on the precedence parsing to the binary operator logic. 
12:00:09 <divVerent> right, it just removes the restriction itself
12:00:13 <minib00m> glguy: you must be long time haskeller if you know such things :)
12:00:20 <c_wraith> actually, iirc, it requires a section. 
12:00:24 <divVerent> I wonder who/wat uses it
12:00:51 <c_wraith> a common example is postfix ! for factorial. 
12:01:10 <lpaste> babelchips pasted “Getting a pointer to a Data.Vector.Storable of (Float, Float, Float)” at http://lpaste.net/168542
12:01:10 <divVerent> right, but when it still requires the extra parentheses... may as well not have it
12:01:20 <divVerent> could imagine some uses in DSLs though
12:01:32 <divVerent> Something { weight = (3 kg) }
12:01:43 <divVerent> well, `kg` :P
12:03:54 <babelchips> I’m working with openGL.  Ideally i’d like to use my own data type for the x,y,z vertex data and to get a Storable ptr to feed to the GPU
12:04:09 <babelchips> This is the closest I’ve got by using a tuple
12:04:20 <babelchips> Any help greatly appreciated
12:04:47 <mizu_no_oto_work> babelchips: what library are you using, out of curisoity?
12:05:18 <divVerent> babelchips: let me guess, you want 16 bytes alignment on them too?
12:05:18 <babelchips> Graphics.GL
12:05:52 <babelchips> yes ideally
12:07:03 <ClaudiusMaximus> babelchips: maybe you want something like http://hackage.haskell.org/package/linear-1.20.5/docs/Linear-V3.html  (but V3's Storable doesn't do the 16byte alignment required in some GL circumstances, afaik - I'd use V4 for that case)
12:08:39 <babelchips> Ok - does Linear V4 compare to Data.Vector.Storable/Unboxed in terms of performance?
12:08:58 <KaneTW> how's goldfire's dependent haskell stuff coming along?
12:09:45 <minib00m> is it possible to use forkIO on monad transformers with IO at the base?
12:10:30 <ClaudiusMaximus> babelchips: i think operations on V4 would be faster, as they are less generic - but benchmark to be sure - they really serve different purposes though (small fixed size vectors vs operations on larger amounts of data)
12:10:57 <ClaudiusMaximus> babelchips: likely you will have a (Storable) Vector of V4 at some point
12:12:28 <c_wraith> KaneTW, as far as I know, it's on schedule. the TypeInType extension is the most recent step. 
12:13:12 <babelchips> ClaudiusMaximus: Just to clairfy is Linear.V4 instead of Data.Vector… or as a type to use with Data.Vector?
12:14:09 <Zemyla> minib00m: Try looking into this https://hackage.haskell.org/package/monad-control-1.0.1.0/docs/Control-Monad-Trans-Control.html
12:14:41 <ClaudiusMaximus> babelchips: i mean that you use both, V2/V3/V4 for each datum (eg vertex position/normal/texcood), and Vector to collect them all together (eg a whole mesh)
12:15:02 <minib00m> Zemyla: thank you, reading
12:18:33 <iphy> msgpack has a bug where decoding "Maybe a" results in an infinite loop (recursion) in fromObject: https://github.com/msgpack/msgpack-haskell/blob/master/msgpack/src/Data/MessagePack/Object.hs#L192
12:18:43 <iphy> any ideas how to fix this? I'm not ever sure how it happens
12:19:28 <iphy> class MessagePack a where fromObject :: Object -> Maybe a
12:20:11 <iphy> ok, I know
12:21:31 <iphy> ok, I don't know after all..
12:22:19 <babelchips> ClaudiusMaximus: Ok great.  Thank you.
12:23:48 <iphy> ok, fixed it, but I don't know if it's correct - it does the right thing, but I think the msgpack library generally violates some laws, so whatever
12:24:07 <hexagoxel> iphy: because that needs to be `obj -> Just <$> fromObject obj`
12:24:20 <iphy> yeah
12:24:26 <iphy> that's how I did it now
12:26:41 <hexagoxel> the one case that is not caught by the types.. done wrong :D
12:27:57 * hackagebot postgresql-simple 0.5.2.1 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.2.1 (LeonSmith)
12:32:35 <Denommus> life is curious when I find a Haskell framework easier to use than a JavaScript framework
12:33:17 <tmillc> Denommus: which framework?
12:33:21 <zomg> Denommus: many of the JS frameworks can be pretty damn complicated, especially the new ones :P
12:33:34 <Denommus> reflex-dom in comparison to CycleJS
12:37:17 <iphy> hexagoxel: yep, pull request made: https://github.com/iphydf/msgpack-haskell/commit/a8b706f4befc67978578c3fac57a57f7e70aa26e
12:37:31 <iphy> I hope they are responsive.. the last commit is june 2015
12:38:29 <dmj`> zomg: like react?
12:39:32 <zomg> in some ways yeah
12:40:20 <dmj`> zomg: I believe it
12:45:41 <SkyGuardian> can someone help me what book is a good book after chris allens book for haskell?
12:46:15 <suppi> SkyGuardian, what do you want to learn?
12:46:22 <Denommus`> my connection dropped
12:46:28 <SkyGuardian> fully master haskell
12:46:34 <monochrom> I wonder if you need more practice than more books.
12:46:39 <Denommus`> I was going to say that CycleJS is interesting, and simpler than React, but reflex-dom is still simpler and more elegant
12:46:53 <suppi> you can't read a book and master something
12:47:03 <suppi> the best thing you can do is practice, practice and practice more
12:47:03 <monochrom> Only a literature researcher can become a master by more reading.
12:47:11 <SkyGuardian> as in have complete knowledge to perform everything
12:47:24 <SkyGuardian> let me rephrase my question I apologize
12:47:28 <monochrom> there is no "complete" knowledge.
12:47:28 <suppi> make stuff, a lot of stuff, fail and learn from that
12:47:35 <SkyGuardian> Is there any book that builds on top of Chris Allens book
12:47:44 <suppi> there isn't
12:47:58 * hackagebot b9 0.5.20 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.20 (SvenHeyll)
12:48:21 <SkyGuardian> does the notes on Upenn build on top of it?
12:48:37 <suppi> notes?
12:48:45 <monochrom> no
12:49:00 <kadoban> SkyGuardian: There's likely a few places to go after that, off the top of my head NICTA (though much of it is redundant, it'd still be good practice), doing your own projects, maybe stuff like Okasaki's Purely Functional Data Structures, Bird's Pearls of Functional Algorithm Design, etc.
12:49:00 <suppi> just write programs. when you feel something isn't working come and ask here
12:49:03 <DrEntropy> start writing stuff. start using Haskell "In anger" 
12:49:16 <dmj`> DrEntropy: +1
12:49:19 <SkyGuardian> http://www.seas.upenn.edu/~cis552/lectures/Lec1.html
12:49:29 <kadoban> SkyGuardian: But kind of at the end of that book, you should definitely start just writing stuff.
12:49:44 <SkyGuardian> okay thanks man!
12:49:47 <dmj`> one must wrestle with ghc
12:50:03 <SkyGuardian> so those upenn lecture chaps are redundant? 
12:50:52 <suppi> if you are really bent on learning more stuff, perhaps this have something useful http://www.scs.stanford.edu/16wi-cs240h/
12:50:54 <kadoban> SkyGuardian: I never really got anything out of cis552, but I didn't look that hard. All that's available is some notes, right? It looked pretty sparse.
12:51:15 <SkyGuardian> thats what i figured lol wasnt sure
12:51:24 <SkyGuardian> they have two classes cis194 and cis552
12:51:24 <suppi> but i highly encourage you to stop reading and start writing. you can only reach enlightenment by doing
12:52:16 <monochrom> I have finished reading a swimming textbook. I want to read a second swimming textbook.
12:52:23 <suppi> or at least read source code instead
12:52:42 <glguy> monochrom: Oh, cool Which one?
12:52:49 <maerwald> "reading" for a programmer also means "doing", if it's code.
12:53:24 <SkyGuardian> im new to programming i just want to gather my intel before i start 
12:53:27 <monochrom> I made that up. I never read a swimming textbook.
12:53:32 <glguy> oh :(
12:53:33 <SkyGuardian> to make sure im doinng everything 
12:53:39 <kadoban> Step 1) Don't sink.
12:53:58 <suppi> SkyGuardian, did you do all the exercises in the book?
12:54:21 <SkyGuardian> nooo just bought the book
12:54:25 <DrEntropy> Step one - Cut blue wire. But first.... 
12:54:47 <suppi> did you read the book?
12:54:52 <cheater> monochrom: i read a diving textbook and you had to read the textbook in full before they let you dive.
12:55:04 <cheater> that's because you can DIE HORRIBLY if you don't know what you're doing! :-)
12:55:39 <cheater> so i'd say there's something to be said about knowing what you're doing, rather than jumping into the tire fire
12:56:05 <SkyGuardian> can someone give me programming languages that go good with haskell?
12:56:23 <DrEntropy> c ? 
12:56:37 <cheater> if you know haskell you'll find it easy to work with purescript, ocaml and rust
12:56:44 <kadoban> SkyGuardian: JS I guess, if you're doing GHCJS
12:57:21 <SkyGuardian> thanks guys for all the help!
12:57:30 <DrEntropy> Oh i may have misunderstood what you meant by "go good with"... I use c to implement glue from haskell to other 'stuff'.   
12:57:31 <SkyGuardian> lastly a bit off topic however nodejs or ruby?
12:57:33 <bitemyapp> SkyGuardian: Parallel & Concurrent Programming in Haskell is a good follow-up
12:57:53 <SkyGuardian> I read about you bitemyapp! not sure where
12:58:14 <monochrom> In fact it was an important lesson for me. I was sent to a swimming class just like other kids were. We started in shallow water, hands solidly grabbing pool edge, and practiced kicking. After some time, all the other kids were confident enough to let go and free-float, but I wasn't, despite the coach's encouragement and urging. Two weeks later, I finially gave it a try, and it was not so bad! At some point, you've got to just give it a try.
12:59:33 <maerwald> I don't understand what these metaphors are. Haskell is one of those languages that require a LOT of reading along some doing before you even get to beginner level. Just because of the sheer amount of concepts.
12:59:53 <maerwald> so yeah, keep reading
12:59:54 <SkyGuardian> SEE ^ he GETS ME
13:00:02 <maerwald> but not JUST reading
13:00:13 <kadoban> maerwald: They conversation was about what to do after reading Haskell Programming from First Principles, which should be a great start, especially with the exercises.
13:00:13 <SkyGuardian> agreed
13:00:25 <glguy> If you're just reading the whole time you definitely won't have to worry about making any mistakes
13:00:52 <cheater> with haskell it's a good thing if you have some simple code to play around with and change it and see what happens
13:00:56 <suppi> maerwald, haskellbook has over 1000 pages, i think that's more than enough reading...
13:01:04 <cheater> like a very simple game or something.
13:01:09 <cheater> like "guess the number".
13:02:05 <monochrom> and it does Monad, Foldable, Traversable, transformers etc to death. I am really not convinced there is anything more to read.
13:02:09 <SkyGuardian> unfortunately not in epub 
13:02:27 <SkyGuardian> bought it today but ya 
13:02:30 <SkyGuardian> cant wait 
13:02:42 <haskellNoob> hi all
13:02:47 <monochrom> instead, it's time to do things to test your understanding. (you will be surprised how much you got the wrong messages.)
13:02:54 <haskellNoob> got a question, lens related (the thing, not the package)
13:03:15 <SkyGuardian> so then the concurrent programming in haskell isnt needed?
13:03:20 <suppi> monochrom, there is always more to learn, but it should come from need.
13:03:41 <haskellNoob> get :: ((Int -> Const Int Int) -> Offset -> Const Int Offset) -> Offset -> Int
13:03:52 <haskellNoob> get l = getConst . l Const
13:03:58 <suppi> SkyGuardian, please, ask questions after you read a chunk of the book. you are trying to optimize prematurely
13:04:05 <haskellNoob> Oh wait, I should paste this somewhere I guess
13:04:16 <kadoban> SkyGuardian: It's hard to say "needed" or not. It's interesting and useful information, but it's not necessary to program, and you should get experience with your own code in between learning more stuff IMO.
13:04:19 <monochrom> Concurrent Programming in Haskell is needed. But I wonder if you are ready to read it right now, or you should do things before you are ready.
13:04:31 <SkyGuardian> ya i have ocd i apologize
13:04:41 <maerwald> we all have xD
13:04:50 <SkyGuardian> no .. i take meds for it lol
13:04:52 <monochrom> I don't.
13:07:23 <maerwald> anyway, I'll go with rms on this one: it's more useful to contribute to an existing opensource project rather than writing mini-programs in your basement. You get review and comments for free and you see how other people do things.
13:07:43 <maerwald> ofc, the bar is higher there, but hey...
13:07:58 <maerwald> why aim low
13:08:49 <SkyGuardian> lol 
13:09:06 <SkyGuardian> who programs in basements really lol
13:09:12 <maerwald> :(
13:09:17 <lpaste> haskellNoob revised “No title”: “Problems with custom lens” at http://lpaste.net/168546
13:09:18 <monochrom> I program on the second floor
13:09:49 * EvanR penthouse
13:10:01 <haskellNoob> There, I think that exactly explains the problem I'm having
13:10:24 <monochrom> basement is so passe when 1960s computers filled a whole room and could only find space in basements.
13:11:04 <monochrom> today's young people go to a cafe, take out a tablet, and program.
13:11:09 <SkyGuardian> anyone have opinions on ruby v nodejs
13:11:25 <glguy> haskellNoob: The problem is you're promising that you can use *any* f that has a functor constraint but you're then trying to assume that f is []
13:11:26 <kadoban> Well, neither one is haskell.
13:11:28 <SkyGuardian> you technically cant program on a apple tablet or android
13:11:35 <monochrom> what vs? I think they're similar.
13:11:43 <tmpasdfasdf> Hello. Could somebody please help out a beginner here? I'm trying to do some fixed-precision arithmetic. Namely, I want to generate a list of `Centi` (from Data.Fixed) numbers, the next number in the list being the previous plus a `Centi` constant. I came up with this: `take 5 [(1.01 :: Centi) * i | i <- [0..]]`, but this just gives me `[0.00,0.01,0.02,0.03,0.04]`, while I want `[1.01, 2.02, 3.03, 4.04, 5.05]`.
13:11:43 <sm> kadoban: that's just, like, your opinion man
13:11:58 <glguy> haskellNoob: The caller of testModify gets to pick what f is
13:12:11 <tmpasdfasdf> Funnily, when I multiply by a constant (like `2`) instead of `i`, the multiplication seems to work as expected.
13:12:14 <maerwald> I almost misspelled *duck typing here, sheesh.
13:12:49 <glguy> ti) * i | i <- [0..]]
13:13:01 <crough> tmpasdfasdf: fmap (* 1.01) [0..]
13:13:06 <crough> why not just do that?
13:13:20 <haskellNoob> glguy: but the problem is that for modify, f is [] and for get it's Const
13:13:28 <glguy> > take 5 [i::Centi | i <- [0..]]
13:13:29 <lambdabot>  [0.00,0.01,0.02,0.03,0.04]
13:13:55 <crough> > take 5 ((*) 1.01 <$> [0..])
13:13:57 <lambdabot>  [0.0,1.01,2.02,3.0300000000000002,4.04]
13:14:04 <tmpasdfasdf> glguy: yeah, that's the problem. Why isn't it [1, 2, 3, 4, 5]?
13:14:05 <crough> haha floats, but you get it
13:14:14 <tmpasdfasdf> crough: i mean, starting from zero.
13:14:33 <SkyGuardian> sorry i asked about that in the wrong chat room
13:14:35 <SkyGuardian> my bad
13:14:41 <haskellNoob> glguy: there must be a way for me to say "just keep it as a Functor even if a called function picks a concrete type.  Otherwise, how is the real lens package doing it?  I assume you can set and view i the same statement
13:15:01 <tmpasdfasdf> crough: it's a bit more complicated, the constant is not actually 1.01, it's also dynamic `Centi` number
13:15:04 <SkyGuardian> thanks everyone for the help again thanks!
13:15:16 <glguy> haskellNoob: Lens does it either using rank-2 types, the ReifiedLens type, or ALens type along with cloneLens
13:15:42 <crough> tmpasdfasdf: let gen : Centi -> [Centi]; gen c = fmap (*c) [0..]
13:16:17 <haskellNoob> glguy: so what would be the cheapest way to do what I'm trying to do here?  I'm using [] as a cheap (i.e. in base) version of Identity
13:16:25 <glguy> tmpasdfasdf: Yeah, the [0..] behavior of Centi is surprising.
13:16:43 <crough> haskellNoob: Identity is in base
13:16:50 <crough> haskellNoob: since 4.8 iirc
13:16:53 <monochrom> tmpasdfasdf: I don't think anything says that Enum instances must go 0, 1, 2, 3. Instead, since Centi's purpose is fractions of 2 decimal places, I'm pretty sure it is useful to go 0, 0.01, 0.02, 0.03.
13:17:05 <glguy> > take 5 [i::Centi | i <- [0,1..]] -- tmpasdfasdf you can do this
13:17:06 <lambdabot>  [0.00,1.00,2.00,3.00,4.00]
13:17:13 <monochrom> It is afterall a complete enumeration of all 2-decimal-place fractions.
13:18:04 <tmpasdfasdf> glguy: huh? [0..] doesn't work, but [0,1..] does? a bit surprising i would say
13:18:19 <glguy> ok
13:18:26 <tmpasdfasdf> glguy: do you buy any chance know why?
13:18:32 <tmpasdfasdf> glguy: or any pointers?
13:18:33 <haskellNoob> crough: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Identity.html    <----- seems to indicate it's in mtl
13:18:33 <hpc> > [0..] :: Centi
13:18:35 <lambdabot>      Couldn't match type ‘[Integer]’ with ‘Data.Fixed.Fixed E2’
13:18:35 <lambdabot>      Expected type: Centi
13:18:35 <lambdabot>        Actual type: [Integer]
13:18:51 <hwkng> there are very obvious/elegant ways of writing scheme/sexp parsers. Are there any obivous/clean ways of writing a parser for a haskell-like language (infix, user defined operators, whitespace-indenting)
13:19:14 <hpc> > [0..] :: [Centi]
13:19:15 <lambdabot>  [0.00,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.10,0.11,0.12,0.13,0.14,...
13:19:16 <monochrom> [x..] calls a different function from [x, y..]
13:19:17 <crough> haskellNoob: look at Data.Functor.Identity
13:19:18 <hpc> ah there it is
13:19:33 <haskellNoob> crough: aha, yea just saw that clicking on Identity
13:19:35 <hpc> it's stepping by epsilon instead of 1.0
13:19:40 <tmpasdfasdf> hpc: any idea why this happens? does it have to do with [0..] deriving Enum or something?
13:19:48 <xa0> > 1 :: Centi
13:19:49 <lambdabot>  1.00
13:19:50 <crough> haskellNoob: Data.Functor.* has a bunch of fun functors, even in base :)
13:19:52 <hpc> it's the enum instance for Centi
13:19:59 <haskellNoob> crough: I thought the last time I played with this, cabal told me I needed mtl
13:20:02 <glguy> hpc: We covered that part
13:20:03 <hpc> someone just decided it should do that
13:20:12 <xa0> > succ 1 :: Centi
13:20:13 <lambdabot>  1.01
13:20:18 <crough> haskellNoob: It may have-- I think that module showed up in base recently
13:20:18 <tmpasdfasdf> hpc: so [0..] steps by epsilon by default?
13:20:27 <tmpasdfasdf> huh, who kney
13:20:32 <tmpasdfasdf> *knew
13:20:43 <hpc> s/by default//
13:20:49 <crough> tmpasdfasdf: it steps by enumerating all possible values
13:21:06 <hpc> arguably that's the correct way to do it too
13:21:07 <crough> tmpasdfasdf: you get the `x .. y` syntax from the Enum instance
13:21:11 <hpc> and what Float/Double do is the wrong way
13:21:12 <monochrom> I wonder if anyone saw what I said.
13:21:25 <tmpasdfasdf> crough: oh, i see
13:21:26 <crough> hpc: oh god do float and double do it that way? that's terrible
13:21:33 <hpc> > [1.0 ..]
13:21:35 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
13:21:43 <crough> hpc: I am very saddended by this
13:21:54 <hpc> > [1234567.0 ..] :: [Float]
13:21:55 <lambdabot>  [1234567.0,1234568.0,1234569.0,1234570.0,1234571.0,1234572.0,1234573.0,12345...
13:22:01 <hpc> > [12345678.0 ..] :: [Float]
13:22:03 <lambdabot>  [1.2345678e7,1.2345679e7,1.234568e7,1.2345681e7,1.2345682e7,1.2345683e7,1.23...
13:22:12 <haskellNoob> crough: Have you been following my larger problem?
13:22:26 <hpc> hmm
13:22:26 <tmpasdfasdf> whoa, ok, that's pretty cool
13:22:30 <crough> haskellNoob: No not very well. I pop in and out of paying attention at work
13:22:34 <hpc> i probably need to add a ton of digits, and then it won't show up
13:22:45 <hpc> there's a point for floats and doubles where epsilon > 1
13:22:57 <crough> haskellNoob: Basically, I jump in a while at lunch :)
13:23:08 <hpc> and for Float it's reeeeaaaally close to a range of numbers you would expect to regularly encounter
13:23:29 <glguy> > take 3 [2^53-1 :: Double .. ]
13:23:30 <lambdabot>  [9.007199254740991e15,9.007199254740992e15,9.007199254740992e15]
13:23:35 <haskellNoob> crough: Fair enough, the issue is I'm trying to use a get on a lens, which must use Const and a modify on a lens, which must use [] (now Identity) but the first use is locking in what Functor f is.
13:24:00 <haskellNoob> crough: I don't even know where to look online to figure out how to deal with this because I don't know how to describe it
13:24:04 <glguy> haskellNoob: You'll have to use any of the 3 techniques I mentioned
13:24:53 <tmpasdfasdf> ok, thank you guys, good to learn this stuff
13:25:20 <haskellNoob> glguy: Rank2 (if I just look up Rank2, is this a common situation so I'll immediately see what else is needed?  I'm guessing just turning on Rank2 won't be enough), and a couple of type setups that are probably pretty elaborate
13:26:38 <shachaf> The third thing glguy said, with cloneLens, is probably the simplest.
13:27:21 <glguy> shachaf: except haskellNoob is reimplementing lenses and doesn't have that one already
13:27:31 <shachaf> Oh.
13:27:49 <shachaf> Then I should've read more scrollback.
13:27:59 * hackagebot JuicyPixels 3.2.7.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.7.2 (VincentBerthoux)
13:28:01 * hackagebot foobar 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/foobar-0.1.0.0 (parsonsmatt)
13:28:03 * hackagebot monad-logger-prefix 0.1.0 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.0 (parsonsmatt)
13:28:03 <shachaf> It might still be the best approach.
13:28:23 <hpc> ooh new juicypixels
13:28:33 <shachaf> foobar? Exciting package.
13:28:51 <shachaf> Author name here is very prolific.
13:28:59 <haskellNoob> basically what I'm doing is: I'm writing a library that exposes some data types.  For accessors, I'm just exposes lens compatible accessors as described by ekmett on his wiki
13:29:17 <shachaf> Ah, I see.
13:29:34 <shachaf> And you run into cloneLens-style issues in that context?
13:29:37 <haskellNoob> I don't want a lens dependency on my library, and I shouldn't need one.  Just for testing I would need it, but a simple get / modify is easy enough to define
13:30:01 <haskellNoob> I guess what I've run into is a Rank 2 types issue (been reading up on it now, it's not what I thought it was)
13:30:23 <haskellNoob> because to test that modify actually.... modified, I need to get right after but get has to use a different f than modify does
13:34:50 <haskellNoob> so I included Rank2Types and put a forall f. in front of Functor f =>   .... no love
13:36:53 <xa0> should be Functor f => forall f. ..., not forall f. Functor f => ...
13:37:42 <glguy> xa0: no, that doesn't look right
13:37:43 <shachaf> xa0: What?
13:38:09 <xa0> am i wrong? 
13:38:15 <xa0> sorry, long day...
13:39:31 <haskellNoob> Actually, I tried xa0's suggestion and it said I needed AmbiguousTypes
13:40:06 <haskellNoob> turning that on makes it compile.... haven't tried to run it.  Especially since I just noticed that if I do this exact same thing in a lambda it works perfect without Rank2Types.....
13:40:19 <glguy> haskellNoob: If you want a polymorphic function argument with RankNTypes you'll need:
13:40:32 <glguy> testModify :: (forall f. Functor f => ....) -> The -> Other -> Stuff
13:42:53 <MichaelK> If I get a "Pattern match(es) are overlapped" warning only when I have a catch-all final case, does that mean I've covered all possible cases?
13:42:57 <Timvde> How well can you control performance in Haskell? (e.g. data locality for optimal cpu cache usage). I'm an experienced imperative programmer with barely any Haskell knowledge, and I'm wondering if it would be suitable for really performance-critical code.
13:43:07 <haskellNoob> glguy: ah, I tried (forall f. Functor f) =>       I didn't try wrapping the whole first function.  Thanks, that appears to work.  Still strikes me as odd that I can do exactly the same thing in a lambda with no extension
13:44:14 <glguy> haskellNoob: I don't know what you tried with a lambda, but in Haskell function arguments are monomorphic
13:44:22 <MichaelK> Timvde: I've had some success dropping down to primitive ops: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate/docs/GHC-Prim.html
13:44:58 <haskellNoob> QC.testProperty "modify hours offset" $ \d@(Positive s, Positive m, Positive h) -> h < 13 && s < 55 && m < 55 QC.==> get seconds (modify (+5) seconds  (offset s m h)) == ((+5) . secs) d
13:45:46 <haskellNoob> that worked.  Is it because I say the lens (seconds) twice, so each one is decided as a different type and it can't work in the second because it's passed as a variable?
13:45:52 <glguy> haskellNoob: Since you aren't passing the lens as a parameter it's still polymorphic. top-level, where-bound and let-bound definitions can be polymorphic
13:46:15 <glguy> so each use of seconds can pick its own instantiation of the polymorphic type
13:46:43 <haskellNoob> ok, that makes sense.  But that would mean if I changed testModify to take 2 different lenses and then just pass seconds in each one, that would also work, yes?
13:46:48 <glguy> yeah
13:47:08 <haskellNoob> cool, thanks everyone for your help.
13:47:33 <haskellNoob> I knew there would be an easy way to do this, I just lacked the vocabulary to ask google. :)
13:48:10 <augur> is there a way to know whether or not a package version depends on a particular version of GHC?
13:50:08 <MichaelK> augur: I'm not sure, but you could always check the required version of `base` and see what GHC that requires
13:51:07 <augur> MichaelK: base is also a package, so that just pushes the question back one level
13:52:22 <monochrom> except that base version is in bijection with GHC version
13:54:12 <monochrom> most community packages do not actually want to constrain GHC version. they would rather go out of their way to support more versions with a hell lot of #ifdef's
13:54:58 <babelchips> I have a question about memory layout differences between ‘Data.Vector.Storable Float’ and ‘Data.Vector.Storable Linear.V3 Float’.
13:55:06 <maerwald> except those ifdefs are ugly version checks, which I don't find satisfying
13:55:45 <monochrom> yeah, but if you're a user of such a package, all you need to check is "try build it".
13:56:32 <babelchips> If I lay out 3 times as many Storable Float as Linear V3 Float, shouldn’t they be the same?
13:56:33 <monochrom> you're in good company with Doug McIlroy in saying "if you use #ifdef, you've already lost"
13:59:34 <minib00m> is there any haskell opensource project that is not hard to get into contributing to for 6-months haskeller?
13:59:49 * maerwald waits for people posting their own projects :D
13:59:55 <minib00m> lol
14:00:52 <minib00m> could be your projects guys :D 
14:00:57 <KaneTW> GHC
14:01:00 <KaneTW> *hides*
14:01:19 <maerwald> minib00m: are you familiar with gtk?
14:01:41 <sm> this is getting to be quite a FAQ
14:01:59 <maerwald> minib00m: I mean, is there anything you are particularly familiar with yet?
14:02:20 <glguy> minib00m: You should start using Haskell code to do stuff for yourself, figure out what packages or programs are useful to you, fix or improve that package as needed to support what you're doing, and fold those improvements back into the upstream project
14:03:06 * sm holds up the his [ hledger needs you! ] sign
14:12:46 <minib00m> maerwald: i didn't master any library yet
14:13:04 <minib00m> glguy: what you mean code stuff for myself? 
14:13:34 <minib00m> now i'm trying to code some turn-based simple game, that will take me a while
14:14:05 <sm> minib00m: good idea, games are fun
14:14:11 <minib00m> but i thought that maybe it would be better if i spend my time on some useful project and in the same time i could learn haskell :)
14:15:20 <maerwald> hard to recommend something without knowing what kind of domains you know about
14:15:31 <sm> hledger is my accounting project (didn't you see my sign ?), you'd be welcome there
14:17:21 <minib00m> sm: wow! that's some great amount of commits you got there :D
14:17:30 <monochrom> bind has joined, fmap has lifted, and return has not returned.
14:18:00 * hackagebot beam-th 0.1.0.3 - Template Haskell utilities for beam  https://hackage.haskell.org/package/beam-th-0.1.0.3 (hesiod)
14:18:09 <adarqui> any idea how to fix this stack issue on osx? http://hastebin.com/qumezedoku.txt .. haven't seen this before. trying to upgrade to the latest purescript and im getting missing library errors etc, but when i stack install those libraries specifically, they already exist
14:18:12 <sm> uh.. thx. if I were better, I'd have used fewer :)
14:19:53 <sm> Je n’ai fait celle-ci plus longue que parce que je n’ai pas eu le loisir de la faire plus courte.
14:28:56 <minib00m> sm: http://lpaste.net/168550 
14:29:40 <sm> minib00m: is there a reason for using ghc 8 ? it's not yet mainstream
14:29:47 <minib00m> is it something wrong with my stack or there are missing deps in your stack-ghc8.taml?
14:29:51 <minib00m> yaml*
14:30:34 <sm> not sure, I would try stack install hsc2hs first. Tools like that are not installed automatically by stack/cabal unfortunately
14:31:00 <EvanR> reasons to use ghc, it has crazy new features
14:32:37 <maerwald> no instructions to build with cabal... meh
14:32:54 <minib00m> i think i have messed up stack/ghc
14:33:16 <glguy> hsc2hs comes with GHC
14:33:22 <maerwald> ah, there is buildSandbox.sh
14:33:29 <maerwald> minib00m: just ditch stack and use cabal
14:33:31 <barrucadu> Hmm, I've never used hledger before, but I keep hearing nice things. I should give it a go.
14:33:59 <sm> maerwald: cabal install ./hledger-lib ./hledger [./hledger-ui] [./hledger-web]
14:34:17 <maerwald> sm: I just found buildSandbox.sh, which does what I want, yeah
14:34:36 <sm> ok, I didn't make that but great :)
14:34:50 <mgsloan> minib00m: Did you try doing the things it suggests doing?
14:35:06 <maerwald> stack should suggest "try without stack first" ;)
14:35:10 <mgsloan> One of the thing that stack really tries to prioritize is having messages suggest what to do next.
14:35:25 <minib00m> mgsloan: yes, it suggests running stack setup
14:35:34 <mgsloan> Unlike cabal, maerwald.   Please don't mislead people to use tools with terrible UX, where the problem of constraint solving is the priority, not building your code
14:35:43 <minib00m> and it tries to download and install ghc-7.10.3
14:35:47 <sm> I'm sorry for not mentioning cabal on the download page.. I spent the first N years of hledger trying to document every possible installation failure mode, and stack has been a godsend
14:35:50 <maerwald> mgsloan: erm, I am not misleading people
14:35:51 <minib00m> but i get messages like: /home/minib00m/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
14:35:52 <glguy> No, using cabal is not something you get to scold people about
14:36:18 <mgsloan> glguy: Feel free to use cabal, but if you say that stack should suggest to switch to cabal-install, that is absurd
14:36:20 <maerwald> mgsloan: I think stack fanboys mislead people in thinking stack is more than a deployment tool and can solve all your cabal problems (which it doesnt)
14:36:30 <mgsloan> glguy: I mean not you, (maerrwald)
14:36:33 <sm> to conserve my time, I now recommend stack
14:36:50 <mgsloan> To conserve the communities time as a whole I recommend and actively develop it
14:37:11 <maerwald> maybe you should still let people have their opinions
14:37:39 <maerwald> I've had more trouble with stack than anything and people constantly try to tell me that I have problems with cabal-install. Weirdly enough, I don't.
14:37:57 <monochrom> negative opinion is less valuable than horror stories.
14:37:58 <maerwald> and hledger just built fine
14:38:07 <maerwald> (with cabal only)
14:38:17 <monochrom> a horror story at least tells me how to reproduce the problem
14:38:18 <maerwald> while you are strill trying to figure out how to get it to work with ghc-8 
14:38:36 <monochrom> a position statement tells me nothing
14:38:47 <mgsloan> "stack install hledger --resolver nightly". Done.
14:38:58 <monochrom> in fact, positive opinions are similarly valueless too.
14:39:12 <Robin_Jadoul> minib00m: you probably need your systems dev package for libtinfo
14:39:40 <mgsloan> Confused users just tells me we need to make the output clearer
14:39:53 <mgsloan> That particular message is already greatly improved on HEAD
14:40:07 <mgsloan> First of the output to get pretty-printer-ified + ansi-ified
14:40:50 <mgsloan> Or the docs.  Or add cartoons to the docs
14:41:35 <sm> minib00m: stack-ghc8.yaml needed text-zipper as extra dep. Fixed now, thank you
14:41:58 <mgsloan> Anywho, sorry to get peaved, don't quote me out of context, cabal-install does some pretty cool stuff too ;D
14:42:10 <mgsloan> And Cabal has proven not-too-bad to wrap in stack itself
14:42:25 <mgsloan> gtg, peace out, y'all
14:42:38 <minib00m> Robin_Jadoul: thanks for the hint
14:43:30 <sm> mgsloan: and you're right, it recommended that I do exactly that. Nice job. Wish I'd read the bottom of the error output first
14:43:47 <minib00m> sm: seems to work, build is proceeding :)
14:44:51 <barrucadu> sm: The tab-completion of account names in `hledger add` is very nice
14:45:05 <sm> courtesy of haskeline!
14:46:44 <sm> we have a really great ecosystem of libs which has been hardly tapped yet
14:53:58 <minib00m> sm: your code base is so huge :P 
14:55:25 <maerwald> minib00m: check out xmonad maybe, configuring it is basically writing haskell
14:55:36 <maerwald> and the codebase is not that huge afais
14:56:38 <minib00m> maerwald: is it... configuring my X's with haskell? 
14:56:48 <maerwald> it's a tiling window manager
14:57:41 <barrucadu> sm: Just re-entering the transactions from a couple of weeks ago and I've already discovered a small arithmetic error I made when I worked it out myself. I think I'm sold :)
14:58:02 <sm> excellent
14:58:39 <sm> minib00m: well, if you're looking at all the packages..
15:05:51 <sm> maerwald: buildSandbox.sh renamed to cabal-install.sh and now installs hledger-ui
15:06:28 <maerwald> sounds good
15:17:13 <sboosali> hi, can I get the main thread id, like myThreadId?
15:18:27 <hpc> myThreadId :: IO ThreadId
15:18:36 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent.html#t:ThreadId
15:18:49 <jle`> i'm guessing the question is probably about getting the "global" 'main' thread id
15:18:57 <jle`> from some arbitrary forked thread
15:19:10 <sboosali> jle1: right
15:19:15 <sboosali> jle1`: right
15:19:16 <glguy> sboosali: no
15:19:24 <hpc> oh yeah, there's no way to do that
15:19:30 <hpc> get it in the main thread and pass it through
15:19:32 <sboosali> ok thanks
15:19:44 <sboosali> yeah i thought of that
15:19:51 <sboosali> but i'm writing this
15:20:04 <sboosali> beginRunLoop = do   isOnMainThread <- (==) <$> myThreadId <*> mainThreadId    if   isOnMainThread   then throwS "{NSSpeechRecognizer.Bindings.beginRunLoop} must be run on only the main thread"   else beginMainRunLoop
15:20:10 <sboosali> eh
15:20:11 <jle`> you might be able to do some tricks with those "global variable" hacks
15:20:27 <jle`> (but
15:20:30 <jle`>      don't)
15:20:31 <sboosali> http://lpaste.net/168552
15:20:56 <sboosali> it's very simple, just calls NSRunLoop (Objective-C), which seems to not reply to events unless on the main thread
15:21:12 <sboosali> so i wanted to warn the user, rather than silently failing
15:21:57 <jle`> i might consider that a bug in NSRunLoop ?
15:22:20 <sboosali> jle`: that's a good idea. hacky, but might better than nothing. 
15:22:29 <sboosali> no
15:22:32 <glguy> sboosali: Does it have to be the main thread or just any bound thread?
15:22:33 <glguy> isCurrentThreadBound :: IO Bool
15:22:52 <sboosali> idk it might be something complicated involving ghc runtime
15:23:05 <sboosali> yeah i tried forkOS, didn't work
15:23:17 <sboosali> well, i don't really know much about ObjectiveC, or OS threads for that matter
15:23:25 <sboosali> glguy: can you explain?
15:24:56 <glguy> Which part?
15:25:49 <sboosali> glguy: afaik, bound threads mean that ghc won't move your thread from the os thread it's initially spawned in
15:26:28 <sboosali> glguy: so maybe some thread-local data is being wiped if the thread is switched to another os thread?
15:26:55 <sboosali> glguy: either way, i had tried that a while back (just replacing forkIO with forkOS), and it didn't seem to work, not that I knew what I was doing
15:27:26 <sboosali> glguy: is that what you meant? 
15:28:33 <glguy> yeah, it makes sure that all foregin calls go out on the same thread and that when those foreign calls reenter the runtime that you're still on the same "bound thread"
15:29:07 <glguy> but if the orignal main thread (which is bound) already had some important aspect to it (identity or thread local state) then making a new bound thread won't help
15:29:26 <glguy> but we don't know what you're actually doing that needs bound threads
15:29:37 <sboosali> glguy: right
15:31:14 <sboosali> what i should do is see if forking the thread within Objective-C (like in XCode) works or not. But, didn't seem worth it (have to use delegates). 
15:31:44 <sboosali> laziness lets me evaluate an arbitrary expression in another thread, i've forgotten how awesome that is
15:35:00 <joe9> This is my cabal install command: cabal install --enable-shared --enable-executable-dynamic . I want to specify the flags shared and executable-dynamic in the .cabal file. Is that possible?
15:35:15 <joe9> I do not want to specify these flags in my global cabal config file.
15:35:35 <joe9> Just want these flags for one executable only (and it's related libraries)
15:36:39 <joe9> When I tried this line "executable-dynamic: true" in my .cabal file, I got an error
15:37:45 <luite> joe9: that setting is intended to be decided by the user and not the packager
15:38:06 <luite> joe9: but you can use a local cabal config file
15:38:31 <joe9> luite, "a local cabal config file" -- just for the project? Is that possible?
15:39:07 <monochrom> joe9: Firstly on --enable-shared. You shouldn't need it and you shouldn't overrule it if your GHC version and cabal version are pretty recent. It is for building libraries, and ghci itself needs libraries built with it, that's why it's the default and you shouldn't overrule it.
15:40:21 <luite> joe9: have a cabal.config file in the project dir, but I'm not 100% certain if this requires a sandbox
15:40:22 <joe9> monochrom: oh, ok. I just found out that I am getting the same executable size without the flag --enable-shared. I just need --enable-executable-dynamic then.
15:41:28 <joe9> luite, cool, that worked.
15:41:43 <monochrom> ok good
15:41:48 <joe9> luite, I just added a cabal.config file in this project's dir and it took that flag.
15:42:15 <monochrom> --enable-shared is for libraries rather than exes.
15:42:40 <monochrom> wait, I already said that last time
15:42:42 <joe9> monochrom: ok, Thanks. I will not bother with it.
15:53:04 * hackagebot hoppy-generator 0.2.0 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.2.0 (khumba)
15:53:06 * hackagebot hoppy-runtime 0.2.0 - C++ FFI generator - Runtime support  https://hackage.haskell.org/package/hoppy-runtime-0.2.0 (khumba)
15:53:08 * hackagebot hoppy-std 0.2.0 - C++ FFI generator - Standard library bindings  https://hackage.haskell.org/package/hoppy-std-0.2.0 (khumba)
15:53:10 * hackagebot hoppy-docs 0.2.0 - C++ FFI generator - Documentation  https://hackage.haskell.org/package/hoppy-docs-0.2.0 (khumba)
16:08:04 * hackagebot lol 0.4.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.4.0.0 (crockeea)
16:08:06 * hackagebot lol-apps 0.1.1.0 - Lattice-based cryptographic applications using Lol.  https://hackage.haskell.org/package/lol-apps-0.1.1.0 (crockeea)
16:59:13 <iphy> http://lpaste.net/168559 <- can I do something like this?
16:59:22 <iphy> it doesn't work, so I'm wondering which way it would work
17:00:16 <iphy> the intention is to get the runtime type name of the result type
17:01:27 <glguy> iphy: You need to use ScopedTypeVariables to link the 'a' in your top-level type to the 'a' in your type annotation on Proxy
17:01:41 <glguy> and then you can shed all the type class constraints from the Proxy annotation
17:01:41 <iphy> I have ScopedTypeVariables
17:01:51 <glguy> you need to use the "forall" keyword then
17:02:02 <glguy> You'll be left with: (Proxy :: Proxy a)
17:02:25 <iphy> forall works :)
17:04:12 <glguy> demo 07:: forall a07. Typeable a 07=> Tagged a String
17:04:19 <glguy> demo 07= Tagged (tyConName (typeRepTyCon (typeRep (Proxy 07:: Proxy a))))
17:13:04 <gtsteel> I'm getting an overlapping instances error with no overlap
17:13:36 <geekosaur> remember the context does not take part in instance selection
17:13:39 <gtsteel> I have defined `instance Monoid (MakeHTM Elem)` and `instance Monoid a => Monoid (MakeHTM a)`
17:14:06 <gtsteel> Elem is not an instance of Monoid but I am getting an overlap error
17:14:09 <glguy> a overlaps Elem
17:14:14 <geekosaur> as I just said
17:14:35 <gtsteel> so how do I get them not to overlap?
17:14:41 <glguy> delete the a instance
17:15:21 <gtsteel> Do i need to replace that with specific instances for all the other monoids of interest?
17:15:28 <glguy> right
17:16:05 <glguy> you can name the implementation of the class methods so that you only have to write them once
17:16:48 <glguy> It would be even better if you could delete the MakeHTM Elem instance
17:16:56 <glguy> and have them all use the MakeHTM a one
17:19:09 <gtsteel> unfortunately, elem has no monoid structure
17:20:13 <glguy> It might not even be necessary for MakeHTM to have a Monoid instance at all
17:21:55 <gtsteel> I am making a combinator library for emitting HTML in Haste
17:22:21 <gtsteel> monoid operations are quite useful.
17:23:54 <gtsteel> I decided that the elem instance was more important than the general Monoid one and went with the specific instances suggestion
17:39:45 <dgpratt> I'm interested in experimenting with stack and ghcjs
17:41:01 <dgpratt> found this http://docs.haskellstack.org/en/stable/ghcjs/ but it doesn't give much if any explanation of the possible options or why the particular given settings are what they are
17:41:53 <kadoban> dgpratt: It's largely just a magic incantation to get stack to be able to install ghcjs for you
17:42:39 <dgpratt> where do those ghcjs builds come from? the ghcjs github project?
17:42:41 <MichaelBurge> How do you guys usually handle name collisions on constructors or fields in a larger project? I've been using a naming convention like 'type_constructor_field': http://hastebin.com/evocadafim.hs
17:43:38 <kadoban> dgpratt: Oh that, yeah I dunno who is hosting that one. I don't know that I'd trust it myself. It's a bit annoying because GHCJS doesn't have actual releases yet. I think there's a couple you can use instead from at least the official ghcjs github repo, but I don't have the line on me to do it.
17:44:06 <dgpratt> I see, thanks kadoban
17:45:56 <dgpratt> is there a set of ghcjs builds that stack "knows about" (i.e. can be referenced without specifying source)? where would they be defined?
17:47:22 <mgsloan> dgpratt: There is only one, and it is old.  It is the "old-base" release.  It is official because it's stable
17:47:39 <mgsloan> This is because there are no official ghcjs releases
17:47:46 <dgpratt> I see
17:48:00 <mgsloan> Which sucks, we should fix that https://github.com/ghcjs/ghcjs/issues/481
17:48:21 <mgsloan> Sounds like Luite is almost done porting it to GHC 8, maybe a release can happen after that
17:49:05 <mgsloan> So yeah, these configurations are just when someone said "Hey I'll package up a source dist and tag it with today's date"
17:49:19 <dgpratt> I feel like I've seen several references to folks using ghcjs -- considering that, the path is not as well trod as I would have thought
17:50:06 <mgsloan> Yeah, it's well trod, but not to the point of being silky smooth
17:50:26 <mgsloan> The folks that are using GHCJS are willing to put up with some setup and growing pains
17:50:53 <mgsloan> I tried to control enough with "stack setup" to make it just work for people
17:51:35 <dgpratt> your efforts are appreciated, mgsloan
17:51:58 <dgpratt> wouldn't dare tackle it if not for that
17:53:16 <kadoban> mgsloan: Do you know who actually did that package of ghcjs that it's linking to? I like to at least know who I'm trusting :-/
18:03:25 <dgpratt> if one does "stack new blah" and does not specify a template name, does it default to new-template?
18:04:22 <dgpratt> and does the template affect or determine what resolver gets used?
18:06:58 <kadoban> dgpratt: Yes and no, respectively. You can set what the default template is though, if you want to.
18:07:15 <kadoban> So the default default is new-template, but you can set your own default.
18:07:44 <dgpratt> I see -- for a new project, what determines what resolver is selected?
18:08:11 <kadoban> It just does the same thing that 'stack init' does AFAIK.
18:08:43 <kadoban> It tries to match whatever ends up in the .cabal file I suppose? So in that sense I guess the template affects what resolver is chosen.
18:09:07 <dgpratt> ah
18:09:14 <dgpratt> ok, thanks kadoban
18:09:20 <kadoban> 'welcome
18:31:00 <iphy> http://lpaste.net/168568 <- what does this cabal error message tell me?
18:31:13 <iphy> what exactly is failing there? can I fix it by pinning some versions?
18:48:10 * hackagebot cartel 0.18.0.2 - Specify Cabal files in Haskell  https://hackage.haskell.org/package/cartel-0.18.0.2 (OmariNorman)
19:36:31 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
19:36:31 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:43 2016]
19:36:31 --- names: list (clog litriv lsep2 wilx kurt11 rabisg Squarism hexagoxel exferenceBot Sam_ pyon I-Win tmtwd justanotheruser FreeBirdLjj dhruvasagar kunaaljain______ fcpga_te FjordPrefect zenjyn jmcarthur bloodwire conal radoye tag Goplat edsko ThatOtherPerson rrradical j2j ashishnegi herzmeister DiCablo rofer TxmszLou Cale wraithm sebleblanc systemfault ekinmur andyhoang_ tpsinnem phileas lambda-11235 fizbin i-amd3 Rotaerk plutoniix xaviergmail Kristler andyhuzhill Lokathor)
19:36:31 --- names: list (Big_G jungnam dgpratt bencryption Rodya_ Zekka alunduil ype gtsteel Uakh rgrinberg Nik05 jedws desophos Welkin moei tripped rootnode predator117 markus1189 zero_byte Sorella dan_f Deadhand dedgrant st0opkid taksuyu darkf Koterpillar nkaretnikov electrostat MrDetonia darkbolt Quashie_ jsmnsr sdothum chlong alang dmj` mgsloan aarvar Sgeo_ MichaelBurge mdarse MP2E edmund Guest34807 UnlikeSuika Partmedia thunderrd bind ironChicken noam Timvde glguy dmiles)
19:36:31 --- names: list (irishsultan albertus1 hawk78 montanonic hwkng icosahedral skeuomorf kungp copy` sarfraz hiratara slomo athinggoingon logcat dicioccio bergmark Yaiyan fairfieldt Twey ahf Eagle_Erwin yfeldblum mads- Fuuzetsu indiffernet lnx aaron7 trajing owa nyef` xaxisx marchelzo WzC ijp doomlord MichaelK mda1_ M-cpt bb010g[m] wolfcub araujo_ zudov dmwit douglascorrea crough jcreekmore rhovland Jinxit bb010g Guest40185 tommd Mikasa- garphy`aw howdoi benwbooth fiddlerwoaroof)
19:36:31 --- names: list (trism biscarch ludat Kruppe- mimi_vx djm aleator gniourf qnix georgew spinda tgeeky urodna HEGX64 Morgawr Willis anemecek codesoup Robin_Jadoul mceier cerror Voldenet NeverDie gabiruh AntiSpamMeta inad922 kadoban lenstr Matajon eacameron KevinK mada hvr Sose MitchW cereal_killer_ zaquest tazjin elgot derpderp carella PennyNeko eliasr CaptainLex kosorith binaryplease pikhq Enigmagic erikd OnkelTem fionnan nshepperd_ seyt eldon monochrom Sinestro rbocquet)
19:36:31 --- names: list (hackagebot Guest47924 fengshaun Vq Fubar^ dddddd dwynwen_ddlleyw juhp abrar jdt acertain Sornaensis Stratege orzo valdyn Jesin nwf a3Dman_ spion tnecniv edwtjo raek friden Jaak jokleinn Ariadeno vishesh Tinchos lyuha benl23 paul0 Natch jenslarsson Nivim vpm Tourist nakal__ hrnz wolfcore rembo10 dcoutts_ rotty dolio Johannes13 albel727 swistak35 mjo tnks Qommand0r canta elementalest greeny dario docnvk nont_ alx741 sdx23 theDon mnoonan heyj nick123 greyeax)
19:36:31 --- names: list (sebstrax enetsee sz0 chameco ninefingers dxld minsky Xnuk t0mb0_ solatis besenwesen jokester cbm80 argent0 Amnez777 king_jah huonw sleepynate CurryWurst magthe kriztw rossberg_ qnikst dibblego Moto-chan koray sujeet jophish_ mvaenskae r143255 infinity0 kav Flonk fold4 mpereira tv Skuzzy zenzike nckx vqrs ninegrid wedens dogui schjetne andyo M-radix M-Shrike1 M-wamaral davidar M-david M-Magnap M-schmittlauch M-mistake M-Illandan M-krsiehl shounak M-Quora c9s)
19:36:31 --- names: list (Jonno_FTW _6a68 Khisanth bjobjo Ashy MrWoohoo heurist condy ninedotnine pikajude Orion3k cyphase Axman6 knyppeldynan borkdude koz_ machinedgod marsam seivan_ emmanuel_erc bernalex mtesseract ljhms Ralith opios ricardo82 josephle BlackYoup Frankablu fkurkowski Xack JeanCarloMachado dysfun whaletechno PierreM je5finger Ranhir tusj cross seraphime Freundlich lyxia jle` ChongLi Intensity chishiki Guest67739 cic kurnevsky sgronblo epta chronon-io ManiacTwister)
19:36:31 --- names: list (x1n4u Bez_ Oxyd karls mgaare amiri hanDerPeder ClaudiusMaximus nullfxn magicman chrisg_ dueyfinster Rodya riscool jonh QtPlatypus Forkk CetusY yrdz Ubercow rcsgns chrismytton sevas freekevin DrCode Tesseraction catsup liste Elision_ PlasmaStar hive-mind Speed SenpaiSilver anoe jkarni bengt_ staticfox trampi shutdown_-h_now myfreeweb prooftechnique eugen julienXX erebe1 Taylor der-landgraf cods enolan bounb bsermons xinming kjanosz Hafydd levi drbean RGamma)
19:36:31 --- names: list (Xandaros nathanic Tharbakim ireniko dmoon1221 mikedlr acro ortmage cdk marmalodak rmorgan verement texasmynsted taruti LordDeath libreman Poke95 frelux brt1 Liskni_si emiliocobos lachenmayer Neo hc nkpart bkonkle dunj3 brisbin happy0 totte amiller_ guampa fergusnoble avdi Akii mendez rockfruit fakedrake Elsi tekacs aatxe Ulrar carc max-m adamCS Edoxile adamh buoto tomus Saimeidae whiteline jinblack oherrala johnw stqism angular_mike Cerise octo- metaf5_)
19:36:31 --- names: list (BrianHV noexcept_ ephemeron bartavelle potatoe reem iphy RazorX- barrucadu ddima_ thomie tjbp_ kuno bizarrefish iliastsi_ Kneiva_ hpc TRMander1on brennie integral_ jaaket quuxman_ tswett pfoetche1 jrp6_ Ke Saizan_ Igloo_ mpickering CindyLinz jmct Raptor8m3_ hjljo ggherdov zrl_ seanparsons PotatoGim shans_ mno2 vikram__________ kjnilsson mankyKitty Tritlo rfw {AS} paf31_ marcel Guest34040 dgonyeo ess_sing nbouscal bus_nolrai gornikm monad_cat mvr_ kyagrd)
19:36:31 --- names: list (sbauman kolko_ koomi inr mauke ssedov dixie_ ahihi keix svp icedev DTZUZU Nahra Myrl-saki _ashbreeze_ osfameron a6a3uh wtw m1dnight_ srcerer zv tenc wagle MindlessDrone mak` bluepixel maurer deam tristero cdsmith l0rdPE afcondon Nycatelos funfun phaazon luzie WizJin ramatevish warc Rembane stelleg mitch_ cleamoon_ jophish Philonous Maxdamantus dsantiago rntz jak burp sword_smith LiaoTao cogrendel yamadapc Tril robogoat bsmt pacak posco przembot caw)
19:36:31 --- names: list (incomprehensibly dkua jessicah amatecha sclv nyandoge jfokkan__ arcetera aristid stasku____ ocharles banjiewen yaknyasn zpconn__________ YP-Cloud__ sisir__ milessabin zph_ TabAtkins phuu sephiap pkogan_ jknick tjpeden louispan harmchop jimki tg psacrifice qguv micmus zmanian__ lpaste wizonesolutions briansmith catern Purlox etcinit xa0 crank1988 adelbertc si14 ixian andreypopp angseus joeyh ericbmerritt carter _flow_ Xorlev GGMethos jonrh mikeplus64 staffehn)
19:36:31 --- names: list (jcp nyuszika7h monkeyiq orcus Ring0` tych0 vlopez gargawel mach geal cheater benzrf squisher cschneid cin wolf_mozart sqrt2 fall_ timrs2998 acfoltzer Vbitz marienz otterdam dpn` SegFaultAX Geekingfrog DustyDingo statusfailed tomku sbrg adimit zimp1 asjo swhalen sphalerite TimWolla mikeizbicki wjm xou KorriX seliopou bikeshedr Pucilowski alevy liff joachifm flux phadej pleiosaur jorrakay DANtheBEASTman eyenx_ dfranke dqd Cr8 hyPiRion RevJohnnyHealey Chousuke)
19:36:31 --- names: list (melancholia niteria acowley imalsogreg jtobin troydm skeet70 Moyst keemyb Satyajit jgertm JRHaigh fr33domlover krgn Internet13 slackircbot schnizzle rtur cantstanya lieven chelfi lokydor andrewsw boek euphoria- shwouchk M-ou-se gbarboza abra0 haasn maerwald gsingh93 reqq456 Deewiant mero dschoepe thimoteus ongy Ralith_ samgd Lord_of_Life obihann kloeri sleezd themagician cchalmers benonsoftware bd_ codebje Madars bshelden Tristan-Speccy joehillen \u bgamari)
19:36:31 --- names: list (etrepum alpounet_ cdidd josh_ jrib1 saurik_ lispy_ cynick AustinIncognito OH- davl_ Ankhers PHO Hijiri carter-znc aaronm04 notdan obcode jrslepak zhulikas_ ebird supki_ Eliel_ sjl__ mmaruseacph2 zerokarmaleft XMunkki_ iross_ dh ipuustin jix jud ski Reda suppi noplamodo nesqi urdh shirt asm89 hodapp nille Greezler eddsteel defanor kyren _janne Desoxy thoughtpolice toon nopf eyck comboy mokus dilinger NemesisD parsnip itnex Wamanuz2 marens_ zeroskil1or byorgey)
19:36:31 --- names: list (hbar_ coddinkn Boreeas StoneToad seagreen bcoppens Blkt aloiscochard Ravana dpower aplund Phyx- robertk tessier moop Kavec sellout Raynes TheVoid chris2 croben gnusosa horatiohb eagleflo martinga_ SoupEvil mattp_ JDevlieghere Fylwind ggVGc uwap Sonmi padre_angolano bitemyapp SphericalCow ynyounuo arianvp cosban lpsmith optocoupler low-profile karshan Ezku jtcs etabot `0660 Ornedan fmapE hausdorff dan64 marko___ mjrosenb akfp` niko luite Gothmog_ KeelOfSteel)
19:36:31 --- names: list (julm idupree dhrosa guios earthy linduxed mt fingerzam1 askarpo mindos_cloud____ cjwelborn_ vikraman Diabolik Watcher7 lyddonb Tiktalik ndeine jbalint peddie cmn squimmy_ SLi cjay pyrtsa xnyhps kshannon joshc runeks hansihe RayNbow` yorick avn eatonphil sLite bydo strmpnk jzl gseitz razi1 bvad u-ou Simson-san noctux s4msung liyang swipO amuck swilsonau divVerent tdammers psmolen andreass _kit_ grol joeytwiddle Chobbes chirpsalot tek0 __name__ quaestor davean)
19:36:31 --- names: list (lattenwald cgfbee gratimax jnoah henrytill gmci stephe_ rstone mbrcknl loopspace trevorriles dredozubov coeus_ armlesshobo nikola pdgwien surtn unsymbol pmade julmac niluje strixy cjh` luigy cow-orker Ewout maskd japesinator_ ps-auxw jstolarek bus000_ tumdum LeaChim_ callumacrae monty arw demize Arch-TK xplat larsen cocreature hongminhee platz jlewis kolmodin mxf statusbot moredhel mw dredozubov_ tobiasBora ziman Plastefuchs Paks leadingthenet eikke so Maerten)
19:36:31 --- names: list (alem0lars Klumben SolarAquarion xacktm kier theorbtwo aseidl tumdedum sparr zymurgy andjjj23 KaneTW ephess_ obiwahn shahn qz thomas MasseR pointfree exio4 betawaffle igniting d3lxa Baughn Jello_Raptor_ gauge abh Bane^ ao1ei8_ yarou gothos_ CosmicRa` yeltzooo9 scopedTV_ numberten toure Mandus Hakey kosmikus tzaeru knittl tomjaguarpaw jstimpfle jlouis TheMystic zyoung honkfest1val Drezil o`connor_ davidthomas Horv jlengyel zomg tero- frontendloader hxegon)
19:36:31 --- names: list (kennyp_ rvncerr caasih zopsi Iceland_jack wayne jotrk absence hegge LnL hpd tctara hyperboreean atomi mkloczko negatratoron kantokomi scinawa nitrix Dykam stux|RC-only jorendorff_ joedevivo pchiusano isochronia mniip oelewapperke ario Factionwars dalmahal spaceships tinco teppic naudiz deni Sigyn alex_lu qinusty FMJaguar sanitypassing johnstein Nimatek dustinm gpampara rieper trilog Starfire Profpatsch danieli magbo vin-ivar eL_Bart0 epitron Black-Wolf reynir)
19:36:31 --- names: list (impure_hate ormaaj cnr chriswk zero7 yminsky bigs henriquev wyvern sewilton xplat|work jroesch_ shennyg lancetw OliPicard fuziontech shelling__ S11001001 bgyss pootler_ beckyconning_ alphonse23_ nekomune CARAM__ cstrahan nurupo dca drewdavis coppro brezel akermu lanodan dstockwell jlyndon tarcwynne_ solidsnack JackMc katymoe bedouin Scorchin ryoia fabianvf Flaeme MorTal1ty codedmart mkurkov ryanpcmcquen kipd AlainODea bitonic spicydonuts lexi-lambda)
19:36:31 --- names: list (ajmccluskey johtso codebam Brando753-o_O_o kmicu Tene ByronJohnson t0m0 Shandy pelegreno pikpok yusukesuzuki brixen DigitalKiwi case39 ploop mrowe MK_FG Adios JPohlmann miklcct sm simony watersoul Majiir jameseb fryguybob chrzyki thalleralexander killtheliterate alanz SuperTux88 cbaines raid minad codehero usr nemesit|znc lambdabot joncfoo felher ppnkk Xe nisstyre nathyong anders0 greymalkin mudfog_ spwhitt_ M2tias erg jackhill ent Quintasan Jaxan brolin_empey)
19:36:31 --- names: list (bjs cyberlard Thulsadum DDR richi235 Athas bbee ircbrowse abbe froztbyte benjamincrom spacebug_ int-e geekosaur tortal majoh lassulus okek zzz_nek0 keteim BrAsS_mOnKeY dju emmflo l3france bwbaugh s4kashya ElderFain klugez opqdonut xaimus wting hydraz lucz shachaf srhb drdo sunfun TommyC jgornick da-x Tehnix cYmen c-rog nilOps martinbjeldbak adarqui capisce Taneb tippenein arrdem Bigcheese sinopeus oberstein petercommand ion mingc zxtx masquerade lhynes)
19:36:31 --- names: list (IndigoTiger Guest83419 rom1504 kipras Lutin` mudfog irclogger_com Biohazard avocado mephx_ Amadiro jb55 relrod isomorphismes mj12` Zemyla siddhu clever averell gridaphobe dxtr __main__ mrshoe parsnipM_ funrep mitchty bogdanteleaga mathu leftylink pdxleif xxpor tokik newsham shapr aweinstock mrd luis wamaral tolt Vivek [swift] worch baweaver Laney lstrano Clint hemite bananagram arkeet Reyu trig-ger kini c_wraith chaptastic RageD joco42_ edwardk sajith @ChanServ)
19:36:31 --- names: list (EvanR pharaun vodkaInf1rno tsani ec\ Belgarion0 ReinH acomminos Adeon Cathy tomaw ft robtaylor Ov3rload marmoute ernst hiredman sohum BigEndian skarn mrlase kaol anachrome koala_man __rlp lukky513 Atlanis amontez)
19:36:31 <Koterpillar> what was the language where you could define lambdas with holes, like this: (_ + 1) :: Int -> Int ?
19:36:47 <thimoteus> purescript has that syntax
19:38:32 <okek> Scala too
19:38:54 <okek> (without the :: part)
19:39:14 <Koterpillar> thanks!
19:40:32 <mgsloan> iphy: Not sure, I never could understand those.  Perhaps try using stack?  It isn't quite as puzzling
19:41:00 <mgsloan> (hey hey if maerwald can spread stack FUD, then I can recommend it when people have misc cabal-install problems related to its UX..)
19:42:09 <mgsloan> dgpratt: Glad you find it useful!! :)
19:42:33 * Welkin waves in front of mgsloan's eyes
19:42:47 <Welkin> are you talking to ghosts?
19:43:00 <mgsloan> Just reading backlog
19:43:40 <mgsloan> Oh, maerwald, yes, he pissed me off earlier by spouting half-truths and non-truths about stack
19:47:34 <mgsloan> Like I usually don't tell people that have problems with cabal to use stack, I leave that to others
19:48:23 <mgsloan> But if the error message tells the user _exactly how to solve the problem_, and you are telling them to switch to cabal
19:48:53 <mgsloan> That is purely some sort of wacky anti-stack agenda based in something completely separate from the quality of the tool
19:50:01 <mgsloan> Not sure if I'll make a habit of poking people to give it a try, I imagine many do on their own accord after encountering enough cabal-install puzzlement 
19:50:23 <Welkin> I use stack by default now
19:50:35 <Welkin> I don't see any reason to use cabal directly
19:50:35 <mgsloan> \p/
19:50:59 <mgsloan> I hear from avid cabal-install users that they've had a lot of trouble using stack.
19:51:09 <Welkin> I did have trouble when I started
19:51:14 <Welkin> I think you helped me with it
19:51:15 <mgsloan> That's like saying you have trouble with haskell when you already know C
19:51:18 <Koterpillar> mgsloan: confirmation bias: you _don't_ hear from happy stack users, because they are happy
19:51:19 <Welkin> since then I had no trouble
19:51:19 <EvanR> i love cabal installing something followed by it failing and then proceeding to manually unregister and reinstall a host of things, often involving 9 lens deps
19:51:45 <monochrom> you don't hear from happy cabal users either, such as me
19:51:53 <mgsloan> Welkin: Glad it's working well for you!
19:52:23 <mgsloan> monochrom: Certainly if you've used it for a long time it can work well for you.  I never got to that point after quite a few years
19:52:39 <monochrom> and now, for the "I am more real-world than thou" bias: when you do hear from me, you can simply accuse that my projects are toys.
19:52:47 <mgsloan> But I also didn't really try very hard to upgrade my cabal foo.  Like I was still using hsenv rather than cabal sandboxes
19:53:22 <mgsloan> monochrom: There is that, there is certainly a difference in optimal use-case there
19:53:53 <mgsloan> Koterpillar: Glad you're happy too, thanks :D
20:05:42 <m1dnight_> Is there an easy way to list all files excluding directories in haskell?
20:07:44 <athan> Hi everyone. Is there a `endProcess :: IO a` that _isn't_ just `pure undefined`?
20:07:54 <athan> I just want clean error messages :)
20:09:08 <athan> Muahaha! `exitCode` Thank you for telepathically communicating that to me!
20:09:32 <MichaelK> Hi, should I report a panic I found in GHC 7.10.3?
20:10:23 <glguy> MichaelK: better would be to reproduce it in ghc8.
20:10:39 <MichaelK> glguy: fixed in ghc8, should've mentioned that
20:10:45 <glguy> 7.10 is unlikely to get much attention
20:11:36 <MichaelK> makes sense. still annoying since my stack install still defaults to 7.10 
20:12:22 <glguy> M1dnight_: the directory package can list directory contents and can test if something if a file or directory
20:28:38 <vctrx> anyone using spacemacs?
20:34:20 <m1dnight_> Oh, I must have missed that? I found System.Posix.Files.isRegularFile 
20:38:28 <glguy> m1dnight_: http://hackage.haskell.org/package/directory-1.2.6.3/docs/System-Directory.html
20:54:14 <m1dnight_> Yes! I've got it working :) Thanks guys
20:54:16 <m1dnight_> and ladies
21:14:07 <koz_> How do I re-export something specific from an imported module?
21:14:36 <geekosaur> just list it, qualified if you imported it qualified?
21:15:36 <geekosaur> remember that *all* exports show to an importing module as coming from yours, so if your module is imported qualified by another module then it must qualify that re-export as being from your module, not the original
21:15:48 <koz_> geekosaur: Oh, is that all? Cool, thanks!
21:46:56 <codedmart> If I have [“key", “value"] and I want to run a function on each one and turn it into a Map what is the best way to do that?
21:47:12 <Koterpillar> map
21:47:32 <codedmart> I know I can map the func
21:47:45 <codedmart> But then how do I turn it into a Map Text Text?
21:48:17 <Koterpillar> what does your function return?
21:48:41 <Koterpillar> oh, do you literally have two values?
21:48:50 <codedmart> Yeah
21:49:08 <Koterpillar> :t singleton
21:49:10 <lambdabot>     Not in scope: ‘singleton’
21:49:10 <lambdabot>     Perhaps you meant one of these:
21:49:10 <lambdabot>       ‘Data.ByteString.singleton’ (imported from Data.ByteString),
21:49:15 <Koterpillar> :t Data.Map.singleton
21:49:16 <lambdabot> k -> a -> Data.Map.Map k a
21:49:22 <Koterpillar> this?
21:50:14 <Koterpillar> let [k, v] = ["key", "value"] in M.singleton k v
21:50:16 <Koterpillar> > let [k, v] = ["key", "value"] in M.singleton k v
21:50:18 <lambdabot>  fromList [("key","value")]
21:50:52 <codedmart> Koterpillar: Thanks!
22:05:39 <begriffs> Anybody have opinions positive or negative about protolude as an alternative prelude?
22:06:59 <koz_> Where can I find arrays for Haskell?
22:07:06 <dmj`> @package vector
22:07:06 <lambdabot> http://hackage.haskell.org/package/vector
22:07:14 <dmj`> koz_: ^
22:07:57 <koz_> dmj`: Thanks!
22:21:17 <koz_> Say I have 'foo :: MonadRandom m => Int -> m Text' and I do 'replicateM 10 (foo 4)', will will I get 10 copies of the same random Text, or 10 different random texts?
22:21:26 <koz_> s/will will/will
22:22:38 <Koterpillar> different, assuming it's actually using the randomness
22:23:14 <koz_> Koterpillar: OK, I thought so too, but I wanted to check to make sure.
22:23:15 <Koterpillar> > replicateM 10 $ putStrLn "different things"
22:23:17 <lambdabot>  <IO [()]>
22:23:29 <Koterpillar> koz_: try that
22:25:56 <MichaelK> Given a data type `T a`, is there any way to compose `T`? i.e. effectively like `IO . T`?
22:28:27 <M4R4B4> !help
22:29:03 <Koterpillar> MichaelK: what do you get of this composed thing?
22:29:53 <MichaelK> an applicative instance, I have `T (a -> b) -> T a -> m (T b)` already
22:32:57 <johnw> MichaelK: isn't that just "pure"?
22:33:07 <johnw> as in, T a -> m (T a)
22:34:26 <MichaelK> johnw: I have that too, I mean composed so (if ghc had type lambdas) I could do `instance Applicative (\a -> IO (T a))`
22:34:42 <M4R4B4> scan vulln someone has?
22:36:38 <kadoban> MichaelK: There is Compose from https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Compose.html#t:Compose , which sounds like what you're looking for, but I'm not positive.
22:38:16 <MichaelK> kadoban: I
22:38:18 <MichaelK> *I
22:38:32 <MichaelK> *I'll double check, but I don't think newtypes support partial application
22:40:07 <glguy> Newtype does support partial application
22:40:28 <MichaelK> oh, no way, it works. thanks kadoban
22:40:53 <kadoban> Cool, 'welcome.
22:41:20 <slack1256> with ghc 8 64-bit applications ask for 1.0T of virtual memory. The release note say this but say not to worry
22:41:26 <slack1256> it look wrong though
22:41:48 <geekosaur> I noticed. gotten several xmonad bug reports about it...
22:42:15 <M4R4B4> I need a scan like this someone has ??? http://prnt.sc/bmwh00
22:42:59 <Koterpillar> M4R4B4: this is not the topic of this channel
22:43:41 <yamadapc> How does cabal decide which packages to keep uncompressed on the `$HOME/.cabal/packages` directory?
22:44:32 <yamadapc> This: https://www.dropbox.com/s/o1urnmjg2a2qadt/Screenshot%202016-06-30%2002.43.42.png?dl=0
22:45:36 <geekosaur> dropbox is demanding login; I think you need to put that in your Public
22:45:45 <M4R4B4> which channel can I get to see on this subject?
22:45:48 <geekosaur> (i.e. even if I am logged in I do not have access to your dropbox)
22:46:05 --- mode: ChanServ set +o glguy
22:46:19 <yamadapc> I think you can just close that popdown; tried on a incognito tab
22:46:20 <Koterpillar> M4R4B4: I don't have any idea; ask on #help
22:47:12 <yamadapc> It's just a screenshot of a ~/.cabal directory tree, there're some versions of a package which are compressed (.tar.gz) and some which are decompressed (the Category.Thing.Source.Tree)
22:47:34 <m1dnight_> tree | nc termbin.com 9999 
22:47:38 <m1dnight_> That might be easier than a screenshot :p[
22:47:55 <m1dnight_> or `ls | nc termbin.com 9999` whatever.
22:48:17 <yamadapc> That's new... http://termbin.com/m239
22:48:23 <geekosaur> in any case, I have a fairly large ~/.cabal/packages and none of them are unpacked. I would guess that any unpacked ones were manually unpacked
22:48:24 <yamadapc> (didn't know about it)
22:49:38 <geekosaur> because unpacking is done either to a temporary dir not under packages (unless this changed in 1.24) or to somewhere specified by an explicit cabal get / cabal unpack
22:49:44 <yamadapc> oh... okay... I think codex is doing it
22:50:17 <geekosaur> if cabal *is* unpacking there now, it would suggest a failed build attempt
22:51:09 --- mode: glguy set -o glguy
22:51:36 * slack1256 learned sometimes you want Maybe (IO a) instead of MaybeT IO a, specially if you are dealing with nested ifs
22:51:44 <yamadapc> What I wanted to try out was to use existing cabal packages on my system to symlink all the source code for things I'm working on between my own source-tree
22:52:15 <yamadapc> And go from there for other stuff I want to try; it's not a strictly practical task, just wondering
22:52:20 <geekosaur> sounds a bit like reinventing stack / backpack...
22:53:20 <yamadapc> Yes, sort of...
23:31:33 <rfw> is there some kind of generic type that expresses data Foo a = a | And a a | Or a a?
23:32:13 <dibblego> there is data These a b = This a | That b | Both a b
23:32:52 <jle`> rfw: what would the difference between the And and the Or constructors be?
23:32:57 <rfw> hm i don't think that's quite the right thing
23:32:59 <jle`> and what is that first constructor supposed to be?
23:33:08 <dibblego> (a, Maybe a, Bool)
23:33:08 <rfw> jle`: i'm just wondering if there's a generic type level encoding of boolean terms
23:33:29 <jle`> oh ah.  like an expression type?
23:33:32 <rfw> where the atoms are some type i pass in
23:33:32 <rfw> yeah
23:34:03 <jle`> is the first constructor supposed to be Not or something?
23:34:26 <rfw> oh oops
23:34:38 <rfw> data Foo a = Atom a | Not a | And a a | Or a a
23:34:52 <jle`> but yeah, this does sound a little too specific that there would be one people would have lying around
23:35:01 <rfw> er, sorry, replace al lthe other as with (Foo a)
23:35:10 <jle`> but you can construct arbitrary sum/product types with various combinators like Either, (,) etc.
23:35:17 <rfw> ah ok
23:35:26 <jle`> or :*:, :+:, etc.
23:35:56 <jle`> if you use :*:/:+:/Product/Sum then you can get generic combinators/folders for working with it
23:36:18 <pavonia> :t (:*:)
23:36:19 <lambdabot> Not in scope: data constructor ‘:*:’
23:36:31 <jle`> it's hidden in GHC.Generics for some reason
23:36:33 <rfw> what module is :+: in?
23:36:39 <rfw> ah
23:37:00 <jle`> it's also defined as 'Sum' in the transformers package
23:37:23 <jle`> but they both have the appropriate Functor instance to make them suitable for the "data types a la carte" style
23:38:08 <rfw> hm i don't see Sum in transformers
23:38:08 <jle`> :+: is just syntactically nicer, i think...
23:38:28 <rfw> :+: in GHC.Generics looks like a type constructor?
23:38:35 <jle`> it's in Data.Functor.Sum
23:38:42 <jle`> yes, it's a type constructor, just like Data.Functor.Sum
23:39:11 <rfw> ah, i meant something to represent expressions like that at the value level
23:39:15 <jle`> if f is a functor, and g is a functor, then (f :+: g) is a functor
23:39:16 <rfw> i guess i'll have to just write my own
23:39:23 <jle`> yeah, for that, you'd use its constructors
23:42:10 <jle`> basically, your type data Foo a = Atom a | Not (Foo a) | And (Foo a) (Foo a) | Or (Foo a) (Foo a)
23:42:36 <jle`> can be implemented as data FooF f a = Not (f a) | And (f a) (f a) | Or (f a) (f a)
23:42:44 <jle`> which can be implemented as:
23:42:54 <jle`> type FooF f = f :+: (f :*: f) :+: (f :*: f)
23:42:56 <athan> Anyone have any idea on how to trace back _where_ an exception might be thrown from?
23:43:00 <athan> I've been grepping throughout some packages, and haven't found jack :\
23:43:08 <jle`> and your original type is `Free FooF`
23:43:27 <rfw> oh, that's cool
23:43:32 <jle`> it's identical to your original type, and the advantage is that you already have pre-built folders, collapsers, generators, generic mappers, traversals, etc. for it
23:43:55 <jle`> and you can use pattern synonyms to work as "smart constructors" so you can literally use 'And'/'Or' as constructors
23:44:11 <rfw> i think that might be a little more complex than i need
23:44:21 <jle`> yeah, you'll have to think hard about whether or not it's worth the complexity, heh
23:44:28 <rfw> can't i do deriving Generic on Foo?
23:44:51 <jle`> that gives you mappers/traversals, but not folders
23:44:55 <jle`> and generators
23:45:03 <jle`> but definitely a viable option too :)
23:45:05 <rfw> i see
23:45:08 <rfw> thanks
23:46:43 <jle`> np!
23:50:14 <athan> So I take it there's no possible way to backtrace an Exception? ._.
23:50:14 <athan> it is dun goofed
23:51:13 <MichaelK> athan: depending on how much you want to change, you could use `SomeException` and label the exceptions thrown by function
23:52:12 <Cale> What is the exception?
23:52:30 <AbelianGrape> Why does Repa's computeP return a result wrapped in a Monad? It doesn't have any other typeclass constraints, so you could just use Identity and then there's no point using a Monad...
23:54:37 <jle`> AbelianGrape: it's to sort of discourage you from nesting calls to computeP.  it's not perfect, but it encourages a "sequential" style
23:54:46 <jle`> usually people use Identity
23:54:52 <Cale> AbelianGrape: see the comment here: http://hackage.haskell.org/package/repa-3.4.1.1/docs/Data-Array-Repa-Eval.html#v:suspendedComputeP
23:54:59 <athan> Cale: I'm not even sure, technically, but all I know is that the data constructor is _probably_ named `HandshakeFailed` (from the show instance)
23:55:41 <AbelianGrape> Cale: Is the comment really accurate? How would Idenity "ensure that each array is fully evaluated"?
23:55:42 <athan> MichaelK: Hmm, that's a good point, and could help me narrow down what actually is throwing this
23:55:42 <athan> (this is all in the websockets library by the way, while using it as a client)
23:55:44 <jle`> AbelianGrape: Simon Marlow addresses this question here: http://chimera.labs.oreilly.com/books/1230000000929/ch05.html#sec_par_repa_parallel_sp
23:56:37 <jle`> if your program makes multiple calls to computeP, if you "sequence" them all using Identity/>>= for Identity, it prevents weird things from happening with nested computeP calls
23:57:53 <jle`> and only use 'runIdentity' once, at the very end/at the exit point
23:58:13 <Cale> It's really just a trick for structuring the forced evaluation using deepSeqArray -- you wouldn't *have* to use Identity, but it's nice notation for picking an order in which to evaluate things.
23:58:57 <AbelianGrape> jle`: So what happens if I use "computeP <$> computeP x"? Isn't this equivalent to nesting computeP if we're using Identity?
23:59:41 <AbelianGrape> I can't imagine how Identity would give us any sort of useful sequencing behavior
23:59:55 <AbelianGrape> given that it doesn't have any additional strictness characteristics or anything
