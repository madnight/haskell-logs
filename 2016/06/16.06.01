00:07:36 * hackagebot processing 1.2.0.2 - Web graphic applications with processing.js.  https://hackage.haskell.org/package/processing-1.2.0.2 (DanielDiaz)
00:07:36 * hackagebot delude 0.1.0.3 - Generalized the Prelude more functionally.  https://hackage.haskell.org/package/delude-0.1.0.3 (sgschlesinger)
00:12:31 * hackagebot cryptonite 0.16 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.16 (VincentHanquez)
00:52:04 <BartAdv> what's the advantage of, let's call it a "pattern", to make a record datatype with unXXX/runXXX field? It seems to be used quite often (for example, I'm now looking at persisten generated datatypes: UserKey {unUserKey :: BackendKey SqlBackend}). The only thing that comes to my mind is that it gives you a function to unpack it without pattern matching for
00:52:04 <BartAdv> free, but then it's awful to read using default Show instances
00:52:58 <kadoban> BartAdv: That's pretty much the advantage and disadvantage, yes.
00:57:33 * hackagebot hetero-dict 0.1.0.0 - Fast heterogeneous data structures  https://hackage.haskell.org/package/hetero-dict-0.1.0.0 (winterland)
01:06:17 <quchen> BartAdv: Show is not for prettyprinting, https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
01:07:15 <ggVGc> How can i best turn [Nothing, Just [a], Nothing, Just [b,c]] into [Nothing, Just a, Nothing, Just b, Just c]
01:07:41 <BartAdv> quchen: yup, I might have sounded like I used it for this, but I was just printing in a test to debug and it only just reminded me I always was curious about the reason for all those records, nothing else
01:10:47 <BartAdv> quchen: interesting article though, especially that I've failed on point 1 already :P
01:11:17 <quchen> BartAdv: *Frequently* brought up topics ;-)
01:11:47 <sdx23> ggVGc: concatMap sequence --?
01:12:37 <contiver> > concatMap sequence [Nothing, Just [3], Nothing, Just [1,2]]
01:12:40 <lambdabot>  [Nothing,Just 3,Nothing,Just 1,Just 2]
01:13:36 <quchen> contiver: You can literally use 'a' in expression here! :-)
01:13:49 <quchen> > concatMap sequence [Nothing, Just [a], Nothing, Just [b,c]]
01:13:51 <lambdabot>  [Nothing,Just a,Nothing,Just b,Just c]
01:14:06 <EvanR> where literally literally means literally
01:14:21 <contiver> quchen: o_O how does that work?
01:14:22 <ggVGc> sdx23: thanks! I was just looking at sequence ;)
01:14:36 <quchen> contiver: simple-reflect package
01:14:44 <contiver> quchen: does it assume it's a char?
01:14:50 <quchen> :t a
01:14:52 <lambdabot> Expr
01:14:54 <quchen> :t f
01:14:56 <lambdabot>     Ambiguous occurrence ‘f’
01:14:56 <lambdabot>     It could refer to either ‘L.f’,
01:14:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:320:1
01:15:00 <quchen> ?undef
01:15:00 <lambdabot> Undefined.
01:15:02 <quchen> :t f
01:15:03 <lambdabot> FromExpr a => a
01:15:19 <quchen> It's type class magic.
01:15:21 <quchen> http://hackage.haskell.org/package/simple-reflect
01:15:54 <contiver> quchen: interesting, thanks for the tip :]
01:22:46 <sdx23> quchen: hmpf, by your article-link and stalking your github stuff, you created some new tabs in my "have to read somewhen" area
01:23:09 <quchen> Sorry about that!
01:23:52 <sdx23> take it as a compliment :)
01:24:23 <quchen> :-þ
01:55:34 <mikail_> Hi, I have a design question. Say I have a type defined as follows: data Foo = Foo Int Int. Is there a way to use the type system to construct values such that one Int is less than the other Int. That is, at the point of construction, if I create a Foo, then the first Int has to be less than the second Int. Is there a way to do this in Haskell?
01:56:15 <Taneb> mikail_, I do not believe there is
01:56:23 <Taneb> One solution is to use smart constructors
01:56:44 <Taneb> That is, hide the actual constructor and instead have foo :: Int -> Int -> Maybe Foo
01:57:57 <sdx23> mikail_: LiquidHaskell should be applicable for this.
01:59:23 <mikail_> I'm just going to throw this in to the mix even though I don't know what it is, but is this the thing that dependent typed languages solve?
02:01:19 <EvanR> you can do it with dependent types or fake dependent types in haskell
02:01:48 <Faucelme> The refinement types of LiquidHaskell are a restricted form of dependent types, IIRC.
02:02:12 <Faucelme> That can be treated more efficiently for some cases.
02:02:14 <EvanR> mkFoo : (x, y : Int) -> (x < y) -> Foo Int Int
02:02:36 <EvanR> mkFoo : (x, y : Int) -> (x < y) -> Foo
02:02:46 <EvanR> it doesnt let you prove that x and y are really in there though
02:03:34 <EvanR> but it requires you have evidence that x is less than y at compile time
02:03:53 <EvanR> smart constructors are probably more practical in haskell, even though its a runtime test
02:18:05 <mikail_> thanks - I'll go with smart constructors
02:18:16 <MichaelBurge> mikhail_: If you know the Ints in question are literals or available at compile-time, you could use Template Haskell and throw an error with a smart constructor
02:18:19 <MichaelBurge> that would catch it at compile time
02:18:24 <MichaelBurge> I don't know if it's worth it, though.
02:19:30 <mikail_> wowsers - I don't know what Template Haskell is - I will look into it
02:30:37 <MichaelBurge> mikhail_: Here's an example: http://lpaste.net/164969
02:42:37 * hackagebot extra 1.4.9 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.9 (NeilMitchell)
02:45:09 <Tekkkz> hm. anyone can tell me what for a bug appeared at http://ix.io/Ntr?
02:46:30 <MichaelBurge> Tekkkz: It looks like a gcc bug, and that you're building it on ARM.
02:47:02 <MichaelBurge> Tekkkz: Are you using an unregisterized ghc?
02:48:46 <Tekkkz> what is an unregisterized ghc?
02:49:33 <MichaelBurge> Tekkkz: When you compile ghc, you do it in 2 stages: First you make one that can output C code, and then you use that one to compile a GHC that outputs native platform code.
02:49:57 <MichaelBurge> Tekkkz: People often use the first kind when porting to weird platforms. Which makes sense if you're doing it on a phone or other tiny device with an ARM
02:50:48 <MichaelBurge> Tekkkz: If you're using the unregisterized one, then one possibility is that GHC emitted C code that gcc crashed on. I'm sure there's a way to capture that C code and submit a bug to the GCC team.
02:51:55 <Tekkkz> ahh no i anstalled the precompiled one from debian repo on my archarm system. BUT! yesterday i did it on the same hardware and it worked
02:52:37 * hackagebot ghc-imported-from 0.3.0.6 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.3.0.6 (CarloHamalainen)
02:57:38 * hackagebot tz 0.1.1.1 - Efficient time zone handling  https://hackage.haskell.org/package/tz-0.1.1.1 (MihalyBarasz)
02:58:25 <kuribas> So I was thinking how a low level ski calculus could be implemented in hardware.  Turns out there research doing this: https://www.assembla.com/spaces/skiclub/wiki
02:58:33 <kuribas> Anyone know more about this?
02:58:55 <kuribas> Would it help in better parallelism for programs?
03:00:30 <MichaelBurge> kuribas: The reference here could be relevant to you: https://en.wikipedia.org/wiki/Graph_reduction_machine
03:03:01 <kuribas> hm interesting
03:06:26 <kritzcreek> How do you approach a change where you change the underlying datatype of a "large" codebase? How can I get back to it compiles again quickly and iterate on something that typechecks?
03:08:09 <kuribas> kritzcreek: Just follow the typeerrors?
03:08:23 <MichaelBurge> kritzcreek: What kind of change is it?
03:10:15 <kritzcreek> https://www.irccloud.com/pastebin/NqJ200Q8/
03:10:34 <kritzcreek> I want to go from PscIde -> Ide
03:10:55 <{AS}> As a consequence of these laws, the Functor instance for f will satisfy
03:10:55 <{AS}> fmap f x = pure f <*> x
03:11:00 <{AS}> How does that happen?
03:11:18 <{AS}> I cannot find any other place that links fmap to pure
03:11:26 <JuanDaugherty> is there a list of stuff 8 doesn't break?
03:11:29 <kritzcreek> @MichaelBurge the "Environment" holds a TVar for the State
03:11:29 <lambdabot> Unknown command, try @list
03:12:30 <MichaelBurge> kritzcreek: I'd probably keep both definitions for now, and add a function for converting between the old type and the new type.
03:13:19 <MichaelBurge> kritzcreek: Then I'd work on the code that would best use the new type, using conversions to interface with the rest of the codebase
03:13:38 <MichaelBurge> kritzcreek: And once I'm sure it's useful, I'd start switching everything else over.
03:14:24 <kritzcreek> The problem is that I can't write an adapter for the Ide -> PscIde constraint
03:14:39 <kritzcreek> those are used like mtl typeclasses
03:15:14 <kritzcreek> But I'm halfway down that road allready so thanks for confirming! I guess I'll just have to bite the bullet and break everything :S
03:15:23 <MichaelBurge> kritzcreek: Is it possible to convert between PscIdeState and IdeState?
03:15:45 <kritzcreek> yes
03:17:38 * hackagebot hlint 1.9.34 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.34 (NeilMitchell)
03:18:13 <MichaelBurge> kritzcreek: I'd have to work through why that isn't possible. Another possibility would be to add the fields to the existing type, and set both collections in your runReader call.
03:18:19 <MichaelBurge> Then remove the old fields when you're done.
03:19:19 <kritzcreek> oh that sounds like a great idea. I'll totally do that thanks!
03:31:33 <deni> bennofs: not much difference with running stack exec vs just running the compiled binary directly ... still the same error
03:35:25 <EvanR> any idea what main.\ means
03:35:30 <EvanR> in a profile
03:35:45 <EvanR> lambda?
03:42:54 <EvanR> ... why is stuff being retained...
03:43:07 <lyxia> a lambda in the body of main
03:43:42 <{AS}> EvanR: Can you link your code?
04:00:00 -tenniscp25(~tenniscp2@ppp-110-168-232-50.revip5.asianet.co.th)- LONG ReadUID(LPBYTE uid, LPINT uidLen);
04:00:05 <tenniscp25> oops sorry
04:00:19 <tenniscp25> let's say i have a c function like this: LONG ReadUID(LPBYTE uid, LPINT uidLen);
04:00:48 <tenniscp25> if i want to make an ffi call from haskell, is this declaration correct?
04:00:50 <tenniscp25> foreign import ccall "ReadUID" c_readUid :: CString -> Ptr Int -> IO CLong
04:22:51 <AfC> When you have an type being used as the state in a State/StateT monad, is there a reason I can't have a free type variable in it?
04:24:13 <opqdonut> of course you can
04:24:15 <opqdonut> :t get
04:24:16 <lambdabot> MonadState s m => m s
04:24:28 <opqdonut> hmph that's slightly too generic
04:25:03 <opqdonut> but anyway, the state type s is polymorphic
04:25:05 <AfC> No, that's alright. `get` lives in MonadState
04:25:22 <AfC> opqdonut: yeah, I wouldn't have thought it matters. Me pastebins
04:32:41 * hackagebot stratux-types 0.0.3 - A library for stratux  https://hackage.haskell.org/package/stratux-types-0.0.3 (TonyMorris)
04:32:43 * hackagebot stratux-websockets 0.0.3 - A library for using websockets with stratux  https://hackage.haskell.org/package/stratux-websockets-0.0.3 (TonyMorris)
04:33:10 <cloudhead> Hey, I'm trying to figure out how to scale various types, like vectors, integers, floats with a single function and scaling factor, but I'm not able to find a typeclass that would work for this, essentially I need something like :: (Num a) ⇒ a → Double → a,   any ideas?
04:35:02 <cloudhead> so `a` could be `Vector Float` or `Integer`, and I'd multiply them both by the Double
04:35:07 <lyxia> I see a scalar multiplication in a vector space, I don't know if there is a "standard" typeclass for that
04:35:35 <cloudhead> yeah, I think that's it
04:36:42 <cloudhead> hmm, is there any clever way to parametrise the function perhaps?
04:37:17 <cloudhead> to take more concrete types, while still being flexible enough 
04:37:41 * hackagebot stratux 0.0.3 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.3 (TonyMorris)
04:39:53 <EvanR> {AS}: theres a lot of code
04:40:40 <EvanR> ill try to remove parts of the program until the effect goes away
04:44:37 <mettekou> Hi guys
04:44:46 <Eduard_Munteanu> Hi, mettekou.
04:44:47 <mettekou> I don't like haskell
04:45:03 <mettekou> haha jk i love it
04:45:09 <mettekou> i jizz in my pants for it
04:50:40 <makalu> which company mode backend should I use in emacs? There's company-ghci and company-ghc (uses ghc-mod)?
04:53:23 <EvanR> so here is the profile output for a blank gloss program 
04:53:25 <EvanR> http://i.imgur.com/6HSGpEX.png
04:53:29 <EvanR> normal? 
04:53:46 <EvanR> i got started debugging this when the RES memory report just increases
04:54:04 <EvanR> if its normal, im not sure how to know if i did something wrong
04:55:10 <{AS}> EvanR: You should write this in Idris :)
04:55:32 <merijn> EvanR: Man...you need to use the flag to colourise output
04:55:35 <merijn> That's unreadable :\
04:55:36 <{AS}> Oh, wait, I wrote in the wrong channel :)
04:55:39 <{AS}> I will take a look
04:55:44 <EvanR> which flag is that, i agree
04:56:01 <EvanR> the top thing is something about GLUT
04:56:14 <merijn> EvanR: hs2ps -c
04:56:25 <merijn> According to the GHC manual, anyway
04:56:37 <merijn> eh
04:56:40 <merijn> hp2ps -c
04:57:05 <EvanR> http://i.imgur.com/octSpp0.png
04:57:48 <{AS}> It seems that there are some GLUT resources that are not released
04:58:53 <merijn> EvanR: And this program does nothing?
04:58:59 <EvanR> right
04:59:04 <EvanR> it displays a blank window
04:59:14 <merijn> Sounds like a bug in GLUT?
04:59:14 <EvanR> it cant even handle input
04:59:19 <merijn> Or the bindings, anyway
04:59:34 <{AS}> I think he uses Graphics.Gloss
04:59:36 <EvanR> alright ill look at gloss internal
05:00:08 <merijn> Shouldn't the profiler also be able to associate allocations with functions?
05:00:39 <EvanR> i just generated that report, but it just says MAIN because the library isnt built with profiling, i think
05:02:22 <EvanR> (er, library-profiling: True is set in my .cabal/config)
05:02:57 <merijn> EvanR: You need to insert profiling points when building
05:03:27 <merijn> Try "-auto-all -caf-all -rtsopts" as flags
05:13:14 <EvanR> merijn: those flags worked, there is more info
05:15:22 <EvanR> http://i.imgur.com/xDfewI5.png
05:15:32 <EvanR> it might be continually reinstalling a callback without uninstalling the old one
05:19:00 <ski> @tell kuribas hm, reminds me of "An Architecture for Combinator Graph Reduction (TIGRE)" (Ph.D. thesis) by Philip Koopman in 199[02] at <https://users.ece.cmu.edu/~koopman/tigre/index.html>
05:19:00 <lambdabot> Consider it noted.
05:19:20 <ski> {AS} : where's that from ?
05:21:39 <{AS}> The applicative stuff?
05:22:02 <{AS}> It is from the definition of Data.Applicative
05:23:46 <ski> {AS} : hm, i suspect it's because of unicity of `fmap'
05:24:37 <ski> given
05:24:43 <ski>   fmap f x = pure f <*> x
05:24:43 <{AS}> ski: So by unicity of fmap and because (pure f <*>) satifies the applicative laws? then fmap and (pure f <*>) are equal?
05:24:50 <ski> we can compute
05:24:52 <{AS}> sorry the functorial laws
05:25:10 <ski> hmm
05:25:24 <ski> {AS} : i suspect so, yes
05:25:50 <{AS}> so because (pure id <*>) = id and (pure (f . g) <*>) = (pure f <*>) . (pure g <*>)  :)
05:26:44 <EvanR> fixed it... http://i.imgur.com/UpwHKKb.png
05:27:09 <EvanR> in the display callback for GLUT, it is atomicmodfying an ioref containing a record containing a frame count of type Int
05:27:13 <EvanR> and doing s = s + 1
05:27:23 <EvanR> but i guess nothing ever uses that number
05:27:30 <EvanR> making it a strict field fixed the leak
05:27:48 <{AS}> ski: Thanks for the answer
05:27:56 <{AS}> Do you have any guide that shows how to prove the unicity of fmap?
05:27:58 * EvanR removes like 100 bang patterns and tries again
05:32:59 <ski> {AS} : i don't recall how it's done, and i don't recall any link either. sorry
05:33:09 <{AS}> ski: OK, thanks :)
05:33:19 <{AS}> I mean I can do it for list, etc.
05:33:26 <{AS}> but I can not do it for any given datastructure
05:33:34 <merijn> EvanR: \o/
05:34:51 <{AS}> because we have to do analysis on datatype definitions to show the contradiction :)
05:36:44 <ski> (contradiction ?)
05:37:07 <maerwald> how do I make "cabal haddock" not generate local filesystem links?
05:37:51 <{AS}> ski: The easiest way to show that two fmap implementations are the same is to show bisimulation right?
05:38:08 <{AS}> and so you have to show that it is impossible that they would deviate from the functorial laws
05:38:46 <{AS}> which means that it would be contradictory if they weren't unicent 
05:39:53 <{AS}> i.e. we know because that since fmap id = id, then forall f. fmap f [] = []
05:40:36 <michaelt> maerwald: are you uploading your own haddocks to hackage? 
05:40:42 <merijn> {AS}: btw, in haskell you need only 1 functor law :)
05:40:45 <maerwald> no, but something similar
05:40:51 <merijn> {AS}: "fmap id == id", that's it :)
05:41:00 <{AS}> merijn: I believe you told me the other one follows by parametricity, right?
05:41:01 <{AS}> :)
05:41:04 <merijn> Yes
05:41:09 <cocreature> maerwald: there is a --for-hackage option in cabal 1.24
05:41:16 <maerwald> I already tried that
05:42:09 <michaelt> cabal haddock --hyperlink-source --html-location=xxx exists, but I don't profess to understand it
05:42:44 * hackagebot octane 0.5.7 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.7 (fozworth)
05:42:47 <ski> merijn : no `fmap id = id'. there's no need for there to be an `Eq' instance on the function type in question
05:42:52 <maerwald> and I don't really want '--for-hackage', I want to put the documentation to a github.io page and have the links properly reference hackage
05:43:09 <dcoutts> maerwald: the --html-location flag is what you want
05:43:13 <merijn> ski: I'm not talking about haskell ==
05:43:22 <ski> then don't write `==' ?
05:43:24 <merijn> ski: Also = would be wrong too if we talked about =
05:43:40 <merijn> ski: Well, what else then? They only need to be structurally equal, not definitionally
05:43:47 <merijn> So clearly = is wrong too
05:43:59 <merijn> s/structurally equal/extensionally equal
05:44:02 <dcoutts> maerwald: possibly also --contents-location
05:44:27 <merijn> ski: If you give me a notation for extensional equality I'd be more than happy to use that :)
05:44:35 <ski> merijn : clearly it was used as a proposition, so it's not definitional equality
05:44:59 * ski actually prefers using the same symbol for both
05:45:02 <hpc> ^
05:45:07 <merijn> ski: As a proposition it still leaves open the question of extensional vs intensional equality
05:45:21 <{AS}> Intensional equality is not fairly useful :)
05:45:35 <hpc> intensional equality is useful in other contexts
05:45:49 <{AS}> I mean we use it for decidability
05:45:54 <hpc> but haskell doesn't have the mechanisms to make you care
05:45:55 <hpc> ;)
05:46:06 <{AS}> But for proving things it is more a pain than a feature :)
05:46:11 <ski> (i suppose you could perhaps use `≡' or `===', if you insist ?)
05:46:16 <dcoutts> maerwald: e.g. something like --html-location=https://hackage.haskell.org/package/$pkg-$version/docs/
05:46:32 <merijn> hpc: Sure we do :)
05:46:32 <tobiasBora> Hello,
05:46:33 <maerwald> ah, it takes variables?
05:46:39 <merijn> hpc: reallyUnsafePtrEquality#
05:46:43 <{AS}> > (:~:)
05:46:44 <lambdabot>  Not in scope: data constructor ‘:~:’
05:46:45 <hpc> oh you
05:46:51 <dcoutts> maerwald: yes, to construct the right urls
05:47:14 <tobiasBora> I would like to use unicode in variable name. I can do it with grec letters, but I can't do it with ∈. Do you know if there is a way to do it ?
05:47:15 <hpc> merijn: what makes it unsafer than the regular sort of unsafe i wonder :P
05:47:18 <merijn> Haskell has the best naming for unsafe things :)
05:47:26 <{AS}> If something is really unsafe why should it be supported
05:47:33 <merijn> hpc: It can produce both false positives AND false negatives, yay!
05:47:44 * hackagebot shake 0.15.7 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.7 (NeilMitchell)
05:47:49 <hpc> lol
05:47:59 <merijn> I'm not even joking :)
05:48:07 <maerwald> dcoutts: that looks indeed like what I want, thanks
05:48:12 <{AS}> merijn: http://soundiness.org/
05:48:22 <merijn> {AS}: Because GHC is a playground and happily exposes all the dirty internals for you to play with
05:48:35 <merijn> {AS}: Of course, if you don't know what you're doing it'll blow up in your face
05:48:37 <hpc> omg is that website a riff on truthiness?
05:48:51 * ski thinks the whole naming convention with "unsafe" isn't very helpful
05:48:52 <hpc> i just scrolled down, yes it is
05:49:29 <merijn> ski: The real problem, imo is that the convention is really straightforward
05:49:38 <{AS}> It should introduce the Unsafe monad
05:49:50 <ski> one shouldn't just claim that an operation is "unsafe" in some vague sense. one should indicate the proof obligation of the user
05:49:51 <merijn> since "reallyUnsafePtrEquality#", "unsafePerformIO" and "unsafeCoerce" are in WAAAAAAAAAY different classes of unsafe
05:49:54 <{AS}> with a destructor called unsafe
05:50:12 <merijn> In fact, unsafePerformIO is outright benign compared to the unsafeCoerce
05:50:16 <ski> e.g. `unsafePerformIO' could have been called `promisePureIO' or something like that
05:50:42 <merijn> I should start a group to rename unsafeCoerce to "iLikeDebuggingSegfaults"
05:50:43 <ski> (Mercury uses this "promise" convention)
05:50:55 <hpc> unsafePerformIO is equal to unsafeCoerce in the violations it admits
05:50:56 <{AS}> Why would you use unsafeCoerce anyway?
05:51:00 <hpc> you can implement either in terms of the other
05:51:03 <ski> (`unsafeCoerce' can be implemented in terms of `unsafePerformIO' and `IORef's)
05:51:07 <dcoutts> merijn: don't forget my favourite accursedUnutterablePerformIO :: IO a -> a
05:51:12 <merijn> {AS}: Because The safe coerce didn't exist :)
05:51:18 <merijn> dcoutts: It's no longer named that :(
05:51:25 <merijn> dcoutts: I think it's inlinePerformIO now
05:51:39 <dcoutts> waaat!
05:51:48 <merijn> dcoutts: I'd have to check to be sure, though
05:51:53 <ski> (also it's debatable whether `unsafeInterleaveIO' is unsafe)
05:51:59 <{AS}> I like my naming schemes like I like my food
05:52:08 <merijn> {AS}: Spicy and varied? :p
05:52:18 <hpc> i like the use of the word "unsafe"
05:52:24 <{AS}> I would have said safe to eat
05:52:28 <{AS}> :)
05:52:38 <dcoutts> merijn: phew! no it's still there.
05:52:45 <hpc> even though it doesn't totally communicate what it's about, it is such a showstopper of a word in a programming context that you have to stop and look at it and make sure it's being used right
05:53:00 <dcoutts> merijn: I renamed it from inlinePerformIO. You scared me that someone had switched it back without telling me :-)
05:53:14 <{AS}> They should really call the unsafe stuff %%%%UNSAFEPERFORMIO%%%%
05:53:32 <{AS}> Make sure everyone sees that you are doing something you may not want to do
05:53:59 <{AS}> The editors should even implement blink on top as syntax coloring
05:54:09 <hpc> ski: imo it is, because though it doesn't break out of IO entirely it breaks purity anyway
05:54:16 <hpc> ski: by binding execution to evaluation
05:54:25 <ski> hpc : that's the debatable part :)
05:55:10 <hpc> ski: a similar action of the same type that just forks off the computation wouldn't be a violation because it doesn't bind itself to any evaluation, but that's a hard nuance to explain to people
05:55:16 <hpc> yeah
05:55:43 * hpc can remember having that exact conversation here a couple of times in the past
05:55:54 * ski was possibly involved
05:56:35 <hpc> it's funny how something less predictable can be more legal than something that is totally predictable
05:57:02 <hpc> (or at least, less deterministic)
05:57:32 <merijn> hpc: How do you implement unsafeCoerce using unsafePerformIO, then?
05:57:49 <{AS}> merijn: You make a polymorphic IORef
05:58:09 <ski> merijn : use `topIORef :: IORef a; topIORef = unsafePerformIO (newIORef undefined)', then write and read
05:58:20 <ski> (or use `Maybe', if you don't like the `undefined')
05:58:28 <{AS}> It is why they have the value restriction in ML
05:58:29 <merijn> That's not the same operational behaviour, though
05:58:39 * ski was just about to say what {AS} said
05:58:42 <hpc> merijn: the magic there is that you can use topIORef :: IO Bool and topIORef :: IO Int in the same expression
05:59:03 <hpc> merijn: (in much the same way one can use id :: Bool -> Bool and id :: Int -> Int in the same expression)
05:59:20 <merijn> hpc: Sure, but to me that's not "implementing unsafeCoerce"
05:59:24 <ski> of course it only works if the I/O effect above of allocating the cell is done only once (iow shared)
05:59:29 <hpc> sure it is
05:59:33 <merijn> Because it ALWAYS results in bottom
05:59:40 <dcoutts> merijn: sure, then just unsafeCoerce a = unsafePerformIO $ do writeIORef polyRef a; readIORef ployRef
05:59:41 <{AS}> merijn: You have to assign to it
05:59:46 <merijn> oh
05:59:47 <merijn> Right
05:59:48 <hpc> unsafeCoerce v = unsafePerformIO $ do
05:59:55 <hpc>   writeIORef topIORef v
05:59:59 <hpc>   readIORef topIORef
06:00:20 <hpc> it's still pretty early in the morning ;)
06:00:31 <merijn> It is? >.>
06:00:31 <{AS}> Actually they had like weird imperical polymorphic variables before the value restriction
06:00:43 <{AS}> but noone really knew how to use them very well :)
06:01:04 <ski> ("imperical" ?)
06:01:06 <{AS}> imparative *
06:01:08 <{AS}> imperative*
06:01:15 <{AS}> Today is me not being able to spell day
06:01:16 <hpc> oh right, you're .nl
06:01:21 <ski> yes.  '2a  or something
06:01:39 <merijn> hpc: To be fair, I'm still jetlagged into chicago :p
06:01:39 * ski recalls seeing it in a paper
06:02:20 <hpc> so it's basically 8 for you
06:17:45 * hackagebot hetero-dict 0.1.0.1 - Fast heterogeneous data structures  https://hackage.haskell.org/package/hetero-dict-0.1.0.1 (winterland)
06:17:47 * hackagebot hedis 0.9.1 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.9.1 (k_bx)
06:32:46 * hackagebot octane 0.5.8 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.8 (fozworth)
06:44:47 * EvanR bwahaha memory usage remains essentially fixed as i move around shooting at nothing
06:45:58 <hpc> EvanR: ?
06:47:17 <EvanR> http://i.imgur.com/ugVI7yY.png
06:47:52 <merijn> :)
06:48:00 <hpc> you're making a game?
06:49:14 <EvanR> in a half experimental, half half-assed sort of way
06:52:52 <byorgey> . o O (what's a pirate's favorite closure description in a heap profile)
06:54:34 <locallycompact> byorgey, I don't know, what 's a pirates favorite closure in a heap profile?
06:55:12 <byorgey> locallycompact: see the link EvanR pasted for a hint =)
06:56:09 <locallycompact> byorgey, :)
06:57:32 <EvanR> ill take the liberty of being impressed as hell at the GC performance here
06:57:38 <EvanR> while i can
06:57:47 * hackagebot octane 0.5.9 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.5.9 (fozworth)
06:57:52 <EvanR> surely itll all go to shit at some point
06:58:00 <locallycompact> byorgey, btw, I referenced you in a blog post I wrote, maybe you'd do me the favour of casting a glance? :)
06:58:04 <locallycompact> http://locallycompact.blogspot.co.uk/2016/05/a-heideggerian-refinement-of-agile.html
07:00:19 <tobiasBora> There is something pretty simple I would like to do : create a type of 4-upple, who derive from Eq, Ord, Show...
07:00:23 <tobiasBora> I tried this 
07:00:47 <tobiasBora> data MyType = (Int,Int,Int,Int) deriving (Eq,Ord,Show)
07:00:58 <tobiasBora> but (Int,Int,Int,Int) cannot be a data
07:00:58 <merijn> tobiasBora: Lacks a constructor
07:01:13 <tobiasBora> merijn: Can't I avoid using constructor ?
07:01:17 <merijn> tobiasBora: No
07:01:28 <merijn> tobiasBora: Not if you want to create new instances
07:01:51 <tobiasBora> Well, since tupple already have a way to be created I cannot
07:01:54 <tobiasBora> *don't need it
07:01:56 <byorgey> locallycompact: I skimmed it, though I must confess I'm not in the mood to carefully read something so dense right now
07:02:06 <byorgey> locallycompact: I do like your idea of "comprehension as a deliverable" though
07:02:24 <tobiasBora> merijn: And can't I use "type MyType = (Int,Int,Int,Int)" with something like deriving ?
07:02:52 <ski> that four-tuple type already has instances of `Eq',`Ord',`Show'
07:02:55 <merijn> tobiasBora: Nope, type is literally just an alias for the original type and instances are tied to the type
07:02:58 <ski> do you need different instances ?
07:03:02 <locallycompact> byorgey, thanks, much obliged :)
07:03:18 <tobiasBora> merijn: Ok. Well too bad, thank you !
07:04:00 <Itkovian> tobiasBora you could do data MyType = MT (Int, Int, Int, Int) deriving (Eq, Ord, Show)
07:04:18 <Itkovian> but I'm not sure if this is worth it
07:04:31 <Itkovian> since the 4-tuple will also have this
07:04:50 <tobiasBora> Itkovian: Well since I would like to add personnal instances, I need something like that no ?
07:05:13 <ski> tobiasBora : iow, what's wrong with `type MyType = (Int,Int,Int,Int)' (and no extra `deriving') ?
07:05:15 <Itkovian> add what?
07:05:27 <ski> tobiasBora : oh, custom instances, in place of the derived ones
07:05:55 <ski> tobiasBora : may i ask what kind of custom instances ?
07:06:01 <tobiasBora> ski: Well I would like both : custom instances and derived ones
07:06:18 <tobiasBora> ski: I would like to define a distance notion
07:06:21 <ski> tobiasBora : there can be at most one instance of a type class, for a particular type
07:06:45 <tobiasBora> so I would like to do something like "class Distable x where dist :: x -> x -> Int"
07:07:12 <Itkovian> I would pick -> Double, but ymmv
07:07:47 * hackagebot scotty-params-parser 0.5.1.1 - HTTP-request's query parameters parser abstraction for "scotty"  https://hackage.haskell.org/package/scotty-params-parser-0.5.1.1 (NikitaVolkov)
07:08:26 <ski> tobiasBora : would you like custom instances of any of `Eq',`Ord',`Show', though ? or only for `Distance' ?
07:08:40 <merijn> tobiasBora: What's stopping you from doing "instance Distable (Int, Int, Int, Int) where"?
07:08:52 <tobiasBora> ski: I just need to have custom distance
07:08:55 <ski> you could also do what merijn said, with `FlexibleInstances'
07:09:13 <ski> tobiasBora : yes, but custom instances of which class(es) ? :)
07:09:20 <tobiasBora> Hum, I'm stupid ^^'
07:09:38 <hpc> why does this need type classes? are you writing a library?
07:09:53 <tobiasBora> by "custom distance" I mean "custom instance of class Distance"
07:10:14 <tobiasBora> hpc: Something like that...
07:10:46 <EvanR> maybe you can pass in a custom distance function to something
07:11:33 <tobiasBora> EvanR: I don't see what you mean
07:12:07 <tobiasBora> you mean I should give the distance function as an argument ? Class are practical, why shouldn't I use it ?
07:12:09 <ski> tobiasBora : instead of `foo :: Distance a => ..a..', why not `foo :: (a -> a -> Int) -> ..a..' ?
07:12:49 <ski> new classes should normally be defined only when you have at least two different instances in mind
07:12:54 <tobiasBora> ski: I thin it's clearer to have Distance a, I don't need it to propagate it everywhere in my code
07:13:10 <ski> tobiasBora : you may want to consider implicit parameters, then
07:13:31 <tobiasBora> ski : it's possible to use implicit parameters in haskell ? O_o
07:14:04 <ski> tobiasBora : see <https://www.haskell.org/ghc/docs/latest/html/users_guide/glasgow_exts.html#implicit-parameters>
07:14:42 <ski> sorry, wrong link. try <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters>
07:15:11 <tobiasBora> Hum really nice... 
07:15:17 <EvanR> theres also reflection
07:15:32 <EvanR> but the simplest is an argument
07:15:36 <tobiasBora> But actually I could use it for 2-upple, 3-upple... So I don't see why using classes is bad
07:15:54 <EvanR> using tuples for this is bad
07:15:59 <ski> tobiasBora : how would `dist' be defined for your quadruples ?
07:16:44 <tobiasBora> ski : like the number of "cases" that differs
07:17:14 <tobiasBora> for example dist (1,1,0,0) (2,1,1,0) = 2
07:17:39 <EvanR> if its all the same type, shouldnt you use a vector of some sort
07:17:47 * hackagebot hflags 0.4.2 - Command line flag parser, very similar to Google's gflags  https://hackage.haskell.org/package/hflags-0.4.2 (MihalyBarasz)
07:17:48 <EvanR> then it works with any length
07:18:27 * ski was thinking perhaps `dist (x0,x1,x2,x3) (y0,y1,y2,y3) = maximum [abs (x - y) | (x,y) <- zip [x0,x1,x2,x3] [y0,y1,y2,y3]]'
07:18:44 <tobiasBora> EvanR: Then it's difficult to propagate invariant in type, such as "every element must have the same length"
07:19:33 <EvanR> is it, i havent really tried 
07:19:44 <tobiasBora> ski: I could, but here I'm interesting in another distance ^^
07:20:05 <EvanR> there are type level natural literals..
07:20:27 <tobiasBora> EvanR: Well how can you be sure when you see the type that two vectors have the same length ?
07:20:49 <tobiasBora> Vector Int doesn't provide any information on the size of the vector
07:21:44 <EvanR> Vector 3
07:21:55 <EvanR> where 3 is a type
07:22:05 <hpc> or a lifted natural number
07:22:25 <tobiasBora> Really ?
07:22:32 <EvanR> hmmmm my heap profile graphs are showing constant memory usage, but RES in htop is continuing to increase...
07:22:46 <EvanR> what gives
07:22:49 <EvanR> who to trust
07:23:40 <ski> tobiasBora : hm, afaik, it's a metric space
07:23:43 <tobiasBora> EvanR: fromList [1,2,3] :: Vector 3
07:23:46 <ski> s/afaik/afaics/
07:23:46 <tobiasBora> gives me an error
07:24:49 <EvanR> yes, but its possible with different syntax and library support
07:24:57 <geekosaur> I thought it was V3? (hasn't been redone for typelits yet)
07:25:20 <tobiasBora> ski: Well I need Hamming distance here : https://fr.wikipedia.org/wiki/Distance_de_Hamming
07:27:38 <merijn> EvanR: RES is meaningless
07:27:50 <EvanR> alrighty then
07:27:51 <merijn> EvanR: Well, not entirely
07:28:08 <ski> tobiasBora : *nod*
07:28:23 <EvanR> so go with GHC stats 
07:29:00 <merijn> EvanR: The point is, it makes sense for GHC to grab a bunch of virtual memory from the OS so it doesn't constantly have to call sbrk to get more memory (expensive system call), so most languages with a runtime end up doubling every time they have to sbrk
07:29:13 <EvanR> and so it can unmap
07:29:20 <merijn> EvanR: Virtual memory, of course, is basically free as long as you're not using it (it will just get swapped)
07:29:28 <EvanR> but VIRT is already way up there
07:29:32 <tobiasBora> ski: Not sure to follow you
07:29:33 <EvanR> and doesnt change much
07:29:52 <merijn> EvanR: RES is basically "pages of virtual memory RESident (present) in physical memory)
07:29:53 <EvanR> RES creeps up slowly, making me nervous
07:29:54 <tobiasBora> EvanR: If you have examples of Vector 3 I'm interested
07:30:12 <merijn> EvanR: If your system has low memory pressure the OS basically can't be arsed to swap RES to disk
07:30:26 <merijn> EvanR: Because, why bother if no other process needs it
07:30:49 <EvanR> ok
07:30:59 <EvanR> so what is the 60k in the heap profile that im hovering around
07:31:10 <EvanR> memory-as-comprehended-by-the-runtime?
07:31:24 <merijn> EvanR: "amount of data GHC actually cares about" (i.e. not garbage)
07:31:41 <EvanR> really?
07:31:48 <EvanR> surely there is garbage i dont know about yet
07:31:49 <merijn> EvanR: How much is RES increasing over what time frame?
07:32:05 <EvanR> like 5 to 15 every few seconds
07:32:09 <EvanR> in units of who knows
07:32:22 <EvanR> a five digit number
07:32:48 * hackagebot language-dart 0.1.0.0 - Manipulating Dart source: abstract syntax and pretty-printer  https://hackage.haskell.org/package/language-dart-0.1.0.0 (kseo)
07:33:16 <EvanR> maybe that is GHC runtime chewing through memory and old memory is being left resident because OS
07:33:25 <merijn> EvanR: tbh, I wouldn't trust htop for monitoring anyway? Is there something like /proc where you can ask the OS?
07:34:10 <merijn> On OSX I would usually use like DTrace/Activity Monitor for detailed info
07:34:16 <EvanR> i guess the blogosphere recommends Activity Monitor
07:34:26 <hpc> on windows?
07:34:35 <EvanR> OSX
07:34:35 <ski> tobiasBora : i only recall seeing hamming distance in relation to binary strings
07:34:36 <geekosaur> process explorer
07:34:43 <geekosaur> (on win)
07:34:50 <hpc> ah right
07:34:52 <merijn> EvanR: Yeah, on OSX do activity monitor, double click process and you get the numbers
07:35:10 <lipt> z
07:35:21 <merijn> FWIW, bash has 2.36GB virtual memory in use on my system, apparently >.>
07:35:40 <tobiasBora> Well me I use it to play with differencial privacy
07:36:25 <merijn> EvanR: And if you REALLY want to get detailed you can always get loads of interesting stuff using DTrace, but that'd require like a few hours learning DTrace :p
07:36:32 <EvanR> activity monitor is showing less detailed numbers, but they dont appear to be creeping upward
07:36:43 <merijn> EvanR: (OTOH, learning DTrace is a totally worthwhile investment)
07:36:52 <EvanR> yes i heard of it
07:37:38 <merijn> EvanR: Maybe keep it running overnight and see what happens? If there's a real leak you should see it, if it's just htop faffing about...that should also be clear :)
07:37:48 * hackagebot streaming 0.1.4.2 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.1.4.2 (MichaelThompson)
07:40:39 <darthron> Hi, guys!
07:40:57 <dmj> darthron: hi ! 
07:41:19 <lifter> :r hi
07:41:58 <darthron> I have a quick question. I've just seen that you cand have `data MyData = Int String`. How do you declare something of this type and how is it used?
07:42:22 <lipt> z
07:42:37 <merijn> EvanR: Dunno how old your htop is, but I also see a bunch of bug reports of RES and VIRT memory reported by htop being wrong (off by 4x it seems), so I'd take Activity Monitor accuracy over htp any day :)
07:42:37 <ski> darthron : e.g. `Int "foo"' would be an expression of type `MyData'
07:42:50 <merijn> (on OSX, that is)
07:43:05 <ski> darthron : also, i'd say that it's a bit confusing to name the data constructor there `Int', since `Int' would normally make one think of the type
07:43:23 <geekosaur> darthron, note that the Int in that is not the same as the type Int
07:43:39 <geekosaur> it's a data constructor name, not a type
07:44:25 <merijn> EvanR: You could also try just "top" since that ships with OSX, instead of being 3rd party
07:44:26 <EvanR> merijn: time to make a quake console to get real time stuff from ghc stats
07:44:46 <merijn> But I'm not enough of a top wizard to find the right process :p
07:44:55 <EvanR> top is weird... i cant figure out how to operate it
07:44:58 <EvanR> its not like linux
07:45:05 <merijn> EvanR: Correct, it's bsd top :p
07:45:26 <tobiasBora> Does anyone knows where the package https://hackage.haskell.org/package/hmatrix-0.13.0.0/docs/Numeric-GSL-Minimization.html goes in recent versions of hmatrix ?
07:45:34 <geekosaur> for comparison: in `data Maybe a = Nothing | Just a`, Maybe is a type (type constructor), Nothing and Just are data constructors (a data value and a data constructor, respectively)
07:45:34 <tobiasBora> I'm looking for a good tool to do minimisation...
07:45:57 <merijn> EvanR: The same for several others. I had the reverse problem first using linux (I started on BSD), some commands being subtly different, but not different enough to remember until you hit that one weird corner case ;)
07:46:06 <geekosaur> mrf, I botched that, it's probably more confusing now
07:46:51 <EvanR> capital names can be types or constructors (or type constructors!) 
07:46:58 <EvanR> now its all clear
07:47:14 <geekosaur> yeh, but I used "data constructor" in two different ways in there /o\
07:48:00 * EvanR momentarily has existential crisis about english words for haskell then finds breakfast
07:49:11 <geekosaur> that one at least isn't worth it; natural language sucks for precision, and something as insanely multi-valued as English especially so
07:50:24 <ertesx> hi there…  is there a library for serialisable functions?  it doesn't have to be a full embedded scripting language, just a way to construct functions that i can render to and read from JSON (ideally) or some other encoding
07:50:33 <EvanR> constructor is a versatile concept, unless you get mixed up with c++...
07:50:52 <ertesx> but not via GHC static pointers, because the underlying haskell may change over time
07:50:56 <EvanR> in which case its a bad choice of words
07:51:53 <darthron> ski: oh, okay, that's why I was confused. Thank you!
07:52:03 <darthron> geekosaur: Thank you!
07:52:05 <merijn> ertesx: Are both sides of the communication using haskell?
07:52:30 <ertesx> merijn: there is only one side…  i need to save and restore functions
07:52:35 <merijn> ertesx: Because, if so, "Map String (a -> b)"? If that doesn't work...eh...good luck?
07:53:03 <ertesx> if not, i'm going to invent a small EDSL like accelerate's
07:53:46 <geekosaur> I suspect some hack along the same lines as the ad package could be used to carry a text description of known functions around... or maybe some typeclass-based thing
07:54:00 <geekosaur> but I don't think there's one already, unless the universe package has one hidden inside it (with the limitations of that...)
07:54:23 <ertesx> they don't have to be haskell functions, but they should be somewhat easy to write in haskell – like accelerate functions
07:55:35 <ertesx> i think i'll go the EDSL route, perhaps with RebindableSyntax, because do-notation would be useful
07:56:39 * ski immomentarilaty has universal crisis about logic terms for english
07:58:36 <rtpg> Is there something I can put in my cabal file that'll set my project to "-Wall" on compile?
07:58:41 <rtpg> I'm using stack
07:58:59 <dcoutts> rtpg: ghc-options: -Wall in the .cabal file
07:59:22 <dcoutts> that's a per-component thing, ie per lib, per exe etc
08:02:49 * hackagebot streaming-bytestring 0.1.4.4 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.4.4 (MichaelThompson)
08:12:49 * hackagebot streaming-utils 0.1.4.3 - http, attoparsec, pipes and conduit utilities for the streaming libraries  https://hackage.haskell.org/package/streaming-utils-0.1.4.3 (MichaelThompson)
08:13:30 <rtpg> thanks for that info, super usefl
08:19:56 <netsu> Hello! Trying get colors in ghci like here https://wiki.haskell.org/GHCi_in_colour#Full_highlighting
08:20:28 <netsu> But ==> Usage: For basic information, try the `--help' option.
08:20:47 <netsu> I mean ==> ghc: unrecognised flag: --colour
08:21:12 <dolio> Never heard of that flag.
08:21:38 <netsu> Isn't it supported for 7.10.3?
08:21:54 <infandum> How can I define a type point free? Like, instead of doing (\x -> x :: Double) . genericLength $ xs can I do (:: Double) or something like that?
08:23:09 <geekosaur> infandum, not yet
08:24:37 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/SignatureSections didn't make ghc8.0.1
08:24:55 <dolio> netsu: I don't remember that ever being an option. It's not clear that that part of the article isn't just someone's idea for something cool.
08:25:04 <geekosaur> netsu, that doesn't exist yet as I read it
08:25:20 <geekosaur> which is why the following sections give you two ways to actually do it
08:25:22 <netsu> that option would be nice to have
08:26:11 <netsu> geekosaur: ok, I'll try them. Thanks to all anyway
08:26:24 <geekosaur> note that both have known shortcomings
08:33:13 <infandum> geekosaur: OK, thanks, it's good to know that it's on the upcoming features
08:52:51 * hackagebot IntervalMap 0.5.1.0 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.5.1.0 (ChristophBreitkopf)
08:54:55 <ertesx> you know, GHC, you sure don't support writing backward-compatible code
08:55:19 <ertesx> this is not a technical complaint: how can you update to GHC 8 and *not* use -XTypeInType all over the place?
08:56:47 <scshunt> hah
08:56:50 <scshunt> what did you do?
08:59:16 <ertesx> i just read the release notes of GHC 8
08:59:20 <ertesx> now i'm updating
08:59:41 <scshunt> oh, lol
09:00:07 <ertesx> we're so close to -XDependentTypes now
09:00:20 <scshunt> I needed to monomorphize a type because it stopped inferring a constraint
09:00:32 <scshunt> I could have written the constraint manually but it was easier to monomorphize
09:00:39 <ph88> how can i check if a Char is equal to one of these characters ?    " # & ' () * + , - . / : ; < = > [ ] _ |
09:00:55 <glguy> :t elem
09:00:56 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
09:00:57 <ertesx> ph88: an easy way is to use elem
09:01:25 <ertesx> ph88: if you do this repeatedly, an efficient and still easy way is to use Data.Set or Data.IntSet
09:02:03 <ertesx> > S.member 'a' (S.fromList "abcdef")
09:02:04 <lambdabot>  True
09:02:24 <heebo> anyone managed to get ghc-mod working with emacs in haskell?
09:02:34 <heebo> on stack?
09:02:37 <hpc> i can't wait until someone excitedly posts that haskell can specify the size of a vector with a type signature, and someone else says C++ templates have been doing it for years
09:02:45 <hpc> it'll be comedy gold
09:02:57 <merijn> hpc: To be fair, C++ templates can do a bunch of stuff haskell just can't
09:03:08 <merijn> No comment on whether those things are good things...
09:03:44 <ertesx> hpc: mainly i want to encode equivalence constraints in my semantics
09:03:52 <hpc> if you tell the compiler to have no limit on template crunching, it's turing-complete
09:03:54 <ertesx> often simply by unification
09:04:14 <hpc> ertesx: i am excited for the matrix libraries
09:04:26 <ph88> ertesx, you mean Data.Set or Data.IntSet is faster than elem ?
09:04:29 <hpc> imagine a DT'd gpgpu edsl
09:04:41 <heebo> hpc: which is the easiest matrix library to use in your opinion?
09:04:52 <ertesx> hpc: currently this is solved in an ugly singleton types way:  getAccess :: SUser u -> SResource r -> IO (Maybe (Access u r))
09:05:13 <ertesx> i have to translate between types and values all the time…  and going from values to types is particularly ugly
09:05:31 <hpc> yeah
09:05:38 <ertesx> ph88: simple 'elem' can be faster, if you have only very few characters
09:05:48 <hpc> i just want to see mult :: Matrix a b -> Matrix b c -> Matrix a c
09:06:01 <merijn> heebo: Does performance matter?
09:06:12 <ertesx> ph88: IntSet is the fastest option, HashSet is almost as fast, but does not require the Int encoding, and Set is reasonably fast
09:06:12 <hpc> a, b, c :: Integral n => n
09:06:30 <heebo> merijn: ish.... 
09:06:40 <hpc> also i just noticed that type looks like function composition
09:06:41 <ertesx> ph88: if we pretend that Char is an infinite type, then all of them have logarithmic membership tests
09:06:44 <hpc> i suppose it is in a way
09:07:06 <ertesx> ph88: (they are actually constant in practice)
09:07:09 <merijn> heebo: Then just use haskell bindings for blas? https://hackage.haskell.org/package/hblas
09:07:24 <heebo> i mean i dont want to quibble over nanoseconds
09:07:24 <heebo> thanks 
09:07:38 <ertesx> hpc: that one is actually easy enough…  see the linear library
09:08:02 <merijn> heebo: BLAS is like the state of the art in "fast C matrix processing", so if that's not fast enough, you're shit out of luck :p
09:08:22 <merijn> Actually...I suppose BLAS might actually be Fortran? Not sure...
09:08:24 <ertesx> hpc: (!*!) :: (…) => m (t a) -> t (n a) -> m (n a)
09:08:26 <ph88> ertesx, well it's for a parser so i'll take the fastest choice, the Data.IntSet
09:09:06 <levi> merijn: I think it is Fortran.
09:09:11 <hpc> ertesx: now i am just imagining what the absolute most generic thing you can put into that (...) is
09:09:13 <ertesx> ph88: there is a faster choice, if you want to go for the absolute best possible speed, but it's a bit inconvenient:  make a bit field for the character range and testBit it
09:09:35 <hpc> maybe if all of them were both Traversable and Monad
09:09:51 <ertesx> ph88: you could abuse Integer to do that, or you could use the 'vector' library with an unboxed Word vector
09:10:00 <ertesx> ph88: in all cases it requires a bit of programming and testing
09:10:36 <ertesx> ph88: IntSet and HashSet are reasonably fast though…  go the bitfield route, if it actually becomes a bottleneck
09:10:36 <hpc> :t traverse
09:10:37 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:10:57 <ph88> ertesx, well i'm a beginner, what type should i choose ?
09:10:59 <ertesx> hpc: (!*!) :: (Functor m, Foldable t, Additive t, Additive n, Num a) => m (t a) -> t (n a) -> m (n a)
09:11:25 <ertesx> ph88: HashSet from Data.HashSet from the unordered-containers package
09:11:51 <ertesx> it gives you IntSet performance with a Set interface
09:12:06 <ertesx> > HS.member 'a' (HS.fromList "abcde")
09:12:07 <lambdabot>      Not in scope: ‘HS.member’
09:12:07 <lambdabot>      Perhaps you meant one of these:
09:12:07 <lambdabot>        ‘S.member’ (imported from Data.Set),
09:12:24 <ertesx> @let import qualified Data.HashSet as Sh
09:12:25 <lambdabot>  .L.hs:89:1:
09:12:25 <lambdabot>      Data.HashSet: Can't be safely imported!
09:12:25 <lambdabot>      The module itself isn't safe.
09:12:43 <ertesx> seriously?
09:12:49 <ph88> :/
09:13:21 <ertesx> ph88: don't worry about it…  the error message just tells us that lambdabot doesn't feel good (security-wise) about importing that module and exposing its functionality to us =)
09:13:28 <hexagoxel> til: when using CPP, multiline string literals need \\ at the end of the line, next line as usual.
09:13:33 <hpc> ertesx: i was thinking even more generic than that
09:14:11 <ertesx> hpc: in principle you can use Applicative rather than Additive
09:14:25 <levi> merijn: At least historically BLAS is Fortran; it's more of a standard than a single codebase now and there are apparently Fortran and C versions, and probably large bits of the highly optimized binaries were at least partially hand-optimized assembly.
09:15:03 <ph88> oki
09:15:21 <hpc> ertesx: i think the issue there is losing Num there, which is implicitly using (*, 1) as the monoid for Foldable t
09:15:29 <hpc> or something
09:16:11 <ertesx> hpc: there is a package for semirings…  but this smells suspiciously like overengineering =)
09:16:15 <tobiasBora> Is there a way to say "when I wrote MyType a, a MUST be Ord", so that I don't write everywhere (Ord a) => MyType a -> ... ?
09:16:22 <hpc> yeah
09:16:39 <hpc> it just seems like one of those funny things, composition of type functions and whatnot
09:16:51 <ertesx> tobiasBora: type MyTypeOrd a = (Ord a) => MyType a
09:17:01 <tobiasBora> ertesx: Thank you !
09:17:02 <ertesx> tobiasBora: requires -XRankNTypes though (i think)
09:17:16 <ski> ertesx : i
09:17:23 <hpc> or something that RankNTypes implies
09:17:24 <ertesx> tobiasBora: and it would be a readability hit to do that…  and you may find yourself typing more rather than less
09:17:32 <ski> ertesx : i'm not sure that'll do what tobiasBora wanted ..
09:17:50 <ski> or rather, it'll only do it, if used as a return type
09:17:52 * hackagebot libroman 2.0.0 - arabic to roman numeral conversions  https://hackage.haskell.org/package/libroman-2.0.0 (ahakki)
09:18:00 <hpc> maybe a GADT?
09:18:03 <ertesx> oh, indeed
09:18:10 <ski> ("presupposition" is not the same as "assumption")
09:18:18 <ertesx> tobiasBora: nevermind, my solution sucks in many more ways =)
09:18:20 <hpc> data MyType where Foo :: Ord a => a -> MyType a
09:18:58 <ertesx> hpc: that loses the ability to unify
09:19:01 <tobiasBora> hpc: I'm not sure to understand the where clause
09:19:02 <ertesx> MyType a -> MyType a
09:19:04 <ski> s/where/a where/
09:19:24 <ski> the GADT, or alternatively `data MyType a = Ord a => Foo a' is the best answer, i think
09:19:27 <ertesx> hpc: no, it doesn't…  your lacking kind signature confused me
09:19:46 <hpc> oh right
09:19:50 <hpc> i was wondering why it looked off
09:20:09 <ggVGc> wish I had some GGADTs so I could generalise my generalisations
09:20:36 <hpc> tobiasBora: it's GADT syntax, which is a different and imo better overall way to write data definitions
09:20:54 <hpc> tobiasBora: a very simple example with newlines and none of the GADT features would be
09:20:58 <hpc> data Bool :: * where
09:21:00 <hpc>   False :: Bool
09:21:03 <hpc>   True :: Bool
09:21:15 <ertesx> tobiasBora: hpc's definition means: whenever you pattern-match on a value of type 'MyType a', you will know (in that clause) that 'a' is an Ord
09:21:36 <hpc> tobiasBora: basically, you write "data {name of type} :: {kind of type} where"
09:21:47 <hpc> tobiasBora: and then in the block you list the type signature of every constructor for the type
09:22:11 <hpc> another one is
09:22:15 <hpc> data Maybe :: * -> * where
09:22:18 <hpc>   Nothing :: Maybe a
09:22:22 <hpc>   Just :: a -> Maybe a
09:22:32 <ertesx> hpc: data Bool = False | True  -- i like this one better =)
09:22:56 <hpc> well for Bool maybe :P
09:23:26 <tobiasBora> I cannot find which LANGUAGE I should add to have gadts
09:23:36 <hpc> {-# LANGUAGE GADTs #-}
09:24:15 <ertesx> and KindSignatures
09:24:20 <hpc> fair warning, GADTs are the gateway drug to language extensions
09:24:26 <hpc> i think GADTs enables KindSignatures too
09:24:29 <ertesx> it doesn't
09:24:32 <hpc> ah :(
09:25:05 <scshunt> ertesx: yes, short data definitions are nice, but only when they can be expressed :)
09:25:23 <tobiasBora> Hum... I keep having error saying I do not have GADTs
09:25:24 <hpc> i like seeing "Just :: a -> Maybe a" far more than i like seeing "Just a"
09:25:25 <tobiasBora> http://pastebin.com/pvxQiHuR
09:25:52 <hpc> oh, i don't think that comment will work in ghci
09:25:54 <ertesx> scshunt: i have yet to see a case of a non-G ADT that is shorter to write with GADT syntax…  and most ADTs are non-G =)
09:25:58 <hpc> you'll need to do ghci -XGADTs
09:26:14 <JazzyEagle> Hey, folks.  I'm trying to figure out how to extract info from a website.  Wiktionary.org, specifically.  I'm at the point of trying to use their Rest API using aeson and curl-aeson, but I'm struggling with Aeson a bit...
09:26:18 <hpc> ertesx: it's not about shorter
09:26:50 <ertesx> the only thing i like more about GADT syntax is the uniformity of it:  every line has the same shape, there is no "=" and "|" to watch out for
09:26:55 <ertesx> but that's a nitpick really
09:26:57 <JazzyEagle> Specifically, most of the tutorials I'm finding are showing clean JSON examples, where there's just a oouple of basic variables within one object.  I'm getting a little confused when it comes to objects within objects, etc...
09:27:11 <ggVGc> what's a simple situation when you'd be pushed to need a GADT?
09:27:27 <JazzyEagle> I'm noticing a bunch of other aeson libs.  Are there any that help deal with the embedded objects better?  If not, can someone explain how I can use Aeson to extract the embedded objects nicely?
09:27:36 <tobiasBora> hpc: Hum ok, I can also use :set -XGADTs
09:27:36 <hpc> ggVGc: typed eDSLs
09:27:49 <tobiasBora> Let's now test it on my project !
09:27:52 * hackagebot libroman 2.0.1 - Roman Numerals for YOU  https://hackage.haskell.org/package/libroman-2.0.1 (ahakki)
09:27:54 * hackagebot cndict 0.7.8 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.8 (DavidHimmelstrup)
09:28:26 <ertesx> JazzyEagle: if you can't *derive* a FromJSON instance, you will have to write it by hand, and the haddocks explain most of how to do that…  everything else follows from the types
09:28:32 <JazzyEagle> Really, I'm just looking for the pageId, so if I could ignore all the rest of that information, that'd be even better.  For an example of the layout I'd need:  https://en.wiktionary.org/w/api.php?action=query&titles=hello&format=jsonfm
09:28:59 <ggVGc> hpc: so, if I wanted to protype a language within haskell, I could model the AST using GADTs, and have the haskell program generate my compiled code, without resorting to TH?
09:29:16 <hpc> something like that, yeah
09:29:22 <ggVGc> that sounds interesting
09:29:24 <ertesx> JazzyEagle: create a type to hold it:  newtype PageId = PageId { fromPageId :: Int }
09:29:30 <ggVGc> since I actually have a small language I want to prototype
09:29:39 <ggVGc> but I don't want to spend too much implemetnation effort on it
09:29:42 <ertesx> JazzyEagle: then write a FromJSON instance that descends into the nested structures and gets the id
09:29:44 <ggVGc> and I dont care about syntax taht much
09:29:46 <hpc> you'd use GADTs in combination with specific type signatures to express that some constructors are impossible to find in certain scenarios
09:30:01 <JazzyEagle> ertesx: I'm not sure I understand how to descend into the nested structure using fromJSON.
09:30:14 <JazzyEagle> Again, the examples show one object with a couple of basic variables.
09:30:31 <ggVGc> hpc: do you know of any project that does something similar to this that I could take inspiration from?
09:30:37 <JazzyEagle> In this case, I need a value in an Object of an Object of an Object of an Object.
09:30:37 <ertesx> JazzyEagle: what i see there is a bunch of nested objects
09:30:51 <thoughtpolice> hpc: I agree GADT syntax is much nicer than ordinary data decl syntax. I think at one point the wild suggestion to make GADT-ish syntax the 'enshrined' syntax was at least floated around (not by me)
09:30:53 <hpc> i know they exist, but i can't name one off the top of my head
09:31:06 <ggVGc> reading the haskell wiki o GADTs now
09:31:08 <ggVGc> cheers
09:31:12 <hpc> thoughtpolice: it might have been me if it was recent enough
09:31:21 <hpc> but i wouldn't be surprised in the least if it was someone else
09:31:32 <thoughtpolice> ggVGc: http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html is a good example
09:31:40 <ggVGc> thanks
09:31:51 <ggVGc> hm, that doesn't load for me
09:32:00 <JazzyEagle> ertesx: Yes, but I don't understand through the example how to traverse down through the embedded objects.
09:32:00 <ggVGc> maybe it's being blocked..
09:32:30 <thoughtpolice> hpc: No, I think this was Richard. Either way I'd be +1 on it.
09:32:33 <thoughtpolice> ggVGc: Try http://archive.is/DjSFd then
09:33:22 <ertesx> JazzyEagle: in this simple case, you can do without FromJSON…  these two functions will help you, but you have to write them yourself:  object :: Value -> Maybe Object;  field :: Object -> Text -> Maybe Value
09:33:23 <hpc> i have a feeling it will happen when DependentHaskell happens
09:33:37 <hpc> every other DT'd language i have seen uses GADT syntax
09:34:07 <thoughtpolice> This was in regards to the language standard, too. Dependent Haskell isn't coming close to that anytime soon.
09:34:36 <hpc> yeah
09:34:49 <ertesx> JazzyEagle: wait, flip the arguments of field:  field :: Text -> Object -> Maybe Value
09:35:00 <hpc> if i cared enough to figure out how, i would create a trac account and propose enabling GADTSyntax by default
09:35:14 <ph88> ertesx, i made this helper function for my parser:    charInString string = satisfy $ \x -> HS.member x (HS.fromList string)
09:35:19 <ertesx> JazzyEagle: then you can just chain them (import Control.Monad):  object >=> field "query >=> object >=> field "pages" >=> ...
09:36:16 <michaelt> JazzyEagle: with lens-aeson you can apply this to the json you linked  json ^? key "query" . key "pages". key "4803". key "pageid"
09:36:17 <JazzyEagle> ertesx: Ok, so then the field would assume that I know the number that is used as the key for the 3rd embedded object (labeled "4803" in the sample I provided)
09:36:26 <michaelt> JazzyEagle: and get Just (Number 4803.0)
09:37:09 <ertesx> JazzyEagle: not sure what you mean, but check michaelt's solution, too…  if you're a lens user, it's way simpler
09:37:12 <JazzyEagle> michaelt: You have the same assumption:  When using curl-aeson, I don't know what number is being returned.  If I knew that, i don't think I'd need to access the Rest API at all.
09:37:29 <ertesx> JazzyEagle: it *extracts* the number
09:37:30 * JazzyEagle will need to read up on lenses...  Not sure how to do that.
09:37:34 <ertesx> both of them do
09:38:14 <ph88> i use stack, how can i import HashSet ?  my import statement gives this error:   Could not find module ‘Data.HashSet’      import Data.HashSet as HS (member)
09:38:15 <JazzyEagle> ertesx: No, I mean the code that michaelt provided (adding intentional emphasis):  json ^? key "query" . key "pages" . key ***"4803"*** . key "pageid"
09:38:27 <JazzyEagle> I wouldn't know the number used in that key to code it into the program.
09:38:34 <ertesx> oh, i'm pretty sure that was a mistake
09:38:52 <JazzyEagle> But that is the key to the 3rd embedded object.
09:39:03 <michaelt> JazzyEagle: right, the way this is set up, you would have to do two passes, I guess to get the stuff deeper in
09:39:10 <ertesx> oh, i didn't even see that
09:39:26 <michaelt> JazzyEagle: json ^.. key "query" . key "pages" gives: [Object (fromList [("4803",Object (fromList [("ns",Number 0.0),("pageid",Number 4803.0),("title",String "hello")]))])]
09:39:43 <ertesx> with lens you could just traverse everything below the "pages" key
09:39:48 <michaelt> JazzyEagle: which is easy enough to pattern match on
09:40:59 <ggVGc> what have you guys used GADTs for in the past?
09:41:13 <ertesx> key "query" . key "pages" . _Object . traverse . key "pageid"
09:41:18 <ertesx> that should do it
09:41:58 <lyxia> ph88: are you running "stack ghci" and have you installed unordered-containers
09:42:17 <michaelt> ertesx: perfect  json ^? key "query" . key "pages" . _Object . traverse . key "pageid"
09:42:24 <michaelt> ertesx: Just (Number 4803.0)
09:42:51 <ertesx> even better:  key "query" . key "pages" . _Object . traverse . key "pageid" . _Integer
09:42:59 <ph88> lyxia, i thought i had to install HashSet :/
09:43:39 <michaelt> Just 4803
09:44:19 <ph88> do i only have to escape double-quotes in string or other characters too?  i'm getting this error   lexical error in string/character literal at character '`'    for string    "!$%@?\^`{}~¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»���¿×÷�"
09:45:00 <ertesx> JazzyEagle: this lens just descends below that numeric key and doesn't care about its value…  however, it seems like a reasonable assumption that the key is actually the pageid itself
09:46:59 <tobiasBora> I tried lot's of differents way to deal with records, but it doesn't work : http://pastebin.com/iaVfa3HD
09:47:13 <JazzyEagle> ertesx: Thanks.  I'll read up on lens and give that a try, then.  :)
09:47:15 <tobiasBora> (I tried to add/remove almost all elements)
09:48:06 <Welkin> tobiasBora: put it on the turntable and place the needle on the record
09:48:08 <Welkin> you hipster noob
09:48:36 <ph88> ertesx, what do you think of my function, good idea ? maybe it rewrite it in a better way ?
09:49:04 <Welkin> god damn I have an urge to write something in haskell today
09:49:19 <Welkin> I haven't programmed in 6 months
09:49:32 <tobiasBora> you hipster noob
09:49:52 <ertesx> ph88: your function will make your code *less* efficient
09:50:08 <ertesx> ph88: reason is that you are constructing the HashSet for every single check
09:50:29 <ertesx> ph88: you should construct it once and give it a name, then use 'satisfy' with only 'HS.member'
09:51:17 <ertesx> let chars = HS.fromList "abcde"  -- then just reuse 'chars'
09:51:35 <Welkin> wtf is HS?
09:51:39 <ertesx> HashSet
09:51:55 <ertesx> (i prefer to call it Sh, but everybody else calls it HS)
09:53:41 <ph88> ertesx, the compiler doesn't optimize this ??
09:54:10 <ertesx> ph88: the compiler uses sharing for things that have a name
09:54:12 <ph88> it can know that the thunk of several functions is the same by analyzing the code
09:54:37 <ph88> i call it like this:     specialCharacter = charInString "\"#&'()*+,-./:;<=>[]_|"
09:54:46 <ertesx> ph88: but it doesn't automatically share expressions that are equal, because there is no way for it to know whether that's going to perform better, and a lot of times it would perform MUCH worse
09:55:29 <ertesx> yeah, don't do that
09:55:54 <erisco> hackage is just not applying my documentation update :(
09:56:33 <ertesx> ph88: do this instead:  ... satisfy (`HS.member` chars) ...  where chars = HS.fromList "..."
09:56:34 <ph88> ertesx, what about this, is this ok ?      charInString hashset = satisfy $ \x -> HS.member x hashset
09:56:47 <ertesx> ph88: yeah, that's better
09:56:48 <maerwald> erisco: which is why I fixed my travis build at github to upload a documentation to github pages
09:56:49 <ph88> ok
09:56:59 <ertesx> ph88: but only if your character set has a name
09:57:31 <thoughtpolice> It's probably the CDN being fickly. We need to make sure it PURGEs properly when docs go up...
09:57:44 <ertesx> ph88: bad: charInString (HS.fromList "...")
09:57:51 <ertesx> ph88: good: charInString myCharSet
09:57:58 <erisco> I think I got the directory structure wrong again
09:59:21 <erisco> is this still up-to-date? https://github.com/haskell/hackage-server/issues/56
09:59:24 <Cale> ph88: It will almost never take two subexpressions any more complicated than a single variable which are identical and common them up, even though it's a valid operation to perform, it's frequently devastating to space performance in a way which it's hard for the compiler to predict.
09:59:48 <erisco> the structure is  package-name-version-docs/src/  ? i.e. where all the generated haddock stuff goes?
09:59:58 <Cale> The one exception to this is when you end up with (perhaps after inlining) nested case expressions which match on the exact same scrutinee.
10:00:20 <thoughtpolice> erisco: If you're using cabal 1.24 there's a two-step way to do it: cabal haddock --for-hackage --haddock-option=--hyperlinked-source && cabal --http-transport=curl upload --doc dist/*-docs.tar.gz
10:00:24 <ph88> ertesx, Cale ok so my best choice is to do   specialCharactersHashSet = HS.fromList "\"#&'()*+,-./:;<=>[]_|"     and then go from there ?
10:00:37 <thoughtpolice> That will also generate the cool hyperlinked source, IF you're using ghc 8.0.1.
10:00:46 <erisco> oooh nice :D
10:00:47 <Cale> yep, if you bind it to a variable, it'll retain the HashSet for you
10:00:51 <ertesx> ph88: yeah
10:01:04 <erisco> but I spent all this time figuring out how to make a ustar
10:01:27 <ertesx> ph88: as long as that one has a name, everything is fine…  but at that point i would really just write:  satisfy (`HS.member` myCharSet)
10:02:19 <Cale> Also, I would normally stick to Data.Set unless there was a specific reason to go with HashSet.
10:02:49 <EvanR> IntSet
10:03:05 <ertesx> Cale: HashSet gives you IntSet, which is often double the speed, but with a Set-like interface
10:03:18 <erisco> thoughtpolice, that is so much better, thanks ♥
10:03:21 <ertesx> i'd go with HashSet most of the time, unless ordering has any importance
10:03:31 <erisco> I was struggling to make a script for this… not much of a cmd.exe programmer
10:03:37 <Cale> If you ignore the cost of hashing, sure.
10:04:00 <EvanR> id go with IntSet unless you have a specific reason not to use Int ;)
10:04:01 <Cale> I've seen performance go either way whenever I tried both.
10:04:10 <ertesx> Cale: hashing any of the machine-sized things is constant with the 'hashable' library…  because it doesn't actually hash at all =)
10:04:21 <ertesx> Cale: hash 'A' = 65 = ord 'A'  -- basically
10:04:26 <Cale> Yeah, for Char, I suppose it's fine.
10:04:30 <thoughtpolice> erisco: np
10:04:31 <ph88> is   `   a special character in a string that needs to be escaped ?
10:04:36 <Cale> For String, I would be more wary
10:04:49 <EvanR> hash = ord seems terribly wrong
10:05:00 <kadoban> ph88: I don't see why it would be
10:05:04 <ertesx> Cale: then for String there is bytestring-trie…  there is almost always a better structure than Set and Map
10:05:32 <Cale> bytestring-trie doesn't work on String does it?
10:05:39 <Cale> That sounds like it's for ByteString
10:05:44 <EvanR> it is
10:05:47 <geekosaur> ph88, no. unless you're doing something like ghc -e "..." in which case the shell would be seeing it
10:05:53 <EvanR> you have to encode whatever as a bytestring to use it
10:05:54 <ph88> kadoban, well i get this error:   lexical error in string/character literal at character '`'     for string     "!$%@?\^`{}~¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»���¿×÷�"
10:06:16 <glguy> ph88: The problem is the \^ part
10:06:19 <geekosaur> oh
10:06:19 <erisco> unfortunately the silly thing still isn't updating on hackage
10:06:20 <geekosaur> yes
10:06:26 <ertesx> Cale: it works with a UTF-8 encoding of the String
10:06:30 <glguy> > '\^A'
10:06:30 <ph88> ah i need to escape the backslash itself ?
10:06:32 <lambdabot>  '\SOH'
10:06:36 <erisco> the only option I have is to delete docs AND rebuild… which just rebuilds the incorrect docs
10:06:37 <geekosaur> \^x is a way to enter things like control-c
10:06:39 <geekosaur> and yes you need to escape backslash
10:06:49 <erisco> would be nice to have a delete-only option
10:06:58 <erisco> (or to have the doc upload work in the first place :P)
10:07:21 <ph88> glguy, do i also need to escape the backslash in single quote for a single character ?
10:07:28 <ph88> '\'  -->  '\\'
10:07:30 <geekosaur> yes
10:07:36 <ph88> hhmm strange ^^
10:07:41 <thoughtpolice> erisco: Like I said, it might be the CDN. I'd be able to purge it for you but I'm running out of my house right now and can't.
10:07:44 <hpc> ooh, TIL about that character literal syntax
10:07:47 <thoughtpolice> erisco: If it persists, ping me a little later.
10:07:48 <Welkin> > '\^C'
10:07:49 <geekosaur> see the example glguy just used ('\^A')
10:07:50 <lambdabot>  '\ETX'
10:07:54 * hackagebot language-lua 0.9.0 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.9.0 (EricMertens)
10:07:55 <erisco> what is a CDN?
10:07:59 <hpc> that seems like it would be handy in some terminal interaction situations
10:08:02 <hpc> content delivery network
10:08:03 <geekosaur> content delivery network
10:08:04 * erisco reveals his devops knowledge
10:08:07 <hpc> it's an internet thing
10:08:15 <Welkin> what is with that? Because ^ is a special character in that case?
10:08:17 <hpc> they host static crap for you
10:08:19 <ph88> thank you all
10:08:22 <ph88> back later
10:08:29 <erisco> so it doesn't mean Canadian, okay
10:08:39 <EvanR> CDN = overly complex "host static crap"
10:08:54 <geekosaur> Welkin, \ introduces an escape sequence. \^c is one form of escape, for entering control characters in arrow notation
10:09:00 <erisco> are you saying it may be a cache then?
10:09:12 <EvanR> N levels of caching
10:09:16 <geekosaur> or \xNNN to enter a codepoint in hex, etc.
10:09:22 <Welkin> a cdn is a static file host + cache
10:09:44 <systemfault> What a bad definition...
10:09:48 <Welkin> > '\^001'
10:09:50 <lambdabot>  <hint>:1:4:
10:09:50 <lambdabot>      lexical error in string/character literal at character '0'
10:10:15 <Welkin> > '\x001'
10:10:16 <lambdabot>  '\SOH'
10:10:21 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6 for the details of escape sequences
10:10:26 <erisco> well, I knew what Travis was, so I'm not completely out of the loop
10:11:04 <Welkin> that's good to know
10:11:22 <Welkin> I I think typed them in some weird way when I needed to use \SOH for my irc bot
10:12:06 <systemfault> A CDN is a network of caching static assets servers spread across the globe... The nice thing about them is that you push files to an origin server then those files are replicated to all the other servers. For the user, it ensures that they get the files from the server that is the closest to him/her. (faster)
10:13:16 <geekosaur> ...presuming it updates in a timely manner. and you get what you pay for in that regard (so, if you want a smarter CDN, go fund haskell.org)
10:14:01 <erisco> is hackage and haskell.org run by the same people?
10:14:28 <hpc> hackage.haskell.org, so yes :P
10:15:05 <Welkin> it's owned by lizard people
10:15:08 <Welkin> aka hpc
10:15:22 <erisco> well they could just have the subdomain pointed to completely different servers run by a completely different team… /me covers face
10:16:28 <magneticduck> yeah, subdomains are run by a seperate party in a lot of cases
10:16:37 <maerwald> meh, 'cabal haddock' is really broken: https://github.com/haskell/cabal/issues/1919
10:18:23 <erisco> so where is the indiegogo for haskell.org?
10:21:15 <erisco> it looks like they have corporate sponsors
10:21:26 <dcoutts> maerwald: feel like investigating and sending a PR? It's probably not that hard
10:21:53 <maerwald> dcoutts: you mean like the one that has been done almost a year ago? https://github.com/haskell/cabal/pull/2753
10:22:54 * hackagebot scrape-changes 0.1.0.2 - Scrape websites for changes  https://hackage.haskell.org/package/scrape-changes-0.1.0.2 (2chilled)
10:23:03 <dcoutts> maerwald: ah, so fixing that one to work properly would probably be even easier! :-)
10:23:04 <maerwald> it would probably already help if you could tell haddock to only run for _one_ target (as in: only the executable, not the library)
10:23:19 <dcoutts> that's also true
10:23:32 <dcoutts> and PRs in that direction would be welcome
10:23:55 <hvr> on that topic... I'm looking forward to `cabal new-haddock` =)
10:42:58 <rrradical> is there a zip function that will give you the excess elements instead of discarding them?
10:43:37 <lyxia> what would zip [] [1] be
10:43:51 <kadoban> rrradical: If you know in advance which one is bigger you can just pad the other (with an infinite stream usually)
10:44:27 <rrradical> kadoban: oh that's a good idea. that might work for me
10:46:18 <hpc> i wonder if there's a zipWithSpares :: [a] -> [b] -> ([(a, b)], Maybe (Either [a] [b]))
10:46:28 <hpc> or something along those lines
10:57:05 <Boomerang> @let zipWithSpare l = let crop x y = drop (length x) y in (,,) <$> zip l <*> crop l <*> (flip crop) l
10:57:07 <lambdabot>  Defined.
10:57:25 <Boomerang> > zipwithSpare [1..5] [4..6]
10:57:26 <lambdabot>      Not in scope: ‘zipwithSpare’
10:57:26 <lambdabot>      Perhaps you meant ‘zipWithSpare’ (line 157)
10:57:35 <Boomerang> > zipWithSpare [1..5] [4..6]
10:57:37 <lambdabot>  ([(1,4),(2,5),(3,6)],[],[4,5])
10:58:03 <Boomerang> :t zipWithSpare
10:58:04 <lambdabot> [a] -> [b] -> ([(a, b)], [b], [a])
10:58:14 <APic> Aaaahh. The good old Functionality!
11:02:55 * hackagebot shake 0.15.8 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.8 (NeilMitchell)
11:04:20 <Boomerang> @let zipWithSpare a b = (zip a b, drop (length b) a, drop (length a) b) -- cleaner version
11:04:21 <lambdabot>  .L.hs:157:1:
11:04:22 <lambdabot>      Equations for ‘zipWithSpare’ have different numbers of arguments
11:04:22 <lambdabot>        .L.hs:(157,1)-(159,49)
11:04:31 <VeiledSpectre> Heya guys - question:  I tried installing GHC via stack but it gave me 7.10.3 instead of 8.0.1 - is this because 7.10.3 is considered current / stable while 8.0.1 is just some sort of beta?  or did I mess up my stack install?
11:07:56 * hackagebot ascii-table 0.1.0.0 - ASCII table  https://hackage.haskell.org/package/ascii-table-0.1.0.0 (mitchellwrosen)
11:08:37 <rrradical> Boomerang: thanks, exactly what I want I think
11:08:58 <maerwald> @hoogle (Monad m1, Monad m2) => m1 (m2 a) -> (a -> m2 b) -> m1 (m2 b)
11:08:59 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:08:59 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:08:59 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:09:29 <geekosaur> VeiledSpectre, stack defaults to LTS and there is not yet an LTS for ghc 8.0.1. use nightly
11:17:15 <maerwald> @pl \x f -> fmap (>>= f) x
11:17:15 <lambdabot> flip (fmap . (=<<))
11:23:32 <heebo`> hello , slight tangent but what do people feel about apache spark and big data in general
11:25:31 <mfukar> I feel statisticians are definitely mad they didn't come up with "big data" all that time..
11:26:18 <EvanR> I feel 
11:26:23 <EvanR> like a natural
11:26:24 <EvanR> woman
11:27:04 <ehrlichja> apache spark has a great api
11:27:22 <ehrlichja> big data is very useful but still overhyped
11:27:31 <ehrlichja> and has tons of potential for evil misuse
11:27:40 <chrismwendt> @djinn f (a -> b) -> f a -> f b
11:27:40 <lambdabot> -- f cannot be realized.
11:27:50 <chrismwendt> @djinn Functor f => f (a -> b) -> f a -> f b
11:27:50 <lambdabot> Error: Class not found: Functor
11:28:08 <heebo`> isnt  that applicative?
11:28:15 <chrismwendt> Yes, it's `<*>`
11:28:40 <chrismwendt> I would like to write <*> in terms of fmap, pure, and pair : f a -> f b -> f (a x b)
11:29:04 <maerwald> @pl \t f -> (fmap join) $ forM t f
11:29:04 <lambdabot> (fmap join .) . forM
11:29:05 <freeman42-m> heebo` this is how they search on Google about apache spark https://www.google.ie/trends/explore#q=%2Fm%2F0ndhxqz
11:29:30 <ehrlichja> i am going to spark summit west next week
11:29:42 <EvanR> :exf Functor f => f (a -> b) -> f a -> f b
11:30:09 <exferenceBot> could not find expression
11:30:16 <heebo`> im at a spark talk now, i dont really like it as a technology... but.... i feel i should stay current
11:30:27 <EvanR> exferenceBot: you worthless bucket of bolts
11:30:47 <hexagoxel> EvanR: Applicative?
11:30:53 <EvanR> oh
11:31:06 <EvanR> :exf Applicative f => f (a -> b) -> f a -> f b
11:31:06 <exferenceBot> (<*>)
11:31:07 <ehrlichja> right now my job is mostly developing on spark
11:31:19 <maerwald> @pl \a1 a2 -> a1 >>= \x -> fmap join $ forM x a2
11:31:20 <lambdabot> (. ((fmap join .) . flip forM)) . (>>=)
11:31:22 <maerwald> man
11:31:28 <maerwald> wtf
11:31:59 <freeman42-m> ehrlichja the beautiful spark api has some functions which have an argument which is a string... and it only has 1 possible categorical value. Seems like it was coded by PhDs on weed
11:32:10 <maerwald> is there nothing that does: (Traversable t, Monad t, Monad m) => m (t a1) -> (a1 -> m (t a)) -> m (t a)
11:32:26 <maerwald> e.g. if you have two actions that are IO (Maybe a)
11:32:45 <ehrlichja> freeman42-m haha yes its not perfect but we are comparing it to the original hadoop mapreduce api
11:32:50 <EvanR> :exf (Traversable t, Monad t, Monad m) => m (t a1) -> (a1 -> m (t a)) -> m (t a)
11:33:02 <chrismwendt> maerwald: Maybe look into https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Compose.html
11:33:12 <freeman42-m> heebo` are you at the spark talk in Dublin by any chance?
11:33:14 <exferenceBot> could not find expression
11:34:27 <maerwald> I feel like this isn't a corner case. You have one action that is "IO (Maybe a)" and another that uses that 'a', as in "a -> IO (Maybe b)". without boring do-notation and case-experession you end up with: \a1 a2 -> a1 >>= \x -> fmap join $ forM x a2
11:34:33 <maerwald> which isn't really that intuitive
11:35:06 <glguy> maerwald: In that case you're working with a MaybeT and the >>= has the right behavior
11:35:27 <maerwald> I don't know what that means
11:35:38 <glguy> MaybeT IO a = IO (Maybe a)
11:35:44 <glguy> and the bind for that type does what you wanted
11:36:28 <maerwald> I don't work with MaybeT
11:37:01 <glguy> which is why you're having to jump through hoops to get that function
11:37:50 <maerwald> I'd rather do that than using monad transformers on the gtk+ bindings
11:37:55 <hexagoxel> :exf "(Monad m, Monad t, Traversable m, Traversable t) => m (t a1) -> (a1 -> m (t a)) -> m (t a)"
11:37:56 <exferenceBot> \ a f2 -> a >>= (\ f -> sequenceA (f >>= (sequenceA . f2)))
11:37:57 * hackagebot retry 0.7.4 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.4 (MichaelXavier)
11:37:57 <EvanR> is there a generic >>>>== operator that does any two monads
11:38:08 <carter> glguy: thanks for the clarification on gh :)
11:38:17 <mauke> EvanR: what, like IO into Identity?
11:38:22 <EvanR> heh
11:38:26 <carter> EvanR: mmorph package ?
11:39:51 <freeman42-m> "does any two monads" ( ͡° ͜ʖ ͡° )
11:40:17 <EvanR> i.e. "whatever maerwald is wanting right now"
11:40:25 <EvanR> as a special case
11:40:44 <EvanR> mmorph looks funky
11:40:51 <chrismwendt> :exf (Traversable t, Monad t, Monad m) => Compose m t a1 -> (a1 -> Compose m t a) -> Compose m t a
11:41:17 <exferenceBot> could not find expression
11:41:21 <hexagoxel> (i am not sure if Compose is in the exference environment)
11:41:34 <hexagoxel> :t \ a f2 -> a >>= (\ f -> traverse f2 f >>= (pure . join))
11:41:35 <lambdabot> (Monad m, Monad m1, Traversable m1) => m (m1 a) -> (a -> m (m1 a1)) -> m (m1 a1)
11:42:41 <hexagoxel> EvanR: bot aborts too soon; i can force local exference to run longer :)
11:43:15 <carter> I think maerwald could just copy and paste maybe t with a fresh name into his code
11:43:22 <carter> ;)
11:43:29 <carter> Sometimes that's the best approach
11:43:58 <carter> And just expose enough that someone can do a safe coerce to the aanaogus transformers code
11:46:27 <maerwald> I'd rather just define a new operator than introducing clumsy monad transformers
11:46:52 <EvanR> >>>>== ? ;)
11:47:34 <freeman42-m> the readability in that symbol is over 9000
11:47:59 <maerwald> any operator that has over 3 chars sucks
11:48:01 <tippenein> how could I get a random shuffling of something like this: [ card | card <- [Ambassador ..], _ <- [1..3] :: [Int] ]
11:48:53 <enthropy> does this repo for stack (16.04) http://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu work for other people? I seem to have enabled it but there's no stack package to install
11:49:05 <enthropy> @hackage monad-random
11:49:06 <lambdabot> http://hackage.haskell.org/package/monad-random
11:51:15 <enthropy> tippenein: http://hackage.haskell.org/package/random-shuffle is one package but I thought for a moment it was also in another package
11:51:51 <enthropy> which had other functions for dealing with random numbers you might like too
11:52:38 <enthropy> http://hackage.haskell.org/package/random-fu-0.2.6.2/docs/Data-Random-List.html#v:shuffle is the same code
11:53:59 <geekosaur> enthropy, works for me fwiw
11:54:07 <geekosaur> remember to sudo apt-get update
12:03:12 <enthropy> geekosaur: update prints "Ign:3 http://download.fpcomplete.com/ubuntu xenial InRelease" (which is supposed to be okay). But install says: "E: Unable to locate package stack"
12:04:06 <enthropy> geekosaur: the repo could be at fault instead of something in my system?
12:04:16 <geekosaur> possibly
12:04:40 <heebo`> freeman42-m: im at strataconf london
12:04:51 <geekosaur> there's a fair amount of magic going on with their server; I'd expect to be able to navigate that in a web browser but it looks like the paths are some kind of magic
12:05:18 <heebo`> enthropy: i installed stack from the repo
12:05:24 <geekosaur> I'm (effectively) on trusty and apt thinks the package is there
12:05:31 <heebo`> did you run apt-get update?
12:05:46 <geekosaur> [01 19:02] <enthropy> geekosaur: update prints "Ign:3 http://download.fpcomplete.com/ubuntu xenial InRelease" (which is supposed to be okay). But install says: "E: Unable to locate package stack"
12:11:16 <enthropy> heebo`: for xenial?
12:11:29 <enthropy> I did run apt-get update
12:12:58 * hackagebot libroman 2.0.2 - Roman Numerals for YOU  https://hackage.haskell.org/package/libroman-2.0.2 (ahakki)
12:14:01 <enthropy> maybe I'm mistakenly running i386
12:17:53 <enthropy> heebo`, geekosaur my problem was that this system is i686
12:17:58 * hackagebot network-transport 0.4.4.0 - Network abstraction layer  https://hackage.haskell.org/package/network-transport-0.4.4.0 (FacundoDominguez)
12:18:04 <geekosaur> whoops :p
12:22:47 <tippenein> Is there no such type signature? RandomGen g => [a] -> Rand g [a]
12:25:04 <tippenein> I don't even care if it's shuffle :: [a] -> IO [a]
12:27:59 * hackagebot distributed-static 0.3.5.0 - Compositional, type-safe, polymorphic static values and closures  https://hackage.haskell.org/package/distributed-static-0.3.5.0 (FacundoDominguez)
12:28:16 <tippenein> * why not use unsafePerformIO to grab the random seed? :\
12:28:37 <EvanR> probably not a good idea
12:29:01 <tippenein> haha, yeah. then the sig is [a] -> [a]  :O
12:29:16 <EvanR> shuffle = reverse
12:29:20 <EvanR> implementation chosen totally at random
12:29:56 <EvanR> tippenein: look for runRandom
12:30:28 <EvanR> theres also a shuffle package already on hackage 
12:30:52 <tippenein> https://www.haskell.org/hoogle/?hoogle=runRandom
12:33:18 <tippenein> shuffleM seems applicable
12:34:52 <EvanR> https://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
12:37:19 <tippenein> that's a little weird that I have to include the MonadRandom package to actually use one of the methods from random-shuffle
12:37:32 <tippenein> I got it to work with shuffleM tho
12:38:39 <lpaste> tippenein pasted “shuffle cards” at http://lpaste.net/165030
12:39:30 <EvanR> because it exports things you can do with monad random
12:39:41 <monochrom> <tippenein> Is there no such type signature? RandomGen g => [a] -> Rand g [a]
12:40:05 <monochrom> that's exactly shuffleM isn't it? set m = Rand g
12:41:38 <tippenein> you might be right. maybe it's just wrapping with evalRand :: RandomGen g => Rand g a -> g -> a
12:42:05 <tippenein> hoogle found nothing of the sort though
12:51:17 <zennist> Is there an 'inverse' of Profunctor? e.g., f a b, covariant in a, but contravariant in b
12:52:39 <shachaf> I don't think there's a standard class for it anywhere.
12:54:34 <mizu_no_oto_work> Would the 'inverse' of a profunctor be a coprofunctor?
12:55:03 <mizu_no_oto_work> or a contraprofunctor?
12:55:59 <shachaf> scshunt: Maybe you can comment.
12:56:20 <shachaf> I don't think "coprofunctor" makes sense, for the same reason "cofunctor" doesn't.
12:56:41 <monochrom> but perhaps "confunctor" is acceptable
12:57:29 <mizu_no_oto_work> ping edwardk
12:57:40 <edwardk> pong
12:57:50 <edwardk> cofunctor isn't a thing
12:57:53 <edwardk> cofunctor = functor
12:58:38 <mizu_no_oto_work> edwardk: is there a name for a profunctor with inverse variance?
12:58:54 <edwardk> given (a -> b) you get (f a -> f b)  flip the arrows (b -> a) gives (f b -> f a)  and alpha rename and you get functor all over
12:59:25 <edwardk> heh, well, depends on how anal retentive you want to get. most mathematicians would call that a 'profunctor' and what we call a 'profunctor' a 'distributor'
12:59:43 <edwardk> or a 'module' or some equally uninformative name
13:00:36 <edwardk> anyways usually a profunctor is defined relative to a pair of categories, rather than 'endoprofunctors on hask' like we use
13:00:56 <edwardk> so a profunctor with inverse variance would just be a profunctor on opposite categories
13:00:59 <edwardk> which is boring
13:01:31 <shachaf> Well, it's no more boring than it is in Haskell.
13:02:23 <mizu_no_oto_work> edwardk: would calling it a coprofunctor be sensible?
13:02:26 <zennist> yeah - properties wise it wouldn't be more interesting than Profunctor; but in terms of shape this allows it to use functions that apply to Contravariants
13:02:27 <edwardk> ive been meaning to get a full on 'hask'-like treatment for profunctors, but i've found i need to empower them with more information
13:02:44 <edwardk> mizu_no_oto_work: you could probably get away with it, because if you flip all the arrows they flip around right
13:03:22 <mizu_no_oto_work> zennist: seems you can call it a coprofunctor
13:03:25 <edwardk> zennist: well it has the wrong kind for you to direction use the functions from contravariant
13:03:57 <edwardk> much like rmap does the same thing as fmap if they are both defined by laws, but arent the same operation
13:05:04 <zennist> I see - is it commonly a wrong approach to identify the class type by the 'operations' it should perform?
13:06:25 <c_wraith> zennist, doing that has a tendency to result in classes that are collections of operations without a justification for putting them all together - or even that it's a useful abstraction 
13:06:55 <c_wraith> zennist, which is why approaching class design in terms of laws tends to be more useful 
13:08:30 <zennist> what if all the laws still apply..?
13:09:20 <zennist> e.g., in the case of Profunctor - although rmap and fmap might mean different things, but I assume many data types which implement Profunctor would still provide a Functor implementation?
13:09:24 <dfeuer> c_wraith, OTOH, it is sometimes nice to have "operator classes" that provide (usually one) operation each. Not pretty, but good for pattern synonyms sometimes.
13:09:52 <dfeuer> zennist, rmap and fmap must mean the same thing.
13:10:34 <c_wraith> dfeuer, sometimes those are helpful. but if there's an expected relationship between operators, it's nice to get them into the same class. 
13:10:42 <dfeuer> A bigger annoyance is that you could have something that's contravariant in the second to last argument but not covariant in the last, so it's not a Profunctor and there's no nice way to contramap over that second to last.
13:11:24 <metl> is there a way to do this with a one-liner using foldM or something? http://lpaste.net/5834823718563479552
13:11:56 <c_wraith> is it possible to make lawful lenses over contravariant fields? 
13:12:02 <monochrom> do you have a typo in the paste?
13:12:15 <metl> monochrom: me?
13:12:17 <zennist> the thing is that a lot of time your data type is 'opaque' to the extent that it's open to interpretation by its use - my mental model is such that when I see a data type that implements a class, I don't really see that as 'X is a ClassA', but rather 'X can behave like a ClassA'; that's why one type can implement many classes and yet there is no nasty `class` hierarchy/super class problems as in OO languages
13:12:22 <monochrom> are printList and printClientList the same thing?
13:12:37 <metl> monochrom: oops yeah i just made it generic, forgot to change that line
13:12:51 <metl> fixd
13:13:42 <Cale> metl: you could write zipWithM (\n a -> putStrLn $ show n ++ ": " ++ show a) [n..] xs
13:13:51 <monochrom> yeah
13:14:14 <Cale> Or I think I'd often have  forM (zip [n..] xs) $ \(n,a) -> putStrLn $ show n ++ ": " ++ show a
13:15:02 <c_wraith> that shadowing of n makes me twitch. it makes me wonder if it's a typo or not. 
13:15:22 <dfeuer> c_wraith, hrmmmm... I doubt that would be a *lens*, but there's got to be something.....
13:15:39 <dfeuer> Well, actually,
13:15:47 <c_wraith> dfeuer, indeed, I should have said optic 
13:15:49 <dfeuer> it's probably a Lens, but not a law-abiding one.
13:16:09 <dfeuer> Because s and t have conceptually different roles.
13:16:32 <dfeuer> (a -> f b) -> (q b -> f (q a))
13:17:01 <dfeuer> I'm pretty sure you could do that.
13:17:19 <Cale> c_wraith: Oh, good point... usually the first n wouldn't even be an n though ;)
13:17:52 <metl> Cale: ty i will study on this :)
13:18:11 <glguy> :t argument
13:18:13 <lambdabot> (Settable f, Profunctor p) => (a -> f b) -> p b r -> f (p a r)
13:18:23 <glguy> argument 07:: Profunctor p 07=> Setter (p b r) (p a r) a b
13:18:29 <c_wraith> Oh, thanks glguy
13:18:39 <glguy> might be relevant
13:18:48 <maerwald> Now that my gtk+ code is growing, I end up having the exact same problems I have with gtk+ in C. Complicated side effects on widgets updates and interactions. Why am I even using haskell for that?
13:18:51 <c_wraith> I guess it does have to be a Setter
13:19:08 <c_wraith> it's not like you can read from a contravariant field. 
13:21:41 <c_wraith> ... I know, that statement makes no sense. fields aren't contravariant. 
13:26:44 <ph88> hi guys   instead of    do  foo <- bar   return Constructor1 foo    what can i use as direct notation without do-block ?
13:26:58 <glguy> Constructor1 <$> bar
13:27:00 <fishythefish> Constructor1 <$> bar
13:27:17 <ph88> thx
13:31:23 <ph88> this  digit parser from attoparsec is giving me back a Char and my constructor takes an Int  how can i convert it from Char to Int ? i think i can use read .. but i'm not sure where to put read       digitV = MkDigit <$> digit
13:31:45 <glguy> :t digitToInt
13:31:46 <lambdabot> Char -> Int
13:32:57 <ph88> like this ?    digitV = MkDigit digitToInt <$> digit
13:34:00 <ph88> hhmm no
13:34:23 <mauke> MkDigit . digitToInt <$> digit
13:34:27 <mauke> might need parens around the .
13:36:28 <glguy> MkDigit (.) digitToInt <$> digit? -- :-p
13:45:16 <Hafydd> maukeDigit
13:45:44 <c_wraith> nah, (.) is infixr 9
13:45:57 <glguy> You can remember that <$> is 4 because it collides with ==
13:46:23 <c_wraith> it's helpful to remember that nothing infixr binds more tightly than (.) 
13:46:27 <monochrom> I don't even remember that == is 4
13:46:34 <deni> hey guys, any help regarding my snap issue with dynamic reloading is appreciated: https://www.reddit.com/r/haskell/comments/4m3fji/snap_default_scaffolding_not_working_with_dynamic/
13:46:34 <c_wraith> err, nothing infix 
13:46:48 <glguy> monochrom: Oh, then maybe remember that it's 4 because it collides with <$>
13:47:06 <monochrom> haha
13:47:28 <fishythefish> The second suggestion might be viable
13:47:33 <fishythefish> especially if $ is above 4 on your keyboard
13:47:51 <c_wraith> but $ is infixr 0
13:47:59 <fishythefish> c_wraith: get a different keyboard
13:48:25 <c_wraith> I don't think that'll change the definition of ($) 
13:50:01 <fishythefish> I'm half joking, but in any case, I find the precedence of $ easier to remember than <$>
13:50:22 <c_wraith> Oh, I'm fully joking. :) 
13:50:47 <fishythefish> Oh, uh, me too.
13:50:54 <Hafydd> I'm 3/2 joking.
13:51:20 <c_wraith> pushing it right past the limit. :) 
13:57:04 <ph88> seems good mauke thank you
14:13:03 * hackagebot cacophony 0.7.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.7.0 (jgalt)
14:22:47 <Wizziee> Hi, I have a list of length from 1 to 3 and I need to perform a map which depends on it's position. How would you do that? I have two ideas. First: `mapAccum` with position as accumulator. Second: map this list to list of tuples (position, element) and then perform map on it.
14:24:50 <Wizziee> by position i mean index ofc
14:24:51 <muesli4> Wizziee: zipWith (\i x -> ) [1..] xs
14:25:06 <ij> Is there an identity/replacement lens?
14:25:15 <Wizziee> what doas [1..] do?
14:25:20 <Wizziee> oh
14:25:23 <Wizziee> i get it
14:25:30 <Wizziee> just an infinite list
14:25:33 <muesli4> Wizziee: You could also do it with a pattern if the length stays below.
14:26:33 <glguy> ij: like "id"?
14:27:47 <glguy> > [view id "test", set id "replace" "test"]
14:27:48 <lambdabot>  ["test","replace"]
14:28:03 * hackagebot weigh 0.0.2 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.2 (ChrisDone)
14:29:30 <ij> That works!?
14:30:47 <ph88> hey guys, can anyone take a look at this code ?  http://pastebin.com/4bND62Tm   i think that do-block is working in the Maybe-monad and i expect a Parser-monad .. not sure why it's going wrong
14:30:47 <glguy> id is the identity element for (.), and (.) is how you put lenses together
14:31:42 <glguy> ph88: Use lpaste.net , pastebin.com has ads and doesn't highlight correctly
14:31:56 <ph88> lpaste is down for maintenance it says here
14:32:31 <benzrf> ij: indeed
14:32:47 <glguy> ph88: try refreshing
14:33:25 <glguy> or even using fpaste.org or something, lpaste does seem to be under some kind of bad load
14:33:49 <ph88> cuz i was refreshing it all the time :P
14:35:15 <ph88> glguy, https://paste.fedoraproject.org/373550/48168781/
14:36:29 <glguy> ha, looks like they use the same broken highlighter
14:37:31 <glguy> You can't do this: option Nothing (Just underline)
14:38:09 <glguy> maybe you meant: option Nothing (Just <$> underline)
14:39:07 <ph88> wow nice
14:39:13 <ph88> that sure cleared up some errors :P
14:40:33 <ArtfulDodger> o/
14:41:03 <ph88> \o
14:42:35 <ArtfulDodger> Do you even (Monad m, MonadTrans t) => m a -> t m a ?
14:47:10 <ArtfulDodger> Is there anyone here who /loves/ Haskell?
14:48:10 <ph88> mee meeeee !
14:48:30 <ArtfulDodger> ph88: Oh? :)
14:48:34 <ph88> :D
14:48:37 <ArtfulDodger> ph88: Why is that?
14:48:45 <ph88> good challange lol
14:48:54 <Cale> ArtfulDodger: Probably most of us? There are things which are less than ideal about Haskell, but it's so much nicer than almost everything else which you can do practical work with, for so many reasons.
14:49:25 <ArtfulDodger> I tried to write a Hello World once and it made my brain hurt :)
14:49:55 <Cale> main = putStrLn "Hello, world!"
14:50:26 <Cale> Well, it is very *different* from most programming languages that are popular, so it's not something you can expect to pick up in a week.
14:50:54 <Cale> I think for me, it was about 2 months before I really started to feel confident that I could do useful things with it, and then about a year to be totally comfortable.
14:51:17 <Cale> (and I knew 15 or so programming languages at the time)
14:51:57 <Cale> But yeah, the differences aren't just for the sake of being different -- they're actually helpful once you're used to them.
14:52:55 <d-rock> I wish I had started with Haskell. I'm coming into it from scala/scalaz and I have a certain mental inertia that makes reading signatures a bit difficult
14:53:13 <koz_> d-rock: It's just a matter of practice.
14:53:22 <d-rock> That, and the lack of punctuation compared to all of the C-like languages I've written in
14:53:25 <koz_> Getting into the habit of reading signatures can get you surprisingly far.
14:53:31 <sbrg> d-rock: I write Scala for work as of recenty and I find scala much harder to read 
14:53:36 <sbrg> but I guess it's a matter of what you're used to
14:53:37 <Cale> Haskell code ends up being more reusable, easier to refactor, more reliable than almost anything else with as much library coverage.
14:53:40 <d-rock> Oh yeah, I'm much better at it now
14:53:42 <sbrg> s:scala:scala signatures:
14:53:46 <sbrg> but also scala ingeneral.
14:54:06 <d-rock> Scala had to make a lot of compromises to maintain Java compatibility
14:54:13 <sbrg> aye
14:54:16 <maerwald> Cale: unless you use C binding libraries, in which case you end up with the same mess
14:54:18 <d-rock> At the time we all thought this was a worthwhile tradeofff
14:54:27 <maerwald> just that the mess is written in haskell now :o
14:54:39 <sbrg> maerwald: true. but for many C libraries there are higher level API wrappers
14:54:43 <Cale> maerwald: hah, well, maybe... even then, there's more potential to abstract over the pain
14:55:08 <maerwald> sbrg: except for desktop GUIs
14:55:13 <sbrg> using gtk via haskell makes me wonder if seppuku wouldn't be more enjoyable
14:55:15 <sbrg> ... yes ^
14:55:26 <maerwald> seppuku is nice, yeah, lol
14:55:27 <d-rock> Oh my, that sounds like a sentence, not a project
14:56:05 <ph88> well my parser works well .. just that now i have the concrete parse tree .. but i don't want all these tiny nodes in the tree so i want an abstract parse tree  .. how do i go about that ?   https://paste.fedoraproject.org/373561/46481809/
14:56:35 <ArtfulDodger> Cale: Sounds pretty interesting
14:56:35 <Cale> ArtfulDodger: The company I work for builds web applications for various clients pretty much entirely in Haskell. We use Snap and Groundhog on the backend (connecting to a postgresql database, and serving up data over websockets mostly, sometimes XHR), and on the frontend we're using reflex-dom compiled via GHCJS to Javascript.
14:56:42 <d-rock> Is there not a better UI toolkit than GTK+ around? Admittedly it's been a very long time since I've done any UI work (think AWT...)
14:57:13 <sbrg> d-rock: well, there's not much work being done, it seems. everything is moving toward web, really
14:57:31 <d-rock> True. Chrome is the new Wyse ;)
14:57:37 <sbrg> e.g. ghcjs, threepenny-gui, all the other haskell-ish web languages or haskell-to-JS transpilers, etc
14:57:42 <ph88> Cale, why you use snap over yesod ?
14:57:51 <Cale> ph88: Even snap is overkill really
14:58:05 <Cale> ph88: We're serving up one page which does complicated communication with the backend.
14:58:12 <sbrg> heh
14:58:25 <ph88> Cale, can you put an example source code online ?
14:58:50 <ArtfulDodger> Cale: What sort of time investment difference is there?
14:58:55 <Cale> Not really... our backend stuff is still closed source.
14:59:11 <ArtfulDodger> Cale: Surely it takes longer to code something in Haskell than it would in C or similar?
14:59:15 <sbrg> ArtfulDodger: I spend *much* more time thinking about my code when writing Haskell than writing it. 
14:59:20 <Cale> ArtfulDodger: No, much much less time
14:59:29 <ph88> ArtfulDodger, for sure C is slooooooooooooow to develop things in
14:59:52 <sbrg> ArtfulDodger: You can do things in Haskell with one line that would probably require hundreds of lines of code in C
15:00:05 <Cale> ArtfulDodger: I've done things in 600 lines of Haskell code which would be like 50000 lines of C.
15:00:05 <sbrg> and if you use features like laziness and such, even more
15:00:15 <ph88> Cale, what thing ?
15:00:49 <Cale> ph88: I wrote a somewhat-brute-force-ish pipeline scheduler for PPC + Altivec at one point
15:00:58 <ArtfulDodger> Cale: That sounds like fun
15:01:04 <sbrg> ArtfulDodger: I recently wrote a compiler in C. A big chunk of the code is just writing constructors for the nodes in the AST. You don't have to do that in Haskell. Defining the datatype means creating the constructors.
15:01:08 <maerwald> ph88: which is why there is C++ where development is faster, but you never really want to _maintain_ it :P
15:01:58 <ph88> maerwald, i decided C++ is not for me
15:02:00 <Cale> which basically used the list monad a bunch, and tried to find schedules for code which minimised the number of cycles it would take to run (keeping in mind that the CPU architecture could have multiple instructions executing on different units)
15:02:14 <sbrg> ArtfulDodger: And we haven't even mentioned all the time you save on debugging.
15:02:27 <Cale> and then that also had a register allocator, which is pretty straightforward, but hey
15:02:37 <Cale> It was really about 1200 lines, but half of that was commentary.
15:02:39 <maerwald> sbrg: debugging is not really a joy in haskell though, when it happens ;)
15:02:47 <ph88> nice Cale 
15:03:39 <ph88> anyone wanna take a look at my parser question ?
15:03:42 <ArtfulDodger> Haskell sounds pretty nice actually
15:03:48 <ArtfulDodger> I think I'll go read up some :)
15:03:51 <ph88> :)
15:04:01 <sbrg> one of us .. 
15:04:03 <sbrg> one of us!
15:04:06 <ArtfulDodger> Haha
15:04:09 <koz_> Lol.
15:05:26 <sbrg> maerwald: I disagree. *So* many common mistakes are eliminated by the type system. this means you don't need to think about whole classes of errors when you're wondering where the bug is
15:05:31 <Cale> We had some vectorised code for computing sine/cosine pairs which was something like 36 instructions long, and my scheduler got the loop down to about 17 clock cycles, each iteration would compute 8 floats (4 sines and 4 cosines). I think the real world performance was something like 2.5 clocks/float (loads and stores slow it down a bit)
15:05:44 <maerwald> sbrg: I was talking about when you have to debug, not about how nice the type system is.
15:05:50 <maerwald> which cannot safe you from many bugs
15:06:00 <Cale> By extremely unfair contrast, GNU libm's cosine function costs about 200 clock cycles
15:06:27 <sbrg> maerwald: I am well aware. and when I am debugging, and the type system has eliminated most of the bugs I can write in other languages, I don't need to waste mental energy on those types of bugs. I know they aren't possible and I can narrow the possible causes faster.
15:06:46 <Cale> (The exact numbers here might be off by a few, this was stuff I did back in 2004)
15:06:58 <maerwald> sbrg: you mean like having a proper call stack which you don't in haskell? :P
15:07:51 <Cale> maerwald: On the one hand you don't have a call stack, but on the other hand, you don't have a call stack.
15:07:58 <maerwald> haha
15:08:42 <sbrg> maerwald: Sure, there are tradeoffs. It doesn't change the fact that I spend orders of magnitude less time on fixing bugs in Haskell code than in many other languages.
15:09:08 <sbrg> but obv. you can't save yourself from semantic bugs with the type system
15:09:14 <sbrg> s:from:from all:
15:09:16 <maerwald> sbrg: yes, you debug LESS, but when you really hit something non-trivial, debuggins is more annoying than anywhere else IMO. And I've done lots of debugging in C.
15:10:38 <Cale> Well, is it though?
15:10:54 <maerwald> imo.
15:11:11 <ArtfulDodger> maerwald: did you ever do enough debugging in C to find bugs in the windows api, by identifying falts in the assembly routines? :P
15:11:12 <sbrg> maerwald: I see where you're coming from, but I would rather saw off my own arm and then beat myself to death wielding the sawed-off arm in the other arm than debug C code
15:11:27 <maerwald> ArtfulDodger: I simply don't program for windows, haha.
15:11:40 <Cale> I don't even know if *that's* true, or if it just seems more annoying because you suddenly go from "hey, everything is working all the time and I don't even have to debug it" to something highly nontrivial that the type system couldn't catch.
15:11:59 <ArtfulDodger> maerwald: I ran into a lot of walls when I was programming under Windows, the API is shit and I'd frequently find my code being perfect in a vacuum, only to find the API itself was crapping itself
15:12:25 <maerwald> Cale: once had a bug in a not-so-easy computational geometry algorithm. Debugging through the recursions was hell.
15:12:52 <maerwald> and it was a logical bug
15:12:54 <Cale> It's certainly nicer than working with an imperative language when the semantic bugs are in pure functions, because you know that if you see a result in isolation, that will be the result in the real program.
15:13:05 * hackagebot cereal-text 0.1.0.2 - Data.Text instances for the cereal serialization library  https://hackage.haskell.org/package/cereal-text-0.1.0.2 (ulikoehler)
15:13:20 <maerwald> and the type system doesn't tell you whether your algorithm is correct :o
15:13:22 <ArtfulDodger> Ok can someone tell me if this guy was totally crazy? I had this guy I was considering moving in with (the rent couldn't be beaten) and we got to talking about programming.
15:13:41 <ArtfulDodger> He starts going on and on and on about Haskell, fractal compression, and how he's going to solve some decades-old mathematical problem
15:13:43 <sbrg> The hardest applications to debug in Haskell are applications that depend on a lot of external state that you can't easily replicate in the repl, such as a web server or some such. 
15:14:20 <ArtfulDodger> Actually the more that I write this out, yeah, he was just nuts.
15:14:26 <ArtfulDodger> I'll spare you all the details.
15:14:37 <Cale> maerwald: Sure, there can still be tricky bugs in complicated algorithms, but I'd much rather run into that in a pure functional language where I can reason equationally about things, than run into it in a setting where everything is mutable everywhere.
15:14:40 <sbrg> because the debugger is useless so you can't inspect the program while it's running, so you have to resort to logging or mock the whole thing and test it locally or something
15:15:07 <maerwald> Cale: basically had to rewrite parts of the algorithm just so I can debug it and have intermediate results...
15:15:14 <sbrg> exactly
15:15:18 <Cale> ArtfulDodger: He might've been crazy, but from what you wrote thus far, it's not clear :)
15:16:04 <jle`> how are ~ constraints implemented in GHC?
15:16:09 <jle`> is there any dictionary passing involved?
15:16:26 <maerwald> I think imperative, typesafe and memorysafe programs are inherently easier to debug than haskell. Although you might have to debug more.
15:16:29 <Cale> maerwald: Yep, usually that's what I tend to do when something has a bug in it -- break it into smaller parts until each of the parts is clear, and usually in the process either the bug goes away, or it becomes obvious that it's located in a smaller piece of the code.
15:16:34 <thoughtpolice> Cale: It'd be interesting to chat about this sometime. I've vaguely been wanting something like that for my own code; I want to write hand-rolled loops for core algorithms like ChaCha20 and see if I can force out better instruction schedules to improve IPC.
15:17:10 <c_wraith> jle`, I don't believe so. There's no runtime functionality associated with type equality constraints. 
15:17:25 <jle`> so if i unsafeCoerce a Dict, nothing would go wrong?
15:17:28 <jle`> ...fsvo nothing
15:17:42 <maerwald> Cale: which you also have to do for performance debugging, because of the semi-random "callstack"
15:17:46 <Cale> thoughtpolice: It was very specialised to PPC, and did leverage the fact that it was a good deal more predictable than Intel machines tend to be, though I'm sure you could attempt the same thing for other architectures.
15:18:13 <c_wraith> jle`, well, things would go wrong if you had any other constraints relying on those type variables 
15:19:50 <jle`> thanks
15:20:04 <thoughtpolice> Cale: Well, maybe I should start with my PPC machine I'm ssh'd into over here. :)
15:20:07 <Cale> thoughtpolice: Basically, it did the trick where you're operating on several elements of an array simultaneously, so that all the instructions will commute with one another, and then it did a simulation of the cores available in the processor, just trying to fill up each cycle as much as possible, in a greedy-first fashion with backtracking, and we'd give it a specific number of instructions to try to fit the thing in (there are obviou
15:20:07 <Cale> sly other approaches one could take)
15:20:31 <thoughtpolice> Cale: They're truly pretty awesome for some workloads from some of the basic testing I've done.
15:21:52 <Cale> When I was leaving the project, we were kind of hyped about the cell... it's too bad that never took off, but having direct control of the cache would be pretty nice for this kind of thing where you want to predict performance, and don't mind running your compiler overnight to try to brute force out slightly better code.
15:22:34 <thoughtpolice> Cale: Yeah, that's basically something along the lines of what I was thinking about. Most 'core loops' can fit into a model like that (ChaCha20 is no different I think) and are relatively limited in size, so it seems like it could pay off for specific domains.
15:23:22 <thoughtpolice> Even if you can only generate fast schedules for the core loop bodies (and not necessarily the slow paths for irregularly sized inputs, etc) that's still quite a good spot to do the improvements.
15:23:31 <Cale> yeah
15:23:33 <thoughtpolice> Intel has their own tool for doing this for Sandy Bridge+ machines.
15:28:15 <thoughtpolice> Cale: https://software.intel.com/en-us/articles/intel-architecture-code-analyzer in case you're interested. It's interesting since it builds the model of the loop body and the AST directly from the object code, using some compiler directives. So you can augment the loop body in an existing C program and see if the compiler output can be improved.
15:28:27 <Cale> cool
15:31:04 <Cale> Yeah, our thing basically worked on slightly abstracted assembly (just prior to register allocation). I was pretty much just building a lazy list of all the possible schedules which fit inside of n clock cycles for some n, and it was usually pretty easy just to explore by hand to find the boundary where it goes from being easy to find a schedule to taking a few minutes before finding the first one, and then we stepped it down by anothe
15:31:04 <Cale> r cycle and let it run over the weekend and it got one :)
15:32:19 <Wizziee> how to check if Int is between 2 and 5?
15:32:34 <Cale> 2 <= n && n <= 5 ?
15:32:40 <Wizziee> I mean a simple function, not this ^ :P
15:32:50 <Wizziee> like range(2,5)
15:32:57 <monochrom> 2 <= n && n < 5
15:33:01 <Cale> There actually is inRange
15:33:06 <Cale> But that's kind of abusive...
15:33:21 <Cale> > filter (inRange (2,5)) [1..10]
15:33:23 <lambdabot>  [2,3,4,5]
15:33:32 <monochrom> @type inRange
15:33:33 <lambdabot> Ix a => (a, a) -> a -> Bool
15:33:41 <Cale> inRange is part of the Ix machinery, rather than Ord
15:34:04 <Cale> So it'll work for Int, but for other types, it might not be checking the inequalities you really wanted
15:34:24 <monochrom> > inRange (LT, GT) EQ
15:34:25 <lambdabot>  True
15:34:50 <Cale> > inRange (1,1) (100,100) (50,200)
15:34:51 <lambdabot>      Couldn't match expected type ‘(Integer, Integer) -> t’
15:34:51 <lambdabot>                  with actual type ‘Bool’
15:34:51 <lambdabot>      The function ‘inRange’ is applied to three arguments,
15:35:03 <Cale> > inRange ((1,1), (100,100)) (50,200)
15:35:05 <lambdabot>  False
15:35:22 <Cale> > (1,1) <= (50,200) && (50,200) <= (100,100)
15:35:24 <lambdabot>  True
15:35:39 <Cale> ^^ so be careful :)
15:36:27 <Cale> You could of course write a function to do that yourself :)
15:37:27 <Wizziee> oh, So i guess i'm good without a function ;)
15:53:06 * hackagebot hw-json 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.1.0.0 (haskellworks)
16:41:02 <MichaelBurge> @type do { return 5; }
16:41:03 <lambdabot> (Monad m, Num a) => m a
16:41:31 <MichaelBurge> ^ Shouldn't that be "Applicative m" with the new ApplicativeDo extension?
16:42:28 <RyanGlScott> lambdabot probably isn't using it.
16:42:36 <kadoban> Is lambdabot even using GHC8 yet? And the extension? Seems like not.
16:42:48 <glguy> Even with the extension it gets a Monad constraint
16:42:56 <MichaelBurge> I tried it in ghci with GHC 8 though
16:42:58 <kadoban> Hmm, really?
16:43:23 <kadoban> That seems odd.
16:44:33 <glguy> This did not get a Monad constraint, though: \m -> do {x <- m; return 5}
16:44:45 <RyanGlScott> What's the reasoning behind that?
16:45:20 <MichaelBurge> glguy: Yeah, that one works fine
16:45:37 <kadoban> Must just be a bug or something?
16:45:43 <MichaelBurge> I'll make a bug report
16:46:49 <kadoban> Out of curiosity, does it have a way to tell it to show you what Applicative code it desugared to?
16:47:42 <glguy> Prelude> :t \m -> do m; return 5
16:47:44 <glguy> \m -> do m; return 5 :: (Num b, Monad m) => m a -> m b
16:49:31 <lambdayak> is there a similar thing to OverloadedStrings, but for chars / word8s?
16:49:38 <RyanGlScott> Hm, I read the users' guide section on -XApplicativeDo, and it has this to say:
16:49:59 <RyanGlScott> The expression needs to be of the form
16:50:00 <RyanGlScott> do p1 <- E1; ...; pn <- En; return E
16:50:23 <RyanGlScott> (That last one can also be 'pure E')
16:50:32 <Koterpillar> RyanGlScott: and N > 0?
16:51:12 <RyanGlScott> Koterpillar: Curiously, it makes no mention of that.
16:51:28 <RyanGlScott> It does say that it must be exactly 'pure E' or 'return E' and not, say 'return $ E'.
16:51:41 <kadoban> Err, really?
16:51:55 <RyanGlScott> If you don't believe me: http://git.haskell.org/ghc.git/blob/0676e68cf5fe8696f1f760fef0f35dba14db1104:/docs/users_guide/glasgow_exts.rst#l877
16:52:10 <kadoban> I believe you, that just sounds oddly restrictive.
16:52:27 <kadoban> Must be a pain in the butt to implement otherwise maybe?
16:53:04 <Koterpillar> it also tells you how to see the desugared form
16:54:33 <kadoban> That's neat. Sounds like it's probably a messy result usually though, if I read that right.
16:54:53 <RyanGlScott> True, you can use -ddump-ds, but that's a bit of an extreme option
16:55:05 <thoughtpolice> RyanGlScott: So, `\m -> do { x <- m; return $ x; }` and `\m -> do { x <- m; return x; }` yield different types, yes.
16:55:20 <thoughtpolice> Although interestingly, `\m -> do { x <- m; return (id x); }` yields a type generalized to Functor.
16:55:49 <RyanGlScott> That doesn't bother me as much as the inconsistency with things like do { return "wat" } and \f -> do { f; return "wat" }
16:56:01 <thoughtpolice> Yes, I'd agree.
17:08:09 * hackagebot opaleye-trans 0.3.3 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.3.3 (wraithm)
17:20:11 <jle`> anyone have a good example of a library that has good tests?
17:22:52 <dmj`> jle`: https://github.com/dmjio/stripe/tree/master/stripe-tests/tests/Web/Stripe/Test
17:23:38 <jle`> thanks! :o
17:25:21 <dmj`> jle`: mostly just integration tests (IO-based), not unit tests (pure), will add hspecs auto discover thing eventually. Don't have quickcheck serialization isomorphism tests since stripe just receives jsons, doesn't send it
17:26:43 <jle`> thanks :)
17:27:31 <maerwald> IO tests :( I'd rather look for nice doctests as an example
17:27:57 <dmj`> there's a free monad in there somewhere
17:28:12 <maerwald> here are some doctests: https://git.io/vrxTT
17:28:53 <Alxandr> Hi. I'm confused about a piece of code and was wondering if I could get help understanding it. The code in question is the following { errorExpected = maybe E.empty E.singleton el } (including the curly brackets)
17:28:58 <dmj`> maerwald: yes, doctests would be ideal. But everything in this lib does IO
17:29:16 <maerwald> then I wouldn't cnsider it a nice example :P IO testing sucks
17:29:22 <maerwald> unless you have a way to sandbox properly
17:29:34 <dmj`> We'd have to mock stripe's webserver and run it, then submit the request just to test the docs
17:29:59 <Alxandr> What does this `{ name = value}` syntax mean?
17:30:03 <maerwald> well, some things you can't mock, I really want an IO sandbox
17:30:19 <Alxandr> Does it make a function that changes a single field in a record?
17:30:31 <maerwald> e.g. the tests fail if anything tries to break out of the sandbox too
17:30:53 <scshunt> Alxandr: rec { name = value } is an updated record
17:31:16 <scshunt> it creates a new value from rec by updating the field
17:31:25 <Alxandr> Right
17:32:00 <Alxandr> So it's like { rec with name = value } in F# I guess (not that anyone here necessarily knows F# :P)
17:34:19 <maerwald> @hackage test-sandbox
17:34:19 <lambdabot> http://hackage.haskell.org/package/test-sandbox
17:34:54 <maerwald> dmj`: ^ maybe that can be used
17:38:47 <dmj`> maerwald: that's pretty cool
17:40:03 <dmj`> maerwald: very cool it starts / stops the process
17:40:55 <maerwald> yeah, but I'm rather looking for something that's really a filesystem sandbox where I can say "only files in this directory must be touched by the process, otherwise make the test fail"
17:42:09 <Alxandr> The following code then: Label <$> NE.nonEmpty l - Label is a constructor, NE is List.NonEmpty and l is a string. (NE.nonEmpty l) has type [string] -> NonEmpty string as far as I can understand, but I don't understand what happens when you do Label <$> to it.
17:44:49 <rhovland> Why aren't things like Set typeclasses? seems like you could just have a few things the instance would require (union, intersection, etc?) and then the current Set and IntSet (and heck,maybe Map) would be instances of Set?
17:46:26 <RyanGlScott> rhovland: You may be interested in http://hackage.haskell.org/package/sets-0.0.5/docs/Data-Set-Class.html
17:51:32 <Koterpillar> ?type (<$>)
17:51:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:51:39 <Koterpillar> Alxandr: ^^
17:52:11 <Alxandr> Yeah. I already know that. But it doesn't quite help me as I'm not sure what f is in this instance.
17:52:47 <Koterpillar> what's l again?
17:52:49 <Alxandr> It's either a list, a NonEmpty list or an option
17:52:51 <Alxandr> l is a string
17:53:05 <Alxandr> And the result of the expression is an option
17:54:03 <Alxandr> *maybe in haskell (sorry)
17:54:24 <Koterpillar> and Label?
17:54:30 <Alxandr> It's a constructor
17:55:04 <Alxandr> It takes a NonEmpty list and returns a ErrorItem
17:55:37 <pavonia> Label <$> list applies Label to all elements of the list
17:56:02 <Alxandr> The code in question is from here: https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Prim.hs#L680
18:18:11 * hackagebot cron 0.4.1.1 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.4.1.1 (MichaelXavier)
18:29:56 <newcomer> so I have few questions about ghci. The way I understand it is that when one type expressions in ghci it's dealt with as if it's in an implicit do block. right?
18:30:29 <newcomer> with "return exp" evaluated instead of just "exp".
18:30:40 <newcomer> where "exp" is the typed expression.
18:30:51 <dmj`> newcomer: yes, you're inside the IO monad
18:31:13 <shachaf> newcomer: Not exactly, but close to that.
18:31:14 <Koterpillar> newcomer: but if your expression is of type IO, it'll be do { result <- exp; return result }
18:31:31 <shachaf> do { result <- exp; return result } = exp
18:31:52 <Koterpillar> ok, then either do { print exp } or do { result <- exp; print result }
18:33:07 <newcomer> Koterpillar, if the expression is an IO () why not just do the act?
18:33:30 <Koterpillar> it does
18:33:51 <Koterpillar> that's the "result <- exp" part there
18:33:54 <newcomer> Koterpillar, OK, I get. you meant if it's IO String for example.
18:34:06 <newcomer> Koterpillar, like typing "getLine".
18:34:17 <Koterpillar> yes; I think if the type is IO () it doesn't print the ()
18:34:56 <Cale> If your expression x isn't an IO action, it executes print x. If x is an IO action, it executes x >>= print
18:35:09 <Cale> Oh, right, and there's a special case for IO ()
18:35:10 <newcomer> so "getLine" in ghci is do {result <- getLine; return result}. right?
18:35:33 <Cale> do {result <- getLine; return result} is the same thing as getLine in all cases
18:35:54 <Cale> (this is one of the monad laws)
18:36:48 <Cale> If you input getLine, it executes getLine >>= print
18:37:33 <Cale> You'll notice that those both have the exact same effect, since it doesn't bother binding to print in the case when the action has type IO ()
18:37:47 <Cale> (It assumes you don't care to see the empty tuple result)
18:38:08 <Koterpillar> for completeness, if you input something of type IO a where a doesn't Show, it'll execute it and then tell you it's not Show
18:38:12 <newcomer> Cale, OK, got it.
18:39:21 <newcomer> Koterpillar, Cale: I think you covered all the cases.
18:40:25 <Cale> I kind of preferred the old default of not also printing the results of IO actions
18:40:45 <Cale> It was a little easier to explain anyway :P
18:41:53 <newcomer> 1) exp is not IO a, print exp 1) exp is IO a where a is instance of Show, exp >>= print. 3) exp is IO a where a is not instance of Show, exp >>= ShowSomeMessage. 4) exp is IO (), exp >>= DoNothing
18:42:25 <Cale> Case 4 can just be exp
18:42:56 <newcomer> Cale, OK.
18:43:10 <newcomer> Now a question about main and lazy evaluation.
18:43:23 <newcomer> it's related to ghci too.
18:44:45 <newcomer> The way I understand it is no expressions are evaluated and no action are done except if they are subexpressions of main :: IO (). right?
18:45:09 <Cale> actually, it doesn't print a message for me when there's no instance of Show, it just executes
18:45:15 <Koterpillar> correct [TH aside]
18:45:29 <Cale> Well, not necessarily directly subexpressions
18:45:51 <Koterpillar> nothing that's _not referenced_ in main will be evaluated
18:45:54 <Cale> But, like, transitively subexpressions of definitions of things reachable from main
18:46:11 <newcomer> Cale, OK.
18:46:39 <Cale> also, the evaluation of expressions is separate from the execution of IO actions
18:46:56 <newcomer> Cale, how is that?
18:48:00 <Cale> Evaluation of expressions puts the expression into a form where either it is a lambda, or a data constructor applied to some arguments. i.e. it's the process which is reducing expressions to values which can be pattern matched on (or in the case of functions, applied to an argument)
18:48:19 <Cale> Evaluation has no user-visible effects
18:48:44 <Cale> It just does computation and warms up your CPU a bunch, perhaps consumes lots of memory :)
18:49:12 <ExcaliburZero> What does it mean when a function signature includes something like the following?
18:49:13 <ExcaliburZero> (MonadIO m, MonadCatch m)
18:49:13 <Cale> Execution on the other hand refers to carrying out the effects which are described by IO action values.
18:49:17 <ExcaliburZero> Such as in the following:
18:49:21 <ExcaliburZero> (MonadIO m, MonadCatch m) => Path b File -> ZipArchive a -> a
18:49:29 <scshunt> ExcaliburZero: that is a typeclass constraint
18:49:37 <Koterpillar> ExcaliburZero: doesn't make sense though, there's no m on the right
18:49:42 <scshunt> it means that there must be instances of MonadIO and MonadCatch for m
18:49:51 <scshunt> but in this case, as Koterpillar said, that makes no sense, because m is not used
18:50:04 <ExcaliburZero> Whoops, I mis-copied. There is an m before the a on the end.
18:50:12 <ExcaliburZero> (MonadIO m, MonadCatch m) => Path b File -> ZipArchive a -> m a
18:50:22 <Koterpillar> then that m must be MonadIO and MonadCatch
18:50:41 <Cale> Right, so this is a function which takes a Path b File, and a ZipArchive a, and produces an m-action, where m is any monad that happens to be an instance of MonadIO and MonadCatch
18:50:52 <Cale> MonadIO means that you have liftIO :: IO a -> m a
18:51:07 <Cale> i.e. there is a way to turn IO actions into m actions.
18:51:37 <Cale> MonadCatch means that you have  catch :: Exception e => m a -> (e -> m a) -> m a
18:51:45 <newcomer> Cale, Yes, I understand, but both are only done if they are transversely subexpressions of main. right?
18:52:14 <Cale> newcomer: sure -- it'll never go off evaluating or executing things which there's no reason to
18:52:24 <Koterpillar> Cale: if it's not in main, it won't get evaluated; if it is, it _might_
18:52:39 <ExcaliburZero> So in this case the typeclass constraints being in a tuple shows that both are applied to the m term?
18:52:51 <Cale> Right, he didn't say if and only if ;)
18:53:13 * hackagebot unix-compat 0.4.2.0 - Portable POSIX-compatibility layer.  https://hackage.haskell.org/package/unix-compat-0.4.2.0 (JacobStanley)
18:53:33 <Koterpillar> ExcaliburZero: I don't know if you can call that a tuple, but yes
18:53:39 <Cale> ExcaliburZero: Yeah, it's not even really a tuple, it's just the notation which is used to list multiple type class constraints
18:54:01 <ExcaliburZero> Okay, that makes sense.
18:54:41 <ExcaliburZero> I wasnt sure if it was supposed to represent a real tuple or was just the  notation for multiple constraints.
18:55:08 <newcomer> Speakign of ExcaliburZero's topic. I just just reading about MonadError typeclass and I was confused that it's instances of such a class are actually pairs of an error type and a (Monadic) type constructor. A pair together is an instance, right? 
18:55:31 <Cale> Well, it kind of is a tuple in a way... you can imagine that your function is secretly getting an argument which is a tuple of dictionaries constructed from the appropriate instances of the type classes
18:55:57 <newcomer> My last sentence is full shamefully full of typos :)
18:56:07 <newcomer> so is this :)
18:56:29 <ExcaliburZero> Can you recommend any good resources on working with MonadCatch? I've looked a  bit at the documentation of Control.Monad.Catch, but I was wondering if there is any other resource which is a bit more instructive on how to work with it.
18:56:32 <Cale> Yeah, that one is a multi-parameter type class
18:56:55 <Cale> MonadError e m expresses a relationship between the monad m and some error type e
18:57:15 <Cale> There's a functional dependency on the class, saying that m determines e uniquely, so there can be at most one instance for any given m
18:57:34 <Cale> and knowing m, when the compiler finds that instance, it can determine which type e is
18:57:58 <Cale> (which can help resolve cases where it's ambiguous)
18:58:53 <Cale> e.g. perhaps you use  catchError :: MonadError e m => m a -> (e -> m a) -> m a  like  catchError foo (\_ -> ...), where the argument to the handler is unused
18:59:16 <Cale> If the functional dependency weren't there, then it might not be able to figure out which type e should be used
18:59:49 <Cale> and so even though there's perhaps an instance available, it wouldn't know that it's the right one
19:00:05 <Cale> class Monad m => MonadError e m | m -> e where ...
19:00:15 <Cale> So the m -> e there helps out in that case
19:02:20 <newcomer> Cale, if m determines e why make it a multi-parameter type class in the first place?
19:02:40 <Cale> newcomer: Well, what else to do?
19:02:52 <Cale> newcomer: There actually are other options now
19:02:52 <Koterpillar> newcomer: when defining an instance, you'll have to define e
19:03:03 <Cale> Yeah, each instance will specify which type e is
19:03:47 <Cale> With a much newer compiler extension, we could instead have:
19:03:55 <Cale> class Monad m => MonadError m where
19:04:06 <Cale>   type ErrorType m
19:04:24 <Cale>   catchError :: m a -> (ErrorType m -> m a) -> m a
19:04:54 <Cale> and then in the instances, you'd specify which type ErrorType m was for your particular m
19:05:09 <kadoban> Cale: Woh. What extension is that, out of curiosity?
19:05:14 <Cale> TypeFamilies
19:05:22 <kadoban> Ah, hmm
19:06:07 <Cale> (it's newer, but not really new at this point)
19:06:42 <Koterpillar> Cale: and you can't say e determines am here
19:07:07 <dfeuer> The advantage of type families is that the "determination" is available from within Haskell.
19:07:15 <Cale> Yeah, if you wanted e to determine m as well, you'd have to introduce two associated types
19:07:23 <dfeuer> But in most practical circumstances, that's not actually important.
19:07:42 <Cale> and then stick some equality constraints into the place where superclass constraints go
19:07:51 <dfeuer> Actually, let me restate:
19:08:02 <dfeuer> Even if that *is* important, it's nicer to have the MPTC.
19:08:08 <dfeuer> (IMO)
19:08:28 <Cale> I'm not sure if I understand what point dfeuer is trying to make...
19:08:34 <dfeuer> OK.
19:08:43 <Cale> But multiparameter type classes tend to be good at some things and type families good at others
19:08:56 <Cale> and maybe he's just saying it's nice to be able to choose?
19:09:04 <dfeuer> You can simulate the fundep using type families:
19:09:18 * newcomer is confused. But that's OK.
19:09:31 <dfeuer> class e ~ ErrorType m => MonadError e m where ...
19:10:02 <Cale> oh, haha, that's yet another option
19:10:15 <dfeuer> The nice thing about that is that you can (if you like) write   foo :: MonadError e m => e :~: ErrorType m; foo = Refl
19:10:24 <Cale> Still using multiparameter type classes, but now also with type families :)
19:10:30 <dfeuer> Whereas with the fundep version, you can't.
19:11:11 <dfeuer> The nice thing about MPTC is that the context makes a very clear statement: "Given an m which is an error monad with error type e ...."
19:11:19 <Cale> uh... well, with the fundep version, there aren't two names for the same type
19:11:25 <Cale> So it would just be e :~: e
19:11:40 <Cale> But yeah
19:12:09 <dfeuer> Where's with the type-family-only version you may have to write nasty things like   (ErrorType m ~ String, MonadError m) => ....
19:12:12 <dfeuer> *whereas
19:12:49 <Cale> Yeah, I see what you mean
19:13:10 <dfeuer> Cale, in practice, it seems you generally don't need to be able to prove such things as foo.
19:13:19 <lpaste> glguy pasted “a difference between fundeps and type families” at http://lpaste.net/165051
19:13:27 <dfeuer> But if fundeps were implemented in terms of type families, you could indeed do so.
19:14:23 <glguy> The difference I pasted shouldn't be a difference, but it is in GHC
19:14:34 <Cale> oh, that's... fun
19:15:45 <ggVGc> I know I've asked before, but I still get into doubts. What's the pros/const of having an ADT of "actions" vs having a record of functions?
19:15:58 <categoryTheoreti> if I have a type foo (bar::kd)  where data kd = biz | baz, how can I pattern match on a foo to check if bar is biz or baz?
19:16:44 <ggVGc> categoryTheoreti: case foo of kd(biz)
19:16:50 <ggVGc> etc.
19:17:00 <ggVGc> categoryTheoreti: you can pattern match on any constructor
19:17:10 <ggVGc> and any nesting of constructors
19:17:32 <Cale> Note that this is not syntactically correct because both type and data constructors must start with an uppercase letter
19:17:39 <ggVGc> yeah, that
19:17:43 <categoryTheoreti> Cool, thanks, just didn't know the syntax and google wasn't helping
19:18:06 <Welkin> the Alan Turing film was good
19:19:03 <ggVGc> categoryTheoreti: if you at some point want to pattern match on somethign but also want to bind the value of the whole thing, you can do this case foo of x@(Foo(Bar y)). This will bind y to the value held by Bar, and bind all of Foo(Bar y) to the name x
19:19:21 <ggVGc> Welkin: kind of, but I hear it's very full of misinformation
19:19:23 <ggVGc> but yeah, I enjoyed it
19:20:06 <Welkin> sure
19:20:14 <Welkin> most movies like that are not completely accurate
19:20:23 <Welkin> but it is entertaining and the acting is well done
19:21:25 <Welkin> I like how people only say "homosexual" because there was no word such as "gay"
19:21:38 <dmj`> Welkin: haskell-blah
19:21:41 <Welkin> I found that interesting
19:22:02 <Welkin> dmj`: I was banned for no reason, and decided not to bother going back
19:44:44 <newcomer> karim_, is that an Arabic name?
19:45:35 <dfeuer> newcomer, it is. Apparently it means "generous" or "noble".
19:45:36 <karim_> yup
19:45:55 <karim_> it means generous
19:46:22 <newcomer> dfeuer, Yeah, I'm an Arab myself.
19:46:36 <newcomer> أهلاً وسهلاً يا كريم
19:46:48 <karim_> اهلا  
19:47:19 <karim_> اول مره اقابل عربي هنا  
19:47:42 <newcomer> آديك قابلت ... شكلك كمان مصري
19:48:16 <glguy> Sorry, those Arabic letter are very pretty, but this is an English language channel
19:48:16 <newcomer> Are we violating any policies by talking in Arabic?
19:48:33 <karim_> sorry guys 
19:48:39 <karim_> yup i am egyptain 
19:48:53 <newcomer> yeah, me tool
19:48:57 <newcomer> too
19:49:06 <Welkin> anglais
19:49:07 <glguy> If you guys want to chat about names or language, etc, you're welcome to use #haskell-offtopic
19:49:20 <peddie> is there a #haskell-ar?
19:49:23 <newcomer> glguy, noted.
19:50:18 <newcomer> peddie, no.
19:50:45 <peddie> newcomer: you know what to do :)
19:50:56 <newcomer> peddie, yes, just did :)
21:38:18 * hackagebot octane 0.6.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.6.0 (fozworth)
22:41:57 <jle`> so much unsafeCoerce Refl's
23:08:21 * hackagebot html-entities 1.1.2 - A codec library for HTML-escaped text and HTML-entities  https://hackage.haskell.org/package/html-entities-1.1.2 (NikitaVolkov)
23:08:25 <texasmynsted> does anybody use hlint inside ghci?  Looks like the recommendation is to add somethings to .ghic file as shown here —>  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-dot-files.html
23:08:33 <texasmynsted> But that page does not appear to exist
23:09:56 <Koterpillar> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-and-haskeline-files
23:10:14 <texasmynsted> oh nice.  Thank yoyu
23:10:14 <Koterpillar> where'd you find the link?
23:10:17 <texasmynsted> or you rather
23:10:34 <texasmynsted> Here —> https://github.com/ndmitchell/hlint
23:10:38 <geekosaur> the manual was reorganized a bit for 8.0, all the old links stopped working
23:14:24 <texasmynsted> It says "The script is at https://raw.githubusercontent.com/ndmitchell/hlint/master/data/hlint.ghci, and a copy is installed locally in the data directory."
23:14:38 <texasmynsted> where is the "data directory"?
23:16:06 <geekosaur> if you "git clone https://github.com/ndmitchell/hlint; cd hlint" then it will be in a directory named data/
23:17:26 <Koterpillar> texasmynsted: that's whatever getDataDir returns
23:18:10 <texasmynsted> I think I installed hlint via stack
23:18:20 <texasmynsted> the binary is in ~/.local/bin
23:19:01 <Koterpillar> it'll be somewhere in .stack then
23:20:51 <Koterpillar> ~/.stack/snapshots/x86_64-linux/lts-5.13/7.10.3/share/x86_64-linux-ghc-7.10.3/hlint-1.9.31/hlint.ghci
23:20:52 <Koterpillar> found it
23:27:09 <texasmynsted> thank you
23:27:37 <Koterpillar> with cabal install, it was ~/.local/share/hlint/
23:33:22 * hackagebot pipes-cacophony 0.3.0 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.3.0 (jgalt)
23:33:24 * hackagebot typelits-witnesses 0.2.3.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.2.3.0 (jle)
23:42:44 <maybefbi> why do people say Applicative is laxer than a Monad?
23:46:37 <shachaf> Because it's a lax monoidal functor, no doubt.
23:46:59 <shachaf> I guess a monad is also a lax functor.
23:47:16 <lieven> because every Monad can be made into an Applicative but not the other way around. just like every field is a ring but not the other way around
23:47:34 <jle`> maybefbi: i've never herad anyone call Applicative "laxer than a monad"
23:47:58 <maybefbi> jle`, http://dev.stephendiehl.com/hask/#applicative-do
23:48:37 <jle`> ah in that context it probably means that the constraint is more general
23:48:44 <jle`> it's referring to the constraints
23:48:50 <Ferdirand> what is the simplest Applicative that is not a proper Monad, btw ?
23:48:56 <jle`> instead of only working for Monad instances, it works for all Applicatives, too
23:49:04 <jle`> Ferdirand: Const s comes to mind
23:49:17 <maybefbi> applicative doesn't deal with (a -> m b) so how can a monad be an applicative?
23:49:34 <Cale> Ferdirand: The canonical example is ZipList
23:49:53 <jle`> maybefbi: a Monad has extra abilities than just what Applicative in general has
23:50:04 <shachaf> Cale: I'm not sure an example that people keep arguing about is good as a canonical example.
23:50:12 <jle`> maybefbi: your question is like asking "not all shapes have corners, so how can a square be a shape"
23:50:18 <Cale> shachaf: what?
23:50:25 <Cale> People argue about ZipList?
23:50:32 <shachaf> People keep thinking that there's a way to extend ZipList to a monad.
23:50:33 <maybefbi> jle`, ok
23:50:49 <shachaf> They keep being wrong, but it means it's not particularly obvious.
23:50:51 <jle`> maybefbi: or like asking "not all animals have legs, so how can humans be animals" :)
23:51:11 <Cale> ah, hmm
23:51:15 <Cale> I was unaware of that
23:51:29 <shachaf> Maybe I'm overstating the case.
23:51:29 <Cale> I guess it is a little bit like Stream, which is isomorphic to (->) Nat
23:51:44 <maybefbi> jle`, so being able to compose (a -> m b) like things is something only monads can do
23:51:56 <shachaf> I do think Const e (for non-() monoid e) simpler.
23:52:07 <maybefbi> jle`, monads can also do f (a -> b) -> f a -> f b
23:52:13 <maybefbi> jle`, ?
23:52:14 <jle`> maybefbi: yes, they can do both
23:52:30 <jle`> it's a fun exercise to try to implement the second one using only >>= and return, or fmap
23:52:51 <Cale> :t let ap mf mx = do f <- mf; x <- mx; return (f x) in ap
23:52:53 <lambdabot> Monad m => m (t -> b) -> m t -> m b
23:53:02 <Cale> oh, I guess I just spoiled the exercise
23:53:06 <jle`> :P
23:53:13 <Cale> didn't read the comment before typing
23:53:15 <jle`> 'Const e' is my favorite non-Monad Applicative
23:53:24 <jle`> but there's also the "Validation" Applicative instance for Either
23:53:29 <Koterpillar> Cale: your punishment is redoing it without do
23:53:52 <Cale> @undo do f <- mf; x <- mx; return (f x)
23:53:52 <lambdabot> mf >>= \ f -> mx >>= \ x -> return (f x)
23:54:08 <jle`> it's more immediately obvious with 'Const e' that a Monad instance is impossible, I suppose, becuase you can't even write one that typechecks
23:54:23 <jle`> but you could write a typechecking Monad instance for the ZipList Applicative and not realize why it's wrong
23:54:47 <shachaf> \mf mx -> (do mf) >>= \f -> (do mx) >>= \x -> (do return) (do f x)
23:55:03 <Cale> heh
23:56:02 <shachaf> I can't remember if there was a reason that "f do x" and "f \x -> ..." and so on are errors.
23:56:26 <Cale> I don't believe there's a particularly good reason
23:56:30 <jle`> i just remember there being lots of pushback when people try to modify the syntax to allow f \x -> ...
23:57:06 <jle`> maybe people miss writing perl so much
23:57:21 <Cale> Well... it's tricky. You don't just want to do it without a compiler flag, but I think it's possibly the case that modifying the parser in such a way that this is easily a flag is tricky?
23:57:23 <shachaf> @quote \\.*::.*::.*::
23:57:23 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
23:58:54 <Cale> cute
