00:01:46 <shachaf> > Just $ do 4 :: Int
00:01:48 <lambdabot>  Just 4
00:02:06 <Cale> > Just $ do 4 :: Int :: Maybe Int
00:02:08 <lambdabot>  Just 4
00:02:56 <shachaf> > Just $ do 4 :: (Int :: *) :: (Maybe Int :: *)
00:02:58 <lambdabot>  Just 4
00:04:02 <Cale> If only we had do-syntax at the type level ;)
00:05:19 <shachaf> That would be useful if you had a monad in the category of endofunctors.
00:06:02 <maybefbi> surely there must be a free monad based on endofunctors
00:11:49 <aleator> Anyone know how errors are represented in GHC internals? Is there an ADT or are they just strings from the beginning?
00:27:18 <ArtfulDodger> gnome-screenshot -a
00:27:27 <ArtfulDodger> whoops
00:38:24 * hackagebot pipes-key-value-csv 0.2.0.0 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.2.0.0 (mjmrotek)
00:47:52 <b6> hi, i'm looking for someone to take over maintainership of oeis. https://github.com/bsl/oeis/issues/5
00:48:24 * hackagebot refined 0.1.2.1 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.1.2.1 (NikitaVolkov)
00:50:20 <maybefbi> b6, so the main issue is it doesnt build with new packages?\
00:51:44 <b6> maybefbi: i'm not sure. i see the main issue as being, after being obsessed with computers for 20 years, i want to do different stuff now. ;)
00:53:05 <maybefbi> b6, ok :)
01:08:25 * hackagebot parconc-examples 0.4 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4 (SimonMarlow)
01:17:15 <quchen> aleator: They're "Doc"s
01:17:52 <quchen> (Which is a structured string)
01:19:16 <quchen> aleator: See ghc/compiler/utils/{Pretty,Outputable}.hs
01:20:18 <quchen> And here's for example how "no instance" errors are being generated: https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcErrors.hs#L2074
01:42:14 <brujoand> I've got a haskell project which is built using stack. Is there a good way to make a deb from the build? I tried using checkinstall, but it failed to handle the shared libs. So I was hoping there was a waya to use fpm maybe?
01:46:31 <evilop> there isn't one
01:46:50 <evilop> write a propper deb that pulls in all the deps from the debian repos
02:08:27 * hackagebot pinch 0.3.0.0 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.3.0.0 (abhinav)
02:09:03 <outluck> http://espedito.homepc.it/ @ostever
02:30:11 <pavonia> Is there a package for comparing two lists and getting a result that describes the difference between these lists?
02:30:34 <pavonia> Apparently "difference lists" is something completely different in Haskell
02:30:55 <merijn> pavonia: You mean like edit distance?
02:31:09 <pavonia> I think so
02:31:18 <merijn> e.g. Levenshtein or similar?
02:32:10 <pavonia> Wel, not only a number but a transformation list or something
02:33:15 <merijn> You're going to have to be a whole lot more specific in explaining what you mean :p
02:33:20 <berndl> Quick question: If I have two values of type IO (), are those values technically the same even though they may be describing different IO actions?
02:34:38 <pavonia> merijn: Like when you are comparing two files line by line, you get a result of which lines are the same, where lines have been inserted and where lines have been removed. I want that for arbitrary lists
02:35:13 <phanimahesh> berndl: I don't think so. I am pretty sure they aren't.
02:35:46 <EvanR> pavonia: so a "diff"
02:35:59 <phanimahesh> They just happen to be opaque. You can create them only using a few provided tools, and once created you can not destructure theminto components.
02:36:42 <EvanR> this sort of operation is actually built into clojure
02:36:53 <EvanR> for "arbitrary" structures
02:37:01 <merijn> berndl: Define the same
02:37:04 <pavonia> EvanR: If "diff" is the term used for it, yes :p
02:38:02 <EvanR> i think patch theory has some good math for this
02:38:11 <pavonia> Ah, there's the Diff package which seems to implement that
02:41:31 <ph88> is there a single function for    concatMap id   ?
02:42:06 <pavonia> join
02:42:27 <jle`> fold
02:42:47 <jle`> or, um
02:42:49 <jle`> concat
02:42:53 <jle`> >_>
02:42:59 <jle`> > concatMap id [[1,2,3],[4,5,6]]
02:43:01 <lambdabot>  [1,2,3,4,5,6]
02:43:05 <jle`> > concat [[1,2,3],[4,5,6]]
02:43:06 <lambdabot>  [1,2,3,4,5,6]
02:43:16 <jle`> ^ ph88 
02:43:20 <bergmark> @type [concatMap id, concat, join]
02:43:21 <lambdabot> [[[b]] -> [b]]
02:43:41 <jle`> :t [concatMap id, concat, join, fold, foldMap id]
02:43:43 <lambdabot> [[[b]] -> [b]]
02:43:54 <jle`> :t [concatMap id, concat, join, fold, foldMap id, mconcat]
02:43:55 <lambdabot> [[[b]] -> [b]]
02:44:09 <jle`> :t [concatMap id, concat, join, fold, foldMap id, mconcat, asum, msum]
02:44:10 <lambdabot> [[[b]] -> [b]]
02:44:13 <bergmark> :-)
02:44:27 <jle`> that's all i got
02:44:44 <jle`> foldMap id probably shouldn't count because they were asking for single functions
02:48:07 <bergmark> ph88: hlint would have told you about concat
02:53:29 <berndl> merijn: if a and b have type IO (), then a = b.
02:54:46 <Xandaros> If a and b have type Int, then a = b
02:54:49 * EvanR doesnt seem right
02:55:04 <merijn> berndl: That's not a definition of "same", because you don't specify what '=' *means*. Which is a rather pedantic question, but at the same time rather crucial :) You're essentially asking a non-sensical question, but it's hard to explain why it's non-sensical without knowing why you think it IS sensical :)
02:55:11 <Xandaros> They may have the same type, but they have different values
02:55:47 <EvanR> launchMissiles :: IO (), cookBreakfast :: IO ()
02:55:54 <opqdonut> berndl: no, they are not the same in any way
02:56:05 <berndl> merijn: I meant "a == b", but then I guess I'm assuing that all types are deriving Eq
02:56:13 <berndl> *assuming
02:56:21 <merijn> berndl: Right, but there's a reason IO () is not an instance of Eq :)
02:56:25 <jle`> berndl: consider source code for a program that prints out the fibonacci sequence, and the source code for a program that prints out the factorial series
02:56:41 <jle`> berndl: they both have the same type -- IO actions -- but they are different
02:56:56 <jle`> they aren't really the same in any meaningful way
02:57:07 <merijn> You guys are all saying the same thing (i.e., it's non-sensical), but not explaining why
02:57:17 <berndl> I guess my misunderstanding comes from the assumption that IO () and () have the same cardinality.
02:57:23 <jle`> ah, definitely not
02:57:27 <opqdonut> yeah
02:57:29 <Xandaros> berndl: I think you are getting confused by the "()". This is not the sole type, the IO is important. "()" only has one possible value, "IO ()" has an infinite amount
02:57:33 <jle`> there are lots of different IO actions that return ()
02:57:35 <opqdonut> you can think about [()] vs. () as an analogy
02:57:44 <merijn> berndl: If we're thinking of types as sets of inhabitants than () has 2 inhabitants, whereas "IO ()" has infinite :)
02:57:55 <berndl> Makes sense.
02:57:56 <Xandaros> (ignoring undefined)
02:58:01 <jle`> berndl: remember that IO actions describe computations, so an IO () is a description of a computation
02:58:12 <jle`> berndl: so, there are many, many, many descriptions of computations that return ()
02:58:43 <jle`> `putStrLn "hello"` is one description of an IO action, `putStrLn "world"` is another description of an IO action
02:58:45 <berndl> OK.
02:58:50 <jle`> they both reutrn (), so they have the same type
02:58:52 <merijn> berndl: Lemme introduce the notion of intensional vs extensional equality. Things are intensional equal if they're literally the same thing (i.e. something like pointer equality in C, it relies on a notion of identity)
02:58:54 <jle`> but they definitely are very different actions
02:59:07 <jle`> and they describe different actions ... just like different files of source code with different contents
02:59:17 <merijn> berndl: Then we have extensional equality (things that behave identical, like value equality)
03:00:00 <ph88> thx jle` 
03:00:14 <merijn> berndl: Now, when it comes to code (which is the closest thing to IO, I think) things become tricky. Suppose we have to pointers/references to the same function, it's trivial to say they're "the same", but suppose we have to functions that both compute factorial. Are they the same?
03:00:35 <merijn> berndl: What if we have different source computing the same result? Extensionally equal, intensionally...not so.
03:00:53 <berndl> merijn: True.
03:01:00 <merijn> berndl: (That's not even taking into account they might have different performance, i.e. quadratic vs linear or whatever)
03:01:03 <ph88> is it a good idea to install this package  ?  https://hackage.haskell.org/package/heredoc
03:01:25 <jle`> i've used it before
03:02:14 <merijn> berndl: Intensional equality (i.e. ptr equality) is generally doable, but kinda useless. Extensional equality brings millions of problems, like differences in operation performance, decidability (how do you compare the behaviour of Turing complete functions?)
03:02:20 <berndl> merijn: You said () has two inhabitants. I thought it only has one, namely () confusingly.
03:02:31 <Xandaros> berndl: every type has undefined
03:02:44 <Xandaros> …which I generally ignore
03:02:47 <merijn> berndl: So the sanest thing to do is to say "screw this" and say "we can't compare code", hence the lack of IO equality
03:02:59 <berndl> Xandaros: ah, OK.
03:02:59 <merijn> berndl: And yes, as Xandaros points out "bottom" inhabits every type :)
03:03:09 <merijn> (undefined being a form of bottom)
03:03:16 <berndl> But isn't bottom a type?
03:03:31 <Xandaros> bottom is a value
03:03:39 <merijn> berndl: Bottom is the mathematical notion of non-termination. It's a value that inhabits every type
03:03:42 <berndl> Oh, OK. Then what is the type with no values?
03:03:48 <Xandaros> That's Void :)
03:03:51 <merijn> berndl: Doesn't exist in Haskell
03:03:51 <phanimahesh> bottom is a value that indicates the code never terminated.
03:03:56 <berndl> I see...
03:03:58 <merijn> Xandaros: No, Void is inhabited by bottom
03:04:04 <Xandaros> (Void does contain undefined, though)
03:04:45 <merijn> berndl: There are languages that are total (no non-termination, but that sacrificies Turing-completeness), those have types that have 0 inhabitants (and () there has 1, as you thought)
03:04:45 <berndl> OK, so it doesn't exist.
03:04:46 <phanimahesh> or in other words, bottom is returned by programs that never return.
03:06:36 <berndl> In a sense, all Haskell functions are partial function since they can return undefined.
03:07:00 <Xandaros> berndl: You can usually ignore the existance of bottom altogether. It is my belief that if someone decides to put bottom in one of my functions, they deserve to get undefined behaviour. That said, if you define a function like absurd, you should probably seq it, because it's guaranteed to be bottom
03:07:24 <Xandaros> berndl: They _can_m but unless they _do_, they aren't partial
03:07:53 <phanimahesh> I find undefined a nice convinience. Define types and leave out the body for later.
03:08:04 <Xandaros> typed holes ftw
03:08:25 <Xandaros> _ is also shorter than undefined :P
03:08:26 <EvanR> Xandaros: hold on now
03:08:56 <phanimahesh> Yep. Also holes. I'm just getting started but love being able to leave out parts I can not easily figure out.
03:09:09 <EvanR> you may be programming in a way to explicitly makes use of bottom, for example racing threads that compute an answer first
03:09:24 <EvanR> and killing the loser
03:09:43 <Xandaros> EvanR: I have actually used bottom explicitly before. I did say 'usually' :P
03:09:51 <Xandaros> It can be rather useful at times, I agree
03:10:13 <Xandaros> For the most part, it can be safely ignored, though
03:10:30 <EvanR> its an integral part of haskell lore ;)
03:12:42 <etatoby> hello. does anybody know how to Debug.Trace the type of an expression? like the way :t works in ghci?
03:13:39 <cocreature> etatoby: if you have a Typeable constraint you can call typeOf which gives you a TypeRep that you can show
03:18:29 * hackagebot supplemented 0.5.1 - Early termination for monads  https://hackage.haskell.org/package/supplemented-0.5.1 (NikitaVolkov)
03:18:49 <sbrg> etatoby: You can just derive Typeable if you enable the extension, if only for debugging.
03:20:12 <etatoby> cocreature: sbrg: I'm reading up on that. does it have predefined instances for basic types?
03:20:40 <sbrg> yep
03:20:50 <EvanR> > typeOf True
03:20:52 <lambdabot>  Bool
03:20:57 <EvanR> > typeOf 3
03:20:58 <sbrg> > show $ typeOf 3
03:20:59 <lambdabot>  Integer
03:21:00 <lambdabot>  "Integer"
03:21:05 <cocreature> in fact since ghc something you can only derive Typeable, it’s not possible to implement it yourself
03:21:05 <sbrg> EvanR: lol, same number
03:21:19 <EvanR> 3 is clearly the most random integer of all
03:21:22 <sbrg> for some reason I always use 3 when writing arbitrary integer constants for demonstrative purposes
03:21:27 <sbrg> EvanR: I agree whole-heartedly
03:21:36 <cocreature> I use 5 in most cases
03:22:07 <etatoby> nice!
03:22:29 <Xandaros> Relevant: https://xkcd.com/221/
03:22:44 <etatoby> I'm reading http://chrisdone.com/posts/data-typeable
03:22:56 <cocreature> I know what xkcd that is without klicking on it :)
03:23:02 <etatoby> but his :i Typeable shows much more than mine
03:23:06 <sbrg> same
03:23:19 <sbrg> though I disagree with Munroe's choice of 4
03:23:25 <sbrg> it is clearly less random than 3
03:23:28 <sbrg> or 7
03:23:30 * hackagebot interspersed 0.1.2 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.2 (NikitaVolkov)
03:23:31 <EvanR> etatoby: everything is Typeable
03:23:32 * hackagebot unsequential 0.5.1 - An extension removing the sequentiality from monads  https://hackage.haskell.org/package/unsequential-0.5.1 (NikitaVolkov)
03:28:30 * hackagebot json-incremental-decoder 0.1.1 - Incremental JSON parser with early termination and a declarative DSL  https://hackage.haskell.org/package/json-incremental-decoder-0.1.1 (NikitaVolkov)
03:28:32 * hackagebot json-encoder 0.1.8 - A direct-to-bytes single-pass JSON encoder with a declarative DSL  https://hackage.haskell.org/package/json-encoder-0.1.8 (NikitaVolkov)
03:33:30 * hackagebot http-response-decoder 0.2.2 - Declarative DSL for parsing an HTTP response  https://hackage.haskell.org/package/http-response-decoder-0.2.2 (NikitaVolkov)
03:41:49 <Aruro> how do i delay stuff in main function? putStr "1" >> threadDelay 1000000 >> putStr "2" , does something very bad.
03:42:23 <sbrg> define "something very bad"
03:43:13 <Aruro> puts all at the same time
03:43:16 <ahihi> make sure you have stdout buffering disabled if you're using putStr
03:43:25 <ahihi> or flush it manually
03:43:37 <Akii> does anyone in here use haskell for event sourcing?
03:44:25 <Aruro> ahihi:  ah, forgot put does not flush, ty. 
03:46:26 <Faucelme> I often use the NumDecimals extension to specify delays as "threadDelay 1e6".
03:46:56 <mauke> don't disable buffering if you can avoid it
03:47:04 <mauke> hFlush is better here
03:48:30 * hackagebot jwt 0.7.2 - JSON Web Token (JWT) decoding and encoding  https://hackage.haskell.org/package/jwt-0.7.2 (StefanSaasen)
04:00:09 <ph88> how do i use this  here  function ?   https://hackage.haskell.org/package/heredoc-0.2.0.0/docs/Text-Heredoc.html
04:00:35 <EvanR> [here| whatever |]
04:00:59 <EvanR> its not a function, its a quasiquoter
04:01:29 <EvanR> here = (qq "here" Exp) { quoteExp  = litE . stringL . toUnix }
04:01:39 <EvanR> so [here| whatever |] is an expression
04:01:47 <EvanR> as opposed to a type, or declaration, or something else
04:02:36 <ph88> hows that different from str ?
04:02:49 <EvanR> it becomes a string literal in the code
04:03:00 <EvanR> because of the litE . stringL
04:03:37 <EvanR> so if you write
04:03:46 <EvanR> [here| line1
04:03:47 <EvanR> line2
04:03:50 <EvanR> line3
04:03:52 <EvanR> |]
04:04:07 <ph88> oh ok so i don't need | in front of every line
04:04:09 <EvanR> it would become " line1\nline2\nline3\n"
04:04:11 <ph88> i want to use doctest + something to put strings in multi-line
04:05:39 <EvanR> for multiline strings theres also literate haskell
04:06:10 <ph88> can i use that with doctest ?
04:06:14 <EvanR> dunno
04:08:38 <ph88> is it possible somehow to make this type so that   i don't need I1 and I2 ?  i can already see which type it is from the underlying constructor    data Identifier = I1 BasicIdentifier | I2 ExtendedIdentifier
04:09:07 <sbrg> ph88: Either?
04:09:13 <ph88> here is an example out put for show:    (I1 (MkBasicIdentifier "ieee"))
04:09:23 <ph88> well Either still shows me Left and Right no ?
04:09:57 <sbrg> you need a type to represent that it can be one or the other. you can't simultaneously have two different types
04:09:59 <ph88> maybe i can unwrap MkBasicIdentifier  first and put the string in I1  ?
04:10:12 <sbrg> you could do that
04:10:44 <ph88> how ?
04:10:51 <ph88> i have this function      identifier = (I1 <$> basicIdentifier) <|> (I2 <$> extendedIdentifier)
04:11:37 <sbrg> what is the type of BasicIdentifier vs ExtendedIdentifier?
04:11:40 <ph88> hhmm actually i know, i can just make BasicIdentifier an alias of String
04:11:48 <sbrg> data Identifier = Basic | Extended ish?
04:11:50 <ph88> newtype BasicIdentifier = MkBasicIdentifier String
04:12:07 <sbrg> why not just gather those under an Identifier sumtype?
04:13:04 <ph88> not sure what you are saying
04:13:24 <ph88> but i solved it by changing that last line to:   type BasicIdentifier = String
04:13:47 <sbrg> ph88: why is ExtendedIdentifier a different type from BasicIdentifier?
04:14:03 <ph88> because it can contain different characters
04:14:12 <sbrg> Both are identifiers. It makes sense to represent them both using data Identifier = BasicIdentifier String | ExtendedIdentifier String
04:14:22 <ph88> ye !
04:14:23 <sbrg> that would remove the need to create the I2, I2 sumtype
04:14:29 <sbrg> i1*
04:14:40 <ph88> yes i just renamed I1 to IBasic
04:15:43 <ph88> in my parser how can i save the line and position where the string was found ?
04:18:56 <sbrg> you'll need to manually keep track of it
04:19:15 <ph88> uf
04:19:20 <ph88> that's gonna be ugly
04:19:49 <ph88> a global variable with the current line number would be nice
04:26:20 <ph88> library <- pack <$> (asciiCI "LIBRARY")     asciiCI "LIBRARY" is of type    Parser String   and i want to convert it to    Parser Text   with the pack function, not sure what i'm doing wrong here
04:29:28 <ph88> maybe fmap ?
04:29:40 <pavonia> (<$>) is fmap
04:29:54 <pavonia> What is the error message?
04:31:44 <berndl> Is it possible to make a type consisting of finitely many values of an existing type, like data BoolString = "False" | "True".
04:32:34 <ph88> https://paste.fedoraproject.org/373698/86712414/
04:32:38 <ph88> pavonia, ^
04:33:23 <ph88> berndl, im noobie, but maybe that goes into the direction of depended typing or smart constructors
04:34:48 <berndl> ph88: OK.
04:34:50 <pavonia> ph88: Are you sure asciiCI is returning a String?
04:35:20 <ph88> eh no
04:35:21 <ph88> sorry
04:35:32 <ph88> asciiCI :: Text -> Parser Text
04:36:24 <EvanR> berndl: not directly, but there is a library for talking about arbitrary properties that are checked at compile time (or checked that you will check at runtime), such as the property of a string that it equals "True" or "False"
04:37:07 <EvanR> or that the string consists of only ascii characters
04:37:39 <EvanR> generally though you dont want to represent important information in String form
04:37:42 <ph88> pavonia, i removed that pack (i put it there on the wrong assumption)  ..  but my data is like   data = Foo String    and it expect string but i get back Text .. how can i change my data from String to Text ?     Not in scope: type constructor or class ‘Text’
04:38:33 * hackagebot json-pointer 0.1.2.1 - JSON Pointer parsing and interpretation utilities  https://hackage.haskell.org/package/json-pointer-0.1.2.1 (NikitaVolkov)
04:39:17 <pavonia> ph88: There's unpack
04:39:35 <ph88> i heard Text was better than String
04:39:37 <berndl> EvanR: OK.
04:42:40 <EvanR> berndl: its kind of an acquired taste to find the sweet spot between genuinely new types and existing types plus properties
04:43:17 <berndl> you mean its kind of *difficult*
04:43:54 <EvanR> well you learn by doing, for example instead of "True" | "False", use a Bool and when you need that string, use show on it
04:44:05 <EvanR> > show True
04:44:06 <lambdabot>  "True"
04:44:17 <berndl> But I need the reverse, I need a function that takes "True" to True, etc.
04:44:19 <EvanR> your string is just an image of some other better type (for this purpose)
04:44:43 <pavonia> ph88: Why do you use String if your data type then? :p
04:44:47 <pavonia> *in
04:44:51 <berndl> Because IO
04:45:01 <EvanR> berndl: you want to validate some input that it is "True" or "False" and if so return the bool?
04:45:10 <berndl> Yes.
04:45:17 <EvanR> i.e. readBool :: String -> Maybe Bool
04:45:24 <EvanR> :t readMaybe
04:45:25 <lambdabot> Not in scope: ‘readMaybe’
04:45:36 <ph88> pavonia, it was a mistake :/  i'm looking for the right  type for Text to use in  data
04:45:47 <berndl> Nice. Let me see how that is coded.
04:46:07 <EvanR> readMaybe :: Read a => String -> Maybe a
04:46:18 <EvanR> its in Text.Read
04:47:56 <EvanR> @import Text.Read
04:47:57 <lambdabot> Unknown command, try @list
04:48:03 <EvanR> > import Text.Read
04:48:05 <lambdabot>  <hint>:1:1: parse error on input ‘import’
04:48:59 <ph88> pavonia, i think i'm not suppose to use this package ..  https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Internal.html
04:49:38 <ph88> tried  Data.Internal.Text.Text
04:49:49 <pavonia> ph88: Just use Text from Data.Text
04:56:31 <maerwald> what's the best way in cabal to specify the minimum GHC version?
04:57:12 <dcoutts> maerwald: it's typically not the ghc version exactly, but some language extension or the version of the base library that you want to specify
04:57:26 <maerwald> it's the GHC version here
04:58:06 <dcoutts> maerwald: some ghc bug?
04:58:22 <dcoutts> anyway, you can proxy on the base version
04:58:30 <maerwald> PatternSynonym type signature are not supported in GHC < 7.10
04:59:24 <dcoutts> maerwald: you mean it's not just a new extension, but a change to an existing one? Yeah that's harder.
04:59:33 <cow_2001> https://i.imgur.com/GHxmrsR.jpg
05:01:40 <maerwald> surprisingly accurate
05:03:41 <tobiasBora> Hello,
05:04:12 <oherrala> cow_2001: I'm probably doing something wrong because I don't get any unicorns
05:04:19 <cow_2001> :(
05:04:40 <tobiasBora> I would like to do a simple thing : do a fold (or a map) on a Data.Map, but in a monade (IO in my case) *and* reading keys
05:05:12 <tobiasBora> How can I do that, since the foldM in Control.Monad only accept (a -> b) functions, and not (k -> a -> b)
05:09:08 <tobiasBora> I found traversal where I ignore the result, I don't know if it's the better method, but it works !
05:09:14 <tobiasBora> *traverseWithKey
05:10:22 <maerwald> :t (fmap . map) id (return [1] :: IO [Int])
05:10:25 <lambdabot> IO [Int]
05:12:33 <maerwald> :t (fmap . Data.Map.map) id (return $ fromList [(1,1)] :: IO (Map Int Int))
05:12:34 <lambdabot>     Not in scope: type constructor or class ‘Map’
05:12:35 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
05:12:46 <maerwald> :t (fmap . Data.Map.map) id (return $ fromList [(1,1)] :: IO (Data.Map.Map Int Int))
05:12:48 <lambdabot> IO (M.Map Int Int)
05:13:34 * hackagebot libroman 2.1.0 - Roman Numerals for YOU  https://hackage.haskell.org/package/libroman-2.1.0 (ahakki)
05:14:10 <tobiasBora> :t (fmap . Data.Map.map) (\k a -> putStrLn $ show (a,k)) (return $ fromList [(1,1)] :: IO (Data.Map.Map Int Int))
05:14:11 <lambdabot> Show t => IO (M.Map Int (t -> IO ()))
05:15:12 <tobiasBora> maerwald: Not sur to understand how you get keys involved here
05:17:42 <int-e> :t Data.Map.mapWithKey
05:17:43 <lambdabot> (k -> a -> b) -> M.Map k a -> M.Map k b
05:17:48 <maerwald> > (fmap . Data.Map.mapWithKey) (\k a -> a + 2) (return $ fromList [(1,3)] :: IO (Data.Map.Map Int Int))
05:17:50 <lambdabot>  Not in scope: ‘Data.Map.mapWithKey’    Not in scope: type constructor or cla...
05:17:54 <maerwald> meh
05:18:05 <int-e> try M.mapWithKey
05:18:27 <maerwald> but that works
05:18:48 <maerwald> similar thing if you want to fold
05:20:30 <maerwald> the first fmap gets you "into" the Monad and then you mess with the Data.Map via mapWithKey, that's sort of an idiom (fmap . fmap)
05:21:13 <maerwald> explicit do-notation might be more readable though
05:24:16 <maerwald> > (fmap . fmap . fmap) (+1) (return [[1], [2]] :: IO [[Int]])
05:24:18 <lambdabot>  <IO [[Int]]>
05:24:20 <maerwald> can be easily overdone :P
05:24:33 <int-e> > Data.Map.mapWithKey
05:24:35 <lambdabot>      No instance for (Typeable k0)
05:24:35 <lambdabot>        arising from a use of ‘show_M573268715868881871229411’
05:24:35 <lambdabot>      In the expression:
05:24:58 <ski> i'd probably use `liftM .  map . map' there
05:25:17 <maerwald> I often end up using fmap just out of laziness, because "always works" heh
05:33:35 * hackagebot libroman 2.1.1 - Roman Numerals for YOU  https://hackage.haskell.org/package/libroman-2.1.1 (ahakki)
05:39:40 <EvanR> finally proper roman numeral support
05:40:05 <EvanR> dont worry we have haskell developers working on the issue as we speak
05:43:58 <int-e> @where+ state http://silicon.int-e.eu/lambdabot/State/
05:43:58 <lambdabot> It is forever etched in my memory.
05:45:06 <Axman6>  @where+ lambdabotsbrain http://silicon.int-e.eu/lambdabot/State/
05:45:31 <phanimahesh> what is lambdabot etching in its memory?
05:45:39 <Axman6> @where state
05:45:39 <lambdabot> http://silicon.int-e.eu/lambdabot/State/
05:45:41 <Axman6> that
05:45:44 <hpc> michaelangelo's david
05:45:57 <phanimahesh> Ah. Link aggregator?
05:46:00 <phanimahesh> Kewl
05:46:23 <hpc> @where rwh
05:46:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:46:26 <Axman6> it's just a useful way of remembering urls
05:46:30 <hpc> it's just a place to put things that get used often
05:46:33 <Axman6> (or anything else, but usually urls)
05:46:45 <hpc> @where where
05:46:45 <lambdabot> ^^^^^^
05:48:55 <int-e> the state one still pointed at dons' site... I guess it wasn't used that much ;-)
05:49:04 <Axman6> heh
05:54:20 <muzzle> hi, is there a performance difference between megaparsec and attoparsec?
05:54:56 <muzzle> nvm
05:54:57 <EvanR> isnt megaparsec for generic parsing like parsec is?
05:55:28 <muzzle> attoparsec is faster according to https://github.com/mrkkrp/megaparsec#performance
05:55:41 <EvanR> attoparsec chews through bytes and is optimized for ByteString data
05:56:00 <EvanR> but lacks some more fancy features, like detailed errors
05:56:03 <muzzle> Then it's probably better suited for my purposes
05:56:26 <muzzle> i want to tokenize several dozen million lines of code
05:56:34 <muzzle> so probably i'll use attoparsec
05:56:43 <EvanR> tokenize only?
05:56:53 <muzzle> yeah
05:57:01 <muzzle> and across multiple programming languages
05:57:07 <EvanR> maybe you want a lexer generator, like uhm... 
05:57:15 <muzzle> alex?
05:57:19 <EvanR> yeah
05:57:40 <muzzle> is there any advantage to using alex over attoparsec?
05:58:14 <EvanR> since its dedicated to lexing i would think its even faster than attoparsec for that purpose
05:59:14 <muzzle> hmm maybe someone has done a comparison before?
05:59:42 <muzzle> I just prefer "the feel" of parser combinators over generators like alex or happy
06:00:03 <EvanR> well yeah
06:14:33 <idev> is there a way to tell ghci that "pattern mathces are not exhaustive" is NOT a warning, but an ERROR ?
06:18:03 <merijn> idev: -Werror ?
06:21:35 <geekosaur> idev, fine control of that is still in the planning stage, for now there's only the -Werror big hammer
06:23:37 * hackagebot solr 0.3.2 - A minimal Solr client library  https://hackage.haskell.org/package/solr-0.3.2 (NikitaVolkov)
06:24:07 <idev> merijn: geekosaur how do I feed that to "cabal repl" ?
06:24:30 <idev> ghc-options: in blah.cabal I think
06:24:30 <dcoutts> idev: --ghc-options=
06:24:57 <idev> yep, it works now; thanks!
06:25:08 <dcoutts> idev: typically you don't want to hard code -Werror into .cabal files (or if you do, you have to guard it with a "dev" flag or similar)
06:28:13 <muzzle> When i use conduit and have something like source $$ a =$= scanl (...) =$= c =$= sink, how do i get at the scanl result?
06:28:37 * hackagebot aeson-value-parser 0.11.3.1 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11.3.1 (NikitaVolkov)
06:35:16 <muzzle> So my question is how do i get conduit result values?
06:35:40 <muzzle> from stuff that is neither a source nor a sink
06:38:37 * hackagebot text-all 0.1.0.0 - Everything Data.Text related in one package  https://hackage.haskell.org/package/text-all-0.1.0.0 (Artyom)
06:43:37 * hackagebot xdcc 1.0.4 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.4 (JanGerlinger)
06:45:38 <phanimahesh> https://github.com/andreyvit/git-subdir~ODODOD   1
06:45:38 <phanimahesh> OBOBOBOBOBOBOBOBOBOBOBOBOBOBOBOB[200~https://github.com/andreyvit/git-subdir
06:45:51 <phanimahesh> oops, sorry.
06:50:28 <maerwald> sounds like an irssi user
06:50:57 <Hafydd> That was a bit ODODOD.
06:53:53 <mgsloan> muzzle: You can't.  Note that (=$=) takes a Conduit which has () for the return type
06:54:21 <mgsloan> I suggest hacking it in via IORef if you really need that
06:55:33 <maerwald> dcoutts: yeah, especially since <$> now doesn't need to be explicitly imported in GHC-8/base-4.9, you'll get tons of warnings with -Wall -Werror for code that's supposed to work for GHC-8 and GHC-7.10
06:55:37 <phanimahesh> maerwald: Yep, irssi misbehaved when I was pasting.
06:55:51 <maerwald> I figured, mostly happens to irssi users only
06:55:54 <phanimahesh> How did you identify? Are irssi screwups so common?
06:55:57 <maerwald> yes
06:56:28 <phanimahesh> Oh. :/ I'm getting used to irssi. Tried weechat and chatzilla, didn't like them.
06:56:52 <maerwald> we need to write an IRC client in haskell to fix all that :o
06:57:42 <phanimahesh> Hahahah. Till then, any recommendations? terminal, preferably.
06:58:13 <maerwald> hexchat if you don't mind gtk
06:58:15 * Cale is doing paid work right now basically doing that... only not quite IRC, but another chat service.
06:58:48 <maerwald> pidgin irc works too, but it doesn't properly break long messages, it just cuts them
06:59:05 <evilop> pidgin is horrible at irc though
06:59:15 <muzzle> mgsloan: so there is no way to get results from Data.Conduit.mapAccum ?
06:59:17 <glguy_> <$> doesn't need explicit import in 7.10 either
06:59:23 <phanimahesh> Yep. But otherwise for xmpp I really like pidgin.
06:59:39 <maerwald> glguy_: then that was 7.8 I guess
07:00:02 <c_wraith> especially when you're using on an os that has middle-click paste
07:00:03 <c_wraith> *using irssi on
07:00:06 <phanimahesh> Cale: Looks like everyone is after chat. I was building a chat service, but in elixir and erlang.
07:00:12 <maerwald> I use pidgin irc only because I don't like having muiltiple chat clients
07:01:20 <phanimahesh> I've returned to linux after an year of using mac. And slack was an abomination even on mac, it's unusable on linux.
07:01:53 <phanimahesh> So I need a reliable irc/xmpp client. Looks like pidgin is the only good option. :/
07:02:25 <maerwald> the only major problem there is that it cuts overly long messages you send and doesn't auto-break them
07:02:54 <geekosaur> you can also run some other IRC client and bitlbee (but I suggest running your own, not using their hosted one)
07:02:56 <mfukar> phanimahesh, had you remained on OS X, you could try Textual :(
07:04:09 <ski> c_wraith : hm, does Irssi handle Bracketed Paste mode ? or is it just timing ?
07:04:14 <phanimahesh> The only thing I liked on my macbook was the battery life and light weight. Moving jobs, so handed over old device. Wasn't worth retaining.
07:04:43 <phanimahesh> ski: Weird thing is, paste worked nicely after a restart. Must be timing.
07:06:27 <mgsloan> muzzle: Well, you have that be your sink
07:06:39 <eacameron> Is there a string interpolation lib that doesn't depend on haskell-src-exts and template haskell?
07:06:59 <eacameron> I don't need it to do anything fancy, just put variables in the string.
07:07:16 <muzzle> but from the type signature it doesn't seem to be a sink
07:07:19 <muzzle> mapAccum :: Monad m => (a -> s -> (s, b)) -> s -> ConduitM a b m s 
07:07:40 <muzzle> mgsloan
07:09:10 <mgsloan> "ConduitM i o m r" is only compatible with "Conduit i m o" when "r ~ ()"
07:09:20 <muzzle> because it's different from fold :: Monad m => (b -> a -> b) -> b -> Consumer a m b 
07:09:40 <mgsloan> Source allows (r ~ ())
07:10:20 <mgsloan> Sink is the only synonym that allows you to have r be something other than ()
07:10:33 <mgsloan> (well, Consumer too)
07:10:37 <mgsloan> It's gotta go on the right
07:10:52 <mgsloan> conduit is demand driven, can't have multiple sinks
07:12:07 <mgsloan> Though, ZipSink can help with that, check it out!
07:12:17 <mgsloan> Yeah, I think ZipSink will do the trick
07:12:19 <muzzle> but what if i want to perform two different kinds of fold over the same conduit? would i have to hack that into one fold with a (,) accumulator?
07:13:26 <mgsloan> (ZipSink allows you to feed two sinks from the same Source)
07:15:02 <ski> phanimahesh : i think sometimes if stuff gets hung up a bit, Irssi can misinterpret it
07:16:18 <phanimahesh> possible. Unless it becomes an annoyance, I'll stick with irssi. Sunk cost. :P
07:16:47 <evilop> phanimahesh: there is a script for irssi to make it split long messages
07:17:25 * evilop prefers weechat though
07:17:31 <phanimahesh> the long messages issue was with pidgin.
07:17:47 <phanimahesh> irssi messed up my paste.
07:18:18 <phanimahesh> Weechat wasrecommended to me but I didn't like it as much.
07:19:40 <mauke> evilop: current irssi has that feature built in
07:21:19 <ski> phanimahesh : a terminal-based client has the advantage that you can run it being GNU Screen
07:21:44 <muzzle> mgsloan, thanks for your help. But I still don't quite get why there is fold and mapAccum in Data.Conduit.List. If the output of mapAccum can only ever be used in a sink why don't they remove it from the library?
07:22:03 <Sose> weechat looks cool. I've ~always used irssi though
07:22:20 <phanimahesh> I'm a tmux user, but yep. that and being able to use over ssh
07:22:40 * ski nods
07:22:45 <phanimahesh> And not having to deal with badly designed guis.
07:22:58 <ski> (s/being/behind/)
07:25:50 <mgsloan> muzzle: Because you use sinks with conduits?
07:26:48 <mgsloan> Have you read tutorials about conduit? That might help
07:27:30 * mgsloan is real tired right now, not the best time to try to explain 
07:49:04 <shirt> How is it possible that pressing "Control C" causes "user interrupt" exception to be thrown on a thread that is not the main thread?
07:49:33 <EvanR> threads can throw exceptions to each other, in a thing called asynchronous exceptions
07:49:50 <EvanR> its bodacious
07:50:05 <sm> control c maybe interrupts the currently running thread ?
07:50:26 <shirt> i fear this may be a bug in ghc
07:50:30 <sm> async is a good library for making sure your main thread knows about it
07:51:12 <EvanR> control C causes SIGINT, which is caught by the runtime and converted into an exception, which you can do stuff with
07:51:17 <cocreature> C-c should always arrive in the main thread afaik
07:51:24 <cocreature> shirt: are you using the ghc api?
07:51:47 <shirt> cocreature: yes i am! that must be it!
07:52:06 <cocreature> shirt: yep ghc does weird stuff to the signal handlers
07:52:21 <shirt> cocreature: i thought it was the networking library doing weird stuff, totally forgot about ghc api
07:52:38 <cocreature> shirt: there is an issue somewhere but I didn’t find a solution the last time I searched
07:52:46 <shirt> cocreature: this is not good :(
07:52:59 <cocreature> hm actually I might have seen something, give me a minute
07:53:29 <cocreature> shirt: try this https://github.com/ezyang/ghc-shake/blob/74641035f85a63f6a78de7812bb2af338e37c96a/GhcShake.hs#L112
07:53:41 <shirt> cocreature: thanks, you've already helped me... i would have spent hours trying to figure this out without even thinking that it might be because of ghc api
07:54:02 <cocreature> shirt: heh, I’ve been in the exact same situation a months ago
07:54:14 <cocreature> +few
07:55:12 <nitrix> data X = X { y :: STRef s Y }
07:55:21 <ski> `s' is unbound
07:55:31 <nitrix> So the only way is to thread s in X's type?
07:55:44 <cocreature> you can also use an existential or a rank n type
07:55:50 <cocreature> the latter is probably more appropiate
07:55:54 <ski> the only sensible way, in this case, presumably
07:55:59 <geekosaur> re control-C: POSIX signals are sent to the currently running thread
07:56:10 <nitrix> cocreature: Would rank-2 be enough? Do you mind a short example?
07:56:26 <cocreature> nitrix: data X = X { y :: forall s. STRef s Y }
07:56:41 <cocreature> nitrix: rank-2 is enough but Rank2Types is just a synonym for RankNTypes these days
07:57:03 <ski> with what cocreature suggested, the action in the `y' field can't use any `STRef's or `STArrays' constructed elsewhere
07:57:07 <ski> (or vice versa)
07:57:37 <ski> cocreature : in fact `PolymorphicComponents' is enough in that case
07:57:42 <nitrix> ski: But the "elsewhere" could?
07:57:46 <Cale> Neither an existential nor a rank-2 type is particularly appropriate for this
07:57:50 <cocreature> ski: oh I didn’t know that exists!
07:58:16 <nitrix> I intend to just store the handle there in that type and use it back later.
07:58:17 <Cale> With the existential, you'll lose the ability to runST any ST action which tries to extract the STRef and use it
07:58:38 <nitrix> Ah, that's no good :x
07:58:51 <ski> cocreature : the state-thread expressed by the `y' field must be independent of other state threads, non-interacting
07:58:52 <Cale> With the polymorphic component, you won't be able to fill the field in at all.
07:59:19 <nitrix> Makes sense.
07:59:22 <ski> Cale : you can fill it in, as long as it's independent
07:59:44 <ski> (but presumably the point here was to have something non-independent ..)
07:59:45 <Cale> Well... where are you going to get an STRef with a polymorphic s?
07:59:57 <ski> oh, sorry, you're right
08:00:19 <ski> (for some reason, i was thinking of `y :: forall s. ST s Y', without explicitly being aware of it)
08:01:35 <c_wraith> I can get you an STRef with an existentially quantified s. does that help? 
08:01:40 <Cale> Whenever you get an STRef from newSTRef or whatever, the STRef you get back isn't actually polymorphic in the choice of s -- it's the same s as the ST s you run the action in.
08:01:57 <cocreature> ski: oh I was too :P
08:01:59 <nitrix> I have a ST state computation, which uses values of type :: X. It also creates as bunch of STRef as it goes and I wanted to put those in the record to re-use them later.
08:02:08 <Cale> c_wraith: That's the other case I mentioned, and what happens is you can't runST anything that uses it when you get the STRef out again
08:02:41 <c_wraith> Cale, I know. it's an important case in the soundness of runST 
08:02:45 <nitrix> I'm still on my quest of finding an elegant way to solve relational data without ID systems and lookup tables.
08:02:47 <Cale> Basically, if you build data structures which contain STRefs, in order to be useful, they must also have an s type parameter.
08:03:37 <c_wraith> nitrix, have you looked into edwardk's work with discriminators on relational data? 
08:03:41 * hackagebot safe-access 0.3.0.0 - A simple environment to control access to data  https://hackage.haskell.org/package/safe-access-0.3.0.0 (thoferon)
08:04:03 <ski> Cale : it would be nice to be able to have local data type declarations, ior modules parameterized by types
08:04:34 <nitrix> I wonder if that could be a good use of type synonyms/alias, type GuildRef = STRef GuildState Guild
08:04:37 <Wizziee> Hi, I have a function: `digits :: Integer -> [Int]`   `digits = map digitToInt . show `. However I want it to work both on Integer and on Int. I tried to change Integer to Num, but Num doesn't subclass Show
08:04:48 <nitrix> Then you can just do y :: GuildRef or something, without threading the `s` :/
08:04:51 <nitrix> Not sure.
08:04:54 <Cale> nitrix: You also should never plug anything specific in for s
08:04:59 <Cale> :t runST
08:05:00 <nitrix> c_wraith: Link? I'll definitely look.
08:05:00 <lambdabot> (forall s. ST s a) -> a
08:05:07 <mauke> Wizziee: (Integral a, Show a) => a -> [Int]
08:05:17 <Wizziee> @mauke thanks!
08:05:18 <ski> Wizziee : `Num' is not a type, you can't just interchange `Integer' with `Num'
08:05:18 <lambdabot> Unknown command, try @list
08:05:36 <c_wraith> nitrix, I don't have one offhand. I just know it was a goal of the discriminators package
08:05:38 <Cale> ^^ This means when you give an ST s computation to runST, it has to be polymorphic in the choice of s
08:06:13 <Wizziee> @ski it's a typeclass, yeah? I'm still confused about the terminology, but I get the point ;)
08:06:13 <lambdabot> Maybe you meant: wiki src ask
08:06:39 <Cale> (nevermind the fact that the s parameter is a phantom which is only used to coerce the type system into keeping the stateful computations isolated)
08:06:43 <dolio> Wizziee: Best if you don't prefix stuff with @. That triggers bot commands, and it doesn't do anything on IRC.
08:07:12 <nitrix> Cale: Can't you specialize runST ?
08:07:13 <Wizziee> sorry, I'm used to other chat clients ;)
08:07:21 <Cale> nitrix: In what way?
08:07:24 <ski> @type Control.Monad.ST.stToIO
08:07:26 <lambdabot> ST RealWorld a -> IO a
08:07:36 <glguy> nitrix: An STRef with a fixed 's' is an IORef
08:07:42 <ski> Wizziee : yes, a type class
08:07:51 <Cale> nitrix: There's stToIO, but that's not a specialisation of runST
08:08:00 <nitrix> Cale: Really this reference (if I was to store it in the record as `STRef GuildState Guild` is only going to be used inside some GuildState computation.
08:08:19 <Cale> I think you're misinterpreting what the s type parameter on STRef is
08:08:31 <nitrix> Very likely. STRef confuses the hell out of me.
08:08:34 <Cale> It *never* gets filled in
08:08:36 <Cale> ever
08:09:01 <Cale> If you want, you can pretend that the implementation of runST fills it in with something concrete that it gets to choose and you don't get to see
08:09:02 <ski> Wizziee : prefixing nicknames with `@' isn't IRC custom, right. just mention the nickname as the first thing in the message, if you want to specifically address somebody
08:09:06 <Cale> i.e. the type of the heap
08:09:13 <geekosaur> nitrix, the whole point of "s" is that it's an impossible value that can never exist; this prevents you from either mixing runST computations or leaking internal details of them
08:09:36 <nitrix> Mhhh.
08:09:40 <ski> Wizziee : many IRC clients can highlight a user when their nickname is mentioned. but often they only do it if its the first thing in the message
08:09:41 <geekosaur> that "mixing runST computations" part means you can't do what you seem to be trying to do
08:09:55 <Cale> If you pick a specific s, runST will refuse to run your computation
08:10:02 <Cale> :t runST
08:10:03 <lambdabot> (forall s. ST s a) -> a
08:10:09 <Cale> ^^ the argument type is polymorphic
08:10:36 <nitrix> geekosaur: I just want a mechanism like IORef that lets me an actual reference to something while not falling back to IO. Surely there's a way to do that purely.
08:10:43 * ski idly wonders whether nitrix would like to use an `s' that is a "subtype" of `RealWorld'
08:10:45 <bbear> hello
08:10:45 <nitrix> *create.
08:10:57 <geekosaur> both those restrictions are key to ensuring that runST can be used to do impure computations without letting the impurity escape
08:10:59 <davidkart> hello
08:11:13 <davidkart> is haskell a good language ?
08:11:15 <c_wraith> nitrix, um. that would violate referential transparency. 
08:11:20 <geekosaur> and no, there isn't, and should not be
08:11:29 <Cale> Well, runST kind of does
08:11:39 <glguy> nitrix: What's the problem you're solving by omitting the s parameter from your type?
08:11:42 <ski> nitrix : each use of `runST' creates a separate State Thread (that's what `ST' stands for), whose state parts can intercommunicate, but which is independent from other state threads
08:11:52 <geekosaur> runST lets you do it but only on the condition that it never escape that specific computation
08:11:55 <Cale> But all the uses of the reference have to occur inside the computation which is the argument to runST, and they can't escape
08:12:21 <ski> davidkart : yes. next question ?
08:12:23 <nitrix> Cale: But what if the computation is prolonged, for the entire duration of the program?
08:12:24 <geekosaur> you cannot save them and pass them to other ST computations; that *must* be done in IO only
08:12:30 <Cale> note that the use of thread there might be misleading though, in that it has nothing to do with threads in the sense of concurrency
08:12:44 <davidkart> how many time do I need to learn thoroughly through it ?
08:12:53 <davidkart> is 2 months enough ?
08:13:03 <Cale> nitrix: That's possible, but that means your program is going to compute a single result and never do any IO for its whole lifetime
08:13:12 <nitrix> Everywhere the STRef is used would need to be in that ST computation, but I'm trying to have an ST that lives for the whole duration of the program and arbitrarily have STRef handles in records.
08:13:20 <ski> nitrix : then there has to be a single `runST' that runs for the entire duration of the program (or `stToIO' is used)
08:13:33 <nitrix> Right.
08:13:46 <c_wraith> davidkart, you can be productive at 2 months, but only at a middle level. There's just so much to learn... 
08:13:47 <Wizziee> http://lpaste.net/5552398445978845184 Why I get this error? Anybody? ;)
08:13:51 <Cale> nitrix: You can't do user-visible input/output in ST, only manipulate memory cells that you create.
08:13:57 <nitrix> Which is fine because the IO is already separated from ST at this point in myp program.
08:14:10 <nitrix> Cale: That'd still be perfect.
08:14:13 <mauke> Wizziee: ( ( )
08:14:21 <ski> nitrix : `stToIO' can be used to ensure that portions of your program can interact with state, but can't do I/O, while other parts that can do I/O can be interleaved with them
08:14:23 <Cale> nitrix: What sort of program is it?
08:14:23 <c_wraith> nitrix, OK, then, put an s type parameter on your data structures 
08:14:49 <Cale> nitrix: and what does the big ST action compute?
08:15:06 <Wizziee> mauke: oh, thanks, I must be blind or something ;>
08:15:17 <nitrix> Cale: A new game state in my case presumably.
08:16:03 * ski assumes Cale means the action that is passed to `runST'
08:16:08 <nitrix> It'd use the STRefs to resolve "references" on the current game state (so we're still referentially transparent).
08:16:18 <Cale> Ah, so you're going to compute the state for one frame from the previous, then throw out all the data structures and start over for the following frame?
08:16:25 * ski nods :)
08:17:34 <nitrix> Cale: Mhhh, the data structures are in that state.
08:17:46 <c_wraith> hmm.. this sounds like a case for, uh.. whatever that thing was that edwardk was trying to steal from clojure.. transients? 
08:17:54 <nitrix> My goal with the STRefs is to have references to create relations in the data of the current state.
08:17:56 <ski> davidkart : how long did it take you to learn programming from scratch, to be productive ?
08:18:09 <davidkart> ski: seriously ? 
08:18:15 <Jinxit> c_wraith: transducers?
08:18:22 <Cale> nitrix: I'm not sure what you mean by relations
08:18:23 <davidkart> ski : I learned BASIC in 3 days I was 11 years old.
08:18:28 <c_wraith> Jinxit, nah. something else. 
08:18:29 <ski> davidkart : have you learned another functional programming language before ?
08:18:34 <nitrix> Cale: Consider a game where players belongs to a guild.
08:18:57 <ski> davidkart : if not, expect that it will take longer to learn your first functional programming language, than it will to learn yet another imperative one
08:19:01 <davidkart> ski, no, nope
08:19:02 <nitrix> Cale: surely you can copy the guild info in each players, GHC would share the pointer, but then changing the guild implies updating all the player instances.
08:19:10 <davidkart> ski: Yes I know
08:19:17 <nitrix> Cale: So instead, you store a guild ID in the player and lookup a relation table everytime.
08:19:20 <c_wraith> davidkart, I understand your position. haskell was a surprise to me because it's actually different. it took time to learn. 
08:19:23 <davidkart> I know it is difficult but I wanted to know « how difficult »
08:19:25 <Cale> nitrix: sure
08:19:31 <nitrix> Cale: Where in C, it'd just be a pointer / or reference in C++.
08:19:39 <geekosaur> Wizziee, you're missing a close parenthesis on line 4
08:20:11 <Wizziee> geekosaur: yeah, mauke already helped me with that, but thanks ;)
08:20:20 <geekosaur> srry, missed that
08:20:21 <c_wraith> Jinxit, I think transients.. the thing that give you a mutable structure that you can freeze into a copy on write structure. 
08:20:40 <nitrix> Cale: That, is what I'm trying to solve. Clearly there has to be a way to get those relation as some kind of O(1) references while not breaking referential transparency, since everything the references needs is the current state of the game.
08:21:04 <Cale> There is, but immutable cyclic structures are indistinguishable from infinite ones, so that tends to be awkward
08:21:14 <nitrix> Probably some State and ST transformers, STT maybe.
08:21:42 <Cale> There's no STT
08:21:43 <nitrix> I'll just work on a prototype, see if I can figure it out :/
08:21:55 <nitrix> Cale: https://hackage.haskell.org/package/STMonadTrans-0.3.3/docs/Control-Monad-ST-Trans.html ?
08:21:59 <cocreature> Cale: yep it was transients https://github.com/ekmett/transients
08:23:08 <cocreature> eh ^ c_wraith 
08:23:32 <c_wraith> is the package in a usable state? 
08:23:45 <Cale> nitrix: Oh... that's... very evil
08:24:04 <cocreature> I have no idea how usable it is
08:24:21 <c_wraith> because I feel like it's exactly what nitrix wants
08:24:30 <c_wraith> if it's usable. :) 
08:24:48 <Cale> In pretty much any case where that thing would be safe, it won't let you do anything you couldn't do by either building a monad over ST or IO instead
08:25:05 <Cale> but in other cases, it lets you build horrible nightmares
08:25:43 <c_wraith> let cthulu = ... 
08:26:25 <Cale> This package should probably be filed under Acme.*
08:27:00 <ski> davidkart : .. i wouldn't have said i learned BASIC in three days, when i was 6.5, but people learn at different speeds, so it's hard to compare, i think
08:27:50 <davidkart> ski: especially because I'm no longer that kid :) Learning process is a bit steeper now...
08:29:13 <c_wraith> davidkart, you're not going to know until you try. and it's not going to be the basics that trip you up. it's going to be things like higher-kinded polymorphism. (that one takes everyone a while) 
08:29:13 <davidkart> yes, and haskell is very different than the imperative language I've known for 20 years
08:29:52 <dolio> I think you could write Haskell equivalents of 3-day-in basic programs in 3 days. But no one would agree that you had "thoroughly learned" it.
08:30:08 <ski> (i assume you've already seen <http://norvig.com/21-days.html>)
08:30:55 <dolio> I'm not sure they'd agree that you had thoroughly learned basic, either, though. Unless basic is very shallow.
08:31:02 <hpc> it's very shallow
08:31:17 <Cale> Depends on which basic you were learning
08:31:39 <hpc> the only basic i can think of that wouldn't be learnable in 3 days is vb.net
08:31:43 <hpc> but only because it has .net attached
08:31:49 * ski was thinking of the kind that was on a programmable calculator with 544 bytes of RAM available for programs
08:31:51 <Cale> But even then, knowing all the syntactic constructions available in some super-simple variant of BASIC isn't really knowing how to write software in it.
08:31:52 <c_wraith> I think I started learning Haskell in 2008. 8 years later... There's still so much to learn. 
08:32:01 <dolio> I'm not sure even old visual basics (like, 5 or 6) are that shallow.
08:32:09 <hpc> i learned TI basic in under an hour
08:32:12 <c_wraith> most basics don't even have dynamic memory allocation. 
08:32:19 <ski> (oh, and BASIC V2.0 which was on the Commodore 64)
08:32:31 <hpc> i had finished a standardized math test when i was 13-ish and had nothing else to do
08:32:33 <hpc> so i wrote pong
08:32:42 <hpc> i had never programmed anything before
08:33:42 <hpc> funny enough, in that time i also learned loop unrolling
08:34:04 <exio4> I "learnt" lots of languages as a kid, when I saw the code after 4-5 years I couldn't think of a way to end with such AWFUL code again :P 
08:34:25 <hpc> i duplicated the main loop logic 3 times, so it would go faster
08:34:57 <exio4> I did things in overcomplicated ways, things which would be some nested ifs, were done using 5 functions and global variables to do.. god knows what :P 
08:35:07 <hpc> somehow i knew that would work, though it was probably just because the loops were extra lines
08:36:26 <Boomerang> Did you also make your variable names shorter so they would be parsed faster? :p
08:36:55 <hpc> iirc you had a fixed amount of variables
08:36:56 <c_wraith> also, put your code on fewer lines to parse fewer line numbers. 
08:37:09 <hpc> A-Z, and if you really needed more memory you'd use theta and n
08:38:20 <hpc> function calls didn't exist either
08:38:36 <hpc> i wrote another game later that had to use some repeated code, and typing it out was a huge pain
08:38:39 <c_wraith> gosub was basically the same thing 
08:38:44 * hackagebot statistics 0.13.3.0 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.13.3.0 (AlexeyKhudyakov)
08:38:52 <hpc> so i noticed a program could call another program and return
08:38:58 <c_wraith> except for the issue about not having its own variable scope. 
08:39:14 <hpc> so i had game, game1, game2, game3, ... and all but the first were function calls
08:39:42 <hpc> in retrospect i could have used gotos, but i might have run out of labels at that point too
08:39:53 <hpc> i don't remember if those were single-character too
08:40:22 <c_wraith> gosub instead of goto, if you needed to return to the caller. 
08:40:49 <c_wraith> when I was 6, gosub confused the heck out of me. why would I need that? 
08:41:27 <hpc> i had also figured out things like fill rates, to a very primitive extent
08:41:46 <hpc> drawing larger moving objects was extremely slow, but if i only changed the pixels at the edge when the object moved, it worked much faster
08:42:11 <dolio> I guess VB really is much more complex.
08:42:23 <c_wraith> it is. 
09:03:45 * hackagebot sproxy-web 0.3.1 - Web interface to sproxy database  https://hackage.haskell.org/package/sproxy-web-0.3.1 (ip1981)
09:04:40 <hpc> i hear using a sproxy can interfere with the functionality of websprockets
09:50:33 <guest345> ernet connection to "stack new <project>" so that it can download the template. Is there any setting that I can change to make sure that it works offline too? If I have used that template before, why should it download it again?
09:52:18 <MichaelBurge> guest345: You can use a local stackage repository, I believe.
09:52:47 <MichaelBurge> although that might be only for the packages themselves
09:53:32 <mgsloan> guest345: Known issue, tracked by https://github.com/commercialhaskell/stack/issues/1595
09:53:34 <MichaelBurge> I think stack by default is supposed to cache the packages in your home directory, so if it's not that I wonder what it's downloading
09:53:37 <guest345> MichaelBurge: this is not at the repository stage. In fact, if I had downloaded a package for another project, stack does not seem to re-install it....but when I start a new package with "stack new" it insists on downloading the template ech time
09:53:56 <guest345> It is merely downloading the template
09:54:18 <guest345> mgsloan: thanks!
09:55:27 <guest345> mgsloan: so this problem has not been resolved yet and there is no workaround? 
09:56:46 <c_wraith> you could work around it with a local caching proxy. I don't know if it's worth the effort. 
09:56:48 <mgsloan> You can manually download a template and indicate it by name
09:56:56 <mgsloan> Yeah, or a cache
09:57:40 <mgsloan> cblp recently wrote something for this stuff https://github.com/cblp/stack-offline
09:57:56 <mgsloan> I was a little surprised this would be a separate project - discussion here https://github.com/commercialhaskell/stack/issues/2224
09:58:30 <mgsloan> Basically, stack is still young, and templates are a tertiary feature, so there are rough corners there
10:06:00 <guest345>  Thanks. I just looked at stack-offline as you suggested, but I am not sure if I have correctly understood its usage as described on the git page. Do I simply do `stack-offline new <project name>` ?
10:14:46 <mgsloan> guest345: I have no idea, it is a work in progress project I just heard about very recently
10:15:05 <guest345> I see. Thanks a lot!
10:16:05 <maerwald> erm, where is the Pretty module defined, I cannot find it
10:21:39 <guest345> I am sorry if this is a very stupid question, but I only recently began to use stack. I do not really need to use "stack new" right? I can manually create the folder, then do a cabal init, and thereafter a stack init to take make the stack.yaml file?
10:22:42 <maerwald> it seems Pretty is part of ghc, but it's nowhere to be found on hackage
10:23:09 <kadoban> guest345: Sure, though that's likely more work in general. But yes, 'stack new' is just a convenience thing.
10:23:10 <guest345> I can manually create the app directory too right?
10:23:48 * hackagebot parconc-examples 0.4.1 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4.1 (SimonMarlow)
10:25:30 <guest345> kadoban: thanks! And is it true that if I am using the same version of a library (as a dependency) from the same snapshot that I used in another project, then stack does not need to download anything and therefore will build offline?
10:25:58 <guest345> Assuming that I had already downloaded that for another project
10:26:21 <kadoban> guest345: In the common case it'll reuse the already built stuff, yeah. There may be rare cases where it can't do that, so I don't want to say 100% yes, but usually yes.
10:26:47 <guest345> kabodan: I see...thanks! 
10:28:48 * hackagebot parconc-examples 0.4.2 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4.2 (SimonMarlow)
10:29:28 <nmdanny> @pl
10:29:29 <lambdabot> (line 1, column 1):
10:29:29 <lambdabot> unexpected end of input
10:29:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:30:09 <nmdanny> @pl  lookupSetting env def = do { mbEnv <- lookupEnv env ; return $ fromMaybe def $ mbEnv >>= readMay }
10:30:10 <lambdabot> (line 1, column 28):
10:30:10 <lambdabot> unexpected '{'
10:30:10 <lambdabot> expecting variable, "(", operator or end of input
10:33:46 <glguy> nmdanny: You can play with lambdabot in /msg
10:35:08 <gabre> hey
10:35:52 <gabre> I have a HUnit test with one test case but if I call cabal test no test cases are run. Could you help me?
10:36:07 <gabre> http://pastebin.com/sEPpkewb this one
10:39:57 <sm> gabre: have you declared the test suite in your cabal file ?
10:40:15 <gabre> yes, I have a test suite part there
10:40:33 <gabre> and I get the following output for cabal test: 1 of 1 test suites (1 of 1 test cases) passed.
10:40:45 <gabre> but in the test log I have 0 passed 0 failed
10:42:21 <sm> odd, repaste the test file and cabal section, if you like
10:42:49 <gabre> okay
10:43:49 * hackagebot parconc-examples 0.4.3 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4.3 (SimonMarlow)
10:44:32 <gabre> look
10:44:34 <gabre> http://pastebin.com/9XWZAqvy
10:50:47 <gabre> any help is welcome because I have no idea what s going on here
10:52:11 <kadoban> gabre: Make sure you're looking at the correct .hs file and etc? I dunno really.
10:52:44 <sm> gabre: I also use test-framework, but I pass the hunit tests through hUnitTestToTests - maybe you need that ?
10:53:22 <gabre> sm: I would like to use cabal test as it would be a kind of build system
10:53:40 <gabre> sm: but I would be thankful if U showed me how you do that
10:54:22 <gabre> kadoban: I will double (triple) check it
10:54:25 <sm> you can, but try "hunitTestToTests [test1]" at line 13
10:54:38 <sm> (hunitTestToTests [test1])
10:56:05 <sm> or [hunitTestToTests test1], maybe
10:56:33 <sm> https://github.com/simonmichael/hledger/tree/master/hledger-lib is where I do it
10:56:33 <gabre> kadoban: I m sure it is OK
11:01:07 <gabre> main = defaultMainWithOpts (hUnitTestToTests test1) mempty
11:01:09 <gabre> this works
11:01:11 <gabre> thanks sm
11:01:18 <gabre> I have no clue what s the difference
11:01:44 <gabre> as it was well typed
11:01:53 <gabre> I mean the list of Tests
11:03:39 <sm> hunit's Test and test-framework's Test are different, not sure why it type-checked either
11:04:22 <sm> test-framework is fine, but you might also want to compare tasty 
11:07:35 <nmdanny> is there a good way between mapping from Persistent datatypes to normal haskell datatypes, while minimizing rendundancy?
11:07:46 <gabre> may it have type checked correctly cause of the newlines? look at the pastebin
11:09:28 <hpc> nmdanny: pattern matching, though i expect that's what you meant by redundant, because depending on how your code is structured you might be writing a lot of them
11:09:43 <sm> gabre: pretty sure you'll find there's a good explanation if you keep digging
11:10:01 <sm> GHC's typechecker isn't usually confused by whitespace
11:10:18 <hpc> nmdanny: maybe you could write a GADT, like data PersistValue' a where PersistText' :: Text -> PersistValue' Text ...
11:10:45 <hpc> nmdanny: write a convert of some sort, and have fromPersist :: PersistValue' a -> a
11:11:03 <gabre> sm: it wasn't even do notation. btw I don't see the difference between HUnit and TestFramework. Am I using TestFW now?
11:11:43 <hpc> fundamentally sql is rather dynamically typed anyway, so you might have trouble with that approach
11:12:32 <nmdanny> I'm not asking about the technical part of converting, what I'm asking is,
11:12:47 <nmdanny> is there a general pattern or some library for mapping of haskell data types to DB types?
11:14:33 <sm> gabre: you are, see the import Test.Framework.* lines
11:15:27 <gabre> sorry, this is copypaste :)
11:15:43 <gabre> so I used that and defined HUnit tests for it 
11:16:47 <hpc> nmdanny: ah, in that case it just depends on the backend
11:17:05 <sm> have you seen doctest ? That's also quite nice, and simple
11:17:06 <hpc> because in that sense, there's multiple sets of db types
11:17:33 <nmdanny_> ok for example I have a 'User' entity
11:18:04 <nmdanny_> which is pretty close to a native haskell datatype, but there are some annoying things with it
11:19:02 <nmdanny_> fo example, I am trying to generate a swagger schema for the haskell datatypes generated by Persistent
11:19:22 <nmdanny_> but it gives me a problem saying that 'Key User' does not have an instance of generic
11:20:07 <nmdanny_> which I guess is because of the persistent type magic that doesnt allow provding such a generic instance..
11:21:21 <nmdanny_> but anyway, in this case I would have to mirror the datatype generated by Persistent with a handwritten one, a datatype that could be easily converted to JSON, or be shown in the swagger docs, or etc etc..
11:21:24 <gabre> sm: no I haven't but I ll have a look
11:21:56 <nmdanny_> so basically every time I transfer from the DB universe to the API universe, I have to convert between the persistent types and my own haskell types
11:22:06 <sm> nmdanny_: being able to do that sounds highly desirable, #yesod or #servant might know how
11:23:18 <nmdanny_> anyway, is there any place with real world servant or yesod example programs/projects?
11:24:26 <nmdanny_> because so far all examples I've found are either missing a database layer, or have a very toy database (like blog,blogpost) and don't cover stuff like authentication
11:24:50 <gabre> sm: the only thing I do not get how it compiled before
11:24:55 <sm> nmdanny_: the source for haskellers.com would probably be a good one
11:25:56 <sm> gabre: if you want to find out, look at the types of those pieces in GHCI
11:26:06 <sm> that may help
11:27:45 <jacco> how can I get cabal to tell me where a dependency came from? (its reverse dependency ancestors). Some transitive dependency causes a conflict
11:28:04 <Welkin> nmdanny_: yeah, I had to figure out the auth stuff myself
11:28:05 <bergmark> jacco: -v2
11:28:29 <Welkin> I made a custom auth module based on the email auth one from snoyman
11:28:51 <freeman42-m> jacco https://github.com/ambiata/mafia/blob/master/README.md
11:31:12 <jacco> bergmark, it doesn't give me any new information (it's haddock-api, and cabal calls it a user goal, although it's not a direct dependency nor the package I'm trying to build)
11:31:30 <sm> freeman42-m: best README image ever :)
11:31:54 <nmdanny_> does anyone know of full blown servant example projects? projects that have authentication, authorization, slightly more complex datatypes and database joins, etc?
11:32:00 <sm> make this cabal's new logo, and gain users
11:35:44 <Welkin> nmdanny_: all of the database stuff is donw through something like Persistent
11:35:49 <Welkin> servant ha nothing bult-in
11:35:59 <Welkin> it doesn't have authorization built in either
11:36:08 <Welkin> it only has http basic authentication
11:36:38 <nmdanny_> I know, im looking for an example project that utilizes multiple libraries
11:37:46 <nmdanny_> or an example of using oauth with servant if its even possible
11:41:03 <ph88> how can i use the Text type from Data.Text ?
11:41:53 <muesli4> ph88: How do you want to use it? :D
11:41:58 <ph88> sorry issue was resolved, ignore
11:42:09 <ph88> muesli4, i like to use it to carve my chicken
11:42:16 <ph88> hungry
11:42:53 <ph88> behold, the first output of my glorious parser:  Right (CC [CI_Library (LC "LIBRARY" (LNL [LN (IBasic "ieee")]))])
11:43:04 <Zemyla> If I'm installing Haskell Platform 8.0.1, I should uninstall 7.10 and delete any previous sandbox, right?
11:43:18 <muesli4> ph88: *thumbs down*
11:43:28 <ph88> thought haskell platform was discontinued
11:44:23 <Zemyla> ph88: No, 8.0.1 came out just recently.
11:45:15 <hexagoxel> jacco: -v3
11:46:00 <hexagoxel> jacco: that ends with a listing of "package - reason" at least after successfully finding a plan..
11:46:11 <hexagoxel> (-v2 does not)
11:48:12 <jacco> The problem is that it can't find a plan :) This is what I'm getting and I'm wondering where the haddock dependency comes from: rejecting: haddock-api-2.16.1/installed-ENz... (conflict:Cabal==1.24.0.0/installed-9cq..., haddock-api =>Cabal==1.22.5.0/installed-9ea...)
11:50:13 <hexagoxel> jacco: it does not improve the asymptotic complexity of manually searching the dependency tree, but you can work from both ends with http://packdeps.haskellers.com/reverse/haddock-api
11:56:04 <jacco> hexagoxel, thanks :)
11:57:27 <jacco> also, could somebody help rationalize this cabal conflict? (rejecting: haddock-api-2.16.1/installed-ENz... conflict:Cabal==1.24.0.0/installed-9cq..., haddock-api =>Cabal==1.22.5.0/installed-9ea...)
11:57:45 <jacco> when I look at the dependencies of haddock-api, there is no upperbound on Cabal
12:00:44 <dolio> It looks like it's talking about installed packages? So your installed haddock-api package was built against cabal 1.22.5.0?
12:21:31 <Benzi-Junior> Hey, I need a data type that contains keyboard configuration data so I have 4 rows containing 12 12 11 and 10 buttons each, is there a better way to lay the data definition out than to have it be just massive tuples ?
12:23:31 <kadoban> What kind of keyboard has 12 12 11 10 buttons? That's not even close to mine.
12:23:54 * hackagebot hylogen 0.1.2.2 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.2.2 (sleexyz)
12:25:30 <monochrom> a [12,12,11,10] kind of keyboard :)
12:26:01 <monochrom> I would use Data.Map
12:26:32 <Benzi-Junior> kadoban: well if you only look at the character keys
12:26:56 <Benzi-Junior> kadoban: the first one should be 13 though because of tilde
12:27:07 <monochrom> I would experiment with using type-level literals to declare the constants 12, 12, 11, 10 at the type level, but I wouldn't go out of my way to make it work.
12:27:44 <kadoban> Benzi-Junior: Still pretty far from matching any I've seen. But okay, what operations do you need to do really? Like what kind of knowledge do you need to get out of it?
12:28:51 <Benzi-Junior> kadoban: http://www.charvolant.org/~doug/xkb/html/img3.png 
12:29:03 <geekosaur> kadoban, mine is 13-13-11-10 if I pretend keys like tab and backspace and enter aren't characters (they are, just not printing characters)
12:29:20 <Benzi-Junior> kadoban: well each key contains 4 Char values
12:29:23 <geekosaur> and the second 12 makes me think Benzi-Junior missed \|
12:30:37 <Benzi-Junior> ;,.pyfgcrl/@  nope thats 12 characters
12:31:28 <kadoban> Is that like weird dvorak?
12:31:32 <dolio> geekosaur: Maybe only square buttons count.
12:32:11 <Benzi-Junior> dolio: in this case yes ... well at least first draft
12:32:38 <geekosaur> dolio, that assumption was why I asked about \| (which is <BKSL> in the xkb image they linked)
12:33:25 <monochrom> what is a button? we just don't know.
12:33:53 <monochrom> but my shirts have disc buttons :)
12:34:13 * geekosaur went low-rent and used what the xlib api gave him instead of something structured at http://lpaste.net/68445
12:34:24 <geekosaur> but it's using the old api, not xkb
12:36:01 <hsk3> Can I rely on Stackage Nightly? https://www.stackage.org/snapshots
12:36:09 <hsk3> ghc 8 is currently only in nightly
12:36:12 <hsk3> i want ghc 8
12:36:22 <ph88> hey guys, im using attoparsec and i'm trying to parse a string in between two backslashes, but the string itself may contain backslashes which must be escaped with a backslash. For example   \ap\\ple\  for string "ap\ple"   how can i detect the double backslashes? right now my parser also consumes the closing backslash which is not good
12:37:16 <Benzi-Junior> monochrom: data Button = Key Char Char Char Char
12:37:20 <geekosaur> rely on how? the packages should be known to work together, just the package set you get today might not be the same versions you will get tomorrow
12:37:28 <Cale> ph88: Is there a notFollowedBy combinator in whatever parser combinator library you're using?
12:37:36 <Cale> oh, attoparsec
12:37:39 <Cale> There probably is
12:37:46 <ph88> oh ok
12:38:39 <Cale> oh, apparently not...
12:38:47 <Cale> But there is lookAhead...
12:39:42 <ph88> so i should make an exception for the \ character ?
12:41:18 * geekosaur would do that as (char '\\' *> char '\\') <|> anyChar
12:41:52 <geekosaur> well, not exactly, you'd like it to end :)
12:42:22 <ph88> this is my code  https://paste.fedoraproject.org/373868/48965031/
12:42:45 <ph88> what's  *>   ?
12:43:08 <Welkin> <*> that ignore the left-hand result
12:43:11 <geekosaur> run two parsers in order, return the result of the second
12:43:46 <ph88> oh is it like the next statement in a do block ?
12:44:00 <geekosaur> think the Applicative version of that, yes
12:44:04 <ph88> ah ok
12:44:46 <ph88> on which function should i apply this?  the character origin is in  otherSpecialCharacter   but the surrounding backslashes are in   extendedIdentifier
12:47:26 <hsk3> Can I rely on Stackage Nightly? https://www.stackage.org/snapshots
12:47:27 <hsk3> Only nightly has GHC 8, and I want GHC 8
12:47:29 <geekosaur> graphicCharacter = (char '\\' *> char '\\') <|> (char '\\' *> fail) <|> anyChar -- I think
12:47:37 <geekosaur> [02 19:36] <geekosaur> rely on how? the packages should be known to work together, just the package set you get today might not be the same versions you will get tomorrow
12:47:48 <hsk3> oh sorry, just saw your reply geeko
12:47:49 <geekosaur> hsk3 ^^ since you missed it the first time
12:48:11 <hsk3> geekosaur: ok, so even nighly snapshots can be replied on for production?
12:48:34 <geekosaur> hsk3, *I* wouldnt but I have a conservative view of production compared to many web devs...
12:49:02 <hsk3> but isn't it pretty much safe to say that if my program compiles using a nightly snapshot, it's pretty much solid
12:49:15 <hsk3> in the sense that if there are problems, i'll catch them at compile time
12:49:41 <geekosaur> reasonably, assuming some package in the nightly doesn't change incompatibly at some point. (which is why you'd use lts, but as noted there is no lts for 8.0.1 yet)
12:49:57 <geekosaur> but yes, you should be reasonably safe otherwise
12:50:41 <geekosaur> ph88, one thing I'd be wary of is I mixed a monadic "fail" in the way monadic parsers use it into an Applicative series, which is kinda bad. so maybe I should provide the Monad version...
12:51:05 <geekosaur> graphicCharacter = (char '\\' >> char '\\') <|> (char '\\' >> fail) <|> anyChar -- should be reasonably the same
12:51:31 <hsk3> geekosaur: ah ok! so "stack build" today is not the same as "stack build" tomorrow and things could break if I have nightly. But if I have LTS, "stack build" will stay the same. Is that about right?
12:51:46 <geekosaur> yes, that's what "long term support" means
12:51:54 <hsk3> thank you
12:51:59 <hsk3> nice
12:52:19 <geekosaur> nightly guarantees the packages all work together but can promise nothing about your program's use of them. lts gives you a stable api target
12:52:52 <geekosaur> but ghc 8.0.1 is new enough that stable api target isn't to be expected for another month or so at least
12:52:54 <ph88> geekosaur, error  Probable cause: ‘fail’ is applied to too few arguments
12:53:04 <geekosaur> oh right, it wants a message
12:53:15 <geekosaur> but hre we don't care as it's just to make the many1 stoo
12:53:17 <geekosaur> *stop
12:53:20 <geekosaur> so fail ""
12:54:01 <geekosaur> actually, hm, I think that consumes the endpoint
12:54:43 <ph88> seems to work well geekosaur 
12:54:46 <geekosaur> graphicCharacter = (char '\\' >> char '\\') <|> (try (char '\\') >> fail "") <|> anyChar -- I thinl
12:54:53 <ph88> why did you chance *> to >>  ?
12:55:13 <geekosaur> because fail is from Monad, not Applicative. I think in this case it doesn't matter, but I prefer to stick to one or the other
12:55:33 <ph88> how to make an applicative fail ?
12:55:34 <geekosaur> (although <|> is somewhat special. normally it's Applicative but parsec includes one that's Monad)
12:55:37 <geekosaur> you don't
12:56:39 <ph88> geekosaur, what would go wrong without that try ?  let me test it
12:57:01 <geekosaur> I think wuthout that it eats the final \ that I used to make the many1 stop by producing (fail "")
12:57:32 <geekosaur> so the try makes it "back up" after matching it, so it's there for extendedIdentifier
12:57:45 <ph88> works too without  try
12:57:46 <geekosaur> oh, hm, no it woulsn't since it's succeeeding
12:57:59 <geekosaur> if it's not eating it then just take it off
12:58:11 <ph88> ??
12:58:34 <geekosaur> I was trying to ensure the final \ was not consumed, so it'd be there for extendeIdentifier to match
12:58:41 <ph88> ye ok
12:58:41 <geekosaur> but I did it wrong and it's not doing anything anyway
12:58:46 <ph88> ok
12:58:55 * hackagebot hylogen 0.1.2.3 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.2.3 (sleexyz)
12:59:20 <geekosaur> come to think of it, I think many1 has ot handle that itself, so it shouldbe fine
13:00:58 <geekosaur> also re the >> vs. *>, try it with *> and if you get a type error then use >>. I think parsers override fail in such a way that it should work as an Applicative anyway?
13:01:16 <geekosaur> except that in current Haskell "fail" is a method of Monad, not Applicative
13:01:45 <geekosaur> ... but a Monad is an Applicative, and I'm being a trifle fuzzy atm because I just woke from a nap :/
13:01:51 * geekosaur hunts coffee
13:04:41 <ph88> geekosaur, it's giving an extra \ when i test it like this     tp identifier "\\hel\\\\lo\\"
13:06:00 <ph88> first i escape all \ for haskell so \\ of the real string becomes \\\\    but \\ in the real string should just represent a single \
13:06:11 <geekosaur> you're using show, aren't you?
13:06:26 <geekosaur> (perhaps implicitly via `print` or ghci's prompt)
13:06:42 <geekosaur> if its wrapped in quotes then show is inserting a \ so it's a legal string. use putStrLn instead
13:06:59 <geekosaur> > "a\\b"
13:07:00 <lambdabot>  "a\\b"
13:07:07 <Maxdamantus> > fix show
13:07:09 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
13:07:12 <ph88> o_O
13:07:14 <geekosaur> > text "a\\b" -- only in lambdabot
13:07:16 <lambdabot>  a\b
13:07:46 <geekosaur> (`text` there is taking advantage of a wart in a prettyprinting package to evade Show)
13:08:02 <shachaf> @let newtype T = T String
13:08:05 <lambdabot>  Defined.
13:08:07 <shachaf> @let instance Show T where show (T s) = s
13:08:08 <lambdabot>  Defined.
13:08:13 <shachaf> > T "abc"
13:08:15 <lambdabot>  abc
13:08:19 <Maxdamantus> > show $ text "a\\b"
13:08:21 <lambdabot>  "a\\b"
13:08:36 <Maxdamantus> Wouldn't it simply be using `show` there?
13:09:01 <Maxdamantus> it just doesn't add quotes and escape sequences like the `Show Char` show.
13:09:24 <geekosaur> text is producing a String, as Show instances do. it just doesn't escape anything
13:09:33 <geekosaur> since it's already a String, it doesn't get `show` applied to it
13:09:40 <geekosaur> lb's a little weird
13:09:49 <Maxdamantus> No. It's not weird or special.
13:09:51 <acowley> Are there any surviving efforts to separate serialization from display?
13:09:55 <geekosaur> well that's not exactly that
13:09:57 <ph88> tp identifier "\\hel\\\\lo\\" :: Either String Identifier   .. figuring out how to putStrLn only for Right at the moment
13:10:07 <monochrom> "text" is from the Text.PrettyPrint library
13:10:17 <ski> it does get `show' applied to it
13:10:18 <Maxdamantus> When the result of the evaluation is a String, it applies `show`. When the result of the evaluation is a Text, it applies `show`.
13:10:39 <monochrom> @type text
13:10:40 <lambdabot> String -> Doc
13:10:45 <ski> (no exception for `String')
13:10:56 <Maxdamantus> The `show` in `Show Text` just doesn't add escape sequences or quotes.
13:11:10 <ski> ph88 : and for `Left' ?
13:11:56 <ph88> ski, what about left ?
13:12:29 <Maxdamantus> `Show Doc`, rather.
13:12:50 <geekosaur> ph88, putStrLn (either show id (tp identifier "\\hel\\\\lo\\" :: Either String Identifier)) -- written without $, if it's a Left you get quotes and if an Identifier not
13:13:19 <hsk3> Changing only the "resolver" variable in ~/.stack/global-project/stack.yaml
13:13:20 <hsk3> Is this the correct way of changing my default resolver to a nightly snapshot (so I can get GHC 8)?
13:13:41 <geekosaur> it should be, yes
13:13:49 <hsk3> ok thanks
13:14:03 <ph88> geekosaur, https://paste.fedoraproject.org/373885/98412146/
13:14:12 <ski> geekosaur : did you mean `either id show' ?
13:14:18 <geekosaur> probably
13:15:27 <ph88> geekosaur,  IExtended "hel\\lo"
13:15:30 <geekosaur> ski, either show id = show on Left, id on Right? for Either String Identifier where Identifier is the weird backslash stuff being parsed (extended idetifier)
13:16:08 <geekosaur> oh, I see, Identifier has a constructor around it. it's not just a String. you'll need to unwrap it
13:16:12 <ski> geekosaur : "either show id = show on Left, id on Right?" -- yes
13:16:33 <ski> oh, they wanted to `show' the `String' ?
13:17:08 <geekosaur> I wanted to distinguish the String (presumably parse error) from the Identifier (which is the backslash-delimited thing)
13:17:25 <geekosaur> but Identifier has a wrapper constructor apparently
13:18:14 <geekosaur> and yes, getting this right is harder since I don't know the other constructrs (from the above I see IExtended, what others exist?)
13:18:26 <geekosaur> but I was taking a shortcut and it just stopped being short
13:19:37 <geekosaur> extracting just the IExtended case will be more painful
13:20:33 <ph88> well i intend to build a pretty printer too
13:21:08 <ph88> which libraries can help me with that? i'm using attoparsec  and atm i'm looking at this library  https://hackage.haskell.org/package/pretty-1.1.3.3/docs/Text-PrettyPrint.html
13:23:31 <geekosaur> you'd need to write a function Identifier -> Doc and have that render just the IExtended case specially
13:23:47 <geekosaur> if you used Text.PrettyPrint
13:24:52 <ph88> you recommend Text.PrettyPrint ?
13:25:13 <geekosaur> alternately you could use Show but write your own Show instance instead of having ghc derive it; that means boilerplate for all but the IExtended case that you would override
13:25:36 <geekosaur> ...and is considered bad form because Show by convention produces something resembling Haskell code
13:25:55 <geekosaur> (which is why a String gets quotes around it and embedded \s doubled)
13:26:05 <ph88> ok lets not do change show
13:26:34 <Zemyla> I wish PrettyPrint produced Texts instead of Strings.
13:26:36 <geekosaur> I said it only because you said you were looking at it. there's a number of prettyprinter packages on hackage, I have not looked deeply enough to prefer one
13:27:04 <ph88> oh ok
13:27:13 <ph88> i already found a bunch of them ye .. not sure which one to take
13:28:56 * hackagebot ghc-exactprint 0.5.1.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.1.0 (AlanZimmerman)
13:34:13 <alanz> does hackage build docs at the moment? Or do we still have to upload them?
13:34:49 <glguy> It builds them
13:35:03 <maerwald> if you are lucky
13:35:18 <maerwald> sometimes it doesn't
13:35:25 <glguy> It builds them. If your package can't be built by the buildbot you won't get docs
13:36:02 <maerwald> sometimes the buildbot does not build your package
13:36:50 <glguy> in those cases the maintainer can click the button to reschedule docs
13:37:30 <maerwald> where is that button?
13:37:53 <glguy> In the "Maintainer's corner" section at the bottom of the contents page
13:38:35 <maerwald> I only see "edit package information"
13:38:47 <glguy> yeah, go in there and keep reading, there's a whole section on documetnation
13:43:30 <hsk3> GHC 8 adds the Strict extension. Should I (1) use it sparingly, or (2) just try it and if my code runs faster continue using it?
13:43:30 <hsk3> Are there any caveats to option (2)?
13:43:46 <hsk3> in (2), I'm talking about particular modules
13:43:54 <hsk3> (of course)
13:44:08 <dolio> (3)
13:44:26 <glguy> Sorry, there were only 1 or 2
13:45:05 <hsk3> lol
13:48:20 <alanz> glguy, thanks. I will give it some time, and upload if they do not get built
13:50:17 <geekosaur> hsk3, -XStrict breaks a lot of standard functions. I would only use it in specific modules expecting it and knowing which Prelude functions are safe to use
13:51:55 <hsk3> geekosaur: Is this some temporary problem, or will this be a thing going forward---Haskell programmers having to "just know" which particular functions break with Strict, just like they currently have to "just know" which functions are "unsafe" (such as head, which crashes for []).
13:52:42 <geekosaur> hsk3, Haskell is a lazy language and the Prelude knows it. -XStrict *will* break the pervasive assumption of laziness. This is not a bug
13:53:24 <geekosaur> it is not there for you to toss in to see if it speeds things up, it's there for specific use cases
13:53:45 <hsk3> ok, well put
13:53:47 <hsk3> good to know
13:53:48 <hsk3> thanks
13:53:58 <ski> (it could just as well slow things down. perhaps infinitely much)
13:54:08 <dolio> I think you should just not use it.
13:54:28 <geekosaur> and now I'm wondering if it needs to be renamed because people have the habit of "this is too slow, make it strict everywhere I can think of" and will think this automates it --- which it does not, it's more extreme than that
13:54:51 <Squarism> hmm.. im writing my first haskell program (some 500 lines now, spread over 5 files).. i do miss beeing able to just write stuff into the console as a tool for debugging + i do miss a debugger
13:54:56 <geekosaur> ("make it strict everywhere I can think of" itself being a terrible idea)
13:55:40 <Squarism> does intellij's haskell plugin support debugging? Mine doesnt seem to do it out of the box
13:56:02 <dedgrant> geekosaur: On a related note, what will -XStrict break even if prelude is not included?
13:57:14 <ski> Squarism : you are using the interactor, yes ?
13:57:27 <Squarism> ski, what is that?
13:57:34 <ski> GHCi, in the case of GHC
13:57:41 <geekosaur> dedgrant, I don't know offhand. I just know there is a lot of code out there that knows that Haskell is lazy and will be in for an unpleasant surprise with -XStrict
13:57:56 <ski> also sometimes known as the "REPL" (Read-Eval-Print Loop)
13:58:26 <Squarism> ski, well yes.. but mostly for testing syntax out.. not to run my programs.. that i do in intellij
13:59:29 <geekosaur> Squarism, note that debuggers are not very useful in general with Haskell code because evaluation doesn't work the way it does in other languages
13:59:46 <magneticduck1> Squarism: uh, ghci is a repl
13:59:46 <magneticduck1> as for debuggers, we don't really use them much in Haskell, but they exist
13:59:56 <ski> Squarism : it's common to use it to test out operations that you define, as you write them, if possible
14:00:43 <dolio> Some debuggers work well. But they haven't been maintained, and instead we have something closer to ordinary debuggers, for some reason.
14:00:58 <Squarism> Geekingfrog, magneticduck1, how do you inspect values during your execution wo modifying all functions to be IO monad dependent?
14:01:43 <Zemyla> Squarism: Generally, people use Debug.Trace, which is technically unsafe, but causes few problems in practice.
14:01:45 <ski> Squarism : also you could check out <https://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html>,<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger>,<https://hackage.haskell.org/package/hood>,<https://hackage.haskell.org/package/hat>
14:01:52 <ski> unfortunately i think
14:01:57 <ski> @where Buddha
14:01:57 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
14:02:09 <ski> has bitrotted
14:02:30 <dolio> Someone was working on hat up until last year.
14:02:32 <Squarism> Zemyla, ski thanks 
14:02:36 <magneticduck1> Squarism: also, unit tests are nice
14:02:37 <dolio> And I think it could do something similar to buddha.
14:02:52 <ski> dolio : oh, that's interesting
14:02:52 <dolio> I haven't tried using hat, though.
14:02:55 <magneticduck1> if your functions are simple and tested, your program is usually bug free! ^^
14:03:02 <dolio> So I don't really know what its status is.
14:03:28 <Squarism> magneticduck1, are there some goto test frameworks?
14:03:32 <ski> Squarism : oh, and you should definitely check out <https://hackage.haskell.org/package/QuickCheck> as well
14:03:45 <acowley> Is anyone here using intero yet?
14:03:52 <magneticduck1> Squarism: quicktest is a bit of a standard
14:04:05 <ski> @hackage HUnit
14:04:05 <lambdabot> http://hackage.haskell.org/package/HUnit
14:04:15 <ski> Squarism : seems to be used a bit, if you like unit testing
14:04:24 <magneticduck1> spoilers: Haskell goes great with unit tests
14:04:30 <davidkart> hello
14:04:43 <davidkart> would you have some hint on how to debug using stder with haskell ?
14:04:48 <ski> (there was some other unit testing package i saw mentioned here recently, that iirc was claimed to have some advantage, but i don't recall the name)
14:04:59 <davidkart> (like printing log, states, etc ?)
14:05:10 <magneticduck1> davidkart: Debug.Trace if it's just for development
14:05:29 <davidkart> so how does it work
14:05:33 <magneticduck1> use a Logger monad{transformer} if you want actual logging
14:05:42 <magneticduck1> er, it just prints stuff when it's evaluated
14:05:50 <ski> hm, perhaps it was <https://github.com/sol/doctest#readme>, not sure
14:06:21 <magneticduck1> oh that's cool, the doctest thing is moving to Haskell
14:06:50 <ski> `hood' might be considered an update of `Debug.Trace'
14:08:15 <ski> s/update/upgrade/
14:12:35 <ph88> can i use hspec together with doctest ?
14:23:35 <maerwald> sure
14:29:17 <sm> Squarism: depends on what you like/need - there's hunit for straight haskell, hspec for an english-like DSL, doctest for ghci tests transplanted into comments, quickcheck/smallcheck for random property-based testing, my own shelltestrunner for command-line testing
14:29:45 <sm> then tasty or test-framework help tie these together
14:30:43 <Squarism> sm, ok.. good to know. I think id prefer to use the one that most in haskell community use then
14:31:21 <Squarism> whick was quicktest?
14:31:40 <sm> there isn't a clear favourite. Of the last two, tasty has been getting more releases lately
14:31:52 <Squarism> oh ok
14:32:41 <sm> I'm quite fond of doctest right now, it's about the easiest
14:33:13 <cocreature> hspec is also fairly popular
14:33:46 <maerwald> what I don't like about doctest is that it relies on the Show instances pretty much
14:33:52 <cocreature> it does a lot of the work that tasty & test-framework do so using them both does not make to much sense
14:34:05 <sm> hspec seems to have nice docs 
14:34:33 <cocreature> it also has hspec-discover which is pretty neat
14:34:38 <sm> maerwald: I haven't used it a *lot*, but it seems you can always doctest without relying on Show instances
14:34:43 <sm> if you need to
14:35:25 <sm> eg >>> Right _ <- runParser (parser <* eof) "blah"  -- parser should succeed
14:36:03 <maerwald> uh?
14:36:10 <sm> uh yourself
14:36:14 <sm> :)
14:36:36 <maerwald> what's the point of doctest if you add non-idiomatic logic to work around its limits?
14:36:48 <maerwald> it will be confusing for the reader
14:37:14 <sm> it's easy and brings a lot of value. You can nitpick if you like.
14:37:37 <maerwald> I don't feel that's nitpicking. doctests should be short and understandable
14:37:51 <maerwald> e.g. perfect fit for the filepath package
14:37:55 <maerwald> ofc they don't use it, lol
14:38:30 <sm> I agree you should use the right tool for the job ("depends on what you like/need")
14:38:51 <maerwald> still annoying when you have to think about whitespaces in listes and tuples and so on, otherwise your tests fail
14:38:58 * hackagebot force-layout 0.4.0.5 - Simple force-directed layout  https://hackage.haskell.org/package/force-layout-0.4.0.5 (BrentYorgey)
14:39:45 <sm> I haven't found it a hassle, maybe because I test in GHCI and then paste, which is great - also the ... wildcard is available
14:43:57 <sm> and.. you can always write any other kind of test in a doctest, right ?
15:03:59 * hackagebot goatee-gtk 0.3.1.1 - A monadic take on a 2,500-year-old board game - GTK+ UI.  https://hackage.haskell.org/package/goatee-gtk-0.3.1.1 (khumba)
15:13:17 <Benzi-Junior> God damn it ... I just realized I've been miscounting the number of keys on my keyboard this entire time
15:13:25 <Benzi-Junior> geekosaur: ^
15:13:33 <geekosaur> heh
15:13:49 <ggVGc> so, I currently have an ADT of actions, and these actions are being generated fairly deep within my program, then on the way "upwards" various functions along the way inspect these actions and act on them. Is this a bad design_
15:13:53 <ggVGc> ?
15:13:59 <ggVGc> It feels wrong having an ADT that are essentially functions
15:14:17 <ggVGc> but if they were not an ADT I couldn't inspect them at multiple levels of evaluation
15:14:24 <ggVGc> but maybe that's a bad idea at the core?
15:14:53 <sm> how about symbols representing abstract actions, rather than functions ? easier to inspect ?
15:15:16 <sm> oh, is that what you said ?
15:15:18 <ggVGc> isn't that what I have?
15:15:19 <ggVGc> yeah
15:15:26 <Squarism> ertes, you there? 
15:15:26 <sm> +1, carry on
15:15:32 <ggVGc> sm: so, I have this, https://gist.github.com/0838c7ef9d8a99ae1c0f0cb1ec9e806b
15:15:49 <ggVGc> and eventually it gets run through "runTransportActions", but before that some other stages of my program also inspect it
15:16:05 <ggVGc> but is this a bad design?
15:16:11 <sm> sounds alright.. are you noticing any problems ?
15:16:20 <ggVGc> no, I just wonder if I'm making a bad design choice
15:16:24 <ggVGc> it seems the most traightforward
15:16:55 <ggVGc> but the fact is that there are actually multiple ways of evaluating these actions, so maybe this is actually correct
15:17:23 <sm> sounds good
15:18:18 <sm> is this the music player using brick
15:18:20 <sm> ?
15:18:32 <ggVGc> whats brick?
15:18:45 <sm> a great text ui widgets lib on top of vty
15:18:45 <ggVGc> it's a midi sequencer/DAW I've been building the past months
15:18:52 <ggVGc> my first real haskell project
15:18:55 <ggVGc> almost 5k lines now :(
15:19:05 <ggVGc> nah, I don't have a UI. It only runs on my midi controllers
15:19:14 <sm> ah, cool. Someone announced a text UI music player today, I thought it might be you
15:19:37 <angular_mike> I've installed network-conduit-tls with cabal from Hackage, but when I try to setup a custom package that depends on it like this `runhaskell Setup.hs configure` I get `Setup.hs: At least the following dependencies are missing:
15:19:37 <angular_mike> 1:15 AM network-conduit-tls -any` Do I need to do something in addition to give access to installed packages?
15:20:00 <ggVGc> sm: my sequencer runs on two of these, and one launchpad(which is very similar) http://produto.mercadolivre.com.br/MLB-705159795-controladora-dj-apc-40-mini-ableton-profissional-lacrada-_JM
15:20:06 <sm> angular_mike: yes, declare it in the custom package's cabal file
15:20:07 <ggVGc> and two keyboards
15:20:34 <sm> ggVGc: nifty.. is that the UI then ?
15:20:37 <angular_mike> sm: it's not mine
15:20:38 <ggVGc> yep
15:21:05 <ggVGc> sm: I've been wanting a music production environment that's actually integrated and use midi controllers full potential for about 7 years. Now I'm finally building it
15:21:08 <ggVGc> but it's been a lot of rwork
15:21:10 <yyyyy> assuming I have a JSON with something like [(A, [B])] where B = B A C and I need to turn it into a [B], but each [B] in the JSON is missing its A, how would you go about it?
15:21:22 <angular_mike> sm: isn't the fact that it's failing a sign that it's already declared?
15:21:30 <angular_mike> :q
15:22:22 <yyyyy> i'm currently simply passing a Default on the B on the inner run, and after getting it back updating with a simple (B → B) function. does this seem OK?
15:22:49 <yyyyy> despite being contained on the parseJSON, this “trickery” seems dirty.
15:22:53 <sm> angular_mike: I don't have the full context, but do you know it's a bit unusual to run Setup.hs directly these days ? usually there's a cabal file and and you run cabal build or stack build
15:23:26 <angular_mike> sm: oh, yes it's there, do I just feed it to cabal?
15:23:52 <sm> I'd try cabal install --only-dependencies [--dry-run]
15:24:08 <sm> then cabal build
15:24:38 <ertes> yyyyy: sorry, but i can't make sense of that…  could you give a concrete example?
15:24:47 <ertes> Squarism: i am
15:25:37 <angular_mike> sm: is it normal to get unrecognized stanza warnings?
15:25:40 <angular_mike> ls
15:26:12 <sm> angular: are you using a very old version of cabal ?
15:26:24 <Squarism> ertes, just wanted to tell you i worked a bit on the game you helped me with starting. Havent gotten near completing it but anyways here it is https://github.com/gurgl/julius-caesar . Just wanted you to know! =D
15:26:25 <jacco> cabal 1.24 includes some new stanza's over 1.22
15:26:29 <angular_mike> https://www.irccloud.com/pastebin/1rE9idLE/
15:27:03 <angular_mike> it looks like 1.22.9 is the latest packaged for my distro
15:27:15 <sm> or building a very new project requiring cabal 1.24, I guess ? otherwise no it's not normal
15:27:25 <jacco> which distro is that?
15:27:34 <angular_mike> arch
15:27:47 <angular_mike> the .cabal file has got this: `cabal-version:       >=1.10`
15:27:48 <ertes> Squarism: nice…  i'm checking it out
15:28:27 <sm> angular_mike: sounds compatible.. maybe the cabal file is bad
15:28:52 <Squarism> ertes, great! Holler if you see any raging noob mistakes =D
15:29:00 <angular_mike> sm: ok, i'll mention it to the dev
15:29:08 <sm> or paste it
15:29:14 <angular_mike> ?
15:29:32 <jacco> angular_mike, you can "cabal install cabal-install" to get 1.24
15:29:40 <sm> if you'd like, paste the cabal file on a paste site so we could take a look 
15:29:43 <angular_mike> sm: you want link to source?
15:30:12 <ertes> Squarism: not necessarily a mistake, but i would go with the 'vector' library rather than 'array'
15:30:17 <angular_mike> sm: https://notabug.org/jazzyeagle/OSM-Server/src/master/osm-server.cabal
15:30:50 <Squarism> ertes, oh ok. Ill check it out
15:31:02 <sm> a lot of music projects today!
15:31:22 <angular_mike> sm: yeah, I'm getting the feeling that haskell is language of choice for the field
15:31:39 <sm> angular_mike: and, can you paste the command & errors you're seeing ?
15:31:48 <ertes> Squarism: your module structure is a bit odd…  it's not necessarily bad, but it pays off to follow a few conventions:  there should be something like a "core" module, and sometimes it's also a good idea to have a module only for types
15:31:56 <ertes> Squarism: Core.hs and/or Types.hs
15:32:04 <ertes> Squarism: that makes navigating a lot easier
15:32:12 <angular_mike> functional => maths => signal processing
15:32:25 <ertes> Squarism: i assumed that Model.hs is your core, but it doesn't seem to be
15:32:56 <angular_mike> https://www.irccloud.com/pastebin/UPGGuLgr/
15:33:25 <Squarism> ertes, ok.. i guess Model.hs is my "Types.hs" .. Board.hs should really be in Model.hs, so that too then 
15:33:41 <ertes> Squarism: next, you have to list all modules in your cabal file for it to be a proper cabal package:  for executables you list extra modules with "other-modules"
15:33:46 <sm> angular_mike: might there be a problem with line endings ?
15:34:00 * hackagebot text-all 0.2.0.0 - Everything Data.Text related in one package  https://hackage.haskell.org/package/text-all-0.2.0.0 (Artyom)
15:34:00 <ertes> Squarism: other-modules: Board Model …
15:34:11 <Squarism> oh ok
15:34:18 <sm> angular_mike: oh.. what's this --config-file option, that looks wrong
15:34:37 <vectorspacealien> Hi, I've got a question about Haskell and speed. I've got a particular application where I need to swap two nodes in a linked list. In C that's just a matter of switching some pointers around. In Haskell, though, I'm mapping an old list to a new list... does that come with any decrease in speed?
15:34:45 <vectorspacealien> I'm not really sure what the final compiled code actually does
15:34:53 <ertes> Squarism: there is an easy way to test whether you forgot something:  do a 'cabal sdist', extract the generated package and see if it builds properly
15:34:57 <vectorspacealien> I also haven't learned how to do this operation in haskell yet :p
15:34:57 <sm> angular_mike: you don't need to specify the cabal file, just be in the directory
15:34:58 <angular_mike> sm: did I pass the .cabal file incorrectly?
15:35:05 <shachaf> vectorspacealien: You'll presumably allocate two new nodes, and eventually GC the old ones.
15:35:10 <angular_mike> sm: any way to do that explicitly?
15:35:36 <ertes> vectorspacealien: there is the speed penalty of traversing the list up to the point where the swap happens
15:35:44 <shachaf> At least, with standard [] lists and the typical operations you'd do on them.
15:35:48 <ph88> how come this search https://hackage.haskell.org/packages/search?terms=pretty doesn't display this package https://hackage.haskell.org/package/pretty-1.1.3.3/docs/Text-PrettyPrint.html  ??
15:35:50 <Squarism> ertes, ill try it right away
15:36:00 <vectorspacealien> ertes: ah, well that's the same as in C in any case.
15:36:01 <shachaf> Oh, if you're not swapping the first two nodes of the list, then you'll allocate more than two, of course.
15:36:25 <lpaste> yyyyy pasted “Nested but carrying parameters” at http://lpaste.net/165114
15:36:25 <sm> angular_mike: I don't see an option for it.. why ?
15:36:38 <angular_mike> sm: I like to have the option
15:36:48 <ertes> vectorspacealien: also the prefix of the list after swapping is a new list and can't be shared, so lists are really not a good idea for that
15:36:55 <ertes> vectorspacealien: you should probably use Data.Sequence
15:37:00 <vectorspacealien> ertes: The application requires repetitively doing this: searching out the first node that matches a condition; updating a number it contains; and swapping it with the previous list.
15:37:05 <yyyyy> ertes: i think this is a good description of the problem. the actual payload has many more fields, but only one gets “carried” further down
15:37:12 <angular_mike> ok, it seems the warning were cause I was passing the .cabal file in a wrong way
15:37:14 <vectorspacealien> ertes: so I have to do the work of finding it first, and then hopefully I wouldn't have to find it again when I swap.
15:37:21 <vectorspacealien> previous *node, not previous list, sorry
15:37:26 <lpaste> yyyyy revised “Nested but carrying parameters”: “Nested but carrying parameters” at http://lpaste.net/165114
15:37:54 <vectorspacealien> @shachaf: yeah it is in the middle of the list. Okay maybe list isn't the thing to use for this
15:37:55 <lambdabot> Unknown command, try @list
15:38:01 <vectorspacealien> oops
15:38:07 <ertes> vectorspacealien: Data.Sequence gives you a sequence type based on finger trees rather than linked lists, which makes almost all operations cheap in terms of space and time
15:38:18 <lpaste> yyyyy revised “Nested but carrying parameters”: “Nested but carrying parameters” at http://lpaste.net/165114
15:38:30 <shachaf> ertes: Cheap if you don't look at the constants. :-)
15:39:24 <sm> ggVGc: looks like a cool project
15:40:00 <ertes> shachaf: if you consider that the prefix is never shared when you "change" a list, then Seq probably has better constants than [] =)
15:40:14 <ertes> at least in space
15:40:20 <shachaf> Oh, I'm not suggesting [] for this operation.
15:40:39 <ertes> there is also ropes, but they require a bit of engineering
15:42:01 <ertes> yyyyy: do you want to flatten the structure?
15:42:31 <yyyyy> ertes: yes, but using only a subset of it
15:43:07 <ertes> yyyyy: i'd first read the information you need, and then flatten in a separate step
15:43:30 <ertes> i.e. get into haskell land first
15:43:59 <Squarism> ertes, what is the purpose of Core.hs? 
15:44:05 <yyyyy> that would entail creating a separate data type only for holding this information temporarily, right?
15:44:09 <Squarism> is that like Main?
15:44:14 <yyyyy> either that or i have to pass around tuples
15:44:29 <ertes> yyyyy: yeah…  or you could also work on the Value type directly
15:45:36 <yyyyy> ertes: the wrapping and unwrapping is a pita in this case. this happens in multiple levels. but i think you shed some light. i'll do it in two passes, using a non-exported data type for this purpose.
15:45:55 <yyyyy> it would be nice if data types could be defined within let or where blocks
15:46:07 <yyyyy> thanks a lot :)
15:46:10 <vectorspacealien> is it okay if I don't know what finger trees are?
15:46:17 <ertes> Squarism: it's the "core" of your project…  core types and a set of primitive functions, or even just the semantics
15:46:21 <ph88> https://hackage.haskell.org/package/mainland-pretty  from the description:  what is there to "track" about the source locations when they are already associated? and why #line pragma's  ?
15:46:22 <vectorspacealien> I mean will I run into problems or unexpected slow operations?
15:46:25 <hpc> finger trees are like regular trees but bite-sized for your enjoyment
15:47:13 <hpc> vectorspacealien: if you mean in the context of Data.Sequence, every operation should have its big O documented in haddock
15:47:21 <ertes> Squarism: it's up to you what the "core" is, but it should be the "core" or the starting point…  a critical point in your module structure that helps navigating it
15:47:25 <vectorspacealien> ah yah I see that now
15:47:57 <ertes> yyyyy: yeah, i do that, too…  or often i just work on Value directly
15:48:22 <ertes> yyyyy: if you're familiar with lenses, there is also lens-aeson, which provides a few very useful traversals
15:48:35 <ertes> it's a real code saver
15:48:49 <Squarism> ertes, ok.. more like the place where the domain logic is done and not where you keep helper functions / "facades" of sorts? 
15:49:30 <ertes> vectorspacealien: finger trees are a structure with O(n * log n) size that give you cheap splitting, appending and element changes, especially at the edges of the sequence
15:50:01 <ertes> vectorspacealien: think of them as efficient functional sequence types
15:50:05 <yyyyy> ertes: i have been typing way to many `fmap . fmap . fmap`s and `traverse . traverse`s to know that i should learn lenses, but i need some time to stop and dive into it. right now i only use it for `view` and `over` and very rarely Prisms, but i don't yet feel able to write down the types to everything on a wall
15:50:09 <hpc> vectorspacealien: if out of curiosity you want to know more anyway, read http://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf or http://andrew.gibiansky.com/blog/haskell/finger-trees/
15:50:25 <hpc> vectorspacealien: the paper is very easy to read, it's basically written in a heavily italicized haskell dialect ;)
15:50:36 <yyyyy> so i'll look into it and hope i can make sense in time for this product delivery :)
15:50:53 <hpc> (at least as far as not having to fight against the structure of academic papers goes)
15:50:56 <ertes> Squarism: yeah…  i generally try to find a minimal core of my project and drop it into Core
15:51:08 <ertes> Squarism: alternatively i formulate abstract semantics and put it into Model
15:51:14 <hpc> the second link uses the same graphics as the paper
15:51:36 <ertes> Squarism: and when there are many types with lots of mutual dependencies, i usually have a Types module, too
15:52:29 <m1k3l1nux> > /quit
15:52:30 <lambdabot>  <hint>:1:1: parse error on input ‘/’
15:52:36 <ertes> Squarism: don't worry about finding the perfect module structure…  you will get a feeling for it over time
15:53:13 <ertes> yyyyy: i'm not a big lens user, but i use traversals a lot
15:53:15 <hpc> > /privmsg #haskell <hint>:1:1: parse error on input ‘/’
15:53:16 <lambdabot>  <hint>:1:1: parse error on input ‘/’
15:53:20 <hpc> my god, it works
15:55:56 <ph88> is this a good package ?  https://hackage.haskell.org/package/mainland-pretty
15:59:29 <Welkin> ph88: are you a size queen?
16:00:58 <glguy> If you don't have anything to contribute to the question it's fine to refrain
16:02:07 <hpc> ph88: i like the idea
16:04:40 <Welkin> glguy: you didn't find it funny?
16:04:59 <ertes> some package types don't need their own category on hackage
16:05:03 <ertes> they really need their own hackage
16:05:11 <ertes> parsers, pretty printers and web frameworks
16:05:13 <glguy> Welkin: No, I find a lot of your comments off-topic like that one
16:05:31 <Koterpillar> glguy: +1
16:06:09 <hpc> i don't mind it, if they're immediately followed up by something useful
16:06:14 <hpc> see also, my finger tree joke earlier
16:06:15 <dolio> It's also inappropriate, in addition to being off topic.
16:06:41 <Koterpillar> I have the following handler: type ServerPart s t = MaybeT (ReaderT URI (StateT s IO)) t. I want to introduce another effect into the stack which _can_ be modelled by another StateT, but ideally has custom operations. Should I go for free or extensible-effects?
16:06:43 * hpc didn't get the joke though
16:07:23 <ertes> Koterpillar: ideally you would reuse the StateT that is already in the stack
16:07:33 <hpc> Koterpillar: make it type ServerPart s t = MaybeT (ReaderT URI (StateT (s, something else) IO)) t
16:08:20 <ggVGc> does this implementation of fromSongPos look correct, if toSongPos is? https://gist.github.com/cf38d802f3990d530bbf0035c8033848
16:08:28 <ertes> Koterpillar: you can narrow your view on the current state type either by writing a small combinator or by using lenses
16:09:20 <Koterpillar> ertes: hpc: Thanks for the suggestion, it'll require rewriting all the dependent code but okay. What if I really want to restrict it to a custom monad?
16:09:48 <ertes> Koterpillar: at some point you should start using an effect system like mtl
16:10:00 <ertes> mtl uses effect classes like MonadState and MonadReader
16:10:27 <ertes> and the MaybeT effect (at least the "throw" part) is modelled by Alternative
16:10:33 <Koterpillar> ertes: I'm using transformers and relying on MonadState and MonadReader
16:10:44 <ertes> those are from mtl, not transformers
16:10:56 <Koterpillar> oh, right, sorry
16:11:05 <yyyyy> ertes: it's one big package to grok, though
16:11:12 <ertes> mtl implements a class-based effect system on top of transformers
16:11:22 <ertes> yyyyy: i agree =)
16:11:59 <ertes> yyyyy: what helped me to understand it was to ignore it and implement van laarhoven lenses myself
16:12:24 <ertes> yyyyy: they have a very small core, and the majority of the lens package is really just convenience functions built on top of them
16:12:40 <Koterpillar> err, lens or mtl?
16:13:00 <ertes> Koterpillar: that was for yyyyy 
16:14:55 <Squarism> classes are only sane to use if you want to define similar logic for many types? 
16:17:12 <Squarism> i have a "data" type called Card, in a certain situation i want to be able to do an ordering of these. Should that be done using class/instance or just as a function?  
16:17:47 <Koterpillar> Eq?
16:18:05 <Koterpillar> ?type cmp
16:18:06 <lambdabot> Not in scope: ‘cmp’
16:18:10 <Koterpillar> ?type compare
16:18:11 <lambdabot> Ord a => a -> a -> Ordering
16:18:16 <Koterpillar> Squarism: ^^
16:18:25 <hpc> classes are more for when you discover a bunch of things have the same API and you're getting sick of writing the same thing over and over
16:18:26 <Squarism> instance Ord Card ... feels wrong as the ordering is situational 
16:18:31 <ertes> Squarism: yeah…  classes define semantics, instances define implementations…  and for ordering there is the predefined Ord class
16:18:36 <Koterpillar> Squarism: depending on what?
16:18:56 <hpc> classes are conspicuously poor for making multiple different types interoperate
16:19:01 <yyyyy> ertes: good tip. i'll set aside next week to get back to basics and do the same before attempting another run at it.
16:19:46 <Squarism> Koterpillar, in a certain situation in my "game" cards determine player order. But in some other situation i might wanna order by something else
16:20:02 <Koterpillar> ?type compare `on` fst
16:20:03 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
16:20:05 <EvanR> playing cards dont have a specific ordering
16:20:15 <EvanR> if any, it depends on the game
16:20:19 <Koterpillar> Squarism: ?type compare `on` even
16:20:20 <ertes> Squarism: i think you're mixing up *what* you are ordering
16:20:24 <EvanR> they might even only have a partial order
16:20:25 <Koterpillar> ?type compare `on` even
16:20:26 <lambdabot> Integral a => a -> a -> Ordering
16:20:28 <ertes> Squarism: players or cards?
16:20:40 <Koterpillar> EvanR: Squarism: are you talking about the same thing?
16:20:56 <EvanR> im talking about cards not players
16:21:19 <EvanR> luckily the sort functions arent fixed to Ord
16:21:27 <ertes> Squarism: Ord doesn't have to correspond to any meaningful ordering…  other than for numbers it's mostly used to build data structures
16:21:34 <Koterpillar> ?type sortBy
16:21:35 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
16:21:35 <monochrom> but Data.Set and Data.Map are fixed to Ord
16:21:48 <Squarism> ertes, true.. i really wanna order on what card players played. So its not Card's i wanna order.. i just used it as an example 
16:22:06 <Squarism> Koterpillar, ill try that compare thingy
16:22:15 <Koterpillar> Squarism: and see sortBy above
16:22:27 <Squarism> ok
16:22:35 <ertes> Squarism: what do you use the ordering for?  sorting?  finding minima?  …?
16:23:16 <Squarism> ertes, card "movement" number + faction who played it.. on ties, Caesar goes before Pompeji
16:23:18 <Squarism> =D
16:24:00 <ertes> Squarism: it's never wrong to write a standalone function…  if you don't have a "don't repeat yourself" kind of reason not to do that, just write a function
16:24:11 <ertes> unless you can map it to any of the predefined classes
16:24:43 <Squarism> ok
16:29:02 * hackagebot sbp2udp 0.0.1 - SBP to UDP  https://hackage.haskell.org/package/sbp2udp-0.0.1 (markfine)
16:29:25 <EvanR> is there a module for controlling the GC
16:29:34 <EvanR> GHC.something
16:32:32 <Tehnix> EvanR: like GC information? There's https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Stats.html - if you want to actually control the GC, then I'v unfortunately no idea
16:33:09 <Tehnix> EvanR: oh, there's System.Mem and `performGC`
16:34:16 <EvanR> ah
16:36:37 <EvanR> that module is pretty cool, it seems to allow a form of CPU time-limit
16:36:50 <EvanR> in the form of an allocation limit
16:37:44 <EvanR> and triggering a major gc after dropping references to a huge data set seems like a win, if you dont want this to happen in the middle of the next interactive part of the program
16:54:52 <Squarism> i wrote this function, i wonder if the ordering part at the end is as good as it gets or if it could be simplified? it feels unnecessary to define "g x y" just to get access to the guards
16:54:54 <Squarism> http://lpaste.net/165121
16:55:37 <simpson> Squarism: case compare m m2 of ...
16:55:47 <Squarism> oh ok
16:55:47 <simpson> :t compare
16:55:48 <lambdabot> Ord a => a -> a -> Ordering
16:56:05 <simpson> And then your cases would be EQ, LT, and GT.
16:56:11 <Koterpillar> why double case?
16:56:19 <simpson> > EQ
16:56:21 <lambdabot>  EQ
16:57:08 <Squarism> Koterpillar, the complete unpacking would be a bit more unreadable i figured
16:57:15 <simpson> I'm guessing that this function has other cases possible for cards that aren't PlainCard.
16:57:49 <Koterpillar> Squarism: use where?
16:58:13 <Koterpillar> if there's only one case, that is
16:58:40 <Squarism> Koterpillar, not sure i understand you now.. could you write a short example?
16:59:58 <Koterpillar> http://lpaste.net/165121
17:00:22 <Koterpillar> oops, sorry, edited yours, thought it'd copy
17:01:19 <Squarism> np
17:01:33 <geekosaur> you wanted annotate
17:01:38 <Squarism> i guess that was more readable
17:04:17 <lambdayak> does anyone know how the language extensions in ghc(i) are implemented?
17:08:33 <lambdayak> magic then? got it.
17:11:46 <geekosaur> which language extensions?
17:12:20 <geekosaur> but implementation questions are probably better for the glasgow-haskell-users mailing list
17:22:10 <lambdayak> OverloadedStrings, but I'm wondering about the possibility of making an extension like it but for chars
17:22:25 <lambdayak> is it reasonable to request such a thing?
17:23:48 <pavonia> Are there many use cases for that?
17:24:31 <lambdayak> probably not, im browsing Data.ByteString looking for the function a want..
17:25:20 <lambdayak> I'd want to maybe map over a ByteString and change one "character" to another
17:25:41 <geekosaur> it's a bit harder for Char because the individual cells of a ByteString or Text are not directly addressable
17:26:25 <hpc> they sort of are, at certain levels of abstraction
17:26:26 <geekosaur> mono-traversable arranges for things to be unpacked and repacked as needed, but it's only viable if things can re-fuse; if not, it's pessimal
17:26:59 <hpc> you can get words from a bytestring, or characters from text
17:27:11 <hpc> but not in a way even remotely amenable to an OverloadedChars extension
17:27:51 <hpc> especially ByteString, for which there is no canonical way to extract character-like elements to begin with
17:28:59 <lambdayak> I just want a simple replaceAll
17:30:28 <lambdayak> i guess it is doable, but i have to workwith word8
17:31:06 <pavonia> If you really know what you are doing, you could use Char8.map
17:34:09 <lambdayak> pavonia: that is what i wanted! thank you
17:39:04 * hackagebot hw-json 0.2.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.2.0.0 (haskellworks)
17:39:06 * hackagebot wikicfp-scraper 0.1.0.2 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.2 (debugito)
17:40:44 <geekosaur> make sure it really is what you wanted though. misusing it can lead to data corruption
17:45:34 <ertes> lambdayak: would you want character literals to be interpreted as Word8?
17:47:03 <Koterpillar> characters don't fit in Word8
17:47:23 <ertes> it's an "are you sure you want that?" kind of question
17:50:10 <hpc> i always liked minecraft's "are you sure" prompt for deleting worlds
17:50:15 <hpc> saying it would be gone forever (a long time)
17:51:44 <hpc> or in this case, sometimes it will break things (and we won't tell you when or how)
17:58:04 <Squarism> lpaste complains. "Warning: Use camelCase" when i have dataTypeName_functionName
17:58:29 <Squarism> i thought that was standard "instance" method naming?
17:58:48 <Koterpillar> AFAIK dataTypeNameFunctionName
18:00:24 <EvanR> instances dont need names
18:00:32 <EvanR> do you mean record fields
18:01:43 <ggVGc> my code sometimes break things, but it never tells me when it's going to
18:02:49 <Squarism> Koterpillar, hmm ok. EvanR yep i guess
18:03:23 <Koterpillar> Squarism: do you need to repeat the type name though? Why not functionName by itself?
18:04:20 <Squarism> Koterpillar, if you have many type ive experianced conflicts
18:04:32 <Squarism> as they are global identifiers
18:05:32 <Koterpillar> example?
18:05:40 <Koterpillar> maybe you actually have a typeclass then?
18:12:29 <EvanR> Squarism: record fields arent necessarily global, it depends on how you import them
18:13:02 <EvanR> also in my experience it does help to name them differently
18:13:20 <EvanR> you can also try DuplicateRecordFields extension
18:17:26 <Squarism> EvanR, oh i see. Ill check that out
18:18:37 <Squarism> Koterpillar, well its been thinks like "name" for Location, Army, etc
18:19:19 <Koterpillar> yeah, prefix them
18:19:20 <EvanR> also if you want common word like that for record names, maybe you want to look at extensible records
18:19:31 <Squarism> class Named a ... ?
18:19:32 <Squarism> =D
18:19:39 <EvanR> record fields*
18:19:56 <EvanR> type classes are a bad idea for that
18:20:13 <Koterpillar> Squarism: I actually had that
18:20:35 <EvanR> its more complex less flexible and you still have to name the record field something else internally
18:20:49 <Koterpillar> https://github.com/koterpillar/multiblog/blob/master/src/Models.hs#L30 HasSlug, HasContent
18:22:03 <Squarism> i heard there is work beeing done on mechanisms like these in next version of haskell? 
18:22:29 <Koterpillar> Squarism: yes, but not currently available
18:22:48 <Koterpillar> Squarism: well, I can merge arSlug/mtSlug, but I can't have HasSlug as a constraint
18:23:12 <EvanR> ghc 8 is available
18:23:48 <Koterpillar> EvanR: can I have equivalent of HasSlug in GHC 8?
18:23:59 <EvanR> look at DuplicateRecordFields
18:24:49 <Koterpillar> EvanR: AFAIK that lets me merge arSlug/mtSlug, but I can't even have slugLength = length . slug as a standalone function
18:25:03 <Koterpillar> Squarism: might be enough for you though
18:26:57 <EvanR> well, this sort of pattern seems inside out to me anyway, because on one hand you have different types, but on the other hand you really dont care what the type is, you really want to accept any string 
18:27:08 <parsnipM_> if i stop a resource intensive call in repl, the resource intensity can remain after cancelling... all until i finally quit the repl? 
18:27:37 <parsnipM_> or maybe this is bug in verboseCheck
18:27:38 <EvanR> so the most flexible way is to just take a string instead
18:27:56 <vectorspacealien> eyy thanks people who helped me before, I'm gonna use Data.Sequence for swapping a pair of nodes
18:28:04 <sm> parsnipM_: it depends on how well the thing you stopped cleans up its threads
18:28:32 <Koterpillar> EvanR: do you suggest returning a façade record?
18:28:42 <vectorspacealien> I've never done this before, so my plan is: use spanl to split the sequence at the node I'm looking for, do the swapping and put them back together
18:28:56 <parsnipM_> sm: ah. and the original hanging of verboseCheck? it is for `prop :: Fun String Integer -> Bool; prop (Fun _ f) = f "monkey" == f "banana" || f "banana" == f "elephant"`
18:29:23 <EvanR> Koterpillar: that is a good way to do interfaces, if section of code wants some uniform interface, it takes a record, and you can map whatever type you want to this record 
18:29:30 <EvanR> i.e. manual subtyping
18:29:33 <parsnipM_> quickCheck terminates fine after like two tests
18:29:52 <EvanR> when the record consists of a single string though, better to just take a string
18:30:09 <sm> parsnipM_: not sure, sorry
18:30:31 <sm> sounds worth a bug report IMHO, it's nice to be able to stop things in GHCI
18:30:52 <Koterpillar> EvanR: I have two, but rarely use them together
18:31:41 <EvanR> if rarely means never, then you dont even need adhoc polymorphism
18:31:58 <Koterpillar> EvanR: it's more like, I'm quite happy with my Has* classes - why would I need to change them?
18:32:47 <EvanR> whatever works, but that method will not really scale
18:33:06 <EvanR> if its a one off thing for 1 thing it may work
18:33:44 <Koterpillar> hmm, if I have a façade, I can still put it in one typeclass
18:34:02 <EvanR> there would be no point...
18:35:08 <Koterpillar> OK, thanks for the suggestions, I'll think about then next time this is refactored
18:38:08 <ExcaliburZero> How do you work with data that is held within MonadThrow? For example, if a function returns a `MonadThrow m => m Path Rel File` and you want to use the contained Path Rel File in a function like `MonadThrow m => Path Rel File -> m EntrySelector`.
18:38:46 <parsnipM_> sm: done https://github.com/nick8325/quickcheck/issues/96 :)
18:38:54 <glguy> You use >>= or do-notation
18:40:03 <ertesx> ExcaliburZero: same way you combine (getLine :: IO String) and (putStrLn :: String -> IO ())
18:40:05 <parsnipM_> for now, "'Doctor, Doctor, it hurts!', 'Don't Do That™'"
18:42:32 <ExcaliburZero> I tried using do notation, like in the following, but I got errors:
18:42:32 <ExcaliburZero> http://sprunge.us/TWdP
18:42:43 <ExcaliburZero> No instance for (MonadThrow m) arising from a use of ‘parseRelFile’
18:43:11 <ExcaliburZero> Couldn't match expected type ‘ZipArchive (m b1)`                with actual type ‘a0 -> m0 a0’
18:43:47 <Koterpillar> ExcaliburZero: what's that return doing on the end?
18:44:00 <Koterpillar> i.e. what's the type of createArchive?
18:44:09 <ertesx> ExcaliburZero: note that you are passing three arguments to createArchive
18:44:23 <geekosaur> sounds like you forgot a parameter (since the -> in the actual type means "this value is a function")
18:44:39 <Koterpillar> geekosaur: or vice versa
18:45:09 <ExcaliburZero> createArchive is `(MonadIO m, MonadCatch m) => Path b File -> ZipArchive a -> m a`
18:45:20 <glguy> then delete the return () at the end
18:46:06 <glguy> also: do { ...; result <- m; return result } is just do { ...; m }
18:46:11 <ExcaliburZero> From what I can tell, the `return()` at the end of createArchive is needed, as it throws in an empty `ZipArchive a`
18:46:21 <ertesx> i'm not familiar with the library, but i'm pretty sure that ExcaliburZero wants this:  createArchive p (return ())
18:46:24 <Koterpillar> ExcaliburZero: then put it in brackets
18:46:30 <Koterpillar> ExcaliburZero: createArchive p (return ())
18:46:40 <Koterpillar> that's assuming ZipArchive is also a monad?
18:47:11 <ExcaliburZero> Okay, putting `return ()` in parenthesis worked.
18:47:48 <ertesx> ExcaliburZero: also what glguy said…  'return' does not "return" in the way it does in virtually every other language
18:48:30 <ertesx> the action (do x <- c; return x) is the same as the action c
18:49:32 <EvanR> which is also true in ruby ;)
18:49:41 <ExcaliburZero> Thanks!
18:50:25 <EvanR> more like (return x) is some value, not a control flow operation
18:50:32 <EvanR> in fact return cant have any effect
18:50:35 <ertesx> background: (return x) is the action that does nothing and returns x
18:51:01 <ertesx> try this:  main = do return (); putStrLn "hello world!"
18:51:35 <EvanR> i just realized how confusing this might be ;)
18:52:01 <ertesx> explaining 'return' is one of the first things i do when teaching =)
18:53:18 <ertesx> (since the AMP this has become less of a problem, because i can just talk about 'pure' instead)
18:56:03 <glguy> > 2 * do 3 + 4
18:56:04 <lambdabot>  14
18:56:53 <Welkin> what is this? perl now?
18:58:48 <vectorspacealien> ugh okay I'm having trouble. Let's say I have a Data.Sequence fromList [1, 2, 3, 4, 5], right?
18:59:08 <vectorspacealien> And I want to swap the two elements closest to 2.5, right?
18:59:25 <Koterpillar> wherever they are?
18:59:41 <vectorspacealien> Yeah. Assume the Sequence is sorted, though.
18:59:56 <Koterpillar> and the numbers are unique?
19:00:05 <vectorspacealien> So it's going to be the first element that doesn't satisfy (>=2.5), and the first element that does.
19:00:09 <vectorspacealien> Yes, and the numbers are unique.
19:00:18 <ertesx> vectorspacealien: if they are unique, you could also use Set
19:00:29 <vectorspacealien> aren't sets unordered?
19:00:32 <Koterpillar> well, no, counterexample: [1, 2, 2.1, 2.9, 2.99, 3]
19:00:48 <ertesx> vectorspacealien: Data.Set sets are ordered
19:00:54 <ertesx> (via Ord)
19:00:55 <Koterpillar> vectorspacealien: you would swap 2.1 and 2.9 which is wrong
19:00:58 <vectorspacealien> ?? okay lemme look up what those are
19:00:58 <lambdabot>  okay lemme look up what those are
19:01:09 <vectorspacealien> oops
19:01:14 <Koterpillar> nice
19:01:17 <ertesx> vectorspacealien: nevermind, you can't change the order of a Set…  obviously =)
19:01:28 <vectorspacealien> Koterpillar: why's that wrong?
19:01:40 <Koterpillar> ok, [2.1, 2.51, 2.52]
19:01:48 <EvanR> also use Set for its ordering seems like abuse
19:01:58 <Koterpillar> vectorspacealien: the two numbers closest to 2.5 are 2.51 and 2.52
19:02:07 <vectorspacealien> oh oops. Sorry, I mispoke.
19:02:16 <vectorspacealien> I meant the numbers on either side of 2.5.
19:02:22 <Koterpillar> okay
19:02:31 <vectorspacealien> Thanks, my bad.
19:02:55 <Koterpillar> then if it's sorted, you'll be fine with that algorithm
19:03:07 <vectorspacealien> Well, I can't figure out how to implement it.
19:03:26 <vectorspacealien> I tried splitting it with spanl (<=2.5) x
19:03:49 <Koterpillar> is that thing foldable?
19:03:53 <vectorspacealien> where x=[1, 2, 3, 4, 5] or whatever I said before
19:04:13 <vectorspacealien> so I get fromList [1,2] and fromList [3,4,5]
19:04:23 <ertesx> vectorspacealien: you can use viewl and viewr to extract the first and last element of the suffix and prefix respectively
19:04:27 <vectorspacealien> and I want to swap 2 and 3, but I don't see a fast way to access the last element of fromList [1,2]
19:04:32 <vectorspacealien> yeah its foldable
19:04:53 <vectorspacealien> ertesx: ooh, I can? I saw views in the Data.Sequence help page but I didn't get what they were
19:05:09 <Welkin> you could even write it recursively and pattern match on the first half to grab the previous element
19:05:19 <Welkin> if you want to use a list
19:05:54 <Welkin> oh wait, that would be kind of a mess
19:05:54 <vectorspacealien> Welkin: I want to use whatever is most natural for this search and swap thing
19:05:58 <vectorspacealien> oh ok
19:06:05 <vectorspacealien> ok I'll read into views
19:06:11 <ertesx> vectorspacealien: their names are probably inspired by "view patterns" or by things like minView and maxView from ordered data structures
19:06:12 <Welkin> sequence could work
19:06:44 <EvanR> or view types
19:07:57 <EvanR> data Uncons = Empty | Word8 :- ByteString
19:08:33 <Koterpillar> vectorspacealien: since you're O(n), why not zip that sequence with its tail?
19:08:56 <vectorspacealien> Koterpillar: oooooh
19:09:43 <vectorspacealien> how do I execute stuff on the bot again?
19:09:51 <Koterpillar> > "stuff"
19:09:53 <lambdabot>  "stuff"
19:09:57 <vectorspacealien> hehe cool
19:10:01 <Koterpillar> > "st" ++ "uff"
19:10:02 <lambdabot>  "stuff"
19:10:07 <vectorspacealien> > let x = [1.0, 2.0, 3.0, 4.0, 5.0]
19:10:08 <ertesx> because there is still a difference between bad O(n) and unimaginable-nightmare O(n)
19:10:08 <lambdabot>  <no location info>:
19:10:09 <lambdabot>      not an expression: ‘let x = [1.0, 2.0, 3.0, 4.0, 5.0]’
19:10:14 <geekosaur> it's not ghci
19:10:18 <vectorspacealien> oh
19:10:22 <geekosaur> it only does expressions
19:10:27 <Welkin> @let fuck = "hello"
19:10:29 <lambdabot>  Defined.
19:10:35 <vectorspacealien> oh
19:10:46 <vectorspacealien> @let x = [1.0, 2.0, 3.0, 4.0, 5.0]
19:10:47 <Koterpillar> ertesx: true, I'm assuming tail is O(1), which I can't get from the page, actually
19:10:48 <lambdabot>  Defined.
19:10:48 <geekosaur> (well, that's a slight lie, but polluting the shared namespace isn't always a good idea)
19:11:01 <vectorspacealien> oh
19:11:10 <geekosaur> especially since there was already an "x" (and likewise every other single letter variable, via simple-reflect)
19:11:19 <Koterpillar> > q
19:11:21 <lambdabot>  q
19:11:26 <Koterpillar> ?type q
19:11:28 <lambdabot> Expr
19:11:38 <ertesx> Koterpillar: 'tail' is fine, but 'zip' is bad
19:11:41 <Welkin> > let x = [1..5] in map (^^2) x
19:11:42 <lambdabot>  [1.0,4.0,9.0,16.0,25.0]
19:12:01 <vectorspacealien> OH cool! okay that's how I'm gonna do variables with lambdabot
19:12:11 <Welkin> > map toUpper fuck
19:12:11 <Koterpillar> ertesx: is there ++?
19:12:13 <lambdabot>  "HELLO"
19:12:35 <ertesx> Koterpillar: sure: instance Monoid (Seq a)
19:12:59 <ertesx> > Seq.fromList [1,2,3]
19:13:00 <lambdabot>  fromList [1,2,3]
19:13:01 <Koterpillar> efficient?
19:13:07 <ertesx> > Seq.fromList [1,2,3] <> Seq.fromList [4,5,6]
19:13:09 <lambdabot>  fromList [1,2,3,4,5,6]
19:13:17 <vectorspacealien> O(log(min(n1, n2)))
19:13:35 <ertesx> Koterpillar: logarithmic
19:13:36 <Koterpillar> ertesx: then I'm with your solution with viewr
19:13:39 <vectorspacealien> so efficient enough for my purposes. I'm trying to keep elements that are accessed often near the left of the list.
19:13:55 <vectorspacealien> or, modified often, rather.
19:14:01 <vectorspacealien> So, hopefully n1 is usually going to be small.
19:14:14 <ertesx> all the little fast operations add up of course, but it's still better than going linear over the full sequence
19:14:31 <vectorspacealien> oh, yeah, I can't go linear over the whole sequence
19:14:57 <Koterpillar> vectorspacealien: looks like you're not using the fact that the sequence is sorted
19:15:19 <vectorspacealien> yeah I guess not.
19:15:39 <ertesx> vectorspacealien: not sure what you're doing, but all of this sounds like you actually need a priority queue
19:15:43 <ertesx> i'm just guessing
19:15:54 <Koterpillar> it won't be sorted after you do that, though
19:15:59 <vectorspacealien> I'm doing a... I forget what it's called, but it's a modification to Gillespie's algorithm
19:16:21 <vectorspacealien> for simulating chemical reactions. Though I'm actually using it to simulate cell growth.
19:17:14 <vectorspacealien> Um, not sure whether to explain in full.
19:17:28 <vectorspacealien> priority queue hmm.
19:18:59 <vectorspacealien> No, I don't think so, from reading the wiki page.
19:19:13 <vectorspacealien> Okay, and I thought of a simple explanation.
19:19:51 <vectorspacealien> I have a list of cell populations, lets call it PopulationList. This is what I've been thinking of using Data.Sequence for.
19:20:21 <vectorspacealien> Each one contains a Population. Each Population has a genotype (just a unique identifier), a size, and a growth rate.
19:21:28 <vectorspacealien> In each step of the simulation, one of the populatioin's sizes is going to be incremented by 1. (Next thing I'm going to try to do is make it so they can also spawn new Populations, but I'm not trying to do that right now.)
19:22:08 <vectorspacealien> The probability of a Population being chosen in a single step is proportional to its size times its growth rate.
19:23:06 <vectorspacealien> When I was talking about a sorted list before, this is analogous to the cumulative sum list of the size*rates. Hmm, lets call a size*rate the Propensity of a population, and the cumulative sums CumPropensities.
19:23:49 <vectorspacealien> So for example if our populations have sizes [1, 10, 100], and growth rates [3, 2, 1], our Propensities will be [3, 20, 100], and our CumPropensities [3, 23, 123]
19:24:31 <ertesx> are you trying to pick a population at random?
19:24:38 <ertesx> with the given probabilities?
19:24:52 <vectorspacealien> So of course CumPropensities is sorted, but it's not really what I'm storing, it's just something derived from it. So I was playing with sorted lists to figure out how to do this.
19:25:00 <vectorspacealien> ertesx: Yes.
19:25:08 <ertesx> why didn't you say so…
19:25:19 <ertesx> the mwc-random package gives you exactly that…  batteries included
19:25:36 <ertesx> https://hackage.haskell.org/package/mwc-random-0.13.4.0/docs/System-Random-MWC-CondensedTable.html
19:25:39 <vectorspacealien> ertesx: You can do that in this case by picking a random number from 1 to 123 and choosing the first population with a CumPropensity higher than that.
19:26:24 <vectorspacealien> well, there are lots and lots of populations. Hundreds of thosuands, or millions.
19:26:37 <vectorspacealien> And they have really really different sizes. 
19:27:09 <vectorspacealien> So one strategy people use, which I was planning to use, is to move a population one step closer to the beginning of the list every time you increment its population size.
19:27:33 <vectorspacealien> So, the ones you have to update the most often are right at the beginning of the list.
19:28:28 <vectorspacealien> CondensedTable doesn't seem like it will work,s ince construction is slow, and I have to build a new table at every step (since probability increases with population size, and every step I increment the size of one of the populations.)
19:29:15 <vectorspacealien> well, I think construction is slow. It doesn't actually say.
19:29:21 <ertesx> i see…  what you can do is not to use Data.Sequence, but instead a full finger-tree as it is implement in the 'fingertree' package, and use the propensity as the measure
19:29:27 <Welkin> vectorspacealien: are you looking for a solution that works, or the optimal solution?
19:30:04 <ertesx> vectorspacealien: then the sequence does not count length, but propensity, and you get logarithmic split at the generated random number
19:30:45 <vectorspacealien> Welkin: I'll get to the optimal solution if I need it I guess. What I need is something I can write as quickly as possible that can run the simulations I need.
19:30:55 <vectorspacealien> I'm running code someone else gave me right now, and it's been running for like 3 days.
19:31:25 <vectorspacealien> I don't know if these simulations are even accurate enought o be worth a lot of effort, but I need something that will at least run fast enough to give me results in order to decide that...
19:32:13 <vectorspacealien> ertesx: I don't really follow but I'll take a look at the fingertree page and see if I get what you're saying
19:33:18 <ertesx> vectorspacealien: data Pop = Pop { popSize :: !Int, popRate :: !Int }
19:34:17 <ertesx> newtype Propensity = Propensity Double;  instance Monoid Propensity where mempty = 0; mappend (Propensity x) (Propensity y) = Propensity (x + y)
19:34:33 <ertesx> now from the fingertree package:
19:34:33 <vectorspacealien> btw if anyone wants to read more about these kinds of algorithms, here's where I learned about them: http://www.annualreviews.org/doi/abs/10.1146/annurev.physchem.58.032806.104637?journalCode=physchem
19:34:40 <vectorspacealien> and also if you have access to the journal
19:35:12 <ertesx> instance Measured Propensity Pop where measure (Pop s r) = Propensity (fromIntegral s * fromIntegral r)
19:35:46 <ertesx> now you can use the FingerTree Propensity Pop type
19:36:03 <ertesx> it gives you a cheap 'split' at the cumulative propensities
19:36:40 <ertesx> so there is no longer a need to keep the sequence ordered in any way
19:36:57 <vectorspacealien> ooooooooooooh!
19:37:02 <vectorspacealien> wow
19:37:07 <vectorspacealien> wowow
19:37:57 <vectorspacealien> wait... so how long does the split take?
19:38:17 <ertesx> O(log(min(i, n - i)))
19:38:56 <vectorspacealien> but i is the number of Populations before the chosen Population?
19:39:06 <vectorspacealien> that could be very large if we're not keeping it ordered
19:39:15 <ertesx> i is the index of the splitting point
19:39:18 <ertesx> note the "log"
19:40:21 <vectorspacealien> okay... maybe that will still be fast enough, and I can try the swapping approach if it isn't
19:42:13 <ertesx> you can still bubble populations with large propensities to the front
19:42:53 <ertesx> but you don't have to do it all the time…  instead you could introduce a sorting step every few thousand iterations
19:43:31 <vectorspacealien> hmm yeah that's true
19:45:16 <ertesx> ultimately a benchmark will be the best way to choose the parameters
19:45:46 <ertesx> or you could add a genetic meta-algorithm to do that – if you want to get a bit crazy =)
19:46:09 <ertesx> the self-optimising cell growth simulator =)
19:46:17 <vectorspacealien> :p
19:46:47 <Welkin> vector-space alien? or, vector space-alien?
19:47:12 <vectorspacealien> sounds like I just need a PopulationList of cell growth simulators, with a score that's incremented whenever they complete a run....
19:47:25 <vectorspacealien> welkin: an alien from a vector space
19:47:53 <vectorspacealien> ppl usually shorten it VSA but I like the shortening "alien" the most :p
19:50:04 <ertesx> vectorspacealien: i've done such meta-algorithms in the past, so it's not unreasonable =)
19:53:46 <vectorspacealien> So, I would update my fingertree like: next populationList cutoff = (prefix |> chosen) >< afterChosen
19:54:08 <vectorspacealien> where splitPopulationList = split (>cutoff) populationList
19:54:14 <vectorspacealien> prefix = fst splitPopulationList
19:54:22 <vectorspacealien> suffix = snd splitPopulationList
19:54:40 <vectorspacealien> chosen = head suffix
19:54:44 <vectorspacealien> afterChosen = tail suffix
19:54:50 <vectorspacealien> although idk if fingertrees have head and tail?
19:54:51 <ertesx> where (prefix, suffix) = split (> cutoff) popList
19:55:06 <ertesx> they have viewl and viewr
19:55:19 <vectorspacealien> ooh I didn't know you could assign like that in haskell
19:55:30 <ertesx> it's regular pattern-matching
19:55:58 <Welkin> vectorspacealien: head and last
19:56:21 <vectorspacealien> I always thought of pattern matching as something you do in function arguments. 
19:56:24 <vectorspacealien> okay, cool. Still have to read about views.
19:56:41 <ertesx> > Seq.viewl (Seq.fromList [1,2,3])
19:56:42 <lambdabot>  1 :< fromList [2,3]
19:56:52 <ertesx> > Seq.viewl mempty
19:56:53 <lambdabot>  EmptyL
19:57:04 <ertesx> that's all there is to views
19:57:27 <sinful_> Selling botnet source
19:57:30 <vectorspacealien> > Seq.viewl (Seq.fromList [1,23]) + 1
19:57:31 <lambdabot>      No instance for (Show a0)
19:57:31 <lambdabot>        arising from a use of ‘show_M709348306203321692013490’
19:57:31 <lambdabot>      The type variable ‘a0’ is ambiguous
19:58:13 <sinful_> Anyone interested in buying botnet source?
19:58:20 --- mode: ChanServ set +o glguy
19:58:20 --- mode: glguy set +b *!*@gateway/web/irccloud.com/x-rzbhjiaugxcryybv
19:58:21 --- kick: sinful_ was kicked by glguy (sinful_)
19:58:21 <ertesx> > let xs = Seq.fromList ["hah","huh","hih"] in case Seq.viewl xs of EmptyL -> "the sequence was empty"; y :< ys -> "non-empty with head: " ++ y
19:58:22 <lambdabot>      Not in scope: data constructor ‘EmptyL’
19:58:22 <lambdabot>      Perhaps you meant one of these:
19:58:22 <lambdabot>        ‘Data.Sequence.EmptyL’ (imported from Data.Sequence),
19:58:32 <ertesx> > let xs = Seq.fromList ["hah","huh","hih"] in case Seq.viewl xs of Seq.EmptyL -> "the sequence was empty"; y Seq.:< ys -> "non-empty with head: " ++ y
19:58:33 <lambdabot>  "non-empty with head: hah"
19:58:51 <ertesx> vectorspacealien: hope this helps
19:59:25 <ertesx> vectorspacealien: it's like cons/nil pattern-matching
20:00:46 <vectorspacealien> getting the view is O(1); is doing something with the actual value O(1)?
20:01:02 <EvanR> views let you pattern match on data as if it was structured in a way that it isnt, which is especially helpful when youre dealing with an abstract type like Sequence which cant be pattern matched normally
20:01:11 --- mode: glguy set -b *!*@gateway/web/irccloud.com/x-rzbhjiaugxcryybv
20:01:15 --- mode: glguy set -o glguy
20:01:29 <vectorspacealien> ok I g2g
20:01:31 <EvanR> but is also handy for other sorts of data
20:01:31 <vectorspacealien> thanks guys
20:45:43 <linoge> I don't understand how pattern matching works here http://lpaste.net/165152
20:46:37 <Koterpillar> linoge: mapping :: (a -> b) -> (r -> b -> r) -> r -> a -> r 
20:46:44 <Koterpillar> how about now?
20:47:11 <linoge> Everything clear
20:47:34 <Koterpillar> that's equivalent to what you have; a -> (b -> c) is the same as a -> b -> c
20:48:08 <linoge> But (a -> b) -> (r -> b -> r) must be written like that right?
20:48:29 <Koterpillar> linoge: yes, (a -> b) -> c is different; '->' is right associative
20:48:55 <parsnipM_> > quickCheck (\xs -> (reverse . reverse) xs == xs)
20:48:56 <lambdabot>      Couldn't match expected type ‘[()] -> Bool’
20:48:56 <lambdabot>                  with actual type ‘QuickCheck-2.8.1:Test.QuickCheck.Random.QC...
20:48:56 <lambdabot>      The lambda expression ‘\ xs -> (reverse . reverse) xs == xs’
20:49:10 * hackagebot gtk2hs-buildtools 0.13.2.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.2.1 (HamishMackenzie)
20:49:11 <parsnipM_> > quickCheck (\xs :: [Int] -> (reverse . reverse) xs == xs)
20:49:13 <lambdabot>      Illegal result type signature ‘[Int]’
20:49:13 <lambdabot>        Result signatures are no longer supported in pattern matches
20:49:13 <lambdabot>      In a lambda abstraction:
20:49:20 <parsnipM_> oops, wrong channel, sorry
20:50:07 <linoge> So (r -> a -> r) = r -> a -> r
20:51:02 <Koterpillar> by itself, that doesn't make much sense
20:51:12 <Koterpillar> a -> THAT = a -> (THAT) though
20:56:25 <acowley> Has anyone started on getting intero to work with Nix?
21:09:10 * hackagebot Shellac 0.9.9 - A framework for creating shell envinronments  https://hackage.haskell.org/package/Shellac-0.9.9 (RobertDockins)
21:09:12 * hackagebot Shellac-readline 0.9.9 - Readline backend module for Shellac  https://hackage.haskell.org/package/Shellac-readline-0.9.9 (RobertDockins)
21:09:14 * hackagebot Shellac-editline 0.9.9 - Editline backend module for Shellac  https://hackage.haskell.org/package/Shellac-editline-0.9.9 (RobertDockins)
21:09:16 * hackagebot Shellac-compatline 0.9.9 - "compatline" backend module for Shellac  https://hackage.haskell.org/package/Shellac-compatline-0.9.9 (RobertDockins)
21:17:31 <bollu> hey guys
21:17:32 <bollu> what
21:17:55 <bollu> what's the relationship between a monad (that arises out of an adjunction) and a kleisli category?
21:18:28 <bollu> In particular, I guess I have two questions: 1. what exactly is the kleisli category trying to capture? 2. Given a monad "m", can I always find two functors such that their adjunction yields "m"?
21:38:06 <jle`> bollu: https://en.wikipedia.org/wiki/Adjoint_functors#Monads
21:54:12 * hackagebot EdisonAPI 1.3.1 - A library of efficient, purely-functional data structures (API)  https://hackage.haskell.org/package/EdisonAPI-1.3.1 (RobertDockins)
22:11:21 <TiaTnT> Greetings
22:24:14 * hackagebot rex 0.5.2 - A quasi-quoter for typeful results of regex captures.  https://hackage.haskell.org/package/rex-0.5.2 (MichaelSloan)
22:32:49 <dmwit_> hum
22:33:28 <dmwit> "cabal upload dist/template-default-0.1.2.tar.gz" printed "Ok" and exited with code 0, but the template-default package still seems to be stuck on 0.1.1.
22:34:14 * hackagebot template-default 0.1.2 - declaring Default instances just got even easier  https://hackage.haskell.org/package/template-default-0.1.2 (DanielWagner)
22:34:33 <dmwit> ...ok
22:34:41 <dmwit> Guess there's just a bit of a delay. =P
22:34:48 <mgsloan> Yeah I also got a couple minutes lag
22:35:54 <zinking> get = State $ \s -> (s,s)  
22:36:08 <zinking>     stackNow <- get       if stackNow == [1,2,3] 
22:36:08 <dmwit> Beautiful, isn't it?
22:36:29 <zinking> why stackNow could be compared with [1,2,3]
22:36:35 <zinking> isn't it a state ?
22:36:50 <Koterpillar> zinking: is that the next line?
22:36:58 <zinking> yes
22:37:06 <zinking> stackNow <- get 
22:37:08 <dmwit> No, `get` is a `State` action. But `stackNow` has the type of the contained state.
22:37:37 <Koterpillar> zinking: get >>= \stackNow -> if stackNow == [1, 2, 3]
22:37:42 <Koterpillar> zinking: that's what you have
22:37:47 <dmwit> If `get :: State s s`, then in the `...` part of `do { stackNow <- get; ... }`, we have `stackNow :: s`.
22:38:24 <zinking> I see
22:38:37 <zinking> I misunderstand the <- 
22:38:38 <zinking> thanks
22:39:41 <dmwit> Generally, if `act :: m a` for some monad `m`, then `do { v <- act; ... }` makes `v :: a` in the `...`.
22:51:11 <dmwit> Ugh, the new tab warning is the worst.
22:51:34 <dmwit> Do we really need thousand-line patches to legacy packages to change whitespace?
22:53:12 <glguy> dmwit: What types are you using that TH on that don't support the default generics instance?
22:53:35 <dmwit> glguy: I dunno. I'm not using the package, just received patches from elsewhere.
22:53:50 <glguy> ah, I guess the default generics instance doesn't default to the first constructor in a sum type, actually
22:55:56 <glguy> dmwit: I know you just added 7.10 support 25 minutes ago, but 8.0 doesn't work now!
22:56:35 <dmwit> patches welcome...
22:57:31 <lpaste> tippenein pasted “concurrent mconcats ?” at http://lpaste.net/165153
22:57:59 <tippenein> how would you concurrently run mconcats and keep them out of  IO?
22:58:53 <tippenein> ah.. I don't want Control.Concurrent.Async for one, i guess..
22:59:14 <EvanR> heres one way https://hackage.haskell.org/package/unamb-0.2.5/docs/Data-Unamb.html
22:59:15 <dmwit> I guess this is what `par` and `pseq` are for, right?
22:59:24 <EvanR> or par
23:00:57 <dmwit> let [a, b, c] = map mconcat [as, bs, cs] in a `par` b `par` c `pseq` mconcat [a,b,c]
23:13:08 <tippenein> ------------------------------------------------------------
23:13:22 <tippenein> no idea what key-combo caused that
23:25:44 <tippenein> both implementations take 3.5 seconds :/
23:30:24 <lpaste> tippenein revised “concurrent mconcats ?”: “concurrent mconcats ?” at http://lpaste.net/165153
23:32:34 <tippenein> ah, this is in ghci, maybe I have to compile it with -threaded
23:34:03 <hvr> dmwit: the delay is due to our CDN
23:49:13 <tippenein> the `par` solution is actually slower :/
23:51:40 <systemfault> I'm a ghc noob but don't you have to start the program using a switch to make it use your cores?
23:52:32 <systemfault> tippenein: Like.. if you have 4 core, you'd do +RTS -N4
23:53:32 <EvanR> and you probably need to link with ghc -threaded
23:53:54 <tippenein> using this: ghc -threaded -rtsopts -eventlog --make 
23:54:30 <systemfault> tippenein: Then when you actually run the compiled program, you have options to pass IIRC
23:54:36 <systemfault> The two I gave you
23:54:51 <tippenein> yeah, that makes it 3x slower
23:54:55 <systemfault> Nice
23:55:05 <tippenein> :D
23:55:45 <EvanR> not mconcatting enough pylons
23:56:50 <tippenein> not folding hard enough?!
23:57:51 <systemfault> Perhaps you need to compile with -O99
23:57:54 <systemfault> j/k
23:58:09 <systemfault> Might be worth trying with optimizations on though.
23:58:20 <systemfault> Perhaps it would be to 10 times slower :)
