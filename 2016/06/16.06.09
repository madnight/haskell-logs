00:03:10 <quchen> Those seem like two different ways to look at the same thing.
00:04:57 <quchen> Mathematically, a function is roughly a set of pairs of (input, output) with unique inputs.
00:05:12 <quchen> Function application is a lookup on the first entries.
00:05:53 <quchen> So you have application and indexing represented just the same.
00:07:40 * hackagebot monoid-extras 0.4.1 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.1 (BrentYorgey)
00:07:40 * hackagebot parseargs 0.2.0.7 - Full-featured command-line argument parsing library.  https://hackage.haskell.org/package/parseargs-0.2.0.7 (BartonMassey)
00:40:32 <bollu> this is a slightly dumb question
00:40:38 <bollu> but how do I start using lens "properly"?
00:40:51 <bollu> as in, how do I learn the more "advanced" uses of lens other than view, set, etc?
00:41:09 <merijn> bollu: Have you watched edward's talk on "how lens works"?
00:41:56 <bollu> merijn: somewhat - I watched in ~a year back I think, though I don't think I took away a lot back then
00:42:06 <bollu> I think I now have a much better idea (eg. comonads, store, etc)
00:42:13 <merijn> bollu: You can always see if rewatching enlightens you more :)
00:42:57 <bollu> merijn: fair point :)
00:43:02 <bollu> merijn: any chance there's a transcript somewhere?
00:43:49 <merijn> Not sure if there's a transcript, but it's on youtube
00:43:56 <merijn> Maybe if you google the title you can find something?
00:43:58 <merijn> @where lens
00:43:58 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
00:45:30 <bollu> I did look actually, but all it gives you is about real lenses :P restricting to "Haskell" didn't help
00:46:36 <shachaf> Quite a lot has changed since that talk anyway.
00:47:31 <bollu> another question: every adjunction generates a monad. Can every monad be generated by an adjunction? (Google says yes, and that the kleisli category has some link to this, but I couldn't exactly figure out what)
00:48:41 <shachaf> Yes.
00:49:06 <quxbam> Isn't it dangerous for Foldable.length to return an Int?
00:49:08 <quxbam> > length (():replicate maxBound ())
00:49:12 <lambdabot>  mueval-core: Time limit exceeded
00:49:40 <bollu> shachaf: how exactly does one construct the kleisli category K from a category C with a monad m on it?
00:49:51 <bollu> you keep the same objects, but what are the new arrows?
00:50:08 <quxbam> Admittingly, that would be a long list, but they are allowed to be codata
00:50:09 <merijn> quxbam: Yes, many people consider that a flaw
00:50:20 <merijn> quxbam: But Integer is a bit slower to compute
00:50:37 <shachaf> An arrow : A -> B in Kleisli M is an arrow : A -> M B
00:50:44 <merijn> quxbam: And to be fair, a list that's finite, but larger than "maxBound :: Int" won't fit in your memory anyway ;)
00:50:46 <quxbam> merijn: Couldn't the compiler use for smaller Integers Ints?
00:51:00 <merijn> > maxBound :: Int
00:51:02 <lambdabot>  9223372036854775807
00:51:02 <shachaf> Just like the Haskell type newtype Kleisli m a b = Kleisli (a -> m b)
00:51:02 <bollu> shachaf: and that is legal because M B is guaranteed to be in C?
00:51:14 <shachaf> ?
00:51:23 <merijn> > (maxBound :: Int) / (1024 * 1024 * 1024)
00:51:25 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
00:51:25 <lambdabot>      In the expression: (maxBound :: Int) / (1024 * 1024 * 1024)
00:51:27 <quxbam> merijn: But it doesn't have to fit in memory, it's lazy
00:51:31 <merijn> > (maxBound :: Int) `div` (1024 * 1024 * 1024)
00:51:33 <lambdabot>  8589934591
00:51:47 <shachaf> Oh, where C is your original category. Yes, M B has to be an object there, of course. M is a functor.
00:51:54 <bollu> shachaf: this works because we have monadic composition right? (a -> m b) -> (b -> m c) -> (a -> m c)?
00:51:58 <merijn> quxbam: If you only compute the length, sure. But usually you don't ONLY compute the length, but something else too
00:52:07 <merijn> quxbam: Which means you can GC as you compute the length
00:52:24 <bollu> shachaf: so taking C -> Kleisli M C (assuming that's the right notation) is a Functor?
00:52:30 <merijn> quxbam: Consider "avg xs = sum xs / length xs" <- this keeps all of 'xs' in memory
00:52:30 <shachaf> That's how composition works in Kleisli M, yes.
00:52:34 <quxbam> merijn: If you use a foldr, you can compute the length and the sum and what not in constant memory
00:52:45 <shachaf> The functor I'm talking about is M : C -> C
00:52:50 <osa1> quxbam: small Integers are Ints actually. see GHC.Integer.Type's source (Integer type is defined, see S# constructor)
00:52:55 <merijn> quxbam: Sure, but then you're not using length anymore, so who cares about the type of length, then? :)
00:53:10 <quxbam> :)
00:53:34 <quxbam> It's at least in a class which is quite prominent for its laws
00:53:36 <quxbam> :)
00:53:36 <bollu> shachaf: where do you get M: C -> C? doesn't M only have "return" and "join" ? return :: a -> m a, join :: m (m a) -> m a right?
00:53:48 <merijn> quxbam: My point is that if we assume, optimistically 1 byte per list element, we consume 8,589,934,591 GB of memory to store a list of maxBound elements :)
00:53:50 <shachaf> No, M is a monad.
00:54:03 <shachaf> A monad is a functor.
00:54:06 <bollu> shachaf: correct, so it's a *monoid* of endofunctors right?
00:54:17 <shachaf> What's a monoid of endofunctors?
00:54:20 <bollu> a monad?
00:54:43 <quxbam> merijn: Yes, I'm not having any practical issue, more a theoretical issue
00:54:44 <shachaf> M happens to be a monoid object in a particular monoidal category of endofunctors. But you don't need to worry about that.
00:54:55 <shachaf> In order to even be in that category, M has to be an endofunctor itself.
00:55:09 <quxbam> merijn: I'm quite uncomfortable with a lot of the overflow story in haskell
00:55:18 <bollu> shachaf: hmm, can you elaborate on how you went from (1) to (2)?
00:55:27 <quxbam> like Data.Set beeing undefined for Sets bigger than maxBound
00:55:29 <shachaf> What is 1 and 2?
00:55:46 <bollu> 1 - M happens to be a monoid object in a particular monoidal category of endofunctors. 2 - n order to even be in that category, M has to be an endofunctor itself.
00:56:04 <shachaf> Well, I just said you don't need to worry about that.
00:56:12 <shachaf> A monoid object in a category is of course an object in that category.
00:56:24 <merijn> quxbam: It's not ideal, no
00:56:30 <bollu> hm, okay
00:56:47 <bollu> well, okay, so a monad is a functor, so we have a C -> C
00:57:28 <bollu> so now, where does the adjunction come into the picture?
00:57:41 <shachaf> Of course "M is a functor : C -> C" is a shorthand. It means that M maps objects in C to objects in C and (more importantly) maps that it maps an arrow f : A -> B to an arrow M(f) : M(A) -> M(B)
00:57:50 <shachaf> I don't know, you brought it into the picture.
00:57:53 <bollu> shachaf: right
00:57:57 <quxbam> merijn: I'm tempted to describe a functor of infinite length at the typelevel with a Nat of maxBound+1, but I feel a bit guilty to exploit that
00:58:17 <bollu> shachaf: no, I mean, I was told that there is some relation between the question "is every monad generated by an adjunction" and the Kleisli category
00:58:25 <merijn> quxbam: If "maxBound + 1" is not an error, then it really shouldn't be Bounded in the first place
00:58:28 <bollu> shachaf: I was hoping you knew the connection
00:58:29 <shachaf> Yes, there's one adjunction that involves Kleisli M.
00:58:45 <quxbam> merijn: A Nat isn't Bounded
00:58:53 <bollu> shachaf: okay, so to form the adjunction, we need another functor "back" from Kleisli M to C right?
00:59:10 <merijn> quxbam: Sure, but then "maxBound" doesn't make sense :p
00:59:11 <quxbam> merijn: foo :: S.Set Int `OfSize` 9999999999999999
00:59:19 <shachaf> You need one functor in each direction, yes.
00:59:21 <bollu> shachaf: so how do we describe this functor?
00:59:37 <shachaf> The way https://en.wikipedia.org/wiki/Kleisli_category#Kleisli_adjunction describes it.
00:59:58 <quxbam> merijn: yes, the maxBound for Int, hardcoded into the type and hoping that 124bit architectures won't come in the forseeable future
01:00:08 <quxbam> 128
01:00:33 <sbrg> quxbam: you cuold do that. and the compiler would never finish typechecking, I guess.
01:00:52 <quchen> quxbam: Sets are strict in the spine, so maxBound-sized ones are impractical.
01:00:57 <quxbam> sbrg: Does he do all the peano story in the background?
01:01:22 <bollu> shachaf: what exactly does it mean to say TY and Tf?
01:01:26 <shachaf> You need one functor in each direction, of course.
01:01:33 <shachaf> You haven't described either one of them.
01:01:59 <quxbam> quchen: I'm trying to write a lib which carries arround information of the minimal and the maximal possible size of a functor.
01:02:07 <shachaf> I think you shouldn't be thinking about adjunctions right now. Better to spend more time becoming familiar with functors and monads and so on. There's a lot of notation to pick up first.
01:02:33 <bollu> shachaf: ah, nvm, I just noticed that in <T, \eta, \mu> T is the endofunctor :)
01:02:33 <shachaf> T is a functor, which means it maps objects and arrows. TY is the object part of T, applied to Y. Tf is the object part of T, applied to f.
01:02:34 <quxbam> tail :: [a] `OfMaxSize` n -> [a] `OfMaxSize` (n-1)
01:02:43 <quxbam> in that style
01:04:41 <exio4> which libraries are out there for making a webpage? I am looking for something really simple (iow not yesod) but more than a http server
01:04:52 <quxbam> sbrg: just checked, it doesn't disturb ghc in the slightest to have that big Nats, it's still instant to compile
01:05:00 <quchen> exio4: scotty, spock
01:05:42 <sbrg> quxbam: ah, my bad. I assumed it would have to walk the entire structure. did you try it with maxBound of Int?
01:05:45 <quxbam> sbrg: Note that it doesn't signify that I've got that big a functor, only that it is a functor which hasn't got a proven smaller size
01:06:03 <exio4> quchen: ok! saved :)
01:06:04 <quchen> What's the size of a functor anyway?
01:06:08 <quxbam> sbrg: with a lot of 9s, surely more than maxBound
01:06:15 <sbrg> quxbam: alright
01:06:43 <quxbam> quchen: s/functor/foldable
01:07:06 <sbrg> exio4: "making a webpage" in what way? there's plenty of ways. you want more than a webserver, so you want a webserver? or can it be static? do you want a templating DSL?
01:07:09 <sbrg> etc
01:07:16 <sbrg> there
01:07:34 <sbrg> there's lucid and blaze and more for type-safe HTML DSLs, for example
01:07:48 <sbrg> or you can use Hakyll which can create a static website by compiling stuff to html via pandoc
01:09:07 <sbrg> there's scotty and spock for some really simple webservers, and I'd think those support both blaze and lucid. there's also servant.
01:09:28 <sbrg> oh, scotty and spock already mentioned
01:13:17 <exio4> sbrg: it is a dynamic webpage, some database management and that's all
01:28:53 <sbrg> exio4: I'd probably go with scotty/spock and persistent then
01:28:54 <sbrg> works great
01:29:32 <sbrg> exio4: there was a post yesterday or a couple of days ago on /r/haskell that I think was an example of using scotty and servant together
01:29:41 <sbrg> eh, persistent
01:29:44 <sbrg> not servant
01:30:59 <Tekkkz> Hello! I am using haskell instead of php for webdevelopment. Now i need to create a login system, but how can I set the seission for the user? I mean with javascript it is very unsafe because people can see the javascript code and change their userid and so on (https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) but how else cou
01:30:59 <Tekkkz> ld i do it?
01:33:23 <kadoban> Tekkkz: You'd want to use a framework that does it for you. I know yesod has at least one way to handle sessions.
01:34:03 <Tekkkz> but isn't yesod an own webserver? i just wanna use my compiled haskell scripts via they give output ... or is that wrong?
01:34:35 <sshine> Tekkkz, it uses warp.
01:34:52 <Tekkkz> but i want to use lightttp
01:34:55 <kadoban> Tekkkz: You want to do haskell as CGI? You can … CGI is kind of an old idea though that everybody seems to be moving away from.
01:35:10 <Tekkkz> why should i not use CGI?
01:36:12 <sshine> Tekkkz, just use warp as the application server and point your favourite proxying httpd to it.
01:36:44 <Tekkkz> hm okay. if you say so
01:37:06 <kadoban> Tekkkz: It's just easier not to really. The frameworks that exist save you a lot of time, since they have functionality in them you'll presumably need.
01:37:31 <kadoban> You can do CGI if you want, I just don't think I ever would without a strong reason.
01:37:52 <Tekkkz> okay ill have a lokk at it. but how to send from my lightttpd to warp?
01:38:02 <sshine> I'm not sure exactly what CGI gives you?
01:38:32 <sshine> Tekkkz, I'd google "use lighttpd as a proxy". it seems there are some tutorials.
01:39:36 <Tekkkz> okay thanks a lot. cu
01:40:04 <sshine> you're welcome!
01:51:37 <av_> Hi everybody, I have a quick question:
01:53:13 <av_> I've got a list with elements that can be evaluated independently of each other, and a load of CPUs for that task.  I thought Control.Parallel could come in handy, so I wonder what the best way is of telling the compiler that it can evaluate the elements of the list in parallel?
01:53:35 <av_> i.e., how do I build a simple definition out of par and pseq to tell it that?
01:53:40 <merijn> parMap?
02:00:47 <quchen> parMapChunked
02:02:00 <quchen> parMapChunked i f = (`using` parListChunked i strat) . map f
02:03:50 <quchen> parMap alone is often kind of slow because it sparks a lot of individual computations
02:05:29 <av_> quchen: where do i find parMapChunked?
02:05:48 <quchen> Three lines above
02:06:06 <quchen> It's a modified version of parMap that uses parListChunked instead of parList.
02:06:25 <quchen> If your list is small, you can use parMap. For anything larger, I'd use parMapChunked.
02:06:52 <av_> quchen: OK
02:07:01 <av_> merijn: thanks
02:07:38 <av_> quchen: where do I find parListChunked anyway?
02:07:59 <quchen> It's not in a library I think. I don't know why.
02:09:40 <haskell-herbert> alexHaskell: hallo
02:09:55 <alexHaskell> haskell-herbert: hi
02:10:15 <haskell-herbert> a3Dman: hi
02:12:44 <konstantin> Hey, I just try to learn Haskell so I am reading learnyouahaskell. Now I am a little bit confused how Haskell compares lists.
02:13:53 <konstantin> There is an example where it shows that [3,2,1] > [2,10,100] is true and it says that haskell compares from left to right. But then it would be 3 is bigger than 2 and then 2 is bigger than 10 which isn't true?
02:14:20 <Cale> konstantin: It doesn't compare the second element in that case.
02:14:38 <Cale> 3 > 2, so [3,2,1] > [2,10,100]
02:14:49 <Cale> Only if the first elements are equal, do you compare the tails
02:15:03 <Cale> It's similar to how words are ordered in a dictionary
02:15:14 <konstantin> thank you :)
02:15:40 <konstantin> I bet I will ask some more stuff in the next days :)
02:18:48 <konstantin> Cale: And if one list is smaller than the other haskell asssumes that the longer list is filled with 0? So [1,2] > [1,2,3] is like [1,2,0] > [1,2,3]?
02:19:13 <Cale> konstantin: No, it's just that the empty list is smaller than any other
02:19:37 <Cale> comparing with 0 wouldn't work in the case of negative values for example
02:19:46 <Cale> and it wouldn't even mean anything in cases of other types
02:20:27 <konstantin> mhh thats weird :D
02:21:32 <konstantin> because first haskell compares the items of the list but if one list is smaller it compares the length of the list?
02:22:47 <Cale> Every list is either the empty list [], or it is a list of the form (x:xs) with a first element x, and tail xs
02:23:51 <Cale> When comparing two lists, if both lists are empty, then they are obviously equal. The empty list is less than any nonempty list.
02:24:38 <Cale> To compare two nonempty lists, (x:xs) and (y:ys), compare x and y. If the result is anything but equal, that's the result of the comparison. If x and y are equal, then compare xs and ys.
02:24:53 <tsahyt> Are there any guidelines for naming modules? Say I'm writing a parser for some language, should it be in Language.something or Text.something?
02:25:17 <Cale> tsahyt: Those seem like good options
02:25:18 <Ferdirand> in real world dictionaries, a word that is a prefix of another also comes before it
02:25:41 <Cale> For example, you would expect to find cat before catamaran in the dictionary.
02:25:57 <konstantin> Ahh yeah I got it ;)
02:26:17 <konstantin> Thank you for you patience
02:27:01 <tsahyt> I guess it's a logical issue. Is parsing a function on the text or on the language definition?
02:27:20 <tsahyt> From that I'd go with the former since it maps an input text to an AST
02:28:59 <tsahyt> so to get back to my original question, is there a writeup somewhere? Some categories seem incredibly broad, like Data for example.
02:30:07 <tsahyt> Also, is megaparsec the preferred parser library for user facing parsers these days?
02:39:45 <alexv111> Is there a way to tell stack to install 32 bit GHC?
02:39:57 <alexv111> on 64 bit system?
02:52:40 * hackagebot clash-prelude 0.10.9 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.9 (ChristiaanBaaij)
02:52:42 * hackagebot clash-lib 0.6.17 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.17 (ChristiaanBaaij)
02:52:44 * hackagebot clash-vhdl 0.6.13 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.13 (ChristiaanBaaij)
02:57:40 * hackagebot clash-ghc 0.6.19 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.19 (ChristiaanBaaij)
03:04:49 <tobiasBora> Hello,
03:05:36 <tobiasBora> I would like to install diagrams-gtk, but my cabal version is 1.22.8 while "The package 'cairo' requires Cabal library version -any && >=1.24"
03:06:02 <magneticduck> tobiasBora: any reason to not upgrade cabal?
03:06:25 <magneticduck> also -- nowdays it seems like the best practice for dealing with dependencies is either nix or stack
03:06:34 <magneticduck> might want to look into that if you're so inclined
03:06:35 <tobiasBora> magneticduck: Well I don't know how to do since I'm already up to date with the debian testing repo...
03:07:01 <tobiasBora> magneticduck: I also tried stack, but it doesn't manage to solve my depends...
03:07:02 <mniip> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html#t:Coercible
03:07:07 <mniip> what's the (~R#) mean
03:07:23 <magneticduck> tobiasBora: 1) cabal update ; cabal install cabal
03:07:31 <magneticduck> or, more ideally, 2) get stack working
03:07:34 <magneticduck> it works, I guarantee it ^^
03:07:54 <tobiasBora> What is the difference between nix and stack ?
03:08:06 <hexagoxel> tobiasBora: try installing `Cabal` manually first.
03:08:09 <hexagoxel> (the library)
03:08:13 <magneticduck> well, for starters, they're totally different =P
03:08:28 <magneticduck> stack is arguably simpler and has less of a learning curve
03:08:42 <magneticduck> it's also totally adequate for making your life with dependencies much easier
03:08:45 <tobiasBora> Does one of them allow to have several packages version/haskell version (amd/32/64...) on the same machine ?
03:08:46 <hexagoxel> someone reported that that fixed a similar problem recently.
03:08:47 <magneticduck> nix is... a thing in itself
03:08:56 <magneticduck> both of them allow that
03:09:13 <tobiasBora> What do you mean by a thing in itself ? ^^
03:09:16 <magneticduck> nix isn't specific to Haskell
03:09:39 <magneticduck> in fact, it's used as the foundation for NixOS
03:10:10 <magneticduck> in a single sentence, you could say that nix lets you describe build processes as expressions in a pure, lazy functional language
03:10:22 <mniip> jle`: poke
03:10:36 <magneticduck> it happens to be popular with Haskellers because it shares our philosophy, and has nice support for Haskell
03:10:46 <magneticduck> but it does a whole lot more, and it might take a little time to get up to speed with it
03:11:02 <magneticduck> stack seems to be the industry standard of sorts for Haskell
03:13:26 <quchen> Stack is a wrapper around Cabal that makes things fairly easy.
03:13:38 <quchen> For some value of "things".
03:14:13 <magneticduck> well that's.. concise?
03:16:28 <tobiasBora> magneticduck: Interesting, I didn't know nix before !
03:16:37 <tobiasBora> And here is the error I have with stack :
03:16:41 <tobiasBora> --  Failure when adding dependencies:    
03:16:43 <tobiasBora>       Chart: needed (>=1.7 && <1.8), 1.5.4 found (latest applicable is 1.7.1)
03:16:45 <tobiasBora>       diagrams-svg: needed (>=1.4 && <1.5), 1.3.1.10 found (latest applicable is 1.4.0.2)
03:16:47 <tobiasBora>     needed for package Chart-diagrams-1.7.1
03:16:51 <tobiasBora> How would you deal with it ?
03:17:22 <magneticduck> you're using a pitifully outdated package set
03:18:17 <tobiasBora> Well I already run stack update...
03:18:37 <magneticduck> right, but you need to specify what package set you want to use
03:18:54 <magneticduck> in stack.yaml iirc
03:19:02 <tobiasBora> Hum I've never heard about package set before.
03:19:24 <tobiasBora> in the extra-depts ?
03:20:31 <tobiasBora> Here is my stack.yaml : http://paste.debian.net/730171
03:20:55 <tobiasBora> All the add in extra-depts are things that stack told me to put
03:21:29 <magneticduck> uh, no
03:21:38 <mniip> I wonder
03:21:45 <magneticduck> those look like things that can be found by the resolver
03:22:01 <mniip> did anyone come up with a package to assist with induction on GHC type-level numbers?
03:22:06 <magneticduck> just set the resolver version to a later one, with the package versions you're looking for 
03:23:01 <tobiasBora> magneticduck: The last one is lts-6.2 ?
03:23:12 <tobiasBora> It's strange it doesn't do it by itself..
03:23:46 <magneticduck> that's a very interesting set of dependencies
03:24:25 <magneticduck> you appear to be writing .. a .. svg-to-audio converter?
03:25:29 <tobiasBora> magneticduck: Well some basic code needs svg, some others needs alsa...
03:25:55 <tobiasBora> And can't I use stack to install deps for my whole system ?
03:26:22 <magneticduck> er, stack is a build tool, not a deployment system
03:26:40 <magneticduck> s/deployment system/package manager
03:27:04 <ahihi> now I really want an svg-to-audio converter
03:27:48 <tobiasBora> By whole system I mean "why couldn't I use stack to install deps that I want to run with a basic "stack ghci" ?"
03:28:00 <magneticduck> uh, you can
03:28:12 <tobiasBora> For example let's imagine I often use ghci to plot some basic functions
03:28:36 <magneticduck> (stack ghci is a thing)
03:28:43 <magneticduck> (yes you can use it)
03:29:07 <tobiasBora> So it's not bad to have a stack.yaml file with several unrelated deps right ?
03:29:25 <tobiasBora> (the stack in .stack/global-project/stack.yaml)
03:31:54 <nilof> Question about applicative
03:32:07 <nilof> you can construct fmap from pure and <*>
03:32:41 * hackagebot pgdl 10.0 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.0 (sifmelcara)
03:32:42 <nilof> can you formulate an applicative in terms of just fmap, pure, and something else like for monads?
03:34:05 <mmercer2> I don't think you can construct fmap with pure and <*>?
03:34:20 <mniip> you can
03:34:42 <magneticduck> @type (<*>) . pure
03:34:43 <lambdabot> Applicative f => (a -> b) -> f a -> f b
03:34:52 <mmercer2> hmm right
03:35:16 <mmercer2> of course.. brain fart
03:35:27 <mniip> nilof, "like for monads"?
03:35:27 <mmercer2> you can construct not just fmap but also liftA2, liftA3 ...
03:35:44 <mniip> elaborate
03:35:58 <nilof> well, a monad can be completely specified by fmap, pure(return), and join
03:36:09 <mniip> ah, the 3 equivalent definitions of monads
03:36:17 <mniip> yes, applicative has an alternative definition too
03:36:37 <mniip> class Functor f => Applicative f where unit :: f (); (**) :: f a -> f b -> f (a, b)
03:37:09 <koz_> mniip: That's the lax monoidal functor definition right?
03:37:23 <mniip> possibly
03:37:29 <mniip> (my CT isn't strong enogh)
03:37:37 <koz_> I recall this being mentioned on the Typeclassopedia. And mine isn't really either...
03:37:57 <mniip> in fact my CT isn't even pointed
03:38:28 <nilof> I was thinking if there is some formulation that makes monads as a special case of applicative more explicit
03:39:31 <mniip> applicatives don't come up in CT very often
03:40:02 <koz_> :t >>=
03:40:03 <lambdabot> parse error on input ‘>>=’
03:40:07 <koz_> :t (>>=)
03:40:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:40:10 <mniip> because they rely on the Set/Hask category a lot (in particular, its internal hom-functor and (e,)-(e->) adjunction)
03:40:14 <koz_> :t (=<<)
03:40:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
03:40:25 <koz_> :t <*>
03:40:27 <lambdabot> parse error on input ‘<*>’
03:40:31 <koz_> :t (<*>)
03:40:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:40:45 <koz_> I think those make it abundantly clear, nilof. :P
03:41:20 <koz_> If you compare (=<<) and (<*>), you can see it. pure and return are the same thing.
03:41:43 <nilof> OK, so it's best compared with the Join formulation of monads
03:41:49 <nilof> *bind
03:41:53 <nilof> sorry
03:42:04 <mniip> :t (pure <*>)
03:42:05 <lambdabot> (b -> a) -> b -> b
03:43:31 <nilof> :t join
03:43:32 <lambdabot> Monad m => m (m a) -> m a
03:43:59 <mniip> unrelated question: what are the most common schemes of induction?
03:44:52 <mniip> obviously, P(0) and P(n) => P(n + 1)
03:44:52 <koz_> mniip: I'm not sure I understand what you mean.
03:45:00 <koz_> Oh, that.
03:45:06 <koz_> There's also structural induction and invariants.
03:45:33 <mniip> P(1), P(n) => P(2n), P(n) => P(2n+1)
03:45:39 <mniip> is also common but there's the problem
03:45:52 <mniip> in the context I'm talking about natural numbers start from 0
03:46:01 <koz_> You can start inducing from anywhere.
03:46:04 <nilof> :t (**)
03:46:05 <lambdabot> Floating a => a -> a -> a
03:46:17 <koz_> As long as your argument doesn't lean on anything 'below' where you started.
03:46:37 <mniip> koz_, I'm thinking of writing a GHC.TypeLits induction witness library
03:46:45 <nilof> :t (*)
03:46:46 <lambdabot> Num a => a -> a -> a
03:46:48 <mniip> but I'm not sure how to handle the logarithmic induction issue
03:47:01 <nilof> :t <*>
03:47:02 <lambdabot> parse error on input ‘<*>’
03:47:03 <koz_> mniip: Ah, OK. For this, you might need an expert. I'm just a noob. :P
03:47:18 <nilof> :t (<*>)
03:47:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:47:28 <nilof> :t (<**>)
03:47:29 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
03:47:35 <mniip> one solution is P(n) => P(2n+1), P(n) => P(2n+2)
03:47:40 <mniip> but would that be easy to use
03:47:41 <koz_> nilof: Are you trying to find the type of every non-alphanumeric sequence of characters as an operator?
03:47:54 <mniip> another solution is to give up and allow multiple proofs for P(0)
03:47:59 <nilof> :t (<*> id)
03:48:01 <lambdabot> (a -> a -> b) -> a -> b
03:49:48 <nilof> :t (<*> (pure id))
03:49:49 <lambdabot> Applicative f => f ((a -> a) -> b) -> f b
03:49:55 <mniip> where's jle when you need him
03:50:12 <koz_> He'll be around eventually.
04:21:27 <rydgel> Did someone tried Halive?
04:43:38 <jakub_> Hi, I am trying to use `zippers` package: `let a = zipper "hello" & fromWithin traverse & tugs rightward 3` how can I collect everything left of the focus, i.e. "hel" or "hell"?
04:49:32 <ertesx> now that all types can be promoted, is there a way to promote functions to type families automatically?  this is not about my own functions, but about those defined in a library
04:50:18 <coppro> try adga or idris :P
04:51:24 <Xandaros> Not yet, I'm afraid
04:51:29 <ertesx> unfortunately there is no implementation of the snap framework for agda/idris ;)
04:51:40 <ertesx> neither for lucid and clay
04:52:21 <ertesx> s/for/of/
04:54:21 <merijn> ertesx: If you want dependently typed web-programming, try Ur/Web? :)
04:54:34 <merijn> ertesx: http://www.impredicative.com/ur/
04:55:07 <merijn> ertesx: It's not fully dependent, but it does have stuff like row polymorphic records, etc.
04:56:08 <ertesx> merijn: actually what i want is *haskell* programming…  at this point i'd rather wait for the necessary language features than switch to a different language
04:56:31 <ertesx> merijn: also we have row-polymorphic records, too, just not builtin, e.g. vinyl
04:57:13 <merijn> ertesx: I don't consider vinyl to have row-polymorphic records unless they can now do O(1) indexing
04:57:49 <ertesx> merijn: that's actually the reason i'm asking…  i'd like to use stuff like Map on the type level
04:58:38 <merijn> ertesx: Even if you don't plan to use it, I'd still recommend having a look at Ur, it's really cool (if slightly syntax, due to being 50% ML inspired and 50% haskell inspired >.>)
04:59:14 <merijn> ertesx: You can do a type-level map in haskell using association lists, but it's not brilliant
05:01:32 <ertesx> merijn: i've actually read its documentation…  it was when it first as announced (on haskell-cafe?  i don't remember)…  i didn't like it that much, even though i liked the idea
05:02:03 <ertesx> merijn: association lists cause O(n)
05:02:26 <ertesx> and i'm not sure i can implement an efficient type-level Map myself
05:02:44 * hackagebot distributed-process 0.6.2 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.2 (FacundoDominguez)
05:02:46 * hackagebot distributed-process-tests 0.4.6 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.6 (FacundoDominguez)
05:03:01 <ertesx> merijn: though a type-level HashMap would also work, and with enough randomness it would practically balance itself
05:06:05 <ironChicken> in parsec, i have a parser which goes: `do { xs <- ((try p1) <|> (try p2)) `sepBy` spaces; ... }` where each parser (p1, p2, etc.) generates a value of type Foo (Foo has several value contructors)
05:06:20 <ironChicken> how can i, in the case that one of the space separated strings is not parsable by any of the parsers, cause the whole parser to fail?
05:06:34 <ironChicken>  at the moment i just get a list of all the parsable ones up to, but not including, the first invalid one
05:06:48 <merijn> ertesx: O(n), but at compiletime, so it's not an issue for your actual program
05:07:06 <ertesx> ironChicken: parse something distinct *after* those
05:07:22 <merijn> ironChicken: Read this: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
05:07:38 <ertesx> ironChicken: for example EOF or a closing parenthesis…  that would be the simplest way
05:09:22 <ertesx> merijn: if the constructor recursion is type-directed (example: List :: [*] -> *), it affects the value level, too
05:11:38 <ironChicken> ertesx: yay! that seems to work
05:12:12 <ironChicken> merijn: thanks for that. i've noticed that article quite a few times but for some reason tried to avoid reading it :-/
05:13:51 <merijn> ironChicken: I mention it because your use of 'try' in that example seems suspect :)
05:27:18 <ironChicken> merijn: yeah, possibly. so every space-sparated string is a Foo. i'm using try because each one could be any kind of Foo
05:28:30 <ironChicken> i do get my errors in the correct position in the input at least
05:28:30 <ertesx> ironChicken: if each of them start with a clearly different token, that's fine…  but it should really be handled by the individual parsers
05:29:34 <ironChicken> ertesx: which "it" should be handled?
05:29:43 <ertesx> backtracking
05:30:08 <ironChicken> ok
05:30:12 <magneticduck> ironChicken: have you noticed how symbol names in most languages can't start with numbers? ^^
05:30:27 <ertesx> ironChicken: as soon as a parser recognises that it can't be anything else it *should* consume
05:30:27 <magneticduck> simple syntaxes are nice
05:33:12 <ertesx> (alternatively you can use an arrow/applicative parser that tries all branches at the same time and reports all errors)
05:34:07 <ironChicken> http://pastebin.com/xw493qNJ
05:34:20 <ironChicken> that was the abstraction of my problem
05:34:41 <ironChicken> although it got a bit convoluted because i originall thought the problem was somewhere else
05:35:50 <ironChicken> so i think you're arguing that fooBox and barBox should take responsibility for backtracking in the case that they can't parse the current input
05:36:05 <ironChicken> and that line should not do the backtracking
05:37:45 * hackagebot hquantlib 0.0.3.0 - HQuantLib is a port of essencial parts of QuantLib to Haskell  https://hackage.haskell.org/package/hquantlib-0.0.3.0 (PavelRyzhov)
05:47:45 * hackagebot ansigraph 0.2.0.0 - Terminal-based graphing via ANSI and Unicode  https://hackage.haskell.org/package/ansigraph-0.2.0.0 (Cliff_Harvey)
06:02:46 * hackagebot yesod-auth-oauth2 0.1.9 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.9 (jferris)
06:07:33 <quchen> Does anyone know the paper that talks about how to desugar nested patterns in `case` into nested `case` blocks of simple patterns?
06:07:44 <quchen> I remember someone mentioning it (a long time ago)
06:10:59 <JuanDaugherty> it's a publicly logged channel
06:20:09 <hodapp> I'll search my logs for 'desugar' or something
06:21:08 <hodapp> though, my logs go back only to 2013 November or so
06:23:01 <quchen> hodapp: There's IRCBrowse as well, but I couldn't find it
06:23:12 <hodapp> are folks using https://commercialhaskell.github.io/intero/ much yet? I installed it yesterday
06:23:13 <quchen> Maybe it was quoted in another paper
06:23:42 <sbrg> hodapp: I've been trying it out. seems pretty cool.
06:23:59 <hodapp> it's been working well for me, though the REPL is still a bit clunky in Emacs (e.g. hit Home or C-a and it moves cursor to before prompt)
06:24:23 <hodapp> and in certain cases when I type ( it interrupts me to open up a file browser to look for something or other
06:24:34 <bergmark> hodapp: i tried and it was great, but then i noticed it doing strange things to my emacs, such as just overwriting buffers that were changed instead of asking to revert
06:24:55 <hodapp> :|
06:26:10 <Cale> quchen: SPJ's book on implementing functional programming languages discusses that at length
06:26:29 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
06:26:58 <quchen> Cale: Ah, great! Incidentially, I also found the quote, it's "Wadler 1987" in the 1992 STG paper
06:29:21 <ertesx> is there anything intero does that haskell-interactive-mode doesn't do?
06:30:01 <tobiasBora> magneticduck: Thank you for your help, I managed to install what I wanted with stack. I just found it's weird not to automatiquely update the solver...
06:30:11 <Ankhers> ertesx: intero is more than just a repl, so yes
06:30:22 <ertesx> Ankhers: so is haskell-interactive-mode
06:30:36 <Ankhers> It is?
06:30:45 <tobiasBora> And since I updated the solver (also the haskell version ???), I now have errors like :
06:30:48 <tobiasBora>     Overlapping instances for Arbitrary (DiscretRange y)
06:30:50 <tobiasBora>       arising from a use of ‘arbitrary’
06:30:52 <ertesx> Ankhers: yes…  it's pretty much a complete IDE
06:30:59 <tobiasBora>     Matching instances:
06:31:01 <tobiasBora>       instance [safe] (Ord a, Arbitrary a) => Arbitrary (Set.Set a)
06:31:03 <tobiasBora>         -- Defined in ‘Test.QuickCheck.Arbitrary’
06:31:05 <tobiasBora>       instance (Arbitrary y, Ord y) => Arbitrary (DiscretRange y)
06:31:07 <tobiasBora>         -- Defined at Haskell_checks_maths.hs:125:10
06:31:09 <tobiasBora> Y
06:31:23 <ertesx> tobiasBora: please use a pastebin for longer code or error messages
06:31:29 <tobiasBora> ertesx: Sorry
06:31:32 <magneticduck> tobiasBora: but at least now, your package versions won't magically change in the future
06:31:59 <tobiasBora> magneticduck: What do you mean ?
06:32:28 <tobiasBora> magneticduck: They seems to have remove all my packages, now I need to install some of them again...
06:33:08 <magneticduck> tobiasBora: once you find a stack configuration that works for your project, you won't have issues of a similar nature in the future
06:33:40 <magneticduck> i.e. when installing it on another computer or trying to use it again in a few years
06:34:23 <tobiasBora> magneticduck: But since I use stack to install things for all of my local scripts (and ghci), it doesn't make sens
06:34:34 <ertesx> there is one interesting feature of intero that haskell-interactive-mode doesn't have:  finding out the type of a subexpression
06:35:02 <ertesx> too bad intero needs stack
06:35:24 <hodapp> ertesx: interesting, how does one do that?
06:35:49 <ertesx> hodapp: i guess it replaces the subexpression by a hole and asks for the type of that hole
06:35:52 <merijn> heh
06:35:55 <ertesx> but i don't know exactly
06:36:01 <merijn> hdevtools has done that for ages?
06:36:14 <merijn> I don't think you need to do something as silly as holes, etc.
06:36:14 <hodapp> ertesx: I didn't mean how does *it* do that, I meant how does a person access that feature :P
06:36:19 <merijn> It just queries the GHC API?
06:36:34 <ertesx> hodapp: don't know…  i'm not using it
06:37:17 <ertesx> merijn: do you by any chance know whether HIM offers access to that feature?  i couldn't find it
06:37:25 <merijn> HIM?
06:37:27 <merijn> What's that?
06:37:37 <bernalex> a Finnish rock band.
06:37:38 <mauke> haskell interactive mode
06:37:39 <ertesx> h-i-m, haskell-interactive-mode =)
06:38:04 <bernalex> pretty interesting to see "HIM" in my IRC at the exact same moment as I put on a song by them.
06:38:27 <ertesx> i just figured i can complete it with dabbrev, because it's a bunch to type
06:38:30 <bernalex> I wish intero worked without stack. I'd check it out in a heartbeat.
06:38:40 <bernalex> intero.el that is.
06:38:48 <ertesx> yeah, it looks interesting, if only for that one feature
06:38:54 <EvanR> you dont want to install stack? or it would actually be a pain
06:38:56 <bernalex> intero itself looks very similar to ghc-ng atm.
06:39:08 <mauke> "stackless haskell"
06:39:10 <ertesx> EvanR: i have a nix-based development environment
06:39:12 <bernalex> EvanR: I don't want stack. I don't use stack. I want nothing to do with it.
06:39:15 <Ankhers> I believe both are made by chris done
06:39:18 <EvanR> so youre morally opposed
06:39:33 <bernalex> EvanR: no. I just have no use for stack, so I don't want yet another complex piece of software to deal with.
06:39:42 <EvanR> one use would be to try intero
06:39:57 <bernalex> EvanR: additionally, it is made for use with stack projects. I have never hacked on a stack project, or had the need to.
06:40:07 <EvanR> until now!
06:40:11 <bernalex> I use cabal-install and am happy with that.
06:40:26 <EvanR> its not like intero is windows only and you have to get a license
06:40:37 <ertesx> without nix i would definitely go for stack
06:41:01 <merijn> ertesx: I don't do emacs, so I have no idea :p
06:41:02 <ertesx> although cabal sandboxes have worked for me
06:41:05 <Ankhers> bernalex: I'm not telling you to switch, but you can test out intero by placing a stack executable somewhere in your PATH and using `stack init` within a project. Don't need to keep anything stack creates if you don't want to.
06:41:08 <bernalex> stack doesn't solve anything for me. it is useless to me. I'm not going to start using an editor plug-in that forces me to use a big piece of software I don't need or want.
06:41:37 <bernalex> Ankhers: I know. I still need to install stack and use stack to do that. I can't be bothered with that.
06:41:59 <sbrg> bernalex: then don't use intero
06:42:02 <Ankhers> Fair enough. Just figured if you wanted to test it it is fairly simple.
06:42:03 <bernalex> I'd rather hack intero to work without stack. or just live without it. I'm quite happy with ghc-mod. afaiu, the fp-complete guys couldn't get ghc-mod to work properly.
06:42:04 <sbrg> ¯\_(ツ)_/¯
06:42:18 <bernalex> Ankhers: yeah, chrisdone already explained this to me on reddit.
06:42:26 <bernalex> sbrg: I am not using intero.
06:42:43 <EvanR> sounds like moral opposition, which is ok
06:42:51 <sbrg> ghc-mod has been a pain to get to work correctly reliably for a while. I also abandoned it in favor of just using flycheck with emacs.
06:42:58 <bernalex> EvanR: I have no moral opposition to use stack.
06:42:58 <sbrg> which I think uses the repl or some such.
06:43:01 <Ankhers> Most people I hear from have issues with ghc-mod being setup reliably.
06:43:02 <bernalex> sbrg: I use ghc-mod with flycheck.
06:43:10 <EvanR> "i dont like the idea of it" ;)
06:43:25 <EvanR> enough undefined terms all start to look the same
06:43:26 <Ankhers> Though, that may be skewed as the people that have it working are not complainig...
06:43:43 <bernalex> EvanR: I don't need/want stack. it solves nothing for me. it contributes nothing. that is not about morals. nor did I say that I don't like the idea of it -- that is a strawman.
06:43:55 * ertesx didn't intend to cause a development environment flamewar
06:44:04 <bernalex> Ankhers: I've heard lots of complaints too. I had some problems myself a long time ago.
06:44:44 <bernalex> ertesx: if it appears that I am flaming, I want to make it clear that I am not. all I said was that I wish intero.el worked with cabal-install. and in came the stack-brigade. ;)
06:45:00 <ertesx> but indeed i don't see any inherent reason why intero has to be stack-bound
06:45:10 <bernalex> I don't care about stack at all. if it works for people who have problems with cabal-install, then great.
06:45:29 <Ankhers> ertesx: Probably because it comes from fpcomplete. Which stack also comes from.
06:45:36 <ertesx> bernalex: stack is useful for deployment scenarios
06:45:43 <ertesx> but it's not the only option
06:45:44 <Ankhers> For better or worse, I feel like they are going to develop everything to use stack.
06:45:52 <bernalex> ertesx: because it's made by fp-complete who also make stack. you could view it as lock-in, or you could view it more favourably as fp complete just wanting to make their tools easier to use at work.
06:46:11 <ertesx> i'm sure it's mostly the latter
06:46:27 <ertesx> and i guess one could add support for other environments
06:46:28 <bernalex> ertesx: Ankhers: they'll definitely try to keep everything revolving around stack. which is mostly fine, since it is free software. anyone could un-stack it if they were willing to put in the work.
06:46:58 <ertesx> anyway, haskell-interactive-mode works
06:47:08 <bernalex> ertesx: people keep telling me that stack is useful for deployment and that I must be using haskell wrong if I don't have problems with deployment that can only be solved with stack. idk. I have deployed things before without using stack. it was fine.
06:47:24 <quicksilver> you just didn't understand that things weren't fine
06:47:27 <ertesx> and i could probably get a ghc-mod module, if i wanted, but i'm not that desparate for that one particular feature =)
06:47:27 <quicksilver> you were living a lie bernalex 
06:47:36 <bernalex> quicksilver: this is essentially the argument I keep getting.
06:47:45 <quicksilver> bernalex: i was being facetious, I hope that's clear :)
06:47:57 <bernalex> quicksilver: yes, I'm just underlining how to-the-point your satire was.
06:48:00 <EvanR> youre all spoiled by the existence of only 2 technologies
06:48:02 <quicksilver> ^5
06:48:21 <hodapp> you're all spoiled by Haskell
06:48:30 <EvanR> go to ruby or javascript and witness the deluge of deployment / testing / frameworking / dev env / version management of the bi-week
06:48:40 <EvanR> which you probably cant argue against
06:48:42 <ertesx> bernalex: there are basically nix and stack, the latter being basically a haskell-specific nix…  without nix i would definitely go for stack, because i see its merit
06:48:55 <hodapp> ertesx: stack indeed has some integration with nix already
06:49:06 <bernalex> ertesx: I don't use either. I just compile things. and then deploy them. and then it works.
06:49:20 <bernalex> ertesx: I sometimes use portage though. that's even easier.
06:49:31 <Ankhers> I have not put in much time with it, but I have been unable to understand what stack offers for nix.
06:49:56 <mauke> EvanR: haskell is pretty hard to use compared to perl
06:50:23 <EvanR> really? the perl tools are better?
06:50:26 <ertesx> Ankhers: i don't think it offers anything…  nix already handles everything from the compiler to haskell library to any other library
06:50:38 <bernalex> ertesx: are you using a distro that uses nix?
06:50:46 <ertesx> bernalex: yeah
06:50:50 <bernalex> then I would use nix.
06:51:09 <ertesx> Ankhers: there is some merit to using stack *only*
06:51:14 <bernalex> in Gentoo I would use portage. if a distro did not have either nix, portage, paludis, or pkgcore, I would maybe need stack for something.
06:51:37 <ertesx> Ankhers: nix *insists* on handling everything from the system libraries to the compiler to the project…  stack does not
06:52:12 <ertesx> bernalex: i'd use nix everywhere, if only to get easy cooperation between multiple hosts and reproducible builds
06:52:23 <bernalex> using nix on distros that don't use nix isn't a good idea ime.
06:52:30 <quchen> Has anyone used Intero?            (3 pages of rambling about Stack)
06:52:38 <hodapp> quchen: IT WASN'T MY FAULT
06:52:47 <ertesx> bernalex: in fact i *do* use nix everywhere, for example i frequently deploy to CentOS
06:53:25 <bernalex> ertesx: interesting. I guess I would "try harder" to use nix if I weren't on a distro that already had a somewhat decent package manager.
06:53:41 <bernalex> ertesx: do you know if there were any progress on hsnix?
06:54:45 <ertesx> bernalex: i loved portage when i used it, and i hated pacman when i switched to arch (i switched because i became impatient)
06:54:50 <ertesx> bernalex: sorry
06:54:51 <ertesx> no
06:55:02 <ertesx> i wouldn't even know what it does
06:55:13 <bernalex> ertesx: it's just nix ported to haskell.
06:56:16 <hodapp> apparently HSNIX is also the Hartford Strategic Income Fund Class I.
06:56:39 <Ankhers> Yeah, nothing useful when googling hsnix comes up.
06:57:01 <bernalex> ertesx: I used to have confidence in Nix OS, but then realised they didn't do any real GPG signing/verification, and that they didn't make packages as modular as I would like (I want as many USE flags as I have in Gentoo), nor could I compile everything myself (I think a lot of packages were binary only). do you know if any of this has improved? as someone who's used portage, maybe you understand the value
06:57:03 <bernalex> in customisation via USE flags better than most people I've asked this question to.
06:57:18 <mauke> EvanR: I think so
06:57:26 <bernalex> my "distro hope" lately has been GNU Guix, but IDK how well that's progressing.
06:57:29 <Ankhers> searching for "hsnix haskell" lead me to some IRC logs that stated the development has stopped.
06:57:39 <bernalex> hodapp: Ankhers: it might have been hnix.
06:58:06 <bernalex> hodapp: Ankhers: oh, no, hnix was just the haskell parser for nix.
06:58:43 <bernalex> I can't fix hsnix either. so it's probably dead then, like you say, Ankhers.
06:58:48 <bernalex> s/fix/find/
06:59:09 <hodapp> I'm just not seeing any reference to it ever being alive
06:59:41 <ertesx> bernalex: i think, you have a wrong idea about the whole thing: there is no difference between "binary" and "source"…  if you get a binary package, you get it because it was already compiled, and if you were to compile it yourself, you would get the same result
07:00:04 <bernalex> ertesx: it was already compiled -- on someone else's computer.
07:00:30 <ertesx> bernalex: you can easily say that you want to compile everything yourself
07:01:18 <bernalex> ertesx: for all packages? IIRC there were several packages I wanted that I could only get binaries from. maybe I remember wrong though -- it's been a long time.
07:02:00 <ertesx> bernalex: there is a small number of binary packages, but that's stuff like skype you can't get the source code for
07:02:14 <bernalex> ertesx: well that's nice then. but what about mah useflags?
07:02:43 <bernalex> and when I last talked to them, they did not OpenPGP sign central repositories, nor verify them, and they didn't even understand what I meant by MitM.
07:04:03 <ertesx> bernalex: you don't get *flags*, you get configuration in the form of function arguments…  those can be global (like generalised USE flags) or even package-specific (called overriding)…  the build farm just builds with defaults
07:04:18 <ertesx> bernalex: verification works differently though, and it happens…  but this is becoming really off-topic
07:04:33 <bernalex> ertesx: #-offtopic?
07:04:34 <Ankhers> bernalex: You could always make a PR for any packages you want to use and need more flags for. I think they basically start out being just what the creator needs or the most common configuration options. But you are always free to add any options you may need.
07:05:00 <bernalex> Ankhers: if I change from Gentoo, I want to do *less* work. :-P
07:05:11 <bernalex> but, as ertesx correctly points out, this is becoming #-offtopic territory.
07:05:52 <ertesx> bernalex: feel free to /query me, and i'll attempt to explain it, if you're interested
07:06:18 <Ankhers> Last thing: I think more people are using Gentoo than NixOS at the moment. So someone needs to do the work.
07:07:33 <eii2222> hi, I am having troble with haskell installtion and looking for help
07:07:52 <eii2222> have a working ghc set on fedora23
07:07:59 <bernalex> eii2222: you've come to the right place. :) what are you trying to install, and how are you trying to install it?
07:08:08 <eii2222> hi!
07:08:11 <eii2222> thank you
07:08:32 <eii2222> I am trying to install haskell-platform-8.0.1.tar.gz
07:08:39 <eii2222> I ran plarform.sh 
07:08:46 <eii2222> then it stopped at 
07:08:47 <bernalex> eii2222: does fedora not package the platform for you so that you can install it with yum?
07:08:56 <eii2222> src/OS/Win.hs:34:13:
07:09:18 <eii2222> Not in scope: type constructor or class 'C.PackageInstalled'
07:09:36 <mauke> sudo dnf install haskell-platform
07:09:57 <eii2222> I did...
07:10:01 <eii2222> but it's old
07:10:05 <eii2222> 7.9.4
07:10:09 <eii2222> sorry
07:10:11 <eii2222> 7.8.4
07:10:15 <eii2222> wanted to try 8.0.1
07:10:20 <bernalex> mauke: oh they don't use yum any more? I have not used fedora since fc6. :p
07:10:31 <mauke> eii2222: why did you run plarform.sh?
07:10:32 <eii2222> no, they use dnf now ..
07:10:52 <eii2222> because it is there :-)
07:10:59 <eii2222> README says I need to run it 
07:11:07 <mauke> interesting
07:11:10 <mauke> the website disagrees
07:11:15 <eii2222> ohh
07:11:39 <mauke> and no, it is not there
07:12:09 <eii2222> in the BUIDLING section of README, it says
07:12:26 <eii2222> In either the source repo or unpacked source tarball, simply run this:     ./platform.sh $PATH_TO_GHC_BINDIST_TARBALL
07:12:29 <mauke> there's no README in there either
07:12:35 <eii2222> ohh
07:12:36 <mauke> what did I download?
07:12:48 * hackagebot fbmessenger-api 0.1.0.0 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.0.0 (mseri)
07:13:05 <mauke> I've got haskell-platform-8.0.1-unknown-posix--minimal-x86_64.tar.gz
07:13:12 <eii2222> I got this
07:13:22 <eii2222> haskell-platform-8.0.1.tar.gz
07:13:39 <mauke> ooh, you downloaded the source package
07:14:21 <mauke> any reason you're compiling from source?
07:15:33 <eii2222> the installation guide for fedora says "dnf install haskell-platform"
07:15:54 <eii2222> but I've already done it and it installs 7.8.4
07:16:20 <eii2222> that's why I am trying to install it from it
07:17:03 <mauke> https://www.haskell.org/platform/linux.html#linux-generic
07:17:15 <Aruro> intero on emacs can not find stack, file error searching for program
07:17:29 <Aruro> system OS x
07:17:52 <Ankhers> Aruro: Do you have stack on your machine? Can you use it from the command line?
07:18:11 <eii2222> ohh
07:18:14 <eii2222> thank you Mauke
07:18:16 <eii2222> checking it now
07:19:40 <Aruro> Ankhers: yes i do, stack is not in path issue?
07:20:00 <Aruro> from terminal stack could install intero
07:20:03 <Aruro> without problem
07:20:16 <Ankhers> Aruro: Can you use `M-S ! stack --version`
07:21:03 <Aruro> bash tells stack not found
07:21:15 <Ankhers> How are you starting emacs?
07:21:32 <Aruro> from icon?
07:21:47 <Aruro> in dock
07:22:01 <Aruro> i can try emacs -nw
07:22:10 <Ankhers> I think that is the issue.
07:22:38 <Ankhers> https://github.com/haskell/haskell-mode/wiki/PATH explains the issue. I think it is the problem you are seeing.
07:22:48 * hackagebot fbmessenger-api 0.1.0.1 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.0.1 (mseri)
07:24:31 <Ankhers> I'm not sure if there is a way to tell intero to use a specific executable.
07:25:03 <eii2222> Mauke, I've installed it and now I have ghc 8.0.1 on my machine
07:25:06 <eii2222> thank you!
07:25:22 <mauke> nice
07:26:09 <eii2222> yup!
07:26:33 <eii2222> have a sudoku solver and wanted to try the latest ghc
07:26:36 <eii2222> thank you again
07:27:16 <Aruro> Ankhers: ty, seems the case
07:32:48 * hackagebot fbmessenger-api 0.1.0.2 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.0.2 (mseri)
07:50:05 <ocramz> hullo!
07:51:07 <ocramz> does anyone have experience with dynamic linking from GHCi in OSX?
07:51:26 <ocramz> I think there's a bug
07:52:05 <ocramz> but I'd rather seek other opinions first
07:52:49 * hackagebot web-plugins 0.2.9 - dynamic plugin system for web applications  https://hackage.haskell.org/package/web-plugins-0.2.9 (JeremyShaw)
07:53:00 <ocramz> namely, when linking more than one dynlib, and symbols in one require symbols in the other one
07:55:15 <`Guest00000> which haskell compiler produces fastest code?
07:55:41 <bernalex> GHC produces code at all, so I guess GHC.
07:56:13 <simpson> `Guest00000: Which compilers are you comparing?
07:56:35 <liste> OTOH JHC does whole program optimization
07:57:49 * hackagebot docvim 0.1.0.0 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.1.0.0 (wincent)
08:00:48 <merijn> ocramz: Does GHCI even support dynamic linking?
08:02:16 <ocramz> merijn: what does ghci do when I say `ghci Test.hs ... -L${LIBDIR} -llib` ?
08:02:28 <merijn> no idea
08:02:49 <ocramz> erm
08:04:03 <ocramz> merijn: I guess you've tinkered with the FFI before?
08:04:04 <EvanR> i know it gives a runtime error about not being able to open a library when i try to evaluate something in a gloss module
08:04:08 <merijn> ocramz: Yes
08:04:14 <geekosaur> ghci can dynamic link. (it can't static link in recent versionsm as I understand it, whereas it used to)
08:04:59 <ocramz> geekosaur: exactly. I care about dynlibs, or .so 
08:05:02 <geekosaur> but there are some limitations. you probably want to ask in #ghc and prtovide specific versions because there's been a lot of changes there in recentish versions
08:05:27 <geekosaur> (7.8, 7.10, 8.0 all have changes in that area)
08:05:59 <geekosaur> and platform because Windows and OS X both have issues Linux doesn't
08:06:03 <ocramz> geekosaur: I'm noticing a problem with 7.10.3 under OSX, at present. Whereas the same code with the same deps builds fine in Ubuntu
08:12:49 * hackagebot docvim 0.2.0.0 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.2.0.0 (wincent)
08:13:17 <roconnor__> How come ghci doesn't accept this:  do { let x = 5; [5] }
08:13:22 <roconnor__> er
08:13:24 <roconnor__> How come ghci doesn't accept this:  do { let x = 5; [x] }
08:13:40 <roconnor__> it doesn't parse either actually
08:14:11 <roconnor__> > do { let x = 5; [x] }
08:14:12 <lambdabot>  <hint>:1:21: parse error on input ‘}’
08:14:25 <phanimah1sh> No idea. I don't see anything obviously wrong there.
08:14:31 <dolio> do { let {x = 5 ; [x] } }
08:14:36 <roconnor__> oh
08:14:53 <roconnor__> > do { let {x = 5}; [x] }
08:14:55 <lambdabot>  [5]
08:15:05 <phanimah1sh> Wut? why?
08:15:14 <EvanR> is that necessary when using separate lines?
08:15:24 <magneticduck> no
08:15:29 <magneticduck> huh, I hadn't noticed that
08:15:35 <roconnor__> because let is a set of mutually recursive bindings
08:15:53 <roconnor__> and the ; is abiguous;  is it the end of the binding or the end of the block of bindings.
08:16:09 <ertesx> roconnor__: it changed at some point…  GHC used to accept it
08:16:10 <roconnor__> so if we are going to use curly brace notation for a do block we need to also use it for the set of let bindings.
08:16:13 <EvanR> haskell's forgotten C syntax ;)
08:16:26 <roconnor__> ertesx: oh really?
08:16:46 <ertesx> yeah, i think it changed with 7.6 or 7.8
08:16:58 <dolio> It's possible that the Haskell report requires that that be parsed correctly.
08:17:10 <ertesx> at some point they introduced a slight syntax change…  it came together with the new layout rules for if/then/else
08:17:37 <phanimah1sh> Interesting
08:17:49 <roconnor__> it seems sensible now.
08:17:50 * hackagebot web-routes-boomerang 0.28.4.2 - Use boomerang for type-safe URL parsers/printers  https://hackage.haskell.org/package/web-routes-boomerang-0.28.4.2 (JeremyShaw)
08:17:54 <geekosaur> only change I can recall there was back in 6.x
08:18:37 <geekosaur> someone demonstrated a program that was ambiguous by haskell98 layout disambiguation rules for a case similar to that (two different parses produced valid syntax)
08:19:15 <dolio> Actually, I guess the rule I'm thinking of wouldn't apply.
08:19:21 <dolio> Since it's about tokenizing.
08:19:31 <dolio> I think.
08:20:14 <roconnor__> let x = 5; [x] ...  is [x] a return type or a pattern match for a second binding.  How much are we willing to parse to figure it out? :D
08:20:56 <ocramz> geekosaur, EvanR, merijn: just for reference, I've written about this bug here: https://stackoverflow.com/questions/37723674/ghci-linking-with-cross-calling-dynlibs-fails-on-osx
08:21:09 <ertesx> i wonder if (do let; []) used to parse
08:21:23 <ertesx> back when (do let x = y; []) did
08:21:43 <EvanR> ocramz: yes thats the exact problem
08:21:44 <dolio> Does that not parse? It seems easier to figure out.
08:21:50 <ertesx> it doesn't
08:22:03 <ertesx> with comprehensions it does, but with 'do' it doesn't
08:22:22 <ertesx> > [0 | let]
08:22:24 <ocramz> EvanR : uggh. Does this mean I have to start developing in a container?
08:22:24 <lambdabot>  [0]
08:22:26 <dolio> Well, with comprehensions the separators is ,
08:22:35 <ertesx> > do let; [0]
08:22:37 <lambdabot>  <hint>:1:12:
08:22:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:22:38 <dolio> So it's even easier.
08:22:40 <merijn> ocramz: Any particular reason you're using gcc?
08:22:44 <ertesx> > do let {}; [0]  -- but this one works
08:22:46 <lambdabot>  [0]
08:23:02 <ocramz> merijn: not really. Should I be using clang?
08:23:39 <roconnor__> Data.Vector.Unboxed.Mutable seems a little under-documented. :D
08:23:56 <merijn> ocramz: I would certainly check. OSX's library/executable format is different from linux' ELF and I don't know whether gcc installations use the system linker or one that ships with gcc
08:24:07 <roconnor__> I'm surprised that splitting two mutable vectors results in two vectors that still overlap according to overlap.
08:24:27 <roconnor__> I'm not sure what will happen if I try to grow one of the split vectors.
08:24:46 <ocramz> merijn: clang should support the same set of flags as gcc I guess? At least the basic ones like -c, -g and -w
08:24:54 <ocramz> I'll check thanks
08:24:56 <merijn> ocramz: Apple's linker has also been a lot more pleasant/flexible for me in the past (it does multi-pass and lazy linking, etc.)
08:25:11 <merijn> ocramz: AFAIK clang's frontend is 100% gcc compatible
08:25:26 <merijn> ocramz: The only exception being warning names, I think? And even a lot of those...
08:25:41 <geekosaur> apple uses ld64; binutils/bfd ld usually has problems with Mach-O
08:26:00 <SweetKatya> hi. if I use debian linux, what would be your recommendation for GUI programming using haskell?
08:26:36 <geekosaur> also note that the "gcc" shipped with every xcode since 4.1 is actually clang
08:26:44 <merijn> True
08:27:09 <ocramz> merijn: however, the C compiler that built the dynlibs I'm depending on was chosen by their configure step, I didn't interfere there. And I've already verified that one of those two dynlibs works fine.
08:27:40 <ertesx> SweetKatya: there are many options on many different levels of abstraction…  you should provide more context:  what's your level of haskell?  what kind of GUI do you want?  what level of abstraction are you going for?
08:28:03 <merijn> Also "tolerance level for GUI bullshit" :)
08:28:23 <EvanR> recommendations for GUI programming... I guess trying not to
08:28:41 <EvanR> the browser has the lowest barriers to entry
08:29:21 <merijn> See if you can get away with unix and commandline only so you can use brick for UI :P
08:29:37 <EvanR> is brick even that nice?
08:29:44 <ertesx> it isn't
08:29:50 <mniip> question
08:30:01 <dolio> roconnor__: That is odd.
08:30:02 <merijn> vty-ui was okayish. Brick is supposedly nicer, haven't tried using it yet
08:30:04 <ertesx> for one thing you can't make it cooperate easily with any FRP framework
08:30:16 <ocramz> "640 KB of RAM ought to be enough for everybody"
08:30:22 <dolio> roconnor__: They're the same underlying arrays when you split. But it's odd that they overlap.
08:30:34 <mniip> I'm thinking of implementing a library of induction witnesses for typelevel naturals
08:30:37 <dolio> Maybe there's an off-by-1 error somewhere.
08:30:40 <mniip> how should I handle logarithmic induction
08:30:48 <ertesx> ironically vty-ui is easy to FRPise
08:31:04 <EvanR> ertesx: exactly what is required for "easy to FRPise" ?
08:31:16 <dolio> roconnor__: You should probably file a bug.
08:32:10 <ertesx> EvanR: flexible control…  for most frameworks a callback-based library is enough, and some (notably AFRP) even prefer event waiting
08:32:33 <ertesx> brick insists on taking control
08:32:47 <roconnor__> Hmm, grow doesn't even do anything in the simplest of cases.
08:33:50 <EvanR> ertesx: callbacks in which direction...
08:34:12 <ertesx> and it does so in an awkward way…  it uses pure state updates, so it can only really be FRPised by AFRP, because all major non-A FRP frameworks require IO
08:34:16 <roconnor__> oh I totally misunderstood grow
08:34:32 <ertesx> EvanR: event callbacks like in vty-ui
08:34:34 <roconnor__> grow is going to make a copy I guess
08:34:41 <dolio> Yeah.
08:34:46 <EvanR> ertesx: oh, youre talking about replacing the gui libs inner workings with some FRP library
08:35:02 <ertesx> EvanR: no, just making the input of a text field a behaviour
08:35:15 <dolio> Although it's a method of the class, so in principle it might not, I guess.
08:35:21 <ertesx> EvanR: that already requires cooperation between the FRP framework and brick
08:35:21 <EvanR> not putting a toolkot or graphics lib on top of the library
08:35:36 <dolio> If there's some way for a vector type to know it doesn't need to make a copy. I don't know how it would, though.
08:35:51 <roconnor__> dolio: if I split a vector a and grow the lower half, I think it will be insane not to make a copy.
08:36:16 <roconnor__> and at that point you had better make the semantics require a copy
08:36:22 <dolio> Yeah, it'd be pretty bad if it just annexed part of another array.
08:36:33 <ertesx> EvanR: usually you don't get a lot of choice there…  SDL is the only library i know that has actual event waiting, so you get to structure your control
08:36:57 <ertesx> in gtk and vty-ui you have to bind to event handlers…  that's fine with most FRP frameworks though
08:36:59 <EvanR> ertesx: ... uhg. this is all a mess 
08:37:28 <ertesx> in brick you don't even get that…  it gives you event handling, but it insists on taking control
08:37:37 <ertesx> so you get the worst of both
08:37:43 <ocramz> EvanR: back at the linker problem; what GHC did you notice it with? 7.10.* ?
08:37:45 <EvanR> what is "taking control"
08:37:50 * hackagebot happstack-authenticate 2.3.4.2 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.2 (JeremyShaw)
08:37:52 <EvanR> ocramz: yes
08:37:55 <ertesx> EvanR: main loop
08:37:57 <EvanR> ok
08:38:15 <ocramz> EvanR : and you have an OSX 10.9 or so
08:38:34 <EvanR> el capitan
08:38:49 <ocramz> ok, so this must be a GHC bug
08:38:56 <ocramz> Good! fun times ahead
08:40:46 <dolio> roconnor__: I could make a vector type that over-allocates, for instance, and can grow cheaply up to the amount it held in reserve.
08:41:03 <ocramz> EvanR: and how did you solve it? 1. try different GHC 2. Linux container 3. flip all the tables
08:43:29 <EvanR> ocramz: i didnt, its still happening
08:43:42 <EvanR> im about to try the no sandbox flag on ghci
08:44:26 <roconnor__> dolio: regarding overlap, nevermind, I'm an idiot.
08:44:51 <roconnor__> They do overlap because I'm using a packed bit vector and splitting in the middle of a machine Word.
08:45:02 <dolio> Oh, I see.
08:45:21 <roconnor__> clever
08:45:50 <roconnor__> well, at least it is unclear what the right answer is.
08:46:05 <roconnor__> maybe a bug in the bit vector library.
08:48:10 <roconnor__> mokus: hey is it a bug in bitvec if you splitAt in the middle of a Word that overlap still returns True?  Is it unsafe to use copy from one to the other in this case?   (Is it unsafe to use move?)
08:48:49 --- mode: ChanServ set +o glguy
08:48:50 --- mode: glguy set -bo *!*@gateway/web/cgi-irc/kiwiirc.com/ip.82.36.109.113 glguy
08:49:41 <roconnor__> dolio: if you are going to have grow copy in some cases you need to have grow copy in all cases because the semantics of sub-vectors of the growing vector changes.
08:53:45 <arcetera> what algo does haskell's sort (from Data.List) use?
08:53:59 <quchen_> arcetera: mergesort
08:54:01 <arcetera> ok
08:54:19 <quchen_> arcetera: It's a very easily readable implementation, you should have a look at the source!
09:00:22 <mokus> roconnor__: unfortunately i'd have to look at the implementation to be sure in this case... i suspect it probably would be unsafe but i'm not 100% sure
09:00:31 <EvanR> is a function with type X -> Type, where X is some type, a dependent type?
09:00:58 <mokus> roconnor__: if you want to open an issue on it i can try to find the time to check it out and document it
09:01:30 <ski> EvanR : no. that's sometimes called a "family"
09:01:51 <EvanR> a type family?
09:02:14 <arcetera> what's the opposite of `head`
09:02:21 <arcetera> (sorry for dumb questions)
09:02:30 <sbrg> arcetera: tail?
09:02:35 <ski> > tail "head"
09:02:35 <sbrg> > tail "foo"
09:02:36 <lambdabot>  "ead"
09:02:36 <lambdabot>  "oo"
09:02:43 <Tuplanolla> I'd say (:).
09:02:44 <liste> last?
09:02:48 <arcetera> liste: there we go
09:02:52 <ski> > last "init"
09:02:54 <lambdabot>  't'
09:03:20 <ski> EvanR : i'm not sure if that term is related
09:03:45 <ertesx> EvanR: a function?  like a type constructor?
09:04:04 <EvanR> the example is... X is a type of indexes or identifiers, and to each one you assign a boring type like Char, Bool, (Int,Bool)
09:04:08 <ertesx> where X ≠ Type?
09:04:16 <EvanR> X is not Type
09:04:48 <ertesx> you mean the value of type X is not a type?
09:04:58 <EvanR> so an indexed family of types, but the target types are regular types not special
09:05:17 <EvanR> X is the index type
09:05:31 <EvanR> like String or Integer
09:05:45 <ertesx> yeah, "family" seems to be the most accurate term, but it's overloaded
09:06:09 <ertesx> for example we refer to Writer as a family of monads, even though its argument is of type Type
09:07:19 <Tuplanolla> Sounds like you're after what set theorists call an indexed family.
09:07:51 * hackagebot protobuf 0.2.1.1 - Google Protocol Buffers via GHC.Generics  https://hackage.haskell.org/package/protobuf-0.2.1.1 (NathanHowell)
09:08:52 <EvanR> so its not a dependent product?
09:09:14 <ertesx> EvanR: i've seen the term "lightweight dependent type", but i don't really like it
09:09:19 <EvanR> haha
09:09:23 <ertesx> haskell has no dependent types, and we shouldn't pretend that it does
09:09:24 <EvanR> lightweight spaceship
09:09:29 <EvanR> this isnt haskell..
09:09:37 <ertesx> oh
09:09:54 <EvanR> i didnt think you could do String -> Type in haskell
09:10:00 <ertesx> it is dependent, if you can use the value of type X in the definition
09:10:14 <ertesx> F : X -> Type
09:10:15 <EvanR> what does use mean
09:10:18 <ertesx> F x = …
09:10:23 <EvanR> foo "a" = Char
09:10:24 <ertesx> that's dependent
09:10:26 <EvanR> foo "b" = Int
09:10:27 <ertesx> yeah
09:10:48 <ertesx> but only if F is actually a function that you can use on the value level
09:10:56 <nitrix> :k Type
09:10:57 <lambdabot> Not in scope: type constructor or class ‘Type’
09:11:05 <nitrix> What's the Type type?
09:11:12 <EvanR> in hasekll its *
09:11:40 <ertesx> F is also dependently typed, if X ≠ Type and you can refer to (x : X) to the right side of (->)
09:11:49 <ertesx> F : (x : X) -> ...
09:14:10 <EvanR> ertesx: i know that part, but im not referring to it
09:14:11 * hackagebot haskell-fake-user-agent 0.0.1 - Simple library for retrieving current user agent strings  https://hackage.haskell.org/package/haskell-fake-user-agent-0.0.1 (grzegorzgolda)
09:14:11 * hackagebot tpdb 1.3.2 - Data Type for Rewriting Systems  https://hackage.haskell.org/package/tpdb-1.3.2 (JohannesWaldmann)
09:15:27 <EvanR> its not like foo t = (F t, G t)
09:15:48 <EvanR> but i guess if you imagine a case statement 
09:15:57 <EvanR> alright
09:16:23 <Kasavage> Hey guys, can anyone help me with a ghc-mod failure when loading up Atom?
09:17:21 <Welkin> Kasavage: use emacs?
09:17:50 <maks_> Kasavage: what is Atom? 
09:18:06 <sm> Kasavage: tell us more, here or in #haskell-ide :)
09:18:12 <maks_> oh it's an ide
09:18:36 <Kasavage> Atom is an ide. I can move over to haskell-ide is needed.
09:18:37 <Welkin> an ide of march
09:18:47 <bernalex> you can also try #ghc-mod.
09:18:49 <Welkin> Kasavage: just use emacs
09:18:58 <Welkin> everything works
09:19:05 <sm> huh, there's a #ghc-mod
09:19:32 <bernalex> Welkin: please don't do that. people are allowed to use the tools they want. and it's unlikely that someone who has a bunch of tooling for other languages in atom to consider to start using emacs just to try out some haskell thing.
09:19:39 <bernalex> with that said: just use emacs.
09:19:44 * sm things #ghc-mod should become #haskell-ide
09:19:51 <arcetera> Failed to install ghc-paths-0.1.0.9
09:19:52 <arcetera> Build log ( /home/arc/.cabal/logs/ghc-paths-0.1.0.9.log ):
09:19:52 <arcetera> cabal: /home/arc/.cabal/logs/ghc-paths-0.1.0.9.log: openFile: does not exist
09:19:52 <arcetera> (No such file or directory)
09:20:05 <arcetera> send help
09:20:05 <bernalex> sm: there's also #haskell-emacs. there used to be #haskell-atom as well.
09:20:31 <sm> yeah.. I revived #haskell-atom recently but dropped it in favour of #haskell-ide
09:20:34 <bernalex> any emacs/ghc-mod people know how to make ghc-mod use -Wall by default? I ask this every now and again, and never get an answer.
09:21:17 <bernalex> in vim you can just let g:ghcmod_ghc_options = ['-Wall'].
09:21:45 <arcetera> oh i'm stupid
09:23:41 <sm> bernalex: which emacs package is using ghc-mod ? I don't see it used in a quick search of haskell customization groups
09:24:26 <bernalex> sm: uhm I'm not sure. I don't really know how to emacs. I do have flycheck-ghcmod and company-ghc.
09:24:33 <sm> maybe M-x customize-apropos ghc-mod finds the setting
09:24:52 <bernalex> "no match"
09:24:58 <Kasavage> So this ghc-mod error I'm getting is failed to launch. Does anyone think this is a path issue?
09:25:17 <Ankhers> Kasavage: Well, can you start it on the command line?
09:25:19 <mokus> roconnor__: actually i just realized, even if copy/move are safe (which i expect they are not), it still wouldn't be threadsafe so overlap should still return True in that case
09:25:51 <sm> bernalex: flycheck-ghcmod looks non-customizable, so you'd have to hack its source or set up an alternate "ghc-mod" script in your path
09:26:12 <bernalex> sm: maybe you can do it in haskell-mode? I have no clue.
09:26:29 <Kasavage> Ankhers: No, it won't work through the terminal. 
09:26:32 <arcetera> where did "emacs everything just works" go
09:26:35 <sm> #haskell-emacs should know more
09:26:42 <sm> arcetera: ha ha ha ha ha ha
09:26:44 <sm> good one
09:27:01 <Ankhers> Kasavage: Same error or different?
09:27:26 <bernalex> sm: I'll just email the person who wrote flycheck-ghcmod.
09:27:37 <sm> good idea, or open an issue
09:27:48 <Welkin> sm: you'll open a suse?
09:27:49 <vctrh> has anyone tried rapid yet?
09:28:39 <arcetera> why should i use ghcmod over hdevtools though
09:28:43 <arcetera> i'm a vimmer
09:29:16 <bernalex> ghc-mod rules in vim. I could never get hdevtools to do anything interesting.
09:29:19 <sm> the only reason to use ghc-mod is "my preferred IDE needs it"
09:29:41 <Welkin> I don't use any of those things
09:29:44 <sm> so eg all the Atom and Intellij plugins need it
09:29:45 <Welkin> just haskell-mode
09:29:47 <Kasavage> I'm leaning towards a path issues. I cannot run it from the terminal and the error I'm getting in Atom is "failed to launch".
09:30:06 <vctrh> i use spacemacs + haskell layer. tbh i'm not sure exactly what aspect of the functionality is ghc-mod
09:30:14 <Kasavage> Cabal installed it and no errors where given, guess I just need to find and set the path now.
09:30:23 <Ankhers> vctrh: I don't believe any of it.
09:30:54 <sm> ghc-mod is pretty cranky though, and it seems like the project to replace it is sleeping ?
09:31:00 <vctrh> Ankhers don't believe any of what?
09:31:19 <Ankhers> I don't think haskell-mode uses ghc-mod
09:31:29 <sm> Kasavage: it's probably in ~/.cabal bin
09:31:46 <arcetera> i've been spending most of my time over the last few days learning haskell and by god i'm confused but i'll probably figure it out eventually maybe
09:31:47 <Kasavage> I've tried to cd into that directory and it tells me it cannot be found.
09:31:48 <vctrh> ankhers oh rly? i thought ghc-mod was somehow involved in either the linting or code completion
09:32:06 <arcetera> or should i say eventually Maybe
09:32:07 <arcetera> haha
09:32:11 <arcetera> hilarious and original
09:32:17 <Kasavage> I take that back, now it seems to work all of a sudden. Thanks sm.
09:32:34 <Welkin> (bd)sm
09:32:40 <Ankhers> vctrh: I've looked through the code and haven't come across anything ghc mod specific. Doing a quick search on the codebase on GH comes up with nothing.
09:32:49 <baordog> Welkin: What's up with Haskell and sex jokes
09:32:59 <sm> Kasavage: that may not be in your path if you start Atom from the GUI
09:33:18 <Welkin> baordog: that never happens here
09:33:22 <vctrh> Ankhers i could've sworn people talk about ghc-mod and haskell mode. I often hear "i disable ghc-mod because blah"
09:33:25 <Kasavage> I went to the ~/.cabal dir and read the "where-is-my-stuff.txt" and got the bin path.
09:33:27 <arcetera> baordog: i KNEW they were related somehow. the bitwise or operator has always looked like a middle finger
09:33:35 <vctrh> well i'm confused :P
09:34:08 <vctrh> has anyone tried intero, particularly w/ spacemacs?
09:34:13 <vctrh> seems to be getting a lot of love
09:34:13 <Ankhers> vctrh: I could be completely wrong. People in #haskell-emacs would know more than I.
09:34:17 <sm> vctrh: there are some separate packages, ghc-mod and flycheck-ghcmod, probably often used with haskell-mode, and people sometimes use "haskell-mode" as a shorthand for all
09:34:25 <arcetera> see this is why i use vim
09:34:29 <arcetera> get off my lawn
09:35:05 <vctrh> sm the spacemacs haskell layer probably turns on all of them right?
09:35:12 <dfeuer> HRMMM
09:35:14 <sm> I don't know
09:35:36 <dfeuer> Nope nope nope.
09:35:41 <dfeuer> Grrr.
09:35:43 <sm> the haskell-mode site has some kind of setupguide
09:35:46 <Kasavage> Looks like I got it going now. No errors, that's great. Just to note, I love emacs but ever since I screwed up my vim and emacs config I have nothing but problems with both and haven't had the urge to go correct them, haha.
09:35:56 <Kasavage> Thanks for the help!
09:36:01 <Ankhers> vctrh: spacemacs doesn't seem to use the ghc-mod packages either.
09:36:09 <vctrh> arcetera i've used vim in the past but the emacs non-editing aspects like the rich ecosystem are worth it.
09:36:22 <arcetera> i tried emacs and spacemacs and they just got on my nerves
09:36:24 <Ankhers> emacs + evil
09:36:25 <arcetera> ┐('~'; )┌
09:36:40 <lpaste> arcetera pasted “kinda sorta isInfixOf” at http://lpaste.net/1110337861644713984
09:36:53 <arcetera> ^
09:36:59 <arcetera> why does this work? i'm dumb
09:37:05 <arcetera> and i don't really understand folds
09:37:18 <vctrh> arctera i have my gripes about spacemac, but the tradeoffs are more favorable than anything else i've looked into
09:37:38 <arcetera> spacemacs is like taking a massive piece of software and adding more to it
09:37:44 <arcetera> more than needed imo
09:37:52 * hackagebot octane 0.7.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.7.0 (fozworth)
09:38:45 <Ankhers> It is simply a batteries included config for emacs. emacs, and vim, can both be intimidating to someone just starting.
09:39:53 <dmwit> I think including the vim batteries I know about would make learning vim more intimidating than starting from a bare install, not less.
09:39:59 <dmwit> Can't speak for emacs but I would bet it's the same.
09:41:42 <vctrh> imo big or small is not inherently good or bad. it's the user/developer interface design that matters
09:42:02 <arcetera> but yeah why does that code snippet work? i don't understand using False as the accumulator
09:43:03 <Ankhers> :t foldl
09:43:04 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:43:23 <Ankhers> a fold "reduces" your data. You can use anything as an accumulator.
09:43:37 <arcetera> huh
09:43:58 <arcetera> i mean i understand how say
09:44:05 <arcetera> `foldl (+) 0 [1,2,3,4,5]` works
09:44:09 <idev> what is the infixr/infixl ranking of <, <=, >, and >= ? I can find it for +-*/, but not the comparison operators.
09:44:14 <locallycompact> how is that not isInfixOf
09:44:26 <arcetera> locallycompact: different name
09:44:33 <arcetera> i'm just reimplementing things for the sake of learning
09:44:37 <locallycompact> oh ok
09:45:17 <arcetera> because well i don't know haskell
09:45:28 <arcetera> and i am trying to learn and i am getting very confused very fast
09:45:34 <Ankhers> arcetera: Do you understand how your search function works?
09:45:38 <arcetera> Ankhers: no
09:45:40 <arcetera> that's why i'm asking
09:45:49 <Ankhers> alright, do you understand what your lambda function does?
09:45:56 <ski> idev : did you try `:i' in the interactor ?
09:45:59 <arcetera> no
09:46:22 <Welkin> but you wrote it!
09:46:31 <dmwit> > foldl (+) 0 [1..5] :: Expr
09:46:31 <arcetera> Welkin: this is from learn you a haskell
09:46:32 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
09:46:34 <idev> :i (<)
09:46:38 <idev> > :i (<)
09:46:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:46:41 <Ankhers> :t foldl
09:46:42 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
09:46:44 <ski> idev : lambdabot doesn't understand it
09:47:19 <dmwit> idev: I believe they are all `infix` (non-associative).
09:47:22 <Ankhers> Your function takes 2 arguments (a and b) and returns some b. For your specific function, b = Bool and a = String.
09:47:32 <idev> ski dmwit : got it from :ghci :i ... thanks!
09:47:38 <dmwit> idev: That is, `x < y < z` is a syntax error.
09:47:43 <ski> idev : np :)
09:48:07 <Ankhers> disregard String. I thought this was specific to strings.
09:49:44 <arcetera> so basically what i'm thinking of how this works
09:49:48 <arcetera> correct me if i'm wrong, please
09:49:49 <Ankhers> foldl :: (Bool -> String -> Bool) -> Bool -> [String] -> Bool -- arcetera 
09:50:02 <Ankhers> Is foldl's type specific to how you are using it.
09:50:30 <arcetera> so it takes False as `acc` and passes it to the lambda, and then takes the first element of `tails haystack` as x
09:51:12 <Cale> arcetera: That would be much better off as a foldr, btw
09:51:16 <arcetera> and if `take (length needle) x == needle` then it returns true, else it returns acc which is false
09:51:26 <arcetera> the question is the accumulator always false
09:51:38 <arcetera> Cale: i don't understand what i'm doing
09:51:42 <arcetera> this is all so confusing
09:51:43 <Cale> search needle haystack = any (isPrefixOf needle) (tails haystack)
09:51:51 <arcetera> what is isPrefixOf
09:52:03 <Cale> It checks whether one list is a prefix of another
09:52:13 <ski> @type isPrefixOf
09:52:14 <lambdabot> Eq a => [a] -> [a] -> Bool
09:52:17 <arcetera> oh god i'm so confused
09:52:19 <Ankhers> Cale: They mentioned LYAH. I'm not sure if things line any have been shown yet.
09:52:25 <Cale> > isPrefixOf "abra" "abracadabra"
09:52:26 <lambdabot>  True
09:52:29 <Ankhers> s/line/like
09:52:30 <ski> > "abc" `isPrefixOf` "abcde"
09:52:31 <lambdabot>  True
09:52:42 <ski> > "abc" `stripPrefix` "abcde"
09:52:43 <lambdabot>  Just "de"
09:52:49 <ski> > "abc" `isPrefixOf` "abdce"
09:52:51 <lambdabot>  False
09:52:52 <ski> > "abc" `stripPrefix` "abdce"
09:52:54 <lambdabot>  Nothing
09:53:15 <arcetera> this is just so incredibly confusing
09:53:18 <Cale> @src isPrefixOf
09:53:18 <lambdabot> isPrefixOf [] _          = True
09:53:18 <lambdabot> isPrefixOf _  []         = False
09:53:18 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
09:53:29 <ski> @type stripPrefix
09:53:33 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
09:53:51 <Ankhers> arcetera: What part are you confused about right now?
09:54:01 <Cale> arcetera: Well, the needle occurs somewhere in the haystack if any of the tails of the haystack has the needle as a prefix, right?
09:54:12 <arcetera> yes
09:54:14 <Cale> > tails "abracadabra"
09:54:16 <lambdabot>  ["abracadabra","bracadabra","racadabra","acadabra","cadabra","adabra","dabra...
09:54:25 <idev> I want to define my own < that is :: Expr Num -> Expr Num -> Expr Bool // it's a way to build up math expressions
09:54:27 <arcetera> correctamundo
09:54:29 <idev> should I name it something else ?
09:54:37 <Cale> > filter (isPrefixOf "cad") (tails "abracadabra")
09:54:38 <lambdabot>  ["cadabra"]
09:54:43 <ski> idev : yes
09:54:45 <Cale> > any (isPrefixOf "cad") (tails "abracadabra")
09:54:46 <lambdabot>  True
09:54:54 <Cale> > filter (isPrefixOf "car") (tails "abracadabra")
09:54:56 <lambdabot>  []
09:55:00 <Cale> > any (isPrefixOf "car") (tails "abracadabra")
09:55:01 <Welkin> arcetera: you mean "correcto"
09:55:02 <lambdabot>  False
09:55:50 <Cale> arcetera: I think it will be simpler to work out how to write any in terms of foldr
09:55:56 <Cale> Or even "or"
09:56:02 <Cale> @src or
09:56:02 <lambdabot> or = foldr (||) False
09:56:04 <Cale> aww
09:56:15 <Cale> hah, I was expecting a recursive one
09:56:19 <ski> > mapMaybe ("abr" `stripPrefix`) (tails "abracadabra")
09:56:21 <lambdabot>  ["acadabra","a"]
09:56:31 <Cale> heh
09:56:41 <Welkin> Cale: aren't those short-circuiting?
09:56:49 <Cale> sure
09:56:57 <Welkin> but you can't short-circuit a fold
09:57:02 <Cale> yes you can
09:57:06 <Welkin> how?
09:57:08 <Cale> foldr will short-circuit
09:57:11 <Cale> Lazy evaluation
09:57:17 <mauke> > foldr (\_ _ -> 42) 0 [1 .. ]
09:57:18 <lambdabot>  42
09:57:29 <Cale> @src foldr
09:57:29 <lambdabot> foldr f z []     = z
09:57:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:57:37 <Cale> ^^ foldr passes control to f
09:57:44 <Cale> (in the recursive case)
09:57:54 <arcetera> i don't understand
09:58:02 <Cale> If f doesn't pattern match its second argument, no need to evaluate the rest of the foldr
09:58:15 <Cale> arcetera: Yeah, that's a subtle point, don't worry about that
09:58:42 <arcetera> i can't even wrap my mind around lazy evaluation
09:58:55 <Cale> arcetera: If you want, I could explain how it works
09:59:00 <arcetera> please do
09:59:14 <Cale> Well, I have a meeting in 2 minutes, but let's see if I can get this in
09:59:25 <Cale> Suppose we have a program like double x = x + x
09:59:37 <Cale> and we want to evaluate double (double 5)
09:59:48 <Cale> Under innermost-first evaluation, it would go like:
09:59:52 <Cale> double (double 5)
09:59:58 <Cale> -> double (5 + 5)
10:00:00 <Cale> -> double 10
10:00:04 <Cale> -> 10 + 10
10:00:06 <Cale> -> 20
10:00:21 <Cale> But we could also choose to evaluate the outermost function first:
10:00:25 <Cale> double (double 5)
10:00:30 <Cale> -> (double 5) + (double 5)
10:00:36 <Cale> -> (5 + 5) + (double 5)
10:00:41 <Cale> -> 10 + (double 5)
10:00:44 <Cale> -> 10 + (5 + 5)
10:00:47 <Cale> -> 10 + 10
10:00:48 <Cale> -> 20
10:00:49 <pikajude> ertesx: hi, sorry, i'm trying to figure out how to reproduce the bug
10:01:04 <Cale> But this caused duplication of work, since x occurred more than once in the body of double
10:01:38 <Cale> However, outermost first evaluation has an advantage over innermost first evaluation: sometimes you don't end up needing to evaluate the argument to a function at all
10:02:00 <Cale> Whereas with innermost-first evaluation, you always evaluate the arguments to functions
10:02:30 <Cale> So lazy evaluation is outermost-first evaluation, with an additional rule that says you share the work done to evaluate an expression that's bound to a variable
10:02:47 <arcetera> so like
10:02:50 <Cale> If we can use let ... in ... to represent this sharing, it'd look like:
10:02:54 <Cale> double (double 5)
10:03:05 <arcetera> wait wait wait
10:03:06 <Cale> -> let x = double 5 in x + x -- note we expanded the outermost double still
10:03:10 <arcetera> let me try
10:03:14 <arcetera> so it'd be like
10:03:16 <Welkin> I see
10:03:17 <arcetera> double (double 5)
10:03:28 <Welkin> any is defined using foldMap, which is defined using foldr
10:03:33 <arcetera> (double 5) + (double 5)
10:03:34 <Welkin> I seem to have forgotten a lot of this
10:03:39 <arcetera> (5 + 5) + (5 + 5)
10:03:41 <arcetera> or am i horribly wrong
10:03:59 <drostie> You're right.
10:04:05 <arcetera> woo
10:04:25 <Cale> Yeah, that's the effect of it
10:04:37 <arcetera> why is that a good thing
10:04:58 <drostie> In fact double (double 5) doesn't do anything, it stores a deferral -- which in Haskell is called a thunk -- which can later be used if you actually do anything with it.
10:05:22 <drostie> arctera: because [0..] is the infinite list of numbers starting with 0.
10:05:26 <mauke> < Cale> However, outermost first evaluation has an advantage over innermost first evaluation: sometimes you don't end up needing to evaluate the argument to a function at all
10:05:36 <Cale> So with innermost-first evaluation, you evaluate each argument to a function exactly once. With outermost-first evaluation, you evaluate them zero-or-more times. With lazy evaluation, you sort of get the best of both worlds, and each parameter is evaluated zero or one times.
10:06:22 <mizu_no_oto_work> arcetera: Lazy evaluation is good because it means that you can sometimes do less work
10:06:22 <drostie> arcetera: you can literally define it as list n = n : list (n + 1) if you want, the infinite list of numbers gradually increasing by 1.
10:06:48 <mizu_no_oto_work> Consider, for example, `head (x:xs) = x`
10:06:58 <drostie> It works because the second list (n + 1) basically just sits there unevaluated until you need it.
10:07:11 <mizu_no_oto_work> Head only needs to evaluate enough of the list to get the first element out of it
10:07:11 <Cale> brb
10:07:44 <mizu_no_oto_work> If you don't need the rest of the list anywhere, lazy evaluation will leave it unevaluated
10:08:48 <drostie> yeah, so if you ask for head [0..] it gives you 0 correctly, not caring about the infinite list that is the rest of that expression. But in strict languages it needs to know everything about the argument to head before it can do anything with that function.
10:08:59 <arcetera> oh i think i get it now
10:08:59 <mizu_no_oto_work> arcetera: The other useful thing to understand about lazy evaluation is that practical lazy languages cache the evaluation of variables
10:09:39 <mauke> mizu_no_oto_work: we just went over this
10:09:40 <mizu_no_oto_work> So in double (double 5), even though it expands out to (double 5) + (double 5), you only calculate (double 5) once
10:09:42 <mauke> this is what "lazy" means
10:10:51 <arcetera> hold on let me get out a pencil and paper and try to see how my custom isInfixOf is evaluated
10:10:55 <ertesx> mizu_no_oto_work: that's not lazy evaluation, but sharing…  it's only calculated once, because it has a name
10:11:22 <mizu_no_oto_work> ertesx: It's call-by-need vs call-by-name
10:11:22 <mizu_no_oto_work> Both are lazy
10:11:27 <mauke> no
10:11:31 <ertesx> > let double = (2*) in double 5 + double 5  -- potentially no sharing, calculated twice
10:11:33 <lambdabot>  20
10:11:49 <ertesx> > let double = (2*), x = double 5 in x + x  -- definitely shared, calculated once, in GHC
10:11:51 <lambdabot>  <hint>:1:18: parse error on input ‘,’
10:11:58 <ertesx> s/,/;/
10:12:36 <Welkin> > or $ repeat False
10:12:40 <lambdabot>  mueval-core: Time limit exceeded
10:12:43 <drostie> are you sure it's definitely shared? seems like one of those Monomorphism Restriction examples...
10:13:01 <ertesx> drostie: that's exactly why it's shared
10:13:32 <mizu_no_oto_work> ertesx: right; call-by-need doesn't necessarily mean common-subexpression-elimination.  Just that in `f x = x + x`, x will only be evaluated once.
10:13:54 <Welkin> > True <> False
10:13:56 <lambdabot>      No instance for (Monoid Bool) arising from a use of ‘<>’
10:13:56 <lambdabot>      In the expression: True <> False
10:13:56 <ertesx> mizu_no_oto_work: that's sharing, too
10:14:02 <drostie> @type let double = (2*); x = double 5 in x
10:14:03 <lambdabot> Num a => a
10:14:09 <Welkin> > Any True <> Any False
10:14:10 <lambdabot>  Any {getAny = True}
10:14:26 <arcetera> oh i get it now
10:14:29 <arcetera> but my only question is
10:14:32 <Welkin> I see
10:14:39 <arcetera> once the lambda returns True
10:14:44 <drostie> ertesx: are you sure the above polymorphic type doesn't force GHC to hold off on memoizing the thing even though it has a name?
10:14:50 <arcetera> does the accumulator kinda "become" true (that's how i'm thinking about it)
10:14:56 <ertesx> drostie: it defaults to Integer
10:15:02 <arcetera> e.g. with `foldl (+) 0 [1,2,3]`
10:15:14 <arcetera> -> 0 + 1 w/ list [1,2,3]
10:15:15 <ertesx> drostie: if x had a type signature with a polymorphic type, then sharing would not happen
10:15:22 <mizu_no_oto_work> ertesx: call-by-need is basically call-by-name + sharing.
10:15:22 <arcetera> -> 1 + 2 w/ list [2,3]
10:15:25 <arcetera> you get the idea
10:15:33 <drostie> ertesx: which it does according to the @type I issued above.
10:15:41 <arcetera> so does the accumulator kinda become what's evaluated by the lambda here
10:15:44 <arcetera> or am i dumb
10:16:12 <drostie> but maybe lambdabot just by default sets -XNoMonomorphismRestriction or summat.
10:16:16 <ertesx> drostie: once you *use* x like that, it defaults to Integer
10:16:36 <ertesx> x itself is still polymorphic, so if you ask for its type, you won't get Integer
10:16:48 <drostie> @type let double = (2*); x = double 5 in x + x
10:16:50 <lambdabot> Num a => a
10:16:55 <drostie> Still not defaulted...
10:17:00 <arcetera> again here http://lpaste.net/1110337861644713984
10:17:01 <ertesx> drostie: it defaults when you evaluate
10:17:12 <ertesx> when you ask for its type, it is still polymorphic
10:17:27 <arcetera> once the lambda returns True, is the next thing passed to the lambda as `acc` also True?
10:17:58 <ertesx> drostie: reason is that the value *must* have a specific type when you evaluate (otherwise you couldn't), and then due to MR the local 'x' inherits that type
10:18:14 <ertesx> example:
10:18:22 <ertesx> > let x = 1 + 1 in x + x :: Double
10:18:23 <lambdabot>  4.0
10:18:42 <ertesx> i instantiated the type variable as Double, and immediately 'x' inherited that type
10:19:01 <ertesx> > let x :: (Num a) => a; x = 1 + 1 in x + x :: Double  -- here it doesn't happen
10:19:02 <lambdabot>  4.0
10:19:18 <ertesx> (though GHC performs some limited CSE, so it may still be evaluated only once)
10:19:39 <arcetera> apparently, yes
10:19:40 <arcetera> okay
10:19:42 <arcetera> i get it now
10:19:44 <arcetera> it all makes sense
10:19:53 <arcetera> holy crap
10:20:54 <arcetera> thank you
10:20:55 <ertesx> drostie: with -XScopedTypeVariables it's easier to explain why sharing does happen even in the context of polymorphism:  y :: forall a. (Num a) => a; y = x + x where x :: a; x = 1 + 1
10:21:00 <drostie> OK ertesx, I have tested with Debug.Trace and you are just 100% unconditionally wrong; lambdabot if running normal GHCi with -XNoMonomorphismRestriction set is going to evaluate the darn thing twice.
10:21:13 <ertesx> drostie: as you see in that example, even though y is polymorphic, x is actually monomorphic
10:21:15 <kzhang> I want to deserialize a value at run time. However, I do not know its type. But I know its type must be the same as another value's. So I was able to do: x = head [deserialize (bs :: ByteString), proxy]. But this looks ugly. Is there a way to do something like: x = castType (deserialize bs) proxy 
10:21:16 <Ankhers> @src foldr
10:21:17 <lambdabot> foldr f z []     = z
10:21:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:21:28 <arcetera> okay now the question is
10:21:35 <drostie> ertesx: you may try this in your own ghci by :m +Debug.Trace
10:21:35 <arcetera> when should i use foldr, when should i use foldl, when should i use foldl'
10:21:42 <drostie> then you can try let double = (2*); x = trace "eval" (double 5) in x + x
10:21:43 <Welkin> arcetera: never use foldl
10:21:46 <Welkin> either use foldr or foldl'
10:21:54 <arcetera> why?
10:22:04 <Welkin> foldl will overflow your memory
10:22:10 <Welkin> when it doesn't need to
10:22:16 <arcetera> why?
10:22:20 <drostie> and you will by default get "eval\neval\n20". Which if you :set -XMonomorphismRestriction finally becomes "eval\n20".
10:22:22 <Welkin> because it bulds up thinks
10:22:24 <Welkin> thunks*
10:22:31 <arcetera> and foldl' doesn't?
10:22:34 <Welkin> no
10:22:40 <arcetera> why?
10:22:42 <Welkin> foldl' evaluate each step
10:22:43 <ertesx> drostie: i told you, it's because of the monomorphism restriction that it's evaluated only once, despite being polymorphic
10:22:47 <arcetera> Welkin: oooh
10:22:48 <arcetera> okay
10:22:50 <Welkin> evaluates* each step as it goes
10:22:55 <Welkin> the ' means it is strict
10:22:59 <Welkin> strict evaluation
10:22:59 <arcetera> why is foldr okay then?
10:23:05 <ertesx> drostie: so what you got is exactly what i'd expect
10:23:12 <arcetera> and when should i use foldr vs foldl'
10:23:14 <Welkin> foldr is useful for lazy evaluation because it doesn't eat up your memory
10:23:44 <Welkin> you can use it to fold infinite lists, for example, and take only the first 10 results
10:24:00 <mizu_no_oto_work> https://mail.haskell.org/pipermail/haskell-cafe/2012-July/102494.html
10:24:01 <drostie> ertesx: *facepalm* the whole point of my comment to you, "hey that will depend on the monomorphism restriction", was just that. 
10:24:19 <Cale> Generally, if computing any part of the result of the fold is going to require looking at *all* of the input list, you probably want foldl'
10:24:30 <Cale> and if not, you probably want foldr
10:24:56 <drostie> ertesx: do you believe that you cannot turn off the monomorphism restriction? or were you just trying to explain defaulting rules to me even though you agreed with my point on the monomorphism restriction? or... what?
10:25:08 <ertesx> generally, if you have a foldr pattern, you probably want foldr =)
10:25:08 <Cale> Note that the compiler will usually turn foldl into foldl' on its own for you if you compile with optimisations, when it can see that it would be a good idea to do so.
10:25:49 <arcetera> so in the case with the reimplementation of isInfixOf
10:25:54 <ertesx> drostie: i think, we should stop here
10:26:00 <arcetera> should i use foldr or foldl'?
10:26:18 <Cale> GHC doesn't *just* use lazy evaluation, it actually does something a good deal fancier, making things more strict whenever it can see that it would be beneficial to do so, but lazy evaluation is generally a very good approximation -- it should only ever pleasantly surprise you.
10:26:38 <Cale> With isInfixOf here, we want foldr, because we want it to short-circuit out once it finds the thing
10:26:48 <drostie> arcetera: so a nice way to think about foldr versus foldl' is to think about whether you want to transform a stream of values to a stream of values, or to an individual summary quantity.
10:26:57 <Cale> If the needle occurs right at the start, we don't need to look at the rest of the input
10:27:00 <arcetera> drostie: huh?
10:27:22 <arcetera> @src foldr
10:27:23 <lambdabot> foldr f z []     = z
10:27:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:27:26 <Cale> drostie: Well, that will give the wrong answer in this *particular* case ;)
10:27:28 <drostie> arcetera: a summary might be "the length of a list" or "the sum of the items of a list" or whatever.
10:27:31 <hpc> another thing that matters occasionally is if the operator is associative
10:27:39 <ertesx> i don't think isInfixOf is a right fold, unless you apply tails beforehand
10:27:39 <hpc> > foldr (/) 1 [5, 4, 3, 2, 1]
10:27:39 <Welkin> arcetera: foldl must evaulaute the entire list before it can give you a result, whereas foldr gives you a result immediately
10:27:40 <Cale> But yeah, if it's a summary that uses all the input values
10:27:41 <lambdabot>  1.875
10:27:49 <hpc> > foldl' (/) 1 [5, 4, 3, 2, 1]
10:27:50 <lambdabot>  8.333333333333333e-3
10:27:50 <Welkin> because it only needs to evaluate one step at a time
10:28:09 <ertesx> it's not a left fold either, because you can't short-circuit
10:28:11 <Cale> ertesx: We're doing the   any (isPrefixOf needle) (tails haystack)
10:28:15 <Welkin> haha my typing is bad today :D
10:28:28 <arcetera> okay so
10:28:28 <ertesx> ah
10:28:33 <drostie> arcetera: by a transformation of the streams I just mean, "to figure out the first element of this output stream of values I only need one or two or three elements from the beginning of the input stream of values."
10:28:49 <Cale> which is a somewhat naive algorithm, but written in a way that makes it look far more naive than it really is to programmers used to strict evaluation :)
10:29:11 <ertesx> yeah =)
10:29:16 <Welkin> > take 10 $ foldl' (+) [1..]
10:29:17 <lambdabot>      Couldn't match expected type ‘[a]’
10:29:17 <lambdabot>                  with actual type ‘t0 [t1] -> [t1]’
10:29:17 <lambdabot>      Probable cause: ‘foldl'’ is applied to too few arguments
10:29:21 <ertesx> on the other hand you can't really use a fancy algorithm with haskell lists
10:29:26 <drostie> arcetera: a foldr is better for stream transformations because you can start outputting values without processing the whole list. If you need to process the whole list then a foldl' is usually better if you can do it right.
10:29:26 <Cale> You can
10:29:41 <Welkin> > take 10 $ foldl' (+) 0 [1..]
10:29:42 <ertesx> Cale: you can skip the equality testing, but you can't jump
10:29:42 <lambdabot>      No instance for (Show a0)
10:29:42 <lambdabot>        arising from a use of ‘show_M309872329953444478930919’
10:29:43 <lambdabot>      The type variable ‘a0’ is ambiguous
10:30:05 <Cale> http://www.twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
10:30:06 <Welkin> > take 10 $ foldl' (+) [1..] 0
10:30:08 <lambdabot>      Could not deduce (Num (t0 [a]))
10:30:08 <lambdabot>      from the context (Enum a, Num a, Num (t [a]), Num [a], Foldable t)
10:30:08 <lambdabot>        bound by the inferred type for ‘e_11010’:
10:30:28 <Welkin> > take 10 $ foldl' (+) [1..] 0 :: [Integer]
10:30:30 <lambdabot>      No instance for (Foldable t0) arising from a use of ‘foldl'’
10:30:30 <lambdabot>      The type variable ‘t0’ is ambiguous
10:30:30 <lambdabot>      Note: there are several potential instances:
10:30:37 <Welkin> o.o
10:31:04 <Ankhers> :t foldl'
10:31:05 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:31:08 <Welkin> > take 10 $ foldl' (+) 0 [1..] :: [Integer]
10:31:10 <lambdabot>      No instance for (Num [Integer]) arising from a use of ‘+’
10:31:10 <lambdabot>      In the first argument of ‘foldl'’, namely ‘(+)’
10:31:10 <lambdabot>      In the second argument of ‘($)’, namely ‘foldl' (+) 0 [1 .. ]’
10:31:24 <Welkin> > take 10 $ foldl' (+) 0 [1..]
10:31:26 <lambdabot>      No instance for (Show a0)
10:31:26 <lambdabot>        arising from a use of ‘show_M719120030847226796030999’
10:31:26 <lambdabot>      The type variable ‘a0’ is ambiguous
10:31:32 <arcetera> so in this case
10:31:36 <ertesx> Cale: yeah, that one is as fancy as you can get (O(n) instead of O(n*m)), but a fancy algorithm would require O(n/m)
10:31:39 <Welkin> > (take 10 $ foldl' (+) 0 [1..]) :: Integer
10:31:40 <lambdabot>      Couldn't match expected type ‘Integer’ with actual type ‘[a0]’
10:31:40 <lambdabot>      In the expression: (take 10 $ foldl' (+) 0 [1 .. ]) :: Integer
10:31:48 <Welkin> > (take 10 $ foldl' (+) 0 [1..]) :: [Integer]
10:31:49 <lambdabot>      No instance for (Num [Integer]) arising from a use of ‘+’
10:31:49 <lambdabot>      In the first argument of ‘foldl'’, namely ‘(+)’
10:31:49 <lambdabot>      In the second argument of ‘($)’, namely ‘foldl' (+) 0 [1 .. ]’
10:31:53 <Welkin> did I die and go to hell?
10:31:55 * EvanR gets washed away
10:32:04 <arcetera> foldl' (\acc x -> if take nlen x == needle then True else acc) False (tails haystack) where nlen = length needle
10:32:08 <arcetera> how would i use a foldr?
10:32:16 <Cale> Welkin: you're applying take 10 to an Integer...
10:32:22 <arcetera> sorry for all these dumb questions :/
10:32:24 <Welkin> oh haha
10:32:32 <Welkin> yeah
10:32:35 <Welkin> it's been a while
10:32:43 <EvanR> arcetera: i think for this you would not?
10:32:48 <Cale> arcetera: Let's write a simpler function
10:33:02 <Cale> arcetera: It's going to take a list of Bool values, and determine if any of them is True
10:33:04 <Welkin> > take 10 $ foldl' (:) 0 [1..]
10:33:05 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
10:33:05 <lambdabot>      Expected type: [a] -> [a] -> [a]
10:33:05 <lambdabot>        Actual type: a -> [a] -> [a]
10:33:10 <arcetera> okay
10:33:16 <coppro> laziness to the rescue!
10:33:19 <Cale> arcetera: then we can use this together with map and tails
10:33:31 <Welkin> > take 10 $ foldl' (flip (:)) 0 [1..]
10:33:32 <lambdabot>      No instance for (Show a0)
10:33:32 <lambdabot>        arising from a use of ‘show_M3300845750989463331072’
10:33:32 <lambdabot>      The type variable ‘a0’ is ambiguous
10:33:36 <drostie> arcetera: the technical difference is that foldr (&) x [a, b, c, d] is x & (a & (b & (c & d))). Another way to think of this is that when you get your arguments to let f val acc = ..., you can assume that the acc has already been processed with f.
10:33:50 <Cale> Welkin: you might want to try /query lambdabot  :)
10:33:53 <arcetera> :t (&)
10:33:54 <lambdabot> a -> (a -> b) -> b
10:33:57 <arcetera> what
10:34:18 <EvanR> (&) might be confusing things unnecesarily
10:34:23 <drostie> Sorry, I just meant as a generic operator.
10:34:23 <Cale> arcetera: drostie didn't mean a specific implementation of (&)
10:34:28 <arcetera> ok
10:34:53 <drostie> Yeah. if you want to foldr f x [a, b, c, d] that's f x (f a (f b (f c d)))
10:35:04 <kzhang> take 10 $ foldl (flip (:)) [0] [1..]
10:35:05 <Cale> drostie: also, that's incorrect
10:35:17 <Tuplanolla> > take 10 $ scanl' (+) 0 [1 ..] -- Is this what you're after, Welkin?
10:35:19 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
10:35:27 <Cale> foldr (&) x [a,b,c,d] = a & (b & (c & (d & x)))
10:35:27 <drostie> oh, sorry, Cale is totally right.
10:35:32 <kzhang> take 10 $ foldr (:) [0] [1..]
10:35:42 <drostie> arcetera: sorry sorry. f a (f b (f c (f d x)))
10:35:45 <arcetera> why am i doing this to understand an xmonad config...
10:35:54 <drostie> The x is on the right hand side of everything.
10:35:55 <Cale> arcetera: heh
10:36:03 <ertesx> arcetera: because xmonad is not a window manager =)
10:36:04 <kzhang> > take 10 $ foldr (:) [0] [1..]
10:36:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:36:12 <kzhang> > take 10 $ foldl (flip (:)) [0] [1..]
10:36:19 <lambdabot>  mueval: ExitFailure 1
10:36:22 <EvanR> @src foldr
10:36:22 <lambdabot> foldr f z []     = z
10:36:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:36:34 <Cale> arcetera: If this is just an xmonad config, use isInfixOf from Data.List :P
10:36:44 <ertesx> arcetera: it's a framework for writing your own window manager, and you should treat it as such…  you're not writing a config, you're writing a computer program
10:37:06 <arcetera> Cale: no i'm learning haskell to be able to do cool things with xmonad
10:37:13 <Cale> ah, okay
10:37:18 <arcetera> this isn't actually part of my xmonad config
10:37:25 <drostie> arcetera: so clearly what you want to start with here is x = False, and then you have that f val acc = acc || ______ for some ______. If you ever get True you want to propagate that to the top for this isInfixOf.
10:37:38 <Welkin> kzhang: thanks
10:37:39 <arcetera> what
10:38:18 <ertesx> arcetera: are you struggling with folds?
10:38:27 <arcetera> ertesx: yes
10:38:41 -bxobx(~kgsnh@205.204.41.99)- Penis.
10:38:58 <drostie> arcetera: just look at the structure of taking [a, b, c, d] and some x to isInfixOf needle haystack = ... = f a (f b (f c (f d x)))). 
10:39:27 <drostie> arcetera: you think "if I get to the end of this thing and I haven't seen anything, then I want to return False."
10:39:44 <drostie> That is the x value.
10:39:58 <arcetera> but how do i short-circuit if i get to the end of this thing and i HAVE seen something
10:40:05 <arcetera> or rather
10:40:12 <arcetera> short-circuit immediately after i see something
10:40:26 <ertesx> arcetera: the most important fold to understand is the right fold (foldr)…  it your secret weapon…  and that's why i'm going to give you an exercise:
10:40:40 <Welkin> wtf was that?
10:40:43 <Welkin> failed troll
10:40:51 <EvanR> succeeded troll
10:41:05 <ertesx> arcetera: safeHead :: [a] -> Maybe a  -- write this safe 'head' function in terms of foldr
10:41:07 <drostie> arcetera: lazy evaluation, p || q has not yet evaluated q and won't if p is True. 
10:41:21 <arcetera> i don't understand what safe means and i don't understand what Maybe is
10:41:35 <arcetera> i'm so confused
10:41:40 <Welkin> arcetera: Maybe is a type constructor
10:41:40 <ertesx> arcetera: oh…  in that case i suggest that you learn the basics first
10:41:51 <Welkin> data Maybe a = Nothing | Just a
10:41:59 <arcetera> ertesx: i am reading learn you a haskell and i haven't gotten to the monad chapter yet
10:42:01 <Welkin> it can either by nothing, or something
10:42:04 <ertesx> arcetera: and this channel is probably not a good way to do so, because there are too many teachers here
10:42:11 <Welkin> lol
10:42:14 <ertesx> arcetera: you don't need monads at all
10:42:15 <arcetera> i'm reading learn you a haskell
10:42:19 <arcetera> and i can't understand it at lal
10:42:20 <arcetera> all
10:42:30 <Welkin> arcetera: use the cis course
10:42:34 <Welkin> or check out haskell book
10:42:40 <Welkin> @where learnhaskell
10:42:40 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:42:44 <Welkin> @where haskellbook
10:42:44 <lambdabot> http://haskellbook.com
10:42:48 <kadoban> arcetera: LYAH wouldn't be my recommendation, if you're open to other things. ^ those would be
10:42:49 <ertesx> arcetera: what Welkin said
10:43:24 <drostie> arcetera: so anyway, skipping that other stuff, come back to me with the f a (f b (f c (f d x))) thing, we've seen x = False, now we have to figure out what [a, b, c, d] are. It sure would be nice if those were the tails of the original haystack, so let's make them that.
10:43:39 <arcetera> i'm not following you drostie 
10:43:51 <arcetera> hold on
10:44:01 <drostie> k.
10:44:52 <ertesx> arcetera: i highly recommend what Welkin said rather than IRC
10:45:41 <arcetera> well problem with haskellbook or whatever
10:45:47 <arcetera> is i am a highschooler with no money
10:45:55 <ertesx> arcetera: check out the first link
10:46:08 <ertesx> no money needed except to pay your internet connection =)
10:46:10 <schell> LYAH is fun though
10:46:57 <maerwald> yeah, non-free learning resources are unethical and shouldn't be suggested
10:47:04 <ertesx> (note: i'm not implying that anyone is a bad teacher here, but it's just too crowdy, and too many people are explaining things in different ways)
10:47:32 <kadoban> arcetera: cis194 is free. It's not as good as haskellbook, but it's decent.
10:47:34 <arcetera> i'm being bombarded with information and i'm incredibly confused
10:47:39 <kadoban> maerwald: … that's ridiculous.
10:47:51 <maerwald> not at all. I believe that knowledge should be free.
10:48:08 <ertesx> maerwald: i think people should be able to get paid for their work
10:48:11 <maerwald> if people want or can pay for it, fine, but requiring them to pay for that is ridiculous
10:48:33 <maerwald> ertesx: that's a different thing and can be solved separately
10:49:20 -Werdandi(~eelwa@189-25-158-238.user.veloxzone.com.br)- Attention: freenode is merging with irc.librairc.net and the main channel will be #lounge. It's effective on June 11 at 1:00 PM GMT.
10:49:21 <ertesx> maerwald: it's best that every author decides that for themselves, and i will never judge an author by whether they put things behind a paywall or not…  i will just make a decision whether i buy it or not
10:49:36 <arcetera> whaaaa
10:50:44 <kadoban> maerwald: Solved separately how? It certainly seems very related.
10:52:21 <kzhang> Let me ask again
10:52:23 <kzhang> I want to deserialize a value at run time. However, I do not know its type. But I know its type must be the same as another value's. So I was able to do: x = head [deserialize (bs :: ByteString), proxy]. But this looks ugly. Is there a way to do something like: x = castType (deserialize bs) proxy
10:53:11 <ertesx> kzhang: you can use -XScopedTypeVariables to refer to the *type* of proxy instead
10:53:30 <ertesx> kzhang: deserialize bs :: theTypeVariableOfProxy
10:53:49 <ertesx> kzhang: but there is also asTypeOf somewhere
10:53:52 <ertesx> :t asTypeOf
10:53:53 <lambdabot> a -> a -> a
10:54:10 <ertesx> deserialize bs `asTypeOf` proxy
10:54:28 <roconnor__> mokus: I submitted a git issue on the topic.
10:54:30 <kzhang> asTypeOf is good, thanks
10:54:39 <arcetera> oh, hm
10:54:58 <ertesx> kzhang: if you want to get rid of 'proxy' altogether, ScopedTypeVariables is the best way
10:55:24 <arcetera> so i managed to implement it with a foldr, but it still goes over the entire list
10:55:52 <arcetera> lemme paste it
10:56:00 <kzhang> ertesx, I still need "proxy" to get theTypeVariableOfProxy
10:56:23 <ertesx> kzhang: nope, that's what ScopedTypeVariables is for…  you can refer to type variables from an outer scope
10:56:57 <ertesx> kzhang: f :: forall a. … a …;  f … = … (something :: a) …
10:57:09 <arcetera> why is lpaste always down for maintenance
10:57:49 <ertesx> arcetera: it has been for a while now…  i use codepad.org until it comes back
10:58:07 <kzhang> ertesx: I do not have type "a" here. The type has to be looked up from "proxy"
10:58:27 <ertesx> kzhang: but 'proxy' comes from somewhere, doesn't it?
10:58:35 <ertesx> like:  f proxy = …
10:58:45 <arcetera> http://sprunge.us/DZQG so i got it working with foldr
10:58:55 <arcetera> but i want it to short-circuit when a match is found
10:58:58 <arcetera> if a match is found
10:59:05 <arcetera> rather
10:59:06 <kzhang> proxy = T = T (forall a, ...)
10:59:08 <arcetera> how would i do this?
10:59:31 <ertesx> arcetera: looks fine to me
10:59:41 <arcetera> what do you mean?
10:59:46 <arcetera> it works, sure
10:59:55 <arcetera> but if it reaches a value, i don't want it to continue comparing
10:59:56 <ertesx> arcetera: and it short-circuits
11:00:01 <arcetera> ertesx: whaaaaat?
11:00:02 <arcetera> how?
11:00:23 <ertesx> arcetera: try it on an infinite list that includes the string
11:00:40 <ertesx> arcetera: an infinite haystack that is
11:01:52 <kzhang> ertesx, "proxy" comes from a heterogeneous list, so you don't have a type variable of proxy
11:02:22 <ertesx> kzhang: but you always have that proxy?  i mean: you're not passing the proxy *just* to get the type?
11:02:34 <ertesx> (because there is always a way to get the type variable directly)
11:03:27 <arcetera> ertesx: it works! but how
11:04:05 <ertesx> arcetera: foldr f z (x:xs) = f x (foldr f z xs)
11:04:24 <ertesx> in your case, if x satisfies a condition, f doesn't even look at its second argument
11:04:30 <ertesx> it just returns True
11:04:56 <arcetera> what
11:04:58 <arcetera> i don't understand
11:05:16 <ertesx> look at your f
11:05:19 <glguy> f x (foldr f z xs)   when you write this your program doesn't evaluate the foldr before passing the result to the function f like in a strict language
11:05:24 <ertesx> arcetera: it's the lambda
11:05:32 <glguy> it passes the unevaluated expression (foldr f z xs) as an argument to f
11:05:40 <kzhang> ertesx, I define `data T where T :: a -> T`, and a list `xs :: [T]`, let's say I pass the list `xs` to some function, extract the first element in the list which is the `proxy`, how do you know the type?
11:06:50 <ertesx> kzhang: with ScopedTypeVariables, patterns are allowed to have type signatures
11:07:00 <kzhang> ertesx, I don't know that
11:07:08 <kzhang> ertesx, let me take a look
11:07:09 <ertesx> kzhang: f (T (proxy :: a) : proxies) = …
11:07:17 <glguy> arcetera: In your program "acc" is the *unevaluated* accumulator, doesn't get evaluated until something cases on it
11:07:22 <arcetera> OH
11:07:32 <arcetera> OH MY GOD
11:07:40 <kzhang> ertesx, thanks
11:07:47 <arcetera> IT JUST
11:07:53 <ertesx> kzhang: but in this case, asTypeOf is probably even cleaner
11:08:03 <kzhang> ertesx, agree
11:08:24 <arcetera> it makes sense
11:08:27 <arcetera> it just makes sense
11:08:34 <arcetera> that moment
11:09:44 <arcetera> so in this function
11:09:44 <Saizan_> is "cabal repl" supposed to be able to reuse the binaries from "cabal build"?
11:09:52 <arcetera> let me try to see how exactly this evaluates
11:10:29 <ertesx> arcetera: write the following function:  takeOne :: [a] -> [a]  -- it should take any list and return a list with just its first element, or the empty list, if there is none
11:10:32 <arcetera> it folds through the list provided by tails haystack until the lambda returns true, and then it just doesn't bother with the accumulator anymore
11:10:51 <arcetera> ertesx: that's pretty easy
11:10:53 <arcetera> hold on
11:11:10 <glguy> Saizan_: It will if you've got an executable section which depends on a library section in the same package and you repl the executable, for example
11:11:23 <arcetera> so just reimplement head?
11:11:31 <ertesx> arcetera: next i'll give you a template for that function…  it must look like this:  takeOne = foldr _f _z
11:11:34 <Saizan_> glguy: but not just for the library?
11:11:37 <arcetera> m
11:11:39 <glguy> Saizan_: But if you're using the repl to open a library you just built you usually want repl to load the bytecode and not the object code
11:11:42 <arcetera> hm
11:11:50 <ertesx> arcetera: your exercise is to find _f and _z
11:12:02 <glguy> Saizan_: but with the right flag you can have it load the object code instead
11:12:19 <ertesx> arcetera: to do that, first write the direct version of takeOne…  the one with two patterns
11:12:23 <Saizan_> glguy: do you happen to know the right flag?
11:12:27 <arcetera> ertesx: yes
11:12:34 <ertesx> arcetera: then implement 'foldr' yourself
11:12:34 <glguy> I think you want --ghc-options=-fobject-code
11:12:44 <ertesx> arcetera: finally compare those two
11:12:55 * hackagebot microlens-platform 0.3.1.1 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.1.1 (Artyom)
11:13:13 <glguy> (I need to check; I haven't messed with that lately)
11:13:25 <arcetera> well ertesx 
11:13:33 <arcetera> i've already implemented something similar using two patterns
11:14:05 <arcetera> except it takes a list and returns the first element
11:14:08 <arcetera> not a list containing the first element
11:14:28 <arcetera> can i use `foldr1`
11:14:31 <ertesx> arcetera: yeah, now you'll do the list variant
11:14:33 <ertesx> arcetera: no
11:14:35 <arcetera> ok
11:14:51 <ertesx> (not that i say you shouldn't, but you actually can't)
11:14:51 <arcetera> can i use last
11:14:56 <ertesx> no
11:15:00 <arcetera> ertesx: yes i can
11:15:11 <ertesx> not for this variant
11:15:17 <Saizan_> glguy: it is compiling stuff, i'll see if it will just load them the second time around
11:15:19 <arcetera> hhhhwat
11:15:35 <ertesx> arcetera: foldr1 can't deal with non-empty lists
11:15:41 <ertesx> uhm
11:15:42 <ertesx> empty lists
11:15:48 <ertesx> can *only* deal with non-empty lists
11:16:08 <Saizan_> glguy: it does! thanks
11:16:25 <ertesx> arcetera: takeOne should not crash if the argument list is empty…  it should return the empty list instead:  takeOne [] = []
11:16:32 <ertesx> arcetera: it's impossible to write that in terms of foldr1
11:16:51 <glguy> Saizan_: Glad it worked :)
11:17:16 <Saizan_> i want object code because it's too many modules to interpret them all
11:17:55 * hackagebot haskoin-core 0.3.1 - Implementation of the core Bitcoin protocol features.  https://hackage.haskell.org/package/haskoin-core-0.3.1 (xenog)
11:17:57 * hackagebot haskoin-node 0.3.1 - Implementation of a Bitoin node.  https://hackage.haskell.org/package/haskoin-node-0.3.1 (xenog)
11:17:59 * hackagebot haskoin-wallet 0.3.1 - Implementation of a Bitcoin SPV Wallet with BIP32 and multisig support.  https://hackage.haskell.org/package/haskoin-wallet-0.3.1 (xenog)
11:22:44 <sinelaw> hey, intero doesn't work for me :( shows the error buffer, with stack ghci output at top showing its usage string
11:23:38 <arcetera> okay, got takeOne without the fold
11:23:43 <arcetera> now takeOne with the fold
11:28:06 <arcetera> ertesx: http://sprunge.us/FFiZ
11:29:27 <ertesx> arcetera: there you go =)
11:29:56 <ertesx> arcetera: every time you write something in terms of foldr, you're going to get insight into how foldr is really just equations
11:30:02 <ertesx> nothing magical is going on
11:30:42 <ertesx> foldr f z [] = takeOne [] = z = []  -- so z = []
11:31:26 <ertesx> foldr f z (x:xs) = takeOne (x:xs) = f x (foldr f z xs) = [x]  -- so f x _ = [x]
11:32:17 <ertesx> (the experience is certainly magical, but the nature of the thing really isn't)
11:42:56 * hackagebot yaml 0.8.17.2 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.17.2 (MichaelSnoyman)
11:50:28 <jasonkuhrt> Hi, is it possible for a user to somehow make their own `->` (function) Data? I can't think of a way but I'm not sure.
11:50:53 <shachaf> It depends on exactly what you mean, but the answer is probably no.
11:52:03 <jasonkuhrt> shachaf: I would like to try my hand at implementing typeclasses for (->) myself (for learning purposes) but of course the error is "duplicate typeclass..."
11:52:17 <monochrom> add a newtype wrapper
11:52:18 <jasonkuhrt> I will have to just go read the source code/work on paper I guess : )
11:52:34 <jasonkuhrt> I tried newtype and it gave me an error or maybe I did it wrong?
11:52:43 <dmj`> jasonkuhrt: can you paste your code
11:52:56 <dmj`> @where paste
11:52:56 <lambdabot> Haskell pastebin: http://lpaste.net/
11:52:56 * hackagebot themoviedb 1.1.2.0 - Haskell API bindings for http://themoviedb.org  https://hackage.haskell.org/package/themoviedb-1.1.2.0 (PeterJones)
11:52:58 <jasonkuhrt> `newtype Doit = (->)`
11:53:01 <monochrom> an error message means you did it wrong, tautologically.
11:53:26 <jasonkuhrt> "Illegal binding of built-in syntax (->)"
11:53:27 <monochrom> read up on newtype
11:53:30 <jasonkuhrt> Ok
11:53:43 <monochrom> especially its syntax
11:53:56 <black0range> Hello, is it possible to define your own derivable typeclasses? 
11:54:15 <monochrom> no
11:54:23 <hpc> black0range: deriving for custom type classes will leave every method with a default implementation
11:55:07 <Ankhers> black0range: You can't use the deriving keyword, but you can create TemplateHaskell functions for automatically generating instances.
11:55:11 <hpc> there's some shennanigans you can do with Data and Typeable which makes that able to do some stuff
11:56:07 <black0range> What may those shennianigans be? :)
11:56:20 <Ankhers> What do you call a function in TH? Someone suggested macro, but I still don't know what to call them.
11:56:36 <hpc> i don't remember, because i would never use it myself
11:56:46 <hpc> i just remember them existing, because of the "oh, that's weird" factor
11:57:06 <hpc> it probably also requires a language extension be enabled
11:58:17 * ski blinks
11:58:53 <black0range> So learning Template haskell would be the best way?
12:02:15 <ski> black0range : perhaps you could try <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming>
12:02:57 * hackagebot byline 0.2.2.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.2.2.0 (PeterJones)
12:15:10 <monochrom> oh God, https://melpa.org/#/haskell-tab-indent exists
12:15:42 <monochrom> "for Haskell projects which requires tabs for indentation and do not permit spaces (except for where"
12:29:41 <cheater> why would you work in such a project
12:29:54 <monochrom> hehe yeah!
12:30:06 <cheater> have people no dignity
12:30:24 <monochrom> can't imagine who would do this
12:31:12 <monochrom> then again, you know, the two safe extremes are "all U+0020" and "all U+0009"
12:31:17 <cheater> next thing people will run haskell on the java vm
12:31:48 <monochrom> oh, that has been wished for for 20 years
12:32:02 <cheater> i was just quipping at Sc*l*
12:32:03 <daftmonk> it does already, it's called scala :P
12:32:16 <cheater> the language that shall not be named
12:33:04 <monochrom> so much so that the FFI spec 20 years ago already reserved "foreign import/export jvm" for it
12:34:08 <monochrom> the Haskell committee's only crime is forgetting to also reserve "foreign import/export js" :)
12:34:56 <Cale> Maybe we should just have vertical tab not be a lexical error, so that people can use only vertical tabs as a compromise
12:35:28 <monochrom> hmm, what does vertical tab do?
12:35:44 <hsk3> https://hackage.haskell.org/package/dlist-0.7.1.2/docs/Data-DList.html
12:35:44 <hsk3> Why do you reckon the authors didn't make a Traversable instance for DList?
12:35:45 <hsk3> I thought Traversable was a pretty standard thing in Haskell.
12:35:49 <drostie> summons demons.
12:35:53 <cheater> obviously it rolls your matrix printer's roll down by 4 lines
12:36:29 <Cale> hsk3: Traversable didn't exist yet
12:36:29 <cheater> so that it doesn't have to return the carriage to the beginning of the line and then shuttle to the same horizontal position again
12:36:53 <hsk3> Cale: Aug 23, 2015
12:36:56 <Cale> hsk3: At least to me, Traversable still seems like a relatively new development
12:37:04 <hsk3> Traversable is that new?
12:37:06 <hsk3> Wow.
12:37:20 <cheater> coming from haskell, is the rust type system fun to work with? or are there cringeworthy issues that you just wish weren't there?
12:37:26 <cheater> yes hsk3 it is new
12:37:52 <hsk3> doesn't rust have this <T, U> syntax mess like C++?
12:37:53 <Cale> I'm amazed that this dlist library saw an update in 2014 even
12:37:56 <Cale> It's from 2007
12:37:57 <Cale> haha
12:37:58 <hsk3> nothing as beautiful as Haskell
12:39:29 <schell> does anyone have any tricks for getting stack or ghc to use less memory when compiling? i seem to be hitting the 2GB limit on my CI server
12:40:27 <monochrom> ghc <your other arguments> +RTS -M100M
12:40:46 <monochrom> that says "heap bounded by 100MB"
12:40:55 <schell> ah, thanks ;)
12:41:05 <schell> i guess the tradeoff is time?
12:41:17 <Cale> schell: The tradeoff is the compiler stops running
12:41:21 <mizu_no_oto_work> monochrome: The only reason I can think of for writing Haskell with tabs is if you're writing at an organization with an ancient and cross-language indentation policy
12:41:22 <schell> lol
12:41:33 <schell> well i guess that’s just as bad as failing!
12:41:59 <Cale> schell: Well, it's perhaps better than having your entire system thrash a whole lot before it's memkilled
12:42:00 <mizu_no_oto_work> so your options would be 'Haskell with tabs', 'no Haskell', and 'find a new job'
12:42:23 <monochrom> it fails earlier, and less impact on other jobs on the same computer
12:42:35 <Cale> mizu_no_oto_work: If they have a policy like that, probably there are many other reasons to find a new job.
12:42:49 <schell> okay, thanks for the info
12:42:56 <Cale> schell: more practically...
12:43:05 <Cale> schell: See if you can break the module down into smaller pieces
12:43:12 <monochrom> mizu_no_oto_work: I prefer early retirement and/or start one's own business
12:43:26 <Cale> schell: and then import and re-export the pieces from the original module
12:43:26 <maks_> 3
12:43:51 <schell> Cale: i wish i could - it actually seems to be an upstream dependency (JuicyPixels)
12:44:13 <monochrom> no, I mean, I prefer haskell with tabs (I know how to do it with ease), followed by the two I mentioned
12:45:06 <monochrom> JuicyPixels is not famous for needing 2GB to build
12:45:42 <EvanR> stupid question i know but, is there a type class for unwrap :: f a -> a
12:45:58 <schell> monochrom: maybe it’s stack, then?
12:46:01 <monochrom> is it maybe CoPoint?
12:46:31 <EvanR> for functors like data Flagged a = Stop a | Go a
12:46:35 <EvanR> CoPointed?
12:46:35 <Cale> schell: There was an example of this I dealt with recently in a module which basically just exported a giant template-haskell-generated map of metadata for all of emojione's shortcodes. It was somehow managing to use more than 8GB of memory to build after we switched to GHC 8.0.1 (Perhaps a performance regression? I haven't had the time to look into what's happening.) But I split the module into 26 separate ones for ea
12:46:35 <Cale> ch letter of the alphabet, and then merged the maps together, and that fixed the space issue.
12:47:34 <EvanR> what are the laws
12:48:24 <EvanR> whatever you put in you get back out
12:48:36 <EvanR> which seems like just parametricity
12:49:01 <Cale> Well, if you want laws, you can see if you can get a comonad.
12:49:24 <EvanR> actually everything im thinking of is probably comonad
12:50:55 <EvanR> duplicate (Stop x) = Stop (Stop x)
12:50:59 <drostie> hsk3: not even sure how a DList traversable would actually work, staring at the sequenceA of taking a [f a] -> [f a] and producing a f([a] -> [a]) confuses me. Maybe the right solution 'morally' is just to apply the inner function to [], sequenceA whatever you get so you have f [a], and then fmap (++) on that to get the right f([a] -> [a]) ?
12:51:01 <EvanR> duplicate (Go x) = Go (Go x)
12:51:39 <drostie> hsk3: but it'd suck if DLists could do all of these other things O(1) but somehow traverse was O(n).
12:51:52 <hsk3> drostie: yeah...
12:52:44 <hsk3> pity
12:52:54 <EvanR> so many instances to write manually ...
12:53:02 * hackagebot vimeta 0.2.2.0 - Frontend for video metadata tagging tools  https://hackage.haskell.org/package/vimeta-0.2.2.0 (PeterJones)
12:53:04 <EvanR> can we have programmable deriving
12:53:44 <Cale> drostie: Well, there are plenty of other things you can't do well with DLists.
12:54:14 <drostie> fair point; they do have an O(n) head operation.
12:54:14 <Cale> I think the best implementation of Traversable is to convert to list, traverse that, and then fmap convert back.
12:55:10 <mgsloan> Cale: Oddly enough, in the presence of a lot of inlining, splitting up typeclasses can drastically improve compilation performance
12:58:38 <arcetera> why is there a need for genericLength, genericTake, genericDrop... etc
12:58:46 <arcetera> why not just use normal length/take/drop
12:59:08 <EvanR> yes, why not just have the generic versions and call them length, take, drop
12:59:16 <arcetera> exactly
12:59:55 <EvanR> also map = fmap
13:00:00 <EvanR> also
13:00:01 <EvanR> ...
13:00:21 <hsk3> Does manually typing out  {-# INLINE func_name #-}  have any purpose whatsoever with -O2 ?
13:00:56 <hpc> when you need to guarantee inlining
13:01:12 <hpc> there's some very low-level examples that deal with weird IO stuff
13:01:21 <hpc> unsafeDupablePerformIO is one of them iirc
13:05:57 <acowley> hsk3: Yes! GHC has a size threshold for what can be inlined, and the INLINE pragma overrides that.
13:08:02 * hackagebot hashmap 1.3.1 - Persistent containers Map and Set based on hashing.  https://hackage.haskell.org/package/hashmap-1.3.1 (ryanglscott)
13:25:41 <hsk3> acowley: so if I add an INLINE to some humongous function, Haskell would actually inline that?
13:28:09 <EvanR> do what i say not what i ... uh
13:28:17 <EvanR> right
13:33:03 * hackagebot text-conversions 0.3.0 - Safe conversions between textual types  https://hackage.haskell.org/package/text-conversions-0.3.0 (lexi_lambda)
13:54:10 <fishythefish> Say I have several functions Double -> Bool where the input Double can be either a success rate x or the related failure rate 1 - x. I want to have all of these in a single list, but I want the type to indicate the sort of input it should take. I also want to iterate over this list with a given value x and for each function determine whether x or 1 - x should be used based on the type. Is this possible?
13:55:36 <mauke> not with different types, but with a single type with two constructors
13:57:21 <fishythefish> mauke: yeah, should've thought of that myself. The code I'm refactoring is trying to solve this problem with phantom types.
13:57:48 <raek> fishythefish: you can use the type "Either Double Double". Then "Left x" could be failure rate and "Right x" success rate.
13:58:35 <mauke> [Either (Double -> Bool) (Double -> Bool)]
13:58:47 <mauke> or you could pair them with a Bool
13:58:52 <raek> all elements in a list have the same type, unless you introduce exisential types or other tricks
13:59:20 <fishythefish> raek: Not opposed to existentials per se, but what you and mauke suggested is the obvious solution
13:59:20 <fishythefish> Thanks
14:00:51 <raek> hrm. is there a type class or something that can be used to encode that "Either Double Double" and "(Bool, Double)" are isomorphic?
14:01:34 <fishythefish> class Iso a b where iso :: a -> b; uniso :: b -> a or something like that?
14:01:34 * geekosaur would probably go with a dedicated type, though, since "Success" and "Failure" are easier to understand in context than "Right" and "Left"
14:01:36 <fishythefish> I'm sure that exists
14:01:58 * fishythefish is with geekosaur
14:03:41 <raek> fishythefish: yeah, exactly!
14:04:15 <shachaf> There's no canonical isomorphism between those types.
14:06:04 <fishythefish> raek: though that does limit you to choosing a single isomorphism between two types (without wrapper types)
14:06:26 <drostie> shachaf: there isn't? Left x --> (False, x), Right x --> (True, x).
14:07:16 <drostie> reversed by if fst tuple then Right (snd tuple) else Left (snd tuple)...
14:07:29 <fishythefish> Can you call that canonical? Left x --> (True, x); Right x -> (False, x) is equally valid.
14:07:40 <glguy> drostie: or you could switch the booleans the other way around, and it has a different number of bottom elements
14:08:49 <glguy> or it could be Left x -> (True, x) Right x -> (False, negate x)
14:09:18 <EvanR> it's not canon
14:09:48 <drostie> I mean, that requires the Num typeclass, no?
14:09:56 <drostie> But I get the point.
14:10:12 <glguy> Well, Double's definitely an instance of Num, so that's covered
14:10:17 <fishythefish> ^
14:10:17 <drostie> Stress on the word "Canonical"; but we can choose the obvious one to be canon.
14:11:01 <fishythefish> drostie: what makes the choice of isomorphism obvious?
14:11:17 <drostie> fishythefish: basically the fact that one preserves Ord.
14:11:35 <drostie> And doesn't invoke any other stuff.
14:11:38 <monochrom> "L" is alphabetically before "R", "F" before "T" :)
14:12:00 <monochrom> this invokes the most irrelevant reason :)
14:12:10 <shachaf> Much better to have values representing your isomorphisms, rather than class instances.
14:12:17 <fishythefish> monochrom: lexicographic Ord is best Ord?
14:12:17 <shachaf> Then you can just say which one you mean.
14:13:20 <EvanR> drostie: we can call it "the arbitrary isomorphism"
14:13:39 <EvanR> its more arbitrary than the others
14:13:55 <roconnor__> ugh, the order of arguments for Data.Vector.Unboxed.Mutable.move and copy are not haddocked.
14:14:28 <EvanR> pulling in other structures like Ord is interesting though, also arbitrary
14:15:27 <fishythefish> Meh, let's just agree to call unsafeCoerce the canonical isomorphism /j
14:16:20 <monochrom> @quote monochrom Coerce
14:16:20 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
14:16:45 <floralshoppe> FP is a meme
14:17:15 <fishythefish> as long as it's a dank meme, I can live with it
14:17:46 <monochrom> I was a genius. I wrote a rondo of 3 canonical isomorphisms in one go.
14:18:10 * fishythefish applauds
14:18:12 * glguy remembers when monochrom was a genius
14:18:52 <raek> shachaf: sounds better. is there an isomorphism type in a library or something?
14:19:10 <shachaf> There's one in lens.
14:19:43 <shachaf> It even has a class for certain canonical isomorphisms (a newtype with its underlying type).
14:20:14 <raek> hrm. some day I need to look into lens more seriosly
14:20:56 <raek> I don't know what I am supposed to use lenses for, except for "composable getters and setters"
14:21:30 <raek> but reaching deeply into data structures seems like a code smell for me...
14:21:36 <monochrom> I used the basic part of it for first-class reference
14:21:59 <drostie> That's basically it. You're supposed to use lenses when you don't mind a hefty library dependency and you want to be able to say set (complicated expression that looks like it gives you a value) to (some value you want it to have).
14:22:19 <monochrom> and it fact my use eliminated, not add, a code smell. the code smell in all BST-balancing (rotation) implementations.
14:23:17 <monochrom> the code smell that you have two copies of rotation code, only because one is for the left and the other is for the right. you write one copy and then you write its mirror image.
14:23:50 <raek> making concepts first-class values seems like a good idea
14:23:51 <monochrom> and you wonder why you can't write it just once and take a parameter (or two) to stand for "left" vs "right"
14:24:04 <monochrom> well, lens is that parameter
14:24:08 <raek> interesting.
14:24:15 <Habib> i heard interesting
14:25:08 <Habib> Favourite use of the function application function?
14:25:34 <nitrix> zipWith ($) ?
14:25:53 <fishythefish> eliminating parentheses?
14:26:25 <Habib> Didn't think of that, but I was gonna say, no eliminating parentheses and map ($) list_of_functions before fishythefish beat me to it.
14:26:50 <EvanR> raek: concepts are cool, as long as they are well defined... so rather than values maybe they should be types
14:27:25 <Habib> I just used it as io_action_that_returns_a_function >>= ($ arg)
14:27:47 <Habib> io_action_that_returns_a_function_that_returns_an_io_action, rather
14:28:01 <Habib> I'm sure there's a better way to write that.
14:28:11 <monochrom> @type \i a -> i >>= ($ a)
14:28:12 <lambdabot> Monad m => m (a -> m b) -> a -> m b
14:28:25 <EvanR> raek: im trying to figure out whether deeply nested data structures is considered good bad ugly or it depends by people
14:28:33 <monochrom> @type \i a -> i <*> pure a
14:28:34 <lambdabot> Applicative f => f (a -> b) -> a -> f b
14:28:42 <raek> io_action_that_returns_a_function <*> arg ?
14:28:43 <drostie> Habib: I had a nice library which exposed a combining function any :: [Rule] -> Rule.
14:28:45 <monochrom> ah, not quite the same
14:29:03 <EvanR> and why and what the alternative is
14:29:09 <monochrom> @type \i a -> join (i <*> pure a)
14:29:10 <lambdabot> Monad m => m (a1 -> m a) -> a1 -> m a
14:29:14 <monochrom> :)
14:29:19 <glguy> do f <- io_action_that_returns_a_function_that_returns_an_io_action; f arg
14:29:19 <drostie> Habib: it turned out to be a one-liner, any rules page = concat $ map ($ page) rules
14:29:34 <Habib> drostie: thank you, for some reason I tried <$>
14:30:40 <monochrom> there is also concatMap for the finishing touch
14:31:03 <shirt> what are good recent hackage packages to look at to study current modern haskell best-practices?
14:31:10 <drostie> monochrom: yes but that breaks symmetry with the corresponding all rules page = mergeAll $ map ($ page) rules, which doesn't use concat. :P
14:31:17 <Habib> whoops, meant to direct my last message to raek, who volunteered the <*> solution
14:31:25 <monochrom> and beyond finishing touch: concatMap = flip (>>=)
14:31:43 <Habib> drostie: I'm not sure what any does there
14:31:56 <monochrom> ah, I have to think up something else
14:32:20 <drostie> Habib: it creates a Rule from a list of other Rules. In this case the new rule matches whenever any of the other rules match.
14:32:30 <fishythefish> monochrom: and beyond that, concatMap = (=<<)
14:32:41 <drostie> (This is all in the context of a DSL, so Prelude.any and Prelude.all are shadowed explicitly.)
14:33:10 <Habib> What does the page argument refer to?
14:33:19 <drostie> Habib: a web page.
14:33:25 <Habib> Oh, haha.
14:34:47 <drostie> Basically type Rule = Page -> [Match], Match is something complicated, mergeAll m1s m2s = [mergeMatch m1 m2 | m1 <- m1s, m2 <- m2s].
14:35:51 <drostie> there is also a mergeAny = concat, and then the two "rule combinators" any and all are defined as mergeAny $ map ($ page) rules and mergeAll $ map ($ page) rules. Should hopefully be straightforward for whoever my successor is.
14:36:23 <Pamelloes> Is it provable that all functions with the same type signature are equivalent or equivalent to undefined--given that the type signature has no fixed points?
14:37:02 <Habib> What was this DSL for and what's it called?
14:37:22 <fishythefish> Pamelloes: I think that statement is false
14:37:37 <EvanR> Int -> Int
14:37:50 <mjrosenb> Pamelloes: (+1) and (\x->0-x) have the same type signature.
14:37:52 <mjrosenb> efb.
14:38:34 <Pamelloes> Errr... Sorry, I meant no fixed type signatures
14:38:37 <mauke> (a,a) -> a
14:38:37 <Pamelloes> *types
14:38:49 <Pamelloes> Ah!
14:38:54 <mauke> AAAAA
14:39:05 <Pamelloes> Hmmm
14:39:42 <drostie> Habib: it is a middleman between a bunch of nontechnical users who type expressions in a simplified version of Haskell in a web app form, there is JS to parse that and typecheck it as a Rule, and then those Rules get scheduled to be run on subsets of a database of saved web pages to mine them for information.
14:39:57 <pikajude> hey, TypeApplications are neat!
14:40:12 <Pamelloes> mauke: If you prohibit a type occurring twice in the same parameter, then does it become true?
14:40:46 <mauke> Pamelloes: [a] -> [a]
14:41:20 <drostie> The simplified Haskell DSL has lists, function applications, strings, and grouping parentheses, but no operators or lambdas or other things that would be really hard to explain to a nontechnical user.
14:41:37 <Pamelloes> mauke: Errrr, multiple values of the same type (i.e. prohibiting tuples and lists)
14:41:47 <Pamelloes> (and any other collection)
14:41:50 <mauke> Pamelloes: a -> a -> a
14:42:05 <shachaf> I don't understand the original question.
14:42:05 <Habib> Where can I go to check it out?
14:43:33 <drostie> Habib: it's proprietary; there is nowhere to go to check it out.
14:44:30 <mauke> shachaf: how to restrict type signatures to ensure that there's only one value of this type (modulo bottom)
14:44:46 <Pamelloes> mauke: Alright, my original premise was flawed clearly
14:44:47 <Habib> That's a shame, I would have liked to have seen that.
14:45:03 <Pamelloes> But, for instance, a -> a has only id
14:45:22 <Pamelloes> and a -> b -> a has only const
14:45:33 <drostie> But basically it allows the people at the company to say things like `all [justOne (block ["| Times", "| Post"] (any [has "NY", has "New York"])), any [things-which-are-illegal-to-say-in-NY-State]]` and they then get results where the page somewhere says NY or New York, but not where the only such mentions are the NY Times or NY Post...
14:46:03 <shachaf> mauke: Of which type?
14:46:12 <Habib> That's pretty cool.
14:46:52 <mauke> shachaf: any type?
14:46:59 <Pamelloes> Yep
14:47:36 <EvanR> Pamelloes: and a -> a -> a has more than 1 impl
14:47:42 <Pamelloes> shachaf: I'm curious what function types have only one possible definition (and undefined)
14:48:16 <mauke> Pamelloes: a -> a has at least 3
14:48:21 <Pamelloes> 3?
14:48:22 <mauke> id, const undefined, undefined
14:48:32 <EvanR> bottom be damned
14:48:37 <Pamelloes> mauke: const undefined is the same as id
14:48:37 <monochrom> oh haha
14:48:49 <monochrom> perhaps you should ask about System F rather than Haskell
14:48:52 <mauke> > id ()
14:48:54 <lambdabot>  ()
14:48:58 <mauke> > const undefined ()
14:48:59 <lambdabot>  *Exception: Prelude.undefined
14:49:02 <drostie> Habib: Yeah. One of the cases where switching to a strongly typed language really saved me. It turns out the original definition of a Match was a list of other things, and so you had Page -> [[OtherStuff]] which when written in a type-unsafe language was insanely buggy; things were being improperly concat'ed.
14:49:03 <srpx> Is there any reason for haskell-blah to ban freenode's webchat client?
14:49:13 <Pamelloes> mauke: : Sorry, const undefined is the same as undefined
14:49:20 <mauke> > undefined `seq` ()
14:49:21 <shachaf> Not in Haskell.
14:49:22 <lambdabot>  *Exception: Prelude.undefined
14:49:24 <mauke> > const undefined `seq` ()
14:49:26 <monochrom> srpx: haskell-blah's admin insists on TLS connections
14:49:26 <lambdabot>  ()
14:49:46 <Pamelloes> hmmm
14:50:36 * srpx sighs
14:50:37 <srpx> ok
14:53:06 * hackagebot microlens 0.4.4.1 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.4.1 (Artyom)
14:56:02 <Habib> raek: <*> doesn't work unfortunately, as its type is `Applicative f => f (a -> b) -> f a -> f b`, when we want something like `Applicative f => f (a -> b) -> a -> f b`
14:56:15 <Habib> Late response, I know
14:57:04 <EvanR> :exf Applicative f => f (a -> b) -> a -> f b
14:57:05 <exferenceBot> \ a b -> fmap (\ f6 -> f6 b) a
14:57:21 <EvanR> @pl \ a b -> fmap (\ f6 -> f6 b) a
14:57:21 <lambdabot> flip (fmap . flip id)
14:57:21 <fishythefish> Habib: you can lift the a with `pure` first
14:57:34 <EvanR> :t (<*>) . pure
14:57:35 <lambdabot> Applicative f => (a -> b) -> f a -> f b
14:57:51 <Habib> other way?
14:57:56 <EvanR> :t pure . (<*>)
14:57:58 <lambdabot> (Applicative f, Applicative f1) => f1 (a -> b) -> f (f1 a -> f1 b)
14:58:23 <fishythefish> :t \f a -> f <*> pure a
14:58:24 <lambdabot> Applicative f => f (a -> b) -> a -> f b
14:58:44 <Habib> Don't like lambdas.
14:59:02 <fishythefish> Feel free to use combinators to eliminate them
14:59:04 <EvanR> f <*> pure x <*> bar <*> baz
15:00:06 <fosskers> hi everyone
15:00:12 <EvanR> let f (<*>>) x = f <*> pure x
15:00:13 <Habib> What's a combinator in the context of Haskell?
15:00:20 <EvanR> f <*>> x <*> bar <*> baz
15:00:20 <Habib> Hi fosskers.
15:01:09 <Habib> Sorry, that's one for google.
15:01:21 <fosskers> If I have a `[Foo]`, which is concrete, can the individual `Foo` have polymorphic contents?
15:01:53 <EvanR> Foo can be an existentially quantified type constructor
15:02:27 <EvanR> i mean, data constructor... data Foo = forall a . Foo ... a ...
15:02:29 <fosskers> what I need is a homogenous list of Foo, but Foo have contents which may vary by typeclass
15:02:33 <fishythefish> :t (. pure) . (<*>)
15:02:34 <lambdabot> Applicative f => f (a -> b) -> a -> f b
15:02:42 <fishythefish> Habib: ^
15:02:43 <EvanR> are you sure you need type classes though
15:02:59 <fishythefish> Personally, I find the lambda cleaner. Or give it a name.
15:03:06 * hackagebot hashmap 1.3.1.1 - Persistent containers Map and Set based on hashing.  https://hackage.haskell.org/package/hashmap-1.3.1.1 (ryanglscott)
15:03:11 <EvanR> <*>> is pretty nice ;)
15:03:16 <Habib> At that point, I might as well say a >>= ($ arg)
15:03:27 <Habib> :t (<*>>)
15:03:28 <lambdabot>     Not in scope: ‘<*>>’
15:03:28 <lambdabot>     Perhaps you meant one of these:
15:03:28 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
15:03:33 <EvanR> i defined it above
15:03:36 <fosskers> perhaps not. What I really need is said "contents" to themselves be homogeneous, but they may vary at the foo level
15:03:36 <glguy> the do-notation version is still the clearest
15:03:37 <fishythefish> Habib: You specified Applicative, not Monad ;)
15:04:18 <fosskers> say, data Foo = Foo [Bar]
15:04:25 <EvanR> fosskers: theres different things you can do, but your list has to have a uniform interface to it in any case
15:04:37 <Habib> Touché
15:05:15 <fosskers> But Bar could be one of three things. They can't be a normal union type, because the list has to have the same contents
15:05:27 <fosskers> So, data Bar = B1 | B2 | B3 wouldn't work
15:05:36 <Habib> But in my case, it is a Monad, so bind is fine.
15:05:44 <EvanR> what does the three different things have in common
15:05:51 <fosskers> Because if I have a list of Bar, they need to have the same contents ([B1,B2,B3] is bad)
15:06:07 <EvanR> how will you make use of this list
15:06:30 <fishythefish> So [Bar] needs to be homogeneous, but all you know is the element type could be one of three things?
15:06:44 <EvanR> you have to know something else
15:06:56 <fosskers> indeed, I'm thinking.
15:07:05 <EvanR> also [B1,B2,B3,B2,B2] would totally work if thats all there is to it
15:07:12 <EvanR> they are all the same type
15:07:32 <fishythefish> EvanR: I think those constructors represent semantically different things
15:07:38 <fishythefish> And fosskers wants them to be the same
15:07:44 <fosskers> fishythefish, yes
15:07:59 <EvanR> i dont really understand what that means, the same, but different
15:08:14 <fosskers> let me use real examples
15:08:22 <fishythefish> fosskers: Any reason Foo can't be parameterized?
15:08:25 <drostie> fosskers: if you want the type system to prevent someone from using multiple constructors in the list, the difference between the constructors has to manifest at the type level.
15:08:48 <drostie> fosskers: that leads to 3 different types B1, B2, B3 so that [B1, B2, B3] is impossible.
15:09:08 <fosskers> one minute, I'm considering my requirements
15:09:34 <drostie> fosskers: then you take whatever functions you had over your B1 | B2 | B3 data type and turn that into a typeclass, class Bar b where {...}
15:10:05 <EvanR> that..... better let them figure out what they actually are trying to do
15:10:27 <drostie> yeah...
15:12:08 <fosskers> ok, I work in GIS
15:12:37 <fosskers> Given `Point`, `Line`, and `Polygon`, I'd like to have functions that work on those unique types
15:12:46 <fosskers> a la: length :: Line -> Int
15:13:01 <fosskers> area :: Polygon -> Float
15:13:03 <fosskers> etc
15:13:14 <fishythefish> fosskers: So just define those?
15:13:21 <monochrom> and Point->?
15:13:28 <fosskers> Now, these three things can collectively be called "Features", and have behaviour in common (typeclasses!)
15:13:31 <EvanR> Point -> ()
15:13:52 <EvanR> what is the common behavior?
15:14:01 <monochrom> Int and Float aren't the same type. do you know that?
15:14:02 <nathyong> Anybody know if it's possible to run GHCi on modules inside the GHC code base?
15:14:16 <fosskers> metadata, for one
15:14:49 <drostie> Or if you had a graphical package you might have class Drawable d where draw :: Screen -> d -> IO ()
15:14:51 <monochrom> . o O ( what is metadata? we just don't know )
15:15:12 <fosskers> drostie, yeah
15:15:27 <drostie> fosskers: you've described a bunch of simple things, do you have a problem or have you worked it all out now?
15:15:38 <fosskers> now a feature can be a single instance of one of those objects, or it can be a group of them
15:15:54 <fosskers> Collectively, a group of features is called a Layer, but let's just pretend it's a list
15:16:22 <drostie> You mean a list of points, lines, and polygons?
15:16:35 <fosskers> essentially, but further abstracted
15:16:52 <fosskers> if you have a Feature, which is a list of one of those three things, said list must be homogeneous
15:17:22 <Squarism> one thing i feel is a real drawback with haskell record/values compared to say java is the situation : 1. you sit there in some "create this half complex function" context with a number of values. 2. you know you prolly have all data you need. 3. You feel unsure how data was packed in the different values. 4. May be a question on IDE feature but i imagine its better to look around in your values if it 
15:17:22 <Squarism> would be laid out like obj.field1.field2
15:17:25 <drostie> Ok. Then indeed Point, Line, Polygon should be different types, Feature should be parameterized over those types.
15:17:49 <fishythefish> e.g. data Feature a = Feature [a]
15:17:51 <fosskers> drostie, but then I can't have a list of Features, can I?
15:18:02 <drostie> fosskers: you can!
15:18:07 * hackagebot eventstore 0.13.0.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.0.1 (YorickLaupa)
15:18:14 <drostie> fosskers: but it is a bit complicated. :)
15:18:30 <fosskers> [Feature Point, Feature Line, Feature Polygon] wouldn't compile, yeah?
15:18:38 <fosskers> drostie, lol I've noticed, hence I'm here
15:18:41 <fishythefish> Existential types!
15:18:42 <drostie> fosskers: correct.
15:18:51 <fosskers> yeah, let's get to the meat here
15:19:04 <drostie> fosskers: what you need is a way of forgetting everything about a type except for an interface that it implements.
15:19:18 <fosskers> sounds like a typeclass
15:19:19 <drostie> Interfaces are combinations of typeclasses, so that's easy. 
15:19:46 <drostie> The rest of it is the magic word "forall" which appears if you :set -XRank2Types in GHCi.
15:20:34 <fosskers> a ha, this is wizardry I've seen plenty but never had to touch myself
15:20:45 <drostie> what you want is newtype DrawList = DrawList [forall d. Drawable d => d] or stuff like that.
15:21:05 <fosskers> yeah. is that evil?
15:21:11 <rfw> what's the purpose of the reader monad? just to hide an argument to a function?
15:21:31 <drostie> fosskers: no, but there is evil that it can potentially lead to/
15:21:47 <fosskers> rfw, read-only state
15:22:08 <rfw> fosskers: so is passing in the state as the first argument, though?
15:22:13 <fosskers> you can use it to build up a big run-time environment and query it
15:22:36 <drostie> fosskers: I guess even more simply, data DrawWrap = DrawWrap (forall d. Drawable d => d) is also enough, then you can just write [DrawWrap].
15:22:41 <fosskers> rfw, true, but using it as a Monad gives you more power
15:23:08 <rfw> fosskers: oh, in what way 
15:23:25 <drostie> Also, maybe you can newtype that?
15:23:55 <fosskers> rfw, convenience functions that come with Reader, and the ability to mix Reader into other monad transformers
15:24:08 <fosskers> `local` is one such function
15:24:12 <hpc> it doesn't really give you more power, so much as using Reader writes a whole bunch of functions for you
15:24:22 <rfw> I'm just struggling to see why it's useful, especially since you have to mess with monad transformers to compose computations 
15:24:25 <hpc> :t when
15:24:26 <lambdabot> Applicative f => Bool -> f () -> f ()
15:24:26 <SrPx> I wonder why nobody has given any feedback on my post, is the whole idea bad for some obvious reason I'm missing, are people just not interested? I'd really appreciate some of your insight on that one...
15:24:42 <hpc> actually when isn't terribly useful for Reader
15:24:43 <hpc> but still
15:24:55 <drostie> fosskers: so here's the drawback to DrawWrap. Once something goes into the DrawWrap constructor, you can't get its original type back out. So now you have to resist the temptation to define in some interface some function like "className :: d -> String" and then the temptation to do things like (if className d == "Point" then f (unsafeCorce d :: Point) else something)
15:25:14 <fosskers> drostie, oh god, spare me
15:25:35 <drostie> fosskers: if you can resist those temptations then Rank2Types and RankNTypes will work well for you.
15:25:38 <hpc> fosskers: there is a solution though
15:25:55 <hpc> fosskers: instead of class Drawable d where foo :: d -> Bar, ...
15:25:58 <Enigmagic> GADTs
15:26:15 <hpc> fosskers: you likely want data Drawable = Drawable {foo :: Bar, ...}
15:27:10 <fishythefish> So in my earlier example, data Func = SuccessFunc (Double -> Bool) | FailureFunc (Double -> Bool), suppose I add type wrappers for Double to distinguish between success rate and failure rate, so only the right one can be passed to the function.
15:27:19 <drostie> Right, you can also skip all of this by observing e.g. that a typeclass is really just a value paired with some functions to manipulate that value which happen to come along with the class for the ride, and then you can simply store the values of all of those functions applied to that value (lazy language!) etc.
15:27:48 <fishythefish> How can I deduplicate code like `foo (SuccessVal lim) = SuccessFunc (> lim); bar (FailureVal lim) = FailureFunc (> lim)`?
15:28:07 * hackagebot distributed-process 0.6.3 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.3 (FacundoDominguez)
15:29:13 <drostie> so if you had class Drawable d where {bounds :: d -> BoundingBox; draw :: Screen -> d -> IO ()}, you can now rewrite that as data Drawer = Drawer {bounds :: BoundingBox, draw :: Screen -> IO () } instead, and then accept a [Drawer].
15:29:47 <drostie> And then you don't need Rank2Types any more.
15:30:07 <fishythefish> mauke / geekosaur: you might remember my example above?
15:35:36 <drostie> fishythefish: at this point by far the easiest way is to convert to one choice and use it consistently; it might be best for example to just have a function successProb (SuccessProb p) = p; successProb (failProb q) = 1 - q, so that when you're in the middle of the calculation you know which one you're using.
15:36:09 <drostie> er, that second one should be successProb (FailProb q) with a capital F.
15:36:49 <drostie> Then you no longer have a distinction between SuccessFunc and FailFunc but only between SuccessProb and FailProb.
15:37:01 * SrPx feels invisible
15:37:03 <fizruk> hey guys! is there somewhere in libraries a function like this? https://gist.github.com/fizruk/740c3e7818b06013c2cd10cab494228a
15:37:05 <SrPx> okay then :(
15:37:06 <drostie> Meanwhile you can still have functions which return a SuccessProb or FailProb.
15:37:10 <fishythefish> Hm. In practice, I can't actually do that because there could be an additional pending rate, i.e. it's not the case that successRate = 1 - failureRate
15:37:18 <lethjakman> So, I'm using http.conduit and I have a line like this:
15:37:23 <lethjakman>  response <- httpLBS "http://httpbin.org/get"
15:37:42 <lethjakman> But httpLBS's type signature is MonadIO m => Request -> m (Response ByteString)
15:37:48 <lethjakman> http://haddock.stackage.org/lts-6.2/http-conduit-2.1.10.1/Network-HTTP-Simple.html#v:httpLBS
15:37:53 <lethjakman> Why can I insert a string?
15:38:22 <lethjakman> I don't see any sort of packing or anything...
15:38:57 <lethjakman> My first thought was someone was doing something crazy with overloaded strings.
15:39:24 <gabryel> hello new to this
15:40:33 <drostie> fishythefish: someone was mentioning "why would you have a Reader monad" just recently; sounds like you could use successProb :: SuccessOrFailProb -> Reader PendingRate Double... :P
15:43:13 <drostie> fishythefish: or you might need to just graduate to a datatype with smart constructors if you know the pending rate in advance, data Rates = Rates {pending :: Double; success :: Double; failure :: Double}
15:43:37 <drostie> successPending :: Double -> Double -> Rates
15:43:44 <drostie> etc.
15:44:19 <lyxia> lethjakman: you didn't shadow httpLBS?
15:44:39 <lethjakman> lyxia: No. I've just imported the library. 
15:44:45 <fishythefish> drostie: I guess I'm more interested in whether I can express this in the type system
15:45:20 <fishythefish> i.e. suppose there isn't a clean mathematical relationship to be exploited here
15:45:54 <pikajude> are there any haskell libraries for reading an RSA public key from a pem file?
15:46:32 <maks_> pikajude: have you tried Crypto? I can't guarantee it has it but it's a pretty large lib
15:46:48 <pikajude> no such package exists, so no
15:46:56 <pikajude> oh, ok
15:46:58 <pikajude> i misspelled it
15:48:25 <fishythefish> pikajude: Check cryptonite as well
15:48:27 <lyxia> lethjakman: well that you can use a string in place of a non-string means you are using OverloadedStrings. I'm looking for its definition.
15:48:27 <maks_> pikajude: last answer http://stackoverflow.com/questions/20318751/rsa-sign-using-a-privatekey-from-a-file
15:49:02 <Squarism> is advisable for a noob to install GHC 8?
15:49:21 <pikajude> oh, crypto-pubkey-openssh
15:49:24 <pikajude> finally
15:49:37 <lethjakman> Ahhh, so I was on the right track. 
15:49:49 <drostie> fishythefish: you almost certainly can, sure. What might be best is, we've talked a lot about sort of bottom-up programming, but maybe this is the sort of problem that you need to tackle with wishful thinking and a top-down approach. Write your algorithms as if you had some magical apprentice who immediately runs off and starts writing these functions you're penning down -- what shape do the algorithms take? Now run GHC, it will give you compiler errors 
15:49:49 <drostie> that you haven't defined a bunch of stuff, first just fill in stubs (foo = undefined) with some type signatures, try to see where you're accidentally screwing up types in your fleshy human brain. Finally once the type signatures compile, start filling in the stubs that you wished into existence earlier. 
15:50:18 <maks_> Squarism: i don't advise it
15:50:28 <pikajude> "Failed reading: Invalid key type"
15:50:29 <maks_> Squarism: i did it and couldn't install *many* packages afterwards
15:50:30 <pikajude> jesus christ
15:50:40 <fishythefish> pikajude: There's also HsOpenSSL
15:50:42 <drostie> fishythefish: Keep in mind that you want this type-level distinction of those success and failure probabilities and see where they get naturally resolved.
15:50:42 <Squarism> maks_, ok, good to know
15:50:48 <pikajude> yeah, but I haven't seen anything for parsing in HsOpenSSL
15:50:54 <maks_> Squarism: I  had to go back to the 7.* version
15:51:22 <cheater> if i have a value in my haskell program, can i somehow erase it such that that value does not exist in memory any more?
15:51:24 <lyxia> lethjakman: https://s3.amazonaws.com/haddock.stackage.org/lts-6.2/http-client-0.4.28/src/Network-HTTP-Client-Request.html instance IsString Request
15:51:33 <cheater> in specific something like a cryptographic key or an password
15:52:05 <fishythefish> pikajude: https://hackage.haskell.org/package/HsOpenSSL-0.11.1.1/docs/OpenSSL-PEM.html#v:readPublicKey
15:52:12 <lethjakman> Ohhhh
15:52:14 <lethjakman> OK
15:52:16 <lethjakman> Thank you!
15:52:22 <lethjakman> Weird. But it makes sense. 
15:52:26 <lethjakman> I've never seen anyone do that. 
15:52:27 <fishythefish> Does that do it?
15:53:03 <pikajude> HsOpenSSL tells me that my key has no start line
15:53:19 <pikajude> since it starts with -----BEGIN RSA PUBLIC KEY-----, not sure what to finger as the problem
15:54:02 <fishythefish> Maybe it uses the other style? Try removing "RSA"
15:54:50 <pikajude> wrong tag
15:55:39 <pikajude> i think it needs PEM_read_bio_RSAPublicKey
15:56:28 <drostie> cheater: I can't see anything so far.
15:57:50 <drostie> cheater: wait! https://hackage.haskell.org/package/securemem-0.1.9/docs/Data-SecureMem.html
16:00:07 <drostie> cheater: with that said, it's sort of a chicken-and-egg problem I suppose because to get the memory into there you need to already have it in, say, a bytestring... not sure you can for-sure scrub this sort of data in Haskell.
16:02:17 <cheater> maybe you would need IO functions that create SecureMem and don't leave other stuff behind
16:02:39 <fishythefish> drostie: This isn't an issue with designing algorithms. Everything already works if I just have doubles everywhere. I'm trying to determine how I can limit certain behavior by encoding information in types.
16:03:53 <Squarism> is it important to start using lenses early? Does it makes things sign easier? 
16:05:31 <notAbot_> Squarism:  no
16:05:32 <fishythefish> Squarism: no
16:06:10 <sm> Squarism: it makes updating deeply nested records much easier. It comes with a (fixed) cost - a few more operators to know, making it harder for people not used to lenses to read your code
16:06:36 <EvanR> but you can roll your own way to update deeply nested data structures
16:07:02 <EvanR> the functional reference / semantic editor combinator trick
16:07:30 <sm> yes, you can always roll your own. The payoff of using lens is less rolling required, and a principled consistent system that'll be familiar across all lens projects
16:07:59 <EvanR> the size of lens and the deps makes me hesitant to embrace that... it feels like C++ boost
16:08:11 <sm> microlens pretty much solves that
16:08:20 <c_wraith> most of the size of lens isn't real. 
16:08:41 <EvanR> and the size of its docs
16:08:47 <sm> unless you have advanced needs, microlens is basically lens that installs much quicker
16:08:51 <c_wraith> most of the size of lens is lenses for lots of packages that would otherwise need orphan instances
16:09:13 <c_wraith> or orphan lenses, I suppose. 
16:09:36 <fishythefish> are orphan lenses just monocles?
16:09:55 <Squarism> sm, fishythefish , notAbot_ .. ok thanks!
16:10:52 <notAbot_> even monocles are huge
16:11:14 <cheater> Squarism: knowing/understanding lenses is relatively unimportant for anyone just doing general programming with haskell
16:12:00 <cheater> they're utility stuff and the theory behind them is unimportant for normal use, and you can normally just get by copypasting from SO or docs
16:12:49 <Hafydd> Oh, god.
16:13:16 <Hafydd> I don't recommend "copypasting from SO or docs" as an alternative to understanding what you're doing.
16:13:26 <sm> I converted something with 3-deep records to use lenses yesterday, and it's not clearly better. Probably in larger projects and with more complex types they start to shine
16:14:07 <Squarism> ok
16:14:23 <c_wraith> it's not really about record access. in my experience, lenses are huge wins when you start structuring your data transformations in terms of traversals. 
16:14:44 <c_wraith> even if there are no records involved. 
16:14:45 <glguy> it's about generalized operations, all the stuff suffixed with -Of
16:14:51 <glguy> records are a corner case
16:15:11 <glguy> working with maps, sets, lists
16:15:13 <sm> but usually the gateway into the lens world
16:16:18 <Hafydd> Lists: a gateway drug to Lenses.
16:19:16 <notAbot_> > ["hello", "world"] !! 0
16:19:17 <lambdabot>  "hello"
16:19:29 <notAbot_> wow! lenses are amazing
16:20:21 <c_wraith> > ["hello", "world"] ^. ix 0
16:20:23 <lambdabot>  "hello"
16:20:57 <Hafydd> lenses :: [[[a]]] -> [[Int]]
16:21:26 <Hafydd> lenses = map (map length)
16:23:47 <notAbot_> I wonder if lambdabot grew much bigger since the inclusion of lens
16:24:26 <c_wraith> lambdabot is agnostic to what its evaluation template contains 
16:24:40 <c_wraith> it just calls mueval
16:24:42 <zipper> Hey dudes I noticed that the travis haskell thing has changed and people are not using a travis_long file anymore
16:25:00 <zipper> However, when I read the travis docs on haskell nothing is really clear
16:25:14 <zipper> Any place I can find something?
16:26:14 <dolio> The win is when you get a big composable grammar of common operations.
16:27:33 <dolio> > let x = ["hello", "world"] in (x ^. ix 1, x & ix 1 .~ "universe", over (ix 1) (++ "s") x, has (ix 1) x)
16:27:35 <lambdabot>  ("world",["hello","universe"],["hello","worlds"],True)
16:32:58 <glguy> zipper: https://github.com/hvr/multi-ghc-travis
16:33:33 <zipper> glguy: Thanks
16:36:59 <zipper> hmmm are you guys not using stack anymore?
16:37:12 <zipper> I can't see much of it in the travis builds
16:42:10 <mgsloan> zipper: http://docs.haskellstack.org/en/stable/travis_ci/
16:42:56 <zipper> mgsloan: Hello
16:42:58 <zipper> Thanks
16:43:36 <Squarism> c_wraith, you have an example of a project that relieas on alot on lenses - preferably in a domain that is easy to understand/does require special knowledge?
16:48:04 <c_wraith> Hmm.  The only thing I know of offhand is an exploration of Cofree for game trees I did a while back. But it was a single file mostly intended to be loaded into ghci and analyzed interactively with the lenses, rather than using them heavily within the source file
16:49:10 <c_wraith> Huh.  I'd put it on lpaste, but lpaste appears dead
16:49:38 <Squarism> i can take whatever paste
16:49:38 <EvanR> its cutting in and out
16:51:45 <c_wraith> https://gist.github.com/chowells79/dbc7c6df2af8f1e00aa6a037c1cfc3d8
16:52:25 <c_wraith> Lots of fun can be had with that, though it's hard to see without some examples.
16:52:39 <c_wraith> I'll put a few into the gist, in a few minutes.
16:53:10 <glguy> zipper: Yeah, for travis ci builds for libraries we just build with cabal directly
16:54:53 <Squarism> c_wraith, thanks alot
16:55:10 <arcetera> what's the difference between map and fmap?
16:55:11 <arcetera> again
16:55:13 <arcetera> dumb questions
16:55:18 <fishythefish> map is fmap specialized to lists
16:55:20 <hpc> fmap is more generic
16:55:21 <hpc> :t fmap
16:55:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:55:23 <hpc> :t map
16:55:24 <lambdabot> (a -> b) -> [a] -> [b]
16:55:33 <hpc> when f = [], fmap = map
16:55:40 <arcetera> so when should i use fmap and when should i use map?
16:55:49 <maerwald> I never use map
16:55:51 <arcetera> does it matter?
16:55:52 <maerwald> but that's just me
16:55:53 <arcetera> ok
16:55:57 <fishythefish> fmap for any Functor, which happens to be map if the functor is [a]
16:56:06 <hpc> you can use fmap in any situation where you could use map
16:56:11 <glguy> You can use map when you want to help type inference to know something is a list
16:56:12 <arcetera> so just use fmap?
16:56:12 <fishythefish> When map is usable, it's the same as fmap
16:56:14 <maerwald> if you use fmap, chances are also high that you have less to do when refactoring types
16:56:19 <fishythefish> That would work, yes.
16:56:19 <maerwald> and it happened to me too, so I never do map
16:56:23 <arcetera> ok
16:56:39 <arcetera> still reading learn you a haskell...
16:56:42 <codebje> :t concatMap
16:56:44 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
16:56:49 <arcetera> i know what concatMap is
16:57:04 <codebje> I was just checking how general it is :-)
16:57:09 <arcetera> ok
16:57:15 <codebje> I use concatMap somewhat frequently, but fmap over map every time
16:57:41 <hpc> i have never used concatMap
16:57:49 <arcetera> alternatively
16:57:54 <arcetera> concat . fmap whatever
16:57:56 <hpc> i maybe used it once or twice in ghci during my first week with haskell
16:58:05 <arcetera> this is my first week with haskell
16:58:14 <arcetera> i am incredibly confused
16:58:15 <hpc> but i am only guessing since it was so long ago
16:58:24 <codebje> hpc, do you use something similar in action now, or concat.fmap ?
16:58:33 <M-Magnap> I've heard something about a proposal for type tags that would be e.g. be used for ensuring that fmap receives a list
16:58:46 <EvanR> :t foldMap
16:58:47 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:58:48 <maerwald> too many functions, I also find it ok to do a bit of "duplication" so I don't have to memorize too much random stuff
16:58:49 <hpc> i use (>>=) in the rare situations where i really want that on lists
16:58:59 <hpc> usually i can express it with join or as a fold instead
16:59:30 <hpc> arcetera: things will gradually start to make more sense
16:59:41 <maerwald> hpc: you also do: join (+) 4? :P
16:59:43 <M-Magnap> But I don't remember enough about it to google it :/
16:59:46 <EvanR> and other things will make less sense
16:59:46 <arcetera> why does concat . fmap (replicate 4) [1..3] not work, but concat . fmap (replicate 4) $ [1..3]
16:59:50 <arcetera> does work
16:59:51 <M-Magnap> Something with the '@' symbol
16:59:57 <arcetera> oh yeah i was meaning to ask
17:00:00 <arcetera> what does @ do
17:00:26 <EvanR> does LYAH use @ without explaining it?
17:00:29 <arcetera> yes
17:00:30 <hpc> it depends on where you use it, but it's definitely not first-week material ;)
17:00:31 <EvanR> lol
17:00:31 <arcetera> apparently
17:00:33 <M-Magnap> arcetera: the meaning that I know of of @ is in pattern-matching
17:00:40 <M-Magnap> It matches the entire pattern
17:00:43 <fishythefish> let l@(x:xs) = [1, 2, 3] will bind 1 to x, [2, 3] to xs, and the whole list to l
17:00:49 <M-Magnap> ^
17:00:50 <arcetera> OH
17:00:51 <arcetera> okay
17:00:53 <hpc> by the time you care what it does, you'll be asking "is there something that does X" and someone will say "@" and you'll go "oh, neat"
17:00:54 <arcetera> i thought so
17:01:19 <hpc> but yeah, it does that for pattern matches
17:01:22 <fishythefish> Of course, the list is just an example - this'll work in a general pattern match
17:01:36 <EvanR> @ is called an "as" pattern
17:01:39 <maerwald> arcetera: it doesn't work because of precedence
17:01:55 <hpc> and in ghc8 you can do fmap@[] or (+)@Int and it'll apply those types to the forall
17:01:59 <hpc> :t (+)@Int
17:02:00 <lambdabot> Pattern syntax in expression context: +@Int
17:02:05 <hpc> :t (+) @ Int
17:02:06 <lambdabot> Pattern syntax in expression context: +@Int
17:02:21 <hpc> is lambdabot using ghc8 yet?
17:02:31 <arcetera> i'm still on ghc7 because openbsd hasn't updated it yet
17:02:34 <hpc> anyway, that should say (+) :: Int -> Int -> Int, or something along those lines
17:02:35 <maerwald> arcetera: it helps when you apply the definition of (.) to your term and look what comes out
17:03:12 <M-Magnap> hpc: that's exactly what I was thinking of, thanks!
17:03:21 <M-Magnap> what's it called?
17:03:26 <hpc> M-Magnap: oh, i didn't even see your question
17:03:35 <hpc> i don't know what it's called, just seen it discussed here
17:04:02 <hpc> from what i understand it's far from the coolest thing about ghc8 too
17:04:31 <hpc> ill be updating when the world forces me to, or if i get a linux box that has more than a gig of ram
17:05:09 <M-Magnap> Visible Type Application!
17:05:12 <jig123> I would like to use Data.Set for part of my program, but I'm running into issues using lenses to manipulate them since they aren't Traversable and such (I am somewhat new to lenses, but everything else has worked great).
17:05:30 <jig123> is there no way to get a traversal for the elements in the set?
17:05:50 <hpc> it's not possible, Set isn't Applicative
17:06:07 <jig123> what do people do when they need something with a set?
17:07:01 <hpc> they use the stuff defined in that module, and/or Foldable
17:07:10 <c_wraith> Squarism: I wrote a comment that showed a couple tiny things that can be done with lens to examine the game tree.
17:07:16 <c_wraith> Squarism: same link
17:07:34 <jig123> ah, so just not using a lens
17:07:36 <pikajude> ok, might as well stop beating around the bush
17:07:45 <pikajude> i'm trying to port a node library that uses crypto.verify
17:07:49 <pikajude> and I don't have any idea how it actually works
17:08:03 <maerwald> that's a good prerequisite for doing crypto work
17:08:12 <zipper> hmm I keep running stack build from in a project and it keeps assuming that I'm running it from outside a project.
17:08:20 <zipper> Has anyone experienced this?
17:08:35 <fishythefish> zipper: have you initialized that directory as a stack project?
17:08:53 <zipper> fishythefish: What do you mean by that?
17:08:56 <zipper> stack init?
17:09:40 <Squarism> c_wraith, thanks man.. got into the zone here
17:09:53 <fishythefish> zipper: e.g. stack new
17:09:58 <sm> zipper: yes, which should create a stack.yaml file in the project
17:09:59 <fishythefish> or are you just running it in a dir of haskell code?
17:10:31 <zipper> Just running it from a dir of haskell code after deleting the .stack-work
17:10:40 <zipper> It has a stack.yml file
17:10:54 <sm> should be stack.yaml
17:11:31 <zipper> sm: The naming is such a big deal? Ok the stack.yaml is also a symlink from stack-8.0.yml
17:12:22 <sm> until it's working, I'd assume it's a big deal yes
17:12:38 <arcetera> huh
17:13:09 <arcetera> ghc-mod is complaining about my usage things like `foldr (+) 0` "why not use sum" when it's a function
17:13:13 <arcetera> where i reimplemented sum...
17:13:18 <arcetera> suffering
17:13:33 <fishythefish> zipper: try re-init'ing the directory? I don't know the internals of stack, but maybe it needs .stack-work
17:13:43 <shirt> is there something like a type hole, but for a type? Maybe _
17:13:58 <sm> arcetera: ghc-mod, or hlint ?
17:14:10 <hpc> arcetera: every linting tool i have seen, if it was a person i would want to punch it in the face ;)
17:14:19 <sm> hlint is fully customizable
17:14:23 <Koterpillar> hpc: that is by design
17:14:25 <hpc> regardless of language
17:14:27 <fishythefish> shirt: in what context? Would a type variable work?
17:15:08 <geekosaur> shirt, I would expect that to work, tbh
17:15:11 <shirt> fishythefish, like: data Foo = Foo (Maybe _)
17:15:17 <geekosaur> a type hole is a type variable with extra behavior
17:15:33 <fishythefish> geekosaur: that parses?
17:15:34 <geekosaur> although hm, might not work in data
17:15:39 <Koterpillar> shirt: and what do you expect to get from that?
17:15:52 <arcetera> sm: hlint was a dependency for ghc-mod
17:15:59 <geekosaur> actually I don't think that can sanely be done, since it needs to know the type there
17:16:00 <arcetera> and i have syntastic installed
17:16:03 <arcetera> so it might be using hlint
17:16:18 <geekosaur> or know that it's a variable (by it being a type parameter) or that it's existential (forall)
17:16:20 <sm> that kind of message sounds like hlint, and as I say you can configure it
17:16:29 <shirt> Koterpillar: not quite sure... but this works:  foo :: Maybe _
17:16:47 <pikajude> here we go http://lpaste.net/4703937977460457472
17:16:49 <Koterpillar> shirt: and says "a type hole found"?
17:16:50 <pikajude> not sure where the issue is
17:17:01 <c_wraith> there is _ at the type level, but it means the same thing as _ in a pattern, not in a type hole. 
17:17:13 <pikajude> i'll add the node stuff to the paste actually
17:17:36 <c_wraith> it means "unify with whatever". but it still needs to be able to figure it out from context
17:17:51 <shirt> Koterpillar: yeah
17:17:58 <pikajude> http://lpaste.net/4703937977460457472
17:18:10 <shirt> Koterpillar: but i get a worse error when trying to use in data
17:18:10 <pikajude> so i don't know where i'm going wtrong
17:18:12 <pikajude> wrong
17:18:16 <nshepperd> jig123 hpc: eh? should be possible to get a traversal over elements of a set
17:18:41 <zipper> The yml instead of yaml broke it :(
17:18:44 <zipper> Thanks
17:18:54 <hpc> nshepperd: https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Traversable
17:19:03 <hpc> nshepperd: depends on Functor, which you can't write for Set
17:19:11 * fishythefish wonders what's with the sync'd timeouts
17:19:44 <nshepperd> hpc: a travesal, not Traversable
17:19:51 <hpc> Set has invariants about the ordering of elements within it, which are used for performance (which is convenient) and deduping (which is necessary for Set's semantics)
17:20:29 <hpc> as in a lens Traversal?
17:20:30 <nshepperd> (\f -> fmap Set.fromList . traverse f . Set.toList) :: (Ord b) => Traversal (Set a) (Set b) a b
17:20:49 <nshepperd> yeah
17:21:29 <hpc> argh, you're right
17:21:37 <c_wraith> maybe it is
17:21:55 <hpc> i blame it on the original question not specifying a package or module, and the two having the same name
17:21:59 <shirt> Koterpillar, geekosaur: When I use -fdefer-type-errors, then  "foo :: Maybe _"  compiles but  "data Foo = Foo (Maybe _)" does not
17:22:18 <geekosaur> [10 00:15] <geekosaur> actually I don't think that can sanely be done, since it needs to know the type there
17:22:38 <geekosaur> a data declaration is not the same thing as a type signature, nor as a pattern
17:22:42 <shirt> geekosaur: thanks. so it can't be done?
17:22:46 <geekosaur> type holes make no sense there
17:23:11 * hackagebot http-api-data 0.2.3 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.2.3 (NickolayKudasov)
17:23:13 <geekosaur> either you pass in a type in a type variable, or you specify one. what would a type hole mean? do inference in a situation where inference is never done otherwise?
17:24:18 <geekosaur> or perhaps some kind of action at a distance where it tells you the type it made at any given site? (that could get noisy...)
17:25:10 <shirt> if i later do something like "Foo (Just 3)" then it can infer the type
17:25:41 <geekosaur> presuming it was: data Foo a =
17:25:56 <geekosaur> so you want data Foo _ = Foo (Maybe _) ?
17:26:07 <geekosaur> note the _ *before* the =, where the type variable would go
17:26:45 <shirt> i was thinking without any type variables.. but i guess i can understand how this can get messy
17:26:56 <geekosaur> note also that data Foo = Foo a -- does not do what you want
17:27:41 <geekosaur> do you understand why that is relevant?
17:28:00 <geekosaur> data Foo = Foo (Maybe a) -- error: Not in scope: type variable `a'
17:28:16 <geekosaur> data Foo a = Foo (Maybe a) -- valid
17:29:02 <geekosaur> so you want the latter but with a type hole message whenever a value of that type is created? as I said, could get noisy; also has some action at a distance issues
17:29:34 <shirt> yeah, that i understand. i am just going through a tutorial about partial type signatures, and trying to think about what if the writer is interested in introducing a new data type, but isn't sure yet about the concrete type
17:29:41 <geekosaur> (you export that. something in a module, possibly built against your module months or years later, uses it. do all uses in that module warn of type holes?)
17:29:59 <geekosaur> it still has to be a type variable in that case
17:30:17 <geekosaur> and the variable removed to make the concrete type if you indeed decided to do that, but that seems weird to me
17:31:41 <geekosaur> and with the type variable, you'd pretty much have to use not bare _ but the _foo syntax so you can refer to the name
17:32:31 <geekosaur> (any type var starting with _ is a type hole; _ is a trivial case usable only when you don't need to refer to it. but a data would almost always refer to it, barring phantom types)
17:36:17 <shirt> thanks, i understand a little, but this stuff might be too advanced for me
17:48:11 * hackagebot distributed-process 0.6.4 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.4 (FacundoDominguez)
18:12:18 <Squarism> are : type XYZ = OtherType just an alias or does it mean something more?
18:13:15 <EvanR> just an alias. are you following some haskell guide?
18:15:54 <divVerent> Squarism: almost; higher kind type constructors work too in there
18:16:05 <divVerent> e.g. type MonadCrap = IO will allow you to define main :: MonadCrap ()
18:16:20 <divVerent> but that's now really all there is to "type"
18:17:17 <lukke100> I believe you could also do some type name obfuscation in case you'd like to export a different type, but yeah, there really isn't much to `type`
18:17:52 <divVerent> can even do simple type mappings like "type Pair i = (i, i)"
18:18:38 <divVerent> but no pattern matching like "type One (a, a) = a" ;)
18:19:02 <EvanR> lol... non linear type level patterns
18:19:19 <divVerent> (if you need stuff like that, TypeFamilies will help you)
18:19:22 <EvanR> today i learned elixir has non linear patterns
18:19:34 <EvanR> giving haskell a run for its money
18:21:21 <Squarism> divVerent, ok thanks
18:23:47 <lukke100> Out of curiosity, does anyone know of any painfully Haskell98-compliant compilers/interpreters? Spec-compliance is something I generally try to aim for with code.
18:24:13 <EvanR> thats probably not a good idea with haskell
18:24:22 <EvanR> GHC-compliance is better
18:25:19 <EvanR> but there is NHC
18:25:35 <lukke100> As much as I like that, what "GHC-compliance" means grows and grows each year. It's a good thing, but having a *single* compiler seems rough to me. :/
18:25:44 <simpson> lukke100: Why Haskell 98 instead of Haskell 2010?
18:26:51 <EvanR> choosing a standard out of nowhere, then wishing for many different implementations of it seems backwards
18:26:53 <lukke100> simpson: Simply because it's the older one. I understand that 2010 isn't backwards compatible, but a lot of the older existing interpreters were 98.
18:27:16 <simpson> lukke100: Do you have a Haskell 98 codebase to maintain? I don't understand the desire to use an outdated standard.
18:27:16 <arcetera> should i learn lambda calculus
18:27:25 <simpson> arcetera: If you like. It's not especially hard.
18:27:35 <arcetera> should i learn it to understand haskell well
18:27:52 <arcetera> more importantly
18:27:57 <EvanR> for haskell you should go with typed lambda calculus
18:28:03 <arcetera> why am i learning the entirety of haskell just so i can write an xmonad config
18:28:22 <EvanR> xmonad has no config, its haskell code
18:28:32 <lukke100> simpson: No, but I've but a lot of thought into creating a small interpreter for Haskell.
18:28:33 <simpson> arcetera: No, lambda calculus is not a requirement for understanding Haskell.
18:28:37 <arcetera> i hate this
18:28:39 <simpson> lukke100: Fun! Go for it.
18:29:19 <lukke100> simpson: Thanks! The thing is, I'd want to aim for something that could be called a "reference" implementation, you know?
18:29:43 <lukke100> simpson: Starting with 98 seemed like the right way to do it, simply because it's been around longer.
18:29:47 <simpson> lukke100: That's a bold task.
18:30:03 <simpson> lukke100: Well, nobody writes Haskell 98. People are either coding to Haskell 2010 or to GHC.
18:30:11 <lukke100> simpson: I've read *a lot* about the task.
18:30:15 <lukke100> simpson: That's true.
18:31:29 <EvanR> its important to be realistic about standards
18:31:34 <lukke100> simpson: Alright, you've convinced, I'll stick with 2010.
18:31:50 <lukke100> *convinced me
18:32:06 <simpson> Yay! Now you just have to hack for a couple years.
18:32:39 <lukke100> I've got plenty of time on my hands. :D I don't think it should be /that/ difficult.
18:32:40 <EvanR> at least youre not trying to write a c++ compiler
18:32:48 <Enigmagic> famous last words
18:32:54 <lukke100> Yeah, I wouldn't dare to touch c++. Lol
18:33:01 <lukke100> Enigmagic, you may have a point.
18:33:10 <shirt> purescript is very close to haskell 98 and was written by one man, right? did it take him several years?
18:33:24 <lukke100> Honestly, though, the main thing I'm worried about is garbage collection.
18:33:34 <simpson> lukke100: Crib GHC's.
18:33:44 <EvanR> GC is probably the easiest part
18:33:58 <simpson> ...Actually, now that I think about it, maybe you just want to give GHC a Haskell 2010 mode?
18:34:07 <lukke100> simpson, but that means writing my interpreter in C. D:
18:34:16 <EvanR> what no
18:34:25 <simpson> lukke100: Well, what language were you going to write it in?
18:34:28 <lukke100> simpson: I think it *sorta* has one?
18:34:46 <EvanR> never implement programming languages in C
18:34:49 <lukke100> simpson: But it's sorta vague on what "compliant" means. I'd like something a bit stricter.
18:35:20 <lukke100> simpson: So, I know a few languages, including C, but I wouldn't dare that. That *would* take me years.
18:35:49 <lukke100> Honestly, as crazy as this sounds, Python doesn't seem bad, except the performance would be god awful.
18:35:52 <simpson> lukke100: You're right that C is an untenable implementation language.
18:36:03 <simpson> lukke100: Oh. Use RPython. You get a free JIT.
18:36:17 <simpson> It's taken me ~2yrs to produce a reference implementation of a language using RPython.
18:36:32 <lukke100> simpson: Which language?
18:36:41 <simpson> lukke100: RPython.
18:36:48 <simpson> http://rpython.readthedocs.io/en/latest/
18:37:08 <lukke100> Ah! I see.
18:37:14 <simpson> lukke100: Oh! Which language did I implement? Monte. https://monte.readthedocs.io/en/latest/
18:37:57 <Axman6> lukke100: why are you worried about garbage collection? there are very few programs where GC pauses have any effect at all (once you're proficient in writing not awful code, which you do a lot of early on)
18:39:39 <lukke100> Axman6, honestly, I have a lot of apprehension towards rolling my own custom GC. It seems like the sort of thing that's really easy to get wrong.
18:39:57 <lukke100> simpson: I'm reading through this and it seems like a really neat project.
18:40:27 <EvanR> why even bother with GC if youre writing an interpreter
18:40:38 <Axman6> oh, I thought you were worried about using Haskell, because it had GC =)
18:40:38 <EvanR> in something besides C
18:41:01 <lukke100> Axman6, oh no. :D
18:41:40 <lukke100> EvanR, well, my next pick would be something like Rust, but that too doesn't have GC, but, with the nature of interpreting a language, would effectively require me to write one.
18:42:11 <lukke100> Java is a good pick, but the idea of cold JVM startups really turns me off.
18:42:45 <EvanR> the nature of interpreting a language requires reimplementing the gc?
18:43:31 <lukke100> In Rust, which lacks GC, and instead has an elegant borrow checking system, I would say so, yes.
18:43:39 <simpson> Absorb or reify. *Something* has to have the GC somewhere.
18:43:44 <EvanR> your best bet with reference implementation level success is probably haskell
18:43:57 <simpson> The good news is that, by the time you get down to where Rust is, the GC has become a simple library.
18:44:33 <lukke100> simpson: Is there a GC library for Rust?
18:44:45 <EvanR> choosing not haskell for this, i can only imagine because you want even more challenge
18:47:48 <lukke100> EvanR, my only concern with doing that is Haskell's occasional tendency for awkward performance. Implementing Haskell with Haskell gives me a strange feeling. :/
18:48:19 <EvanR> so youre going for a production grade implementation
18:48:26 <lukke100> While I don't care too much about how fast code, I think I'd still want it to be predictable and simple, and Haskell within Haskell seems to be a hard way to implement that.
18:49:26 <arcetera> suffering
18:49:46 <arcetera> almost none of this has made sense so far. i would try a better tutorial if
18:49:47 <arcetera> - i had money
18:49:49 <EvanR> succotash?
18:49:54 <arcetera> - i wasn't already so far into learn you a haskell
18:50:24 <EvanR> another one bites the dust to LYAH
18:50:27 <lukke100> EvanR, maybe? Even a large portion of the GHC is C. I'm not planning on having the next GHC, just something I can write small libraries in and know that they can be thoroughly relied on.
18:50:56 <Squarism> one thing i find cumbersome is testing list elements. Its allways about 1. find element. 2. check element. Would be nicer to say.. i want list to contain elements obaying these criterias
18:50:59 <lukke100> arcetera, is there anything in particular you're suffering with? I'd be willing to help.
18:51:03 <EvanR> your version of haskell is supposed to more predictable and simpler than GHC haskell?
18:51:04 <Squarism> ...in any language
18:51:16 <EvanR> while still following the spec
18:51:43 <arcetera> - folds are a pain, what on earth is `Maybe` and why is it special, i can look at the problems given by lyah but i can't actually figure out algos to solve my own problems
18:51:46 <arcetera> like
18:51:47 <EvanR> Squarism: filter?
18:51:50 <arcetera> i understand what the book is saying
18:51:54 <arcetera> i understand the examples fine
18:52:05 <arcetera> but i don't know how to actually make algos to solve my problems
18:52:14 <lukke100> EvanR, no no, definitely not. Simpler, probably, but just because it follows the spec to the word. But predictable, no. But building on any implementation of Haskell seems like a hard time for performance.
18:52:21 <arcetera> the only thing which ive actually managed to write a program for is euler #1
18:52:25 <codebje> arcetera, folds are central to a lot of functional programming, but they require an 'aha!' moment to understand; if you use the collectors stuff in Java 8 streams, you've used folds
18:52:55 <Squarism> EvanR, and assert no filtering is empty?
18:52:57 <arcetera> codebje: i've programmed in java (for a class), but never dealt with those
18:53:11 <EvanR> Squarism: huh, that seems backwards
18:53:14 <codebje> if you've ever dealt with the difference in SQL between NULL and an empty string, you've seen what Maybe is for: it adds Nothing (like NULL) to some other type
18:53:59 <Squarism> EvanR, oh.. you mean a combined filter that should cover all of list?
18:54:25 <EvanR> filter takes a Bool test and gives you a list with everything failing the test removed
18:54:26 <Squarism> just trying to understand what you mean
18:54:27 <codebje> sometimes for tricky folds I basically just write out the list reduction by hand: foldr f o [a,b,c] == a `f` (b `f` (c `f` o))
18:54:36 <EvanR> > filter even [1,2,4,5,7,8,9,10]
18:54:37 <lambdabot>  [2,4,8,10]
18:54:44 <EvanR> so you dont have to write that
18:55:39 <codebje> and that helps me understand what f should be (and of course lets you internalise the distinction between foldl and foldr)
18:56:00 <Squarism> filter (\x -> doElaborateTestingOnNestedValues ) listToTest @=? listToTest
18:56:29 <EvanR> filter f listToTest where
18:56:31 <Squarism> oh forgot the x param
18:56:32 <EvanR> f x = 
18:56:38 <arcetera> codebje: if foldr is that, what is foldl?
18:57:09 <codebje> :t foldr
18:57:11 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:57:11 <codebje> :t foldl
18:57:12 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:57:33 <codebje> the first argument flips, and the parentheses thus balance a different way
18:57:36 <EvanR> the order of arguments in the fold.... uhg
18:57:52 <codebje> foldl f [a,b,c] o == ((o `f` a) `f` b) `f` c
18:57:58 <arcetera> oh ok
18:58:57 <codebje> oh, and I get confused because I expect the initial value to shift past the list for foldr and it doesn't :-)  I think that's an ocaml thing
18:59:30 <EvanR> shift past?
18:59:34 <codebje> (as in I expect foldr :: (a -> b -> b) -> t a -> b -> b)
18:59:46 <codebje> so it's clear that the initial value is _after_ all the foldable values
19:00:10 <codebje> (though it's still evaluated earlier than all but the last)
19:00:29 <codebje> (_probably_ evaluated, depending on f, but now I'm getting too pedantic)
19:00:31 <EvanR> earlier than all but last
19:00:50 <EvanR> isnt that a no solution
19:01:00 <arcetera> oh boy did i implement euler 2 but insanely slow
19:01:03 <arcetera> o h b o y
19:01:20 <codebje> no, it would be evaluated last, I'm just slow
19:01:46 <EvanR> in ocaml wouldnt it get evaluated immediately
19:02:08 <arcetera> well
19:02:11 <arcetera> i implemented fibonacci
19:02:35 <codebje> in haskell it would be evaluated last, in ocaml it'd be evaluated before the fold is expande at all
19:02:50 <Squarism> what paste can i use while lpaste is down?
19:02:55 <arcetera> sprunge.us
19:02:59 <EvanR> in haskell it might not get evaluated
19:02:59 <codebje> but if I write down the expansion, in either language, it's _written_ last :-)
19:03:21 <arcetera> aaaa
19:03:22 <codebje> let's just assume for the sake of simplicity that `f` uses both arguments always
19:03:26 <codebje> anyway, away 
19:03:32 <EvanR> yeah writing the expansion seems incredibly confusing for an eager language
19:03:42 <EvanR> what would be the implication
19:04:39 <Squarism> EvanR, so was it like this you meant (hunit) : http://sprunge.us/RcdD
19:05:44 <EvanR> whats @=?
19:06:03 <Squarism> im using hunit.. its assert-equals
19:08:21 <Squarism> i figured hunit was what people were using
19:08:30 <Squarism> like the junit for haskell
19:08:43 <EvanR> heres a random way to reformat it
19:08:46 <EvanR> http://codepad.org/fE4T2bWs
19:09:20 <arcetera> okay well
19:09:31 <EvanR> i figure your f function would crash though
19:09:53 <EvanR> oops the last where is wrong
19:10:24 <Squarism> nice
19:10:40 <Squarism> yeah.. need a wildcard there
19:11:06 <arcetera> okay
19:11:20 <arcetera> i implemented euler project #2 in haskell, can someone critique my code and tell me how i could do things better?
19:11:33 <arcetera> http://sprunge.us/CbPd it's rather slow
19:11:52 <arcetera> ah wait i forgot to use `even`
19:14:13 <Axman6> arcetera: why use (map nfib [0 ..] !!) instead of calling nfib directly?
19:14:34 <Axman6> arcetera: if you're aiming to memoise the results of nfib, this won't help you
19:14:48 <arcetera> yes that's what i'm tryna do
19:15:36 <Axman6> the way this is written, (map nfib [0 ..] !!) is exactly the same as fib = nfib
19:16:16 <Axman6> what you want if you're trying to memoise something is a list that is never garbage collected. the easiest way to do that is have somerthing at the top level of your program
19:17:46 <Axman6> firstly, we can make nfib much faster, this version runs in O(fib(n)) time, there's a linear* version which starts at 0 and counts up: fib n = fib' n 0 1 where fib' 0 x _ = x; fib' n x y = fib' (n-1) y (x+y)
19:18:14 <Axman6> just using that will immediately make your program much faster
19:18:23 * Axman6 needs to go to lunch
19:19:00 <arcetera> but why does that work
19:19:09 <arcetera> i don't understand haskell very well and it's all so confusing :<
19:21:21 <peddie> arcetera: it defines the sequence by a recursion, but it saves the previous two values in the sequence by passing them as arguments, so it doesn't need to recalculate or memoize anything
19:27:46 <Squarism> hunit looks like its some kind of monad. I wonder if i could map a list of items fmap to assertions and then bind each assertion to that monad?
19:28:26 <Squarism>  I wonder if i could fmap a list to assertions and then bind each assertion to that monad?
19:28:36 <Squarism> (read before you send)
19:29:42 <Squarism> or,.. how would i call putStrLn with a list of strings, one call for each string 
19:35:01 <arcetera> honestly
19:35:09 <arcetera> i'm beginning to think that this isn't worth it
19:35:48 <simpson> arcetera: It'll be okay. Programming isn't easy, after all; it's an unnatural act.
19:36:17 <arcetera> but like
19:36:29 <arcetera> ive spent all this time doing this so i can use xmonad well
19:36:45 <arcetera> is it worth it just so i can use xmonad?
19:37:02 <arcetera> learning a programming language to configure a wm?
19:37:58 <peddie> arcetera: why don't you just see how it goes and post any questions you have while configuring the wm to #xmonad?  I used xmonad for a few years before I learned any haskell
19:38:22 <arcetera> because i am extremely uncomfortable typing things i don't understand
19:38:27 <simpson> arcetera: I had to learn a bit of Lua when I started using Awesome.
19:38:54 <simpson> arcetera: And now I know enough Lua to hate it, which is really all that matters when learning a language without having to use it seriously.
19:39:06 <simpson> arcetera: You can do the same thing with Haskell.
19:39:31 <arcetera> well i mean
19:39:35 <arcetera> how do i learn it _right_?
19:39:44 <arcetera> because lyah is just confusing me and i'm not sure if that's okay
19:40:31 <simpson> Then read something else. Real World Haskell is still good.
19:40:39 <arcetera> well i mean
19:40:54 <arcetera> i'm not sure if it's the fault of lyah or the fault of me being a fucking idiot or haskell being confusing
19:41:05 <simpson> But yes, the first few times that you learn a new language, it's going to be rough; you're still developing higher-order ideas about computation.
19:41:26 <simpson> It's nobody's *fault*. It's just something that happens.
19:41:31 <ggVGc> simpson: why do you hate lua?
19:41:38 <Squarism> arcetera, my best bet would be to take on bigger and bigger projects, starting from small. I myself have chance learning a language wo using it directly
19:41:38 <ggVGc> what other language fills the niche of it?
19:41:47 <ggVGc> and what actual language flaws does lua have?
19:41:57 <ggVGc> I thknk it's essentially the perfect dynamic language currently
19:41:58 <Squarism> have no chance.. even
19:42:10 <simpson> ggVGc: Arrays are one-indexed and looking up a non-existent index in an array returns nil.
19:43:20 <simpson> ggVGc: Anyway, how can you say that you know a language well if you don't have something that you hate about it?
19:44:03 <ggVGc> yeah, that's fair
19:44:32 <ggVGc> simpson: the 1-indexing is just a peculiarity though, which you might disagree with, but it's not an outright design or implementation errors
19:44:37 <ggVGc> of which most other languages have plenty
19:44:55 <ggVGc> simpson: and the main thing about lua is that the VM is tiny, runs extremely fast, and runs anywhere ANSI C compiles
19:44:58 <ggVGc> which is amazing
19:45:05 <ggVGc> and has real tail optimization
19:45:13 <ggVGc> so you can actually write efficient recursive code in it
19:45:35 <simpson> ggVGc: I characterize languages not by what they do right, but what they do wrong. I recognize that this is not a popular view. We'll have to agree to disagree.
19:45:44 <ggVGc> and metatables are probably the only good implementation of prototypical inheritance I've seen, even though I kind of disagree with prototypes in general
19:45:54 <ggVGc> yeah, fair
19:45:59 <ggVGc> but I think lua does very very little wrong
19:46:30 <peddie> ggVGc: my impression has also been that Lua is basically as nice as dynamic scripting languages get, for the little it's worth :)
19:48:36 <glguy> Lua's pretty cool. I've been working on a debugger for it https://github.com/GaloisInc/galua
19:48:40 <ggVGc> peddie: for me it's worth a lot  because you can get rapid development with quick testing(by hotloading dynamic code) at speeds that are fast enough for almost anything you can think of
19:48:52 <ggVGc> I wish there was a functional language with those properties
19:48:54 <ggVGc> but there arent
19:49:13 <peddie> can't you hot-load erlang code?
19:49:13 <ggVGc> I started working on a small eDSL in haskell that will generate lua
19:49:16 <arcetera> fuck i feel like i know nothing
19:49:19 <ggVGc> to get the same development pipeline but with haskell
19:49:27 <arcetera> after trying for three days
19:49:33 <ggVGc> peddie: yeah, but can you run erlang code anywhere you can run ansi C?
19:49:36 <peddie> for me the nice part of lua was the very straightforward C interop
19:49:41 <peddie> ggVGc: of course not
19:49:47 <ggVGc> right, so then the point is moot
19:49:59 <glguy> http://imgur.com/mBTPUIu
19:50:02 <peddie> you can't run lua everywhere you can run ansi C either
19:50:04 <ggVGc> peddie: lua is something you can throw into almost any project, and have dynamic scripting at good speed within a day or so
19:50:09 <ggVGc> that's pretty nice
19:50:12 <ggVGc> yes you can
19:50:17 <ggVGc> where can lua not run?
19:50:26 <ggVGc> the VM compiles on anything
19:50:41 <peddie> microcontrolers . . . ?
19:50:49 <peddie> DSPs?
19:51:00 <ggVGc> why can't you run lua there?
19:51:01 <glguy> Cheeseburgers?
19:51:08 <glguy> In any case, Lua is off-topic in #haskell
19:51:12 <ggVGc> yeah, sorry
19:51:15 <peddie> sorry, fair enough
19:51:39 <ggVGc> on a related not though, I would like someone to make this haskell eDSL for me, so I can generate lua from it
19:51:49 <ggVGc> it's gonna take me a long time to get it right
19:52:11 <ggVGc> this is all I got, https://github.com/ggVGc/Tua
19:58:03 <Squarism> ill never understand dynamic languages. 5 lines and i start miss types
19:58:16 * hackagebot stratux-types 0.0.6 - A library for reading JSON output from stratux  https://hackage.haskell.org/package/stratux-types-0.0.6 (TonyMorris)
20:08:16 * hackagebot stratux-http 0.0.6 - A library for using HTTP with stratux  https://hackage.haskell.org/package/stratux-http-0.0.6 (TonyMorris)
20:08:18 * hackagebot stratux 0.0.6 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.6 (TonyMorris)
20:11:00 <jasonkuhrt> Hi, in the applicative instance for functions can someone explain clearly why the definition for <*> cannot be: `(<*>) f g x z = f x (g z)`?
20:12:46 <shachaf> Why not?
20:13:28 <mauke> type mismatch
20:13:33 <dfeuer> @pl \a' b' -> Two (Elem a') (Elem b')
20:13:34 <lambdabot> (. Elem) . Two . Elem
20:13:48 <mauke> Two `on` Elem
20:13:56 <shachaf> Oh, I misread.
20:14:24 <mauke> (<*>) :: f (a -> b) -> f a -> f b
20:14:50 <mauke> let f = (e ->), then (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
20:15:01 <mauke> that's three arguments, f, g, x
20:15:05 <mauke> there's no room for z
20:15:55 <dfeuer> mauke, that's an interesting point, but I'm slightly more interested in the fact that it's  (. Elem) #. Two .# Elem  I'm not sure that's worth the trouble though.
20:16:58 <Squarism> How would i call putStrLn with a list of strings, one call for each string ?
20:17:14 <c_wraith> :t mapM_ putStrLn
20:17:15 <lambdabot> Foldable t => t String -> IO ()
20:18:20 <Squarism> well what im really after.. how to interact with a monad with a list of operations
20:19:34 <c_wraith> mapM and mapM_ are the operations you're looking for
20:19:47 <c_wraith> mapM_ discards the results, mapM collects them into a list
20:20:04 <Squarism> ok!
20:21:55 <mauke> :t putStr . unlines
20:21:56 <lambdabot> [String] -> IO ()
20:22:23 <jasonkuhrt> mauke: Thanks
20:23:39 <Axman6> arcetera: Did you get any more help on your project euler code?
20:24:26 <Squarism> c_wraith, worked out well!
20:29:40 <Squarism> EvanR, about that filter approach.. it doesnt assert all element filters run in case of a list of copies
20:38:18 * hackagebot lol 0.3.0.0 - A library for lattice cryptography.  https://hackage.haskell.org/package/lol-0.3.0.0 (crockeea)
20:40:02 <syntaxfree_> this is a semi-ill defined question, please don't hurt me.
20:40:21 <dfeuer> SWEET!
20:41:00 <syntaxfree_> I'm taking a basic course on algorithms and we did something of a step-by-step count of how many function calls were involved in the naive and tail-recursive fibonacci function. 
20:41:40 <geekosaur> this sounds like it will be very ill defined in Haskell
20:41:49 <pikajude> does anybody know how to create an RSA key for usage in HsOpenSSL's EVP verification function?
20:41:58 <syntaxfree_> and then I thought to myself - is it possible to have an actual iteration/function call with something like, uh, a logging monad in Haskell?
20:42:35 <syntaxfree_> something that's always being passed with the code and incremented passively. without me having to add an extra parameter to each and every function.
20:43:15 <dibblego> yes, but "the number of times a function is called" cannot be accurately determined without predicting compiler behaviour.
20:43:18 * hackagebot lol-apps 0.1.0.0 - Lattice-based cryptographic applications using Lol.  https://hackage.haskell.org/package/lol-apps-0.1.0.0 (crockeea)
20:43:24 <geekosaur> graph reduction doesn't quite work like that, anyway
20:43:39 <pikajude> actually, it doesn't look like I can create an RSA key
20:43:45 <pikajude> i'd have to generate one, there's no reading available
20:43:47 <geekosaur> I could imagine a mutant Writer where >>= had a tell built into it
20:44:23 <geekosaur> but I suspect Monad is barking up the wrong tree here
20:44:31 <syntaxfree_> maybe. 
20:44:31 <pikajude> so HsOpenSSL is sadly useless also
20:44:38 <pikajude> is there any way to do EVP verification in Haskell?
20:44:44 <syntaxfree_> I have my answer. Thanks, kind internet chatters.
20:58:58 <slack1256> I carved my tomb myself. 
20:59:13 <slack1256> I am colaborating with a non-programming on a website. We will use hakyll
20:59:45 <slack1256> but he uses windows, doesn't know the cmd and launching a hakyll preview requires that (plus installing ghc/stack)
20:59:48 <slack1256> any ideas?
21:00:14 <Koterpillar> make them batch files
21:01:55 <slack1256> yep, I still need a windows machine where to test that. But that's viable
21:02:04 <slack1256> I will get with it now...
21:02:26 <Koterpillar> or, make them a vagrant/virtualbox/etc. image
21:04:06 <athan> slack1256: Pretty sure there are free 32bit windows virtual boxes, something for IE compatability or something
21:04:29 <dfeuer> I just realized I can make the Traversable instance for Data.Sequence.Seq do a lot less fmapping :-)
21:04:56 <Koterpillar> athan: slack1256: you mean http://modern.ie/
21:06:01 <dfeuer> I just need to Data.Coerce.coerce the whole bleedin' thing on the way in and on the way out, with just a little source code duplication required on the way out to keep the coercions legal.
21:07:03 <Squarism> say you have a list (set) of value's of type and you wanna test that the list contains 4 elements each obaying verifications of 5 different criterias. What would be a nice way to do that?
21:07:17 <slack1256> vagrant/virtualbox/etc sounds cool but he being non-technical makes it hard
21:07:28 <Squarism> values of same type but maybe different constructors
21:07:31 <dfeuer> Squarism, you have a what? And you want what? Can you give an example?
21:07:36 <slack1256> I will probably go with the batch files (and testing it works on a local virt machine)
21:07:52 <Koterpillar> slack1256: maybe Hakyll isn't the right tool at all?
21:07:55 <Squarism> dfaur, ill arrange.. ona momenta
21:08:07 <Koterpillar> slack1256: have them send you the content
21:08:16 <dfeuer> Squarism, you should be a little more careful about how you type other people's names.
21:08:18 <Koterpillar> slack1256: or build a non-static website
21:09:08 <Squarism> dfeuer, oh.. well.. here is an example http://sprunge.us/RcdD
21:09:28 <dfeuer> Why the heck does GHC take apart the Applicative dictionary to send <*> and pure to a worker function, but not also pull fmap out of the enclosed Functor dictionary at the same time?
21:10:14 <Squarism> dfeuer, its flawed.. if the 2 elements in deps were copies, my verifican should not go through which it could do now
21:10:22 <dfeuer> Wat?
21:11:03 <Squarism> dfeuer, the example is flawed
21:11:18 <dfeuer> Squarism, that code fragment is utterly incomprehensible, there's no context, I don't understand what you mean about duplicates, etc.
21:11:18 <Squarism> ..that i pasted 5 rows up
21:11:35 <slack1256> Koterpillar: probably, But I like that hakyll works on pandoc(-esque) files and can check that they compile or don't
21:12:00 <dfeuer> Try to write out a coherent question, with context, with enough code to make some sort of sense, in complete sentences, with correct spelling and grammar, and paste *that* somewhere.
21:12:24 <Squarism> oh.. sorry. In essence i wanna check that "deps" contain 2 elements, each having different criterias. 
21:12:33 <Squarism> ..its a hunit test btw
21:12:48 <Squarism> @=? are assertions
21:12:48 <lambdabot>  are assertions
21:13:46 <Squarism> this is something ive hade troubles with in many languages over the years, so i hoped someone had a good solution
21:14:07 <Squarism> haskell should have the tools for it i guess
21:14:26 <Koterpillar> Squarism: so you want to check that the list has exactly 2 elements, each satisfying a predicate?
21:14:29 <dfeuer> Squarism, Haskell's got great testing tools.
21:14:40 <Squarism> Koterpillar, exactly
21:14:57 <dfeuer> But you haven't written out a proper explanation of what you're trying to do, what you actually have so far, etc. I know you *think* you've explained it, but you're wrong.
21:15:09 <Squarism> Koterpillar, and that each predicate is only checked once
21:15:15 <slack1256> modern.ie is great!
21:15:29 <Squarism> Koterpillar, or matched to a certain element
21:15:35 <Koterpillar> Squarism: ok, one predicate or two predicates?
21:16:04 <Squarism> Koterpillar, as many predicates as list elements
21:16:33 <Koterpillar> that is, two?
21:16:42 <ggVGc> why can't I do this? i.e have a Lens pointing to a Lens? https://gist.github.com/0f173be1ece10442fd478194d44ac11b
21:16:43 <Squarism> in this case yes
21:17:04 <Koterpillar> for example, "I want to check that my list of numbers contains 2 elements. Exactly one must be even, and exactly one must be positive."
21:17:08 <Koterpillar> Squarism: does that sound close?
21:17:27 <Squarism> yep
21:17:43 <Koterpillar> Squarism: http://sprunge.us/HCCc
21:18:19 * hackagebot stratux-types 0.0.7 - A library for reading JSON output from stratux  https://hackage.haskell.org/package/stratux-types-0.0.7 (TonyMorris)
21:19:06 <dfeuer> ggVGc, that sounds like it's probably an issue with the rank-2 type. What error message do you get?
21:19:09 <Squarism> Koterpillar, well thats the best ive seen.. ill go with that. thanks
21:20:09 <Koterpillar> Squarism: np, I just translated my last sentence :)
21:21:14 <Koterpillar> "I want a list to have 2 elements. I want exactly 1 element to satisfy X. I want exactly 1 element to satisfy WHY."
21:21:22 <dfeuer> ggVGc, the lens to the lens will have type  Functor f => (Lens' ControllerState (Int, Int) -> f (Lens' ControllerState (Int, Int))) -> ..... That's a problem, because it's impredicative.
21:22:19 <Koterpillar> What does "impredicative" mean? I've played a bit with forall, and gave up because GHC either told me about impredicative types or refused to unify what I thought were perfectly fine terms.
21:23:04 <glguy> ggVGc: _offsetLens :: ReifiedLens' ControllerState (Int,Int)
21:23:18 <glguy> You can wrap that up in a newtype
21:23:27 <dfeuer> ggVGc, you should be able to work around it by using ALens' or ReifiedLens' instead of Lens'.
21:23:37 <dfeuer> Yeah, glguy said it faster.
21:23:50 <ggVGc> ah yeah, ImpredicativeTypes is the error I got
21:23:55 <ggVGc> but I have no idea what that means
21:24:03 <ggVGc> dfeuer: alright, will look into that
21:24:06 <ggVGc> never heard of these types
21:24:07 <ggVGc> thanks
21:24:29 <dfeuer> ggVGc, the big problem is that you're applying f to a foralled type. That's no good.
21:24:47 <dfeuer> Haskell can't do that.
21:24:57 <ggVGc> alright
21:25:03 <ggVGc> I tink I don't understand what I'm trying to do really
21:25:08 <dfeuer> [yet, anyway, and whether it should is subject to some considerable debate]
21:25:09 <ggVGc> because of lacking Lens knowledge
21:25:16 <dfeuer> Lens is tricksy.
21:25:22 <ggVGc> but it seemed reasonable to me to be able to have a lens pointing to a lens
21:25:24 <ggVGc> but I guess not
21:25:28 <dfeuer> Well, you *can*.
21:25:55 <dfeuer> A ReifiedLens' *is* a lens; it's just wrapped up with newtype to satisfy the type checker.
21:29:59 <ggVGc> hm, how do I use the reified lens?
21:30:39 <ggVGc> oh
21:30:40 <ggVGc> runLens eh
21:31:01 <ggVGc> hm, not sure this is worth the hassle in this case
21:43:20 * hackagebot stratux-http 0.0.7 - A library for using HTTP with stratux  https://hackage.haskell.org/package/stratux-http-0.0.7 (TonyMorris)
21:43:22 * hackagebot stratux-websockets 0.0.7 - A library for using websockets with stratux  https://hackage.haskell.org/package/stratux-websockets-0.0.7 (TonyMorris)
21:43:24 * hackagebot stratux 0.0.7 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.7 (TonyMorris)
21:45:24 <dfeuer> Wow, that was silly.
21:45:38 <dfeuer> SNAKES! ON A PLANE!
21:45:45 * dfeuer mutters.
21:45:54 <dfeuer> Sorry for the noise.
21:51:43 <jle`> mniip: sup?
21:52:33 <jle`> Koterpillar: ImpredicativeTypes is when you want to use a rank-n type 'inside' a data constructor, like Maybe (forall a. a) or [forall a. Show a => a -> r]
21:53:06 <jle`> you have to wrap them inside a newtype or data wrapper
21:53:17 <jle`> so they don't sow up naked like that
21:54:23 <Koterpillar> jle`: makes sense, thanks! I ended up scraping all the forall stuff though
21:55:22 <dfeuer> Look, ma! Less fmap! https://github.com/haskell/containers/pull/284/files
21:56:38 <Squarism> Koterpillar, hmm.. your solution there about list matching would require a corresponding "False" implementation of each predicate right?
21:57:36 <Koterpillar> Squarism: the predicates have to be total, yes
21:58:02 <Koterpillar> Squarism: "f 0 = True" is not a very good function to test whether numbers are equal to 0
21:58:30 <Koterpillar> Squarism: f 0 = True; f _ = False is what you want
21:58:49 <Squarism> Koterpillar, hehe true.. well it does get a bit clumsy in that case as a "general solution" to the problem
21:59:12 <Koterpillar> why? you just need "f _ = False" for both your lines
21:59:31 <Koterpillar> defining non-total functions is a bad idea anyway
22:03:26 <Squarism> just mean i wish it could be shorter to make test more expressive and less plumbing
22:04:16 <Squarism> shortest i can do http://sprunge.us/abbV
22:05:09 <Koterpillar> Squarism: you don't need brackets/parens around (e)
22:05:35 <Koterpillar> and I won't squash the two lines of f2 and f1 together
22:05:37 <pikajude> hey, does anybody know how I'd use cryptonite's RSA PKCS15 module to encrypt and then verify a string?
22:05:42 <Koterpillar> expressive != short
22:06:04 <Squarism> verbosity hides intent
22:06:36 <Koterpillar> actually
22:06:47 <Koterpillar> f2 x = x == (Deployment 3 (ArmyAtLoc Legio1 Rome) Pompeji)
22:06:58 <Koterpillar> that's assuming Deployment (?) has an Eq instance
22:07:05 <Squarism> it does!
22:07:22 <dfeuer> Koterpillar, you have redundant parentheses there.
22:07:25 <Squarism> nice!
22:07:33 <Koterpillar> dfeuer: true
22:14:09 <Squarism> http://sprunge.us/TMaV
22:14:30 <Koterpillar> Squarism: this is actually not immediately clear to me
22:15:11 <Koterpillar> I would remove 'v'
22:15:14 <Squarism> if you have 40 tests using same principle
22:15:26 <Koterpillar> oh
22:15:26 <Squarism> it could save parse power in brain
22:15:41 <Koterpillar> do Deployments have Ord?
22:15:57 <Squarism> no, not currently
22:17:56 <Koterpillar> make one, then: http://sprunge.us/RFTQ
22:18:21 * hackagebot amazonka-core 1.4.3 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.3 (BrendanHay)
22:18:23 * hackagebot amazonka 1.4.3 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.3 (BrendanHay)
22:18:25 * hackagebot amazonka-test 1.4.3 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.3 (BrendanHay)
22:18:27 * hackagebot amazonka-discovery 1.4.3 - Amazon Application Discovery Service SDK.  https://hackage.haskell.org/package/amazonka-discovery-1.4.3 (BrendanHay)
22:18:29 * hackagebot amazonka-marketplace-analytics 1.4.3 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.4.3 (BrendanHay)
22:19:03 <Squarism> Koterpillar, but true.. not clear the argument "deps" is part of verifications.. so i took that back
22:19:50 <Koterpillar> Squarism: you can define 'sameSet' in my last paste without Ord too; it will be quadratic but still workable
22:20:18 <Koterpillar> your solution is currently quadratic, too
22:20:38 <Squarism> that is beuitiful
22:21:09 <Squarism> but it wont handle wildcards "_" ? 
22:21:30 <Koterpillar> correct; if you have wildcards, you're back to predicates
22:23:17 <Koterpillar> can you post the actual code with 40 checks?
22:23:31 * hackagebot amazonka-route53-domains 1.4.3 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.4.3 (BrendanHay)
22:23:33 * hackagebot amazonka-directconnect 1.4.3 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.4.3 (BrendanHay)
22:23:35 * hackagebot amazonka-elasticsearch 1.4.3 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.3 (BrendanHay)
22:23:37 * hackagebot amazonka-devicefarm 1.4.3 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.4.3 (BrendanHay)
22:23:39 * hackagebot amazonka-ec2 1.4.3 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.3 (BrendanHay)
22:24:41 <Squarism> well i dont have it yet.. (only 5 tests with such req) but i assume ill land there. https://github.com/gurgl/julius-caesar/tree/master/src
22:25:10 <Koterpillar> paste 5
22:25:28 <Koterpillar> the less info we have about your tests, the more vague the advice will be
22:25:53 <Koterpillar> i.e. I had no idea you had 40 predicates, so didn't think that was a problem
22:26:07 <Koterpillar> and I didn't know all your predicates were partially applied (==)
22:27:40 <Squarism> ops, forgot to push
22:27:48 <Squarism> https://github.com/gurgl/julius-caesar/blob/master/src/Tests.hs
22:28:27 <Koterpillar> https://github.com/gurgl/julius-caesar/blob/master/src/Tests.hs#L94
22:28:33 <Koterpillar> I have no idea what this means
22:28:41 * hackagebot amazonka-s3 1.4.3 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.3 (BrendanHay)
22:28:43 * hackagebot amazonka-elb 1.4.3 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.4.3 (BrendanHay)
22:28:45 * hackagebot amazonka-cognito-sync 1.4.3 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.4.3 (BrendanHay)
22:28:47 * hackagebot amazonka-dms 1.4.3 - Amazon Database Migration Service SDK.  https://hackage.haskell.org/package/amazonka-dms-1.4.3 (BrendanHay)
22:28:49 * hackagebot amazonka-importexport 1.4.3 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.3 (BrendanHay)
22:28:52 <Koterpillar> I can guess: "at least one deployment should have a Caesar"
22:29:21 <Koterpillar> so you're shooting yourself in the foot with shortening names to "g1"
22:30:06 <Koterpillar> the key property of tests is: when they fail, they tell you something valuable
22:31:26 <Squarism> Koterpillar, true. But now the target audiance for the tests are me only. At work i wouldnt use these crytpic names
22:32:05 <Koterpillar> Squarism: you won't remember anything if you come back to these tests in a months
22:32:07 <Koterpillar> Squarism: you won't remember anything if you come back to these tests in a month
22:32:24 <Squarism> you are right about that! =D
22:32:48 <Squarism> ill take your advice and make them more readable tomorrow
22:33:30 <Koterpillar> also, if you have any invariants to check, do that. For example, there should be only one Caesar (IDK, maybe that's nonsense)
22:33:51 * hackagebot amazonka-certificatemanager 1.4.3 - Amazon Certificate Manager SDK.  https://hackage.haskell.org/package/amazonka-certificatemanager-1.4.3 (BrendanHay)
22:33:53 * hackagebot amazonka-kinesis 1.4.3 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.4.3 (BrendanHay)
22:33:55 * hackagebot amazonka-cloudsearch-domains 1.4.3 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.4.3 (BrendanHay)
22:33:57 * hackagebot amazonka-cloudwatch 1.4.3 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.4.3 (BrendanHay)
22:33:59 * hackagebot amazonka-cloudfront 1.4.3 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.4.3 (BrendanHay)
22:35:01 <Squarism> Koterpillar, its an implemenation of a boardgame. Caesar is "army ownership"
22:35:03 <Squarism> https://boardgamegeek.com/boardgame/37836/julius-caesar
22:35:39 <Koterpillar> oh, OK. Well, if you can find something that should be true all the time and gets wrong often, check that.
22:36:47 <Squarism> Koterpillar, im not such what you mean there? Some common pitfall that i should be aware of?
22:37:46 <Koterpillar> let's say you're doing chess; then both kings should be on the board somewhere, all the time
22:38:13 <Koterpillar> if you have bugs where kings disappear for any reason, it makes sense to always check that they are there after operations
22:38:19 <Koterpillar> possibly using QuickCheck
22:39:01 * hackagebot amazonka-elastictranscoder 1.4.3 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.4.3 (BrendanHay)
22:39:03 * hackagebot amazonka-sts 1.4.3 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.4.3 (BrendanHay)
22:39:05 * hackagebot amazonka-elasticache 1.4.3 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.4.3 (BrendanHay)
22:39:07 * hackagebot amazonka-cloudformation 1.4.3 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.4.3 (BrendanHay)
22:39:09 * hackagebot amazonka-ecs 1.4.3 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.4.3 (BrendanHay)
22:39:54 <Squarism> Koterpillar, you mean in test suites? a set of verifications that should be true allways?
22:40:02 <Koterpillar> yes
22:40:20 <Koterpillar> let's say you have a function :: Move -> Board -> Board
22:40:44 <Koterpillar> then for any Move and (valid) Board, the result of that move should be a valid (!) Board
22:40:46 <Squarism> Sure, that would be applicable to this domain
22:41:53 <dibblego> Move -> Board -> Either InvalidMove Board -- more likely
22:44:11 * hackagebot amazonka-marketplace-metering 1.4.3 - Amazon Marketplace Metering SDK.  https://hackage.haskell.org/package/amazonka-marketplace-metering-1.4.3 (BrendanHay)
22:44:13 * hackagebot amazonka-kinesis-firehose 1.4.3 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.4.3 (BrendanHay)
22:44:15 * hackagebot amazonka-sqs 1.4.3 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.4.3 (BrendanHay)
22:44:17 * hackagebot amazonka-swf 1.4.3 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.3 (BrendanHay)
22:44:19 * hackagebot amazonka-cloudwatch-events 1.4.3 - Amazon CloudWatch Events SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-events-1.4.3 (BrendanHay)
22:49:21 * hackagebot amazonka-sdb 1.4.3 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.3 (BrendanHay)
22:49:23 * hackagebot amazonka-workspaces 1.4.3 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.4.3 (BrendanHay)
22:49:25 * hackagebot amazonka-emr 1.4.3 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.4.3 (BrendanHay)
22:49:27 * hackagebot amazonka-codedeploy 1.4.3 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.4.3 (BrendanHay)
22:49:29 * hackagebot amazonka-cloudwatch-logs 1.4.3 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.4.3 (BrendanHay)
22:54:31 * hackagebot amazonka-codecommit 1.4.3 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.4.3 (BrendanHay)
22:54:33 * hackagebot amazonka-efs 1.4.3 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.4.3 (BrendanHay)
22:54:35 * hackagebot amazonka-gamelift 1.4.3 - Amazon GameLift SDK.  https://hackage.haskell.org/package/amazonka-gamelift-1.4.3 (BrendanHay)
22:54:37 * hackagebot amazonka-elasticbeanstalk 1.4.3 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.4.3 (BrendanHay)
22:54:39 * hackagebot amazonka-apigateway 1.4.3 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.4.3 (BrendanHay)
22:58:45 <simpson> Stupid question: Is there an ordered associative container that doesn't require Ord (but Eq is okay) for its keys?
22:59:08 <simpson> Actually, of course there is: Associative lists. Okay.
22:59:33 <simpson> Next question: Is there something along those lines that has a faster-than-linear membership test?
22:59:41 * hackagebot amazonka-datapipeline 1.4.3 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.4.3 (BrendanHay)
22:59:43 * hackagebot amazonka-support 1.4.3 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.4.3 (BrendanHay)
22:59:45 * hackagebot amazonka-iot-dataplane 1.4.3 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.4.3 (BrendanHay)
22:59:47 * hackagebot amazonka-sns 1.4.3 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.4.3 (BrendanHay)
22:59:49 * hackagebot amazonka-dynamodb-streams 1.4.3 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.4.3 (BrendanHay)
23:00:11 <peddie> simpson: is Hashable OK?
23:00:51 <pikajude> never mind, I figured it out. it turns out 1024 bits is a totally different thing from 128 bytes
23:01:11 <pikajude> wow, i am REALLY wrong today. that should have read: "it turns out 1024 bytes is a totally different thing from 128 bytes".
23:01:29 <simpson> peddie: Sure.
23:02:00 <simpson> peddie: Are you thinking of HAMTs? I was curious about other options, but HAMTs do check my checkboxes.
23:02:06 <peddie> I think Data.HashMap.HashMap has a Traversable instance in case you want to traverse it in (some) order . . . and membership test is a lot faster than linear
23:02:31 <peddie> yes, I am :)
23:04:51 * hackagebot amazonka-cloudtrail 1.4.3 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.4.3 (BrendanHay)
23:04:53 * hackagebot amazonka-opsworks 1.4.3 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.4.3 (BrendanHay)
23:04:55 * hackagebot amazonka-rds 1.4.3 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.4.3 (BrendanHay)
23:04:57 * hackagebot amazonka-cognito-identity 1.4.3 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.4.3 (BrendanHay)
23:04:59 * hackagebot amazonka-codepipeline 1.4.3 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.4.3 (BrendanHay)
23:05:58 <geekosaur> we been amazonked :p
23:10:01 * hackagebot amazonka-ssm 1.4.3 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.4.3 (BrendanHay)
23:10:03 * hackagebot amazonka-ml 1.4.3 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.4.3 (BrendanHay)
23:10:06 * hackagebot amazonka-ses 1.4.3 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.4.3 (BrendanHay)
23:10:08 * hackagebot amazonka-inspector 1.4.3 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.4.3 (BrendanHay)
23:10:10 * hackagebot amazonka-glacier 1.4.3 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.3 (BrendanHay)
23:11:08 <Axman6> Amazonka is so amazing, I'm really glad to see updated =)
23:11:12 <Axman6> updates*
23:15:12 * hackagebot amazonka-iot 1.4.3 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.4.3 (BrendanHay)
23:15:14 * hackagebot amazonka-ds 1.4.3 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.4.3 (BrendanHay)
23:15:16 * hackagebot amazonka-route53 1.4.3 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.4.3 (BrendanHay)
23:15:18 * hackagebot amazonka-cloudsearch 1.4.3 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.4.3 (BrendanHay)
23:15:20 * hackagebot amazonka-storagegateway 1.4.3 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.4.3 (BrendanHay)
23:17:50 <Hafydd> Welcome to amazonko.com.
23:20:22 * hackagebot amazonka-cognito-idp 1.4.3 - Amazon Cognito Identity Provider SDK.  https://hackage.haskell.org/package/amazonka-cognito-idp-1.4.3 (BrendanHay)
23:20:24 * hackagebot amazonka-kms 1.4.3 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.4.3 (BrendanHay)
23:20:26 * hackagebot amazonka-autoscaling 1.4.3 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.4.3 (BrendanHay)
23:20:28 * hackagebot amazonka-redshift 1.4.3 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.4.3 (BrendanHay)
23:20:30 * hackagebot amazonka-lambda 1.4.3 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.4.3 (BrendanHay)
23:22:38 * JuanDaugherty has no complaints, i pay $0.85 for my parked instance
23:25:32 * hackagebot amazonka-application-autoscaling 1.4.3 - Amazon Application Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-application-autoscaling-1.4.3 (BrendanHay)
23:25:34 * hackagebot amazonka-config 1.4.3 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.4.3 (BrendanHay)
23:25:36 * hackagebot amazonka-waf 1.4.3 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.4.3 (BrendanHay)
23:25:38 * hackagebot amazonka-ecr 1.4.3 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.3 (BrendanHay)
23:25:40 * hackagebot amazonka-cloudhsm 1.4.3 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.4.3 (BrendanHay)
23:30:42 * hackagebot amazonka-dynamodb 1.4.3 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.4.3 (BrendanHay)
23:30:44 * hackagebot amazonka-iam 1.4.3 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.4.3 (BrendanHay)
23:30:46 * hackagebot hylogen 0.1.4.0 - Purely functional GLSL embedded in Haskell  https://hackage.haskell.org/package/hylogen-0.1.4.0 (sleexyz)
23:30:48 * hackagebot hylogen 0.1.4.1 - Purely functional GLSL embedded in Haskell  https://hackage.haskell.org/package/hylogen-0.1.4.1 (sleexyz)
23:30:50 * hackagebot geoip2 0.2.0.1 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.2.0.1 (ondrap)
23:33:42 <Squarism> how do i write a pattern that matches first elemetn on list wo capture
23:33:58 <Squarism> (x:_) = myList
23:34:15 <Squarism> eh
23:34:26 <Squarism> (1:_)
23:34:32 <Squarism> (1:_) = myList
23:34:35 <Squarism> so to speka
23:34:37 <Squarism> speak
23:34:43 <Squarism> sorry for sloppyness
23:34:46 <Koterpillar> what things do you want it to match?
23:34:58 <Squarism> its those filters again
23:34:58 <Koterpillar> e.g. lists of 1+ elements?
23:35:04 <Squarism> yeah
23:35:09 <Koterpillar> (_:_) = myList
23:35:52 * hackagebot hylide 0.1.4.0 - Livecoding WebGL renderer for Hylogen  https://hackage.haskell.org/package/hylide-0.1.4.0 (sleexyz)
23:36:16 <Squarism> Koterpillar, but its in those filters again
23:36:50 <Squarism> seems i cannot write : filter (MyStuff (1:_) "a") myList
23:37:01 <Koterpillar> you can not
23:37:07 <Koterpillar> you have to write a function
23:37:26 <Squarism> grr
23:37:27 <Squarism> =D
23:37:50 <Koterpillar> well... filter (\a -> case a of { (_:_) -> True; _ -> False }) myList
23:37:55 <Koterpillar> but please don't do this
23:38:10 <geekosaur> pattern guards?
23:38:28 <Koterpillar> Squarism: stop fitting stuff into one line and give your functions names
23:40:02 <Squarism> i strongly believe in that verbosity is a problem. If you can express yourself clearly with whats at hand ill use it
23:40:18 <Squarism> problem is i dont know haskell well enough
23:40:29 <lyxia> you should read some perl
23:40:37 <lyxia> or J
23:41:36 <Koterpillar> Squarism: you _can_ do it in a less verbose way, I've shown how
23:41:51 <Squarism> sameSet?
23:42:01 <Koterpillar> just before
23:42:10 <Koterpillar> where I said "please don't do this"
23:43:00 <Squarism> gotta go
23:43:05 <Squarism> thanks for help anyway
23:43:25 <jle`> Squarism: verbose sometimes is more readable :)
23:43:36 <jle`> and more maintabinable
23:43:43 <jle`> *maintainable
23:44:12 <jle`> readability and maintainability should be your priority, not an artificial empasis on least amount of characters
23:44:56 <jle`> you also seem to value clarity in expression
23:45:05 <jle`> sometimes the more verbose option is more clear
23:46:30 <dibblego> verbosity is not measured in glyphs, or characters, or pixels, or any other arbitrary metric.
23:48:46 <akfp> the stack documentation site is down.  anyone from FP Complete here that can fix it?
