00:04:47 <glguy_> Koz_: don't use getStdGen, you need newStdGen
00:06:43 <glguy_> Osager_: same for you
00:09:10 <osager_> glguy_, ok
00:09:16 <osager_> why
00:11:49 <glguy_> http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#g:3
00:12:34 <osager_> ok
00:15:51 <koz_> glguy_: I don't use it in any case.
00:15:56 <koz_> I was just trying to help solve the type error there.
00:16:24 <glguy_> It's a common mistake so I just thought I'd mention it
00:17:43 <ijp> which priority queue package do people generally use?
00:18:40 <Welkin> dunno
00:18:43 <Welkin> try all of them
00:18:46 <Welkin> or write your own
00:19:04 <Welkin> a priority queue is pretty simple to write
00:19:31 <Welkin> I'm not sure why there isn't one in the containers package
00:31:39 <athan> Am I wrong here: If Data.Map was annotated with additional "distance" information, like the diffs between the keys, then you could make a `lookupMany :: Set k -> Map k a` that zips the sizes...?
00:32:01 <athan> hmm actually nevermind haha
00:32:02 <athan> hm
00:32:46 <athan> actually I'm not sure
00:33:01 <athan> really I think the question is, how quickly can you do parallel search
00:33:27 <athan> and sorting
00:33:35 <athan> I think
00:34:02 <athan> I have no idea, this is a giant question
00:43:15 <Welkin> athan: a giant, hairy question
00:55:10 <koz_> Does QuickCheck work with the 'detailed' testing option in Cabal?
01:12:52 <mrkgnao> .
01:13:09 <mrkgnao> :t Maybe
01:13:10 <lambdabot>     Not in scope: data constructor ‘Maybe’
01:13:10 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
01:13:21 <mrkgnao> :t Just
01:13:22 <lambdabot> a -> Maybe a
01:30:24 <adimit> Is there a package that defines TimeLocale for anything other than the U.S.? 
01:51:33 <the_2nd> I seem to be missing something when trying to use Maybe Monads within main http://lpaste.net/8709462913372389376
01:51:45 <the_2nd> why do neither of my case of prints work?
01:52:23 <sbrg> the_2nd: that doesn't typecheck
01:52:24 <colock> the_2nd: not sure about line 3
01:52:49 <sbrg> the_2nd: Maybe is a type. Just and Nothing are the constructors for the Maybe type.
01:52:49 <colock> shouldn't be either Just something or Nothing?
01:53:28 * hackagebot streaming-eversion 0.3.1.0 - Translate pull-based stream folds into push-based iteratees.  https://hackage.haskell.org/package/streaming-eversion-0.3.1.0 (DanielDiazCarrete)
01:53:31 <colock> Just a | Nothing is what Maybe is… all about
01:53:35 <the_2nd> yeah my bad, line 3 could be evo = Just ""
01:53:40 <the_2nd> or evo = Nothing
01:53:49 <sbrg> if you replace evo with either `Nothing` or `Just <something>` then it should work fine
01:53:50 <colock> ok, moving on them
01:53:58 <sbrg> yeah
01:54:18 <the_2nd> well it's not printing within my code :/
01:54:19 <sbrg> the_2nd: line 5 is the culprit
01:54:44 <sbrg> the type of that expression is IO (IO ())
01:55:08 <the_2nd> sbrg, I also tried stuff like : return $ evo >>= (\x -> print x), with same results
01:55:16 <andrewhn> remove the return
01:55:18 <sbrg> the_2nd: what you are doing instead of evaluating the IO actions is returning the IO action. 
01:56:06 <the_2nd> okay, this solved my minimal test problem
01:56:15 <the_2nd> I'll try fixing the rest of them and report back
01:56:28 <sbrg> the_2nd: you can either 1. remove the return on line 5, as suggested, or 2. do something like "foo <- return $ case .." and then follow that expression by `foo`
01:56:37 <sbrg> which will evaluate the IO action chosen by the case expression
01:57:44 <colock> like a = print "me"; a
01:57:48 <colock> in an imperative language
01:58:16 <colock> but it makes more sense to just print "me", right?
01:58:29 * hackagebot sproxy-web 0.4.1 - Web interface to sproxy database  https://hackage.haskell.org/package/sproxy-web-0.4.1 (ip1981)
02:01:54 <Axman6> "Couldn't match type ‘n + 3’ with ‘1 + (1 + (1 + n))’" :(
02:10:27 <the_2nd> sbrg, how can I make this syntax work? Or what is the "shorter" way of writing it? Before I added some returns there until it compiled, but this resulted as before in nothing being printed
02:11:29 <sbrg> the_2nd: What do you mean?
02:11:33 <sbrg> You can just remove the return on line 5
02:12:36 <the_2nd> ah im dumb :D didnt paste the new link, hold on
02:12:47 <the_2nd> sorry : http://lpaste.net/3759650590930501632
02:13:33 <sbrg> :t (>>=)
02:13:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:13:46 <sbrg> the_2nd: what does that type signature tell you? 
02:14:32 <the_2nd> maybe into function returning new maybe (or monad)
02:15:12 <sbrg> Yes, a new Maybe, in your case
02:16:02 <sbrg> the thing is, the m type variable can only be instantiated to one thing. so if you give it a maybe as first parameter, the type of bind(>>=) has essentially been instantiated to Maybe a -> (a -> Maybe b) -> Maybe b
02:16:38 <sbrg> your function, (\x -> print a) has type :: a -> IO b, essentially. 
02:16:55 <sbrg> the point is: when chaining monads together using bind, you can't "switch monads"
02:17:57 <sbrg> > maybe (print "Nothing") print (Just 3)
02:17:58 <lambdabot>  <IO ()>
02:18:08 <Maxdamantus> There is no subtype relationship between `Maybe`, `Monad` or `m`.
02:19:24 <ggherdov> hello, was the ICFP programming contest 2016 announced? icfpcontest.org still redirects to the 2015 installation, and the event is usually around this time. Plus, the IFCP conference is on september, where the results are usually announced.
02:19:49 <the_2nd> so is the case of the only way of doing so? Since I only want to do something in the just case
02:20:05 <koz_> Is there a way to get QuickCheck property checks to work with the detailed test type from Cabal?
02:21:40 <sbrg> the_2nd: You can use `maybe` like above. There's also `fromJust` but that's partial and will cause a runtime error if it's Nothing. 
02:22:42 <sbrg> the_2nd: The thing is, you can't do "if thing is like this, do that" and not have an else case. It's not a case *statement*, it's an expression. The expression has to have a value in both cases.
02:22:50 <sbrg> if you want to "do nothing" then you can just "return ()" 
02:23:01 <srhb> And the value has to have the same type
02:23:09 <sbrg> ^
02:23:18 <srhb> (Which you may exploit, since IO () has a noop `return ()`)
02:23:23 <srhb> But this is not the case in general.
02:23:26 <the_2nd> sborg I think I got it
02:23:33 <the_2nd> I like the maybe function's syntax
02:23:42 <sbrg> :t maybe
02:23:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:24:02 <sbrg> maybe <value if nothing> <function to convert value inside Just if Just> <Maybe value>
02:24:26 <sbrg> > maybe "nothing" (const "something") Nothing
02:24:27 <lambdabot>  "nothing"
02:24:33 <sbrg> > maybe "nothing" (const "something") (Just undefined)
02:24:34 <lambdabot>  "something"
02:28:30 * hackagebot amqp 0.14.0 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.14.0 (HolgerReinhardt)
02:34:15 <the_2nd> sbrg, all working now, thanks
02:36:27 <the_2nd> sbrg, since my IO broke after using maybe, I thought I was in the Nothing cases all the time, since I onl tried to print in the Just cases. Finally working again
02:38:31 * hackagebot hascar 0.1.0.0 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.1.0.0 (hc)
02:40:06 <fr33domlover> Q: Is there a way to create HTML image maps in Haskell? e.g. a PNG image of some diagram, with some boxes being hyperlinks. I know graphviz can generate them and I can use the dotgen package to build a .dot graph, but are there more Haskellish ways, maybe using 'diagrams'?
02:44:29 <atc-> Morning all :)
02:45:34 <sbrg> anyone have a recommendation for a library for colored text output to terminal?
02:46:09 <sbrg> already seen https://hackage.haskell.org/package/rainbow-0.26.0.6/docs/Rainbow.html and System.Console.ANSI. 
02:53:50 <atc-> If I defined a Class in one module, and I import that module elsewhere, I presume I can still access that class in the outer module, correct? I ask because the compiler can't seem to find the methjod I'm calling on from the class
02:53:54 <atc-> *function not method
02:56:33 <atc-> I get a "Not in scope: xxxx" error
02:57:51 <srhb> atc-: The outer module being the importing one?
02:59:34 <pikajude> how do I get the nice syntax highlighting theme that's on hackage in my own haddocks?
03:00:33 <quchen> sbrg: ansi-terminal is the standard I think. There's also ansi-wl-pprint, built upon the former, which is a nice prettyprinter.
03:00:47 <quchen> I recommend using the latter.
03:00:49 <atc-> that's right srhb 
03:00:57 <srhb> atc-: Yes, you can.
03:01:21 <atc-> curious why I get the error then
03:01:38 <srhb> atc-: Did you specify an export list?
03:01:45 <srhb> atc-: Leaving out the methods?
03:03:00 <srhb> atc-: If module A exports everything (ie has no export list) and module B imports A and has no import list, then everything is exported and everything is imported.
03:06:24 <atc-> srhb, thanks, that's what I thought. I'll re-check what i've done
03:06:36 <srhb> atc-: Yeah, sounds like a wrong assumption somewhere. :)
03:10:39 <srhb> Oh dear.
03:11:20 <srhb> I think the report implies that Foo a => a is called a method.
03:11:31 <srhb> How disturbing.
03:11:55 <atc-> srhb, having implemented my instance of the imported class, I still get  Not in scope: type constructor or class 'xxx'
03:12:05 <atc-> It MUST be me, just can't see the wood for the trees
03:12:07 <srhb> atc-: Time to lpaste.net a minimal example :)
03:16:48 <atc-> srhb, found it. Too embarassed to say :(
03:16:55 <srhb> atc-: Fair enough. ;-)
03:19:05 <atc-> srhb, hehe I had () on the import for some reason
03:19:08 <atc-> That explains it
03:19:17 <srhb> atc-: Great. :)
03:19:23 <atc-> srhb, thanks for the help!
03:22:12 <sbrg> quchen: Seems Rainbow worked pretty fine.
03:23:32 * hackagebot hascar 0.1.0.1 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.1.0.1 (hc)
03:26:36 <koz_> I keep finding myself writing 'if someBooleanFromFoo then Just foo else Nothing'. Is there some kind of cleverer way to do this?
03:28:44 <lyxia> foo <$ guard someBooleanFromFoo
03:28:45 <sbrg> eh, I think this came up the other day as well. I think someone had a pretty smart solution, though I can't remember it
03:29:07 <koz_> lyxia: That's pretty awesome!
03:29:09 <koz_> :t guard
03:29:10 <lambdabot> Alternative f => Bool -> f ()
03:29:21 <koz_> :t (<$)
03:29:22 <lambdabot> Functor f => a -> f b -> f a
03:30:09 <koz_> lyxia: And if I wanted to Nothing on someBooleanFromFoo being true?
03:30:56 <lyxia> guard (not someBoolean)
03:31:07 <koz_> lyxia: Derp, of course. Thank you!
03:31:13 <lyxia> yw
03:33:37 <lpaste> koz_ pasted “Confirming my understanding - am I right lyxia?” at http://lpaste.net/166738
03:38:27 <Cale> koz_: yes
03:38:44 <Cale> er
03:38:47 <Cale> no, haha
03:38:55 <koz_> Cale: What did I miss then?
03:38:56 <Cale> You need not (null x)
03:39:02 <lyxia> heh
03:39:06 <koz_> Cale: Wait what?
03:39:26 <Cale> guard True = Just ()
03:39:30 <Cale> guard False = Nothing
03:39:55 <Cale> v <$ Nothing = Nothing, and v <$ Just x = Just v
03:40:14 <koz_> Cale: So how should I have written what I had up there?
03:40:30 <Cale> replace null x with not (null x) and it'll work
03:40:43 <koz_> Oh derp. Thank you!
03:43:55 <lpaste> koz_ pasted “Have I understood it now, Cale and lyxia?” at http://lpaste.net/166739
03:44:31 <Cale> Try it and see
03:44:44 <koz_> I guess I shall.
03:44:49 <Cale> You really ought to have ghci open alongside your text editor so that you can keep the code loaded
03:45:13 <Cale> Then it's easy to see if you have things right by just plugging in some values and checking that you get what you expected
03:45:48 <koz_> Cale: True that.
03:46:00 <koz_> But yeah, it works.
03:46:06 <koz_> As an aside,I should read up on MonadPlus again.
03:46:23 <MichaelBurge> I get type errors all the time, but I think this is the first time I've gotten a kind error: http://hastebin.com/gosufusogu.vbs
03:46:29 <MichaelBurge> I've been puzzling out how to read it for the past few minutes
03:48:04 <MichaelBurge> I think it's saying I mixed up 'Any *' and '*'. According to the docs, it should be safe for me to coerce them somehow.
03:48:08 <Cale> Btw, this <$ operation is also very often useful in the context of FRP libraries, as you often want to replace the values in the occurrences of an Event with some other constant. e.g. you'll get some  click :: Event ()  representing the clicks on a button, and then  v <$ click  will be an event which fires with value v whenever the button is clicked.
03:48:50 <lyxia> MichaelBurge: that errors looks nasty
03:49:48 <koz_> Cale: I see. I think I just need to read the Typeclassopedia about MonadPlus again.
03:49:57 <koz_> Also, I'm kinda annoyed at the type of equating right now.
03:50:08 <Cale> Is equating a thing?
03:50:26 <koz_> Because it means I can't write something like '(S.size . S.map i $ x) == S.size x' as 'equating S.size (S.map i x) x'.
03:50:31 <koz_> Yep - it's in BasicPrelude.
03:51:09 <koz_> (where S is a prefix for Data.Set stuffs)
03:51:33 <Cale> why can't you write that?
03:51:55 <Cale> oh
03:52:02 <Cale> er, no, I don't see it :)
03:52:30 <koz_> Cale: S.map i x has type 'Set Int', while x has type 'Set SomethingOtherThanInt'.
03:52:40 <Cale> Oh, I see
03:52:43 <koz_> equating, like comparing, wants a function of type a -> b.
03:52:54 <koz_> Set Int isn't Set SomethingOtherThanInt type-wise.
03:53:00 <Cale> yes, there's nothing you can do about that
03:53:07 <koz_> It really should be (forall a. a -> b) honestly.
03:53:21 <MichaelBurge> Is there a way to get GHC to print out the simplified version of a type alias in error messages?
03:53:24 <Cale> That would mean that you could only give a constant function
03:53:34 <Cale> The only functions of type (forall a. a -> b) are constant functions
03:53:56 <koz_> Cale: Whoops, my bad.
03:54:04 <koz_> I realize that now.
03:54:20 <koz_> So there *really* is nothing I can do about that except by writing 'setEquating' or somesuch?
03:54:25 <Cale> right
03:54:29 <koz_> :(
03:54:31 <koz_> Oh well.
03:55:08 <koz_> Yeah, because it'd need to have the type (forall a . Set a -> b), right?
03:55:23 <Cale> yeah
03:55:43 <Cale> Perhaps with an Ord constraint on a in there
03:56:01 <Cale> :t S.size
03:56:02 <koz_> Yeah.
03:56:02 <lambdabot> Data.Set.Set a -> Int
03:56:11 <Cale> ah, don't need it for this case :)
03:56:16 <koz_> But in general you would.
03:56:44 <koz_> For all we know, that function is something like 'S.foldl' (+) 0'...
03:56:56 <koz_> (although that'd need a *different* constraint on a...)
04:03:34 * hackagebot sexp-grammar 1.2.1 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.2.1 (EugeneSmolanka)
04:14:33 <sbrg> Is it normal for a library that essentially uses QuasiQuotes to let me do multi-line strings easily(library is called here) to depend on haskell-src-exts?
04:14:48 <sbrg> because it's taking *forever* to build and the dependency tree kind of seems large and strange to me
04:16:15 <sbrg> @hackage here
04:16:15 <lambdabot> http://hackage.haskell.org/package/here
04:19:13 <MichaelBurge> sbrg: I've used raw-strings-qq before
04:19:44 <sbrg> i just removed the library and used a list and unlines for now. this is just ridiculous
04:20:16 <sbrg> after literally 10 minutes building only haskell-src-exts
04:23:12 <Axman6> using stack means you'll only pay that cost once(-ish)
04:24:56 <MichaelBurge> sbrg: Yeah, that library is parsing Haskell inside the block. It seems like overkill. I'd probably write something that looks more like printf with a signature like 'template :: String -> [AnyStringable] -> String'
04:25:24 <sbrg> MichaelBurge: I see
04:28:48 <srhb> sbrg: You should try nix... :-)
04:30:31 <sbrg> It's on my list, heh
04:30:34 <sbrg> been there for a while
04:30:51 <srhb> I just wanted to one up Axman6, by paying the cost "no times (ish)" :-P
04:34:42 <Prutheus> Hello. I am on archlinux. I have GHC8.0.1 installed. I wanted to install clash-compiler via cabal now, but it tells me an error »ghc required <=7.12« so now I cloned the git repo of clash-compiler and executed »stack build && stack install« but now when i wanna execute the clash program, i get error »CLaSH needs the GHC compiler it was build with, ghc-7.10.3, but it was not found. Make sure its 
04:34:48 <Prutheus> location is in your PATH variable.« . How to fix that? What could I do?
04:35:51 <srhb> Prutheus: It sounds like Stack installed GHC 7.10.3 outside of your PATH. I think the correct solution is to have stack drop you into an environment where it IS on path before executing clash
04:36:23 <Prutheus> so i should add following to path or what? .stack/programs/x86_64-linux/ghc-7.10.3/bin/
04:36:57 <srhb> That would be one solution, but I can't figure out if it's brittle or not. Does stack not provide a way to get a shell with its modified PATH?
04:37:09 <Axman6> srhb: fair call :P though in both cases you're basically only ever going to pay the cost of recompilation if a new version is used
04:37:14 <srhb> Prutheus: ie. stack exec bash or something
04:37:42 <srhb> Axman6: Yeah, the main gain is the binary cache so you never need to build (if it's there.) :)
04:37:56 <Axman6> ah, didn't know about that
04:38:58 <Prutheus> okay, this is a solution srhb , but is it also possible to build clash-compiler with ghc8 ?
04:39:02 <Axman6> and yes, stack exec bash should give you a shell with all the appropriate environment variables
04:39:14 <puregreen> sbrg: try neat-interpolation
04:39:26 <srhb> Prutheus: If their master branch specified that it needs 7.10.3 in its stack configuration, my guess is "no"
04:39:39 <srhb> Prutheus: But you can try modifying it if you like.
04:40:01 <puregreen> (well, tho neat-interpolation is only for Text, not String)
04:40:14 <Prutheus> srhb, okay, i tryed to do it via a stack shell now, but now i get: .local/bin/clash --interactive FIR.hs :
04:40:34 <Prutheus> http://ix.io/UcP
04:40:41 <Prutheus> what does this means? q.q
04:41:05 <srhb> Prutheus: That the module is unavailable in the pkg db for the ghc it's using.
04:42:04 <Prutheus> so how can i fix that? i think i have no modules installed in the stack ghc 7.12
04:43:33 <srhb> I'm not fluent enough in stack, but I would assume you add them to stack.yaml
04:44:09 <Prutheus> okay
04:51:14 <Prutheus> srhb how to add them?
04:51:28 <srhb> Prutheus: I don't know. :)
04:52:03 <Prutheus> okay, so ,any other possiblity to get clash working exept via stack?
04:52:53 <Axman6> Prutheus: what problem are you having with stack?
04:53:52 <Prutheus> at executing the program build with stack, i have missing libraries which it needs
04:55:08 <Axman6> and what does stack say?
04:55:16 <Prutheus> Axman6: http://ix.io/Ud4
04:56:11 <Ulrar> Is there something similar to Data.Text.splitOn but that will stop at the first separator instead of splitting the whole string ?
04:56:20 <Axman6> so you're not in a stack based project?
04:56:54 <Prutheus> Axman6: I installed clash-compiler via stack, and now I just have a .hs File which i need to execute running clash program with it
04:57:51 <Axman6> and you installed clash-compiler using stack install class-compiler?
04:57:58 <Axman6> clash*
05:00:14 <Prutheus> nono
05:00:22 <Prutheus> i cloned the git repo of clash-compiler
05:00:29 <Prutheus> then i run stack build && stack install
05:00:42 <Axman6> and stack was happy with that?
05:00:59 <Prutheus> sure. it is installed in .local/bin
05:01:17 <Prutheus> but, because you mentioned it
05:01:25 <srhb> Prutheus: Why not use the install script provided?
05:01:28 <srhb> Does it not work?
05:01:31 <Prutheus> i can do stack install clash-ghc, so then it installs the real package
05:01:40 <Prutheus> i am doing that right now :D
05:01:47 <Prutheus> didn't know that stack has something like that
05:02:00 <Axman6> yeah, I was about say clash seems to be in stackage
05:02:36 <Prutheus> ahh, it is called stackage then xD
05:02:45 <Prutheus> Axman6: can you shortly explain me please what stack is? :D
05:03:09 <Axman6> https://github.com/fpco/lts-haskell#readme is probably a good place to start
05:03:19 <srhb> Prutheus: And have you read this? https://github.com/clash-lang/clash-compiler/wiki/Getting-started
05:03:40 <Axman6> basically it's like cabal, but it uses stackage LTS snapshots, which are library versions known to compile together
05:03:44 <srhb> At least the first section.
05:04:01 <Prutheus> ahh thanks. i see
05:08:36 * hackagebot text-loc 0.1 - Line-column locations within a text.  https://hackage.haskell.org/package/text-loc-0.1 (MikhailVorozhtsov)
05:13:16 <Prutheus> it worked now, thanks guys
05:15:25 <MichaelBurge> What's a good way to hide a single overloaded field when importing a module? Here's an example: http://lpaste.net/166740
05:17:29 <srhb> MichaelBurge: hiding (A1(error)) I believe
05:17:53 <srhb> MichaelBurge: Note that in this case you're also colliding with the Prelude.error function
05:18:13 <MichaelBurge> srhb: Yeah, I'd like a way to hide all of them at once without having to repeat them.
05:18:17 <Cale> I wonder how long it'll be until we start really regretting DuplicateRecordFields
05:18:20 <srhb> Basically never have the same record field name, it's too painful.
05:18:30 <srhb> Even if the alternative is painful as well.
05:23:37 * hackagebot benchpress 0.2.2.8 - Micro-benchmarking with detailed statistics.  https://hackage.haskell.org/package/benchpress-0.2.2.8 (willsewell)
05:43:38 * hackagebot rainbow 0.28.0.2 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.28.0.2 (OmariNorman)
05:46:09 <hc> hi
05:46:26 <hc> i uploaded a package to hackage, but it fails to build due to too tight version restrictions in the cabal file
05:46:36 <hc> what's the recommendation about version restrictions these days?
05:46:41 <hc> any docs you could point me to? :)
05:47:47 <srhb> I didn't even know that was possible.
05:54:16 <coppro> hc: in your cabal file or another package's?
05:54:50 <hc> coppro: in mine
05:55:21 <hc> i use lts-6 and basically use the current version of each package as minimum, and the n.(x+1) as maximum
05:55:28 <hc> but i think that's too restrictive in many cases
05:56:35 <coppro> hc: that's usually what I use
05:56:39 <oherrala> hc: I used stack build --resolver lts-X to find what's the minimum versions of libs that still pass the test suite
05:56:56 <coppro> hc: just inspect the dep that's failing and see if it can safely be upgraded
05:57:17 <coppro> or determine if the library's versioning scheme allows you to safely drop the restriction to major-only
05:58:08 <hc> okay... and i guess to test whether a build will actually succeed on hackage, you'd have to build using cabal without stack locally
05:58:32 <hexagoxel> hc: stackage nightly uses ghc-8, which is what the buildbot uses.
05:58:38 * hackagebot crypto-multihash 0.2.0.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.2.0.0 (mseri)
05:59:25 <hexagoxel> so if you can make it build with that, the loosened bounds should make it work on hackage.
05:59:50 <coppro> hc: or do a stackage override
06:02:14 <atc-> Anyone here know Servant very well? I'm looking to get access to the request info (headers e.g. user agent, ip address) but the documentation doesn't seem to cover it
06:02:47 <ron___> hi
06:03:13 <ron___> how to program in hsakell
06:03:25 <hc> alright, thanks everyone! :)
06:04:24 <hpc> ron___: just type things until it works
06:04:32 <hpc> doesn't matter what
06:04:34 <hpc> :P
06:04:36 <oherrala> slam the keyboard until it compiles :)
06:08:39 * hackagebot accuerr 0.2.0.2 - Data type like Either but with accumulating error type  https://hackage.haskell.org/package/accuerr-0.2.0.2 (OmariNorman)
06:09:08 <hawk78> Hi, I need info about ghc and non exaustive patterns warnings... is it normal such warning are not emitted for function patterns?
06:09:15 <hawk78> asdfa
06:09:22 <hawk78> asdfaf
06:09:31 <hawk78> ops, sorry!
06:10:11 <hawk78> My irc client got stuck and then recovered and sent those two lines!
06:13:20 <Axman6> hawk78: warnings aren't emitted by default
06:13:39 * hackagebot crypto-multihash 0.2.0.1 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.2.0.1 (mseri)
06:14:00 <Axman6> you need -Wall (or the specific watning for that)
06:14:05 <Nuxular> Hi, I'm looking at the following page: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Traversable.html
06:14:28 <Nuxular> It mentions some laws involving an applicative transformation t
06:15:16 <Nuxular> where it defines 'applicative transformation', does t have to have the same concrete type in every mention of it?
06:15:30 <Nuxular> is 't' a single function?
06:15:43 <Nuxular> can 't' be polymorphic?
06:16:09 <hawk78> Axman6: I'm using this flags -threaded -rtsopts -with-rtsopts=-N -Wall -W -fwarn-incomplete-uni-patterns
06:16:23 <Nuxular> where it says the following: t x <*> t y
06:17:00 <Nuxular> I'm asking if the following is an instance of that: [(*2)] <*> [5]
06:17:47 <hawk78> Axman6: It works for patterns in case expressions, but does not work for patterns in functions
06:18:04 <Nuxular> where t x = [(*2)] and t y = [5]
06:18:39 * hackagebot fitspec 0.2.0 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.2.0 (rudymatela)
06:19:34 <hawk78> Axman6: e.g. it does not give me a warning for data D = A | B \n f A = 3
06:20:08 <Nuxular> it seems to me that if t must have the same type in every occurrence within the expression "t x <*> t y" then it severely limits to what the laws apply
06:21:11 <hexagoxel> hawk78: with "-Wall -W", "-W" overrides "-Wall". so you only get normal=default warnings + uni-patterns
06:22:58 <Nuxular> actually, that can't work, because (<*>) :: Applicative f => f (a -> b) -> f a -> f b
06:23:34 <Nuxular> so on the type level f(a -> b) = f a
06:24:35 <Nuxular> so I guess I'm left with the only option that the laws are referring to different instances of t in the two times it occurs in "t x <*> t y"
06:25:52 <jmcarthur> hexagoxel: That seems like an undesirable interface. I would have expected that -W can only add warnings, not remove them.
06:26:28 <jmcarthur> I presume -Wall behaves similarly.
06:28:01 <hexagoxel> jmcarthur: so am i wrong? i may be; i only know that you can override e.g. Werror with later switches.
06:28:40 * hackagebot hascar 0.1.1.0 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.1.1.0 (hc)
06:29:50 <hawk78> hexagoxel: you are right thanks!
06:32:13 <mniip> Nuxular, the applicativee transformation has the type forall a. (Applicative f, Applicative g) => f a -> g a
06:32:31 <mniip> so naturally, it doesn't care whether a is a value or a function
06:34:35 <Nuxular> mniip, my question was about whether to consider t in "t x <*> t y" as the same function or not. As in what concrete types can be assigned to it.
06:34:58 <jmcarthur> hexagoxel: hawk78 says you were right, so I'm just sad now. 
06:35:00 <mniip> yes it is the same term, but since it is polymorphic, it can appear at different types in the expression
06:35:55 <hexagoxel> jmcarthur: i was wrong, according to my quick testing in ghci
06:36:04 <Nuxular> mniip, that approximates a answer to my question, but I think I've already answered my question
06:36:08 <Nuxular> *an
06:36:40 <Nuxular> mniip, the confusion I have is around whether or not to consider a polymorphic function a single function or not
06:36:45 <mniip> well, with visible type application,
06:37:12 <mniip> forall a b. t@(a->b) x <*> t@a y = t@b (x <*> y)
06:37:36 <hexagoxel> hawk78: -Wall -W probably works. my next guess is that it did not actually recompile the relevant module, so you did not see the warning. -Werror might be useful.
06:37:44 <hexagoxel> hawk78: sorry about the misinformation.
06:37:53 <Nuxular> what is 'visible type application'?
06:38:01 <Nuxular> mniip
06:38:17 <mniip> t is universally quantified
06:38:27 <mniip> we clarify how its type is specialized when applying
06:38:52 <mniip> 1466256978 [16:36:18] <Nuxular> mniip, the confusion I have is around whether or not to consider a polymorphic function a single function or not
06:38:56 <mniip> is 'return' a single function or not
06:39:04 <mniip> er
06:39:07 <mniip> 'repeat'
06:39:23 <Nuxular> are you asking me a question?
06:39:33 <mniip> yes
06:40:04 <Nuxular> There is a sense in which it is a single function and there is a sense in which it is not
06:40:28 <mniip> sure
06:40:38 <Nuxular> the sense in which it is not is one that considers only concrete types as instances
06:41:03 <mniip> but is it useful to treat functions of incompatible types as different
06:43:23 <Nuxular> when you refer to compatibility, do you mean how  "f :: a" is compatible with "f :: Int"
06:43:26 <Nuxular> ?
06:43:38 <mniip> yes
06:44:28 <mniip> in category theory, a natural transformation is a mapping from F A to G A, for any A
06:45:02 <mniip> it is usually determined completely by the structure of the functors F and G, so the parameter A is of no interest (objects are rarely of interest in CT)
06:45:14 <mniip> so in haskell we just universaally quantify over a
06:45:22 <mniip> doesn't mean it's somehow multiple functions for each type a
06:45:51 <Nuxular> so you are saying that the two mentions of t in "t x <*> t y" are the same function only in the sense that they each admit the same class of types individually (ignoring that as soon as one of them is constrained to a concrete type, the other must in fact differ)?
06:46:57 <Cale> Hm, I'm not sure I agree so much with that. There are typically many different natural transformations between any pair of functors.
06:47:41 <guillaum1> I have two monadic actions A and B. I want something such as "a <- A; b <- B; if a || b then ... else ..." but I want to avoid doing the monadic action B if a is true. Is there a solution ?
06:48:37 <mniip> Cale, oops, yes, that's not exactly what I meant
06:48:51 <guillaum1> (My problem is more complexe actually, I want to test "c0 && (c1 || Mc2)" where c0 and c1 are Bool and Mc2 is "m Bool" I want to avoid executing if it is not necessary...
06:49:53 <mniip> guillaum1, a straightforward solution would be 'when c0; unless (not c1); c2 <- mc2 ...'
06:50:16 <Cale> mniip: Also, in the more general setting, you're allowed to specify for each object A what the map FA -> GA is (so long as the naturality squares will commute), so there's a bit more freedom of definition than parametrically polymorphic functions will give you.
06:50:29 <mniip> oops I think I messed up the signatures there
06:51:24 <mniip> when c0 $ unless c1 $ do c2 <- mc2; ...
06:51:37 <mniip> Cale, yes
06:51:40 <Nuxular> Cale, mniip, could I have confirmation that I'm on the right track? is that what was meant when they used 't' in the laws mentioned on that page?
06:51:41 <Cale> @let x .|| y = do b <- x; if b then return True else y
06:51:43 <lambdabot>  Defined.
06:51:45 <mniip> but those NTs are rarely considered
06:52:54 <mniip> Nuxular, I'm not sure I agree with that
06:52:55 <guillaum1> mniip: actually yes, but I have an else branch, so for now I'm forced to do "if c0 then (if c1 then okBranch else do {c2 <- mc2; if c2 then okBranch else falseBranch}) eles falseBranch" 
06:53:03 <Cale> Nuxular: Is what what was meant?
06:53:20 <Nuxular> Cale, 	Nuxular	so you are saying that the two mentions of t in "t x <*> t y" are the same function only in the sense that they each admit the same class of types individually (ignoring that as soon as one of them is constrained to a concrete type, the other must in fact differ)?
06:53:29 <Cale> Nuxular: They define what they mean by an applicative transformation there.
06:53:39 <mniip> no, they're the same term
06:53:48 <mniip> just used at different types
06:53:51 <Cale> They're the same t
06:53:59 <mniip> > (id "foo", id 3)
06:54:00 <lambdabot>  ("foo",3)
06:54:03 <Cale> t is polymorphic there
06:54:15 <mniip> > let t :: a -> a; t = id in (t "foo", t 3)
06:54:16 <lambdabot>  ("foo",3)
06:55:50 <Nuxular> I'm confused by how you disagree and then offer an explanation which seems to agree with what I'm trying to say
06:56:08 <Cale> I guess that means we're confused about what you're trying to say
06:56:39 <mniip> > let t :: [a] -> Maybe a; t = fmap fst uncons in  t [(+5),(*2)] <*> t [1,2,3]
06:56:40 <lambdabot>      Couldn't match type ‘Maybe (a, [a])’ with ‘(Maybe a, b0)’
06:56:40 <lambdabot>      Expected type: [a] -> (Maybe a, b0)
06:56:40 <lambdabot>        Actual type: [a] -> Maybe (a, [a])
06:56:49 <mniip> > let t :: [a] -> Maybe a; t = fmap fst . uncons in  t [(+5),(*2)] <*> t [1,2,3]
06:56:50 <lambdabot>  Just 6
06:56:55 <mniip> > let t :: [a] -> Maybe a; t = fmap fst . uncons in  t ([(+5),(*2)] <*> [1,2,3])
06:56:57 <lambdabot>  Just 6
06:57:19 <mniip> the above t is an example of an applicative transformation
06:57:41 <mniip> the two t's are the same, they have the same implementation
07:01:44 <nitrix> How viable is a language with parametric polymorphism but no type classes?
07:02:01 <nitrix> My understanding is that is how C++ templates works?
07:02:03 <mniip> you can do those by hand
07:02:13 <mniip> not exactly
07:02:40 <coppro> C++ templates are... interesting
07:02:56 <hpc> are C++ templates parametric?
07:02:57 <mniip> well iirc C++ has something resembling typeclasses in the newer standarss?
07:03:22 * hpc would expect them to be like java and you can do instanceof to "pattern match" on them
07:03:54 <hpc> (just because leave no abstraction uncrippled :P)
07:03:55 <Nuxular> ok, so both t's in "t x <*> t y" are the same in the same sense as within a let expression. I didn't even know that let expressions didn't reduce each defined term to a (single) concrete type before applying.
07:04:00 <nitrix> So the language would have to support pattern matching on types?
07:04:39 <mniip> hpc, int foo(A _) { return 0; }; int foo(B _) { return 1; }
07:04:56 <mniip> template<typename T> int bar(T t) { return foo(t); }
07:05:19 <hpc> yeah, that figures
07:06:29 <nitrix> Interesting.
07:07:18 <Cale> nitrix: Pattern matching on types breaks the parametricity
07:07:28 <nitrix> I was reading Kittenlang (http://kittenlang.org/intro) and they have what seems to be a very limited form of polymorphism.
07:07:37 <nitrix> The type of map is :: <a, b> ([a] (a -> b) -> [b])
07:07:54 <nitrix> And they have pattern matching by value, so I'm trying to figure out how limitating this is.
07:08:06 <nitrix> Rank-N types seems a problem, for one.
07:08:23 <jmcarthur> nitrix: There are many languages with parametric polymorphism but no type classes. Most languages in the ML family, for example.
07:08:45 <mniip> nitrix, you can get away without typeclasses just fine, just pass dictionaries by hand!
07:08:46 <jmcarthur> nitrix: (though some of the violate parametricity in a few limited ways)
07:09:05 <jmcarthur> It's totally viable.
07:09:50 <nitrix> Okay, but lets say you have a Rank-2 function, how would that work?
07:10:08 <jmcarthur> Those don't require type classes.
07:10:13 <Cale> It... would work how it does in Haskell when you don't use type classes
07:10:20 <nitrix> jmcarthur: I'm enlarging the question.
07:10:26 <Nuxular> btw mniip, is "fmap fst . uncons" the standard way of getting a version of 'head' that returns a Maybe value?
07:10:49 <jmcarthur> nitrix: A language could have higher rank types without having type classes. I don't understand the question.
07:11:01 <nitrix> jmcarthur: It's not about type classes anymore.
07:11:08 <jmcarthur> nitrix: What is it about now?
07:11:30 <mniip> Nuxular, "standard"? no, just one I came up with
07:11:39 <mniip> I think there's a package for those
07:12:12 <jmcarthur> nitrix: Are you asking if higher rank types is a redundant feature?
07:12:19 <nitrix> jmcarthur: If you have a polymorphic function in that kind of language which gives very little information about what `a` is, and then turns out one of those `a` are other polymorphic function (thus you're trying to implement a Rank-2 function), how do you pattern match that?
07:12:33 <Cale> nitrix: I don't understand the question, didn't you just ask how rank-2 types would work in the absence of type classes?
07:13:00 <nitrix> With Haskell, you get a clear `forall`, they don't seem to have anything like this. Just a very blatant `a` that's supposed to represent any type, all the time.
07:13:03 <Nuxular> mniip, I see. it seems they provide listToMaybe in the Data.Maybe module that does the same thing
07:13:11 <jmcarthur> nitrix: You can't pattern match on functions with or without type classes.
07:13:22 <nitrix> jmcarthur: It isn't about type classes anymore.
07:13:28 <Cale> nitrix: uh, what's the difference between "any type" and "for all types"?
07:13:34 <nitrix> Cale: None.
07:13:46 <nitrix> Cale: Or, maybe I should say `exist`, but still.
07:13:48 <suppi> nitrix, you can also look at Elm. it has par pol but no type classes or higher kinds
07:13:50 <Cale> huh?
07:13:56 <jmcarthur> nitrix: What do you mean by "that kind of language" then?
07:14:20 <nitrix> jmcarthur: I've given the link and everything.
07:14:37 <nitrix> I've given all the info, you're just stuck on `type classes`.
07:14:53 <jmcarthur> nitrix: I don't mean to make fun, but I can't read an entire manual for a language I don't know to tell you how it works.
07:15:21 <suppi> nitrix, btw i think the kitten website is not up to date with the latest compiler so it might be worth to wait a bit for it :)
07:15:30 <nitrix> jmcarthur: That's why I saved you the trouble and extracted the relevant parts and formulated a question.
07:16:05 <jmcarthur> nitrix: What are the relevant parts then? Could you state the question coherently?
07:16:12 <nitrix> I'm out.
07:16:16 <jmcarthur> nitrix: Does that language even support higher rank types?
07:16:35 <nitrix> jmcarthur: It's what I'm asking.
07:16:42 <Cale> nitrix: What does the [a] mean in that type signature?
07:17:00 <Cale> oh, that's the list
07:17:09 <nitrix> Cale: The <> reads as some kind of forall, presumably.
07:17:12 <jmcarthur> nitrix: That again makes it sound like you are wanting somebody to read the documentation for you.
07:17:21 <Cale> nitrix: Yeah
07:17:30 <nitrix> jmcarthur: I've read the documentation. Stop making assumptions. You aren't helpful in any way. If you don't want to help, don't.
07:17:53 <jmcarthur> nitrix: I am just trying to understand your question, because I do want to help.
07:18:17 <Cale> nitrix: So why couldn't something just have a type like (<a> a (a -> a) -> a) -> Int -> Int?
07:18:24 <Cale> or I dunno
07:18:29 <Cale> maybe they'd want to uncurry
07:18:36 <Cale> (<a> a (a -> a) -> a) Int -> Int
07:18:42 * hackagebot pusher-http-haskell 1.0.0.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.0.0.0 (willsewell)
07:19:26 <nitrix> Cale: Forget about it.
07:19:31 <nitrix> Cale: Thanks though.
07:19:38 <suppi>  nitrix
07:19:55 <suppi> not sure if i understand correctly
07:19:56 <Cale> i.e. what we'd write in Haskell as (forall a. a -> (a -> a) -> a) -> Int -> Int
07:20:17 <jmcarthur> Cale: I seem to be coming off to nitrix as abrasive, so I'll ask you since it looks like you are at least making some progress. Do you understand nitrix's question?
07:20:24 <suppi> but a (a -> a) -> [b] is a function that expects two values on the stack
07:21:04 <suppi> i mean :: <a, b> ([a] (a -> b) -> [b])
07:21:06 <Cale> jmcarthur: I'm not sure, but I think he's asking how higher rank types would look in this notation that uses <a> in place of forall a. to quantify
07:21:24 <Cale> I don't know why he'd be asking that though, now that I write it down...
07:21:26 <suppi> it's like, have a list and a function on the stack and i'll give you back a list
07:21:40 <suppi> it's not about [a] being a higher rank type
07:21:55 <Cale> [a] isn't a higher rank type
07:22:01 <suppi> right
07:22:50 <Cale> It seems like you could easily enough fit higher rank types into this type system, but I have no idea if the language in question supports them
07:23:46 <suppi> i don't either, yet
07:23:59 <jmcarthur> nitrix: I'm sorry you found my line of questioning frustrating. I am going to give up now. I hope you understand that I was not being intentionally obtuse.
07:24:59 <nitrix> It's not like the documentation is great, but I was trying to work off from the features listed, e.g. the parametric polymorphism done with <a> and the pattern matching to see how the rest of the nice Haskell features could fit in there.
07:25:21 <mniip> neither of those says anything about the support of higher rank types
07:27:09 <nitrix> I'm assuming it'd look similar to Haskell's nested foralls, as well as all the complexity with scoped type variables and whatnot.
07:27:48 <mniip> never seen a situation where scoped tyvars are mandatory
07:28:10 <nitrix> How limitated are you without higher ranks?
07:28:50 <mniip> system F?
07:29:30 <coppro> mniip: it can be necessary to explicitly type declarations in where clauses
07:29:47 <mniip> example?
07:30:25 <coppro> foo :: a -> a; foo = bar where bar :: a -> a
07:30:42 <coppro> here, bar's type is implicitly quantified, but sometimes you want it to be monomorphic
07:31:08 <mniip> well scopedtyvars aren't mandatry here
07:31:25 <coppro> they are if you want bar's type to be monomorphic
07:32:25 <nitrix> That seems like let generalization to me.
07:32:58 <coppro> since the a in bar's signature and the a in foo's are different, bar is actually forall a. a -> a
07:33:01 <coppro> not a -> a
07:33:42 * hackagebot octane 0.10.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.10.0 (fozworth)
07:33:46 <mniip> coppro, why
07:33:50 <dolio> It's possible to construct examples where you must annotate bar, but a also must not be polymorphic.
07:33:57 <coppro> mniip: why what?
07:34:05 <mniip> why would you want it to be monomorphic
07:34:19 <mniip> I'm still waiting for a concrete example
07:34:20 <coppro> because sometimes you want to help the unifier
07:34:37 <coppro> if nothing else, for better error messages :)
07:34:43 <mniip> shrug
07:35:29 <dolio> If you do 'foo x = ...' where an argument of bar must be the same type as x, then it cannot be polymorphic.
07:35:32 <coppro> ghc manual gives the following example, not sure if it will fail to unify
07:35:38 <coppro> :let { foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where ys = reverse xs }
07:35:49 <coppro> >let { foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where ys = reverse xs }
07:35:58 <coppro> > let { foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where ys = reverse xs }
07:35:59 <lambdabot>  <no location info>:
07:35:59 <lambdabot>      not an expression: ‘let { foo :: forall a. [a] -> [a]; foo xs = ys ++ ys...
07:36:03 <coppro> > :let { foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where ys = reverse xs }
07:36:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:36:09 <coppro> lambdabot pls
07:36:40 <coppro> > let foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where ys = reverse xs in foo []
07:36:42 <lambdabot>  []
07:36:54 <coppro> > let foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where { ys :: [a]; ys = reverse xs in foo } []
07:36:56 <lambdabot>  <hint>:1:87: parse error on input ‘in’
07:37:04 <coppro> > let foo :: forall a. [a] -> [a]; foo xs = ys ++ ys where { ys :: [a]; ys = reverse xs } in foo []
07:37:06 <lambdabot>  []
07:37:18 <coppro> > let foo :: [a] -> [a]; foo xs = ys ++ ys where { ys :: [a]; ys = reverse xs } in foo []
07:37:19 <lambdabot>      Couldn't match type ‘a1’ with ‘a2’
07:37:19 <lambdabot>        ‘a1’ is a rigid type variable bound by
07:37:19 <lambdabot>             the type signature for foo :: [a1] -> [a1] at <interactive>:1:12
07:38:02 <coppro> mniip: in any case, why do people like top-level signatures? because it gives faster compilation, better error messages, and no less unintentional behaviour
07:38:09 <coppro> same goes for signatures inside where clauses
07:41:48 <mniip> huh
07:51:21 <jmcarthur> Does anybody know of a good example of Boehm-Berarducci encoding mutually recursive (with themselves and each other) types?
08:01:04 <dolio> jmcarthur: I think you'd need to turn the mutual fixed point into a single fixed point. There are multiple ways of doing that.
08:06:33 <jmcarthur> dolio: Yeah, I think I have no choice but to just roll up my sleeves and do it. I was just hoping somebody with better google-fu than me might find a worked example on the Internet.
08:07:47 <jmcarthur> dolio: Thanks.
08:46:19 <lpaste> glguy pasted “Boehm-Berarducci generics” at http://lpaste.net/166788
08:46:50 <glguy> jmcarthur: That doesn't help with your question about mutually recursive types, but your question made me want to explore using generics for that encoding
08:54:20 <edwardxhaigh> Hey guys
08:55:27 <jmcarthur> glguy: neat!
09:15:53 <jessu> hi    
09:17:46 <gio_> hi, can one tell me a chanel related for types?
09:18:02 <osager_> i have got this error: <stdout>: commitBuffer: invalid argument (invalid character)
09:18:08 <jessu> any haskel web developers here?
09:18:15 <osager_> where can i find the function that makes this error ?
09:18:17 <jessu> I menat webdevelopers using haskel
09:20:17 <coppro> jessu: Cale does
09:20:22 <lpaste> tippenein pasted “ListT STMContainers sort” at http://lpaste.net/166805
09:20:23 <coppro> gio_: what do you mean?
09:20:38 <coppro> osager_: please try to reduce a testcase
09:21:19 <tippenein> I have an STMContainers Map and I'd like to sort the contents and fold them into a bytestring
09:21:43 <jessu> coppro:  cale a framewrok?
09:21:48 <geekosaur> osager_, if I had to guess, you tried to output a Unicode codepoint that is not representable in whatever your locale is. In general, you want a UTF8 locale for Haskell.
09:21:53 <tippenein> however... when I do a sortBy (comparing snd) I think it comes out of the STM context
09:22:44 <geekosaur> jessu, Cale is a user who's often here in this channel (but isn't right now)
09:22:56 <geekosaur> oh wait, missed them the first time
09:23:08 <jessu> ok only one in 1432 nicks :(
09:23:40 <geekosaur> I don;t think anyone in here can tell you how many of the 1432 nicks might represent people who do web; just one or two well known people
09:23:56 <geekosaur> it's not like we require people to register their expertise before entering the channel
09:24:06 <jessu> hahaha ok
09:24:10 <geekosaur> and this is not a web developer channel
09:24:20 <jessu> ok I know
09:24:22 <glguy> jessu: If you actually have a question about web dev it would be better to ask than
09:24:39 <glguy> unless you're specifically interested in the number of people paying attention to the channel right now who do dev and are interested in saying so
09:24:53 <jessu> I wnt to know any one developed any analytical dashboad that is developed using haskel as backend
09:25:21 <zomg> jessu: I don't see why that wouldn't work :)
09:25:57 <jessu> it will wpork but i am just interested to know thats it
09:49:39 <JohnnyL> what topics are their next after learning monads?
09:50:09 <EvanR> MonadPlus
09:50:35 <hpc> a lot of stuff opens up
09:50:52 <hpc> probably the most practically useful thing is to go deep into IO-y stuff
09:51:01 <hpc> concurrency, etc
09:51:58 <hpc> theoretically, nothing stands out to me at the moment of "you should learn this next"
09:52:03 <hpc> maybe CPS / ContT
09:52:19 <hpc> oh, learn mtl maybe
09:52:21 <EvanR> stop learning stuff and write programs?
09:52:48 <hpc> well keep learning, but as directed by the programs you want to write
09:53:08 <JohnnyL> ok
09:55:25 <suppi>  what EvanR said
09:55:29 <suppi> and hpc
09:56:05 <suppi> also this is this path haskellbook follows, might be interesting: http://haskellbook.com/progress.html
09:56:17 <EvanR> JohnnyL: personally, GADTs changed my life
09:56:55 <EvanR> but thats pointless until you have something to say with them
09:57:29 <JohnnyL> EvanR: yah, it's nice to have the model in the code and the code in the model. :)
10:04:28 <mauke> https://rt.perl.org/Public/Bug/Display.html?id=128427
10:05:57 <geekosaur> ... o.O
10:07:25 <EvanR> hahaha
10:07:34 <MichaelK> Hi, how can I get GHC to distinguish between the class instances `C (f a) b => C (:*: f g a) b` and `C (g a) b => C (:*: f g a) b`?
10:09:31 <mauke> you don't because those are the same instances
10:11:18 <pavonia> Why are they the same?
10:11:24 <MichaelK> mauke: Ok then what I'm trying to do is provide something like `if C (f a) b then func (x :*: _) = x; if C (g a) b then func (_ :*: y) = y`. How can I do that?
10:11:51 <mauke> I don't think you can
10:12:01 <glguy> You can add an extra type parameter to make an explicit choice about which branch to take
10:12:06 <mauke> I think of classes like functions
10:12:27 <pyon> How do I make zippers for polymorphically recursive data types? (e.g., finger trees)
10:12:34 <mauke> instances become cases in the definition; constraints become the function body
10:12:40 <glguy> pavonia: They both match C (:*: f g a) b
10:12:42 <JohnnyL> let x  hpc+1 where channel==#haskell;
10:13:06 <jmcarthur> mauke: I'm having difficulty understanding that perl bug report. Are they saying that they need to patch ghc to fix perl5?
10:13:07 <mauke> so the instances above correspond to: C (:*: f g a) b = C (g a) b; C (:*: f g a) b = C (f a) b
10:13:28 <mauke> and because the patterns are the same, that's an error
10:14:10 <mauke> jmcarthur: the bug description sounds plausible, but the patch itself is against ghc for some inexplicable reason
10:14:14 <jmcarthur> Wait, are they saying they have a build dependency on C sources from GHC?
10:14:18 <MichaelK> mauke: So could I do something like `C (:*: f g a) b = Either (C (g a) b) (C (f a) b)
10:16:27 <glguy> MichaelK: You don't get to make decisions based on the existence of an instance
10:16:45 <jmcarthur> Lol, or maybe I guess somebody just patched the wrong language.
10:17:46 <glguy> MichaelK: Did you also have a functional dependency between the two typeclass arguments?
10:18:35 <MichaelK> glguy: For with or without the extra type parameter?
10:19:33 <JohnnyL> how can I help haskell to be more positional in business and indie usage?
10:19:58 <glguy> whatever C is, the point being that in addition to not being able to branch on the existence of instances that you're be violating the functional dependency with those two instances
10:20:34 <Cale> JohnnyL: use it? :)
10:20:49 <JohnnyL> Cale: ok!
10:21:04 <glguy> (if there was one, but classes of that structure commonly have them, so I was asking)
10:21:14 <JohnnyL> but what if i want to distribute on as many platforms as possible?
10:21:29 <JohnnyL> is there a haskell, to say, asm.js available?
10:21:38 <MichaelK> glguy: Ah, that makes sense
10:22:01 <MichaelK> JohnnyL: as far as I know, not quite: https://github.com/ghcjs/ghcjs
10:23:43 <JohnnyL> MichaelK: thanks.
10:25:14 <EvanR> hmmm when as many platforms as possible immediately means browsers
10:25:30 <EvanR> instead of gameboys, toasters...
10:26:03 <EvanR> haskell is woefully stuck on 3 main PC desktop OS... plus browser
10:26:36 <JohnnyL> EvanR: this ghcjs looks nice.
10:26:40 <Cale> JohnnyL: At the company I work for, we develop web applications entirely in Haskell using ghcjs and reflex-dom on the frontend
10:26:49 <JohnnyL> Cale: sweet!
10:27:22 <JohnnyL> Cale: what sort of industry if I may be so bold (u can pm me if you care).
10:27:24 <JohnnyL> ?
10:27:29 <Cale> https://obsidian.systems/
10:27:41 <Cale> Various industries...
10:29:31 <JohnnyL> Cale: i was going to vear to js/functional. but if ghcjs is close to production that may be more preferable.
10:29:32 <Cale> The applications I'm currently involved in are a chat client for intra-business use that has a bunch of extra productivity features (integration with email, etc.), and a market for shippers and carriers (truckers) to get matched up.
10:29:49 <Cale> It's quite usable for production
10:29:54 <JohnnyL> oh great!
10:30:11 <JohnnyL> I wrote an OSHA Training Manager back in 1994 using Visual Basic.
10:30:30 <ludat> Cale: did you try purescript? I'm between those right now
10:30:50 <Philonous> Cale, Oh, you're not in game dev any more?
10:30:52 <Cale> ludat: I haven't actually tried it
10:31:14 <Cale> Philonous: I haven't been in game dev for a few years now
10:31:42 <ludat> Cale: oh, ok
10:32:33 <JohnnyL> ludat: can you tell me if purescript is a haskell spec or a haskell fork?
10:32:54 <Cale> It's just similar to Haskell
10:33:09 <ludat> JohnnyL: afaik, it's not strictly haskell
10:33:20 <JohnnyL> ludat: ok thanks.
10:33:24 <Cale> It's really nice that with GHCJS you get to use most of the stuff on Hackage
10:33:26 <EvanR> it had some improvements
10:33:44 <EvanR> all haskell clones have improvements to the records
10:33:47 <ludat> it has some new things like row types but ghc is just huge
10:33:52 <JohnnyL> i've been programming a game in c++, but it is SOOO much boilerplate and takes so long to write.
10:34:08 <Cale> especially, e.g. the fact that you can use the same Aeson code for both the frontend and backend
10:34:24 <EvanR> JohnnyL: weve got a dedicated channel for game programming... #haskell-game btw
10:34:31 <JohnnyL> okay, does ghjc or purescript support sdl2 or webgl?
10:34:37 <JohnnyL> EvanR: very cool thanks!
10:34:50 <JohnnyL> jesus 72 people! ha.
10:34:52 <ludat> Cale: ohhh that's a big plus, it's really crazy how much of hackage ghcjs can compile
10:36:44 <Cale> JohnnyL: btw, I should also mention reflex and reflex-dom in particular as being really nice for building UIs
10:38:28 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI -- talk/demo :)
10:39:32 <Cale> I don't think there's much special support for webgl yet in GHCJS, but Javascript FFI is relatively easy to do, so someone could write a binding.
10:39:55 <JohnnyL> Cale: ok. :)
10:40:19 <JohnnyL> Are there things like JavaScript Lenses in haskell?
10:40:22 <Cale> googling, I found a github repo here with what looks like a good start on that
10:40:31 <Cale> https://github.com/ziocroc/ghcjs-webgl
10:40:58 <int-index> Hi, why doesn't this code compile? https://gist.github.com/int-index/c6b853351912d177cfcefd54678b27ff
10:41:02 <Cale> also https://github.com/isomorphism/webgl
10:41:25 <Cale> JohnnyL: What are those?
10:41:36 <Cale> I only know about the Haskell sort of lenses
10:42:25 <JohnnyL> Cale: ok
10:42:48 <Cale> JohnnyL: You can use Control.Lens
10:42:56 <Cale> (and we do)
10:44:12 <JohnnyL> Cale: oh sorry.
10:45:59 <JohnnyL> Cale: just using functions like 'over', 'view', 'indexof', 'path'. all purely functions. it allows you to manipulate props using micro precision.
10:46:23 <Cale> Yeah, Control.Lens is the original library which defined those
10:46:28 <bjs> JohnnyL: sounds like ekmetts lenses, so see Control.Lens
10:46:32 <JohnnyL> ok
10:46:40 <JohnnyL> sweet stuff.
10:47:03 <Cale> (well, there were a few other small ones, also in Haskell, before it, but Control.Lens is the really major one)
10:55:53 <tippenein> How do you sort inside STM monad. ListT doesn't seem to provide that
10:56:33 <Cale> tippenein: What type of thing do you want to sort?
10:59:16 <tippenein> towards the bottom of this http://lpaste.net/166805
10:59:25 <tippenein> it's a STMContainer Map
10:59:34 <tippenein> trying to sort by the values in the map
11:00:54 <Cale> I don't really understand what you're trying to do here -- how does the nondeterminism come in?
11:01:09 <Cale> Why ListT?
11:02:16 <tippenein> used it mostly because this sentence "Useful for streaming of monadic data structures."
11:02:48 <tippenein> am I misinterpreting it?
11:03:23 <Cale> yeah, ListT is for adding nondeterminism (i.e. actions with multiple results, where you want to try all possibilities) to another monad
11:04:12 <Cale> If you have a list and you want to sort it, you can just use the usual sort/sortBy etc.
11:04:38 <Cale> I don't know if there are any special sorting algorithms for the stuff in STMContainers, I've never used those.
11:05:20 <tippenein> nothing seems to pop out as a sort - https://hackage.haskell.org/package/stm-containers-0.2.13/docs/STMContainers-Map.html
11:06:26 <Cale> Well, yeah, that data structure is unordered, so it's not even clear what it would mean to sort it
11:07:40 <tippenein> I'm just incrementing a count for the value of the map, maybe STM is unnecessary
11:14:22 <gedda> Hey guys. I'm having trouble creating a custom container, anyone have a couple of minutes to help me out?
11:15:19 <gedda> formulated my code and question here: http://hastebin.com/anevoxikoh.haskell 
11:15:55 <gedda> The problem is in instantiating the container, I'm still fairly green to all the extensions and on how to use them correctly
11:16:03 <glguy> instance Ini (IniStorage a) a where
11:16:18 <glguy>     Expecting one more argument to ‘Ini (IniStorage a)’
11:16:30 <glguy> That means you have to provide one more argument to ...
11:16:32 <gedda> what the, i swear i tried that. Anyways, thanks
11:16:56 <gedda> I guess I should have figured it out, since the typeclass needs to argument aswell
11:16:58 <gedda> Thanks :)
11:17:11 <tippenein> seems like I lose concurrency if I move to Data.Map.Strict
11:21:12 <offensive_goat> hi everyone is racism allowed on this channel?
11:21:18 <Cale> offensive_goat: no.
11:21:44 <hpc> is that a serious question?
11:21:58 <offensive_goat> yes
11:22:04 <offensive_goat> ?
11:22:50 <hpc> pretty sure it's against network rules even
11:23:02 <offensive_goat> what happens if i am going to offend network rules?
11:23:14 --- mode: ChanServ set +o glguy
11:23:14 --- mode: glguy set +b $a:offensive_goat
11:23:14 --- kick: offensive_goat was kicked by glguy (offensive_goat)
11:23:20 <glguy> Let's go ahead and nip that in the bud
11:23:28 <Cale> seems fair
11:23:29 <jmcarthur> Yeah...
11:23:41 <Cale> tippenein: What if you just have an MVar (Map k v)?
11:23:59 <Walther> they seem to be trolling multiple channels in the network
11:24:29 <Zekka> It was nice of him to ask!
11:26:30 <Welkin> lol wtf
11:28:39 --- mode: glguy set -o glguy
11:38:16 <Benji__> Really new to haskell and having mind bended,  How can I pass a second parameter to the function I am using for map
11:39:05 <glguy> map (\x -> f x y) -- or -- map (f y)   depending on what you needed
11:42:50 <deech> Anyone know if the standard libs have an equivalent of C's popen?
11:43:08 <mauke> one of the process create things
11:43:30 <deech> Yeah, https://www.gnu.org/software/libc/manual/html_node/Pipe-to-a-Subprocess.html.
11:43:46 <glguy> ?hackage process
11:43:46 <lambdabot> http://hackage.haskell.org/package/process
11:44:14 <Benji__> glguy: amazing: thanks
11:44:40 <deech> glguy: Was that for me?
11:44:57 <mauke> yes
11:46:30 <deech> I was looking at that, I see createPipe http://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO-ByteString.html#v:createPipe and hPutStr, but I don't see how to start a subprocess.
11:47:05 <mauke> huh?
11:47:54 <glguy> That's the wrong package (unix), you need process
11:48:32 <deech> Oh, duh. I see it now. Sorry for the noise. I was wanting something like popen("ls -alh" ...). I believe the equivalent is openFd.
11:48:44 <glguy> Nope, not openFd
11:48:52 <glguy> that's also from unix, you need process
11:49:42 <mauke> deech--
11:49:47 <Benji__> Any feedback on this code? http://lpaste.net/166820
11:50:55 <deech> Ah, I see `createProcess` in the `process` package.
11:51:25 <sinelaw> Benji__: you can use @ to give 'x:xs' another name
11:51:49 <Benji__> sinelaw: Oh, i see, cool!  Thanks.
11:52:01 <mauke> Benji__: you can use a Set String for exceptions
11:52:26 <sinelaw> Benji__: and you can use guards to make it more concise
11:52:42 <lpaste> glguy annotated “No title” with “guards and stuff” at http://lpaste.net/166820#a166821
11:53:40 <Benji__> glguy: oooh, thats cool.
11:54:15 <sinelaw> Benji__: and as mauke said, you can use Set String instead of [String] for exceptions
11:54:54 <Benji__> sinelaw mauke: ah, yeah, great
11:55:52 <lpaste> jmcarthur annotated “No title” with “No title (annotation)” at http://lpaste.net/166820#a166822
11:56:30 <jmcarthur> Benji__: A bunch of changes included there ^^^
11:57:11 <jmcarthur> Ah, I like glguy's pattern matching + guards better than mine.
11:57:38 <Benji__> thanks all.  I feel like I’m learning how to program again with this language :O
11:58:22 <lpaste> jmcarthur revised “No title (annotation)”: “No title (annotation)” at http://lpaste.net/166822
11:58:38 <Cale> Benji__: Oh, and make sure to configure your text editor to convert tabs to spaces for you
11:59:08 <Cale> Benji__: Otherwise, you'll be in for some confusing issues when the compiler treats tabs as aligning to the next multiple of 8 spaces
11:59:18 <Cale> (and your editor presumably doesn't)
11:59:55 <jmcarthur> Funny how the tabs vs. spaces debate is much less intense when your language has layout sensitive syntax.
11:59:55 <gio_> Cale: hi
12:00:01 <Cale> hi
12:00:21 <gio_> Cale: could you please see pm
12:00:24 <gio_> ?
12:00:29 <Cale> (do you ever say anything other than hi? I have a bunch of private messages from you which just say hi over and over)
12:00:54 * Clint squints.
12:01:06 <jmcarthur> * Squint clints.
12:01:25 <Clint> jmcarthur: hi
12:02:04 <puregreen> * Sclint quints.
12:02:21 <Clint> things are spiraling out of control
12:02:23 <gio_> Cale: there is more then 
12:02:27 <gio_> hi
12:04:30 <mauke> gio_: hi
12:06:26 <JohnnyL> Cale: Looking at the Reflex video now. thank you! also compiling ghcjs.
12:06:41 <Cale> JohnnyL: Oh, you can save yourself the trouble of compiling it
12:07:06 <Cale> https://github.com/reflex-frp/reflex-platform -- if you grab this repo, and run ./try-reflex
12:07:18 <Cale> it'll download everything you need and drop you into a shell with ghcjs all set up
12:11:44 <gio_> Cale
12:11:50 <gio_> mauke: hi
12:12:22 <gio_> mauke: i have a some problem with types... and Cale is an expert about it :)
12:12:48 <Cale> pls no
12:13:04 <mauke> yeah, annoying one specific user is always a good plan
12:14:25 <Cale> Yeah, it's much better if you'd just ask your questions in an appropriate channel. Maybe someone else in ##typetheory would be interested
12:14:33 <quchen>  /msg Cale is a channel about Cale. #haskell is a channel about Haskell.
12:14:43 <yellow_apple> @pl (\x y z -> snd $ y $ x $ z)
12:14:44 <lambdabot> ((snd .) .) . flip (.)
12:15:30 <JohnnyL> Cale: try-reflex wants nix.
12:15:40 <Cale> Yeah, that's right
12:16:04 <Cale> It should install nix itself if you don't have it
12:16:10 <JohnnyL> no it errors out.
12:16:13 <Cale> hm
12:16:18 <Cale> What's the message you get?
12:17:52 <JohnnyL> Cale: 
12:17:58 <JohnnyL> reflex/reflex-platform-develop/common-setup
12:18:14 <JohnnyL> p.sh: line 66: /root/.nix-profile/etc/profile.d/nix.sh: No such file or directory
12:18:23 <JohnnyL> -p
12:18:48 <Cale> wait, are you running the script as root?
12:19:30 <JohnnyL> Cale: no
12:19:36 <Cale> okay, hm
12:19:43 <JohnnyL> at first i did though.
12:20:10 <JohnnyL> sorry, wrong paste.
12:20:27 <JohnnyL> reflex/reflex-platform-develop/common-setup.sh: line 66: /home/john/.nix-profile/etc/profile.d/nix.sh: No such file or directory
12:21:03 <puregreen> is -XAnonymousSums available in GHC 8?
12:21:36 <geekosaur> last I saw it was still a proposal in the design phase
12:22:12 <Cale> JohnnyL: I'm going to ask Ryan if he's ever seen that
12:23:45 <JohnnyL> Cale: okay.
12:24:19 <JohnnyL> Cale: I am using Linux.
12:24:44 <ryantrinkle> JohnnyL: did you have nix installed before running try-reflex?
12:27:10 <JohnnyL> ryantrinkle: no and it's still not installed.
12:27:31 <ryantrinkle> JohnnyL: can you try getting rid of /nix?
12:27:37 <JohnnyL> sure
12:35:08 <Cale> JohnnyL: any luck?
12:36:48 <gio_> does polimorfism helps to give variable universal type? i.e. to be it instantiable by any terms?
12:37:07 <mauke> u wot m8?
12:37:15 <johnw> huh?
12:37:27 <gio_> m8?
12:37:32 <gio_> what is that?
12:37:37 <Welkin> mate
12:37:47 <Welkin> it's what the aussies call each other
12:37:51 <Welkin> and the kiwis
12:38:00 <Welkin> therei s a joke that it is short for "inmate"
12:38:03 <Welkin> polandball
12:38:16 <gio_> ok
12:38:20 <gio_> :)4
12:39:06 <guillaum1> Why a function such as "inc v = modifySTRef' v (+1)" is responsible for 20% of the %alloc of the profiling ? The STRef stores a `Int`.
12:40:43 <quchen> Hard to say without seeing the code.
12:41:13 <quchen> Nested functions require a heap allocation, so there's that. But that's not really special about this definition, compared to what other Haskell looks like.
12:41:51 <johnw> maybe 'v' is a thunk retaining a large amount of memory, so that 'inc v' retains it as well?  Not entirely sure why it would be assigned to that cost center, though
12:42:23 <circ-user-ZHfj9> I wounder, how do you map (f ~~~ g) worldX to the function declaration (~~~) :: (IO b) -> (b -> IO c) -> IO c
12:42:24 <circ-user-ZHfj9> http://stackoverflow.com/a/2488852/6267925
12:42:37 <quchen> You could try defining `inc = let plusOne = (+1) in modifySTRef' v plusOne`, but I doubt GHC doesn't already do that on its own.
12:44:24 <lvella> hi, what is the easiest way to make an haskell compiler for Ethereum?
12:44:45 <lvella> are you aware of TheDAO attack yesterday?
12:45:37 <guillaum1> quchen: indeed, that's the (+1) which allocate, I can set it as a top level writting "add1 = (+1)" and I can see now that the cost center which allocate is now "add1"
12:45:38 <jle`> many some sort of intermediate compiler to solidity, or a dsl
12:46:20 <jle`> or i guess it might be possible to compile directly to the EVM
12:46:30 <jle`> or at leasthave a dsl to codegen for evm
12:46:36 <guillaum1> quchen: do you know if there is a way to remove that. I mean I just want to increment a STRef, this does not need an allocation (does it ?)
12:47:03 <quchen> guillaum1: What type is your addOne?
12:47:10 <quchen> Try making it monomorphic
12:48:07 <guillaum1> quchen: its "Int -> Int"
12:48:26 <quchen> Well then I'm out of ideas without seeing the code.
12:49:15 <nineonine> hi there !
12:49:22 <nineonine> I have question
12:50:04 <nineonine> can we say that immutability can be used to uniquely describe functional paradigm ?
12:50:17 <nineonine> or 
12:50:21 <johnw> I would say, "no"
12:50:45 <johnw> the "functional paradigm" is not accurately described enough for us to say certain things about the paradigm as a whole
12:51:13 <osager_> how to replace the value of certain element in a list?
12:51:16 <sinelaw> that's very loosely defined and depends on who you're talking to 
12:51:22 <nineonine> i see
12:51:48 <guillaum1> quchen: https://github.com/guibou/inversionsCount/blob/syntax/inversions.hs
12:52:37 <nineonine> so I had a talk with OOP guy and he used this statement to describe functional PL
12:52:51 <guillaum1> (.<=.), at, (.-), inc, (+=) takes roughly 50% of the alloc for reasons that I don't understand.
12:52:58 <nineonine> so we is not correct to some extent ?
12:53:01 <nineonine> he*
12:53:34 <johnw> osager_: usually you build up a new list after dropping the element you don't want; lenses give you a very succinct way to express this, or you could write a set_nth function
12:53:52 <osager_> ok
12:54:36 <mauke> osager_: if you mean by index, splitAt may help you
12:54:50 <mauke> but if you need that operation a lot, that's a sign that you shouldn't use a list
12:54:52 <osager_> mauke, no i dont mean that
12:54:59 <johnw> nineonine: I usually here that referred to as "pure functional", but that's still an imprecise term
12:55:17 <EvanR> functional paradigm and oop paradigm are like justice league and council of doom, each has a multitude of aspects, and each one doesnt define the whole thing
12:55:19 <quchen> nineonine: No. OOP with only value objects is not FP, but everything's immutable.
12:55:25 <osager_> mauke, i want to replace the 3rd element by a new value,for example
12:55:31 <mauke> that is by index
12:55:50 <EvanR> and also the members change from issue to issue randomly
12:56:07 <quchen> nineonine: "Using functions a lot" uniquely describes the functional paradigm. Like "functional paradigm", it's a very imprecise thing.
12:56:30 <EvanR> i use functions a lot in C
12:56:40 <quchen> There are some recurring themes in FP, such as a focus on immutability, first-class functions, and what not. But none of those are unique.
12:56:56 <nineonine> got it !
12:57:12 <quchen> EvanR: C with lots of function pointers is pretty functional. It's not what I'd choose for FP, but hey, you can do it. Likewise, you can do objecty things in Haskell ;-)
12:57:15 <nineonine> thanks to all who contributed answering this !
12:57:15 <johnw> also, tending to build programs up from composition
12:57:32 <nineonine> but
12:57:41 <nineonine> did immutability come from FP ?
12:57:46 <quchen> johnw: That's hard to formalize as well. Composing objects is also a form of composition, and dependency injection is similar to using parameters in FP.
12:57:55 <nineonine> historically 
12:58:01 <EvanR> composition is a popular thing and jargon in oop
12:58:21 <quchen> Immutability is also an important part of a compiler optimization technique/approach called SSA.
12:58:22 <EvanR> its just nicer in FP
12:58:24 <johnw> I mean, composition of functions as in "f . g"
12:58:39 <quchen> SSA is particularly popular with non-immutable languages.
12:59:04 <quchen> johnw: Sure, I understand. But it's passing data through two things, and that's something one could argue OOP does just as well.
12:59:27 <quchen> What I mean is that it's hard to "uniquely characterize" FP.
12:59:31 <johnw> no argument here, it's all imprecise enough for us to say lots of stuff
12:59:35 <quchen> It's not a useful term for a formal description.
12:59:45 <sinelaw> nineonine: in a way immutability comes before mutability. the name 'variable' in math means a label for something immutable. 
13:00:10 <sinelaw> So historically, mutability was the new thing, not immutability
13:01:08 <nineonine> what i was trying to ask is that which paradigm incorporated that technique first
13:01:27 <johnw> I guess the math paradigm incorporated it first :)
13:01:33 <nineonine> :)
13:01:39 <EvanR> yes pythagoras just kept using new spaces on the tape, and turing came along and revolutionized, allowing you to go back and overwrite characters. he must have been inspired by typewriters
13:02:19 <nineonine> so i am referring to wikipedia page about "Immutable object"
13:03:42 <sinelaw> That's from object-oriented
13:03:52 <nineonine> and it doesn't say anything about connections between paradigms and that technique
13:04:07 <sinelaw> nineonine: Why do you worry about it so much?
13:04:16 <nineonine> im just curious
13:04:26 <nineonine> In object-oriented and functional programming, an immutable object (unchangeable[1] object) is an object whose state cannot be modified after it is created.
13:04:55 <nineonine> however If i read haskell wiki
13:05:05 <nineonine> specifically
13:05:06 <nineonine> https://wiki.haskell.org/Functional_programming
13:05:16 <johnw> it's fairly safe to model mutability in the presence of immutability, using arguments; but it's harder to guarantee immutability without language features that allow you to hide implementation details
13:05:29 <sinelaw> In object oriented programming, objects are an encapsulation of both mutable state and methods (functions) that alter that state. So 'immutable object' is special because you can't change it's state by passing messages to it.
13:05:33 <nineonine> immutability is considered here to be one if the functional languages features
13:06:12 <sinelaw> nineonine: But if you just talk about values, immutability is straightforward: 3 is just 3
13:07:15 <sinelaw> And "in FP", we more often talk about "just values"
13:07:16 <EvanR> we dont yet have the technology to modify the value of 3
13:07:25 <sinelaw> EvanR: Ruby has it
13:07:28 <EvanR> lol
13:07:30 <nineonine> :D
13:08:10 <EvanR> Q might be able to do it
13:08:42 <godel> is there some variation of    iterate :: (a -> a) -> a -> [a]
13:08:45 <nineonine> anyways, I am satisfied with the answer I was given , thank you !
13:08:52 <godel> that stops when new elements are not changed?
13:09:00 <godel> when it stabilizes
13:09:16 <quchen> If you woke me up at night asking me "quick, what is FP" I'd probably say "focus on function composition, functions as first-class arguments, immutability, equational reasoning, denotational over operational semantics".
13:09:35 <quchen> Like 4 in the morning.
13:09:47 <johnw> sinelaw: lol!
13:10:05 <quchen> In particular the last point is mostly a consequence of the others, but key to why I like Haskell.
13:10:15 <johnw> that last point is the most significant for me too
13:10:37 <Zekka> Well, there's a lot of allegedly functional languages that still care a lot about what actually happens
13:10:46 <godel> until   does kind of what I want
13:10:56 <quchen> Zekka: For some value of "actual".
13:10:59 <Zekka> You could argue the big difference between a Prolog and a SQL is the well-defined evaluation order
13:11:21 <Zekka> I think most people would still use the term FP for Prolog though
13:11:43 <Zekka> Yeah, "what actually happens" was vague, sorry -- I was trying to be inclusive but I was really hinting at "evaluation order, order of side effects"
13:12:08 <quchen> Some people think Javascript is functional. Some people say Haskell isn't purely functional. There is a lot of room for interpretation.
13:12:16 <EvanR> what actually happens though... being vague... thats is good insight
13:12:33 <EvanR> the C virtual machine isnt what actually happens either
13:13:01 <quchen> Zekka: The STG, which is what GHC maps Haskell to, has very clear evaluation order, for example.
13:13:07 <Zekka> I'm just being a jerk and saying I don't like it when people say "FP looks like [my favorite FP language]"
13:13:32 <Zekka> quchen: Useful to know, although I don't know much about intermediate representations of Haskell. Bear in mind that that's GHC, not Haskell
13:13:50 <quchen> And mapping Haskell to STG isn't even complicated. Tedious, but not complicated. Doing it in an efficient way is more difficult, of course.
13:13:59 <Zekka> for most Haskell programs you can do a whole lot to evaluation order without resulting in an incorrect program, but that's not true of most C programs, many Lisp programs, many Erlang programs
13:14:24 <Zekka> You can model that in Haskell but you can model anything in anything -- it's not a hard dividing line afaict
13:14:32 <quchen> Zekka: The unspecified evaluation order is a blessing for optimizing the code, I would think
13:15:03 <Zekka> quchen: Hey, I'm not saying it's bad or anything
13:15:13 <quchen> I didn't hear it that way
13:15:19 <quchen> I mean I didn't think you did
13:15:43 <geekosaur> fp's a programming style, not something a language possesses. it's about using functions in data-like ways (passing them to other functions, composing them, etc.) things like immutability are less important to my mind, although they can encourage fp style and enable compilers to optimize fp style code better
13:15:50 <Zekka> I just think it excludes a *lot* of technologies to say "FP is about focus on denotational semantics over operational semantics" when that usually means things like "we don't care about precise evaluation order"
13:16:23 <quchen> Zekka: Hence my 4-am-in-the-morning disclaimer :-þ
13:16:31 <Zekka> quchen: Point totally gotten!
13:16:52 <quchen> I'm a Haskell enthusiast, so all things considered I'll still be totally biased
13:17:12 <Zekka> It kinda seems like "FP" is a term that's had a ton of drift over time but if I were trying to be inclusive I'd probably say sometihng closer to what Geekosaur said
13:17:29 <quchen> That's not to say I'm not interested in other things, I really like Rust for example. And Idris, but that's Haskell++.
13:17:31 <dmiles> i am really not very good sometimes at defining things.. but interesting to hear that immutablity is not a requimirement of FP
13:17:39 <Zekka> some "FP" languages don't even have a feature called functions, or the scoping rules to pretend to have them, so it's not perfect, but it's probably pretty good
13:17:58 <quchen> Zekka: Such as? What's an FP language without functions?
13:18:00 <johnw> just say "immutable FP", and claim that that's its defining feature
13:18:08 <Zekka> quchen: Prolog
13:18:16 <quchen> Oh. I've never heard that one being called functional.
13:18:28 <Zekka> Prolog guys call it functional!
13:18:42 <johnw> I here it called a logic programming language, as in "pro" and "log"
13:18:43 <dmiles> (I consider Prolog functional .. but that is a style I use while writing prolog)
13:18:44 <tdammers> Python guys call python functional
13:18:50 <Welkin> lol
13:18:56 <Welkin> python is the farthest thing from functional
13:19:08 <Welkin> guido would go into a rage if he heard someone call it functional
13:19:12 <Zekka> FWIW Prolog enables you to pretend to have lambdas, stuff like that, and that's a common style feature
13:19:35 <tdammers> Welkin: I doubt that. Python has a lot of FP influence in it
13:19:43 <dmiles> And that pretending is 100% defiantily function
13:19:59 <EvanR> Professional Logic
13:20:01 <quchen> tdammers: Everyone and their grandmothers call their language functional, it's fashionable
13:20:04 <Welkin> tdammers: guido hates recursion and anything remotely functional
13:20:06 <tdammers> quchen: my point
13:20:06 <Zekka> It's a language that lets you work on abstract representations of operations
13:20:08 <dmiles> And that pretending is 100% defiantily functional programming (thats why i consider PRolgo to be FP when used that way)
13:20:10 <quchen> Map and filter are in? Better say it supports functional features!
13:20:12 <Welkin> lol
13:20:23 <Welkin> go on wikipedia and look at programming language categories
13:20:32 <Welkin> you will see many languages listed that are not functional
13:20:38 <Zekka> unfortunately, almost every programming language lets you operate on abstract representations of operations
13:20:39 <Welkin> but they claim to be
13:20:55 <tdammers> depends on your definition
13:21:05 <tdammers> by the strictest one, even Haskell doesn't qualify
13:21:08 <mauke> tdammers: http://fold.sigusr2.net/2010/03/guido-on-functional.html
13:21:42 <quchen> tdammers: Edwin Brady said that to me a week ago. It was tongue in cheek, but he still had a point.
13:21:47 * dmiles is in agreement with Zekka .. but why do some people consider prolog to not be a functional language ?
13:22:08 <tdammers> mauke: made perfect sense, until the last bit
13:22:12 <tdammers> > You can write reduce() in a few lines of Python. Not so in a functional language.
13:22:13 <lambdabot>  <hint>:1:24: parse error on input ‘in’
13:22:20 <mauke> tdammers: see also the comments at https://www.reddit.com/r/haskell/comments/lxoo0/guido_van_rossums_criterion_for_when_a_language/
13:22:27 <Zekka> It's not really expression-based or anything, and it doesn't have lexical scoping
13:22:39 <Welkin> functional programming is like pornography
13:22:46 <Welkin> no one has a definition of it
13:22:48 <quchen> Reduce over multiple line is a tough one in Haskell. You'd have to insert every syntactically correct line break in order to achieve that.
13:23:04 <Zekka> by "not expression-based" I mean that if you have two representations of a computation, you often can't nest their results by syntastically nesting their representations
13:23:23 <Zekka> by syntactically*
13:24:15 <Zekka> You still have an analogue of higher-order-functions, but you don't have higher-order functions to e.g. "get the value of each of these and add them together"
13:24:17 <tdammers> Welkin: it's actually pretty simple. A language that has functions is functional. The problem is clearing up the confusion between functions and procedures (a.k.a. "functions")
13:24:37 <tdammers> By a stricter definition, a language is functional when it *only* has functions
13:24:44 <tdammers> but that's a bit harsh
13:24:56 <EvanR> C
13:25:26 <EvanR> LC
13:25:45 <EvanR> FP is kind of old and crusty as a term
13:25:53 <Welkin> pedants like to argue over terminology
13:25:57 <dmiles> Zekka: ah yeah even though we can simulate these missing features i suppose we are simulating them.. and not having them by default
13:25:59 <Welkin> who cares what it's called though
13:26:08 <Nuxular> Can someone give me an example an instance of Applicative which cannot be made an instance of Monad (without breaking monad laws)? Or is it the case that you can always do this?
13:26:12 <Zekka> I mean, I mostly bring this stuff up to troll peopel who really like terminology
13:26:29 <tdammers> Welkin: it's not pedantic to consider functions (actual functions, not procedures) the core of functional programming
13:26:34 <Zekka> https://en.wikipedia.org/wiki/Joy_%28programming_language%29 <- this is another fun one
13:26:42 <Zekka> "In Joy, everything is a function that takes a stack as an argument and returns a stack as a result. " so it's forth
13:27:07 <dmiles> I sort of wanting to hear how to defend prolgo to be function.. since i want to put it on resume that i am functial programmer (that is the light hearted reason i care)
13:27:16 <tdammers> I wonder why they called it "Joy" and not "Agony"
13:27:21 <Zekka> ""binrec" is one of Joy's many recursive combinators, implementing binary recursion. It expects four quoted programs on top of the stack" <- or maybe it's functional the way Prolog is!
13:27:23 <dmiles> prolog to be functinal*
13:29:06 <dmiles> lately jobs i am interested in seem to mostly want haskell programmers.. probably becasue they want people that are not run of the mill
13:29:07 <EvanR> whats interesting is there are people who will indulge in terminology for its own sake, and others who will use the result of a meaningless use or mention of terminology to actually make decisions...
13:29:25 <EvanR> terminology as a skin, vs terminology as the actual substance at stake
13:29:42 <Zekka> https://en.wikipedia.org/wiki/FP_%28programming_language%29 <- I never worked with this one, but it looks suspiciously like it's more about manipulating terms (like Prolog) than about manipulating opaque things you can call (like Haskell)
13:29:54 <Zekka> but it would be a bad idea for me to make definite statements about it since I didn't ever use it
13:31:26 <dmiles> Zekka: yeah that wiki page is why i think prolog is FP sometimes
13:31:44 <EvanR> agreed i prefer functions to be expressions than opaque callable
13:31:50 <deech> Anyone know how to get the File Descriptor back out of a Handle? http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-IO-Handle.html#t:Handle
13:32:15 <geekosaur> @index handleToFd
13:32:15 <lambdabot> System.Posix.IO.ByteString, System.Posix.IO, System.Posix.ByteString, System.Posix
13:32:49 <deech> geekosaur: Thanks!
13:36:35 <deech> geekosaur: Unfortunately that function also closes and flushes the Handle.
13:36:39 <mcuramen> hello
13:37:03 <geekosaur> yes. what I've done is then used fdToHandle to get a new Handle, which does not invalidate the fd (because it uses the fd)
13:37:33 <deech> Ah, great. Thanks!
13:37:35 <geekosaur> you do have to be careful using both at the same time, though; doing so naively *will* cause you endless headaches
13:37:51 <geekosaur> which is why ghc makes it hard
13:38:09 <deech> geekosaur: Thanks for the tip!
13:38:32 <koala_man> is Data.Graph.Inductive.Graph a safe choice for building a graph or should I be looking at something else?
13:39:49 <geekosaur> C, perl. etc. all have the same caveats: handles are usually buffered, mixing them for output will result in odd interleaving, mixing for input won't know if something pushed back on the handle (that part may not apply to Haskell but most other handle abstractions allow 1 byte of readahead/pushback)
13:40:04 <hawk78> I have a doubt about type families: I have a <<class C a where type S a>>. I also have a <<data I a = I a>> and an <<instance C (I a) where type S (I a) = I a>>. How do I define an instance <<(Monad m, C c) => C (m c) where _ >> ?
13:41:11 <hawk78> I meant  <<instance (Monad m, C c) => C (m c) where _ >>
13:41:42 <glguy> Generally you wouldn't define such an instance
13:43:18 <hawk78> glguy: without type families it is possible to define that instance
13:43:36 <glguy> You shouldn't do it then, either
13:46:39 <glguy> The fact that this is a bad idea aside (because it's going to overlap with lots of other types, using the FlexibleInstances extension you could write
13:46:41 <glguy> 03instance (Monad m, C c) 07=> C (m c) 03where 03type S (m c) 07= S c
13:47:00 <glguy> I don't know what particular definition you actually had in mind for S in this case, however
13:50:47 <idev> what is is about haskel./idris that makes so much easier to write a js backend for idris than for haskell ?
13:51:16 <drdo> Probably strict evaluation
13:51:23 <hawk78> glguy: that gives an "Conflicting family instance declarations"  error 
13:51:37 <glguy> hawk78: Yeah, that's part of why this is a bad idea
13:52:52 <glguy> hawk78: Your typeclass instances should be for the form C (T a1 a2 ... an) where T is a type constructor and a1..an are type variables
13:53:10 <glguy> What you're doing is going to overlap with things as you're experiencing
13:55:36 <hawk78> glguy: what I wanted to get is something like: add  f :: Int -> a into the class and then add f = I . fromIntegral and f x = return $ f x into the two instances
13:56:38 <hawk78> But I would like to also be able to customize the types the instances use.
13:58:35 <hawk78> Basically I wanted the S instance for the monad instance to be the same as the S instance for the other instance.
13:58:46 <glguy> hawk78: You'll need one instance per type, you don't get to add one for "all monads"
13:58:59 <hawk78> :-(
13:59:39 <glguy> instance Monad m => C m -- doesn't mean that this instance is for all monads, it means it's for all types and also those types need to have a Monad instance
14:00:52 <glguy> In your case: instance Monad m => C (m c) -- says that it's the instance for all types m with kind *->* and c with kind * , and that when this instance is used that a Monad constraint will be added
14:01:17 <glguy> so then you can't have *any other* instances that match types of that shape
14:03:39 <hawk78> glguy: What do you mean by " when this instance is used that a Monad constraint will be added"
14:03:41 <hawk78> ?
14:03:59 <glguy> It's common for people to think that what you wrote means it will be used for things that are monads, only those things
14:04:28 <glguy> but it means that that instance will be used any time (m c) matches, and that when it is used it will be required that m is an instance of Monad
14:08:34 <hawk78> I think there is a missing piece in my understanding of typeclasses! Adding (Monad m) => adds a constraint, what happens for a matching (m c)  that does not obey the constraint? 
14:09:07 <chicken> how many years does it take to learn haskell?
14:09:15 <glguy> hawk78: you'll get a type error
14:11:38 <glguy> chicken: Definitely not more than 10
14:12:11 <thimoteus> at least 0
14:12:31 <glguy> I'm even more certain that 0 is a lowerbound than that 10 is an upper bound
14:13:07 <hawk78> With the constraint this typeclass can be applied to all (m c) that are monads but is defined for any (m c) and for those that are not monad is gives me a type error?
14:13:26 <glguy> hawk78: Yeah, and if you have an associated type synonym, you can't have any overlap, either
14:14:06 <hpc> chicken: i started learning haskell most of the way through those 10 years of learning programming, and it took about a month for me to go from nothing to IRC bot
14:15:07 <hpc> chicken: (it'll take more than a month to get comfortable enough with other things, and your time may vary)
14:15:52 <Cale> I think it took me about 2 months before I really felt like I could do useful things with it, and about a year to be comfortable.
14:17:10 <hawk78> glguy: what is the difference between a typeclass not beeing defined for an instance and beeing defined for the instance but not satifying the constraints?
14:17:30 <hpc> yeah, i wasn't comfortable with the irc bot i had after a month, it merely existed
14:18:02 <hpc> haskell has a very long tail though
14:18:12 <hpc> you'll spend years learning things you would never get to in most other languages
14:18:12 <hawk78> hpc: +1
14:19:13 <glguy> hawk78: The difference is that in one case an instance was chosen and that the constraints weren't satisfied. In the other no instance was chosen and you could add that instance if it made sense
14:20:44 <hawk78> So that means that you can't have two overlapping instances with different sets of constraints?
14:20:57 <glguy> Right. Constraints aren't used in instance selection
14:21:08 <hawk78> Ah! Eureka!
14:22:20 <hawk78> hpc: The longer I use/study haskell the more I understand I don't get it completely, and I've used it quite a lot also for non trivial things.
14:24:09 <hawk78> hpc: I fear beeing able to "code" something in haskell does not mean you really understand how it works.
14:26:45 <Zemyla> For some reason, I kind of cringe whenever I see "join" applied to an arbitrary monad.
14:27:01 <hawk78> glguy: is there a way to avoid writing so much duplicated code? If I have code that works for any monad can I generate specializations of that code for all (or a subset) of monads?
14:27:15 <dmj`> hawk78: what do you mean, "how it works" ?
14:27:27 <jmcarthur> hawk78: You can write code that is polymorphic over any monad, yes.
14:28:35 <hawk78> jmcarthur: over monads and monads only?
14:28:39 <glguy> hawk78: The first question will be to determine if you actually need to involve a new typeclass for whatever it is you're doing
14:28:52 <dmj`> Zemyla: you can define (>>=) in terms of fmap / join, so you might be using it more than you think :) 
14:29:11 <dmj`> @typ \m f -> join (fmap f m)
14:29:12 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
14:29:33 <dmj`> @typ ((\m f -> join (fmap f m)) :: Monad m => m a -> (a -> m b) -> m b)
14:29:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:29:37 <Zemyla> dmj`: Well, yes, but it feels like an inefficiency.
14:30:23 <jmcarthur> hawk78: Not only monads.
14:30:24 <dmj`> Zemyla: I'd check the core
14:32:06 <ahihi> cabal file path /Users/ahihi/Code/haskell/hämähäkki/hämähäkki.cabal does not match the package name it defines.
14:32:09 <ahihi> Please rename the file to: hämähäkki.cabal
14:32:10 <ahihi> that's helpful
14:32:25 <hawk78> dmj`: by "how it works" I mean that I can "use hasell"/"drive a car" even if I don't know "how it works".
14:33:29 <shijinabraham_> hi. Can someone help me with this code http://pastebin.com/GR7SxAdW
14:34:35 <glguy> mempty `mappend` x = x -- this shadows mempty
14:34:35 <dmj`> hawk78: --ddump-asm
14:35:02 <glguy> shijinabraham_: mempty `mappend` x = x   --  matches any two arguments and names the left argument mempty and the right argument x
14:35:09 <hawk78> glguy: I'm trying to develop hierarchical state machines in haskell... I want the user of the library to be able to define what the state is and to define what an action is.
14:35:11 <dmj`> shijinabraham_: are you referring to your comment here: -- how does this work???? (Just' 1) `mappend` mempty  :: Optional (Product Int)
14:35:12 <glguy> It doesn't mean:  x `mappend` y | x == mempty = x
14:35:34 <glguy> shijinabraham_: In this case you should write: Nothing' `mappend` x = x
14:35:52 <shijinabraham_> How do it work when --  x `mappend` mempty = x   is commended out
14:35:57 <hawk78> glguy: its an exercise I'm doing for "self improvement"
14:36:21 <glguy> shijinabraham_: It doesn't work correctly (as you intended)
14:36:39 <glguy> shijinabraham_: The reason you had to comment out the second one is that it will never match. the pattern above it will always match
14:37:22 <glguy> mempty is a pattern that matches anything and names it mempty
14:37:33 <glguy> It's not a pattern that only matches the previously defined thing named mempty
14:37:35 <hawk78> glguy: thus I don't need typeclasses, I'm not using a typeclass at the moment, I was just investigating.
14:37:44 <shijinabraham_> ok .. got it giguy
14:38:13 <shijinabraham_> i was assuming that since define mempty = Nothing', the pattern's below will be matched with Nothing' 
14:38:22 <hawk78> Most of the times I try using typeclasses I end up liking another approach best.
14:38:25 <shijinabraham_> thank you 
14:38:29 <glguy> shijinabraham_: Don't worry, you aren't the first one to assume that :)
14:39:11 <brandon_> hmm
14:49:38 <hexagoxel> ahihi: maybe the hämähäkkti.cabal is saved with some encoding that cabal does not understand?
14:52:15 <ahihi> it's HFS+, so filenames are UTF-16, but I suppose cabal might be tripped up by the normalization
15:00:34 <hexagoxel> i just noticed that for ansi-wl-pprint (<+>), (<$$>) and (<$>) have no (left or right) unit.
15:00:56 <hexagoxel> are there any good reasons to choose it over `pretty` ?
15:02:52 <hexagoxel> (apart from the things mentioned in the "prettier printer" paper)
15:03:05 <JohnnyL> glguy: where you just using ansi colors?
15:14:16 <siwica`> How would you normally define a datatype that can only take Int-values in certain ranges?
15:18:09 <fr33domlover> siwica`, you could use a smart constructor
15:18:26 <fr33domlover> that checks the value, but that will error only during runtime
15:18:28 <kadoban> siwica`: Put it in a module, don't export the data constructor, and export a function that checks it and converts (which should probably be something like :: Int -> Maybe MyRange)
15:19:27 <siwica`> I am thinking of whether using an error or Maybe. What would be prefered?
15:19:46 <siwica`> And what is the naming convention for smart constructors?
15:21:25 <circ-user-Df59r> how do I write this with fewer parens: liftA2 (+) (ZipList [1,2,3]) $ ZipList [1,2,3]
15:22:24 <shachaf> ZipList $ zipWith (+) [1,2,3] [1,2,3]
15:22:55 <glguy> ZipList [2,4,6]
15:23:04 <circ-user-Df59r> lol
15:23:11 <ahihi> (+) <$> ZipList [1,2,3] <*> ZipList [1,2,3]
15:23:27 <circ-user-Df59r> I mean, with the same semantics, though with diferent syntax
15:23:33 <circ-user-Df59r> I wonder about . and $
15:23:38 <circ-user-Df59r> and how to use them properly
15:23:59 <circ-user-Df59r> I guess I do not understand them properly
15:24:18 <circ-user-Df59r> I was trying something like liftA2 (+) $ ZipList [1,2,3] $ ZipList [1,2,3]
15:24:20 <ahihi> liftA2 f a b = f <$> a <*> b
15:25:06 <ahihi> what you tried means liftA2 (+) (ZipList [1,2,3] (ZipList [1,2,3]))
15:25:25 <circ-user-Df59r> yeap. :-(
15:26:04 <kadoban> siwica`: Depends what you want to happen when it doesn't fit, I guess. I'd default to Maybe. You can always write an unsafe version too I guess. Naming convention, maybe  mkThing, I use that. Not sure how common it is.
15:30:42 <jmcarthur> > zipWith (+) [1,2,3] [1,2,3]
15:30:44 <lambdabot>  [2,4,6]
15:30:56 <jmcarthur> Cheating?
15:31:25 <jmcarthur> oh right, need the ZipWith constructor, and somebody already beat me to it
15:31:30 <jmcarthur> I need to pay more attention.
15:43:41 <pyon> There's no function “Either a b -> Either b a” in the standard library?
15:45:11 <fr33domlover> pyon, nothing I'm aware of, but there is one in the 'either' package
15:45:18 <jmcarthur> :t Right ||| Left
15:45:19 <lambdabot> Either b c -> Either c b
15:45:36 <fr33domlover> cool!
15:45:46 <fr33domlover> :t |||
15:45:47 <lambdabot> parse error on input ‘|||’
15:45:50 <fr33domlover> :t (|||)
15:45:51 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
15:46:14 <jmcarthur> It's just a slightly more general version of either.
15:46:18 <jmcarthur> :t either Right Left
15:46:19 <lambdabot> Either b a -> Either a b
15:47:00 <fr33domlover> I use functions from Control.Arrow often but I still haven't learned the theory behind arrows yet :P
15:47:37 <jmcarthur> I feel like the theory of Arrow was constructed top-down rather than the usual (from math, at least) approach of going bottom-up.
15:47:53 <jmcarthur> Generalized arrows feel a bit more (IMO) principled.
15:48:08 <jmcarthur> http://www.megacz.com/berkeley/garrows/
15:48:57 <jmcarthur> I mostly just use Arrow's instance for (->).
15:49:16 <jmcarthur> arr is the worst part.
15:49:36 <jmcarthur> It eliminates a lot of things that would otherwise be pretty nice instances.
16:17:22 <muesli4> Hi, so I recently upgraded to ghc-8.0.1, and now cabal (1.24.0.0) somehow ignores my setting for user-install (False), any idea what's causing this?
16:18:44 <maks__> museli4: terrible mistake to install ghc-8.0.1
16:19:06 <muesli4> maks__: I know, I already regret it for other reasons.
16:19:20 <maks__> muesli4: i think your best bet is to get rid of it and go back to ghc-7.*
16:19:31 <muesli4> maks__: Well, my distro is shipping it already.
16:19:48 <maks__> muesli4: it completely messed cabal for me and i couldn't get half of my stuff to compile...
16:20:07 <maks__> muesli4: what distro are you using, just curious?
16:20:14 <muesli4> maks__: Archlinux
16:20:30 <glguy> muesli4: the setting works for me using Cabal-1.24, so perhaps you have a typo or you're editing the wrong file
16:20:46 <glguy> GHC 8 or not should be irrelevant to this topic
16:21:20 <muesli4> glguy: I have the same file for (probably) years, additionally it complains about some wrong profiling option (since I enabled profiling).
16:21:47 <maks__> ghci
16:22:20 <glguy> muesli4: Well, that old file might now be incompatible with Cabal-1.24
16:33:18 <glguy> muesli4: You can use the "cabal user-config" command to see what cabal-install thinks of your configuration file
16:33:31 <glguy> cabal user-config diff, for example
16:34:09 <muesli4> glguy: That's useful.
16:51:37 <buglebudabey> is there a built in function that has the signature (Monad m) => [m a] -> [a], kind of like flattening the list?
16:52:20 <glguy> No, there can be no function like that
16:53:10 <glguy> sequence 07:: Monad m 07=> [m a] 07-> m [a]
16:53:13 <glguy> You can do that, though.
16:53:49 <buglebudabey> there can't? what about flat (Monad a : ms) = a : flat ms?
16:54:07 <buglebudabey> flat [] = []
16:54:33 <glguy> I don't know of any Monad data constructor as used in your definition of flat
16:55:10 <buglebudabey> so you saying i can't have that function with a list of Maybe values?
16:55:19 <buglebudabey> and if its Nothing just skip it?
16:55:30 <glguy> You can write a function :: [ Maybe a ] -> [a]
16:55:36 <glguy> and it would work for Maybe, sure.
16:55:50 <glguy> You can't write a function that works for all Monad instance, however, unless you did something like:
16:55:58 <glguy> const [] 07:: Monad m 07=> [m a] 07-> [a]
16:56:11 <buglebudabey> gotcha
16:56:12 <buglebudabey> thanks
16:59:06 * hackagebot generic-deriving 1.10.5 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.5 (ryanglscott)
17:09:07 * hackagebot exp-pairs 0.1.5.0 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.1.5.0 (Bodigrim)
17:16:46 <romildo> Is there a function in the libraries similar to group that groups all equal elements of a list, even when they are not consecutive?
17:17:13 <mauke> group . sort
17:19:38 <romildo> mauke, without unnecessarily reordering the elements
17:19:58 <shachaf> How would it do that?
17:22:20 <mauke> define "unnecessarily"
17:24:02 <romildo> groupBy' (\(a,_) (b,_) -> a == b) [(10,'x'),(10,'y'),(5,'p'),(10,'a'),(5,'z')]    would give   [[(10,'x'),(10,'y'),(10,'a')],[(5,'p'),(5,'z')]]
17:24:42 <johnw> > nub $ (\xs -> map (\x -> filter (== x) xs) xs) [1,2,5,1,4,3,2]
17:24:43 <lambdabot>  [[1,1],[2,2],[5],[4],[3]]
17:25:03 <glguy> > reverse <$> M.fromListWith (++) [ (k, [k]) | k <- [(10,'x'),(10,'y'),(5,'p'),(10,'a'),(
17:25:04 <lambdabot>  <hint>:1:88:
17:25:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:25:19 <glguy> > reverse <$> M.fromListWith (++) [ (k, [k]) | k <- [(10,'x'),(10,'y'),(5,'p'),(10,'a'),(5,'z')] ]
17:25:20 <lambdabot>  fromList [((5,'p'),[(5,'p')]),((5,'z'),[(5,'z')]),((10,'a'),[(10,'a')]),((10...
17:25:35 <glguy> > reverse <$> M.fromListWith (++) [ (fst k, [k]) | k <- [(10,'x'),(10,'y'),(5,'p'),(10,'a'),(5,'z')] ]
17:25:37 <lambdabot>  fromList [(5,[(5,'p'),(5,'z')]),(10,[(10,'x'),(10,'y'),(10,'a')])]
17:25:43 <johnw> romildo: ^^
17:25:45 <glguy> You could go with something like this
17:26:10 <glguy> > reverse <$> M.fromListWith (++) [ (fst k, [snd k]) | k <- [(10,'x'),(10,'y'),(5,'p'),(10,'a'),(5,'z')] ] -- ok, last fix...
17:26:11 <lambdabot>  fromList [(5,"pz"),(10,"xya")]
17:27:18 <maks__> romildo: why not first sort and then use group ?
17:27:31 <johnw> maks__: he wants the ordering to be stable
17:30:00 <kadoban> sort is stable though
17:30:25 <kadoban> Or sortBy if they want equality determined some other way than the usual.
17:30:41 <kadoban> s/equality/order/
17:33:30 <circ-user-AQzCn> in haskell there are these typeclasses
17:33:39 <circ-user-AQzCn> and laws that they have to obey to
17:34:03 <circ-user-AQzCn> i wonder if these laws could be coded in the typeclass definitions
17:34:17 <reinstra> Hi all
17:34:42 <johnw> I meant, he wants the ordering of the original list preserved
17:34:45 <johnw> see my example
17:34:55 <circ-user-AQzCn> like... when one would declare an instance of functor fmap id = id
17:35:18 <circ-user-AQzCn> and all that
17:35:31 <johnw> circ-user-AQzCn: there have been many different approaches to doing that, but none of them really work in Haskell itself yet
17:35:52 <circ-user-AQzCn> :-)
17:36:13 <circ-user-AQzCn> what name do they give to that
17:36:15 <circ-user-AQzCn> ?
17:36:17 <shachaf> romildo: https://hackage.haskell.org/package/discrimination-0.2.1/docs/Data-Discrimination-Grouping.html does what you wan, though it might be too complicated/overkill.
17:36:46 <johnw> circ-user-AQzCn: do you mean, what would you google for to find those efforts?
17:36:56 <shachaf> (It does linear-time grouping, not Ord-based.)
17:37:21 <circ-user-AQzCn> yeap johnw.
17:37:41 <buglebudabey> I have a big AST for parsing Lisp and one of my constructors in my datatype is "If { predicate :: Expr -> Bool, ifTrue :: Expr, ifFalse :: Expr }" but I get an error saying theres no Show instance for predicate, can I create an instance without taking away the (deriving Show) from the whole AST?
17:37:49 <johnw> circ-user-AQzCn: for example, https://www.quora.com/Would-it-be-possible-for-a-Haskell-compiler-to-enforce-the-different-laws-governing-functors-applicatives-monoids-and-monads
17:38:01 <circ-user-AQzCn> thank you
17:38:55 <muesli4> buglebudabey: No, since you can't derive an instance for a function.
17:39:07 <lpaste> koz_ pasted “Can this be written better?” at http://lpaste.net/166860
17:39:28 <buglebudabey> so how can I derive show for the rest of my constructors but not for that one? muesli4 
17:39:47 <buglebudabey> without having to manually do it
17:39:49 <buglebudabey> for each one
17:39:53 <koz_> buglebudabey: You derive show for a type, not a constructor IIRC.
17:39:59 <koz_> s/show/Show
17:40:25 <muesli4> buglebudabey: You can't. Why does your predicate even have to be a function?
17:41:36 <glguy> koz_: You're getting too aggressive with the . and $, (evaluated ==) . S.singleton . Just $ False  is just   evaluated == S.singleton (Just False)
17:42:08 <glguy> It's OK to apply functions directly
17:43:19 <koz_> glguy: Yeah - I guess I went a bit overboard there. :P
17:43:34 <glguy> koz_: and you can make a function that does what the guards for Form and Clause do
17:44:21 <koz_> glguy: Yeah, that makes sense actually - it'd save a lot of rewriting.
17:45:22 <buglebudabey> muesli4 	i guess it doesn't, but when i parse "(if (< x y) 2 0)" then i'd like it to go into my datatype as If (\x y -> x < y) 2 0
17:45:57 <buglebudabey> or maybe if I parse "(if (< 0 1) "yes" "no")" would be If True "yes" "no"
17:46:56 <behzad-nouri> i have this haskell code which runs slow; so i tried to profile it using -prof -fprof-auto. but then the code compiled with profiling flags runs ~20 times faster! what could possibly be the reason?
17:48:54 <jmcarthur> I don't know what to believe about performance anymore. I ran into a major performance regression (a 3x slowdown) in a non-Haskell program recently that turned out to be because I had reformatted the code.
17:49:09 <jmcarthur> And the reason, it turns out, it not crazy.
17:49:18 <jmcarthur> A bit sad, perhaps.
17:49:24 <jmcarthur> s/it/is/
17:50:06 <muesli4> buglebudabey: Go into your datatype? I would assume you parse an Expr, which you evaluate in another part (the interpreter or code generator). That's the most logical way to me, and this way the compiler can easily derive the Show instance for you, assuming Expr has one.
17:50:10 <mauke> jmcarthur: how is that not crazy?
17:50:52 <buglebudabey> Expr has one, all of them were showing correctly until i changed the predicate from an Expr into Expr -> Book
17:50:54 <jmcarthur> mauke: I mean the history that led to it doesn't seem crazy... The compiler was including line numbers in the generated names of anonymous functions, which affected their ordering in some hashtable, which affected the code layout, which affected the instruction cache.
17:50:55 <buglebudabey> Bool*
17:51:29 <mauke> jmcarthur: wow
17:51:34 <jmcarthur> mauke: The questionable part is that the ordering in the hashtable affected code layout, but it's not terribly surprising.
17:53:03 <muesli4> buglebudabey: I know. But it is impossible to Show functions. How would you distinguish between (* 2) and (\x -> x + x)? 
17:53:18 <behzad-nouri> jmcarthur: wow! and how did you figure that out?
17:53:32 <buglebudabey> I understand, it's alright I changed it back into something that can be shown
17:53:39 <jmcarthur> behzad-nouri: Lots of trial and error and speculation and discussion with compiler devs.
17:54:13 <behzad-nouri> jmcarthur: what lang was it?
17:54:19 <jmcarthur> It was OCaml.
17:54:57 <jmcarthur> Not that it matters. This sounds like the kind of thing that could happen in any language.
17:58:29 <behzad-nouri> jmcarthur: so any suggestion how can i figure out why adding -prof -fprof-auto flags makes the code 20 times faster? i mean what could possibly be the reason?
18:08:44 <buglebudabey> are Integers and Doubles part of the same datatype?
18:09:19 <kadoban> buglebudabey: No? They're separate types completely.
18:10:18 <buglebudabey> So there's no way to make a list of "numbers" that can include ints and doubles
18:10:47 <koz_> buglebudabey: It depends on what you'd want to do with said list.
18:11:19 <koz_> Also - how much precision do you need? You can have Rationals pull double-duty in this way if you know how much precision you're after.
18:12:06 <kadoban> buglebudabey: You could use Scientific or Rational, both of which can encode the same values as both Double and Integer (probably not technically true, Double is wacky)
18:12:09 <buglebudabey> I have a data type Op that can be Add [Int], but it can also be Add [Double] or Add [String]
18:12:30 <geekosaur> consider multiple constructors
18:12:34 <buglebudabey> I want to make a function that will extract the list and fold it into a single value
18:13:04 <geekosaur> well, per type, but come to think of it that gets noisy fast with that layout. I'd abstract the op, probably...
18:13:08 <koz_> buglebudabey: data Op = AddI [Int] | AddD [Double] | AddS [String] ?
18:13:45 <buglebudabey> koz geekosaur id like to avoid making 12 constructors, because I need one for Mul, Div, and Sub as well
18:14:26 <kadoban> data Value = I Int | D Double | S String -- ?
18:14:32 <geekosaur> might try a different factoring of your Op then. but what works there depends on what exactly you're after
18:14:45 <kadoban> Though working with that is going to be a little tedious, and maybe not correct.
18:14:53 <buglebudabey> alright, i'll see what works best
18:14:54 <buglebudabey> thank you
18:44:42 <pyon> fr33domlover: sorry for the late response, but thanks
18:59:10 * hackagebot deriving-compat 0.2.1 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.2.1 (ryanglscott)
19:17:41 <Choups> hi guys
19:19:10 <Choups> any1 ever eard of Sakai Learning Management System? more expecifically Sakai 10.5? not the latest version.
19:19:11 <Choups> trying to get lucky but im really off my usual place any help/hints/tips?
19:21:02 <shachaf> Does it have anything to do with Haskell?
19:24:49 <Choups> nope
19:24:56 <Choups> sorry
19:24:59 <Choups> wrong channel
19:28:28 <glguy> :t ()
19:28:29 <lambdabot> ()
19:30:54 <EvanR> agreed
20:13:38 * maks bored
20:14:13 * hackagebot scc 0.8.2.4 - Streaming component combinators  https://hackage.haskell.org/package/scc-0.8.2.4 (MarioBlazevic)
20:23:13 <mjrosenb> @hoogle IO a -> (b -> IO a)
20:23:14 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
20:23:14 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
20:23:14 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
20:23:59 <mjrosenb> @hoogle IO a -> [b] -> IO [a]
20:23:59 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:23:59 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:23:59 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
20:24:13 <mjrosenb> guess not.
20:25:07 <mjrosenb> actually, I bet I want const.
20:29:13 * hackagebot canteven-log 0.3.0.3 - A canteven way of setting up logging for your program.  https://hackage.haskell.org/package/canteven-log-0.3.0.3 (taphu)
20:29:53 <maks> > print "hi"
20:29:55 <lambdabot>  <IO ()>
20:30:14 <maks> @info finally
20:30:14 <lambdabot> finally
20:30:22 <maks> @info scanl
20:30:22 <lambdabot> scanl
20:32:29 <geekosaur> there's no @info
20:32:46 <geekosaur> @info do a; b -- it edit corrects to @undo
20:32:46 <lambdabot> a >> b
20:34:14 <mjrosenb> geekosaur: that seems worse than saying "command not found: @info"
20:34:39 <mjrosenb> although, I guess in general, lambdabot shouldn't reply when people aren't actually talking to it
20:34:54 <mjrosenb> e.g. when people start using @ to attempt to identify people
20:35:22 <maks> does the lambdabot support stuff like :t and :k from ghci?
20:35:24 <geekosaur> if it were my bot I'd have it at least say something about what it actually runs in that case... but not mine, and not my decision
20:35:34 <geekosaur> it does :t and :k but not :info
20:35:40 <geekosaur> ad not other :-commands
20:36:32 <maks> @t print
20:36:33 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
20:36:36 <maks> :t print
20:36:37 <lambdabot> Show a => a -> IO ()
20:36:39 <maks> ok
20:36:54 <maks> :k Bool
20:36:55 <lambdabot> *
20:36:59 <maks> great
20:38:21 <geekosaur> both of those are available as @-commands, but you can't use just one letter for them. @type and @kind. (I think you can abbreviate to @ty and @ki)
20:46:57 <maks> thanks geekosaur
20:59:06 <buttons840> I have a question about how valueB works in reactive-banana: http://stackoverflow.com/questions/37902800/how-does-valueb-work-it-always-returns-the-same-value
20:59:44 <buttons840> valueB always seems to return the same value, although I expected it to differ over time
21:01:41 <EvanR> :t valueB
21:01:42 <lambdabot> Not in scope: ‘valueB’
21:02:17 <EvanR> MonadMoment m => Behavior a -> m a
21:02:34 <Geraldus_> Hi folks!
21:02:47 <mjrosenb> buttons840: valueB just fetches the value at that point in time
21:03:11 <mjrosenb> buttons840: since you call valueB when the program is initialized, you only get the initial value.
21:03:59 <mjrosenb> the variable that you labeled 'behavior' doesn't have type Behavior String.
21:04:25 <Geraldus_> I'm trying to run Persistent with logging.  I have successfully implemented it with runNoLoggingT, but now I want to enable logging.  Likely I have to define my custom logging function. 
21:05:50 <buttons840> mjrosenb: your right, behavior has the type string in this case
21:06:32 <Geraldus_> I can't find a way to turn LogStr into String.  If there is no way to do this, how can I actually log something in my custom function?
21:07:15 <buttons840> mjrosenb: so i'm using valueB wrong; where would I use valueB? it has to be used inside of Moment or MomentIO
21:08:07 <Geraldus_> should I use `monadLoggerLog` for this purpose?
21:09:39 <geekosaur> so it looks like monad-logger gets LogStr from fast-logger, which has http://hackage.haskell.org/package/fast-logger-2.4.6/docs/System-Log-FastLogger.html#v:fromLogStr
21:10:03 <mjrosenb> buttons840: more or less the only time that I use valueB is when I want to get the initial value of a Behavior
21:10:18 <Geraldus_> geekosaur: Oh, thanks for pointing this out!  I missed it
21:10:43 <mjrosenb> I suspect you can also use it inside of your reactimate function to get a value, but I usually just use the applicative stuff to get it.
21:11:28 <buttons840> mjrosenb: i don't think you can use it in reactimate, because the reactimate function is not in the Moment monad
21:12:00 <buttons840> rather, the function you pass to reactimate is not in the monad
21:12:59 <buttons840> mjrosenb: valueB must be useful for more than just getting the initial value; if that's all it can do you could replace it just with hard coded literals couldn't you? (i guess you said that's all you have used it for, not all it can be used for)
21:13:11 <mjrosenb> buttons840: oh right, sorry, it has been a while since I've used ReactiveBanana
21:13:21 <mjrosenb> buttons840: it can also be used with the switch functions
21:13:33 <mjrosenb> which I still haven't gottent the hang of.
21:14:33 <mjrosenb> or at least, I assume that it can be.
21:18:05 <mjrosenb> :t mapM
21:18:06 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
21:18:16 <mjrosenb> gooood.
21:19:09 <buttons840> mjrosenb: i fixed the confusion about behavior vs behavior value in that question; the code is still effectively the same though, and thus behaves the same
21:19:41 <buttons840> as you say, behavior was just a plain old String, so I guess I shouldn't be expecting any special behavior from it
21:20:14 <buttons840> mjrosenb: have you been using other FRP frameworks?
21:21:04 <mjrosenb> right, what you want that last line to be is reactimate (print <$> behavior) <$ fireEvent
21:21:25 <mjrosenb> buttons840: no, that project has just been on hold for an annoyingly long time.
21:21:38 <mjrosenb> also, the work I've been doing on it is not in the FRP bits.
21:24:13 <buttons840> mjrosenb: in that line you wrote, is "behavior" a Behavior or a String? 
21:24:34 <mjrosenb> a Behavior
21:25:12 <buttons840> what is the type of print <$> behavior ?
21:25:32 <buttons840> obviously a -> IO () since that's what reactimate calls for
21:25:50 <buttons840> trying to understand that part
22:07:35 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
22:07:35 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
22:07:58 <crabmusket> jle`: cheers, I had looked at those but for example, repConstr still needs a DataType, which you get from dataTypeOf :: a -> DataType (needs a value)
22:08:10 <crabmusket> I'm thinking that what I want can't actually be done :p
22:08:24 <crabmusket> (trying to remake webroutes-boomerang without TH)
22:08:56 <mpickering> crabmusket: What are you trying to do exactly? 
22:09:21 <mpickering> Calling toConstr only makes sense if you have a value
22:09:32 <mjrosenb> buttons840: https://gist.github.com/b03a181568f43ed9af7c4634c36062de
22:09:52 <mpickering> Or to say it another way, the question, which constructor was used, only makes sense relative to a value
22:11:38 <crabmusket> mpickering: yeah that makes sense. the question I was trying to answer was not 'which constructor was used for a particular value' but 'does the constructor used for this value match the constructor that was associated with this specific HTTP route'
22:11:55 <crabmusket> that part, associating a constructor with a route, I was trying to do without, I dunno, passing dummy values around
22:11:58 <crabmusket> which I guess I could do
22:13:55 <buttons840> mjrosenb: when I run that it has the same behavior as my code in the stackoverflow question
22:14:06 <mjrosenb> really? :-(
22:14:09 <buttons840> mjrosenb: it prints "stepper initial value" twice
22:14:22 <buttons840> mjrosenb: at least I know i'm not alone in my confusion :\
22:14:55 <buttons840> i'm sure the author of reactive banana will answer the question eventually -- hes been quite active in the community for a long timme i think
22:15:42 <mjrosenb> oh nope...
22:16:12 <mjrosenb> the code that I'm using there just uses valueB to get the initial value of a behavior
22:16:26 <mjrosenb> since it was too onerous to pass in both the initial value and the behavior.
22:16:48 <buttons840> mjrosenb: there is also valueBLater, i doubt that gives any clues though
22:21:44 <buttons840> or we can always decide "it's a bug" and stop worrying about it :)
22:23:36 <buttons840> mjrosenb: i'll be leaving in 5 mins, just want you to know in case your trying to help me still
22:33:02 <hannofcart> I have just started reading "Learn you a Haskell...". In the chapter on Syntax in Functions, the author mentions a one liner saying: "Which reminds me, you can also pattern match in list comprehensions. Check this out:" and provides this code snippet: http://codepad.org/xJdJCW39 I can't seem to follow from the preceeding description of pattern matching why this snippet ALSO describes pattern matching. All I can seem to observe is a straightforward list
22:33:02 <hannofcart>  comprehension. Could one of you elaborate on the explanation a bit?
22:34:18 * hackagebot docvim 0.3.1.6 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.6 (wincent)
22:34:27 <shachaf> hannofcart: The pattern matching is the (a,b) <- part.
22:34:58 <shachaf> Rather than just a plain variable, like a <- ..., you're pattern-matching to get (a,b)
22:35:30 <glguy> and even just 'a' on its own on the left side of the <- is a "pattern" 
22:36:23 <shachaf> Well, sure.
22:39:18 * hackagebot quickcheck-text 0.1.1.0 - Alternative arbitrary instance for Text  https://hackage.haskell.org/package/quickcheck-text-0.1.1.0 (fractalcat)
22:41:31 <hannofcart> shachaf, so if I understand what you are saying, then would this: http://codepad.org/ZYdeEHSq be a way of writing the previous snippet *without* pattern matching?
22:42:12 <shachaf> Well, as glguy points out, a is still a pattern.
22:42:22 <glguy> hannofcart: No, that would just be matching against a less interesting pattern
22:42:39 <shachaf> I don't know that it's worth worrying about whether something is pattern matching or not.
22:43:14 <glguy> In list comprehension syntax the <- takes a pattern and a list of values and matches each of them against the pattern, skipping the ones that don't match
22:43:51 <hannofcart> glguy, ah! So all list comprehensions involve pattern matching. Correct?
22:44:11 <shachaf> Well, all list comprehensions that use <-.
22:44:22 <glguy> yeah, they can include guards and let bindings, too
22:44:39 <glguy> > [ (x,x) | let x = True ]
22:44:41 <lambdabot>  [(True,True)]
22:44:49 <glguy> > [ "weird" | False ]
22:44:50 <lambdabot>  []
22:44:52 <shachaf> Well, let bindings still have patterns.
22:44:57 <shachaf> But [x | b] doesn't.
22:45:27 <glguy> > [ "fine" | let ]
22:45:29 <lambdabot>  ["fine"]
22:45:50 <hannofcart> glguy, shachaf thanks for taking the time to explain. I understand now.
22:46:01 * glguy files that last example under "productive"
22:48:32 <shachaf> glguy: foiled again
22:48:41 <shachaf> glguy: I'll say that it's not a "binding" if it doesn't have "=".
22:48:44 <shachaf> It's just a let.
22:50:42 <shachaf> > do let in the cat
22:50:43 <lambdabot>  meow
22:52:50 <Rotaerk> heh
22:54:18 * hackagebot names-th 0.2.0.2 - Manipulate name strings for TH  https://hackage.haskell.org/package/names-th-0.2.0.2 (KeiHibino)
22:59:18 * hackagebot sql-words 0.1.4.1 - Simple idea SQL keywords data constructor into OverloadedString  https://hackage.haskell.org/package/sql-words-0.1.4.1 (KeiHibino)
23:04:23 <akfp`> how/where do I find an Arbitrary instance for HTML
23:09:19 * hackagebot HDBC-session 0.1.0.1 - Bracketed connection for HDBC  https://hackage.haskell.org/package/HDBC-session-0.1.0.1 (KeiHibino)
23:19:19 * hackagebot persistable-record 0.4.0.2 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.0.2 (KeiHibino)
23:19:21 * hackagebot text-postgresql 0.0.2.1 - Parser and Printer of PostgreSQL extended types  https://hackage.haskell.org/package/text-postgresql-0.0.2.1 (KeiHibino)
23:21:14 <Zemyla> Okay, I have a couple typeclass questions.
23:24:19 * hackagebot relational-query 0.8.2.3 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.2.3 (KeiHibino)
23:25:50 <Zemyla> Is there a typeclass for GADTs that can prove certain aspects about their type, like, for instance, class Provable c k where prove :: proxy c -> k a -> (c => r) -> r ?
23:33:42 <Cale> Zemyla: you could define that, but I don't know of one. Have you seen Ed Kmett's constraints library though?
23:34:05 <Zemyla> I have. It doesn't have what I'm looking for, though.
23:42:19 <jle`> that's neat
23:42:29 <mjrosenb> did ghc-8 disallow creating unfilled structs?
23:44:20 * hackagebot relational-schemas 0.1.3.1 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.3.1 (KeiHibino)
