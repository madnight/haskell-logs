00:01:51 <glguy> You should have 2.9 if you're on ghc 7.8, it comes with template Haskell
00:04:09 <glguy> You'll need to uninstall any copies of template-haskell you installed and revert to using the GHC provided one
00:04:47 <glguy> ghc-pkg list. Will show all of them
00:11:00 <Clint> how do i tell cabal install to just install the output of `cabal build` and not try to pull in newer versions of dependencies?
00:12:14 <glguy> Copy and register commands 
00:12:49 <Zemyla> () should be an instance of Num and Fractional.
00:12:51 <glguy> Install is a stand alone command,
00:12:59 <Zemyla> Also Floating.
00:13:59 <Clint> glguy: hrnfnfhghnfh
00:14:22 <glguy> OK 
00:16:40 <slingamn> complete output:
00:16:43 <slingamn> /usr/lib/ghc-7.8.4/package.conf.d
00:16:43 <slingamn> /home/shivaram/.ghc/i386-linux-7.8.4/package.conf.d
00:16:43 <slingamn>    template-haskell-2.11.0.0
00:17:01 <slingamn> `ghc-pkg unregister template-haskell` warns: "ghc-pkg: unregistering template-haskell would break the following packages: hackage-security-0.5.2.1 (use --force to override)"
00:17:41 <glguy> You'll need to install template Haskell via your package manager
00:18:25 <glguy> And unregister anything that depends on this wrong version
00:18:45 <glguy> Like hackage-security
00:19:14 <glguy> Using the ghc from your package manager works best when you only use your package manager
00:19:23 <slingamn> hmm
00:19:31 <glguy> Mixing with cabal install will be trickier
00:19:44 <slingamn> maybe it would be easier to move to a newer ghc?
00:20:03 <slingamn> i'm trying to build taffybar and in the past, i've needed to cabal-install some of its build-time dependencies
00:20:26 <slingamn> in particular, alex, happy, gtk2hs-buildtools
00:20:46 <glguy> Alex is probably in your package manager already
00:21:03 <glguy> Same for happy and gtk
00:21:05 <slingamn> yeah, but in the past, my package manager's alex hasn't been sufficiently up-to-date to build taffybar
00:22:04 <slingamn> so i think it might be safer to go in the direction of a bleeding-edge ghc
00:22:32 <glguy> If you want newer versions of things than are in your package manager then you'll probably want to avoid using it altogether for Haskell
00:23:17 <slingamn> also out of curiosity, how did you attribute the problem to template-haskell?
00:23:21 <mgsloan> Yup, best to do user local installs or manual installs
00:23:58 <mgsloan> (of ghc and related tools)
00:24:08 <glguy> ClassOpI is a template Haskell constructor and Template Haskell changes wildly between versions
00:25:07 <slingamn> oh hmm, i could tell cabal to install an older version of QuickCheck maybe
00:25:35 <glguy> The problem is still that you have the wrong template haskell
00:26:02 <glguy> Not quick check
00:26:31 <slingamn> oh
00:26:50 <glguy> Normal users always have the right template Haskell 
00:27:08 <glguy> But your distro split it into an optional package
00:27:58 <glguy> (which would work fine if you were using only packages provided by the distro)
00:28:19 * hackagebot hOpenPGP 2.5.1 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5.1 (ClintAdams)
00:48:11 <slingamn> i ditched ~/.ghc and ~/.cabal, installed alex etc. from my package manager, and now i'm trying again with `cabal install taffybar`
00:59:34 <tsahyt> I have a data structure wrapping around a graph and I'm doing a lot of somewhat involved lookups in that (the same ones very often). Since this turns out to be a bottleneck, I'd like to memoize these calls. What would be the best/most idiomatic way to go about this?
00:59:57 <Axman6> does the structure change often?
01:00:37 <slingamn> that didn't work:
01:00:39 <slingamn> cairo-0.13.3.0 failed during the configure step. The exception was:
01:00:39 <slingamn> user error (The package 'cairo' requires Cabal library version -any && >=1.24
01:00:39 <slingamn> but no suitable version is installed.)
01:01:16 <slingamn> (since my distribution is packaging 1.18.x
01:01:39 <slingamn> i should probably start from scratch with a local install of upstream ghc
01:03:50 <rydgel> slingamn: you can't use stack?
01:04:05 <slingamn> not familiar
01:04:09 <tsahyt> Axman6: no, only once
01:04:15 <slingamn> http://docs.haskellstack.org/en/stable/README/ this?
01:04:30 <tsahyt> Axman6: I build the structure and it remains unchanged from there on until termination of the program
01:04:34 <Axman6> tsahyt: would it be possible to build a lazy map of all possible queries?
01:04:36 <rydgel> slingamn: yep
01:04:54 <tsahyt> Axman6: technically yes
01:04:57 <slingamn> that's probably what i need
01:05:25 <tsahyt> so I would store the map with the structure then?
01:11:00 <rydgel> slingamn: you can try to clone the taffybar project and then run `stack install` inside
01:11:22 <rydgel> slingamn: you'll probably need some external lib to compile tho (X11 or related stuff)
01:11:47 <slingamn> rydgel, stack won't enable me to cabal-install it?
01:12:26 <rydgel> slingamn: stack use cabal underneath, but will choose the right packages/ghc versions for that particular project.
01:14:20 <rydgel> slingamn: also if the program you need is in Hackage, you might not even need to clone it actually
01:15:20 <rydgel> slingamn: something like `stack install taffybar` for instance will put the binary in ~/.local/bin/ by default or something similar
01:18:21 * hackagebot rison 1.1.0.0 - Parses and renders RISON strings.  https://hackage.haskell.org/package/rison-1.1.0.0 (martinvlk)
01:48:53 <slingamn> rydgel i'm in DLL hell with stack: `/home/shivaram/.stack/programs/i386-linux/ghc-7.10.3/lib/ghc-7.10.3/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory`
01:49:08 <slingamn> (my distribution packages libtinfo.so.6 instead)
01:50:54 <slingamn> hmm google says to remove ~/.stack and start again
01:53:16 <Freundlich> Is there a channel specific to category theory?
01:54:02 <merijn> Freundlich: #haskell? :p
01:54:17 <merijn> tbh, I take all my CT questions here
01:55:10 <Freundlich> If it's not considered off-topic too much, I might do that as well.
01:58:22 * hackagebot mustache 1.0.2 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-1.0.2 (justus)
02:01:10 <slingamn> https://github.com/commercialhaskell/stack/issues/2300
02:02:17 <tobiasBora> Hello,
02:02:32 <tobiasBora> Is there a shortcut to the code :
02:02:34 <tobiasBora> run $ (do
02:02:36 <tobiasBora>                  tmp <- generate $ probabilitySimplexArbitrary range1
02:02:38 <tobiasBora>                  return $ traceSShow "p=" tmp)
02:02:40 <tobiasBora> ?
02:03:11 <tobiasBora> (run here is Test.QuickCheck.run)
02:03:19 <tobiasBora> (run here is Test.QuickCheck.Monadic.run)*
02:04:24 <tsahyt> Is there an easy way to disable profiling for one module?
02:12:18 <merijn> tobiasBora: Well you can simply fmap "traceSShow "p=" over the other expression and avoid the bind/return
02:13:42 <tobiasBora> merijn: Ok thank you ! I am a bit confused between <$> and fmap, when should I use one or the other ?
02:14:21 <merijn> tobiasBora: They are literally identical
02:14:34 <merijn> tobiasBora: So you use whichever is more readable
02:14:48 <merijn> "f <$> x = fmap f x"
02:18:23 * hackagebot hoogle 5.0 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0 (NeilMitchell)
02:19:38 <tobiasBora> Ok thank you !
02:19:47 <tobiasBora> And I have a question with QuickCheck :
02:20:32 <tobiasBora> I did a generator that take as argument a parameter :
02:20:45 <tobiasBora> probabilitySimplexArbitrary :: (Ord y) => DiscretRange y -> Gen (ProbabilitySimplex y)
02:21:30 <tobiasBora> When I whant to generate two probabilitySimplex with the *same* range, I always use monadicIO, with something like prop_conjectureP51 :: Double -> DiscretRange Int -> Property
02:21:38 <tobiasBora> and then
02:21:40 <tobiasBora>   p <- run $ generate $ probabilitySimplexArbitrary range1
02:22:04 <tobiasBora> is there a better way to procced ?
02:23:23 * hackagebot stgi 1 - Educational implementation of the STG (Spineless Tagless  G-machine)  https://hackage.haskell.org/package/stgi-1 (quchen)
02:23:48 <tobiasBora> Hum... merijn your code doesn't work :
02:23:51 <tobiasBora> No instance for (Show (IO (ProbabilitySimplex Int)))
02:23:53 <tobiasBora>         arising from a use of ‘traceSShow’
02:24:02 <tobiasBora> with 
02:24:04 <tobiasBora>   p <- run $ (traceSShow "p=" <$> generate $ probabilitySimplexArbitrary range1)
02:25:03 <merijn> tobiasBora: That's because $ has lower precedence then $
02:25:42 <merijn> So it's bracketing as "(traceSShow "p=" <$> generate) (probabilitySimplexArbitrary range1)"
02:25:45 <merijn> eh
02:25:47 <merijn> $ has lower than <$>
02:26:18 <tobiasBora> So I can't avoir manuall bracketting ?
02:26:25 <tobiasBora> wit ((traceSShow "p=") <$> (generate $ probabilitySimplexArbitrary range1))
02:27:32 <merijn> You can just do "fmap (traceSShow "p=") . generate $ probabilitySimplexArbitrary range1
02:28:06 <tobiasBora> Ok thank you !
02:28:19 <chaosmasttter> or "traceSShow "p=" <$> generate (probabilitySimplexArbitrary range1)"
02:28:47 <merijn> true
02:42:18 <Zemyla> Why does Hint only use Strings as input, instead of maybe having the opportunity of giving it an AST of some kind?
02:47:25 <puregreen> Zemyla: because hint uses GHC API, and my guess is that the AST provided by GHC API is constantly changing, not really pleasant to work with, etc., and so nobody would want to generate it manually anyway
02:47:30 <puregreen> (but I might be mistaken)
02:48:13 <Zemyla> Well, maybe Hint could provide a different AST, possibly one that's typed like a GADT.
02:48:22 <tsahyt> is Data.Sequence really that much slower for sorting than lists or am I building my benchmarks wrong?
02:48:38 <merijn> Zemyla: In practice GADT typed ast are kinda annoying to do with
02:48:55 <merijn> tsahyt: If you're sorting large amount you'd want to use vectors anyway
02:49:18 <merijn> tsahyt: What are you trying to do?
02:49:29 <puregreen> Zemyla: and that would be a major undertaking for not much benefit
02:50:27 <tsahyt> merijn: I have a presorted queue of successor states for a search problem and since no new successors are added to the queue, psqueues or similar doesn't make much sense. So it all hinges on what's best for presorting
02:51:20 <tsahyt> merijn: also, how large is large in this context?
02:52:06 <merijn> 1000s? It also depends on how often you sort, I guess
02:52:34 <tsahyt> well that hinges a lot on the heuristic quality
02:52:44 <tsahyt> I'm gonna benchmark vectors as well
02:53:13 <tsahyt> but since the data starts out as a list, I guess the conversion step is something to take into account as well
02:54:21 <tsahyt> which raises the question whether I measure this right now in the benchmark or not. I use whnf (sortBy (comparing fst)) q at the moment, where q is defined with a bangpattern in a where clause. I suppose that since it's already evaluated to whnf, the conversion to Seq (or Vector) shouldn't be measured, right?
02:54:28 <merijn> tsahyt: Also, note that the sort GHC uses for lists is SUPER efficient for partially sorted data
02:55:00 <merijn> tsahyt: It uses merge-sort that keeps sorted chunks in tact (instead of starting with chunks of size 1 always)
02:55:01 <tsahyt> that makes some sense, since a lot of the values are usually the same in the cases I'm working with right now
02:55:26 <merijn> tsahyt: So if you expect data to be mostly sorted the list sort is hard to beat
02:55:47 <tsahyt> that's good to know. It also simplifies other things a lot, like evaluating the list in parallel before it's sorted
02:55:58 <tsahyt> I still have 7 cores left to use here after all
02:59:26 <tsahyt> is there really no sort implement in the vector package?
02:59:36 <merijn> hmm, there isn't?
02:59:44 <tsahyt> I can't find any
03:00:20 <tsahyt> there's always vector-algorithms of course
03:27:39 <sigrlami> Imagine big hypothetical Haskell conference, something like ClojureWest, EuroPython, how would you call it? My current favor `Unfoldr`, but I'm interested in some catchy ideas
03:32:08 <zomg> Evil Genius Conference 2016
03:32:23 <Jinxit> i'd attend that
03:34:25 <sigrlami> nice)
03:45:34 <theduke> ghc compiler/basicTypes/Id.hs: isNaughtyRecordSelector. I never met a naughty record selector before. :D
03:49:00 <quchen> theduke: My favourite in GHC is the stupid theta.
03:51:45 <puregreen> what's the stupid theta?
03:52:19 <puregreen> nevermind, googled it up and I kinda can guess why it's stupid
03:56:39 <quchen> It's something nobody should use because it's stupid but it' there so GHC supports it. ;-)
03:57:18 <quchen> If you use a data type with a typeclass constraint that's a stupid theta
03:58:29 <quchen> Not sure whether Haskell actually allows stupid thetas
03:58:47 <quchen> But GHC certainly does (I think it might require a language extension though)
04:20:33 <tsahyt> How can I have more finegrained control over what cost centers are created when compiling with stack?
04:20:41 <tsahyt> e.g. I just want to profile one module
04:22:21 <merijn> tsahyt: You can manually annotate cost centers, afaik
04:22:29 <merijn> tsahyt: consult the GHC manual for details
04:22:51 <dramforever> something like {-# OPTIONS_GHC -auto-caf -auto-all #-} ?
04:23:36 <tsahyt> merijn: but that won't keep stack from using -fprof-auto when compiling with --executable-profiling afaik
04:24:00 <dramforever> Sorry, wasn't really careful
04:24:10 <merijn> tsahyt: Sounds like a stack problem to me
04:24:21 <tsahyt> cabal would do too I suppose
04:24:46 <merijn> tsahyt: Cabal doesn't add profiling options, it just uses a different config when you build with profiling
04:24:56 <merijn> But tbh, I've never used stack, so no idea
04:25:45 <tsahyt> okay I think I've figured it out 
04:25:59 <tsahyt> --ghc-options=-fno-prof-auto does it
04:26:38 <tsahyt> but that still doesn't normalize the results it seems
04:27:37 <tsahyt> so the whole problem I have is that all the time in the normal profiling output is taken up by parsing the input, which is irrelevant in the real world usecase because the input is created dynamically by another application. As a result, the profiling output shows a very distorted picture for my actual code 
04:28:28 <tsahyt> I'd like to pretend that all the input data is available instantly to see how my library performs, because I have no control over how and where it is created anyhow
04:32:36 <marchelzo> hi
04:33:29 <dramforever> marchelzo: Hi, if you want to ask questions, just post it here and someone noticing it will respond
04:33:36 <marchelzo> is there something like modify from Control.Monad.State but instead of returning 'm ()' returns the old value of the state?
04:33:49 <marchelzo> dramforever: thanks
04:34:43 <dramforever> :t \f -> get <* modify f
04:34:44 <lambdabot> MonadState s f => (s -> s) -> f s
04:35:18 <marchelzo> i'm using lens and currently i have { l <- use level; level .= foo; } but i'd like to be able to write { l <- ??? level foo; }
04:35:31 <dramforever> Ooh lens, there must be one for that
04:35:35 <puregreen> <<.=, maybe
04:35:37 <puregreen> or <.=
04:35:40 <puregreen> I don't remember which
04:35:59 <puregreen> http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60-.-61-
04:36:03 <puregreen> “Replace the target of a Lens into your Monad's state with a user supplied value and return the old value that was replaced.”
04:36:08 <marchelzo> looks like <<.= returns the old state and <.= returns the new state
04:36:12 <marchelzo> thanks!
04:37:32 <dramforever> puregreen: Good to know, thanks!
04:39:17 <puregreen> “<” and “<<” work with most other operators, by the way (<%=, etc)
04:39:31 <itnex> i wish the default string type wasn't using lists
04:39:41 <puregreen> lots of people do, yep
04:44:42 <dramforever> The current solution seems to be: Just use the better ones
04:45:56 <merijn> I'm undecided
04:46:01 <merijn> It has it's pros and cons
04:46:23 <merijn> The biggest issue I have is that a lot of libraries poorly suited to String still use it anyway (like the posix/filesystem stuff)
04:46:48 <dramforever> Uh, well, the "better" ones should include [Char], in case it's useful
04:47:25 <merijn> Except that you have no idea whether Char makes sense
04:47:45 <merijn> Maybe backpack will allow saner filesystem libraries
04:48:43 <dramforever> backpack?
04:49:15 <merijn> dramforever: ezyang's stuff on ocaml like modules for GHC
04:49:32 <merijn> http://blog.ezyang.com/category/haskell/backpack/
04:50:18 <quchen> marchelzo, dramforever, puregreen: https://github.com/quchen/articles/blob/master/lens-infix-operators.md
04:50:44 <quchen> I tried decyphering the nomenclature some time ago, and it turns out there's a pattern behind the names.
04:51:21 <puregreen> sure there is, I think lens even has a similar page in the docs
04:52:09 <puregreen> I just still forget which of < an << is which and where @ goes in indexed operators
04:52:54 <dramforever> quchen: Ah, that's a very much nicer cheet sheet
04:52:57 <dramforever> Thanks!
04:53:40 <dramforever> merijn: Thanks, reading it
04:54:30 <marchelzo> quchen: thanks, checking it out
04:59:11 <tsahyt> is there some way to profile just one thread?
05:31:16 <zedik> Hi all. Question from a complete newbie, I just wanted to calc mean of the list: why sum [1..9] / length [1..9] doesn't work? How to make it wok?
05:32:15 <Clint> :t (/)
05:32:16 <lambdabot> Fractional a => a -> a -> a
05:32:27 <Clint> :t sum [1..9]
05:32:28 <lambdabot> (Enum a, Num a) => a
05:32:32 <Clint> :t length [1..9]
05:32:34 <lambdabot> Int
05:32:37 <Clint> zedik: ^
05:33:29 * hackagebot unused 0.5.0.2 - A command line tool to identify unused code.  https://hackage.haskell.org/package/unused-0.5.0.2 (joshuaclayton)
05:33:45 <tsahyt> :t fromIntegral (length [1..9])
05:33:46 <lambdabot> Num b => b
05:35:34 <zedik> I see.. thanks!
05:37:44 <Velizar> I have a tree and it's built via fromList - a very slow function. However, traversing it should be fast. But in GHCi, every time I do `Data.Foldable.maximum mytree`, it takes the same amount of time because it rebuilds it. Is it possible to separately execute fromList, and then the other thing I call on it?
05:45:01 <merijn> Velizar: tbh GHCi is gonna be slow anyway
05:45:12 <merijn> Velizar: GHCi uses bytecode interpretation and doesn't optimise a lot
05:45:41 <Velizar> merijn: that's fine, I'm looking at Big O. it's currently taking 2-3 secs with n = 100k
05:46:30 <Velizar> for that time, GHCi can do 5-10 mil or more
05:47:20 <Velizar> I mean with foldl' max 0 [1..n]
05:47:43 <Velizar> and 50mil actually
05:48:04 <merijn> I wonder if Foldable.maximum is strict or not
05:49:38 <Velizar> no: got stack overflow with 50mil
05:50:31 <cheater> can someone tell me what the type of the new $ operator is? all i can find on the mailing list is moaning that it's bad, with no mentions of what it is exactly
05:50:46 <phanimahesh> new $ ?
05:51:29 <phanimahesh> I know just one $, the function application operator.
05:51:49 <Velizar> :t ($)
05:51:51 <lambdabot> (a -> b) -> a -> b
05:52:13 <phanimahesh> And it isn't new, it was there when I looked at haskell years ago.
05:52:27 <cheater> you're missing the fact that ghc 8 changes the type to something else
05:52:30 <merijn> phanimahesh: The type of $ is a bit of a lie
05:52:42 <merijn> Basically there was a special case hack in the typechecker for $
05:52:43 <cheater> but i don't know what!
05:52:56 <phanimahesh> cheater: Oh, didn't know that!
05:53:20 <merijn> phanimahesh: In GHC 8 the type system has been changed to not need the ugly special case in the type checker to work
05:53:38 <merijn> phanimahesh: As a result the type of $ is now generalised (i.e. it accepts more than the old type)
05:53:45 <merijn> But the full type is a bit intimidating
05:54:07 <phanimahesh> Oh. What's the new type?
05:54:10 <merijn> The full type is: ($) :: forall (w :: Levity) a (b :: TYPE w). (a -> b) -> a -> b
05:54:23 <merijn> This stackoverflow has a good discussion: https://stackoverflow.com/questions/35318562/what-is-levity-polymorphism
05:54:30 <tsahyt> So I've spent the last two days optimizing code. I've gone from 20ms per call to the heuristic function to 251µs. So much for Haskell isn't suited for high performance applications.
05:54:52 <phanimahesh> Thanks. Was just going to ask what levity is. :P
05:54:59 <tsahyt> also, criterion is just awesome
05:55:17 <merijn> phanimahesh: Are you familiar with the terms "boxed" and "unboxed"?
05:55:21 <phanimahesh> tsahyt: Anything is suited for high performance applications in the hands of a persistent and patient programmer
05:55:39 <phanimahesh> merijn: Yep, I know boxed and unboxed
05:55:52 <merijn> phanimahesh: Right, so "levity" is just "boxedness"
05:55:57 <Velizar> ":t ($)" gives the same output for me with both GHCi 8 and 7.something
05:56:08 <merijn> phanimahesh: So levity polymorphism deals with the ability to write "boxedness polymorphic" types
05:56:28 <merijn> phanimahesh: The stackoverflow has a more detailed explanation (but it assumes you know what boxed/unboxed is, hence the question :))
05:56:43 <maerwald> more random details people have to know about basic language functionality
05:56:51 <tsahyt> phanimahesh: Actually I wasn't even that persistence. It's business as usual. Profile, identify, fix. The biggest speedup obviously came from a smarter algorithm, and the rest is pretty much just caching. I haven't even got to strictness annotations yet.
05:56:52 <merijn> Velizar: The discussion was that GHC should probably hide the full type
05:56:57 <Phyx-> Oh, you can expressed boxed types as a typeclass constraint?
05:57:03 <magneticduck> hey uh, I'm thinking of a kind of combinator that I read about a while ago
05:57:04 <cheater> Velizar: it starts with 8.0.1 i think
05:57:07 <merijn> Phyx-: As a constraint, yes
05:57:12 <magneticduck> it's like the fixed-point combinator but more .. general, somehow
05:57:12 <merijn> Phyx-: Not a typeclass constraint :p
05:57:28 <Velizar> I meant 8.0.1
05:57:32 <magneticduck> I remember reading a fascinating page on the Haskell wiki about a small set of combinators related to `fix`
05:57:35 <Phyx-> merijn: ah, I see
05:57:39 <magneticduck> they had funky names and interesting types
05:57:44 <Velizar> double-checked, it is (a -> b) -> a -> b
05:58:00 <Phyx-> i missed that ot
05:58:14 <Phyx-> i missed that it's in the forall. Still didn't know that
05:58:54 <phanimahesh> merijn: Thanks. reading it and links referenced there
06:00:06 <cheater> great link merijn thanks
06:00:14 <cheater> really enjoyed reading that
06:00:26 <phanimahesh> Is it normal to deal with unboxed values in haskell?
06:00:30 <Phyx-> yup, thanks merijn 
06:00:51 <Phyx-> makes sense that the reference is from Richard too heh
06:01:04 <phanimahesh> Haven't seen any examples, atleast not enough to remember any off hand.
06:02:20 <cheater> now that i've seen it, i don't think that the issue is so bad
06:02:39 <cheater> i mean ok maybe teaching someone might need you to lie to them a little bit or explain a little bit more
06:03:07 <cheater> you could just say "for most normal types $ has type (a -> b) -> a -> b".
06:03:36 <cheater> i don't see a reason for the outrage
06:04:57 * phanimahesh thinks outrage often doesn't have strong reasons
06:10:27 <maerwald> cheater: the lying required to teach haskell is a lot and I think that's sad and tells something about the language. Simplicity isn't really a primary goal for most things.
06:12:29 <gfixler> can any functor be covariant?
06:12:48 <gfixler> sorry, contravariant
06:12:57 <coppro> no
06:12:59 <coppro> most can't
06:13:01 <gfixler> ah ha
06:13:03 <gfixler> I didn't think so
06:13:06 <gfixler> that answers some things
06:13:20 <coppro> contravariant functors usually arise with wacky things like function composition
06:13:25 <gfixler> yep
06:13:30 <gfixler> it makes perfect sense for that
06:14:52 <cheater> maerwald: welp, some things aren't going to be simple
06:15:02 <cheater> you can forfeit them, but then what are you left with? not a lot.
06:15:27 <maerwald> cheater: it's not that easy
06:15:38 <maerwald> you're basically saying "nothing can be done simpler in haskell"
06:15:39 <cheater> my whole point
06:15:56 <cheater> nah, but a lot of things just aren't going to be
06:16:20 <maerwald> cheater: e.g. https://github.com/purescript/purescript/wiki/Differences-from-Haskell#no-special-treatment-of-
06:17:07 <cheater> i find that worse
06:17:56 <maerwald> well, it's simple, but in haskell people often want to be accomodated for every possible corner case, so we have all those GHC extensions and hacks and stuff
06:21:05 <ertesx> cheater: when teaching haskell, you should never lie (in my experience), but you can be overly specific and use overly specialised types
06:21:15 <ertesx> like: (>>) :: IO a -> IO b -> IO b
06:21:23 <ertesx> that's not a lie…  it's just not the whole truth
06:21:58 <maerwald> how can you not lie about IO :)
06:22:19 <ertesx> hmm?
06:23:13 <ertesx> i think, the only lie that we use a lot is fast and loose reasoning…  that's a genuine lie, but an 'okay' one
06:24:28 <phanimahesh> Without lying a little it is difficult to teach most nontrivial things.
06:24:52 <ertesx> like: 'id' is the only function of type 'forall a. a -> a'…  that's a lie, but it's an 'okay' lie
06:25:24 <merijn> maerwald: I disagree with you about simplicity not being a goal. I consider "special-cased hacks in the type checker" complexity. I prefer a system that is easy to reason about for simplicity
06:25:32 <ertesx> phanimahesh: i don't lie in teaching…  i've done that in the past, and it always turned against me
06:26:01 <maerwald> merijn: how is laziness easy to reason about wrt performance
06:26:23 <merijn> I care about reasoning about correctness
06:26:33 <phanimahesh> Lying a little as in providing simplified truths stripped of detail becomes necessary in my opinion.
06:26:42 <merijn> Not all programs have to be fast, but all programs need a fighting chance at correctness
06:26:45 <tsahyt> How much faster roughly is using something like binary over serialization using read and show?
06:27:02 <merijn> tsahyt: Orders of magnitude
06:27:04 <maerwald> merijn: I care about understanding code. The more complex the language, the more GHC extenions, the more corner cases can be expressed etc... the more difficult it is to understand a given piece of code.
06:27:10 <merijn> tsahyt: read is slow as shit
06:27:10 <ertesx> phanimahesh: i don't consider "(>>) :: IO a -> IO b -> IO b" a lie
06:27:11 <maerwald> and haskell is pretty bad at this
06:27:31 <tsahyt> merijn: I've noticed, yes. What's the preferred serialization library these days?
06:27:32 <maerwald> sure, people like it and see it as an academic experience or whatever
06:27:32 <ertesx> neither "(<>) :: String -> String -> String"
06:27:49 <merijn> tsahyt: binary and cereal, depending on whether you want lazy or strict
06:28:01 <maerwald> but I think for a lot of things it's just fuzz that we could live without
06:28:13 <merijn> maerwald: So which extensions would you ban/remove then?
06:28:20 <tsahyt> strictness would be nice for profiling purposes I think
06:28:37 <ertesx> tsahyt: safecopy is also popular, if you need versioning
06:28:54 <maerwald> merijn: PatternSynonyms, because they are sorta broken wrt exhaustiveness check. Either do it properly, or don't do it.
06:29:01 <maerwald> and there are more that are semi-broken
06:30:01 <merijn> I think we should have first class prisms/lenses instead of ViewPatterns/PatternSynonyms, but those will never be retrofitted
06:30:50 <Phyx-> maerwald: I don't think that's a fair statement. since ($) would have that type under just HM, which is what the Haskell standard defines the language under anyway
06:32:31 <merijn> I wonder why the classify EmptyDataDecls as an extension
06:32:42 <maerwald> merijn: also, last I heard ImpredicativeTypes is also constantly broken
06:32:49 <Iceland_jack> ghci> :t (>>) @IO
06:32:49 <Iceland_jack> (>>) @IO :: IO a -> IO b -> IO b
06:33:15 <maerwald> to me, GHC moves too fast and the haskell language report is rotting away
06:33:44 <maerwald> new GHC extensions are not going to improve simplicity in any significant way
06:33:53 <merijn> maerwald: ImpredicativeTypes has never worked (or always, depending on your point of view)
06:34:02 <merijn> Because no one knows what it's supposed to do
06:34:03 <maerwald> it's usually just added complexity to deal with yet another corner case
06:34:21 <merijn> I don't consider levity polymorphism a corner case
06:34:29 <merijn> I consider it a fundamental feature
06:34:55 <merijn> The ability to interact with unboxed values is one of Haskell's biggest contributions
06:35:30 <ertesx> merijn: because EmptyDataDecls *is* an extension in h98
06:35:47 <ertesx> just like PatternGuards
06:36:05 <merijn> ertesx: Except purescript is newer than h2010, afaik
06:36:20 <ertesx> ah, you mean purescript…  then i don't know
06:37:34 <ertesx> is purescript even related to haskell that much?  as far as i understood, it's just nicer syntax, types and more reasonable semantics for what is essentially just javascript
06:38:39 <gfixler> ertesx: purescript is written in Haskell and feels quite a bit like it
06:38:47 <gfixler> ertesx: it is strictly evaluated, though
06:39:16 <ertesx> how can a strict (by default?) language even feel like haskell "quite a bit"?
06:39:28 <maerwald> why not?
06:39:46 <maerwald> most of the time people break laziness anyway, either on purpose or without knowing
06:40:04 <ertesx> i don't do that a lot
06:40:10 <gfixler> ertesx: maybe I should say looks quite a bit like it
06:40:28 <ertesx> gfixler: yeah, that sounds more reasonable
06:41:05 <gfixler> ertesx: you get functors, applicatives, and monads, though
06:41:25 <gfixler> ertesx: and they don't feel insane, like pymonad
06:41:40 <rydgel> I kind of dislike (<<<) instead of (.) but I understand why
06:42:31 <gfixler> yeah, I'm not into big operators
06:42:40 <maerwald> well, it adds a lot to simplicity
06:53:57 <numee> Hi, when employing mutable arrays for efficiency it is tempting to have early exits (`break` in c-like languages) from loops for efficient imperative style programming. what are the best practices for situations like this? control-monad-loops? ContT?
07:03:36 <dcoutts> numee: I don't find I need to do anything fancy, early exit is pretty straightforward
07:04:53 <ertesx> numee: in a recursive loop, just don't recur
07:05:22 <ertesx> gfixler: i can't imagine how i would use monads without lazy evaluation
07:06:04 <maerwald> ertesx: like IO?
07:06:11 <ertesx> maerwald: even []
07:06:27 <maerwald> you know IO isn't really lazy...
07:06:50 <ertesx> maerwald: (>>) and (>>=) are non-strict in their second argument, and that's a requirement for IO to work sensibly
07:07:03 <maerwald> ah you mean that
07:08:11 <maerwald> pretty sure you can have the same semantics for that in a strict language
07:08:26 <hexagoxel> what are sensible names for placeholders in `class _ k where _ :: (forall a . f a -> g a -> h a) -> k f -> k g -> k h` ?
07:08:46 <hexagoxel> HoistZip?
07:10:17 <maerwald> ertesx: on second thought, I don't really understand what you are saying
07:10:46 <maerwald> the second argument is a function, not an IO action
07:11:08 <ertesx> maerwald: (>>=) is non-strict in the result of the second argument
07:11:24 <ertesx> (neither is it strict in the second argument itself)
07:11:29 <maerwald> the function might never be executed, lazy or not
07:11:56 <ertesx> try this:  putStrLn "blah" >>= undefined
07:12:31 <glguy> Being strict in a function argument wouldn't do much
07:12:52 <maerwald> ertesx: I usually don't put undefined in my code
07:13:09 <maerwald> so I don't see how this is a show-stopper
07:13:31 <ertesx> maerwald: you couldn't write 'forever' without a non-strict (>>=)
07:13:46 <gfixler> ertesx: why not?
07:13:58 <ertesx> because it would loop
07:14:25 <gfixler> I thought forever was a loop
07:14:26 <glguy> Strict in function argument didn't mean preemptively reevaluating function body
07:14:54 <ertesx> forever action = let c = action >> c in c  -- what is the action 'forever c', if (>>) were strict in both arguments?
07:15:08 <ertesx> c >> forever c  -- and what's that?
07:15:13 <ertesx> c >> c >> forever c  -- and what's that?
07:15:15 <ertesx> …
07:15:18 <merijn> ertesx: Oh! Oh! I know!
07:15:31 <glguy> Ertesx, no you wouldn't use >>
07:15:31 <merijn> ertesx: Is the answer "crash due to memory exhaustion"?
07:15:52 <merijn> glguy: What would you use, then?
07:16:04 <glguy> >>= 
07:16:18 <maerwald> ertesx: https://github.com/purescript/purescript-tailrec/blob/360cfb715fb9818a51e95c6056b7145284f4679c/src/Control/Monad/Rec/Class.purs#L114
07:16:22 <gfixler> can't you do all of this with a trampoline?
07:16:36 <maerwald> seems like there's an easy solution
07:17:00 <ertesx> glguy: yeah, most strict-by-default languages would allow that
07:17:07 <glguy> forever m = m >>= \_ -> forever m
07:17:10 <gfixler> c >> c is c >> \_ -> c, no?
07:17:26 <merijn> glguy: How does this solve the leak?
07:17:27 <ertesx> gfixler: this isn't about tail calls
07:17:35 <ertesx> gfixler: it's the same as with constructing infinite lists
07:17:42 <glguy> Gfixler, not the same if you're imposing strictness
07:17:45 <maerwald> ertesx: did you have a look at the link?
07:17:48 <gfixler> ertesx: but don't you need to eval the left to pass an arg to the right?
07:17:56 <gfixler> the result
07:18:01 <ertesx> maerwald: just a second, please
07:18:53 <ertesx> gfixler: repeat x = let xs = x : xs in xs  -- works, because (:) is non-strict in its second argument
07:19:22 <glguy> Merijn: which leak?
07:19:48 <ertesx> in a strict language you can't write this, except perhaps by using glguy's "function indirection as laziness emulation" hack
07:20:05 <ertesx> (if the language supports functions)
07:20:11 <glguy> It's not a hack, its the type of>>=
07:20:13 <maerwald> "hack", lol
07:20:21 <glguy> And functions
07:20:51 <maerwald> anyway, purescript is strict and has 'forever' via Monads, so no idea what the problem is here
07:21:07 <ertesx> glguy: it is a hack, because most languages don't insist on evaluating arguments to normal forms
07:21:30 <ertesx> function arguments that is
07:23:02 <ertesx> maerwald: just read the code…  and you need this kind of explicitness everywhere
07:23:17 <maerwald> what's the problem?
07:23:40 <ertesx> it's not practical for the way i code
07:23:50 <maerwald> that I don't care about much
07:25:16 <maerwald> and I don't understand what "everywhere" means, you have 'forever' defined here pretty simple
07:25:19 <ertesx> then why do insist that i don't have a problem?  i distinctly said that *i* can't imagine how monads could be even useful in such a context
07:25:22 <maerwald> and you don't need to copy-paste the solution
07:25:36 <maerwald> ertesx: what you can imagine depends on what you have seen :P
07:25:53 <ertesx> maerwald: there are replicateM_, mapM_, …
07:28:15 <maerwald> ertesx: mapM_ in purescript is traverse_ https://github.com/purescript/purescript-foldable-traversable/blob/master/src/Data/Foldable.purs#L174
07:28:38 <maerwald> not sure why we are playing this game
07:29:02 * glguy needs to find the beginning of this, thought it was just about strictness of >>= 
07:30:39 <ertesx> maerwald: because i'm very sure that a straightforward implementation of (replicateM_ n) will actually use O(n) space
07:31:13 <ertesx> something as innocent as (mapM_ print [1..100000]) might as well
07:31:23 <ertesx> as said: i can't imagine having to pay attention to this
07:31:34 <maerwald> "might"? I don't know. Check the purescript implementation
07:31:46 <ertesx> even if most of the standard libraries try to hide it
07:32:01 <maerwald> I think you are just used to one way of doing things.
07:32:12 <ertesx> i am indeed
07:33:38 <ertesx> i spent a long time getting rid of my C/C++ thought patterns, and i'm not going back…  that's why i'd rather juse GHCJS than try to use any of the "smaller" languages =)
07:33:58 <maerwald> sure, I just think that lacks a strong argument against strict approaches
07:34:30 <maerwald> even SPJ said (jokingly though, maybe) "Maybe the next haskell will be strict" ;)
07:34:41 <maerwald> I don't mind either approach
07:34:54 <cheater> ertesx: your intuition is correct. monads have specifically been introduced because they are a way of ensuring in-order computation in a lazy language.
07:35:28 <cheater> ertesx: they make little sense in a strict language other than an improvement on syntax. they are sometimes used in scala or ml, but they're not necessary.
07:35:28 <maerwald> cheater: you are talking about haskell though
07:35:31 <cheater> yes.
07:35:36 <maerwald> you have monads in other languages too, for different reasons
07:35:49 <cheater> i mentioned that
07:36:01 <maerwald> yeah and they make sense there too
07:36:41 <ertesx> cheater: i disagree there though…  monads would be very useful for things like tree substitution and generic combinators…  but they are just awkward to use, if the language is strict by default
07:36:58 <merijn> ertesx: Haskell just warps my C++ thought patterns into Lovecraftian horrors :p
07:36:58 <maerwald> ertesx: have you actually used a strict language with monads?
07:37:11 <ertesx> hehe
07:37:13 <maerwald> Idris, purescript or whatever
07:37:52 <merijn> ertesx: Witness this monstrosity: http://lpaste.net/1601965815781916672
07:38:42 <_ohso> Hello, I am porting a C# application into Haskell. I can make it work, but I don't like how OO encapsulation seems so difficult to express in Haskell. In C# I have a deep inheritance hierarchy with a lot of virtual methods, and derived classes including state that makes no sense to their base classes.
07:39:09 <ertesx> maerwald: i tried to reinvent monads in PHP and found them to be useless, terrible syntax being the primary reason in this case, but lack of tail recursion and strictness being other reasons in decreasing order of significance…  i've also used F#, which doesn't quite have monads in the same sense as haskell, because the type system isn't expressive enough
07:39:12 <cheater> _ohso: use composition rather than inheritance
07:39:16 <cheater> _ohso: use type classes for overloading
07:39:17 <merijn> _ohso: Yeah, you're not going to duplicate that in Haskell
07:39:20 <cheater> rather than indirection
07:39:30 <merijn> Inheritance is an anti-pattern
07:39:33 <maerwald> ertesx: then it's time you try purescript for real.
07:39:36 <gfixler> merijn: is that for summoning a Great Old One?
07:39:39 <_ohso> The best I've been able to acheive is to have each C# class use a different data constructor on a single type and use pattern matching (which I've read seems to be the canonical way to do it) to test for each scenario. 
07:39:44 <cheater> _ohso: and use statless algorithms immutability and purity rather than global state
07:39:50 <ertesx> merijn: that's…  surprisingly readable
07:40:20 <ertesx> maerwald: i will the next time i need to write JS
07:40:28 <ertesx> maerwald: i'd love to be proven wrong on this =)
07:40:41 <merijn> ertesx: I spent a lot of time cleaning it up :p
07:40:46 <merijn> gfixler: No comment :)
07:41:08 <_ohso> I'm trying to do it "the haskell way" and keep everything pure as possible. (I'm implementing a z-machine interpreter - http://inform-fiction.org/zmachine/standards/index.html )
07:41:10 <merijn> gfixler: It's boilerplate reduction, if you believe it :)
07:41:42 <ertesx> merijn: i'd say i can only read this because i'm an experienced programmer in both C++ and haskell =)
07:41:43 <gfixler> merijn: maybe for Vogons
07:42:16 <merijn> ertesx: I'm guessing you can guess the reason for it's existence too :p
07:42:31 <maerwald> ertesx: the optimum would be if neither the language nor libraries impose a strict vs non-strict choice on you. But I don't see how that's easily possible. You'll always have a default and libraries that provide strict or non-strict versions of things.
07:42:46 <_ohso> My problem is that unlike most interpreters that have a bunch of switches/if statements all over the place to test for version specific behavior, I really really want to consolidate each version into it's own module to make it easy from a documentation standpoint to see each version's behavior in isolation. Inheritance in C# allowed this, but I can't seem to achieve it in Haskell.
07:43:51 <cheater> _ohso: again, you want overloading via type classes rather than via indirection through inheritance
07:44:51 <merijn> Sounds like classical expression problem
07:45:10 <gfixler> _ohso: you can still get inheritance over behaviors with type classes (e.g. Ord requires Eq)
07:45:21 <gfixler> merijn: didn't Wadler solve that? I haven't read that one yet
07:46:45 <merijn> gfixler: It's not really something you "solve" it's more of a "compromise to do what you want"
07:47:13 <_ohso> I'd considered typeclasses, but I read conflicting things about them - since they are for adhoc polymorphism more so than inheritance. There doesn't seem to be an (easy? possible?) way to reuse implementations from one type in another. Something that is pretty much a requirement in my case.
07:48:49 <pi_> Hi all !
07:49:12 <_ohso> Composition vs. inheritance seems maybe a better way to go...I often do that in C# to reduce complexity.
07:49:43 <gfixler> inheritance is almost always a problem
07:49:55 <gfixler> look what's happening in the UK
07:51:59 <_ohso> My main goal is to have each version's (C# class's) behavior in one physical file instead of spread across hundreds of pattern matched functions.
07:52:44 <acai> trying to understand how to use do notation with maybe monads correctly
07:53:11 <acai> how can i change this example http://lpaste.net/167936 so that baz returns Nothing instead of producing an exception?
07:53:14 <gfixler> _ohso: well, Haskell is all about functions
07:53:22 <gfixler> _ohso: no OOP-style classes to be seen
07:53:38 <gfixler> _ohso: do you have hundreds of methods atm?
07:53:51 <_ohso> Yes
07:54:50 <gfixler> _ohso: so you're okay with hundreds of functions?
07:55:23 <_ohso> But like I said, each one is a mess of conditional logic based on machine version (each version is a C# class in the original). Trying to get a glimpse of the differences say from version 3 to version 4, is practically impossible in the Haskell code...it's spread everywhere.
07:55:46 <gfixler> _ohso: can you pass in the machine version as an arg?
07:56:05 <_ohso> Certainly I can pass it as an arg.
07:56:11 <gfixler> _ohso: or if it's more than one thing, a record of settings?
07:56:49 <gfixler> acai: do you need the do in foo?
07:56:52 <pi_> _acai : Try like this :
07:56:59 <gfixler> acai: i.e. can you just have foo = return (Number 3)?
07:57:08 <hexagoxel> acai: String blah <- Just x
07:57:37 <pi_> http://pastebin.com/YqiyKSdM
07:57:45 <acai> yes that does it hexagoxel thanks
07:59:18 <numee> ertesx: well, I just wrote a recursive version and it was more straightforward than expected. but I'm not sure if the recursive version is clearer than the loop one: http://pastebin.com/Wr34HqSj
07:59:44 <hexagoxel> gfixler: or `baz = Nothing` ? :D
08:00:30 <pi_> What library would you use to play sound generated at real time ?
08:00:33 <cheater> _ohso: again, you don't want inheritance. specifically because there is no inheritance in haskell.
08:00:34 <pi_> (runtime)
08:00:49 <cheater> _ohso: the reason your program in C# is using inheritance is to allow polymorphism and/or overloading.
08:00:51 <gfixler> cheater: there's some inheritance through typeclasses
08:01:18 <gfixler> cheater: perhaps that's not the best way to frame it
08:01:23 <cheater> no, it's not
08:01:24 <gfixler> cheater: I suppose it's more like prereqs
08:01:36 <cheater> you're thinking of a different kind of inheritance which is irrelevant for _ohso 
08:01:41 <gfixler> cheater: retracted
08:02:09 <cheater> _ohso: either way, polymorphism and overloading are done in haskell using typeclasses and polymorphic function types
08:02:32 <cheater> _ohso: that's why there's no line-by-line translation of C# to haskell
08:03:01 <_ohso> I understand Haskell doesn't have inheritance in the same sense. What I am looking for a more about code organiztion (from a human eyeball, documentation standpoint). 
08:03:26 <quchen> C# has classes where Haskell has modules. C$
08:03:33 <cheater> _ohso: so you'd have your data types that you operate on, and those don't get overloaded, what instead gets overloaded is functions, like e.g. sort, and you'd have different instances of typeclasses for them
08:03:41 <quchen> C# has properties and methods where Haskell modules has functions and values.
08:04:18 <quchen> C# does implementation hiding by making things class-private. Haskell does this by not exporting certain definitions from modules.
08:04:21 <_ohso> Having all the various opcodes that vary by machine version each have there own conditional pattern matching on version (or accepting a version argument) makes it impossible to see at a glance the behavior differences between versions. I am looking at a way to reorganize the code such that this becomes possible again.
08:04:39 <cheater> to create new typeclass instances for an otherwise unchanged type, you create a "newtype" which is a wrapper around the old data type. it's like making an empty subclass, it's little more than just a new label for the old type.
08:04:59 <cheater> so you'd put that in one file, and together with that you'd put all the typeclass instances in there
08:05:04 <cheater> and that's your "everything in one file"
08:05:59 <_ohso> Hmm, so something like:   Version2 = Version2 (Version1)      ?
08:06:50 <mizu_no_oto_work> _ohso: There's also the records-of-functions option
08:07:31 <gfixler> _ohso: is the data the same across versions, but the things you do to it different?
08:07:41 <cheater> you'd write newtype Version2 = Version2Constructor BasicVersion
08:07:51 <cheater> where BasicVersion is a type
08:08:24 <cheater> mizu_no_oto_work: he's got issues getting to grips with typeclasses, he doesn't need to think about phantom types yet
08:08:53 <mizu_no_oto_work> cheater: You don't need phantoms for records of functions
08:09:13 <cheater> no, but that's where it's going if you want a full extension of the idea
08:09:26 <cheater> specifically state etc
08:11:23 <mizu_no_oto_work> _ohso: read https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ for the basic idea
08:13:25 <mizu_no_oto_work> It's most commonly used when you want heterogenous collections, which is something that existential typeclasses also enable
08:13:47 <mizu_no_oto_work> But is not something that actually comes up all that often
08:14:18 <_ohso> Both the data and functions change across versions. Later versions include data earlier version don't have. Many functions remain th same across versions (but may vary witht he value of a few version specific constants), while other functions change radically, or do completely different things, or even become illegal.
08:14:54 <ertesx> merijn: not quite sure, but it looks like a very dumb smart constructor to me
08:15:15 <mizu_no_oto_work> _ohso: is the type of these functions fixed?
08:15:50 <Welkin> a dumb constructor
08:15:51 <_ohso> The type is not always fixed.
08:16:04 <ertesx> maerwald: perhaps an explicit data/codata choice would be more sensible…  those could select the default strictness for data structures, and function strictness would pretty much follow from that
08:16:09 <_ohso> It is in most cases, but there are weird exceptions.
08:17:12 <merijn> ertesx: No, it's there for template deduction
08:17:32 <merijn> ertesx: You can't deduce template parameters on constructors
08:17:43 <merijn> But you can on functions, so by wrapping the constructor you can get deduction
08:18:58 <ertesx> numee: there is also the 'fix' pattern:  fix $ \again -> do …  -- it can be more readable, but usually only when no arguments are involved, unless you invent a bunch of combinators
08:18:59 <mizu_no_oto_work> _ohso: Is the AST fixed, at least?
08:19:29 <ertesx> numee: personally i just define a loop using 'let':  do …; let { go x y = … }; go x0 y0
08:19:48 <ertesx> numee: or using 'where', if i don't need any local bindings
08:20:04 <ertesx> merijn: ah, yeah, i remember
08:20:05 <maerwald> ertesx: idris has a Lazy type afair
08:20:07 <_ohso> AST?
08:20:13 <ertesx> maerwald: it does
08:20:33 <ertesx> maerwald: and it's reasonably easy to use for data structures…  not so much for functions though
08:21:21 <_ohso> I there a way to create a class that has default behavior such that it doesn't have to be re-written in each type that has an instance of the class?
08:21:25 <mizu_no_oto_work> _ohso: I'd consider having a bunch of different modules - Machine.Z.V1, Machine.Z.V2, etc. and then have a simple Eval typeclass.  You can abstract common parts of the modules into a Machine.Z.Base or just have Machine.Z.V2 rely on Machine.Z.V1
08:21:49 <mizu_no_oto_work> Instead of trying to bash this into typeclasses or records of objects or something
08:21:54 <ertesx> _ohso: are you trying to emulate OOP with type classes?  if yes, you're probably going to be very disappointed
08:22:18 <mizu_no_oto_work> since what you're trying to do is rather less principled than what those things give you
08:22:44 <mizu_no_oto_work> This allows you to have the code sharing you'd like, and you can even have a polymorphic interpreter function
08:22:54 <_ohso> mizu_no_oto_work,  I'd like each version in it's own module, yes. That's what I'm trying to achieve. 
08:23:05 <mizu_no_oto_work> AST equals abstract syntax tree
08:24:06 <ertesx> _ohso: before writing a type class, answer the following questions:  1. can you think of at least two different types that are sensible instances of this class?  2. can you write at least one function using that class as a context and no reference to any particular instance?  3. can you formulate at least one algebraic law for the members of the class?
08:24:22 <mizu_no_oto_work> _ohso: just use plain functions in the different modules
08:24:33 <ertesx> _ohso: if you can't answer at least two of them with "yes", don't write a type class
08:24:44 <mizu_no_oto_work> And abstract common functionality shared between them into another module
08:25:10 <mizu_no_oto_work> so each module really just has the code to handle what's different between each version
08:26:58 <_ohso> I think typeclass makes sense:  I have eight versions - each has some operations in common (run a machine cycle, decode an operation, etc.) However each version has a different list of implmented opcodes. What is an illegal opcode in one version may be legal in another. opcodes often change implementation between versions, or even swap behavior between two different opcode numbers. Sometimes opcodes only enhance existing bahaivor.
08:27:55 <_ohso> I'd prefer not to duplicate code across versions or write a huge number of functions that merely wrap the functions of the previous version. (I hate code duplication).
08:29:26 <_ohso> Later versions have data earlier ones do not (sound support, color support, many other little things)
08:31:05 <_ohso> need to go afk for a bit.
08:31:07 <ertesx> _ohso: that's two of the questions answered with 'yes', so a type class may indeed make sense
08:31:27 <ertesx> _ohso: next try to come up with laws and try to distill your class(es) into their essence
08:31:41 <ertesx> in other words: remove any members that could be defined in terms of others
08:31:51 <ertesx> and actually just define them as regular functions
08:32:03 <ertesx> (or values)
08:32:18 <xaviergmail> What does a single quote at the end of a function mean?
08:32:33 <ertesx> xaviergmail: it's part of the name
08:33:02 <ertesx> xaviergmail: there are a number of conventions:  foldl' is the strict version of foldl, but it has no technical meaning…  it's just another name character
08:33:16 <xaviergmail> Ah
08:33:21 <ertesx> > let b'l'a'h'''' = 5 in b'l'a'h'''' + b'l'a'h''''
08:33:23 <lambdabot>  10
08:34:18 <ertesx> :t let don't action = pure () in don't (do putStrLn "Hello!")
08:34:19 <lambdabot> Applicative f => f ()
08:34:24 <acai> i'm writing a bunch of rest clients in servant. would people prefer one monolithic package with many services, or one package per service?
08:35:10 <ertesx> acai: a package can have multiple executables…  use whatever is easier to manage for you
08:35:48 <acai> it's meant to be a library
08:36:06 <ertesx> acai: you have the model as a separate library?
08:36:27 <acai> talks to a bunch of data services for biological data, those services are independent of one another
08:36:38 <ertesx> acai: personally i tend to keep things separate
08:36:59 <ertesx> like in 'timelike', 'timelike-time' and 'timelike-clock'
08:37:24 <ertesx> but there are also examples of throwing everything into a single library, like pandoc
08:38:04 <ertesx> one relevant question is:  do the different implementations have different library dependencies?
08:38:09 <ertesx> if yes, you may want to keep them separate
08:38:24 <acai> they all have the same library dependencies
08:38:50 <ertesx> then it probably doesn't pay off to separate
08:38:53 <acai> each one is basically a servant client specification, some boilerplate, and some small utility functions
08:39:37 <ertesx> one reason to separate could be to reduce compilation times for people who use only a small subset of the functionality…  but it's not a big deal
08:40:14 <acai> yeah. the other thing is that there could be frequent updates as a i tweak one particular client or add others
08:40:55 <acai> on the other hand, it seems like brand-awareness is better when it's all one big thing
08:40:56 <ertesx> another reason may be to have separate repositories for each service, potentially even to push patches between them
08:41:36 <ertesx> you can communicate brand through names and hackage categories
08:41:44 <ertesx> it shouldn't influence your design too much
08:48:36 * hackagebot yesod-auth-oauth2 0.1.10 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.10 (PatrickBrisbin)
08:48:37 <numee> ertesx: I didn't know thet fix trick and yoru proposal seems great, thanks!
08:53:30 <theseb> if someone learns haskell will it help them with lisp/scheme...i mean are they similar in any way?
08:53:36 * hackagebot ghci-history-parser 0.1.0.0 - parse output of ghci ":history" command  https://hackage.haskell.org/package/ghci-history-parser-0.1.0.0 (phlummox)
08:54:38 <marchelzo> i think it could help
08:55:01 <marchelzo> i think it's almost always helpful to have experience with other languages
08:55:18 <theseb> marchelzo: thanks
08:56:53 <gfixler> I'm learning about profunctors
08:57:06 <gfixler> I don't understand why I can't write fmap for Endo (a -> a)
08:57:22 <gfixler> I would presume my f would monomorphise
09:00:24 <xaviergmail> How do sum'' and product'' work in this: http://lpaste.net/167943 ? More specifically, how do they know to pass the arguments they are given to what they're assigned to to complete that function call?
09:00:46 <xaviergmail> I feel like these written "lectures" are skipping out on a bunch of information
09:01:12 <gfixler> xaviergmail: I think you're asking about currying
09:01:31 <xaviergmail> Right
09:01:37 <gfixler> all functions in Haskell are functions of one argument
09:01:47 <gfixler> and the function constructor arrow is right-associative
09:02:41 <gfixler> so (a -> b -> b) -> b -> [a] -> b is really (a -> b -> b) -> (b -> ([a] -> b))
09:03:08 <gfixler> iow, sum'' really just takes (+) in your example, and returns a new function
09:03:20 <gfixler> and that function takes the 0 and returns a new function
09:03:30 <gfixler> this works as function application is left-associative
09:03:31 <hpc> even further, it's really (a -> (b -> b)) -> (b -> ([a] -> b))
09:03:37 <gfixler> hpc: right :)
09:03:40 <hpc> ;)
09:04:02 <xaviergmail> ah nice!
09:04:21 <gfixler> xaviergmail: each returned function is a closure, with what was passed to it bound inside it
09:04:53 <xaviergmail> Yeah, I've done quite my fair share of currying in Lua without really realizing it
09:05:09 <gfixler> xaviergmail: currying is great for generating helpful, new functions
09:05:20 <gfixler> e.g. sum'' and product'' are new, specific functions, based on fold
09:05:45 <mvaenskae> cheers, how can i define a string variable in haskell? i would like to not have to write string every time but keep variables for readability reasons
09:06:01 <xaviergmail> I was wondering what kind of magic was happening since I didn't see anything explicit hinting at it but your explanation was very helpful
09:06:17 <gfixler> xaviergmail: yeah, there's no magic - it's just associativity, and single-argument functions
09:06:25 <xaviergmail> :)
09:06:43 <gfixler> mvaenskae: where are you writing string?
09:07:54 <monochrom> mvaenskae: Do you have code showing what you already have but unsatisfactory to you?
09:09:16 <mvaenskae> gfixler: i would like to have it "defined" using the following syntax (using -- as delimiters) --RealStart = "<real>"--
09:09:44 <mvaenskae> but it then complains with "Not in scope: data constructor 'RealStart'"
09:09:54 <monochrom> you can't use RealStart for the name. you need to start with lowercase. maybe realStart
09:10:09 <mvaenskae> ah, forgot about that :(
09:10:27 <mvaenskae> that solves my issue very likely :)
09:10:35 <monochrom> realStart = "<real>"  is already legal, nothing to fix.
09:10:48 <monochrom> do you know the term "data constructor"?
09:17:24 <sirf0x> Hi there!
09:17:28 <xaviergmail> Ah what you explained to me was explained at the end of the lecture
09:17:45 <mvaenskae> yeah, it just slipped my mind; i am trying to refresh my skills by writing a simple file parser from which i convert the values then to another format (normalized double to hex)
09:17:46 <ertes-t6v> theseb: doesn't help as much as one might think
09:18:10 <ertes> theseb: clisp/scheme and haskell are very different in many ways
09:18:21 <gfixler> xaviergmail: multiple explanations are good - they help it sink in better
09:18:35 <xaviergmail> Yeah :)
09:19:20 <ertes> yeah, "monads are spaceships", "monads are burritos", …
09:19:23 <monochrom> the 3rd explanation is always the best explanation
09:19:38 <sirf0x> what is the best approach in haskell to generate code the way C++ templates does? I have some boilerplate code I would like to factorize but TH seems a bit overkill for that
09:20:03 <ertes> sirf0x: do you actually need to *generate* code?  what's the application?
09:20:16 <monochrom> 90% of C++ template is simply parametricity in Haskell
09:20:37 <ertes> sirf0x: often the proper kind of polymorphism will do the trick
09:20:50 <sirf0x> i'm writing a simple rest api and I would like to factorize the CRUD
09:20:51 <monochrom> for example "template <T> T f(T x) { return x;}" is simply "f :: t -> t; f x = x"
09:20:52 <magneticduck> sirf0x: if you're looking at a Haskell problem and thinking "Hm, if only I could use a feature from C++", you're looking at things the wrong way ;)
09:21:14 <ertes> sirf0x: in what way?  to have a common API for many things?
09:21:17 <sirf0x> i'm a haskell beginner too, I should have begun like that ^^
09:21:35 <monochrom> there is only 10% in which you start to factorize integers into prime factors, at compile time, that you need TH
09:21:46 <magneticduck> if you look at a C++ program and are thinking "Hm, if only I could use a feature from Haskell", it means you're not dead yet
09:21:56 <sirf0x> To avoid repeating code that is identical
09:21:57 <magneticduck> s/program/problem
09:22:31 <sirf0x> simple standard code factorization, simple stuff in most language
09:22:36 <ertes> sirf0x: that's one of the features of polymorphism, but you need to be more specific
09:22:57 <ertes> sirf0x: are you familiar with monoids?
09:24:17 <sirf0x> I'm familiar with the term monad and unsterstand it partly but I could not say i'm familiar with monoids per se
09:24:37 <ertes> sirf0x: let me just show you two examples of monoids:
09:24:46 <ertes> > "abc" <> "def"  -- the concatenation monoid
09:24:48 <lambdabot>  "abcdef"
09:24:54 <ertes> > Sum 5 <> Sum 7  -- the addition monoid
09:24:55 <lambdabot>  Sum {getSum = 12}
09:25:15 <sirf0x> I think I understand the concepts here yes
09:25:38 <ertes> one of the most important ways in which haskell saves code duplication is writing generic functions in terms of type classes
09:25:49 <sirf0x> ok
09:25:50 <ertes> > mconcat ["abc", "def"]
09:25:52 <lambdabot>  "abcdef"
09:26:00 <ertes> > mconcat [Sum 3, Sum 5, Sum 7]
09:26:02 <lambdabot>  Sum {getSum = 15}
09:26:11 <ertes> the mconcat function is not defined twice…  it has a single definition
09:26:24 <sirf0x> I see
09:26:36 <gfixler> (<>) <> (<>) -- the monoid monoid
09:26:40 <ertes> but it uses (<>), and which one it uses depends on the type
09:26:51 <gfixler> > ((<>) <> (<>)) "foo" "bar"
09:26:52 <lambdabot>  "foobarfoobar"
09:27:18 <sirf0x> ok
09:27:50 <ertes> sirf0x: but you don't actually need type classes for that…  all of this can be reduced to simple higher-order functional programming
09:28:17 <sirf0x> Maybe If can show you some code you'll understand exactly what I mean
09:28:55 <sirf0x> http://pastebin.com/3BPQ12Rp
09:29:16 <sirf0x> this code is an example from servant-persistant, a github repo using servant to define a simple API
09:29:26 <sirf0x> in there is the definition of simple CRUD
09:29:47 <sirf0x> but i know this could be factorized into something I can reuse on other types than User in that case
09:30:34 <sirf0x> In C++ i would use a simple templated class to define the methods that apply the same behaviour but on different types
09:30:42 <ertes> sirf0x: let me use a simpler example
09:30:42 <gfixler> sirf0x: yeah, that's typeclasses
09:31:01 <sirf0x> (thank you for taking the time guys :))
09:31:09 <sirf0x> ertes : i'm reading
09:31:27 <ertes> sirf0x: do you know how to write a function to sum a list in haskell?
09:31:43 <ertes> sirf0x: mySum :: (Num a) => [a] -> a  -- with this type
09:31:54 <sirf0x> i would use reduce i guess
09:32:10 <ertes> sirf0x: let's pretend that you don't have reduce (which is called foldl' in haskell)
09:33:06 <sirf0x> i would recode something close with recursion i think
09:33:42 <ertes> do it…  don't bother with performance or anything, just write the most straightforward implementation you can think of
09:39:39 <sirf0x> http://pastebin.com/10ziqyDK
09:39:47 <sirf0x> something like that?
09:40:04 <ertes> sirf0x: yeah, exactly…  minor style note though:  use "f x" rather than "f(x)"
09:40:19 <sirf0x> ok
09:40:41 <ertes> sirf0x: now do the same thing for multiplication of numbers and concatenation of lists
09:40:55 <ertes> myProduct :: (Num a) => [a] -> a
09:41:02 <ertes> myConcat :: [[a]] -> [a]
09:41:32 <ertes> (you can use the predefined (++) in myConcat)
09:41:42 <ertes> the point is to observe how they all follow the same basic pattern
09:41:58 <ertes> then factor that pattern out as a next step
09:43:57 <ertes> sirf0x: oh, and please use <http://lpaste.net/>…  pastebin.com messes up the formatting of haskell and has a lot of clutter
09:46:55 <Guest75671> Haskell newbie here.. I'm wondering if anybody can help me understand a type signature in the example given in the Scalpel docs (https://hackage.haskell.org/package/scalpel-0.3.1/docs/Text-HTML-Scalpel.html)
09:47:09 <Guest75671> specifically, this: comments :: Scraper String [Comment]
09:48:34 <gfixler> Guest75671: https://hackage.haskell.org/package/scalpel-0.3.1/docs/Text-HTML-Scalpel.html#t:Scraper
09:48:38 * hackagebot ghci-history-parser 0.1.0.1 - parse output of ghci ":history" command  https://hackage.haskell.org/package/ghci-history-parser-0.1.0.1 (phlummox)
09:49:35 <Guest75671> gfixler: it's funny... I read that last night, but _now_ it makes sense to me 
09:49:40 <Guest75671> thank you :D sorry for the trouble
09:49:53 <gfixler> Guest75671: no trouble :)
09:54:15 <ertes> sirf0x: note that you don't have to do everything at once…  i'll guide you through capturing the pattern once you see it
09:54:55 <sirf0x> I have something but when try to apply it the interpreter rejects it
09:55:06 <ertes> sirf0x: feel free to paste it
09:56:02 <sirf0x> http://lpaste.net/167957
09:57:57 <ertes> sirf0x: that's not quite the pattern
09:58:07 <ertes> sirf0x: you have two equations in the general pattern:
09:58:23 <ertes> f [] = _z  -- this is the first thing that changes between use cases of the pattern
09:58:49 <ertes> f (x:xs) = _f x (f xs)  -- the _f is the second thing that changes
09:59:34 <ertes> now give this pattern a name…  this particular pattern already has a name: it's called foldr
09:59:49 <ertes> then make everything that changes between instances of the pattern an argument to the pattern
10:00:08 <ertes> foldr f z [] = z  -- the two things that change became an argument
10:00:31 <ertes> foldr f z (x:xs) = f x (foldr f z xs)  -- the function 'f' actually takes two arguments
10:00:43 <ertes> sirf0x: did that make sense?
10:00:48 <hodapp> mleh. I have little love for the state of documentation on hmatrix
10:00:55 <hodapp> perhaps I should fix it up once I understand it
10:02:13 <ertes> sirf0x: if you want to play around with it, call it myFoldr…  foldr is predefined (but it's the same thing)
10:02:29 <sirf0x> il just played with foldr
10:03:00 <ertes> sirf0x: in particular write mySum again, but this time using myFoldr (or foldr):  mySum = foldr _f _z  -- this is basically just filling in the holes
10:03:20 <sirf0x> ok
10:03:48 <ertes> sirf0x: feel free to paste that one-liner here
10:06:26 <sirf0x> mySum x = foldr (+) 0 x
10:06:43 <ertes> sirf0x: yeah, or even just:  mySum = foldr (+) 0
10:06:56 <ertes> sirf0x: that's how you don't repeat code in haskell =)
10:07:13 <sirf0x> haha, makes sense now that you say it
10:07:30 <ertes> recognise patterns, give them a name, reuse them
10:07:40 <ertes> and always keep in mind that functions can be regular arguments as well
10:07:56 <pi_> How Control.Concurrent.Chan_s performance compares to IORef_s ??
10:08:26 <ertes> pi_: that's really apples and bananas…  once is a message channel, the other is a mutable variable
10:08:39 <ertes> s/once/one/
10:08:57 <sirf0x> ok thanks, i'll look further into basic language mecanism before trying something like that
10:09:11 <pi_> Yeah, i know. But is it better to use a Chan or a IORef in the case of a buffer. 
10:09:13 <ertes> sirf0x: type classes make this even nicer in many cases…  their purpose is basically not to write "f" and "z" explicitly, when they can be deduced from the types
10:09:24 <pi_> e.g. using modifyIORef (:value) 
10:09:44 <ertes> pi_: in that particular case Chan is likely to perform a lot better
10:09:51 <pi_> Thanks !
10:10:09 <ertes> pi_: is this actually about multiple threads?
10:10:18 <pi_> Yes
10:10:49 <ertes> then Chan, definitely…  and if you ever use an IORef from multiple threads, keep in mind that modification is not atomic by default
10:10:52 <ertes> use atomicModifyIORef
10:11:05 <pi_> Ok thanks
10:12:47 <Morgawr> I have a list of Maybe Bool, is there a way I can foldl or reduce or whatever on them to obtain a Maybe Bool as a result? Like folding a || on them.
10:13:03 <hpc> :t or . catMaybes
10:13:04 <lambdabot> [Maybe Bool] -> Bool
10:13:13 <Morgawr> Nice, thanks
10:13:25 <ertes> Morgawr: a Maybe Bool or a Bool?
10:13:25 <hpc> or one of a gazillion other ways that all do different things
10:13:39 * hackagebot crypto-multihash 0.4.0.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.4.0.0 (mseri)
10:13:39 <hpc> :t sequence . fmap catMaybes
10:13:40 <lambdabot> Traversable t => t [Maybe a] -> [t a]
10:14:05 <hodapp> Should the results on [Nothing, Just False] be 'Nothing', or 'Just False'?
10:14:56 <Morgawr> ertes: Actually I just need a bool so what hpc posted is perfect for me
10:15:45 <hodapp> just make sure your corner-cases are right - [] and [Nothing] and so on
10:16:23 <Morgawr> Yeah, thanks.
10:18:55 <ertes> :t foldr (\x xs -> if x then xs else False) True
10:18:56 <lambdabot> Foldable t => t Bool -> Bool
10:19:29 <ertes> :t or . or
10:19:30 <lambdabot>     Couldn't match type ‘Bool’ with ‘t0 Bool’
10:19:30 <lambdabot>     Expected type: t Bool -> t0 Bool
10:19:30 <lambdabot>       Actual type: t Bool -> Bool
10:19:33 <ertes> :t or
10:19:35 <lambdabot> Foldable t => t Bool -> Bool
10:19:47 <ertes> :t or . fmap or
10:19:48 <lambdabot> (Functor t, Foldable t, Foldable t1) => t (t1 Bool) -> Bool
10:20:12 <ertes> > or . fmap or $ [Just True, Just True, Just False]
10:20:13 <lambdabot>  True
10:20:29 <dolio> if p then q else False is p && q, right?
10:20:39 <itnex> why does something like data Something = Something !Int have any kind of memory usage overhead over simply using an Int?
10:20:46 <ertes> dolio: yeah
10:21:05 <ertes> somehow i were thinking of and while writing or…
10:21:11 <dolio> :)
10:21:25 <dolio> itnex: There is an extra indirection.
10:21:40 <itnex> i dont understand
10:21:57 <itnex> why is there an uint32 tag
10:22:06 <itnex> because there is an uint32 tag even is there is only one constructor, no?
10:22:08 <hpc> even though the parameter is strict, the memory layout is still the same for that type
10:22:11 <hpc> (in ghc)
10:22:12 <itnex> if there is*
10:22:25 <hpc> (without optimizations and other flags that would unbox it and whatnot)
10:22:48 <hpc> you probably want newtype if that really matters to you
10:23:17 <ertes> itnex: newtype and single-strict-field-data aren't the same thing, not even semantically
10:23:25 <mvaenskae> hm, does anyone know of a function which converts an int to a hex value?
10:23:41 <ertes> mvaenskae: see the Numeric module
10:23:58 <itnex> yes but newtype only allows 1 field
10:24:18 <dolio> So, glguy points out that 'data Foo = Foo !Int' is covered by -funbox-small-strict-fields.
10:24:23 <ertes> itnex: that's because a newtype is technically exactly the same
10:24:31 <ertes> as the field type
10:24:33 <dolio> So it's actually the same sort of memory layout as Int.
10:24:36 <itnex> oh thats wonderful
10:24:38 <itnex> ty
10:24:48 <dolio> Although there are minor differences that could cause overhead.
10:24:48 <hpc> ertes: what's the difference?
10:24:59 <hpc> (between newtype and strict-single-field)
10:25:03 <mvaenskae> ertes: hm, is there also a function which doesn't use read/show?
10:25:03 <ertes> hpc: pattern-matching:  f (C x)
10:25:26 <hpc> oh right, the whole fixed point thing that tuples have too
10:25:26 <dolio> I think -funbox-small-strict-fields is on with -O.
10:25:32 <hpc> that makes sense
10:25:33 <ertes> hpc: for newtypes, this one is not strict on x, for strict fields it is
10:25:42 <hpc> oh, and that
10:25:59 <ertes> mvaenskae: i don't think showHex uses show
10:26:25 <hpc> i was thinking of the thing where you have (x, y) = f (x, y) or something like that
10:26:41 <mvaenskae> because i have a list of triples [(a,b,c),(d,e,f)] and am having a bit of trouble to print that list in hex :/
10:26:42 <hpc> been too long since i saw the actual example and can't remember it exactly
10:27:38 <ertes> mvaenskae: the functions in 'Numeric' follow a pattern similar to 'showsPrec', so you can compose them
10:28:23 <ertes> > showChar '(' . showHex 5 . showString ", " . showHex 7 . showChar ')' $ ""
10:28:24 <lambdabot>  "(5, 7)"
10:28:32 <ertes> > showChar '(' . showHex 50 . showString ", " . showHex 70 . showChar ')' $ ""
10:28:34 <lambdabot>  "(32, 46)"
10:28:37 <ertes> better example
10:29:11 <ertes> mvaenskae: you can also use 'shows' or 'showsPrec' itself in there
10:29:13 <ertes> :t shows
10:29:14 <lambdabot> Show a => a -> ShowS
10:29:36 <ertes> > showChar '(' . showHex 50 . showString ", " . shows "bäh!" . showChar ')' $ ""
10:29:37 <lambdabot>  "(32, \"b\\228h!\")"
10:30:33 <mvaenskae> hm, this seems a lot of same function writing; maybe i can have that parsed with a foldr over the triples
10:31:18 <ertes> that's the nature of triples…  if the components are all numbers, consider defining a triple type that captures it
10:31:35 <ertes> data Triple a = Triple a a a  deriving (Foldable, Functor, Traversable)
10:31:44 <ertes> then you can just fold a Triple
10:31:55 <ertes> using foldr, foldl', etc.
10:32:20 <mvaenskae> my haskell-fu is not yet sooo strong, but i will try getting my program done and let you guys have a look at it then once i am finished :)
10:35:26 <ertes> mvaenskae: the reason you can't just fold a tuple is that each component may be of a different type, so you would have to write a special folding combinator
10:35:48 <ertes> mvaenskae: but you can ignore (,,) and just make your own triple type, which enforces all components to be the same…  that's what Triple above is
10:36:11 <ertes> when you do that and write the "deriving" stuff, haskell basically gives you map, fold and traversal for free
10:36:33 <ertes> @let data Triple a = Triple a a a  deriving (Foldable, Functor, Traversable)
10:36:34 <lambdabot>  Defined.
10:36:44 <ertes> > fmap (2*) (Triple 3 4 5)
10:36:45 <lambdabot>      No instance for (Show (Triple b0))
10:36:45 <lambdabot>        arising from a use of ‘show_M493570540885760789827211’
10:36:45 <lambdabot>      In the expression:
10:36:48 <ertes> oh
10:36:49 <ertes> @undef
10:36:50 <lambdabot> Undefined.
10:37:00 <ertes> @let data Triple a = Triple a a a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
10:37:01 <lambdabot>  Defined.
10:37:05 <ertes> > fmap (2*) (Triple 3 4 5)
10:37:06 <lambdabot>  Triple 6 8 10
10:37:45 <Iceland_jack> > toList (Triple 3 4 5)
10:37:46 <lambdabot>      Ambiguous occurrence ‘toList’
10:37:46 <lambdabot>      It could refer to either ‘Data.Foldable.toList’,
10:37:46 <lambdabot>                               imported from ‘Data.Foldable’ at /tmp/mueval102...
10:37:46 <mvaenskae> i am trying to covert a real to a hex basically (given some normalization to the real) and i can convert it to an int and print that tuple nicely with "mapM_ print rgbAsInts" but i am uncertain how to do push "showHex" in there :/
10:37:51 <Iceland_jack> > Data.Foldable.toList (Triple 3 4 5)
10:37:52 <lambdabot>  [3,4,5]
10:38:33 <ertes> mvaenskae: what format do you need?
10:38:42 <Iceland_jack> mvaenskae: What is the type of 'showHex'? Something like this may work
10:38:43 <Iceland_jack>     mapM_ (putStrLn . showHex) rgbAsInts
10:38:51 <Iceland_jack> If 'showHex :: _ -> String'
10:39:03 <ertes> it isn't
10:39:13 <geekosaur> :t mapM_ (putStr . flip showHex "") ?rgbAsInts
10:39:14 <lambdabot> (Integral a, Show a, Foldable t, ?rgbAsInts::t a) => IO ()
10:39:24 <pikajude> hey, i'm using lifted-async and lifted-base and i'm wondering if it's possible or a good idea to use unexceptionalio in my code
10:39:46 <Iceland_jack> Ah, from base
10:40:13 <Iceland_jack> ertes: So it's a 
10:40:13 <Iceland_jack>     showHex :: _ -> _ -> String
10:40:13 <Iceland_jack> function ;)
10:40:21 <mvaenskae> ertes: basically i would like to parse files of the following type and have the the numbers in there converted (between <real></real>) using haskell https://raw.githubusercontent.com/carloscuesta/materialshell/master/osx/iterm/materialshell-dark.itermcolors
10:40:21 <geekosaur> it's ShowS
10:40:28 <Iceland_jack> ShowS = String -> String
10:40:33 <geekosaur> yes
10:41:13 <geekosaur> a smarter conversion would actually use ShowS instead of shortcircuiting it by passing "" like I did >.>
10:41:50 <ertes> mvaenskae: the code from the link is the source format?
10:41:54 <mvaenskae> right now i want to just convert the numbers, i don't care about the mapping of the colours to the original key they belonged to, that i can fix later by using proper types i guess, but for now i just wanted to extract and convert them nicer
10:42:25 <mvaenskae> that is the input, my code as of now is erm... i can upload it, but please don't hit me for writing bad haskell D:
10:42:49 <ertes> mvaenskae: what's important is that you end up with a list of triples
10:42:50 <mvaenskae> i have yet to grasp IO and in our lecture we were bascially told "oh, you use IO? please don't use it, it's bad and will hurt you"
10:42:58 <ertes> mvaenskae: and you want to "show" that list somehow
10:43:16 <ertes> mvaenskae: is that accurate?
10:43:33 <nitrix> How does one convert from Scientific to Int ?
10:43:53 <ertes> nitrix: most likely 'round'
10:43:59 <ertes> nitrix: or 'floor' or 'truncate'
10:44:04 <ertes> depending on the semantics you want
10:44:16 <nitrix> Thanks.
10:47:36 <mvaenskae> ertes: https://bpaste.net/show/3a7bde2b6b7a this is the code so far and i would like to eventually have the input i mentioned be parsed and have the following output --"Colour 1: #f33di7\n"--
10:48:31 <mvaenskae> for the moment to check if i am doing it all correct i would like to just print the single colour channel components (r,g,b) and have that then later mapped to the proper colour definition
10:50:11 <mvaenskae> and yes, i know my program is ugly on the string parsing, but strings are ugly anyways so there's that
10:53:01 <Welkin> mvaenskae: how come none of your functionas have a type signature?
10:53:06 <pi_> If I'm generating a list of (Time,Double) - with Double representing the amplitude of a sound - what library should I use to play that sound at runtime ?
10:54:12 <marchelzo> Welkin: getLines does
10:54:35 <marchelzo> getLines = fmap lines . readFile
10:55:02 <mvaenskae> Welkin: because that is something i am not yet comfortable with for most and i would rather concentrate on coding that deriving type signatures in the beginning
10:55:41 <Welkin> mvaenskae: but that is how you program in haskell, by first specifying the types
10:55:52 <Welkin> the types are not something you add later, they are the foundaton of the program
10:56:00 <mvaenskae> Welkin: not if i don't know what is all needed
10:56:30 <pi_> Explicit types also help to have clearer compiler error messages
10:56:32 <Welkin> mvaenskae: have you looked at any of the resources yet? Like the cis course?
10:56:42 <Welkin> it will help you a lot
10:56:53 <Welkin> @where learnhaskell -- mvaenskae 
10:56:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:57:02 <mvaenskae> and that is not what we were taught so there's that... *sigh* i sometimes love academics where theory not related to programming is of utmost importance but not the actual programming itself
10:57:15 <Welkin> what?
10:57:18 <Welkin> this is not theory
10:57:25 <Welkin> this is programming
10:57:28 <mvaenskae> that is what i mean
10:57:33 <Welkin> the type system is half of the language in haskell
10:57:48 <monochrom> I wouldn't draw a line between theory and programming.
10:58:15 <mvaenskae> anyways, does that answer my question of how to convert to hex? because i don't think it does :)
10:58:16 <monochrom> I respect drawing a line between useful and not-yet-useful, but that's a different line.
10:58:21 <Welkin> trust me, once you write down the types, it becomes incredibly easy to write your programs
10:58:40 * hackagebot test-fixture 0.2.0.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.2.0.0 (lexi_lambda)
10:58:51 <monochrom> in fact a lot of "practical" stuff becomes not-useful under my line.
11:00:29 <monochrom> an expert would not need to write type signatures to remind themselves what's going on. but you are not an expert yet.
11:00:47 <Welkin> monochrom: that is bad practice anyway
11:00:48 <monochrom> and yet, an expert tends to write more type signatures.
11:00:58 <Welkin> even the compiler complains when you lack top-level type declarations
11:01:17 <monochrom> it's ironic, eh? the person who doesn't need it does it more; the person who needs it more doesn't want to do it.
11:02:36 <monochrom> to convert to hex, keep using divMod with divisor 16.
11:02:43 <mvaenskae> let's just say that i am still having trouble deriving types and tbh, how does one draw from (.) . (.) the type in his head?
11:02:58 <ExcaliburZero> How do you work with IO in Hspec? Currently I am trying to test a Parsec JSON parser against a large JSON file that would be unreasonable to type into the spec file. I can access the contents of the file using `readFile` in order to use it to test the parser, however I am unsure of how to do this in the contents of an hspec spec.
11:03:02 <mvaenskae> i for one need a couple minutes of concentration
11:03:08 <monochrom> why are you asking about "(.) . (.)"?
11:03:18 <Welkin> mvaenskae: it will come in time
11:03:18 <monochrom> do it need it for hex?
11:03:22 <Welkin> just start with the basics
11:04:09 <mvaenskae> just as an example we were asked to derive the type from... it took a lot longer than i anticipated
11:04:11 <monochrom> I can do "(.) . (.)", in fact I already wrote my solution on lpaste a long time ago. but it is advanced and it is unlikely you need it.
11:04:42 <Welkin> I have never used (.) . (.)
11:04:52 <Welkin> there are always many ways to write the same thing
11:04:57 <pi_> :t (.) . (.)
11:04:58 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:04:59 <monochrom> is it a strawman attack? pick a difficult example, so that you can perpetuate "types are useless theory"?
11:05:00 <Welkin> not everything needs to be pointfree
11:05:52 <monochrom> ignoring the fact that working out the type of "if b then (x, True) else (False y)" is easy and useful?
11:06:01 <Welkin> monochrom: haha, calm down
11:06:09 <monochrom> s/False y/False,y/
11:06:14 <Welkin> mvaenskae is asking for help, don't shame them
11:08:09 <mvaenskae> this was asked in an exercise and i was very confused and still am kinda but i think given around 5 minutes i could derive it myself again
11:08:46 <monochrom> are you sure that that exercise is aimed at your level?
11:08:49 <mvaenskae> it just showed me how complex the type system is (and i have yet to throw in monads properly in them... *shudder*)
11:09:08 <Welkin> mvaenskae: it is not as complex as you think
11:09:12 <Welkin> but you can make it as complex as you want
11:09:27 <marchelzo> that is deep
11:09:32 <Welkin> I have programmed many production applications in haskell, yet I have no idea what people are talking about in here half the time
11:09:37 <Welkin> you can make it as complex as you want
11:09:40 <EvanR> i just finished the idris chapter 2 exercises, in retrospect haskells type system is complex, but beginners dont have to know that ;)
11:09:44 <mvaenskae> it very well might not but we learn haskell to forget it because noone uses it afterwards really in the courses so it's a shame
11:10:00 <marchelzo> is there a quote-grab bot in here?
11:10:05 <mvaenskae> and because i want to like it i am writing a couple programs now which i think haskell is quite useful for
11:12:15 <Squarism> what webservers should i use if i want to use websockets? I know very little about websockets / comet. But ive gathered websockets = 2016?
11:14:00 <EvanR> mvaenskae: if you only learn stuff because a course makes you, yeah youll probably forget it
11:14:17 <EvanR> stick to what youre actually interested in
11:14:53 <pi_> EvanR : I couldn't tell how much I agree with you.
11:15:15 <mvaenskae> i want to learn haskell because i think it will later make prototyping awesome
11:15:32 <mvaenskae> and sometimes C/Java just plain out are too complicated
11:15:54 <monochrom> yes
11:16:45 <mvaenskae> even though i could have done this much quicker with them I want to use haskell
11:17:41 <dmj`> mvaenskae: the prototype might end up being better than the real thing
11:17:51 <Welkin> mvaenskae: soon it will be the opposite
11:18:15 <Welkin> once you get used to haskell, you won't want to use java any more
11:18:31 <monochrom> no no
11:18:56 <EvanR> you wont be able to stand java even if you wanted to use it anymore
11:18:57 <monochrom> once you get used to Haskell, you will write like "public class Deep where" and "if (n==0) then" in Java.
11:19:13 <monochrom> happened to be a few days ago
11:21:10 <mvaenskae> java is part of android programming and C is to learn about hardware and make it go haywire for me
11:21:12 <nitrix> import Control.Lens hiding (|>)
11:21:16 <nitrix> I'm getting a parse error.
11:21:28 <monochrom> one more pair of parentheses
11:21:41 <nitrix> Oh. Oh yeah, sorry, I'm distracted.
11:22:17 <Welkin> mvaenskae: haskell has a very good C api, which you might like
11:23:03 * dmj` mutters something about implementation details
11:25:00 <monochrom> Java is used in my 2nd year data structure course.
11:25:39 <Welkin> you can run haskell on the JVM too, using Frege
11:25:48 <monochrom> What you don't know, though, is that Haskell is used when I verify or even generate solutions against my Java solutions.
11:25:51 <EvanR> thats not haskell though
11:26:01 <monochrom> (that's right, I am the instructor)
11:26:17 <EvanR> do you tell the students that
11:26:21 <monochrom> yes
11:26:33 <EvanR> do they say "wtf arent we using haskell ..."
11:26:36 <Welkin> monochrom: why would a data structures course use java?
11:26:37 <Welkin> mine used c
11:26:56 <EvanR> many universities dropped C for java a while back
11:27:03 <EvanR> im sure it was a corporate decision
11:27:14 <Welkin> well, I was technically in computer engineering, not cs
11:27:24 <monochrom> because Java : Haskell :: English : Esperanto or whatever
11:27:27 <Welkin> in cs they did teach it in java I think
11:27:28 <EvanR> "C is old hat, lets update"
11:28:55 <dmj`> my data structures course didn't use computers
11:28:58 <monochrom> there is starter code I give to students that goes "public class Answer { public boolean x; public int y; }"
11:29:02 <Welkin> lol dmj` 
11:29:13 <Welkin> well, neither did mine, except to run the homework
11:29:21 <Welkin> of course, everything else was written on paper
11:29:27 <monochrom> and I add the comment "// This is so wrong. Why doesn't Java have sum types like Haskell and Scala do?"
11:30:07 <monochrom> but this course is an imperative data structure course, so I would like to stick to an imperative language
11:30:08 <Welkin> monochrom: what about union?
11:30:16 <dmj`> yea, I felt bad for our graders, we just mimicked the CLRS pseudo code, those who used TeX got higher marks
11:30:54 <monochrom> and between {C, C++, Java, Python, Haskell}, the common denominator is {Java, Python}. then I simply picked the more typed one.
11:31:32 <monochrom> Does Java have union?
11:31:43 <Welkin> yes
11:33:11 <ertes> there is a point when types get so cumbersome to use that you may want to go with the less static one
11:33:45 <EvanR> "The designers of the Java programming language chose to omit the union construct because there is a much better mechanism for defining a single data type capable of representing objects of various types: subtyping."
11:33:59 <EvanR> "A discriminated union is really just a pallid imitation of a class hierarchy."
11:34:24 <EvanR> http://www.oracle.com/technetwork/java/page1-139488.html
11:34:35 <Welkin> really? I have seen union being used in a data structures textbook in java
11:35:04 <EvanR> might be something else...
11:35:16 <EvanR> interface UnionType extends TypeMirror or something
11:35:19 <Welkin> strange... maybe I am thinking of c++
11:35:51 <ertes> why haskell is still growing slowly compared to other languages: "wow, haskell is amazing!  i need to invent a programming language with this subset of features"
11:36:29 <monochrom> yeah, see, I was ahead of them years ago: ...
11:36:34 <monochrom> @quote monochrom invent
11:36:34 <lambdabot> monochrom says: When I invent a programming language I will use Word100 to stand for 8-bit words. :)
11:36:42 <monochrom> err, no, not that one.
11:37:18 <monochrom> @quote monochrom download
11:37:19 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
11:37:59 <ertes> go is basically a love letter to erlang and haskell, but something that can be sold as a Google Product
11:38:03 <monochrom> but yeah, Word100 sounds like a great idea
11:38:07 <haskell720> (beginner) I have an infinite list that looks something like  [(1,'a'), (2,'b'), (3,'c'), (3,'d'), (4,'e') ...]
11:38:08 <ertes> and just terrible enough that you can sell support
11:38:23 <haskell720> i want to return the element where it stops getting bigger, e.g. (3,'c')
11:38:37 <haskell720> it seems like i can do this with a recursive function pretty easily
11:38:50 <Welkin> haskell720: look ahead by one element
11:38:51 <ertes> haskell720: the recursive function is probably the nicest way to do it
11:38:54 <Welkin> check two elements at a time
11:38:57 <haskell720> but i *should* be able to do it with a fold, but am having trouble wrapping my mind around how to do this as a fold
11:39:08 <haskell720> i get the picture that it's foldr, since it's an infinite list
11:39:16 <ertes> haskell720: you can't do it with a fold
11:39:22 <monochrom> it is a few steps away from foldr
11:39:28 <dmj`> ertes: go is weird lookin', that array syntax...
11:39:34 <haskell720> but how do i think about authoring what should be a simple function? what makes this hard is that when i think about foldr, it goes right to left
11:39:51 <haskell720> ok so *why* can't i think of this as foldr?
11:39:57 <ertes> haskell720: pattern recoginition basically…  you memorise the shape of foldr
11:39:59 <monochrom> "right to left" is wrong intuition for foldr. two things wrong about it
11:40:10 <monochrom> first thing is that foldr is still left to right
11:40:13 <ertes> haskell720: whenever you see something that looks like foldr, you can probably use foldr
11:40:20 <exio4> unrelated, but what's the intuition on "right to left" and "left to right" things? I never grasped those .. analogies?
11:40:45 <monochrom> second thing is that foldr lets you consider one item at a time, not two consecutive items. so, no comparing.
11:40:49 <Welkin> exio4: the grouping of the parentheses for the final expression
11:41:01 <ertes> haskell720: at some point this becomes…  uhm…  what's the english word?  when you're used to something so much that it becomes effortless
11:41:04 <haskell720> @monochrom but what about the accumulator, do i think in terms of an accumulator with foldr?
11:41:04 <lambdabot> Unknown command, try @list
11:41:09 <haskell720> it could store the biggest thing I've seen so far
11:41:30 <monochrom> foldr has no accumulator.
11:41:42 <lpaste> glguy pasted “finding where the list stops growing” at http://lpaste.net/167971
11:41:49 <monochrom> foldl has one, but you're asking foldr.
11:41:51 <glguy> You can always go that route if the goal is to foldr it
11:41:55 <exio4> xs=[a,b,c] ; foldr f z xs = f a (f b (f c z))
11:42:03 <exio4> Welkin: I don't see it
11:42:42 <ertes> haskell720: another option is to preprocess a list such that it can be processed with the foldr pattern
11:42:42 <Welkin> > foldr f g [x, y, z] :: Expr
11:42:44 <lambdabot>  f x (f y (f z g))
11:42:51 <Welkin> > foldl f g [x, y, z] :: Expr
11:42:52 <lambdabot>  f (f (f g x) y) z
11:43:00 <glguy> haskell720: that paste was for you
11:43:06 <haskell720> ty
11:43:32 <monochrom> exio4, if I bring you back to kindergarten and ask you to do basic arithmetic "3+(1+(4+1))", you will do "4+1" first, then "1+5", etc. In this sense it is right-to-left.
11:44:01 <monochrom> I am not defending it. I am just outlining what other people think.
11:44:06 <exio4> monochrom: ah, that somehow makes sense
11:44:07 <ertes> to be honest i don't think foldl and foldr have much in common
11:44:32 <exio4> sounds complicated if you are trying to understand it :P 
11:44:36 <ertes> their names suggest that there is some interesting duality, but really they are completely different patterns
11:44:52 <monochrom> And their problem is that they conflate parsing with evaluation order. "3+(1+(4+1))" is supposed to only tell you how to parse. You choose your evaluation order.
11:44:53 <Welkin> they are both folds
11:45:07 <ertes> Welkin: strictly speaking only foldr is a fold
11:45:27 <exio4> monochrom: 0*(3425*(234523*34243)) ? :P 
11:45:32 <monochrom> Yeah!
11:45:52 <monochrom> @quote monochrom 0\*
11:45:53 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748) and find one single student who faithfully evaluate 389238493+97283748 first.
11:46:01 <ertes> exio4: you scanned for 0 using a bird's eye view
11:46:19 <ertes> exio4: it involved an actual search algorithm that you didn't notice because you're used to it
11:46:31 <Welkin> I suppose another way to think about left vs right fold is that for foldl, the accumulator begins accumulating on the left side of the input, and on the right side for foldr
11:46:38 <EvanR> i dont know how to evaluate 3+(1+(4+1)) in any other order, haskell or not ...
11:46:47 <ertes> Welkin: foldr has no accumulator
11:46:56 <exio4> ertes: that's part of algorithm doing the evaluation :p
11:47:22 <monochrom> EvanR, how about I change the example to x || (y || (z || t))
11:47:49 <EvanR> oh right, if the first term was zero that would allow a different strategy
11:48:11 <EvanR> like if x=True in the || version
11:48:34 <Welkin> I remember looking in the source for (*) I think it was, and it pattern matches for 0 and then short circuits
11:48:52 <Welkin> at least last year that was the case
11:48:59 <ertes> for which type?
11:49:02 <ertes> > 0 * undefined :: Integer
11:49:03 <lambdabot>  *Exception: Prelude.undefined
11:49:09 <Welkin> hmm
11:49:18 <exio4> > undefined * 0 :: Integer
11:49:19 <lambdabot>  0
11:49:23 <EvanR> dude
11:49:29 <ertes> that's…  weird
11:49:35 <monochrom> \∩/
11:49:36 <ertes> is that a GMP anomaly?
11:49:50 <glguy> GHC 8 doesn't do that, 7.10 did
11:49:50 * EvanR makes sure not to put unsafePerformIOs in the left operand
11:49:58 <jomg> i think that may have been a bug, considering it matches on the right
11:50:11 <glguy> jomg: It's not a bug in general to match on the right
11:50:16 <jomg> there was something on stackoverflow about that, iirc
11:50:28 <ertes> so lambdabot is GHC 7.10?
11:50:36 <jomg> glguy, sure, but it's certainly weird considering everything else seems to match on the left :P
11:50:38 <glguy> Anyway, don't rely on that "feature", GHC 8 doesn't preserve it :)
11:51:00 <ertes> > System.Info.compilerVersion
11:51:02 <lambdabot>  Not in scope: ‘System.Info.compilerVersion’
11:51:09 <ertes> @let import System.Info
11:51:11 <lambdabot>  Defined.
11:51:13 <ertes> > compilerVersion
11:51:14 <lambdabot>  Version {versionBranch = [7,10], versionTags = []}
11:51:17 <ertes> i see
11:51:30 <ertes> > undefined * 0 :: Int
11:51:32 <lambdabot>  *Exception: Prelude.undefined
11:51:33 <ertes> good =)
11:51:55 <glguy> > x * 0
11:51:56 <lambdabot>  x * 0
11:55:19 <haskell720> thank y'all. also for all the extra knowledge on short-circuiting. :)
11:55:28 <whittle> I’m trying to simplify a test: is there a good way for me to combine an assertion about a value and a function for extracting an inner value? 
11:55:42 <lpaste> whittle pasted “Assertion and extraction?” at http://lpaste.net/167975
11:56:18 <Welkin> whittle: pattern match on the value
11:56:50 <whittle> Welkin: Oh, right. Duh. 
11:56:51 <ertes> whittle: Either is a monad, and there is also a transformer variant, if you need it
11:57:21 <ertes> whittle: in simple cases (i.e. not a lot of repetition), you can also just use 'either'
11:58:21 <ertes> whittle: either (\_ -> assertionFailedOrWhatever) (\jwt -> ...) ejwt
11:58:40 <whittle> ertes: Thank you. I’m still not great at error handling in Haskell, but I feel like EitherT is something I should get better at using. 
11:59:00 <EvanR> or ExceptT
11:59:10 <ertes> whittle: i've used haskell since 2007, and i think i've only used EitherT once =)
11:59:17 <EvanR> ive never used EitherT
11:59:24 <EvanR> mainly because there are so many other equivalents
11:59:53 <EvanR> including building it into your one giant monad directly
12:00:28 <ertes> whittle: in the code sample you pasted, i'd have used 'either', just differently
12:00:33 <whittle> I read http://www.yesodweb.com/blog/2016/04/fixing-monad-either and came out feeling like I understood less. 
12:00:42 <whittle> ertes: I see what you mean now. 
12:01:08 <whittle> Thank you all; I love this community. 
12:01:55 <ertes> whittle: either (\_ -> assertFailure "Not Right") (\jwt -> ...) ejwt
12:02:55 <ertes> whittle: btw, if you're interested, the version you pasted suffers from a particular kind of illness: boolean blindness
12:03:23 <whittle> ertes: What, pray tell, is boolean blindness? 
12:03:36 <ertes> it has a formal knowledge gap between the assertion and the extraction similar to this:  unless (null xs) (print (head xs))
12:04:13 <ertes> the programmer checked that the list is not empty, proving that the 'head' is safe…  but it is knowledge only the programmer has…  the compiler does not
12:04:29 <Welkin> headMay
12:04:30 <Welkin> :D
12:04:43 <ertes> whittle: pattern-matching closes that gap
12:04:45 <Welkin> here's a good question for you
12:04:45 <EvanR> maybe versions arent always appropriate
12:05:11 <monochrom> @quote monochrom safeFromJust
12:05:11 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
12:05:12 <EvanR> divMay would be annoying
12:05:15 <ertes> whittle: foldr (\x _ -> print x) (pure ()) xs  -- this one doesn't have the gap
12:05:17 <divVerent> ertes: this is a bit interesting... how is that bad
12:05:19 <divVerent> and compare to:
12:05:21 <Welkin> for okasaki's queue implementation, he defined the api to include: empty, isEmpty/null, head, tail, snoc
12:05:29 <Welkin> but head and tail are unchecked
12:05:31 <divVerent> if null xs then print (head xs) else return ()
12:05:38 <divVerent> now the compiler has the knowledge, right?
12:05:40 <ertes> divVerent: that's the same code
12:05:44 <ertes> divVerent: nope
12:05:46 <EvanR> divVerent: nope
12:05:50 <ertes> divVerent: you just repeated my example =)
12:05:54 <divVerent> so the problem wasn't that "when" is just a library function?
12:05:56 <whittle> ertes: I’m going to read up on boolean blindness, but I think what you’re describing is what was bothering me about it. 
12:06:00 <divVerent> *unless
12:06:20 <divVerent> but yes, right, null is also not a builtin, but just in Prelude
12:06:26 <EvanR> this isnt exactly boolean blindness, but partial functions where the check is somewhere else. the check is closeby though
12:06:27 <divVerent> so technically the compiler isn't supposed to know what it does
12:06:40 <monochrom> divVerent: I do not argue over whether the compiler knows or not. However, I do argue: http://www.vex.net/~trebla/haskell/crossroad.xhtml
12:06:48 <Welkin> would there be a better way of defining this api?
12:07:00 <Welkin> without using headMay, tailMay
12:07:10 <EvanR> Welkin: you can check on dependent types
12:07:12 <Welkin> I have used Sequence as a regular queue before
12:07:14 <ertes> EvanR: it is boolean blindness…  the culprit lies secretly in the condition (a boolean that *we* know what it means, but the compiler does not)
12:07:24 <EvanR> condition checks arent necessarily booleans
12:07:29 <Welkin> I like the way you can pattern match on the head and get the tail at the same time
12:07:31 <whittle> I feel like, at this point in my career, I no longer trust that because a check and a statement that relies on that check start out next to each other, that there’s any guarantee that they’ll stay together over time. 
12:07:32 <EvanR> its that youre doing a check to see if a partial function will work
12:08:09 <ertes> whittle: this is the original article on boolean blindness: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
12:08:17 <monochrom> Welkin: Seq has viewL and viewR. dequeuing should do a similar thing, a sum type of "it's empty" + "it's non-empty, moreoever, the answer is ___"
12:08:46 <ertes> EvanR: it doesn't have to be boolean, but you're branching on a value that has some meaning the compiler doesn't understand
12:09:04 <monochrom> OK everyone, simply read my http://www.vex.net/~trebla/haskell/crossroad.xhtml and rest.
12:09:07 <divVerent> monochrom: I understand the theory, but don't get to the same conclusion :P
12:09:13 <Welkin> monochrom: yes, but I am talking about this implementation: data Queue a = Queue [a] [a]
12:09:18 <divVerent> I'm very sure there are cases where this kind of repetition is more readable
12:09:26 <divVerent> certainly not in the quoted sample, though
12:09:49 <monochrom> Welkin, why should the implementation matter? You don't know the implementation of Seq, yet this doesn't violate the existence of viewl and viewr
12:09:57 <divVerent> I suppose it's more readable exactly if you'd otherwise be calling the pattern-matched variable something like headXs
12:10:23 <Welkin> monochrom: let me check, perhaps I forgot how those work. I have only used them with ViewPatterns
12:11:17 <EvanR> ertes: a trusted view that you can pattern match on solves the problem you mentioned, however it doesnt automatically solve boolean blindness where the property youd like to guarantee is checkable by the computer, in which case youd need to return more information than just the tag
12:11:36 <EvanR> like Dec type in idris
12:11:48 <monochrom> divVerent: I believe that a long-time Schemer will find "if null xs then ... else ... head xs ... tail xs ..." more readable, and a long-time Haskeller will find "case xs of [] ... y:ys ..." more readable.
12:12:08 <divVerent> oh, what I meant is that it depends on the naming you need when using the variable
12:12:13 <EvanR> i can read the null case but it makes me uncomfortable
12:12:23 <ertes> EvanR: if you fork on (null xs), then in one branch you have a mental proof that xs is non-empty…  if you pattern-match, then you have a formal proof…  not necessarily an intuitionistic curry-howard-style proof, but a proof nonetheless
12:12:26 <divVerent> in some cases a bare "x" will be unreadable crap and "head xs" will tell you what you're actually doing there
12:12:28 <monochrom> Welkin: you don't have to use ViewPattern. "f s = case viewl s of ..." is Haskell 2010.
12:12:53 <divVerent> e.g. if there is parallelism between multiple similar statements
12:13:01 <divVerent> I think I once encountered such a case when logging
12:13:29 <ertes> EvanR: the knowledge gap above involves two components:  the branch together with the 'head'…  if you never use 'head' or any other unsafe function in the not-null branch, then there is no gap
12:13:29 <EvanR> ertes: its better to patern match when you can
12:13:35 <Henson_D> hello, could somebody help me with figuring out how to specify a type signature in a monad.  Here's a link to the relevant code: http://pastebin.com/xVA3WgAe . I'm getting the error "Couldn't match z with z1" saying that "'z' is a rigid type variable bound by" and so on.  How can I specify the type signature of something within a monad?
12:13:37 <monochrom> ok, I agree to choosing good names.
12:13:38 <Welkin> divVerent: you are a lumberjack?
12:13:42 <divVerent> no?
12:14:08 <monochrom> I am a computer scientist and I take log all the time.
12:14:11 <Welkin> Henson_D: (z :: SomeType)
12:14:19 <EvanR> ertes: there is still a gap though, but thats a different gripe than griping about the different kinds of boolean blindness
12:14:51 <EvanR> the view can return empty list if it wants to, even if its not empty
12:15:05 <divVerent> I admit I encountered this in C++ though - yes, in a subcase I did already have a reference to obj->someField, yet in that case I still repeated the obj->someField lookup in a logging statement as that was more consistent with the other field accesses in the same statement
12:15:19 <divVerent> so the Haskell example would probably be
12:16:22 <monochrom> The only reason why C, C++, Scheme, Lisp, Java.... (the list goes on and on) tells you to use predicates and selectors is because, just because, they don't provide pattern matching.
12:16:37 <divVerent> monochrom: not in my specific case though
12:16:43 <divVerent> (typing up a sample where I'd do the same in Haskell)
12:17:46 <monochrom> pattern matching is a pretty recent invention. circa 1980 with ML. much younger than Algol and Lisp.
12:17:57 <monochrom> probably even FP didn't have it.
12:18:16 <EvanR> if then else was definitely a bedrock foundation of all computation, from what i remember learning
12:18:25 <EvanR> im glad i recovered from that
12:18:27 <divVerent> case r of Rec {item = Foo f} -> print "Got Foo " ++ f ++ " from record " ++ (show $ item f) ++ 
12:18:38 <divVerent> " " ++ (show $ otherproperty f) ++ ...
12:18:40 <divVerent> yes, it's contrived
12:18:42 * hackagebot cpsa 3.3.2 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.3.2 (mliskov)
12:18:43 <monochrom> unless you tell me about how natural deduction already has it before even lambda calculus, which is true
12:18:59 <divVerent> oops, item r
12:19:12 <divVerent> yes, it's contrived, but I see a benefit from using "item r" here over "Foo f"
12:19:21 <divVerent> as it makes it more clear this is a field of the record I'm printing some fields of
12:19:36 <Henson_D> Welkin: does that mean I need to figure out what the type of z is and specify it in a type constraint, or is there some way I can leave it undefined?
12:19:57 <monochrom> wait, "item r" does not give you f. you will need "unFoo (item r)" to get f. :)
12:20:00 <ertes> EvanR: i think there are mainly two kinds of gaps:  knowledge gaps and totality gaps
12:20:02 <divVerent> basically, I'd personally say here that consistency trumps not repeating the same path to get to the same value
12:20:13 <ertes> EvanR: what you said sounds like the latter
12:20:14 <divVerent> monochrom: indeed, I don't want f
12:20:21 <divVerent> but the whole thing, which implements Show
12:20:43 <divVerent> assume there are multiple such debug logging statements
12:21:00 <divVerent> which each print a possibly different subset of the fields
12:21:20 <divVerent> but then I'd still find it nice that each field is accessed in each such statement the same way
12:21:43 <monochrom> I see.
12:26:02 <EvanR> ertes: its kind of a well-typedness thing too, if you think the "proper" type of head takes an extra argument, proof that the list isnt empty, then doing if then else wouldnt get you there
12:26:10 <EvanR> with the intermediate bool result
12:26:29 <EvanR> but neither does normal pattern matching in haskell
12:26:40 <_ohso> Question: If I have essentially a constant array, and I have a function that returns that array with a single element altered. Will every call of that function generate a new object, or is the compiler smart enough to really only do it once and reuse the same object everywhere?
12:26:41 <EvanR> since youre not necessarily talking about the same list
12:26:52 <xaviergmail> Could someone try to clear up why function composition is 'reversed' in writing?
12:27:14 <ertes> monochrom: if someone doesn't quite get the essence of your crossroad article, they might wrongly think that "case compare x y of …" is fine, even though it's another instance of conditional branching
12:27:24 <monochrom> because function application is reversed in writing. f (g x) = (f . g) x
12:28:03 <ertes> EvanR: you just remind me again how much i'd love to have dependent types
12:28:11 <xaviergmail> I sadly don't get it :\
12:28:26 <ertes> xaviergmail: convention
12:28:42 <monochrom> would you prefer f (g x) = (g . f) x?
12:28:51 <ertes> (f . g) x = f (g x)  -- there is no inherent advantage to any order, but it came this way from math
12:28:54 <EvanR> the problem is application
12:28:58 <EvanR> its lame
12:29:26 <ertes> _ohso: depends on the array library
12:29:28 <roconnor> Heh, I just got bit by the *non*-monomorphism restriction for once
12:29:38 <xaviergmail> I don't have any preference and from a previous google search I saw about >>> but I was just wondering why it was like that
12:29:47 <xaviergmail> If it comes from math I won't question it :P
12:30:40 <_ohso> ertes, oh, that surprises me.
12:30:47 <ertes> _ohso: no library for immutable arrays will guarantee altering an array in memory, but some can just save an array along with a set of altered elements, or similar…  if you want to ensure that you actually alter an element in memory, you have to use mutable arrays
12:31:23 <ertes> _ohso: immutable arrays are useful for bulk operations (mapping, folding, etc) or query-only scenarios
12:31:48 <Cale> xaviergmail: Well, it's just a convention. If Newton had used (x)f rather than f(x) a long time ago, we would probably have the opposite convention.
12:32:24 <ertes> _ohso: there are also data structures to make array modifications efficient while keeping them immutable, most notably finger trees
12:32:36 <Welkin> I also noticed there is no sorting algorithm for Array/Vector, but I see that it makes sense to just convert to a List, sort, and copy the elements back
12:32:47 <xaviergmail> Yeah :P I was wondering if it was that way because it allowed for some cool tricks or something
12:33:08 <ertes> Welkin: see vector-algorithms
12:33:27 <_ohso> It's an immutable array, but I want to produce some new arrays that are almost identical, yet have a few different elements. I'd prefer that 1) I don't have to redeclare all those elements that are the same and 2) not have it be recomputed everytime the function to create it is used.
12:33:37 <Cale> xaviergmail: Well, it is actually kind of nice in the case of lazy evaluation -- it sort of means that things are evaluated left-to-right.
12:33:47 <ertes> Welkin: they are for mutable arrays, but you can just use 'modify'…  and they are usually orders of magintude faster than sorting a list or a Seq
12:34:10 <Cale> If you have f (g (h x)), it's f which is evaluated first, and its parameter is bound to the as-yet-unevaluated expression g (h x)
12:34:31 <ertes> _ohso: do you need to refer to the old arrays once you have computed the updated ones?
12:35:02 <Welkin> ertes: I don't see a quicksort
12:35:11 <_ohso> I'm just trying to create a series of immutable arrays that get used as big constant objects, yet I want to declare them by relation to one another to prevent a boatload of code duplication.
12:35:22 <elucidata> is there a good haskell "cheat sheet" of sorts? 
12:35:36 <_ohso> Yes, the original value is used.
12:35:37 <elucidata> like a quick reference 
12:35:44 <ertes> Welkin: introsort is pretty much a better quicksort
12:35:46 <Welkin> elucidata: hoogle and hayoo
12:35:59 <Welkin> ertes: I see
12:36:17 <ertes> _ohso: how many elements per array?
12:36:26 <ertes> _ohso: and how many dimensions?
12:36:49 <elucidata> Welkin: thanks
12:37:03 <_ohso> One dimension, a couple hundred elements each.
12:37:22 <ertes> _ohso: then you probably don't want arrays in the first place…  use Map (from containers) or HashMap (from unordered-containers)
12:37:41 <ertes> _ohso: given a choice (order of keys irrelevant), then HashMap is generally faster
12:37:50 <ertes> -", then"
12:38:40 <ertes> _ohso: if possible, IntMap (from containers) is preferable to both
12:38:56 <ertes> both faster and smaller than both
12:39:04 <ertes> and all of them have the property that they are structure-sharing
12:39:08 <Cale> My general rule of thumb is just to always use Map until it's apparent that something more refined is needed for performance
12:39:51 <ertes> Cale: for me the default has become HashMap, and i have yet to see a case when it's *not* twice as fast
12:40:16 <_ohso> The elements of the array are functions, and O(1) access seems like a good idea (they are operations for a bytecode interpreter). Map seems an odd choice for that sort of thing.
12:40:19 <Cale> I've run into cases where HashMap was slower than Map
12:40:26 <ertes> Cale: the rationale is that the hashes produced by 'hashable' are actually pretty terrible =)
12:40:37 <ertes> for most machine-sized types it's just identity
12:42:38 <ertes> _ohso: O(1) with bad memory locality (→ bad cache behaviour) can be much slower than O(log n) with good memory locality
12:42:53 <ertes> _ohso: ultimately you have to benchmark, but my first instinct would be to go with one of the three
12:43:09 <Cale> _ohso: If you use a non-strict array, btw, you should be able to define the arrays in terms of one another, even with mutual recursion, and have it work
12:43:29 <ertes> you'll still duplicate the array though
12:43:39 <Cale> Well, you won't duplicate the elements
12:43:45 <Cale> Only the pointers to those elements
12:45:02 <Welkin> Cale> I've run into cases where HashMap was slower than Map <-- me too
12:45:25 <Welkin> I only tried on a small dataset a couple time though
12:45:27 <ertes> _ohso: what's the nature of your keys?  are your arrays always dense?
12:45:41 <monochrom> a binary search tree built hapzardly (i.e., new nodes at random times) can be cache-nonlocal too.
12:45:41 <ertes> _ohso: these are two different questions
12:46:24 <monochrom> moreover it uses more memory and pushes the garbage collector over the edge
12:46:30 <_ohso> keys are essentially a byte (0-255) and yes every element MUST be populated with something.
12:46:42 <EvanR> then you might want a static map
12:46:53 <Cale> With regard to Map, it's generally easy to switch from Map to something more particular, but it won't always be a refactoring for performance in the direction of HashMap -- sometimes you might want to change the key type, and maybe there won't be a good Hashable instance, while Ord is a little easier to come by.
12:46:57 <monochrom> computing is hard. the only way to win is wait 5 more years for a faster computer.
12:47:05 <ertes> _ohso: you could get the best of both worlds by using a finger tree
12:47:22 <ertes> _ohso: then you can use actual dense arrays in memory, but you can manipulate them without duplication
12:47:23 <EvanR> 256 keys... ?
12:47:56 <Cale> monochrom: They only seem to make computers which use less power now
12:48:23 <Welkin> multicore
12:48:27 <ertes> even the core count doesn't seem to increase
12:48:31 <EvanR> yeah the geek craze has become, wag the dog style, with how little power you can use
12:48:48 <EvanR> reverse epeen
12:49:03 <monochrom> I see. this is hopeless. all is lost. use a linked list.
12:49:21 <_ohso> The array index is a byte. The elements are functions.  The array never changes, but I need a half dozen similar ones and don't want to define the entire array 6 different times, but rather once, and then define the others by how they differ.
12:49:37 <ertes> how many of you have to charge their phones every day?  in other words: i like the direction of less power consumption =)
12:50:06 <ertes> _ohso: are those index-only?
12:50:09 <monochrom> yes, I recharge daily.
12:50:12 <ertes> _ohso: all of them?
12:50:31 <ertes> _ohso: if yes, you could just wrap the array by a function
12:50:33 <_ohso> index-only?
12:50:41 <ertes> _ohso: you only ever ask for individual elements?
12:50:45 <_ohso> oh, yes
12:51:23 <ertes> _ohso: in haskell indexing an array and applying a function that indexes an array are pretty much the same thing
12:51:24 <EvanR> i cant seem to find the Data.Map replacement which allocates a fixed size vector 
12:51:33 <monochrom> If you use 6 immutable arrays, the code can look like you define the first and then modulate it for the other 5, and the reality can still be 6 separate arrays.
12:51:34 <ertes> _ohso: so just unify the two notions
12:51:51 <ertes> _ohso: myArray ix = if ix == 15 then f else someActualArray ! ix
12:51:53 <monochrom> and since each is small, for speed purpose I still recommend having 6 arrays.
12:52:07 <Welkin> haha, wow introsort is pretty crazy
12:52:11 <Welkin> so many optimizations
12:52:18 <monochrom> and for reasoning purpose the code can still read like one array plus 5 variations.
12:52:41 <monochrom> which is the code ertes just wrote.
12:52:49 <_ohso> Wow, you all lost me there.
12:53:01 <ertes> _ohso: because we're proposing different solutions =)
12:53:05 <monochrom> actual code loses you?
12:53:27 <monochrom> err, ertes's code is not what I meant. nevermind.
12:53:29 <ertes> _ohso: my solution is: one array, six different interfaces to it
12:53:38 <ertes> _ohso: monochrom's solution is:  six arrays
12:54:02 <Welkin> or you can use a list :D
12:54:08 <ertes> which one is better depends on the quality of branch prediction and the size of your L1 cache =)
12:54:10 <_ohso> ertes, I get yours, although that seems a bit unweildy since there may be 20-30 changes...that's a lot of if's.
12:54:23 <ertes> _ohso: six different arrays then
12:55:57 <_ohso> I was wondering if I had:   foo = myArray // [myChanges]
12:55:57 <ertes> there are still ways to share as much as possible, but at this scale i'd say: don't bother
12:56:20 <_ohso> Will the computation to alter myArray get run everywhere I use foo, or only once?
12:56:28 <monochrom> then you have two physical arrays, foo and myArray
12:56:29 <ertes> only once
12:56:52 <_ohso> ertes, only once - that answered my original question. Thanks.
12:56:53 <ertes> _ohso: the reason may sound a bit peculiar:  you gave it a name
12:57:25 <_ohso> Yes, it would be named.  :)
12:57:42 <_ohso> I was hoping that would be the case, but I wasn't sure.
12:58:04 <ertes> has a name + is monomorphic → is computed only once and then shared
12:58:56 <_ohso> I'm fine with them being six different arrays...I just don't want to have 6 big lists of hand typed function names, re: maintainability  and didn't want them being recomputed unnecessarily.
12:59:25 <_ohso> "has a name + is monomorphic → is computed only once and then shared"  --- very good to know
13:01:16 <ertes> with that in mind it often pays off performance-wise *not* to write local type signatures, unless you're very careful to reproduce what the monomorphism restriction would come up with
13:04:41 <saurabhnanda> :t getEnv
13:04:42 <lambdabot>     Not in scope: ‘getEnv’
13:04:42 <lambdabot>     Perhaps you meant ‘getAny’ (imported from Data.Monoid)
13:06:43 <_ohso> ertes, monomorphic = has a concrete type?
13:07:31 <EvanR> monomorphic = not polymorphic = no foralls
13:08:14 <saurabhnanda> can anyone help me with this: https://groups.google.com/forum/#!topic/yesodweb/bMDb_NtAG58
13:08:36 <saurabhnanda> how do I configure Google-auth for a Yesod app where the clientId & clientSecret are coming from environment variables?
13:09:42 <_ohso> EvanR, I've seen haskell code with forall in it. I will not pretend to understand any of it though. So I definitely won't be writing any soon.
13:10:24 <EvanR> foralls are often omitted for brevity
13:10:34 <EvanR> map :: forall a b . (a -> b) -> [a] -> [b]
13:10:39 <EvanR> map is polymorphic
13:10:49 <lowercase> has anyone tried using threepenny-gui for multi-page apps? or would I be better off using a more normal webserver approach? i'm making an app that would lend itself well to a web gui but that would be run locally
13:11:44 <_ohso>  map :: forall a b . (a -> b) -> [a] -> [b]     is the same as   map :: (a -> b) -> [a] -> [b]            ?
13:11:53 <EvanR> yes
13:11:56 <ertes> lowercase: is threepenny-gui still maintained?
13:11:57 <_ohso> oh.
13:12:32 <lowercase> ertes, last update 12th feb. 2016
13:12:39 <EvanR> _ohso: a type which looks like forall x . something(x) means you have permission to pick any type you want, remove the forall, and substitute your type inthe body whereever x appears free
13:12:40 <lowercase> ertes, so I guess it is
13:12:45 <ertes> _ohso: note that "has foralls" is not the same as "refers to type variables"
13:13:03 <_ohso> So monomorphic means no polymorphic type in the signature.
13:13:07 <monochrom> be careful. that "you" refers to the user, not the author.
13:13:24 <ertes> _ohso: nope…  it means "no foralls", as EvanR said
13:13:28 <EvanR> so map :: (Int -> Char) -> [Int] -> [Char] is a valid specialization of maps fully polymorphic type
13:13:44 <EvanR> ertes: well i was ignoring rank 2
13:13:59 <Iceland_jack> ghci> :t map @Int
13:14:00 <Iceland_jack> map @Int :: (Int -> b) -> [Int] -> [b]
13:14:00 <Iceland_jack> ghci> :t map @Int @Char
13:14:00 <Iceland_jack> map @Int @Char :: (Int -> Char) -> [Int] -> [Char]
13:14:05 <monochrom> the user of map gets to say "I want a=Int b=Char today". the author doesn't.
13:14:07 <_ohso> so is map :: (Int -> Char) -> [Int] -> [Char]   not monomorhpic?
13:14:27 <EvanR> thats monomorphic
13:14:27 <ertes> _ohso: here is an example:  f :: forall a. (Num a) => a -> a; f x = y + y  where y :: a; y = x*x
13:14:32 <ertes> _ohso: y is monomorphic
13:14:49 <ertes> (i'll ignore higher-rank types for now)
13:15:14 <ertes> _ohso: oh, and the example assumes -XScopedTypeVariables
13:15:25 <ertes> so the inner 'a' is actually the same as the outer 'a'
13:16:10 <_ohso> I think I get it a bit now, thanks.  :)
13:16:22 <Welkin> I like this api for queue
13:16:42 <Welkin> dequeue $ empty `snoc` 1 `snoc` 2 `snoc` 3
13:16:51 <_ohso> My arrays would definitely be monomorphic.  :)
13:17:05 <ertes> _ohso: it means the user (in this case 'f') doesn't get to choose the type of the named thing (in this case 'y')
13:17:13 <Welkin> maybe I should steal |> from Sequenece for infix snoc
13:17:45 <_ohso> cool
13:18:03 <saurabhnanda> anyone help with https://groups.google.com/forum/#!topic/yesodweb/bMDb_NtAG58 please?
13:18:45 <_ohso> I probably could've chosen something simpler for my first Haskell program. :)
13:19:52 <Welkin> saurabhnanda: just add googleEmail to your auth plugins list in your Foundation.hs, and convert the String you get from getEnv into Text
13:20:11 <Welkin> http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#v:pack
13:23:56 <HoloIRCUser1> Welkin, the problem is not string vs text. The problem is string vs IO String
13:24:37 <Welkin> eh?
13:24:38 <EvanR> saurabhnanda: to get config data like that, youll need to get it in IO and then somehow pass it around
13:24:46 <EvanR> i think weve had this discussion before ;)
13:24:56 <Welkin> nakedString <- IOString
13:25:10 <Welkin> everything ins Yesod is in IO, pretty much
13:25:17 <Welkin> if it is inside a Handler, it is IO
13:25:30 <Welkin> but for configuration, you want to store it in your foundation datatype
13:25:37 <Welkin> so grab it in Application.hs
13:25:53 <saurabhnanda> Correct. I managed to do that everywhere else but got stuck here, because this function definition is out of my control. Its type Sig is defined by the typeclass
13:26:26 <Welkin> then grab the data when you start the application in Application.hs, then add that information to your foundation datatype
13:26:33 <Welkin> which is readable everywhere in the program
13:27:01 <EvanR> saurabhnanda: Sig ?
13:27:06 <Welkin> I have taken the lazy way out before though
13:27:12 <saurabhnanda> Welkin, evanr let me show you example on yesod site 
13:27:18 <Welkin> which is to call getEnv and lookup the data inside each handler that needs it
13:27:25 <Welkin> it's not that big of a problem though
13:27:30 <_ohso> Thanks for the help, all.
13:27:31 <Welkin> only a few functions would use/need it
13:27:32 <mvaenskae> cheers, so it seems i am very close to my goal, just have to do some sorting of the output to have it copy-pasteable :) anyways, can someone give it a look and tell me if my type definitions make sense and what i should parameterise more? (i have worked up to line 65 and was then stumped if that is actually nice of me to do) https://bpaste.net/show/73e187ae234b
13:28:58 <saurabhnanda> How will you change the first example on this page to take client id and secret from environment variables? 
13:29:03 <saurabhnanda> http://www.yesodweb.com/book/authentication-and-authorization
13:29:47 <Welkin> you don't pass the information in there
13:29:51 <merijn> mvaenskae: Well, processing XML (?) as String using splitAt, etc. is rather ugly but other than that it looks ok
13:29:52 <Welkin> you do it in your handler
13:30:03 <mvaenskae> merijn: how else would i do that? :)
13:30:04 <EvanR> whats the type of getAuthId
13:30:04 <Welkin> I have nevr used googleEmail, so I am not sure how it works
13:30:34 <merijn> mvaenskae: There's a bunch of XML libraries around, xml-conduit is fairly usable, imo
13:30:37 <mvaenskae> oh, i just saw there are also other keys... grrr, i why D:
13:30:43 <saurabhnanda> In my handler? Isn't the v point of yesod auth plugibs to avoid such boilerplate.
13:31:05 <merijn> mvaenskae: Which would let you do things like "get me all key tags"
13:31:11 <mvaenskae> merijn: i tried getting the filtering done on my own just to myself strings a lot more :)
13:31:19 <saurabhnanda> Evanr, very complicated
13:31:29 <Welkin> saurabhnanda: lol, no
13:31:36 * EvanR throws a chair at yesod
13:31:43 <mvaenskae> i specifically am only trying to match some keys, i should actually make the filtering better i think
13:32:59 <EvanR> also at google for pushing this awful oauth crap
13:33:27 <saurabhnanda> Isn't the problem the type of authPlugins, which seems to be a pure function, but I want it to be an import IO value. 
13:33:38 <Welkin> I have only used the browserID plugin
13:33:40 <Welkin> it works fine
13:33:49 <Welkin> I usually use my own custom email module though
13:34:09 <EvanR> saurabhnanda: being pure shouldnt be a problem, not letting you pass in the stuff you need to customize would be... im trying to understand where client id and client secret are in the first example at all?
13:34:25 <saurabhnanda> Up top
13:34:32 <saurabhnanda> Top Level decorations
13:34:37 <saurabhnanda> Declarations
13:34:44 <EvanR> oh, authPlugins...
13:34:50 * EvanR gets the type of authPlugins
13:34:58 <saurabhnanda> And used below in a typeclass instance
13:35:42 <mvaenskae> merijn: i do believe that i am emulating that behaviour quite closely on my own
13:35:49 <Welkin> oh wait
13:35:58 <mvaenskae> with the "get all tags of type X"
13:36:00 <Welkin> I misunderstood what you meant by that
13:36:28 <Welkin> like I said, I never used oauth or googleEmail
13:37:20 <merijn> mvaenskae: Sure, but this string approach with length and splitAt will be fairly slow
13:37:23 <saurabhnanda> Hmm, for me the question is not about this particular solution, but how hard it is to get things to compose in Haskell.  And how hard it makes library and API design. 
13:37:34 <mvaenskae> merijn: could i have some "magic matcher" which matches on removeFiltered either string A or string B? 
13:37:35 <EvanR> saurabhnanda: not making much sense to me since the example has authGoogleEmail clientId clientSecret which should be an AuthPlugin
13:37:47 <EvanR> but authGoogleEmail seems to not be a function at all in the docs
13:37:53 <Welkin> http://hackage.haskell.org/package/yesod-auth-1.4.13.1/docs/Yesod-Auth-GoogleEmail2.html
13:37:57 <EvanR> AuthPlugin m
13:38:23 <EvanR> i dont see how it takes arguments
13:38:31 <saurabhnanda> It's a plugin architecture
13:38:42 <saurabhnanda> It's a separate package
13:38:45 <Welkin> m is the Foundatiion datatype
13:39:21 <saurabhnanda> Welkin, didn't understand what you meant by foundation data type
13:39:30 <EvanR> i dont see how or where the id or secret would be used
13:39:47 <EvanR> maybe the example is for a diffeerent version of yesod-auth
13:39:49 <Welkin> which is typically App
13:40:06 <Welkin> you can extend App to include any data you want
13:40:33 <EvanR> Welkin: which doesnt help here unless you were writing a new plugin
13:41:04 <EvanR> were trying to figure out how to use existing Yesod.Auth.GoogleEmail
13:41:23 * EvanR was looking at an old version...
13:41:28 <saurabhnanda> Google email **2**
13:41:54 <Welkin> http://hackage.haskell.org/package/yesod-auth-1.4.13.1/docs/Yesod-Auth-GoogleEmail.html
13:41:57 <Welkin> deprecated
13:42:03 <Welkin> because google doesn't use it anymore
13:42:04 <EvanR> alright
13:42:36 <EvanR> so yeah you can create plugins with any client id and secret you want, but youre not going to be able to make new instances at runtime without stupid tricks
13:42:46 <EvanR> thats the problem
13:43:21 <saurabhnanda> Ye
13:43:36 <saurabhnanda> And environment variables are to be read at runtime
13:44:06 <EvanR> if the Gmail plugin didnt take parameters like this, and instead took App actions to get the keys, it would work
13:44:19 <Welkin> you don't need to use the provided Auth
13:44:21 <EvanR> then youd be able to smuggle the data to the plugin
13:44:22 <Welkin> you can write your own
13:45:00 <EvanR> Welkin: which kind of makes these packages useless? :(
13:45:08 <saurabhnanda> Yes
13:45:10 <saurabhnanda> Sadly
13:45:29 <saurabhnanda> Let @snoyman respond then
13:45:39 <Welkin> it is very common in yesod for people to write their own Authentication module
13:46:20 <Welkin> well, at least their own plugins
13:58:46 * hackagebot uri-bytestring 0.2.1.1 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.1.1 (MichaelXavier)
14:01:23 <k0ral> Hello
14:03:39 <merijn> hmmm, speaking of xml-conduit, anyone have experience with more elaborate use than me? I keep running into the annoying problem that, e.g. attribute returns [Text] instead of just Text, making it kinda annoying to extract attributes from tags
14:07:27 <mvaenskae> given a list, how can i best reorder it arbitrarily? i assume i can hardcode it but i am not certain how i could do that
14:08:00 <crough> what do you mean exaclty?
14:08:06 <mvaenskae> meaning [1,2,3,4,5,6,7,8] should be ordered [4,1,6,2,8,3,5,7]
14:08:50 <mvaenskae> i can only think of pattern matching with a lambda the length of the list
14:09:03 <ertes> mvaenskae: the best way is terrible…  you should use a different structure
14:09:08 <mvaenskae> which is fine, i have at most 25 fields iirc
14:09:39 <ertes> > 25*13
14:09:41 <lambdabot>  325
14:09:45 <Welkin> lol mvaenskae 
14:09:52 <Welkin> do a random shuffle
14:10:05 <crough> this seems bad
14:10:06 <monochrom> why do you reorder it arbitrarily? how arbitrarily?
14:10:09 <mvaenskae> hm, thinking off, actually thanks ertes, i should map the fields i have with somethign i can totally order and then undo it
14:10:17 <ertes> mvaenskae: are you asking for "the best" way or a "good" way?
14:10:26 <ertes> mvaenskae: because the best way to reorder a list is not good
14:10:28 <mvaenskae> monochrom: because the colour standard of Xterm/st wants that to be :)
14:10:43 <monochrom> in fact why is the original order not as arbitrary as any other order?
14:11:14 <mvaenskae> monochrom: it is, apple thinks 10 < 2... NOT!
14:11:17 <monochrom> I refuse to believe that any colour standard says literally "arbitary"
14:11:22 <ertes> mvaenskae: either try not to reorder (produce the list in the correct order) or use a structure that supports reordering well (like Vector or Seq)
14:11:29 <monochrom> no, I don't think you're making sense.
14:13:36 <mvaenskae> monochrom: http://git.suckless.org/st/tree/config.def.h (starting line 71) and this format here (https://raw.githubusercontent.com/carloscuesta/materialshell/master/osx/iterm/materialshell-dark.itermcolors) when read serialised don't apply to one another
14:13:46 * hackagebot atom-conduit 0.3.1.1 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.3.1.1 (koral)
14:14:13 <mvaenskae> and i want to write a converter which reads iterm colours and converts them to pasteable st colours
14:15:15 <mvaenskae> so you see, i have an "arbitrary" ordering as my tags were broken, but if i find the actual numbers used for terminal colours of the other fields then i can reorder my list nicely
14:15:44 <mvaenskae> broken in the sense of "they are ordered all over the place, just not according to their number or even alphabetically"
14:16:20 <Zemyla> Hmm, shame Haskell98 couldn't have, say, an Eq1T (t :: (* -> *) -> * -> *) type class.
14:16:28 <monochrom> you can set up a lookup table. use module Data.Map.Strict for example.
14:16:29 <Welkin> mvaenskae: just sort the list
14:16:38 <Welkin> yes, or that
14:16:54 <Welkin> you are already using an association list, right?
14:17:02 <Welkin> a Map is just the same thing, but better
14:17:24 <Zemyla> With liftEqT :: (forall u v. (u -> v -> Bool) -> f u -> g v -> Bool) -> (a -> b -> Bool) -> t f a -> t g b -> Bool
14:17:33 <monochrom> at a meta level, you are letting your opinion get into the way of describing your question.
14:17:49 <codedmart> How do you usually deal with modules that rely on each other? https://gist.github.com/codedmart/bf1f1fe44a6873055087ec01017e0884
14:17:50 <mvaenskae> Welkin: i right now have a list of tuples (String, String) emulating a key-value pair, so i should be able to exchange all my keys and then sort by them
14:17:55 <EvanR> is it funny that Data.Map, usually considered simpler and easier to understand than e.g. PHP arrays... but secretly Map also has a notion of ordering like an array
14:18:14 <EvanR> which ends up being even more useful that PHP arrays for that purpose
14:18:49 <Welkin> mvaenskae: look at Data.Map
14:18:57 <ertes> mvaenskae: you end up poorly emulating Data.Map.Strict
14:19:05 <monochrom> it is OK to opine that their standard is pretty arbitrary. but by the time you talk coding to their standard, the code has to do a deterministic and complying thing, not an arbitary thing.
14:19:42 <mvaenskae> monochrom: i assume their config file to always adhere to the same ordering so i could hardcode a permutation of the list on my own
14:19:49 <Welkin> codedmart: I recall a solution somewhere... I forgot what it was though
14:19:51 <ertes> mvaenskae: and for stringy things like String, i generally recommend HashMap over Map
14:20:28 <EvanR> what is the difference really?
14:20:41 <EvanR> besides the constraints on keys
14:20:47 <Welkin> EvanR: one is Hashable the other is Ordered
14:21:02 <ertes> EvanR: Map would compare two strings on every branch
14:21:05 <EvanR> when the keys are both whats the difference
14:21:30 <Welkin> EvanR: the constant time factor for hashing
14:21:34 <EvanR> benchmarks?
14:21:45 <ertes> EvanR: HashMap is a radix tree on the hashes, so you get about IntMap efficiency on String keys
14:21:56 <mvaenskae> my size is erm... that textfile, i assume performance is not that important there
14:21:58 <EvanR> for short strings maybe
14:22:01 <ertes> with the extra cost of computing the hash once per operation
14:22:11 <monochrom> a Map operation may need (lg n * string length) comparisons of characters.
14:22:14 <EvanR> just wondering if theres a gratuitous bar graph showing how much better it is
14:22:49 <Zemyla> ertes: We honestly need a good radix map for mapping lists.
14:23:00 <monochrom> a HashMap operation goes through just (string length) steps for the one-word hash value. (then compare it many times, sure)
14:23:30 <Zemyla> monochrom: In the worst case, everything hashes to the same value, and you get Map behavior or worse (depending on whether you require Eq or Ord).
14:23:32 <ertes> also hashable actually produces terrible hashes, but they are very cheap to produce
14:23:41 <ertes> Zemyla: sorry, i don't know what that means
14:23:59 <monochrom> yeah, I am not wedded to either side.
14:24:09 <monochrom> the joy of being single
14:24:26 <ertes> Zemyla: actually you get pretty bad behaviour when hashes collide
14:24:33 <mvaenskae> a hash function will, given enough input map inputA and inputB to hashX
14:24:41 <ertes> it acts more like [] for colliding hashes
14:25:14 <Zemyla> ertes: data RadixMap k a = RadixMap !(Maybe a) !(Map k (RadixMap a))
14:25:17 <mvaenskae> and that usually is not that good for hashing and requires some form of recovery then
14:25:20 <EvanR> and comparison on strings isnt necessarily length of string
14:25:40 <mvaenskae> true, grep in the unix world does some magic stuff on string comparisons
14:25:47 <Zemyla> It's basically a value of a for [], and a RadixMap for each s:l.
14:25:48 <mvaenskae> that's why it's so insanely fast
14:26:33 <ertes> mvaenskae: that's a different kind of optimisation though
14:26:40 <ertes> it uses clever substring search
14:27:18 <monochrom> the best of both worlds is to hash all substrings and then do KMP on the hash values :)
14:28:47 * hackagebot crypto-multihash 0.4.1.0 - Multihash library on top of cryptonite crypto library  https://hackage.haskell.org/package/crypto-multihash-0.4.1.0 (mseri)
14:33:27 <xaviergmail> Is it possible to combine these two in a match? (x:xs) (y:ys) &  x == y
14:33:46 <xaviergmail> might have my terms confused here
14:33:47 * hackagebot shelly 1.6.7 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.7 (GregWeber)
14:33:53 <ertes> xaviergmail: "(x:xs) (y:ys) | x == y"?
14:34:31 <xaviergmail> Thought about that just as I hit enter :P
14:34:39 <xaviergmail> What's the | called again? Guards?
14:34:59 <ertes> vertical bar
14:35:09 <Welkin> yes, a pattern guard
14:35:12 <ertes> but yeah, the stuff to its right is called a guard =)
14:35:15 <xaviergmail> well the character istself is a pipe 
14:35:15 <ertes> not a pattern guard
14:35:17 <ertes> just a guard
14:35:19 <Welkin> eh?
14:35:22 <xaviergmail> alright thanks
14:35:27 <ertes> a pattern guard is this:  | x <- y
14:35:29 <Welkin> ertes: but there is alsothe function guard
14:35:42 <ertes> Welkin: "pattern guard" has special meaning
14:35:53 <Welkin> oh, I see
14:35:57 <Welkin> pattern matching inside a guard
14:36:18 <ertes> yeah…  "guard patterns" would have been a better term, i guess
14:36:42 <monochrom> Haskell 2010 says just "guard", no and, not but.
14:37:35 <ertes> … for what we call "pattern guards" today
14:38:18 <monochrom> seriously?
14:38:32 <monochrom> look for "pat <- infixexp	    (pattern guard)" in section 3.13
14:39:15 <ertes> again:  i guess, "guard patterns" would have been a better term for what we call "pattern guards" today
14:39:32 <monochrom> ok, I see what you mean now.
14:41:25 <xaviergmail> Is there a way to reduce these matches down to one line or so? http://pastie.org/10889412
14:42:00 <xaviergmail> could I perhaps put what I want to match first at the top and reduce it to f x y = [] at tne end?
14:42:10 <xaviergmail> kind of like the 'otherwise' keyword
14:42:17 <monochrom> I can do two. "f [] _" and then "f _ []"
14:42:21 <koz_> xaviergmail: exactMatchesHelper _ _ = []
14:42:32 <koz_> You have [] regardless of what else happens.
14:43:12 <monochrom> but yeah, it is better to have "f (_:_) (_:_)" first. then the rest are just "f _ _"
14:43:29 <xaviergmail> koz_: Exactly what I just tried :)
14:43:33 <koz_> monochrom: In this case, I don't see why you even need to. The result is always [].
14:43:47 * hackagebot smallcaps 0.6.0.3 - Flatten camel case text in LaTeX files  https://hackage.haskell.org/package/smallcaps-0.6.0.3 (StefanBerthold)
14:44:21 <Cale> koz_: Well, presumably this thing does something more interesting in the case that both lists are nonempty
14:46:03 <xaviergmail> So is it safe to say that patterns are always matched top to bottom in the way they are written?
14:46:34 <ertes> xaviergmail: yes
14:46:35 <xaviergmail> unlike css in which the most 'complex' / precise  pattern has priotity
14:46:43 <xaviergmail> neat
14:47:39 <Welkin> xaviergmail: the pattern matching is converted into case expressions by the compiler I believe
14:47:52 <ReinH> jle`: ping
14:47:53 <Welkin> which are handled top to bottom
14:48:13 <ertes> xaviergmail: semantically at least…  GHC will match simultaneously as much as possible
14:48:21 <xaviergmail> ahh
14:48:57 <xaviergmail> Is there a way to have fallthroughs then?
14:49:18 <monochrom> appealing to what GHC does is not going to be a satisfactory explanation, because it begs the question "why don't they do a different thing?"
14:49:22 <ertes> xaviergmail: like skipping clauses?
14:49:57 <ertes> xaviergmail: clauses are tested in order, and the first match wins…  there are no exceptions
14:51:15 <xaviergmail> I meant more like make two patterns are evaluated the same
14:51:22 <xaviergmail> but I can't think of a reason to do that yet 
14:51:41 <monochrom> you want less tie-breaking?
14:52:02 <merijn> There's no nice way to use Arrow combinators on Kleisli arrows without the bothersome newtype wrapping, is there?
14:52:22 <Cale> monochrom: He means like OR-patterns
14:52:27 <Cale> (which Haskell doesn't have)
14:52:37 <monochrom> yeah, we don't have that.
14:52:52 <gfixler> xaviergmail: fallthrough like by omitting a break in a case?
14:53:09 <Cale> https://hackage.haskell.org/package/OrPatterns -- there is however a Template Haskell library which adds them
14:53:12 <monochrom> and we don't have that either
14:53:14 <gfixler> xaviergmail: it's not like case in other languages, so no
14:53:34 <Welkin> template haskell, haha
14:53:35 <gfixler> xaviergmail: remember that all Haskell functions are single expressions
14:53:38 <Welkin> of course
14:53:42 <merijn> i.e., what's the nicest way to convert "Foo -> Maybe a" and "Foo -> Maybe b" into "Foo -> Maybe (a, b)"?
14:53:42 <monochrom> yeah, this is an expression language, not a command language, there is no "don't break"
14:53:49 <gfixler> xaviergmail: they're not blobs of statements, as in other langs
14:54:06 <xaviergmail> Yeah gfixler, I was trying to come up with an example and that was pretty apparant as I wrote another line
14:54:30 <monochrom> the benefit is that we don't need two versions of if-then-else, we just need one, and it is good for both.
14:54:45 <gfixler> xaviergmail: functions are more like equations - the left can be replaced by the right
14:54:54 <Welkin> merijn: (***) and a lambda?
14:54:55 <gfixler> xaviergmail: but, at least theoretically, they can be replaced the other way, too
14:55:06 <gfixler> xaviergmail: which gives you like-for-like replacement, as in math
14:55:06 <merijn> Welkin: That doesn't quite work, does it?
14:55:13 <xaviergmail> yeah I understand that
14:55:16 <gfixler> xaviergmail: which gives you "equational reasoning," which is powerful stuff
14:55:39 <Cale> Of course, it's a little weird due to the nature of pattern matching
14:55:53 <merijn> Welkin: I was hoping to use the (***) of Kleisli arrow without needing to wrap with Kleisli explicitly :\
14:56:05 <Cale> You can have an "equation" like  f xs ys = 0, or whatever
14:56:21 <Cale> and then if it's preceded by f [] [] = 1, then it's not the case that f xs ys is always 0
14:56:25 <xaviergmail> I took a wrong turn in my thinking 
14:56:30 <xaviergmail> Back on track though
14:56:55 <monochrom> merijn, I think you have to wrap, or else you have to use type-level lambdas. because type-wise going from "X -> M Y" to "A X Y" requires either.
14:56:57 <gfixler> xaviergmail: I have had plenty of situations where I've wished I could have 2 expressions merge a bit, though
14:57:22 <gfixler> xaviergmail: leading to puzzling out how to refactor to share info, usually via let or where, or guards, etc
14:57:28 <merijn> monochrom: Yeah, but I'm not married to Arrow, I was just wondering if there was any existing functions for this sorta stuff already
14:57:41 <monochrom> "A" has to be either a newtype or a "(Λ x y. x -> Maybe y)"
14:57:47 <merijn> monochrom: I suppose it could also be Compose of reader and maybe, but that's still annoying
14:58:32 <monochrom> let's ask @pl
14:58:54 <xaviergmail> Thanks for the heads up
14:58:57 <Iceland_jack> Star Maybe
14:59:02 <gfixler> Cale: cases make it more like step functions
14:59:06 <merijn> I suppose it's "liftA2 . liftA2"
14:59:06 <Iceland_jack>     Star f a b = a -> f b 
14:59:16 <merijn> Iceland_jack: That's Kleisli
14:59:37 <merijn> "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }"
14:59:38 <monochrom> no, @pl will give a horrid answer
15:00:00 <Iceland_jack> Yes a more general version
15:00:01 <hpc> fun fact: @pl doesn't care if what you give it is well-typed
15:00:07 <gfixler> Cale: one of these things: http://mathbitsnotebook.com/Algebra1/FunctionGraphs/PWeq1a.png
15:00:10 <Iceland_jack> Should have read up
15:00:35 <hpc> @pl \x -> x x
15:00:36 <lambdabot> join id
15:00:40 <hpc> :t \x -> x x
15:00:42 <lambdabot>     Occurs check: cannot construct the infinite type: r1 ~ r1 -> r
15:00:42 <lambdabot>     Relevant bindings include x :: r1 -> r (bound at <interactive>:1:2)
15:00:42 <lambdabot>     In the first argument of ‘x’, namely ‘x’
15:00:44 <hpc> :t join id
15:00:46 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
15:00:46 <lambdabot>     Expected type: a1 -> a1 -> a
15:00:46 <lambdabot>       Actual type: a1 -> a1
15:01:03 <ertes> xaviergmail: if you have "f PAT1 = y" and "f PAT2 = y", you can write:  f x = case x of PAT1 -> r; PAT2 -> r  where r = y
15:01:19 <ertes> xaviergmail: it's not short, but less repetetive
15:02:27 <monochrom> what erks me is that in math they have only thought of using non-anonymous functions to let you have conditionals and pattern matching.
15:03:22 <Cale> Well, you can define functions in a lot of ways in math
15:03:40 <monochrom> if you think Fortran is so bad it doesn't have first-class anything, try math. math doesn't even have first-class boolean blindness.
15:03:42 <Cale> If you want, you can just describe the function's graph as a union of sets.
15:05:13 <Cale> I also think you could get away with writing "x |--> " followed by a conditional expression of the sort with a single open brace
15:05:13 <ertes> at least composition is well established in math
15:05:39 <Cale> It's a little unusual to see that, but I think everyone would understand you.
15:05:43 <ertes> but it's really the fault of you people, you academics
15:06:06 <gfixler> and the names
15:06:14 <ExcaliburZero> How do you work with IO in Hspec? Currently I am trying to test a Parsec JSON parser against a large JSON file that would be unreasonable to type into the spec file. I can access the contents of the file using `readFile` in order to use it to test the parser, however I am unsure of how to properly do this in the contents of an hspec spec.
15:06:14 <gfixler> groups, semigroups, monoids, rings
15:06:58 <ertes> i want physicists to stop using that brain-damaged bra-ket notation, and there is only one way to do it:  write papers using regular vector notation
15:07:15 <ertes> unfortunately i'm not a physicist, so they will continue using the brain-damaged style
15:07:47 <ertes> and non-physicists like me will continue to have a hard time to understand physics
15:07:47 <Cale> gfixler: What's wrong with those names? Eventually you run out of English words which give some sort of idea of a collection of things (that you can use for collections having some special structure)
15:08:32 <gfixler> Cale: true - my problems have been that some things sound painfully complex, like monoids, and then turn out to be blissfully simple
15:08:47 <gfixler> Cale: and then some things sound completely unrelated, and then turn out to be one notch away from each other
15:08:51 <Cale> Perhaps it's just a matter of what sounds complex to you :)
15:09:07 <gfixler> Cale: "monad" didn't help me not fear "monoid," that's for sure
15:09:17 <Welkin> really?
15:09:27 <gfixler> Welkin: me?
15:09:30 <Welkin> monoid was easier to understand than monad was
15:09:35 <Welkin> for me
15:09:37 <gfixler> Welkin: right
15:09:38 <merijn> Welkin: That's what he said
15:09:40 <Welkin> oh
15:09:55 <gfixler> tried forever to learn monads, then feared learning monoids, but learned them in an afternoon
15:10:02 <Cale> Yeah, he's saying that he learned about monads first, and found it challenging, and expected monoids to be similarly so
15:10:17 <Cale> But most people in mathematics learn about monoids long before they learn about monads.
15:10:17 <ertes> it's peculiar that even today beginning haskellers tend to learn about monads sooner than about monoids
15:10:39 <Cale> yeah
15:10:41 <gfixler> ertes: they get all the press
15:11:02 <hpc> most people in mathematics learn about algebras before monoids
15:11:07 <gfixler> and they're just so weird - earlier today we were talking in here about how they're not even useful in a strict language
15:11:13 <gfixler> which became a debate about whether or not that's true
15:11:17 <hpc> though they probably don't realize that "algebra" can be plural
15:11:31 <ertes> you know what's the worst of it all?
15:11:45 <ertes> professional programmers come to haskell *not* knowing about monoids already
15:12:16 <Welkin> lol
15:12:19 <gfixler> ertes: I've known tons of programmers who have virtually no math background
15:12:25 <gfixler> ertes: myself included :(
15:12:27 <monochrom> hell, they come to Haskell not knowing Unicode either.
15:12:27 <Welkin> I just followed LYAH at first
15:12:43 <gfixler> monochrom: what does it mean to "know" Unicode?
15:12:43 <Welkin> it covers Functor, Applicative, Monoid, then Monad
15:12:43 <Cale> Well, it's amazing that monoids don't come up in CS courses where they teach you about binary trees
15:12:58 <monochrom> (It does matter. They come thinking that Char is 8-bits or less.)
15:12:58 <Welkin> Cale: well, it hasn't caught up with the curriculum yet
15:13:07 <shachaf> You mean in courses where they teach you about sequences?
15:13:07 <ertes> monochrom: proving once again that comedy is strongly related to tragedy
15:13:17 <Welkin> the course material is still stuck in the 1970's, right?
15:13:24 <ertes> monochrom: i laughed, but a part of me cried
15:13:29 <gfixler> it hasn't caught up with languages yet
15:13:36 <gfixler> is knowing what a monoid is helpful in Java?
15:13:38 <Cale> Instead, you spend ages learning about all these different kinds of binary trees which vary based on which monoid is being used to combine summary information about data in the leaves of the tree.
15:13:38 <hpc> Welkin: that's exactly it
15:13:46 <gfixler> I mean, a little, but can you abstract over the idea for any real gain?
15:13:49 <hpc> my class on parsing used lex and yacc
15:14:08 <monochrom> gfixler: some basic awareness of "ascii is so passe" is probably good enough for the first few months
15:14:24 <Cale> gfixler: It should even be useful in Java, since Java's polymorphism isn't bad enough to stop you from actually abstracting over it.
15:14:27 <gfixler> monochrom: maybe we should have an outreach program
15:14:38 <gfixler> monochrom: haskellers can visit schools and preach
15:14:42 <codedmart> Is there a syntax like import Types.Models (User(..) as U)?
15:14:51 <Cale> No
15:14:54 <maurer> Is there a variant of fold that uses something like Map.minView as it's step?
15:14:55 <ertes> gfixler: you don't necessarily need to "know math" (i'm not even sure that means anything), but there are algebraic concepts that cover most of what OO people love to call "design patterns"
15:14:57 <hpc> Cale: well, i would argue it is bad enough
15:15:02 <maurer> I find myself open recursing this way a bunch
15:15:10 <hpc> Cale: instanceof being the main offender
15:15:25 <hpc> with just instanceof, you lose parametricity and everything goes out the window
15:15:35 <Welkin> I recently started learning about some of these "design patterns" by learning some java, and yeah, it seems stupid
15:15:38 <gfixler> ertes: I bet a lot of CS teachers also don't know this
15:15:39 <hpc> and its use isn't discouraged like the law-breakers in haskell are
15:15:47 <Welkin> because it just makes sense to use functions
15:15:56 <Cale> hpc: you'd have some parametric class Monoid<A> whose objects are monoid structures on the type A.
15:16:16 <ertes> gfixler: just knowing monoids and everything that surrounds them (monoid morphisms!) would get them much further than the thickest OO "design patterns" book
15:16:30 <gfixler> Welkin: I've wanted to learn design patterns really well so I could show people the better ideas in Haskell, but it's just been too painful to actually make myself spend time learning them :)
15:16:33 <monochrom> maurer: there are a few Map operations that already recurse through minView for you...
15:17:03 <gfixler> ertes: the first time I learned about monoids (LYAH), I thought "Okay... so?"
15:17:04 <monochrom> for example Data.Map.foldr (better, Data.Map.Strict.foldr)
15:17:13 <gfixler> ertes: then later (LYAH) I saw them used in Writer, and the other shoe dropped
15:17:26 <monochrom> oh, foldrWithKey is even better
15:17:27 <gfixler> ertes: I don't know Java enough to know if there's any equivalent
15:17:43 <ertes> gfixler: search for things starting with I
15:17:47 <ertes> ICombinable or whatever
15:17:49 <ertes> sorry
15:17:59 <ertes> IEnterpriseBusinessCombinable
15:18:10 <Welkin> gfixler: my first realization at how useful they were was when I wanted to make an alchemy game where the player can cook various items together and it produces another item that has properties of thoe two items combined, including the name
15:18:12 <gfixler> ertes: I guess I've used a few of those in C# - IEnumerable in particular
15:18:26 <ertes> gfixler: that's more like Foldable
15:18:44 <gfixler> Welkin: that sounds fun
15:18:45 <maurer> monochrom: Those do not do what I want - I want access to the map without all the k/vs I've folded through thus far
15:19:19 <maurer> monochrom: I can simulate them with a foldl/foldr by keeping a depopulated version of the map in the accumulator, but that's not much better than open recursing
15:20:05 <monochrom> OK, then I think you have to stick to your own recursion.
15:20:28 * glguy punches maurer's recursion card.
15:20:32 <glguy> It looks like you have 5 left
15:20:51 <monochrom> because an over-arching theme of what people call "fold", across all data structures, is that they don't let you access the intermediate data structure.
15:20:59 <Welkin> "your language does not support tail call optimization. You have reached your recursion limit."
15:21:14 <monochrom> for example []'s foldr and foldl don't tell you the shorter lists.
15:21:21 <maurer> monochrom: that's why I said variant-of-fold
15:21:26 <maurer> this clearly isn't fold
15:21:29 <monochrom> it is like that's the whole point, to deny you of the shorter lists.
15:21:31 <maurer> but it's the closest recursion I know about
15:21:48 <Welkin> you can use scanl/scanr
15:22:33 <ertes> maurer: construct a list of views first, then fold on that list
15:22:33 <maurer> Welkin: I don't think that does what I want
15:22:50 <maurer> ertes: Actually, that seems really clean, thanks
15:23:07 <ertes> :t unfoldr M.minView
15:23:08 <lambdabot> Data.Map.Map k a -> [a]
15:23:14 <ertes> :t unfoldr M.minViewWithKey
15:23:15 <lambdabot> Data.Map.Map k a -> [(k, a)]
15:23:35 <ertes> :t unfoldr ((\(x, y) -> (y, x)) . M.minViewWithKey)
15:23:37 <lambdabot>     Couldn't match expected type ‘Maybe (a, Data.Map.Map k a1)’
15:23:37 <lambdabot>                 with actual type ‘(t0, t1)’
15:23:37 <lambdabot>     Relevant bindings include
15:23:39 <ertes> meh
15:23:44 <ertes> you get the idea
15:23:47 <maurer> Yeah, I do
15:23:54 <Ohso_> How can I define a type in one module that uses functions from another module when the function signatures have the type from the first module?  I get an error that the imports form a cycle.
15:24:23 <Welkin> Ohso_: break them out into another module than both the previous ones import
15:24:31 <ertes> :t unfoldr (fmap (\(x, y) -> (y, x)) . M.minViewWithKey)
15:24:32 <lambdabot>     Couldn't match type ‘(k, a)’ with ‘Data.Map.Map k a’
15:24:33 <lambdabot>     Expected type: (k, a) -> Maybe ((k, a), Data.Map.Map k a)
15:24:33 <lambdabot>       Actual type: Data.Map.Map k a -> Maybe ((k, a), Data.Map.Map k a)
15:25:02 <ertes> alright, lambdabot, i get it…  i'm stupid…  it's okay
15:27:01 <Cale> Ohso_: How does your type definition manage to use a function?
15:27:02 <ertes> :t unfoldr (fmap (\((k, x), xs) -> ((k, x, xs), xs)) . M.minViewWithKey)
15:27:03 <lambdabot> Data.Map.Map t t1 -> [(t, t1, Data.Map.Map t t1)]
15:27:08 <ertes> finally
15:27:22 <Cale> Ohso_: That's kind of tricky in Haskell, since we don't really have dependent types...
15:28:42 <Ohso_> Cale, the type definition doesn't, but the module also includes functions that use functions form the second module...sorry for the omission.  Am currently attempting Welkin's advice.
15:28:45 <ertes> i made an amazing discovery today
15:29:09 <ertes> if you actually sit down and think before you write, you get a higher probability that your program will work
15:29:40 <Ohso_> crud this isn't going to work
15:29:48 <gfixler> ertes: that's the Feynman Algorithm
15:30:21 <ertes> so i'm a feynman now?
15:31:38 <gfixler> ertes: basically
15:32:17 <glguy> ertes: That sounds like a good way to be not-first
15:32:29 <monochrom> just make sure tonight you go to a topless bar and work on some physics or programming
15:32:44 <glguy> monochrom: is that a lattice joke?
15:32:54 <monochrom> no, it's what Feynman did
15:32:59 <glguy> bummer
15:33:07 <Rembane> That sounds very excentric.
15:33:17 <Rembane> Did he solve the problem?
15:33:28 <ertes> the weather increases the probability for any establishment to end up being a topless bar
15:33:28 <glguy> excentric is when you aren't centric any more
15:33:35 <monochrom> I think he didn't really care about the topless part. He just became friend to the bar owner, that's all.
15:34:06 <Rembane> And seismic activity increases the probability for any establishment to end up being a topples bar.
15:34:22 <ertes> anything that gets the equations right
15:34:24 <monochrom> and he probably didn't even drink alcohol there. he once spoke up for the bar owner, so the bar owner gave him free soda.
15:34:40 <monochrom> so he just went there to do moar physics
15:34:54 <glguy> Did he do any Haskell programming?
15:35:14 <ertes> hmm…  so feynman should not get any credit…  the bar owner should…  without him, none of this would have happened
15:35:16 <monochrom> no, but today he would probably be interested.
15:35:38 <monochrom> towards his last years, he got interested and involved in computing
15:36:19 <joe9>  http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ in this article, "4" talks about using Monad and fail. I cannot figure out where the E.catch function comes from?
15:36:29 <joe9> When I tried the same code, I get a compilation error.
15:36:41 <koz_> joe9: Control.Monad.Error perhaps?
15:36:42 <joe9> Just want to check which modules should be imported for that E.catch
15:36:48 <glguy> 13import qualified Control.Exception as E
15:37:21 * glguy goes to have a word with the syntax highlighter... too many missed opportunities
15:38:04 <shachaf> 6import 04q08u09a11l12i13f04i08e09d Control.Exception as E
15:38:05 <monochrom> great, soon you will have moar colours
15:38:09 <joe9> glguy: using the Control.Exception, I get this error http://codepad.org/b3icVsXr
15:38:11 <koz_> Can anyone tell me how I can tell Cabal to use a non-Hackage-hosted library?
15:38:33 <hpc> koz_: download it somewhere and run the commands without a package name
15:38:37 <monochrom> glguy and his technicolour dream haskell code
15:38:43 <hpc> in the same directory as the .cabal file
15:38:49 <koz_> hpc: Is that all? OK.
15:39:03 <Ohso_> Splitting the type out into it's own module works as long as I wasn't planning on enforcing a smart constructor.  :(
15:39:13 <hpc> there's sometimes more to it, but cabal will tell you what to do usually
15:39:38 <glguy> joe9: The code you're trying to run doesn't seem to appear in the linked article
15:39:46 <glguy> joe9: You can't putStrLn the error, it's not a String
15:40:06 <Ohso_> I guess I could make some accessor functions to take the place of pattern matching and then I can go back to a smart constructor. :p
15:40:30 <joe9>  https://gist.github.com/4dfd3e414deeeb55f721f60c711b5cbb is my code.
15:40:55 <joe9> glguy: let me reset back to his code and try.
15:40:56 <glguy> joe9: Yeah, you can't catch a String, so putStrLn isn't going to work there
15:40:59 <joe9> glguy, Thanks.
15:41:20 <glguy> Also the article looks like it was written using the old exception system. Now you'll need to add a type annotation as to which type of exception you're catching
15:41:47 <monochrom> use "print err" instead of "putStrLn err"
15:42:03 <glguy> Prelude Control.Exception> fail "example" `catch` \e -> print (e :: IOError)
15:42:03 <glguy> user error (example)
15:42:13 <monochrom> alternatively "putStrLn (show err)"
15:42:15 <Ohso_> Polari has to be the worst IRC client I've ever used.
15:42:29 <joe9> glguy, monochrom: http://codepad.org/fXbYK9pl
15:42:31 <maurer> Ohso_: weechat is quite nice
15:42:48 <monochrom> use glguy's fix
15:42:57 <joe9> glguy, monochrom, any suggestions on where I can find a working version to capture such errors.
15:43:00 <glguy> I'd listen to monochrom on this
15:43:30 <joe9> glguy, got it. Thansk.
15:43:39 <joe9> glguy, Thanks Sorry for the bother.
15:43:48 <Ohso_> I'm definitely switching to *something* else as soon as I get the chance.
15:44:15 <joe9> glguy, got it working. Thanks a lot.
15:44:23 <glguy> You're welcome.
15:45:39 <Ohso_> Everytime I use anything Gnome related I feel like I should be holding a crayon in one hand and safety scissors in the other.
15:48:58 <glguy> After "qualified" and "as" are there other tokens that are sometimes keywords and sometimes identifiers?
15:49:15 <glguy> oops, pressed up when pressing enter
15:53:44 <glguy> bits of the foreign import syntax, ccall, stdcall, safe, unsafe...
15:53:44 <ggVGc> when will haskel be the primary language of the web?
15:54:23 <ggVGc> I hope javascript will slowly evolve into a functional-inspired immutable language
15:54:27 <ggVGc> it's kid of happenig
15:55:03 <Welkin> javascript will be an assembly
15:55:12 <ggVGc> more on topic, why is `when` not just an inverted `let`?
15:55:12 <Welkin> that's the trend
15:55:21 <Welkin> you have elm, ghcjs, purscript, etc
15:55:33 <Welkin> other languages have their own versins
15:55:55 <suppi> https://ro-che.info/ccc/20
15:56:00 <glguy> hiding is another..
15:57:04 <suppi> forall
15:58:04 <glguy> When the extension is turned on family becomes one
15:58:10 <glguy> lots of editor highlighters miss that one
16:01:35 <ggVGc> is there a language extension that would allow using `when` inside a lambda without doing a pattern match?
16:01:43 <ggVGc> or would it be reasonable to write one?
16:03:15 <glguy> How would you parse: let a = \b -> c where d = e
16:03:31 <glguy> currently the where is outside of the lambda
16:03:42 <glguy> and attached to 'a'
16:03:52 <shachaf> Is "when" a time version of "where"?
16:04:26 <ggVGc> glguy: yeah, fair
16:04:34 <ggVGc> I figured there was a good reason for it
16:06:00 <AleXoundOS> Hi. What's the right way of doing something once in a period of time in Haskell?
16:06:26 <ertes> AleXoundOS: start a thread with a loop using threadDelay
16:06:49 <ertes> if that's all you do, you can also just loop in the main thread with threadDelay
16:07:01 <ertes> forever (action >> threadDelay 1000000)
16:07:02 <ggVGc> loop meaning a recursive function
16:07:05 <ggVGc> oh, or that
16:07:32 <AleXoundOS> ertes, thank you
16:12:41 <ReinH> glguy: Listening to monochrom is sound advice in general ;)
16:12:56 <glguy> thanks!
16:13:20 <mniip> :t when -- shachaf :)
16:13:21 <lambdabot> Applicative f => Bool -> f () -> f ()
16:13:40 <shachaf> I know the function when.
16:13:47 <mniip> :p
16:14:07 <ertes> :t where
16:14:08 <lambdabot> parse error on input ‘where’
16:14:26 <ReinH> AleXoundOS: I think the only real answer is "it depends".
16:14:45 <ReinH> Something naive like ertes's might be sufficient, but it might not.
16:16:25 <ReinH> How accurate do you need to be, for example?
16:17:00 <AleXoundOS> ReinH, not accurate, check stream status once in ~15 minutes
16:17:15 <AleXoundOS> twitch (video service) stream
16:18:50 * hackagebot uri-bytestring 0.2.1.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.1.2 (MichaelXavier)
16:19:45 <Fmap> Sorry trying to use lamdabot
16:20:05 <ertes> AleXoundOS: can't they push updates to you?  polling is usually a bad idea
16:20:29 <ReinH> Fmap: you can just /q lambdabot :)
16:20:33 <AleXoundOS> ertes, I doubt, there is REST API
16:20:38 <jle`> ReinH: what's up?
16:20:45 <Fmap> Thanks ReinH
16:21:45 <ReinH> jle`: Hi! So... auto looks cool. Is it still your new hotness?
16:21:53 <AleXoundOS> ertes, moreover I go further and try to get HLS m3u playlist to be 100% sure that twitch not only marks it as online, but provides access to the video stream
16:23:10 <jle`> ReinH: haha development has sort of quieted down, i've been working on some other things lately, but i still maintain it
16:23:20 <jle`> i haven't had as much success building full on games with it as i had hoped on the onset
16:23:24 <ReinH> wah wah
16:23:33 <ReinH> What's the issue(s)?
16:23:33 <jle`> but i still maintain a chatbot written in it
16:23:55 <ReinH> compositional state stuff is interesting. Even the frontend JavaScript world is getting into this now.
16:24:17 <jle`> yeah, i dream of compositional state and denotative computation specs
16:24:43 <jle`> the thing with games was that turn-based game paradigms were tricky to fit in
16:24:54 <jle`> at least while keeping the high-level denotative thing
16:25:07 <ReinH> hmm
16:25:20 <jle`> it works but it ends up being a little unnatural, and i haven't really gotten around to looking at a serious answer
16:25:21 <ertes> AleXoundOS: i barely know what twitch is…  in any case if that's all your program does, then it's probably fine
16:25:52 <ReinH> jle`: have you seen Redux? (https://github.com/reactjs/redux)
16:25:55 <ertes> AleXoundOS: you may want to have cleanup though, or be able to abort the loop, etc.
16:25:56 <ReinH> Similar to Elm's model
16:26:13 <jle`> hm, i haven't
16:26:17 <ReinH> @google parallel and concurrent programming haskell
16:26:18 <ertes> AleXoundOS: in that case the 'async' library helps a lot, especially with constructs like 'withAsync'
16:26:19 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
16:26:19 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
16:26:28 <ReinH> AleXoundOS: whatever you're doing, you should read that (free) book.
16:26:34 <ertes> AleXoundOS: also i generally recommend reading The Book
16:26:38 <bluezone> What odes the backslash do in \_ http://www.happylearnhaskelltutorial.com/1/function_magic.html#s5.2
16:26:46 <ertes> AleXoundOS: it's the one ReinH just linked =)
16:27:06 <Cale> bluezone: That's a lambda, it's just that the pattern being used is _ which matches anything
16:27:07 <AleXoundOS> ReinH, ertes, ok, thank you very much
16:27:14 <Welkin> @where parconc
16:27:14 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
16:27:16 <Welkin> lol
16:27:26 <Cale> > (\x -> x^2) 5
16:27:28 <lambdabot>  25
16:27:30 <bluezone> so every time you want to declare a lambda you must use brackets and start it with '\' Cale ?
16:27:36 <Welkin> \ is a lambda :D
16:27:44 <ReinH> @google haskell wiki anonymous function -- bluezone 
16:27:45 <lambdabot> https://wiki.haskell.org/Anonymous_function
16:27:46 <Welkin> but it lost its leg
16:27:51 <ggVGc> and if you enable unicode syntax you can even have a lambda sign
16:27:57 <ggVGc> wish I was that cool
16:28:05 <Welkin> I use a lambda symbol in ghci
16:28:05 <ertes> > (λ x -> 2*x) 5
16:28:06 <lambdabot>      Pattern syntax in expression context: λ x -> 2 * x
16:28:08 <Welkin> not in my source though
16:28:21 <ertes> @let {-# LANGUAGE UnicodeSyntax #-}
16:28:21 <lambdabot>  Parse failed: Parse error: EOF
16:28:29 <ggVGc> nice one
16:28:30 <Welkin> haha
16:28:55 <Welkin> @set -XUnicodeSyntaxe
16:28:55 <jle`> ReinH: i still think that auto is nicely suited for "frp-style" GUI's, but I hear that some actual FRP libraries have had some good stories these days
16:29:02 <ReinH> bluezone: Yes, \<pattern> -> <expression> is the syntax for a lambda in Haskell.
16:29:05 <Welkin> dunno the command
16:29:13 <Cale> bluezone: Well, the parens just do what parens normally do -- a lambda expression will continue as far to the right as it can
16:29:22 <bluezone> thanks very much :)
16:29:28 <ReinH> jle`: what would you use today if you were to try again? Reflex is interesting.
16:29:37 <ertes> jle`: "auto" sounds like AFRP…  i tend not to recommend AFRP for anything
16:29:45 <ggVGc> I'm still having a hard time seeing why I would want to use FRP
16:29:51 <ggVGc> I don't know how much gains it brings
16:29:52 <Welkin> there is elm too :D
16:30:00 <dmj`> Welkin: no type sharing though
16:30:12 <Welkin> lol dmj` 
16:30:18 <dmj`> it's a problem
16:30:18 <Welkin> I was just thnking of you
16:30:28 <ertes> Welkin: elm has never been FRP, and recently it became even less…  as far as i understood, they're pretty much back to event callbacks
16:30:46 <Welkin> ertes: yeah, but it is still a nice dsl for creating web apps
16:30:50 <Cale> ggVGc: The gains it brings is that you get to think about interactive systems in an equational reasoning sort of way
16:31:05 <ggVGc> Cale: but there also seems to be a lot of complexities added
16:31:11 <Cale> It becomes easy to see all the things which can affect some value which changes over time.
16:31:18 <ggVGc> and difficult situations that arise as a result of it
16:31:21 <Cale> Well, at the implementation level for sure
16:31:25 <jle`> ReinH: at this point in time I might try reflex for GUI's and web stuff
16:31:34 <ReinH> ertes: luckily, these days FRP means whatever the person using it wants.
16:31:38 <dmj`> ReinH: a lesser known, elm-like framework https://github.com/boothead/oHm
16:31:42 <ReinH> That way they are never wrong and no one knows what they mean.
16:32:00 <ertes> ReinH: there are libraries that follow FRP semantics, most notably reactive-banana and reflex
16:32:09 <Cale> ggVGc: But by and large, it's way nicer than any other approach I've seen for writing GUIs and AIs and other interactive things like that.
16:32:10 <ReinH> FSVO FRP.
16:32:18 <ReinH> IIRC, neither are continuous time.
16:32:21 <ertes> and interestingly those tend to be much nicer to work with than anything that labels itself as "FRP", but really isn't
16:32:31 <Cale> ReinH: neither of which?
16:32:32 <ggVGc> Cale: hm, don't think I've ever seen an AI using FRP
16:32:38 <ggVGc> do you know any public example?
16:32:41 <ReinH> Cale: reactive-banana and reflex
16:32:43 <Cale> I've written one, but it's not public
16:32:53 <ggVGc> why is FRP good for AI?
16:32:55 <ReinH> I don't know of any popular modern FRP framework that is actually FRP per Conal
16:33:02 <Cale> ReinH: At least Conal says that he considers reflex to be continuous time
16:33:03 <ertes> ggVGc: FRP is for the interaction part…  AI and interaction are orthogonal
16:33:08 <ReinH> Cale: Oh? Cool.
16:33:10 <Cale> ReinH: Reflex is ambiguous-time
16:33:13 <ReinH> heh
16:33:22 <ggVGc> ertes: that's why I don't exaclty see the connection
16:33:25 <Cale> It doesn't take any stance on what time is apart from that it's totally ordered
16:33:49 <ertes> ReinH: reactive-banana is continuous-time, reflex is least-assumptions-on-time
16:34:22 <ertes> ReinH: also people tend to confuse "continuous time semantics" with having an actual continuous time type
16:35:04 <ggVGc> I'm wondering if I should try making a version of the UI layer of my sequencer with FRP. The part of it that deals with the communications with midi controllers, which is the UI for it
16:35:23 <ggVGc> there's no on-screen UI, only midi controller interactions
16:35:34 <ggVGc> but not sure if FRP would be good for me there
16:35:34 <ertes> ggVGc: i don't see the connection either =)
16:35:59 <ertes> ggVGc: if you have a long-running (i.e. non-batch) application with interacting components, FRP is for you
16:36:09 <ggVGc> yeah, so I should probably try that out
16:36:32 <ggVGc> I'm not to unappoy wit how it is now, but it does seem like the perfect fit for FRP and a good chance to get more understanding
16:37:12 <ggVGc> this actually looks highly related, https://wiki.haskell.org/Reactive-balsa
16:37:16 <ggVGc> to my current work
16:38:41 <ReinH> ertes: I wish someone would actually explain what reflex is for someone who knows that FRP is.
16:38:54 <ReinH> I haven't looked at it in a couple months though. Are there docs now?
16:38:55 <ertes> ggVGc: it's unlikely to work now
16:39:06 <ertes> ReinH: an implementation of FRP =)
16:39:11 <ReinH> ertes: :p
16:39:37 <ertes> ReinH: reflex is very similar to reactive-banana with very similar semantics, but perhaps a bit more pragmatic
16:40:03 <ertes> ReinH: reflex-dom is very easy to get into…  there are lots of examples, and ryan (the author) has a bunch of videos
16:40:45 <ertes> reflex without any particular framework was a bit difficult to get into for me, but it's reasonable…  it requires getting the types to fit
16:41:18 <ReinH> ertes: I've used reflex-dom, but learning it was like pulling teeth.
16:42:00 <ggVGc> is reactive-banana and reflex the only serious candidates for an FRP lib in haskell currently?
16:42:06 <ggVGc> or should I look at something else too?
16:42:08 <Cale> We really need to make some more tutorial materials -- the Haddock documentation right now will show you lots of stuff which is pretty rarely used right next to stuff which gets used all the time
16:42:18 <Cale> So it's a bit tough to navigate at first
16:42:28 <dmj`> ReinH: are you looking moreso for an elm-like framework for ghcjs?
16:42:30 <ertes> ggVGc: there is also Yampa, but in general i'd prefer the other two
16:42:53 <ertes> ggVGc: and there is also my own library called netwire, but i no longer recommend to use it
16:43:48 <ReinH> dmj`: Really I'm trying to get a grip on how one one would write a large-scale application in any FRP framework. Just conceptually.
16:43:54 <ggVGc> so, for midi streams and fairly little FPR experience in general, wich would would be more suitable?
16:43:57 <ReinH> How are complexities managed, etc
16:44:04 <ggVGc> I'm leaning to ractive-banana
16:44:25 <Welkin> inactive-banana :D
16:44:28 <ReinH> Anything can support a todolist...
16:44:30 <ertes> ReinH: that's one of the major design considerations of reflex…  you should watch one of ryan's talks on reflex
16:44:45 <ReinH> ertes: ok! Any recommendations?
16:44:53 <ReinH> Also I really should try to get him on the haskell cast...
16:44:54 <ggVGc> Welkin: inactive could also mean stable
16:45:06 <ReinH> then I can just bug him with my questions in person
16:45:28 <Cale> ReinH: have you seen https://www.youtube.com/watch?v=dOy7zIk3IUI
16:45:37 <Welkin> ggVGc: https://github.com/gelisam/frp-zoo
16:45:47 <Welkin> many of the frp libraries compared
16:45:49 <ggVGc> thanks
16:45:59 <dmj`> ReinH: been wondering the same myself, think it would be possible to emulate elm in haskell though
16:46:07 <ReinH> Cale: Thanks
16:47:16 <ggVGc> dmj`: haha, I've been thinking that for a long time. "Wouldn't Elm, implemented as a DSL in haskell, compiled using GHCJS be a much more mature and efficient project"
16:47:38 <ggVGc> I actually even posted a similar idea on the ELm mailing list
16:47:40 <ggVGc> and got shot down hard
16:47:42 <ReinH> heh
16:48:15 <Welkin> elm was never meant for us though
16:48:20 <ReinH> Cale: Added to my Watch Later list, although that list is really more aspirational...
16:48:31 <Welkin> elm was made specifically for javascript users who were afraid of haskell
16:48:36 <dmj`> Welkin: elm maybe not, but the elm arch. is novel, and is more or less what redux is based on
16:48:48 <ggVGc> Welkin: that's not what I meant. I meant that you could have exactly elm like it is, except the implementation was powered by GHC
16:48:56 <ggVGc> and got all the optimizations etc.
16:48:57 <Welkin> sure, why not
16:49:07 <Welkin> elm is written in haskell, afterall
16:49:12 <ggVGc> right
16:49:20 <maerwald> ggVGc: does elm produce javascript code?
16:49:29 <Welkin> yes
16:49:35 <Welkin> javascript, html, and css
16:49:37 <maerwald> is it as unreadable as GHCJS?
16:49:48 <Welkin> I think it is readable
16:49:56 <dmj`> Welkin: elm uses virtual-dom, this is something we can just write in haskell with a rose tree
16:49:57 <maerwald> so then it's clear why they don't want GHCJS
16:50:01 <ertes> dmj`: why would one even want to emulate elm in haskell?  we have FRP libraries
16:50:20 <ggVGc> maerwald: yeah, maybe. But then it could at least compile to Haste or Purescript
16:50:20 <dmj`> data VTree action = Node [ Attribute action ] [ VTree action ] | TextNode String 
16:50:27 <ggVGc> I dunno
16:50:31 <ggVGc> to not implement everything once again
16:50:33 <Cale> Oh, btw, in the talk Ryan mentions that someone is actually using reflex to build a midi synthesizer library already
16:50:42 <ggVGc> hah, cool
16:50:42 <Cale> but he didn't mention who it was
16:50:45 <ggVGc> gonna listen to it
16:50:45 <ggVGc> thanks
16:51:05 <dmj`> ertes: it comes down to purity, and how you manage state and state transitions. The elm arch. give you purity, and what comes with that is serializeability, and replayability, which is great for testing. 
16:51:48 <ertes> elm started out as such a great idea, and it had so much potential with all the neat features like the time-travelling debugger…  but ultimately it went in the opposite direction
16:52:02 <ggVGc> ertes: yeah, I feel the same
16:52:03 <dmj`> if we reimplemented our own VTree / diff / patch we could compile on both client and server. Then just provide ToHtml VTree (on server), so we could share the types, this is something that FFI'ing into virtual dom doesn't give you
16:52:16 <ggVGc> I'm a bit weirded out about the ELm project now
16:52:27 <ggVGc> and I was really enthuseastic about it at first
16:52:34 <Welkin> haha, same
16:52:36 <ggVGc> even wrote a small game in it to get a better look
16:52:42 <dmj`> ertes: that might have been the product of its runtime system, we have a very good runtime system in ghcjs :)
16:52:44 <Welkin> the time-travelling debugger was the killer feature for me
16:53:17 <ggVGc> Now I'm starting to feel like ELm is just a less mature Purescript
16:53:32 <dmj`> ggVGc: well it's less type safe that's for sure
16:53:44 <ggVGc> kind-of-purescript
16:53:46 <ReinH> ertes: is there anything on reflex per se, rather than reflex for writing SPAs using GHCJS?
16:53:48 <mvaenskae> alright, i am close to finished with my program, just having one more issue and that is a bug i believe in Data.Map.Strict
16:54:07 <Cale> Really?
16:54:15 <ertes> the first letdown was that it wasn't actually FRP…  now i could live with that, if i can emulate FRP within its semantics, but i can't:  it's first-order
16:54:25 <ggVGc> I highly doubt there is a bug in Map.Strict
16:54:27 <ggVGc> but maybe
16:54:29 <mvaenskae> https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Strict.html#v:delete <-- this should return a map again same as the input, right?
16:54:53 <Welkin> mvaenskae: it does
16:55:01 <Cale> Well, it should be the same type as the input Map...
16:55:07 <mvaenskae> i shall post code and output of ghci
16:55:37 <ertes> ReinH: "SPA"?
16:55:41 <ggVGc> it would be really really upsetting if there's some obvious bug in Map.Strict.deletre
16:55:44 <ggVGc> delete*
16:55:49 <dmj`> ertes: single page application
16:55:54 <mvaenskae> code: https://bpaste.net/show/d33c30d90067
16:56:05 <mvaenskae> ghci compile output: https://bpaste.net/show/6b7dada3e897
16:56:09 <dmj`> ertes: all interaction is client side, including navigation and all requests done async
16:56:15 <mvaenskae> i fail to see how the type is even determined
16:56:23 <ReinH> ertes: I want to understand reflex per se, rather than reflex + reflex-dom + GHCJS + websockets + ...
16:56:39 <Welkin> mvaenskae: works for me
16:57:10 <mvaenskae> Welkin: what is your type of delete and deleteAt?
16:57:16 <ertes> ReinH: the haddocks are the most helpful resource there…  personally i don't use reflex-dom…  i've just played with it
16:57:31 <ertes> ReinH: the most important module is Reflex.Class, which is the semantics
16:57:33 * ggVGc starts writing reflex-midi
16:57:53 <Welkin> mvaenskae: once again, you are missing type declaration on everything
16:58:08 <mvaenskae> are you blind?
16:58:11 <ertes> ReinH: if you don't use any framework (that's typically how i use reflex), you'll also be interested in Reflex.Host.Class
16:58:18 <mvaenskae> i have included for most of my functions a type declaration
16:58:36 <ggVGc> "most", i.e not everything
16:58:37 <Cale> ggVGc: You might want to talk to ryantrinkle (he's online right now, but is only idling in #reflex-frp at the moment) to find out who was already working on one.
16:58:48 <ggVGc> Cale: :) I need to watch the talk firt
16:58:54 <ggVGc> and start plaing with reflex
16:58:55 <Welkin> mvaenskae: [Char] is just String
16:59:04 <Welkin> that will make it easier to read at least
16:59:06 <ggVGc> before I have anything useful to get out of that
16:59:07 <ggVGc> but yeah
16:59:12 <mvaenskae> seriously, but that is not helpful in this case as in my case it actually deletes the mapping of (key, value) leaving me with values only
16:59:24 <ReinH> ertes: thanks
16:59:26 <ertes> ReinH: in that case you'll need Reflex.Spider, too…  that one is an implementation of the semantics from Reflex.Class
16:59:38 <Welkin> mvaenskae: that is not what delete does...
16:59:49 <Welkin> it removes a single item from the Map
17:00:00 <mvaenskae> Data.Map.Strict
17:00:03 <Welkin> ys
17:00:04 <Welkin> yes
17:00:27 <Cale> mvaenskae: delete can only remove an element -- it produces the same type of result as the Map you give it, so it can't just leave you with the values and not the keys
17:00:39 <mvaenskae> it does Cale
17:00:51 <Cale> mvaenskae: where?
17:01:04 <ertes> ReinH: i've pasted a very small no-framework example you can use to get an idea:  http://lpaste.net/159333
17:01:06 <Cale> How are you applying it?
17:02:10 <Cale> mvaenskae: If you remove the delete operation (which should typecheck), are you left with the thing you expected?
17:02:33 <mvaenskae> i am Cale 
17:02:41 <Cale> mvaenskae: are you referring to the commented out lines in printXterm?
17:03:05 <dmj`> ertes: how would you use the history API w/ reflex?
17:03:08 <mvaenskae> Cale: let to_print = deleteAt 3 $ fromList special_colours
17:03:09 <Cale> Note that mapM_ iterates over the values of a Map
17:03:17 <ertes> dmj`: history API?
17:03:43 <mvaenskae> Cale: if i don't do delete or deleteAt my xtPrintSpecial is being called correctly
17:04:07 <dmj`> ertes: yes
17:04:24 <dmj`> the html5 history api
17:05:15 <ertes> you probably use ghcjs-dom and connect that to reflex (or perhaps reflex-dom has something predefined)
17:05:20 <Cale> mvaenskae: what's the type of the Map?
17:05:34 <ertes> i'm not familiar with the history API
17:05:37 <dmj`> ertes: how does reflex allow you to plugin arbitrary IO actions into its FRP system
17:05:38 <mvaenskae> Cale: of which map specifically?
17:06:02 <Cale> One that you're having trouble deleting an element from
17:06:05 <ertes> dmj`: there is a control part, the "main loop" if you will, from where you do all the IO
17:06:27 <ertes> dmj`: the argument to runSpiderHost
17:06:59 <Cale> mvaenskae: Also, what's the intended type of printXterm?
17:07:10 <Cale> Especially: what's the type of colours meant to be?
17:07:40 <mvaenskae> Cale: it should be of type [([Char], [Char])]
17:08:29 <Squarism> ertes, your architecture is coming along well here. Ive implemented the server part of the game. Done most cumbersome parts of UI in Elm and will now conenct the 2 with websockets. 
17:08:33 <Welkin> so your Map is Map String String
17:08:41 <Cale> So it's a list of pairs of strings, and then you zip it with a list of strings... to get  special_colours :: [(String, (String, String))], yeah?
17:09:02 <Cale> and so  fromList special_colours :: Map String (String, String) ?
17:09:08 <Cale> Is that what's intended?
17:09:10 <mvaenskae> oh and colours is supposed to be [[Char]]
17:09:16 <Cale> oh
17:09:21 <ertes> Squarism: are you sure you want/need websockets?
17:09:34 <ReinH> ertes: thanks again
17:09:41 <Cale> mvaenskae: You really should put a type signature on printXterm which says this
17:09:57 <Cale> It'll make the compiler's errors much easier to understand the more type signatures you put in
17:09:58 <Squarism> ertes, well i do need bidirectional communication? Thought websockets was the thing to use
17:10:19 <ggVGc> Squarism: long polling is almost always good enough
17:10:30 <Cale> (and it'll catch problems which arise where the inferred type of something isn't what you were hoping)
17:10:33 <ggVGc> unless you need very high frequency interactions
17:10:35 <Welkin> Squarism: it's not the only solution
17:10:39 <Welkin> there is also http2
17:10:46 <ertes> ReinH: you're welcome
17:10:50 <Cale> mvaenskae: So, colours :: [String]
17:10:54 <mvaenskae> my first proper program which actually goes beyond lectures so yeah, i am not highly certain of the type signatures as it was never so important for us to design it
17:11:10 <Welkin> mvaenskae: then your teacher is teaching it wrong
17:11:11 <Cale> So we have  special_colours :: [(String, String)]
17:11:21 <Cale> and so  fromList special_colours :: Map String String
17:11:57 <ggVGc> Squarism: how many interactions per second do you need between server and client?
17:12:06 <Cale> mvaenskae: So the function argument to mapM_ should have type (String -> IO ())
17:12:36 <Cale> but, xtPrintSpecial :: ([Char], [Char]) -> [Char], and ([Char], [Char]) is not String
17:12:51 <Squarism> ertes, ggVGc, Welkin as im not very keen on troubleshooting / experimenting with this aspect of my app. Just wanna spend as little time as possible getting the communication going. Ofcourse i want to use something that "works" for most people. Ie. the standard way of doing it.
17:13:14 <mvaenskae> Cale: i use function application to convert ([Char], [Char]) -> [Char]
17:13:24 <Cale> mvaenskae: hm?
17:13:26 <ggVGc> Squarism: probably long polling then, which is how server/client web apps have been built the past decade
17:13:27 <mvaenskae> and then use putStrLn on that which should be fine
17:13:29 <ggVGc> before websocktes
17:13:36 <Cale> mvaenskae: The problem is that you don't have a (String, String)
17:13:50 <Cale> mvaenskae: mapM_ iterates over the values in the map, it doesn't use the keys
17:13:55 <ertes> Squarism: not necessarily…  i recommend that you watch this talk, if you've got half an hour to waste:  https://www.youtube.com/watch?v=zgI0H28AgGY
17:14:02 <Cale> :t mapM_
17:14:03 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
17:14:11 <Squarism> ggVGc, well.. its a board game so its not intense. But it would feel nice if the technology is scalable. Be able to say "I could have 100s of games running at the same time" 
17:14:11 <Cale> We're using t = Map String
17:14:15 <Cale> and m = IO
17:14:30 <ertes> Squarism: in general "HTTP push" tends to have lower engineering overhead
17:14:37 <Cale> and presumably a = String too, since it was a Map String String
17:14:40 <ggVGc> Squarism: still long polling. You need websockets for things like audio communication, very low latency action games etc.
17:14:51 <mvaenskae> Cale: i fail to see the issue because the moment i remove --delete "string" $ fromList $ -- i get it working just fine
17:14:58 <Cale> So in this case, mapM_ :: (String -> IO b) -> Map String String -> IO ()
17:15:10 <Squarism> ertes, ok ill do it
17:15:13 <Cale> Well, sure, if you iterate over a list of pairs
17:15:16 <ertes> Squarism: and there are a few other caveats with websockets that one needs to be aware of…  in general, if you don't need any "as real-time as possible" features, websockets are probably not the way to go
17:15:17 <Cale> then the types will line up
17:15:21 <Welkin> mvaenskae: follow the types and listen to Cale
17:15:23 <Cale> because you're iterating over the elements of a lsit
17:15:25 <Cale> list*
17:15:28 <Welkin> he knows what he's doing
17:15:34 <Squarism> ertes, ok.. good to know
17:15:43 <ertes> Squarism: not that websockets are bad, but they have a rather narrow application domain
17:16:12 <Cale> mvaenskae: If you do  mapM_ (...) special_colours
17:16:34 <ertes> also the bidirectionality refers to "bidirectionality over a single connection", which most of the time you don't need
17:16:58 <ertes> there is nothing wrong with firing up a second connection for sending
17:17:04 <Welkin> Squarism: what are you making?
17:17:18 <Cale> then we need to match t a with [(String, String)]
17:17:27 <Welkin> snoyberg has a very simple implementation of a webchat irc client using http push
17:17:27 <Cale> So t will be [], the list type constructor
17:17:34 <Cale> and a will be (String, String)
17:17:59 <Cale> and so the function argument to mapM_ in that case takes a pair of strings
17:18:11 <Cale> mvaenskae: Does that make sense?
17:18:48 <Cale> The problem isn't with delete
17:18:55 <Cale> it's the fromList
17:19:18 <Cale> You're converting this thing into a Map, and then expecting to iterate over the keys
17:19:28 <Squarism> Nothign fancy.. just wanted to learn haskell and find a good method of making digital boardgame adaptions. Its called Julius Caeasar and is a "block wargame" if that says somethign.  https://www.boardgamegeek.com/boardgame/37836/julius-caesar
17:19:30 <Cale> but mapM_ doesn't give you the keys of the map
17:19:49 <Welkin> oh, for a boardgame websockets is overkill
17:19:54 <Squarism> --> Welkin 
17:19:55 <Welkin> it is turn based
17:19:57 <Cale> It gives you the elements of whatever data structure
17:20:15 <mvaenskae> Cale: i am just... confused by the system completely right now
17:20:33 <ertes> Squarism: i agree, don't use websockets…  if all you want is instant feedback (instead of waiting for the server reply), you should use something like predictive folds on the client side
17:20:43 <Welkin> mvaenskae: you wrote expressions that are too long/complex without writing types for them
17:20:47 <Welkin> so no wonder you got confused
17:20:54 <Welkin> this is what we warned you about earlier today
17:20:55 <monochrom> Does Julius Caeser make you use the Caeser cipher? :)
17:21:05 <Squarism> ertes, Ill watch your video. Ive got the client working with websockets so i might persue that path just to start with the integration. Hopefully it will be an easy to replace layer.
17:21:06 <Welkin> write all your types and let the types guide your program
17:21:09 <Welkin> you can't go wrong if you do that
17:21:14 <Welkin> Cale just did exactly that
17:21:27 <Cale> Well, you can, but it's a lot harder to go wrong :)
17:22:14 <ertes> Squarism: what i call a "predictive fold" is like a regular left-fold, but keeps a sequence of stuff sent to the server that hasn't been acknowledged yet…  the fold just pretends that it has been acknowledged, but if the server answers anything unexpected, it just goes back to the last state that both sides agreed upon
17:22:20 <ertes> Squarism: i hope that makes sense
17:23:07 <Cale> Why go to such trouble to avoid a websocket?
17:23:18 <ertes> Cale: because websockets can be trouble themselves
17:23:27 <mvaenskae> i most certainly can and will go wrong on my first days of "actual world" programming as the core of our exercises was small on scope
17:24:00 <ertes> Cale: proxies don't like them, support is far from ubiquitous, and there is engineering overhead
17:24:36 <davean> Don't forget virus checkers
17:24:42 <Welkin> lol, really?
17:24:56 <davean> that wait untill the connection terminates to verify there isn't a virus and passing the first byte through
17:25:15 <davean> (yes, they'll buffer any amount of data in memory first)
17:25:25 <Cale> hah
17:25:38 <ertes> davean: i think most virus scanners understand streaming today =)
17:25:46 <levi> That sounds like some fun hard-to-diagnose brokenness.
17:25:47 <monochrom> I hope they guard against buffer overrun on themselves.
17:25:48 <davean> I've had to cancel several projects due to these issues and I've lost days of sleep due to deugging that stuff
17:25:51 <ertes> otherwise you couldn't watch an online video with those virus scanners
17:25:55 <Cale> monochrom: hahahaha
17:25:57 <davean> ertes: you'd think, but I have strong evidence you're wrong
17:26:10 <Welkin> does anyone run a virus scanner on linux?
17:26:13 <Cale> Remote execution by virus checker
17:26:13 <davean> ertes: A lot of videos are multiple connections
17:26:26 <davean> cutally, remote execution by virus checker is a common thing
17:26:30 <mvaenskae> Cale: doing mapM_ (..) special_colours i get "t a" which must match [(String, String)] you say? and you mention that 't' is '[]' and 'a' is "(String, String)
17:26:43 <Cale> :t mapM_
17:26:44 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
17:26:46 <davean> Both in their proxy, but their zip implimentations have been a common target
17:26:50 <davean> particularly related to meail
17:26:50 <Cale> ^^ I'm referring to the t a in that
17:27:18 <Cale> If you give a list of something, then t a = [a]
17:27:34 <Cale> and if it's a list of pairs of strings, then a = (String, String)
17:28:15 <mvaenskae> that makes sense
17:28:35 <Cale> So in that case, we get that the function you give in the first argument is receiving a pair of String values
17:28:56 <Cale> But now consider t a = Map String String
17:29:16 <Cale> Function application associates to the left, even at the type level, so that matches as t = Map String, and a = String
17:29:38 <monochrom> yeah, "Map String String" means "(Map String) String", so t = Map String here.
17:30:01 <mvaenskae> gnah, right and left association
17:30:04 <mvaenskae> i always confuse them
17:30:36 <mvaenskae> and that was highly likely what caused the issue for me in this case
17:31:13 <monochrom> fortunately Haskell is pretty self-consistent on this. you just have one thing to memorize, not two things.
17:31:38 <monochrom> to be sure Haskell has some other inconsistent aspects, but not this one.
17:31:39 <bluezone> Kind of neat how it compiles directly to binary executables
17:31:43 <Cale> mvaenskae: Well, it wouldn't make any sense to associate to the right here: Map (String String) would mean that you're applying String as a function to the type String
17:31:48 <bluezone> it's the first language I use that does so
17:32:09 <Cale> But perhaps you were thinking something like Map (String, String)
17:32:20 <ertes> the inconsistency i run into most frequently is -XTupleSections not being standard
17:32:28 <ertes> > map (, 2) [1,3,5]
17:32:28 <Cale> (but that just isn't how it works)
17:32:29 <lambdabot>  [(1,2),(3,2),(5,2)]
17:33:32 <mvaenskae> Cale: true, that doesn't make too much sense... 
17:33:45 <mvaenskae> it's been way too long for this simple parser, around 12h now
17:33:58 <Cale> bluezone: The library I use for work, reflex-dom, is a GUI library which if you compile with GHC, you get native code desktop applications that use webkit-gtk, and if you compile with GHCJS, you get web pages using javascript :)
17:34:08 <mvaenskae> but alas, i learned a lot more haskell than i thought i wanted and am happy with my results
17:34:16 <mvaenskae> i just have to fix one more bug from the looks...
17:34:26 <bluezone> nice
17:34:30 <Cale> mvaenskae: Maybe just convert the Map immediately back to a list?
17:34:42 <Cale> given that you're iterating over it anyway
17:34:48 <bluezone> I'm not sure if I can find haskell jobs around here
17:35:16 <ertes> bluezone: the way you get both a compiler and interpreter that actually agree with each other is very useful for rapid prototyping…  i think i haven't seen anything like that in other languages
17:35:20 <ertes> even the compiled ones
17:35:26 <monochrom> the inconsistency I have in mind is: module F(x,) is allowed, import F(x,) too, but not module F(,x), import F(,x), [1,2,3,], [,1,2,3]
17:35:39 <Squarism> ertes, about the folding. Ill take note of that for later.. when-and-if i rip out that websocket stuff
17:35:59 <ertes> Squarism: that one could be useful, even if you use websockets
17:36:10 <monochrom> (and recall that do {;;; return 0 ;;;} is allowed)
17:36:14 <ertes> Squarism: it allows instant user feedback, which is always a good thing
17:36:58 <ertes> Squarism: i considered writing a library for that, because i actually use it quite often
17:37:10 <ertes> would anyone else find this useful?
17:37:59 <monochrom> Cale: Is the goal to mapM_ over the dictionary, but we need the keys too?
17:38:37 <mvaenskae> Cale: that i did, it just prints the entries now for one case in the incorrect order
17:38:40 <mvaenskae> which is confusing
17:40:00 <Iceland_jack> Tangent, I use this a lot for pure expressions
17:40:01 <Iceland_jack>     foo = do
17:40:01 <Iceland_jack>       let a = "hi"
17:40:04 <Iceland_jack>       a ++ a
17:40:59 <mvaenskae> ah, i see what is happening, it returns the list ordered :(
17:41:08 <hpc> Iceland_jack: i like that that works
17:41:11 <monochrom> hmm, you could exchange the do for an in. foo = let a = "hi" in a++a
17:41:34 <Iceland_jack> monochrom: I use that too sometimes
17:41:34 <Iceland_jack>     foo = let
17:41:34 <Iceland_jack>       a = "hi"
17:41:34 <Iceland_jack>       b = "bye"
17:41:37 <Iceland_jack>       in a ++ b
17:41:42 <Iceland_jack> The 'in' has always rubbed me the wrong way
17:41:59 <monochrom> true, it is also something you never can decide how to indent :)
17:42:17 <Iceland_jack> I ended up indenting it one more space than the 'let'
17:42:50 <monochrom> I chose aligning "in" with the binded names
17:42:52 <Iceland_jack> when I do use it, I use the trailing 'let' as above or
17:42:52 <Iceland_jack>     let a = "hi"
17:42:52 <Iceland_jack>         b = "bye"
17:42:52 <Iceland_jack>      in a ++ b
17:43:09 <monochrom> err, no, I chose aligning "in" with "let'
17:43:50 <Iceland_jack> oh, I never thought of this...
17:43:55 <monochrom> and "let" on a new line if necessary
17:43:59 <Squarism> ertes, for what do you use it? 
17:44:14 <Iceland_jack>     foobar = let
17:44:14 <Iceland_jack>          a = "hi"
17:44:14 <Iceland_jack>          b = "bye"
17:44:14 <Iceland_jack>       in a ++ b
17:44:17 <Iceland_jack> best of all worlds or worst, you decide
17:45:01 <monochrom> I love worst of all worlds, it's more funny.
17:45:26 <monochrom> Earlier today I invented the substring-search algorithm of: hash all substrings, then do KMP over the hash values.
17:45:44 <ertes> Squarism: instant response in user interfaces, relevant for anything that needs to make a network roundtrip to advance the application state, but in almost all cases can predict what the outcome will be
17:46:57 <Iceland_jack> That's pretty bad, almost as bad as padding every parentheses with one-two spaces :)
17:47:04 <ertes> Squarism: imagine for example a text box the logic of which is handled on the server side, so every character you type and every cursor movement needs to be acknowledged by the server (perhaps because there are rules or other users involved)…  but most of the time the server will just agree, so instead of waiting, you could update the UI instantly
17:47:35 <dolio> Put the 'in' on the last line of the last declaration.
17:48:35 <ertes> Iceland_jack: in 'let X in Y' i actually prefer X and Y to have different indentations…  it helps readability
17:48:40 <deech> I just started a package and I'm getting "<blah> is a package module" when I try to Cabal build. What am I doing wrong?
17:50:41 <Iceland_jack> ertes: I do agree with you, but I prefer it in the first version I posted
17:50:41 <Iceland_jack>     longFunctionName a b = do
17:50:41 <Iceland_jack>       let c = a ++ b
17:50:41 <Iceland_jack>  
17:50:44 <Iceland_jack>       c ++ "!"
17:50:47 <Iceland_jack> just because I value predictable indentation, only if I really followed that I would write
17:50:51 <Iceland_jack>     let 
17:50:54 <Iceland_jack>       c = a ++ b
17:50:57 <Iceland_jack> but that's a bridge too far
17:52:17 <ertes> Iceland_jack: just don't forget that you're writing for humans, not computers…  that's why i find that "comma first" list style highly questionable
17:52:56 <mvaenskae> out of interest, can i give a type definition for something defined via "let foo = ble" ?
17:53:02 <Iceland_jack> I have different styles depending on projects, but usually I am too impatient to optimize for anyone other than me 
17:53:10 <ertes> mvaenskae: a type signature, sure
17:53:23 <ertes> mvaenskae: let x :: …; x = …
17:53:37 <Iceland_jack> mvaenskae: sure
17:53:37 <Iceland_jack>     action = do
17:53:38 <Iceland_jack>       let puts :: String -> IO ()
17:53:38 <Iceland_jack>           puts = putStrLn
17:53:41 <Iceland_jack>       puts "Hello, World!"
17:53:51 <Iceland_jack> Impatient and selfish
17:54:00 <ertes> and very noisy on IRC =)
17:54:13 <Squarism> ertes, ok.. sounds sane. Much like the techniques in network action games (early atleast). 
17:54:26 <Iceland_jack> Yes I'm aware, I try to keep the code examples as short as possible
17:54:49 <ertes> Squarism: yeah, actually that's exactly what i mean
17:55:00 <mvaenskae> thanks, i will use that from now when i define something with let to give it as well a signature :)
17:55:31 <Iceland_jack> mvaenskae: Good
17:55:46 <ertes> Squarism: just pretend that the server has acknowledged, and backtrack in the rare cases when it actually disagrees
17:55:54 <Iceland_jack> "You can never have too many type signatures." as the wind told me
17:56:13 <ertes> actually you can
17:56:32 <Iceland_jack> Interpret poetically
17:56:52 <ertes> unless you heavily use ScopedTypeVariables, too many type signatures can actually hurt the performance of your code
17:56:53 <Iceland_jack> That's why I preach InstanceSigs
17:56:58 * mvaenskae is too lazy to implement his own map and corresponding deletion function
17:57:17 <ertes> in other words: the monomorphism restriction is your friend – most of the time
17:57:22 <mvaenskae> so the output will have 2 lines flipped but that doesn't matter as it matches by string in that case not by order :)
17:58:18 * mvaenskae could now try implementing a file writer but rather not
17:59:39 <ertes> dealing with IO is probably the most important section on your way to mastering haskell =)
17:59:56 <ertes> i'd say IO is the most complicated thing about haskell (and this has nothing to do with monads)
18:00:10 <mvaenskae> understanding monads and <*> and there was one other sign
18:00:35 <ertes> no, i'm talking about actual practical software engineering in haskell
18:01:35 <gfixler> mvaenskae: <$>?
18:02:12 <mvaenskae> an, it was fmap
18:03:14 <ertes> i don't know why, but it seems like people spend too much time solving project euler-style problems to learn haskell, and when they try to write actual software, they fail and feel miserable ("i can solve all PE problems, so why the hell can't i read run-time configuration from a file and make a TCP connection?!")
18:04:07 <mvaenskae> hm, is there a function which reads in arguments and not lines as input? :)
18:04:26 <ertes> mvaenskae: getArgs gives you the command line arguments, if that's what you mean
18:04:32 <ertes> it's in System.Environment
18:05:53 <mvaenskae> it's a shame that we were told in the first lecture that IO is evil and we should stay away from it
18:06:07 <Iceland_jack>  
18:06:07 <Iceland_jack>  
18:06:07 <Iceland_jack> Yeah IO is not evil at all
18:06:27 <ertes> mvaenskae: that's pure dogma most of the time
18:06:37 <ertes> IO is probably one of the most powerful features of haskell
18:08:13 <mvaenskae> hm, were i to read in getArgs, then i get [[Char]], how would i best then assign those [char] to different vars of my naming? or should that not be done when using getArgs?
18:08:20 <ertes> mvaenskae: there is truth to it: the logic part of your program should be pure, but the part that connects everything can and probably should use IO
18:08:50 <ertes> mvaenskae: notable example: concurrency
18:08:55 <Iceland_jack> mvaenskae: The easy unsafe way to read two command line arguments is
18:08:55 <Iceland_jack>     main = do
18:08:55 <Iceland_jack>       [one,two] <- getArgs
18:08:55 <Iceland_jack>       ...
18:09:32 <ertes> mvaenskae: you should pattern-match on the result:  do args <- getArgs; case args of [] -> putStrLn "gimme some args"; …
18:09:36 <Iceland_jack> "unsafe" because it crashes on 5 arguments, but 90% of the time it's not a huge deal
18:09:46 <mvaenskae> ertes: concurrency is with every language beyond broken imho, you just have to know what evil you want to play aroudn with ;)
18:09:59 <mvaenskae> Iceland_jack: it crashes on exactly 5?
18:09:59 <ertes> mvaenskae: try haskell concurrency =)
18:10:09 <Iceland_jack> mvaenskae: 0,1,3,4,5,6,...
18:10:29 <mvaenskae> ertes: nah, rather not yet, but likely towards the end of the year
18:10:46 <mvaenskae> i just have to use it and it will like me
18:10:57 <ertes> mvaenskae: when you feel comfortable enough using basic IO, i highly recommend that you read The Book
18:11:15 <ertes> mvaenskae: http://chimera.labs.oreilly.com/books/1230000000929
18:11:40 <Iceland_jack> It's a great book
18:11:49 <Iceland_jack> Simon Marlow is an excellent communicator 
18:12:08 <ertes> more importantly he knows what he is talking about
18:12:25 <mvaenskae> ertes: i am a bit confused by your case :) do you just mean pattern matching there?
18:12:44 <ertes> mvaenskae: 'case' *is* pattern-matching
18:14:21 <mvaenskae> hm, i will have to read up on that :)
18:14:34 <mvaenskae> thanks for showing me the getArgs function and giving me a pointer where to commence
18:14:57 <ertes> mvaenskae: you haven't seen 'case' before?
18:15:14 <mvaenskae> could be slipping my mind, 3AM here
18:15:16 <ertes> > case Just 3 of Just x -> x + x; Nothing -> 42
18:15:18 <lambdabot>  6
18:16:59 <p1lg1m> sup sudoers
18:17:50 <ertes> BTW, i tend to think that a program should never complain about "too many arguments"
18:18:19 <ertes> one solution is:  prog -opts x y = prog -opts x && prog -opts y
18:22:11 <Zemyla> ertes: If I have a program that copies one file to another name, then what hapens if I give it three arguments?
18:23:58 <ertes> Zemyla: do what 'cp' does
18:24:30 <ertes> though i don't like its argument order…  the destination-first convention makes more sense to me
18:25:36 <ertes> cp dst src1 src2 = cp dst src1 && cp dst src2  # but that's not quite true…  cp handles the two differently, if dst is a file
18:46:43 <koz_> I absolutely heart Cabal right now.
18:49:35 <gfixler> koz_: wow, that's something I never expected to hear
18:50:26 <ertes> koz_: there are ways to treat stockholm syndrome
18:50:35 <koz_> gfixler and ertes: LOL.
18:53:54 <Squarism> I managed to get a websocket with echo functionallity up and running. So now i got client-server. But, starting the websocket server stops execution(?) and the Scotty rest server doesnt initialize. How should i go about having bothing running together? 
18:54:17 <Squarism> Stops at "startWSSocketServer" in http://lpaste.net/167994 
18:54:22 <Squarism> line 36
18:56:06 <mikail`> Hi, please refer to this code snippet: http://lpaste.net/167990. I am looking for some design advice. I have created two type classes here each of which represent different algorithms to use in the `c` function. Each type in my program can have a function `c` which implements algorithm F and algorithm B. I would like some advice on whether this is the best approach to represent this problem.
18:58:01 <ertes> mikail`: start without type classes
18:58:32 <mikail`> how come?
18:59:10 <mikail`> it makes sense to use them as i have a lot of types which need to implement their own version of the c function
18:59:39 <mikail`> on top of this, there a about 3 to 4 different algorithms that can be used to implement the c function
18:59:47 <ertes> mikail`: take inspiration from sortBy
19:00:05 <ertes> mikail`: sort uses Ord, but sortBy does not use any type class
19:00:41 <Cale> If the type uniquely determines which implementation of the functions you'll want, then going ahead and using type classes sounds sane
19:01:13 <mikail`> Cale: yes the types do define the implementation of the `c` function
19:01:49 <ertes> mikail`: it never hurts to start without classes, and it also helps to see when and why classes can help
19:01:49 <Cale> But if there's going to be different implementations of the function for a single type, or if it would be beneficial to have that flexibility, sometimes it can help to just make the class into a record type
19:02:15 <mikail`> ertes: I did start w/o TCs but then after coding a few examples it made sense to use them
19:02:33 <Squarism> i guess ive hit the stage where i need multiple threads - two ways of doing, and i guess they need to be "synchronized". I can understand this is a huge topic, but would be glad for a direction. Preferably some easy fundamentals. 
19:02:45 <Squarism> two ways of doing IO even
19:03:51 <mikail`> Cale: so I don't know what record types are
19:04:08 <mikail`> how do they help? or should i go away and do some reading first
19:04:13 <Welkin> @where parconc -- Squarism 
19:04:14 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
19:04:57 <Squarism> Welkin, thanks!
19:05:30 <Cale> mikail`: I just mean ordinary data types, with one data constructor, using record syntax, like  data Operations a = Ops { getFrob :: a -> IO Frob, ... }
19:05:43 <ertesx> disconnected
19:06:47 <mikail`> Cale: but then how do you associate that to a type?
19:07:03 <ertesx> mikail`: as a general rule, unless the class is large, i would start with the *By or *With variant…  it doesn't hurt, and sometimes it pays off
19:07:13 <Cale> You don't exactly, you just have values for various types a
19:07:53 <mikail`> Cale: I see - I'm going to explore that
19:08:01 <Cale> Like, if we didn't have the Ord type class, we'd probably have to pass around functions of type (a -> a -> Ordering) for various types a
19:08:57 <koz_> I think I'm misunderstanding Rand from Control.Monad.Random. I wrote 'type Cluster = Rand (IntMap Processor)', but when I try to use Cluster in a type sig, it says it has kind * -> *. Wtf?
19:09:34 <Cale> koz_: I believe Rand is also parameterised on the kind of RNG state you're using, usually it's StdGen?
19:09:45 <coppro> ^
19:09:50 <Cale> Try  Rand StdGen (IntMap Processor)
19:09:57 <koz_> Cale: Ah, OK.
19:10:00 <koz_> Thanks for that!
19:18:38 <lpaste> koz_ pasted “Still unclear on how I use Rand” at http://lpaste.net/167995
19:22:12 <Welkin> koz_: http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#v:randomRs
19:23:19 <koz_> Welkin: That cashes out the generator, which I need to keep around for the final Cluster type.
19:23:29 <koz_> I need it to grab some of its values (and update it appropriately) to do some initial set-up.
19:24:14 <Welkin> that gives you an infinite list of values
19:24:22 <Welkin> just take what you need and pass the rest along
19:25:43 <koz_> Welkin: But that doesn't give me an updated generator. I need the updated generator too...
19:25:57 <koz_> I guess I still don't quite get how to use the State monad (or this variant of it) properly.
19:26:26 <Welkin> you do not
19:26:32 <Welkin> what do you need a generator for?
19:26:37 <Welkin> you have an inifinite list of random values
19:26:57 <koz_> Because later, the cluster will be asked to generate *different* random values.
19:26:59 <Welkin> otherwise, you can do it manually
19:27:10 <Welkin> generates one random value at a time
19:27:34 <Welkin> just use the suingular variant `randomR` then
19:27:37 <Welkin> singular*
19:27:44 <Welkin> it's on the same page
19:28:54 <koz_> Welkin: I understand that - it gives me one random value and an updated state. I need to do this many times, updating the state each time.
19:31:57 <Welkin> or you can just do it once to create two generators, then use randomRs on one, and pass the other one along
19:35:03 <deech> Anyone have some idea of what it means when `cabal build` complains that `<blah> is a package module`?
19:36:29 <Welkin> what is <blah>?
19:36:55 <Welkin> maybe it is empty and doesn't export anything? like Data in Data.List?
19:40:06 <glguy> deech: You should show us all the information you have, what you tried to do, etc
19:40:24 <Squarism> I want to create server serveing multiple users - all taking part in 2-players games. I guess i could start with on big MVar containing all users and all games. But i guess the right way would be to separate the state of connected clients and the states of each individual game? 
19:40:26 <glguy> If you don't know what it means you don't know what information it's safe to omit
19:40:36 <Squarism> one big MVar even
19:42:48 <koz_> I am *horribly* confused over the proper use of Rand.
19:42:53 <koz_> Like, I actually do not get it.
19:43:39 <Welkin> koz_: just create a generator, then run the generator
19:43:55 <Welkin> pass the new generator along to use it again later on
19:44:02 <Welkin> you can make as many generators as you want
19:44:21 <Welkin> if you need a lot of random values all at once, use randomRs to get an infinite list of random values
19:44:57 <Welkin> every time you want to use randomR or randomRs, you need a new, unused generator
19:45:34 <koz_> Welkin: Basically, I have a bunch of Processors. I need to set them up, and the setup requires selection of two values from an indexed collection randomly. Some choices of value (unforeseeable initially) will yield bad results, which I can check for once the choice is made. If I get a bad result, I need to try again. Throughout, the generator needs updating, and the same generator is used to generate all the
19:45:36 <koz_> Processors in a Cluster.
19:45:49 <koz_> I don't really know how the fuck I would write this.
19:46:09 <Welkin> what do you mean the generator needs updating?
19:46:15 <Welkin> the bounds of the output?
19:46:40 <Welkin> you specify the bounds when you run the generator
19:47:28 <koz_> Suppose I start with (mkStdGen 42) or whatever. Then, I wanna generate Processor 1. I will need to call randomR to do it, but it could be several times, and I dunno ahead of time how many. Then I need to generate Processor 2, using the same generator, updated to take into account that it generated values to make Processor 1 (as otherwise, it would generate the same values over and over again).
19:47:38 <koz_> And so on and so forth.
19:48:36 <Welkin> > take 5 $ randomRs (0,20) (mkStdGen 0)
19:48:38 <lambdabot>  [14,2,12,12,10]
19:48:45 <Welkin> that is how you use it
19:48:56 <Zemyla> Oh, you know how I was wanting an AST for use with the hint library, instead of passing it Strings?
19:49:14 <Welkin> > take 100 $ randomRs (0,20) (mkStdGen 0)
19:49:15 <lambdabot>  [14,2,12,12,10,10,15,19,4,12,17,7,15,13,14,7,17,12,0,0,4,18,0,11,7,8,20,0,17...
19:49:29 <koz_> Welkin: Thanks, but I'm clearly not making myself understood properly.
19:49:45 <koz_> I'll try and figure it out on my own, because I'm clearly not communicating my intent clearly.
19:50:09 <Welkin> koz_: you can use getStdGen to get a generator from the system
19:50:19 <Welkin> instead of providing a seed value yourself
19:50:48 <koz_> Welkin: I wanna have reproducibility, hence my use of a fixed seed rather than the one I get via an IO op.
19:50:56 <koz_> It's OK - I'll figure it out on my own.
19:50:57 <Zemyla> Well, why doesn't it use Template Haskell?
19:51:04 <zRecursive> Welkin: what's an elegant way to make randomRs not to produce repeated numbers ?
19:51:20 <zRecursive> s/repeated/not repeated
19:51:21 <Welkin> zRecursive: just check if the number has already been used, then ignore it
19:51:34 <Welkin> or you can take a large number of them and filter for uniques
19:52:25 <monochrom> or use shuffling 
19:52:26 <zRecursive> Now i use (\\) to kick out the choosed number before doing the next choice.
19:52:37 <Welkin> that's fine too
19:53:44 <zRecursive> but i am not sure (\\) is O(?) if the list is long ?
19:54:37 <Welkin> if you really care about that, you could track your "used" values in a Set and just do a lookup when you grab a new value
19:55:19 <Welkin> but yes, it seems that list difference is O(n^2)
19:55:30 <Welkin> I haven't seen the implementation though
19:55:49 <zRecursive> ok, thanks 
20:19:08 <koz_> Is there some reason why Set and Map have an elemAt operation, but IntSet and IntMap don't?
20:26:17 <gfixler> koz_: well, they're based on different kinds of trees
20:26:32 <gfixler> koz_: not sure if that's why, but IntSet is missing an Indexed section in its docs
20:26:48 <gfixler> sets and maps aren't naturally ordered
20:27:45 <gfixler> I guess the implementation of Set is ordered, as fromList has an Ord constraint as well
20:28:05 <koz_> gfixler: Yeah - I had a look at the data structure at the heart of the Int{Set, Map}, and it is indeed unordered.
20:28:18 <koz_> (well, in the sense that you can't really iterate over it sensibly)
20:28:32 <gfixler> Data.Set is size balanced binary trees, and Data.IntSet is big-endian patricia trees
20:28:41 <koz_> Oh well, looks like I'll just use Set Int Bool instead.
20:28:45 <koz_> s/Set/Map
20:29:14 <ertes> koz_: adding efficient indexed operations would require additional information that is not already found in the tree
20:29:35 <koz_> ertes: Yeah, I can see that now. Should have read what the underlying data structure was.
20:30:03 <ertes> with Set and Map the information is there anyway (because it's used for balancing)
20:30:14 <ertes> so there is no extra cost
20:30:49 <gfixler> ah, PATRICIA is an acronym: "Practical Algorithm To Retrieve Information Coded In Alphanumeric"
20:31:00 <gfixler> PATRICIA tries are radix tries with radix equals 2
20:31:04 <ertes> a.k.a. "radix tree"
20:34:06 <mjrosenb> are things like process included with ghc?
20:36:19 <gfixler> mjrosenb: process?
20:37:34 <koz_> mjrosenb: You mean kernel processes or something? Like, the ability to fork new processes?
20:38:08 <mjrosenb> yes. specifically, the package name process.
20:39:04 <mjrosenb> ghc-pkg list | grep process process-1.2.3.0
20:39:19 <mjrosenb> ... there was a newline in there when I pasted it
20:39:21 <koz_> Is there a safe version of Data.Map.findMin anyplace?
20:39:45 <koz_> Oh, never mind, minView is a thing, derp.
20:46:32 <mjrosenb> but yeah, I'm trying to build a package that requires me to upgrade the system version of process to something newer than 1.2.3.0, but ports doesn't seem to have it listed, which leads me to believe that it is bundled with ghc.
20:48:29 <glguy> mjrosenb: Yes, process comes with GHC
20:55:41 <mjrosenb> glguy: so, I'll need to upgrade to ghc-8 in order to get a new process?
20:57:54 <gfixler> mjrosenb: not using stack?
20:58:35 <glguy> The new process builds on GHC-7.10.3
20:58:45 <mjrosenb> gfixler: I tried using cabal, but after poking at it for a bit, I couldn't figure out how to get it to install to a system directory.
20:58:54 * mjrosenb has 7.10.2 :-(
20:59:10 <glguy> I don't know if that works or not, I don't have 7.10.2
20:59:43 <glguy> It's generally not worth using less than the latest of the major versions
20:59:50 <glguy> 7.6.3, 7.8.4, 7.10.3, 8.0.1
21:00:14 <mjrosenb> anyhow, what I'd prefer is to install all of the dependencies using the package manager
21:00:37 <glguy> Does your package manager have the version you need?
21:01:37 <mjrosenb> it has 7.10.2
21:01:43 <glguy> of process
21:02:01 <mjrosenb> nope, it has 1.2.3; I don't know which version I need, but it is newer than process
21:02:14 <mjrosenb> also, it doesn't have a package for process, it just has the one bundled with ghc
21:02:28 <mjrosenb> I suspect (hope) a ghc-8 package will be forthcoming soon.
21:02:45 <glguy> ghc 8.0.1 comes with process 1.4.2.0
21:04:36 <mjrosenb> so I'll sit tight until 8.0.1 or better makes it in.
21:20:33 <koz_> OK, now I'm in a predicament. I have a Maybe (Maybe [Bool], Bool), and I need a Maybe ([Bool], Bool). What should I do?
21:21:09 <glguy> definitely write a function
21:21:17 <gfixler> join?
21:21:40 <mjrosenb> Data.Maybe.fromMaybe :: a -> Maybe a -> a
21:22:40 <mjrosenb> I always expect that function to be called maybe, not fromMaybe :-(
21:23:04 <glguy> :t (>>= sequenceOf _1) :: Maybe (Maybe [Bool], Bool) -> Maybe ([Bool], Bool)
21:23:05 <lambdabot> Maybe (Maybe [Bool], Bool) -> Maybe ([Bool], Bool)
21:23:27 <koz_> :t sequenceOf
21:23:28 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
21:23:35 <koz_> Ah, dem lenses.
21:24:20 <mjrosenb> next question: can I have cabal include the OS name in the path where it puts executables?
21:24:31 <glguy> :t (\m -> do (a,b) <- m; a' <- a; Just (a',b))
21:24:32 <lambdabot> Maybe (Maybe t, t1) -> Maybe (t, t1)
21:24:41 <gfixler> oh, I misread as Maybe (Maybe ([Bool], Bool))
21:29:55 <koz_> glguy: Yeah - I did basically that.
21:29:59 <koz_> Do-notation to the rescue!
21:34:07 <gtsteel> \quit
21:35:21 <Zemyla> :t maybe -- mjrosenb
21:35:22 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:35:31 <Zemyla> "maybe" is a rather more useful function.
21:53:34 <mjrosenb> because ~ is shared between operating systems, and it would be pretty snazzy if it could use ~/.cabal/bin/FreeBSD and ~/.cabal/bin/Linux
21:53:45 <mjrosenb> or swap the bin and OS, I'm not picky.
21:56:32 <koz_> Grah, how do I State monad.
21:57:00 <geekosaur> in a Stately manner
21:57:04 <koz_> I have a function 'randRow :: RandomGen g => Table -> g -> (Maybe ([Bool], Bool), g)', and as part of that, I need to run a computation that results in a (Int, g) using the same generator.
21:57:59 <koz_> I assume the way to go is do-notation, but I obviously get type issues as a result.
21:58:52 <koz_> I started it as 'randRow t gen = do i <- <the (Int, g) computation above>', but obviously, that doesn't work.
21:58:56 <koz_> Not sure how to do this...
21:59:56 <geekosaur> RandomGen g => Table -> State g (Maybe ([Bool],Bool])
22:00:33 <koz_> geekosaur: I was also told that using State was 'doing it wrong' for this, and I should be using Rand instead.
22:00:43 <koz_> Could you help me make sense of how?
22:01:37 <koz_> Signature should be 'RandomGen g => Table -> Rand g (Maybe ([Bool],Bool])', as I understand it.
22:01:48 <geekosaur> I wouldn't call it doing it wrong, I would say you're doing it a bit toward the hard way --- otoh if you want to figure out how to use State/StateT, this is a reasonable way to do it. (Rand is just State specialized to RandomGen g)
22:02:07 <koz_> geekosaur: I think jle` mentioned something about using Rand instead last time I tried.
22:02:40 <geekosaur> that is, Rand is just a state monad with some conveniences added
22:02:47 <koz_> But ultimately, this doesn't really change the fact that I need to run an (Int, g)-yielding computation inside that function, and I'm not sure how.
22:03:08 <koz_> I *assume* this involves liftRand somehow.
22:04:16 <jle`> yeah, you can use liftRand :: (g -> (Int, g)) -> Rand g Axman6 
22:04:20 <jle`> oops, pressed tab, heh
22:04:25 <koz_> jle`: LOL!
22:04:27 <jle`> liftRand foo :: Rand g Int
22:04:35 <jle`> so you can sequence `liftRand foo` in the middle of your do block
22:04:53 <koz_> We can now generate Axmen.
22:05:01 <koz_> Alrighty, I'll give it a try.
22:05:07 <geekosaur> although it might make more sense to rephrase that computation in terms of Rand so you don't need lift
22:05:19 <geekosaur> *to lift
22:05:24 <jle`> yeah, it'd probably better no never deal explicitly with 'g''s in the first place
22:05:39 <jle`> that's sort of the "point"; a 'Rand g a' is a computation that produces a random 'a'
22:06:19 <geekosaur> ^ Rand lets you not worry about futzing directly with the RandomGen, just do your stuff and it handles the seed for you
22:06:29 <jle`> it's an abstract representation of "an action with randomness"
22:06:41 <jle`> like IO, you create complex IO actions by sequencing together "IO primitives"
22:06:58 <jle`> and with Rand-like approaches, you create complex random-genarting-things by sequencing together random-generating primitives
22:07:08 <koz_> jle` and geekosaur: OK, I'm gonna try and write this and see what happens.
22:07:10 <jle`> like 'getRandom', 'getRandomR', etc.
22:08:34 <jle`> 'liftRand' is mostly for inter-operability with other libraries, i feel
22:09:03 <lpaste> koz_ pasted “jle`: What goes in the hole?” at http://lpaste.net/167999
22:10:33 <cheater> hi
22:10:39 <koz_> Hi cheater!
22:11:17 <cheater> if you were going to sum this up in a couple of sentences what would you say gadts are for? their most important uses
22:11:23 <jle`> koz_: 'return'
22:11:41 <jle`> return :: a -> Rand g a; 'return x' is a Rand action that just produces 'x' all the time
22:11:42 <koz_> jle`: That doesn't compile.
22:11:45 <jle`> so the most boring kidn of random action, heh
22:11:48 <jle`> well, you have the wrong type
22:11:57 <jle`> it should be returning Rand g (Maybe ([Bool], Bool))
22:12:31 <jle`> if you want to randomly produce a 'g', you have to create one
22:12:42 <jle`> someSeed <- makeARandomSeedSomehow
22:12:48 <koz_> jle`: My intent was to run the first computation to get an Int plus twiddle the state, then use that Int, plus the twiddled state to generate the final one.
22:12:49 <jle`> return (getAt, someSeed)
22:12:52 <jle`> but, why?
22:13:01 <jle`> yeah, you don't manually deal with the state
22:13:08 <jle`> you're describing a "random action"
22:13:27 <jle`> you want to describe a random action that produces a Maybe ([Bool], Bool)
22:13:35 <jle`> so the type you want is Rand g (Maybe ([Bool], Bool))
22:13:41 <koz_> Well, what I wanna do is 'make a random Int of the right size, use that to maybe-fetch a row, return result'.
22:14:07 <jle`> sure, get a random Int with getRandom :: Rand g Int
22:14:14 <jle`> and then use it
22:14:19 <jle`> myRandomInt <- getRandom
22:14:24 <jle`> return (use the int to get what you want)
22:15:22 <jle`> or i <- getRandomR (0, M.size rows - 1)
22:15:34 <jle`> return (getAt t i)
22:16:03 <jle`> er, i <- getRandomR (0, M.size (rows t) - 1); return (getAt t i)
22:16:21 <jle`> or `getAt t <$> getRandomR (0, M.size (rows t) - 1)`
22:17:32 <koz_> I still get the wrong type...
22:18:01 <jle`> can you post what you're doing?
22:18:04 <koz_> That seems to expect 'Rand g (Maybe ([Bool], Bool), g)'.
22:18:22 <jle`> er, you're expecting that by having that type signature
22:18:31 <jle`> try using Rand g (Maybe [Bool], Bool) as the type signature
22:18:43 <koz_> Never mind.
22:18:45 <jle`> "expecting" is what you write as a type signature, not what the thing returns
22:18:46 <koz_> I'm severely retarded.
22:18:47 <koz_> Fixed.
22:18:50 <jle`> congrats :D
22:18:55 <Squarism> i accidently read half of chapter 12 in parconc and grasped it! 
22:19:17 <koz_> jle`: Thanks for showing me the Applicative-based approach to this.
22:19:22 <koz_> It makes *much* more sense to me that way.
22:19:24 <jle`> when using Rand, you're supposed to completely ignore the (g -> (a, g)) thing.  it's abstracted away, and in fact, it might not even be implemented like that
22:19:27 <jle`> the implemntation is hidden
22:19:34 <jle`> a more useful type signature might be:
22:19:47 <jle`> randRow :: MonadRandom m => Table -> m (Maybe ([Bool], Bool))
22:20:02 <koz_> Ah, OK.
22:20:07 <koz_> I'll do that then.
22:20:13 <jle`> the abstract nature of what you're describing is more clear there
22:20:27 <jle`> you're describing an entropy-based action that produces a Maybe ([Bool], Bool)
22:20:37 <jle`> and there are plenty of MonadRandom instances, besides just Rand g :)
22:21:04 <koz_> jle`: Thanks so much - that makes *so* much more sense now.
22:21:20 <jle`> also, using MonadRandom m => ..., restricts you to only use "random primitives", like getRandom, getRandomR, etc., which enforces the mindset
22:21:23 <jle`> Squarism: congrats :)
22:22:04 <Squarism> i thought id die on the introduction
22:22:17 <koz_> I should have read Control.Monad.Random.Class too.
22:26:04 <koz_> One of these days, I will get how to properly use monads.
22:26:08 <koz_> *One* of these days...
22:35:24 <Squarism> Modelling a "server state" where some parts needs global sync and some parts only sync between groups of users. Ive gathered i need this data to "model" server state. 
22:35:36 <Squarism> ServerState { clients :: [Client], games :: [RunningGame] }, Client { id:ClientId, con:Connection }, RunningGame { gameId::Int, participants::[ClientId], game::Game }
22:36:01 <Squarism> What is clear is the "clients" need to be an MVar
22:37:04 <Squarism> as a RunningGame is only shared between a group of participants it fowuld feel wrong to make "games" an MVar
22:37:42 <Squarism> rather synchronized per game among participants
22:38:21 <Squarism> any thoughts on this? 
22:43:49 <Ashy> wow persistent is nice
22:45:48 <Squarism> what about this ServerState2 { clients::[Client'], games :: [(GameId,TChan)] } ,type Client' = (Text,GameId, WS.Connection)
22:46:24 <Squarism> where all of ServerState2 would be an MVar?
23:15:44 <mjrosenb> Is there anything that will read all of the data that it can from a handle without blocking?
23:17:59 <koz_> :t join . fmap
23:18:00 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
23:18:00 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
23:18:00 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
23:18:04 <koz_> Whoops.
23:18:24 <Axman6> mjrosenb: hGet?
23:18:48 <koz_> I keep finding myself doing 'join . fmap doFoo'. Is there a function that does this in 'one go'?
23:18:53 <Axman6> I might be wrong... but I believe there is
23:18:55 <koz_> I *swear* there is, but I can't recall it for the life of me.
23:19:00 <johnw> koz_: it's called >>=
23:19:06 <koz_> johnw: Derp.
23:19:10 <koz_> Thanks!
23:19:27 <koz_> :t (>>=)
23:19:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:19:47 <koz_> :t (=<<)
23:19:48 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:21:14 <koz_> Can I write this more concisely? 'return . (mkForm =<<) . (traverse rowToClause =<<) . sequence $ xs'
23:21:25 <Axman6> mjrosenb: hGetBufSome is a very low level interface which does that, I believe ByteString builds on top of it for hGetSome :: Handle -> Int -> IO ByteString
23:21:26 <Skuzzzy> this is why I hate haskell
23:21:42 <koz_> Skuzzzy: You're in a strange choice of channel for hating Haskell. :P
23:21:47 <Skuzzzy> uhhhhhh
23:21:51 <Axman6> koz_: can it be written more clearly? =)
23:22:25 <koz_> Axman6: Let me rephrase. Can it be written more idiomatically? I think the two uses of =<< suggest a composition of some kind, but I have no idea what.
23:23:12 <mjrosenb> Axman6: I dont' see hGet in System.IO.
23:23:14 <Axman6> I can't easily tell what it's doing so it's hard to say. I wuold guess there is a better way though
23:23:41 <Axman6> mjrosenb: yeah I think I made it up. hGetBufSome is the closest
23:24:00 <Axman6> there's also hGetBufNonBlocking
23:24:43 <mjrosenb> Axman6: but that takes a Ptr a, and returns an IO int, I'd like something that just returns an IO String :-(
23:25:03 <lpaste> koz_ pasted “Axman6: Does this help?” at http://lpaste.net/168002
23:25:11 <pavonia> koz_: (>=>), (<=<) perhaps
23:25:41 <koz_> pavonia: So fish together 'traverse rowToClause' and mkForm?
23:25:52 <koz_> :t (<=<)
23:25:54 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
23:26:00 <mjrosenb> that feels way too low level, I just want to process some input in approximately the same order that another program gives it to me.
23:26:01 <Axman6> mjrosenb: what if the data that's available stops half way between a multibyte character? implementing that function is a lot harder than you think
23:26:38 <pavonia> koz_: I haven't looked closely at the types but the combination of (.), (>>=) and return looks like you want that, yes
23:26:51 <Axman6> any reason you cant use hGetContent? you'll get a lazy String of data
23:26:59 <Axman6> s/data/text
23:27:38 <koz_> pavonia: Alrighty, I'll do some fish contemplation. Thanks!
23:28:09 <mjrosenb> Axman6: fair enough.
23:28:33 <mjrosenb> although, I can't imagine it is any more difficult than hGetLine
23:28:59 <mjrosenb> just the granularity has been increased from 'multi byte character' to 'line'
23:31:42 <saurabhnanda> :t sequence (getEnv "a", getEnv "b")
23:31:43 <lambdabot>     Not in scope: ‘getEnv’
23:31:43 <lambdabot>     Perhaps you meant ‘getAny’ (imported from Data.Monoid)
23:31:43 <lambdabot>     Not in scope: ‘getEnv’
23:31:46 <mjrosenb> so I'm like 90% sure I could implement this in C, but I'm not sure how I'd implement it in haskell?
23:32:02 <mjrosenb> I guess I could use ByteString, and one of its error handling functions
23:32:02 <saurabhnanda> :t sequence (System.Environment.getEnv "a", System.Environment.getEnv "b")
23:32:03 <lambdabot> IO (IO String, String)
23:34:29 <saurabhnanda> hey can anyone help me understand the type of sequence (System.Environment.getEnv "a", System.Environment.getEnv "b")?  Why is it IO (IO String, String) and not IO(String, String)?
23:36:50 <EvanR> saurabhnanda: seems like a typo
23:37:07 <saurabhnanda> :t sequence (System.Environment.getEnv "a", System.Environment.getEnv "b")
23:37:08 <lambdabot> IO (IO String, String)
23:37:14 <EvanR> oh
23:37:19 <saurabhnanda> EvanR: check that output from lambdabot
23:37:42 <EvanR> i didnt get sequence was part of the code, so sequence is sequencing over the right component and leaving the first as it is
23:37:58 <EvanR> > fmap (+1) ('a', 3)
23:37:59 <lambdabot>  ('a',4)
23:38:00 <ludat> :t sequence [System.Environment.getEnv "a", System.Environment.getEnv]
23:38:01 <lambdabot>     Couldn't match expected type ‘IO String’
23:38:02 <lambdabot>                 with actual type ‘String -> IO String’
23:38:02 <lambdabot>     Probable cause: ‘System.Environment.getEnv’ is applied to too few arguments
23:38:21 <ludat> :t sequence [System.Environment.getEnv "a", System.Environment.getEnv "b" ]
23:38:22 <lambdabot> IO [String]
23:38:57 <EvanR> you might be thinking about the behavior of Bitraversable
23:39:04 <saurabhnanda> :i ()
23:39:49 <saurabhnanda> interesting () does not have Traversable, but [] does. And the type of `sequence` says that it can work only on Traversable values. If () is not traversable shouldn't it result in a type error, instead of an incorrect result?
23:40:01 <EvanR> kind mismatch
23:40:54 <saurabhnanda> :t sequence [System.Environment.getEnv "a", System.Environment.getEnv "b"]
23:40:55 <lambdabot> IO [String]
23:41:09 <saurabhnanda> okay, I'm not clear how sequence works, or what it's supposed to do
23:41:31 <EvanR> it executes all the action in the list, and returns the list of results
23:41:59 <EvanR> and it can generalize to any traversable
23:42:12 <saurabhnanda> Evaluate each monadic action in the structure from left to right, and collect the results. For a version that ignores the results see sequence_.
23:42:14 <saurabhnanda> sequence :: Monad m => t (m a) -> m (t a)  | 
23:42:17 <saurabhnanda> sorry
23:42:29 <saurabhnanda> sequence :: Monad m => t (m a) -> m (t a) | Evaluate each monadic action in the structure from left to right, and collect the results. For a version that ignores the results see sequence_.
23:42:53 <EvanR> in the case of (env, a), the env goes along for the ride and doesnt participate
23:42:58 <saurabhnanda> I'm expecting `sequence (IO String, IO String)` to evaluate to `IO (String, String)` -- is that incorrect?
23:43:07 <EvanR> yes its incorrect
23:43:10 <saurabhnanda> how?
23:43:17 <saurabhnanda> isn't that what the docs say?
23:43:28 <saurabhnanda> :t System.Environment.getEnv
23:43:29 <lambdabot> String -> IO String
23:43:31 <glguy> Yes it isn't
23:43:32 <EvanR> the structure in this case is the right side of (env,a)
23:43:48 <saurabhnanda> :t System.Environment.getEnv "a'
23:43:49 <lambdabot>     lexical error in string/character literal at end of input
23:43:50 <saurabhnanda> :t System.Environment.getEnv "a"
23:43:51 <lambdabot> IO String
23:44:12 <saurabhnanda> EvanR: glguy: what's the use-case of sequence? What's the correct way to use it?
23:44:33 <EvanR> if you have a traversable structure of actions, you can execute them all and collect the results into the same structure
23:44:47 <EvanR> youre just misunderstanding the pair's traversable instance
23:45:34 <EvanR> > sequence ("foo", Just 3)
23:45:35 <lambdabot>  Just ("foo",3)
23:45:42 <EvanR> > sequence ("foo", Nothing)
23:45:43 <lambdabot>  Nothing
23:45:51 <saurabhnanda> what?!
23:45:59 <EvanR> "foo" isnt executed because it has nothing to do with the monad
23:46:10 <saurabhnanda> hang on, first of all I don't think () is traversable
23:46:15 <EvanR> () ?
23:46:25 <EvanR> its not traversable since it has no type variable
23:46:38 <saurabhnanda> okay let me try again
23:47:08 <saurabhnanda> :i (String)
23:47:14 <saurabhnanda> :i (String, String)
23:47:25 <saurabhnanda> is a tuple of Strings traversable? how do I check
23:47:40 <saurabhnanda> doing :i () in ghci doesn't give me traversable as an instance
23:48:03 <EvanR> (a,b) has two variables and traversable only works with one of them
23:48:28 <EvanR> () and (a,b) are two different types
23:48:39 <EvanR> try :i (,)
23:49:07 <saurabhnanda> yes that's traversable
23:49:19 <saurabhnanda> hmm interesing
23:49:19 <EvanR> nstance Traversable ((,) a)
23:49:23 <EvanR> instance Traversable ((,) a)
23:49:30 <saurabhnanda> :i (,,) is not traversable, which is what I was doing in my app actually
23:49:45 <EvanR> (,,) a b can be made traversable
23:50:01 <EvanR> though you werent asking about (,,)
23:50:16 <saurabhnanda> I thought that was the simplified example
23:50:52 <EvanR> data () = (), data (,) a b = (a,b), data (,,) a b c = (a,b,c) is three different types
23:51:00 <saurabhnanda> but strangely the following line compiles   (cId, cSecret, botToken) <- sequence (getEnv "GOOGLE_CLIENT_ID", getEnv "GOOGLE_CLIENT_SECRET", getEnv "TELEGRAMT_TOKEN") 
23:51:46 <saurabhnanda> and gives an error on a subsequent line, where I'm trying to use cId as a String. It complains that cId is IO String
23:51:50 <saurabhnanda> which got me to check what's going on
23:52:09 <EvanR> i dont know where your instance is coming from, but just change it to a list of actions
23:52:22 <saurabhnanda> :t (System.Environment.getEnv "a", System.Environment.getEnv "b", System.Environment.getEnv "c")
23:52:23 <lambdabot> (IO String, IO String, IO String)
23:52:32 <saurabhnanda> :t sequence (System.Environment.getEnv "a", System.Environment.getEnv "b", System.Environment.getEnv "c")
23:52:33 <lambdabot>     No instance for (Traversable ((,,) (IO String) (IO String)))
23:52:33 <lambdabot>       arising from a use of ‘sequence’
23:52:33 <lambdabot>     In the expression:
23:52:40 <saurabhnanda> and this is not even a valid expression
23:52:47 <EvanR> its valid
23:52:47 <saurabhnanda> how is my program not throwing an error on this line
23:53:00 <EvanR> but lambdabot doesnt have that instance defined
23:53:08 <EvanR> if it did, your code would still be wrong
23:53:10 <saurabhnanda> :t sequence [System.Environment.getEnv "a", System.Environment.getEnv "b", System.Environment.getEnv "c"]
23:53:11 <lambdabot> IO [String]
23:53:31 <saurabhnanda> how do I convert [IO String, IO String, IO String] -> IO [String, String, String]
23:53:39 <saurabhnanda> oh
23:53:42 <EvanR> sequence
23:53:44 <saurabhnanda> sorry IO [String] is the type
23:53:49 <saurabhnanda> it's not a typle
23:54:19 <EvanR> [IO String] -> IO [String]
23:54:19 <saurabhnanda> okay work
23:54:25 <saurabhnanda> thanks, EvanR
23:54:29 <saurabhnanda> work!
23:55:33 <Ashy> how can i get ghc to print the code that TemplateHaskell generates?
23:56:03 <Ashy> something like: ghc --expand-templatehaskell SomeFile.hs
23:56:46 <EvanR> -ddump-splices ?
23:58:21 <Ashy> cheers
23:58:33 <Ashy> wow persistent is generating way more code than i expected
