00:03:51 <lyxia> rfw: what are you trying to do
00:07:37 * hackagebot means 0.1.0.0 - calculate varieties of mean/average using semigroup.  https://hackage.haskell.org/package/means-0.1.0.0 (winterland)
00:07:37 * hackagebot aivika-lattice 0.1.1 - Nested discrete event simulation module for the Aivika library using lattice  https://hackage.haskell.org/package/aivika-lattice-0.1.1 (DavidSorokin)
00:09:48 <hal> s
00:12:31 * hackagebot flow-er 1.0.2 - MOre directional operators  https://hackage.haskell.org/package/flow-er-1.0.2 (expede)
00:17:32 * hackagebot size-based 0.1.0.0 - Sized functors, for size-based enumerations  https://hackage.haskell.org/package/size-based-0.1.0.0 (JonasDuregard)
00:30:27 <jerin> https://paste.fedoraproject.org/378354/raw/
00:30:43 <jerin> This is a hakyll code, how can I make this repeat based on arguments
00:31:09 <jerin> for eg.  I need to do the same thing for "web.html" in "posts/web/*"
00:35:27 <sdx23> jerin: well, make it a function, substitude all occurences by function parameters
00:37:07 <jerin> sdx23: https://paste.fedoraproject.org/378355/raw/ This is what I did
00:37:12 <jerin> but its giving me a lot of errors
00:37:32 * hackagebot test-framework-th-prime 0.0.9 - Template Haskell for test framework  https://hackage.haskell.org/package/test-framework-th-prime-0.0.9 (KazuYamamoto)
00:40:18 <sdx23> jerin: could you show us the errors?
00:41:36 <jerin> sdx23: https://paste.fedoraproject.org/378356/raw/
00:45:23 <sdx23> the last one is due to the way you call it. The second and the third are related. 
00:46:08 <sdx23> Start at the first. It wants an Identifier but you gave it a Pattern. Search hayoo for what these are: http://hackage.haskell.org/package/hakyll-4.8.3.1/docs/Hakyll-Core-Identifier.html
00:47:22 <sdx23> okay, IsString and OverloadedStrings work when it's not a variable. With your construct you must make sure that page is an Identifier
00:47:55 <sdx23> add this in the type signature. Then you'll see the error is at the call site. Maybe use fromFilePath
00:48:50 <sdx23> Most often it is helpful to add type signatures - which makes the errors occur at places they actually are.
00:53:11 <XBoy> -0mujmj- 099+-+/
01:08:47 <jerin> sdx23: thanks. Most errors are resolved
01:09:18 <jerin> sdx23: now how do I call this, map createPage pages doesn't seem to work, says   Couldn't match expected type ‘Rules a0’                with actual type ‘[Rules ()]’
01:10:56 <sdx23> jerin: well you want to merge a list of Rules into one Rules. Lets check what Rules provides.
01:11:02 <merijn> @remember Unknown The plural of developers is a "merge conflict".
01:11:03 <lambdabot> I will remember.
01:11:17 <merijn> If Rules is a Monad you can just "sequence"
01:11:45 <sdx23> http://hackage.haskell.org/package/hakyll-4.8.3.1/docs/Hakyll-Core-Rules.html and so what merijn says.
01:12:35 <merijn> Or rather
01:12:37 <merijn> :t sequence_
01:12:38 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
01:12:43 <sdx23> by the way, note that route takes "Routes". The name suggests to me, that you should take multiple routes to rules, instead of each route to one rule and merge them.
01:14:42 <jerin> sdx23: I've got the desired output, but I didn't get what you meant by rules 
01:15:32 <sdx23> jerin: route :: Routes -> Rules () -- this function. But I'm not sure what I said fits your usecase.
01:17:34 * hackagebot lazy-search 0.1.0.0 - Finds values satisfying a lazy predicate  https://hackage.haskell.org/package/lazy-search-0.1.0.0 (JonasDuregard)
02:08:03 <Profpatsch> Why is it that we now have to add forall in these cases on GHC 8.0.1?
02:08:04 <Profpatsch> https://github.com/jgm/filestore/commit/6aef6646deb703e27228968855d7d9e460e31ef9
02:08:25 <Profpatsch> That’s existential qualification, right?
02:08:53 <koz_> Argh threadscope in sandbox.
02:11:04 <cocreature> Profpatsch: no it’s a rank2type not an existential
02:15:10 <Profpatsch> cocreature: How does that work?
02:15:31 <Profpatsch> FileStore is of Rank *
02:15:35 <Profpatsch> eer, kind
02:15:46 <Profpatsch> But I still have a variable 'a'?
02:16:16 <cocreature> Profpatsch: the rank2type here forces the a to be polymorphic, since it is polymorphic it doesn’t need to be added as a parameter to FileStore
02:16:48 <Profpatsch> Isn’t a type variable always polymorphic?
02:16:58 <m1dnight_> Can you write Functor for a type of kind *?
02:17:01 <merijn> It's basically saying that that field can ONLY have functions that work on every 'a'
02:17:28 <m1dnight_> I have a datatype that takes no type in its constructor but still want to write a functor for my functions that traverse the ast
02:17:33 <merijn> Profpatsch: Well, "Left :: a -> Either a b", but with "Either Int Char" "Left :: Int -> Either Int Char"
02:17:48 <merijn> Profpatsch: This is saying that the 'a' cannot be specialised
02:18:21 <cocreature> MichaelBurge: you can’t write an instance for Functor but you can write an instance for MonoFunctor from mono-traversable
02:20:43 <m1dnight_> Hrm, I really must be missing something fundamental here
02:21:09 <cocreature> eh that was directed at m1dnight_ obviously. I’m too stupid for autocomplete
02:21:47 <merijn> Profpatsch: Consider the case where "Int" is an instance of Contents, then "FilePath -> Author -> Description -> Int -> IO ()" would match "Contents a => FilePath -> Author -> Description -> a -> IO ()"
02:22:19 <merijn> Profpatsch: BUt what if that's not what you want? What if you want to say "this only accepts function that work on EVERY instance of Contents", that's what the RankNType is doing
02:22:25 <dexterph> m1dnight_: a functor f must support a function (fmap) of type (a > b) -> f a -> f b, so a data type of kind * can obviously not support that
02:23:01 <merijn> Profpatsch: Normally within a datatype type variables scope of the entire data declaration, here you are introducing a local scope for the variable 'a' that only covers the "save" field
02:28:05 <m1dnight_> Hrm I get it indeed
02:29:08 <m1dnight_> The thing is, I have an AST that is comprised of three distinct data types. E.g, Type, Protocol, and Choice. And I want to easily apply a function on a root node of the AST that walks all the nodes (including the ones of type Protocol and Choice) that looks/modifies all the Type nodes.
02:30:05 <m1dnight_> Hold on, Im making a minimal example.
02:30:06 <merijn> m1dnight_: It's common to have "data AST a" where 'a' denotes what's on the leaves
02:30:16 <merijn> m1dnight_: Then you can just use fmap
02:31:30 <m1dnight_> https://www.refheap.com/120237
02:31:58 <ggVGc> is it bad practice that I basically always add deriving (Read, Show) when I declare new data types?
02:32:02 <m1dnight_> This is whatI have so far. But I would also want a function that walks over all the strings. (E.g., the string in `TypVar String`) but I guess that might be a fault in my data type.
02:32:19 <merijn> ggVGc: I'd say show is good for debugging, but read not so much
02:32:38 <merijn> ggVGc: Especially since derived Read instances are slow as hell, so you should encourage using them
02:33:03 <ggVGc> should not?
02:33:16 <ggVGc> I mean, did you mean I should not encouerage using them
02:33:30 <koz_> OK, now I'm *really* confused. I used the following .cabal: http://lpaste.net/165879, but when I try to configure, it complains about missing deps!
02:33:41 <koz_> (this went into a sandbox, obviously)
02:33:50 <dexterph> m1dnight_: you can make a function which walks the tree and only 'does something' when it encounters a Typvar
02:34:23 <merijn> m1dnight_: Why not http://lpaste.net/165880 ?
02:35:11 <koz_> (specifically happy, alex and threadscope)
02:35:20 <koz_> (obviously I *don't* wanna profile them)
02:35:26 <merijn> koz_: Why is with-rtsopts in quotes?
02:35:40 <koz_> merijn: Because this: https://nikita-volkov.github.io/profiling-cabal-projects/
02:35:47 <merijn> koz_: You can't really depend on alex/happy since their executables, dependencies only track libraries
02:36:00 <koz_> merijn: How would I have them be available in my sandbox then?
02:36:14 <merijn> koz_: By manually installing them
02:36:19 <koz_> I wanna have threadscope, but I obviously don't wanna do a global install, and there's no package for it in my distro.
02:36:40 <merijn> koz_: If you run "cabal install" while inside a sandbox directory it will only install inside that sandbox
02:36:56 <koz_> OH... I feel stupid now.
02:37:13 <koz_> So would I just call 'cabal install threadscope'?
02:37:18 <merijn> yeah
02:37:25 <koz_> OK, that makes more sense. Thanks!
02:39:13 <Profpatsch> merijn: So this means when I instantiate FileType I have to give a function that can work on all a
02:39:18 <m1dnight_> merijn: You probably meant to change the String in line 11 too, right? 
02:39:18 <ij> Will the stack fill up if I call foo? "foo a = somethingUseful >> when (predicate a) (foo a) >> foo (f a)" 
02:39:26 <m1dnight_> In that case, make sense. Ill give that a go!
02:39:36 <Profpatsch> merijn: Is this a usage of Rank2Types?
02:40:23 <merijn> Profpatsch: Yes
02:40:56 <merijn> ij: No
02:41:23 <merijn> ij: GHC doesn't use a callstack, so infinite recursion is not a problem
02:41:47 <ij> I thought there was a stack, but it just has TCO.
02:41:58 <lpaste> koz_ pasted “What is this I don't even” at http://lpaste.net/165882
02:42:05 <merijn> m1dnight_: Maybe, depends on what it means
02:42:06 <koz_> merijn: ^
02:42:10 <koz_> I don't even *understand* wtf.
02:42:14 <koz_> This is going into a clean sandbox.
02:42:37 * hackagebot flow-er 1.0.3 - More directional operators  https://hackage.haskell.org/package/flow-er-1.0.3 (expede)
02:42:54 <merijn> koz_: "internal error: could not construct a valid install plan." <- what you requested insists on incompatible dependencies
02:43:10 <koz_> merijn: I literally made an empty sandbox and asked it to install threadscope.
02:43:12 <merijn> koz_: "clean sandbox" doesn't equal "everything will always install"
02:43:29 <merijn> koz_: Then someone fucked up their dependency ranges
02:43:34 <koz_> What could be causing this to have these issues? Something in my .cabal maybe?
02:43:54 <merijn> koz_: Which GHC?
02:44:00 <ij> merijn, what does it have instead then/
02:44:09 <koz_> merijn: 8.0.1
02:44:43 <merijn> ij: What does it have for what?
02:44:54 <ij> merijn, Instead of call stack.
02:45:07 <merijn> ij: Nothing, the way haskell is compiled doesn't need a call stack
02:45:39 <merijn> koz_: You seem to have a copy of "text" from somewhere and that version requires a version of binary that's incompatible with threadscope
02:45:57 <merijn> koz_: Since threadscope wants 0.7.6 and your version of text requires 0.8.3
02:46:12 <koz_> Let me do a quick check.
02:46:22 <merijn> So the question is "where is text coming from?"
02:46:32 <koz_> Global - for pandoc from my package manager.
02:46:40 <koz_> So do I need to get rid of pandoc?
02:46:59 <merijn> koz_: You could try installing an old version of text in the sandbox by hand and retyring threadscope
02:47:12 <koz_> merijn: I'll give it a shot.
02:47:50 <merijn> ij: Basically, in stuff like C when you call a function you do "call" which pushes a stack frame and then "return" to remove the stack frame and continue where you left off
02:48:22 <koz_> merijn: No help. I'm gonna try nuke pandoc and see if that solves it.
02:48:40 <merijn> ij: GHC compiles to CPS (Continuation Passing Style) where instead of "return" you simply "jump" to the code where you want to continue. So you never "return" to the parent, which means the entire "call" operations and stack frames become useless
02:53:47 <koz_> merijn: OK, substantial nuking later, I seem to have gotten threadscope to *start* building.
02:53:56 <koz_> Only time will tell if it *continues* to do so.
03:04:41 <tks> By default in acid-state, data Foo = blah get serialised in state/Foo/ . Is is possible to rename this default path?
03:06:35 <sdx23> tks: you've seen openLocalStateFrom?
03:07:18 <tks> sdx23: Yeah. But that opens an existing directory right?
03:07:57 <sdx23> tks: if its there. otherwise creates it. Its just the more general version of openLocalState, see the source.
03:11:24 <hexagoxel> koz_: related: https://github.com/quchen/cabal-install-bin
03:12:07 <tks> sdx23: I apparently didn't know about openLocalStateFrom. Always read the source huh?
03:12:35 <hexagoxel> koz_: or my version which works slightly differently, https://github.com/lspitzner/cabal-exec-install
03:15:02 <sdx23> tks: nah, more like "see haddoc, ask yourself what 'from a directory' means exactly, be happy". But asking here is helpful too, as you see :)
03:15:25 <sdx23> oh, there's a "read the source" before the last comma
03:15:35 <athan> Has anyone seen the "access failure, core closed" error with acid-state?
03:15:45 <Guest66963> what is the difference between 3, Just 3 and Maybe 3
03:16:00 <hpc> :t 3
03:16:01 <lambdabot> Num a => a
03:16:03 <hpc> :t Just 3
03:16:05 <sdx23> athan: occurs when you do what?
03:16:05 <lambdabot> Num a => Maybe a
03:16:07 <hpc> :t Maybe 3
03:16:08 <lambdabot>     Not in scope: data constructor ‘Maybe’
03:16:08 <lambdabot>     Perhaps you meant one of these:
03:16:08 <lambdabot>       ‘MaybeT’ (imported from Control.Monad.Trans.Maybe),
03:16:45 <Guest66963> still dont understand the actual difference..
03:17:05 <hpc> so, 3 is a numeric literal
03:17:19 <Guest66963> :t Maybe
03:17:19 <hpc> it has a type that says it can be of any type that's number-y
03:17:20 <lambdabot>     Not in scope: data constructor ‘Maybe’
03:17:20 <lambdabot>     Perhaps you meant one of these:
03:17:20 <lambdabot>       ‘MaybeT’ (imported from Control.Monad.Trans.Maybe),
03:17:28 <hpc> (specifically, by being an instance of the Num type class)
03:17:38 * hackagebot tianbar 1.0.1.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.0.1.0 (AlexeyKotlyarov)
03:17:41 <liste> Guest66963: the first two are values of different types, the third one is a type
03:17:53 <liste> Guest66963: actually the third one is nonsense
03:17:57 <hpc> Just 3 is a value of a different type
03:17:57 <liste> Maybe Int would be a type
03:17:59 <athan> sdx23: I'm just trying to insert some data :s
03:18:06 <athan> it works fine with the in-memory version of the DB
03:18:07 <toph> how do i un-install cabal and ghc if i built and installed both from source separately?
03:18:11 <athan> but not when I'm trying to store it
03:18:32 <hpc> the type (Maybe a) means that values of that type might or might not actually contain values of type a
03:18:44 <athan> I'm using `createCheckpointAndClose` as my error handler
03:18:54 <hpc> (Just 3) is a might-have-a-value type thing that happens to have a value
03:19:07 <hpc> the alternative, not having a value, is Nothing
03:19:10 <hpc> :t Nothing
03:19:12 <lambdabot> Maybe a
03:19:24 <hpc> the last case, Maybe 3, is an error
03:19:32 <hpc> Maybe is at the type level, and 3 is at the value level
03:19:43 <sdx23> athan: you closed the state and used it afterwards again
03:20:16 <athan> sdx23: https://github.com/athanclark/happ-store/blob/master/main/Main/Options.hs#L194 am I using bracket correctly?
03:20:19 <athan> hmm
03:20:21 <magneticduck> Guest66963 just has an innate desire for dependant types
03:20:43 <hpc> heh
03:20:57 <Guest66963> ok, thanks a lot
03:22:17 <sdx23> athan: I guess not. You can't do it in this way.
03:22:38 * hackagebot bzlib-conduit 0.2.1.4 - Streaming compression/decompression via conduits.  https://hackage.haskell.org/package/bzlib-conduit-0.2.1.4 (MichaelSnoyman)
03:23:58 <toph> well, how do i at least remove ghc if i installed from source? manually delete everything from /usr/bin/local and home?
03:24:36 <athan> oh wait I understand, thank you sdx23
03:26:05 <aa_> a
03:34:27 <lemonxah> good day 
03:34:35 <tdammers> hullow
03:34:47 <lemonxah> is it possible to get the haskell compiler to understand → instead of -> ?
03:35:23 <lemonxah> cause i really like those time of characters and i know i can see them like that in vi with the haskell plugins but i would like to use them while coding
03:35:28 <sdx23> lemonxah: https://wiki.haskell.org/Unicode-symbols
03:35:30 <cocreature> lemonxah: -XUnicodeSyntax
03:35:34 <mpickering> and this section of the user guide
03:35:35 <mpickering> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax
03:35:45 <tdammers> possible, yes; advisable, no
03:35:54 <lemonxah> oh why is it not avisable?
03:36:01 <tdammers> one, because it's a language extension
03:36:29 <tdammers> two, because it makes it harder to pass code through non-unicode channels (online forums, e-mail, whatever)
03:37:05 <tdammers> three, because not everyone wants to be bothered with setting up an input method where they can comfortably type those characters, and using them could scare them away from contributing
03:37:48 <lemonxah> parts 2 and 3 doesn't really concern me right now i am the sole contributer and will most likely always be
03:38:02 <lemonxah> but why is having a language extension a bad idea?
03:38:17 <tdammers> it's not necessarily bad to use a language extension, but doing so comes at a cost
03:38:21 <mpickering> Nothing really.. most modern haskell programs use language extensions
03:38:36 <mpickering> and especially as this extension only changes the syntax then I don't see any problem
03:38:38 <tdammers> it's just that in this case, the benefit is too marginal
03:38:42 <lemonxah> what kind of costs are you talking about?
03:38:48 <mpickering> apart from the mythical "other Haskell compilers"
03:39:07 <sdx23> lemonxah: when you're the only one, why don't you just use one of these editor plugins?
03:39:45 <lemonxah> sdx23, editor plugins? like the vim one that displays them like those unicode ?
03:40:02 <lemonxah> i have that allready 
03:40:34 <lemonxah> was just curious cause i have a keyboard macro app that makes → when i type - > next to each other
03:40:49 <lemonxah> and i use that in scala and other places so i have to turn that off when i do haskell
03:41:04 <athan> sdx23: It works! Thank you :)
03:41:26 <sdx23> athan: you're welcome :)
03:41:49 <sdx23> lemonxah: ah, i see.
03:44:21 <athan> heck yes. Even though my server is scraping hackage for data, I'm still at constant memory while the server runs
03:44:41 <athan> vote for pedro
03:45:04 <hexagoxel> how do i avoid the cyclic dependencies problem when install deps --enable-tests or --enable-bench on a boot lib (i.e. a dependency of criterion) ?
03:53:39 <koz_> OK, I'm *really* confused. I have '-eventlog' in my ghc-options field, but when I try to run with -l, it says I need to build with '-eventlog'...
03:53:43 <koz_> Wtf?
03:55:40 <koz_> Do I need to pass some magic flag to 'cabal configure'?
03:56:34 <lyxia> can you show your .cabal and how you're running your program?
03:57:18 <koz_> lyxia: Well... I seem to have fixed it by adding '-with-rtsopts=-N2 -l" to ghc-options...
03:57:35 <koz_> Now I can just do 'cabal configure' followed by 'cabal run' and it, well, runs.
03:58:03 <lyxia> were you passing these options to cabal rather than your program?
03:58:20 <koz_> lyxia: I was saying 'cabal run +RTS -N2 -l'.
03:58:27 <hexagoxel> cabal run -- +RTS -N2 -l
03:58:32 <hexagoxel> better^
03:58:41 <koz_> Oh goddamn it cabal. Thanks hexagoxel!
03:59:15 <koz_> But hey, at least I have working threadscope, finally!
04:01:16 <athan> Can anyone suggest batch-job style mapM_ over IO?
04:02:23 <hexagoxel> not really cabal's fault, it is consistent with other unix utilities. like "rm -r -- *". if you don't "--", there might be a file called "-f".
04:02:32 <athan> sorry, I meant to ask for how to parallelize mapM_ concurrently, with chunksOf of a given size, or something similar
04:02:37 <athan> like a max queue of jobs
04:04:08 <koz_> hexagoxel: I know, I know, but I guess I'm not used to that as-yet.
04:04:30 <athan> https://hackage.haskell.org/package/acme-everything
04:04:36 <koz_> It's more of a 'fuck, it was *that*!?!' exclamation that a 'cabal is deficient in a design sense!' exclamation.
04:04:45 <koz_> Also, wtf is with the acme stuff anyway?
04:05:28 <merijn> athan: async library + QSem?
04:05:52 <merijn> athan: See, for example, https://gist.github.com/merijn/d8188ddd129718ffcfb0
04:06:26 <merijn> athan: The monadIO stuff based on concurrently no longer works in modern versions of async, but using "mapConcurrently" in combination with QSem guarded IO actions works fine
04:07:40 * hackagebot fbmessenger-api 0.1.0.3 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.0.3 (mseri)
04:12:55 <athan> merijn: Wow, this is too cool! So the count throttles Concurrently, while it adjusts it's capabilities with getNumProcessors etc?
04:13:08 <merijn> athan: Yes
04:13:24 <athan> that's incredible
04:13:30 <merijn> athan: QSem is a semaphore, as semaphore only allows the first N threads through
04:13:40 <athan> does Concurrently need to be the base monad, though? I can't use IO still?
04:13:44 <merijn> After the first N it blocks until one of the running threads increases it
04:13:53 <merijn> athan: No, in fact, that doesn't work any more
04:14:05 <athan> ahh darn, that's unfortunate
04:14:19 <merijn> athan: async has "mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)"
04:14:34 <merijn> athan: No, I meant using Concurrently as a (base) monad no longer works
04:14:59 <merijn> athan: But mapConcurrently uses Concurrently internally to perform a parallel map
04:15:17 <merijn> So if you just use IO with a QSem inside and then call it via mapConcurrently that just works
04:15:29 <merijn> You just shouldn't use Concurrently explicitly :)
04:16:04 <athan> oh wow o_o
04:16:15 <athan> this feels like I'm playing with fire
04:16:25 <merijn> Why?
04:16:28 <athan> but really really really hot fire for turbo boosters
04:16:43 <athan> I guess it's just powerful for me to recognize haha
04:16:50 <athan> sorry, just amazed
04:17:34 <puregreen> does anybody here use base-prelude? if so, a mini-survey: 1. did you know that it reimplements some functions from newer versions of base, like (&) and sortOn? 2. is/was this confusing? 3. do you use them? 4. should they be removed in next major release (which means you'd have to use base-compat or something?)
04:18:09 <merijn> athan: Control.Concurrent has some pretty good builtin primitives for concurrency :)
04:19:00 <merijn> athan: Basically it spawns one thread per task, but only the first N don't block on the semaphore. Whenever a thread finishes and increases the semaphore a new one gets to run
04:23:25 <quchen> Is there a tool I can use to extend my dependency ranges? I have around 40 dependencies, and I strongly suspect their version bounds could be larger than what they are. I'm looking for a way to run the installation+testsuite with different version bounds in order to expand these ranges.
04:23:46 <merijn> quchen: I think hvr has some tool he uses to generate reports?
04:24:16 <quchen> It's not hard to get a first order approximation by doing 40 binary searches, but -- hvr
04:24:21 <quchen> Thanks :-)
04:25:18 <athan> thank you merijn! This is awesome!!
04:25:24 <quchen> It would be really helpful to start without dependency worries using Stackage, and then let a CI server expand the known-to-work ranges over night.
04:25:45 <hodapp> quchen: hmmmm... does anything yet do that?
04:25:54 <quchen> hodapp: Nothing I know of.
04:26:04 <hodapp> seems like it'd get into a pretty large search space and you'd have to give some parameters to limit it
04:26:11 <quchen> But conceptually it's very simple as long as you don't want to do an exhaustive search.
04:27:26 <quchen> 1. Expand first package by binary search in both directions around a working version; 2. expand second package … 
04:27:41 <merijn> quchen: This assumes packages don't share dependencies
04:27:47 <quchen> I mean yeah it takes its time, but it's a one-time cost
04:27:56 <hodapp> FAMOUS LAST WORDS!
04:27:58 * hodapp runs off
04:27:59 <quchen> merijn: Sure, it's not optimal. But it's way better than manually doing it
04:30:13 <koz_> OK, threadscope needs *serious* RAM.
04:30:30 <Profpatsch> merijn: So data Foo = Foo { meh :: forall a. a -> Bool } is Rank 2, because the Foo constructor is a function where the first argument is a local forall?
04:30:47 <merijn> Profpatsch: Yes
04:31:31 <merijn> Profpatsch: This is my usual example of (one) use case of Rank2 types: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:31:47 <Profpatsch> and meh :: forall a. (forall b. b -> a) -> a would be rank 3 ?
04:32:10 <merijn> Rank2, because the first forall is implicit
04:32:31 <Profpatsch> With meh in Context of Foo
04:32:31 <merijn> Profpatsch: ""id :: a -> a" is equivalent (in the underlying theory) to "id :: forall a . a -> a"
04:32:51 <merijn> Profpatsch: Then yes, I think? I'm not 100% sure :)
04:33:10 <Profpatsch> The foralls are there, only they are implicitly added by the Haskell semantics, right?
04:33:15 <merijn> Yes
04:33:22 <Profpatsch> Purescript requires them explicitely.
04:33:44 <Profpatsch> Which is not bad I think, as long as I can use ∀ :P
04:35:46 <Profpatsch> I wonder if GHC 8.0.1 derivates from the Haskell Report by requiring forall.
04:36:07 <Profpatsch> Or was 7.x the one that didn’t implement the Report correctly?
04:36:11 <ggVGc> wait, will we need explicit foralls in 8.0?
04:36:21 <hexagoxel> does `Free ((,) a) b` have a name?
04:36:22 <Profpatsch> ggVGc: Only for Rank2/N
04:36:27 <ggVGc> ah
04:36:31 <Profpatsch> Wait, it’s an extension anyway. :P
04:36:32 <cocreature> Profpatsch: the haskell report doesn’t allow you to use rank2/n types
04:36:52 <Profpatsch> So nothing yet standardized .
04:37:32 <maerwald> the haskell report doesn't allow you to execute IO :P
04:37:57 <ggVGc> IO is pretty crap anyway
04:38:24 <hpc> IO is the best part of haskell
04:38:30 <maerwald> ugh
04:38:36 <ggVGc> I'm confused, didn't we already have DuplicateRecordFields?
04:38:42 <ggVGc> it says it's new in 8.0
04:38:56 <cocreature> it is new
04:38:57 <ggVGc> hpc: IO is always terrible, but it's a lot better in Haskell than elsewhere
04:40:49 <hjljo> interesting that openNewFile exists in System.IO but the only export that uses it is for creating temporary files. i think it would be nice if System.IO exported a newFile / withNewFile too...
04:41:17 <ggVGc> the more I think about it, DuplicateRecordFields seem like pretty much a big hack
04:41:37 <locallycompact> Why?
04:42:04 <ggVGc> well.. I guess it's accessors that are polymorphic over a certain set of types
04:42:09 <ggVGc> but that's a but awkward I think
04:42:10 <ggVGc> maybe not
04:42:14 <ggVGc> I'm not good at type theory
04:42:41 * hackagebot tpdb 1.3.3 - Data Type for Rewriting Systems  https://hackage.haskell.org/package/tpdb-1.3.3 (JohannesWaldmann)
04:43:36 <maerwald> hjljo: if you are on unix I suggest you go with the unix functions instead of what base offers
04:47:42 * hackagebot elm-hybrid 0.1.1.0 - Combine Elm with Haskell for data based applications  https://hackage.haskell.org/package/elm-hybrid-0.1.1.0 (matsrietdijk)
04:49:51 <hpc> :t foldr
04:49:52 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:50:59 <hpc> :t foldl'
04:51:00 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
04:51:17 <hpc> i don't know why, but it annoys me that b and a are reversed there
04:51:52 <athan> How should I properly close a haskell program if it's something like a web server?
04:52:04 <merijn> athan: What do you mean?
04:52:05 <athan> C^c Seems to be making acid-state bork out
04:52:18 <merijn> Define "bork out"?
04:52:47 <hjljo> open works but it's more low level in addition to being posix specific.  high level cross-platform file IO is nice to have and the code is already there, it's just not exported except for an overly specific case.  but i promise not to winge about this anymore.
04:52:53 <athan> As I press ^C, it tells me "Access failure: Core closed" merijn
04:53:14 <puregreen> athan: maybe you're running it from ghci
04:53:15 <puregreen> *?
04:53:19 <athan> and the next infocation of my program isn't connecting to the database for some reason I think
04:53:26 <athan> No, it's an executable
04:53:31 <puregreen> hm-m, weird
04:53:41 <merijn> Time for my usual complaint about acid-state not being a database
04:54:29 <puregreen> athan: can you show the code?
04:54:45 <sdx23> athan: guessing that you're still using bracket incorrectly.
04:54:58 <athan> :\
04:55:12 <athan> merijn: What would you call it?
04:55:32 <merijn> athan: persistent heap data with ACID guarantees
04:55:41 <merijn> Or just persistent data with ACID guarantees
04:55:58 <merijn> Or hell "state with ACID guarantees" if you will :p
04:56:36 <hpc> merijn: i consider ACID to be what makes it a database
04:56:38 <athan> puregreen: It's just a bit messy right now
04:56:39 <hpc> albeit not a relational one
04:56:47 <puregreen> I used to like acid-state but now I have boilerplate *everywhere* and I'm afraid to add any more fields to my records and... yeah, I wish I used a database or something
04:56:54 <tks> merjin: Just out of curiosity, what does a database offer in addition to acid state?
04:57:00 <athan> hah, that makes sense merijn
04:57:15 <tks> merijn: Just out of curiosity, what does a database offer in addition to acid state?
04:57:21 <merijn> hpc: I would say a database the data format to be portable/well-defined so it can be accessed and queried by other programs/languages and 
04:57:49 <merijn> tks: Query optimisation, the existence of querying in the first place, an independent data specification
04:58:08 <merijn> I think acid-state is a brilliant thing I haven't seen in any other language
04:58:21 <puregreen> tks: acid-state doesn't have a schema, which means issues like https://github.com/acid-state/acid-state/issues/65
04:58:27 <merijn> But thinking of it as a database tends to make people use it in ways that it doesn't fit very well
04:59:18 <merijn> For instance, acid-state to store persistent state in a daemon is a brilliant idea. Using an IntMap based acid-state as a sort of key-val database? Not so brilliant
04:59:19 <puregreen> athan: here's what I do and it works for me: https://github.com/aelve/guide/blob/master/src/Main.hs#L701
04:59:42 <merijn> Right, I think schema was the word/concept I was looking for :)
05:00:06 <merijn> hpc: Not relational databases, such a Berkeley DB are still clearly very different from acid-state
05:00:16 <tks> Schema makes the distinction clearer for me ;)
05:00:27 <merijn> hpc: And I would consider BDB a database, so it's not the "lack of relational" that is the deal breaker for me
05:00:43 <hpc> ah, fair enough
05:01:13 <hpc> just as long as you aren't falling into the trap i see so often, of thinking mongodb or redis are databases, or even that sqlite is one
05:01:38 * hpc tries to nip that one in the bud whenever possible
05:01:42 <merijn> I would consider sqlite one, it has a separate schema and concurrent access (though not very good...)
05:01:48 <puregreen> why isn't sqlite a database?
05:02:08 <athan> puregreen: Ahh I wonder if it's ekg that's failing me
05:02:14 <hpc> you can corrupt data by doing concurrent writes from two different programs
05:02:16 <lemonxah> found this book called real world haskell and wondering if its a good read for a beginner like me?
05:02:19 <tzaeru> they are still databases
05:02:27 <athan> becuase I'm using `createCheckpointAndClose` just like you, basically
05:02:28 <tzaeru> that something is a bad database doesn't mean it's not a database
05:02:43 <hpc> tzaeru: it has to have ACID or it's not a database at all imo
05:03:01 <merijn> See, this is why the AI people invented fuzzy logic ;)
05:03:17 <maerwald> that's not how the term "database" is defined
05:03:38 <puregreen> defined by whom
05:03:55 <tzaeru> like every source on computing related terminology.
05:04:19 <tzaeru> of course if you want to redefine terms, do go ahead, but it does make communication a bit weird..
05:04:53 <hpc> i see so many people assume ACID from things that say they are databases that i have found it to be a safe thing to distinguish on
05:05:07 <puregreen> it's already weird, but to me it looks that people who cite sources to prove that their definition is more right are trying to say “it's *your* fault it's weird”, which kinda upsets me
05:05:25 <hpc> people will use mongodb and assume they are protected from power disruptions, even though it doesn't do immediate writes
05:05:52 <linduxed> not strictly a haskell question, but here goes: for something to be a "cache" does it have to support fallback calls?
05:05:58 <merijn> hpc: Man, mongodb doesn't even guarantee consistency without power failures
05:06:08 <tzaeru> puregreen, ..I've just never seen a demand anywhere that a database that isn't ACID isn't a database. sounds about equal to saying that a programming language isn't a programming language if it has no type safety guarantees
05:06:10 <hpc> so you pass data to the API, it returns control to you, but you can't even assume the data is anywhere at all
05:06:44 <hpc> you have to wait some mysterious amount of time (which mongodb people expertly describe as "eventually") for the information to exist somewhere you can trust it to stay
05:07:09 <merijn> tzaeru: Word of warning, but there's no such thing as "type safety guarantees" (or rather there is, but the way you use it there is wrong :))
05:07:14 <linduxed> like, let's say the "cache" in question gets populated with data from a database, if there's a miss, is it necessary that this "cache" goes and fetches data from the database directly as a fallback for it to be OK that it's called a "cache"?
05:07:33 <linduxed> could one still call it a cache if it didn't do the fallback thing at all?
05:07:33 <merijn> tzaeru: Type safety doesn't have an independent meaning. A programming language can only be type-safe in relation to a model.
05:07:57 <hpc> linduxed: it doesn't have to do that sort of pass-through lookup stuff, but many caches do
05:07:58 <merijn> tzaeru: For example, C is perfectly type-safe in the operational model of a single byte-addressed address space
05:08:18 <puregreen> tzaeru: a charitable interpretation of “it has to have ACID or it's not a database at all imo” would be, for instance, “it has to have ACID or else it's useless for the kind of things that people usually need databases for”
05:08:29 <hpc> linduxed: usually if something doesn't, a programmer is going to quickly write something around the API that does
05:08:31 <linduxed> hpc: well, practically every one of the ones i've been in contact do
05:08:45 <tzaeru> merijn, myea, sure
05:08:46 <hpc> general-purpose caches usually don't, because you would have to program it to do the appropriate lookup
05:09:07 <hpc> and sometimes all you might care about is the fact that something is absent from the cache to begin with
05:09:12 <toph> how does ACID relate to CAP thm.?
05:09:30 <linduxed> but wouldn't one just refer to it as another database if you just populated it on a regular basis but never let fallback happen?
05:10:00 <toph> is it the CP?
05:10:28 <merijn> toph: It's the C part
05:10:57 <merijn> toph: ACID = Atomicity, Consistency, Isolation, Durability
05:11:28 <sdx23> no, this is what people usually get wrong with the two. The Cs are totally different.
05:11:59 <merijn> sdx23: Eh, explain?
05:12:21 <merijn> Although I suppose Durability could (partially) map to the P part of CAP too
05:12:28 <operanew1> http://espedito.homepc.it/ OneHostX...)
05:12:40 <sdx23> acid-c: data is logically consistent (entries in a user list and number of users if stored separately, e.g.). cap-c: the same data is everywhere.
05:13:00 <sdx23> if you have a distributed database you can violate cap-c but keep up acid-c
05:13:30 <sdx23> "logically" may be the wrong term. Perhaps "according to a schema" or something.
05:13:30 <tzaeru> hpc, you can request acknowldgement out of mongodb for writing to journal etc though
05:13:43 <merijn> sdx23: "The consistency property ensures that any transaction will bring the database from one valid state to another. Any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof."
05:13:48 <tzaeru> which is.. pretty much the same as with any db I suppose.
05:13:52 <merijn> sdx23: acid-c is a superset of CAP-c
05:14:33 <merijn> acid-c = sequential consistency + additional constraints
05:14:35 <tzaeru> and it's not like your database choice would magically make power failures a non-issue. there are still disk caches and whatnot, which need to be backed up by batteries etc.
05:14:48 <athan> Now that the sun's up, time for bed :) night yall, and thank you for all the help!
05:14:57 <hpc> tzaeru: in that case, it might be possible to write some code on top of mongodb that would qualify as a database
05:15:06 <merijn> tzaeru: Except mongodb can lose data even with confirmations
05:15:19 <hpc> oh, TIL
05:15:22 <tzaeru> merijn, yes, but I think that's somewhat unintented.
05:15:37 <tzaeru> again going to the point that being a bad database doesn't mean it's not a database.
05:16:07 <hpc> tzaeru: the key point is that by not returning until data is fully written, a power failure may have made it not write something you told it to
05:16:18 <hpc> tzaeru: but until it returns, it's not something that it promised would be written yet anyway
05:16:38 <hpc> tzaeru: so when you start back up again, you're a little bit further back in time, but as a consistent state
05:17:06 <hpc> tzaeru: if you don't block, program execution keeps going and you do stuff based on the assumption that the data you wrote will always be there
05:17:16 <hpc> then there's a problem of some sort and it's not
05:17:26 <hpc> the database goes back in time, but everything else has moved on
05:17:40 <hpc> you've charged people money, sent emails, etc
05:18:20 <tzaeru> TIL most people don't use databases, because most people don't force fsync after every write :(
05:18:41 <merijn> tzaeru: Pretty sure postgres/mysql do that
05:18:47 <hpc> or to put it another way, the parts of the world you interact with are counted for consistency
05:18:49 <merijn> Well, hopefully mysql does that...
05:18:56 <tzaeru> merijn, by default they cache a bit before doing it.
05:18:59 <tzaeru> though there are settings to force it
05:19:08 <tdammers> my money would be on "mysql attempts to do it, but doesn't quite get it right"
05:19:11 <tzaeru> default write operation is not safe in mysql at least
05:19:23 <hpc> tzaeru: with which engine?
05:19:35 <tzaeru> innodb
05:19:38 <tzaeru> unless I remember wrong.
05:20:00 <tzaeru> a distinct possibility! but I think by default there are some light cache settings which don't force file buffer sync on every write operation
05:20:05 <hpc> you might be misremembering, or thinking of myisam
05:20:13 <hpc> innodb is pretty okay
05:20:43 <tdammers> innodb is definitely a lot less broken than myisam
05:24:53 <tzaeru> mh no, the defaults should be 100% acid compliant
05:26:08 <tzaeru> nowadays though there *should* be settings for mongodb to force acknowledgement for writes. not sure if they work as intented tho
05:26:19 <tzaeru> and there are still problems for consistency in sharded environments.
05:27:05 <lemonxah> what is a good example of a haskell project file system layout?
05:27:41 <lemonxah> do you use the src/ directory for your source code and package names, java like? 
05:27:54 <lemonxah> or how do you structure a haskell project / solution
05:27:58 <hpc> i think cabal defaults to putting things in src/ now
05:28:13 <osager> How to understand the bar in : class Monad m => MonadReader r m | m -> r where
05:28:19 <locallycompact> lemonxah, stack new helloworld
05:28:23 <lemonxah> ok so it starts off in src/ do you make sub folders?
05:28:23 <hpc> in any event i have seen src/ used in most things on hackage i have looked at lately
05:28:28 <mauke> https://aphyr.com/posts/322-jepsen-mongodb-stale-reads
05:28:31 <lemonxah> locallycompact, let me try that
05:29:18 <mauke> osager: m -> r is a functional dependency
05:29:19 <Cale> osager: It's a piece of punctuation which separates off the functional dependencies between the class variables
05:29:30 <mauke> it says m uniquely determines r
05:29:32 <Cale> You could read it aloud as "where"
05:29:45 <lemonxah> i also understand to make a library you can ghc -c lib to build the lib.hs file to a object 
05:30:28 <lemonxah> then you can include that as a import in your main.hs and then compiling that you do ghc -o outputexec main.hs lib.o
05:30:56 <osager> So in English what does it mean by dependency?
05:30:59 <lemonxah> but what i dont understand is how to have a bunch of these .hs files in one project and then just build your main.hs and have it auto include all the other files
05:31:12 <mauke> it says m uniquely determines r
05:31:56 <hpc> osager: a fairly simple example is class Monad m => MonadReader r m | m -> r where
05:32:16 <osager> does it mean that the function m-> r must be implemented ?
05:32:17 <hpc> osager: one of the instances for it is MonadReader r ((->) r)
05:32:40 <mauke> osager: there is no such function because | m -> r is not a type signature
05:32:43 <hpc> osager: in that instance, r = r, and m = ((->) r)
05:33:21 <hpc> osager: m uniquely determines r, so to the type system that means it can always determine that if it can infer m = ((->) r), r always is r
05:33:40 <hpc> osager: you can't go back and write another instance where r = Bool and m is kept the same
05:34:14 <hpc> osager: in other words, the functional dependency restricts what instances you can write, and from that restriction you gain back a little bit of type inference
05:34:18 <lemonxah> locallycompact, so your Main.hs lives in app and your "library" code in src/ ? does it compiles recursively through src/ ?
05:34:35 <osager> so the type of m determines the type of r
05:34:50 <hpc> yep
05:35:10 <Cale> osager: It means that for any given m, there can be at most one r for which an instance MonadReader m r exists, and so if the type checker knows which type m is, and it finds an instance of MonadReader for m, then it can use that instance to determine which type r is
05:35:57 <locallycompact> lemonxah, yeah think so
05:36:49 <lemonxah> can you have multiple versions of the ghc compiler installed at the same time? and you just specify which version to use with the stack.yaml?
05:37:07 <lemonxah> sorry for the questions if you guys think it stupid please shout at me 
05:37:17 <osager> what's the logic that m determines r ?
05:37:35 <locallycompact> lemonxah, stack will sandox one for you with stack build, it doesn't use a global ghc
05:37:51 <kadoban> lemonxah: stack does that automatically. It uses the GHC that's appropriate for the selected resolver. You don't have to install GHC either, it does it internally for you.
05:38:08 <kadoban> Well, it uses global GHC if it's the correct one.
05:38:20 <lemonxah> ok cool and how can i then change the resolver of a project to lets say use a newer version of the compiler?
05:38:31 <kadoban> lemonxah: Edit stack.yaml
05:39:43 <lemonxah> so i can just replace lts-6.3 with ghc-8.0.1 and that should work?
05:40:15 <lemonxah> oh cool yeah :) is there any benefit in using lts? 
05:40:25 <kadoban> lemonxah: There are resolvers just for specific compilers, but that's usually not what you want. If you want GHC 8, you should probably use one of the "nightly" resolvers from stackage
05:40:38 <merijn> lemonxah: Even without stack having multiple GHC version installed is simple
05:40:44 <lemonxah> ok cool
05:40:57 <merijn> lemonxah: Since cabal just uses whichever GHC it finds first on your path and GHC has a per-version package database
05:41:00 <osager> is the source code of ghc a good reference for beginning to intermediate programmer ?
05:41:15 <merijn> lemonxah: So switching between versions is as trivial as "update your PATH"
05:41:21 <merijn> osager: It's ok...
05:41:23 <kadoban> The compiler resolvers only include whatever comes with GHC, I think. So if you use many packages at all, you'll end up having to specify them as extra-deps, and also you'll lose the benefit of having a curated set of packages that all build together.
05:41:30 <osager> i mean are those code too low level?
05:41:33 <merijn> osager: A lot of it is old code written in the SPJ style, which I personally find horrid
05:41:47 <lemonxah> kadoban, is there any benifit in using 8 over 7.10 ?
05:41:50 <merijn> osager: If you wanna look at "real" haskell project I would probably recommend pandoc and xmonad
05:42:01 <merijn> lemonxah: If you need a specific feature from 8.0
05:42:07 <osager> what do yo umean real ?
05:42:07 <merijn> lemonxah: If not, I'd wait for the dust to settle
05:42:15 <osager> modern?
05:42:17 <kadoban> lemonxah: There's new features and such, but GHC8 is really new. I wouldn't use it yet as a default (in fact I don't).
05:42:22 <merijn> osager: As in, projects of fairly big size that are used by lots of people
05:42:27 <lemonxah> merijn, i dont know anything about haskell yet :) just started out really
05:42:35 <merijn> lemonxah: Then no, I'd stick with 7.10
05:42:36 <lemonxah> so you would suggest me then to use a lts version?
05:42:49 <osager> ok
05:42:51 <osager> thanks
05:42:55 <kadoban> lemonxah: Probably a good default, sure.
05:42:56 <merijn> lemonxah: Let other people discover/fix the bugs/problems/etc. :)
05:44:29 <osager> monad transformers are said to transform one monad to anther, so what does ReaderT transform ?
05:47:34 <mauke> osager: a monad
05:47:39 <mauke> is this a trick question?
05:48:03 <osager> nope, jsut trying to udnerstand
05:48:23 <mauke> given any monad m, ReaderT e m is also a monad
05:48:24 <hpc> i still think comonad transformers should have been called decepticons
05:49:02 <mauke> for example, Maybe gets "transformed" to ReaderT e Maybe
05:51:03 <bezirg> hi, I have `data X = X deriving Show` and `instance Exception X` and it works without having to  `derive Typeable for X`. How is that so?
05:51:19 <ertesx> bezirg: since GHC 7.10 that's implicit
05:51:22 <bezirg> is AutoDeriveDataTypeable on by default?
05:51:51 <bezirg> ertesx: so I should stop writing `deriving Typeable` clauses for GHC>=7.10 ?
05:52:17 <ertesx> bezirg: you can still write them for backward-compatibility, if you care…  but it's effectively just a comment now
05:52:34 <ertesx> personally i like no longer having to import Data.Typeable everywhere
05:52:43 <bezirg> ertesx: ok thanks, how about the LANGUAGE pragma DeriveDataTypeable ? is this obsolete also?
05:52:44 * hackagebot webkitgtk3-javascriptcore 0.14.2.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.14.2.0 (HamishMackenzie)
05:52:46 * hackagebot webkit-javascriptcore 0.14.2.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.14.2.0 (HamishMackenzie)
05:53:08 <ertesx> bezirg: it's only needed, if you write the deriving clause explicitly
05:53:21 <bezirg> ertesx: thank you!
05:54:24 <koz_> Does anyone else use Flycheck in Emacs for Haskell? I'm getting *very* odd checker behaviour for compilation *errors*.
06:34:23 <toph_> after i installed haskell-platform for generic linux i tried running `cabal install cabal cabal-install` and gcc linker couldn't find `lgmp`, is that normal?
06:34:43 <toph_> installing `libgmp-dev` from repository seems to have worked
06:35:36 <quchen> toph_: Last time I installed the Platform (which is a few years back) I'm pretty sure it didn't install OS-level dependencies either. So your solution sounds about right.
06:36:15 <quchen> I'm surprised it didn't warn you about the missing dependency.
06:38:41 <lemonxah> is it possible to have your own package server? like a company maven server for libraries that needs to be shared between projects but that is not open to the public?
06:39:18 <schjetne> lemonxah: you can make your own quicklisp distributions
06:39:36 <schjetne> sorry, wrong channel
06:39:51 <schjetne> And wrong language and package manager
06:40:10 <lemonxah> lol :)
06:40:31 <schjetne> But I'm sure the same can be done with Cabal
06:41:16 <byorgey> lemonxah: yes, that is possible.  For example see http://hackage.haskell.org/package/hackage%2Dserver
06:41:39 <byorgey> lemonxah: I think many companies do this, though I am not familiar with the details
06:42:36 <lemonxah> yeah we run our own maven and ivy2 servers but if i start coding in haskell and get more ppl to code in it too we need something like this 
06:42:39 <lemonxah> thank you for the linnk
06:42:42 <lemonxah> link even
06:43:52 <lunaris> Hi all, does anyone here use resource-pool/have experience with mkWeakIORef?
06:47:47 * hackagebot abnf 0.3.2.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.3.2.0 (Xandaros)
06:50:44 <Sinestro> I'm probably being really dumb, but I can't get mutable vectors to work. I'm thawing the vector in question, using write on it a few times, then refreezing it, but that frozen version doesn't reflect the changes made.
06:51:07 <nitrix> Can someone confirm my understanding that Haskell has two form of polymorphism? Ad-hoc polymorphism for type classes; and parametric polymorphism for functions (and algebraic data types I suppose) ?
06:52:37 <Xandaros> nitrix: It has a few more, but those are the main kinds of polymorphism in haskell, yes
06:52:58 <nitrix> Am I correct about which is what?
06:53:14 <Xandaros> Google says yes :P
06:55:52 <EvanR> nitrix: yeah, except that ad hoc is probably a bad name for type classes, its more like bounded polymorphism
06:55:56 <EvanR> or constrained
06:57:03 <EvanR> Sinestro: minimal testcase?
06:57:57 <Sinestro> I'm slamming it together right now, it's the kind of wonderful code you get when it's the middle of the night and you can't sleep so you 'work' on your project mostly by slamming your head into it so paring it down is a bit of a pian
06:58:19 <hpc> i wouldn't consider type classes to be polymorphism, but constraints against parametric polymorphism
06:58:57 <nitrix> I found bounded quantification and a paper on something called constraint-bounded polymorphism.
06:59:06 <nitrix> Maybe it'll be what EvanR is referring to.
07:00:23 <nitrix> "Bounded quantification[/polymorphism] refers to universal or existential quantifiers which are restricted (bounded) to range only over the subtypes of a particular type."
07:00:26 <EvanR> often parametric polymorphism is just called "polymorphism"
07:00:45 <Sinestro> http://lpaste.net/3799536749617610752
07:01:01 <Sinestro> That should work, the only dependency is (obviously) `vector`
07:01:19 <EvanR> nitrix: yeah maybe this termnology is really used in languages with subtypes
07:01:20 <nitrix> Yeah, it seems it's a blurry line. I was planning to demystify it today, but it proves not to be as trivial as I thought.
07:01:28 <EvanR> instead of subtype polymorphism
07:01:36 <nitrix> Gotcha.
07:03:03 <EvanR> Sinestro: not very minimal
07:03:32 <EvanR> minimal is "thaw a vector, write to it, freeze it, and the frozen version does not reflect the changes"
07:03:38 <Xandaros> I like the idea of thinking of type classes as restricting the possible choices for type variables. That's how I usually think about them and the form of the type signatures seem to support that point of view
07:03:48 <Sinestro> Okay, was trying to closely reflect my code
07:03:56 <EvanR> reflect the problem
07:04:03 <EvanR> which seem a lot more focused
07:04:05 <monochrom> Cale: Toronto Haskell Meetup is moved to June 22
07:07:48 * hackagebot store 0.2.0.0 - Fast binary serialization  https://hackage.haskell.org/package/store-0.2.0.0 (MichaelSloan)
07:10:18 <lunaris> Alternatively, is anyone savvy with finalizers and their running by GHC?
07:10:53 <mat__> @unmtl StateT TS [] a
07:10:53 <lambdabot> TS -> [] (a, TS)
07:13:46 <jon_wingfield> I have a question about monads :)
07:14:08 <liste> jon_wingfield: go ahead
07:14:59 <jon_wingfield> I've been building this intuition the sequencing is implied by the bind operator
07:15:04 <c_wraith> I have lots of answers about monads.  Most of them are "Don't think they're so important you must understand them instantly."
07:15:32 <nitrix> My first thought is "Monads?! All of them?".
07:15:35 <EvanR> class MonadAnswer
07:15:47 <jon_wingfield> But recently I read that isn't the case. Thoughts?
07:15:51 <jon_wingfield> haha
07:16:07 <c_wraith> There is a sequence implied by the binding.
07:16:18 <c_wraith> But it isn't necessarily the evaluation or execution order
07:16:23 <c_wraith> rather, it's the binding order. :)
07:16:42 <jon_wingfield> So, a simple example:
07:16:43 <Sinestro> EvanR: The minimal example works just fine, I'll have to pour over my shitty code some more and figure out what the problem is
07:17:01 <nitrix> It seems correct to me. >>= would be the sequencing of monadic actions, >=> is the composition of monadic actions.
07:17:34 <c_wraith> There is certainly a binding sequence.  That's the whole point of the Reflection Without Remorse paper
07:19:34 <jon_wingfield> interp (Add u v) e  = do
07:19:34 <jon_wingfield>   a <- interp u e
07:19:34 <jon_wingfield>   b <- interp v e
07:19:36 <jon_wingfield>   add a b
07:20:05 <fr33domlover> Are there databases (SQL ones, key-values ones, etc.) that can do hierarchical queries (e.g. get all the ancestors of some entity) but can't join (in the SQL sense)?
07:20:22 <fr33domlover> e.g. maybe NoSQL databases, but I never used them so I'm not sure
07:20:32 <jon_wingfield> so, because b isn't (strictly) dependent a, does sequencing force order in that example?
07:20:49 <jon_wingfield> If you translate it to the lambda form it would certainly seem to be forced
07:20:52 <c_wraith> jon_wingfield: impossible to answer without knowing what m is, concretely
07:21:02 <c_wraith> jon_wingfield: if m is Reader, then no ordering is implied
07:21:12 <c_wraith> jon_wingfield: if m is State, then ordering is implied
07:21:17 <Squarism> i cannot run this expression in my ghci: 
07:21:18 <Squarism> > sortBy (comparing fst <> comparing snd) [(1,30), (2,20), (3,10)]
07:21:19 <lambdabot>  [(1,30),(2,20),(3,10)]
07:21:20 <nitrix> jon_wingfield: `a` is guaranteed to happen before `b` (in sequence). When is this sequence happening is still to be determined. Haskell's evaluation and execution are separate. 
07:21:42 <Squarism> im on ghc 7.10
07:21:59 <fr33domlover> Squarism, what error do you get
07:22:03 <jon_wingfield> hmmm
07:22:04 <c_wraith> nitrix: that's not strictly true.  It depends on whether the definition of (>>=) forces its first argument when it's evaluated.
07:22:12 <c_wraith> (pun intended)
07:22:20 <tdammers> fr33domlover: there's this algorithm that allows you to store tree-shaped structured by assigning "left" and "right" values to each element, such that any child element has child.left > parent.left and child.right < parent.right, and that no two siblings can overlap
07:22:25 <nitrix> Oh that true, I didn't pay attention to which monad it was.
07:22:31 <geekosaur> @index comparing
07:22:32 <lambdabot> Data.Ord, Distribution.Simple.Utils
07:22:32 <nitrix> s/that/that's/
07:22:47 <tdammers> fr33domlover: to my great shame, I keep forgetting the name of that algorithm
07:23:02 <fr33domlover> tdammers, nested sets
07:23:15 <jon_wingfield> so if I rewrite it as: `interp (Add u v) e = interp u e >>= (\a -> interp v e >>= (\b -> add a b))`
07:23:43 <geekosaur> oh, (<>) also isn't in Prelude?
07:23:54 <jon_wingfield> it seems like the outer \a must be called before the inner \b can be?
07:24:05 * geekosaur had to import Data.List for sortBy, Data.Ord for comparing, and Data.Monoid for (<>) fwiw
07:24:11 <fr33domlover> tdammers, I'm implementing real recursive queries (SQL supports them using WITH RECURSIVE) on top of persistent, and I need to do an SQL join. I just wonder if there's a good reason to split the functions that need the join into a separate subclass
07:24:17 <jon_wingfield> even with lazy evaluation, doesn't \a need to be evaluated to even access \b?
07:24:30 <c_wraith> jon_wingfield: The outer (>>=) must be evaluated before the inner (>>=) is
07:24:35 <fr33domlover> If some backends can do these querie but can't join, it makes sense to split
07:24:46 <fr33domlover> otherwise, it's just confusing  etc.
07:24:50 <c_wraith> jon_wingfield: but that doesn't imply anything about the arguments to (>>=)
07:25:11 <invisible-vision> Can anyone get this wiki page's examples to work? No matter what I try they refuse to typecheck: https://wiki.haskell.org/Catamorphisms
07:25:51 <Squarism> fr33domlover, http://lpaste.net/165898
07:25:52 <c_wraith> jon_wingfield: depending on what m is, (>>=) might not evaluate either of its arguments.
07:26:03 <nitrix> jon_wingfield: I think it's the other way around. Evaluating the outer >>= may cause the inner >>= to be evaluated.
07:26:20 <nitrix> The `may` is important.
07:26:28 <fr33domlover> Squarism, you used mappend there
07:26:37 <fr33domlover> instead of <> or `mappend`
07:26:41 <hpc> invisible-vision: can you paste code?
07:26:42 <c_wraith> data Trivial a = Trivial ; instance Monad Trivial where return _ = Trivial ; _ (>>=) _ = Trivial -- jon_wingfield 
07:26:44 <hpc> @lpaste
07:26:44 <lambdabot> Haskell pastebin: http://lpaste.net/
07:26:57 <jon_wingfield> c_wraith: that makes sense
07:27:09 <Xandaros> Just updates to GHC 8 and cabal 1.24. If I now do “cabal list”, it fails with “cabal: ghc-pkg dump failed”. If I use ghc-pkg myself (specifying the sandbox I'm using), it seems to work fine. Anything I can do to fix this?
07:27:29 <Squarism> fr33domlover, thanks! worked
07:27:49 * hackagebot store-core 0.2.0.0 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.2.0.0 (MichaelSloan)
07:27:55 <hpc> c_wraith: no parens around (>>=)
07:27:59 <Squarism> fr33domlover, but "<>" didnt work?!
07:28:02 <c_wraith> Oh, right.
07:28:13 <geekosaur> Xandaros, make sure you have the new cabal-update and not the old (if you "cabal install"ed it and the old version was from somewhere other than cabal, your shell might still be caching the old one)
07:28:22 <c_wraith> It also doesn't have an applicative instance, so won't compile on any recent ghc
07:28:33 <fr33domlover> Squarism, the errors you get are trivial. Syntax errors, missing imports, etc.
07:28:33 <Xandaros> geekosaur: cabal --version shows 1.24
07:28:36 <hpc> oh yeah, that too
07:28:49 <hpc> not that it detracts from the example, but just in case someone tries it
07:28:50 <geekosaur> Squarism, fr33domlover as I pointed out earlier, ghc 7,10 needs you to import Data.Monoid for (<>)
07:28:55 <fr33domlover> Squarism, you'll quickly learn how to fix them :P
07:29:04 <Xandaros> geekosaur: http://tcp.mniip.com/tmsq
07:29:27 <fr33domlover> geekosaur, I hope it got moved to Prelude :P
07:29:40 <fr33domlover> I import Data.Monoid very often for it
07:29:51 <jon_wingfield> But in simple terms, doesn't this mean that `a` must be computed before `b`?  Event though there is actually no data dependency between computing `a` and `b`
07:29:52 <jon_wingfield> ?
07:30:06 <geekosaur> I think they're still trying to sort that. the problem is that Data.Semigroup is on the way and it has a *different* <>
07:30:21 <Squarism> geekosaur, fr33domlover.. worked with Data.Monoid imported
07:30:22 <nitrix> jon_wingfield:  _ (>>=) _ = Trivial
07:30:25 <Guest69472> @unmtl StateT TableauState [] ()
07:30:25 <lambdabot> TableauState -> [] ((), TableauState)
07:30:30 <nitrix> jon_wingfield: In this example, neither are evaluated.
07:31:13 <jon_wingfield> yeah, that makes sense
07:31:18 <Xandaros> geekosaur: Hmm, the cabal.sandbox.config still mentions the old 7.10.3 directory. That's probably the issue, then
07:31:26 <geekosaur> possible, yes
07:32:17 <Xandaros> Yup, changing it fixed it.
07:32:21 <c_wraith> jon_wingfield: the thing is, this isn't a monad question at all.  The answer isn't determined by monads.  The answer is determined by a specific instance.  If you ignore the monad class, you lose no information.
07:33:07 <jon_wingfield> right
07:35:42 <c_wraith> jon_wingfield: If you have the time to work through this, I suggest writing monad instance for two possible definitions of Identity, and looking at how they differ in terms of strictness
07:36:10 <c_wraith> jon_wingfield: the two definitions are "data Identity a = Identity a" and "newtype Identity a = Identity a"
07:36:46 <jon_wingfield> Alright, I'll give that a shot.  I enjoy toying with things, it helps me understand them better
07:36:47 <c_wraith> jon_wingfield: they actually have significant differences in behavior with identical Monad instances, because of the different semantics of pattern-matching a data constructor vs a newtype constructor.
07:37:17 <nitrix> c_wraith: I'm guessing the data constructor one is going to be lazy?
07:37:35 <c_wraith> nitrix: that's what everyone guesses.  Even me the first time.  It's the other way around.
07:37:45 <nitrix> The newtype are getting eliminated during com---
07:37:49 <nitrix> what? Oh wow.
07:37:57 <c_wraith> nitrix: because evaluating a newtype constructor is a no-op.  Evaluating a data constructor forces computation.
07:38:22 <c_wraith> err, pattern-matching the constructors
07:38:44 <nitrix> Well, doesn't it gives you only weak-head form of that constructor?
07:38:51 <jon_wingfield> Intersting, because newtype is isomorphic to the raw data (`a` in this case)?
07:39:10 <c_wraith> it's kind of subtle.  Best to work it out yourself. :)
07:39:28 <nitrix> Now you got me curious :P
07:40:10 <c_wraith> http://lpaste.net/165900 Is a good test case
07:40:36 <c_wraith> If you can extract a value from it, you've demonstrated that (>>=) is lazy
07:41:29 <c_wraith> I guess "undefined >> return 5" is shorter for the same idea
07:41:51 <jon_wingfield> c_wraith: That's fascinating, exactly what I was looking for
07:42:24 <jon_wingfield> when you desugar it: undefined >>= (\x -> return 5)
07:42:48 <jon_wingfield> ah, so I see
07:42:59 <jon_wingfield> depending on the monad `undefined` isn't evaluated?
07:43:31 <c_wraith> At least, not in that expression
07:43:35 <nitrix> Depending on the monad instance implementation for a given type, and the nature of that type (as demonstrated by c_wraith).
07:44:11 <nitrix> I didn't know it had an effect on the outcome, but apparently both does.
07:44:29 <c_wraith> Well, it's really the just the definition of (>>=) that matters
07:44:44 <nitrix> Oh, you're right.
07:44:54 <c_wraith> You can get either behavior out of data or newtype.  It's just that one is more natural in each case
07:45:07 <nitrix> Because >>= might pattern match, which is then, cause to effect conclusive.
07:45:27 <nitrix> Yeah okay. Gotcha.
07:45:37 <c_wraith> There's also irrefutable matches on data to get newtype-like behavior, or using seq to force evaluation in the newtype case
07:46:12 <nitrix> "But c_wraith! Does't that mean that it makes monadic code even harder to reason about the evaluation & execution?"
07:47:23 <nitrix> You have to know the specific Monad properties to have make any educated guess :x
07:47:34 <c_wraith> It does mean you can't ignore the specific type, if you're doing things that rely on strictness properties to function correctly.
07:48:57 <jon_wingfield> does strictness only matter when dealing with impurity though?
07:49:12 <bitemyapp> jon_wingfield: Monads are not impure
07:49:26 <bitemyapp> jon_wingfield: strictness always matters in any situation, as bottom can lurk anywhere in a program.
07:49:35 <nitrix> jon_wingfield: Strictness doesn't affect purity.
07:49:49 <jon_wingfield> ok, I'm reading about this, because I don't understand what it means apparently :)
07:49:50 <merijn> There is no impurity! *
07:49:50 <nitrix> I guess that's ill-phrased.
07:49:55 <c_wraith> it also matter when you depend on laziness for termination.
07:49:59 <c_wraith> *matters
07:50:01 <merijn> * - Unsafe functions not withstanding
07:50:14 <jon_wingfield> c_wraith: that's a good example, thanks
07:51:38 <c_wraith> In practice, you can write a fair bit of code that's agnostic to specific monad instances, because it doesn't rely on strictness properties to work.
07:52:02 <c_wraith> But when you do rely on them, you need to consider specific types.
07:53:11 <jon_wingfield> I'm learning things
07:53:12 <jon_wingfield> haha
07:54:10 <nitrix> jon_wingfield: Strictness matters at any point in your program. Just like with other languages you may want to short-circuit computations early to avoid doing extra work, Haskell choosing the opposite evaluation model (lazy evaluation) means you may want to force a computation to execute entirely rather than do as little as possible.
07:54:25 <nitrix> jon_wingfield: head [1, undefined]
07:55:10 <nitrix> This is independant of purity. Monads are pure by the way. Haskell doesn't allow impurity, except one evil function we wont mention :P
07:55:24 <merijn> nitrix: Multiple evil functions we won't mention >.>
07:55:25 <mauke> unsafeCoerce?
07:55:29 <jon_wingfield> so, can haskell also rewrite nested lambdas (eg binds) so that they're executed out-of-order?
07:55:40 <merijn> mauke: accursedUnutterablePerformIO too
07:56:00 <eldon> i'm a bit confused about currying, i get that you can pass in a function and return a function (partially applied) until you can call it with 1 arg and get the desired result
07:56:16 <mauke> completelyTotallyUnsafePointerEqualityISwear
07:56:19 <nitrix> eldon: I can explain it nicely I think.
07:56:23 <eldon> but what is the advantage compared to say just accepting 2 or more args like another language
07:56:31 <mauke> eldon: simplicity
07:56:33 <nitrix> eldon: You probably already know that functions are first-class citizens in Haskell?
07:56:35 <eldon> is it just a way of getting around the 1 arg limitation in haskell?
07:56:38 <eldon> yea
07:56:41 <mauke> you don't have to introduce "argument lists" as a special concept
07:56:51 <merijn> jon_wingfield: Instead, try to realise the truth...there is no order!
07:56:56 <nitrix> eldon: Meaning they are perfectly capable to play the role of values (in fact they are values_.
07:57:18 <nitrix> eldon: The idea is that every function takes one argument, and returns one argument. Always.
07:57:33 <eldon> why is that nitrix? is it a language limitation or does it give other benefits?
07:57:44 <jon_wingfield> \a -> a + 1
07:57:47 <eldon> i come from a c# background btw, hence a lot of the confusion :)
07:57:53 <jon_wingfield> doesnt that force ordering ^^
07:58:04 <nitrix> eldon: Thus, a function of type `:: a -> a -> a` actually reads as `:: a -> (a -> a)` where the resulting value of applying the first argument is a new function expecting the other argument.
07:58:09 <fr33domlover> eldon, you get partial application for free
07:58:11 <merijn> jon_wingfield: In what sense?
07:58:23 <jon_wingfield> in order to compute that function, you first need to know the value of a?
07:58:27 <c_wraith> jon_wingfield: depends on the type.  (+) is still a class function.  :)
07:58:33 <merijn> jon_wingfield: Do you?
07:58:50 <jon_wingfield> merijn: I'm not so sure now :-P
07:59:10 <nitrix> eldon: It's definitely intentional, not a limitation :P
07:59:11 <merijn> jon_wingfield: If you have Peano arithmetic "data Peano = Zero | Succ Peano"
07:59:14 <c_wraith> jon_wingfield: you could write an instance of Num for lazy naturals that would evaluate to WHNF on the expression (a + 1) without evaluating a
07:59:29 <fr33domlover> eldon, you could ask why some languages don't have currying built in an can't do partial application like Haskell :P
07:59:40 <merijn> jon_wingfield: You can do "x + Zero = x; x + (Succ n) = Succ (x + n)" <- now you don't need to know a
07:59:49 <mauke> sml could do it but doesn't
08:00:02 <c_wraith> jon_wingfield: on the other hand, if you say (a + 1 :: Int), then yes, it needs to evaluate a to evaluate (a + 1)
08:00:10 <jon_wingfield> interesting
08:00:22 <jon_wingfield> so it depends on the context?
08:00:35 <fr33domlover> > map (+ 1) [0, 2, 4] -- eldon 
08:00:39 <lambdabot>  mueval-core: Time limit exceeded
08:00:42 <c_wraith> Well, it depends on the types.  I suppose those are the part of the context of an expression
08:00:53 <fr33domlover> > map (+ 1) [0, 2, 4]
08:00:56 <lambdabot>  [1,3,5]
08:01:05 <jon_wingfield> ah, right the types. Context was causing my brain some problems there anyway :)
08:01:39 <mauke> welcome to perl
08:01:57 <eldon> i guess the bit i'm confused at is where currying/partial application is useful, could i do something like partially apply a function then send it to something else to finish computing? e.g. a diff computer on a network
08:02:23 <eldon> i think erlang does that actually
08:02:25 <mauke> eldon: how about to a different function, like the map example above?
08:02:25 <nitrix> eldon: fr33domlover just gave you an example.
08:02:26 <c_wraith> eldon: it's mostly about being able to pass a partially-applied function to a higher-order function
08:02:48 <eldon> 2 secs, trying to wrap my head round that :)
08:02:50 <nitrix> eldon: Just passsing it to another function expecting a function as an argument (higher-order).
08:03:06 <c_wraith> eldon: instead of having to write a lambda (or even worse, something like a C++ "functor"), you just supply the argument in code.
08:03:26 <c_wraith> eldon: It makes it completely trivial to use higher-order functions.
08:04:57 <c_wraith> eldon: in a lot of ways, you can consider partial application to be the factory pattern with *far* better syntax. :)
08:05:38 <eldon> actually, the map (+1) [0, 2, 4] example is good, i can't think how else you'd do that
08:05:46 <jon_wingfield> eldon: here's an example from javascript that would be simplified by currying/partial evaluation:
08:05:51 <jon_wingfield>     var validator = function(test, apply) {
08:05:51 <jon_wingfield>         return function(item) {
08:05:51 <jon_wingfield>           return validateItem(item, test, apply);
08:05:53 <jon_wingfield>         };
08:05:55 <jon_wingfield>     };
08:06:36 <fr33domlover> > withFile "hello.txt" ReadMode $ \ h -> readFile h >>= putStrLn
08:06:37 <jon_wingfield> I just did this in a codebase the other day... it would have been much simpler with partial evaluation
08:06:40 <lambdabot>      Not in scope: ‘withFile’
08:06:40 <lambdabot>      Perhaps you meant one of these:
08:06:40 <lambdabot>        ‘writeFile’ (imported from Prelude),
08:06:43 <c_wraith> Heh.  I've just learned about underscore/lodash.  Both make that far easier - but it's buried in a library, not part of the language.
08:06:45 <fr33domlover> eldon, another example ^
08:07:14 <jon_wingfield> c_wraith: yeah, and it's almost more noise than it's worth
08:07:18 <eldon> i see, think i get it now, thanks :)
08:07:20 <fr33domlover> of how not passing all the arguments instaly is useful
08:12:20 <merijn> fr33domlover: Needs more fish operator
08:12:42 <jdreaver> I have a package on stackage at version 0.1.1. I want to bump the version because I added a bunch of features. If I call the new version 0.2 will it be in the next LTS, or do I have to call it 0.1.2?
08:12:48 <merijn> fr33domlover: "\h -> readFile h >>= putStrLn" -> "readFile >=> putStrLn"
08:13:05 <merijn> Fish operator makes everything better
08:13:08 <hpc> @where pvp
08:13:09 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
08:13:19 <hpc> jdreaver: follow the guidelines here ^
08:13:30 <bblfish> Hi I am on OSX and I have installed haskell 8.0.1 
08:13:30 <fr33domlover> merijn, it's probably a useless exampe anyway :P
08:13:40 <fr33domlover> I just didn't have a better one
08:13:45 <jdreaver> hpc: thanks
08:14:13 <jdreaver> Ah I see, the first two numbers both comprise the major version.
08:14:27 <bblfish> Hi I am on OSX and I have installed haskell 8.0.1 
08:14:27 <bblfish> and am trying to continue with 
08:14:27 <bblfish> cabal install --upgrade-dependencies hlint stylish-haskell hindent ghc-mod
08:14:29 <bblfish> but there are a lot of missing dependencies. Any idea?
08:14:58 <fr33domlover> bblfish, cabal update ?
08:15:04 <bblfish> yes, I did that
08:15:07 <hpc> jdreaver: oh, if you do 'cabal init' and tell it to document the package fields, there's a bit of explaining on version numbers there too
08:15:41 <hpc> jdreaver: oh, i guess it just links back to that wiki page
08:16:12 <fr33domlover> bblfish, also it's probably easier to use GHC 7.10 for now
08:16:22 <fr33domlover> unless you specifically want 8
08:16:45 <bblfish> was just going for the lastest, as I was having a bit of trouble with what I had previously.
08:17:37 <jdreaver> So if all I did was add new features, I guess I should change the version from 0.1.1 to 0.1.2 then.
08:17:58 <jdreaver> Interesting, I thought it was going to be closer to semver
08:20:06 <ggVGc> what do you guys reckon is the biggest carrot to upgrade from 7.10 to 8?
08:20:39 <mauke> http://www.carrot-programming.org/
08:23:08 <bblfish> What is the best IDE for using Haskell at present? I can't use IntellIj with haskell 8.0.1 as it wants those ghc-mod.
08:23:23 <bblfish> so I might as well see if something else works before I install a different version.
08:23:29 <bblfish> Is Atom good?
08:23:31 <mauke> linux, but I always say that
08:23:54 <bstamour> I use emacs with haskell-mode and stack
08:24:03 <bstamour> Seems to do everything I need
08:24:23 <Sonmi> atom is pretty and seems great to me so far
08:24:41 <Sonmi> i've only been using it for a week or so but i like it
08:24:53 <bblfish> I suppose what I really need is something to help me with finding types, and type inferences, as I am quite new.
08:25:19 <bblfish> Sonmi: are you using it with 8.0.1 ?
08:25:58 <Sonmi> are you talking about ghc? i'm confused
08:25:59 <Xandaros> bblfish: I've heard good things about atom, if that's your kind of thing. I personally use neovim with ghc-mod. Only just now upgrading to 8, though, so I can't tell you how well it behaves just yet
08:26:16 <Sonmi> i'm honestly very new to haskell as well
08:26:40 <Freundlich> Xandaros: ghc-mod doesn't work with ghc-8.
08:26:46 <bblfish> Xandaros: let me know if you succeed in compiling ghc-mod and if it works...
08:26:48 <merijn> I wouldn't recommend using 8.0.1 when just starting out
08:26:58 <merijn> There's not really any point to it
08:27:12 <Sonmi> looks like i'm on 7.10.3
08:27:16 <fr33domlover> Save yourself the frustration and use 7.10
08:27:47 <hodapp> I'm on Emacs & intero, and liking it so far though I keep bumping into bugs and annoyances
08:27:48 <bblfish> what about 7.13 ?
08:27:51 * hackagebot stratosphere 0.1.2 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.2 (jdreaver)
08:27:51 <Sonmi> about atom, though, there's some telemetry enabled by default, just fyi if you were to use that
08:27:59 <merijn> bblfish: There's no 7.13
08:28:08 <merijn> bblfish: Stable GHC releases are always even numbered
08:28:15 <bblfish> Ah I thought I had something a bit above 7.10
08:28:44 <merijn> 8.0 is the first version after 7.10, but unless you NEED some of the new features, you're better of lagging and using an older version
08:29:04 <merijn> And since all the new features tend to be advanced stuff, beginners are better off using a more settled/tested version
08:29:31 <merijn> I'd probably recommend trailing the latest version by 6 months to 1 year (so update to 8.0 when it's been out that long)
08:29:55 <merijn> Unless you have a specific reason to upgrade
08:30:09 <bblfish> Ah I must have been thinking of 7.10.3
08:31:05 <bblfish> Yes, looks like it's not that old anyway. Ok, so I'll re-install that.
08:45:22 <Xandaros> Using bleeding edge versions does come with a number of disadvantages: Lack of tooling, libraries might not compiler, etc. Of course, you get to use the awesome new features, but if you don't know what they do anyway, there's not much point :P I have to say, I personally only use the newest GHC because I can. The only thing I actually need it for is the fancy new haddock source linking. Which doesn't seem to
08:45:23 <Xandaros> work. :/
08:48:03 <Squarism> it feels like i use the test framework noone is using : hunit?! Resources about it is scarce.
08:48:39 <Xandaros> I use hunit. Kinda…
08:48:57 <bblfish> yes, it just seemed like 8.0.1 would be a huge step from 7.10
08:49:50 <Xandaros> Squarism: I use tasty with tasty-hunit for my tests. ocharles has a blog post on it
08:50:06 <Squarism> Xandaros, should you be able do multiple assertions? ...in do 1 @=? a <NL> 2 @=? b ... ?
08:50:18 <hexagoxel> "the community demands more breaking changes in base!"
08:51:57 <Xandaros> Squarism: No idea. All my tests appear to use assertEqual and assertFailure :/
08:52:52 * hackagebot filestore 0.6.2 - Interface for versioning file stores.  https://hackage.haskell.org/package/filestore-0.6.2 (JohnMacFarlane)
08:56:54 <Sinestro> I hate how good Haskell is at preventing bugs most of the time
08:57:17 <Sinestro> My intuition for finding the problem when something does slip through in a Haskell program isn't very good
08:58:19 <Sinestro> And other good problems to have
08:58:31 <maerwald> depends what kind of bug you mean
08:59:20 <maerwald> unexpected behavior in your IO code?
09:09:04 <nitrix> Sinestro: The only problems that I've had were lazy/strictness, race conditions, logical, and IO that made no sense (directory missing or whatever).
09:10:07 <nitrix> Sinestro: Nothing Haskell could've prevented. The race condition was particuliarly tricky and at least, it'd kill the thread upon detecting it. The application was able to recover from the crash and spawn a new thread, so there's that.
09:10:21 <Sinestro> I managed to create IO/ST actions that would never actually get executed, but they returned () so I didn't notice until I realized that they didn't do anything.
09:11:43 <nitrix> Strange. I'd imagine IO to necessarily carry out the effects if you evaluate it.
09:11:52 <bblfish> Mhh I am having trouble when opening Atom on this project https://github.com/dalaing/cofun
09:11:53 <nitrix> Unless the effects are inhebited like lambdabot.
09:12:37 <hpc> nitrix: evaluation and execution are distinct in haskell
09:12:44 <Sinestro> That's the only way I can guess that this would work
09:13:19 <nitrix> hpc: Yes, but execution drives evaluation.
09:14:17 <nitrix> hpc: It seems impossible to be you'd get the `()` of an `IO ()` without the effects being carried out (unless inhebited).
09:14:21 <hpc> oh, i missed what Sinestro said
09:14:23 <nitrix> s/be//
09:14:37 <nitrix> s/be/me/
09:14:52 <hpc> yeah, i would expect that to more be a case of writing something one way and thinking it was something else
09:15:09 <Sinestro> No, I was creating an IO action that created an IO action and then didn't evaluate it, then `return ()`ed at the end
09:15:11 <nitrix> With ST though, I think you can actually break things.
09:15:19 <Sinestro> GENIUS!
09:15:32 <Squarism> if your program hangs, if its some infinite loop going on does haskell detect it?
09:15:40 <hpc> Sinestro: so like, doTheThing action = return (), and then it doesn't run action?
09:16:02 <hpc> Squarism: how would it?
09:16:07 <c_wraith> Squarism: GHC's runtime catches one particular infinite loop, and terminates with an exception.  But it's not going to catch everything.
09:16:11 <hpc> Squarism: that's the halting problem
09:16:16 <Squarism> hpc, i dont know... next gen magic?
09:16:30 <hpc> but yeah, there's only one thing that ghc catches
09:16:32 <Sinestro> Nah, it was more like do theThing x; return () but somehow the action that theThing returned never got executed.
09:16:46 <nitrix> Shouldn't the type have been :: IO (IO ()) ?
09:16:53 <nitrix> I don't think you're telling us everything :P
09:16:55 <puregreen> c_wraith: what loop is that?
09:16:56 <hpc> when evaluating a thunk in such a way that evaluating the thunk requires evaluating that exact same thunk, that's detectable and the program crashes with "<<loop>>"
09:17:08 <c_wraith> puregreen: exactly what hpc just said
09:17:15 <Squarism> nitrix, me?
09:17:23 <hpc> but only in the non-threaded runtime
09:17:29 <nitrix> Squarism: Sinestro.
09:17:51 <hpc> in the threaded runtime, the thread just waits because maybe something else will throw an exception to it or something
09:17:52 <c_wraith> hpc: actually, the threaded runtime will detect that case now
09:17:57 <hpc> oh, neat
09:18:07 <c_wraith> hpc: it detects it during GC passes
09:18:49 <hpc> the exact mechanism it uses is called a black hole
09:18:51 <Sinestro> I have a data type with a IO (MVector RealWorld a) inside of it, but when I use the wrapper function I made to grab the vector and mangle it around it does nothing, but it works fine if I run the exact contents of those functions right in main.
09:19:18 <hpc> when ghc begins evaluating a thunk, it rewrites the thunk temporarily to "crash the program" in the non-threaded runtime, or "wait for it to be evaluated elsewhere" in the threaded runtime
09:19:36 <c_wraith> Sinestro: creating a data structure that contains an IO action doesn't necessarily bind that IO action to anything.  If you want the IO action to be run, it needs to be bound.
09:19:48 <hpc> and then if it loops back on itself it hits that behavior
09:20:08 <hpc> after evaluation, the thunk is rewritten again
09:20:20 <hpc> i suppose i should be saying "box" instead of "thunk" here maybe
09:20:39 <hpc> anyhoo, the life cycle of a thunk/box from start to finish is
09:20:55 <geekosaur> :t return (putStrLn "hello") -- doesn't run
09:21:00 <hpc> "compute the value in this thunk" >>> "crash the program" >>> "return the value that was just computed"
09:21:09 <lambdabot> Monad m => m (IO ())
09:21:09 <geekosaur> did we lose the bot?
09:21:13 <geekosaur> oh, there it is
09:21:21 <geekosaur> :t join
09:21:34 <lambdabot> Monad m => m (m a) -> m a
09:21:37 * geekosaur sends lambdabot coffee
09:21:38 <Sinestro> That's not the problem here. it's a case of `do vector <- _vector bigThing; MV.write vector place stuff` somehow doing nothing (or at least not doing anything when I freeze the BigThing again)
09:21:41 <hpc> and in ghc a thunk is implemented as something that resembles a function call
09:22:01 <hpc> i don't know if it uses the actual assembly for function-y stuff or if it just does a jump to some instruction or what
09:22:11 <hpc> but that's the gist of it
09:25:33 <Sinestro> The frustrating part is that any simple test I try to make to show what's wrong works fine
09:25:59 <hpc> c_wraith: do you happen to know how the GC pass detects the loop?
09:26:03 <c_wraith> Sinestro: I suspect you're misunderstanding the problem in the failing case, which is why you can't reproduce it in smaller cases.
09:27:30 <c_wraith> hpc: during the GC pause, it checks to see, if any thread is blocked evaluating a thunk, if any other thread is working on that thunk.  If not, it throws the loop exception.
09:28:03 <c_wraith> hpc: it ignores the case that some other thread might use throwTo, because throwTo is considered an imprecise exception, and GHC considers any imprecise exception to be just as good as any other.
09:28:47 <c_wraith> and loop is also an imprecise exception
09:30:20 <Sinestro> c_wraith: that is correct
09:31:45 <Sinestro> I was somehow in the wrong monad (i.e. not IO) but the types of the functions I used were generic enough that it was trying its best
09:31:55 <hpc> ah, cool
09:32:04 <Sinestro> Bless ghc's little heart
09:32:37 <hpc> "imprecise exception" being roughly described as like a non-IO exception?
09:33:18 <hpc> and something like throwIO would be considered precise?
09:34:36 * hpc is new to the term
09:37:07 <hpc> it'd be so great if hackage would build haddock even if compilation failed
09:37:34 <hpc> being able to read documentation on things that depend on sdl2 or whatever
09:40:57 <twopoint718> In the Haxl example, https://github.com/facebook/Haxl/blob/master/example/facebook/readme.md#the-data-source-api-fbdatasource what would using a "vanilla" HTTP request look like. It would probably be a different implementation of `fetchReq`. The current example uses the `FacebookT` monad transformer & I can't quite follow how that's doing the underlying HTTP GET.
09:42:54 * hackagebot hakyll-filestore 0.1.2 - FileStore utilities for Hakyll  https://hackage.haskell.org/package/hakyll-filestore-0.1.2 (aergus)
09:44:16 <defanor> how up-to-date https://wiki.haskell.org/CPlusPlus_from_Haskell is? seems like bindings to C++ libraries just make C APIs first, and then use them (e.g., wxc), but it'd be one more layer
09:45:42 <defanor> though it'd probably also be easier. anyway, i'm not sure how to do that, so looking for more information
09:46:01 <defanor> (that is, which way to pick)
09:47:37 <glguy> defanor: The only portable way to talk to C++ is via a C layer
09:48:17 <glguy> as far as the FFI goes
09:48:25 <defanor> glguy: thanks. making stand-alone C bindings at once wouldn't harm anyway
09:49:21 <glguy> defanor: C++ name mangling is implementation dependent iirc, so it's key that you let your C++ compiler make the C interface itself
09:52:34 <bblfish> bblf
09:58:04 <nitrix> One could argue C doesn't really have an ABI either as per the standard, just a de-facto agreement. Surely similar could've been done for C++.
09:58:30 <glguy> Yes, one is certainly prone to argument
10:00:29 <nitrix> I just find it sad we're creating additional complexity in that problem space. We could gain a lot of the C++ libraries effortlessly if this was different.
10:00:41 <schell> lol
10:03:29 <nitrix> I'm not sure why its funny and badly received. Isn't it a valid point? I'm thinking all the game engines for one that could join the Haskell force.
10:04:07 <schell> sorry, the funny part was glguy’s “one is certainly prone to argument” comment 
10:05:17 <schell> i actually haven’t been following the conversation other than that
10:05:45 <schell> i’m all for c++ bindings without having to write a c wrapper
10:06:07 <Cale> nitrix: You mean pick a specific C++ implementation and add support to GHC for its conventions?
10:07:38 <schell> i’ve been really happy writing bindings using bindings-dsl, maybe there’s a similar strategy for c++ wrappers?
10:10:39 * defanor wonders whether there's a SWIG-alike tool, but with C++-to-C mode
10:11:26 <defanor> with that, it'd still be fairly easy to make C++-via-C bindings
10:11:51 <defanor> and it's mostly mechanical work to make those C++-to-C ones
10:24:39 <jm_c_> I am trying to write a very naive scripting language, and I would like it to have macros
10:24:49 <jm_c_> I want to write a Parsec parser for it
10:25:32 <jm_c_> So, suppose Parsec has determined that it hit a macro, how do I push the value of the macro onto the front of the string that Parsec is parsing?
10:26:26 <jm_c_> suppose it just parse "macro1", then I essentially want to put the contents of macro1 in front of everything else that remains to be parsed
10:29:33 <jm_c_> I can't use a lexer (afaik) because the value of macro1 might depend on parsing earlier parts of the script...
10:39:33 <lyxia> jm_c_: take a look at getInput and setInput
10:40:49 <geekosaur> it is possible to use a lexer but you need to arrange for parsing to be able to influence future lexing. conveniently, lexing and parsing are usually both in IO already.
10:40:57 <lyxia> or set/getParserState
10:41:02 <geekosaur> (and, depending on how your macros work, you may need to do it at the lexer level)
10:41:30 <jm_c_> lyxia: I'll take a look
10:41:32 <jm_c_> geekosaur: thx
10:42:16 <geekosaur> or in the parser but separating levels so you can handle the macro at a place where you aren't already committed to a different parse
10:42:59 <jm_c_> lyxia: it seems that a "setInput (macro1 ++ getInput)" should work
10:43:23 <jm_c_> geekosaur: yeah, but I don't really know how to do that... atm
10:43:44 <jm_c_> geekosaur: probably need a more abstract view of what is going on..., but lyxia's suggestion might work
11:12:57 * hackagebot irc-client 0.4.1.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.1.0 (barrucadu)
11:19:53 <baordog> Good afternoon haskelers. Can you suggest a constraint solver systme in haskell?
11:26:33 <the_2nd> Can I define a class constraint somewhere globally? e.g. f :: (S a, B a, C a) => a -> a    f2 :: (S a, B a, C a) => a -> bool
11:26:52 <the_2nd> So I don't have to repeat the constraint for all similar functions
11:27:13 <the_2nd> Since they might keep calling each other anyway
11:27:16 <glguy> the_2nd: You could do this with the ConstraintKinds extension: type SBC a = (S a, B a, C a)
11:27:38 <buglebudabey> I made a small program that is supposed to use Aeson, but im getting ' Could not find module ‘Data.Aeson’' when i try to run in ghci. does anyone know what to do?
11:28:04 <glguy> buglebudabey: You'll have to install aeson: cabal install aeson
11:28:19 <buglebudabey> thanks!
11:28:56 <MichaelBurge> buglebudabey: If you're using stack to manage your project, 'stack repl' or 'stack ghci' will load all the packages in your .cabal. cabal has a similar feature too, I'm sure.
11:29:48 <buglebudabey> i'm not really familiar with using either stack or cabal, i've been learning haskell for a while but haven't used that at all
11:30:13 <buglebudabey> can you recommend any good resources?
11:31:23 <MichaelBurge> buglebudabey: The docs for stack are pretty good: http://docs.haskellstack.org/en/stable/README/
11:33:37 <mjrosenb> is there an irc channel for using emacs with haskell?
11:33:51 <nitrix> mjrosenb: There is #haskell-emacs
11:34:16 <mjrosenb> barring that, does anyone know if there is a way to indent some number of lines in emacs?
11:35:32 <puregreen> mjrosenb: I just have these defined in a utils module: http://lpaste.net/165965
11:36:11 <geekosaur> mark them, C-u <amount to in/outdent> C-x TAB
11:37:52 <geekosaur> (oddly, I actually had noticed this morning that I needed to reindent something in a script (in a way the major mode doesn't like but I do), so I did it there before sending here :)
11:44:24 <nitrix> Or 5>> if you use evil-mode :)
11:50:37 <geekosaur> ...but only by the shiftwidth setting, not an arbitrary amount
11:52:55 <mjrosenb> puregreen: can't those be implemented with just a keybinding to the indent-code-rigidly function that you're already using?
11:53:41 <puregreen> mjrosenb: this would mean having to do C-u and I don't want that
11:54:46 <puregreen> so I have “indent left” and “indent right” bound to C-n and C-m (which are actually C-< and C-> on my layout) and I just press them several times
11:55:39 <mjrosenb> puregreen: ahh, fair
12:01:35 <the_2nd> any resource where I can see best practices with using monads and maybes within the program flow / decisions?
12:18:42 <dutchie> I have tried multiple times "rm -fr ~/.stack; stack setup"
12:18:51 <dutchie> and I keep getting "/usr/bin/ld: /tmp/stack-sanity-check2355/Main.o: relocation R_X86_64_32S against `stg_bh_upd_frame_info' can not be used when making a shared object; recompile with -fPIC"
12:19:21 <dutchie> stack --version: Version 1.1.2 x86_64 hpack-0.14.1. Arch Linux x64
12:19:23 <dutchie> any clues?
12:19:49 <dutchie> (lts-6.2)
12:20:48 <nitrix> dutchie: Are you on Arch Linux ?
12:21:09 <monochrom> some kind of not making up its mind on static linking vs dynamic linking
12:21:10 <dutchie> yes, is it broken at the moment?
12:21:12 <nitrix> GHC master doesn't compile on arch atm.
12:21:49 <nitrix> GHC 8 is doomed to fail until someone looks into the ticket I opened (:
12:21:55 <dutchie> Is it not master though? Wouldn't stack be getting a 7.10.3 tarball?
12:22:10 <nitrix> dutchie: Only for older stack snapshots.
12:22:15 <EvanR> ghc 8: avoid success at all costs
12:22:18 <nitrix> 6.2 is recent and will use GHC 8 I believe.
12:22:32 <dutchie> it's grabbing 7.10.3
12:23:03 <hexagoxel> even latest lts is still ghc-7.10.3
12:23:06 <nitrix> Oh you're right. It's 7.10.3
12:23:15 <nitrix> Nightlies are GHC 8.
12:24:26 <nitrix> dutchie: Anyway, if it's comforting, all my arch systems have the same problem currently.
12:24:52 <dutchie> it's weird, it worked when I did the same thing on my laptop earlier today
12:25:05 <dutchie> but I got home, repeated the same steps on my desktop box and now it's broken
12:25:06 <dutchie> oh well
12:25:50 <nitrix> dutchie: I personally solved it by installing 7.10.3 myself and letting stack detect it as already installed.
12:26:34 <hexagoxel> dutchie: maybe you have a ghc-7.10.3 installed via system on one of them, getting used?
12:28:26 <dutchie> I thought I uninstalled the system ghc
12:29:09 <dutchie> on both boxes
12:29:43 <buglebudabey> if i wanted to share my program here to help debug something, what would be the best medium to that?
12:29:50 <dutchie> @paste
12:29:50 <lambdabot> Haskell pastebin: http://lpaste.net/
12:33:31 <lpaste> buglebudabey pasted “json parse” at http://lpaste.net/165974
12:35:15 <buglebudabey> if i want to keep all of my io actions in my main method of the same type, how can i accompllish this here: http://lpaste.net/165975 (sorry if you guys see this twice, i was disconnected)
12:41:02 <mjrosenb> what is the recommended networking library?
12:41:14 <johnw> mjrosenb: just plain sockets?
12:41:19 <mjrosenb> Network says it is deprecated, ad we should use Network.Socket
12:41:32 <mjrosenb> but Network.Socket says that Network is the high level interface.
12:41:42 <mjrosenb> johnw: yeah.
12:46:12 <EvanR> i use Network out of spite for that deprecation warning
12:46:52 <mjrosenb> cool.
12:50:44 <cocreature> there is also network-simple or something like that
12:59:49 <EvanR> oh nice
13:02:30 <fvh> hi folks! I'm working with `postgre-simple` and for very simple code `(xs :: [Integer]) <- returning conn query'' vals` get `No instance for (FromRow Integer)` . How so? It's simple type, tried Int8, Int64 same story. Any suggestions how to fix this?
13:05:42 <dmj`> fvh: there is no instance for FromRow Integer, but there is one for FromRow [Integer], can you paste your code
13:11:27 <fvh> dmj: http://lpaste.net/165978 here you go
13:11:43 <fvh> I hust want to get id of inserted record
13:11:46 <fvh> *just
13:13:02 * hackagebot union 0.1.1.1 - Extensible type-safe unions  https://hackage.haskell.org/package/union-0.1.1.1 (int_index)
13:16:02 <freinn> hi! I'm having problems using my implemented type instance of Monad (is Reader), I have to implement a function like the penultimate, but using my type and its Monad instance: http://lpaste.net/165979
13:18:52 <johnw> freinn: I'm not exactly sure what the question is
13:18:56 <johnw> normally one would write this:
13:19:12 <johnw> getDogRM' (Person a b c) = Dog b c
13:19:21 <johnw> there's no need to use Reader, or anything monadic, here
13:20:27 <freinn> johnw is just an exercise from the chris allen's book, and I don't know how to use my type for that to compile and run
13:20:52 <johnw> chris allen is usually hanging out in #haskell-beginners, and would be glad to help if he's there
13:21:50 <freinn> thanks johnw
13:21:55 <mauke> why does the PVP specify that new major versions have to be > old versions?
13:22:24 <byorgey> mauke: as opposed to being < ?
13:22:55 <mauke> yes
13:23:11 <mauke> why is there an ordering relation between major versions?
13:23:59 <byorgey> I guess just because it's convenient to have historical order and version number order coincide?
13:25:19 <dmj`> fvh: I'd try 'execute' then
13:29:19 <fvh> dmj`: Execute an INSERT, UPDATE, or other SQL query that is not expected to return results.
13:29:33 <fvh> already tried
13:32:40 <dmj`> fvh: "Note that it is possible to write query conn "INSERT ... RETURNING ..." ... in cases where you are only inserting a single row"
13:33:03 * hackagebot git-annex 6.20160613 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160613 (JoeyHess)
13:33:04 <dmj`> fvh: maybe try 'query'
13:33:05 * hackagebot hapstone 0.2.0.0 - Capstone bindings for Haskell  https://hackage.haskell.org/package/hapstone-0.2.0.0 (ibabushkin)
13:33:07 * hackagebot hapstone 0.2.0.1 - Capstone bindings for Haskell  https://hackage.haskell.org/package/hapstone-0.2.0.1 (ibabushkin)
13:33:13 <johnw> mauke: how would it ever make sense for version 3.x to follow 4.x?
13:33:31 <johnw> a lot of tooling expects an ordering
13:34:02 <fvh> dmj`: yeah, I read this too, gives exactly the same error
13:34:20 <puregreen> fvh: there was a function to get last inserted ID
13:35:21 <puregreen> hm, or not
13:35:25 <fvh> puregreen: so you propose to make 2 queries, insert then select?
13:36:24 <puregreen> nope, a postgresql-simple function, but in reality I saw it in sqlite-simple and it looks like it's not present in postgresql-simple
13:37:22 <mauke> johnw: the PVP seems to treat each major version as distinct and incompatible
13:37:31 <johnw> ah
13:37:33 <puregreen> fvh: ahh, you probably should use Only
13:37:36 <fvh> no, I think postgresql-simple doesn't have that one. Actually I had pretty smooth experience with library until this error
13:37:47 <mauke> johnw: also note that in A.B.C, A.B is the "major version"
13:37:47 <fvh> I tried to use [Only Integer]
13:37:52 <puregreen> did it work?
13:37:55 <fvh> nope
13:37:59 <fvh> another error
13:38:14 <puregreen> can you paste it?
13:38:30 <fvh> yeah, just a sec
13:39:31 <dmj`> fvh: [Only Integer] works
13:39:32 <fvh> `No instance for (ToRow T.Text) arising from a use of ‘returning’`
13:39:34 <lpsmith> fvh: http://lpaste.net/165978
13:39:40 <fvh> but I just tried with query
13:39:43 <lpsmith> That should be pretty close to working
13:39:45 <fvh> and it works
13:39:58 <lpsmith> returning is analogous to executeMany
13:40:12 <fvh> yes, so is that a bug for returning?
13:40:21 <lpsmith> That's if you want to insert multiple rows at once
13:41:54 <lpsmith> returning is if you want to expand the (?,?,?) after the values into multiple VALUES (a,b,c),(d,e,f),(x,y,z),... 
13:41:57 <fvh> than docs are ambiguous about that, in my understand I'm insetring either list with many values or list with one
13:43:03 <fvh> yeah, I get that, but I assume that [] converted into (x,y,z)s
13:43:04 * hackagebot Plot-ho-matic 0.9.0.9 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.9 (GregHorn)
13:43:13 <lpsmith> fvh: http://lpaste.net/165978
13:43:17 <mjrosenb> more network questions:
13:43:41 <fvh> lpsmith: nice catch!
13:44:34 <lpsmith> Actually, that should be val,  singular,  but you can put more than one tuple in that list,  and it should work
13:44:37 <fvh> but what if I have table with >15 fields, do I need to write my own tuple?
13:44:57 <mjrosenb> after I've accepted a connection, is there any way to close the connection without closing the handle?
13:44:58 <Denommus> hi
13:45:02 <mjrosenb> err
13:45:08 <mjrosenb> without closing the socket
13:45:15 <mjrosenb> I guess I can just close the handle.
13:45:32 <fvh> afaik, there is only 10 field tuple supported
13:45:32 <lpsmith> You can write a ToRow instance,  or you can use a list,  or you can use :.  to string together multiple tuples
13:46:01 <hpc> mjrosenb: you mean, close the connection you just accepted but keep listening for new ones?
13:46:45 <fvh> lpsmith: thanks, very helpful, what is :. ?
13:46:51 <geekosaur> mjrosenb, http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html#v:shutdown
13:47:04 <geekosaur> or do you mean what hpc said, or ?
13:47:46 <hpc> you don't usually deal with the Socket type directly
13:48:32 <mjrosenb> hpc: yeah, that.
13:49:24 <hpc> ah yeah, just close the handle you just accepted then
13:58:04 * hackagebot monad-timing 0.1.0.0 - Monad transformer for recording timing events  https://hackage.haskell.org/package/monad-timing-0.1.0.0 (pikajude)
14:08:36 <lpsmith> fvh, http://hackage.haskell.org/package/postgresql-simple-0.5.1.3/docs/Database-PostgreSQL-Simple-Types.html#t::.
14:23:05 * hackagebot shellmate 0.3.1 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.1 (AntonEkblad)
14:23:07 * hackagebot shellmate-extras 0.3.1 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3.1 (AntonEkblad)
14:23:25 <fvh> lpsmith: interesting, thanks
14:28:06 * hackagebot hashing 0.1.0.1 - A pure haskell library implements several hash algorithms.  https://hackage.haskell.org/package/hashing-0.1.0.1 (wangbj)
14:38:06 * hackagebot monad-timing 0.1.0.1 - Monad transformer for recording timing events  https://hackage.haskell.org/package/monad-timing-0.1.0.1 (pikajude)
15:08:07 * hackagebot stratosphere 0.1.2.1 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.2.1 (jdreaver)
15:40:42 <benzrf> is there any way to use the Cabal library without going through the cabal-install binary?
15:40:46 <benzrf> or is it designed to be used with?
15:43:07 <puregreen> benzrf: if something like default-extensions is set in .cabal, the files simply won't compile
15:43:53 <benzrf> puregreen: i don't know what you mean... how does that apply to what i asked?
15:45:43 <puregreen> benzrf: I thought that you wanted to load the files without going thru cabal. In a simple case it should be possible, but my point was that you can't always do without parsing the .cabal file and changing the way you invoke GHC based on what you see in the .cabal file.
15:46:21 <benzrf> oh - i dont have something i want to do
15:46:38 <benzrf> i was just wondering if the cabal library was supposed to be separate from the cabal-install binary, or if it's just supposed to be a backend for it
15:46:47 <puregreen> ah
15:47:08 * puregreen looks at the question closely
15:47:23 <hexagoxel> benzrf: http://packdeps.haskellers.com/reverse/Cabal
15:47:24 <puregreen> I have misread it completely, nevermind
15:47:30 <hexagoxel> does that answer the question?
15:48:08 * hackagebot dustme 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/dustme-0.1.0.0 (MarkWotton)
15:48:10 <TerNit> hi! how to make instance? https://bpaste.net/show/f720c3e2f5fb
15:48:11 * hackagebot mellon-core 0.7.0.0 - Control physical access devices  https://hackage.haskell.org/package/mellon-core-0.7.0.0 (dhess)
15:50:18 <monochrom> TerNit: I think you have a misunderstanding that's more basic than classes and instances.
15:50:31 <hexagoxel> TerNit: It is very well possible that a/=b even when your context provides (Num a, Num b)
15:51:12 <buglebudabey> could someone help me with Happy? I'm trying to parse a lisp list such as '(1 2 3) into a data type, but don't know how here's my code http://lpaste.net/166007
15:51:25 <monochrom> if you declare a function to have type "s :: (F a, Num b) => a -> b", it means the user, not you the author, dictates what b will be.
15:51:49 <monochrom> whereas your coding implies that you think you the author has that right.
15:52:40 <lethjakman> So, I've imported Text qualified as T, but I'm getting this error:
15:52:43 <lethjakman>  Not in scope: ‘T.putStrLn’
15:52:48 <lethjakman> That seems kinda weird...
15:53:00 <lethjakman> Is there a way to check if my specific instance of Data.Text has putStrLn?
15:53:06 <coppro> lethjakman: that's in Data.Text.IO iirc
15:53:11 <acowley> lethjakman: You need the IO module
15:53:17 <acowley> what coppro said
15:53:17 <lethjakman> OH
15:53:19 <jle`> lethjakman: what module did you import?
15:53:19 <lethjakman> Der.p 
15:53:31 <jle`> the Text module doesn't actually involve Text, i think
15:53:36 <jle`> it's more abuot string manipulation in general
15:53:37 <acowley> lethjakman: Conveniently, you can also import Data.Text.IO as T and it won't conflict with Data.Text
15:53:40 <jle`> *the text package
15:53:51 <jle`> text package is under Data.Text, normally
15:54:13 <lethjakman> Gotcha.
15:54:34 <jle`> you can check what functions your module exports with :browse in ghci, or just looking at the haddocks too
15:55:11 <lethjakman> T.concat doesnt' work when I import Text.IO as T
15:55:20 <buglebudabey> anyone know how to parse a lisp list with happy?
15:55:21 <lethjakman> Not in scope: ‘T.unpack’ …
15:55:26 <jle`> i don't think Data.Text.IO exports unpack
15:55:43 <acowley> Yes, that's why I mentioned importing both modules
15:55:46 <jle`> Data.Text probably does though
15:56:08 <lethjakman> Hrm...
15:56:11 <lethjakman> So I do have to import both.
15:56:17 <japesinator> hey, I'm trying to build GHC on a hardened system and I keep getting linker errors
15:56:20 <japesinator> http://pastebin.com/M9nGNaz2
15:56:24 <japesinator> what should I do about this?
15:56:26 <puregreen> or if you import text-all you'll get lots of stuff at once
15:56:35 <puregreen> (shameless plug)
15:57:13 <jle`> such shamelessness
15:57:18 <lethjakman> Lol. 
15:57:22 <lethjakman> Excellent to know. 
15:57:26 <lethjakman> Yet...none of these are related, right?
15:57:37 <lethjakman> Why isn't text in prelude?
15:57:41 <jle`> they're all provided by the 'text' package
15:57:46 <jle`> the text package provides a bunch of modules :)
15:57:52 <jle`> @hackage text
15:57:52 <lambdabot> http://hackage.haskell.org/package/text
15:58:09 * hackagebot shakespeare-sass 0.1.0.3 - SASS support for Shakespeare and Yesod  https://hackage.haskell.org/package/shakespeare-sass-0.1.0.3 (brcha)
15:58:47 <jle`> not quite sure if there is any big reason to keep 'text' from being in base/the core language other than keeping the core language clean i guess
16:01:42 <maerwald> jle`: it also slows down development, sort of, because you don't just update "base"
16:02:31 <jle`> true, but active libraries like binary, containers are also tied to base/are included in ghc
16:02:45 <jle`> so they are updated at the same rate
16:03:42 <maerwald> I wouldn't say thery are tied to base, unless your package depends on ghc directly you can still have a different local version
16:04:27 <maerwald> so it's more flexible
16:05:01 <jle`> oh, this must be a misunderstanding on my part :)
16:08:06 <wagle> howcome ghc 8 doesnt come as an .app for macos?  (curious)
16:10:34 <hexagoxel> to be fair, cabal won't install a newer version of a boot library unless you force it to (e.g. when installing dependencies).
16:11:52 <schell> wagle: i’m sure at some point it will be (https://ghcformacosx.github.io/)
16:12:40 <wagle> schell: ah ok..  thought there might be a reason other than ... an ... nonstrictness
16:12:48 <hexagoxel> so jle` might be correct in that boot library versions are adapted slower than other libs.
16:12:52 <wagle> schell: ah ok..  thought there might be a reason other than ... ah ... nonstrictness
16:13:05 <wagle> ls
16:13:56 <hexagoxel> (i wonder if cabal could be convinced to not use a globally installed lib if that version was disabled via hackage constraints. it.. might work.)
16:14:40 <wagle> oh wow, ghc8 is bare bones
16:15:06 <schell> wagle: what do you mean by that?
16:15:23 <wagle> install it, and there's not even cabal
16:15:31 <wagle> just joking, sorry
16:24:10 <wagle> the installation method changes each time, so that I have the remnants of 3 versions
16:24:20 * wagle fixes that
16:27:45 <wagle> the light bu;bs turn on
16:27:49 <wagle> bulbs
16:28:10 * hackagebot murmur3 1.0.2 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm.  https://hackage.haskell.org/package/murmur3-1.0.2 (PhilippeLaprade)
16:28:44 <buglebudabey> does anyone know how to parse a lisp list with happy?
16:30:02 <wagle> in detail, yes, but dont know happy at all
16:30:40 <wagle> .. so there might be questions I can answer
16:31:47 <fishythefish> In McBride's work on derivatives of regular datatypes, is it "just" coincidence that the structural recursion agrees with the product rule, chain rule, etc. of mathematical derivatives or is there a deeper reason this should be true?
16:32:08 <fishythefish> Like a connection to, say, the limit definition of a derivative
16:35:57 <ExcaliburZero> Is there anywhere, other than a general search engine, that I can reliably look up language extensions to find out information on what they do?
16:36:12 <glguy> ExcaliburZero: GHC User's Guide
16:36:32 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html
16:38:30 <ExcaliburZero> Thanks!
16:43:11 * hackagebot mellon-core 0.7.0.1 - Control physical access devices  https://hackage.haskell.org/package/mellon-core-0.7.0.1 (dhess)
16:45:29 <wagle> fishythefish: I think its deep, but I've only seen glimmers so far
16:46:41 <fishythefish> wagle: I'd be interested in any insight you have.
16:47:57 <cdsmith> fishythefish: I think it would be more accurate to say that derivatives are only one example of a class of systems that satisfy those kinds of equations.  See https://en.wikipedia.org/wiki/Derivation_(differential_algebra)
16:48:11 * hackagebot mellon-gpio 0.7.0.1 - GPIO support for mellon  https://hackage.haskell.org/package/mellon-gpio-0.7.0.1 (dhess)
16:48:13 * hackagebot mellon-web 0.7.0.1 - A REST web service for Mellon controllers  https://hackage.haskell.org/package/mellon-web-0.7.0.1 (dhess)
16:48:36 <fishythefish> cdsmith: oh, that's a useful way of looking at it
16:49:12 <fishythefish> Actually, I much prefer that way of thinking
17:12:00 <haskell_question> hello
17:12:13 <Koterpillar> haskell_question: hello! ask it :)
17:12:38 <haskell_question> commonWords :: Int -> [Char] -> [Char]
17:12:43 <haskell_question> doen't work
17:12:47 <haskell_question> i'm following a tutorial
17:12:55 <Koterpillar> haskell_question: what do you expect it to do? link to tutorial?
17:13:21 <haskell_question> <interactive>:4:1: error:     Variable not in scope: commonWords :: Int -> [Char] -> [Char]
17:13:32 <fishythefish> Where is commonWords defined?
17:14:02 <haskell_question>  im in interactive mode ghci
17:14:04 <glguy> haskell_question: to be clear, you can't write Haskell code into GHCi the same way you would write it in a file
17:14:09 <haskell_question> ok
17:14:12 <haskell_question> i see
17:14:17 <haskell_question> that makes sense
17:14:22 <haskell_question> much appreciated!!
17:14:25 <fishythefish> Ah, yeah, you can't directly type `commonWords :: Int -> [Char] -> [Char]` into ghci
17:14:39 <glguy> haskell_question: The best way to go is to have your editor open in one window, and ghci open in another with the file loaded
17:14:43 <haskell_question> thanks
17:14:48 <glguy> haskell_question: then you can reload ghci with  :r
17:14:51 <haskell_question> great help
17:14:54 <haskell_question> much appreciated
17:20:38 <monochrom> programming in a REPL does not scale.
17:21:08 <monochrom> I don't understand why programmers don't grok this.
17:21:45 <maerwald> you mean you need that functionality in your editor?
17:21:50 <monochrom> you never make typos? you never make typos that you won't notice until 100 lines later? you never need to go back and edit something 100 lines ago?
17:22:21 <Koterpillar> monochrom: jupyter
17:22:24 <simpson> Languages that have compilation models that forbid REPLs are disappointing, but they've been around for a while, so it's not a big deal.
17:22:36 <monochrom> I haven't even seen a programmer who can type in 10 lines of code correctly blindfolded
17:23:19 <maerwald> it happened to me once and I was spending half an hour to figure out why it was correct :D
17:23:29 <monochrom> heh
17:23:30 <maerwald> cause I didn't believe it
17:24:03 <monochrom> anyway, if you enjoy programming at the REPL prompt, I recommend the editor "ed" to you.
17:24:15 <fishythefish> monochrom: coding over shaky SSH has turned out to be good practice for blind programming :)
17:24:20 <monochrom> in fact, "cat" may be even better
17:24:38 <maerwald> only if you've written your own cat in Assembly
17:24:39 <monochrom> "cat >> myfile.hs"
17:24:54 <Koterpillar> monochrom: ghc <(cat)
17:25:26 <monochrom> I don't think ghc actually cares about stdin
17:25:45 <fishythefish> That's not stdin, that's process substitution, yeah?
17:25:48 <monochrom> but you can always create a named pipe
17:25:50 <Koterpillar> fishythefish: correct
17:26:23 <Koterpillar> monochrom: it's Bash for named pipe
17:27:33 <monochrom> unfortunately ghc cares about filename suffixes
17:28:12 * hackagebot fbmessenger-api 0.1.1.0 - High-level bindings to Facebook Messenger Platform API  https://hackage.haskell.org/package/fbmessenger-api-0.1.1.0 (mseri)
17:28:42 <monochrom> but nice
17:38:13 * hackagebot Plot-ho-matic 0.9.0.10 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.9.0.10 (GregHorn)
17:39:15 * hpc can imagine "plot-ho-matic" being a lyric of daft punk's technologic song
17:54:47 <S11001001> @remember monochrom anyway, if you enjoy programming at the REPL prompt, I recommend the editor "ed" to you.
17:54:47 <lambdabot> I will remember.
17:55:44 * koz_ is thrilled by Haskell's parallelism now.
17:55:55 <koz_> Although I am *less* thrilled with how much memory Threadscope needs.
17:58:36 <Axman6> I've never had threadscope not crash on OS X, which is really disappointing
18:00:37 <koz_> Axman6: On my GNU/Linux machine, it eats *all the RAM*, but doesn't crash.
18:01:08 <koz_> (geez, and I though 8G would be enough for dev work)
18:02:28 <koz_> Although maybe I should just upgrade my laptop to 16G already.
18:02:30 * koz_ isn't sure.
18:05:54 <Axman6> koz_: I wish I had 32GB for a lot of the work I do - was hoping Apple would announce new macbook pros so I could get one, but sadly not
18:06:19 <geekosaur> they'll only do that when you need 32GB to boot >.>
18:07:45 <koz_> Axman6: What do you need that much for? Virtualization?
18:09:41 <Axman6> yeah
18:09:57 <koz_> Axman6: Yeah, in that case, fair enough.
18:09:59 <Axman6> running the one VM I use a lot needs 6GB
18:10:39 <mgsloan> I had 32gb, but then I started getting rare "strange closure type" errors.  Ran memtest and turns out it was very rare memory corruption :|
18:10:47 <Axman6> and atom needs like 39GB RAM
18:10:51 <koz_> mgsloan: Just lucky, I guess. :P
18:10:52 <mgsloan> Now putzing along with 8gb
18:11:03 <Axman6> :(
18:11:08 <koz_> Axman6: Atom is basically an awful, slow reimplementation of about 0.1 Emacs. :P
18:11:20 <koz_> (or at least, that's my humble opinion)
18:11:26 <mgsloan> The GHC garbage collector is actually really great at detecting rare memory corruption
18:11:35 <mgsloan> ... and giving a head scratcher of an error about it :)
18:11:47 <koz_> mgsloan: It's funny that you need to rely on a *language tool* to detect hardware problems. :P
18:12:03 <koz_> (and the fact that it's actually better than tools supposedly designed for said detection)
18:12:59 <mgsloan> Ooh, it would be cool if that error would do a little memtest of the incorrect byte
18:13:13 <mgsloan> Check if there's a stuck bit or whatnot
18:13:48 <Axman6> koz_: it's pretty good for Haskell, but really it's an awful, slow implementation of sublime
18:13:51 <mgsloan> So that it could actually give the error "Hey your memory isn't behaving at address 0xcafe"
18:14:20 <hpc> is sublime the one you have to pay for?
18:14:57 <hpc> ah, it's nagware
18:15:16 <mgsloan> Ja, really pretty / fast / well made nagware 
18:15:20 * geekosaur is actually not surprised ghc detects memory errors better than dedicated tools
18:15:44 * koz_ just uses Emacs.
18:15:48 <geekosaur> they usually show up with particular access patterns, and no tool ever manages to reproduce the kinds of access patterns needed reliably
18:15:50 <koz_> It does everything I need it to do, and is plenty fast.
18:16:12 <mgsloan> Yeah I use Emacs too, but I still miss some aspects of Sublime 
18:16:13 <geekosaur> they try hard but they work best when a memory problem has gone from "weird sporadic program failure" to something more consistent
18:16:43 <koz_> Hmm, why oh why is this parallel program not getting any faster...
18:17:36 <hpc> geekosaur: i assume it's the extremely unusual nature of boxes/thunks that makes you say that?
18:17:49 <geekosaur> no, this is a general thing, not specific to ghc
18:18:20 <mgsloan> The GC regularly sanity checking parts of thunks is what gives this property
18:18:21 <geekosaur> actual programs always produce more kinds of bit patterns and access patterns than any memory testing program can
18:18:49 <mgsloan> Interesting!  That's somewhat terrifying that you can have memory corruption which goes undetected by memtest
18:18:50 * geekosaur used to see this with RDBMS engines >.>
18:19:03 <hpc> oh i bet that was a nightmare
18:19:30 <mgsloan> After this I was wondering if you could have a compiler flag that built a version of programs that did auto error correcting
18:19:47 <mgsloan> Increase memory 2 or 3 x and use redundancy
18:19:51 <geekosaur> anyway the hardware folks will tell you not to trust memtest, if you're getting that kind of oddness go directly to a hardware memory tester that can look for e.g. voltage out of spec that will work 99% of the time and then give you a sporadic fail that a memtest will miss
18:20:16 <mgsloan> Seems like you'd "just" need to make all the spots that do load / store and multiplex them 
18:20:50 <geekosaur> it's not just supporting themselves, memory testing software just can't reliably trigger the fun ways that memory hardware actually fails in practice
18:21:31 <geekosaur> unless it is a hard error (bit 100% reproducibly out)
18:23:10 <mgsloan> Right!  This definitely wasn't a hard error.  A very specific bit in the aligned groups would get set to 1 on read.  This happened at a range of near memory addresses, on just 2 of the memtest passes
18:25:01 <geekosaur> yep, that's the kind of thing you see once it reaches the point it shows in memtest. hardware test will likely tell you there's a bit of signal leakage in that case, so a 0 gets pushed just high enough to look like a 1
18:53:08 <koz_> If I wanted to write zip using the stuff in Control.Parallel.Strategies, how would I?
18:53:20 <koz_> (like, I wanna do a parallel zip with a strategy parameter)
19:20:32 <cool> Hi all
19:21:35 <koz_> oxBAB: Hihi.
19:21:40 <koz_> Goddamn it... :(
19:22:17 <pavonia> Too slow
19:22:40 <tempeh> Anyone familiar with extensible-effects? I can't get anything with the type signature "(Member (State a) r) => Eff r ()" to compile
19:23:03 <koz_> pavonia: Not everyone has your lightning-fast fingers.
19:23:05 <tempeh> or anything that includes a type variable in the state variable type
19:23:56 <pavonia> koz_: My typing is pretty slow actually :p
19:25:33 <koz_> pavonia: Very fast reading/response then? I dunno - I'm typing (and checking in) on here while I wait for my profiling code to run between tweaks.
19:26:47 <pavonia> tempeh: Do you have a sample?
19:26:52 <Ralith_> tempeh: I've never actually used it, but I'm given to understand that one of the tradeoffs it makes is that you have to explicitly annotate a lot of subexpressions
19:27:10 <tempeh> (Typeable e, Member (State e) r) => Eff r e compiles but (Typeable e, Member (State e) r) => Eff r () doesn't.. wat
19:28:13 <tempeh> When I don't include the typeable constaint, I get something about unsafe overlapping instances
19:28:23 <pavonia> tempeh: So that won't compile even if the function definition is undefined?
19:28:34 <tempeh> when I including typeable, it gives me     Could not deduce (Typeable e0) from the context (Typeable e, Member (State e) r)
19:28:50 <tempeh> pavonia: Yep the definition is undefined
19:29:42 <lpaste> tempeh pasted “extensible-effects-wat” at http://lpaste.net/166022
19:31:04 <geekosaur> it can't determine what e is from the information you gavce it
19:31:13 <lpaste> tempeh pasted “extensible-effects-wat-error” at http://lpaste.net/166023
19:31:49 <tempeh> geekosaur: doesn't it just require typeable?
19:33:04 <geekosaur> no? type variables still have to make sense. there is no way for it to ever fix an actual type for e in the type checker, because e is not used, therefore it can never match any use site --- which is essentially what the type error is telling you, by using a new type variable e0
19:33:43 <geekosaur> Typeable is *runtime*, this needs to be able to figure out something about "e" at *compile time*
19:34:23 <tempeh> geekosaur: so the e needs to appear on the right side of the =>?
19:34:27 <geekosaur> yes
19:34:41 <geekosaur> in fact I'm a little surprised you don't get that error message
19:34:54 <tempeh> geekosaur: I see, thanks for the explaination - but that's a bummer, any way around it?
19:34:56 <geekosaur> ghc used to tell you about that
19:35:38 <geekosaur> I can't think of one, but it's a bit late here and I'm far from a type wizard :/
19:36:00 <geekosaur> if nobody's around here that can help, maybe ask on SO
19:36:15 <tempeh> I could maybe use Eff (State e :> r) () instead, but that's also a bummer semantic change
19:36:40 <tempeh> thanks for your help geekosaur, thanks everyone who looked at it
20:07:52 <roconnor> I'm trying out lens-family for the first time.  It's pretty nice.  Need's a stock traversal for the head of a list though.
20:18:33 <c_wraith> roconnor: and it needs a...  wait, once you get all of the things it needs, you're back to the lens situation it is attempting to avoid. :)
20:27:27 <gabbiel> @src cycle
20:27:27 <lambdabot> cycle [] = undefined
20:27:27 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:29:39 <gabbiel> confusing defnition
20:30:05 <glguy> What part is confusing you?
20:30:05 <jle`> gabbiel: just think about the 1st, 2nd, third, etc. element
20:30:17 <jle`> it's actually a common pattern, to help with sharing :)
20:30:30 <jle`> @src fix
20:30:30 <lambdabot> fix f = let x = f x in x
20:30:52 <jle`> the straightforward definition would be fix f = f (fix f)
20:31:10 <jle`> but doing it like this lets you share more
20:31:12 <gabbiel> its defined in terms of itself, pretty hard to visuzlize at sight
20:31:35 <jle`> gabbiel: you'll get used to it :)
20:31:39 <jle`> recursive functions are tricky at first
20:31:42 <glguy> Have you seen the slightly simpler:
20:31:46 <glguy> > let xs = 1 : xs in xs
20:31:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:31:55 <jle`> but i think they can be actually more natural than imperative definitions in a lot of cases
20:32:00 <jle`> map f [] = []
20:32:06 <jle`> map f (x:xs) = f x : map f xs
20:32:17 <Zemyla> Why is the type of <|> not something like (<|>) :: (Alternative f) => f a -> f b -> f (Either a b)?
20:32:19 <gabbiel> let ys = 1 : ys
20:32:25 <gabbiel> > ys
20:32:28 <lambdabot>      Not in scope: ‘ys’
20:32:28 <lambdabot>      Perhaps you meant one of these:
20:32:28 <lambdabot>        ‘y’ (imported from Debug.SimpleReflect),
20:32:34 <jle`> Zemyla: wouldn't make a monoid
20:32:45 <jle`> so you can't really chain/reassociate them
20:33:13 <jle`> it's also not clear what the identity would be
20:33:31 <jle`> oh i guess the identity would make sense
20:33:41 <Zemyla> jle`: empty :: (Alternative f) => f Void
20:33:49 <jle`> yea :)
20:33:57 <jle`> but still, having <|> be monoidal is pretty useful
20:34:05 <jle`> for reassociativity, being able to chain it, etc.
20:34:19 <gabbiel> what is the purpose of arrows
20:34:29 <glguy> :t \x y -> Left <$> x <|> Right <$> y
20:34:31 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
20:34:44 <jle`> gabbiel: it's hard to say anything about arrows in general
20:34:54 <jle`> do you mean about specific arrows, or about having a polymorphic Arrow interface?
20:35:13 <gabbiel> im not familiar with arrows, I just want to know a general purpose
20:35:37 <Zemyla> jle`: It also feels like it would go better with the formulation of Applicative as having unit :: f () and (<,>) :: f a -> f b -> f (a, b).
20:36:14 <gabbiel> too much to learn, one life. if only I knew what Lens, Arrows, and a million other libraries were made for
20:36:17 <jle`> gabbiel: i'm not sure there is really a general high-level purpose except something handwavey like to represent chaining computations
20:36:28 <jle`> but, i can tell you about specific Arrow instances
20:36:41 <jle`> and why they're useful
20:36:55 <gabbiel> where do I learn about this stuff, is there a book. or do you read academic papers
20:37:01 <jle`> mostly blog posts
20:37:03 <glguy> gabbiel: If you have to pick something to spend time learning, Arrows can be a lower priority
20:37:19 <jle`> yeah, you won't get much return from learning "about arrows"
20:37:21 <glguy> (regarding arrows, lenses, and millions of libraries)
20:37:34 <jle`> but then again you won't get much return from learning "about monads" either
20:38:02 <jle`> i'm not sure it's useful to go after learning a haskell concept just for the sake of knowing it.  i've only been able to learn what i know becuase i've been forced to use it :)
20:38:05 <MP2E> hmm could anyone help me with this error message? http://lpaste.net/166024 I'm just curious as to what could be causing it
20:38:05 <gabbiel> whats the best return?, aka, what do I learn instead
20:38:14 <jle`> it depends on what you need or want to do :)
20:38:25 <MP2E> my theory is that i'm using mingw-w64 compiled libraries in a haskell library, and it's blowing up in my face by using the in-place mingw toolchain ghc carries around
20:38:32 <MP2E> dunno if that's true though
20:38:39 <MP2E> or if so, how I can even fix this
20:38:49 <Zemyla> Also, actually, this typing could help differentiate between Alternatives with f a -> f b -> f (Either a b) and Alternatives with f a -> f b -> f (These a b).
20:38:49 <gabbiel> ok, what about compression, I want to get into that, unless its stale
20:39:02 <gabbiel> but then, thats not haskell specific
20:39:04 <gabbiel> nvm
20:39:09 <Zemyla> Where data These a b = This a | That b | These a b.
20:41:19 <gabbiel> where's jle, he actually seems like a cool guy
20:41:49 <toph> is there a way to map over one specific element of a list?
20:42:03 <jle`> toph: the lens library has some combinators for this :)
20:42:05 <gabbiel> u have to know its element
20:42:13 <gabbiel> *elemnt position
20:42:14 <jle`> > over (ix 3) (*2) [1..10]
20:42:17 <lambdabot>  [1,2,3,8,5,6,7,8,9,10]
20:42:43 <gabbiel> toph: map f . filter (==element)
20:43:13 <tempeh> that won't give the list back though gabbiel
20:43:14 <toph> gabbiel: yes i know the index, i just want to modify element 1 in a 3-element list
20:43:29 <toph> sounds like what jle` linked to will do it :)
20:43:55 <jle`> > over _head negate [1..10]
20:43:56 <gabbiel> toph: then just f (list !! element_index)
20:43:57 <lambdabot>  [-1,2,3,4,5,6,7,8,9,10]
20:44:25 <glguy> gabbiel: No, that also loses the list
20:44:55 <qinusty> Can anyone give me a simplified explanation to how to handle IO when it comes to performing non IO functions on IO variables?
20:45:13 <jle`> qinusty: you can use 'fmap' to map over the results of IO actions
20:45:29 <glguy> qinusty: What do you mean when you say "IO variable"?
20:45:31 <jle`> `fmap length getLine` :: IO Int, will be an IO action that gets a line from stdin and returns its length
20:45:58 <tempeh> or "bind" the value in a do expression and then operate on it
20:47:00 <qinusty> Well I have an IO ByteString and I am trying to convert it to Text using Data.Text.decodeUtf8
20:47:51 <jle`> fmap Data.Text.decudeUtf8 :: IO ByteString -> IO Text
20:48:03 <glguy> qinusty: You can name the result of executing your operation with do-notation
20:48:13 <glguy> do someByteString <- yourOperation;
20:56:35 <qinusty> So if I have do-notation within a function I cannot return anything non IO though, correct?
20:56:57 <shachaf> Not correct.
20:57:04 <koz_> qinusty: Not necessarily - it depends on whether you have the IO monad involved.
20:57:10 <koz_> Do-notation is not IO-specific.
20:57:49 <qinusty> Yeah unfortunately I do :/ I understand the concept of Pure programming, it's just not really something I'm too used to. 
20:58:21 * hackagebot hipchat-hs 0.0.4 - Hipchat API bindings in Haskell  https://hackage.haskell.org/package/hipchat-hs-0.0.4 (oswynb)
20:59:25 <Koterpillar> qinusty: do-notation is just syntactic sugar, it won't let you do anything you're not able to otherwise.
20:59:39 <jle`> qinusty: yeah, the idea about do notation with IO is that you're *describing* an IO action
20:59:46 <jle`> you're not exactly 'doing' IO action
21:00:04 <jle`> if you're specifying an IO Int, that means that you're describing how to create an IO Int
21:00:05 <koz_> With parallel GC work balance, is 60-odd percent halfway-decent? If not, what does this indicate and how would I go about improving it?
21:00:09 <qinusty> Yeah, I'm just trying to figure out a way around handling IO without it being too messy
21:01:10 <mjrosenb> I'm guessing that with a Chan a, there is no way of getting its current contents without altering them?
21:02:12 <EvanR> mjrosenb: this is one case where TChan is better, peekTChan 
21:02:12 <jle`> qinusty: yeah, using a combination of do notation and fmap (or its infix alias <$>) usually helps
21:02:54 <mjrosenb> EvanR: that looks like it only gets one element
21:03:01 <jle`> mjrosenb: yeah, chans aren't really too sophisticated
21:03:12 <mjrosenb> I want to get everything that is pending.
21:03:26 <EvanR> without taking it?
21:03:33 <EvanR> you could dup the chan
21:03:35 <mjrosenb> correct.
21:03:49 <qinusty> 5am Haskell may not be the best idea but I've committed now so I might aswell continue
21:04:06 <koz_> qinusty: 5am Haskell is the *best* idea.
21:04:18 <jle`> haskell is the only language i feel confident enough to write at 5am heh
21:04:27 <EvanR> at 5am... it might as well be your only idea
21:04:35 <EvanR> no use in going to sleep 
21:04:56 <qinusty> I haven't touched Haskell since January when my Haskell module finished. We barely touched on IO and Monads so it wasn't the most informative module
21:05:23 <EvanR> are you following a guide?
21:05:37 <qinusty> Ummmmmmmm, I should be 
21:05:46 <mjrosenb> 5am haskell, where all variables, type variables, constructors and type constructors have names like 'blerg' 'thingie' 'voorwerp'
21:06:01 <qinusty> Currently I'm going off my knowledge from my course and the learn you a haskell book I have next to me
21:06:05 <qinusty> oh and IRC
21:06:30 <qinusty> Using my usual learn a language technique of picking a useless project and making it 
21:07:25 <EvanR> LYAH at 5am...
21:08:05 <koz_> Could someone remind me what the -N run-time option does if *not* given a number?
21:08:18 <koz_> Because from where I'm standing, it seems to be 'only use one core'.
21:09:09 <nshepperd> oh sweet, Arch stealth upgraded to ghc-8.0.1
21:09:22 <koz_> nshepperd: Oh, I see you got caught by that one too... :P
21:09:28 <Koterpillar> nshepperd: and you only have yourself to blame
21:09:36 <Koterpillar> like always with Arch :(
21:09:42 <Cale> koz_: It's supposed to let the RTS choose the number of capabilities based on the number of cores.
21:09:53 <Koterpillar> btw, it wasn't exactly stealth with all new haskell-*
21:10:02 <koz_> Cale: I guess it thinks my machine is too weedy for more than 1. :P
21:10:04 <nshepperd> are you kidding, this is the best ever :D
21:10:18 <nshepperd> ApplicativeDo, yessss
21:11:12 <mjrosenb> EvanR: a duplicated chanel starts out empty.
21:11:19 <qinusty> Is there any way to iteratably (Might not be a word, 5am bleh) use the <- operator within a do block?
21:11:35 <Koterpillar> qinusty: foldM?
21:11:38 <Koterpillar> :t foldM
21:11:39 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
21:11:44 <nshepperd> Koterpillar: heh, lucky for me I don't use any of the haskell- packages, only cabal
21:11:52 <koz_> qinusty: Are you trying to grab each element of a list or something?
21:12:13 <qinusty> Um, I have a list of names, and I'm counting occurances within an IO ByteString
21:12:41 <Koterpillar> qinusty: you can't "count occurrences" within an "IO ByteString"
21:12:44 <mjrosenb> qinusty: sounds like you want a let, along with a non-IO function.
21:12:46 <qinusty> Well, actually the <- is needed for getting the [IO ByteString]
21:12:47 <EvanR> mjrosenb: hm. then this seems like the wrong use for channels... you can make a new concurrency thing that lets you view the whole queue
21:12:49 <jle`> qinusty: mapM?
21:12:53 <Koterpillar> qinusty: mapM, forM
21:13:05 <jle`> :t mapM
21:13:07 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
21:13:16 <qinusty> I am terrible at explaining right now :L Thanks for putting up with me 
21:13:17 <jle`> mapM :: (a -> m b) -> [a] -> m [b]
21:13:26 <Koterpillar> qinusty: make a function to count occurrences in a ByteString
21:13:33 <Koterpillar> qinusty: you don't need IO for that
21:13:35 <mjrosenb> EvanR: yeah, that's where I'm going next.
21:13:37 <qinusty> I have but its already IO
21:13:42 <qinusty> its from an rss
21:13:55 <Koterpillar> qinusty: you can call that function
21:14:27 <mjrosenb> EvanR: I guess I'll look at the chan code to see how they implemented it, then add one or two things on top of what's there.
21:14:33 <Koterpillar> qinusty: if you want [IO a] -> IO [a], that's mapM as jle` said
21:15:58 <jle`> or sequence
21:16:07 <glguy> qinusty: You can still write a pure function (ByteString -> NameCounts) and combine that with your rss IO ByteString to get an IO NameCounts
21:32:45 <qinusty> Can anyone explain a Lazy ByteString to me? 
21:37:21 <pavonia> It's basically a lazily evaluated list of byte chunks, AFAIK
21:38:14 <Axman6> @src L.ByteString
21:38:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:38:17 <Axman6> :(
21:38:41 <Axman6> yeah it's basically a spoecialised [Strict.ByteString] which unpacks the strict bytestrings into the cons cells
21:40:40 <Cale> and then on top of that, there's a bunch of stream fusion trickery to avoid intermediate bytestrings when you have a nice composite of ByteString -> ByteString functions which act on them
21:44:03 <mjrosenb> oh wow, Chans are implemented using 3 MVars?
21:49:07 <Cale> mjrosenb: Well, an arbitrary number, but a new empty channel uses 3, yeah
22:20:01 <mjrosenb> Cale: oh my, I don't understand how these work at all then
22:23:25 * hackagebot simple-sendfile 0.2.25 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.25 (KazuYamamoto)
22:26:17 <lpaste> koz_ pasted “Some optimization questions” at http://lpaste.net/166025
22:29:19 <kadoban> koz_: Something about building up the cov list just to M.fromList it seems wrong. Why not just build the Map as you go? (I have no idea what's actually causing any performance hit, yet … nor am I confident I can find it, but that stands out as a bit odd)
22:29:29 <qinusty> By the way guys, I got it working. Thanks for all the help, Sorry my brain wasn't very *functional* today
22:29:53 <Koterpillar> koz_: it seems the steps are independent, so you should be able to parallelize it
22:37:18 <koz_> kadoban: If I understand correctly, a Map insertion is O(log(n)), which makes O(n log (n)), but building a list then converting it is O(n) followed by O(n log (n)), and hence the same?
22:37:24 <koz_> Although I could try it.
22:37:36 <koz_> Koterpillar: I have no idea how to work with Maps using Control.Parallel stuffs.
22:46:38 <Koterpillar> koz_: you have fromList/toList at both ends though
22:49:36 <koz_> Koterpillar: This is true - I've just rewritten without using any intermediate list, and will see if it'll help.
22:50:24 <Squarism> how can i implement a show instance for all functions * -> MyType ?
22:51:23 <Squarism> it doesnt have to be nice
22:51:55 <Squarism> or output anything meaningful. Its just that i cant have types containing functions derive Show wo it
22:53:51 <Koterpillar> Squarism: FlexibleInstances?
22:58:15 <Squarism> yeah.. google hinted about that too
22:58:48 <Koterpillar> after setting that, I could just do "instance Show (a -> String) where show = undefined"
22:59:17 <Koterpillar> well, actually, I put error "here", that's how I verified it got called
23:01:49 <Squarism> Koterpillar, worked out fine!
23:01:52 <Squarism> Thanks
23:03:26 * hackagebot wai-app-file-cgi 3.1.2 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.2 (KazuYamamoto)
23:45:37 <koz_> If I wanna do stuff to a Data.Map.Map in parallel, do I basically have to use splitRoot, do whatever in parallel, then recombine?
23:58:28 * hackagebot sexp-grammar 1.2.0.1 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.2.0.1 (EugeneSmolanka)
