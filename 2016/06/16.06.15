00:00:33 <koz_> That actually makes sense now, kinda.
00:00:40 <koz_> But I *definitely* need to learn monad-loops.
00:00:46 <koz_> I get the feeling I'll be needing them.
00:02:21 <jle`> monad-loops is basically just a bunch of things like this that you could write yourself
00:02:38 <jle`> just as a canonical place for people to import them
00:02:44 <Koterpillar> "stdlib is basically a bunch of things that you could write yourself"
00:02:45 <jle`> you can think of it like a package of a bunch of left-pads
00:02:56 <koz_> Lol.
00:03:09 <jle`> Koterpillar: not quite, there are a lot of things in the standard libraries that are important to be standardized or that you can't really sensibly re-implement :)
00:03:26 <Koterpillar> right, jk
00:04:37 <jle`> i used to use monad-loops whenever i could but nowadays i just write the one-off definitions, heh
00:05:26 <jle`> btw if you want to use doNKeep with a large n, it pays to make your x accumulator strict
00:06:23 <jle`> or well, maybe doN w/out keeping is the more important one to make strict
00:06:29 <jle`> hm.  yeah, i think both cases it'd be nice.
00:06:33 <jle`> 'iterate' in Prelude has the same problem
00:06:52 <jle`> you'd wish that itereate f x !! 10000000 worked nice, but it doesn't really for a lot of cases
00:07:11 <jle`> but if you wrote a version of 'iterate' with a strict accumulator, iterate' f x !! 1000000 works just fine
00:07:22 <koz_> jle`: OK, will do.
00:07:33 <jle`> this is one of the small annoyances i have with the Prelude's iterate and/or !!
00:07:37 * hackagebot phone-metadata 0.0.1.0 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.0 (vijayanant)
00:07:37 * hackagebot eccrypto 0.0 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.0 (MarcelFourne)
00:08:35 <jle`> if we had a !! that forced values as it went along, then the classic 'fibs !! 10000000000' would actually work
00:08:59 <jle`> referring to fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
00:09:02 <jle`> that or a strict zipWith, heh
00:11:06 <Cale> You can also transform the list to make it work
00:11:53 <Cale> @let strictList [] = []; strictList (x:xs) = x : (x `seq` xs)
00:11:54 <lambdabot>  Defined.
00:12:10 <Cale> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
00:12:10 <jle`> that'd be nice too
00:12:11 <lambdabot>  Defined.
00:12:32 <Cale> > strictList fibs !! 1000000
00:12:35 <lambdabot>  *Exception: stack overflow
00:12:53 <jle`> hrm
00:12:55 <koz_> Lol @ Control.Monad.Extra.obvious
00:12:56 <Cale> Actually, that number is large enough that we probably can't compute it
00:13:23 <Koterpillar> Cale: won't that compute the list in memory?
00:13:37 <jle`> @let (x:_) !!! 0 = x; (x:xs) !!! n = x `seq` (xs !!! (n - 1))
00:13:38 <lambdabot>  Defined.
00:13:43 <jle`> > fibs !!! 1000000
00:13:44 <Cale> The cons cells aren't a big deal
00:13:47 <lambdabot>  mueval-core: Time limit exceeded
00:14:13 <jle`> > fibs !!! 100000
00:14:15 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
00:14:26 <Cale> > strictList fibs !! 100000
00:14:29 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
00:14:37 <jle`> :t fibs
00:14:41 <lambdabot> Num a => [a]
00:14:44 <Koterpillar> > fibs !! 100000
00:14:48 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
00:14:51 <Koterpillar> well
00:14:55 <jle`> well well
00:15:34 <jle`> > fibs !! 500000
00:15:36 <lambdabot>  *Exception: stack overflow
00:15:41 <jle`> > strictList fibs !! 500000
00:15:43 <lambdabot>  *Exception: stack overflow
00:15:48 <jle`> > fibs !!! 500000
00:15:52 <lambdabot>  mueval-core: Time limit exceeded
00:15:58 <jle`> hm
00:16:38 <Cale> strictList fibs !! 500000 works for me in ghci at least, but yeah, not enough time :P
00:16:59 <jle`> it looks like 250000 is just enough to test it in lambdabot
00:17:02 <jle`> > fibs !! 250000
00:17:04 <lambdabot>  *Exception: stack overflow
00:17:07 <jle`> > fibs !!! 250000
00:17:10 <lambdabot>  3635611701093956182642616417579843557747148441883530783506128097098561428526...
00:17:18 <jle`> > strictList fibs !! 250000
00:17:19 <lambdabot>  *Exception: stack overflow
00:17:21 <jle`> ah hah
00:17:30 <jle`> looks like strictList is a no-op
00:17:44 <jle`> hrm
00:18:11 <jle`> @let strictList' [] = []; strictList' (x:xs) = x `seq` (x : strictList' xs)
00:18:13 <lambdabot>  Defined.
00:18:19 <jle`> > strictList' fibs !! 250000
00:18:22 <lambdabot>  3635611701093956182642616417579843557747148441883530783506128097098561428526...
00:18:24 <jle`> heh
00:18:28 <Cale> It's not a no-op
00:18:39 <Cale> It's just slightly lazier than that version
00:18:45 <jle`> > strictList [undefined,undefined,1] !! 2
00:18:47 <lambdabot>  *Exception: Prelude.undefined
00:18:54 <Cale> It won't force the head until you force the tail of the list
00:19:00 <jle`> hm yeah, i guess it sits somewhere in between
00:25:50 <jle`> i don't think it'd be too big a deal if 'iterate' was made strict by default, or we always recommend the strict version
00:42:33 * hackagebot eccrypto 0.0.1 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.0.1 (MarcelFourne)
00:44:18 <koz_> OK, I *swear* I'm going insane.
00:44:32 <koz_> I checked out a git branch of an earlier version of my algorithm.
00:44:44 <koz_> I *profiled* that thing for *days*, and it had a runtime of ~30m.
00:44:51 <koz_> Now, *that same fucking thing* runs in ~7s.
00:44:56 <koz_> I... what.
00:44:59 <koz_> Am I insane?
00:47:33 * hackagebot docvim 0.3.1.1 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.1 (wincent)
00:48:10 <merijn> koz_: A little bit of operational knowledge about GHC goes a long way :)
00:48:43 <koz_> merijn: The thing is, I changed *literally* nothing since I last touched that branch.
00:48:49 <koz_> (which you helped me optimize)
00:48:54 <koz_> It *did not* run that fast.
00:49:00 <koz_> Not within an order of fucking magnitude.
00:49:36 <merijn> koz_: Did you test in ghci or compile?
00:49:42 <koz_> merijn: Compile with -O2
00:50:25 <merijn> koz_: Did you ever benchmark without the -O2 ?
00:50:31 <koz_> merijn: No, never.
00:50:51 <koz_> Unless I was a *lot* sleepier than I remember being.
00:50:52 <merijn> hmmm, odd
00:51:01 <koz_> It's completely inexplicable.
00:51:08 <merijn> koz_: The only thing I can think of is accidentally benchmarking an old binary lying around
00:51:20 <koz_> I cabal cleaned before, but that wouldn't have been that fast either.
00:51:27 <koz_> Nothing I test runs in less than ~5m.
00:51:32 <koz_> (or at least, until now...)
00:52:33 <koz_> Oh well, I'm just going to assume that St. IGNUcius decided my computer is blessed or somesuch.
00:52:33 <merijn> Not sure how to debug irreproducible "my performance sucked before but now doesn't" issues :p
00:52:50 <koz_> I'm not sure I can even summon an explanation beyond 'techno-magic pixies'.
00:59:39 <lemonxah> dont think i will understand monads till i just forget about them
00:59:46 <lemonxah> i am probably over thinking this a lot
01:02:04 <Cale> lemonxah: Probably the best way to understand what the monad abstraction is for, is to just understand a bunch of examples of it.
01:02:30 <lemonxah> yes but i am not finding examples really
01:03:04 <merijn> lemonxah: Maybe, list, either, parsers
01:03:08 <lemonxah> other than like Either Maybe and those but they make perfect sense i just cant seem to build my own
01:05:31 <lemonxah> just a question would you make a monad for a record type?
01:07:43 <lemonxah> data T = T ( name :: String, age :: Int }
01:07:50 <lemonxah> would you make monad instances for that?
01:07:54 <Cale> That's not the right kind of thing to be a monad
01:07:58 <lemonxah> ok
01:08:03 <lemonxah> this is making a lot more sense then
01:08:20 <Cale> Monads must have type parameters
01:08:42 <lemonxah> like data maybe a = Nothing | just a
01:08:46 <liste> lemonxah: try "data T a = T { name :: a, age :: Int }"
01:09:04 <lemonxah> so data T a = T { name :: a .. 
01:09:07 <lemonxah> that can be a monad?
01:09:17 <liste> lemonxah: yes
01:09:18 <Cale> It would be possible to define a valid monad instance for liste's type, but given the names, you probably wouldn't want one.
01:09:21 <lemonxah> but why would you make that a monad what benefit do you get from making it a monad?
01:09:36 <Cale> Well, you get all the operations in Control.Monad for a start
01:09:47 <Cale> Things like sequence :: (Monad m) => [m a] -> m [a]
01:10:13 <Cale> and  liftM2 :: (a -> b -> c) -> m a -> m b -> m c
01:10:27 <Cale> (Monad m) => ... of course
01:11:22 <lemonxah> but you have to make a sequence instance for your monad? or if the monad instance is properly implemented then sequence will just work?
01:11:44 <Cale> If you have a Monad instance, you get sequence and liftM2 and filterM and so on for free
01:11:51 <lemonxah> OH
01:11:55 <lemonxah> ok this makes sense
01:12:19 <liste> but you need to follow the monad laws for them to work correctly
01:12:30 <lemonxah> yeah ofc
01:12:36 <Cale> Also, you get that monad transformers work with your monad, and lots of other things...
01:12:41 <lemonxah> ok so this makes a LOT more sense
01:12:45 <sshine> otherwise, the monad police will come and knock at your door.
01:12:51 <lemonxah> i think i just had my aha moment
01:12:58 <lemonxah> and ofc i did over think this too much
01:13:20 <lemonxah> its just a pattern then when you follow it you get a bunch of functions to help you do things for free
01:13:24 <Cale> yep
01:13:40 <lemonxah> cause those functions are built with the understanding that this is just the contract of a monad
01:13:56 <Cale> It just turns out that a lot of useful control-structure-like operations can be implemented in terms of some return :: a -> m a and (>>=) :: m a -> (a -> m b) -> m b
01:14:07 <lemonxah> i was trying to understand this form an acedemic side
01:14:29 <lemonxah> like i have read its a monoid in endofunction terms
01:14:36 <lemonxah> but that makes zero sense to me
01:15:01 <Cale> Well, yeah, if you don't know what monoidal categories are all about, that definition isn't going to be helpful at all
01:15:07 <lemonxah> because i dont understand category theory .. i am too old to learn theory i find it extremely difficult
01:15:17 <merijn> lemonxah: I understand what "monoid in the category of endofunctors" means and that STILL doesn't make sense to me
01:15:18 <Cale> and it's not even the definition you'd come across first in category theory
01:15:20 <EvanR> lemonxah: that explanation was probably meant as a joke
01:15:39 <EvanR> and its not even funny
01:15:44 <lemonxah> ok good
01:15:51 <Cale> EvanR: It's not really a joke though
01:16:09 <lemonxah> like i understood most all the things about monads just lacked the why 
01:16:09 <EvanR> monads are "just" a monoid in some category of endofunctors
01:16:13 <merijn> lemonxah: Category theory is overrated as tool for learning haskell
01:16:13 <EvanR> whats the problem
01:16:43 <lemonxah> what is an endofunctor?
01:16:47 <tdammers> EvanR: the problem is that monads are monoids, but Monads aren't Monoids
01:16:47 <Cale> A monad on C really is a monoid object in the monoidal category of endofunctors C -> C, where the monoidal operation on objects is functor composition
01:16:58 <Cale> lemonxah: An endofunctor is a functor from a category to itself
01:17:12 <lemonxah> and a catergory is a type?
01:17:14 <lemonxah> like 
01:17:18 <lemonxah> Monad a
01:17:19 <merijn> lemonxah: The original monad paper by Wadler is pretty easy. It focusses solely on "hey! Look how this pattern appears in many different places!"
01:17:21 <lemonxah> a is the category?
01:17:22 <merijn> lemonxah: http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
01:17:47 <Cale> A category consists of a whole bunch of data... the definition is a bit of a mouthful, but the idea is that you're abstracting over what takes place in mathematics with sets and functions
01:17:57 <merijn> I wish more people just read the Wadler paper instead of terrible blog posts :\
01:18:39 <lemonxah> merijn i have seen this before but i am too stupid to understand it
01:18:54 <Cale> lemonxah: https://en.wikipedia.org/wiki/Category_(mathematics)#Definition
01:18:54 <lemonxah> <-- self taught programmer, did not have money to go to college
01:19:04 <lemonxah> so i have been winging it for the last 20 years
01:19:12 <lemonxah> and learning where i can and when its needed
01:19:24 <merijn> lemonxah: Have you read it? Most (all?) of that paper uses only very basic haskell
01:19:24 <Cale> ... I don't actually care for this particular presentation of the definition, but it's handy
01:19:34 <srhb> lemonxah: You can safely ignore category theory in Haskell. :-P
01:19:43 <merijn> srhb++
01:20:20 <shachaf> Other classes that represent a monoid in "the" category of endofunctors include Applicative and Alternative
01:20:23 <lemonxah> srhb i thought i needed to understand category theory to finally understand monads
01:20:36 <shachaf> In fact a MonadPlus is a monoid in three different categories of endofunctors.
01:20:36 <Cale> lemonxah: Only if you want to apply monads to other areas of mathematics
01:21:08 <Cale> lemonxah: The definition is actually much more general, and we've stomped on it and fit it into the confines of Haskell
01:21:14 <lemonxah> i feel a little less stupid now .. but i am still surrounded by you guys that make me feel like a newborn 
01:21:15 <lemonxah> lol
01:21:37 <lemonxah> so in haskell terminology 
01:21:49 <merijn> lemonxah: 5 years from now you'll still feel like that, 'cause I still do :p
01:21:52 <lemonxah> data Maybe a = Nothing | Just a
01:22:02 <lemonxah> that a is the category?
01:22:06 <Cale> no
01:22:09 <Cale> well...
01:22:15 <liste> lemonxah: it can go the other way too - for me it was easier to read about natural transformations, Yoneda etc. after learning the Haskell aspect of monads
01:22:17 <Cale> Yeah, in a sense :D
01:22:24 <Cale> It's an object in our category
01:22:43 <lemonxah> but lets say
01:22:46 <Cale> The category we're concerned with in Haskell has types as its objects, and functions between those types as the arrows
01:22:52 <lemonxah> the type of a is the category
01:23:06 <lemonxah> so Just "blah" would make my category String?
01:23:11 <lemonxah> and Just 5 would make it Int?
01:23:37 <srhb> lemonxah: For most intents and purposes there is one category in Haskell, loosely called Hask
01:23:38 <lemonxah> or Just MyType 
01:23:47 <srhb> lemonxah: And because there's only one, it conveys no meaning, and can safely be ignored.
01:23:58 <Cale> lemonxah: It's just one category we're concerned with in Haskell, pretty much
01:24:25 <EvanR> can safely be ignored, must be ignored
01:24:30 <Cale> (and even that is slightly mythical)
01:24:31 <lemonxah> ok and arrows are basically (a -> b) ?
01:24:40 <EvanR> since Monad, Category arent talking about Hask
01:24:47 <Cale> Yeah, the "objects" of our category are types
01:25:07 <mniip> well
01:25:13 <Cale> and given two types A and B the arrows A -> B are the (Haskell-definable) functions A -> B
01:25:23 <mniip> Category does talk about Hask
01:25:38 <mniip> the (*) (->) category is Hask
01:25:50 <Cale> Yeah, the Category type class is sort of a weird internalisation of what categories are
01:25:51 <EvanR> a type which is a Category isnt a category
01:26:13 <EvanR> in its own right, its inside haskell
01:26:43 <EvanR> Monad isnt talking about monoids in another category
01:26:54 <lemonxah> Haskell is a pure language but it has exceptions?
01:27:11 <tobiasBora> For people interested, my yesterday bug occurs because gnuplot cannot plot more than 2028 points (well at least before version 5.0pl4). If someone here developped gnuplot haskell, if would be great to write an error message more explicit :D
01:27:25 <mniip> lemonxah, exceptions are represented with bottoms
01:27:55 <mniip> or do you mean exceptions as in exceptions from the rule?
01:28:14 <lemonxah> as in runtime exceptions? like IO exceptions
01:28:27 <lemonxah> file doesn't exist or network connection refused
01:28:32 <mniip> EvanR, Idunno, if you declare a datakind, and then a dyadic datatype indexed by that kind
01:28:39 <mniip> I'm not sure how that would fit inside Hask
01:29:25 <EvanR> Hask is not well defined at least for that reason
01:29:38 <EvanR> i mean if you want it to coincide with actual haskell
01:30:22 <EvanR> lemonxah: IO exceptions actually make sense, since its an effect of the IO type
01:30:38 <lemonxah> sorry just one more question what is a kind and how does that relate to a type
01:30:58 <Cale> kinds are like the types of types
01:31:02 <EvanR> what doesnt fit nicely into that is that pure computations can freeze up or throw their own exceptions, "errors"
01:31:03 <Cale> :k Integer
01:31:04 <lambdabot> *
01:31:13 <Cale> * is the kind of all the ordinary types which have values
01:31:16 <Cale> :k Maybe
01:31:17 <lambdabot> * -> *
01:31:25 <cheater> hello
01:31:34 <Cale> You can see here that Maybe is a type which takes a type of kind * as an argument, and produces a type of kind *
01:31:52 <Cale> :k Maybe Integer
01:31:53 <lambdabot> *
01:31:58 <Cale> :k (->)
01:31:59 <lambdabot> * -> * -> *
01:32:00 <cheater> what does this syntax mean? x = y @Char @[] --- I don't understand why "@Char" makes sense here?
01:32:20 <Cale> cheater: That's the new explicit type application extension
01:32:56 <cheater> let me read about it
01:33:05 <Cale> cheater: y is something whose type is polymorphic, e.g. perhaps it has type  forall a f. a -> f a
01:33:18 <Cale> and this applies it with a = Char and f = []
01:33:27 <Cale> So it specialises to Char -> [Char]
01:33:46 <Cale> (if my example type were correct, at least)
01:33:55 <EvanR> lemonxah: any IO action has the possibility of failing (you described a few reasons), and you can also catch these exceptions for your own purposes with stuff in IO, also any computation of any sort can fail to evaluate to a defined value, such as let x = x in x, or error "this is impossible or a bug"
01:35:10 <EvanR> :t error
01:35:11 <lambdabot> [Char] -> a
01:35:28 <EvanR> with that type it cant possibly produce a value
01:35:32 <Cale> Since carrying out the effects described by IO actions is a separate process from evaluation, we don't worry about the fact that it's possible for IO actions to catch exceptions
01:36:03 <EvanR> practically you need to know about IO's ability to catch IO exceptions
01:36:38 <Cale> Most of the time, you only throw exceptions using the error function that you don't ever want to catch
01:36:55 <merijn> If you do wanna catch them you're boned anyway :p
01:36:57 <Cale> If you want to catch the exception later, throwIO is much better
01:36:58 <merijn> Because it's hard
01:37:13 <EvanR> right `error' is not for throwing catchable IO exceptions
01:37:17 <cheater> Cale: ok, so basically x is still completely unapplied, that is it takes two arguments, but now GHC knows what types those two arguments will have?
01:38:01 <Cale> cheater: You can imagine that all polymorphic functions really have secret hidden parameters which are the types to plug in for the type variables in their signature
01:38:36 <cheater> aha?
01:38:37 <Cale> cheater: and the @-prefixed types there fill in those formerly-invisible arguments which would normally be filled in by type inference
01:38:42 <cheater> gotcha
01:38:45 <cheater> :)
01:39:45 <cheater> can i partially apply those? can i apply those and normal arguments as well? can i fill those with lambdas?
01:46:39 <Squarism> if i wanna create a method signature matching a list parameter when its value is []
01:46:43 <Squarism> how do i write that?
01:52:44 <lyxia> Squarism: I don't understand.
01:52:47 <peddie> Squarism: [] is a value of type [a]; you can only put types in type signatures, not values
01:53:49 <Squarism> okey. So is there a type/pattern for the empty list?
01:54:10 <tdammers> there is a pattern, but not a type
01:54:25 <tdammers> an empty list is still a list of *something*
01:54:37 <tdammers> number-of-elements is a property of a list value, not a list type
01:54:38 <Squarism> what im talking about is: f :: [Int] -> Int  \n f [] = 2  \n f x:xs = 34
01:54:49 <tdammers> but element type is a property of the list type
01:55:13 <Squarism> okej so boolean guard is a better way
01:55:16 <tdammers> yes, almost, except that you need parentheses around (x:xs)
01:55:30 <tdammers> you can pattern-match on the empty list just fine, and it works exactly as you wrote
01:55:53 <tdammers> f :: [Int] -> Int; f [] = 2; f (x:xs) = 34
01:56:05 <peddie> Squarism: I'm sorry, when you said "signature" I thought you meant type signature
01:56:06 <Squarism> > f :: [Int] -> Int; f [] = 2; f (x:xs) = 34
01:56:08 <lambdabot>  <hint>:1:18: parse error on input ‚Äò;‚Äô
01:56:49 <Squarism> > let f :: [Int] -> Int; f [] = 2; f (x:xs) = 34
01:56:51 <lambdabot>  <no location info>:
01:56:51 <lambdabot>      not an expression: ‚Äòlet f :: [Int] -> Int; f [] = 2; f (x:xs) = 34‚Äô
01:56:57 <Hijiri> use @let for definitions like that
01:57:02 <Hijiri> @let f :: [Int] -> Int; f [] = 2; f (x:xs) = 34
01:57:03 <lambdabot>  .L.hs:167:3:
01:57:03 <lambdabot>      Couldn't match expected type ‚Äò[Int]‚Äô
01:57:03 <lambdabot>                  with actual type ‚Äò(Int, Int, Int)‚Äô
01:57:28 <Hijiri> maybe there is an existing f
01:57:29 <Hijiri> :t f
01:57:31 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
01:57:31 <lambdabot>     It could refer to either ‚ÄòL.f‚Äô,
01:57:31 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:165:1
01:57:36 <tdammers> > let f :: [Int] -> Int; f [] = 2; f (x:xs) = 34 in f []
01:57:37 <lambdabot>  2
01:57:44 <tdammers> > let f :: [Int] -> Int; f [] = 2; f (x:xs) = 34 in f [1,2,3]
01:57:45 <lambdabot>  34
01:58:16 <tdammers> note, however, that in this particular case, we can also:
01:58:20 <tdammers> > let f :: [a] -> Int; f [] = 2; f (x:xs) = 34 in f [1,2,3]
01:58:22 <lambdabot>  34
01:58:30 <tdammers> > let f :: [a] -> Int; f [] = 2; f (x:xs) = 34 in f ["a", "b", "c"]
01:58:32 <lambdabot>  34
01:58:41 <tdammers> however:
01:58:46 <tdammers> > let f :: [a] -> Int; f [] = 2; f (x:xs) = x in f ["a", "b", "c"]
01:58:48 <lambdabot>      Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äòa‚Äô
01:58:48 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
01:58:48 <lambdabot>            the type signature for f :: [a] -> Int at <interactive>:1:10
01:59:02 <tdammers> not sure if that's actually helpful
01:59:16 <Squarism> well.. you seem to be able to do what i want.
01:59:51 <tdammers> you try in lpaste (see /topic)
01:59:52 <Squarism> I get "duplicate type signatures" error when trying
02:00:03 <tdammers> definitely lpaste you code then
02:00:28 <Squarism> oh.. my bad
02:05:02 <SweetKatya> hi. I am looking for someone who writes parallel code. I still cannot understand what does the function named `inner` do?
02:09:09 <dcoutts> SweetKatya: 'inner' from which lib?
02:10:23 <SweetKatya> dcoutts, Control.Concurrent.Async
02:11:04 <dcoutts> SweetKatya: as in: 
02:11:04 <dcoutts> withAsync action inner = bracket (async action) cancel inner
02:11:05 <SweetKatya> and I am reading about it in the book "parallel and concurrent programming in haskell"
02:11:13 <SweetKatya> yes
02:11:29 <SweetKatya> also you will find it in the book examples
02:11:32 <dcoutts> SweetKatya: so there is no function called inner of course, it stands for your code that does something
02:12:29 <dcoutts> withAsync myAsyncThing $ \a -> do
02:12:31 <dcoutts>   ...
02:13:18 <SweetKatya> dcoutts, so you mean i have to write my own function in the place of "inner" ?
02:13:22 <dcoutts> yes
02:13:38 <dcoutts> like my little fragemen above using a lambda
02:13:45 <dcoutts> fragemen/fragment
02:13:54 <SweetKatya> yes I get it. now makes sense.
02:14:47 <dcoutts> SweetKatya: this pattern of withThing $ \thing -> ...   is very common, so it's useful to be able to spot it
02:14:54 <dcoutts> @type withFile
02:14:55 <lambdabot>     Not in scope: ‚ÄòwithFile‚Äô
02:14:55 <lambdabot>     Perhaps you meant one of these:
02:14:55 <lambdabot>       ‚ÄòwriteFile‚Äô (imported from Prelude),
02:15:37 <dcoutts> SweetKatya: e.g.  withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
02:15:58 <dcoutts> that (Handle -> IO r) bit is the same idea, some "inner" action that is given access to an additional resource
02:16:19 <dcoutts> what resource it is is different in different cases, and what extra args are needed to create the resource change
02:16:39 <dcoutts> but the ...  -> (SomeResource -> IO a) -> IO a    bit you'll see again and again
02:16:48 <dcoutts> and not just in IO, but other monads
02:16:52 <SweetKatya> ok got it. 
02:17:06 <SweetKatya> dcoutts, much like foldr. isn't?
02:17:25 <SweetKatya> sorta that
02:17:46 <dcoutts> SweetKatya: not really, both are higher order (a function that takes other functions), but they're being used for different purposes
02:17:57 <dcoutts> this pattern is the safe/scoped resource pattern
02:18:09 <SweetKatya> yes i know .. just i am pointing at the inner function only
02:18:46 <dcoutts> I don't think I'd draw too much of a connection with foldr
02:19:00 <SweetKatya> ok just forget it..
02:19:14 <dcoutts> SweetKatya: have fun with that book, it's really very good
02:21:35 <SweetKatya> dcoutts, I know.. I am teaching it to two Masters students
02:22:03 <SweetKatya> private tutoring
02:22:30 <dcoutts> oh cool
02:22:36 * hackagebot haskell-fake-user-agent 0.0.2 - Simple library for retrieving current user agent strings  https://hackage.haskell.org/package/haskell-fake-user-agent-0.0.2 (grzegorzgolda)
02:22:38 * hackagebot intero 0.1.15 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.15 (ChrisDone)
02:33:46 <Squarism> so "makeLenses" on operates on fields starting with "_" ?
02:38:06 <merijn> Squarism: By default, yes
02:38:11 <merijn> Squarism: You can use other functions to use something else
02:38:32 <Squarism> okey
02:51:41 <tero-> merijn: in the end I used MultiParamTypeClasses and FunctionalDependencies https://gist.github.com/tlaitinen/b37423c3c16b1c3590e78af603cfdc6b . this version allows also for database joins
02:56:56 <koz_> OK, this performance regression makes no sense.
03:00:27 <koz_> I have *the* weirdest performance regressions.
03:01:14 <koz_> I have two main functions - yesterday, main1 ran in ~3 minutes, and main2 in ~30. Now, main1 runs in ~1*h*, and main2 in ~7*s*. What is this I don't even.
03:09:25 <tsahyt> Hello. Can I somehow use profiling with a library that's been loaded dynamically from a C program?
03:15:11 <tsahyt> I guess it boils down to setting RTS options at compile time, or at runtime via the C interface
03:18:49 <lemonxah> hi
03:19:21 <lemonxah> is .. add :: Int -> (Int -> Int) the same as :: Int -> Int -> Int ?
03:19:39 <opqdonut> yes
03:20:10 <opqdonut> :t (+)
03:20:11 <lambdabot> Num a => a -> a -> a
03:20:16 <opqdonut> :t ((+) 1)
03:20:17 <lambdabot> Num a => a -> a
03:20:19 <opqdonut> :t ((+) 1) 2
03:20:20 <lambdabot> Num a => a
03:20:32 <opqdonut> you can partially apply functions
03:20:41 <opqdonut> i.e. just give them one argument
03:20:43 <lemonxah> ok so it is the same :)
03:20:44 <opqdonut> and get a function back
03:21:18 <opqdonut> technically there are only one-argument functions in haskell, and multi-argument functions are built up from them
03:24:08 <tsahyt> how can I tell cabal to build with some CPP option defined?
03:24:29 <dcoutts> tsahyt: cpp-options in the .cabal file is usually what you want
03:25:04 <tsahyt> dcoutts: But changing the cabal file every time I want a particular debug build seems somewhat unwieldy
03:25:36 <dcoutts> tsahyt: ah well in that case use --ghc-options= on the command line
03:26:05 <tsahyt> and then I'd just use -Dwhatever for the GHC options?
03:26:53 <tsahyt> Good, that works. Thanks!
03:27:37 <tsahyt> It's a bit of a hack but I've decided to just log all library calls that are made from C++ and replay them from a haskell executable to do proper profiling. I don't care how long the C++ side takes anyhow, I just need to assess the performance of my library
03:27:42 <Squarism> ive started out with lenses just yesterday. Here http://lpaste.net/166193 i have some code. I wonder, how would i remove an element in "ccc" when its =="Ba" ... /c/quux/ccc[=="Ba"]
03:27:52 <tsahyt> hence the conditional compilation. if enabled, log calls.
03:54:28 <akegalj> I would like to create phantom type `newtype Id a = Id String`, and that a is constrained only on Int, so: `newtype Id (a :: Int) = Id String`. Additionally I would like `Id 1` be different type then `Id 2`. As I understand I have to promote values to types here with DataKind or do I have to do some more work ?
04:02:39 * hackagebot bitx-bitcoin 0.9.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.9.0.0 (tebello_thejane)
04:03:19 <puregreen> akegalj: you need type-level naturals
04:03:39 <akegalj> puregreen: is there some extension for that ?
04:04:25 <puregreen> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html
04:04:49 <akegalj> puregreen: thanks a lot, will read that now
04:05:21 <lemonxah> so
04:05:37 <lemonxah> just as a final nail in my understanding of monad coffin
04:06:02 <lemonxah> could i have a Basket monad?
04:06:15 <lemonxah> i mean does a Basket make sense to be a monad?
04:06:49 <lemonxah> like data Basket a = Empty | Items a
04:07:53 <merijn> lemonxah: Basket is just identical to Maybe :)
04:07:58 <merijn> lemonxah: So yes
04:08:11 <lemonxah> how would you extend Basket to be more than just a Maybe
04:08:18 <lemonxah> just a simple example
04:08:33 <haskell654> Is Haskell a good main language to 'learn' for a new developer? They say you should focus on one lanuguage - would Haskell make sense for someone who wants to find a job/freelance work as a developer? Is there enough work to find, and is it a competitive space?
04:09:08 <lyxia> lemonxah: can you define functions return :: a -> Basket a and (>>=) :: Basket a -> (a -> Basket b) -> Basket b? Do they satisfy the monad laws?
04:10:33 <lemonxah> merijn, would you make a Basket monad or just use maybe?
04:10:57 <merijn> "It Depends (TM)"
04:11:18 <lemonxah> ok here is another thing i need the basket to be able to do
04:12:03 <lemonxah> lets say i want to do a getBasketValue on a Basket
04:12:19 <lemonxah> so all items in the Basket has to have a "value" field
04:12:23 <lemonxah> how would you do that?
04:13:33 <lemonxah> something like 
04:13:56 <merijn> I'm not sure how this relates to your earlier question?
04:14:30 <lemonxah> getValue :: ItemValue a => Basket a -> Float
04:14:43 <lemonxah> it doesn't relate sorry
04:14:48 <koz_> How can I check the biggest possible Int for my platform?
04:14:55 <hpc> > maxBound :: Int
04:14:57 <lambdabot>  9223372036854775807
04:19:05 <obadz> > maxBound :: Float
04:19:06 <lambdabot>      No instance for (Bounded Float) arising from a use of ‚ÄòmaxBound‚Äô
04:19:06 <lambdabot>      In the expression: maxBound :: Float
04:19:07 <obadz> ‚áí why?
04:19:27 <merijn> obadz: What should the maxBound be?
04:19:32 <merijn> obadz: Infinity?
04:19:48 <obadz> ah yes I forget it has infinity
04:19:59 <obadz> well yes I suppose that would be the maxBound
04:20:19 <obadz> I was thinking the highest possible mantissa/exponents
04:21:57 <koz_> OK, I think I've figured out wtf was going wrong...
04:22:01 * koz_ feels super-duper daft.
04:22:04 <koz_> Or at least *half* of it.
04:30:28 <lemonxah> i think the last thing i need to be able to start doing something usefull is just some help around a type class i think i need a typeclass for this but i am not sure
04:30:54 <lemonxah> lets say i have 
04:31:50 <lemonxah> data Basket a = Empty | Items a
04:32:12 <lemonxah> and i want all the a types to have some way of saying they have a value
04:32:27 <lemonxah> then i have to make a typeclass with a value function on it?
04:32:46 <lemonxah> lets say i have 1 item i want to sell and i want to put that into a basket and i call that ticket
04:33:08 <lemonxah> data Ticket = Ticket { seatno :: Int, value :: Float }
04:33:49 <lemonxah> then i have to make an instance of the value type class that takes ticket and returns value?
04:34:15 <lemonxah> and also one for a list of tickets since basket can also have a list of tickets that i am buying?
04:34:23 <lemonxah> is this the pattern that you would follow?
04:38:13 <lyxia> you could also factor the value out in the basket: Basket v a = Empty | Items a v
04:40:02 <lemonxah> hmm i dont understand that line yet
04:40:25 <lemonxah> oh have the value seperate
04:40:43 <lemonxah> and as you add items you also "update" the value of all the items?
04:41:06 <lemonxah> lyxia, is that what you mean with that factor the value out in the basket?
04:42:26 <lemonxah> but lets say data Ticket = Ticket { seatno :: Int, value :: Float -> Float -> Float }
04:42:50 <lemonxah> so that you take the base ticket value and add some organiser costs to it when you calculate it or .. blah
04:43:09 <lemonxah> so what i proposed isn't too bad?
04:50:29 <hjljo> if you tag your tickets with their value like (Value, Seat) then given a list of tickets [(Value, Seat)] you can squash that down to (Value, [Seat]) with sequenceA say, if Value is a monoid
04:50:42 <hjljo> no typeclasses required (unless you want them for some other purpose)
04:51:29 <lemonxah> yeah granted hjljo :) but i was kind of asking if that is the design pattern used for functional programming
04:51:36 <lemonxah> well not the only one
04:51:38 <lemonxah> but more is it a valid one
04:54:44 <lemonxah> i see DatatypeContexts doesn't work by default
04:55:04 <lyxia> lemonxah: oh right my solution doesn't work very well with updates
04:55:37 <lemonxah> i wanted to do data Value a ‚áí Basket a = Empty | Items a
04:55:55 <lemonxah> but it letss me to add {-# LANGUAGE DatatypeContexts #-}
04:56:00 <lemonxah> is that bad practice?
04:56:04 <merijn> Yes
04:56:10 <merijn> Because it doesn't do anything useful
04:56:18 <lemonxah> i dont want them to just put anything into the basket it has to be something that has the Value typeclass constraint
04:56:36 <lemonxah> i dont want a basket of Ints for example
04:57:39 <lemonxah> merijn, why doens't it do anything useful?
04:57:59 <lemonxah> doesn't it stop people from putting Ints or Strings into my Basket?
04:58:15 <lemonxah> and then i can reason that everything in my basket will have a value?
04:58:57 <lemonxah> or do i just trust that no one will use it that way?
05:00:04 <merijn> lemonxah: Well, why do you want to stop people from doing that?
05:00:54 <lemonxah> when you want to checkout the basket to pay for it you need to get the value and int and string doesn't have the value typeclass on it so i dont know how much those "items" cost
05:01:18 <dibblego> lemonxah: it's the same reason you don't put implicit parameters on constructors in scala.
05:01:52 <merijn> lemonxah: "checkOut :: Value a => Basket a -> Foo" <- this already prevents that
05:02:02 <lemonxah> oh ok merijn 
05:02:19 <merijn> lemonxah: That way the checkOut function only accepts Baskets whose items are instances of "Value"
05:02:25 <lemonxah> so you put the constraint on the funtion itself
05:02:31 <dibblego> lemonxah: Correct.
05:02:36 <merijn> You *have* to put the constraint on the function
05:02:41 <merijn> You can't not do that
05:02:52 <lemonxah> yes ok makes sense :)
05:03:00 <lemonxah> thank you dibblego and merijn 
05:03:06 <lemonxah> the more i learn about haskell the more i like it
05:09:04 <zoey_> :t flip id
05:09:06 <lambdabot> b -> (b -> c) -> c
05:09:19 <zoey_> Why am I able to flip id? I dont get it?
05:09:31 <obadz> :t flip
05:09:32 <zoey_> Shouldn't flip take in a two argument function?
05:09:32 <lambdabot> (a -> b -> c) -> b -> a -> c
05:10:07 <obadz> zoey_: there's no such thing as a two argument function
05:10:12 <zoey_> oh right
05:10:34 <zoey_> a -> (b -> c)? = a -> a?
05:10:37 <cocreature> :t flip
05:10:39 <lambdabot> (a -> b -> c) -> b -> a -> c
05:10:39 <cocreature> :t id
05:10:41 <lambdabot> a -> a
05:10:54 <obadz> zoey_: (b -> c) -> (b -> c) ~ (a -> a)
05:10:55 <cocreature> now try unifying a -> b -> c and a' -> a'
05:11:01 <zoey_> no wait I'm still confused
05:11:51 <zoey_> cocreature: How do I do that? b->c = a'?
05:11:51 <obadz> :t (($), flip id)
05:11:52 <lambdabot> ((a -> b) -> a -> b, b1 -> (b1 -> c) -> c)
05:11:59 <obadz> :t ((&), flip id)
05:12:01 <lambdabot> (a -> (a -> b) -> b, b1 -> (b1 -> c) -> c)
05:12:13 <obadz> cool that (&) = flip id
05:12:16 <cocreature> a -> b -> c is the same as a -> (b -> c), so now you are trying to unify a and a' and b -> c and a' so b->c and a have to be the same so you end up with (b->c)->(b->c)
05:12:32 <zoey_> oh thanks
05:15:45 <osager> what does this mean in the .ghci file
05:15:47 <osager> :def x \_ -> return ":set -XOverloadedStrings -XOverloadedLists"
05:16:05 <osager> with this i can do :x within ghci ?
05:16:13 <obadz> yup
05:16:16 <osager> ok
05:16:48 <osager> so i guess the return means wrap the string in IO
05:17:12 <obadz> I don't know if it's IO or some other monad but yes
05:20:13 <Squarism> does one get used to interpret signatures one mile long? Ex from lens library : "type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t". For me to understand that i need a cup of coffe and 20 minutes.
05:20:26 <Squarism> (ive done haskell for 1.5 months)
05:21:31 <tdammers> it gets better
05:21:40 <tdammers> lenses are a bit of an extreme case though
05:22:26 <tdammers> by necessity, because they mess with fairly fundamental things, and because they are extremely generalized in order to be maximally useful
05:22:40 <tdammers> you won't usually see this kind of type signatures in application code
05:23:20 <dibblego> haven't you been writing scala?
05:29:33 <Squarism> dibblego, sure. Maybe not used it to its full potentiel / less FP oriented. 
05:29:50 <Squarism> Your scalaz got me interrested in going all out FP. So i thought i could just as well try haskell directly. =D
05:30:14 <lemonxah> is it possible to have an instance of a type class for a list of my type?
05:30:33 <dibblego> trait Setter[S, T, A, B] { def ?[F[_]](f: A => F[B], s: S, x, F[T])(implicit S: Settable[F])
05:30:44 <lemonxah> like i have 'Instance Value Ticket where value a = price a' 
05:31:21 <dibblego> lemonxah: it is generally more recommended to, newtype Blahs = Blahs [Blah], then instance TheClass Blahs where Ö 
05:32:00 <lemonxah> i am looking to do something like 'instance Value [Ticket] where value a = sum $ fmap price a
05:32:14 <lemonxah> oh ok dibblego let me try that :)
05:33:41 <bitonic> Is there a way to relax a lower bound with cabal-install? E.g. `cabal install --allow-older foobar`?
05:40:23 <lemonxah> dibblego, when i have [Basket Ticket] and i do a sequence on that to get a Basket [Ticket] and i then try to do a checkOut on that it tells me No instance for (Value [Ticket]) arising from a use of ‚ÄòcheckOut‚Äô
05:40:36 <lemonxah> but i am unable to make such an instance
05:52:20 <lemonxah> could someone please take a look here http://lpaste.net/166211
05:55:49 <kmelva> Is there a way to fix this code ( https://gist.github.com/kmelva/b9f11d4209166413c9cab46bcf85cb73 ) just by changing the signature of `makeForm`?
05:57:43 * hackagebot phone-metadata 0.0.1.1 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.1 (raghuugare)
06:04:42 <Unhammer> if I have a cabal.config lying around in my project root for non-stack-users, will stack ignore that, or be confused by it?
06:05:50 <lemonxah> hmm how do you go from a newtype Ints = [Int] to [Int] ?
06:06:28 <liste> lemonxah: you mean "newtype Ints = Ints [Int]" ?
06:06:46 <liste> lemonxah: in that case, pattern matching usually
06:07:08 <liste> "foo (Ints ints) bar = bar ints"
06:07:18 <lemonxah> liste what i have is a [Ticket] and i want to make a typeclass instance for that but you cant so you have to make newtype Tickets = Tickets [Ticket]
06:07:32 <lemonxah> but i have [Basket Ticket]
06:07:37 <hexagoxel> you can do: newtype Ints = Ints { runInts :: [Int] }
06:07:48 <lemonxah> and when i do a sequence on that i have Basket [Ticket]
06:07:56 <hexagoxel> lemonxah: why can't you make an instance for [a]?
06:08:14 <lemonxah> but the instance of my Value typeclass does not understand [Ticket]
06:08:28 <lemonxah> hexagoxel, i get Illegal instance declaration for ‚ÄòValue [Ticket]‚Äô
06:08:39 <hexagoxel> Unhammer: don't know, but seems easy to test. just add some impossible constraint.
06:09:50 <lemonxah> hexagoxel, http://lpaste.net/166211
06:10:50 <tucuman> any suggestions on how to compute Mode of a list of numbers?
06:11:07 <hexagoxel> lemonxah: and the error does not suggest some useful extension? :D
06:11:46 <lemonxah> i have seen the FlexibleInstances but i was told that i should not just willy nilly add language extensions
06:11:49 <liste> tucuman: https://hackage.haskell.org/package/pretty-1.1.3.4/docs/Text-PrettyPrint-HughesPJ.html#t:Mode this?
06:12:08 <liste> or some other Mode
06:13:55 <liste> lemonxah: FlexibeInstances is safe and useful
06:14:04 <tucuman> liste: I mean Mode in a mathematical/statistical sense. given a list of number return the number that is most common on the list
06:14:14 <lemonxah> ok i will add it then :) was just busy reading this 
06:14:30 <lemonxah> but also dibblego suggested i do the newtype method so that is why i was looking at that first
06:16:52 <liste> tucuman: I see. folding them into a Map Int Int is one way
06:18:07 <liste> and then getting the key with the largest value
06:18:23 <liste> sorting and keeping track of run length is another way
06:18:33 <hexagoxel> lemonxah: http://dev.stephendiehl.com/hask/#language-extensions
06:18:34 <Unhammer> hexagoxel,  aha, of course :) yeah, stack seems to ignore cabal.config 
06:18:39 <Hafydd> > let modes = map head . last . groupBy ((==) `on` length) . sortBy (comparing length) . group . sort in modes [2,2,1,2,3,1,3,3]
06:18:40 <lambdabot>  [2,3]
06:18:54 <Hafydd> (Gives bottom for the empty list.)
06:20:01 <Hafydd> And there probably is a more efficient way using a fold.
06:20:18 <hexagoxel> lemonxah: esp. the list of benign ones below the table.
06:20:51 <phanimahesh> That's a cool one liner.
06:21:46 <phanimahesh> A fold can give the mode in a single pass, so yep, there exists a more effecient implementation.
06:22:55 <phanimahesh> A hashmap from element to number of occourences can be used as the accumulator, then pick the key(s) with max value.
06:23:35 <phanimahesh> I'm not good at haskell enough to convert it to haskell code immediately, though. :/
06:27:50 <quchen> @let histogram = M.toList . foldl' (\acc x -> M.insertWith (+) x 1 acc) mempty
06:27:51 <lambdabot>  Defined.
06:28:02 <quchen> > histogram [1,2,3,1,2,3,2,2,2,2,1,2,3] -- tucuman 
06:28:03 <lambdabot>  [(1,3),(2,7),(3,3)]
06:28:31 <quchen> The key part is the fold which builds a Map, which you can query efficiently using
06:28:34 <quchen> :t M.findMin
06:28:35 <lambdabot> Data.Map.Map k a -> (k, a)
06:29:02 <quchen> (careful, crashes on empty map)
06:35:15 <phanimahesh> :+1:
06:37:44 * hackagebot nix-paths 1.0.0.1 - Knowledge of Nix's installation directories.  https://hackage.haskell.org/package/nix-paths-1.0.0.1 (PeterSimons)
06:40:08 <sm> morning all.
06:41:45 <tucuman> thanks for all the replies
06:41:55 <fProgrammer_>  Quick question(asking again): I am parsing json in haskell using Aeson, I've a numerical field (say: age)  which is represented in always in string in json. How do I parse it into an integer using "decode" in Aeson. Here's example: http://lpaste.net/166215
06:42:28 <fProgrammer_>  I did try writing an instance for FromJSON here: http://lpaste.net/166218  But this works only if the type of "age" is String, how do I put "read" command while parsing?
06:42:44 * hackagebot distribution-nixpkgs 1 - Types and functions to manipulate the Nixpkgs distribution.  https://hackage.haskell.org/package/distribution-nixpkgs-1 (PeterSimons)
06:45:22 <srhb> fProgrammer_: look at the type of (.:). I'm pretty sure it returns a parser, which has a functor instance.
06:45:27 <srhb> (Meaning you can fmap read over it)
06:46:08 <fProgrammer_> srhb: something fmap read <*> v .:  "age" ?
06:47:27 <quchen> Don't use read, it crashes when the data is malformatted. readMaybe is a much better option.
06:48:22 <lpaste> quchen pasted ‚ÄúConverting age in explicit JSON parser for fProgrammer_‚Äù at http://lpaste.net/166221
06:48:41 <quchen> Ah, forgot a "pure".
06:49:01 <srhb> fProgrammer_: The parser is v .: "age"
06:50:00 <fProgrammer_> quchen: thanks, lemme check
06:50:38 <sshine> hi srhb!
06:54:30 <srhb> sshine: o/
07:00:44 <fProgrammer_> quchen: I am getting a strange parser error on "=" 
07:02:37 <fProgrammer_> quchen: sorry, noob error
07:08:46 <lpaste> quchen annotated ‚ÄúConverting age in explicit JSON parser for fProgrammer_‚Äù with ‚ÄúConverting age in explicit JSON parser for fProgrammer_ (annotation: better errors, exhaustive pattern)‚Äù at http://lpaste.net/166221#a166225
07:17:45 * hackagebot ghc-time-alloc-prof 0.0.0.1 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-time-alloc-prof-0.0.0.1 (MitsutoshiAoe)
07:20:53 <elpetrero_> I got some resources I only serve on yesod ocasionally, I would like to have it in memory for a short period of time after it has been served in case another request come
07:21:27 <elpetrero_> after that I would like to drop it and then if requested again re-readed. (think really old post). Any good abstraction for that?
07:22:05 <haskell654> Is Haskell a good main language to 'learn' for a new developer? They say you should focus on one lanuguage - would Haskell make sense for someone who wants to find a job/freelance work as a developer? Is there enough work to find, and is it a competitive space?
07:23:05 <elpetrero_> haskell654: depends where you want to develop mostly
07:24:29 <elpetrero_> if web-dev probably you would be better with purescript and elm (haskell inspired but target to web). Distributed systems haskell is really cool. Domains with good concurrency needs purity is a god send
07:26:20 <elpetrero_> haskell654: by the way, haskell was my first lang :-P, but if you need "jobs right now" you probably would be better with what is in demand
07:26:57 <ahihi> in the long term, I would recommend getting familiar with as many languages as practically possible
07:27:00 <ahihi> versatility is good
07:27:21 <bennofs> i think haskell is definitely more on the side "is there a job with haskell" rather "how many jobs with haskell are there" :=)
07:27:31 <bennofs> s/rather/rather than
07:29:17 <cheater> hi
07:32:02 <elpetrero_> is there a "robust" alternative to the cache package?
07:37:39 <srhb> elpetrero_: If it's just a single value, an mvar with a small wrapper and an expiry forkIO might do the trick? 
07:38:32 <elpetrero_> yep, but there are a lot of really old blog posts and sometimes they check them out progresively.
07:59:27 <c_wraith> funny thing is, people with Haskell on their resumes have little trouble let finding non-haskell jobs. 
07:59:37 <c_wraith> -let
08:00:02 <c_wraith> Haskell tends to impress people at the places you want to work anyway. 
08:00:23 <buglebudabey> can someone help with setting up a persistent file with postgres? i'm getting a parse error on 18:1 and i feel like it has something to do with template haskell http://lpaste.net/166240
08:01:10 <sm> c_wraith: I can confirm that
08:01:24 <oherrala> c_wraith: me too
08:02:06 <codedmart> We are going to be doing something along these lines on a web app project https://en.wikipedia.org/wiki/Entity_component_system. I would like to explore writing the back end in haskell. I am just not sure how to handle a varying degree of different json structures I could get for the same model?
08:02:43 <tdammers> codedmart: depends how far you want to lock things down
08:02:51 <tdammers> at the extreme end, you could just use Aeson's Value
08:03:21 <codedmart> tdammers: Yeah I was thinking that, but not sure how that would work in practice.
08:05:23 <codedmart> I had one thought along these lines. Allowing from the web app to add schemas so then on the back end we could either allow anything of no schema was provided or check against the schema if it was provided.
08:06:13 <buglebudabey> could someone tell me why i'm getting a parse error here? http://lpaste.net/166240
08:06:17 <buglebudabey> on line 18
08:06:45 <Xandaros> needs to be indented, I think
08:07:05 <buglebudabey> when i indent it i get a pare error on 'deriving'
08:07:11 <buglebudabey> parse*
08:07:47 <buglebudabey> on line 21
08:09:54 <Xandaros> buglebudabey: I have no idea, this is really just guesswork, but try adding a newline in front of [persistLowerCase|. The examples seem to do it that way
08:11:18 <Xandaros> actually, not all of them do that
08:15:07 <buglebudabey> it's weird, i did everything the same as the tutorial and it doesn't work
08:15:11 <buglebudabey> this is basically the first step
08:19:08 <buglebudabey> it works now! i removed module Main where
08:19:09 <srhb> buglebudabey: language pragmas go before moedule
08:19:11 <buglebudabey> and that fixed it
08:19:31 <buglebudabey> srhb thank yo
08:19:47 <srhb> buglebudabey: The problem was that they are just comments if they are not the very first thing in the source file. :)
08:20:10 <buglebudabey> thanks :)
08:22:47 * hackagebot type-combinators 0.2.4.1 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.4.1 (KyleCarter)
08:27:47 * hackagebot type-combinators 0.2.4.2 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.4.2 (KyleCarter)
08:32:57 <gurra> Is there any reason why Haskell chose to define Monad in terms of (>>=) instead of fmap and join?
08:34:38 <dolio> (>>=) is better most of the time for actual programming stuff.
08:35:06 <glguy> It's not the original reason, but I believe that join is incompatible with the current state of GeneralizedNewtypeDeriving
08:35:30 <dolio> Also Monad was unrelated to Functor until very recently.
08:35:37 <mizu_no_oto_work> glguy: incompatible in what way, out of curiosity?
08:39:24 <maerwald> gurra: no, it's arbitrary
08:39:49 <maerwald> I also find it more natural to just define join.
08:40:46 <travisxcode> I have basic knowledge of languages such as Python, Java, and C#, and am now looking to learn a functional language. Is Haskell generally recommended as a first functional language? I'm torn between it or a Lisp dialect.
08:41:19 <maerwald> travisxcode: yes, it is recommended
08:41:29 <maerwald> (at least here, lol)
08:42:09 <travisxcode> What exactly can be built with a functional language?
08:42:14 <maerwald> everything
08:42:23 <travisxcode> Coming from dealing with objects, I'm sure I have a lot to learn.
08:42:43 <maerwald> yes, forget everything you learned before and don't try to draw comparisons
08:42:45 <maerwald> it's easier that way
08:43:03 <travisxcode> Do you have any recommended learning resources?
08:43:19 <maerwald> https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
08:43:33 <travisxcode> As I previously stated, I would consider myself beginner/intermediate
08:43:37 <glguy> mizu_no_oto_work: With monad transformers you get an error due to the untracked roles of the monad being transformed
08:44:48 <lpaste> glguy pasted ‚ÄúGeneralizedNewtypeDeriving vs join-based Monad class‚Äù at http://lpaste.net/166257
08:46:05 <buglebudabey> travisxcode: Racket was my first language and it made for an easy transition into haskell - although i consider myself a haskell newbie still
08:48:10 <hsk3> I can zip over two lists. I can also zip over two ByteStrings (using the zip in the ByteString module).
08:48:10 <hsk3> But how can I zip over one list and one ByteString?
08:48:19 <hsk3> Is there a function for that?
08:48:22 <travisxcode> buglebudabey, I was actually looking at the SICP. Maybe I'll try to follow along and translate the examples to Haskell.
08:48:36 <glguy> hsk3: No, but you can zip your list with a list of indexes and index the bytestring using that index
08:49:30 <buglebudabey> travisxcode: i HIGHLY reccomend this book, and maybe follow along in haskell instead http://www.ccs.neu.edu/home/matthias/HtDP2e/
08:49:54 <buglebudabey> if you're new to functional programming it's an amazing intro and it picks up fast
08:50:04 <EvanR> or a list and a list of Word8
08:50:37 <glguy> Yeah, you could zip with ByteString's unpack function to get a list out
08:50:46 <hsk3> ah that would work for me, thanks
08:51:14 <EvanR> i liked SICP
08:51:56 <EvanR> when haskell was designed i think they took all those principles and juiced them up
08:52:46 <EvanR> actually that work probablt went into mirandas ancestors first
08:52:48 * hackagebot hsyslog-udp 0.1.1 - Log to syslog over a network via UDP  https://hackage.haskell.org/package/hsyslog-udp-0.1.1 (jonplussed)
08:53:07 <tdammers> I like how "How To Program" is the prologue
08:54:00 <tdammers> I dislike how it starts with a GUI
08:54:11 <EvanR> it does o_O
08:54:17 <tdammers> http://www.ccs.neu.edu/home/matthias/HtDP2e/part_prologue.html
08:54:19 <tdammers> yes
08:54:20 <tdammers> DrRacket
08:55:29 <tdammers> and the main reason why I dislike that is because in my own development as a programmer, the fact that I started with Turbo Pascal in Borland's IDE held me back, or at least that's how it feels
08:58:16 <tdammers> it could be bias, or a wrong interpretation on my side of the Unix epiphany I had years later
08:59:04 <danza> hey can anybody recommend a library to manipulate time conveniently? The kind of operations i would be interested to do is, for example: check that a given date is not earlier than one day ago, and similar
08:59:24 <hsk3> Is there a map function that accepts the function as the last param? map' :: [a] -> [b] -> (a -> b)
08:59:35 <hsk3> wait lol flip!
08:59:37 <hsk3> right?
08:59:47 <hsk3> hmm
08:59:52 <hsk3> no
09:00:41 <danza> hsk3, worst case you can wrap it in a lambda, like in \ a b c -> map c a b
09:01:08 <simpson> :t for
09:01:09 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
09:01:16 <simpson> hsk3: ^^?
09:01:40 <EvanR> danza: Data.Time
09:01:48 <danza> thanks EvanR !
09:01:48 <EvanR> use the Day type
09:02:12 <danza> looks good +1
09:02:17 <hsk3> simpson: that applicative is overkill
09:02:22 <hsk3> i guess i can make my own map'
09:02:56 <hsk3> no wait wtf
09:03:05 <hsk3> :t flip map
09:03:06 <lambdabot> [a] -> (a -> b) -> [b]
09:03:09 <hsk3> actually works fine
09:03:33 <maerwald> I don't even understand what: map' :: [a] -> [b] -> (a -> b) -- is supposed to do
09:03:45 <hsk3> i made a type
09:03:47 <hsk3> i'm an idiot
09:03:48 <hsk3> sorry :(
09:03:51 <hsk3> typo
09:04:39 <simpson> hsk3: I don't know what "overkill" means. Most of the prelude has undergone a transformation to have more Traversable and Applicative.
09:05:07 <maerwald> he doesn't need applicative
09:19:18 <texasmynsted> Now I do not see this but I am guessing it is possible some how‚Ä¶  How do I execute a function multiple times, each time against the result of the last application.  Imagine (+1) three times.
09:19:25 <texasmynsted> Is this possible?
09:20:25 <Hafydd> > iterate (+1) 0 !! 3
09:20:26 <lambdabot>  3
09:20:36 <Hafydd> :t iterate
09:20:38 <lambdabot> (a -> a) -> a -> [a]
09:20:58 <texasmynsted> oh nice!
09:21:04 <texasmynsted> Thank you
09:21:07 <Hafydd> Welcome.
09:21:38 <texasmynsted> hmm.  I did not expect [a]
09:21:52 <Hafydd> It gives a list of successive values produced.
09:22:12 <texasmynsted> so rather than applying the function to the result of the last, it is creating a list. 
09:22:20 <Hafydd> It is doing both of those things.
09:22:23 <texasmynsted> I suppose I could fold
09:23:03 <Hafydd> You can simply use (!!) to obtain the correct value. This would be equivalent to folding it.
09:27:44 <texasmynsted> :t (!!)
09:27:46 <lambdabot> [a] -> Int -> a
09:28:03 <texasmynsted> ah
09:28:03 <texasmynsted> :-)
09:29:26 <texasmynsted> Thanks again
09:30:26 <quchen> > take 3 (iterate f x)
09:30:31 <lambdabot>  [x,f x,f (f x)]
09:30:40 <Hafydd> texasmynsted: I highly recommend reading the entire Prelude, if you haven't already. This contains some of the most important functions in Haskell. This is a good reference for it: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/Prelude.html
09:31:35 <Hafydd> And this is another reference (the seminal one, in fact): https://www.haskell.org/onlinereport/haskell2010/haskellch9.html
09:33:22 <texasmynsted> thank you
09:34:13 <jstolarek> I have a silly question. I have no idea how to login to my account at haskellers.com
09:34:25 <jstolarek> frankly speaking I do not remember which of the login methods I used
09:34:33 <jstolarek> is there any way for the web page to remind that?
09:34:42 <glguy> You'll have to ask the people that run that site
09:35:33 <jstolarek> right
09:35:39 <jstolarek> that's what i was afraid of
09:38:35 <muesli4> I'm writing a C binding for a library, what is the best (portable) way to specify linker flags in a cabal file?
09:40:22 <glguy> muesli4: Does the C library provide a pkg-config file?
09:41:21 <nitrix> If so, just a row with pkgconfig-depends: thelib >= 1.0.0  is enough.
09:44:14 <muesli4> glguy, nitrix: Thanks, actually it does, but how portable is pkg-config? :)
09:44:52 <maerwald> muesli4: careful, you have to check that _upstream_ provides the pkg-config file and not a distributor gone mad (which happens)
09:45:02 <maerwald> otherwise the thing may or may not compile depending on the distro
09:45:14 <dcoutts> muesli4: works widely on linux systems, can in principle work on windows, support on osx is as good as most of the other C lib support
09:45:38 <geekosaur> except that os x doesn't ship with pkg-config itself, you need to install it from brew or macports
09:47:57 <glguy> which might be OK if you're also installing the library itself via brew
09:49:14 <glguy> Does Cabal actually need pkg-config itself install to read the pkg-config files that come with many libraries when installing them via homebrew?
09:50:32 <muesli4> It seems to work, but GHCi doesn't like it.
09:53:01 <quchen> Can anyone point me to the difference between push/enter and eval/apply, other than that the latter tags functions with their arity and chunks argument frames together?
09:53:29 <Zemyla> quchen: In which context?
09:53:29 <quchen> I'm confused about the computational difference, and I've read fastcurry a couple of times :-|
09:53:47 <quchen> Zemyla: They're two different execution models of the STG
09:53:50 <maerwald> glguy: I hope so, otherwise I don't know how it properly would figure out the directory of the .pc files, except assuming stuff
09:54:58 <dcoutts> glguy: yes
09:55:28 <dcoutts> glguy: it uses pkg-config via it's cli to get info, does not read .pc files directly
10:02:50 * hackagebot conduit-merge 0.1.0.0 - Merge multiple sorted conduits  https://hackage.haskell.org/package/conduit-merge-0.1.0.0 (cblp)
10:12:07 <buglebudabey> quick survey, what types of things did you guys do/read to get to where you are now for haskell
10:13:45 <jle`> mostly blogs
10:13:50 <jle`> after an intro course book
10:14:01 <Jinxit> buglebudabey: #haskell
10:14:03 <EvanR> IRC
10:14:04 <Jinxit> osmosis
10:14:18 <buglebudabey> osmosis is definitely the way to go
10:14:43 <schell> i read LYAH, real world haskell, did as many of the 99 probs as i could, read blogs and IRC
10:14:45 <EvanR> probably more important than reading is writing
10:14:57 <schell> yeah - lots of projects
10:15:18 <buglebudabey> lots of little/mid-size ones?
10:15:27 <buglebudabey> i'm trying a project where i'm making a compiler now
10:15:43 <schell> that sounds like a good one
10:15:49 <buglebudabey> but idk where along the way i can include useful things just yet
10:16:14 <buglebudabey> i know the basics of monads but never use common ones in practice like reader or state
10:16:40 <maerwald> state is actually not that useful
10:16:45 <maerwald> I mean, using it directly
10:17:01 <buglebudabey> that's interesting, any reason?
10:17:49 <schell> maerwald: like opposed to StateT? or RWST or something?
10:18:06 <buglebudabey> ^ like those, i don't know stuff like this
10:18:24 <EvanR> State by itself is so limited to never come up
10:18:50 <maerwald> the only time I remember using it was the State thing of Array, STArray or so?
10:19:02 <maerwald> but again, that's not State directly
10:19:10 <schell> yeah, i see
10:19:21 <EvanR> but an instance of MonadState thats not State, maybe
10:19:25 <maerwald> and when it comes to frameworks, they mostly have their own monad stack, that is far more powerful
10:19:36 <maerwald> using mtl and whatnot
10:20:16 <EvanR> buglebudabey: rather than look for way to use this or that monad, start with the project and do without them, until you identify a place where it would help
10:20:36 <EvanR> because the other way around, it probably wont help, itll get in the way
10:21:10 <maerwald> https://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html here's another use case of STArray
10:21:17 <EvanR> monads arent required to do anything
10:21:20 <maerwald> those are rather specific cases
10:21:28 <buglebudabey> EvanR thank you, that's helpful
10:21:35 <buglebudabey> right now i'm doing exactly that
10:22:58 <dmj`> Some monads are just great for certain problem domains
10:23:40 <maerwald> and when you really think you might need State to make your API more simple, then it often is just about hiding explicit function parameters and stuffing a lot of liftFOO into your code
10:23:49 <suppi> buglebudabey: stuff like that basically http://gilmi.xyz/post/2015/02/25/after-lyah
10:24:35 <buglebudabey> thanks suppi 
10:24:50 <EvanR> it suggests after lyah or cis... to learn web sites
10:24:58 * EvanR ignoring that one ;)
10:25:15 <ggVGc> you're such a lyah
10:25:22 <Zemyla> Will ApplicativeDo turn do { x <- mx; y <- my; f x y } into liftA2 (,) mx my >>= uncurry f?
10:25:25 <schell> lol
10:25:34 <dmj`> lyol
10:25:50 <maerwald> Scotty is ok for starters
10:25:52 <EvanR> if you know you want websites, you already know that, if not, people shouldnt taint your innocence
10:26:02 <ggVGc> I've started using Maybe's monad instance a lot more lately
10:26:25 <ggVGc> I used scotty for a small thing, and it was real nice
10:26:34 <ggVGc> but also it's the only web related anythign I've used in haskell
10:26:38 <maerwald> it's just one suggestions and it's fine
10:27:08 <Zemyla> Because it seems that that is simpler, especially with a good Applicative instance.
10:27:29 <ggVGc> I feel for something with a big API requiring high stability, I would use Servant. For smaller things, or prototypes I'd use Sctty
10:27:38 <ggVGc> Servant seems much better, but also with a lot more overhead
10:27:41 <EvanR> Zemyla: what... you mean liftA2 f mx my ?
10:28:09 <EvanR> skipping the tuple
10:28:23 <EvanR> and the whole point of liftA2 being about functions instead of tuples ;)
10:28:48 <dmwit> ?tell Clint I guess either dschoepe or I would be the people to bug. But beware. Bug us and you might become the maintainer.
10:28:48 <lambdabot> Consider it noted.
10:28:51 <ggVGc> only time I've used any lift is when writing lenses, and only liftA2
10:28:58 <dmj`> ggVGc: more overhead?
10:29:00 <EvanR> rapidly prototyped webapp
10:29:08 <ggVGc> I feel I'm missing a whole part of haskell by not getting involved in monad transformers
10:29:15 <EvanR> i.e. the final product web app 
10:29:24 <dmj`> ggVGc: servant's monad isn't as complex as scotty's
10:30:06 <ggVGc> dmj`: I got the feeling that servants type safety also led to a fair bit of noise and boilerplate, compared to for example scotty
10:30:10 <ggVGc> but yeah, I didn't use servant
10:30:15 <ggVGc> so I can't say much
10:30:45 <dmwit> Zemyla: https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo has the desugaring rules
10:31:18 <ggVGc> scotty and WAI was really nice for my use case though
10:31:24 <Clint> dmwit: i don't even use it :P
10:31:29 <Zemyla> EvanR: No, I mean join (liftA2 f mx my).
10:32:02 <dmj`> ggVGc: servant is like typed wai sugar. When you call 'serve (Proxy :: Proxy API) endpoints' you're left with a simple wai 'Application'.
10:32:05 <EvanR> well that do notation doesnt imply a join
10:32:19 <EvanR> oh, no return...
10:32:35 <EvanR> then f <*> mx <*> mx
10:32:53 <dmj`> ggVGc: in regards to monad transformers, have you checked out grabmuellers paper?
10:33:07 <johnw> dmj`: link?
10:33:08 <ggVGc> never heard of.
10:33:17 <dmj`> johnw, ggVGc: https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
10:33:36 <johnw> thx
10:33:49 <dmwit> Clint: You wouldn't be the first package maintainer who didn't use their own package. =P
10:33:59 <EvanR> @undo do {x <- mx; y <- my; f x y}
10:33:59 <lambdabot> mx >>= \ x -> my >>= \ y -> f x y
10:34:00 <dmj`> transformers, monads in disguise
10:34:24 <Clint> dmwit: that's true
10:35:11 <ggVGc> dmj`: I've just never come across a situation whre I needed transformers I think
10:35:49 <circ-user-BTdkW> hi. when I type (*3) in www.tryhaskell.com I get :: Num a => a -> a. Though, in ghci I get:
10:35:49 <circ-user-BTdkW> <interactive>:6:1:     No instance for (Show (a0 -> a0))       (maybe you haven't applied enough arguments to a function?)       arising from a use of ‚Äòprint‚Äô     In the first argument of ‚Äòprint‚Äô, namely ‚Äòit‚Äô     In a stmt of an interactive GHCi command: print it
10:36:07 <circ-user-BTdkW> i already tried :print (*3)
10:36:09 <glguy> circ-user-BTdkW: You can ask GHCi for the type of something with the :t command
10:36:25 <Cale> :t (*3)
10:36:26 <lambdabot> Num a => a -> a
10:36:29 <EvanR> try haskell does weird things on output
10:36:44 <geekosaur> circ-user-BTdkW, ghci can do some limited things of that kind (only for non-polymorphic expressions though, so it wouldn't work here regardless).
10:36:44 <circ-user-BTdkW> thnks
10:37:06 <geekosaur> and it's not enabled by default, you need to install a package and then load it into ghci
10:37:10 <suppi> does ghci 8 print the type signature instead or is it the same as 7.10?
10:37:23 <glguy> same
10:37:51 * hackagebot conduit-merge 0.1.0.1 - Merge multiple sorted conduits  https://hackage.haskell.org/package/conduit-merge-0.1.0.1 (cblp)
10:48:21 <ggVGc> dmj`: thanks, that was a good read!
10:52:29 <dmj`> ggVGc: for sure, a little dated, but good
10:53:26 <dmj`> his final stack
10:53:27 <dmj`> :k forall env error logs integer a . ReaderT env (ExceptT error (WriterT [logs] (StateT integer Identity))) a
10:53:29 <lambdabot> *
11:02:32 <nitrix> At that point, you write your own monad, right?
11:04:28 <dmj`> nitrix: do you mean newtype it?
11:05:01 <Faucelme> Why not use Except over RWS instead?
11:05:05 <nitrix> Does the french saying "too much, is like not enough" applies to monad transformers?
11:05:29 <maerwald> extensible effects are nicer :/
11:06:21 <nitrix> dmj`: It's the question. What's the idiomatic way? Newtyping it? What are the alternatives?
11:06:28 <EvanR> is extensible effects referring to a specific librar or
11:06:47 <maerwald> well, there is an oleg library for extensible effects, but...
11:07:02 <maerwald> oleg libraries tend to have funny types
11:07:11 <dmj`> nitrix: every additional layer introduces overhead at runtime, so depends on what your needs are. I've found this overhead to be negligible for my needs and the capabilities added to really help producitivty.
11:07:24 <adelbertc> MTL ?
11:08:21 <schell> also afaik extensible-effects has been replaced by freer, am i right?
11:08:23 <dmj`> nitrix: you can newtype it sure, and derive most instances, but I'd recommend programming against the typeclasses MonadState, etc. As opposed to programming against StateT. Keep the functions that operate on your monad stack abstract
11:09:38 <dmj`> nitrix: fair warning, the more free variables you have in your type, the harder it will be to derive instances generically
11:10:14 <maerwald> schell: haven't even tried that, but it looks more similar to what idris does than the oleg lib
11:10:36 <maerwald> utilizing more GHC extensions it seems
11:11:17 <dmj`> nitrix: lambdabot doesn't have GeneralizedNewtypeDeriving enabled, otherwise I'd show you
11:11:46 <schell> maerwald: it‚Äôs based on oleg‚Äôs paper which i think is like extensible effects 2.0 
11:17:52 * hackagebot type-combinators 0.2.4.3 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.4.3 (KyleCarter)
11:36:32 <osager> i cloned a github haskell project and want to play around the code, i stack ghci inside the project ?
11:37:07 <bennofs> osager: what is your question? 
11:37:08 <osager> if i want to play around a second project, wont stack reinstall a lot of stuff ?
11:37:17 <Athas> osager: yes, you use stack ghci.
11:37:28 <Athas> osager: no, stack has a cache in $HOME/.stack.
11:37:35 <bennofs> osager: oh, too early :) i believe stack caches binaries as long as the snapshot is the same
11:37:37 <Athas> Although not all projects fit well in ghci.
11:38:13 <osager> so those caches are global
11:38:20 <osager> for the user
11:38:24 <jle`> yeah, it re-uses what it can
11:38:29 <osager> great
11:38:34 <osager> thanks everyone
11:38:46 <jle`> you might need to stack init or stack install first maybe
11:38:53 <Athas> Or stack setup to get GHC.
11:39:01 <osager> but emacs intero seems to reinstall some packages for each project
11:39:15 <Athas> It will reinstall if it's not the exact same snapshot and GHC version.
11:39:19 <osager> quite annoying
11:39:33 <osager> Athas, i see
11:42:08 <osager> inside a github project folder, i see several stack.yaml, with different ghc verions. how to use those files ?
11:42:30 <osager> ex: stack-7.10.yaml, stack-7.8.yaml
11:42:50 <osager> i mean stack can choose ghc verions ?
11:42:53 * hackagebot extra 1.4.10 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.10 (NeilMitchell)
11:42:58 <osager> isn't it automatic ?
11:46:23 <nitrix> osager: It does it based on the snapshot/resolver used.
11:46:59 <nitrix> osager: But what you're referring to is something else.
11:48:45 <lpaste> gfixler pasted ‚Äúcapitalize first words in sentences‚Äù at http://lpaste.net/166322
11:49:07 <gfixler> oops, wrong channel
12:05:35 <sinelaw> Hey, using ansi-wl-pprint, I'm getting rediculous line breaks in lists (e.g. [1,2,\n3]) - any idea how to prevent that?
12:10:24 <muesli4> sinelaw: http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3/docs/Text-PrettyPrint-ANSI-Leijen.html#v:renderPretty You can always change the width to which you render (although that has been unsatisfying for me in the past).
12:12:54 * hackagebot servant-auth-cookie 0.1.0.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.1.0.1 (zohl)
12:32:34 <joncfoo> Where does one typically "announce" a useful tool?
12:33:02 <dmj`> joncfoo: reddit / haskell cafe
12:33:37 <dmj`> ANN: Useful tool 1.0 
12:34:25 <joncfoo> thanks!
12:34:47 <sinelaw> muesli4: thanks
12:37:19 <tombert> howdy everyone; I have a conceptual question; haskell's lazy and all that, which is great.  
12:37:30 <tombert> but I have a question; why can't you specify laziness in the code?
12:37:45 <johnw> do you mean, why isn't it "opt in"?
12:37:45 <tombert> what's teh disadvantage of being able to tell the compiler to be strict or not-strict
12:37:54 <tombert> yeah, like Scala or something
12:38:01 <tombert> not asking to flame, I'm genuinely curious
12:38:06 <johnw> you have to pick one or the other as the default
12:38:11 <johnw> Haskell makes the laziness choice
12:38:27 <johnw> you *can* do it in code, but that comes with certain tradeoffs
12:38:33 <johnw> Idris does exactly this
12:38:36 <tombert> yeah, that's what I'm asking though
12:38:40 <tombert> what's the tradeoff?
12:38:54 <johnw> one you have to specify it in one place, you end up needing to propagate it in more places
12:39:10 <geekosaur> and much of the ecosystem relies on that choice being the default, so you can't just arbitrarily tell it "be strict now" and expect things to "just work"
12:40:28 <mizu_no_oto_work> tombert: one of the big tradeoffs with strict vs lazy is that lazy algorithms compose better than strict ones
12:40:31 <platz> even Edwin (who created Idris) has said that he's not sure whether strict-by-default or lazy-by-default is the best option
12:41:24 <mizu_no_oto_work> For example: head . sort is a terrible algorithm in a strict language, but a good one in a lazy language
12:41:49 <tombert> Im not disagreeing with the virtues of laziness
12:42:06 <tombert> I'm mainly asking what does Scala sacrifice by giving you the option
12:42:18 <johnw> lots of dupilcation in libraries
12:42:23 <johnw> in order to have strict and lazy versions of algorithms
12:42:28 <johnw> edwardk knows the answer to this in detail
12:42:37 <johnw> since he uses both Scala and Haskell a lot, and is a proponent of implicit laziness
12:42:56 <tombert> I mean, I am too, for the most part
12:43:01 <mizu_no_oto_work> S11001001, too
12:43:44 <mizu_no_oto_work> At any rate, the one problem is that whatever the default is will generally be over-represented
12:44:18 <mizu_no_oto_work> strict-by-default languages with optional laziness essentially all lead to code that's over-strict.
12:44:49 <tombert> I guess I'm asking more from a compiler perspective
12:45:00 <tombert> if I had a `lazy` keyword
12:45:17 <tombert> or a `strict` keyword
12:45:36 <tombert> is that harder to optimize?  if so, why?
12:47:11 <mizu_no_oto_work> Check out https://wiki.haskell.org/Correctness_of_short_cut_fusion
12:48:07 <tombert> mizu_no_oto_work: I've actually read that, but doesn't something like Lazy.js do that too?
12:48:11 <tombert> and js is a strict language
12:49:14 <ralu_> speakung about strictness, can some body take a look at this code please, that I am unable make it to work https://gist.github.com/ra1u/0d2a9c5c090e4a9fbb0fed71eaba400c
12:51:06 <johnw> you should include the error
12:51:20 <johnw> and whether "make it work" means something other than just a syntax error
12:51:23 <ralu_> main stucks
12:51:32 <ralu_> and does not evaluate
12:52:46 <mauke> btw, the verb is "to stick" or "to get stuck". "stucks" doesn't exist
12:53:05 <ralu_> I am sorry. That is what I meant
12:53:17 <ralu_> it gets struck
12:53:59 <mauke> struck is a different word :-)
12:54:08 <mauke> hmm, evalT looks cyclic
12:55:04 <ralu_> it is cyclic, but i think it should work if everything is lazy
12:56:36 <lyxia> you're traversing an infinite list
12:57:36 <ralu_> why reader works, and state monad does not?
12:57:46 <johnw> ralu_: monads do not "produce" values lazily
12:58:05 <johnw> this is the whole reason that streaming libraries are a thing
12:58:44 <johnw> I'm guessing reader works because there is no value dependency between bound actions
12:58:50 <johnw> but it can't work generally
12:59:17 <johnw> instead of m [b], you need something like Pipes' Producer m b
13:03:32 <lyxia> ralu_: what should the first element of your list be
13:03:44 <lyxia> uh, the second
13:04:19 <lyxia> it's n+whatever the state is when r terminates
13:04:23 <lyxia> but r doesn't terminate
13:05:46 <ralu_> is it possible to rewrite evalT so that it will work?
13:07:21 <lyxia> perhaps using mfix
13:08:45 <ralu_> thank you, i will take a look.
13:13:52 <Gurkenglas> :t sequence . iterate (>>= ?f) . return -- ralu_, do you want something that works pretty much like this?
13:13:54 <lambdabot> (Monad m, ?f::a -> m a) => a -> m [a]
13:15:32 <ralu_> i have function [a] -> [b] that behaves well. It outputs one value for each input
13:15:52 <Gurkenglas> Does it have the form map f for some f?
13:16:14 <ralu_> not exactly, but similar
13:16:29 <ralu_> it was constructed as applicative on ziplist
13:18:03 <Gurkenglas> > let iterateM f = sequence . iterate (>>= f) . return in (`evalState` 0) $ iterateM (\n -> modify (+n) >> get) 1
13:18:05 <lambdabot>  [1,1,4,20,168,2704,86560,5539904,709107840,181531607296,92944182936064,95174...
13:19:51 <Gurkenglas> ralu_, can you rephrase that applicative on ziplist thing?
13:22:48 <ralu_> lists that I am working with is not monad but like zipList. What I am dealing with is using Applicative to construct [a]->[b]
13:24:31 <NemesisD> does anyone know if there's such a thing as a docker image with a snapshot preinstalled? building a small project on my CI server and it took like half an hour before running out of memory building haskell-src-exts
13:24:41 <Gurkenglas> You mean, in each step you need one element from a list available beforehand to determine the next element from the output list?
13:25:16 <ralu_> yes
13:26:15 <ralu_> I will take a look in code you have posted
13:26:22 <Gurkenglas> :t alaf StateT traverse
13:26:24 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
13:28:55 <Gurkenglas> :t mapAccumL -- Actually if you don't have yet another monad to layer on top of the state thing you only need this but imo mapAccumL manages to get both argument order and tuple order wrong
13:28:57 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:29:18 <Zemyla> Okay, I downloaded the latest Haskell Platform today, and it's something that for some reason freezes whatever program I try to run it from.
13:29:46 <Zemyla> I run it from Explorer, and Explorer freezes. I run it from Task Manager, and Task Manager freezes.
13:32:03 <Zemyla> I guess I need to try downloading it again.
13:40:19 <lifter> Should I close a TMQueue that I'm not going to use anymore or does it not matter if it's left open?
13:41:15 <monochrom> does the doc suggest something?
13:41:51 <lifter> Not from what I can tell
13:42:07 <lifter> http://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TMQueue.html
13:43:44 <monochrom> OK, suppose I am the writing end and you are the reading end.
13:44:10 <monochrom> I have not written for an hour. And yet I don't close it.
13:44:37 <monochrom> What do you see on the reading end? How much can you guess what my future intention is?
13:45:43 <lifter> I'd think it would depend on the context. But in my case actually I think no one will read the TWQueue anymore and I assume(?) it could be garbage collected.
13:46:15 <monochrom> Do you want to be able to distinguish between "I intend to write again in the future, maybe 5 days later but who knows" vs "I intend to not write again"?
13:47:00 <lifter> Well, I know that I intend not to write again.
13:48:11 <monochrom> you sound like you have set things up so that the writer and the reader have an a-priori agreement on how many messages will be written so the reader knows a priori how many messages to wait for.
13:48:35 <monochrom> in which case why do you need TMQueue as opposed to the simpler TQueue?
13:49:39 <glguy> dcoutts: Follow-up from yesterday, I just managed to make a test monolithic shared library on Linux
13:49:56 <lifter> monochrom: You may be right, I might not need the TMQueue.
13:50:03 <monochrom> have you read the doc of readTMQueue?
13:50:24 <lifter> Yeah
13:50:44 <monochrom> so you know the difference between a closed queue and a non-closed queue
13:50:49 <lifter> yes
13:51:04 <monochrom> does the difference make a difference to your application?
13:51:06 <sinelaw> any recommended ordered set package?
13:51:19 <lifter> monochrom: I'll have to investigate a bit more.
13:51:35 <monochrom> yeah. use intelligent design. don't use evolution.
13:52:01 <monochrom> every line of code you keep must serve a definite purpose.
13:52:18 <lifter> this is true
13:52:57 * hackagebot language-javascript 0.6.0.6 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.6 (ErikDeCastroLopo)
13:53:27 <monochrom> but you can have meta-reasons like "I'm using a library more powerful than I need, but this is because I already have this one installed, I don't want to install a simpler but different one"
13:53:50 <monochrom> that is a good reason but you need to know you are not using its extra features.
13:54:30 <lifter> right
13:54:31 <sinelaw> or should I just implement my own ordered set?
13:54:50 <monochrom> I would use Data.Set for ordered set.
13:55:16 <monochrom> I wouldn't want to code up my own balanced binary search tree once again.
13:55:30 <monochrom> but I can send you my code if you want :)
13:56:17 <monochrom> what is the average number of times a programmer implements balanced binary search trees, counting his/her student days?
13:56:27 <monochrom> and what is the distribution?
13:56:44 <dmwit> There is also Data.List.Ordered if you need the different laziness tradeoff.
13:56:46 <sinelaw> monochrom: in what sense is Data.Set ordered?
13:57:01 <dmwit> What is an ordered set?
13:57:06 <monochrom> (I make my students do it at least once :) )
13:57:36 <sinelaw> dmwit: I mean an ordered container with unique elements
13:57:39 <EvanR> elements are in some order
13:57:47 <monochrom> it has an Ord requirement, and it is able to spit out elements in the ‚â§ order in linear time
13:58:15 <sinelaw> monochrom: ok, that's not what I meant. I mean that the insertion order is the traversal order
13:58:20 <monochrom> (cf "toAscList")
13:58:21 <sinelaw> or reverse
13:58:26 <sinelaw> like a list
13:58:52 <EvanR> stack?
13:59:03 <sinelaw> yes, or reversed, but with unique elements
13:59:05 <dmwit> I don't know of an ordered set package. But you should poke around on Hackage.
13:59:08 <monochrom> then you cannot use the word "set", since inserting 3 times is different from inserting 1 time.
13:59:24 <dmwit> If you don't see anything pretty quickly, there isn't one.
13:59:26 <monochrom> you can probably call it a queue
13:59:32 <sinelaw> monochrom: inserting 3 times should have the same effect as inserting once (first insertion sets the order)
13:59:33 <dmwit> monochrom: To be fair, he didn't say "set", he said "ordered set".
13:59:45 <dmwit> monochrom: Jargon often includes more than one word.
13:59:56 <sinelaw> queue with unique elements then
14:00:04 <monochrom> no, you simply cannot include the word "set", no matter how many adjectives you pile on it
14:00:05 <EvanR> interesting rules
14:00:06 <sinelaw> never mind the name now
14:00:16 <dmwit> monochrom: I reject your restriction.
14:00:22 <monochrom> unless one of the adjectives is "not"
14:00:28 <sinelaw> You cannot reject restrictions
14:00:36 <dmwit> sinelaw: and yours =D
14:00:41 <sinelaw> :)
14:01:04 <monochrom> I don't know how to fulfill the uniqueness requirement. (or is it the distinctness?)
14:01:05 <glguy> What about the ordered multiset, [] ?
14:01:53 <jle`> monochrom: multisets are a thing
14:01:56 <dmwit> It ought to be easy to build out of, say, combining Data.Set and Data.Seq. But I don't know of anything prebuilt that does it.
14:02:01 <monochrom> I know how now, but I need either Ord or Hashable
14:02:07 <EvanR> its a stack where if you try to push an element that is already somewhere in the stack, it has no effect
14:02:46 <EvanR> so... a list or sequence
14:03:35 <dmwit> Hm. It is actually mildly tricky if you want to support deletion.
14:03:35 <dmj__> Sounds inefficient :)
14:03:42 <monochrom> you know, I can agree to "name is unimportant", on condition that you write axioms instead of suggestive names.
14:03:48 <EvanR> deletion, from a stack?!
14:04:04 <EvanR> well just wait and see if thats required
14:04:25 <dmwit> What makes you say it's a stack? sinelaw never said it was.
14:04:25 <Zemyla> I have a question. Is there something like DefaultSignatures that works on data or type families?
14:05:50 <dmwit> I can imagine a pretty clean mutable data structure for this.
14:05:52 <glguy> Zemyla: Yes, if you're talking about an associated type synonym (which you can then wrap in a newtype to have it behave like an associated data type
14:06:01 <dmwit> Essentially `Map t (DoublyLinkedListNode t)`.
14:06:13 <glguy> Zemyla: Example: https://github.com/glguy/tries/blob/master/src/Data/GenericTrie/Internal.hs#L107 and line 182
14:06:36 <EvanR> dmwit: seems like a regular list is just as good, if youre not storing references
14:06:41 <EvanR> to the middle
14:06:50 <dmwit> EvanR: As I said: regular list sucks for deletion.
14:06:56 <EvanR> so does this
14:06:56 <sinelaw> monochrom: toList (insert b (insert a empty)) == [a, b]
14:07:09 <dmwit> EvanR: Not at all. Deletion is cheap: look up the key, and do two pointer rewrites.
14:07:10 <EvanR> (for number of elements where anything makes a difference)
14:07:18 <EvanR> look up = traverse whole list?
14:07:23 <dmj__> glguy: woa
14:07:26 <sinelaw> monochrom: toList (insert a (insert a empty)) == [a]
14:07:31 <dmwit> EvanR: No, it's a doubly-linked list and I have a pointer to a node.
14:07:34 <sinelaw> or whatever to make it precise
14:07:38 <EvanR> you already looked it up...
14:07:39 <monochrom> with a‚â†b?
14:07:41 <dmwit> EvanR: No traversal needed: the map points right into the list.
14:07:45 <EvanR> heh
14:07:47 <sinelaw> monochrom: yes
14:07:53 <EvanR> and then you update the map/
14:07:58 * hackagebot Hclip 3.0.0.4 - A small cross-platform library for reading and modifying the system clipboard.  https://hackage.haskell.org/package/Hclip-3.0.0.4 (JensThomas)
14:08:04 * EvanR stops remembering C++ and goes back to work
14:08:09 <dmwit> EvanR: Yes. So the total cost is O(log n), n the number of elements.
14:08:20 <dmwit> EvanR: Compared to O(n) if you store it in a [].
14:08:39 <sinelaw> Can be a heap with elements tagged by their insertion index
14:09:01 <sinelaw> never mind, I'll just use some ad-hoc hack for now
14:09:06 <Zemyla> glguy: Your instance for V1 a should be data instance GTrie V1 a = VTrie.
14:09:10 <glguy> dmj__: If you're checking out the code do note that the associated data type is actually generated as a function of the original type :)
14:09:12 <dmwit> sinelaw: Again, that seems like it would interact badly with deletion.
14:09:22 <dmwit> sinelaw: Do you need deletion?
14:09:27 <Zemyla> This way, you can have a trie of, say, Either Void k.
14:09:30 <sinelaw> I don't actually
14:09:37 <Zemyla> Which is an inhabited type.
14:09:41 <dmwit> sinelaw: Oh. Then just combine a [] and a Set.
14:09:50 <sinelaw> yah
14:10:46 <Zemyla> Kind of like how Proxy is a Representation of (->) Void.
14:10:49 <glguy> Zemyla: Are you sure that I don't support that already?
14:10:54 <EvanR> dmwit: in the case you have a mutable map into some mutable structure that you have to update, might as well just have the map
14:11:16 <dmwit> EvanR: I have an immutable Data.Map.Map into a mutable doubly linked list.
14:11:30 <Zemyla> glguy: Yeah, pretty sure. If you try to traverse a trie with a key of Either Void a, it looks like it'll give an error.
14:12:05 <dmwit> EvanR: Perhaps your objection is that looking up index i in the doubly linked list costs O(i) instead of O(log n) or O(1). I hadn't thought of that problem.
14:12:18 <dmwit> EvanR: And that does suck. Dang.
14:12:50 <EvanR> my objection is with all the randomly linked lists i made never actually provable helping me get the job done better or faster
14:12:58 <glguy> Zemyla: *Data.GenericTrie Data.Void> traverse print (insert (Right () :: Either Void ()) () empty )
14:12:58 <glguy> ()
14:12:58 <glguy> STrieR (Con "Right" (Con "()" ()))
14:13:32 <dmwit> EvanR: I can't parse your objection.
14:13:42 <Zemyla> Hm. Still.
14:15:35 <EvanR> at some point i stopped using the theorem that obviously traversing pointers in order to mutate stuff is obviously going to be faster or nicer
14:16:00 <glguy> Zemyla: The reason that it is correct as is is that GTrie is the type of non-empty tries
14:16:06 <EvanR> because we have such nice immutable structures that require no thought
14:17:01 <glguy> Zemyla: So the empty case for V1 is handled by Nothing. Consider: type TrieRepDefault k = Compose Maybe (GTrie (Rep k))
14:17:02 <Zemyla> Oh, I didn't know they had to be non-empty.
14:17:12 <glguy> Zemyla: That's discussed on line 175
14:17:21 <dmwit> EvanR: Okay, I'll bite. What's your proposal for an immutable structure that matches the asymptotics of my proposed mutable one? Namely: insertion in O(log n), deletion in O(log n), traversing in O(n)
14:17:53 <glguy> Zemyla: In any case, hopefully this code is relevant to your question in some way
14:18:07 <monochrom> you always traverse pointers, mutable or immutable :)
14:18:38 <monochrom> or at least, I always do.
14:18:52 * glguy mapMs pointers when possible
14:19:29 <Zemyla> Oddly enough, that's pretty much exactly the code I was trying to write :V
14:20:10 <monochrom> it is true that after sunset I become denotational and only think of values not pointers. but that's also when I don't know time costs.
14:23:15 <EvanR> yeah but were talking about "cleaner"
14:23:28 <EvanR> secondarily how efficient it is
14:23:50 <monochrom> even if that's only secondary, you can't stay denotational
14:23:52 <EvanR> i know i would seg fault at least 130 times before i got it right
14:24:15 <dmwit> It's not that easy to write segfaults with STRef.
14:24:30 <dmwit> Nobody's messing with *pointers* here.
14:24:34 <dmwit> Merely references.
14:25:05 <monochrom> yeah, you will have to appeal to another kind of bug, e.g., accidentally build a circular list so you run into an infinite loop, rather than segfault.
14:25:06 <EvanR> i didnt even realize we were talking about a mutable doubly linked haskell structure, how do you get it in and out of ST?
14:25:20 <dmwit> Who says you do?
14:25:31 <dmwit> As usual: mutable things are in ST. No avoiding that.
14:25:38 <EvanR> nobody, and nobody wants to delete either
14:25:45 <dmwit> Well, there is avoiding it by going to the even worse IO. ;-)
14:26:01 <monochrom> it's a good puzzle to try to support deletion
14:26:02 <dmwit> Yes, it turns out deletion isn't needed; once I learned this I suggested the much simpler immutable structure.
14:26:28 <monochrom> we know that the sans-deletion problem is already solved and closed.
14:26:38 <EvanR> i was wondering about the puzzle of using this thing in a the program as a whole which isnt all ST
14:26:52 <EvanR> unsafe?
14:27:05 <dmwit> I, too, am curious about an immutable structure that supports all the interesting operations at speed.
14:27:12 <monochrom> sure, I'm thinking over how to do it immutably too. have you solved it yet?
14:27:20 <monochrom> why are you arguing instead of solving?
14:27:41 <monochrom> (same beef I have with anti-AI people. why are they arguing rather than solving?)
14:27:57 <EvanR> a list or sequence
14:27:58 <kadoban> What operations does it need to support?
14:27:59 * hackagebot rtcm 0.1.6 - RTCM Library.  https://hackage.haskell.org/package/rtcm-0.1.6 (markfine)
14:28:20 <monochrom> (well, I guess in their case, since they have chosen anti-AI, the last thing they want happen is that they can also solve.)
14:28:58 <dmwit> kadoban: For now, I've been thinking about insertion (by key, index auto-chosen), deletion (by key, index auto-discovered), and traversal (in index order).
14:29:17 <dmwit> kadoban: Indexing (by index) might also be nice if you're feeling ambitious.
14:29:22 <EvanR> im also wondering about what youd use this DS for
14:29:53 <kadoban> dmwit: Isn't that just Data.Map or friends?
14:29:54 <monochrom> kadoban: you need to support: insertion; insertion is idempotent; deletion; able to spit out elements in the same order they were inserted the first time
14:30:22 <monochrom> it is a queue plus idempotence and random-access deletion
14:30:42 <dmwit> kadoban: Tell me more! What are the keys in your Map? What are the values? How are values managed?
14:30:57 <monochrom> or maybe change it to stack (correspondingly, able to spit out element in the reverse order they were inserted the first time). seems to be just as tricky.
14:31:10 <monochrom> (tricky if you want it fast, of course)
14:31:38 <kadoban> dmwit: Well, you said by key, index auto-chosen and auto-discovered, so ‚Ä¶ just have the index == the key, and who cares? But it appears monochrom's description is more what you want.
14:32:09 <monochrom> I spent years training myself to write precise specifications :)
14:32:33 <monochrom> probably more than half of my grad school time was that
14:32:42 <dmwit> kadoban: Yes, I was a bit lax about the automation. Apologies.
14:32:52 <monochrom> and more than 1/3 of my grad school time on haskell
14:32:52 <EvanR> solution call it web 3.0, never delete
14:33:41 <kadoban> What about two Maps, one from index to key, and one from key to value. To insert you just pick the highest index in the index->key map, increment it, and use that as the new index. Then you insert into the other map.
14:34:04 <monochrom> web 3.0 is not "never delete". instead, it means persistence. (Okasaki's kind, i.e., old versions still available, but you still talk of deletion.)
14:34:05 <kadoban> Oh hmm, you'd also need key->index for deletion.
14:34:20 <monochrom> s/talk of/support/
14:34:22 <dmwit> What is "key" and "value"?
14:34:37 <dmwit> There is only "value". =)
14:34:45 <EvanR> you call it "the little x, dont ask what it means, the item goes away"
14:34:49 <kadoban> dmwit: You said the values have keys ‚Ä¶  Okay, then the key is the same as the value, make it a Set instead.
14:34:56 <EvanR> to avoid user confusion
14:35:13 <EvanR> if govt asks to really delete, call back
14:35:49 <dmwit> kadoban: Okay, so a `Map k Index` and a `Set k`? How do you do traversal in index order?
14:37:15 <dmwit> I guess you mean a `Map k Index` and a `Map Index k`. That seems plausible for the operations I asked for.
14:37:21 <gaze__> hey! Is anyone here familiar with accelerate? I'm curious how one might write a histogramming function
14:37:45 <kadoban> dmwit: It's Map Index k, Set k, and I guess you need a Map k Index for deletion too.  You just traverse the indicies in the Index->k map in order. Actually if the key is equal to the value, you don't even need the Set really.
14:37:47 <gaze__> it seems like folds run only over exps
14:37:47 <dmwit> I was originally thinking that deletion would require changing all the indices. But since we don't support access by index or traversal-with-index, I suppose you wouldn't need to do that.
14:38:15 <monochrom> yeah, that looks nice
14:38:20 <dmwit> That seems clean, and we even have a package offering most of that capability.
14:38:58 <EvanR> a relation between index and value?
14:39:08 <EvanR> or bimap
14:39:12 <monochrom> this one is a bijection
14:39:23 <dmwit> It's a bijection between a subset of the indices and a subset of the values.
14:39:33 <EvanR> the subset being whats in the container
14:39:37 <dmwit> yes
14:39:37 <monochrom> but Map doesn't know how we're using it
14:39:40 <Cale> Which data structure are you guys talking about?
14:40:04 <EvanR> nice
14:40:04 <monochrom> Cale: you need to support: insertion; insertion is idempotent; deletion; able to spit out elements in the same order they were inserted the first time
14:40:12 <dmwit> ?hackage bimaps seems to offer it
14:40:12 <lambdabot> http://hackage.haskell.org/package/bimaps seems to offer it
14:40:14 <Cale> ah
14:40:32 <dmwit> Though you still need to write a bit of code, of course.
14:40:56 <monochrom> Cale: P.S. Toronto Haskell Meetup has been moved to next Wednesday, not today
14:40:58 <Cale> This is very closely related to a question that I was thinking about with Ryan, of how to get something similar to Data.Set, but with a specified ordering imposed on the elements.
14:41:15 <glguy> Cale: Would you call that an "ordered set" ?
14:41:21 <dmwit> monochrom: Insertion is more than just idempotent, I guess.
14:41:26 <Cale> monochrom: I noticed that, thought I'd just put it into my calendar wrong :)
14:41:46 <Cale> glguy: Yeah, I suppose so
14:41:52 <dmwit> monochrom: e.g. insert k . insert k' . insert k = insert k' . insert k
14:41:59 <EvanR> in this case the ordering is fixed to the order you build it in
14:42:00 <monochrom> it is true that there was a time, 2 weeks ago, when the bentomiso calendar had it today. then it got changed.
14:42:32 <monochrom> so it is also true that I told you "today" some time ago.
14:43:18 <monochrom> yes dmwit
14:43:37 <monochrom> there is probably no pre-made word for this
14:43:43 * dmwit nods agreeably
14:44:08 <monochrom> I guess more reason to write axioms rigorously and ditch natural languages
14:44:39 <simpson> monochrom: zo'o xu do tavla?
14:45:10 <simpson> "Do you speak Lojban? Also I am joking."
14:46:46 <dmwit> Next puzzle would be how to support indexing.
14:47:22 <Cale> Or even something like a list-like sequence, but where you could look up an element by value and get a cursor to the first occurrence of that element would be nice. Deletion is tricky though.
14:47:30 <dmwit> Actually, I guess Data.Seq might enable that reasonably easily.
14:47:49 <kadoban> dmwit: As-in lookup 5, and that's the 5th value that was inserted that still exists?
14:47:52 <dmwit> Since the elements in the Seq I'm imagining would be monotonic, binary search would be possible.
14:47:59 <dmwit> kadoban: right
14:48:18 <dmwit> So you could keep a Seq off to the side that stores the indices that are still "live".
14:48:39 <kadoban> You can extend the Map thing by using an order statistics tree for that, still in O(lg n). I don't know if Data.Map supports that though. An annotated balanced BST could.
14:48:58 <shachaf> hi dmwit
14:49:01 <shachaf> dmwit++
14:49:12 <dmwit> hi shachaf
14:49:18 <monochrom> still stick the the bimap. it takes O(lg n) to ask for "what is the ith guy in your Map k Index"
14:49:36 <dmwit> kadoban: From the Wikipedia page, I think Map supports Select(i) but not Rank(x).
14:49:44 <kadoban> Ah okay, yeah I'm not familiar with bimaps, but if it already supports that, that'll work.
14:50:04 <monochrom> binary search trees with subtree sizes can do both.
14:50:09 <kadoban> Yeah, you need to annotate each subtree with "how many elements are in this subtree", which Data.Map probably doesn't do.
14:50:12 <shachaf> whoa whoa whoa, succinct data structures?
14:50:17 <shachaf> Hm.
14:50:18 <monochrom> and the functional world uses such trees
14:50:36 <kadoban> BSTs are pretty badass.
14:50:38 <monochrom> Data.Map does. it's balancing is based on subtree sizes
14:50:41 <shachaf> Maybe not.
14:50:41 <dmwit> Oh, Map does support Rank(x).
14:50:50 <dmwit> :t M.lookupIndex
14:50:52 <lambdabot> Ord k => k -> Data.Map.Map k a -> Maybe Int
14:51:15 <glguy> :t M.elemAt
14:51:16 <lambdabot> Int -> Data.Map.Map k a -> (k, a)
14:51:18 <dmwit> Great! This seems totally plausible.
14:51:21 <kadoban> Nice
14:51:37 <monochrom> oops, s/Map k Index/Map Index k/
14:51:51 <monochrom> I'm going to put it on my exam!
14:52:26 <dmwit> monochrom: I hope you give your students plenty of time for your exams. =)
14:53:20 <monochrom> actually maybe assignment instead of exam.
14:55:49 <monochrom> yeah, the invention of "a take-a-number scheme but it is not the user-end index" is not something you can invent in an exam.
14:56:05 <dmwit> right
14:57:17 <Zemyla> What is the Haskell option for making everything in a file separate?
14:57:34 <dmwit> What does "separate" mean?
14:57:54 <monochrom> if I re-index, but only once in a while, what amortized time am I look for?
14:58:04 <monochrom> s/look for/looking at/
14:58:23 <monochrom> (I am looking for an interesting amortization puzzle.)
14:58:30 <Zemyla> Like, if an executable depends on a single function in a file in a library, then it won't have everything from that library added.
15:00:11 <dmwit> Is that what --split-objs does?
15:00:12 <Cale> Zemyla: You can import specific definitions from a module like  import Foo.Bar (foo, bar, quux)
15:00:22 <monochrom> -fsplit-objects (sp?)
15:00:38 <Cale> Zemyla: If you're talking at the level of compilation, I don't think there's anything more granular than the module level there
15:00:58 <Zemyla> Yeah, split-objs.
15:01:19 <monochrom> the linker will take forever.
15:01:32 <monochrom> but yes exe size will be smaller
15:02:00 <monochrom> but you have to use -split-objs on the library
15:05:49 <Zemyla> monochrom: That's why I'm setting splot-objs in the cabal config.
15:07:03 <monochrom> yeah
15:08:00 * hackagebot streaming-eversion 0.2.0.0 - Translate pull-based stream folds into push-based iteratees.  https://hackage.haskell.org/package/streaming-eversion-0.2.0.0 (DanielDiazCarrete)
15:13:00 * hackagebot bits 0.5 - Various bit twiddling and bitwise serialization primitives  https://hackage.haskell.org/package/bits-0.5 (ryanglscott)
15:15:37 <mrpat> hi everybody, I‚Äôm struggling with displaying a simple template with Ginger (http://hackage.haskell.org/package/ginger-0.2.5.0)
15:15:55 <mrpat> my code is at: http://lpaste.net/166349
15:16:45 <mrpat> line 48 (amongs other) fails with: Couldn't match type ‚ÄòEither ParserError Template‚Äô with ‚ÄòTemplate‚Äô
15:16:45 <mrpat>     Expected type: Either ParserError Template
15:16:47 <mrpat>       Actual type: Either ParserError (Either ParserError Template)
15:16:48 <mrpat>     In the expression:
15:16:48 <mrpat>         parseGingerFile loadFileMay "templates/index.html"
15:17:03 <shachaf> Please on't paste more than about 2 lines in here. You can use your hpaste instead.
15:17:23 <mrpat> gotcha, sorry about that
15:17:53 <mrpat> so yeah, any help, or even an example would be appreciated, i‚Äôm just beginning with haskell
15:18:38 <jdreaver> When using "run" in Shelly, is there a way to make it not print to stdout? I want to run a command and get the output, but not print to stdout as well.
15:20:18 <monochrom> what is the type of parseGingerFile? what is the type of loadFileMay?
15:20:43 <monochrom> (and no, don't tell me what they do "intuitively". clearly, intuition is wrong here, therefore irrelevant. what are their types?)
15:26:26 <johnw> jdreaver: there's a function for that
15:26:28 <johnw> I think it's just run_
15:27:19 <jdreaver> johnw: What run_ does is not return an argument, but it still prints the output of your command to stdout
15:27:28 <jdreaver> not return a result*
15:28:03 <jdreaver> So for example this still prints to stdout: run_ "echo" ["hello"]
15:30:35 <jdreaver> Ah, there is an option in Shelly to run silently. You just do "shelly $ siliently $ do ..."
15:31:21 <schell> shelly eh?
15:31:32 <johnw> right
15:41:27 <Zemyla> Is there some kind of parlor-trick-type package that uses OverloadedStrings to let you turn Haskell into a glorified Bash?
15:42:09 <Zemyla> Like, being able to say "grep" "file" $| "less"?
15:42:21 <Zemyla> Or something along those lines?
15:42:58 <jle`> you could just write an IsString instance for IO () where toString x = exec x
15:43:14 <jle`> tehn you could just write main = "grep file | less"
15:44:10 <Zemyla> jle`: You could also write an IO String instance, that captures its stdout.
15:44:25 <jle`> beautiful
15:44:34 <puregreen> Zemyla: it looks kinda like https://github.com/aelve/new-hs/blob/master/new-hs.hs#L40
15:45:25 <puregreen> (and the instance is at https://github.com/aelve/new-hs/blob/master/new-hs.hs#L244https://github.com/aelve/new-hs/blob/master/new-hs.hs#L244)
15:45:31 <puregreen> * https://github.com/aelve/new-hs/blob/master/new-hs.hs#L244
15:54:53 <buglebudabey> i read on bitemyapp that i should not use the haskell platform, and start fresh with stack, can anyone offer their two cents?
15:55:10 <schell> i think that‚Äôs fine advice
15:55:18 <schell> stack is great
15:55:26 <jle`> that's sort of what i would say if i was helping someone start wiht haskell
15:55:43 <jle`> the HP has only caused me pain and complexity in the past that would have all been fine if i just used stack from the beginning
15:55:50 <jle`> but i hear that the new HP includes stack so, what
15:56:07 <buglebudabey> i have a handful of projects, some current, some not, but none are managed by cabal or anything, so would uninstalling the HP be alright?
15:56:22 <buglebudabey> should I even bother uninstalling?
15:56:31 <jle`> you don't need to uninstall anything
15:56:40 <kadoban> buglebudabey: I'd probably uninstall it just so it's less confusing, but it's not really necessary.
15:57:32 <buglebudabey> i haven't really dug into it enough to be confused, what are the common complaints? i read that after a while when the libraries get old HP can cause problems
15:57:42 <jle`> well, it doesn't have stack
15:57:58 <jle`> and it doesn't offer anything that stack doesn't
15:58:08 <jle`> it's a bit less inflexible with library updates, yeah
15:58:19 <jle`> idk, i just don't really even know why anyone would want to use it
15:58:32 <jle`> it has a fraction of the functionality and a lot of really simple things are made really complicated
15:58:37 <kadoban> buglebudabey: Once you start needing packages that HP doesn't include, there's no sane way to proceed (that I know of).
15:58:38 <jle`> or impossible
15:58:48 <kadoban> Or different versions, or etc.
15:58:52 <buglebudabey> alright, do you know how id go about fully uninstall without causing future problems?
15:59:09 <dmj> buglebudabey: fully uninstall haskell platform?
15:59:13 <buglebudabey> yes
15:59:39 <dmj`> buglebudabey: yea, I had a script for that... let me look
15:59:47 <buglebudabey> O: my hero
16:00:06 <buglebudabey> does using stack mean foregoing cabal?
16:00:24 <dmj`> buglebudabey: think it was from this
16:00:27 <dmj`> https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090170.html
16:01:09 <dmj`> there's this 
16:01:11 <dmj`> https://gist.github.com/steakknife/3775443
16:01:11 <buglebudabey> dmj` i see two groups of commands, is it the first one?
16:01:22 <Zemyla> I installed the minimal GHC, and am now cabal installing lens.
16:01:32 <dmj`> the gist above is the script from that mailing list post
16:01:33 <Zemyla> I will probably see you all next week.
16:01:59 <buglebudabey> ah thank you dmj` 
16:02:03 <buglebudabey> ill run it
16:06:45 <buglebudabey> dmj` the script aborted and i'm not sure why
16:08:02 * hackagebot streams 3.3 - Various Haskell 2010 stream comonads  https://hackage.haskell.org/package/streams-3.3 (ryanglscott)
16:09:05 <mietek> Anyone interested in Kripke semantics, or normalisation by evaluation?
16:09:48 <buglebudabey> dmj` i have GHC.framework and not HaskellPlatform.framework, does this mean i should still continue with the uninstall
16:11:26 <buglebudabey> i did it, i uninstalled the HP
16:11:33 <buglebudabey> now to stack, woo?
16:26:12 <Zemyla> Is there a way I can get cabal to download all the packages first, and then start building them?
16:26:35 <puregreen> cabal fetch pkg
16:26:58 <puregreen> where pkg is your package name
16:26:59 <puregreen> (but you'll have to do cabal install manually)
16:27:16 <hexagoxel> combine with cabal install --dry-run, probably..
16:27:35 <puregreen> cabal fetch fetches all deps
16:28:02 * hackagebot semigroupoids 5.1 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.1 (ryanglscott)
16:29:59 <hexagoxel> puregreen: but it won't see the .cabal in current dir.
16:47:04 <Koterpillar> Aha! GI/GLib/Callbacks.hs: commitAndReleaseBuffer: invalid argument (invalid character)
16:47:44 <buglebudabey> i just removed my haskell platform and installed stack, is there anything i need to do to make sure everything is up and running?
16:49:18 <dmj`> buglebudabey: you should be good
16:49:33 <mgsloan> buglebudabey: How about trying "stack new my-project", then cd into the folder and run "stack build"
16:53:03 * hackagebot neural 0.2.0.0 - Neural Networks in native Haskell  https://hackage.haskell.org/package/neural-0.2.0.0 (lbrunjes)
16:53:48 <Koterpillar> so either Stack or a different (newer?) Cabal version ate half of that message
16:54:26 <Zemyla> Oh man, lens is finally building :O
16:59:54 <buglebudabey> how do i get Happy with stack?
17:00:31 <Koterpillar> stack install happy
17:00:44 <Clint> i'm sad that you made that unambiguous
17:01:20 <Koterpillar> presumably they'll also be happier after running that command, too
17:01:31 <buglebudabey> when i run the command happy parser.y it says the command cannot be found
17:01:46 <Koterpillar> add ~/.local/bin to your PATH
17:01:57 <Koterpillar> (stack should warn you, I think)
17:02:09 <buglebudabey> newbie here, how do i do that
17:02:14 <Koterpillar> OS?
17:02:21 <buglebudabey> mac osx
17:02:24 <Koterpillar> pass
17:02:43 <Koterpillar> install linux, add to .bashrc/.zshrc
17:03:01 <Clint> .zshenv, really
17:03:11 <Koterpillar> yes
17:03:13 <Koterpillar> export PATH=~/.local/bin:$PATH
17:03:30 <Koterpillar> buglebudabey: run that on your command line now to get it working in this session
17:04:02 <buglebudabey> <3
17:04:06 <johnw> does using ~ in the PATH string work for every shell?
17:05:03 <Clint> johnw: it doesn't work correctly in bash
17:05:12 <maerwald> johnw: it's part of the posix standard
17:05:19 <buglebudabey> Koterpillar can you explain why that's necessary for the command to work?
17:05:29 <Clint> oh, maybe they fixed that
17:05:33 <geekosaur> maerwald, expanding ~ is only in POSIX as the start of a word. notably, that means not after :
17:05:37 <Koterpillar> buglebudabey: https://en.wikipedia.org/wiki/PATH_(variable)
17:06:49 <geekosaur> (whether it works after = is indeterminate. until recent bash versions ~ after a colon did not work --- note that OS X ships older bash --- and after = didn't work in very old versions but should be fine for people here
17:07:39 <Koterpillar> export PATH=$HOME/.local/bin:$PATH
17:07:45 <Koterpillar> portable
17:08:16 <sm> buglebudabey: stack installs executables like happy in the $HOME/.local/bin/ directory, so that directory must be in your $PATH for the shell to find them when you type $ happy
17:08:43 <Clint> bash still does weird and incorrect expansion of literal tildes in $PATH
17:08:43 <buglebudabey> thanks Koterpillar and sm
17:08:54 <sm> otherwise you'd have to type $ $HOME/.local/bin/happy every time
17:12:36 <maerwald> geekosaur: "In an assignment (see XBD¬†Variable Assignment), multiple tilde-prefixes can be used: at the beginning of the word (that is, following the <equals-sign> of the assignment), following any unquoted <colon>, or both."
17:13:16 <geekosaur> wonder when they fixed that, then
17:13:48 <geekosaur> old versions of POSIX didn't consider after = start of a word, more recent ones didn't consider after : start of a word
17:14:00 <maerwald> it's a mess anyway, since '~' is a valid filename too
17:14:39 <geekosaur> that said I did kinda give up on posix when they decided that they'd remove all the ksh stuff they'd had in it for a decade to make some commercial vendor happy, rendering a lot of stuff instantly noncompliant with no deprecation or warning
17:14:40 <maerwald> e.g. the haskell path library wrongly assumes that '~' cannot be parsed as a relative path. But it's just a shell-ism
17:15:09 <buglebudabey> would anyone like to offer some witty name for a compiler i'm making for a simple lisp language?
17:15:26 <maerwald> hisp
17:16:13 <buglebudabey> seems too easy but it's unchallenged so far
17:16:14 <buglebudabey> anyone else?
17:16:33 <Koterpillar> buglebudalisp
17:16:50 <maerwald> lol
17:16:56 <buglebudabey> as much as i like my name lol
17:17:02 <Koterpillar> lolisp
17:17:08 <maerwald> hellisp
17:17:35 <maerwald> must start with h!
17:17:53 * puregreen shall play devil's advocate
17:17:57 <puregreen> rustle
17:18:07 <buglebudabey> hmmmm
17:18:43 <buglebudabey> Hexpression? Lisp likes S-expressions
17:18:55 <maerwald> HAXPRESSION
17:19:19 <maerwald> hex is boring, must be haxax
17:19:30 <buglebudabey> haxpress?
17:19:36 <puregreen> while I'm at it (i.e. at proposing sort-of-synonyms): murmure 
17:19:39 <maerwald> now that sounds like a company name haha
17:19:46 <buglebudabey> it does
17:19:49 <buglebudabey> i dont like it
17:19:59 <buglebudabey> what murmure
17:20:00 <puregreen> haxax is ugh if you know Russian
17:20:08 <maerwald> what does it mean?
17:20:17 <buglebudabey> i don't i know portuguese :P
17:20:24 <Koterpillar> puregreen: and are typing in leet
17:20:53 <buglebudabey> right now the project is named Haskett because I was basing it on Racket language
17:21:03 <buglebudabey> but it's really a bit more simple than racket
17:21:14 <maerwald> Heckmett :D
17:21:24 <maerwald> (now that was a joke, lol)
17:22:11 <buglebudabey> what about TLC The Lisp Compiler
17:22:14 <buglebudabey> like GHC but not
17:22:28 <puregreen> ‚Äúhaxax‚Äù is roughly how ‚Äúhaha‚Äù might be written by someone who is using a weird form of transliteration (where some letters are replaced with similar-looking ones, not similar-sounding ones) *and* it's an ugly form of ‚Äúhaha‚Äù as well
17:22:28 <Koterpillar> yeah, put in your own city name
17:23:03 <Koterpillar> puregreen: but how are you going to pronounce it?
17:23:06 <buglebudabey> I don't really have a city, so it'd seem meh
17:23:12 <buglebudabey> i move around a lot
17:23:14 <Koterpillar> mehlisp
17:23:17 <buglebudabey> lol
17:23:19 <Koterpillar> has an H, too
17:23:28 <buglebudabey> lishp
17:23:34 <buglebudabey> like how sean connery would say
17:23:50 <maerwald> ok, so we have a h, lisp AND sean connery!
17:23:52 <puregreen> murmure is sort of like ‚Äúrumble‚Äù in french and ‚Äúlisp‚Äù can mean ‚Äúrustle‚Äù in English if my dictionary is to be believed
17:24:18 <zomg> buglebudabey: whenever Sean Connery comes up I can't help but think of those SNL Celebrity Jeopardy bits :P
17:24:24 <zomg> "suck it Trebek!"
17:24:52 <maerwald> SL -- Sean Lisp
17:26:05 <puregreen> another name, this time with ‚Äúh‚Äù if you insist: ‚Äúlishp‚Äù
17:26:10 <puregreen> tho it's sorta obvious
17:26:46 <Koterpillar> taken
17:26:50 <Koterpillar> lolisp is also taken
17:26:55 <mrpat> monochrom: the type of parseGingerFile is: parseGingerFile :: Monad m => IncludeResolver m -> SourceName -> m (Either ParserError Template)
17:26:59 <Koterpillar> lishp is lisp in sh
17:27:00 <buglebudabey> zomg that is a good one
17:27:23 <Koterpillar> actually, lishp is taken twice, one in sh, one in haskell
17:27:42 <puregreen> Lishp III, then
17:27:57 <buglebudabey> It's just the name of my repository, i can name it whatever :P
17:28:08 <buglebudabey> not like i'm hoping this will be the new lisp compiler
17:28:21 <Koterpillar> you never know
17:28:37 <buglebudabey> What about Harentheses
17:28:40 <buglebudabey> sounds greek
17:28:59 <Koterpillar> yeah, translate "lisp" to greek
17:29:07 <ironChicken> i have a parsec parser which does: `(try a) <|> (try b) <|> invalid` where `invalid` is some parser which will always succeed.
17:29:27 <ironChicken> the idea is to be able to build a result structure that contains the parse errors, because `invalid` returns a value representing a parse error.
17:29:52 <ironChicken> but when `a` or `b` encounter a parse error, the whole parser stops. whereas when `a` or `b` calls `fail`, it falls through to the `invalid` parser, which is what i want in either case
17:30:01 <buglebudabey> or Harens
17:30:51 <puregreen> looks like ‚Äúsigmatism‚Äù isn't yet taken by almost anyone except for https://github.com/ljos/sigmatism but it doesn't count really c'mon only 2 stars
17:30:59 <puregreen> let's move to haskell-blah
17:31:08 <maerwald> no, haskell-offtopic :P
17:31:20 <ironChicken> so what's the difference between a parser failing and calling Monad fail from within a parser?
17:31:22 <puregreen> didn't know it existed
17:31:28 <maerwald> puregreen: sure
17:32:12 <buglebudabey> ironChicken what happens if you take out the try's
17:32:28 <buglebudabey> a <|> b <|> invalid
17:33:08 <buglebudabey> actually that doesn't pertain to your q, apologies
17:33:17 <ironChicken> well i guess that input would get consumed by the failed a or b and then invalid wouldn't be able to parse the invalid input (and b wouldn't be able to have a go at parsing the thing that a couldn't)
17:36:03 <ironChicken> actually, i'm going to leave this now and got to bed
17:44:24 <buglebudabey> Koterpillar when i tried running my happy command from another place the command wasn't recognized again
17:44:33 <buglebudabey> and i had to add the path again?
17:45:02 <Koterpillar> http://askubuntu.com/questions/3744/how-do-i-modify-my-path-so-that-the-changes-are-available-in-every-terminal-sess http://www.cyberciti.biz/faq/appleosx-bash-unix-change-set-path-environment-variable/
17:45:44 <Koterpillar> as I said, the "export" command only worked for that particular session (terminal window)
17:46:48 <buglebudabey> oh sorry i missed that paort
17:46:49 <buglebudabey> part
17:48:38 <blargh> is there a standard function that does this on a list of Maybe values? ex ((Just x) : xs) = x : (ex xs) ; ex ((Nothing) : xs) = ex xs ; ex [] = []
17:48:51 <Koterpillar> :t catMaybes
17:48:52 <lambdabot> [Maybe a] -> [a]
17:48:56 <dmj`> @src catMaybes
17:48:56 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:49:09 <Koterpillar> > catMaybes [Just 1, Nothing, Just 2]
17:49:10 <lambdabot>  [1,2]
17:49:18 <blargh> doh :P
17:49:20 <blargh> thanks
17:49:21 <dmj`> blargh: note, that kind of pattern matching isn't partial, but syntactic sugar
17:49:49 <johnw> i prefer syntactic honey
17:50:09 <blargh> dmj` property of the maybe monad right?
17:50:15 <dmj`> johnw: :) syntactic smores
17:50:25 <johnw> I think it's part of the list comprehension sugar
17:50:33 <johnw> akin to guard patterns
17:50:43 <dmj`> > [ x | Right x <- [ Right 1, Left 2 ] ]
17:50:44 <lambdabot>  [1]
17:52:46 <koz_> Is there a more concise way of writing 'not (all (False==) vs) && not (all (True==) vs)'
17:52:49 <koz_> ?
17:54:18 <johnw> case vs of [] -> True; (v:vs) -> not (all (== v) vs)
17:54:36 <Koterpillar> koz_: elem False vs && elem True vs
17:54:41 <buglebudabey> is there a way i can add autocomplete to stack commands?
17:55:05 <koz_> Thanks johnw and Koterpillar!
17:55:36 <johnw> note that Koterpillar's version has worse asymptotics
17:55:37 <Koterpillar> koz_: sorry, my version is not equivalent to yours
17:55:59 <johnw> for example, if vs is all True, then it has to scan the whole list for a False first
17:57:02 <koz_> johnw: Yeah, I noticed.
17:57:05 <Koterpillar> it also gives a different result on []
17:57:18 <koz_> johnw's version has the desired semantics, so I'm happy.
18:00:12 <johnw> although, it's only 5 characters shorter and maybe not as obvious :)
18:01:02 <Koterpillar> I'm still going for concise and correct: elem False vs == elem True vs
18:02:14 <johnw> that's nice
18:02:20 <Koterpillar> you _have to_ scan the list up to first element that's not equal to the first one
18:02:26 <puregreen> not . null . drop 1 . group
18:02:51 <johnw> Koterpillar: doesn't your version still have minimum O(n) performance every time?
18:03:02 <blargh> is there a cleaner way to do this? mkFlippedPairs (f, l) = (\(x,y) -> (y, x)) <$> (,) f <$> l
18:03:03 <johnw> my version can abort on the second element
18:03:15 <Koterpillar> > (not . null . drop 1 . group) (False: (True: repeat False))
18:03:16 <lambdabot>  True
18:03:23 <johnw> sorry, wrong use of O notation
18:03:42 <Koterpillar> > (\vs -> elem False vs == elem True vs) (False: (True: repeat False))
18:03:44 <lambdabot>  True
18:03:48 <jle`> blargh: you can use 'swap' from Data.Tuple
18:04:02 <Koterpillar> johnw: no
18:04:11 <Koterpillar> so will mine
18:04:22 <johnw> > (\vs -> elem False vs == elem True vs) (repeat True)
18:04:27 <lambdabot>  mueval: ExitFailure 1
18:04:35 <johnw> > (\vs -> case vs of [] -> True; (v:vs) -> not (all (== v) vs)) (repeat True)
18:04:38 <blargh> jle` just noticed that, besides that? swap <$> (,) f <$> l
18:04:39 <lambdabot>  mueval-core: Time limit exceeded
18:04:42 <puregreen> if we had ‚ÄúmapAdjacent‚Äù, it could be ‚Äúor . mapAdjacent (/=)‚Äù
18:04:50 <Koterpillar> johnw: no way around that
18:04:53 <johnw> true
18:04:54 <jle`> blargh: fmap f . fmap g = fmap (f . g)
18:05:16 <johnw> also, not (all (== v) vs) is the same as any (/= v) vs
18:05:45 <jle`> blargh: also i think you just have traverse
18:05:53 <jle`> > traverse (1, Just "hello")
18:05:54 <lambdabot>      Couldn't match expected type ‚Äòa -> f b‚Äô
18:05:54 <lambdabot>                  with actual type ‚Äò(Integer, Maybe [Char])‚Äô
18:05:54 <lambdabot>      In the first argument of ‚Äòtraverse‚Äô, namely ‚Äò(1, Just "hello")‚Äô
18:06:06 <jle`> er, i mean sequence
18:06:10 <jle`> > sequence (1, Just "hello")
18:06:11 <lambdabot>  Just (1,"hello")
18:06:22 <jle`> except you flip the result for some reason
18:06:26 <buglebudabey> if i am making a chat bot that is supposed to recognize certain user questions, are there some good libraries already out there that I can tweak? or maybe some AI libraries
18:06:39 <jle`> :t fmap flip . sequence
18:06:40 <lambdabot> (Monad f, Traversable ((->) a)) => (a -> f (b -> c)) -> f (b -> a -> c)
18:06:41 <jle`> er
18:06:42 <buglebudabey> or anything else anyone would recommend
18:06:45 <jle`> :t fmap swap . sequence
18:06:47 <lambdabot> Monad f => (a, f b) -> f (b, a)
18:06:50 <jle`> ^^ blargh 
18:07:14 <jle`> it's a bit over-constrained though
18:07:38 <jle`> `Functor f => (a, f b) -> f (a, b)` is often called 'strength'
18:07:41 <Koterpillar> > (\vs -> case vs of [] -> True; (v:vs) -> not (all (== v) vs)) (take 1000000 $ repeat True)
18:07:43 <lambdabot>  False
18:07:45 <puregreen> finally, and since I'm golfing anyway, ‚ÄúliftA2 (&&) or (not.and)‚Äù works as well and is actually kinda not so bad
18:07:58 <Koterpillar> (\vs -> elem False vs == elem True vs) (take 1000000 $ repeat True)
18:08:27 <Koterpillar> ...
18:08:55 <Koterpillar> johnw: you win
18:09:17 <Koterpillar> > (\vs -> elem False vs == elem True vs) (take 1000000 $ repeat True)
18:09:19 <lambdabot>  False
18:09:25 <Koterpillar> ...surprising
18:09:37 <Koterpillar> > (\vs -> elem False vs == elem True vs) (take 100000000 $ repeat True)
18:09:42 <lambdabot>  mueval-core: Time limit exceeded
18:09:50 <Koterpillar> > (\vs -> case vs of [] -> True; (v:vs) -> not (all (== v) vs)) (take 100000000 $ repeat True)
18:09:56 <lambdabot>  mueval-core: Time limit exceeded
18:10:02 <Koterpillar> > (\vs -> case vs of [] -> True; (v:vs) -> not (all (== v) vs)) (take 10000000 $ repeat True)
18:10:05 <lambdabot>  mueval-core: Time limit exceeded
18:10:11 <Koterpillar> > (\vs -> case vs of [] -> True; (v:vs) -> not (all (== v) vs)) (take 5000000 $ repeat True)
18:10:13 <lambdabot>  False
18:10:23 <Koterpillar> > (\vs -> elem False vs == elem True vs) (take 5000000 $ repeat True)
18:10:28 <lambdabot>  mueval-core: Time limit exceeded
18:10:28 <lambdabot>  mueval: ExitFailure 1
18:10:33 <johnw> Koterpillar: you may want to take this to /query lambdabot 
18:10:39 <Koterpillar> sorry, noted
18:10:43 <johnw> thx
18:10:53 <Koterpillar> you win anyway :)
18:11:21 <johnw> yay?
18:12:58 <buglebudabey> if i've already started a haskell project (made a few files) it's not too late to make a stack package with those files, right?
18:13:10 <Koterpillar> not at all
18:13:16 <buglebudabey> awesome
18:13:23 <jle`> blargh: the 'lens' library offers a "traversal" with only a Functor constraint
18:13:28 <Koterpillar> do you have a cabal file?
18:13:41 <buglebudabey> no i don't even have cabal i don't think
18:13:42 <jle`> :t sequenceAOf _2 `asAppliedTo` (undefined,undefined)
18:13:44 <lambdabot> Functor f => (t, f b) -> f (t, b)
18:13:50 <buglebudabey> since i just installed stack alone
18:14:01 <jle`> > sequenceAOf _2 (1, Just "hello")
18:14:02 <lambdabot>  Just (1,"hello")
18:14:07 <buglebudabey> should I get it Koterpillar 
18:14:23 <Koterpillar> buglebudabey: no; create a new stack project, look at the resulting layout, copy files over
18:14:40 <buglebudabey> alright will do
18:14:46 <buglebudabey> thank you very much for your help today
18:14:55 <Koterpillar> yw
18:15:25 <puregreen> :t sequenceA `asAppliedTo` (undefined, undefined)
18:15:27 <lambdabot> Applicative f => (t, f a) -> f (t, a)
18:15:42 <jle`> yeah, it's overly constrained
18:16:53 <jle`> 'traverse' for `(,) e` actually works for all Functor (a -> f b), not just Applicatives, but you can't express that with the Traversable typeclass
18:16:58 <jle`> *Functor f
18:17:40 <jle`> same for Identity and some other common Traversables
18:17:52 <puregreen> I should probably go to sleep instead of trying to golf things that nobody needs golfed anyway
18:21:46 <blargh> whee haskell golf :D
18:22:00 <puregreen> :t app . first (fmap . (,))
18:22:01 <lambdabot> Functor f => (b, f a) -> f (b, a)
18:22:22 <blargh> supposed to be figuring out some science and here I am golfing.
18:25:30 <Zemyla> Is there a version of the Haskell platform for Windows which comes with LLVM?
18:25:54 <blargh> is there some tool that can take a bunch of functions and automatically make a command line tool based on their type signatures?
18:27:06 <dmj`> blargh: getopt-generics might be close to what you want
18:27:11 <dmj`> @package getopt-generics
18:27:11 <lambdabot> http://hackage.haskell.org/package/getopt-generics
18:27:49 <blargh> dmj` woohoo cool
18:37:35 <blargh> what do people do about pieces of records that are auxillary to a parse
18:37:43 <blargh> for instance, I have a record type witha fromJSON instance
18:38:01 <blargh> but I want to decorate that record information with additional fields made elsewhere
18:38:20 <blargh> I could define an entirely new type, but that seems pretty boilerplate-ish
18:38:35 <blargh> on the other hand, I could add extra optional fields that get filled in after the parse
18:38:55 <blargh> but that seems imperative-ish, with the possibility of invalid record states.
18:42:39 <chronon-io> clear
18:42:54 <chronon-io> oops, wrong terminal - sorry
18:48:07 * hackagebot aur-api 0.1.1.0 - ArchLinux AUR json v5 API  https://hackage.haskell.org/package/aur-api-0.1.1.0 (wangbj)
18:48:27 <pavonia> blargh: I asked about that same problem before here and was recommended to use a record type with an additional parameter :: * -> * that is appied to all the fields. So you can have it instantiated with Maybe when building the record, and convert to Identity for the final version
18:49:56 <blargh> pavonia hmm i don't know enough type level tricks to understand that.
18:50:39 <sebleblanc> Can I get rid of the binding to "x" in the following code? http://lpaste.net/329911131088879616
18:52:40 <blargh> pavonia is that similar to every parameter being of Maybe type and changing the type at runtime somehow?
18:53:14 <pavonia> blargh: So instead of "data Foo = Foo { a :: String }" you define "data Foo t = Foo { a :: t String }". Then you can have values of type "Foo Maybe" where each field is a Maybe, or or type "Foo Identity" where each field is a pure value wrapped in the Identity constructor
18:54:06 <blargh> that is a cool trick. Does that correspond to a particular extension?
18:54:38 <blargh> and then does that mean all fromJSON fields are assigned with .:?
18:55:10 <pavonia> I don't think it requires extensions
18:55:16 <blargh> and is there a boilerplate-free way to copy from the Foo Maybe intermediate to the Foo Identity?
18:56:12 <blargh> that is really weird. what is the type of the accessor functions in that case?
18:56:39 <pavonia> No one that gives decent information about where an error occurred
18:58:29 <pavonia> blargh: The accessor function just return the normal value, just either wrapped in Maybe or Identity
19:01:33 <pavonia> You could probably write a general conversion function using TH for any record type
19:16:54 <benzrf> blargh: Foo t -> t String, of course
19:18:08 * hackagebot nats 1.1.1 - Natural numbers  https://hackage.haskell.org/package/nats-1.1.1 (ryanglscott)
19:19:20 <refried_> is there a tidier way to write this function?  \a -> (a, f (g a) )
19:19:44 <refried_> apart from \a -> (a, (f . g) a)
19:20:06 <dibblego> (,) <*> f . g -- not checked
19:20:16 <Clint> @pl \a -> (a, f (g a) )
19:20:17 <lambdabot> ap (,) (f . g)
19:20:29 <dibblego> @type (,) <*> f . g
19:20:30 <lambdabot>     Could not deduce (Show b0) arising from a use of ‚Äòf‚Äô
19:20:30 <lambdabot>     from the context (Show a1, FromExpr a)
19:20:30 <lambdabot>       bound by the inferred type of
19:20:37 <dibblego> @type (,) <*> (f . g)
19:20:39 <lambdabot>     Could not deduce (Show b0) arising from a use of ‚Äòf‚Äô
19:20:39 <lambdabot>     from the context (Show a1, FromExpr a)
19:20:39 <lambdabot>       bound by the inferred type of
19:20:49 <Cale> f and g aren't what you want them to be
19:21:03 <Cale> :t \f g -> (,) <*> f . g
19:21:04 <lambdabot> (b -> a) -> (a1 -> b) -> a1 -> (a1, a)
19:21:08 <dibblego> ta
20:31:13 <sebleblanc> can a "case match" be worked into a function that accepts some value to match and returns (Maybe a), with Nothing if the pattern match fails?
20:33:05 <sebleblanc> in other words, given the function Integer -> Char in ( http://lpaste.net/5376871958749118464 ), what is the most elegant way to write this function to make it Integer -> Maybe Char ?
20:33:53 <glguy> 041 07-> Just 04'1'; 07...; _ 07-> Nothing
20:34:03 <glguy> Or you can use another function like
20:34:17 <glguy> lookup x [(041,04'1'), (042,04'2')] etc
20:34:24 <glguy> and then you can generate *that* list instead of typing it out
20:35:08 <glguy> In this particular case there's a function intToDigit, so:
20:35:23 <glguy> f x 07| isDigit x 07= Just (intToDigit x) 07| otherwise 07= Nothing
20:37:31 <sebleblanc> yeah, the code I provided is bogus, I don't have intToDigit in mind
20:37:44 <sebleblanc> the lookup trick is good, thanks
20:40:56 <AbelianGrape> Can anyone help me with Liquid Haskell? I'm having some basic issues. I made a data structure "data S a = C a (S a) | T". I'm having trouble writing recursive functions on it because Liquid Haskell doesn't count pattern matching on "C a t" and then recursing on "t" as a "decreasing parameter". It's like it doesn't know about structural recursion or something
20:41:42 <AbelianGrape> I could see how to do this if Liquid Haskell supported GADTs: You specify in the refined constructor type that the "length" measure on the tail is smaller than the "length" measure on the Cons-cell, and then you use the "length" measure as your decreasing parameter
20:41:56 <AbelianGrape> but I can't figure out how to refine a GADT and that seems too complicated
20:42:06 <AbelianGrape> in the tutorial they don't do anything special, but that's not working for me
20:43:54 <nkaretnikov> AbelianGrape: not very familiar with lh, but doesn't that mean that you need to write something like C a (S a) and then recurse on (the second a) to satisfy this condition?
20:44:04 <nkaretnikov> iirc, that's how it's done in Coq's Fixpoint.
20:44:22 <nkaretnikov> you could check the software foundations book for a good explanation
20:44:29 <nkaretnikov> i guess it's pretty similar in this case
20:44:39 <AbelianGrape> The second "a" in that term is a type variable, not a value: I can't recurse on it per se
20:44:59 <AbelianGrape> I'm probably just misunderstanding you
20:45:18 <AbelianGrape> s/term/expression
20:46:22 <nkaretnikov> AbelianGrape: yeah, i get that, was just sharing my thoughts.  anyway, i suggest you to look at the book. specifically the injective definition on peano numbers there, which shows how such things are defined
20:46:26 <nkaretnikov> but i may be wrong
20:46:46 <nkaretnikov> AbelianGrape: i just wanted to share some thoughts since no-one answered your q
20:47:56 <nkaretnikov> AbelianGrape: https://www.cis.upenn.edu/~bcpierce/sf/current/Basics.html#lab35
20:48:58 <AbelianGrape> Yeah the trick here is that LH does not appear to recognize that recursing on the argument of S (in your example) is decreasing
20:49:21 <AbelianGrape> I haven't tried peano numbers in LH, but the principle should be the same as with cons-lists
20:49:58 <AbelianGrape> This could be intentional because Haskell admits unbounded corecursion, but I'm not sure how to deal with it
20:51:06 <AbelianGrape> Is there a liquid haskell IRC or something? I've never really gotten any good help here
20:51:14 <AbelianGrape> It has to have some users; it's super tight
20:54:32 <nkaretnikov> i guess you could try asking on the cafe list
20:55:39 <AbelianGrape> Yeah might do that
20:55:42 <AbelianGrape> thanks
20:55:48 <glguy> bummer, seconds too slow
20:56:09 <glguy> It's too bad AbelianGrape didn't paste any code, the problem described doesn't show up in simple examples
21:10:12 <koz_> In a .cabal file, suppose I have a very large description, and I want to keep the file at 80 characters wide. Is there some kind of 'line continuation' escape sequence I should know, or is it all done with indentation?
21:10:51 <glguy> koz_: example: https://github.com/ekmett/lens/blob/master/lens.cabal
21:11:16 <refried_> thanks dibblego, Cale 
21:11:30 <refried_> + Clint 
21:11:38 <koz_> glguy: Ah, thanks!
21:32:19 <buttons840> anyone want to try to help me understand the switch operation in functional reactive programming?
21:32:54 <buttons840> i feel like i understand all the other primative operations and how they can be combined to accomplish things, but i don't have a good intuition for switch
21:39:47 <pavonia> buttons840: What part is unclear?
21:43:09 <buttons840> pavonia: my intiuition is that switch is a way of having the network modify itself
21:44:17 <buttons840> pavonia: does switch make large modifications to the network? for example, can it add several new "event streams" to the network, or can it only modify itself?
21:44:44 <buttons840> i'm probably relying too much on loose intuition right now, but it's where i'm at
21:45:21 <pavonia> Hhm, doesn't that depend on the implementation?
21:46:05 <buttons840> probably somewhere, there's some ambiguity in what people call "frp" i think
21:46:36 <buttons840> but in both sodium and reactive-banana switch is essentially Event (Event x) -> Event x
21:46:59 <buttons840> or Behavior (Behavior x) -> Behavior x
21:48:05 <buttons840> that type signatures seems to suggest that switch can only modify a small part of the network
21:50:38 <pavonia> It modifies that one event or behavior
21:51:59 <buttons840> pavonia: so the number of events and behaviors in the network is constant?
21:52:40 <buttons840> pavonia: i was originally picturing that a network could grow, adding new events and behaviors, although that sounds complicated, so if that is not how things are done i'm happy
21:52:49 <pavonia> I think so, yes. It doesn't add new behaviors to the network, it only modifies the current one
21:53:08 <koz_> I'm having a bit of trouble understanding how to define an Arbitrary instance for my type.
21:53:31 <koz_> Is there any kind of guide or tutorial to this?
21:53:46 <buttons840> pavonia: ok, that is what I was hoping to get help with; it's really helpful to have another person confirm my understanding is correct, so thank you
21:53:48 <Koterpillar> koz_: what kind of type?
21:54:40 <koz_> Koterpillar: Data Expr = Var Int | Neg Expr | Conj Expr Expr [Expr] | Disj Expr Expr [Expr]
21:54:43 <pavonia> buttons840: Note my knowledge about FRP is a bit rusty, haven't done anything in that field for years :S
21:54:46 <koz_> Additionally, Int must be 0 or above.
21:55:07 <Cale> buttons840: I find it's probably better to first understand the operations in terms of what they mean, rather than how they're implemented. What type does the switch you're looking at have?
21:55:20 <buttons840> pavonia: switch kind of feels like a transistor then
21:55:42 <buttons840> Cale: i mentioned the type above was Event (Event x) -> Event x
21:55:45 <koz_> And in any Conj or Disj, we cannot have 'gaps' in the Ints (so we can't have something like 'Conj (Var 0) (Var 10) []').
21:56:14 <buttons840> Cale: i am not attempting to look at their implementation right now
21:56:25 <Koterpillar> koz_: look at "Generator combinators" here: https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck.html
21:56:27 <koz_> Koterpillar: I basically need to understand the idea behind how Arbitraries are constructed.
21:56:32 <koz_> Koterpillar: Thanks!
21:56:54 <Koterpillar> koz_: so in your case: oneof [Var <$> arbitrary, Neg <$> arbitrary, ...]
21:57:26 <koz_> Koterpillar: But won't that (for example) potentially generate 'Var -1'?
21:57:34 <koz_> (which I specifically said can't exist?)
21:57:51 <Cale> buttons840: MonadMoment m => Event (Event a) -> m (Event a), isn't it?
21:58:00 <Koterpillar> perhaps for vars, use sample [0..10]?
21:58:18 <buttons840> Cale: yeah
21:58:44 <Koterpillar> koz_: or generate the list of variables, and then base your expressions on that
21:58:47 <buttons840> Cale: i'm kind of brushing over MonadMoment part, to me it just means you have to use switch when building the network in the MomentIO monad
21:58:52 <koz_> Koterpillar: I think the latter option is better.
21:59:03 <koz_> So would I use sized for that?
21:59:29 <Koterpillar> yes
21:59:31 <Cale> Well, that is actually important, in that occurrences of the input Event (Event a) before the time at which you're running this action don't count
21:59:36 <koz_> Koterpillar: OK, I'll give it another shot.
22:00:00 <Cale> The monad m can be thought of as a reader monad for the current time (though it's actually not implemented as one)
22:00:15 <buttons840> Cale: i'm not familiar with reader monad
22:00:54 <Cale> ah, well, you can think of  m a  as meaning  CurrentTime -> a  is what I mean
22:01:43 <Cale> Or I suppose just Time -> a, but with the understanding that it's always the current time that is being supplied
22:02:20 <Cale> and what this does is, it takes our input x :: Event (Event a)
22:02:26 <buttons840> Cale: ah, reader monad like implicitly passes a state around, am i remembering correctly?
22:02:34 <codedmart> How do I tell stack to rebuild my whole project?
22:02:40 <Cale> Well, usually it's called an "environment"
22:02:49 <Cale> since it doesn't change throughout running the actions
22:02:51 <Cale> action*
22:02:59 <Cale> But yeah
22:03:07 <Cale> It's just passing a function parameter around
22:03:38 <buttons840> Cale: ok, my understanding of haskell and the terminology used in the community are both pretty mediocer
22:03:47 <Cale> So, switchE does is to discard any occurrences of x before the current time (this is necessary because we don't actually store those in memory in the implementation)
22:04:29 <buttons840> Cale: so the whole frp network is like a ReaderMonad over time, it's like a black box that responds to event inputs, but also responds to time passing
22:04:30 <Cale> and then whenever x occurs subsequently, it occurs with some value  e :: Event a
22:04:51 <Cale> The network thing is a detail of how things are implemented
22:04:58 <Cale> For now don't worry about networks
22:05:56 <Cale> A value of type Event a is something which consists of a sequence of "occurrences" at particular points in time, and each occurrence has a value of type a
22:06:04 <Cale> and it doesn't have a value at other times
22:06:51 <Cale> A value of type Behavior a is something which has a value of type a at every time, and it might change more frequently than you can observe it
22:07:05 <buttons840> Cale: when I say "network" i'm thinking high level, i don't think that's an implementation detail -- i think of the "network" as just being the function that responds to events and time, that "network" is built out of the basic FRP functions like map, filter, merge, switch, etc
22:07:21 <buttons840> i'll try to follow your line of though though
22:07:39 <Cale> Well, okay
22:08:47 <Cale> I'm just saying to think of Events and Behaviors as values in their own right
22:09:21 <Cale> and these functions like map/filter/switch are just taking Events or Behaviors and producing others
22:09:23 <buttons840> Cale: yeah, that matches my understanding that Event is a "stream" and Behaviors are like a variable, except as you say a Behavior can change continuously unlike a variable
22:09:47 <buttons840> Behaviors are the way you keep state in the network
22:09:57 <Cale> and you don't have to worry so much about the fact that for efficiency's sake, the library is determining the dependencies between these things and doing lots of work to determine what needs to be computed
22:10:20 <Cale> (it is, but you don't have to think about that to understand what it all means)
22:11:22 <koz_> Koterpillar: This is making my head hurt.
22:12:08 <koz_> Koterpillar: Suppose I had a list [0 .. n]. How would I make [Gen Expr] out of that by making a Var with that respective index?
22:12:17 <buttons840> Cale: i am not worrying about performance or implementation right now; my understanding is that usually it's just standard push or pull (or both) event handling happening underneath, but most importantly that it doesn't matter and can change, it's just an implementation detail
22:12:18 <Cale> and yeah, that's correct about Behaviors -- via the operation that reflex calls 'hold' and reactive-banana calls 'stepper', they retain memory over time
22:12:36 <Koterpillar> koz_: elements
22:12:51 <koz_> Koterpillar: That'd give me Gen Expr by picking *one*.
22:13:13 <koz_> I'm trying to construct an expression tree bottom-up, essentially.
22:13:19 <koz_> (which I assume is how you would do it.
22:13:21 <koz_> )
22:13:25 <Cale> So, I wanted to describe this switch operation... it's weird to me that reactive-banana doesn't have it as Behavior (Event a) -> m (Event a)
22:13:30 <Koterpillar> so, Var <$> elements [0..n] :: Gen Expr
22:13:34 <Cale> but either way, it makes sense
22:13:59 <koz_> Koterpillar: Is constructing the expression tree bottom-up the right way to go?
22:14:05 <Koterpillar> yes, I think so
22:14:09 <buttons840> Cale: well it has Behavior (Behavior a) -> Behavior a   -- as well as the Event version mentioned before; they're called switchB and switchE
22:14:16 <Koterpillar> oh, wait, sorry, I am going from the top
22:14:32 <Koterpillar> i.e. I'll choose either Var or Expr... what was your () constructor?
22:14:47 <koz_> Koterpillar: Data Expr = Var Int | Neg Expr | Conj Expr Expr [Expr] | Disj Expr Expr [Expr]
22:14:51 <koz_> Tree looks hence.
22:14:56 <buttons840> i'm interesting in your description of switch though
22:14:59 <Cale> It's just that it's more natural to me to start with  Behavior (Event a)
22:15:01 <koz_> Additionally, Int must be 0 or above.
22:15:07 <koz_> And in any Conj or Disj, we cannot have 'gaps' in the Ints (so we can't have something like 'Conj (Var 0) (Var 10) []').
22:15:12 <koz_> ^ additional constraints.
22:15:16 <Cale> because there's always some current Event that you're observing the occurrences of
22:15:22 <koz_> It's those additional constraints that I'm not sure how to deal with.
22:15:38 <Koterpillar> ok, so arrbitrary = sized $ \var_count -> oneof [Var <$> [0..var_count], Conj <$> arbitrary <*> arbitrary]
22:15:49 <buttons840> Cale: you mean whenever code is running in the network it is because an event was fired?
22:15:55 <Koterpillar> koz_: so Conj must be 0 1 2?
22:15:59 <Koterpillar> can it be 2 0 1?
22:16:14 <Cale> buttons840: I don't know how to interpret that in the context of the stuff I said
22:16:17 <koz_> Conj can contain other Conjes.
22:16:29 <koz_> Koterpillar: Let me write up some examples.
22:16:34 <koz_> Hopefully it'll make it clearer.
22:16:35 <Koterpillar> koz_: yes, that'll be nice
22:16:37 <buttons840> Cale: nevermind
22:16:39 <Cale> I mean, the idea of switchE is that you have an Event (Event a), and whenever it occurs, it gives you a new Event a
22:17:17 <Cale> and if x :: Event (Event a) is this event we put in
22:20:17 <Cale> then when we execute switchE x, the resulting event will start out as the Event which never occurs, and whenever x occurs (subsequently to our executing the switchE), the output Event will switch and mimic the value in the occurrence of x
22:20:39 <Cale> Whenever x occurs, it gives us a new e :: Event a to use
22:21:23 <Cale> and so our output event will occur when that event e occurs... until x occurs again, swapping it out for another e' :: Event a
22:21:40 <Cale> Does that make sense?
22:21:55 <Cale> Perhaps I should make a picture...
22:22:12 <buttons840> it makes some sense: "as the Event which never occurs" confused me though
22:22:37 <Cale> Well, it's like we're switching which Event a we're observing
22:22:40 <lpaste> koz_ pasted ‚ÄúKoterpillar: Hopefully this explains it‚Äù at http://lpaste.net/166385
22:22:46 <buttons840> i'm getting some insight though, hopefully the insight you intended :)
22:22:48 <Cale> and we start out observing the Event a which never occurs
22:23:06 <Cale> and then start observing some other Event a, the first time that x occurs
22:23:17 <Cale> (the first time *after* we executed the switchE)
22:23:23 <buttons840> Cale: i'm thinking the interesting question is, where does Event (Event x) come from? probably not from the outside world, but from the earlier nodes in the network
22:23:49 <Koterpillar> koz_: is Conj (Disj 0 1) 3 ok?
22:23:58 <koz_> Koterpillar: Nope - missing 2.
22:24:28 <Cale> buttons840: Well, imagine a GUI library which gives you some tabbed dialog widget for example
22:24:35 <Koterpillar> koz_: is it true that for _every_ expression, if you take all the variables and flatten, they'll be [0..n]?
22:24:37 <buttons840> Cale: so the frp operations give us powerful ways to combine and create new event streams (sticking with events as an example), so we might chose to make an event of events, but in order to utilize this event of events we need switch to flatten it
22:24:51 <buttons840> in haskell, what is the m (m a) -> m a function?
22:24:52 <koz_> Koterpillar: Yes, though not necessarily in that order.
22:25:08 <buttons840> mconcat or something?  or was it sequence?
22:25:11 <buttons840> :t sequence
22:25:12 <Cale> There's join
22:25:12 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:25:17 <Koterpillar> koz_: example of when they are not in order?
22:25:21 <buttons840> :t join
22:25:22 <lambdabot> Monad m => m (m a) -> m a
22:25:27 <Cale> But with Event, there are many different ways to "flatten" that you might want
22:25:31 <buttons840> oh yeah, so switch is the join of FRP
22:25:44 <koz_> Conj (Var 1) (Var 0) [], when flattened, would give [1, 0]
22:25:45 <Cale> Event isn't naturally a monad
22:26:25 <Cale> If it were, return :: a -> Event a would have to be an Event which was always occurring, which isn't something that is usually desirable or meaningful
22:26:26 <Koterpillar> koz_: is Conj (Conj 3 2) (Conj 1 0) fine?
22:26:37 <koz_> Koterpillar: Yep.
22:27:39 <Koterpillar> koz_: first, I'll skip Disj from now on, it's the same as Conj and you can always oneof it 
22:27:45 <koz_> OK.
22:27:50 <Cale> (in fact, usually you even want to ensure that there is a minimum distance between occurrences of your events, so that the system doesn't have more computation to do as a consequence of each occurrence than it can actually accomplish between the firings)
22:28:08 <Koterpillar> koz_: how about you start with the [0..n] list and then if you want to generate a Conj, split the list at a random point, possibly reverse the parts and pass to two Conj's?
22:28:45 <koz_> How would I decide the split point arbitrarily? choose?
22:28:58 <Koterpillar> yes
22:29:24 <Cale> buttons840: But yeah, these higher order combinations of Events and Behaviors are often the result of user interfaces which switch between different views -- you might have something which switches between multiple widgets, providing an Event of the result of running the widget whenever it switches
22:29:25 <buttons840> Cale: going back, is my observation that Event (Event x) probably comes from inside the network rather than from the outside accurate?
22:29:31 <Koterpillar> I have no idea if the resulting distribution will be any good, but all the possible combinations will be there
22:29:33 <koz_> OK, now about the 'possibly reverse the parts' - how would I make that decision arbitrarily and then use that value? Just use Gen's monadic interface I guess?
22:29:51 <Cale> buttons840: and then if the result is *itself* an Event (say representing various possible button clicks on that tab view)
22:30:01 <koz_> So like, use choose (False, True) and then bind into it?
22:30:07 <Cale> you might want a way to switch between which result you're looking at
22:30:40 <koz_> (or use do-notation, I guess...)
22:30:43 <Koterpillar> koz_: more like elements
22:30:52 <Cale> buttons840: I find it hard to answer questions like that, because I don't really think that way, but I suppose it's true.
22:31:03 <koz_> Koterpillar: So elements [False..]?
22:31:05 <Koterpillar> koz_: you might want to build a list splitter function
22:31:14 <buttons840> Cale: i imagine if someone clicks a tab on a GUI, i would get something like Event () on an input, not an Event (Event ())
22:31:15 <Cale> buttons840: Well, does it count as coming from outside if the Event is provided by a GUI driver?
22:31:22 <Koterpillar> koz_: elements [False, True]
22:31:36 <koz_> > [False..]
22:31:38 <lambdabot>  <hint>:1:9: parse error on input ‚Äò]‚Äô
22:31:43 <buttons840> Cale: yes, i think events from the GUI frameworld are "the outside"
22:31:47 <koz_> > [False ..]
22:31:49 <lambdabot>  [False,True]
22:31:52 <Koterpillar> ok, that
22:31:57 <Cale> here, let's take a look at an example from reflex...
22:32:04 <koz_> Koterpillar: OK, I think I got it now - thanks!
22:32:12 <koz_> It *just* hit me that Gen is a monad...
22:32:26 <Koterpillar> yes, that helps
22:33:02 <buttons840> Cale: all events come from the outside, right? a FRP network cannot just fire an event by itself? i guess it could recursively, one of the outputs of the network could fire an input event
22:33:11 <Cale> buttons840: reflex-dom gives you an operation:  dyn :: MonadWidget t m => Dynamic t (m a) -> m (Event t a)
22:33:17 <koz_> Koterpillar: For the arbitrary instance for my tree type, I can use choose (1, whatever) as a starting point (for how many Var indices I want). Is it sensible to cap 'whatever' to something small?
22:33:20 <koz_> Like, 10 or so?
22:33:24 <koz_> Or should I not cap it at all?
22:33:28 <Koterpillar> sized
22:33:38 <Cale> buttons840: To understand this, first of all, just ignore the t type parameters
22:33:46 <buttons840> Cale: reflex...  i looked at it but it's API was considerably scarier IMO
22:33:49 <koz_> Koterpillar: With sized, I could get 0 or negatives, which isn't useful.
22:33:57 <koz_> I mean, I guess I *could* abs it.
22:34:33 <Koterpillar> there's also Positive: https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck.html#t:Positive
22:34:36 <Cale> Secondly, Dynamic is a data structure which consists of an Event and a Behavior paired up in such a way that the Behavior only ever changes when the Event occurs, and changes to the value that the Event occurs with immediately following the occurrence of the Event
22:34:53 <Cale> (i.e. it won't have changed at the time that the Event is occurring, but at all subsequent times)
22:34:54 <koz_> Koterpillar: Oh? OK.
22:34:57 <Koterpillar> koz_: Positive varCount <- arbitrary
22:35:46 <koz_> Koterpillar: OK, that gives me everything I need - thank you very much!
22:36:27 <buttons840> Cale: so Dynamic is like a hold of sorts, but higher level
22:36:29 <Cale> anyway, what this does is to run the contents of the Dynamic, which is a MonadWidget action, that means it's usually going to write some stuff into the DOM and display some part of your UI (at least, that's typical)
22:36:33 <Cale> yeah
22:36:46 <Cale> it's like the result of a hold, paired up with the Event being held
22:37:09 <Cale> So that you can get prompt notifications of when the thing is changing, as well as its current value
22:37:29 <buttons840> Cale: and yeah, I know there's an implementation decision about when Behavior are seen as having updated and potential pitfalls with recursion, it looks like most libraries just don't show the updated behavior value until the current event is finished
22:37:44 <Cale> yeah
22:37:52 <Cale> That's the right way to make that call, in my experience
22:38:16 <Cale> *sometimes* you want the other thing, but usually it just gets you into trouble with recursion
22:38:41 <Cale> so anyway, what this dyn thing does is to give you a dynamically changing widget
22:39:31 <Cale> an action of type m a here is something which can do pretty much arbitrary FRP stuff (holds and whatnot), as well as define some part of the DOM which is making up your page
22:39:56 <Cale> The order of execution in the monad is almost arbitrary, but is used mainly to determine which order things are laid out on the page.
22:40:37 <buttons840> Cale: about an implementation detail; the code that makes up the FRP network is not running (as in, not using the CPU) unless a specific event (or events) are being processed, correct?
22:40:38 <Cale> So here, this dyn combinator takes as its input a Dynamic widget
22:40:43 <Cale> right
22:41:28 <Cale> and it starts out by running the action which is the current value of the Dynamic, getting some result of type a, and probably displaying some stuff on the page in the process (perhaps some buttons)
22:42:18 <buttons840> Cale: need to leave in about 5 mins
22:42:27 <Cale> and each time that the Dynamic changes, it switches out the widget, running some new widget, and getting a new result of type a
22:42:41 <Cale> Whenever it does this, the Event which is its result fires
22:43:14 <Cale> Now, the important thing to notice here is that the type 'a' might itself consist of an Event representing the various actions a user might have taken with the UI that was being displayed
22:43:28 <Cale> So then we'd end up with an Event t (Event t UserAction)
22:44:08 <Cale> Or you might have, say, a colour picker with multiple different modes that it can be in, HSV, RGB and whatnot
22:44:40 <Cale> and so the input Dynamic widget would switch between different modes, but whichever mode you were in, you'd be getting a Dynamic t Colour result
22:44:49 <Cale> So then you'd have an Event t (Dynamic t Colour)
22:45:09 <Cale> buttons840: Does that sort of make sense?
22:45:32 <Cale> That's the natural sort of way that these nested Events and Behaviors show up in GUI settings anyway
22:45:39 <buttons840> Cale: still reading; is Dynamic an alternative to switch in anyway? or is it used with switch?
22:45:42 <Cale> UIs that switch between multiple views on something
22:45:51 <koz_> Koterpillar: These combinators are awesome!
22:46:00 <Cale> There are switch-like operations which work on Dynamic
22:46:29 <Cale> switchPromptlyDyn :: forall t a. Reflex t => Dynamic t (Event t a) -> Event t a
22:47:10 <Koterpillar> koz_: IKR? That's generally the case with combinators
22:47:16 <Cale> This is a switch which can be used in the case that you care about the case where the Dynamic is updated to a new Event value, and the Event it's switching to occurs at that very moment
22:47:30 <Cale> Its output Event will fire in that case
22:47:42 <koz_> Koterpillar: Yeah, and the fact Gen is a monad is kinda sick too.
22:47:44 <Cale> (with the *new* Event's value, if both were occurring)
22:48:19 <Cale> You can also turn the Dynamic t (Event t a) into a Behavior t (Event t a) by applying  current :: Dynamic t a -> Behavior t a
22:48:31 <Cale> and then reflex has:  switch :: Behavior t (Event t a) -> Event t a
22:48:34 <buttons840> Cale: hmm, i definiately got some new insights, but i'm not sure i got all the insights you wanted me too
22:48:38 <buttons840> :)
22:48:55 <Cale> which creates an Event that occurs whenever the Event which is the current value of the Behavior occurs
22:49:22 <buttons840> i'm going to check out reflex after reactive-banana, but refelx has less documentation
22:49:27 <Cale> The switchE in reactive-banana can be understood as a hold never, followed by this switch
22:49:43 <Cale> Yeah, that's something we really hope to be able to work on at some point
22:50:10 <buttons840> reflex looks exciting, but yeah, the API is a lot more intimidating as a newcomer
22:50:19 <Cale> I'm working for Obsidian Systems, and we use reflex and reflex-dom for production web applications for various clients
22:50:39 <buttons840> Cale: are you the author of reflex?
22:51:05 <Cale> No, I've contributed a tiny amount, but it's mostly Ryan Trinkle's work
22:51:10 <buttons840> Cale: i did watch the reflex talks, and checkec out obsidians site, which is nice i guess, but slow to load (especially on mobile)
22:51:22 <Cale> We worked together on earlier FRP systems that inspired reflex and sodium thought
22:51:24 <Cale> though*
22:51:37 <Cale> Yeah, that's changing soon!
22:51:49 <Cale> Luigy just implemented server-side rendering for reflex-dom
22:51:51 <buttons840> been reading the FRP book from manning, but it's got a lot of really verbose java :(
22:53:08 <Cale> So we'll be able to run the reflex code on the server side at first to serve you up static pages that still behave as they should (if a bit slower to react, but quicker to load)
22:53:40 <Cale> and then at some point, we also hope to implement switching over to the client-side reflex-dom application once it's downloaded
22:53:55 <buttons840> Cale: if I were to write a FRP tutorial, i would write what the 10 basic FRP operations are along with some illustrations on how you can combine them (like how to make an accumulator), and then talk about how you can setup inputs and outputs with the ouside world -- and that's pretty much where i'm at now
22:54:02 <Cale> yeah
22:54:08 <buttons840> just looking for experience now now that i have the basics down
22:56:21 <Cale> buttons840: The documentation for reflex is still a bit scary, but there is a tutorial here that you might want to try if you're interested :) https://github.com/reflex-frp/reflex-platform
22:56:33 <buttons840> i may not have looked in the right places, but i was suprised there wasn't any simple FRP tutorials out there; i couldn't find any that simply tell me what a hold, map, merge, etc are
22:57:28 <Cale> Yeah... I think at present a lot of this information is travelling primarily by word of mouth -- there are some papers on it too, but...
22:57:47 <buttons840> Cale: oh, i did run accross that but skipped it because ghcjs + me not being super experienced with the DOM api was too much
22:58:17 <buttons840> my current experiments are just on the command line, which is really not a great showcase for FRP, but works
22:58:28 <Cale> Oh, if you grab that git repo, there is a try-reflex script in it, that will download everything you need, and give you a self-contained shell that has the right versions of everything
22:58:49 <Cale> (We actually use it for our production work :)
22:59:20 <Cale> It's way more convenient than trying to build ghcjs yourself
22:59:53 <buttons840> Cale: for the sake of feedback, i didn't use that script because i would rather have build ghcjs myself (which i have done, it's pretty easy with stack), and i'm werry of running random scripts on my machine
23:00:21 <buttons840> i might take a look though
23:00:56 <Cale> Well, I hope it's not malicious in any way, I run it several times a day :P
23:01:06 <sbrg> I really need to dive in and take a look at reflex + ghcjs at some point. if it performs okay and is usable, I might get to replace some our stuff(which is scalajs + scalajs-react) with it
23:01:13 <buttons840> it's not the setup that scares me away though, it's mainly that GHCJS is in a beta state (at best) and i'm not familiar with the DOM apis; so it seems like a lot of new technologies at once when what I"m really trying to learn is just FRP for now
23:01:17 <sbrg> and then I'd be writing Haskell for money and have achieved my dream!
23:01:48 <reqq456> what are the best 'learning haskell' resources for you? i'm currently walking through learnyouahaskellforgreatgood and it is great, i've known some basics before, do you recommend any further guides or what i should learn next?
23:02:20 <Cale> reqq456: There's http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
23:02:39 <buttons840> Cale: i'm trying to follow the "one new tech at a time" rule here; i want to learn FRP in a familiar environment (like the command line), not in the unknown world of GHCJS + the terrible DOM apis, and browser imcompatibilities, etc
23:03:14 <reqq456> thx Cale i will look at it
23:04:05 <Cale> buttons840: Here's a little "incremental game" I wrote in 5 minutes with reflex-dom :)  http://cale.yi.org/share/incremental.jsexe/
23:04:24 <Cale> (it's not much of a game, but it demonstrates a few ideas :)
23:05:16 <buttons840> Cale: thank you again for all the help, i did gain a lot of new insights and I'm no longer stuck on some experiements I was doing, so it really did help
23:05:23 <Cale> cool
23:05:28 <buttons840> Cale: the drones are OP :)  that game is suprisingly addictive for how simple it is
23:08:48 <sbrg> can ghcjs work with servant? That is, could I write a server using Servant and then use the route types to implement type-safe routers in the ghcjs front-end code?
23:16:25 <reqq456> can someone tell me why you should annotate every function with a signature, even if haskell has a really good type guessing system, isn't it unneeded work then?
23:17:05 <mauke> humans read code, too
23:17:23 <sbrg> reqq456: Well, for someone else reading your code, it is helpful to have the types. Moreover, when you enable certain extensions, the type inference engine sometimes doesn't work too well and you need explicit signatures for things to work the way you intended
23:17:52 <reqq456> okay thanks
23:18:06 <Koterpillar> reqq456: and to contain your type-level mistakes inside one function
23:19:03 <reqq456> okay i just wondered because mostly the compiler said to me that i've wrote a wrong type signature 
23:19:49 <Koterpillar> that, in my opinion, is better than being told that something is wrong where the function is called
23:20:02 <Koterpillar> I can see that I _defined_ it wrong, not _called_ it wrong
23:20:20 <reqq456> yeah ofc
23:20:37 <zRecursive> ls
23:20:46 <sbrg> .
23:20:48 <sbrg> ..
23:23:06 <ggVGc> top level functios without type sigs are just a nightmare
23:23:10 <ggVGc> if changing anything
23:23:38 <ggVGc> I often but local type sigs in where bindings also, becase it helps me guide my writing
23:23:43 <ggVGc> and makes it easier to use holes
23:23:48 <ggVGc> (holes are amazing btw)
23:24:17 <sbrg> yeah
23:25:29 <ggVGc> I seldom write my own top level type sigs though. Often I just write the function and then use ghc-mod to generate it
23:25:36 <ggVGc> so that if I need to change it, it's there
23:27:10 <sbrg> I often leave them out when working on the function as well. or make the last arrow -> _ so that I can easily return whatever type without type errors
23:52:00 <sshine> sbrg, or: .    ..    Downloads/    Documents/    letter_to_mom.txt    hamster_simulator*
23:55:24 <reqq456> http://pastebin.com/2a7Q7yzv, what would be the correct typesignature for this function? 
23:55:46 <hunteriam> why cant dependent types be rendered as something like assertions at run time, and removing any mention of types?
23:55:47 <reqq456> the compiler suggests to use Ord, but  if I swap Num with Ord it is also not working
23:56:25 <Koterpillar> reqq456: (Num a, Ord a) => a -> a
23:56:27 <hunteriam> you need num and ord
23:56:37 <reqq456> ah, i can use two typeclasses, thx
23:56:40 <hunteriam> the reason is because you use * and > on x
23:56:46 <koz_> reqq456: You can use as many as you need.
23:56:46 <hunteriam> * requires num and > ord
23:57:19 <oherrala> :t \x -> if x > 100 then x else x * 2
23:57:20 <lambdabot> (Num a, Ord a) => a -> a
23:57:45 <oherrala> Haskell can also automatically tell you that ;)
