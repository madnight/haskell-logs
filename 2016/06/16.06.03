00:07:38 * hackagebot rex 0.5.2 - A quasi-quoter for typeful results of regex captures.  https://hackage.haskell.org/package/rex-0.5.2 (MichaelSloan)
00:07:38 * hackagebot template-default 0.1.2 - declaring Default instances just got even easier  https://hackage.haskell.org/package/template-default-0.1.2 (DanielWagner)
00:09:49 <spion> hope this question makes sense... is stToIO atomic?
00:10:39 <coppro> it doesn't really
00:11:02 <shachaf> stToIO is effectively just unsafeCoerce
00:11:38 <coppro> not sure I'd agree with that characterization
00:11:44 <coppro> but it is definitely a coercion function
00:11:50 <coppro> it doesn't execute anything really
00:13:08 <spion> ok, so I guess if multiple ST actions were involved, I should probably use a lock (e.g. an MVar)
00:13:35 <spion> (though I'm sure there is a better way to do it than that... its still *a* way)
00:13:46 <coppro> multiple ST actions can't interact
00:14:19 <spion> coppro: when coerced to IO.
00:14:56 <EvanR> ST actions cant access MVars
00:15:10 <EvanR> or shared IORefs, or 
00:15:39 <coppro> yeah, I'm not quite sure what you're talking about now
00:15:40 <zinking> -- ie:  get 1 -> (1,1) get :: State s s get s = (s,s)
00:15:41 <spion> you can lock with an mvar, coerce the ST action to IO and run that, then unlock
00:16:07 <coppro> oh, yes
00:16:11 <zinking> how would get give the current value, if it is defined so 
00:16:26 <coppro> yeah, that's what you need to do if you want the ST action to be atomic with respect to other actions in the IO state thread
00:16:49 <spion> coppro: thats what I wanted to ask, thanks for expressing it clearly :)
00:17:07 <EvanR> they its not a question of the ST action itself
00:17:32 <shachaf> coppro: Why don't you like that characterization?
00:18:02 <spion> EvanR: possibly. I didn't quite understand stToIO for sure, but now I see that its basically "yeah, this whole thing is IO not ST"
00:18:05 <spion> :)
00:18:08 <shachaf> The actual implementation is stToIO (ST m) = IO m, where ST and IO are newtypes for the same thing.
00:25:13 <zinking> get method in State monad is defined as get s = (s,s)
00:25:27 <zinking> in this case , how would the state value be extracted ?
00:25:44 <shachaf> Extracted from what?
00:27:50 <zinking> (on, score) <- get
00:28:15 <zinking> like this one, from the function definition, I can't image score (value) be extracted
00:28:19 <Axman6> zinking: do {myState <- get; <do things with myState>; put newState; ...}
00:29:13 <zinking> Axman6: I can understand that .
00:29:43 <zinking> I can't understand how `get` is implemented 
00:29:44 <zinking> get s = (s,s)
00:29:52 <zinking> https://wiki.haskell.org/State_Monad
00:30:18 <coppro> zinking: State s a is isomorphic to s -> (s, a)
00:30:27 <coppro> it is a function which, given a state, computes a new state and a result
00:31:08 <coppro> in that example, they're treating it as just being aliases of one another
00:31:18 <Rotaerk> get doesn't modify the state, but it puts the state into the result... so get s = (s, s) makes sense
00:31:21 <coppro> in Control.Monad.State, it's a newtype wrapper
00:31:41 <coppro> what get does, is it takes the current state, then leaves that state s the new state and provides it as a result
00:34:31 <zinking> <coppro> zinking: State s a is isomorphic to s -> (s, a),  I'm quite familiar the math context. but left hand side is `State` the right hand side is `function`. I am even more confused
00:34:40 <fr33domlover> The State monad doesn't hold the actual state. When you contruct a State computation, you simply construct a state modifier function that takes some initial state, and returns the modified state after all the changes, if you made any. With StateT, that can be interleaved with actions of the base monad etc.
00:34:46 <zinking> not quite familiar
00:35:25 <EvanR> newtype State s a = MkState (s -> (s,a))
00:35:29 <fr33domlover> zinking, think of State as a wrapper of a function
00:35:39 <fr33domlover> yeah that :P
00:35:42 <EvanR> get = MkState (\s -> (s,s))
00:36:00 <EvanR> newtypes are isomorphic to whatever type they wrap
00:36:15 <fr33domlover> zinking, if you haven't yet, read about monads and State in the Haskell Wikibook
00:37:19 <EvanR> runState get 'x'
00:37:24 <EvanR> ('x','x')
00:38:01 <EvanR> runState just applies the function to the initial state
00:38:16 <zinking> hmm, right reminds me of Monad -> Functor -> wrapper of function. so the isomorphism make sense now. 
00:39:38 <zinking> still if get s = (s,s) how would I get the `a` out of a state
00:39:39 <zinking>  ?
00:39:49 <zinking> as demoed in the example 
00:39:54 <EvanR> > let a = ('x','x') in a
00:39:56 <lambdabot>  ('x','x')
00:39:58 <Axman6> that is generally not how get is implemented btw
00:39:59 <EvanR> erm
00:40:07 <EvanR> > let (_,a) = ('x','x') in a
00:40:08 <lambdabot>  'x'
00:40:36 <Axman6> since state in practice is implemented as a newtype, it must be defined as get = State (\s -> (s,s))
00:40:40 <coppro> @src get
00:40:41 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:41:02 <Axman6> get iirc is defined in MonadState
00:41:13 <coppro> Axman6: get = state $ \s -> (s, s)
00:41:26 <coppro> in Control.Monad.Trans.State.Lazy
00:41:30 <Axman6> right
00:42:28 <zinking> https://wiki.haskell.org/State_Monad implement section #get#
00:43:47 <Axman6> yeah I wouldn't use that page, since it differes a lot from reality (though conceptually is correct)
00:44:31 <Axman6> it might be instructive to see what get >>= return expands to
00:45:03 <zinking> but conceptually I didn't follow as well. how can get be defined as (s,s) , I could understand if it is something like get s = (s,a)
00:45:10 <zinking> (a,s)
00:45:21 <Axman6> what is a?
00:45:23 <EvanR> in get s = (s,a), a is not defined
00:45:28 <Axman6> there is no input value named a
00:45:38 <zinking> right 
00:45:51 <Axman6> what get does is takes the current state, and returns that state, and leaves the state unmodified
00:46:07 <Axman6> get :: State s s -- correct?
00:46:13 <zinking> playGame (x:xs) = do     (on, score) <- get
00:46:19 <zinking> in example 1, there's such code
00:46:24 <Axman6> which expands to basically get :: s -> (s,s)
00:46:51 <Axman6> so in that case, get :: State (Bool, Int) (Bool,Int)
00:46:51 <EvanR> so get :: State (Bool,Int) (Bool,Int) in that example
00:47:00 * EvanR leaves
00:47:08 <Axman6> no, I act5ually need to leave :P
00:47:21 <Axman6> you got this EvanR!
00:47:28 <EvanR> no you got it!
00:47:44 <EvanR> jk
00:51:26 <zinking> ah, I see my problem now. 
00:51:34 <zinking> silly me. thanks for the dicussion
01:19:00 <tobiasBora> Hello,
01:19:10 <Akii> hi
01:19:33 <tobiasBora> Is it possible to use Chart to plot a matrix-like data ?
01:21:53 <Athas> What determines whether or not a GHC-built executable links to libffi?
01:57:48 <EvanR> is there a way to abuse fail to see if anything in a list matches the patter
01:58:25 <EvanR> Foo <- anyAbuse [x,y,z,w]
01:58:34 <EvanR> it only fails if there are no Foo
01:58:39 <merijn> EvanR: Trivial in list comprehension
01:59:04 <EvanR> i guess i should implement Alternative or something?
01:59:13 <merijn> "(_:_) <- [x | x@Foo{} <- [x,y,z]"
01:59:17 <EvanR> or MonadZero?
01:59:20 <merijn> Eh, missing ] there
01:59:53 <merijn> If there's no Foo in [x,y,z] it produces an empty list which fails on (_:_)
02:00:04 <Maxdamantus> O_o didn't know patterns were allowed to fail in list comprehensions.
02:00:18 <merijn> Maxdamantus: Pattern fail is equal to skip :)
02:00:24 <Maxdamantus> > [a | Left a <- [Left 1, Right 2]]
02:00:27 <lambdabot>  [1]
02:00:43 <EvanR> > [x | Just x <- [Nothing, Just 'x', Nothing]]
02:00:44 <lambdabot>  "x"
02:00:54 <merijn> Maxdamantus: On a scale of 1 to 10, how much did that improve your life? ;)
02:01:24 <Maxdamantus> 0
02:01:37 <merijn> Maxdamantus: Means you need to use more lists :p
02:01:52 <EvanR> ok but the pattern got moved out of the original do notation
02:02:05 <Maxdamantus> Means my belief that list comprehensions should be replaced with do blocks is slightly diminished.
02:02:05 <EvanR> i cant use this for an existing monad
02:02:59 <simpson> Maxdamantus: How do you feel about monad comprehensions?
02:03:17 <Maxdamantus> Dunno. What are monad comprehensions?
02:03:26 <Maxdamantus> Something to do with monad transformers?
02:03:46 <simpson> Generalized list comprehension syntax that works on monads besides [].
02:04:05 <Maxdamantus> Oh, okay. Not something for creating monads.
02:05:19 <EvanR> :t msum
02:05:20 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
02:07:36 * hackagebot amazonka-core 1.4.2 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.2 (BrendanHay)
02:07:38 * hackagebot amazonka 1.4.2 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.2 (BrendanHay)
02:07:40 * hackagebot amazonka-test 1.4.2 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.2 (BrendanHay)
02:07:42 * hackagebot amazonka-dynamodb 1.4.2 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.4.2 (BrendanHay)
02:07:44 * hackagebot amazonka-datapipeline 1.4.2 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.4.2 (BrendanHay)
02:10:13 <Maxdamantus> simpson: well, I generally like the idea of having a single overall construction to replace do/list comprehensions .. that might involve adding small extensions to the `do` construct and allowing it to pick classes other than Monad.
02:12:02 <Maxdamantus> but that's a bit weird when you always have some expression at the beginning that will be applied to `return`.
02:12:46 * hackagebot amazonka-iam 1.4.2 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.4.2 (BrendanHay)
02:12:48 * hackagebot amazonka-discovery 1.4.2 - Amazon Application Discovery Service SDK.  https://hackage.haskell.org/package/amazonka-discovery-1.4.2 (BrendanHay)
02:12:50 * hackagebot amazonka-kinesis-firehose 1.4.2 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.4.2 (BrendanHay)
02:12:52 * hackagebot amazonka-route53-domains 1.4.2 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.4.2 (BrendanHay)
02:12:54 * hackagebot amazonka-directconnect 1.4.2 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.4.2 (BrendanHay)
02:13:59 <Cale> I think it's not so much intended as a replacement for all do-notation, but just to be used sometimes, when there's a particular focus on the elements being produced.
02:17:56 * hackagebot amazonka-sqs 1.4.2 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.4.2 (BrendanHay)
02:17:58 * hackagebot amazonka-devicefarm 1.4.2 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.4.2 (BrendanHay)
02:18:00 * hackagebot amazonka-cognito-sync 1.4.2 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.4.2 (BrendanHay)
02:18:02 * hackagebot amazonka-elb 1.4.2 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.4.2 (BrendanHay)
02:18:04 * hackagebot amazonka-ecs 1.4.2 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.4.2 (BrendanHay)
02:23:06 * hackagebot amazonka-marketplace-metering 1.4.2 - Amazon Marketplace Metering SDK.  https://hackage.haskell.org/package/amazonka-marketplace-metering-1.4.2 (BrendanHay)
02:23:08 * hackagebot amazonka-cloudformation 1.4.2 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.4.2 (BrendanHay)
02:23:10 * hackagebot amazonka-sts 1.4.2 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.4.2 (BrendanHay)
02:23:12 * hackagebot amazonka-autoscaling 1.4.2 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.4.2 (BrendanHay)
02:23:14 * hackagebot amazonka-certificatemanager 1.4.2 - Amazon Certificate Manager SDK.  https://hackage.haskell.org/package/amazonka-certificatemanager-1.4.2 (BrendanHay)
02:23:41 <Maxdamantus> Anyone up for a game of spot the typing atrocity? https://github.com/couchbase/couchbase-jvm-core/blob/master/src/main/java/com/couchbase/client/core/ClusterFacade.java
02:24:19 <EvanR> .java
02:24:33 * Maxdamantus was anticipating that.
02:25:26 <Maxdamantus> (that's not the actual answer)
02:28:16 * hackagebot amazonka-kinesis 1.4.2 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.4.2 (BrendanHay)
02:28:18 * hackagebot amazonka-kms 1.4.2 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.4.2 (BrendanHay)
02:28:20 * hackagebot amazonka-cloudsearch-domains 1.4.2 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.4.2 (BrendanHay)
02:28:22 * hackagebot amazonka-cloudwatch 1.4.2 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.4.2 (BrendanHay)
02:28:24 * hackagebot amazonka-iot-dataplane 1.4.2 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.4.2 (BrendanHay)
02:29:55 <Xandaros> Maxdamantus: Probably a question more fitting for #haskell-blah :)
02:30:32 <Maxdamantus> Meh, I just mentioned it in ##java anyway.
02:31:34 <zomg> Maxdamantus: I almost read that as ClusterFuck.java... lol
02:31:41 <zomg> had to do a double take
02:32:06 <Xandaros> zomg: So did I, no worries
02:33:26 * hackagebot amazonka-cloudtrail 1.4.2 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.4.2 (BrendanHay)
02:33:28 * hackagebot amazonka-elasticache 1.4.2 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.4.2 (BrendanHay)
02:33:30 * hackagebot amazonka-elasticsearch 1.4.2 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.2 (BrendanHay)
02:33:32 * hackagebot amazonka-waf 1.4.2 - Amazon WAF SDK.  https://hackage.haskell.org/package/amazonka-waf-1.4.2 (BrendanHay)
02:33:34 * hackagebot amazonka-importexport 1.4.2 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.2 (BrendanHay)
02:38:36 * hackagebot amazonka-s3 1.4.2 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.2 (BrendanHay)
02:38:38 * hackagebot amazonka-swf 1.4.2 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.2 (BrendanHay)
02:38:40 * hackagebot amazonka-sdb 1.4.2 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.2 (BrendanHay)
02:38:42 * hackagebot amazonka-ec2 1.4.2 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.2 (BrendanHay)
02:38:44 * hackagebot amazonka-codecommit 1.4.2 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.4.2 (BrendanHay)
02:41:38 <Profpatsch> Are Bifunctor/Bitraversable instances defined for IntMaps somewhere?
02:41:50 <Profpatsch> Or is this the point where I should start using lens?
02:42:15 <EvanR> er how would they be
02:42:22 <Profpatsch> OrphanInstances?
02:42:30 <EvanR> :k IntMap
02:42:32 <lambdabot>     Not in scope: type constructor or class ‘IntMap’
02:42:32 <lambdabot>     Perhaps you meant ‘Data.IntMap.IntMap’ (imported from Data.IntMap)
02:42:38 <EvanR> :k Data.IntMap.IntMap
02:42:39 <lambdabot> * -> *
02:42:54 <EvanR> BiMonoTraversible?
02:43:04 <EvanR> haha
02:43:16 <Profpatsch> Hm, I thought I’d have something like (Int, a) which traverses over the key and the value.
02:43:40 <EvanR> how would you map the Int to a Char if you wanted to
02:43:46 <merijn> Profpatsch: And then something changes the Int type and...?
02:43:46 * hackagebot amazonka-codedeploy 1.4.2 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.4.2 (BrendanHay)
02:43:48 * hackagebot amazonka-cloudfront 1.4.2 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.4.2 (BrendanHay)
02:43:50 * hackagebot amazonka-efs 1.4.2 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.4.2 (BrendanHay)
02:43:51 <Cale> Profpatsch: IntMap doesn't have the right kind to be a Bifunctor
02:43:52 * hackagebot amazonka-gamelift 1.4.2 - Amazon GameLift SDK.  https://hackage.haskell.org/package/amazonka-gamelift-1.4.2 (BrendanHay)
02:43:54 * hackagebot amazonka-elasticbeanstalk 1.4.2 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.4.2 (BrendanHay)
02:43:57 <Cale> :k IntMap
02:43:58 <lambdabot>     Not in scope: type constructor or class ‘IntMap’
02:43:58 <lambdabot>     Perhaps you meant ‘Data.IntMap.IntMap’ (imported from Data.IntMap)
02:44:01 <EvanR> amazonked
02:44:04 <Cale> :k Data.IntMap.IntMap
02:44:05 <lambdabot> * -> *
02:44:20 * EvanR just did that
02:44:26 <Profpatsch> Right, bimap can change the type of the first argument.
02:44:31 <Profpatsch> That would be silly indeed.
02:45:01 <EvanR> i dont think you can do it for Map either
02:45:04 <EvanR> because of the Ord constraint
02:48:56 * hackagebot amazonka-apigateway 1.4.2 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.4.2 (BrendanHay)
02:48:58 * hackagebot amazonka-ses 1.4.2 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.4.2 (BrendanHay)
02:49:00 * hackagebot amazonka-support 1.4.2 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.4.2 (BrendanHay)
02:49:02 * hackagebot amazonka-dms 1.4.2 - Amazon Database Migration Service SDK.  https://hackage.haskell.org/package/amazonka-dms-1.4.2 (BrendanHay)
02:49:04 * hackagebot amazonka-dynamodb-streams 1.4.2 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.4.2 (BrendanHay)
02:54:06 * hackagebot amazonka-redshift 1.4.2 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.4.2 (BrendanHay)
02:54:08 * hackagebot amazonka-opsworks 1.4.2 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.4.2 (BrendanHay)
02:54:10 * hackagebot amazonka-emr 1.4.2 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.4.2 (BrendanHay)
02:54:12 * hackagebot amazonka-cognito-identity 1.4.2 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.4.2 (BrendanHay)
02:54:14 * hackagebot amazonka-codepipeline 1.4.2 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.4.2 (BrendanHay)
02:59:16 * hackagebot amazonka-ssm 1.4.2 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.4.2 (BrendanHay)
02:59:18 * hackagebot amazonka-ml 1.4.2 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.4.2 (BrendanHay)
02:59:20 * hackagebot amazonka-workspaces 1.4.2 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.4.2 (BrendanHay)
02:59:22 * hackagebot amazonka-inspector 1.4.2 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.4.2 (BrendanHay)
02:59:25 * hackagebot amazonka-rds 1.4.2 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.4.2 (BrendanHay)
03:04:27 * hackagebot amazonka-iot 1.4.2 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.4.2 (BrendanHay)
03:04:29 * hackagebot amazonka-ds 1.4.2 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.4.2 (BrendanHay)
03:04:31 * hackagebot amazonka-cloudwatch-logs 1.4.2 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.4.2 (BrendanHay)
03:04:33 * hackagebot amazonka-route53 1.4.2 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.4.2 (BrendanHay)
03:04:35 * hackagebot amazonka-cloudsearch 1.4.2 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.4.2 (BrendanHay)
03:09:37 * hackagebot amazonka-storagegateway 1.4.2 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.4.2 (BrendanHay)
03:09:39 * hackagebot amazonka-cognito-idp 1.4.2 - Amazon Cognito Identity Provider SDK.  https://hackage.haskell.org/package/amazonka-cognito-idp-1.4.2 (BrendanHay)
03:09:41 * hackagebot amazonka-marketplace-analytics 1.4.2 - Amazon Marketplace Commerce Analytics SDK.  https://hackage.haskell.org/package/amazonka-marketplace-analytics-1.4.2 (BrendanHay)
03:09:43 * hackagebot amazonka-elastictranscoder 1.4.2 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.4.2 (BrendanHay)
03:09:45 * hackagebot amazonka-lambda 1.4.2 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.4.2 (BrendanHay)
03:12:48 <offnode> http://espedito.homepc.it/ regards, ;-)
03:13:47 <zinking> Not in scope 'pure' 
03:13:57 <zinking> :t (pure 1) under ghci
03:13:58 <lambdabot> Not in scope: ‘ghci’
03:14:05 <zinking> how to resolve this ?
03:14:45 <zinking> ? lambdabot:
03:14:47 * hackagebot amazonka-application-autoscaling 1.4.2 - Amazon Application Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-application-autoscaling-1.4.2 (BrendanHay)
03:14:49 * hackagebot amazonka-config 1.4.2 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.4.2 (BrendanHay)
03:14:51 * hackagebot amazonka-sns 1.4.2 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.4.2 (BrendanHay)
03:14:53 * hackagebot amazonka-cloudwatch-events 1.4.2 - Amazon CloudWatch Events SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-events-1.4.2 (BrendanHay)
03:14:55 * hackagebot amazonka-glacier 1.4.2 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.2 (BrendanHay)
03:15:06 <bergmark> zinking: what version of ghc are you using?
03:15:19 <bergmark> before 7.10 you need to import Control.Applicative to get pure in scope
03:15:38 <zinking> 7.8.3
03:15:42 <zinking> thanks
03:18:30 <zinking> pure "Hey" :: [String]  
03:18:39 <zinking> is ::  an operator ?
03:19:03 <zinking> how to understand the statement ?
03:19:42 <bergmark> zinking: you can read `::' as "has type"
03:19:57 * hackagebot amazonka-ecr 1.4.2 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.2 (BrendanHay)
03:19:59 * hackagebot amazonka-cloudhsm 1.4.2 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.4.2 (BrendanHay)
03:20:01 * hackagebot hetero-dict 0.1.1.0 - Fast heterogeneous data structures  https://hackage.haskell.org/package/hetero-dict-0.1.1.0 (winterland)
03:21:02 <zinking> pure "Hey" :: [String]  
03:21:30 <zinking> λ> :t (pure "he")       (pure "he") :: Applicative f => f [Char]
03:21:45 <zinking> so :: did change pure "hey" though
03:22:24 <zinking> bergmark: ?
03:24:04 <EvanR> zinking: you can specialize a polymorphic type to something more specific
03:24:08 <EvanR> :t 3
03:24:10 <lambdabot> Num a => a
03:24:15 <EvanR> :t 3 :: Int
03:24:18 <lambdabot> Int
03:24:53 <zinking> I see, thanks 
03:28:16 <Profpatsch> Is this a good way to handle Undo/Redo? https://wiki.haskell.org/New_monads/MonadUndo
03:28:57 <Profpatsch> It seems to be a problem people seldomly have, though you need it in basically every user interface.
03:29:32 <Profpatsch> (that is more than a one-shot CLI application)
03:29:36 <EvanR> for undo redo you want to define a group of actions that modify the model
03:29:56 <EvanR> then you keep a log of the actions, and you can reverse any of them to zip back and forth in history
03:30:10 <EvanR> group in the sense of group theory
03:33:23 <EvanR> the key different between groups and monoids is that each action is reversible
03:33:49 <EvanR> so while paint brush stokes are monoids, to make it undoable each stroke needs to save what was on the canvas before
03:35:16 <Profpatsch> EvanR: A monoid does “destructive” updating in a sense.
03:35:24 <EvanR> it might
03:35:35 <EvanR> which is why i call the monoid <> "fusing"
03:35:35 <Profpatsch> e.g. "abc" <> "def"
03:36:09 <Profpatsch> Is there a class for a “reversible” <>?
03:36:33 <Profpatsch> There is also the garbage collection problem.
03:36:33 <EvanR> Group ?
03:37:07 <EvanR> as long as you hold onto the history, you use memory. if you forget old history itll be reclaimed
03:37:24 <Profpatsch> Know your algebra. :P
03:37:31 <Profpatsch> https://hackage.haskell.org/package/groups-0.4.0.0/docs/Data-Group.html
03:37:41 <Profpatsch> That looks like the package I want.
03:37:58 <EvanR> its not that the <> is reversible, its the actions you put on the left or right
03:38:38 <EvanR> foo <> bar <> baz <> baz^-1 evaluates to 
03:38:44 <EvanR> foo <> bar
03:39:50 <Profpatsch> <s>reversible</s> invertable
03:40:13 <EvanR> (foo <>) is invertible
03:40:40 <Profpatsch> (Sum 1) <> (Sum -1) == mempty?
03:40:56 <EvanR> > (Sum 1) <> (Sum -1) == mempty
03:40:58 <lambdabot>      Couldn't match expected type ‘Sum Integer’
03:40:58 <lambdabot>                  with actual type ‘a0 -> Sum a0’
03:40:58 <lambdabot>      Probable cause: ‘Sum’ is applied to too few arguments
03:41:02 <EvanR> > (Sum 1) <> (Sum (-1)) == mempty
03:41:04 <lambdabot>  True
03:41:10 <Profpatsch> nice.
03:41:24 <Profpatsch> Now that must be the simplest example. :)
03:41:35 <EvanR> it doesnt demonstrate group support though
03:41:43 <EvanR> inv (Sum 1) == Sum (-1)
03:41:59 <kqr> sooo... which alternative prelude to use? my main gripes: having to do an import dance to use Text instead of String as well as needing to import forM_ and other useful monad thing
03:42:09 <EvanR> inv [1,2,3] == ? error not a group
03:42:15 <kqr> is there any place that compares the popular alternatives?
03:42:15 <Profpatsch> kqr: I use Protolude, which is quite nice.
03:42:24 <kqr> never heard of that, Profpatsch. will take a look!
03:43:02 <Profpatsch> EvanR: So I need to define a data structure which instances group, then I can undo and redo changes by inverting and applying to my state?
03:43:40 <EvanR> yes, the action type is the possible edits with whatever support is needed to invert
03:43:43 <Profpatsch> e.g. I have an EntryChange { from :: Entry, to :: Entry }
03:43:59 <Profpatsch> Which is trivial to invert by switching from and to.
03:44:05 <EvanR> well if you do it that way, you might as well just save a stack of Entry
03:44:22 <EvanR> if it only included whats necessary to update the Entry, it will be more efficient
03:44:41 <EvanR> [Entry] is simpler though
03:44:55 <kqr> Profpatsch, balls. that does look rather nice. is there a list somewhere of the functions it contains and such?
03:45:23 <Profpatsch> kqr: Best to look at the source. Haddock has problems with the export strategy the module usess.
03:45:42 <kqr> ah
03:45:48 <kqr> that explains that
03:46:03 <Profpatsch> EvanR: Basically I have an IntMap of indexed Entries (which are the leaves of my data).
03:46:24 <EvanR> what kinds of edits can you do
03:46:39 <Profpatsch> And it’s a simple Grid which displays the stuff and can be edited (changing fields)
03:47:00 <Profpatsch> And there’s some filtering, but that’s only for display and (probably) doesn’t need any undo.
03:47:10 <Profpatsch> Very basic.
03:47:26 <EvanR> so the edit could be { before :: (Int, Entry), after :: (Int, Entry) }
03:47:35 <EvanR> hmm
03:47:40 * hackagebot dead-code-detection 0.8 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.8 (SoenkeHahn)
03:47:51 <EvanR> (Int, (Entry,Entry))
03:48:00 <Profpatsch> Ah, then I can update the IntMap state by index.
03:48:09 <Profpatsch> “destructively”
03:48:28 <EvanR> the simpler way is to keep a stack of the whole IntMap ;)
03:48:33 <Profpatsch> And when that happens it is also saved to the database.
03:49:12 <EvanR> if you decide another operation is to swap two
03:49:18 <EvanR> | Swap Int Int
03:49:28 <EvanR> the reverse is obvious
03:49:50 <EvanR> actually its its own inverse
03:50:11 <Profpatsch> And then instance group with inv (Swap x y) = Swap y x
03:50:20 <Profpatsch> Way, reverse != inverse?
03:50:24 <Profpatsch> *Wait
03:50:35 <EvanR> Swap x y is already its own inverse edit
03:50:47 <Profpatsch> Right. :)
03:51:00 <EvanR> but Update Int Entry Entry needs to swap entries
03:51:27 <Profpatsch> If I kept IntMap as a stack, there would be no redo, though3
03:51:37 <EvanR> true, itd have to be a zipper
03:51:43 <Profpatsch> That’s what complicates matters a bit.
03:51:58 <Profpatsch> Ah, I should have known there’s a data structure for that. :)
03:52:01 <EvanR> youd want the action history in a zipper too
03:52:09 <EvanR> for redo
03:53:29 <EvanR> as you zip backwards you move the opposite action to the right
03:53:46 <EvanR> when you zip back to the future, move the opposite of the opposite to the left 
03:53:57 <Profpatsch> Is that a kill ring then?
03:54:07 <EvanR> huh
03:54:19 <Profpatsch> Ah, you mean the inverse
03:54:23 <EvanR> yes
03:54:44 <EvanR> so you only have 1 apply operation instead of 2
03:54:48 <Profpatsch> Does Zipper have anything to do with the functions zip and zipWith?
03:54:53 <Profpatsch> Or is it just name overloading?
03:54:55 <EvanR> no
03:54:59 <Profpatsch> Oh, okay.
03:55:21 <EvanR> data Zipper a = Zipper [a] a [a], for a non-empty zipper
03:57:23 <EvanR> im glad someone is working on a GUI ;)
03:58:50 <Profpatsch> EvanR: why?
03:59:32 <Profpatsch> But Zippers look great.
04:00:31 <EvanR> haskell gets relatively little GUI love, unless maybe html5
04:01:35 <Profpatsch> EvanR: Yes, I kind of wish I did it with a web gui now.
04:01:52 <Profpatsch> Well, I could still switch.
04:02:29 <Profpatsch> Then again that would mean a whole swath of other problems.
04:03:28 <EvanR> an emptyable zipper actually makes more sense
04:03:43 <EvanR> with no current element
04:04:03 <Profpatsch> Yes, because with Events there’s only past and future.
04:07:05 <Profpatsch> Hah, here’s a pretty good description of undo with zippers: https://en.wikibooks.org/wiki/Haskell/Zippers
04:07:57 <EvanR> i read that before, but if i thought about it as inverting a group action it probably would have made more sense
04:08:18 <EvanR> maybe not
04:09:45 <EvanR> that one uses a nonempty zipper
04:10:08 <EvanR> ah no
04:27:55 <Profpatsch> It will take quite some time until I grok Zippers …
04:28:31 <sbrg> Profpatsch: they're really not that complicated. it's probably easiest to look at list zippers to start with.
04:28:37 <sbrg> maybe roll your own. 
04:29:01 <Profpatsch> Nothing in FP is complicated once you’ve built an intuition. :P
04:29:23 <EvanR> all theorems are obvious when you have the proof
04:29:34 <Profpatsch> *once you understood the proof
04:29:57 <EvanR> when you have... done the proof
04:30:16 <Koen_> what if your proof uses other theorems
04:30:21 <Koen_> which are not obvious?
04:30:45 <EvanR> its transitive
04:30:53 <EvanR> you need those proofs
04:32:14 <EvanR> Profpatsch: for your purpose ([a],[a]) is kind of braindead simple
04:52:38 <suppi> so, parsers for programming languages, earley or megaparsec? :)
04:52:59 <cocreature> suppi: trifecta
04:53:26 <suppi> cocreature, reasons?
04:53:33 <cocreature> suppi: awesome error messages
04:53:35 <merijn> suppi: Super cool looking errors ;)
04:53:50 <cocreature> suppi: leaving that aside I think these days I’d probably go for earley since I’m too lazy to leftfactor my grammar
04:53:50 <Profpatsch> No documentation!
04:54:02 <cocreature> Profpatsch: the trick is to pretend you’re using parsec
04:54:08 <merijn> Profpatsch: The documentation is in parsers
04:54:19 <suppi> no left factor is incredibly appealing
04:54:34 <suppi> trifecta - any tutorials available?
04:54:40 <cocreature> nope
04:54:44 <suppi> rejected.
04:54:46 <mauke> handwritten recursive descent
04:54:47 <cocreature> well not that I know off
04:54:47 <merijn> suppi: You can look at my code, it's pretty straightforward: https://github.com/merijn/lambda-except
04:55:08 <merijn> suppi: Parser.hs/Lexer.hs, obviously
04:55:30 <merijn> The language itself is broken, but the parser should be clear :)
04:55:46 <suppi> merijn, thanks. but I rather use packages with tutorials.
04:56:23 <suppi> merijn, i am starring your repo though :)
04:57:01 <Profpatsch> The documentation is probably: a) the types match b) you’ll see what went wrong from the error messages
04:57:27 <Profpatsch> Also pick up a dictionary to look up the meanings of the words used for class names. :)
04:57:30 <suppi> I guess i'll flip a coin for earley vs megaparsec
04:58:21 <suppi> thanks everyone
04:58:22 <Profpatsch> There’s Ropes, there’s Strands, Carets and Fixits!
05:01:32 <merijn> Profpatsch: Tbh, I had the epiphany "I only need to look at the class methods in parsers and the 1 additional class in trifecta itself (DeltaParsing) and use those"
05:01:38 <merijn> After that it was easy
05:01:58 <merijn> The caret/strands/fixits are just if you want to do custom EVEN FANCIER error reporting
05:02:06 <Profpatsch> The hard thing about ekmett libraries is to know where to look.
05:02:40 <Profpatsch> Using cassava took me a long time because there’s no error messages at all.
05:03:23 <lpaste> Koterpillar pasted “No title” at http://lpaste.net/165162
05:03:31 <Koterpillar> How can I use Control.Effects.State from effect-handlers and get my new state back?
05:08:42 <kqr> @pl \f g -> f <$> g <*> g
05:08:42 <lambdabot> (. join (<*>)) . (<$>)
05:08:49 <kqr> @pl \g -> (,) <$> g <*> g
05:08:49 <lambdabot> ((,) <$>) . join (<*>)
05:08:52 <kqr> not quite it
05:10:28 <Koterpillar> kqr: if I understand you right, I've done something like that; it's just strange that it's not provided by the handler
05:12:43 <kqr> I know I've done something like that too
05:12:50 <kqr> in this case I want to generate a tuple of random numbers
05:12:56 <kqr> I know there was a neat way but I can't remember it
05:13:17 <andreas`> Hi everyone, I'm trying out some Turtle shell scripting, but I've hit a small road bump with FilePath
05:13:47 <Koterpillar> kqr: is this what you wanted to do? https://www.haskell.org/hoogle/?hoogle=State+s+x+-%3E+State+s+(s%2C+x)
05:13:54 <andreas`> Turtle expects a FilePath for most of the shell functions, and it is able to convert literal strings to FilePath. How do I convert any arbitrary String to a FilePath?
05:14:11 <EvanR> isnt type FilePath = String
05:14:22 <sbrg> kqr: liftM2? 
05:14:22 <kqr> Koterpillar, no, not quite. more like "m a -> m (a, a)"
05:14:24 <andreas`> Not for Turtle
05:14:34 <sbrg> > let f = randomRIO (1, 6) in liftM2 (,) f f
05:14:35 <lambdabot>  <IO (Integer,Integer)>
05:14:36 <andreas`> In Prelude it is just a String
05:14:36 <kqr> join (liftA2 (,)) would work, but it looks a bit cryptic
05:15:16 <sbrg> > let f = randomRIO (1, 6) in (,) <$> f <*> f
05:15:17 <lambdabot>  <IO (Integer,Integer)>
05:15:20 <kqr> andreas`, https://hackage.haskell.org/package/system-filepath-0.4.13.4/docs/Filesystem-Path-CurrentOS.html
05:15:24 <kqr> andreas`, specifically, encodeString
05:15:35 <kqr> andreas`, wait decodeString, if you want to go that way
05:15:48 <merijn> EvanR: Not in all libraries
05:15:57 <merijn> EvanR: There's multiple FilePath types around
05:15:58 <Koterpillar> ?type \act -> get >>= \s' -> act >>= \r -> return (r, s')
05:15:59 <lambdabot> MonadState t1 m => m t -> m (t, t1)
05:16:01 <EvanR> nice
05:16:06 <Koterpillar> kqr: ^^
05:16:10 <andreas`> kqr: I'll try that quickly
05:16:30 <kqr> Koterpillar, yes, something along those lines
05:16:40 <EvanR> i see Turtle has solved the FilePath situation its own way
05:17:59 <kqr> Koterpillar, ah this was what I did before https://github.com/kqr/gists/blob/master/marshalling/cardsagainstdevops.hs#L43-46
05:18:28 <kqr> Koterpillar, but it's not quite the same thing
05:19:39 <andreas`> kqr: Thanks, that worked great!
05:19:48 <andreas`> decodeString
05:19:55 <kqr> cool
05:19:57 <kqr> turtle is the best
05:27:44 * hackagebot gtk3 0.14.5 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.5 (HamishMackenzie)
05:27:46 * hackagebot gtk 0.14.5 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.14.5 (HamishMackenzie)
05:54:25 <RyanGlScott> shahn: I have a question about dead-code-detection
05:54:55 <RyanGlScott> I'm trying to use it on one of my simpler projects: https://github.com/RyanGlScott/keycode, using
05:55:32 <RyanGlScott> dead-code-detection --root src/Web/KeyCode.hs -isrc
05:55:47 <RyanGlScott> But this errors: cannot find module: src/Web/KeyCode.hs
05:55:56 <RyanGlScott> Am I doing something wrong?
05:58:35 <sbrg> RyanGlScott: did you try: dead-code-detection --root -isrc KeyCode ?
05:58:44 <sbrg> the -i argument suggests you do not need the full path
05:58:52 <sbrg> https://hackage.haskell.org/package/dead-code-detection example here kind of supports that as well
05:59:27 <RyanGlScott> Oh, so it's expecting a Haskell-style module name, and not a filepath?
05:59:42 <sbrg> no idea, haven't used it. just looked it up. it kind of looks that way though, yes
05:59:45 <RyanGlScott> Sure enough, `dead-code-detection --root Web.KeyCode -isrc` works
05:59:51 <sbrg> cool
06:00:01 <RyanGlScott> That wasn't clear at all from --help, though...
06:00:32 <sbrg> RyanGlScott: https://github.com/soenkehahn/dead-code-detection pull request then? ;)
06:00:34 <RyanGlScott> Now let me try this on a package with Cabal macros :)
06:02:02 <Profpatsch> EvanR: Now that I think about it, Group requires Monoid.
06:02:35 <Profpatsch> If I want to instantiate the type EntryChange (Int, (Entry, Entry)) from before, it needs to be a Monoid first.
06:02:36 <RyanGlScott> Eek, dead-code-detection does NOT like Cabal macros, even with -idist/build/autogen
06:03:12 <Profpatsch> But that’s hard, because what is <> in that case. :)
06:03:50 <EvanR> Profpatsch: <> is the same
06:04:16 <EvanR> to be a group you need a no-op edit anyway
06:04:28 <mudfavor12> I created a mud server in haskell
06:04:31 <mudfavor12> Try it
06:04:38 <mudfavor12> http://tecflare.com:8000/webclient/
06:04:50 <EvanR> Edit = DoNothing | EntryChange ... | Swap ... | ...
06:05:18 <mudfavor12> EvanR: I created a mud in haskell
06:05:21 <EvanR> if you dont want an identity, you dont have to have one, just use a different class
06:05:24 <mudfavor12> http://tecflare.com:8000/webclient/
06:05:25 <Profpatsch> e1 <> e2 = ?
06:05:27 <sbrg> mudfavor12: doesn't seem to work
06:05:28 <EvanR> theres a word for it
06:05:34 <Profpatsch> Groupoid?
06:05:42 <sbrg> semigroup?
06:05:51 <EvanR> Profpatsch: e1 <> e2 is the edit composed of e1 followed by e2
06:06:11 <mudfavor12> visit https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwi20biD9ovNAhUM9IMKHaDEDXsQFggfMAA&url=http%3A%2F%2Fwww.mudconnect.com%2Ffmud%2F&usg=AFQjCNHFqt7R8RUmRiBhkpTbWnIOVD9WTA&sig2=or68oVAy_n0EF3qFs5PvlQ 
06:06:17 <EvanR> sbrg: with inverses
06:06:19 <mudfavor12> and the server is tecflare.com 
06:06:23 <mudfavor12> port 4000
06:07:22 <EvanR> Profpatsch: but its easy to just add an identity edit
06:08:27 <mudfavor12> sbrg: did it work?
06:09:01 <EvanR> Profpatsch: since your zipper is like ([Edit],[Edit]) you dont really need any type class here, just the inverse operation on Edit. the [ ] is serving the role of the <> expression builder
06:09:22 <Ven> hi, I'm looking for a function `(a -> Either b c) -> [a] -> Either b [c]` (i.e., a reduce-with-either that stops on the first Left). `sequence`, `traverse` and `mapM` don't seem to do what I'd want, and hoogle brings no result.
06:09:28 <EvanR> conceptually its a group but you dont have to go out of your way to deal with type classes for this
06:09:33 <mudfavor12> http://tecflare.com:8000/webclient/
06:09:34 <mudfavor12> http://tecflare.com:8000/webclient/
06:09:50 <merijn> Ven: mapM ?
06:09:52 <merijn> :t mapM
06:09:53 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:09:54 <sbrg> mudfavor12: nope.
06:10:14 <merijn> :t mapM `asAppliedTo` (f :: a -> Either b c)
06:10:15 <lambdabot>     Could not deduce (Show a1) arising from a use of ‘f’
06:10:15 <lambdabot>     from the context (Traversable t)
06:10:15 <lambdabot>       bound by the inferred type of
06:10:28 <merijn> :t mapM `asAppliedTo` (undefined :: a -> Either b c)
06:10:30 <lambdabot> Traversable t => (a -> Either b1 b) -> t a -> Either b1 (t b)
06:10:34 <mudfavor12> sbrg: Try using putty then telnet and telnet to tecflare.com port 4000
06:10:39 <sbrg> mudfavor12: no thanks
06:10:44 <mudfavor12> ok
06:10:51 <Ven> merijn: right, that looks correct.
06:11:04 <EvanR> mudfavor12: try #haskell-offtopic
06:11:14 <shahn> RyanGlScott: Yeah, dead-code-detection doesn't know anything about cabal.
06:11:25 <Ven> merijn: that's from Control.Monad? because the Traversable instance for Either doesn't seem to be what I'd want
06:11:42 <RyanGlScott> shahn: So is there a workaround for files that use MIN_VERSION_foo(x,y,z) ?
06:11:57 <shahn> No, currently not.
06:11:58 <merijn> Ven: It's not the traversable of Either
06:12:06 <merijn> Ven: It's the traversable of []
06:12:17 <Ven> merijn: oh my, you're right!
06:12:18 <merijn> Ven: "t a" -> "[a]"
06:12:25 <RyanGlScott> shahn: Gotcha. Do you happen to know where dead-code-detection errors when GHC's preprocessor fails?
06:12:27 <shahn> RyanGlScott: I guess the tool could allow to pass in ghc flags. Then you could include the cabal_macros.h file.
06:12:32 <RyanGlScott> I'd be curious to look at that code.
06:12:53 <merijn> Ven: Either is the Monad in mapM :)
06:13:03 <Ven> marienz: yeah, that part I got :P.
06:13:17 <shahn> RyanGlScott: Sorry, what do you mean?
06:13:33 <RyanGlScott> Currently, it errors with the message: dead-code-detection: phase `C pre-processor' failed (exitcode = 1)
06:13:48 <RyanGlScott> Do you know where in the dead-code-detection source code that error message gets thrown?
06:14:31 <shahn> dead-code-detection calls the ghc api. So that's the one that generates the error.
06:14:58 <RyanGlScott> Sure, that makes sense. Do you have an idea which API function is the entrypoint, though?
06:15:13 <RyanGlScott> Currently, I have no idea where I'd begin to debug this.
06:16:10 <shahn> Not 100% sure, but I guess here: https://github.com/soenkehahn/dead-code-detection/blob/master/src/Ast.hs#L73
06:16:44 <RyanGlScott> Aha! There's something within runGhc. Thanks, that'll give me a place to look into.
06:18:17 <Profpatsch> EvanR: I’m still not sure how I’d implement <>.
06:18:39 <Profpatsch> Because how do I append two EntryChanges?
06:19:13 <EvanR> you want to use the edit group as-is, as an expression of edit terms in a sequence
06:19:42 <EvanR> one way to do this is to add a case for the <> combination, data Edit = ... | ... | Append Edit Edit
06:19:56 <EvanR> so its basically the combination of a primitive edit and a list
06:20:16 <EvanR> so its really easier to drop it and just use a list, which your zipper is made of
06:20:36 <EvanR> to answer to original question (<>) = Append
06:20:38 <Profpatsch> Ah, so I’m just constructing a forced Monoid.
06:20:53 <Profpatsch> As a datatype.
06:21:01 <EvanR> its not really forced, its really what youre dealing with
06:21:13 <EvanR> a sequence of primitive edits, each one can be inverted and cancelled
06:21:22 <EvanR> (but not resequenced)
06:21:48 <EvanR> practically [Edit] where inv :: Edit -> Edit is all you need
06:21:58 <ggVGc> what is the functional equivalent of a list of objects with a shared interface, each holding a local state that's different type per object and not part of the interface?
06:22:11 <EvanR> and apply :: Edit -> model -> model
06:22:18 <EvanR> the group action
06:22:38 <EvanR> ggVGc: a record type for the interface
06:22:49 <ggVGc> EvanR: yeah,but how do I keep a state per object?
06:23:09 <Profpatsch> EvanR: And how does the Zipper come into play?
06:23:10 <EvanR> with a closure / passed in to the constructor
06:23:35 <ggVGc> EvanR: but I need to modify the state
06:23:36 <EvanR> imagine ([Edit],Model,[Edit])
06:23:39 <ggVGc> doI have to hold an MVar?
06:23:58 <EvanR> you can use IO or not
06:24:23 <EvanR> example Ellipse { width :: Double, setWidth :: Double -> Ellipse }
06:25:05 <EvanR> or IOEllipse { width :: IO Double, setWidth :: Double -> IO () }
06:27:05 <codedmart> Anyone using stack, vim, and syntastic? I installed ghc-mod and hlint and have ~/.local/bin in my path. But syntastic only shows hlint as available and loaded checkers.
06:27:14 <hpc> newIOEllipse w = do {var <- newIORef w; return IOEllipse {width = readIORef var; setWidth :: writeIORef var} -- and then close over a var for the state
06:28:50 <EvanR> and you may thus secure a place in FP hel; )
06:29:14 <sbrg> codedmart: try restarting vim. if you didn't restart after adding it to $PATH then vim doesn't know about it(though it's strange it knows about hlint, but it's worth a try)
06:29:40 <codedmart> sbrg: Have already done that.
06:30:36 <ggVGc> hpc: yeah, that's what I was asking. if I have to close over an MVar
06:30:40 <ggVGc> seems like something I don'twant to do
06:30:56 <hpc> it's not that bad
06:31:39 <hpc> if you don't feel like closing over it, you could have data IOEllipse = IOEllipse {state :: IORef Double}
06:32:10 <EvanR> no each one has to have a different internal type
06:32:27 <EvanR> its a list of things with uniform interface but different implementations
06:32:29 <hpc> oh i see
06:32:38 <hpc> yeah, close over the implementation
06:32:47 * hackagebot ghc-exactprint 0.5.1.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.1.1 (AlanZimmerman)
06:32:55 <hpc> it's a very lisp-OOP-ish style which a lot of people forget about
06:33:25 <sm> "I have another ten open roles in the growing Strats team at Standard Chartered." .. what is going on at SC..
06:33:44 <Profpatsch> EvanR: Okay, that’s what I came up with so far: http://lpaste.net/165171
06:33:44 <hpc> and it makes you think hard about what API you want to expose
06:33:47 <hpc> which is always a good thing
06:34:43 <EvanR> Profpatsch: whats Z.Zipper
06:34:56 <Profpatsch> Ah, https://hackage.haskell.org/package/ListZipper-1.2.0.2/docs/Data-List-Zipper.html
06:36:03 <ggVGc> maybe I am thinking about things wrong though. My situation is this: I have these modes in my program, Each mode can update and render, and they are composable into larger modes. But each of them have various internal states they need, which are currently just kept in one big type for all modes, which is notvery sustainable
06:36:08 <EvanR> undo ((u:us),s,(r:rs)) = ((inv r):us, apply u s, rs)
06:36:21 <mnoonan> ggVGc: you know about existential types? https://wiki.haskell.org/Existential_type
06:36:25 <ggVGc> but if I don't have this one type for the state, I don't know how to write "Run this composed mode, and update the state"
06:36:25 <Profpatsch> EvanR: what is the type of undo and redo?
06:36:48 <EvanR> er i messed up
06:36:50 <ggVGc> mnoonan: yeah, but that won't get me away from the mvar I tink?
06:36:51 <EvanR> its late
06:37:26 <EvanR> Profpatsch: undo :: ([Edit],Thing,[Edit]) -> ([Edit],Thing,[Edit])
06:37:37 <ggVGc> mnoonan: with existential types I can keep a list of objects with a uniform interface, but how do I modify them with new states, when the states for each object is different
06:37:48 <EvanR> undo ((u:us),s,(r:rs)) = (us, apply u s, inv u:rs)
06:38:01 <EvanR> ... undo ((u:us),s,(r:rs)) = (us, apply u s, inv u:r:rs)
06:38:30 <EvanR> when you zip one way or the other, apply the edit to the model
06:38:44 <Profpatsch> And when do I apply it to my data structure?
06:38:50 <EvanR> i already did it
06:38:53 <Profpatsch> apply == applyEdit?
06:38:58 <EvanR> yes
06:39:11 <mnoonan> ggVGc: how would you model the situation in an OO language? maybe I'm not catching some detail here.
06:39:28 <EvanR> ggVGc: existentials arent really better here
06:39:28 <Profpatsch> Okay, so undo changes my History and my data structure in one go.
06:39:47 <EvanR> Profpatsch: in the way i said it here yeah, but you can separate it out...
06:39:52 <ggVGc> mnoonan: with a closure over a mutable variable
06:39:59 <ggVGc> which is what it seems I will need to  do in haskell too
06:40:06 <ggVGc> which is a shame
06:40:12 <EvanR> whats the issue?
06:40:55 <EvanR> youre returning to a time when men were men and simulated OOP using lexical closure ;)
06:41:49 <ggVGc> EvanR: I just feel there should be another way. If I have a list Foo{getNewFoo :: Foo}, I should be able to put the new Foo back into the list even if it has a state that's different from another foo
06:41:54 <ggVGc> I feel
06:42:01 <ggVGc> I mean, it should be possible with existential types I reckon
06:42:02 <EvanR> alternatively you might be accidentally slipping into full C++ mode 
06:42:24 <ggVGc> well, that's why I'm searcing for something better
06:42:24 <EvanR> theres not really a point to exposing a type variable that no one can use
06:43:12 <EvanR> you still have to manage some sort of state behind the scenes in your "private" functions
06:44:06 <cocreature> existentials mostly make sense if you can regain that type info by pattern matching on a gadt or something like that
06:44:19 <Profpatsch> EvanR: https://hackage.haskell.org/package/ListZipper-1.2.0.2/docs/Data-List-Zipper.html
06:44:22 <Profpatsch> Ah, sorry
06:44:33 <Profpatsch> undo :: IndexedEntries -> State UndoHistory IndexedEntries
06:44:55 <EvanR> if you wish
06:45:06 <EvanR> my sig was more symmetric ;)
06:45:26 <Profpatsch> Alternatively it would be something like (UndoHistory, IndexedEntries) -> (UndoHistory, IndexedEntries)
06:45:40 <texasmynsted> where is a good place to share haskell code for this channel?
06:45:46 <Profpatsch> texasmynsted: lpaste.net
06:45:58 <texasmynsted> ok thank you
06:46:06 <EvanR> undo :: MyAppMonad ()
06:49:26 <Profpatsch> undo :: MonadState UndoHistory m => IndexedEntries -> m IndexedEntries   ?
06:50:04 <texasmynsted> Ok, a few of us were looking at this code (from a book exercise).  I could find no way to use '\n' as the criteria for splitting up the lines as used in myLines and at the same time have myLines be myLines :: a -> [a]   Is it possible?  http://lpaste.net/4556632101130076160
06:50:27 <EvanR> Profpatsch: urg... that sure is mixing up every single way ;)
06:50:43 <merijn> texasmynsted: That doesn't make sense
06:51:07 <Profpatsch> texasmynsted: '\n' :: Char
06:51:19 <merijn> oh, wait
06:51:31 <merijn> texasmynsted: You probably want "\n"?
06:51:34 <Profpatsch> texasmynsted: "\n" :: [Char]
06:51:49 <Profpatsch> EvanR: How’s that?
06:52:05 <merijn> Actually, wait
06:52:15 <merijn> What he wants should use '\n'
06:52:24 <EvanR> Profpatsch: do you want to use side effects or return pure values or use basic loose operations or
06:52:27 <merijn> texasmynsted: What's not working?
06:52:42 <EvanR> Profpatsch: the history and the model are both part of the app state, imo
06:52:57 <Profpatsch> You are right, the function should be pure.
06:54:06 <Profpatsch> But using State is semantically nicer than piping through tuples me thinks.
06:54:21 <EvanR> this is the most idiomatic imo
06:54:49 <EvanR> rawUndo :: History -> Model -> (History, Model)
06:55:11 <EvanR> and somewhere else undo :: MyApp (), if you use something like that
06:55:18 <Profpatsch> Probably yes.
06:55:27 <Profpatsch> Everything else is just gift-wrapping.
06:56:02 <EvanR> so mile long constraints are avoided this time
06:58:34 <texasmynsted> The issue I was having was typing.  As soon as I designated the key as '\n' then myLines became fixed to [Char] -> [[Char]] or String -> [String]
06:58:41 <geekosaur> texasmynsted, if you're still confused, the signature for myLines is wrong
06:58:53 <texasmynsted> oh
06:58:55 <geekosaur> you should be getting a type error from it, in fact
06:59:00 <texasmynsted> Yeah I think you are right.
06:59:04 <Squarism> how do i load my multimodule project into ghci?
06:59:11 <texasmynsted> I think I am still half asleep or something
06:59:22 <geekosaur> ...although having just gotten up I think I just isread it also
07:00:21 <texasmynsted> sorry.  Thank you for looking
07:00:27 <geekosaur> oh
07:00:40 <geekosaur> "became fixed to [Char] -> [[Char]]"
07:00:47 <geekosaur> String is [Char]
07:02:08 <geekosaur> it's a type alias, String is identical to [Char], not a wrapper for it
07:02:48 * hackagebot file-modules 0.1.2.3 - Takes a Haskell source-code file and outputs its modules.  https://hackage.haskell.org/package/file-modules-0.1.2.3 (yamadapc)
07:03:04 <Squarism> anyone? How do you load a multimodule project into GHCi?
07:03:17 <Squarism> ...so you can check types of stuff etc
07:05:38 <mightybyte> Hi all, the Compose :: Conference is having a sister event in Melbourne, Australia!  Check out http://www.composeconference.org/2016-melbourne/cfp/ for the CFP.
07:06:08 <Boomerang> Squarism: if you're using cabal you can do "cabal repl", if you're using stack you can do "stack repl" :)
07:06:08 <mightybyte> Also, I posted it over at HN if anyone would like to give it an upvote there.
07:06:45 <cocreature> mightybyte: that’s even further away than the us, you need one in europe :P
07:07:24 <Squarism> Boomerang, thanks! That worked fine with cabal
07:07:36 <Boomerang> :)
07:07:42 <Squarism> anyways.. how do cabal and stack relate?
07:08:14 <Squarism> <-- total noob that has followed step-by-step guidance wo understanding whats going on
07:08:23 <d-rock> stack uses cabal under the covers, IIRC
07:08:47 <d-rock> Squarism: https://www.fpcomplete.com/blog/2015/06/why-is-stack-not-cabal
07:08:54 <Boomerang> stack tries to solve "cabal hell" and does it pretty well. It's easier to setup but in the end stack uses cabal anyway :)
07:08:58 <d-rock> Explains a little bit about the plumbing and design
07:08:58 <Squarism> so if you have stack installed, all interaction with cabal should be done using stack
07:09:09 <Squarism> d-rock, thanks.. ill read right awya
07:09:20 <d-rock> Yes. It handles things like sandboxes and other cabal frustrations automatically
07:09:20 <Boomerang> pretty much (you still have to maintain you .cabal project file though
07:09:25 <d-rock> Right
07:10:34 <maerwald> if there is "cabal hell" within a cabal sandbox, that just means the dependencies of a package are wrong and need to be fixed
07:11:10 * merijn goes off on his old people rant of "none of this is cabal hell!"
07:11:40 <merijn> Cabal hell hasn't existed for like 5 years (or more?) :\
07:12:15 <maerwald> and for development, I'd rather tell people to use plain cabal in order to get those package build failures, so they can fix them
07:12:17 <geekosaur> and it's always been ghc hell anyway, cabal was the messenger
07:12:38 <Boomerang> Yeah I find cabal sandboxes pretty good in general (I just wish it was easier to remove a package without having to delete the sandbox and reinstalling everything).
07:12:40 <maerwald> stack is for deployment, IMO
07:12:56 <Squarism> so most people use stack then?
07:12:57 <bernalex> I still don't understand what stack solves.
07:13:08 <merijn> Boomerang: You can just "unregister" the package
07:13:11 <maerwald> bernalex: can be nice for deployment, but other than that...
07:13:28 <bernalex> and I haven't experienced cabal hell really at all. I've experienced people who have wrong deps, but that hasn't been cabal's fault.
07:13:36 <geekosaur> bernalex, mostly it forces ghc to see a consistent set of packages so it can't go haring off installing something it thinks is more appropriate
07:13:38 <merijn> bernalex: Me neither, but apparently it does wonders at whatever it does for people :)
07:14:01 <bernalex> merijn: stack users keep telling me that I have cabal issues, and if I don't then I am not using cabal correctly. which sounds a bit wrong way around to me.
07:14:05 <merijn> bernalex: To be fair, cabal hell WAS an actual thing and it wasn't about wrong dependencies. It's also not existed for a long while :)
07:14:06 <maerwald> bernalex: exactly, if the deps are wrong, don't blame the build system 
07:14:11 <Boomerang> merijn: I don't think unregistering is enough when you want to change the source of a dependency (when you're editing the library yourself for example)
07:14:38 <geekosaur> (cabal-install tried to solve that by being polite, and until recently often failed. stack started out from the outset beitng ghc with a Big Stick, so it was more successful)
07:14:46 <geekosaur> *beating ghc
07:15:10 <MichaelBurge_> I tend to say stack is for applications, while cabal should be used by library maintainers
07:15:24 <EvanR> Boomerang: it is, ive been doing that
07:15:33 <merijn> bernalex, maerwald: The REAL cabal-hell was a few years ago, where it would sometimes silently replace installed packages with newly reinstalled versions that would silently break the transistive closure of every installed library depending on it
07:15:33 <d-rock> My understanding was that it's intended to be a superset, from the perspective of packaging and deployment
07:16:05 <bernalex> MichaelBurge_: a lot of people say that, and it makes no sense to me. people shouldn't have to learn a lang-specific tool to install a program. Joe Random User doesn't even know what haskell is. they should be using emerge/apt-get/yum/whatever.
07:16:21 <bernalex> merijn: did this happen is sandboxes?
07:16:42 <MichaelBurge_> bernalex: No, I mean application developers should develop with stack, while library developers should develop with cabal. End-users should just download a binary.
07:16:48 <merijn> bernalex, maerwald: And figuring out what exactly it broke was impossible so you had to nuke and start over. That was an actual problem and cabal deserved flack for it. Nowadays people have heard the name and use it whenever "cabal build" doesn't fail for ANY reason, even if it is "your dependencies are wrong"
07:16:54 <merijn> bernalex: Mu. Sandboxes didn't exist
07:17:01 <maerwald> "end users should just download a binary" -- er wat?
07:17:03 <bernalex> MichaelBurge_: why should program developers use stack?
07:17:10 <bernalex> maerwald: windows/mac people do that.
07:17:12 <maerwald> ah
07:17:34 <bernalex> merijn: then it must be a *long* time ago indeed.
07:17:41 <merijn> eh, whenever it DOES fail for ANY reason, not "doesn't fail" :p
07:17:46 <merijn> bernalex: Like I said, years
07:17:46 <Boomerang> EvanR, merijn: I didn't know about "cabal sandbox hc-pkg unregister", only "cabal sandbox delete-source", thanks for the tip :)
07:18:30 <merijn> Boomerang: Right, that's the one I was thinking off
07:18:33 <mightybyte> cocreature: We'd love to get a Compose franchise in Europe...just need a group who's willing to make it happen.  :)
07:18:51 <bernalex> maerwald: I think maybe win10 is going to have package management of sorts. but everything is probably statically linked and bloated. and they're only doing it to introduce censorship rather than usability. -_o_-
07:18:54 <MichaelBurge_> bernalex: Because stack is better for deployment - you can fix yourself to a particular set of packages that build correctly together
07:19:36 <bernalex> MichaelBurge_: I don't understand the argument. when I deploy, I just build the binaries and deploy them on whatever computers need them.
07:19:36 <MichaelBurge_> bernalex: I feel like I'd be fiddling with finding specific versions of packages if I used cabal directly.
07:19:55 <bernalex> I can't say I've had that issue.
07:20:14 <maerwald> MichaelBurge_: Try it maybe. Wrong dependencies mostly happen when developers use stack. Other than that, stuff works.
07:20:31 <Cale> heh
07:20:33 <bernalex> which is not to say that it doesn't exist. I just have not encountered it. which I find odd, since stack users say it's the biggest problem ever.
07:21:17 <bernalex> having alternatives to cabal-install (i.e. having more frontends) is probably good though.
07:23:43 <maerwald> wouldn't even be surprised if some people use stack for their travis build -.-
07:26:37 <Profpatsch> wx doesn’t even build with stack.
07:26:52 <Profpatsch> But I’m on nixos, so I use nix anyway. :)
07:27:20 <adamCS> From a newish user perspective, stack has been easier than cabal for me.  Whatever it's named, I would have dependency issues with cabal that went away when I started using stack.  That being said, I appreciate that cabal might be a better choice for library maintainers.  Is this because it requires more careful attention to the dependency bounds, thus making your package more usable by others?
07:27:49 * hackagebot abnf 0.1.0.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.1.0.0 (Xandaros)
07:28:45 <Profpatsch> Is there any reason why I’d use State and not directly StateT?
07:28:54 <Profpatsch> Can I convert to StateT should I need it?
07:29:13 <ozgura> Profpatsch: these days State is StateT Identity anyway
07:29:23 <Profpatsch> ozgura: Yes, exactly.
07:29:41 <Profpatsch> I like to have only as much generalization as I need.
07:29:52 <EvanR> State by itself is kind of a wimpy abstraction
07:30:02 <Profpatsch> But e.g. for a library it doesn’t make sense to expose State, right?
07:30:04 <EvanR> StateT over IO is redundant
07:30:08 <ozgura> I generally use MonadState when defining functions, and only fix the monad later when running it
07:31:44 <MichaelBurge_> My StateTs often end up being RWSTs after a while.
07:32:05 <Profpatsch> Because the -> (History, Stuff) definitions of undo/redo lead to clumsy code.
07:32:20 <hpc> i haven't used StateT in ages
07:32:34 <EvanR> Profpatsch: it can be much clumsier i guarantee
07:32:39 <maerwald> I think I've only used the stateful Array thing or so. Not State directly
07:32:43 <hpc> the last thing i used it for had a big thunk-buildup space leak that i didn't feel like fixing
07:33:04 <Profpatsch> hpc: And you just use tuples now?
07:33:15 <hpc> i ended up rewriting that thing in perl for unrelated reasons, and i tend to use either mutation or threading things through myself ever since
07:33:34 <hpc> i also write significantly less stateful code now
07:33:52 <EvanR> Profpatsch: the suggestion was to write the lowest level operation for undo redo that way, which is dead simple, then you apply that however you want in the next layer of utility functions, which may or may not get and put the inputs and outputs from some arcade monad stack
07:34:03 <EvanR> not to use tuples throughout the code
07:34:12 <Profpatsch> Hm, it’s hard to make the undo history stuff less stateful. :)
07:34:15 <netsu> Hi there! How can I distribute my package with stack to hackage/stackage?
07:35:31 <EvanR> Profpatsch: in my current app, im not using tuples or monads for the "state". it takes some getting used to, mainly just not thinking about state as being this sort of global mutable variable
07:36:51 <lyxia> netsu: stack upload?
07:36:52 <Profpatsch> EvanR: What are you using instead?
07:37:12 <EvanR> theres a few interlocking components for the whole program
07:37:42 <lyxia> netsu: or stack sdist then manually upload the tarball via your browser
07:37:50 <netsu> lyxia: thanks!
07:38:11 <EvanR> but it boils down to a large nested data type
07:38:58 <Squarism> is there a way to see all "patterns" a functions match?
07:40:24 <lyxia> uh, look at the definition
07:41:21 <maerwald> nested data types are annoying. Especially because they force you to use lenses at some point.
07:42:20 <EvanR> Profpatsch: near the top level, where the front end driver is, animation is basically iterating s -> s. when i want to modify the s, then i choose which modification routine i want (which involves a StateT) and run it, getting the updated s back
07:42:22 <haskell766> hi. can anyone help me with one function please?
07:42:45 <Boomerang> haskell766: What function is it?
07:42:53 <EvanR> rather than StateT being where im storing the state, its a way to write the modification
07:43:31 <haskell766> i've got a type of it, but i can't understand what to write in its application
07:43:49 <haskell766> the type is:
07:44:21 <haskell766> co :: (b -> c) -> (a -> b) -> (a -> c)
07:44:30 <EvanR> maerwald: i have to use something like lenses anyway because im tracking access to the different parts
07:45:32 <maerwald> :t (.)
07:45:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:45:32 <Boomerang> haskell766: is it for an assignment (coursework) or is it your own work? :)
07:45:36 <maerwald> it's the belly button operator
07:45:49 <haskell766> no, it's just an exercise from the book
07:47:32 <Boomerang> so this function take two argument (that are functions) and you have to apply them in a way to get the output type. It is exactly what maerwald showed you
07:49:20 <haskell766> could u give me an example of how i can type it abstractly?
07:49:30 <Boomerang> :t lef f a b = a . b in f
07:49:31 <lambdabot> parse error on input ‘=’
07:49:37 <Boomerang> :t let f a b = a . b in f
07:49:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:49:46 <Boomerang> take a look at the source code
07:49:49 <Boomerang> @src (.)
07:49:49 <lambdabot> (f . g) x = f (g x)
07:50:24 <Boomerang> It is function composition just like in mathematics
07:51:08 <haskell766> the problem is i dont know math so good)
07:51:57 <haskell766> ok. i ll give you an example of what i'm trying to get
07:52:06 <Boomerang> alright :)
07:52:12 <haskell766> r :: [a] -> [a]
07:53:10 <haskell766> r x = if not (null x) then tail x else x
07:53:51 <Profpatsch> EvanR: now my quickcheck props look something like this: http://lpaste.net/165177
07:54:18 <haskell766> so how can i do the same with    co :: (b -> c) -> (a -> b) -> (b -> c) ?
07:55:11 <Profpatsch> Or can I easily use foobar -> (a, b) as a State a b?
07:55:32 <haskell766> nope )
07:55:38 <EvanR> Profpatsch: you can if you want
07:55:45 <jameseb> haskell766: what do you mean by "do the same with"?
07:55:47 <EvanR> :t state
07:55:48 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:56:12 <EvanR> odd that its reversed
07:56:16 <haskell766> how to write to someone concrete in this chat?)
07:56:24 <SoleSoul> Hi, how do I check what the meaning of the type ShowS is? It's the return type of 'shows' but I'm not sure what I'm getting.
07:56:36 <EvanR> :i ShowS
07:56:39 <Profpatsch> haskell766: It’s IRC, just mention someone’s name.
07:56:49 <Boomerang> haskell766: I'm not sure how your function r :: [a] -> [a] relates to the other one. By the way that function r is the same as tailSafe from the safe library :)
07:56:55 <merijn> SoleSoul: I think it's "String -> String", the way I'd find out is by clicking on "ShowS" in the docs to go to it's definition
07:57:01 <Akii> Profpatsch: I like you disliked techs :P
07:57:05 <haskell766> thanks)
07:57:05 <SoleSoul> EvanR: Thank you!
07:57:13 <Akii> (the fact that you dislike them, not the tech itself)
07:57:16 <umib0zu> Hey I think I brought this up before, but I started a reading group for Spivak’s Category Theory for Scientists. It’s not too late to join in, and I have found there are a lot of mathematician students and I’m the only programmer. If anyone is interested, give me a PM.
07:57:20 <SoleSoul> merijn: you are correct. Thanks
07:57:48 <merijn> SoleSoul: It's basicallly an application of DList to String
07:58:01 <Profpatsch> Akii: techs?
07:58:01 <merijn> SoleSoul: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
07:58:29 <merijn> umib0zu: Semi-related, have you read Bartosz stuff on CT for programmers?
07:58:44 <SoleSoul> merijn: thanks
07:58:46 <haskell766> Boomerang: it's not related. i just wanted to tell i don't care what the func does. it only matters that it satisfied the type )
07:58:51 <Akii> Profpatsch: https://stackoverflow.com/cv/profpatsch
07:59:14 <umib0zu> merijn no. I just read LYAH and I’m actually a javascript programmer by job. I’m totally new to diving into CT. Have any links?
07:59:18 <Profpatsch> Akii: Ugh, that’s very old.
07:59:25 <Profpatsch> I should probably revise it.
07:59:29 <haskell766> Boomerang: aren't u Russian? coz i am ))
07:59:42 <Akii> Profpatsch: it's 2 hops away from your twitter description :)
07:59:45 <Boomerang> haskell766: as shown before the composition function: (.) is exactly the right type. I am not Russian sorry...
08:00:29 <haskell766> Boomerang: but in the book there was no such func yet, so i should do it in other way
08:00:54 <merijn> umib0zu: First my disclaimer: I think CT is cool and interesting, there seems to be this idea that it helps (or even that you need it) for Haskell, which is an outright lie. As someone learning CT and knowing haskell, if your goal is being better at haskell I can recommend you easier things to invest your time in ;)
08:01:04 <Boomerang> :t let f a b c = a (b c) in f
08:01:05 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
08:01:12 <merijn> umib0zu: That being said, Bartosz' has a really solid blog series introducing CT for programmers: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
08:01:38 <haskell766> Boomerang: o_O
08:01:38 <dredozubov_> merijn: i'd even say that haskell is a good mind-bending tool to learn CT later
08:01:58 <dredozubov_> CT is definitely not necessary for learning haskell
08:02:05 <merijn> dredozubov_: Sure :)
08:02:15 <umib0zu> merijn to be honest, I was kind of excited to read Baez and physics and some things about music. I mostly want to learn the lingua franca of math. luckily I’m not a haskeller by job.
08:02:22 <merijn> Haskell is better suited to building CT abstractions in than other languages :)
08:02:41 <dredozubov_> i saw a tutorial bringing CT to the music theory
08:02:56 <Boomerang> haskell766: if you don't want to use partially applied functions, you could return a lambda function. Like this: f a b = \c -> a (b c)
08:02:59 <dredozubov_> it's ongoing, so it's interesting to see how it will develop
08:03:13 <merijn> umib0zu: That's fine, I just hate to see people wasting their time bashing their head against things they don't have to :) Learning CT because you're curious is great. I'm just trying to stop people from learning it just because they think they have to for haskell :p
08:03:23 <haskell766> Boomerang: YES ) that's what i'm asking for ))
08:03:50 <Boomerang> But that is exactly the same as the previous one ^^
08:04:49 <merijn> umib0zu: Incidentally, for curious people I can always recommend studying type theory (you will see lots of parallels with CT), the de facto standard book for that is Pierce's "Types and Programming Languages", and another incredibly useful and interesting thing is theorem proving (especially about programs), for which there is a great free book called "Software Foundations"
08:04:54 <merijn> @where sf
08:04:55 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
08:04:55 <lambdabot> assistant."
08:05:07 <merijn> (Incidentally, also co-written by Pierce)
08:05:24 <umib0zu> merijn ah I read Type Theory and Functional Programming. That was good. 
08:05:28 <haskell766> Boomerang: so, i shouldn't use any arguments in func at all?
08:05:35 <merijn> umib0zu: So if/when you get bored with CT have a look at those :)
08:07:23 <umib0zu> merijn I will. I’ve heard Pierce was good but haven’t had time to read it. but do you want a fair question related to CT in Haskell? How do I make a “proof” and assert it’s statement in Haskell? For example the Universal Property of Products is a statement like… “For all (…) There exists (…) such that (….)” My problem is the contents of the “such that”. How do I enforce a constraint on a universal quantifier that doesn’t amount 
08:07:23 <umib0zu> throwing an error if the constraint isn’t met?
08:07:51 * hackagebot funnyprint 0.0.1 - funnyPrint function to colorize GHCi output.  https://hackage.haskell.org/package/funnyprint-0.0.1 (netsu)
08:07:57 <Boomerang> haskell766: if you have a function f :: a -> b -> c, the following holds: (f x y) :: c, (f x) :: (b -> c) and obviously f :: (a -> b -> c)
08:09:11 <merijn> umib0zu: Well, if we're talking "types as proofs" ala Curry-Howard we're talking intuitionistic logic
08:09:55 <haskell766> Boomerang: THANKS!
08:10:06 <merijn> umib0zu: In which we only accept constructive proofs. A proof of the theorem "a -> b" consists of a value that has that type. Therefore a false theorem has no inhabitants
08:10:23 <merijn> umib0zu: i.e. "data Void"
08:11:21 <merijn> umib0zu: Except...Haskell being Turing complete it has non-termination (bottom), which inhabits every type. "Wait, if being inhabited is a proof and every type is inhabited in haskell, doesn't that mean I can proof any theorem?!"
08:11:32 <merijn> The answer is: "eh...well...yes"
08:11:40 <EvanR> which is very convenient
08:11:56 <merijn> Turing-completeness costs you the soundness of your logic
08:12:13 <EvanR> its like cheatcodes for logic
08:12:34 <merijn> umib0zu: If you really wanna do logic you want Coq or Agda, which are total language (they are not Turing complete, which prevents this shenanigans)
08:12:49 <merijn> umib0zu: Incidentally, the Software Foundations book I mentioned covers proving things using Coq
08:13:54 <merijn> Anyway, time for weekend for me
08:15:02 <umib0zu> merijn thanks. that makes sense. you’re saying because the UPP isn’t of the form A -> B, I can’t really “prove” it in Haskell.
08:15:29 <umib0zu> and you can’t really “prove” anything in Haskell. that’s fair.
08:15:56 <dredozubov_> i'd use coq or agda for that
08:16:02 <umib0zu> I’ll have to look at Pierce’s book. This book club thing is nice since I feel like I need some CT to get by, but I’ll add it to the list.
08:16:03 <dredozubov_> if i really want a proof
08:16:11 <dredozubov_> SF book is a good suggestion
08:16:17 <dredozubov_> i need to finish it myself :)
08:16:34 <umib0zu> merijn do you have a twitter by the way? PM it over to me and I’ll follow
08:16:40 <dolio> You can witness the universal mapping part for products in Haskell, and you can prove it's unique by reasoning about that mapping.
08:17:00 <dolio> The uniqueness proof just isn't a Haskell term.
08:17:49 <dolio> Products are easy, though. The problem is if you have a construction that involves equations, because equations can't really be internalized.
08:17:52 * hackagebot aeson-compat 0.3.4.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.4.0 (phadej)
08:18:57 <EvanR> can you elaborate on "equations can't really be internalized"
08:20:14 <phadej> You cannot have 'proof :: fmap id x \== x` in Haskell
08:20:36 <phadej> you can do something with `:~:`
08:20:39 <umib0zu> dolio you mean you can’t show commuting in haskell?
08:20:40 <dolio> Think of pullbacks. The definition involves types (for our purposes) A, B, C, and functions f :: A -> C and g :: B -> C. The pullback is an object Z with projections fst :: Z -> A and snd :: Z -> B such that f . fst = g . snd.
08:21:10 <umib0zu> like functions that commute implies a “path” of two functions equaling a different function. that’s kind of exactly what I’m asking when I’m asking about UPP.
08:21:19 <umib0zu> yes!
08:21:21 <dolio> When you go to construct Z, it involves having types that represent equations of values.
08:22:09 <dolio> You want the type of all pairs (a, b) such that f a = g b.
08:22:44 <umib0zu> Pullbacks are exactly it. It almost seems as if I can’t really do anything but throw errors if a pullback doesn’t commute in haskell.
08:22:48 <dolio> But there's no type 'f a = g b' to add to the type of pairs to get that subtype.
08:22:52 * hackagebot aeson-extra 0.3.2.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.2.0 (phadej)
08:23:34 <umib0zu> hm… well I’ll have to look into it. I’m not exactly sure about how to explain why it doesn’t work, but at least I know it doesn’t work and it sounds like you’re telling me it doesn’t work for a reason.
08:23:50 <dolio> Products you can do, though.
08:24:08 <dolio> Limits that don't involve equations on the arrows.
08:24:13 <dolio> (And colimits).
08:25:27 <dolio> There are ways you can kind of do pullbacks, and things like them, but it's not something you would ever want to do.
08:26:08 <dolio> It's the same as a way of encoding the free monoid.
08:26:22 <dolio> We have a class Monoid, and the convention that instances of Monoid must be monoids.
08:27:38 <dolio> So the type (forall r. Monoid r => (a -> r) -> r) is the free monoid, because the convention about monoids internalizes the equations in a way.
08:28:45 <dolio> Even though the type (forall r. r -> (r -> r -> r) -> (a -> r) -> r) is not the free monoid without quotienting by those conventional equations.
08:30:52 <dolio> So, to do pullbacks, for every choice of f :: A -> C and g :: B -> C, you can introduce 'class FGSpan z where l :: z -> A ; r :: z -> B', with the convention that instances must be such that f . l = g . r.
08:31:35 <dolio> And then the pullback is obtained in the same way as the free monad, by convention.
08:33:33 <dolio> Sorry, free monoid.
08:47:53 * hackagebot octane 0.6.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.6.1 (fozworth)
08:50:09 <nitrix> I wish people would stop giving fancy library names that has nothing to do with what the libraries does :(
08:51:29 <nitrix> Octane is a funny wink though.
08:52:19 <erisco> is there a parser for Haskell source that can recover from errors?
08:53:28 <greg`> erisco: you mean if it reaches something that doesnt parse it can continue?
08:54:37 <erisco> it should attempt to make sense of the erroneous string and also parse to the end of the string
08:54:48 <greg`> erisco: i first thought it wouldnt be possible. but if you just interpret parse error as bottom , it does a lot of that already
08:55:21 <erisco> it is easily possible, it is just a question of strategy
08:55:22 <hpc> how would it know when a parse fails, where it can seek up to and continue parsing?
08:55:39 <hpc> maybe the next top-level definition or something
08:55:52 <erisco> it knows if a parse fails the same way any parser knows a parse fails
08:56:05 <hpc> no, i mean
08:56:09 <hpc> when a parse fails
08:56:16 <hpc> you either stop, or you have to figure out where to continue from
08:56:24 <acowley> hpc: Maybe just keep trying restarting at the next token
08:56:25 <erisco> that isn't true
08:56:26 <hpc> i could have worded that better
08:57:03 <erisco> ignoring symbols is one approach, for sure, but not the only one
08:57:09 <Sparhawk> totally random question, is there a term for "a function with no free references"? like "myfunction() return 1"?
08:57:18 <erisco> anyways, I was just wondering if there was a parser for Haskell source that does this
08:57:19 <erisco> I guess not
08:57:26 <acowley> Sparhawk: closed
08:57:41 <Sparhawk> oh right
08:57:44 <Sparhawk> thanks
08:57:57 <hpc> combinator perhaps?
08:58:08 <acowley> erisco: Helium is, I believe, a teaching dialect for Haskell, so might do something user-friendly with parse errors. It is based on parsec, I think.
08:58:50 <Sparhawk> and a closed function is not necessarily pure is it? if it can have an unpure function as a bound reference
08:59:32 <nitrix> Sparhawk: Referential transparency is irrelevant of being closed or not.
08:59:42 <EvanR> purity != RT
08:59:44 <Cale> "supercombinator"
08:59:59 <acowley> Usually, a combinator wouldn't introduce a literal, but just apply one argument to another in some permutation.
08:59:59 <Sparhawk> yeah that's what I thought but someone disagreed with me, thanks again
09:00:06 <hpc> Cale: ah, that was it
09:00:08 <nitrix> EvanR: Wha'ts purity then?
09:00:48 <hpc> acowley: depends on what you consider a free reference vs being built-in
09:00:54 <acowley> Although people disagree about what a combinator is pretty often, so it's best to not get too hung up on it.
09:00:57 <acowley> hpc: Yeah
09:00:58 <EvanR> a pure function doesnt have side effects or depend on an environment that changes
09:01:03 <EvanR> its a function from math
09:01:14 <hpc> acowley: i was taking it for granted that Sparhawk is using a definition of free that admits that example not having any
09:01:27 <nitrix> EvanR: A function "from math" !?
09:01:33 <samwise> question, is it possible to constraint the value of a type? like say I want a function to only accept a list of length 5, is such a thing even possible with a type system?
09:01:34 <acowley> hpc: Well, his example used the literal "1"
09:01:44 <Sparhawk> I mean more from a technical viewpoint of a function not accessing anything outside its own definition
09:01:45 <EvanR> yeah its only uses the inputs to compute the output
09:01:58 <EvanR> (or some fixed environment like a closure)
09:02:01 <Sparhawk> (assuming constants are considered part of its definition)
09:02:48 <Cale> https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/220.HTM -- this chapter of SPJ's old book about implementing functional programming languages is perhaps relevant
09:02:52 <nitrix> EvanR: I think the property you're describing is referential transparency, where a function always evaluates to the same result given the same inputs.
09:02:59 <nitrix> EvanR: That's referential transparency.
09:03:00 <EvanR> nitrix: no, thats another thing
09:03:08 <EvanR> thats what purely functional programming is about, pure functions
09:03:22 <erisco> nitrix, the definition you just gave is purity
09:03:27 <EvanR> RT involves your ability to substitute things that supposedly equal in some context
09:03:38 <EvanR> are supposedly equal
09:03:55 <nitrix> Purely functional programming is a set of ideas that englobes purity, but purity is also a set of ideas that includes referential transparency.
09:04:00 <Sparhawk> purity is no side effects + referential transparency?
09:04:04 <nitrix> I don't know how you can psosibly think they are mutually exclusive.
09:04:05 <EvanR> pure = no side effects
09:04:32 <EvanR> it doesnt check the time or launch missiles when you evaluate
09:04:40 <Cale> But there's two different discussions going on here
09:05:04 <berndl> EvanR: but it warms up my CPU though...
09:05:14 <EvanR> use super conductors
09:05:15 <MichaelBurge_> Is there a reason a module might compile fine with GHC but can't be interpreted with GHCi, with the error "Illegal datatype context (use DatatypeContexts):"?
09:05:16 <Cale> (\x -> y) is an expression for a pure function, but it refers to a variable y which is not bound within the expression
09:05:28 <Sparhawk> mm well I guess I was kinda mixing up r-t and side-effects anyway
09:05:58 <acowley> MichaelBurge_: Are you using cabal to build, but loading a module directly with GHCI?
09:06:35 <samwise> so value contraint using a type system?
09:06:47 <EvanR> nitrix: i noticed in the last year people were curiously calling purity RT despite it being a much longer word and refers to quotation
09:06:58 <EvanR> i mean, contexts, one of which is quotation
09:07:02 <nitrix> EvanR: If you can substitute a function by its value without changing the behavior of the program, then the function has no side effects and is referentially transparent, by definition.
09:07:05 <erisco> RT is related to extensionality
09:07:28 <Cale> Referential transparency is the property that if two expressions are equal, i.e. they evaluate to the same result, then one may be substituted for the other without affecting the result of the program.
09:07:32 <MichaelBurge_> acowley: The exact command was 'stack repl' or 'stack ghci'. I guess your worry was that I had specified an extension in my .cabal that wouldn't be picked up with plain ghci?
09:07:39 <nitrix> Cale: I am well aware.
09:07:43 <Sparhawk> EvanR: guess who sees a bit more sense in Haskell since the last time=p
09:07:54 <acowley> MichaelBurge_: Yeah, that's what I was thinking
09:07:55 <nitrix> Cale: EvanR is insisting that there's something more to his jargon word "purity".
09:08:14 <erisco> you can have terms t1 and t2 which are semantically equivalent, yet have `f t1` and `f t2` mean different things
09:08:16 <Sparhawk> ...assuming you were the one tryng to teach me stuff my memory is awful
09:08:27 <EvanR> so you can say that specifically in programming a pure function has the nice property of being usable in a RT context, which is also true of other things besides functions, and generally you can talk about other kinds of contexts
09:08:37 <EvanR> but purity is a property of functions in programming
09:08:46 <dolio> Cale: How can two things be called 'equal' if they cannot be substituted for one another?
09:08:51 <EvanR> contexts can be RT or R opaque
09:09:12 <EvanR> dolio: if you substitute into an inapproriate context
09:09:34 <dolio> My two definitions for the jargon 'purity' and 'referential transparency' are different.
09:09:48 <erisco> seems no one agrees what these are, then
09:10:00 <greg`> i think theres a difference between equality and identity
09:10:10 <EvanR> it wasnt until haskell blogs i encountered RT being used for purity, i blame you all
09:10:15 <greg`> mainly an extra horizontal line :P
09:10:38 <dolio> EvanR: What makes them equal, then?
09:11:02 <EvanR> outside the context, you had a let perhaps ;)
09:11:19 <Koen__> equality is a relation between two elements of a same set, whereas identification is a relation between two elements of two sets linked by an isomorphism?
09:11:23 <EvanR> let x = frank in [bob, sue, x]
09:11:28 <nkaretnikov> in the recent HList, how do i refer to the result of HAppend xs ys in another typeclass constraint? HAppend xs ys ~ zs, HAppend zs ... doesn't work because HAppend expects kind * while the actual kind is Constraint
09:11:34 <EvanR> let x = frank in ["bob", "sue", "x"]
09:11:47 <EvanR> the second one is not ["bob", "sue", "frank"]
09:11:53 <EvanR> its referentially opaque
09:12:04 <Koen__> or context-dependant
09:12:28 <nkaretnikov> the old version used functional dependencies so the same could be expressed as just HAppend xs ys zs
09:12:33 <Koen__> any syntax highlighting text editor will make it very not-opaque
09:12:45 <EvanR> this has not much to do with side effects
09:12:48 <EvanR> or functions
09:13:16 <Koen__> it's just a coincidence that the alphabet used for programming and the alphabet used for strings happens to be the same
09:13:44 <Sparhawk> hieroglyphs for programming would have been cool though
09:14:06 <EvanR> Sparhawk: https://lh3.googleusercontent.com/-QQf4EVC6Yb4/VRfCAB29mvI/AAAAAAAANSM/HXFAPX0-smM/w599-h142/CBGuIJyWUAAP_bZ.png
09:14:21 <cobreadmonster> Guys like why can't we serialize thunks?
09:14:23 <Sparhawk> where do I sign up
09:14:31 <cobreadmonster> like cPickle for Haskell.
09:14:42 <cobreadmonster> cHickey, that's what we can call it.
09:14:47 <dolio> Anyhow, I think discussions about which jargon word means which thing aren't very useful.
09:14:51 <Cale> dolio: Well, I spoke quickly -- the "equality" we're talking about is really the equality of denotations of the results of evaluating the expressions, I suppose.
09:15:26 <dolio> The important part is which properties are worth caring about.
09:15:31 <EvanR> dolio: i just get annoyed when purity is called referential transparency, since its 3.5 times as long i feel like its an attempt to sound more profound
09:15:36 <dolio> And which way of specifying those properties is good.
09:15:37 <EvanR> which would be ok if it was even right ;)
09:15:46 <Koen__> EvanR: is that just the List.map function ?
09:15:51 <EvanR> yeah
09:15:58 <dolio> I also don't think any definitions that talk about 'values' are very good.
09:16:23 <EvanR> yeah value is weird
09:16:54 <Cale> EvanR: I don't recall hearing the term "purity" much in the very early days when I was learning Haskell. It really started to become popular much later.
09:17:13 <EvanR> purity was a big deal when i was learning scheme
09:17:17 <nkaretnikov> alternatively: is there a way to make Constraint match where * is expected?
09:17:23 <hpc> cobreadmonster: it depends on what the thunk closes over
09:17:24 <EvanR> there was a distinction to be made between pure and not pure functions
09:17:34 <EvanR> pure was better 
09:17:44 <EvanR> so i switched to haskell ;)
09:18:03 <cobreadmonster> hpc: So it's not possible in general?
09:18:05 <hpc> cobreadmonster: erp, ignore that, you said pickle and it had me thinking of impure functions
09:18:30 <hpc> cobreadmonster: maybe with the right runtime support it can be done in a classless way
09:18:32 <Cale> So people who learned Haskell earlier on probably use the term "referentially transparent" just because it was the term that people used to refer to that property that it's okay to reason equationally about programs and the things those programs reduce to under evaluation.
09:18:34 <sm> pure = no side-effect outputs, referentially transparent = no side-effect inputs ?
09:18:45 <hpc> which it would have to be, because a thunk can still close over arbitrary non-serializable values
09:18:53 <hpc> and have them not show up in the type signature
09:19:04 <EvanR> yeah RT lets you do equational reasoning
09:19:13 <dolio> I don't think 'side-effect' is a good thing to have in the definition, either.
09:19:14 <EvanR> which is more than just how functions work
09:19:34 <thoughtpolice> You can serialize arbitrary thunks or whatever in Haskell, today. But it's very fragile.
09:19:37 <thoughtpolice> @hackage packman
09:19:37 <lambdabot> http://hackage.haskell.org/package/packman
09:19:41 <dolio> It doesn't tell you why you'd want to care about it, other than using a bad word.
09:19:48 <hpc> cobreadmonster: if you use a sufficiently liberal definition of thunk, you can serialize a value by evaluating it and then serializing it
09:19:54 <hpc> but that's probably cheating
09:20:07 <EvanR> s/pure function/proper function/
09:20:07 <dolio> One property is, "I don't have to worry about evaluation order, except for termination."
09:20:11 <EvanR> s/impure function/procedure/
09:20:21 <cobreadmonster> hpc: Yeah, the point is to do interesting things like distributed computation.
09:20:25 <hpc> cobreadmonster: presumably you want hPickle bottom /= bottom
09:20:31 <dolio> Another property is, "I don't have to worry about factoring out/inlining subexpressions."
09:20:32 <thoughtpolice> Well, Packman might actually force things. But it can serialize arbitrary things; the type is something like `a -> IO SerializedThing`
09:21:03 <hpc> cobreadmonster: the other way would be to write an algorithm eDSL or something
09:21:17 <hpc> which expresses a serializable subset of haskell expressions
09:21:19 <thoughtpolice> But it's so fragile you can't even recompile an executable with identical code and still have the resulting values deserialize sensibly. So it's useful for only certain kinds of application.
09:21:31 <cobreadmonster> Like imagine if you can create something like a distributed computation monad?
09:21:45 <cobreadmonster> So like you literally don't have to worry about the parallelization or anything.
09:21:58 <cobreadmonster> The monad will send the thunks across and perform the computation elsewhere.
09:22:02 <hpc> if you have the exact same code running on every machine, you might be able to do something like what acid-state does
09:22:25 <Cale> EvanR: Or if you want to be a certain way about things, you can say s/pure function/function/
09:22:26 <hpc> acid-state keeps a serialized transaction log, which it occasionally applies to the disk state
09:22:29 <thoughtpolice> cobreadmonster: You can use Cloud Haskell, which has a lot of abstractions inspired by things like OTP. But broadly, yes, sure. If you use the relatively new `-XStaticPointers` extension, you can get relatively close to 'natively' being able to send function calls over the wire.
09:22:36 <EvanR> Cale: right
09:22:45 <hpc> (basically, loading from disk = read the current full state, then apply the log of transactions)
09:23:05 <cobreadmonster> thoughtpolice: That seems like what I want.
09:23:11 <cobreadmonster> Though, it's a bit more rigid.
09:23:19 <cobreadmonster> I'd like to be able to serialize continuations.
09:23:19 <hpc> cobreadmonster: those changes are expressed as values of type (Update ...) which is a full-blown monad
09:23:26 <cobreadmonster> hpc: Oh cool.
09:23:45 <hpc> cobreadmonster: but template haskell gives each one you specify a serialized form
09:23:51 <thoughtpolice> Static Pointers are also fairly flexible; for example library A can expose some functions, and two applications B and C can individually use A, and send 'function calls' over that use A over the wire. That's OK.
09:23:59 <EvanR> by occasionally applies you could mean it checkpoints, but the log is on disk as often as is sane for acid guarantees
09:24:07 <hpc> cookBacon :: Int -> String -> Update ...
09:24:10 <thoughtpolice> You can also do some weird stuff with polyvariadic functions, DSLs, TH, the same way Acid state sort of does, yes.
09:24:14 <hpc> has a serialized form automatically generated via
09:24:35 <hpc> data CookBacon = CookBacon Int String
09:24:38 <hpc> plus some instances
09:24:43 <cobreadmonster> thoughtpolice: this still feels sorta hack-y.
09:24:47 <thoughtpolice> But broadly, 'natively' serializing continuations and function calls is Difficult and not a premier feature.
09:24:48 <hpc> or something like that
09:25:13 <hpc> it might lump all the operations on a given state type into one data type, i haven't looked that closely
09:25:35 <cobreadmonster> thoughtpolice: ghc 9.0? :D
09:26:13 <EvanR> hpc: i believe theres a different type for each kind of update and view
09:26:16 <thoughtpolice> You can just use Packman today, like I said. But it's got its own set of limitations.
09:26:50 <thoughtpolice> Improving those things by working on GHC could happen, but only if you make it happen I'm afraid. :)
09:26:53 <EvanR> and you should (have to?) use safecopy to modify them after you have a live database
09:27:46 <EvanR> or else you cant reliably read the log anymore
09:31:37 <hpc> EvanR: yeah, there's a whole section of documentation just for how to update a data type
09:32:49 <etatoby> my ghci :info does not seem to know the fixity of (!!)
09:32:59 <etatoby> while the sources clearly state infixl 9 !!
09:33:08 <etatoby> and in fact it does associate left
09:33:19 <etatoby> do yours too?
09:33:27 <geekosaur> it may be not printing it because that's the default
09:33:31 <glguy> That's because it's the default
09:33:35 <etatoby> oh I see
09:33:59 <glguy> (though it probably makes sense to print it even if its using the default)
09:34:34 <etatoby> yeah, I just made myself a table of all the default operators and I was puzzled over !!
09:38:22 <netsu> Hello. Can I call shell command from ghci.conf e.g. to configure PROMPT?
09:40:51 <michaelt> netsu: you can change the prompt in .ghci yes
09:42:24 <netsu> michaelt: but I whant it by using some shell commands like `tput` to consider terminal type
09:44:28 <etatoby> netsu: I don't think you can call :set prompt conditionally in .ghci / ghci.conf
09:44:42 <geekosaur> I think you have to do stuff with :def to do that
09:45:10 <geekosaur> since that can run code in IO and produce a ghci command as a result, which can iirc be another :-command
09:45:12 <netsu> geekosaur: okay, thanks
09:45:34 <netsu> geekosaur: that's nice idea
09:46:04 <etatoby> netsu: personally I would just write a ghci shell script (or ghci.bat) that does the tests and invokes the real ghci with additional options
09:47:27 <etatoby> such as adding a -ghci-script colored-prompt.conf
09:57:56 * hackagebot hsyslog 4 - FFI interface to syslog(3) from POSIX.1-2001  https://hackage.haskell.org/package/hsyslog-4 (PeterSimons)
10:22:05 <dmwit> hvr: I see, thanks for letting me know.
10:26:41 <perax> Does the (>>) operator have a name?
10:26:59 <EvanR> corporal
10:29:15 <geekosaur> not really, no
10:29:22 <sbrg> yes, it's name is simon.
10:29:25 <sbrg> its
10:29:32 <EvanR> forgetful bind
10:29:34 <perax> :)
10:30:06 * geekosaur considered saying "yes, it's semicolon" >.>
10:30:10 <sbrg> forgetful, so good-byend. 
10:30:13 <sbrg> i'll show myself out.
10:30:42 <EvanR> so long good byend
10:31:04 <michaelt> perax: "and then"
10:32:39 <ph88> can anyone recommend a pretty printer ? i'm using attoparsec to go along with it
10:35:16 <ics> Looking for some help using function pointers with Inline-C package
10:35:41 <EvanR> for printing data structures ive had good results with GenericPretty
10:36:38 <ics> more specifically, I have some functions in C which I've already wrapped, but some of them take function pointers as callbacks
10:38:55 <ph88> not sure if my message was send due to unstable network:   can anyone recommend a pretty printer ? i'm using attoparsec to go along with it
10:39:16 <EvanR> for printing data structures ive had good results with GenericPretty
10:39:46 <ph88> oh, but i would like to keep show as it is 
10:39:51 <ics> and I'm unable to get a FunPtr of the right type (from a Haskell IO function) in my very elementary attempts
10:39:56 <EvanR> huh
10:40:00 <ph88> what do you think about mainland-pretty ?
10:40:07 <EvanR> GenericPretty doesnt deal with show
10:40:09 <mikail_> Hi, please can you help me understand this is function defintion: f :: (Functor f, Num (f Int)) => f String -> f Int -> f Int
10:40:20 <EvanR> havent tried mainland
10:40:46 <mikail_> I don't understand the Num (f Int) bit
10:40:53 <mikail_> what's happening there?
10:40:54 <ph88> mikail_, looks like it takes a  string functor and an  int functor  and returns an  int functor
10:41:16 <ph88> mikail_, looks like it says   (f Int) should be of the typeclass  Num
10:42:42 <mikail_> thanks ph88 - not sure why it needs the Num (f Int) then
10:42:51 <mikail_> if that is all it is doing - maybe I missing something
10:43:02 <mikail_> I am looking at this page : https://www.haskell.org/hugs/pages/users_guide/class-extensions.html
10:43:09 <ph88> mikail_, maybe its forced by the implementation of the function
10:45:03 <drdo> Is it just me or the Num and friends classes are a bit messy?
10:45:50 <geekosaur> more than a bit, yes
10:47:17 <etatoby> drdo: as a concept or implementation?
10:47:32 <etatoby> this cleared some thing up for me: http://perugini.cps.udayton.edu/teaching/books/PL/www/lecture_notes/figs/typeclass.png
10:47:32 <nkaretnikov> following up on my hlist question: i just defined a wrapper class: class HAppend a b => HAppend3 a b c | a b -> c and used that instead
10:48:45 <drdo> etatoby: I'm not sure what you mean. There are nice well-known algebraic structures that could have been used (i.e. rings and friends)
10:49:29 <dolio> 'Just' using algebraic structures doesn't really hold up to scrutiny very well.
10:49:38 <drdo> Num and the other classes seem extremely biased towards a handful of things
10:49:55 <drdo> dolio: How so?
10:50:14 <dolio> So, what classes are you going to have?
10:50:16 <dolio> Monoid?
10:50:41 <dolio> Group?
10:50:43 <EvanR> Num is a practical compromise for how numbers are usually treated in programming in a basic way, which is not very algebraic
10:50:53 <EvanR> the other numeric classes are kind of random
10:50:57 <drdo> EvanR: Yes, but the common parts could be in another class, with Num a superclass
10:51:03 <EvanR> except for the IEEE ones which are obviously for floats
10:51:36 <etatoby> if you look at the picture I posted, they are not random at all
10:51:40 <dolio> Once you get to Ring, there are two Monoid superclasses, because (semi)rings have two different monoid structures interacting.
10:51:41 <drdo> Fractional for example really wants to be a Field, but then there's that strange fromRational there
10:51:42 <EvanR> im not sure the Num superclass makes sense... it doesnt work like oop classes
10:52:24 <etatoby> each contains functions and operators that only apply to some specific type of numbers, eg. compex numbers are not ordered, and so on
10:52:57 <EvanR> etatoby: its pretty mixed up when you get past Integral
10:52:57 <drdo> etabot: I'm not saying they are, just very biased towards a few number sets
10:53:08 <drdo> And so they are awkward to use for anything else
10:53:15 <dolio> Also, abstract algebra tends to use * for non-commutative operations, and + for commutative operations, but both multiplication and addition of integer types are commutative.
10:53:21 <drdo> e.g. finite fields, polynomials
10:53:54 <EvanR> you can get very complicated trying to apply these structures
10:54:11 <EvanR> theres libraries which are tried all this
10:54:15 <EvanR> which have*
10:54:19 <drdo> dolio: So what? You can just have a ring class with both, and some are commutative and some aren't, what's the issue?
10:54:31 <EvanR> the Prelude is an attempt to make things sensible by default
10:54:53 <dolio> So rings are the only thing from algebra you're using?
10:54:55 <drdo> It's exactly like Monoid
10:55:00 <EvanR> floats arent really a ring
10:55:05 <EvanR> but they are Numbers ;)
10:55:06 <drdo> Some are groups, so what
10:55:17 <etatoby> how are floats not a ring
10:55:23 <EvanR> assoc law
10:55:24 <drdo> Some are commutative monoids, that's not a problem 
10:55:36 <ph88> whats the difference between build-depends and extra-deps?  i'm getting this message  https://paste.fedoraproject.org/374179/14649765/
10:55:53 <EvanR> some Nums are rings, some arent whats the problm
10:56:10 <glguy> ph88: build-depends capture the dependencies of your package. They express ranges
10:56:12 <drdo> EvanR: The problem is that Num and friends require a bunch of extra stuff
10:56:28 <EvanR> which class should exact-real be in ;)
10:56:28 <glguy> extra-deps: is the specific version of the package you want for that particual workspace
10:56:50 <glguy> ph88: The .cabal file describes the requirements of the package, the stack.yaml is just local information for what you're using right now
10:56:51 <EvanR> what does it require, that we can possibly achieve
10:57:45 <EvanR> at least Num isnt necessarily Eq (anymore)
10:57:54 <dolio> drdo: The problem is that you immediately punted when I started asking specific design questions about what 'use algebraic structures' means.
10:58:07 <dolio> And I didn't ask all the questions.
10:58:13 <adamCS> ph88: That error means that the package isn't in the set of packages (resolver) that stack is using.  In this case not even another version is in the resolver.  If you add it to extra-deps, stack will attempt to get it from hackage (?) and see if it all works.
10:58:30 <drdo> dolio: Are there known issues?
10:58:43 <dolio> I just brought some up.
10:59:12 <drdo> You have?
10:59:16 <adamCS> but if it's not in hackage you will need to add it to "packages:" either by github commit or downloading a version and giving the path to stack
10:59:31 <dolio> Okay, forget it.
10:59:36 <simpson> drdo: "So rings are the only things from algebra that you're using?"
10:59:54 <EvanR> its been suggested that Num is trying to be a Ring
11:00:01 <drdo> dolio: The Ring and Groupoid issue is the same issue as Num and Monoid
11:00:13 <simpson> I mean, I sympathize. My language that I've been designing *does* say that integers form a ring, but it doesn't go any further, nor does it try to force everybody to think in terms of rings.
11:00:15 <drdo> It's just a limitation of haskell
11:00:29 <EvanR> i think that Num cant be a Ring and satisfy some basic expectations about computer number folklore
11:00:58 <drdo> simpson: I mainly wanted Num to not hog the good symbols :P
11:01:17 <EvanR> simpson: is it a commutative ring? ;)
11:02:05 <mizu_no_oto_work> EvanR: Floating point numbers don't even form a monoid, right?
11:02:07 <simpson> EvanR: Well, yeah. It's a ring just like Haskell's Integers form a ring. (If you ignore _|_, of course.)
11:02:32 <EvanR> so we cant exploit commutative multiplication?
11:02:46 <EvanR> drdo: what kind of Num are you working on that cant satisfy Num's interface
11:02:58 * hackagebot funnyprint 0.0.2 - funnyPrint function to colorize GHCi output.  https://hackage.haskell.org/package/funnyprint-0.0.2 (netsu)
11:03:04 <etatoby> floats are an abomination, but a very useful one
11:03:07 <mizu_no_oto_work> Since floating point error means (((a + b) + c) +d) might not be a + (b + (c + d))
11:03:09 <drdo> EvanR: polynomials
11:03:10 <simpson> Honestly, the sticking point is that people want IEEE 754 numbers even though they're terrible.
11:03:56 <EvanR> well you can hide Num in your module, or use existing Ring packages and use their symbols
11:04:22 <mizu_no_oto_work> And I rather doubt that the distributive law holds for floats, either
11:04:27 <EvanR> it doesnt
11:04:29 <simpson> It doesn't.
11:04:33 <drdo> floats are just screwed up
11:04:43 <ph88> adamCS, aaah i see !
11:05:04 <adamCS> ph88:  Nice!
11:05:15 <drdo> simpson: Just let floats use some other symbols, and let us have the good ones for everything else :P
11:05:16 <mizu_no_oto_work> Well, they form a perfectly fine magma, at the very least :p
11:06:04 <simpson> drdo: That doesn't fix any of the problems that dolio brought up though.
11:06:21 <EvanR> i would rather use + for floats and ints
11:06:26 <simpson> In particular, the whole thing where implementing one kind of structure tends to give you *two* of another structure.
11:06:27 <drdo> simpson: Which problems are those?
11:06:37 <drdo> simpson: Yes, but that problem already exists
11:06:58 <Hijiri> Is there something recommended for localization in Haskell?
11:07:08 <simpson> drdo: You don't get to ignore a problem just because it's already noticed. In fact, that's generally the situation in which the problem matters even more!
11:07:25 <drdo> It's the reason that Data.Monoid.Sum and friends exist
11:07:28 <ph88> how can i get position information with attoparsec? or its impossible and i better use parsec ?
11:07:52 <drdo> simpson: There's just no solution to that problem in haskell afaik
11:08:12 <simpson> drdo: Okay. Then what did you have in mind for a Prelude built on these classes? Do you have example code somewhere?
11:08:39 <drdo> simpson: No, I don't. I was just trying to do some computation and noticed this difficulty :)
11:08:57 * EvanR gives drdo "other symbols"
11:09:05 <EvanR> have fun
11:09:08 <EvanR> ;)
11:09:31 <etatoby> drdo: don't polynomials have commutative * anyways?
11:09:41 <drdo> etatoby: yes, so what?
11:09:51 <drdo> That's not the issue, the issue is that you can't implement Num as a polynomial
11:10:09 <drdo> abs, signum
11:10:20 <EvanR> just leave them undefined
11:10:37 <drdo> EvanR: yes, of course, that's what the polynomial lib guy did
11:11:11 <drdo> But it's just not nice, and we could separate those out
11:12:02 <EvanR> that would expand constraints a lot relatively speaking for relatively little benefit
11:13:10 <EvanR> you can experiment with how horrible it can get by implementing your algebra in idris!
11:13:36 <shirt> What is the current state of the art for parallel haskell? "parallel" package? I want to do a parallel Data.List.find computation
11:13:50 <etatoby> I was thinking of idris too ;)
11:13:58 <drdo> EvanR: type level irreducible testing for the field instances would be interesting haha
11:14:27 <EvanR> you can put all the laws for all these things in the dependent type
11:14:35 <EvanR> dependent record type
11:14:45 <drdo> I'm sure you can, but I really just want to compute some stuff
11:14:58 <EvanR> abs = undefined
11:16:04 <ph88> damn looks like i took the wrong bet with attoparsec
11:17:07 <drdo> EvanR: yes yes, the difficulty now is that I need the prime integer congruence rings to be fields for the division algorithm
11:17:42 <EvanR> Fractional
11:17:43 <etatoby> or maybe invent some kind of abs and signum for polynomials, such as map abs and map signum over the coefficients
11:17:53 <etatoby> dunno if it would be useful ;) but it surely holds abs x * signum x == x
11:18:14 <etatoby> wait, maybe not
11:18:52 <simpson> etatoby: You could define the absolute value of a polynomial based on flipping the sign on the biggest-order coefficient to be positive and then flipping the rest of the polynomial accordingly.
11:19:01 <simpson> But I'm not sure what that would *mean* or what it would be *useful* for.
11:22:59 * hackagebot FTPLine 1.4.1.1 - A command-line FTP client.  https://hackage.haskell.org/package/FTPLine-1.4.1.1 (DanielDiaz)
11:23:00 <EvanR> does that imply an ordering to polynomials?
11:29:06 <amf> which function does one use to iterate over a list and find only one element when im in >1 monad? id use foldMap but there is no monoid instance for Either
11:29:26 <amf> (probably going to have to restructure and use Maybe)
11:31:38 <Cale> amf: I... don't understand what you mean by "when I'm in >1 monad"
11:32:00 <Cale> amf: In particular, what does it mean to be "in" a monad?
11:32:13 <Cale> Or more to the point, what's the type of the operation you want?
11:32:16 <amf> withZookeer (\x -> do runEither (-- code runs here))
11:32:50 <Cale> You can still use all the normal operations on lists in any expression...
11:33:11 <schell> monad stacks can be tricky to learn
11:34:05 <Cale> I don't like referring to them as stacks, I think it's misleading
11:34:34 <mgsloan> Yeah, I don't like that monad transformers are perceived by some as foundational
11:34:47 <mgsloan> When I think it's an added on hack ;)
11:35:02 <schell> Cale: monad nests?
11:35:03 <bernalex> Cale: how so?
11:35:10 <mgsloan> (a cool hack, true)
11:35:54 <ph88^> anyone have experience with megaparsec ?
11:36:25 <pyon> Given an unknown “Functor f”, and a type isomorphic to “Free f”, is it possible to determine what “f” should've been?
11:36:47 <Cale> schell: Just monads.
11:36:54 <pyon> (Up to isomorphism, of course.)
11:37:32 <Cale> schell: If you obtain an Integer by applying a bunch of functions f, g, h :: Integer -> Integer, like f (g (h 6)), you'd never call that an "Integer stack"
11:37:36 <schell> Cale: shouldn’t we at least mention monad transformers?  
11:37:57 <ph88^> is it possible to have a type with a list where its required that the list has minimally one element ?
11:38:00 <Cale> You can mention monad transformers :)
11:38:14 <Cale> Monad transformers are a thing, monads are a thing
11:38:15 <schell> Cale: but we do have a word for that, composition!
11:38:31 <fishythefish> ph88^: https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
11:38:32 <schell> so then, monad transformer composition?
11:38:34 <EvanR> its possible to see composition and think stacks
11:38:40 <EvanR> but its totally bogus
11:38:41 <Cale> Yeah, you can compose monad transformers in order to form new monad transformers... if that's what you're doing.
11:38:50 <Cale> Usually you apply monad transformers to obtain new monads.
11:38:54 <michaelt> pyon: it's easy enough in practice at least in happy cases. 
11:39:01 <schell> Cale: i see what you’re saying
11:39:11 <EvanR> in f . g . h, its not a stack because you can append or prepend more functions
11:39:13 <schell> the result really is one monad
11:39:18 <Cale> yes
11:39:19 <pyon> michaelt: Yeah, I've noticed that in cases that arise in actual programming, it's easy.
11:39:32 <Cale> If you have to think about all the monads you got along the way, you're doing it wrong.
11:39:51 <schell> I can agree with that
11:40:07 <bernalex> I wonder, does a rapist have a hard-on when he leaves the house in the morning,
11:40:09 <bernalex> or does he develop it during the day while he's walking around looking for somebody.
11:40:10 <pyon> EvanR: when you compose a bunch of functions, internally, in memory, you effectively have them arranged in a list, right?
11:40:13 <bernalex> hmmmmmm this might be the wrong buffer
11:40:18 <Cale> bernalex: wrong channel!
11:40:18 <fishythefish> lolwut
11:40:29 <bernalex> fishythefish: it's a george carlin bit lol
11:40:56 <fishythefish> bernalex: yeah, I recognize the question, but was trying to figure out what that was a metaphor for in this channel :P
11:41:12 <schell> Cale, EvanR: maybe if one needs to use all their monads’ contexts in the raw one should use freer?
11:41:22 <bernalex> fishythefish: that wasn't my intention. :p
11:41:31 <EvanR> pyon: f . g . h ? its probably a tree of some sort
11:41:58 <fishythefish> bernalex: I had a pang of self-doubt when I wondered if I missed a deep truth about monad transformers hidden in that line
11:42:01 <EvanR> or its been compiled by ghc into something awesome
11:42:16 <Cale> schell: I also don't know what "contexts" refers to
11:42:29 <bernalex> Cale: I kind of agree with your reasoning. I have just referred to them as "stacks" out of convention.
11:42:54 <Cale> It's a weird convention, and I don't know where it came from :D
11:43:00 * hackagebot pretty 1.1.3.4 - Pretty-printing library  https://hackage.haskell.org/package/pretty-1.1.3.4 (DavidTerei)
11:43:09 <bernalex> probably the same person as the one who "shortened" hamburger to burger.
11:43:15 <Cale> It started at some point a while ago, and I think it creates a lot of confusion
11:43:16 <schell> Cale: mmm - like running lifted reader computations in a transformer non-stack where reader is just one of many contexts ;)
11:43:29 <EvanR> heres another problem with monad stacks, you can have an empty stack but not an empty monad stack
11:43:37 <bernalex> Cale: I guess maybe it has something to do with how the fact that they are ordered is very important.
11:43:41 <Cale> schell: The monad you end up with is either a MonadReader instance, or it is not.
11:44:20 <Cale> bernalex: The order in which you apply functions to an Integer to get subsequent Integer values also tends to be pretty important :)
11:44:45 <schell> Cale: couldn’t you be using a transformer without using mtl? in that case this specific reader may not have a MonadReader instance, correct?
11:44:50 <Cale> Or even with other sorts of types
11:44:54 <EvanR> when you pop the stack 4:[] you get [], but if you pop the "stack" Reader Int, you get...
11:45:09 <schell> Cale: nit picking but i know what you mean
11:45:42 <Cale> schell: Well, sure. You apply lift to convert actions of your original monad to actions in the transformed monad.
11:45:50 <schell> EvanR: i think popping the stack in this case would be running the reader
11:45:58 <EvanR> o_O
11:46:09 <EvanR> now its just getting silly
11:46:15 <Cale> :t lift
11:46:16 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:46:18 <schell> i’m just playing devils advocate
11:46:47 <schell> there’s an analogy - it doesn’t fit glovely
11:46:49 <Cale> No, it's a fair point that something like MonadReader isn't necessarily required
11:47:07 <EvanR> when i heard someone refer to f . g . h as a stack, i was really hoping "popping" was finally applying something to it
11:47:23 <EvanR> wasnt* applying
11:48:00 * hackagebot binary 0.8.4.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.4.0 (LennartKolmodin)
11:48:04 <pyon> “<EvanR> pyon: f . g . h ? its probably a tree of some sort” --> i think of it as folding a type-aligned sequence: http://hackage.haskell.org/package/type-aligned
11:48:33 <EvanR> its not a type aligned sequence..
11:48:51 <EvanR> semantically youre not suppose to care about the grouping at all
11:48:58 <schell> EvanR: i think it would be a bit different, because unlike regular composed functions, composed monad transformers can be “ran” to give you a new monad that you can run again  
11:49:00 <EvanR> only the initial and final types
11:49:06 <Cale> But typically what you're going to do is to build up a library of actions of your finished monad by lifting actions from the monads that you transformed along the way, and then you're going to export an API that hides the fact that monad transformers were involved.
11:49:11 <pyon> EvanR: a type-aligned sequence doesn't care about the intermediate types either
11:49:21 <pyon> EvanR: they're all existentially quantified
11:49:29 <EvanR> schell: then what is push?
11:49:52 <schell> “wrapping” another monad transformer
11:50:02 <EvanR> pyon: but theres 1 type per node there
11:50:08 <Cale> Wait, when do we wrap monad transformers?
11:50:16 <EvanR> and its a sequence
11:50:18 <Cale> We don't have monad transformer transformers, usually
11:50:24 <schell> Cale: lol
11:50:26 <Cale> (though we could)
11:50:32 <EvanR> . is a tree node and 2 types are involved
11:50:33 <schell> i knew you wouldn’t like that terminology :)
11:50:52 <pyon> EvanR: there are actually 2 types per sequence: initial and final... you can compose sequences if the final type of the prefix is the initla type of the suffix
11:51:16 <Cale> schell: An easy way to tell is to look at the kind of the type you're thinking about
11:51:31 <Cale> schell: If it's * -> *, then you might be able to call it a monad
11:51:33 <pyon> EvanR: the empty sequence has equal initial and final types
11:51:46 <Cale> If it's (* -> *) -> (* -> *), then you might be able to call it a monad transformer
11:51:51 <EvanR> pyon: i thought you could nest any thing you want inside such a thing
11:52:08 <Cale> But things of kind * -> * can't be monad transformers
11:52:10 <EvanR> its polymorphic
11:52:25 <EvanR> the analogy seems remote
11:52:34 <pyon> EvanR: type-aligned sequences are basically the free category from a quiver, just like lists (ignoring the possibility of infinite lists) are the free monoid from a set
11:52:42 <schell> Cale: my kind game is an area i need to improve
11:53:31 <EvanR> because of the polymorphism i have a hard time taking that category seriously
11:53:33 <Cale> and it's weird to talk about monads of kind (* -> *) -> (* -> *) -- though there might be monads on the category of endofunctors in Haskell, I don't really know what those look like.
11:53:44 <Cale> (and we don't have a type class for them)
11:53:51 <schell> i think the argument in favor of calling these things monad “stacks” is to save key presses
11:53:52 <pyon> EvanR: every element of a type-aligned sequence is some “f a b”, then the next element must be some “f b c”, then the next some “f c d”, and so on... by existentially quantifying all the intermediate types, the result is type-aligned sequence only cares about the initial and final types
11:53:56 <EvanR> you can nest aynthing, its not specific to any type
11:54:22 <EvanR> oh, arbitrary bifunctor?
11:54:31 <pyon> EvanR: arbitrary binary type constructor even
11:54:51 <pyon> EvanR: all that's needed is that it has kind “k -> k -> *” for some fixed k
11:55:06 <EvanR> .. how would ensure it could be constructed even
11:55:09 <schell> Cale, EvanR: back to work for me :) o/
11:56:26 <Cale> schell: You might imagine a "stack" of separate monads when you're working with, say, StateT Integer (WriterT (Product Rational) []), then you have WriterT (Product Rational) [] and [] below that, but I don't know if this is what people are referring to, and if so, I think it's distracting if you're constantly thinking about all of the monads, rather than the one you ended up with.
11:56:33 <pyon> EvanR: “cons :: f a b -> Seq f b c -> Seq f a c”, “append :: Seq f a b -> Seq f b c -> Seq f a c”
11:57:17 <EvanR> well that structure is also a tree
11:57:22 <EvanR> ignoring the assoc
11:57:49 <schell> Cale: yes, i think that is what people are imagining and yes i think you’re correct that it’s distracting
11:57:49 <pyon> EvanR: i guess so, if you view a list as a degenerate tree
11:58:32 <EvanR> no i mean "in memory"
11:58:42 <EvanR> in the fictional graph reduction picture
11:59:55 <pyon> EvanR: ah i have no idea what might happen in physical memory in a haskell program compiled with ghc :-p
12:00:56 <pyon> EvanR: all that i know is that, no matter what that representation is, logically, a chain of nested functions is like foldr1'ing a type-aligned sequence containing all those functions
12:01:25 <pyon> errr s/nested//
12:01:28 <EvanR> logically, its the grouping agnostic composition directly to the final product ;)
12:01:55 <tempeh> Hi guys. I was recently using MonadState, and realized that some of my MonadState functions never modified the state. It occured to me that it would be nice to specify this at type level. Ideally, there would be a MonadReader implementation of StateT, but it seems that leads to overlapping instances. Is there another nice solution? Looking for thoughts :)
12:02:00 <pyon> EvanR: that's just because the binary operation you're passing to the fold happens to be associative :-p
12:02:01 <EvanR> it doesnt matter if you fold left right or both ways
12:02:31 <tempeh> MonadReader instance*
12:02:39 <pyon> EvanR: i said foldr1 specifically because “infixr 9 .” or so ghci tells me
12:03:05 <pyon> EvanR: but as you correctly note, from the pov of the final result, it doesn't matter if it's a left or right fold
12:03:22 <EvanR> or a randomly selected order of evaluation
12:03:27 <pyon> yup
12:08:43 <hshiraiwa> does anybody knows a good source to learn functional programming ?
12:09:45 <maerwald> functional programming is a paradigm with many forms
12:10:22 <nineonine> hi everyone
12:10:31 <nineonine> has anyone read this book ?
12:10:33 <nineonine> Categorical Combinators, Sequential Algorithms, and Functional Programming (Progress in Theoretical Computer Science) 
12:10:35 <schell> hshiraraiwa: bitemyapp has been working on a link list (and more i’m sure)
12:10:45 <nineonine> by 
12:10:46 <nineonine> P.-L. Curien
12:11:05 <nineonine> http://www.amazon.com/gp/product/0817636544/ref=olp_product_details?ie=UTF8&me=
12:11:27 <hshiraiwa> maerwald: i just want to learn something new
12:17:45 <bernalex> hshiraiwa: we don't know what you already know. maybe try Introduction to Functional Programming Using haskell
12:18:24 <bernalex> hshiraiwa: the latest edition is quite new -- https://www.amazon.co.uk/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643/277-3921352-8742348?ie=UTF8&*Version*=1&*entries*=0
12:19:58 <hshiraiwa> bernalex: thanks i'll take a look. I only know the basics of the paradigm
12:20:15 <bernalex> it's called "Thinking Functionally with Haskell". it was previously entitled "Introduction to Functional Programming using Haskell", and prior to that simply "Introduction to Functional Programming". lots of people like it.
12:20:44 <bernalex> doesn't emeijer have a mooc using haskell too?
12:20:59 <bernalex> hshiraiwa: 
12:21:01 <bernalex> https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0
12:22:54 <hshiraiwa> bernalex, thanks a lot
12:25:13 <monochrom> yes emeijer had a mooc using haskell. and it was famous, or notorious, because he inflicted hugs on the students. the problem is that the students needed tech support for hugs but these days no one is interested.
12:28:02 * hackagebot cpsa 3.3.1 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.3.1 (mliskov)
12:34:31 <bernalex> monochrom: you didn't *have* to use hugs though. it's a mooc, so it's kind of inherent that you need to spend a bunch of time on it outside the actual course.
12:34:39 <bernalex> monochrom: I agree that it's bad and misleading though.
12:35:34 <monochrom> actually I am ambivalent on whether it's bad and/or misleading.
12:47:26 <kern_> regarding the book, somebody put the "Thinking Functionally with Haskell" book on archive.org -> https://archive.org/details/pdfy-9mSqnvZwb98w41N8
12:52:33 <Cale> kern_: ah, cool
12:54:12 <Cale> Richard Bird has a lot of good stuff related to transforming programs by using equational laws, and it looks like that book is no exception :)
12:55:04 <Cherim_> In case somebody doesn't know about gen.lib.rus.ec, that book was there since 2014.
13:12:06 <minib00m> ggVGc: sounds cool! :D
13:33:53 <fr33domlover> @src join
13:33:53 <lambdabot> join x = x >>= id
13:34:34 <fr33domlover> is that the join I thin? :P
13:34:38 <fr33domlover> @type join
13:34:39 <lambdabot> Monad m => m (m a) -> m a
13:34:46 <fr33domlover> ah yes it is
13:35:18 <fr33domlover> *think
13:45:08 <zv> has anyone here ever used the GHC maude model extension?
13:57:53 <tempeh> I remember reading on reddit a while ago about a 'design pattern' for only asking for a subset of the state from a MonadState. Anyone remember that article/know where to find it?
13:58:06 * hackagebot hylolib 1.5.0 - Tools for hybrid logics related programs  https://hackage.haskell.org/package/hylolib-1.5.0 (GuillaumeHoffmann)
13:58:37 <coppro> tempeh: zoom?
13:59:41 <tempeh> coppro: it was at the type level. so like if your whole app needs state (a, b, c), but some function only needs a and other needs (a, b)
14:00:42 <coppro> tempeh: yes, that's zoom
14:01:07 <|meta> I read somewhere that SPJ has expressed opinions that Haskell shouldn't be used in production. Is that true?
14:01:20 <|meta> Is it true that it shouldn't be used in production, I mean
14:01:56 <tempeh> coppro: huh. I'll look into it, but I'm sure that's not what I was reading about
14:02:24 <tempeh> |meta: no :) I think he said that quite a while ago, before we had some more practical features
14:02:29 <nitrix> |meta: Yeah, the second you put a line of Haskell code in production, everything breaks.
14:02:41 <tempeh> when haskell started out it was very much unusable. that was a long time ago
14:02:43 <nitrix> |meta: Do not ever use Haskell. Don't even learn it.
14:02:55 <schell> |meta: i know many of us *are* using haskell in production, if that helps ease your woes
14:02:57 <|meta> I've always strayed away from Haskell, but it seems like the more I program, the more things that I want
14:03:06 <coppro> nitrix: how long until GHC supports -XProductionReady?
14:03:32 <nitrix> |meta: Also, discard Facebook and other large companies using Haskell, they don't know what they're doing.
14:03:50 <|meta> ah, thats a good point
14:03:53 <nitrix> I think the important lesson is to interpret everything we read only as godsend.
14:03:56 <yyyyy> my life would be a little sadder without haskell in production here. i ironed out quite a few bugs from legacy systems by migrating services to it.
14:03:58 <nitrix> *online.
14:05:14 <maerwald> uhm, how do I show an exception without using the Show instance? -.-
14:05:27 <coppro> maerwald: manually?
14:05:35 <maerwald> aha
14:05:44 <buttbutter> Hey. I'm trying to understand why haskell can short-circuit evaluation with foldr but not foldl. Can someone explain?
14:05:48 <fr33domlover> I have a function (a -> Maybe b) and I'd like to take [a] or some Foldable a, and return (Maybe b) for the first matching item. Is there an existing function for that?
14:06:05 <fr33domlover> The closest I found is 'find' and 'lookup'
14:06:17 <fr33domlover> but neither are that thing
14:07:26 <glguy> buttbutter: foldl can short circuit, it's just working from the lsat element in
14:07:27 <glguy> > foldl (\x y -> y && x) True [undefined, undefined, False]
14:07:29 <lambdabot>  False
14:08:18 <buttbutter> That's equivalent to (((undefined &&) && undefined) && False), right?
14:08:23 <buttbutter> Oh, wait.
14:08:29 <nitrix> head . catMaybes . map ?
14:08:40 <buttbutter> That's equivalent to (((True && undefined) && undefined) && False), right?
14:08:41 <buttbutter> That.
14:08:53 <glguy> buttbutter: no, it's False && (undefined && (undefined && True))
14:08:57 <fr33domlover> listToMaybe . catMaybes . map
14:09:12 <fr33domlover> listToMaybe . mapMaybe
14:09:18 <fr33domlover> that should do
14:09:20 <kern_> |meta: SPJ said that you shouldn't use haskell during a time where the only possible way of having side-effects was, that your haskell program was of type ( String -> String ) and you attached stdin and stdout to it.
14:09:25 <glguy> > foldl f z [a,b,c]
14:09:26 <lambdabot>  f (f (f z a) b) c
14:10:20 <|meta> yeah I didnt realize how old that quote was. I saw it recently and just assumed, since I'm not really plugged in
14:10:29 <glguy> buttbutter: If any of those uses of 'f' ignore their first argument, then they won't be evaluated
14:10:33 <buttbutter> Isn't that what I wrote?
14:10:48 <glguy> buttbutter: No, you had it backward
14:11:08 <glguy> In a && b, b might not be evaluated, but a always is
14:11:08 <nitrix> @let myFirst = listToMaybe . mapMaybe
14:11:09 <lambdabot>  .L.hs:161:25:
14:11:10 <lambdabot>      Couldn't match type ‘[a1] -> [b]’ with ‘[a]’
14:11:10 <lambdabot>      Expected type: (a1 -> Maybe b) -> [a]
14:11:29 <buttbutter> If you let f = (&&), then (&&) ( (&&) ( (&&) z a) b ) c =  (((z && a) && b) && c)...right?
14:11:49 <glguy> yeah, but f was not &&, it was the flipped &&
14:12:07 <buttbutter> Flipped &&? I'm confused:C
14:12:14 <glguy> (\x y -> y && x)
14:12:36 <buttbutter> Ohh.
14:12:46 <buttbutter> My brain glossed that over :)
14:12:55 <fr33domlover> @type mapMaybe
14:12:56 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:13:07 * hackagebot haskell-gi 0.17.4 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.17.4 (inaki)
14:13:09 <glguy> > foldl (\_ x -> Just x) Nothing [undefined, undefined, 7]
14:13:10 <lambdabot>  Just 7
14:13:43 <buttbutter> So in a similar vein foldr (&&) True [undefined, undefined, False] also short-circuits
14:13:53 <fr33domlover> @type \ f -> listToMaybe . mapMaybe f
14:13:54 <lambdabot> (a1 -> Maybe a) -> [a1] -> Maybe a
14:13:56 <buttbutter> It's just a matter of whether False is evaluated first, right?
14:14:07 <glguy> > foldr (&&) True [undefined, undefined, False]
14:14:08 <buttbutter> Well, whether the function is applied to the False element of the list first.
14:14:08 <lambdabot>  *Exception: Prelude.undefined
14:14:14 <buttbutter> Damnit >:C
14:14:50 <glguy> foldr associates the other way. since foldl starts at the end of the list you can't use it on an infinite list
14:15:01 <glguy> but foldr starts at the front of the list, so you can use it on an infinite list
14:15:30 <buttbutter> Okay, I'm confused again.
14:15:36 <buttbutter> I thought foldr "eats" elements from the right.
14:15:43 <buttbutter> Right to left.
14:15:47 <glguy> > foldr f z [a,b,c]
14:15:48 <lambdabot>  f a (f b (f c z))
14:15:55 <glguy> no, the outermost f is applied to the first element
14:16:10 <glguy> so if you ignore the second argument to f you can stop processing the list
14:16:21 <glguy> > foldl f z [a,b,c]
14:16:22 <buttbutter> Ohh. 
14:16:23 <lambdabot>  f (f (f z a) b) c
14:16:25 <dolio> foldl starts not-looping at the end of the list.
14:16:26 <glguy> Outermost f is applied to the last element
14:16:49 <buttbutter> That's hard to think about.
14:17:00 <buttbutter> Since, the inner-most nested parens on foldr are the last element.
14:17:20 <buttbutter> But I understand it. :)
14:17:40 <buttbutter> So that's just lazy evaluation in action, right?
14:18:04 <buttbutter> Haskell doesn't even touch (f b (f c z)) since a = False and we know that anything anded with False is False.
14:18:07 * hackagebot tidal-midi 0.8 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.8 (AlexMcLean)
14:18:09 * hackagebot tidal 0.8 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.8 (AlexMcLean)
14:18:42 <nitrix> buttbutter: It depends if `f` is strict and in which arguments.
14:18:50 <nitrix> Then the choice of foldr vs foldl becomes important.
14:19:09 <glguy> specifically because the way && is implemented is that if the first argument is False then the second is ignored, but you could implement that differently if you wanted it to be strict in both arguments
14:19:10 <dolio> Strictly speaking, it doesn't even go from `foldr f z [b,c]` to `f b (f c z)`.
14:19:11 <Cale> And yes, it's that lazy evaluation is outermost-first
14:19:29 <buttbutter> nitrix: strict = not lazy?
14:19:33 <Cale> right, it leaves that as a foldr
14:22:59 <Cale> buttbutter: The technical definition of a strict function f is that f ⊥ = ⊥, where ⊥ is the value of an expression which doesn't terminate (or produces an exception) -- putting it another way, in order to evaluate f x, you must evaluate x
14:23:01 <buttbutter> So just to make sure I really understand. foldr f z [a,b,c] = foldr f (f z a) [b,c], right? Does the compiler then apply f to z and a? Why isn't it lazy and just makes a thunk out of it?
14:23:07 * hackagebot bond 0.4.1.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.4.1.0 (chwarr)
14:23:11 <Cale> no, that's foldl you did
14:23:14 <Cale> @src foldl
14:23:14 <lambdabot> foldl f z []     = z
14:23:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:23:18 <Cale> @src foldr
14:23:18 <lambdabot> foldr f z []     = z
14:23:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:23:19 <buttbutter> ARggh
14:23:50 <Cale> foldr f z [a,b,c] -> f a (foldr f z [b,c])
14:24:07 <buttbutter> Ah. Right. That makes way more sense.
14:24:22 <Cale> and then f is applied, and only when its second argument gets pattern matched will the foldr continue
14:24:27 <buttbutter> So THEN, we try to evaluate f. And if f = (&&) and a = False we can just quit there since we know it has to be False regardless of the second argument, right?
14:24:29 <maerwald> how can I make umlauts not get messed up when showing exceptions? I barely have control over what happens there
14:24:32 <Cale> right
14:24:41 <buttbutter> Okay! :)
14:24:59 <buttbutter> Thank you!
14:25:17 <monochrom> maerwald: I think you'll have to first find out what messes it up.
14:25:18 <nitrix> Alternatively, you may want `all`.
14:25:20 <Cale> maerwald: uhh... check that your system locale is set correctly or something? They show up okay for me.
14:25:20 <nitrix> :t all
14:25:22 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:25:30 <maerwald> monochrom: the show instance of SomeException ofc
14:25:43 <maerwald> Cale: that's not the problem
14:25:59 <maerwald> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#v:displayException
14:26:24 <Cale> ah, I see
14:26:40 <Cale> What kind of exception is it?
14:26:44 <glguy> maerwald: you need to put it as a string, not show it again
14:26:46 <maerwald> IOException
14:26:50 <monochrom> eh, displayException is pretty new
14:27:00 <lpaste> glguy pasted “umlauts in errors” at http://lpaste.net/165220
14:27:24 <glguy> Maybe that's what you're seeing?
14:27:25 <monochrom> yeah, what glguy said
14:27:30 <maerwald> glguy: I need it as string, I cannot print it
14:27:56 <monochrom> ok, but glguy's experiment shows that the string content is not messed up.
14:28:09 <monochrom> because if the string content were messed up, putStrLn could not fix it.
14:28:09 <glguy> maerwald: That fine, but however you're looking at this thing at the end you need to do it in a way that doesn't cause another pass of "show"
14:28:20 <Cale> Prelude Control.Exception> show (userError "föö")
14:28:20 <Cale> "user error (f\246\246)"
14:28:35 <monochrom> at this point I'm pretty sure you conclude "monochrom is not helping"
14:28:36 <Cale> ^^ I think this is what maerwald is referring to
14:28:50 <glguy> Cale: same thing
14:28:52 <maerwald> I am passing the exception as a String to a gtk+ function.
14:29:04 <maerwald> umlauts work fine in my program, except for exceptions
14:29:26 <maerwald> because I mostly use GlibString instances, without showing anything
14:30:12 <Cale> oh, yeah, that's not a problem
14:30:18 <Cale> (what I showed)
14:30:28 <Cale> Prelude Control.Exception> print (userError "föö")
14:30:28 <Cale> user error (föö)
14:30:31 <Cale> working :)
14:30:42 <maerwald> I cannot use "print"
14:30:48 <Cale> So it's just a matter of not applying show an additional time
14:30:54 <maerwald> I don't...
14:31:08 <monochrom> I don't know GlibString.
14:31:44 <monochrom> "GlibString instances"? so that means it's a type class that could have faulty instances?
14:32:08 <glguy> Maybe the umlaut is getting scrambled before it goes into the exception message
14:32:20 <monochrom> can you circumvent GlibString altogether?
14:33:05 <maerwald> monochrom: no
14:33:07 <maerwald> https://hackage.haskell.org/package/gtk3-0.14.2/docs/Graphics-UI-Gtk-Windows-MessageDialog.html#v:messageDialogNew
14:33:09 <monochrom> in fact I haven't seen a complete experiment that reproduces what you observed, so everything I said can be blind guesses
14:34:01 <monochrom> at this point I don't think anyone knows how many stages of mistranslations there are in the whole chain and where the mistranslation in the chain happened
14:34:09 <monochrom> nobody. nooobody
14:34:42 <monochrom> because all we're doing up to now is ecstatic abstract talk
14:34:42 <maerwald> the problem is the exception library making assumptions about how to convert an exception to a string
14:34:44 <parsnipM_> any clues as to why one would bother to use Function rather than simply CoArbitrary? 
14:34:45 * geekosaur pokes, sees GlibString only has instances for [Char] and Text. so the question is where the exception as a string came from
14:34:50 <monochrom> and squeezing out toothpaste 1mm at a time
14:34:54 <Cale> maerwald: Can you print the exception and show us the result of that?
14:35:11 <monochrom> or perhaps 1ml
14:35:32 <glguy> isn't 1ml pretty much toothpaste?
14:35:42 <monochrom> yeah. make it 0.1ml
14:35:47 <glguy> OK, thanks.
14:36:30 <maerwald> Cale: 'print e' is messed up too. And this is an IOException I have no control over.
14:36:38 <monochrom> "squeezing out toothpaste" has become a Hong Kong idiom for complaining that government officials are hiding something and only reveal little bits when really pressed
14:36:40 <Cale> I want to see the message
14:36:48 <parsnipM_> maybe because you need some Show part, and CoArbitrary alone doesn't provide that
14:36:58 <maerwald> Cale: http://lpaste.net/165221
14:37:16 <mauke> WTF-8
14:37:18 <geekosaur> oh dear
14:37:24 <geekosaur> double utf8 encoding...
14:37:38 <maerwald> umlauts work fine in the rest of the program
14:37:44 <geekosaur> (and yeh, wtf-8 is the standard name for that in a few other projects...)
14:41:01 <lpaste> glguy annotated “umlauts in errors” with “umlauts in errors (annotation)” at http://lpaste.net/165220#a165222
14:48:08 * hackagebot base-orphans 0 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0 (ryanglscott)
14:48:13 <athan> Does anyone here know of a `foo :: (Monad f, Alternative f, Alternative f') => f (f' a) -> f a`?
14:48:58 <athan> crud nevermind
14:50:01 <athan> @let fromMaybeA :: (Monad f, Alternative f) => f (Maybe a) -> f a; fromMaybeA mxs = do {mx <- mxs; case mx of; Nothing -> empty; Just x -> pure x;}
14:50:02 <lambdabot>  Defined.
14:50:13 <athan> fromMaybeA [Nothing]
14:50:19 <athan> > fromMaybeA [Nothing]
14:50:20 <lambdabot>  []
14:50:25 <athan> > fromMaybeA [Just x]
14:50:27 <lambdabot>      Ambiguous occurrence ‘x’
14:50:27 <lambdabot>      It could refer to either ‘L.x’,
14:50:27 <lambdabot>                               defined at /tmp/mueval16816927771714636915.hs:1...
14:50:34 <athan> erp
14:50:35 <athan> > fromMaybeA [Just 1]
14:50:37 <lambdabot>  [1]
14:50:41 <athan> > fromMaybeA [Just 1, Nothing, Just 2]
14:50:42 <lambdabot>  [1,2]
14:50:50 <athan> catmaybes everybody :D
14:51:09 <athan> er, an... alternative for it :v
14:52:17 <mauke> @undefine
14:52:17 <lambdabot> Undefined.
15:05:48 <tempeh> is there a monoid that just keep the element on the right?
15:06:45 <geekosaur> http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Last
15:07:24 <tempeh> perfect! thank you
15:08:09 * hackagebot SciFlow 0.4.1 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.4.1 (kaizhang)
15:08:11 * hackagebot yesod-markdown 0.11.1 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.11.1 (PatrickBrisbin)
15:17:52 <jhb563> :q
15:28:09 <acowley> Is anyone here using intero?
15:33:10 * hackagebot hpath 0.7.4 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.4 (maerwald)
15:42:14 <nitrix> Is anyone familiar with the ixset library and would nicely comfort me that serializing and unserializing the relations isn't going to end up very awkward?
15:42:23 <mikail__> Hi, I have a design question. Is it bad to just declare types without any value constructors? E.g. data Foo .
15:42:30 <nitrix> I intend to fully commit to ixset, I just don't want too many surprises.
15:42:43 <mikail__> bad as in non idiomatic Haskell
15:42:57 <nitrix> mikail__: It's not bad; the use cases are just really limited.
15:43:20 <mikail__> the problem i had is that I had some enumerations defined before
15:43:27 <mikail__> like data Foo = A | B
15:43:50 <mikail__> and I was using those in another type to create it's value constructors
15:44:00 <mikail__> so data Bar = Int Foo String
15:44:10 <mikail__> the problem came when I created a typeclass
15:44:52 <nitrix> Quick pause. Foo isn't and cannot be used as a "value constructor".
15:45:09 <glguy> ?lpaste
15:45:09 <lambdabot> Haskell pastebin: http://lpaste.net/
15:45:15 <glguy> Maybe paste an example of what you're doing
15:45:18 <nitrix> And I also believe the value constructor `Int` would result in an error.
15:45:37 <nitrix> (In Bar's definition)
15:45:43 <glguy> You can name a data constructor "Int"
15:45:56 <glguy> data Bar = Int Foo String makes a new type Bar with one data constructor Int that has two fields
15:46:00 <geekosaur> not an error, that definaes a new data constructor Int with no relationship to the type constructor Int
15:46:08 <nitrix> glguy: I'd have expected one already, that is all.
15:46:34 <nitrix> geekosaur: I'm aware.
15:46:35 <geekosaur> no, while Int has a constructor, it's got a magic name (literally, it requires the MagicHash extension to access)
15:46:40 <mikail__> the function I had defined in the type class (just one function) depended on whether Foo was A or B and would take different implementations if it was either
15:46:54 <geekosaur> you kinda don't want internal details to leak into a program's namespace
15:46:56 <mikail__> So then I thought I need to change the type of Bar so that it takes Foo as a type parameter
15:47:17 <mikail__> data Bar a b = Int Foo String
15:47:18 <geekosaur> um. this sounds like you want a dependent type
15:47:54 <geekosaur> you can't quite do that yet, although ghc is moving in that direction slowly
15:48:11 * hackagebot hpath 0.7.5 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.7.5 (maerwald)
15:48:11 <geekosaur> (a type that depends on a value. A and B are not types, so you cannot base a type on them)
15:48:18 <nitrix> "On wether Foo was A or B ?" You mean like...
15:48:40 <mikail__> I'm going to paste the code
15:48:44 <glguy> mikail__: Was there some specific code that you already wrote that you had a question about or is this an idea you had for some future code?
15:48:44 <mikail__> it will make more sense
15:48:46 <mikail__> one second
15:48:51 <nitrix> myFunc (Int A str) = ...
15:48:54 <nitrix> myFunc (Int B str) = ... ?
15:49:49 <nitrix> I'm not following. Foo is a sum type, you're allowed to pattern match the different constructors.
15:53:42 <nitrix> You can even make it polymorphic and add a type parameter to your class. There should be a couple options remaining on the table here.
15:54:15 <nitrix> Your case doesn't sound hairy enough to name drop dependent types :P
15:55:14 <geekosaur> I think we need to see code to be certain
15:56:28 <geekosaur> but I went to dependent types because pattern matching is just a shorthand for comparing them in the body of the function; if it were that simple, I don't see why typeclasses were brought in
15:56:46 <geekosaur> (literally, that pattern match desugars to a case)
15:57:10 <mikail__> this is the pasted code: http://lpaste.net/165225
15:57:17 <nitrix> mikail__: Maybe give lpaste.net a try so we have a concrete example to play with.
15:57:22 <nitrix> Beat me to it :)
15:57:34 <mikail__> so the AFTER section is my new idea
15:57:41 <mikail__> but I am not sure if it is good
15:57:56 <geekosaur> they said they were working on the paste...
15:58:26 <mikail__> the BEFORE section doesn't really work for me because I would have to write some case statements for the price function
15:58:39 <mikail__> to determine whether it is a Call or Put being priced
15:58:51 <mikail__> i don't want to do that as it seem not very elegant
15:59:00 <geekosaur> but that is, in some sense, how we would do it normally. typeclasses are not really the right answer here
15:59:03 <mikail__> so I thought I would create instances for the different types
15:59:08 <glguy> mikail__: It's not that it's not elegant, it's just wrong
15:59:16 <glguy> You can't actually create any values of Option  this way
15:59:27 <glguy> without them being "bottom"
16:00:27 <glguy> Also, all of your data constructors have the same name, which is a different problem but which won't work
16:00:29 <mikail__> geekosaur : what is the right way then?
16:00:57 <mikail__> the price implementation depends on three factors
16:01:03 <nitrix> I remember combining | with similar constructor names to lead to dangerous things, I think.
16:01:10 <mikail__> Equity, European and Call
16:01:26 <geekosaur> they cant have the same name because the constructor tag determines which types are expected
16:01:40 <glguy> mikail__: In this case you don't appear to need a typeclass at all
16:01:43 <mikail__> oh yeah
16:01:51 <geekosaur> the thing that is "dangerous" is using the same name for type and data constructors --- demonstrated by your Int example earlier
16:01:57 <mikail__> i haven't compiled that code
16:02:07 <mikail__> just fleshing out the idea
16:02:32 <geekosaur> anyway, I'd just use pattern matching. price European Call ... = ...; price American Put ... = ...; (and so on)
16:02:38 <nitrix> @let data Dangerous = A { example :: String } | B {} 
16:02:39 <lambdabot>  Defined.
16:02:44 <geekosaur> imagine them on separate lines instead of the semicolons
16:02:48 <mikail__> i think you are right nitrix
16:02:51 <geekosaur> this desugars to a case
16:02:55 <mikail__> pattern matching is the way to go
16:02:55 <nitrix> > example B
16:02:57 <lambdabot>  "*Exception: No match in record selector example
16:03:02 <nitrix> Boom :(
16:03:05 <mikail__> i can;t avoid it
16:03:17 <glguy> nitrix: That's something different than what is happening in this case
16:03:19 <geekosaur> but the top level pattern match form is more idiomatic
16:03:34 <nitrix> glguy: Ah. That's comforting.
16:04:01 <nitrix> I wouldn't want more of these gotcha to learn.
16:04:04 <mikail__> ok guys thanks - i needed a sounding board
16:13:19 <ggVGc> I'm looking for examples of using haskell to implement a language, where the language is typed using haskells type system, and compiled by compiling the haskell program then running it to generate the actual output
16:13:23 <ggVGc> what would be the term for this?
16:13:42 <ggVGc> eDSL gives me a lot of different things
16:17:13 <geekosaur> "EDSL" basically means writing your language as Haskell functions. what those functions do (interpret, generate code, ...) is not really included in the definition
16:18:59 <geekosaur> and yes, this sounds like a straightforward EDSL
16:20:48 <ggVGc> geekosaur: my goal is to have a fairly simple edsl that can spit out Lua
16:21:12 <ggVGc> the part I can't get my head around is how to define custom data types in my eDSL
16:21:21 <ggVGc> and have haskell type check it
16:23:33 <ggVGc> do I need GADTs for this?
16:25:33 <metl> are type families considered abstract types?
16:27:01 <dedgrant> metl: It doesn't really follow, since abstract data types have a specific meaning as data types with operations whose representations are hidden.
16:28:51 <dedgrant> metl: Type families are frequently said to be like type functions though, in the sense that they require some parameter (a type) and produce some other type as a result.
16:31:52 <metl> dedgrant: i see, i was trying to understand concrete vs abstract types; concrete types have to be fully applied, so a parameterized type might not be concrete, but it's not exactly abstract?
16:33:13 * hackagebot hylogen 0.1.3.0 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.3.0 (sleexyz)
16:33:19 <dolio> That's not really the difference.
16:33:36 <dolio> Abstract types refer to the implementation being somehow hidden.
16:35:37 <ggVGc> geekosaur: do you know waht I can look for to understand how I can represent user-defined data types in a DSL?
16:35:44 <ggVGc> eh, an eDSL
16:39:25 <Enigmagic> ggVGc: two (related) ways I've seen it done are via HLists (or nested tuples), or regular haskell records with restricted field types.. and using generics or TH to access them
16:40:45 <Enigmagic> ggVGc: or maybe vinyl
16:42:19 <ggVGc> vinyl looks interesting
16:42:34 <ggVGc> I'm essentially trying to create a typed subset of lua
16:42:52 <dedgrant> metl: There are different perspectives on the approach to defining types that are all generally equivalent.  Type function is one perspective, type constructior is another. You may come across the vocabulary 'unsaturated' to describe a type whose parameters have yet to be applied, and 'saturated' to describe a fully applied type.
16:44:52 <Enigmagic> ggVGc: one more idea if you don't need field names: https://github.com/alphaHeavy/llvm-general-typed/blob/75c39111f7fc685aacb3eaf1b2948451e7222e0b/llvm-general-typed-pure/src/LLVM/General/Typed/Value.hs#L44
16:46:01 <ggVGc> I think I do need field names
16:46:42 <Enigmagic> I guess it would be possible to use a type level Symbol for the field names and still do it entirely in types ..
16:46:57 <Enigmagic> but I think one of the other options would probably be easier to use
16:47:27 <ggVGc> I basically want typed records and functions acting on those records
16:47:33 <ggVGc> so I can generate lua fromit
16:48:14 * hackagebot web-routes-th 0.22.5 - Support for deriving PathInfo using Template Haskell  https://hackage.haskell.org/package/web-routes-th-0.22.5 (JeremyShaw)
16:53:14 * hackagebot react-flux 1.1.0 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.1.0 (JohnLenz)
17:33:04 <siwica> Having a type signature like a -> (b -> c) -> a do the parenthesis have any semantic meaning or are they just there to illustrate how the function arguments are normally applied?
17:33:36 <shachaf> They have the same semantic meaning that they normally do.
17:34:03 <shachaf> "a -> (b -> c) -> a" means "a -> ((b -> c) -> a)"
17:34:16 <shachaf> "a -> b -> c -> a" means "a -> (b -> (c -> a))"
17:35:03 <siwica> Ok! Do you have a quick example where this distinction matters?
17:36:48 <shachaf> It matters in practically every case where you have two types that look like that.
17:36:58 <shachaf> If you write two functions with those two types, they'll be different.
17:38:52 <siwica> ok, I think I got it.
17:39:07 <siwica> Thank you!
17:46:48 <nitrix> @let f :: a -> (b -> c); f = undefined
17:46:49 <lambdabot>  Defined.
17:46:53 <nitrix> :t f
17:46:54 <lambdabot>     Ambiguous occurrence ‘f’
17:46:54 <lambdabot>     It could refer to either ‘L.f’,
17:46:54 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:164:1
17:47:01 <nitrix> How convenient.
17:47:31 <nitrix> :t L.f
17:47:32 <lambdabot> a -> b -> c
17:48:02 <nitrix> siwica: Notice :: a -> (b -> c) and :: a -> b -> c being exactly the same as far as the type system is concerned.
17:49:18 <siwica> So emitting the parentheses in the type signature would not change how the program behaves?
17:49:24 <siwica> *omitting
17:49:30 <geekosaur> in that case, where it's at the end
17:50:00 <nitrix> siwica: As long as you respect the associativity. It's right-associative, my example was to the end.
17:50:01 <geekosaur> because application groups rightward, so a -> b -> c is (a -> (b -> c))
17:50:43 <nitrix> siwica: a -> (b -> c) -> a could be written a -> ((b -> c) -> a)
17:52:13 <siwica> Ok, I see!
18:21:21 <chrismwendt> Is there any way to avoid repeating `o .: "children"` so often in this code? https://github.com/chrismwendt/ruby-tc/blob/master/src/Lib.hs#L77
18:22:16 <Cale> chrismwendt: 404
18:23:07 <chrismwendt> Sorry about that, try it now
18:23:18 <chrismwendt> In general, can I specify the instance of a type class that should be used when computing a value in a let binding?
18:26:42 <chrismwendt> Say I have a function `f :: SomeTypeClass t => Int -> t` in `let y = f 5 in (foo y, bar y, baz y)` where each of foo, bar, and baz accept a different type
18:28:31 <Hijiri> foo, bar, and baz each accept a different concrete type?
18:29:06 <Zemyla> Okay, someone needs to fix the lambdabot so that @pl turns fix . const into id.
18:29:17 <Hijiri> let y :: SomeTypeClass t => t; y = f 5 in (foo y, bar y, baz y)
18:29:31 <geekosaur> Zemyla, lambdabot's on github, submit a PR :)
18:29:39 <Hijiri> Or the language extension NoMonomorphismRestriction
18:29:44 <glguy> chrismwendt: You can name the expression: o .: "children"
18:30:01 <chrismwendt> Yeah, for example `foo :: Int -> String` `bar :: String -> String` `baz :: Char -> String` where each of Int, String, and Char are in the type class SomeTypeClass
18:30:21 <glguy> or even name: (\f -> f <$> o .: "children")
18:30:27 <geekosaur> ghc8 lets you use the core @ syntax
18:30:32 <Hijiri> There's a restriction by default that a binding without a type signature can only instantiate the type variables at one type
18:30:56 <geekosaur> but you still need to make the binding itself polymorphic with a type signature, as Hijiri said
18:31:19 <chrismwendt> I'll try the let binding with NoMonomorphismRestriction
18:31:41 <chrismwendt> Is NoMonomorphismRestriction a sane extension? I heard that some extensions are best not used
18:31:53 <Hijiri> It's fine as far as I remember
18:31:58 <Hijiri> I don't think I've actually used it myself
18:32:10 <geekosaur> it's not only sane, as of ghc 7.8 it's on by default in ghci
18:32:25 <geekosaur> you *can* get in trouble with it due to unexpected sharing though
18:32:36 <glguy> chrismwendt: or just put a type signature on the let binding
18:34:02 <nitrix> Holy crap. The author of the Brick library is a genius.
18:34:12 <nitrix> UIs done right.
18:36:04 <nitrix> Apparently inspired from gloss. I really want to read more about it now. The idea is a bunch of handlers for each of the different aspects of rendering the program. I love it.
18:36:25 <nitrix> This, this is my reward for learning Haskell <3
18:36:42 <chrismwendt> Sweet, just adding a type signature to the let binding worked
18:37:00 <chrismwendt> Thanks everyone =)
18:41:13 <nitrix> Yeah, it's my understanding that there's no good or wrong with Monomorphism Restriction. There's essentially two schools of thought with each really good pros and cons supporting them.
18:41:46 <nitrix> Thus, if you do favor one in particuliar, you'll probably find yourself changing side a few times during your time learning Haskell.
18:41:55 <nitrix> As far as I've been told / seen.
18:43:55 <Cale> I think the monomorphism restriction would almost always be better off a warning. There are some very rare cases where it can cause more numeric defaulting to occur than otherwise would and actually manage to be convenient.
18:44:20 <nitrix> Maybe better diagnostic messages?
18:44:22 <Cale> But mostly the thing is defends against are performance issues that a warning would suffice for.
18:45:50 <Cale> also, you could wait until the pattern-bound thing actually got used in multiple places to warn
18:46:05 <sm> nitrix: yes, it's great
18:46:14 <sm> (re brick)
18:46:34 <nitrix> sm: We're getting married :3
18:46:54 <sm> is that really the core idea (handlers for different aspects ?) not sure
18:47:27 <nitrix> sm: I don't know, it's how it was explained to me on #ghc.
18:47:44 <nitrix> Oh, you mean brick.
18:49:02 <nitrix> sm: Yeah I love it. There's a handler for drawing, a handler for choosing the cursor, a handle for any key/mouse event, and the attribute map that essentially is a weaker version of CSS.
18:49:31 <sm> yeah! I've got themes! B-)
18:50:11 <nitrix> sm: You give attribute names to your widgets and it'll apply the attribute (typically a color or font transformation) to those that have that attribute.
18:51:04 <nitrix> It's just so clean. And the layout constructs that aligns verticall/horizontally with padding and whatnot reminds me of Qt.
18:52:27 <sm> nitrix: I am looking for a better way to model different screen types and save a history of them (with their states)
18:52:55 <sm> have you seen any apps like that ?
18:54:05 <sm> any multiscreen apps, really
18:56:00 <nitrix> The only multiscreen application I have is i3wm. It just gives me work workspaces to work with; I don't think I have any tiled window actually overlapping both simultanously.
18:56:40 <nitrix> I doubt terminals would handle this well...
18:56:55 <sm> they can actually.. but I mean brick apps where you can navigate between different screens
18:57:58 * sm is typing this in a terminal emacs in which the currently active screen layout has 20 windows
18:58:32 <sm> not to get sidetracked. Just looking for more brick apps to look at
19:47:15 <alilashen> hiiii
19:49:14 <vx1r_> is there a way to hoogle for  a specific function signature and not include function signatures with more general types?
19:58:24 * hackagebot phoityne-vscode 0.0.5.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.5.0 (phoityne_hs)
19:58:26 * hackagebot throttled-io-loop 0.1.0.0 - Loop over an action but throttle it to a certain rate  https://hackage.haskell.org/package/throttled-io-loop-0.1.0.0 (RobertFischer)
20:40:13 <siwica`> I am just learning about monads and understood the meaning of '>>=' in the context of the IO Monad. Could somebody explain me when instead '>>' is used to chain together IO actions?
20:40:50 <shachaf> When you don't use the result of the first one.
20:40:55 <shachaf> E.g. print 1 >> print 2
20:41:01 <siwica`> ok, I see
20:41:02 <thimoteus> >> can be thought of as f >>= \ _ -> g
20:41:27 <nitrix> Not only thought of, it's the implementation :)
20:41:36 <siwica`> So the do-notations uses '>>=' or '>>' as necessary and hides this from me?
20:42:03 <siwica`> *notation
20:42:05 <thimoteus> nitrix: i can never remember what's the actual implementation and what's just "good enough", like the magicness of ($)
20:42:58 <nitrix> thimoteus: The actual implementation is what the instance implements of course, but the default one is `f >>= \_ -> g` in case it isn't provided.
20:43:46 <siwica`> (https://www.haskell.org/onlinereport/standard-prelude.html#$tMonad)
20:44:22 <siwica`> I think I finally get the meaning of monads. It's actually much simpler then I thought.
20:44:28 <siwica`> *than
20:44:39 <nitrix> siwica`: Correct, `do` and `<-` are syntaxic sugar around >>= and >>
20:45:22 <siwica`> nitrix: Ok, thank you!
20:45:23 <nitrix> siwica`: Lines with a `<-` binding desugars with >>=, the ones without, with >>
20:45:49 <siwica`> Ok, that's what I thought. That makes perfect sense!
20:46:35 <nitrix> siwica`: do { x <- xx; y <- yy; return $ x + y }      becomes    xx >>= \x -> (yy >>= \y -> return $ x + y)
20:46:45 <nitrix> If I did it right.
20:47:26 <siwica`> Is the do-notation actually built into the language or can it be defined in terms of the language core?
20:48:17 <thimoteus> i think it's part of the compiler
20:48:20 <shachaf> It is built in.
20:48:46 <nitrix> siwica`: Part of the language (and the Haskell report). You wouldn't be able to implement it.
20:49:25 <siwica`> Ok, thank you! 
20:49:43 <siwica`> So there is no mechanism to define similar syntactic sugar?
20:50:28 <nitrix> siwica`: For example, there's also `mdo`, which is recursive do, and that requires support from the language to work, so it's implemented as an extension.
20:51:42 <siwica`> Ok I see! Never stumbled over mdo yet, but I could imagine the need for it
20:52:31 <geekosaur> siwica`, not in ghc. there's SHE which is a preprocessor that you can use to add syntax
20:53:17 <siwica`> ok, I see. Is SHE actually widely used or is it rather uncommon?
20:53:34 <geekosaur> uncommon, it's a testbed of sorts not a production environment
20:53:53 <geekosaur> but some things in current ghc got their start as SHE extensions
20:54:31 <siwica`> ok, that sounds interesting!
20:56:05 <siwica`> Btw, I am using "Real World Haskell" as a book to teach myself Haskell. Since it seems rather dated in some respects I was wondering if there is some kind of erratum around to acount for changes in the language and certain libraries?
20:56:45 <geekosaur> there's a wiki for it which has addenda and errata
21:00:28 <tmobile> siwica`: You might look into "Haskell Programming from First Principles" (
21:00:28 <tmobile> --    (BL.Chunk _ lbs') -> lbs'
21:00:28 <tmobile> --    _ -> BL.Empty
21:00:28 <tmobile> -- @
21:00:33 <tmobile> Hah.
21:00:43 <tmobile> (http://haskellbook.com/index.html)
21:00:45 <tmobile> There we are.
21:00:51 <siwica`> Ok thank you :)
21:01:03 <tippenein> any recommendations for doing persistent migrations ?
21:02:08 <siwica`> tmobile: Since I bought a hard copy of RWH I don't really want to give up on it
21:02:54 <siwica`> But the fact that it's a couple years old makes it hard reproduce certain fragments sometimes
21:04:15 <geekosaur> yes. haskell moves quickly; I think the exception stuff was out of date even before it was in bookstores
21:05:11 <siwica`> But sometimes the deprecated parts make me do my own research, so it's not always bad I guess
21:18:40 <tmobile> Anyone have experience building a shared object (of Haskell) callable from C?
21:25:04 <glguy> tmobile: There was a pull request against Cabal for building "native" shared libraries for Haskell
21:25:22 <glguy> tmobile: It's easier to build a single static library from Haskell that you link from C
21:25:42 <glguy> and on OS X since everything is compiled with PIC it's easier to go from those static libraries to a shared library
21:26:02 <glguy> If you just want to use the existing shared libraries that ghc/cabal make you have to link against a bunch of them, one for each package
21:27:46 <glguy> https://github.com/haskell/cabal/pull/2540
21:27:50 <tmobile> glguy: I'm particularly interested in generating a single shared object for x86_64 Linux, RTS and all, but the only way I've been able to manage is building a separate GHC + libs that have -fPIC.
21:28:16 <glguy> I was in the process of trying to get a -fPIC compiled GHC on Linux this afternoon, actually
21:28:33 <tmobile> It's a huge pain.
21:28:33 <glguy> I think that's probably as good as it gets on Linux, at least
21:28:58 <glguy> On OS X everything is already PIC so you don't have to fuss with that
21:29:03 <tmobile> I'm frustrated by how much easier this is on BSDs.
21:29:10 <tmobile> It's even trivial on Windows.
21:29:58 <glguy> Does the single .a file not work for your usecase?
21:30:22 <tmobile> I'm making something an existing application will dlopen().
21:31:09 <tmobile> And I need to deliver the binary to another team that definitely won't have GHC available.
22:43:06 <lpaste> kpeters pasted “Parse error at g” at http://lpaste.net/165255
22:44:31 <glguy> kpeters: You can't have a function application as a pattern:  fmap f1 (DaWrappa (f a) (g b))
22:44:38 <glguy> so the f a, and g b are invalid
22:44:56 <kpeters> Ah, okay
22:45:30 <kpeters> So how could I construct the pattern?
22:45:43 <glguy> You can have: fmap f1 (DaWrappa x y)
22:55:51 <kpeters> Finally figured it out. Thanks glguy!
23:22:13 <zinking> EvanR: can you help on http://lpaste.net/165258 ?
23:24:21 <EvanR> question 1. do you mean that you tested it and you cant get "get" to work?
23:24:52 <zinking> things I put, I cannot get back
23:24:54 <zinking> empty 
23:25:18 <zinking> I think it was because it was evaluated based on the M.empty each time 
23:25:39 <EvanR> in the function repl
23:25:55 <EvanR> when you do repl db at the end, that is the original database, not the update
23:26:13 <EvanR> evalState is dropping the updated state
23:26:40 <EvanR> :t evalState
23:26:41 <lambdabot> State s a -> s -> a
23:26:44 <EvanR> :t runState
23:26:45 <lambdabot> State s a -> s -> (a, s)
23:32:49 <lpaste> zinking revised “haskell kv db”: “haskell kv db” at http://lpaste.net/165258
23:33:50 <EvanR> let (r,s) = runState st db
23:33:56 <EvanR> ...  repl db
23:34:12 <EvanR> s is the update of the db, you are ignoring it, so youll never see it change
23:35:26 <zinking> EvanR: yeah, how should I feed it back 
23:35:45 <EvanR> repl s
23:37:25 <zinking> ah, right. thanks a lot
23:37:48 <zinking> EvanR: one more question, is this how State should be used ? am I using it correctly ?
23:37:57 <EvanR> pretty much
23:38:12 <EvanR> though State by itself is kind of rarely useful
23:39:21 <zinking> yeah, I still felt I am passing the DB around 
23:39:36 <EvanR> because you are ;)
23:39:58 <EvanR> which is a lot of times just fine, and State is really just getting in the way
23:41:59 <lpaste> zinking pasted “original code that I thought was improved” at http://lpaste.net/165266
23:42:36 <zinking> EvanR: would you say 165258 improved 165266 
23:43:22 <EvanR> a long string of >>=... i would write it with do notatino
23:43:48 <zinking> although one argument is removed from exec. but each function become more complicated to involve State 
23:44:14 <zinking> or say, is execCmd improved ?
23:44:22 <zinking> I agree with the do notation part 
23:46:14 <EvanR> maybe you should look for a haskell style guide to answer these questions
23:46:19 <EvanR> @where style guide
23:46:19 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide https://github.com/chrisdone/haskell-style-guide
23:46:44 <zinking> thanks
23:50:40 <Myrl-saki> Any use case where 16 gb of ram is useful?
23:53:19 <Adeon> big program need big memory
23:53:41 <zomg> Myrl-saki: virtual machines, compiling big programs, etc.
23:53:43 <Adeon> big data processing jobs with big working sets may benefit from large memories for disk caching or otherwise
23:54:18 <unK_> http://lpaste.net/165268 why isn't this rejected by ghc? I would expect it to protest that F Bool is not defined
23:54:32 <Myrl-saki> Adeon: How about on the programming desktop side?
23:55:26 <Adeon> not sure
23:55:30 <zomg> Heavy IDEs, 100's of tabs in Chrome, Photoshop or graphics tools, etc.
23:55:46 <zomg> (and at least I run virtual machines for dev work every so often)
23:55:57 <Myrl-saki> zomg: Yeah, I'll probably be running virtual machines too.
23:56:21 <zomg> yeah
23:56:31 <zomg> I'm actually thinking of just getting 32 gigs of ram for my next PC build soon'ish :P
23:56:39 <zomg> it's not that expensive afterall :D
23:57:12 <Adeon> I have 8 gigabytes on my work laptop
23:57:21 <Adeon> I develop on linux in a virtualbox VM on OS X
23:57:35 <Adeon> it's doable but occasionally I get memory pressure and things slow down to crawl or crash
23:57:45 <zomg> yeah
23:57:54 <Myrl-saki> On the other hand, I can probably use emacs without lagging now.
23:58:22 <unK_> Myrl-saki: I had 8GB of RAM, but I once reached 7GB mem usage with chrome, compilation of a C++ program (template-heavy) and a couple of things running in background. shortly after that I bought another 8GB so I don't need to think about it.
23:58:31 <zomg> Funnily enough my desktop only has 12 gigs of RAM and I use it for much heavier work than my macbook pro which has 16...
23:58:35 <Myrl-saki> unK_: Hmmm
23:58:57 <zomg> but then again I did build the desktop originally like 6 years ago or so :P
23:59:41 <Myrl-saki> zomg: You had 12 gb ddr2 wam?
