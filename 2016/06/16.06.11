00:01:48 <athan> Rotaerk: They sure do
00:02:37 <koz_> Also - if someone has a Haskell Wiki account, please could you edit this to remove the off-by-one error? https://wiki.haskell.org/Random_shuffle#Purely_functional
00:02:57 <koz_> It should be 'randomR (0, i - 1) gen
00:02:59 <koz_> '
00:03:44 <pavel1> which web framework and html lib would you recommend for a small web site with db and sessions ?
00:04:27 <Squarism> can you instruct cabal / compiler to give more readable compile errors than "src/Board.hs:286:1: Parse error in pattern: segments"
00:04:53 <cocreature> pavel1: scotty is nice and simple
00:05:08 <athan> pave11: nestedroutes with lucid, acid-state and saltine :D
00:05:18 * athan some assembly required
00:05:19 <Squarism> ...even if that was "ok". Some times its just "parse error"
00:05:39 <bennofs> Squarism: I believe not... 
00:05:41 <cocreature> Squarism: no, the important info here is the line number. most of the times that’s very accurate
00:05:43 <pavel1> actually i'm onto spock tight now, since it's successor of scotty i think
00:05:49 <pavel1> er *right
00:05:54 <cocreature> oh yeah I meant spock
00:05:58 <cocreature> I always confuse the two
00:06:01 <Squarism> ok
00:07:00 <pavel1> what about lucid vs blaze?
00:07:40 * hackagebot servant-purescript 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/servant-purescript-0.1.0.0 (eskimo)
00:07:40 * hackagebot servant-purescript 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/servant-purescript-0.1.0.1 (eskimo)
00:08:23 <Phyx-> lol, how is that description not noticed
00:10:35 <cocreature> Phyx-: I guess people don’t look at the descriptions of their own packages too closely. after all they should know what their package does :)
00:10:55 <cocreature> stack should just ask for an input here or output an error when uploading with this message
00:11:31 <bennofs> It is not the description btw (description says "look README"), but the synopsis. When I started with Haskell, I was also confused what synposis is supposed to be about
00:13:12 <Phyx-> cocreature: ah, true. maybe hackage should reject a package with that template in it.
00:16:50 <cocreature> seems to fragile in hackage, e.g. stack could change the wording slightly and it would break. putting that check in 'stack upload' seems like a better idea.
00:18:19 <kadoban> Is it really a serious problem that requires a solution? I'd think any package that anyone spends a decent amount of time on, it'll get noticed and fixed fairly quickly.
00:20:59 <cocreature> fair point
00:21:16 <Phyx-> on the other hand, the solution wouldn't be hard either, so why not?
00:27:35 * hackagebot servant-subscriber 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/servant-subscriber-0.1.0.0 (eskimo)
00:32:35 * hackagebot servant-subscriber 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/servant-subscriber-0.1.0.1 (eskimo)
00:37:36 * hackagebot nanovg 0.3.0.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.3.0.0 (cocreature)
00:47:36 * hackagebot servant-purescript 0.1.0.2 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.1.0.2 (eskimo)
00:52:36 * hackagebot servant-subscriber 0.1.0.2 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.1.0.2 (eskimo)
00:52:55 <athan> In attoparsec, should I skipSpace _between_ my `sepBy1`? Or on either side of the main data parsed?
00:59:13 <Squarism> how do i use (.)
00:59:18 <Squarism> f . g ?
00:59:22 <Squarism> or 
00:59:26 <Squarism> . f g ?
00:59:42 <kadoban> f . g    or   (.) f g  if you really want to
01:02:04 <paolino> hello, how I fix the array type here ? http://lpaste.net/165756
01:02:37 * hackagebot http-dispatch 0.4.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.4.0.0 (owainlewis)
01:02:57 <paolino> I don't want the array to come out so runSTUArray seems not the solution
01:05:08 <paolino> if I annotate 'presence' I don't know how to treat 's' type param
01:09:39 <SweetKatya> hi. If I want to be certified in Haskell from a reputed people much the same what happens with Cisco or Oracle, who should I go to?
01:10:09 <Jinxit> lol certs
01:10:30 <SweetKatya> Jinxit, why the LOL ? ☺
01:10:45 <kadoban> Certs in languages aren't all that common really, or in my experience all that useful.
01:11:18 <SweetKatya> well here in the middle east certifications or degrees matter lots
01:11:31 <Jinxit> being able to cram for an exam doesn't mean you've learned anything, but I guess I'm not hiring
01:11:37 <Squarism> if you have myList::[(a,a)] and wanna do fmap f myList where f a -> a -> b. what do i need to do to apply f on (a,a)
01:11:57 <Jinxit> do you have a degree?
01:12:20 <kadoban> :t curry
01:12:21 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:12:31 <kadoban> Bleh, I always get that backwards … every time.
01:12:33 <kadoban> :t uncurry
01:12:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
01:12:56 <kadoban> Squarism: If you uncurry f, it'll give you a function that works on tuples instead of separate arguments. Does that make sense?
01:13:14 <Squarism> kadoban, sure!
01:13:23 <SweetKatya> Jinxit, I have a Masters degree in Information Technology from James Cook University in Australia . I studied there. I also have a BS degree in Computer Science from Bierut,Lebanon . I live in Lebanon
01:13:48 <DangerousDave> Hello, there is somthing I can't understand in Text.Parsec.Expr, I try to create one with arithmetic :: Parser Expr
01:13:57 <DangerousDave> arithmetic = (Ex.buildExpressionParser table term)
01:13:58 <kadoban> SweetKatya: I would think that and some projects you can show would be enough for employers, no?
01:14:28 <shachaf> whoa, DAVE.EXE
01:14:47 <DangerousDave> and it doesn't work with the error When checking that ‘table’ has the inferred type table :: forall s u (m :: * -> *) a.
01:14:48 <Jinxit> SweetKatya: then you probably took a course in programming paradigms/languages?
01:14:55 <Jinxit> (also what kadoban said)
01:15:02 <SweetKatya> kadoban, you are right, but I want the certification because in Lebanon, because no one is teaching Haskell here.
01:15:19 <Jinxit> then what are the chances of working with haskell?
01:16:03 <DangerousDave> I think the problem is that I dont understand enough the table of the buildExpressionParser, can somone please tell me what it contains, It is not written anywhere and I couldn't infer it
01:16:46 <SweetKatya> Jinxit, chances are : either i have to open a commercial programming office that does thing in Haskell, or I have to teach it. and I am better in teaching than writing apps.
01:16:56 <SweetKatya> I love to teach.
01:18:20 <suppi> also remote work is possible, no?
01:18:46 <SweetKatya> barely i'd trust remote work.
01:18:48 <Jinxit> are certs really valued in academia?
01:20:19 <kadoban> I'd think they're even less valued in academia than they are in software dev, but I wouldn't really know I guess.
01:21:15 <SweetKatya> Jinxit, all I want to show an evidence that I can write in Haskell.  I am already a masters degree holder.
01:21:44 <kadoban> SweetKatya: Have you written stuff in haskell? Can't you just make a profile out of it?
01:21:47 <Jinxit> I would expect any masters in CS/IT to be able to pick up and write any language within a week to a month
01:21:56 <SweetKatya> ok.. we swayed from my question.. 
01:21:59 <Squarism> beeing author of on or more open source projects could work as a degree. Id hire someone who got an interesting github repo
01:22:01 <Phyx-> I've never had an employer ask for or value certs. :/
01:22:37 <SweetKatya> kadoban,  not really . Just very basic things.
01:23:13 <Jinxit> then explore the language and build a portfolio
01:23:17 <Jinxit> see if you actually like it
01:23:24 <SweetKatya> but I know I can teach it. I am doing so these days . I helping some Masters students studying in Romania.
01:23:42 * SweetKatya hopes the students will pass
01:24:14 <SweetKatya> Jinxit, I LIKE HASKELL.. there is no argues about that.
01:24:18 <DangerousDave> Hello, can somone help me with buildExpressionParser
01:24:24 <SweetKatya> I really like it.
01:24:38 * SweetKatya was just stressing the LIKE
01:28:01 <DangerousDave> why is this OperatorTable cell give me an error '[Ex.Prefix (((char '-') >> return negate) <|> ((char '+') >> return id)) Ex.AssoccNone]'?
01:36:34 <koz_> How can I tell Cabal that when I call 'cabal clean', I want to also remove some additional files?
01:37:09 <cocreature> DangerousDave: prefix operators don’t have an associativity argument. also you would typically use two different entries in your operator table instead of merging them into one
01:37:29 <hvr> koz_: extra-tmp-files: filename list
01:37:30 <hvr> A list of additional files or directories to be removed by setup clean. 
01:37:47 <hvr> koz_: it's documented at https://www.haskell.org/cabal/users-guide/developing-packages.html
01:38:01 <DangerousDave>  cocreatur I got the first thing you have said and already fixed it, but can you explain the snd one
01:38:04 <DangerousDave> ?
01:39:41 <cocreature> DangerousDave: use [Ex.Prefix ((char '-') >> return negate), Ex.Prefix ((char '+') >> return id)]
01:40:00 <DangerousDave> I understood that, but why is that?
01:40:03 <DangerousDave> for readability?
01:40:07 <DangerousDave> or there is a logic problem
01:40:50 <cocreature> mostly for readability. the whole point of buildExpressionParser is to just specify the operators you want to support and let buildExpressionParser take care of parsing them correctly.
01:44:13 <DangerousDave> I did not understand it from the documentation, what happend if some of the terms are of type LInt and some of LBool it will just try to parse it by precedencey and if it succeed it stop? what does it return?
01:45:40 <DangerousDave> Im asking because I tried to read the code/documentation but without any success
01:45:48 <DangerousDave> and I'm getting the following error http://pastebin.com/07qy0yqV
01:46:28 <DangerousDave> http://pastebin.com/PCp7YQNv
01:46:33 <DangerousDave> this is the error
01:46:58 <DangerousDave> The first pasebin was just the table
01:47:39 * hackagebot type-fun 0.1.1 - Collection of widely reimplemented type families  https://hackage.haskell.org/package/type-fun-0.1.1 (AlekseyUymanov)
01:48:48 <cocreature> FlexibleContexts is a pretty safe extension you can just enable it here.
01:49:18 <DangerousDave> I preffer to understand why I'm getting a problem
01:49:19 <Squarism> Out of curiosity. Do you feel you are more productive than imperative programmers on task X? For most or special types of X. =D 
01:49:49 <DangerousDave> prefer*
01:51:50 <DangerousDave> Could you help me with that please?
01:53:59 <cocreature> DangerousDave: the problem is that (without extensions) constraints have to be of the form C (f t1 … t2) where f is a type variable that is applied to n types. however in your case you do not have a type variable but a concrete type Char
01:54:33 <cocreature> also Stream relies on MultiParamTypeClasses allowing one class to have multiple type parameters
01:58:53 <DangerousDave> Oh ok, thank you!
02:22:40 * hackagebot juandelacosa 0.1.1 - Manage users in MariaDB >= 10.1.1  https://hackage.haskell.org/package/juandelacosa-0.1.1 (ip1981)
02:23:46 <DavidEichmann> Any one know a convenient way to do pattern matching in order to get a Maybe. E.g. I have a line intersection result that could be a line or a point or nothing. I am only interested in the point case so want do do something like: maybePoint = case result of Point p -> Just p; _ -> Nothing
02:24:12 <DavidEichmann> Is there a nicer way to do it?
02:25:09 <Squarism> got a bit confused here in my imperative mindset. I have mesh. I have 2 type's. MeshStep n1 n2 and MeshConnection n1 n2. "Eq MeshConnection" disregards order of nodes. MeshStep dont. But a MeshStep can be seen as a MeshConnection when compared to other MeshConnection. But should have other Eq implemenation for MeshStep. How can i realize this?   
02:26:12 <osager> The ReaderT seems to have two forms of definition: 1: {runReaderT :: r -> m a} 2: ReaderT r m a
02:26:18 <sbrg> Squarism: are those different types or different constructors?
02:26:18 <osager> what's the difference
02:26:31 <Squarism> sbrg: Different types
02:26:41 <sbrg> If you have data MeshThing = MeshStep ... | MeshConnection .., you roll your own Eq instance that does what you want
02:29:44 <Squarism> do feel (may be wrong) they should be different types - to be able to express explicit function signatures. * -> MeshThing feels awkward
02:30:48 <sbrg> Squarism: you can have them in different types and wrap them in another type and write an Eq instance for that one, then?
02:31:10 <sbrg> data MeshThing = ActuallyMeshStep MeshStep | ActuallyMeshConnection MeshConnection
02:31:59 <Squarism> haskell has implicit conversion?
02:32:05 <sbrg> no
02:32:07 <sbrg> thank god
02:32:32 <sbrg> but that allows you to treat them as one thing when you need to
02:33:05 <sbrg> Squarism: though FYI that type above is just Either
02:33:08 <sbrg> so you could just use that
02:33:11 <koz_> How does one define NFData for their own type?
02:37:01 <Squarism> sbrg, ah. thanks! 
02:49:59 <Squarism> i learned theres fmap and  <$>. Same thing with differnt associativity. 1. Theres no place where you can find what "aliases" a funktion has? 2. is there some version of fmap on the form : [a] op (a -> b)
02:51:40 <sbrg> :t for
02:51:41 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
02:51:47 <sbrg> hm
02:51:58 <sbrg> :t flip map
02:51:59 <lambdabot> [a] -> (a -> b) -> [b]
02:52:30 <sbrg> > let myFor = flip map in [1..10] `myFor` (+1)
02:52:32 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:53:31 <Squarism> ok.. maybe not worth the effort =D
02:53:59 <sbrg> you can define your own operator
02:54:24 <Squarism> i got used to that type of chaining from scala
02:55:07 <Squarism> lst map (x => ..) fmap ( x => ..) filter ( x => ..) 
02:55:16 <Squarism> flatMap i mean
02:55:22 <sbrg> aye. 
02:55:53 <DavidEichmann> concatMap :: (a -> [b]) -> [a] -> [b]
02:57:42 * hackagebot text-ldap 0.1.1.7 - Parser and Printer for LDAP text data stream  https://hackage.haskell.org/package/text-ldap-0.1.1.7 (KeiHibino)
03:02:42 * hackagebot hopenpgp-tools 0.19 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.19 (ClintAdams)
03:12:43 * hackagebot hgeometry 0.5.0.0 - Geometric Algorithms, Data structures, and Data types.  https://hackage.haskell.org/package/hgeometry-0.5.0.0 (FrankStaals)
03:13:54 <Berra> Given Da :: { f1 :: String, f2 :: String } -- and pDa :: Parser Da = do x <- pf1; y <- pf2; return $ Da x y; Can I change that into an fully applicative parser and how would I compose or fmap to achieve the contstruction of Da ?
03:15:11 <cocreature> Berra: liftA2 Da pf1 pf2
03:15:19 <cocreature> or Da <$> pf1 <*> pf2 if you prefer that
03:15:46 <Berra> cocreature: Hm, I think I did try that second syntax, but let me try again to make sure. Thanks
03:18:19 <Berra> cocreature: It would still apply if in reality it was Da :: { f1 :: F1, f2 :: F2 } -- pDa :: Parser Da = Da <$> (F1 <$> pf1) <$> (F2 <$> pf2) -- ?
03:18:37 <biglama> 5~~~~~~~
03:18:42 <biglama> oops sorry
03:19:29 <cocreature> Berra: assuming F1 and F2 have the appropriate types it should work
03:20:01 <cocreature> Berra: eh no you need Da <$> _ <*> _ not Da <$> _ <$> _
03:21:57 <Berra> cocreature: But it would still be Da <$> (F1 <$> pf1) <*> _ -- right?
03:22:02 <cocreature> yep
03:22:14 <Berra> cocreature: Hm, ok. Thanks. 
03:24:33 <dimsuz> hi! As an exercise in learning monads I wrote a simple function which doubles ints based on index in list. Now I suspect I could simply use a few base-library functions to replace all this code :) Would be grateful if you could hint me which way to go: http://lpaste.net/165762
03:25:33 <dimsuz> I am thinking that I should lift that predicate to a state monad and then use some std function(s), but not sure if I'm right. 
03:25:34 <Squarism> i can do : let f = `elem` [1,2,3]. Problem i cant stand those backticks. Can i accomplish that short form wo backticks? 
03:26:14 <cocreature> flip elem [1,2,3] would work
03:26:53 <Squarism> thanks
03:28:43 <Squarism> do people use flip alot or is it frown upon? 
03:29:08 <cocreature> I try to avoid it since imho it makes the code harder to read
03:29:44 <Cale> Just remember that lambdas exist :)
03:29:46 <sbrg> Squarism: I use it when appropriate. I sometimes think for some functions there should be flipped variants in base
03:30:00 <sbrg> runState/T for example
03:30:04 <sbrg> :t runState
03:30:06 <lambdabot> State s a -> s -> (a, s)
03:30:28 <Berra> :t flip runState
03:30:29 <lambdabot> s -> State s a -> (a, s)
03:30:40 <sbrg> I often want to do: runState myState $ do .. 
03:31:01 <sbrg> though it's not a big problem. refactor into a where-clause, etc
03:31:21 <sbrg> for = flip map is also sometimes useful
03:32:18 <cocreature> yeah runState is one of the functions I always use flip on
03:33:26 <sbrg> dimsuz: well, your example is a perhaps a bit pathological/weird, since there are easier ways to do what you are doing without using State
03:33:48 <toph_> is there a mirror for https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html?
03:33:52 <sbrg> but take a look at `modify` instead of get >>= put
03:34:06 <Squarism> sbrg, okej.. good to know
03:34:17 <dimsuz> sbrg: I know there are (btw, what are they). But I specifically wanted to do this in a State monad
03:34:29 <toph_> i guess i'll just go to web archive .org :)
03:34:56 <Gurkenglas> toph_, http://webcache.googleusercontent.com/search?q=cache:https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
03:34:57 <toph_> god, i hate macros :3
03:36:09 <sbrg> > let myNumbers = [1, 3, 6, 9, 10, 14] in map (\(a, b) -> if even b then a * 2 else x) $ zip myNumbers [0..]
03:36:11 <lambdabot>  [1 * 2,x,6 * 2,x,10 * 2,x]
03:36:21 <sbrg> oops. 
03:36:25 <sbrg> > let myNumbers = [1, 3, 6, 9, 10, 14] in map (\(a, b) -> if even b then a * 2 else a) $ zip myNumbers [0..]
03:36:27 <lambdabot>  [2,3,12,9,20,14]
03:36:39 <sbrg> dimsuz: ^
03:36:47 <Gurkenglas> I only use flip on runState when the initial state is a constant, otherwise I try to eta-reduce the initial state awa
03:36:48 <Gurkenglas> *y
03:37:46 <dimsuz> sbrg: oh, I suspected the zip would be involved, but somehow it didn't occur to me to zip with `[0..]`. thanks
03:38:22 <Gurkenglas> dimsuz, you usually replace the state monad with more specialized things for the same reasons you replace explicit recursion with things like map or foldr
03:38:32 <sbrg> dimsuz: anyway, you could refactor your example so that you isolate getting the index and returning doubled or not based on the predicate. then your entire function could be replaced with mapM (yourFunction pred) list
03:39:19 <dimsuz> thank you all
03:40:48 <sbrg> dimsuz: and re. the zip [0..] thing. yeah, it's a neat trick. there are a lot of those that one might not think of immediately when learning, and because they are so simple, they don't always have counterparts in base. even though they might be common.
03:41:01 <sbrg> where as scala has stuff like zipWithIndex
03:41:46 <Gurkenglas> > let pred = even in (`evalState` 0) . mapM (\i -> do b <- gets pred; modify (+1); return $ (if b then 2 else 1) * i) $ [1,2,3,4,5] -- but to answer your question dimsuz
03:41:48 <lambdabot>  [2,2,6,4,10]
03:42:22 <sbrg> neat
03:43:23 <dimsuz> sbrg: yep, currently using kotlin for android development, it has similar functions. e.g. mapWithIndex
03:44:20 <dimsuz> Gurkenglas: nice! was about to try to write something like this following sbrg's advice
03:45:33 <toph_> could i use template haskell to define a custom escape sequence? say for some unicode number?
03:46:30 <dimsuz> haskell is so beautiful
03:49:10 <Squarism> theres no filter for maybe? 
03:49:36 <sbrg> Squarism: in what way?
03:50:04 <sbrg> if you want to keep only Just values in a list, there's catMaybes
03:51:12 <Squarism> in scala they regard Maybe as a list of 0..1 elements. I got used to that
03:51:47 <sbrg> Squarism: yeah, they are a bit more "liberal" with the ways they treat things in Scala in my experience. I learned haskell before scala
03:52:06 <sbrg> Squarism: what does filter do for Option in scala?
03:52:23 <Squarism> converts it to None 
03:52:30 <sbrg> aah, yeah
03:53:06 <mauke> filter f y@(Just x) | f x = y; filter _ _ = Nothing
03:53:17 <dibblego> Squarism: the teaching technique of using Option as a list of 0 or 1 originated in use with haskell
03:53:51 <Squarism> oh ok
03:55:08 <Squarism> mauke, ill copy that!
03:56:25 <Gurkenglas> :t mfilter -- Squarism
03:56:26 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
03:56:52 <Squarism> hah!
03:57:48 <Gurkenglas> :exf "(a -> Bool) -> Maybe a -> Maybe a" -- Squarism
03:57:49 <exferenceBot> mfilter
03:58:25 <sbrg> wut
03:58:29 <sbrg> nice
03:58:43 <sbrg> :exf "[a] -> (a -> b) -> [b]"
03:58:43 <exferenceBot> \ as f2 -> fmap f2 as
04:00:07 <phanimahesh> what does exference mean?
04:00:24 <Gurkenglas> Opposite of (type) inference
04:00:30 <phanimahesh> The bot looks handy, I'm seeing this for the first time.
04:01:04 <phanimahesh> Gurkenglas: Oh. Awesome. does it query hoogle/hayoo or does it have its own db?
04:01:09 <Clint> @djinn [a] -> (a -> b) -> [b]
04:01:09 <lambdabot> Error: Undefined type []
04:01:19 * Clint hmms
04:01:27 <mauke> :exf "a -> b"
04:01:28 <Gurkenglas> Not a database, it has a list of some functions and their types, and then searches through the space of combinations
04:01:42 <Cooler> are there different version of haskell?
04:01:53 <exferenceBot> could not find expression
04:01:54 <Cooler> versions*
04:02:00 <mauke> Cooler: yes
04:02:25 <phanimahesh> I presume all of stdlib is indexed? Does it also index all of hackage?
04:02:29 <Cooler> is there a version that is architecture aware?
04:02:34 <koz_> If I have a lot of fizzling sparks, what does this indicate?
04:02:36 <mauke> Cooler: what?
04:02:45 * hackagebot time-locale-compat 0.1.1.2 - Compatibility of TimeLocale between old-locale and time-1.5  https://hackage.haskell.org/package/time-locale-compat-0.1.1.2 (KeiHibino)
04:03:04 <Gurkenglas> phanimahesh, https://github.com/lspitzner/exference/tree/master/environment
04:03:15 <phanimahesh> umm, what does architecture aware mean?
04:03:18 <phanimahesh> Gurkenglas: Thanks!
04:03:35 <mauke> :exf "String -> int"
04:03:41 <Cooler> well haskell, if i am not mistaken, is trying to emulate a purely mathematical / logical space with no physical ties
04:03:46 <mauke> Cooler: no
04:04:03 <exferenceBot> could not find expression
04:04:06 <mauke> that's as true of Haskell as it is of C
04:04:07 <Gurkenglas> :exf "String -> Int"
04:04:10 <exferenceBot> \ as -> fromEnum (as /= as)
04:04:15 <mauke> hahaha
04:04:17 <sbrg> koz_: did you use unsafeCoerce?
04:04:39 <mauke> Gurkenglas: it should've found error
04:04:46 <sbrg> > (\s -> fromEnum (s /= s)) "foobar"
04:04:47 <lambdabot>  0
04:04:49 <sbrg> heh
04:04:50 <Gurkenglas> error is not in its "database"
04:04:50 <Cooler> mauke, i know
04:05:06 <Cooler> C is trying to do that too, in a different way
04:06:12 <Gurkenglas> Its not made for numerical stuff, its made for control flow, because that's where types should specify what you do
04:06:21 <koz_> sbrg: No - just parMap rpar stuff.
04:06:33 <sbrg> oh, that kind of sparks
04:06:35 <sbrg> lol
04:06:49 <Cooler> Haskell, if i am not mistaken, is just using a more well thought out mathematical approach to it
04:06:49 <Gurkenglas> "sparks" = "makes sense"?
04:07:02 <Cooler> than C
04:07:32 <Cooler> by being more explicit about sideeffects and so on
04:07:54 <koz_> I'm just trying to lern2parallel in Haskell, but I'm not too sure how to reduce my spark fizzle rate.
04:08:13 <Gurkenglas> (Automorphisms are evil, as a generalization of boolean blindness is evil)
04:08:30 <sbrg> koz_: I don't recall 100% what fizzled sparks mean, but i think those are thunks that are created but never forced or something.
04:08:45 <Cooler> mauke, you still here?
04:08:50 <mauke> yes?
04:08:52 <sbrg> "It means they are evaluated by ordinary program flow before the corresponding spark finished." http://stackoverflow.com/questions/22638421/parallel-haskell-ghc-gcing-sparks
04:09:03 <Cooler> i don't know if you agree
04:09:13 <mauke> I don't know what you're talking about
04:09:22 <Cooler> oh
04:09:28 <mauke> I'm busy staring out the window, being aware of architecture
04:09:40 <koz_> sbrg: So that means I oversparked?
04:10:01 <cocreature> mauke: don’t forget the architecture inside of the building!
04:10:15 <Cooler> i was wondering if there's a version of haskell that doesn't ignore the architecture
04:10:28 <sbrg> koz_: I'm not entirely sure. could you paste the code?
04:10:38 <cocreature> Cooler: what is ignoring architecture supposed to mean?
04:10:52 <Cooler> i was able to find something close http://www.dcs.gla.ac.uk/~trinder/papers/ArchAwareGpH.pdf
04:10:56 <sbrg> koz_: might be too fine-grained parallelism
04:11:43 <koz_> sbrg: Sure - http://lpaste.net/165763
04:12:07 <koz_> I'm a bit new to this whole 'parallelism in Haskell' thing.
04:12:45 * hackagebot microlens 0.4.4.3 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.4.3 (Artyom)
04:12:54 <sbrg> koz_: if you're processing a list an element at a time, try chunking it up and processing it like that instead
04:13:16 <Cooler> so is there a version of haskell that does that?
04:13:23 <sbrg> it seems that you are doing some redundant evaluation. fizzling means that something else is evaluating the value before a spark that was created to evaluate it finished evaluating. 
04:13:41 <koz_> sbrg: What do I use for list chunking?
04:14:03 <sbrg> koz_: take a look at this: http://chimera.labs.oreilly.com/books/1230000000929/ch03.html http://community.haskell.org/~simonmar/Chalmers-par-monad.pdf
04:14:20 <sbrg> the second contains a simple definition for a parMapChunk
04:14:34 <koz_> sbrg: Oh derp - I even *have* this book. Will read - thank you!
04:15:02 <sbrg> koz_: reading all of Simon Marlow's stuff on parallelism is a good idea
04:15:16 <sbrg> and I guess the other simon's maybe as well. I confuse them
04:15:20 <koz_> sbrg: I'll do that also.
04:15:32 <koz_> I'm just using this as a performance hack to get data faster.
04:21:15 <Geraldus> Hi friends!
04:22:15 <Geraldus> Is there a way to dump persistent's models as .hs files generated by Template Haskell? -ddump-splices is not exactly what I'm looking for
04:35:42 <Geraldus> or, it seems I misread .dump-splices file
04:37:47 * hackagebot connection-pool 0.2.1 - Connection pool built on top of resource-pool and streaming-commons.  https://hackage.haskell.org/package/connection-pool-0.2.1 (PeterTrsko)
04:47:47 * hackagebot scientific 0.3.4.7 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.7 (BasVanDijk)
04:57:48 * hackagebot th-reify-compat 0.0.1.0 - Compatibility for the result type of TH reify  https://hackage.haskell.org/package/th-reify-compat-0.0.1.0 (KeiHibino)
05:09:09 <thomie> Geraldus: -dth-dec-file, see https://downloads.haskell.org/~ghc/master/users-guide/debugging.html#ghc-flag--dth-dec-file
05:09:39 <Geraldus> thomie: Hi!  Thank you very much!
05:09:49 <Geraldus> let's try
05:14:59 <Geraldus> Hmm… How should I use this flag with stack?  I tried `stack build -dth-dec-file=test.hs`, but can't find resulting file
05:15:27 <Geraldus> Apologize, `stack build --ghc-options=-dth-dec-file=test.hs`
05:27:49 * hackagebot http-dispatch 0.5.0.0 - High level HTTP client for Haskell  https://hackage.haskell.org/package/http-dispatch-0.5.0.0 (owainlewis)
05:32:49 * hackagebot one-time-password 2.0.0 - HMAC-Based and Time-Based One-Time Passwords  https://hackage.haskell.org/package/one-time-password-2.0.0 (AlekseyUymanov)
05:44:44 <Berra> Using Parsec, I have parsers p1 = catMaybes <$> sepBy p2 newline -- and p2 = optionMaybe p3; As soon as p2 returns a Nothing (like expected) no further parsing is done in p1. I'm thinking this is because of sepBy not working as I expect. How can I get around this?
05:48:14 <EvanR> Berra: review the conditions for when sepBy stops
05:52:46 <EvanR> it continues as long as it sees p2, then newline, then p2, then newline, ...
05:53:09 <EvanR> but if it sees p2 then no newline, or newline and no p2, it stops
05:53:33 <EvanR> if p2 returns Nothing in the middle of the line, there will be no newline
05:53:58 <Berra> EvanR: Yes, how do I get around this. Something other than sepBy?
05:54:26 <Berra> EvanR: Nevermind
05:54:35 <EvanR> to get it to work, youd have to consume the rest of the line on failure
05:54:52 <EvanR> which is impossible, make sure not to consume the newline itself (with lookahead)
05:55:00 <EvanR> s/impossible/TOTALLY POSSIBLE/
05:55:04 * EvanR needs coffee
05:55:10 <Berra> Looking at sepBy1 https://hackage.haskell.org/package/parsec-3.1.3/docs/src/Text-Parsec-Combinator.html#sepBy . Isn't there some way to write that without do ?
05:55:51 <EvanR> it would be kind of a bitch to write it without do because of the variables x and xs
05:55:54 * arcetera reads his drink and eats his paper
05:56:09 <Berra> EvanR: Alrigth, thanks
05:56:30 <EvanR> maybe liftM2 (:) line1 line2 ?
05:56:59 <Phyx-> it there anyway to overrule constraints in the cabal file from cabal-install?
05:57:13 <Mion> you can edit it
06:03:45 <Berra> EvanR: Is there no other way than making it consume the rest of the input?
06:08:24 <EvanR> Berra: which isnt hard, but you can also run the parser on each line
06:08:31 <EvanR> after splitting it with `lines'
06:09:12 <EvanR> to consume the rest of the input, write a parser which eats any character until it sees a newline and stops (and doesnt eat the newline)
06:09:15 <EvanR> called i p4
06:10:07 <Berra> EvanR: But would't that mess up the results later eaten by catMaybes? http://lpaste.net/4785265133125369856
06:10:08 <EvanR> then sepBy (do {x <- p2; p4; return x}) newline
06:10:36 <EvanR> no
06:11:27 <Berra> EvanR: pComments = catMaybes <$> sepBy (pLine <* untilNewline) newline -- Works perfectly. Thanks for the help.
06:12:39 <EvanR> ok
06:28:04 <hodapp> hmm... doing a bunch of vector operations manually on lists: not as painful as I thought in Haskell
06:28:18 <hodapp> being completely explicit about what dimension something operates over is oddly helpful
06:31:04 <mikail__> Hi, I need some design advice. Is there a better way to write this code: http://lpaste.net/165765?
06:32:11 <mikail__> maybe some advanced FP pattern which handles this better
06:33:14 <lyxia> you keep applying functions to s k r v t q in that order
06:33:47 <mikail__> yeah
06:33:57 <mikail__> is there a way to avoid that
06:34:00 <EvanR> but it comes from different sources
06:34:05 <lyxia> the only varying part in the patterns is also UpAndIn/Call
06:34:07 <mikail__> the repitition
06:34:28 <mikail__> yeah that is for the different "items" to price if you like
06:34:51 <EvanR> yeah this factors cleanly
06:35:45 <mikail__> EvanR are you saying this code is ok?
06:36:10 <EvanR> no you can collapse it
06:37:06 <mikail__> I can't see how I can do that
06:37:10 <EvanR> take as arguments the "DownAndIn/UpAndOut" and "Call/Put", and compute the error message, and either a single function to call on s k r v t q h, OR a pair of functions to call on s k r v t q h and subtract
06:37:35 <EvanR> then somewhere else put the results into this repeating pattern, which is no longer repeating
06:37:43 <mikail__> oh right
06:37:47 <mikail__> yep, got it
06:37:49 <mikail__> thanks
06:39:03 <EvanR> i should say... compute (lte,gt) case, where the case is a single function, pair of functions, or constant (0)
06:39:08 <EvanR> and the error message
06:39:21 * EvanR waves hands and leaves for coffee
06:40:44 <lpaste> lyxia annotated “Pricing Code” with “Pricing Code (annotation) to mikhail__” at http://lpaste.net/165765#a165767
06:41:17 <lyxia> mikail__: ^
06:42:13 <mikail__> awesome - thanks lyxia
06:49:49 <DangerousDave> Hello, somone have an idea why I get the following error eventhough I got "+" on my reservedOps in my lexer: unexpected "+"
06:50:16 <DangerousDave> expecting letter or digit, "(", identifier, number, "true", "[", "\\" or ")"
06:51:58 <pavonia> DangerousDave: That's hard to tell without seeing some code
06:53:41 <DangerousDave> well I think that this is the minimal piece of code that I can give: http://pastebin.com/eupJwqwa. If its not enough please tell me.
06:55:09 <DangerousDave> actually I'm trying to extend https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter4/untyped/Parser.hs
06:57:26 <lyxia> what's tol
06:57:29 <lyxia> tok
06:58:06 <DangerousDave> import qualified Text.Parsec.Token as Tok
06:58:06 <lyxia> Parsec?
07:02:33 <DangerousDave> So...Someone have an idea? :|
07:02:49 <lyxia> well what are you trying to parse
07:02:52 <lyxia> how do you do it
07:03:21 <DangerousDave> I am trying to parse (\x.x+4)
07:04:34 <DangerousDave> "<stdin>" (line 1, column 7): unexpected "+" expecting letter or digit, "(", identifier, number, "true", "[", "\\" or ")"
07:04:44 <DangerousDave> thats the error I get
07:05:02 <lyxia> DangerousDave: that's not even in the syntax
07:05:18 <magneticduck> ah, so we have an error from your custom parser and an unexplained expression that you need to parse somehow
07:05:34 <magneticduck> oh wait, context, you also linked your code
07:06:18 <DangerousDave> lyxia: What is not in the syntax?
07:06:29 <lyxia> DangerousDave: makeTokenParser builds a dictionary of token parsers that you must then compose to parse full expressions
07:06:59 <lyxia> DangerousDave: https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter4/untyped/Syntax.hs there's no "+" in this ADT
07:07:11 <DangerousDave>  where ops = ["->","\\","+","*","-","="]
07:07:19 <DangerousDave> there are reservedOpNames
07:07:35 <DangerousDave> and the + operator is there
07:07:37 <lyxia> but you have to write more code to give these opNames meaning
07:07:46 <DangerousDave> Oh, I did it
07:08:33 <DangerousDave> but I thought that I have a problem cause it seems like reservedOp "*"
07:08:35 <DangerousDave> doesn't work
07:08:51 <DangerousDave> "+" sorry.
07:09:20 <DangerousDave> and it should work as "+" is in the reservedOpNames
07:09:23 <DangerousDave> shouldn't it?
07:10:46 <lyxia> it should
07:11:25 <DangerousDave> the error I get saying it doesn't isn't it?
07:11:52 <DangerousDave> http://pastebin.com/BfpLYLQ6 thats the extension I have added.
07:20:07 <lyxia> how did you add it to the final parser?
07:20:14 <lyxia> why not post all your code
07:20:32 <DangerousDave> http://pastebin.com/ZnMA6upB
07:21:00 <DangerousDave> lyxia: or better one - http://pastebin.com/rTdPXBUw
07:21:56 <DangerousDave> and thats the error which I don't get: http://pastebin.com/nchiL5Ka
07:25:23 <lyxia> your arithmetic expressions can only contain numbers
07:25:26 <lyxia> not variables
07:26:03 <DangerousDave> even if I write (3+4)
07:26:06 <DangerousDave> I get the same message
07:26:19 <lyxia> parens expr <|> parens arithmeticExpr will never try the second alternative
07:27:05 <DangerousDave> Thank you! :P
07:27:26 <DangerousDave> Now I get what happend
07:27:28 <lyxia> because of how parsec backtracks: parens expr sees a parenthesis, consumes it, fails. so parens expr <|> parens arithmeticExpr fails because the first alternative failed while having consumed some input
07:27:47 <DangerousDave> What is the good practice here then?
07:28:48 <DangerousDave> I mean I don't want to get infinity recursive loop
07:28:57 <lyxia> a quick fix is to use try
07:29:13 <DangerousDave> try over what
07:29:16 <lyxia> try (parens expr) <|> parens arithmeticExpr
07:32:50 <DangerousDave> Is there any way to avoid the parent for the arithmetic Expr?
07:32:55 * hackagebot irc-conduit 0.2.0.0 - Streaming IRC message library using conduits.  https://hackage.haskell.org/package/irc-conduit-0.2.0.0 (barrucadu)
07:34:19 <lyxia> parens expr <|> arithmeticExpr <|> lambda
07:34:41 <lyxia> (after pulling variable inside arithmetic Expr)
07:35:05 <DangerousDave> but variable is not an arithmetic expr
07:35:48 <lyxia> oh no my bad that wouldn't have worked anyway
07:36:14 <lyxia> can't get around try without rewriting everything
07:37:03 <lyxia> well ok keep variable there then, try (parens expr) <|> arithmeticExpr <|> variable <|> lambda, perhaps?
07:37:55 <DangerousDave> well thats what I did, seems to work fine, but I need to fix my prettifier so ill know later
07:42:35 <muesli4> Hi, what's the issue with this code: http://codepad.org/0Pav3UKG ? I want to filter a heterogeneous list by a specific type and produce a length-encoded list.
07:45:08 <muzzle> hi
07:46:07 <muzzle> how can i use the library from a project i'm developing locally in an other project (using stack)
07:49:17 <DangerousDave> Hello, where can I find what is the s u m in ParsecT, I mean what each argument stand for?
07:50:29 <muzzle> http://hackage.haskell.org/package/parsec-3.1.10/docs/Text-Parsec.html
07:50:41 <EvanR> state, stream type, monad
07:50:59 <EvanR> hmm thats backwards
07:51:24 <muzzle> it's stream type, user-state monad
07:51:33 <DangerousDave> thank you :)
07:51:59 <DangerousDave> looked over it over all the Text.Parsec.* should try that :P
07:52:03 <muzzle> when the newest hackage documentation for a project isn't built, try one of the (slightly) older versions
08:03:39 <lyxia> muesli4: the compiler doesn't know that FilterMTRes ts is some MTList, so it can't reduce MTListCons
08:05:00 <muesli4> lyxia: so maybe if i instead specify the length, it could work
08:05:44 <lyxia> specify where
08:06:26 <muesli4> lyxia as a type family,
08:06:48 <lyxia> ah, yeah maybe
08:07:33 <muesli4> lyxis: bingo, thx very much ;)
08:07:56 * hackagebot js-jquery 3.0.0 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-3.0.0 (NeilMitchell)
08:08:05 <muzzle> Can i use a project that i have locally as a dependency for another local project in stack?
08:09:10 <lyxia> muzzle: just add the directory of the dependency in your stack file
08:09:29 <muzzle> as a location in the packages section?
08:09:58 <lyxia> yeah, like there's usually  - '.'   already
08:11:08 <muzzle> doesn't seem to work
08:11:49 <muzzle> Coudl not find package ... in known packages
08:12:49 <lyxia> it should be a path
08:12:59 <muzzle> it is
08:13:20 <muzzle> -location /home/muzzle/programming/test-package
08:13:31 <muzzle> -location: /home/muzzle/programming/test-package
08:14:56 <muzzle> nvm
08:14:58 <muzzle> i got it
08:15:01 <muzzle> lyxia thanks
08:17:57 * hackagebot irc-client 0.4.0.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.0.0 (barrucadu)
08:52:21 <kritzcreek> I'm trying to use optparse-applicative with ghc8 and it seems like all the options are missing a semigroup instance and now I think have to use `mappend` over <>. Am I missing something?
08:56:51 <nilof> Has anyone else run into trouble trying to install hmatrix? I got this error when trying to cabal install it: http://pastebin.com/D7yCJjmq
08:57:58 * hackagebot dunai 0.1.0.0 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.1.0.0 (IvanPerez)
08:58:00 * hackagebot bearriver 0.10.4 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.10.4 (IvanPerez)
08:59:21 <chiboo> has anyone managed to get intero to play nice with ghcjs? or do you know if there's work being done to make that happen?
09:21:40 <nitrix> Why is GHCJS a fork of GHC and not an additional backend?
09:23:00 * hackagebot sexp-grammar 1.2.0 - Invertible parsers for S-expressions  https://hackage.haskell.org/package/sexp-grammar-1.2.0 (EugeneSmolanka)
09:26:24 <DangerousDave> Hello, I am trying to divide 2 numbers of type Num should I pattern match/case over all the possible combinations to put fromIntegral in the integers place, or is there another way?
09:27:55 <EvanR> :t \x y -> fromIntegral x `div` fromIntegral y
09:27:57 <lambdabot> (Integral a, Integral a1, Integral a2) => a1 -> a2 -> a
09:28:00 * hackagebot cgrep 6.6.15 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.15 (NicolaBonelli)
09:28:03 <jmcarthur> nitrix: It's not a fork.
09:28:19 <jmcarthur> nitrix: It just uses the GHC API.
09:32:49 <nitrix> Oh o:
09:36:33 <DangerousDave> Hello, Why do I get Parse error in pattern: _
09:37:00 <DangerousDave> I just try to catch Lit ([LDouble/LInt] x) with L (_ x)
09:37:07 <DangerousDave> Lit (_ x)
09:37:39 <DangerousDave> As I understand the pattern match _ symbol is only over exact types?
09:37:59 <DangerousDave> if it does, how can I solve this problem?
09:38:12 <EvanR> (_ x) doesnt make sense
09:38:42 <EvanR> for example data Two a = Two a a
09:38:50 <EvanR> (Two x)
09:38:57 <EvanR> no data looks like Two x
09:39:06 <EvanR> it would be a type error
09:39:10 <nitrix> DangerousDave: If it's matching any type constructor, how do you know which constructor it is to extract its argument?
09:39:34 <nitrix> *data constructor
09:42:05 <nitrix> Even with `data Foo a = Bar a | Baz a` you'd probably get the same parse error.
09:42:16 <DangerousDave> so how should I avoid
09:42:22 <DangerousDave> to write all the combinations then?
09:42:36 <Iceland_jack> DangerousDave: I'd like some example code but it can probably be done with pattern synonyms
09:44:28 <DangerousDave> hmmm well I have 2 types data Lit = LDouble Double | LInt Int and a method that get Lit->Lit->Double that divide the numbers
09:45:59 <EvanR> DangerousDave: what type do you want it to have when you do funky arithmetic on them
09:46:16 <EvanR> are Ints being promoted
09:47:02 <EvanR> for Lit->Lit->Double just convert it to double first
09:49:21 <DangerousDave> I dont understand how can I even catch
09:49:22 <DangerousDave> both of them
09:49:27 <nitrix> divLit a b = na / nb where na = case a of LInt x -> fromIntegral x; LDouble x -> x;  nb = ... same thing
09:49:32 <Iceland_jack> You can use a single pattern 
09:49:32 <Iceland_jack>     asDbl :: Lit -> Double
09:49:32 <Iceland_jack>     asDbl (LDouble a) = a
09:49:32 <Iceland_jack>     asDbl (LInt    a) = fromIntegral a
09:49:33 <DangerousDave> If I want to pattern match
09:49:36 <Iceland_jack> and
09:49:39 <Iceland_jack>     pattern Dbl :: Double -> Lit
09:49:42 <Iceland_jack>     pattern Dbl d <- (asDbl -> d)
09:49:46 <Iceland_jack>       where Dbl d = LDouble d
09:50:04 <nitrix> DangerousDave: I have this `na` and `nb` pattern matching and converting to Double.
09:50:22 <nitrix> DangerousDave: `asDbl` from Iceland_jack is a similar, probably better idea.
09:50:24 <Iceland_jack> Then you can write
09:50:25 <Iceland_jack>     Dbl a /// Dbl b = a / b
09:51:03 <Iceland_jack> Overkill for this simple situation but can be useful once Lit grows
09:51:50 <nitrix> The pattern synonyms maybe, but the asDbl is pretty much the only way I can think of.
09:52:25 <Iceland_jack> Yes, it's very easy to write without the synonym
09:52:25 <Iceland_jack>     (asDbl -> a) /// (asDbl -> b) = a / b
09:53:05 <Iceland_jack> or Haskell2010
09:53:05 <Iceland_jack>     a /// b = a' / b' where (a', b') = (asDbl a, asDbl b)
09:53:55 <Iceland_jack> Which I should have mentioned before pattern synonyms
10:07:02 <bblfish> let f =  flip runReaderT 3
10:07:12 <bblfish> let g = flip evalStateT 3
10:07:44 <bblfish> :t g . f
10:07:44 <bblfish> g . f :: (Monad m, Num s, Num r) => ReaderT r (StateT s m) a -> m a
10:07:46 <lambdabot>     Could not deduce (Show b0) arising from a use of ‘g’
10:07:46 <lambdabot>     from the context (Show a, FromExpr c)
10:07:46 <lambdabot>       bound by the inferred type of it :: (Show a, FromExpr c) => a -> c
10:08:13 <bblfish> g . f
10:08:30 <bblfish> how come f and g compose?
10:09:17 <bblfish> :t  flip runReaderT 3
10:09:18 <lambdabot> Num r => ReaderT r m a -> m a
10:09:27 <bblfish> :t flip evalStateT 3
10:09:28 <lambdabot> (Monad m, Num s) => StateT s m a -> m a
10:10:15 <bblfish> :t .
10:10:16 <lambdabot> parse error on input ‘.’
10:10:27 <bblfish> as I understand function composition has type (b -> c) -> (a -> b) -> a -> c
10:11:58 <bblfish> I suppose there is something special about newtype objects ...
10:12:11 <ClaudiusMaximus> try writing out the type unification by hand, taking care to rename things to avoid clashes (the 'm' in each type separately isn't the same across the combined type)
10:14:10 <osager> I've seen a code like this:  type ContentApi a = ReaderT ApiConfig (ResourceT IO) a
10:14:21 <osager> why does the author use ResourceT IO
10:14:23 <osager> ?
10:14:49 <osager> in fact, i dont understand what to define for m in ReaderT r m a
10:15:22 <EvanR> m is something of kind * -> *
10:15:35 <osager> i know
10:15:40 <EvanR> which ends up needing a Monad instance to do anything
10:16:01 <EvanR> so ResourceT IO is one choice
10:16:28 <osager> so i have an action which reads some config, and i use return to wrap the results to a readerT
10:16:44 <osager> what's the relation between my action and the m 
10:17:08 <EvanR> if all it does is read the config, nothing
10:17:11 <osager> if i choose IO as m , does it mean that my action needs to be IO ?
10:17:42 <EvanR> your action will be ReaderT Config m ()
10:18:07 <EvanR> unless you return something thats not ()
10:18:15 <osager> then which monad should i pick for m?
10:18:25 <osager> ReaderT Config m
10:18:26 <EvanR> you dont have to pick any if you dont use anything from m
10:18:31 <EvanR> it can be polymorphic
10:18:44 <osager> when ever will i use the m ?
10:18:54 <EvanR> for example if you wanted to read the config AND execute IO
10:19:49 <EvanR> if it doesnt use m you can also use the simpler Reader Config ()
10:19:52 <EvanR> (m = Identity)
10:20:46 <osager> so if my action is defined as a ReaderT and it reads a config and do IO, then the m is IO ?
10:21:10 <EvanR> either IO or some monad which involves IO, like another transformers over IO, or a type that is an instance of MonadiO
10:21:15 <EvanR> MonadIO
10:22:00 <EvanR> IO lets you do anything, so if thats not exactly what you want its possible do work to restrict the kind of IO you want to do, in which case you would not put literally IO there
10:22:27 <EvanR> you pick m to be whatever monad that has the abilities you want to use
10:22:29 <osager> the readert is really counter intuitive...
10:22:58 <EvanR> you dont have to use ReaderT to do what ReaderT does, you can just pass the config to whatever needs it
10:24:04 <osager> so readerT is created only so the people dont have to pass configs around ?
10:24:21 <osager> youve mentioned generic code
10:24:21 <EvanR> pretty much
10:25:05 <EvanR> you can make an action of type :: ReaderT MyConfig m MyResult
10:25:32 <EvanR> then it can be used with actions where m is anything
10:25:42 <EvanR> but you cant use m for anything
10:26:23 <osager> in which code do i concretely use the m?
10:26:38 <osager> when i define a function that returns a ReaderT ?
10:27:02 <osager> within this function i can use m?
10:27:13 <EvanR> or when you write a ReaderT value directly, not returned from a function
10:27:51 <osager> the constructor seems to be a function called: runReaderT
10:28:06 <osager> But ReaderT r m a is also a constructor
10:28:18 <EvanR> runReaderT isnt a constructor, its the destructor
10:28:26 <EvanR> or evaluator
10:30:08 <osager> thanks
10:30:14 <osager> very much
10:31:28 <prannayk> can I use CUDA libraries with Haskell in any way
10:32:28 <hpc> yes
10:32:57 <hpc> there's a cuda package which is plain FFI bindings, and accelerate-cuda which is awesome
10:33:43 <prannayk> alright thanks
10:36:23 <bblfish> :k StateT
10:36:24 <lambdabot> * -> (* -> *) -> * -> *
10:36:51 <bblfish> It looks like StateT is defined as "newtype StateT s m a :: * -> (* -> *) -> * -> *"
10:37:42 <bblfish> so does that mean that s :: *, m :: *->*, a :: * and StateT is a function that given those values returns a new type (the last *) ?
10:38:22 <monochrom> yes
10:38:39 <monochrom> but no, not values. types.
10:40:19 <bblfish> ah yes.
10:41:01 <bblfish> :t flip evalStateT 42
10:41:02 <lambdabot> (Monad m, Num s) => StateT s m a -> m a
10:41:08 <bblfish> :k flip evalStateT 42
10:41:09 <lambdabot> Not in scope: type variable ‘flip’
10:41:09 <lambdabot> Not in scope: type variable ‘evalStateT’
10:41:53 <EvanR> :k Just 'z'
10:41:55 <lambdabot> parse error on input ‘'’
10:41:58 <EvanR> heh
10:42:18 <EvanR> :k does not work on values
10:42:19 <lambdabot> Not in scope: type variable ‘does’
10:42:20 <lambdabot> Not in scope: type variable ‘not’
10:42:20 <lambdabot> Not in scope: type variable ‘work’
10:42:40 <bblfish> so can I expand "StateT s m a -> m a" somehow into a larger function?
10:42:59 <monochrom> I don't understand that question.
10:43:29 <monochrom> do you know "value", "type", "kind"?
10:43:44 <bblfish> :t f
10:43:45 <lambdabot> FromExpr a => a
10:44:30 <bblfish> :t flip evalStateT 24 . flip runReaderT 42
10:44:32 <lambdabot> (Monad m, Num s, Num r) => ReaderT r (StateT s m) a -> m a
10:44:50 <bblfish> that composition works, but I don't understand how
10:45:01 <bblfish> :t flip evalStateT 24
10:45:02 <lambdabot> (Monad m, Num s) => StateT s m a -> m a
10:45:06 <bblfish> :t flip runReaderT 42
10:45:08 <lambdabot> Num r => ReaderT r m a -> m a
10:45:25 <glguy> bblfish: You can play with lambdabot in /msg
10:45:42 <monochrom> glguy, it's ok, those two lambdabot queries are part of the question
10:46:05 <monochrom> do you mind if I rename the type variables for minimum conflation?
10:46:17 <bblfish> of course I don't mind :-)
10:46:45 <monochrom> flip runReaderT 42 :: Num r => ReaderT r n b -> n b
10:47:18 <monochrom> so we need n b = StateT s m a.  Therefore, n = StateT s m, b = a
10:47:45 <monochrom> flip runReaderT 42 :: Num r => ReaderT r (StateT s m) a -> StateT s m a.
10:47:52 <monochrom> now the composition can proceed.
10:48:40 <bblfish> ahh. ok. That hurts my brain.
10:48:43 <prannayk> any interesting project I might wanna undertake so that I get comfortable with Monads? I am a beginner
10:49:07 <Mion> prannayk: a better mousetrap
10:49:51 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
10:51:03 <bblfish> thanks. I am trying to translate http://dlaing.org/cofun/posts/free_and_cofree.html into Scala. It's actually quite difficult to do.
10:52:30 <bblfish> (at leat for someone like me who does not have a lot of practical experience with Haskell...)
10:53:49 <EvanR> prannayk: i would not try to think of projects to do monads with, monads are better for small scale quick computations, if at all
10:54:13 <EvanR> instead pick a project and try to do it somehow, or else pick a monad and try to do some simple thing with it
10:54:50 <EvanR> (note the difference between that, and "using monads")
10:55:14 <bblfish> prannayk: actually try reading an article about Free monads, Those are more difficult, but so unusual that they will show you what is so really interesting there.
10:55:41 <EvanR> free monads are probably going to get in the way of learning how to use particular monads for something
10:55:51 <EvanR> if you dont already understand it all
10:56:20 <EvanR> and if you havent already, learn how to use Functors first
10:56:33 <monochrom> that's what free things always do, isn't it?
10:56:53 <prannayk> right. I think I will go with EvanR . I do know how to use Functors and have built something using them. 
10:57:05 <monochrom> wikipedia is free. and this means it is useful after you understand the topics
10:57:19 <bblfish> could be. At the same time it's only when I discovered that with Free Monads I could write a server that would be able to write programs that could fetch graphs, and manipulate them, wherever they were on the web, without having to bother about them being local or remote that I was convinced that FP in the manner of Scala was really interesting.
10:57:32 <monochrom> a lot of blog articles claiming to explain things are free. and this again means that they are useful after you understand the topics.
10:57:45 <EvanR> im not sure what that has to do with free monads in particular
10:57:58 <ania123> does one has access to this paper: Janine Wittwer. Survey Article: A user's guide to Bellman functions 
10:58:48 <bblfish> HEre is an LDPCommand DSL for use with FreeMonads https://github.com/read-write-web/rww-play/blob/dev/app/rww/ldp/LDPCommand.scala
11:00:00 <bblfish> And here is how one could use it https://github.com/read-write-web/rww-play/blob/dev/test/ldp/LDRTestSuite.scala#L55
11:00:44 <bblfish> (btw, that was what I did when I did not even quite realise that Category Theory was important, by following someone who knew what they were doing)
11:02:41 <bblfish> monochrom: ok, I see. What I am not used to is that in Haskell the pattern matching is so wide spread, not just limited to `match` expressions...
11:04:03 <EvanR> bblfish: i get kind of suspicious whenever some API from another language claims to use monads for something... only to end up basically being some monoid with (actual) side effects
11:04:10 <EvanR> not sure what this scala thing is though
11:04:40 <Jinxit> scala is functional OOP on the JVM
11:05:40 <EvanR> talking about free monad DSLs for downloading stuff
11:05:42 <bblfish> EvanR: as Jinxit says. And it has two libs for pure functional programming a la Haskell scalaz and cats https://github.com/typelevel/cats
11:05:52 <EvanR> right scalaz
11:18:07 <MILK_FNT> Hi :D
11:25:23 <dfeuer> Word up, home dog?
12:12:15 <Gurkenglas> Why does "interact $ unlines . foldr (filter . isInfixOf) entries . words . head . lines" do nothing, not even waiting for stdin?
12:12:34 <Gurkenglas> Same for "getLine >>= putStrLn . foldr (filter . isInfixOf) entries . words"
12:14:58 <mauke> :t entries
12:14:59 <lambdabot> Not in scope: ‘entries’
12:15:31 <petercommand> Gurkenglas: what is 'entries'?
12:15:42 <petercommand> :t isInfixOf
12:15:43 <lambdabot> Eq a => [a] -> [a] -> Bool
12:15:49 <dfeuer> Gurkenglas, why are you using interact? Also, I'm betting that entries is [].
12:15:52 <Gurkenglas> :t interact $ unlines . foldr (filter . isInfixOf) ?entries . words . head . lines
12:15:53 <lambdabot> (?entries::[String]) => IO ()
12:16:02 <Gurkenglas> Nah, printed it, took a awhile
12:16:29 <petercommand> :t interact $ unlines . foldr (filter . isInfixOf) _ . words . head . lines
12:16:30 <lambdabot>     Found hole ‘_’ with type: [String]
12:16:31 <lambdabot>     In the second argument of ‘foldr’, namely ‘_’
12:16:31 <lambdabot>     In the first argument of ‘(.)’, namely
12:16:44 <petercommand> it supports type hole :D
12:17:00 <mauke> that's not a type hole
12:17:18 <Gurkenglas> dfeuer, because I thought that would send each line through the function... I guess a version of that line that justifies interact is:
12:17:44 <dfeuer> Gurkenglas, I'm not saying you *can't* use it. It's just a bit old-fashioned.
12:17:51 <Gurkenglas> :t interact $ unlines . map (unlines . foldr (filter . isInfixOf) ?entries . words) . lines
12:17:52 <lambdabot> (?entries::[String]) => IO ()
12:18:23 <Gurkenglas> What do you use nowadays? "forever $ getLine >>= putStrLn f"?
12:18:30 <dfeuer> I have a weird and annoying problem that I've come to realize is basically a parsing problem. Maybe I can structure this thing like a parser.
12:18:53 <Gurkenglas> *putStrLn . f
12:19:07 <dfeuer> But I don't know much about parsers.
12:19:26 <dfeuer> I'm pretty sure this can be written as a parsing problem.
12:19:47 <Gurkenglas> Stahp ranting unless you give us the problem!
12:20:20 <joe9> Is there a way to migrate my ~/.cabal/config to ~/.stack/config.yaml? I have some local libraries and specified them as extra-lib-dirs. I want to ensure that stack picks up this entry.
12:20:30 <dfeuer> Gurkenglas, I'm trying to figure out how to implement fromList :: [a] -> Seq a   (for Data.Sequence) with an absolute bare minimum of extra allocation.
12:21:37 <dfeuer> The current version (which is modified from one written by Ross Paterson) is pretty fast, but it allocates intermediate lists that I think probably shouldn't be necessary.
12:21:41 <Gurkenglas> foldMap pure doesn't O2 to the optimum?
12:22:04 <dfeuer> Um ... no.
12:22:09 <dfeuer> Definitely not.
12:22:48 <dfeuer> In fact, GHC optimization tends to be blocked up pretty badly in Data.Sequence. It gets some stuff right, but its generally not reliable.
12:22:59 <petercommand> mauke: ah, it is only a hole :D
12:23:07 * hackagebot postgrest 0.3.2.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.3.2.0 (begriffs)
12:23:20 <dfeuer> There's too much polymorphic recursion, higher-order functions, etc.
12:23:46 <dfeuer> But in this case, foldMap pure just doesn't even come close to expressing an optimal algorithm.
12:25:31 <joe9> Would anyone mind sharing their stack/config.yaml ? I am trying to figure out how to let stack see my local libraries.
12:26:46 <Adeon> when I've used local libraries I've just specified a path in stack.yaml of the project and put extra-dep: True on it
12:26:52 <athan> joe9: I usually develop a bunch of packages in a shared parent directory, then in my `stack.yaml` I'll include `packages: '.'\n '../foo'`
12:26:54 <Adeon> or alternatively git path if the project is easily accessible on git
12:28:45 <dfeuer> But yeah, this totally must be expressible as a parsing problem in a way that will be useful. Just need to find the way.
12:29:18 <dfeuer> Parse failure has to produce not only the leftovers but also some useful pieces of indermediate results.
12:29:25 <dfeuer> *intermediate
12:31:18 <dfeuer> I just ... can't ... see it.
12:32:52 <dfeuer> Another way to express it might be as a stream fusion problem....
12:35:07 <dfeuer> Gurkenglas, look at https://github.com/haskell/containers/blob/ed43239058dc02decf07ab144acde5dbb0aa1d53/Data/Sequence.hs (which is easier to understand than my recent modification). Do you see how getNodes makes a list of nodes? I'd rather it didn't.
12:35:40 <joe9> Adeon, Thanks for the response. I have some local haskell libraries that I prefer to use in my projects. With cabal, I specified extra-lib-dirs in ~/.cabal/config. With flycheck, it invokes the stack executable. It appears that the stack executable cannot find my local libraries.
12:35:59 <dfeuer> I'd like to avoid any node lists, and "parse" directly from the Elem list.
12:40:07 <Gurkenglas> I'm not that into that stuff yet, but that sounds like you want to eliminate the lists through continuation passing?
12:41:32 <Gurkenglas> getNodes :: Int -> a -> [a] -> (Int -> FingerTree (Node a), Digit a)
12:43:32 <pikajude> so still, I'm not sure what governs the order of types in TypeApplications
12:43:53 <Gurkenglas> getNodes !_ x1 [] = (const EmptyT, One x1) -- etc for the next two lines
12:44:00 <pikajude> from the wiki page it sounds like an implicit forall is placed at the beginning of the type. but how do I know what the ordering of variables in the forall is?
12:45:04 <monochrom> pikajude, the GHC user's guide has a paragraph on this.
12:45:38 <monochrom> actually it blows up into several paragraphs
12:46:09 <Gurkenglas> (And then there might be another step where it turns out this transformation gets rid of the [a] argument to getNodes too)
12:46:10 <monochrom> what wiki page? wiki pages are sporadic these days
12:46:26 <pikajude> that's a shame, because nix's installed GHC doesn't have a user guide
12:46:30 <monochrom> even I stopped working on wiki pages
12:46:32 <Gurkenglas> dfeuer you getting what im getting at?
12:46:44 <dfeuer> Gurkenglas, sorry, looked away.
12:47:25 <monochrom> the user's guide is also on GHC website. but I recommend a local copy. pretty sure there is a nix package for that.
12:47:32 <dfeuer> Gurkenglas, no, I'm not seeing that yet.
12:47:42 <pikajude> oh, okay. it's just left-to-right
12:48:02 <monochrom> yeah, but that's just the first paragraph, for the ordinary case
12:48:23 <monochrom> the next several bullets start telling you deviations because of dependency etc
12:48:30 <pikajude> so it's not *just* left-to-right, GHC does a stable toposort
12:48:47 <monochrom> ah, that's a nice way to put it
12:49:02 <dfeuer> Gurkenglas, I'm giving the stream approach a shot now...
12:49:20 <dfeuer> Or something.
12:50:19 <monochrom> the most unsettling part is that kind variables are up for instantiation too, and yet this is just for the explicit ones, you can't touch the implicit ones
12:52:01 <Gurkenglas> (Ah shoot getNodes is recursive I thought its only used in mkTree this might be hard)
12:52:04 <monochrom> I guess that is more sensible than allowing access to the implicit ones. you see a variable, you instantiate.
12:52:14 <pikajude> well it says it does a toposort. i wish it were my wording
12:52:17 <pikajude> how odd.
12:52:31 <pikajude> so that is why fmap's first type argument is for 'f'
12:52:52 <monochrom> oh, actually fmap's is in the paragraph for class methods :)
12:52:58 <osager> ReaderT :: (r -> m a) -> ReaderT r m a
12:53:09 * hackagebot tagsoup 0.14 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.14 (NeilMitchell)
12:53:19 <dfeuer> No .... not that.
12:53:20 <osager> the first ReaderT is a function
12:53:20 <dfeuer> UGH.
12:53:21 <monochrom> see how it is blowing up to the complexity of C++ ambiguity resolution? :)
12:53:30 <osager> and the second is a constructor ?
12:55:02 <monochrom> osager, a data constructor can play the role of function. the first ReaderT is both data constructor and function.
12:55:11 <osager> if we look at the second one, ReaderT take three arguments
12:55:33 <osager> but if we look at the first one, it takes only one
12:55:50 <osager> im really confused
12:56:13 <monochrom> yes, all confusions are caused by wrong assumptions.
12:58:09 * hackagebot hackage-whatsnew 0.1.0.1 - Check for differences between working directory and hackage  https://hackage.haskell.org/package/hackage-whatsnew-0.1.0.1 (JeremyShaw)
12:59:30 <Cale> osager: Note that there are two things which are called ReaderT which live in separate namespaces. There is a type constructor, which takes three *type* arguments, its kind is * -> (* -> *) -> * -> *, it takes an environment type, and some monad, and produces another monad.
12:59:52 <monochrom> yeah, the 2nd ReaderT is a type constructor
13:00:13 <monochrom> at some point you'll need to distinguish the value level from the type level
13:00:39 <Cale> osager: and then there's a data constructor, which is a value-level thing, its type is (e -> m a) -> ReaderT e m a -- it takes just one argument which is a function.
13:01:11 <osager> thanks
13:01:22 <osager> so there are two ways to construct a ReaderT
13:01:27 <Cale> The occurrence of ReaderT e m a in this type here is obviously the type-level ReaderT which I mentioned first
13:01:41 <osager> ReaderT f or ReaderT Config Actiion
13:01:59 <monochrom> no
13:02:07 <Cale> Well, it depends on what you mean by "construct a ReaderT" -- as soon as you specify what that is, there's only going to be one way.
13:02:25 <Cale> Are you constructing a value, or a type?
13:02:43 <osager> ok i see
13:02:47 <osager> type and value thing
13:03:05 <osager> i dont see this confusion in EitherT
13:03:21 <Cale> It might be less confusing if we were to rename the data constructor
13:03:40 <Cale> newtype ReaderT e m a = MkReaderT (e -> m a)
13:03:55 <osager> i get it!
13:03:58 <osager> great!
13:03:59 <Cale> Now we have the function  MkReaderT :: (e -> m a) -> ReaderT e m a
13:04:48 <Cale> MkReaderT and ReaderT live in completely separate namespaces, so it's valid to reuse the same name there
13:06:26 <yorick> using aeson, I have: maybeAnInt :: Parser Int -> Parser String -> Parser Int. but then, I keep having to write `maybeAnInt (r .: "ResponseCode") (r .: "ResponseCode")`
13:06:31 <yorick> there's gotta be a better way
13:06:39 <monochrom> EitherT :: ... -> EitherT l m a. It has two EitherT's
13:06:46 <athan> Is there a monoid for Maximum / Minimum?
13:06:46 <jmcarthur> dfeuer: Maybe you can define a family of mkTreeN functions with up to four extra arguments for the prefixes of the list, define a family of getNodesN functions with up to three extra arguments to save up for a call into one of the mkTreeN functions, and make them all mutually recursive. (Am I even making sense?)
13:07:44 <dfeuer> jmcarthur, not sure. Do you think you could sketch it out? Prefixes tend to be easy peasy.The suffixes bite.
13:07:58 <athan> erp nevermind, semigroup to the rescue!
13:09:20 <jmcarthur> dfeuer: I'll just clone it and give it a shot.
13:11:52 <jmcarthur> Ah the actual current implementation is a little different from what I was looking at.
13:18:10 * hackagebot accuerr 0.2.0.0 - Data type like Either but with accumulating error type  https://hackage.haskell.org/package/accuerr-0.2.0.0 (OmariNorman)
13:18:34 <biglambda> How does one get cabal to compile the library section of the configure file?
13:21:44 <hexagoxel> biglambda: `cabal build lib:LIBNAME` where LIBNAME equals package name.
13:22:12 <hexagoxel> if there is no other component called LIBNAME, the "lib:" part can be omitted.
13:22:53 <biglambda> I see, where do I find the library once it’s compiled?
13:23:47 <biglambda> I see it, in dist build :)
13:28:09 <texasmynsted> Anybody know why Erik Meijer no longer seems interested in Haskell?  He had made those C9 lectures, but he seems no longer interested in functional programming, especially haskell.
13:29:52 <joncfoo> maybe he's traveling the world preaching the good news of FP
13:29:54 <systemfault> He seemed to me that he's sacrificing himself to promote the usage of FP by dumbening it down so 9 to 5 people can understand it.
13:30:13 <systemfault> I think we need more people like him.
13:31:02 <texasmynsted> I like Erik, and he does a nice job of explaining things, but I have not heard him talk about haskell in a long time.
13:32:01 <benzrf> he left to found a successful chain of grocery stores in the midwest
13:32:08 <texasmynsted> I do not know about "dumbing it down".  You can either explain well or you can not.
13:32:23 * texasmynsted facepalm
13:32:31 <joncfoo> it all depends on your target audience
13:33:02 <texasmynsted> yes, all explanations do
13:33:52 <systemfault> texasmynsted: Telling newcomers that a monad is just a monoid in the category of endofunctor doesn't help the FP cause.
13:33:55 <joncfoo> when I was brand new to FP a lot of the terms thrown around did make it seem like it was another world that was unapproachable
13:34:14 <joncfoo> but then I ran across this post: http://www.stephendiehl.com/posts/abstraction.html
13:34:16 <zennist> in lens - how to convert a Prism to something that's settable i.e., given data AB = A a | B b, makePrisms ''AB, mymap :: Map Int AB; I'd like to make this work: mymap & at 3.someFunc _A.non a' .~ a
13:34:37 <jmcarthur> @tell dfeuer This is trickier than I thought it would be. I think my direction doesn't work after all, or at least it's difficult.
13:34:37 <lambdabot> Consider it noted.
13:34:43 <benzrf> systemfault: talking about "dumbing stuff down" is extremely arrogant and alienating
13:34:50 <glguy> zennist: You set through a Prism without doing anything else
13:34:57 <joncfoo> and understood the purpose of being able to talk about things in an abstract manner
13:34:59 <systemfault> benzrf: Not everyone has a phd in math.
13:35:21 <benzrf> i am not talking about what you *mean*, i'm talking about what you *say*
13:35:34 <systemfault> Ok, I'm sorry. Can we move on?
13:35:39 <glguy> > set _Left 10 (Left True)
13:35:41 <lambdabot>  Left 10
13:35:49 <joncfoo> how you say something also makes a big difference
13:36:12 <zennist> > set _Left 10 (Right "what")
13:36:13 <lambdabot>  Right "what"
13:36:24 <zennist> glguy: this doesn't work...
13:36:44 <glguy> zennist: _Left doesn't point inside Rights, so it shouldn't try and set it
13:36:57 <zennist> essentially I want a mapping that allows me to specify a setter, and always give me back the shape I want by using 'non'
13:37:00 <glguy> > const (Left 10) (Right "what")
13:37:01 <lambdabot>  Left 10
13:37:13 <glguy> If you jsut want to replace a value you just use a function
13:37:36 <zennist> > set (non 5) 20 Nothing
13:37:37 <lambdabot>  Just 20
13:37:40 <glguy> zennist: Write the thing you want without lens and I'll help you write it with lens
13:38:33 <zennist> > set _Just 20 Nothing
13:38:35 <lambdabot>  Nothing
13:38:48 <zennist> could you see what I want now?
13:39:59 <benzrf> > set id (Just 20) Nothing
13:40:01 <lambdabot>  Just 20
13:40:04 <zennist> I want a lens that maps a partial value of `a` e.g., Maybe a, or any Prism over a, to a `a`, but not in a `mapped` sense, but allowing me to modify that partial value to one containing a
13:40:33 <zennist> benzrf: the problem is that I'm allowed to write these in a Lens
13:40:43 <benzrf> that doesn't make sense
13:40:45 <benzrf> consider -
13:40:49 <benzrf> suppose i say:
13:41:01 <benzrf> set (foo._Just._1) 3
13:41:02 <zennist> the function I'm passing this into expects to use that same expression for both 1. getting a value from a structure; 2. setting the value in the structure
13:41:06 <benzrf> what if foo points to a Nothing?
13:41:11 <benzrf> what should the second element of the tuple be?
13:41:24 <zennist> benzrf: you use 'non a' to give a default
13:41:31 <benzrf> ah
13:41:40 <benzrf> then -
13:41:47 * benzrf thinks
13:42:23 <zennist> I tried this:
13:42:36 <zennist> > set (pre _Just . non 5) 20 Nothing
13:42:37 <lambdabot>      Could not deduce (Contravariant Identity)
13:42:37 <lambdabot>        arising from a use of ‘pre’
13:42:37 <lambdabot>      from the context (Eq a, Num a)
13:42:39 <benzrf> inb4 `to (preview pr)'
13:42:45 <benzrf> :t pre
13:42:46 <lambdabot> (Functor f, Conjoined p, Contravariant f) => Getting (First a) s a -> p (Maybe a) (f (Maybe a)) -> p s (f s)
13:43:02 <zennist> `to` only gives you a getter not a lens
13:43:07 <benzrf> yeah
13:43:23 <benzrf> what does pre do? it's been a while since i've tried to read lens type signatures
13:43:57 <zennist> pre supposedly converts a prism into a preview of the underlying partial value
13:44:13 <zennist> > Just 5 ^. pre _Just
13:44:15 <lambdabot>  Just 5
13:44:18 <benzrf> > (Just 2, Nothing) ^. _1.pre _Just
13:44:20 <lambdabot>  Just 2
13:44:21 <zennist> > Just 5 ^? _Just
13:44:22 <benzrf> o
13:44:23 <lambdabot>  Just 5
13:44:29 <benzrf> > (Just 2, Nothing) ^. _2.pre _Just
13:44:31 <lambdabot>  Nothing
13:44:34 <benzrf> i see
13:44:39 <zennist> it's the same as using 'preview'
13:44:40 <benzrf> but that's a getter, not a lens, then 
13:44:43 <Clint> dmwit_: whom should one bug about xmonad-extras?
13:44:43 <benzrf> ?
13:44:53 <zennist> yeah that might be true
13:45:07 <benzrf> f is restricted to basically being Const m up there
13:45:11 <benzrf> so that's a getter iirc
13:45:43 <zennist> that actually makes sense, because `preview` only gives you a view too
13:50:07 <jmcarthur> Using doctest for the first time today. It is amazing.
13:51:16 <jmcarthur> The only thing giving me grief is that multiline quickcheck tests seem unsupported.
14:13:56 <guest36246> i have a newbie question - ran into this line of code: modifyBlock $ blk { stack = i ++ [ref := ins] }
14:14:14 <guest36246> what does the [ref := ins] part mean? what's the := operator? can't find any info on that
14:15:01 <guest36246> (code is part of this tutorial: http://www.stephendiehl.com/llvm/)
14:15:50 <Cale> guest36246: Well, it's got to be a data constructor for some type
14:16:57 <aaronm04> the way I would solve this is to search the source for this library for ":="
14:17:21 <aaronm04> maybe you could also try importing in ghci and then doing :type (:=)
14:17:38 <guest36246> ok so it's something defined by the library, not a common construct?
14:17:42 <guest36246> looking
14:17:46 <Cale> guest36246: yes
14:17:49 <Cale> http://hackage.haskell.org/package/llvm-general-pure-3.5.1.0/docs/LLVM-General-AST-Instruction.html#v::-61- -- perhaps this
14:17:50 <zennist> @let nonp p def = iso (fromMaybe def . preview (clonePrism p)) (review (clonePrism p))
14:17:51 <lambdabot>  Defined.
14:18:41 <zennist> > set (nonp _Just 15) 20 Nothing
14:18:43 <lambdabot>  Just 20
14:18:51 <zennist> finally works
14:18:59 <benzrf> does that follow the iso laws
14:19:09 <guest36246> Cale, thank you! how did you find that tho? i tried searching Hoogle for ":=" but it came out empty
14:19:13 <benzrf> fyi, there's #haskell-lens
14:19:24 <benzrf> guest36246: hoogle doesnt know about everything on hackage
14:19:36 <benzrf> or, uh, maybe it does - im not sure >.>
14:19:37 <zennist> I think it should follow
14:19:58 <zennist> cool - didn't know that channel; guess it warrants its own channel after all!
14:20:00 <Cale> guest36246: I searched hackage for llvm, and since llvm-general's index didn't turn up anything, I tried the next package.
14:20:55 <guest36246> Cale, but the search results for ":=" always come out empty
14:20:59 <Cale> http://hackage.haskell.org/packages/search?terms=llvm -> http://hackage.haskell.org/package/llvm-general-pure -> http://hackage.haskell.org/package/llvm-general-pure-3.5.1.0/docs/LLVM-General-AST.html -> http://hackage.haskell.org/package/llvm-general-pure-3.5.1.0/docs/doc-index.html -> http://hackage.haskell.org/package/llvm-general-pure-3.5.1.0/docs/doc-index-58.html
14:21:01 <guest36246> did u do some fancy escaping or something?
14:21:27 <guest36246> ah the doc index, got it 
14:21:29 <guest36246> thanks!
14:23:43 <schell> anyone have a quick Attoparsec parser (ByteString.Char8) that consumes input until the end of a line? 
14:25:32 <tommd> schell: Does takeWhile (/= '\n') not cut it?
14:26:43 <monochrom> it loses the suffix. but then span will solve that.
14:27:05 <monochrom> oh! Haskell Platform tarball has grown to 260MB?!
14:27:05 <schell> tommd: i guess that would work
14:27:09 <schell> thanks
14:27:40 <schell> i was thinking in terms of endOfLine and isEndOfLine - i guess it threw me off 
14:28:13 * hackagebot rose-trees 0.0.4 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.4 (athanclark)
14:28:19 <monochrom> does attoparsec have a "manyTill"? that would do it too.
14:29:04 <monochrom> it does. you can consider it.
14:29:09 <hpc> it's in the parsers package anyway
14:29:24 <hpc> so attoparsec would necessarily have it
14:29:30 <schell> monochrom: it does, and i tried that - though it gives you back a String, not a ByteString
14:29:33 <monochrom> if you will process the suffix within attoparsec, then manyTill will help
14:29:41 <schell> i’m just nitpicky
14:30:05 <schell> i ended up with takeTill (== ‘\n’)
14:30:29 <monochrom> oh, takeTill looks better type-wise, yeah
14:30:46 <monochrom> wouldn't want [Word8] which defeats the point of ByteStringing
14:31:56 <Profpatsch> let x = return () :: StateT Int [] ()
14:32:16 <Profpatsch> Can I express the type of x with a MonadState restriction type signature?
14:32:38 <monochrom> @type state
14:32:39 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:33:05 <monochrom> MonadState s Int => m ()
14:33:28 <monochrom> need FlexibleContext (sp?)
14:34:01 <Profpatsch> But that’s not the type of x, is it?
14:34:13 <Profpatsch> x is already specified to []
14:34:43 <monochrom> your requirement is self-contradictory. cannot both generalize to MonadState and still mention [] somewhere.
14:34:59 <monochrom> please redesign a satisfiable requirement.
14:35:02 <Profpatsch> Hm, okay.
14:35:32 <monochrom> @type lift
14:35:33 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:36:27 <Profpatsch> I’m trying to find out whether I want my functions to return State, StateT or MonadState =>
14:37:04 <Profpatsch> Is there a rule of thumb?
14:37:24 <monochrom> soul-searching for what you want is a journey you have to go through yourself. no one else can help.
14:37:41 <dmj> Profpatsch: in general, programming against abstractions is better than concretions. MonadState would be usable with both State, StateT, etc.
14:37:47 <hpc> my rule of thumb is as long as the types work do whatever
14:37:48 <monochrom> but meanwhile, deleting all type sigs can achieve letting the compiler tell you what your code is really capable of
14:37:55 <Profpatsch> Or is this the same problem of „should I use an Int or a =>”
14:38:00 <athan> monochrom: I'd conjecture that inspiration helps!
14:38:07 <dmj`> athan: o/
14:38:08 <monochrom> delete all type sigs. unleash your code!
14:38:10 <hpc> ghc takes care of things pretty well at the type level, and just pay attention at the value level yourself for when things get too disorganized
14:38:30 <athan> sup dmj`!
14:39:00 <Profpatsch> hpc: So more specific to get good types and then loosen it up when I need more?
14:39:17 <Profpatsch> *good types as in easy to read type errors
14:39:50 <hpc> yeah, that should work to start with
14:40:33 <Profpatsch> As long as only I have to use the code. :)
14:43:13 * hackagebot rose-trees 0.0.4.1 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.4.1 (athanclark)
14:43:15 * hackagebot octane 0.8.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.8.0 (fozworth)
14:48:13 * hackagebot poppler 0.14.0 - Binding to the Poppler.  https://hackage.haskell.org/package/poppler-0.14.0 (IanWooKim)
15:16:12 <rgrinberg> is parsec/attoparsec as powerful as PEG parsers?
15:16:29 <monochrom> yes
15:16:43 <Cale> It ought to be a little stronger
15:16:48 <rgrinberg> monochrom: is it exactly the same power wise?
15:16:50 <monochrom> in fact they can do context-sensitive grammars too
15:16:59 <monochrom> no, PEG is limited
15:17:19 <monochrom> to be fair, PEG is limited for good purposes, and sometimes you want its simplicity
15:17:32 <monochrom> in fact, usually you want its simplicity
15:19:06 <rgrinberg> what about performance? PEG is always linear AFAIK. Are there such guarantees for parsec?
15:21:25 <glguy> There are no guarantees for Parsec, it runs as fast or slowly as the grammar you write in it
15:21:30 <glguy> varies by how much backtracking you use
15:21:54 <glguy> If you can factor your grammar not to need backtracking, it won't
15:22:03 <slack1256> is www.yesodweb.com down or is just me?
15:22:11 <rgrinberg> glguy: so if there's no backtracking then it would be linear. correct?
15:22:13 <M-Magnap2> isup.me
15:22:20 <monochrom> with less limitation comes less responsibility
15:23:04 <monochrom> but it is certainly true that: for every complexity class, there is a parsec algorithm in that class
15:23:48 <slack1256> checked with isup.me, still can't connect to them. Currently viewing the yesod book from the internet archive
15:24:09 <glguy> rgrinberg: as long as you don't do any non-linear computation along the way, then it will be linear
15:24:18 <glguy> parsec allows you to intersperse arbitrary computation into your parsing
15:24:56 <M-Magnap2> slack1256: it's down for me, which isup.me agrees with, no?
15:25:49 <slack1256> nop, it says is just me
15:26:06 <slack1256> it isn't a 404 though, is it a connection reset
15:28:01 <monochrom> dear slack1256, I got "this site can't be reached. the connection was reset.", says Chrome.
15:28:50 <slack1256> thanks for confirmation
15:29:02 <monochrom> rgrinberg: you're looking at two opposite cultures of parsing, one of Haskell people, the other of imperative people.
15:32:31 <Zemyla> monochrom: I'm honestly curious what you mean by that.
15:32:32 <monochrom> about the imperative people, their languages are too cumbersome for writing parsers at a whim, so they prefer to settle on a restricted class such as regex or PEG, write a grammar in a string, then send the string to one single function written by someone very clever so that no one else needs to worry about how parsers look like
15:33:39 <EvanR> i see imperative people
15:33:59 <rgrinberg> monochrom: it's a bit more than that no? parsers written in such DSL's can perhaps have more opportunities for optimization
15:34:07 <rgrinberg> ragel seems like a good example of that
15:34:46 <monochrom> on the other hand, about the Haskell people, their language is highly amenable to providing various bits of a parser as simply a suite of library functions, so they prefer to use such a library and compose its functions in whatever way possible. plus, they disdain string representations of grammars; code is more structured than string.
15:35:53 <glguy> I certainly prefer using happy to parsec when I have a choice between the two
15:35:58 <TheMystic> monochrom: I know of at least one example of a TDOP parser implemented in python, whose grammars are a list of tuples.
15:36:37 <Zemyla> glguy: I think, if its internals didn't feel so clumsy, I would prefer Earley.
15:36:39 <EvanR> its true parsec is one of these things that is clearly more awesome than equivalents in C, yet gets not as much attention as say something like "monads". and you cant just go around telling people this fact
15:36:52 <EvanR> s/parsec/combinator parsing/
15:37:23 <monochrom> EvanR, my monad training became complete when I read the parser combinator paper
15:37:26 <EvanR> so we have to wallow in our alien technology in silence
15:37:32 <glguy> I find that parsec obfuscates the grammar after you massage it to fit into parsec and that parsec implementations tend to do more than parsing while parsing
15:37:40 <glguy> which hides the actual language being parsed
15:37:47 <TheMystic> monochrom: got a link? I've not read the actual paper
15:37:48 <Zemyla> It's combinator parsing that gets optimized to a polynomial-time parser.
15:38:06 <EvanR> whatever you call this thing
15:38:13 <EvanR> parser combinators
15:38:24 <monochrom> TheMystic: http://www.cs.nott.ac.uk/~pszgmh/bib.html#monparsing
15:39:00 <TheMystic> monochrom: thanks!
15:39:33 <monochrom> so the two monad tutorials I used were Phil Wadler's tutorial followed by parser combinators
15:39:46 <rgrinberg> glguy: one nice thing that attoparsec (perhaps parsec as well?) supports is that it works on partial input
15:39:55 <rgrinberg> I don't know about happy but a lot of parser generators don't suppor that :/
15:41:02 <monochrom> there is a way you can use ContT and/or ParsecT to accomplish partial input. http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro
15:42:45 <glguy_> Rgrinberg: happy will generate a parser running in an arbitrary monad, so you can run the generated parser in something like pipes or machines if you wanted
15:43:10 <glguy_> And build chunk-wise parsing that way, at least
15:46:07 <Zemyla> My only problem with Earley is that it requires you to specify the rules in a special monad so you can have recursive rules without having to detect loops somehow.
15:46:22 <EvanR> ew
15:46:34 <Profpatsch> monochrom: Phil Wadler’s '91 tutorial is probably the best one out there.
15:46:52 <monochrom> yeah!
15:47:50 <Profpatsch> Sadly, I only found it a few days ago, after having learned stuff the hard way.
15:48:09 <EvanR> Profpatsch: whats that called
15:48:39 <Profpatsch> wadler92essence_of_PF.pdf. :P
15:48:48 <Profpatsch> The Essence of Functional Programming.
15:49:10 <Profpatsch> Which is quite a misleading title iyam.
15:49:25 <monochrom> :)
15:50:20 <EvanR> chrome refuses to google that filename
15:50:52 <Profpatsch> http://www.eliza.ch/doc/wadler92essence_of_FP.pdf
15:51:00 <Profpatsch> Search: https://scholar.google.de/scholar?hl=en&q=essence+of+functional+programming&btnG=&as_sdt=1%2C5&as_sdtp=
15:51:23 <Profpatsch> Directly followed by Generalising monads to arrows in the Scholar search. oO
15:52:59 * EvanR scans wadler92essence_of_FP.pdf for curious analogies of what monads are like
15:53:20 <Profpatsch> You won’t find any, it’s quite superb.
15:53:26 <Profpatsch> Right to the essence of things.
15:53:35 <monochrom> at most you'll find "it's like functional programming"
15:53:36 <EvanR> arrows are more general? doesnt sound right
15:53:49 <dolio> Arrows are monads.
15:53:57 <Profpatsch> There’s also a '95 paper that seems to expand on the '92 one.
15:53:58 <EvanR> eh?
15:53:59 <Profpatsch> http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
15:54:14 <Profpatsch> Isn’t ArrowApply equal to Monad?
15:54:50 <EvanR> so Arrow implies more than just Arrow class
15:54:51 <dolio> There's a category with categories as objects, and profunctors as arrows.
15:54:54 <Profpatsch> Ah, it also has a “Parsers” section.
15:55:13 <dolio> Profunctor composition forms a monoidal structure, with unit (->).
15:55:43 <Profpatsch> Now that’s what I call abstract nonesense. :)
15:55:47 <dolio> And arrows are monoids for that monoidal structure.
15:56:24 <dolio> Just like monads are monoids with the case where instead of profunctors you have functors, and instead of (->) you have identity.
15:56:29 <EvanR> is all this what "\"Arrow\"" is referring to? 
15:57:08 <dolio> No, Arrow is just a name the creator made up.
15:57:12 <EvanR> oh
15:57:19 <codygman> I'm trying to make a ModuleString, here is how ModuleString is defined: newtype ModuleString = ModuleString { getModuleString :: String }
15:57:26 <dolio> Because profunctors have covariant and contravariant parts, like functions, I expect.
15:58:01 <dolio> Arrows are actually not just monads for that structure, they're fancy monads, because of all the `first` `second` etc. stuff.
15:58:20 <Zemyla> Technically speaking, arrows are Strong Categories.
15:58:26 <dolio> But `arr` and composition are the monad parts.
15:58:47 <Zemyla> Arrows are weaker than Monads.
15:58:56 <EvanR> i see
15:58:56 <dolio> You haven't been listening.
15:59:08 * EvanR see two parallel conversions about to collide ;)
15:59:18 <EvanR> the streams have crossed
16:00:22 <Profpatsch> inb4 someone tells us streaming libraries are only arrows.
16:00:28 <EvanR> Arrow and Monad class seem to be orthogonal, though apparently one is an instance of the other in category theory
16:01:12 <dolio> Well, lots of things are monads.
16:01:19 <dolio> Like, all monoids.
16:34:30 <tolt> Any idea for an in memory bound log-like structure?
16:35:31 <simpson> tolt: I'm not sure I understand. IIRC prefix tries tend to O(log n) space for n entries, though.
16:36:08 <simpson> Er, "prefix trie" being a data structure. English was not kind to the word "trie".
16:38:16 <tolt> simpson: I was very confused. That makes sense now. I'll look into it
16:42:55 <simpson> tolt: I still don't understand your original query, though. Sorry.
16:43:14 <tolt> I'm looking for a mutable structure that acts like a rotating log
16:43:56 <tolt> But the actions on the log would allow you to write the logs that get flushed out somewhere
16:46:24 <jmcarthur> I don't really understand either. Are you looking for something to help with logging? Does it need to be able to write to disk? What kind of guarantees are you looking for? Why is its in-memory representation important to you?
16:47:49 <simpson> tolt: Oh! I've seen *exactly* this before!
16:48:05 <simpson> tolt: It's called an *inigo*. There's a fancier more precise name, but I like this one. It's catchy.
16:49:09 <simpson> tolt: It's a standard ring buffer, except it *summarizes* different bits of history, on an exponential scale, so that linear increases in space cause exponential increases in the amount of history stored.
16:50:08 <simpson> Here's a big outline of the concept: https://awelonblue.wordpress.com/2013/01/24/exponential-decay-of-history-improved/
16:50:32 <simpson> If you can read Python, a Python version is here: https://github.com/MostAwesomeDude/inigo/blob/master/inigo.py
16:50:42 <tolt> simpson: awesome! Thanks
16:50:43 <simpson> I haven't written the Haskell version; I'm sure that somebody else has, though.
16:51:08 <tolt> jmcarthur: I was specifying in memory because I have found a lot of rotating file things
16:53:19 * hackagebot pipes-text 0.0.2.4 - properly streaming text  https://hackage.haskell.org/package/pipes-text-0.0.2.4 (MichaelThompson)
16:58:54 <tpierson> Does anyone have any experience building llvm from source and using it with llvm-general or llvm-pure using stack?  I can't seem to get those pacakages to find my shared llvm build.
18:04:57 <koz_> Is there any way to tell *which* sparks fizzle in a parallel Haskell program? I'm having trouble figuring out where I'm over-sparking.
18:07:57 <jmcarthur> koz_: Maybe you could use Debug.Trace to help?
18:08:29 <jmcarthur> koz_: It'll slow things down and probably interfere with results, but maybe depending on what you're doing it will still be okay.
18:09:05 <koz_> jmcarthur: I'm not sure how I could use Debug.Trace to determine which sparks fizzle.
18:09:27 <koz_> I could see what's getting sparked when, I guess, but I dunno how that'd inform me if a spark fizzles or not.
18:09:28 <jmcarthur> koz_: If you print something in every spark, you just see which ones *didn't* print.
18:11:21 <koz_> jmcarthur: That's a bit hard to do, considering that fizzled sparks are evaluated anyway: https://wiki.haskell.org/wikiupload/0/09/Spark-lifecycle.png
18:11:27 <Zemyla> I need to figire out a way to use something like applicative-regex, compile a regex, and then turn it into a Parsec parser.
18:11:44 <koz_> But I think Threadscope can do what I need it to do.
18:11:45 <jmcarthur> koz_: You could arrange for the print to happen only when the *result* of the spark is used.
18:11:54 <Zemyla> As if to say "This part is linear and can be matched without backtracking".
18:11:54 <jmcarthur> Hmm
18:12:00 <jmcarthur> Actually, not sure how to arrange that
18:12:36 <koz_> jmcarthur: Never mind - Threadscope can give me this info it turns out.
18:12:42 <jmcarthur> Nice
18:13:03 <koz_> If I install something like Threadscope (makes an executable) in a cabal sandbox, how would I execute it?
18:15:26 <koz_> Would it be 'cabal exec threadscope' or something?
18:15:50 <geekosaur> yes. don't forget to -- if it takes parameters
18:15:56 <geekosaur> cabal exec -- threadscope ...
18:16:07 <geekosaur> (otherwise cabal exec eats the options)
18:16:18 <koz_> geekosaur: OK, thanks!
18:16:19 <geekosaur> ("yay" gnu-style option parsing)
18:16:38 <koz_> I've already managed to parallel-out a 40% increase in speed, which is nice.
18:16:53 <koz_> Now I just wanna bring the fizzle-rate down.
18:17:09 <Paracompact> Dang, I forget, isn't there a prelude function for \x -> [1..x] ?
18:17:41 <Paracompact> Or maybe \x y -> [x..y]
18:17:54 <shachaf> @pl \x -> [1..x]
18:17:54 <lambdabot> enumFromTo 1
18:18:04 <Paracompact> Thanks
18:23:43 <codygman> Why does ghc-mod's module declaration here export its own module: https://github.com/DanielG/ghc-mod/blob/c925e920a0b913d0c93f1400e416312bc73fcc14/Language/Haskell/GhcMod/Types.hs#L6
18:26:57 <geekosaur> so it can export names imported from other modules without having to also list every name it defines as exported
18:27:36 <geekosaur> those threee other names are from: import GHC (ModuleName, moduleNameString, mkModuleName)
18:28:23 * hackagebot th-data-compat 0.0.2.1 - Compatibility for data definition template of TH  https://hackage.haskell.org/package/th-data-compat-0.0.2.1 (KeiHibino)
18:36:12 <jmcarthur> One downside to stack is it's putting more pressure on me to get a bigger hard drive.
19:05:47 <athan> I have this feeling that effects and exceptions are somehow related
19:06:16 <athan> like how the exceptions package achieves extensible exceptions, I'm wondering how it could relate to effects
19:10:40 <sgronblo> Is there no [a] -> Int -> Maybe a?
19:10:48 <jmcarthur> athan: You may be interested in algebraic effects.
19:11:15 <athan> sgronblo: Check out the safe library
19:11:20 <athan> thanks jmcarthur!
19:11:25 <sgronblo> athan: ah yeah i just noticed that in hayoo
19:19:00 <doomlord> what are records like in haskell these days
19:20:37 <geekosaur> mostly the same. ghc8.0.1 has the first step toward a new record system
19:26:01 <coppro> what is it?
19:28:12 <geekosaur> DuplicateRecordFields https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields
19:29:27 <geekosaur> which is supposed to eventually lead to https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
19:31:52 <coppro> ahhh... the use of fake typeclasses is why it can safely do overloading, right?
19:33:46 <geekosaur> yes
19:34:21 <geekosaur> because it becomes a type level question which the constraint solver can deal with
19:43:27 * hackagebot hOpenPGP 2.5 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5 (ClintAdams)
19:51:23 <sgronblo> Does my understanding sound correct? A SomethingT allows me to wrap a Something monad inside of another monad. And the SomethingT's >>= will allow me to bind according to the binding logic for Something?
19:53:54 <Zemyla> Is there any type that can be a Read but not a Show?
19:56:18 <athan> Zemyla: ...an existentially quantified one?
19:56:21 <drostie> Zemyla: functions?
19:56:33 <drostie> like, lambda-functions
19:57:15 <Zemyla> Yeah, makes sense.
19:58:46 <sgronblo> And I can read something like MaybeT IO String as "An IO computation that returns a Maybe String", right?
20:02:07 <drostie> sgronblo: Yep, newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}
20:02:32 <drostie> sgronblo: the IO gets wrapped around the Maybe, so it's "a program which returns either Nothing or a Just String."
20:03:19 <dmj`> sgronblo: so specialized, runMaybeT :: MaybeT IO String -> IO (Maybe String)
20:12:29 <pikajude> > runMaybeT @IO
20:12:30 <lambdabot>      Pattern syntax in expression context: runMaybeT@IO
20:12:33 <pikajude> rats
21:39:23 <athan> What would you call a "percentage", where it's signed, and forms a monoid over multiplication?
21:41:10 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
21:41:10 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
21:41:10 --- names: list (clog rydgel DavidGuru dsm Oliphaunte Squarism GenericUsername athan hamid Guest32446 rnons xtreak jsmnsr jmcarthur readmore xiinotulp FreeBirdLjj jrajav quark[0] howdoi hk238 otto_s doomlord vin-ivar justanotheruser rrradical Sixmsj montagy BlueRavenGT bjz Keiko predator117 hexagoxel exferenceBot lspitzner armyriad guruguru glguy` pfurla asthasr Sorella watabou ao2 kunaaljain_ hamishmack phanimah1sh ype nomotif MorpheusB tgeeky echo-area TxmszLou garrydanger)
21:41:10 --- names: list (AustinMatherne hucksy_ cyphase vili_ yfeldblum rgrinberg tessier edsko pseudo-sue darkbolt wolfcub herzmeister cpup drostie Coldblackice dkasak phileas andyhuzhill nilminus seangrove Kristler der-landgraf paul0 binaryplease tripped ali_bush markus1199 NeverDie riscool cxccxcxcxcv montanonic vic_ eL_Bart0 pgiarrusso_ Guest26324 nakal_ prannayk rekahsoft codygman pavonia conal Xal dgpratt fkurkowski Argue edwinvdgraaf aaronm04 Jinxit ircshans danpalmer Akahige)
21:41:10 --- names: list (lukke100 Moyst epitron thunderrd_ augur xanadu_ nshepperd obadz lambda-11235 whaletechno xvilka desophos hausdorff xkapastel Deadhand darkf dolio systemfault mkloczko jbalint GGMethos sdothum Voldenet Zekka nont_ __name__ king_jah ClaudiusMaximus zariuq urodna mada Mikasa- thetallguy glguy dan_f Goplat Lokathor codesoup Black-Wolf prophile Nycatelos verement slackircbot tek0 Arxenix fengshaun AntiSpamMeta kjanosz jonassa hiptobecubic warc jophish__ docnvk)
21:41:10 --- names: list (dschoepe eyck Sonmi whiteline kritzcreek nikolaMilj2 dmwit_ Mon_Ouie reynir Azel acertain Taylor a3Dman erikd Jonno_FTW hackagebot albel727 spion mfukar araujo_ Meow-J netsin dibblego monochrom kmelva benl23 Lord_of_Life impure_hate shadowdaemon drbean_ |2321 Swizec obihann ormaaj MichaelBurge jhinkle MoALTz steshaw dogui chlong joeyh linduxed Nik05 khumba statusbot CaptainLex Sgeo_ PlasmaStar benwbooth knutstrut canta Rotaerk xplat eldon alunduil Orion3k)
21:41:10 --- names: list (shafox h3nnn4n kosorith alx741 M-Magnap2 bus000 rjnw Sornaensis Yuras tobiasBora vqrs cnr jotrk aseidl niteria Intensity Guest58814 nidr0x dud` Guest21 emmanuel_erc raek ekr_ seraphime pavlicek ollef VsyachePuz hbar_ Sonderblade lsep rossberg TheVoid rmk0 mceier bergey petermw jokleinn1 leadingthenet dsantiago kav Sose nathanic themagician Skuzzzy schjetne Uakh jud magthe xinming sujeet acowley akfp Shou rainbyte magicman liyang elementalest sevas OnkelTem)
21:41:10 --- names: list (chrisdotcode godel mak` rhovland coeus_ mero cjay mbrcknl chriswk mankyKitty zero7 yminsky bigs henriquev zpconn__________ joedevivo hansihe wyvern sewilton carter xplat|work loopspace Tritlo jroesch_ shennyg briansmith lancetw si14 Xorlev reem OliPicard wizonesolutions fuziontech etcinit aphprentice mpickering cbm80 shelling__ S11001001 rfw pchiusano jo`ve LordDeath scinawa martingale acro fangs124 marsam shymega mauke Eiam jorendorff_ byorgey ninegrid stiell)
21:41:10 --- names: list (cogrendel caw guampa sephiap zmanian__ erzar_ louispan bgyss zrl_ swilsonau mdarse heurist jfokkan__ pootler_ beckyconning_ s4msung ericbmerritt alphonse23_ nekomune CARAM__ happy0 cstrahan radge___ saurik jonrh tjpeden nurupo mounty thoughtpolice sanika dca mosh M-ou-se chris2 jtcs koz_ drewdavis ph88_ vlopez robogoat bluezone Natch coppro noexcept reuben364 moredhel shellyssh BrianHV pgiarrusso iross Wamanuz brezel amiri akermu cchalmers lanodan mmaruseacph2)
21:41:10 --- names: list (Sigyn iphy zoran119_ isocliff absence RazorX moei Freundlich tommd dstockwell jlyndon trevorriles kungp condy paf31_ NemesisD mvr_ tarcwynne_ spinda solidsnack JackMc ggherdov katymoe Guest34040 vikram_________ bedouin Scorchin ryoia fabianvf strmpnk etrepum Flaeme MorTal1ty codedmart parsnip mkurkov ryanpcmcquen kipd AlainODea M-radix bitonic spicydonuts ocharles gornikm sclv phuu lexi-lambda ajmccluskey askarpo johtso {AS} nkpart FMJaguar marcel dkua avdi)
21:41:10 --- names: list (weekend_Nolrai razi1 bkonkle nyandoge andreypopp jmct stephe_ tomus rstone milessabin mno2 incomprehensibly angular_mike harmchop seanparsons TabAtkins sisir__ zph_ ikke amatecha tomku tinkyholloway MindlessDrone codebam marmalodak pikajude cosban asjo timrs2998 amuck bluepixel dxld Didac Enigmagic Johannes13_ wolfcore hiratara avn Brando753-o_O_o Nivim Philonous idev m1dnight_ cods tristero fractalcat ipuustin alevy keix amf mimi_vx Ravana texasmynsted r143552)
21:41:10 --- names: list (noraesae burp arcetera mjo rembo10 zerokarmaleft kmicu Tristan-Speccy Khisanth ljhms aatxe dario Hakey qnikst Tene ByronJohnson Jaak aplund moop totte kr36 kosmikus levi gnusosa fyolnish lachenmayer t0m0 davean CurryWurst atomi crodjer m0rphism bydo Shandy pelegreno Cale Blkt imalsogreg joehillen Qommand0r pikhq nexraf pikpok Pastaf yusukesuzuki brixen shwouchk DigitalKiwi bitemyapp zaquest _6a68 Bane^ chattered M-krsiehl M-Illandan M-mistake M-david M-davidar)
21:41:10 --- names: list (M-schmittlauch _kit_ M-Quora jcreekmore kfpratt Myrl-saki zos case39 Kneiva Amnez777 sword_smith kakos shesek dpower pyon tdammers electrostat OutlawStar toon cross ploop cdk minsky mrowe MK_FG Adios fr33domlover bsamorim JPohlmann miklcct rotty zudov Ralith_ greeny sm potatoe Deewiant codebje Raynes simony watersoul sqrt2 iliastsi banjiewen joshc stelleg josephle prooftechnique machinedgod Ranhir rodlogic Ashy Majiir ortmage garphy`aw opios andyo besenwesen)
21:41:10 --- names: list (LnL t0mb0_ solatis lokien jameseb tekacs LiaoTao fryguybob APic _ashbreeze_ Fubar^ Vq spaceships nick123_ danieli samgd mirsal rockfruit Tesseraction_d ahihi jdt tusj chrzyki gothos bencryption slick Reda catsup Nahra tsou ChongLi thalleralexander wilx Princess17b29a killtheliterate alanz sLite SuperTux88 cbaines raid minad codehero usr nemesit|znc krgn jnoah SoupEvil lambdabot joncfoo felher nille jknick TRManderson ppnkk Internet13 lpsmith adamCS karls luzie)
21:41:10 --- names: list (strixy Xe squisher SegFaultAX gracjan nisstyre haasn divVerent nak nathyong xa0 Cerise anders0 greymalkin nitrix Edoxile Guest31006 mudfog_ SaidinWoT pmade ggVGc janne- barrucadu funfun_ jtobin_ spwhitt_ stevenxl M2tias horatiohb jrslepak Ezku_ kuno erg osfameron jackhill ent XMunkki_ phadej Quintasan Walther kjnilsson Jaxan_ valdyn brt1 integral Dykam_ bizarrefish bwe frelux brolin_empey micmus LoganG stass sz0 gienah shirt wedens Igloo bjs cdidd omgfrak)
21:41:10 --- names: list (cyberlard platz Thulsadum Eagle_Erwin hpc RGamma dtulig jle` darxun dalmahal tlevine mrkrwtsn infinity0 Xack croben sleblanc arw CosmicRay hive-mind trevorb demize Arch-TK abra0 DDR richi235 Athas truncate gseitz Frankablu mnoonan bbee dgonyeo jcp emiliocobos dwynwen_ddlleyw YP-Cloud__ qguv pkogan_ pdgwien max-m yaknyasn stasku____ nbouscal aristid cin ircbrowse nyuszika7h x1n4u fall_ abbe japesinator vpm froztbyte benjamincrom Gothmog_ Purlox zeroskillor davl)
21:41:10 --- names: list (spacebug_ dustinm` int-e rofer _flow_ asm89 mt geekosaur tortal majoh lassulus okek cocreature nesqi borkdude zzz_nek0 hyPiRion defanor stqism keteim [BNC]clion Saizan_ hanDerPe1er Liskni_si omilu_ lieven sbauman hc Simsonsan georgew BrAsS_mOnKeY Guest3280 yorick kyagrd monad_cat benonsoftware runeks robertk staticfox inr_ flux cjwelborn daph WizJin jgertm gauge keemyb Tinchos metaf5 dju Rodya Maerten dixie libreman noam emmflo Soft ninedotnine etabot l3france)
21:41:10 --- names: list (zyla naudiz trajing jessicah shans_ dpn` PotatoGim coddinkn BlackYoup chishiki bgamari hegge kantokomi mitch_ andrewsw derpderp eddsteel bwbaugh jeyraof thomie robot cgfbee Guest54896 nullfxn tjbp Cetusx mach euphoriaa MitchW sbrg whoops elgot s4kashya carc esssing DustyDin1o Sam_ sizur mattp_ mgaare ramatevish ElderFain ziman ski bartavelle meretrix shutdown_-h_now JRHaigh Paks Ralith Caelum Klumben jcurbo boothead cheater dredozubov ned jix pfoetchen)
21:41:10 --- names: list (mtesseract cic1 oherrala fingerzam1 johnw klugez opqdonut wagle Ariadeno_ Horv alang ireniko xaimus seagreen larsen agrif taruti seliopou Bashmetim wting hydraz wedify Oxyd lucz u-ou hvr suppi earthy bind negatratoron wolf_mozart mek42 shachaf nopf rcsgns Kruppe DrCode tv dqd cmn bcoppens psacrifice srhb shahn dfranke wjm mikeizbicki lin tazjin drdo sunfun pointfree Diabolik schnizzle a6a3uh OH- LeaChim gsingh93 orcus staffehn benzrf lpaste TommyC brennie niko)
21:41:10 --- names: list (jgornick srcerer KeelOfSteel yude da-x Tehnix cYmen sphalerite ManiacTwister obiwahn comboy CindyLinz c-rog nilOps shelf martinbjeldbak sleezd adarqui jrp6 Nimatek capisce Taneb nwf jorj neshmi buoto tippenein solidus-river kloeri RevJohnnyHealey dan64 arrdem Bigcheese cantstanya epta lyxia adamh sinopeus dicioccio phaskell julm edwtjo dcoutts oberstein SolarAquarion xacktm Elsi vigs abh_ Tiktalik Vbitz_ cschneid- acfoltzer Ulrar KorriX_ Cr8 petercommand)
21:41:10 --- names: list (Ferdirand Chousuke ion davidtho1as liif frontendloader squimmy mingc marens ixian dh gregf_ idupree jlengyel zxtx masquerade jlewis zimp1 aleator Hafydd Xnuk eamelink mlhmwglt bounb TheMystic lhynes StoneToad urdh rork polux Plastefuchs IndigoTiger Kavec Morgawr mendez_ RayNbow`TU Raptor8m3 ynyounuo Guest83419 rom1504 betawaffle surtn henrytill kipras tnks przembot dilinger Lutin` hongminhee joeytwiddle thomas Matajon awal Maxdamantus unsymbol mudfog SLi hpd)
21:41:10 --- names: list (otterdam oelewapperke chelfi noplamodo padre_angolano alem0lars mindos_cloud____ irclogger_com peddie TimWolla vikraman jokester Akii Biohazard myfreeweb avocado jstolarek yodeler pyrtsa xnyhps knyppeldynan mikeplus32 kriztw Ke Slush- Eliel_ huonw mephx_ grol_ Ewout ebird monkeyiqde jre2 Amadiro catern jb55 tomjaguarpaw jimki_ quuxman_ sshine PierreM_ angseus_ relrod isomorphismes lokydor mj12` Zemyla siddhu clever tswett averell ao1ei8 zenzike igniting toure)
21:41:10 --- names: list (gridaphobe hjljo dxtr Baughn Geekingfrog marienz Neseth Desoxy jzl __main__ geppettodivacin mrshoe kier parsnipM_ fold4 `0660 funrep thorkilnaur_ d3lxa Yaiyan Axman6 Fylwind mokus ps-auxw SenpaiSilver ricardo82 mitchty andjjj23 bogdanteleaga mathu pranz leftylink pdxleif xxpor tokik newsham xou luite brisbin shapr aweinstock mw Elision marko__ mrd Guest78801 luis wamaral tolt theDon Vivek eyenx lattenwald [swift] worch baweaver Laney lstrano k3d3 swhalen)
21:41:10 --- names: list (cow-orker Clint arianvp hemite bananagram comstar arkeet Reyu quicksilver zuz_ trig-ger crank1988 kini c_wraith chaptastic RageD gpampara joco42_ capicue indiffernet_ bd__ edwardk jrib julmac posco pacak caasih fergusnoble bjobjo ndeine \u gbarboza mjrosenb luigy_ aaron7 zyoung_ freekevin logcat sajith rbocquet obcode kalloc uwap wtw hxegon ski_ Iceland_jack maerwald @ChanServ nxnfufunezn Mandus cjh` n__dles EvanR zopsi pharaun tumdum dunj3 callumacrae)
21:41:10 --- names: list (vodkaInf1rno tsani lispy Factionwars Jello_Raptor MasseR simpson ec\ Belgarion0 ReinH monty Profpatsch fionnan_ fmapE irishsul1an ephemeron rvncerr acomminos Adeon ironChicken Xandaros owa armlesshobo Pucilowski Cathy tomaw Twey guios bernalex ft stux|RC-only octophore qnix tumdedum zomg niluje KaneTW statusfailed robtaylor Ov3rload marmoute pleiosaur tero- hodapp rtur ernst andreass scopedTV mads- ongy glckr_ hiredman zhulikas_ supki SphericalCow kshannon)
21:41:10 --- names: list (gabiruh Watcher7 qz nikola Ankhers Saimeidae noctux kyren Ornedan Rembane jinblack sohum icedev anoe sparr Boreeas sanitypassing joachifm sdboyer BigEndian exio4 sdx23 lyddonb alpounet julienXX stomp Willis skarn cynick optocoup1er mrlase zymurgy jaaket kaol jstimpfl1 notdan yamadapc anachrome sgronblo koomi koala_man __rlp ario ephess_ geal bsermons sellout numberten lukky513 ddima_ maskd friden gargawel jkarni tych0 Atlanis deni tg bergmark karshan knittl)
21:41:10 --- names: list (amontez o`connor lenstr dasmith91 tzaeru DANtheBEASTman liste Erebe gratimax kennyp phz_ lnx PHO sleepynate low-profile yarou ahf honkfestival Drezil yeltzooo Starfire aparent eagleflo jlouis wayne Speed Ring0` so eikke sjl_ carter-znc bshelden quaestor)
21:50:17 <jle`> athan: sounds like just a normal real/rational etc.?
21:54:05 <Squarism> if matching an integer, can i use a range of sorts in a case-of pattern?
21:57:38 <Squarism> oh.. guards i see
22:20:14 <Zemyla> Is there such a thing as a Free MonadFix?
22:20:21 <saurabhnanda> hello good people. Broadcasting my latest Haskell philosophical question here, in case someone can help: http://stackoverflow.com/questions/37770984/does-haskell-have-variables-or-easiest-way-to-read-configuration-data
22:24:59 <athan> Zemyla: You mean a MonadFix instance for an arbitrary Functor f => Free f?
22:25:09 <EvanR> saurabhnanda: i like ENV vars
22:25:43 <saurabhnanda> EvanR: the problem is not ENV vs config file. The problem is using them in Haskell painlessly
22:25:54 <EvanR> you read them at the beginning of IO like you did
22:25:59 <EvanR> but you do not assigned them to a global
22:26:07 <EvanR> just pass them into the program
22:26:10 <EvanR> perhaps using Reader
22:26:36 <Zemyla> athan: Not mecessarily an arbitrary one, but is there a way to choose an f such that there is a MonadFix for Free f?
22:26:39 <EvanR> then you have the possibilities of testing your code
22:26:40 <athan> saurabhnanda: I usually have different parseable options, then turn them into a global type that I stick into a reader
22:26:56 <athan> like one for optparse, one for yaml configs, etc
22:27:07 <EvanR> athan: you cant pass secret keys on the command line (without being obviously insecure)
22:27:40 <athan> Zemyla: IIRC ContT is specifically _not_ MonadFix able for a specific reason, I can't really remember though
22:27:49 <saurabhnanda> EvanR, athan: I'm trying to avoid Reader. Won't that result in changing type signatures at a lot of places?
22:27:49 <athan> have you read the paper "Value Recursion in Monadic Computations"?
22:27:50 <jmcarthur> Zemyla:    newtype FreeMonadFix f a = FreeMonadFix (forall m. MonadFix m => (forall x. f x -> m x) -> m a)
22:28:09 <athan> EvanR: That's why the function is in IO :)
22:28:16 <saurabhnanda> athan: is the paper for me?
22:28:20 <EvanR> saurabhnanda: if you have done much dynamic programming, using ways of "not having to change a lot of code" often results in a disaster after a while
22:28:54 <EvanR> one issue is spooky action at a distance
22:29:01 <Zemyla> jmcarthur: That is the absolute worst free monad implementation. I apologize, but seriously.
22:29:09 <EvanR> something is happening and you have no idea why, because someone didnt want to change the code properly, maybe you
22:29:09 <athan> saurabhnanda: I ran into that too :\ for me, the best thing to do is have one global Env type that packs all my globally needed config data throughout my app
22:29:24 <jmcarthur> Such strong opinions.
22:29:31 <EvanR> saurabhnanda: another issue with this global approach is none of your code is testable as is, it relies on a global and undefined value
22:29:40 <saurabhnanda> athan: which is fine, but how to initialize the global data-structure during app startup?
22:29:54 <EvanR> getEnv
22:29:56 <athan> Here I'll show you my app
22:30:25 <EvanR> somehow taking the config as an argument really is the best practice
22:31:08 <EvanR> this is really what Reader and ReaderT is for
22:31:25 <jmcarthur> Zemyla: Well, what is your criteria for a valid answer?
22:32:10 <athan> sorry this wifi sucks eggs, still loading
22:32:38 <saurabhnanda> EvanR: I'm looking for a pragmatic short cut. The app cannot start without those values. Main can be written to crash if it can't find those config variables. I don't want all the other code to deal with complexities of ReaderT for such a small thing.
22:32:43 <Zemyla> Something which actually offers some theoretical insight on what such a thing might look like.
22:33:12 <athan> ReaderT is actually not too complex
22:33:34 <EvanR> saurabhnanda: you dont have to use ReaderT, just take arguments for things that need it
22:33:42 <athan> given that you have one single source of environment data, and getters into specific parts, then all you need is `myPart <$> ask` to get it arbitrarilly
22:33:44 <EvanR> FP 101
22:34:20 <athan> saurabhnanda: Here's what I consider my effects stack / context to be throughout my app: https://github.com/athanclark/happ-store/blob/master/src/Application/Types.hs#L37
22:34:24 <Zemyla> That solution you posted has neither useful simplicity nor useful complexity.
22:34:25 <EvanR> saurabhnanda: pure code just cant randomly read the env vars whenever it wants to, it wouldnt make sense
22:34:28 <EvanR> welcome to haskell
22:34:30 <jmcarthur> Zemyla: My suggestion at least gives you a starting point to derive something else.
22:34:37 <saurabhnanda> EvanR: even that is problematic. What if the function that actually needs to use those arguments is the lowest level function? Every higher-level function will need it's type-sig modified and will need to pass along those params to the lower-level function.
22:34:49 <athan> And here's my specific environment itself, post options/config/env variable parsing: https://github.com/athanclark/happ-store/blob/master/src/Application/Types.hs#L84 saurabhnanda 
22:35:19 <saurabhnanda> EvanR: I'm trying to NOT get pure code to read the environment, but a pure global Haskell value.
22:35:33 <EvanR> saurabhnanda: im imagining your program as being 1000 functions, and 4 of them needing to be modified to get to the lowest level to read the config
22:35:59 <EvanR> saurabhnanda: if you do that, your code will not be pure anymore
22:36:10 <saurabhnanda> EvanR: as I said, two parts to the question -- pragmatic solution to current problem AND understanding what's the best approach for future.
22:36:19 <saurabhnanda> EvanR: why won't my code be pure?
22:36:22 <EvanR> pragmatic is to pass the config in as a new argument
22:36:42 <EvanR> because it refers to a variable that has no value
22:36:50 <athan> saurabhnanda: Here's how I _build_ an Env, with options and config parsing: https://github.com/athanclark/happ-store/blob/master/main/Main/Options.hs#L122
22:37:03 <EvanR> it auto runs IO code or something whenever you attempt to use it
22:37:04 <athan> specifically this one: https://github.com/athanclark/happ-store/blob/master/main/Main/Options.hs#L175
22:37:07 <saurabhnanda> EvanR: my code is pure and referentially transparent after the app has been started. Once Main sets everything up, nothing changes in global state.
22:37:29 <EvanR> saurabhnanda: the first time anything refers to the global, it will do IO behind the scenes
22:37:31 <athan> EvanR: See! It's in IO! :) https://github.com/athanclark/happ-store/blob/master/main/Main/Options.hs#L183
22:38:11 <EvanR> saurabhnanda: you would probably change less code pass it in as an argument than pulling off a working global variable, which is what youre trying to do
22:38:26 <EvanR> if not, its not that much difference
22:38:40 <EvanR> and the difference will not be worth it
22:39:22 <saurabhnanda> athan: are a lot of functions actions in AppM monad for you?
22:39:22 <EvanR> saurabhnanda: technically speaking, no it wont be "referentially transparent" specifically because of this issue
22:40:01 <EvanR> when you substitute the expression its either broken or it has a value depending on the environment
22:40:40 <EvanR> i dont recommend restructuring the entire app with a global monad, that would definitely be a hassle
22:40:47 <saurabhnanda> EvanR: referential transparency can be lost between different invocations of the entire app. Not within the same running process. Isn't that good enough?
22:41:30 <EvanR> i just dont see the benefit of hacking the runtime to pull this off?
22:42:55 <EvanR> the global variable itself will need special no inline pragmas to avoid creating multiple independent values (in terms of guarantees, which you wont have any of)
22:43:15 <EvanR> if the ENV is modified between those times, youll have the possibility of insanity
22:43:39 <EvanR> its like doing a large script and reading the current time 10 times when you only think its all "happening at the same time"
22:44:26 <EvanR> if you want fast and loose haskell code, next time write the entire app in IO
22:44:53 <EvanR> if you want a simple quick fix, pass the string in as an argument to the function
22:45:03 <EvanR> simple quick, safe, robust, easy to test, fail safe...
22:45:11 <EvanR> generally sane, sensible
22:45:32 <EvanR> consistent, semantically clear
22:45:34 <saurabhnanda> what about this approach? http://hackage.haskell.org/package/seal-module-0.1.0.1/docs/Language-Haskell-SealModule.html
22:45:55 <EvanR> thats a new one
22:46:06 <EvanR> there are various technologies to do implicit parameters
22:46:07 <saurabhnanda> also another idea... global config variables in a global HashMap/Dictionary which is initialised by `main`
22:46:21 <athan> saurabhnanda: MonadApp takes care of the whole context for me, I never really think about AppM until the last minute / in main
22:46:22 <EvanR> but thats just a lot of trouble to just have a param to the functions that need the config
22:46:50 <athan> but MonadApp includes everything I need: exception handling, logging, IO, a weird Url monad I rigged together, all of it
22:46:52 <EvanR> saurabhnanda: ... it requires a noline IO ref
22:47:08 <EvanR> using unsafePerformIO, which you can do, and is just silly from the problem youve described
22:47:09 <saurabhnanda> athan: how does that work? wouldn't everything have to have a return type of AppM
22:47:15 <EvanR> i.e. being too lazy to write normal code
22:47:16 <athan> it's the generic version of all my effects, so in my main codebase I just need `foo :: MonadApp m => m Foo`
22:47:32 <athan> saurabhnanda: You can leave it all generic until `main` :)
22:47:38 <EvanR> youre even entertaining the global App monad... anything to do the easiest solution
22:47:44 <athan> just like how `get :: MonadState s m => m s`
22:47:48 <EvanR> anything to avoid the easiest*
22:48:44 <EvanR> "global variables are bad normally, but in haskell they are really bad"
22:49:10 <saurabhnanda> EvanR athan: is MonadApp something special, or just some monad-transformer stack? Like how SqlPersistT is used for most apps dealing with DB
22:49:25 <EvanR> MyAppMonad
22:49:28 <EvanR> is what hes talking about
22:49:36 <EvanR> you make your own big monad out of parts or directly
22:49:39 <athan> saurabhnanda: Yeah sorry, it's one of the links I sent
22:49:52 <athan> It's not a specific stack, but a combined description of one
22:49:58 <athan> through typeclasses
22:50:00 <saurabhnanda> EvanR: how are they bad? as long as they values are immutable, aren't the manageable? Also, even functions are defined globally.
22:50:18 <EvanR> global mutable variables
22:50:33 <saurabhnanda> EvanR, athan: how about a global HashMap that can be initialise by `main`?
22:50:47 <EvanR> that would require a global mutable variable
22:50:54 <EvanR> and IO to read it
22:51:09 <EvanR> its 10x more engineering than just passing the value in as an argument
22:51:29 <athan> saurabhnanda: Pack that in Env
22:51:30 <saurabhnanda> EvanR: right, so I'm saying that the variable is mutable till BEFORE the real app starts. Immutable afterwards. Is that possible? something like `freeze` in Ruby?
22:51:36 <athan> unless it's supposed to be stateful that is
22:51:38 <EvanR> its not possible
22:52:03 <EvanR> this is not ruby
22:52:04 <athan> EvanR: You could pack the STRef in Env :D
22:52:10 <EvanR> not like that does anything in ruby either
22:52:36 <EvanR> athan: yes, IORefs in a ReaderT works great
22:52:46 <EvanR> not the other way around
22:53:34 <athan> !!! That's an adventure
22:53:43 <EvanR> saurabhnanda: go ahead and put this in your code: toplevel... myCleverVar = unsafePerformIO (getEnv "foo")
22:53:51 <EvanR> and see what happens
22:54:41 <saurabhnanda> :t unsafePerformIO
22:54:42 <lambdabot> Not in scope: ‘unsafePerformIO’
22:54:46 <EvanR> IO a -> a
22:55:10 <saurabhnanda> EvanR: okay. I'm trying to use a global Data.Map.Strict instead right now
22:55:23 <saurabhnanda> EvanR: with the map being constructed BEFORE the real app starts
22:55:25 <EvanR> that wont work
22:56:08 <EvanR> theres no modifyGlobalBindings :: VarName a -> a -> IO ()
22:56:26 <texasmynsted> if I can do this
22:57:05 <texasmynsted> let foo = ['a'..'z'] ++ ['A'..'Z'] ++ foo
22:57:12 <EvanR> if that existed, i quit haskell
22:57:14 <texasmynsted> how do I do decending?
22:57:31 <texasmynsted> ['z'..'a'] does not seem to work
22:57:52 <saurabhnanda> Even Data.Map.Strict is immutable?
22:58:18 <EvanR> you can build as many Maps as you want, you cant assigned to any global names 
22:59:03 <EvanR> variables arent rebindable
22:59:08 <Cale> texasmynsted: ['z','y'..'a'] would work
22:59:38 * texasmynsted tries
22:59:39 <Cale> texasmynsted: But perhaps reverse ['a'..'z'] would be clearer
23:00:15 <texasmynsted> hah
23:00:16 <texasmynsted> ok
23:00:27 <texasmynsted> well this is where I was going
23:00:32 <EvanR> > ['z','x'..'a']
23:00:36 <lambdabot>  "zxvtrpnljhfdb"
23:00:37 <texasmynsted> let bar = ['Z','Y'..'A'] ++ ['z','y'..'a'] ++ bar
23:00:42 <EvanR> how the heck
23:00:43 <texasmynsted> > let bar = ['Z','Y'..'A'] ++ ['z','y'..'a'] ++ bar
23:00:47 <lambdabot>  <no location info>:
23:00:47 <lambdabot>      not an expression: ‘let bar = ['Z','Y'..'A'] ++ ['z','y'..'a'] ++ bar’
23:01:02 <saurabhnanda> why is this not working? let x = empty :: Map String String; x = insert "foo" "bar" x
23:01:11 <saurabhnanda> :t Data.Map.Strict.Map
23:01:13 <lambdabot>     Not in scope: data constructor ‘Data.Map.Strict.Map’
23:01:18 <EvanR> > let x = 1:x in x
23:01:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:01:21 <saurabhnanda> :k Data.Map.Strict.Map
23:01:23 <lambdabot> * -> * -> *
23:01:27 <EvanR> you know let bindings are recursive?
23:01:45 <texasmynsted> > let bar = ['Z','Y'..'A'] ++ ['z','y'..'a'] ++ bar
23:01:46 <lambdabot>  <no location info>:
23:01:46 <lambdabot>      not an expression: ‘let bar = ['Z','Y'..'A'] ++ ['z','y'..'a'] ++ bar’
23:01:53 <saurabhnanda> > let x = empty :: Data.Map.Strict.Map String String; x = insert "foo" "bar" x
23:01:55 <lambdabot>  <no location info>:
23:01:55 <lambdabot>      not an expression: ‘let x = empty :: Data.Map.Strict.Map String String; ...
23:02:03 <texasmynsted> hmm.  I can do that in ghci why not the lambdabot?
23:02:19 <saurabhnanda> aargh
23:02:32 <EvanR> saurabhnanda: you cant bind x twice in same block with two different things?
23:02:40 <EvanR> sorry that should be no ?
23:03:19 <EvanR> are you following a guide somewhere on haskell?
23:04:54 <saurabhnanda> EvanR: is that for me? 
23:04:57 <saurabhnanda> EvanR: guide?
23:05:09 <EvanR> saurabhnanda: http://lpaste.net/165813
23:08:36 * hackagebot asn1-encoding 0.9.4 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-encoding-0.9.4 (VincentHanquez)
23:09:23 <saurabhnanda> EvanR: right, got that. realised that I can't cheat by moving things into a data-structure. Even that is immutable. The same why x=x+1 won't work in haskell, is the same reason why mutating a map won't work.
23:10:29 <texasmynsted> why would you want a mutable data structure?
23:11:18 <EvanR> they dont want a mutable data structure they want a mutable global variable
23:11:42 <texasmynsted> like a reader monad?
23:11:48 <EvanR> to avoid passing an argument into a function that needs it
23:11:51 <saurabhnanda> texasmynsted: context -- http://stackoverflow.com/questions/37770984/does-haskell-have-variables-or-easiest-way-to-read-configuration-data
23:11:52 <texasmynsted> oh mutable global?
23:12:00 <saurabhnanda> texasmynsted: immutable global
23:12:20 <EvanR> myGlobal = unsafePerformIO (getEnv "yoohoo")
23:12:25 <texasmynsted> reader monad would be fine for immutable global, right?
23:12:52 <EvanR> rewriting the code to be in a Reader would take as much work or more than just passing it in
23:13:06 <saurabhnanda> --- approach changed
23:13:29 <texasmynsted> sounds like work that needs to be done
23:13:37 * hackagebot gi-atk 2.0.5 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.5 (inaki)
23:13:39 * hackagebot gi-cairo 1.0.5 - Cairo bindings  https://hackage.haskell.org/package/gi-cairo-1.0.5 (inaki)
23:13:41 * hackagebot gi-gdk 3.0.5 - Gdk bindings  https://hackage.haskell.org/package/gi-gdk-3.0.5 (inaki)
23:13:43 * hackagebot gi-gdkpixbuf 2.0.5 - GdkPixbuf bindings  https://hackage.haskell.org/package/gi-gdkpixbuf-2.0.5 (inaki)
23:13:45 * hackagebot gi-gio 2.0.5 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.5 (inaki)
23:14:50 <saurabhnanda> if SqlPersistT = ReaderT SqlBackend; and NwApp = SqlPersistT IO; and NwApp is my app-wide monad, can I use it for aforementioned config variables?
23:15:06 <saurabhnanda> since it already has a ReaderT embedded in it?
23:15:20 <EvanR> i dont know if you can hijack it for your own purposes
23:15:28 <EvanR> its more proper to wrap yet another ReaderT around it
23:15:33 <EvanR> or under it
23:15:41 <saurabhnanda> but, it's a ReaderT that Persistent needs. 
23:15:50 <EvanR> its being used for internal stuff
23:16:03 <saurabhnanda> EvanR: don't know what the ReaderT is being used for...
23:16:19 <EvanR> i think you almost exhaused every mad science way of doing this
23:16:37 <EvanR> to avoid adding a parameter
23:17:39 <saurabhnanda> ha ha
23:17:58 <saurabhnanda> EvanR: avoid changing function signatures everywhere...
23:18:09 <EvanR> i would be surprised if it was "everywhere"
23:18:25 <EvanR> unless youve structured your code that badly
23:18:47 * hackagebot gi-girepository 1.0.5 - GIRepository (gobject-introspection) bindings  https://hackage.haskell.org/package/gi-girepository-1.0.5 (inaki)
23:18:49 * hackagebot gi-glib 2.0.5 - GLib bindings  https://hackage.haskell.org/package/gi-glib-2.0.5 (inaki)
23:18:51 * hackagebot gi-gobject 2.0.5 - GObject bindings  https://hackage.haskell.org/package/gi-gobject-2.0.5 (inaki)
23:18:53 * hackagebot gi-gst 1.0.5 - GStreamer bindings  https://hackage.haskell.org/package/gi-gst-1.0.5 (inaki)
23:18:55 * hackagebot gi-gstaudio 1.0.5 - GStreamerAudio bindings  https://hackage.haskell.org/package/gi-gstaudio-1.0.5 (inaki)
23:19:05 <EvanR> in which case you might as well finish it off with a myEnv1 = unsafePerformIO (getEnv "myEnv1")
23:23:57 * hackagebot gi-gstbase 1.0.5 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.5 (inaki)
23:23:59 * hackagebot gi-gstvideo 1.0.5 - GStreamerVideo bindings  https://hackage.haskell.org/package/gi-gstvideo-1.0.5 (inaki)
23:24:01 * hackagebot gi-gtk 3.0.5 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.5 (inaki)
23:24:03 * hackagebot gi-gtkosxapplication 2.0.5 - GtkosxApplication bindings  https://hackage.haskell.org/package/gi-gtkosxapplication-2.0.5 (inaki)
23:24:05 * hackagebot gi-gtksource 3.0.5 - GtkSource bindings  https://hackage.haskell.org/package/gi-gtksource-3.0.5 (inaki)
23:28:15 <saurabhnanda> any good ReaderT tutorial?
23:29:07 * hackagebot gi-javascriptcore 3.0.5 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-3.0.5 (inaki)
23:29:09 * hackagebot gi-javascriptcore 4.0.5 - JavaScriptCore bindings  https://hackage.haskell.org/package/gi-javascriptcore-4.0.5 (inaki)
23:29:11 * hackagebot gi-notify 0.7.5 - Libnotify bindings  https://hackage.haskell.org/package/gi-notify-0.7.5 (inaki)
23:29:13 * hackagebot gi-pango 1.0.5 - Pango bindings  https://hackage.haskell.org/package/gi-pango-1.0.5 (inaki)
23:29:15 * hackagebot gi-pangocairo 1.0.5 - PangoCairo bindings  https://hackage.haskell.org/package/gi-pangocairo-1.0.5 (inaki)
23:29:33 <EvanR> note that ReaderT will also require changing signatures, only more drastically
23:30:14 <Zemyla> saurabhnanda: Hmm, what do you mean? ReaderT is one of the simpler monad transformers.
23:30:32 <EvanR> https://carlo-hamalainen.net/blog/2014/3/5/note-to-self-reader-monad-transformer
23:31:16 <saurabhnanda> EvanR: I know, but I think that's a bullet I need to bite. Having an app-wide Monad is a common Haskell pattern, it seems. I ended-up using it for the DB-specific parts of my app. Planning to extend the same monad to the environment specific parts as well. 
23:32:39 <EvanR> in the post i linked, ignore the entire first section it seems to be nonsense
23:33:31 <saurabhnanda> :i ReaderT
23:33:49 <saurabhnanda> :i Control.Monad.Reader.ReaderT
23:34:17 * hackagebot gi-poppler 0.18.5 - Poppler bindings  https://hackage.haskell.org/package/gi-poppler-0.18.5 (inaki)
23:34:19 * hackagebot gi-soup 2.4.5 - Libsoup bindings  https://hackage.haskell.org/package/gi-soup-2.4.5 (inaki)
23:34:21 * hackagebot gi-vte 2.91.5 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.5 (inaki)
23:34:23 * hackagebot gi-webkit2 4.0.5 - WebKit2 bindings  https://hackage.haskell.org/package/gi-webkit2-4.0.5 (inaki)
23:34:25 * hackagebot gi-webkit2webextension 4.0.5 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.5 (inaki)
23:35:04 <EvanR> saurabhnanda: the implementation of ReaderT in real life is kind of irrelevant... you just need to know do notation and then runReaderT
23:35:07 <EvanR> :t runReaderT
23:35:08 <lambdabot> ReaderT r m a -> r -> m a
23:35:44 <EvanR> youd use this as part of your top level runMyApp 
23:38:02 <saurabhnanda> how do I define a ReaderT to represent a String -> String environment?
23:38:50 <saurabhnanda> in ReaderT r m a => 'm' is the 3rd party monad which ReaderT is going to wrap. What is 'r' and 'a'
23:39:27 * hackagebot gi-webkit 3.0.5 - WebKit bindings  https://hackage.haskell.org/package/gi-webkit-3.0.5 (inaki)
23:39:33 <EvanR> r is the environment type
23:40:02 <EvanR> so ReaderT (String -> String) (PersistWhateverT...) MyResultType
23:40:23 <saurabhnanda> EvanR: what does that mean? "environment type"?
23:40:30 <EvanR> :t ask
23:40:31 <lambdabot> MonadReader r m => m r
23:40:35 <EvanR> :t asks
23:40:36 <lambdabot> MonadReader r m => (r -> a) -> m a
23:40:47 <Cale> If your monad is just ReaderT or StateT over IO, and computations in the monad are doing unrestricted IO, I would strongly advise looking for a different solution. IO already has a lot of facilities for keeping track of state, and if you're putting just ReaderT over IO, well, you're trading off passing a parameter for using liftIO everywhere and making it a hassle to forkIO/catch/etc.
23:40:54 <EvanR> when you execute ask, you get the environment
23:41:55 <EvanR> Cale: hes trying to get a global config, not keep state, but your advice still applies probably
23:42:00 <saurabhnanda> Cale: that's what EvanR has been trying to tell me, I guess
23:42:18 <EvanR> and theres already a pile of transformers for the databse
23:42:22 <saurabhnanda> Cale, EvanR: is it better to just create a Map in main and pass it around? and not complicate life
23:42:36 <Cale> saurabhnanda: Yeah, start with just doing that.
23:42:38 <EvanR> not a Map, but a record of your config strings
23:42:45 <EvanR> since you know what the config vars are
23:42:58 <saurabhnanda> EvanR: correct. Because 'lookup' will return a Maybe
23:44:15 <Cale> The really right thing to do is never so obvious that you can just say what it is without thinking really hard about the particulars of what you're doing. But passing an explicit parameter around is never so bad as it might at first seem, and as your project goes on, you can always refactor things -- often you might want to bundle some parameters together into a new data type if you find they're going to all the same p
23:44:15 <Cale> laces in the code.
23:45:52 <saurabhnanda> Cale: EvanR: thanks. let me try to define a record type called MyConfig and put all the stuff there, and pass it around wherever required.
23:45:55 <EvanR> honestly passing an environment in wins just based on the alternatives pain in the ass factor, if nothing else
23:46:22 <liste> with explicit parameter passing you never need to figure out where a value came from
23:47:30 <EvanR> i dont know if this is normal but even in C++ they advised me to pass stuff like this in as a parameter
23:47:39 <EvanR> pass in objects to things that use them
23:48:41 <liste> usually in OO world that kind of stuff is passed via constructors and it's called Dependency Injection
23:49:41 <EvanR> well it should elevated to the level of design pattern because its awesome
23:49:48 <Cale> As far as I can tell, dependency injection seems to just be a very convoluted way of explaining the concept of a function.
23:50:40 <Cale> But yeah, functions are good
23:50:41 <shachaf> Cale: I think it involves more XML than a regular function.
23:50:46 <Cale> lol
23:51:28 <liste> I think it's a more limited form of partial application: "funcThatDoesStuff = funcThatHasDeps dep1 dep2 <=> objThatDoesStuff = new Obj(dep1, dep2)"
23:52:49 <EvanR> maybe there should be a non-joke guide on how to map OO stuff like that to FP
23:53:39 <liste> (the Spring folks ruined a perfectly good name for a simple concept with tons of frameworking and XML)
23:53:45 <EvanR> because its both too obvious to FP people to care, and totally foreign to ground floor OO practitioners
23:56:34 <liste> also that sort of guide would help FP newcomers with design/"programming in the large", which was the hardest part for me at least
23:56:54 <liste> (if they have previous exposition to OO, as many do)
