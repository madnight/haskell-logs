00:15:10 --- mode: verne.freenode.net set +o dcoutts
00:23:51 * hackagebot HPhone 0.0.1.0 - Phone number parser and validator  https://hackage.haskell.org/package/HPhone-0.0.1.0 (vijayanant)
00:40:52 <hc> hi
00:40:57 <hc> about my question from yesterday again...
00:41:16 <hc> i need a data structure for implementing lzh decompression fast
00:41:51 <hc> i need two operations: append single bytes, or copy one or more bytes already on the data structure to the end of the data structure
00:41:59 <hc> is a mutable array the best choice for that?
00:42:07 <hc> (right now, i'm using data.sequenec)
00:42:49 <hc> also, in the end i need to convert the structure to a ByteString. All the elements are of type Word8
00:43:22 <hc> ( the current implementation is here if someone wants to have a look: https://github.com/VirtualForgeGmbH/hascar/blob/master/src/Codec/Archive/SAPCAR/FlatedFile.hs )
00:43:26 <hc> it works but is very slowish
00:43:46 <hc> (the decodeIt function is the important one
00:44:47 <cordova> http://espedito.homepc.it/ onehostx...)
00:52:55 <hc> hmm
00:53:08 <hc> I'm thinking of using an ST array and then using Data.ByteString.Builder to convert it into a ByteString in the end
01:01:08 <Axman6> hc: I attempted to make something similar for decoding lz4 data, IIRC I just did it all in IO, but eventually gave up because the lz4 spec is basically the C implementation, because the documents aren't precise enough
01:01:44 <Axman6> I wanted to be able to emit data in chunks for things like streaming and lazy bytestrings, but it proved too difficult
01:03:53 * hackagebot enclosed-exceptions 1.0.2 - Catching all exceptions from within an enclosed computation  https://hackage.haskell.org/package/enclosed-exceptions-1.0.2 (MichaelSnoyman)
01:03:55 * hackagebot ghcjs-perch 0.3.3 - GHCJS version of Perch library.  https://hackage.haskell.org/package/ghcjs-perch-0.3.3 (geraldus)
01:14:51 <hc> Axman6: sigh, that's probably the case for other compression routines, too.
01:14:58 <hc> Axman6: but imho we need more pure haskell implementations
01:15:15 <hc> even the awesome zip library (the new one with conduits) uses a C implementation of libz
01:16:27 <hc> anyway, I'll try to use STUArray for now
01:32:31 <Axman6> hc: yeah I agree.
01:34:08 <Axman6> hc: I intended to make some kind of monadic interface that could keep track of the current write buffer, and the previously written buffer which would be large enough to copy the maximum distance back the compression scheme allows
01:34:22 <Axman6> so buffers of like 2^16 or something
02:35:04 <RedNifre> If I trade between USD and EUR and I have a `data Order = Order Currency Currency Amount` and a function postOrder order = ... is there a way to express that the Order needs to be about two DIFFERENT currencies i.e. an order that buys dollars for dollars (Order USD USD 1) is invalid? Or do I need Idris for that?
02:37:11 <merijn> RedNifre: You can do it, but it's a bit (not too bad) finnicky and has horrible errors (could be improved using 8.0 but I haven't looked at the custom type errors yet)
02:37:31 <merijn> RedNifre: See my example here: https://gist.github.com/merijn/6130082
02:37:52 <merijn> (It's a bit finnicky if you use polymorphic literals, i.e. numeric literals or OverloadedStrings)
02:38:27 <merijn> Actually, I suppose it could be simpler
02:43:44 <merijn> RedNifre: Something like http://lpaste.net/167410 you'd probably want to use the singletons library to reflect the currencytype back to the value level
03:18:20 <Normen> Why does http://lpaste.net/167412 not type check?
03:20:25 <merijn> Normen: Because the 'b' in the where clause is NOT equal to the 'b' in the top level clause
03:21:11 <tero-> Normen: ScopedTypeVariables and forall a b c d. then it works
03:21:36 <Normen> merijn Why is that?
03:21:36 <merijn> Normen: Type variables aren't scoped over where/let clauses, so you're saying "(,) (snd a) (snd b)" is "(b,d)" for ALL possible types 'b' and 'd', EVEN types DIFFERENT from the 'b' in the type of 'f'
03:21:57 <Normen> Ah!
03:22:00 <Normen> Thx.
03:22:01 <merijn> Normen: "Because they weren't defined to be"
03:22:31 <merijn> Normen: As tero- says you can use ScopedTypeVariables to explicitly make them scoped, or you can just leave the signature out
03:22:50 <merijn> Normen: Unrelatedly, why use snd/fst like this instead of pattern matching?
03:23:22 <Normen> merijn and tero- Thx. I'm still a beginner and doing some exercises. 
03:23:30 <lpaste> merijn annotated “No title” with “Refactored” at http://lpaste.net/167412#a167417
03:23:40 <merijn> See that variation :)
03:24:04 <cheater> RedNifre: you could use a GADT and a free monad and make sure that Order on two constructors that are the same results in Fail.
03:24:18 <Normen> merijn That looks much nicer. Still, let me try to incorporate tero- adivce...
03:24:28 <lpaste> merijn annotated “No title” with “Alternative refactoring” at http://lpaste.net/167412#a167418
03:24:43 <merijn> Or that one
03:25:39 <Normen> I added ScopedTypeVariables, but where to put the `forall`?
03:26:13 <Cale> Just after the :: in a type signature?
03:26:13 <tero-> Normen: f :: forall a b c d. (a,b) -> ...
03:26:23 <Cale> yeah, like that
03:27:50 <Normen> Hmm... doesn't compile: Illegal symbol '.' in type
03:27:52 <Normen>     Perhaps you intended to use RankNTypes or a similar language
03:27:52 <Normen>     extension to enable explicit-forall syntax: forall <tvs>. <type>
03:28:05 <tero-> Normen:  {-# LANGUAGE ScopedTypeVariables #-} in the first line
03:28:33 <Normen> Ah!
03:28:35 <Normen> Great!
03:28:45 <Normen> Thx guys!
03:32:27 <tero-> whoa. ghc 7.10.2  --supported-languages gives 203 flags and 103 do not start with "No". it's quite a challenge to keep up with these 
04:26:57 <hc> I'm trying to embed an STUArray inside a StateT...
04:26:59 <hc> any hints? :)
04:27:16 <hpc> don't
04:27:27 <hc> The Idea is that I've got a BitStream inside the State, and "output" the result by writing to an STUArray
04:27:30 <hpc> STUArray is a mutable type for ST, which is weird and different
04:27:37 <hc> Yeah I need that for optimistation
04:27:42 <hc> optimisation, even
04:28:03 <hpc> mutable ST types can't be used outside of an ST action
04:28:08 <hc> I know
04:28:14 <hc> Which is why I'm struggling with the types right now
04:28:25 <hc> I need to process a stream of bits and write the output to an array, while also accessing previously set elements of that array (lzh decompression)
04:28:36 <hpc> and ST is designed so that running an ST action that produces one of those types is also impossible to use
04:28:46 <hpc> it simply can't be done
04:28:56 <hc> Okay, do you have a recommendation what to do instead?
04:29:39 <hpc> if you really do want a mutable algorithm, use the mutable refs of IO
04:29:56 <hc> Well... right now I'm using Data.Sequence, which is immutable
04:30:05 <hc> performance: C code: ~2s, my code: ~120s
04:30:51 <hpc> there's probably also some stream processing library that can help
04:30:52 <hc> kinda unsatisfactory... so I'm trying to figure out how to speed it up
04:31:16 <hc> It's not the input stream that's costing so much performance (it does cost some, but I'll fix that lateR)
04:31:31 <hc> The problem is generating the output stream
04:31:45 <hc> I'd use a ByteString builder, but I can't because I need to backreference already written bytes
04:35:11 <hc> hey wait
04:35:24 <hc> I could store the bitstream inside an STUArray aw well
04:35:39 <hc> So I'd have two STUArrays, one to read from and one to write to
04:35:45 <hc> that might work, correct?
04:38:27 <hpc> the fundamental problem you're having is that it's impossible to use STUArray outside of ST
04:38:40 <hpc> (StateT is not ST)
04:38:44 <merijn> hc: Why does the need to backrefrence already written bytes prevent you from using builder?
04:46:06 <hc> hpc: i wouldn't need state then anywhere
04:46:13 <hc> merijn: maybe I don't know the builder well enough?
04:46:55 <merijn> I'm not entirely sure what you'd trying to do, so it's hard to say
04:47:14 <hc> merijn: i'm trying to implement lzh decompression
04:47:22 <hc> or rather, optimise the existing implementation
04:47:59 <merijn> hc: Sounds like something that you'd really want to use one of the streaming libraries like conduit/pipes for
04:52:42 <troydm> what's the most popular package for working with JSON?
04:52:56 <troydm> aeson?
04:53:03 <bergmark> yes
05:04:05 * hackagebot mywatch 0.1.2 - View MySQL processes  https://hackage.haskell.org/package/mywatch-0.1.2 (ip1981)
05:19:06 * hackagebot gf 3.8 - Grammatical Framework  https://hackage.haskell.org/package/gf-3.8 (ThomasHallgren)
05:25:01 <merijn> What's a good way to indicate (in command line help) that an option is legal to specify more than once?
05:25:51 <siwica`> Is there a library that contains lists of characters, alpha numerical characters, ...?
05:27:06 <quchen> > filter isAlphaNum [' '..] -- siwica` 
05:27:07 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
05:27:23 <tdammers> merijn: I think traditionally, you'd mention this in prose
05:27:41 <tdammers> "this option can be given multiple times, in which case {behavior}"
05:29:22 <siwica`> quchen: and if I wanted only ASCII alphaNums?
05:31:03 <quchen> > (filter isAlphaNum . map chr) [0..127]
05:31:04 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
05:31:44 <quchen> Char is an abstract Unicode codepoint, so you'll have to truncate your characters to ASCII manually.
05:31:45 <siwica`> quchen: Thank you!
05:34:26 <mauke> > filter isAlphaNum [' ' .. '~']
05:34:28 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
05:34:48 <tdammers> > filter isAlphaNum [minBound..maxBound] -- :x
05:34:49 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
05:34:58 <tdammers> > length $ filter isAlphaNum [minBound..maxBound] -- :x
05:34:59 <lambdabot>  105901
05:35:01 <tdammers> whoa
05:35:30 <tdammers> > takeEnd 100 $ filter isAlphaNum [minBound..maxBound] -- :x
05:35:31 <lambdabot>  Not in scope: ‘takeEnd’
05:35:37 <dramforever> > ['0'..'1'] ++ ['A'..'Z'] ++ ['a'..'z']
05:35:39 <lambdabot>  "01ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
05:35:50 <tdammers> > drop 105800 $ filter isAlphaNum [minBound..maxBound] -- :x
05:35:51 <lambdabot>  "\917899\917900\917901\917902\917903\917904\917905\917906\917907\917908\9179...
05:35:53 <dramforever> uh...change that to 9
05:38:13 <dramforever> (admittedly verbose solution)
05:38:55 <quchen> And error prone.
05:39:29 <dramforever> sure...
05:40:39 <siwica`> I am trying to define a datatype that consists of a subset of Latin1 characters. What would be the proper way to do that?
05:41:24 <tero-> newtype Latin1Char = Latin1Char Char? 
05:45:46 <siwica`> yes, ok :)
05:46:35 <siwica`> is there also a 'not elem' function in haskell or would I use 'not . elem'?
05:47:15 <quchen> :t notElem
05:47:16 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
05:47:52 <ggVGc> haha...
05:48:14 <siwica`> that makes sense :)
05:48:33 <ggVGc> "hm, I often do map and then concat. I wonder if... oh, concatMap"
05:49:00 <geekosaur> sometimes spelled (>>=)
05:49:10 <quchen> I often do "map f . sequence".
05:49:29 <quchen> I often wondered if …
05:50:41 <tero-> I guess hlint catches many of these
05:51:07 <Philonous> map f . sequence? Not sequence . map f ? 
05:51:23 <quchen> Yes.
05:51:44 <quchen> Well, fmap instead of map usually.
05:51:44 <eklavya_> I am sending input to a program using pipes cat test | haskProgram
05:51:53 <eklavya_> this results in: user error (Prelude.readIO: no parse)
05:52:07 <eklavya_> sorry
05:52:17 <eklavya_> let me ask in the beginners channel :P
05:52:22 <ggVGc> no here is fine
05:52:23 <quchen> This is the beginners channel.
05:52:37 <eklavya_> :)
05:52:53 <hpc> this is the beginners channel, and the beginners channel is the other beginners channel ;)
05:52:55 <ggVGc> eklavya_: this means that you are using read, and the input you're sending doesn't match your data structure
05:53:06 <ggVGc> eklavya_: show the code and the content you are piping in
05:53:23 <eklavya_> 1
05:53:24 <eklavya_> 3
05:53:24 <eklavya_> 1 2 3
05:53:25 <eklavya_> 4 5 1
05:53:28 <ggVGc> no, not here
05:53:31 <geekosaur> @paste
05:53:31 <lambdabot> Haskell pastebin: http://lpaste.net/
05:53:31 <ggVGc> paste it somewhere
05:53:33 <ggVGc> yeah
05:54:05 <geekosaur> or gist.github.com, to have your source + the data file (may require a github account for multiple files though_
05:54:13 <eklavya_> http://lpaste.net/167437
05:54:28 <ggVGc> eklavya_: what's your haskell program?
05:54:40 <eklavya_> creating a paste
05:55:14 <eklavya_> http://lpaste.net/167438
05:55:52 <mauke> eklavya_: readLn already does 'read' for you
05:56:06 <mauke> half of those should be getLine
05:56:10 <geekosaur> yeh
05:56:28 <eklavya_> I got this from a hackerrank stub
05:56:35 <eklavya_> I assumed this was the correct way :P
05:57:15 <eklavya_> oops
05:57:17 <eklavya_> my bad
05:57:20 <eklavya_> they used getLine
05:57:46 <ggVGc> today you learn!
05:58:19 <siwica`> When I want to check if all characters of a string 'str' are part of a set 's', is there a way of doing 'all (\x -> elem x s) str'?
05:58:30 <siwica`> * a better way
05:59:11 <hpc> depending on the string, maybe if you sort and nub it
05:59:26 <hpc> though "better" in that case merely means "faster"
05:59:41 <siwica`> maybe some elem function with reverse param order so I can use currying?
05:59:42 <eklavya_> let me checkout readLn
05:59:54 <quchen> nub and faster is a delicate balance
06:00:11 <hpc> there's not really anything terribly wrong with what you have, other than the usual "redesign your system so you no longer need that" ;)
06:00:13 <mvaenskae> hm, can someone help me with infering the type of a couple functions? it is for my upcoming exam and i am kinda lacking in actually understanding how haskell derives this :(
06:01:01 <rydgel> mvaenskae: show us
06:02:53 <mvaenskae> thanks, let's start with a simple lambda expression then; (\x y z -> x (y z)) has the type (b -> c) -> (a -> b) -> (a -> c) but i don't even see where to begin properly with deriving these without using trees and i think that is not what a haskell programmer has to do :)
06:03:37 <hpc> so first off, look at the lambda, which is \x y z -> ...
06:03:48 <hpc> right away, you see that the type of the whole thing is going to be (?? -> ?? -> ??)
06:04:05 <hpc> you also see that the body is x (??)
06:04:12 <mauke> needs more arrows
06:04:13 <eklavya_> updated version http://lpaste.net/167439
06:04:17 <eklavya_> still doesn't work
06:04:19 <mauke> three parameters, three arrows
06:04:23 <hpc> oh yes
06:04:38 <hpc> (?? -> ?? -> ?? -> ??)
06:04:53 <UberLambda> any way to become less allergic to monads?
06:05:04 <mauke> UberLambda: yeah, stop thinking about "monads"
06:05:11 <UberLambda> I understand the basics and why they work the way they do
06:05:18 <hpc> so, with the body being x (something) you can conclude the type of the final result is the type of x's final result
06:05:22 <mauke> eklavya_: numElems should probably be an Int, not an [Int]
06:05:27 <hpc> and that x :: ?? -> ??
06:05:38 <UberLambda> it's just that I can't wrap my head around most of the standard functions
06:05:41 <eklavya_> omg
06:05:45 <mauke> eklavya_: and you can't use readLn for a1/a2 because they don't use list syntax
06:05:48 <hpc> so fill that in, and you have the whole thing :: ((?? -> a) -> ?? -> ?? -> a)
06:06:15 <mauke> > read "1 2 3" :: [Int]
06:06:16 <lambdabot>  *Exception: Prelude.read: no parse
06:06:17 <eklavya_> mauke: thanks :) that was amazingly stupid of me :P
06:06:20 <mauke> > read "[1, 2, 3]" :: [Int]
06:06:22 <lambdabot>  [1,2,3]
06:06:37 <mauke> > map read (words "1 2 3") :: [Int]
06:06:39 <lambdabot>  [1,2,3]
06:07:01 <hpc> mvaenskae: do the same thing for y, which fills in the parameter for x, as well as the parameter of the whole thing that's in y's position
06:07:50 <hpc> mvaenskae: and keep going until you can match no further, and just give unique type variables to every ?? that remains (though in this example you won't have to)
06:07:54 <quchen> UberLambda: See what the generic functions do when you put in specific monad examples (Maybe, List, State, IO, ...). After some time you'll notice that they do kind of similar things in a way.
06:09:18 <UberLambda> quchen: hm, yeah I guess I could do that
06:10:19 <hpc> important caveat to quchen's advice, IO is an abstract type (meaning it doesn't have a pure haskell definition), so your investigations there will be a bit more opaque
06:11:17 <hpc> it's not terribly important to its status as an instance of Monad, but it'll make playing around with it slightly different from the others
06:11:51 <hpc> another good type to play around with is Identity
06:12:18 <hpc> (which is a pathologically simple instance of Monad)
06:14:32 <mvaenskae> pardon, got distracted a bit by other haskell stuff >.>
06:19:02 <mvaenskae> i think i begin understanding a bit better, can you elaborate on why for filling in x we get ((?? -> a) -> ?? -> ?? -> a)? how can i conclude that the type of the final result is the type of x's final result that is :)
06:23:25 <hpc> so, x is applied to an argument, so it's (?? -> ??)
06:23:48 <hpc> the first ?? in the type of the whole expression is equal to x's type
06:24:07 <hpc> so ((?? -> ??*) -> ?? -> ?? -> ??*)
06:24:24 <hpc> and the position of x in the body of the lambda is that the result of the lambda is the result of x applied to something
06:24:42 <hpc> so the types of their results are the same, so we use the same type variable where i have asterisk'd
06:26:05 <mvaenskae> hpc: that is from the rhs of the lambda expression, correct?
06:26:10 <hpc> yes
06:26:46 <hc> merijn: I'm already using conduits
06:27:05 <hc> conduits for teh win
06:27:07 <hc> =)
06:30:53 <siwica`> how is CR escaped in haskell strings?
06:31:06 <geekosaur> \r
06:31:10 <quchen> \r
06:31:20 <siwica`> thank you!
06:33:37 <mvaenskae> hpc: so to show if i understood it let me work out the other ??s :) we know z :: ?? -> ?? and y :: ?? -> ??; further we can deduce (y z) as ?? -> ?? -> ?? with the final result being of type y --> (y z) :: ((?? -> b) -> ?? -> b) correct?
06:34:20 <mauke> or \13
06:34:51 <hpc> you don't know what type z is
06:35:05 <hpc> but from (y z) you can deduce that y :: (type of z) -> ??
06:37:24 <mvaenskae> hm, this is a lot more confusing than i thought :/
06:37:37 <mvaenskae> do you have any links which i could read?
06:37:53 <mvaenskae> i think that is a lot more productive that way :)
06:39:18 <merijn> mvaenskae: What are you trying to learn/understand?
06:40:27 <mvaenskae> type inference of functions and expressions
06:40:48 <mvaenskae> given a couple building blocks of functions of known types
06:41:06 <mvaenskae> mostly it's the "put definition part X in there and it will solve itself"
06:41:08 <hpc> ill pastebin something in a bit if merijn doesn't make it make sense ;)
06:41:34 <mauke> there are some basic blocks
06:41:44 <merijn> mvaenskae: Time to my usual answer "Get a copy of TaPL" :p
06:42:00 <mauke> essentially, different kinds of expressions generate different constraints / equations
06:42:06 <mauke> and then the type checker solves the equations
06:42:07 <merijn> Really, if you wanna learn about type inference, type checking, or basically anything else the best answer will always be "TaPL"
06:42:26 <bernalex> PFfPL is also good
06:42:44 <mauke> e.g. if you have function application (foo bar), then foo :: a -> b, bar :: a, foo bar :: b (for some types a and b)
06:42:56 <mvaenskae> it's just difficult to find google results which explain them beyond simple constructs and showing the single steps
06:43:34 <mvaenskae> merijn: TaPL? doesn't ring a bell :)
06:43:36 <mauke> and (\x -> y) produces x :: a (within y), y :: b, (\x -> y) :: a -> b
06:43:40 <mauke> @where tapl
06:43:40 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:44:10 * hackagebot cassava-megaparsec 0.1.0 - Megaparsec parser of CSV files that plays nicely with Cassava  https://hackage.haskell.org/package/cassava-megaparsec-0.1.0 (mrkkrp)
06:44:37 <merijn> mvaenskae: Types and Programming Languages, it's the de facto standard book on how to implement, prove, understand type checking
06:45:02 <merijn> mvaenskae: Starts from untyped lambda calculus and keeps adding more complex type systems
06:45:15 <buglebudabey> is there a good package to parse strings for dates?
06:45:30 <hpc> @hoogle parsetime
06:45:33 <lambdabot> Data.Time.Format class ParseTime t
06:45:33 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
06:45:33 <lambdabot> Data.Time.Format parseTimeM :: (Monad m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t
06:45:45 <merijn> mvaenskae: You should be able to reimplement Haskell2010 typesystem with only like 50% of the content of the book :)
06:45:57 <hpc> parseTime is the inverse of formatTime
06:46:30 <mvaenskae> merijn: that is a book i haven't heard of (or don't remember at least)
06:47:19 <buglebudabey> thanks hpc 
06:47:58 <merijn> mvaenskae: It's about as comprehensive as a book on this can be and it requires/assumes very little background knowledge. A basic haskell/lambda calculus background would help, but that's about it
06:49:13 <mvaenskae> i will check if our library has a copy of it floating around later today
06:49:46 <jackhill> merijn: Are you recommending the regular _Types in programming languages_ or _Anvnaced topics in types and programming languages_ (my library seems to have both)
06:50:13 <bernalex> jackhill: regular.
06:51:12 <jackhill> bernalex: thanks. Yeah, I'm definitely not ready for advanced
06:53:09 <quchen> merijn: I'd imagine typeclasses to be particularly tricky to implement
06:53:48 <merijn> jackhill: The advanced is basically the continuation of the regular one :)
06:54:28 <merijn> quchen: If you don't have to do multiparam (which is not haskell2010 anyway) it's pretty straightforward
06:54:43 <hpc> mvaenskae: http://pastebin.com/iU51erw6
06:54:57 <hpc> mvaenskae: in retrospect, using "??" was a bit of a mistake in the explanation
06:55:07 <hpc> mvaenskae: fundamentally, type inference is a system of equations
06:55:12 <quchen> merijn: Hm. I remember thinking "those rules look difficult" when reading Wadler's paper on typeclasses (superficially).
06:56:11 <merijn> quchen: I'd have to check, I haven't really tried, tbh. But it seems like it should be fairly straightforward
06:56:27 <merijn> Anyway, time to go for a bit
06:56:48 <hpc> mvaenskae: there's unification rules, which are mostly common sense, and you just methodically work through the expression adding equations to the environment and reducing them until you have fully solved for everything
06:57:49 <troydm> suggest a good transactional embedded database storage engine for Haskell
06:58:07 <hpc> mvaenskae: that paste runs a few steps, showing a full environment of equations at each stage
06:58:14 <troydm> I'm thinking about sqlite but not entirely sure
06:58:32 <tdammers> acid-state might be another option
06:58:39 <hpc> troydm: sqlite has some big weaknesses
06:58:47 <hpc> acid-state has different weaknesses
06:58:52 <tdammers> correct
06:59:08 <tdammers> rolling your own persistent storage has yet other weaknesses
06:59:10 <mvaenskae> hpc: wow, thanks a lot for that; i am reading right now and trying to connect all the dots :)
06:59:11 <hpc> there's others like berkeleydb
06:59:25 <tdammers> hpc: which has *yet other* weaknesses :x
06:59:50 <hpc> yeah
07:00:27 <hpc> also lpaste is currently read-only, not sure why
07:00:28 <tero-> hpc: what's the biggest weakness of sqlite?
07:00:56 <hpc> the absolute super-mega-biggestest weakness is that it's not ACID
07:01:07 <hpc> opening an sqlite database in multiple processes is completely unsafe
07:01:21 <hpc> and nothing stops you from doing it
07:01:48 <hpc> it's also got an entirely crap-ass type system, even compared to other relational databases
07:02:04 <hpc> the types of columns are effectively just suggestions
07:02:19 <tero-> hpc: I thought that it can be used from multiple processes safely.  https://www.sqlite.org/faq.html#q5
07:03:07 <tero-> and how is it not ACID?
07:03:10 <hpc> ah, maybe it's changed
07:03:52 <hpc> if you concurrently wrote to an sqlite db across multiple processes, the data would be corrupted
07:03:55 <hpc> losing I
07:04:04 <tero-> ah, ok so it was related to that
07:04:35 <tero-> hpc: and what's the biggest weakness of acid-state?
07:04:39 <hpc> oh, maybe it still isn't safe: "Under Unix, you should not carry an open SQLite database across a fork() system call into the child process"
07:04:48 <hpc> for acid-state, it's schema updates
07:05:11 <sm> and memory usage ?
07:05:25 <hpc> when you change the definition of the type that's stored in the acid-state db, you need to write a function to convert from the old type to the new type
07:05:34 <hpc> also memory usage, the whole state is kept in memory at once
07:06:05 <mvaenskae> hpc: one dot is a still not fitting; like 34 you state x1 = y2; how do you know that? i presume it is because we feed the result of y (being y2) to x (being x1), therefore x1 must be y2
07:06:40 <sm> also being a niche product with little documentation
07:06:56 <hpc> mvaenskae: correct
07:07:05 <siwica`> are you aware of an emacs function/macro/... that creates a module declaration and exports all functions from a haskell file so that I can just delete the functions that I dont want to export?
07:07:32 <mvaenskae> alright, then that component does fit and also explains the setting of parenthesis
07:07:35 <hpc> mvaenskae: actually, i still skipped a few steps there
07:07:49 <hpc> but they aren't terribly important steps for that example
07:07:54 <hpc> the value passed to x is (y z)
07:08:04 <hpc> and type of (y z) is y2
07:08:39 <hpc> so you do that and then repeat the whole process of inspecting a function call's parameter with y, as was done with x
07:08:48 <hpc> to see what z is
07:09:14 <tero-> hpc: if you use sqlite only through a wrapper like Database.Persist then I guess the crap-ass type system would not matter much? 
07:09:22 <hpc> tero-: right
07:10:11 <mvaenskae> hpc: this is becoming clearer :) i do believe i can also then give the explicit types for x y and z on their own from the type derivation, correct? :)
07:10:40 <hpc> mvaenskae: right
07:10:52 <hpc> tero-: another weakness of sqlite, which i notice from the faq that isn't really a technical weakness
07:11:19 <hpc> tero-: is the developers consider thread-safety to be a concession, rather than a necessary feature or even a nice-to-have
07:11:58 <hpc> which makes me think there are other blind spots that they are dismissing out of hand because they don't get the volume of complaints that thread-safety does
07:12:14 <hpc> https://www.sqlite.org/faq.html#q6
07:13:28 <tero-> hpc: luckily sqlite is so widely used so it's also quite well de facto tested  
07:13:40 <hpc> so is php
07:13:44 <tero-> good point
07:14:04 <mauke> AFAIK sqlite has actual tests that the developers actually pay attention to
07:14:09 <hpc> the paper they link to about threads being bad is from 2006 (a very long time ago as concurrent programming goes)
07:15:18 <hpc> it seems to argue concurrency is a problem merely because of nondeterminism
07:20:56 <hpc> ah, in faq3: "This is a feature, not a bug. SQLite uses dynamic typing. It does not enforce data type constraints"
07:21:11 <hpc> they're aware of how bad their type system is :(
07:21:57 <mauke> well, it used to be a tcl extension that grew into a rdbms
07:22:25 <hpc> yeah but they internalized the badness :P
07:22:55 <mauke> it's too late, it's a feature now
07:23:51 <hpc> i wonder how long thread-unsafety was a feature
07:26:26 <tero-> hpc: at least it supports foreign keys now
07:26:56 <tdammers> hpc: IIRC, sqlite wasn't even *process* safe for most of its existance
07:27:18 <tdammers> i.e., multiple processes could open the same database file concurrently and break it
07:33:08 <R0B_ROD> Well... it seems Im going to have to port Stack to OpenBSD
07:33:18 <R0B_ROD> DOnt know how to start that even, Oh Lord
07:33:41 <hpc> tdammers: it was, i had no idea it had changed
07:34:13 <R0B_ROD> Well I guess Haskell platform is gonna have to b installed
07:34:13 <tdammers> R0B_ROD: set up a working haskell toolchain, clone the stack source repo, build, and see what errors you get
07:34:29 <tdammers> I believe you don't need platform, but you do need a working cabal
07:34:45 <R0B_ROD> tdammers: ok going to see what I can do 
07:35:17 <tdammers> apparently there's a working installer for FreeBSD, maybe starting from there isn't a lousy idea
07:35:48 <R0B_ROD> tdammers: already tried bro
07:35:54 <R0B_ROD> no luck
07:36:05 <tdammers> oh wait, yeah, that one just ships precompiled binaries
07:36:13 <R0B_ROD> i can only get ghc, no package for cabal
07:36:14 <buglebudabey> could someone help with this error? No instance for (ParseTime String) arising from a use of ‘parseTime’ in the expression: parseTime defaultTimeLocale "%d%m%y" string
07:36:38 <R0B_ROD> the platform bins have cabal
07:36:44 <R0B_ROD> maybe I need to dive into ports
07:37:34 <tdammers> you can, at least in theory, bootstrap cabal with just ghc installed
07:37:53 <dcoutts> there are also cabal binaries available
07:38:06 <tdammers> ^ probably a better approach
07:38:34 <idev> on OSX + ghc 7.10, is there a way to say "import osx gui libraries in haskell" ?
07:38:42 <idev> I don't want to use gtk-blah, I want osx native widgets
07:39:05 <dmj`> idev: good luck
07:39:11 <tdammers> idev: either FFI the relevant C libraries yourself, or find a Haskell library that does this for you
07:39:19 <tdammers> also what dmj` said
07:41:46 <R0B_ROD> cabal-install is the pkg name for OpenBSD ;)
07:42:44 <R0B_ROD> ok so now cabal and ghc are on my system
07:47:22 <idev> dmj` , tdammers : okay, so basically this is hard to do in haskell
07:49:13 * hackagebot enchant 0.1.0.0 - Binding to the Enchant library  https://hackage.haskell.org/package/enchant-0.1.0.0 (kseo)
07:50:50 <hardlin3r> hi guys, i have a problem installing stack on manjaro linux
07:51:55 <hardlin3r> libtinfo.so.5: cannot open shared object file: No such file or directory
07:53:36 <argent0> hardlin3r: looks like you are missing a dependencie (you should probably install a package)
07:53:39 <hardlin3r> it occurs then i run stack setup
07:56:25 <hardlin3r> argent0, yes, but i have package aur/libtinfo installed
07:57:06 <argent0> hardlin3r: and you have the libtinfo.so.5 file where hask is looking for?
07:57:43 <hardlin3r> argent0, where does stack search libtinfo.so.5?
07:57:58 <hardlin3r> i want to add symlink to libtinfo.so 
07:58:47 <argent0> isn't libtfino.so.5 what hask is looking for?
07:59:03 <argent0> but yes a symlink could solve the problem
07:59:21 <hardlin3r> argent0, thanks you, i solved the problem
08:00:17 <hardlin3r> sudo ln -s /usr/lib/libtinfo.so /usr/lib/libtinfo.so.5
08:00:22 <hardlin3r> it helped me
08:03:28 <argent0> hardlin3r: you could also report it to your distro's bugtracker if you used their package.
08:03:39 <argent0> to install hask
08:03:45 <hardlin3r> yes
08:07:09 <buglebudabey> could someone tell me what i'm doing wrong here: http://lpaste.net/167462 I'm getting a no instance (ParseTime String) error
08:08:11 <shirt> Is it a good idea to use view patterns?
08:09:40 <mvaenskae> hpc: thanks again for helping me out with the type derivation, it begins to make a lot more sense; i guess by tomorrow i will understand it quite well :)
08:22:16 <lpaste> argent0 revised “no instance for parsetime string”: “no instance for parsetime string” at http://lpaste.net/167462
08:22:53 <argent0> ^buglebudabey (who left :))
08:24:15 * hackagebot gnss-converters 0.1.9 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.9 (markfine)
08:24:25 <rydgel> I just get back to C++ after a some years of Haskell/Rust/Scala. I feel so insecure.
08:25:27 <davidkart> you mean with C++ ?
08:25:35 <davidkart> I can understand.
08:48:32 <hc> hi
08:48:47 <hc> wouldn't it make sense to offer a modifySTRef function that returns the old reference instread of ()?
08:48:54 <hc> s/instread/instead/
08:52:35 <mauke> :t \x r -> readSTRef r <* writeSTRef r x
08:52:36 <lambdabot> a -> STRef s a -> ST s a
08:54:02 <hc> yeah nice thanks
08:55:11 <hc> let n = (flip (-) 5)       <-- any simpler way to write this?
08:55:20 <glguy> subtract 5
08:55:28 <hc> thanks :)
08:55:58 <johnw> is that really subtract 5?  Or is in (5-)?
08:56:00 <hc> mauke: shouldn't the type signature rather be something like STRef s a -> (a -> a) -> ST s a    ?
08:56:45 <Xandaros> :t modifySTRef
08:56:46 <lambdabot> STRef s a -> (a -> a) -> ST s ()
08:57:49 <mauke> :t \r f -> readSTRef r <* modifySTRef r f
08:57:50 <lambdabot> STRef s a -> (a -> a) -> ST s a
08:58:28 <buglebudabey> if i know i have exactly 5 pieces of data that are all related is there a better way to put them together than a big tuple?
08:59:03 <Xandaros> put them in a data type/record?
08:59:27 <hc> dank je well mauke
09:00:00 <hc> that statement looks just like your previous one... 
09:00:18 <hc> ah now i see.
09:00:20 <hc> :)
09:00:52 <monochrom> oh what fun, if two threads have access to the same STRef
09:01:01 <mauke> "you're welcome" in dutch
09:01:02 <glguy> How would two threads do that?
09:01:17 <tippenein> how do ppl manage parsing json which you don't know the structure of? For example, an endpoint like something/:name where name serializes "Name" data and returns it as json. 
09:01:26 <monochrom> oh haha, nevermind, I can't ethically.
09:02:04 <tippenein> or for an ETL which has an aggregate of many different data type formats which change often
09:05:23 <puregreen> tippenein: we parse it as a Value/Object/Array/etc and process (e.g. https://artyom.me/aeson#unknown-field-names, or when there are simply several known alternatives you can go with https://artyom.me/aeson#more-interesting-choices)
09:06:10 <puregreen> also lens-aeson/microlens-aeson can make things easier
09:07:52 <tippenein> puregreen: perfect, thanks
09:15:27 <Hephaistos> I'm somewhat new to programming and completely new to Haskell. In fact, apart from some small python programs, I want Haskell to be my first language. This might be foolish, but I understand why pure functional is the Right Way™ so I'm looking for the absolute best resource for a total beginner.
09:16:03 <Hephaistos> I've been watching Lambdaconf2015 lectures
09:16:28 <Hephaistos> but that's not really teaching me to program, just giving me a clearer idea about why functional is the way to go
09:16:36 <Hephaistos> Any suggestions?
09:16:54 <boek> http://learnyouahaskell.com/ is a good start
09:17:34 <mauke> @where cis194
09:17:34 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:18:03 <Hephaistos> boek: I'll give it a look but I'm not really the type of person to enjoy the quirky millennial superfun happy jive
09:18:08 <mauke> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:18:24 <hpc> there's also RWH
09:18:26 <hpc> @where rwh
09:18:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:18:54 <Hephaistos> thanks everyone, I'll start looking these over
09:19:21 <Hephaistos> also, best IDE? I use IntelliJ which has a Haskell module, but I'm very open to suggestions
09:19:38 <hpc> i just use bog-standard vim
09:19:43 <hpc> anything works
09:20:38 <monochrom> Hephaistos: If you can spend money, http://haskellbook.com/ is step by step, from the ground up, and contains plenty of exercises.
09:20:57 <Hephaistos> I can spend money, sure. As long as the material is quality.
09:21:11 <the_2nd> when declaring newtype Foo = Foo Double
09:21:17 <tigerfinch> I would second a recommendation for haskellbook.com
09:21:23 <Hephaistos> awesome
09:21:30 <the_2nd> how can I later do basic math on these types?
09:21:46 <Hephaistos> also, quick question, how many of you also have experience with lisp?
09:21:57 <the_2nd> I get errors like "No instance of Num Foo arisings from the use of '-'
09:22:09 <hpc> the_2nd: you need to give your type at least some of the instances here: https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Double
09:22:29 <Hephaistos> I'm told often that I should learn lisp to grasp functional fundamentals
09:22:40 <Hephaistos> agree? disagree?
09:22:45 <hpc> the_2nd: you can use generalized newtype deriving to make it a bit easier
09:23:02 <hpc> Hephaistos: you should learn lisp to grasp lisp fundamentals ;)
09:23:20 <hpc> the lisp family varies wildly on how closely they hold you to functional style
09:24:19 <Hephaistos> I would just use sbcl
09:24:30 <hpc> it's still a decent family of languages for other reasons, but there's a lot of ways for you to stray away from functional style
09:24:56 <hpc> ah, common lisp
09:25:18 <hpc> common lisp is a bit of an everything language
09:25:27 <niteria> can you have functions polymorphic in the constraint, like:  forall C . C => a -> (C => a -> a) -> a, or is that not even well defined?
09:25:47 <the_2nd> hpc, thanks
09:25:48 <hpc> i think some here would say it's got everything but nothing good
09:26:07 <hpc> if you go the other way and master functional style first, then start writing common lisp
09:26:11 <hpc> you'll find some interesting things
09:26:11 <tippenein> ^
09:26:57 <hpc> as dumb as it sounds, i think perl is the best language to look at for weird functional stuff
09:27:03 <hpc> (though absolutely not as a first language)
09:27:42 <Hephaistos> im not looking for weird or esoteric anything, im looking to make money from programming in a superior paradigm
09:27:52 <hpc> ah
09:28:13 <Hephaistos> i hear lisp is a competitive advantage, for example
09:28:30 <GLM> Hephaistos: Depends on who you as
09:28:32 <GLM> *ask
09:28:33 <Hephaistos> not sure if that applies to Haskell too
09:29:05 <GLM> The main advantage to Lisp is macros and those usually become unmanageable after a few people
09:29:18 <GLM> Haskell is a great production language though
09:29:20 <hpc> if you heard lisp was a competitive advantage from that paul graham article, keep in mind that was written a very long time ago about a business he started even longer ago
09:29:41 <Hephaistos> I did hear from Chris Allen that Haskell code is easier to maintain, more expressive, etc. so that could be considered a competitive advantage
09:29:55 <ocharles> hpc: I learnt about immutable data structures in Perl
09:29:57 <hpc> sadly, if you just want to make money programming you should look at the more popular languages
09:29:59 <ocharles> never heard of them before :)
09:30:10 <ocharles> I'm making a fine amount of money in Haskell
09:30:11 <GLM> Java makes plenty of money
09:30:14 <hpc> ocharles: what immutable structures are there in perl lol
09:30:27 <GLM> I have a friend making a bunch writing COBOL
09:30:31 <ocharles> hpc: it's not necessarily about them being *in* perl, but the community is interested in them as a whole
09:30:39 <Hephaistos> well I'm an entrepreneur that has made my living on making CMS driven websites, so this is a big leap for me into "actual" programming
09:30:51 <ocharles> http://blog.woobling.org/2009/05/immutable-data-structures.html
09:30:52 <hpc> ocharles: probably in a "never seen anything like that before" way :P
09:31:17 <ocharles> and then http://blog.woobling.org/2009/05/immutable-data-structures-cont.html
09:31:38 <Hephaistos> so for me, I'm looking for a programming language that gives me a competitive edge in development time, maintainability, stability, and speed of implementation of features
09:31:59 <Hephaistos> after I learn the ropes, anyway
09:32:50 <buglebudabey> does anyone know a quick and dirty way i can use parsec to skip everything in a string except the first Int it sees?
09:32:58 <hpc> the way programming works when you try to make money from it is that everyone uses the same language on a single project
09:33:18 <Hephaistos> right
09:33:24 <hpc> businesses prefer languages that they can hire more people that know, and programmers prefer languages that they can get hired to use
09:33:38 <hpc> which means java and web stuff
09:34:04 <Hephaistos> that's why I said I'm an entrepreneur, I don't have to worry about anyone other than myself and those I hire
09:34:07 <hpc> if you want to use haskell as a competitive advantage, you really need to either get a job first, then push it
09:34:10 <hpc> or yeah, start your own company
09:34:21 <hpc> in which case you need to be a good programmer in general
09:34:26 <Hephaistos> yes
09:34:32 <Hephaistos> which I'm not
09:34:35 <Hephaistos> but I can try
09:35:12 <Hephaistos> it's been too easy to make money on slinging customized CMS websites
09:35:23 <Hephaistos> which hasn't made me a good programmer at all
09:36:11 <Hephaistos> alright well thanks for the info I'll get started on these excercises
09:38:00 <suppi> Hephaistos: another recommendation for www.haskellbook.com
09:38:21 <suppi> i hope you'll enjoy haskell :)
09:39:27 <Hephaistos> ty
09:49:14 <tippenein> Hephaistos: I believe agrafix contracts with haskell. His projects may be useful when the time comes for you. I've used typed-wire and users in the past https://github.com/agrafix
09:53:25 <hc> omg, i don't believe it
09:53:45 <hc> I transformed theLZH decompressor from using Data.Sequence to STUArray, and upon the first successful compile the algorithm actually *RUNS* successfully
09:53:52 <hc> awesome :-))
09:54:00 <hc> plus it's a lot faster now
09:54:25 <hc> 120 seconds down to 4 seconds
09:54:41 <peddie> hc: nice job, wow!
09:54:52 <joehillen> Types are magic!
09:55:25 <peddie> hc: do you use quickcheck to make sure the two implementations are identical?
09:55:51 <joehillen> You try to tell other programmers about "I compiled it and it worked" and they just never believe you
09:56:52 <hc> peddie: not yet, but I'm running manual tests right now
09:57:02 <hc> sha256 values seem to match so far, but I'm still running tests
09:57:15 <hc> joehillen: don't believe it myself yet... ;)
10:06:31 <monochrom> I only talk to programmers who know Haskell. So when I say "I compiled it and it doesn't work" they never believe me. :)
10:07:46 <shachaf> monochrom: Well-typed programs can't be blamed.
10:12:52 <dfeuer> Why doesn't Hackage show documentation for Data.Array.Base?
10:13:53 <dfeuer> (Or provide access to unsafeReadArray and unsafeWriteArray from some other module?)
10:14:20 * hackagebot generic-random 0.1.1.0 - Generic random generators  https://hackage.haskell.org/package/generic-random-0.1.1.0 (lyxia)
10:14:21 <maerwald> joehillen: I write haskell and I don't believe it either, unless I see actual proof. A typechecked program is not necessarily a correct program in terms of desired behavior.
10:15:21 <mizu_no_oto_work> maerwald: It's been remarked that it's more "if you refactored and it typechecked, then it works"
10:15:31 <maerwald> not even that is true
10:15:41 <maerwald> it's more likely, though
10:16:46 <mjrosenb> cabal update (and cabal install) are segfaulting on me, is there anything I can do to track down what the issue is, and fix it?
10:17:11 <dmj`> mjrosenb: segfaulting? can you paste the error
10:17:39 <dmj`> mjrosenb: I've seen cabal exit prematurely due to RAM limitations on some small ec2 instances
10:17:45 <mjrosenb> mjrosenb@memoryalpha ~ $ cabal update
10:17:45 <mjrosenb> Downloading the latest package list from hackage.haskell.org
10:17:47 <mjrosenb> Segmentation fault (core dumped)
10:17:59 <mjrosenb> this machine has 16 gigs of memory
10:18:03 <mjrosenb> or maybe 32?
10:18:09 <dmj`> @paste
10:18:09 <lambdabot> Haskell pastebin: http://lpaste.net/
10:18:33 <dmj`> mjrosenb: can you paste the whole thing here, see if its on the cabal issue tracker first
10:18:42 <mjrosenb> dmj`: that is the whole thing.
10:18:45 <mjrosenb> there is nothing else.
10:18:59 <johnw> segfaulting is usually that the program dereferenced a pointer into a memory page not allocated to the process, or accessed memory that was incorrectly aligned
10:19:05 <mjrosenb> including the command line where I ran it!
10:20:50 <mizu_no_oto_work> mjrosenb: have you seen http://unix.stackexchange.com/questions/257175/cabal-update-causes-segmentation-fault-on-freebsd-10-2 ?
10:20:55 <mizu_no_oto_work> What OS are you using?
10:21:14 <mjrosenb> freebsd.
10:21:15 <dmj`> unless cabal is dereferncing pointers sounds like it could be an RTS issue
10:21:36 <mjrosenb> mizu_no_oto_work: yes, and I didn't build it with llvm support
10:21:42 <mjrosenb> so, I stopped it in gdb
10:21:57 <mjrosenb> and it looks like it jumped to something that it should not have.
10:22:18 <mjrosenb> mizu_no_oto_work: unless there's a different way to disable llvm that I don't know of.
10:23:47 <mizu_no_oto_work> mjrosenb: is it possible that it got llvm support by default when you built it?
10:25:47 <mjrosenb>                                                               │ │ [ ] LLVM      Use the LLVM backend for code generation                   │ │                                                                 
10:25:55 <mjrosenb> it says it is unselected.
10:26:08 <mjrosenb> if I can't trust make config, then I may be in a lot of trouble.
10:28:14 <fvh> help me out folks, I have ill-defined API in JSON that I'm parsing with Aeson that changes keys, so I in simplest case need to parse { key: value} where `key` is always different, tried several approaches, but failed. Maybe there is simple solution?
10:29:08 <lyxia> parse to a JSON value then convert the dictionary to a list, then pattern match on the list
10:29:16 <puregreen> fvh: https://artyom.me/aeson#unknown-field-names
10:34:49 <nut>  lookup (read x :: Int) str
10:34:55 <nut> anything wrong with this ?
10:35:03 <dmj`> nut: read is dangerous
10:35:18 <mauke> :t lookup (read x :: Int) ?str
10:35:19 <lambdabot>     Couldn't match type ‘Expr’ with ‘[Char]’
10:35:20 <lambdabot>     Expected type: String
10:35:20 <lambdabot>       Actual type: Expr
10:35:24 <mauke> :t lookup (read ?x :: Int) ?str
10:35:25 <lambdabot> (?str::[(Int, b)], ?x::String) => Maybe b
10:35:26 <nut> ok
10:35:31 <nut> x is ''
10:35:34 <nut> x is '1'
10:35:40 <glguy> nut: That depends on what you think that that does
10:35:40 <mauke> then that's a type error
10:35:49 <mauke> > read '1'
10:35:50 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
10:35:50 <lambdabot>      Expected type: String
10:35:50 <lambdabot>        Actual type: Char
10:35:59 <nut> yes, here its wrong
10:36:06 <nut> rookie mistake
10:36:08 <nut> thank you
10:37:32 <nut> how to turn a if read is dangerous
10:37:44 <nut> what is better ?
10:37:51 <mjrosenb> reads is marginally better
10:38:07 <glguy> Text.Read.readMaybe 07:: Read a 07=> String 07-> Maybe a
10:38:35 <nut> ok
10:44:02 <nut> can i pattern match a Maybe result like this?
10:44:03 <nut> Just l1 = lookup (read [x] :: Int) c
10:44:25 <glguy> What happened when you tried?
10:44:29 <nut> sorry
10:44:33 <nut> i should do that
10:44:46 <nut> just so used to ask questions here
10:45:28 <nut> then answer is yes
10:45:54 <mjrosenb> nut: but you may want to not do that
10:46:26 <magneticduck> nut: (you get a compiler warning)
10:46:28 <nut> there is exception
10:46:37 <magneticduck> that's equilivant to the `fromJust` function
10:47:08 <dfeuer> Sometimes you know that something is in a map; if you're getting the key from `read`, however, you generally *don't* know that.
10:47:43 <dfeuer> On a totally unrelated note, what map type are you using?
10:47:46 <nut> so in these cases how do you get that wraped value out in the safe way
10:48:06 <mjrosenb> nut: case lookup (read [x])....
10:48:07 <dfeuer> nut, you have to decide what you want to happen when it's not in the map!
10:48:10 <magneticduck> explicitly, you can do that through a pattern match
10:48:34 <magneticduck> you can also use one of the typeclasses Maybe is an instance of -- Functor, Applicative, or Monad, primarily
10:48:36 <mjrosenb> nut: also, if I know it is a character, I'd probably use (ord x - ord '0') -- after verifing that it is a numeric charater.
10:48:39 <nut> dfeuer, it's just [(Int,[Int])]
10:48:50 <dfeuer> Or you can use `maybe` or `fromMaybe` or `fmap` or `traverse` or `foldMap` or whatever.
10:49:05 <nut> mjrosenb, hey great tip
10:49:16 <dfeuer> nut, you should consider using Data.IntMap for such things.
10:49:20 <magneticduck> you can't 'get the value out' in a safe way though -- `Maybe a -> a` cannot be defined to return in all cases
10:49:29 <nut> mjrosenb, iven been searching for this couple of days ago , like the C programmng way
10:49:30 <glguy> mjrosenb: Data.Char.digitToInt :: Char -> Int
10:49:39 <glguy> mjrosenb: rather than manually working with ascii values
10:49:40 <mjrosenb> actually, I would not be surprised if there is already a function like that in Data.Char
10:49:43 <mjrosenb> efb.
10:49:52 <dfeuer> Data.Char has.
10:50:34 <dfeuer> Unfortunately, you might be able to do better, because I think digitToInt also handles hexadecimal.
10:50:51 <dfeuer> There's some weird cruftiness around that stuff.
10:50:59 <glguy> which won't be a problem because you have to test the inputs are in the right range befor eyou use it
10:51:08 <mauke> > map digitToInt "0xf0rd"
10:51:10 <lambdabot>  [0,*Exception: Char.digitToInt: not a digit 'x'
10:51:22 <dfeuer> glguy, I just mean it might be possible to get faster code.
10:51:25 <mauke> > map digitToInt "hmm"
10:51:27 <lambdabot>  [*Exception: Char.digitToInt: not a digit 'h'
10:51:33 <mauke> well, that's boring
10:52:30 <shachaf> > map (\x -> preview (base 36) [x]) "0xf0rd"
10:52:32 <lambdabot>  [Just 0,Just 33,Just 15,Just 0,Just 27,Just 13]
10:56:58 <boek> ls
10:57:01 <boek> doh..
10:58:17 <ggVGc> ./my_first_haskell.txt     ./how_to_use_vim.txt
10:58:42 <ggVGc> ./nanoscience_meets_static_typing
10:58:50 <dfeuer> > map digitToInt "f00d"
10:58:52 <lambdabot>  [15,0,0,13]
11:05:15 <dfeuer> I had an idea a day or two ago, but I haven't implemented it yet because it's disgusting. And doing it properly requires using SmallArray#, which doesn't have a friendly interface in base or array, and doesn't exist in GHC 7.8 (which I'm still using because I haven't gone to the trouble of figuring out how to upgrade)
11:09:39 <boek> redraw
11:14:56 <ggVGc> boek: this is not vim either
11:16:11 <nut> i draw my first num from a list l1, second num from l2, etc... how do i print all possible combination? i know about list comprehension, but the number of num is unknow beforehand
11:16:28 <mauke> example?
11:17:27 <nut> l1 = [1,2], l2 = [1,2,3],  combination 1 = 11, c2 = 12, c3 = 13, c4 = 21,...
11:18:15 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
11:18:16 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
11:18:25 <Cale> ^^ is that what you're looking for?
11:18:40 <nut> man ...
11:18:41 <mauke> > [(c1, c2) | c1 <- [1,2], c2 <- [1,2,3]]
11:18:43 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
11:18:58 <nut> mauke, i dont know how many c1,c2
11:19:06 <nut> there could be c3, c4
11:19:57 <lyxia> > sequence [[11,12,13], [21,22], [31,32,33]]
11:19:59 <lambdabot>  [[11,21,31],[11,21,32],[11,21,33],[11,22,31],[11,22,32],[11,22,33],[12,21,31...
11:20:30 <lyxia> It's magic!
11:21:15 <boek> @ggVGc: this is embarrassing. Swapped from an IDE / GUI for everything to a CLI. Still getting used to it
11:21:16 <lambdabot> Unknown command, try @list
11:21:54 <nut> Cale, i got to check out the implementation of sequence...
11:24:23 * hackagebot syb-with-class 0.6.1.7 - Scrap Your Boilerplate With Class  https://hackage.haskell.org/package/syb-with-class-0.6.1.7 (JeremyShaw)
11:25:12 <hguant> list comprehensions are freaking magic
11:25:28 <mauke> s/freaking magic/very simple/
11:26:04 <mauke> > concatMap (\c1 -> concatMap (\c2 -> [(c1, c2)]) [1,2,3]) [1,2]
11:26:05 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
11:26:25 <hguant> mauke that's what makes it magic - the application of something very simple that expands and makes possible things that otherwise would have been rather complicated
11:26:40 <mauke> ^ this version isn't much more complicated
11:26:46 <mauke> or this one:
11:26:57 <mauke> > do c1 <- [1,2]; c2 <- [1,2,3]; return (c1, c2)
11:26:59 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
11:27:21 <oherrala> > [(a,b) | a <- [1..3], b <- [1..3]]
11:27:23 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:35:06 <mjrosenb> mauke: there are some extensions to list comprehensions that looked pretty complex.
11:37:22 <buglebudabey> is there a function to move a value from one monad to the other, such as Just a >=} (\r -> Right r)
11:38:21 <glguy> You can't generically switch between types that have Monad instances
11:38:23 <coppro> ^
11:38:31 <coppro> imagine if you could go IO a -> Maybe a
11:38:38 * glguy daydreams
11:40:14 <johnw> Just . unsafePerformIO .... imagined
11:41:16 <johnw> ouch, that was a nightmare
11:41:41 <shachaf> My imagination provides "const Nothing".
11:41:50 <johnw> yes, much better
11:42:30 <glguy> shachaf: I'd like a Proxy a -> Identity a
11:44:24 * hackagebot colonnade 0.1 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.1 (andrewthad)
11:44:26 * hackagebot reflex-dom-colonnade 0.1 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.1 (andrewthad)
11:49:24 * hackagebot texmath 0.8.6.4 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6.4 (JohnMacFarlane)
11:54:24 * hackagebot strict-data 0.1.0.0 - Verious useful strict data structures  https://hackage.haskell.org/package/strict-data-0.1.0.0 (AlexanderThiemann)
11:55:42 <nut> Cale, just found out about the function traverse, also does some unintuitive magic
11:56:19 <Cale> traverse is closely related, yeah
11:56:23 <Cale> :t traverse
11:56:24 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:56:32 <Cale> :t sequence
11:56:33 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:57:06 <Cale> :t traverse id
11:57:07 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
11:57:20 <Cale> :t sequenceA
11:57:21 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:57:26 <Cale> ^^ same thing
11:57:32 <nut> and mapM
11:57:36 <Cale> yep
11:57:40 <nut> :t mapM
11:57:41 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:57:54 <Cale> > mapM (\x -> [x, 10*x]) [1,2,3]
11:57:54 <EvanR> nut: unintuitive?
11:57:55 <lambdabot>  [[1,2,3],[1,2,30],[1,20,3],[1,20,30],[10,2,3],[10,2,30],[10,20,3],[10,20,30]]
11:58:14 <Cale> Well, it's only unintuitive until you understand the definition
11:58:19 <Cale> and have seen some examples
11:58:31 <nut> right, now i feel lost still
11:58:44 <nut> when i just read the abstract definition
11:58:56 <nut> it's algebra
11:59:08 <Cale> Something important to understand is that for the list monad, when you "run" a list, it means to pick an element from it in all possible ways
11:59:08 <nut> not yet tables and chairs
11:59:23 <EvanR> yeah you need concrete examples before going on to abstract, even if you get some abstract definition for what it is, then youre left wondering why anyone would care
11:59:24 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:59:25 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:59:46 <Cale> So here, we pick x from [1,2,3], y from [4,5] and z from [6,7,8], and produce a triple (x,y,z)
11:59:58 <Cale> and this is done in all possible ways, and we collect a list of the results
12:00:03 <nut> Cale, i get list comprension
12:00:14 <Cale> Right, so this is a generalisation of list comprehensions
12:00:25 <Cale> because all the stuff which will work with an arbitrary monad is going to work here
12:00:33 <Cale> @src sequence
12:00:33 <lambdabot> sequence []     = return []
12:00:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:00:33 <lambdabot> --OR
12:00:33 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:00:40 <nut> list comprehension is written in a more intuitive way
12:00:41 <Cale> Let's focus on that first definition there
12:01:01 <EvanR> i didnt think list comprehensions "are intuitive"
12:01:09 <Cale> sequence is a function which will take a list of actions, and run them all, collecting a list of the results
12:01:19 <EvanR> im trying to call into question a thing being intrinsically intuitive, and failing
12:01:39 <Cale> sequence [] = return [] -- if the list of actions is empty, we produce the action which does nothing except to result in an empty list
12:02:07 <Cale> sequence (x:xs) = ... -- if the list of actions is nonempty, consisting of some first action x, and the rest of the list xs...
12:02:23 <Cale> sequence (x:xs) = do v <- x; ... -- we run the first action x, getting some result v
12:02:25 <nut> Cale, yeah but the way you use it a few moments ago
12:02:32 <nut> isn't very sequence like
12:02:43 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then we run the rest of the actions, getting a list of results vs
12:03:01 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- finally, we return a combined list with all the results
12:03:18 <Cale> So, in the case of the list monad, we'll be putting in a list of lists, running each of them, and collecting a list of the results
12:03:30 <Cale> and what it means to run a list is to pick one element from it (in all possible ways)
12:03:34 <nut> > sequence [[1,2,3],[4,5],[6,7,8]]
12:03:35 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
12:03:45 <nut> where is the action ?
12:03:47 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return [x,y,z]
12:03:48 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
12:03:54 <Cale> "actions" are lists in this case
12:04:03 <Cale> and "running" one means picking an element
12:04:16 <nut> Cale, exactly, when you call a list an action, that's not intuitive
12:04:27 <Cale> Well, it turns out to work.
12:04:57 <nut> and where's the picking ?
12:05:06 <Cale> Well, look at the list of results
12:05:23 <Cale> each result here is a list [x,y,z] where x is an element of our first list [1,2,3]
12:05:32 <Cale> y is an element of our second list [4,5]
12:05:40 <Cale> and z is an element of our third list [6,7,8]
12:07:02 <Cale> One way you can think of it is to imagine that lists are computations which split the universe into as many copies as they have elements, and in each copy of the universe, we've selected one of the elements of the list (if the list was empty, we destroy the universe)
12:07:18 <nut> anyway i will be more powerful once i get a control on these functions
12:07:31 <Cale> and then when we get to the end, we produce some value
12:07:44 <nut> i'm practising on codewar and i see really some clever implementations
12:07:48 <nut> great way to learn
12:08:03 <Cale> and all the universes which survive to the end and produce their result, we collect up a list of the results
12:08:34 <Cale> > do x <- [1,2,3,4,5,6,7]; y <- if even x then [()] else []; return (x,y)
12:08:35 <lambdabot>  [(2,()),(4,()),(6,())]
12:08:50 <Cale> > do x <- [1,2,3,4,5,6,7]; if even x then [()] else []; return x
12:08:51 <lambdabot>  [2,4,6]
12:09:07 <Cale> > do x <- [1,2,3,4,5,6,7]; guard (even x); return x
12:09:09 <lambdabot>  [2,4,6]
12:09:38 <EvanR> its all the ways a non deterministic computation can finish, which could be no ways
12:09:45 <Cale> yeah
12:10:09 <Cale> If you've ever seen nondeterministic finite automata or nondeterministic Turing machines, it's much the same idea
12:10:37 <dfeuer> Is ST considered "portable"?
12:11:19 <Cale> dfeuer: I think so... it's very well understood at least, and only requires rank-2 types for runST, which Hugs supported.
12:12:44 <dfeuer> Cale, thanks. Still don't think I'm going to use it for non-GHC just yet, though.
12:13:00 <jle`> ST might be a nice thing to have in the new standard
12:13:11 <Cale> dfeuer: What other implementation of Haskell are you worried about supporting?
12:13:30 <Cale> GHCJS will support it obviously
12:13:51 <Cale> Actually, I should check that before I speak, I've never tried it
12:14:04 <Cale> But I'd be really surprised :)
12:14:05 <dfeuer> Cale, I dunno. containers used to support nhc98 and Hugs. It no longer tries to do so, but it generally tries to keep the generally portable stuff (CPP + bang patterns only) separate from non-portable stuff.
12:14:13 <Cale> ah
12:14:43 <dfeuer> But I haven't been able to figure out how to do what I'm trying to do without ST :-(
12:15:06 <dfeuer> Which is sad, because it's a very, very pure sort of thing ultimately.
12:16:57 <mjrosenb> heh, this talk of universes reminds me of quantum typechecking :-p
12:18:49 <ecclesiastes> exit
12:18:52 <ecclesiastes> ...
12:27:30 <hc> hi again
12:27:45 <hc> it seems there is no efficient way to copy the bytes of a  UArray Int Word8 to a Data.ByteString
12:27:53 <hc> any ideas?
12:28:29 <hc> I'm currently using arrayToBytestring = S.pack . elems, but that's creating a list in the process
12:29:05 <ggVGc> mjrosenb: what's quantum type checking?
12:29:10 <ggVGc> sounds like mumbo jumbo
12:29:33 <ggVGc> oh wait..
12:29:39 <ggVGc> quantum computations need special type systems eh
12:30:10 <ggVGc> like this? http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=450667
12:32:15 <shirt> hc: Use Data.Vector instead of UArray if you can
12:33:01 <hc> shirt: is vector otherwise as efficient as UArray?
12:33:17 <shirt> hc: yes, it is more efficient
12:33:21 <hc> oh cool!
12:33:28 <hc> yeah i'll try to use it instead, then
12:33:52 <hc> another question: currently for ~70mb of data I'm having a runtime of ~40 seconds if compiled with -threded, 19 seconds if compiled without
12:33:57 <hc> i'm running on an i7 quad core
12:34:22 <hc> I don't use any explicit parallelisation... Is there something I can do to make it run just as fast in the -threaded version?
12:35:59 <int-e> :t Data.ByteString.Short.Internal.SBS
12:36:00 <lambdabot> GHC.Prim.ByteArray# -> Data.ByteString.Short.Internal.ShortByteString
12:42:39 <joobus> Does anyone here have an opinion on elm vs pursescript vs haste?
12:43:00 <ggVGc> depends on what you want
12:43:06 <ggVGc> Elm has the best community by far
12:43:10 <ggVGc> but is also fairly infant
12:43:22 <ggVGc> haste has the benefit of being actually haskell
12:43:32 <ggVGc> purescript I think has some nice semantics that I sometimes wish haskell had
12:43:37 <ggVGc> especially the records are nice
12:43:53 <ggVGc> but the bad part of both elm and purescript is that you can't share code with a haskell backend code base
12:44:20 <int-e> hc: how about http://lpaste.net/167617
12:44:27 * hackagebot reflex-dom-colonnade 0.2 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.2 (andrewthad)
12:44:32 <ggVGc> personally I've been using Elm for a small client-only thing because I wanted to try it, and I've used ghcjs for an actual haskell web project where I had both backend and frontend
12:44:46 <ggVGc> joobus: Elm is great to get into FRP
12:45:00 <joobus> ggVGc: do you prefer elm over ghcjs?
12:45:35 <ggVGc> for completely different use cases
12:45:39 <ggVGc> not really comparable imo
12:46:18 <ggVGc> if you have both backend and frontend, I'd use GHCJS because of full code sharing. For a clientside thing, maybe Elm. But honestly if you know haskell, I'm not convinced Elm offers that much atm
12:46:19 <int-e> hc: (untested, but should work. that code still produces a copy which could be avoided if the bytearray is pinned...)
12:46:22 <ggVGc> it's fairly limited
12:46:33 <ggVGc> Elm is a stepping stone I feel
12:46:38 <joobus> elm seems to be all the rage on hacker news lately.  i don't see haste or purescript or ghcjs mentioned much at all
12:46:39 <ggVGc> at least atm
12:46:47 <ggVGc> Elm is very educational
12:46:50 <ggVGc> and has a great community
12:46:56 <ggVGc> ad has a good FRP implementation
12:47:06 <ggVGc> but if you know haskell, it'll feel restricted
12:47:49 <bernalex> elm is not frp.
12:47:57 <ggVGc> how so?
12:47:57 <hc> int-e: thanks!
12:48:04 <hc> making a copy is certainly cheaper than creating a list
12:48:28 <bernalex> ggVGc: in the same way it isn't a breed of horse, a banana, or a wormhole.
12:48:48 <ggVGc> I don't undetstand what you're saying
12:48:53 <puregreen> ggVGc: http://elm-lang.org/blog/farewell-to-frp, e.g.
12:49:04 <puregreen> (I don't know how much of FRP it was before)
12:49:14 <puregreen> (but now it seems to be Officially Not)
12:49:17 <ggVGc> oh.. they dropped the FRP implementation?
12:49:19 <ggVGc> awkward
12:49:27 * hackagebot harp 0.4.2 - HaRP allows pattern-matching with regular expressions  https://hackage.haskell.org/package/harp-0.4.2 (JeremyShaw)
12:49:28 <bernalex> puregreen: it wasn't.
12:49:29 <ggVGc> it used to be the main thing
12:49:32 <puregreen> 'kay
12:49:33 <ggVGc> hm, okay
12:49:42 <ggVGc> well, I used it in 0.14 and it sure felt like FRP to me
12:49:48 <ggVGc> but I don't know much abot FRP I guess
12:50:02 <ggVGc> everyone said it was an FRP implementation anyway
12:50:04 <ggVGc> including Evan
12:50:19 <EvanR> ggVGc: didnt they just drop the claim that it was frp...
12:50:32 <EvanR> its not that different
12:50:39 <ggVGc> I don't know
12:50:40 <hc> int-e: oh I just noticed that UArray internally uses a ByteString? :)
12:50:46 <ggVGc> I haven't been involved since 0.14
12:50:52 <ggVGc> ELm moves fast
12:50:59 <ggVGc> which is also why it'smaybe not so useful for real work
12:51:02 <ggVGc> but it's a bit fun
12:51:06 <EvanR> elm was in the camp of we can call it frp if we want no matter what
12:51:20 <ggVGc> I think it's great as an introduction to FP and the community is very supportive and helpful to people
12:51:40 <ggVGc> Elm made me actually get into haskell for real
12:51:44 <ggVGc> so it helped me
12:51:53 <ggVGc> but I don't really want to use it now
12:51:54 <jorrakay> how do you share data between front/back end with ghcjs? do you use json or something else? Just curious
12:52:04 <ggVGc> jorrakay: literally sthe same code
12:52:29 <Zekka> Does it really matter what you call it? It was an Applicative interface for dealing with side effects
12:52:40 <ggVGc> jorrakay: you could use Data.Binary, and serialise using it, and just send it between client and server with the same logic
12:52:44 <Zekka> names are usually not a very important part of things
12:52:45 <bernalex> EvanR: the change was that they removed the reactive component called 'signals'.
12:52:54 <Zekka> attaching a different name to something doesn't really change what it is
12:53:02 <bernalex> Zekka: there are no side-effects in Elm -- it is a purely functional language.
12:53:11 <jorrakay> ggVGc: is there an example of this kind of thing i can read somewhere? Thanks btw
12:53:22 <Zekka> bernalex: If I say "effects," does that make it better?
12:53:26 <EvanR> Zekka: well i got the feeling it and everything else for js calls itself that for attracting people and isnt really interested in telling you what it means
12:53:50 <bernalex> Zekka: it would make your statement correct, which is useful, so I'd say 'yes'.
12:53:55 <EvanR> so its disingenuous
12:53:57 <Zekka> Because this is basically the thing I'm talking about -- I don't think any meaning is transmitted by saying "FRP" at this point, and I don't think any meaning is lost
12:53:57 <ggVGc> jorrakay: it's not much to read about. GHCJS compiles any Haskell to javascript. That's the benefit of it
12:54:05 <sinelaw> How is ST implemented? I see STRef's use newMutVar#, readMutVar#, etc. - are those things magical built-in to the compiler?
12:54:10 <ggVGc> jorrakay: so if you have some haskell code, you can build it as javascript using ghcjs
12:54:30 <ggVGc> jorrakay: this means you can run the client on the server and even the server logic on the client if you wished
12:54:37 <EvanR> Zekka: meaning is transmitted most of the time, depends on who is speaking. a minority of people hearing will ignore it completely
12:54:38 <jorrakay> i mean some code that uses this practice to read
12:54:38 <ggVGc> anything that isn't IO will run exactly the same on both
12:54:47 <jorrakay> I'm familiar with the setup, i've done the same with js
12:54:51 <ggVGc> jorrakay: I have a small project I can send you, one sec
12:54:52 <int-e> sinelaw: yes, those are builtin primitives
12:55:01 <Zekka> if I say "side effects" -- my mistake, but I'm talking about a particular kind of interface where both of us know what it does
12:55:27 <EvanR> also not everyone auto knows what Applicative does
12:56:02 <Zekka> EvanR: Maybe it's not a good idea to use the words "FRP" or "Applicative",
12:56:16 <Zekka> But I think the important thing here is that terminology is a vehicle, it's not an end in itself
12:56:45 <EvanR> yeah im still at the level of only talking about what some system really is or does directly... which is usually omitted for frp systems
12:56:49 <Zekka> if someone misuses a word and that misuse has become more common, the problem isn't that the terminology is important and you've somehow failed it
12:56:56 <ggVGc> jorrakay: hm, actually, it's probably not useful for you at all.. sorry
12:57:08 <hpc> obligatory http://xkcd.com/
12:57:16 <Zekka> the problem occurs when people misunderstand each other because of it
12:57:21 <ggVGc> jorrakay: but, read this, https://hackage.haskell.org/package/binary-0.8.4.0/docs/Data-Binary.html
12:57:28 <EvanR> the problem is occurring
12:57:32 <ggVGc> you can derive binary instances, and then you have automatic serialization
12:57:40 <ggVGc> then you can send that over a HTTP request of a web socket or whatever
12:57:54 <jorrakay> no problem, thanks for the info!
12:58:01 <Zekka> EvanR: AFAICT the problem is being inflicted on learners by pedants who think that one very specific formulation of a pattern that gets you this interface is the true formulation
12:58:02 <hpc> but in a technical context, you depend on language being not necessarily one thing or the other, but being consistent
12:58:18 <johnw> are we discussing the meaning of "FRP"?
12:58:20 <jorrakay> another general question on the topic: are there libs for haskell that make WebZone programming as easy as Elm?
12:58:27 <ggVGc> EvanR: I barely understand Applicative personally..
12:58:30 <EvanR> Zekka: pedants like the elm guy? im a learner by this measure
12:58:46 <Zekka> EvanR: The Elm guy's not the guy being dogmatic about the definition of "FRP" here
12:58:47 <puregreen> johnw: no, at this point we're discussing discussions about the meaning of FRP and similar ones
12:59:07 <EvanR> i have 25 lines here im not sure who is or why it matters
12:59:38 <Zekka> You're kinda the person I'm griping about in this discussion
12:59:42 <EvanR> why?
12:59:47 <hc> int-e: "Pattern bindings containing unlifted types should use an outermost bang pattern" 
12:59:56 <Zekka> You previously asserted that Elm isn't FRP, and you're correct that there's a specific definition of FRP which does not include elm.
12:59:58 <hc> int-e: That's what I'm getting for the line (UArray _ _ _ a) = ...
12:59:59 <ggVGc> puregreen: can we abstract this discussion into a general discussion concept and write a module for it so we can reuse it over all similar discussions about discussions?
13:00:06 <EvanR> today?
13:00:16 <puregreen> ggVGc: that's what Lesswrong does
13:00:29 <Zekka> Yes, in agreement with something bernalex also said
13:00:37 <bernalex> EvanR: the "words don't mean anything" camp isn't really worth arguing with ime.
13:00:38 <EvanR> o_O
13:01:09 <EvanR> ok
13:01:11 <puregreen> Zekka: I would suggest moving the discussion somewhere else, not even because it's offtopic but because discussions like this one are ones that everyone wants to say something about (like I'm doing) and so it's very hard for others to not produce more offtopic :)
13:01:21 <Zekka> puregreen: Yeah, I'll bow out
13:01:28 <Zekka> the last few times I've seen this happening nobody changed their minds
13:01:28 <hc> int-e: ah, solved it!
13:01:37 <Zekka> It's kind of a pet peeve for me, I shouldn't leap on it
13:01:59 <puregreen> Zekka++
13:02:10 <hc> int-e: works, thank you! :)
13:02:41 <joobus> so is ghcjs better than haste?  haste has the younger commit on github, so that means it's better right?
13:03:03 <hc> int-e: it reduced the time by another 5 seconds from 19 to 14 seconds
13:03:24 <int-e> nice!
13:03:31 <geekosaur> that kind of logic gets you using the biuggiest stuff because it has more commits
13:03:51 <hc> still the original C code needs .65 seconds for the same payload... ;)
13:03:55 <ggVGc> joobus: my take is this. Elm is good for being introduced to FP if you're not comfortable with it, and will get you interesting things going fast. GHCJS is probably the most useful overall because you can share all code on client and server. Haste is less useful than GHCJS in that sense(doesn't support everyting ghc does), but produces smaller output and has a nicer FFI I think.
13:04:12 <c_wraith> joobus, haste is better if you want small js. ghcjs has much support for existing code. 
13:04:17 <ggVGc> joobus: Purescript is a bit weird because it's "kind of haskell, but not really" so you can't really share code
13:04:21 <boek> FFI?
13:04:33 <ggVGc> boek: foreign function interface. I.e what you use to interact with other JS code
13:04:49 <boek> ggVGc: Ah, gotcha. Thanks!
13:04:53 <ggVGc> joobus: personally I use GHCJS currently, and most people are gravitating towards it
13:05:05 <ggVGc> I think haste will be dead within 5 years from now
13:05:08 <merijn> Zekka: Elm *isn't* FRP and the only reason people call it FRP is because, due to unlucky circumstances, people in the JavaScript/fad language du jour communities have come up with these "reactive" frameworks and they figure that "Elm is a functional language" and "Elm is like our reactive frameworks", therefore "Elm is Functional Reactive Programming". Meanwhile Elm, afaik, doesn't meet the main criterium 
13:05:11 <ggVGc> and ghcjs will produce much better output
13:05:39 <Zekka> merijn: I see what happened to the word "isomorphic" as suitable punishment for using the word "isomorphic" too dang much =)
13:05:45 <ggVGc> merijn: also, Evan(the elm guy, not EvanR) stated it himself many times
13:06:12 <merijn> of being FRP
13:06:15 <ggVGc> joobus: I think, if you can get GHCJS up and running(sometimes hard) and don't mind the file size, then use that.
13:06:21 <ggVGc> it's the most practically useful
13:06:35 <joobus> ggVGc: what kind of file size are you seeing/using?
13:06:44 <ggVGc> joobus: with GHCJS you can build ANY module on hackage. Haste has issues with several.
13:06:50 <ggVGc> lemme check
13:07:14 <ggVGc> joobus: I think most people get around 1mb
13:07:16 <c_wraith> ggVGc, be careful with your universal quantifiers. :) 
13:07:17 <ggVGc> so it's quite a lot
13:07:27 <joobus> ggVGc: yes, that is a lot
13:07:27 <ggVGc> c_wraith: well...yea, okay
13:07:36 <ggVGc> c_wraith: but significantly more than with haste anyway
13:07:48 <c_wraith> ggVGc, good luck with any package that creates primops or binds to C code. :) 
13:08:07 <ggVGc> joobus: if you read a bit online though, you'll find that many people start with haste, and then end up porting to GHCJS because modules from hackage they want to use don't compile
13:08:25 <ggVGc> c_wraith: yeah, but it's not that many honestly. And very few of those are ones you want to compile to JS
13:09:33 <ggVGc> joobus: personally purescript is out of the question for me, since it looses too much of the benefits by being "almost haskell"
13:09:40 <EvanR> looks like elm now does the same as Rx does the same as the observer pattern in C++
13:09:41 <ggVGc> even though it has nice semantics and good FFI
13:09:57 <joobus> ggVGc: that's about what i think of elm
13:10:07 <joobus> ggVGc: it's almost decent
13:10:26 <ggVGc> joobus: right, and Elm also has the issue of being very new and very moving. HEnce why I think it's good as an education tool, but maybe not for projects
13:10:45 <c_wraith> I feel like purescript made a bizarre choice with strictness. it's almost haskell, except for the ability to decompose producers and consumers! 
13:11:05 <ggVGc> joobus: purescript and elm are both nice, but the fact you can't share code with a haskell backend makes it not so intersting imo
13:11:33 <ggVGc> also Elm is really hard to abstract in currently
13:11:38 <ggVGc> and if you do any haskell, you'll miss it
13:11:42 <frew> is there a command I can use to ask stack if setup will do anything?
13:12:03 <frew> basically I want to run stack setup only if I need to
13:12:22 <ggVGc> won't it just do nothing?
13:12:32 <frew> yes; this is sorta just for logging
13:13:41 <EvanR> ggVGc: not being able to share code with haskell also eliminates... a lot of languages
13:13:45 <EvanR> past and future
13:13:47 <bernalex> c_wraith: isn't that just a "it's easier b/c js" decision?
13:15:46 <bernalex> ggVGc: it seems that the logic you are appealing to is that if I say that I am a porcupine many times, I am a porcupine, and everybody needs to change their worldview in order to accommodate me.
13:16:18 <ggVGc> EvanR: yeah, but what I mean is. If you want to write something haskellish, which both elm and purescript are. THen I'd rather write actual haskell and use GHCJS to run it both on server and client
13:16:23 <merijn> Zekka: A bit late due to my internet being horrific shit atm, but...I'm going to have to strongly disagree with you. Elm isn't FRP by the only definition that matters
13:16:23 <merijn> Zekka: Elm *isn't* FRP and the only reason people call it FRP is because, due to unlucky circumstances, people in the JavaScript/fad language du jour communities have come up with these "reactive" frameworks and they figure that "Elm is a functional language" and "Elm is like our reactive frameworks", therefore "Elm is Functional Reactive Programming". Meanwhile Elm, afaik, doesn't meet the main criterium 
13:16:23 <merijn> of being FRP
13:16:25 <frew> I'm just gonna check for the existence of the version of the compiler I'm looking for.
13:16:52 <comerijn> So...did I actually manage to stay online long enough to send a message last time, or?
13:16:52 <ggVGc> bernalex: hm? not sure I understand
13:16:55 <ggVGc> what am I arguing?
13:17:01 <ggVGc> I was just answering joobus question
13:17:09 <ggVGc> he asked if anyone had opinions about these varoius languages
13:17:12 <ggVGc> so I said my opinions
13:17:21 <bernalex> ggVGc: you keep saying that Evan says it's frp. that does not make it so.
13:17:28 <bernalex> it is not an argument whatsoever.
13:18:05 <comerijn> Right, so based on this context I'm guessing that my insistent complaint that Elm is *not* FRP didn't manage to arrive before my internet died
13:18:17 <ggVGc> bernalex: I was answering merijin. I meant that the reason people perceive it as frp regardless of if it is or isn't isn't just a JS community thing. It's also because the creator said so
13:18:21 <ggVGc> I have no opinion either way
13:18:25 <ggVGc> I don't know much about frp as I said
13:18:31 <ggVGc> and I only used elm a little bit
13:18:36 <mizu_no_oto_work> c_wraith: strictness makes more sense if you value straightforward compilation to a strict language 
13:18:42 <ggVGc> and I thought it was frp, but also don't really care
13:18:47 <ggVGc> I thought the signals were nice
13:18:59 <ggVGc> regardless of what the correct term is
13:19:28 <bernalex> I thought they were nice enough to use. I also liked foldp.
13:19:53 <mizu_no_oto_work> c_wraith: It makes it easier to consume Purescript code from JS
13:19:59 <ggVGc> but I really used Elm as a stepping stone to get into haskell for real
13:20:06 <ggVGc> and I think that's it's main use atm
13:20:10 <mizu_no_oto_work> Even if it makes writing purescript harder
13:21:46 <ggVGc> but the main reason I wouldn't really use Elm for anything long term is that it might not even be the same language in any way in 6 months
13:21:51 <ggVGc> like, the removal of signals now
13:22:09 <ggVGc> it's essentially an experiment in bringing FP to more people, which I think is great
13:22:14 <ggVGc> but not for long term project work
13:23:12 <mjrosenb> ggVGc: not quite.
13:23:23 <mjrosenb> ggVGc: have you heard of quantum bogosort?
13:23:36 <mizu_no_oto_work> Purescript is also currently following the maxim 'move fast and break stuff' 
13:23:41 <ggVGc> mjrosenb: I have not at all.
13:23:48 <ggVGc> you are living a decade ahead of me
13:23:49 <mjrosenb> ggVGc: shame
13:23:52 <ggVGc> :)
13:23:54 <mjrosenb> have you heard of bogosort?
13:24:01 <ggVGc> no heh
13:24:17 <mizu_no_oto_work> The last few purescript compiler versions have all had breaking changes
13:24:19 <magneticduck> hey, can TH generate TH?
13:24:27 <ggVGc> ph dear
13:24:28 * hackagebot wl-pprint-terminfo 3.7.1.4 - A color pretty printer with terminfo support  https://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1.4 (EdwardKmett)
13:24:29 <ggVGc> oh*
13:24:51 <puregreen> magneticduck: I think I saw it in some library
13:24:52 <ggVGc> mjrosenb: oh, right, yeah I have
13:24:53 <mizu_no_oto_work> ggVGc: bogosort is basically "generate a random permutation until the list is sorted"
13:24:53 <ggVGc> a long time ago
13:24:55 <puregreen> store, maybe
13:25:10 <EvanR> ggVGc: i know... so a not as extreme conclusion is that if you like haskell, you have to live with its warts forever since something haskell like but not will never be original haskell
13:25:12 <ggVGc> yeah, I only know of bogosort since my data structures and algorithms class 10 years ago
13:25:16 <ggVGc> had forgotten the term
13:25:51 <mizu_no_oto_work> quantum bogosort relies on the many worlds interpretation of quantum mechanics
13:26:12 <ggVGc> EvanR: I'd go for a functional language that is similar to haskell and runs on both client and server. I actually even started writing a native backend for Elm, through Nim, but then realised I don't want to use it because of the lacking tools for abstracting in elm currently
13:26:17 <merijn> Welp...my whole rant on the meaning of FRP is being undercut by my inability to type even one message before my internet dies
13:26:29 <ggVGc> EvanR: if purescript had a good implementation for running server side I might use it
13:26:35 <puregreen> magneticduck: http://hackage.haskell.org/package/th-utilities-0.1.1.0/docs/TH-Derive.html
13:26:36 <mjrosenb> ggVGc: quantum bogosort is similar; just randomly permute your list. if it is sorted, they you're good! if it isn't, destroy the universe.
13:26:37 <mizu_no_oto_work> It's bogosort that runs quickly, based on the powerful technique of 'generate a random permutation and destroy the universe if you guessed wrong'
13:26:37 <hpc> spaghetti sort is best sort
13:26:39 <ggVGc> but as it stands haskell is actually pretty good
13:26:55 <puregreen> I think double $s mean that it's TH generating TH, but I'm not 100% sure
13:27:22 <kadoban> What's spaghetti sort, the O(n) one with actual spaghetti?
13:27:44 <hpc> it's another quantum sorting algorithm
13:27:54 <hpc> it works similarly to the physical variant
13:28:13 <mizu_no_oto_work> so the only universes where it continues to run are the ones where you guessed right
13:29:11 <ggVGc> I don't want my universe to be sorted
13:29:12 <ggVGc> souds boring
13:29:16 <mjrosenb> so quantum typechecking is similar... you give every expression a random type, if your program typechecks, then yay! if it doesn't, then destroy the universe
13:29:16 <ggVGc> I'd rather live in spaghetti
13:29:24 <ggVGc> that sounds pretty cool
13:29:43 <ggVGc> if only I had a quantum computer to try it out on..
13:29:45 <hpc> just prove string theory
13:29:52 <mjrosenb> a nice consequence of this is that it is now impossible to even write a program that isn't typesafe.
13:31:00 <mizu_no_oto_work> Impossible?  Or just suicidal?
13:31:27 <ggVGc> why suicidal?
13:32:19 <ggVGc> mjrosenb: could we write a quantum type checking implementation and run it on GPUs reasonably?
13:33:07 <mjrosenb> ggVGc: probably not, since last time I checked, gpus are not capable of destroying the universe.
13:33:29 <mizu_no_oto_work> If you destroy every universe that the program doesn't typecheck in, and the program has a type error, then you'll destroy every universe
13:33:52 <ggVGc> I figured you'd run one universe per gpu core
13:34:04 <ggVGc> and each would result in either something or nothing
13:34:05 <geekosaur> many worlds interpretation... presumably one "copy" of you continues to exist somewhere. (replacing the "collapsed wave function" in te Copenhagen interpretation)
13:34:19 <mjrosenb> mizu_no_oto_work: except the ones where you wrote a program without type errors.
13:34:37 <geekosaur> ...and yes, some of those will have other type errors, but at leats one will have fixed the type error you accidentally added :)
13:34:46 <EvanR> never trust programmers with quantum physics
13:34:53 <ggVGc> never trust programmers.
13:34:58 <EvanR> never trust
13:35:03 <ggVGc> trust.
13:35:23 <ggVGc> what a lovely poem
13:35:33 <hpc> five, seven and five
13:35:37 <hpc> syllables make a haiku
13:35:39 <hpc> remarkable oaf
13:36:01 <mizu_no_oto_work> I think Ken Thompson had some remarks on trusting trust
13:36:18 <ggVGc> is trust typesafe?
13:36:26 <hiptobecubic> haikus are easy
13:36:35 <hiptobecubic> but sometimes they don't make sense
13:36:38 <mjrosenb> is trust well specified?
13:36:41 <hiptobecubic> refrigerator
13:36:55 <ggVGc> mjrosenb: depends on which universe you are running...
13:37:10 <mizu_no_oto_work> interestingly, Japanese haiku are rather shorter than English haiku
13:37:11 <EvanR> are specifications trustworthy
13:37:31 <mizu_no_oto_work> since it's 5-7-5 mora in Japanese, not syllables
13:37:49 <ggVGc> I never understood the point of haikus
13:38:02 <ggVGc> or why the western world seem to have gone a bit obsessed with them
13:38:02 <hiptobecubic> teaching primary school students about syllables.
13:38:31 <mizu_no_oto_work> ggVGc: have you looked at actual Japanese haiku?
13:38:50 <ggVGc> only as in seen it, but since I don't know japanese it doesn't mean anything to me
13:38:56 <mjrosenb> I feel like saying haiku are about counting syllables is like saying that haskell is about monadic IO.
13:39:27 <mizu_no_oto_work> They're a short poem about nature, with two distinct thoughts that are typically compared/contrasted
13:39:31 <roboguy`> ggVGc: well, the same point as most poetry I suppose. Poetry has been based around rhythmic units for thousands of years
13:39:44 <hiptobecubic> Well for most people in the West, I think the only exposure to Haiku was when learning about syllables in school. It's not like you see outside of that.
13:39:49 <ggVGc> but why did the western world start adapting a japanese form of poem structure?
13:39:53 <hiptobecubic> Maybe on the odd motivational poster lately
13:40:13 <hiptobecubic> You must admit though, it's a nice format.
13:40:15 <roboguy`> ggVGc: that I don't know the answer to
13:40:28 <EvanR> east and west collide
13:40:37 <hiptobecubic> I am a giant; I am seriously tall; It's hard to buy pants
13:40:55 <ggVGc> I hear people mention "haiku" way more than I hear names of western poetry formats
13:40:59 <EvanR> lets do haskell haikus
13:41:00 <roboguy`> I guess the shortness of it can be appealing and it's a nice break from iambic pentameter?
13:44:25 <hiptobecubic> Badges of honor; Writers confuse the Readers; Monanalogies
13:49:30 * hackagebot fltkhs 0.4.0.8 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.8 (deech)
13:49:32 * hackagebot hascar 0.2.0.0 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.2.0.0 (hc)
13:49:32 <mizu_no_oto_work> ggVGc: My guess is that counting syllables is easy compared to counting meter and rhyming
13:57:21 <xaviergmail> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies." How much of this is true?
13:57:49 <Zekka> xaviergmail: There are a few people here who are imho pretty condescending sometimes, but I think most people are interested in helping
13:58:18 <Zekka> I think there are a lot of people here who have a distorted view of what's important to newbies, and it's very common for people to underestimate how difficult the subject matter they're covering will be
13:58:34 <puregreen> I'd give #haskell 11/10 for patience
13:58:43 <merijn> Zekka: People in here condescending? :O
13:58:45 <Zekka> so you run into people who nonchalantly suggest very complex abstractions for problems that aren't that hard
13:58:59 <xaviergmail> As to be expected with any irc community I presume 
13:59:11 <Zekka> But definitely unusually patient, and there are a lot of people who really do want to teach
13:59:29 <merijn> Compared to my run ins with the C, C++, Java, and python IRC channels this place is filled with geniuses and saints, imo
13:59:32 <Zekka> merijn: I think there's a lot of "Oh, it's actually easy." or "here, this will blow aside the other models you ever considered"
13:59:39 <Zekka> But yeah, this is better than almost all of those channels
13:59:53 <xaviergmail> Sweet
13:59:54 <Zekka> some of the worst experiences I've ever had getting tech support on IRC were in the C and Java channels
13:59:59 <joehillen> It's hard to talk to expert beginners
14:00:00 <merijn> Zekka: The alternative would be that smart people never mention anything
14:00:10 <xaviergmail> I considered #python to be a decent resource
14:00:14 <merijn> Zekka: I like #haskell because you can learn stuff at ANY skill level
14:00:30 <Zekka> merijn: I think it's less "what gets mentioned" and more "am I mentioning this stuff because it addresses a need for you, because I think it's cool, or because it feeds my ego?"
14:00:31 <merijn> You just have to accept that at times 50% off the channel will go over your head
14:00:45 <dmj`> 50% seems high :)
14:00:49 <Zekka> I'd say that a lot of help is motivated by "because I think it's cool", which is better than "because it feeds my ego" but not as good as "this will exactly feed your needs"
14:00:50 <dmj`> er, low :)
14:01:06 <puregreen> merijn: I agree about geniuses and saints, it's just that some of the geniuses aren't saints and vice-versa, so overall the experience will vary depending on who you meet
14:01:32 <merijn> Zekka: I tend to be more optimistic about people and assume that they're wanting to share things you might not be ready for and that's fine. Just say "thanks, but I have no clue what that means" and shelf it for later thought
14:01:49 <Zekka> merijn: FWIW I'm guilty of speaking on behalf of hypothetical people here
14:02:08 <Zekka> it's been a while since I was a haskell learner and I'm trying to crossreference #haskell with my experience with learners from elsewhere
14:02:16 <Zekka> (this is not the community where I do the most tech support)
14:02:36 <Zekka> I think a lot of the learners I usually deal with would not have a lot of patience for #haskell, and they're probably underrepresented when you ask "what do you guys think of the channel?"
14:03:14 <Zekka> Obviously I had patience for all the stuff I didn't understand, and the stuff people just talked about because it was cool, but then I tried sharing that stuff with people who really had no particular interest in theory, golf, stuff that's just cool
14:03:33 <Zekka> and I foudn out that a lot of the learners I knew had a low tolerance for that kind of thing, because it didn't solve their problems
14:03:34 <xaviergmail> Fair enough, and do you guys have any opinions on learnyouahaskell.com 
14:03:40 <merijn> Zekka: I've heard people argue before that people using terminology/designs/whatever that you don't understand is "condescending", which I disagree with in the first place. But furthermore, I've never had a case where something was mentioned here and people were not willing to explain further
14:03:52 <merijn> xaviergmail: A bit dated in terms of usefulness
14:03:58 <joehillen> xaviergmail: I'm not a fan, but I'm pretty sure I'm the only one
14:04:08 <merijn> xaviergmail: See https://github.com/bitemyapp/learnhaskell and the new Haskell Book
14:04:12 <joehillen> xaviergmail: I've heard very good things about haskellbook.com
14:04:27 <ggVGc> haskell is by far the most helpful place I've ever been trying to learn something online
14:04:32 <merijn> joehillen: Well, most of the people like me, who liked LYAH read LYAH when it was the only thing besides the tutorial :p
14:04:35 <maks> xaviergmail: personally i've enjoyed a lot learnyouhaskell.com, was the most useful to get started actually
14:04:35 <ggVGc> people here have spent hours essentially giving me private lessons
14:04:42 <puregreen> joehillen: you're not the only one, people have been annoyed with various aspects of LYAH for some time by now
14:04:45 <merijn> @quote Brend piranha
14:04:45 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
14:04:54 <xaviergmail> Alright thank you for the options
14:05:07 <xaviergmail> lol
14:05:14 <shachaf> For what it's worth I don't recommend that book at all.
14:05:21 <merijn> shachaf: Which one?
14:05:24 <ggVGc> I think a lot of the haskell wiki is fairly badly written for people trying to learn things, unfortunately
14:05:28 <merijn> shachaf: bitemyapp's?
14:05:34 <shachaf> Yes.
14:05:35 <ggVGc> but I am not at a level where I could improve it
14:05:36 <shachaf> At least, based on the parts of it that I've read.
14:05:45 <joehillen> shachaf: which book?
14:05:46 <merijn> shachaf: hmmm, I liked the parts that I read
14:05:51 <EvanR> ggVGc: the wiki is in need of love 
14:06:03 <ggVGc> I often try to learn stuff from it, and just end up giving up
14:06:14 <jackhill> there is also #haskell-beginners where the same stuff is on topic as here except that the assumption is that people are less experienced and are reminded to use useful teaching techniques.
14:06:41 <bernalex> or told to "shut up" because they're "not helping right".
14:06:44 <EvanR> well #haskell-beginners was probably founded on what Zekka's opinion earlier was
14:06:48 <maks> xaviergmail: there is also a great page called "things I wish i knew when i started learning haskell" by dahl (I think?)
14:06:50 <shachaf> Note that beginners are welcome in #haskell. That channel is unrelated to this one.
14:06:54 <joehillen> ggVGc: Failing and retrying are actually essential steps for learning something as different and Haskell
14:06:56 <bernalex> or was that that other channel which now changed its name to something non-haskell?
14:07:11 <Cale> Yeah, I'm still pretty upset about the naming of #haskell-beginners
14:07:15 <shachaf> The second edition of Hutton's book, _Programming in Haskell_ will be out in a couple of months. I've only read the first edition, but I recommend it.
14:07:27 <bernalex> #haskell is the best channel for all haskellers, including beginners.
14:07:33 <maks> xaviergmail: here dev.stephendiehl.com/hask/tutorial.pdf
14:07:33 <shachaf> Cale: And of haskellbook.com and so on, for that matter.
14:07:52 <xaviergmail> Thank you maks 
14:07:55 <bernalex> shachaf: Cale: I agree. it seems hostile.
14:07:58 <ggVGc> joehillen: yeah, but the wiki isn't writtenin a good way
14:08:06 <ggVGc> most of it at least
14:08:25 <EvanR> the wiki seems to be a stream of consciousness with half links broken
14:08:30 <ggVGc> pretty much
14:08:32 <mgsloan> Better than #haskell-noobs!
14:09:07 <EvanR> but its probably reaching "ancient" status at this point
14:09:09 <Cale> We used to have a really good wiki which was very productive and which many people used to communicate, back before it got switched to MediaWiki
14:09:28 <EvanR> whoa really
14:09:31 <bernalex> according to the wiki '#haskell-beginners' is 'Haskell people focused on teaching and learning Haskell, not just beginners.' that would be exactly what #haskell is for.
14:09:32 <Cale> and then it immediately became dysfunctional
14:10:09 <bernalex> mediawiki is a gigantic pita for everyone. I wish we could do something about it. but IMO the haskell.org development process is not clear and transparent enough.
14:10:13 <joehillen> yeah, the mediawiki should probably be taken down. It lacks proper maintainers, which are essential for having a good wiki. The current wiki lacks a sense of ownership
14:10:39 <mgsloan> Yeah, perhaps it should be frozen with a message at the top
14:10:40 <ggVGc> I think everyone seems to essentialyl have given up on it
14:10:43 <ggVGc> unfoertunately
14:10:59 <EvanR> hey i signed up to fix something
14:11:08 <ggVGc> maybe a new wiki needs to be started
14:11:15 <EvanR> it wasnt as easy as wikipedia but
14:11:15 <merijn> bernalex: There isn't really one. If someone is willing to invest the time and nows a better wiki solution I'm sure it'd be welcome
14:11:19 <ggVGc> and knowledge manually transcribed from the old to the new
14:11:21 <ggVGc> in a better format
14:11:26 <joehillen> I've not super thrilled with the current infrastructure team
14:11:34 <Cale> We need a wiki which people will feel comfortable with *having conversations* in
14:11:47 <Cale> As soon as you use MediaWiki, people stop doing that
14:11:57 <ggVGc> why was it switched?
14:11:59 <Cale> for no really good reason except that it's disallowed on wikipedia
14:12:04 <hpc> what about mediawiki discourages conversation?
14:12:10 <hpc> ah
14:12:15 <EvanR> talk pages
14:12:20 <bernalex> merijn: in my view this would be much simpler if haskell.org had a contribution section about the development process. of course the process would need to be sufficiently transparent.
14:12:27 <Cale> Yeah, there's separate talk pages which nobody ever sees
14:12:27 <joehillen> does gitit support talk pages?
14:12:38 <bernalex> tbf 'anyone' could probably set up a wiki on their own, and migrate stuff there, and go "hey guys, look how much better this is".
14:12:40 <mizu_no_oto_work> Perhaps something based on c2 would encourage discussion?
14:12:48 <Cale> I don't want talk pages, I want inline conversations which gradually get edited into the article.
14:12:49 <ggVGc> I Like the c2.com format a lot
14:12:52 <joehillen> ugh, c2 is the worst!
14:12:53 <hpc> is registering for edit access on the haskell wiki even possible?
14:12:58 <hpc> or does it need to be approved?
14:13:05 <ggVGc> http://c2.com/cgi/wiki?HaskellLanguage
14:13:08 <ggVGc> that's nice
14:13:09 <ggVGc> I think
14:13:21 <EvanR> c2 the software might have the same issue as wikipedia the software
14:13:21 <hpc> imo now that we have hackage2 we should lump the wiki under that login
14:13:22 <bernalex> hpc: IIRC you email someone with the username you want, and they enable it when they get 'round to it.
14:13:22 <merijn> bernalex: It's mostly a matter of just mailing the relevant mailing lists, all of which are public, afaik
14:13:29 <Cale> Yeah, the old wiki was running moinmoin which is a lot more in the style of c2
14:13:31 <EvanR> that people feel like they need to act like C2 on it
14:13:49 <hpc> simply under the selfish interest of i want a wiki account for free
14:13:52 <bernalex> hpc: which feels needlessly arduous, considering places like wikipedia aren't that annoying. but then again, I think the haskell.org people never groked how to fight spam properly.
14:14:00 <Cale> I'd be much happier with people emulating c2 than emulating wikipedia -- we don't really need another wikipedia
14:14:01 <bernalex> merijn: that's not good enough.
14:14:10 <Cale> But it would be nice to have a place to have semi-static discussions
14:14:26 <Cale> that gradually get organised into a useful resource
14:14:29 <bernalex> merijn: it leads to your polling of (busy) people for information until you can't be bothered any longer. I've been through this with haskell infrastructure before.
14:14:43 <EvanR> well, you could gradually organize the existing wiki
14:14:52 <hpc> terrible terrible idea: make the haskellwiki use trac like the ghc wiki
14:15:00 <Cale> The problem is that the existing wiki is full of *articles* rather than discussion
14:15:02 <bernalex> hpc: I don't think it's so very terrible.
14:15:20 <ggVGc> Cale: weirdly written articles that are barely helpful to anyone who doesn't already understand what the content describes
14:15:23 <Cale> yes
14:15:32 <bernalex> Cale: we could stand to have both.
14:15:40 <hpc> bernalex: i guess maybe it could work
14:15:50 <hpc> it'd be weird with having a bugtracker for absolutely nothing tacked onto it
14:15:58 <Cale> Usually written by someone who has just barely understood the thing which they're writing about, because that's when people are most excited to write about something.
14:16:00 <bernalex> Cale: however, I'm not convinced a public wiki where anyone can change things without review or moderation is a good solution for the article side of things.
14:16:13 <hpc> i guess you could write bugs for things like "this page sucks, it needs to be redone"
14:16:31 <bernalex> we could have explanatory articles that are maintained by some resident expert, and then devote most of the wiki to discussions and informal things in general.
14:16:41 <merijn> bernalex: Sure, but if you feel strongly about that you could always lead the way in proposing a workflow/management model for the infrastructure, I'm not quite sure what you expect the people involved to do?
14:16:47 <bernalex> Cale: what is 'c2'?
14:17:04 <Cale> http://c2.com/cgi/wiki?HaskellLanguage -- an old wiki
14:17:07 <EvanR> do we even need explanatory articles written by an expert, that seems like a tall order to block on
14:17:28 <EvanR> the discussion format seems better than what we have
14:17:28 <bernalex> merijn: that will likely also lead to polling of people who don't have time to answer, until that gets old. and it gets old. quickly.
14:17:37 <hpc> that url screams old all by itself
14:17:43 <hpc> no www, 2-character domain name
14:17:46 <hpc> a /cgi directory
14:17:51 <hpc> and bare get params
14:17:52 <merijn> bernalex: So what do you think should be done?
14:18:09 <joehillen> The wikibooks site is actually pretty good. I've learned a lot from it https://en.wikibooks.org/wiki/Haskell
14:18:15 <merijn> bernalex: You don't know c2? They invented the wiki :)
14:18:16 <EvanR> its an old wiki... it was the original wiki
14:18:21 <bernalex> merijn: what I said. a contribution page that makes everything very transparent, with simple processes for contributing.
14:18:28 <ggVGc> hpc: I am not so much talking about the actual c2 site, but the way it works
14:18:31 <ggVGc> I like how people participate
14:18:42 <bernalex> merijn: no, I don't know c2. I would not have asked what it was if I knew what it was.
14:18:48 <Enigmagic> Cale: wasn't it the original wiki?
14:18:55 <Cale> Enigmagic: yes, I believe so
14:18:57 <merijn> bernalex: And whose supposed to define what is transparent and what the process should be?
14:19:12 <hpc> ggVGc: i found you have to know in advance what you are looking at in order to get through a c2-style page on your first pass
14:19:20 <EvanR> yes jimbo wales didnt invent wikis, neither did the guy who said hello to at the water cooler
14:19:32 <bernalex> merijn: the people who run the thing.
14:19:42 <ggVGc> c2 isn't very good, content-wise, maybe. But something c2-like could be good content-wise I think
14:20:00 <ggVGc> and I thin it encourages participation in a better way
14:20:01 <Cale> Well, content is secondary to communication.
14:20:04 <ggVGc> than something wikipedia-like
14:20:16 <puregreen> hpc: maybe c2 appeals more to people who'd rather read lots of text if they know it would eventually give them an answer to their question, while more coherent wikis are for people who can't be bothered?
14:20:19 <bernalex> well, again, with the wiki, anyone could just set up a wiki. post it to reddit etc.. might be an interesting exercise.
14:20:27 <EvanR> if we had sometihng like c2, we could have good a c2-like wiki with good content, if we had some good content
14:20:37 <merijn> bernalex: It's not really run so much as "fires put out in a JIT fashion", hence why I suggested writing such a workflow/process
14:20:58 <okek> hpc: wouldn't the existence of "www" scream old much more?
14:21:09 <hpc> www.www.extra-www.com
14:21:14 <bernalex> merijn: that's a too demotivating process for I think anyone to bother undertaking, when they have no assurance that the people in charge would even bother reading it at all.
14:21:21 <puregreen> bernalex: set up a wiki, then fill it with lots of content that would be written in a style that would encourage future participants to write in a similar style 
14:21:29 <Cale> heh
14:21:32 <puregreen> that's not so easy
14:21:47 <hpc> dammit that doesn't exist anymore
14:21:48 <Cale> Well, you start with one page: a question page
14:21:57 <EvanR> just start by copying c2's content, existing haskell wiki's content, and smush them together
14:21:58 <merijn> bernalex: So, petition to become one of those people and then dictatorially impose said process
14:21:59 <ggVGc> and then the monad page!
14:22:03 <Cale> ahaha
14:22:14 <Cale> and then IRC quote page
14:22:20 <ggVGc> and then the "actually don't use monads, use applicative" page
14:22:27 <merijn> bernalex: You're saying "people are too busy to listen" and then expecting them to not be to busy to invent a process instead?
14:22:37 <EvanR> dont use applicative, use monoidal categories
14:22:38 <Cale> and then "do notation considered harmful"
14:22:39 <hpc> applicatives are like hot dogs
14:22:52 <bernalex> merijn: I think you are confused. I don't personally feel like being in charge. I am merely pointing out that the situation is problematic.
14:22:54 <ggVGc> EvanR: and finally we end up in the category of endofunctors
14:22:58 <Cale> and then you burn the thing to the ground and start over
14:23:03 <Cale> lol
14:23:04 <ggVGc> and then the wiki is done
14:23:05 <bernalex> flamebait is a nice way to encourage people.
14:23:13 <hpc> actually, what is it that makes the haskell infra people slow to create accounts for people?
14:23:13 * EvanR pours salt on the burning flames of this idea
14:23:21 <bernalex> write all the examples imperatively in IO
14:23:22 <hpc> do they just check their email once a month or something?
14:23:29 <merijn> bernalex: The problem is that everyone else currently involved ALSO doesn't feel like being in charge
14:23:35 <merijn> bernalex: So if not you, who then?
14:23:51 <EvanR> merijn: randomly chosen
14:23:53 <merijn> bernalex: The situation will remain problematic until someone DOES feel like being in charge
14:24:00 <EvanR> dont put anyone who wants to be in charge in charge
14:24:08 * puregreen does— aw crap
14:24:25 <bernalex> merijn: yes. although I'm not sure why you think this is my responsibility. I can comment on things without pledging to solve all the problems of the world.
14:24:59 <hpc> also where on the website is the current list of people running it?
14:24:59 <bernalex> EvanR: the Greek had a very nice implementation of democracy once. basically, every year there was a lottery for who'd be the representatives.
14:24:59 <merijn> bernalex: Because the way your formulated it seems to implicitly blame the infrastructure people for the current status quo
14:25:33 <merijn> hpc: I think technically I'm one of them, but I've been to busy to actually do anything since that happened. Although maybe I got removed by now
14:25:49 <hguant> hey - I'm working through the School of Haskell tutorial on yesod, and it ends rather abruptly, though it seems to promise more to come. Is that out there somewhere?
14:26:34 <merijn> hpc: https://phabricator.haskell.org/w/infrastructure/
14:26:42 <merijn> hpc: https://wiki.haskell.org/Haskell.org_infrastructure
14:26:50 <merijn> hpc: And #haskell-infrastructure
14:26:59 <merijn> And corresponding mailing lists
14:27:10 <bernalex> merijn: if by 'implicitly', you mean 'I'm going to decide what you think based on what I think that you think', then sure. but anyway, their taking up the responsibility does naturally inflict some, well, responsibility on them.
14:28:20 <bernalex> anyway, lack of manpower isn't exactly a new problem in haskell-land. and it unfortunately leads to an age old catch 22.
14:28:41 <bernalex> fwiw, I'm one of the people who think that GHC has a nice process, and enjoyed contributing there.
14:44:32 * hackagebot propellor 3.1.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.1.0 (JoeyHess)
14:49:29 <xaviergmail> If anyone here runs Arch, do I want the stack or haskell-stack package?
14:50:36 <bergmark> [C
14:51:05 <koz_> xaviergmail: haskell-stack I think.
14:52:56 <senoj> haskell-stack
14:53:07 <xaviergmail> Alright thanks
14:54:15 <hexagoxel> are you sure? haskell-stack depends on stack, and seems to only include the libs that are of no use to you if you are using stack.
14:56:34 <xaviergmail> Ah I get the difference between the two
14:59:06 <xaviergmail> :0 ghc is huge
15:00:55 <hexagoxel> (so if you want to use stack as a library while using cabal-install as manager, then haskell-stack is for you. potentially. unless i am missing something in the file list..)
15:05:08 <senoj> oh, yep. you're correct. You should use the 'stack' package on Arch Linux.
15:05:33 <senoj> http://docs.haskellstack.org/en/stable/install_and_upgrade/#arch-linux
15:12:54 <BigShitter> whoa
15:15:01 <acowley> You can write a type signature that GHC says is ambiguous but could be resolved with explicit TypeApplications. Is there AllowAmbiguousTypes the only way to settle that difference of opinion?
15:15:35 <acowley> Because I've only ever hurt myself using AAT, so I tend to avoid it :/
15:16:30 <Cale> Usually the solution is to fix some type which is being used internally
15:16:50 <Cale> but which is not part of the external interface of the function
15:17:00 <mgsloan> Dunno if that aspect of TypeApplications was considered.  It's almost like you want a way to mark the function with "intended for use with TypeApplications"
15:18:09 <Cale> Perhaps if TypeApplications is on, and you write an explicit forall which mentions a type variable that is unused in the remainder of the signature, it should just accept it.
15:20:18 <Cale> Really, what we ought to have is Pi over types, distinguished from forall
15:21:27 <Cale> i.e. instead of  Proxy a -> ...  or  forall a. ... something ambiguous ..., you would write  Pi a. ..., and then an explicit type argument would be required on use.
15:22:07 <glguy> You'd probably still require the special syntax to provide a type argument
15:22:54 <roboguy`> Cale: hmm, I've heard that suggestion before. What does having that and distinguishing between pi and forall give us, in the context of Haskell?
15:23:01 <mgsloan> It could be a nice usability upgrade for TypeApplications to have some explicit syntactic form
15:23:21 <mgsloan> Better type errors if it can tell you to use type applications to resolve the ambiguity
15:23:25 <Cale> roboguy`: Basically you would use it whenever you would have used Proxy.
15:23:36 <roboguy`> Cale: ahh
15:24:31 <glguy> It's not very far away from taking Proxy# arguments
15:25:25 <Cale> Of course, that would just be an even more constant reminder that we don't have dependent function types
15:26:24 <Samo_svoj> Hi pals, I would like to ask advantages of haskell over scala?
15:27:23 <glguy> Samo_svoj: There's a lot written on that topic if you do a bit of searching in Google
15:27:28 <Cale> Samo_svoj: Scala has an implementation that runs on the JVM.
15:27:41 <Cale> basically... that's the main thing
15:27:42 <glguy> Samo_svoj: If you had some questions about Haskell while reading any of it you'd be welcome to ask here
15:27:43 <acowley> Sorry, I was afk. Yes, you both understand the situation exactly. The need for an argument to fix the type is what I'm trying to get around.
15:28:18 <Cale> acowley: At the time being I would feel no shame in using Proxy.
15:28:20 <acowley> It doesn't seem like there's a good way. I've had other problems with TypeApplications already, so perhaps it's just not fully baked.
15:28:28 <glguy> acowley: If you have a type that can only be used with an explicit type application, why not take a proxy argument anyway?
15:28:39 <coppro> Proxy is the worst
15:28:42 <acowley> I think I use more Proxies than any other type :(
15:28:56 <Cale> acowley: What the heck are you doing?
15:28:57 <Cale> :D
15:29:13 <Cale> It's possible that you're trying to encode too much at the type level for Haskell.
15:29:22 <Samo_svoj> glguy: I couldn't find any satisfable answer on Google so that is why I am here. Cale, thanks I know Scala and JVM also Haskell has JVM implementation, too.
15:29:34 <Cale> Samo_svoj: Not really?
15:29:35 <acowley> s/It's possible that//
15:29:54 <acowley> glguy: I just wanted to see if it would look nicer, really
15:30:16 <Samo_svoj> Cale: https://github.com/Frege/frege
15:30:19 <Cale> Samo_svoj: There's no actual Haskell compiler on the JVM. There are some other languages which are a little closer to Haskell than Scala is which will run on the JVM, but they are not as popular or well-supported as Scala.
15:30:22 <acowley> glguy: The definition site certainly looks nicer, and maybe "@ Foo" could come to look nicer than "(Proxy::Proxy Foo)"
15:30:30 <Cale> Yeah, Frege is not Haskell
15:30:43 <Cale> It's just kind of similar to Haskell
15:30:56 <glguy> acowley: Yeah, I know what you meant about it being slightly less syntax
15:31:36 <Samo_svoj> Cale: One of my questions are - If I write code in Haskell and in Scala which one is more optimized (one with ghc or other with javac)?
15:31:37 <acowley> You'd think GHC could desugar an application of the form "foo 'Bar" to "foo @ Bar", too
15:31:55 <acowley> That would really make it not-unbearably-ugly
15:32:08 <mgsloan> I haven't looked much into this TypeApplications stuff
15:32:11 <Cale> Samo_svoj: Unfortunately, any program you write will be accepted by at most one of the compilers.
15:32:17 <mgsloan> But on the surface it seems gross, because now constraint order matters
15:32:28 <mgsloan> I would have much preferred better syntax for Proxy
15:32:29 <acowley> mgsloan: It's super fragile. Even with explicit foralls, I keep running into issues.
15:32:39 <Cale> (well, not entirely true, but basically so)
15:33:11 <acowley> mgsloan: I started implementing the (::Foo) syntax to expand to a Proxy, but that was taken by Standard Chartered version that expands to "id :: Foo -> Foo"
15:33:22 <acowley> mgsloan: But the SC variant doesn't work with DataKinds
15:33:22 <Samo_svoj> Cale: Scala supports functional programming and Haskell is all about fp. Which one produce more optimized code?
15:33:24 <roboguy`> Samo_svoj: it will often depend mostly on which one you optimize more
15:33:28 <acowley> mgsloan: And it never got implemented in any case
15:33:31 <Cale> Samo_svoj: Haskell is compiled to native code though, so you don't have to run it atop a VM, which is nice.
15:33:35 <mgsloan> acowley: SC variant should still work for polymorphic proxy, right?
15:33:45 <mgsloan> I really liked the (:: Ty) section :(
15:33:48 <Cale> But yeah, it's possible to write fast code with both of them
15:34:05 <comerijn> Cale: tbh, writing fast Scala is rather har
15:34:17 <Cale> You can descend to as low a level as you like with Haskell at least, I don't know enough about Scala to know what its options are there.
15:34:17 <mgsloan> (cuz (ty -> ty) fits as a value of (proxy ty))
15:34:17 <acowley> mgsloan: I don't think you can have a value-level function take a type as an argument, but maybe that's changed with GHC8
15:34:22 <Samo_svoj> comerijn: How do you mean?
15:34:31 <comerijn> Cale: Last workshop I was at on Scala implementation they struggled a lot with performance
15:34:43 <comerijn> Samo_svoj: Scala want to do lots of things which the JVM was not designed to do
15:34:45 <Cale> ah, interesting
15:34:57 <comerijn> Samo_svoj: A lot of the workarounds used to make it do those...are not particularly fast
15:35:04 <mgsloan> acowley: Do you need that, though?  Thing is, the id section still works as a value for "proxy ty"
15:35:13 <mgsloan> But not as a value for "Proxy ty"
15:35:26 <acowley> mgsloan: No, you can't
15:35:33 <Cale> Samo_svoj: But Haskell is just a much nicer language overall, to the point that unless I really *needed* the JVM, I would not even consider Scala over it.
15:35:51 <acowley> How does the id section get you "proxy ty"?
15:35:58 <comerijn> Cale: So, by my, potentially out of date knowledge, Scala performance is pretty bad compared to haskell, even if you consider optimisation
15:36:03 <shachaf> One time I used *-kinded types for compact type application syntax.
15:36:11 <mgsloan> proxy ~ (ty ->)
15:36:15 <Cale> comerijn: Good to know, I guess.
15:36:15 <lpaste> glguy pasted “for acowley” at http://lpaste.net/167666
15:36:19 <glguy> acowley: How about that?
15:36:26 <glguy> best of both worlds? :)
15:36:34 <acowley> mgsloan: (My "No, you can't" was to say that you can't have, say, id :: 'Foo -> 'Foo)
15:36:41 <comerijn> Cale: Insert usual caveats of talking about languages speeds in the abstract ;)
15:36:47 <Cale> right
15:37:23 <Cale> It's a pretty meaningless discussion -- the real question is "will the generated code be fast *enough* for my application, and how hard is it to fix the compiler if it's not?"
15:37:39 <acowley> glguy: "best" :P  but that actually does look pretty good compared to what I'm doing at the moment
15:37:40 <mgsloan> acowley: Ahh, right, I didn't consider that (ty -> ty) would restrict ty to (ty :: *)
15:37:47 <Samo_svoj> comerijn: So Haskell code is much more cleaner and faster than Scala except Scala has support for OOP while Haskell is purly functional?
15:38:03 <comerijn> For the record, Scala is the only language I've heard othr haskellers describe as "to complex"
15:38:06 <acowley> mgsloan: right! But the SC haskell compiler doesn't have DataKinds
15:38:15 <comerijn> Samo_svoj: Note that those two are not mutually exclusive
15:38:16 <mgsloan> Or constraint kinds, I imagine
15:38:25 <acowley> Probably not that either
15:38:27 <Cale> Samo_svoj: You can write OOP code in Haskell too
15:38:37 <Cale> Samo_svoj: It just doesn't need anything special to support OOP
15:38:45 <mgsloan> Yeah, too bad SC's compiler is closed, I'd like to try out its type errors stuff
15:38:49 <comerijn> Samo_svoj: Ocaml is functional and has objects (it's not purely functional, but not because of the presence of objects. One could perfectly well make a purely functional ocaml)
15:38:59 <Cale> If you have records and first class functions, you can program in an OO style just fine.
15:39:06 <comerijn> Cale: Well, structural subtyping would be nice
15:39:12 <acowley> I like the (::) section syntax, and do wish we had it
15:39:23 <Cale> Yeah, *maybe*, but subtyping is very very overrated IMO
15:39:37 <coppro> agreed
15:39:40 <shachaf> Substructural typing would be nice too.
15:39:51 <Cale> Most of the reason people want subtyping in OO settings is because their languages foolishly tie the implementations of methods to the types of the objects.
15:39:58 <comerijn> Cale: I dunno, I kinda like structural subtyping
15:40:15 <Cale> and so you need subtyping just to vary the method implementations
15:40:22 <EvanR> Cale: you mean inheritance?
15:40:28 <Cale> not even inheritance
15:40:28 <comerijn> Cale: inheritance is dumb, imo. But I'd really like structural subtyping and row polymorphic (dependent?) records in haskell
15:40:45 <Cale> Just, like, how do you get Animals that have different sounds?
15:41:07 <EvanR> by making a subclass
15:41:14 <glguy> Cale: Did your parents not go over that with you?
15:41:14 <Cale> You *have* to make separate subclasses in a lot of these languages, because you don't have a constructor to make an Animal from whole cloth from its method implementations.
15:42:00 <Cale> (actually, many of them have been adding ways, but nobody ever uses this feature)
15:42:44 <Cale> Once you have a way to just write as many different Animal values as you like by saying what the methods do, you don't need subtyping nearly so much.
15:42:54 <Cale> Yeah, it's nice to get a little name reuse out of it.
15:43:07 <acowley> glguy: Weirdly, intero doesn't like the (p @Int) syntax
15:43:09 <coppro> tell me about it :(
15:43:13 <Samo_svoj> Scala is not so complex. I am SC programmer but do not know Haskell and I am trying to find out what are advantages of Haskell over SC?
15:43:17 <acowley> glguy: Though the repl is happy
15:43:22 <glguy> acowley: What's intero?
15:44:14 <acowley> glguy: A type checker code introspection thing that plugs into emacs for flycheck and navigation stuff
15:44:37 <acowley> glguy: https://github.com/commercialhaskell/intero
15:44:53 <dedgrant> Samo_svoj: What is SC?
15:45:05 <EvanR> Cale: right so different implementations of one interface doesnt really involve subtyping, people reach for subclasses in those languages instead because inheritance mechanism was confused with the implementation variation pattern, so they arent looking for subtypes actually
15:45:09 <Samo_svoj> dedgrant: SC = Scala
15:45:18 <dedgrant> Samo_svoj: gotcha :)
15:45:18 <Cale> EvanR: yep
15:45:32 <Cale> EvanR: and usually when subclasses really *would* be needed, they just create problems anyway
15:46:03 <EvanR> subtypes are what you want when you want implicit conversion when its "incredibly obvious how youd do it"
15:46:17 <EvanR> which has not much to do with inheritance
15:46:38 <Cale> and you pay for all this with having shitty type inference
15:47:11 <EvanR> my problem is that this incredible obviousness doesnt come up that much
15:47:26 <EvanR> but you can easily fooled that its obvious like numeric types
15:47:35 <EvanR> or date times
15:47:52 <lpaste> glguy annotated “for acowley” with “for acowley (annotation)” at http://lpaste.net/167666#a167668
15:48:15 <Cale> Right, numeric types provide many excellent examples of how you can shoot yourself in the foot really badly with implicit coercions.
15:48:28 <glguy> acowley: This is the best I've come up with in this style to get things to use Proxy#. You can't have a top-level Proxy# a value, nor can you have a polymoprhic, unlifted binding
15:48:41 <glguy> (just sharing)
15:48:46 <acowley> Oh wow
15:48:49 <EvanR> i do see a huge hole in web programming not knowing what the fields of a expected record are or should be
15:49:10 <acowley> glguy: That's really neat
15:49:10 <EvanR> and if you apply static types, you suddenly have to care about all the other fields that you never look at
15:49:52 <acowley> glguy: But I think "(q$p @Int)" is getting a touch squirmy syntactically
15:50:02 <glguy> oh, certainly
15:50:15 <Cale> EvanR: The way we deal with that is just to use Haskell datatypes, and autogenerate all the JSON instances without any regard for how pretty they are.
15:50:30 <EvanR> including records?
15:50:33 <Cale> As long as it's an isomorphism it's fine.
15:50:49 <Cale> yeah, it's mostly record types
15:51:01 <EvanR> to make a wild complex record fit into your minimal expectations, do you do explicit conversions?
15:51:11 <EvanR> it wouldnt be an iso
15:51:35 <Cale> Well, we do the usual things that you do in Haskell -- break the type down into smaller products
15:51:51 <EvanR> most APIs return lots of useless forms
15:51:56 <EvanR> er fields
15:51:56 <glguy> acowley: (q$p @Int) isn't necessarily better than (proxy# @Type @Int), or (proxy# @_ @Int)
15:52:10 <EvanR> i dont want to bother making types for them
15:52:24 <danza> EvanR, did you see how this is resolved in Purescript?
15:52:32 <Cale> Yeah, interfacing with external APIs I suppose is a nuisance :)
15:52:33 <EvanR> row polymorphism?
15:53:15 <danza> i am not sure, but there are a couple of nice ideas there
15:53:32 <acowley> glguy: I appreciate your heroic effort at making me feel less bad about the uglyness of normal Proxy usage :)
15:53:34 <EvanR> thats kind of what i was getting at, 
15:53:40 <EvanR> related to the subtyping thing
15:54:10 <glguy> ok ok, I'll move on ;-)
15:54:25 <Cale> EvanR: Though, it's actually surprisingly liveable to have a ridiculous record type with 30 fields, and just use either lenses or the record field extractors and record update syntax. It's a bit painful, but it won't stop you from getting things done.
15:55:22 <danza> Cale, yeah but, do you need to define a type mapping the whole record?
15:55:43 <Cale> hm?
15:55:47 <EvanR> Cale: the way i see it, they give you information, but i only care about some of it, so thats all the validator needs to check for, and give me the minimum record
15:55:52 <Cale> This *is* a type I'm talking about
15:56:00 <EvanR> so its an orthogonal issue to lensing
15:56:19 <danza> EvanR, you can define a mapping to just part of the JSON
15:56:34 <EvanR> its a bitch to sift through some half-specified json format
15:56:52 <EvanR> danza: define a mapping? in pure script?
15:56:57 <Cale> That is of course not the fault of Haskell in any way
15:57:03 <danza> EvanR, no, in Haskell
15:57:09 <EvanR> you mean the validator
15:57:16 <Cale> half-specified json formats are garbage to start with
15:57:19 <EvanR> well yeah
15:57:27 <EvanR> and you are responsible for consuming them
15:57:53 <Cale> So, being able to use parser combinators to deal with it is pretty nice.
15:58:02 <danza> recently i had to consume a complex object, but my type has a subset of its fields
15:58:09 <danza> it worked fine
15:58:13 <Cale> The Parser that Aeson uses is an instance of Alternative :)
15:58:14 <EvanR> yeah a parser like aeson parser
15:58:20 <danza> yup
15:58:30 <EvanR> brilliant
15:58:56 <danza> nope ... just ... lazy! :D
15:59:07 <danza> as in human lazy, not lazy evaluation :D
15:59:09 <Cale> Better than writing nested if/then/else statements in some imperative language anyway.
15:59:26 <EvanR> in normal web languages youd probably have a stringly typed DSL to do this
15:59:42 <EvanR> and it wouldnt work as well as a applicative / monad parser combinator
16:00:19 * EvanR gripes about the aeson built in instance for UTCTime
16:02:06 <Samo_svoj> what do you think about Yesod?
16:13:21 <srhb> Samo_svoj: Big and unwieldly and very popular. :-)
16:14:22 <Samo_svoj> srhb: which web framework would you use for med to large scale web apps?
16:15:34 <EvanR> for large scale web apps, use small scale frameworks
16:15:56 <Cale> Samo_svoj: The company I work for uses reflex-dom on the frontend, and then snap and groundhog on the backend (though this almost doesn't matter so much, snap is already overkill for us).
16:18:44 <cheater> Cale: what company is that?
16:18:50 <Cale> Obsidian Systems
16:18:55 <cheater> oh :)
16:19:31 <Cale> When your application is constructed as a Haskell program which controls the DOM directly and it sits in a single page and communicates with the backend, most of the things that most web frameworks deal with are a bit of a moot point.
16:19:36 * hackagebot string-conv 0.1.2 - Standardized conversion between string types  https://hackage.haskell.org/package/string-conv-0.1.2 (MichaelXavier)
16:20:07 <Cale> e.g. you probably don't need super-complicated URL routing
16:20:24 <Cale> and you certainly don't need a fancy templating system
16:20:31 <dfeuer> GRRRRR
16:21:20 <dfeuer> Cale, I missed your message ages ago too. And now I have to run.
16:21:21 <Samo_svoj> Cale: Thanks pal! Bthw what do you (or other ppl here) think about using languages like Haskell, Scala, etc. on the frontend that compiles to JS instead using plain JS with their libraries and frameworks (jQuery, etc.)?
16:21:24 <dfeuer> But I'll be back later, I hope.
16:21:37 <dfeuer> I'm currently writing the most disgusting code ever.
16:21:52 <dfeuer> And I just realized it's going to need to be *even worse*.
16:21:53 <Cale> Samo_svoj: it's *sooooo* much better
16:22:32 <dfeuer> Unless...
16:22:42 <Cale> Samo_svoj: In fact, with reflex-dom it's so good that I now greatly prefer frontend work to backend.
16:23:00 <Samo_svoj> Cale: But these days you have new things like 'progressive apps' and ideas like 'web worker', 'shared worker', and especially 'service worker' from the frontend?
16:23:14 <Cale> We need to get FRP going in the backend/DB layer, which will solve a lot of the complexities we're running into there.
16:23:29 <Cale> I don't know what any of those terms refer to
16:23:45 <xaviergmail> Just wanted y'all to know my brain is breaking
16:24:00 <Samo_svoj> xaviergmail: stay with us, pal!
16:24:08 <xaviergmail> :D
16:24:12 <xaviergmail> I intend on doing so
16:24:37 <Samo_svoj> Cale: service worker is new specification for building 'progressive apps'.
16:25:35 <Samo_svoj> Cale:  Idea is to have one JS thread especially for communication with the backend/server. It thread doesn't do any manipulation with the DOM at all!
16:25:42 <Cale> Samo_svoj: Basically, our frontend is a Haskell program which communicates via a websocket with the backend, sending what we call "view selectors" which is a monoidal record type used to represent what data the user is looking at presently, and in response, the backend sends patches to a View data type, which are accumulated.
16:26:15 <Cale> I don't recall if our websocket is running in another Haskell thread or not
16:26:56 <Samo_svoj> Cale: https://github.com/slightlyoff/ServiceWorker , https://slightlyoff.github.io/ServiceWorker/spec/service_worker_1/
16:27:08 <Cale> We're using a functional reactive programming system throughout the frontend to build our UIs
16:27:28 <Samo_svoj> you have FRP for backend too
16:27:34 <Cale> and on top of that, we have a means of dynamically accumulating the view selector based on which widgets the user is looking at
16:27:43 <Samo_svoj> FRP is even implemented in Scala libs from Haskell
16:27:46 <Cale> Not really yet -- eventually we hope to have something there
16:29:06 <Cale> It would be *so* nice to have a way to register a Dynamic query with the DB and get notified with an Event of diffs against the result of the query whenever a transaction commits that affects it.
16:30:22 <Samo_svoj> Cale: you mean to have some kind of Promise type
16:30:24 <Cale> (or whenever the Dynamic query changes causing it to be recomputed...)
16:31:16 <Samo_svoj> Cale: https://github.com/roman/Haskell-Reactive-Extensions <-?
16:31:43 <Cale> https://github.com/reflex-frp/reflex-dom
16:32:01 <Cale> https://github.com/reflex-frp/reflex-platform would be a better link actually
16:32:06 <Samo_svoj> Cale: I know it is for frontend but not for backend
16:32:36 <Cale> But that's frontend stuff. I mean a way to represent an entire stream of communication with the database as essentially a pair of values: something like Dynamic t (Query a) representing the current query we want to make (with information about when it changes)
16:33:36 <Samo_svoj> Cale: what do you think about https://github.com/roman/Haskell-Reactive-Extensions ?
16:33:38 <Cale> and then minimally, something like Dynamic t (Results a), a dynamically changing set of rows which are the result of the query
16:34:13 <Cale> I haven't looked at it closely enough to know
16:35:00 <Cale> But really what we'd want is more like  Event t (Patch (Results a))
16:35:47 <Samo_svoj> It is Haskell implementation of http://reactivex.io/
16:37:19 <frew> hey guys, when I do stack setup it extracts to some files to somewhere under /, presumably /tmp
16:37:47 <frew> TMPDIR is set to /mnt/tmp but also I would have expected it to check out to hte work-dir, which by default is .stack-work, right?
16:37:57 <dfeuer> Can GHC unbox ST results?
16:38:01 <frew> stack is using up 2G so I sorta need to fix this
16:38:03 <frew> ideas?
16:38:12 <dfeuer> Making unboxed triples, say?
16:38:13 <Cale> frew: Really? I would expect it to use your home directory...
16:38:18 <frew> Cale: yep, same.
16:38:18 <ggVGc> compiling haskell uses way too much ram :(
16:38:34 <dfeuer> Or do I need to do something really horrifying?
16:38:34 <Cale> oh, right, it does use /tmp some
16:38:44 <frew> hardcoded?
16:38:48 <Cale> uhhh
16:39:24 <Cale> You can set the TMPDIR environment variable to make it use a different directory
16:39:32 <frew> that's what I tried
16:39:41 <frew> let me verify
16:39:47 <Cale> make sure the variable is exported
16:39:55 <frew> yeah
16:40:00 <Cale> or set it on the same commandline
16:40:02 <Koterpillar> TMPDIR, not TEMP or TMP?
16:40:08 <frew> TMPDIR is the normal one
16:40:15 <frew> I don't know if it would look for the latter two
16:40:21 <frew> (would surprise me if it did)
16:40:22 <Cale> https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#user-content-can-i-change-stacks-default-temporary-directory
16:40:50 <frew> ok
16:40:56 <frew> well I wonder why that's not working...
16:41:03 <frew> let me verify 100% that the env var is getting set
16:41:08 <itnex> help
16:41:18 <Cale> I don't know why some linux distributions put /tmp in RAM, it's pretty silly, and kind of a bad idea.
16:41:45 <frew> yeah this is in AWS and we really want /tmp to be ephemeral and local
16:41:46 <Cale> Real disks have buffers anyway
16:41:57 <frew> (ie not an ebs)
16:41:58 <Cale> ah
16:41:59 <itnex> there are strange noises coming from behind me and im afraid to look
16:42:01 <itnex> what can i do?
16:42:23 <Cale> itnex: /join #haskell-offtopic
16:42:44 <frew> ok tmpdir is being set, running command again to be sure
16:42:50 <frew> oh wait...
16:42:52 <frew> using sudo
16:42:56 <frew> env getting blown away
16:43:01 <frew> sorry about that, thanks  for your patience
16:43:10 <Cale> ah!
16:43:18 <Cale> You shouldn't need to sudo...
16:43:32 <frew> I do, but not becuase of anything you guys are doing :)
16:43:37 <Cale> okay
16:43:38 <Koterpillar> sudo -E
16:43:44 <frew> Koterpillar: yep
16:44:45 <itnex> but i already have
16:51:18 <orzo> What's the best haskell compiler with reasonable compile-time performance?
16:51:23 <orzo> ghc is too slow
16:51:34 <glguy> In that case you'll have to use GHC
16:51:57 <acowley> Older versions of GHC are an option
16:52:01 <glguy> possibly with optimizations turned down if you want faster compiles
16:52:45 <orzo> hm, guess i was hoping there was a separate code base
16:52:52 <slack1256> I have a netbook from 2011, cabal --disable-optimizations does wonders for faster compile times
16:53:29 <slack1256> what I like of this is how well performant it is the program without optimizations.
16:54:38 * hackagebot persistent-iproute 0.2.2 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.2 (sickmind)
16:55:10 <newcomer> I was looking into sequence and found out that it's implemented using foldr. It seems to me that this reverses the order of evaluation of the monadic values. I thought the first thing evaluated in foldr is combining the last (right-most) element with the initial value. If my understanding is correct, then the last monadic value is evaluated first. right?
16:55:15 <Cale> itnex: Then keep non-Haskell-related discussion there :)
16:55:32 <itnex> how can i know whether it is haskell related or not
16:55:33 <glguy> newcomer: No, it's not the case that foldr evaluates the last element first
16:56:26 <orzo> foldr allows short-circuit for MonadPlus instances
16:57:00 <orzo> if you are sequencing a list of maybes, you want it to bail at the first Nothing
16:57:16 <newcomer> so foldr (+) v [x,y, z] = (x + (y + (z + v)))
16:57:17 <newcomer> so I thought z + v is evaluated first.
16:57:55 <slack1256> the problems with the example of foldr (+) is that (+) is strict in both arguments. Try `const`
17:01:52 <orzo> slack1256: configure don't like --disable-optimizations.  Is it an option to build rather than configure?
17:02:05 <newcomer> slack1256, so in case of foldr const 0 [x, y , z] = const x w = x. Where w = foldr const 0 [y, z] but is not actually evaluated. right?
17:02:28 <glguy> orzo: $ cabal configure --disable-optimization
17:02:43 <orzo> thanks, glguy
17:02:45 <dcoutts> or -O0
17:03:04 <dcoutts> ie  cabal configure -O0
17:03:26 <glguy> orzo: If you type cabal --help, it shows you all these options
17:03:33 <slack1256> ops, an 's' extra
17:04:10 <orzo> hm, 5 times faster without optimisations
17:04:24 <orzo> boy are those optimizations costly
17:04:39 --- mode: ChanServ set -o dcoutts
17:04:49 <newcomer> slack1256, Thanks, now I understand that a comment about the combining function f being able to produce part of the result without referencing the recursive case. Comment found here: https://wiki.haskell.org/Fold
17:06:29 <slack1256> newcomer: Cool! :-)
17:06:52 <newcomer> <glguy> newcomer: No, it's not the case that foldr evaluates the last element first
17:07:12 <newcomer> ^^__ so it's actually the opposite?
17:07:26 <glguy> > foldr f z [1..]
17:07:28 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (f...
17:07:31 <newcomer> or it depends?
17:07:37 <glguy> the outermost application of f is applied to 1
17:07:46 <glguy> and it proceeds from there
17:08:30 <glguy> (f 2 ...) might be evaluated in the course of evaluating f 1 (f 2 ...)
17:10:40 <glguy> consider a definition for sequence_ = foldr (>>) (return ())
17:10:59 <glguy> if you have sequence_ [a,b] that evaluates to  a >> (b >> return ())
17:11:29 <slack1256> newcomer: by the way, are you reading the definitions for foldlM and foldrM right?
17:16:36 <newcomer> slack1256, not yet, but was coming to it.
17:16:40 <newcomer> foldr (\x y -> if x == 100 then x else x + y) 0 [1..]
17:17:47 <slack1256> > foldr (\a acc -> if a == 100 then a else a + acc) 0 [1..]
17:17:49 <lambdabot>  5050
17:18:32 <slack1256> > sum [1..100]
17:18:34 <lambdabot>  5050
17:19:53 <newcomer> slack1256, yes, I thought of this example to grok the idea that the combining function doesn't always have to evaluate the next recursive call.
17:23:48 <c_wraith> :t \p -> foldr (\x c -> if p x && null c then [] else x : c) [] 
17:23:50 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
17:24:06 <c_wraith> that example is fun. 
17:26:32 <newcomer> is it still called acc in case of foldr? I think it's a confusing name since it doesn't actually accumulate anything. unlike foldl.
17:27:04 <c_wraith> you're right. acc is a poor name for it. 
17:27:40 <c_wraith> I like to think of it as a closure representing the possible rest of the fold. 
17:29:50 <c_wraith> by the way, try out my example. it's fun. it has some surprising laziness properties 
17:36:57 <roboguy`> > let f p = foldr (\x c -> if p x && null c then [] else x : c) []      in f odd (cycle [1,2,3])
17:36:59 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
17:37:05 <roboguy`> ^ c_wraith: hmm, you mean like that?
17:39:09 <xaviergmail> Slightlt stumped by the way of passing 'calls' as arguments
17:39:13 <xaviergmail> slightly*
17:39:46 <roboguy`> xaviergmail: passing calls as arguments?
17:40:01 <xaviergmail> an expression, I guess
17:40:49 <xaviergmail> dosomething(floor(x - somethingelse(z)))
17:41:56 <roboguy`> xaviergmail: what part are you confused by?
17:42:07 <xaviergmail> How to write something like that
17:42:47 <xaviergmail> the interpreter thinks I'm trying to pass floor as an argument
17:43:02 <Koterpillar> xaviergmail: expression you just pasted will work; paste your exact thing
17:43:07 <roboguy`> xaviergmail: if you write exactly that, it should work...
17:43:20 <roboguy`> (although some of the parens are unnecessary. Not a big deal though)
17:43:59 <xaviergmail> Hmm, it must be a different error then
17:44:05 <Koterpillar> xaviergmail: put all your parens like it's C, then remove ones with no spaces inside
17:46:30 <roboguy`> xaviergmail: you should show us the actual line of code
17:46:37 <Koterpillar> and the error
17:47:22 <xaviergmail> Gonna try to figure this one out myself first :p
17:47:54 <tag> parens in haskell are actually only for precedence, this sometimes takes people a little while to figure out.
17:48:26 <roboguy`> xaviergmail: you might have the syntax for function calls confused (which is what I suspect from your example)
17:48:58 <tag> roboguy`, confused like that there are no function calls
17:49:19 <tag> ?
17:49:28 <roboguy`> tag: what do you mean?
17:49:48 <xaviergmail> I got the grasp of there not being actual 'calls' and I have a slight bit of experience with parenthesis-less calling from CoffeeScript
17:50:09 <xaviergmail> put quotes on actual and not calls up there but yeah
17:51:40 <slack1256> exit
17:51:45 <tag> xaviergmail, It's a little bit of a different implication, coffeescript or perl or w/e vs. haskell's no-parenthesis calling. In haskell, I find I'm often using parens where a comma would suffice in a language where parameters were separated by commas.
17:52:26 <xaviergmail> True, forgot about commas
17:52:32 <tag> because...there's not really a delimiter between the parameters of this function and the parameters of the functions which are the arguments to this function. So parenthesis disambiguate.
18:00:28 <newcomer> c_wraith, sorry, wife hijacked laptop. 
18:00:47 <newcomer> c_wraith, honestly, I don't get your example.
18:01:13 <newcomer> Maybe because it's 3:00 am here :)
18:01:24 <itnex> wow
18:01:45 <itnex> thats really late
18:03:17 <newcomer> so last question to make sure that I understand correctly. There's no way to shortcut foldl since it immediately recursively calls itself. It has to transverse the entire structure. right?
18:04:36 <newcomer> itnex, yes, no work tomorrow. Day schedule gets screwed during Ramadan.
18:10:25 <geekosaur> newcomer, yes re foldl
18:21:25 <newcomer> geekosaur, Thanks.
18:28:01 <renatosilva> hi, is this channel suited for windows questions? any windows maintainer in here?
18:28:40 <Rotaerk> haskell-on-windows you mean?
18:29:29 <renatosilva> yes :)
18:29:33 <buglebudabey> when parsing a language, is the assignment sign '=' right associative? right now i have a simple expression "x = let a = 2 in a" tripping up the parser
18:29:44 <buglebudabey> and it has no association at the moment
18:30:22 <coppro> what do you mean "a language"?
18:30:45 <buglebudabey> i'm parsing the Core language
18:30:59 <buglebudabey> making a compiler for it
18:31:07 <coppro> do you mean like Report haskell?
18:31:15 <Rotaerk> renatosilva, don't see why not
18:31:17 <buglebudabey> i don't know what that is
18:31:28 <coppro> the Haskell Report is the language standard
18:31:35 <buglebudabey> for...?
18:31:41 <roboguy`> buglebudabey: I don't know that is really to do with associativity of =
18:31:55 <coppro> buglebudabey: Haskell
18:32:03 <roboguy`> it would be equivalent to x = (let a = 2 in a)
18:32:06 <buglebudabey> i see, you mean the grammer coppro 
18:32:17 <coppro> buglebudabey: well the grammar specified in the Report, yes
18:32:33 <buglebudabey> yes roboguy`  but i think the parser is matching (x = let a) = 2 in a
18:32:39 <coppro> but the Report also specifies various semantics
18:32:40 <renatosilva> Rotaerk: ok, are you a windows maintainer?
18:32:42 <buglebudabey> roboguy` and that does not match a pattern
18:32:44 <coppro> so it's not just a grammar
18:34:10 <coppro> buglebudabey: = does not have an associativity, it is not an operator.
18:34:37 <roboguy`> buglebudabey: The left equal should probably be separated more from the right equal. So maybe a rule like (a bit simplified): <top-level-binding> ::= <id> = <expr>
18:36:35 <roboguy`> well, maybe a little more general than that would be ok. Either way, you shouldn't let the RHS of a binding match a "partial" expression. It should only match a full, syntactically correct, expression
19:02:16 <Mishac> Hello Can someone help me understand why does the last line not compile?
19:02:17 <Mishac> http://pastebin.com/Jxj9NsUa
19:02:55 <Mishac> I am getting the following error: http://pastebin.com/1jzjTShB
19:03:24 <coppro> Mishac: you probably mean "instance (Num a) => TooMany (a, a)
19:03:26 <Koterpillar> Mishac: instance (Num a) => TooMany (a, a)
19:04:11 <Mishac> I am not sure I can follow, can you paraphrase?
19:04:26 <coppro> Mishac: you currently have written instance TooMany ((Num a) => (a, a))
19:04:36 <coppro> you probably want instance (Num a) => TooMany (a, a)
19:04:53 <Mishac> hmm
19:05:07 <Koterpillar> the type you're making an instance of is (a, a)
19:05:21 <Koterpillar> s/ of//
19:05:38 <Mishac> and I want Num a => (a,a) to be an instance of TooMany
19:05:52 <Mishac> otherwise it defeats the purpose
19:06:00 <Koterpillar> You want to be (a, a) to be TooMany *if* a is Num
19:06:06 <Koterpillar> is that right?
19:06:12 <Mishac> yes
19:06:19 <Koterpillar> instance (Num a) => TooMany (a, a)
19:06:20 <coppro> then yes, you want what we've suggested
19:06:24 <Koterpillar> that's the syntax to do that
19:06:33 <Mishac> let me try it
19:06:45 <coppro> instance TooMany ((Num a) => (a, a)) would be saying "there is an instance of TooMany for things which are (a, a) for *any* Num a"
19:06:54 <coppro> e.g. :t (1, 1)
19:07:02 <coppro> :t (1, 1)
19:07:03 <lambdabot> (Num t, Num t1) => (t, t1)
19:07:13 <coppro> :t let t = 1 in (t, t)
19:07:14 <lambdabot> (Num t, Num t1) => (t, t1)
19:07:22 <coppro> bah
19:07:38 <Koterpillar> :t \x -> (x, x)
19:07:39 <lambdabot> t -> (t, t)
19:07:45 <Koterpillar> :t (\x -> (x, x)) 1
19:07:46 <lambdabot> Num t => (t, t)
19:07:49 <coppro> ^
19:08:10 <coppro> the instance head you had would be saying that that expresion is an instance of TooMany
19:08:18 <coppro> and it would be only one instance regardless of which Num type you had
19:09:11 <Mishac> I see,
19:09:59 <Mishac> ok so the question in the book states: Make anohter TooMany instance, this time for (Num a, TooMany a) => (a,a)
19:10:21 <glguy> What book?
19:10:24 <Mishac> so the correct anwser to it would be: instance (Num a,TooMany a) => TooMany (a, a)  where
19:10:36 <Mishac> haskell programming from first principles ( haskellbook.org)
19:11:09 <Mishac> did I get it right: instance (Num a,TooMany a) => TooMany (a, a) where
19:11:19 <Koterpillar> let the compiler tell you that
19:12:25 <Mishac> it compiles
19:12:35 <Mishac> so what I am trying to understand is that
19:12:47 <Mishac> (Num a, TooMany a) are constraints
19:13:19 <Koterpillar> hmm, so you have one instance of Num a => TooMany (a, a) and another one which is _more constrained_?
19:13:48 <Mishac> nope: Num a => TooMany (a, a) is just easier version of: Num a,TooMany a) => TooMany (a, a) where
19:13:56 <Mishac> I was trying to understand what I did wrong
19:14:05 <xaviergmail> What does the 's' stand for in (x:xs) when dealing with lists?
19:14:19 <Koterpillar> xaviergmail: s/x/thing/, does it make more sense now?
19:14:33 <Cale> xaviergmail: xs is pronounced "eckses" i.e. it's plural
19:14:42 <geekosaur> xaviergmail, it's just a plural. an x followed by more x-s
19:14:47 <Koterpillar> Mishac: the short answer is the constraint goes before the typeclass
19:14:52 <xaviergmail> ah makes sense, thanks
19:14:56 <Cale> It's just a convention we have about naming variables which stand for lists
19:15:03 <mcuramen> Hello guys, I have a beginner question
19:15:17 <Cale> sure
19:15:36 <troydm> hpc: what are the weaknesses of acid-state u've mentioned?
19:16:28 <Mishac> Koterpillar: Thank You. So, in other words type constrains go before the name of the typeclass that you are dealing with
19:16:59 <mcuramen> In Learn You a Haskell section on Typeclasses 101 it says that (==) :: (Eq a) => a -> a -> Bool means that the equality function takes any two values that are of the same type.
19:17:26 <Cale> That's right
19:17:32 <mcuramen> Technically, 1 and 2.212121 are not the same since 1 is an Int and the other is a Float
19:17:38 <Koterpillar> :t 1
19:17:39 <lambdabot> Num a => a
19:17:43 <Koterpillar> :t 2.21
19:17:45 <lambdabot> Fractional a => a
19:17:45 <dfeuer> Technically?
19:17:49 <Cale> actually, if they're literals, both are polymorphic
19:18:38 <mcuramen> I thought that he meant both have to be integers or both have to be floats
19:18:41 <Cale> If you compare them, then it'll have to pick some Fractional type (Num is a superclass of Fractional)
19:18:56 <Cale> and due to numeric defaulting, if you say nothing else, Double will get picked
19:19:06 <Cale> > 2.212121 == 1
19:19:07 <lambdabot>  False
19:19:20 <Cale> > 2.212121 == (1 :: Complex Double)
19:19:21 <lambdabot>  False
19:19:25 <Cale> > 2.212121 == (1 :: Integer)
19:19:27 <lambdabot>      No instance for (Fractional Integer)
19:19:27 <lambdabot>        arising from the literal ‘2.212121’
19:19:27 <lambdabot>      In the first argument of ‘(==)’, namely ‘2.212121’
19:19:54 <mcuramen> wow I feel stupid
19:19:54 <Cale> Here, since both arguments need to have the same type, and we know that the 1 is an Integer, the 2.212121 had better also be an Integer
19:20:09 <Cale> However, it can only be interpreted as a type which is an instance of Fractional, which Integer is not
19:21:24 <Cale> You shouldn't really -- the design of the numeric library is a little bit subtle
19:24:40 <mcuramen> Is this book the best one to learn as a beginner? Are there books that are better laid out and more precise with wording?
19:25:23 <Cale> Graham Hutton's book is pretty good, at least for what it covers -- the 2nd edition of it is coming out shortly
19:26:28 <mcuramen> I might check that out, but I think it's best to stick with one thing for now.
19:27:26 <Cale> There's also some free course materials here: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
19:27:55 <dfeuer> Cale, this code is far too nasty.
19:28:15 <Cale> (there are some newer editions of that course as well if you poke around, which might be nice, but that semester in particular is considered especially good)
19:31:43 <mcuramen> wow thanks for that!
19:32:07 <mcuramen> can you guys point me to some Haskell problems I can do as a beginner?
19:32:13 <dfeuer> I've left behind all the beauty of algebraic data types and nice safe functions in pursuit of performance :(
19:32:38 <Hafydd> mcuramen: https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
19:32:38 <mcuramen> I think the best way to learn it is to actually write use it instead of just reading about it.
19:33:07 <dfeuer> mcuramen, DON'T do the 99 haskell problems.
19:33:16 <mcuramen> Haha, dfeuer do you mean you're using C now?
19:33:18 <dfeuer> Hafydd, that's not to be recommended.
19:33:23 <Hafydd> dfeuer: why not?
19:33:31 <dfeuer> mcuramen, doesn't CIS194 have problem sets?
19:34:05 <dfeuer> Hafydd, it's *extremely* non-idiomatic for Haskell, and many of the problems need to be "translated" in order to make any sort of sense. Mostly they were stolen from LISP, which stole them from PROLOG.
19:34:18 <dfeuer> Some of the problems make very little sense even once translated.
19:34:27 <mcuramen> Yes it does! Thank you for the link.
19:34:29 <dfeuer> They ask you to do things that you just *wouldn't do* in Haskell.
19:34:41 <Hafydd> dfeuer: what is extremely non-idiomatic? A problem can't be idiomatic.
19:35:48 <dfeuer> Hafydd, you're wrong about that :)
19:36:04 <Koterpillar> problems can be easy or hard
19:36:15 <Hafydd> dfeuer: what is an example of one such problem?
19:37:24 <mcuramen> It's great that Penn has a Haskell course. My university doesn't have it.
19:37:36 <dfeuer> Hafydd, questions about representing trees as lists, which is a sensible thing to do in LISP, but not in Haskell.
19:38:40 <dfeuer> Hafydd, they're not *good* problems, that make sense regardless of language.
19:38:49 <Hafydd> dfeuer: I haven't seen any problem in H-99 that requires trees to be represented as lists. It sounds like you're confusing a possible solution with the problem itself.
19:39:09 <dfeuer> Hafydd, I'm talking about the language of the problem statements.
19:39:45 <dfeuer> Huh. That failed.
19:39:47 <Hafydd> dfeuer: you have still not provided a concrete example to support your statement.
19:39:50 <dfeuer> No performance :(
19:39:53 <thimoteus> think we need a problem # now
19:40:27 <Zemyla> Why does Template Haskell not have a monad that's like Q, but guaranteed to not have IO in it? :O
19:40:45 <dfeuer> Hafydd, problem 7.
19:41:13 <dfeuer> Which is translated below, but it's just *weird*
19:42:18 <dfeuer> Problem 11 is just *stupid* in Haskell. There is no reason to do that.
19:42:34 <dfeuer> (or really anywhere)
19:43:04 <Hafydd> dfeuer: that is still something you might need to do in Haskell, although it's true that it's uncommon. Even so, you can still learn something from doing it.
19:43:46 <dfeuer> Hafydd, studying how to do things that are approximately useless tends to develop bad instincts, I think.
19:44:01 <Hafydd> dfeuer: the point of exercises it to make the student think about how to solve problems in Haskell, not to teach them some pre-determined solutions.
19:44:29 <Hafydd> I think that develops some quite useful general skills.
19:44:41 <coppro> Zemyla: what purpose do you intend to use it for?
19:45:15 <dfeuer> Hafydd, those aren't good problems!
19:45:20 <Hafydd> dfeuer: someone who only solves common problems is often at a loss for what to do when they encounter a common problem.
19:45:24 <dfeuer> They're "Learn LISP" problems.
19:45:44 <Koterpillar> dfeuer: lists are a common data structure
19:45:52 <Koterpillar> dfeuer: list manipulation is encountered often
19:45:55 <Zemyla> Mostly to be able to have there be a type difference between a TH splice that reads the source code and writes some functions, and one that launches missiles at compile-time.
19:45:57 <Hafydd> dfeuer: *an uncommon problem
19:46:01 <dfeuer> Koterpillar, yes, but those problems are largely about LISP lists!
19:46:03 <Cale> Koterpillar: But Lisp lists aren't really lists :)
19:46:14 <Cale> Koterpillar: They're a weird sort of trees
19:46:18 <Hafydd> (They're originally Prolog problems.)
19:46:32 <Koterpillar> lisp lists are still a common data structure
19:46:36 <Hafydd> dfeuer: anyway, I do invite you to suggest your own set of problems.
19:46:54 <Hafydd> There might well be a better set.
19:47:12 <dfeuer> Koterpillar, sure they are, in LISP. Not so much in Haskell.
19:47:51 <Koterpillar> dfeuer: for the purposes of learning stream processing, you might as well do linked lists instead of any other representation
19:48:10 <dfeuer> Koterpillar, what does that have to do with LISP lists?
19:48:21 <dfeuer> Which have strict spines?
19:49:32 <Koterpillar> I don't think #11 is about teaching you strictness
19:49:44 <dfeuer> A proper language-agnostic problem will ideally not discuss such representational details.
19:50:07 <Koterpillar> are you perhaps over-reading it? The input is a finite sequence of letters
19:50:22 <dfeuer> I'm sick of this conversation. I greatly dislike the 99 Haskell Problems and I think they're inappropriate for new Haskell programs. Other people clearly disagree.
19:50:57 <Koterpillar> well, ok
19:51:16 <dfeuer> *programmers
19:51:45 <Maxdamantus> Why are they different in Haskell? They're just unary trees with values at branches.
19:51:47 <mcuramen> dfeuer, so the Penn problems should be a good starting point for beginners?
19:52:02 <dfeuer> mcuramen, I haven't looked at many, but yes.
19:52:27 <Squarism> on paper, stack seems to be overall just better than cabal. Still, seems most people run cabal
19:52:27 <dfeuer> I haven't heard anything bad about that course.
19:53:02 <dfeuer> Squarism, Stack uses Cabal. But yes, many people seem to think stack is better than *cabal-install*.
19:53:13 <dfeuer> (Cabal is a library; cabal-install is a program)
19:53:20 <Cale> Maxdamantus: Because lisp lists can be irregularly nested
19:53:45 <Cale> Maxdamantus: also, lisp lets you put something in the cdr of a cons which is not itself a list
19:54:22 <Cale> So really they are binary trees, with a peculiar interpretation.
19:55:08 * dfeuer really hopes his benchmarks will compile after this painful dep installation.
19:55:48 <Squarism> dfeuer, but isnt it just better? Stack has that global cache that cabal seems to miss? Sounds like a deal breaker to me
19:56:04 <Koterpillar> cabal-install has a global cache, too
19:56:12 <Squarism> oh ok
19:56:14 <Koterpillar> which is the only one
19:57:42 <glguy> Squarism , stack and cabal install solve Aussie
19:57:45 <glguy> Typo
19:58:19 <glguy> Different problems for me, cabal for building individual things, stack for managing complicated workspaces
19:58:25 <dfeuer> GRRR
19:58:40 <dfeuer> After all that, I have negative performance improvement. Must be missing something.
19:59:24 <Squarism> Well im prolly just a noob - but i keep rebuilding dependencies alot
19:59:49 <glguy> What causes that?
20:01:00 <Squarism> i havent used cabal sandbox alot
20:01:08 <Squarism> until minutes ago
20:01:15 <glguy> Ah, using sandboxes will certainly cause that
20:02:23 <benzrf> what can i read for a straightfoward explanation of STG stuff?
20:08:50 <Zemyla> benzrf: http://dev.stephendiehl.com/fun/000_introduction.html
20:09:40 <benzrf> thanks!
20:19:07 <Zemyla> Is there a proposal to add Data.Functor.Contravariant to base? I mostly want it so GHC can derive Contravariant.
20:31:25 <benzrf> are GADTs powerful enough to possibly have more than one functor instance
20:32:22 <coppro> nope
20:33:07 <mniip> fmap f (C ...) = C ...
20:33:16 <mniip> by parametricity and the id law
20:38:27 <jle`> i'm down with just absorbing most of transformers into base
20:38:42 <jle`> transformers is completely haskell 98, right?
20:39:00 <jle`> we're basically absorbing transformers module-by-module, anyway, with Identity etc.
20:39:07 <Zemyla> Yeah.
20:39:10 <jle`> oh wait why did i mention transformers when we were talking about contravariant
20:39:22 <Zemyla> Contravariant is Haskell 98, too.
20:40:19 <Zemyla> Well, honestly, I'm not sure we should absorb the monad transformers themselves, but MonadTrans and MonadIO should definitely be absorbed.
20:40:36 <jle`> oh when i talk about transformers i mean the functor/applicative transformers, not the typical monad transformers like WriterT/MaybeT etc.
20:41:12 <dfeuer> jle`, I think some bits are controversial; namely things like Eq1.
20:41:53 <jle`> is Eq1 transformers?
20:41:58 <jle`> isn't Eq1 already in base?
20:42:53 <jle`> i guess a lot of trasnformers types like Product/Sum/Constant already have alternatives in transformers
20:42:58 <jle`> *alternatives in base
20:43:14 <jle`> but it's a bit awkward that base's Product/Sum live in GHC.Generics
20:43:17 <Zemyla> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Classes.html It is.
20:43:45 <jle`> i wonder why such useful general-purpose combinators are hidden away in GHC.Generics
20:44:17 <Zemyla> jle`: I think that's so that you can write a typeclass over Generics without much worry that someone will use the functors within.
20:44:21 <dfeuer> jle`, I dunno. Some of that stuff.
20:44:27 <roboguy`> benzrf: a lot of GADTs can't have even one functor instance
20:44:40 <jle`> Zemyla: hm, how do you mean
20:44:50 <Zemyla> Actually, hmm.
20:44:58 <roboguy`> benzrf: (in fact, probably most of them can't have a functor instance)
20:45:00 <jle`> i mean, Product and Sum are the basis of the entire "data types a la carte" paradigm
20:45:17 <dfeuer> GRRRRRRRRRR
20:45:26 <Zemyla> Also, I'm super sad that Read1 and Read2 don't have functions in them that operate on ReadPrecs.
20:45:57 <dfeuer> Zemyla, there's a proposal for that up right now. Gotten a few +1s.
20:46:00 <jle`> i still see a lot of people recommending Sum/Product from transformers and not realizing that tehy're already in base, because they're hidden away so weirdly
20:46:14 <jle`> and Compose, too
20:46:16 <dfeuer> jle`, where are they?
20:46:23 <jle`> GHC.Generics
20:46:31 <dfeuer> Those have different names.
20:46:41 <jle`> yeah, but that's pretty much like Const/Constant
20:46:43 <dfeuer> And require the TypeOperators extension.
20:47:04 <dfeuer> And this fucking thing isn't going any faster.
20:47:26 <dfeuer> I may give up on it. It's really complicated, and tons of code, and slower than the simpler way.
20:47:29 <jle`> i think they're still generally useful enough to recommend over Sum/Product/Compose for most ues cases
20:47:55 <jle`> i mean, if you're using base-4.9, you're probably not worried about TypeOperators
20:48:22 <dfeuer> How's that follow?
20:48:43 <jle`> you're already on the bleeding edge :o
20:48:51 <dfeuer> ....
20:49:17 <jle`> not using extensions is usually a choice for portability, right?
20:49:23 <jle`> but base-4.9 is already non-portable
20:49:58 <Squarism> does scotty provide "websocket" out of the box? (i dont know the correct term.. some years ago they called it "comet" and "long pool")
20:50:04 <dfeuer> jle`, you can use base-4.9 and limit yourself to the portable parts.
20:50:26 <Squarism> long poll
20:50:31 <jle`> hm
20:51:34 <roboguy`> Squarism: Hmm, I'm not sure what you mean... there is a related package called kansas-comet that provides Comet style stuff
20:51:51 <roboguy`> ah, yeah. I think that's probably what you're looking for
20:52:33 <Squarism> roboguy`, oh ok.. im not sure what im lookign for but ill look into what you gave me
20:54:22 <roboguy`> both are made here at KU, so they work together well. I haven't directly used them together personally, but another package called blank-canvas (also from KU) uses them together
20:57:14 <mjrosenb> is there a way to check if a value has an accessor defined for it/
20:57:18 <mjrosenb> ?
20:57:38 <glguy> For example?
21:06:14 <Lisa1157> Hi, I am trying to understand how GADTs work, "Cons :: a -> List a -> List a" this is for a list GADT. I dont understand what this syntax means tho, does it mean that Cons is a data type that takes in a type 'a' and a List of type 'a', and returns a List of type 'a'?
21:07:30 <Koterpillar> Lisa1157: s/data type/constructor/, otherwise correct
21:07:35 <Koterpillar> List is a data type
21:08:07 <Koterpillar> i.e. if you have x :: a and y :: List a, then you are allowed to make Cons x y :: List a
21:08:37 <jle`> Lisa1157: that's actually the same constructor as for the normal list ADT
21:08:51 <jle`> (:) :: a -> [a] -> [a]
21:08:54 <jle`> :t (:)
21:08:55 <lambdabot> a -> [a] -> [a]
21:08:58 <jle`> you could write list as
21:09:09 <jle`> data [a] where [] :: [a]; (:) :: a -> [a] -> [a]
21:09:16 <jle`> you're just defining the constructors by their type :)
21:09:31 <jle`> data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a
21:09:32 <jle`> :t Just
21:09:33 <lambdabot> a -> Maybe a
21:09:36 <jle`> :t Nothing
21:09:37 <lambdabot> Maybe a
21:09:49 <dfeuer> Lisa1157, GADT syntax lets you give data constructors type signatures just like you give bindings. There are just restrictions on what they can look like.
21:10:05 <jle`> (it means that Cons is a constructor that takes something of type 'a' and something of type 'List a' and returns something of type 'List a')
21:10:22 <Koterpillar> Lisa1157: but with GADTs you can do fancier things, for example, restrict this Cons to only work for Int: Cons :: Int -> List Int -> List Int
21:11:22 <Lisa1157> alright I see, thanks everyone. I was just not clear on the syntax :)
21:12:21 <dfeuer> GRRRRRRRRRR
21:13:26 <pavonia> ?
21:14:23 <dfeuer> pavonia, I'm struggling to get GHC to unbox everything I want it to.
21:14:35 <dfeuer> It's very frustrating.
21:14:56 <pavonia> Ah, I thought that was related to the current conversation
21:15:25 <glguy> No, he just kind of does that..
21:15:50 <c_wraith> It might be rabies.  Should probably get that checked. :P
21:17:02 <dfeuer> glguy, yeah, I guess I do tend to let my frustration out audibly at somewhat inappropriate times and in baffling manners.
21:17:52 <dfeuer> glguy, you think you can help for a sec? I'm trying to convince GHC to unbox my record....
21:18:41 <phanimahesh> _GHC_ doesn't want to hear anything, it's over. :'(
21:18:52 <dfeuer> ?
21:20:50 <phanimahesh> Imagine GHC is a person, who isn't listening and you are trying to convince them.
21:21:19 <dfeuer> That is not a very happy thought.
21:21:52 <dfeuer> Nope; still no good.
21:21:54 <Cale> dfeuer: Isn't it possible to just use unboxed types directly?
21:22:02 <phanimahesh> Yes, that isn't a happy thought. Try bribing it with chocolate.
21:24:23 <dfeuer> Cale, yes, it is, but in this case that's a bit horrifying. In particular, I'd need to use  State# s -> (# s, ret1, ret2 #) instead of packing up ret1 and ret2 in a record and using ST s (TS ret1 ret2) as I'm currently doing.
21:24:30 <dfeuer> er...
21:24:46 <dfeuer> State# s -> (# State s, ret1, ret2 #), I mean.
21:24:59 <dfeuer> That's got a typo, but you know what I mean.
21:26:39 <Zemyla> dfeuer: CPS transform. (ret1 -> ret2 -> ST s r) -> ST s r.
21:27:40 <dfeuer> Zemyla, won't I end up building closures?
21:28:23 <dfeuer> I mean, I guess I could try, but that's a lot of transforming I think.
21:28:28 <Zemyla> If you consume them at the same place you produce them, and aggressively inline, then the closures shouldn't appear.
21:29:23 <dfeuer> Zemyla, I'll give it a whirl. Not sure if it'll work with the recursion, but I'll try. Why isn't GHC unboxing my tuples though? 
21:31:21 <Zemyla> dfeuer: Because converting (# s, (t, u) #) to (# s, t, u #) is actually quite difficult. Did you know that GHCi literally can't handle unboxed tuples at all?
21:31:33 <dfeuer> I knew the latter.
21:31:37 <dfeuer> The former not so much.
21:38:19 <dfeuer> Zemyla, I'm trying it now.
21:38:55 <dfeuer> ARGH
21:39:17 <dfeuer> Zemyla, it sort of worked. Except now I have to unpack *another* record from inside....
21:39:26 <dfeuer> This is *horrible*.
21:39:38 <dfeuer> Abstraction gone :(
21:44:38 <dfeuer> And something didn't inline....
21:55:07 <Zemyla> dfeuer: Try using SPECIALIZE INLINE.
21:55:15 <dfeuer> Zemyla, okay.....
21:56:52 <dfeuer> OI don't think it's working.
21:58:04 <Zemyla> You may have to unbox manually then.
21:58:40 <Zemyla> Though first, you should prove that the compiler's failure to unbox is causing your program undue hardship. If it's not inside a tight loop, then it's probably not necessary.
21:58:49 <dfeuer> Zemyla, that means giving up *everything* nice, including the ability to use >>=.
21:59:11 <dfeuer> Well, it's a bit hard to follow all the code, but I think it *is* in a tight loop.
21:59:28 <Zemyla> Benchmark, then.
22:00:57 <dfeuer> Last I checked the benchmarks were unimpressive. Doing some space profiling might help, but I'm fairly confident I'm allocating quite a bit more than I want to be. Cutting allocation is the whole goal of this insane implementation.
22:01:56 <dfeuer> CPS thing benchmarks badly.
22:02:00 <dfeuer> *sigh*
22:02:06 <dfeuer> Good night!
22:02:34 <mjrosenb> glguy: data Sample = A {x :: Int, y :: Int} | B {x::Int, z :: Int} | C {y :: Int, z :: Int}
22:03:44 <mjrosenb> and then ideally, there would be 3 functions either has_x, has_y and has_x :: Sample -> Bool, or get_{x,y,z} :: Sample -> Maybe Int
22:08:04 <pavonia> mjrosenb: You could use Template Haskell to derive such accessors from a data type
22:09:02 <mjrosenb> pavonia: I thought there might be an easier way (my guess would be lens, but lens is super-dense)
22:19:29 <joe9> need some advice, please? I have a haskell program that does some screen scraping. I want to be able to tell the program when I want it to check additional urls in addition to what it is currently doing. I am planning on changing the haskell program to listen on a socket for the additional urls.
22:19:45 <joe9> I have never done a haskell server process. Just want to check if you have any suggestions.
22:20:14 <joe9> I would have a forkIO on each new connection and the server program doing the screen scraping.
22:20:43 <Ashy> Depends how often it scrapes, it's probably easier to set up separate cron jobs
22:20:44 <joe9> and I can use Chan to communicate from the new connections to the server program.
22:20:59 <Ashy> Or if it's a learning process then carry on :)
22:21:16 <joe9> Ashy: I understand. It is a daemon process that I want to keep running continuously.
22:22:15 <joe9> I cannot figure out how to implement the "listen on socket for additional info and pass it on to the main process" part of the program.
22:24:06 <mjrosenb> joe9: a Chan sounds like a good way to do that.
22:24:07 <joe9> Ashy, found this https://wiki.haskell.org/Implement_a_chat_server . not sure if it is dated or still current though.
22:24:19 <joe9> mjrosenb: ^^
22:27:51 <Ashy> You could also do a simple rest api with scotty or servant
22:28:25 <joe9> ashy, thanks will check up on scotty or servant.
22:31:24 <joe9> Ashy, Thanks for the suggestion. Scotty seems to be a lot more heavyweight for this task.
22:34:27 <Ashy> Yeah true, just a suggestion...
22:34:53 <joe9> Ashy, Thanks. appreciate it a lot. I did not know that such stuff existed.
22:39:36 <Velizar> Is there any 'monad fiction'? That is, a fictional story with monads and such.
22:39:56 <johnw> most monad tutorials should fit that bill
22:40:39 <Velizar> tutorials are about explaining, rather than about being a story
22:40:47 <Koterpillar> alternatively, Summa Technologiae
22:42:53 <lieven> Velizar: Ari Juels Tetraktys
22:47:01 <f-a> is there a function like "getchar" that differentiates between the, err, first keystroke and when the key is being kept pressed (and there is an endless stream of characters)?
22:48:41 <Rotaerk> f-a, why? what are you trying to do?
22:49:23 <lieven> you'd need lower lewel system specific interfaces for that anyways
22:49:47 <f-a> Rotaerk: say I press the 'c' key, I'd like to intercept only the first 'c'. What for: a roguelike
22:50:21 <f-a> lieven: yeah I was dabbling with SDL, I hoped I could stay away from it
22:55:40 <lieven> well, with the terminal interface you need to put the input into raw mode, with X you need to look at X events. I have no idea what to do with windows. and so on
22:56:59 <f-a> thanks lieven 
23:03:39 <dfeuer> X X X
23:21:43 <joe9> I am trying to figure out if the readChan of Control.Concurrent.Chan blocks if there is nothing to be read. Is there a way to get a non-blocking version of the Chan?
23:22:08 <joe9> isEmptyChan seems to be deprecated.
23:23:05 <monochrom> Chan does not really work well for non-blocking operations
23:23:39 <monochrom> TChan is better, for this and other uses, if you don't mind using STM
23:24:29 <joe9> monochrom, Thanks. https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TChan.html
23:32:44 <Cale> joe9: Note that you can use orElse :: STM a -> STM a -> STM a in conjunction with TChan stuff to attempt reading from multiple channels.
23:33:03 <Cale> (assuming that's the reason you want a nonblocking read)
23:33:17 <joe9> Cale, I think I can use atomically $ tryReadTChan ?
23:33:24 <Cale> You can
23:33:27 <joe9> so, I can get the value as a  "Maybe a"
23:33:35 <joe9> and I do not have to worry about the STM monad.
23:34:26 <Cale> Well, it might just be a little cleaner if you're trying to read from more than one TChan to do it that way, so you don't need to pattern match the Maybe in order to decide what to do next.
23:35:06 <joe9> Cale, oh, ok. I have a single reader Channel.
23:35:10 <Cale> Or, well, I don't know the reason for doing a nonblocking read, so...
23:35:54 <Cale> Usually the way I imagine Chan/TChan getting used, you would want the overall operation to block a fair amount of the time.
23:57:36 <ongy> what's the best way to get a diff between ghc-7.10 and ghc-8.0 template haskell?
