00:07:39 * hackagebot versions 3.0.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.0.0 (fosskers)
00:07:39 * hackagebot wai-cors 0.2.5 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.5 (larsk)
00:08:33 <nblu> Hi, I am starting to work on a simple HTTP server that produces Kafka messages from POSTs and GETs. I am looking for good libraries to get a very good throughput.
00:10:29 <nblu> I found Mighthttpd, which seems to require running the Kafka producer from a CGI script. Is this a reasonable approach to handle >10k requests/s per server? Or should I rather look into solutions which are kept alive in memory?
00:10:43 <nblu> Suggestions on libraries to investigate?
00:14:25 <mfukar> nblu, at 10k rps, is memory your bottleneck? I bet it's still the network.
00:15:46 <nblu> ah, I was quite imprecise there: the point would most likely not be the memory, but the fact, that CGI means to spawn a new process on every request
00:17:34 <zomg> nblu: FastCGI might help with that, if it's supported
00:18:45 <mfukar> Gotcha
00:32:42 <tdammers> with CGI, there is always at least the process spin-up overhead
00:33:32 <tdammers> if your application can be cached aggressively, this may not be a big deal, but if you actually need to run the CGI program for every request, then 10k rps means 10k processes started and stopped per second
00:33:55 <tdammers> it also means that any initialization code you need to run at process startup has to run 10,000 times per second
00:34:59 <nblu> I also had a look if FastCGI is supported by mighttpd and it seems like it is not (not sure though, only found rather old information)
00:35:04 <EvanR> and if the program is a demon that is being connected to for results 10000 times per second, thats overhead too. which is why fastcgi lets you multiplex many requests on the same connection
00:35:07 <tdammers> anyway, if we're talking Haskell anyway, then Warp behind a reverse proxy, or FastCGI, or SCGI, are about as easy to write as a CGI server
00:36:05 <EvanR> a fastCGI "monad" which exploits concurrency is really nice IMO
00:36:32 <tdammers> in fact, you could probably just write your code to support them all, and pick the most performant when deploying
00:36:34 <EvanR> i hate to see entire technology stacks invented to replace it
00:37:56 <tdammers> yep
00:37:58 <nblu> EvanR, would you have any references to where I could read more about that approach?
00:38:21 <Axman6> nblu: anything using warp should be plenty fast, if your app is able to scale properly. I'm a big fan of servant for apps like you're describing
00:38:33 <tdammers> the only real gripe I have with FastCGI is how you have to be careful not to poison stdout
00:38:55 <EvanR> what does stdout have to do with it?
00:39:17 <EvanR> it uses a dedicated socket
00:39:40 <tdammers> oh wait, yes, I was confused for a second there
00:41:04 <EvanR> what on earth... https://hackage.haskell.org/package/fastcgi-3001.0.2.4/docs/Network-FastCGI.html
00:41:21 <EvanR> its "hard coded" to use forkOS for each request
00:41:24 <EvanR> why
00:41:50 <EvanR> (rather than forkIO)
00:42:32 <EvanR> nblu: well, just any thing on concurrent haskell and the spec for fastcgi
00:43:00 <nblu> Axman6, I might indeed just start with warp and see how it behaves. Also going to read about servant, thanks.
00:44:23 <nblu> EvanR: Ok, sounds like a big, good learning opportunity! ;)
00:46:50 <EvanR> a web app that is totally self contained as one haskell program is probably best though
00:47:02 <EvanR> simpler and high performance
00:56:15 <nblu> EvanR: and for doing so, Warp would be a proper starting point, I guess? Just wondering if there is something else I should be aware of. From my research so far is seems like Wai & Warp are at least the most popular libs
01:07:35 <EvanR> nblu: yes, also servant
01:08:29 <Axman6> nblu: warp is a web server, it's not what you'd actually use to write your app, you'd use something like servant or scotty to actually write your handlers, and warp takes care of running that concurrently
01:22:34 * hackagebot rison 1.0.0.0 - Parses and renders RISON strings.  https://hackage.haskell.org/package/rison-1.0.0.0 (martinvlk)
01:58:50 <Guest22155> @pointfrree 
01:58:50 <lambdabot> Unknown command, try @list
01:59:22 <Guest22155> @pointfree \x -> (x, f x)
01:59:23 <lambdabot> Unknown command, try @list
01:59:41 <Akii> I think the command is @pl
02:00:15 <Guest22155> @list
02:00:15 <lambdabot> What module?  Try @listmodules for some ideas.
02:00:41 <Guest22155> @listmodules
02:00:41 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:01:09 <Guest22155> @list pointful
02:01:09 <lambdabot> pointful provides: pointful pointy repoint unpointless unpl unpf
02:01:51 <Guest22155> @list pl
02:01:51 <lambdabot> pl provides: pointless pl pl-resume
02:02:24 <Guest22155> @pointless \x -> (x, f x)
02:02:25 <lambdabot> ap (,) f
02:07:39 <TRManderson> Where do I go to report errors in the fpco/stack-build:lts-6.2 docker image on the Docker for Windows beta?
02:10:03 <fvh> I have small app in snap and recently switched to stack, earlier I can `cabal install -f development` to start hot-reload mode, how can I do this with stack?
02:12:36 * hackagebot hylogen 0.1.3.1 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.3.1 (sleexyz)
02:22:09 <mgsloan> fvh: Not sure if snap has caught up with such things yet
02:25:32 <siwica> Is there a library that provides a data type "country" that consists of all countries on earth? 
02:25:52 <tdammers> siwica: that doesn't strike me as something you want to hard-code into your types
02:26:02 <tdammers> that stuff just changes too fast and too unpredictably
02:26:25 <siwica> So you would just go with Strings?
02:26:41 <tdammers> I would go with a custom data type that holds the relevant country information
02:27:06 <EvanR> that stuff goes in a database
02:27:11 <tdammers> pull that information from a file or database
02:27:14 <tdammers> exactly
02:27:24 <siwica> I would just need something like 'data Country' = Germany | USA | France''
02:27:53 <tdammers> the problem with that is that your application then cannot deal with countries appearing or disappearing once compiled
02:28:10 <tdammers> and unfortunately, on a global scale, this kind of thing is the norm, not the exception
02:28:14 <EvanR> newtype Country = Country { countryName :: String }
02:28:26 <EvanR> germany = Country "germany"
02:28:38 <EvanR> now at least its not a string
02:28:51 <siwica> Hm, Maybe
02:29:05 <tdammers> you could also look into, say, geonames' countryInfo API
02:29:06 <siwica> I was just concernd with countries having multiple names
02:29:09 <EvanR> and you can rely on a database (of strings) 
02:29:25 <siwica> "USA", "United States", "United States of America", ...
02:29:28 <EvanR> countryNames :: [String]
02:29:37 <EvanR> commonName :: String
02:29:45 <EvanR> abbrev :: String
02:29:45 <tdammers> data Country = Country { countryCode :: String; countryNames :: [String] }
02:29:46 <EvanR> etc
02:29:50 <siwica> And wanted to map them all to the same data type
02:29:59 <tdammers> alternatively:
02:30:08 <EvanR> those alternative names are properies of a country, not the implementation of a country
02:30:13 <tdammers> countries :: HashMap CountryName CountryInfo
02:30:24 <tdammers> (or additionally)
02:30:33 <EvanR> a set of countries indexed by whatever
02:30:42 <EvanR> i.e. database
02:31:34 <siwica> EvanR: Sure. What I initially thought was to have one datatype per country convert different names (from various sources) to the same type
02:31:45 <EvanR> siwica: the countries form a (mutable) set, the members of this set of abstract. all the usual things we know about countries are images of this set
02:31:56 <EvanR> the members of this set are abstract*
02:32:11 <EvanR> to go backwards from information to country, you use an index
02:32:26 <EvanR> one datatype per country seems the wrong way around
02:33:23 <tdammers> you could have an enum datatype for country identifiers, but again, this means you hard-code the list of existing countries into the application, which is needlessly rigid
02:33:31 <EvanR> one particularly useful index is "arbitrary ID"
02:33:38 <EvanR> which is a unique index
02:34:04 <siwica> Yes, probably that's an idea
02:34:04 <EvanR> but country codes would also work and not be as artificial
02:34:22 <EvanR> and are easier to typ
02:35:24 <siwica> I want to program an application to manage chess tournaments and I am concerned to get all abstractions right from the beginning
02:35:38 <EvanR> arbitrary ID works as long as it doesnt escape the confines of the system
02:35:55 <EvanR> that might be annoying
02:36:41 <tdammers> the risk with natural keys however is that you might end up building other functionality on them, which could violate "single responsibility"
02:36:51 <siwica> Having not too much experience with languages with sophisticated type systems it's not always easy to decide what data abstractions are useful
02:36:56 <tdammers> e.g., you might be tempted to use the country's English name for the index
02:36:56 <EvanR> theyre not keys, they are just another index
02:37:39 <EvanR> if they dont have any inherent ID no one can be blamed for using one thing over the other ;)
02:39:03 <EvanR> siwica: honestly haskell's type system as it is doesnt map directly to the dataset picture i was describing, but you can make it work
02:39:24 <siwica> Ok, I will think about it. Thank you!
02:39:27 <EvanR> to get off the ground quickly you can just use country code strings to refer to a country, and all your data can key on that
02:39:41 <EvanR> it shouldnt be hard to replace it all if you need to
02:40:32 <siwica> So you would just do "data Country = GB | GER | ... | FR" as a starter?
02:40:36 <EvanR> no
02:40:50 <siwica> ok, I see
02:41:01 <siwica> Sorry. That would be immutable
02:41:03 <EvanR> someCountries = ["no","de","fr","us"]
02:41:22 <EvanR> type Country = String
02:41:27 <EvanR> longNames :: Country -> [String]
02:41:29 <EvanR> etc
02:41:50 <EvanR> loadLongNames :: FilePath -> IO (Map Country [String])
02:42:44 <EvanR> this is quick and not hard to reimplement with a different backend
02:43:08 <siwica> Ok, thank you!
02:47:53 <siwica> Do you know if there is a good book for data modeling in haskell?
02:54:08 <EvanR> siwica: i wish
02:54:18 <rydgel> I wish too
02:54:45 <EvanR> "you havent written it yet"
02:54:46 <siwica> You guys are experienced. You should write one ;-)
02:56:30 <koz_> siwica: Dunno about you, but I dunno shit about either Haskell or data modelling.
02:57:36 <EvanR> database stuff is a field were mainstream has been almost tricked into doing something heavily mathematical
02:57:52 <EvanR> so it would be a great place for haskell to move in and clean up
02:58:35 <tdammers> fortunately, someone misinterpreted the word "relational" to save the day
03:00:31 <siwica> tdammers: what do you mean by that?
03:02:21 <EvanR> for the full report, read all of c2wiki
03:03:17 <tdammers> siwica: the word "relational" in "relational database" refers to how tables are relations. Not necessarily to how foreign keys "relate" tables to one another
03:06:39 <siwica> ok, sure!
03:07:10 <nut> clc
03:24:49 <nut> test
03:27:46 <EvanR> failed
03:29:35 <nut> Intero for Emacs works quite well
03:30:02 <nut> is it possible to launch the stack exec myprogram directly?
03:30:08 <Xandaros> tdammers: I never actually understood how tables are relations
03:30:55 <Xandaros> nut: interreto? :P
03:31:09 <EvanR> as implemented in *SQL you have to squint really hard while wearing beer goggles
03:31:33 <nut> Xandaros, didnt get that joke
03:31:54 <Xandaros> Oh, this isn't -blah. nvm
03:45:24 <nomeata> Hi. Is there an easy way to resolve a stackage name like nightly or lts-6 to the name of the actual snapshot?
03:52:44 <bergmark> nomeata: if you request https://www.stackage.org/lts you get redirected to 6.2, is that what you had in mind?
03:53:14 <nomeata> bergmark: something like that, but preferably scriptable
03:53:38 <ocramz> hullo!
03:53:45 <nomeata> But I found a work-around: I write "resolver: lts-1.0" to stack.yaml (thus avoiding stack init) and then let "stack solver --resolver nightly --update-config" update it.
03:55:21 <bergmark> oh i didn't know about --update-config, hvr asked about something like that yesterday
03:57:33 <ocramz> Q: is there a difference (or a reason to prefer) FunctionalDependencies over TypeFamilies, when a MPTC needs type parameters? e.g., between declaring `class Sized c t | t -> c` and `class Sized c where type Tc t` ?
04:00:00 <lyxia> I can't think of any
04:00:17 <EvanR> functional dependencies take less typing
04:02:39 * hackagebot tttool 1.6.1.1 - Working with files for the Tiptoi® pen  https://hackage.haskell.org/package/tttool-1.6.1.1 (JoachimBreitner)
04:05:04 <bergmark> ocramz: i think type families are nicer because you get a type function, but if you need a two way dependency you need FDs (or closed type families but that only works for some specific cases)
04:13:06 <nomeata> Ah, the work-around does not work; stack solver --update-config --resolver foo does not change stack.yaml even if resolver differs.
04:21:45 <hpc> another very minor benefit of fundeps is you can see what the 'c' type is in the class constraint
04:29:38 <zoran119> i'm trying to make a function that finds the index of the largest element in a list and is one of attempts:
04:29:43 <zoran119> maxIndex xs = snd . maximum $ zip xs [0..]
04:30:27 <zoran119> however, when called on a large-ish list the kernel kills the process because it consumes all the ram
04:30:52 <ocramz> space leak!
04:31:54 <zoran119> ocramz: am i creating the space leak in that function?
04:32:31 <ocramz> it looks like
04:33:28 <ocramz> there are a few fixes: use a strict fold, for example
04:37:40 * hackagebot subwordgraph 1.0.2 - Subword graph implementation  https://hackage.haskell.org/package/subwordgraph-1.0.2 (adambak)
04:38:19 <EvanR> @src maximum
04:38:19 <lambdabot> maximum [] = undefined
04:38:19 <lambdabot> maximum xs = foldl1 max xs
04:38:47 <EvanR> blah
04:41:09 <liste> what's the point of that first match?
04:41:25 <liste> > foldl1 (+) []
04:41:27 <lambdabot>  *Exception: Prelude.foldl1: empty list
04:42:16 <Xandaros> > maximum []
04:42:17 <lambdabot>  *Exception: Prelude.maximum: empty list
04:42:51 <liste> ~so it's really something like `error "Prelude.maximum: empty list"'. that makes sense (:
04:43:07 <merijn> liste: @src is filled with lies :)
04:43:29 <merijn> liste: It's just a textual database and most of the entries come from the haskell report, not what GHC actually uses
04:45:06 <EvanR> does maximum use a strict fold or
04:45:28 <merijn> EvanR: Mu
04:46:34 <EvanR> > maximum [1..1000000]
04:46:35 <lambdabot>  *Exception: stack overflow
04:46:41 <EvanR> raw
04:46:49 <merijn> EvanR: The question is ill-formed
04:46:51 <merijn> :t maximum
04:46:53 <lambdabot> (Ord a, Foldable t) => t a -> a
04:47:00 <merijn> EvanR: It depends on the foldable instance
04:47:05 <EvanR> oh geez
04:47:35 <EvanR> is there a newtype then so lists work again
04:47:48 <osa1> this sounds awesome: https://mail.haskell.org/pipermail/haskell-cafe/2016-June/124096.html is Hackage using this version yet?
04:48:52 <Xandaros> osa1: uhhhh, I like that
04:49:05 <merijn> EvanR: Why do you need a newtype for that?
04:49:14 <EvanR> because
04:49:17 <EvanR> > maximum [1..1000000]
04:49:19 <lambdabot>  *Exception: stack overflow
04:49:31 <EvanR> maximum (Working [1..1000000])
04:49:35 <EvanR> 1000000
04:49:51 <merijn> oh, I see what you mean
04:50:09 <merijn> EvanR: I think they kept it lazy for backwards compatibility because the old one was lazy?
04:50:35 <EvanR> whats the use of maximum that is using a lazy left fold
04:50:54 <osa1> yeah it's awesome. Hackage is probably lagging a little bit though
04:52:36 <Xandaros> I upload docs manually, anyway. I don't trust hackage :P Also, I don't need this, but I still love it
04:52:41 * hackagebot ghc-heap-view 0.5.6 - Extract the heap representation of Haskell values and thunks  https://hackage.haskell.org/package/ghc-heap-view-0.5.6 (JoachimBreitner)
04:54:38 <EvanR> ghc-heap-view looks cool
05:06:12 <quxbam> Is the order of a sumtype significant for the performance of derived instances like Eq?
05:06:42 <quxbam> Let's say we've got  data A = B | C | D deriving (Eq)
05:07:07 <quxbam> If D is a lot more frequent than B, would it help to move it to the beginning?
05:08:20 <quchen> quxbam: Sum types are represented by an int tag by the compiler, so you're paying a flat int comparison.
05:08:57 <quchen> At least I would think that. :-)
05:09:51 <quchen> And besides, you should be extremely sure about your bottlenecks before you reorder your code to optimize it.
05:10:13 <EvanR> i use shorter variables names to speed things up
05:10:16 <lyxia> there is a comment about this in containers for example
05:10:24 <quxbam> I've profiled and it says that my bottlenecks are (==) and compare
05:10:30 <quchen> à² _à²  EvanR 
05:10:34 <EvanR> lol
05:11:07 <lyxia> http://hackage.haskell.org/package/containers-0.5.7.1/docs/src/Data.Map.Base.html [Note: Order of constructors]
05:11:08 <quxbam> So I guess I'm stuck
05:11:44 <quchen> If you're feeling really hardcore you could fall back to enumToTag.
05:12:00 <quxbam> Thanks lyxia
05:12:12 <quchen> But that's probably not what you want, and opens a barndoor to footshootings.
05:12:13 <quxbam> I guess I'll use criterion to see if it's still valid
05:12:24 <quxbam> what does enumToTag?
05:12:41 * hackagebot tianbar 1.0.0.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.0.0.0 (AlexeyKotlyarov)
05:13:03 <freinn> hi! I'm having problems with nested do blocks, but I need them because I'm using recursion, code and error here: http://pastebin.com/yKXWWRcP
05:13:24 <quxbam> My situation is that I've got a *huge* data type (about 150 constructors) and some occur very frequent...
05:13:53 <EvanR> freinn: this looks like a mess
05:13:55 <maerwald> freinn: line 55 looks wrong indented
05:14:07 <maerwald> it's not part of the let, so why is it indented like it
05:14:16 <EvanR> 55 is right
05:14:34 <quxbam> freinn: you can't put the "then" or the "else" on the same column than the if in an do block
05:14:59 <quchen> quxbam: Sounds like your problem is the huge, not the ordering.
05:15:20 <EvanR> i take it back
05:15:25 <freinn> EvanR interesing aportation
05:15:27 <quchen> You could add hashes for faster comparisons, similar to the FastString type in GHC.
05:15:43 <lyxia> freinn: then do let ...
05:16:32 <merijn> And even when doing "do let" you need to indent line 55 less
05:16:46 <EvanR> lpaste is down ;_;
05:16:57 <merijn> freinn: But, in general, I would drastically refactor this code, because it's a mess to read, atm
05:17:08 <merijn> freinn: Move part into a where-clause
05:17:19 <quxbam> quchen: My comparisons take place in a lot of small Sets, I've already tried HashSet, but it got slower and the bottleneck was the hashing according to the profiler
05:17:27 <freinn> merijn tell me how to improve it plz
05:18:06 <quchen> quxbam: You could also write your own Ord instances that compare the fields that are likely to be different first
05:18:55 <quxbam> quchen: That's a good idea, but a lot to write
05:19:01 <quxbam> I'll try it
05:19:09 <quchen> And that among not only single data types like in the derived Ord instance, but also looking down the type a couple of levels
05:19:26 <quxbam> The profiler suggests that I've got ca. 10.000.000 calls to compare :)
05:19:27 <quchen> But that solution depends highly on the usage patterns, and might make things worse in the general case
05:19:55 <quchen> In that case, your program simply does a lot, maybe that's why it is slow :>
05:20:21 <quxbam> 2s, not that bad actually. But I'd like to be in subsecond
05:20:39 <EvanR> freinn: http://codepad.org/vjUaDr6p my first attempt at reformatting it
05:20:51 <quxbam> but compiles 30min :o
05:21:45 <EvanR> also (getFun oper) result rhs = getFun oper result rhs
05:22:06 <quchen> Reformatting won't do here, what you need is several well-named helper definitions instead of one monolithic block.
05:22:44 <quxbam> quchen: I also thought about using a bloomfilter, but the only implementation seems to be abandoned
05:23:11 <freinn> EvanR thanks
05:24:07 <quchen> quxbam: Which one?
05:24:23 <quxbam> https://hackage.haskell.org/package/bloomfilter
05:24:44 <quchen> Does it build?
05:24:51 <quxbam> it crashes on 32bit
05:25:12 <quchen> Hm.
05:25:29 <quxbam> And hasn't recent activities, issues and prs aren't attended etc
05:26:41 <quchen> Bryan's gotten a bit quiet over the last years, yes. :-(
05:27:42 * hackagebot hsx-jmacro 7.3.8 - hsp+jmacro support  https://hackage.haskell.org/package/hsx-jmacro-7.3.8 (JeremyShaw)
05:27:46 <quxbam> Well, I've to go, but thank you very much quchen!
05:34:31 <maerwald> github should transfer ownership of projects if PRs are unattended for half a year or so
05:34:57 <maerwald> happens to a lot of haskell libs
05:35:06 <EvanR> uh to who?
05:35:17 <maerwald> the guy who created the PR
05:35:22 <EvanR> haha
05:35:58 <quchen> You can transfer ownership on Github by forking things.
05:36:07 <quchen> What you want is ownership on Hackage.
05:36:13 <maerwald> quchen: well, both
05:36:30 <Ankhers> maerwald: What if there are multiple PRs waiting approval?
05:36:39 <EvanR> yeah better to let things remain and create a new fork
05:36:45 <maerwald> Ankhers: give ownership to the first guy and add the rest as collaborators.
05:36:57 <maerwald> EvanR: that doesn't fix the issue
05:37:10 <EvanR> it certainly doesnt create new issues
05:37:13 <maerwald> the old package is already distributed and people use it
05:37:22 <Ankhers> maerwald: And what if that person didn't want ownership? Or lost interest in 6 months?
05:37:28 <maerwald> and it's dead and no easy way to tell users of the lib that you have a better fork
05:37:41 <maerwald> Ankhers: details...
05:37:59 <basdirks> Is it possible to suppress stack traces in ghci for `error`? (other than using `errorWithoutStackTrace` instead of `error`)
05:39:10 <maerwald> quchen: but yeah, if hackage had a "request package ownership" or so that the maintainer must respond to, otherwise it's transferred, then that would be interesting
05:39:11 <quchen> basdirks: What's the problem with the verbosity?
05:39:14 <maerwald> I imagine it could cause spam though
05:40:07 <basdirks> quchen, I <3 the stack traces. But I use doctests to make sure I kill the process for the right reasons, for various incorrect inputs
05:40:34 <bergmark> maerwald: me essentially have that https://wiki.haskell.org/Taking_over_a_package
05:40:35 <basdirks> the stack traces contain line numbers and file name, which is awesome, but not for tihs
05:41:24 <maerwald> bergmark: that's a tedious manual process
05:41:43 <maerwald> I really think this should be more automated
05:42:42 * hackagebot hackage-security 0.5.2.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.2.0 (DuncanCoutts)
05:42:49 <bergmark> meh, i've only done it once and that was fine by me
05:43:21 <maerwald> most people won't care to go through that process and start a fork, which then means there's another dead library on hackage
05:43:27 <basdirks> I could return `Either String a` instead of `error`ing, but I think it would be overkill right now.
05:47:46 <quchen> basdirks: You can add invisible helper definitions to doctests, you could catch errors in there.
05:48:34 <quchen> You should not test the error string because that's not for the user, but for the developer. "error" being called is a bug, not an exception that a user should have to deal with.
05:48:44 <joncfoo> is there a ghc option that checks for pattern patch failures in "do expressions"?
05:49:21 <quchen> joncfoo: Nope :-/
05:49:36 <joncfoo> curses!
05:49:47 <quchen> joncfoo: You'll have to write an explicit case expression to do this
05:50:15 <joncfoo> yes I had to do that - that's one more thing I have to remember
05:50:22 <quchen> do { x <- foo; case x of Just y -> â€¦ }
05:50:31 <basdirks> quchen: clear, thanks
05:50:45 <joncfoo> I wonder if there is a ghc bug
05:50:49 <joncfoo> ticket open rather
05:51:54 <quchen> joncfoo: It's not a bug. Unfortunately, if you ask me. It has to do with the 'fail' function from Monad.
05:52:23 <quchen> Pattern match failures are desugared to a call of 'fail', and until around GHC 8.6 that will remain the case.
05:52:34 <quchen> Warnings will gradually make it harder though.
05:52:58 <joncfoo> that's...strange
05:54:35 <joncfoo> does hlint or some other checker offer warnings as of today?
05:55:31 <quchen> I don't think so.
05:55:44 <quchen> Avoid failable patterns, that's as good as it gets.
05:56:55 <joncfoo> ok thanks quchen - I'm glad to know that the feature/warning is in the pipeline
05:57:12 <quchen> joncfoo: It's in GHC 8.0 already, but disabled
05:57:43 * hackagebot jsaddle 0.4.0.2 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.2 (HamishMackenzie)
05:58:33 <quchen> joncfoo: See -XMonadFailDesugaring
05:58:47 <joncfoo> sweet :)
05:58:54 <quchen> Seems to be undocumented in the release notes. I wonder why they removed that.
05:59:25 <quchen> joncfoo: And this one might be interesting for your own monad instances. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wmissing-monadfail-instances
06:02:43 * hackagebot jsaddle-dom 0.1.0.2 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.1.0.2 (HamishMackenzie)
06:07:27 <joncfoo> thanks for the info quchen & also for working on it!
06:07:43 * hackagebot obdd 0.3.3 - Ordered Reduced Binary Decision Diagrams  https://hackage.haskell.org/package/obdd-0.3.3 (JohannesWaldmann)
06:12:43 * hackagebot reform-hsp 0.2.7 - Add support for using HSP with Reform  https://hackage.haskell.org/package/reform-hsp-0.2.7 (JeremyShaw)
06:29:40 <shirt> dcoutts: https://github.com/haskell/cabal/issues/3485
06:42:44 * hackagebot clash-prelude 0.10.8 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.10.8 (ChristiaanBaaij)
06:44:42 <freinn> hi! I'm programming a precedence climbing algorithm with Parsec, but I don't know why it doesn't work. Maybe I'm losing information between mutual recursion calls? http://lpaste.net/165643
06:47:44 * hackagebot clash-lib 0.6.16 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.16 (ChristiaanBaaij)
06:47:46 * hackagebot clash-vhdl 0.6.12 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.12 (ChristiaanBaaij)
06:47:49 * hackagebot clash-ghc 0.6.18 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.18 (ChristiaanBaaij)
06:52:45 * hackagebot instance-control 0.1.1.0 - Controls how the compiler searches for instances using type families.  https://hackage.haskell.org/package/instance-control-0.1.1.0 (lazac)
06:57:45 * hackagebot references 0.3.1.0 - Selectors for reading and updating data.  https://hackage.haskell.org/package/references-0.3.1.0 (lazac)
07:07:45 * hackagebot structural-traversal 0.1.1.0 - Initial project template from stack  https://hackage.haskell.org/package/structural-traversal-0.1.1.0 (lazac)
07:18:36 <freinn> stackoverflow points if you help me with that problem guys: https://stackoverflow.com/questions/37681474/precedence-climbing-in-haskell-parsec-mutual-recursion-error
07:20:44 <ondrejs> hello. I created module A ( State ) where ... data State = State {...}, then I do 'import qualified A' but using A.State as a constructor says 'not in scope: data constructor A.State'. Any hints please? Thank you
07:21:20 <Boomerang> ondrejs: try to export State (..)
07:21:20 <tdammers> you need to export the constructors
07:21:35 <tdammers> module A (State) -- only exports the type, but not the constructors
07:22:38 <ondrejs> Boomerang, tdammers: thank you guys!
07:23:22 <bernalex> lpaste is down QQ
07:28:10 <ondrejs> on the same note: can I somehow group export lenses made with 'makeLenses'? Or do I have to export x for each record field x?
07:40:31 <quchen> ondrejs: You can also have lenses derived in their own module that simply exports everything.
07:56:38 <Tekkkz> what do you think about using haskell as web backend languange and web server / game server language?
07:58:13 <sm> sounds good
07:59:00 <Tekkkz> sm, why?
07:59:17 <Akii> it's fast
07:59:26 <sm> haskell's a good language
07:59:28 <EvanR> concurrent haskell makes writing network demons a breeze (relatively speaking)
07:59:41 <EvanR> and the type system keeps all your shit straight
07:59:41 <Akii> sm:  well can't argue with that :D
07:59:45 <maerwald> Tekkkz: hedgewars uses haskell as their server language
07:59:54 <maerwald> not for the game logic though
08:01:17 <Tekkkz> maerwald: what stuff is managed by there haskell server apps?
08:01:34 <maerwald> I don't understand that question
08:02:14 <EvanR> game stuff ;)
08:02:43 <ondrejs> quchen: oh, ok. Thank you
08:02:44 <Tekkkz> what exactly are they doing with haskell?
08:02:56 <maerwald> Tekkkz: the server
08:03:00 <maerwald> https://github.com/hedgewars/hw/tree/master/gameServer
08:03:03 <Tekkkz> game server?
08:03:07 <maerwald> erm 
08:03:47 <sm> why can't haddock deal with https://gist.github.com/simonmichael/fdac7d81effd70c46e4831702a76059e ?
08:04:25 <sm> I keep falling into the trap of wasting time on such docs.. what's the best workaround ?
08:12:46 <glguy> sm: You only get to put a comment on a record field, not components of its type
08:12:56 <sm> bah
08:12:57 <dolio> Make real types instead of using tuples?
08:12:58 <glguy> so you can either do:  myField :: (a,b,c) -- ^ (this,that,the other)
08:13:03 <glguy> or make a new record
08:13:28 <sm> that's what I had an hour ago before I started on this :-)
08:13:43 <sm> maybe a new record type then, thanks
08:17:47 * hackagebot jsaddle-dom 0.1.0.3 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.1.0.3 (HamishMackenzie)
08:22:47 * hackagebot stack-run-auto 0.1.1.3 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.1.3 (yamadapc)
08:29:38 <henke> I ThreadScope still the one tool to use for paralell Haskell applications? The install instructions seems for OSX is old and im not able to install it.
08:29:44 <henke> *Is
08:30:37 <thoughtpolice> ghc-events-analyze is also very useful but doesn't have the exact same visualisation. No GTK, though.
08:30:58 <thoughtpolice> http://www.well-typed.com/blog/2014/02/ghc-events-analyze/
08:32:09 <Akii> henke: just use homebrew
08:32:15 <Akii> works like a charm
08:32:48 * hackagebot stack-run-auto 0.1.1.4 - Initial project template from stack  https://hackage.haskell.org/package/stack-run-auto-0.1.1.4 (yamadapc)
08:33:39 <henke> Akii: brew install threadscope?
08:37:09 <sirreal> :q
08:38:44 <sirreal> 
08:45:20 <henke> can i have cabal-install side by side with stack? Homebrew need it for some of its installed 
08:47:41 <dredozubov_> why not?
08:49:27 <henke> dredozubov: so i can install the haskell platform and still use stack for when i want?
08:50:16 <dredozubov_> just install cabal-install with stack and you won't need the haskell platform
08:52:10 <mrpat> hi all, Iâ€™m trying to understand how to build a minimalistic context for runGinger for the library: http://hackage.haskell.org/package/ginger-0.2.5.0. anybody can help?
08:53:18 <mrpat> so far I have: http://lpaste.net/165644
08:53:19 <joncfoo> mrpat: how about the example in Text.Ginger.Run ?
08:55:04 <mrpat> joncfoo: I canâ€™t make it work, iâ€™m getting a: parse error on input â€˜contextâ€™ for that line: context = makeContext contextLookup
08:55:32 <srhb> mrpat: It has to be indented equally far as contextLookup (it's the same let block)
08:56:10 <srhb> mrpat: If that's not it, paste your version. 
08:58:04 <mrpat> srhb: http://lpaste.net/165644
08:58:36 <joncfoo> let needs to be further indented
08:59:09 <mrpat> joncfoo: my bad, correcting
08:59:32 <joncfoo> try http://lpaste.net/165644
08:59:50 <EvanR> as part of my programs inner guts i have a list of existentially wrapped things, which hides one of their type variables, effectively a hetero list
08:59:52 <mrpat> joncfoo: the corrected version: http://lpaste.net/165644
09:00:06 <EvanR> and it actually works since i loop through and use a polymorphic function on the contents
09:00:26 <mrpat> itâ€™s still complain: parse error on input â€˜contextâ€™
09:00:30 <EvanR> somewhere else. its really a mind blowing thing, because the basic advice you get ... always... is to use homolists
09:00:33 <Xandaros> Is there a standard function which does `\x -> map ($x)`?
09:01:06 <glguy> no
09:01:13 <joncfoo> mrpat: align it with the let
09:01:20 <joncfoo> or just put `let context = ...`
09:01:23 <joncfoo> and align the lets
09:01:29 <Xandaros> :( I feel like there should be
09:01:59 <mrpat> joncfoo: I did it, now i get: parse error on input â€˜=â€™ at: context = makeContext contextLookup
09:02:49 <joncfoo> mrpat: this is happening because on unaligned expressions
09:03:24 <joncfoo> what does your code look like now?
09:03:45 * EvanR goes to look up what "the existential antipattern" is
09:06:11 <EvanR> ah "existential typeclass"
09:06:32 <mrpat> joncfoo: I think itâ€™s my case: here it is: http://lpaste.net/165644
09:11:42 <nitrix> EvanR: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:17:19 <nickcbg> hi, is there a newtype for the constraints kind ?
09:17:40 <nickcbg> newtype MyShowNum a = MyShowNum (Num a, Show a)
09:20:44 <geekosaur> what would newtype do there that type doesn't?
09:22:59 <benzrf> nickcbg: that's not how typeclasses work
09:23:12 <benzrf> nickcbg: oh, sorry - i see what you were asking
09:28:05 <geekosaur> more specifically, if you want to create a constraint alias, with ConstraintKinds enabled it's: type MyShowNum a = (Num a, Show a)
09:28:18 <tippenein> seems like haskell's numeric stability is much better than pythons?
09:29:00 <inkjetunito> what is numeric stability?
09:30:11 <tippenein> doing some udacity deep learning and I've been doing the exercises in haskell.. until this one that asks to take 1billion + (fold (+) 0 (replicate 1000000 0.000001)) - 1billion
09:30:24 <tippenein> which haskell returns 1.0 for..
09:31:58 <chelfi> is that bad ?
09:32:25 <chelfi> oh, sorry, out of context
09:33:39 <tippenein> tehe, the .95 that python returns is bad
09:34:02 <srhb> mrpat: contextLookup and context _still_ need to be indented to the same level. https://en.wikibooks.org/wiki/Haskell/Indentation
09:34:22 <srhb> mrpat: Notice the "right" example
09:34:28 <kadoban> tippenein: I wouldn't think python or haskell has an edge up in numeric stability, when using the same floating point types. Haskell might have more types to use, but then again in python you could use Decimal I think it is, isn't that infinite precision? Haskell has Rational or whatever. Any difference in Double seems like it'd be an accident
09:34:40 <Cale> > 10^9 + (fold (+) 0 (replicate 1000000 0.000001)) - 10^9 :: Float
09:34:41 <lambdabot>      No instance for (Foldable ((->) ([a0] -> Float)))
09:34:41 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
09:34:41 <lambdabot>        arising from a use of â€˜foldâ€™
09:34:42 <geekosaur> what exactly happens depends on how it does the operations. in that one haskell happens to use a more stable computation. for other computations Python's may be more correct
09:34:49 <Cale> > 10^9 + (foldl (+) 0 (replicate 1000000 0.000001)) - 10^9 :: Float
09:34:51 <lambdabot>  *Exception: stack overflow
09:34:54 <Cale> > 10^9 + (foldl' (+) 0 (replicate 1000000 0.000001)) - 10^9 :: Float
09:34:56 <lambdabot>  0.0
09:35:03 <mrpat> srhb: yes, thanks for that!
09:35:14 <Cale> Of course lambdabot wouldn't -O :)
09:35:36 <EvanR> kadoban: Decimal cant be infinite precision, ... just divide by 3
09:35:49 <kadoban> Well, yeah â€¦
09:36:07 <orion> https://github.com/centromere/cacophony/blob/master/tests/vectors/Types.hs#L58 <-- Is this an example of the Existential Antipattern?
09:36:17 <EvanR> in haskell i think the equivalent is Scientific
09:37:42 <nitrix> orion: Looks like it, yes.
09:37:51 <tippenein> so, basically the example is accidently accurate?
09:38:00 <Cale> It is an existential type...
09:38:32 <Cale> Whether it's an example of the "existential antipattern", I suppose depends on whether there is a better design which avoids this existential
09:38:49 <EvanR> constraints in GADts seem to be ok with GADTs
09:38:51 <nitrix> @let data ShowBox = forall s. Show s => MkSB s
09:38:53 <lambdabot>  Defined.
09:39:01 <kadoban> I'd say it's accidentally more accurate in one than the other. In python are you doing the 1000000 additions of 0.000001 to the first 1billion directly?
09:39:10 <EvanR> constraints in data types
09:39:19 <nitrix> > show [MkSB 0, MkSB True, MkSB (), MkSB Nothing]
09:39:21 <lambdabot>      No instance for (Show ShowBox) arising from a use of â€˜showâ€™
09:39:21 <lambdabot>      In the expression: show [MkSB 0, MkSB True, MkSB (), MkSB Nothing]
09:39:29 <nitrix> Whoops
09:39:37 <nitrix> :t [MkSB 0, MkSB True, MkSB (), MkSB Nothing]
09:39:39 <lambdabot> [ShowBox]
09:39:52 <Cale> > foldl' (+) 0 (10^9 : replicate 1000000 0.000001 ++ [-10^9])
09:39:53 <lambdabot>  0.95367431640625
09:40:18 <Cale> ^^ there's your 0.95
09:42:03 <Cale> tippenein: It's the same CPU doing the calculation in either case -- your chip contains circuits for working with numbers of this sort, and regardless of which language you're using, the floating point calculations get done through that
09:43:37 <EvanR> yes excel got a lot of flak for "not being able to add 0.1 and 1 correctly" when its the same story in any language
09:43:43 <EvanR> > 0.1 + 1
09:43:44 <lambdabot>  1.1
09:43:55 <EvanR> > 1 + 0.1
09:43:56 <lambdabot>  1.1
09:44:01 <EvanR> yowza
09:44:08 <Cale> Addition of floating point values is commutative
09:44:08 <kadoban> Hehe. It's just not showing the really low order digits.
09:44:15 <EvanR> its wrong i guarantee you
09:44:20 <tippenein> I'm assuming ghc does some interesting things to avoid those simple mistakes?
09:44:25 <kadoban> > 0.1 + 1 == 1.1
09:44:27 <lambdabot>  True
09:44:34 <kadoban> *shakes tiny fist*
09:44:36 <EvanR> > 1.1 - 1
09:44:37 <lambdabot>  0.10000000000000009
09:44:55 <cobreadmonster> You guys use a lot of LaTeX, don't you?
09:45:05 <cobreadmonster> Okay wait, sorry, thought this was -blah
09:45:20 <tippenein> you probably aren't wrong either way
09:45:48 <josephle> you need to throw in some associativity to see where floating point values go wrong
09:47:36 <tippenein> I appreciate the show-n-tell on numerical (in)stability
09:48:10 <tippenein> *brent rambo thumbs up*
09:48:14 <glguy> tippenein: Python also produces the right answer: >>> 1e9 + sum ([0.000001] * 1000000) - 1e9
09:49:33 <ggVGc> IÃ¤ve got two numbers that can be adjusted by the user, but one of them should always be lower than the other. So, if a should alwyas be lower than b, if the user sets be, then a should also never be able to be read as higher than b. Can I embed this in the type system somehow_
09:49:47 <ggVGc> or should I just go old fasioned implementation hiding
09:52:24 <EvanR> proof carrying ui widgets
09:53:02 <schell> EvanR: what are those?
09:53:08 <EvanR> ggVGc: one way is to only have a and b is always a function of a and the positive amount
09:53:10 <schell> (just joined)
09:53:18 <EvanR> i made it up
09:54:03 <kadoban> You could also just have Blah a b    and just when you use it, flip them as required I guess.
09:54:28 <kadoban> Though that might not make sense in the UI
09:55:07 <EvanR> but even guaranteeing that you have a non negative number is a pain in the ass
09:56:19 <ggVGc> EvanR: thatÃ¤s actually a good idea. Except it would be the other way around. i.e a max bound, and a negative offset from it
09:56:27 <ggVGc> but yeah, that might be a good way
09:56:41 <ggVGc> although, yeah
09:56:44 <ggVGc> that number could turn positive
09:56:47 <ggVGc> and then itÃ¤s borked
09:59:07 <Cale> tippenein: The thing you have to be careful about is that with floating point, addition is not associative: a + (b + c) and (a + b) + c are generally not going to come out the same, especially when it involves numbers that vary widely in scale.
09:59:29 <Cale> Same goes for multiplication
09:59:38 <tippenein> Cale: good to know. So, is Scientific the answer?
09:59:51 <geekosaur> only for some things
09:59:52 <Cale> Also, distributivity, the property that a * (b + c) = (a * b) + (a * c) fails
10:01:46 <dolio> Associativity of * also fails, I think.
10:02:16 <slack1258> for hspec, how can I test executable code?
10:02:23 <slack1258> I can only import the library code
10:03:32 <coppro> dolio: yes, Cale said that
10:04:09 <srhb> slack1258: What do you mean by executable code?
10:04:24 <dolio> Oh, yeah.
10:04:32 <slack1258> declared as executable on project.cabal
10:04:35 <nilof> Do you guys have any reccomendation for linear algebra libraries?
10:04:52 <schell> nilof: i like â€˜linearâ€™
10:05:09 <root_> nilof: i used hmatrix and found it quite good
10:05:15 <root_> oups 
10:05:17 <root_> gonna relog in
10:05:22 <geekosaur> executables don't generally expect to be imported. you'd normally run it as an external program and compare outputs
10:05:52 <maks_> so yeah hmatrix is quite good and has bindings to lapack blas making it essentially as efficient as C
10:06:40 <geekosaur> or have the main call into a test library so you can import the library elsewhere for a test harness not based on executables
10:06:58 <slack1258> That!
10:07:13 <slack1258> genius geekosaur!
10:09:02 <nilof> hmatrix has a good help section on the author's website for whenever cabal install fails
10:09:04 <nilof> I like
10:12:37 <ph88_> how can i let stack use a particular compiler ? i installed some version of gcc on an alternative path, deleted it .. and now stack is still looking for this version even though its not in $PATH
10:16:12 <ph88_> ghc is looking in the wrong path for gcc
10:17:51 * hackagebot abnf 0.3.0.0 - Parse ABNF and generate parsers for the specified document  https://hackage.haskell.org/package/abnf-0.3.0.0 (Xandaros)
10:18:51 <maks_> nilof: yeah hmatrix did the job for me, after a re-write in c i didn't get that much compared to haskell actually (other than reducing a bit the memory usage)
10:19:19 <nilof> Yeah
10:19:45 <ph88_> this file has wrong settings, can i change it manually?   ~/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/settings
10:20:12 <nilof> I'm figuring out the windows install process atm, this is one of the cases where I wish I was on Linux and could do a few apt-get
10:20:47 <maks_> nilof: it's too bad you're on windows indeed on linux it's pretty smooth... i can't help with windows, basically illeterate at windows
10:20:55 <bergmark> ph88_: pretty sure you can
10:21:11 <ph88_> cool
10:23:05 <Blandino> Hi, guys. I am a beginner. If i want to try Haskell on Android, which app would you recommend?
10:23:27 <augur> is there a hoogle-like ghc plugin for use on cabal projects?
10:25:45 <hpc> Blandino: this might be relevant if you plan on writing apps in it: https://wiki.haskell.org/Android
10:26:08 <Blandino> Thank you!
10:26:10 <hpc> Blandino: if you just want to dip your toes, look at http://tryhaskell.org/
10:26:33 <kadoban> Personally if I were going to be doing android apps in Haskell, I'd look into GHCJS and maybe something like sencha touch or one of those to access platform-specific features.
10:26:51 <hpc> i don't know if that wiki link will take you down a rabbit hole of nightmares or not, i don't really like android dev ;)
10:27:15 <Blandino> I am not planning to write android apps. I want to learn Haskell using interpreter on an Android device
10:27:52 * hackagebot bitcoin-payment-channel 0.1.1.1 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.1.1.1 (runeks)
10:30:35 <Cale> Blandino: I don't think GHC itself has been compiled on Android. All the Haskell Android stuff in the past has been done via cross compilation.
10:31:02 <Blandino> Cale: Looks like hugs is the only option.
10:31:15 <Cale> It's honestly not a very good option either
10:31:31 <Cale> But if it exists, then that's something, I suppose.
10:31:34 <hpc> Blandino: if you somehow have a linux box sitting around, setting up ssh and remoting into it from an android app might suit your needs?
10:34:13 <Cale> yeah, that's probably much saner
10:35:03 <merijn> And if you don't have a linux box, you can get one from like a few dollars per month :p
10:35:08 <hpc> i didn't open up with that because it's not often you have a linux box lying around and not know about ssh already
10:36:57 <Cale> GHC's error messages are generally better than Hugs' (though sometimes the simplicity of Hugs' messages is nice, if you don't get immediately why you're getting the error, they're not terribly helpful), and I would expect it to be a frustrating experience trying to get most libraries to build under Hugs at this point.
10:36:59 <Blandino> hpc: Thank you for the suggestion. I will just have to use my notebook:)
10:37:28 <EvanR> Hugs exists?
10:37:30 <Cale> (It's basically unmaintained and has been dead for several years now)
10:37:48 <Cale> But yeah, it still exists and you can still run it.
10:38:09 <Blandino> I quite like tryhaskell.org, but it is too short:(
10:41:12 <quchen_> How would I write "concat :: [[a]] -> [a]" where concatenation is left-associative in a nice way? It's for demonstrational purposes.
10:41:31 <quchen_> It's strange to do this in the wrong order, and I can't come up with anything smart.
10:41:37 <hpc> it'll be interesting when things change enough for hugs to stop working
10:41:48 <hpc> and we might start to see just how many people still use it
10:42:05 <hpc> (though we do get some of that in september when people need help with their out-of-date uni courses)
10:42:29 <hpc> @src concat
10:42:29 <lambdabot> concat = foldr (++) []
10:42:37 <hpc> quchen_: replace foldr with foldl'
10:42:52 * hackagebot ixset 1.0.7 - Efficient relational queries on Haskell sets.  https://hackage.haskell.org/package/ixset-1.0.7 (JeremyShaw)
10:44:04 <quchen_> hpc: Wait, that works? Now I feel stupid.
10:44:13 <quchen_> I felt like that should reverse the list because it has the arguments flipped.
10:44:44 <hpc> > foldl' (++) [] (words "you might be right")
10:44:46 <lambdabot>  "youmightberight"
10:44:50 <hpc> oh, neat
10:44:57 <quchen_> See?
10:45:01 <quchen_> I'm confused.
10:45:11 <Cale> What's confusing?
10:45:21 <hpc> > concat (words "nope, i was right :P")
10:45:23 <lambdabot>  "nope,iwasright:P"
10:45:24 <quchen_> Funny thing is, I'm writing a program precisely to find out about this sort of confusion. Haha
10:45:31 <Cale> (++) is an associative operation, foldl and foldr will produce the same result on finite lists when applied to it
10:45:40 <hpc> > foldl' (++) [] (words "nope, i was right :P")
10:45:42 <lambdabot>  "nope,iwasright:P"
10:45:42 <nitrix> It's just the "associativity" that stays the same.
10:45:51 <Cale> xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
10:45:52 <quchen_> Okay then.
10:46:11 <hpc> oh wait, lambdabot has Expr too
10:46:13 <Cale> Both foldr and foldl maintain the order of the elements of the list
10:46:23 <hpc> > foldr f 0 [x, y, z]
10:46:24 <lambdabot>      No instance for (Show a0)
10:46:25 <lambdabot>        arising from a use of â€˜show_M662042855159146363611804â€™
10:46:25 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
10:46:27 <hpc> > foldr f 0 [x, y, z] :: Expr
10:46:29 <lambdabot>  f x (f y (f z 0))
10:46:33 <hpc> > foldl' f 0 [x, y, z] :: Expr
10:46:35 <lambdabot>  f (f (f 0 x) y) z
10:46:44 <hpc> er
10:46:56 <EvanR> thats a good way to get confused
10:47:00 <hpc> > foldl' (*) 0 [x, y, z] :: Expr
10:47:02 <lambdabot>  0 * x * y * z
10:47:06 <hpc> > foldr (*) 0 [x, y, z] :: Expr
10:47:08 <lambdabot>  x * (y * (z * 0))
10:47:14 <sbrg> heh
10:47:26 <hpc> the "list terminator" switches sides, but because it's mempty it's all fine
10:47:34 <hpc> and (*) is associative too
10:48:46 <EvanR> "foldr goes right, foldl goes left" ;)
10:48:55 * EvanR not confused at all
10:48:57 <EvanR> i swear
10:49:17 <quchen_> Yep, seems to work. 750 steps to right-concat, 2500 to left-concat.
10:50:08 <hpc> yay
10:51:18 <quchen_> 3600 vs 50k and a hot CPU when using [[1]...[100]]. Quadratic enough for me ;-)
11:14:14 <ph88_> anyone know why this is broken?  https://paste.fedoraproject.org/375950/14653232/
11:15:11 <dmj> ph88_: you need to enable {-# LANGAUGE OverloadedStrings #-}
11:15:51 <dmj> or you need to call pack on your strings
11:16:03 <ph88_> its not enabled ?
11:16:17 <baordog> It seems like there isn't much ML/AI stuff going on in Haskell, am I just missing it or something?
11:16:21 <baordog> Seems like a natural choice.
11:17:29 <hpc> <insert joke about ML the language here>
11:17:30 <merijn> baordog: Why does it seem like a natural choice?
11:17:38 <merijn> Most of the ML stuff is deep learning nowadays
11:17:44 <merijn> Which is usually GPU
11:17:53 * hackagebot rapid 0.1.0 - GHCi background threads, hot reloading and reload-surviving values  https://hackage.haskell.org/package/rapid-0.1.0 (esz)
11:18:14 <dmj> ph88_: the type of string is Parser Text I think
11:18:24 <ph88_> which string ?
11:18:37 <dmj> "string :: Text -> Parser Text"
11:18:45 <dmj> line 21
11:19:02 <dmj> but it says foo :: Parser String
11:19:17 <dmj> foo = T.unpack <$> string "foo"
11:19:24 <ph88_> ah i see
11:20:10 <ph88_> maybe i can change the datatype ?  from String to something that is compatible ?
11:20:14 <ph88_> or is that a bad idea ?
11:20:55 <dmj> ph88_: I wouldn't use String in general
11:21:28 <coppro> prefer something like Text or ByteArray to String
11:21:32 <dmj> M-x replace-string String -> Text
11:21:37 <ph88_> how can i import Text ?
11:21:43 <dmj> import Data.Text
11:21:48 <EvanR> s/ByteArray/ByteString
11:21:50 <dmj> add `text` to your cabal file
11:22:15 <EvanR> prefer not ByteString for text if possible
11:22:36 <ph88_> ah yes works now
11:23:12 <coppro> err, right, ByteString. But yeah, ByteString is bad for text. It's good for sequences of bytes
11:23:18 <ertes> EvanR: i think you're gonna like this: https://hackage.haskell.org/package/rapid
11:23:23 <EvanR> i just saw that 
11:24:22 <maerwald> depends what you are doing, not sure I'd use Text for base64 encoded stuff
11:25:24 <maerwald> "Text" is not that well defined. Is a .obj mesh file "text"?
11:25:52 <maerwald> parsing it with bytestring is probably faster if you're dealing with 100mb+ files
11:26:16 <coppro> why are you encoding 100 mb in base64?
11:26:22 <maerwald> coppro: ?
11:28:27 <maerwald> coppro: mesh files are not in base64 format
11:28:34 <Squarism> so, for testing, all your data needs "...deriving (Eq)"
11:28:37 <Squarism> right?
11:29:01 <Squarism> cant compare stuff wo it so to speak
11:29:11 <Squarism> (im using hunit)
11:35:25 <coppro> Squarism: basically everything should have an Eq instance unless there's a good reason for it not to (like it contains a function, which can't be compared)
11:35:39 <EvanR> maerwald: no id probably have a dedicated type for base64 data
11:36:08 <maerwald> I won't, since there's already a nice module for ByteString and base64.
11:36:11 <Squarism> coppro, ok
11:36:13 <EvanR> its like ascii data, its secretly a bytestring, but carrying proof / trust that the bytes have certain properties
11:36:37 <EvanR> yes of course, if a module already exists
11:37:21 <bergmark> Squarism: if you don't want the instances in the library for some reason you can use StandaloneDeriving in your test suite
11:37:51 <Squarism> ok
11:38:03 <ertes> there is a nice dedicated type for compactly storing base64 data:  ByteString
11:38:17 <bergmark> i also have tons of IsString instances for tests :)~
11:38:20 <ertes> it needs only three bytes of memory for every four base64 characters
11:38:26 <coppro> ertes: lol
11:39:37 <Squarism> When running a hunit test i get "ERROR: Prelude.!!: index too large" ... prolly from hunit trying to present a "difference" using Show. Is there a way to investigate why this is happening? Like a bigger stacktrace of sorts?
11:41:14 <bergmark> Squarism: HUnit was patched to give source locations for assertions, but maybe the source itself is not using that
11:42:20 <EvanR> ertes: uh oh, time for an encoding argument
11:42:39 * Rembane hands out popcorn to the channel
11:43:42 * fishythefish munches
11:43:57 <ertes> jokes aside, why would you even *store* base64 data?  it should be very volatileâ€¦  i believe encoding should happen as late as possible (e.g. just before going to Builder), and decoding should happen as early as possible (e.g. while parsing)
11:44:45 <Rembane> ertes: What about if you store some identifier for the protocol used to encode it, with the data and then gzip the whole shebang?
11:45:04 <ertes> what?
11:45:17 <bitemyapp> ertes: rapid looks sweet btw, thank you for releasing that.
11:45:24 <bitemyapp> ertes: have you/will you do a release announcement on Reddit?
11:45:28 <ertes> bitemyapp: you're welcome
11:45:37 <ertes> bitemyapp: feel free to do it, because i don't have a reddit account
11:46:13 <ertes> bitemyapp: but perhaps wait until the docs are built =)
11:46:25 <EvanR> ertes: not talking about storing stuff, just how to deal with it when you have it
11:46:35 <EvanR> you might not want to actually decode it
11:47:10 <ertes> EvanR: sureâ€¦  you can use a newtype around ByteStringâ€¦  but i tend to just decode right away
11:47:17 <ertes> it's cheap and saves memory
11:47:28 <EvanR> and then reencode immediately because the problem didnt call for decoding ;)
11:47:56 <EvanR> especially if the fully decoded version is big and complex
11:47:59 <ertes> depends: is it 16 bytes or 256 MiB? =)
11:48:08 <maerwald> newtypes are only useful if you pass around that data a lot, not just get it and then directly parse/examine it
11:48:29 <ertes> my reasoning is that base64 is really just ByteString in a different encodingâ€¦  i don't keep numbers as strings of digits either
11:48:34 <bitemyapp> ertes: if
11:48:34 <ertes> even if the problem does not call for decoding
11:48:51 <EvanR> different because base64 data is usually a lot bigger than a number
11:49:15 <ertes> EvanR: but also a lot easier to decode on the flyâ€¦  you probably won't even notice a difference in CPU time =)
11:49:58 <ertes> decimal numbers are expensive to decode, so i can see why one would not decode them in certain cases
11:50:19 <EvanR> another thing about decoding by default is that large blobs of data involves memory 
11:50:37 <EvanR> if it can be piped directly somewhere you might save some memory pressure
11:51:07 <ertes> well, yeahâ€¦  in that case you don't keep it at all
11:51:20 <ertes> but if you keep it around, you should decode it in my experience
11:51:30 <EvanR> but you dont want to accidentally pipe the decoded version or some other unrelated ByteString ;)
11:52:03 <ertes> unfortunately you mostly get base64 as ByteStringâ€¦  in most cases you would wrap it just to unwrap it immediately =)
11:52:40 <ph88_> how can i customize my error message with attoparsec ?
11:52:46 <EvanR> a newtype is a pain, i was day dreaming about a different way to acknowledge this in the type system
11:53:17 <ertes> EvanR: that would be ByteString, because we don't have a type for 6-bit numbers
11:53:28 <EvanR> a way thats type safe
11:53:43 <ertes> yeahâ€¦  you need Word6
11:53:46 <EvanR> no
11:53:54 <EvanR> a way that doesnt involve any transcoding
11:54:00 <ertes> it doesn't
11:54:08 <EvanR> [Word6] ? ;)
11:54:35 <ertes> more like Vector Word6 from Data.Vector.Storable =)
11:54:55 * geekosaur casts Summon DEC Mainframe :p
11:55:10 <EvanR> thats a start
11:55:26 <EvanR> it doesnt seem directly related to base64 though
11:55:31 <ertes> bitemyapp: i was waiting for something to follow that "if" =)
11:56:20 <heebo> lo
11:56:33 <heebo> what does it mean to have ! infront of a type?
11:56:42 <heebo> does it make it non-lazy?
11:56:52 <EvanR> its a strict field
11:56:52 <ertes> EvanR: base64 encodes three 8-bit strings as four 6-bit stringsâ€¦  you could of course go as far as to attach a proof to every byte, but you're not gonna like this =)
11:57:09 <geekosaur> it means that it will have seq applied to it before construction of the containing value, yes
11:57:10 <heebo> EvanR: thanks
11:57:22 <heebo> is this new , i havent seen it before
11:57:37 <ertes> heebo: in modern GHC it also means that it can be unboxed
11:57:51 <ertes> heebo: it's standard since at least h98
11:57:52 <EvanR> ertes: the proof would need to talk about sequence of bytes
11:58:12 <EvanR> and the final thingie
11:58:32 <ertes> EvanR: no, you can attach a proof to every byte individuallyâ€¦  all you need for a valid base64 string is that only valid characters are used
11:58:36 <ertes> A-Z, a-z, 0-9, +, /
11:58:47 <EvanR> and the number of = signs at the end?
11:58:53 <ertes> the last equal signs are optional when you have a length
11:59:30 <ertes> they are only there to make the length a multiple of 4
11:59:49 <bitemyapp> ertes: you were operating under the assumption the docs would get built
11:59:54 <bitemyapp> ertes: I amended it to, "if"
12:04:12 <EvanR> with lens is the convention to name record fields like _this or like this_
12:04:23 <EvanR> _this triggers type holes when you screw up
12:04:39 <EvanR> instead of not in scope
12:06:14 <ertes> bitemyapp: i'll wait a few hours, and if they don't get built, i'll upload them manually
12:07:01 <ertes> EvanR: that's fineâ€¦  "not in scope" and "hole" are the same thing (for now)
12:08:01 <EvanR> no, the errors happen in different phases
12:08:42 <EvanR> hole errors happen with type errors and are huger than the one line error message that you mispelled or didnt import
12:08:42 <ertes> since GHC 8 "not in scope" is deferred, if holes are deferred
12:08:57 <ertes> and both give you type info
12:09:17 <EvanR> wait... unknown variable name gives you type info?
12:10:35 <ertes> EvanR: https://ghc.haskell.org/trac/ghc/ticket/10569 â‡ currently it's not optional
12:10:43 <ertes> has been introduced with 8.0.1
12:15:44 <ph88_> so attoparsec, no positioning information, no custom error message ?
12:15:56 <ertes> bitemyapp: is there a way to find out what the current status is?  for example the current queue position
12:16:02 <EvanR> ertes: ... we want to convert misspelled variables into runtime errors? o_O
12:16:22 <ertes> EvanR: it already happened, and i hate itâ€¦  that's why i reopened that issue
12:16:35 <EvanR> and the type error is 2 screens tall instead of showing like 20 missing variables names at once
12:17:12 <ertes> EvanR: you could support me by commenting on the issue, asking for a flag to turn off the type errors =)
12:17:29 <ertes> it's my least favourite feature in GHC 8â€¦  in fact i'm inclined to call it a bug
12:19:38 <bitemyapp> ertes: I do not believe so.
12:22:56 * hackagebot ascii-table 0.3.0.0 - ASCII table  https://hackage.haskell.org/package/ascii-table-0.3.0.0 (mitchellwrosen)
12:23:34 <infandum> What is the best / standard library for working with graphs? Nodes, edges, and all of that good stuff?
12:23:35 <EvanR> "its quite nice to get type info for an out of scope variable"
12:23:51 <infandum> I think I remember someone talking about pg---something but I forget it
12:24:09 <EvanR> 99% of the time i just didnt import the correct thing
12:24:15 <EvanR> or i changed the name of something
12:24:28 <EvanR> but i am not using defer-type-errors so many i am safe
12:25:28 <ertes> EvanR: i'm using -fdefer-typed-holes, because i don't want to defer type errors in general
12:25:48 <ertes> but that already enables that not-in-scope deferral
12:27:25 <infandum> AH
12:27:29 <infandum> it's called FGL
12:35:25 <sm> there's also Data.Graph in unordered-containers
12:38:51 <webrtc2> http://espedito.homepc.it/ new home server:)
12:52:16 <alx741> hellos guys, haskell newcomer here. I'm a bit confused a bout `cabal install` does it -install package on the current directory or from hackage given its name to the system- or is like php's `composer install` that only donwloads the dependencies for the current project?
12:52:49 <Squarism> Running this "testsuite" reports "1 of 1 test suites (1 of 1 test cases) passed"  : https://github.com/gurgl/julius-caesar/blob/master/src/Tests.hs 
12:53:00 <Squarism> ...but it actually is 2 testcases?
12:55:58 <ertes> alx741: "cabal install" installs the package in the current directory along with all its dependencies
12:56:10 <mauke> ertes: that's ambiguous
12:56:13 <ertes> i.e. just "cabal install" with no extra arguments
12:56:26 <geekosaur> alx741, if ypu specify a package name then it downloads from hackage. without a package name, it looks for a cabal file in the current directory and installs using that
12:57:12 <ertes> alx741: installing only the current package's dependencies is also possible:  cabal install --only-dependencies
12:57:30 <alx741> but where does it install it? some local (per user) cabal directory i suppose (?)
12:57:40 <geekosaur> ~/.cabal/bin
12:57:57 <geekosaur> I think I tracked down the windows equivalent once but don't recall it offhand
12:57:58 <basdirks> quchan: I have gone with your earlier advice of avoiding error for user exceptions, and to use Either String a instead. It's cleaner after all, and educational to implement.
12:58:17 <ertes> alx741: if you're in a sandbox (if you don't know, you aren't), it installs in the sandbox directoryâ€¦  otherwise what geekosaur said â€“ but only by default
12:58:26 <ertes> there is an option to install a package system-wide, too
12:58:33 <basdirks> quchen*
12:58:54 <alx741> ooh!! so, when a do `cabal install` in a project that i got from github for example, the dependencies for it get installed on ~/.cabal/lib , *not* in the same directory of the project (am i right?)
12:59:11 <geekosaur> unless you are in a sandbox, yes
12:59:14 <ertes> alx741: yes, unless you used "cabal sandbox init" in the project directory
12:59:22 <geekosaur> you'd have to take specific action to ctreate a sandbox though
13:00:29 <alx741> i'll have to read a bit more of the docuementation about sandboxes, but it's all much clear now, thank you guys. Haskell community is so nice
13:04:28 <Squarism> How do i use the local function g outside f from :  f x = g x where g y = y + y. can i somehow invoke g from (f 2) ?
13:04:52 <Squarism> oh... 
13:04:56 <Squarism> How do i use the local function g outside f from :  f x = g x where g y = y + y. 
13:05:10 <Squarism> (artifacts of old question removed)
13:05:30 <mauke> you don't; it's local
13:06:10 <fishythefish> g isn't defined at the top level, only in that where clause, so it's only in scope for the definition of f
13:06:11 <Squarism> mauke, i learned yesterday that i could?
13:06:35 <mauke> learned where?
13:06:45 <Squarism> here 
13:06:52 <mauke> [citation needed]
13:07:11 <Squarism> my scrollback is to short
13:07:15 <fishythefish> Squarism: can you provide a link to the logs, then?
13:07:33 <Squarism> where can i find logs?
13:07:36 <Squarism> ill google
13:07:58 * hackagebot sandi 0.4.0 - Data encoding library  https://hackage.haskell.org/package/sandi-0.4.0 (MagnusTherning)
13:07:59 <mauke> Squarism: /topic
13:08:02 <fishythefish> Read the channel topic
13:09:47 <Squarism> 16:58:18 yesterday (http://tunes.org/~nef/logs/haskell/16.06.06). Koterpillar said yes you can
13:10:35 <fishythefish> Perhaps what he meant was that in the computation of (f 2), you will invoke g
13:10:40 <Squarism> well.. maybe its seen as "not nice". I thought it would be good for namespacing
13:10:43 <glguy> Now we know who was wrong, but you still can't call g from outside of f directly
13:11:15 <ph88_> nowhere i can find something about attoparsec and error handling other then showing a string
13:11:16 <mauke> Squarism: they were wrong
13:11:20 <Squarism> okey
13:16:12 <tippenein> Can I get any comments on this persistent code? http://lpaste.net/165649
13:17:58 * hackagebot imagemagick 0.0.4.2 - bindings to imagemagick library  https://hackage.haskell.org/package/imagemagick-0.0.4.2 (AlexanderVershilov)
13:18:00 * hackagebot tak 0.1.0.0 - A library encoding the rules of Tak, and a playtak.com client.  https://hackage.haskell.org/package/tak-0.1.0.0 (HenryBucklow)
13:20:36 <tippenein> ugh, I bet it's because of ==. overloading by esqueleto
13:21:22 <tippenein> yup..
13:21:51 <tippenein> selectFirst [PersonName Database.Persist.==. name] []  .. beautiful
13:22:58 * hackagebot tak-ai 0.1.0.0 - AI(s) for playing Tak on playtak.com  https://hackage.haskell.org/package/tak-ai-0.1.0.0 (HenryBucklow)
13:26:15 <Squarism> ertes, In order to be able to test individual "transitions" i moved all the local functions in your "hangmangame" to global scope. You see any big problem with this : https://github.com/gurgl/julius-caesar/blob/master/src/GameLogic.hs
13:26:27 <Squarism> ?
13:30:51 <ph88_> is there a function to count the amount of lines in a string (Text) ?
13:31:56 <samgd> length . lines ?
13:32:00 <mauke> just count the '\n's
13:32:06 <mauke> add 1 if the last character is not \n
13:34:41 <nitrix> One could argue "abc\n" is two lines :P
13:34:52 <mauke> but then one would be wrong
13:35:01 <nitrix> Is "abc" a line?
13:35:13 <mauke> it's an unterminated or incomplete line
13:35:26 <shachaf> '\n' is a line terminator.
13:35:46 <sbrg> nitrix: to `lines` "abc\n" is one line, anyway
13:36:15 <mauke> https://www.youtube.com/watch?v=kpk2tdsPh0A
13:36:23 <tippenein> ph88_: there's Data.Text.splitOn
13:36:39 <nitrix> mauke: Noted.
13:36:41 <hexagoxel> does optparse-applicative really have no pure function to retrieve some full usage/help text given a `ParserInfo a` ?
13:37:26 <jdreaver> What's the best way to include Javascript directly inside a Hamlet HTML template? I'm currently converting to Text and then using preEscapedToHtml, but that feels dirty. I'm using shakespeare directly and not Yesod.
13:38:27 <tippenein> hexagoxel: https://github.com/pcapriotti/optparse-applicative/commit/bab98fe8ee95635a0befca6ad9365be7d31b0541
13:38:32 <jdreaver> I wish I could use Yesod widgets without depending on Yesod haha
13:39:03 <tippenein> that commit message helped me write the showHelpText method
13:40:19 <lpaste> tippenein pasted â€œshowHelpTextâ€ at http://lpaste.net/165652
13:40:47 <tippenein> and by helped, I mean, I literally copy pasta'd it
13:47:52 <Zemyla> :t uncurry (\n -> maybe n (\c -> if c == '\n' then n else n + 1)) . foldl' (\(n, _) c -> let n' = if c == '\n' then n + 1 else n in seq n' (n', Just c)) (0 :: Int, Nothing) -- ph88_
13:47:53 <lambdabot> Foldable t => t Char -> Int
13:48:17 <ph88_> o_O
13:48:22 <hexagoxel> tippenein: i see, thanks.
13:48:27 <ph88_> is that gonna be fast ?
13:49:24 <Zemyla> ph88_: Yeah, it only goes over the string once.
13:49:25 <hexagoxel> it is a pitty one needs copy-pasta for a common usecase. also, the signature is still wonky; why can't i just get a string.
13:49:34 <ph88_> cool
13:49:34 <hexagoxel> or Doc or whatever.
13:52:50 <baordog> Anyone get an invite for hushcon?
13:52:55 <mauke> :t \s -> T.foldl' (\z x -> if x == '\n' then z + 1 else z) 0 s + if not (T.null s) && T.last s /= '\n' then 1 else 0
13:52:56 <lambdabot>     Not in scope: â€˜T.foldl'â€™
13:52:56 <lambdabot>     Perhaps you meant one of these:
13:52:56 <lambdabot>       â€˜F.foldl'â€™ (imported from Data.Foldable),
13:53:05 <EvanR> if youre worried about the complexity or performance of a String = [Char], then it sounds like you have bigger issues
13:53:26 <EvanR> because it means that its so long that its silly
13:53:45 <maks_> what is the code supposed to do anyway, count the number of '\n' ?
13:55:39 <mauke> count '\n's, add 1 if the last character is not \n
13:57:12 <EvanR> ;_; possibly copying the entire thing
13:58:00 * hackagebot hylogen 0.1.3.2 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.3.2 (sleexyz)
13:59:01 <baordog> Is Haskell a good language for writing compilers?
13:59:22 <mauke> activatedmytrapcard.jpg
14:00:11 <Myrl-saki> traps? traps.
14:00:55 <baordog> Myrl-saki: contentious topic? 
14:01:00 <baordog> Wasn't trying to start a fight
14:01:45 <mauke> no, haskell is really good at compilers
14:02:05 <baordog> I was surprised to learn people don't like to use it for ML
14:02:20 * EvanR shudders at idea of compilers written in some other popular language
14:02:38 <dolio> And yet they are.
14:02:46 <Myrl-saki> lol
14:03:01 <EvanR> how o_O
14:03:17 <Myrl-saki> baordog: It was mauke who started saying traps. I just react to traps, esp. the cute ones.
14:03:18 <baordog> EvanR: I guess you could use ML
14:03:38 <baordog> Myrl-saki: Hard to find one's that are packing the right amount of heat ;) impolite to ask too
14:03:48 <mauke> I didn't say "traps", I said "trap card"
14:03:58 <mauke> do you even yu-gi-oh
14:04:16 <Myrl-saki> mauke: Yes, I do.
14:04:19 <EvanR> vanguard 
14:04:20 <Myrl-saki> mauke: :(
14:04:35 <Myrl-saki> mauke: don't ruin my trap paradise man.
14:06:24 <baordog> I guess Haskell isn't fast enough for ML? I asked about that once before and people said it's mostly GPU nowadays
14:07:06 <EvanR> what is the speed of an unladen programming language
14:07:23 <pseudo-sue> neural nets definitely lean heavily on gpus. it's not necessarily true of other ml algos, though. 
14:07:45 <Myrl-saki> EvanR: Wow, that caught me off guard. Lol.
14:08:43 <Myrl-saki> Also, correct me if I'm wrong, but FRP can be used for ML.
14:08:46 <Myrl-saki> Err
14:08:49 <Myrl-saki> neural nets.
14:09:13 <pseudo-sue> i use lisp quite a bit for ml stuff. mostly genetic algos. 
14:09:14 <EvanR> continuous time neural nets?
14:09:57 <pseudo-sue> i'm a complete noob in haskell, though, so i'm curious how it would work out in this lang. 
14:10:05 <Zemyla> EvanR: The code I posted works for Texts and ByteStrings, obviously using their foldl' instead of the standard one.
14:10:17 <bitemyapp> pseudo-sue: there's prior art for GPU accelerated numerics in Haskell
14:10:24 <pseudo-sue> ah, cool. 
14:10:27 <Myrl-saki> urgh. i'm going to slept
14:10:40 <bitemyapp> pseudo-sue: http://hackage.haskell.org/package/accelerate has a CUDA backend, though I don't know if you'd necessarily want to use _that_ library specifically or not.
14:10:52 <bitemyapp> pseudo-sue: there's a haskell numerics channel you'd want to query about that.
14:10:54 <pseudo-sue> bitemyapp: thanks!
14:11:02 <bitemyapp> pseudo-sue: also, hi. I saw you and the little-un in passing at the conf right?
14:11:04 <XBoy> Hey everyone, I'm starting with uni this year, and my initial classes would be taught using Racket. 
14:11:17 <mauke> I take it ML doesn't stand for "mailing list"?
14:11:20 <pseudo-sue> yeah, nice to see you here, bitemyapp! I was there, but w/o kids. 
14:11:26 <XBoy> Does it make sense to learn Haskell before Racket? (I actually want to learn Haskell :P)
14:11:38 <maks_> XBoy: yeah sure why not
14:11:39 <bitemyapp> pseudo-sue: I just checked, #numerical-haskell is the channel with the wizards.
14:11:44 <Myrl-saki> XBoy: It always makes sense to learn Haskell.
14:11:49 <EvanR> XBoy: see if you can just get the whole class to switch over
14:11:52 <Myrl-saki> always.
14:11:53 <bitemyapp> pseudo-sue: nice seeing you here too :)
14:11:55 <maks_> XBoy: only problem is once you learn haskell you may find racket displeasing
14:11:57 <mauke> XBoy: what if you're SPJ?
14:11:58 <Myrl-saki> EvanR: even the prof.
14:11:59 <mauke> er
14:12:05 <mauke> Myrl-saki: what if you're SPJ?
14:12:11 <Myrl-saki> mauke: spj?
14:12:15 <XBoy> spj?
14:12:25 <mauke> Peyton `Simon` Jones
14:12:26 <Myrl-saki> Society of Professional Journalists | Improving and protecting ...
14:12:29 <Myrl-saki> ty google
14:12:33 <EvanR> incredibly crucial question
14:12:51 <baordog> bitemyapp: Wizards? 
14:12:54 <Rembane> The Haskell clone army
14:12:54 <baordog> Like virgins?
14:13:33 <XBoy> And getting the whole class to shift would be fun 
14:14:08 <mauke> baordog: https://en.wiktionary.org/wiki/wizard#Noun
14:14:12 <XBoy> And yeah, I went through a few pages of learn you a haskell. It's definitely better than all the javascript/python etc books I've tried
14:14:32 <EvanR> if you think THATs good
14:14:35 <baordog> XBoy: Wait till you get to the monads ;)
14:15:24 <XBoy> Going for Haskell then :D
14:16:07 <EvanR> monads are a side show
14:16:33 <EvanR> and comonads are night clubs
14:17:13 <mizu_no_oto_work> A burrito is just a strong monad in the symmetric monoidal category of food, whatâ€™s the problem?
14:17:21 <XBoy> That'd be nice considering my uni is supposed to have a dead social scene anyway xD
14:20:07 <maks_> Question: I'm always worried about using things like fromList to construct things like say Vector. Is this worry unfounded, does lazyness somehow take care of my worry (the worry being that say first a list is generated and then inefficiently converted to a Vector)
14:20:19 <mizu_no_oto_work> XBoy: When you get to the point of learning about monads, https://wiki.haskell.org/Typeclassopedia is great, and stay away from anything that tries to tell you 'a monad is like a pink fluffy nuclear-waste-burrito filled spacesuit' - https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
14:21:19 <glamdring> hi, for "foo p az = or . fmap p . tails $ toList az", why can I write a type signature like "foo :: Traversable t => ([a] -> Bool) -> t a -> Bool" but seemingly not "Traversable t => (t a -> Bool) -> t a -> Bool"?
14:21:56 <EvanR> maks_: you kind of have to try really hard to get a list to fully materialize, even if you wanted to. an except is if you put an infinite list in a top level definition
14:22:03 <mauke> :t or
14:22:04 <lambdabot> Foldable t => t Bool -> Bool
14:22:33 <maks_> glamdring: didn't you convert az to a list with toList? therefore the p is [a] -> Bool type
14:22:54 <EvanR> exception*
14:23:01 * hackagebot drmaa 0.1.0.0 - A simple Haskell bindings to DRMAA C library.  https://hackage.haskell.org/package/drmaa-0.1.0.0 (kaizhang)
14:23:23 <EvanR> maks_: it helps to work out some examples of how haskell code (involving a list or not) evaluates
14:24:02 <maks_> EvanR: yeah I might take a look
14:24:04 <EvanR> lists are more like control structures than data structures
14:24:08 <maks_> ok great
14:24:13 <maks_> that's also what i though
14:24:30 <glamdring> maks_ : so if another package exposed a predicate of type p :: Traversable t => t a -> Bool, could I not use it with foo?
14:25:48 <maks_> glamdring: correct
14:26:03 <maks_> glamdring: but I think your code is easily fixable to allow for using anything of the form t a -> Bool
14:27:43 <maks_> glamdring: the culprit is that you convert to a list with toList
14:27:45 <glamdring> maks_: once I call (tails . toList) on a Traversable, I am not sure how to proceed without taking a predicate that's specialized to list
14:28:00 <maks_> yeah you wanna eliminate the (toList)
14:28:02 * hackagebot drmaa 0.1.0.1 - A simple Haskell bindings to DRMAA C library.  https://hackage.haskell.org/package/drmaa-0.1.0.1 (kaizhang)
14:30:06 <maks_> glamdring: why not try using something like Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
14:30:07 <glamdring> maks_ :  Data.List.tails only takes [a] though, right? I still only have limited insight into using Traversable (or Foldable) 
14:30:44 <maks_> glamdring: I think you can just increase the accumulator and skip any action when it's equal to 0, that should amount to tails 
14:31:23 <rfw> is it possible to use lens to filter all items from a list matching some data constructor?
14:31:47 <benzrf> rfw: if so, it's almost definitely a list-specific thing
14:31:57 <maks_> the a is the accumulator, the b is the traversable, the second argument is starting value of the accumulator, the third the initial list, the return value is the final accumulator + the fmap'ed list
14:31:58 <benzrf> i don't know of any typeclasses for removing elements - try searching for list stuff
14:32:02 <glamdring> maks_ : thanks, I'll try to start there!
14:32:22 <maerwald> @hoogle toConstr
14:32:23 <lambdabot> Data.Data toConstr :: Data a => a -> Constr
14:32:24 <rfw> benzrf: yeah the documentation is a bit of a maze for finding these things
14:32:34 <maerwald> not sure why you'd need lens for that
14:32:37 <rfw> so i don't know if i can't find it or if it doesn't exist
14:32:53 <benzrf> try searching for `filter' in the lens docs
14:33:02 * hackagebot SciFlow 0.5.0 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.5.0 (kaizhang)
14:33:02 <EvanR> prism something
14:33:11 <rfw> maerwald: i want to compose it with a bunch of other lenses after
14:33:13 <maks_> glamdring: there's also the mapAccumL starting from the left which is probably what you need (rather than the one from the right)
14:33:40 <benzrf> rfw: wait, hold on
14:33:50 <benzrf> do you mean you want to do a filter, or do you mean you want to select everything under the constructor?
14:34:39 <rfw> benzrf: uhh basically filter (\x -> case x of { Yes _ -> True; _ -> False }) xs
14:34:51 <benzrf> > traverse._Left._2 %~ (+1) [Right "hello", Left ("a", 1), Left ("b", 2)]
14:34:53 <lambdabot>      Couldn't match type â€˜[]â€™ with â€˜(->) a0â€™
14:34:53 <lambdabot>      Expected type: a0 -> Either ([Char], t0) [Char]
14:34:53 <lambdabot>        Actual type: [Either ([Char], t0) [Char]]
14:34:54 <benzrf> rfw: ah, ok
14:35:10 <benzrf> looks like i screwed up my arguments anyway...
14:35:16 <benzrf> > traverse._Left._2 %~ (+1) $ [Right "hello", Left ("a", 1), Left ("b", 2)]
14:35:18 <lambdabot>  [Right "hello",Left ("a",2),Left ("b",3)]
14:35:24 <benzrf> that's unrelated to what you want?
14:36:21 <rfw> > [Left 1, Right 2, Left 3] ^. traverse._Left
14:36:23 <lambdabot>      No instance for (Show a0)
14:36:23 <lambdabot>        arising from a use of â€˜show_M401432032343583810515944â€™
14:36:23 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
14:36:37 <benzrf> > [Left 1, Right 2, Left 3] ^.. traverse._Left
14:36:38 <lambdabot>  [1,3]
14:36:43 <rfw> oh
14:36:46 <rfw> yes that's exactly what i want
14:36:46 <benzrf> ^. is `view', not toListOf
14:36:47 <rfw> thanks
14:36:49 <benzrf> :)
14:37:18 <rfw> ah
14:37:31 <rfw> still getting a handle on all the funky operators
14:38:11 <rfw> thanks!
14:38:14 <benzrf> np
14:38:23 <benzrf> > [Left "hello", Right 2, Left " world"] ^. traverse._Left
14:38:24 <lambdabot>  "hello world"
14:41:02 <benzrf> rfw: that particular solution didn't immediately occur to me, because it's not really "filtering" - it's getting a list of targets of the Traversal, but it just so happens that your original thing is also a list
14:48:02 * hackagebot hackage-security 0.5.2.1 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.2.1 (DuncanCoutts)
14:51:32 <Squarism> im trying to use boolean guards on parameters of a function, but compiler complains : http://lpaste.net/165655
14:52:17 <Squarism> cant i use arbitrary expression in these boolean guards? 
14:53:07 <maerwald> "compiler complains" isn't really specific
14:54:19 <Squarism> well compiler inst more specific than : (Error:(106, 63) ghc: parse error on input ‘|’)
14:55:11 <maerwald> (BattlePhase b batt possibleBlockActions f) -- what is that
14:55:23 <maerwald> you really give only half of the info
14:56:05 <Squarism> well its a argument matcher
14:56:47 <maerwald> is the error at line 3?
14:56:56 <Squarism> one argument that in this case is data type BattlePhase, with its field records exposed
14:57:42 <Squarism> complaint is on line 5
14:58:11 <maerwald> try moving the where clause at the very bottom
14:58:56 <mgsloan> Is there a good term for subexpression, but for types?
14:59:04 <mgsloan> (subtype is right out ;) )
14:59:26 <mgsloan> (lol and I used the term "term" xd)
15:03:03 * hackagebot xlsx 0.2.2 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.2 (KirillZaborsky)
15:08:03 * hackagebot clckwrks 0.23.15 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.15 (JeremyShaw)
15:31:49 <Squarism> How would i modify http://lpaste.net/165658 to assign a constant value to "commandStr" if "m" is Just whatever ? 
15:32:02 <Squarism> ...keeping all lines but 3 intact
15:33:04 * hackagebot twitter-feed 0.2.0.7 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.7 (jpvillaisaza)
15:33:30 <kadoban> Squarism: I don't think I understand the goal?
15:33:49 <idev> fmap Just getLine
15:33:53 <idev> requires deleting line 4
15:34:32 <Squarism> commandStr should not be read from console if "isJust m" is True
15:35:46 <kadoban> Squarism: Oh so you want it to be something like, if it's Nothing, use getLine to get one, otherwise use what we already have?
15:35:48 <EvanR> use pattern matching to branch on the maybe
15:36:01 <EvanR> or use maybe
15:36:04 <EvanR> :t maybe
15:36:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:36:36 <kadoban> Yeah, pattern matching is the clearest conceptually, maybe is the short way.
15:37:18 <Squarism> kadoban, correct.. but really i just wonder how i can add an if statement within that IO centric function
15:37:23 <maerwald> wait, why is the result even IO (Maybe String) then?
15:38:01 <maerwald> you'd use isJust and fromJust, which is kind of ugly though if you can use straight case of expression
15:38:04 * hackagebot SciFlow 0.5.1 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.5.1 (kaizhang)
15:38:06 <Squarism> the function is just a simple example that i dont really care about.. what i care about is how i can add an if statement in it
15:38:46 <EvanR> do
15:38:48 <EvanR>   ...
15:38:51 <EvanR>   if foo bar baz
15:38:56 <EvanR>     then do
15:38:57 <Squarism> let commandStr = if isJust m then "aConstant" else getLine 
15:38:58 <kadoban> Squarism: You could do an if, but it would be *far* from my choice how to do it.
15:39:03 <EvanR>     else do
15:39:05 <maerwald> if isJust m then return $ fromJust m else getLine >>= (return . Just) -- ?
15:39:22 <kadoban> An if is pretty much the same as a pattern match, except much more error-prone.
15:39:27 <kadoban> (in this case)
15:40:19 <Squarism> im transitioning into haskell, im taking babysteps, one at a time. So not trying to achive perfect but just compiling
15:41:23 <Squarism> maerwald, thanx.. but maybe a bit to hard to read for me
15:41:33 <maerwald> make it nicer then
15:42:22 <maerwald> also, I agree you'd be learning case m of ... _before_ if then else 
15:42:42 <maerwald> which is what most tutorials do, because case of is pretty fundamental in haskell, while if then else is not
15:43:32 <maerwald> most of the time when I use if then else is for convenience in a short anonymous function
15:45:41 <EvanR> :t bool
15:45:43 <lambdabot> a -> a -> Bool -> a
15:45:47 <EvanR> wawhaha
15:46:56 <maerwald> terrible name
15:47:35 <EvanR> every type comes with a destructor with no real better name
15:47:42 <EvanR> but the same functionality
15:48:05 <Iceland_jack> > bool "f" "t" True
15:48:07 <lambdabot>  "t"
15:48:07 <maerwald> I don't think that's true for every type
15:48:24 <EvanR> prove it
15:48:48 <maerwald> like coming up with a random type right now?
15:49:32 <EvanR> a type you cant church encode
15:49:38 <maerwald> whatever
15:55:22 <c_wraith> I know how to church encode sums, products, and exponentials. what else is there? 
15:57:22 <EvanR> fractional types
15:57:58 <c_wraith> like quotient types? I suppose I don't know how to church encode them.
15:58:10 <EvanR> not sure if thats the same thing
15:58:13 <EvanR> also negative types
16:01:55 <rfw> hm, a prism is unpacks a data constructor into a tuple? how can i use the lenses on my data type to read the data if i want to filter by the prism first?
16:02:30 <rfw> i guess i could do _Foo . re _Foo . myFieldLens but that seems gross
16:17:12 <c_wraith> rfw, is your goal just to filter by whether a particular prism matches? 
16:17:20 <rfw> c_wraith: yeah
16:17:31 <c_wraith> :t having
16:17:32 <lambdabot>     Not in scope: â€˜havingâ€™
16:17:32 <lambdabot>     Perhaps you meant one of these:
16:17:32 <lambdabot>       â€˜takingâ€™ (imported from Control.Lens),
16:17:45 <c_wraith> blah, what was it named.. 
16:18:04 <c_wraith> Oh, right. 
16:18:56 <c_wraith> :t filtered.has
16:18:57 <lambdabot> (Applicative f, Choice p) => Getting Any a a1 -> Optic' p f a a
16:22:30 <c_wraith> > [Nothing, Just 1, Just 2, Nothing] ^.. traverse . filtered (has _Just) -- rfw
16:22:32 <lambdabot>  [Just 1,Just 2]
16:22:59 <rfw> aha thanks
16:23:12 <c_wraith> be wary of using filtered as a traversal, of course.  Sometimes it's sketchy. :)
16:23:19 <rfw> good gravy lenses have weird types
16:24:49 <Zemyla> What does has do? And why does it have Any in it?
16:25:02 <c_wraith> :t has
16:25:03 <lambdabot> Getting Any s a -> s -> Bool
16:25:08 <Zemyla> I thought Any was uninhabited.
16:25:19 <Zemyla> :t _Just
16:25:20 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
16:25:32 <Zemyla> :t has _Just
16:25:34 <lambdabot> Maybe a -> Bool
16:25:58 <c_wraith> has tests to see if the provided optic has targets in the provided structure 
16:26:50 <c_wraith> I have no idea what that any is doing in there. 
16:27:02 <c_wraith> Oh, yeah I do. 
16:27:38 <shachaf> Zemyla: has takes an optic and a structure and checks whether the optic focuses on any things inside the structure.
16:27:43 <shachaf> That's where the Any comes from.
16:28:28 <obadz> any reason why instance MonadError () Maybe isn't defined?
16:29:12 <rfw> > [(Just 1, Just 2), (Nothing, Just 3), (Just 4, Nothing)] ^.. traverse . filtered (has (_1 . _Just))
16:29:14 <lambdabot>  [(Just 1,Just 2),(Just 4,Nothing)]
16:29:27 <c_wraith> it's Data.Monoid.Any, not the strange ghc thing. 
16:29:31 <rfw> > [(Just 1, Just 2), (Nothing, Just 3), (Just 4, Nothing)] ^.. traverse . filtered (has (_1 . _Just)) . _2
16:29:33 <lambdabot>  [Just 2,Nothing]
16:29:36 <shachaf> Oh, yes.
16:29:42 <shachaf> I forgot there was another Any.
16:29:44 <rfw> > [(Just 1, Just 2), (Nothing, Just 3), (Just 4, Nothing), (Just 5, Just 6)] ^.. traverse . filtered (has (_1 . _Just)) . _2 . _last
16:29:45 <lambdabot>      Could not deduce (Num a0)
16:29:45 <lambdabot>      from the context (Num a, Snoc (Maybe a) (Maybe a) a1 a1)
16:29:45 <lambdabot>        bound by the inferred type for â€˜e_112345612â€™:
16:30:05 <rfw> > [(Just 1, Just 2), (Nothing, Just 3), (Just 4, Nothing), (Just 5, Just 6)] ^.. traverse . filtered (has (_1 . _Just)) . _last . _2
16:30:06 <Zemyla> shachaf: Oh, I was thinking of the wrong Any.
16:30:07 <lambdabot>      Could not deduce (Num a0)
16:30:07 <lambdabot>      from the context (Num a,
16:30:07 <lambdabot>                        Num a3,
16:30:10 <rfw> close enough
16:30:44 <shachaf> You could also define has l = null . toListOf l and it would behave almost the same.
16:30:52 <shachaf> Er, notNull
16:30:54 <maerwald> obadz: it has MonadThrow though
16:40:48 <obadz> well, https://github.com/ekmett/mtl/pull/36
16:40:58 <obadz> guess I'll find out soon enough :)
16:41:31 <Squarism> maerwald, im starting to understand why your idea is the sane approach. The imperative keeps me locked here. I wonder.. what does the : " getLine >>= (return . Just) " part really mean
16:41:49 <Squarism> the "." in particular
16:42:11 <maerwald> uhm, did you start with a haskell tutorials that throws IO at you without explaining fundamentals?
16:42:35 <shachaf> @where hoogle
16:42:35 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle â€“ See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
16:42:46 <shachaf> If you type "." into Hoogle, it'll tell you.
16:43:03 <maerwald> that's too fundamental to be explained by hoogle
16:43:32 <maerwald> Squarism: https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
16:43:35 <Squarism> maerwald, i read this https://wiki.haskell.org/IO_inside thoroughly some time ago.. but i guess it faded in memory... 
16:44:01 <maerwald> that wiki is often awful and not really a learning resource imo
16:44:53 <Squarism> shachaf, ok.. ill check it
16:44:59 <maerwald> IO is usually not the first thing you should learn in haskell
16:47:24 <Squarism> maerwald, my approach is to implement something that motivates me. Theory before practice never worked well for me
16:47:45 <maerwald> I'm afraid that'll make the learning process in haskell more difficult, IMO.
16:48:08 <maerwald> it's not one of those languages you can just start doing stuff and learn as you go
16:48:16 <Squarism> hehe.. no shit. But the alternative for me would be "no learning process"
16:48:38 <maerwald> Squarism: why is that? look at the link I gave you, the first learning resource has excellent exercises
16:48:59 <maerwald> and they are carefully crafted for what you know and don't know
16:49:07 <Squarism> its bookmarked
16:49:31 <Squarism> and ill promise to read parts of it
16:50:15 <fishythefish> Squarism: you might find working through all of it more rewarding than you think
16:50:28 <fishythefish> Those resources are based on exercises and solving problems, not just theory
16:51:24 <Squarism> i know i need to get a bit more formal. But i think ive gotten pretty close to implement the project ive set out to do. 
16:51:42 <maerwald> > (+1) . (*2) $ 4
16:51:44 <lambdabot>  9
16:52:22 <fishythefish> maerwald: just checking?
16:53:09 <maerwald> > (\y -> y + 1) ((\x -> x * 2) 4)
16:53:10 <lambdabot>  9
16:53:16 <Squarism> ive got 15 years of proffessional experiance in programming and i think this project doesnt require much of the advanced paradigm parts of haskell/fp just yet
16:53:17 <maerwald> @src (.)
16:53:17 <lambdabot> (f . g) x = f (g x)
16:53:25 <maerwald> Squarism: did you see that?
16:53:34 <Koen_> > (+ 1) . (* 2) 4
16:53:36 <lambdabot>      No instance for (Typeable c0)
16:53:36 <lambdabot>        arising from a use of â€˜show_M349318281827936732218759â€™
16:53:36 <lambdabot>      In the expression:
16:53:56 <maerwald> (.) is not advanced, it's pretty much the most fundamental function in haskell
16:54:02 <fishythefish> Koen_: you need the $, else the function application will take precedence over composition
16:54:11 <Squarism> i now understand "."
16:54:47 <fishythefish> Squarism: the thing is, it's the fundamental parts of Haskell that (likely) make it different than the programming you're used to
16:54:49 <maerwald> Squarism: you could write it as: getLine >>= (\x -> return (Just x))
16:55:21 <maerwald> although at that point you can just
16:55:21 <maerwald> :t fmap Just getLine
16:55:22 <Koen_> fishythefish: yup that makes sense
16:55:22 <lambdabot> IO (Maybe String)
17:00:15 <protoneony> Hey #haskell, noob question that I can't seem to find the answer to: I have an ADT with a whole bunch of constructors and I want to implement my own version of show for a few of them, but use the deriving version for the rest. Is there a way to do that, or a way to reference the deriving implementation from an instance statement?
17:00:19 <Squarism> maerwald, thanks alot man. I had some problems grasping IO interactions requires results to be passed into a new contexts. And that the if statement sort of created 2 isolated islands =D
17:00:46 <orion> Hey, does anyone know why cabal-install might be failing for FreeBSD 10.2?: http://lpaste.net/8469407810990374912
17:00:47 <maerwald> before dealing with IO you should be familiar with Functors, Applicatives and Monads
17:01:30 <koala_man> protoneony: that's a good question
17:02:05 <hpc> or at least, learn do notation and be aware that there's stuff behind it you still need to learn to use it effectively
17:04:31 <Cale> protoneony: Not really, but what you could do is write a function which is not show itself, derive the Show instance, and have your new function use show in a fallthrough case
17:07:27 <Squarism> maerwald, ill read up on that thourougly before asking stupid questions again =D
17:08:01 <fishythefish> Squarism: the resources maerwald linked to are great for learning about those things ;)
17:08:36 <protoneony> Cale: Ah, that's a good idea. As an alternative, is there a way to get the name of the value constructor as a string? That way I could just do the same thing as the deriving implementation.
17:09:27 <Cale> protoneony: If you derive Data
17:09:35 <maerwald> :t toConstr
17:09:37 <lambdabot> Data a => a -> Constr
17:09:42 <Cale> :t showConstr
17:09:43 <lambdabot> Constr -> String
17:09:56 <hpc> > toConstr "test"
17:09:57 <lambdabot>  (:)
17:10:03 <Cale> > showConstr (toConstr (Just undefined))
17:10:05 <lambdabot>      No instance for (Data a0) arising from a use of â€˜toConstrâ€™
17:10:05 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
17:10:05 <lambdabot>      Note: there are several potential instances:
17:10:12 <Cale> > showConstr (toConstr (Just 5))
17:10:14 <lambdabot>  "Just"
17:10:53 <fishythefish> By the way, is there ever reason not to go with the derived Show instance if one is available?
17:11:01 <maerwald> mind that toConstr deriving sometimes chokes in some cases and defining it manually is annoying
17:11:05 <maerwald> err, Data
17:11:19 <hpc> fishythefish: only very very rarely
17:11:19 <Koterpillar> fishythefish: if you're Map, it won't make sense
17:11:36 <fishythefish> hpc: that's what I figured, but I'm struggling to think of those rare instances :P
17:11:42 <hpc> Text is one of them
17:11:47 <Koterpillar> Map, Set
17:11:52 <hpc> > pack "this is text" :: Text
17:11:53 <lambdabot>      Not in scope: â€˜packâ€™
17:11:53 <lambdabot>      Perhaps you meant one of these:
17:11:53 <lambdabot>        â€˜Data.ByteString.packâ€™ (imported from Data.ByteString),
17:11:57 <Koterpillar> anywhere you don't want to expose the _implementation_
17:12:04 <hpc> hmm
17:12:05 <fishythefish> Ah, good points
17:12:27 <protoneony> Cool, thanks a lot!
17:12:30 <hpc> usually you just don't have a Show instance at all for abstract stuff
17:13:04 <Koterpillar> if you don't expose the constructor, no reason to show it in Show
17:14:33 <rfw> is the concept of Fold in lens many-to-many? as in, Fold a b maps many as to many bs?
17:14:35 <maerwald> Show is for debugging
17:15:03 <Cale> Yeah, you really want the Show instance to produce valid Haskell code for constructing the values
17:15:16 <Koterpillar> maerwald: your debugging or other people debugging your code? I stand by the Map example
17:15:20 <Cale> Or as close to it as you can manage
17:15:32 <protoneony> Oh that's good to know, lyah kinda treats it like a toString method
17:15:50 <fishythefish> Cale, maerwald: right, which is why I was struggling to come up with a situation in which I would want to override the derived behavior
17:16:03 <maerwald> there are pretty printing libraries
17:16:20 <Cale> You almost never want to override the derived behaviour whenever deriving works.
17:16:22 <Zemyla> protoneony: It is for the primitive types - Int(eger), FDouble, and so on.
17:16:34 <maerwald> unfortunately, you're often stuck with Show, e.g. if you have exceptions and want to visualize them to the user
17:17:03 <protoneony> Makes sense. I was just thinking I would make the debugging more readable, but show's output turned out to be pretty good. I just wanted to know if I was missing something
17:17:14 <Squarism> maerwald, thanks to you i could write this : http://lpaste.net/165663 =D
17:17:15 <Zemyla> fishythefish: You want to hide the constructors and instead provide pattern synonyms for construction and destruction.
17:17:35 <maerwald> :t displayException
17:17:36 <lambdabot> Exception e => e -> String
17:17:45 <maerwald> which is in fact "show"
17:17:46 <fishythefish> Zemyla: yeah, Koterpillar's remarks were helpful
17:18:18 <Zemyla> I really wish importing patterns didn't require adding the word "pattern".
17:18:35 <maerwald> Squarism: you don't need the "return" there in line 6
17:18:36 <Zemyla> It feels like it breaks the illusion.
17:19:24 <maerwald> > ([1] >>= return) == [1] -- it's the same for any Monad that satisfies the laws
17:19:25 <lambdabot>  True
17:20:40 <Zemyla> I want to be able to tell the user to pretend my patterns are how the data type was constructed, and the implementation details are unimportant.
17:22:40 <maerwald> Koterpillar: imo, (\x -> (read . show) x == id x)  -- should be True
17:22:41 <Zemyla> And being able to tell the compiler that a set of patterns is comprehensive is a nice start.
17:23:07 * hackagebot acid-state 0.14.1 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.14.1 (JeremyShaw)
17:23:15 <Cale> protoneony: Sometimes I like to use haskell-src-exts to pretty print the output of show by parsing it as a Haskell expression with parseExp (which usually succeeds), and then using prettyPrint on the result.
17:23:23 <Koterpillar> maerwald: agree - but you're not always Read
17:23:47 <Cale> protoneony: If you're debugging stuff with annoyingly massive datastructures, that can be pretty helpful
17:24:22 <Cale> (it'll indent everything nicely)
17:24:39 <glguy> If you want some nicely indented view of Show output you can run it through https://hackage.haskell.org/package/pretty-show
17:25:59 <Cale> Ah, yeah, that library seems like a pretty similar idea
17:26:23 <Cale> (nicely packaged up though :)
17:26:35 <Zemyla> Cale: Will there be a way to, if you have an exhaustive set of pattern synonyms, have GHC derive Read and Show from them as if those were its constructors?
17:26:58 <Cale> I don't believe I've heard anything planned in that regard.
17:27:11 <sm> pretty-show is great for debugging, if your Show instances are vanilla
17:27:32 <sm> there's also something more fancy.. pprint ?
17:27:37 <protoneony> Oh cool I'll keep those in mind! But generally there's no way to create exceptions when using deriving, I guess? (Which I suppose makes some amount of sense, idk when that would really be useful)
17:27:47 <sm> data-pprint
17:28:38 <Zemyla> Am I the only one who would want that thing?
17:30:16 <maerwald> I just want exhaustiveness checks non-broken with pattern synonyms, lol
17:30:52 <Zemyla> Well, yes, that would be a prerequisite. (Also, exhaustiveness check non-broken with GADTs.)
17:36:58 <shirt> how many packages are there on hackage?
17:39:02 <c_wraith> several.  That question is hard to answer in any meaningful way.
17:39:24 <c_wraith> I mean, someone could run a line count on the index, but that doesn't really tell you what you want to know.
17:39:44 <shirt> yeah, i just want to know the total number of packages
17:39:47 <c_wraith> Some packages are deprecated in favor of other packages.  Some packages haven't been updated in forever, and don't build on any GHC newer than 6.soemthing
17:41:11 <c_wraith> Then there are questions about wired-in packages.  They're in the hackage index, but you can't install them.
17:41:54 <maerwald> well, if he just wants to know the total number of packages on hackage, there is a precise answer
17:42:10 <c_wraith> But it's not a useful number. :)
17:42:17 <maerwald> depends on what he wants to do with it
17:42:57 <bshelden> The raw number even of installable-usable-on-current-ghc isn't all that useful for anything more than curiosity anyway.
17:44:08 <shirt> i'm just curious to see what has changed since 2013. even better: is there an updated version of these graphs? https://wiki.haskell.org/Hackage_statistics
17:45:15 <c_wraith> cabal list --simple-output | awk "{ print \$1 }" | uniq | wc -l
17:45:30 <c_wraith> Reports 9760 on my system
17:45:51 <Koterpillar> for "installable", try stackage?
17:48:08 * hackagebot stratux-types 0.0.4 - A library for reading JSON output from stratux  https://hackage.haskell.org/package/stratux-types-0.0.4 (TonyMorris)
17:53:08 * hackagebot stratux-websockets 0.0.4 - A library for using websockets with stratux  https://hackage.haskell.org/package/stratux-websockets-0.0.4 (TonyMorris)
17:53:10 * hackagebot stratux-http 0.0.4 - A library for using HTTP with stratux  https://hackage.haskell.org/package/stratux-http-0.0.4 (TonyMorris)
17:53:50 <Zemyla> Also, do I have to make it so that if I have a bidirectional pattern Pat a b, then (\(a, b) -> case Pat a b of { Pat a' b' -> (a', b') }) is id?
17:57:07 <c_wraith> Isn't that basically required by construction in bidirectional patterns?
17:57:31 <c_wraith> Or did that change in ghc 8?
17:57:47 <glguy> c_wraith: You can specify each direction independently
17:57:54 <c_wraith> Ah, so it did change.
17:58:08 * hackagebot stratux 0.0.4 - A library for stratux  https://hackage.haskell.org/package/stratux-0.0.4 (TonyMorris)
17:58:28 <c_wraith> In that case..  It would be polite to your users to make things work the way they'd naively expect. :)
17:59:14 <glguy> You could specify them independently in 7.10, too
17:59:45 <c_wraith> Huh.  I don't remember that.
17:59:54 <glguy> It looks like this: pattern X x <- (10,x) where X x = (5,x)
18:00:35 <c_wraith> Hmm.  How did I never discover that.
18:00:51 <Zemyla> c_wraith: I was thinking about something for expressions in some language, and case Literal 0 :+ x of { Literal n + x' -> ... } would not match.
18:01:02 <c_wraith> The one thing I really wanted was the ability to combine with view patterns and pass arguments to the view function. :(
18:01:02 <fooboo> is there a simple hello-world-ish example for writing simple EDSLs?
18:01:09 <Zemyla> Well, not necessarily.
18:01:16 <fooboo> for example a stripped down blaze-html
18:01:39 <Zemyla> fooboo: Most of the time, a DSL is going to be some kind of free monad.
18:02:23 <ertes> Squarism: as long as you didn't change the game type, it's fine
18:02:33 <ertes> Squarism: how you implement games is up to you
18:02:43 <c_wraith> Eh.  That doesn't need to be the case.  Free monads just provide an abstraction for writing DSLs with interchangeable backends
18:02:53 <fooboo> zemyla i'm not versed in free monads yet .. is there a good starting point to them and their relation to a DSL?
18:03:06 <Squarism> ertes, "game type" ? 
18:03:09 <ertes> fooboo: what application domain?  because DSLs can look very different
18:03:22 <Zemyla> fooboo: How familiar are you with monads in general?
18:03:36 <ertes> Squarism: the type that encodes the game interface â€“ in my example Hangman (or did i call it HangmanGame?)
18:03:58 <fooboo> ertes something like a transpiler, to say, a very narrow subset of html, R, or C
18:04:17 <fooboo> zemyla: i'm about 24 chapters into haskellbook (past the monad chapter)
18:04:20 <ertes> fooboo: free monads can express most *imperative* DSLs very well, but then an imperative DSL is not necessarily the best solution
18:04:44 <fooboo> with about 6 months of haskell practice
18:04:48 <fooboo> on small projects
18:05:13 <ertes> fooboo: DSLs can look very differently depending on what you want to do with them
18:05:21 <ertes> even IO is a DSL
18:05:29 <Squarism> ertes, ah ok.. the "phase" so to speak data Game  = Hangman ([Char] -> Game) | Won | Loss 
18:05:30 <fooboo> ertes in my case i'm looking to generate static-ish, pure code
18:05:47 <ertes> Squarism: yeah
18:06:04 <fooboo> for example, like an abbreviated transpiler to R, python, or C
18:06:15 <Squarism> ertes, i find your general idea very flexible and sort of readable. So i preserved that
18:06:16 <ertes> fooboo: you could encode the C AST
18:06:18 <fooboo> or shorthand for html
18:06:51 <ertes> fooboo: or the parts you care aboutâ€¦  in general construct a type that represents the essence of what you're trying to express
18:07:02 <fooboo> ertes so represent every token as a sum type or something?
18:07:08 <ertes> i can't provide any specific example without writing it
18:07:24 <Zemyla> fooboo: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
18:07:32 <Squarism> ertes, so was this called CPS? or atelast near CPS ?
18:07:48 <fooboo> zemyla for now i'm interested in representing stateless systems
18:07:52 <ertes> Squarism: i wouldn't call it anything specificâ€¦  it's a DSL
18:07:57 <Squarism> ok
18:08:00 <Zemyla> fooboo: Soo? Monads can be stateless.
18:08:10 <ertes> fooboo: well, one example i can provide: the Hangman game type i showed Squarism =)
18:08:14 <ertes> but it's about interactivity
18:08:40 <ertes> so probably not that interesting in your case
18:09:05 <Zemyla> Though you may actually want to provide an arrow-ish interface instead.
18:10:07 <fooboo> zemyla nice gabriel's blog looks like a gentle starting point
18:10:44 <ertes> fooboo: unfortunately free monads aren't that useful for transpiling
18:11:39 <ertes> they are useful for things that "suspend" in an abstract way:  like a command language, where an interpreter picks the next commandâ€¦  the free monad provides it and "suspends", handing control over to the interpreter
18:11:57 <Zemyla> Yeah, monads hide too much inside. Something resembling arrows would probably be better.
18:12:31 <ertes> arrows are "almost monads with a terribly awkward interface"
18:13:34 <Zemyla> ertes: Yes, but they can handle input, output, and control flow without hiding it.
18:14:40 <ertes> Zemyla: as an example of DSLs i'd start with something much simpler
18:15:05 <Cale> Zemyla: how do Arrows hide any less?
18:15:17 <ertes> arrows have a learning curve, and they end up being not that useful
18:15:50 <Cale> Arrow would be more useful for certain things if it were more closely modelled on the definition of a symmetric monoidal category
18:16:26 <fooboo> this is a bit odd. the tutorial cites Fix as being pre-defined
18:16:30 <Zemyla> Cale: Because control flow can be done with ArrowChoice and doesn't need the full power of ArrowApply.
18:16:41 <fooboo> but it's not in the prelude. where is the Fix constructor defined?
18:17:02 <Cale> You're forced into using 'arr' to wire things up with Arrow a little more than you ought to, and it means that you can't really do the kinds of static analysis you'd like to most of the time.
18:17:26 <Zemyla> Cale: Yeah, that is an issue.
18:17:27 <Cale> Because although Arrow makes the connections between computations more explicit, each 'arr' is still a black box that you can't see through.
18:17:38 <Zemyla> Frigging pirates.
18:20:11 <caconym> fooboo: it shows up in a few packages iirc including this one i just found on google: https://hackage.haskell.org/package/data-fix-0.0.3/docs/Data-Fix.html
18:20:21 <ertesx> docs still not built after 5-6 hoursâ€¦  is it likely that they won't build at all?
18:20:27 <ertesx> (hackage)
18:21:18 <ertesx> fooboo: for the purpose of the tutorial you can just define Fix yourselfâ€¦  it's a one-liner:  newtype Fix f = Fix { unwrap :: f (Fix f) }
18:21:51 <caconym> fooboo: yeah if the subject of the tutorial is Fix you will benefit greatly from defining it yourself, as "simple" as it is
19:30:03 <ggVGc> I find myself often going "Hm, an MVar and a record of functions" for IO-related modules
19:30:14 <ggVGc> but this doesn't seem very haskell to me
19:30:30 <tommd> init :: IO RecordOfFunctions ?
19:31:36 <ggVGc> right now I want to make a thing keeping track of played notes, so I can tell it to kill all currently active ones. So it'll have a state of which notes are active, and an interface of {playNote, stopNote, stopAllPlaying}, which I'll pass into the other modules
19:32:20 <ggVGc> what would be a more haskell way of doing it, rather than having a local MVar and passing around the interface that closes over that mvar?
19:33:41 <tommd> Collect all notes in a structure and pass that around?
19:33:47 <tommd> playNode :: Notes -> IO ()
19:34:01 <tommd> stopNode :: Note -> Notes -> IO ()
19:34:14 <tommd> stopAllPlaying :: Notes -> IO ()
19:36:03 <ggVGc> tommd: yeah, but then all other modules interacting with this one needs to hold states of it
19:36:13 <ggVGc> which doesn't seem better in practice than an mvar
19:58:25 <synergistics> :q
19:58:28 <synergistics> sigh
20:06:41 <YellowOnion> @pl (\a b -> Just (a,b))
20:06:41 <lambdabot> (Just .) . (,)
20:06:53 <YellowOnion> ^Is there a better way to do this?
20:08:37 <Clint> YellowOnion: curry Just
20:11:08 <YellowOnion> Clint, ahh thanks!
20:13:51 <tommd> ggVGc: I disagree.  You seem to be assuming there is only one system of notes.  What if you want multiple structures that I have so far named `Notes`?
20:45:00 <Squarism> what is flatMap called in haskell world?
20:45:08 <Axman6> >>=
20:45:14 <Axman6> :t (>>=)
20:45:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:45:21 <Squarism> ok
20:45:34 <Squarism> so there is no alphanumeric variant ?
20:45:35 <Axman6> > [1,2,3] >>= \x -> [-x,x]
20:45:37 <lambdabot>  [-1,1,-2,2,-3,3]
20:45:39 <Axman6> no
20:45:51 <Axman6> you can always write flatMap = >>= if you want though
20:46:06 <Axman6> (uh, flatMap = (>>=) )
20:46:24 <Axman6> but also we have monadic do syntax, which means you don't have to write >>= basically ever
20:46:47 <Axman6> > do {x <- [1,2,3]; [-x,x]}
20:46:49 <lambdabot>  [-1,1,-2,2,-3,3]
20:48:52 <Welkin> lol flatmap
20:48:57 <Welkin> wtf is with that name?
20:49:06 <jle`> less scary i guess
20:49:06 <Welkin> why do people come in here asking about flatmap?
20:49:14 <Welkin> sounds like an insulting name you call someone
20:49:15 <jle`> Squarism: people call it 'bind'
20:49:34 <jle`> when you talk about it when you're speaking
20:49:35 <Squarism> a, i heard that
20:49:39 <jle`> but i also call it bind when typing, too
20:49:56 <Squarism> in monad land that is
20:50:02 <jle`> bind sometimes can also refer to the flipped variant, :: (a -> m b) -> m a -> m b
20:50:20 <jle`> so it's more of an informal word
20:51:18 <Squarism> thanks
20:51:48 <byorgey> Squarism: for lists specifically, we do have 'concatMap'
20:52:06 <byorgey> :t concatMap
20:52:07 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
20:52:17 <fProgrammer> Quick question: how do I apply Redis Database function "hgetall" to elements of  listP, the types of each are mentioned here:  http://openpaste.org/23C7c3F1   | lpaste is down
20:52:19 <shachaf> Not to mention concat . map f
20:52:37 <byorgey> actualy, I guess concatMap is for arbitrary Foldables now
20:52:52 <Squarism> when using boolean guards for function arguments, can u provide one that should apply to "all other cases" 
20:53:13 <lyndon1> Squarism: "otherwise"
20:53:17 <byorgey> Squarism: sure, just do   | otherwise = ...
20:53:22 <byorgey> otherwise is defined as True
20:54:19 <Squarism> thanks people
20:55:08 <fProgrammer> anybody? 
20:59:43 <Cale> fProgrammer: your paste isn't working
21:00:01 <Cale> oh, refreshed and it started working
21:00:11 <fProgrammer> :Cale I'm able to access it
21:00:24 <Cale> Yeah, OpenPaste just gave me an error the first time
21:01:47 <Cale> The fact that ghci is telling you the package version of bytestring is spooky. It may indicate that your project depends on more than one version of bytestring, which would be bad, because bytestrings coming from different versions of the package can't be used interchangeably.
21:03:05 <Cale> But anyway, let's see,  hgetall :: RedisCtx m f => ByteString -> m (f [(ByteString, ByteString)]),  listP :: Either Reply [ByteString]
21:03:54 <Cale> So, perhaps  map hgetall <$> listP
21:04:11 <Cale> But I would probably case on listP first, and deal with the Left case separately
21:04:26 <Cale> and then have a list of ByteString to work with, instead of the Either
21:05:07 <fProgrammer> Cale: but isn't map :: a -> b  | hgetall is sort of  a -> m b
21:05:16 <Cale> :t map
21:05:17 <lambdabot> (a -> b) -> [a] -> [b]
21:05:26 <Cale> map takes a function of any type whatsoever
21:05:49 <fProgrammer> Cale: okay lemme give it a shot
21:05:53 <Cale> and produces a function which takes a list of what will be arguments to that function, and produces a list of the results of applying it to those arguments
21:07:31 <Cale> You might want to use mapM instead to turn the  RedisCtx m f => [m (f [(ByteString, ByteString)])]  that you get back from this into an m action, if m is a monad... which is suggested by the variable name but I can't really tell without knowing what RedisCtx is
21:08:07 <jasonkuhrt> Hi, I am having a hard time understanding this for some reason: `(sequenceA $ [Constant (Sum 5), Constant (Sum 6)]) == Constant (Sum 11)`
21:08:08 <Cale> You'd get an action of type m [f [(ByteString, ByteString)]] then
21:08:29 <jasonkuhrt> Can someone help me walk through it?
21:08:53 <Cale> and then you could presumably run that to get a list whose type was [f [(ByteString, ByteString]]
21:08:55 <kadoban> :t sequenceA
21:08:56 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:09:04 <Squarism> is there a nice listing of syntactic sugar in haskell?
21:09:21 <Cale> Squarism: The GHC User's Guide documents lots of extensions.
21:09:24 <Welkin> Squarism: just do notation
21:09:31 <kadoban> Squarism: Off the top of my head it's a short list: do blocks
21:09:33 <Welkin> and list comprehensions
21:09:41 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
21:09:57 <Cale> It really depends on what you consider to be syntax sugar
21:10:11 <shirt> Can I write unit () type or data constructor with unqualified syntax? Prelude.()
21:10:11 <Cale> if/then/else might be considered syntax sugar for case expressions on Bool
21:10:14 <jasonkuhrt> kadoban: I'm aware but I don't understand the nature of how Constant results in the monoid append of Sum which I assume is happening
21:10:21 <Squarism> i dont know.. i just wondered if im missing out
21:10:22 <Cale> shirt: Yes, of course.
21:10:24 <Welkin> `a <- ma ...` is the same as `ma >>= \a -> ...`
21:10:39 <kadoban> jasonkuhrt: Yeah, that wasn't meant to be an answer, I'm considering it myself.
21:10:47 <Cale> shirt: You can use anything from the Prelude unqualified normally, unless you went out of your way to import it qualified.
21:10:54 <jasonkuhrt> I'm reviewing the source code of https://hackage.haskell.org/package/transformers-0.2.2.0/docs/transformers/src/Data-Functor-Constant.html#Constant and https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Traversable.html#Traversable to try and understand better but to no avail
21:10:59 <jasonkuhrt> so far
21:11:06 <jasonkuhrt> kadoban: Ah ok
21:11:07 <glguy> jasonkuhrt: The Monoid constraint comes from the Monad instance for Constraint
21:11:09 <glguy> err Constant
21:11:21 <Cale> shirt: If you did for some reason, then note that you can import it again, listing things that you want to import unqualified from the Prelude.
21:11:53 <Cale> shirt: If you're just trying to avoid collisions with a small number of things, consider, e.g.  import Prelude hiding (id)
21:12:00 <shirt> Cale: no matter what i try, Prelude.() doesn't work. but Prelude.length and Prelude.Maybe work
21:12:13 <Cale> shirt: hmm
21:12:26 <Cale> shirt: well, it is a special case, I wonder...
21:12:29 <jle`> () is special syntax, i believe
21:12:32 <jle`> like (,)
21:12:37 <jle`> and (:) and [a]
21:12:39 <ggVGc> I feel I''ve gotten a much better understanding of lists in haskell lately, and no longer consider it bad that they have the special syntax
21:12:40 <jasonkuhrt> glguy: traverse swaps structure... that I understand I think
21:12:47 <glguy> jasonkuhrt: The Monoid constraint comes from the *Applicative* instance for Constant -- there we go
21:12:51 <Welkin> parens are not special
21:12:52 <Welkin> lol
21:12:52 <ggVGc> I now only use them as temporary structures, essentially for generators
21:12:57 <ggVGc> and never store actual aplication dat in lists
21:12:57 <jasonkuhrt> e.g. [Just 1, Just 2] -> Just [1,2]
21:13:00 <jle`> Welkin: the () type and its constructor
21:13:03 <ggVGc> and it makes a lot of sense
21:13:20 <Cale> Oh, I see. You don't have to qualify usage of ()
21:13:34 <Cale> (and indeed, can't)
21:13:56 <fProgrammer> Cale: Yes I tried mapM; It says no instance of Show for ..  here's the detailed paste http://openpaste.org/90312c22
21:13:57 <ggVGc> jle`: is (:) special? Isn't it just the cons operator?
21:14:09 <ggVGc> same with (,)?
21:14:44 <jle`> data (,) a b = (,) a b
21:14:49 <jle`> and it has its own parsing rules
21:14:58 <ggVGc> hm, oalright, that makes sense
21:15:01 <ggVGc> but (:) also?
21:15:07 <jle`> how (,) is parsed and stuff is not like normal operators
21:15:13 <Cale> fProgrammer: I meant in place of map in the thing I told you to write, but this gives us a better idea of what the types are
21:15:25 <geekosaur> ggVGc, with respect to lists (:) is more or less normal but [] needs special handling
21:15:31 <Clint> jasonkuhrt: (sequenceA $ [Constant (Sum 5), Constant (Sum 6)]) == Constant (Sum 5) <*> Constant (Sum 6) == Constant (Sum 5 `mappend` Sum 6) == Constant (Sum 11)
21:15:32 <jle`> (:) is probably parsed like a normal operator, i suppose, but you can't define it in normal haskell.  i probably was meaning to say [a]
21:15:40 <ggVGc> geekosaur: what does more or less mean?
21:15:46 <fProgrammer> Cale:  Understood
21:15:47 <ggVGc> ah right
21:16:02 <Cale> fProgrammer: What's the type of p?
21:16:21 <ggVGc> why couldn't you define (:) in normal haskell?
21:16:29 <ggVGc> isn't it literally cons?
21:16:38 <geekosaur> ggVGc, in this case that it's wired-in / known to the compiler for expansion of other list syntax (the [a,b,c] sugar and I think list comprehensions), but not otherwise special
21:16:39 <Cale> ggVGc: You could, you just couldn't give it that name.
21:16:53 <fProgrammer> Cale: I'm sorry,  I renamed listP as p; should have mentioned it
21:17:14 <jle`> ggVGc: (:) isn't allowed for custom defined data constructors
21:17:15 <geekosaur> it doesn't require special syntax rules or etc.
21:17:36 <jle`> @let data List2 a = a : List2 a
21:17:36 <lambdabot>  Parse failed: Illegal data/newtype declaration
21:17:37 <ggVGc> yeah, alright
21:18:12 <ggVGc> you know what I love in haskell? You can almost always go "foo == bar" and it actually means the comparison you want to do
21:18:16 <ggVGc> and works
21:18:21 <ggVGc> because, gasp, things are values
21:18:25 <ggVGc> what an enlightenment
21:18:31 <Cale> ggVGc: hahaha
21:18:53 <ggVGc> seriously, I know almost no other language where "==" usually means what I want to do
21:19:01 <Cale> Doing the same operation in C can be a massive pain
21:19:05 <ggVGc> right
21:19:10 <ggVGc> or even in something like java or C#
21:19:16 <ggVGc> == is almost never what you intend
21:19:23 <ggVGc> unless it's very basic values
21:20:25 <ggVGc> I have this functon. Am I replicating somethign that already exists? https://gist.github.com/c4ab4ac7740d44cc5aa0e8088c30b9c2
21:20:44 <Cale> and then you have stuff like Javascript, where it means something that's not even an equivalence relation.
21:20:45 <ggVGc> I mean in the standard libarry
21:20:53 <geekosaur> jle`, are you sure? hint does its own parsing pass with h-s-e, ghc may be more permissive (especially with -XRebindableSyntax so it knows that you're changing stuff it normally considers wired in)
21:20:54 <ggVGc> Cale: I don't even want to talk about that..
21:21:17 <glguy> > imap (,) "test"
21:21:19 <lambdabot>  [(0,'t'),(1,'e'),(2,'s'),(3,'t')]
21:21:33 <ggVGc> heuheu, I knew I was being dumb
21:21:38 <ggVGc> it's one of the first functions I wrote in this project
21:21:39 <ggVGc> thanks
21:21:48 <Welkin> > iimap (,,) "hello"
21:21:49 <lambdabot>      Not in scope: â€˜iimapâ€™
21:21:49 <lambdabot>      Perhaps you meant one of these:
21:21:49 <lambdabot>        â€˜dimapâ€™ (imported from Control.Lens),
21:21:56 <Welkin> dimap? lol
21:21:57 <Cale> geekosaur: wait, hint uses h-s-e? Why?
21:21:59 <Welkin> :t dimap
21:22:00 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
21:22:15 <ggVGc> dimap (,,) "hello"
21:22:23 <ggVGc> >dimap (,,) "hello"
21:22:26 <ggVGc> damn
21:22:29 <Welkin> ggVGc: you drunk
21:22:32 <ggVGc> > dimap (,,) "hello"
21:22:33 <glguy> Cale: I don't think it does.
21:22:34 <lambdabot>      Couldn't match expected type â€˜c -> dâ€™ with actual type â€˜[Char]â€™
21:22:34 <lambdabot>      In the second argument of â€˜dimapâ€™, namely â€˜"hello"â€™
21:22:34 <lambdabot>      In the expression: dimap (,,) "hello"
21:22:43 <geekosaur> Cale, it did last I checked. I don't know why offhand but if you look closely at the parse errors it reports they are usually those of h-s-e instead of those of ghc
21:22:44 <ggVGc> Welkin: haha, no, just sloppy
21:23:03 <geekosaur> admittedly, h-s-e's parse errors are often more useful than ghc's. which may well be the point
21:23:20 <Cale> geekosaur: Are you sure you're not thinking of mueval, the thing that lambdabot uses?
21:23:25 <glguy> h-s-e certainly doesn't seem to be a transitive build-dep of hint
21:23:34 <Cale> (which then uses hint, after checking a bunch of stuff)
21:23:36 <geekosaur> oh, sigh
21:23:46 <geekosaur> confused which level was doing that, I guess
21:23:56 <mgsloan> HSE parse errors are sometimes better?!
21:24:06 <mgsloan> That seems counterintuitive, I thought it was forked from ghc
21:24:16 <mgsloan> I guess maybe enhanced after the fork?  Seems unlikely
21:24:35 <geekosaur> no, it had to reimplement the parser because ghc's is not sufficiently self contained iirc
21:24:36 <glguy> I don't really see where h-s-e comes in with mueval, either (just looking at http://hackage.haskell.org/package/mueval )
21:25:00 <Cale> oh, perhaps it no longer uses it
21:25:14 <geekosaur> you can't pull out the lexer and parser without dragging in big chunks of ghc internals that h-s-e wanted to avoid forcing on you
21:25:27 <Cale> At one point, I'm fairly sure mueval, or at least lambdabot *did* do an extra parse to make sure that your thing was an honest expression.
21:25:57 <geekosaur> this is also why it lags ghc updates often; they can't just lift the new productions out of ghc
21:26:13 <fProgrammer> Cale: any idea what I'm doing wrong? Any hint will also be fine, here's an updated paste with types http://openpaste.org/94F90c64
21:26:55 <Cale> fProgrammer: Well, it's complaining that it doesn't know how to show an IO action, which is reasonable
21:27:13 <Cale> fProgrammer: If you ask for the type of the expression which is giving you the error, what does it say?
21:27:43 <Cale> (also, you've really got to get those package qualifiers sorted out... that's awful to read :)
21:29:32 <fProgrammer> Cale: I am new to this, I'm using stack, these packages  are building locally, and I'm checking the functions through "stack ghci", how do I remove package qualifiers? You mean like this : import x.y.z as xyz?
21:29:58 <Cale> hmm
21:31:04 <Cale> I haven't used stack much at all, so I'm not sure... I wonder if stack has an equivalent to ghc-pkg
21:31:51 <Welkin> Cale: it just uses cabal
21:32:00 <Welkin> so, hc-pkg
21:32:06 <Welkin> oh, that is for cabal sandboxes
21:32:23 <Cale> ah
21:32:24 <glguy_> Generally if you want to do something like that with stack you prefix with: stack exec
21:32:25 <Cale> try this
21:32:27 <geekosaur> stack exec -- ghc-pkg ... ?
21:32:35 <Cale> stack exec -- ghc-pkg check
21:32:57 <Cale> and see if it reports anything
21:32:57 <mgsloan> Yeah, I was actually just thinking last night that I should add "stack pkg check" / "stack pkg describe" / etc
21:33:20 <mgsloan> Why would you use ghc-pkg check?
21:33:36 <mgsloan> I do not see that question that would prompt that
21:33:45 <Cale> mgsloan: His ghci is reporting package versions in types for bytestring, so there's something weird going on.
21:33:46 <Welkin> because you can
21:33:52 <mgsloan> Cale: Gotcha
21:33:53 <fProgrammer> Cale: No errors as such, just some warnings of stack exec -- ghc-pkg check
21:34:21 <Cale> Try  stack exec -- ghc-pkg list bytestring
21:34:40 <Cale> (and pastebin the output somewhere)
21:35:04 <Cale> Specifically, does it report more than one bytestring package?
21:35:06 <mgsloan> fProgrammer: Are you using something that links against ghc?
21:35:22 <mgsloan> Then again, those bytestring versions have the same version
21:35:54 <mgsloan> Are you overriding the version of any of ghc's boot packages in extra-deps?
21:36:35 <mgsloan> Oh but ghc probably doesn't use bytestring, does it
21:36:37 <fProgrammer> mgsloan: So slack is a wrapper around cabal which sandboxes by FPComplete; it also downloads different versions of ghc/ghci etc for each project if  required
21:36:41 <mgsloan> It's got its own fast string biz
21:36:44 <Welkin> stack*
21:36:59 <mgsloan> fProgrammer: I know, I wrote a fair bit of it
21:37:47 <fProgrammer> mgsloan: That's awesome!
21:40:18 <mgsloan> Cale: I don't think that's the issue here.  There is no mismatch of types due to package versions
21:40:27 <mgsloan> It just is using package qualified names for some reason
21:40:37 <fProgrammer> Cale: I tried using liftIO $ print mapM (\x -> runRedis conn $ hgetall x) <$> p ; it still complains; maybe I am doing some mistake, lemme go through it again. Thanks for your help!
21:41:04 <Cale> mgsloan: It's just anecdotal, but I've only ever seen it start doing that when there was more than one package exposed that exported a module with that name.
21:41:11 <mgsloan> True!
21:41:34 <mgsloan> I'll bet there are two versions of bytestring being used, one by ghc and one by everything else
21:41:48 <mgsloan> This can happen when you override a boot package but still use ghc
21:42:29 <Cale> fProgrammer: Well, let me look up the type of runRedis and some other stuff
21:42:57 <Cale> fProgrammer: ah, I see
21:43:24 <Cale> fProgrammer: The main instance of RedisCtx is one for  RedisCtx Redis (Either Reply)
21:43:44 <Cale> fProgrammer: So whenever you see a type involving  (RedisCtx m f) => ...
21:44:00 <Cale> you can replace occurrences of m with Redis, and occurrences of f with Either Reply
21:44:43 <Cale> So in particular,  hgetall :: ByteString -> Redis (Either Reply [(ByteString, ByteString)])
21:46:13 <Cale> fProgrammer: You probably want to be doing most of your work *inside* the action which you're applying runRedis to, rather than using runRedis many times
21:46:14 <fProgrammer> Cale: so I should >>= to print values i.e. treat Redis like a monadic instance?
21:46:23 <Cale> Redis is a monad
21:46:33 <Cale> So you can use do-notation here
21:46:40 <Cale> runRedis conn $ do ...
21:46:42 <fProgrammer> Cale: That is correct, I do "runRedis conn $ (do ...)"  
21:46:46 <Cale> yeah
21:47:16 <fProgrammer> Cale: I used single instance of this in ghci to reproduce this error
21:47:24 <Cale> ah
21:47:34 <Cale> Perhaps I could see the actual program you're trying to write?
21:47:58 <Cale> I think we probably want to first of all pattern match on p in order to handle the Left case somehow
21:48:15 <Cale> That probably indicates some sort of error, I don't really know how Redis works
21:48:26 <ggVGc> if I have a [(Int, a)], whats the best way of getting a list of a from it, sorted by the value of the integer?
21:48:39 <ggVGc> sortBy followed by map snd?
21:49:34 <Cale> Yeah, probably   map snd . sortBy (comparing fst)
21:50:22 <ggVGc> thanks
21:50:39 <Cale> fProgrammer: From the documentation: "Outside of a transaction, if the Redis server returns an Error, command functions will return Left the Reply. The library user can inspect the error message to gain information on what kind of error occured."
21:51:45 <silverjam> Anyone familiar with gabrielg's "turtle" library?
21:52:04 <Cale> fProgrammer: So that's indeed what it means (it's typical in Haskell for Left e to mean that there was an error e, and for Right x to mean that something was successful, with result x)
21:53:07 <silverjam> I think I want to compose "grep" and "sed" but I'm not sure how to do that... http://lpaste.net/165665
21:53:10 <fProgrammer> Cale: Understood, but it is wrapped inside Redis monad If I am not wrong
21:53:27 <Cale> fProgrammer: don't think of it as "wrapped"
21:53:40 <silverjam> And then... how to get turtle to close the file so I can write the new file
21:53:58 <Cale> A value of type Redis t is a program which describes some interaction with your connection to redis, and if you were to run it, would produce a result of type t
21:54:31 <Cale> i.e. it doesn't "wrap" a value of type t any more than /bin/ls "wraps" a list of files in your home directory :)
21:55:41 <shachaf> Good analogy.
21:56:18 <Cale> ;)
21:57:17 <Cale> @quote shachaf /bin/ls
21:57:17 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:57:50 <Cale> fProgrammer: So, do the mapM inside the do-block you're giving to runRedis
22:00:17 <fProgrammer> Cale: Got it, I will try, this is my source code: http://openpaste.org/972CF7e9
22:01:18 <Cale> I am pretty sure that is not quite the value of listP
22:01:58 <Cale> It could be  Right ["UDCM:123456789"]
22:02:06 <fProgrammer> Cale: I meant when I print it, the type is as i mentioned, [ByteString]
22:02:23 <Cale> When you print it, does it not print "Right"?
22:02:25 <fProgrammer> Cale: Yes, Right ["UDCM:.."]
22:02:30 <Cale> cool
22:03:08 <Cale> So, if you're writing a proper program, you'd probably write  case listP of Left e -> ... handle error somehow ...
22:03:36 <Cale> and have a branch for  Right xs -> ... use xs :: [ByteString] here ...
22:03:57 <fProgrammer> Cale: will do it, I was just trying to get acquainted with Redis commands
22:04:00 <Cale> Given that we're just exploring here, maybe we just want to pattern match directly on the right of the <-
22:04:16 <Cale> er, pattern match Right, on the left of the <-  :D
22:04:40 <Cale> So,  Right ks <- keys "UDCM:*"
22:04:54 <Cale> and then you have  ks :: [ByteString]
22:05:01 <Cale> and you can write something like
22:05:17 <Cale> forM ks $ \k -> hgetall k
22:14:23 <fProgrammer> Cale: Will check it out later, thanks a ton!
22:43:30 <orion> GHC 8 identifies redundant constraints. I've removed all redundant constraints. Still though, there are constraints which I can remove and have the library compile successfully. Why?
22:44:13 <Ralith> at a guess, because "redundant" and "unnecessary" are not equivalent
22:44:33 <kadoban> orion: Do you have an example? At a guess, maybe it can't identify all redundant constraints, or maybe it knows that some are required in old GHC versions and it'd be annoying to warn on those.
22:44:51 <fProgrammer> Cale: Hey it works, I need not do :: ByteString for keys; thanks!
22:45:28 <orion> kadoban: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise.hs#L122 -- Cipher c
22:47:57 <Squarism> how do i write the case pattern for a 2 element list? 
22:48:07 <Squarism> that doesnt match 3 elements
22:48:31 <siwica> Being fairly new to Haskell I am having problems to find official documentations for Haskell packages. Where can I obtain an official documentation for let's say Parsec (https://hackage.haskell.org/package/parsec)?
22:48:37 <kadoban> x:y:[] or [x,y]
22:49:03 <kadoban> orion: Hmm, I don't know those typeclasses or code at all :-/
22:49:03 <siwica> I resorted to look at the Parsec source but that can't be the proper way
22:49:33 <parsnipM_> i think there's a nice manual for Parsec
22:49:39 <kadoban> siwica: https://hackage.haskell.org/package/parsec-3.1.10 There's supposed to be links as you see down below to the docs for each specific module, but hackage kind of sucks about building it sometimes.
22:49:52 <parsnipM_> and a few blog tutorials
22:50:14 <kadoban> siwica: https://www.stackage.org I look here usually, it's better about having the docs, though it's not exactly the same.
22:51:52 <siwica> Ok, thanks!
22:53:18 * hackagebot tak-ai 0.1.0.1 - AI(s) for playing Tak on playtak.com  https://hackage.haskell.org/package/tak-ai-0.1.0.1 (HenryBucklow)
23:12:21 <crodjer> I have been learning Haskell for a while and would like to be involved in real world Haskell projects. I have read and tried a lot of the popular tutorials, submitted (tiny) patches to various Haskell based projects here and there, but haven't been able do anything beyond that. The primary deterrent for me has been the omnipresent subtle requirement of a strong mathematics background. I don't see such 
23:12:27 <crodjer> constraints in say, Clojure/Python/Ruby. Are there any good sources (tutorials/books/lectures) laying out the minimum amount of mathematical knowledge required to start working with Haskell? I am an internet-taught programmer with no formal computer science background.
23:16:34 <oherrala> crodjer: how did you find out the requirement for math background?
23:19:30 <ggVGc> yeah I don't think haskell requires much math background actually
23:19:37 <ggVGc> other than maybe mathematical thiknking
23:20:05 <zomg> I was terrible in math, I'm a pretty decent programmer, and ok in Haskell too
23:20:26 <Koterpillar> which other languages also require, only they don't tell you so until your program crashes or silently produces wrong results
23:20:29 <zomg> A math background would probably only help if you know category theory or something like that which helps understand all the crazy terminology that gets thrown around
23:21:46 <kadoban> crodjer: Have you looked at http://haskellbook.com/ ? It aims to teach from the ground up. Though I disagree that much math is required, personally.
23:22:56 <oherrala> ggVGc: Terminology one be one obstacle
23:23:24 <crodjer> kadoban: I have, but I was waiting for it to be completed.
23:23:51 <kadoban> crodjer: It's already quite usable, and quite long. And you get updates as it progresses.
23:24:05 <crodjer> kadoban: Oh, alright. I'll check it out then.
23:25:03 <crodjer> Terminology is a major issue for me. Generally, when trying to just passively follow a conversation it's always clear to me that I am missing some context (which may make things obvious).
23:25:09 <kadoban> crodjer: You can see the content it covers in there somewhere, it's *quite* extensive really. It definitely hits the pain points most people run into, IME.
23:25:10 <cocreature> I think it also is complete as far as the content go. only issues are being correct now
23:25:29 <cocreature> *corrected
23:25:40 <kadoban> I wouldn't stress the terminology much if that's what bothering you. A lot of the terms in haskell come from category theory, but AFAIU, they are just insipired by it, there's no need to actually know category theory.
23:25:50 <kadoban> I don't think most of them even match up that well, so knowing CT might not help a ton.
23:27:18 <cocreature> knowing ct mostly helps to have some motivation for why some thing are the way they are, e.g. the monad laws or something like that. if you just accept that they are the way they are and build up an intuition on your own while programming you donâ€™t need ct
23:27:26 <cocreature> that said ct is fun :)
23:27:29 <ggVGc> I have very weak math background, and I think I'm doing okay in haskell
23:28:21 <kadoban> I am terrible at math, I do fine in haskell.
23:28:27 <ggVGc> crodjer: missing context etc. isn't lack of math background. It's literally lack of haskell knowledge. The real issue is that haskell is such a huge language
23:28:33 <ggVGc> it has way more high level concepts than most other languages
23:28:54 <ggVGc> but to write a useful program in haskell, I reckon you need about 15% of it
23:28:55 <ggVGc> maybe 20
23:29:09 <cocreature> in my experience most haskellers are quite willing to explain the terminology they use. you just need to ask :)
23:29:26 <ggVGc> more than half of haskell seems to be essentially tools for language research
23:29:33 <ggVGc> which are not super useful in everyday work
23:29:47 <ggVGc> and definitely not necessary
23:30:16 <ggVGc> haskell gives you the power to abstract to extreme levels, but in no way demands it
23:31:42 <crodjer> Yeah, that's clearly so. I can see how that can be very powerful.
23:32:32 <Cale> crodjer: There's a lot of terms which we steal from various areas of mathematics, but that doesn't mean that you need to know those areas of mathematics to be able to understand the corresponding Haskell libraries
23:33:24 <crodjer> Would you recommend any projects, which preferably don't use too many extensions and could be considered to be logically self-contained?
23:33:42 <ggVGc> crodjer: any form of text processing
23:33:52 <ggVGc> is pretty well suited for haskell and quite easily self contained
23:38:01 <crodjer> ggVGc: You mean like Parsec and projects that depend on it?
23:41:33 <cocreature> crodjer: existing projects to look at or project ideas you could implement yourself?
23:41:57 <crodjer> cocreature: Mostly read code and possibly contribute.
23:42:06 <crodjer> As a learning exercise.
23:42:37 <cocreature> crodjer: xmonad is fairly small and self contained. also the code is pretty clean
23:43:05 <Koterpillar> yeah, write a WaylandMonad finally :)
23:43:35 <crodjer> cocreature: I did use and read it partially. But I now am on OSX, so can't experiment.
23:44:31 <crodjer> Koterpillar: It seems Haskell needs good wayland bindings first?
23:45:32 <Koterpillar> yeah, I tried to look into it and got nowhere
23:53:53 <crodjer> I'll actually try to get familiar with Wayland. Koterpillar, project link?
23:54:22 <Koterpillar> crodjer: serious? https://wayland.freedesktop.org/
23:54:47 <crodjer> Koterpillar: Oh, I meant if you had started a Haskell project.
23:55:06 <Koterpillar> was just kidding
23:55:39 <Koterpillar> well, I have a few under my nickname at GH, but they're not examples of brilliance
