00:04:14 <Maxdamantus> 18:49:26 < Cale> As far as I can tell, dependency injection seems to just be a very convoluted way of explaining the concept of a function.
00:04:17 <Maxdamantus> http://blog.cleancoder.com/uncle-bob/images/fpvsoo.jpg
00:09:09 <liste> Maxdamantus: I find that article a bit wierd: "
00:09:10 <liste> The overriding difference between a functional language and a non-functional language is that functional languages don't have assignment statements.[1]"
00:09:21 <liste> (link to the article: http://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html)
00:11:11 <Maxdamantus> That bit sounds accurate.
00:11:16 <Maxdamantus> I'm not sure about the rest of the article.
00:12:36 <Cale> I've come to think of the difference between classical "FP" and "OO" as being the difference between an emphasis on inductive vs. coinductive data.
00:12:38 <Maxdamantus> If you take a language like .. JavaScript .. and remove its assignment operators, you pretty much have a purely functional language.
00:12:56 <Maxdamantus> and maybe remove its operators that have to do with determining identity of objects.
00:13:56 <Cale> In classical FP, you work with inductively defined data via pattern matching -- you define new types by saying first how their values are built up, and then certain principles for taking them apart again are derived from that.
00:13:57 <liste> Maxdamantus: what about I/O then? can it still be purely functional with console.log()s running rampantly everywhere?
00:14:17 <Maxdamantus> liste: console.log will conceptually be implemented using assignment operators.
00:14:39 <Maxdamantus> liste: though to be fair, console.log isn't part of the language.
00:14:44 <Cale> In classical OO, you work with coinductively defined data structures (records of functions mostly), defined first by how they are to be taken apart (i.e. how they respond to messages or methods)
00:15:52 <Maxdamantus> You'd obviously need to change some of the functions provided by the ECMA specification, like Array.prototype.push.
00:16:03 <Maxdamantus> that's not really a language issue though.
00:16:53 <Maxdamantus> (and the specification usually describes those functions in terms of assignment/setProperty/whatever
00:16:56 <Maxdamantus> )
00:17:38 <shachaf> Cale: Do you mean this as an expression-problem-style thing?
00:18:10 <Cale> Yeah, traditional FP and OO focus on different aspects of the expression problem.
00:23:39 * hackagebot docvim 0.3.0.0 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.0.0 (wincent)
00:25:40 <sgronblo> omg, I think I managed to use a monad transformer for the first time in my life!
00:26:02 <liste> sgronblo: show us (:
00:26:56 <sgronblo> just a really crappy forced example of ReaderT String IO String
00:27:20 <sgronblo> nothing interesting
00:27:32 <Cale> Try  WriterT (Product Rational) []
00:29:14 <Cale> That one is fun -- you can use it to compute probabilities
00:34:02 <sgronblo> Cale: So that's kind of a computation that has multiple monoidal values?
00:34:25 <Cale> @unmtl WriterT (Product Rational) [] a
00:34:25 <lambdabot> [] (a, Product Rational)
00:34:38 <Cale> It's basically a list of pairs of elements and rational numbers
00:34:53 <Cale> With the interpretation that you're going to multiply the rationals as you go
00:37:28 <Cale> http://paste.lisp.org/display/318138
00:38:13 <Cale> sgronblo: ^^ A quick hack I wrote using that monad, when I wanted to compute some probabilities regarding a card-flipping game
00:49:29 <Shou> Does the property of "argument direction" in an operator have a name? e.g. given an arbitrary operator *, a * b = b AND b * a = a AND a * b * c = c, shows a "right-leaning".
00:50:47 <shachaf> If a * b = b for any a and b, there's only one possible operator * could be.
00:53:46 <Shou> True, (*) = flip const. I'm trying to describe an operation which only acts like that under certain circumstances and curious if there's a name for that property.
00:54:33 <shachaf> Maybe some of the varieties in https://en.wikipedia.org/wiki/Band_(mathematics) will be relevant to your question.
00:55:34 <shachaf> But in general it seems pretty vague.
00:58:41 * hackagebot docvim 0.3.1.0 - Documentation generator for Vim plug-ins  https://hackage.haskell.org/package/docvim-0.3.1.0 (wincent)
01:08:17 <Shou> shachaf: thanks, zero bands seem a step in the right direction
01:25:43 <saurabhnanda> another philosophical question. If my app-config record type has a bunch of config variables AND a bunch of run-time related stuff, like the DB connection pool, and various Channels for inter-thread communication, how is it really different from writing the entire app in IO?
01:26:02 <saurabhnanda> EvanR: Cale: another philosophical question. If my app-config record type has a bunch of config variables AND a bunch of run-time related stuff, like the DB connection pool, and various Channels for inter-thread communication, how is it really different from writing the entire app in IO?
01:28:12 <saurabhnanda> Isn't "easier reasoning about code" the core benefit of purity? However, if a lot of functions are taking one humongous kitchen-sink as an argument, how can you really understand what the function is doing? If it's taking an NwConfig value, which has the DB connection pool, HTTP manager, AND various Channels, it could be doing anything at all. Who knows. The only thing I can tell is whether it's an IO action or not. Within the IO acti
01:28:14 <saurabhnanda> on, it could be doing anything.
01:42:53 <sbrg> saurabhnanda: sure, it could be doing anything. but the functions it consists of can't. presumably, large parts of the internal logic are going to be pure
01:49:26 <ocramz> hullo
01:50:08 <sbrg> morning
01:51:04 <ocramz> Q: when running `stack solver`, what does "rejecting lib-0.1:!test (global constraint requires opposite flag)" ?
01:51:22 <ocramz> (I am writing lib in question)
01:52:32 <ocramz> (and I haven't specified or required such a flag)
01:58:43 * hackagebot werewolf 1.2.0.3 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.2.0.3 (hjwylde)
01:59:30 <sgronblo> Cale: card flipping? final fantasy 8?
02:01:07 <Cale> Nah, it's a completely random bonus game in Prismata which you play to win skins and emotes
02:06:59 <jani_> Hey, So uh, I just started learning haskell, I come form imperative programmers world... I had small case where I want to produce a list, starting from an empty list [], then I want to chain some functions, which all take two argument, second argument must be the list from the previous function result. Something like this. if chain operator will be |> it will look like this: [] |> someFn arg |> anotherFn arg |> and so on. starting fro
02:07:05 <jani_> to produce final result
02:07:39 <jani_> please help
02:07:55 <ocramz> jani_ why do you want to start from an empty list?
02:08:21 <ocramz> you don't need to
02:08:43 * hackagebot aivika 4.5 - A multi-method simulation library  https://hackage.haskell.org/package/aivika-4.5 (DavidSorokin)
02:08:45 * hackagebot aivika-transformers 4.5 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.5 (DavidSorokin)
02:08:46 <jani_> ocramz: it can already contain something, but if you have another way help will be appreciated
02:08:47 * hackagebot aivika-branches 0.1.3 - Nested discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-branches-0.1.3 (DavidSorokin)
02:08:49 * hackagebot aivika-distributed 0.2 - Parallel distributed discrete event simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-distributed-0.2 (DavidSorokin)
02:08:51 * hackagebot aivika-lattice 0.1 - Nested discrete event simulation module for the Aivika library using lattice  https://hackage.haskell.org/package/aivika-lattice-0.1 (DavidSorokin)
02:09:35 <Cale> jani_: So you could write x |> f = f x if you really want to
02:12:02 <dibblego> @type (&)
02:12:03 <lambdabot> a -> (a -> b) -> b
02:12:26 <jani_> Cale: thanks, if that's a bad idea, do you have another solution? I want to produce list by executing some functions, which's result depends on a previous list...
02:13:27 <Cale> jani_: Well, you can compose the functions together in the normal way, and apply the resulting function to the empty list ... . anotherFn arg . someFn arg $ []
02:14:11 <Cale> The only difference being the order in which you write things
02:14:43 <jani_> Cale: so that will be applied from right to left, am I correct?
02:14:56 <ocramz> composition (.) is from right to left, yes
02:15:03 <Cale> In some sense, but the evaluation actually runs left to right anyway
02:15:41 <Cale> But  f . g . h $ x  means the same thing as  f (g (h x))
02:16:45 <Cale> The advantages being fewer parens, and the fact that for example, f . g and g . h are substrings that are also going to be well-typed expressions, so it's a little easier to pull it apart and refactor things
02:23:02 <jani_> Cale: aha gotcha, made it work
02:23:04 <jani_> thanks guys!
02:30:11 <slack1256> I making a site with yesod. The usual approach to do a "recent news sections" is store the order of the news on the database right?
02:34:59 <prannayk> I want to build a neural net using Haskell from scratch
02:35:15 <prannayk> Cam it be done? How?
02:37:03 <sbrg> of course
02:39:46 <ocramz> prannayk : perhaps you can be a bit more specific? 
02:42:54 <ocramz> you know, structure of the network, node functions. Then comes training; you need a nonlinear optimizer that can handle the error function.
03:03:47 * hackagebot nvim-hs 0.0.8 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.8 (saep)
03:09:43 <the_2nd> Is it possible to define types on classes?
03:09:58 <the_2nd> Something like type MyType = (Floating, Floating)
03:10:08 <the_2nd> can't find the correct syntax for this
03:10:19 <mpickering> What is the error?
03:10:47 <the_2nd> Expecting one more argument to Floating
03:11:15 <mpickering> So it will work if you have type MyType a = (Floating a, Floating a)
03:11:24 <mpickering> I'm not sure what you are trying to do
03:11:48 <the_2nd> I was defining types and functions on double
03:11:58 <the_2nd> but floating would be fine, so I want it to be more generic
03:12:50 <eldon> why does 92 / 10 return 9.2 but 92 `div` 10 (or div 92 10) returns 9?
03:12:59 <eldon> is there some sort of type coercion going on?
03:13:33 <mpickering> eldon: No, / and div are different
03:13:34 <the_2nd> eldon div is for integer, while / is for floating
03:13:38 <mpickering> :t (/)
03:13:39 <lambdabot> Fractional a => a -> a -> a
03:13:40 <mpickering> :t div
03:13:40 <eldon> ah i see, thanks :)
03:13:41 <lambdabot> Integral a => a -> a -> a
03:14:16 <eldon> :t Bool
03:14:17 <lambdabot>     Not in scope: data constructor ‘Bool’
03:14:17 <lambdabot>     Perhaps you meant variable ‘bool’ (imported from Data.Bool)
03:14:24 <eldon> heh, nice bot
03:14:27 <the_2nd> mpickering, so I have e.g. type Range = (Double, Double)
03:14:41 <the_2nd> f :: Range -> Double
03:14:57 <mpickering> ok right, so you want it to work for any Floating
03:15:06 <the_2nd> yep
03:15:32 <mpickering> ok, the way to do this is, type Range = forall a . Floating a => (a, a)
03:15:46 <mpickering> or if you ever put `Range` into a data structure you need to wrap it in a newtype
03:16:03 <mpickering> newtype Range = Range (forall a . Floating a => (a, a))
03:22:32 <the_2nd> mpickering, the type syntax gives me an illegal symbol error for the dot
03:22:41 <mpickering> You need to enabled RankNTypes as well
03:23:43 <mpickering> I repeat, this will cause problems if you have anything like [Range] in your program
03:23:55 <mpickering> and ask you to turn on ImpredicativeTypes which is a horribly broken extension
03:24:10 <mpickering> so probably the correct thing to do is the second thing I suggested which is to use a newtype
03:28:48 * hackagebot rose-trees 0.0.4.2 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.4.2 (athanclark)
03:39:30 <the_2nd> mpickering, seems to work, thanks
03:39:54 <the_2nd> other issue:  I had zip ones twos      to create my ranges
03:40:07 <the_2nd> which now wont work, since (Double, Double) != Range
03:40:19 <the_2nd> how can I solve this?
03:40:47 <the_2nd> f :: [Double] -> [Double] -> [Range]
03:42:26 <liste> the_2nd: f1 :: [Double] -> [Double] -> [(Double,Double)] and f2 :: [(Double, Double)] -> [Range]
03:42:42 <liste> f2 involves `map'
03:42:51 <mpickering> What doesn't work the_2nd?
03:43:30 <the_2nd> just working on it
03:43:47 <the_2nd> map Range $ zip ones twos    is my current non-working solution
04:03:19 <the_2nd> I get a couldnt match type (Double,Double) with forall a. Floating a => (a,a)
04:03:49 * hackagebot streaming 0.1.4.3 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.1.4.3 (MichaelThompson)
04:04:42 <the_2nd> mpickering, http://lpaste.net/1932912613809717248 
04:04:50 <the_2nd> where Range is the newtype definition of yours
04:09:25 <mpickering> my definition was slightly wrong
04:09:34 <mpickering> https://www.irccloud.com/pastebin/683wIlqY/
04:09:50 <mpickering> That works instead,
04:11:32 <ocramz> C preprocessor question (working with c2hs now): is there a way to exclude certain header files in a directory to be imported ?
04:11:53 <mpickering> I got the quantification in the wrong place, another way is data Range = forall a . Floating a => Range (a, a)
04:12:16 <alokbeniwal> how do you install the `random`  module? GHC 8.0.1 seems to lack System.Random
04:15:10 <cocreature> alokbeniwal: cabal install random
04:16:15 <alokbeniwal> why does 'stack install random' not do anything? isn't it a wrapper for cabal?
04:18:49 <the_2nd> mpickering, sadly with the new definition this fails already : http://lpaste.net/9152578859713953792
04:18:53 <liste> alokbeniwal: are you doing that in a project?
04:19:01 <the_2nd> couldnt match a with a1
04:19:06 <the_2nd> where both are floating
04:19:21 <ocramz> alokbeniwal : it depends. Are you running it in a directory that has a stack.yaml ? That is, have you run `stack init` in the directory already?
04:19:41 <alokbeniwal> @liste no, globally
04:19:41 <lambdabot> No module "no, globally" loaded
04:19:58 <cocreature> the_2nd: using an existential means that you can’t assume anything about a except for the type class constraints. in particular you can’t return an arbitrary a
04:20:13 <cocreature> the_2nd: if you want to force it to be polymorphic you need a rank2type not an existential
04:20:55 <mpickering> Maybe instead you want, "type Range a = (a, a)"
04:21:11 <mpickering> and then you can write centerRange :: Floating a => Range a -> a
04:21:15 <mpickering> which would be a lot simpler
04:42:48 <the_2nd> mpickering, looks better, g2g now, tho. Thanks for your help (also cocreature)
05:07:21 <eldon> in gchi if i type :t 1 it returns "Num a => a", 1 is of type Num but what does the "a => a" part mean?
05:07:28 <eldon> ghci*
05:08:52 * hackagebot shake 0.15.9 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.9 (NeilMitchell)
05:09:50 <pavonia> eldon: It mean 1 is of type a where a is an instance of the Num typeclass
05:10:54 <eldon> ok, not quite sure i follow but maybe it'll become clearer later in the book :)
05:11:07 <eldon> not covered the type system yet so probably should read it first
05:11:16 <agocorona> eldon: put a parenthesis:   (Num a)  -> a
05:11:25 <agocorona> (Num a ) =>  a
05:12:18 <phanimahesh> eldon: Type classes represent a class ( group ) of types.
05:12:24 <agocorona> return any a,  tha is instance of  the Num class
05:12:34 <phanimahesh> eldon: Num represents types that can be considered a number.
05:13:22 <phanimahesh> And (Num a) => a is the notation for "a type a where a belongs to typeclass Num.
05:13:53 <eldon> ah i think i get it now, ta :)
05:43:53 * hackagebot IntervalMap 0.5.1.1 - Containers for intervals, with efficient search.  https://hackage.haskell.org/package/IntervalMap-0.5.1.1 (ChristophBreitkopf)
05:58:53 * hackagebot werewolf 1.3.0.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.3.0.0 (hjwylde)
06:03:54 * hackagebot werewolf-slack 1.0.1.3 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.3 (hjwylde)
06:05:58 <Esxyz> did you guys see Peyton Jones' new music video  https://www.youtube.com/watch?v=vqYJRc0TJkQ
06:09:58 <maerwald> that's not Peyton Jones afais
06:10:21 <Esxyz> maybe there's a difference in your locale
06:13:01 <Esxyz> maerwald sorry here's the correct link https://www.youtube.com/watch?v=26-VzfBZg1w
06:17:15 --- mode: ChanServ set +o mauke
06:17:15 --- kick: Esxyz was kicked by mauke (Esxyz)
06:19:15 --- mode: mauke set -o mauke
06:34:58 <Pythonbeginner> Hi! Im writing a small python program based on the mind game called "mastermind". Only this time its the computer who solves the code and the player makes one up. I started by writing a code that can solve what numbers are in the code. Everything works fine exept that my code seems to run twice every move? Can somebody help me and take a look at my code?
06:36:26 <Pythonbeginner> is anyone here?
06:36:44 <eldon> you might have better luck in #python
06:36:57 <Pythonbeginner> okay thx
06:48:42 <EvanR> pugs wikipedia state benefit of haskell "Because Haskell is a purely functional language, making the functional code interact with the real world requires thought"
06:49:10 <EvanR> requires thought!
06:55:11 <EvanR> one of the main issue with dynamic typing is that ensuring continued consistency requires thought
07:08:21 <shersh> Hello everyone! I want to ask what is equivalent of eta-reduction in haskell for functions inside monads? I just want to write some code more concisely. For example, if I have function `fWithMap :: Map k v -> Int -> IO ()` I can simply write default `f` like `f :: Int -> IO ()`, `f = fWithMap empty`. This is simple eta-reduce. But what I really want is to pass `Map` inside `IORef`. So now I have `fWithMap :: IORef (Map k v) -> Int -> I
07:09:03 <shersh> But I cant write neither `f = fWithMap (newIORef emtpy)` nor `f = newIORef empty >>= fWithMap`
07:10:01 <shersh> So my question: how can I avoid passing arguments inside definition of `f` with using `IORef`?
07:10:55 <M-Magnap2> return empty should work
07:11:54 <M-Magnap2> what's the lambdabot syntax again?
07:12:05 <M-Magnap2> :t return mempty :: IORef (Map k v)
07:12:06 <lambdabot> Not in scope: type constructor or class ‘IORef’
07:12:06 <lambdabot>     Not in scope: type constructor or class ‘Map’
07:12:07 <lambdabot>     Perhaps you meant ‘Data.Map.Map’ (imported from Data.Map)
07:12:49 <coppro> shersh: f i = newIORef empty >>= \r -> fWithMap r i
07:12:59 <coppro> @pl f i = newIORef empty >>= (\r -> fWithMap r i)
07:12:59 <lambdabot> f = (newIORef empty >>=) . flip fWithMap
07:13:04 <coppro> ^
07:13:36 <shersh> coppro: thanks! That helps a lot!
07:37:39 <danpalmer> Anyone here have much experience with Heist templating? I'm having real difficulty getting splices to bind to names. Following the examples practically to the letter. Are there any 'gotchas' I should be looking out for
07:41:10 <danpalmer> Ah ok, turns out Snap wasn't calling my handler it was just returning the template directly.
07:43:57 * hackagebot streaming-eversion 0.1.0.0 - Translate pull-based stream folds into push-based iteratees.  https://hackage.haskell.org/package/streaming-eversion-0.1.0.0 (DanielDiazCarrete)
07:53:32 <the_2nd> how can I cast a Double to the Floating within my scope?
07:54:51 <maerwald> cast?!
07:56:00 <pavonia> Double already is a Floating
08:03:51 <the_2nd> hm the issue is as follows:
08:04:20 <the_2nd> f :: (Floating a) => Mytype a => Something
08:04:28 <the_2nd> within the function I produce a double
08:04:35 <the_2nd> which I now want to cast to a
08:04:51 <the_2nd> how can I do that?
08:05:00 <magneticduck> @type realToFrac
08:05:01 <lambdabot> (Fractional b, Real a) => a -> b
08:05:09 <Big_G> Does anyone have resources on how to view a software system as an algebraic system?
08:05:45 <maerwald> the_2nd: you cannot cast, you mean convert
08:07:47 <the_2nd> maerwald, got it to work
08:08:02 <the_2nd> one question: if i define a function with Floating a
08:08:12 <the_2nd> and within it define another function, also Floating a
08:08:20 <the_2nd> I get issues that a and a1 dont match
08:08:27 <the_2nd> if I drop the signature, it works fine
08:08:34 <the_2nd> what's the correct signature there?
08:08:48 <coppro> the_2nd: either don't specify a type signature, or look at ScopedTypeVariables
08:10:33 <the_2nd> is that correct? : just re-use a in the inner function and add that header?
08:10:41 <the_2nd> without defining what a is
08:13:31 <SweetKatya> hello. I am reading here : http://chimera.labs.oreilly.com/books/1230000000929/ch13.html#conc-par_00000029 . i could not understand what doesthe function`inner` do. please help
08:13:47 <EvanR> the_2nd: to do it properly you need scoped type variables extension
08:14:03 <EvanR> in the outter signature use forall to name the type variables
08:14:06 <EvanR> outer*
08:14:24 <EvanR> in the inner signature you can then use them (but dont mention it in another forall, it would be shadowing)
08:14:43 <c_wraith> SweetKatya: it does whatever.  inner is an argument.  You can pass in any function with the correct type.
08:14:52 <the_2nd> EvanR, I think I'll go with dropping the inner signatures
08:14:57 <EvanR> if it works, yeah
08:21:05 <jmcarthur> Disambiguating DuplicateRecordFields turns out to be really annoying.
08:21:21 <jmcarthur> I have a case where even annotating the selector with its type doesn't help.
08:21:41 <c_wraith> Is there a type family involved?
08:21:44 <jmcarthur> No.
08:22:54 <jmcarthur> I ended up doing this, which actually gives me a pretty nice syntax for disambiguating, but I'm afraid of how many lines I'm going to have to write like this: import qualified Graphics.Vulkan as VkPhysicalDeviceProperties (VkPhysicalDeviceProperties (..))
08:23:31 <c_wraith> I'm not sure how the type wasn't sufficient to disambiguate without a type family being involved
08:23:40 <jmcarthur> Me either.
08:24:03 <jmcarthur> Suspect a bug. I haven't attempted to report it yet.
08:35:22 <Ohso_> Is there an easier way to create a newtype "Blah = Blah Int"  that has most of the properties of an Int without a page and a half of boilerplate typeclass instances that go with it? I have a number of these I'd like to create and am getting tired of having to copy/paste an entire file full of instance declarations.
08:37:01 <hpc> look at generalized newtype deriving
08:37:03 <simpson> Ohso_: You can use GeneralizedNewtypeDeriving, if you're not doing anything fancy. Out of curiosity, is it really a page and a half?
08:38:05 <hpc> if you're one of those silly people who insists on 80x24, writing Eq and Ord instances is already most of a terminal window
08:38:15 <hpc> :P
08:39:07 <simpson> Can't the compiler do Eq and Ord on newtypes automatically without GND?
08:39:30 <jmcarthur> yes
08:39:33 <hpc> yeah, that was just an example, and not a very serious one either
08:40:51 <Ohso_> Maybe not quite, but creating a new file and changing it for each new type is a pita:  http://pastebin.com/Xev7fmyP
08:41:43 <pyon> I have a “Functor f”. Furthermore, “f a” is always a monoid, in a way that doesn't depend on “a”. Does it automatically follow that “f” is an Alternative? If so, how could I prove it?
08:42:34 <pyon> Right now, the only examples I have in mind are [] and Maybe, which happen to be Alternatives.
08:43:22 <hpc> pyon: is f also Applicative?
08:43:35 <Ohso_> I need to use these types as indexers into arrays, which adds a bit, but it's bad enough even without that.
08:43:36 <hpc> pyon: if not, it doesn't always follow because you can't write pure
08:43:52 <simpson> Ohso_: Huh. Did your workplace ban Ints or something?
08:44:08 <monochrom> you can probably go with "x <|> y = x <> y" and see if the monoid laws for <> logically implies the alternative laws for <|>
08:44:56 <hpc> the laws for Applicative are that (<|>) is associative and empty is the identity of (<|>)
08:44:57 <pyon> hpc: Oh. Is there an example of a Functor withour a valid Applicative instance, but which, applied to any type, always yields a monoid?
08:45:02 <hpc> er, for Alternative
08:45:15 <hpc> pyon: probably
08:46:43 <Ohso_> The types are logically distinct and are used in close proximity to each other. Using Ints could lead to hard to discover bugs. I really thought this would be something easy to do in Haskell.
08:46:48 <hpc> pyon: for something like this i would take the constructive approach, that if Applicative really did always follow from Functor f and Monoid (f a), you could write some generic instance for it
08:46:53 <nshepperd> you can write pure with that
08:47:16 <nshepperd> oh, maybe not
08:47:21 <pyon> Ah, right!
08:47:47 <nshepperd> I mean (\x -> fmap (const x) mempty) has the right type but is clearly wrong
08:48:09 <simpson> Ohso_: You can use GND, which is easy.
08:48:52 <Ohso_> Not familiar with that.
08:49:19 <jmcarthur> Ohso_: At the top of your file, add {-# Language GeneralizedNewtypeDeriving #-}. Now you can derive all that stuff instead of defining it manually.
08:49:23 <pyon> Mmm, given “data Foo a = Foo (Maybe a) (Maybe a)”, Foo is clearly a Functor, and not an Applicative. Yet “Foo a” is a Monoid. I guess that settles my earlier question.
08:49:32 <Ohso_> Only been using Haskell for a few weeks and this is my first real application using it.
08:50:10 <jmcarthur> pyon: That looks like an applicative to me.
08:50:20 <nshepperd> pyon: isn't it? there's the pointwise applicative instance
08:50:40 <pyon> Oh.
08:51:10 <Ohso_> I get:   Warning:    -XGeneralizedNewtypeDeriving is not allowed in Safe Haskell; ignoring -XGeneralizedNewtypeDeriving
08:51:40 <hpc> sufficiently evil use of GND can produce unsafeCoerce-like effects
08:51:42 <nshepperd> I think all polynomial data types are functor and applicative generically
08:52:12 <pyon> IIUC, the problem with GND is its interaction with GADTs and type families.
08:52:31 <jmcarthur> Ohso_: I think you might be using an old version of GHC. I thought newer versions supposedly fixed this.
08:52:41 <jmcarthur> With the roles system.
08:52:50 <jmcarthur> Which is not exactly my favorite thing in the world, but...
08:53:03 <pyon> Yeah, roles are kinda ugly. :-|
08:53:03 <anewnewbie> Hello, I am using TH to generate lens (fields and prisms) for a few types (say A, B, C).
08:53:03 <anewnewbie> At the moment I have to do makeFields ''A ; makePrisms ''A ; makeFields ''B ; makePrisms ''B ; makeFields ''C ; makePrisms ''C. 
08:53:03 <anewnewbie> I would like to reduce the repetition so I wrote something like: models = [''A, ''B, ''C] ; concat <$> mapM makeFields models; concat <$> mapM makePrisms models.
08:53:03 <anewnewbie> I am getting the GHC stage restriction error though. Is it possible to have 'models' defined in the same file as the concats?
08:54:03 <jmcarthur> anewnewbie: You can't use template haskell to generate code in the same module that the TH is defined.
08:54:23 <Ohso_> This would likely be a bit older, since it is the version in Debian stable. Has it really changed much in the last year or two?
08:54:36 <jmcarthur> Ohso_: GHC changes pretty rapidly.
08:54:47 <monochrom> one year is a long time for GHC
08:55:13 <anewnewbie> jmcarthur: Yeah, that's what I though. I was wondering whether there is a way for the models variable to be "created" at compile time also and used in the same module.
08:55:40 <monochrom> by default, assume that your linux distro is too much behind. this is correct 99% of the time.
08:56:02 <monochrom> (I mean for GHC of course.)
08:56:09 <jmcarthur> 87% of statistics are made up, though.
08:56:14 <hpc> that rule applies to most other things too
08:56:19 <hpc> /especially/ with debian
08:56:54 <anewnewbie> If I am understanding this correctly, if  I had 3 TH functions f,g,h and g depended on f , and h on g, I would have to create 3 modules, one for each just to work around the stage restriction.
08:57:39 <hpc> no, you could use all three together compositionally in one module
08:57:50 <hpc> you just can't actually execute that TH against its own source file
08:57:52 <jmcarthur> anewnewbie: Only if they are all being used to generate the next. If you are just composing them, you can define them together.
08:58:02 <anewnewbie> Ah, I see
08:59:17 <anewnewbie> So I could put all f, ,g ,h in a giant [d|  |] in one file and splice h in another.
09:02:12 <jmcarthur> anewnewbie: You don't even have to put them all in the same [d| |].
09:02:21 <jmcarthur> But you could.
09:04:10 <anewnewbie> jmcarthur and jpc: thanks a bunch guys! I've been struggling with this all day :(
09:15:43 <maaarcocr> I'm trying to create a server for a 1v1 online game. I want to use forkIO in order to manage different players at the same time. I wanted to use the snap framework, but I can't find any example of using forkIO and snap.
09:17:23 <hpc> a webserver for a 1v1 game?
09:18:17 <maaarcocr> sorry for the poor description. The game will be online, thus I need a server
09:22:05 <the_2nd> might a kdtree be faster with strict nodes?
09:22:11 <the_2nd> I wanna try to speed it up
09:23:00 <hpc> maaarcocr: snap isn't a general-purpose library for writing servers, it's a web framework
09:23:10 <sdx23> does, by chance, anyone know a reversible mail parsing library?
09:23:31 <hpc> as in parse a message and then serialize it again?
09:23:44 <maaarcocr> hpc: thanks, so what should I use? (sorry for being such a noob)
09:23:59 <sdx23> hpc: exactly, plus modifications.
09:24:13 <jmcarthur> the_2nd: It might. It depends on how it's being used.
09:25:39 <the_2nd> jmcarthur, I can't get it to work : http://lpaste.net/7944260536210817024
09:25:59 <hpc> sdx23: mime-mail does the serializing half of it...
09:27:46 <sdx23> hpc: I had used mime-mail and mime at some point, but the types of the two are horribly non-matching. With all that plumbing I've come to think about writing my own, and now wanted to recheck, not that there's been something escaping my radar.
09:27:48 <hpc> hsemail seems to do parsing, but i am not thrilled with it
09:28:17 <hpc> in particular, it doesn't handle multipart messages at all
09:28:21 <hpc> i don't know what it even would do
09:28:31 <hpc> it parses a message as a list of headers followed by a string
09:28:37 <jmcarthur> the_2nd: !KdTree2D v  I think needs parens. Strictness annotations apply to types, not type constructors.
09:29:20 <maerwald> it's also sad we don't have a proper smtp implementation
09:30:38 <hpc> i would write it if i didn't already know that a good implementation of message parsing and serialization would be 20k lines
09:30:40 * jmcarthur has never heard of a "proper" smtp implementation.
09:31:09 <maerwald> jmcarthur: opensmtpd
09:31:10 <the_2nd> jmcarthur, didnt speed it up, ill leave it lazy then
09:31:41 <hpc> between all the bullshit like punycode for domain names, =UTF8?whatever= weirdness
09:32:19 <hpc> there's a mime type for message parts that are split across multiple messages, even
09:32:24 <hpc> god help you if you ever need that
09:32:39 <sdx23> hpc: I'd need multipart :(
09:32:43 <sdx23> maerwald: what do you mean?
09:32:54 <maerwald> sdx23: ?
09:33:37 <hpc> if you're going to use opensmtpd, you might as well go all the way and use postfix
09:33:44 <maerwald> why?
09:35:33 <hpc> it's more configurable
09:35:40 <maerwald> it's a configuration mess
09:36:14 <hpc> it doesn't even look possible to add antispam to an opensmtpd instance
09:36:15 <maerwald> I don't really see why you would generally just use postfix in favor of openstmpd. I cannot follow.
09:36:24 <geekosaur> postfix is the new sendmail?
09:36:49 <hpc> oh, it seems it can
09:37:03 <hpc> by shelling out to other commands
09:37:48 <hpc> sendmail is fucking awful
09:37:50 <hpc> postfix is alright
09:38:05 <maerwald> depends, sendmail code is easier to tread
09:38:07 <maerwald> *read
09:38:12 <hpc> uh
09:38:13 * Clint squints.
09:38:32 <hpc> the last time i looked at sendmail code, i spent 4 hours trying to figure out what if-block i was in
09:38:42 <maerwald> it has comments, useful ones even
09:38:53 <hpc> it's not indented right at all
09:39:19 <sdx23> geekosaur: i'd rather ssmtp be the new sendmail
09:39:54 <hpc> somewhere out there is a mailing list conversation i was a part of with a sendmail dev where the two of us plus a couple of other devs couldn't collectively figure out where a single log line was coming from
09:40:02 <hpc> in 2000 lines of C
09:40:09 <hpc> /that's/ how bad sendmail is
09:42:07 <maerwald> that's just C
09:42:32 <hpc> i know how to read C, that code was something special
09:43:06 <maerwald> I experienced that with random C projects, so I don't consider that special.
09:43:23 <Zemyla> Hmm, if I have a potentially deeply nested data type, an I want it to be Hashable, then should I use a 
09:43:28 <maerwald> global states, side effects, spagehtti code, all pretty common in C
09:43:35 <Zemyla> *Hash cache type?
09:43:55 <hpc> okay, postfix's source code is in multiple files
09:44:00 <hpc> that's already an improvement on sendmail
09:44:40 <Zemyla> Like data SHash a = SHash !Int a; sHash :: (Hashable a) => a -> SHash a; sHash a = SHash (hash a) a;
09:44:50 <hpc> yeah, postfix's source is very pleasant
09:45:22 <maerwald> erm, sendmails source code is not in a single file
09:50:32 <hpc> it might as well be
09:59:03 * hackagebot libroman 2.2.0 - Roman Numerals for YOU  https://hackage.haskell.org/package/libroman-2.2.0 (ahakki)
09:59:26 <jmcarthur> Zemyla: This is a reasonable thing to do as long as you are mixing your hashes correctly.
09:59:38 <bollu> tangential question, but the HELL does writing shell completions work?
09:59:40 <bollu> it's like black magic
09:59:51 <Zemyla> jmcarthur: How do I do that?
09:59:52 <bollu> bash, zsh and fish all have different methods to hook in completion
10:00:02 <bollu> plus there's no proper way to inject shell completions?
10:00:08 <sdx23> hpc: 20kloc you say? hsemail has 2k, mime <1k. Are they missing out on so much?
10:00:14 <bollu> what the hell, can someone please tell me how I can start to learn about this?
10:00:30 <jmcarthur> Zemyla: Use hashWithSalt to integrate the hashes from deeper levels of your data structure into the current level.
10:01:30 <jmcarthur> Zemyla: That is, you can only use the plain hash function in leaves.
10:01:52 <hpc> sdx23: it's probably not that bad, but missing out on multipart (which is itself non-trivial and has stuff like individual part headers, embedding references to one part in another, alternative parts, etc)
10:02:00 <hpc> sdx23: plus only doing half of the parse/print combo
10:02:35 <jmcarthur> Zemyla: Actually.... I'm not quite sure I'm making sense.
10:03:24 <sdx23> hpc: this seems like a huge project to me. Even though it should mostly be converting rfc2822 into code, isn't it?
10:03:36 <jmcarthur> Zemyla: It seems to me that a well behaved Hashable instance implements hashWithSalt. If you are caching your hashes, that seems to imply you should actually be caching partially applied hashWithSalt functions (that is, Int->Int, not just Int), which would defeat the purpose of the cache.
10:04:07 <jmcarthur> Anyway, I still think it's reasonable to do, but maybe the quality will go down a bit.
10:04:41 <hpc> the mime package does QP and base64, but it doesn't do punycode for unicode domain names, you need something to validate email addresses
10:05:28 <hpc> probably also parsing dates and received headers, doing DKIM/SPF checks
10:06:25 <hpc> i also don't see where hsmail does unicode handling in mail headers
10:06:35 <hpc> because that's done totally differently as well and it's really ugly
10:07:17 <hpc> besides QP and base64, i remember there also being a few other content transfer encodings, but i don't remember specifically what they are off the top of my head
10:07:40 <sdx23> ah, I remember some issues with encoding additionally brought me on the self-implement train.
10:07:59 <bollu> how does one implement bash and zsh completions?
10:08:00 <hpc> (not all of that is mandatory to have, or always needed for every message, but i would consider them required to be present for a library to be considered good)
10:08:01 <bollu> is there a "unified" way to do this?
10:08:27 <hpc> i have seen (granted mostly in spam) content transfer encodings of 6bit, 7bit, and 9bit
10:08:44 <hpc> which are probably nonsense but should be handled properly in some way
10:09:47 * hpc has done a ridiculous amount of email stuff
10:10:15 <geekosaur> bollu, had you considered asking somewhere where people might know the answer?
10:10:32 <sdx23> me almost non, coding wise. And I'm not so sure anymore that I should.
10:10:50 <bollu> geekosaur: I'm honestly not sure where the right place is - I debated stackOverflow, and I assumed it would be closed for being "too broad". The compsci IRC is pretty sparse
10:11:03 <bollu> geekosaur: I thought I'd have a good shot here because a lot of people frequent the IRC
10:11:14 <hpc> sdx23: it's not a terrible thing to get good at, though haskell isn't the ideal environment
10:11:29 <geekosaur> hpc, all three are historical (and historically were used) --- but pretty much nothing within the past 20 or so years should be generating them
10:12:25 <geekosaur> (6 and 9 bit were DEC mainframes, 7 bit was for serial connections where the 8th bit was parity and the hardware didn't allow turning parity off)
10:12:40 <geekosaur> and DEC minis esp. for 6 bits
10:13:03 <geekosaur> bollu, tbh I'd be using SO for that
10:13:22 <geekosaur> I have not seen a lot of completions discussion here so it's not someplace I'd ask first...
10:14:24 <geekosaur> also I don't think I've ever seen unified completions support, quite often people support bash-completion and then a zsh enthusiast translates that separately in my experience
10:28:13 <puregreen> what are Eq1, Show1, etc. useful for? (I feel that I have even asked this question before, but I don't remember the answer)
10:29:24 <Gurkenglas> Why was NonEmpty's Cons instance removed from lens? Just because it's _Cons is singular?
10:30:00 <puregreen> Gurkenglas: https://github.com/ekmett/lens/issues/636
10:31:10 <Gurkenglas> If you asked, it wasn't in #haskell http://ircbrowse.net/browse/haskell?q=puregreen+Eq1 http://ircbrowse.net/browse/haskell?q=puregreen+Show1
10:31:24 <Gurkenglas> -it's
10:37:27 <Gurkenglas> Ah of course, unconsing a NonEmpty a into a Maybe (a, NonEmpty a) is dumb.
10:39:04 * hackagebot clckwrks 0.23.16 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.16 (JeremyShaw)
10:40:26 <Gurkenglas> (And I'd vote for an additional Cons law that says that that prism may only fail on empty)
10:41:22 <geekosaur> puregreen, https://ghc.haskell.org/trac/ghc/ticket/11135#comment:18 seems relevant
10:41:36 <geekosaur> re Eq1 et al
10:44:54 <Jef_> I've got a little question about the Maybe monad. http://lpaste.net/990061322609623040 . I thought that placing this code in a monad block would cause the whole function to return nothing if any step fails, but the compiler throws me an error. Did I misunderstand something?
10:47:07 <puregreen> Jef_: it should be “let start = ...” (same for end)
10:47:32 <puregreen> since “UTCTime date (realToFrac seconds)” is just a value, it isn't wrapped in Maybe
10:48:10 <puregreen> or you could write “start <- return $ UTCTime ...”, which is kinda pointless
10:48:57 <Jef_> ok thank you! I just found that second solution, but clearly your way is the correct way to do it!
11:01:33 <grandpascorpion> Question about generating smooth numbers if anyone could help me out.  http://lpaste.net/165836
11:03:03 <puregreen> grandpascorpion: what's mergeAll?
11:03:32 <grandpascorpion> http://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/Data-List-Ordered.html
11:03:42 <grandpascorpion> @puregreen.  Thx
11:03:42 <lambdabot> Unknown command, try @list
11:03:58 <puregreen> grandpascorpion: “@” prefixes commands to bot in this channel
11:04:05 * hackagebot flow-er 1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/flow-er-1.0.0 (expede)
11:04:06 <Squarism> is it not allowed to use "where" within a if-then.else clause?
11:04:07 * hackagebot flow-er 1.0.1 - Directional operators to for common combinators  https://hackage.haskell.org/package/flow-er-1.0.1 (expede)
11:04:08 <bollu> :t (.^)
11:04:09 <lambdabot>     Not in scope: ‘.^’
11:04:09 <lambdabot>     Perhaps you meant one of these:
11:04:09 <lambdabot>       ‘.’ (imported from Data.Function),
11:04:19 <bollu> oh, lens functions aren't here?
11:04:26 <puregreen> :t (^.)
11:04:27 <lambdabot> s -> Getting a s a -> a
11:04:37 <puregreen> they are, you just mistyped :)
11:04:42 <bollu> oh right :)
11:04:53 <Welkin> I decided to play around with java today
11:04:59 <bollu> I wanted to understand how Getting, Iso, etc. worked. They're datatypes, not type classes right? so, like, where to "instances" of Getting a s a come from?
11:05:11 <bollu> I don't really get how the whole Getting, Iso, and stuff get "created"
11:05:18 <Welkin> what do I need to download? There are several SDKs, not all of which are open
11:05:19 <puregreen> a Lens can be subtyped to a Getting
11:05:23 <bollu> like, how lens mimics a "inheritance hierarchy"
11:05:31 <geekosaur> Squarism, where is part of declaration syntax. Use let for expression syntax
11:05:39 <bollu> puregreen: exactly! how do you have subtyping in a language with no inheritance?
11:05:59 <Welkin> (the #java people don't respond)
11:06:05 <puregreen> type Getting r s a = (a -> Const r a) -> s -> Const r s 
11:06:28 <puregreen> type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s
11:06:33 <bollu> oh >_< so all the lens types are aliases for functions?
11:06:37 <puregreen> yep!
11:06:58 <bollu> what about Fold and Traverse?
11:07:11 <puregreen> and now go read lens over tea where this all is explained in excruciating detail
11:07:15 <Squarism> geekosaur, oh, good to know
11:07:22 <bollu> ooh, I will
11:07:32 <puregreen> Traversal is like Lens but with Applicative
11:07:43 <bollu> also, I was wondering - how do I "get into" using lens more than the usual way of using it for getters and setters?
11:07:52 <bollu> like, I see people write some really "elegant" code using lens
11:08:00 <bollu> but I don't know how to "learn" lens so to speak
11:08:07 <bollu> because it's a bunch of.. combinators
11:08:16 <bollu> operators*
11:08:20 <maerwald> "elegant" :o
11:08:38 <bollu> maerwald: quotes because opinions of elegant differ :)
11:09:05 <bollu> so, like, how do I learn to use lens effectively?
11:09:21 <maerwald> wait until you actually need it?
11:10:10 <bollu> maerwald: exactly, how do I even know if lens has a feature of not? Like, for a usual library, you know it's scope
11:10:13 <bollu> but I don't even know the scope of lens!
11:10:20 <bollu> and you can't just read the docs of the 100 odd operators
11:10:32 <bollu> its* scope
11:10:46 <ocramz> hullo
11:11:08 <grandpascorpion> Sorry, puregreen ...
11:11:19 <puregreen> grandpascorpion: a sec
11:12:53 <grandpascorpion> Oh, I found something on rosettaCode for "hamming numbers" which is closely-related.  Thanks, anyways
11:13:47 <ocramz> I'm on OSX and `getEnvironment` from System.Environment only returns some env. variables. How come?
11:14:33 <ocramz> I'm calling getEnvironment from a ghci session, if that changes anything
11:14:46 <geekosaur> that is not something that I have seen on OS X
11:14:58 <geekosaur> (but my OS X box is offline atm)
11:15:49 <maerwald> ocramz: how do you compare the results?
11:16:20 <ocramz> with `printenv`, but now I realized my mistake: some variables are declared in my .bashrc , which I guess is not read in.
11:16:42 <ocramz> uhm
11:17:01 <geekosaur> if you do foo=bar but don't do export bar, it
11:17:04 <geekosaur> s not in the environment
11:17:10 <maerwald> yeah
11:17:37 <geekosaur> also will depend on how things are started; the window system does not read your shell dotfiles when starting up, so settings from there will only exist in terminals
11:18:02 <geekosaur> although ghci should be running in a terminal (but if you launch via the window stuff then it won't be a login shell)
11:18:30 <ocramz> exactly; also, this ghci session was started by haskell-mode in Emacs.
11:18:56 <ocramz> too many layers
11:19:13 <geekosaur> an aqua emacs won't have run shell dotfiles then, yes
11:20:19 <ocramz> There should be a database or a KVS for these things, rather than a million textfiles
11:21:04 <puregreen> grandpascorpion: darn, it was obvious... once I spent 10m figuring it out, yeah
11:21:05 <puregreen> mergeAll [map (*x) (pwrlist 3) | x <- pwrlist 2]
11:21:47 <geekosaur> ocramz, and then you lose rvm and cabal-install/stack because the database doesn't let you have sandbox overrides
11:22:24 <geekosaur> (and lots of other similar tools for many different development environments)
11:24:06 * hackagebot rose-trees 0.0.4.3 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.4.3 (athanclark)
11:24:08 * hackagebot clckwrks-plugin-page 0.4.3.3 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.3 (JeremyShaw)
11:28:07 <alpha1> hey, Is there a git repo for @lambdabot? 
11:28:29 <sqrt2> https://github.com/lambdabot/lambdabot
11:28:35 <Clint> alpha1: yes
11:29:52 <jmcarthur> The most annoying thing about storable/unboxed vectors is that sometimes you have to convert to other types of vectors just to please the type checker even though you know fusion would make it such that you never have to actually generate the intermediate vector.
11:40:59 <nilof> Does anyone here know how to get the length of an hmatrix vector?
11:41:06 <nilof> Or the last element
11:41:38 <nilof> I've looked through the documentation a few times and couldn't find the length function -.-
11:45:59 <Clint> nilof: is there a Data.Vector Vector instance for your type?
11:47:52 <cocreature> nilof: there is also https://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra-Data.html#v:size
11:47:57 <sdx23> nilof: look at the Typeclasses, find Indexable and Container
11:48:06 <nilof> It's the basic datatype in Numeric.LinearAlgebra  provided by hmatrix, and as I understand it is just a wrapper for C arrays
11:48:25 <martinvlk> How about the size' function, from the Container typeclass?
11:49:03 <martinvlk> Ah, snap. :-)
11:49:50 <nilof> ah
11:49:54 <nilof> wait what
11:50:15 <nilof> it's in a different package from the same guy that I need to install separately
11:50:32 <nilof> well that explains it
11:51:38 <nilof> or no
11:52:02 <nilof> if not, it's not in scope when it should be
11:54:07 * hackagebot text-all 0.3.0.0 - Everything Data.Text related in one package  https://hackage.haskell.org/package/text-all-0.3.0.0 (Artyom)
11:54:24 <nilof> ah well, toList from the same page seems to be in scope
11:54:52 <nilof> I can convert my result back to a Haskell list, which is even better
12:04:17 <Clacious> join #reddit
12:04:39 <prohobo> no u
12:06:54 <maaarcocr> Hello, so I'm trying to build a server in haskell for a 1v1 online game. It will be sort of a quiz game where 2 players have to guess as fast as possible the correct answer and the first that guess is the winner. Now I was wondering what would be the best choice in terms of libraries, I have read about warp and snap-server, but I don't fully understand how concurrency works with them. Instead I quite understand the ha
12:08:28 <MichaelBurge> maarcocr: I found Scotty is pretty easy to get started with. Also, the sentence starting with "Instead I quite understand [...]" was cut off.
12:09:05 <jmcarthur> maaarcocr: They don't have any particular first class support for concurrency except that requests are handled concurrently with others. You would just have to use some sort of shared state and whatever (IO) concurrency primitives you feel like, I guess.
12:09:32 <Jesin> http://comonad.com/reader/2015/on-the-unsafety-of-interleaved-io/
12:10:06 <maaarcocr> this is the rest of the message: Instead I quite understand the haskell HTTP libraries and how to do concurrency with them (there are also more tutorial on them). Are there any good resources that can help me?
12:11:28 <maaarcocr> jmcarthur: that was my main problem, they concurrently deal with request but I was not finding any first class support for concurrent programming.
12:12:22 <MichaelBurge> maaarcocr: What exactly are you looking for from your web server for concurrency support?
12:13:11 <jmcarthur> maaarcocr: Right, so just use normal Haskell concurrency primitives instead.
12:13:20 <maaarcocr> MichaelBurge: due to the fact that it has to be a game server, it has to deal with multiple games at the same time (each game is quite simple, just checking the answers the clients send)
12:13:54 <jmcarthur> maaarcocr: What features do you need?
12:14:36 <MichaelBurge> maaarcocr: In that case, I'd have a separate storage layer keeping track of the games(maybe Redis or something in-memory), and each request would request state from the storage layer
12:15:46 <jmcarthur> To be honest, it doesn't sound like this game needs anything unusual for web services. Just the usual database backed engine seems fine to me.
12:16:02 <MichaelBurge> maaarcocr: That way, your server would be something like 'getGame :: Request -> IO StorageLayerState', and 'processRequest :: Request -> StorageLayerState -> IO Response'
12:16:46 <EvanR> you probably want something transactional so that things are consistent no matter what order peoples requests end up being in
12:16:52 <maaarcocr> jmcarthur: my main issue is to save the state of each game. Would you save it on a database?
12:17:14 <jmcarthur> Yeah. I doubt the extra milliseconds of latency is going to be a big deal for this kind of game.
12:17:38 <EvanR> except an additional RDBMS is a lot compared to a single MVar in memory
12:17:45 <EvanR> a lot to setup
12:17:55 <jmcarthur> Use whatever you're comfortable with, it my point.
12:18:04 <jmcarthur> I just don't think there are any special needs here.
12:18:13 <jmcarthur> s/it my/is my/
12:19:17 <Myrl-saki> reflex's code is purrty cray.
12:19:41 <jmcarthur> In particular, if you already have some sort of database for other aspect of the web site, might as well use it.
12:20:44 <maaarcocr> Thanks everyone for the support! Another question: so from what I have understood from this conversation it would be possible to use something like MVar with a server like warp or snap-server, right?
12:22:20 <MichaelBurge> maaarcocr: Correct, that will give you a functional solution in very few lines of code.
12:44:09 * hackagebot octane 0.9.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.9.0 (fozworth)
12:44:52 <maaarcocr> Okay, I have one last question about the game server: When one player guess the correct answer how can I tell the other player that he has lost? Do I need to make a request from the client and respond to it only when the game is finished?
12:45:29 <maaarcocr> For the ones that have not read my previous question, I'm trying to develop a game server for a 1v1 quiz app.
12:49:09 * hackagebot binary-conduit 1.2.4.1 - data serialization/deserialization conduit library  https://hackage.haskell.org/package/binary-conduit-1.2.4.1 (AlexanderVershilov)
12:50:13 <shafox> if i were to build a search platform i.e library such as lucene would haskell be a valid choice or should i go for something else (what are my options ?)
12:57:27 <mfukar> shafox, what are your requirements? Does Haskell meet them?
12:58:44 <shafox> mfukar: i am not sure whether haskell meets the requirement or not, i want to develop something more like what lucene does. 
13:00:13 <mfukar> Yeah, but we can't respond to something that vague with anything other than "others have built some sort of search engine(s) in Haskell", which is equally vague
13:01:14 <shafox> has anyone built search rngine in haskell ? this is what i wanted to ask. 
13:01:36 <mfukar> Sure
13:02:28 <shafox> is there  any paper or code that i can look into ?
13:02:51 <mfukar> Well googling comes up with lots of results, some are already in hackage
13:04:47 <ralu> is there a class where (f a -> f b) -> (f (a -> b)) makes sense? 
13:09:10 * hackagebot ad 4.3.2.1 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.3.2.1 (EricMertens)
13:12:16 <maaarcocr> Is there a way of doing long-polling on a haskell server?
13:15:15 <puregreen> maaarcocr: there's a binding to socket.io, and something with long polling here (https://github.com/mcschroeder/todo-example)
13:19:31 <mauke> is there a way to get ghc-7.4.2 on a current linux system?
13:20:30 <osager_> in cabal file, do i have to precisely define the dependent library version?
13:21:18 <Clint> osager_: often you don't need any bounds at all
13:21:21 <pikajude> does it make sense to be using MonadCatch m and MonadError SomeException m in the same context?
13:22:01 <mauke> the binary tarball fails with a linker error because of libgmp
13:22:10 <osager_> Clint, all online source code iven seen states the version number
13:22:19 <mauke> the source tarball doesn't compile because System.Time can't be found
13:22:49 <Clint> osager_: if you need to specify a minimum version, specify a minimum version. if you don't, don't.
13:23:24 <Jesin> mauke: do you have libgmp installed?
13:23:58 <mauke> yes, otherwise ghc wouldn't work
13:24:15 <Clint> mauke: set up a debian wheezy chroot
13:24:19 <Jesin> mauke: try specifying the full path to it in LD_PRELOAD
13:24:26 <mauke> Jesin: wtf?
13:24:32 <mauke> Clint: a what?
13:25:00 <geekosaur> Jesin, you're (badly) trying to solve the wrong problem
13:25:06 <Clint> mauke: a chroot with debian 7.0
13:25:29 <mauke> sounds complicated
13:25:37 <Jesin> geekosaur: if you have information I lack, please explain
13:25:43 * Clint shrugs.
13:25:45 <geekosaur> mauke, as an ugly hack, ghc doesn't use the parts of libgmp that changed significantly and symlinking the newer one to the old name works
13:26:18 <Jesin> thanks
13:27:05 <geekosaur> people have been doing that in both directions on debian for years because ghc and debian updates are so out of step with each other
13:28:05 <mauke> man, this stuff is about 1000 times easier with perl
13:30:52 <mauke> next step: libncurses.so.5
13:31:21 <geekosaur> that one will be nastier :/
13:31:38 <geekosaur> ncurses.6 is not backward compatible
13:32:07 <Clint> chroot, vm, or container
13:33:05 <mauke> seems to run anyway
13:33:21 <geekosaur> I think it's only needed for ghci (specifically haskeline)
13:33:51 <geekosaur> and come to think of it, that might get away with only using terminfo level functions that would still be compatible
13:34:24 <mauke> The Glorious Glasgow Haskell Compilation System, version 7.4.2
13:34:40 <mauke> ghci seems to be ok, too
13:38:23 <Squarism> is it advisable to upgradde to GHC 8.01 if you are a haskell noob?
13:39:16 <mauke> probably not yet
13:39:26 <monochrom> it is most advisable to install several versions alongside
13:39:52 <monochrom> rather than self-inflict the false dichotomy of "should I switch?"
13:40:16 <monochrom> ./configure --prefix=/usr/local/haskell/ghc-8.0.1 and play with PATH
13:40:39 <monochrom> (to "uninstall", simply rm -rf /usr/local/haskell/ghc-8.0.1
13:41:08 <geekosaur> or on debian/ubuntu use hvr's repos and https://github.com/geekosaur/ghc-wrapper
13:41:27 <mauke> ... assuming the versions still install
13:42:03 <Clint> Squarism: a lot of stuff is still broken with ghc 8
13:42:07 <monochrom> in fact Haskell Platform has been using version-specific directories for a while
13:42:27 <Squarism> ok.. good to know
13:42:45 <monochrom> but yeah you don't need 8's new features yet, and most libraries are still incompatible
13:43:21 <Squarism> is that what slack help u with? Multiple versions of ghc + version specific dependencies?
13:43:23 <monochrom> then again if you aren't going to use most libraries out there, there is no harm either
13:43:31 <Squarism> stack i mean
13:43:45 <monochrom> yes but I never needed stack for multiple versions
13:43:57 <monochrom> ./configure --prefix=/usr/local/haskell/ghc-8.0.1 and play with PATH
13:44:12 <geekosaur> stack can also select between multipe versions, but has its own pain because it ties them to resolvers (basically, stackage releases)
13:44:20 <Clint> Squarism: take a look at what's commented out in https://github.com/fpco/stackage/blob/master/build-constraints.yaml
13:44:45 <monochrom> my multi-version practice pre-dated stack
13:44:57 <monochrom> my sandboxing pre-dated sandboxes
13:45:30 <glguy> monochrom: You were cool before it was cool
13:45:37 <monochrom> there are a lot of things you can do by just reading a unix manual and GHC user's guide
13:47:13 <glguy> It's easy to switch between installed GHCs. cabal-install takes a -w flag for the GHC executable you want to use
13:47:23 <monochrom> stack is helpful if you want even more than multi-version: if you want one copy of GHC per project. that's what stack automates.
13:48:19 <monochrom> and that's heavenly gospel to some people, unspeakable montrosity to some others
13:51:27 <monochrom> I have installed 8.0.1 for curiosity. However, I still use 7.10.3 as the main version.
13:54:21 <monochrom> this gets interesting. Data.Monoid has a <>, Data.Semigroup has a <> too, and they are different.
13:56:35 <Clint> it should only take 10 years to make Semigroup => Monoid
14:15:11 <dfeuer> jmcarthur, I'm sorry I vanished suddenly last time we spoke. Did you have any concrete ideas about the Data.Sequence fromList thing?
14:15:20 <byorgey> Clint: not that long, Semigroup => Monoid is actually in process
14:15:28 <Clint> byorgey: cool
14:15:31 <dfeuer> Oh... Just got the lambdabot message.
14:15:41 <jgt> hey, does anyone know how to use a UUID for a model in Yesod?
14:16:04 <byorgey> the thing with <> being in both Data.Monoid and Data.Semigroup is probably an intermediate step to help folks upgrade without too much breakage (though I forget the details)
14:16:17 <jmcarthur> dfeuer: Yeah, sorry!
14:17:20 <dfeuer> jmcarthur, the whole thing's a bit weird. Like I don't actually understand why using a strict-spined list benchmarks better than using a lazy one; it doesn't make sense to me and it feels like it's covering up some deeper issue....
14:17:54 <dfeuer> I'll do what seems to be fastest, but I really want to get down to the bottom of this thing and do it *right*.
14:19:12 * hackagebot data-default-class 0.1.1 - A class for types with a default value  https://hackage.haskell.org/package/data-default-class-0.1.1 (LukasMai)
14:19:14 * hackagebot data-default 0.7.1 - A class for types with a default value  https://hackage.haskell.org/package/data-default-0.7.1 (LukasMai)
14:24:05 <jmcarthur> dfeuer: How do you feel about taking advantage of the fact that (at least for me when I last checked) the growable stack in GHC is a little faster than allocating list nodes on the heap?
14:24:13 * hackagebot purescript-bridge 0.6.0.1 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.6.0.1 (eskimo)
14:24:28 <dfeuer> jmcarthur, I love that idea. I just haven't been able to figure out how to take advantage of it.
14:24:33 <jmcarthur> dfeuer: As with last time, this is pretty half baked.
14:24:38 <dfeuer> I keep getting confused.
14:24:53 <dfeuer> The tricky part is dealing with "leftovers">
14:24:59 <jmcarthur> Yeah
14:25:17 <dfeuer> That is, we *don't* want to attempt to build a huge node, fail, and then start over with a smaller size.
14:25:27 <dfeuer> Rather, we want to build in pieces and put them together.
14:26:05 <dfeuer> But I don't know how to make that happen on the stack.
14:26:16 <dfeuer> Which doesn't mean it can't be done, of course.
14:26:50 <jmcarthur> Have you tried versions of this where you know the length of the list in advance?
14:27:08 <jmcarthur> I wonder if the extra pass to compute the length might be worth it.
14:27:22 <dfeuer> There already is one (accessible from the outside using the IsList instance)
14:27:44 <jmcarthur> Ah!
14:28:08 <dfeuer> jmcarthur, you mean make one pass building Node (Elem a) and also counting?
14:28:08 <jmcarthur> There are some effects of this idea that seem a little undesirable.
14:28:25 <dfeuer> That could be better than what I have now.
14:28:51 <dfeuer> Or just counting.
14:28:53 <dfeuer> Either way,
14:28:56 <jmcarthur> I actually meant two passes. I'm not sure how the idea you're thinking of right now would work.
14:29:19 <dfeuer> I am annoyed by this whole situation.
14:29:46 <dfeuer> It feels like there must be some beautiful solution and I'm not seeing it.
14:30:19 <dfeuer> Particularly to put stuff on the stack.
14:30:30 <dfeuer> That's been my goal for the last two days and I've gotten nowhere.
14:30:40 <jmcarthur> A negative side effect of this is that computing the entire list as a first pass puts a little more pressure on the GC, since it means it can't GC the list as you construct the tree if the list isn't needed anymore. (Then again, I may be misremembering the code with this strict list anyway... does it end up traversing the list all the way long before constructing deeper nodes of the tree anyway?)
14:30:57 <jmcarthur> Same for all this stack stuff, really.
14:31:19 <dfeuer> With the strict list, yeah, it fully constructs a list one third the length of the original before doing anything much else.
14:32:26 * jmcarthur looks up the IsList instance
14:32:28 <dfeuer> I know I can manually switch from three to nine,
14:32:32 <dfeuer> which might help,
14:32:43 <jmcarthur> Yay for unsatisfying constant factors.
14:32:44 <dfeuer> but I don't know how to go for the general.
14:33:03 <dfeuer> Gotta run. If you have an idea, open a GitHub issue.
14:33:10 <jmcarthur> alright
14:39:13 * hackagebot pipes-http 1.0.3 - HTTP client with pipes interface  https://hackage.haskell.org/package/pipes-http-1.0.3 (GabrielGonzalez)
14:41:16 <idev> does stack support ghc 8 yet?
14:44:13 * hackagebot pipes-group 1.0.5 - Group streams into substreams  https://hackage.haskell.org/package/pipes-group-1.0.5 (GabrielGonzalez)
14:44:15 * hackagebot pipes-bytestring 2.1.3 - ByteString support for pipes  https://hackage.haskell.org/package/pipes-bytestring-2.1.3 (GabrielGonzalez)
14:44:32 <jmcarthur> idev: It does if you use the nightly stackage.
14:52:34 <dfeuer> jmcarthur, an approach that worked well with splitAt was a sort of pseudo-continuation-based one, where all the accumulated pieces got passed along. I don't know if fromList admits a solution like that.
14:53:10 <dfeuer> There seem to be basically two processes going on; one is top to bottom and the other left to right.
14:53:24 <dfeuer> Top to bottom is easy to think about; left to right is easy to think about.
14:53:35 <dfeuer> I'm struggling to fit them both in my head at once.
14:53:55 <dfeuer> Vaguely speaking, 
14:54:17 <dfeuer> instead of consing a newly formed Node onto a list, I kind of want to pass it forward to some helper function.
14:54:18 <dfeuer> Maybe.
14:58:10 <jgt> anyone know how to answer this? http://stackoverflow.com/q/37779364/704015
14:59:14 * hackagebot shakespeare-sass 0.1.0.0 - SASS support for Shakespeare and Yesod  https://hackage.haskell.org/package/shakespeare-sass-0.1.0.0 (brcha)
15:05:48 <Cale> jgt: The use of lens machinery there is pretty non-essential.
15:05:59 <fr33domlover> jgt, I think the yesod and persistent docs mention you can override the name and perhaps the type of the id column. Note that even if it causes trouble, you can instead make the UUID column additional, and make it a secondary key (UniqueWhatever uuid)
15:06:50 <Cale> I don't know much about Yesod, but you could just use toASCIIBytes and fromASCIIBytes directly rather than constructing that Prism
15:07:31 <Cale> In fact, I don't even understand why they did that, it's actually more code than it would have been otherwise.
15:14:14 * hackagebot break 1.0.1 - Break from a loop  https://hackage.haskell.org/package/break-1.0.1 (GabrielGonzalez)
15:17:21 <dfeuer> jmcarthur?
15:18:35 <jmcarthur> dfeuer: Hey
15:18:41 <dfeuer> Yeah.
15:18:55 <dfeuer> So one half-formed idea I can't get out of my head
15:19:14 * hackagebot shakespeare-sass 0.1.0.2 - SASS support for Shakespeare and Yesod  https://hackage.haskell.org/package/shakespeare-sass-0.1.0.2 (brcha)
15:19:17 <dfeuer> is that it could make sense to build some representation of the left side of the tree,
15:19:22 <dfeuer> as far as it goes,
15:19:29 <dfeuer> and then *somehow* deal with the rest.
15:19:30 <dfeuer> But 
15:19:38 <dfeuer> that is waaaay too vague.
15:19:41 <dfeuer> Ugh.
15:19:54 <dfeuer> I'm failing.
15:19:57 <dfeuer> Another thought:
15:20:33 <jmcarthur> I was thinking of something that sounds similar, but not quite the same. Basically, reverse the list and compute its length (can be done in one pass) then just build the tree from top to bottom using both the front and the back of the list in a fashion that looks a bit similar to applicativeTree.
15:20:36 <dfeuer> Maybe restrict the number system in some way to make pieces fit together better. Sort of.
15:21:03 <jmcarthur> It's basically just a variation on fromList2
15:21:24 <jmcarthur> I have no intuition for whether fromList2 is better or worse than this.
15:21:33 <dfeuer> jmcarthur, that's probably going to suck. Better, perhaps, to use replicateA with the monadic array access primitive.
15:21:46 <jmcarthur> Ah!
15:21:48 <jmcarthur> That's good too
15:21:54 <dfeuer> Maybe.
15:21:58 <dfeuer> Haven't tried.
15:22:30 <dfeuer> Maybe not.
15:22:38 <dfeuer> I don't think reversing the list is going to be a win though.
15:22:39 <jmcarthur> Well, "good" is a bit optimistic, but it seems nice for the middle to be lazy (although we did have to strictly evaluate the whole list up front...)
15:22:48 <dfeuer> This wouldn't be lazy.
15:22:59 <dfeuer> Unfortunately, fromArray is lazy (my fault!)
15:23:10 <dfeuer> The problem is that it can lead to space leaks.
15:23:45 <dfeuer> Because take 5 (fromArray giganticArray) holds on to the entire array until everything is forced.
15:23:49 <jmcarthur> Ah
15:24:01 <jmcarthur> Yeah. Even just one element left is enough.
15:24:10 <dfeuer> Yup.
15:24:11 <dfeuer> :(
15:25:12 <dfeuer> Let's try to avoid such things right now and see if there's a way to make the tree-based approach clean.
15:25:26 <dfeuer> Don't know if it's possible, but it *feels* like it should be.
15:25:34 <dfeuer> And I *want* it to be.
15:26:33 <jmcarthur> I'm having a lot of trouble imagining bottom-up algorithms that don't either produce progressively shorter lists like the current implementation or build up dag-shaped closures like applicativeTree.
15:27:29 <jmcarthur> The former is level order. The latter is depth first. And that's all I can think of.
15:28:10 <jmcarthur> s/depth first/pre order/
15:28:14 <dfeuer> The approach used in https://github.com/haskell/containers/blob/ed43239058dc02decf07ab144acde5dbb0aa1d53/Data/Sequence.hs#L3532 (before my recent strictification stuff) looks like it *should* be better than now, but it's not. Its laziness makes things incremental in the way I want them to be,
15:28:22 <dfeuer> but I don't want its allocation.
15:29:27 <dfeuer> So what's wrong with "dag-shaped" closures like applicativeTree, whatever exactly you mean?
15:29:41 <ij> What if I have "foo a = somethingUseful >> when (predicate a) (foo a) >> foo (f a)" will the stack fill up?
15:29:48 <dfeuer> Just doesn't apply?
15:30:02 <jmcarthur> Nothing wrong with it. I actually think it's what you are looking for, just with the length being discovered incrementally instead of up front.
15:30:16 <dfeuer> Yah, that be the hard part.
15:30:18 <jmcarthur> I'm gonna write a little code.
15:30:22 <dfeuer> OK!
15:30:37 <dfeuer> Even if you just get a partial sketch, don't be scared to open a GitHub issue.
15:30:44 <dfeuer> Later!
15:30:49 <dfeuer> And thanks.
15:44:15 * hackagebot index-core 1.0.4 - Indexed Types  https://hackage.haskell.org/package/index-core-1.0.4 (GabrielGonzalez)
15:54:16 * hackagebot xml-conduit-decode 1.0.0.0 - Historical cursors & decoding on top of xml-conduit.  https://hackage.haskell.org/package/xml-conduit-decode-1.0.0.0 (BenKolera)
16:05:15 <EvilMachine> Hi. I could found no example of how to use modern Data.Typeable. (As in: Not using typeOf, but that weird :~: and Refl…) Can anyone point me to an example or show me one?
16:05:29 <EvilMachine> (Or preferably add one to the so-called “documentation”)…
16:08:25 <dfeuer> EvilMachine, well, it seems likely to change again in 8.2, so you might want to wait till then. Otherwise, what do you find confusing about the Haddocks?
16:09:06 <EvilMachine> dfeuer: Nothing, because it contains no actual explanation on how to use the stuff… which one _might_ expect from something called a “documentation”. ^^
16:09:16 * hackagebot sparkle 0.1.0.1 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.1.0.1 (MathieuBoespflug)
16:09:36 <EvilMachine> dfeuer: But that is, sadly, the “normal case” for Haskell packages. :/
16:09:55 <EvilMachine> Whatever… I just need an example on how to use it.
16:09:56 <dfeuer> EvilMachine, well, the current incarnation of Typeable is pretty straightforward and pretty limited, unlike the one slated for 8.2.
16:11:07 <EvilMachine> dfeuer: So, how do you do now, what typeOf did before?
16:11:13 <maks_> hi guys, I wrote a small program to MD5 hash everything in the directory. I like it's speed, but the memory usage is very sub-optimal (at least compared to md5sum). Could some of you comment on the code http://pastebin.com/s2xHxUM9
16:11:24 <EvilMachine> (I want to branch, based on type.)
16:11:39 <dfeuer> EvilMachine, the main thing you need is eqT. Aside from that, most of the good stuff is in Data.Type.Equality.
16:12:14 <dfeuer> cast and gcast and gcast1 and gcast2 all seem to be primarily for convenience.
16:12:49 <dfeuer> Most of the detailed manipulation of TypeReps is for things like error messages.
16:12:59 <glguy> EvilMachine: What's the operation you're trying to implement?
16:13:08 <dfeuer> These days.
16:13:34 <EvilMachine> dfeuer: eqT can not be found by Hoogle
16:13:47 <dfeuer> In 8.2, hopefully, a TypeRep will be very GADT-like, allowing you to reveal information about a type by pattern matching.
16:13:56 <dfeuer> EvilMachine, it's in Data.Typeable....
16:14:03 <dfeuer> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Typeable.html
16:14:26 <dfeuer> The Hoogle on haskell.org has been somewhat limited for a while. Use the FPComplete version.
16:14:28 <EvilMachine> dfeuer: Ah, right, :)
16:14:48 <dfeuer> glguy, do you know how the Typeable remake is going?
16:14:54 <glguy> nope
16:15:06 <mpickering> It exists on a branch, what else do you want to know?
16:15:17 <athan> Does anyone here know how to force a deep rebuild of a package (in stack)?
16:15:43 <dfeuer> mpickering, mostly whether it's pretty much ready to go or whether there's a risk that it'll be bogged down in more discussion till 8.4 or whatever.
16:16:13 <EvilMachine> dfeuer: currently I just used case cast x of { Just (SomeConstructor y) -> f y; Nothing -> g . fromGenericSomething . toGenericSomething x }
16:16:24 * dfeuer looks forward to a Typeable that's actually fun to play with.
16:16:45 <EvilMachine> dfeuer: But that isn’t generic enough. I need SomeConstructor to be passed as a parameter. (I might use TH.)
16:17:18 <dfeuer> EvilMachine, passing a constructor doesn't let you deconstruct. What are you *actually* trying to do?
16:17:22 <mpickering> dfeuer: You can read here, it is up to date from what I can see
16:17:23 <mpickering> https://ghc.haskell.org/trac/ghc/wiki/Typeable
16:17:36 <dfeuer> Thanks, mpickering.
16:17:48 <maks_> any takers on http://lpaste.net/165849 ? I'm wondering if the memory usage can be improved there
16:20:05 * EvilMachine strangles anyone who uses that mind-cancerous “what are you *actually* trying to do” harassment meme for stupidity and being a bully.
16:20:21 <sm> athan: stack clean ?
16:20:22 * EvilMachine blocked dfeuer.
16:20:32 <jmcarthur> ?
16:20:59 <dfeuer> I guess he got annoyed that I asked him exactly what he was trying to do when he was asking for help and being too vague about what he wanted.
16:21:36 <dfeuer> *shrug*
16:21:44 <dfeuer> I have no need to help angry people.
16:22:09 <maks_> dfeuer: it's ok, maybe now you can help *me*
16:22:26 <dfeuer> maks_, I'll take a glance. I *should* be leaving, however.
16:22:58 <maks_> dfeuer: ok I just mostly want to know if i'm doing something obviously sub-optimal
16:23:12 <dfeuer> mpickering, oh, good, it does look like there's been real progress on the Typeable front (another paper, etc.)! The development was somewhat private for a time as things were being worked out.
16:24:25 <dfeuer> maks_, well, I'm not very happy about that zip.
16:24:36 <dfeuer> That doesn't make it wrong,  mind you.
16:24:48 <maks_> dfeur: ok I'll get rid of it and see what happens
16:25:44 <dfeuer> maks_, depending on how large the directories are, you *may* need to restructure. How big are they?
16:26:07 <maks_> dfeuer: it seems to block when the directory contains a very large file
16:26:44 <maks_> dfeuer: but seems to work fast on a directory containing many small files (essentially as fast as md5sum in that scenario)
16:26:44 <dfeuer> My discomfort with the zip is mostly just because you *know* that the vectors involved have the same length, but that information has been "lost" to the Haskell logic. There may or may not be a *good* way to fix that here; dunno.
16:27:12 <dfeuer> Oh wait, there's a bigger problem.
16:27:18 <dfeuer> Eeef.
16:27:23 <dfeuer> Yeah, you need to redo something.
16:27:34 <dfeuer> That "doesFileExist" looks like a real bad plan.
16:27:42 <maks_> dfeuer: oh
16:28:09 <maks_> dfeuer: is it because I filter on a list?
16:28:47 <dfeuer> maks_, the usual rule for this sort of thing: NEVER ask if you can do something; try it and see if it succeeds. Someone else could delete the file between the time you make the list and the time you use it!
16:29:34 <dfeuer> You can't know how many files you'll actually process till you've processed them all.
16:30:10 <maks_> dfeuer: agreed for these two points
16:30:13 <dfeuer> You want to step through the file list, reading the files (dealing with exceptions if the reads fail) and then see what you got. 
16:30:56 <dfeuer> It's also possible the file's there but you don't have permission, etc., etc. You shouldn't worry about *why* the read fails unless you need that for your exception handler.
16:31:04 <dfeuer> *in your exception handler.
16:31:14 <hjljo> dfeuer: do you know how to open a file for writing as long as it doesn't exist in a nice cross-platform way in haskell?  because i've had a similar moral dilemma
16:31:14 <maks_> dfeuer: ok but let's suppose i get rid of the doesFileExist, and can guarantee you everything is fine
16:31:24 <maks_> dfeuer: i'm more concerned about the memory usage
16:31:37 <maks_> dfeuer: since the md5sum seems to have a constant *memory use*
16:31:46 <maks_> dfeuer: compared to haskell which needs more memory for bigger files
16:31:50 <dfeuer> hjljo, I think you just use withFile wrapped in an exception handler, but I'm not an expert!
16:32:16 <dfeuer> maks_, oh, yeah, I see the problem you mean. 
16:32:19 <athan> sm!! Thank you!
16:32:54 <dfeuer> maks_, if the hashing library supports it, you can switch from Data.ByteString to Data.ByteString.lazy.
16:33:19 <maks_> dfeuer: aha!
16:33:25 <dfeuer> Oh, and ....
16:33:37 <dfeuer> V.mapM readFile is definitely not what you want.
16:33:45 <dfeuer> You could run out of file descriptors, I think.
16:34:06 <dfeuer> Yeah, I'm being slow to understand the code and why it's wrong.
16:34:12 <dfeuer> Not being intentionally obtuse.
16:35:20 <maks_> dfeuer: definitely switching to the lazy bytestrings sounds like a good idea!
16:35:29 <dfeuer> maks_, I'd start by setting up an "abstraction barrier" with a function that takes a file handle and returns IO (Hash)  (or whatever the hash type is called)
16:35:42 <hjljo> dfeuer: as far as i can tell withFile will let me truncate or append to a currently existing file OR write to a knew one without letting me tell the difference... which is useless :(
16:35:46 <dfeuer> ER ... maybe that's even wrong.
16:35:57 <hjljo> new rather than knew
16:36:02 <maks_> dfeuer: yeah there is a hashlazy version ... I'll try that and see what happens
16:36:14 <dfeuer> maks_, make it take a file path and give you IO(Hash)
16:36:32 <dfeuer> Because you definitely, definitely don't want to open all the files at once.
16:36:36 <maks_> dfeuer: ok
16:36:38 <dfeuer> You want only *one* file open at a time.
16:36:59 <maks_> dfeuer: so one thing I was confused about, I thought that laziness will prevent from opening all the files at once?
16:37:11 <monochrom> but V.mapM is not lazy
16:37:18 <dfeuer> withFile the thing, getting and evaluating the hash.
16:37:38 <monochrom> at least, not when the monad is IO
16:37:59 <dfeuer> monochrom, maks_, I'm not 100% sure if readFile will actually open the file before returning.
16:38:02 <maks_> dfeuer: ah!
16:38:18 <monochrom> "Haskell is lazy" is a myth that's 30% wrong if no IO is involved, 99.99999% wrong when IO is involved
16:38:20 <dfeuer> Or if it will lazily delay that (even worse!) making the file access time totally unpredictable.
16:38:37 <maks_> dfeuer: so mapM becomes strict when IO is involved?
16:38:43 <monochrom> it opens the file here-and-now.
16:38:53 <hjljo> honestly how often do you want to either overwrite/append to a file or write a new one without caring about the difference :(
16:38:56 <dfeuer> mapM is (almost) always strict.
16:39:07 <dfeuer> in something, anyway.
16:39:17 <monochrom> just try mapM_ readFile (repeat "/dev/null") and wait for file descriptor exhaustion
16:39:35 <monochrom> and it's even mapM_
16:40:03 <maks_> so is there a lazy analogue of mapM ?
16:40:12 <dfeuer> monochrom, yup, you're totally right!
16:40:42 <dfeuer> maks_, no, yes, sort of. Sorry that's not helpful. There are LOTS. pipes, conduits, machines, "ListT done right"....
16:40:43 <monochrom> there are two
16:40:58 <dfeuer> Which aren't really lazy.
16:41:04 <monochrom> one is when the monad involved is lazy in some sense, e.g., Control.Monad.State.Lazy
16:41:04 <maks_> dfeuer, oh, but it's nothing trivial?
16:41:09 <dfeuer> But they are good at "lazy-style" programming.
16:41:14 <monochrom> the other is when you use unsafeInterleaveIO
16:41:23 <dfeuer> Do not use unsafeInterleaveIO.
16:41:32 <monochrom> my recommendation is: give up
16:42:12 <dfeuer> monochrom, I still need to put together a package with int-e's implementation of IO with lazy ST semantics. Which is pretty cool, if perhaps impractical.
16:42:26 <maks_> interesting so after changing to lazy ByteString, and lazy hash, the program is basically as fast as C
16:42:43 <dfeuer> maks_, for this porpoise, you are likely better off doing it by hand than trying to use a fancy library.
16:42:47 <maks_> but still uses a lot of memory, I'm changing now to the one descriptor, one hash version suggested by dfeuer
16:42:54 <thimoteus> hehe porpoise
16:43:11 <maks_> dfeuer: you mean implementing the md5 hash?
16:43:17 <monochrom> lazy ST is very hard to understand
16:44:08 <dfeuer> maks_, I meant looping through the files by hand, but actually that's not necessary as long as you mapM *the right thing*.
16:44:18 * hackagebot pipes-extras 1.0.4 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.4 (GabrielGonzalez)
16:44:40 <dfeuer> It won't start causing you trouble with the one-file-at-a-time approach till the directory gets very large, I don't think.
16:44:59 <maks_> dfeuer: aha, trying this now
16:45:00 <dfeuer> Too large to worry about, I suspect.
16:45:04 <bitemyapp> dfeuer: howdy :)
16:45:08 <dfeuer> bitemyapp, HALLO.
16:45:22 <dfeuer> WHY AM I STILL HERE? I NEED TO GO.
16:45:43 <monochrom> because you haven't been demanded yet
16:45:53 <maks_> dfeuer: ok sorry for keeping you around
16:46:01 <dfeuer> maks_, not your fault.
16:46:06 <dfeuer> I'm bad at transitions.
16:47:52 <bitemyapp> dfeuer: nice seeing you :)
16:47:58 <bitemyapp> dfeuer: escape while you still can!
16:49:01 <dfeuer> jmcarthur, one more idea that may not make sense: what about building up something like the *right* half of a finger tree  RightHalf a = EmptyR | SingleR a | DeepR !(RightHalf (Node a)) !(Digit a)   by snoccing, and then stretching the left side out from the bottom?
16:49:18 * hackagebot morte 1.6.1 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.1 (GabrielGonzalez)
16:52:45 <maks_> thanks guys
16:52:52 <maks_> dfeuer: your suggestion worked wonders
17:08:19 <Cortland> hello all
17:09:47 <Iceland_jack> Welcome Cortland 
17:12:21 <Cortland> hmm, can anyone help me with an lpaste? Just a simple thing
17:12:43 <Cortland> curious how id approach something more..."haskell like"
17:12:44 <Cortland> http://lpaste.net/165853
17:13:20 <glguy> :t any
17:13:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:13:22 <glguy> :t isPrefixOf
17:13:24 <lambdabot> Eq a => [a] -> [a] -> Bool
17:13:30 <glguy> Cortland: both of those could come in handy
17:14:04 <kadoban> I thought credit card numbers were distinguished by checksums, not prefixes.
17:14:19 <Cortland> gah damn that makes sense
17:15:14 <shachaf> Distinguished by checksums?
17:15:24 <shachaf> I think they're checksummed by checksums.
17:15:40 <kadoban> Yeah that was ambiguously stated. I thought the way to check what company a CC is by is by the checksum system used.
17:16:23 <shachaf> I don't think that's true.
17:18:10 <athan> Is there a version of cereal / safecopy that uses Hashable and Eq rather than Ord for deriving instances?
17:23:22 <lpaste> athan annotated “Credit Card Algorithm” with “Credit Card Algorithm (annotation)” at http://lpaste.net/165853#a165856
17:23:49 <athan> :x
17:23:54 <athan> I didn't mean to I promise
17:24:27 <Cortland> wtf is n after the of
17:24:32 <Cortland> I've never even seen that before
17:25:59 <athan> You mean the guard?
17:26:01 <hpc> kadoban: can also confirm, the prefix determines the company, the last digit is a checksum, and the algorithm is the same for everyone
17:26:16 * hpc has done an unpleasantly non-zero amount of credit card handling in his time
17:36:59 <lpaste> dibblego annotated “Credit Card Algorithm” with “Credit Card Algorithm (annotation)” at http://lpaste.net/165853#a165857
17:38:25 <kadoban> hpc: Huh, interesting. I guess I remembered wrong.
17:42:44 <hodapp> hummmm. I wish I could figure out how to label my axes in the Chart package
17:42:57 <hodapp> their examples have legends for the dataset itself, but none of them label the axes :|
17:55:05 <Cortland> yeah showing who has joined, etc is annoying
18:00:06 <glguy> Cortland: That's why when I made my client I collect all the joins and parts together as they occurred http://imgur.com/6EabfHl
18:00:29 <glguy> (or it can be toggled away by pressing F4)
18:00:43 <hodapp> oh, here we go, lenses... layout_x_axis . laxis_title .= "λ" and such
18:00:51 <hodapp> one of these days(tm) I need to learn lenses.
18:01:46 <lpaste> athan pasted “Strange stack error” at http://lpaste.net/165860
18:01:58 <athan> Has anyone here seen this issue before?
18:02:23 <lpaste> athan revised “Strange stack error”: “Strange stack error” at http://lpaste.net/165860
18:03:04 <kadoban> athan: I don't think I understand. It looks like you have warnings and it's failing because of -Werror ?
18:03:20 <athan> Right? All it gives me is that <no location info> doodad
18:03:51 <athan> this is on the latest version of stack also, upgraded with `stack upgrade`
18:03:53 <kadoban> athan: Well … the reason why is the warnings above.
18:04:28 <athan> ? Oh! -Werror forces it to stop? That makes sense
18:04:37 <glguy> Werror says warnings are errors
18:04:39 <kadoban> Yeah, that's what it's for "if I have warnings, treat it as an error"
18:05:43 <Squarism> how can one search a list::[a] of arbitrary properties in elements of list. i.e. not just one Ord a
18:05:49 <Squarism> eh.. wrong
18:05:54 <Squarism> SORT i meant
18:06:11 <Cortland> f4 didnt work also
18:06:29 <kadoban> Squarism: I don't understand the question. You have a list and want to sort it?
18:06:44 <Squarism> kadoban, yes. 
18:07:01 <kadoban> :t sort
18:07:02 <lambdabot> Ord a => [a] -> [a]
18:07:05 <kadoban> > sort [5,2,1]
18:07:07 <lambdabot>  [1,2,5]
18:07:10 <Squarism> kadoban, but not define one single ordering for the type in list
18:07:30 <athan> herp, sorry my mistake. Thanks kadoban and glguy!
18:07:38 <kadoban> You want to sort by multiple keys or something then?
18:07:43 <kadoban> athan: Anytime
18:07:59 <Squarism> kadoban, i might want to sort using (fld2 ( fld 1 a)) 
18:08:08 <Squarism> fld1
18:08:29 <kadoban> Squarism: Can you put in English what you're trying to do? I don't understand that notation.
18:09:00 <geekosaur> :t sortBy
18:09:01 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
18:09:10 <geekosaur> commonly used with
18:09:10 <Squarism> geekosaur, thanks!
18:09:12 <geekosaur> :t comparing
18:09:13 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
18:10:18 <Squarism> kadoban, sorry for that. Its sortBy i need
18:10:54 <kadoban> Oh I see
18:12:32 <Iceland_jack> :t sortOn
18:12:33 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
18:14:02 <Iceland_jack>     sortOn f = sortBy (comparing f)
18:15:44 <codebje> Squarism: Ordering is a monoid, so you can compose comparisons with <> or mappend
18:18:37 <Squarism> codebje, like subordering for Ordering.EQ elements?  
18:20:00 <Iceland_jack> Sort on first component, then on second:
18:20:00 <Iceland_jack> > sortBy (comparing fst <> comparing snd) [(1,30), (2,20), (3,10)]
18:20:03 <lambdabot>  [(1,30),(2,20),(3,10)]
18:20:11 <Iceland_jack> Sort on second component, then on first:
18:20:11 <Iceland_jack> > sortBy (comparing snd <> comparing fst) [(1,30), (2,20), (3,10)]
18:20:13 <lambdabot>  [(3,10),(2,20),(1,30)]
18:20:19 <Squarism> ok.. like sql : select ... order by monoid1, monoid2..
18:20:36 <athan> Would the hackage guys hate me if I pinged `/package/:package/preferred` for _every_ package, roughly once per day?
18:20:55 <athan> From what I've seen, there's no other way to get an exhaustive list of every package's versions :\
18:21:44 <Squarism> thanks, codebje Iceland_jack - ill use that
18:21:57 <Iceland_jack> Squarism: (comparing fst <> ...) may seem odd
18:22:05 <Iceland_jack> since the type of
18:22:06 <Iceland_jack> :t comparing fst
18:22:07 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
18:22:08 <Iceland_jack> Is a function
18:22:20 <Iceland_jack> :t (<>)
18:22:21 <lambdabot> Monoid m => m -> m -> m
18:22:33 <Iceland_jack> :t (<>) :: Monoid m => (a -> m) -> (a -> m) -> (a -> m)
18:22:34 <lambdabot> Monoid m => (a -> m) -> (a -> m) -> a -> m
18:22:45 <Iceland_jack> :t (<>) :: Monoid m => (a -> b -> m) -> (a -> b -> m) -> (a -> b -> m)
18:22:46 <lambdabot> Monoid m => (a -> b -> m) -> (a -> b -> m) -> a -> b -> m
18:23:00 <Iceland_jack> If this doesn't help, ignore :)
18:23:15 <Iceland_jack> :t (<>) `asAppliedTo` compare
18:23:16 <lambdabot> Ord a => (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
18:23:26 <Squarism> i think ill get it
18:23:30 <Iceland_jack> Cool
18:23:45 <Iceland_jack> For completeness and maximum confusion
18:23:45 <Iceland_jack> :t (<>) `asAppliedTo` comparing fst
18:23:46 <lambdabot> Ord a => ((a, b) -> (a, b) -> Ordering) -> ((a, b) -> (a, b) -> Ordering) -> (a, b) -> (a, b) -> Ordering
18:25:01 <Squarism> i might need to glare some on these signatures but then it will prolly work out 
18:25:54 <Squarism> ive accepted monads, monoids next!
18:27:52 <Iceland_jack> Monoids are very simple :) what complicated about the above is the Monoid *instance*
18:27:52 <Iceland_jack>     instance Monoid m => Monoid (a -> m) where
18:27:52 <Iceland_jack>        mempty :: a -> m
18:27:53 <Iceland_jack>        mempty _ = mempty
18:27:57 <Iceland_jack>        mappend :: (a -> m) -> (a -> m) -> (a -> m)
18:28:01 <Iceland_jack>        (mappend f g) a = mappend (f a) (g a)
18:57:38 <paracompact> Can anybody tell me why these two implementations for Cartesian list product differ so much in performance? http://lpaste.net/165862
18:59:46 <Ohso_> How do I create the instance asked for in the following error? I'm trying to use an array with elements consiting of a newtype:  http://pastebin.com/UAMKHPtK
19:00:15 <Squarism> there is no Tuple3? is it composed of 2 tuples?
19:00:28 <Squarism> (a,b,c) i mean
19:00:29 <dibblego> Squarism: (,,) tuples are different (better) in haskell than in scala
19:01:01 <dibblego> > (1, '2', "3")
19:01:03 <lambdabot>  (1,'2',"3")
19:01:09 <dibblego> @type (,,)
19:01:10 <lambdabot> a -> b -> c -> (a, b, c)
19:01:27 <dibblego> and then, all haskell functions take one argument (always, there are no exceptions to this rule)
19:01:27 <Squarism> ok.. so to access 3rd element i do : snd ( snd myTuple) ?
19:01:31 <dibblego> use lens
19:01:33 <dibblego> @type _3
19:01:34 <lambdabot> (Functor f, Field3 s t a b) => (a -> f b) -> s -> f t
19:02:00 <dibblego> fst, snd are specific to (,) and will not work for (,,)
19:02:13 <Squarism> ok
19:02:48 <Squarism> starting with lenses now would stop momentum though =D
19:03:25 <dibblego> so put the question aside for now
19:07:34 <athan> is HashSet nice for doing setwise difference?
19:12:02 <monochrom> I don't know. Does the doc say something?
19:15:29 <athan> sorry monochrom I should have checked, thanks
19:16:49 <monochrom> No worries.
19:25:14 <athan> monochrom: Are you familiar with the space consumption of unordered containers vs. ordered by chance?
19:25:47 <athan> I'm just wondering what advantage hashability might have over ordering
19:26:12 <athan> (besides the obvious utility tradeoff)
19:28:50 <begriffs> What's the best library to work symbolically with polynomials of multiple variables? I'd like to add and multiply them, like (a + bx)*(c + dy) = ac + ady + bcx + bdxy
19:41:25 <drostie> begriffs: hard to say, for simple things I would always just use the mathomatic program. There's also SageMath which might help. Not sure what Haskell has to offer.
19:45:47 <EvanR> athan: hashmaps are used in e.g. aeson objects because you probably have short strings
19:46:59 <EvanR> to image why this might matter, compare a balanced binary tree which has to compare two strings at each node, vs a trie which only has to compare one bit or byte at each node (of the hash... so there is the real cost)
19:47:40 <EvanR> if the hash is cheap i.e. short strings, it might win
19:53:16 <begriffs> drostie: good call, I'll check sage out
20:02:07 <athan> EvanR: Dang... that's awesome, thank you!
20:15:18 <athan> When using acid-state in development, how should I _not_ save any checkpoints?
20:15:49 <athan> I see `Data.Acid.Memory.openMemoryState`, but I'm not sure what I should use in the other branch in `bracket`, if that makes sense
20:17:58 <athan> hm, even using `openMemoryState` alone without bracketing still saves a checkpoint
20:18:28 <athan> and the Pure versions are completely different types, so it's not really a drop-in replacement :\
20:19:01 <EvanR> whats wrong with checkpoints
20:19:05 <athan> wait wait wait, I think I'm being silly
20:19:20 <athan> EvanR: For "development mode", I wouldn't want to save the data
20:19:43 <EvanR> then you dont want to avoid checkpoints
20:19:54 <EvanR> you want to stop logging
20:20:08 <EvanR> i believe there is a memory-only backend
20:20:25 <athan> :s hmm, okay
20:21:39 <athan> yeah I was just mistaken, openMemoryState is working fine :)
20:21:42 <EvanR> https://hackage.haskell.org/package/acid-state-0.14.1/docs/Data-Acid-Memory-Pure.html
20:21:43 <athan> thanks EvanR
20:21:55 <athan> EvanR: That uses different AcidState types though :\
20:22:14 <athan> compared to the storable version
20:22:28 <sysRPL> hello
20:22:50 <sysRPL> regarding recent events ...
20:23:05 <sysRPL> i'm from central florida and have started a campaign -> http://cache.codebot.org/images/sticker-small.png
20:23:22 <EvanR> athan: looks like the API is identical, except the one that takes a filename... maybe its just changing the import
20:23:56 <Hijiri> it's a political ad
20:24:07 <sysRPL> it is?
20:25:35 <sysRPL> i wrote the svg program generator for it 
20:25:38 <athan> EvanR: Yeah, but that would mean my application would need to be parametric for some higher-kinded database effect type, I'm not sure if I want that
20:25:54 <athan> sysRPL: cmon
20:25:59 <EvanR> no, it would be like changing from lazy map to strict map
20:26:02 <athan> leave that for your personal space
20:26:10 * athan stares at himself *cough*
20:26:40 <athan> EvanR: But I would like both development and production modes optional at runtime, not requiring a rebuild
20:26:51 <koz_> How do you make lambdabot eval some Haskell?
20:27:02 <athan> > 1 + 1
20:27:03 <lambdabot>  2
20:27:05 <athan> :)
20:27:12 --- mode: ChanServ set +o shachaf
20:27:16 --- mode: shachaf set +b *!*sysRPL@*.res.bhn.net
20:27:16 --- kick: sysRPL was kicked by shachaf (sysRPL)
20:27:19 --- mode: shachaf set -o shachaf
20:27:22 <athan> not all haskell, though. IIRC Haskell2010 without extensions
20:27:23 <koz_> athan: Thanks!
20:27:28 <EvanR> athan: test mode and production mode simultaneously? interesting
20:27:33 <athan> and pure, too
20:27:48 <athan> EvanR: Not simutaneously, it's a sum-type flag
20:28:00 <athan> so `fooserver --production` sparks it in production mode :)
20:28:27 <EvanR> theres another option for memory only?
20:28:43 <EvanR> not sure what the point of .Pure is
20:29:33 <athan> EvanR: I think for quickcheck I'm guessing :s
20:54:57 <koz_> I'm trying to install threadscope into a sandbox, and for some reason, glib and cairo failed on me. The logs are less than helpful. Could someone help me out?
20:55:37 <koz_> (I have both Glib and cairo [as in, the C ones] installed on my system)
20:56:52 <koz_> (they failed to install,in case it matters)
21:00:55 <orion> Hi. What are the valid values for HOST_ARCH here?: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/System.Info.html#arch
21:08:00 <Cale> koz_: I'm not sure what the problem might be from that description
21:09:23 <geekosaur> koz_, build log would be helpful. also make sure you have the devel libraries for the gtk stuff installed, not just the runtimes, if you're on a debian-like or rhel/centos/fedora-like system
21:09:30 <koz_> Cale: I'm not too sure either, to be honest. I only have what Cabal told me (which is basically that the install failed and that there's an empty log).
21:09:35 <koz_> geekosaur: I'm on Arch.
21:09:47 <koz_> Where do the build logs live in a sandbox?
21:13:49 <geekosaur> orion, https://github.com/ghc/ghc/blob/master/aclocal.m4#L1835
21:15:14 <geekosaur> hm, I'm not actually sure
21:16:35 <geekosaur> orion, note that not all of those platforms are actually supported (someone in #ghc keeps threatening?/joking about actually adding s390 support...)
21:17:14 <lambda-11235> Is there an upper limit to how many cases an ADT can have?
21:17:43 <koz_> geekosaur: I checked the build logs, but they're *literally* empty files.
21:17:53 <geekosaur> yug
21:18:03 <geekosaur> but you know it failed, so you got *something*?
21:18:50 <lpaste> koz_ pasted “Does this count as 'something'?” at http://lpaste.net/165868
21:20:03 <geekosaur> mrr. that makes me think Setup.hs is failing for them. and I can't think why that would happen except that all the gtk stuff does a lot of extra things.. oh.
21:20:09 <geekosaur> check executable /tmp
21:21:24 <koz_> geekosaur: Sorry, what do you want me to check?
21:22:11 <slack1256> What is the way of storing the order of blogposts on a site?
21:22:22 <slack1256> strictly not haskell, but i am using yesod :-P
21:22:37 <slack1256> should I use the database to store it?
21:23:04 <geekosaur> sigh. am trying to think  this through. traditionally "mount | grep /tmp | grep noexec" would do it, but systemd uses cgroups to play additional games with per-process tmp mappings
21:23:15 <kadoban> slack1256: Store the date+time probably? Usually you need that in a blog anyway.
21:23:53 <geekosaur> and I don't know the details of what systemd is doing or how to check them, offhand
21:24:06 <geekosaur> (I think arch can do systemd...)
21:24:29 * hackagebot language-python 0.5.3 - Parsing and pretty printing of Python code.  https://hackage.haskell.org/package/language-python-0.5.3 (BerniePope)
21:24:30 <koz_> geekosaur: Arch defaults to systemd.
21:24:31 * hackagebot language-python-test 0.5.3 - testing code for the language-python library  https://hackage.haskell.org/package/language-python-test-0.5.3 (BerniePope)
21:24:36 <koz_> OK, no threadscope for me, then...
21:24:39 <slack1256> kadoban: so simple yet I missed it. I was thinking on checking creating time on the hamlet files. 
21:24:45 <slack1256> Will go with this
21:24:47 <koz_> (it's not packaged for Arch and I don't wanna system-wide it)
21:25:42 <geekosaur> koz_, ok, you may need to find out how to override the systemd  stuff because even without noexec I think /tmp ends up being per process instead of per process group by default --- so stuff fails because it's not where it's expected to be, it's in a private temp dir for another process
21:26:34 <koz_> geekosaur: Jeez, that seems really involved. I guess system libs are a pain that way.
21:26:35 <geekosaur> I recall someone running into that a couple months ago and it confusing cabal-install into not producing any logs (possibly because *those* ended up in per-process tmpdirs)
21:27:10 <geekosaur> I mean, the concept is lovely from a security standpoint, but build systems aren't going to expect it...
21:28:25 <Squarism> what IDE/editor do most people use? Theres no clear winner?
21:29:09 <koz_> Squarism: I use Emacs. Dunno about everyone else.
21:29:24 <geekosaur> no clear winner, no. many use vim or emacs with their haskell support. various other editors also have haskell support (atom, sublime text, etc.)
21:29:25 <kadoban> emacs is popular in haskell it seems. I use vim. I usually recommend either one of those two, or atom, sublime, maybe a couple of other decent ones.
21:29:53 <kadoban> (I personally don't rely on a lot of haskell support, because it's a pain in the ass to keep working)
21:30:04 <geekosaur> yeh
21:30:16 <Squarism> oh ok. 
21:30:22 <geekosaur> IDE-type support is perennially in flux. various projects have been started and apparently abandoned
21:30:28 <geekosaur> including at least two from fpcomplete
21:31:03 <glamdring> i've only ever used hackage/statistics for averages before, and never used mwc-random -- i'd like to plot a normal distribution, is there a convenient way to feed in [0...100] and get out the y-values for a normal distribution with mean, say, 30?
21:31:05 <kadoban> I wonder if haskell-ide-engine is making good progress at all
21:31:12 <Squarism> Im from java land so ive gotten used to IDE's for navigation/refactoring/autocomplete/context-info etc 
21:31:22 <koz_> Squarism: Because Java is unworkable otherwise.
21:31:39 <koz_> Since it's verbose as fuck and needs 20,000 lines for what everyone else can do with like, 2.
21:31:44 <Squarism> haha
21:32:30 <Squarism> dont you like getter/setter generation?
21:32:40 <koz_> Squarism: You mean what Lenses can do better?
21:32:41 <Squarism> cmon, you gotta miss that
21:32:44 <Squarism> =D
21:32:46 <koz_> And *don't* require editor support?
21:32:49 <Squarism> just kidding
21:32:50 <koz_> You mean *that* generation? :P
21:34:01 <koz_> geekosaur: Suppose I decided to try and install threadscope globally with Cabal. Is this a Bad Idea (tm)?
21:34:03 <Squarism> Well, as haskell seems so well defined there could be odds for a nice IDE in the future
21:34:20 <koz_> Squarism: In all honesty, I dunno how much more IDE than what you can get with Emacs or Vim you *need*.
21:35:06 <glamdring> is Statistics.Distribution.density what I want maybe?
21:36:10 <geekosaur> lambda-11235, I don't think there is an upper limit. there is a limit beyond which things can get slower (it can store up to I think 7 in pointer tags, beyond that it has to go into the actual constructor tag) but the constructor tag itself is a machine word
21:38:06 <peddie> glamdring: you can just evaluate the PDF of the normal distribution in closed form
21:41:05 <glamdring> peddie: sorry, I'm not sure I follow - I am just starting to study statistics and probability so I am unsure of what you mean. are you saying to translate an analytic expression of the normal distribution into haskell, and feed that a list of x values?
21:41:26 <peddie> yeah
21:41:31 <peddie> https://en.wikipedia.org/wiki/Normal_distribution  
21:42:10 <glamdring> peddie: sorry, I should have made my intention more clear - I want to be able to graph the different distributions available in the statistics and mwc-random package using plotly
21:42:51 <peddie> oh, I see, sorry.  maybe someone else can help you!
21:43:00 <glamdring> which needs pairs of x-y values -- so I am just starting with the normal distribution. I was hoping to leverage the existing code in those packages :)
21:43:19 <glamdring> peddie: thanks!
21:43:48 <lpaste> koz_ pasted “geekosaur: Could this be related to my build troubles?” at http://lpaste.net/165869
21:44:07 <glamdring> peddie: that will at least get me one plot in any case, I didnt even think of doing it :) and I can do the same for other distributions if there's nothing more convenient 
21:44:16 <lambda-11235> geekosaur: Thanks, the machine word was the limit I was thinking of.
21:45:14 <geekosaur> koz_, could be but I'd expect better errors from that normally. also is this ghc8? I think things break oddly if you use ghc8 with an older cabal-install or Cabal library; it must be Cabal-1.24 and cabal-install 1.24
21:45:46 <koz_> geekosaur: It's not GHC8, but it turns out I can upgrade my OS packages to GHC8 and cabal-install-whatever-the-bigger-version-is.
21:46:00 <koz_> I'll give it another whirl post-upgrade.
21:46:20 <geekosaur> lambda-11235, from what I know of ghc you will run into other problems long before you hit 4 billion (and that only on 32 bit!) constructor tags :)
21:46:46 <koz_> Maybe I'll be able to get me some threadscope action!
21:47:11 <koz_> As a complete aside: Is there a master list of 'Good Things GHC8 Will Give You'?
21:48:00 <lambda-11235> geekosaur: Yeah, I was just thinking about how ADTs were layed out in memory, and was wondering how they were tagged.
21:48:09 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0 and http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html
21:48:55 <geekosaur> lambda-11235, machine word for constructor tag, followed by machine words for (usually) boxed values stored with that tag. can be modified by UNPACK pragma and unboxed strict types
21:49:30 * hackagebot means 0.1.0.0 - calculate varieties of mean/average using semigroup.  https://hackage.haskell.org/package/means-0.1.0.0 (winterland)
21:49:42 <geekosaur> but always that constructor tag exists for boxed types
21:50:08 <lambda-11235> geekosaur: That's what I thought. Thanks again.
21:51:57 <glamdring> answering my own question, Statistics.Distribution.density does seem to be what I wanted :) I wish bos was still churning out these impeccable libraries, sigh
22:05:18 <koz_> geekosaur: OK, progress - I now have an actual build failure log!
22:05:58 <lpaste> koz_ pasted “An actual build failure log!” at http://lpaste.net/165870
22:14:31 * hackagebot aivika-lattice 0.1.1 - Nested discrete event simulation module for the Aivika library using lattice  https://hackage.haskell.org/package/aivika-lattice-0.1.1 (DavidSorokin)
22:22:09 <orion> geekosaur: Thanks.
22:33:58 <jgt> haskell noob here
22:34:19 <jgt> can I get a an `a` from an `IO a` without using the slurp operator?
22:36:00 <zRecursive> cv
22:38:13 <bollu> how do I take a project on hackage down? (I own it)
22:40:02 <Cale> jgt: What's the slurp operator?
22:40:46 <jgt> Cale: apparently, it's `<-` inside some `do` notation
22:41:07 <Cale> jgt: The way to get an 'a' from an 'IO a' is to run the action. A value of type 'IO a' is a description of some steps which could be carried out that would produce an 'a' in the end, assuming it terminates normally.
22:41:31 <Cale> There's no 'a' inside there, any more than /bin/ls contains a list of files in your home directory.
22:41:58 <Cale> and yeah, in do-notation, v <- x means "execute the action x, and name whatever its result is v"
22:42:14 <Cale> and the do-block as a whole is then itself an IO action
22:42:30 <Cale> (assuming that x was)
22:42:34 <jgt> I see
22:42:43 <jgt> basically, I have an applicative form in Yesod
22:43:04 <jgt> and I want to say `<*> pure "a-uuid-value"`
22:43:15 <jgt> and that string should actually be a UUID
22:43:47 <jgt> I can get a Text from a UUID with `toText`
22:44:09 <jgt> but to get my uuid value, I need `nextRandom`
22:44:15 <jgt> which is an IO UUID
22:44:56 <jgt> should I create a separate function for running my IO action and returning the value?
22:47:12 <jgt> I know I can do this to get the time, which is also an IO `<*> lift (liftIO getCurrentTime)`
22:52:27 <johnw> shouldn't just "<*> liftIO getCurrentTime" work in this context?
22:53:06 <jgt> johnw: in the docs, they use `<*> lift (liftIO getCurrentTime)`
22:53:13 <johnw> interesting
22:53:30 <jgt> I would have thought the same would work for my UUID
22:54:16 <jgt> if I do `<*> lift (liftIO nextRandom)`, I get 'Couldn't match type ‘UUID’ with ‘Text’\nExpected type: IO Text\n  Actual type: IO UUID'
23:41:08 <lyxia> I guess you must convert UUID to Text
23:49:38 <rfw> if i pass a th splicing function a Name, can i splice the Name? like say i pass ''T, can i insert ''T into the result?
