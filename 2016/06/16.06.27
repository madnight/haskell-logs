00:00:00 <zeitgeist7> i had installed ghc, haskell-platform and others using Homebrew
00:00:21 <zeitgeist7> but now i can no more run cabal install cabal-install
00:00:47 <parsnipM_> haskell-platform has an uninstall i've heard
00:00:52 <zeitgeist7> also in Atom I am having some issues asking me to update ghc-mod
00:01:12 <zeitgeist7> I must have messes up my environment
00:05:32 <Saizan_> zeitgeist7: what error do you get from "cabal install cabal-install"?
00:05:59 <zeitgeist7> cabal: failed to parse output of 'ghc-pkg dump'
00:06:12 <zeitgeist7> been having that since yesterday
00:07:40 * hackagebot spatial-math 0.3.1.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.3.1.0 (GregHorn)
00:07:40 * hackagebot Plot-ho-matic 0.10.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.10.0.0 (GregHorn)
00:08:45 <quchen> zeitgeist7: Can you just reinstall everything?
00:08:58 <quchen> It's hard to tell what's wrong given the information you wrote.
00:09:12 <zeitgeist7> I know sorry for that
00:09:36 <zeitgeist7> the fact is that so much is need  and i do not fully understand all the components
00:09:42 <glguy> If your cabal-install is too old and ghc too new they won't be able to talk
00:10:00 <zeitgeist7> removing the .cabal dir will suffice?
00:10:18 <zeitgeist7> i mean + brew uninstall ghc cabal-install
00:10:39 <zeitgeist7> anything else that i should remove?
00:10:45 <quchen> .ghc
00:10:47 <glguy> What versions of things are you using?
00:11:17 <zeitgeist7> cabal-install version 1.16.0.2
00:11:24 <zeitgeist7> ghc is 8.0.x
00:11:45 <zeitgeist7> but i cannot get cabal-install to upgrade
00:11:45 <quchen> UUh. That's probably the issue. We're at Cabal 1.24.
00:11:54 <zeitgeist7> i know 
00:11:56 <glguy> You need at least cabal install 1.22.? Better 1.24
00:12:03 <glguy> To use ghc 8
00:12:05 <Axman6> yeah cabal 1.24 is necessary for GHC 8.0
00:12:13 <zeitgeist7> but how do i upgrade cabal
00:12:49 <quchen> I don't know Homebrew, but unless you have a good reason to not just remove and reinstall everything, that's what I would do.
00:12:50 <glguy> Might be in homebrew
00:13:01 <zeitgeist7> funny : cabal-install 1.24.0.0_1 already installed
00:13:05 <zeitgeist7> from homebrew
00:13:19 <quchen> Then maybe your $PATH is bad?
00:13:34 <quchen> And you're simply calling the wrong (old) version of cabal?
00:13:50 <Axman6> run `which cabal`
00:13:54 <zeitgeist7> ok how can i see all the version on my system
00:14:09 <urbanslug> Well fwiw I use stack only
00:14:45 <zeitgeist7> which cabal: /usr/local/bin/cabal
00:15:02 <quchen> What does `cabal --version` say?
00:17:00 <zeitgeist7> cabal-install version 1.16.0.2
00:17:56 <quchen> Then I think your $PATH points to the wrong Cabal executable.
00:20:24 <zeitgeist7> yes homebrew tells me that cabal 1.24 is installed and not linked
00:20:58 <quchen> I don't know what "linked" means.
00:22:47 <rydgel> zeitgeist7: it means there is no symbolic link yet for that binary
00:23:03 <zeitgeist7> yes i just made the link
00:25:47 <quchen> And? Does it work now?
00:25:47 <zeitgeist7> i am now able to run cabal install cabal-install
00:26:05 <zeitgeist7> it is downloading the dependencies
00:26:13 <zeitgeist7> with some warnings here and there
00:27:47 <zeitgeist7> do you configure your environment using haskell platform from the website or using homebrew?
00:29:02 <tdammers> zeitgeist7: these days, I'd recommend stack
00:29:27 <zeitgeist7> there are so many tools to get to program in Haskell
00:29:47 <tdammers> it's not as bad as JS, really
00:29:49 <Axman6> stack has become the one tool I use now
00:29:53 <zeitgeist7> is stack the ONE tool that you can get to manage all the dependencies?
00:29:57 <quchen> Yes.
00:30:05 <tdammers> stack is the one tool that ties the ecosystem together in a sane way
00:30:09 <Axman6> pretty much, and it's much less prone to breaking
00:30:15 <quchen> Stack will even get you the right compiler.
00:30:21 <zeitgeist7> ok i will get it
00:30:24 <tdammers> it doesn't replace any of the others, it just ties them together
00:30:27 <hvr> quchen: nope, it doesn't ;)
00:30:36 <zeitgeist7> should i remove everything and restart with stack
00:30:37 <Axman6> tdammers: well, it somewhat replaces cabal-install
00:30:40 <hvr> quchen: there's no guarantee it will pick the right one ;)
00:30:45 <tdammers> Axman6: replaces as in uses
00:30:49 <quchen> hvr: It does for me, always, so far.
00:30:56 <zeitgeist7> or stack will do the right thing
00:31:00 <Axman6> it doesn't use cabal-install afaik, only Cabal the library
00:31:08 <quchen> hvr: When does it not?
00:31:11 <hvr> quchen: sure, because you're on a well supported OS :-)
00:31:14 <tdammers> Axman6: it does sort of replace cabal as a package manager, which it wasn't designed to be in the first place
00:31:25 <hvr> quchen: on less mainstreamy environments
00:31:31 <Axman6> zeitgeist7: I ended up removing everything that wasn't installed by stack, it meant I didn't end up with weird conflicts between old and new stuff
00:31:54 <rydgel> +1 for Stack, solved all my cabal workflow problems
00:31:59 <hvr> quchen: for instance, some of the older SLES distros which are not yet EOL'ed
00:32:08 <zeitgeist7> ok thank
00:32:24 <hvr> quchen: and of course on platforms where you can't even build stack
00:32:34 <zeitgeist7> thank you everyone who helped
00:32:38 <zeitgeist7> you are legends
00:33:01 <quchen> Old tales of half truth? ;-(
00:33:07 <hvr> quchen: and at this rate, Stack will only work on a subset of the platforms where GHC works
00:33:11 <hvr> & cabal-install
00:33:45 <Axman6> I've recently been having several issues with stack, but that's because my employer changed my username, and moving my home dir broke all my paths
00:34:11 <hvr> Axman6: to be fair, that you'd have had w/ cabal-install as well
00:34:12 <quchen> hvr: Right, Stack is a solution for the average use case. For specialized ones I don't know.
00:34:56 <hvr> quchen: yeah, Stack is a good 80/20 solution
00:35:01 <tdammers> for specialized use cases, you need specialized solutions
00:35:03 <Axman6> hvr: yes, it's not a complaint =)
00:35:19 <tdammers> but you can always drop down to doing manually what stack automates for you
00:35:24 <hvr> quchen: I'm just miffed at the notion that Stack was a perfect solution
00:35:36 <hvr> which it definitely is not
00:36:05 <quchen> hvr: Keep in mind that we're trying to sell Haskell to a newcomer here, and instead of being 100% right I'd much rather get a working environment running.
00:36:13 <quchen> But from an advanced perspective you're right of course.
00:36:28 <hvr> sure
00:37:25 <quchen> hvr: Are there many users of Haskell on mainframes?
00:37:55 <hvr> quchen: you mean SLES/RHEL and stuff?
00:38:22 <quchen> For example, yes.
00:38:38 <quchen> "Giant centralized computers"
00:38:52 <hvr> sadly, no idea... those ppl usually operate in the dark
00:39:10 <hvr> you only notice them when they surface to ask for help on some issues
00:39:16 <EvanR> i saw hackers, its very colorful in the mainframe
00:39:21 <quchen> So fixing these problems is mostly speculative then?
00:39:46 <quchen> As in "possibly needed and useful for a mature system", not "someone requested it"
00:40:05 <hvr> quchen: well, so far everywhere my job takes mhe, there's some old RHEL or SLES server I need to make due with
00:40:18 <hvr> which is frustrating on its own
00:40:31 <hvr> as that basically means you get reminded how Linux was 10 years ago
00:40:52 <thimoteus> eww
00:41:12 <quchen> 10 years ago, that was the year of the Linux desktop, right?
00:41:22 <thimoteus> what kernel versions are those?
00:41:24 <hvr> quchen: you mean, decade of the linux desktop :)
00:43:03 <EvanR> it was year of the linux media center
00:43:05 <hvr> thimoteus: https://www.novell.com/support/kb/doc.php?id=3594951
00:43:19 <Squarism> what is the simplest database (ease of use appriciated) one can use for a hobby haskell project running on ubuntu 
00:43:37 <EvanR> an MVar containing your data
00:44:33 <EvanR> if you want a persistent file on disk, sqlite-simple
00:45:07 <tdammers> although one could also extend the MVar-with-your-data-in-it setup with a bit of rigging to persist that MVar to a JSON file or sth
00:45:12 <Squarism> sooner or later ill need it persistent so ill try that
00:45:30 <tdammers> or use sth like Celery for binary serialization
00:45:43 <EvanR> tdammers: er... seems like that would lose on both ease of use and robust
00:45:44 <tdammers> the downside of that being that the serialized data won't be portable
00:45:52 <hvr> tdammers: Celery?
00:46:01 <tdammers> sorry, Cereal
00:46:09 <tdammers> weirdly confused
00:46:17 <EvanR> i wish there was something simpler than that and simpler than sqlite
00:46:21 <hvr> Celery would be a nice name for a Cereal successor :))
00:46:32 <tdammers> "lighter than cereal, and healthier!"
00:46:46 * quchen is still waiting for Duncan's CBOR
00:46:55 <hvr> quchen: we all are :(
00:47:02 <thimoteus> hvr: ahh good ol' 2.6.32
00:47:22 <quchen> s/good //
00:47:26 <EvanR> Squarism: well your question has got me thinking on how the heck to invent your answer
00:47:35 * hackagebot yesod-core 1.4.22 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.22 (MichaelSnoyman)
00:47:37 * hackagebot yesod-auth 1.4.13.3 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13.3 (MichaelSnoyman)
00:47:41 <hvr> quchen: I keep watching https://github.com/well-typed/binary-serialise-cbor
00:47:49 * EvanR wonders about haskelldb
00:47:50 <Squarism> EvanR, =D
00:48:59 <hvr> quchen: there's a 0.2 milestone which seems to collect the TODOs  for the initial rls
00:49:38 <tdammers> anyway, I believe deriving JSON instances, persisting your data to a JSON file on updates, and loading it back in on startup, is hardly more difficult to write than marshalling between a relational DB and Haskell types
00:49:55 <EvanR> tdammers: -simple libs do that for you
00:50:09 <EvanR> and also writing a json file isnt necessarily safe
00:50:36 <EvanR> its a classic "oh... i dont know wtf im doing, my data is corrupted" situation
00:50:48 <tdammers> hehe well, yeah
00:51:10 <Axman6> acid-state is a very cool alternative to a database with ACID guarantees
00:51:11 <tdammers> safe concurrency is a welcome feature of RDBMS'
00:51:26 <EvanR> acid-state is cool, also not "simple"
00:51:48 <Axman6> it's just as simple as a RDBMS if you've never used a RDBMS =)
00:51:50 <EvanR> i would go with acid-state for what Squarism is asking for
00:51:56 <Axman6> and a lot harder to get wrong
00:52:08 <hvr> rotfl @ https://github.com/well-typed/binary-serialise-cbor/blob/master/scripts/dragon-bureaucrat.sh
00:52:23 <EvanR> but to answer Squarism's actual question, i dont think it exists
00:53:02 <Axman6> hvr: I have a feeling that might have been written after Austin's talk where he grepped for the US spelling and realised he'd made a terrible mistake
00:53:11 <Mossa_Mossa> 1400 people, wow.
00:53:25 <Mossa_Mossa> What is a good method for leaving messages and information on a NAS without using Source control like Git?
00:53:53 <Axman6> Mossa_Mossa: does that have anything to do with Haskell?
00:54:18 <Mossa_Mossa> It's a general question. Sadly: no.
00:55:02 <Axman6> you might have better luck in a more appropriate channel such as #linux, or which ever OS you're using
00:55:39 <Mossa_Mossa> It's a general question. Someone said this channel was polite so I came here.
00:55:46 <Squarism> EvanR, glancing through RWH it atleast looks simple to use sql. http://book.realworldhaskell.org/read/using-databases.html
00:56:07 <Mossa_Mossa> Thank you for your time.
00:56:50 <EvanR> Squarism: sqlite-simple mysql-simple and postgres-simple are libs i support for sql... its just that its sql
00:57:01 <Axman6> RWH is quite out of date, things have progressed a lot since then
00:57:21 <Axman6> sqlite-simple is definitely a good choice if things aren't going to get too complex
00:57:28 <EvanR> sql = "really, this is how advanced we are still"
00:57:58 <EvanR> the only widespread alternatives to come out are just even worse
00:58:02 <Squarism> EvanR, yeah, its getting pretty dated =D
00:59:30 <EvanR> Squarism: btw what kind of data are you storing
01:00:28 <Squarism> EvanR, Now.. very simple game setup. And soon game logs - to recreate state.  
01:01:22 <Squarism> Axman6, never tried a sqlite client. Are it/they good? 
01:02:08 <Squarism> ...of stdio flavor
01:02:59 <EvanR> its incredibly simple
01:03:15 <EvanR> relative to mysql and postgres
01:03:27 <Axman6> SQLite is interesting, it's worth knowing its limitations before using it though. one sec and I'll see if I can find something for you
01:03:44 <Squarism> sounds good to know
01:05:59 <oish> I'm using servant-client to write to firebase. Is there a way to append ".json" to the URI that my client requests?
01:06:04 <Axman6> Squarism: https://news.ycombinator.com/item?id=11934826 has a lot of discussion of the limitations of SQLite. Most of them aren't big issues, but a bit odd, like you can't drop a column from a table without creating a temp table, copying everything, dropping the original and renaming
01:06:31 <EvanR> similarly you cant reorder columns in postgres
01:07:12 <Squarism> Axman6, ugh.. thats personality
01:07:39 <EvanR> this is haskell, we like immutable stuff, including the whole design right!
01:09:23 <Squarism> ok.. ill just consider it pure or something then
01:10:02 <Axman6> it's append only, so old code won't break (except code using SELECT *)
01:10:09 <rydgel> Can Haskell do fully static binary?
01:10:34 <rydgel> I don't want to install GDAL on my servers if I can
01:10:38 <srhb> rydgel: It's a compiler and linker thing, and yes.
01:10:41 <srhb> rydgel: GDAL?
01:10:53 <rydgel> srhb: yeah
01:11:00 <rydgel> I'm using it
01:11:09 <srhb> rydgel: Oh, a library.
01:11:22 <rydgel> srhb: yup for Geolocation stuff
01:11:57 <srhb> rydgel: You basically want ghc -static -optl-static
01:12:21 <srhb> rydgel: The first static being for statically linking against other Haskell libraries, the second for the system linker to do the same to foreign ones.
01:14:40 <Axman6> is here a GDAL library? I use GDAL all the time and never even thought to look, because I thought the geospatial and Haskell intersection would be so small =)
01:15:05 <rydgel> Axman6: I had a hard time to find one
01:15:28 <Axman6> I considered briefly rewriting PROJ4 in Haskell, then realised that was madness
01:15:31 <rydgel> Axman6: but I found `bindings-gdal` on Github and it's working pretty nicely so far (for what I'm doing)
01:15:41 <Axman6> possibly doable, but the benefits would likely be low
01:15:42 <adarqui> getting better at haskell is the best feeling in life
01:17:28 <rydgel> Axman6: I need a webservice for my company. Basically I send latitude/longitude and it gives me back the country/region/state and timezone
01:18:26 <rydgel> working nicely so far. Using GDAL and Spock for the http part. Now I just need to figure out deployment and stuff
01:18:32 <Axman6> I've written very similar things - ours extracts a timeseries of data from a NetCDF file
01:19:00 <Axman6> Haskell stuff tends to be pretty easy to deploy, especially if you have managed to statically link everything
01:19:26 <Habib> has anyone got any experience with the plugin package on Hackage?
01:19:36 <Axman6> we just make sure we build on the same OS and install all the deps
01:19:50 <Habib> I'm trying to dynamically load a Haskell file to get at a function at runtime.
01:20:03 <rydgel> Axman6: I don't have a lot of experience in this subject, and so far I can't build a fully static binary in OS X so I'll to fire up a linux VM to try that
01:20:24 <Habib> I manage to compile it, but loading the object file fails with a message like `phasmatys: Prelude.undefined`
01:20:37 <Habib> phasmatys is the name of the program
01:20:37 <Axman6> yeah it'll be easier on linux I think, OS X is pretty dylib heavy
01:20:49 <Axman6> we just build things in vagrant, but you can also use stack --docker build
01:21:20 <srhb> Habib: PErhaps you can provide a minimal example of the problem?
01:21:24 <Axman6> Habib: how helpful, I feel for you :(
01:21:45 <rydgel> Axman6: I fired up a vagrant VM yeah
01:21:47 <EvanR> Habib: that error could mean anything
01:21:53 <EvanR> unfortunately
01:21:54 <Habib> srhb: coming up
01:22:01 <rydgel> didn't had time to learn docker tho, it's on my todolist
01:22:14 <Habib> yeah, as far as I understand it, as soon as undefined is evaluated, it's boomtime, right?
01:22:31 <EvanR> if youre lucky its boom time
01:22:36 <Habib> but what I'm confused about is that my program name is prefixed before the message; does that usually happen?
01:22:40 <EvanR> if youre less lucky its freeze time
01:22:52 <Habib> hmm
01:23:10 <EvanR> yes it does
01:23:20 <Habib> okay, fair enough.
01:23:50 <rydgel> Habib: are you using undefined in your code by any chance?
01:24:07 <Habib> I don't directly use it anywhere in my code
01:24:30 <EvanR> +RTS -xc may give you an indication of where the undefined is coming from
01:24:46 <Habib> cool, thanks for letting me know
01:24:48 <EvanR> but you might need to have all your libraries built with profiling
01:24:49 <Axman6> rydgel: stack makes it pretty trivial, you just install the docker tools for OS X, and then run stack --docker build instead of stack build
01:24:58 <EvanR> if its coming from a library
01:25:54 <rydgel> Axman6: I should configure the Linux OS I need etc. prior to that right?
01:27:02 <Axman6> not necessarilly, though since you need gdal there's some extra steps which I don't remember, but it could be as simple as adding the deps to your stack.yaml
01:27:23 <Axman6> basically stack takes care of setting up all the docker stuff once docker is installed
01:27:44 <rydgel> great
01:28:09 <rydgel> yeah I should probably tell him to do a `apt-get install gdal` or something similar
01:28:24 <Axman6> then you can do things like stack --docker exec foo and it shoudl run it inside the container
01:28:56 <srhb> Habib: By the way, iirc, that is the error you will see if the object file you're trying to load is missing.
01:29:43 <Habib> It's definitely not missing. I use getDirectoryContents to make sure the file is there. I pass in the directory with the file in to the load command.
01:30:14 <Axman6> rydgel: take a look at http://docs.haskellstack.org/en/stable/docker_integration/#derivative-image (and the rest of the page, but that tells you how to add deps)
01:30:27 <rydgel> Axman6: Thank you dude
01:31:33 <Habib> how can i pull in hackage packages for a simple example project without pulling in all the cabal/stack stuff?
01:32:00 <srhb> Habib: "pull in" ? 
01:32:23 <Habib> Yeah, I can't import the plugins package for a minimal example
01:32:28 <Axman6> you can download them from hackage... but that's more pain than it's worth. just use stack and be hapy
01:32:45 <srhb> Habib: Injecting these into the package db without cabal is rather painful.
01:32:58 <Habib> Cool, I'll just use stack, then.
01:37:35 <srhb> Habib: Well, I got load_'ing a single Int working at least. It seems the -dynamic flag is necessary
01:38:14 <Habib> you mean as a flag in the [Arg] argument?
01:38:35 <srhb> Habib: No, as a flag to ghc
01:38:43 <Habib> ah
01:38:53 <Habib> thanks, let me try that.
01:46:12 <Habib> That doesn't seem to work either. I added -dynamic to ghc-options in the cabal file. I made sure the ghc-options field was working by testing -Wall first, expecting to see warnings, which I did. Changing to -dynamic and recompiling and retesting still results in the `undefined` error message.
01:48:02 <chreekat> What does ghci enable that ghc doesn't, such that I had a error about a "rigid, skolem" type variable that didn't present itself until I switched from the former to the latter?
01:48:24 * chreekat googles "skolem" for the umpteenth time
01:51:32 <quchen> GHCi has extended defaulting, maybe it has something to do with that?
01:52:03 <srhb> I wonder, is plugins what they use at Facebook for dynamically loading their Haxl stuff?
01:52:43 <Habib> srhb: minimal example at https://github.com/habibalamin/hsplugins
01:53:52 <Habib> I recall that it's made by a prolific and competent Haskeller, the same guy who made Yi, xmonad, and others
01:54:14 <Axman6> Habib: you probably need more type annotations
01:54:25 <Axman6> Don Stewart
01:54:45 <Habib> Axman6: where specifically do I fall short on type annotations?
01:54:50 <Habib> And how so?
01:55:02 <Axman6> hmm, I gbuess it's clear that otherFunc :: IO ()
01:55:13 <Habib> Should be, from main's type, right?
01:55:21 <Axman6> yeah
01:55:27 <Habib> and that it uses putStrLn
01:56:12 <Axman6> and you shouldn't be loading "src/" ++ mod ++ ".o"?
01:56:23 <Habib> why not?
01:56:35 <Axman6> well, you're not loading something from src/ but .
01:56:48 <Habib> Oh, I add src to the list of directories to search.
01:56:55 <Axman6> oh right
01:57:21 <Axman6> so, the case of the files doesn't match, perhaps you should have Other.hs
01:57:22 <Habib> Worth trying to prepend src to the file to load
01:57:33 <Axman6> this will work on OS X but not anywhere else currently
01:57:43 <Habib> I am on OS X.
01:58:12 <Habib> YES, got it. Prepending "src" instead of adding it as a search path gets me further.
01:58:16 <Axman6> sure, but it's not a bad idea to have name things properly, modules names really should be capitalised
01:58:22 <Axman6> excellent!
01:58:25 <Axman6> what happened?
01:58:26 <Habib> Okay, will do that, thanks.
01:58:41 <Habib> hsplugins: mismatched interface file versions (wanted "7103", got "8001")
01:58:49 <Axman6> interesting...
01:58:57 <Habib> I think I just need a fresh recompile
01:59:01 <Axman6> yeah
01:59:15 <Axman6> you've obviously switched to GHC 8.0 at some point =)
01:59:20 <Habib> Yes, I have.
01:59:53 <Axman6> GHC has never been ABI compatible between versions
02:00:13 <oherrala> This looks neat: https://devdocs.io/ but the Haskell docs need stuff from Hackage :P
02:00:45 <Axman6> that would get very big, very fast
02:01:03 <Habib> But only on my Homebrew installation, stack should still be on whatever it was. Though I do recall that when I uninstalled Homebrew GHC, I got a weird pattern matching error from Distribution.Simple. Reinstalling fixed it, so it does seem to be using the system GHC.
02:01:13 <Habib> How do I fix that?
02:01:37 <Axman6> what does which ghc say?
02:01:46 <Axman6> (and possibly stack exec -- which ghc
02:02:15 <Habib> which -a ghc -> /usr/local/bin/ghc
02:02:24 <Habib> stack exec -- which ghc -> /Users/Habib/.stack/programs/x86_64-osx/ghc-7.10.3/bin/ghc
02:02:28 <Habib> need to add to the PATH
02:02:37 * hackagebot cabal-test-quickcheck 0.1.7 - QuickCheck for Cabal  https://hackage.haskell.org/package/cabal-test-quickcheck-0.1.7 (TimothyJones)
02:02:37 <Axman6> hmm, seems ghc is still installed by homebrew
02:02:46 <Habib> Yes, I reinstalled it after uninstalling it.
02:02:52 <Habib> Sorry, very confusing, I know.
02:03:09 <Axman6> you should probably uninstall it. I just use stack ghc whenever I need to call ghc directly
02:03:38 <Habib> Needed man pages, but turned out it doesn't have it, anyway.
02:04:06 <Habib> So I removed it. That broke my program somehow with the pattern match error.
02:04:32 <Axman6> did you run stack setup after removing ghc?
02:04:46 <Habib> No
02:06:57 <Habib> Okay, set up PATH correctly, uninstalled Homebrew ghc, rebuilt and reran.
02:07:05 <Axman6> any luck?
02:07:23 <Habib> Yes, I have gotten further. Is three lines of output for hpaste?
02:07:43 <Axman6> it's fairly quiet here, go for it
02:07:50 <Habib> ah, too late - http://lpaste.net/4056555207587266560
02:08:33 <Axman6> hmmmmaybe try using load_
02:09:29 <Habib> I did look at the source for this the other day, and load_ literally just calls load with an empty array for the third argument (which is just what I'm doing).
02:09:34 <Axman6> but at this point I'm getting to unfamiliar territory
02:09:42 <Axman6> heh ok
02:09:52 <Habib> Yeah, same result.
02:09:58 <Habib> Thanks for the help, though.
02:10:12 <Habib> I'm further along than before.
02:12:29 * Axman6 -> home
02:13:47 <Habib> Here's a weird way that one person fixed it: http://stackoverflow.com/a/21971643/905250
02:19:04 <Habib> Interesting. I was able to load an Integer, like srhb.
02:22:37 * hackagebot distribution 1.0.1.0 - Finite discrete probability distributions.  https://hackage.haskell.org/package/distribution-1.0.1.0 (RomainEdelmann)
02:23:44 <harfangk> i‚Äôm surprised to see so many people in haskell channel
02:23:56 <Clint> none of us are real
02:24:08 <harfangk> (gasp) that means...
02:24:46 <Habib> That's actually a common misconception, at least 5% of us are real.
02:24:54 <Habib> It's just no one knows which oens.
02:25:19 <Habib> So, in effect, none of us are real.
02:25:21 <Habib> But some of us are.
02:30:55 <quxbam> unsafeCoerce: Do I have to fear segfaults when converting arbitrary types to Int?  The docs imply that, but I've propertytested a whole range of strings and tuples and nothing has lead to errors...
02:31:36 <quxbam> (I'm thinking about implementing a map with unsafeCoerce to avoid an Hashable constraint)
02:35:46 <Habib> Well, this is frustrating. Time to take a break, I think. Tthanks for the help srhb and Axman6. Peace.
02:35:55 <srhb> Habib: o/
02:44:51 <Morgawr> How common is it in Haskell to use fromJust or isNothing/isJust to work around Maybe monads?
02:44:55 <Morgawr> Is it a code smell?
02:46:32 <quxbam> Morgawr: It depends, in some cases you *know* that a maybe is a Just _, for example a lookup in a map
02:47:11 <quxbam> But in most cases you should use `maybe` to handle both cases explicitely
02:47:39 <Morgawr> I have some code that is getting some data from an external protocol and some parameters can be null/empty (so it's a Nothing in my case) and I need to conditionally set some flags if those parameters are not set, so I'm using an isNothing in an if statement. I feel it's appropriate but I'm not sure.
02:48:03 <Morgawr> I don't care about their value (at this stage) so I just need to check if they are set or not.
02:50:18 <tdammers> Morgawr: fromMaybe is OK, fromJust is a smell
02:50:36 <dsub> Morgawr: I agree with quxbam that `maybe` in most cases is the better choice. Perhaps in this one as well. But it's mostly a matter of preference
02:50:43 <quxbam> Well, if you really don't care about the value, you can use isNothing, or use a Bool
02:50:57 <tdammers> isNothing / isJust is harmless, but explicit pattern matching or using maybe / fromMaybe are better choices
02:51:05 <tdammers> (usually)
02:51:12 <qinusty> what IDE's would everyone recommend?
02:51:27 <quxbam> qinusty: emacs
02:51:30 <qinusty> ew
02:51:35 <qinusty> :P
02:51:43 <Clint> no IDE
02:51:44 <dsub> qinusty: emacs/vim is what most haskellers use I believe
02:51:48 <Morgawr> Alright thanks everyone for your input. :)
02:52:10 <tdammers> IDE support for Haskell is lousy; I believe the reason for this is that Haskell works really well without an IDE, and most Haskellers just won't bother
02:52:28 <tdammers> i.e., the need for an IDE isn't pressing enough for the community to produce one
02:52:34 <qinusty> vim is my preferred terminal editor of choice, I was considering emacs but I don't fancy the RSI
02:52:41 <tdammers> vim is fine
02:52:46 <qinusty> I've been using sublime though tbh
02:53:01 <qinusty> the repl is a bad though 
02:53:07 <qinusty> is bad*
02:53:12 <tdammers> standalone ghci is pretty good
02:53:17 <dsub> Isn't IntelliJ supporting Haskell now?
02:53:22 <qinusty> Is it?
02:53:25 <qinusty> I shall enquire
02:53:31 <tdammers> try it
02:53:39 <dsub> Haven't looked at it, but I think it does
02:53:48 <qinusty> There is a plugin for it 
02:54:02 <dsub> nice
02:54:13 <qinusty> Anyone tried Leksah?
02:54:23 <dsub> nope
02:54:41 <qinusty> The Haskell IDE written in Haskell 
02:54:49 <tdammers> I have no personal need for an IDE; I hear mixed things about leksah
02:54:57 <dsub> ^
02:55:02 <tdammers> one big downside for me would be that it seems to be an IDE *only* for Haskell
02:55:09 <qinusty> Yeah
02:55:16 <qinusty> I might try the intellij plugin tbh
02:55:26 <tdammers> if I were to adopt an IDE at all, it would have to be one that supports every programming language with a nonzero chance of being used by me in the foreseeable future
02:55:43 <qinusty> I mean, for editing over ssh I like vim. But it isn't aesthetically pleasing enough for me when developing inside a DE 
02:57:40 <quchen> How can I start the doc build on Hackage? My package has been stuck on "pending" for quite some time. I could upload them manually, but that's so 2014
02:58:05 <quxbam> qinusty: You can and you should rebind keys if you fear RSI
02:58:11 <tdammers> I don't use a text editor to satisfy my cravings for aesthetic things
02:58:17 <tdammers> I use a text editor to edit text
02:58:25 <qinusty> Two birds with one stone :P
02:58:29 <quxbam> qinusty: For example, use the neo-layout
02:59:16 <tdammers> the problem with 'aesthetically pleasing' UIs is that they often (or even, almost always) get in the way of efficient UX
02:59:19 <quxbam> Knows anybody a case of unsafeCoerce segfaulting when converting to an Int?
02:59:21 <tdammers> the top end, that is
02:59:52 <tdammers> a beautiful UI is great if your goal is to avoid scaring beginners away
02:59:56 <quxbam> I've tried a lot, even  unsafeCoerce unsafeCoerce :: Int
03:00:05 <quxbam> and it never crashes
03:01:27 <Hafydd> It seems like that would be hard, because an Int, only occupying one word of memory, and only ever read from, isn't likely to cause any access violations, wherever it's pointed at.
03:01:48 <Hafydd> I mean: for locations where something else already exists.
03:02:38 * hackagebot mywatch 0.2.0 - Web application to view and kill MySQL queries  https://hackage.haskell.org/package/mywatch-0.2.0 (ip1981)
03:04:28 <quxbam> Hafydd: I'm thinking about a map which uses unsafeCoerce to produce the keys, like a HashMap without the Hashable constraint.
03:04:44 <Hafydd> Oh, god.
03:05:14 <Hafydd> I don't recommend this. Just because you can't think of a case where it fails doesn't mean it won't fail.
03:06:00 <Hafydd> Also... the values might change over time.
03:06:15 <quxbam> Hafydd: Within the same execution?
03:06:28 <Hafydd> quxbam: I think it could, as the GC rearranges memory.
03:06:41 <quxbam> Oh!
03:07:00 <Hafydd> And also, as thunks are expanded.
03:07:38 <quxbam> Hafydd: I wanted to avoid the cost of hashing, but well... perhaps I'll use a hashmap
03:27:26 <drem> can you map over each element of a lens doing something like this? fmap (\node -> (node . x + node . nextX)) allNodes  
03:27:38 <drem> where allNodes would be a list of nodes
03:28:34 <drem> trying to update a bunch of points where each point has a direction
03:30:15 <bergmark> drem: sounds like uniplate/Data.Lens.Plated, do you want (a -> a) -> b -> b?
03:30:53 <drem> bergmark, yes, I think s
03:30:54 <drem> so
03:35:44 <mettekou> Say I have a 'Term' data type which represents terms in some simple programming language with variable binding. Is there an elegant way to use a zipper over 'Term' together with 'StateT' to deal with introducing the variable in a context aside from descending underneath a binder?
03:56:15 <bash_turtle> hi 
03:59:14 <bluezone> Ok guys 
03:59:23 <bluezone> time for problem #2 hehe
04:13:46 <jophish> Hmm, there don't seem to be any bindings for tcl
04:13:59 <jophish> or ast I can pretty print
04:31:17 <bluezone> Aren't instances of "Num" also instance of "Eq"?
04:31:50 <bluezone> Compiler is complaining because I am comparing a Num with a integer. For example a == 1, where a is a Num
04:32:26 <Clint> bluezone: the error is "you are comparing a Num with an integer"?
04:35:34 <bluezone> Clint: https://github.com/1337micro/haskell-practice/blob/master/tias/1to10/3/3.hs
04:36:11 <bluezone> the method name is misleading but anyway this is a compiling problem
04:36:35 <Clint> bluezone: you need an Eq constraint
04:36:54 <bluezone> How do I add it on top of the Num
04:37:04 <bluezone> oh
04:37:06 <bluezone> nevermind
04:37:17 <bluezone> I know what I must do :)
04:43:32 <bluezone> ok problem 4... 95 left
04:52:41 * hackagebot text-lips 0.1 - Monadic parsing combinator library with attention to locations  https://hackage.haskell.org/package/text-lips-0.1 (MikhailVorozhtsov)
04:55:25 <dysfun> hi folks. i'm having difficulty with getting a small stack-based project to build on nixos. is this a good place to ask?
04:56:51 <pavonia> Yes
04:57:16 <dysfun> okay. i'm getting errors when it tries to find c libraries. in particular zlib and icu
04:57:29 <dysfun> i've been trying to follow the nixpkgs manual instructions for resolving this, but it's not working
04:58:07 <dysfun> i attached some info to https://github.com/commercialhaskell/stack/issues/2309
04:59:38 <oherrala> dysfun: have you tried to specify the lib locations in .cabal/config?
04:59:51 <dysfun> no. how do i do that?
05:00:04 <oherrala> or project's cabal file
05:02:07 <oherrala> dysfun: apparently cabal files also support pkgconfig-depends
05:02:57 <oherrala> so something like "pkgconfig-depends: zlib, icu" might work if those libs support pkg-config
05:04:02 <dysfun> okay, trying it out. may take a little while, on a slow machine :)
05:04:33 <oherrala> And if that doesn't work then maybe using extra-include-dirs and extra-lib-dirs works
05:04:36 <maerwald> I think 'icu' is not a valid pkg-config file
05:05:22 <dysfun> ok, pkgconfig-depends didn't do it
05:06:03 <dysfun> okay, i didn't have pkg-config even installed
05:06:29 <maerwald> https://packages.debian.org/jessie/amd64/libicu-dev/filelist
05:06:33 <dysfun> wow, the defaults on nixos are very minimal
05:06:38 <maerwald> you want something like icu-i18n, not icu
05:07:03 <dysfun> the only nix package with 'icu' in it is called 'icu'
05:07:13 <dysfun> are these not interpreted by nix?
05:07:22 <maerwald> dysfun: I'm talking about the pkg-config files, not the package name
05:07:34 <maerwald> pkg-config files are maintained upstream
05:08:15 <maerwald> so, "pkgconfig-depends: zlib, icu" will not find anything icu related afais
05:08:35 <dysfun> it was actually zlib that complained
05:08:53 <dysfun> (i commented out the packages: line and it compiled all the pure haskell modules fine)
05:09:30 <oherrala> dysfun: btw. are you familiar with cabal2nix?
05:09:55 <dysfun> nope, only heard of it. i've been using nix for almost two days now :)
05:10:09 <oherrala> ah, you are probably on same level of Nix than me :)
05:10:29 <bluezone> Just to subtract 1 from an Int and ghc is telling me off :(
05:10:38 <dysfun> well if i can't figure out how to get haskell to build, it's going to lose out to another distro
05:11:28 <bluezone> Urghh had to put brackets around the subtraction
05:15:25 <tdammers> > pred 23
05:15:26 <lambdabot>  22
05:15:29 <tdammers> :D
05:15:29 <dysfun> okay, i changed the pkg-config to match the "missing c libraries" that the error mentions, but it's still present. updated gist: https://gist.github.com/jjl/071d5635d1f154b733765de25a7821a9
05:16:29 <maerwald> dysfun: what do you mean with "match the missing c libraries"?
05:16:44 <dysfun> that error complains * Missing C libraries: icuuc, icui18n, icudata
05:16:47 <maerwald> the pkg-config file names are not necessarily the package names as I already said
05:16:56 <dysfun> so i changed the pkg-config-depends to use those
05:17:15 <maerwald> well, then you didn't listen
05:18:06 <dysfun> no, i merely assumed that the things it was complaining about where package-config file names
05:18:29 <maerwald> I even gave you a link that shows the correct pkg-config names
05:18:56 <dysfun> oh, i assumed those would differ between distributions
05:19:08 <maerwald> no, I also told you that they are maintained upstream
05:19:25 <maerwald> otherwise your cabal file would only work on one distro
05:19:57 <dysfun> ok
05:20:21 <maerwald> for the missing header file thing, you probably need an fhs compatible nix chroot or fix the include-dirs
05:20:29 <maerwald> because nix deliberately breaks fhs
05:21:11 <dysfun> yes, i'm having mixed feelings about what nix does to the filesystem layout
05:21:22 <maerwald> it breaks it.
05:21:43 <maerwald> but there are tools to create fhs compatible chroots
05:21:46 <dysfun> even freebsd breaks it these days a little bit
05:24:03 <maerwald> I'd say NixOS is horrible for development, but can be nice for deployment.
05:24:35 <maerwald> if you develop stuff, you likely do things outside of the package manager and that's not made easy with nix
05:24:38 <dysfun> but it uses systemd, so i couldn't possibly deploy it
05:26:41 <maerwald> uhm, you can use nix within any other distro
05:27:02 <dysfun> yes, which is starting to look like an appealing option
05:28:16 <dysfun> okay, getting an fhs environment set up looks easy enough
05:28:36 <oherrala> for deploying stuff I would look Docker before Nix
05:29:12 <quxbam> I'd say that NixOS is great for development
05:29:22 <quxbam> ghc-mod works like a charm
05:29:38 <quxbam> and cabal works just fine in a nix-shell
05:29:43 <dysfun> what do you do to get stack to build things that need C linkage then?
05:30:43 <maerwald> nix-shell as he said
05:30:45 <quxbam> Well, I don't use stack in nixos, so can't comment on that one
05:31:21 <quxbam> and cabal2nix makes it quite easy to generate a package
05:31:37 <maerwald> yet I find it rather silly to have to write expressions and chroot somewhere just to have normal expected linux behavior
05:32:14 <maerwald> using stack + nix also feels somewhat redundant
05:32:31 <maerwald> since they're trying to fix similar problems
05:32:47 <quxbam> nixos is surely a bit more cumbersome that e.g. debian, but you reap a lot of benefits as well
05:33:03 <quxbam> it's technically superior, but the UX is a bit wonky
05:33:09 <dysfun> stack made most of my cabal woes go away. does nix really offer that?
05:33:19 <maerwald> quxbam: that's highly debatable
05:33:39 <Aruro> nixos is not os, its a package manager :)
05:33:41 <maerwald> dysfun: well, it's also sort of "sandboxed" stuff so yeah
05:33:49 <maerwald> Aruro: wrong, the PM is called nix
05:33:58 <quxbam> maerwald: UX or superior?
05:34:00 <Aruro> i mean its linux distro isnt it?
05:34:07 <Aruro> so os part is invalid
05:34:12 <maerwald> nix is the PM, NixOS is a nix based distro
05:34:19 <Aruro> linux based?
05:34:22 <Athas> Is there a standard library function of type 'Monoid a => Maybe a -> Maybe a -> Maybe a'?  I.e., a function that uses mappend to combine the operands if they are both Just.
05:34:27 <Aruro> the kernel is linux?
05:34:30 <quxbam> Aruro: The term "os" isn't well defined
05:34:35 <quxbam> Aruro: yes
05:34:36 <maerwald> Aruro: check the homepage and read up on it
05:34:37 <Rembane> Athas: fmap
05:34:44 <Rembane> :t fmap
05:34:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:34:49 <hpc> > Just EQ <> Nothing
05:34:51 <lambdabot>  Just EQ
05:35:03 <quxbam> Aruro: but you can as well use hurd (or it used to be so)
05:35:03 <hpc> > Just LT <> Just GT
05:35:05 <lambdabot>  Just LT
05:35:12 <hpc> > Just EQ <> Just GT
05:35:13 <lambdabot>  Just GT
05:35:14 <Aruro> so, nixos Linux
05:35:17 <Aruro> on front page
05:35:28 <hpc> Athas: there's a Monoid instance for (Monoid a => Maybe a) that does that
05:35:32 <Athas> > Just [1,2] <> Just [3,4]
05:35:34 <lambdabot>  Just [1,2,3,4]
05:35:35 <Aruro> misusage of words as always
05:35:46 <Aruro> nix linux will be much better
05:36:05 <Athas> Huh, I didn't think the instance was like that.  Thanks!
05:36:26 <quxbam> Aruro: A lot of people would say the same of your usage of that term
05:36:54 <maerwald> dysfun: so the "sandboxed" functionality (I mean not just cabal packages sandboxed, but potentially also ghc) you can get with nix too... however, you don't get the tested stack package set
05:37:01 <hpc> Athas: there's a few valid instances, and based solely on your question the default instance will work
05:37:18 <maerwald> dysfun: so I sort of don't see the advantage for just development
05:37:24 <hpc> Nothing is mempty, so x <> Nothing = x and Nothing <> x = x
05:37:51 <hpc> though maybe you want to have Nothing behave like how 0 behaves with (*), and have Nothing <> x = Nothing, x <> Nothing = Nothing
05:37:59 <hpc> and there's another instance which does things that way
05:38:00 <quxbam> maerwald: the package set is mostly based on the stack set
05:38:07 <hpc> don't remember how to use that one though
05:38:15 <maerwald> quxbam: afais it just builds latest hackage always
05:38:21 <dysfun> maerwald: well i'm not absolutely tied to using stack, but i'm not sure how to go about using nix properly for it
05:38:40 <Aruro> hpc: Sum Product?
05:39:06 <quxbam> maerwald: There are stackage sets and haskellPackages is planned to go to the stackage set (I thought that it is already the case, but not sure)
05:39:23 <impure_hate> hello! I'm having troubles with this simple parser https://gist.github.com/sorki/854a8c04d9d16e81c2d4e010fd0cd081 it works only if matching separator with string but stops parsing messages when using takeWhile. dunno why
05:39:44 <dysfun> there are stackage sets but i don't know how they work and if you use nixos-stable they lag quite a way behind
05:39:57 <dysfun> nixos-unstable is only 1 LTS version out of date
05:40:06 <maerwald> dysfun: well, what functionality do you actually need from nix? the declarative configuration, the state backups, the heavy sandboxing?
05:40:53 <maerwald> if you struggle so much with it, then I don't see how it's going to improve your productivity
05:41:21 <dysfun> i'm brand new to nix and i'm expecting it to take a little while to learn the tools
05:41:55 <maerwald> well, then your path leads to nix-shell
05:42:19 <dysfun> okay, i'll investigate. thanks
05:42:46 <quxbam> dysfun: use cabal2nix
05:43:51 <dysfun> oh, that was surprisingly easy
05:44:08 <dysfun> (cabal2nix)
05:44:31 <maerwald> http://wiki.ocharles.org.uk/Nix
05:44:48 <quxbam> The major drawback of nix is the language nix.
05:45:36 <quxbam> It's some sort of bastardization between PHP and Haskell
05:45:46 <Aruro> yeah its bad, feels like bash :D
05:45:50 <tdammers> question about Chan - if I use dupChan, and never read from the original Chan, only the duplicated one, am I creating a resource leak?
05:45:51 <dysfun> yes, it's horrible
05:46:01 <dysfun> guix looks appealing, but guixsd is not ready yet
05:46:19 <dysfun> (guixsd is the 'system distribution')
05:46:22 <maerwald> the major drawback is the complete lack of guidance and policies. in nixpkgs you get anything from good quality (pretty much only the core packages) to very low quality and horrendous configuration management that is beyond anything user friendly
05:46:56 <dysfun> heh, but AUR and launchpad make you feel better about the situation?
05:46:58 <Aruro> major salling point of nix is "purely functional"
05:47:03 <Aruro> selling*
05:47:14 <dysfun> guix is too. but it's written in scheme
05:47:28 <quxbam> scheme is surely a superior language
05:47:32 <maerwald> dysfun: I don't use AUR or launchpad
05:47:47 <dysfun> maerwald: well they're probably worse than nixpkgs :)
05:47:51 <maerwald> no
05:48:14 <quxbam> And sadly, the arguments for using a wonky language in nix are void and it doesn't disturb the devs the slightest :(
05:48:52 <Aruro> told you they are puting most impact on "purely functional"
05:49:12 <mkloczko> Hey, would it be possible to recursively use (:*:) operator (from GHC.Generics) in a function ?
05:49:13 <quxbam> They say that the dependency on ghc is to heavy for embedded stuff, which is ridiculous if you use nixops
05:54:11 <quxbam> Is someone writing a DSL to write nix expressions in haskell?
05:57:07 <bluezone> mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:57:19 <bluezone> this signature is confusing af
05:58:20 <maerwald> quxbam: why?
05:58:26 <maerwald> what would be the benefit?
05:58:57 <quxbam> maerwald: Better means to abstract and a type system which is sane
05:59:02 <quxbam> no stringly typed bools
05:59:13 <maerwald> I don't see that as a benefit for that use case
05:59:44 <quxbam> You could in ghci tabcomplete to browse packages etc
05:59:59 <maerwald> nothing you need a new language for
06:00:41 <maerwald> it's similar to propellor... while the idea is nice, there's no real benefit to the strict typesystem for that use case imo
06:00:54 <maerwald> since the typesystem doesn't tell you anything whether the configuration actually _works_
06:01:00 <maerwald> that, you cannot map to the language
06:01:05 <maerwald> you have to _test_ it
06:01:25 <sm> it maybe tells you that it's sensible, at least ?
06:01:41 <quxbam> but you'd at least have valid packages in the sense of typos
06:01:43 <maerwald> no, it just tells you the internal types of the API are correct
06:01:49 <maerwald> the configuration might just be outright broken
06:01:55 <quxbam> and the type errors are surely better than that of nix
06:01:58 <sm> and those types are designed to rule out some impossible configs
06:02:34 <quxbam> you'd have semantics
06:03:11 <maerwald> quxbam: not sure if they would be better, GHC errors are often overly verbose and confusing
06:03:20 <maerwald> especially if it would use stuff like lens
06:03:48 <maerwald> then you'd have half of nix users enter this channel and ask questions
06:03:52 <impure_hate> hm, somehow 'parse (many1 ((Data.Attoparsec.Text.takeWhile (=='=') <|> takeTill isEndOfLine) <* endOfLine)) "wtf\n===\nwtf\n"' won't work but adding one explicit char makes it work .. parse (many1 ((char '=' *> Data.Attoparsec.Text.takeWhile (=='=') <|> takeTill isEndOfLine) <* endOfLine)) "wtf\n===\nwtf\n"
06:04:18 <quxbam> maerwald: that's already the case perhaps
06:04:34 <maerwald> I don't really see that
06:04:44 <maerwald> we have that with xmonad users regularly though
06:05:17 <maerwald> while some people might think that is nice, I also think it's wasting users time
06:06:17 <quxbam> fair points
06:10:01 <lyxia> impure_hate: takeWhile never fails, so the second alternative is never run
06:10:13 <impure_hate> lyxia: oh. how come it never fails?
06:11:04 <lyxia> because if the predicate is False at the start then it succeeds by matching nothing
06:11:05 <impure_hate> hmm, I see, using takeWhile1 works too
06:11:06 <hpc> either it matches some non-zero number of characters that match, or it's a zero-width match
06:11:13 <impure_hate> thanks!
06:14:18 <impure_hate> and suddenly, everything makes sense :D
06:14:57 <Qommand0r> and then, you wake up
06:15:02 <Qommand0r> and it's all gone
06:15:08 <Qommand0r> :|
06:17:00 <maerwald> wat xD#
06:21:58 <quxbam> Has anybody a nice typeintype tutorial? (I've already read the one on the wiki)
06:29:03 <dramforever>  HexChat: 2.10.2 ** OS: Linux 4.3.3-303.fc23.x86_64 x86_64 ** Distro: Fedora release 23 (Twenty Three) ** CPU: 4 x Intel(R) Core(TM) i5-3337U CPU @ 1.80GHz (GenuineIntel) @ 1.09GHz ** RAM: Physical: 7.7GiB, 67.0% free ** Disk: Total: 262.1GiB, 27.7% free ** VGA: Intel Corporation 3rd Gen Core processor Graphics Controller ** Sound: HDA-Intel - HDA Intel PCH ** Ethernet: Realtek Semiconductor Co., Ltd. 
06:29:04 <dramforever> RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller ** Uptime: 1w 1d 3h 50m 8s **
06:29:09 <dramforever> Ouch sorry
06:29:17 <buglebudabey> one off topic question, does anyone use CIRC?
06:29:40 <dramforever> Well fortunately nothing too important was leaked
06:33:26 <quxbam> How do cost centers in profiled builds relate to the performance distortion of a profiled build?  Let's say that I don't use any cost center, would it then perform like the unprofiled binary?
06:38:27 <buglebudabey> does anyone know how to ghci into a file with stack?
06:39:40 <StoneToad> you mean like the 'stack ghci <file>' thing? might be repl or something instead of ghci...
06:40:13 <buglebudabey> StoneToad: yeah i mean that
06:40:30 <dramforever> Seems to work: stack ghci --ghci-options a.hs
06:40:38 <dramforever> or you can probably just call :l inside
07:06:34 <`Guest02> how to implement a dictionary with type-level keys and heterogenous values, without using existential types?
07:07:45 * hackagebot dotenv 0.3.0.2 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.0.2 (jpvillaisaza)
07:52:54 <impure_hate> is there a parser for human readable sizes? like 10 M, 20k..
07:59:50 <Skami> impure_hate: What do you mean? ("10 M" => 10 * 10‚Å∂) ??
07:59:50 <impure_hate> Skami: yup
08:01:44 <impure_hate> Skami: need to parse such sizes into bytes, seems quite common so I'm wondering if there's a lib for it
08:01:44 <Skami> inpure_hate: I don't know any. But making one shouldn't be too hard.
08:05:05 <srhb> impure_hate: https://hackage.haskell.org/package/units-attoparsec-1.0/docs/Data-Units-SI-Prefixes-Attoparsec-Text.html -- most of the work is done there. :)
08:08:48 <impure_hate> srhb: hehe, indeed, thanks
08:09:44 <Skami> I like how it uses the units package
08:10:28 <maerwald> doing a generic parser for user input looks like it's going to be a lot of <|> and backtracking though
08:11:01 <maerwald> I'd probably write my own monadic thing there, doing the choice directly in that one parser
09:07:48 * hackagebot irc-client 0.4.2.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.2.0 (barrucadu)
09:22:05 <nalin> hi all
09:25:28 <bitemyapp> nalin: hi
09:28:02 <Morgawr> Can I curry a lambda? Let's say I have a lambda like (\x y z -> x + myFunction $ y z) is there a way to turn it into (\x -> x + myFunction)?
09:28:34 <Iceland_jack> that's not currying
09:29:13 <Iceland_jack> It's possible to /eta reduce/ a lambda, but your example doesn't work
09:29:20 <glguy> Morgawr: Also, did you intend to write:   \x y z -> (x + myFunction) (y z)
09:29:28 <Iceland_jack> > (\n xs -> take n xs) 2 "hello"
09:29:29 <GLM> Morgawr: Are you talking about just applying arguments for x and y?
09:29:29 <lambdabot>  "he"
09:29:32 <Iceland_jack> > (\n -> take n) 2 "hello"
09:29:33 <lambdabot>  "he"
09:29:35 <Iceland_jack> > (take) 2 "hello"
09:29:37 <lambdabot>  "he"
09:30:18 <Morgawr> I want to call myfunction y z and then add that result to x
09:30:25 <Morgawr> (I know I used $ wrong, sorry)
09:31:00 <GLM> You can either wrap that in more lambdas or use some flip tricks
09:31:06 <glguy> Morgawr: OK, \x y z -> x + myfunction y z -- is the right way to do that
09:31:12 <Iceland_jack> Morgawr: You want to write it pointfree, I would avoid it in your example
09:31:14 <Iceland_jack> @pl \x y z -> x + myFunction y z
09:31:15 <lambdabot> (. myFunction) . (.) . (+)
09:31:31 <Iceland_jack> I would much rather read (\x y z -> x + myFunction y z) :)
09:31:43 <Skami> Yeah, that's kind of ugly
09:32:04 <Morgawr> I want to avoid having y and z explicitly defined in my lambda though
09:32:07 <Morgawr> as it feels redundant
09:32:34 <Iceland_jack> Morgawr: If you feel strongly about it and if its used severla times, consider writing an auxiliary function
09:32:43 <glguy> It's not redundant, it shows which arguments go to the function "myFunction" and which don't
09:33:33 <Morgawr> mmm... I guess...
09:34:48 <Iceland_jack> Morgawr: The argument order is also not ideal 
09:35:09 <Iceland_jack> For example with
09:35:09 <Iceland_jack> @pl \y z x -> x + myFunction y z
09:35:09 <lambdabot> ((+) .) . myFunction
09:35:56 <Morgawr> Yeah I didn't make the argument order of foldlWithKey unfortunately
09:36:24 <saurabhnanda> anyone with Raspberry Pi + Haskell experience. Which distro should I start with? Which will give the least amount of pain?
09:37:07 <glguy> saurabhnanda: I'm using Raspbian and GHC 8
09:37:38 <saurabhnanda> glguy: how did you install GHC 8 on it?
09:37:42 <saurabhnanda> and what about cabal/stack?
09:38:03 <hpc> you can download ghc from the website
09:38:04 <glguy> I installed GHC from the arm bindist available from haskell.org
09:38:08 <hpc> and then build/install cabal yourself
09:38:21 <glguy> You have to change a setting after you install it, I'm looking it up now
09:38:28 <hpc> not sure what the procedure is for stack, but it's probably documented somewhere
09:38:39 <glguy> I had to add:  ("C compiler flags", " -marm -fno-stack-protector -mcpu=cortex-a7"),
09:38:48 <glguy> to my $prefix/lib/ghc-8.0.1/settings
09:38:51 <hpc> (on windows it's install stack first, then stack installs everything else)
09:38:54 <glguy> the difference is the mcpu flag
09:39:06 <glguy> I bootstrapped a cabal-install executable
09:39:45 <glguy> There was an issue with the released version of cabal-install's bootstrap.sh. It lists a slightly wrong version of time
09:39:56 <glguy> err, no. tar
09:40:03 * Phyx- only uses cabal
09:40:08 <glguy> so I had to change it from 0.5.0.1 to 0.5.0.3
09:40:26 <glguy> Yeah, I don't need a stack executable for the kind of development I do on my raspberry pi
09:40:32 <glguy> nothing that complicated
09:40:42 <glguy> but I'm sure it works
09:45:48 <Morgawr> What's the haskell code style for indentation when function parameters are too long and go past the line character limit? 
09:46:01 <Morgawr> I couldn't find this anywhere, should they line up to the function name or to the first parameter?
09:46:33 <Iceland_jack> Morgawr: lpaste example code?
09:46:38 <hpc> exactly how long is too long in this case?
09:46:52 <hpc> usually it means you need to structure your code a bit better
09:48:00 <Prutheus> Hello! How can i replace the nth element of a vector?
09:49:31 <Iceland_jack> Prutheus: If you mean lists the answer is not great
09:49:38 <Welkin> Prutheus: modify (\v -> write v index value)
09:49:44 <Welkin> for Vector
09:49:50 <Welkin> er
09:49:50 <Prutheus> Welkin: thanks
09:49:51 <Iceland_jack> Unless you have lens
09:49:58 <Morgawr> http://lpaste.net/6773464683388076032 This is the code example (removed parameter names and stuff due to proprietary-ish code). The last line goes past the 80 character limit.
09:50:01 <Welkin> yes, that is the way
09:50:46 <EvanR> Morgawr: maybe like this in the worst case scenario
09:50:48 <EvanR> http://lpaste.net/168196
09:51:05 <EvanR> if the function name is short enough, then you could light it all up at the ::
09:51:40 <Iceland_jack> align!
09:51:40 <Iceland_jack>   supercalafragiwhatsit
09:51:40 <Iceland_jack>     :: CoolClass a
09:51:40 <Iceland_jack>     => Uhg a
09:51:43 <Iceland_jack>     -> Yeah b
09:51:46 <Iceland_jack>     -> (a -> b) 
09:51:58 <Welkin> Morgawr: your "where" in indented too much
09:52:05 <EvanR> like this
09:52:08 <EvanR> http://lpaste.net/168196
09:52:30 <EvanR> Iceland_jack: this is just weird...
09:52:36 <Morgawr> Welkin: Where should it line up with? :/
09:52:53 <Welkin> Morgawr: using haskell-mode?
09:53:00 <Iceland_jack> EvanR: The benefit is that it isn't dependent on the length of the function name
09:53:21 <Morgawr> Welkin: I'm using vim with some haskell indent plugin but sometimes it messes up the indentation
09:53:22 <Welkin> well, you could put it at the top-level of your function, indented 2 spaces
09:53:25 <EvanR> that is a benefit if youre writing a program to do it
09:53:52 <Morgawr> Welkin: Should it just go under the | guard?
09:53:56 <Welkin> yes
09:54:27 <Morgawr> Alright, but still this doesn't answer my question, I mean this makes my code not go past the 80 char limit (barely, to be honest, like 2-3 chars left). In case it does what's the standard?
09:54:44 <EvanR> it sounds like youre function is really just too complicated
09:54:45 <Welkin> use parentheses
09:54:50 <EvanR> your function
09:54:54 <Welkin> or shorten your parameter names
09:55:03 <Welkin> in haskell is is okay to use very short variable names
09:55:04 <EvanR> you can make related params into a new data type
09:55:21 <EvanR> or split up the function
09:55:38 <Welkin> many of mine are often like this: a, x, xs, ys, acc
09:55:47 <Welkin> they all have an actual meaning
09:56:04 <Morgawr> The function is already split up (see the "helper function" in the code I pasted), the parameter names cannot really be shortened. As for the function being too complicated I'm not sure, I'm just accumulating values over a map and passing that into another function...
09:56:05 <EvanR> new and improved, now with actual meaning!
09:56:09 <Cale> Morgawr: I generally find that 80 characters is probably too low for most Haskell code
09:56:35 <Cale> Morgawr: I personally don't like very long lines, but at least 120 or something is a lot more comfortable.
09:57:21 <EvanR> unfortunately, if i moved the margin to 120, then two half windows open would need to be too small for me to read
09:57:50 <Cale> I wouldn't indent that 'where' so far though -- remember it's part of the definition of function1, and scopes over both of the guards, so it probably deserves to be indented less than the guards are.
09:58:14 <Morgawr> Yeah I fixed the where already :)
09:58:34 <Morgawr> Also unfortunately my project's coding guidelines limit me to 80 char (which I also personally like and usually have in all my projects anyway)
09:58:50 <Welkin> I often have long compositions of functions
09:59:02 <Welkin> I just split at the (.) when it gets too long
09:59:05 <EvanR> compositions of functions are great candidates for multiple lines
09:59:43 <Welkin> and yes, it could be that your function is too complicated if it takes that many parameters
10:00:49 <Morgawr> http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Lazy.html#v:foldlWithKey I didn't really make up the gist of my code though...
10:00:49 <Welkin> Morgawr: it is also common to keep helper functions internal to the function that it helps
10:00:53 <Welkin> define it in a where clause
10:01:01 <Welkin> and you can name it `f` or something if you like
10:01:01 <Morgawr> Welkin: Yeah I guess I can do that.
10:01:27 <EvanR> did i miss a paste of your actual code?
10:02:13 <Welkin> Morgawr: it is common in haskell to name a list of inputs as `xs` or `ys` or similiar
10:02:24 <Welkin> and a single value as `a` or `b` or whatever
10:02:30 <saurabhnanda> glguy: hpc: does the same code compile without hassles on a mac as well as r-pi?
10:02:39 <Welkin> (x:xs) to match the head of a list
10:02:48 <EvanR> a or b are common type variables
10:02:52 <saurabhnanda> glguy: hpc: or does one always need to compile & test ON THE r-pi throughout development?
10:03:11 <EvanR> for a completely non descript variables which has no real meaning, x or y
10:03:40 <Morgawr> EvanR: http://lpaste.net/6773464683388076032 the paste of my code (I already moved the where in the proper indentation place)
10:03:55 <Morgawr> Welkin: I know that already, I do that whenever I can :)
10:04:01 * EvanR reformats that
10:04:39 <EvanR> Morgawr: though this doesnt seem to have super long or numerous anythin
10:05:51 <Morgawr> EvanR: Yes, it just goes past the character count (80 char per line), which is why I was curious about the rules for splitting up parameters to a function on multiple lines, although moving the "where" back to where it belongs fixed it for me.
10:05:55 <Morgawr> But still I'm curious :)
10:09:40 <EvanR> @pl f x y z = x + g y z w
10:09:40 <lambdabot> f = (. flip (flip . g) w) . (.) . (+)
10:09:43 <EvanR> hmm
10:09:52 <EvanR> no help there
10:11:05 <EvanR> Morgawr: you can call "reducer" f, because calling this reducer is probably annoyingly obvious, like int myInt = new Int(getInt()) in c++
10:11:20 <EvanR> that will "reduce" the number of characters somewhat
10:11:26 <Morgawr> EvanR: I guess... 
10:11:55 <Morgawr> I mean, I agree with you, I'm not sure if the guy doing the code reviews will agree with that though.
10:11:59 <Morgawr> but we'll see :)
10:12:16 <EvanR> well tell him to do his own haskell style guide practice
10:12:58 <EvanR> when variables are introduced and used so close, having longer names is sometimes in the way
10:13:05 <Morgawr> Yep, I agree.
10:14:40 <hpc> the other side of it is that if something is generic, it should have a generic name
10:15:49 <hpc> pList can be just "ps"
10:15:52 <hpc> (plural of p)
10:15:58 <hpc> (p for param)
10:16:37 <EvanR> param, [param]  in the type sig yeah
10:16:45 <EvanR> p and ps for vars
10:16:53 <hpc> oh, didn't even notice that's type variables too
10:16:56 <EvanR> the word List in a variable is kind of unidiomatic
10:17:13 <hpc> the param type variable should be shorter too, so it's clear that it's not something specific
10:17:48 <hpc> the where can be less indented
10:17:53 <hpc> i would probably do something like
10:17:58 <hpc> foo arg arg | guards
10:18:04 <hpc>             | ...
10:18:07 <hpc>   where ...
10:18:54 <Morgawr> EvanR & hpc: the parameter names aren't actually those, I just made up some long parameter names because I can't write the actual names (as it's confidential code, silly as it may be). But yeah point taken :) I simplified a few things already, thanks
10:19:31 <hpc> Morgawr: yeah, as long as you got the gist of it :D
10:20:40 <saurabhnanda> hpc: glguy: where do I get the haskell platform for r-pi from?
10:20:50 <saurabhnanda> can't find one here: https://www.haskell.org/ghc/distribution_packages
10:21:35 <EvanR> Morgawr: heres something less than 80... the bottom one is a common thing i do which is to instantly get into a big where blog 
10:21:38 <EvanR> http://lpaste.net/168199
10:22:03 <EvanR> i dont like putting a where after something complex like a guard or do
10:22:58 <Iceland_jack> You can of course use lets in guards
10:23:02 <EvanR> which also lets you have inner wheres pretty painlessly
10:23:08 <Iceland_jack>     f x 
10:23:08 <Iceland_jack>       | let u = x + x
10:23:08 <Iceland_jack>       = u
10:23:18 <Iceland_jack> not a huge fan
10:23:25 <EvanR> what on earth ;)
10:24:16 <Iceland_jack> There are more things in heaven and Haskell than are dreamt of in your philosophy
10:24:17 <Cale> Wait, what?
10:24:27 <Cale> no way
10:24:39 <Morgawr> EvanR: Thanks, I'll have alook
10:24:53 <Cale> When did that happen?
10:25:01 <Iceland_jack> Well you can also write it with pattern guards
10:25:02 <Iceland_jack>     f x 
10:25:02 <Iceland_jack>       | u <- x + x
10:25:05 <Iceland_jack>       = u
10:25:17 <EvanR> Iceland_jack: in the first example, u is a Bool?
10:25:22 <Cale> oh, is it part of PatternGuards?
10:25:32 <Iceland_jack> u is some Num
10:25:50 <EvanR> oh... what does the guard check?
10:25:55 <EvanR> being non zero??
10:26:00 <Cale> It doesn't check anything
10:26:06 <EvanR> wtf
10:26:11 <Cale> It just matches the pattern u against the expression x + x
10:26:12 <Iceland_jack> It's just like
10:26:13 <Iceland_jack>     [ x | y <- ys, let x = y + y ]
10:26:15 <Cale> which obviously succeeds
10:26:20 <Cale> because u is irrefutable
10:26:21 <EvanR> oh
10:26:52 <Cale> Yeah, given PatternGuards, it makes sense to have let guards
10:27:03 <Cale> I didn't actually know that existed, hah
10:27:21 <Cale> It's been a while since I actually learned a new thing about the Haskell syntax
10:27:51 <shachaf> Is there a difference between | x <- y and | let x = y?
10:28:03 <Iceland_jack> I don't believe there is, want to be proven wrong
10:28:43 <Iceland_jack> shachaf: Only in the error messages it seems
10:29:05 <glguy> saurabhnanda: I don't know if there is a Haskell Platform for r-pi. I don't use Haskell Platform. I primarily use vanilla bindist + cabal-install
10:29:06 <Iceland_jack>     f x | Left u <- Right (x + x) = u + u
10:29:06 <Iceland_jack> v
10:29:07 <Iceland_jack>     f x | let Left u = Right (x + x) = u + u
10:29:07 <Iceland_jack>  
10:29:33 <saurabhnanda> glguy: I don't know what you mean by bindist. Where do I download it from?
10:29:43 <Cale> Iceland_jack: Maybe with respect to polymorphism?
10:29:50 <Cale> or recursion?
10:29:51 <glguy> http://downloads.haskell.org/~ghc/8.0.1/
10:30:11 <Iceland_jack> ah, I found a difference Cale 
10:30:38 <Iceland_jack> If 'let' doesn't match it fails, if pattern guard doesn't match it moves to next equation
10:30:39 <Cale> @let foo x | let { u = x : u } = u
10:30:41 <lambdabot>  Defined.
10:30:45 <Cale> > foo 0
10:30:47 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:31:01 <Cale> @let bar x | u <- x : u = u
10:31:02 <lambdabot>  .L.hs:163:18:
10:31:02 <lambdabot>      Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòExpr‚Äô
10:31:02 <lambdabot>      Relevant bindings include
10:31:17 <Cale> (normally that would be a "not in scope")
10:31:35 <Robin_Jadoul> @pl f a b = liftM2 (+) <$> a <*> b
10:31:35 <lambdabot> f = ((liftM2 (+) <$>) .) . (<*>)
10:31:48 <Cale> Iceland_jack: that too, indeed
10:31:50 <saurabhnanda> glguy: thanks, checking it
10:31:50 <Iceland_jack> Cale: Isn't that lambdabot's Expr?
10:31:54 <Cale> Yes
10:32:07 <Cale> Well, it's simple-reflect's Expr
10:32:26 <Iceland_jack> When I write
10:32:26 <Iceland_jack>     f x | u <- x:u = undefined
10:32:26 <Iceland_jack> I do get "not in scope" for u
10:32:37 <Cale> @let bar x | let = x
10:32:39 <lambdabot>  Defined.
10:32:45 <Cale> LOL
10:32:47 <saurabhnanda> got it
10:32:55 <saurabhnanda> glguy: and where do you get cabal-install from?
10:33:19 <Cale> This means that 'let' can be used instead of 'otherwise'
10:33:22 <glguy> saurabhnanda: Downloaded it from hackage and ran the bootstrap.sh contained in the tarball
10:33:24 <Iceland_jack> You're teaching me new things :)
10:33:32 <Iceland_jack> can't wait to abuse this
10:33:41 <saurabhnanda> glguy: basically, compile from source?
10:33:42 <glguy> saurabhnanda: I'll give you the executable if you want
10:33:45 <glguy> yeah
10:33:48 <Iceland_jack> > length "otherwise" - length "let"
10:33:50 <lambdabot>  6
10:33:51 <saurabhnanda> glguy: and compiled **on the pi**? how long did it take?
10:33:53 <Iceland_jack> Look at those savings!
10:34:14 <glguy> saurabhnanda: I don't remember exactly, I got it all set up in a single night, though :)
10:34:16 <saurabhnanda> glguy: let me get frustrated first :) then I'll come back to you for the executable
10:34:20 <ReinH> Cale: well, that's interesting
10:34:31 <saurabhnanda> glguy: does one have to baby-sit the install? or run the command and go to sleep?
10:34:42 <glguy> saurabhnanda: make sure you edit the bootstrap.sh like I mentioned and change the tar version from 0.5.0.1 to 0.5.0.3 like I mentioned earlier
10:34:43 <Iceland_jack>     isPos x
10:34:44 <Iceland_jack>       | x <= 0 = "neg"
10:34:44 <Iceland_jack>       | let    = "pos"
10:34:44 <Iceland_jack>     
10:34:54 <Iceland_jack> This made my day
10:35:13 <saurabhnanda> glguy: change the "tar" version? some file it downloads from the internet?
10:35:14 <Cale> brillant
10:35:27 <glguy> saurabhnanda: Yeah, the bootstrap script downloads the dependencies and installs them
10:36:00 <saurabhnanda> glguy: got it. Generally, how fast does haskell code run? I'm planning to run a telegram bot + download manager on it.
10:36:12 <saurabhnanda> glguy: how fast on the r-pi
10:36:19 <glguy> It runs at normal raspberrypi speeds
10:37:08 <saurabhnanda> glguy: okay :) my first run with an r-pi and I don't know why 'I'm doing it on haskell. fun times ahead!
10:38:36 <benzrf> Iceland_jack: "let"?
10:38:50 <saurabhnanda> thanks, glguy. Download noobs and 7.10.3 (arm) in parallel. will start installing tomorrow. let's hope for the best.
10:40:07 <petercommand> Is there any way to express anti-constraint in type class instances?
10:40:39 <petercommand> that is, the constraint cannot be satisfied
10:41:13 <Zemyla> Okay, I'm doing something wrong.
10:41:25 <Iceland_jack> petercommand: The second thing you said is possible (using 'Int ~ Bool' or 'Any') but the first one isn't possible afaik
10:41:47 <petercommand> I want to be able to do something like instance (TypeInequal x y) => MyClass x y
10:42:06 <Zemyla> Parsing a 16-character expression should not take over 2.5 GB.
10:42:34 <petercommand> Iceland_jack: the reason is that I want to avoid OverlappingInstances and IncoherentInstances
10:42:41 <glguy> Zemyla: wasn't that yesterday's problem?
10:42:55 <Zemyla> Oh, I must already have mentioned it.
10:43:16 <glguy> It's a new day :)
10:43:35 <EvanR> petercommand: nope. one reason is that your code will type check and then be totally wrong when someone separately compiled in a different instance of that class
10:43:44 <petercommand> by explicitly stating that a constraint is satisfied in one instance, and that the constraint is not satisfied in another instance, I will be able to avoid using OverlappingInstances
10:43:55 <Iceland_jack> benzrf: yeah :)
10:44:00 <EvanR> thats the thing you cant tell haskell this is the only instance ever
10:44:30 <Iceland_jack> petercommand: You can create a closed type family or index it with allowed types (DataKinds)
10:45:12 <petercommand> EvanR: yeah..
10:45:37 <petercommand> Iceland_jack: How to do it with a closed type family?
10:45:37 <EvanR> the only-foo-ever thing is where data types or data kinds comes in
10:45:49 <Zemyla> You know, I think there's a way to produce a typeclass which can't be extended.
10:46:16 <petercommand> Zemyla: how?
10:46:29 <Iceland_jack> This is how you create a type class that can't be instantaited
10:46:29 <Iceland_jack>     class Any => Bottom where
10:46:34 <Zemyla> Well, at least not obviously extended.
10:46:37 <EvanR> you mean doesnt admit a superclass?
10:47:11 <Iceland_jack> EvanR: It's impossible to define an instance, this is used in edwardk's constraints library
10:47:24 <EvanR> interesting
10:47:40 <EvanR> not sure if thats what Zemyla was referring to
10:47:56 <Iceland_jack> yeah I'm looking for a way of implementing that
10:47:57 <Iceland_jack> a min
10:47:59 <Zemyla> class ClosedTypeClass_ x where { ... }; instance ClosedTypeClass_ Int where { ... }; instance ClosedTypeClass_ Float where { ... }; type family ClosedTypeClass x :: Constraint where { ClosedTypeClass x = ClosedTypeClass_ x }
10:48:08 <Zemyla> And then you only export ClosedTypeClass.
10:48:11 <petercommand> interesting..using Any as a constraint
10:48:54 <Iceland_jack> Zemyla: https://gist.github.com/goldfirere/846c3faf7640e27025f0#file-basics-hs-L183
10:49:26 <Iceland_jack> Look at "Typeable" and how it interacts with "Typeable'"
10:49:37 <Zemyla> However, that doesn't prove to the compiler that it can't ever see any other instances, because a user can still create a dictionary somehow, use the reification trick, and pass it to your library.
10:50:08 <coppro> "reification"?
10:50:13 <Zemyla> Also, I had a weird thought about Integer.
10:50:37 <EvanR> reflection trick?
10:50:55 <Zemyla> coppro: Below the level of Core, Constraint and * have the same representation.
10:51:12 <Zemyla> http://hackage.haskell.org/package/reflection-2.1.2/docs/Data-Reflection.html
10:51:26 <Iceland_jack> There are even discussions of treating Constraint and * as the same
10:51:34 <coppro> ahhh
10:52:12 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/11715#comment:14
10:53:38 <petercommand> Zemyla: I see..so basically, it's listing out all the instances that are needed
10:54:29 <Iceland_jack> petercommand: The internals of Haskell don't really have a notion of "inequality", this is deliberate as I understand it
10:54:49 <Zemyla> Also, is there code to split a TypeRep for (f a) into a TypeRep for f and a TypeRep for a?
10:56:19 <petercommand> Iceland_jack: why is that?
10:56:24 <Iceland_jack> Zemyla: https://ghc.haskell.org/trac/ghc/wiki/Typeable#ProposedAPI
10:56:28 <Iceland_jack> look at TRApp
10:57:36 <Zemyla> Yes, but is there a way to do it in current GHC?
10:57:41 <Iceland_jack> No
10:57:54 <Iceland_jack> TypeReps currently aren't even indexed
10:58:01 <petercommand> there are Typeable that can check for equality, so it should be easy to implement inequality for basic types
10:58:30 <Iceland_jack> petercommand: Typeable checks happen dynamically, not statically
10:58:38 <Iceland_jack> but if you Google around you'll find examples
10:59:17 <mtesseract> Hi
10:59:34 <petercommand> Iceland_jack: I see..
10:59:53 <Iceland_jack> http://stackoverflow.com/a/14277376/165806 good answer by pigworker
11:00:13 <Zemyla> Iceland_jack: Well, for now, you can have an indexed TypeRep be data TTypeRep (a :: k) where { TTypeRep :: (Typeable a) => TTypeRep a }.
11:06:36 <Zemyla> But yeah, I want to be able to create data TTypeSplit (a :: k) where TTypeSplit :: forall (f :: k1 -> k) (x :: k1). (Typeable f, Typeable x, f x ~ a) => TTypeSplit a
11:07:43 <sinelaw> I have an type that's a functor, want to map only over the head constructor. e.g. fmapHead :: (a -> a) -> f a -> f a
11:08:07 <sinelaw> (not really fmap, of course)
11:08:23 <sinelaw> is there a generic way to do this? or do I have to implement it by spelling out all the constructors?
11:13:57 <mkloczko> Is it possible to use a runtime variable to parametrise a type ?
11:20:32 <srhb> mkloczko: In some cases, assuming you mean a dependent types. 
11:20:39 <srhb> mkloczko: You might want to search for that term.
11:21:22 <mkloczko> srhb: Ok, thanks!
11:21:49 <srhb> mkloczko: Agda might be a better bet, depending on what you need. It's still rather new territory in Haskell land.
11:23:38 <Squarism> i tried to rewrite an IO function but failed misserably. Can anyone spot what went wrong http://lpaste.net/168207 ?
11:23:50 <mkloczko> srhb: I'd like to unsafeCoerce Any type into a type family type which is parametrised by Nat.
11:23:56 <mkloczko> type family instance *
11:25:37 <Cale> Squarism: do toGame' <- ... is an IO action, not a pair
11:25:56 <Cale> Squarism: So it doesn't make much sense to be pattern matching it against a pair
11:26:23 <Cale> Squarism: You probably meant to execute that IO action.
11:26:52 <Cale> Also, the last line of the do-blocks there are pairs, and not IO actions, and they really need to be, so probably you're missing the return on each.
11:28:22 <Squarism> ok.. so i need to "complete the IO blocks" and forget about doing standard haskell in the middle of it all
11:31:44 <klop> Is there a good way to have syntax highlighting w/ stack ghci  within spacemacs Interactive-Haskell mode?
11:31:55 <Squarism> Cale, this worked : http://lpaste.net/168207
11:32:20 <Cale> Squarism: yeah
11:32:42 <Cale> Squarism: v <- x inside a do block means "execute the action x, and call whatever its result is v"
11:32:52 * hackagebot proto-lens-combinators 0.1.0.0 - Utilities functions to proto-lens.  https://hackage.haskell.org/package/proto-lens-combinators-0.1.0.0 (JudahJacobson)
11:33:11 <Welkin> `a <- ma` is the same as `ma >>= \a -> ...`
11:33:11 <Cale> Squarism: and then the do-block as a whole will be an action of the same monad as x was
11:33:48 <Cale> (and in particular will have the same type as the action on the last line of the do-block)
11:38:50 <Squarism> i do get the idea behind that IO bind/fmap...  i keep forgetting normal rules dont apply in those situations. 
11:40:37 <Cale> Normal rules?
11:41:26 <Cale> The thing to understand is that evaluating the do-block doesn't produce a pair here -- it just gives you an action that needs to be executed (which is a separate process from evaluation) to obtain a pair.
11:42:20 <Cale> The action is just a description of what ought to be done
11:43:17 <Cale> (basically an imperative programming language treated as a functional data structure)
11:44:44 <mniip> huh
11:44:48 <mniip> "Relevance inference simply looks at usage sites; iff a variable is used in a relevant context (scrutinee of a pattern-match, or passed to a function expecting a relevant argument, among others) then it is relevant."
11:45:05 <mniip> f x = f x
11:45:18 <mniip> would x be relevant or not
11:46:02 <dolio> Probably not.
11:47:31 <Squarism> Cale, in a sense it would probebly better for a noob like me to use bind directly.
11:48:03 <Cale> Maybe -- it's possible just to understand things in terms of the do-notation first, and then understand bind in terms of that
11:48:23 <Cale> i.e.  x >>= f = do v <- x; f v
11:48:38 <Cale> But yeah, in reality, it works the other way around
11:48:46 <cheater> is christopher howard in here?
11:48:55 <Cale> You can imagine that IO is a data type something like:
11:49:13 <mniip> "Yet, we do not want Proxy * Bool to be the same as Proxy Nat Zero. So, we choose the latter classifier."
11:49:16 <mniip> why not?
11:49:22 <mniip> they are the same term aren't they
11:49:52 <Cale> data IO a = Return a | PutChar Char (IO a) | GetChar (Char -> IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
11:50:00 <Squarism> i understand list and maybe, and monads not that different. Yet i often fool myself with those do/<- blocks
11:50:01 <mniip> what exactly is the problem with forall-quantifying kind-polymorphic datatypes?
11:50:26 <Cale> Where the constructors take the arguments of some primitive IO action, and then a function of the result which produces whatever action is meant to follow that
11:50:42 <Cale> and do-notation and (>>=) are just ways of building values of this data type
11:50:49 <Cale> The implementation in GHC is a bit differetn
11:50:52 <Cale> different*
11:51:08 <Cale> (It's a hack, it uses impure functions)
11:51:15 <Zemyla> So what is the approved way to expose S#, Jn#, and Jp# from GHC.Integer if GHC.Integer is hidden?
11:51:28 <Cale> but it ultimately amounts to the same thing
11:52:40 <mniip> Zemyla, what are you going to do if GHC is not compiled with gmp?
11:52:53 <Cale> There are some other encodings you could also imagine working... there's a nice one that uses a GADT for example
11:53:46 <Ohso_> If I have a type Foo2 that is made up of a Foo and some other stuff, can I take a collection of functions that are Foo -> Foo and turn them into a collection of functions that are Foo2 -> Foo2  ?
11:53:51 <Cale> and probably if you were to really do it like that you wouldn't have constructors for GetChar/PutChar, but some other basic I/O primitives that would perform better than that :P
11:54:08 <Cale> (as well as something to provide details for an FFI call)
11:54:29 <Cale> Ohso_: In principle that seems reasonable.
11:54:38 <shachaf> Ohso_: Yes, with a lens.
11:54:42 <Zemyla> Well, my goal is to write a Data.Vector.Unboxed instance for GHC.Integer, so if it wasn't built with GMP, probably just have the Unbox instance be a wrapper around Data.Vector.Vector Integer.
11:54:43 <Cale> Ohso_: You ought to be able to write a function (Foo -> Foo) -> Foo2 -> Foo2
11:54:57 <Cale> (maybe with a lens, or just directly)
11:54:58 <shachaf> A Lens' S A is an isomorphism exists e. S <-> (e,A)
11:56:26 <sinelaw> Is there a sane way to get Ord for STRef?
11:56:26 <shachaf> Yes, of course you can do it directly. Or you can write a function :: (Foo -> f Foo) -> Foo2 -> f Foo2, which is a generalization of what Cale said and a good representation of a lens.
11:56:26 <Ohso_> Ah, (Foo -> Foo) -> Foo2 ->    ‚îÇ `0660
11:56:26 <Ohso_>                       | Foo2
11:56:26 <Ohso_> oops, sorry. That function signature looks like what I needed. Thanks
11:56:27 <shachaf> It's just that a lens represents exactly "a tyep Foo2 that is made up of a Foo and some other stuff" by definition.
11:57:17 <Cale> shachaf: Yeah, I just figured that if you're asking that question, you're probably not quite ready for lenses yet :)
11:57:29 <Zemyla> Well, here's a simple way to think of Lenses.
11:57:34 <shachaf> Fair enough.
11:57:43 <Ohso_> Thanks, yeah don't know what a lens is.
11:57:53 <Zemyla> Imagine a lens as the type data Lens' s a = Lens' { get :: s -> a, set :: s -> a -> s }.
11:58:26 <Cale> Ohso_: They're things that let you refer to a part of a data structure and get/set it (in a non-mutating sort of way)
11:58:34 <Ohso_> shachaf: What's with the extra f in the signeture you gave?
11:58:49 <Ohso_> signature, sorry
11:59:07 <Cale> Ohso_: and they compose, so you can take a lens which gets a field of type C in a structure of type B, and a field of type B in a structure of type A, and glue them together into a lens which gets a field of type C in a structure of type A.
11:59:09 <shachaf> It lets you do a bunch of extra things, like read the value, if you're into that.
11:59:16 <shachaf> But you don't have to worry about it.
11:59:31 <shachaf> It seems that Cale has convinced me not to talk about lenses, and I've convinced Cale to talk about them.
11:59:37 <Cale> lol
12:00:11 <EvanR> first rule of lens club
12:00:25 <EvanR> talk about not talking about lens club
12:00:26 <shachaf> Anyway I think the isomorphism view of lenses has a lot of advantages over the getter/setter view. Especially when it's what this person asked for in the first place.
12:00:36 <Cale> EvanR: hahaha
12:01:23 <Zemyla> shachaf: Yeah, it does, because it means they compose with prisms, traversals, and other crazy stuff. However, this is just a simple overview.
12:01:28 <shachaf> I also think four-parameter lenses (s t a b) are much easier to think about than two-parameter lenses, though some people disagree.
12:01:53 <Ohso_> I have a headache
12:02:02 <shachaf> Zemyla: No, even when you're just talking about lenses. The fact that lenses compose, for instance, is obvious -- it's just associativity of (,).
12:03:28 <Zemyla> You can compose two lenses with compose :: Lens' s a -> Lens' a b -> Lens' s b; compose (Lens { get = getA, set = setA }) (Lens { get = getB, set = setB }) = Lens { get = getB . getA, set s b = setA s (setB (getA s) b) }.
12:06:27 <AleXoundOS> Hi. I have a function of this type:
12:06:30 <AleXoundOS> frameReader :: (MonadIO m, MonadError String m) => AVPixelFormat -> InputSource -> m (IO (Maybe AVFrame), IO ()) 
12:06:57 <AleXoundOS> What literature would you recommend me in order to understand how to use this function?
12:07:35 <EvanR> the documentation?
12:07:37 <AleXoundOS> This major difficulties are with MonadIO and MonadError.
12:07:51 <AleXoundOS> EvanR, not documentation, I mean theory
12:08:18 <AleXoundOS> I don't understand how to get AVFrame out of this structure
12:08:21 <EvanR> you can replace m with any MonadIO, for example IO
12:08:31 <Cale> AleXoundOS: That just means that if m is any monad which is both an instance of MonadIO and an instance of MonadError String, you're allowed to choose that m
12:08:48 <Cale> I don't think IO is an instance of MonadError String though.
12:08:51 <EvanR> (that is also an instance of MonadError String)
12:08:52 <Cale> is it?
12:09:01 <EvanR> i dont know, whats MonadError >_<
12:09:18 <Zemyla> You know, I wonder if you could optimize the Integer library by using mutability.
12:09:19 <EvanR> last weeks preferred error monad
12:09:24 <AleXoundOS> MonadError is from Control.Monad.Error.Class library
12:10:32 <Cale> So I guess you could use ExceptT String IO, if there's nothing better to use.
12:10:33 <EvanR> AleXoundOS: to (try to) get the frame, execute the m (IO (Maybe Frame), ...) action to get a (io,_)
12:10:38 <Cale> But which library is this function from?
12:10:42 <EvanR> then execute the io to get a Maybe Frame
12:10:43 <Cale> Perhaps they give you a monad to use.
12:10:53 <EvanR> then pattern match on that to see if its nothing or not
12:10:54 <Zemyla> Like, suppose there was a type MutableInteger s, and a function create :: (forall s. ST s (MutableInteger s)) -> Integer.
12:11:44 <AleXoundOS> Cale, fromReader function is from ffmpeg-light package.
12:12:20 <Zemyla> Basically, using the same kind of unfolding that Vector has.
12:13:42 <Cale> This is really kind of an awkward type...
12:14:21 <EvanR> its designed to be used inside of a transformer stack of a certain stack
12:14:27 <EvanR> certain shape
12:14:36 * EvanR shakes fist at it
12:14:42 <Cale> Yeah, but the library doesn't give you the monad to use
12:14:50 <Cale> at least, as far as I can see
12:14:50 <EvanR> its up to you!
12:15:01 <AleXoundOS> there is also a similar function:
12:15:03 <AleXoundOS> frameReaderT :: (Functor m, MonadIO m, MonadError String m) => InputSource -> m (MaybeT IO AVFrame, IO ())
12:15:06 <Cale> But whatever
12:15:15 <EvanR> thats even worse
12:15:29 <Cale> This library is not very polished
12:15:37 <Cale> But whatever, I guess you can just...
12:15:40 <Cale> :t runExceptT
12:15:41 <lambdabot> ExceptT e m a -> m (Either e a)
12:16:12 <Cale> and treat the "m a" in these as ExceptT String IO a
12:16:35 <Cale> and that'll get you an IO (Either String ...)
12:16:47 <Cale> which you can run, and then pattern match on the possible error
12:18:03 <AleXoundOS> thank you, I will try to realize these ideas
12:18:21 <Cale> so it'll look like
12:18:52 <cheater> is it a good idea to use MultiParamTypeClasses?
12:18:57 <Cale> do eResult <- runExceptT (frameReader dstFmt input)
12:19:01 <cheater> or is it covered in dust?
12:19:01 <Cale>    case eResult of
12:19:07 <Cale>      Left err -> ...
12:19:15 <EvanR> cheater: its used pretty extensively in libraries
12:19:36 <Cale>      Right (something, something) -> ...
12:19:51 <Cale> I'm not sure what the two actions you get back from frameReader are supposed to do
12:19:54 <cheater> thanks EvanR
12:19:57 <Ohso_> sweet, I was able to convert my collection functions to another type.  :)
12:20:20 <AleXoundOS> Cale, aha, ok, thank you, I know the actions
12:20:21 <cheater> EvanR: is it used exclusively with fun deps?
12:20:32 <EvanR> no, you can use associated types
12:20:33 <Cale> ah, they get the next available frame, and free the stream
12:20:39 <Cale> (respectively)
12:20:47 <AleXoundOS> right:)
12:20:49 <EvanR> cheater: whether its a good idea to use... thats the sort of the same question as whether its a good idea to use type classes
12:21:30 <EvanR> at all
12:23:00 <Cale> cheater: It's pretty common for MPTCs and functional dependencies to go together, and slightly uncommon, though not unseen, to use MPTCs and type families together.
12:23:39 <pyon> Is there some IO action for loading a file in the REPL?
12:23:43 <EvanR> is it totally impossible to use MPTCs without either?
12:23:47 <Cale> (the reason being that usually you have one main type that everything else can be determined from, in which case your associated types just use that as their single parameter, and you only need a single parameter type class)
12:23:58 <Cale> It's not impossible
12:24:14 <fraac> this is weird, is it not possible to case match against a variable value?
12:24:28 <EvanR> a binary relation between types seems useful, but functional deps kind of makes that not that
12:24:31 <Cale> fraac: pattern matching binds variables
12:24:34 <pyon> EvanR: Type families seem more like a replacement for the combination of MPTCs and functional dependencies.
12:24:40 <Cale> fraac: Perhaps you want a guard that tests for equality?
12:24:44 <EvanR> pyon: right
12:25:03 <fraac> Cale here I have a go function within a where clause
12:25:07 <EvanR> pyon: readFile ?
12:25:18 <EvanR> or do you want to :load or :import code
12:25:39 <fraac> within that go function is a case condition. one of the case conditions is meant to match a variable from the outer function
12:25:57 <fraac> Cale probably a guard is the way to go. is there no way to do that without guards?
12:26:35 <pyon> EvanR: Load code.
12:26:39 <pyon> EvanR: Using an IO action.
12:26:48 <Cale> well, there's something even more awkward
12:26:51 <EvanR> oh, modify ghci using haskell code
12:26:52 <pyon> EvanR: Maybe not available in compiled programs, but it would be very useful in the REPL.
12:26:59 <EvanR> that would be nice
12:27:45 <EvanR> pyon: whats the use case specifically?
12:27:46 <fraac> Cale more awkward?
12:27:54 <Cale> You could use the ViewPatterns extension :P
12:28:52 <Cale> > let x = 5; f ((== x) -> True) = 0; f _ = 1 in map f [1..10]
12:28:52 <EvanR> fraac: the pattern x in haskell introduces a new variable, shadowing any previous x, and it always matches whatever. haskell doesnt have a pattern which compares values for equality by use a variable
12:28:54 <lambdabot>  [1,1,1,1,0,1,1,1,1,1]
12:28:58 <pyon> EvanR: Load different code into the REPL, on different systems.
12:29:09 <pyon> EvanR: Without using the atrocious C preprocessor in Haskell source code.
12:29:12 <Cale> I think that's significantly worse than using a guard, and it requires an extension
12:29:22 <EvanR> pyon: editors have ways to controlling ghci, i would look into that
12:29:27 <pyon> Ah!
12:30:33 <EvanR> elixir does though
12:30:54 <EvanR> (allow you to use a variable in a pattern to stand for the value of something in the pattern)
12:31:18 <EvanR> arguably thats not really a pattern anymore
12:33:04 <fraac> EvanR ah that is tricky
12:34:18 <ski> EvanR : presumably because Erlang does (which got it from Prolog)
12:34:27 <fraac> yet agian... warning messages important :|
12:34:48 <EvanR> does erlang or prolog let you repeat variables in a pattern?
12:35:29 <ski> Prolog does for sure (there's no difference between patterns and terms there)
12:35:38 <Cale> Well, as I just demonstrated, Haskell actually *does* have a pattern which compares equality... but it's ugly
12:35:47 <EvanR> well you have to put a == in
12:35:59 <EvanR> might as well use a guard
12:36:00 <ski> yes, Erlang also allows it
12:36:04 <Cale> Actually we could create a pattern synonym
12:36:41 <cheater> EvanR: are associated types and type families the same thing?
12:36:46 <EvanR> yes
12:37:52 <c_wraith> I think the relationship is that associated types are type families or data families declared in a class. 
12:37:55 <cheater> thank you
12:38:19 <cheater> when did that come into ghc?
12:38:49 <c_wraith> early 6.x, I think. 
12:39:21 <c_wraith> I know they were present but somewhat new when I started, which was on 6.8
12:39:21 <cheater> same time as type families, right?
12:39:25 <c_wraith> yes
12:39:28 <cheater> thanks
12:40:18 <pyon> ski: But Prolog isn't higher-order. You can repeat variables in patterns because equality testing is decidable for the thingies that you can supply as arguments to predicates.
12:40:48 <pyon> I guess it would be nice if Haskell would let you repeat variables, and automatically infer an Eq constraint, though.
12:41:00 <EvanR> why would it require an Eq constraint?
12:41:31 <EvanR> hrm
12:41:55 <Cale> EvanR: because obviously you can't compare things otherwise
12:42:04 <pyon> EvanR: Suppose Haskell let you do this: ‚Äúfoo x x = True ; foo x y = False‚Äù. Then ‚Äúfoo‚Äù should have type ‚ÄúEq a => a -> a -> Bool‚Äù.
12:42:07 <dolio> Miranda allowed it.
12:42:08 <EvanR> thats not obvious
12:42:10 <ski> pyon : except people simulate higher-order stuff all the time in it ..
12:42:15 <Cale> It would be "nice", but there are some really confusing cases
12:42:18 <pyon> ski: Yes, and that's painful.
12:42:31 <Cale> There are good reasons it wasn't adopted by Haskell
12:42:39 <dolio> I imagine lambda prolog allows it.
12:42:50 <EvanR> if you repeat variables in idris they either unify or not, so this isnt Eq constraint
12:42:50 <ski> yes
12:42:56 <EvanR> just saying
12:43:17 <ski> but unification in lambdaProlog isn't complete. it'll warn in cases where it won't necessarily compute all solutions
12:43:35 <pyon> dolio: Œª-Prolog also has issues. It isn't truly higher-order. It implicitly uses first-order names to refer to predicates. Think C function pointers - they can be different even if they point to extensionally equal functions.
12:44:16 <pyon> s/first-order names/a ground type of names/
12:44:19 <ski> pyon : that's because predicates are open in lambdaProlog
12:45:06 <dolio> I don't think it matter if it has first class predicates.
12:45:26 <dolio> It has lambda terms, which are higher order, no?
12:46:00 <ski> if you define `p 0.' and also `q 0.', then you still can't claim that `p' and `q' are equal, since you're free to assume e.g. `p 1' as a local assumption, any time you like
12:46:08 <pyon> dolio: IIUC, they still range over function names, rather than over functions themselves.
12:46:25 * ski isn't sure they're following what pyon is after
12:46:36 <Cale> EvanR: Yeah, but that's using the unification of values at the type level which Haskell has no concept of.
12:47:01 <pyon> ski: Yep, that's exactly the problem.
12:47:13 <pyon> IOW, modularity.
12:47:29 <dolio> Cale: It's also much more limited, I assume. It only works if the two things are provably identical statically.
12:47:36 <Cale> right
12:47:37 <ski> pyon : it would be interesting with a logic programming system which allowed you to have both open and closed predicates
12:47:48 <dolio> It's not non-linear pattern matching.
12:48:01 <dolio> 'Match this case when these two are equal.'
12:48:05 <EvanR> provably identical either through reducing and comparing, or using theorems
12:48:28 <pyon> ski: A while back I found a blog post about a nicer take on making Prolog higher-order. It was even implemented in Haskell! https://billwadge.wordpress.com/2016/01/18/extensional-higher-order-prolog/
12:48:43 <ski> the (=)/2 predicate in Mercury is required to be sound wrt semantic equality. this (and some other things) means that they can handle quotient types in a nicer way
12:48:44 <EvanR> which might be "trust me"
12:48:47 <EvanR> like primitives
12:49:02 <ski> pyon : ty
12:49:08 <pyon> :-)
12:49:21 <Cale> EvanR: the fall-through in the case that they don't happen to compare as identical even though they might evaluate to the same thing is kind of ugly.
12:49:59 <EvanR> oh i wasnt really thinking of case
12:50:24 <dolio> Wait, is idris actually letting you do case analysis on whether the definitional equality thinks two things are equal?
12:50:28 <dolio> Because that sounds terrible.
12:50:35 <EvanR> no
12:50:47 <dolio> Okay.
12:50:57 <dolio> It's like normal dependent pattern matching, then?
12:51:13 <dolio> Where non-linear occurrences mean that there is evidence that they are equal.
12:51:23 <EvanR> yes
12:51:31 <dolio> And it can't fail.
12:51:41 <EvanR> it can fail to type check
12:52:06 <Cale> Right, right
12:52:07 <EvanR> but it cant conditionally fail to type check
12:52:12 <dolio> Whether the values in those positions are equal or not cannot cause the pattern to fail, I mean.
12:52:25 <ski> basically, you define a quotient type in Mercury by something akin to `newtype Abstract = Project Representation' in Haskell, except that you also specify a binary predicate on the `Representation' type (which is required to be an equivalence relation), which will be used as the implementation of (=)/2 (on the `(in,in)' mode) on the (so to speak) `Abstract' data type
12:52:38 <black0range> Hello! Sorry to bother you but I cannot wrap my head around cabal dpendencies error messages, how do i solve this? https://lambda.sx/MXL#890645u7
12:52:52 <dolio> If the real pattern matches would succeed, it is impossible for the non-linear occurrences to not be identical.
12:52:56 <Cale> You can't have  foo x x = 0; foo x y = 1  in Idris
12:53:00 <ski> in this case, the data constructor `Project' will not be injective (and so matching on it will be (semantically) non-deterministic, which is handled by the determinism system nicely), though it is surjective, of course
12:53:26 <Cale> Well, it would be an overlapping pattern, since if the foo x x were accepted, then foo x y would be redundant.
12:53:47 <dolio> Right. That one's like (old) Agda. :)
12:53:54 <dolio> Shadow in the same argument list.
12:54:29 <ski> (there is also a "promise" pragma, where one can promise that some (internal) non-determinism, due to peeking at the representation value, doesn't matter, and so declare a predicate (or function) deterministic anyway)
12:54:32 <Cale> black0range: What are you trying to build?
12:54:51 <ski> dolio : Agda1 ?
12:55:04 <black0range> Cale: transformers 0.4.3.0
12:55:07 <dolio> ski: No, I mean non-current versions of Agda2.
12:55:12 <joncfoo> anyone know if you can get `stylish-haskell` to recognize enabled extensions from the cabal file instead of from the top of the source file?
12:55:14 <Cale> black0range: I mean more generally
12:55:28 <dolio> It might still have that behavior. I haven't checked in a while.
12:56:06 <ski> (in comparion, quotient types are more problematic in Prolog, since when comparing them by unification, you'll automatically get the structural equality on the representation. so you have to be careful to never accidentally do such implicit comparision)
12:56:08 <Cale> black0range: transformers-0.4.3.0 requires an older GHC than what you have installed
12:56:18 <Cale> black0range: So probably you don't want to install it.
12:56:35 <Cale> (or if you really must, you'll have to downgrade your GHC)
12:57:24 <Cale> It's probably easier not to do that and either install a newer version of whatever depends on transformers-0.4.3.0 or relax its version constraints so that it'll use a newer one.
12:57:38 <Cale> (probably the new one will be compatible anyway)
12:57:57 <black0range> Cale: Oh, nah the lower ghc is becasue of depencencies with friday, I'll see if i can relax its constrains :) Thanks! 
12:58:55 <seivan_> regarding Parsec, are the >>-, >>> and >>= operators standardized somehow? Because constantly see different operators used for the same purpose? Trying to reimplement Parsec in Swift with my own flavour
12:59:29 <EvanR> :t (>>-)
12:59:30 <lambdabot>     Not in scope: ‚Äò>>-‚Äô
12:59:31 <lambdabot>     Perhaps you meant one of these:
12:59:31 <lambdabot>       ‚Äò>>‚Äô (imported from Control.Monad.Writer),
13:01:12 <geekosaur> where are you seeing these exactly?
13:02:55 * hackagebot octane 0.13.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.13.0 (fozworth)
13:03:12 <AleXoundOS> Cale, thank you, your solution with runExceptT works!
13:05:55 <parc> i've been banging my head against the keyboard for an hour; what am i doing wrong here: http://lpaste.net/168217
13:08:03 <cheater> seivan_: they're from arrow
13:08:12 <seivan_> cheater: Okay?
13:08:18 <cheater> >>- and >>> at least
13:08:22 <seivan_> geekosaur: Parsec
13:08:31 <seivan_> cheater: Yeah, but do they mean different things? Because I see them as synonums
13:08:39 <EvanR> >>> is from Control.Category
13:08:39 <seivan_> cheater: Also not sure to call them FlatMap or bind?
13:08:48 <cheater> yes, they mean different things
13:09:16 <EvanR> flatMap kind of makes sense... in haskell joinMap
13:09:36 <geekosaur> :t concatMap
13:09:37 <seivan_> cheater: In Parsec they seem to be used for the same thing, maybe I missed something
13:09:37 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:09:40 <ski> parc : .. does it help if you say :  Lookup k ('(k,v) : rest) = Just v
13:10:06 <cheater> if I use a MPTC with fundeps, and i have one instance of it, will i be able to make another instance as well or will that result in an error?
13:10:19 <cheater> i mean like class MyClass a b | a -> b
13:10:31 <ski> cheater : depends on the FD, and on the instance
13:10:32 <ZelteHonor> How can I write my own put and get instance for Cereal? I want to use some really low-level (binary encoding) for my data. Or should I use something like the builder in bytestring?
13:10:46 <cheater> will instance MyClass Foo Bar mean I can't make instance MyClass Foo Baz anymore?
13:10:58 <geekosaur> seivan_, Arrow is an ancestor of Applicative, and can be used for parsing in place of Monad. the operations are similar but have some key differences, notably that >>= can make choices based on a value but Arrow operations can't
13:11:05 <EvanR> cheater: you can totally make that second instance
13:11:26 <EvanR> but MyClass Foo Baz wouldnt make sense
13:11:27 <cheater> how will the type inference engine know what instance i'm talking about?
13:11:29 <ski> cheater : that logically expresses `forall a. unique b. MyClass a b', iow `forall a b0 b1. (MyClass a b0,MyClass a b1) => b0 ~ b1', iow for any given `a', there can be at most one `b' with an instance `MyClass a b'
13:11:30 <parc> ski: yes it does...i could have sworn i tried that
13:11:39 <EvanR> cheater: its smart
13:11:47 <ski> cheater : but for different `a's you can of course add instances
13:12:05 <cheater> ski: i meant for the same a
13:12:24 <EvanR> infer will go the other direction
13:12:34 <cheater> oh really?
13:12:35 <EvanR> the direction of the arrow
13:12:38 <cheater> yes
13:12:41 <cheater> that's what i mean
13:12:41 <ski> cheater : you can't have both `MyClass Foo Bar' and `MyClass Foo Baz', with that FD
13:12:48 <seivan_> geekosaur: What method name would you give it, if I am trying to avoid operator overloading? I was thinking flatMap or Bind() ?
13:13:05 <cheater> i have MyClass Foo Bar and MyClass Foo Baz, how does ghc know that if given Foo it should choose Bar and not Baz?
13:13:06 <EvanR> seivan_: its going to be really ugly...
13:13:13 <cheater> ski: ok, will that error out?
13:13:48 <ski> the FD `a -> b' there means "`a' (uniquely) determines `b'" -- compare with relational database theory (normalization, 3NF,4NF,BCNF,&c.) if you know any
13:13:52 <ski> cheater : yes
13:13:59 <cheater> OK
13:14:05 <cheater> so i have to use an MPTC without fundeps
13:14:14 <seivan_> Reading up on documentations and tutorials, I tend to see >>> sometimes, what does that mean?
13:14:20 <cheater> because i'll have an m:n relation between a and b
13:14:21 <EvanR> cheater: oh i misread your example... i didnt see two Foos, sorry
13:14:28 <cheater> np EvanR :)
13:14:43 <johnw> cheater: if you don't have an FD, be sure that both of your type class variables are used in the type of each method
13:14:59 <cheater> why?
13:15:15 <johnw> if a method is lacking a use of a type variable, GHC will be unable to infer which type class instance to use
13:15:25 <EvanR> seivan_: <<< (reversed arguments to >>>) is just generalized (.)
13:15:28 <cheater> currently my class has no methods at all. i haven't yet come up with what methods i'll need.
13:15:28 <ski> cheater : the other effect of the FD is that if you have e.g. `foo :: [a] -> [b]' in that class, and you use `foo' twice (on an input of type `[a]', then instead of inferring something like `(MyClass a b0,MyClass a b1) => [a] -> ..b0..b1..', it'll automatically get simplified into `MyClass a b => [a] -> ..b..'
13:15:30 <johnw> you'll then need to add a Proxy ? argument, solely to resolve inference
13:15:38 <EvanR> :t (<<<)
13:15:39 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
13:15:43 <EvanR> urg!
13:15:44 <seivan_> EvanR: Yeah but how come some docs don't bring it up? Is it a synonum for >>- ? 
13:15:45 <ski> cheater : also, for the same reason, you'll get less ambiguity errors
13:16:04 <EvanR> seivan_: well, its a generic operator
13:16:16 <EvanR> to read the docs, you see that some type is an instance of Category
13:16:26 <EvanR> for example + is not documented, you just see Num
13:16:28 <cheater> johnw: what's Proxy?
13:16:44 <johnw> cheater: if you end up needing it, ask me then :)
13:17:07 <seivan_> I am not being clear. Most Parsec docs/source codes seem to mix up >>>, >>>- and >>- are they the same thing?
13:17:16 <EvanR> what are their types?
13:17:18 <cheater> seivan_: sometimes you don't want to use Monad if a lighter weight class will work, because that other class might allow more optimizations.
13:17:20 <seivan_> sequence operator where the former result is kept, and the latter is discarded
13:17:33 <EvanR> >>> isnt sequence, its composition
13:18:11 <EvanR> seivan_: i see, well that explains it
13:18:21 <seivan_> >>>- is a sequence where former result is kept while >>> discards former results
13:18:26 <EvanR> oh..
13:18:30 <EvanR> then thats totally different
13:18:38 <EvanR> its not the same as standard >>>
13:18:50 <seivan_> For instance http://unbui.lt/#!/post/haskell-parsec-basics I can't find anything like >>-, >>>- and >>> there
13:18:55 <seivan_> While other docs and source codes seem to bring it up
13:18:55 <EvanR> did you try the docs?
13:19:03 <seivan_> EvanR: Yeah.
13:19:09 * EvanR tries the docs
13:19:20 <cheater> dcoutts: regarding rewrite rules, is there any plan to do something like this? you supply different rewrite strategies, and ghc tries them all, and then chooses the one giving best results depending on some criterion (that you provide, e.g. the least wrappers or boxes or everything is strict etc)
13:20:08 <EvanR> seivan_: i dont see >>> in that blog post or in the docs
13:20:16 <seivan_> EvanR: I see that in other examples
13:20:34 <EvanR> have you tried the latest version of parsec
13:21:22 <EvanR> they may have started, in ancient times, with weird operators and then standardized it to agree with other libraries and classes
13:21:23 <seivan_> EvanR: Mostly reading its source
13:21:37 <seivan_> Second question, would >>- be considered a bind() or flatMap()? 
13:21:39 <EvanR> Applicative for example might have appeared after parsec
13:21:41 <seivan_> If I'd want to avoid operators?
13:21:44 <EvanR> what is >>- ?
13:22:37 <EvanR> i do not see any of these in parsec
13:23:32 <cheater> dcoutts: so more like a heuristic search, rather than a single-track set of routings
13:24:02 <cheater> seivan_: it would be considered neither.
13:24:20 <EvanR> seivan_: can you link to docs containing these operators?
13:24:21 <cheater> seivan_: flatMap and bind are two names for the exact same thing, which is also denoted >>=. >>- is not >>=.
13:25:17 <divVerent> there really is no function to repeat a given list n times? I.e. no function with f n = concat . replicate n
13:25:53 <cheater> (take n) . replicate
13:26:06 <EvanR> nah
13:26:06 <divVerent> not quite the same
13:26:13 <divVerent> you mean (take totalCount) . cycle?
13:26:24 <cheater> oh sorry, i see now
13:26:38 <divVerent> I mean, I'm kinda disappointed that this list operation is missing in Prelude
13:26:45 <seivan_> cheater: What is >>= (is that flatMap/bind)? I am trying to find out what >>- is, so far I've seen it in parsec ports in other languages, I am wondering if it's to work around their operator issues
13:26:52 <divVerent> essentially Perl's "x" operator
13:26:55 <EvanR> a lot of prelude is missing stuff, but ive never missed that
13:27:07 <EvanR> which you can just say as concat . replicate n
13:27:16 <divVerent> sure, now the main issue is, I have to name this without using the words "repeat" and "replicate" :P
13:27:20 <divVerent> writing the function itself is easy
13:27:29 <divVerent> but replicateList is not very nice either
13:27:30 <EvanR> names are lame
13:28:05 <seivan_> cheater: EvanR I see now..
13:28:13 <seivan_> >>= and >>- are the same :)
13:28:16 <divVerent> ah, Data.Text calls this op replicate too
13:28:23 <seivan_> While >>> and >> are the same.
13:28:26 <EvanR> seivan_: lets clarify, you werent asking about haskell code ;)
13:28:34 <EvanR> very confusing
13:28:41 <seivan_> EvanR: I am really sorry
13:28:47 <seivan_> EvanR: There isn't much info about Parsec outside of the Haskell com, not sure where to look to be honest.
13:28:48 <EvanR> >>> and >> are both haskell operators, not at all the same
13:29:03 <EvanR> i suggest looking inside haskell
13:29:14 <seivan_> EvanR: No, I meant between source codes. In Applicataves/Parsec
13:29:26 <EvanR> look at parsec docs
13:29:32 <seivan_> They seem to be using >>> for >> and >>- for >>= 
13:29:35 <cheater> EvanR: you can find >>- here https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html
13:29:40 <seivan_> EvanR: I have, I am just trying to map that to other ports.
13:29:55 <EvanR> cheater: thats a totally third topic
13:30:07 <seivan_> cheater: EvanR Is right, that's different.
13:30:24 <cheater> :t (>>>)
13:30:25 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
13:30:27 <seivan_> Looks like Bind/FlatMap are annotated with different operators on other language ports
13:30:38 <cheater> :t (>>)
13:30:39 <lambdabot> Monad m => m a -> m b -> m b
13:30:55 <cheater> looks like you're not right on >>> and >> being the same
13:31:04 <EvanR> open up your other language ports and take the type of those operators and compare
13:31:17 <EvanR> cheater: >>> in another language unknown to us, and >> in haskell
13:31:34 <mkloczko> Is it possible to generate a structure of nested tuples with arbitrary length using a recursive function ? I had imagined it as something like this: f 1 = (1,0); f n = (n, f (n-1))
13:31:34 <seivan_> EvanR: yes sir.
13:31:41 <cheater> ok... dunno bout those...
13:32:04 <EvanR> mkloczko: what is the type of such a function
13:33:04 <ski> mkloczko : how do you intend to use the result ?
13:33:05 <seivan_> So >>= is a bind/flatmap. Just to be clear?
13:33:09 <EvanR> yes
13:33:14 <cheater> yes
13:33:21 <ski> (usually pronounced "bind" in Haskell)
13:33:26 <cheater> bind is what it's called in ML family langs
13:33:37 <cheater> flatMap is what it's called in /those other langs/...
13:33:42 <Squarism> Can i somehow create a Chan that is emptied as long none is reading from it? 
13:33:43 <seivan_> cheater: haha :) Alright
13:33:51 <seivan_> cheater: thanks, I would have assumed flatMap was from haskell.
13:33:57 <EvanR> Squarism: with a broadcast TChan
13:34:01 <seivan_> at least I saw fmap in Haskell.
13:34:13 <seivan_> Btw, parsec is really special, surprised I haven't seen it as much
13:34:15 <cheater> fmap is short for "functor map"
13:34:18 <EvanR> fmap is something else entirely
13:34:34 <cheater> ML flips its args and calls it >>|
13:34:34 <Squarism> EvanR, i thought TChan was for a STM scenario? I roll with MVar's
13:34:44 <seivan_> Have i confused this then "We replace the use of >>= with fmap" -> fmap not being Flatmpa(?)
13:34:54 <EvanR> Squarism: the MVar version is Chan, but the broadcast api isnt as nice
13:35:05 <EvanR> you can use STM and MVars together
13:35:15 <Squarism> ok
13:35:16 <mkloczko> ski: I'd like to do something similiar using :*: operator for generics. The intended usage is to put in through generic type class methods for tests.
13:36:26 <cheater> seivan_: fmap can replace >>= in some cases when it generates exactly one output for one input
13:36:26 <cheater> err
13:36:26 <cheater> let me rephrase
13:36:26 <cheater> seivan_: fmap can replace >>= in some cases when the function on the right of >>= generates exactly one output for one input
13:36:26 * ski isn't sure they follow
13:36:27 <EvanR> im not sure i follow
13:36:57 <EvanR> seivan_: fmap is not >>=
13:36:58 <ski> seivan_ : cheater is probably thinking of `act >>= return . f  =  fmap f act'
13:37:03 <ski> @src liftM
13:37:03 <lambdabot> liftM f m1 = do
13:37:03 <lambdabot>     x1 <- m1
13:37:03 <lambdabot>     return (f x1)
13:37:03 <seivan_> cheater: I think I got confused by the word "fmap" into believeing it stood for flatmap. I know bind is synonym with >>=
13:37:10 <cheater> [1, 2, ..] >>= \n -> repeat n 'a'
13:37:14 <mkloczko> EvanR: Uh, hard to tell. Int -> (a,b) where b could be (b,c). I imagined RankNTypes could help here
13:37:18 <seivan_> Not sure if fmap means flatmap or what you said earlier
13:37:24 <ski> `fmap' is not "flatmap", no
13:37:33 <ski> @src Functor
13:37:34 <lambdabot> class Functor f where
13:37:34 <lambdabot>     fmap :: (a -> b) -> f a -> f b
13:37:35 <cheater> seivan_: fmap is not flatmap/bind/>>=.
13:37:41 <EvanR> mkloczko: right... good try, and whats c ;)
13:37:50 <EvanR> any type?
13:37:51 <geekosaur> fmap is functor map
13:38:04 <mkloczko> EvanR: yep
13:38:10 <EvanR> mkloczko: that would give you only 2 deep
13:38:21 <cheater> > [1, 2, ..] >>= \n -> take n $ repeat n
13:38:23 <lambdabot>  <hint>:1:8: parse error on input ‚Äò..‚Äô
13:38:27 <ski> mkloczko : what you asked for requires dependent types. perhaps you can manage to do what you want in some other way, not sure
13:38:29 <cheater> > [1, 2 ..] >>= \n -> take n $ repeat n
13:38:30 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
13:38:36 <cheater> cannot be replaced by fmap
13:38:49 <cheater> > [1, 2 ..] >>= \n -> show n
13:38:52 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
13:38:58 <EvanR> mkloczko: theres a way to encode this thing in haskell but its not that pretty
13:39:02 <cheater> cannot be replaced by fmap either
13:39:16 <cheater> > [1, 2 ..] >>= \n -> head $ show n
13:39:18 <lambdabot>      Couldn't match expected type ‚Äò[b]‚Äô with actual type ‚ÄòChar‚Äô
13:39:18 <lambdabot>      In the expression: head $ show n
13:39:18 <lambdabot>      In the second argument of ‚Äò(>>=)‚Äô, namely ‚Äò\ n -> head $ show n‚Äô
13:39:31 <cheater> > [1, 2 ..] >>= \n -> return.head $ show n
13:39:32 <lambdabot>  "123456789111111111122222222223333333333444444444455555555556666666666777777...
13:39:43 <cheater> right. this can be replaced by fmap:
13:40:01 <cheater> > (\n -> head $ show n) <$> [1, 2 ..]
13:40:01 <EvanR> cheater: i think this discussion about replacing >>= with fmap is drifting into nonsense, whatever theyre reading is probably misleading
13:40:02 <lambdabot>  "123456789111111111122222222223333333333444444444455555555556666666666777777...
13:40:03 <mkloczko> EvanR: I'd be happy to see it. Does it rely on Template Haskell ?
13:40:11 <EvanR> mkloczko: no, type classes
13:40:34 <EvanR> but a long nest of tuples has other equivalent formulations
13:40:47 <EvanR> also using type classes
13:40:56 <cheater> EvanR: there was talk about replacing >>= with fmap, i was demonstrating what it means, no idea why that's nonsense..
13:41:18 <EvanR> cheater: yeah the phrase "replace >>= with fmap" continues to be stated repeatedly
13:41:22 <EvanR> thats about it
13:41:38 <cheater> ok well here was my way of understanding it
13:44:26 <mkloczko> EvanR: Cool! How do i do that ?
13:46:19 <EvanR> class CreateNestedTuplesFromNumber n a where
13:46:32 <EvanR> instance CreateNestedTuplesFromNum 0 EndOfList where
13:47:56 * hackagebot dot-linker 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/dot-linker-0.1.0.0 (pjrt)
13:48:19 <bernalex> 'flatmap' is a really odd name. why do people call it that?
13:48:36 <bernalex> it's so arbitrary.
13:48:38 <EvanR> instance CreateNestedTuplesFromNum n b => a ~ (b,c) => CreateNestedTuplesFromNum (n+1) a where
13:48:41 <EvanR> hrm this isnt right
13:48:50 <dolio> Why is it called concatMap?
13:49:05 <bernalex> dolio: I mean the scala people who call >>= flatmap.
13:49:23 <EvanR> flatten is a common operation for trees of arrays
13:49:24 <bernalex> dolio: concatMap/flatMap in itself is fine. it maps and flats/concats.
13:49:37 <dolio> That's what (>>=) does.
13:49:37 <bernalex> but calling >>= flatMap is just really odd.
13:49:49 <EvanR> its because flatMap also works for Option in scala
13:50:00 <Cale> Well, it's not odd if your main examples of (>>=) are lists and trees
13:50:01 <cheater> bernalex: because flatMap can be made out of the functions "flat" and "map".
13:50:09 <bernalex> cheater: but they use it generically for everything.
13:50:14 <bernalex> sorry Cale ^
13:50:19 <cheater> map is your usual map, and flat :: m (m a) -> m a
13:50:43 <cheater> so you'd first map, and then flatten once. that's why it's called flatmap.
13:50:43 <Cale> bernalex: Yeah, but that's how names for abstract things are formed -- by taking something related to an example
13:50:44 <bernalex> it's as silly as saying mappend for Monoid a => a -> a -> a! oh. wait.
13:50:57 <mizu_no_oto_work> seivan_: just because no-one else has mentioned it, fmap is a more generic version of map.  'map' was reserved for lists, because of 'beginner friendliness', so they just threw a f onto the front because the typeclass for mapping is called Functor (due to some mathematical abstract nonsense)
13:51:06 <bernalex> Cale: that's still dumb. why don't we just s/Functor/List/?
13:52:02 <ski> (iirc, "functor" was borrowed from logic)
13:52:02 <EvanR> its is actually dumb is scala or is flatMap used for stuff that makes sense
13:52:07 <bernalex> using a completely specific name for a generic operation is just really confusing and annoying to me.
13:52:25 <bernalex> which is why I dislike mappend too.
13:52:29 <Cale> Well, some functors are a bit too not-quite-list-like to admit that, I suppose.
13:52:40 <Cale> I mean, it almost works.
13:52:46 <cheater> there's always a way to be upset about names
13:52:47 <mizu_no_oto_work> seivan_: It's 'beginner friendly' because beginners don't get more complex type errors when they first learn how to map lists
13:52:56 <bernalex> Cale: do you think that >>= are 'flatMap'?
13:53:16 <EvanR> is joinMap better?
13:53:17 <bernalex> mizu_no_oto_work: which, ironically, has provet to confuse plenty of beginners. I guess it depends on their background.
13:53:27 <Cale> I don't hate calling it that. Especially since you always have x >>= f = join (fmap f x)
13:53:42 <bernalex> EvanR: EvanR getLine `joinMap` putStrLn -- wat??
13:53:44 <Cale> So there's always a way to interpret the word "flat" such that it works
13:53:51 <mkloczko> EvanR: thanks!
13:53:54 <EvanR> bernalex: whats join?
13:54:00 <Cale> :t join
13:54:01 <lambdabot> Monad m => m (m a) -> m a
13:54:01 <EvanR> whats a better name for join
13:54:16 <johnw> Œº?
13:54:23 * ski suggested `scaffold :: Comonad w => w a -> w (w a)'
13:54:23 <EvanR> micromap
13:54:24 <Cale> ^^ this is always going to be around, and it's an abstract kind of "flattening"
13:54:32 <mizu_no_oto_work> seivan_ bernalex: it's beginner friendly in that it makes it easier to teach a semester of Haskell (where you might not mention fmap).  It's beginner unfriendly in that it makes the second step (learning fmap) a bit more confusing.
13:54:58 <mizu_no_oto_work> dolio: wasn't map the same as fmap in Haskell 1.4?
13:55:02 <bernalex> mizu_no_oto_work: yes. I think the latter is very serious. I don't believe in optimising for the first week of the learning curve.
13:55:13 <dolio> mizu_no_oto_work: fmap was called map.
13:55:18 <EvanR> bernalex: yeah, weed em out! ;)
13:55:19 <mizu_no_oto_work> right
13:55:30 <EvanR> if they cant handle big words they dont need to continue
13:55:36 <bernalex> EvanR: that's not what I, nor anyone else said.
13:55:44 <EvanR> i just did
13:56:09 <EvanR> half serious, since that will happen
13:56:47 <bernalex> EvanR: I just don't think that depriving someone of the deeply insightful truth in favour of making the elevator pitch is a good idea.
13:56:49 <mizu_no_oto_work> bernalex: I think the tradeoffs there might have been a bit different back in '98.  Regardless, it's certainly a bad tradeoff now.
13:57:16 <cheater> i just wish i could type ++ instead of `mappend` because that's so huge.
13:57:33 <EvanR> i use ++ when defining Monoid 
13:57:35 <bernalex> for quite a lot of people, the time wasted on needless confusion, is much longer than the time "gained" by by buying into a perhaps more easily immediately understood version of the truth.
13:57:39 <EvanR> for explanatory purposes
13:57:42 <bernalex> cheater: <>.
13:57:51 <mizu_no_oto_work> > [1,2,3] <> [4,5,6]
13:57:52 <EvanR> <> doesnt invoke anything special to anyone but us
13:57:53 <lambdabot>  [1,2,3,4,5,6]
13:57:53 <cheater> mm yeah..
13:57:56 * hackagebot cryptohash-sha256 0.11.100.1 - Fast, pure and practical SHA-256 implementation  https://hackage.haskell.org/package/cryptohash-sha256-0.11.100.1 (HerbertValerioRiedel)
13:58:11 <bernalex> EvanR: that's not true. it looks quite a bit like what I'd expect it to do from maths.
13:58:12 <cheater> i keep forgetting that, because it has nothing to do with adding :S
13:58:13 <Cale> EvanR: Except for some other programmers for whom it means "not equal to"
13:58:18 <mizu_no_oto_work> EvanR: It should clearly be <+>
13:58:33 <bernalex> cheater: neither does mappend.
13:58:36 <EvanR> bernalex: the diamond operator symbol? wtf does that do
13:58:42 <EvanR> modal logic
13:58:46 <monochrom> and ++ invoke the wrong special thing to anyone not among us.
13:58:47 <mizu_no_oto_work> simply because (+) doesn't parse right
13:58:49 <bernalex> cheater: <> could be e.g. multiplication.
13:59:15 <bernalex> EvanR: <> is used in e.g. category theory for the exact same thing it is used for by us in haskell.
13:59:16 <cheater> do idris or agda have axiom of choice for countable types?
13:59:17 <dolio> ++ increments something, right?
13:59:22 <monochrom> yeah!
13:59:37 <Cale> Also, it's a bit weird that somehow it's normal to *add* strings rather than multiply them, since the operation isn't commutative.
13:59:42 <bernalex> EvanR: in abstract algebra I mostly see „Éª instead of a diamond though.
13:59:50 <monochrom> concatenation in C is called "strcat", and concatenation in Java is called "+".
13:59:51 <Cale> Usually we reserve addition-looking-things for commutative operations
14:00:02 <monochrom> So, dare I say, <> is no worse than ++
14:00:09 <maurer> cheater: Perhaps you should ask in #idris or #agda
14:00:16 <EvanR> multiplication is usually more complicated than appending strings
14:00:21 <cheater> i was wondering if someone here knew, i'll ask there
14:00:39 <bernalex> I always use <> instead of ++. <> = less refactoring when changing to a different string type. because haskell. lol.
14:01:05 <monochrom> I would love to have <> in Prelude so I don't always have to import Data.Monoid
14:01:09 <cheater> my main question was, i was wondering if given a small program in haskell where i can't populate some types due to missing AC, whether i could easily do that in a prover language, with minimal changes to the program.
14:01:18 <EvanR> bernalex: which would also be true if (++) = (<>) and you used ++
14:01:23 <Cale> Yeah, I'm really happy to have (<>) in Haskell, and it does deserve to be in the Prelude.
14:01:26 <maurer> cheater: I don't know about idris, but I suspect that it is present in Agda due to its Martin-Lof heritage
14:01:32 <bernalex> monochrom: it should have been there. but people just whine about their fairbairn threshold.
14:01:55 <maurer> cheater: However, if you're trying to write an actual program you can't write in haskell, you will not be able to write it in agda
14:02:03 <cheater> maurer: why?
14:02:05 <maurer> Haskell will allow you to write strictly more programs than agda will
14:02:09 <bernalex> EvanR: it would also be true if lulz = (<>) and I used `lulz`; I don't see the relevance.
14:02:11 <cheater> oh, how so?
14:02:13 <Squarism> as there is newBroadcastTChanIO (created in IO monad), arent there corresponding read - write methods in IO too?
14:02:27 <maurer> there's a straightforward erasure transformation between any agda code which typechecks and haskell code
14:02:29 <bernalex> maurer: that depends on the definition of "can't".
14:02:31 <EvanR> bernalex: i dont see the relevance of lulz either
14:02:33 <maurer> well, not _that_ straightforwards
14:03:00 <EvanR> Squarism: sorry, youll have to wrap it in atomically
14:03:15 <cheater> Squarism: because the idea behind STM is to perform reads and related writes in a single transaction, and a single IO action will be a complete transaction, you can't have multiple IO actions in a single STM transaction.
14:03:22 <EvanR> Squarism: newBroadcastTChanIO is there to facilitate top level TVar hax, which makes not much sense for reads
14:04:47 <EvanR> Squarism: and on the subject of STM, yeah, STM is really not doing IO, so its good its not in the IO monad
14:05:03 <EvanR> too bad more stuff isnt
14:05:50 <Squarism> ok ok.. ill see what i can do. Will sheer willpower
14:05:54 <EvanR> its not doing I/O so its good that it doesnt use the IO type as part of its DSL
14:06:13 <Squarism> With even
14:15:13 <seivan_> EvanR: cheater https://groups.google.com/forum/#!topic/elm-discuss/rAfKkv2w1GU
14:17:57 * hackagebot werewolf 1.4.0.0 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.4.0.0 (hjwylde)
14:22:28 <EvanR> seivan_: in this case it actually helps because when youre doing FRP, which mostly doenst let you >>= signals, it gives you an idea of how elm thinks of signals at all
14:22:38 <EvanR> which is not a standard thing across FRP
14:22:57 * hackagebot werewolf-slack 1.0.1.4 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.4 (hjwylde)
14:23:32 <Squarism> TChan seems to work well
14:23:37 <Koen_> there's gonna be a conference on the werewolf game at the computer olympiads in Leiden
14:24:21 <Squarism> Koen_, Ultimate Werewolf Daybreak?
14:24:32 <Koen_> hum I was thinking more like the social card game
14:24:38 <Koen_> you might know it as "mafia"
14:24:46 <Squarism> ...or One night ultimate Werewolf
14:25:01 <Squarism> well those are the same arent they?
14:25:19 <Koen_> though maybe you're the one who's right and I extrapolated on their schedule, it only said "the werewolf game"
14:25:27 <Koen_> oh
14:25:35 <Koen_> I don't know, I've never heard it called it that way
14:31:06 <hexagoxel> "error: Multiple declarations of ‚Äò$t9FOllBx5bHn3J2CRjxOsK6‚Äô" welp, DeriveDataTypeable can't handle (datakind-lifted) phantom types?
14:38:59 <EvanR> hexagoxel: collision?
14:39:11 <EvanR> or its just doing it wrong
14:39:43 <hexagoxel> yeah, when i try to define instance for roughly (Foo 'True) and (Foo 'Bar)
14:41:04 <hexagoxel> i guess instance Typeable x => Foo x _is_ the correct path, even though the typeable does not make much sense to me.
14:41:28 <hexagoxel> and that runs into trouble as well, later on.
14:42:01 <hexagoxel> so s/correct path/less failing path/
14:49:25 <Zemyla> Rrgh, I want to make a tiny change to base but I can't because I'm on Windows and I don't have the proper compiler for it. D:
14:52:03 <Zemyla> The stimes function for NonEmpty should be stimes n _ | n <= 0 = error "stimes: NonEmpty: expective positive argument"; stimes 1 bs = bs; stimes n (b:|bs) = b:|(bs ++ stimes (n - 1) (b:bs))
14:53:16 <quchen> Zemyla: We should be careful with "tiny changes to Base". What's wrong with the current definition?
14:54:04 <honeymead> can you use lenses to modify each element of a list in a record with the another value from the record?
14:54:07 <Zemyla> Nothing, it's just inefficient.
14:54:09 <ski> sharing, perchance ?
14:55:47 <sveit> Is it true that, after {newtypes, multiparamtypeclasses, typefamilies, gadts, constraintkinds} are added to Haskell, Haskell has equivalent functionality to OCaml functors/modules? The main missing feature might be first-class modules, since typeclass instances cannot be created in code as far as I know. As a follow-up, is the Haskell answer to functors just wrapping every new instance in a newtype?
14:56:23 <EvanR> i would be interested in see ocaml functors/modules done in haskell somehow
14:56:52 * ski . o O ( s/ocaml/ML/ )
14:57:52 <Habib> Why does the plugins package have trouble importing IO actions or functions that return them/
14:57:53 <sveit> I was getting jealous, but given the extensions I listed above I don't see any serious functionalities missing... Perhaps i should also add generalizednewtypederiving to that list to be complete
14:57:55 <EvanR> but i havent had much success trying to use type classes for serious "different implementations" design strategy, instead the record of functions works out 
14:57:58 <monochrom> no, typefamilies is the main thing you need to do ML functors.
14:58:02 <Tene> sveit: There's some work going on to add an ocaml-style solution: https://ghc.haskell.org/trac/ghc/wiki/Backpack
14:58:14 <quchen> Zemyla: You're probably right, seeing that the default for stimes is exponentiation by squaring. Here's how you could proceed: 1) ask the former maintainer of Semigroups for his opinion (was it Edward?), 2) ask the libraries@ mailing list, 3) profile both solutions to prove the one is actually less efficient, 4) Do the patch, post it on Phab, wait for code review
14:58:21 <quchen> ‚Ä¶ in no particular order.
14:59:08 <quchen> Zemyla: The problem with changing Base is that it might introduce very subtle changes that distribute over a *lot* of Haskell programs, so we should not change it light-heartedly.
14:59:45 <bernalex> preferably 3 before 4, to make 4 easier/quicker. preferably 1 before the others, because maybe edwardk can save you quite a bit of work by showing you why you're wrong. :)
15:00:00 <quchen> One thing to also keep in mind is that some inefficient implementations may be very good for certain input sizes, for example.
15:01:18 <quchen> EvanR: Records of functions are essentially what typeclasses are.
15:01:28 <quchen> Well, records of values.
15:02:01 <quchen> I think there's a post by Simon Meier where he talks about the Service Pattern, which makes good use of not-typeclasses-but-records.
15:02:42 * ski notes that ML modules can also contain types
15:03:05 <bergmark> oh random thing i also read :-)
15:03:18 <sveit> ski: but that's "solved" by typefamilies, right?
15:03:57 <acowley> Any shm users here?
15:04:08 <EvanR> quchen: they are mechanically, but practically its a big difference to usability
15:04:21 <ski> sveit : i'm not aware of it, but possibly. perhaps you can elaborate, or provide a link ?
15:04:45 <bernalex> acowley: I wish I were. not that it helps you. but I wish I could easily use shm.
15:04:46 <ski> (if anything, i thought it was "solved" by existentials)
15:04:52 <EvanR> you cant make instances at runtime (in any obvious way), the type system for getting them to do what you want is hugely more complex
15:05:02 <acowley> bernalex: It's almost fantastic
15:05:05 <Shou> Is there a way to do "class (A a | B a) => C a where ..." for either one constraint or another?
15:05:13 <seivan_> What is a permutation?
15:05:24 <bernalex> acowley: evil user here. it's no good with evil. and too much work to make it less no good.
15:05:27 <acowley> bernalex: But boy does it want to bite you when you look at it hte wrong way
15:05:27 <thimoteus> a bijection
15:05:28 <quchen> EvanR: Sure, the two approaches serve different purposes in practice. It's just that "typeclasses as records" is not something new.
15:05:30 <ski> Shou : there isn't, afaik
15:05:30 <bernalex> acowley: I like the idea though.
15:05:48 <bernalex> acowley: try #haskell-emacs and #haskell-ide.
15:05:53 <acowley> bernalex: Yeah, sometimes it is so, so right. Paired with intero it is on the cusp of greatness
15:06:01 <acowley> There are too many channels :/
15:06:12 <bernalex> acowley: I don't use intero either. I'm the 1% that actually has a working ghc-mod. :-P
15:06:17 <quchen> seivan_: You get a permutation of something by reordering its components. A permutation of (1,2,3) would be (1,3,2) for example.
15:06:20 <acowley> I used ghc-mod for years
15:06:35 <ski> seivan_ : a bijection from a set/type to itself. in case of a finite set/type, sometimes one expresses it as a finite list listing each element/inhabitant exactly once
15:06:39 <acowley> And am part of the 1% of the 1% who went from a working ghc-mod to intero!
15:06:55 <EvanR> quchen: good for intuition, bad for getting things done in a nice way
15:07:18 <quchen> Not sure what's bad about it.
15:07:22 <EvanR> if you use them interchangably the wrong way, and not being new is a lot of things
15:07:29 <bernalex> acowley: IIRC, intero.el was too annoying with evil as well. so I'm stuck with ghc-mod, flycheck, and some others. :)
15:07:47 <quchen> EvanR: Oh, you were referring to the typeclass comment, not permutations. Nevermind.
15:07:47 <acowley> But I'm glad you're using it! It always seems so pointless to me when people ponder editor features that have already existed for years.
15:07:50 <EvanR> no
15:08:17 <moosnat> hello, new to Haskell here
15:08:31 <moosnat> I'm trying to do a feasibility study for using Haskell in a project
15:08:32 <acowley> bernalex: intero.el doesn't do much in terms of UI. It's advantage is that it's fast, and does a very good job with dealing with distinct projects.
15:08:43 <bernalex> acowley: what I'd like is more automatic things. I can use flycheck to get up 'oh, you're doing X? why aren't you doing Y?!' -- I want it to go one step further and just s/X/Y/ for me as well.
15:08:52 <acowley> bernalex: shm on the other hand is UI armageddon or rapture depending on what you're trying to do
15:08:53 <moosnat> how does servant's authentication system work? Is it reasonable to plug in JWT support for it?
15:09:05 <ski> hello moosnat
15:09:05 <acowley> bernalex: Oh yea, that hlint output is such a tease!
15:09:16 * ski doesn't know anything about `servant'
15:09:24 <acowley> bernalex: The worst is when the suggestion disappears after you start typing and you end up getting it wrong
15:09:39 <bernalex> acowley: I don't use stack either, so that's another 'strike' against intero.el for me. if it used cabal-install and worked with evil, I'd probably be more enthusiastic. it looks pretty cool -- but not quite cool enough to warrant the man hours.
15:09:53 <acowley> bernalex: I started using stack in order to use intero
15:09:53 <bernalex> acowley: I agree that shm is really really (potentially) cool.
15:10:09 <moosnat> ski: how well does Haskell support an actor model to concurrency?
15:10:16 <bernalex> acowley: I considered doing that. but then something didn't work with stack, so after 15mins I gave up. :p
15:10:21 <acowley> bernalex: But frankly, intero works so smoothly with stack I think the tight coupling is a net win
15:10:21 <maerwald> acowley: imo, that shows that intero is really misdesigned if it forces that kind of choice on you
15:10:33 <acowley> bernalex: That sounds fair
15:10:33 <moosnat> the project I have in mind maps nicely to actors
15:10:41 <quchen> My car is also misdesigned because it can't swim. The car manufacturer should really work on that.
15:10:47 <EvanR> moosnat: not great, since actors dont have a good story for well-typed ness
15:11:01 <bernalex> acowley: I just went vim -> emacs a month or two ago, so I kind of spent my procrastination time for the next few months!
15:11:05 <acowley> maerwald: I agree and disagree! I opened a PR with WIP integration between intero and nix and the PR was immediately rejected
15:11:05 <EvanR> but you can create your own single universe of messages
15:11:11 <EvanR> itll just suck to use
15:11:14 <moosnat> EvanR: hmmm...it seems like monadic chaining would work well for my idea as well
15:11:27 <maerwald> acowley: well, that's nothing new given the maintainer
15:11:32 <acowley> maerwald: So that was a touch annoying, however the nix Haskell world proceeded to self destruct more or less the next day, washing my annoyance away
15:11:32 <ski> moosnat : it's "green threads" are very cheap. you can communicate between them using `MVar's, `Chan's, &c. there's also `STM' (Software Transactional Memory), if you want more compositionality
15:11:36 <bernalex> maerwald: it's not misdesigned as such. intero.el was made by FP Complete people to make their job easier. they use stack so. -_o_-
15:11:42 <moosnat> EvanR: a part of my project concept is a chatbot
15:11:49 <bernalex> it's free software, so you can fork it and make a cabal-install or nix version. so that's great.
15:11:50 <moosnat> ski: thanks
15:11:53 <EvanR> yes you can do nice concurrency in haskell
15:12:13 <EvanR> but a generalized actor based library has a typing issue
15:12:13 <acowley> maerwald: I think about 50% accept/reject with PRs to projects Chris controls, but I always try his stuff
15:12:14 <bernalex> I just don't have the time to be that person. :)
15:12:17 <seivan_> Is <^> considered to be map? 
15:12:24 <moosnat> EvanR: I understand now, thanks
15:12:26 <seivan_> I can't find <^> in Parsec, but I understand map exists
15:12:27 <fvh> When building app with stack inside docker I have an "There was an error reading the package tarball" .. package.tar.gz NoTarFormat how to fix this?
15:12:28 <maerwald> bernalex: sounds like they're not dedicated to the community then
15:12:38 <ski> seivan_ : perhaps you're looking for `<$>' ?
15:12:42 <maerwald> acowley: he just ignores most of my bug reports, so I stopped caring
15:12:44 <seivan_> ski: Ah
15:12:50 <acowley> maerwald: I meant to say, I'm about 50% accept/reject
15:13:31 <bernalex> maerwald: they're dedicated enough in supporting *their* tools. and they tailor everything around those tools. which I find 100% fair since it's free software. but it is worrying if it becomes hostile to the point of actively sabotaging alternatives. 
15:13:34 <seivan_> ski: <$> is map?
15:13:34 <acowley> maerwald: Yeah, I can understand your response.
15:13:43 <ski> seivan_ : it's `fmap'
15:13:55 <ski> @type (<$>)
15:13:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:13:57 * acowley agrees with bernalex
15:14:05 <bernalex> maerwald: it *is* troubling that they e.g. reject acowley's stuff, if someone also ends up offering to *maintain* it.
15:14:30 <bernalex> but as of now, in a sort of part-time alpha-beta-type of thing that they find useful at work, I find it a bit early to cry evil yet.
15:14:40 <acowley> Me, too
15:14:46 <moosnat> where is a good place to ask servant questions?
15:14:54 <bernalex> it's not like they're systemd...
15:15:03 <bernalex> moosnat: here! or #servant. I think that's a channel, anyway.
15:15:08 <moosnat> ahh
15:15:11 <acowley> I think what they're doing is totally fair, and the product they're producing (stack+intero) is really fantastic
15:15:19 <bernalex> moosnat: but anything #haskell is good to ask here. :)
15:16:26 <moosnat> bernalex: thanks! How much do you know about servant's authentication system?
15:16:27 <maerwald> acowley: I judge projects not by their features, but how they treat contributors
15:16:27 <bernalex> moosnat: nothing! I almost went to a talk about servant. but I couldn't afford it. so my knowledge about servant is limited to what I read in the intro text to that talk. :)
15:16:27 <moosnat> ahhh
15:16:27 <bernalex> moosnat: but ask away, and someone might answer. :)
15:16:35 <moosnat> thanks, this is a nice channel :)
15:16:39 <acowley> maerwald: I do, too, but they've always been friendly to me. I've had a few PRs rejected from ghc-mod, too, so it's not like I had another home to turn to.
15:17:03 <maerwald> rejected PRs is ok... that means they are communicating 
15:17:13 <maerwald> which is also not always the case
15:17:18 <acowley> moosnat: Oddly, there are a good number of Servant users on Haskell Twitter if that's something you use.
15:17:29 <moosnat> Does anyone know how I would go about incorporating JWT authentication in a Servant app?
15:17:30 <acowley> Maybe not odd, I guess it's really popular
15:17:30 <bernalex> what's Haskell Twitter?
15:17:48 <bernalex> twitter written in haskell? a twitter-like social networking site limited to haskell?
15:17:54 <acowley> The part of Twitter I interact with
15:18:10 <bernalex> ah. yes. I follow a lot of people. I think I follow you too.
15:18:22 <acowley> I mean the social network you reach on Twitter if you follow people you also see on #haskell :)
15:18:23 <bernalex> or at least you show up a lot when other people I follow retweet you. :)
15:20:23 <acowley> I actually type a lot into IRC, too, but don't notice when ERC has disconnected so it's a sad, very technical monologue.
15:21:29 <moosnat> My familiarity with functor, applicative, and monad is a little shaky - is it possible to use a monad for delimited computations?
15:22:07 <sm> acowley: I hate that! :)
15:22:31 <acowley> sm: You do it, too?
15:22:41 <acowley> sm: I'm glad I'm not alone in that.
15:22:48 <sm> yeah, thought it was just me
15:22:49 <moosnat> like in a chat bot where I might have something like `getFirstMessage >>= processFirstMessage >>= nextPartOfConversation` and so on
15:22:59 * hackagebot quantum-random 0.6.0 - Retrieve, store and manage real quantum random data.  https://hackage.haskell.org/package/quantum-random-0.6.0 (Cliff_Harvey)
15:23:01 <bernalex> acowley: mosh is nice. maybe try that. :)
15:23:05 * sm finds a buddy in disconnection!
15:23:16 <bernalex> IDK how it works with ERC tho. probably well, if I were to guess.
15:24:05 <maerwald> moosnat: some say you can view Monads as programmable semicolons. Ofc that's a generalisation, but it has some truth
15:24:48 <acowley> bernalex: I use a ZNC bouncer, already. It's just that my local Emacs can disconnected, and the "CLOSED" just sits there in the mode line without me noticing, and it lets me keep typing away.
15:25:08 <moosnat> maerwald: what I'm not quite sure on is how you do something like what I suggested
15:25:19 <bernalex> acowley: mosh picks up what you typed and forwards it when you get a connection.
15:25:30 * ski isn't quite sure on what moosnat was suggesting
15:25:30 <bernalex> acowley: it's made for shitty roaming networks. trains and the like.
15:25:32 <acowley> moosnat: How is what you want to do different from what you wrote?
15:26:05 <moosnat> sorry I'm not making complete sense
15:26:10 <maerwald> :D
15:26:14 <moosnat> say I'm writing an IRC bot
15:26:21 <glguy> You're writing an IRC bot
15:26:28 <maerwald> glguy: stop xD
15:26:37 <moosnat> and I want to represent the flow using monadic chaining
15:26:51 <maerwald> moosnat: well yes, then do that :)
15:27:11 <monochrom> what is "the flow"?
15:27:26 <moosnat> I guess I'm confused as to where the border between the lower-level protocol details and the higher-level conversation details is
15:27:58 <moosnat> monochrom: "the flow" refers to a conversation
15:28:07 <maerwald> that sounds more specific than "what can I do with monads"
15:28:18 <moosnat> maerwald: it is...my apologies that it wasn't clear
15:28:53 <monochrom> I am not convinced that an IRC bot needs a notion of conversation. I mean I only see the need of a knee-jerk message dispatch.
15:29:15 <moosnat> IRC's not the best example, you're right
15:29:46 <moosnat> I guess what I'm really talking about is like a conversation-oriented chatbot
15:30:33 <maerwald> I'd say you'd need a more sophisticated representation of state then
15:30:43 <maerwald> but now we are going the AI route?
15:31:25 <EvanR> moosnat: you can use monads to write "dialog" based procedures, like the old style getUserInput() "function" which blocks until the user types a line of text, then resumes
15:31:35 <EvanR> that probably helps with protocols
15:31:38 <moosnat> EvanR: that's exactly what I was looking for
15:32:05 <monochrom> ok, knee-jerk message dispatch can be the low-level backbone. it can dispatch a message to a high-level thing. that high-level thing will look like a stateful, suspendable, resumable computation, which is what you said about delimited computation.
15:32:07 <EvanR> i used something like that for MUD parsers
15:32:45 <sm> EvanR: sounds like the wizards package
15:32:55 <EvanR> wizards you say
15:33:57 <moosnat> monochrom: what does the "dispatch a message" part look like in Haskell? In Erlang, I'd have a process send a cast to the conversation process while the conversation process waits
15:34:11 <monochrom> at this point there are many choices. one choice is a Haskell thread and just do it in IO. another choice is what EvanR says. I wonder whether EvanR says is a free monad, but even if not, free monad is another option.
15:34:16 <EvanR> moosnat: a dialog is either producing a pure answer, or is waiting for input from the user so it can process it to produce another dialog
15:34:17 <sm> make asynchronous events seem like a procedural flow also sounds like the transient package
15:34:39 <EvanR> user or client or whatever
15:34:48 <EvanR> repl operator
15:35:14 <EvanR> yeah, might be a specialization of free monads
15:36:41 <EvanR> data Dialog a = Pure a | Waiting (String -> Dialog a)
15:36:48 <moosnat> EvanR: that does look right
15:37:26 <EvanR> probably a terrible name since you dont get a prompt
15:37:51 <EvanR> the power is yours!
15:38:44 <monochrom> a message-dispatch loop in Haskell will be a thread that runs: blocking-read the IRC socket, get a message, parse it and decide which resumable computation deserves to receive it, resume that computation (if the resumable computation wants to send, this has to be detected somehow and someone has to actually do the write-to-socket), repeat.
15:39:54 <moosnat> monochrom: okay, that makes sense
15:40:17 <moosnat> how hard is it to make this loop multi-threaded?
15:40:42 <monochrom> just a call to forkIO
15:41:01 <monochrom> this loop runs in one thread, it doesn't need more threads.
15:41:04 <moosnat> ohh
15:41:30 <EvanR> data Dialog a = Pure [IO ()] a | Waiting Prompt [IO ()] (String -> (Dialog a) has the power to ask a question and launchMissiles after each command...
15:41:50 <monochrom> it is true that the resumable computation should happen in another thread. that can be easily pre-arranged. then the message-dispatch thread sends a message to the other thread.
15:41:58 <EvanR> [IO ()] can be represnted as IO (), >> as the mappend
15:42:51 <moosnat> this is one of the things that's always intrigued me about Haskell
15:43:08 <monochrom> Did you know: since GHC 8, "instance Monoid a => Monoid (IO a)" exists. It does >> on the effects, <> on the return values.
15:43:34 <EvanR> funny
15:43:50 <moosnat> this problem is one that I'm used to thinking of in an imperative way, but Haskell, through monads, makes it possible to build really convenient abstractions
15:44:02 <maerwald> monochrom: wut
15:44:17 <monochrom> so you can now actually use mconcat on [IO ()], and it will do what you just said, modulo inefficiency due to doing <> on ()'s.
15:44:26 <EvanR> or use Writer (IO ())
15:44:30 <stick> hello, does anyone know if there's a package for haskell providing a data structure similar to c++'s std::vector? meaning an efficient array structure along with automatic growth when adding elements. i was thinking of something like Data.Vector.Mutable, but it doesn't seem to provide automatic growth
15:46:43 <stick> there's dynamic-mvector package which looks like just what i need, but it's not in my distro's repositories, so i'd like to know if there are any alternatives
15:49:03 <johnw> stick: you might be misthinking your approach to the problem?
15:49:29 <johnw> when you say std::vector, you're already thinking in terms of memory management, which is rarely how one proceeds in Haskell -- unless you have a very specific use case in mind
15:50:01 <fishythefish> moosnat: nice to see you here :)
15:50:25 <moosnat> agreed fishythefish
15:50:48 <moosnat> I never could stay away from learning how to make monads do cool stuff :)
15:53:09 <stick> most likely, i just need to store an arbitrary number of primes, and was thinking of something more efficient that lists
15:54:03 <ski> (and you need random access ?)
15:54:22 <stick> sequential access
15:54:44 <ski> lists might be more efficient then, if they get fused away
15:55:48 <ski> (though i suppose that you need access to earlier primes to compute subsequent ones, which probably will bar fusion then)
15:55:55 <Shou> Is there a term describing outer-constructor equality? (Right Nothing == Right (Just 1)). Could I use "extensionality"?
15:55:56 <stick> i just thought that allocating memory for each new element every millisecond can't be very efficient
15:56:51 <moosnat> stick: laziness may help you here
15:56:53 <Rembane> stick: The compiler might fusion away the allocations, thus having very few of them.
15:56:54 <ski> allocation is quite cheap. perhaps you should measure some versions against each other
15:57:48 <ski> Shou : "extensionality" means roughly that two things are equal in case they "behave" the same
15:58:24 <ski> Shou : i don't think "extensionality" would be a good word choice in your case
15:58:38 <fishythefish> moosnat: How much have you played with IO in Haskell?
15:58:44 <ski> perhaps you should try to describe more about what you're trying to do/express, to the channel
15:59:28 <moosnat> fishythefish: I know that it uses monadic chaining to sequence operations
15:59:35 <Shou> ski: Pattern matching on the outer-layer of constructors to see whether they're the same or not basically
15:59:39 <fishythefish> moosnat: that's theory; do you have any practice?
15:59:51 <Shou> I'm wondering if there's a succint way to describe that.
15:59:56 <Shou> Or more standard way
16:00:27 <moosnat> fishythefish: mostly just interacting with stdio
16:00:34 <ski> Shou : i'm not aware of any term for that. it also seems a bit arbitrary thing to focus on (given that such things can change wildly, with type refactorings)
16:00:35 <fishythefish> moosnat: Maybe try coding one of those simple command-line guessing games. You'll get the basics of IO and the extent to which monadic bind/do notation feels functional vs imperative
16:01:01 <moosnat> fishythefish: thank you
16:04:49 <mniip> what is the modern recommended set of literature for introducing people to haskell?
16:05:11 <mniip> familiar with imperative programming but not so much functional
16:05:44 <seivan_> What is the userstate for in Parsec?
16:06:27 <fishythefish> mniip: I still go with LYAH (and I need to revisit RWH to see how it is)
16:06:29 <fishythefish> I prefer free online books
16:06:59 <fishythefish> Courses like cis194 are good for practice, but the reading assignments come from those books anyway
16:08:11 <mniip> oh yes
16:08:17 <mniip> totally forgot about cis194
16:08:36 <EvanR> moosnat: hehe... it works http://lpaste.net/168257
16:09:05 <moosnat> EvanR: awesome
16:09:08 <moosnat> thank you very much
16:09:21 <EvanR> its lazy though do you need bang patterns to crash if user input can crash the whole thing
16:09:35 <EvanR> like read
16:10:03 * EvanR hopes this obeys monad laws
16:10:37 <sm> seivan_: if you're parsing some stateful kind of format. Eg in hledger journals you can have a directive that sets the current year
16:10:56 <sm> affecting subsequent parsing
16:12:12 <EvanR> and the bang on 43 isnt necessary
16:12:43 <seagreen> I need an associative array and normally I would just use HashMap from unordered-containers, but in my case the keys are actually already hashes. Because of that would another structure be more efficient?
16:13:17 <EvanR> hash = Int ?
16:13:29 <EvanR> IntMap
16:13:54 <seivan_> sm: Ah, it's like a blackboard/contextmanager
16:14:17 <cheater> is there a generics based way to generate all values of an ADT?
16:18:00 * hackagebot test-fixture 0.2.1.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.2.1.0 (lexi_lambda)
16:22:10 <seagreen> EvanR: The hashes are utf8 encoded bytestrings, but I can turn that into an Int no problem if that's the best thing to do.
16:22:23 <EvanR> well, then youre back to HashMap
16:22:49 <EvanR> turning a string into an Int is a hash
16:23:47 <EvanR> if you have Int keys, resulting from a hash or not, IntMap is good
16:24:23 <EvanR> but HashMap does the hash + intmap for you
16:30:09 <moosnat> EvanR: your Dialog monad looks a lot like Free
16:30:56 <EvanR> you could have invented free monads
16:31:30 <moosnat> that's a very cool concept
16:31:47 <seagreen> EvanR: Hmm, turning the ByteString into an Int doesn't need to involve hashing.
16:32:14 <EvanR> no?
16:32:38 <moosnat> EvanR: where is execIO used? I only see a declaration
16:32:43 <EvanR> i didnt use it
16:32:54 <EvanR> it was just an after thought
16:32:58 <moosnat> ohh
16:33:44 <Welkin> exeggutor
16:33:52 <Welkin> programming with pokemons
16:34:52 <EvanR> moosnat: you could test a dialog by just ignoring its IO components
16:35:01 <EvanR> since they dont expect a response, they effectively dont matter
16:35:44 <EvanR> of course you cant test the IO itself that way but...
16:35:49 <EvanR> who does that!
16:36:01 <seagreen> EvanR: ByteStrings can be thought of as base-8 numbers and converted to base-10 int (and that can be reversed, unlike a hash function)
16:36:12 <EvanR> seagreen: sure but its going to overflow an Int
16:36:33 <EvanR> and youll get collisions
16:36:53 <EvanR> it might work for very short strings
16:37:28 <seagreen> EvanR: Ah, I see what you mean. I think if I make sure that I never let anything that hasn't already been hashed slip though I should be good.
16:37:29 <EvanR> er, byte strings are base 256 numbers
16:37:51 <seagreen> EvanR: Heh oops.
16:38:40 <seagreen> Thanks for the help btw.
16:38:44 <EvanR> basically youre back to Map ByteString, HashMap ByteString, or perhaps Trie
16:41:04 <EvanR> seagreen: oh i see, you mean reverse the encoding of the string version of the hash back to the N-bit rep
16:41:22 <EvanR> yeah, though you still need to deal with collisions somehow
16:42:47 <fishythefish> moosnat: ekmett actually talks about how IO could be implemented with free monads here: http://comonad.com/reader/2011/free-monads-for-less-3/
16:44:11 <moosnat> fishythefish: that link also mentions delimited continuations! thanks!
16:52:29 <parsnipM_> i installed stack on ubuntu as speciifed on its github, is it advisable to install cabal-install with stack or independently? 
16:53:54 <Axman6> parsnipM_: what do you need cabal-install for?
16:55:06 <parsnipM_> Axman6: i've had good luck with *.cabal files, cabal sandbox, `cabal sandbox int`, cabal install --only-dependencies
16:55:16 <parsnipM_> *sandbox init
16:55:28 <glguy> parsnipM_: It should work the same no matter how you install it, just do whatever's easier for you
16:55:47 <glguy> if you go the stack route you'll need to use a nightly or manual resolver to get cabal-install-1.24
16:56:19 <parsnipM_> hmm, there is no `ghc --version`
16:56:32 <parsnipM_> maybe i need to get the stack stuff on my path
16:57:13 <parsnipM_> can i get stack and cabal-install to share binaries? 
16:57:21 <parsnipM_> er, ghc's
16:57:43 <glguy> cabal-install will use whatever GHC is in your path or which is specified with the -w flag
17:04:35 <sebleblanc> Can "cabal repl" load a module without rebuilding it? e.g. I make changes to a module and it stops building due to an error, yet I would like to experiment with definitions from that module. having the ability to reload the module as it was when it used to build would be very useful to me
17:06:30 <sebleblanc> I could always use source control and "stash" changes, but it is kind of cumbersome
17:09:57 <Enigmagic> sebleblanc: sometimes this helps https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/defer-type-errors.html
17:10:06 <Enigmagic> depending on what the error is
17:10:10 <monochrom> that is the number 1 most wanted feature. meanwhile, some people keep 2 ghci's running, so that one can sit on the last error-less loading
17:13:02 * hackagebot heredocs 0.1.3.0 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.3.0 (KatsutoshiItoh)
17:22:16 <AleXoundOS> Control.Monad.Error is marked on stackage as deprecated. Does it also mean that Control.Monad.Error.Class is also deprecated?
17:23:19 <koz_> AleXoundOS: Do they come from the same package?
17:23:37 <AleXoundOS> yes
17:23:52 <Skami> I think you ought to use control.monad.except now
17:24:07 <AleXoundOS> yeah, I think so too, but not 100% sure
17:24:17 <koz_> Skami: Is there a corresponding monad transformer for that too?
17:24:43 <Skami> Yes, ExceptT
17:24:56 <Skami> See https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
17:27:06 <Squarism> I have a typical receive-act loop that creates a new state each time. Using 1. read TChan. 2. execute update 3. send optional response to other Chan. 
17:27:28 <Squarism> i wonder how i should model that. 
17:27:50 <Squarism> MVar? 
17:28:33 <Skami> Squarism: if you create a new state each turn, I would use an Automaton arrow and feed it input and push it's output
17:28:47 <Skami> Depending of your needs
17:29:43 <Squarism> Skami, will google it
17:30:34 <Skami> Squarism: See the arrow transformer package 
17:32:01 <Squarism> Cant find much more than api docs
17:32:50 <Axman6> arrows are a pain :\
17:33:16 <Zemyla> Axman6: Wear better armor.
17:33:34 <Squarism> Axman6, you have a less painful approach?
17:34:00 <Axman6> well, why not do exactly what you said, and use a Chan?
17:35:13 <Squarism> Hmm.. i said MVar?
17:35:46 <Axman6> what is the MVar doing? you original problem spoke only of Chans...
17:38:38 <sebleblanc> monochrom, +1 on running two interpreters 
17:39:42 <Skami> Your func would look like  http://lpaste.net/168264
17:40:02 <Skami> Squarism, sorry for typos or errors, I'm on my phone
17:40:17 <Zemyla> I find myself really needing affine traversals.
17:41:37 <Squarism> Skami oh thanks.. what if i need to select outgoign channel depending on "action outcome"
17:42:06 <Skami> Squarism, can you precise, I'm not good at English.. 
17:43:13 <itnex> can i compile haskell into minecraft redstone circuits?
17:43:26 <Koterpillar> itnex: are they Turing complete?
17:43:58 <itnex> i have no idea actually but i suspect they are
17:44:02 <Koterpillar> then yes
17:44:45 <sebleblanc> itnex, as an additional challenge, program a bot that will build the redstone circuit interactively
17:47:32 <sebleblanc> itnex, in all seriousness, though, I believe that redstone circuits are kind of limited due to their physical restrictions, that is they can only be laid-out in cube grids
17:48:54 <Squarism> Skami, http://lpaste.net/168265
17:54:01 <Skami> Squarism, you have a two chans, a in and a out? And you want to map a function over the content of the chans, but having a state that changes after each actions? If I understand right. 
17:54:23 <Squarism> Skami 1 in, 2 out
17:55:21 <Squarism> depending on outcome of i action i should send to out1 or out2 or both
17:55:41 <Skami> Ok, I'll write a sample working program with an Automaton that you could edit later if you let me get my computer 
17:55:43 <Squarism> g2cCaesar and g2cPompeji i mean
17:56:17 <Squarism> Skami id be very thankful
18:04:14 <Skami> Are you still here ??
18:10:12 <Squarism> Skami, sure am
18:10:30 <Skami> I have almost finish
18:22:27 <bburd> Question for anyone: Is there a chat room about functional programming in general?
18:24:14 <Skami> It's still laggy, but you can have a look at it while I correct the bugs : http://lpaste.net/168270
18:24:22 <Skami> Squarism
18:24:29 <Squarism> Skami, 
18:30:42 <bburd> I have a question about pure functions and side-effects, not particularly in Haskell. Is it fair game in this chat room?
18:31:08 <c_wraith> Yeah, in general we'll talk general FP as well as haskell-specific.  It also depends on how busy it is.
18:32:56 <texasmynsted> How do I look up how to use "where" and "in"?
18:33:21 <texasmynsted> Those are common english words and I am having trouble googling for how this works with haskell syntax
18:33:45 <c_wraith> texasmynsted: in must always go with a let
18:34:00 <c_wraith> texasmynsted: in general..  let ... in ..  is an expression.
18:34:07 <c_wraith> texasmynsted: you can use it anywhere you can use an expression.
18:34:13 <glguy> https://www.haskell.org/definition/haskell2010.pdf is the place to go for syntax questions
18:34:40 <c_wraith> texasmynsted: in contrast, where clauses attach to cases in a case expression or patterns in an equation.
18:35:10 <c_wraith> that's the short version.
18:35:29 <texasmynsted> oh hm
18:35:54 <c_wraith> There are some other details, like let-without-in inside of do blocks, and where clauses being shared over all guards within the same pattern match.  But they're minor in comparison to the main point.
18:36:10 <texasmynsted> so if I put "module Foo where " then that is somehow part of a case expression?
18:36:25 <bburd> I was trying to distinguish among the following terms: referential transparency, purity, having no side-effects. As far as I can tell referential transparency is only one side of having no side-effects. Referential transparency means you don‚Äôt use any values except your parameters. But having no side-effects means you also don‚Äôt change any outside values (except to return a result). I‚Äôve seen purity defined as almost the same 
18:36:26 <bburd> referential transparency, and as having no side-effects. Is there agreed upon terminology for all this?
18:37:08 <bburd> P.S. I realize that referential transparency is more like substitutabiliy, but it looks like it boils down to not using any outside values.
18:37:24 <Skami> Squarism, Actually it would work, the problem it that unzip is not lasy enough, but you get the idea.
18:37:30 <texasmynsted> An expression is referentially transparent if all occurrences of the expression in the program can be replaced by the result of evaluating the expression without affecting the meaning of the program.
18:37:34 <glguy> texasmynsted: No, the syntax for a module is simply module *modid* [*exports*] where *body*
18:37:36 <Skami> @let import Data.List
18:37:37 <lambdabot>  Defined.
18:37:46 <Skami> > unzip $ zip [1..] [2..]
18:37:47 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:37:48 <glguy> texasmynsted: You can see that in the grammar listing in section 10.5
18:38:00 <Squarism> Skami, trying to run it as we speak
18:38:39 <Skami> Squarism, it won't, see the example, but if someone know how to make a lasy unzip, just substitute it with that.
18:39:07 <Skami> Squarism, Tried with Writer, still no luck.
18:40:01 <bburd> texasmynsted - What does ‚Äúthe result of evaluating the expression‚Äù mean when the expression is something like getFromStdin which can have many values, depending on when it‚Äôs evaluated?
18:41:08 <augur> is there a Stack channel?
18:41:15 <Squarism> Skami, well thanks for taking your time! Much appriciated
18:41:32 <glguy> bburd: getFromStdin evaluates to an action that can (presumably) get from stdin, it doesn't get anything from stdin by being evaluated
18:41:38 <texasmynsted> I did not see let or in, in 10.5
18:41:50 <texasmynsted> hah
18:42:05 <glguy> texasmynsted: Its in there about two pages in under "lexp"
18:42:05 <texasmynsted> getFromStdin would take () 
18:42:09 <Skami> Squarism, Until then, you can see that it works with only one output chan : http://lpaste.net/168272
18:42:33 <bburd> glguy ‚Äî I‚Äôm not referring to any getFromStdin in Haskell. I‚Äôm talking about the dumb old input calls from imperative languages.
18:43:38 <Squarism> Skami, ill play around some with arrows and see if im lucky
18:44:09 <Skami> Good luck then
18:44:17 <texasmynsted> ok glguy.  Thank you
18:44:46 <Squarism> Skami, thanks ! 
18:45:21 <Skami> Squarism, this one helped me a lot : http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
18:45:56 <texasmynsted> bburd, what I am saying is that the result of evaluating getFromStdin depends on the type that is read by stdin, and that would be I/O which is kind of BS.
18:46:44 <Skami> Got two chans working with a simple map instead of unzip... If someone is interested http://lpaste.net/168273
18:47:35 <Squarism> Skami, ok.. ill take a look
18:50:17 <texasmynsted> imperative languages execute computation via statements rather than expressions or declarations.
18:50:37 <texasmynsted> imperative languages "do things"
19:05:48 <bburd> OK. So, ‚Äúbeing pure‚Äù vs. ‚Äúreferentially transparent‚Äù vs. ‚Äúnot having side-effects‚Äù. What‚Äôs the relationship?
19:07:05 <EvanR> let x = "jim" in (x,x)
19:07:05 <EvanR> =
19:07:10 <EvanR> ("jim","jim")
19:08:15 <EvanR> note that this doesnt work in many languages because theyre not referentially transparent, or because you could say their variables mean something else, mutable cells
19:08:25 <EvanR> not names
19:08:32 <EvanR> pure functions dont have side effects
19:08:49 <Squarism> gah.. arrows was harder than i hoped
19:09:18 <EvanR> so the only relationship i can see is that application of pure functions can work in an RT context
19:09:50 <bburd> EvanR: It doesn‚Äôt work because of x‚Äôs mutability?
19:10:13 <Squarism> this has to be a common problem. Anyone got a simpler idea than arrows to create an update loop (of a state s) within http://lpaste.net/168265
19:10:34 <EvanR> bburd: well, if "jim" were f("ji","m")
19:11:35 <Squarism> s' = apply msg s, where s' is next "s" so to speak
19:11:51 <Zemyla> So every functor that is affine traversable is equivalent to Compose (Either e) ((,) w) for some e and w, I assume?
19:11:57 <monochrom> Squarism, what do you mean by "arrow", do you mean simply the "->" symbol?
19:12:26 <Squarism> monochrom, i got hints it could be solved using https://hackage.haskell.org/package/arrows
19:12:33 <EvanR> bburd: also, using a variable could be a method call. it depends on the specifics i guess
19:12:41 <bburd> EvanR: What does ‚Äújim‚Äù being f(‚Äúji‚Äù, ‚Äúm‚Äù) have to do with it?
19:12:43 <Squarism> but it seems a bit too exotic
19:13:07 <monochrom> yeah I don't think you should bother
19:13:11 <EvanR> var x = f("ji","m"); return [x,x];
19:13:11 <Koterpillar> bburd: let x = f("ji", "m") in (x, x) vs. (f("ji", "m"), f("ji", "m"))
19:13:29 <EvanR> [f("ji","m"),f("ji","m")]
19:13:32 <EvanR> ["jim","jim"]
19:13:45 <monochrom> in every community there are always extremist enthusiasists who will recommend the most advanced things for the most ordinary needs.
19:13:57 <Squarism> haha
19:14:27 <monochrom> math enthusiasists will recommend learning quaternions for the mere purpose of multiplying two real numbers
19:14:44 <EvanR> or matrices for the purpose of multiplying quaternions
19:15:04 <emmanuel_erc> Does anyone here any experience calling C++ from Haskell? I am trying to find some information about this and I have some trouble finding it.
19:15:07 <Squarism> i really just want results and shortest path to them when it comes to my problem
19:16:27 <bburd> EvanR: I‚Äôm still not seeing it. I‚Äôm also not sure what question to ask as a follow up.
19:17:15 <EvanR> bburd: in haskell you can use equational reasoning to replace certain parts of the program with another equivalent program, but you can do this as much in javascript
19:17:18 <EvanR> or ruby
19:17:54 <EvanR> CANT do this.... >_<
19:17:55 <monochrom> Squarism: I'm wondering if my simple stdin-stdout game will help you? http://lpaste.net/52480
19:18:12 <monochrom> in short you simply use recursive calls with new parameters to replace "state".
19:18:15 <Squarism> ill have a look
19:18:30 <Zemyla> emmanuel_erc: Generally you want to have the stuff you call in Haskell exported with extern "C".
19:18:38 <monochrom> in my example "lo" and "hi" are so-called "state"
19:18:49 <EvanR> bburd: another relationship is that pure and RT are apparently synonymized in a lot of blog comments
19:19:02 <monochrom> but then they're just function parameters. low-tech vanilla functions.
19:19:03 <EvanR> with RT being to go to, despite being longer
19:20:09 <monochrom> stateful thinking is imprisioning. recursive thinking is liberating.
19:20:35 <emmanuel_erc> Zemyla: So interacting with C++ is tricky?
19:20:42 <bburd> EvanR: That‚Äôs what I‚Äôm worried about. Are they really equivalent to one another? The thing that touched off this problem for me is the post http://blog.higher-order.com/blog/2012/09/13/what-purity-is-and-isnt/
19:20:51 <EvanR> right
19:20:52 <Squarism> monochrom, recursion.. well i though about it. I just felt it would feel strange for a network loop
19:20:54 <seivan_> Should a sysUnExpectError return a Reply or a ParseError?
19:21:03 <Squarism> monochrom, but i could try atleast
19:21:29 <bburd> EvanR: He defines purity as follows: An expression e is referentially transparent if for all programs p, every occurrence of e in p can be replaced with the result of evaluating e without changing the result of evaluating p. A function f is pure if the expression f(x) is referentially transparent for all referentially transparent x.
19:21:52 <EvanR> bburd: i learned in scheme that functions can be pure or not. "not" means that evaluating a function application will possibly change the state of the program, check a system clock, or make monkeys fly out of your nose, then give you an answer
19:22:09 <Zemyla> emmanuel_erc: Yeah, mostly because of name mangling.
19:22:16 <EvanR> and that this arguably means those functions "arent even functions at all, they are procedures"
19:22:29 <monochrom> recursion is going to be strange for anything at all, if you're used to while-loops and for-loops for everything.
19:22:51 <EvanR> bburd: however RT is not talking about functions specifically, but linguistic contexts
19:23:02 <monochrom> Did you know: Semantics of imperative languages use recursion to define the meaning of while-loops and for-loops.
19:23:26 <bburd> EvanR: Am I correct that, in this blog author‚Äôs definition, a function that makes monkeys fly out of your nose can still be pure as long as it doesn‚Äôt use any values other than its parameters?
19:24:09 <EvanR> to take the question seriously i would need to fully grok the authors definition
19:24:15 <Squarism> monochrom, i use alot of recursion but never tried it with network loops
19:24:55 <EvanR> bburd: a function that maps from the input domain to (Result, NumberOfMonkeysToMakeFly) would be pure
19:25:08 <EvanR> every time you evaluate it, you get the same number of monkeys
19:25:14 <EvanR> for that input
19:26:01 <bburd> EvanR: Right, I don‚Äôt think it would be pure, but this blog author sounds so authoritative, and yet I think that mapping to (Result, Monkeys‚Ä¶) would be pure according to him.
19:26:13 <EvanR> the latter definitely
19:26:22 <EvanR> the previous either isnt well defined, or is grossly impure
19:27:19 <EvanR> bburd: "using values" isnt really the value way to go about either one of these things
19:27:34 <EvanR> ... er... isnt the best way
19:27:38 <seivan_> What is parsec prim? 
19:27:42 <seivan_> Their error seems different
19:27:59 <seivan_> Their mergeError returns a reply while regular ParsecErrors just return ParseErrors
19:28:05 <bloodwire> weird, didn't know you can place apostrophy's in variables's
19:28:05 <EvanR> whether a function "uses" what "values" sounds like an attempt to conflate all of the above notions into one
19:29:47 <bburd> EvanR: So my ultimate question is, what do you think of the blogger‚Äôs definition of ‚Äúpure‚Äù? Is it the commonly-held notion of pure?
19:30:37 <EvanR> bburd: well... scrolling down to what hes actually trying to say
19:30:56 <bloodwire> does /= relate to  !=?
19:31:16 <Koterpillar> bloodwire: /= is "not equal"
19:31:28 <EvanR> bburd: it doesnt seem to define anything directly
19:31:41 <EvanR> the quote you posted was him referring to some book to begin an argument
19:31:53 <bloodwire> Yea I thought so... just wanted to make sure.
19:31:58 <Koterpillar> bloodwire: ‚â† is / and =
19:33:46 <bburd> EvanR: The first chapter where he discusses these issues is free :-)
19:34:02 <bburd> EvanR: I guess it‚Äôs time for me to do more reading.
19:34:14 <EvanR> bburd: i think itll be good to take 19 steps back on this... for example, "when a function application is evaluated... such and such" kind of makes no sense for pure functions, also known as math functions, also known as just "functions"
19:34:35 <pchiusano> is there a way to do a nonblocking read from a `Handle` that is guaranteed to return at least 1 byte?
19:34:47 <EvanR> the time you do anything in real life isnt a math idea
19:34:47 <pchiusano> I'm looking at `hGetNonBlocking :: Handle -> Int -> IO ByteString`
19:35:01 <Welkin> Squarism: lol, that is how I do a game loop in haskell: create a function called `loop` that recursively calls itself with the updated game information
19:35:09 <pchiusano> but that can return empty
19:35:26 <monochrom> "side-effecting function" was a sloppy invention when people could not make up their mind whether the word "function" should mean mathematical function or computational procedure.
19:35:30 <EvanR> bburd: so a lot of discussion on this will begin some time after setting up a nonsensical context
19:35:38 <Cale> pchiusano: What is it supposed to do if there are no bytes available?
19:35:45 <Squarism> Welkin, im from imperative land! 
19:35:49 <pchiusano> Cale: block
19:35:56 <monochrom> today we don't even have "side effect", really.
19:35:57 <Cale> That... wouldn't be a nonblocking read
19:36:05 <Cale> That's a blocking read
19:36:22 <bburd> EvanR: Thanks. My eyes had bypassed
19:36:28 <pchiusano> Cale: I want to block, but only if there are literally zero bytes available
19:36:35 <Cale> getChar
19:36:39 <Cale> hGetChar
19:37:02 <Welkin> I found it interesting how in the game dev world people call their functions "procedures"
19:37:13 <pchiusano> Cale: I don't think that solves my problem
19:37:16 <Cale> Welkin: and their procedures functions?
19:37:18 <monochrom> we only have: "effect" for when your program's purpose is to interact with the outside, "no effect" when not. what side effect? do you intend the effect or not? make up your mind. if intended, simply "effect". if unintended, simply "bug". what is so "side" about it?
19:37:31 <Cale> pchiusano: I don't understand how it isn't exactly what you're describing
19:37:48 <Squarism> Welkin, wasnt procedure a keyword in C ?
19:37:50 <pchiusano> Cale: I want to read the maximum number of bytes that are available, or block if none are available
19:38:01 <bburd> EvanR: I understand that ‚Äúwhen a function is evaluated‚Äù is very sloppy. Where did that come from? Did I write it or did you find it in the blog?
19:38:14 <Welkin> pchiusano: that is what getChar does
19:38:14 <Cale> pchiusano: ah, you said "at least 1 byte"
19:38:43 <pchiusano> I suppose I could call `hGetChar` repeatedly, but, erm, no
19:38:44 <EvanR> bburd: thats just how the explanation of impure function goes, in languages where they realize a function may correspond to a real math function, or not
19:38:50 <EvanR> and procedures are called functions
19:39:02 <emmanuel_erc> Zemyla: That sucks... I really want to use this C++ library called LinBox.
19:39:05 <pchiusano> I want a ByteString which is of maximum size... I do not want to repeatedly read a single byte
19:39:41 <EvanR> bburd: basically if you separate functions and procedures first, some of this discussion evaporates
19:39:58 <EvanR> RT however remains and is a broader topic
19:40:11 <EvanR> and has not much to do with monkeys flying out of noses
19:40:14 <glguy> pchiusano: Bytestring has hGetSome :: Handle -> Int -> IO ByteString
19:40:39 <bburd> EvanR: Given that so many languages are hybrid (functional and imperative) it‚Äôs natural to mix these terms up. So is it save to say that a computational procedure is pure if and only if it‚Äôs a function in the mathematical sense?
19:40:57 <EvanR> hmm. ok
19:41:04 <pchiusano> glguy: perfect! that is what I was looking for
19:41:29 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:hWaitForInput
19:41:32 <EvanR> bburd: which kind of makes the word pure, used a lot in haskell, redundant
19:41:35 <glguy> pchiusano: Which is implemented using this
19:41:56 <Welkin> well, technically, everything in haskell is pure
19:41:59 <Welkin> isn't that right?
19:42:10 <Welkin> except for unsafe actions
19:42:16 <EvanR> let propertyX be meaningless. everything has propertyX
19:42:18 <pchiusano> glguy: oh wait, it uses *polling*??
19:42:34 <EvanR> Welkin: all functions are pure
19:42:49 <glguy> pchiusano: I don't know where you read that
19:43:12 <pchiusano> glguy: am just reading docs for hWaitForInput
19:43:27 <Zemyla> emmanuel_erc: Write an extern C wrapper for it.
19:43:43 <pchiusano> glguy: "It returns True as soon as input is available on hdl, or False if no input is available within t milliseconds."
19:43:51 <bburd> OK so, let‚Äôs restrict ourselves to mathematical functions a.k.a. pure functions. How can the use of any of these not be referentially transparent, or vice-versa?
19:43:52 <glguy> pchiusano: That's not what polling is
19:44:14 <pchiusano> i guess it is okay since it returns true as soon as input is available
19:44:27 <pchiusano> i dunno, i'd have to see how it is used
19:45:32 <sebleblanc> bburd, are you asking if pure functions are pure?
19:45:38 <EvanR> bburd: how about this rewrite... let x = "jim" in "(x,x)" =====> "(\"jim\",\"jim\")"
19:45:48 <EvanR> note it has not much to do with functions
19:46:16 <EvanR> in haskell that rewrite is not allowed, since string literals are not referentially transparent
19:46:32 <EvanR> but in some other language it could be
19:47:52 <bburd> String literals aren‚Äôt referentially transparent???
19:47:52 <sebleblanc> EvanR, is this related to languages that have the property of allowing the use of a variable only once?
19:48:00 <EvanR> nope
19:48:11 <EvanR> bburd: if they were, youd be able to apply the let like that
19:48:14 <pchiusano> glguy: okay, yeah I can see how it works now
19:48:35 <pchiusano> there's no polling, you are right
19:48:44 <EvanR> you cant take x = "jim" seriously inside that literal
19:48:55 <pchiusano> it just only blocks for a limited amount of time
19:49:13 <pchiusano> hGetSome calls it in a loop
19:50:22 <glguy> hGetSome waits for -1 milliseconds, which I imagine is a lot of milliseconds
19:51:09 <pchiusano> ha, i didn't even notice that
19:51:25 <bburd> Let me see if I understant this. Being sloppy about the quotation marks for a moment, you‚Äôre saying that there‚Äôs a program fragment in which you can‚Äôt replace the actual text ‚Äúlet x = him in (x,x)‚Äù with the actual text ‚Äú(jim,jim)‚Äù?
19:51:27 <pchiusano> that line could use a comment on the meaning of -1
19:51:47 <glguy> pchiusano: If it's valid hWaitForInput could use a comment about hte meaning of negative values
19:52:00 <EvanR> bburd: you missed the quotes around the (x,x)
19:52:19 <bburd> Yes, I missed all kinds of quotes. Did I muddy up the point by doing so?
19:52:22 <EvanR> and being precise about quotes is entirely the point here
19:52:32 <EvanR> thats whats mucking up the RT
19:52:36 <pchiusano> glguy: well, both would be good
19:52:40 <bburd> OK. Let me look more carefully at the quotes...
19:52:53 <EvanR> > let x = "jim" in "(x,x)"
19:52:55 <lambdabot>  "(x,x)"
19:52:57 <EvanR> didnt... work
19:53:17 * EvanR switches to PHP
19:54:32 <bburd> So the quotes within quotes is what‚Äôs mucking things up? The fact that you need to escape the inner quotes? That‚Äôs actually a syntactic issue. And that, you‚Äôre saying is RT?
19:54:52 <EvanR> well adding outer quotes is kind of complicating things 
19:55:08 <EvanR> i was hoping we could get by leaving those implicit
19:55:26 <EvanR> bburd: did you see my last lambdabot computation?
19:55:26 <monochrom> bburd: In imperative languages, "tmp = rand(6); x = tmp+tmp" is very different from "x = rand(6)+rand(6)". In this setting, one can make a big fuss about effects, RT, impurity, etc etc.  A fertile ground for a lot of controversy, losing hair, and losing friends.
19:55:40 <glguy> EvanR: I think you might be confusing what referential transparency is? or at least you're confusing me. What does string interpolation have to do with referential transparency here?
19:55:51 <monochrom> The better way to win is not to play.
19:56:34 <monochrom> Except that when you lose hair you don't really think "fertile", haha.
19:56:36 <EvanR> glguy: in an RT context, like in an expression and outside the quotes you can replace equal program fragments, including variables
19:56:51 <EvanR> inside the quotes you cant
19:56:56 <EvanR> its opaque
19:57:17 <ADTJunkie> whats the best way to learn Scala
19:57:21 <glguy> the stuff inside the quotes isn't a program though, it's not intended to be treated as normal source text
19:57:22 <ADTJunkie> should I learn haskell first
19:57:23 <EvanR> glguy: the discussion began with yet another confusion about why people have two words for purity, which is something else
19:57:36 <monochrom> Anyway, I have no interest in someone else's blog. But I can explain why there is a big fuss when one's mind is imprisoned in imperative thinking.
19:57:50 <kadoban> ADTJunkie: You should learn haskell because it's cool, but I doubt it's a good use of effort if your only goal is to learn scala.
19:58:09 <ADTJunkie> well I wanna learn functional programming
19:58:27 <ADTJunkie> is there any particular part of haskell that will help me with that
19:58:32 <ADTJunkie> like pattern matching shit
19:58:32 <EvanR> glguy: correct, the (x,x) in "(x,x)" cant be treated like normal source code
19:58:43 <EvanR> in any way
19:58:50 <kadoban> ADTJunkie: Haskell is a functional language, and has all kinds of nice properties. You'll learn a lot if you learn it.
19:59:12 <monochrom> After I learned Haskell, things become so much simpler. You have an intended effect, or you have a bug; there is no "side". Do or do not, there is no try.
19:59:18 <ADTJunkie> kadoban: im afraid that my brain will run out of memory if I learn both scala and haskell
19:59:22 <ADTJunkie> (at the same time)
19:59:29 <glguy> EvanR: but what does that have to do with RT?
19:59:36 <ADTJunkie> and then ill forget other things 
19:59:38 <kadoban> ADTJunkie: You probably shouldn't learn them at the same time, yeah.
19:59:39 <monochrom> wait, it should be: no try there is.
20:00:12 <sebleblanc> EvanR, is this a referentially transparent string literal? http://slashes.tryitonline.net/
20:00:21 <EvanR> glguy: however in some other languages "(#{x},#{x})" you restored the RT context, and the whole thing is equal to "(#{"jim"},#{"jim"})"
20:00:39 <bburd> ADTJunkie: I‚Äôm coming from Java to Haskell. Scala is an in-between language. For me, the trouble with learning Scala is that it doesn‚Äôt teach me where the boundary is between functional an imperative because it‚Äôs a mix.
20:00:43 <sebleblanc> EvanR, sorry: slashes.tryitonline.net/#code=L3gvamltL3gseA&input=
20:01:59 <Welkin> bburd: immutable data and referential transparency at least, also declarative style
20:02:05 <Welkin> there is no real definition though
20:02:21 <EvanR> ^ purity
20:03:13 <EvanR> just trying to save you guys keystrokes, and a needless digression into linguistic philosophy
20:03:17 <ADTJunkie> bburd: yea true
20:03:26 <ADTJunkie> lines are blurred lol
20:03:56 <Welkin> scala feels like java to me
20:04:14 <ADTJunkie> its just a wrapper for java written in java
20:04:15 <ADTJunkie> lol
20:04:22 <ADTJunkie> like nodejs is just javascript same idea
20:05:43 <texasmynsted> scala lives in the JVM.  It can not deviate too far and still be useful on the JVM
20:06:05 <EvanR> frege tho
20:06:11 <bburd> Frege is Haskell for the JVM.
20:06:19 <texasmynsted> The JVM is scala greatest strength and weakness
20:06:36 <ADTJunkie> is scala just frege and Jython then
20:06:37 <ADTJunkie> wtf
20:06:50 <mayhew> Wasn't there news about a LLVM Scala implementation recently?
20:06:59 <texasmynsted> I do not expect Frege to be as successful 
20:07:05 <texasmynsted> yes
20:07:13 <EvanR> well theres scalaz
20:07:14 <texasmynsted> But why LLVM.
20:07:37 <EvanR> who would reject scalaz, and move to frege without also dropping the whole thing and switch to haskell
20:07:51 <texasmynsted> Once use leave the JVM you have to wonder why scala over Haskell, Idris, etc.
20:08:19 <texasmynsted> I mean Once YOU leave
20:08:31 <bburd> I guess with Frege you get all the Java libraries.
20:08:41 <texasmynsted> to me scalaz is the right answer for scala
20:08:50 <EvanR> bburd: you also get java libraries in haskell....
20:08:55 <EvanR> java-bridge!
20:08:58 <geekosaur> familiarity, presumably
20:09:07 <ADTJunkie> is haskell not in the jvm?
20:09:11 <EvanR> java libraries in all their glory
20:09:23 <texasmynsted> o_O
20:09:41 <EvanR> jvm != ghc
20:09:42 <dmj`> ADTJunkie: no haskell in the jvm
20:09:54 <relrod> ADTJunkie: not yet, there's a GSOC project for it this year though: https://github.com/rahulmutt/ghcvm
20:10:03 <bburd> Does anyone here know any Android? I‚Äôm trying to make sense of a git repository about Frege for Android, and the author is nowhere to be found.
20:10:05 <Squarism> monochrom, worked out perfectly with recursion! Thanks for getting me back on track
20:10:14 <texasmynsted> doty should be better than scalac but there are limits 
20:10:19 <ADTJunkie> EvanR: what are the differences
20:10:24 <ADTJunkie> im sure one was influencerd by the other
20:10:34 <EvanR> all three of the letters of their acronyms
20:10:35 <geekosaur> the argument I have heard is that without the ability to do tail calls, it would perform very badly. but with tail calls finally arriving it's being looked at ahain
20:11:00 <texasmynsted> tail call elimination?
20:11:02 <EvanR> ADTJunkie: theyre actually completely different since they are designed for very different languages
20:11:17 <geekosaur> the way ghc works, all calls are tail calls
20:11:50 <texasmynsted> and it is part of what makes ghc so great
20:12:28 <texasmynsted> Get dependent typing in haskell and you can write off idris for me also
20:12:43 <ADTJunkie> how do you do pattern matching in haskell
20:12:43 <EvanR> well, soup up ghci's UI
20:13:19 <EvanR> add totality checking
20:13:28 <texasmynsted> what is wrong with ghci's UI?
20:13:28 <geekosaur> which pattern matching? Haskell has pattern matching but it doesn't mean what the term means outside of functional programming languages
20:13:34 <monochrom> we write "dependency injection" to mean we inject dependent types into Haskell.
20:13:38 <EvanR> texasmynsted: idris's repl is way nicer
20:13:46 <texasmynsted> oh
20:13:57 <EvanR> you can inspect a lot more of the program and the definitions
20:14:05 <ADTJunkie> like in scala I can just do
20:14:11 <geekosaur> ghci is in need of quite a lot of love. for that matter, so does the bytecode backend that it (and TH) uses
20:14:24 <sebleblanc> :t (. concat)
20:14:25 <lambdabot> Foldable t => ([a] -> c) -> t [a] -> c
20:14:29 <ADTJunkie> val var = x match { case Type1: => do something , etc } 
20:14:30 <texasmynsted> hmm‚Ä¶.. I recall watching a presentation by Daniel Spiewak about type inference....
20:15:03 <monochrom> case x of { Nothing -> 0; Just y -> y+1}
20:15:08 <texasmynsted> I need to find that again
20:15:16 <geekosaur> the ghci-ng package on hackage is a testbed for ghci work; 7.8.1's ghci is in sync with it
20:15:19 <Zemyla> geekosaur: I think the first step for that is writing documentation of how the bytecode works.
20:15:23 <monochrom> except in Haskell we don't "do something", we give answers.
20:15:49 <geekosaur> (that is, it was most recently used to test the stuff that was ultimately added to 7.8.1)
20:16:05 <geekosaur> er 8.0.1 sigh
20:17:18 <ADTJunkie> monochrom: the Just y can be any type?
20:17:29 <monochrom> no
20:17:43 <ADTJunkie> I feel like haskell would be easier to learn if I were a type theorist
20:18:02 <monochrom> yes, but not the only way
20:18:12 <glguy> Or a tutorial reader
20:18:21 <monochrom> indeed, haskell would be easier to learn if you invented haskell, too.
20:18:44 <geekosaur> :t case x of { Nothing -> 0; Just y -> y+1}
20:18:45 <lambdabot>     Couldn't match expected type ‚ÄòExpr‚Äô with actual type ‚ÄòMaybe t0‚Äô
20:18:45 <lambdabot>     In the pattern: Nothing
20:18:45 <lambdabot>     In a case alternative: Nothing -> 0
20:18:50 <monochrom> @quote monchrom download
20:18:50 <lambdabot> No quotes for this person.
20:18:56 <monochrom> @quote monochrom download
20:18:56 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
20:19:00 <texasmynsted> it would be easier to learn if you knew it already
20:19:06 <geekosaur> :t \x -> case x of { Nothing -> 0; Just y -> y+1}
20:19:07 <lambdabot> Num a => Maybe a -> a
20:19:17 <geekosaur> sometimes simple-reflect is annoying
20:19:17 <ADTJunkie> I just need to learn how to intuitively think of types (I have a degree in pure math btw)
20:19:22 <ADTJunkie> but I suck at programming /never taken cs
20:19:46 <monochrom> intuitionistic logic helps.
20:20:17 <geekosaur> but, case is the basic pattern matching / ADT deconstruction mechanism. (the others desugar to case)
20:20:28 <thimoteus> step 1) learn intuitionistic logic step 2) apply curry-howard step 3) know haskell
20:20:34 <monochrom> but precisely the problem with pure math people is that they don't think that explicitly doing symbolic logic helps.
20:20:46 <dibblego> the scala equivalent is x match { case None => 0; case Some(y) => y + 1 } 
20:20:49 <EvanR> ADTJunkie: types are totally applicable to math too
20:20:51 <thimoteus> i'm a pure math person who focused on logic :(
20:21:08 <ADTJunkie> hm
20:21:17 <bburd> thimoteus: Intuitionistic logic? Why intuitionistic?
20:21:17 <geekosaur> maybe you want mercury instead of haskell then? :)
20:21:20 <ADTJunkie> EvanR: yea I know its supposedly set theory but I only know set theory
20:21:26 <ADTJunkie> which I assume is more like object oriented programming lol
20:21:28 <dibblego> scala allows you to do type-casing in the match, unlike haskell. It is a bad idea to do type-casing, even though it is allowed (like many things in scala)
20:21:34 <EvanR> ADTJunkie: nah, set theory is that other thing
20:21:40 <thimoteus> bburd: because haskell's type system corresponds to some fragment (i think, havent really looked it up) of intuitionistic logic
20:22:03 <monochrom> bburd: because "Either a b" corresponds well with "a or b" if the "or" there is intuitionistic logic's "or", not classical logic's "or"
20:22:43 <EvanR> ADTJunkie: set theory is a classic *untyped* environment
20:22:55 <thimoteus> everything is a set!
20:23:08 <ADTJunkie> so what do I replace set by
20:23:11 <ADTJunkie> a type? 
20:23:14 <EvanR> yep
20:23:17 <ADTJunkie> and some rules?
20:23:28 <ADTJunkie> I Dont get how to formalize the rules to give the structure
20:23:32 <EvanR> rules like
20:23:36 <ADTJunkie> like okay peano arithmetic 
20:23:45 <ADTJunkie> is that a type constructor for Int ?
20:23:49 <EvanR>   Nothing : forall a . Maybe a
20:23:56 <EvanR>   Just : forall a . a -> Maybe a
20:25:04 <ADTJunkie> like how is the actual physical computer able to construct a data structure in memory from just the type and some rules lol
20:25:15 <EvanR> Int is isomorphic to a vector of 64 bits
20:25:35 <bburd> Either a b doesn‚Äôt obey the law of excluded middle?
20:25:42 <monochrom> right
20:25:43 <EvanR> but Int is abstract, and 64bits isnt
20:26:21 <EvanR> ADTJunkie: thats the language implementations job
20:26:56 <geekosaur> this level you don't want haskell, you want the STG I think?
20:27:08 <geekosaur> implementation details
20:27:20 <ADTJunkie> EvanR: but how do I know *if* I defined something right? like say I wanted to invent a data structure that behaved like a Ring , how do I knwo the computer will "get" my particular implementation of that logic?
20:27:33 <ADTJunkie> when theres infinitely many ways I could descripe it given the primitives of the language
20:27:35 <geekosaur> (and other haskell compilers do it differently, not that there are many around these days)
20:27:49 <ADTJunkie> thats what I really dont get about functional programming
20:27:49 <geekosaur> computer has no clue what a Ring is
20:27:55 <Zemyla> EvanR: Not all set theories are.
20:28:20 <EvanR> ADTJunkie: whether your axioms are "right" ? isnt that just math?
20:28:42 <EvanR> whether the program achieves some goal, thats another story
20:28:48 <Zemyla> NBG has both sets and proper classes, some set theories have ur-elements which aren't sets but can be in sets, and New Foundations has a transfinite stack of set types.
20:28:50 <ADTJunkie> yea but unless the compiler or VM is doing some kind of magic I dont get how it could know that
20:28:57 <EvanR> Zemyla: right...
20:28:57 <ADTJunkie> since theorem provers dont exist (in completion)
20:29:16 <ADTJunkie> like what magic is it doing behind the scenes
20:29:16 <geekosaur> "proofs are programs"
20:29:19 <monochrom> clearly, Haskell is not a theorem prover. or CAS.
20:29:48 <monochrom> it doesn't even bloody know e^(i pi) = -1
20:30:10 <monochrom> (and Mathematica does)
20:30:17 <EvanR> > e**(pi * (0 :+ 1)) == -1 :: Complex CReal
20:30:18 <lambdabot>      Couldn't match expected type ‚ÄòComplex CReal‚Äô
20:30:18 <lambdabot>                  with actual type ‚ÄòBool‚Äô
20:30:18 <lambdabot>      In the expression: e ** (pi * (0 :+ 1)) == - 1 :: Complex CReal    Could...
20:30:25 <EvanR> > e**(pi * (0 :+ 1)) == -1 :+ 0 :: Complex CReal
20:30:27 <lambdabot>      Precedence parsing error
20:30:27 <lambdabot>          cannot mix prefix `-' [infixl 6] and ‚Äò:+‚Äô [infix 6] in the same infi...
20:30:30 <EvanR> alkdsjflsdkfj
20:30:47 <geekosaur> it's not the language's job or the compiler's job or the computer's job to verify that your program correctly implements, say, Ring. (and it should not be; what if the point is to change things and see how the result doesn't behave right for a ring?)
20:30:57 <geekosaur> unless you are using a theorem prover, of course
20:31:02 <Zemyla> {-# RULES "Euler" exp (0 :+ pi) = (negate 1) :+ 0 #-}
20:31:13 <Zemyla> See, monochrom, now it knows that.
20:31:15 <monochrom> yeah it can compute some digits (especially since you use CReal). but it computes only. it doesn't use complex analysis.
20:31:23 <monochrom> haha
20:31:26 <geekosaur> and even then, you are providing it with the details and it's just checking your work
20:31:40 <EvanR> > exp (pi * (0 :+ 1))  :: Complex CReal
20:31:42 <lambdabot>  (-1.0) :+ 0.0
20:31:47 <geekosaur> (against what *you said* it should be)
20:32:09 <monochrom> case in point is it hangs hard when you ask for "filter (> 1) (repeat 0)"
20:32:44 <ADTJunkie> hm
20:32:55 <ADTJunkie> so it brute forces it lol?
20:33:17 <monochrom> it is a programming language, not a mathematician.
20:33:20 <geekosaur> there are programs out there that can do actual proofs. they're very much Ph.D fodder still
20:33:37 <EvanR> ghc was intentionally limited in its artificial intelligence, for everyones safety
20:34:09 <ADTJunkie> how does it decide on precision
20:34:13 <geekosaur> FP languages don't "know" math; they just have the ability to *represent* it
20:34:30 <geekosaur> but it's up to you to provide the representation
20:34:41 <geekosaur> (or get it from a package)
20:34:44 <monochrom> you choose your number type, Double or Float or CReal of Fixed or whatever. that determine precision. in other words you caused it.
20:35:05 <monochrom> it's a programming language. everything that goes wrong is your fault.
20:35:16 <ADTJunkie> I see
20:35:31 <ADTJunkie> so is there a version of haskell with machine learning built in?
20:35:34 <ADTJunkie> so its more like a CAS lol
20:35:47 <ADTJunkie> (and theorem prover)
20:36:07 <monochrom> yes. me.
20:36:24 <monochrom> I can run Haskell programs slowly and do some math quickly.
20:36:33 <geekosaur> also, because they run on real hardware, they have to use approximations for real numbers (hence Float, Double, CReal, etc. so you can tell it how to approximate for your purpose)
20:37:07 <ADTJunkie> seems like all of programming is built to evade poor choices hardware ppl made in memory design
20:37:08 <ADTJunkie> lol
20:37:27 <ADTJunkie> redesign the memory imagine the languages that could come out of it 
20:37:39 <EvanR> they should have just gone with the infinite tape
20:37:43 * geekosaur suggests reading soem Cantor to see the flaw in that
20:38:59 <monochrom> I don't see what's fundamentally wrong with current memory design.
20:39:07 <geekosaur> Cantor diagonalization, and its ramifications, puts a serious crimp in what you can do with any real device
20:39:12 <ADTJunkie> you could optimize it tho for recurisve calls and functional paradigms instead of this von neumann shit
20:39:19 <monochrom> Or rather, I don't see what a redesign can be.
20:39:36 <ADTJunkie> monochrom:  I feel like its object oriented inherently
20:39:49 <geekosaur> @google can programming be liberated from von neumann
20:39:51 <ADTJunkie> because ultimately youre representing datastructures in memory as objects 
20:39:52 <lambdabot> http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf
20:39:52 <lambdabot> Title: Can Programming Be Liberated from the von Neumann Style? A Functional Style a...
20:40:20 <ADTJunkie> i dunno how youd represent a function tho physically
20:40:21 <ADTJunkie> lol
20:40:34 <ADTJunkie> maybe as an array of its values ?
20:40:46 <geekosaur> and the STG upon which ghc is based is one vision of that. I'm not sure you could actually do that in hardware though (I do not mean here CPU microcode, that's just pushing Von Neumann down a level)
20:41:00 <EvanR> they do have new CPU architectures with these moving memory windows, maybe that can help a ghc
20:41:02 <dmj`> geekosaur: that first sentence, wow
20:41:09 <dmj`> "Conventional programming languages are growing ever more enormous, but not stronger."
20:41:17 <dmj`> true then, truer now
20:41:38 <ADTJunkie> implement it on an FPGA
20:42:00 <geekosaur> plus √ßa change, plus √ßa m√™me chose
20:42:36 <EvanR> ADTJunkie: representing a function is boring, lets just talk about its relationships to other things
20:42:49 <sebleblanc> *c'est la m√™me chose
20:42:51 <EvanR> what laws does it follow
20:43:09 <ADTJunkie> so its really that easY?
20:43:19 <ADTJunkie> if I Can represent hte law in the syntax
20:43:22 <ADTJunkie> it will compile?
20:43:36 <EvanR> in coq, agda, idris
20:43:43 <ADTJunkie> I feel like im assuming some natural faithfulness to semantics and syntax 
20:43:45 <ADTJunkie> which isnt there
20:48:28 <ADTJunkie> so if there can be runtime errors whats the point of being so type safe like in haskell
20:49:11 <ADTJunkie> or is that not one of the goals of haskell?
20:49:18 <EvanR> you can think of a program that crashes as not done yet
20:49:40 <EvanR> you probably want to try your program before its really really done
20:49:58 <dmj`> totality isn't a requirement of functions in haskell, but it does warn you
20:52:42 <ADTJunkie> has anyone ever studied the movement in physical memory while the ghc is running to find the optimal way to create memory for functional langauges?
20:54:08 <dfeuer> hexagoxel?
20:55:19 <dfeuer> dmj`, it only warns about pattern coverage problems, not non-termination.
20:55:39 <ADTJunkie> like if voltage tends to flow in a certain way while functions are executed in the GHC then youd know how to construct the physical layout for a rela GHC
20:55:40 <ADTJunkie> real*
20:55:58 <EvanR> current flows, voltage does not
20:56:17 <sebleblanc> EvanR, with capacitance, voltage "flows"
20:56:38 <ADTJunkie> well current then 
20:56:49 <EvanR> o way
20:57:16 <ADTJunkie> its probably just a graph 
20:57:19 <ADTJunkie> like nodes 
20:57:24 <ADTJunkie> on a cluster computer
20:58:15 <ADTJunkie> they should make Graph MEmory
20:58:22 <ADTJunkie> (just invented that)
20:59:42 <ADTJunkie> just use machine learning + Djkstras algorithm to find the optimal path 
20:59:51 <ADTJunkie> every CPu cycle 
21:00:25 <EvanR> it might end up like dial F for frankenstein
21:03:20 <ADTJunkie> yea
21:03:38 <ADTJunkie> thatd be cool
21:04:14 <ADTJunkie> I think were on the verge of real AI ...all we gotta do is get the hardware to spin up 40 billion VMs and run a simulation of 1 neuron on each 
21:04:27 <ADTJunkie> then do some machine learning to connect all the IPs together
21:04:32 <dmj`> dfeuer: ah, yea :/ another problem indeed
21:05:03 <ADTJunkie> itd just be some routing algorithm written in a message passing framework
21:05:14 <ADTJunkie> that minics brain waves
21:23:08 * hackagebot vty 5.7.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.7.1 (JonathanDaugherty)
22:13:10 * hackagebot servant-aeson-specs 0.1 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.1 (SoenkeHahn)
22:35:38 <dfeuer> *headshake*. Since `seq` was made fully polymorphic before Haskell 98, I've had to write my own temporary Force class just to verify that I'm not forcing anything I shouldn't.
22:37:36 <Cale> dfeuer: oh?
22:37:48 <Cale> dfeuer: Is it a problem to force the evaluation of functions in your case?
22:38:47 <dfeuer> Cale, I want to make sure that I'm not forcing something I know nothing about!
22:39:10 <Cale> ah, fair enough
22:39:27 <dfeuer> I'm not supposed to be forcing elements, but the code is (necessarily) so polymorphic that it's a bit hard to see whether I could be doing so.
22:40:06 <dfeuer> By temporarily creating an empty Force class, I can make my type signatures tell me which argument types are safe to force.
22:41:00 <dfeuer> Had the Haskell designers been wiser (IMO), I wouldn't need such nonsense.
22:42:41 <EvanR> whats not safe to force?
22:43:02 <EvanR> in the sense that you guard against it in the type of seq
22:43:56 <Zemyla> Okay, I think I've actually figured out how to do a free arrow type.
22:45:14 <Zemyla> dfeuer: Why not just use NFData?
22:45:16 <dfeuer> EvanR, in my particular case, I want to avoid forcing the elements that are handed to me, because I'm supposed to be lazy in them. Forcing functions is generally evil.
22:47:22 <dfeuer> Zemyla, that's valid, under the circumstances. Didn't think of it.
22:47:25 <Zemyla> dfeuer: I've always seen forcing functions as harmless, since they really shouldn't do anything until called.
22:47:25 <dfeuer> Oh, but they can be _|_.
22:47:26 <dfeuer> Because Haskell.
22:47:26 <coppro> ^
22:47:26 <coppro> they may also be slow
22:47:26 <coppro> even if defined
22:47:39 <dfeuer> Also true.
22:47:42 <Zemyla> coppro: Well, souldn't orcing the function itself not be slow?
22:47:42 <Zemyla> And if it is _|_, wouldn't you rather find about it sooner than later?
22:47:42 <EvanR> forcing functions is evil?
22:47:42 <dfeuer> foo a  = case blah blah blah of Yeah x -> \b -> ....
22:47:42 <coppro> Zemyla: not if you can get away with never evaluating it at all
22:47:42 <coppro> and no, you can't assume that forcing anything is fast
22:48:17 <dfeuer> EvanR, pretty much. Good general rules: 1. Don't have undefined functions. 2. Don't force functions.  Violate these rules and shit can get a bit weird.
22:48:43 <dfeuer> Not like segfault weird, but just unexpected weird.
22:49:25 <dfeuer> undefined functions are sometimes tolerable because no one in their right minds forces them :-)
22:49:49 <EvanR> does "force" in this case just mean force and seq, or does it include applying it to something
22:50:06 <dfeuer> Just means evaluate and seq.
22:50:13 <dfeuer> And ! and all that.
22:50:23 <EvanR> case cant do it right
22:50:31 <EvanR> without !
22:50:35 <dfeuer> Right.
22:51:21 <EvanR> > const (+1) undefined 9
22:51:23 <lambdabot>  10
22:51:41 <EvanR> mkay
22:54:08 <EvanR> trying to understand the effect of applying a function which is closing over stuff
22:54:26 <EvanR> does that evaluate the closed over stuff, i guess not
22:54:37 <EvanR> in which case who cares if you force it
22:55:01 <EvanR> i guess because theres stuff leading up to the \
22:56:03 <EvanR> let x = if collatzConjecture then const 9 else id in [x,x,x]
23:38:12 * hackagebot wolf 0.2.7 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.7 (markfine)
23:43:59 <pavonia> Is there any trick to keep values bound to a variable in a GHCi session in memory across reloading of modules?
23:44:24 <Axman6> there's a package for that...
23:44:30 <Axman6> I can't remember its name
23:45:11 <EvanR> rapid
23:45:29 <EvanR> which is based on foreign-store
23:46:10 <EvanR> https://hackage.haskell.org/package/foreign-store-0.2/docs/Foreign-Store.html
23:46:13 <pavonia> I'll have a look at it, thanks
23:54:37 <Axman6> EvanR: nice team work bro, I set 'em up, you knocked 'em down
23:56:36 <EvanR> bro do you even store
23:57:23 <pavonia> Hhm, how do you use these Stores? I obviously can't use them directly in GHCi because I would lose the reference to the Store when reloading the module
23:57:57 <EvanR> the Store is a newtype wrapper around a Word32
23:58:02 <EvanR> still...
23:58:06 <EvanR> not sure
23:58:39 * EvanR looks at rapid
