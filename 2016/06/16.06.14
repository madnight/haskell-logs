00:12:57 <quchen> koz_: Map is traversable, and there's parTraversable for example
00:13:15 <koz_> quchen: I'll have to look into it then.
00:13:33 <quchen> If you want to have access to the keys as well as the values, then splitRoot is probably what you have to use, yes
00:13:46 <koz_> I need both keys and values to do what I want.
00:13:58 <koz_> I was actually just checking how Traversable is defined for Maps.
00:14:24 <quchen> You don't have access to the keys in the Traversable instance.
00:15:10 <koz_> quchen: OK, so it is splitRoot-reliant, then.
00:15:18 <quchen> Well, actually "Map" isn't traversable â€“ "Map k" is.
00:15:21 <koz_> OK, I'll have to think a bit then - thanks!
00:16:43 <quchen> Unfortunately, it's an implementation detail of Data.Map that it's a tree internally; you don't have access to any of that.
00:23:29 * hackagebot cryptonite 0.17 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.17 (VincentHanquez)
01:27:16 <quicksilver>  lens gives you key-and-value traversing though
01:33:41 <ocramz> hullo!
01:36:46 <ocramz> I'm looking for a robust way of retrieving environment variables. In particular, some might be declared in the users's .bashrc or similar. Related question: what variables are accessible to `getEnvironment` from System.Environment ?
01:38:04 <liste> ocramz: so you want to read the .bashrc variables even if the program is run from something other than bash?
01:40:59 <lemonxah> morning
01:41:12 <lemonxah> what is a do block?
01:41:42 <lemonxah> well thats not really my question
01:42:30 <quchen> ocramz: The environment is given to a program by the shell. It does not matter where those variables come from, your program is initialized with an environment and that's it.
01:42:37 <chelfi> it is syntactic sugar
01:42:45 <chelfi> well thats not really my answer
01:43:01 <quchen> ocramz: You can view your current shell's environment by running 'env'
01:47:41 <liste> @undo do {x <- foo; y <- bar; return (x + y)}Â -- lemonxah
01:47:42 <lambdabot> <unknown>.hs: 1: 40:Parse error: Â
01:47:54 <liste> wat
01:47:57 <lemonxah> so do is just for monads?
01:48:06 <lemonxah> and return is lifting the result into a monad?
01:48:13 <liste> lemonxah: yes, they plan on expanding it to Applicative though
01:48:59 <liste> return is a function
01:49:01 <liste> :t return
01:49:02 <lambdabot> Monad m => a -> m a
01:49:13 <quchen> @undo do { x <- foo; y <- bar; pure (x+y) }
01:49:13 <lambdabot> foo >>= \ x -> bar >>= \ y -> pure (x + y)
01:49:14 <lemonxah> yeah i know i saw it with
01:49:19 <lemonxah> :info Monad
01:49:22 <quchen> Not sure why it didn't work before
01:49:34 <quchen> There's no :info in Lambdabot :-/
01:49:55 <lemonxah> yeah i see that :) but in ghci i saw that return is just lifting 
01:52:47 <lemonxah> is there something i can read to help me understand monads?
01:53:02 <lemonxah> or some trivial example of how to write my own and why i need it
01:54:29 <ocramz> env
01:54:33 <ocramz> oops :D
01:55:58 <liste> lemonxah: I'd start with Functor first
01:56:15 <liste> (unless you already understand it, of course)
01:56:19 <lemonxah> i think i know what functor is
01:56:33 <lemonxah> the problem really is i think i understand what a monad is but then i think i dont
01:56:49 <lemonxah> like i understand that a monad is an applicative which inturn is a functor
01:57:19 <lemonxah> functor adds "map" and monad adds "bind" i think you call it in haskell in scala its called flatMap
01:57:38 <lemonxah> and i know how to use it 
01:58:00 <lemonxah> like i can get 2 input stirngs concatenated by like fmap (++) getLine <*> getLine
01:58:21 <lemonxah> and then you have an IO String monad that contains the concatenated string 
01:58:31 <merijn> lemonxah: Interesting exercise for you
01:58:33 <lemonxah> but what i dont undestand is why 
01:58:40 <lemonxah> why do i need it
01:58:51 <merijn> lemonxah: Try to implement Functor, Applicative, Monad for "data Const k a = Const k"
01:58:53 <lemonxah> i have not gotten the why yet so my understanding is limited
01:59:10 <merijn> What can be implemented, what can't, what needs extra constraints?
01:59:35 <merijn> lemonxah: tbh, your example has nothing to do with monads or applicative
01:59:54 <lemonxah> its using the IO Monad kind of
02:00:01 <lemonxah> stupid example but i guess that is my point
02:00:04 <merijn> lemonxah: You could have code that does "fmap (++) getLine <*> getLine" without having Functor, Applicative, Monad
02:00:07 <lemonxah> i need to learn more about what it is
02:00:22 <lemonxah> yeah but getLine is IO Monad
02:00:27 <merijn> No
02:00:32 <merijn> getLine is IO
02:00:48 <merijn> there is nothing "monadic" about "IO String"
02:01:09 <merijn> "Being a monad" is a property of a type, not a property of IO values
02:01:20 <lemonxah> i understand but there is instances for Monad IO and Functor IO and Applicative IO
02:02:05 <lemonxah> so calling fmap on IO String uses the instance of the Monad type class?
02:02:07 <merijn> lemonxah: Sure, but my point is that IOs behaviour is not derived from that
02:02:21 <merijn> lemonxah: If those typeclasses did not exist IO could do the exact same things it can now
02:02:39 <lemonxah> yes if IO had the functions to do it?
02:02:45 <merijn> lemonxah: So IO is an instance of those things because those interfaces capture (some) of the functionality of IO
02:03:09 <lemonxah> yeah i understand that i think
02:03:10 <merijn> lemonxah: IO doesn't derive any functionality from being an instance of those things (well, besides notational convenience :))
02:03:30 <merijn> lemonxah: So probably your issue is not "I don't understand applicative/monad", but "I don't understand IO"
02:03:39 <lemonxah> so how i understand it is that IO does not know what <*> is
02:03:56 <lemonxah> but since there is a typeclass instance of Functor for IO 
02:04:20 <lemonxah> you can then use <*> with IO 
02:04:23 <r444> <*> is defined with an Applicative typeclass
02:04:32 <r444> IO has an Applicative instance
02:04:34 <lemonxah> yeah typo soz
02:04:44 <younder_> Maybe it would be easier to use exceptions. The pure solution is Just awkward bu I suppose it is better than Nothing..
02:04:53 <lemonxah> i meant <*> is applicative 
02:05:17 <lemonxah> and you can do (>>=) since there is a Monad instance 
02:05:22 <merijn> younder_: My rule of thumb is: Maybe for library APIs, exceptions for internal use in applications
02:05:45 <merijn> younder_: (Alternatively provide an exception based API in addition to the Maybe one in your library)
02:06:03 <merijn> lemonxah: So, what is the confusion? :)
02:06:27 <lemonxah> merijn i dont know what it is that is confusing me 
02:06:33 <lemonxah> but i am very confused
02:06:59 <lemonxah> i have never grasped the (why do i need it)
02:07:12 <lemonxah> it doesn't solve a problem for me i guess
02:07:42 <merijn> lemonxah: Functor, Applicative, Monad are just abstract "interfaces" (not in the OO sense, but in the "pattern" sense). And people noticed "hey, these interfaces are really general and cover lots of different problems"
02:08:25 <lemonxah> in the context of lets say the Maybe those interfaces makes all the sense in the world
02:08:35 <merijn> lemonxah: The only overarching thing about Functor/Applicative/Monad is that they have some laws about how said interfaces should work, such as "return x >>= f" being equal to "f x"
02:09:18 <merijn> lemonxah: Maybe the key insight is that Haskell distinguishes between evaluation and execution.
02:10:16 <merijn> lemonxah: Evaluation is how haskell expressions are, well, evaluated. It's described in the haskell report. "IO a" is just another value, it's effectively a "program fragment" that produces an 'a' when executed
02:10:53 <merijn> lemonxah: Note that there's no way to execute an IO *inside* haskell. So you can never observe the effects of execution from within Haskell (this is why the language is pure)
02:11:23 <koz_> And then you combine all the IOs into one big IO, which actually gets executed.
02:11:44 <koz_> When you combine IO using the monadic binding operator, you're basically saying 'please do these things in this order when you do the big IO thingy'.
02:11:46 <merijn> lemonxah: So fmap/>>=/etc are just "program fragment transformers". fmap takes a function "(a -> b)" and turns a program fragment that produces an 'a' and changes it into a program fragment that produces a 'b'
02:12:40 <merijn> lemonxah: Similarly "(>>=) :: IO a -> (a -> IO b) -> IO b" says "take a program fragment that produces an 'a' and a function that uses an 'a' to produce a program fragment producing a 'b' and produce a program fragment producing 'b'"
02:13:49 <lemonxah> i understand that aswell
02:13:53 <merijn> lemonxah: Consider this "putStrLn :: String -> IO ()" what does this do? Well, it takes a String and produces a program fragment that, when executed, prints said String and produces a '()'. Why is this pure? Well, consider what purity means. A function is pure IFF when given the same input it always evaluates to the same result.
02:14:18 <lemonxah> its very difficult to ask for help on this matter cause i understand most of everything everyone tells me but there is some small tiny bit that just haven't clicked yet
02:14:32 <merijn> lemonxah: putStrLn when given the same input (String) produces the same result "a program fragment that, when executed, prints said String"
02:15:38 <merijn> tbh, in my experience people tend to overthink Monad. "This all seems fairly simple, so I guess I'm missing some deep insight", the truth is "it's just not that complicated and there is no secret deep insight". (Or maybe the lack of deep insight is the deep insight...)
02:16:01 <lemonxah> maybe that is it
02:16:39 <lemonxah> if i could write my own monad instances for an arbitrary type and know why i needed to do that .. what benefit i get from doing that 
02:16:46 <lemonxah> that is what i want to know really
02:17:20 <lemonxah> like i would be able to impliment functor and monad and (with some difficultly) applicative instances for any type
02:17:35 <koz_> lemonxah: http://dev.stephendiehl.com/hask/#whats-the-point
02:17:43 <koz_> Have a look at this - it may just be the flash of insight you seek.
02:17:45 <lemonxah> but i am missing the (why would i want to, what problem does this solve for me)
02:18:00 <merijn> lemonxah: Because there's 1000s of lines and library code that works with any functor
02:18:15 <merijn> lemonxah: And if I implement Functor/Monad all of that will work on my data too
02:18:35 <lemonxah> hmm 
02:18:44 <merijn> lemonxah: Consider
02:18:48 <merijn> @hackage monad-loops
02:18:48 <lambdabot> http://hackage.haskell.org/package/monad-loops
02:18:49 <lemonxah> could you give an example of some library call that you use frequently
02:18:49 <koz_> merijn: Is there any blogpost/tutorial/shamanistic wisdom about reducing a Haskell program's RAM footprint?
02:18:57 <koz_> lemonxah: fmap
02:19:02 <merijn> koz_: Profiling :p
02:19:12 <merijn> koz_: I think RWH has a chapter on how to profile
02:19:21 <koz_> merijn: Yeah, I know *that*. Once I've identified where heavy allocation is, how do I then reduce it?
02:19:21 <lemonxah> koz_, fmap isn't library code its part of the functor interface
02:20:02 <merijn> koz_: Depends on what it is :)
02:20:24 <koz_> merijn: OK, I'll just look into it more thoroughly and ask you. :P
02:20:35 <koz_> I've been behind a profiler for the last week or so. :P
02:21:15 <merijn> koz_: lpaste the profiling results/upload the coloured memory usage graph?
02:21:38 <koz_> merijn: Sure - but you'd probably want the sauce code to put it into context as well.
02:21:46 <koz_> Let me just get some fresh results from the changes I've made.
02:22:08 <merijn> lemonxah: Have you looked at Parsec/Attoparsec? Those are good example of good use of the monad interface
02:22:19 <koz_> merijn: And the Applicative one now.
02:22:38 <koz_> (although probably ReactiveBanana is a better one for Applicatives...)
02:23:14 <koz_> Another really important (ab)use of Functors - the lens.
02:23:39 <merijn> Oh, digestive functors are a nice web-oriented example of Applicative
02:23:46 <koz_> merijn: Wat?
02:24:39 <lemonxah> merijn not yet
02:26:13 <koz_> lemonxah: http://unbui.lt/#!/post/haskell-parsec-basics/
02:26:15 <merijn> koz_: Also known as formlets, see: https://www.era.lib.ed.ac.uk/bitstream/handle/1842/3686/The%20Essence%20of%20Form%20Abstraction.pdf?sequence=1
02:26:20 <koz_> That makes it super-fun and easy to follow.
02:26:28 <koz_> merijn: Ah, OK.
02:26:36 <koz_> As ever, Haskell has the sickest technology.
02:26:37 <merijn> koz_: The paper uses ocaml, but it should be readable with basic haskell knowledge
02:26:47 <lemonxah> merijn, hmm maybe i should take a problem domain i undestand and know how to solve and then ask someone to solve this using monadic design and then see the difference
02:27:57 <koz_> lemonxah: Seriously, check out the Parsec link I sent you.
02:28:10 <lemonxah> i am reading it now thank you
02:28:23 <koz_> If you've *ever* tried to parse structured text in any language and beat your head against the wall and cried in frustration, *that* will show you the difference. :)
02:28:43 <koz_> merijn: OK, I think I found a culprit - I have heavy alloc from my Fisher-Yates shuffler.
02:29:00 <merijn> koz_: Odd, that should be O(n) space at most :)
02:29:07 <koz_> Let me get the sauce code real quick.
02:29:22 <koz_> merijn: https://wiki.haskell.org/Random_shuffle#Purely_functional <-- this one here
02:29:27 <koz_> I'm having to shuffle rather large lists.
02:29:40 <koz_> I might have to check precisely *how* large, but they're *large*.
02:30:08 <muzzle> hi
02:30:14 <merijn> koz_: Might wanna use a ST based one?
02:30:21 * koz_ has beaten his head against the wall and cried in frustration at structured text parsing in non-Haskell langs.
02:30:22 <muzzle> i'm using the bloom filter library and the functions seem to require a Storable bound
02:30:28 <koz_> merijn: ST?
02:30:30 <muzzle> but their type signature doesn't show it 
02:30:40 <muzzle> can anyone help me understand whats going on here?
02:30:42 <lemonxah> is parec a depency i have to download?
02:30:46 <koz_> lemonxah: Yes.
02:30:55 <koz_> Just a bit of Cabal magic.
02:31:17 <merijn> koz_: "State Thread", ST is essentially a limited version of IO. So you have mutable references, but since the side effects are limited you can "purify" the results at the end
02:31:37 <merijn> koz_: See the "Lazy Functional State Threads" for details
02:31:42 <koz_> merijn: Alrighty, shall do.
02:32:01 <merijn> koz_: Basically, ST lets you implement pure functions that use mutable state internally :)
02:34:24 <koz_> The other major alloc culprit is here: http://lpaste.net/166039
02:34:59 <koz_> That thing is damn near 1/3 of all the allocs in my code.
02:35:28 <koz_> (and its calls are about 1/4 of the CPU time)
02:35:35 <merijn> koz_: Have you tried forcing the "size" computation?
02:35:53 <muzzle> Can functions require type class bounds that are not visible in the type signature ?
02:36:03 <merijn> As a side note, why have an if/then inside a guarded clause?
02:36:04 <koz_> merijn: On the thing I just linked?
02:36:11 <merijn> muzzle: No
02:36:14 <merijn> koz_: Yes
02:36:56 <koz_> merijn: Nope, haven't tried forcing it. And the guard is because at termination, this might Nothing-out under certain conditions, although I guess I could just guard it properly.
02:37:08 <muzzle> merijin No instance for (Storable t) ... arising from a use of â€˜BF.Easy.easyListâ€™
02:37:16 <muzzle> merijn vs. https://hackage.haskell.org/package/bloomfilter-2.0.1.0/docs/Data-BloomFilter-Easy.html
02:37:18 <koz_> merijn: How would I force the size there?
02:37:20 <merijn> koz_: "(M.size t, targ)" <- seems like it'd keep 't' alive until you eventually force the size
02:37:53 <merijn> koz_: "let s = M.size t in s `seq` Just (s, targ)"
02:38:16 <koz_> Alrighty, I'll give it a try.
02:39:29 <koz_> And rewrite with proper guards!
02:39:59 <merijn> koz_: I'm assuming your Table is 1) big and 2) you frequently compute new ones?
02:40:08 <osager_> * No module named "Main". The 'main-is' source file should usually have a header indicating that it's a 'Main' module.
02:40:18 <osager_> what is wrong here
02:40:37 <osager_> its a livrary
02:40:41 <osager_> no main file
02:40:47 <koz_> merijn: Yes to both.
02:41:07 <koz_> osager_: Do you have it under an executable build in your .cabal?
02:41:16 <koz_> merijn: OK, taking it for a spin.
02:41:33 <osager_> no
02:41:46 <osager_> it's under Library
02:41:55 <merijn> koz_: Right, so you want computations using Table as input to be forced ASAP, that way you don't keep the tables alive until, e.g., the size finally gets forced
02:41:57 <koz_> Wow merijn - that *alone* brought the speed up and the memory use down *heaps*.
02:42:20 <lemonxah> koz_, http://lpaste.net/166040
02:42:32 <merijn> koz_: It can help to get a better understanding of how laziness works operationally if you wanna reason about performance
02:42:42 <lemonxah> when trying to run just that in my ghci so that i can follow along
02:42:44 <koz_> merijn: Any good reading material?
02:43:10 <merijn> koz_: Depending on how deep you wanna go https://hackhands.com/guide-lazy-evaluation-haskell/ is a nice beginner piece 
02:43:20 <merijn> koz_: If you want more detailed stuff, there's the STG paper: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
02:43:23 <koz_> lemonxah: You need to say 'let blah blah blah'.
02:43:33 <koz_> In GHCi, any definitions require let.
02:43:42 <lemonxah> oh no its in a test.hs file
02:43:45 <koz_> merijn: Thank you - I will read them for great justice.
02:43:46 <lemonxah> and i use :l test
02:43:48 <lemonxah> to load it
02:43:50 <merijn> koz_: The latter probably requires basic C or ASM knowledge, but is a very interesting read
02:43:50 <osa1> actually that's not true with 8.0.1
02:44:04 <koz_> merijn: I have pretty good C, so it'll be OK.
02:44:09 <merijn> koz_: It's a bit out of date with the reality of what GHC does currently, but it's a good intuition
02:44:14 <osa1> you can define stuff without let. it's a little bit broken though.
02:44:42 <koz_> osa1: Well, I didn't know. Thanks for the info!
02:44:50 <osager_> ok one LICENSE file missing...
02:44:57 <merijn> koz_: The STG paper is basically "how can you compile a lazy functional language to C/ASM to have it actually work"
02:44:58 <koz_> lemonxah: You need to give it a type.
02:45:00 <osager_> error message is missleading
02:45:14 <koz_> Because otherwise, Parsec doesn't have the first clue wtf you want it to parse out.
02:45:45 <koz_> merijn: Interesting - will *definitely* look into that one.
02:46:34 <koz_> Also, holy shit, laziness guide written by Apfelmus! Definitely reading.
03:01:46 <lemonxah> havnig the hardest time typing that function
03:25:01 <lemonxah> i learn so slow the last few years
03:25:21 <lemonxah> i feel like i am getting dumber as i get older
03:26:13 <Koen_> or maybe the things you have been trying to learn recently are much arduous than the things you used to learn when you were younger?
03:27:17 <lemonxah> i could learn new concepts of programming way easier 
03:27:45 <KaneTW> http://eric.seidel.io/pub/nanomaly-icfp16.pdf this is cool
03:27:50 <lemonxah> its only been 15 years since i started out as a junior dev but .. i am super stupid now
03:28:17 <KaneTW> lemonxah: everybody gets dumber as you get older
03:28:27 <lemonxah> yeah .. but it still sucks
03:28:28 <KaneTW> you get dumber the more you know, even!
03:28:34 <KaneTW> it does
03:29:03 <lemonxah> i am super sad that i didn't start out my programming carreer doing haskell or another functional langauge
03:31:26 <bernalex> lemonxah: then you'd be learning something else now, thinking "omg why didn't I learn this 15 years ago?" -- it's a useless thought process. :)
03:33:19 <lemonxah> but fp uber alles
03:33:27 <lemonxah> ;P
04:03:37 * hackagebot slack-api 0.9 - Bindings to the Slack RTM API.  https://hackage.haskell.org/package/slack-api-0.9 (mpickering)
04:09:53 <osager_> how to understand this:
04:09:54 <osager_> class Imageable i where
04:09:54 <osager_>   type Pixel i :: *
04:10:49 <kishar> "The best time to plant a tree is twenty years ago. The second best time to plant a tree is now," etc.
04:11:20 <bergmark> An Imageable type has a Pixel type associated with it
04:11:22 <Eduard_Munteanu> osager_, in terms of MPTCs and fundeps, that's   class Imageable i p | i -> p
04:11:59 <osager_> associated ?
04:13:26 <Eduard_Munteanu> osager_, for every 'i' such that 'Imageable i', there's a type 'Pixel i'.
04:14:34 <osager_> ok so this is just to help ghc to reduce some guess work right /
04:14:35 <osager_> ï¼Ÿ
04:14:36 <Eduard_Munteanu> The instance definition picks/sets that type.
04:15:49 <Eduard_Munteanu> osager_, maybe, if you mean that every 'i' uniquely determines a 'Pixel i'.
04:17:55 <Eduard_Munteanu> osager_, perhaps an example would be better
04:20:27 <Eduard_Munteanu> osager_, consider   class StringLike s where type Character s :: *; foldString :: (a -> Character s -> a) -> a -> s -> a
04:21:16 <Eduard_Munteanu> osager_, for String, an obvious instance is   instance StringLike String where type Character String = Char
04:21:49 <Eduard_Munteanu> osager_, for ByteString, you would have something like    instance StringLike ByteString where type Character ByteString = Word8
04:23:15 <Eduard_Munteanu> Instance selection, when calling foldString, is based on that 's' type.
04:36:24 <osager_> thanks Eduard_Munteanu 
04:37:46 <osager_> if i dont write the dependcy thing, it should still compile
04:37:55 <osager_> just bad performance impact right?
04:37:58 <osager_> Eduard_Munteanu, 
04:47:27 <bergmark> osager_: it's there to resolve ambiguities, it's not related to performance
05:21:49 <Eduard_Munteanu> osager__, it won't compile without that associated type synonym
05:22:01 <osager__> why
05:23:28 <cheater> i've just seen this, it's really really cool: http://neilmitchell.blogspot.co.at/2015/09/detecting-space-leaks.html
05:24:35 <merijn> Eduard_Munteanu: There's no such thing as an "associated type synonym" you're thinking of an associated type family maybe?
05:25:31 <Eduard_Munteanu> merijn, well, type families are type synonyms basically. That is, they're not data/newtype.
05:25:51 <merijn> Eduard_Munteanu: no, that's fundamentally not true
05:25:57 <Eduard_Munteanu> osager__, because the Pixel type won't be defined?
05:26:08 <merijn> Type synonyms are literally that, as textual substitution for another type
05:26:19 <merijn> Type families can do many things type synonyms cannot do
05:27:56 <Eduard_Munteanu> merijn, seems the manual uses a similar terminology: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#synonym-families
05:28:53 <Eduard_Munteanu> "they can appear inside type classes (in which case they are known as associated type synonyms)."
05:29:31 <merijn> hmmm
05:29:48 <merijn> I'm unhappy with whoever wrote that :\
05:30:48 <Eduard_Munteanu> merijn, I interpret "synonym" rather loosely, as in "some type which reduces to another type".
05:52:57 <buttbutter> Hi. I'm trying to create a data type for an infinite list (called a Stream). This is what I have, and the compilation error I get: http://lpaste.net/new/haskell . So I understand the compilation error (the only data constructor is Element), but it brought up further questions. Why can't I use a type constructor in an expression? And should I just...make a data constructor "Stream a" to fix it?
05:53:34 <buttbutter> Oops, fail link.
05:53:47 <buttbutter> Fixed: http://lpaste.net/166045
05:54:44 <Eduard_Munteanu> buttbutter, because a type constructor is a type, not a term-level thing
05:54:55 <buttbutter> Term-level?
05:55:05 <Eduard_Munteanu> buttbutter, something part of an expression
05:55:15 <Eduard_Munteanu> buttbutter, similarly, you can't use Int in an expression
05:55:27 <buttbutter> Oh, right. That makes sense. :)
05:58:41 <cheater> is a schrÃ¶dinger cat box a good analogy for a haskell box?
05:58:57 <buttbutter> Oh, I figured out the second part of my question (in case anyone was going to answer it). Thanks :D
06:00:15 <maerwald> is there another way to compare constructors easily without Data.Data? Some GHC extension maybe
06:01:32 <maerwald> my data type includes IOException at some point which breaks deriving Data and writing a Data instance manually is very annoying and more code than writing custom comparison functions
06:01:43 <cheater> compare in what way?
06:01:48 <maerwald> the constructors
06:01:57 <cheater> yes, what do you wish to compare?
06:02:02 <maerwald> the constructors
06:02:24 <cheater> :)
06:03:36 <cheater> you mean as in the compare function?
06:04:05 <cheater> you could use Enum for that
06:15:32 <maerwald> cheater: it can't derive enum automatically and that will also make writing 'isConstructor :: Constr -> Bool' functions non-type safe
06:15:48 <maerwald> because I rely on Ints then
06:16:05 <cheater> you mean like isLeft, isRight?
06:16:30 <maerwald> yeah, but the main point is I have to write the Enum instance myself, at which point I again gained almost nothing
06:17:12 <tinco> cheater: when you said 'because of boxing' (in #rust) did you mean because operations are applied to thunks and not immediately evaluated so you don't really over-alloc?
06:17:56 <cheater> maerwald: http://sprunge.us/WEji
06:18:29 <maerwald> I don't like it, I'd rather write explicit isFoo functions then
06:18:38 <cheater> OK
06:18:49 <maerwald> !! and fromJust ..
06:19:02 <maerwald> next time I change something, my code will blow up at runtime
06:19:20 <cheater> the haskell type system is a proof assistant, in this instance i can prove things by hand that haskell can't
06:19:35 <cheater> proving this piece of code by hand isn't an issue
06:19:46 <cheater> it is well augmented by quickcheck
06:20:55 <maerwald> when I add a constructor I also have to remember fixing the list...
06:21:06 <maerwald> another source of bugs
06:22:43 <cheater> yep
06:22:46 <cheater> that's unfortunate
06:23:03 <Axman6> maerwald: why not use prisms?
06:23:07 <cheater> this code is uglier than what i'd normally accept, but this time i really didn't care because i needed enum for it
06:23:08 <Axman6> they can be derived automatically for you for each constructor
06:23:26 <maerwald> it's sad that GHC can't just magically understand: someValue == MyConstructor{}
06:26:23 <Axman6> :t matching _Left
06:26:25 <lambdabot> Either a c -> Either (Either b c) a
06:26:28 <cheater> you don't need Ord for that you just need Eq
06:26:30 <cheater> you can derive Eq
06:26:31 <Axman6> :t matching _Just
06:26:32 <lambdabot> Maybe a -> Either (Maybe b) a
06:26:45 <maerwald> cheater: ?
06:27:21 <cheater> > data Two = A | B deriving Eq; let x = A; if (x == A) then putStrLn "a" else putStrLn "b"
06:27:22 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
06:27:35 <cheater> (you have to break this up into lines)
06:28:10 <maerwald> cheater: you are assuming a nullary data constructor here
06:28:18 <maerwald> which is not the case
06:28:27 <cheater> yes, ok
06:29:47 <maerwald> there should be a smaller version of Data.Data that doesn't need that many constraints
06:30:04 <maerwald> writing your own instance of that is just too tedious
06:30:25 <cheater> still works if the constructors have parameters
06:30:33 <maerwald> what works?
06:30:36 <cheater> deriving Eq
06:30:51 <maerwald> yes, but then you don't _just_ compare the constructors
06:31:17 <cheater> ok, so you want to know if a value was created with a specific constructor, ignoring the parameters
06:31:17 <maerwald> toConstr $ Maybe "blah" == toConstr $ Maybe "foo" -- should be True
06:31:26 <cheater> can't you do this with Generic?
06:34:35 <maerwald> typeÂ Rep1ConProductÂ f g =Â D1Â D1ConProduct (C1Â C1_ConProduct (S1Â NoSelectorÂ (Rec1Â f)Â :*:Â S1Â NoSelectorÂ (Rec1Â g)))
06:34:43 <maerwald> ok, stopped looking at that package :o
06:37:07 <maerwald> another possibility would be to have a version of 'any' that doesn't choke on non-exhaustive pattern match in the comparison function
06:37:33 <maerwald> > any (\(Just _) -> True) [Nothing]
06:37:35 <lambdabot>  *Exception: <interactive>:3:6-22: Non-exhaustive patterns in lambda
06:38:42 * hackagebot BlogLiterately 0.8.3.1 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.3.1 (BrentYorgey)
06:40:26 <gurra> Merely an implementation of join is not enough for a Monad instance, right? return is also needed if I understood it correctly
06:40:51 <gurra> "Philosophically" speaking, that is
06:42:21 <geekosaur> mathematically, you need what Haskell calls return, join, and fmap
06:42:31 <cheater> maerwald: this is just as ugly as !! and fromJust.
06:42:42 <maerwald> cheater: what do you mean?
06:43:25 <cheater> you've got a partial function again
06:43:34 <maerwald> how is that function partial?
06:43:50 <geekosaur> but generally you are given map (i.e. fmap) in a mathematical context (since it must by definition be a(n endo)functor), so return and join are the new things you need
06:44:29 <gurra> geekosaur: Could one implement join and fmap in terms of return and (>>=)? I know how to implement (>>=) in terms of join and fmap.
06:44:56 <geekosaur> yes, and for historical reasons Haskell does so
06:45:09 <geekosaur> (but it calls the derived fmap "liftM")
06:45:25 <gurra> Thanks!
06:45:43 <gurra> Is there any good intuition as to why return is needed for a monad?
06:46:02 <cheater> you could derive fmap and >>= in terms of join and return too.
06:46:09 <cheater> and any other combination.
06:46:16 <cheater> iirc
06:46:23 <osager> gurra, if you change the name to wrap, it would be more intuitive and necessary
06:46:33 <martingale> Is there a way to write this rank2type with (=>) `test :: Ord b => (forall v s a. (Ord a, MVector v a)
06:46:33 <martingale>               => v s a -> ST s ()) -> [b] -> [b]1
06:46:47 <gurra> cheater: Yeah, but I can't derive return from fmap and join though
06:47:51 <gurra> osager: I know that for most instances of Monad, return does something like "wrapping" things. But what would we get if we didn't require return for monads? Would there be some fundamental difficulty or flaw when reasoning about moands in haskell, then?
06:47:53 <maerwald> is there a way to catch non-exhaustive pattern match exception in pure code and return a specified value?
06:48:33 <osager> gurra, you mean automatically return ?
06:49:02 <cheater> try \x -> fmap (\() -> x)
06:49:18 <martingale> test :: Ord b => (forall v s a. (Ord a, MVector v a) => v s a -> ST s ()) -> [b] -> [b]
06:49:28 <gurra> :t \x -> fmap (\() -> x)
06:49:29 <osager> gurra, i guess the function wont know what to return or wrap
06:49:29 <lambdabot> Functor f => b -> f () -> f b
06:49:46 <martingale> :t test :: Ord b => (forall v s a. (Ord a, MVector v a) => v s a -> ST s ()) -> [b] -> [b]
06:49:47 <lambdabot>     Not in scope: â€˜testâ€™
06:49:47 <lambdabot>     Perhaps you meant one of these:
06:49:47 <lambdabot>       â€˜textâ€™ (imported from Text.PrettyPrint.HughesPJ),
06:49:58 <cheater> yeah i don't know how to make an f ().
06:50:15 <gurra> cheater: Exactly, so I guess return can't be implemented in terms of join and fmap.
06:50:41 <c_wraith> :t fmap (const ())
06:50:43 <lambdabot> Functor f => f b -> f ()
06:51:03 <gurra> osager: I'm talking about just not being able to return. Would there be any problems with everyday types like Maybe, [] and IO if one didn't have access to return and pure?
06:51:29 <c_wraith> gurra: you can't do that without hiding constructors.
06:51:35 <c_wraith> gurra: and that would definitely create problems.
06:51:43 <c_wraith> gurra: namely, it would make the types useless.
06:51:59 <gurra> c_wraith: For IO, too?
06:52:07 <c_wraith> Nah, IO is different.
06:52:08 <cheater> gurra: i'm not sure how to prove that.
06:52:20 <cheater> gurra: it's an interesting question.
06:52:41 <c_wraith> IO does hide its constructor.  But without return, you wouldn't be able to inject values into it.
06:53:04 <c_wraith> At least, not without some inert element you could fmap over
06:53:18 <c_wraith> Which turns out to be isomorphic to return
06:55:02 <c_wraith> because the only way you can describe what "inert" means is by appealing to the same laws return must satisfy
06:57:41 <maerwald> hmm, I can't seem to catch PatternMatchFail or is it just ghci not letting me
07:08:26 <maerwald> :t either (\(_ :: PatternMatchFail) -> return False) return =<< try (return $ any f xs)
07:08:27 <lambdabot>     Ambiguous occurrence â€˜fâ€™
07:08:27 <lambdabot>     It could refer to either â€˜L.fâ€™,
07:08:27 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:163:1
07:08:41 <maerwald> shouldn't this work?
07:09:55 <Eduard_Munteanu> maerwald, did you define 'f' earlier with @let?
07:10:02 <maerwald> I don't mean the error, but the function
07:10:11 <maerwald> :t \f xs -> either (\(_ :: PatternMatchFail) -> return False) return =<< try (return $ any f xs)
07:10:12 <lambdabot> Foldable t => (a -> Bool) -> t a -> IO Bool
07:10:23 <maerwald> the pattern match fail is never catched
07:11:12 <binx> I here you are nice over here
07:11:25 <binx> can I please get some help
07:11:43 <Eduard_Munteanu> binx, yes, just ask a question directly
07:12:19 <binx> I use emacs (not a hipster) just disciple of stallman
07:12:37 <binx> do you have any guides to setting up haskel in emacs
07:12:59 <bergmark> binx: try https://commercialhaskell.github.io/intero/
07:14:28 <binx> do I need to install haskell ghc
07:14:34 <binx> or something else
07:14:42 <dutchie> You will need to install stack
07:15:00 <Eduard_Munteanu> maerwald, try   return $! any f xs
07:15:06 <binx> also once I have done that how do I proceed to compile and run my code
07:15:09 <dutchie> http://docs.haskellstack.org/en/stable/README/
07:15:18 <dutchie> that has lots of instructions
07:15:52 <maerwald> Eduard_Munteanu: doesn't work
07:16:13 <Eduard_Munteanu> maerwald, same thing, right?
07:16:42 <maerwald> yes
07:16:51 <maerwald> I start to wonder whether this is a GHC bug
07:17:40 <Eduard_Munteanu> maerwald, what happens if you try to catch any exception?
07:17:46 <ARM9> speaking of intero, is code completion supposed to work on qualified imports? for example `import qualified Data.ByteString as B` and then type B.unpa and no suggestions, typing just unpa and it completes it (but only B.unpack is available which it makes sure to point out)
07:17:58 <Jinxit> is there anything in ghc 8 (or on the horizon) regarding circular includes? eliminating the need for a single file with all the types
07:18:22 <maerwald> Eduard_Munteanu: the same
07:18:56 <maerwald> Jinxit: you know about boot files?
07:20:11 <maerwald> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules
07:23:17 <Jinxit> yes, and last time I checked (7.10) my case required both a boot file and a single file with all the types
07:23:41 <Jinxit> something about the way the dependency worked
07:24:31 <binx> have setup haskel-mode then what
07:30:08 <binx> what is involved with the haskel stack
07:30:37 <binx> like I have copied the above setup is that all there is too it??
07:32:19 <binx> ghc do I need that
07:39:44 <roconnor> What is the recommended practice for eliminating empty data declarations?  Enable EmptyCase ?
07:43:59 <byorgey> roconnor: I'd say so.  Though I don't recall off the top of my head which was the first GHC version to support it.
07:45:40 <edd_> Hello! Noob question - what type of programs is Haskell used/good for?
07:46:03 <simpson> edd_: Haskell's a general-purpose programming language; it can be used for many things. What were you thinking of building?
07:46:17 <bjs> edd_: the same thing you use other high-level programming languages for, a lot of things!
07:52:59 <EvanR> edd_: video games!
07:53:17 <EvanR> ... compilers ...
07:55:56 <edd_> Haha! What are it's advantages comapred to Python?
07:56:34 <edd_> And would you recommend it as a primary language for a beginner? I've learn a bit of Python (enough to be dangerous) and some C++
07:57:03 <hpc> the biggest advantage is having a type system whatsoever
07:57:25 <hpc> if you write a function that does 8 + "eight", you don't have to run that function to discover that it won't work
07:57:38 <bwe> length [2,1] / 5 # why does this fail whereas 2 / 5 doesn't?
07:57:46 <hpc> :t 2
07:57:47 <lambdabot> Num a => a
07:57:50 <hpc> :t length [2, 1]
07:57:51 <lambdabot> Int
07:57:55 <hpc> :t (/)
07:57:56 <bjs> edd_: probably Haskell's type system, especially the static type checking and inference if you're coming from python
07:57:57 <lambdabot> Fractional a => a -> a -> a
07:58:17 <hpc> bwe: when you use the literal 2 there, it's got the type (Num a, Fractional a) => a
07:58:31 <hpc> bwe: which probably gets monomorphized to Double
07:58:51 <hpc> bwe: Int doesn't have a Fractional instance, because there's no unambiguous way to define what (1 / 2) :: Int should be
07:58:55 <hpc> :t div
07:58:57 <lambdabot> Integral a => a -> a -> a
07:59:06 <minib00m> edd_: it's really fun and worth diving, just don't be afraid of math, it's extremly cool and useful
07:59:14 <hpc> div is the integral division operator (or quot which is slightly different)
07:59:22 <hpc> > length [1, 2] `div` 2
07:59:23 <lambdabot>  1
07:59:45 <edd_> Ok - I will give it a go, downloading the platform now :) 
07:59:55 <minib00m> edd_: of course you don't need to study math to write haskell, but i find it really useful (although i never liked math, but programmed in c++ for 3 years)
08:00:06 <edd_> You guys are like the opposite to the community on other ircs/stackoverflow to nooby general questions :P
08:00:08 <bwe> hpc: Well, how then do I get the decimals 
08:00:16 <bwe> > length [1,2,3] `div` 2
08:00:18 <hpc> :t fromIntegral
08:00:18 <lambdabot>  1
08:00:19 <lambdabot> (Integral a, Num b) => a -> b
08:00:29 <hpc> > fromIntegral (length [1..5]) / 400
08:00:32 <lambdabot>  1.25e-2
08:00:38 <bjs> edd_: i'm sure the c++ and python irc's are just as nice(?)
08:01:08 <Myrl-saki> " it
08:01:36 <trilog> minib00m: for me, haskell is actually driving me thinking more mathematically inclided.. and that makes programming so much more fun because it doesn't feel like programming in most languages (error and try etc)
08:01:37 <hpc> bwe: or if you want to just get the remainder, there's also
08:01:54 <hpc> > length [1..54321] `quotRem` 77
08:01:56 <lambdabot>  (705,36)
08:02:05 <minib00m> trilog: exactly this!
08:02:11 <hpc> > 77 * 705 + 36
08:02:12 <lambdabot>  54321
08:02:55 <hpc> bjs: the python community as a whole (not sure about specifically #python) have an attitude of there being only one way to do it
08:03:06 <hpc> bjs: so if you write code that works but isn't "pythonic", it's actually wrong
08:03:40 <edd_> bjs: I have seen people get very quickly shot down for asking a question which was considered "dumb", such as for loops with a 'return' statement not working
08:03:48 <bjs> hpc: they have good reasons for that, mainly because python is weird and "pythonic" generally translates to "doesn't break as often"
08:04:02 <hpc> some people take that seriously to the point of being rude to beginners who haven't internalized the zillions of idioms
08:04:23 <hpc> there's often more than one way to do it, and which way is valid depends on which way you care about things breaking when that code has to be edited
08:04:46 <bwe> hpc: thanks ;)
08:04:53 <hpc> a python programmer would never write carmack's inverse square root, for instance
08:05:08 <hpc> so they would be years late to writing 3d rendering code
08:05:27 <minib00m> hpc: there's good reason they wouldn't, python doesn't even try to be fast :P 
08:05:46 <hpc> i mean if they were both writing in C, with different philosophies :P
08:05:55 <hpc> but yeah, that too
08:09:05 <baordog> Sup
08:09:09 * hpc wouldn't consider carmack's inverse sqrt to be necessarily a good piece of code, but that mostly comes down to documentation
08:09:32 <hpc> a comment saying it's doing one step of newton's method and where the magic constant came from would be enough
08:09:46 <hpc> which maybe it has, and people erase it to be clever in their explanation of it
08:10:53 <hpc> as far as what it does when executed, it's a totally perfect piece of code for the time it was written
08:11:24 <hpc> mathematicians have studied it and found no better magic constant, and the instructions used to do the mathematical operations are very fast
08:12:02 <dolio> inversesqrt x = x * x -- dolio's fast inverse sqrt
08:12:41 <EvanR> inversesqrt (x * x) = x
08:12:49 <tobiasBora> Hello,
08:13:00 <bjs> dolio: haha yeah, hpc did mention good documentation, maybe "inverse" isn't the right word
08:13:00 <EvanR> oh i have it backwards, thats sqrt
08:13:17 <bjs> i believe it was more "reciprocol sqrt"
08:13:18 <baordog> lol
08:13:27 <dolio> bjs: Yeah, it is. :)
08:13:31 <EvanR> sqrt (x * x) = x -- fast sqrt algorithm
08:14:08 <Velizar> I'm trying to understand the functions defined for Traversable. It's clearly useful with IO, but plugging in any other Applicative didn't seem useful. Is there some deeper meaning, or is it just made for IO and in case some other Applicative or Monad happens to need it? (I get the part where the collection being traversed can be list, tree or anything)
08:14:10 <tobiasBora> Does anyone here can explain me this strange but ? I recently upploaded the gnuplot package, and now I can plot multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:14:19 <tobiasBora> Here is a minimal code that fails : http://paste.debian.net/739158
08:15:09 <tobiasBora> As you can see, when you run it it works, but when you replace [(2,1),(1,2)] by l2, nothing happens ! 
08:15:16 <dolio> Velizar: Do you think Foldable is useful?
08:15:21 <dolio> Like, foldMap?
08:16:20 <Velizar> dolio: Yes, I can clearly understand Foldable
08:16:41 <Velizar> at least foldr and foldl, haven't thought much about foldMap
08:16:44 <dolio> Okay. Well, foldMap is traversing with the Const m Applicative, where m is a monoid.
08:16:46 <Velizar> 's uses
08:17:53 <nitrix> dolio: Might have been better to write `Const m` applicative.
08:18:05 <dolio> (a -> m) -> t a -> m  --> (a -> Const m b) -> t a -> Const m (t b)
08:18:16 <dolio> I guess.
08:21:08 <mizu_no_oto_work> Velizar: sequence is often useful.
08:21:21 <dolio> Anyhow, it's useful for just about every Applicative, really. It's pretty common to have some kind of `a -> f b` and to want to 'do stuff' at every point in a big structure `t a` to get back an `f (t b)`.
08:23:56 <roconnor> @unmtl StateT s (Either e a)
08:23:56 <lambdabot> Plugin `unmtl' failed with: `StateT s (Either e a)' is not applied to enough arguments, giving `/\A. s -> Either e a (A, s)'
08:23:59 <Velizar> so it's a generalization.... I need to understand Applicative better, though
08:24:04 <roconnor> @unmtl StateT s (Either e) a
08:24:04 <lambdabot> s -> Either e (a, s)
08:26:17 <mizu_no_oto_work> For example, you might want to turn a [r -> a] into a `r -> [a]`.  Or a [(w,a)] into a (w,[a]).  Or a [STM a] into a STM [a].  etc, etc. etc.
08:27:38 <mizu_no_oto_work> > sequenceA [("foo",1), ("bar", 2), ("quux", 3)]
08:27:39 <lambdabot>  ("foobarquux",[1,2,3])
08:28:45 <Velizar> it's starting to make sense, guess I need more practice
08:30:25 <dolio> unmtl failed with: here's the answer
08:30:44 <mizu_no_oto_work> > sequence [Left 42, Left 23, Right "Generic Error message"]
08:30:46 <lambdabot>  Left 42
08:30:53 <mizu_no_oto_work> ><
08:31:09 <dolio> Right is the right answer.
08:31:13 <mizu_no_oto_work> > sequence [Right 42, Right 23, Left "Generic Error message"]
08:31:14 <lambdabot>  Left "Generic Error message"
08:31:23 <mizu_no_oto_work> > sequence [Right 42, Right 23]
08:31:25 <lambdabot>  Right [42,23]
08:32:22 <Velizar> I knew about that use case, although I didn't think of `[r -> a]` into `r -> [a]`
08:33:25 <Velizar> what I'm trying to do is to get an intuition about the underlying pattern
08:34:06 <Velizar> Applicative feels a bit vague 
08:34:14 <tobiasBora> So nobody can explains this strange bug : http://paste.debian.net/739158
08:36:08 <ClaudiusMaximus> tobiasBora: "it doesn't work" is not enough information for a meaningful reply
08:40:32 <tobiasBora> ClaudiusMaximus: I wrote several lines about this above but I can put them again here :
08:40:51 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot
08:40:53 <tobiasBora> multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:40:57 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot
08:40:59 <tobiasBora> multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:41:01 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot
08:41:03 <tobiasBora> multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:41:07 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot
08:41:09 <tobiasBora> multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:41:11 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot
08:41:13 <tobiasBora> multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:41:26 <tobiasBora> I recently upploaded the gnuplot package, and now I can plot multiple path *when one of the argument is a variable* (is I hard write everything there isn't any problem)
08:41:32 <tobiasBora> Here is a minimal code that fails : http://paste.debian.net/739158
08:41:37 <tobiasBora> As you can see, when you run it it works, but when you replace [(2,1),(1,2)] by l2, nothing happens !
08:41:47 <tobiasBora> Hum sorry for the duplicates
08:47:54 <Velizar> Another question: implementing foldMap automatically provides you with both foldl and foldr, but does that actually perform well? Or do you usually need to provide your own implementations of foldr and foldl. I know that it won't perform well without compiler optimizations, since you're turning n things into a function and then composing them, so does the compiler optimize that well?
08:48:50 <Velizar> In general, if I do something complicated like that with a high number of higher order function applications and wrappings, can I expect it to be optimized?
08:50:56 <Jinxit> Velizar: a keyword here is fusion
08:51:09 <EvanR> Velizar: before second guessing ghc's optimizations its pays to review how the unoptimized stuff works, since its very different from say the implementation of clojure on the JVM
08:52:05 <EvanR> then the optimizations start
08:54:25 <Velizar> ah, I was drawing guesses from my compilers course and also from how Scala works
08:55:46 <Squarism> what is required to invoke makeLensens ''<insert-my-data-type>. Right now ive imported Control.Lens .. but i get " Syntax error on ''Foo \n perhaps you intended to use TemplateHaskell \n In the Template Haskell quotation ''Foo"
08:56:09 <Squarism> googled but couldnt find anything related
08:56:30 <adamCS> Squarism: Do you have {-# LANGUAGE TemplateHaskell #-} at the top?
08:56:41 <Squarism> sure dont
08:56:44 <Squarism> ill try that
09:22:34 <shirt> Is there a guide for choosing module names when authoring a library?
09:23:11 <coppro> not really
09:23:40 <coppro> just look at other examples and do your best
09:26:43 <oisdk_> Having trouble with the types of patterns synonyms. Does anyone have any idea how to get something like this to work: https://gist.github.com/oisdk/76484963ee8f897393431b185523c42a
09:28:04 <mpickering> oisdk_: 
09:28:15 <mpickering> The important question is which version of GHC are you usuing
09:28:23 <Gurkenglas> Is EvanR saying that he shouldn't worry about that because it's constant factors?
09:28:48 * hackagebot config-value 0.4.0.2 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.4.0.2 (EricMertens)
09:29:00 <mpickering> Seems to me that you using GHC 7.10.3 so you would need to unfortunately write "() => Show a => a -> a -> (a, a)"
09:29:00 <oisdk_> mpickering 7.10.3
09:29:49 <oisdk_> mpickering That works!
09:30:09 <mpickering> In GHC 8, you would write what you did. Which would be equivalent to Show a => () => a -> a -> (a, a)
09:32:52 <mpickering> also that terrible error message is fixed in ghc 8, there have been lots of improvements to pattern synonyms 
09:33:48 * hackagebot hoauth2 0.5.4.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.4.0 (HaishengWu)
09:38:49 * hackagebot lua-bc 0.1.0.1 - Lua bytecode parser  https://hackage.haskell.org/package/lua-bc-0.1.0.1 (EricMertens)
09:38:51 * hackagebot type-combinators 0.2.4.0 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.4.0 (KyleCarter)
09:39:29 <Squarism> if i have a datatypes :  Foo { _bar :: Int, _baz :: [Moo], _quux :: a } and  data Moo = Moo { _a::Int} deriving (Show). How would i update some element in "baz" list matching some criteria?
09:39:35 <Squarism> using lenses
09:40:30 <Squarism> in a Foo value
09:41:20 <oisdk_> mpickering Thanks!
09:41:20 <glguy> over (baz . mapped) :: (Moo -> Moo) -> Foo -> Foo
09:41:52 <Zemyla> @src absurd
09:41:53 <lambdabot> Source not found. Where did you learn to type?
09:42:48 <Squarism> glguy, not sure i follow you there? Im very new to lenses
09:42:50 <johnw> he might need filtered too
09:43:19 <Squarism> glguy, oh.. i might get it
09:43:20 <glguy> johnw: it's usually better to put value selection logic in the update function than to potentially abuse filtered
09:43:25 <johnw> true
09:43:34 <johnw> > [1,3,4,5] & mapped.filtered (==4) .~ 7
09:43:36 <lambdabot>  [1,3,7,5]
09:43:41 <johnw> but you can just add it too
09:43:49 <glguy> Yeah, that'd be an abuse of filtered
09:44:07 <johnw> why an abuse?
09:44:26 <glguy> you changed the value such that it no longer matched the predicate
09:44:53 <johnw> I vewied it more as "describing an element", I didn't think about the description needing to endure an update
09:45:06 <glguy> You can read more here http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Fold.html#v:filtered
09:45:07 <johnw> what would that be... a transient lens?
09:45:49 <johnw> cool, thanks for that pointer glguy 
09:47:51 <puregreen> okay, I'll bite the bullet and ask: can someone please clearly explain to me why filtered is being constantly bashed and discouraged and so on while nobody screams in horror when, I don't know, people keep using names like â€œsâ€ and â€œs'â€ (where a typo would easily and silently lead to a logic error)?
09:48:09 <mizu_no_oto_work> tobiasBora: What happens if you replace ",[(2,1),(1,2)]]" with something like "[(2,1),(4,2),(6,3)], [(1,2), (2,4), (3,6)], [(23,42), (42, 67), (56,89)]]"?
09:48:55 <Squarism> glguy, thanks.. got it to work
09:49:20 <johnw> puregreen: are you asking about the name "filtered", or its use?
09:49:28 <puregreen> its use
09:49:37 <johnw> so, it can lead to a violation of the lens laws
09:49:47 <GLM> .list
09:50:18 <johnw> which the link glguy referenced talks about
09:50:32 <c_wraith> filtered is potentially dangerous. if you treat it like a normal traversal, you will end up in a situation where refactoring that should be correct isn't. 
09:50:59 <puregreen> okay, so basically the only situation in which it can happen is when someone blindly fuses something like â€œover evens f . over evens gâ€?
09:51:14 <c_wraith> yep 
09:51:34 <puregreen> can this at least happen automatically? (e.g. when using â€˜fusingâ€™ or due to some rewrite rule or something)?
09:51:48 <c_wraith> not that I know of. 
09:52:02 <puregreen> because otherwise the amount of discouragement that â€˜filteredâ€™ gets seems *completely* unjustified to me
09:52:16 <puregreen> especially given how useful filtered is
09:52:48 <c_wraith> it's useful, but it breaks expectations that the lawful lenses don't. 
09:52:59 <c_wraith> it's worth mentioning that. frequently. 
09:54:36 <c_wraith> I mean, there's a reason why it's in the Fold module. There's also a reason why the type doesn't restrict it to being a Fold. 
09:55:03 <c_wraith> it's only lawful as a Fold. but it's too useful to reject using it as a Traversal
09:55:04 <johnw> it's also not the first time that useful, potentially lawless lenses have been provided
10:03:49 * hackagebot hspec-setup 0.1.1.1 - Add an hspec test-suite in one command  https://hackage.haskell.org/package/hspec-setup-0.1.1.1 (yamadapc)
10:13:50 * hackagebot persistable-record 0.4.0.1 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.0.1 (KeiHibino)
10:17:07 <gio> can one point me good survey paper to learn basics of polymorphism ?
10:17:22 <johnw> there are a few different "kinds" of polymorphism
10:17:31 <johnw> which are you looking to understand in particular?
10:18:23 <EvanR> to foo polymorphism you must first foo substitution
10:19:15 <gio> i want to learn theory 
10:19:25 <gio> and main concepts of it
10:21:19 <adelbertc> gio: this paper comes to mind http://lucacardelli.name/papers/onunderstanding.a4.pdf
10:21:42 <Squarism> in ghci, how can see in what module a definition comes from? 
10:21:44 <adelbertc> and a spiritual follow-up http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
10:22:03 <EvanR> try :i <thedef>
10:22:04 <dmj`> Squarism: :i 
10:22:10 <Squarism> thanks
10:22:12 <dmj`> @info div
10:22:12 <lambdabot> div
10:23:31 <gio> thx
10:25:49 <johnw> gio: btw, if you don't know already, "polymorphism" is Greek for "many shapes".  It is used when a single "type" can have multiple definitions.
10:26:29 <johnw> how this is achieved may vary
10:26:52 <gio> i need to have an kind of most general type
10:27:05 <gio> that is why I want to read about it
10:27:15 <gio> maybe it is offtopic to chat here...
10:27:21 <gio> no?
10:27:27 <johnw> with ad hoc polymorphism, you provide multiple definitions for a common type; with parametric polymorphism, the choice of arguments results in a definition in terms of that type
10:28:33 <johnw> this subject is not off topic, I'm just not aware of papers that talk just about "polymorphism"
10:28:58 <gio> assume types are defined following way: R= 1 | B | R+R | R.R | R*  and tau= B | R-->tau
10:29:32 <Squarism> glguy, interpolating from your example.. is this the right way to do it when adding another "level" : http://lpaste.net/166059
10:29:45 <gio> assume X : R*->B  and x : R*  4
10:29:47 <gio> assume X : R*->B  and x : R*  
10:30:07 <Squarism> glguy, ...just illustrating some random update
10:30:35 <gio> I want X(x) to be matched with any term in the form f(a)  where f : R->B and a:R
10:30:52 <gio> to be matched contravariance has to be hold
10:30:53 <gio> but
10:31:27 <gio> R-> B < R* ->B does not hold
10:31:43 <gio> and I am thinking maybe poly can help me with this matter
10:32:19 <gio> johnw: did u get the point?
10:32:44 <johnw> no, I didn't follow at all
10:32:53 <Squarism> anyone.. is this the way to do updates of a value nested in 2 other values : http://lpaste.net/166059 ?
10:34:36 <gio> johnw: I want X(x) to match with any term....
10:34:40 <Squarism> ie upate a value nested in a value containing a list of values containing a list of the type of value i want to update 
10:34:44 <Squarism> update
10:34:48 <gio> with the type system I am using, it is impossible
10:34:59 <gio> because contravariance is not kept...
10:34:59 <lpaste> glguy annotated â€œProper way of updating 3 level data?â€ with â€œProper way of updating 3 level data? (annotation)â€ at http://lpaste.net/166059#a166063
10:35:12 <johnw> gio: I see what you're asking now
10:35:24 <glguy> Squarism: what you had is fine, this is just a cleaned up version
10:35:28 <johnw> gio: but maybe someone else has a resource for you
10:35:47 <gio> what do u think, poly can help with this matter?
10:36:00 <Squarism> glguy, ok.. good to know! Thanks alot man. Feels im ready for lenses! =D
10:36:12 <johnw> I don't feel confident giving you an answer, but maybe someone else can
10:36:29 <lpaste> glguy annotated â€œProper way of updating 3 level data?â€ with â€œProper way of updating 3 level data? (annotation) (annotation)â€ at http://lpaste.net/166059#a166064
10:36:30 <gio> ok
10:36:33 <glguy> Squarism: or even that
10:36:40 <gio> thx
10:39:50 <Squarism> glguy, thats even nicer
10:40:01 <`Guest00000> if i uninstall Haskell Platform, will i lose all installed libraries?
10:42:34 <roconnor> @hoogle Either a a -> a
10:42:37 <lambdabot> Data.Either rights :: [Either a b] -> [b]
10:42:37 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
10:42:37 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
10:44:48 <roconnor> (^.chosen) seems to work.
10:46:51 <Xandaros> Is there a â€œcabal cleanâ€ equivalent for projects using â€œnew-buildâ€? â€œnew-cleanâ€ does not exist, unfortunately. Do I simply delete â€œdist-newstyleâ€?
10:49:21 <Xandaros> I just had the brilliant idea of renaming the folder instead of deleting it. (novel concept, I know) - Yep, you can simply delete it
10:52:43 <Squarism> if i want to refactor a record field name - what editor/IDE/tool do you recommend?
10:53:08 <Squarism> as in "rename"
10:53:13 <glguy> The same editor you're already using
10:53:25 <hexagoxel> Xandaros: completely unofficial: https://gist.github.com/lspitzner/fcd41eb5c3111a2bbd192a77b7697663
10:54:35 <Xandaros> hexagoxel: Ah, good to know. I'll keep it as reference
10:54:44 <hpc> @pl \x -> case x of y -> z
10:54:45 <lambdabot> (line 1, column 21):
10:54:45 <lambdabot> unexpected '>'
10:54:45 <lambdabot> expecting operator
10:54:49 <hpc> :(
10:55:05 <Squarism> id hoped there were something that could do it utilizing compiler info
10:55:10 <Xandaros> @pl \x -> case x of {y -> z}
10:55:10 <lambdabot> (line 1, column 17):
10:55:10 <lambdabot> unexpected '{'
10:55:10 <lambdabot> expecting variable, "(", operator or end of input
10:55:14 <Xandaros> :(
11:32:15 <Alxandr> Hi. How do I add a hackage package as a dependency in my cabal file?
11:32:20 <Alxandr> (first time doing haskell)
11:32:45 <Alxandr> I'm trying to add this as a dependency to my project: https://hackage.haskell.org/package/megaparsec
11:33:12 <Alxandr> And I have build-depends: megaparsec
11:33:35 <glguy> Alxandr: What's the problem?
11:34:19 <glguy> If it's struggling with the syntax you might use this as an example https://github.com/glguy/config-value/blob/master/config-value.cabal
11:35:05 <Alxandr> Oh. Wait. I just had to do `cabal install`
11:35:17 <Alxandr> I see, so all my other deps have been on my system already then?
11:35:28 <Alxandr> `cabal build` doesn't go look at the internet?
11:35:39 <glguy> Right, cabal build just builds
11:36:06 <glguy> "cabal install" is a mega command that installs dependencies, configures, builds, makes documentation, copies, registers
11:36:22 <Alxandr> How do I only install deps?
11:36:27 <glguy> cabal install --dep 
11:36:32 <mjrosenb> what is the difference between a TVar and a TMVar?
11:36:53 <Alxandr> cabal is fairly confusing O_o
11:37:05 <glguy> TVars can't be empty, TMVars can be. YOu can block waiting for a TMVar to not be empty
11:37:11 <Alxandr> I've used node and nuget and gradle and others
11:37:15 <glguy> or block waiting to put into a full TMVar
11:37:18 <dcoutts> Alxandr: in future versions it'll work how you expected, ie build will just do the right thing.
11:37:34 <Alxandr> And cabal takes the cake of I have no idea what I'm doing :P
11:37:59 <dcoutts> Alxandr: there's an experimental new ui available in 1.24 that works like this, but it's only for beta-testing atm really
11:38:06 <Alxandr> Yeah, build did dep resolution (locally), so I just interpreted it as it downloading stuff too
11:38:20 <mjrosenb> glguy: ahh, awesome.  I wish the docs said that on the first line :-(
11:39:00 <Alxandr> Also, vs code support is pretty cool and well working :)
11:39:16 <Alxandr> Syntax highlighting could be better, but still, color me impressed :)
11:39:24 <mizu_no_oto_work> Alxandr: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
11:39:48 <Alxandr> Yeah, I read that.
11:39:52 <mjrosenb> next question: ar cloned TChans garbage collected?
11:40:23 <mjrosenb> e.g. if I clone a TChan to inspect the original's contents, will I be paying the cost of that clone indefinitely?
11:41:03 <EvanR> not if you drop the clone
11:41:36 <EvanR> mjrosenb: the TMVar may not be explained since its supposed to be a direct analog to MVar which is explained in Control.Concurrent.MVar
11:42:29 <Alxandr> Haskell is really cool. But it also makes my head spin around a few more times than what's healthy :P
11:42:42 <EvanR> youll get used to it
11:42:58 <Alxandr> Does it compile down to code that C code can link against?
11:43:09 <mjrosenb> Alxandr: yup.
11:43:11 <Walther> and taking your head for a spin is good for you :)
11:43:17 <Alxandr> Yeah
11:43:19 <Alxandr> I agree
11:43:36 <EvanR> thats just the world, which is normally spinning around you, slowing down to the same speed so you can actually see whats going on
11:44:15 <Alxandr> I'm generally comfortable with functional programming (been using it for a few years). But when you start making your types into functions (`* -> *`) in some rather elaborate ways my brain just hates me :P
11:45:06 <EvanR> yeah if types were first class that would be easier to explain ;)
11:45:11 <EvanR> Type -> Type
11:45:28 <EvanR> then its not very elaborate
11:45:42 <Alxandr> Also, I just used a week to figure out Haskell to find that the original code I was translating from was bugged in the first place :-/
11:46:55 <platz> Say I want to put Day from time package in a HashMap in my lib.  Day is a newtype over Integer, but Day is not Hashable.  Do I define an orphan instance for Day in my lib to make it Hashable?  seems like an instance likely to conflict when used by consumers
11:48:45 <puregreen> platz: there's usually a library with orphan instances on Hackage
11:48:51 <puregreen> e.g. http://hackage.haskell.org/package/hashable-time
11:49:28 <puregreen> if you use one of those and it's widely used, your consumers likely won't have any conflicts
11:49:52 <platz> sure, i can use that.  isnt it strange how few downloads it has though?  only 3 this period
11:50:27 <EvanR> you can also newtype the newtype
11:50:39 <EvanR> if the inner workings of the lib are hidden
11:51:03 <EvanR> but its sort of silly since Day should be hashable already
11:51:12 <platz> yep.. both good options.  just wonderdd what folks are actually doing assuming this omes up for them too
11:51:34 <puregreen> hashable doesn't depend on time, so no :(
11:51:58 <glguy> platz: If you want want to depend on the orphan package you can use a newtype
11:52:31 <platz> newtypes seem like the 'easy' solution here, yeah
11:52:52 <platz> thanks
11:53:27 <EvanR> .oO generic instance for Hashable anything that is a newtype over a Hashbale type
11:53:38 <EvanR> GeneralizedNewtypeDeriving?
11:53:53 * hackagebot mywatch 0.1.0 - View MySQL processes  https://hackage.haskell.org/package/mywatch-0.1.0 (ip1981)
11:53:55 * hackagebot pcg-random 0.1.3.3 - Haskell bindings to the PCG random number generator.  https://hackage.haskell.org/package/pcg-random-0.1.3.3 (cchalmers)
11:56:20 <cocreature> is there some tool to generate diagrams of module dependencies (where an import counts as a dependency)?
11:56:57 <glguy> http://hackage.haskell.org/package/graphmod
11:57:16 <cocreature> thx
12:23:54 * hackagebot shake 0.15.10 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.10 (NeilMitchell)
12:51:19 <minib00m> guys i need your advise, i want to create simple turn-based game (something like checkers or similiar :) ), what would be best graphical library to do this? there is so many to choose from on hackage...
12:55:23 <edd_> Just started learning Haskell, it's fun so far!
12:55:57 <minib00m> edd_: great to hear that! :D 
12:59:28 <suppi> minib00m, perhaps gloss?
13:01:25 <minib00m> suppi: looks cool! :) 
13:01:58 <minib00m> and it has some great amount of examples on github, that's helpful :) thanks
13:02:11 <suppi> it's pretty well known in being easy to work with, but not very full featured (like not supporting images or something)
13:02:18 <suppi> sure. good luck :)
13:02:42 <sebleblanc> Messing around with Parsec, can I avoid having to type the constraints on my ParsecT values? i.e. (Stream s m Char) => ...
13:03:00 <silverjam> Anyone know how I would simulate a regex "capture group" with Turtle.Pattern?
13:03:30 <Maxdamantus> sebleblanc: probably. You should rarely *need* to declare types in Haskell.
13:05:37 <Maxdamantus> > show undefined
13:05:40 <lambdabot>  "*Exception: Prelude.undefined
13:05:42 <sebleblanc> I know, but when I leave out the types the compiler complains about having "No instance for (Stream s0 m0 Char) arising from a use of 'someParserP' [â€¦]"
13:06:28 <osager> where is the original list definition in ghc ?
13:07:23 <cheater> try finding :
13:09:45 <puregreen> osager: https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Types.hs#L109
13:11:08 <osager> puregreen, great! how did you do that? are you just so familiar with ghc ?
13:11:32 <puregreen> if you try writing that in a file and compiling, you'll find that it actually parses, by the way (but the message will be â€œIllegal binding of built-in syntax: []â€)
13:12:44 <puregreen> I knew where to look for it because a while ago I got curious about the â€œmaximum 62 elementsâ€ limit for tuples and someone directed me to https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs#L34, which is in the same source directory
13:13:40 <puregreen> sebleblanc: maybe you could specify that you're parsing a string
13:14:05 <sebleblanc> osager, try :info (:) in ghci
13:14:21 <puregreen> sebleblanc: or you could use the Parser type from Text.Parsec.String/Text
13:14:47 <puregreen> sebleblanc: nice
13:14:59 * puregreen forgets about :i all the time
13:15:15 <osager> sebleblanc, great
13:16:01 <sebleblanc> osager, but from what I gather, Lists are somewhat magic in GHC; they are implemented at the syntax level instead of being plain old datatypes
13:16:14 <sebleblanc> puregreen, not sure how I can do thatâ€¦ let me post an excerpt
13:17:16 <eovv> If you have both GeneralizedNewtypeDeriving and DeriveAnyClass, newtype deriving takes precedence?
13:17:16 <osager> sebleblanc, yea i've heard it's sort of built-in
13:18:54 <sebleblanc> puregreen, http://lpaste.net/4659208654736588800
13:19:30 <sebleblanc> puregreen, interword is Pause 3
13:21:48 <geekosaur> sebleblanc, osager, the built-in nature is mostly because of the conflict between the list sugar [a,b,c] and [] as empty list constructor (and similar type level handling of [a] vs. [] a)
13:22:14 <geekosaur> which is specifically why you get the error about rebinding [], which needs to be handled specially
13:28:56 * hackagebot parsers 0.12.4 - Parsing combinators  https://hackage.haskell.org/package/parsers-0.12.4 (EricMertens)
13:51:45 <puregreen> sebleblanc: eh, okay, well
13:52:19 <puregreen> if you want them to be monad-agnostic, then there aren't any type synonyms for that, I think
13:53:17 <puregreen> you'd have to define a type synonym by yourself
13:53:31 <puregreen> asking just in case: do you actually want them to be monad-agnostic?
13:56:01 <sebleblanc> puregreen, so that is the reason why... I am not sure what monad-agnosticism involves, though. does it have anything to do with do-syntax?
13:57:28 <edd_> what is the best resource to learn Haskell?
13:57:51 <tucuman> I found this guide really good (http://learnyouahaskell.com/)
13:57:58 <puregreen> @where learn
13:57:58 <lambdabot> http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/bitemyapp/learnhaskell | https://github.com/NICTA/course/
13:58:40 <edd_> thanks guys
13:59:02 <puregreen> a lot of popular recommendations are reviewed here: http://bitemyapp.com/posts/2014-12-31-functional-education.html
14:00:41 <suppi> www.haskellbook.com
14:01:29 <pikajude> is feeling ðŸ˜” monomorphic.
14:01:38 <puregreen> sebleblanc: if you're asking then you probably don't need it :) just import Text.Parsec.String and write â€œmorseSpaceP :: Parser MorseCodeâ€ and it should work
14:03:43 <puregreen> ParsecT is a monad transformer. In some cases you want to combine parsing with something else (e.g. Writer) and then you use ParsecT s u Writer MorseCode. In some cases you want state and then you might write ParsecT s SomeState m MorseCode
14:04:41 <puregreen> in these cases you usually want to keep smaller parsers as generic as possible and so you have to spell out â€œParsecT s u mâ€ to mean â€œit works with any monad, any state, etcâ€
14:05:09 <EvanR> or delete the signature! ;)
14:05:22 <puregreen> and then -Wall will complain :(
14:05:32 * puregreen wonders whether it's time to ditch -Wall
14:06:15 <puregreen> but in the majority of cases you don't need all those extra features and so you can just use â€œParserâ€, which is a synonym for â€œParsecT String () Identityâ€, which means â€œno state, no extra monadsâ€
14:06:40 <sebleblanc> EvanR, yes, that is my ultimate goal, but the compiler will not let me: it is complaining about no instance for (Stream s m Char)[â€¦]) 
14:06:57 <sebleblanc> puregreen, oh, great
14:07:39 <alluringme> MyWallPuregreen :P < That valid variable in Haskell? :P (Just for fun)
14:07:54 <puregreen> valid type/class name
14:08:05 <puregreen> myWallPuregreen â† valid variable
14:08:59 <puregreen> (|=|) â† valid variable too, tho it doesn't quite convey green-ness
14:09:29 <alluringme> Hehe, I thought I'd just say hello. I've never tried haskell. I hear( and I heard it right) this is a good chan to join on this article :)  https://news.ycombinator.com/item?id=5587268
14:10:31 <alluringme> Haskell is like Scala?
14:10:35 <johnw> we're an interesting channel if you find Haskell interesting
14:10:45 <johnw> otherwise, we discourage off-topic chatter, since we have other channels for that
14:10:49 <alluringme> What are it's applications when compared to PHP?
14:11:02 <alluringme> johtso, hey. How are you?
14:11:09 <johnw> it's general purpose, usable for anything, but is very different from PHP
14:11:34 <johnw> I encourage starting here: http://learnyouahaskell.com/
14:12:34 <alluringme> johtso: top 3 features that other languages don't support? I will check that thanks.
14:12:45 <alluringme> johnw**
14:12:46 <johnw> I don't like comparing Haskell to other languages
14:13:09 <johnw> it's best to just give it a try
14:13:16 <johnw> and then choose what _you_ like best
14:14:05 <alluringme> Hmm, okay. Learning something new is always an investment. haha, I will check the basics thou. Thanks for your time.
14:14:52 <johnw> once you have questions, please come back, we always welcome discussion about Haskell
14:14:54 <simpson> alluringme: You might be surprised at how few features are actually unique to any given programming language.
14:15:42 <alluringme> simpson, I agree. I was just curious. This is the fist time I ever visited this chan. :)
14:15:58 <simpson> alluringme: Haskell's just another programming language. It's nifty.
14:16:37 <alluringme> I can see that haha. 1498 in this room. It has quite a userbase.
14:16:57 <puregreen> actually it's an interesting question. What features are obscure enough to be interesting to someone who has seen Scala, yet not obscure enough to seem useless?
14:17:19 <puregreen> (I don't know Scala so it's hard for me to answer)
14:17:27 <baordog> puregreen: Does Scala have lenses?
14:17:33 <baordog> oh you don't know it.
14:17:37 <puregreen> it does
14:17:46 <baordog> I feel like you'd have better luck using Scala on a production server than haskell.
14:17:55 <baordog> But I also kind of feel the JVM is cancer :/
14:18:02 <baordog> I'm prejudiced that way.
14:18:15 <baordog> Has someone written a haskell JVM front end yet?
14:18:21 <baordog> I feel like that's inevitable.
14:18:23 <pikajude> the JVM is very decent, it's scala that's the "problem"
14:18:31 <alluringme> puregreen, I started exploring Kotlin and Scala just a few months back. :) All I know is a lil bit of PHP, html, css and js. But, I am willing to learn something new and I will.
14:18:32 <ARM9> see frege
14:18:34 <pikajude> it's the kitchen sink, kitchen counter, stove, oven, fridge, and the linoleum flooring
14:18:37 <baordog> I mean, I just hear people saying it's unlearnable in complexity.
14:18:47 <pikajude> you could say there's too much stuff in it
14:19:04 <baordog> Now, when haskell people are talking shit at you for being complex, you might have a problem.
14:19:10 <baordog> That might be a sign.
14:19:22 <pikajude> haskell is very simple both to write and to parse
14:19:26 <pikajude> scala is neither
14:19:50 <baordog> pikajude: I mean simple and complex are definable terms.
14:20:06 <baordog> Some would argue haskals type system is complex.
14:20:09 <alluringme> Thank you guys, I'll start here: http://learnyouahaskell.com/chapters
14:20:12 <alluringme> have fun!! :D
14:20:25 <puregreen> alluringme: you can also join https://github.com/haskell-learning-group/haskell-learning-group/issues
14:20:33 <puregreen> (if you learn better with a mentor)
14:20:35 <geekosaur> it only gets complex when you start playing with advanced type system features
14:20:45 <baordog> alluringme: I've heard LYAH is badly out of date.
14:20:46 <puregreen> (ouch, without â€œ/issuesâ€)
14:20:55 <geekosaur> if you stick to H-M with typeclasses (i.e. standard Haskell) then it's fairly simple, just different from what you are used to
14:21:04 <pikajude> and inference makes it much easier
14:21:15 <baordog> Then there's the complexity of the language extensions
14:21:23 <baordog> since you need those to get most things done in the real world
14:21:44 <alluringme> puregreen, I will bookmark that too. Thanks for your time. Let's see how it goes. :D
14:22:14 <EvanR> do you really need language extensions for the real world
14:22:31 <EvanR> or is that a product of one or two now-popular web frameworks
14:22:39 <simpson> OverloadedStrings is pretty useful.
14:22:48 <EvanR> which isnt that complex
14:22:55 <simpson> But it's an extension.
14:23:03 <simpson> And it does add complexity.
14:23:12 <mkloczko> Dunno, the language seems pretty powerful to me with TypeFamilies, for example. GADTs are also nice
14:23:15 <pikajude> multi param type classes?
14:23:17 <EvanR> about as much as 3 being not just an Int
14:23:33 <pikajude> you need MPTCs to use any of mtl basically
14:23:43 <EvanR> you dont need to activate MPTC to use mtl
14:23:50 <baordog> mtl?
14:23:59 <EvanR> monad transformers
14:24:00 <pikajude> oh really? whoops
14:24:07 <quchen> Haskell is simple to parse? I don't think so. There may be more complicated things to parse (C, or god forbid Perl), but e.g. resolving infix operator precedence isn't trivial, since you need to understand modules in order to do that, require two passes, and what not.
14:24:24 <johnw> funny how a discussion about Haskell not being complex quickly devolves into one that only Haskell experts can follow
14:24:34 <sebleblanc> I like PartialTypeSignatures, allowing for holes in type signatures
14:24:40 <pikajude> it's just a monoid in the category of endofunctors...
14:24:50 <EvanR> im limiting to just whether you need "complex" extensions
14:25:47 <mkloczko> need depends heavily on the use case. I had a fun time using extensions while developing a multi-agent simulation.
14:25:51 <quchen> baordog: LYAH isn't advanced enough to be "badly out of date", really.
14:25:54 <EvanR> the idea should be that you can use haskell *this much* for *these things* without understanding all or most of the extensions, and your knowledge can grow incrementally
14:26:21 <EvanR> rather than "i dont get haskell at all because <list of extensions>"
14:26:28 <baordog> johnw: Functional programmers are immune to that type of irony
14:26:30 <quchen> baordog: All LYAH gets wrong right now is that many foldable functions (e.g. length) have been generalized, and that we have Applicative => Monad now.
14:26:30 <puregreen> okay, if it's â€œyou can use Haskell without knowing what most extensions doâ€, I wholeheartedly agree
14:26:58 <baordog> quchen: I just see a lot of moaning about it on reddit these days :) I'm not an expert.
14:27:06 <kadoban> I have no godly idea what most extensions do â€¦ I get by fine.
14:27:09 <quchen> Monaers will moan.
14:27:19 <maerwald> understanding _haskell_ doesn't include GHC extensions per definition
14:27:29 <EvanR> haskell=ghc ;)
14:27:32 <maerwald> no
14:27:41 <quchen> LYAH won't teach you Haskell, but it will teach you to be interested in it. Worked for me at least.
14:27:45 <puregreen> aargh arguments about definitions again
14:27:54 <minib00m> love them
14:27:59 <maerwald> puregreen: well, the haskell report is a pretty strong argument
14:28:14 <kadoban> quchen: Seems a bit long-winded if that's the only outcome.
14:28:36 <Quintasan> Is hakyll not buidling in LTS Haskell an bug? If so there does anyone know where I can report that?
14:29:17 <puregreen> it's only a strong argument if you agree that definitions matter and want to figure out which definition has the most authority
14:29:42 <EvanR> fix discussionAbout
14:30:54 <maerwald> puregreen: nah, it'
14:31:02 <maerwald> *it's just wrong saying haskell=ghc
14:31:04 <puregreen> nah, meta never goes more than 3 levels deep
14:31:09 <puregreen> or was it 4..?
14:31:15 <maerwald> you could as well say C=gcc, which is also wrong
14:31:25 <glguy> Quintasan: You'd have to paste the error for us to guess if it's your mistake or hakylls
14:31:30 <glguy> ?lpaste
14:31:30 <lambdabot> Haskell pastebin: http://lpaste.net/
14:31:41 <hpc> yeah, C=clang
14:31:42 * hpc ducks
14:31:49 <c_wraith> quchen, parsing perl isn't just hard, it's undecidable (statically) 
14:31:55 <quchen> hpc: C is a C compiler
14:31:57 <quchen> Sounds right
14:31:58 <ARM9> except c has several mature implementations being maintained
14:32:03 <puregreen> maerwald: you can't say that something is wrong without giving context. In some contexts â€œHaskell=GHCâ€ is very right.
14:32:15 <Quintasan> glguy: http://lpaste.net/6354741093271076864 I'm pretty much sure this is a problem with Hakyll
14:32:19 <hpc> haskell = ghc
14:32:22 <hpc> haskell = hugs
14:32:28 <EvanR> maerwald: i see a planescape of inconnected wrongness linking universes 
14:32:28 <hpc> obviously this means hugs = ghc
14:32:33 <maerwald> haskell is not an implementation-defined language, haskell has a language report
14:32:57 <Quintasan> More precisely lts haskell 6.3 not knowing about newer hakyll version which have the issue fixed
14:33:02 <Athas> maerwald: does it really matter if people in practice program to the compiler, not the report?
14:33:06 <EvanR> maerwald: which would lead to haskell not existing
14:33:06 <puregreen> â€œhaskellâ€ is a word that humans use, not a Lisp symbol that is unique
14:33:18 <maerwald> Athas: it matters to distinguish compiler and language
14:33:19 <EvanR> which is fascinating but not exciting
14:33:25 <glguy> Quintasan: Have you tried building the latest version? 4.8.3.1
14:33:34 <quchen> Quintasan: Strange. When all packages involved are in a Stackage release, they should be guaranteed to build together.
14:33:40 <buttbutter> Is there any function that converts from a Floating number to a RealFrac? I'd like to use 'floor' on a Floating number, but floor mandates that its argument belong to the RealFrac typeclass.
14:33:42 <Quintasan> Hm
14:33:46 <Quintasan> This is ever more weird
14:34:20 * EvanR looks up whether Float implies RealFrac
14:34:24 <EvanR> Floating
14:34:31 <buttbutter> EvanR: Thanks C:
14:34:42 <hpc> :t floor
14:34:43 <lambdabot> (Integral b, RealFrac a) => a -> b
14:34:50 <hpc> > floor (5.5 :: Double)
14:34:51 <lambdabot>  5
14:35:16 <buttbutter> Basically I need to convert the floor of the result of LogBase to an integer. And naively trying toInteger (floor (logBase x y)) doesn't work :P
14:35:22 <puregreen> :t realFrac :: (Floating a, RealFrac b) => a -> b
14:35:24 <lambdabot>     Not in scope: â€˜realFracâ€™
14:35:24 <lambdabot>     Perhaps you meant â€˜realToFracâ€™ (imported from Prelude)
14:35:27 <puregreen> :t realToFrac :: (Floating a, RealFrac b) => a -> b
14:35:27 <Quintasan> My stack can't find the new version for some reason hakyll: needed (==4.7.*), 4.8.3.1 found (latest applicable is 4.7.5.2)
14:35:29 <lambdabot>     Could not deduce (Real a1) arising from a use of â€˜realToFracâ€™
14:35:29 <lambdabot>     from the context (Floating a, RealFrac b)
14:35:29 <lambdabot>       bound by the inferred type of
14:35:31 <Quintasan> I'll just rebuild
14:35:36 <puregreen> okay, that didn't work
14:35:43 <glguy> Quintasan: LTS-6.3 does have the latest version of hakyll, not the one you're trying
14:36:01 <EvanR> buttbutter: interesting, for has random these classes seem, Floating does not ensure you can do this
14:36:02 <Quintasan> Yeah, I have it set as resolver in my stack.yaml
14:36:06 <EvanR> pick another constraint
14:36:22 <EvanR> for example RealFrac
14:36:36 <buttbutter> What do you mean pick another constraint? 
14:36:49 <EvanR> the Floating constraint by itself doesnt imply you can do floor
14:36:56 <buttbutter> Oh.
14:37:13 <buttbutter> I'm not sure how to "add a constraint"
14:37:23 <EvanR> ... why are you dealing with Floating then
14:37:27 <glguy> > floor (logBase 2 10) :: Integer
14:37:29 <lambdabot>  3
14:37:30 <buttbutter> I needed to take a log.
14:37:31 <EvanR> do you mean Float
14:37:38 <glguy> buttbutter: You don't need to do anything to get an integer out of floor
14:37:53 <buttbutter> glguy: Oh, you can just mandate the type using ::?
14:37:59 <buttbutter> :t floor
14:38:00 <lambdabot> (Integral b, RealFrac a) => a -> b
14:38:07 <glguy> or let it infer the type from the surrounding context
14:38:07 <buttbutter> No, that doesn't make sense to me.
14:38:10 * EvanR reads, oh yeah floor already outputs Integer
14:38:14 <buttbutter> glguy: That only worked in ghci for me.
14:38:17 <buttbutter> It doesn't work in my actual code.
14:38:21 <mauke> so show your actual code
14:38:24 <glguy> Then you'll have to give us actual code
14:38:26 <buttbutter> Okay, let me paste it
14:38:35 <Quintasan> ...
14:38:35 <Quintasan> wow
14:38:59 * hackagebot irc-core 1.1.5 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.5 (EricMertens)
14:39:01 <buttbutter> http://lpaste.net/166095
14:39:10 <Quintasan> I really suck at this, my .cabal file had build-depends: hakyll == 4.7.*
14:39:27 <EvanR> remove the toInteger
14:39:30 <mauke> buttbutter: you're calling logBase on an Integer
14:39:46 <mauke> hmm, or not
14:40:05 <mauke> I'm wrong
14:40:13 <EvanR> yes you are
14:40:15 <glguy> mauke: You're right
14:40:18 <EvanR> i mean, youre right
14:40:24 <EvanR> twoPower is making x an integer
14:40:31 <mauke> accidentally then :-)
14:40:39 <mauke> because my reasoning was incorrect
14:40:44 <buttbutter> Oh, I see :D
14:40:56 <glguy> "I was wrong once; I thought I was wrong when I was actually right"
14:41:18 <EvanR> haskell the best numeric programming language
14:41:31 <buttbutter> Oh wait I don't understand.
14:41:40 <buttbutter> twoPower is making x an integer in its first or second argument?
14:41:49 <EvanR> the first arg is Integer
14:41:59 <EvanR> so your list is a list of Integers, which makes no sense because logBase
14:42:32 <EvanR> alternatively, its a list of Doubles, but twoPower expects integer
14:42:54 <mgsloan> Quintasan: Do you have any extra-deps or flags set?
14:43:00 <buttbutter> Okay, so the issue is that I'm passing 'x' to logBase, and x is an Integer.
14:43:12 <buttbutter> Not that twoPower expects Integer arguments.
14:43:14 <EvanR> whatever x is, its inconsistent 
14:43:20 <buttbutter> Okay, I see now :)
14:44:14 <EvanR> "no solution"
14:44:22 <buttbutter> I just changed logBase 2 x to logBase 2 (fromIntegral x) :)
14:44:38 <EvanR> eeeexcellent
14:44:39 <buttbutter> (I know the code is super ugly, it's just a stupid test function)
14:44:45 <buttbutter> Thanks for the help!
14:49:54 <koz_> How would I write a function to 'weave together' two lists of the same type? By this, I mean 'weaveTogether [1,2] [11,12,13,14]' should give [1,11,2,12,13,14].
14:50:35 <c_wraith> koz_, I'd go with basic pattern matching. 
14:51:08 <c_wraith> I mean, I have written code that does the same thing via hyperfunctions. but that's just silly fun. :) 
14:51:09 <koz_> c_wraith: OK, I think I have it now.
14:51:45 <puregreen> > concat (transpose [[1,2], [11,12,13,14]])
14:51:47 <lambdabot>  [1,11,2,12,13,14]
14:56:05 <EvanR> koz_: since there are times when you want to wave them together based on some more detailed strategy, than just "one from here, one from there", id just do a recursive function with pattern matching
14:57:02 <EvanR> :t interleave
14:57:03 <lambdabot> Not in scope: â€˜interleaveâ€™
14:57:17 <EvanR> unless that already existed ;)
15:03:58 <fr33domlover> :t concat . transpose
15:03:59 <lambdabot> [[a]] -> [a]
15:04:19 <fr33domlover> koz_, ^
15:04:40 <fr33domlover> concat $ transpose [[1..5], [11..15]]
15:04:45 <fr33domlover> > concat $ transpose [[1..5], [11..15]]
15:04:46 <lambdabot>  [1,11,2,12,3,13,4,14,5,15]
15:04:57 <koz_> fr33domlover: That's a very elegant way - thank you!
15:05:21 <fr33domlover> > concat $ transpose [[1..5], [11..15], [111..555]]
15:05:22 <lambdabot>  [1,11,111,2,12,112,3,13,113,4,14,114,5,15,115,116,117,118,119,120,121,122,12...
15:05:31 <fr33domlover> works for any number of lists :P
15:05:50 <koz_> fr33domlover: Yeah, that's very nice - I think I'll use that one, rather than my pattern-matching one.
15:35:04 <buttbutter> Hey, is there any way to avoid these Ambigious ocurence errors?  http://codepad.org/UeA1kXvv   The course I'm using at some point implied that it wouldn't happen (and the solutions that I was provided support that) if you were adding instances to typeclasses, but that's clearly not the case for me.
15:35:31 <buttbutter> (Avoid them without doing something like Prelude.+ or whatever)
15:36:03 <glguy> buttbutter: Indent the definitions on lines 5-7 
15:36:10 <glguy> they need to be nested under the instance declaration
15:36:35 <buttbutter> Oh :D
15:36:38 <buttbutter> Thanks! 
15:36:38 <glguy> What your code is doing as written is shadowing the existing definitions of (+), negate, and fromInteger instead
15:36:50 <buttbutter> Yeah, that makes sense. :)
15:37:16 <prannayk> > take 2 $ drop 1000 [1..]
15:37:18 <lambdabot>  [1001,1002]
15:37:44 <prannayk>  > concat $ transpose [[1..5], [11..15]]  
15:38:26 <geekosaur> extra space at the front
15:38:27 <prannayk> where can I find the code for lambda bot?
15:38:32 <geekosaur> @version
15:38:32 <lambdabot> lambdabot 5.0.3
15:38:32 <lambdabot> git clone https://github.com/lambdabot/lambdabot
15:38:48 <glguy> ?google lambdabot
15:38:49 <lambdabot> https://wiki.haskell.org/Lambdabot
15:49:01 * hackagebot typed-wire 0.3.1.1 - Language-independent type-safe communication  https://hackage.haskell.org/package/typed-wire-0.3.1.1 (AlexanderThiemann)
16:09:02 * hackagebot hobbits 1.2.3 - A library for canonically representing terms with binding  https://hackage.haskell.org/package/hobbits-1.2.3 (EddyWestbrook)
16:12:49 <jstimpfl1> I needed a state+writer function and thought i'd write it in this clever way
16:12:50 <jstimpfl1> (<+>) f g st = let ((b, st'), (b', st'')) = (f st, g st') in (b <> b', st'')
16:13:11 <jstimpfl1> curiously to me it aborts with "loop detected"
16:15:00 <Koterpillar> jstimpfl1: CNR, what are you running it on?
16:16:14 <jstimpfl1> how do you mean? I used stack build on a regular amd64
16:17:00 <Koterpillar> I've pasted your definition into GHCi, it works as expected
16:17:36 <lpaste> Koterpillar pasted â€œNo titleâ€ at http://lpaste.net/166103
16:17:50 <jstimpfl1> thanks, should have tried that first
16:17:58 <Koterpillar> jstimpfl1: see paste
16:30:13 <sebleblanc> can I expose a module from inside a GHCi REPL, without restarting it?
16:31:53 <geekosaur> I'm not sure what you're asking...
16:32:05 <APic> *grin*
16:32:35 <geekosaur> (the only "expose" I can think of is the cabal file exposed-modules, and the repl seems unrelated to that)
16:32:51 <sebleblanc> geekosaur, a function returned a (Data.Vector.Storable.Vector a), from hidden module vector-(something)
16:32:58 <sebleblanc> yes, "cabal repl"
16:35:20 <geekosaur> hm. I don't think you can change directly at that point, but you may be able to evade it with `:set -XPackageImports` and then `import "vector-<explicit version here>" Data.Vector.Storable`
16:35:38 <geekosaur> actually I tink you want :seti not :set
16:36:16 <Welkin> SETI
16:44:04 * hackagebot gnss-converters 0.1.8 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.8 (markfine)
16:49:49 <lpaste> Koterpillar pasted â€œStack in Docker build problemâ€ at http://lpaste.net/166105
16:50:08 <Koterpillar> Where do I start to debug this? https://github.com/koterpillar/tianbar/blob/docker-build/Dockerfile is what am I running
16:51:53 <EvanR> any idea what "constructor class" is ?
16:52:03 <EvanR> or how its different from type classes
16:53:59 <pikajude> "haddock: internal error: --read-interface=HUnit-1.3.1.1,HUnit-1.3.1.1/HUnit.haddock: openFile: does not exist (No such file or directory)" what does this mean?
16:55:25 <pikajude> not on google anywhere
16:56:32 <geekosaur> pikajude, looks to me like it's trying to use a command line option as a filename
17:04:44 <pikajude> i see
17:05:18 <fishythefish> EvanR: Context?
17:05:31 <Koterpillar> what about "setup: GI/GLib/Callbacks.hs: invalid argument"?
17:25:09 <oxBAB> Hi all
17:25:49 <Koterpillar> oxBAB: Hi.
17:26:05 <oxBAB> First time here for me
17:40:04 <M-Magnap2> Hello and welcome!
17:52:34 <pikajude> does anybody know how to parse a ByteString into an xml-types Document?
17:58:10 <jstimpfl1> Koterpillar, can you reproduce the loop in http://lpaste.net/166113
18:03:56 <rfw> why can't i do let x = do ...? it seems to be a syntax error
18:05:26 <geekosaur> @paste what is actually failing for you?
18:05:26 <lambdabot> Haskell pastebin: http://lpaste.net/
18:06:16 <Koterpillar> jstimpfl1: I get T () and then it hangs
18:07:22 <Cale> rfw: It's not a syntax error, so the problem is something else. If you paste your code on lpaste, we can probably tell you pretty quickly. I'm guessing it's probably indentation related -- the subsequent line has to start in a strictly deeper column than the x in order to be part of the do-block.
18:07:49 <rfw> Cale: ohh
18:07:57 <jstimpfl1> Koterpillar: Fail: <<loop>>
18:08:19 <jstimpfl1> .. is what I get as output and it terminates immediately
18:08:21 <rfw> Cale: i see, it works now
18:09:01 <kybaeus> A significant amount of haskell is whitespace sensitive.
18:09:02 * geekosaur agrees with Cale. remember that let also uses layout, so even if do would work with your indentation by itself, it must also abide by let's layout here
18:51:08 <athan> Couldn't Traversable be created by any Foldable & Unfoldable, and an Applicative context?
18:51:44 <johnw> how would you unfold the same structure that you folded?
18:52:32 <athan> traverse f = foldM (\acc x -> snoc acc <$> f x) empty
18:52:43 <athan> where snoc and empty are proveded by Unfoldable
18:53:01 <johnw> there are many structures where snoc could have multiple meanings
18:53:16 <godel> hey
18:53:20 <johnw> data List' a = Nil | Cons1 a (List' a) | Cons2 a (List' a)
18:53:24 <johnw> which Cons does snoc use?
18:53:25 <godel> what do you recommend using for testing in haskell?
18:53:26 <athan> I mean, there are laws you could extablish relating to foldable though
18:53:29 <godel> Like unit testing
18:53:34 <johnw> godel: I like hspec, some like tasty
18:54:01 <johnw> athan: I still don't think so; foldable doesn't provide you any structural information to make use of in the unfold
18:54:07 <Welkin> atan
18:54:13 <godel> johnw: which one do you like better?
18:54:13 <Welkin> vs atan2
18:54:17 <athan> johnw: Wouldn't it be related to `fromList`, like how Foldable is analogous with `toList`?
18:54:18 <Welkin> vs athan
18:54:19 <johnw> it's the job of Traversable to "maintain" structure while apply 'f' at every 'a'
18:54:40 <johnw> fromList would still have to use a "default structure"
18:54:46 <johnw> again, see my List' example
18:54:59 <athan> Welkin: Don't diverge from the topic :v
18:55:13 <Koterpillar> what laws are there for snoc?
18:55:14 <Welkin> athan: how are you?
18:55:15 <athan> johnw: Well yeah of course
18:55:25 <athan> just like how HashSet needs a default one too
18:55:31 <johnw> so, Traversable is more than fold/unfold+applicative
18:55:32 <athan> as a Foldable
18:55:37 <athan> I would agree too
18:55:45 <athan> I'm just asking about recreation
18:55:57 <athan> or satisfying its intuitive behavior
18:56:11 <athan> like how you could recreate an applicative out of a monad back in the day
18:56:36 <athan> Welkin: I'm doing good, still a rogue, but a cool one with a black tank top and sweet shades who never smiles
18:56:39 <athan> how about you?
18:57:01 <johnw> well, if you want to create Traversable in that way, you'd need something more capable than Traversable
18:57:11 <johnw> what you're asking is more like trying to get Monad from Applicative
18:57:40 <Koterpillar> where is the canonical definition of Unfoldable?
18:57:56 <johnw> I think there is no official Unfoldable for that reason
18:58:07 <athan> hmm ahh okay that makes sense
18:58:17 <Welkin> athan: okay, just looking for work :D
18:58:22 <Welkin> ...still
18:58:33 <athan> :\ I feel that
18:58:40 <athan> I've almost got a slick app store for hackage built
18:59:00 <athan> I'm hoping people will be like "ooh ahh we should use haskell for enterprise"
19:01:07 <Welkin> lol
19:07:06 <EvanR> athan: ill sell you the rights to use the phrase "Enterprise Haskell Integrations"
19:16:43 <nitrix> Enterprise-ready.
19:21:45 <monochrom> perhaps simply convince the Star Trek people to use Haskell. then it is truly Enterprise-ready.
19:24:09 * hackagebot MissingH 1.4.0.1 - Large utility library  https://hackage.haskell.org/package/MissingH-1.4.0.1 (JohnGoerzen)
19:27:05 <Welkin> MissingNo!
19:27:06 <Welkin> :D
19:27:11 <Welkin> make a package called MissingNo
19:27:28 <EvanR> where all the operations are spelled with unrenderable unicode?
19:27:34 <Koterpillar> Welkin: http://incolumitas.com/2016/06/08/typosquatting-package-managers/
19:28:08 <Welkin> lol Koterpillar 
19:31:53 <athan> Any IxSet masters here?
19:32:22 <athan> I'm wondering if there's a function like `reIndex :: IxSet a -> k -> (a -> a -> a) -> IxSet a`
19:32:41 <athan> which tries to make the index `k` unique in the set, and calls the function when there's a collision
19:32:58 <athan> maybe `reIndexWith` might be a better name, similar to `Data.Map.insertWith`
19:33:35 <EvanR> sounds like a map
19:34:00 <athan> But but...
19:34:01 <athan> :(
19:34:02 <EvanR> k -> ([a] -> a) -> IxSet a -> IxSet a
19:34:21 <athan> oh I thought you meant a Data.Map map
19:34:24 <athan> thanks EvanR!
19:34:58 <athan> wait I don't think IxSet has a `map`
19:35:06 <EvanR> its not really map
19:36:02 <EvanR> im not even really sure how to think of IxSet since it isnt well typed
19:36:53 <athan> eh maybe groupBy will just work
19:36:57 <athan> right? :S
19:38:00 <EvanR> Eq k => IxSet a -> Map k [a], heh
19:46:32 <godel> hey
19:46:45 <godel> do you know why this fails? type x = [Integer] -> [Integer] -> Ordering
19:46:49 <godel> it says
19:46:53 <godel> Malformed head of type or class declaration
19:48:52 <Welkin> any type must start with an uppercase letter
19:48:55 <Welkin> that is a type alias
19:50:52 <benzrf> godel: yes, capitalization affects the semantics of haskell code
19:51:20 <geekosaur> godel, initial case is how it knows the difference between a type constructor and a type variable, just as initial uppercase is hoiw patterns tell the difference between data constructors and pattern variables/bindings
19:52:30 <godel> yes
19:52:32 <godel> thanks you
19:52:36 <godel> so stupid :P
19:53:10 <broma0> what SQL libs are you all using these days? I'm getting a bit annoyed with postgresql-simple
19:54:25 <Welkin> broma0: Persistent
19:54:31 <Welkin> it does all the work for you
19:54:42 <Welkin> you can use rawSql if necessary (still typesafe)
19:58:45 <broma0> i dont like how persistent hijacks my data declarations :(
20:03:08 <Welkin> broma0: you can control what the names are in your database by adding annotations
20:06:18 <nitrix> Hey
20:06:19 <nitrix> port <- fromMaybe 9000 . join . fmap readMay . listToMaybe . drop 1 <$> getArgs
20:06:46 <nitrix> I see the `join . fmap f` in this, which makes it immediatly obvious to me that this could be transformed to a >>=
20:07:10 <nitrix> Yet it's blocking mentally how I'd do this on a single one liner.
20:07:42 <EvanR> join . fmap f = 
20:07:55 <EvanR> (f >>=)
20:08:07 <EvanR> hm no
20:08:17 <EvanR> (>>= f)
20:08:30 <EvanR> hm
20:08:39 <EvanR> yeah
20:08:43 <nitrix> EvanR: Yes...
20:09:04 <EvanR> equational reasoning 
20:09:42 <nitrix> I'm not following.
20:09:50 <EvanR> but if you put that in your pipe and smoke it, coworkers will think youre nuts
20:09:53 <EvanR> oh wait this is haskell
20:10:14 <nitrix> Did you get hit on the head by a rock?
20:10:18 <EvanR> nitrix: you can replace join . fmap readMay up there with literally (>>= readMay)
20:10:49 <nitrix> I see. It's the point-free style combined with bind that is throwing me off.
20:10:56 <EvanR> yeah
20:11:42 <EvanR> or (readMay =<<) but maybe join and fmap is clearer here
20:15:58 <nitrix> I went with (readMay =<<)
20:16:37 <nitrix> I tried without pointfree, even nested do's. It's as good as it gets :/
20:17:19 <EvanR> i support this
20:17:36 <nitrix> :)
20:17:42 <EvanR> i just wont tell anyone about it when i try to convince that haskell is not that hard
20:20:03 <nitrix> Sure it's probably not how you'd manage to sell Haskell, but it isn't particuliarly complex either. The question was more about style. The alternatives are just equally noisy.
20:20:39 <EvanR> how would you explain what (readMay =<<) does in the middle of a pipeline
20:21:19 <EvanR> because i actually havent figured it out yet
20:21:48 <EvanR> i can explain the join . fmap readMay
20:22:14 <EvanR> :t listToMaybe
20:22:15 <lambdabot> [a] -> Maybe a
20:22:38 <EvanR> so id explain it in those two parts
20:31:48 <jle`> looking at the type probably is clear enough
20:31:52 <jle`> :t (readMaybe =<<)
20:31:53 <lambdabot> Not in scope: â€˜readMaybeâ€™
20:31:59 <jle`> @let import Text.Read
20:32:00 <lambdabot>  Defined.
20:32:01 <jle`> :t (readMaybe =<<)
20:32:03 <lambdabot> Read b => Maybe String -> Maybe b
20:32:38 <jle`> i can't imagine any other sensible interpretation of that type signature :)
20:32:46 <EvanR> ok yeah
20:33:16 <EvanR> i understand it now, but i still dont have an english explanation ;)
20:33:27 <EvanR> except to explain fmap readMaybe, then explain join
20:33:36 <Welkin> fmap fmap fmap
20:33:37 <shachaf> readMaybe . fromMaybe "0"
20:34:50 <EvanR> readMaybe, then put "=<<" on it
20:35:38 <Welkin> put a =<< on it
20:35:51 <Welkin> reminds me of a song from a game I played as a young child
20:36:13 <EvanR> i was thinking of portlandia
20:36:15 <Welkin> "put a bandage on it!" said the lion doctor who sounds like he's a car salesman from new jersey
20:36:18 <Welkin> :D
20:36:28 <Welkin> or was he another animal?
20:54:58 <grenegan> how are russian hackers so damn good? what are they doing that i am not to be so good?
20:55:33 <shachaf> This is off-topic.
20:55:58 <Welkin> shachaf is off topic
20:59:07 <johnw> Welkin: being rude to ops doesn't turn out well :)
20:59:31 <JuanDaugherty> fight!
20:59:56 <Welkin> JuanDaugherty: hello
21:00:07 <JuanDaugherty> yello Welkin 
21:01:10 <dibblego> Welkin: Please stop.
21:02:46 <Welkin> dibblego: ?
21:03:01 <Welkin> I haven't said anything for 7 minutes
21:03:06 <dibblego> Welkin: Please stop comments that are off the topic for the channel.
21:32:24 <phanimahesh> Welkin: There's #haskell-offtopic, though there aren't as many people
21:33:53 <godel> hey
21:34:10 <godel> how can I check if a     x : Num a    is zero?
21:34:19 <Koterpillar> :t 0
21:34:20 <lambdabot> Num a => a
21:34:22 <godel> I don't want to add    Eq a   to the signature, if possible
21:34:29 <godel> nope Koterpillar 
21:34:37 <godel> I cannot simply ask    x == 0
21:34:39 <Koterpillar> aha
21:35:04 <Koterpillar> but...
21:35:24 <Koterpillar> isn't Eq a prerequisite to Num?
21:35:30 <godel> nope
21:35:33 <Cale> godel: There's no way to do this in general.
21:35:37 <Cale> You need Eq
21:35:38 <phanimahesh> godel: Any reason why you don't want Eq?
21:35:52 <godel> Because of mental masturbation phanimahesh 
21:36:02 <godel> I thought it very hard
21:36:06 <godel> I don't think it's possible
21:36:09 <phanimahesh> hahahah. Alright.
21:36:22 <godel> but maybe any of you knew a trick
21:36:39 <phanimahesh> Yep. I don't think it's possible either. you want to check for equality, there's no way around using Eq
21:36:47 <Cale> There are instances of Num for which equality is not computable.
21:36:50 <godel> :( thanks phanimahesh 
21:36:51 <Koterpillar> laws of Num are defined using Eq
21:37:07 <phanimahesh> Cale: Example?
21:37:16 <Cale> The computable real numbers
21:37:17 <godel> phanimahesh: things like
21:37:18 <simpson> phanimahesh: CReal would be an example.
21:37:23 <godel> yea
21:37:44 <godel> Cale: good argument
21:37:46 <godel> thanks
21:37:47 <Cale> Or something like a formal power series type
21:38:05 <Cale> Though often you just define Eq there, and let it be partial
21:38:12 <shachaf> Cale: Equality is also not computable for the uncomputable real numbers.
21:38:32 <Cale> shachaf: Sure, but who wants to write *that* Num instance? :D
21:38:55 <phanimahesh> I didn't know about CReal. Cool.
21:39:27 <phanimahesh> But it has a sensible equality defined. Not perfect, but the best that can be done.
21:40:27 <Cale> Yeah, you may or may not want to define that -- it's not a particularly good Eq instance.
21:41:06 <Cale> (It's not even transitive)
21:41:10 <phanimahesh> Yep.
21:41:17 <godel> pff
21:41:22 <godel> who wants transitivity
21:41:28 <phanimahesh> What is a use case for CReal?
21:42:18 <phanimahesh> Also TIL KnownNat typeclass.
21:42:21 <shachaf> Obviously you want an Eq instance with a type-level parameter.
21:57:19 <koz_> I can define 'rollDie = state $ randomR (1, 6)'. What if I wanna roll 100 dice and collect a list of their results and the new state after all those rolls - what would I use?
21:57:47 <Koterpillar> :t state $ randomR (1, 6)
21:57:48 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m a
21:57:57 <Koterpillar> :t replicateM
21:57:58 <lambdabot> Monad m => Int -> m a -> m [a]
21:58:06 <Koterpillar> koz_: ^^
21:58:31 <koz_> > replicateM 4 (state $ randomR (1, 6))
21:58:33 <lambdabot>      No instance for (Show (m0 [a0]))
21:58:33 <lambdabot>        arising from a use of â€˜show_M11944490381041057908017â€™
21:58:33 <lambdabot>      The type variables â€˜m0â€™, â€˜a0â€™ are ambiguous
21:58:47 <koz_> Wait, missed an arg.
21:58:55 <koz_> > replicateM 4 (state $ randomR (1, 6) (mkStdGen 0))
21:58:56 <lambdabot>      Couldn't match expected type â€˜s0 -> (a, s0)â€™
21:58:56 <lambdabot>                  with actual type â€˜(Integer, StdGen)â€™
21:58:56 <lambdabot>      Possible cause: â€˜randomRâ€™ is applied to too many arguments
21:59:13 <Koterpillar> you need a runState
22:00:09 <koz_> evalState (replicateM 5 (state $ randomR (1, 6))) (mkStdGen 0)
22:00:13 <koz_> > evalState (replicateM 5 (state $ randomR (1, 6))) (mkStdGen 0)
22:00:15 <lambdabot>  [6,6,4,1,5]
22:00:18 <Koterpillar> ^_^
22:00:24 <koz_> Damn, that simple?
22:00:29 <koz_> I fucking love monads sometimes...
22:00:54 <koz_> > runState (replicateM 5 (state $ randomR (1, 6))) (mkStdGen 0)
22:00:56 <lambdabot>  ([6,6,4,1,5],732249858 652912057)
22:01:21 <koz_> Now I can roll *all the dice I want*.
22:01:29 * koz_ laughs maniacally.
22:14:45 <jle`> do you love monads, or Monad? :O
22:15:08 * jle` reads up a little
22:15:11 <jle`> yeah, Monad is great :O
22:15:22 <jle`> it's one of the things haskell gets right that a lot of languages can't emulate
22:19:32 <koz_> jle`: OK, I'm a bit confused.
22:19:33 <Koterpillar> jle`: a lot of new features different languages advertise are really instances of Monad
22:19:52 <jle`> koz_: you're celebrating because 'replicateM' was written once, and you can use it for a bunch of different monads
22:20:06 <jle`> and that's a triumph of the Monad typeclass and how typeclasses work, in specific :)
22:20:09 <koz_> jle`: Yeah, I know *that*. I'm trying to get my computation into a State monad.
22:20:11 <Koterpillar> jle`: i.e. Cont in Go, List in Prolog, etc.
22:20:37 <koz_> jle`: Basically, as I understand it, 'return' means 'fuck the state, here's a result'.
22:20:48 <koz_> While 'put' means 'fuck the result, here's the state'.
22:21:03 <Koterpillar> koz_: that's not what 'return' for State is
22:21:05 <johnw> not quite
22:21:14 <jle`> Koterpillar: yeah, and the place where they come up short is that it's hard to work with functions that work for *all* Monads
22:21:18 <johnw> return means 'given any input state, here is a result with the same output state'
22:21:22 <Koterpillar> well... depends on the definition of fuck
22:21:35 <Koterpillar> yes, as johnw said
22:22:11 <koz_> OK... I'm trying to understand the example in Control.Monad.State.Strict.
22:22:31 <koz_> (the tick one)
22:23:59 <koz_> The 'get' in there fishes out the state.
22:24:08 <koz_> So I guess 'put' replaces it with a different one?
22:24:17 <koz_> And return does... what?
22:24:31 <jle`> > runState (return 10) "hello"
22:24:33 <lambdabot>  (10,"hello")
22:24:33 <Koterpillar> koz_: return does the same thing for every monad, nothing
22:24:38 <johnw> put means 'given any input state, ignore it and return unit with the given output state"
22:24:43 <Koterpillar> :t return
22:24:44 <lambdabot> Monad m => a -> m a
22:25:06 <jle`> > runState (put "hey") "hello"
22:25:07 <lambdabot>  ((),"hey")
22:25:12 <Koterpillar> koz_: because return doesn't depend on a _specific_ Monad, it can't do anything to your state at all
22:25:18 <koz_> OK, now I'm *utterly* lost.
22:25:33 <koz_> Every time I try to understand how to use the State monad, I end up *more* confused.
22:25:39 <jle`> koz_: 'return x' is a state action that leaves the state unchanged, and whose result is 'x'
22:25:59 <Koterpillar> koz_: keep trying, the 'aah' moment is near
22:26:11 <koz_> Koterpillar: It doesn't help that my particular case is fairly tricky.
22:26:11 <jle`> koz_: 'put s' is a state action that sets the state to 's', and whose result is ()
22:26:37 <alpha1> Why is Monad a subclass of Applicative, but Comonad isn't?
22:26:41 <koz_> I have an evolutionary algorithm generation as [Individual], and I need to run the generation, with some StdGen state (for some random choices).
22:27:13 <koz_> So I assume what I'm after here is State StdGen [Individual], right?
22:27:18 <Koterpillar> correct
22:27:38 <koz_> OK, so at least I'm not *completely* insane.
22:27:39 <johnw> alpha1: Applicative has 'pure'.  Comonads do not generally have 'pure', but only 'extract'.
22:27:45 <Koterpillar> and replicateM can reduce it to: State StdGen Individual
22:28:01 <koz_> Koterpillar: Each state is a list of individuals.
22:28:19 <koz_> (like, evolutionary algorithm state, not State as in the monad)
22:29:01 <koz_> So I wanna write the respective State monad that runs one generation of my evolutionary algorithm.
22:29:12 <koz_> So then, when I need to run n generations, I just feed that thing to replicateM.
22:29:19 <koz_> (or at least, that's *my* understanding of it)
22:29:26 <Koterpillar> will the signature of that be [Individual] -> State StdGen [Individual]?
22:29:27 <koz_> The issue is that I haven't the first clue wtf to write.
22:29:29 <jle`> alpha1: there are bunches of comonads that aren't Applicatives
22:29:53 <Koterpillar> koz_: or you don't need random in there anymore/
22:30:06 <jle`> koz_: you probably want some sort of monadic iterate
22:30:12 <jle`> like x >>= f >>= f >>= f >>= f
22:30:40 <koz_> Koterpillar: The 'top-level' function should have the signature 'doTheNeedful :: [Individual] -> Int -> [Individual]'.
22:30:54 <koz_> So you take a starting generation, a number of generations to run, and this spews out the final generation.
22:31:02 <Koterpillar> you can have runOneIteration :: State [Individual] ()
22:31:11 <koz_> (I don't mind hardcoding the seed for now)
22:31:23 <Koterpillar> koz_: does each step need a StdGen?
22:31:33 <koz_> Why State [Individual] ()? I need the StdGen at each step.
22:31:44 <koz_> Each generation needs new random numbers.
22:31:47 <jle`> koz_: you can use Rand or RandT to manage randomness
22:31:52 <jle`> instead of with State
22:31:57 <Koterpillar> oh. Then [Individual] -> State StdGen [Invididual]
22:31:57 <koz_> jle`: From mtl?
22:32:01 <jle`> from MonadRandom
22:32:02 <jle`> but!
22:32:08 <Koterpillar> there's a typeclass
22:32:11 <jle`> if you never care about the "result"
22:32:19 <jle`> you can just use x >>= f >>= f >>= f ... etc.
22:32:26 <koz_> jle`: Or replicateM?
22:32:29 <jle`> monad-loops has such a function
22:32:32 <jle`> replicateM is not the same
22:32:37 <jle`> this is like replicate vs. iterate
22:32:45 <koz_> Oh yeah, because it'd give me a list, and I want just the last result.
22:32:48 <jle`> > iterate (*2) 1
22:32:50 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
22:32:54 <jle`> > replicate 10 'a'
22:32:55 <lambdabot>  "aaaaaaaaaa"
22:32:59 <Koterpillar> you can't use replicateM for [Individual] -> State StdGen [Invididual]
22:33:00 <jle`> you probably want iterate, not replicate
22:33:04 <Koterpillar> :t iterateM
22:33:05 <lambdabot>     Not in scope: â€˜iterateMâ€™
22:33:06 <lambdabot>     Perhaps you meant one of these:
22:33:06 <lambdabot>       â€˜iterateâ€™ (imported from Data.List),
22:33:16 <koz_> jle`: Yes, I want iterate, and I specifically only care about the *last* result.
22:33:54 <jle`> yeah, there is a monadic iterate in monad-loops
22:34:07 <jle`> or you can use the one in prelude, too
22:34:10 <koz_> Koterpillar: OK, so I want [Individual] -> State StdGen [Individual]. However, I'm a bit confused where the RNG comes into it from.
22:34:10 <jle`> iterate (>>= f) x
22:34:35 <johnw> I think monad-extras has a few versions of iterate
22:34:45 <Koterpillar> koz_: you have to give it one, with evalState
22:34:55 <koz_> Oh, right at the start?
22:34:58 <Koterpillar> yes
22:35:13 <Koterpillar> but once you do that, you can substitute that function for (iterate N thatfunction)
22:35:17 <koz_> Koterpillar: So how do I 'have' one inside of runOneGeneration? Is this where magical get comes into it?
22:35:26 <Koterpillar> get
22:35:32 <jle`> koz_: the high level is that you are writing a [Individual] -> [Individual] that you want to iterate
22:35:37 <Koterpillar> sorry, you don't really want get
22:35:37 <jle`> except you want to iterate it "with RNG state"
22:35:46 <koz_> jle`: That's *exactly* it.
22:35:46 <Koterpillar> you want randomR
22:35:53 <jle`> so you you want to 'iterate' an [Individual] -> State StdGen [Individual]
22:35:59 <jle`> so instead of 'iterate', you use 'iterateM'
22:36:31 <jle`> so, if you want to iterate a (a -> a) a bunches, use 'iterate
22:36:33 <zRecursive> @unmtl State StdGen [Individual]
22:36:34 <lambdabot> StdGen -> ([Individual], StdGen)
22:36:40 <jle`> if you want to iterate an (a -> m a) a bunches, use 'iterateM' of some sort
22:37:09 <koz_> Koterpillar: OK, let me just write a skeleton real quick.
22:38:57 <lpaste> koz_ pasted â€œSkellingtonâ€ at http://lpaste.net/166156
22:41:14 <lpaste> Koterpillar annotated â€œSkellingtonâ€ with â€œSkellington (annotation)â€ at http://lpaste.net/166156#a166158
22:41:40 <koz_> Oh so *that* is how....
22:42:03 <koz_> So I should basically imagine there's a StdGen in there someplace which I can use with <-.
22:42:18 <Koterpillar> the purpose of State is to hide the need to deal with it manually (return newRNG)
22:42:33 <Koterpillar> you don't have to imagine; it _is_ there, behind State
22:42:44 <koz_> Koterpillar: It helps me think of it that way.
22:42:53 <koz_> I think I can write this now - thanks!
22:45:05 <koz_> Koterpillar: I'm guessing the RNG that's there gets appropriately updated with that randomR call?
22:45:21 <Koterpillar> yes
22:45:27 <koz_> That's fucking magical.
22:46:53 <koz_> Once I've written this, I'm gonna be using it everywhere.
22:49:15 <jle`> in real life, people usually don't use State StdGen too much, I think
22:49:27 <jle`> except for one-offs
22:50:05 <koz_> jle`: What would they use instead?
22:50:17 <Koterpillar> if your use case calls for it, use it
22:50:35 <jle`> MonadRandom, Rand, RandT, and things like that.  it wraps up the functionality a little nicer
22:50:44 <jle`> and conveys intent
22:50:51 <Koterpillar> ^^ ++
22:50:52 <koz_> Also, now I wanna zip together a list fooList and a list of things coming out of my RNG, keeping the RNG updated. How would I write this?
22:51:02 <koz_> jle`: OK, well, I guess I'll have to read up on those too...
22:51:04 <jle`> zipWithM
22:51:10 <koz_> :t zipWithM
22:51:11 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
22:51:57 <koz_> jle`: So it'd be 'zippy <- zipWithM (,) fooList' ?
22:52:02 <koz_> Or am I missing something here?
22:52:23 <jle`> what are the types you are workign with?
22:52:29 <Koterpillar> I think you need this, except for 1 argument and not 2
22:52:57 <Cortland> Hmm
22:53:11 <koz_> My RNG emits Ints, and fooList is [Individual]. The final result is [(Individual, Int)], where the Ints come from that RNG, which gets updated appropriately.
22:53:31 <Koterpillar> :t forM
22:53:32 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
22:53:32 <Cortland> Trying to stack build on a project in ubuntu and I get 
22:53:33 <Cortland> setup-Simple-Cabal-1.22.5.0-ghc-7.10.3: Missing dependency on a foreign library: * Missing C library: ippicv
22:53:38 <Cortland> related to opencv
22:53:50 <koz_> Cortland: Do you have ippicv installed?
22:54:06 <Cortland> it should be.
22:54:08 <Koterpillar> :t forM [1, 2, 3] (liftM (,) randomR)
22:54:09 <lambdabot> (Num (a, a), RandomGen g, Random a) => b -> [(g -> (a, g), b)]
22:54:12 <Koterpillar> nope
22:54:32 <koz_> Koterpillar: Do I need liftM, or will <$> suffice?
22:54:47 <Cortland> should have installed with openvcv correct?
22:54:56 <Koterpillar> they are kind of the same; I can't think of the incantation off the top of my head
22:55:06 <koz_> Koterpillar: I thought so too - just checking.
22:55:22 <Cortland> when I cmake I even  -D WITH_IPP=ON
22:56:04 <Cortland> The project was initially a cabal package (not on hackage). I trying to build it to use stack along with cabal. If that make sense
22:56:23 <koz_> Koterpillar: Just randomR? Not randomR (0, 6) or whatever?
22:56:30 <Koterpillar> oh, right
22:56:38 <Koterpillar> :t forM [1, 2, 3] (liftM (,) (randomR (0, 10))
22:56:39 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
22:56:46 <Koterpillar> :t forM [1, 2, 3] (liftM (,) (randomR (0, 10)))
22:56:47 <lambdabot> (Num a, Num a1, RandomGen a, Random a1) => b -> [((a1, a), b)]
22:57:07 <Koterpillar> I still don't think this is right
22:57:40 <koz_> Koterpillar: My typechecker agrees with you.
22:57:49 <koz_> (in that it's not happy)
22:58:19 <koz_> :t forM
22:58:21 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
22:58:31 <Koterpillar> :t forM []
22:58:32 <lambdabot> Monad m => (a -> m b) -> m [b]
22:58:51 <koz_> :t liftM
22:58:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:59:08 <Koterpillar> :t uncurry
22:59:09 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:59:14 <Koterpillar> :t (,)
22:59:15 <lambdabot> a -> b -> (a, b)
22:59:18 <koz_> Are you sure it's liftM (or fmap, or <$>) we want?
23:00:17 <Cortland> damn this sucks
23:02:52 <Koterpillar> koz_: it's the same, I checked
23:03:06 <Koterpillar> one missing bit is that you have to use state (randomR (0, 10)) and not just randomR
23:03:49 <koz_> Koterpillar: So what would it look like?
23:04:41 <koz_> thingICareAbout <- forM fooList ((,) <$> (state (randomR (0, 10))) ?
23:04:44 <koz_> (or so?)
23:05:20 <Koterpillar> :t forM [1,2,3] (\i -> ((,) i) <$> state (randomR (0, 10)))
23:05:21 <lambdabot> (Num a, Num b, MonadState s m, RandomGen s, Random b) => m [(a, b)]
23:05:58 <koz_> :t forM [1,2,3] ((,) <$> (state (randomR (0, 100))))
23:05:59 <lambdabot>     Could not deduce (Num a0) arising from the literal â€˜1â€™
23:05:59 <lambdabot>     from the context (Num a, Random a)
23:05:59 <lambdabot>       bound by the inferred type of
23:06:01 <Koterpillar> if it can be improved, I'd like to see too
23:06:28 <Koterpillar> I mean, you can make it pointfree with (flip (<$>))
23:15:39 <koz_> OK, that's some super-ugly Haskell, but it seems to be right.
23:17:31 <jle`> koz_: it'd probably write ti with do notation
23:17:40 <jle`> stuff <- forM fooList $ \i ->
23:17:48 <jle`>   x <- state (randomR (0, 10))
23:17:55 <jle`>   return (x, i)
23:20:25 <koz_> jle`: I'll likely rewrite it a bunch of times - right now, I just wanna see if it ticks.
23:21:41 <koz_> jle`: OK, I have a function f :: Table -> [Individual] -> (StdGen, [Individual]). I want to run this state processor for 50 steps, and capture a list of the [Individual]s at the 10th, 20th, 30th, 40th and 50th steps. What should I use to do that?
23:21:54 <koz_> (I have a starting (StdGen, [Individual]) obviously)
23:22:07 <koz_> (and a Table to give it)
23:22:12 <jle`> koz_: i might hand roll a recursive iterator
23:22:22 <koz_> jle`: What should its type be?
23:22:50 <jle`> iterateABunch :: Int -> Int -> State StdGen [[Individual]]
23:23:05 <jle`> the first might be the gaps between the steps and the second might be how many steps to take per report
23:23:07 <jle`> um
23:23:16 <jle`> iterateABunch :: Int -> Int -> [Individual] -> State StdGen [[Individual]]
23:23:26 <jle`> and just writing it with recursion should be fine
23:23:48 <koz_> So it just uses the Ints as counters to either build or control recursion?
23:23:59 <jle`> yeah
23:24:18 * hackagebot phone-metadata 0.0.1.0 - Phonenumber Metadata based on Google's libphonenumber  https://hackage.haskell.org/package/phone-metadata-0.0.1.0 (vijayanant)
23:24:27 <jle`> you could write it with a bunch of nested iterateM's, but sometimes just using recursion with counters a good first step
23:24:29 <koz_> So in my case, the args would be 10 and 5 respectively?
23:24:35 <jle`> mhm
23:30:43 <idev> anyone here used both haskell web dev + elixr-phoenix, and find that somehow elixir-phoeinx has something that haskell lacks?
23:31:01 <idev> I've played with yesod, snap, happstack, but phoenix has something that I can't quite pin that haskell web frameworks seem to lack
23:31:35 <koz_> jle`: How would I append a [Individual] to the State (StdGen, [[Individual]]) I'm building up in the iterator?
23:31:48 <jle`> do notation
23:31:49 <koz_> I guess it uses 'return' somehow, but I'm not clear on that.
23:31:58 <jle`> look up how 'sequence' is defined
23:32:25 <jle`> sequence [] = return []
23:32:28 <jle`> sequence (x:xs) = do
23:32:31 <jle`>   y <- x
23:32:35 <jle`>   ys <- sequence xs
23:32:37 <jle`>   return (y:ys)
23:33:19 <koz_> jle`: I'm not sure I follow how that resembles my case any.
23:35:00 <jle`>   res <- doSomeTimes
23:35:12 <jle`>   reses <- iterateABunch new accumulators res
23:35:16 <jle`>   return (res : reses)
23:35:59 <koz_> jle`: But when I saw <- used in State before, it fetched the StdGen, not the other part.
23:36:18 <jle`> if you do 'x <- blah', x is the result of 'blah'
23:36:24 <Koterpillar> it fetches whatever the type of your state is
23:36:25 <jle`> so the result of the action
23:36:42 <jle`> so if your action is State s Int, 'x' is the Int that is the result
23:36:50 <jle`> if your action is State s Bool, x would be the Bool that is the result
23:37:12 <jle`> sort of like in IO, if you had getLine :: IO String, and you did x <- getLine, x would be the String that is the result
23:37:32 <koz_> OK, I think that makes more sense.
23:39:05 <koz_> OK, let me try something simpler. If I want to iterate a State computation, but only want the *last* result, what would I use?
23:39:46 <koz_> (well, assuming I only have finite iterations)
23:39:47 <jle`> doNTimes :: Int -> (a -> m a) -> a -> m a
23:39:54 <jle`> doNTimes 0 f x = return x
23:39:59 <jle`> doNTimes n f x = do
23:40:03 <Cale> For that, you probably just write something recursive...
23:40:05 <jle`>   y <- f x
23:40:16 <jle`>   doNTimes ??? f x
23:40:21 <jle`> :)
23:40:28 <jle`> i left some parts for you to think it through
23:40:32 <koz_> jle`: OK, *that* I get, I think.
23:40:51 <jle`> er, that should have been 'doNTimes ??? f y'
23:40:58 * koz_ is surprised there's no built-in for that.
23:41:04 <koz_> jle`: I got what you meant. :)
23:41:14 <jle`> we mentioned a couple of libraries before that offered it
23:41:17 <jle`> monad-loops and monad-extras
23:41:29 <koz_> jle`: I guess I'll check them out too.
23:41:38 <jle`> but yeah, it's not too bad to write it as a one-off recursion thing
23:42:01 <jle`> you can use doNTimes as a part of your iterateABunch
23:42:19 <jle`> or well, you can write doNTimes and accumulate the results, too
23:42:30 <jle`> doNTimesKeepResults :: Int -> (a -> m a) -> a -> m [a]
23:42:37 <jle`> doNTimesKeepResults 0 f x = return [x]
23:42:49 <jle`> i'll let you fill in the rest :)
23:43:40 <koz_> jle`: I was planning to use doNTimes exactly in this way!
23:46:48 <koz_> jle`: doNTimesKeepResults n f x = do y <- f x; return y : doNTimesKeepResults (n - 1) f y?
23:47:14 <jle`> pretty much, but you're missing parentheses
23:49:18 * hackagebot eccrypto 0.0 - Elliptic Curve Cryptography for Haskell  https://hackage.haskell.org/package/eccrypto-0.0 (MarcelFourne)
23:51:57 <koz_> jle`: Not according to Haskell - it seems to be OK without parens.
23:52:11 <koz_> OK, now I need to think how to combine them properly.
23:52:41 <jle`> `return y : doNTimesKeepResults (n - 1) f y` shouldn't work
23:52:47 <jle`> did you include the type signature as well?
23:53:26 <koz_> jle`: Both of these are where-bound, so no.
23:53:42 <koz_> doNKeep 0 _ x = return [x]                                                                                        
23:53:44 <koz_>         doNKeep n f x = do                                                                                                
23:53:46 <koz_>           y <- f x                                                                                                        
23:53:48 <koz_>           return y : doNKeep (n - 1) f y
23:53:50 <koz_> (apologies for additional spaces)
23:54:02 <jle`> it's probably inferring a different type than you think
23:54:08 <jle`> add the type signature
23:54:26 <jle`> return y : doNKeep (n - 1) f y is parsed as (return y) : (doNKeep (n - 1) f y)
23:54:45 <jle`> it'd only make sense if your function returns [[a]], not 'm [a]'
23:55:04 <koz_> OK, *now* it's complaining.
23:55:09 <jle`> it's probably inferring doNKeep :: Int -> (a -> [a]) -> a -> [[a]
23:55:10 <jle`> ]
23:55:32 <jle`> but really, you probably already know that you don't want (return y) : (doNKeep (n - 1) f y) :P
23:55:44 <koz_> I suspected as much.
23:55:53 <koz_> Let me think about it some more.
23:56:52 <koz_> OK, I think I have it. Let me make a paste quickly.
23:57:12 <jle`> ah wait yeah, there's more wrong there than just the parentheses
23:57:19 <lpaste> koz_ pasted â€œIs this right?â€ at http://lpaste.net/166167
23:57:23 <jle`> `doNKeep (n - 1) f y` is m [a]
23:57:30 <jle`> but you want to cons it with 'y'
23:57:34 <jle`> so you need an '[a]'
23:57:43 <jle`> yea,h that's right
23:57:48 <koz_> Yay!
23:59:48 <koz_> Thank you very much jle` - your patience is legendary.
23:59:54 <jle`> np!
