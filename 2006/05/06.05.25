01:32:49 <Lemmih> Greetings JaffaCake.
01:32:55 <JaffaCake> hi there!
01:37:28 <malcolm> JaffaCake: is the ghc hackathon looking viable yet?
01:37:56 <JaffaCake> malcolm: last I checked, we had just about enough people I think
01:38:20 <JaffaCake> a few more now, so yes I think it's viable
01:38:34 <malcolm> JaffaCake: it may depend on how many of those promises turn into attendances though
01:38:41 <JaffaCake> true
01:39:56 <malcolm> still, if we record the presentations it will reach a wider audience than just attendees
01:40:31 <JaffaCake> yes, I like that idea
02:04:17 <Lemmih> dons, dcoutts: ping.
02:22:24 <dons> Lemmih: yeah?
02:23:34 <Lemmih> dons: Will 'breakEnd' return to the FPS repo?
02:24:05 <dons> you mean breakLast?
02:24:45 <dons> ah, maybe I was too hasty. breakFirst was not useful. but breakEnd is needed to complement spanEnd
02:26:43 <dons> what we had was breakLast, but we we should have is breakEnd, a la spanEnd
02:26:46 <dons> I'll add that now.
02:32:29 <Lemmih> Thanks.
02:36:42 <dons> Lemmih, done. look for breakEnd in your usual fps repository, or specially selected retailers ;)
02:50:07 <dozer> is there a good debugger for haskell where I can step through the executing code and look at the value of different expressions/variables?
02:50:30 <neologism> there's hat but I never manage to got it working ;(
02:51:08 <dozer> I can't resort to my usual "insert print statements" quick fix :'(
02:51:10 <malcolm> Hat works for mainly h'98 code, with a few extensions - MPTC + FD mainly
02:52:02 <jethr0> dons: i'm thinking about implementing language.python or .ruby. i'm just wondering what those would be good for (i.e. what will language.c for example be used for?)
02:52:37 <Saulzar> dozer, You can use Debug.Trace which is what I usually do
02:52:43 <jethr0> dozer: linear stepping is problematic due to the lazyness. and i haven't gotten "hat" to work either :(
02:53:13 <malcolm> imagine being able to suck in a C program, analyse it, transform it, and spit out the "equivalent" Java or Haskell or Python
02:53:38 <Saulzar> That seems a pretty far out goal...
02:53:39 <jethr0> malcolm: i can imagine that. but from a non-semantically checked AST that's still a far way
02:53:53 * malcolm is willing to receive bug reports on Hat
02:54:05 <Saulzar> Language.C gets used for the FFI tools stuff right?
02:54:25 <jethr0> Saulzar: language.c doesn't exist yet; it's one of the SoC projects
02:54:41 <Saulzar> Ah, but that's what's it's intended for, right?
02:54:46 <jethr0> and the idea is to parse C and then do "something" with the resulting AST (optimization, ...?)
02:54:53 <malcolm> Saulzar: the c2hs tool already does it!  (at least, it generates FFI bindings to the C)
02:55:01 <dozer> ok - will try trace. thx
02:55:19 <jethr0> i have no idea what it's intended for, that's why i'm asking. FFI and all those C related things are working fine without it :)
02:55:28 <Saulzar> Hmm, I thought the Language.C stuff was intended to extend the c2hs stuff.
02:55:45 <jethr0> malcolm: it's not so much bug reports. but it's hard to compile hat for a recent ghc version...
02:55:51 <Saulzar> Maybe put it in a common library form useful for other stuff?
02:56:11 <jethr0> i thought it was about parsing C code in an AST
02:56:11 <malcolm> jethr0: a failure to compile/install is a bug in my book
02:56:42 <jethr0> malcolm: not if it says sth like "hat is compatible with ghc < 6.3"
02:56:57 <Saulzar> I guess a lot of the FFI stuff needs that kind of functionality
02:57:21 <malcolm> jethr0: I'm not aware of any documentation that says ghc < 6.3 ??
02:57:31 <jethr0> :)
02:58:19 <jethr0> malcolm: it's been a while since i tried. but the debian packages are broken for sure. and when trying to compile it myself i ran into all kinds of trouble. (for example getting viable ghc sources and bootstrapping stuff). when i try again (and i will) i'll come back to you *g*
02:59:03 <malcolm> jethr0: I can't speak for debian issues, no-one tells me about them
02:59:18 <jethr0> i wasn't complaining
02:59:21 <malcolm> jethr0: but you don't need a source dist of ghc in order to build hat
03:00:14 <jethr0> i forgot what the concrete issue was. either it didn't compile for amd64 or sth annoying. but i don't want to badmouth hat; maybe i just didn't try in a structured enough fashion
03:00:50 <jethr0> what i _can_ say is that compiling/installing it is definitely non-trivial
03:01:01 <malcolm> jethr0: don't worry about complaining etc.  If it didn't work for you, then it is a problem, and it needs fixing
03:01:35 <malcolm> jethr0: in theory it should be just the usual ( ./configure; make; make install )
03:01:37 <jethr0> malcolm: maybe i'll try again one of these days and then i'll record my progress
03:02:20 <malcolm> jethr0: cool, I look forward to the bug report
03:02:24 <jethr0> malcolm: from i'll try right now
03:02:29 <jethr0> s/from//
03:05:05 <jethr0> malcolm: first bug report "generated ./lib/x86_64-linux/config has syntax error in line 9. autoextracted GHCSYM has two leading newlines"
03:06:32 <malcolm> jethr0: OK, that one is known.  For now, just delete the newlines in lib/.../config to give you GHCSYM=604 and continue.
03:06:36 <jethr0> malcolm: second problem (not hat related): "MkProg: hmake: the compiler 'ghc' is not known.". i've fixed this before in the hat scripts because in my hmake ghc is called ghc64 or so. i'll try to reproduce my fix
03:06:41 <jethr0> already did
03:07:00 <malcolm> hmake-config ghc64
03:08:14 * jethr0 is not very comfortable with the haskell build toolchain. i'm rather confused by all the cabal, Setup.lhs, hmake stuff...
03:08:53 <dozer> I'm not having any joy with using Debug.Trace
03:09:17 <malcolm> hmake is the venerable oldie, cabal and ghc--make are youngsters... :-)
03:09:26 <jethr0> dozer: joy? what problems are you running into? trace can be a bit weird in combination with lazyness, too
03:10:09 <jethr0> /home/jethr0/workspace/env_hask/hat-2.04/script/hat-trans -P. -I. -trusted -prelude -D__GLASGOW_HASKELL__=  604 PreludeBuiltin.hs
03:10:12 <jethr0> Can't open 604
03:10:30 <jethr0> there's two spaces in front of the version number :(
03:10:35 <jethr0> not in my config file though
03:10:37 <malcolm> jethr0: eliminate the space in GHCSYM= 604
03:11:23 <dozer> jethr0: I think it's OK now - I was folding them into an expression inside a "do" block at the wrong level
03:11:25 <jethr0> there's none there in the config file
03:11:26 <dozer> so it wasn't type checking
03:12:17 <malcolm> OK, hold on, it isn;'t in the config file
03:12:51 <malcolm> it's in targets/x86_64-linux/ghcsym
03:13:42 <jethr0> ah, same problem. found it
03:13:47 * malcolm wonders why the Makefile is using that source for the value when it already has GHCSYM defined
03:14:08 <jethr0> CPPFLAGS = -D__GLASGOW_HASKELL__=$(shell cat ${BUILDDIR}/ghcsym)
03:18:06 <Saulzar> Hmm, I tried compiling hat and it seems to be compiling ok.
03:18:28 <Saulzar> It compiles a debugging version of all the base libs?
03:21:22 <jethr0> malcolm: it compiled fine. if this was all i am sorry to have bothered you with it. but i'm pretty sure there was something else last time i tried...
03:23:57 <jethr0> hmake -hat test.hs
03:24:04 <jethr0> hat-trans is not installed/configured for debian. (Tried directory /usr/local/lib/hat)
03:24:25 <jethr0> the executable is in that directory and i can execute it. i have no idea what hmake wants from me
03:27:50 <jethr0> "ghc -package hat test.hs" compiles but doesn't produce a ".hat" file
03:30:15 <Saulzar> That would just link in the hat package. Mine seems to find hat-trans but the structure of the hat libs seems to be different from that in ghc
03:30:56 <Saulzar> hat-trans: /usr/local/include/hat/Text/ParserCombinators/Parsec/Token.hx: openFile: does not exist  -- it has ...Combinators/Parsec.hx instead, and no Parsec directory
03:31:04 <jethr0> "hat-trans file.hs" works fine but then ghc can't fine "Hat.Prelude". i'll check if i got all the include directories right
03:39:17 <dcoutts> dons, hmm I think the strictness is ok, I did document it.
03:39:26 <dcoutts> dons, afterall this diverges too: let xs = Data.ByteString.cons 0 xs in Data.ByteString.take 10 xs
03:40:52 <dcoutts> dons, I'm not sure one can claim that it's wrong, it depends on what you are exepcting
03:41:04 <jethr0> yuchu, i got hat to work :). not with hmake though :(
03:41:38 * vincenz pokes jethr0 
03:41:51 <vincenz> was that you?
03:42:05 <jethr0> was what me?
03:42:10 <vincenz> faking to be lambdabot 
03:42:13 <jethr0> yes
03:42:14 <jethr0> why?
03:42:19 <vincenz> just curious
03:42:44 <jethr0> people kept sending me privmsg requests, but i couldn't answer as non-registered user
03:42:51 <jethr0> i used oasisbot to relay :)
03:42:51 * vincenz snickers
03:43:08 <jethr0> vincenz: did you see the lambdabot problem. you should maybe fix that in oasisbot too
03:46:00 <vincenz> erm no
03:46:06 <vincenz> but I did do an update toda
03:46:10 <vincenz> and recompile
03:50:32 <kevind> hey, can anyone help me get ghc testsuite working.  I get the error "ghc.exe: Can't find package.conf as \c\t-kevind\work\fc-branch\driver\package.conf.inplace" though that file is definitely there
03:53:04 <mnislaih> Lemmih: hi mentor :P
03:56:42 <jethr0> malcolm: thanks for your help!
03:59:36 <Lemmih> mnislaih: Hey.
04:00:23 <jethr0> > kick "jethr0"; kick = ("I hate you "++)
04:00:24 <lambdabot>  "I hate you jethr0"
04:00:40 <mnislaih> Lemmih: can we talk a bit about the project ?
04:02:17 <Lemmih> mnislaih: Yeah.
04:02:41 * jethr0 has the feeling that he'll use "hat" a LOT now that it's working. *yeah*
04:07:54 <inv2004> hi all
04:08:45 <inv2004> data Pars a = Ok a (Pars a) | No | End
04:08:49 <inv2004> c::[Token] -> String -> Int -> Pars a - doesn't work
04:09:05 <inv2004> a is Char in this function
04:09:51 <inv2004> Couldn't match the rigid variable `a' against `[a1]'
04:09:51 <inv2004>       `a' is bound by the type signature for `c'
04:09:57 <jethr0> inv2004: what can we say to that? how does the function look and what doesn't work
04:10:14 <inv2004> c (D1:t) = \s i ->
04:10:14 <inv2004>   case s!!i of
04:10:14 <inv2004>     x|x `elem` "1234567890" -> Ok [x] (p_and t s (i+1))
04:10:14 <inv2004>     _  -> No
04:10:32 <jethr0> i think it's because you have a free type variable in the signature
04:10:33 <inv2004> if I don't declare c::... it works fine.
04:10:46 <jethr0> have you tried replacing "a" with "Char"?
04:10:58 <inv2004> Y, it'll work
04:11:07 <jethr0> also, ghci can tell you the type of a function with ":t"
04:11:12 <inv2004> but its unknown type, why shouldn't I use a ?
04:11:28 <jethr0> it has to be bound, i.e. one of the input types has to determine "a"
04:11:47 <inv2004> y, Parc [Char], I know
04:11:50 <jethr0> i think
04:12:39 <inv2004> hm, don't understand why function can't return a type
04:13:16 <jethr0> or you could put a restriction on it with c :: (Ord a) => [Token] -> Pars a
04:13:40 <inv2004> ok, thx, will try
04:13:58 <malcolm> jethr0: sorry, I got called away to a meeting.  glad you got hat working
04:14:02 <jethr0> you have to make some kind of restriction on a that conforms to the usage in the implementation
04:14:24 <jethr0> @type id
04:14:25 <lambdabot> forall a. a -> a
04:14:28 <jethr0> @type undefined
04:14:29 <lambdabot> forall a. a
04:17:34 <jethr0> inv2004: also, you are fixing the type of the function by implementing "Ok [x]" with x being a character
04:18:13 <jethr0> inv2004: if you wrote "[a]" instead of "String" it might even work
04:19:21 <jethr0> > let c :: [a] -> Maybe a; c [] = Nothing; c (x:xs) = Just x in c [4,5,6]
04:19:22 <lambdabot>  Just 4
04:20:45 <inv2004> I think where is no different a = [a]
04:20:58 <inv2004> a can be list too
04:21:14 <jethr0> > let c :: [a] -> Maybe a; c [] = Nothing; c (x:xs) = Just x in c [[4],[5],[6]]
04:21:15 <lambdabot>  Just [4]
04:21:52 <jethr0> > let c :: [a] -> Maybe [a]; c [] = Nothing; c xs = Just xs in c [[4],[5],[6]]
04:21:53 <lambdabot>  Just [[4],[5],[6]]
04:22:23 <jethr0> > let c :: [[a]] -> Maybe [a]; c [] = Nothing; c (x:xs) = Just x in c [[4],[5],[6]]
04:22:23 <lambdabot>  Just [4]
04:22:28 <jethr0> spam spam spam
04:23:02 <jethr0> by saying "[a]" you are restricting "a" to it to be a list of anything
04:23:16 <inv2004> y
04:23:17 <jethr0> no, you are restricting the whole expression to be a list of a's
04:23:42 <inv2004> a can be [Char] and Char also
04:23:52 <jethr0> so, "a" matches "5", but "[a]" doesn't
04:23:57 <jethr0> yes
04:23:59 <inv2004> y
04:24:16 <inv2004> a matches [5] also
04:25:18 <jethr0> yes
04:26:05 <jethr0> if "[a]" matches "[5]", a is Num or so
04:26:18 <jethr0> if "a" matches "[5]", a is [Num]
04:26:28 <inv2004> I understand it
04:31:12 * shapr boings
04:31:27 * Beelsebob bangs shapr 
04:31:50 <shapr> ohh, I love a good ... wait.
04:31:50 * jethr0 bustles beelsebob for banging the boinsing shapr
04:32:03 <shapr> Sorry, I'm taken already :-P
04:32:06 <Beelsebob> lol
04:32:14 <Beelsebob> so am I... three is just more fun :P
04:32:17 * shapr grins
04:32:35 <shapr> My woman is so good I don't even want to discuss it with others for fear they'll try to grab her.
04:32:49 <Beelsebob> lol
04:32:50 <shapr> Aaanyway.. back to coding :-)
04:32:56 <swiert> does anyone know anything about System F with type equality conversions?
04:33:14 <Beelsebob> swiert: look at Simon PJs TFP paper
04:33:16 <swiert> as in the Simon Peyton Jones paper.
04:33:19 <shapr> hah
04:33:22 <Beelsebob> lol
04:33:36 <shapr> Who needs citeseer when you have #haskell?
04:33:50 <Beelsebob> hehe
04:33:59 <Beelsebob> no one... google scholar all the way
04:34:17 <swiert> oh well. Thanks for the pointer ;)
04:34:51 <shapr> Needs a lambdabot plugin.
04:35:00 <shapr> ?scholar system F with type equality
04:35:00 <lambdabot> Unknown command, try @list
04:35:04 <Beelsebob> what, citeseer?
04:35:10 <shapr> Nah, google scholar
04:35:21 <Beelsebob> just adjust the google module
04:35:31 <Beelsebob> @google-s System F with type equality
04:35:32 <lambdabot> http://lambda-the-ultimate.org/node/1411
04:35:39 <shapr> hm!
04:35:58 <shapr> same paper :-/
04:36:36 <shapr> Funny, it mentions the connection to Epigram
04:36:52 <Beelsebob> oh shapr, did I say I finally managed to batter apple into submission?
04:38:46 <shapr> How so?
04:39:00 <Beelsebob> they're replacing my iBook G4 with a MacBook
04:39:08 <Beelsebob> logic board failed... twice
04:39:17 <shapr> wow
04:39:22 <Beelsebob> I bitched about the Sale and Supply of Goods and Services act
04:39:29 <Beelsebob> they held out for a week
04:39:34 <Beelsebob> and then got bored of me phoning
04:39:36 <inv2004> has heskell smth like option type in ocaml ? buildin I mean
04:39:51 <inv2004> data option a = Some a | None
04:40:04 <Beelsebob> inv2004: Maybe
04:40:09 <jethr0> data Option a = Some a | None
04:40:16 <jethr0> or Maybe of course
04:40:18 <Beelsebob> data Maybe a = Just a | Nothing is built in
04:40:30 <inv2004> is Maybe buildin ?
04:40:33 <Beelsebob> yes
04:40:35 <jethr0> yes
04:40:47 <inv2004> thx
04:40:56 <shapr> I always think that nothing is builtin to Haskell.
04:40:59 <Beelsebob> you might also be interested in Either
04:41:10 <shapr> Except the IO monad, everything can be re-implemented in a library, yeah?
04:41:13 <inv2004> whats Either ?
04:41:15 <Beelsebob> data Either a b = Left a | Right b
04:41:31 <inv2004> ok, don't need Either :)
04:41:36 <Beelsebob> shapr: I think so
04:41:50 <Beelsebob> maybe not Data.Typable
04:42:02 <shapr> Ok, good point.
04:42:10 <shapr> But I remember how free I felt when I first discovered that about Haskell.
04:42:26 <shapr> All the other languages I've used have so much of their definition hardcoded in the runtime.
04:42:39 <jethr0> and of course prelude being almost "naive" implementations is also nice
04:42:51 <shapr> Yeah
04:43:06 <shapr> Oh hey, did you guys hear my idea about tagging functions with laziness properties?
04:43:15 <shapr> I think you could do it like phantom types.
04:43:17 <Beelsebob> hmm?
04:43:27 <inv2004> Not in scope: data constructor `Maybe'
04:43:38 <shapr> Well, laziness bites people only because they don't keep in mind the laziness properties of every bit of code they use.
04:43:40 <jethr0> the constructors are "Just" and "Nothing"
04:43:45 <inv2004> ow
04:43:53 <inv2004> pardon :)
04:44:04 <Beelsebob> shapr: true
04:44:06 <shapr> So I was thinking that you could wrap functions in something that would describe their laziness.
04:44:20 <shapr> For example, length traverses the entire list.
04:44:21 <Beelsebob> hmm, that would be interesting for my debugger actually
04:44:35 <Beelsebob> because it's starting to ask questions like "should f be lazy in it's first argument"
04:44:36 <shapr> So you don't want to pass infinite datastructures to length.
04:44:54 <Beelsebob> hmm... it's hard to tag though
04:45:09 <shapr> Maybe automatically, but why not start manual?
04:45:10 <Beelsebob> for example... f x y = if x > 5 then length y else x
04:45:18 <swiert> shapr: have you considered a finer separation of data/codata?
04:45:25 <Beelsebob> that's strict in it's second argument iff x > 5
04:45:26 <shapr> swiert: Like what?
04:46:04 <swiert> shapr: data as must be finite, possibly strictly evaluated.
04:46:25 <swiert> shapr: and codata that is potentially infinite and evaluated non-strictly.
04:46:30 <shapr> I just realized that I'd like to wrap functions in arrow types (only for the static properties) and then sticking those arrows together would give you the correct lazy/strict properties for your code.
04:47:07 <inv2004> is it possible to call function recursively ? like in Kx fun:{:[0<x;x+_f[x-1];0]}, _f = fun
04:47:16 <shapr> Like IO a mean "it has an action" so why can't I have "Strict a" ?
04:47:38 <shapr> swiert: Sounds interesting
04:48:01 <Beelsebob> inv2004: huh? I don't get what your code is meant to do
04:48:43 <shapr> swiert: How would that apply to tagging code though?
04:49:19 <Beelsebob> shapr: the other problem is... it wouldn't be automatically checkable, because strictness analysis doesn't work in all cases
04:49:23 <swiert> shapr: so it's not something you can easily add to Haskell as a user. It's more of a language design issue.
04:49:46 <Beelsebob> also... tbh... people just need to think more
04:49:54 <Beelsebob> lazyness is easy when you get your brain round it
04:49:56 <inv2004> Beelsebob: _f - just means call the function in which it execute
04:50:00 <swiert> I've started to dislike laziness a bit. It causes too many problems occasionnally.
04:50:03 <shapr> Yeah, but laziness tags would let you find the problem quickly.
04:50:20 <inv2004> fun:{.... _f ... },  _f - calling fun
04:50:22 <shapr> swiert: I hear that a lot, but I think it's only because it's so hard to find a problem once you run into it.
04:50:34 <shapr> swiert: So the solution I see is to make those properties explicit somehow.
04:50:37 * int-e loves lazyness so much he applies it in all areas of life. *cough*
04:50:42 <shapr> and tagging code semes like the easiest approach.
04:50:59 <Beelsebob> inv2004: do you mean you just want to have a recursive function?
04:51:10 <shapr> btw, this comes from SyntaxNinja's question "what's the most important problem in Haskell today?"
04:51:10 * Beelsebob adores lazyness
04:51:13 <inv2004> Beelsebob: Y
04:51:15 <shapr> and I think it's laziness
04:51:35 <Beelsebob> inv2004: fac x = x * fac (x - 1)
04:51:45 <inv2004> Beelsebob: but without call by name inside the function
04:51:59 <jethr0> for certain lazyness makes finding leaks harder. but then again it's one of the most powerful abstraction devices i know of
04:52:01 <swiert> I think laziness is very useful at times.
04:52:10 <Beelsebob> inv2004: oh... you want it strict?
04:52:26 <inv2004> if I change fac name to fac2, I should rename fac inside function too
04:52:29 <swiert> The problem is it can make things so much more difficult to reason about your code, write debuggers, whatever.
04:52:34 * int-e would love to have a sublanguage in haskell that is strict and supports loops - much like working with the ST monad but with a more amenable syntax.
04:52:47 <inv2004> Beelsebob: ?
04:52:52 <Beelsebob> inv2004: then use a refactorer
04:52:54 <shapr> I think I'm going to write a Haskell parody of Heinlein called "The Language that was Too Lazy to Fail."
04:52:58 <Beelsebob> rather than manually changing names
04:53:06 <morans> heh
04:53:12 <inv2004> Beelsebob: why ? _f - is nice solution
04:53:24 <jethr0> swiert: yes, but it also let's you write down how to do things and let the compiler/runtime decide what part of that has to be executed. makes for far less if/then/else blocks
04:53:27 <inv2004> fax = x * _f (x - 1)
04:53:29 <Beelsebob> inv2004: not really - it doesn't tell me anything about what function it's calling
04:53:47 <Beelsebob> I have no logical idea what _f should do
04:53:48 <inv2004> fax = fac
04:53:53 <shapr> Anyway, back to PHP & Flash for me, no time to talk about this unless someone pays me ;-)
04:53:54 <Beelsebob> if I just read the right hand sie
04:53:55 <Beelsebob> side*
04:53:57 <swiert> jethr0: I know. I'm not saying that laziness is without its merits.
04:54:09 <inv2004> Beelsebob: it calls function in which it work
04:54:12 <swiert> I'm just not sure if it is the best way to go by default.
04:54:42 <Beelsebob> inv2004: yes... but then I have to look elsewhere to see that
04:54:45 <inv2004> _f in fac = calls fac, _f in fib calls fib
04:54:48 <jethr0> yes, that's debatable. but when it's optional, chances are that it's gonna be used too sparingly.
04:55:14 <inv2004> Beelsebob: you're always know there you work
04:55:20 <inv2004> function
04:55:25 <bolrod> > let fac 1 = 1 ; fac n = n * _f (n-1) in fac 6
04:55:26 <lambdabot>  Not in scope: `_f'
04:55:28 <Beelsebob> f x = exp where g x = _f -- what does _f call
04:55:37 <bolrod> :]
04:55:55 <jethr0> "<inv2004> Beelsebob: you're always know there you work; function" - parse error
04:56:03 <Beelsebob> lol
04:56:08 <inv2004> and its good to use it in labmdas \x -> x*_f (x-1)
04:56:10 <shapr> Hey, I do have a make question. I'm building .swf files from .hx files and then calling rsync. But right now it's happening once for each .hx file. How can I make rsync happen only after building every .hx file that needs it?
04:56:30 <bolrod> inv2004: it doesn't seem to work
04:56:32 <Beelsebob> inv2004: then don't use lambdas for that kind of function
04:56:38 <int-e> > let x x = x where x = 23 in x 42
04:56:39 <lambdabot>  23
04:56:39 <Beelsebob> name it something useful
04:56:41 <inv2004> Y, I know
04:57:06 <Beelsebob> hehe, thats horrific int-e 
04:57:09 <inv2004> I just think its a good syntax sugar in APL, ask for smth like this in haskell :)
04:57:10 <bolrod> _f does not work?
04:58:05 <bolrod> > (\x -> _f 0) 4
04:58:06 <lambdabot>  Not in scope: `_f'
04:58:13 <inv2004> :)))
04:58:34 <bolrod> (((:
04:59:46 <shapr> Aha, I just move the rsync rule to all: doh
05:00:24 <Beelsebob> tbh... I think it's pretty horrific to reserve a name for "the function scope"
05:00:38 <int-e> hmm. should   {main = return ()}  be a valid Haskell program? I think it should be; ghc rejects it. (the { and } are part of the program)
05:00:47 <Beelsebob> especially when it's not generalised to be able to get at any function scope
05:01:04 <bolrod> I don't think you put {} around your entire program
05:01:11 <bolrod> just in do {..}
05:01:13 <int-e> bolrod: it's just around the body
05:01:15 <bolrod> or possibly let {}
05:01:47 <int-e> bolrod: btw, ghc accepts   module Main where { main = return () }
05:02:01 <bolrod> yes
05:02:21 <bolrod> so without the module
05:02:26 <bolrod> why do you need the {}
05:02:47 <int-e> (relevant portion of the Haskell report: http://haskell.org/onlinereport/decls.html ... I have to admit that I don't know if the indentation rules interfer with that)
05:03:12 <eivuokko> int-e, it seem correct to me, reading report's grammar
05:03:40 <int-e> bolrod: just an old program that was written for compactness and obfuscation. the {} are for disabling the indentation mechanism.
05:04:09 <bolrod> ;o
05:05:25 <int-e> bolrod: I don't believe it's a serious issue, not even for automatically generated code.
05:06:40 <int-e> the program in question is this: http://pastebin.com/736902 (wear your peril-sensitive sunglasses)
05:16:13 <vincenz> int-e: peril or perl
05:16:19 <vincenz> o.O
05:16:28 <vincenz> int-e: where tf did this come from
05:16:57 <int-e> vincenz: can you guess what it is? :P
05:19:39 <int-e> vincenz: Anyway, it's my own code. I also have a readable version of the same code with meaningful identifiers and proper indentation. And it's actually quite old, from 2001.
05:22:24 <int-e> luckily I had not seen $ at the time or the code would be even worse.
05:51:29 <ski> that '_f' idea was really horrible ..
05:53:25 <ski> (it would invalidate the law :   (\x -> ..expression..) x  =  ..expression..   )
05:55:46 <ffranzosi> hi guys... sometimes when I have heavy applications to run using haskell I have to set RTS options in order to increase the stack size. But, by doing that I usually lose lots in efficiency, is it possible to set others RTS options in order to decrease that losing?
06:03:52 <dcoutts> ffranzosi, are you sure that's due to increasing the stack size. It seems unlikely.
06:04:12 <dcoutts> just increasing the stack limit shouldn't make your program run slower
06:04:47 <dcoutts> you can experiment with the other RTS options of course, see the ghc manual for an explanation of what they do
06:04:49 <ffranzosi> dcoutts: of course it is not only because of increasing the stack limit
06:05:35 <ffranzosi> dcoutts: but when I run bigger instances it takes more than the expected time
06:06:00 <dcoutts> the GC overhead is not linear
06:06:30 <dcoutts> you can increase the allocation area, some find that helps
06:06:37 <ffranzosi> dcoutts: ok
06:06:44 <dcoutts> mostly by reducing the frequency of GCs (I think)
06:07:02 <ffranzosi> dcoutts: thanks for the advice
06:07:07 <dcoutts> ffranzosi, of course if you can make your program allocate less then that will help greatly
06:07:41 <dcoutts> ffranzosi, you might find that space profiling helps to identify which bits of your program are doing the most allocation
06:08:13 <ffranzosi> dcoutts: hum... I'll try it now
06:08:30 <dcoutts> dons, so the fusion for fold . map slows down on both the strict and lazy bytestrings
06:08:36 <SamB_XP> GC overhead is crudely O(n) in live data, right?
06:08:52 <dcoutts> dons, and by the same amount, the lazy is no different from the strict
06:08:58 * SamB_XP pretends that GHC doesn't use a generational collector, for the moment
06:09:03 <int-e> SamB: per garbage collection, yes
06:09:17 <SamB_XP> int-e: yes, thats what I meant ;-)
06:09:32 <dcoutts> dons, I reckon it's because the tuple produced by fuseEFL is not being eliminated so we're doing lots of allocation
06:09:32 <int-e> SamB: and thus O(n/m) where m is the total memory available. Very crudely.
06:09:59 <SamB_XP> is that an integral?
06:10:13 <dcoutts> dons, that's not just a complete guess, I've looked at the core files and in one we have tuples consistently where the other does not.
06:10:23 <int-e> SamB: hmm. sort of, yes.
06:10:25 <dcoutts> dons, eg (NoAl, Int) vs just Int
06:10:58 <dcoutts> dons, I don't know how we expect ghc to optimise (NoAl, Int) to just Int
06:11:06 <int-e> SamB: differential actually. O(n/m dt) ... ah, this gets very messy and is stretching the notation a lot. I'll stop.
06:11:14 <SamB_XP> hehe
06:12:52 <SamB> I've written types for most everything in an XPCOM type library file :-)
06:12:59 <SamB> I may have left out a constructor or two...
06:13:34 <SamB> Now I'll just need to write my own typeclass for binary parsing...
06:14:15 <SamB> ...implement it for all the types I've made...
06:16:21 <SamB> ...and write code to generate Haskell and C++ to bind interfaces...
06:16:54 <eivuokko> SamB, Interoperability's fun, ehÂ´? :)
06:17:37 <SamB> well, I think this way is more fun than trying to hack HaskellDirect to do it, when I don't know what HaskellDirect is *supposed* to do in the first place!
06:17:57 <SamB> nor do I know what XPIDL means
06:18:13 <eivuokko> XP Interface Definition Language?
06:18:27 <SamB> no, I mean I don't necessarily understand it.
06:18:29 <ffranzosi> dcoutts: increasing the GC memory really kicks ass!!!
06:18:37 <dcoutts> ffranzosi, great
06:18:40 <davidhouse> okay, haskellers. what's the best way of replacing a sublist within a given list with another sublist?
06:18:44 <dcoutts> dons, hah! got it!
06:18:54 <dcoutts> dons, fuse now runs faster than unfused!
06:19:00 <davidhouse> e.g. replace "%%%" "world" "hello %%%" -> "hello world"
06:19:00 <SamB> besides, parsing binary is more fun than parsing text with Happy and without Alex
06:19:12 <dcoutts> dons, the trick was to add more strictness to fuseEFL
06:19:16 <eivuokko> SamB, Hehe.
06:19:20 <mux> could anyone in here see if there's a way to optimize this code further? http://mu.org/~mux/Main.hs
06:19:54 <dcoutts> dons, so instead of using (a,b) to pair the two accumulating values, I use StrictPair a b and then it just works!
06:20:24 <SamB> if I had Haskell on windows, maybe I would try the HaskellDirect approach, since then I'd have a clue what it is supposed to do ;-)
06:23:04 <davidhouse> SamB, you don't have windows?
06:23:44 <davidhouse> @where JRegex
06:23:45 <lambdabot> I know nothing about jregex.
06:24:06 <davidhouse> @where+ JRegex http://jregex.sourceforge.net/
06:24:07 <lambdabot> Done.
06:24:10 <davidhouse> @where JRegex
06:24:10 <lambdabot> http://jregex.sourceforge.net/
06:24:17 <davidhouse> oh, wait.
06:24:23 <eivuokko> Hmmm
06:24:27 <davidhouse> what's the name of the haskell one?
06:24:42 <davidhouse> it has the same name :|
06:24:55 <davidhouse> @where+ JRegex http://repetae.net/john/computer/haskell/JRegex/
06:24:55 <lambdabot> Done.
06:26:04 <davidhouse> is '%' a special character in posix (i.e. egrep) regexes?
06:26:51 <Igloo> no
06:27:36 <davidhouse> great.
06:29:16 <dcoutts> JaffaCake, I've got an interestign case for GHC's strictness analyser if you're interested. Adding (or infering) strictness in this case makes the code run 44 times faster!
06:29:33 <mux> mmm, 44 times faster :)
06:29:54 <dcoutts> JaffaCake, it may be that the original genuinely is too lazy and there's nothing the strictness analyser could do
06:30:21 <dcoutts> all it needed was chaning one (a,b) to StrictPair a b and then ghc did the rest.
06:30:34 <mux> is StrictPair a standard type?
06:30:38 <dcoutts> nope
06:30:43 <dcoutts> data StrictPair a b = StrictPair {-# UNPACK #-} !a {-# UNPACK #-} !b
06:30:46 <mux> ok
06:30:59 <mux> what does the {-# UNPACK #-} do?
06:31:11 <davidhouse> hmm, you could use :,: for prettier syntax.
06:31:13 <dcoutts> I don't know if the unpack was required, I just threw it in for good measure :-)
06:31:24 <mux> heh
06:31:40 <dcoutts> I'll try without, I think it's just the strictness annotations that did it
06:32:18 <eivuokko> I think it is required unless you have -funbox-strict-fields, but when they are unpacked they are automatically strict. (in ghc)
06:32:24 <dcoutts> JaffaCake, this example is from the array fusion code in Data.ByteString, which is now in the base package.
06:32:35 <eivuokko> Oh, for that fusion stuff.  Dunno.
06:32:37 <mux> -funbox-strict-fields is in the GHC option for FPS
06:32:47 <mux> options
06:33:12 <dons> dcoutts: ah! we need to use strict pairs then
06:33:24 <dcoutts> hia dons :-)
06:33:26 <dons> there's a :*: strict pairs type from the ndp branch we can adopt
06:33:32 <dcoutts> @localtime dons 
06:33:34 <lambdabot> Local time for dons is Thu May 25 23:27:08 2006
06:33:39 <dons> we formerly didn't need it, I thought. but looks like we do now
06:33:44 <dcoutts> (oh, not as late as I thought)
06:33:59 <dcoutts> dons, I've sent a couple emails with more details.
06:34:13 <dons> if you look at Data/Array/Parallel/Base/Hyperstrict.hs in the ndp branch
06:34:40 <dons> there's data (:*:) a b = !a :*: !b
06:34:46 <dons> we just need that then, it seems ?
06:34:53 * mux nods
06:34:58 <mux> unless the UNPACK really do help
06:35:08 <dcoutts> dons, seems so, and only for fuseEFL
06:35:29 <dons> yep. makes sense. they write all their loop stuff in terms of strict pairs. we should probably do so too.
06:35:39 <dcoutts> dons, aye
06:36:23 <mux> mmm, would it make sense to have a State/StateT monad where the pairs used are strict pairs?
06:36:30 <dons> excellent. i see your mail, this seems to have squashed the leak
06:36:59 <dcoutts> dons, I think this fusion stuff should move into a semi-public ByteString.Base module
06:37:18 <dcoutts> dons, so that the main interfaces can be less cluttered by it
06:37:28 <dons> Data.ByteString.Fusion ?
06:37:37 <dons> (following from the ndp branch, again)
06:37:46 <dcoutts> I'd also be tempted to put some of the less savoury direct access stuff there
06:37:59 <dcoutts> eg the actual ByteString representation
06:38:07 <dons> yeah, that's reasonable. a la unsafeAt 
06:38:10 <dons> ah, yes. that would be reasonable too.
06:38:14 <dons> so maybe .Base
06:38:16 <dcoutts> and only export it abstractly from the main module
06:38:39 <dcoutts> things like packAddress, unsafeFinalize etc
06:39:11 <dons> if you'd like to proceed with this, you have my blessing
06:39:13 <dcoutts> so people writing extensions to ByteString (eg gziping) can import Base to get at all the nasty bits
06:39:19 <dcoutts> ok, I'll have a go
06:39:21 <dons> yep. 
06:39:44 <davidhouse> @hoogle lookup
06:39:44 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:39:45 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:39:45 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
06:39:52 <dcoutts> we could further partition the fusion later if we think that helps
06:40:30 <dons> ok.
06:40:41 <dcoutts> dons, so I'd put the low level things like generate, create etc in Base, but I'd be inclined to leave unsafeHead etc in the main one
06:41:08 <dcoutts> dons, btw, what do you think about the loopWrapper stuff?
06:41:09 <dons> then it might also make sense to move .Internal to .Base, since it doesn't contain much
06:41:17 <dcoutts> right, ok
06:41:25 <dons> i think avoiding reallocs is a good idea, and may be a real win.
06:41:32 <dons> it would be good to see the numbers.
06:41:36 <dcoutts> aye
06:41:56 <dcoutts> we'd need a down loop first
06:42:01 <dons> yeah
06:42:20 <dons> but then we get reverse, and a bunch of fuseable *R ops.
06:42:24 <dons> so seems worth it.
06:42:31 <xerox> Geez, 300 emails on the Summer-Accepted list.
06:42:35 <xerox> Ohayou.
06:44:14 <davidhouse> @hoogle filterM
06:44:14 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
06:44:15 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
06:44:15 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
06:44:20 <davidhouse> @hoogle doesFileExist
06:44:20 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
06:46:01 <dcoutts> dons, so the .Lazy version of fuse.hs is running in exactly the same time now.
06:46:20 <dons> excellent. 
06:47:00 <dcoutts> though there is a slight and repeatable variation in running times, perhaps alignment or something
06:47:18 <dcoutts> it flicks between two different times on different runs
06:47:31 <dons> or GC.
06:47:43 <dcoutts> that should be deterministic
06:48:04 <dcoutts> but then it should all be deterministic :-)
06:48:48 <dcoutts> oh, actually, it's not so big a jump if one only looks at user running time
06:48:51 <dcoutts> ie ignoring real & sys
06:49:54 <dons> oh, and non-deterministic GC sounds so much fun ;)
06:51:16 <dcoutts> heh
06:52:05 <dons> ok, so where do we go now? add in the strict pairs. then work on backwards loops, and then wrapper/loop separation?
06:52:21 <dcoutts> right
06:52:42 <dcoutts> I'm doing the split into Base and adding strict pairs for fuseEFL
06:52:55 <dons> and we can perhaps look at fusing some more things on lazy lists, like length/foldl'
06:53:14 <dons> (so that length . map wouldn't need to allocate either)
06:53:19 <dcoutts> right
06:53:32 <dons> or length . filter, i mean. since that's more common by far
06:53:41 <dcoutts> yes indeed
06:54:36 <davidhouse> is 'setCurrentDirectory ".."' portable?
06:57:52 <xerox> This `fuse' stuff is the framework of fusions done by RULES?
06:59:21 <dcoutts> xerox, yes
06:59:32 <dons> yep. array fusion, as described in "Functional Array Fusion", http://www.cse.unsw.edu.au/~chak/papers/CK01.html
06:59:36 <ndm> davidhouse: use Yhc filepath, then you can ask for the parent directory
06:59:44 <ndm> but in reality, yes, pretty portable
06:59:56 <dcoutts> xerox, ghc already does list fusion by RULES, this uses RULES for array fusion
07:00:09 <xerox> Ah, gotcha.
07:01:05 <dcoutts> xerox, and for the lazy bytestrings we're also doing array fusion, which is a new (but obvious) extension
07:01:06 <davidhouse> ndm, yeah, i gave up on setCurrentDirectory hackery and am just using your FilePath lib :)
07:01:35 <xerox> dcoutts - makes sense, yes (:  Good work!
07:03:41 <ndm> davidhouse: neat :)
07:03:48 <ndm> patches welcome
07:04:07 <davidhouse> hey, i already cabalised that.
07:04:08 <ndm> i offered Lemmih to merge our System.FilePath's, but no response yet
07:04:20 <ndm> yes, thanks for that
07:04:53 <dons> dcoutts: there's a missing INLINE [1] on fuseEFL, if you want to add it (just noticed a patch for this in the ndp branch)
07:05:12 <davidhouse> hehe :) it'll help me actually as i can use cabal's dependency management to automagically require System.FilePath
07:05:38 <dcoutts> dons, do you think that'd make the difference?
07:06:16 <dons> it must be that fuseEFL occasionally gets inlined early. this would prevent that.
07:06:16 <dcoutts> dons, eg to the StrictPair issue
07:06:21 <dcoutts> ah ok
07:06:40 <dons> no, just noticed that Roman added a patch to this in the ndp code, so we probably shouuld too
07:06:46 <dcoutts> yep
07:07:10 <dcoutts> hia sjanssen_ 
07:07:21 <sjanssen_> hello dcoutts
07:07:45 <dons> morning sjanssen_ 
07:08:13 <sjanssen_> good morning dons, writing you an email right now
07:08:18 <dons> cool :)
07:08:50 <davidhouse> @hoogle maybeToList
07:08:50 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
07:10:05 <dons> dcoutts: did you see the fun games we play with the ModeledBy class instances now? :)
07:10:30 <dcoutts> dons, I say the new NaturalTransformation class
07:10:31 <dons> I was quite proud of this: instance (NatTrans m n, Model a b) => Model (m a) (n b) where abs x = fmap abs (eta x)  :)
07:10:34 <dcoutts> say/saw
07:10:44 <dcoutts> yeah, nice
07:10:50 <dons> since it solves almost all the funny type cases
07:10:59 <dcoutts> yes, that's great
07:11:08 <dcoutts> category theory strikes again!
07:11:21 <dons> ?karma+ CategoryTheory
07:11:22 <lambdabot> CategoryTheory's karma raised to 1.
07:12:21 <dons> ok, bed time. night guys!
07:12:32 <sjanssen_> goodnight dons
07:14:40 * davidhouse solves #math's problems with haskell.
07:14:46 <davidhouse> i love having a lambdabot in #haskell
07:14:56 <davidhouse> err, #math
07:19:16 <kolmodin> waern: hey!
07:21:41 <pejo> Does anyone in here happen to know why I would prefer having GMP as a framework in MacOS X instead of an ordinary .dylib?
07:22:33 <pejo> (And is there something corresponding to DYLD_LIBRARY_PATH for frameworks?)
07:29:20 <davidhouse> huh. should the following not work?
07:29:23 <davidhouse> data Step'     = forall s. Step s => S { unHide :: s }
07:31:31 <davidhouse> "Can't combine named fields with locally-quantified type variables or context
07:33:33 <swiert_> davidhouse: why not just data Step' = forall s . Step s  => S s ?
07:34:15 <davidhouse> records are handy.
07:34:25 <davidhouse> it gives me an accessor function.
07:34:50 <davidhouse> but it seems to be complaining about it, although i've no idea why.
07:34:57 <davidhouse> oh, wait
07:35:16 <davidhouse> the type of unHide would be exists s. s -> Step, right?
07:35:22 <davidhouse> and this is too much for the type system.
07:35:37 <swiert_> almost.
07:36:09 <davidhouse> almost?
07:36:11 <swiert_> unhide :: exists s . Step s => Step' -> s
07:36:47 <swiert_> unhide breaks up a Step into the s. Not the other way round.
07:37:08 <davidhouse> sorry, yes.
07:37:17 <davidhouse> well the class constraint is immaterial here.
07:37:31 <davidhouse> so unHide :: exists s. Step' -> s
07:38:05 <davidhouse> adding the constraint gives you extra information (it lets you know the type is an instance of Step), but it doesn't do any constraining.
07:38:09 <swiert_> yes. I'm never quite sure what happens to the "Step =>" bit.
07:42:01 <davidhouse> oh, great, pattern matching doesn't work on existentials either.
07:42:07 <davidhouse> how am i meant to get the value out?
07:43:38 <sjanssen_> if I wanted an account on darcs.haskell.org, who would I ask?
07:45:12 <swiert_> davidhouse: you can't. That's what existentially quantifying does.
07:46:13 <davidhouse> oh, for extensible datatypes!
07:46:17 * davidhouse has a long hard think
07:46:48 <davidhouse> i found a paper which _perfectly_ solves my problem, but there's no implementation :(
07:47:30 <eivuokko> Heh
07:47:47 <waern> kolmodin, hi!
07:47:59 <kolmodin> waern: grattis till SoC!
07:48:11 <waern> kolmodin, thanks :)
07:48:19 <kolmodin> how's code? :)
07:48:37 <waern> kolmodin, well.. It's going quite well.. 
07:48:43 <kolmodin> nice to hear
07:48:53 <waern> kolmodin, but my computer broke down so I'm sitting in NC
07:49:05 <kolmodin> still haven't fixed it, right
07:49:17 <ski> davidhouse : istr audreyt getting existential records implemented recently in ghc (though maybe it was only with GADT syntax ?)
07:49:28 <ski> davidhouse : pattern-matching should work
07:49:29 <waern> kolmodin, yep, but I've now ordered a macbook
07:49:39 <kolmodin> waern: really? nice :)
07:50:01 <davidhouse> ski, what extensions do i need?
07:50:21 <davidhouse> with -fglasgow-exts i get "My brain just exploded. I can't handle pattern bindings for existentially-quantified constructors."
07:50:30 <waern> kolmodin, how's your code?
07:50:33 <ski> davidhouse : http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
07:51:11 <kolmodin> waern: slow... I've got an exam on saturday
07:51:14 <sjanssen_> waern: I'm ordering a MacBook with SoC money too!
07:51:45 <davidhouse> hmm... requiring GHC 6.5 is too stringent. i want my program to be portable-ish.
07:52:37 <waern> sjanssen_, great! That means we will more people working on getting GHC to work ;)
07:52:49 <waern> sjanssen, what's your project?
07:53:07 <kolmodin> GHC doesn't work on MacBook?
07:53:18 <swiert_> davidhouse: so what is the problem?
07:53:32 <kolmodin> waern: how far have you come? updated the lexer, parser and what more?
07:53:38 <davidhouse> swiert_, i described it in an email to the haskell mailing list. hold up
07:53:39 <sjanssen_> waern: some Data.ByteString hacking: Unicode support, parsec for packed strings, some other stuff
07:53:51 <waern> kolmodin, I think it does but it's not so straightforward.. I don't know actually, I just skimmed bringerts page about it
07:53:58 <davidhouse> waern: you're the guy working on haddock/GHC API?
07:54:04 <waern> kolmodin, only the lexer so far
07:54:10 <kolmodin> waern: ok. ok.
07:54:28 <waern> sjanssen_, ah that one, ok
07:54:29 <ski> davidhouse : also see the link from that hawiki page .. (September 28-30 on http://use.perl.org/journal.pl?op=display&uid=1505&start=20 might also be interesting)
07:54:50 <waern> davidhouse, yep, that's me :)
07:55:09 <davidhouse> swiert_: http://www.haskell.org//pipermail/haskell-cafe/2006-May/015729.html
07:55:20 <ski> davidhouse : pattern-matching should work prior to 6.5, i think
07:55:30 <davidhouse> waern: cool! i want to start hacking on haddock. i'll warn you, the source is pretty ugly in places ;)
07:55:44 <davidhouse> i'm in the process of cleaning up the (oversized) Main.hs
07:55:50 <waern> davidhouse, I know, I've looked at it before :)
07:56:46 <davidhouse> ski, where am i looking on that page?
07:57:04 <ndm> davidhouse: just as long as you don't break hoogle output!
07:57:12 <ski> davidhouse : which page ?
07:57:13 <kolmodin> I hacked haddock a little while doing our D3-project at school... it really is (was?) ugly in places.. :D
07:57:34 <ndm> waern, that goes for you too, don't break hoogle output! (if you want help with the hoogle side, let me know, since i wrote that bit)
07:57:50 <davidhouse> ndm, i'm only hacking the frontend at the moment.
07:58:03 <davidhouse> ski, that use.perl.org one
07:58:35 <waern> ndm, I will try not to :P
07:58:51 <ndm> waern, thanks :), a nice haddock would be appreciated
08:00:20 <ski> davidhouse : that's autrijus' (audreyts) journal .. that's just some context for how ghc got support for existential records at all .. but since you want pre-6.5 you'll have to settle with pattern-matching, i think
08:00:34 * ski looks at the haskell-cafe post
08:01:27 <davidhouse> pattern matching is fine. it just doesn't work ;)
08:02:19 <ski> can you show what error you got & the code that gives it ?
08:04:49 <davidhouse> ski, getStep :: Program -> StepNum -> Step'
08:04:54 <davidhouse> argh, oops
08:04:59 <davidhouse> http://rafb.net/paste/results/wVKPpl11.html
08:05:09 * davidhouse hates having two clipboards
08:10:05 <davidhouse> also handle is polymorphic, that might be relevant.
08:10:44 <davidhouse> http://rafb.net/paste/results/m3NS2l54.html
08:11:25 <malcolm> davidhouse: general wisdom seems to be to replace a let binding by a case binding in this situation
08:11:31 <ski> try using a case (or a new local, pattern-matching function, if you prefer that) ?
08:11:32 <skd> Is it possible to create something like [f], where f works is a parameter, and [] a function name?
08:11:57 <ski> skd : no
08:12:20 <skd> Thank you, skd.
08:12:21 <skd> ski.
08:13:37 <ski> davidhouse : the call to 'handle' should not be a problem, i think
08:17:00 <kosmikus> no, it's just the use of let rather than case
08:18:27 <davidhouse> what's the difference between them? strictness?
08:21:46 <kosmikus> in general, yes. in this case it's an restriction in the implementation of the "existential types" extension.
08:22:11 <kosmikus> there has been some discussion in the past if lifting this restriction would be without problems or not ...
08:22:14 <mathewm> Are there Haskell jobs?
08:22:58 <ski> kosmikus : hm, what exactly is the restriction ?
08:23:37 <davidhouse> the 'showsPrec' nonsense in Show is really annoying.
08:25:20 <kosmikus> ski: that you cannot match on existential types in a pattern binding ...
08:27:00 <ski> hm, i was about to say i just did that, but noticed that i did a 'S x <- ...' instead of a let
08:27:13 <ski> though, hugs manages it just fine
08:27:31 <kosmikus> hugs doesn't have this restriction
08:27:50 <kosmikus> there's a thread on one of the mailing lists from not long ago
08:27:59 <kosmikus> but I have to go, you'll have to look it up yourself ...
08:28:00 * dcoutts darcs sends dons another pile of fps fusion patches
08:28:06 <sjanssen_> davidhouse: showsPrec is very useful!
08:28:09 <ski> davidhouse : you could consider using 'S step <- return $ prog `getStep` loc'
08:28:27 <skd> Can I define a prefix operator?
08:28:34 <ski> skd : no
08:28:37 <ski> hi esap
08:28:38 <davidhouse> skd, yes
08:28:44 <esap> ski: hi!
08:28:45 <davidhouse> > let (+) = succ in (+) 3
08:28:46 <lambdabot>  4
08:28:54 <dcoutts> davidhouse, that's infix
08:28:56 <ski> that's not an operator
08:29:10 <davidhouse> > let (\/) = or in (\/) [ True, True, False, True ]
08:29:11 <lambdabot>  True
08:29:17 <dcoutts> it is an operator, just infix
08:29:17 <ski> '+' is an operator, '(+)' is not
08:29:30 <dcoutts> bah
08:29:30 <davidhouse> it's all semantics.
08:29:32 <skd> I want to create an unary operator
08:29:43 <davidhouse> oh, then very easily yes.
08:29:45 <skd> Just like a function, but with difference precdence.
08:29:45 <dcoutts> skd, sorry, not possible in Haskell
08:29:50 <skd> Buu.
08:29:55 <skd> Thanks.
08:30:15 <davidhouse> skd, if it's binary, then just surround your normal infix operator in brackets and it becomes prefix.
08:30:25 <davidhouse> you can't define a prefix operator w/o brackets, but that's not a big limitation
08:30:29 <davidhouse> > (+) 2 3
08:30:30 <basti_> what does an unary infix operator do?
08:30:30 <lambdabot>  5
08:30:38 <basti_> :D
08:31:06 <dcoutts> davidhouse, you can:
08:31:22 <dcoutts> > let a \/ b = or a b in (\/) [ True, True, False, True ]
08:31:22 <lambdabot>  Couldn't match `Bool' against `t -> t1'
08:31:36 <dcoutts> hmm
08:31:36 <davidhouse> s/define/use
08:31:49 <davidhouse> or is unary, dcoutts 
08:31:54 <skd> f . (w (h . h)) . g, I want it to become f . ! (h . h) . g
08:32:06 <skd> f,g,h,w are functions
08:32:16 <ski> f . w (h . h) . g
08:32:17 <davidhouse> f . (!) (h . h) . g is possible
08:32:37 <ski> skd : that paren pair i removed was not needed
08:33:05 <sjanssen_> davidhouse: you can't give (!) special precedence, so there's no advantage to a plain old function
08:33:10 <davidhouse> goodness. it works. my complicated type hackery actually sneaks past the typechecker! :D
08:33:13 <davidhouse> sjanssen_: readability
08:33:15 <sjanssen_> s/to/over
08:33:33 <skd> Thank you very much.
08:33:37 * skd is happy
08:33:44 <davidhouse> i'm guessing he wants to change w -> (!) for readability purposes
08:43:35 <mathewm> anyone know if you can bootstrap GHC with hugs?
08:43:46 <Lemmih> You can't.
08:44:11 <mathewm> :(
08:44:28 <davidhouse> why would you want to?
08:45:05 <mathewm> Oh - I hate installing binary distributions
08:45:26 <sjanssen_> Lemmih: I've seen that you have an account on darcs.haskell.org, do you know who I might ask to get one myself?  I'd like a place to post my work for Summer of Code.
08:45:37 <davidhouse> mathewm: you'll hate building GHC even more :)
08:45:48 <mathewm> uhoh :(
08:45:55 <mathewm> davidhouse: why?
08:45:58 <davidhouse> just install a binary and be done with it.
08:46:11 <davidhouse> mathewm: if you don't already have GHC, building it is a nightmare.
08:46:19 <mathewm> davidhouse: I would like to learn a bit about the rts and compiler internals...
08:46:23 <Taldor> why does this 'combination a b | a > 0 = div (fac a) ((fac b) * (fac (a - b)))' work, but not when I replace the 0 by b?
08:46:29 <davidhouse> (i've never actually done it personally, but it's got a bad reputation)
08:46:54 <davidhouse> mathewm: haskell.org/ghc/docs/latest/html has a building guide
08:47:40 <davidhouse> Taldor, it should; pastebin the error you're getting
08:48:23 <Taldor> what's the pastebin & how do I use it?
08:48:38 <davidhouse> @where paste
08:48:38 <lambdabot> http://paste.lisp.org/new/haskell
08:48:54 <davidhouse> paste the error you're getting in there, fill in some other details, and hit "Submit".
08:53:51 <skd> Is there an operator like f(f(..f(x)..)) = f^k(x) ?
08:54:05 <davidhouse> nope, but you could make one.
08:54:25 <davidhouse> tip: fold and replicate.
08:54:42 <integral> @type iterate
08:54:43 <lambdabot> forall a. (a -> a) -> a -> [a]
08:54:51 <davidhouse> yeah, or that.
08:54:56 <integral> !! and iterate :)
08:55:59 <skd> I was thinking of do it recursively, (^) f 0 = id, (^) f (n+1) = (f n) . f
08:56:35 <davidhouse> sure, that would work too. it'd end up being equivalent to my method.
08:56:58 <davidhouse> oh, but (n+1) isn't a valid pattern
08:57:04 <davidhouse> as (+) isn't a constructor.
08:57:17 <mauke> o rly?
08:57:26 <integral> no, special exception.  which some hate.
08:57:35 <sjanssen_> ewwww, n + k
08:57:40 <davidhouse> but f ^ 0 = id; f ^ n = f . (f ^ n - 1)
08:57:55 <davidhouse> > let f (n+1) = n in f 4
08:57:56 <lambdabot>  3
08:58:02 <davidhouse> wow. i never knew that.
08:58:07 <davidhouse> disregard everything i said :)
08:58:21 <davidhouse> > let f (n-1) = n in f 4
08:58:21 <lambdabot>  Parse error in pattern
08:58:22 <sjanssen_> @type \f n -> foldr (.) id $ replicate n f
08:58:23 <lambdabot> forall a.
08:58:23 <lambdabot>               (a -> a) -> Int -> a -> a
08:58:38 <sjanssen_> @pl \f n -> foldr (.) id $ replicate n f
08:58:39 <lambdabot> (foldr (.) id .) . flip replicate
08:59:00 <davidhouse> sjanssen_: right, that's my method.
08:59:12 <davidhouse> @type \f n -> iterate f !! n
08:59:13 <lambdabot>   Couldn't match `[a]' against `t -> t1'
08:59:13 <lambdabot>   Expected type: [a]
08:59:25 <davidhouse> @type \f n -> (iterate f) !! n
08:59:26 <lambdabot>   Couldn't match `[a]' against `t -> t1'
08:59:26 <lambdabot>   Expected type: [a]
08:59:36 <davidhouse> huh.
08:59:38 <sjanssen_> davidhouse: it's likely to be slightly quicker than iterate (at least on GHC)
08:59:38 <davidhouse> @type iterate
08:59:39 <lambdabot> forall a. (a -> a) -> a -> [a]
08:59:45 <davidhouse> @type !!
08:59:46 <lambdabot> parse error on input `!!'
08:59:54 <lisppaste2> Taldor pasted "Why does just one version work?" at http://paste.lisp.org/display/20418
08:59:57 <davidhouse> oh, of course.
09:00:09 <davidhouse> @type \f n x -> iterate f n x !! n
09:00:10 <lambdabot>   Couldn't match `[a]' against `t -> t1'
09:00:10 <lambdabot>   Expected type: [a]
09:00:16 <davidhouse> @type \f n x -> iterate f x !! n
09:00:17 <lambdabot> forall a. (a -> a) -> Int -> a -> a
09:00:21 <davidhouse> :) finally.
09:00:31 <davidhouse> and !! should be polymorphic.
09:00:45 <sjanssen_> @hoogle replicate
09:00:46 <lambdabot> Prelude.replicate :: Int -> a -> [a]
09:00:46 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
09:00:46 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
09:00:55 <sjanssen_> bah, no genericReplicate?
09:00:57 <skd> What operator can I use? I think ^ is already taken
09:01:03 <davidhouse> ^^?
09:01:08 <sjanssen_> davidhouse: taken also
09:01:09 <skd> Ok, it looks fine.
09:01:12 <skd> Grr.
09:01:13 <davidhouse> @type (^^)
09:01:14 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
09:01:22 <davidhouse> @type (^^^)
09:01:23 <lambdabot> Not in scope: `^^^'
09:01:25 <davidhouse> :)
09:01:31 <skd> @type (^!)
09:01:32 <lambdabot> Not in scope: `^!'
09:01:38 <sjanssen_> skd: ^. maybe, looks like an exponent and composition smushed together 
09:01:49 <skd> Uhm, nice.
09:01:52 <skd> @type (^.)
09:01:53 <lambdabot> Not in scope: `^.'
09:02:05 <davidhouse> Taldor: that's only a warning, you could ignore it. but it's because you could provide another guard for the cases where a < b.
09:02:40 <davidhouse> e.g. combination a b | a > b = ...; | otherwise = error "First parameter needs to be > second parameter"
09:03:36 <tromp> stupid question: how to compile a module not called Main?
09:03:37 <Taldor> but why does't it complain then in the other case? it could be that 0 > a
09:04:05 <davidhouse> not sure.
09:04:12 <davidhouse> tromp, --main-is
09:04:46 <tromp> ghc-6.4.1: unrecognised flags: --main-is
09:05:21 <davidhouse> sorry, -main-is
09:06:37 <tromp> Main.c: undefined reference to `__stginit_ZCMain'
09:06:45 <tromp> i thought there was an easier way
09:06:53 <davidhouse> tromp, rm -rf *.o *.hi then do it again
09:07:08 <davidhouse> -main-is is the option you want. you've just screwed up your build env.
09:07:20 <Taldor> I was wrong, the warning is given when I run the program
09:07:22 <tromp> ok, thanks
09:07:29 <davidhouse> all right, Cabal question. In order to compile the Main.hs for my program, you first need to compile BuildMain.hs and run it. this is easy with a Makefile, can Cabal do it?
09:08:25 <eivuokko> Not without lot of prodding in Setup-script
09:09:03 <davidhouse> :(
09:09:07 <eivuokko> Well, dunno how much really, need to hook buildstep and run it yourself
09:09:32 <Taldor> I fixed it, I fotgot an exeption
09:10:20 <eivuokko> davidhouse, I think you could do it somehow like this: hook buildstep, take buildinfo and replace executable with BuildMain, run default hook with that info, then run your exec, then run defaultbuild with original buildinfo.
09:10:24 <Taldor> is it safe to enable glasgow-extensions?
09:10:41 <eivuokko> For most meanings of safe, yes.
09:11:11 <eivuokko> It might make your program unportable to other compilers is probably the biggest drawback.
09:12:09 <Taldor> I'm just experimenting, so that's not an issue
09:13:05 <skd> Can't I do an operator with higher precedence than .?
09:13:58 <eivuokko> skd, Nope, (.) has highest possible priority, 9.
09:14:01 <int-e> no.
09:14:12 <int-e> err, what eivuokko said.
09:15:36 <patron_> referse xs = super (\(a:as) -> as ++ a) (length xs) xs
09:15:49 <patron_> can someone tell why this is not working?
09:15:55 <davidhouse> @type (++)
09:15:56 <lambdabot> forall a. [a] -> [a] -> [a]
09:16:07 <davidhouse> ++ wants two lists, you've given it an element of a list and a list
09:16:16 <davidhouse> try \(a:as) -> as ++ [a]
09:16:26 <patron_> :)
09:16:31 <patron_> obvious error
09:16:34 <patron_> thanks
09:34:05 <MarcWeber> Hi when trying to install any pachage I get the message  Failed to load interface for `Prelude':
09:34:28 <MarcWeber> What might have gone wrong? Do I have to reinstall ghc?
09:36:35 <davidhouse> argh. where's ihope when you need him.
09:36:37 <eivuokko> MarcWeber, You might have corrupted packageconfig.  On saving it, ghc-pkg makes a backup of it, you could try restoring that.
09:44:59 <olegm> hi folks, not sure if it is the right place to ask such question. How is it possilbe that the following program doesn't compile:
09:45:02 <olegm> data AnyValue = forall a. AnyValue a
09:45:04 <olegm> test = AnyValue show
09:45:26 <olegm> GHC 6.4.1 with and withou monomorphism restriction
09:45:39 <ibid> with -fglasgow-exts?
09:45:43 <olegm> jep
09:45:52 <ibid> what does it say?
09:46:12 <olegm> Test.hs:2:16:
09:46:12 <olegm>     Ambiguous type variable `a' in the constraint:
09:46:12 <olegm>       `Show a' arising from use of `show' at Test.hs:2:16-19
09:46:12 <olegm>     Probable fix: add a type signature that fixes these type variable(s)
09:46:57 <ibid> that sounds like it's telling you what the problem is ;)
09:47:15 <ibid> it doesn't know which show should be put in AnyValue
09:47:38 <olegm> hmm :)
09:48:09 <ibid> it's analoguous to the dreaded "show . read" problem
09:50:40 <davidhouse> i want to implement "verbose output" in my algorithm, that prints to stdout some state at each iteration.
09:50:53 <davidhouse> what would be a better way of doing this, unsafePerformIO or Writer?
09:52:04 <eivuokko> When in doubt, don't pick unsafe ;)
09:52:06 <davidhouse> Writer adds more to the resturn result which is a little annoying
09:52:13 <dcoutts_> hmm, which is better "unsafeFoo" or other...
09:52:16 <ibid> what eivuokko said
09:52:37 <davidhouse> perhaps Writer with a wrapper that discards the log.
09:52:44 <ibid> davidhouse: only use unsafe* if there is no other way (given the constraints of your problem, including how much time you can invest in it:)
09:53:05 * dcoutts_ agrees with ibid 
09:53:35 <ibid> davidhouse: another possibility is to use the IO monad, perhaps hiding it with a veil of monads :)
09:54:00 <eivuokko> Veil of monads, heh :)
09:54:55 <ibid> or "a veil of genericity"
09:54:56 <dcoutts_> it's true! I looked at ghc's Tc monad once and after peeling back the layers found that at the bottom it was based on the IO monad!
09:55:12 <MarcWeber> eivuokko: Thx I just forget dependency base, lang
09:55:30 <ibid> in some of my haskell-based compiler projects, i've found that there is really no other way to do it cleanly than to bury the IO monad there somewhere
09:55:43 <davidhouse> @hoogle Writer
09:55:44 <lambdabot> Control.Monad.Writer :: module
09:55:44 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
09:55:44 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
09:55:52 <davidhouse> @hoogle evalWriter
09:55:53 <lambdabot> No matches found
09:56:37 <kolmodin> is there a std library function to expand paths? can't find any
09:56:39 <ibid> in other (off-topic) news, i'm almost ready to release 0.1 of Agora BASIC :)
10:04:14 <davidhouse> is there no evalWriter?
10:04:47 <olegm> ibid, one more question about AnyValue :)
10:04:57 <olegm> exactly the same problem with:
10:04:58 <olegm> test = AnyValue fun
10:04:58 <olegm> fun :: Ord a => a -> a
10:04:58 <olegm> fun a = a
10:05:46 <olegm> and the error is:
10:05:46 <olegm> Test.hs:6:16:
10:05:46 <olegm>     Ambiguous type variable `a' in the constraint:
10:05:46 <olegm>       `Ord a' arising from use of `fun' at Test.hs:6:16-18
10:05:46 <olegm>     Probable fix: add a type signature that fixes these type variable(s)
10:11:03 <davidhouse> huh. i have a State-ful computation that i want to call from a StateT-ful one. not possible?
10:11:22 <davidhouse> seems like there should be some function for it.
10:11:44 <Cale> davidhouse: runState
10:11:57 <dozer> @type .
10:11:58 <lambdabot> parse error on input `.'
10:12:01 <davidhouse> hmm, i suppose so.
10:12:02 <Cale> @type (.)
10:12:03 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
10:12:20 <Cale> davidhouse: you can write a cleaner wrapper using it
10:13:33 <Cale> liftState x = do s <- get; let {(v,s') = runState x s}; put s'; return v
10:14:09 <dozer> @hoogle Monad m => (b -> c) -> (a -> m b) -> a -> m c)
10:14:10 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
10:14:10 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
10:14:10 <lambdabot> Control.Parallel.Strategies.(-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
10:14:25 <Cale> however, if you have the choice, you could give the State computation a more general type
10:14:40 <MarcWeber> How can I expose CA to module Main ? http://www.rafb.net/paste/results/jqwy1351.html
10:15:01 <Cale> replace State s with m and add a constraint (MonadState s m)
10:16:17 <davidhouse> Cale, nice.
10:16:21 <Cale> olegm: despite the fact that fun never uses the dictionary, the type has to be determined so as to satisfy the Ord constraint.
10:17:01 <davidhouse> MarcWeber: module Foo (A(..))
10:17:46 <dozer> @type (.M) g f arg = do { fRes <- f arg ; return g fRes }
10:17:47 <lambdabot> parse error on input `='
10:17:51 <dozer> hehe
10:21:47 <davidhouse> argh! segfaults!
10:21:57 <davidhouse> why is it always me that seems to come across them?
10:22:11 <davidhouse> "Nothing can segfault a haskell program apart from the FFI and unsafe*". Bollocks!
10:22:26 <Cale> how the heck are you causing a segfault?
10:22:38 <jethr0_> i've never had one - even *with* ffi and unsafe*. what is causing it?
10:22:48 <davidhouse> i have _no_ idea.
10:22:55 <Cale> can I have your program?
10:22:59 <eivuokko> +1
10:23:10 <davidhouse> i've ran into compiler bugs before with the buggy recursive modules stuff, but this is nothing like that.
10:23:14 <davidhouse> hold on.
10:24:45 <dozer> @type do { fRes <- f arg ; return g fRes }
10:24:46 <lambdabot> Not in scope: `f'
10:24:47 <lambdabot>  
10:24:47 <lambdabot> <interactive>:1:15: Not in scope: `arg'
10:24:57 <lisppaste2> davidhouse pasted "segfault, part 1" at http://paste.lisp.org/display/20423
10:25:21 <lisppaste2> davidhouse annotated #20423 with "part 2: Smatiny.hs" at http://paste.lisp.org/display/20423#1
10:25:27 <davidhouse> there.
10:25:54 <davidhouse> oh, hang on.
10:25:57 * davidhouse has an idea
10:26:14 <jethr0_> davidhouse: to reproduce we'd need smatiny and commands modules :)
10:26:34 <jethr0_> k, sry
10:27:16 <davidhouse> yeah, something _really_ screwy is happening.
10:27:20 <jethr0_> davidhouse: where does Commands come from?
10:27:49 <davidhouse> i didn't paste that.
10:28:18 <jethr0_> i'd be willing to try and reproduce/find your bug if you did :)
10:29:12 <davidhouse> heh.
10:29:21 <davidhouse> let me tar this up, it'll be simpler.
10:29:26 <jethr0_> k
10:31:40 <davidhouse> http://xmouse.ithium.net/dmh-source/smatiny.tar.gz
10:32:09 * jethr0_ has been thinking for years how to make programming easier. i've got several really cool ideas but implementing would be a *major* pain, even though i know exactly how i'd do it.
10:32:34 <jethr0_> if only there was a more do-what-i-mean interface out there :(
10:33:47 <jethr0_> davidhouse: which one segfaults, Main? and with any params?
10:35:17 <davidhouse> compile Main.
10:35:26 <davidhouse> ghc -o smatiny --make Main.hs
10:35:30 <davidhouse> ./smatiny smatiny-test
10:35:31 <jethr0_> k, i got a segfault with smatiny-test
10:35:37 <davidhouse> *world comes crashing down*
10:36:13 <eivuokko> Not on me.  ghc-6.4.2 in Windows.
10:36:22 <davidhouse> eivuokko: what does it do?
10:36:36 <davidhouse> print "Hi!", by any chance?
10:36:37 <eivuokko> Prints Hi! and empty line
10:36:40 <davidhouse> cool.
10:36:44 <eivuokko> o.O
10:36:48 * eivuokko wanted a crash
10:36:56 <jethr0_> i got the valgrind output. but i'll have to add C debugging symbols. anyone know how to make ghc do that?
10:36:58 <wilx> :))
10:37:03 <jethr0_> i.e. pass "-g" to gcc
10:37:07 <davidhouse> eivuokko: ./smatiny -v smatiny-test > outfile
10:37:20 <davidhouse> (redirect as it'll produce a _lot_ of output)
10:37:28 <eivuokko> I didn't, and no crash.
10:37:37 <eivuokko> Only some hundred lines
10:37:59 <davidhouse> well, that at least means 1) it typechecks. 2) it's a compiler error, not mine.
10:38:12 <eivuokko> Which ghc and platform?
10:38:25 <davidhouse> 6.4.1/linux x86
10:38:28 <eivuokko> Hrm
10:38:33 <davidhouse> anyone on 6.4.2/linux?
10:38:39 * eivuokko ponders installing 6.4.1
10:38:45 <jethr0_> 6.4.2/linux amd64
10:38:51 <jethr0_> also crashes
10:38:54 <davidhouse> ah, okay.
10:39:04 <davidhouse> right, so it's not an upgrade-to-fix-it bug,
10:39:11 <eivuokko> gcc version?
10:39:11 <jethr0_> any ideas how to pass "-g" to gcc?
10:39:21 <eivuokko> Ah, but you don't use -fvia-C
10:39:23 <jethr0_> 4.0.3
10:40:22 <eivuokko> What does -g add?  You do know that ghc mangles the asm generated from C, right?
10:40:44 <jethr0_> debugging symbols
10:41:16 <eivuokko> Those will be only usefull for debugging rts.  I think.
10:41:25 <jethr0_> davidhouse: you wouldn't do some *really* evil pointer arithmatic via ffi, would you?
10:41:48 <jethr0_> eivuokko: no, i hadn't thought about that
10:42:16 <eivuokko> If you can get the address of crash....
10:42:19 <jethr0_>  Jump to the invalid address stated on the next line [...]  Address 0xAE860F0 is not stack'd, malloc'd or (recently) free'd
10:42:32 <eivuokko> ...you can compare that to nm's output
10:42:41 <eivuokko> And find the haskell function inside which it crashed
10:42:47 <eivuokko> (if it was haskell function)
10:43:06 <jethr0_> Access not within mapped region at address 0xAE860F0
10:43:21 <davidhouse> all i'm doing which is odd is some existentials. the rest is h98
10:47:18 <eivuokko> I think ghc people would appreciate if you can let them have the sources and bug report.
10:47:40 <jethr0_> weird, i deleted all .o files recursively and recompiled and now it works. you wouldn't have left any object files in your tar.gz, would you?
10:48:14 <eivuokko> Heh
10:48:22 <eivuokko> Yes there is, in Commands
10:48:22 <davidhouse> :) oops
10:48:26 <davidhouse> great, so i'm on my own.
10:48:39 <jethr0_> davidhouse: try deleting all .o files
10:49:15 <jethr0_> i'm running in 32bit emulation, so my build system should actually be very similar to yours
10:49:26 <davidhouse> have done.
10:49:33 <davidhouse> still borks.
10:49:45 <Cale> cale@zaphod[~/smatiny]$ ./smatiny smatiny-test
10:49:46 <Cale> Hi!
10:50:00 <Cale> works for me
10:50:23 <davidhouse> you know what?
10:50:32 <davidhouse> rm -rf *.o *.hi doesn't delete recursively!
10:50:40 <Cale> right
10:50:40 <eivuokko> Yeah, work for me, ghc 6.4.1 in linux-i686
10:50:53 <Cale> Because .o and .hi files are not usually directories
10:51:19 <jethr0_> find -iname "*.o" -exec rm {} \;
10:51:50 <davidhouse> well, it does work now, after manually deleting files! :)
10:51:55 <davidhouse> thanks all, sorry for wasting your time.
10:52:03 <davidhouse> but it was segfaulting at one point.
10:52:12 <jethr0_> np, after all it's also ghc's fault for not properly rebuilding .o files
10:52:33 <jethr0_> that's can be a major problem at times. especially when it doesn't figure out that a source file has changed
10:52:40 <Cale> ghc really likes to not recompile things when there are .o files lying around
10:52:53 <jethr0_> yes, but it should at least look at the time stamps
10:53:01 <eivuokko> Heh, I use -no-recomp half of the time :)
10:53:05 <jethr0_> or provide "ghc --clean"
10:53:20 <davidhouse> ghc --clean would rock.
10:53:32 <davidhouse> sounds like a hackathon project :)
10:54:04 <jethr0_> time stamps aren't foolproof, but still better than ignoring changes half of the time
10:54:40 <davidhouse> so what does the -r stand for in rm -rf *.o *.hi if not "recursive"?
10:54:54 <eivuokko> If you gave a directory name it recurses into it
10:55:15 <eivuokko> As Cale said, *.o or *.hi aren't directories often
10:55:56 <davidhouse> oh, of course.
10:55:56 <jethr0_> rm can't selectively delete files recursively
10:56:23 <jethr0_> another shortcoming of expanding globs in the shell
10:58:07 <dcoutts_> waern, how's it going? what do you think of the ghc/haddock project?
10:58:29 <waern> dcoutts, well.. i've sent a patch to marlow today.. 
10:58:31 * dcoutts_ was very pleased to vote for waern's SoC project
10:58:42 <waern> thanks =)
10:59:03 <dcoutts_> I've hacked on haddock a little, and I know it's shortcomings
10:59:12 <dcoutts_> basing it on the ghc api would be so useful
10:59:20 <davidhouse> dcoutts_: who else was on the 'committee'?
10:59:38 <dcoutts_> davidhouse, lots of people
10:59:50 <waern> dcoutts, yeah.. ultimately haddock could transform into our intellisense data generator ;) 
10:59:56 <dcoutts_> davidhouse, I think there were about 20 of us
11:00:03 <dcoutts_> waern, exactly!
11:00:13 <dcoutts_> waern, it'd be really useful in IDEs
11:00:18 <dcoutts_> and GHCi
11:00:30 <ibid> olegm: the solution is also the same
11:00:36 <dozer> I'm prety consistently find that when I write the right haskell, it is short, clean and readable, but when I write the wong haskell it is long, tortuous and write-only
11:00:40 <dcoutts_> and we'd get decent parse errors from haddock
11:00:49 <dcoutts_> and proper support for ghc extensions
11:01:02 <waern> dozer, yep.. it's definitely easy to write hard to read code in Haskell
11:01:03 <dozer> now if only I could write the right haskell earlier in the type/compile/scratch head cycle
11:01:07 <cogumbreiro> what is an integral double?
11:01:31 <sjanssen_> cogumbreiro: there isn't such a thing, and that's probably your problem
11:01:45 <jethr0_> valgrind is the sh*t! there should be a rule that whenever you run into hard-to-solve debugging problems you should write better tools.
11:01:50 <cogumbreiro> ERROR "change.hs":145 - Instance of Integral Double required for definition of isCoin
11:01:51 <dcoutts_> cogumbreiro, perhaps you're wondering if Double is an instance of the class Integral
11:02:09 <davidhouse> cogumbreiro: pastebin some coe.
11:02:11 <davidhouse> *code
11:02:13 <dcoutts_> cogumbreiro, then it's a type error in the program
11:02:25 <davidhouse> dcoutts_: funny, i assumed he was talking about double integrals, in the mathematical sense :)
11:02:31 <dcoutts_> heh
11:03:05 <dcoutts_> waern, so what's your plan?
11:03:13 <cogumbreiro> http://www.rafb.net/paste/results/KCFaQt11.html
11:03:20 <SamB> hmm, apparantly I can't use Binary because I need to be able to give byte offsets?
11:03:57 <dcoutts_> waern, presumably you're extending ghc's parser to grok haddock markup?
11:04:00 <sjanssen_> cogumbreiro: first thing, the last line should have &&, not and
11:04:12 <cogumbreiro> rats :S
11:04:18 <cogumbreiro> confused by python... :S
11:04:52 <cogumbreiro> I've changed it to a && and now the error is: ERROR "change.hs":145 - Instance of Integral Double required for definition of isCoin
11:04:56 <waern> dcoutts, yeah.. that's what I'm doing now.. I just sent marlow a patch for the lexer.. it probably still needs to be worked on but I'm looking at the parser now
11:05:04 <dcoutts_> waern, cool.
11:05:17 <dcoutts_> waern, you worked on haste with kolmodin right?
11:06:02 <waern> dcoutts, I still don't know exactly how much work I'll have to do in the other phases to propagate the comments to the ghc-library right now 
11:06:05 <cogumbreiro> sjanssen, what's wrong with '(100 * number) - truncate(100 * number)' ?
11:06:08 <waern> but I'll find out =)
11:06:12 <SamB> @hoogle Word8
11:06:13 <lambdabot> Data.Word.Word8 :: data Word8
11:06:20 <mauke> @type truncate
11:06:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:06:28 <waern> dcouttts, yes.. I'm davve / david
11:06:28 <SamB> er.
11:06:34 <SamB> @hoogle utf8
11:06:37 <lambdabot> No matches found
11:06:47 <sjanssen_> @type truncate
11:06:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:06:51 <mauke> cogumbreiro: they don't have the same type
11:07:09 <dcoutts_> waern, I guess you'll need to augment ghc's ast with an extra haddock markup notes and then store them in the .hi files too.
11:07:13 <cogumbreiro> so, I have to convert truncate
11:07:16 <ski> @type \number -> (100 * number) - fromIntegral (truncate (100 * number))
11:07:17 <lambdabot> forall b.
11:07:18 <lambdabot>                         (RealFrac b) =>
11:07:18 <lambdabot>                         b -> b
11:07:19 <cogumbreiro> fromInteger, maybe?
11:07:21 <sjanssen_> cogumbreiro: truncate turns some kind of fractional thing, into some kind of integral thing.  There aren't any types that are both fractional and integral
11:07:28 <cogumbreiro> cool
11:07:29 <dcoutts_> waern, but Simon will know the best approach for that
11:07:29 <SamB> where can I get a UTF8 decoder...
11:07:36 * joelr1 waves
11:07:37 <mauke> > (100 * number) - fromIntegral (truncate (100 * number)); number = 1.23
11:07:37 <cogumbreiro> thanks alot guys :)
11:07:38 <lambdabot>  0.0
11:07:48 <dcoutts_> SamB, there are a few about
11:08:00 <dcoutts_> SamB, but none in a standard lib yet
11:08:09 <dozer> @lambdabot pastebin
11:08:10 <lambdabot> Unknown command, try @list
11:08:20 <SamB> dcoutts: point ;-)
11:08:38 <waern> dcoutts, yeah.. I'm thinking I'll do it one syntax node (constructor) / production at a time, writing the test for it first and then continuing to the next when the test is succeeding
11:08:40 * SamB was thinking lambdabot had more libs, or something...
11:08:45 <ski> maybe 'fromIntegral . truncate' should be defined ..
11:09:03 <ski> (and similar for 'round','floor','ceiling', of course)
11:09:09 <waern> dcoutts, with the test just consisting of getting ghc not to give a parse error :)
11:09:18 <dcoutts_> waern, sounds good. I'll be very interested to follow your progress :-). Keep us posted!
11:10:04 <dcoutts_> waern, and if you need endless conflicting opinions.. I mean advice then just ask here :-)
11:10:08 <SamB> dcoutts: okay, I'd like a version written in Haskell which uses lists. Where can I copy and paste it from?
11:10:17 <dcoutts_> SamB, from gtk2hs
11:10:17 <waern> dcoutts, hehe sure.. :)
11:10:53 <dozer> http://www.rafb.net/paste/results/6X3Toj13.html
11:10:54 <dcoutts_> SamB, in particular the glib package, in the UTF8String module.
11:11:10 <dozer> so this is my attempt at something a bit like wget, with explicit http proxy support
11:11:16 <dozer> using my patched Network.HTTP
11:11:35 <davidhouse> i've got a question pertaining to coding styles. how stringently do people keep to the 80-column rule?
11:11:42 <dozer> any/all comments about style, efficiency, names etc. gratefully recieved
11:12:21 <SamB> dcoutts: lovely! it is just the type that I wanted!
11:12:28 <waern> davidhouse, me, very stringently :)
11:13:00 <SamB> although I think I might have forgotten which instance I was supposedly writing...
11:13:08 <dcoutts_> davidhouse, pretty close on stuff I expect to share, and much wider for my own private code.
11:13:31 * SamB changes instance head to match ;-)
11:13:45 <lisppaste2> davidhouse pasted "80 col rule example" at http://paste.lisp.org/display/20428
11:13:56 <davidhouse> ^^ as an example of what i mean.
11:14:48 <sjanssen_> davidhouse: Haskeller's are often more lenient with long lines
11:18:36 * davidhouse used a Maybe do-block today
11:18:39 <davidhouse> i am very proud :)
11:18:50 <xerox> With guard? (-:
11:19:07 <davidhouse> 'fraid not.
11:19:41 <davidhouse> it involved a whole two (2!!) consecutive Maybe-computation, so i threw caution to wind and used a do-block :)
11:20:09 <dozer> davidhouse: living on the edge
11:20:47 <davidhouse> gah. where's ihope?
11:22:06 <SamB> so is >>= broken or did you need to bind the value to a name?
11:23:44 <davidhouse> i needed to take two computations in Maybe and combine them into a third
11:23:49 <davidhouse> errors should be propogated.
11:24:00 <davidhouse> oops, gotta go.
11:24:42 <SamB> @hoogle Handle
11:24:43 <lambdabot> System.IO.Handle :: data Handle
11:24:43 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
11:24:43 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
11:34:02 <cogumbreiro> I want to define the `join` function that exists in python
11:34:09 <cogumbreiro> to do so i'm using this signature:
11:34:29 <cogumbreiro> join :: b -> [a] -> String
11:34:38 <cogumbreiro> I want b and a to be of a Show class, how do I do that?
11:34:56 <lightstep> join :: (Show a, Show b) => b -> [a] -> String
11:35:06 <cogumbreiro> thanks :)
11:35:13 <lightstep> but python's join requires b to be String
11:35:20 <cogumbreiro> does that function already exist in standard python?
11:35:24 <cogumbreiro> *hasjell
11:35:37 <lightstep> @type interleave
11:35:38 <lambdabot> Not in scope: `interleave'
11:35:47 <lightstep> @type intersperse
11:35:48 <lambdabot> forall a. a -> [a] -> [a]
11:36:01 <mauke> @type (concat .) . intersperse
11:36:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:36:32 <mauke> > join ";" ["foo","bar","baz"]; join = (concat .) . intersperse
11:36:33 <lambdabot>  "foo;bar;baz"
11:36:41 <cogumbreiro> thanks :D
11:36:50 <lumi> Hi lightstep 
11:36:53 <cogumbreiro> I was using (with strings only)
11:37:08 <lightstep> @whois lumi
11:37:08 <lambdabot> Unknown command, try @list
11:37:15 <lightstep> @wi lumi
11:37:16 <cogumbreiro> foldr (join_aux (show buckle)) "" vals     where  join_aux val x y = if (right == "") then left else (left ++ val ++ right)
11:37:16 <lambdabot> Maybe you meant: wiki wikipedia wn
11:37:31 <lumi> What's that then?
11:37:36 <lightstep> lumi, hi. do we know each other?
11:37:40 <lumi> Yes
11:37:50 <lumi> I wouldn't say hi otherwise, surely?
11:38:12 <cogumbreiro> lightstep, I don't have intersperse, which module is it on?
11:38:25 <hyrax42> @inded intersperse
11:38:25 <lambdabot> Data.List
11:38:27 <lightstep> @index intersperse
11:38:27 <lambdabot> Data.List
11:38:34 <cogumbreiro> thx
11:38:39 <lightstep> oh, /that/ lumi
11:38:59 <lumi> Um? I guess so
11:49:10 <skd> Is there a natural type?
11:49:17 <dcoutts_> no
11:49:26 <dcoutts_> not built-in
11:49:50 <dcoutts_> there is Word if that helps
11:51:03 <lightstep> skd, you can make one with a smart constructor
11:51:28 <skd> :_/
11:56:20 <Cale> data Nat = Zero | Succ Nat
12:00:30 <MrHuskell> I have had a look at the PLEAC site, but it's rather incomplete when it comes to Haskell, you guys know of any other sites with a similar collection of code pices showing how/what things can be done in Haskell?
12:01:08 <dcoutts_> MrHuskell, there's lots of stuff on haskell.org
12:01:25 <sjanssen_> MrHuskell: please don't look at the Haskell code at PLEAC
12:01:33 <sjanssen_> MrHuskell: it's absolutely horrible
12:02:41 <dcoutts_> sjanssen_, and it's wrong :-)
12:02:48 <dcoutts_> s!![0]
12:02:51 <dcoutts_> wtf is that?
12:02:57 <MrHuskell> Yea, gone though it, but it seems more oriented towards Tutorials and Papers on Haskell, rEading a few of those already, but as I progress and start to understand haskell code it would be nice to have someting small and neat to read =)
12:03:02 <sjanssen_> dcoutts_: they redefine a bunch of operators in the code
12:03:09 <dcoutts_> ugg
12:03:19 <MrHuskell> Oookey, PLEAC haskell is no good then =)
12:03:21 <sjanssen_> dcoutts_: another gem is that they make "x . g = g x"
12:03:34 <dcoutts_> noooo
12:03:41 <sjanssen_> just so they can get OO-ish code
12:04:28 <jethr0_> yup, their syntax is really non-idiomatic
12:04:49 <jethr0_> [3,2,1].sort
12:05:11 <sjanssen_> > [3, 2, 1] . sort
12:05:12 <lambdabot>  Couldn't match `b -> c' against `[a]'
12:05:14 <MrHuskell> Why don't you guys send them a email giving them some pointers?
12:05:21 <MrHuskell> an
12:05:22 <MrHuskell> =)
12:06:07 <sjanssen_> sum1 = ("sum is " ^ s1.map ord.sum).putStrLn
12:06:07 <jethr0_> > let (.) a b = b a in [3,2,1].sort
12:06:08 <lambdabot>  [1,2,3]
12:06:15 <sjanssen_> ah ha ha ha ha
12:06:27 <dcoutts_> dons, hah ha! I've got another idea for how to do fusion...
12:06:58 <dcoutts_> dons, and using only 2 phases too! (I think)
12:08:40 <jethr0_> 23ls
12:09:55 <int-e> my favourite comment from PLEAC: -- TODO, dont work, seems monad are lazy too, dont understand io in haskell anymore :(
12:10:08 <dcoutts_> hah
12:10:21 <jethr0_> must have been quite a haskell guru
12:10:30 <int-e> (he(?)'s using getContents)
12:10:31 <sjanssen_> int-e: which section?
12:10:40 <int-e> sjanssen: Helpers
12:11:09 <int-e> sjanssen: (Appendix A) this is where all the ugly non-standard stuff is defined.
12:11:35 <sjanssen_> yeah, I bet there are some gems in here
12:13:00 <jethr0_> (f $ g) x = (g Â° f) x
12:13:09 <jethr0_> (Â°) f g x = f (g x)
12:13:16 <int-e> > succ 'a'
12:13:17 <lambdabot>  'b'
12:13:29 <jethr0_> so Â° is .
12:13:41 <jethr0_> and $ is flip .
12:15:05 <Cale> Oh, the PLEAC Haskell code is ridiculous
12:16:27 <Cale> The problem is that PLEAC is such a boring set of programs that I haven't been able to bring myself to actually coding most of them.
12:17:53 <jethr0> yup, and some of the problems are rather perl biased. it's like the shootout without the challenge :)
12:19:47 <sjanssen_> so, the guy defines [a] to be an instance of Num, and then we get this comment: make this instance is very dangerous, cos now typechecker not detect the error [show 1,show 2]++[0,0], WHY ?
12:20:04 * jethr0 is just trying out the virtualization module of qemu. if it weren't stupidly free-as-in-beer, this would be really nice. supposedly only slowdown is only 1-2!
12:20:33 <Cale> sjanssen: Because 0 is a list.
12:20:49 <sjanssen_> Cale: yeah, I understand.  Just thought the comment was hilarious
12:20:58 <int-e> sjanssen: ironic.
12:21:10 <Cale> oh, the WHY? is his :)
12:21:34 <Cale> unique                     :: (Eq a) => [a] -> [a] -- dont know why but forced to put the type
12:21:34 <Cale> unique = nub
12:22:08 <Cale> (monomorphism restriction)
12:23:39 <Cale> I wonder how long this guy had been writing Haskell code.
12:24:01 <Cale> I also wonder why he decided to do things as unidiomatically as possible.
12:24:05 <sjanssen_> i = 2.3.round
12:24:11 <Cale> haha
12:24:16 <Cale> aaaaaaauuugghh!
12:24:50 <Cale> import Prelude hiding (($),(^),(.),(!!),map,take,lookup,drop,splitAt,reverse,filter,takeWhile,dropWhile,null,foldl)
12:24:58 <Cale> import List hiding ((!!),map,take,lookup,drop,splitAt,reverse,filter,takeWhile,dropWhile,null,insert,union,intersect,delete,partition,foldl,length)
12:24:59 <jethr0> HAHA
12:25:14 <ADEpt> what's left, then?
12:25:44 <sjanssen_> I'm just amazed there isn't any unsafePerformIO
12:26:00 <jethr0> as you can see he's written "haskell" implementations of the problems
12:26:43 <jethr0> > let (.) a b = b a in 2.3e-4.round
12:26:44 <int-e> sjanssen: on the other hand there's a O(n^4) matrix multiplication algorithm.
12:26:44 <lambdabot>  0
12:26:55 <jethr0> nice
12:27:00 <ADEpt> Cale: where's that from?
12:27:19 <Cale> ADEpt: the Haskell PLEAC code
12:27:25 <Cale> ADEpt: it's hideous
12:27:40 <int-e> > let (.) a b = 42 in 2.3.4.5
12:27:41 <lambdabot>  42
12:28:03 <Cale> hehe
12:28:13 <int-e> > let (.)=(+) in 2.3.4.5
12:28:14 <lambdabot>  6.8
12:28:15 <int-e> ugly.
12:28:17 <Cale> > let (.) a b = 42 in 2.3
12:28:18 <lambdabot>  2.3
12:28:24 <Cale> > let (.) a b = 42 in 2. 3
12:28:25 <lambdabot>  42
12:28:33 <sjanssen_> > let (.) a b = show a ++ show b in 2.3.4.5
12:28:34 <lambdabot>  "2.34.5"
12:28:39 <Cale> hehe
12:29:08 <basti_> uhmMmm?
12:29:13 <jethr0> i'm amazed that the parser can handle that :)
12:29:19 <basti_> grotesque!
12:29:29 <Spark> it just means . is not a special token
12:29:30 <ValarQ> what the heck?
12:29:30 <jethr0>  > let (.) a b = show a ++ "." ++ show b in 2.3.4.5
12:29:33 <basti_> it's a packrat parser.
12:29:35 <jethr0> > let (.) a b = show a ++ "." ++ show b in 2.3.4.5
12:29:36 <lambdabot>  "2.3.4.5"
12:29:54 <Spark> > let (let) a b = 42 in 1 let 2
12:29:54 <lambdabot>  parse error on input `)'
12:30:04 <basti_> lol
12:30:11 <ValarQ> hehe
12:30:12 <int-e> > let  (.) a b = show a ++ "." ++ show b in 2 . 3 . 4 . 5
12:30:14 <lambdabot>  "\"\\\"2.3\\\".4\".5"
12:30:20 <basti_> > let it be = be in times of trouble?
12:30:21 <lambdabot>  parse error on input `of'
12:30:21 <basti_> ;)
12:30:59 <Spark> let . a = a in 1 + . 2 . 3 . 4
12:31:01 <Spark> > let . a = a in 1 + . 2 . 3 . 4
12:31:02 <lambdabot>  parse error on input `.'
12:31:58 <shapr> Who do I contact about getting an ssh account for Jun Mukai / HaskellNet on darcs.haskell.org? Is SyntaxNinja the right person?
12:32:12 <Spark> > parse error on input
12:32:13 <lambdabot>  Not in scope: `input'
12:32:19 <ADEpt> Cale: why just blindly solve perl problems in the first place? :)
12:32:56 <sjanssen_> we need to start our own PLEAC like project -- examples like "here we define a state monad", then have a Perl hacker implement them
12:34:09 <Cale> yeah :)
12:35:47 <Cale> Here we define a continuation monad transformer :)
12:36:12 <jethr0> ADEpt: well, it's not so much perl problems as accumulating a cross-language cookbook. but as the original is for perl, there's a strong bias
12:36:44 <jethr0> here we have IO on State on Cont on Error on Parsec
12:37:29 <Cale> um
12:38:17 <sjanssen_> jethr0: sorry, IO isn't a transformer
12:38:22 <Cale> yeah, write a Parsec parser which uses the first part of the file to construct another parsec parser.
12:38:44 <Cale> That would be awfully hard to accomplish in most non-functional languages.
12:38:51 <jethr0> sjanssen_: there's this iomonad thing (can't find it right now). that's why io is on top
12:39:18 <Cale> jethr0: usually you consider IO to be the bottom of the stack.
12:39:23 <jethr0> hmm :)
12:39:36 <Cale> @type lift
12:39:37 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
12:39:38 <lambdabot>    (MonadTrans t, Monad m) =>
12:39:38 <lambdabot>    m a -> t m a
12:39:39 <jethr0> monadio it was
12:39:49 <Cale> @type liftIO
12:39:50 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
12:39:54 <jethr0> cale, sjanssen_: as you can see, stacking monads isn't exactly my forte :)
12:40:24 <Cale> It lifts from IO to some monad which is a transformer stack on top of IO.
12:41:39 <jethr0> yup, i've used it, but stacking monads is still a little voodoo to me. nonetheless i'm looking forward to the SoC parsec transformer
12:42:19 <sjanssen_> haskell-cafe is the only place where you'll read "there are too many free variables in your problem description", rather than "your description isnt specific enough" ;-)
12:44:53 <Pawer> haskell rules
12:44:55 <Pawer> !
12:45:02 <Beelsebob> correct
12:45:21 * basti_ agrees, too
12:45:26 * jethr0 concurrs
12:45:39 * basti_ puts a bag over jethr0's head
12:45:59 <basti_> oh sorry, misunderstood
12:46:05 * basti_ takes the bag off again
12:46:05 <Pawer> haskell is still owning
12:46:42 * jethr0 is flabberghasted
12:46:49 <dcoutts_> dons, oh yeah! the RULES typecheck. They look quite nice too :-)
12:46:54 <dcoutts_> @localtime dons 
12:46:57 <lambdabot> Local time for dons is Fri May 26 05:40:28 2006
12:47:06 <Pawer> > "haskell" + "rules"
12:47:07 <lambdabot>  add an instance declaration for (Num [Char])
12:47:07 <lambdabot>   In the definition of `hih': hih = "haskell" + "rules"
12:47:07 <lambdabot>   In the definition of `ksb':
12:47:18 <Pawer> > "haskell" ++ " rules"
12:47:19 <lambdabot>  "haskell rules"
12:47:23 <Pawer> lol
12:48:11 <Pawer> anyone likes prolog?
12:48:27 <basti_> <
12:48:28 <dcoutts_> dons, we should write a paper on this. :-) The key idea is to do the wrapper elimination first, and then fuse loops within the same wrapper.
12:48:33 <basti_> i do Pawer 
12:48:47 <Pawer> i do not
12:48:57 <Pawer> do not like databases
12:49:15 <basti_> well, as long as you're here, it's ok, if you like haskell.
12:49:33 <Pawer> there si no prolog channel
12:49:52 <sjanssen_> really?  that's a surprise
12:49:59 <basti_> there IS
12:50:12 <Pawer> there was not
12:50:19 <int-e> dcoutts_: are there any plans for releasing a new version of gtk2hs? it's been a while since the last release and a few new functions have been bound (for example that cairo clock doesn't compile with 0.9.10)
12:50:41 <Pawer> well
12:50:50 <Pawer> maybe is similar to haskell
12:50:53 <tennin> we are just messing with your head
12:51:09 <Pawer> in the way of writting the programs
12:51:09 <tennin> we created the Prolog channel half an hour ago for that purpose
12:51:11 <dcoutts_> int-e, yes we've got a shortish TODO list for the next release. We're somewhat stalled on the tree/view api changes.
12:51:18 <basti_> not really, but knowing prolog will help you understand haskell's type system
12:51:26 <dcoutts_> int-e, so no firm ETA 
12:53:00 <int-e> okay.
12:56:04 <Pawer> i readed that there is somebody writing apt utils in haskell
12:57:24 <Lemmih> Pawer: That's xerox.
13:01:35 <dcoutts_> Pawer, or possibly Linspire
13:01:57 <ADEpt> Lemmih: do you want some patches for conjure?
13:02:00 * xerox waves
13:02:55 <Lemmih> ADEpt: Sure, send them along.
13:03:39 <Pawer> I think Linspire
13:03:41 <ADEpt> Lemmih: I dont remember which ones you've seen alreay, so there probably'll be some dupes
13:03:44 <Pawer> is what i have read
13:04:11 <ADEpt> Lemmih: off they went
13:07:34 <Lemmih> Pawer: xerox's work is much more interesting (:
13:07:53 * xerox hops up and down (:
13:07:57 <Pawer> sure
13:08:22 <xerox> Anyway, off to study, TTYL.
13:08:37 <basti_> xeros is terribly productive
13:08:39 <basti_> x
13:08:59 * xerox hugs basti_ 
13:09:06 * basti_ hugs xeros
13:09:09 <dcoutts_> g'evening SyntaxNinja 
13:09:12 <basti_> argh
13:09:17 <basti_> whats up with my fingers
13:10:48 <Pawer> -> Switch to Dvorak
13:14:05 <SyntaxNinja> hyea
13:14:26 <SyntaxNinja> xerox: I take it you're on board w/ SoC?
13:14:51 <xerox> Oi Isaac!  Yes!
13:15:14 <xerox> They are making such a noise on the Summer-Accepted mailing list (:
13:15:25 <Lemmih> ADEpt: Did you send the mail?
13:15:53 <xerox> SyntaxNinja - I saw your mail some days ago, I didn't have time to reply yet, sorry.
13:18:53 <xerox> School gets in the way, those are the last two weeks before the final exams.
13:19:04 * xerox trembles
13:19:29 <sjanssen_> how does one get an account on darcs.haskell.org?
13:21:26 * SamB wonders why his program has typechecked
13:21:51 * SamB is a little freaked out
13:22:52 <SamB> sjanssen: well, I think you generally start by having a good reason to have one
13:23:52 <sjanssen_> SamB: I'd like a place to put my summer of code stuff
13:24:24 <xerox> sjanssen_ - I am sure the org will provide something.
13:25:16 <SamB> ah, well, I'm sure you'll be given somewhere
13:25:22 <SamB> congrats on making the cut ;-)
13:25:54 <sjanssen_> SamB: thanks
13:26:35 <SamB> did they actually publish the list yet?
13:26:52 <xerox> <http://www.haskell.org/pipermail/haskell/2006-May/017999.html> ?
13:27:20 <xerox> Nothing here, though <http://code.google.com/soc/haskell/about.html>
13:28:24 <SamB> I was thinking that it should be on http://code.google.com/soc/, as that page itself proclaimed on the 24th (though it said that it would be published on the 23rd)
13:29:31 <SamB> how come the list doesn't mention known IRC nicks?
13:29:51 <SamB> this is a gross omition!
13:31:08 <SamB> What would a string bundle be?
13:32:36 <SamB> that is, what will Data.Rope be?
13:32:41 <vincenz> re
13:33:10 <sjanssen_> SamB: a rope is a bunch of strings in a tree like structure.  It lets you have fast concatenation
13:33:18 <SamB> ah
13:33:55 <SamB> hmm... you couldn't do that in terms of a generic catenable sequence type?
13:34:30 <sjanssen_> SamB: I'm using a catenable sequence type
13:34:42 <sjanssen_> some other things have to happen if you want fast indexing, for example
13:34:47 <SamB> oh
13:34:56 <sjanssen_> I'm using Data.FingerTree, which is what the new Data.Sequence is based on
13:35:11 <SamB> oh, you mean we already have one?
13:35:29 <ADEpt> Lemmih: I thought I did, but VPN to my smtp server was down. Now I really did.
13:35:31 <sjanssen_> yeah, I think it will be included with GHC 6.6
13:35:57 <SamB> BTW, remind me to wait for 6.6.1 or 6.6.2
13:36:05 <vincenz> hiya ADEpt 
13:36:15 <ADEpt> vincenz: hi
13:36:31 <vincenz> que pasa 
13:36:43 * SamB goes back to wondering how his program can be correctly typed
13:36:54 <sjanssen_> SamB: how can you wait?!  6.6 has the new SMP stuff, which should be tons of fun
13:37:06 <SamB> well, 6.4 is so buggy!
13:37:11 * SamB is using that now
13:37:55 * vincenz thinks there should be some editor based on D.BS
13:37:56 <SamB> and, since I clearly won't upgrade to a different point-release, I must obviously avoid the temptation to get 6.6[.0]
13:38:06 <vincenz> if you open really large files with VIM it seriously slows down
13:38:43 <vincenz> SamB: in that case I suggest you wait about 10 years, then the chance of a bad version is even lower!
13:39:07 <SamB> It looks like GHC should be complaining that I need XPT a in the context of my instance XPT (Off a)
13:39:13 <SamB> vincenz: I can't wait that long!
13:39:27 <SamB> maybe 6.6 will be less buggy than 6.4...
13:39:31 <vincenz>  oh so it's a tradeoff
13:39:42 <vincenz> pick the pareto optimal curve and walk along it
13:41:04 <SamB> who would ever have thought that I would be wondering why my program *had* typechecked, rather than why it *hadn't*...
13:43:03 <SyntaxNinja> xerox: not even sure which mail you mean.
13:43:58 <SamB> oh, I figured out why my program typechecked.
13:44:09 <SamB> I wish it would tell me when I had a strange loop in my program...
13:44:14 * vincenz is off to game a bit
13:45:28 <SamB> okay, yay, I got my type error!
13:45:37 * SamB fixes it
13:50:05 <SamB> okay, why is there no liftM7?
13:50:28 <SamB> aw nuts, I can't do that anyway...
13:50:39 <SamB> oh wait, I can at least liftM4...
13:50:47 <SamB> actually, no.
13:50:54 <xerox> SyntaxNinja: ``Would you mind keeping your soc proposal at this location and updateing it as the process moves forward <trac url>''
13:52:31 <dcoutts_> SyntaxNinja, xerox, we need to make sure that all our students are keeping their sources in public source repos.
13:52:40 <dcoutts_> that probably means darcs
13:52:50 <xerox> Absolutely.
13:52:58 <dcoutts_> perhaps we should give each student an account on darcs.haskell.org
13:53:05 <dcoutts_> and host them all in one place
13:53:46 <dcoutts_> of course we expect the code to get folded back into the 'upstream' projects eventually
13:53:52 <xerox> It's okay either way, I can put them when I put the code last year.
13:54:45 <dcoutts_> SyntaxNinja, or do you think we should only setup repos for projects where the student isn't working on the 'live' repo?
13:55:26 <dcoutts_> I'd say let each student make a darcs fork of their host projects and host them together on darcs.haskell.org
13:55:34 <xerox> Last year it was useful for me to have a separate repository.  But Gtk2Hs is a big beast, for cabal-get the official one would work too I think.
13:55:35 <SamB> if the student is putting patches in a live repo or mailing them to a public list, that should be okay, shouldn't it?
13:55:49 <xerox> I would nevertheless have a local darcs because of its infrastructure, you know.
13:55:56 <dcoutts_> and of course it'd be ok to merge into the upstream project repo too
13:56:40 <dcoutts_> but it might be nice for the students to work in a fork since then they can be more agressive with their changes and not constantly get code review for each patch from their mentor
13:56:52 <SamB> of course you'd have a local one too, its impossible to avoid without doing all development via SSH to the server ;-)
13:57:32 <SamB> let them pick what they think is best!
13:58:45 <waern> dcoutts, It's also nice to have a remote repo to push changes to when moving around between computers
13:58:55 <waern> dcoutts, without that repo being the live repo
13:59:04 <dcoutts_> waern, right
13:59:23 <waern> I already have a such a remot repo, and I'd be happy to move it to darcs.haskell.org
13:59:24 <dcoutts_> and it means the rest of us get to see what you're up to! ;-)
13:59:34 <dcoutts_> lets ask SyntaxNinja 
14:00:18 <dcoutts_> SyntaxNinja, they could have a seperate unix group if you'd worry at all about them all being in the general 'darcs' unix group
14:01:01 <dcoutts_> SyntaxNinja, and it'd probably want to be non-group writable
14:01:15 <SamB> I don't suppose I can have a repo for my XPCOM bindings project, even though I'm not doing SoC?
14:01:44 <dcoutts_> SamB, ask SyntaxNinja what the policy is.
14:01:59 <SamB> SyntaxNinja: what is the policy?
14:02:43 <dcoutts_> if darcs.haskell.org is going to get opened up more widely then I expect they'll want to setup non-login based repos
14:03:14 <dcoutts_> ie via darcs send --sign rather than having to give out unix accounts to everyone (which allows darcs push over ssh)
14:03:21 <SamB> ah, yes ;-)
14:03:44 <damg> is there a standard function to search for a sublist in a list?
14:03:58 <dcoutts_> SamB, and I don't think people have got round to pondering the admin & stuff involved with that
14:03:59 <eivuokko> Sounds like it's time to start fixing darcs' mail sending in Windows..
14:04:03 <jethr0> cale's favorite sublist :)
14:04:11 <damg> sth like indexOf [a] -> [a] -> Int/Bool ?
14:04:11 <SamB> but that *would* be a good bit of work
14:04:24 <jethr0> substr a b = any (a `isPrefixOf`) $ tails b
14:04:27 <SamB> it would be easier to go the unix-account way, probably...
14:04:28 <dcoutts_> eivuokko, or implement darcs push over http POST or something
14:04:46 <xerox> There also exist HTTP PU!
14:04:47 <eivuokko> dcoutts, I have done that.  Daan has done that.  Few others have done that.
14:04:48 <xerox> *PUT
14:04:51 <jethr0> damg: but sadly not in the std libs. maybe there's sth like in missingH
14:05:08 <dcoutts_> eivuokko, is that in current darcs versions then?
14:05:14 <SamB> but... I don't have an SSL certificate!
14:05:15 <damg> jethr0~# thanks
14:05:32 <Cale> and you can replace any with findIndex to get the index
14:05:33 <dcoutts_> SamB, they're not hard to make/handout
14:05:40 <SamB> yes, yes...
14:06:00 <eivuokko> dcoutts, Most of those were implemented as separate helper programs.  The patch tosuch thing to darcs' codebase wasn't accepted.  They don't apparently want it.
14:06:47 <Cale> > let findSublist xs ys = findIndex (xs `isPrefixOf`) $ tails ys in findSublist "or" "Hello, World!"
14:06:48 <lambdabot>  Just 8
14:07:04 <Cale> > "Hello, World!" !! 8
14:07:05 <lambdabot>  'o'
14:07:06 <xerox> Cale++
14:07:58 <Cale> damg: this is the really cool thing about laziness, is that it lets you program effectively in this way which would be wasteful and silly in a strict language
14:08:13 <Cale> (but which is really good as far as reusing components is concerned)
14:08:48 <jethr0> yes, laziness is the most powerful abstraction tool i've seen yet. best example is imo alpha-beta-search on a lazy tree
14:08:55 <damg> interesting, thanks :)
14:09:44 <Cale> > let findSublists xs ys = findIndices (xs `isPrefixOf`) $ tails ys in findSublists "abra" "abracadabra"
14:09:45 <lambdabot>  [0,7]
14:09:45 <jethr0> or in my raytracer i just write down all the formulas and haskell's lazyness takes care of only evaluating what's needed. instead of me writing "if needed then calc; ..."
14:10:09 <xerox> That is neat!
14:10:19 <norpan> it's not all roses though
14:10:31 <jethr0> norpan: no, we've had that discussion before :)
14:10:38 <jethr0> i mean, it's not all roses!
14:10:49 <Cale> Oh, it's all roses, but roses have thorns :)
14:10:53 <jethr0> haha
14:12:19 <norpan> a 20% thorn penalty
14:12:26 <Cale> The main place where laziness gets in the way is when you're taking a large body of data, and consuming it all in order to form a small piece of data. Those are essentially the only cases where you actually want strictness.
14:13:10 <Cale> (note that that's not the same as searching for a small piece of data in a large body of data -- that's actually what laziness is good at)
14:14:14 <Cale> It's more summarizing large bodies of data that is hard, since you end up building up gigantic expressions which consume lots of memory and possibly cause a stack overflow. 
14:14:42 <norpan> basically you want strictness when doing things that end up being strict anyway
14:14:49 <Cale> (since the small piece of data is more or less evaluated all at once, so you can't do any of the work until the very end)
14:15:11 <dcoutts_> dons, oops, sent you a repeated patch bundle, ignore it (or darcs apply will ignore it)
14:15:20 <Cale> Well, there are cases where it doesn't matter whether you're strict or lazy.
14:15:49 <norpan> except for the penalty
14:15:53 <Cale> (mainly, taking small pieces of data and turning them into other small pieces of data)
14:17:43 <Cale> I should also mention that I'm basically measuring "small" or "big" here based on the count of how many pieces of the value could conceivably be separately evaluated without evaluating the whole thing.
14:19:45 <norpan> there is also a difference in a fcuntion being strict in it's arguments and being strict in it's output
14:20:21 <dcoutts_> norpan, hmm, what's that then?
14:20:38 <dcoutts_> what does strict in it's output mean?
14:21:01 <norpan> for instance if it returns a list
14:21:21 <Cale> dcoutts: I presume that it means that it will produce a compound value which one cannot evaluate partially.
14:21:44 <dcoutts_> a function is always "strict in it's output" because if the result wen't demanded then the function would not have been called
14:21:55 <dcoutts_> it returns something in weak head normal form
14:22:12 <norpan> well maybe it's not well defined, but take bytestring unpack as an example
14:22:16 <Cale> right, but how much of that output will be constructed right away?
14:22:34 <Cale> just the first constructor, or the whole thing?
14:22:43 <dcoutts_> (which doesn't mean it can't return an infinite structure, infinite structures can be in weak head normal form too)
14:22:47 <Cale> (when demanded, of course)
14:22:50 <norpan> currently it will construct the whole list
14:22:58 <norpan> when the first list element is requester
14:23:26 <dcoutts_> norpan, so it's stricter than it needs to be
14:23:39 <norpan> that's what i mean by strict in it's output
14:23:47 <Cale> Or consider  amap f
14:23:56 <dcoutts_> ok, but it's always whnf
14:24:11 <norpan> well yes
14:24:30 * dcoutts_ goes home
14:24:55 <norpan> @localtime dcoutts_ 
14:24:56 <lambdabot> Local time for dcoutts_ is Thu May 25 22:24:34
14:24:59 <Cale> This is lazy in its input, but with an Array, it's lazy in output as well, but with a UArray, evaluation of the array will force all the applications of the function f at once.
14:25:38 <norpan> there are more forms than whnf
14:46:03 <SyntaxNinja> dcoutts, SamB: sorry, I'm busy, please email me :)
14:47:22 <cogumbreiro> on hugs i get this:
14:47:30 <cogumbreiro> > (1.1 * 100) - fromIntegral(truncate(1.1 * 100))
14:47:31 <lambdabot>  1.4210854715202004e-14
14:47:43 <cogumbreiro> exactly that
14:47:43 <cogumbreiro> :)
14:47:50 <cogumbreiro> how do I get an accurate value?
14:47:58 <cogumbreiro> it was supposed to be 0 not that value
14:49:27 <jethr0> cogumbreiro: are you familiar with limited precision floating point arithmetic?
14:50:04 <jethr0> for example IEEE floating points?
14:50:21 <cogumbreiro> jethr0, yes, I was asking if there is an accurate class of floating point
14:50:27 <jethr0> ah
14:50:28 <jethr0> sry
14:50:39 <jethr0> well, you could calculate in rationals
14:50:54 <cogumbreiro> thanks, i'll look into that
14:52:28 <jethr0> > (11%10 * 100) - fromIntegral(truncate(11%10 * 100))
14:52:29 <lambdabot>  0%1
14:54:59 <jethr0> there has been talk about an arbitrary precision floating point class, but i don't know it if it exists
15:10:26 <dcoutts> @localtime dons 
15:10:28 <lambdabot> Local time for dons is Fri May 26 08:03:59 2006
15:10:41 * dcoutts is most eager to talk to dons 
15:14:26 <ricebowl> a problem.
15:14:50 <ricebowl> foo :: Bounded a => ...; foo ... = ... where bar = maxBound :: a
15:14:56 <ricebowl> I have seen this before but don't know how to fix it
15:15:28 <ricebowl> I'm using maxBound in a where clause, and it *must* have the type of one of the variables in the outer scope
15:15:30 <xerox> That's rank-2 right?
15:15:35 <ricebowl> I have no idea
15:15:39 <xerox> I think -fglasgow-exts should do it.
15:15:52 <ricebowl> does that work even in GHCi?
15:16:01 <xerox> Yup.
15:16:16 <ricebowl> doesn't seem to
15:16:26 <xerox> Either call `ghci -fglasgow-exts' or once running type `:set -fglasgow-exts'.
15:16:40 <ricebowl> ah, ok
15:16:58 <ricebowl> still complains
15:17:13 <xerox> Another option is sticking `{-# OPTIONS_GHC -fglasgow-exts #-}' ontop of your module.
15:17:20 <xerox> What does it complain about exactly?
15:17:42 <ricebowl> did that already
15:17:48 <ricebowl> what's the address of the pastebin you use?
15:18:01 <xerox> lisppaste2: url
15:18:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:18:40 <lisppaste2> ricebowl pasted "foobar" at http://paste.lisp.org/display/20438
15:19:09 <xerox> What is the complain, I mean.
15:19:16 <ricebowl> Mask is a type representing known/unknown bits
15:19:30 <ricebowl> says that I need b to be an instance of Bounded
15:19:45 <ricebowl> but clearly if it were using the same definition of b as in insr...
15:20:47 <xerox> What about `-fno-monomorphism-restriction' ?
15:20:49 <xerox> I am not sure.
15:21:16 <ricebowl> nope...
15:21:19 <xerox> (It may be that -fglasgow-exts implies that)
15:21:25 <ricebowl> I've seen that problem before, but this time I can't work around it
15:21:45 <ricebowl> unless I set up some function like maxBound that extracts type from a parameter and then discards the parameter
15:21:47 <xerox> Maybe you could try to break up the definition in multiple top-level definitions.
15:21:56 <ricebowl> I don't see how
15:22:20 <ricebowl> if I wanted to inline the definition of msk, dval', and dmsk' then the type inferencer would figure it out without explicitly declaring the types
15:22:28 <ricebowl> but that makes it impossible to read
15:22:56 <xerox> No idea, maybe post on the mailing list.
15:23:44 <dcoutts> you need forall
15:23:51 <ricebowl> I never understood forall
15:24:04 <dcoutts> or types in the patterns
15:24:09 <dcoutts> the thing is...
15:24:14 <xerox> In the clauses?
15:24:21 <dcoutts> foo :: a -> ...; undefined :: a
15:24:35 <dcoutts> those two 'a's are not in any way related
15:24:39 <ricebowl> yes, I know
15:24:44 <dcoutts> it's like this:
15:24:45 <ricebowl> but my question is how to make them related
15:25:09 <xerox> You go the other way around, and let the inner `a' be whatever type, via the explicit quantification?
15:25:11 <dcoutts> foo :: forall a . (a -> ...); undefined :: forall a . a
15:25:19 <dcoutts> so what you do is:
15:25:38 <dcoutts> foo (x::a) = ... ... (undefined :: a)
15:25:55 <ricebowl> ah
15:26:06 <ricebowl> I see, I didn't realize you could stick a type quantifier on a parameter
15:26:15 <xerox> !
15:26:19 <dcoutts> ghc has a new way to do it with type sigs, but I don't know if it's in a released version of ghc yet
15:26:30 <dcoutts> ricebowl, it's another ghc extension
15:26:43 <dcoutts> the new way to do it with ghc is:
15:27:02 <dcoutts> foo :: forall a. a -> ...; foo = .... (undefined :: a)
15:27:03 <ricebowl> works now, that fixed it
15:27:23 <ricebowl> that doesn't make sense to me; could you give a more concrete example?
15:27:26 <dcoutts> is by usign an explicit forall, the type scopes over the body of the function
15:27:35 <dcoutts> is/ie.
15:27:58 <xerox> Makes sense...
15:28:49 <xerox> Is it a sort of dynamic scope, so that you can't override quantified tyvars?
15:30:15 <dcoutts> ricebowl, a vaugely more concrete example:
15:30:17 <dcoutts> foo :: Num n => forall n. n -> n
15:30:44 <dcoutts> foo = ...  (x :: n) ...
15:31:04 <dcoutts> so now the type var n in the body is bound by the forall in the type
15:31:14 <dcoutts> but *only* because we've added the forall
15:31:22 <dcoutts> without it, they're not connected
15:31:34 <dcoutts> the semantics here are a little odd
15:32:15 <dcoutts> the 'forall's shouldn't change the meaning like that, but it seemed less bad than any of the alternatives so that's what new versions of ghc do
15:32:28 <xerox> (That's what I meant, okay.)
15:32:35 <palomer> the forall in ghc doesn't make sense.
15:32:42 <xerox> ?palomer
15:32:43 <lambdabot> That's nuts!
15:32:45 <hyrax42> @index lift
15:32:45 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
15:32:45 <lambdabot> ParserCombinators.ReadPrec, Text.Read
15:32:48 <hyrax42> @type lift
15:32:49 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
15:32:49 <lambdabot>    (MonadTrans t, Monad m) =>
15:32:49 <lambdabot>    m a -> t m a
15:32:53 <palomer> they break alpha conversion
15:33:08 <dcoutts> palomer, really? how?
15:35:38 <ralejs> Â¨/leave
16:01:49 <Pegazus> hi, does anyone knows Martelli-Montanari MGU algorithm?
16:05:22 <Cale> I'll look it up
16:07:33 <Cale> do you have a question about it
16:07:35 <Cale> ?
16:10:39 <Cale> Pegazus: ?
16:12:28 <ricebowl> is there any way more clever to get all pair-wise combinations of an array than foo xs@(y:ys) = zip xs ys?
16:12:37 <ricebowl> hey Pegazo
16:12:52 <Pseudonym> zip cs (tail cs)
16:12:56 <Pseudonym> Or xs
16:13:11 <Cale> ricebowl: you're only looking for adjacent pairs?
16:13:16 <Pseudonym> This is really waht you need the S combinator for, though.
16:13:20 <Pseudonym> s zip tail
16:13:30 <xerox> ap zip tail
16:13:32 <Pseudonym> @pl \xs -> zip xs (tail xs)
16:13:32 <lambdabot> ap zip tail
16:13:35 <Pseudonym> @type ap
16:13:36 * xerox won!
16:13:37 <lambdabot> forall b (m :: * -> *) a.
16:13:37 <lambdabot> (Monad m) =>
16:13:37 <lambdabot> m (a -> b) -> m a -> m b
16:14:35 <xerox> Howdy Pseudonym (:
16:14:41 <Pseudonym> G'day.
16:14:44 <ricebowl> Cale - I was
16:14:49 <ricebowl> just realized that I'm an idiot
16:14:53 <ricebowl> foldr1 is what I want
16:14:55 <Pseudonym> xerox is a better lambdabot than lambdabot
16:15:10 <ricebowl> but I was still curious as to whether or not there was a more elegant solution than what I gave
16:15:13 <ricebowl> zip tail works I guess
16:15:17 <xerox> That's scarily the second time this phrase happen to be said.
16:15:22 <ricebowl> but I was curious as to whether there was a function
16:16:00 <Pegazus> hi ricebowl
16:41:29 <morans> hola
16:41:35 <morans> oops wrong channel
16:41:36 <morans> sorry
16:43:18 <mux> does anyone feel like trying to optimize some code further?
16:43:25 <mux> I'm stuck for now
16:44:44 <mux> http://mu.org/~mux/Main.hs
16:46:01 * mux pings *
16:46:45 <Cale> it randomly rearranges the input lines?
16:46:58 <mux> exactly
16:47:19 <mux> it uses an IOArray and Data.ByteString
16:48:51 <mux> if I got it correctly, I can't have an IOUArray of strings, or I could have an IOUArray of Ptr but they should to some fixed-size space, or some limitation of the sort
16:50:39 <Cale> Yeah, an IOUArray of strings, even if it was possible, would not be very different from an IOArray of strings.
16:51:53 <mux> profiling shows permutations and printLines are the main call centers
16:52:42 <Cale> Yeah.
16:53:08 <xerox> For those interested in SoC, Gamara: in about 50 minutes, we will have the lists up on code.google.com.
16:53:59 <dcoutts> @localtime dons
16:54:01 <lambdabot> Local time for dons is Fri May 26 09:47:32 2006
16:54:15 <mux> @localtime mux
16:54:19 <lambdabot> Local time for mux is Fri May 26 01:53:54 2006
16:54:29 <mux> ctcp time, *nods*
16:54:39 <mux> Cale: any ideas?
16:54:51 <Cale> mux: permutations will do some extra allocation, allocating list cells which quickly expire as they're consumed by shuffle
16:54:59 <mux> yeah
16:55:19 <Cale> you could rewrite shuffle so as to just do the permuting in-line.
16:55:30 <mux> I thought about maybe pushing that in the IO monad
16:55:38 <mux> and do it "iteratively"
16:56:02 <Cale> State will do.
16:56:11 <Cale> (If that)
16:56:33 <Cale> a helper function is probably light enough too
16:57:18 <Igloo> Do you know how much slower than C it is?
16:57:20 <Cale> actually, reparametrise shuffle so that it takes the lower as well as the upper bound to shuffle
16:57:29 <mux> Igloo: yeah, a lot slower :-)
16:57:35 <Igloo> How much?
16:57:53 <Cale> and then just increment the lower bound in your recursive step, using the bounds as a parameter to your random generator
16:58:19 <Cale> (and swap the first element of the range with that which was picked)
16:58:38 <Igloo> If you use the unsafe array indexing functions then you should probably be able to get within a factor of 2, maybe less. With the safe indexing functions you'll be a way off that, I think
16:58:42 <mux> jot 100000 | shuffle > /dev/null takes 1.3s with the Haskell version
16:58:55 <mux> it takes ~ 0.2s with the C version
16:59:37 <mux> Cale: *nods* thanks, will try that now
17:00:13 <Cale> mux: also, you may want to seq the increment, though try it first without. It might not make a big difference.
17:00:39 <Igloo> Try changing your array to count from 0, and then compare readArray/writeArray with unsafeRead/unsafeWrite
17:01:08 <RvGaTe> Im getting interested in the haskell stuff, but im unsure what you can really do with it, (i haven't used haskell YET), basicly i need to see some example programs created in haskell, just to get me convinced to download a compiler...
17:01:26 <Cale> RvGaTe: the compiler you'll likely download is one :)
17:01:47 <Cale> There's darcs, which is a rather nice revision control system
17:01:59 <Cale> There's pugs, which is a working perl 6 interpreter.
17:02:14 <Cale> Yi, a programmable text editor
17:02:21 <Cale> Lambdabot, an IRC bot
17:02:30 <Cale> @yow
17:02:30 <lambdabot> SANTA CLAUS comes down a FIRE ESCAPE wearing bright blue LEG WARMERS
17:02:30 <lambdabot> ... He scrubs the POPE with a mild soap or detergent for 15 minutes,
17:02:30 <lambdabot> starring JANE FONDA!!
17:02:39 <Cale> @modules
17:02:40 <lambdabot> Unknown command, try @list
17:02:40 <mwc> RvGaTe, the bottom line is that once you start using it, you'll never want to use anything else
17:02:43 <Cale> @list
17:02:43 <lambdabot> list [module|command]. Where modules is one of:
17:02:43 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
17:02:43 <lambdabot> version vixen where
17:03:00 <mwc> I'm an applied mathematician, lots of numerical stuff, and I've almost forsworn C
17:04:25 <RvGaTe> Basicly i need an easy to understand language to create simple applications to do simple tasks... basicly starting with reading files/folders and doing things with that information
17:04:49 <Cale> Try Haskell then, I use it for lots of small jobs.
17:05:13 <mwc> some people would tell you that Python is great for that. I agree that Haskell is excellent for the full spectrum of stuff
17:05:18 <mwc> especially for one-off programs
17:05:40 <mwc> the interactive top level lets you get the stuff working pretty quick, and then I find I usually write a five line main function to drive it
17:05:55 <Cale> You can even do some pretty complicated things quite easily.
17:06:02 <Pseudonym> It depends on the task, though.  I still prefer Perl for hard-core semi-structured text processing guff.
17:06:19 <Pseudonym> But then I occasionally find myself rewriting it in Haskell when I need to do something mildly complex. :-)
17:06:25 <mwc> In my numeric modelling class last year, I was using haskell, most students used matlab or maple. I still finished in about a tenth the time and went on to implement the graduate student extra credit stuff.
17:06:28 <dons> moin
17:06:37 <Kasperle> speaking of lambdabot: any ideas as to why this happened?: 23:28 DCC received CTCP SEND with invalid parameters from lambdabot
17:06:44 <Pseudonym> Cool, what were you modelling?
17:06:57 <dons> Kasperle: yes. we got pseudo-spammed by a bug. fixed now.
17:07:02 <Kasperle> ah
17:07:06 <mwc> Pseudonym, it's essentially monte carlo methods
17:07:20 <RvGaTe> So, where do i "start" with haskell (for windows)
17:07:31 * vincenz once wrote a cool simulator in maple... give it any 3d surface and it would simulate a perfectly bouncy ball on top of it
17:07:32 <dons> people were able to print arbitrary strings (including ctcp strings). so they could pretend to be lambdabot asking for ctcp stuff.
17:07:40 <vincenz> great to simulate how electrons move in a charge-field
17:07:43 <dons> harmless, since nothing could actually be done.
17:07:44 <Cale> RvGaTe: I'd probably start by grabbing a copy of GHC/GHCi (they come together)
17:07:46 <dons> but annoying
17:07:52 <mwc> RvGaTe, I think you'll find GHC works best on windows
17:08:02 <Cale> actually, I should point you at the steps page
17:08:07 <vincenz> > x = v; v = v+1
17:08:08 <lambdabot>  parse error on input `='
17:08:11 <vincenz> >  v; v = v+1
17:08:12 <lambdabot>  Exception: <<loop>>
17:08:16 <Pseudonym> I've dumped my Eulerian fluid simulator, and I'm about half way through writing a SPH model instead.
17:08:24 <RvGaTe> GHC stands for Graphical Haskell Compiler? :P
17:08:26 <mwc> Pseudonym, we'd do things like find the curie temperature of a given magnetic material model
17:08:27 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
17:08:31 <Cale> RvGaTe: Glasgow
17:08:33 <Pseudonym> Cool.
17:08:33 <Kasperle> dons: ah.
17:08:36 <vincenz> Pseudonym: eulerian fluid simulator?
17:08:38 <Cale> RvGaTe: Or Glorious ;)
17:08:40 <Pseudonym> Yup.
17:08:47 <vincenz> Pseudonym: sounds interesting
17:09:20 <Pseudonym> http://andrew.bromage.org/eddies.mpeg
17:09:22 <Pseudonym> As an example.
17:09:36 <Kasperle> dons: that message looks like some DoS attempt on some irc clients, too. i seem to recall there being some kind of vulnerability a while back which would be triggered by some malformed DCC/CTCP requests
17:10:17 <mux> Cale: can you reload? I've uploaded a new version: it's much simpler, but doesn't seem to be faster, I'll profile now
17:10:56 <Pseudonym> http://andrew.bromage.org/dissipation_rates.mpeg <- Experimenting with substances which dissipate at different rates.
17:11:26 <mux> Cale: mm, shuffle now does a lot of allocs
17:12:17 <Cale> mux: you can save a few by making it take (x,n) as a pair
17:12:30 <mux> ok
17:12:56 <vincenz> Pseudonym: don't quite get the coloring system
17:13:23 <Pseudonym> The colours don't mean anything in the first one.
17:13:41 <Pseudonym> Although the yellow (actually green, but it's on top of red) dot is a highly concentrated drop in the fluid.
17:13:56 <Pseudonym> In the second one, the different colours dissipate at different rates.
17:14:22 <Pseudonym> So the blue spreads quickly, but the green doesn't.
17:14:46 <Pseudonym> They're just visualising scalar fields.
17:15:01 <Pseudonym> Could be substance concentration, temperature or whatever.
17:15:23 <Pseudonym> http://andrew.bromage.org/fluid.mpeg <- This one visualises temperature.
17:15:29 <Pseudonym> The black substance is colder, so it should sink.
17:15:30 <vincenz> so where does the white come from
17:15:41 <Pseudonym> That's when red, green and blue sit on top of each other.
17:15:43 <Pseudonym> :-)
17:15:49 <vincenz> how does it work?
17:16:10 * RvGaTe is downloading ghc for windows
17:16:17 <mux> Cale: mmm, I've changed that into a strict pair (new file uploaded) it seems to makes things worse
17:16:27 <Cale> mux: hmm
17:16:42 <Cale> mux: how much allocation is it doing?
17:16:57 <Pseudonym> vincenz: It's tricky.
17:17:10 <vincenz> finite element?
17:17:16 <Cale> mux: I didn't mean to use another pair type
17:17:22 <Pseudonym> No, finite difference.
17:17:39 <mux> Cale: no difference
17:17:50 <mux> in allocs
17:17:53 <mux> want a bare pair?
17:17:53 <Pseudonym> The fluid is incompressible, so you can describe its state by simply storing the velocity of the fluid in a 2D array.
17:18:08 <Cale> mux: yeah, because then you can pass it to randomR without reconstructing it
17:18:48 <Pseudonym> Then it's a four-step process to solve each term of the incompressible Navier-Stokes equation.
17:18:51 <vincenz> Pseudonym: erm...well how do you ensure the gaussian of all regions are zero
17:19:00 <Pseudonym> Gaussian?
17:19:06 <vincenz> inflow/outflow
17:19:12 <Pseudonym> Divergence, you mean.
17:19:30 <Pseudonym> Ah, that's the clever bit.
17:19:42 <Pseudonym> First thing you do is find the pressure.
17:19:51 <mux> Cale: it's still the same, new file uploaded again
17:20:02 * vincenz nods quietly
17:20:05 <Pseudonym> If u is the velocity field, you can find the pressure by solving:
17:20:07 <Cale> mux: hmm
17:20:14 <Pseudonym> Del^2 p = div u
17:20:20 <Pseudonym> Del^2 is the Lagrangian.
17:20:38 <vincenz> you mean the square matrix d/d^2x, d/dxdy..
17:20:45 <vincenz> It's been a while :/
17:20:49 <Pseudonym> That's a sparse linear system with one unknown per element in the grid.
17:21:13 <Pseudonym> Well, per non-boundary element.  I'll get back to that in a moment.
17:21:20 <Cale> mux: I don't know where it's doing all its allocation then -- aside from getting the new StdGen and random value
17:21:24 <vincenz> what's the langragian again?
17:21:26 <Pseudonym> Then you basically project onto the divergence-free part.
17:21:43 <Pseudonym> Lagrangian is d^2/dx^2 + d^2/dy^2 + d^2 / dz^2
17:21:49 <Pseudonym> All derivatives are partial.
17:21:51 <vincenz> ah summation
17:21:57 <vincenz> wait
17:22:00 <vincenz> d^2/dx^2
17:22:04 <vincenz> or d^2/d^2x
17:22:11 <Pseudonym> The divergence-free part is u - grad p
17:22:20 <Pseudonym> The former.
17:22:39 <Pseudonym> Del is (d/dx, d/dy, d/dz)
17:22:42 <vincenz> so basically a . product of the single derivative vector
17:22:46 * vincenz nods
17:22:52 <Pseudonym> The lagrangian is the dot product of Del by itself.
17:22:55 <Pseudonym> Yeah.
17:23:09 <vincenz> right
17:23:23 <Pseudonym> Here's what happens if you forget to leave boundary cells out of the pressure equation:
17:23:28 <Pseudonym> http://andrew.bromage.org/bug.mpeg
17:23:58 <adu> :)
17:24:03 <Cale> mux: maybe add some SCC's
17:24:05 <Pseudonym> The computer bug as artist, indeed.
17:24:12 <vincenz> still downloading
17:24:33 <Pseudonym> Basically, everything is fine until the advected flow hits the boundary.
17:24:35 <vincenz> oh
17:24:42 <vincenz> it's a torus world
17:24:44 <Pseudonym> At that point, you're solving a singular linear system.
17:24:52 <Pseudonym> No, not even that.
17:25:02 <Pseudonym> Although that may have been an additional bug.
17:25:47 <RvGaTe> Pseudonym: is it normal that the yellow dot dissapears?
17:26:00 <Pseudonym> Yes, it's not a high enough concentration.
17:26:19 <Pseudonym> It's like putting one drop of milk into a cup of coffee.
17:26:21 <Pseudonym> It dissapears.
17:26:26 <Pseudonym> disappears
17:26:39 <RvGaTe> i understand that, but in an earlyer example, it didn't
17:26:45 <Excedrin> how long did it take to generate that?
17:26:53 <vincenz> that's why adding an infinite amount of milk to coffee still makes it taste like having no milk
17:26:54 <Pseudonym> That's because I used a much higher concentration for that simulation.
17:27:19 <Pseudonym> Excedrin: First thing you have to understand is that I dropped one frame out of ten.
17:27:28 <Pseudonym> Sorry, dropped NINE out of ten.
17:28:13 <Pseudonym> It took a couple of hours, probably.
17:28:43 <vincenz> heh..haskell is great for simulations... just make an infinite lists of approximations and then run until either time runs out for that frame or required correctness is achieved
17:29:02 <Pseudonym> Oh, I didn't use Haskell for the simulation, BTW.
17:29:10 <Pseudonym> Though I did use it for the visualisation.
17:36:23 <dcoutts> @localtime dons
17:36:25 <lambdabot> Local time for dons is Fri May 26 10:29:55 2006
17:36:48 * dcoutts wonders where dons has got to
17:36:56 * dcoutts is impatient :-)
17:38:10 * RvGaTe gets iritated becouse of ghc, probably needs sleep
17:38:48 <machack666> is providing a default implementation for a function and a specialized version for objects which are a member of a particular typeclass a valid/possible approach to defining a function?
17:39:29 <Pseudonym> I'm not sure what you're getting at, mackhack, but...
17:39:31 <machack666> similar to pattern matching based on specific data constructors
17:39:41 <machack666> but at the class/implementation level
17:39:51 <Pseudonym> It's perfectly valid to provide a universal instance of a typeclass, then override for specific types.
17:39:58 <Pseudonym> An example is Show [a]
17:40:10 <Pseudonym> There's an obvious way to Show a list of a if a is showable.
17:40:15 <Pseudonym> But Show [Char] is specialised.
17:40:18 <machack666> s/implementation/instance/
17:41:09 <dons> dcoutts: ?
17:41:12 <dcoutts> dons!
17:41:14 <dons> reading patches! that's what.
17:41:14 <vincenz> Pseudonym: not quite
17:41:24 <vincenz> Pseudonym: Show [a] always does the same
17:41:28 <vincenz> Pseudonym: it calls showList of Show a
17:41:34 <vincenz> Pseudonym: and that's where Char specializes
17:41:34 <dcoutts> dons, ah my flood of patches :-)
17:41:35 <Pseudonym> Ah, yes.
17:41:40 <dcoutts> dons, well I've got more...
17:41:41 <Pseudonym> You're right.
17:41:44 <dons> good!
17:41:50 <vincenz> there is no specialization ala templates
17:41:54 <vincenz> it's gotta be non overlapping
17:42:01 <Pseudonym> Well, not in H98, anyway.
17:42:33 <Pseudonym> In Haskell, everything is fair game if you know what you're doing and have good taste.
17:42:57 <Pseudonym> Except linear implicit parameters.  They're just wrong.
17:43:22 <machack666> in this case instances (using the word loosely) are either members of a class or are not; by virtue of being in the typeclass, there are functions which we can use to short-circuit part of the overall process, otherwise we need to refer to the old/slow defaults.
17:43:24 <Pegazus>  Except linear implicit parameters.  They're just wrong. --> what are linear implicit parameters?
17:43:43 <Pseudonym> Pegazus: I'm sorry I mentioned them.
17:44:03 <Pegazus> why? O_o
17:44:06 <Pseudonym> Look in the GHC manual if you're curious, but beware.  Best not to know about false gods.
17:44:15 <Pegazus> :(
17:48:08 <machack666> so, no ideas on this type of specialization?
17:48:35 <Pseudonym> If you -fallow-overlapping-instances, it's easy.
17:48:41 <Pseudonym> class MyFun a where
17:48:50 <Pseudonym>     myFun :: a -> Something
17:48:55 <Pseudonym> instance MyFun a where
17:49:04 <Pseudonym>     myFun x = defaultImplementation x
17:49:10 <Pseudonym> instance MyFun Char where
17:49:17 <Pseudonym>     myFun c = specialisedImplementation c
17:49:23 <Pseudonym> Right?
17:50:04 <machack666> ah; I didn't think of having the (so-called) target function in a class itself.  Thanks.
17:52:22 <Pseudonym> If you don't want to allow overlapping instances, there's a simple generalisation:
17:52:45 <Pseudonym> Basically, you make defaultImplementation a default implementation, but you have to declare an explicit instance for every use.
17:52:48 <Pseudonym> Even though it's empty.
17:53:02 <Pseudonym> Actually, that may require -fallow-undecidable-instances
17:53:50 <machack666> -fallow-overlapping-instances is fine in this case.  What are the tradeoffs? H98 compat, or some performance issues?
17:54:17 <Pseudonym> H98 compatibility is the biggie.
17:54:24 <heatsink> @lisppaste
17:54:24 <lambdabot> Unknown command, try @list
17:54:27 <heatsink> @paste
17:54:28 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:54:29 <Pseudonym> The other problem is that you may allow overlapping instances in other places where you don't want it.
17:54:35 <Pseudonym> i.e. some errors may not be detected
17:54:51 <Pseudonym> Seems unlikely in your case, but I thought I'd mention it.
17:54:58 <heatsink> beh, I'm not registered there
17:59:56 <lisppaste2> heatsink pasted "HashTable state transformer" at http://paste.lisp.org/display/20446
18:00:32 <heatsink> Am I going about making a state-transformer version of Data.HashTable in the right way?
18:09:28 <SamB> @hoogle assert
18:09:29 <lambdabot> Control.Exception.assert :: Bool -> a -> a
18:09:29 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
18:09:29 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
18:10:05 <SamB> @more
18:12:39 <SamB> okay, what gives an AssertionFailed exception?
18:12:51 <SamB> @hoogle AssertionFailed
18:12:52 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
18:19:42 <SamB> hmm, this error message is messed up!
18:19:57 <SamB> or maybe I forgot to import FPS qualified...
18:20:18 <SamB> okay, it still doesn't use the name I used!
18:33:05 <palomer> >:o
18:34:12 <SamB> Control.Exception.assert should be marked as magical in hoogle's output...
18:34:52 <palomer> is it really magical?
18:34:59 <SamB> a little!
18:36:24 <SamB> my error messages show me that it has been replaced with GHC.Err.assertError "Typelib.hs:259:21-26"#...
18:37:51 <dons> hey, I see our projects are now up: http://code.google.com/soc/haskell/about.html
18:39:06 <SamB> oh, great! now I can understand my error message!
18:44:08 <SamB> wow. My code is now typechecking, and I wasn't expecting any type errors that didn't happen, and I'm not getting any warnings about unimplemented methods ;-)
18:46:05 <heatsink> why are there two Language.C?
18:47:07 <dons> oh, that's weird.
18:47:23 <dons> bug in their script, I suppose.
18:48:13 <dons> all the links are givine me 404s anyway
18:48:48 <heatsink> mkay
18:50:47 <SamB> hmm...
18:51:02 <SamB> wish I could get a traceback for this...
18:51:26 <SamB> my code is trying to read past the end of file...
18:53:35 <nn2> how dues this language work got me stumpd
18:53:44 <dons> nn2?
18:53:51 <dons> how does haskell work?
18:54:02 <SamB> that is implementation specific!
18:54:19 <dons> hehe
18:54:20 <SamB> (really, could you be a little more specific in your question?)
18:54:46 <SamB> at least, point to something confusing ;-)
18:54:59 <nn2> main =
18:55:13 <nn2> onily points to one comand
18:55:24 <nn2> where are the others
18:55:28 <SamB> ah, well, in Haskell, main is a value of type IO ().
18:55:41 <nn2> sam talk on my serv ok
18:55:54 * SamB notices that nn2 is his friend ;-)
18:56:01 <dons> ah.
18:56:10 <dons> welcome to haskell, nn2.
18:56:44 <SamB> if you want more commands, you could use a "do"
18:56:58 <dons> nn2, briefly, main = f ; f = g ; g = print "hello", for example :) 
18:57:09 <dons> though it deepends what you mean by "points   to one command"
18:57:16 <SamB> what was the program you were looking at, anyway?
18:57:25 <nn2> yours
18:57:31 <nn2> ???
18:57:32 <lambdabot> Maybe you meant: . id pl v wn
18:57:39 <dons> nn2, also, have you seen the examples on haskell.org ?
18:57:51 <dons> there's lots of tutorials, and example code there.
18:57:58 <nn2> aut to look a that
18:57:59 <SamB> oh, you mean that Hello, World program?
18:58:12 <dons> > let f = g ; g = h ; h = 1 = 2 ; in f
18:58:12 <lambdabot>  parse error on input `='
18:58:21 <nn2> yes
18:58:21 <dons> > let f = g ; g = h ; h = 1 + 2  in f
18:58:22 <lambdabot>  3
18:58:26 <SamB> hehe
18:58:33 <nn2> setup chan serv
18:58:42 <nn2> can we talk there
18:58:50 <dons> ?wiki Haskell_in_5_steps
18:58:51 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
18:58:52 <dons> might be useful
18:59:12 * SamB doesn't remember nn's new IP address
18:59:30 <nn2> thanks dons 
19:00:11 <dons> Lemmih: around?
19:00:22 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:00:27 <nn2> srv256.homelinux.net
19:00:32 <Cale> that'll answer the question too nn2
19:00:44 <SamB> oh, right, you got the name working...
19:01:00 <nn2> and chan serv
19:08:27 <hyrax42> in a combined monad, what exactly is the purpose of lifting?
19:09:52 <SamB> > 1 + 1
19:09:53 <lambdabot>  2
19:10:02 <SamB> nn2: see how lambdabot computes the answer?
19:10:04 <dons> to lift a value or action in the inner monad to the outer one.
19:10:27 <dons> hyrax42: so I can be in my custom monad, say, one carrying extra state around, but I can still: lift $ print "foo", to do IO.
19:10:42 <dons> the result of lift $ print .. , will have the type of my custom monad, not IO,.
19:10:51 <hyrax42> hm
19:11:10 <hyrax42> well I have StateT s (Reader e) as my monad
19:11:20 <SamB> @source
19:11:21 <lambdabot> lambdabot 3p12, GHC 6.4.1 (Linux i686 3.20GHz)
19:11:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:11:51 <hyrax42> but I don't seem to need to use lift to use ask/asks for the reader
19:13:09 <hyrax42> also in your example, that presupposes that the custom monad includes IO somewhere?
19:14:45 <Cale> hyrax42: that's because there's an instance (MonadReader r m) => MonadReader r (StateT s m)
19:15:00 <hyrax42> ah
19:15:13 <Cale> hyrax42: he's specifically assuming that you're transforming IO in that example.
19:15:22 <dons> yeah, just an example.
19:15:26 <hyrax42> there is no "IOT" is there
19:15:30 <Cale> right
19:15:45 <Cale> (such a thing wouldn't really make much sense)
19:16:23 <hyrax42> so in my case, I don't seem to need to use lift?
19:16:31 <Cale> right
19:16:33 <hyrax42> due to the instance
19:16:37 <Cale> exactly
19:16:49 <hyrax42> largely I guess you'd need lift if IO is in there somewhere?
19:17:02 <Cale> but you would need to use lift if you wanted to use an action which was specifically typed for the Reader monad
19:17:20 <Cale> (and not a general MonadReader)
19:17:32 <hyrax42> hmm
19:17:38 <hyrax42> so that's what it means in all about monads
19:17:47 <hyrax42> where it says allows more modular/uncoupled code
19:18:19 <hyrax42> you could define your actions only to use the monad that they actually need
19:18:20 <Cale> yeah, most likely that's what they're referring to
19:18:25 <hyrax42> and then lift
19:18:46 * palomer thinks this is getting too philosophical for his tastes
19:18:55 <Cale> palomer: ?
19:19:00 <palomer> !
19:19:02 <palomer> @palomer
19:19:02 <lambdabot> Brump!
19:19:45 <Cale> palomer: But what, if anything, is "this"? Can "this" really be said to exist?
19:20:13 <Cale> hehe
19:20:33 <Cale> nn2: how are you finding things?
19:21:48 <palomer> there is no "this"
19:23:26 <SamB> nn2: maybe we should just talk here ;-)
19:23:52 <SamB> I am not sure you are ready to build lambdabot yet, considering I'm not sure that you can still build it with GHC 6.2...
19:24:37 <mlh> "This is this. This ain't something else. This is this"  -- Robert de Niro in "The Deerhunter"
19:25:11 <SamB> this is a conversation.
19:25:15 <SamB> at least, I think it is!
19:25:19 <SamB> I could be mistaken.
19:28:55 <heatsink> No, that was a monologue.
19:29:02 <heatsink> Close, though.
19:29:26 <Pseudonym> > (); fs = flip seq } in "\n\1ACTION gets hacked again\1" `fs` let {
19:29:27 * lambdabot gets hacked again
19:29:47 <Pseudonym> No, dons, I don't have a patch.
19:29:49 <heatsink> wow
19:29:49 <dons> bah
19:30:28 <dons> looks like i'll need an expression parser after all
19:30:37 <Pseudonym> Yeah, I don't see how to avoid it.
19:30:52 <dons> yep. 
19:31:08 <dons> @quit
19:31:54 <dons> though I wonder why my leading space fix didn't work.
19:32:09 <Pseudonym> The leading \n took care of that.
19:32:14 <dons> ah.
19:32:40 <dons> we could strip \ns though
19:32:46 <Pseudonym> I like the flip seq approach.
19:32:57 <Pseudonym> Useful function.  Should be built-in.
19:32:58 <dons> super tricky, i agree.
19:33:31 <Pseudonym> Though you could have waited until I'd come up with a quine. :-)
19:34:27 <dons> well, i just assumed some douche bag would start ctcp spamming. it was so ridiculous yesterday, i wanted to avoid that happening again
19:34:44 <nn2> sam come back
19:34:45 <Pseudonym> Incidentally, I almost got it with (++) instead of `fs`
19:34:52 <dons> now, i do explicitly strip leading nls, i wonder why that didn't work.
19:35:19 <nn2> sam come back
19:35:28 <nn2> you pinged out
19:36:26 <Cale> nn2: what's up?
19:36:39 <SamB> yeah, dialup went down...
19:36:41 * SamB took a bit to notice
19:37:31 <Pseudonym> > (); f x _ = x } in "\n\1ACTION gets hacked again\1" `f` let {
19:37:32 <lambdabot> just seeing how offtopic i could get everyone
19:37:39 <Pseudonym> Actually, that would have worked too.
19:38:34 <Cale> const
19:39:46 <Cale> > (); in "\n\1ACTION gets hacked again\1" `const` let {
19:39:47 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
19:39:48 <Cale> perhaps
19:39:57 <Pseudonym> True.
19:40:04 <Pseudonym> My first approach was something like this:
19:40:05 <Cale> interesting that now it's giving us keal
19:40:08 * SamB laughs out loud
19:40:18 <Pseudonym> > "" } in "\n\1ACTION gets hacked again\1\n" ++ let {
19:40:18 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
19:40:21 <Pseudonym> But that was unclean.
19:40:51 <SamB> @. elite eval "" } in "\n\1ACTION gets hacked again\1\n" ++ let {
19:40:52 <lambdabot> compose module failed: Parse error: "eval"
19:41:01 <SamB> hmm.
19:41:06 <Pseudonym> @pl "" } in "\n\1ACTION gets hacked again\1\n" ++ let {
19:41:06 <lambdabot> (line 1, column 4):
19:41:06 <lambdabot> unexpected "}"
19:41:06 <lambdabot> expecting variable, "(", operator or end of input
19:41:23 <SamB> @eval
19:41:23 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
19:41:28 <SamB> okay...
19:41:30 <dons> strugglying there, Pseudonym   :)
19:41:33 <Cale> > 1 + 1
19:41:33 <Pseudonym> :-)
19:41:34 <lambdabot> can haskell compile flash animations and java apps?
19:41:37 <SamB> Someone hacked the eval plugin ;-)
19:41:46 <dons>  @eval is unloaded.
19:42:00 <Cale> ah, spell checking :)
19:42:04 <Cale> hehe
19:42:08 <dons> instead, we have keal, via spell checking, yep.
19:42:14 <SamB> oh, heh
19:42:21 * SamB laughs even louder
19:42:36 <Cale> There really ought to be a cleaner way for plugins to register shorthand command prefixes
19:42:53 <dons> its a bit of a hack, atm.
19:42:59 <SamB> nn2: seriously, you need to know what to add to your sources.list so you can install 6.4.x
19:43:04 <dons> it could be integrated into the Module type, quite easily, though
19:44:17 <Pseudonym> Anyway, my work here is done.  Lunch now. :-)
19:44:30 <dons> thansk Pseudonym. my work just begins.
19:44:34 <Pseudonym> :-)
19:45:20 <dons> might be ok if i can track down why my leading newline stripping failed.
19:45:34 <dons> in the longer term, integrating an expression parser is needed, though
19:46:01 <SamB> that wouldn't be so hard, would it?
19:46:16 <dons> i can't find a standard library with one, i think we'll have to roll our own.
19:46:23 <dons> maybe 1.5 hours work.
19:46:27 <SamB> well, you would need the GHC API
19:46:38 <dons> nah. we only accept h98
19:46:47 <dons> so using the many h98 parsers is fine.
19:47:03 <SamB> wouldn't it be less work, though?
19:47:04 <dons> but we we want a hook to parse expressions only.
19:47:18 <dons> no, it would mean lambdabot depends on ghc 6.5
19:47:28 <SamB> oh, well, true ;-)
19:47:34 <dons> and each @eval call invoked both ghc-api, and then ghc.
19:47:40 <dons> too heavyweight.
19:47:52 <SamB> what do you add to sources.list to get GHC 6.4.x?
19:48:09 <SamB> Debian peoples?
19:48:51 <dons> ah, my function dropNL only drops from the end.
19:48:52 <dons> stupid name
19:51:43 <dons> @quit
19:52:18 <dons> @bot
19:52:25 <SamB> you had to rebuild the whole thing?
19:52:28 <lambdabot> :)
19:52:32 <dons> > (); fs = flip seq } in "\n\1ACTION gets hacked again\1" `fs` let {
19:52:33 <lambdabot>  ACTION gets hacked again
19:52:45 <dons> i've just been playing with static lambdabot recently
19:53:04 <dons> since i had to move her home, and i didn't bother installing hs-plugins. i should do so.
19:53:25 <SamB> oh, that still works?
19:53:27 <dons> so the fix means that at least that's not a useful action.
19:53:36 <dons> what, static lambdabot?
19:53:44 <SamB> yes
19:53:53 <dons> yeah, that's the default. needed for profiling, btw.
19:54:08 <dons> make dynamic=yes gives you the plugin version.
19:54:10 <heatsink> SamB: are you getting the package with -t testing?
19:54:25 <dons> since its now buildable as a command line ap, plugins aren't so useful for the majority of users.
19:54:29 <heatsink> SamB: stable is only at 6.2.2
19:54:47 <SamB> heatsink: its not my system ;-)
19:54:51 <SamB> what does testing have?
19:54:56 <heatsink> 6.4.1
19:55:00 <SamB> oh, okay.
19:55:44 <SamB> so if my friend adds testing repositories to his sources.list, will he get packages from testing or from stable?
19:55:53 <dons> @where hsx
19:55:54 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
19:56:02 <SamB> (without specifying -t or a specific version)
19:58:42 <dons> ah, the project details are now up: http://code.google.com/soc/haskell/about.html
19:58:48 <dons> (the links work)
19:59:30 <heatsink> SamB: there's some priority scheme whereby apt-get decides which version to get
20:00:08 <heatsink> Your friend will have to adjust the priorities so that the testing version is retrieved rather than the stable version.
20:00:31 <SamB> I was just checking to make sure that the stable version would remain default ;-)
20:02:19 <stepcut> SamB: I think, in fact, that the stable version won't be the default
20:02:26 <SamB> oh
20:02:29 <SamB> okay.
20:02:50 <stepcut> in general, apt-get pulls in the highest version number it can find -- unless you have pinning setup
20:03:06 <stepcut> but, I don't think pinning is setup by default
20:04:51 <ell-hask> So, no matter how much I look at monads, I can't get the simplest thing done with them
20:05:29 <dons> some of these other SoC project are interesting, Software Transactional Memory for Parrot, for example.
20:05:40 <dons> these perl guys seem to have become all lambdafied.
20:05:52 <ell-hask> If I post ~8 lines, would someone be willing to comment on why it is not a valid Monad instance?
20:08:13 <hyrax42> ell-hask: code should go to a paste thingy
20:08:20 <hyrax42> ell-hask: I'm not guaranteeing i can help!
20:08:23 <hyrax42> @where paste
20:08:23 <lambdabot> http://paste.lisp.org/new/haskell
20:08:49 <SamB> hmm, my friend just got himself knocked off his own IRC server for excess flooding...
20:09:15 <lisppaste2> ell-hask pasted "Bad Monad instance" at http://paste.lisp.org/display/20451
20:09:48 <ell-hask> Neat script... I'll have to remember that
20:09:56 <dons> SamB. heh.
20:10:19 <stepcut> ell-hask: I see your problem (atleast one of them) hold on
20:10:42 <ell-hask> stepcut: Roger, thanks
20:14:19 <stepcut> ell-hask: hrm, I found a second problem :-/
20:14:36 <ell-hask> :(
20:14:58 <Cale> ah, a Writer monad?
20:15:17 <Cale> why is this a bad instance?
20:15:29 <ell-hask> Cale: Are you talking to me?  I've heard of the writer monad, but I am just now learning monads in general
20:15:31 * palomer has never found a need for the Writer monad
20:15:44 <ell-hask> Cale: It is a bad instance because ghci and hugs both hate it.
20:16:17 <Cale> oh, you have an extra Test $ there
20:16:25 <Cale> Test (a,True) >>= f0 = f0 a
20:16:41 <stepcut> Cale: the previous line will not type check either
20:17:21 <Cale> ah, right, that too
20:17:33 <ell-hask> Cale/stepcut: No it won't, I confess confusion and frustration at the Monad concept and use.
20:17:35 <stepcut> Cale: since he does not apply the function, it  forces the type to, a -> (a -> m a) -> m a
20:17:39 <Cale> right
20:18:01 <Cale> you really want to apply the function in any case
20:18:13 <Cale> then you have to decide what to do with the boolean values
20:18:25 <ell-hask> Inside the function f0?
20:18:47 <Cale> f0 a returns something of type Test b
20:19:11 <ell-hask> Yes, I've got that and removed the extra Test $ from the True case. 
20:19:14 <stepcut> ell-hask: your real problem is that, data Test a = Test (a, Bool), is not a very useful thing to turn into a Monad 
20:19:19 * dons adds a Haskell parser to lambdabot
20:19:30 <Cale> It's an okay thing to turn into a monad though
20:19:50 <ell-hask> stepcut: It would be useful to me!  I just want to string together operations and have a 2nd result (Integer for the practical case) tell me what failed
20:19:52 <stepcut> I suppose the bools could be AND'd or something
20:20:12 <Cale> yes
20:20:17 <SamB> dons: may you get better parse errors than the ones I get from my XPCOM typelib parser!
20:20:22 <Cale> that's probably exactly what is meant
20:20:23 <dons> :)
20:21:16 <Cale> You'd get an equivalent monad by using Writer Bool, and writing an instance Monoid Bool where mempty = True; mappend = (&&)
20:22:13 <SamB> oh, great, I broke the typing
20:22:41 <SamB> @hoogle trace
20:22:41 <lambdabot> Debug.Trace.trace :: String -> a -> a
20:22:41 <lambdabot> Debug.Trace :: module
20:22:41 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
20:23:48 <stepcut> ell-hask: With your current monad, if you have, f1 >>= f2 >>= f3 -- and 'f2' fails, you still have to apply 'f3' to the result of 'f2'
20:23:57 <Cale> lisppaste2: url
20:23:57 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:24:01 <ell-hask> stepcut: Humm... compiles... I just get a1 out instead of a0... Thanks, I'll look at this and try to learn the writer monad.. and monads in general
20:24:27 <ell-hask> stepcut: Yes, I see - thank you for spelling it out, helps clear things in my mind.
20:25:16 <stepcut> ell-hask: A monad instance for Either might be what you are looking for
20:25:33 <lisppaste2> Cale pasted "Monad" at http://paste.lisp.org/display/20452
20:25:34 <stepcut> ell-hask: I think that would allow you to halt processing and return an error
20:25:58 <lisppaste2> hask-ell annotated #20451 with "Works" at http://paste.lisp.org/display/20451#1
20:26:41 <ell-hask> stepcut: The black and white 'Just' / 'Maybe' is not dynamic enough.  Eventually this Bool will be an Integer or some sensable error code set.
20:27:01 <Cale> ell-hask: do you want computation to stop when there's an error?
20:27:19 <ell-hask> Cale: That would save time, yes I want that.
20:27:27 <Cale> Then use Either
20:27:30 <stepcut> ell-hask: right, Maybe just says 'it failed', but with 'Either' you could actually return a message
20:27:31 <SamB> hmm, have narrowed down the error a bit, I guess...
20:27:46 <palomer> or you could use Error
20:28:08 <Cale> ell-hask: you see, with your type, you're forced to compute a value of the type of the final result, which means that you have to proceed with the computation even if something's gone wrong.
20:28:42 <Cale> ell-hask: If you change your type to something like  data Test a = Failed Bool | Ok a
20:28:51 <ell-hask> Stepcut: Thanks - I will keep living, learning and add that to my list for the long weekend.
20:29:24 <Cale> then you could stop and return Failed True or Failed False as an error
20:29:44 * SamB is glad that he can use the tried-and-true print-statements debugging method ;-)
20:29:47 <Cale> and define (Failed x) >>= f = Failed x
20:30:02 <SamB> (though they aren't statements, and the word print does not appear in them)
20:30:13 <Cale> SamB: for that, the Writer monad is pretty good too
20:30:22 <ell-hask> Humm...
20:30:26 <SamB> I don't know how to use that, though ;-)
20:30:39 <SamB> and prints work fine here
20:31:03 <Cale> You can use Writer to build a list of messages as they occur
20:31:11 <Cale> (and it's lazy too)
20:31:26 <SamB> yes, but, I am too lazy to change the types to accomodate it!
20:31:31 <ell-hask> Cale: I thought when binding to a function that function had to be used.  Ref: "<stepcut> ell-hask: With your current monad, if you have, f1 >>= f2 >>= f3 -- and 'f2' fails, you still have to apply 'f3' to the result of 'f2'"
20:31:39 <SamB> especially since when the bug is gone I won't care!
20:31:54 <lisppaste2> stepcut pasted "Either Monad" at http://paste.lisp.org/display/20453
20:32:02 <Cale> ell-hask: in that case, it was only because the types forced you to do so
20:35:47 <SamB> hmm
20:36:44 <Cale> SamB: yeah, for one-off things, just decomposing your program or using Debug.Trace is enough
20:37:01 <Cale> SamB: but for things like progress reporting, it's handy
20:37:11 <SamB> I imagine so ;-)
20:37:14 <hyrax42> so much haskell :(
20:37:28 <SamB> In fact, I'm beginning to wonder if maybe it would be easier to do that way ;-)
20:37:49 <SamB> okay.
20:37:52 <SamB> hmm.
20:38:26 <SamB> oooh
20:38:40 <SamB> I probably did something stupid.
20:39:03 <SamB> ah yes.
20:39:16 <SamB> very stupid!
20:39:35 <SamB> I typed the wrong name for the offset to hSeek to...
20:40:28 <SamB> everywhere except at the very start of parsing, offsets are handled mostly by the typesystem...
20:40:34 <dons> @quit use parser to avoid code injection bugs in @eval
20:40:50 <dons> @bot
20:41:14 <lambdabot> :)
20:41:17 <dons> > (); fs = flip seq } in "\n\1ACTION gets hacked again\1" `fs` let {
20:41:22 <lambdabot>  Parse error
20:41:26 <dons> > 1+2
20:41:27 <lambdabot>  3
20:41:31 <dons> good stuff.
20:41:40 <SamB> hmm, I'm still getting an EOF error.
20:41:52 <SamB> but at least I'm getting more plausible trace output...
20:43:04 <ell-hask> Ahh, that feels very good.  "My" first Monad is working "return [Integer] >>= one >>= two" = "([Integer] + 1 + 2,[Interger] >=0)"
20:43:07 <ell-hask> Thanks guys
20:44:21 <stepcut> no problem
20:44:24 <hyrax42> dons: so the injections will stop now?
20:44:57 <hyrax42> poor lambdabot, people always trying to break him/her/it
20:45:12 <stepcut> her
20:45:20 <hyrax42> I thought it was
20:45:24 <hyrax42> but why
20:45:34 <SamB> because!
20:45:44 <Pseudonym> dons, have you checked lambdabot into darcs yet?
20:45:57 * Pseudonym ahems
20:46:03 <Pseudonym> Code review!  Yeah, that's it!
20:46:21 <dons> Pseudonym: ?
20:46:31 * Pseudonym isn't going to try to break it again
20:46:34 <Pseudonym> No way.
20:46:36 <Pseudonym> Not me, no.
20:47:12 <dons> I adapted the Language.Haskell parser to parse expressions, imported that. and now check the expression prior to passing it to runplugs to eval.
20:47:23 <Pseudonym> Right.
20:48:02 <dons> so that adds a new constraint that didn't previously exist: they must be valid 'exp' non-terminal fragments from the h98 report, aka, expressions.
20:48:06 <SamB> and how is trying to break it different from code review?
20:48:07 <Pseudonym> So the exercise now is to come up with something that looks like a valid expression, but is evil in a different lexical context.
20:48:15 <SamB> hahaha
20:48:28 <dons> yes :)
20:48:48 <stepcut> dons: in fps, dropWhile and takeWhile don't copy the string, right? They just create a new 'pointer' with different offsets/length ?
20:48:52 <dons> i guess we could do proofs on this security model at some point. might have been a good idea.
20:49:02 <dons> stepcut, yep. check the complexity annotation.
20:49:12 <dons> oh, I guess they're O(n), but they don't copy.
20:49:22 <dons> stepcut, what're you using fps for, dare I ask?
20:49:34 <SamB> yeah, wouldn't copying be higher?
20:49:35 <stepcut> dons: parsing debian control files 
20:49:46 <dons> for this linspire stuff?
20:49:49 <stepcut> yes
20:49:53 <dons> excellent :)
20:49:56 <SamB> Debian's package database needs a new format...
20:50:10 <SamB> it is stored as *flat text*, and it is *far too long*
20:50:14 <dons> stepcut, which fps version are you using, 0.6 ?
20:50:37 <stepcut> I have a version that uses String, but a 16MB packages file takes 180 megs of RAM just to read
20:50:42 <stepcut> yes, 0.6
20:51:10 <dons> ok. with fps that should take 16M to read. with Lazy bytestrings (in the darcs repo) it should take around 1M. coming soon ..
20:51:11 <stepcut> actually, I have whatever was in darcs yesterday afternoon..
20:51:21 <dons> oh, in darcs?
20:51:26 <dons> ok. good.
20:51:40 * dons reminds himself to avoid breaking the darcs repo
20:51:54 <stepcut> dons: yep, I run with profiling and it was indeed only 16MB.
20:51:57 <Spark> i really badly want to hear pulp - disco2000
20:52:01 <Spark> :(
20:52:21 <Pseudonym> Does TH still work?
20:52:32 <dons> Pseudonym: oh, probably not. hmm
20:52:39 <SamB> hehe
20:52:42 <dons> > $( [| 1 + 2 |] )
20:52:43 <lambdabot>  Parse error
20:53:00 <SamB> dons: *I told you that you needed the GHC API*
20:53:02 <dons> submit a patch ;)
20:53:06 <dons> SamB :P
20:53:12 <SamB> :PP
20:53:21 <dons> well, its only a couple of extra tokens. i'd rather patch than use ghc-api still.
20:53:25 <Pseudonym> Would this "patch" think of which you speak resemble a Haskell parser which supports TH, by any chance?
20:53:25 <stepcut> dons: today, I wrote a simple non-backtracking Monadic parser based around takeWhile/dropWhile -- so I can read the control file in, and parse it into a sensible data structure with 0-copies :)
20:53:31 <Pseudonym> s/think/thing/
20:53:34 <dons> Pseudonym: yep.
20:53:38 <Pseudonym> Then no.
20:53:45 <SamB> Pseudonym: resemble a patch to support TH syntax in a Haskell parser, yes
20:54:10 <dons> stepcut, cool :) that's what we hope for here at fps HQ.
20:54:15 <SamB> just think how much easier this might be with ParsecT!
20:54:37 <stepcut> dons: though, I did have to implement takeWhile2 / dropWhile2 so that I could do two character look-ahead 
20:54:38 * SamB begins his campaign for next years SoC ;-)
20:55:04 <Pseudonym> Suggested SoC project: Work on our IRC bot!
20:55:07 <stepcut> SamB: I wanted to try to use Parsec, but it insists that the input is a list of tokens :(
20:55:08 <SamB> (because, you see, you could use a ReaderT to keep track of the nesting)
20:55:27 <SamB> I was talking about the TH parsing
20:55:36 <SamB> not whatever you are doing, stepcut ;-)
20:55:45 <dons> adding TH parsing should be fairly easy. 
20:55:46 * dons hacks
20:55:53 <stepcut> SamB: oops -- to many parser conversations :)
20:55:56 <stepcut> too
20:56:15 <SamB> of course, maybe Parsec isn't good for parsing Haskell...
20:56:30 <stepcut> SamB: have you seen the polish parser paper ?
20:56:36 <SamB> dunno
20:56:54 <SamB> anyway, I have my XPCOM bindings to do
20:57:11 <stepcut> http://www.cs.uu.nl/wiki/pub/Center/UtrechtParserCombinators/p224-swierstra.pdf
20:57:42 <stepcut> its a pretty sweet parser combinator -- and they have a haskell parser written in it 
20:58:03 <stepcut> oops, this is the paper: http://www.cs.uu.nl/docs/vakken/afp/Literature/p224-swierstra.pdf
20:58:19 <stepcut> same name, different contents :)
20:58:47 <SamB> how strange!
21:01:46 <palomer> stepcut: does it support left recursion?
21:02:59 <stepcut> palomer: no 
21:03:19 <palomer> damnit, I want left recursion!
21:03:33 <dons> stepcut: btw, if 16M is too much, you could try Data.ByteString.Lazy, its becoming fairly stable now, and should use around 1M (as long as you're lazily processing the src)
21:03:56 <dons> it'll only hold a cache sized fragment of the file at a time, give or take
21:04:18 <dons> though i would say, its more experimental. you'd be the first user :)
21:04:24 <stepcut> dons: :p
21:07:00 <stepcut> dons: My current parser has to parse the whole thing before it can return a result (similar to parsec), so I am not sure if I would see any benefit... But since I do not do any backtracking, I think I should be able to make the parser lazy pretty easily -- that is tomorrows task :)
21:07:39 <dons> yeah.
21:09:18 <dons> one point is that it would be able to discard any parts of the file already dealt with
21:09:34 <dons> it would be an interesting excercise.
21:10:21 <stepcut> dons: currently I am doing dependency analysis, so I have to read the whole file in and stick it in a Data.Map -- it's very non-linear access...
21:10:27 <dons> ah, right.
21:10:51 <stepcut> dons: but, I forsee other things in the future where linear access will be the norm
21:10:51 <dons> the main thing is then to avoid copying, which i see you've got handled nicely :)
21:11:25 <stepcut> dons: there is a second issue ...
21:11:32 <dons> yeah?
21:12:35 <stepcut> dons: debian control files look somewhat like rfc2822 headers 
21:12:58 <stepcut> each package has a block of headers seperated by a new line
21:13:24 <stepcut> for the dependency analysis, I only need a few lines from each paragraph -- maybe 1/5 the total content of the file
21:13:51 <stepcut> but, if I do zero-copy, I think there is no way to garbage collect the parts I don't care about ?
21:14:00 <dons> sure. you use the 'copy' function
21:14:04 <dons> to extract the piece you need.
21:14:10 <dons> then the rest can be thrown away
21:14:24 <dons> ?type Data.ByteString.copy
21:14:25 <lambdabot> Data.ByteString.ByteString
21:14:26 <lambdabot>         -> Data.ByteString.ByteString
21:14:59 <dons> it just does a memcpy of the (shared) segment you've constructed from the larger string
21:15:01 <stepcut> dons: right, basically I can either have zero-copy *or* I can copy and have the unused data garbage collected
21:15:20 <dons> yep. 
21:15:26 <dons> depends on your use, really.
21:16:17 <stepcut> ok. I think I will try to parameterize my parser so I can choose at parse time
21:16:35 <dons> with the format you describe, it may even be simpler just to readLines, lazily pulling in the lines you want.
21:16:40 <dons> then you never allocate the rest.
21:17:03 <dons> ah, if you're parsing, then you have less chioce.
21:17:12 <dons> (you can't use readLines)
21:17:28 <stepcut> yeah, I have to look at the first few characters of each line to see if it is one I want
21:18:12 <dons> these zero-copy parsers might become a bit of an fps niche application, i forsee.
21:19:00 <stepcut> In anycase -- even with the extra garbage collection, I am still using 10x less memory than before -- which is plenty of headroom for now :)
21:19:34 <dons> ok. good. 
21:20:19 <stepcut> I'll let you know how the lazy parser goes
21:20:30 <dons> yes, please do.
21:21:46 * stepcut goes to bed
22:21:16 <dons> oooh, new record : 221M  114M sleep    biowai   1:05  2.44% ghc-6.4.1
22:21:49 <dons> though I seem to recall gtk2hs taking 800M ?
22:37:01 <Spark> "Here is the secret to being funny - have two groups of friends. One group is people you met while goth clubbing. The other is nerds you know from the internet. You steal the jokes from one group and tell them to the other and pretend you thought of them. Job done."
22:38:00 <palomer> the humours are not interchangeable, from my experience
22:38:11 <palomer> furthermore, nerds are rarely funny
22:39:14 <Spark> goths and nerds laugh at the same things
22:39:20 <monochrom> Both groups will think you are funny.  No, not "your jokes are funny".  "YOU are funny."  Funny as in bizzare.
22:39:33 <palomer> funny looking?
22:39:44 <monochrom> (I.e., they will ROTFL after you have left and they talk behind your back.)
22:40:33 <monochrom> If your purpose is to make people happy, even at your own expense, it works.
22:40:50 <palomer> there are better ways
22:41:23 <monochrom> Yes absolutely.
22:48:25 <xerox> http://code.google.com/soc/haskell/about.html
22:48:51 <xerox> Yeehaa!
22:51:22 <Daveman> xerox :D
22:52:13 * xerox yawnes and stretches
22:52:16 <xerox> Howdy Daveman!
22:52:23 <palomer> <:o
22:53:39 <sieni> palomer: is that a "surprised garden gnome"-smiley?
22:54:08 <palomer> more like a conehead monkey smiley
22:56:58 <Daveman> :)
22:57:04 <Daveman> palomer, you and your hat :P
22:57:11 <Daveman> sieni :P
22:57:14 <Daveman> haha I like that
