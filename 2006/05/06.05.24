00:00:37 <dons> ah, parens. yeah.
00:01:37 <vincenz> \o/
00:01:41 <vincenz> fixed
00:01:53 <vincenz> expression ::= allbinopexps | tigtexpression
00:02:05 <vincenz> tightexpression ::= literal | '(' expression ')'
00:02:13 <vincenz> and then expression ::= ident tight_epxression_list
00:02:26 <vincenz> no conflicts
00:04:05 <vincenz> hmm, nm
00:04:09 <vincenz> 12 sr conflicts
00:05:28 <dons> > x where x = 3
00:05:29 <lambdabot>  parse error on input `where'
00:05:32 <dons> fixed.
00:05:43 <dons> > let x = 3 in x
00:05:44 <lambdabot> 3
00:07:40 <palomer> vincenz: not using parsec?
00:10:04 <vincenz> dunno
00:10:19 <vincenz> for some reason I expect more flexibility with alex/happy
00:10:25 <vincenz> although the original parser is parsec
00:10:30 <vincenz> and allows vertical layouting
00:10:32 <RvGaTe> morning...
00:10:47 <palomer> parsec is far more flexible than alex/happy
00:11:03 <palomer> parsec is turing complete in some sense of that term
00:11:12 <dons> well, in alex/happy, you jsut write a haskell fragment to handle the extra hard stuff
00:11:30 <vincenz> so why is GHC written with alex/happy
00:11:31 <dons> hence ghc uses alex+happy to handle fully -fglasgow-exts haskell
00:11:32 <vincenz> and not parsec
00:11:42 <dons> faster by a long shot?
00:11:43 <palomer> ghc has a parsec grammar
00:11:49 <Joplin> parsec wasn't around at the time, for one
00:11:50 <dons> palomer: no. it uses happy.
00:12:04 <dons> @fptools
00:12:04 <palomer> ok
00:12:04 <lambdabot>  not available
00:12:10 <palomer> but there are haskell98 grammars available
00:12:12 <palomer> for parsec
00:12:18 <palomer> and I've heard of people using ghc with parsec
00:12:29 <palomer> (on this channel)
00:12:33 <dons> $ ls fptools/compiler/parser 
00:12:34 <dons> Ctype.lhs           Parser.y.pp
00:13:06 <palomer> so I'm guessing ghc has a preprocessor (since the ghc grammar isn't context free)
00:13:19 <dons> no, that just adds word sized stuff. nothing magic
00:13:36 <dons> the .pp thingy, i mean
00:13:36 <palomer> how does happy/alex take into account indenting?
00:13:53 <vincenz> palomer: ugly lexing rules
00:14:11 <vincenz> I tried to decipher it
00:14:13 <vincenz> to reuse in my thingy
00:14:24 <vincenz> but i'm too tired
00:14:34 <dons> yeah, just has layout handling in the rules. 
00:14:37 <sjanssen> all Google SoC applicants: visit your student home page, it says whether you've been accepted now
00:14:39 <palomer> anyways, from my experience, I've found parsec easier to use
00:14:51 * sjanssen can finally get some sleep
00:14:52 <dons> <layout, layout_do> {
00:14:52 <dons>   \{ / { notFollowedBy '-' }        { pop_and open_brace }
00:14:54 <dons> ...
00:15:02 <dons> sure, parsec is easier.
00:15:07 <dons> night sjanssen !
00:15:13 <kosmikus> palomer: parsec is easier to use if you're already familiar with Haskell syntax
00:15:32 <kosmikus> but generators are still faster
00:16:06 <palomer> Text.ParserCombinators.Parsec.Language.haskellDef <--the haskell grammar in parsec, I think
00:16:06 <neologism> I am accepted :)
00:16:13 <vincenz> palomer: no it's not
00:16:16 <kosmikus> there have been projects to have combinator libraries optimise themselves and the spit out the optimised code again, so that they can be used as generators, too; but none of this work is mature, I think
00:16:20 <palomer> vincenz: what is it?
00:16:22 <vincenz> palomer: it's just rules for identifiers and crap
00:16:33 <dons> neologism: ?
00:16:40 <vincenz> neologism: likny
00:16:42 <vincenz> linky?
00:16:50 <neologism> dons: SoC
00:16:54 <palomer> oh, that sucks
00:16:59 <palomer> nevermind then
00:17:06 <dons> neologism: oh, hmm, on http://code.google.com/soc/ ?
00:17:09 <vincenz> palomer: there's not even combinators for layouting
00:17:12 <vincenz> I made my own
00:17:16 <vincenz> onside
00:17:17 <vincenz> offside
00:17:28 <vincenz> withPos
00:17:30 <neologism> dons: sjanssen announced that its official now
00:17:35 <neologism> so I wanted to share the joy ;)
00:17:38 <dons> why doesn't it show up here. hmm. damn pacific ocean.
00:17:49 <palomer> refused:/
00:18:00 <dons> is the list on  http://code.google.com/soc/ ?
00:18:03 <palomer> nope
00:18:21 <dons> is it up anywhere?
00:18:29 <palomer> from #summer-discuss "Ineligible and Ranking in progress means that you were not accepted."
00:18:31 <sjanssen> dons: just on student hompages
00:18:37 <dons> ah . ok.
00:19:10 <vincenz> dons: ah and ok are functions?
00:19:12 <sjanssen> dons: so now that it's semi public, can you say how many slots Haskell got?
00:19:48 <neologism> dons: its only on my studewnts page
00:19:55 <dons> we got 9, out of the 34 we asked for. which was more than debian and netbsd, I think. so we did ok.
00:20:06 <neologism> dons: fbsd got 14 out of 45
00:20:21 <dons> ok, so that's about the same ratio
00:20:23 <vincenz> > 14 /45
00:20:24 <lambdabot> 0.3111111111111111
00:20:27 <vincenz> < 9 / 34
00:20:30 <vincenz> > 9 / 34
00:20:31 <lambdabot> 0.2647058823529412
00:20:40 <vincenz> dons: which ones got it?
00:20:47 <dons> i'll make an announce soon.
00:21:07 <vincenz> @seen mahogany
00:21:07 <lambdabot> I haven't seen mahogany.
00:24:31 <Lemmih> Anyone know where musasabi has gone?
00:28:10 <rictic> Would someone mind answering a Haskell newbie's question about function composition / point-free programming?
00:29:17 <Cale> sure
00:29:29 <Cale> er, not at all, rather :)
00:29:30 <Cale> hehe
00:30:01 <Cale> What's the question?
00:30:18 <rictic> Heh, ok.  I'm going through a haskell tutorial
00:30:50 <rictic> And I'm doing one of the exercises, trying to convert a function to point-free form: func2 f g l = filter f (map g l) 
00:31:16 <Cale> okay
00:31:37 <rictic> So I tried to get it part of the way there by eliminating g and l like so: func2 f = (filter f) . map 
00:31:48 <rictic> And I'm not sure why that gives me an error
00:32:32 <rictic> Since the second argument to filter f is a list, which is what map will evaluate to (once it has gotten its two arguments)
00:33:06 <Cale> well, let's try going back the other way
00:33:25 <Cale> func2 f g = ((filter f) . map) g
00:34:24 <Cale>          = filter f (map g)
00:34:32 <Cale> but then
00:34:41 <Cale> func2 f g x = filter f (map g) x
00:35:21 <Cale> It's possible to totally points-free this function, but it's a little awkward.
00:35:43 <Cale> (you should be able to see that the last like there is not the same as what you started with)
00:35:46 <Cale> line*
00:36:03 <rictic> Right, it's trying to pass three values to filter
00:36:11 <rictic> Correct?
00:36:13 <Cale> yeah
00:36:24 <davidhouse> xerox, do we have a list of accepted apps?
00:37:01 <rictic> Hmmm, ok.  These exercises are rather difficult.
00:37:12 <Cale> the farthest I'd normally take it is just  func2 f g = filter f . map g
00:37:40 <Cale> if you want to be more points-free than that, you end up doing some unnatural things with (.)
00:37:56 <Cale> @pl func2 f g = filter f . map g
00:37:57 <lambdabot> func2 = (. map) . (.) . filter
00:38:34 <rictic> I'm not entirely clear on why filter f . map g words, but filter f . map doesn't
00:38:54 <Cale> because map is applied to g before the composition
00:39:11 <rictic> Won't the new function take the same arguments as map?
00:39:29 <Cale> @type filter f . map
00:39:30 <lambdabot> Not in scope: `f'
00:39:35 <Cale> @type \f -> filter f . map
00:39:35 <lambdabot>   Couldn't match `[a]' against `t -> t1'
00:39:36 <lambdabot>   Expected type: [a]
00:39:44 <Cale> @type (.)
00:39:45 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
00:40:15 <rictic> Ah, so . assumes that they each take one value?
00:40:20 <Cale> yes
00:40:25 <davidhouse> imagine expanding it out. filter f (map g) xs is what it'd go do
00:40:41 <davidhouse> which is not what you want, you want filter f (map g xs)
00:40:42 <Cale> filter f :: [a] -> [a] (roughly, actually depends on the type of f)
00:40:46 <rictic> Ahhhhhh, ok, yeah, thanks
00:40:59 <Cale> and map :: (a -> b) -> ([a] -> [b])
00:41:11 <rictic> Right
00:41:18 <Cale> but [a] isn't [a] -> [b]
00:41:28 <Cale> (or anything like it)
00:42:02 * mnislaih just got the acceptance letter from Google
00:42:08 <Lemmih> mnislaih: Congrats!
00:42:10 <mnislaih> !!!
00:42:14 <neologism> congrat
00:42:14 <mnislaih> Woohoo
00:42:17 <mnislaih> thanks :)
00:42:28 <neologism> mnislaih: its delivered on mail?
00:42:30 <neologism> or what letter?
00:42:38 <mnislaih> the acceptance email I mean
00:42:57 <davidhouse> do we not have a list of all accepted projects anywhere?
00:43:03 <neologism> no mail to me
00:43:17 <davidhouse> google stated they were "publishing a list", which was a little, well, wrong.
00:43:27 <Lemmih> davidhouse: I'll be publishing the results on the mailing list soon.
00:43:28 <Bobstopper> Are there any plans to standardise a sequence class for haskell?
00:43:29 <mnislaih> anyone else accepted ?
00:43:30 <Lemmih> *We'll
00:43:38 <davidhouse> Lemmih: good. :)
00:43:49 <davidhouse> Bobstopper: Data.Traversable i think has a sequence method
00:43:54 <Bobstopper> tah
00:43:56 <davidhouse> @docs Data.Traversable
00:43:56 <lambdabot> Data.Traversable not available
00:44:10 <davidhouse> you'll have to use the docs at haskell.org/ghc/dist/current
00:44:25 <Bobstopper> wait, sequence method or class? I meant class.
00:44:47 <davidhouse> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Traversable.html
00:44:59 <davidhouse> sequence is one of the methods for the Traversable classs
00:45:49 <davidhouse> Lemmih, right, i'm going for a shower and some breakfast, when i get back, i expect an ML post :)
00:46:09 <dons> davidhouse: we won't be announcing till google does. so maybe a couple of hours.
00:46:16 <Cale> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Foldable.html
00:46:20 <dons> maybe less. not sure what they're doing.
00:46:20 <Cale> that's also of interest
00:46:28 <davidhouse> hmn, okay.
00:46:44 <davidhouse> google clearly stated that on the 23rd they'd publish a list on code.google.com.
00:46:51 <Cale> I think that rather than a generic sequence class, we're going to see a bunch of more specialised but meaningful classes.
00:46:54 * davidhouse looks at his watch. nope definately the 24th now
00:47:08 <Cale> (Applicative, Foldable, Traversable)
00:47:11 <Bobstopper> hmm... not quite what I had in mind. By sequence I mean something which strings of various formats can be instances of, or lists or arrays etc
00:47:47 <Bobstopper> in particular I'm thinking of an interface to string operations where strings might be ordinary strings or ByteStrings or whatever.
00:48:16 <davidhouse> oh, i think the ByteString people are doing something like that
00:48:22 <davidhouse> a PackedList class or similar.
00:48:47 <sjanssen> Bobstopper: I'm doing exactly that for SoC
00:48:55 <Bobstopper> SoC?
00:49:03 <sjanssen> summer of code
00:49:11 <davidhouse> really, though, wouldn't it be easier if we just ripped out String and replaced it with ByteString? they have compatible interfaces, no?
00:49:22 <Bobstopper> oh cool.
00:49:40 <sjanssen> davidhouse: not exactly, you can't pattern match against ByteString like you can lists
00:49:45 <dons> davidhouse: it doesn't have the nice inductive and typing properties of [a]
00:49:56 <Bobstopper> Well, it'd be even easier if I could write libraries which depended on sequence rather than a hard-coded string preference. Then the user can use whatever string type they want.
00:50:24 <davidhouse> hmm, okay.
00:50:53 * vincenz kicks davidhouse to #oasis
00:51:42 <Cale> Well, I think a generic String class is a good idea, but in my mind it looks rather different from a Sequence class.
00:51:44 <davidhouse> vincenz: i'm not really around, i'm going to have a shower and grab some breakfast
00:52:00 <vincenz> davidhouse: I'm not really a'square cause I'm there
00:53:12 <Bobstopper> Well, a string class would be better, but I figure a sequence class would be somewhere to start from which a string class might instance...
00:54:28 <vincenz> anyone know an algorithm for checking of overlapping patterns
00:54:48 <Cale> Foldable is pretty close to a generic sequence class.
00:55:40 <Bobstopper> Yeah, I suppose it is...
00:56:16 <vincenz> > let {foo True _ = True; foo _ False = False} in foo True
00:56:17 <lambdabot> <Bool -> Bool>
00:56:28 <vincenz> o.o
00:56:31 <vincenz> > let {foo True _ = True; foo _ False = False} in foo True False
00:56:32 <lambdabot> True
00:56:34 <Cale> you kind of want a sensible join though too
00:56:42 <Cale> if not a full monadic structure
00:56:52 <vincenz> > let {foo True _ = True; foo _ False = False; foo False False = False} in foo True False
00:56:53 <lambdabot>   Warning: Pattern match(es) are overlapped
00:56:53 <lambdabot>      In the definition of `foo': foo False False = ...
00:57:02 * vincenz ponders
00:57:08 <vincenz> blegh, it's faulty
00:57:18 <vincenz> True _ | _ False    overlap at times as well
00:57:34 <vincenz> > let {foo True _ = True; foo _ False = False; foo False True = False} in foo True False
00:57:35 <lambdabot> True
00:58:30 <Bobstopper> For that I suppose you'd just instance Monoid as well... hmm... Could probably get most of the string features wanted by just using Monoid and Foldable and have List and ByteString instance them...
00:59:57 <davidhouse> did someone write a pretty printer for functions?!
00:59:58 <davidhouse> > map
00:59:59 <lambdabot> Add a type signature
01:00:15 <vincenz> > not
01:00:16 <lambdabot> <Bool -> Bool>
01:00:22 <davidhouse> > (&&)
01:00:22 <vincenz> > (+1)
01:00:23 <lambdabot> <Bool -> Bool -> Bool>
01:00:23 <lambdabot> Add a type signature
01:00:31 <vincenz> > (++"A")
01:00:31 <lambdabot> <[Char] -> [Char]>
01:00:33 <Bobstopper> damn... to be Foldable, ByteString still needs to have a * -> * kind...
01:00:40 <Cale> yeah
01:00:46 <Cale> so it's not going to satisfy that
01:01:01 <davidhouse> right, so it doesn't work with 1) typeclass polymorphism. 2) HOFs
01:01:02 <Bobstopper> wouldn't it be sensible to make ByteString * -> * anyway? Then you could have it work with arbitrary character formats?
01:01:06 <Cale> this is the usual problem with trying to come up with general collections classes
01:01:06 <vincenz> tell em you want a ByteString a
01:01:17 <davidhouse> > (+)
01:01:18 <lambdabot> Add a type signature
01:01:23 * vincenz snickers
01:01:48 <dons> the ndp guys are working on the Vector a type, which provides this kind of thing
01:01:56 <davidhouse> > (+ (1::Int))
01:01:57 <lambdabot> <Int -> Int>
01:01:59 <vincenz> > undefined :: (Int -> Int)
01:02:00 <lambdabot> <Int -> Int>
01:02:00 <Bobstopper> s/formats/encodings/
01:02:05 <vincenz> \o/
01:04:01 <Bobstopper> dons: would it be insensible to make ByteString * -> * ? any reasons other than backwards compatibility?
01:04:29 <dons> and its insensible :)
01:04:54 <davidhouse> type ByteStringContainer a = ByteString
01:04:56 <dons> ByteStrings' are paramaterised on their element type. so faking it seems unreasonable
01:04:58 <davidhouse> phantom types :)
01:05:06 <dons> s/are/aren't/
01:05:53 <davidhouse> or, with explicit kind annotations, data BSContainer :: * -> * = BSC ByteString
01:05:54 <Bobstopper> paramaterising them might make it possible to make ascii bytestrings or unicode 8 / 16 /32 bytestrings though wouldn't it?
01:06:30 <dons> yeah, if we get a few different element types beyond Word8, then its more reasonable
01:07:35 <dons> but bytestrings aren't packed vectors. and shouldn't be treated as such. use Array i e for that. and as I say, libraries of sequence-ish ops on Arrays are being worked on.
01:12:08 <Bobstopper> Yeah, I suppose the whole "byte" part of "ByteString" betrays the intention... I'm unfamiliar with how ByteStrings work, but are the optimisations feasible for other encodings or only really useful for bytes?
01:12:57 <neologism> google sent fakt "you are accepted mails"
01:13:01 <neologism> http://groups.google.com/group/Summer-Discuss-2006/browse_thread/thread/71dcb003247ee84d/0edab71113a7d53a#0edab71110edab71113a7d53a
01:13:04 <dons> for other encodings, somewhat. sjanssen will be working on utf8, for example.
01:13:16 <dons> and kzm already has a number of different Latin-N encodings
01:13:46 <Bobstopper> Ok, thanks.
01:16:29 <dons> neologism: by fakt you mean "wrong"?
01:16:39 <neologism> fakt -> fake
01:16:49 * dons notices 'e' and 't' are close and chooses 'fake'
01:16:51 <dons> ah yes.
01:17:09 <dons> hmm. that's very unfortunate then.
01:17:12 <neologism> my heart stopped beating for a moment so I mistyped that ;)
01:18:53 <vincenz> anyone know what this does
01:19:00 <vincenz> Parsec ...Combinator.option
01:19:15 <vincenz> apparently not what I thought
01:23:58 <vincenz> @fptools Text.ParserCombinators.Parsec
01:23:58 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
01:24:40 <davidhouse> neologism: ouch, that's scathing
01:28:24 <palomer> hrmph
01:28:25 <palomer> can't sleep
01:30:52 <vincenz> for some stupid reason
01:30:54 <vincenz> my parsec can do
01:30:58 <vincenz> data Foo = Bar
01:30:59 <vincenz> but not
01:31:00 <vincenz> data F = B
01:31:12 <vincenz> constP :: GenParser Char SourcePos ParsedIdent
01:31:12 <vincenz> constP = do l <- oneOf ['A' .. 'Z'] r <- option [] identP return (l:r)
01:31:33 <vincenz> constP = do {l <- oneOf ['A' .. 'Z']; r <- option [] identP; return (l:r)}
01:31:35 <vincenz> identP = identifier
01:32:13 <davidhouse> @hoogle option
01:32:13 <lambdabot> Text.Html.option :: Html -> Html
01:32:13 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
01:32:13 <lambdabot> Text.ParserCombinators.Parsec.Combinator.option :: a -> GenParser tok st a -> GenParser tok st a
01:32:20 <eivuokko> try identP <|> return []?
01:32:25 <davidhouse> what does that do? i can't remember
01:33:56 <palomer> vincenz: http://www.rafb.net/paste/results/KbIBf665.html <-- you might find this useful
01:35:00 <vincenz> \o/
01:35:02 <vincenz> what is pzero
01:35:04 <palomer> http://www.rafb.net/paste/results/4QXpJB56.html <--missing definitions
01:35:09 <palomer> vincenz: failure
01:35:20 <vincenz> aHA!
01:35:51 <vincenz> why the tokerPos thingy
01:36:05 <palomer> you want to allow an arbitrary number of spaces between your tokens, no?
01:36:31 <vincenz> isn't that done automatically?
01:36:33 <palomer> the Pos is an artifact of a previous design decision
01:36:36 <vincenz> oh wait I use Language which comes with lexer
01:36:49 <palomer> ahh, if you use a tokenizer then it's already done
01:36:54 <vincenz> except
01:36:54 <palomer> (I think)
01:36:56 <palomer> (not sure)
01:37:01 <vincenz> tokenizer doesn't choose between uppercase and lowercas
01:37:54 <palomer> I always do my tokenizing manually with tokerPos
01:38:02 <palomer> it's worked so far
01:38:23 <palomer> and saves me from learning To Do It Right
01:39:30 <palomer> (to be fair, my languages are never really that complicated, 500 lines tops)
01:41:41 <vincenz> even try identP <|> return [] fails
01:41:43 <vincenz> quite odd
01:44:34 <palomer> I hate not being able to sleep
01:45:26 <vincenz> funky
01:45:34 <vincenz> not even having a try at the toplevel fixes it
01:46:34 <vincenz> anyways
01:46:35 * vincenz waves
01:46:44 <vincenz> thx for all the input
01:47:55 <swiert> is there a list of accepted SoC projects anywhere?
01:48:19 <dons> not up yet.
01:48:35 <dons> should be up soon, i think.
01:48:50 <swiert> ok. do we know of any Haskell related stuff that has been accepted?
01:49:18 <dons> yes, several projects. we'll be announcing the full list shortly.
01:49:32 * dons forgets to put on SoC admin hat
01:49:48 <swiert> thanks.
01:51:05 <psi> where will it be posted?
01:51:34 <swiert> presumably http://code.google.com/soc/.
01:56:10 <dons> yep.
01:56:28 <dons> and we'll announce on haskell@haskell.org ml.
01:56:41 <dons> just waiting for google...
01:56:42 <psi> ah
01:58:46 <vincenz> woot
01:58:56 <vincenz> fixed shift/reduce issue with happy
01:59:11 <vincenz> now if I could only get vertical layouting 
01:59:21 <dons> cool. vincenz reaches haskell hacker level 4.
01:59:37 <vincenz> what levels are there?
01:59:47 <dons> you know, every time you learn more haskell, it pushes more ocaml out..
01:59:54 <vincenz> erm
01:59:58 <vincenz> that's impossible
02:00:00 <dons> and monads take up a lot of brain space.
02:00:01 <vincenz> my internal FIFO is put like this
02:00:05 <dons> so watch out ;)
02:00:05 <ProfTeggy> vincenz, absolutely lowest: 4, highest: 10  ;-P
02:00:08 <vincenz> [haskell | ocaml | C++ | JAva]
02:00:41 <vincenz> ProfTeggy: :D
02:00:43 <vincenz> anyways
02:00:48 <vincenz> I have added Patterns to my language
02:01:01 <vincenz> now the question is how I can check if patterns overlap or not
02:01:04 <dons> well, i think creating a new monad is level 1. fixing thingies in happy, and writing your own language, that's got to be at least 3.
02:01:30 <vincenz> dons: don't forget my type inference engine
02:01:37 <vincenz> :D
02:01:45 <dons> definitely 4 then.
02:02:03 * vincenz doesn't mention that right now he only has tyvars, tybools, tynils, and tycons
02:02:20 <dons> hehe
02:03:10 * vincenz reboots his laptop after a failed attempt of going to sleep at 11am after an allnighter
02:05:51 <vincenz> dons: what do you use as journal?
02:06:11 <vincenz> like... when you're coding and you think 'hmm...That's a good diea...but for later"
02:06:15 <vincenz> s/diea/idea
02:06:45 <vincenz> ProfTeggy: do you have any experience with parsing vertically layed out code?
02:08:40 <ProfTeggy> vincenz, vertically?  Where the line in which a token occurs influences the parse?
02:09:35 <vincenz> column, yes
02:09:49 <vincenz> like haskell
02:09:57 <ProfTeggy> Column?  So, horizontally layed out?
02:10:02 <vincenz> I tried looking at GHC but GHc code is a mess
02:10:07 <vincenz> foo x = do
02:10:16 <vincenz>               code must on same or further column than do
02:10:25 <ProfTeggy> OK, the offside rule
02:10:28 <vincenz> yep
02:10:36 <vincenz> I've heard many nominations for that rule
02:10:41 <vincenz> wasn't sure which one was std
02:11:31 <ProfTeggy> Isn't this done in the lexer, where the lexer inject separating token  (like ';' in the case of Haskell) before the parses sees the token stream?
02:12:23 <ProfTeggy> That is, the parses isn't aware of parsing layed out code.  
02:12:27 <ProfTeggy> err, parser
02:12:31 <joelr1> howdy folks
02:12:40 <joelr1> are data invariants implemented as part of ghc 6.5?
02:13:04 <vincenz> ProfTeggy: indeed, except that well the one with ghc is hard to read
02:13:18 <Lemmih> joelr1: Data invariants?
02:13:26 <joelr1> Lemmih: yeah
02:13:33 <joelr1> the LtU paper
02:13:47 <Lemmih> The STM data invariants?
02:13:52 <joelr1> http://lambda-the-ultimate.org/node/1500
02:13:57 <joelr1> Lemmih: right on
02:15:57 <dons> vincenz: I use a program called 'devtodo'. http://swapoff.org/DevTodo/
02:16:38 <ProfTeggy> vincenz, http://hyperion.informatik.rwth-aachen.de/Research/FP/HaskellParser/haskellParser.tar.gz contains code which parses Haskell w/ offside rule
02:17:29 <Lemmih> joelr1: No, I don't think so.
02:17:55 <joelr1> Lemmih: too bad... maybe 6.6? i asked simon 
02:18:38 <vincenz> ProfTeggy: thanx
02:18:42 <vincenz> dons: likewise
02:19:23 * vincenz blinks
02:19:34 <davidhouse> http://www.iai.uni-bonn.de/~loeh/OpenDatatypes.html <-- would be really nice to see an implementation of this
02:19:36 <vincenz> ProfTeggy: a completely manually written parser?
02:20:59 <vincenz> dons: any special scripts, or as is?
02:21:59 <Lemmih> What did Simon say? He's got way more authority than me.
02:22:14 <davidhouse> hey, vincenz, how do you close windows in irssi?
02:22:18 <joelr1> Lemmih: nothing yet
02:22:30 <joelr1> is anyone actively using Haskell with Cocoa?
02:22:34 <Lemmih> joelr1: I believe it'll be in 6.6 but I haven't seen it yet.
02:22:41 <vincenz> davidhouse: /part
02:22:44 <vincenz> davidhouse: /window close
02:22:48 <joelr1> Lemmih: when is 6.6 going to be released?
02:22:53 <davidhouse> vincenz: tried /part, didn't work (it was a /q)
02:23:00 <vincenz> davidhouse: /disco
02:23:05 <shapr> RvGaTe: http://www.haskell.org/learning.html
02:23:05 <davidhouse> ah, thanks.
02:23:13 <davidhouse> vincenz: /disco?!
02:23:15 <RvGaTe> thx
02:23:25 <vincenz> davidhouse: no window close
02:23:25 <shapr> RvGaTe: This one is popular - http://www.isi.edu/~hdaume/htut
02:23:27 <Lemmih> joelr1: Around September, I think. Nothing is fixed.
02:23:41 <joelr1> Lemmih: cool
02:24:02 <joelr1> i have an unsatisfied craving in me
02:24:06 <joelr1> an unquenched thirst
02:24:19 <joelr1> i feel that only haskell can fill it!
02:24:47 <joelr1> i'm using lisp full-time but it does not do it
02:24:58 <davidhouse> joelr1: that and jesus :)
02:25:24 <joelr1> davidhouse: i'm not a believer in anybody but meself
02:26:03 <davidhouse> joelr1: that's fine, it was just a lighthearted comment. :)
02:26:09 <joelr1> davidhouse: :D
02:27:02 <shapr> joelr1: Hey, I'm doing a Joel and learning Flash in a week.
02:27:21 <joelr1> shapr: what's doing a joel? 
02:27:36 <shapr> Learning something in a week and doing production work with it immediately :-)
02:27:58 <joelr1> flash is cool, though, i tried that but gave up for a java-based slow compiler (flex, mxmlc) and not being able to use flex builder
02:28:08 <joelr1> shapr: yes, i find that disciplines you greatly!
02:28:17 <joelr1> shapr: nothing like learning under stress!
02:28:30 <shapr> I'm using a flash compiler written in OCaml.
02:28:54 <joelr1> the haskell-vs-erlang post in my blog holds the top stop forever now
02:30:38 <joelr1> #1 haskell vs. erlang, #2 the 90-minute C compiler, #3 trading category 
02:30:49 <joelr1> shapr: what version of flash
02:31:18 <shapr> Flash player 7 is the latest that runs on Linux.
02:31:55 <joelr1> shapr: cool. whatcha using it for?
02:33:09 <shapr> I'm doing contract work from those online sweat shop bidding sites.
02:33:27 <joelr1> shapr: interesting. odesk?
02:33:31 <shapr> odesk?
02:33:47 <joelr1> www.odesk.com. new concept in sweatshopping
02:33:52 <shapr> Haven't heard of that one.
02:34:02 <shapr> I've been using Rentacoder, getacoder, ifreelance, etc
02:34:12 <joelr1> offer the lowest hourly rate as opposed to lowest bid. you forgot elance
02:34:19 <shapr> hm
02:34:27 <joelr1> shapr: and guru.com
02:34:44 <shapr> I'd rather go for per-goal bids because I can do tasks quickly with high quality.
02:34:56 <joelr1> besides offering the lowest rate you also submit to running an app that takes periodic screenshots to make sure you are working
02:35:07 <shapr> Per-hour pay gives the advantage to the $5/hour sweatshops in India and Ukraine.
02:35:16 <shapr> Wow, crazy.
02:35:32 <joelr1> there's a great interview (businessweek?) where the owner says that once he built the whole thing he tried to make his own programmers use it
02:35:35 <joelr1> all but one quit
02:35:58 <joelr1> he shrugged and got programmers off of his own network :-) talk about eating your own dogfood
02:36:48 <joelr1> shapr: btw, my russian programmers never charged me < 15/hr. the big shops charged 25.
02:36:59 <joelr1> how things changed since the early 2000s
02:37:01 <shapr> Thing is, when I get frustrated I tend to play a quick game of barrage or crack-attack, and then I can go back to work. I think the screenshot program wouldn't see frustration release as work.
02:37:11 <joelr1> shapr: yep
02:37:17 <vincenz> dons: todo seems buggy
02:37:37 <joelr1> shapr: it does not prevent you from quitting the work for a while. it's just to make sure you worked the hours you are claiming
02:37:44 <shapr> Hm, yeah.
02:38:21 <shapr> Still, per-goal pay gives the advantage to efficient workers, per-hour pay gives the advantage to assembly programmers.
02:38:27 <neologism> I have the best coding ideas when tooth-cleaning/toilet visit/showering
02:38:27 <Saulzar> You can run 5 computers, do 5 jobs in parallel :)
02:38:47 <joelr1> neologism: i think it's a well-known concept :)
02:38:53 <joelr1> shapr: i agree
02:39:00 <vincenz> dons: I can't get the global-database thingy to wokr
02:39:02 <neologism> joelr1: I just wonder how they check this ;)
02:39:31 <joelr1> Saulzar: you can't ;-) it counts your words per minute and grabs screenshots. maybe checks the programs  you are running and god knows what else
02:39:46 <joelr1> neologism: i meant the shower thing was a well-known concept
02:40:11 <vincenz> dons: nm
02:40:13 <shapr> This reminds me of Bob Rife in Snow Crash.
02:40:16 <Saulzar> Hehe, damn. You need an auto-typer program to keep on typing out the same source file repeatedly when you're not there.
02:40:38 <joelr1> Saulzar: you can't type the same file, see. odesk will check your screenshots
02:40:45 <joelr1> a human checks before paying you for your hours
02:41:21 <Saulzar> I guess you're screwed then, avoid that place like the plague :)
02:41:21 <shapr> I worked with a bunch of Java programmers who were really working the whole time, but never produced anything worthwhile.
02:41:33 <joelr1> haha
02:41:34 <jethr0> but you could do some nasty stuff with slowing down captured camera images and keystrokes :)
02:41:51 <joelr1> jethr0: oh, yeah, forgot about the webcam. they run that too. 
02:41:59 <joelr1> jethr0: but the captures are screen dumps, not camera
02:42:03 <jethr0> yes, but who controls the pc :)
02:42:08 <jethr0> ah, k
02:42:14 <joelr1> anyway, not worth fighting them, just avoiding is best
02:42:46 <shapr> Do you know any other worthwhile freelance websites?
02:42:51 <Saulzar> Is the man running the place an ex-prison manager?
02:43:10 <joelr1> Saulzar: beats me. google for businessweek and odesk
02:43:28 <joelr1> shapr: i don't believe in any. last time i got good business was back in 2000/2001
02:43:38 <kzm> ai!  History down the drain (damn ^L isn't refresh, but delete all in xchat)  Did somebody call?
02:43:44 <jethr0> shapr: how are your experiences with those sites you named above? when i looked at rentacoder the tasks seemed incredibly dull, and pay wasn't exactly enriching
02:43:44 <shapr> Ok, how do you find contract work?
02:43:57 <davidhouse> kzm, meme.b9.com
02:43:58 <joelr1> shapr: i got my current gig (with ex-naughty dog guys) through craigslist
02:44:00 <shapr> jethr0: I haven't had much experience yet.
02:44:06 * kzm is just back from his STM seminar.  Whee.
02:44:06 <joelr1> lucked out probably
02:44:29 <dcoutts> kzm, so why is STM so cool then?
02:44:34 <shapr> jethr0: But yes, dull tasks and not so much pay. But I hope that building a good reputation will let me improve my pay and tasks.
02:44:39 <joelr1> shapr: indeed.com is also good. i actually used indeed.com since it searches all the craigslists
02:44:55 <joelr1> shapr: i thought sweden was good for it jobs
02:45:00 <joelr1> shapr: why bother with us?
02:45:00 <kzm> It just might let people write working threaded programs.
02:45:05 <joelr1> us = states
02:45:23 <kzm> As far as I understand it, that is.  I really have no clue. :-)
02:45:25 <shapr> joelr1: I can't get a job with my self-employed permit. I can only work for my company. I found a bunch of jobs, I just can't take them.
02:45:29 <vincenz> dumdumdum
02:45:47 <joelr1> shapr: i thought you were a swede. are you just studying?
02:45:51 <kzm> But I used to work on a 300KLOC multithreaded C++ monster, and that had...interesting behaviour.
02:45:55 <shapr> Nah, I'm from Alabama.
02:46:09 <joelr1> shapr: what are you doing in sweden if you don't mind my asking
02:46:12 <shapr> I've been living in Finland & Sweden the last six or seven years.
02:46:21 <jethr0> c++ monsters always tend to the unexplainable. and threading doesn't alleviate that tendency
02:46:27 <kzm> dcoutts, I gave the talk, btw.  Incredible what people will believe if you have convincing slides to back you up :-)
02:46:37 <joelr1> shapr: oh. how the hell do you manage that? they are pretty fascist with regulations and permits, etc. 
02:46:39 <shapr> joelr1: I met a woman on ICQ
02:47:01 <joelr1> shapr: i live... ugh... irregularly in spain but i wouldn't fathom doing that in finland or sweden
02:47:38 <shapr> joelr1: I had a live-in partner permit for years, but a) I broke up with that woman and b) part of the relationship pressure was that I had to stay with her to keep my job/country of residence. So I switched to a self-employed permit about a year ago.
02:48:18 <shapr> Immigration said that I need to pay more taxes if I want to stay in Sweden.
02:48:23 <joelr1> shapr: #b often happens. how do you get a self-employed permit? just apply from abroad?
02:48:39 <joelr1> shapr: or is that sort of an extension out of the partner permit
02:48:54 <shapr> If you purchase or create a company in Sweden you can get that flavor of permit. I just happened to already have a company.
02:49:14 <shapr> Nah, I seem to be the first person ever to switch permit types.
02:49:16 <dcoutts> dons, can we move the loop fusion stuff to Internal/Base? and why does it need to be exported exactly?
02:49:27 <shapr> At least, the immigration office had never heard of another.
02:49:38 <shapr> They said "We don't have any forms for that!"
02:49:53 <joelr1> shapr: cool! if i ever get booted out of spain i'll try the swedish permit :D
02:50:00 <dcoutts> shapr, you broke the system !?
02:50:05 <shapr> dcoutts: Second time..
02:50:14 <joelr1> shapr: and the first?
02:50:29 <davidhouse> joelr1: come live in england, the weather's much better than spain's ;)
02:50:41 <dcoutts> davidhouse, it's currently raining
02:50:54 <shapr> First time was when I moved from Finland. I had a permit from Finland that had to be honored by Sweden, but Sweden's other rules said that I had to apply from Finland and wait until my permit passed to get in. So they made new laws for me.
02:50:58 <joelr1> davidhouse: i know! that's why all the british folk are spending their time in tenerife :D /where i live/
02:51:00 <davidhouse> dcoutts: it's a kind of drizzly half-rain, mostly-cloudy where i am.
02:51:15 <joelr1> shapr: wow!
02:51:41 <shapr> Yeah, I always push the boundaries...
02:51:52 <dcoutts> davidhouse, and it's been like that for weeks! and we're in a drought apparently :-)
02:52:03 <shapr> Now I just need to make enough money that I can stay in Sweden with my woman.
02:52:21 <shapr> Actually, make enough *taxes*
02:52:26 <davidhouse> dcoutts: hehe, right. the chelsea flower show were doing a big thing on "How To Beat The Drought", and on the first day i don't think it stopped raining :)
02:52:33 <davidhouse> good ol' british summers.
02:52:38 <dcoutts> aye
02:53:30 <jethr0> a friend of mine works in the US and is a british citizen. to prolong his work status he had to go to the american embassy in his home country to reapply from there. and since the embassy  can't be called from abroad and has a serious waiting times, this whole thing got a little out of hand
02:53:32 <Saulzar> Good for playing avoiding defeat in test cricket
02:54:01 <joelr1> jethr0: i think the us is starting to suck immigration-wise
02:54:10 <shapr> I've been making enough money to pay for rent, food, and the occasional new bit of hardware. Then I get to spend the rest of my time learning new stuff :-)
02:54:16 <aleator> dcoutts: About the c2hs thing.  Any tips (on how to get involved in fixing it?) 
02:54:25 <shapr> jethr0: Sounds like Sweden though.
02:54:32 <joelr1> shapr: what's your tax rate? sweden is notoriously unfriendly to small businesses i think
02:54:36 <shapr> It's really hard to get from one country to another unless you marry someone.
02:54:44 <shapr> joelr1: 25% of everything.
02:54:46 <jethr0> anyone here know how hard it is for a CS graduate to get a working permit for the US?
02:55:01 <joelr1> shapr: that's of gross or net income? i.e. after deductions?
02:55:03 <shapr> joelr1: Basically, you get to keep 50% of your income after costs are counted out.
02:55:11 <swiert> jethr0: kind of depends.
02:55:17 <joelr1> jethr0: rather impossible i would say
02:55:20 <neologism> may I ask.. had SoC proposal by Jiri Hysek mentor? and what was his ranking? if someone knows...
02:55:21 <dcoutts> aleator, you mean a workaround or fixing it properly?
02:55:45 <joelr1> you need a work visa. this will take a year if your a lucky. if you miss it will take two or more. what employer is gonna wait that long?
02:55:46 <shapr> joelr1: Business costs are not taxed. Everything else is.
02:55:48 <jethr0> swiert: i.e. with a job offer and without. a friend of mine just went to the US, but he already had a company that desperately wanted him
02:56:05 <swiert> jethr0: I just applied for a visa for a summer internship in the US. It all worked pretty smoothly, but I all ready had an offer waiting for me.
02:56:06 <joelr1> shapr: how do you end up retaining 50% then if the rate is 25%
02:56:26 <dcoutts> neologism, we found a mentor but that project didn't get into our top 9
02:56:27 <swiert> *already
02:56:29 <joelr1> swiert: summer internship != work visa
02:56:41 <neologism> dcoutts: thnx
02:56:45 <adu> wow
02:56:46 <swiert> joelr1: it does if you get paid ;-)
02:57:00 <neologism> dcoutts: what rank it was? out of how many
02:57:01 <shapr> joelr1: I think because personal costs are taxed.
02:57:01 <aleator> dcoutts: Well, I probably could cope with workaround, but if I can grok the thing I might help with real fix.
02:57:02 <joelr1> swiert: hmm
02:57:14 <shapr> Hm, I don't remember. It's too early for tax math.
02:57:21 <shapr> four minutes till noon!
02:57:25 <adu> if us companies are so desparate for CS people i wonder why i can't find a job
02:57:31 <joelr1> shapr: oh, hang on, so you pay 25% in business tax and then you still pay personal tax on what you pay yourself. right?
02:57:33 <dcoutts> aleator, ever played with grammars, eg yacc/happy ?
02:57:44 <shapr> joelr1: yup
02:58:07 <swiert> joelr1: but admittedly, it is only temporary and I have to leave after three months and promise not to immigrate, speak sufficient english, have decent health insurance, etc.
02:58:17 <davidhouse> hmm. time for some enthralling statistic revision, methinks.
02:58:22 <davidhouse> *statistics
02:58:25 <dcoutts> neologism, 33 out of 111
02:58:25 <shapr> I wish I could trade a US work/residence permit with a Swedish citizen so I could stay here.
02:58:26 <aleator> dcoutts: A little, but thats some years ago..
02:58:29 <shapr> That would be nice.
02:58:48 <swiert> \msg kosmikus I was wondering about lhs2TeX and sigplanconf.
02:58:54 <adu> heh
02:58:55 <swiert> damn latex.
02:58:58 * shapr grins
02:59:00 <joelr1> shapr: come to spain, it's much warmer here ;-)
02:59:06 <shapr> joelr1: And I bet it has lower taxes
02:59:11 <shapr> joelr1: But it doesn't have my woman
02:59:16 <davidhouse> swiert, that could have been very funny ;)
02:59:26 <dcoutts> aleator, well basically we've got a happy grammar for GNU C, but clearly it doesn't match the real GNU C gramar completely accurately.
02:59:26 <adu> shapr: and less chemtrails
02:59:27 <joelr1> shapr: not that much lower but bring your woman :D
02:59:40 <swiert> davidhouse: don't worry it is not particularly private.
02:59:44 <neologism> dcoutts: thnx
02:59:47 * jethr0 is repeatedly amazed about the >100% luxury tax of denmark and i think sweden too.
03:00:06 <shapr> Germany has .. 16% taxes?
03:00:19 <jethr0> just switching to 19% VAT
03:00:21 <joelr1> jethr0: what's that tax? on luxury cars and such?
03:00:26 <shapr> The lowest VAT in the EU is 15%, I'd like to find that place.
03:00:33 <joelr1> the vat is 5% in the canaries
03:00:38 <dcoutts> aleator, we should try and find a spec for GNU C and improve the parser based on that. Some of this may come under the scope of the Language.C SoC project that got funding.
03:00:40 <shapr> I'm considering moving to Zagreb, Croatia if Sweden kicks me out.
03:00:41 <jethr0> joelr1: yes, cars and i think anything expensive without a purpose :)
03:00:44 <joelr1> shapr: we also have an offshore zone here
03:00:56 <dcoutts> shapr, Croatia is nice
03:01:05 <joelr1> shapr: why croatia? tenerife is a short flight away 
03:01:06 <shapr> And I have friends there
03:01:33 <aleator> dcoutts: Hmm. Is there other spec than the implementation even? (ibid?)
03:01:37 <joelr1> anyway, enough of tenerife advocacy. i gotta go get work done :-(
03:01:47 <shapr> Me too
03:01:53 <joelr1> cheers everyone!
03:01:56 <dcoutts> aleator, I suspect not, I looked at the gcc yacc parser
03:01:56 <jethr0> "180% luxury tax on cars in Denmark"
03:01:57 <shapr> joelr1: Any pointers or tips for contracting?
03:01:58 <adu> later
03:02:07 <aleator> dcoutts: What would be the idea for a workaround?
03:02:18 * shapr really wants to stay with his woman
03:02:26 <joelr1> shapr: indeed.com. that's how i got this excellent lisp job. and i was truly in the dumps.
03:02:27 <dcoutts> aleator, define __attribute__(x) to nothing
03:02:36 <shapr> joelr1: Thanks, I'll try it.
03:02:41 <dcoutts> aleator, see Manuel's message on the c2hs list
03:02:47 <joelr1> shapr: and lots of resumes to send out, of course
03:02:51 <dcoutts> aleator, same for asm
03:02:58 <shapr> Been doing that one
03:03:15 <shapr> Oh, I have more to send out
03:03:17 <shapr> joelr1: thanks!
03:03:24 <joelr1> shapr: u r welcome
03:04:04 <araujo> morning!
03:04:34 <vincenz> araujo: boing
03:04:39 <aleator> dcoutts: Ah. Hmm. yes. Thank you.
03:04:48 <araujo> hello vincenz 
03:08:45 <dcoutts> dons, still up?
03:08:49 <dcoutts> @localtime done
03:08:51 <dcoutts> err
03:08:53 <dcoutts> @localtime dons
03:08:54 <lambdabot> Local time for dons is Wed May 24 20:02:40 2006
03:10:26 <dcoutts> dons, I'm writing a loopU for [ByteString]
03:12:17 <aleator> dcoutts: Probably same for __extension__ as well?
03:12:37 <dcoutts> aleator, I don't know much about that
03:15:14 * davidhouse <3 emacs calculator
03:16:02 <shapr> It is way cool
03:16:19 <davidhouse> i want a real life version.
03:16:21 <davidhouse> are there any?
03:18:09 <shapr> You can run emacs on the Nokia 770, does that count?
03:19:02 <davidhouse> hehe awesome :)
03:19:30 <davidhouse> does emacs calculator have a key reference somewhere?
03:19:57 <shapr> Yeah, but it's massive
03:20:04 <dons> dcoutts: ok. very interesting.
03:20:15 <davidhouse> shapr: all right, what's the "square" button?
03:20:30 <davidhouse> or do i have to press 2 ^
03:20:34 <aleator> dcoutts: Apparantly I shouldn't do that..
03:20:52 <dcoutts> dons, if we flip some pairs about then: loopUList f a = List.mapAccumL (loopU f) a
03:21:05 <dons> ah!
03:21:11 <dons> very clever
03:21:23 <shapr> davidhouse: Um, it's stack based, so I think you just push 2 and the square op (which I forget)
03:21:31 <dcoutts> dons, mapAccumL takes and returns it's accum and [] pairs backwards from loopU
03:21:38 <shapr> davidhouse: Oh, are you using the one line version?
03:21:51 <davidhouse> nah, the stack one.
03:22:10 <dcoutts> ie loopU would need the type: (acc -> Word8 -> (Maybe Word8, acc)) -> acc -> ByteString -> (acc, ByteString)
03:22:11 <shapr> I read the docs for emacs calculator once, but it took me about a day to try out everything.
03:22:30 <shapr> I did taylor series(?) with it. Hadn't heard of them before that.
03:22:50 <davidhouse> i would have thought that there would be a shortcut for ^ 2 though.
03:23:02 <davidhouse> like q (or maybe Q? i don't remember) is a shortcut for 0.5 ^
03:23:17 <shapr> I don't know, there might be.
03:23:26 <dcoutts> dons, otherwise its: loopUList f a = swap . List.mapAccumL (\a' -> swap . loopU f a) a
03:23:30 <shapr> I didn't end up using it much, sadly.
03:23:31 <dcoutts> where swap (a,b) = (b,a)
03:23:44 <dons> dcoutts: and then we'd need to be careful to have the swaps removed.
03:23:48 <shapr> I wish someone had put as much effort into the semantic bovinator as was put into the emacs calculator.
03:23:53 <dons> possibly they get optimised away
03:23:59 <dcoutts> dons, possibly
03:24:13 <tromp> why calc in emacs when you can calc in haskell?
03:24:21 <dcoutts> dons, but is List.mapAccumL subject to list fusion?
03:24:25 <davidhouse> tromp, have you used emacs calculator?
03:24:25 <tromp> or in yi ;0
03:24:34 <tromp> no, i'm a vi guy
03:24:39 <dons> dcoutts: hmm. not sure.
03:24:43 <dons> probably not.
03:25:17 <dcoutts> dons, it's defined in ghc as an explicit recursion rather than in terms of fold or anything else
03:25:24 <shapr> davidhouse: tromp has a point, seen the Haskell road to logic and ... ?
03:25:29 <davidhouse> tromp, emacs calculator is... something to be experienced ;)
03:25:35 <tromp> yeah, i proofread it
03:25:44 <tromp> written by a colleague of mine
03:25:47 <dcoutts> dons, btw it's safe to send the SoC email to the haskell list
03:25:53 <dons> ok.
03:25:57 <dons> just wondering that
03:26:15 <davidhouse> shapr, no, what does it concern?
03:26:18 <shapr> davidhouse: http://homepages.cwi.nl/~jve/HR/
03:26:57 <shapr> And as tromp said, it's written by a colleague of his and he proofread it. It's nice to be in such a well connected community :-)
03:27:53 <davidhouse> it's a book? aww :(
03:28:06 <vincenz> tromp: hello!
03:28:11 <vincenz> tromp: been a while :)
03:28:29 <shapr> RvGaTe: If you have any questions, feel free to ask me.
03:28:58 <RvGaTe> shapr: just needed to know if it was available for windows, not going into it today, maybe tommorow
03:29:16 <shapr> RvGaTe: Yup, two of the best Haskellers work at Microsoft Research
03:29:35 <vincenz> is ~> a name reserved for functios
03:29:37 <vincenz> or datacons
03:29:37 <RvGaTe> shapr: doesn't mean it runs best on windows :P
03:29:40 <shapr> vincenz: arrows
03:29:49 * dons sends
03:29:54 <vincenz> shapr: arrows are not a haskell syntactical unify
03:29:55 <vincenz> unit
03:30:20 <shapr> RvGaTe: Hm, I don't know where it runs best. But Haskell does work on Windows, Linux, Mac OS X, and lots of other platforms.
03:30:29 <vincenz> > let (~>) a b = a+b in a ~> b
03:30:29 <lambdabot>  Not in scope: `b'
03:30:33 <vincenz> > let (~>) a b = a+b in 1 ~> 2
03:30:34 <lambdabot> 3
03:30:37 <vincenz> darn
03:31:03 <shapr> ~> is already defined as an arrow constructor. I'm not sure if it's in 6.4.x though.
03:31:04 <RvGaTe> shapr: if i would create something using windows, will that same program run on all the others?
03:31:14 <vincenz> shapr: yes but in a lib
03:31:24 <tromp> hi vincenz
03:31:25 <vincenz> shapr: I was asking in general...can one use it as a funcname or a datacons
03:31:31 <vincenz> tromp: :)
03:31:37 <norpan> i don't think there are any reserved names other than those that have special syntax
03:31:38 <vincenz> I guess it's a funcname
03:31:41 * vincenz uses :~>
03:31:42 <shapr> RvGaTe: If you bind to any windows-specific DLLs, it won't.
03:31:49 <norpan> yeah
03:31:50 <dons> full details of the Google SoC Haskell projects should now be in your haskell@haskell.org mailbox.
03:31:58 <RvGaTe> shapr: good
03:31:59 <norpan> constructor ops all start with :
03:32:08 <vincenz> yay dons
03:32:11 <vincenz> norpan: thx
03:32:11 <norpan> it's the equivalent of capital letter
03:32:11 <davidhouse> dons: yay! :D
03:32:14 <shapr> RvGaTe: But if you write platform neutral code, you'll only need to compile the code with your choice of compiler on your choice of platforms.
03:32:37 <RvGaTe> shapr: so i need to compile for each platform?
03:32:55 <shapr> RvGaTe: Yup, much like Visual C++ can't generate Linux binaries.
03:33:16 <shapr> I was going to say that gcc running on Linux can't generate Win32 binaries, but it might be able to ....
03:33:32 <norpan> i suppose you can set it up to cross-compile
03:33:39 <davidhouse> "Port Haddock to use GHC", "GHCi based debugger for Haskell", "Thin out cabal-get and integrate in GHC" yay :D
03:33:44 <shapr> There's also the YHC compiler, it generates bytecode that does not need to be compiled for each platform.
03:33:45 <RvGaTe> shapr: is it possible, that when i compile, it compiles for both linux and windows at the same time? (so basicly compiling it twice)
03:34:02 <dons> also, here is the SoC projects announcement: http://article.gmane.org/gmane.comp.lang.haskell.general/13726
03:34:45 <shapr> RvGaTe: I don't know if that's possible. I've only tried programs that were compiled for the same platform with that platform's version of GHC.
03:35:31 <shapr> YHC will definitely do that, but I don't know if YHC is ready for everyday use yet.
03:36:40 <swiert> kosmikus: I'd expect not any - remember the lambda cube starts with simply typed lambda calculus.
03:37:10 * shapr wants to hear the rest of that conversation
03:43:07 <davidhouse> dons, did you get bored of waiting for google or have they announced something too?
03:44:58 <RvGaTe> shapr: are there screenshots or something so i can know how it looks like to work with haskell in windows?
03:45:40 <RvGaTe> oh wait
03:50:22 <dozer> I seem to be in dependency hell
03:50:31 * mux waves hello
03:51:06 <dozer> is there a way to get out the dependency graph for all the modules that a given cabal is using?
03:51:09 <dozer> and to flag up clashes?
03:51:43 <vincenz> is there such a thing as
03:51:52 <vincenz> foldr1 (>>) 
03:52:10 <vincenz> kinda like sequence_ but keep the last value
03:52:21 <vincenz> > foldr1 (>>) [Just 1, Just 2, Just 3, Nothing, Just 4]
03:52:22 <lambdabot> Nothing
03:52:24 <vincenz> > foldr1 (>>) [Just 1, Just 2, Just 3,  Just 4]
03:52:25 <lambdabot> Just 4
03:53:00 <davidhouse> > msum [Just 1, Just 2, Just 3,  Just 4]
03:53:01 <lambdabot> Just 1
03:53:42 <davidhouse> vincenz: foldr1 (>>) works, right?
03:54:01 * int-e chants 'sequence'
03:54:16 * int-e thinks.
03:55:11 <davidhouse> > sequence [Just 1, Just 2, Just 3,  Just 4]
03:55:12 <lambdabot> Just [1,2,3,4]
03:55:26 <davidhouse> > sequence [Just 1, Just 2, Just 3, Nothing, Just 4]
03:55:27 <lambdabot> Nothing
03:55:48 <davidhouse> int-e, well, not quite right. it'd be [m a] -> m a , not [m a] -> m [a]
03:56:16 <vincenz> davidhouse: yeah
03:56:31 <int-e> Oh I should just stop replying to the last 3 lines of chat without reading more of the history. Sorry.
03:56:55 <mahogny> int-e, LR, 3 tokens look ahead? ;)
03:58:05 <mahogny> anyone seen ryanT as of lately?
03:58:16 <davidhouse> @seen ryanT
03:58:16 <lambdabot> I haven't seen ryanT.
03:58:20 <davidhouse> clearly not. :)
03:58:26 <mahogny> that bad huh
04:02:55 <dozer> I'm getting errors like:
04:03:03 <dozer> Loading package HTTP-2006.3.25 ... linking ... done.
04:03:03 <dozer> ghc-6.4.2: /usr/local/lib/hxt-5.5/ghc-6.4.2/HShxt-5.5.o: unknown symbol `NetworkziBrowser_lvl88_closure'
04:03:03 <dozer> Loading package hxt-5.5 ... linking ... ghc-6.4.2: unable to load package `hxt-5.5'
04:03:17 <dons> -package hxt ?
04:03:24 <dons> oh h..
04:03:27 <dons> -package network, perhaps
04:04:02 <dozer> hum - is that something I pass to runhaskell Setup.lhs?
04:04:34 <eivuokko> Huh.
04:04:38 <mahogny> uh
04:04:47 <eivuokko> Cabal script that downloads something for you or what?
04:07:43 <dozer> I've modified the HTTP package and bumped its version number, but it seems that I've not tracked down all the other modules taht depend on it
04:07:49 <dozer> and rebuilt them
04:10:25 <vincenz> @type zipWith
04:10:26 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
04:11:01 <vincenz> @type mapM_
04:11:02 <lambdabot> forall (m :: * -> *) a b.
04:11:02 <lambdabot>    (Monad m) =>
04:11:02 <lambdabot>    (a -> m b) -> [a] -> m ()
04:12:29 <dozer> conflict: module `Network.HTTP' is present in multiple packages: HTTP-2006.3.24, HTTP-2006.3.25
04:12:45 <dozer> aarg!!!!
04:12:51 <mahogny> sounds like you have one too many
04:12:52 <mahogny> :P
04:13:42 <eivuokko> ghc-pkg hide HTTP-2006.3.24
04:13:56 * dozer goes to buy a kettle and hopes one version of HTTP will dissapear
04:16:50 * vincenz finds a typing bug in haskell :(
04:19:17 <vincenz> basically
04:19:22 <vincenz> I need to do something like
04:19:25 <vincenz> cae ... of
04:19:37 <vincenz>    p@Record { name = name}
04:19:44 <vincenz>      p@Record{name = name}
04:19:46 <vincenz> a nop 
04:19:51 <vincenz> just to change the type of p
04:20:07 <davidhouse> huh?
04:20:10 <mahogny> uh
04:20:13 <mahogny> that looks weird
04:20:13 <davidhouse> what do you want to do?
04:20:14 <vincenz> yep
04:20:18 <vincenz> no
04:20:19 <mahogny> change type??
04:20:20 <davidhouse> transform one record into another?
04:20:21 <vincenz> tat's what I needed to do
04:20:25 <vincenz> to change the type
04:20:36 <mahogny> since when do one cast types in haskell? :)
04:20:40 * vincenz thinks of writing a mail to haskell-cafe
04:20:47 <vincenz> mahogny: thanks for giving me a good title
04:20:49 <davidhouse> from what i can see, those two lines are precisely the same.
04:20:53 <vincenz> typecasting in haskell 
04:20:54 <vincenz> :D
04:20:58 <vincenz> davidhouse: yet they are not ;)
04:21:05 * vincenz writes a trivialer case
04:21:20 <mahogny> vincenz, I think you are doing something fucked up. what are you Really trying to achieve?
04:22:45 <vincenz> mahogny: I have achieved what I want to achieve
04:22:47 <vincenz> tyvm
04:23:17 <mahogny> and that is? :)
04:30:37 <vincenz> sent to ml
04:30:52 <vincenz> mahogny: I typically use indirect composite for AST representation
04:31:04 <vincenz> cause it allows me to reuse the same datacons over and over in all stages of my compiler
04:31:20 <vincenz> at a certain point, one of the datacons does not depend on the changed type
04:31:20 <mahogny> hmm
04:31:25 <vincenz> yet it still requires to be changed
04:31:28 <vincenz> cause the original variable is bound
04:32:07 <vincenz> it's rathe rfunky :)
04:32:08 <vincenz> btw
04:32:09 <mahogny> doesn't sound too messy but I'd need to dig into the details to see the problem :/
04:32:21 <vincenz> mahogny: I made a SMALL example on haskell-cafe
04:32:26 <vincenz> which illustrates the problem
04:32:39 <vincenz> anywho
04:32:42 <vincenz> I'm happy
04:32:44 <vincenz> I'm getting stuff like
04:32:54 <vincenz> [TyCons Foo] :~> Tyvar 'b'
04:32:57 <vincenz> out of my system
04:32:58 <vincenz> \o/
04:33:16 <vincenz> so my unification works over functions
04:33:18 <vincenz> woot woot
04:34:18 <Lemmih> vincenz: The issue has been brought up before.
04:34:19 <vincenz> (yeah my functiosn are not a -> b -> c but [a,b] -> c)
04:34:24 <vincenz> Lemmih: oh, I did not know that
04:34:28 <vincenz> :/
04:34:40 <vincenz> I just found it curious
04:34:43 <vincenz>  Ican see the reasoning behind it
04:34:53 <vincenz> thought I'd share :)
04:35:21 <vincenz> it's basically in the same issue set as phantom types no?
04:35:27 <vincenz> cause in effect for Bar, one type is phantomed
04:44:59 <davidhouse> hmm... i wouldn't really call that an issue.
04:45:06 <davidhouse> it's a little odd, but it makes sense.
04:46:43 <davidhouse> anyway, i'm off to a statistics exam.
04:48:50 <vincenz> cya
05:20:50 <shapr> abracadabra!
05:21:18 <Lemmih> Neat. You just pulled kpreid_ out of limbo.
05:21:41 <shapr> wow!
05:21:56 <kpreid_> hi shapr
05:23:35 <jethr0> shapr: what do you want augmented reality glasses for anyways?
05:31:46 <aleator> shapr: What's a cool way of timing function calls in ghci?
05:33:12 * jethr0 didn't know there was even an uncool way
05:33:39 <aleator> probably System.CPUTime would be involved..
05:34:03 <Lemmih> aleator: :set +s?
05:34:34 <jethr0> hmm, but lazyness makes it hard to capture specific functions completely. i think going with "ghc --auto-all -prof" is a solution
05:34:34 <aleator> Ah. There it is! 
05:34:54 * jethr0 has to look into the ghci manual to find out about all the features :)
05:36:06 <aleator> Now I only need a general trick to force evaluation..
05:36:12 * vincenz wishes palomer were here
05:36:17 <jethr0> @hoogle evaluate
05:36:18 <lambdabot> Control.Exception.evaluate :: a -> IO a
05:36:18 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
05:36:39 <vincenz> joelk: are you the joel that replied to that email?
05:36:42 <vincenz> @seen joelk 
05:36:42 <lambdabot> joelk is in #haskell. I last heard joelk speak 8 hours, 2 minutes and 29 seconds ago.
05:36:43 <jethr0> or maybe abusing "$!" or "seq"
05:37:09 <vincenz> jethr0: my typechecker infinitely recurses :(
05:37:11 <aleator> c.e.Evaluate doesn't. :/
05:37:27 <jethr0> aleator: i think it does. at least to normal form
05:37:43 <vincenz> foo x y= x y; bar x = foo bar bar
05:38:07 <jethr0> applying a function on itself?
05:38:17 <vincenz> erm yep
05:38:20 <jethr0> k
05:38:31 <vincenz> but it should at least gimme a circularity error
05:38:34 <vincenz> not recurse ad infinitum
05:38:40 * vincenz sniffs
05:38:49 <jethr0> you're really looking for the fixpoint type :)
05:39:02 <vincenz> nono
05:39:07 <vincenz> fixpoint type my ...
05:39:20 <vincenz> @hawiki IndirectComposite
05:39:20 <lambdabot> Maybe you meant: gwiki wiki
05:39:21 <aleator> jethr0: evaluate $ take 100000 fib --> (0.00 secs, 0 bytes) 
05:39:24 <vincenz> @gwiki IndirectComposite
05:39:25 <lambdabot> No Result Found.
05:39:28 <vincenz> @wiki IndirectComposite
05:39:28 <lambdabot> http://www.haskell.org/haskellwiki/IndirectComposite
05:39:46 <jethr0> aleator: as i said, it evaluates to normal form, afaik
05:40:13 <aleator> Ah, read you wrong there. 
05:40:39 <vincenz> sometimes I wonder about people
05:40:46 * vincenz got a reply from haskell cafe
05:40:50 <vincenz> "Hello crostophe"
05:41:06 <vincenz> my name was at least 2-3 times in that mail, not to mention the mailaddress
05:41:22 <jethr0> plus "chrostophe" ain't a name
05:41:58 <vincenz> jethr0: remove the h
05:42:04 <vincenz> see you naturally even put in the 'h'
05:42:23 <vincenz> I can understand thinking crostophe is a name based on cultural difference
05:42:28 <vincenz> but the mail said my name!
05:42:31 <jethr0> aleator: if it's a list you have to deepseq it
05:42:45 <rjlwanro> sounds like catastrophe
05:42:56 <vincenz> hehe
05:43:02 <jethr0> aleator: maybe sth like "evaluate $ map evaluate ..." also works
05:44:19 * vincenz is going to sign "Ego" from now on
05:45:26 <aleator> jethr0: well, I think the real thing I need this for is simple Image -> Double so I can just evaluate it..
05:45:48 <jethr0> image?
05:46:06 <jethr0> @hoogle deepseq
05:46:07 <lambdabot> No matches found
05:46:45 <vincenz> jethr0: YAY!
05:46:52 <vincenz> jethr0: small fix and it works
05:47:00 <vincenz> Tester: user error (Trying to unify recursive type "d" = [TyVar "d"] :~> TyVar "e")
05:47:25 <aleator> jethr0: Image indeed. (FFI, opencv etc.)
05:47:36 <jethr0> aleator: ah, i know why evaluate didn't work. it returns in IO and unless you "execute" it, nothing's done
05:49:39 <aleator> jethr0: aha. Well, atleast this netted me a funny screenshot http://www.cc.jyu.fi/~aleator/fibarch.png.
05:49:58 <vincenz> aleator: what is taht?
05:50:33 <aleator> lots of fibonacci numbers that accidentally have commas funnily aligned..
05:52:31 <kzm> Anybody writing concurrent programs with GHC?
05:53:50 <vincenz> kzm: I did once
05:53:55 <vincenz> kzm: nothing really stupifying
05:54:17 <vincenz> it was an input-output program (for icfp05) so it would constatnly be blocked into a loop with the server, so I had a GUI running in a second thread
05:54:21 <kzm> I guess you didn't do SMP, then?
05:54:31 <vincenz> forkIO?
05:54:56 <kzm> I'm puzzled by the statement about using -Nx for x CPU cores, "not counting hyperthreaded cores".
05:55:17 <kzm> Presumably, they count them as a single core - but why not two?
05:55:53 <kzm> Is there a debian/ubuntu package with GHC >= 6.5?
05:56:11 <vincenz> cause hyperthreading : a) isn't really concurrent, b) doesn't really matter w.r.t caching policy
05:56:41 <jethr0> on single-cpu computers nothing is "really" concurrent
05:56:47 <vincenz> yeao
05:56:48 <vincenz> yeap
05:57:21 <kzm> On multi-scalar CPUs, everything is concurrent.
05:57:30 <vincenz> kzm: no it's not
05:57:35 <kzm> vincenz, is too.
05:57:37 <jethr0> not necessarily. depends on scheduling
05:57:43 <kzm> :-)
05:57:48 <jethr0> at least as we're talking about single process concurrency :)
05:58:04 <vincenz> define concurrent
05:58:04 <jethr0> *long as
05:58:13 <jethr0> that's enough sophism for today
05:58:39 <kzm> The whole point of multiscalar is that multiple ALUs and FPUs are active simultaneously.  But that is irrelevant.
05:58:59 <vincenz> kzm: yes but they're scheduled in a way to obey timing issues
05:59:04 <kzm> For HT, however, there shouldn't be any observable difference from a software perspective (from having two cores)
05:59:08 <vincenz> unless your processor is flawed
05:59:30 <vincenz> kzm: there is a big difference. you have tow different caches which need to be synced
06:00:07 <vincenz> let Tx,Ty = be two threads
06:00:14 <vincenz> let P(Tx) = processor
06:00:22 <vincenz> let C(Tx,Ty) = cost of communication
06:00:35 <vincenz> C(Tx,Ty) ~= 0 if P(Tx) == P(Ty)
06:00:44 <vincenz> and >>0 if P(Tx) != P(Ty)
06:01:15 <vincenz> why do you think tehre are so many papers on how to schedule DAGs of tasks on SMP systems
06:01:20 <vincenz> and noone gives a cent about HT?
06:01:34 <vincenz> HT is just a trick to make your cache appear faaster by switching out anything waiting for memory
06:02:17 <kzm> Okay.  Let me digest that for a second.
06:02:35 <vincenz> last point: atomic actions on 2 threads on 1 HT processor = trivial
06:02:47 <vincenz> atomic actions on 2 threads on 2 different procs = not so trivial
06:03:47 <kzm> Is the point that HT gives no benefit to an MT program?
06:04:06 <vincenz> HT makes your program slightly faster by switching really quickly if one thread waits for memory accesses
06:04:12 <vincenz> that's its main reason of existence
06:04:15 <kzm> Yes.  So why not?
06:04:20 <vincenz> so why not what?
06:04:31 <vincenz> why is SMP not the same as HT?
06:04:40 <vincenz> cause with SMP there are a lot mre issues
06:04:41 <kzm> Slightly faster sounds like slightly better too me, so why not schedule two threads?
06:05:18 <vincenz> the compiler setting for a GHc probably needs to know the amount of cores, cause this will seriously affect a lot of things
06:05:26 <vincenz> starting processes on one processor be it HT or not
06:05:37 <vincenz> is just as easy as forgotthestd_thread_start
06:06:37 <vincenz> HT just boosts it slightly is all
06:06:50 <kzm> I'm not sure I see the reason the compiler needs to know.  In particular, the -smp switch seems to have gone, and the only difference is -threaded to linking.
06:07:15 <vincenz> cause in threads on a monoprocesso
06:07:23 <vincenz> communication between any two threads = nearly nihil
06:07:36 <vincenz> multiprocessor, communication between threads on different procs is costly
06:07:46 <vincenz> so you wanna make sure you put things together that communicate often
06:08:09 <kzm> But all that is taken care of by the hardware and by the OS, isn't it?
06:08:31 <vincenz> kzm: well if that is your point of view
06:08:32 <kzm> (Do you even have a way to control what gets scheduled on which CPU?)
06:08:36 <vincenz> why by more than 1MB of RAM?
06:08:43 <vincenz> your OS will happily swap to H
06:08:44 <vincenz> HD
06:08:51 <vincenz> s/by/buy
06:08:57 <sentinel> kzm: no
06:09:16 <sentinel> you can get pretty much errors when programming with threads
06:09:34 <vincenz> sentinel: he's arguing that threads on HT monoproc is the same as threads on multicore
06:09:47 <sentinel> doubt that
06:09:56 <vincenz> kzm: just google for
06:09:58 <kzm> I'm just asking why I shouldn't schedule two OS threads on a HT CPU.
06:10:01 <vincenz> "scheduling tasks SMP"
06:10:03 <vincenz> TONS of papers
06:10:09 <sentinel> you wont see all possible errors that might occur on an SMP with a singlecore
06:10:14 <vincenz> kzm: there's nothing to schedule
06:10:25 <morans> thanks for the lambdabot in #haskell, whoever did that...
06:10:34 <vincenz> morans: -> dons
06:10:40 <morans> dons: thanks
06:10:55 <sentinel> OS threads? well threading is os specific so
06:11:32 <vincenz> kzm: for instance
06:11:54 <vincenz> kzm: there are MANY papers, that actually DUPLICATE tasks and therefore do MORE work, to speed up a multitasking application on an SMP systme
06:12:13 <vincenz> cause the communication bottleneck between cores is so high
06:12:29 <vincenz> (narrow?)
06:12:49 <tromp> question about ghci:
06:12:56 <tromp> can you make it show #reductions?
06:13:54 <kzm> It seems to me you're saying that I should rather be writing a single-threaded program?
06:14:00 <vincenz> tromp: don't know, but that would imply that it's stored as someting that is reductionable instead of bytecode or assembly
06:14:10 <kzm> -s?
06:14:13 <int-e> tromp: as far as I know the ghc RTS doesn't keep track of them.
06:14:16 <vincenz> kzm: no what I'm saying is that you souldn't confuse SMP threads and HT threads
06:14:45 <tromp> seems it can only report seconds and bytes used
06:15:04 <SamB> if you want those, use hugs?
06:15:07 <vincenz> tromp: make a haskell parser/typechecker that keeps an AST?
06:15:13 <SamB> what is a reduction, anyway?
06:15:15 <vincenz> tromp: then reductionate the AST yourself?
06:15:37 <SamB> is it even meaningful to talk about reductions in GHC?
06:15:40 <vincenz> tromp: not sure how it'd work in a lazy system tho
06:16:30 <int-e> SamB: I suppose you could count the number of closures entered ...
06:16:47 <vincenz> the problem isi that number is not uniquely defined
06:16:48 <kzm> Again: how can my program tell the difference?  The OS just reports two CPUs - how will my program know whether it is HT or SMP?
06:17:08 <vincenz> kzm: It's a COMPILER switch
06:17:27 <vincenz> the compiler needs to know to do a somewhat decent mapping
06:17:30 <kzm> What is a compiler switch?  -threaded?
06:17:36 * vincenz palmslaps
06:17:47 <vincenz> didn't we start this conversation with "-Nx" is only for x number of cores and not threads
06:17:48 <int-e> vincenz: HT mimics SMP as far as the OS is concerned. Actually the idea is to schedule independent tasks on the same core for more parallelism.
06:17:51 <oNoX> I have currently a list where every element is a ([Char], (Integer, Integer))
06:17:52 <kzm> If that is correct, somebody needs to severly update the documentation.
06:18:08 <kzm> -N is not a compiler switch, it is an RTS switch.  According to the documentation.
06:18:17 <vincenz> int-e: well with communicating tasks, wrongly allocating them to cores can seriously ruin performance
06:18:34 <oNoX> but "sortBy (\([k],(n,c)) ([l],(o,d)) -> c > d || n < o ) theMap" gives a type error
06:18:58 <vincenz> int-e: and I doubt HT came from SMP, it's just a way to hide memory-latency
06:19:18 <kzm> And it only tells the RTS to launch x OS threads, you have - as far as I can tell - no way to control scheduling more closely.
06:19:34 <kzm> And: why shouldn't you want to hide memory latency?
06:19:39 <jethr0> tromp: i know gofer lists number of reductions, and it's pretty similar to haskell (except some of the typesystem)
06:19:50 <vincenz> kzm: I'm not saying that is a bad thing
06:19:58 <oNoX> am I doing something wront in sortBy
06:19:59 <oNoX> ?
06:20:02 <vincenz> kzm: I'm saying it's a -different- thing
06:20:03 <kzm> The documentation seems to.
06:20:03 * vincenz  gives up
06:20:20 <vincenz> jethr0: gofer is newer, right?
06:20:27 <kzm> I was going to fix it, but I need to know what to fix it *to*.
06:20:29 <kzm> Okay.
06:20:34 <jethr0> no, i don't think so, but i'm not sure
06:20:41 <kzm> Sorry if I'm unclear, and thanks for the patience.
06:20:45 <jethr0> @type sortBy
06:20:45 <int-e> vincenz: it surely didn't come from SMP but from the fact that cores were scheduling instructions anyway looking for opportunities to parallelize them. It certainly has different performance characteristics than SMP. But it still behaves like two cores for most semantic purposes.
06:20:45 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:20:47 <vincenz> jethr0: hmm, nm then
06:21:02 <jethr0> oNoX: you need to return an ordering. i.e. use "compare"
06:21:33 <jethr0> > sortBy (\(_,x) (_,y) -> compare x y) [(1,4), (2,3)]
06:21:33 <vincenz> int-e: well I find it seriously different cause for HT, it's mostly about getting a bit more juice out of it, with SMP there are a lot more issues, hence the multitude of papers on how to map applications efficiently onto the
06:21:33 <lambdabot> [(2,3),(1,4)]
06:21:51 <kzm> Perhaps the channel will suffer another question:  The docs claim STM has been supported since 2005, but will first be available in GHC 6.6.  Huh?
06:21:59 <jethr0> oNoX: an ordering is either EQ,GT or LT, afair
06:22:54 <vincenz> > sortBy (const $ const EQ) [1,2,3,4]
06:22:55 <lambdabot> [1,2,3,4]
06:22:59 <SamB> why does the SoC page still say that they will publish the list on it on the 23rd?
06:23:00 <kzm> Or was 6.6 released way back, and I just didn't notice it?  Or do they mean STM+SMP?
06:23:06 <SamB> it is now the 24th...
06:23:16 <vincenz> @localtime SamB 
06:23:18 <lambdabot> Local time for SamB is Wed May 24 09:25:08
06:23:21 <oNoX> sortBy (const $ const EQ) [3,2,1,4]
06:23:48 <dcoutts> 14 lazy loop/loop fusion!
06:23:51 <dcoutts> dons, ping!
06:24:13 <vincenz> dcoutts: he hasn't spoken in quite a while
06:24:18 <kzm> (Oh well, it seems to be in my 6.4.something)
06:24:36 <jethr0> oNoX: btw, your ordering make no sense since it returns a bool.
06:24:39 <dcoutts> vincenz, I know. he'll be asleep. he'll see my messages when he wakes up though
06:24:52 * vincenz nods
06:24:57 <jethr0> i think you might have meant "-> if c > d then GT else if n < o then LT else EQ" or so
06:24:59 <vincenz> dcoutts: even if they're separated?
06:25:04 <dcoutts> dons, that's one less than for ByteString because I've only converted map & filter so far, not foldl, scanl etc
06:25:15 <dcoutts> vincenz, huh?
06:25:24 <vincenz> dcoutts: you didn't put dons on the line that had the statement about gains
06:25:41 <jethr0> "case () of () c > d -> GT | n < o -> LT | otherwise -> EQ"
06:25:45 <dcoutts> vincenz, I did on the one after, so he'll see
06:25:48 <vincenz> hmm
06:25:50 <vincenz> fancy logging :)
06:26:06 <vincenz> do you know what he uses?
06:26:10 <dcoutts> nope
06:26:22 <kzm> xchat, I thought.
06:26:26 * kzm checks.
06:26:42 <mauke> ok, I need syntactical advice
06:27:19 <dcoutts> dons, so it looks like as long as our loopU on [ByteString] is correct that we can make it work.
06:28:24 <dcoutts> dons, we just use the same framwork and rules but on loopU for [ByteString] (which of course calls loopU for ByteString
06:28:42 <dcoutts> dons, so we don't need to get two layers of fusion
06:29:17 <jethr0> tromp: as i just read "hugs" is a successor of gofer. so maybe you can turn on reduction display in hugs?
06:29:27 <dcoutts> dons, originaly we were thinking that we needed to get list fusion hapening so that we could bring the P.loopU calls together and then get array fusion
06:29:52 <dcoutts> dons, but it seems like we can just do the loopU fusion at the [ByteString] level
06:29:56 <fincher> there are web servers and web frameworks written in Haskell, right?  Anyone have some links?
06:30:44 <jethr0> tromp: "+s in hugs: shows number of reductions, number of cells, garbage collection"
06:31:05 <jethr0> @google haskell wash
06:31:07 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/WASH/
06:31:16 <xerox> Hi!
06:31:25 <xerox> Who pinged?
06:32:25 <jethr0> fincher: above link is to the "web authoring system haskell"
06:32:32 <xerox> Dear Applicant,
06:32:32 <xerox> Congratulations! This email is being sent to inform you that your
06:32:33 <xerox> application was accepted to take part in the Summer of Code.
06:32:37 <Daveman> xerox :)
06:32:45 <xerox> Yeeeaaaw!
06:32:55 <Daveman> xerox, oh, so they finally got sent out :P
06:33:05 <xerox> Yes!
06:33:09 <oNoX> jethr0: it throws a pattern match failure: only \(k,v) (l,w) works
06:33:24 <Daveman> xerox, I'll look now :(
06:33:38 <xerox> There's also a mail on the Haskell ML.
06:34:05 <oNoX> but I need like \([k],(v,c)) ([l],(w,d)) where c > d or v < w
06:34:16 <jethr0> oNoX: how do you want to sort? second component ascending and then first component descending?
06:35:12 <jethr0> > sortBy (... -> if c > d || v < w then GT else LT) ...
06:35:12 <lambdabot>  parse error on input `->'
06:35:37 <jethr0> using LT in else doesn't make it a stable sort, maybe EQ would work too
06:35:55 <int-e> oNoX: uhm, are you trying to match an arbitrary list wit [k]?
06:36:08 <xerox> http://www.haskell.org/pipermail/haskell/2006-May/017999.html
06:36:17 <oNoX> I have a list with ([name], (time, count))
06:36:35 <oNoX> sorting must be: highest count first, then lowest time
06:36:37 <int-e> hmm. why is name a list? *wonders*
06:36:48 <jethr0> you want (\(_,(t,c)) (_,(t',c'))
06:39:00 <jethr0> > sortBy (\(_,(t,c)) (_,(t',c')) -> if t > t' || c < c' then GT else LT) [("", (3,4)), ("",(4,2)), ("",(2,4))]
06:39:01 <lambdabot> [("",(2,4)),("",(3,4)),("",(4,2))]
06:39:29 <SamB> @type EQ
06:39:30 <lambdabot> Ordering
06:39:44 <SamB> @hoogle Ordering -> Ordering -> Ordering
06:39:45 <lambdabot> No matches, try a more general search
06:40:02 * xerox hugs the Haskell.org team
06:40:09 <norpan> 98 hugs
06:40:20 * SamB thinks there really ought to be one of those...
06:40:32 <SamB> haha
06:40:32 <jethr0> an ordering monad would be nice that bails out on anything but EQ, and continues otherwise
06:40:43 <jethr0> do {compare a b; compare c d}
06:41:00 <SamB> well, how would that work?
06:41:08 <SamB> phantom values?
06:41:14 <oNoX> hmm... I don't get any errors anymore
06:41:15 <jethr0> huh? just like Maybe does
06:41:27 <oNoX> but sorting isn't correct yet
06:41:39 <SamB> well, Maybe actually has a value of that type
06:41:52 <jethr0> oNoX: did you see my sortBy line above? by switching the elements in the boolean expression you should get your desired sort
06:41:54 <SamB> sometimes, anyway.
06:42:11 <SamB> and what would happen if you returned something?
06:42:31 <jethr0> EQ >>= x = x; GT >>= _ = GT; LT >>= _ = LT
06:42:54 <oNoX> I use _ now
06:43:25 <Bobstopper> How does one define a class say Foo a where a must be of the kind * -> *? (eg how would I go about defining the Monad class)?
06:43:27 <jethr0> or, more concise "EQ >>= x = x; y >>= _ = y"
06:43:46 <SamB> jethr0: that don't work
06:43:46 <SamB> you need to pass something to x in the first part!
06:43:50 <oNoX> does it sort depending on _?
06:44:17 <jethr0> SamB: i was just expressing the idea. i'll try to figure it out...
06:44:41 <SamB> isn't there some Monad law to the effect of "return x >>= f  =  f x"?
06:44:54 <vincenz> SamB: yes
06:45:00 <norpan> Bobstopper: the compiler will calculate the kind automatically from the functions in the class
06:45:25 <Bobstopper> norpan: yeah, that's what I figured but GHC keeps telling me "Kind error: `s' is applied to too many type arguments"
06:45:45 <norpan> then s have different kinds somewhere
06:45:46 <SamB> oNoX: what do you use _ for?
06:45:47 <Bobstopper> where "s" is like the "a" in my Foo a example above
06:45:48 <int-e> SamB: how about \(_,(t,c)) (_,(t',c')) -> compare (t,c') (t',c)
06:46:25 <SamB> Bobstopper: it works fine if you actually do something with the type constructor in a type signature of a method
06:46:30 <norpan> Bobstopper: so check all places where you use s in type signatures in your class
06:46:54 <SamB> you could maybe give the kind in the class head, like (s :: * -> *)
06:46:55 <Bobstopper> ah crap, I see it now. I had it using Eq etc. I guess it figured that an instance of Eq is of kind * and not * -> *?
06:47:10 <int-e> SamB: or compare (compare t t', compare c c') (EQ, EQ) :)
06:47:30 <int-e> err c c' -> c' c.
06:47:44 <norpan> Bobstopper: yes
06:48:11 <int-e> @type curry $ flip compare (EQ, EQ)
06:48:13 <lambdabot> Ordering -> Ordering -> Ordering
06:51:07 <norpan> Bobstopper: you will have to apply the Eq constraint to the functions instead I think
06:51:49 <Daveman> xerox, they apparently, did not hug me :(
06:51:58 <Bobstopper> Hmm ok. Thanks.
06:52:00 <xerox> :(
06:52:05 <Daveman> yeah
06:52:36 <Daveman> whatever, I
06:52:43 <Daveman> I'm still going to do hs stuff :P
06:54:40 <xerox> Good good good.
06:54:54 <xerox> It's fun nevertheless
06:55:13 <xerox> Man I'm hungry.  BBL
06:55:49 <oNoX> I still can only sort on c c'
06:56:37 <int-e> oNoX: I'd use \(_,(t,c)) (_,(t',c')) -> compare (t,c') (t',c)
06:57:12 <Daveman> heehee
06:58:07 <jethr0> > let sorter = foldl (\x y -> if x == EQ then y else x) EQ in sortBy (\(x,y,z) (x',y',z') -> sorter [compare x x', compare y' y, compare z z']) [(1,2,3),(3,2,1),(1,1,1),(3,2,3)]
06:58:07 <lambdabot> [(1,2,3),(1,1,1),(3,2,1),(3,2,3)]
06:58:27 <int-e> oNoX: (that compares t and t' and if they're equal c' and c instead - that's how the ordering for pairs is defined)
06:58:59 <oNoX> i need c < c' and if c == c' then t < t'
06:59:00 <int-e> > let sorter = flip compare (repeat EQ) in sortBy (\(x,y,z) (x',y',z') -> sorter [compare x x', compare y' y, compare z z']) [(1,2,3),(3,2,1),(1,1,1),(3,2,3)]
06:59:01 <lambdabot> [(1,2,3),(1,1,1),(3,2,1),(3,2,3)]
06:59:10 <jethr0> int-e: that's a nice solution. i didn't think of swapping elements in the tuples :)
06:59:30 <int-e> oNoX: then use compare (c,t) (c',t') instead.
07:00:16 <oNoX> no, doesn't work
07:00:28 <jethr0> ahh, i didn't know that compare worked on lists either
07:00:35 <jethr0> > compare [1,2,3] [3,2,1]
07:00:35 <lambdabot> LT
07:00:53 <int-e> jethr0: they have the obvious Ord instance (lexicographic order)
07:01:09 <jethr0> yes, i just didn't extrapolate that to compare :)
07:01:15 <norpan> compare "alfa" "beta"
07:01:16 <oNoX> 1st sorting is: 3rd element < 3rd element of next
07:01:18 <norpan> > compare "alfa" "beta"
07:01:19 <lambdabot> LT
07:01:20 <int-e> actually, hmm.
07:01:26 <int-e> > compare [EQ] [EQ, EQ]
07:01:27 <lambdabot> LT
07:01:37 <oNoX> 2nd sorting: where 3rd element is equal, 2nd element < 2nd element of next
07:01:41 <int-e> I should use replicate 3 EQ and not repeat EQ
07:02:10 <jethr0> > compare LT EQ
07:02:11 <lambdabot> LT
07:02:15 <jethr0> > compare GT EQ
07:02:16 <lambdabot> GT
07:02:30 <vincenz> how do you get fixity of an operator in ghci?
07:02:43 <oNoX> anything I have right now, does sort function correctly on 3rd element
07:02:47 <oNoX> but not on 2nd element
07:03:06 <int-e> vincenz: :info (op)
07:03:35 <alar> I don't have "runghc" on my system what should I use instead?
07:03:42 <vincenz> ah thx
07:03:50 <int-e> runhaskell?
07:03:56 * vincenz changes his op to
07:03:56 <vincenz> infixr :~?
07:03:58 <vincenz> infixr :~>
07:04:26 <int-e> oNoX: uh. just to clarify. In which order would you want ("",1,1), ("",2,1) to appear?
07:04:41 <int-e> oNoX: and ("",1,2) for sake of completeness?
07:05:05 <jethr0> > sortBy (\(_,(t,c)) (_,(t',c')) -> compare (t,c') (t',c)) [(1,(2,2)),(3,(2,1)),(1,(1,1)),(3,(2,3))]
07:05:06 <alar> no runhaskell as well
07:05:06 <lambdabot> [(1,(1,1)),(3,(2,3)),(1,(2,2)),(3,(2,1))]
07:05:31 <oNoX> ("",1,2) ("",1,1) ("",2,1)
07:05:41 <jethr0> oNoX: from what i understand that's exactly how you want it (modulo reversion)
07:05:50 <int-e> ok, then your last specification was wrong.
07:06:31 <oNoX> but how should the sorting be now? Using sortBy 2 times doesn't work
07:06:49 <jethr0> > sortBy (\(_,t,c) (_,t',c') -> compare (t,c') (t',c)) [("",2,1), ("",1,2), ("",1,1)]
07:06:50 <lambdabot> [("",1,2),("",1,1),("",2,1)]
07:07:28 * SamB wonders how to deal with bitfields in a binary format
07:07:49 <int-e> using sortby 2 times would work - if done in the correct order (secondary key first, primary key last). sortBy is a stable sort.
07:08:03 <jethr0> > sortBy (\(s,t,c) (s',t',c') -> compare (t,c',s) (t',c,s')) [("b",2,1), ("a",2,1), ("c",1,2), ("d",1,1)]
07:08:04 <lambdabot> [("c",1,2),("d",1,1),("a",2,1),("b",2,1)]
07:08:11 <int-e> sorting only once is more efficient though.
07:08:55 <oNoX> I need to change \(_,t,c) to \(_,(t,c))
07:09:00 <oNoX> and then it doesn't work
07:09:16 <int-e> then you need to change the (_,t',c') as well
07:09:17 <jethr0> oNoX: which part of the code i've been pasting for 10 minutes doesn't suit you?
07:09:49 <oNoX> no, I'll try to get rid of the internal ()
07:09:51 <oNoX> just wait a minute
07:11:57 <jethr0> bbl
07:15:11 <oNoX> I now have this:
07:15:17 <oNoX> transform :: [([Char],(Integer,Integer))] -> [Char,Integer,Integer]
07:15:46 <oNoX> do (k, (v, i)) <- s  ===> on third line: return ([k, i, v])
07:15:54 <oNoX> to remove the internal ()
07:16:02 <oNoX> but it complains about a , on the first line
07:17:42 <vincenz> plink plonk
07:22:21 <alar> if cabalised package doesn't want to install, what should I look at?
07:24:59 <oNoX> Yahoo!!!
07:25:01 <oNoX> it works :D
07:26:17 <oNoX> only in reversed order :P
07:26:57 <oNoX> it works :D
07:27:00 <oNoX> oops
07:28:17 <oNoX> int-e: I have now: \(_,t,c) (_,t',c') -> compare (t,c') (t',c)
07:28:30 <oNoX> that works, but the complete list is like upsidedown
07:28:41 <int-e> oNoX: to reverse the order just swap the two arguments of compare
07:28:49 <int-e> oNoX: i.e. do compare (t',c) (t,c')
07:29:42 <oNoX> yes
07:29:44 <oNoX> thanks
07:29:53 <oNoX> compare is really cool :)
07:30:15 <alar> maybe there is something with cabal in GHC-6.2?
07:30:27 <alar> e.g. it is not installed with GHC
07:30:39 <alar> or needs some manual adjustment
07:30:44 <alar> or sth. else
07:45:01 <marc_vw> hello
07:45:06 <marc_vw> long time no see
07:46:35 <eivuokko> @seen ndm
07:46:36 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 2 days, 17 hours, 47 minutes and 52 seconds ago, and .
07:46:45 <xerox> (;
07:47:04 <marc_vw> where can i learn about such commands?
07:47:11 <Cale> @list
07:47:11 <lambdabot> list [module|command]. Where modules is one of:
07:47:11 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
07:47:11 <lambdabot> version vixen where
07:47:19 <xerox> marc_vw - /QUERY lambdabot and play :)
07:47:35 <Cale> @version
07:47:35 <lambdabot> lambdabot 3p7, GHC 6.4.1 (Linux i686 3.20GHz)
07:47:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:47:53 <marc_vw> can i !gamble for more status? :-)
07:48:27 <marc_vw> but fun aside
07:48:45 <alar> @gamble
07:48:45 <lambdabot> Unknown command, try @list
07:48:51 <marc_vw> i got accepted for summer of code and want to thank anyone involved for their help!
07:49:47 <sjanssen_> is there blogging software for Haskell that generates static pages?  I can't run Haskell on my web host
07:49:56 <sjanssen_> marc_vw: congratulations!
07:49:58 <Cale> marc_vw: You're writing Language.C?
07:50:02 <marc_vw> yep
07:50:07 <Cale> cool
07:50:21 <xerox> http://www.flickr.com/photos/pete/sets/72057594143224765
07:50:22 <marc_vw> i hope i wont get more grey hair from it
07:50:24 <xerox> First 100$ laptop
07:50:55 <inv2004> hi all
07:51:17 <marc_vw> xerox: very cool 
07:51:26 <sjanssen_> xerox: those things that point up look like little horns.  Is this some kind of evil devil robot in disguise?
07:51:36 <marc_vw> wlan antennas?
07:51:41 <Cale> hehe, that's what I was just thinking
07:51:47 <inv2004> question: how is it possible to use multiple condition ? smth like match a with | c1 | c2 | c2 -> Ok | _ -> No ?
07:51:59 <xerox> I think they have to do with wifi too :)
07:52:01 <inv2004> in hugs/ghc
07:52:04 <marc_vw> you can add a paraplu as sattelite dish :-)
07:52:04 <Cale> inv2004: && or ||
07:52:05 <Igloo> inv2004: Only with guards
07:52:07 <sjanssen_> inv2004: use && between them
07:52:30 <inv2004> unexpected symbol "&&"
07:52:36 <inv2004> case s !! i of
07:52:36 <inv2004>     '1' && '2' -> Ok [(s !! i)] No
07:52:36 <inv2004>     _  -> No
07:52:50 <Cale> oh, you can't match multiple patterns
07:53:07 <inv2004> :(
07:53:12 <Cale> use let or where to define the common value
07:53:13 <inv2004> ok, thx
07:53:34 <Cale> (the reason is that in general, they might bind completely different variables
07:53:36 <Cale> )
07:53:37 <ihope> inv2004: that looks like you're trying to do something when s !! i is both '1' and '2' at the same time...
07:53:51 <inv2004> ihope, Y, I know
07:54:19 <marc_vw> xerox: it will certainly be useful, but i doubt we will see more fresh opensource programmers from the $100 laptop
07:54:25 <inv2004> so there'is not way to match multiple pattern
07:54:36 <ihope> Oh, I see... you're trying to do it when it's either '1' or '2'?
07:54:50 <marc_vw> xerox: i am still amazed why so many japanese freebsd users result in just a few developers
07:54:53 <inv2004> '1' or '2'
07:55:04 <ihope> Hmm...
07:55:15 <inv2004> smth like if c !! i _in ['1', '2'] then ...
07:55:16 <marc_vw> xerox: my guess that it will help those folks to get more prosperous, which is a legitimate goal
07:55:43 <inv2004> sry, just beban learning haskell, used ocaml and apl before
07:55:48 <inv2004> began
07:55:53 <marc_vw> paolo: how did you know about my mail with shae?
07:56:16 <Cale> > map (\c -> case c of x | x `elem` ['1','2'] = "ping?" | otherwise = "pong!") "132"
07:56:17 <lambdabot>  parse error on input `='
07:56:25 <inv2004> in ocaml I wrote match c[i] with '1' | '2' -> Ok | _ -> No
07:56:28 <Cale> > map (\c -> case c of x | x `elem` ['1','2'] -> "ping?" | otherwise -> "pong!") "132"
07:56:29 <lambdabot> ["ping?","pong!","ping?"]
07:56:50 <inv2004> ow, thx!
07:57:02 <ihope> Hmm. I think it would be "easy enough" to get that added to GHC.
07:57:24 <Cale> patterns are for structural matching, you can use guards for more complicated conditions
07:58:06 <inv2004> ok, thx
07:58:33 <Cale> inv2004: does  (x:y:xs) | (y:xs) just bind x to undefined when that pattern doesn't match?
08:00:30 <inv2004> where I can find description of `elem` ?
08:00:50 <inv2004> it's like _in at K language
08:00:53 <inv2004> apl
08:01:10 <ihope> x `elem` y is whether or not x is an element of y.
08:01:12 <ihope> !type elem
08:01:14 <ihope> @type elem
08:01:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:01:34 <inv2004> I know, thx
08:01:50 <inv2004> but can't find what is quoters: `elem`
08:01:55 <inv2004> ` and `
08:02:05 <inv2004> I use hugs
08:02:07 <Cale> Putting a function in `'s makes it infix.
08:02:08 <inv2004> :t elem
08:02:16 <ihope> x `elem` y = elem x y
08:02:35 <inv2004> ow, smth like (+) in ocaml, thx
08:02:39 <ihope> Likewise, (+) x y = x + y
08:02:52 <Cale> yeah, putting operators in parens makes them prefix too
08:03:08 <inv2004> elem
08:03:08 <inv2004> ^
08:03:08 <inv2004> parse error
08:03:22 <inv2004> but is works
08:03:33 <ihope> Wait... you just typed "elem" into Hugs and it gave you a parse error?
08:03:59 <inv2004> My fault, sry, typing elem in kx
08:04:07 <inv2004> now is ok
08:04:41 <inv2004> bb
08:06:08 <Bobstopper> I'm playing around with the idea of a String class. I figure the show and read functions need to be defined for anything suitable for a String class. Is it possible to make show and read methods of the String class while they're also methods of the Show and Read class or is this sort of multiple dispatch thing unsupported?
08:06:38 <ihope> Um...
08:06:41 <ihope> What?
08:07:38 <ihope> If you want to force read and show functions to be defined, then class (Read a, Show a) => String' a where ...
08:08:03 <ihope> That's assuming this read and this show are the same ones as the existing ones.
08:08:13 <sjanssen_> Bobstopper: you sound like you're thinking in OO terms -- Haskell typeclasses are quite different from OO
08:09:10 <Bobstopper> Yeah I know they are... I'm not really trying it in a OO-ish manner. I more just noticed a circular relationship in what I was trying to do and wanted to know if it's bogus.
08:09:43 <ihope> Well, do you want entirely new show and read functions, or do you want to use the old ones?
08:09:56 <Bobstopper> Basically, I'd like it to be possible to use show/read in a context where it returns a specific instance of a string
08:10:05 <Cale> Bobstopper: you can't make them members of the String class unless you want to import the prelude hiding them.
08:10:19 <Bobstopper> Cale: Yeah, that's no problem
08:10:26 <Cale> (There are no general union types in Haskell)
08:11:07 <xerox> (,) :: a -> a -> (a,a) isn't "general" ?
08:11:25 <Bobstopper> Ok so functions like (Foo a, Bar b) => a -> b are bogus?
08:11:38 <Cale> no, that's okay
08:11:42 <Cale> @type fromIntegral
08:11:43 <lambdabot> forall b a. (Num b, Integral a) => a -> b
08:12:06 <Bobstopper> I mean functions which make up the definition of both the Foo and Bar classes, sorry :)
08:12:25 <Cale> no, you can't do that
08:12:37 <Cale> You can do similar things with the separate classes.
08:13:08 <ihope> Well, you could probably have class Foo a b where bar :: a -> b
08:13:22 <Cale> you can also do things like require an instance of one class in order to be permitted to have an instance of the other
08:13:25 <Cale> so
08:13:40 <Cale> class (Show a, Read a) => Foo a where
08:13:47 <Cale>    ...extra stuff...
08:14:32 <Bobstopper> Yeah, class (Show a, Read a) => String a where is what I originally had... however instances of the String class are expected to be paramaterised over what encoding of character is being used so it didn't work.
08:14:51 <Cale> really?
08:14:55 <Cale> what happened?
08:14:59 <Bobstopper> Well, in my implementation, yeah.
08:15:33 <Bobstopper> it had a kind error. I was trying to define String as a class of kinds * -> * but Read and Show both made it want classes of kind *
08:15:33 <Cale> Oh, you need different Show and Read instances depending on the extra parameter?
08:15:39 <Bobstopper> Yeah
08:15:55 <marc_vw> what kind of soc project is haskellnet?
08:16:30 <Cale> marc_vw: a project to construct networking libraries
08:16:49 <Cale> the name really fails to convey that somehow
08:17:05 <marc_vw> my first was .net :-)
08:17:10 <marc_vw> my first thought was .net :-)
08:17:46 <marc_vw> however they have f++ or so as functional .net lang
08:18:16 <alar> f++? maybe f*** ?
08:18:46 <Cale> f#
08:19:01 <alar> F###
08:19:09 <Cale> Fb would be funnier
08:19:12 * Philippa has the urge to name an FPL F4 now
08:19:17 <Cale> (F-flat)
08:19:21 <Philippa> (see I18N)
08:31:10 <SamB> F4?
08:31:39 <int-e> F
08:32:10 <sjanssen_> F flat?
08:32:16 <sjanssen_> just call it E
08:32:59 <sjanssen_> if anybody asks, you just say it stands for enharmonic
08:33:37 <SamB> hmm, so, F### is what, G#?
08:34:22 <sjanssen_> hmm, I've never seen a triple sharp in music, is there a symbol for it?
08:34:34 <Cale> Involve quarter tones :)
08:34:40 <sjanssen_> if I were to make a new version of F#, I'd call it Fx
08:34:49 <__phas> Hi, did someone received responses for soc?
08:34:56 <norpan> Bobstopper: why is it so important to have that hierarchy?
08:35:02 <Cale> F-(3/2 sharp)
08:35:17 <Cale> hehe F-augmented
08:35:35 <norpan> Bobstopper: will any of the default implementations in the String class use show or read?
08:35:35 <jethr0> it depends whether you are on a well-tempered scale or a pure one
08:36:18 <Cale> R-demolished
08:36:34 * alar imagines slogan: "F-augmented programming language - with it programming involves more F!"
08:37:27 <alar> we put the fu*k in funktion
08:37:28 <Bobstopper> norpan: the idea was that somebody could, say, show data and when that shown data is used in a context which expects [Char] it works as expected or where it's used in a context which uses ByteString it also works as expected...
08:37:42 <jethr0> http://de.wikipedia.org/wiki/Unterst%C3%BCtzte_Sprachen_und_Compiler_(.NET)
08:37:56 <jethr0> it's amazing. there's even a .net port for brainf*ck :)(
08:37:56 <norpan> Bobstopper: but that's just a matter of making ByteString an instance of Show
08:38:13 <norpan> doesn't involve your String class at all
08:38:53 <norpan> Bobstopper: is your attempt anything like this: http://norpan.org/~martin/StringClass.hs
08:39:23 <Bobstopper> Well, it does, because I don't want it to be a case of using (a -> ByteString) and then show the result, I'd like it to be a case of just using show on the a like I can with [Char].
08:39:35 <marc_vw> There is indeed an Haskell.net on the .net wikipedia list
08:40:16 <norpan> Bobstopper: i don't understand
08:40:36 <Bobstopper> Kinda like that, yeah
08:40:39 <norpan> just make anything you make an instance of String also be an instance of Show
08:40:44 <sjanssen_> norpan: I believe Bobstopper wants show :: (String s, Read a) => a -> s
08:40:53 <Bobstopper> Yeah
08:41:14 <Bobstopper> Though more like show :: (String s, Read a) => a -> s c
08:41:34 <sjanssen_> Bobstopper: phantom type encoding trick?
08:42:36 <Bobstopper> LoL :) what do you mean by that? It seems to me that the character encoding being wrapped up by a string is an important parameter of a string, no?
08:42:37 <norpan> how can Read a help showing it?
08:42:59 <Bobstopper> Sorry, show :: (Show a, String s) => a -> s c
08:43:03 <sjanssen_> norpan: sorry, typo -- should be Show
08:43:43 <norpan> ah, you want show more generic THAT way
08:43:47 <sjanssen_> Bobstopper: perhaps, there are other approaches to the encoding problem
08:44:09 <Bobstopper> can you point me toward some of the other approaches?
08:44:14 <norpan> well it's hard to hide instances
08:44:40 <sjanssen_> Bobstopper: well, the other way is to just write a new datatype for each encoding
08:44:48 <sjanssen_> not sure which is better though
08:45:22 <norpan> i suppose you'll have to find another name for it
08:45:43 <Bobstopper> So for example ByteString, 16BitUnicodeString, 32BitUnicodeString etc?
08:45:49 <sjanssen_> Bobstopper: you'll need an Encoding type class, or turn String into a mult-parameter type class
08:46:10 <sjanssen_> Bobstopper: yeah
08:47:32 <norpan> having the class in http://norpan.org/~martin/StringClass.hs you'd just define sshow = pack . show
08:47:56 <Bobstopper> Yeah, my problem with the multiple datatype solution is that people then end up choosing which encoding to use for their library and it sort of locks the library user into performing manual transfers between different string/encoding types. It seems to me this kind of problem is best handled by context such as typeclasses allow... hence my playing around with it.
08:48:48 <sjanssen_> Bobstopper: you can still have a generic string typeclass without an encoding parameter
08:49:03 <sjanssen_> in fact, not including the parameter is more general than including it
08:49:10 <eivuokko> It might also be usefull to have driver-type solution, ie simple manual dictionary passing.  It's not always convient to parametrise types.
08:49:23 <Bobstopper> norpan: Yeah, I've been playing with that idea too.
08:50:51 <Bobstopper> sjanssen_: Yeah, I guess. I'll have a play with the idea of doing without the parameter and see if it's more useful.
08:50:57 <Bobstopper> Thanks for your help all
08:59:14 <dozer> still got dependency problems
08:59:24 <dozer> how do I go about diagnosing the problem?
09:00:21 <Cale> dozer: module dependencies?
09:00:41 <Cale> dozer: on your own project or someone else's?
09:00:41 <dozer> Cale: yeah
09:01:08 <dozer> Cale: mine is apparently importing two versions of HTTP2006
09:01:14 <dozer> indirectly I assume
09:01:16 <Cale> oh
09:01:29 <Cale> so it's a cabal issue?
09:01:48 <dozer> I guess
09:01:57 <dozer> I've patched the http lib to deal with proxies
09:02:01 <Cale> okay
09:02:17 <dozer> but haven't tracked down all the modules that are using it I guess to rebuild them against my patched version
09:02:22 <Cale> yeah, probably
09:02:47 <dozer> this is one of the things I like about Maven2 - the dependency tracking and multi-module builds works well
09:04:03 <dozer> so is there a command that lets me take a cabal and get the dependency tree out, with the modules and versions it is sucking in?
09:05:10 <Cale> I don't know all that much about cabal apart from using it to install software from time to time
09:05:26 <__phas> There's a list of the soc application for haskell.org?
09:05:48 <Cale> I don't think it's necessarily well-defined which versions of things a .cabal file is referring to.
09:07:16 <dozer> Cale: it seems to default to "newest at link time"
09:07:25 <dozer> unless you specify the version manually
09:07:31 <Cale> right
09:07:45 <dozer> comming from Java, I'm used to run-time bindings :)
09:08:14 <Cale> On most platforms we don't have dynamic linking yet.
09:08:17 <dozer> so I guess what I need is a tool that takes a module name, and for the newest (or a numbered version) lists what dependencies it was linked against
09:08:44 <Cale> I think OS X is the only platform which can generate dynamically linked Haskell libraries as of yet.
09:08:49 <dozer> ok
09:09:17 <dozer> presumably though, the performance potentially sucks big-time if you usually rely on x-module optimizations
09:10:16 <Cale> well, not that much cross-module optimisation is done at the moment either (as far as I know) -- I think it's more just that up until recently there wasn't too much demand for it.
09:10:59 <dozer> ok
09:11:28 <Cale> (that is, dynamic linking)
09:11:53 <dozer> I'm also used to dynamic binding but that's a discussion for another day
09:12:33 <Cale> It's something to be worked out. I bet there are some people working on it.
09:13:00 <dcoutts> Cale, are you talking about ghc & cross-module optimisation? because ghc does lots of it.
09:13:23 <Cale> dcoutts: it does? It sure looks like it compiles things separately.
09:13:55 <Cale> It's doing optimisations at link time?
09:14:03 <Igloo> It does. There are inlining whatsits in .hi files
09:14:10 <Cale> ah, okay
09:14:12 <dcoutts> Cale, that's true, but it emits masses of stuff into the .hi files when using -O and that allows it to inline things across modules
09:14:29 <dcoutts> Cale, and RULES apply across modules too
09:14:31 <Igloo> You could inline even when using DLLs, though. I don't know whether or not it's done.
09:14:41 <Cale> dcoutts: right, good point
09:14:53 <Cale> Igloo: yeah, that would be interesting
09:15:30 <Igloo> It does mean you can't tough the DLL code without bumping the SO, or equivalent, though
09:15:36 <Igloo> s/tough/touch/
09:15:52 <peteog> Hi all, I have a quick question. I have a two types Weekday and Weekend, and a list of type Anyday which is Either Weekday or Weekend. I want to write a function to count the number of weekdays in a list of type [Anyday], is there a way to use the filter function on a particular type?
09:16:15 <Cale> you could use filter
09:16:20 <norpan> there are several ways
09:16:30 <Cale> but I'd probably use either and sum
09:16:42 <Cale> @type either
09:16:43 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
09:16:45 <peteog> filter (==) Weekday [list]
09:17:05 <norpan> isWeekday (Left _) = True; isWeekday _ = False; length . filter isWeekday
09:17:22 * shapr throws lambdas
09:17:46 <peteog> norpan: perfect :)
09:17:54 <peteog> thanks :)
09:18:16 <Cale> filter (either (const True) (const False)) list
09:18:19 <Cale> or
09:18:30 <Cale> sum . filter (either (const 1) (const 0)) list
09:18:35 <Cale> er
09:18:39 <Cale> sum . map (either (const 1) (const 0)) list
09:18:44 <Cale> rather
09:18:45 <jethr0> @hoogle isLeft
09:18:46 <lambdabot> No matches found
09:18:46 <marc_vw> shapr
09:19:03 <marc_vw> thanks for your support
09:19:23 <shapr> hi marc_vw!
09:19:30 <shapr> Nice to see you on #haskell :-)
09:19:57 <marc_vw> paolo dragged me here
09:20:36 <xerox> :)
09:21:15 <shapr> #haskell is a good way to keep up communication. It's also a good way to be distracted from work :-)
09:21:29 <norpan> shapr: word
09:21:36 <marc_vw> that is true
09:21:53 <shapr> My solution was to turn off traffic notification for #haskell and #haskell-blah in my irc client.
09:22:14 <xerox> Training is enough :)
09:22:18 <shapr> true
09:22:31 <xerox> But difficult, I agree.
09:23:33 <dcoutts> xerox, so how's your SoC project going so far? ;-)
09:23:52 <dcoutts> I mean you've had several hours already!
09:23:57 * shapr laughs
09:24:29 <neologism> xerox: what SoC do ytou do?
09:24:38 <marc_vw> i stopped using irc for about two years
09:24:38 <marc_vw> i was lurked in back lately because i got hooked on a manga series where i found out that fans subbed it 
09:24:43 <xerox> shapr - I didn't mean to be rude, I tried that too!
09:24:52 * xerox pokes dcoutts 
09:25:09 <shapr> No worries, I assume people don't mean to be rude. I think someone has to try hard to offend me.
09:25:27 <marc_vw> i underestimated the number of applications
09:25:29 * xerox offers lambda-cookie
09:25:39 <marc_vw> never thought so many people would apply for soc
09:25:44 <xerox> neologism: thin out cabal-get
09:25:46 <shapr> I thought we'd get maybe thirty.
09:25:48 <alar> shapr: have you dropped #eigram?
09:25:53 <shapr> alar: No, but I can if you want it.
09:25:55 <alar> #epigram
09:26:00 <marc_vw> but the increased number of orgs should have warned me
09:26:05 <alar> I never see you there 
09:26:07 <shapr> I just haven't had time to get back to dependently typed languages.
09:26:19 <alar> oh, ok
09:26:25 <shapr> alar: Life is getting in my way.
09:26:31 <Igloo> xerox: "thin out"? You mean you're getting paid to just delete other people's hard work?  :-)
09:26:40 <xerox> Igloo: exactly! :)
09:26:55 <norpan> that's what i do too
09:26:59 <norpan> thin out
09:27:13 <dcoutts> g'afternoon SyntaxNinja 
09:27:16 <xerox> Another way to say that is thinking out a good way to make cabal-get bundle-able with Cabal, thus with GHC.
09:27:18 <marc_vw> shapr: didn't you write me that i can build on previous work too?
09:27:23 <shapr> Sure, yeah.
09:27:25 * xerox hops up and down
09:27:25 <xerox> +
09:27:30 <xerox> SyntaxNinja!
09:27:34 <shapr> hiya SyntaxNinja!
09:27:56 <SyntaxNinja> hey xerox, dcoutts, shapr.  You guys are the creme de la creme.
09:28:04 * shapr is all creamy!
09:28:04 <xerox> You rock too!
09:28:21 * dcoutts grins
09:28:31 <shapr> So what's the final word on SoC? Is everything cleared up now?
09:28:45 <xerox> There was something unclear?
09:28:46 <marc_vw> in what aspect?
09:29:04 <marc_vw> the 1800 mails?
09:29:12 <marc_vw> driving poor students nuts
09:29:13 <neologism> shapr: yes.. everyone knows if he was accepted or rejected
09:29:15 <shapr> Yeah, some students applied for multiple mentoring orgs, what happened there?
09:29:21 <xerox> Ah, I was wondering, why one project was about HSP and nothing about HAppS?  We didn't get HAppS worthy proposals?
09:29:24 <dcoutts> xerox, we got told on the admin list but it's not on the Google SoC website yet
09:29:27 <shapr> Did any of our applicants collide with others?
09:29:34 <dcoutts> shapr, nope
09:29:39 <shapr> Ah, good to hear.
09:29:55 <shapr> Next question, what's involved in being a mentor again? ;-)
09:30:03 <dcoutts> heh
09:30:15 <marc_vw> ZOMG
09:30:20 * shapr grins
09:30:21 * dcoutts doesn't have to do any mentoring this year ;-)
09:30:31 <xerox> dcoutts: you think so!
09:30:34 * xerox grins evilly
09:30:36 <shapr> I'm glad I got HaskellNet, it's such a cool project!
09:30:48 <marc_vw> the name is misleading
09:30:53 <dcoutts> xerox, oh you mean I get to interfeare with lots of projects? :-)
09:30:58 <marc_vw> i thought it was haskell.net
09:31:05 <dcoutts> marc_vw, hah, no.
09:31:06 <shapr> Well, whatever...
09:31:10 <davidhouse> shapr, what is it?
09:31:13 <norpan> it's not HaskellNet that is misleading, it's .net that it
09:31:14 <norpan> is
09:31:34 <marc_vw> good people will know the difference
09:31:39 <xerox> dcoutts: I can't count on my hands' fingers how many things you code or/and manintain :)
09:31:46 <Cale> On Amazon.ca:
09:31:53 <Cale> Our Price: CDN$ 79.54
09:31:53 <Cale> Used from CDN$ 1,419.57
09:31:54 <dcoutts> xerox, yeah, me neither!
09:31:55 <shapr> davidhouse: It's a project to create, collect, test, and package networking libs for Haskell.
09:32:05 <Cale> what the heck?
09:32:07 <davidhouse> Cale, hah :)
09:32:15 <SyntaxNinja> man. it's so fun waking up and reading all of the stuff going on w/ the haskell community while I sleep :)
09:32:18 <davidhouse> shapr, great!
09:32:19 <shapr> Cale: You should see Hamming's "Learning To Learn" prices.
09:32:22 <xerox> Cale: is their b0rked? :)
09:33:04 <Cale> I saw something like that on another book, where it sold for ~$10, but someone was trying to sell it for ~$90
09:33:50 <marc_vw> i sit on probably all books of our university library which will help me with soc :-)
09:34:16 <__phas> Someone could post the ranking of the rejected applications for the soc?
09:35:48 <dcoutts> marc_vw, are you Marc Ernst Eddy van Woerkom ?
09:35:51 <magnus> !pastebot
09:35:54 <xerox> Oh, they published an official banner? <http://code.google.com/images/bnr_soc_125x58.gif>
09:35:56 <marc_vw> yep
09:36:04 <marc_vw> i should have dropped the middle names
09:36:13 <dcoutts> marc_vw, ah! so you're doing Language.C with Manuel
09:36:30 <marc_vw> i am very glad to do so
09:36:36 <marc_vw> i had two c related proposals 
09:36:42 <marc_vw> and two fp related ones
09:36:56 <dcoutts> marc_vw, I'm one of Manuel's c2hs helpers so I expect we'll be having many discussions :-)
09:37:06 <xerox> He's *everywhere*
09:37:08 <dcoutts> marc_vw, I wrote the current c2hs C parser.
09:37:09 <marc_vw> i need to study what is available
09:37:46 <xerox> dcoutts: wasn't I right before? (:
09:38:04 <dcoutts> xerox, yes, I have my fingers in too many pies. :-)
09:38:16 <xerox> Cute :)
09:38:39 <dcoutts> it's a slightly odd english expression
09:38:42 <marc_vw> are you in my timezone?
09:38:48 <dcoutts> marc_vw, yes.
09:38:51 <xerox> @localtime marc_vw 
09:38:53 <lambdabot> Local time for marc_vw is 05/24/06 18:42:56
09:38:56 <marc_vw> manuel seems to be my antipode
09:39:00 * dcoutts is in .uk
09:39:13 <marc_vw> this might help communicatin
09:39:16 <dcoutts> marc_vw, not at the moment, he's in the US I think.
09:39:28 <marc_vw> he wrote a german haskell book
09:39:35 <dcoutts> marc_vw, I just got a bunch of c2hs emails from him.
09:39:37 <marc_vw> quite busy as well
09:39:39 <nhc98> manuel is in Oz usually
09:39:52 <dcoutts> marc_vw, you're subscribed to the c2hs list I presume?
09:39:57 <marc_vw> not yet
09:40:05 * dcoutts reccomends you do so
09:40:14 <marc_vw> any other recommendations?
09:40:31 <xerox> Gobby (:
09:40:36 <dcoutts> hah
09:40:37 <shapr> The Pragmatic Programmer & SICP
09:40:44 <dcoutts> marc_vw, figure out what the existing C parsers are
09:40:53 <shapr> Yeah, check out Knit
09:40:54 <dcoutts> marc_vw, I'm only familiar with the c2hs one.
09:40:58 <marc_vw> that should be easy
09:41:03 <shapr> @google knit reid haskell
09:41:05 <lambdabot> http://citeseer.ist.psu.edu/cis?q=Alastair+Reid
09:41:08 <hyrax42> accepted list is out?
09:41:14 <dcoutts> hyrax42, yep
09:41:32 <dcoutts> marc_vw, have you used happy or yacc before?
09:41:37 <marc_vw> yacc
09:41:38 <hyrax42> where at
09:41:46 <xerox> I think we should adjust the trac homepage if we are going to use the tract henceforth.
09:41:50 <dcoutts> marc_vw, happy is very similar but for Haskell of course
09:41:52 <xerox> trac, even.
09:42:01 <dcoutts> xerox, good idea
09:42:07 <marc_vw> i usually end up writing my parser by hand
09:42:17 <hyrax42> just make sure to keep the old proposals for next tiemaround
09:43:10 <hyrax42> I can't find the list of projects
09:43:22 <marc_vw> did you use happy for c2hs?
09:43:39 <xerox> hyrax42: click on "project list" from the topic's url.
09:43:43 <nhc98> hyrax42: they were posted to the haskell mailing list, but not up on the google site yet
09:43:48 <dcoutts> marc_vw, yes, I used happy.
09:44:02 <xerox> Err, "project ideas"
09:44:02 <lisppaste2> magnus pasted "Bugprone primes" at http://paste.lisp.org/display/20377
09:44:13 <dcoutts> marc_vw, I changed it from a hand written combinator parser that performed terribly.
09:44:30 <marc_vw> i am agnostic
09:44:35 <magnus> Those interested in helping with a semi-newbie questions, please check my paste :)
09:44:48 <dcoutts> marc_vw, it had huge space leaks which made it very slow. The current happy parser is fast but has a couple problems.
09:44:49 <hyrax42> xerox: all of the ones listed were accepted?
09:45:05 <xerox> hyrax42: nope, check here: <http://www.haskell.org/pipermail/haskell/2006-May/017999.html>
09:45:23 <dcoutts> marc_vw, the most tricky thing about parsing C is the typedef'ed identifier issue.
09:45:34 <xerox> sjanssen_: you're going to do Data.Rope as part of your project, nice one!
09:45:37 <marc_vw> i think so
09:45:45 <magnus> I am basically wondering if there's a way to do non-recursive, shadowing let..in...
09:45:46 <marc_vw> that why they are not recommended
09:45:49 <jethr0_> magnus: you can shadow let-bindings inside monads
09:46:02 <hyrax42> cool
09:46:06 <xerox> magnus: may you be more precise?
09:46:08 <dcoutts> marc_vw, not recommended?
09:46:12 <hyrax42> congrats to all
09:46:15 <marc_vw> to use typedefs
09:46:16 <magnus> xerox: did you check the paste?
09:46:17 <xerox> hyrax42: thanks much.
09:46:21 <xerox> magnus: woops.
09:46:38 <nhc98> magnus: you could try using case instead of let
09:46:43 <magnus> jethr0_: Yes, in the paste I have an attempt at that, but not working
09:46:49 <dcoutts> sjanssen_, ah! so that's why you've been hacking on the ByteString stuff!
09:46:56 * dcoutts slaps his forehead
09:47:12 <magnus> nhc98: I'll try, kinda clumsy but it might save bugs :)
09:47:22 <dcoutts> I've not been connecting the names to people
09:47:24 <jethr0_> > fromJust $ do {let {x = 4}; let {x = 3}; return x}
09:47:25 <lambdabot> 3
09:48:08 <ski> magnus : maybe use a state monad ?
09:48:14 <kosmikus> magnus: the runIdentity should work if you prepend the two "find" calls with "return $"
09:48:39 <lisppaste2> nhc98 annotated #20377 with "case instead of let" at http://paste.lisp.org/display/20377#1
09:48:49 <magnus> kosmikus: Ah, thanks!
09:49:06 <magnus> ski: I like keeping my code outside the state monad when I can
09:49:12 <dcoutts> sjanssen_, so are you interested in this list/array fusion stuff? what are your project goals exactly?
09:49:28 <magnus> ski: the state monad is too heavywheight for me
09:49:48 <marc_vw> dcoutts: freebsd's style(9) for kernel code has a passage on why to avoid typedefs - that is what i referred to
09:49:55 <kosmikus> magnus: still a bug in your annotation, because you didn't remove all the ''s ...
09:50:04 <dcoutts> marc_vw, ah
09:50:31 <dcoutts> marc_vw, it means that C's grammar is not LALR, it has a 'context dependency'
09:50:36 <kosmikus> magnus: but using a state monad would look the most concise, I think
09:50:39 <magnus> kosmikus: you are right. I'll fix that
09:50:46 <nhc98> kosmikus: oops, yes I missed one '
09:51:01 <RyanT5000> google still has not posted its soc stuff >:-/
09:51:07 <jethr0_> > runIdentity $ do {let {x = 3}; let {x = 4}; return x}
09:51:07 <lambdabot>  Not in scope: `runIdentity'
09:51:12 <dcoutts> marc_vw, it typically requires some communication between the lexer layer and the parser layer.
09:51:12 <marc_vw> ah i thought c was ll(k), and c++ had context sensitivity
09:51:12 <kosmikus> nhc98: oh, I didn't realize the annotation was by you ...
09:51:31 <shapr> nhc98: hiya!
09:51:34 <nhc98> kosmikus: I see magnus missed a ' in his annotation too
09:51:39 * kosmikus is going home ...
09:51:43 * shapr is going to work!
09:52:00 <dcoutts> marc_vw, because wether an ident is treated as a type or normal depends on stuff parsed earlier and wether an ident is a type or normal affects how we parse!
09:52:02 <jethr0_> nhc98: that's probably why he said it was bugprone :)
09:52:03 * nhc98 is going red
09:52:18 <magnus> :) exactly jethr0_
09:52:28 <shapr> Has anyone tried Adobe PDFs from ebooks.com ? I just discovered they have Hamming's "Art of doing Science and Engineering" for $32!
09:52:32 <dcoutts> sjanssen_, I've been hacking on getting fusion working for the lazy bytestrings. It seems to be working.
09:52:54 <shapr> But they seem to include some sort of DRM, only allowing you to copy 10 pages a day... any clue if that'll work with xpdf?
09:53:01 <marc_vw> dcoutts, do you think a complicated generator setting is still better than handcoding?
09:53:48 * nhc98 has been playing with hylo fusion recently
09:53:52 <RyanT5000> shapr: there was that russian dude who broke the adobe ebook encryption, and then got arrested on a visit to the US; i think you want his software (i'd guess it's pretty easy to find)
09:53:57 <dcoutts> marc_vw, well it makes it easier to match up to a formal grammar spec, and it tells you when the grammar is amgiguous
09:53:58 <Stinger_> shapr "fat chance" would be my guess
09:54:18 <RyanT5000> it's perfectly legal in russia, afaik
09:54:22 <shapr> Yeah, Dmitry Skylarov... iirc Adobe encryption involved lots of XOR
09:54:30 <RyanT5000> lol yeah :)
09:54:39 <mahogny> that case was silly
09:54:45 <mahogny> 'lo RyanT5000 
09:54:46 <marc_vw> dcoutts, i hope there is a usefull grammar avialable
09:54:53 <dcoutts> marc_vw, gcc uses yacc
09:55:08 <marc_vw> dcoutts, i only know of the g++ problems with yacc
09:55:08 <dcoutts> marc_vw, and there is the official C spec
09:55:11 <davidhouse> is an apostrophe still a valid identifier in, say a constructor name?
09:55:12 <dozer> wasn't the source entered into public record in that case - it was part of the evidence - and it didn't get sealed?
09:55:23 <dcoutts> marc_vw, it's not quite so bad for C, compared to C++
09:55:32 <RyanT5000> i put DMCA in thhe category of laws you should go out of your way to break
09:55:39 <dcoutts> marc_vw, but I think that for gcc-4 they've moved to a non-yacc based parser
09:55:52 <RyanT5000> just so that maybe you'll get to challenge it at the supreme court level
09:55:53 <nhc98> davidhouse: yes: Cons'tructor
09:55:54 <marc_vw> dcoutts, i thought they did it long ago
09:56:00 <davidhouse> thanks, nhc98/
09:56:04 <RyanT5000> (<-- going to law school in the fall)
09:56:07 <dcoutts> marc_vw, so the last yacc grammar that specifies all the GNU C extensions is probably gcc-3.4.x
09:56:16 <jethr0> shapr: there's nothing inherently unsafe about xor. it all depends what you xor with :)
09:56:27 <RyanT5000> jethr0: very true ;)
09:56:32 <marc_vw> dcoutts, the goal is to handle real world c codebases, or?
09:56:36 <dcoutts> marc_vw, the official C spec is fine. Allmost all the problems are with GNU C extensions.
09:56:58 <dcoutts> marc_vw, real world C, meaning GNU C.
09:57:15 <nhc98> dcoutts: a bit like the situation with official haskell vs ghc extension :-)
09:57:23 <mahogny> which gnu extensions are problematic?
09:57:23 <marc_vw> dcoutts, my hope was to start with the c99 spec and then try to put some real world code bases through it
09:57:43 <RyanT5000> actually, i heard about some person who suggested that you use a one-time-pad which is a stellar source: both people have (e.g.) a radio telescope, and send each other the coordinates to look at
09:57:45 <dcoutts> nhc98, I think it's worse since the GNU C extensions are not formally specified anywhere
09:57:49 <jethr0> problem with evolved languages like C is that they are not lalr(1) or even lr(1) any more afaik. that makes a structured parsing approach a lot harder
09:58:04 <dcoutts> marc_vw, yes that'd be a good place to start.
09:58:13 <jethr0> RyanT5000: synchronisation and atmospheric filtering might be a problem
09:58:22 <RyanT5000> jethr0: yeah, that's true
09:58:27 <dcoutts> marc_vw, I sort-of did that with the c2hs C parser, then added more GNU stuff
09:58:31 <mahogny> jethr0, depends on what you measure
09:58:37 <jethr0> and of course key exchange. you can take pi starting from some digit too (assuming it's suff. random).
09:58:37 <marc_vw> dcoutts, phk (of freebsd.org) gave me the tip to have the llc book read
09:58:57 <dcoutts> marc_vw, probably a good idea
09:58:59 <jethr0> which, of course, it is not :)
09:59:06 <marc_vw> dcoutts, its statement is supposed to be: if a pdp 11 can parse c than it can't be that hard
09:59:10 <RyanT5000> jethr0: a star is better than pi, because anyone can reproduce pi, but theoretically you can't record the entire sky
09:59:17 <RyanT5000> (in the kind of detail we're talking about here)
09:59:34 <xerox> Updated! <http://hackage.haskell.org/trac/summer-of-code/>
09:59:37 <dcoutts> marc_vw, there is only one remaining problem with the c2hs C parser which is in a subtle case of typedef'ed vs ordinary identifiers
09:59:50 <jethr0> RyanT5000: well, first you have to assume/prove that the star is a source of "good" randomicity. that's not a given for physical processes
09:59:52 <sjanssen_> dcoutts: I find the fusion stuff interesting, but it isn't part of my proposal -- mostly because I don't really understand it ;-)
10:00:07 <jethr0> for example a pulsar will emit a very regular signal imo
10:00:17 <dcoutts> marc_vw, I couldn't get a parser with no shift/reduce conflicts when trying to follow the C99 spec fully.
10:00:24 <pitecus> How do I get rid of that: *** Exception: Prelude.^: negative exponent
10:00:38 <davidhouse> pitecus: use **
10:00:39 <dcoutts> marc_vw, check the c2hs archives for details, or we can talk about it some time.
10:00:40 <RyanT5000> not a pulsar
10:00:42 <jethr0> > 5 ^^ (-2)
10:00:43 <lambdabot> 4.0e-2
10:00:48 <davidhouse> oh.
10:00:50 <davidhouse> hmm.
10:00:51 <dcoutts> sjanssen_, yeah, I only just started looking at that.
10:00:52 <RyanT5000> you'd want to get background radiation from a very specific angle
10:00:54 <davidhouse> > 5 ** -2
10:00:55 <lambdabot>   precedence parsing error
10:00:55 <lambdabot>    cannot mix `(**)' [infixr 8] and prefix `-' [infixl 6] in the same infix expression
10:00:59 <davidhouse> > 5 ** (-2)
10:01:00 <lambdabot> 4.0e-2
10:01:01 <RyanT5000> the noise issue can be solved, probably, by some combination of filtering the random data and using ECC on the message
10:01:07 <davidhouse> wait.
10:01:14 <marc_vw> dcouts, that is what i suspected, i believe those spec/book grammars are more for human consumption than for putting it into a parser code
10:01:14 <davidhouse> > (-5) ^ 2
10:01:15 <lambdabot> 25
10:01:16 <dcoutts> sjanssen_, do you want me to try and explain it?
10:01:20 <davidhouse> huh. dunno.
10:01:35 <pitecus> Too many operators for my overheated brain
10:01:48 <dcoutts> sjanssen_, if so we should move to #haskell-overflow
10:02:06 <sjanssen_> dcoutts: I need to leave in a few minutes, but I will take you up on that offer soon
10:02:11 <dcoutts> sjanssen_, ok
10:02:40 <RyanT5000> i like the way that ti calculators have a separate unary and binary -
10:02:53 <RyanT5000> (they're actually different buttons and different characters)
10:02:59 <mahogny> isn't that common?
10:03:06 * mahogny wants a calculator with matlab
10:03:15 <RyanT5000> for calculators? yes; for programming languages? doesn't seem to be
10:03:25 <RyanT5000> (i'm referring to TI Basic here)
10:03:50 <RyanT5000> * mahogny wants a very tiny computer :P
10:03:59 <mahogny> yup :)
10:04:22 <mahogny> mathematica on a palm top with character recognition would own
10:04:30 <RyanT5000> yeah
10:04:57 <RyanT5000> according to xerox's post, my soc project didn't get accepted :(
10:05:04 <mahogny> yeah, saw it
10:05:12 <jethr0> with my writing style no imaginable OCR could make out the formulas i write down
10:05:21 <mahogny> RyanT5000, still want to give it a shot though?
10:05:27 <RyanT5000> yeah
10:05:38 <RyanT5000> i probably won't even change it that much
10:05:50 <mahogny> I've been sketching on the resource system a bit
10:06:02 <mahogny> one can actually simplify it a tad bit
10:06:11 <mahogny> depending on the notion of a cache manager
10:06:21 <RyanT5000> i agree; i'll be interested to see what you simplified
10:06:32 <RyanT5000> i managed to get rid of resource IDs, e.g.
10:06:57 <mahogny> essentially - remove cache managers entirelly. turn it into a resource manager
10:07:21 <psi> is there any way of knowing how close you were of being accepted? silly perhaps, but I kinda want to know.
10:07:35 <RyanT5000> yeah right now i think i only have three primary classes
10:07:40 <RyanT5000> Manager, Node,  and Transition
10:07:54 <RyanT5000> the Manager holds all the (dynamically typed) Nodes and Transitions
10:08:14 <mahogny> RyanT5000, though I think a proper specification is needed to decide what kind of ID-system is wanted. it affects a lot
10:08:32 <RyanT5000> mahogny: i think IDs can just be considered to be handles in a particular node
10:08:37 <mahogny> hm. dynamic types; I don't have that
10:08:40 <mahogny> yes
10:08:42 <RyanT5000> e.g.: have a node for "unopened files"
10:08:47 <RyanT5000> the handles of which are strings
10:08:52 <RyanT5000> then have a node for opened files
10:08:56 <RyanT5000> the handles of which are file handles
10:09:24 <RyanT5000> my spec for Node doesn't specify the creation function, only the deletion function
10:09:44 <mahogny> however, there are some problems with that; the system easily becomes white boxed with local IDs like that unless one takes care
10:10:06 <RyanT5000> yeah, well you only expose some of the nodes
10:10:41 <RyanT5000> e.g.: unopened files, video card, sound card
10:10:55 <mahogny> for a while I considered toasting IDs and do it semi-SQL style. it has some advantages
10:11:05 <RyanT5000> toasting?
10:11:11 <mahogny> =removing
10:11:13 <RyanT5000> ah
10:11:38 <RyanT5000> so run it like an RDBMS?
10:11:45 <mahogny> the major advantage is that you no longer have to bother about anything than the filename it comes from, at most (but in some cases, not even that)
10:12:01 <mahogny> kind of. your "id" is filename concatenated with how it was loaded etc
10:12:11 <mahogny> but it is up to the modules to decide what to concatenate
10:12:17 <RyanT5000> hm
10:13:10 <mahogny> if you want to load a texture, you can send it a filename which it passes to the fileloader etc. you use the type system more efficiently
10:13:46 <RyanT5000> yeah but i don't see how to get away from dynamic typing
10:13:57 <mahogny> where do you want it?
10:14:07 <mahogny> rather, where do you need it?
10:14:08 <RyanT5000> the manager needs to store a graph of all the transitions and nodes
10:14:19 <RyanT5000> each of which is typed differently
10:14:19 <mahogny> nah. that disappears from what I have seen
10:14:29 <RyanT5000> then how do you find a path to a particular node?
10:14:48 <mahogny> when you initiate a node, you tell it where it can get data
10:15:18 <RyanT5000> oh so you're saying eliminate the manager, and just have nodes?
10:15:49 <mahogny> yes. if you want caching somewhere, then just put it in between where you see it fit
10:16:37 <RyanT5000> yeah, but how do you implement caching policies? like, for instance, precaching
10:17:44 <RyanT5000> or what about if there are multiple routes from the file to the video card?
10:18:00 <RyanT5000> shouldn't it, at least theoretically, have the capability to choose the cheapest one?
10:18:07 <mahogny> make sure that some functions exist for all objects. for example, you might have to use get/unget before using a resource
10:18:26 <mahogny> I think one has to study real life cases in all detail to know what to do there
10:18:30 * mux hearts Distribution.Simple
10:19:10 <RyanT5000> hm, maybe you can put the manager inside the nodes rather than the nodes inside the manager
10:19:30 <mahogny> yes, I considered that; a "factory" for generating cache nodes
10:19:48 <mahogny> I can see some fuzz about the types, but it isn't impossible
10:20:05 <RyanT5000> yeah, but i think you can completely avoid dynamic typing that way
10:20:08 <SamB> that sounds wierd
10:20:17 <davidhouse> hmm... here's a crazy idea.
10:20:21 <mahogny> SamB, never coded C++/java? :)
10:20:39 <SamB> remember to be able to get things out of the cache!
10:20:56 <mahogny> of course :)
10:21:18 <SamB> that is, remember that you eventually need to evict something
10:21:19 <davidhouse> i'm thinking about my extensible interpreter again. the problem is that of plugins: i want to be able to define new commands with plugins. these can be loaded at compiletime, that's no problem.
10:22:04 <davidhouse> now, what i was thinking is that i could write some TH to read a list of modules and pull a function from each.
10:22:06 <RyanT5000> mahogny: about formatting, i'm thinking maybe we should just eliminate it
10:22:18 <RyanT5000> i can't think of any real case where you'd want to dynamically reformat your objects
10:22:26 <davidhouse> (before compiling these functions into a list and sending it on to the non-metacode).
10:22:26 <RyanT5000> s/objects/resources/
10:22:35 <mahogny> RyanT5000, ugh. that's so uncommon that you might as well just reload it
10:22:44 <RyanT5000> also, i think "format handshaking" would be really, really difficult
10:22:46 <SamB> not really, no
10:23:32 <davidhouse> would that be a good application of TH?
10:23:43 <RyanT5000> if node A only supports formats x y and z, and node B only supports formats q r and y, getting them to agree on format y would be bitchy at best
10:23:52 <resiak> a
10:23:57 <mahogny> RyanT5000, yes. not worth the work
10:24:58 <RyanT5000> also, after a long talk with sjanssen, i think i'm going to use classes, existentials, and records, rather than just records
10:25:17 <mahogny> whatever helps :)
10:25:18 <RyanT5000> it doesn't add any code outside their own definitions, really
10:25:25 <RyanT5000> existential and record can both implement the class
10:25:37 <RyanT5000> that way you can have static typing/inlining most of the time
10:25:43 <RyanT5000> but if you need to use dynamic stuff, you can
10:25:44 <davidhouse> @hoogle String -> IO Bool
10:25:45 <lambdabot> System.Win32.Types.failUnlessSuccessOr :: ErrCode -> String -> IO ErrCode -> IO Bool
10:25:54 <davidhouse> @hoogle FilePath -> IO Bool
10:25:54 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
10:25:54 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
10:27:04 <RyanT5000> lol alright so i just eliminated 50% of the external interface of the resource manage
10:27:05 <RyanT5000> r
10:27:11 <RyanT5000> it now consists of only Node
10:27:13 <mahogny> nice :D
10:27:14 <RyanT5000> with open and close
10:27:27 <RyanT5000> i think this is complete, too
10:27:38 <RyanT5000> then of course there is the node-implementers' interface
10:27:42 <RyanT5000> which will be more complex
10:27:51 <RyanT5000> involving Transition, etc.
10:28:01 <davidhouse> anyone written an INI-file parser?
10:28:02 <mahogny> the operations I know so far should be there, are open, close, get, unget
10:28:09 <RyanT5000> what are get and unget?
10:28:13 <davidhouse> or some other config file format
10:28:26 <RyanT5000> davidhouse: there's an xml parser, i think
10:28:51 <mux> Cabal needs to know about the 2-clause BSD license
10:28:57 <mahogny> RyanT5000, you lock the resources just before using them. open and close are just for preparing to use a certain resource, a hint to the preloader
10:29:13 <davidhouse> actually the config file might as well be a haskell file.
10:29:21 <mahogny> RyanT5000, you could of course do without them
10:29:23 <dozer> does Cabal know the location of the relevant source code repository?
10:29:32 <RyanT5000> i think i'm  using open and close as your get and unget
10:29:39 <RyanT5000> and i don't like the idea of exposing caching hints at that level
10:30:17 <mahogny> RyanT5000, hm. actually, maybe it makes sense to remove get and unget when I think about it
10:30:35 <mahogny> RyanT5000, only the cache nodes will have to bother anyway, and those are written once and for all
10:30:52 <RyanT5000> let's say we have a function that returns a resource manager (in the form of returning a couple of nodes from it); then we can have an "advancedCreateResourceManager" that also returns some kind of cache-control thing
10:31:06 <mahogny> maybe
10:31:13 <SamB> mux: 2-clause?
10:31:18 <RyanT5000> hm, how do we type createResourceManager?
10:31:35 <mahogny> RyanT5000, here is also another thing to consider; how do you write a node that downloads files on demand without locking up the program? not hard, but worth pondering
10:32:06 <RyanT5000> i'd say probably threads; although, if you actually request the resource, it should block you if it has to download it
10:32:09 <mux> SamB: *nods*
10:32:22 <RyanT5000> if you give it a hint, otoh, it shouldn't block you
10:32:28 <mux> since it has BSD3 and BSD4 for the 3-clause and 4-clausse version
10:32:40 <RyanT5000> brb
10:32:47 <mahogny> RyanT5000, bad idea in many cases. I think the best is just to encapsulate it in a Just and let the receiver handle it
10:32:56 <SamB> mux: how does that one go?
10:33:06 <mux> SamB: what do you mean?
10:33:40 <mux> the 2-clause is the same as the 3-clause without the non-advertising clause
10:33:45 <davidhouse> can TH dynamically import modules?
10:33:56 <SamB> um...
10:34:03 <SamB> non-advertising clause?
10:34:32 <mahogny> RyanT5000, hm. as for type, it will be a very general type. the type it takes for "IDs" is ... a. and the type it passes on for resources is .... b :P
10:34:33 <mux> I suggest you google for it if you want the precise text
10:35:13 <mahogny> RyanT5000, the type b will however depend on a, but I dunno if that has to go into the class
10:42:37 <dcoutts> @localtime dons
10:42:37 <lambdabot> Local time for dons is Thu May 25 03:36:20 2006
10:42:46 <RyanT5000> mahogny: right now i have class Node node handle
10:43:05 <RyanT5000> handle is the type that you get when you open a resource from that node
10:43:23 <RyanT5000> open :: (Node srcNode srcHandle) => node -> srcNode -> srcHandle -> IO (Maybe handle)
10:43:33 <RyanT5000> i'm not sure that should be a Maybe though
10:43:41 <RyanT5000> i think perhaps it should just use an exception
10:43:43 <shapr> Ok, so far it looks like Adobe Acrobat Reader 7.0 for Linux does not support my $32 ebook.
10:43:54 <mahogny> RyanT5000, Maybe is better than an exception
10:44:09 <psi> Is it possible to receive some feedback on your SoC app? at least, primary reason of rejection?
10:44:15 <RyanT5000> well how do we distinguish errors like "Cannot find path" and "Cannot find resource"
10:44:29 <dcoutts> psi, I can a bit I guess
10:44:29 <RyanT5000> and/or get any other information out?
10:44:40 <mahogny> psi, since each person gave their opinion, you have to ask each mentor...
10:44:49 <psi> dcoutts: thanks
10:44:54 <RyanT5000> i mean, in what nonexceptional circumstance would you return Nothing?
10:45:18 <mahogny> RyanT5000, that's an evil question. I guess you could use Left a/Right String
10:45:19 <dcoutts> psi, you were in the top 20 (#17 actually) but we were allocated 9 projects.
10:45:24 <shapr> For example "Sign in using your .NET Passport, or follow the link to get one." seems to be part of the instructions for activating my ebook.
10:45:40 <RyanT5000> mahogny: that seems like it would be better done by exceptions
10:45:47 <mahogny> RyanT5000, much better
10:45:56 <psi> dcoutts: oh, not too bad.
10:45:57 <dcoutts> psi, we had mentors ready for you and many other projects but 9 is the number we got. We would have been happy to have taken more people on.
10:46:16 <psi> dcoutts: understandable
10:46:18 <dcoutts> psi, none of my projects got into the top 9. It was just very competitive.
10:46:26 <RyanT5000> alright so i'm gonna go with exceptions for the time being
10:46:57 <mahogny> RyanT5000, ehr wait. I said wrong; exceptions plain suck. sorry :)
10:47:04 <RyanT5000> why?
10:47:15 <dcoutts> psi, your prposal was reviewed very favourably, you were selected over the other 2 candidates for that project.
10:47:20 <mahogny> RyanT5000, the problem is that they offer no "nice" way of error recovery. there is some stuff, but it's ugly
10:47:31 <mahogny> RyanT5000, there was a discussion here recently about it
10:47:59 <RyanT5000> but Left/Right are equivalent to exceptions: just catch the exception, and encapsulate it
10:48:11 <psi> dcoutts: ok :) I'm probably going to do it anyway.
10:48:18 <dcoutts> psi, cool!
10:48:37 <davidhouse> @hoogle [[a]] -> [a]
10:48:37 <lambdabot> Prelude.concat :: [[a]] -> [a]
10:48:48 <mahogny> RyanT5000, yes, almost equivalent. the only problem is that they offer less fine-grained tools for dealing with it
10:48:48 <dcoutts> psi, you know about the GObject code generator in Gtk2Hs ?
10:49:02 <RyanT5000> hm
10:49:20 <mahogny> RyanT5000, no one stops the user from using an exception on a String though :)
10:49:29 <psi> dcoutts: nope
10:49:42 <psi> but I gather I can use quite a bit from the glib bindings
10:49:58 <dcoutts> psi, you might find it useful. It's in the gtk2hs darcs repo.
10:49:59 <mahogny> RyanT5000, actually, you could trivially make a node for it
10:50:17 <psi> I've been meaning to check how haskell callbacks are done.
10:50:51 <davidhouse> @hoogle replace
10:50:51 <mahogny> RyanT5000, hm. but type... I usually wait with making the type classes until I have written a few functions to see what it looks like
10:50:51 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
10:50:52 <lambdabot> System.Win32.File.mOVEFILE_REPLACE_EXISTING :: MoveFileFlag
10:50:52 <lambdabot> System.Win32.Registry.c_RegReplaceKey :: PKEY -> LPCTSTR -> LPCTSTR -> LPCTSTR -> IO ErrCode
10:51:01 <davidhouse> psi, higher order functions :)
10:51:22 <psi> dcoutts: are you using a patched version of c2hs? the official one doesn't support hierarchical modules.
10:51:24 <davidhouse> if you mean the same thing by "callback" as i assume you do
10:51:41 <dcoutts> psi, it does now, I sent the patch upstream.
10:52:05 <psi> davidhouse: gtk callbacks for instance. when this button is pressed, call that function.
10:52:09 <dcoutts> psi, it's included in a recent c2hs release (ie not just the current darcs version)
10:52:16 <davidhouse> psi, ah, okay, not what i was thinking.
10:52:19 <mux> I wonder, if I use a RWST IO and actually don't use the Writer monad in the code for instance, will the generated code end up the same as if I had use StateT + ReaderT + IO ?
10:52:22 <psi> dcoutts: oh, cool
10:52:24 <davidhouse> what would be a good way to replace a certain substring within a large string?
10:52:32 <davidhouse> (no regexes needed)
10:52:42 <SamB> psi: what are you doing?
10:52:46 <SamB> psi: you aren't doing XPCOM support by any chance?
10:52:56 <mux> more generically, will a monad that is actually unused will incur a performance penalty
10:52:59 <psi> SamB: no, gstreamer bindings
10:53:02 <shapr> Stinger_: So far, it seems your were right.
10:53:06 <mux> bah, can't type properly
10:53:28 <dcoutts> psi, it'd be nice to have the glib package be extended and made such that other packages other than gtk2hs can use it, eg your future gstreamer stuff
10:53:49 <RyanT5000> mahogny: the thing i don't like about Left/Right is that it forces the user to error-check everywhere
10:53:49 <psi> yep
10:53:56 <RyanT5000> explicitly
10:54:13 <ski> RyanT5000 : have you used the 'Either e' monad ?
10:54:15 <mahogny> RyanT5000, yes. but you can toss it into a monad if you want to
10:54:25 <RyanT5000> i'm already working in the IO monad
10:54:34 <ski> monad transformer, then
10:54:41 <RyanT5000> since the vast majority of resource loaders will need to do IO
10:55:05 <mahogny> RyanT5000, anyhow, you can just add a node that tosses the exceptions if you prefer it that way. it's up to the user that way
10:55:06 <psi> dcoutts: c2hs has the "class" hook, which seems to made specifically for Gtk-style libraries, but I didn't see gtk2hs use it. did I just miss it?
10:55:36 <ski> newtype EitherT e m a = ET (m (Either e a))  -- or something
10:55:56 <dcoutts> psi, no we don't use it. we use our own code generator for that bit and it's slightly different from what c2hs does. better in my opinion.
10:56:13 <psi> ah, ok
10:56:25 <psi> what does it do better?
10:59:10 <psi> this reminds to find out what unsafeCoerce does.
11:01:14 <RyanT5000> can you get stack traces from exceptions? or is there a function that returns a stack trace at the current location?
11:01:27 <RyanT5000> that's pretty critical when writing imperative code
11:01:36 <shapr> What's this about PDF meaning Portable? "Does the Acrobat eBook Reader run on Linux? - We do not currently plan to develop a version for the Linux platform, but we may in the future if that platform becomes more widely used."
11:01:57 <RyanT5000> is eBook really PDF?
11:02:00 <xerox> 'eBook' ?
11:02:01 * shapr grumbles and writes a polite letter to ebooks.com
11:02:06 <RyanT5000> isn't it, like, "encrypted pdf"?
11:02:25 <shapr> I got a PDF file, and the requirements said Adobe Acrobat Reader 7
11:02:25 <mattam> that's more crude
11:02:32 <RyanT5000> huh
11:02:40 <RyanT5000> that's really lame
11:02:45 <shapr> Only later did I notice it also said windows or mac os x.
11:03:25 <mattam> the is something about drm or no drm in poppler i think
11:03:38 <mattam> maybe they support eBooks
11:04:15 <RyanT5000> if you live in a country without laws against that kind of thing, seriously, get a crack
11:04:33 <shapr> My country does not have laws against cracking PDFs.
11:04:44 <shapr> At least, it didn't last I checked.
11:05:04 <RyanT5000> aren't there cracks out there?
11:05:11 <shapr> I don't know.
11:05:26 <shapr> I'd rather try the "color between the lines" approach first.
11:05:39 <RyanT5000> ah
11:05:45 <shapr> If ebooks.com says I can't use Linux and they won't give me a refund, then I'll see about a crack.
11:06:16 <shapr> As much as I would like to read this book, I'd also like to go back to the USA without getting arrested.
11:06:27 <RyanT5000> true
11:06:35 <RyanT5000> i hate the US's laws in that regard
11:06:40 <Cale> Do you think anyone would even notice if you'd cracked it?
11:06:44 <RyanT5000> they're not only evil but also stupid
11:06:50 <shapr> And the DMCA was designed for exactly this sort of thing, so that Adobe can lock me up forever if I crack an ebook.
11:07:05 <shapr> Cale: I'd notice.
11:07:27 <shapr> And either the laws are broken and should be changed, or they're good and we should follow them, yeah?
11:07:45 <RyanT5000> right, and these should be broken and changed
11:07:48 <RyanT5000> has anyone actually been convicted of a dmca violation yet?
11:07:55 <shapr> I think lots of people have
11:08:05 <RyanT5000> really? i thought everyone ended up getting off
11:08:09 <Cale> sure, though I tend to ignore such broken laws when they're unenforceable anyway.
11:08:42 <sjanssen_> RyanT5000: the threat of being prosecuted is enough
11:08:58 <shapr> Yeah, but ignored laws leads to a culture of paranoia and suspicion, because then people can get legally/correctly arrested for everyday behaviour.
11:09:05 <sjanssen_> I'm sure shapr, or indeed any mortal, could withstand an Adobe lawsuit, whether they were right or wrong
11:09:06 <shapr> That turns into tyranny.
11:09:13 <Cale> Not being prosecuted is like losing the lottery. It's really rather easy.
11:09:31 <RyanT5000> shapr: it's better to be disobeying a tyrant than obeying him
11:09:37 <RyanT5000> it's tyranny either way
11:09:46 <sjanssen_> erm, I'm sure that shapr could *not* withstand an Adobe lawsuit
11:09:53 <Cale> I'd probably just not move to the US. I'm fed up with their foreign policy anyway.
11:10:04 <shapr> Yeah, but civil disobedience should be done in public in front of the police station, not quietly at home. That's just cowardice, imho.
11:10:18 <jethr0> is it still tyranny if the tyrant will coincides with the populations'?
11:10:20 <shapr> I probably have an extreme viewpoint on that sort of thing...
11:10:51 <shapr> jethr0: I don't know, but if 50+% of the US uses p2p services to download music "illegally" something's wrong.
11:10:55 <RyanT5000> jethr0: i don't think so
11:11:14 <shapr> The last time that happened in the US was the Prohibition when alcohol was against federal law.
11:11:21 <RyanT5000> yep
11:11:24 <mattam> how do you disobey DMCA in public ?
11:11:36 <astrolabe> speeding?
11:11:37 <xerox> Burn it?
11:11:39 <RyanT5000> mattam: you be the guy writing hte programs to break it
11:11:42 <xerox> (Printed on paper)
11:11:59 <Cale> Write the programs while out on the street with big signs and posters
11:12:01 <mattam> well, i'm not expert enough
11:12:04 <jethr0> also, when the american constitution says copyright should not be given indefinitely and instead the timespan is enlarged whenever copyrights would expire, that's wrong too
11:12:08 <RyanT5000> send a copied DVD to your congressman
11:12:14 <shapr> jethr0: I totally agree.
11:12:15 <jethr0> but obviously doesn't justify breaking the law
11:12:18 <shapr> Mickey Mouse killed copyright law.
11:12:34 <RyanT5000> jethr0: why does that "obviously" not justify breaking the law?
11:12:36 <mattam> so did Bono
11:12:44 <RyanT5000> that's a terrible law, and it should be overturned
11:12:48 <shapr> Yeah, Bono was the guy in front of Disney.
11:13:02 <jethr0> RyanT5000: well, it's not so obvious. but rather than break the law, concerned citizens should try to change it.
11:13:04 <shapr> The recent copyright expiration of The Beatles in the UK is interesting.
11:13:16 <RyanT5000> the only problem is that i don't think it's unconstitutional, so taking it to the supreme court probably wouldn't be effective
11:13:33 <jethr0> if they're too lazy it's their own problem, and if it's impossible to sway the legislature bigger things than copyright infringements are at stake
11:14:07 <RyanT5000> yeah, like lobbyists
11:14:10 <jethr0> RyanT5000: imo it's unconstitutional to generally prolong the period and de facto make it infinite or at least arbitrarily long
11:14:11 <RyanT5000> which are a huge problem
11:14:23 <mattam> xerox: i like that idea, but maybe that would be wronly interpreted
11:14:45 <jethr0> originally in the states it was 30 years or so and now it's 170 or so (don't know the exact numbers)
11:14:55 <RyanT5000> jethr0: it *may* be unconstitutional, but you'd need a very favorable court for them to agree that it is
11:15:09 <RyanT5000> "bad policy" != "unconstitutional"
11:15:21 <mattam> it's unconstitutional if it is not a reasonable delay. > 70 years is not reasonable
11:15:31 <jethr0> i think life+70 years
11:15:40 <jethr0> that sounds a bit long
11:15:47 <RyanT5000> yeah, it's way too long
11:16:09 <RyanT5000> in these days, how many things really stay profitable for that long anyway?
11:16:12 <RyanT5000> only a very select few
11:16:21 <jethr0> RyanT5000: that's why i wrote "imo". it should be wrong though. when you're being sophistic you can generally argue every constitional paragraph away
11:16:28 <jethr0> as they are doing with freedom of the press, etc
11:16:34 <RyanT5000> yeah
11:16:45 <RyanT5000> this is why i'm going to law school, lol
11:17:15 <jethr0> RyanT5000: my issue isn't with the profitable ones, but with the rest. when you have to chase down copyright holders who've been dead for 70 years, that pretty much precludes you from doing anything
11:17:26 <RyanT5000> yeah
11:17:49 <jethr0> there was the example of some kind of movie review where they had to track down all actors appearing on the dvd. it took man years to find them after the decades past
11:17:55 <RyanT5000> what i meant was that so few get any benefit out of it that it's not worth the harm it causes with all the others
11:18:38 <RyanT5000> even if you would say that mickey mouse should stay copyrighted, that doesn't mean everything that old should be
11:18:46 <xerox> This sounds promising ! <http://lambda-the-ultimate.org/node/1500>
11:18:55 <jethr0> yes, and i'm still socialist enough to limit copyright even in profitable cases. after 30 years or so ideas simply have become "public domain" and the law should reflect that
11:19:21 <RyanT5000> yeah
11:19:29 <RyanT5000> i'm not exactly sure why the "life" clause exists at all
11:19:52 <RyanT5000> is it really that painful for your stuff to become public domain, that it's an unreasonable burdon for the law to impose?
11:20:08 <RyanT5000> "oh noes, this book i wrote 30 years ago can be copied; what will i do?"
11:20:50 <Cale> I think it should be 5 years, with the potential for one 5 year extension.
11:21:44 <jethr0> yes, extensions are a good thing because then those people uninterested in their stuff can be "discarded" and only serious content-creators (who can even be tracked down) remain. 5 years might be too little for authors. but anything longer than 25years really becomes ridiculous
11:22:34 <RyanT5000> huh, what if you had to get signatures for a petition to make your work stay copyrighted?
11:22:51 <RyanT5000> i presume people would go around with bribes and get signatures, but at least that means they have to put some effort in
11:23:24 <RyanT5000> otoh if for some reason you have thousands of fans who all want your work to stay copyrighted, you just say "please sign this" and you're good for another 5 years or something
11:23:41 <mattam> the first copyright law in the US grand 14 years, it was in 1790, with an option to renew it (from Lessig's "Free Culture"). Want to go back ?
11:23:54 <mattam> s/grand/granted/
11:24:11 <jethr0> mattam: YES, i would
11:24:27 <RyanT5000> yeah, that would be much better
11:24:44 <jethr0> 30,40,50 years would all be ok with me (especially if they required extending). but life+70 seems a little over the top
11:24:58 <mattam> i just noticed a typo in his book; "... passed in the pubic domain..." :)
11:25:06 <jethr0> he
11:25:09 <RyanT5000> in fact, i might say that 14 years is too long for the modern day
11:25:31 <RyanT5000> maybe for non-modern media it's too short
11:25:40 <jethr0> depends on the content and medium. books have a real long lifetime and i wouldn't want to keep authors from getting their well-deserved pay
11:25:54 <jethr0> but obviously "java in 21 days" won't be so hot in 50 years
11:25:55 <RyanT5000> but name one digital work that you would buy that was made 14 years ago
11:26:18 <mattam> Pong!
11:26:27 <jethr0> RyanT5000: i'm not sure whether this whole discussion applies to software. because you don't have to provide code.
11:26:35 <Cale> probably most of the money is made in the first few years anyway
11:26:37 <mattam> well, i'd rather code it in haskell :)
11:26:50 <jethr0> Cale: not necessarily for fiction.
11:27:06 <RyanT5000> does copyright apply to binaries?
11:27:20 <eivuokko> Yes.
11:27:29 <jethr0> maybe, but what are the chances of running really old binaries productively
11:27:36 <Cale> I suppose there's a chance that a particular work of fiction could come into popularity later on in its life
11:27:38 <RyanT5000> my point exactly
11:27:46 <jethr0> although having legal "abandon wares" would be cool
11:28:03 <RyanT5000> digital media, even music nowadays doesn't have even close to a 14 year profitable lifetime
11:28:19 <RyanT5000> i mean sure there might be a couple songs that are still profitable after that period of time
11:28:28 <jethr0> chart music is more like 140 days
11:28:35 <RyanT5000> right
11:28:42 <jethr0> if that
11:29:21 <RyanT5000> i don't know where the US got lost and started to think that copyright was supposed to be an effort to help the copyright holders
11:29:30 <jethr0> is there some kind of design by contract for haskell? but i guess it might go a bit against functional style
11:29:33 <RyanT5000> copyright should be about making it so consumers can buy things
11:30:07 <jethr0> RyanT5000: content holders like disney and time warner seem to have more influence than the P2P'ing public
11:30:18 <RyanT5000> lol true
11:30:39 <eivuokko> Well, law breakers usually aren't considered worth to trust designing laws.
11:30:39 <RyanT5000> somehow the public needs to dust off its pitch-forks
11:30:40 <Cale> I suppose it doesn't really apply to fiction, but for non-fiction works, a low expiration date on copyright would be a good way to encourage quality in new editions.
11:30:56 <RyanT5000> eivuokko: i disagree with that statement on a fundamental level
11:31:22 <RyanT5000> if you never let the law breakers make the laws, you only end up with more laws
11:31:24 <Cale> I know that there are a lot of texts for university courses where they do little more than rearrange the homework problems and call that a "new edition"
11:32:12 <RyanT5000> there's a difference between unethical and illegal actions, and it should be the people willing to focus on the former who are making the laws
11:33:13 <eivuokko> RyanT5000, I just stated it as a fact, do you have much evidence contrary?  You are just saying it shouldn't be so.  It's easy to come with counter-examples, should, say, child abusers get to make laws considering childs?
11:33:40 <eivuokko> It makes no sense from system's point of view to let people who break the law to design the law.
11:33:49 <RyanT5000> eivuokko: sorry, i read it as more of an ideal thing than a statement of fact thing
11:34:48 <RyanT5000> and what i said was that someone's law-breaking status is irrelevant to their lawmaking ability
11:35:36 <RyanT5000> it's only if someone breaks good laws that we should prevent them from making laws (because presumably they'd abolish good laws or make bad laws, or some combination of the two)
11:35:42 <eivuokko> Yeah, basically in western countries it is actually so.  But in practice political environment doesnt' allow it.  (Yet)
11:35:52 <RyanT5000> of course the definition of "good" and "bad" is very subjective
11:36:03 <eivuokko> Indeed.
11:41:05 <sjanssen_> @keal
11:41:06 <lambdabot> T seems to be haskell, except with a decent interface at this point
11:41:20 <xerox> hahahaha
11:41:22 <xerox> Dinner.
11:41:32 <RyanT5000> there should be a haskell -> brainfuck compiler
11:41:37 <RyanT5000> http://en.wikipedia.org/wiki/Brainfuck
11:42:08 <norpan> there shouldn't
11:42:17 <norpan> that would be utterly pointless
11:42:22 <RyanT5000> lol true
11:42:25 <RyanT5000> but it would be funny
11:42:28 <eivuokko> That's usually implied when Brainfuck is mentioned.
11:43:00 <jethr0> well, C is only a verbose brainf*ck with a little syntactic sugar
11:43:12 <RyanT5000> lol
11:43:22 <RyanT5000> and functions
11:43:37 <RyanT5000> (maybe it's possible to make functions in brainfuck?)
11:43:50 <jethr0> bah, functions. assembly shows that with jumps you pretty much don't need functions
11:43:57 <RyanT5000> it doesn't have jumps either
11:44:06 <jethr0> well, sort of
11:44:13 <int-e> you can emulate everything in brainfuck. just don't expect it to be much easier than doing it ona turing machine.
11:44:29 <RyanT5000> yeah
11:44:32 <RyanT5000> i know you can get any results
11:44:35 <jethr0> for me brainf*ck pretty much is a turing machine with a limited band
11:47:06 <sjanssen_> I'd like to try Keal's 'T' language, it sounds cool from what I've heard
11:47:25 <jethr0> and a decent interface, of course
11:47:35 <norpan> i think it's better to focus on practically usable languages
11:48:03 <jethr0> dpkg: dependency problems prevent configuration of fglrx-driver:
11:48:03 <jethr0>  fglrx-driver depends on xserver-xorg (<< 7.0.99); however:
11:48:03 <jethr0>   Version of xserver-xorg on system is 1:7.0.16.
11:48:05 <jethr0> *argh*
11:48:46 <sjanssen_> norpan: then why are you hanging out in #haskell
11:48:52 * sjanssen_ ducks
11:49:11 <norpan> w00t
11:50:38 <Cale> Haskell makes C look like BF as far as usability goes.
11:51:10 <magnus> exit
11:51:11 <Cale> @keal
11:51:12 <lambdabot> with KealDigit quantum crackproof encryption possible
11:51:19 <jethr0> i think a C->BF compiler wouldn't be that hard, except for library calls/marshalling
11:51:47 <Cale> Maybe someone will write one using Language.C
11:52:14 <Cale> actually, a proper C compiler in Haskell would be pretty interesting.
11:52:22 <jethr0> yes, i agree
11:52:35 <jethr0> although it would be compiled back to C. *oh the irony*
11:52:40 <Cale> GHC could then compile a new C compiler to compile itself with.
11:52:47 <jethr0> *ahh*
11:53:01 <eivuokko> C compiler with C-- backend would be seriously interesting
11:53:02 <jethr0> and do some *really* advanced flow analysis and optimizations
11:53:10 <eivuokko> (Ghc c--)
11:53:33 <dcoutts> yes, C-- would be much more useful for ghc
11:53:38 <jethr0> supposedly gcc is quite a mess when it comes to optimization code readability (from what i've heard)
11:54:23 <eivuokko> jethr0, it's pretty complicated to do anythign with gcc, I think.  The amount of shortcut macros is pretty much same as learning new language.
11:54:24 <Cale> supposedly gcc is coded in such a way to make proprietary use (if you need to modify it) impractical
11:54:30 <eivuokko> *gcc source
11:54:33 <jethr0> although there are some out there, i've always liked the idea of interpreted C, where you can set breakpoints and alter data/code
11:55:07 <Cale> probably the problem with GCC is that the people who are writing it are largely C programmers ;)
11:55:13 <jethr0> lol
11:56:01 <jethr0> i'm not saying gcc is bad. but in haskell a lot of code duplication and high-level abstractions could achieve comparable results with hopefully maintable code. but maybe i'm just daydreaming
11:56:16 <jethr0> s/a lot of/less/
11:56:37 <marc_vw_> look at freebsd: they got rid of cvsup because it was ridden in modula 2
11:56:48 <marc_vw_> look at freebsd: they got rid of cvsup because it was written in modula 2
11:57:24 <jethr0> that's because they do serious code review and noone could be bothered to learn modula :)
11:57:24 <marc_vw_> most os are written in c
11:57:35 <jethr0> so?
11:57:49 <marc_vw_> so the active crowd does c c c
11:58:33 <marc_vw_> modula is not hard to learn
11:58:35 <jethr0> not that it is a good example. but writing emacs in lisp didn't keep people from using it and even learn elisp.
11:58:38 <jethr0> marc_vw_: i know
11:58:53 <marc_vw_> emacs is er... special
11:58:58 <jethr0> marc_vw_: but would *you* want to do serious code review of lots of mangled modula code?
11:59:15 <marc_vw_> rather than rewriting that thingee in c 
11:59:26 <marc_vw_> (i guess)
11:59:39 <Lemmih> dons: ping.
11:59:43 <jethr0> or take darcs or pugs. the important thing is that a program does its job well. then there will most often be people around to work on it
11:59:58 <jethr0> mldonkey is written in ocaml and was at one point really popular
12:00:12 <marc_vw_> ejabberd in erlang does quite well lately
12:00:12 <ihope> Ah, yes.
12:00:28 <ihope> Two dimensional arrays. How easy are they to do?
12:01:07 <sjanssen_> ihope: just use a tuple for your index type, and you're set to jet
12:01:12 <jethr0> > listArray ((1,1),(4,4)) $ repeat 1
12:01:13 <lambdabot> array ((1,1),(4,4)) [((1,1),1),((1,2),1),((1,3),1),((1,4),1),((2,1),1),((2,2),1),((2,3),1),((2,4),1),((3,1),1),((3,2),1),((3,3),1),((3,4),1),((4,1),1),((4,2),1),((4,3),1),((4,4),1)]
12:01:23 <marc_vw_> nice 
12:01:37 <jethr0> sry, should've been (2,2)
12:02:00 <jethr0> spam
12:02:10 <norpan> they're still konceptually one dimensional
12:02:25 <norpan> you can't slice one dimension for instance
12:02:28 <marc_vw_> btw i have that funny feeling that c will stay around a lot longer than c++
12:02:41 <jethr0> norpan: true, but except fortran few languages have supported that lately
12:02:49 <sjanssen_> norpan: you can't do any slicing with Haskell arrays
12:03:04 <norpan> sjanssen_: you can't?
12:03:08 <sjanssen_> well, I suppose you could have the array of array approach
12:03:27 <jethr0> > let a = [[1,2],[3,4]] in head $ transpose a
12:03:28 <lambdabot> [1,3]
12:04:21 <norpan> no slicing, that's bad
12:04:35 <norpan> i like slicing
12:04:41 <jethr0> who doesn't
12:04:44 <jethr0> use fortran :)
12:04:55 <norpan> there must be better arrays
12:05:27 <pitkali> hi there
12:05:28 <sjanssen_> norpan: it certainly wouldn't be hard to write a SlicedArray data type and instance IArray
12:06:10 <pitkali> I'm quite new and have a question that will hopefully not bring many flames upon me
12:06:17 <jethr0> > array ((1,1),(1,4)) . filter (\((x,_),_) -> x == 1) . assocs $ listArray ((1,1),(4,4)) $ repeat 1
12:06:18 <lambdabot> array ((1,1),(1,4)) [((1,1),1),((1,2),1),((1,3),1),((1,4),1)]
12:06:33 <sjanssen_> pitkali: ask away, we're a friendly bunch
12:06:47 <pitkali> what do you recommend for indentation - tabs or spaces?
12:06:52 <norpan> unless you want us to do your homework :)
12:06:53 <jethr0> flamewar
12:06:53 <norpan> spaces
12:06:53 <sjanssen_> pitkali: spaces
12:06:56 <jethr0> spaces
12:07:07 <ihope> Spaces.
12:07:17 <jethr0> whitespace languages like python and haskell like spaces a lot :)
12:07:26 <pitkali> :)
12:07:50 <norpan> tabs are dangerous
12:07:56 <ihope> Well... tabs might be okay if it doesn't matter where the tab stops are.
12:07:57 <norpan> use spaces
12:08:11 <pitkali> I do, I was curious
12:08:15 <pitkali> what other people do :)
12:08:18 <ihope> Generally, it matters where the tab stops are.
12:08:46 <jethr0> tabs are actually quite nice for reformatting in dumb editors. but chances are you'll hit an error and find out half and hour later that some tab was in the way
12:09:07 <jethr0> you can use tabs, but the safest thing then is to have them indent 8 spaces in the editor as well
12:09:08 <Cale> the compiler assumes that tabs are 8 spaces
12:09:24 <pitkali> I read that already
12:09:27 <ihope> Is there a compiler option to set the tab stops? :-)
12:09:45 <jethr0> ihope: wouldn't that create some cross pc problems?
12:09:46 <sjanssen_> ihope: NOOOOOOOOOOOOOO!
12:10:08 <ihope> jethr0: why?
12:10:09 <Cale> Personally, I think the compiler should reject any file containing a tab character.
12:10:19 <jethr0> A: "it compiles fine here", B: "i get all kinds of weird error, did you set any compiler flags?"
12:10:32 <ihope> "Yes, I set --tab-stops 4."
12:10:42 <ihope> Or whatever.
12:10:46 <norpan> be safe - use spaces
12:10:56 <Cale> I bet you could come up with programs which did different things based on the interpretation of tabs.
12:11:04 <ihope> :-)
12:11:04 <jethr0> yeah
12:11:11 <jethr0> underhanded haskell contest
12:11:12 <wilx> The compiler should warn about tabs.
12:11:13 <sjanssen_> that would be neat!
12:11:38 <Cale> actually, it might be neat to sneak a security problem into haskell code like that
12:11:52 <stepcut> Cale: heh
12:12:26 <jethr0> > let \t = 4 in \t
12:12:27 <lambdabot>  parse error on input `='
12:16:10 <ihope> > let in = 3 in in
12:16:10 <lambdabot>  parse error on input `='
12:16:29 <jethr0> > let let = 3 in let
12:16:29 <lambdabot>  parse error on input `='
12:16:37 <ihope> > let do = sequence in do
12:16:38 <lambdabot>  Empty 'do' construct
12:16:41 <jethr0> stupid reserved words
12:16:45 <ihope> Heh.
12:16:53 <ihope> > let (=) = (==) in 3 = 3
12:16:53 <lambdabot>  parse error on input `='
12:18:35 <jethr0> > let (||) = 3 in (+) (||) (||)
12:18:36 <lambdabot> 6
12:23:08 <xerox> > (>>) (<) (>) '>' '<'
12:23:09 <lambdabot> True
12:23:12 * xerox snickers
12:24:45 <sjanssen_> lisppaste2: url
12:24:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:26:39 <pitkali> ok, bye and thanks for the talk
12:27:42 <jethr0> xerox: that line makes my head hurt
12:27:43 <lisppaste2> sjanssen pasted "sneaky tabs" at http://paste.lisp.org/display/20387
12:27:56 * xerox gives jethr0 a lambda-cookie
12:29:21 <jethr0> > liftM2 (>>) (>) (<) '<' '>'
12:29:22 <lambdabot> True
12:29:27 <mansu> i am looking for a way to print an charecter in a list onto the terminal and return the same list .. i am stuck with here ... outputByte :: [Char] -> Int -> [Char]
12:29:27 <mansu> outputByte string index = do
12:29:27 <mansu> 		putStr (string !! index)
12:29:27 <mansu> 		return string
12:29:36 <jethr0> i know what my version does. but why does yours work?
12:29:37 <sjanssen_> bah, it looks like lisppaste untabified my code
12:29:43 <jethr0> because (e->) is a monad?
12:29:58 <xerox> jethr0 - point.
12:30:25 <xerox> jethr0 - ((->) e) is known as the Reader Monad.
12:30:41 <jethr0> k, but are those versions identical?
12:31:01 <jethr0> and is there an infix version for >>?
12:31:22 <xerox> Yes, >>.
12:31:26 <jethr0> haha
12:31:32 <jethr0> xerox: no i meant with it being infix in your line
12:31:44 <sjanssen_> > ((>) >> (<)) '<' '>'
12:31:45 <lambdabot> True
12:31:56 <xerox> > ((<) >> (>)) '>' '<'
12:31:57 <lambdabot> True
12:32:01 <jethr0> mansu: whenever you have an IO operations the string is in IO too. so it would be String -> Int -> IO String
12:33:11 <lisppaste2> mansu pasted "printing a charecter onto a screen" at http://paste.lisp.org/display/20388
12:33:42 <mansu> jethr0: but i want to print it and return the string .. whats the correct way of doing this?
12:34:36 <xerox> mansu - `printf-like' debugging doesn't fit Haskell, modulo "cheating."
12:34:49 <jethr0> i.e. "trace"
12:35:10 <jethr0> mansu, the correct way of doing this is working with the "IO String"
12:35:32 <jethr0> wasn't there a faq somewhere on the wiki answering this question?
12:35:58 <mansu> xerox: thats not for debugging purposes... thats part of the logic... i want to print something when a condition is met... and then call the same function recursively 
12:35:59 <xerox> It ought be one.
12:36:09 <mansu> jethr0: let me try that ..
12:36:40 <jethr0> you'll most likely need some explanations. i'm still looking for that "how do i get the string out of IO String" faq
12:36:50 <xerox> mansu - is the result of the function the value upon the condition is checked?
12:38:18 <mansu> xerox: nope... the result of this print function is an argument to a recursive function..
12:38:39 <mux> maybe using a Writer monad would do you good
12:38:55 <xerox> mansu - what does "this print function" do exactly?
12:40:06 <jethr0> mansu: you'll have to become comfortable that IO actions are a bit "viral" in haskell. meaning that anything to do with IO has to be called from an IO'd function (up to "main").
12:40:28 <xerox> I just need a clear explanation of what he wants to do.
12:40:33 * jethr0 *ducks* because of bad formulation
12:40:34 <mux> always reminds me of const poiosoning in C
12:41:10 <norpan> remember, there is no function called unsafePerformIO
12:41:15 * jethr0 thinks that casts should be called "unsafeCastDontUse" :)
12:41:25 <sjanssen_> norpan: sssh!
12:41:35 <jethr0> *in C
12:41:51 <lisppaste2> mansu annotated #20388 with "complete program " at http://paste.lisp.org/display/20388#1
12:42:02 <mansu> xerox: i have pasted the code... which is using this ... have a look at the paste...
12:42:07 <xerox> Thank you.
12:42:24 <jethr0> there is no spoon
12:42:28 <mux> jethr0: in FreeBSD we have __DECONST :-)
12:42:37 <jethr0> hehe
12:42:42 <mux> pretty explicit too
12:43:05 <jethr0> doesn't that break tons of invariants, pre/post conditions and compiler warnings?
12:43:17 <mansu> jethr0: is that for me?
12:43:22 <mux> nope, the compiler is silent if you use a cast to uintptr_t
12:43:34 <mux> of course, that macro is _not_ to be used
12:43:39 <xerox> mansu - eek.  You can't simply "print something" at random time in the program.
12:44:07 <jethr0> xerox: it's a hard lesson. i had some trouble understanding how a language could not allow that :)
12:44:17 <xerox> Let me see....
12:44:42 <jethr0> Could not find module `System.Posix.IO': it is a member of package unix-1.0, which is hidden
12:44:45 <norpan> mansu: you have more than one problem with your program
12:44:46 <jethr0> *stupid cabal*
12:44:56 <mansu> xerox: how am i supposed to fix that? 
12:45:25 <jethr0> mansu: are you relatively new to haskell?
12:45:29 <xerox> mansu - I know of a brainf*ck compiler neatly written in Haskell you could poke at.  Let me find it.
12:45:32 <norpan> let bfIntptor return the string to print
12:45:39 <jethr0> @google bfinterpreter
12:45:42 <mansu> norpan: what are those... this is my second day with haskell
12:45:42 <lambdabot> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
12:45:54 <norpan> mansu: look at the function, it will never terminate
12:46:01 <norpan> it just keeps calling itself
12:46:27 <xerox> That's it!
12:46:43 <xerox> Geez, that's dense.
12:46:45 <jethr0> xerox: that bfinterpreter is WAAAY too advanced to explain IO
12:47:01 <mansu> xerox: are you sure i cant write one myself... without looking at an example? i am trying to learn the language
12:47:20 <xerox> mansu - I would suggest going through YAHT exercises on IO before.
12:47:25 <xerox> @where yaht
12:47:25 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
12:47:55 <sjanssen_> mansu: the simplest way out of this is to use lazy IO -- it isn't the solution to every problem, but it will work well here
12:48:10 <mansu> xerox: k i will have a look at it
12:48:35 <xerox> mansu - it gives a pretty good introduction to the topic.
12:48:54 <xerox> jethr0 - I still think that interpreter is quite readable (=
12:49:04 <xerox> s/that/that that/1
12:49:15 <mansu> sjanssen_: ok will have a look.. 
12:49:34 <sjanssen_> @hoogle getContents
12:49:34 <lambdabot> Prelude.getContents :: IO String
12:49:34 <lambdabot> IO.hGetContents :: Handle -> IO String
12:49:43 <jethr0> yesyes. i still think it's a superb piece of code. but it's pretty dense
12:49:48 <sjanssen_> oh wait, you want output
12:49:53 <mansu> xerox: i am trying to write an interpreter without looking at an existing one.. i think my thinking process will be crippled if i look at existing examples
12:49:59 <sjanssen_> @hoogle putStr
12:50:00 <lambdabot> Prelude.putStr :: String -> IO ()
12:50:00 <lambdabot> Prelude.putStrLn :: String -> IO ()
12:50:00 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
12:50:08 <xerox> mansu - It is a good idea, go for it!
12:51:08 <norpan> mansu: try this type for bfIntptor :: Inputlist -> Memory -> MemoryIndex -> String
12:51:38 <norpan> i don't think you need an inputindex as you will consume the input sequentially and can just use normal list recursion on that one
12:52:08 <xerox> norpan - what about loops?
12:52:23 <norpan> i don't know how that works in bf, but in that code there are no loops :)
12:52:42 <jethr0> norpan: loops are bounded in the code by '[' and ']'
12:52:44 <xerox> '[' pushes and calls, ']' rets.
12:52:44 <mansu> norpan: can i add otherwise to the gaurd so that the function terminates?
12:53:25 <norpan> [ pushes what?
12:53:25 <mansu> norpan: ya the prob will be with loops
12:53:47 <mansu> xerox: is a bfInperpretor diff app for someone starting with haskell?
12:54:01 <jethr0> mansu: rather
12:54:04 <xerox> mansu - `diff' ?
12:54:05 <norpan> if [ just pushes the rest of the program, that's easy
12:54:17 <norpan> just add an input stack argument
12:54:19 <jethr0> but sometimes chosing a hard program can be a good thing. i would rather suggest something easier
12:54:31 <mansu> xerox: i mean difficult
12:54:59 <xerox> mansu - no, you can do it, but I still advice you'd better go through YAHT before.
12:55:18 <norpan> yes, look at some simple stuff, like list recursion
12:55:43 <mansu> xerox: ok will go through it, IO/Monads are the things i do not understand at the moment...
12:56:01 <xerox> YAHT makes you do a little game which is a good start for understaning how IO works in Haskell.
12:56:18 <norpan> yes that's a good tutorial
12:56:32 <mansu> xerox: yaht is 192 page tutorial... thought that was similar to others
12:56:49 <xerox> If you have got more time there also are good books -- what is that one you always suggest, monochrom?
12:57:12 <monochrom> I always suggest Hudak's book.
12:57:32 <hyrax42> a question about stacking monads
12:58:02 <hyrax42> I have a "state", but part of this will not change throughout the entire computation
12:58:12 <hyrax42> I am thinking I might want to stack state and reader
12:58:23 <norpan> hyrax42: go for it!
12:58:24 <hyrax42> do I?
12:58:38 <xerox> hyrax42 - yup.
12:58:48 <hyrax42> ok, then the if-yes-then-answer question is
12:58:55 <hyrax42> which order is preferable
12:59:05 <hyrax42> statet on reader or readert on state
12:59:16 * hyrax42 finding this all a little confusing and subtle still
12:59:33 <norpan> state on reader
12:59:37 <xerox> You will have to `lift' all calls to the inner Monad's functions, so do what is more comfortable.
12:59:52 <norpan> you will use more state calls
13:00:10 <monochrom> I am not sure we should stack.  How about this?  Get the current state, create a reader monad using it.
13:00:32 <hyrax42> that doesn't quite fit the problem
13:00:54 <hyrax42> which is (still!) a diplomacy orders resolver
13:00:55 <norpan> both state and reader have the same sort of bind so it really doesn't matter how you stack them
13:01:03 <hyrax42> ok
13:01:26 <norpan> at least i don't think so :)
13:01:38 <hyrax42> hm
13:01:46 <hyrax42> well I'll look at it in the evening
13:01:58 <hyrax42> just wanted to ask before I went out for a bit, so I have something to think about
13:02:01 <hyrax42> thanks :)
13:02:30 <norpan> don't think while walking/driving
13:02:39 <norpan> accidents happen all too easily
13:02:43 <monochrom> don't drink while thinking
13:02:47 <hyrax42> ha
13:02:51 <norpan> don't think and drive
13:02:52 <hyrax42> don't think while drinking
13:02:53 <xerox> monochrom's idea sounds like a `listen' for a inner Writer.
13:02:55 <norpan> good slogan
13:03:25 <mahogny> Listen to the Writer Monad within Yourself
13:03:32 <hyrax42> oh I am also thinking about putting a writer in there somewhere, but that's quite unnecessary and I'm not familiar with writer yet
13:03:42 <hyrax42> (or reader or state for that matter... but a little more, at least!)
13:03:46 <xerox> @docs Control.Monad.RWS
13:03:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
13:03:51 <xerox> That has them all (-:
13:04:56 <hyrax42> :o
13:07:03 <monochrom> Someone please ask lambdabot to remember mahogny's "Listen to the Writer Monad within Yourself"  :)
13:07:24 <mahogny> lol
13:07:27 <sjanssen_> @help quote+
13:07:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:07:34 <xerox> I think it is not doable anymore or something like that :-(
13:07:34 <sjanssen_> @help remember
13:07:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:07:49 <xerox> @remember mahogny Listen to the Writer Monad within Yourself
13:07:49 <lambdabot> Unknown command, try @list
13:08:01 <xerox> @quote-add mahogny Listen to the Writer Monad within Yourself
13:08:08 <xerox> @quote mahogny
13:08:24 <xerox> Just lagged? (:
13:08:42 <Lemmih> @bot
13:08:42 <sjanssen_> xerox: I asked lambdabot to list commands -- it will lag for a few seconds
13:08:44 <mahogny> I don't think so :)
13:09:00 <mahogny> > putStr "mahogny Listen to the Writer Monad within Yourself"
13:09:01 <sjanssen_> lambdabot is entirely too functional!
13:09:03 <lambdabot> Unknown command, try @list
13:09:04 <xerox> Lemmih - hi!  I saw your comment.
13:09:07 <lambdabot> mahogny hasn't said anything memorable
13:09:11 <lambdabot> :)
13:09:12 <mahogny> llo
13:09:13 <lambdabot> No IO allowed
13:09:16 <Lemmih> xerox: What comment?
13:09:18 <mahogny> aha
13:09:26 <xerox> Lemmih - about BEncode.
13:09:48 <xerox> Lemmih - I thought that those were the same, thanks for pointing out.
13:10:16 <mahogny> I assume lambdabot is unsafePerformIO protected? :)
13:10:47 <Lemmih> xerox: Ah, on the SoC page.
13:10:57 <jethr0> mahogny: you can't do IO in lambdabot
13:11:14 <mahogny> jethr0, well, the idea was to get rid of IO that way :/
13:11:19 <jethr0> ah, unsafePerformIO, i think so
13:11:31 <jethr0> you'd have to ask dons for specifics (or look at the code)
13:11:49 <mahogny> or just send an rm -Rf and see if it still responds? ;)
13:12:06 <jethr0> > Foreign.unsafePerformIO $ putStrLn "hello world"
13:12:07 <lambdabot>  Not in scope: `Foreign.unsafePerformIO'
13:12:17 <mahogny> hmm
13:12:33 <jethr0> > trace "hello" 4
13:12:33 <lambdabot>  Not in scope: `trace'
13:12:39 <jethr0> > Debug.Trace.trace "hello" 4
13:12:40 <lambdabot>  Not in scope: `Debug.Trace.trace'
13:12:49 <Cale> of course it's not going to have System.IO.Unsafe loaded
13:12:56 <jethr0> hehe
13:12:58 <norpan> > putStrLn "Hello" `seq` 10
13:12:59 <lambdabot> 10
13:13:00 <mahogny> one can always hope :)
13:13:36 <norpan> at least it allows IO as a type
13:14:04 <sjanssen_> > putChar
13:14:05 <lambdabot> <Char -> IO ()>
13:15:27 <norpan> i wonder if you can get it to output a newline
13:15:50 <jethr0> norpan: can you do that without using IO in hugs or ghci?
13:16:21 <norpan> you can define a show instance, ghci will implicitly use print
13:16:42 <jethr0> hmm, no i meant without declaring data types
13:16:48 <jethr0> just on the command line
13:17:08 <jethr0> brb
13:18:28 <SamB> you would need to apply an IO action to an argument to have *any* hope of its running
13:19:58 <xerox> > const 1 $ (undefined :: a -> IO a) "please run!"
13:19:59 <lambdabot> 1
13:20:01 <xerox> Nah.
13:21:00 <hyrax42> @type seq
13:21:00 <lambdabot> forall b a. a -> b -> b
13:21:08 <hyrax42> @index seq
13:21:09 <lambdabot> Prelude, Control.Parallel
13:21:34 <xerox> Well, if *any* means `necessary but not sufficient' I agree :)
13:22:03 <monochrom> It is very inadequately insufficient.
13:22:33 <monochrom> It is also wrong.
13:23:02 <xerox> I would have tought so, but I tought you must fill in the blanks to let it run, eventually.
13:23:03 <monochrom> putStr is not an IO action.  putStr "" is an IO action.
13:23:14 <xerox> Ah, in *that* sense.  Agreed.
13:23:51 <xerox> Is a bit subtle to say that a -> IO a is a function, but that is.
13:24:48 <sjanssen_> > (:)) 1 ([2]
13:24:49 <lambdabot> [1,2]
13:24:51 <sjanssen_> hehe
13:25:05 <isaacd> parentheses?
13:25:16 <xerox> O_O
13:25:23 <sjanssen_> I really hope dons doesn't have some sort of injection bug in this, that'd be terrible
13:25:41 <jethr0> xerox: what da heck?
13:25:51 <jethr0> sry, sjanssen_ i meant
13:25:58 <hyrax42> the whole thing is wrapped in parens
13:26:02 <hyrax42> before beying evaluated
13:26:05 <monochrom> Man I am wordless!
13:26:12 <jethr0> hehe
13:26:13 <hyrax42> is what it lookslike, anyhow
13:26:15 <sjanssen_> hyrax42: yep, I know that because I suggested the change last night!
13:26:19 <xerox> > id)(putStrLn "hi"
13:26:19 <lambdabot> No IO allowed
13:26:32 <jethr0> > 4,2
13:26:33 <lambdabot> (4,2)
13:26:38 <xerox> hahahahaha.
13:26:47 <hyrax42> sjanssen_: what was it previously
13:26:55 <hyrax42> or how
13:26:58 <isaacd> > +
13:26:58 <lambdabot> Add a type signature
13:27:03 <sjanssen_> I'm guessing dons uses Typeof or some such, and compares it with the typeid of IO
13:27:04 <jethr0> > 
13:27:04 <lambdabot> <stdin>: hGetLine: end of file
13:27:15 <xerox> > + :: Int -> Int -> Int
13:27:16 <lambdabot>  parse error on input `::'
13:27:25 <jethr0> )(
13:27:28 <jethr0> > )(
13:27:28 <lambdabot> Couldn't match `()' against `t -> t1'
13:27:35 <xerox> > +)( :: Int -> Int -> Int
13:27:35 <lambdabot>  parse error on input `::'
13:28:25 <jethr0> > +) 3 (2
13:28:27 <lambdabot> 5
13:28:27 <hyrax42> > +) :: Int ->Int ->Int (3
13:28:27 <lambdabot>  Only unit numeric type pattern is valid
13:28:36 <jethr0> +)3(2
13:28:38 <jethr0> > +)3(2
13:28:40 <lambdabot> 5
13:29:03 <isaacd> sjanssen_: it looks at the error message to figure out whether it's IO
13:29:05 <isaacd> no_io      = mkRegex "No instance for \\(Show \\(IO"
13:29:17 <jethr0> > let x = (+) in x)3(2
13:29:22 <isaacd> Plugin.Plugs
13:29:23 <lambdabot> 5
13:29:27 <sjanssen_> isaacd: ahh, yes, Show
13:30:14 <isaacd> > ++
13:30:15 <lambdabot> Add a type signature
13:30:46 <xerox> Well, have fun.  Goodnight.
13:30:47 <sjanssen_> @version
13:30:47 <lambdabot> lambdabot 3p7, GHC 6.4.1 (Linux i686 3.20GHz)
13:30:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:31:18 <jethr0> > (+))(3)((2)
13:31:19 <lambdabot> 5
13:31:34 <norpan> yeah we get it
13:31:39 <jethr0> sry
13:31:42 <norpan> it puts parenthis around it
13:33:30 <sjanssen_> > ++ "love this") ("norpan will "
13:33:31 <lambdabot> "norpan will love this"
13:34:03 <norpan>  
13:34:40 <isaacd> > &&
13:34:41 <lambdabot> <Bool -> Bool -> Bool>
13:36:55 <SamB> xerox has strange ideas about what an "IO action" is
13:37:10 <xerox> Pong.
13:37:19 <sjanssen_> > 3
13:37:19 <sjanssen_> ; 4
13:37:20 <lambdabot> 3
13:37:25 * sjanssen_ get's worried
13:37:43 * sjanssen_ adds apostrophes
13:37:58 <xerox> SamB: how you "feed arguments" to a value of the type "IO a" ?
13:38:13 <SamB> xerox: well, first you have to get under the newtype
13:38:23 <xerox> Ah, ``apply an IO action to an argument'' you said.
13:38:44 <xerox> Nah, doesn't make sense to anyway.
13:38:56 <int-e> > )==(
13:38:57 <xerox> I'd say ``plug it in the RTS and make it spin.''
13:38:58 <lambdabot> True
13:39:09 <SamB> it won't run if you don't pass in the world, I tell you!
13:39:21 <sjanssen_> SamB: getting into the newtype would require GHC extensions (which are off for lambdabot), not to mention more imports
13:39:58 <Cale> ouch with the parens thing
13:40:44 <xerox> Fortunately we got Parsec and not regexp so if we want we could esaily check for balanced parens in the expression before `eval'ling it. (-:
13:40:50 <norpan> > [| (\x->x) |]
13:40:51 <lambdabot> \x_0 -> x_0
13:41:04 <norpan> it supports th it seems
13:41:09 <xerox> Yes, a safer subset.
13:41:10 <jethr0> > /msg lambdabot > 4
13:41:11 <lambdabot>  Not in scope: `lambdabot'
13:41:46 <xerox> She should be in scope ;)
13:41:56 <int-e> @query lambdabot
13:41:57 <lambdabot> Unknown command, try @list
13:42:02 <int-e> woops.
13:42:02 <zarvok> heh, lambdabot is female?
13:42:24 <sjanssen_> @vixen are you female?
13:42:24 <lambdabot> i truely am
13:42:26 <xerox> zarvok - <http://www.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html>
13:42:30 <sjanssen_> zarvok: there you have it
13:42:37 <zarvok> heh, cute
13:43:03 <norpan> @vixen are you male?
13:43:03 <lambdabot> yes, i am
13:43:35 <sjanssen_> @vixen what is your gender?
13:43:35 <lambdabot> i don't know, what?
13:44:00 <norpan> @vixen what is your name emily?
13:44:01 <lambdabot> My name is Emily
13:44:06 <zarvok> @vixen are you male or female?
13:44:06 <lambdabot> i truely am
13:44:14 <Lemmih> @vixen You're quite agreeable, aren't you?
13:44:14 <lambdabot> me?
13:44:16 <zarvok> @vixen what is your name?
13:44:16 <lambdabot> My name is Emily
13:44:31 <Cale> @vixen are you androgynous?
13:44:31 <lambdabot> yes, i am
13:44:35 <zarvok> heh
13:44:57 <Cale> @vixen what isn't your name?
13:44:57 <lambdabot> My name is Emily
13:45:43 <sjanssen_> @vixen this statement is false
13:45:43 <lambdabot>  key
13:46:14 <zarvok> @vixen this statement is unprovable
13:46:15 <lambdabot> People think I'm weird...   do you?
13:46:18 <zarvok> haha
13:46:20 <jethr0> @vixen what's your major?
13:46:21 <lambdabot> i'm a psychology major
13:46:26 <isaacd> @vixen do you know Greek?
13:46:27 <lambdabot> yeah, i know
13:47:35 <jethr0> > @vixen emily, what's your name, emily?
13:47:36 <lambdabot>  parse error on input `@'
13:47:39 <jethr0> @vixen emily, what's your name, emily?
13:47:40 <lambdabot> My name is Emily
13:47:43 <int-e> > ); take _ _ = ("Hello, world!"
13:47:45 <lambdabot> Hello, world!
13:47:46 <isaacd> > ?bot -> bot
13:47:47 <lambdabot>  parse error on input `->'
13:47:57 <Cale> ahaha
13:48:21 <jethr0> int-e: huh?
13:48:23 <eivuokko> int-e, yikes...
13:49:03 <jethr0> > ); take _ _ = ("Hello, world!\n"
13:49:04 <lambdabot> Hello, world!
13:49:09 <Cale> > ); take _ _ = ("> 1 + 1"
13:49:10 <lambdabot> > 1 + 1
13:49:21 <Cale> now we just need a second lambdabot :)
13:49:28 <jethr0> that's really evil
13:49:35 <int-e> hmm.
13:49:39 <Cale> can we get a quine?
13:50:04 <jethr0> > ); take _ _ = Debug.Trace.trace "hello world" 3
13:50:04 <lambdabot>  parse error on input `)'
13:50:09 <int-e> I just had that same idea. It should be possible.
13:50:15 <jethr0> > ); take _ _ = (Debug.Trace.trace "hello world" 3
13:50:16 <lambdabot>  Not in scope: `Debug.Trace.trace'
13:50:30 <isaacd> and imports can only come before all function definitions...
13:50:55 <Pseudonym> http://tunes.org/~nef/logs/haskell/06.04.18
13:50:59 <Pseudonym> About 3/4 of the way down.
13:51:09 <Pseudonym> I actually got a recursive loop between two isntances.
13:51:27 <Pseudonym> Search for "haskell programmers have too much time on their hands".
13:53:16 <Pseudonym> > ); take _ _ = let q x = x ++ show x in q "> ); take _ _ = let q x = x ++ show x in q "
13:53:16 <lambdabot>  parse error on input `)'
13:53:36 <Pseudonym> Ah.
13:53:54 <Pseudonym> > ); take _ _ = (let q x = x ++ show x in q "> ); take _ _ = (let q x = x ++ show x in q "
13:53:55 <lambdabot> > ); take _ _ = (let q x = x ++ show x in q "> ); take _ _ = (let q x = x ++ show x in q "
13:53:57 <Pseudonym> Yay!
13:54:08 <Pseudonym> We have a quine.
13:54:27 <int-e> ah! great, I was still looking for a trick for putting the string at the end.
13:54:40 <Pseudonym> "show" is good for that.
13:55:17 <Pseudonym> > let q x = x ++ show x in q "let q x = x ++ show x in q "
13:55:18 <lambdabot> "let q x = x ++ show x in q \"let q x = x ++ show x in q \""
13:55:37 <int-e> > ); q s = s ++ show s; take _ _ = (q "> ); q s = s ++ show s; take _ _ = (q "
13:55:39 <lambdabot> > ); q s = s ++ show s; take _ _ = (q "> ); q s = s ++ show s; take _ _ = (q "
13:55:39 <Pseudonym> That's the basic structure of the simplest quine in Haskell.
13:55:40 <morans> mmm quines?
13:56:00 <int-e> I already had s ++ show s; it was the idea of using a helper function that I was missing
13:56:15 <RyanT5000> why doesn't it spit out the opening ); ?
13:56:25 <int-e> > ); take _ _ = s ++ show s; s = ("> ); take _ _ = s ++ show s; s = ("
13:56:26 <lambdabot> > ); take _ _ = s ++ show s; s = ("> ); take _ _ = s ++ show s; s = ("
13:56:28 <RyanT5000> i mean, why isn't that a syntax error?
13:56:45 <int-e> but actually the helper function isn't even necessary :)
13:56:55 <Pseudonym> Now, if you want an even more interesting exercise, work this one out:
13:56:58 <Pseudonym> http://iohcc.mgoetze.net/Pseudonym.hs
13:57:05 <eivuokko> RyanT5000, the expression is in something like let foo = ( <insert text> )
13:57:19 <RyanT5000> ah
13:57:21 <Pseudonym> You will note that the start of the program is basically "q x = x ++ show x"
13:57:35 <ihope> module Main where main=putStrx>>print x where x="module Main where main=putStrx>>print x where x="
13:57:47 <ihope> s/putStrx/putStr x/g
13:59:02 <int-e> let foo = ( <...> ) in take 2048 (show foo) ... to be precise. hence the trick of defining take as a string.
13:59:11 <int-e> take _ _ that is.
13:59:24 <sjanssen_> is there Haddock/any other kind of documentation for ghc-api?
14:00:04 <ihope> So we got another lambdabot buggy...
14:00:39 <Lemmih> sjanssen_: No, not really.
14:01:06 <Lemmih> sjanssen_: The source is pretty well commented, though.
14:01:33 <ihope> > ); take _ _ = "\1ACTION CTCP's\1"; dummy = (
14:01:33 * lambdabot CTCP's
14:01:56 <jethr0> > ); putStrLn ("hello world"
14:01:56 <lambdabot>  parse error on input `}'
14:01:57 <sjanssen_> it'd be neat if lambdabot used ghc-api, we'd be done with all these weird eval wibbles
14:02:09 <int-e> jethr0: no IO.
14:02:15 <ihope> @seen dons
14:02:15 <lambdabot> dons is in #Haskell.se, #haskell-overflow and #haskell. I last heard dons speak 9 hours, 58 minutes and 44 seconds ago.
14:02:33 <Pseudonym> It's 7am where dons is.
14:02:37 <Pseudonym> You won't see him for a while.
14:02:38 <Lemmih> sjanssen_: And @type would be prettier.
14:02:46 <Pseudonym> I should know, I'm in the same time zone.
14:02:49 <ihope> Wake him up!
14:03:09 <Pseudonym> And I sure as hell wouldn't be here if it wasn't for extraordinary circumstances.
14:03:29 <ihope> What extraordinary circumstances?
14:03:39 <Pseudonym> Oh, a friend was over from England.
14:03:40 <Lemmih> Pseudonym: Got a paper due later today?
14:03:41 <Pseudonym> Backpacking.
14:03:48 <Pseudonym> had to put him on a bus.
14:03:49 <isaacd> > )} in let {x=(
14:03:51 <lambdabot> ()
14:03:57 <ihope> > ); dummy = (
14:03:58 <lambdabot> ()
14:04:05 <ihope> > ); (
14:04:06 <lambdabot>  parse error on input `}'
14:05:21 <int-e> let { foo = (); () } in ... foo ...
14:05:58 <int-e> @pl \s -> s ++ show s
14:05:59 <lambdabot> ap (++) show
14:06:29 <int-e> > ); take _ _ = app (++) show ("> ); take _ _ = app (++) show ("
14:06:30 <lambdabot> Couldn't match `(b -> t -> t1 -> t2, b)' against `t3 -> t4'
14:06:34 <ihope> > ); show _ _ = seq Foreign.unsafePerformIO "bleh"; dummy = (
14:06:35 <lambdabot>  Not in scope: `Foreign.unsafePerformIO'
14:06:37 <int-e> > ); take _ _ = ap (++) show ("> ); take _ _ = ap (++) show ("
14:06:38 <lambdabot> > ); take _ _ = ap (++) show ("> ); take _ _ = ap (++) show ("
14:06:39 <ihope> Whew.
14:08:38 <isaacd> > )} in xxx; xxx = let {x=(
14:08:39 <lambdabot>  Not in scope: `dyl'
14:08:42 <isaacd> > )} in xxx; xxx = let {x=(
14:08:43 <lambdabot>  Not in scope: `mhw'
14:08:45 <isaacd> > )} in xxx; xxx = let {x=(
14:08:46 <lambdabot>  Not in scope: `vgm'
14:08:58 <jethr0> haha
14:09:08 <Beelsebob> > "STOP TRYING TO ABUSE LAMBDABOT!"
14:09:09 <lambdabot> "STOP TRYING TO ABUSE LAMBDABOT!"
14:10:11 <int-e> Pseudonym: I cheated and won :)
14:10:32 <int-e> what do you mean, trying?
14:10:37 <Pseudonym> :-)
14:12:38 <jethr0> > ); take _ _ = error ("hello world"
14:12:39 <lambdabot> Exception: hello world
14:12:42 <inv> hi all
14:13:04 <inv> is it possible to make GHCi a bit more faster during loading ?
14:13:05 <Lemmih> inv: Hiya.
14:13:20 <inv> Loading package base-1.0 ... linking ... done. - is slow
14:13:21 <norpan> inv: yes ghci can use compiled files
14:13:25 <marc_vw> shapr: what about your erlang vs haskell war?
14:13:57 <jethr0> > ); take _ _ = error (error "hello world"
14:13:58 <lambdabot> Exception: hello world
14:14:03 <inv> erlang - is dynamic typed :(
14:14:17 <marc_vw> it is a different beast
14:14:32 <inv> for example APL is so cool language, but its dynamic too.
14:15:13 <Excedrin> >  parse error on input `)'
14:15:13 <lambdabot>  parse error on input `)'
14:15:59 <jethr0> > ); take _ _ = ("\1PRIVMSG #esoteric Testing...\1"
14:16:22 <norpan> oh
14:17:04 <inv> how is it possible to make GHCi run function from hs file ?
14:17:26 <inv> I try to declare: main = some_fun ..., but it doesn't work
14:17:31 <inv> in module
14:17:49 <norpan> just type main in ghci
14:18:08 <norpan> or whatever the function's name is
14:18:08 <inv> I know :), but without typing 
14:18:14 <norpan> use runghc
14:18:37 <inv> 'runghc' is not recognized as an internal or external command
14:18:43 <norpan> use it from the shell
14:18:51 <inv> ok, thx.
14:18:53 <norpan> it comes with ghc
14:19:09 <norpan> it will run the main function
14:19:30 <jethr0> > ); take _ _ = ("\1ACTION should be quit\1"
14:19:31 * lambdabot should be quit
14:20:12 <jethr0> > ); take _ _ = ("\1KICK jethr0\1"
14:21:00 <int-e> jethr0: you want to learn what CTCP is. It's *not* the bare IRC protocol (luckily)
14:22:01 <jethr0> int-e: just found it
14:22:07 <jethr0> > ); take _ _ = ("\1PING jethr0\1"
14:22:13 <jethr0> damn
14:22:36 <jethr0> > ); take _ _ = ("\1TIME\1"
14:22:41 <int-e> you can experiment with that stuff perfectly well in a private chat.
14:22:57 <inv> data Pars a = Ok String (Pars a) | No
14:22:58 <jethr0> bah, i give up. but i'm still in favor of shutting lambdabot down until this is resolved
14:23:07 <inv> is "show (Ok v n) = "Ok (" ++ v ++ ") ->\n " ++ show n" not correct ?
14:23:21 <norpan> > ); take _ _ = ("\1DCC send /etc/passwd\1"
14:23:31 <jethr0> and that's why
14:23:59 <jethr0> FACE seems like fun
14:24:02 <norpan> hmm
14:24:02 <sjanssen_> I think this can be resolved with a clever layout hack
14:24:14 <khaladan> > ); lol
14:24:25 <norpan> inv: you need to escape \" inside the string
14:24:36 <jethr0> norpan: lambdabot is unlikely to implement DCC
14:24:38 <inv> show (Ok v n) = "Ok (" ++ v ++ ") ->\n " ++ show n
14:24:48 <norpan> err
14:24:52 <inv> its not all the string
14:25:25 <inv> why ? so I shuld use show v = case v of .... ?
14:25:30 <norpan> inv: correct in what way?
14:27:06 <inv> h.m. it works
14:27:14 <inv> strange, it doesn't work in hugs
14:27:18 <norpan> > ); take _ _ = ("\1ACTON smiles\1\n\\QUIT"
14:27:26 <sjanssen_> inv: what kind of error message?
14:27:33 <jethr0> i've got the feeling that lambdabot is gone
14:28:01 <RyanT5000> > 5
14:28:07 <inv> sjanssen_: can't find now. didn't work at work in hugh, home+ghc - is ok
14:28:24 <ihope> > ); take _ _ = "bonks\r\nPRIVMSG #haskell :boinks"; dummy = (
14:28:43 <lambdabot>  parse error on input `)'
14:29:07 <sjanssen_> ihope: I think it's time to stop
14:29:21 <lambdabot> \QUIT
14:29:25 <isaacd> lambdabot is getting tired
14:29:26 <ihope> Wuh oh.
14:29:26 <binary42> ?!? File transfer from lambdabot.... /etc/passwd. Not good.
14:29:29 <lambdabot> 5
14:29:37 <lambdabot> bonks
14:29:39 <lambdabot> PRIVMSG #haskell :boinks
14:29:45 <norpan> > ); take _ _ = ("\1ACTON smiles\1\n/QUIT"
14:29:48 <ihope> Eeh.
14:29:50 <jethr0> binary42: i don't think lambdabot implements DCC
14:29:53 <sjanssen_> does anyone have ops on lambdabot?  she needs to leave
14:29:57 <mauke> zomg ACTON
14:30:00 <binary42> jethr0: Then who spoofed it?
14:30:03 <lambdabot> Maybe you meant: . id pl v wn
14:30:09 <lambdabot> /QUIT
14:30:12 <jethr0> norpan: as int-e already mentioned CTCP is not your clients commands
14:30:19 <norpan> i know
14:30:23 <norpan> that's why the newline
14:30:27 <int-e> people could just stop using that bug.
14:30:28 <binary42> jethr0: I literally got a file send (rejected) from a lambdabot.
14:30:33 <ihope> /quit is not an IRC command.
14:30:42 <mauke>  DCC received CTCP SEND with invalid parameters from lambdabot
14:30:47 <jethr0> http://www.user-com.undernet.org/documents/ctcpdcc.php
14:31:00 <ihope> It's something that makes chat clients send an IRC command.
14:31:06 <jethr0> uh!
14:31:26 <jethr0> doesn't mean much. ctcp is only to setup dcc connections
14:31:29 <sjanssen_> dons: ping
14:31:35 <int-e> anyway, it's not like people can use lambdabot to do stuff they couldn't do without it - and they can't hide their identity either.
14:31:37 * int-e shrugs
14:31:48 <dcoutts> @localtime dons
14:31:50 <lambdabot> Local time for dons is Thu May 25 07:25:31 2006
14:31:56 <sjanssen_> oh yes, far too early
14:32:06 <dcoutts> sjanssen_, yeah, a bit
14:32:07 <sjanssen_> I dunno, maybe there isn't anything serious here
14:32:23 <dcoutts> oh you mean lambdabot 
14:33:16 <ihope> Luckily, lambdabot isn't sending this output right into the socket or whatever.
14:33:29 <inv> is it possible to debug ghci function step-by-step ?
14:33:36 <ihope> It's packaging the text as a couple of IRC commands, then sends those.
14:33:39 <jethr0> luckily the whole thing is insidean "unsafeEval" with only select modules as environment
14:33:42 <dcoutts> inv, not at the moment
14:33:43 <ndm> inv: no
14:33:45 <eivuokko> dcoutts, Re Cabal pkg-config; How does pkg-config work in Windows?  The .pc files are simple foo=bar configs?
14:33:47 <inv> :(
14:33:54 <ndm> although Yhc got hat support a few days ago, so its almost there :)
14:34:01 <dcoutts> eivuokko, pretty much, yes.
14:34:06 <ihope> There be many Haskell debuggers.
14:34:16 <dcoutts> eivuokko, so it works on windows exactly the same as on unix
14:34:27 <inv> ihope: that is best of them ?
14:34:33 <eivuokko> dcoutts, Cool.  I want that in Cabal, then :)  Thanks.  I didn't know how it works in unix either :)
14:34:41 <dcoutts> eivuokko, you run "pkg-config --cflags foobar" and it outputs the flags.
14:34:56 <jethr0> as far as i can see the worst that people can do is create an infinite loop. not sure whether that's actually captured. and no, i don't want to know either
14:34:57 <eivuokko> dcoutts, It makes it easier to specify libs to Cabal in Windows as well.
14:35:12 <eivuokko> dcoutts, (imo)
14:35:15 <norpan> > ); take _ _ = ("\n\n\n\n\n\nlambdabot flood"
14:35:19 <dcoutts> eivuokko, right, but only for C libs that use pkg-config, which is mostly the unixy ones
14:35:36 <eivuokko> dcoutts, But I can write that for any lib I want...or generate it...
14:35:51 <ndm> inv, see Hat, thats one of the best
14:35:55 <inv> ok, thx
14:35:58 <ndm> the others are Hood and Buddah
14:36:02 <dcoutts> eivuokko, true, though the .pc file has to be in a dir where pkg-config will look for it
14:36:03 * resiak tries to figure out why his own lambdabot appears not to be affected by this.
14:36:21 <sjanssen_> resiak: recent change in lambdabot
14:36:26 <resiak> ah, okay.
14:36:34 <jethr0> resiak: i've got an older version too and there doesn't seem to be parens in it.?
14:36:35 <isaacd> > ); take _ _ = (cycle "1"
14:36:39 <inv> no windows version :(
14:36:40 <int-e> resiak: something similar is likely to work, I suppose.
14:36:41 <eivuokko> dcoutts, Well, I am fed up configuring my own directx9 package and have to specify dir each time.. ;)
14:36:45 <jethr0> isaacd: NOT A GOOD IDEA
14:36:47 <sjanssen_> resiak: this should work: > (); take _ _ = "broken"
14:36:59 <int-e> resiak: look at scripts/RunPlugs.hs
14:37:02 <ihope> > (); take _ _ = "broken"
14:37:07 <resiak> Right, looking at that now.
14:37:27 <norpan> there
14:37:27 <isaacd> finally!
14:37:28 <ndm> inv: nope, but give me about a week and i hope to have one
14:37:29 <hyrax42> did you guys break lambdabot?
14:37:32 <jethr0> @seen cale
14:37:34 <hyrax42> > 1 + 2
14:37:41 <ndm> and integrated windows debugging from something similar to winhugs
14:37:50 <ihope> hyrax42: no, isaacd did ;-)
14:37:56 <lambdabot> cale is in #haskell. I don't know when cale last spoke.
14:37:58 <Cale> I'm here
14:38:02 <lambdabot> 3
14:38:05 <isaacd> ihope: I did?
14:38:05 <resiak> int-e: You can hide your identity with it: you could make lambdabot say arbitrary stuff in channels with you hiding in a /msg, no?
14:38:09 <jethr0> cale, wanna kill lambdabot?
14:38:13 <ihope> Well... mmh.
14:38:15 <Cale> why?
14:38:23 <Cale> I suppose I could.
14:38:23 <int-e> resiak: no, because it sends its reply to where the request came from
14:38:24 <ihope> resiak: no.
14:38:25 <jethr0> have you been following the channel?
14:38:34 <Cale> yeah -- can it do arbitrary IO?
14:38:38 <jethr0> i think lambdabot it open to infinite loops right now
14:38:43 <jethr0> Cale: i don't think so
14:38:44 <resiak> ihope, int-e: Weren't people using \n to get around that, though?
14:38:50 <Cale> It's always been open to infinite loops
14:38:51 <ihope> resiak: that doesn't work.
14:38:54 <jethr0> it's inside the limited environment of unsafeEval
14:38:56 <sjanssen_> @bot
14:38:56 <int-e> resiak: they tried but that doesn't work
14:38:56 <lambdabot> :)
14:39:03 <resiak> Ah, okay.
14:39:10 <Cale> > error (cycle '!')
14:39:11 <lambdabot> Couldn't match `[Char]' against `Char'
14:39:16 <int-e> resiak: if they knew the bot better they wouldn't have tried :P
14:39:18 <Cale> > error (cycle "!") :: Int
14:39:21 <jethr0> Cale: but it can do IRC commands
14:39:25 <ihope> What you need is "\r\nPRIVMSG #haskell :foobar", not "\n/msg #haskell foobar".
14:39:36 <jethr0> > ); take _ _ = error ("hello world"
14:39:39 <int-e> jethr0: CTCP only. That's bad enough, granted.
14:39:53 <Cale> jethr0: if so, then you can kill it :)
14:40:03 <jethr0> Cale: how?
14:40:14 <shapr> What's up with lambdabot?
14:40:16 <int-e> ihope: but that doesn't work because the code that runs RunPlugs splits the output on newlines and processes the lines individually
14:40:21 <ihope> "foo\r\nQUIT"
14:40:28 <jethr0> Cale: can it send itself quit messages?
14:40:40 <shapr> Ah, I see.
14:40:41 <Cale> It's just quit
14:40:43 <jethr0> shapr: kinda exploitable
14:40:51 <shapr> I got a DCC command from it.
14:41:05 <Cale> heh
14:41:06 <jethr0> shapr: no, you got the setup of an dcc command via ctcp
14:41:29 <int-e> shapr: DCC is just a special CTCP and thus a privmsg - if you can freely choose the text sent in the privmsg, and we could ...
14:41:39 <shapr> Yeah, I know.
14:41:45 <shapr> Just wondering why I got that.
14:41:48 <jethr0> int-e: from what i read dcc is separate from ctcp
14:41:54 <Pseudonym> Check the logs, shapr.
14:42:02 <ihope> CTCP is used to start DCC, but DCC doesn't operate completely via CTCP.
14:42:04 <shapr> I did write part of lambdabot :-)
14:42:06 <Pseudonym> Lots of stupid lambdabot tricks.
14:42:16 <jethr0> shapr: norpan sent it
14:42:18 <shapr> Though Pseudonym is the actual author of lambdabot.
14:42:30 <shapr> g'day Pseudonym 
14:42:31 <Pseudonym> Very little of my code is in there.
14:42:32 <Pseudonym> G'day.
14:42:51 <Pseudonym> These days, I can only really take credit for the idea.
14:42:54 <ihope> > ); take _ _ = ("foo\r\nPRIVMSG #haskell :bar"
14:42:57 <Pseudonym> ?fact Pseudonym
14:43:04 <ihope> Um...
14:43:12 <ihope> Well, that wouldn't work anyway.
14:43:29 <Pseudonym> > ); take _ _ = ("hello world"
14:43:35 <jethr0> this worked: > ); take _ _ = ("\1PRIVMSG #esoteric Testing...\1"
14:43:40 <Pseudonym> Right.
14:43:47 <isaacd> lambdabot is not present
14:44:03 <ihope> jethr0: that was a CTCP PRIVMSG, which doesn't actually do anything.
14:44:13 <jethr0> i know
14:44:20 <jethr0> just saying
14:44:54 * jethr0 wonders if it is possible to use backspace
14:45:10 <ihope> Probably not.
14:45:31 <int-e> You mean this: ?
14:45:37 <ihope> Yeah, that.
14:45:59 <ihope> Anybody know if ChatZilla can do stuff like that?
14:46:02 <int-e> you can use that. it won't erase anything though.
14:47:21 <jethr0> k, gotta go. don't you guys break our beloved Emily.
14:47:39 <ihope> @vixen What is your name, Jane?
14:47:47 <ihope> Um.
14:48:21 <lambdabot> My name is Emily
14:48:32 <int-e> @version
14:48:35 <psnl> lambdabot: @name
14:48:40 <lambdabot> fixed version
14:48:47 <mauke> > 2+2
14:48:53 <lambdabot> 4.0000001
14:49:04 <mauke> excellent
14:49:09 <Pseudonym> Ah, Pentuim 1, I see.
14:49:14 <ihope> > error "bleh"
14:49:24 <Pseudonym> > let ones = 1 : ones in ones
14:49:33 <lambdabot>  Add a type signature
14:49:40 <inv2004> ups
14:49:52 <inv2004> data Pars a = Ok a (Pars a) | No
14:49:57 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:49:58 <inv2004> 20: x|x `elem` "1234567890" -> Ok x (p_and t s i)
14:50:02 <lambdabot> [6 @more lines]
14:50:06 <ihope> @more
14:50:11 <inv2004> x|x `elem` "1234567890" -> Ok x (p_and t s i)
14:50:18 <inv2004> Couldn't match the rigid variable `a' against `Char'
14:50:18 <inv2004>   `a' is bound by the type signature for `c'
14:50:18 <inv2004>   Expected type: a
14:50:21 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
14:50:41 <ihope> @djinn-add data List a b = (a -> b -> b) -> b -> b
14:50:54 <ihope> @djinn a -> List a b -> List a b
14:51:06 <lambdabot> Cannot parse command
14:51:07 <lambdabot> Cannot parse command
14:51:12 <inv2004> don't understand
14:51:14 <mauke> f xy = y
14:51:27 <mauke> er, f x y = y
14:51:50 <inv2004> Pars a, why a can't be Char ?
14:52:23 <Pseudonym> > let n = 74037563479561712828046796097429573142593188889231289084936232638972765034028266276891996419625117843995894330502127585370118968098286733173273108930900552505116877063299072396380786710086096962537934650563796359 in [ f | f <- [2..n `div`2], n `mod` f == 0 ]
14:52:59 <lambdabot> Terminated
14:56:20 <ihope> > fix (\x -> if isUndefined x then () else undefined)
14:56:32 <shapr> inv2004: "foo = Ok 'a' (No) :: Pars Char" doesn't work?
14:56:52 <lambdabot> Not in scope: `isUndefined'
14:57:00 <ihope> Aww.
14:58:01 <inv2004> shapr: it works, but No instance for (Show (Pars Char))
14:58:10 <ihope> > getUser "lambdabot" >>= isImposter >>= print
14:58:23 <inv2004> sorry for my foolish, first day in haskell
14:58:32 <lambdabot> Not in scope: `isImposter'
14:58:44 <ihope> inv: data Pars a = ... deriving Show
14:58:51 <ihope> Something like that.
14:59:03 <ihope> @hoogle isImposter
14:59:20 <lambdabot> No matches found
14:59:20 <inv2004> have added: instance Show (Pars a) where
14:59:21 <inv2004>   show (Ok v n) = "Ok (" ++ show v ++ ") ->\n " ++ (show n)
14:59:21 <inv2004>   show No = "No"
14:59:59 <inv2004> but
15:00:00 <inv2004> Could not deduce (Show a) from the context (Show (Pars a))
15:00:00 <inv2004>   arising from use of `show' at D:/h_pars/parser.hs:9:29-32
15:00:00 <inv2004> Probable fix: add (Show a) to the class or instance method `show'
15:00:14 <isaacd> error (repeat 'x') is evil
15:00:18 <ihope> instance Show a => Show (Pars a) where ...
15:00:19 <isaacd> but... let evil = error evil in evil
15:00:46 <inv2004> how can I add show for undefined type ?!?
15:00:49 <ihope> isaacd: error (fix error)?
15:01:00 <isaacd> ihope: yep
15:01:10 <ihope> inv2004: as I said, it's instance Show a => Show (Pars a) where
15:01:13 <ihope> Does that work?
15:02:18 <int-e> Pseudonym: Oh, that's an interesting attempt at earning $30k quickly ;)
15:02:45 <isaacd> ihope: or just (fix error) ^_^
15:03:04 <ihope> isaacd: that's a String, while error (fix error) is a
15:03:34 <inv2004> Show (Pars a) where ? parse error on input `where'
15:03:52 <ihope> Um.
15:04:14 <isaacd> ihope: ok.
15:04:24 <inv2004> ups
15:04:29 <inv2004> ihope: thx, it work!
15:04:52 <shapr> Hm javascript 2 is on the way.
15:04:53 <inv2004> will learn what is instance Show a => Show (Pars a) leter :)
15:04:59 <ihope> :-)
15:05:04 <shapr> They've added optional static typing.
15:05:17 <inv2004> shapr: in javascript ?
15:05:19 <shapr> yup
15:05:22 <ihope> It means "for every a in Show, there's a Pars a in Show such that..."
15:05:37 <shapr> For details see - http://developer.mozilla.org/presentations/xtech2006/javascript/
15:05:57 <isaacd> To safely handle such things an implementation would have to only take a limited number of characters from an error, for a limited number of recursions of the error message itself being in error
15:06:13 <isaacd> (where safe = no infinite loop)
15:06:34 <isaacd> and that's not really true with multiple threads I suppose?
15:08:05 <inv> x|x `elem` "1234567890" -> Ok x (p_and t s (i+1)) - Couldn't match the rigid variable `a' against `Char'
15:08:05 <inv>   `a' is bound by the type signature for `c'
15:08:18 <inv> Expected type: a
15:08:19 <inv> Inferred type: Char
15:15:41 <Cale> inv: you gave a more general type to the function than your condition allows
15:16:01 <Cale> inv: delete the type signature and check out what ghci infers.
15:18:09 <inv> Not in scope: type constructor or class `Pars'
15:18:51 <inv> ow
15:18:52 <inv> hm
15:18:56 <inv> work
15:19:29 <inv> but if I define main::Pars a -> error
15:22:55 <inv> so now I can't define main as Pars a ? should redefine to main::Pars Char , then main::Pars String ... ?
15:22:57 * lambdabot 's service don't seem to be needed any more
15:23:00 <lambdabot> QUIT
15:23:24 <ricebowl> is there a convenient example somewhere of writing a custom show?
15:23:45 <ndm> ricebowl: its easy to write a custom show :)
15:23:55 <ndm> give us your example, and it can be shown easily
15:23:57 <petekaz> Does lambdabot normally request /etc/passwd via DCC?
15:24:08 <inv> bb all
15:24:11 <ndm> data MyNewData = MyNewData Int Bool
15:24:14 <mauke> yes, it does that all the time
15:24:18 <ndm> instance show MyNewData where
15:24:29 <ndm>     show (MyNewData a b) = "Hello :)"
15:24:42 <resiak> isaacd: Was that you?
15:25:01 <isaacd> resiak: what?
15:25:26 <resiak> isaacd: disposing of lambdabot?
15:25:58 <mauke> haha
15:26:00 <isaacd> resiak: not intentionally, and it definitely wasn't me the second and final time
15:26:15 <ricebowl> ndm - I have a datatype called MaybeBit
15:26:19 <mauke> -!- lambdabot [i=foobar@p54A37E83.dip.t-dialin.net]  -!-  was      : jethr0
15:26:29 <ricebowl> data MaybeBit = UNKNOWN | FALSE | TRUE
15:26:33 <isaacd> (the second time, assuming it was the infinite lists that did it, I believe Cale sent it one or two)
15:26:55 <ricebowl> actually I guess if I had made it that simple, I wouldn't be asking about a show method.
15:27:06 <ricebowl> well, it's newtype MaybeBit = MaybeBit (Bool, Bool)
15:27:11 <ricebowl> but those are the 3 values which are legal
15:27:18 <ricebowl> and I want to transform it into either '0', '1', or '?'
15:27:35 <ricebowl> the method is written, but I forgot the syntax to make it an instance of Show
15:27:40 <ndm> ricebowl: like this
15:27:40 <ricebowl> so right now it's just deriving(Show, Eq)
15:27:41 <ndm> instance Show MaybeBit where
15:27:43 <ndm>    show (MaybeBit (True, False)) = "?"
15:27:44 <ndm>    show (MaybeBit (True, True)) = "1"
15:27:48 <ricebowl> ah ok, thanks
15:27:51 <ndm> and delete the deriving Show
15:27:54 <ricebowl> right
15:29:17 <resiak> Ah, fair enough.
15:33:15 <ricebowl> @pl foo f (a, b) = (f a, f b)
15:35:09 <isaacd> ok, I guess I've successfully registered (to freenode) now...
15:37:15 <dcoutts> @localtime dons
15:37:30 <dcoutts> no lambabot!
15:37:39 <ski> * lambdabot has quit ("leaving")
15:38:02 <dcoutts> methinks people have been abusing poor lambdabot
15:38:08 <isaacd> bye
15:40:18 <Cale> @pl foo f (a, b) = (f a, f b)
15:40:19 <mbot> foo = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:41:20 <Cale> > join (***) (+1) (5,6)
15:41:21 <mbot> (6,7)
15:41:33 <Cale> foo = join (***)
15:42:34 <Cale> @type join (***)
15:42:35 <mbot> forall (a :: * -> * -> *) b c.
15:42:36 <mbot>      (Arrow a) =>
15:42:36 <mbot>      a b c -> a (b, b) (c, c)
15:43:46 <norpan> it's late
15:45:49 <mauke> @pl \f (x, y) -> ap ((,) . flip id x) (flip id y) f
15:45:51 <mbot> (`ap` snd) . (. fst) . flip (flip . (. flip id) . ap . ((,) .) . flip id)
15:47:00 <morans> dcoutts: oops, hope it wasn't me that broke lambdabot
15:49:14 <Cale> lambdabot ought to be down for the time being -- recent changes have caused it to be somewhat exploitable
15:50:01 <dcoutts> methinks people have been abusing poor lambdabot
15:50:05 <dcoutts> ooop
15:50:29 <dcoutts> wrong window
15:57:19 <bolrod> :o?
16:06:59 <dons> moin
16:08:05 <Beelsebob> moin moin
16:08:47 <dons> oh, Cale, what do you mean "ought to be down for the time being" ?
16:09:15 <int-e> > ); take _ _ = ("Hello, dons"
16:09:16 <mbot>  parse error on input `)'
16:09:16 <lambdabot> Hello, dons
16:09:31 <int-e> this.
16:09:36 <mauke> what was the quine?
16:09:53 <dons> oh, is that the result of the new parens thingy I introduced
16:10:06 <dons> yeah, seems so.
16:10:10 <int-e> > ); take _ _ = ap (++) show ("> ); take _ _ = ap (++) show "
16:10:10 <lambdabot> > ); take _ _ = ap (++) show "> ); take _ _ = ap (++) show "
16:10:11 <mbot>  parse error on input `)'
16:10:11 <mbot>  parse error on input `)'
16:10:18 <int-e> that was the quine.
16:10:19 <mauke> we need mutual recursion
16:10:29 <dcoutts> morning dons!
16:10:48 <mauke> hmm, no. mbot inserts a leading space
16:10:52 <dons> > ); take _ _ = ("Hello, dons"
16:10:52 <lambdabot>  parse error on input `)'
16:10:52 <mbot>  parse error on input `)'
16:11:05 <dons> fixed
16:12:07 * dcoutts records more patches to send to dons 
16:12:15 <dons> mbot: @part
16:12:25 <dons> mbot, @part
16:12:35 <mauke> @party hard
16:12:35 <lambdabot> Not enough privileges
16:12:35 <mbot> Not enough privileges
16:12:46 <int-e> > (); take _ _ = "Hello, dons!" -- I think you should use qualified ids for take and show there.
16:12:47 <lambdabot> Hello, dons!
16:12:48 <mbot> Hello, dons!
16:12:59 <mauke> loop!
16:13:00 <dons> int-e, yse . that's a good idea.
16:14:10 <Beelsebob> hmm
16:15:04 <Beelsebob> > (); take x y = "(" ++ show x ++ " , " ++ show y ++ ")"
16:15:05 <lambdabot> (2048 , "()")
16:15:06 <mbot> (2048 , "()")
16:15:17 <Beelsebob> bah
16:15:37 <Beelsebob> was going for infinite recursion then if I could get a rewrite into it
16:16:11 <mauke> shouldn't take _ _ = ap (++) show ("> ); take _ _ = ap (++) show " work?
16:16:42 <Beelsebob> why?
16:17:09 <int-e> mauke: no, you have to finish the first let binding first. (and please don't try quines as long as both mbot and lambdabot do this stuff)
16:17:25 <dons> mbot, @part #haskell
16:17:44 <stepcut> dons!
16:18:35 <stepcut> dons: have you tried using parsec with fps at all ?
16:18:44 <ihope_> > ); dummy = (
16:18:45 <lambdabot>  parse error on input `)'
16:18:49 <ihope_> :-)
16:21:59 <dons> stepcut: nope.
16:22:18 <Beelsebob> > ("> (); take _ _ = \"hello world"); take x y = filter (/= '\\') $ tail y
16:22:19 <lambdabot> > (); take _ _ = "hello world"
16:22:22 <jethr0> hi dons
16:22:32 <jethr0> lambdabot fixed already?
16:22:33 <Beelsebob> oh... mbot left
16:22:35 <Beelsebob> damn
16:22:42 <jethr0> nm
16:22:43 <Beelsebob> *g*
16:23:19 <jethr0> do any of you have an idea what the SoC project Language.C encompasses? is that supposed to parse to the haskell AST or to its own
16:23:21 <dcoutts> dons, isn't using parsec with fps part of sjanssen's SoC project?
16:23:29 <jethr0> and is it supposed to be compiled to haskell?
16:24:07 <dons> were people playing funny games with lambdabot before?
16:24:13 <dons> dcoutts: yeah.
16:24:22 <dcoutts> dons, they were indeed
16:24:22 <Beelsebob> yep
16:24:27 <jethr0> dons: YES
16:24:32 <dcoutts> abuse!
16:24:41 <jethr0> code injection using the surrounding parens
16:24:43 <int-e> it all started as fun :)
16:24:47 <stepcut> like this -> *** DCC: unknown dcc command `DCC send /etc/passwd' from (n=lambdabo@shodan.cse.unsw.EDU.AU)
16:24:47 <Beelsebob> if you do something like > ("> (); take _ _ = \"hello world"); take x y = filter (/= '\\') $ tail y, but using omega instead of printing hello world, you're buggered
16:24:52 <dons> right. i've fixed the parens issue.
16:24:54 <jethr0> a la "); take _ _ = (sth"
16:24:57 <dons> but was that just it.
16:24:58 <jethr0> k
16:25:15 <Beelsebob> > ("> (); take _ _ = \"hello world"); take x y = filter (/= '\\') $ tail y
16:25:16 <lambdabot> > (); take _ _ = "hello world"
16:25:21 <Beelsebob> no you haven't
16:25:42 <int-e> > )==(
16:25:43 <lambdabot>  parse error on input `)'
16:25:49 <int-e> this gave 'True' before :)
16:25:51 <mauke> > (); take _ _ = "is this fixed?"
16:25:52 <lambdabot> is this fixed?
16:25:58 <dons> ah, ok.
16:26:22 <dons> qualified ids then. mbot will suffer the same issue too.
16:26:28 <int-e> it does.
16:26:43 <jethr0> couldn't you do "take 2048 ... where ''x'' = ..."?
16:26:55 <int-e> jethr0: same problem
16:27:00 <jethr0> right
16:27:17 * dcoutts darcs sends yet more fps patches to dons 
16:27:20 <int-e> jethr0: but qualified ids should fix it (Prelude.take, Prelude.show)
16:27:29 <jethr0> hmm
16:27:32 <dons> yeah, fixing..
16:27:38 <Joplin> what happens if you feed Lambdabot a really long computation?
16:27:44 <int-e> > let take _ _ = 42 in Prelude.take 2 [1,2..]
16:27:45 <lambdabot> [1,2]
16:27:49 <dons> > last [1..]
16:27:53 <lambdabot> Terminated
16:28:04 <Joplin> ahh
16:28:30 <morans> Joplin: that's the second thing everyone tries!
16:28:35 <morans> Joplin: right after 1/0
16:28:37 <jethr0> > (); take _ _ = "is this fixed?"
16:28:38 <lambdabot> is this fixed?
16:29:09 <int-e> jethr0: heh, be patient. I believe dons is working on that.
16:29:18 <morans> Joplin: at least in the places I put it...
16:29:27 <jethr0> nono, i'm just thinking
16:29:55 <jethr0> qualified id's will only patch the problem. but the real culprit is that code injection is at all possible
16:30:06 <jethr0> and i'm pondering if it's possible to avoid at all
16:30:17 <dons> > (); take _ _ = "is this fixed?"
16:30:17 <lambdabot>  parse error on input `;'
16:30:28 <dons> try the other options.
16:31:14 <int-e> what did you do?
16:31:15 <mauke> > v; v = 2
16:31:15 <lambdabot>  parse error on input `;'
16:31:16 <int-e> > 1==1
16:31:17 <lambdabot>  Not in scope: `=='
16:31:21 <mauke> FAIL
16:31:39 <Beelsebob> lol
16:31:43 <int-e> > 1 Prelude.== 2
16:31:43 <lambdabot>  Not in scope: `Prelude.=='
16:31:49 <int-e> wee.
16:32:03 <dons> > 1 == 1
16:32:04 <lambdabot>  Not in scope: `=='
16:32:07 <dons> hmm
16:32:10 <dons> ok. that's a funny one.
16:32:14 <jethr0> even worse would be redefining (++)
16:32:17 <mauke> > Prelude.take
16:32:18 <lambdabot>  Not in scope: `Prelude.take'
16:32:29 <jethr0> P.take
16:33:18 <\ourselves> Should I stop spamming nick changes? :-)
16:35:13 <jethr0> > 5)} in let {x = (5
16:35:14 <dons> > 1 == 1
16:35:14 <lambdabot> 5
16:35:15 <lambdabot> True
16:35:22 <dons> sigh
16:35:34 <dons> you guys have nothing better to do, I guess.
16:35:54 <dons> ok. i'm having breakfast. i'll fix it later
16:36:00 <jethr0> i don't want to annoy you. but we're just making certain that NOONE can exploit lambdabot in the long run :)
16:36:37 <dons> hmm, i think you were just trying to annoying people, if  I look at the logs.
16:37:00 <jethr0> *cough*
16:37:08 <int-e> > )} in "Foobar"; xyzzy = let { guess_the_right_id=(2
16:37:50 <jethr0> that's not a valid expression. you closed the outer "let" with the brace. what's the semicolon supposed to do?
16:38:19 <jethr0> dons: i was just mesmerized...
16:39:04 <dons> i notice no one sends patches though.
16:39:10 * dons gets some coffee
16:40:04 * jethr0 thinks there should be an expression parser in Language.Haskell.Parser
16:40:40 <jethr0> that would make many things a lot easiert (pretty printing, verifying valid code, ...)
16:41:01 <dcoutts> dons, I've been sending other patches :-)
16:45:57 <jethr0> do any of you have an idea what the SoC project Language.C encompasses? is that supposed to parse to the haskell AST or to its own
16:47:16 <dcoutts> jethr0, I don't see what you mean
16:48:01 <dcoutts> it'll parse to some AST
16:48:31 <dcoutts> what's "the haskell AST" in this context?
16:50:28 <hyrax42> @hoogle time
16:50:37 <jethr0> Language.Haskell.Syntax
16:50:39 <mauke> @hammer time
16:51:00 <int-e> jethr0: you can't easily (that is, without parsing the stuff yourself) prevent that sort of code injection, due to the way that lambdabot and hs-plugins work. you can limit it by forbidding } and { on the input and you can make sure that nothing really nasty happens when people do it.
16:51:08 <jethr0> i was just wondering whether there was some kind of plan for Language.*; i.e. freely converting between the languages' ASTs
16:51:40 <dcoutts> jethr0, you can't freely convert between different language's ASTs
16:51:43 <jethr0> int-e: if you did expression parsing on the input, many injections with non-paired parens/braces would be impossible
16:51:58 <dcoutts> the ASTs are different because the languages are different
16:51:59 <hyrax42> @bot
16:52:06 <hyrax42> :(
16:52:14 <jethr0> dcoutts: obviously. but it would be nice to convert between similar languages. just an idea albeit a stupid one
16:52:20 <dcoutts> jethr0, translating between them is compilation, and is non-trivial
16:52:29 <jethr0> i know
16:57:45 <dons> yeah, I was thinking we just parse the input, to make sure its valid. i'll play aroudn with some options
16:57:49 <dons> dcoutts: great!
16:58:57 <dons> dcoutts: you sent all the code in the last bundle?
16:59:16 <dcoutts> dons, no, because I sent half of it eariler
16:59:24 <dons> ok.
16:59:25 <dcoutts> so two non-verlapping bundles I think
16:59:42 <dcoutts> I can send as one bundle if you prefer
16:59:46 <dons> no, its fine.
17:00:02 <dcoutts> the first one is more interesting
17:00:33 <dcoutts> but the second contains a bit that was missing from the first :-)
17:00:43 <jethr0> so, i guess semantics will be checked too, control flow, ...?
17:02:53 <dons> dcoutts: oh, I see properties!
17:02:57 <dons> good stuff.
17:03:17 <dcoutts> dons, so the list/array fusion seems to be ok
17:03:43 <dcoutts> it was deceptively easy
17:03:51 <dons> and you've checked the rules are firing?
17:03:59 <dcoutts> yep
17:04:04 <dons> excellent
17:04:05 <dcoutts> using fuse.hs
17:04:13 <dcoutts> just changed the import for .Lazy
17:04:28 <dcoutts> and same number of loop/loop fusion rules fired
17:04:48 <dons> what about performance, does generalising the type change anything?
17:04:49 <dcoutts> (after adding a missing INLINE [n] annotation)
17:04:54 <dons> do we need a SPECIALIZE?
17:05:00 <dons> (on loopU)
17:05:12 <dcoutts> dons, well we're only generalising the type for the trivial access functions
17:05:25 <dcoutts> loopArr, loopAcc etc
17:05:33 <dons> ah, ok.
17:05:38 <dons> and what fusion test did you use?
17:05:43 <dcoutts> they're just pair projections
17:05:47 <dons> did you write a new one for lazy bytestrigns?
17:06:03 <dcoutts> no, I just hacked tests/fuse.hs
17:06:10 <dons> ok
17:06:33 <dcoutts> import Data.ByteString/import Data.ByteString.Lazy
17:06:36 <dcoutts> and that was it
17:06:38 <dons> really nice!
17:06:40 * dons applies
17:06:46 <dcoutts> :-)
17:07:27 <dcoutts> sjanssen, what a good moment to drop by, we're just reviewing some fps fusion stuff
17:08:51 <sjanssen> dcoutts: fusion for .Lazy?
17:08:57 <dcoutts> sjanssen, yep
17:09:43 <ricebowl> @type Arrow.second
17:09:44 <lambdabot> Couldn't find qualified module.
17:09:45 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
17:09:45 <dons> sjanssen: we should put up a work plan on a wiki for your project. 
17:10:02 <dons> @hoogle second
17:10:03 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
17:11:43 <jethr0> > 4
17:11:44 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
17:12:20 <jethr0> huh?
17:18:27 <dcoutts> dons, I've partitioned loopU into a wrapper and a body
17:18:43 <dcoutts> loopU f = loopWrapper . doUpLoop f
17:19:05 <dons> ok. good.
17:19:11 <dons> now, do the rules fire? 
17:19:12 <dcoutts> dons, then the idea is we could do more than one loop inside a single wrapper
17:19:21 <dcoutts> I've not got that far yet
17:19:24 <dons> yep. its a good idea.
17:19:32 <dons> avoidign that (potential) memcpy is useful
17:19:59 <dcoutts> the RULE would probably be something like:
17:20:02 <dcoutts> loopWrapper doLoop2 (loopArr (loopWrapper doLoop1 arr)) =
17:20:02 <dcoutts>   loopWrapper (\p -> doLoop1 p >> doLoop2 p) arr
17:20:27 <dcoutts> forall doLoop2 doLoop1 arr
17:20:55 <dons> cool. wrapper elimination.
17:21:00 <dcoutts> so that'd allow any direction of loop to go in
17:21:18 <dcoutts> but we'd want to make sure that rule onlyfired after proper loop/loop fusion
17:21:32 <dcoutts> since that's obviously better
17:21:53 <dons> right. that'll be tricky to enforce. maybe we can convince it to happen in stage 2
17:22:03 <dcoutts> right
17:22:29 <dcoutts> but fiddling with the phase control
17:22:32 <dcoutts> but/by
17:22:39 <dons> yep
17:26:03 * lispy plays with phase control to set his phasor to stun ;)
17:27:11 <dons> dcoutts: ah, I see. avoid doing list fusion, and provide a [ByteString] loopU. yes, it all makes sense
17:27:28 <dcoutts> good :-)
17:31:00 <dcoutts> dons, ok so if we have:
17:31:01 <dcoutts> type Loop acc = Ptr Word8 -> Ptr Word8 -> Int -> IO (acc, Int)
17:31:42 <dcoutts> the Int input is 'i' the size of the array
17:31:58 <dcoutts> and the Int result is the new size, eg if there was filtering
17:32:12 <dcoutts> so would this make sense?
17:32:13 <dcoutts> combineLoops :: Loop acc -> Loop acc' -> Loop acc'
17:32:13 <dcoutts> combineLoops loop1 loop2 p1 p2 i = do
17:32:13 <dcoutts>   (_, i') <- loop1 p1 p2 i
17:32:13 <dcoutts>   loop2 p1 p2 i'
17:32:44 <dcoutts> dons, ie we're throwing away the value of the acc from the first loop
17:32:54 <dons> right. so for a map or filter.
17:33:26 <dcoutts> but it's ok to throw away the acc because we're only using it in this case:
17:33:26 <dcoutts> loopWrapper doLoop2 (loopArr (loopWrapper doLoop1 arr))
17:33:42 <dcoutts> loopWrapper (combineLoops doLoop1 doLoop2) arr
17:33:58 <dcoutts> so one should be transformed to the other
17:34:25 <dcoutts> ie were using loopArr, so we're already throwing away the acc from the first loop
17:34:45 <dons> ah, yes. ok.
17:34:56 <dons> be very careful :) you can break all your user's code with a rule.
17:35:02 <dcoutts> :-)
17:35:16 <dcoutts> QC will be my friend I hope
17:36:44 <dons> that reminds me, yes, we should QC any rules, since they're equivalences.
17:37:23 <dons> so if you add a rule: f x = g x, then also add a QC property to check that.
17:37:24 <dcoutts> so the RULE typechecks at least :-)
17:37:25 <dcoutts> {-# RULES
17:37:26 <dcoutts> "loop/loop wrapper elimination" forall loop1 loop2 arr.
17:37:26 <dcoutts>   loopWrapper loop2 (loopArr (loopWrapper loop1 arr)) =
17:37:26 <dcoutts>     loopWrapper (combineLoops loop1 loop2) arr
17:37:26 <dcoutts>   #-}
17:38:01 <dons> ok. good
17:38:09 * dons gets more coffee
17:39:09 <Igloo> Can you write a script to generate QCRules.hs from the sources?
17:39:11 <sjanssen> dons: yeah, wiki sounds like a good idea
17:39:58 <sjanssen> dons: I also enjoy the new eval ;-)
17:40:19 <sjanssen> > ); take _ _ = "@keal"
17:40:19 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
17:40:41 * dcoutts doesn't understand how that hack works
17:40:57 <Igloo> dons, dcoutts: You also need to make sure the rules don't get applied to the QC code
17:41:08 <dcoutts> Igloo, hah, good point
17:41:14 <Beelsebob> > ); take _ _ = "); take _ _ = \"@keal\""
17:41:14 <lambdabot> i can explain why something is without knowing what the rules decided by man are
17:41:16 <dcoutts> compile without -O I guess
17:41:41 <int-e> dcoutts: RunPlugs creates Haskell code; the code of the eval is wrapped in some let: let { foo = ( <code here> ) } in take 2048 (show foo)
17:42:09 <int-e> dcoutts: at least that's how it was when that hack worked.
17:42:20 <Beelsebob> > ); take x y = show x ++ ", " ++ show y
17:42:21 <lambdabot> perhaps i just genius and never tested
17:42:31 <dcoutts> ah, so you're closing and reopening the brackets
17:42:35 <dons> Igloo: good piont :)
17:42:59 <sjanssen> dons: eval should be easy to fix, just qualify all the functions that could be polluted
17:43:11 <dons> yep. and remove the ( ) option
17:43:15 <dons> just testing it now
17:43:53 <sjanssen> the real hacks had nothing to do with parens though
17:43:59 <dons> yep.
17:44:04 <int-e> sjanssen: right.
17:44:05 <dons> also, i will pad all the output with a leading space
17:44:27 <dons> so any string you might produce can't be used as an irc command
17:44:43 <int-e> CTCP. yeah, that sounds good.
17:44:50 <dons> ctcp, sorry.
17:45:03 <dons> that's all it was in the end. string literals being shown
17:49:22 <jethr0> people, the "take" injection doesn't work anymore because it's P.take now!
17:49:57 <dons> yep
17:51:54 <int-e> I can think of one more exploit of that sort, but that requires correctly guessing the random three-letter id used in the code.
17:51:59 * Igloo is confused as to why the above work when they close one paren but don't open any
17:52:18 <jethr0> yes, that's weird
17:52:54 <int-e> Igloo: the ones that worked had an opening parenthesis somewhere
17:53:37 <int-e> actually > ); take _ _ = "foo" -- would have worked, too.
17:53:43 <int-e> (note the --)
17:53:46 <dons> > ); take _ _ = "foo"
17:54:09 <lambdabot>  parse error on input `)'
17:55:03 <Igloo> Did   > ); take _ _ = "@keal"   not work?
17:55:04 <dons> > 1+1
17:55:05 <lambdabot>  2
17:55:35 <dcoutts> dons, woo!
17:55:35 <dcoutts>     15 loop/loop wrapper elimination
17:55:40 <dons> excellent!
17:55:53 <int-e> Igloo: it didn't.  > ); take _ _ = ("@keal"  would
17:56:03 <dcoutts> dons, that's when using the wrapper elimination rule and not the fusion rule
17:56:04 <dons> dcoutts, so only one realloc, that means?
17:56:18 <dcoutts> dons, right, should be
17:56:29 <dons> great!
17:56:52 <dcoutts> dons, of course that only helps in cases where we can't already fuse, since that does it in one pass and therefore one realloc
17:56:55 <jethr0> > show [| \x -> x + 3 |]
17:56:56 <lambdabot>  "\\x_0 -> x_0 GHC.Num.+ 3"
17:57:23 <dcoutts> dons, so this would be for combining alternating sequences of up and down loops
17:57:25 <dons> dcoutts: yep, so for any up/down loops.
17:57:29 <jethr0> > $([|\x_0 -> x_0 + 3|]) 4
17:57:31 <lambdabot>  7
17:58:34 <dcoutts> dons, I've got to go to bed now, I'll send you my code
17:58:38 <Igloo> int-e: It looks like it worked here, at :39?
17:58:58 <dons> dcoutts: ok. great.
17:59:09 <dcoutts> dons, I'll just send it as an ordinary patch, I don't want to record these changes since they're rather experimental
17:59:18 <dons> ok. i'll just review it.
17:59:23 <dcoutts> ta
17:59:31 <sjanssen> Igloo: dons temporarily made all ">" requests yield keal quotes instead of executing the code
17:59:34 <dcoutts> and/or improve it :-)
17:59:45 <dons> Igloo: yeah, like sjanssen says. :)
17:59:45 <Igloo> Ah
17:59:51 <dcoutts> hah
18:00:13 <Igloo> No fair changing the rules when I'm not looking  :-)
18:00:34 <Pseudonym> > keal
18:00:34 <lambdabot>  Not in scope: `keal'
18:00:43 <Pseudonym> Oh well.
18:00:49 <Igloo> @keal
18:00:49 <lambdabot> i want to invent white dye
18:06:41 <jethr0> > printf "%s %s\n" "Hello" "World"
18:06:42 <lambdabot>  Add a type signature
18:06:56 <jethr0> > printf "%d\n" (23::Int)
18:06:57 <lambdabot>  Add a type signature
18:07:04 <dons> result type.
18:07:13 <jethr0> > (printf "%d\n" (23::Int)) :: String
18:07:14 <lambdabot>  "23\n"
18:07:22 <jethr0> > (printf "%s %s\n" "Hello" "World") :: String
18:07:23 <lambdabot>  "Hello World\n"
18:07:36 <jethr0> nice :) not infinitely useful, but nice :)
18:07:45 <jethr0> dons: i love that you have added template haskell
18:08:25 <dons> yeah, dcoutts had some fun TH optimiser games, so we tried to think of a safe way to add it. 
18:08:35 <mauke> > v; v = 23
18:08:36 <lambdabot>  23
18:09:09 <dons> shrug. we'd have to parse the expression.
18:09:10 <jethr0> i think without the IO functions it's safe. because once the TH stuff is spliced in it get's compiled once more, this time inside the restricted environment
18:09:14 <dons> maybe i'll do that anyway.
18:09:42 <jethr0> dons: as i said earlier: it would be nice if language.haskell.parser could parse expressions in addition to modules...
18:09:53 <dons> it can, afaik.
18:10:08 <dons>  @hylo uses it
18:10:08 <jethr0> i didn't see it in the haddock doc
18:10:17 <jethr0> k, gotta look closer then
18:12:09 <jethr0> problem is that expression parsing and TH might clash :(
18:12:32 <jethr0> > --
18:12:32 <lambdabot>  parse error on input `}'
18:12:55 <dons> yeah, i'm not too woried about mauke's trick above
18:13:11 <jethr0> i agree
18:13:27 <dons> sinec we already have that slightly non-spec 'where' issue.
18:13:28 <mauke> I think it's a nice feature
18:13:36 <dons> :)
18:15:05 <Igloo> What were the TH problems?
18:15:34 <jethr0> i guess runIO mainly
18:16:04 <jethr0> imo reify isn't so critical
18:16:08 <Igloo> But that can just be not in scope, can't it?
18:16:15 <jethr0> it is
18:16:19 <jethr0> (not in scope)
18:16:37 <Igloo> Oh, so the problems were all solved?
18:18:11 <dons> there weren't problems, there were potential problems, if we didn't hide reify and runIO :)
18:18:30 <Igloo> OK, I just misunderstood then :-)
18:19:12 <jethr0> dons: although i'm not sure how runIO could be a problem without general IO running
18:19:54 <Igloo> Because $( runIO ... ) doesn't have an IO type
18:19:58 <dons> run it in the splice.
18:20:03 <dons> right.
18:20:35 <jethr0> hmm
18:20:53 <jethr0> right
18:24:10 <jethr0> k, time for bed. cu
18:25:55 <dcoutts> dons, sent. Now I'm off to bed.
18:25:59 <dcoutts> g'night folks
18:26:40 <dons> ok. thanks
18:26:59 <dcoutts> dons, oh, ignore the first bits of the patch, they're irrelevant
18:27:42 <dons> ok :)
18:38:30 <sjanssen> dons, dcoutts: try running this in ghci: let xs = Data.ByteString.Lazy.cons 0 xs in Data.ByteString.Lazy.take 10 
18:39:05 <sjanssen> the coalescing behavior of cons makes this return nothing
18:39:09 <dons> take 10 xs, I guess.
18:39:18 <dons> ah. well spotted
18:39:25 <dons> LPS ["\NUL","\NUL","\NUL","\NUL","\NUL","\NUL","\NUL","\NUL","\NUL","\NUL"]
18:39:25 <sjanssen> oh yeah, missed a bit
18:40:00 <dons> dcoutts: QuickCheck!
18:40:25 <dons> though I guess he did point out that creating a QC test for coalescing cons is tricky
18:40:39 <sjanssen> I think cons shouldn't coalesce
18:41:15 <sjanssen> dons: that's what your ghci actually returned?
18:41:16 <dons> I'll certainly disable it for now.
18:41:21 <dons> sjanssen: yep.
18:41:22 <dons> that 6.4.1
18:41:59 <dons> > let xs = 0: xs in take 10 xs
18:42:00 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
18:42:04 <dons> hmm...
18:42:21 <dons> oh, that's not runnign the coalescing code. sorry, let me try again
18:42:55 <dons> infinite loop?
18:43:04 <dons> damn strictness.
18:43:08 <sjanssen> exactly
18:43:44 <dons> i'm making a note and disabling. and adding a QC test.
18:44:03 <sjanssen> and even if xs was merely long, rather than infinite, we'd still get horrible performance
18:44:08 <dons> yep
21:05:52 <dons> hmm, does hugs have overlapping instances?
21:26:59 <dons> Cale, around?
21:27:17 <dons> I have a fun instances problem for you.
21:38:02 <mathewm> any HOC users here?
21:38:38 <dons> the objective C binding?
21:38:42 <mathewm> yup
21:38:43 <dons> @seen ozone
21:38:44 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
21:39:10 <dons> ozone's the author. but he's not been around recently.
21:39:35 <mathewm> I see
21:39:37 <mathewm> thanks
21:39:56 <mathewm> I was just wondering if anyone has had luck interfacing with applescript
21:41:04 <Cale> dons: what's that?
21:41:48 <dons> in fps, we do some model checking QuickChecks.
21:42:03 <dons> if you look here, you'll see: http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
21:42:13 <dons> the Model class, connects a type to the type it is modelled by
21:42:42 <dons> now, for structure types, I can connect them via: 
21:42:43 <dons> instance (Functor m, Model a b) => Model (m a) (m b) where abs = fmap abs
21:43:13 <Cale> okay
21:43:17 <dons> which works for, say, comparing a function on lists (Word8 -> [Word8])
21:43:17 <dons> against a function on bytestrings, (Word
21:43:21 <dons> 8 -> ByteString)
21:43:32 <dons> since they're both in (Word8 ->) Funcotr
21:43:42 <Cale> yep
21:43:50 <dons> however, I need an extra instance for : instance Model a b => Model (a,a) (b,b)  where abs (a,b) = (abs a, abs b)
21:44:31 <Cale> hmm, okay
21:44:49 <dons> now, what' I'd like is a Functor n, Functor m, n `goesTo` m, Model a b => (m a) (n b) instance
21:45:02 <dons> so that I can have a single, non-overlapping instance for all structured types
21:45:15 <dons> the problem is the goesTo
21:45:37 <dons> also, my Functor solution doesn't work in hugs either. its using some tricky overlapping game that hugs' overlappign instance don't supprort
21:45:41 <Cale> You might be looking for the NatTrans class.
21:45:53 <dons> ah, hmm. maybe maybe.
21:46:19 <Cale> class (Functor f, Functor g) => NatTransf f g where
21:46:19 <Cale>     eta :: f a -> g a
21:46:28 <Cale> that was in Gofer's prelude, way back when :)
21:46:55 <dons> so perhaps if I can NatTrans f g, Model a b => Model (f a ) (g b)
21:47:28 <Cale> sure
21:47:31 <vincenz> grr
21:47:38 <dons> I can apply eta, then apply 'abs' to get the 'g b' type. good!
21:47:39 * dons hacks
21:47:41 <vincenz> someone called himself lambdabot and started spamming oasisbot
21:47:51 <Cale> dons: or the other way around, and it doesn't matter :)
21:47:57 <dons> vincenz: yes :( ihope or jethr0.
21:48:08 <dons> or might have been someone else.
21:48:14 <dons> anyway, bug fixed. update lambdabot.
21:48:36 <vincenz> hmm
21:48:37 <vincenz> k
21:48:41 <dons> vincenz: oh, possibly someone was doing something totally unrelated to last night's bug in this channel.
21:49:05 <vincenz> bug?
21:49:20 <dons> check the logs :) 
21:50:23 <vincenz> funnily it's not all in there
21:50:45 <vincenz> lambdabot!i=foobar@p54A37E83.dip.t-dialin.net
21:51:14 <Cale> It would probably make typechecking really complicated, but sometimes I wish there was a transparent identity functor.
21:51:15 <Korollary> hmm. quine...
21:51:33 <vincenz> yep that's jethr0
21:51:40 <dons> hmm. now why didn't they need to identify? 
21:51:47 <dons> or don't you need to identify to talk in channel?
21:52:02 <vincenz> erm no
21:52:05 <vincenz> how do you do that?
21:52:27 <dons> well, freenode has identification, so presumably you can't pick the nick 'lambdabot' unless you know its secret password
21:52:33 <Cale> http://www.zug.com/gab/index.cgi?func=view_thread&head=1&thread_id=44344 -- did everyone see this thing a while back?
21:52:55 <vincenz> dons: you can for short amount of time
21:53:02 <dons> ah, right vincenz 
21:54:04 <vincenz> we could, however require lambdabot to whois people and check they're identified
21:54:18 <vincenz> I mean... you'r enot on
21:54:18 <vincenz> I do
21:54:23 <vincenz>  /nick dons
21:54:28 <vincenz> then @quit or something
21:58:50 <vincenz> l
21:59:25 <vincenz> is it vacation in australia today? (erm... tomorrow for you?)
22:00:05 <vincenz> dons: ping, ghc-6.4: Error; multiple packages match fps: fps-0.1, fps-0.7
22:00:12 <ski> Cale(,dons) : hrm, that 'NatTransf' class looks evil to me ..
22:00:42 <ski> .. since there can be many natural transformations between two functors .. which one should 'eta' be ?
22:01:16 <ski> or would there only be an instance when there's only one of them ?
22:01:22 <vincenz> anyone know how to deinstall cabal packages
22:01:40 <dons> ?karma+ Cale -- instance (NatTrans m n, Model a b) => Model (m a) (n b) where abs x = fmap abs (eta x)  :)
22:01:40 <lambdabot> Cale's karma raised to 11.
22:02:00 <dons> @pl abs x = fmap abs (eta x)
22:02:01 <lambdabot> abs = fix ((. eta) . fmap)
22:02:18 <dons> now the test, does hugs agree also
22:02:27 <vincenz> dons: how do I remove fps0.7
22:02:32 <dons> ah ha! yes :)
22:02:50 <dons> vincenz: ghc-pkg hide fps-0.7 ?
22:02:54 <vincenz> aha!
22:03:12 <vincenz> no wonder cab[TAB] found nothing
22:03:36 <Cale> ski: whichever one you want
22:03:58 <Cale> ski: of course it's a bit evil, but it's useful for the sort of thing dons wants to do.
22:04:04 <ski> and can't one want different ones in different circumstances, then ?
22:04:11 <Cale> yes
22:05:22 <dons> yeah, its useful for when there's a particular transformation I have in mind.
22:05:30 <dons> ie. the Model trans, in this case.
22:05:50 <dons> @index Functor
22:05:50 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:08:16 <vincenz> hmm
22:08:22 <vincenz> lambdabot won't compile 
22:08:31 <vincenz> Could not find module `Data.ByteString.Char8'
22:08:35 <vincenz> fps-0.1 is too old?
22:08:39 <dons> you just hid fps 0.7 ! ;)
22:08:47 <dons> you'll need to unhide it now.
22:08:56 * vincenz scratches his head
22:08:59 <vincenz> hiding had no effect
22:09:04 <dons> its fps > 0.5 or so that you need
22:09:05 <vincenz> I su'd hid and that didn't work
22:09:12 <vincenz> ah ok :)
22:09:14 <vincenz> so I'm removing 0.1 then
22:09:26 <dons> oh, try makign distclean too, other wise the .hi files end up  confused about which package you're using
22:09:41 * vincenz nods
22:10:32 <dons> Cale, now for identical types, I needed a few lines of the sort: instance NatTrans Maybe Maybe       where eta = id
22:10:40 <dons> can you think how to avoid that?
22:11:35 <vincenz> @hoogle eta
22:11:36 <lambdabot> Text.Html.meta :: Html
22:11:36 <lambdabot> Test.QuickCheck.Poly.BETA :: type BETA
22:11:36 <lambdabot> Test.QuickCheck.Poly.OrdBETA :: type OrdBETA
22:11:37 <Cale> only with unsafe typing features
22:11:47 <dons> yeah, maybe overlapping will be enough. let me see..
22:12:05 <vincenz> what model is this,
22:12:15 <dons> hugs has rather good type class error messages:
22:12:16 <dons> *** This instance   : NatTrans ((,) a) ((,) b)
22:12:16 <dons> *** Overlaps with   : NatTrans a a
22:12:17 <dons> *** Common instance : NatTrans ((,) a) ((,) a)
22:12:30 <Korollary> no brain explosions?
22:12:32 <dons> and in other cases, it will tell your accurately which constraints you need to add
22:13:02 <dons> but its overlapping magic isn't quite as strong as ghc's.
22:15:10 <dons> vincenz: oh, used in ByteString QuickChecks, to check ByteString against its List model
22:15:53 <vincenz> ah :)
22:15:54 <dons> so we can just list the functions which should be equivalent, and the typeclass machinary handles all the conversions  and equality tests
22:16:25 <vincenz>     Warning: `liftIO' is imported more than once:
22:16:26 <vincenz>                imported from Control.Monad.Trans at Lambdabot.hs:71:34-39
22:16:26 <vincenz>                imported from Control.Monad.State at Lambdabot.hs:69:0-25
22:16:26 <vincenz>                imported from Control.Monad.Reader at Lambdabot.hs:68:0-26
22:16:40 <dons> and you're using ghc 6.4 ?
22:16:43 <vincenz> yep
22:16:49 <vincenz> but still, those are different monads
22:17:02 <dons> upgrade your compiler, or turn off -Wall
22:17:25 <dons> its just exported in a number of places.
22:17:30 <dons> @index liftIO
22:17:31 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:19:19 <Captain_Fourier> howdy
22:23:53 <dons> dcoutts: something in the lazy fusion rules is slowing the code down. with -frules-off the lazy fuse tests run about twice as fast. 
22:24:59 <vincenz> dons: how do you do logging from irc?
22:26:06 <dons> I just read the logs
22:26:20 <vincenz> so you just log with irrsi?
22:26:42 <dons> nope. i let meme do the logging, here http://tunes.org/~nef/logs/haskell/
22:26:46 <hyrax42> @type lookup
22:26:47 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
22:27:11 <vincenz> whois meme
22:27:27 <vincenz> dons: and how does that get you highlighting for your nick
22:27:29 <dons> oh, sorry, meme is the other site taht logs haskell.
22:27:47 <dons> it doesn't. i load the logs up in w3m, and search using / and 'n'
22:27:53 <vincenz> ah
22:28:27 <vincenz> so who makes those logs?
22:28:55 <dons> some bot.
22:29:05 <vincenz> clog: 
22:30:54 <ruffneck> kespes
22:43:15 <dons> dcoutts: my mistake. lazy fusion seems to be working fine for map, at least
22:43:24 <dons> I make the pipe 'n' longer, it still runs in the same time.
22:44:04 <dons> and works for filter too.
22:56:05 <vincenz> @fptools Language.Haskell.Pretty
22:56:05 <lambdabot> http://darcs.haskell.org/packages/haskell-src/Language/Haskell/Pretty.hs
23:09:55 <palomer> > ord "\n"
23:09:55 <lambdabot>  Couldn't match `Char' against `[Char]'
23:09:58 <palomer> > ord '\n'
23:09:59 <lambdabot>  10
23:24:34 <xerox> Lambdabot was sending me /etc/passwd ?!?!?!
23:24:59 <vincenz> o.O
23:25:13 <xerox> I found the DCC open.
23:26:41 <Korollary> "DCC received CTCP SEND with invalid parameters from lambdabot"
23:26:58 <xerox> Yes.
23:28:45 <xerox> > ); take _ _ = ("\1PRIVMSG #haskell Was it this?\1"
23:28:46 <lambdabot>  parse error on input `)'
23:37:12 <goltrpoat> this is offtopic probably, but ive just done what is quite possibly the most perverse thing that has ever been done to C++.  DEFUN1(Fac, x, IF( LESS(x, Num<1>), Num<1>, MUL(x, CALL1(Fac, Num<SUB(x, Num<1>)::Result>))));  int x = EVAL(Fac<Num<5> >); // x evaluates to 120 at compile time.
23:37:50 <goltrpoat> i guess it doesn't have the same effect when it's on a single line.  looks pretty lisp-ish when it's written more legibly
23:38:39 * Korollary pours a strong drink for goltrpoat 
23:39:00 <goltrpoat> haha
23:41:19 <goltrpoat> oh, and the pattern-matching version:  DEFUN1(Fac2, x, MUL(x, CALL1(Fac2, Num< SUB(x, Num<1>)::Result > ))); GUARD1(Fac2, Num<1>, Num<1>); int y = EVAL(CALL1(Fac2, Num<5>));
23:41:26 <dons> xerox: yes. jethr0 and ihope (I think) went kind of crazy and spammed lots of people. it was pretty stupid.
23:42:36 <dons> harmless though, since all they code do was have lambdabot print strings for them.
23:42:47 <dons> so they could pretend lambdabot was asking for DCC or CTCP stuff.
23:48:38 <palomer> <:o
23:49:35 <Daveman> nice hat
23:50:30 <palomer> thx
23:50:50 <dons> hehe
23:50:59 <Daveman> :)
