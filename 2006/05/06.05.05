00:11:33 <Cale> palomer: I have a decent example for you
00:13:59 <Cale> (The idea is conveniently stolen, though I had to write the thing again myself since I can't find it online at all)
00:14:17 <vincenz> @SEEN ALAR
00:14:18 <lambdabot> Unknown command, try @list
00:14:22 <vincenz> @seen alar
00:14:23 <lambdabot> I saw alar leaving #haskell 1 month, 3 days, 14 hours, 12 minutes and 6 seconds ago, and .
00:17:19 <vincenz> Cale, palomer: Out of curiousity, you guys still interested in the icfpc
00:17:44 <Cale> somewhat
00:18:42 <vincenz> just haven't heard a word from you guys in the channel :/
00:22:01 <Cale> Is the actual problem posted yet?
00:22:09 <vincenz> well n
00:22:16 <vincenz> but a lot has to be said on organization and planning
00:22:21 <vincenz> and we're making a test framework
00:23:46 <Cale> *Main Data.List> parse (Star (Satisfy ((== 1) . length . nub))) "Mississauga"
00:23:46 <Cale> Just ["M","i","ss","i","ss","a","u","g","a"]
00:23:49 <Cale> :)
00:24:03 <vincenz> Star?
00:24:03 <Cale> highly inefficient, but what the heck :)
00:24:12 <Cale> Kleene closure
00:24:17 <vincenz> aha
00:25:31 <Cale> *Main Data.List> parse (Star (Times (Star (tok 'a')) (Star (tok 'b')))) "aaaaabbbaaabbbab"
00:25:31 <Cale> Just [("aaaaa","bbb"),("aaa","bbb"),("a","b")]
00:26:48 <Cale> parse :: Regexp tok a -> [tok] -> Maybe a
00:26:59 <Cale> (Star (Times (Star (tok 'a')) (Star (tok 'b')))) :: Regexp Char [([Char], [Char])]
00:28:37 <Cale> palomer: are you still around?
00:48:50 <araujo> Hi!
00:49:31 <ADEpt> hi
00:50:38 <kzm> Since #h-o is *so* crowded, I'll repeat myself here:  Is there a SoC student application howto somewhere?
00:50:53 <kzm> Or should I just write one, and point students to it?
00:51:35 * kzm coughs politely.
00:51:44 <vincenz> ask dcoutts 
00:51:59 <vincenz> or xerox__ 
00:52:16 * kzm nudges dcoutts.  Yo!  My man! Waddyathink?
00:52:46 * kzm glances over at xerox, who appears to be soundly asleep.
00:54:01 * kzm sighs, and goes off to try to find it out on his own.  Work, work, work!
00:55:50 <hoan> hey dons, code is cooking, i'm working on hws and it now uses bytestring, and hopefully i'll be able to work on it for SoC, being new to haskell and all that
00:56:18 <ADEpt> kzm: there are howtos from drupal and perl projects. want links?
00:57:34 <dons> kzm, you could write one. and read the apache one too.
00:57:47 <dons> hoan, cool!
00:58:20 <hoan> i really like the code for it, its so nice you can hang it up on a wall next to Rembrant or something
00:58:31 <hoan> i'd like to make it really really fast
00:59:13 <hoan> like yaws for erlang, but we'll call it haws
00:59:47 <vincenz> they're both part of 'flaws"
00:59:52 <vincenz> (functional language..)
01:00:39 <hoan> haw haw haw
01:14:44 * Beelsebob_ wonders what's up with the new version of hmake failing to compile
01:15:46 <kzm> ADEpt, yes, please.  Link away!
01:15:58 <dcoutts> kzm, you want to do what?
01:16:27 <kzm> I already wrote a draft: http://www.ii.uib.no/~ketil/bioinformatics/soc/application.html
01:16:41 <ADEpt> kzm: http://drupal.org/node/59037
01:16:45 <kzm> dcoutts, write the draft I've written. :-)
01:16:48 <ADEpt> kzm: http://drupal.org/node/59963
01:18:04 <dcoutts> kzm, look nice
01:18:55 <hoan> i agree, and i hope i get in
01:19:06 * kzm beams.
01:19:31 <dcoutts> dons, re: eq...
01:20:20 <dcoutts> dons, so you can short-cut inequality if the lengths are different
01:20:33 <dcoutts> dons, that should be a huge boost
01:20:53 <dcoutts> since most random strings are not of equal length, that gives you an O(1) shortcut
01:21:48 <dcoutts> then there is the O(1) equality shortcut which is if the ForeignPtr and the offset and length are equal.
01:22:47 <dcoutts> dons, so the only time you need to do a full traversal of the string is when they are equal value but not the same physical string
01:24:14 <dcoutts> (of course the other case of a nearly full traversal is if two strings are equal length and have a long common prefix)
01:25:22 <kzm> random strings usually differ very quickly.
01:25:44 <kzm> when I was toying with boyer-moore and KMP, I found that isPrefixOf was often faster.
01:26:01 * Saulzar mutters. Scrub out the SDL_main_win32.c and it gives  libmingw32.a: undefined referece WinMain@16
01:26:32 <dcoutts> kzm, but we've got direct (& therefore fast) access to the length
01:26:42 <dcoutts> so it's quicker to do that test first
01:27:05 <kzm> Yes, I'm not saying not to check it.  Very sensible optimization.
01:27:34 <kzm> I suppose you could also be in a situation where the lenght is known, but the content not (yet)  (mmap'ed files?)
01:27:42 <dcoutts> true
01:28:01 <dcoutts> though as you say, strcmp will soon find the difference, if they're different
01:28:23 <dcoutts> though if they happen to actally be the same pointer then that can also be optimises
01:28:38 <kzm> Well - implement, and run 'make bench'.
01:29:03 <dcoutts> oh ok
01:29:04 <kzm> One thing, though - should they be considered equal if they have different encodings? :-)
01:29:50 * kzm isn't sure that should be able to happen, but..
01:30:12 <dcoutts> kzm, bytestrings are encodingless
01:30:18 * kzm is starting to think dons is right in being scared of encodings.
01:30:28 <kzm> ..where angels fear to thread, so to speak.
01:30:36 <dcoutts> you should be scared of string encodings
01:30:36 <Cale> If palomer comes back, tell him to check the GADT page on haskell.org
01:30:37 * dcoutts is
01:30:58 * kzm is no doubt a fool.
01:31:01 <kzm> :-)
01:31:13 <dcoutts> kzm, angles are no good at writing threaded code either huh? not suprising I guess.
01:31:35 <kzm> I think it is silly that we don't have good ways of doing IO with text in some representation.
01:31:47 <dcoutts> you're quite right
01:31:57 <dcoutts> hopefully the new IO lib will solve that
01:32:50 <kzm> Well, of course, how many angels can dance on pinhead-sized source code?
01:33:01 <dcoutts> mmm, good question...
01:33:03 <kzm> Which one is that?
01:33:04 <dcoutts> ;-)
01:33:14 <kzm> Which IO lib, that is?
01:33:28 <dcoutts> kzm, the one Simon and some others have been arguing over
01:33:33 <dcoutts> a streames based one
01:33:37 <dcoutts> with type classes
01:33:40 <kzm> Oh, the bikeshed thing? 
01:33:46 <dcoutts> and block based encoding stuff
01:33:49 <dcoutts> kzm, aye
01:33:56 <kzm> :-)
01:33:58 <lisppaste2> mnislaih pasted "Flawed Memoization" at http://paste.lisp.org/display/19704
01:34:12 <mnislaih> If anyone could give a look to that paste ...
01:34:59 <kzm> About angels - I'm always amazed at the number of errors I make when I have to worry about indexing, threads, etc.
01:35:35 <kzm> Adding encodings to bytestrings is much easier, but OTOH, the perormance of UTF8 has yet to be determined.
01:36:53 <dcoutts> I'd like to investigate lazy ByteStrings
01:37:02 <dcoutts> I think they could perform rather well
01:37:13 <dcoutts> better than ByteStrings in some cases
01:37:24 <dcoutts> in particular, memory usage
01:37:51 <kzm> I agree.  Sometimes I just want to stream through some data.
01:37:58 <kzm> No need to 
01:38:03 * kzm growls.
01:38:10 <kzm> no need to go via [Char] 
01:38:36 <kzm> Sounds a bit like the block/new/IO bikeshed thing?
01:38:41 <dcoutts> right, [a] is pretty effecient really, but not down to the [Char] level
01:38:56 <dcoutts> but [BigPackedChunkOString] should be good
01:38:58 * kzm almost wrote "byteshed", and, in fact, likes that name better.
01:41:18 <kzm> dcoutts, did you want to test the eq optimizations, or should I?
01:41:21 <norpan> kzm: ok, i have a compilable version now
01:41:27 <kzm> It looks easy enough.
01:41:29 <tennin> kind of embarrassing question but... is there a standard function that works like Python's split?
01:41:35 <dcoutts> kzm, I was doing that... (no really I was...)
01:41:35 <kzm> norpan, great!  The full interface?
01:41:42 <kzm> tennin, uh...split?
01:41:43 <norpan> not everything
01:41:50 <tennin> obviously it's easy to write one but...
01:41:53 <norpan> but it's a start
01:42:06 <kzm> norpan, darcs?
01:42:14 <norpan> i haven't put in any functions that are just unpack . f . pack
01:42:36 <norpan> yes, how do i publish it in the easiest manner?
01:42:36 <tennin> like, split ',' "blue, red, green" = ["blue", "red", "green"]
01:42:39 <kzm> norpan, huh?  You only did the hard work?
01:42:44 <norpan> yes
01:42:48 <kzm> do you have a web server?
01:42:51 <norpan> sure
01:42:52 <lisppaste2> mnislaih annotated #19704 with "FIXED" at http://paste.lisp.org/display/19704#1
01:42:57 <tennin> there is regexSplit and break and words
01:43:02 <norpan> i have never used darcs
01:43:06 <kzm> then just put the darcs repo somewhere it can be reached by http
01:43:21 <kzm> It is quite easy to use.
01:43:41 <dcoutts> @where fps
01:43:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:43:43 <norpan> i should "add" my file or what?
01:44:15 <kzm> norpan, yes.  darcs add Data/ByteString/UTF8.hs
01:44:18 <kzm> (or whatever)
01:44:25 <kzm> then "darcs rec"
01:44:41 <kzm> and put it somewhere the web server can see (and distribute) it
01:45:06 <norpan> ok
01:45:07 <norpan> http://norpan.org/~martin/fps-i18n/
01:45:20 <kzm> I did a bunch of those (pack . f . unpack) tedium, and will try to incorporate them.
01:46:48 <dons> dcoutts: already added the length shortcut patch, and a similar one for compare
01:46:53 <dons> its in ghc already :)
01:47:00 <dcoutts> dons, cool!
01:47:12 <dcoutts> dons, how about the pointer identiry shortcut?
01:47:19 <dons> yep.
01:47:24 <dcoutts> nice
01:47:29 <dons> eq :: ByteString -> ByteString -> Bool
01:47:29 <dons> eq a@(PS p s l) b@(PS p' s' l')
01:47:29 <dons>     | l /= l'            = False    -- short cut on length
01:47:29 <dons>     | p == p' && s == s' = True     -- short cut for the same string
01:47:31 <dons>     | otherwise          = compareBytes a b == EQ
01:47:36 <dcoutts> is that in the fps darcs repo?
01:47:52 <dons> yes, and in the base lib head
01:47:58 <dcoutts> cool
01:48:06 <dons> and I added to compare:
01:48:08 <dons>     | x1 == x2 && s1 == s2 && l1 == l2  = EQ  -- short cut for the same string
01:48:37 <dons> so, all good.
01:48:53 <dcoutts> good good
01:49:07 <dons> also:
01:49:24 <dcoutts> did that make any difference to the benchmarks?
01:49:42 <dons> ==================== Grand total simplifier statistics ====================
01:49:42 <dons> Total ticks:     5875
01:49:42 <dons> 1073 PreInlineUnconditionally
01:49:42 <dons> 882 PostInlineUnconditionally
01:49:42 <dons> 688 UnfoldingDone
01:49:44 <dons> 58 RuleFired
01:49:47 <dons>     15 array fusion!       
01:49:50 <dcoutts> woo!
01:50:01 <dons> I'm almost certain it will, but I don't have the many-small-strings benchmark
01:50:16 <norpan> hmmm what benchmark should i run for my UTF-8 stuff
01:50:23 <norpan> i want to check it against raw bytestrings
01:50:35 <dons> norpan: which fps benchmark?
01:50:39 <norpan> yes
01:50:42 <dcoutts> dons, I started looking at implementing a Data.ByteString.Lazy module, with the same api as Data.ByteString
01:50:43 <dons> I'd try to run the full Bench.hs suite
01:50:50 <dons> dcoutts: yeah, I like the idea
01:51:05 <dcoutts> dons, ie a drop in replacement, but with different memory/performance characteristics
01:51:14 <dons> yep. i saw the discussion
01:51:16 <dcoutts> dons, but it's not so easy to write :-)
01:51:27 <dons> its a segmented array of sorts
01:51:29 <dcoutts> I should really be getting on with "real" work :-)
01:51:45 <dons> and dealing with the segment boundaries is the tricky, i guess
01:51:53 <dcoutts> right
01:51:57 <dcoutts> some bits are easy
01:52:02 <dcoutts> but others are tricky
01:52:12 <dcoutts> eg concat is trivial
01:52:18 <dons> would be interesting, as I guess cons would become O(1) again
01:52:18 <dcoutts> but eq is hard! :-)
01:52:27 <dons> ah ,yes.
01:52:30 <dcoutts> dons, well depends on how you want it
01:52:33 <dcoutts> cons I mean
01:52:36 <dons> yeah
01:52:52 <dcoutts> it could tack on a packChar c
01:52:59 <dcoutts> but that's goiing to get really innefecient
01:53:06 <dcoutts> if you want to use the thing after
01:53:28 <dcoutts> I was thinking of a O(1) amortised time cons that does coalesing
01:53:43 <dons> right, that'd be very useful
01:53:49 <dcoutts> bu a bit complex
01:54:05 <dons> so many list algos rely on O(1) cons, and translating that to bytestring can be a bit tricky
01:54:22 <norpan> i have no bigdata file
01:54:34 <dcoutts> it'd have a highish constant overhead for that O(1) however
01:54:36 <dons> norpan, the build system should ln -s it for you ?
01:54:45 <dons> norpan: otherwise, create one.
01:54:51 <kzm> norpan, just ln -s /usr/share/dict/words bigdata
01:54:54 <norpan> ah
01:55:02 <dons> or use the 'data' file possibly
01:55:13 <kzm> also interesting to link to binary files, especially to test the encodings
01:55:14 <dons> but i use a 20M file so that at least some functions don't take 0.00s
01:55:23 <norpan> i didn't do make
01:55:35 <dons> that's the charm
01:55:44 <kzm> And modify letter_frequency to use encodings as well - caught some nastiness for me.
01:55:45 <dcoutts> dons, the main advantage of course would be a hGetContents with a tunable block size parameter
01:56:00 <dons> yep. that'd be really nice actually
01:56:07 <dons> kind of a lines-ish function
01:56:08 <kzm> I can add UTF8 to Bench.hs, if you want
01:56:24 <dcoutts> dons, right, but it's all hidden in the module
01:56:38 <dons> ah, you don't actually get back a chunk. right.
01:57:02 <dcoutts> dons, you'd provide low-level functions for converting L.ByteString -> [P.ByteString]
01:57:15 <dcoutts> but other than that, it'd have the same api as ByteString
01:57:23 <dcoutts> hiding the chunked represnetation
01:57:24 <norpan> i don't have logpp
01:57:32 <dons> norpan: chmod +X
01:57:40 <dons> +x I mean
01:57:57 <norpan> ah
01:57:59 <dons> ls -l before your cry for help ;)
01:58:12 <norpan> hehe
01:58:44 <dcoutts> dons, so perhaps hGetContents would use a default block size (eg 4 or 8k) and then an extra hGetContentstunable would provide the extra control
01:59:03 <dons> yep
01:59:03 <dcoutts> dons, so apps could try a few and pick the one that gives best performance for their situation.
01:59:09 <norpan> i like to be stupid sometimes and just cry
01:59:23 <dons> dcoutts: this sounds very reasonable
01:59:28 * dons -> dinner time!
01:59:35 <dcoutts> dons, we just need someone to write it ;-)
01:59:43 <dons> oh, i thought you would. hint hint
01:59:50 <dcoutts> heh, I'd like to
01:59:51 <norpan> i read hGetContentunstable instead of hGetContentstunable
01:59:52 <dcoutts> but...
02:00:09 <dcoutts> norpan, that'd be fun :-)
02:00:11 <dons> norpan: true. there's not enough unstableFoo functions
02:00:22 <dons> that jsut do random things sometimes
02:00:30 <dcoutts> unsafeUnstableFoo :: a -> b
02:01:17 <norpan> length for UTF-8 is O(n) but what can we do about it
02:01:45 <norpan> without changing the ByteString type
02:04:12 <dcoutts> norpan, not much
02:04:28 <dcoutts> norpan, just make sure users accept that it's O(n)
02:04:38 <dcoutts> it's same as !! on String
02:04:45 <dcoutts> and people survive
02:04:50 <norpan> they do
02:04:59 <dcoutts> if they want O(1) then tell them to convert to UCS4
02:05:21 <dcoutts> you can only do what the representation allows, no trying to hide the facts
02:05:39 <norpan> did you look at my module?
02:05:44 <dcoutts> where?
02:05:49 <norpan> http://norpan.org/~martin/fps-i18n/
02:06:26 <norpan> i have only done a few of the ones that could be optimized
02:08:05 <dcoutts> norpan, anything for validating or normalising UTF8?
02:08:21 <norpan> it's validating, but not normalizing
02:08:44 <dcoutts> which bit does the validating?
02:08:57 <norpan> getUTF8
02:09:08 <kzm> norpan, I'm adding tests to Bench.hs -- okay?
02:09:12 <norpan> sure
02:09:14 <dcoutts> fail "overlong" etc
02:09:19 <norpan> yes
02:10:00 <dcoutts> norpan, I wonder if the best thing to do is to validate all the time rather than on construction
02:10:26 <norpan> well, i used it for mmapFile before
02:10:28 <dcoutts> and provide a non-validating constructor for cases where people really really are sure its valid and normalised
02:10:47 <norpan> and I didn't want it to go through the whole file
02:11:07 <dcoutts> sure, that's why you provide a non-validation version
02:11:14 <dcoutts> but it's unsafe
02:12:11 <norpan> the validation checks are cheap though
02:12:47 <norpan> the data will be in the cache already
02:13:28 <norpan> and branch prediction will make them almost for-free
02:13:39 <norpan> (i hope)
02:13:57 <dcoutts> norpan, mm, yeah hopeflly
02:23:55 <kzm> doesn't normalization belong in Data.Char or something?
02:26:27 <dcoutts> kzm, I wouldn't say so. It's a utf8-specific thing.
02:26:49 <dcoutts> ie rejecting or converting over-long encodings to normal form
02:26:59 <dcoutts> perhaps it's best to always reject
02:27:32 <vincenz> hi
02:27:35 <vincenz> anyone use Makefiles?
02:27:44 <vincenz> basically due to ghc --make
02:28:05 <vincenz> dependencis are not listed in the Makeile
02:28:17 <vincenz> wthis means that recompilation will not occur unless there was a clean or if the Main.hs has changed
02:28:34 <vincenz> (and sorry for the typos, my ssh cnnections is really crappy, and I'm getting seriously frustrated at the IT guys at work)
02:29:42 <dcoutts> vincenz, gtk2hs uses automake, but it's not pretty.
02:30:34 <dcoutts> vincenz, with ghc --make it always checks to see if it needs to recompile, that's why it's so slow
02:30:35 <vincenz> are there any 'prettier' solutions?
02:30:35 <vincenz> someone mentioned .PHONEY, someone else mentioned cabal
02:30:41 <dcoutts> cabal
02:30:48 <dcoutts> but it uses ghc --make :-)
02:31:23 <vincenz> the issue is not ghc --make
02:31:29 <vincenz> the issue is Makefile not listing dependencies
02:32:02 <vincenz> and hence not calling ghc --make agian
02:32:06 <dcoutts> ah right
02:32:19 <dcoutts> ghc -M generates makefile deps
02:32:34 <dcoutts> it's quite possible to use that method
02:32:38 <vincenz> ah
02:32:44 <vincenz> include .depend
02:32:45 <dcoutts> see the ghc user guide
02:32:49 <dcoutts> yeah exactly
02:33:05 <dcoutts> that's what gtk2hs does (and some more ugly things)
02:34:12 <vincenz> thx!
02:34:12 <vincenz> tGRRRRRRRRRRRRRRRRRRRRr my fricking connection
02:34:44 <nnunley> Hrm.  How do I indicate to cabal that I would prefer one module's symbols over the other?
02:34:59 <dcoutts> nnunley, what does that mean?
02:35:36 <nnunley> Ie: fps-0.6 and base-1.0 both provide Data.ByteString
02:35:53 <dcoutts> depends: base
02:36:05 <dcoutts> rather than: depends: fps
02:36:22 <nnunley> Currently, it depends on both.
02:36:27 <norpan> no, normalization is not an utf-8 thing
02:36:35 <norpan> normalization is a unicode thing and belongs in Char
02:36:43 <norpan> or String
02:36:53 <kzm> dcoutts, okay - thought it was about normalizing combining chars and the like
02:37:19 <norpan> no, overlong characters is a validation issue
02:37:23 <norpan> they are illegal
02:37:25 <kzm> I read (somewhere :-) that UTF8 proscribes the shortes encoding for each code point.
02:37:26 <dcoutts> norpan, ok, worng word. I meant utf8 encoding canonicalisation. ie there are multiple ways of representing chars, but shortest is the canonical representation.
02:37:39 <norpan> the shortest is the only valid way
02:37:40 <kzm> but we should perhap be conservative in what we accept?
02:37:58 <dcoutts> I think the reccomendations are to reject over-long encodings
02:38:04 <norpan> in the case of UTF-8 you should never accept overlong characters, as this leads to security issues
02:38:20 <kzm> right, that wat it.
02:38:24 <kzm> was.
02:38:29 <dcoutts> nnunley, you need both fps and base? surely you need just base?
02:38:47 <norpan> and in the new unicode standard overlong characters are illegal
02:38:52 <kzm> Security issues as in accepting domain names that look very much like other domain names? :-)
02:38:54 <dcoutts> nnunley, if your base contains the new Data.ByteString then why do you need the fps package?
02:39:14 <nnunley> Good question.  Eliminated.
02:42:00 <nnunley> Need more coffee.
02:44:16 <norpan> kzm: well, that's a different issue, security issue in checking the UTF-8 string for example for '/' and then missing a '/' because it was encoded overlong
02:44:35 <vincenz> @hoogle incrmenet
02:44:36 <lambdabot> No matches found
02:45:18 <vincenz> @hoogle increment~
02:45:19 <lambdabot> No matches found
02:45:21 <norpan> but there is no reason for UTF-8 ever to contain these overlong encodings so that's why they made them illegal
02:45:36 <nnunley> dcoutts:  Is it possible to indicate that I depend on base-1.0 or fps -any ?
02:46:15 <dcoutts> nnunley, no, you can do conjunctions, not disjunctions.
02:46:36 <vincenz> @hoogle increment
02:46:37 <lambdabot> No matches found
02:59:31 <dcoutts> morning JaffaCake
02:59:39 <JaffaCake> hi there ;)
02:59:54 <dcoutts> JaffaCake, Isaac told me to ask you about setting up a gtk2hs Trac instance.
03:00:19 <dcoutts> he said I needed to persuade you that it'll get used (to stop a proliferation of unused ones)
03:00:37 <JaffaCake> i'm listening :)
03:01:04 <JaffaCake> actually it's dead easy to set up, I made a script for it
03:01:09 <dcoutts> I think gtk2hs is at the stage where we have enough bugs / feature requests / TODO list items that it'd help us keep track of things
03:01:25 <dcoutts> and it give other people more visability into our development & releases
03:01:26 * JaffaCake is easily persuaded
03:01:29 <dcoutts> :-)
03:01:41 <JaffaCake> hang on a tick
03:02:17 * dcoutts does so
03:02:38 <JaffaCake> you want hackage.haskell.org/trac/grtk2hs?
03:02:51 <dcoutts> hackage.haskell.org/trac/gtk2hs
03:02:52 <dcoutts> yep
03:03:01 <dcoutts> s/grtk2hs/gtk2hs
03:03:54 <araujo> Good morning!
03:03:59 <araujo> dcoutts!
03:04:01 <dcoutts> hia araujo 
03:05:45 <kzm> norpan, dcoutts etc - I almost have the utf bench working
03:05:52 <dcoutts> great
03:06:09 <shapr> JaffaCake: Hey, did you see that Peng Li's sources have been released?
03:06:14 <kzm> have to stuff some calories now, back later
03:06:39 <norpan> reverse should be possible to do in-place with UTF-8, i'll be back in a couple of weeks :)
03:06:52 <hoan> shapr: where?
03:06:55 <JaffaCake> shapr: for the events/threads stuff? I haven't seen it
03:07:28 <norpan> or wait, it will be simple
03:08:27 <shapr> JaffaCake, hoan: http://lambda-the-ultimate.org/node/1435#comment-16497
03:08:39 <shapr> simpler - http://www.seas.upenn.edu/%7Elipeng/unify
03:09:21 <JaffaCake> dcoutts: http://hackage.haskell.org/trac/gtk2hs
03:09:33 <dcoutts> yay, thanks JaffaCake 
03:09:41 <hoan> yep found it
03:10:02 <dcoutts> JaffaCake, so how do I admin accounts etc?
03:10:45 <hoan> another web server
03:10:53 <shapr> JaffaCake: Yesterday I was wondering, what else could be profitably moved out of the RTS and into 'userspace'? I couldn't think of any way to move GC... any other ideas?
03:11:02 <shapr> hoan: It's based on JaffaCake's HWS.
03:12:54 <hoan> yep, i'm working on that for SoC
03:13:06 <JaffaCake> shapr: there's a lot of stuff to do with multiplexing I/O that isn't necessary with the threaded RTS, we moved it into userspace
03:13:06 <shapr> Doing what?
03:13:22 <hoan> improving the haskell web server (i got it to use ByteString)
03:13:42 <hoan> i'd like add a few more features and to make it faster
03:13:46 <shapr> Nifty, will you be including the hs-plugins extensions Peter Thiemann wrote?
03:13:55 <hoan> yep i've started with that
03:13:58 <dcoutts> JaffaCake, I can't seem to login. Any ideas?
03:14:04 <JaffaCake> oh
03:14:07 <JaffaCake> hang on
03:14:08 <hoan> and then i'll merge it back into WASH
03:14:41 <hoan> and then HAppS and HSP could use it
03:14:50 <dcoutts> hoan, if you're modifying wash, can you split up those two modules that each take 30min + 700Mb to build :-)
03:14:59 <hoan> yes goddam
03:15:06 <musasabi> hoan: I don't think we would switch to it as our code is faster at the moment.
03:15:14 <musasabi> (HAppS that is)
03:15:15 <hoan> okay sure
03:15:35 <dcoutts> hoan, we've had to implement so much workaround stuff to get wash to build on gentoo on mortal's machines. :-)
03:15:51 <musasabi> hoan: but I think sharing code would make sense.
03:16:12 <musasabi> There are 5+ http server implementations in Haskell and more popping up every day.
03:16:17 <dons> hoan: should you talk to musasabi about what he optimised to get his webserver so blindingly fast. we spent several days working on it.
03:16:24 <hoan> yes, in fact i figured out how to use ByteString from HAppS
03:16:32 <JaffaCake> dcoutts: works now
03:16:43 <hoan> but, there is more to do
03:16:46 <dcoutts> JaffaCake, yep, thanks!
03:17:10 <dons> hoan, tricks like packAddress, and probably now taking advantage of the array fusion of filter and map (be worth trying, musasabi. and the faster eq/compare)
03:17:36 <JaffaCake> dcoutts: if you want to change the logo, I'll probably have to do it by hand
03:17:38 <musasabi> hoan: is there a way to avoid duplicate work and work together in some fashion? I would like to avoid the situation where everyone implements everything from scratch and has to fix all the bugs for themselves.
03:17:41 <hoan> dons: i've got to figure out how to profile first, eek ;)
03:17:47 <JaffaCake> otherwise, pretty much everything else is done via the web interface
03:17:58 <dcoutts> JaffaCake, oh I see. Well I might send you a .png some time if that's ok.
03:17:58 <hoan> musasabi: yes, i agree
03:18:07 <JaffaCake> dcoutts: sure
03:18:27 <hoan> musasabi: thats going to be the main part of the proposal, working with all the other web people
03:18:35 <dons> JaffaCake: is there any way to realloc a MutByteArray# ?
03:19:00 <JaffaCake> dons: just allocate a new one and copy
03:19:18 <musasabi> hoan: btw we have an experimental port of HSP using HAppS.
03:19:25 <hoan> musasabi: so in your opinion, what parts of HAppS HTTP server are better that HWS?
03:19:43 <eivuokko> Anyone knowledgeable about localtime's extended functionality?  That functionality isn't available on Windows and TimeLib doesn't compile because of it.  In Windows you can only get current timezone info, and the dates when time changes between standardtime and daylighttime.  Does localtime(_r) (or do people suppose it does) somehow take into account years when those dates changed etc?
03:19:59 <eivuokko> extended functionality = timezone info
03:20:04 <dons> JaffaCake: since now fps is doing fusion a la ndp, it uses this loopU combinator that reallocs (for filters), but to get realloc I had to move out into a C foreign ptr with a free finalizer.
03:20:42 <musasabi> hoan: we have constrained memory use, and good performance. Also we are matching the HTTP spec better in some areas (while worse in some other areas). I know that serving 500mb video files is no problem, but HWS has an hack to make that possible too.
03:21:11 <dons> which would be nice to avoid, and move packed strings created by map and filter back into the Haskell heap. but do you think copying is ok -- any ideas what realloc does?
03:21:50 <dons> actually, for small strings I could copy, and large ones I could just shrink the packed string offset and length.
03:21:59 <JaffaCake> realloc copies most of the time, I think.  there might be an optimisation to avoid the copy when the string has enough free space after it.
03:22:18 <dons> its always going to be smaller in this case, or equal. never bigger
03:22:20 <musasabi> hoan: the HWS code doesn't e.g. do header-combining (which is expensive, but required) and uses Strings all over. It was much easier to just rewrite the code than to change it.
03:22:22 <JaffaCake> I was assuming you were expanding - certainly shrinking should be possible
03:22:26 <dons> (there's no unfold fusion this way).
03:22:44 <hoan> musasabi: okay, sure
03:22:45 <JaffaCake> right, I think we'd have to add a primitive for that
03:23:01 <JaffaCake> I don't see a problem,though
03:23:16 <dons> yeah, its ok. i wasn't clear myself that we never expanded
03:23:26 <hoan> musasabi: so do you think using strings for headers in hws degrades performance?
03:23:27 <dons> so its fine. this array fusion stuff is really fun :) 
03:23:43 <musasabi> hoan: At least the following exist for HTTP: 1) Network.HTTP (client only?), 2) WASH, 3) HAppS, 4) HAIFA, 5) HSP, 6) hws, 7) ...
03:23:44 <dons> some things end up running many times faster. N times for N maps and filters and folds :)
03:24:00 <JaffaCake> wow, cool
03:24:20 <hoan> musasabi: and there is a Peng-Li one too....
03:24:37 <musasabi> hoan: right.
03:24:39 <dons> it'll be useful for fold . filter . map style things. i know at least filter . map is fairly common in packed string code.
03:24:40 <hoan> i've never heard of HAIFA
03:25:20 <musasabi> hoan: One common nice module would be for MIME parsing with ByteStrings. (+ String interface for those who want that)
03:25:37 <hoan> musasabi: ok
03:25:42 <musasabi> http://www.dcs.shef.ac.uk/~simonf/HAIFA.html
03:25:57 <hoan> musasabi: what would you like to be added to the HAppS http server that is in others?
03:26:39 <hoan> haifa is quite recent too
03:26:56 <musasabi> hoan: for additional features I would like 1) MIME, 2) gzip compression, 3) chunked transfer encoding
03:27:32 <hoan> okay!
03:27:32 <musasabi> I don't think anyone has 2) or 3).
03:28:04 <hoan> mime types are in hws
03:28:08 <musasabi> For 1) I am thinking of adapting the WASH code (and converting it to use ByteStrings, but a common module there would be nice)
03:28:20 <hoan> ah ok
03:28:24 <musasabi> hoan: no, efficient mime-multipart decoding.
03:28:31 <hoan> oh oh
03:29:14 <pejo> eivuokko, what are you asking about localtime, whether it accounts for daylight savings?
03:29:32 <musasabi> hoan: that is needed for file uploads and I need something that is able to handle multi-megabyte files without dying.
03:30:09 <hoan> musasabi: ok, so a RealFastString version of the wash code as a separate module
03:30:19 <eivuokko> pejo, it obviously does.  But to what are the semantics as it goes back in time or forward in time (in case daylight/standard change dates are diffrent)
03:30:59 <musasabi> hoan: yes, something like that. Getting a solution that other people could use too would be nice.
03:31:07 <hoan> musasabi: well it looks like its from 2002
03:31:16 <hoan> so i think he would quite mind
03:31:45 <hoan> hey...
03:31:48 <musasabi> hmm?
03:32:14 <hoan> there is also a utf-8 encoding in there too
03:32:27 <hoan> but as of today RealFastStrings has utf-8
03:32:53 <musasabi> I don't have a problem with using the code from an another webkit if we can get it packaged in a separate fashion and I think everyone else is in the same situation.
03:33:15 <musasabi> HSP cannot depend on HAppS, HAppS cannot depend on WASH, WASH cannot depend on HAIFA etc
03:33:18 <hoan> yes, agree
03:34:08 <musasabi> but we can all depend on a "mime-parser" or "http-common" or something like that, just that it has to be something that everyone is happy with, otherwise people won't move to using it.
03:34:26 <hoan> sure, that makes it all the more tricky
03:34:33 <hoan> do any other of the webkittens hang out here?
03:34:46 <musasabi> Very occasionally.
03:35:13 <musasabi> I think we could do a mailing list to discuss this and get some work done?
03:35:53 <hoan> yes, as long as there is a commitment by the others
03:37:24 <resiak> k
03:38:09 <pejo> eivuokko, boggle. Don't think I can answer that one, sorry. It seems to be hidden in tzset(3), and I bet it's os-dependent.
03:41:24 <musasabi> Everyone wants to keep their favorite bits of code, but I think there are many parts that are simply a chore for everyone.
03:41:36 <eivuokko> pejo, Whole api seems flaky to me.  Thanks for looking into it.
03:43:36 <hoan> musasabi: stuff like multipart/mime, serving pages, etc... is rather a chore so it could be factored out...  the more interesting part is the "framework"
03:46:10 <hoan> okay shower time
03:47:11 <vincenz> is it possible to layer a dynamic amount of monads on top of each other?
03:47:12 <musasabi> -> lunch
03:57:24 <kzm> good news: utf8 is now being benched
03:57:38 <kzm> bad news: the 'inits' test takes approximately forever :-)
03:57:58 <kzm> inits = map pack . List.inits . unpack
03:58:00 <kzm> whee!
03:58:19 <kzm> not-so-bad-after-all-news: it should be rather easy to optimize
04:09:13 <vincenz> is it possible to layer a dynamic amount of monads on top of each other?
04:10:36 <doublec> HAppS looks interesting - does it provide similar functionality to WASH? ie. continuation style web application development
04:11:16 <doublec> There's not much in the way of docs so it's a bit hard to tell how it's best used.
04:11:21 <Saulzar> Hmm, you need to find some way to overload >>= dynamically then... 
04:12:04 <kzm> doublec, hmm... I think this a common problem; it is always difficult to figure out how competing projects relate to each other
04:12:16 <dcoutts> JaffaCake, can I ask you to put this .png on the gtk2hs trac page?
04:12:16 <doublec> kzm, Yes. 
04:12:16 <dcoutts> http://haskell.org/~duncan/gtk2hs/Gtk2Hs-bug-tracker-banner-nobg.png
04:12:18 <kzm> Another example is HaskellDB, Takusen, HDBC, HSQL
04:12:37 <dcoutts> JaffaCake, and could it link back to the main trac start page rather than to edgewall software?
04:12:57 <JaffaCake> ok
04:12:58 <dcoutts> JaffaCake, ie link to http://hackage.haskell.org/trac/gtk2hs
04:14:12 <Saulzar> vincenz, Would an existential monad possibly work? and would it be useful??
04:14:39 <vincenz> Saulzar: I need it
04:16:30 <vincenz> I have a set of monadic actions
04:16:45 <vincenz> that allows me to define the producion of some data based on some other data
04:16:49 <vincenz> now I would like this produced data to be then used by a second monad for producing other data
04:16:57 <vincenz> so if I could couple the production and consumption
04:16:58 <vincenz> I would have
04:17:06 <vincenz> MyMonad a (MyMonad a IO ) () 
04:17:07 <vincenz> for instance
04:17:16 <vincenz> now if I want to have a dynamic amount of these monads
04:17:52 <JaffaCake> dcoutts: do you know what the width/height of the PNG is off hand?
04:18:08 <davidhouse> vincenz: i think you probably just want to bind them together
04:18:33 <vincenz> stacked
04:19:26 <davidhouse> i don't think so.
04:19:37 <vincenz> on another note, what's the ideal structure that allows functional updating at keys
04:19:38 <davidhouse> what does your monad look like?
04:19:40 <JaffaCake> dcoutts: done
04:19:44 <vincenz> with keys being a given range
04:19:59 <vincenz> list = O(N)
04:20:01 <vincenz> but map is sparse
04:20:13 <vincenz> and replaceAt ain't great for lists
04:21:14 * vincenz should really implement a fingertree
04:21:27 <vincenz> I'll do that this weekend and send to haskell-cafe
04:21:43 <vincenz> but dynamically stackable monads = impossible?
04:22:04 <davidhouse> vincenz: i think you need to explain your problem a bit more
04:22:11 <vincenz> ok
04:22:13 <davidhouse> like, show us some code ;)
04:22:19 <vincenz> can't do
04:22:23 <vincenz> but I can give something simialar
04:22:29 <vincenz> MonadSuplply on hawiki, has a push
04:23:31 <vincenz> grrr
04:23:35 <vincenz> stupid fricking ssh connection
04:24:41 <vincenz> let me make a contrived example
04:24:47 <dcoutts> JaffaCake, yay! thanks very much for setting it all up.
04:25:23 <JaffaCake> no problem
04:28:24 <vincenz> ok got it
04:28:29 <vincenz> monad experts please look
04:28:32 <kzm> Hah! There!
04:28:44 <vincenz> http://rafb.net/paste/results/Lcgq7l76.html
04:28:49 <kzm> Got the benchmark to run all the way through utf8.
04:29:11 <vincenz> so right now...action (should be produce) rints
04:29:12 <vincenz> prints
04:29:24 <vincenz> but what if I wanted this aciton produce
04:29:29 <vincenz> to push a consume on a lower level
04:30:19 <vincenz> http://rafb.net/paste/results/uodgT037.html
04:34:45 <musasabi> back
04:34:54 <vincenz> here is a compliable
04:34:59 <vincenz> http://rafb.net/paste/results/SvOT7575.html
04:35:02 <vincenz> now... at the bottom you see the use
04:35:16 <vincenz> what if ... I didn't know how many producers I would stack on top of each other
04:35:23 <vincenz> I'd need a dynamic amount of monads
04:35:55 <musasabi> doublec: There are problems with the continuation style things and WASH suffers from them.
04:36:07 <dcoutts> JaffaCake, is it possible to get bug report changes sent to gtk2hs-devel@lists.sourceforge.net ? like you've got it for ghc?
04:36:12 <vincenz> anyone have any suggestions?
04:36:24 <musasabi> doublec: basically one needs for the state to be serializable, thus no monad, or use the WASH hack.
04:36:34 <dcoutts> JaffaCake, is that something I can do, or do I need to ask you to do it?
04:36:36 <JaffaCake> dcoutts: I'll have a look
04:36:39 <dcoutts> cheers
04:37:11 <norpan> kzm: nice patch comment :)
04:39:11 <kzm> :-)
04:39:27 <kzm> I fixed inits and tails (just recurse over your init and tail - silly me)
04:39:31 <norpan> kzm: can you record your changes to UTF8 as well?
04:39:39 <kzm> I thought I did?
04:39:48 <JaffaCake> dcoutts: ok, you've got he same settings for email as GHC, with the email address for notifications set to gtk2hs-devel@lists.sourceforge.net 
04:39:57 <norpan> i get nothing when i pull
04:40:00 <dcoutts> JaffaCake, thanks very much.
04:40:08 <doublec> musasabi, You could keep them in memory but it does limit what you can do.
04:40:14 <kzm>     M ./Data/ByteString/UTF8.hs -1 +251
04:40:29 <kzm> Hmm.. strange.  I'll check the repos (darcs check)
04:40:52 <norpan> i don't know this darcs stuff, but i get nothing when i do "darcs pull"
04:40:57 <norpan> i got the change in Bench.hs
04:41:08 <vincenz> :(
04:41:12 <kzm> do 'darcs changes -s | less'
04:41:22 <kzm> and 'darcs check'
04:41:55 <norpan> oh
04:41:58 <norpan> i got it thanks
04:42:00 <kzm> and 'darcs diff -u -p "make bench"'
04:42:06 <kzm> Great.
04:42:23 <norpan> is there a better way to use it than build/install?
04:42:24 <musasabi> doublec: and how do you recover from crashes?
04:42:28 <norpan> or simpler?
04:42:35 <doublec> musasabi, you don't :)
04:42:39 <doublec> I agree that serialising is good.
04:43:00 <musasabi> doublec: which is kind of problematic since we really want to give ACID guarantees with HAppS
04:43:31 <kzm> One question: maximum and minimum - they should show the character with maximum code point value?
04:43:52 <kzm> (the single byte encodings show the char with the maximum representation value)
04:43:58 <norpan> kzm: a little unused to darcs, it didnt't report that it updated the file and then i looked at the wrong file :)
04:44:12 <doublec> musasabi, yes, that's one of the things that interests me about it.
04:44:12 <kzm> In general, all functions should behave as List/Char version composed with unpack, no?
04:44:32 <musasabi> doublec: I think there are some solutions to this but it needs someone to think about it for some days.
04:44:34 <kzm> darcs is easy to get used to.
04:44:37 <norpan> kzm: if you ask me, yes
04:45:03 <kzm> Although I worry about incorporating the fusion stuff dons keep advertising. :-)
04:45:04 <norpan> f list = unpack (f (pack list))
04:45:18 <norpan> ==
04:45:46 <kzm> f bs = [pack] List.f . unpack
04:46:08 <kzm> f bs = [pack .] List.f . unpack  -- the first pack if f :: ... -> [Char]
04:46:09 <norpan> yes
04:46:26 <kzm> Okay, I'll fix the 8-bit minimum/maximums.
04:46:45 <kzm> Presumably, they should only return valid characters in the encoding?
04:47:01 <norpan> and sort
04:47:06 <kzm> I.e. for ASCII, maximum bs < 128 for all bs?
04:47:23 <kzm> So.  Small bug to fix there.
04:47:36 <kzm> Of course, sorting of characters depends on locale.
04:48:33 <norpan> one optimization step for UTF-8 bytestring is to use prelude definition (with head/tail instead of pattern matching) instead of pack/unpack
04:48:46 <norpan> i've done that for foldr/foldl
04:49:33 <musasabi> map is evil for UTF-8
04:49:38 <norpan> it is
04:49:57 <vincenz> can anyone explain this:
04:49:57 <vincenz> You are not allowed to post to this mailing list, and your message has
04:49:57 <vincenz> been automatically rejected.  If you think that your messages are
04:49:57 <vincenz> being rejected in error, contact the mailing list owner at
04:50:09 <vincenz> haskell-cafe-owner@haskell.org.
04:50:22 <musasabi> vincenz: you need to post from the address you are subscribed to haskell-cafe.
04:50:25 <kzm> Anyway - I have some chores to attend to.  I've pushed the inits/tails stuff as well.  If anybody wants to add the remaining stuff to utf-8 or improve benchmarks, please go ahead.
04:50:46 <vincenz> oh yeah, wrong email account :D
04:51:40 <kzm> One thing to consider is whether it would make sense to distinguish between different encodings with a phantom type parameter.
04:51:45 <norpan> kzm: if i do it you will see it in my repo
04:51:48 <kzm> (somebody suggested it here earlier)
04:52:23 <kzm> Would probably increase safety quite a bit.
04:52:33 <kzm> And one could consider making a class for the operations.
04:52:34 <norpan> how would that be done exactly
04:53:28 <kzm> adding a type parameter to the ByteString type
04:53:46 <kzm> declaring a specific (constructor-less, I think) data type for each encoding.
04:54:06 <norpan> how would you then go about to use bytestrings functions when implementing bytestring.utf8?
04:54:17 <norpan> the types won't match
04:54:19 <kzm> and having bytestrings be of type "ByteString UTF8" etc.
04:54:31 <vincenz> What's the use of IntMap over Map Int
04:54:33 <norpan> unsafeCastType?
04:54:35 <kzm> You would need to proxy them, I suppose.
04:55:05 <kzm> or perhaps they could have default implementations in the class?
04:55:09 <musasabi> kzm: that would work, and one does not even need a typeclass.
04:55:33 <musasabi> kzm: just one operation: castByteString :: ByteString a -> ByteString b.
04:56:12 <vincenz> musasabi: you know by any chance the use of IntMap over (Map Int) ?
04:56:21 <musasabi> the UTF8 module functions would only take "ByteString UTF8" as input while the generic (ByteString and ByteString.Char8 would take "ByteString a")
04:56:31 <musasabi> vincenz: IntMap is faster.
04:56:32 <kzm> musasabi, which would convert, or simply change the type?
04:56:39 <vincenz> ah
04:57:23 <musasabi> kzm: only change type.
04:57:44 <kzm> You probably want the "reinterpret" cast -- e.g. a multipart MIME could be broken into substrings, and each substring could have its encoding changed depending on Content-Type.
04:57:59 <kzm> (hmm...that would probably be too dynamic for the compiler?)
04:58:02 <musasabi> kzm: you can make conversion functions too but a simple cast is also needed.
04:58:08 <kzm> Yep.
04:58:16 <norpan> unsafeCastByteString
04:58:17 <musasabi> kzm: it works you need just to sprinkle the code with casts.
04:58:25 <musasabi> norpan: there is nothing unsafe about it.
04:58:34 <norpan> it is if we have UTF-8
04:58:53 <musasabi> norpan: it is no more unsafe than reading a file as UTF8.
04:58:59 <kzm> unsafe is as unsafe does :-)
04:59:03 <norpan> that's why you shouldn't be allowed to do that
04:59:11 <kzm> huh?
04:59:15 <norpan> hehe
04:59:30 <musasabi> kzm: you need to check that it is valid when reading it.
04:59:30 <norpan> i like the idea that castByteString -> UTF-8 will do validatoin
04:59:32 * kzm thought irony meant hard, heavy, and metallic.
04:59:59 <norpan> well, we must think some more
05:00:08 <kzm> Well - *I* like the fact that any garbage is preserved when I do pack . unpack, regardless of encoding.
05:00:12 <norpan> i will fix replicate now, that was the biggest number in the bench :)
05:00:14 <musasabi> norpan: then people will want something faster, for the cases where they need the performance. Then again I will happily use Char8 ;)
05:00:25 <kzm> Yeah, shouldn't be hard (replicate)
05:00:32 <norpan> not hard at all
05:00:36 <musasabi> kzm: garbage should create an error with UTF8.
05:01:11 <musasabi> kzm: if it is not valid UTF8 you should not be using the UTF8 module.
05:01:45 <musasabi> kzm: or should each function (like length) check whether the ByteString UTF8 is valid?
05:01:46 <norpan> we'll see
05:01:55 <kzm> Right.  However, people shouldn't be using the funny quotes in Win1252 as apostrophes either.
05:02:38 <kzm> musasabi, currently, I suppose they do - after all, they convert to Chars.
05:03:02 <kzm> We should probably cache the Charwise lenght, though.
05:03:23 <kzm> Would make an ASCII-only utf-8 string much faster for many things.
05:03:24 <norpan> length has a special implementation so it does not check
05:03:30 <musasabi> "unpack . pack = id" should be true of UTF8. But "pack . unpack /= id" for the ByteStrings with invalid UTF8.
05:04:06 <kzm> length can just count 0xxxxxxx bytes, I guess.
05:04:34 <musasabi> that breakes things in nasty ways.
05:04:36 <norpan> it counts 10xxxxxx bytes and subtracts that from l
05:04:48 <musasabi> because length /= normal definition of length then.
05:05:03 <norpan> length is the length of the string in Chars
05:05:14 <norpan> which is the normal definition
05:05:33 <musasabi> "length fps = if null fps then 0 else 1 + length (tail fps)" <- the actual function should be equal to this.
05:05:40 * dcoutts finnishes setting up the new Gtk2Hs bug tracker
05:05:43 <dcoutts> http://hackage.haskell.org/trac/gtk2hs
05:05:49 <dcoutts> seem ok?
05:05:54 <norpan> musasabi: it is if the utf8 is valid
05:05:56 <dcoutts> what have I forgotten?
05:06:02 <dcoutts> (appart from adding some bugs :-) )
05:06:12 <kzm> but if it is not, you should except.
05:06:19 <musasabi> norpan: but having it different for invalid utf8 changes things. One can silently get invalid results.
05:07:03 <norpan> well, currently it's assumed that the string is correct (even if there are checks)
05:08:01 <norpan> i think the best solution would be to allow any bytestrings but only guarantee correctness if they are valid, and provide validator function
05:08:19 <norpan> and if that can be done with the phantom types and type conversion so much the better
05:08:58 <norpan> otherwise you'd have to do really stupid things, like validate the whole string to do "last"
05:10:26 <musasabi> norpan: have a "castByteString :: ByteString a -> ByteString b" "convert :: (Monad m, Convert a b) => ByteString a -> m (ByteString b), and "validate :: Monad m => ByteString a -> m ()". cast and convert as global and validate in each module.
05:10:51 <norpan> and call the simple cast for unsafe
05:10:52 <musasabi> norpan: IO should perform validation, only then we need to add State.
05:11:30 <norpan> i don't understand that last bit
05:11:58 <musasabi> valid :: DecodeState a s => ByteString a -> s -> m s
05:12:56 <norpan> what's with the state?
05:13:03 <musasabi> and convert :: (Monad m, Convert a b, DecodeState a s1, DecodeState b s2) => ByteString a -> s1 -> s2 -> m (ByteString b, s1, s2)
05:13:15 <musasabi> norpan: that is required for some encodings.
05:13:26 <norpan> it is?
05:13:29 <musasabi> yes
05:13:35 <norpan> either the string is valid or it's not?
05:13:40 <musasabi> no.
05:13:55 <musasabi> There is a state associated and different things are valid in different states.
05:13:57 <norpan> i think that's a tautology so you can't say no
05:14:28 <musasabi> And e.g. if you do linewise IO and the state changed 10 lines back you need to know what the current state is when validating that line.
05:15:03 <norpan> i still don't understand: we have a ByteString, and either it's valid or it's not
05:15:07 <norpan> why is it more complicated?
05:15:16 <vincenz> xerox: ping
05:15:29 <musasabi> norpan: lets take UTF8 as an example because that is simpler.
05:15:51 <norpan> sure
05:16:12 <kzm> one example (IIUC) could be MIME multipart.
05:16:39 <vincenz> dcoutts: ping
05:16:46 <dcoutts> vincenz, pong
05:16:46 <musasabi> norpan: we read N bytes of UTF8 data from a socket. Now the amount we have readed happens to end in the middle of one character. Clearly the String is not valid. But concatenating it with the rest of the input is valid.
05:16:59 <vincenz> dcoutts: with cairo, is it feasible to get the current amount that has been translated?
05:17:00 <kzm> or blocks of any multi-byte encoding, which happens to break a multi-byte character.
05:17:12 <vincenz> dcoutts: or will I have to make a IORef and then use liftIO to keep track of htis count?
05:17:16 <dcoutts> vincenz, you can get the current transformation matrix
05:17:31 <vincenz> dcoutts: yeah but that's opaque
05:17:41 <dcoutts> no, it's a concrete matrix
05:17:48 <musasabi> (and when we have solved this, I get to the ISO-2022 and why we really need state even if you have solved this.)
05:17:58 <norpan> musasabi: but that is something else, i am talking about when we have a complete bytesting
05:18:00 <vincenz> dcoutts: then why does haddock not show the data constructors?
05:18:00 <kzm> musasabi, you probably shouldn't worry about encoding before you've got the complete request?
05:18:08 <vincenz> dcoutts: that info ain't exported
05:18:14 <dcoutts> vincenz, oh, hmm
05:18:36 <dcoutts> vincenz, well you could transform (0,0) and see where it ends up?
05:18:59 <vincenz> how?
05:19:16 <musasabi> kzm: and if I get just a stream of data from the network that is e.g. utf8 text with XML tags as the requests?
05:19:20 <vincenz> nope
05:19:24 <vincenz> there's no functionality to get any of this kind of info
05:19:28 <dcoutts> transformPoint
05:19:32 <vincenz> I guess I'l just use an IORef
05:19:41 <vincenz> dcoutts: dne
05:20:09 <musasabi> norpan: we can go to the complete ByteString next when we have solved this one.
05:20:15 <vincenz> ah
05:20:16 <vincenz> in .Matrix
05:20:37 <dcoutts> oh and the constructor is exported
05:20:39 <norpan> musasabi: solved?
05:21:35 <musasabi> The XML parser clearly should use encodings, but if we feed it [ByteString] from the socket then those ByteStrings may be invalid UTF8 even if their concatenation is valid.
05:21:58 <norpan> well sure
05:22:19 <norpan> but the concatenation could not be invalid if the bytestrings are all valid
05:22:35 <musasabi> yes
05:22:58 <vincenz> dcoutts: ah yes
05:23:02 <norpan> so just make the chunks all valid
05:23:11 <vincenz> dcoutts: could you elucidate on the different parms?
05:23:15 <norpan> by not splitting in mult-byte characters
05:23:28 <musasabi> How without using a state parameter in the validation function?
05:23:30 <dcoutts> vincenz, I was just going to add that yeah
05:23:59 <vincenz> heh
05:23:59 <vincenz> grrr
05:24:13 <vincenz> I can only get the Matrix inside the render
05:24:13 <norpan> musasabi: we could add longestValid :: ByteString a -> (ByteString UTF8, ByteString a)
05:24:18 <vincenz> and I basically want to get the final matrix
05:24:20 <vincenz> at the end
05:24:32 <vincenz> and then after having done renderWithDrawable....resize the drawarea
05:24:46 <norpan> there is no point in passing split-up characters
05:24:55 <norpan> that will just mess things up
05:24:58 <kzm> musasabi, add a layer over the raw bytestring layer, that produces a blocks of valid bytestrings in the relevant encoding?
05:24:59 <musasabi> norpan: thus the "ByteString a" serves as a State parameter. + we need to concatenate it with the next line thus we have a state parameter there too.
05:25:20 <norpan> but that's beyond the ByteString datatype
05:25:35 <musasabi> I will now try to explain ISO-2022-JP and why we want the State there.
05:25:39 <kzm> castByteStrings :: [ByteString Word8] -> [ByteString a]
05:25:41 <norpan> gah ISO-2022
05:25:48 <norpan> just kill ISO-2022
05:25:50 <kzm> Hehe - I was worried we would get to this.
05:26:00 <norpan> and never use it again
05:26:13 <musasabi> norpan: the real world uses it.
05:26:22 <norpan> the real world should stop!
05:27:05 <norpan> i don't want to have to deal with 2022 when not dealing with it so i suggest we handle that extremely separate from everything else
05:27:31 <musasabi> ISO-2022 contains codes to switch from one way to encode characters to another ones. Thus when converting/validating we need to know in which encoding we are currently. But the encoding marked may have been in a previous ByteString. Thus we need to pass the current encoding to the conversion/validation functions and return the encoding in which we are in the end. Thus state parameters.
05:27:42 <norpan> i know
05:27:48 <norpan> but UTF-8 is not like that
05:27:55 <norpan> thus, no state parameters
05:28:08 <musasabi> norpan: it would be really sad to get an API that is not usable outside few "nice" encodings.
05:28:23 <norpan> you can probably add some special function just for 2022
05:28:35 <musasabi> norpan: of course if we have the state parameters we have solved the trailing bytes problem.
05:29:01 <norpan> well
05:30:17 <kzm> I think you would need to have the entire text in one string.  For buffered/streaming, a decoding layer, producing blocks with one coding only, or simply converting them to UCS-2/4.
05:30:21 <norpan> i suppose we can have both the simple interface (i.e. convertWithValidation :: ByteString a -> ByteString UTF8) and the more complex
05:30:23 <dcoutts> vincenz, yes you can only get the Matrix in the context of Render, since that's where it makes any sense
05:30:34 <dcoutts> it changes as you render different bits
05:31:16 <musasabi> norpan: and we can provide a simpleConvert :: (Monad m, DecodeState a NoState, DecodeState b NoState, Convert a b) => ByteString a -> m (ByteString b) = convert a = do (x,_,_) <- convert a NoState NoState; return x
05:31:19 <norpan> and for simpler encodings, the more complex interface could default to using the simple
05:31:45 <norpan> this way you needn't worry about it but for 2022
05:31:58 <musasabi> Of course that would encourage people to write code that is hard to convert to use different complex encodings.
05:32:15 <vincenz> dcoutts: I just used a n IORef :)
05:32:24 <dcoutts> vincenz, ok
05:32:38 <vincenz> tx
05:32:53 <norpan> musasabi: that is a point
05:33:06 <norpan> but iso-2022 really is a mess
05:33:27 <norpan> so the sooner people stop using it the better
05:35:11 <musasabi> norpan: I would personally probably use the state parameters to handle multibyte character boundaries in an elegant fashion.
05:35:30 <musasabi> because the mechanism makes it quite possible.
05:39:47 <RyanT5000> anyone know, offhand, what crtbegin.o does, and why ghc wants to link with it?
05:40:27 <musasabi> RyanT5000: you are on windows and gcc paths are messed up?
05:40:33 <RyanT5000> yes :)
05:40:48 <RyanT5000> in fact, i'm trying to untangle them right now
05:41:03 <RyanT5000> i'm pretty sure i've gotten gcc and visual studio binaries mixed up in my build paths
05:41:08 <musasabi> it is something needed by C code but ghc and gcc manage to confuse each other.
05:41:12 <RyanT5000> which causes segfaults at runtime (although surprisingly few)
05:41:25 <RyanT5000> hm, any idea how to fix it?
05:41:37 <eivuokko> What is the actual error?
05:41:50 <RyanT5000> C:\ghc\ghc-6.5\gcc-lib\ld.exe: crtbegin.o: No such file: No such file or directo
05:41:50 <RyanT5000> ry
05:42:20 <eivuokko> Is your ghc slef-compiled on snapshot?
05:42:26 <RyanT5000> no
05:42:31 <RyanT5000> er, it's snapshot
05:42:44 <eivuokko> Did that snapshot ever work?
05:42:46 <RyanT5000> yep
05:42:56 <RyanT5000> at least i'm pretty sure it did
05:42:59 <eivuokko> Hmh.  Then I'd install it again.
05:43:11 <RyanT5000> hm
05:43:18 <RyanT5000> i'll try updating it to a new snapshot
05:43:27 <eivuokko> It is not suprising for ghc binary distr thingy to copy less than enough files on snapshot.
05:43:32 <eivuokko> It never works for me
05:43:40 <RyanT5000> hm
05:44:08 <eivuokko> Hmh
05:44:12 <RyanT5000> actually.... maybe i should try 6.4.2
05:44:17 <RyanT5000> since it's, like, stable
05:44:31 <eivuokko> I thought daily builds for darcs head haven't been compiled succesfully on Windows for ages.
05:44:54 <eivuokko> for ages = months
05:44:55 <musasabi> an automatic testing machine for windows would be nice.
05:44:59 <RyanT5000> i have 3 distros set up right now
05:45:10 <musasabi> as most developers don't seem to have access to windows machines.
05:45:13 <RyanT5000> 6.4.2, 6.5, and Visual Haskell's version (6.5)
05:45:29 <RyanT5000> musasabi: vmware/qemu?
05:45:37 <RyanT5000> i mean it'd suck, but it could be done
05:45:55 <RyanT5000> it's only like 30% slower than running natively, for stuff like compiling
05:45:58 <eivuokko> musasabi, it takes maybe few days work to get windows env to work.  There's plenty of wonderful bugs that need fixing in base and mingw usage etc.
05:46:13 <RyanT5000> yeah, and we windows people don't appreciate that :P
05:46:24 <RyanT5000> i found out last night that my linux laptop doesn't support DRI
05:46:29 <RyanT5000> becuase the card is too old
05:46:30 <musasabi> RyanT5000: I don't even have a windows license and setting up an automated build & testing system with an OS I don't use at all is non-trivial.
05:46:32 <eivuokko> musasabi, I could do daily builds, I guess, if ghc ever compiled and worked out-of-box for me.
05:46:46 <RyanT5000> musasabi: oh yeah,  the whole license issue
05:46:58 * RyanT5000 whistles
05:46:59 <Saulzar> RyanT5000, I got it to work - no segfault, but I had to foreign export the main and use a C file with main to wrap it...
05:47:16 <RyanT5000> was that to prevent the crash or just to get it to work?
05:47:27 <Saulzar> Just to get it to run
05:47:28 <musasabi> when I do libraries I get occasional reports from people saying either "I worked for N hours and it finally worked" or "I tried and it didn't even compile".
05:47:32 <Saulzar> But it doesn't crash either..
05:47:46 <RyanT5000> Saulzar: i'll send you some of my stuff
05:50:46 <vincenz> dcoutts: ping
05:50:52 <dcoutts> vincenz, pong
05:51:01 <vincenz> dcoutts: is it possible to draw a dashed crircle/
05:51:05 <vincenz> circle
05:51:06 <dcoutts> yep
05:51:08 <vincenz> (laggy ssh)
05:51:09 <dcoutts> setDash
05:51:29 <vincenz> thx!
05:51:52 <Saulzar> RyanT5000, Okay - could be one of many differences I guess.
05:52:30 <RyanT5000> yeah, i'm trying to clean out the cruft now
05:52:48 <RyanT5000> i'm gonna try to get a minimal program running
05:52:52 <RyanT5000> maybe without crashing!
05:52:56 <Saulzar> Hehe..
05:52:58 <RyanT5000> because i'm going to do my entire build process in msys
05:53:08 <RyanT5000> right now my build is setup retardedly
05:57:57 <RyanT5000> god i hate windows
05:58:10 <noes> Is there a haskell compiler environment i can fit in less than 50Mb on linux?
05:58:38 <RyanT5000> that seems like an odd constraint; what are you trying to do?
05:58:52 <noes> me?
05:58:55 <RyanT5000> yep
05:59:22 <noes> install a haskell compiler on a usermode linux server i hire.
05:59:29 <RyanT5000> ah
05:59:38 <Philippa_> does it definitely have to be a compiler?
06:00:17 <Saulzar> How big is nhc/yhc?
06:00:21 <vincenz> Philippa_: you're thinking of something like ghci?/
06:00:33 <Igloo> hugs is the obvious choice
06:00:53 <vincenz> Igloo: ooh, maybe you know, is there any way to stack a dynamic amount of similar monads on top of IO?
06:00:57 <vincenz> (on top of each other)
06:01:21 <noes> so hugs is the recommendation. how big are your ghc installs?
06:01:52 <Igloo> IIUC I think you could do it with a class, but I don't have time to go into details ATM
06:02:04 <vincenz> IIUC?
06:02:12 <Igloo> If I Understand Correctly
06:02:15 <vincenz> ah
06:02:22 <vincenz> but in theory it's feasible
06:02:29 <Igloo> The ghc6 deb (without profiling libraries) claims to take 143M when installed
06:03:04 <Igloo> Oh, that's on amd64. 81M on x86.
06:03:10 <vincenz> ghc6 = 82mb on ubuntu
06:03:51 <ibid> hum 50MB sounds small even for an UML installation
06:04:17 <vincenz> you could use extreme compression and commpress it to 20 kb
06:05:04 <noes> well. 50Mb isnt that strict, it is just that these vps have backed up data and every Mb cost silly amounts of money when you pay for them each month.
06:05:18 <vincenz> noes: why would you want to backup ghc
06:05:24 <RyanT5000> how can i make gcc tell me where it's getting its include files from?
06:05:28 <RyanT5000> some kind of -v?
06:05:30 <noes> well, they dont know what is worth to back up.
06:05:50 <vincenz> noes: why do you need haskell on it? compile at home and then send there
06:06:29 <RyanT5000> does anyone know how many SoC submissions there have been so far to haskell.org?
06:06:36 <RyanT5000> or are they at liberty to disclose that
06:06:51 <jgraves> Ryan: use the -I option to give a list of include directories
06:07:01 <vincenz> yu oyou mean 'and'
06:07:01 <vincenz> unless tyou meant 'or are they not allowed to discloe that'
06:07:12 * vincenz sighs at his connection
06:07:18 <noes> vincenz: just checking if i could avoid that :)
06:07:24 <RyanT5000> vincenz: correct :)
06:07:33 <RyanT5000> <- not a morning person
06:07:38 <RyanT5000> @localtime ryant5000
06:07:49 <RyanT5000> apparently neither is lambdabot
06:08:06 <vincenz> 9am
06:08:11 <vincenz> oasisbot answered
06:08:19 <noes> anyway, thanks
06:08:21 <RyanT5000> huh
06:08:56 <RyanT5000> jgraves, i'm trying to figure out exactly which "SDL.h" it's including; sort of like the shell command "which"
06:09:18 <RyanT5000> oh wait nevermind
06:09:30 <RyanT5000> i'm used to "cannot find include file" being a fatal error
06:09:43 <jgraves> you could just run a find command to search for it too
06:09:50 <vincenz> it's not??????
06:09:51 <RyanT5000> so i assumed when i saw a bunch of undefined symbol errors it was finding it
06:10:00 <RyanT5000> apparently not
06:10:06 <vincenz> RyanT5000: undefined symbol errors has nothing to do with headers
06:10:15 <vincenz> but with libs
06:10:16 <Saulzar> Hmm, sure they're not linker errors?
06:10:24 <RyanT5000> sorry, undeclared symbols
06:10:32 <vincenz> still
06:10:35 <Saulzar> Maybe it has the header error at the top and keeps going...
06:10:36 <vincenz> libs
06:10:50 <RyanT5000> Graphics\UI\SDL\General.hsc:1:17: SDL.h: No such file or directory 
06:10:50 <RyanT5000> Graphics\UI\SDL\General.hsc: In function `SDL_main': 
06:10:50 <RyanT5000> Graphics\UI\SDL\General.hsc:54: error: `SDL_INIT_TIMER' undeclared (first use in this function) 
06:11:01 <vincenz> ah
06:11:12 <jgraves> what OS are you using?
06:11:12 <Saulzar> Well it's failing to include SDL ..
06:11:13 <vincenz> well therre you go "SDL.h" no such file
06:11:17 <RyanT5000> jgraves: windows
06:11:19 <RyanT5000> msys
06:11:27 <RyanT5000> vincenz yah i figured that out :)
06:11:45 <RyanT5000> i just had to scroll up several screens to find it
06:11:46 <jgraves> Is that part of Cygwin?
06:11:55 <RyanT5000> msys is sort of simmilar to cygwin
06:11:58 <RyanT5000> only with a lot less cruft
06:12:05 <RyanT5000> and it makes independent binaries
06:12:32 <jgraves> I didn't think there was a port of any Haskell compiler to msys.  Only cygwin.
06:12:45 <Saulzar> ghc runs independant
06:13:03 <Saulzar> Though I think they compile it from mingw/msys
06:13:30 <eivuokko> jgraves, msys is only used to run configure etc, resulting ghc is only dependent on mingw gcc (and binutils etc)
06:13:57 <jgraves> Ah, that's cool.
06:14:07 <eivuokko> jgraves, furthermore, cygwin builds (in either targeting mingw or cygwin) havent worked for a while, I think
06:14:37 <jgraves> It's usally easy to port Unix code to run under Cygwin.  But running standalone is more difficult.
06:15:22 <jgraves> Interesting.
06:15:31 <RyanT5000> we should make half an OS
06:15:41 <jgraves> Ah well, gotta go.
06:15:46 <RyanT5000> like an all-encompasing haskell runtime environment
06:16:08 <RyanT5000> like the java vm except good
06:16:23 <eivuokko> Well, you probably like yhc then..
06:16:29 <RyanT5000> haven't heard of it :)
06:16:41 <RyanT5000> i love it how i always say stuff in here like "i wish..." 
06:16:43 <RyanT5000> and then someone's like
06:16:47 <RyanT5000> "@where blah"
06:18:29 <RyanT5000> yah sounds cool, although i really meant something that did file management etc.
06:18:39 <Oejet> @where #haskell-blah
06:18:39 <lambdabot> I know nothing about #haskell-blah.
06:18:59 <RyanT5000> so that the only connection to the outside world would be a virtual NIC, screen, keyboard, mouse, etc.
06:20:02 <Oejet> Something like a functional virtual machine?
06:20:18 <RyanT5000> hm? something like a virtual processor and OS for haskell
06:20:40 <RyanT5000> sort of like User Mode Linux in theme
06:22:51 <RyanT5000> yay, sourceforge is back up
06:27:26 <roods> what kind of scopping does haskell use?
06:28:03 <ced-2> everything
06:28:19 <roods> how do you set the scope?
06:28:38 <shapr> For what? Can you give a specific example?
06:30:09 <RyanT5000> does anyone else working on windows notice that configure scripts take about 10 times longer to run than on linux?
06:30:18 <RyanT5000> if not 100 times longer
06:30:23 <eivuokko> RyanT5000, yeah, depends
06:30:34 <RyanT5000> is there a solution?
06:30:37 <RyanT5000> and what causes it?
06:30:38 <eivuokko> RyanT5000, I usually boycot configure scripts if I can :)
06:30:44 <RyanT5000> hm
06:30:46 <roods> i'm talking about dynamic scoping
06:31:02 <RyanT5000> i'm not exactly comfortable with the unix build system, to be honest
06:31:06 <eivuokko> Windows is slower to start executables, and configure scripts typically run plenty.
06:31:11 <RyanT5000> hm true
06:31:25 <eivuokko> Also, none of msys thingies use faster dll loading techniques, as binutils don't support them.
06:31:32 <RyanT5000> right
06:31:51 <Saulzar> RyanT5000, Yeah, my SDL configure took about an hour!
06:31:56 <shapr> roods: You could use a state monad?
06:32:02 <eivuokko> Cygwin is even slower, it got all kinds of shader-process bookkepping to do.
06:32:05 <Saulzar> On a Celeron 500 or so
06:32:17 <eivuokko> *shared-process
06:32:29 <RyanT5000> Saulzar: ouch
06:32:42 <eivuokko> Saulzar, ergh.
06:32:45 <RyanT5000> however, i think there's a mingw build of SDL you can just download
06:32:51 <eivuokko> RyanT5000, right.
06:32:59 <eivuokko> RyanT5000, Are you using Lemmih's bindings?
06:33:01 <RyanT5000> i'm building freetype 2 and SDL_ttf, which i think don't have mingw builds
06:33:01 <RyanT5000> yes
06:33:11 <eivuokko> RyanT5000, I had patch for graphics part of them to make cabal work easily
06:33:22 <RyanT5000> what do you mean?
06:33:31 <Saulzar> Btw. the sound worked fine for me, using SDL_mixer
06:33:34 <RyanT5000> i was able to install Core with the normal commands
06:33:40 <eivuokko> Ah cool
06:33:41 <RyanT5000> Saulzar: awesome
06:34:11 <Saulzar> Can't run it on the machine I compiled on but works under wine :)
06:34:23 <RyanT5000> Saulzar: does mixer support 3d sound?
06:34:35 <RyanT5000> not that my boardgame-turned-computer-game really needs it
06:34:44 <Saulzar> No, I don't think so.
06:34:59 <eivuokko> Want to help to make bindings to direct sound? :)
06:35:06 <RyanT5000> want to, yes
06:35:09 <RyanT5000> have time to, no
06:35:15 <eivuokko> Heh
06:35:29 <RyanT5000> my summer is dedicated to getting a client written for my game
06:35:32 <Saulzar> Do the alsa bindings work cross platform?
06:35:38 <RyanT5000> and hopefully doing SoC
06:35:50 <Saulzar> Er
06:35:55 <RyanT5000> oh wait actually i can probably use OpenAL
06:35:57 <Saulzar> openAl
06:36:31 <eivuokko> Aren't those bindings pretty unixy?  Might be lots of work.
06:36:50 <Saulzar> Well, I think they come with ghc currently...
06:36:52 <RyanT5000> there's an OpenAL binding in the standard libs
06:37:11 <RyanT5000> you know what make needs?
06:37:13 <RyanT5000> a progress bar
06:37:26 <RyanT5000> i'm sorry unix people, but progress bars are just nice to have
06:37:33 <RyanT5000> (not that visual studio has one)
06:37:44 <eivuokko> Well, openal bindigs are disabled on normal builds
06:37:49 <eivuokko> (for Windows)
06:37:49 <Saulzar> It would take 99% of the time to go up to 1% then from 1% to 100% in an instant :)
06:38:10 <RyanT5000> lol
06:38:21 <RyanT5000> i mean a useful progress bar
06:38:27 <RyanT5000> not a microsoft progress bar
06:38:52 <eivuokko> Progress bars always lie.  Except when they are ready.
06:38:54 <RyanT5000> you could have it collect build statistics automatically for each file
06:38:58 <Saulzar> You measure it by the console scroll rate
06:39:11 <RyanT5000> Saulzar: but i don't know how far it is going to scroll
06:39:44 <RyanT5000> when i'm building my own stuff, it's OK, because i can just learn what the build looks like
06:39:56 <RyanT5000> but building, e.g., freetype 2
06:40:05 <RyanT5000> i have no idea whether it will be another 5 minutes or another 3 hours
06:40:20 <RyanT5000> or, as the case apparently was, another 30 seconds
06:41:00 <xerox> make doesn't either.
06:41:07 <RyanT5000> but it could
06:41:31 <xerox> Not as it is,it's stateless.
06:41:36 <RyanT5000> hm
06:42:20 <RyanT5000> well i'm not saying it'd be easy to implement, but it's well documented that people are happier using software when they know how long an operation will take
06:42:24 <RyanT5000> even if it's a lie
06:42:30 <RyanT5000> not that i'm advocating a lie
06:42:47 <RyanT5000> just that i'd rather see it do something that "sort of" represents the progress
06:43:00 <RyanT5000> like just a count of the targets
06:43:58 <roods> anyone here use J and switch to haskell?
06:44:06 <RyanT5000> J?
06:44:12 <roods> yes
06:44:23 <xerox> RyanT5000: ghc --make could.
06:44:39 <RyanT5000> hm
06:44:43 <RyanT5000> yeah
06:44:49 <RyanT5000> roods: never even heard of it
06:44:50 <roods> you've use it?
06:45:03 <RyanT5000> what's it like?
06:45:12 <xerox> RyanT5000: in fact it gives you some data... the number of the module being compiled over the total.
06:45:15 <roods> RyanT5000: like APL w/o the funny characters
06:45:25 <RyanT5000> xerox: yeah, i've noticed that, and it's nice
06:45:32 <RyanT5000> hm
06:46:27 <norpan> i probably should make a lazy unpack
06:46:50 <norpan> for my ByteString.UTF8
06:47:02 <xerox> 凄い！
06:47:15 <RyanT5000> i think i've asked this before, but how do you do internationalization in haskell?
06:47:30 <RyanT5000> just make yourself a module MyApp.Strings
06:47:35 <RyanT5000> with string formatter functions in it?
06:47:42 <norpan> i made a gettext binding once
06:47:57 <RyanT5000> hm
06:48:21 <norpan> it was in the haskell-i18n cvs repo
06:48:29 <norpan> i don't know if it's still there
06:51:29 <RyanT5000> warning: passing arg 2 of `execv' from incompatible pointer type
06:51:30 <RyanT5000> wtf?
06:51:40 <RyanT5000> i didn't know such things still existed
06:51:55 <eivuokko> Pointers?
06:52:05 <RyanT5000> incompatible pointer types
06:52:19 <RyanT5000> i presume that means something like near vs. far
06:52:25 <eivuokko> const maybe?
06:52:29 <RyanT5000> maybei
06:52:38 <RyanT5000> actually, no, it's C
06:52:46 <eivuokko> C99 has const
06:52:49 <RyanT5000> well it's not my code and there weren't any errors
06:52:51 <jfoutz> that's the environment
06:52:53 <Igloo> No, it means the type
06:52:57 <RyanT5000> ah ok
06:53:02 <jfoutz> it should be char**
06:53:47 <jfoutz> oh wait...
06:53:51 <jfoutz> nevermind
07:02:17 <norpan> there are different pointer types in c, have always been
07:02:33 <norpan> p++ means different things depending on the size of the thing pointed too for instance
07:03:00 <RyanT5000> no i thought it was referring to "the wrong type of pointer" rather than "a pointer with the wrong type"
07:03:13 <RyanT5000> e.g.: 16-bit vs 32-bit
07:03:13 <norpan> ok
07:03:48 <dcoutts> dons, compareBytes seems broken it gives GT too much :-)
07:04:07 <dcoutts> compare (P.packByte 1) (P.packByte 2) == GT
07:04:17 <dcoutts> compare (P.packByte G) (P.packByte 1) == GT
07:04:19 <dcoutts> err
07:04:23 <dcoutts> compare (P.packByte 2) (P.packByte 1) == GT
07:04:24 <RyanT5000> how do i add a library path to the configuration with Cabal?
07:04:34 <dcoutts> dons, apparantly. and that can't be right :-)
07:05:28 <RyanT5000> i have my beautiful libSDL_ttf.a sitting there in /usr/local/lib, but it can't find it
07:05:40 <dcoutts> dons, we need another QuickCheck test I think.
07:05:51 <xerox> RyanT5000: ghc-options: -l... ?
07:06:18 <RyanT5000> ah in the cabal file
07:06:49 <eivuokko> RyanT5000, ghc doesn't look into msys paths automatically.
07:06:58 <RyanT5000> yeah, i found that out
07:07:53 <RyanT5000> hm... it checks /usr/lib though, right?
07:09:57 <RyanT5000> -lSDL_ttf should find libSDL_ttf.a right?
07:10:00 <RyanT5000> (under msys)
07:12:27 <Saulzar> RyanT5000, If it's in the lib path..
07:12:47 <Saulzar> RyanT5000, I've been installing everything in /mingw
07:13:08 <RyanT5000> well i'm doing this from within msys
07:13:44 <RyanT5000> how do i set the libpath?
07:16:27 <Saulzar> Does it have an env var?
07:16:34 <Saulzar> LD_LIBRARY_PATH?
07:17:26 <RyanT5000> nope
07:43:43 <vincenz> @pl \a b -> f a == f b
07:43:43 <lambdabot> (. f) . (==) . f
07:44:14 <vincenz> @type curry
07:44:15 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
07:44:33 <vincenz> @type (Control.Arrow.&&&)
07:44:34 <lambdabot> forall (a :: * -> * -> *) c' c b.
07:44:35 <lambdabot>         (Arrow a) =>
07:44:35 <lambdabot>         a b c -> a b c' -> a b (c, c')
07:44:39 <vincenz> @type (Control.Arrow.***)
07:44:40 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
07:44:40 <lambdabot>         (Arrow a) =>
07:44:40 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
07:44:57 <RyanT5001> is there a way to pipe a command through vi?
07:44:59 <RyanT5001> i want to do
07:45:08 <vincenz> @type curry(uncurry (==) . (f *** f))
07:45:09 <lambdabot> Not in scope: `f'
07:45:10 <lambdabot>  
07:45:10 <lambdabot> <interactive>:1:28: Not in scope: `f'
07:45:16 <RyanT5001> ghc-pkg describe (stuff) | vi | ghc-pkg update
07:45:17 <vincenz> @type \f -> curry(uncurry (==) . (f *** f))
07:45:18 <lambdabot> forall c b.
07:45:18 <lambdabot>               (Eq c) =>
07:45:18 <lambdabot>               (b -> c) -> b -> b -> Bool
07:45:39 <vincenz> @pl \f -> f *** f
07:45:39 <lambdabot> join (***)
07:45:50 <vincenz> @pl \f -> curry(uncurry (==) . (f *** f))
07:45:50 <lambdabot> curry . (uncurry (==) .) . join (***)
07:46:06 <Igloo> vincenz: Is it really necessary to fill the channel with this?
07:46:37 <RyanT5001> vincenz: lambdabot responds to PMs
07:50:53 <lightstep> where can i find a debian server with gtk2hs?
07:51:25 <dcoutts> lightstep, http://haskell.org/gtk2hs/download/
07:53:33 <lightstep> dcoutts, i want one which i can put into sources.list, with Packages.gz and all that.
07:54:16 <dcoutts> lightstep, that's not available yet
07:54:18 <RyanT5001> does anyone know how to export WinMain from a haskell file?
07:54:40 <lightstep> dcoutts, ok
07:54:43 <Cale> hi
07:54:50 <RyanT5001> i need a function called WinMain@16
07:54:52 <dcoutts> lightstep, sorry. It you want that you'll need to poke liyang and CosmicRay.
07:54:54 <vincenz> Igloo: sorry
07:55:17 <Saulzar> RyanT5001, I know one way.. and that involved foreign export and a C file :)
07:55:25 <norpan> hehe, optimizing UTF to get the same benchmark results as the others is easy, just add special case for < 128 to every function :)
07:55:38 <norpan> well, not all functions of course
07:55:59 <RyanT5001> can i do "foreign export ccall unsafe "WinMain@16" :: stuff"?
07:56:30 <RyanT5001> of course i have totally forgotten what stdcall does
07:58:27 <lightstep> RyanT5001, its the name for Pascal's calling convention
07:58:33 <RyanT5001> ah
07:59:43 <Saulzar> RyanT5000, I don't think so, you still have to link some other C code
08:00:17 <RyanT5000> well i'm already linking to the mingw32 standard libs
08:03:07 <liyang> lightstep: if you really trust me, I could put something up.
08:03:42 <lightstep> liyang, i already read how to create a local repository (in /tmp) in the apt howto, so it's fine now.
08:07:10 <liyang> lightstep: er, okay, but what goal does that achieve? You'll still have to download any packages manually...
08:07:25 <liyang> so you might as welll do dpkg -i for now.
08:07:35 <liyang> (group pub. Later. :)
08:08:12 <RyanT5000> Main.hs:39:0: Type signature given for an expression
08:08:17 <lightstep> liyang, i somehow damaged my apt system during an installation, so it now wants a "standard" source to be able to remove the gtk2hs package
08:08:31 <RyanT5000> foreign export stdcall "WinMain" winMain :: HINSTANCE -> HINSTANCE -> CString -> Int -> IO ()
08:08:40 <dcoutts> lightstep, sorry, ask a debian expert.
08:08:43 <RyanT5000> that's the line... what's wrong with it?
08:09:10 <lightstep> dcoutts, i'm trying that too.
08:09:13 <lightstep> thanks
08:09:30 <Lemmih> RyanT5000: Does it compile?
08:09:42 <RyanT5000> no, it gives me that error
08:09:47 <RyanT5000> oh, maybe i need -fglasgow-exts?
08:10:00 <Igloo> RyanT5000: Do you mean import?
08:10:02 <Lemmih> RyanT5000: -fffi?
08:10:03 <RyanT5000> ah ha
08:10:04 <RyanT5000> yeah
08:10:07 <Saulzar> Hmm, I don't think you can do that directly.
08:10:26 <Saulzar> You have to init/de-init the haskell runtime, if you just export that function it will crash
08:10:33 <RyanT5000> :(
08:10:50 <Saulzar> But you can make a wrapper main.c and call it
08:11:25 <Saulzar> Though linking is slightly annoying - I copied/pasted all the flags from ghc's --make, not sure if there is an easier way to do it
08:11:56 <norpan> can't you add objects even with --make?
08:12:15 <RyanT5000> there has to be a better way
08:12:32 <xerox> Do you think that the term "computer scientist" implies formal education, or something achievable on one's own too?
08:13:07 <Philippa_> it would imply a significant amount of formal knowledge, whether achieved on formal programs or not
08:13:11 <RyanT5000> xerox: there are plenty of "computer scientists" around today who graduated college before "computer science" was a degree
08:13:12 <norpan> if you don't tuck on master or bachelor or phd, then it's achievable on your own
08:13:29 <Philippa_> RyanT5000: yes, although most of them were doing the kind of maths that's still a significant part of the field
08:13:34 <RyanT5000> true
08:14:12 <xerox> I'm not sure, but I like the term.
08:14:25 <RyanT5000> oh... heh
08:14:29 <RyanT5000> i know the problem
08:14:30 <xerox> Do you have better synonyms for not-formally-educated-yet people?
08:14:36 <RyanT5000> linking the mingw libraries is unnecessary
08:15:12 <xerox> Philippa_: I don't mean formal as in maths, but formal as in schoolsystem, is that what you mean?
08:16:48 <Philippa_> that's what I mean by "formal programs". "formal knowledge" would I guess being having seen the formalisms, stuff like that
08:17:11 <Philippa_> I wouldn't be happy describing myself as a type theorist because much of my knowledge is informal, for example
08:17:23 <xerox> Right.
08:17:39 <Philippa_> that's not about "where did I get it?"
08:17:55 <Philippa_> it's a significant amount about never having bashed through the proofs though
08:21:47 <xerox> Philippa_: what term would you use for such a non-really-type-theorist-person? (-:
08:22:31 <Philippa_> hmm. See, the first that comes to mind is 'amateur type theorist', or possibler 'dabbler in type theory'
08:22:40 <xerox> Heh.
08:22:53 <Philippa_> the latter not suffering quite the same problem as the former, of course :-)
08:22:55 <Saulzar> 'Rotten hacker'?  :)
08:32:57 <RyanT5000> so if i type "ld -L/usr/local/lib -lSDL_ttf", it finds it
08:33:15 <RyanT5000> if i add -L/usr/local/lib -lSDL_ttf to my ld-options: in my .cabal
08:33:18 <RyanT5000> it can't
08:33:20 <RyanT5000> what gives?
08:35:17 <eivuokko> cabal/ghc doesn't use msys to run stuff and doesnt get path conversion
08:35:26 <RyanT5000> oh
08:35:34 <RyanT5000> well that explains it
08:35:53 <RyanT5000> so if i just copy libSDL_ttf.a into my gcc-lib dir that should be OK?
08:36:11 <eivuokko> I was jsut about to recommend that for your own working env
08:37:55 <eivuokko> And anyway, correct way to use such things in cabal is to write foo.buildinfo that has right fields
08:41:07 <shapr> Can anyone recommend a reliable virtual host that has a Debian option?
08:41:24 <Saulzar> RyanT5000, I would put them in the "default" mysys dir... 
08:42:00 <Saulzar> RyanT5000, For me it was /mingw which was the search path 
08:42:24 <Saulzar> The configure which ran picked it up from there and worked fine
08:42:47 <Saulzar> (That is /mingw/lib for libraries)
08:45:01 <dcoutts> dons, hmm ByteString.concat seems to be doing a lot of work. Why can't you just find the new total length and memcpy the strings in.
08:45:34 <dcoutts> dons, you seem to be trying to read the list lazily but the final result has to be packed anyway, so I don't see the point.
08:46:12 <sjanssen> dcoutts: dons is trying to reduce the load on the memory allocator (I've asked this question before)
08:46:26 <notanotheridiot> dcoutts: can I put your name down as a possible mentor for gstreamer bindings on SOC
08:46:34 <dcoutts> sjanssen, oh, hmm. ok. I don't quite see how it works.
08:46:48 <dcoutts> notanotheridiot, on the SoC trac you mean?
08:47:11 <notanotheridiot> dcoutts, just in my application
08:47:30 <dcoutts> notanotheridiot, you don't put possible mentors in your application I think.
08:47:54 <dcoutts> notanotheridiot, we do that after you apply I think. Unless you've read otherwise of course.
08:48:26 <xerox> dcoutts: "Interested Mentors" is okay to fill now
08:48:28 <Igloo> dcoutts: I think the idea is you only need 1 copy in memory
08:48:56 <notanotheridiot> fair enough - I'm just finishing it off, I'll post it through google in the next hour
08:49:12 <dcoutts> Igloo, hmm, I suppose so.
08:49:13 <Igloo> dcoutts: And you also don't need all the list constructors in memory
08:49:55 <dcoutts> notanotheridiot, xerox says it's ok, so there we go.
08:50:15 <dcoutts> xerox, I didn't see that on any of the other applications
08:50:18 <xerox> dcoutts: it's okay for mentors to do it, I mean :-)
08:50:36 <dcoutts> notanotheridiot, oh, ok. so don't put me down. I do that.
08:50:38 <xerox> dcoutts: I'm talking about the "== Interested Mentors ==\n * foo" part
08:50:44 * dcoutts is possibly confused
08:51:07 <xerox> It helps students in order to see who to contact to talk about the project
08:51:14 <dcoutts> right
08:51:42 <dcoutts> notanotheridiot, so I might but it in the trac, but you don't put possible mentors in your application. Is that all ok?
08:52:11 <xerox> dcoutts: do it only if you are interested in mentoring the project (-:
08:52:12 * notanotheridiot thinks he understands
08:52:21 <dcoutts> xerox, aye
08:56:46 <araujo> Hi!
08:56:48 * araujo back
08:57:20 <norpan> would it make sense to have a lazy unpack function
08:58:32 <Lemmih> I think it would.
08:58:57 <norpan> i think so too
08:59:39 <vincenz> Lemmih: hiya
08:59:53 <norpan> i wonder how much slower it would be
08:59:58 <Lemmih> vincenz: Yo.
09:00:06 <vincenz> Lemmih: you good at monads?
09:01:18 <norpan> if i make my UTF-8 unpack function lazy, do you think anyone will bother? :)
09:01:46 * vincenz needs some hlep with
09:01:47 <vincenz> http://www.haskell.org//pipermail/haskell-cafe/2006-May/015566.html
09:03:59 <vincenz> on another note
09:04:20 <vincenz> anyone know how to parse conditional expressions (!a, a && b, a || c && d) with parsec?
09:05:37 <Philippa_> "the obvious way"?
09:05:44 <Philippa_> much the same as you would arithmetic expressions, IOW
09:06:12 <vincenz> yeah just not sure how to do it
09:06:32 <vincenz> cause parsec is LL
09:06:34 <vincenz> nor LR
09:07:14 * vincenz tries something
09:07:16 <Philippa_> um, I don't see the problem. You know about chainl/chainl1?
09:07:35 <vincenz> afraid not
09:07:45 <Philippa_> *blink*
09:07:49 <Philippa_> you need to RTFM badly :-)
09:08:39 <vincenz> :D
09:09:42 <Philippa_> chainl is how you handle left-recursion
09:10:01 <vincenz> tx
09:11:54 <vincenz> something like this: conditionP = chainl termP do { reservedOp "||"; return . liftM2 $ (||)}
09:12:16 <Philippa_> yeah, that works
09:12:26 <vincenz> (I'm return monadic actions from my parser)
09:12:36 <musasabi> An activity-time plugin would be nice for lambdabot, estimating when an user is going to be back active on irc based on past usage patterns.
09:13:07 <Lemmih> heh
09:15:11 <xerox> musasabi: yay, please write it (-:
09:19:14 <Oejet> "xerox is in #haskell, spoke 3 hours and 31 minutes ago, and will speak in approximately 4 minutes from now".
09:19:39 <xerox> Evil.
09:20:06 <Saulzar> It can take into account thier response time given the name is highlighted 
09:20:23 <musasabi> Oejet: many people have roughly the same times they irc on different weekdays so approximating that shouldn't be that hard, of course it can guess wrong.
09:20:24 <xerox> And lambdy will say "Hell yeah!" when she get it right?
09:21:27 <dcoutts> xerox, did you see that application about doing something in Common LISP?
09:21:38 <xerox> dcoutts: oh, not yet!
09:21:55 <dcoutts> xerox, I put a comment on it that was visible to the student that we were not the appropriate organisation and marked it -2.
09:22:17 <dcoutts> xerox, so hopefully the student sees that and applies to another mentor organisation.
09:22:46 <Oejet> "xerox has a rate of 3.4 speling errors per sentence, up from 3.2 last week.
09:23:20 <sjanssen> Oejet: excellent idea
09:24:05 <psi> where do I find cabal 1.0.1? I tried to build c2hs with cabal 1.1.4 but I couldn't run Setup.hs.
09:24:23 <psi> my ghc came with cabal 1.0, and it's not supposed to work.
09:24:31 <xerox> dcoutts: which ticket # is it?
09:25:03 <dcoutts> xerox, no, it was a real student application
09:25:11 <dcoutts> not on the trac
09:25:24 <xerox> Ah, I can't see them.
09:25:41 <dcoutts> xerox, the thing is that now that it has a negative score you can't see it.
09:25:55 <xerox> No, I can't see mentor things in general.
09:26:30 <dcoutts> xerox, oh, you can't see the student applications? you're not registered as a mentor?
09:26:39 <xerox> dcoutts: that's right.
09:26:39 <vincenz> what's wrong with this
09:26:40 <vincenz> expressionMap :: forall m e. (MonadSequencer e m) => Map.Map String (Integer -> m Bool)
09:26:46 <psi> if c2hs is supposed to build with cabal 1.1.4, I can post the error somewhere. anyone know?
09:26:59 <vincenz> it complains on the .
09:27:02 <xerox> vincenz: you're not using all the type variables
09:27:06 <xerox> Ah.
09:27:36 <dcoutts> xerox, ok
09:27:48 <vincenz> why does it complain about hte .?
09:28:22 <Igloo> vincenz: Have you got extensions on?
09:28:42 <xerox> I think that after that it will complain about 'e' not being used in the actual type.
09:28:57 <vincenz> fixed
09:29:06 <vincenz> i just removed the forall bit
09:29:25 <xerox> Igloo is right, you need extensions for that.
09:30:06 <vincenz> yeah but apparently I don't even need the forall bit
09:30:18 <xerox> Howdy monochrom.
09:34:53 <vincenz> Igloo: could you notify me when you might have some spare time to look at how to do dynamic monad stacking
09:35:04 <vincenz> (if you want to, that is)
09:35:27 <Lemmih> Are you sure you really need that?
09:35:46 <iturk> hi there in order to request from the user a value an make a evaluation like in a switch in a language like C what is the best aproach in haskell ??
09:36:36 <vincenz> Lemmih: yeah
09:36:45 <Lemmih> iturk: Seen 'case'?
09:38:19 <iturk> or usually its better to use blocks "|"
09:40:14 <norpan> you can use | in a case statement
09:40:20 <norpan> case x of
09:40:28 <norpan>   Foo a | a > 0 -> ...
09:40:36 <Skymarshal> Where can I find a "Haskell and Eclipse on Mac OS X" instal howto? Google doesn't help much.
09:41:53 <xerox> Skymarshal - <http://www.haskell.org/ghc/> has a GHC.dmg package ready for use.  I don't know about Eclipse.
09:43:06 <psi> xerox: does it? the os x binary is not there, but perhaps there's an older version somewhere.
09:43:09 <Skymarshal> xerox: It says "Coming soon" on http://www.haskell.org/ghc/download_ghc_642.html#macosx
09:43:35 <psi> I know there's a dmg for 6.4.1
09:44:00 <xerox> Skymarshal: psi is right, there is one for 6.4.1.
09:44:00 <psi> http://www.haskell.org/ghc/download_ghc_641.html#macosx
09:44:55 <Skymarshal> Ok, got that. Does anybody has a clue how to get Eclipse involved?
09:45:21 <psi> eclipse has a built in system for installing new plugins I believe
09:46:59 <psi> there are instructions at the eclipsefp site
09:47:20 <gordx> @seen kzm
09:47:21 <lambdabot> kzm is in #haskell and #haskell-overflow. I last heard kzm speak 4 hours, 17 minutes and 2 seconds ago.
09:47:29 <gordx> @seen kzm_
09:47:30 <lambdabot> kzm_ is in #haskell and #haskell-overflow. I don't know when kzm_ last spoke.
09:47:33 <Skymarshal> ok. thanks!
09:48:54 <vincenz> @seen nealar
09:48:55 <lambdabot> I haven't seen nealar.
09:48:58 <psi> is it a good environment for haskell dev? I've only tried it briefly.
09:49:53 <norpan> hmmm lazy vs. strict unpack seems to be about 20% slower (when you need the whole list, otherwise it can be faster of course)
09:54:55 <gordx> Hmmm... Question on SoC applications for someone.
09:55:10 <dcoutts_> ask away
09:55:19 <gordx> How much Haskell experience is recommended?
09:55:29 <dcoutts_> how much have you got?
09:55:45 <gordx> Like... One assignment.
09:56:12 <Igloo> Enough to believe you can complete a big enough project in the timescale
09:56:18 <vincenz> xerox: for gtk2hs "labelSetText" one can use markup, what kind of markup is required to get it red
09:56:41 <gordx> It was for a programming languages course, so we studied Haskell in some detail, but there's lots of features I've never heard of
09:57:07 <dcoutts_> vincenz, http://developer.gnome.org/doc/API/2.0/pango/PangoMarkupFormat.html
09:57:22 <musasabi> gordx: at least that is much more work than without more experience as you have to learn many things fast.
09:57:55 <vincenz> dcoutts_: thanks
09:58:04 <dcoutts_> evenin' SyntaxNinja 
09:58:08 <vincenz> sorry for all the incessant questions
09:58:17 <xerox> Yow Isaac.
09:58:27 <gordx> Thanks guys
09:59:24 <dcoutts_> vincenz, It does mention it in the gtk2hs docs: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Display-Label.html#3
09:59:41 <dcoutts_> vincenz, if you find the docs arn't good enough please submit patches :-)
10:00:01 <vincenz> will do
10:00:53 <SyntaxNinja> y0
10:01:26 <vincenz> yo
10:01:41 <tautologico> any parsec specialists here?
10:01:49 <xerox> tautologico: italiano?
10:02:11 <vincenz> tautologico: I'm getting better as we speak
10:02:13 <tautologico> xerox, sono brasiliano
10:02:34 <xerox> Ah (-:
10:03:04 <tautologico> vincenz, I'm using buildExpressionParser
10:03:18 <tautologico> but I want to parse application expressions
10:03:31 <tautologico> that are exp+
10:03:47 <vincenz> oy, too detailed :(
10:03:47 <tautologico> I always get in trouble, because only one of them works
10:04:03 <tautologico> even using try
10:05:05 <tautologico> so, let's try a more general question :)
10:05:28 <tautologico> I have a parser
10:05:52 <tautologico> expr = appExp <|> buildExpressionParser table simpleExp
10:05:55 <tautologico> and then appExp is
10:06:05 <tautologico> appExp = do rator <- simpleExp
10:06:15 <tautologico>    rands <- many simpleExp
10:06:22 <vincenz>  No instance for (Monad (Either ParseError))
10:07:15 <tautologico> problem is if I use try appExp in expr, even then the appExp parser consumes input
10:07:20 <tautologico> and returns an error
10:07:35 <tautologico> shouldn't try "forget" the input it consumed and try the next parser?
10:08:50 <vincenz> yeah
10:11:05 <tautologico> I'm baffled
10:11:51 <Lemmih> Where did you put the 'try'?
10:12:35 <tautologico> expr = try appExp <|> buildExpressionParser table simpleExp
10:13:11 <tautologico> so appExp matches the first simpleExp and when it sees an operator like + it returns an error saying it was expecting another simpleExp
10:14:47 <iturk> http://pastebin.com/700374 -> i am getting this error can someone help ??
10:14:47 <iturk> iturk ops
10:15:07 <Lemmih> tautologico: Does it work if you remove 'appExp'?
10:15:22 <tautologico> yep, it works for operator expressions
10:15:31 <astrolabe> tautologico: is it possible that appExp suceeds before it gets to '+'?
10:15:58 <tautologico> astrolabe, yes, this may be it
10:16:29 <dcoutts_> yay! gtk2hs is new included in darwinports!
10:16:38 <dcoutts_> http://gtk2hs.darwinports.com/
10:16:39 <Lemmih> iturk: Using Hugs?
10:16:41 <xerox> If only GHC was for this architecture!
10:16:46 <dcoutts_> xerox, heh
10:18:35 <iturk> Lemmih: no i am using  GHC Interactive, version 6.2.2, for Haskell 98.
10:18:49 <psi> dcoutts_: great! I'll try it out in a bit.
10:18:51 <j33o> ok.. i know this must be very very simple.. but suppose i have a list of strings, and i want to display them all in sequence using putStrLn... how do i do that?
10:19:27 <Lemmih> iturk: And Image.hs is in the same directory as Menu.hs?
10:19:34 <psi> I wish they would build binaries for darwinports.
10:19:36 <xerox> Lemmih: downnova is freaky.
10:19:49 <iturk> yes
10:19:54 <iturk> i am using eclipse for that
10:19:56 <j33o> see i try things like: map putStrLn list ..
10:20:04 <iturk> they are in the same project + the same directory
10:20:22 <j33o> but of course... that will give a type error
10:20:39 <Lemmih> iturk: Try -ipath/to/your/src/dir/
10:21:18 <iturk> inside ghci
10:21:26 <Lemmih> xerox: It has saved me a lot of time searching for torrents (:
10:21:35 <tautologico> astrolabe, it works now, thanks... pretty obvious but I missed it
10:21:40 <xerox> @karma+ Lemmih 
10:21:41 <lambdabot> Lemmih's karma raised to 16.
10:24:57 <xerox> Lemmih: RssParser code is nuts.
10:26:37 <iturk> Lemmih: using ghci in terminal runs well but inside my eclipse project doesnt locate the file
10:27:40 <Chilli> nick ChilliX
10:28:15 <vincenz> Why isn't (Either String) a monad???
10:28:17 <Lemmih> iturk: :set -ipath
10:28:33 <vincenz> No instance for (Monad (Either String))
10:28:49 <xerox> Error Monad.
10:29:54 <vincenz> I thought that was a monad
10:31:10 <iturk> Lemmih: i could not locate that inside my environment eclipse :: where can i set -ipath i understand the problem !!
10:32:25 <iturk> Lemmih: can i run that command inside the file ??
10:32:45 <Lemmih> iturk: ':set' is a GHCi command.
10:32:50 <dcoutts_> xerox, is this true:
10:32:53 <dcoutts_> http://dhcp0332.gradacc.ox.ac.uk:8080/~duncan/gtk2hs-alt/docs/reference/Graphics-Rendering-Cairo-Matrix.html#t%3AMatrix
10:33:14 <dcoutts_> vincenz, how about the above for ok documentation of the Matrix data type
10:33:30 <xerox> dcoutts_: I'm not sure.
10:33:47 <dcoutts_> xerox, you should know :-) or be able to figure it out :-)
10:34:11 <j33o> i get [IO ()] things... when i need IO ().... map isnt appropriate probably.. i'm just trying to iterate over a list
10:34:15 <vincenz> dcoutts_: great :)
10:34:18 <vincenz> hmm
10:34:18 <xerox> dcoutts_: yep, give me a second!
10:34:25 <resiak> j33o: sequence_ ?
10:34:35 <vincenz> dcoutts_: is there a 'simple' way of getting all the text from a textview? or must I do get textBuffer, create TextIters...
10:34:59 <Lemmih> j33o: mapM_
10:35:33 <dcoutts_> vincenz, did you look in the docs? :-)
10:35:40 <vincenz> dcoutts_: yeah that's why I ask
10:36:04 <j33o> aha.. thanks Lemmih 
10:36:07 <dcoutts_> vincenz, hint: it's an attribute of the buffer
10:36:13 <vincenz> hmm
10:36:18 <j33o> in general, what do the _'s mean?
10:36:29 <vincenz> dcoutts_: I saw that one, just didn't realize I could get something out of it
10:36:32 <dcoutts_> text <- get buffer textBufferText
10:37:39 <dcoutts_> vincenz, attributes are read/write unless specified otherwise
10:37:49 * vincenz nods
10:38:09 <vincenz> getting tired after struggling with ugly monads and parsec :/
10:39:06 <xerox> dcoutts_, it is right.  Cairo stores it your way.
10:39:22 <xerox> dcoutts_: one is probably more familiar with the transposed version, but the equation matches anyway.
10:39:39 <dcoutts_> xerox, are you sure? java does it differently: http://java.sun.com/j2se/1.5.0/docs/api/java/awt/geom/AffineTransform.html
10:40:01 * xerox thinks harder
10:40:14 <xerox> Well yes, that's what I said.
10:40:53 <dcoutts_> xerox, so I should transpose it?
10:40:53 <xerox> It depends wether you consider (x,y) as being a vertical or horizontal 1x2 matrix.
10:41:00 <dcoutts_> ah I see
10:41:48 <xerox> That ascii art is nice anyway.  I would adapt it :-)
10:42:05 <xerox> (But your first version is okay nevertheless.)
10:49:02 <iturk> why i cannot do something like this:
10:49:02 <iturk> getInt2 :: IO Int -> Int
10:49:02 <iturk> getInt2 = return( read getLine :: Int)
10:49:26 <xerox> iturk: because IO is a one-way monad.
10:49:44 <xerox> iturk: in that context, return has type a -> IO a.
10:50:01 <iturk> i am trying to read an integer from the user and return it how should i do it ??
10:50:51 <Lemmih> @type (readLn :: IO Int)
10:50:52 <lambdabot> IO Int
10:51:17 <RyanT5000> can Cabal 1.1.4 be built on GHC 6.4.1?
10:51:55 <xerox> RyanT5000: I think so.
10:52:45 <RyanT5000> it's giving me a parsing error on a line with C preprocessor stuff
10:52:54 <RyanT5000> as if it needs -cpp
10:53:18 <RyanT5000> can i just throw a GHC-Options: in the top-level .cabal file?
10:53:57 <xerox> I think you'd better add {-# OPTIONS_GHC -cpp #-} to the exact file.
10:54:08 <RyanT5000> ah, ok
10:54:57 <vincenz> WOOOOOOOOOOOOOOOOOT
10:55:00 <vincenz> it works
10:55:03 <xerox> dcoutts_: heh a 1xn matrix is more correctly called vector.  Silly me ;-)
10:55:16 <dcoutts_> aye
10:55:28 <dcoutts_> xerox, so for (x,y,0) what I've got is correct?
10:55:54 <dcoutts_> if it were a column vector then we'd need to transpose?
10:56:10 <iturk> http://pastebin.com/700463 here i am trying to get an int and pass it to the function but i am in trouble with IO Int can someone help ??
10:56:24 <dcoutts_> xerox, perhaps I should be explicit about it being a row vector
10:56:34 <xerox> dcoutts_: yes.
10:59:36 <Cale> iturk: sure
10:59:59 <Cale> numer <- readLn
11:00:41 <Cale> that will actually run readLn instead of defining numer to be the same computation
11:02:30 <Cale> It's also unusual to have functions take a tuple of their parameters. callFunctions :: Int -> Picture -> Picture would be a more likely signature.
11:02:39 <RyanT5000> what is "cc1" supposed to do?
11:02:52 <RyanT5000> is it just supposed to be a symlink to gcc?
11:04:27 <iturk> Cale: just one think this is the big picture: http://pastebin.com/700488
11:05:14 <iturk> Cale: horse is a picture of list with Strings and i am trying to update it everytime a function is called
11:05:42 <iturk> Cale: like flip a picture horizontally => flipH
11:05:46 <Cale> yeah
11:06:13 <iturk> the big work is in the main
11:07:05 <iturk> but i am still getting error like couldnt match Int against IO a in let horse = callFunctions(numer, horse)
11:07:23 <Cale> numer isn't an Int
11:07:33 <iturk> so i need one
11:07:40 <Cale> it's an IO Int, that is, an IO action, which when run, will produce an Int
11:08:00 <Cale> the reason it's an IO Int is because it's equal to readLn, which also it
11:08:02 <Cale> is*
11:08:15 <Cale> to actually run readLn, use syntax like
11:08:27 <Cale> do ... printPictures ...
11:08:33 <Cale>    numer <- readLn
11:08:46 <Cale> then numer will be an Int
11:09:23 <iturk> other think so then horse will get a new value
11:09:25 <iturk> with that let
11:09:36 <iturk> and main in the end will call the function again
11:09:38 <iturk> right
11:10:06 <Cale> well, that local binding of horse doesn't extend upward
11:10:20 <iturk> and i can also put a print "Type an Integer" before readln
11:10:29 <Cale> you'll have to pass it back into main, but of course main doesn't take a parameter
11:10:58 <Cale> so it's probably best to do something like
11:11:02 <Cale> main = mainLoop horse
11:11:25 <Cale> mainLoop h = do ...
11:11:44 <Cale>                 numer <- readLn
11:12:05 <Cale>                 mainLoop (callFunctions numer h)
11:12:27 <iturk> hmmm
11:13:01 <iturk> so mainLoop its like a function that call it self
11:13:14 <iturk> and of course that produces a loop
11:13:17 <Cale> yep
11:14:18 <Cale> There are also more sophisticated ways to deal with variables that are being mutated repeatedly, but this will be good for now
11:14:51 <iturk> yes 
11:14:58 <Cale> http://www.haskell.org/hawiki/IntroductionToIO -- you might read this to get the basic idea of how IO works in Haskell.
11:15:00 <iturk> thanks very much
11:15:09 <iturk> thanks
11:15:11 <iturk> :)
11:25:14 <iturk> Cale: what can we call in order to go out of a loop ???
11:26:11 <Cale> well, you could decide whether to rerun mainLoop again based on some condition
11:26:12 <RyanT5000> iturk: if you're using a recursive function, just return from the function without calling it again
11:26:27 <Cale> if foo then mainLoop ...
11:26:35 <Cale>        else return ()
11:26:36 <RyanT5000> if you're in IO (), use return () instead of mainLoop whatever
11:27:06 <RyanT5000> hopefully you can deinterleave Cale's and my explanation
11:27:10 <RyanT5000> :)
11:31:52 <vincenz> dcoutts_: I have another neat gui :)
11:32:02 <iturk> thanks
11:35:10 <iturk> Cale: i would like to apply something like this to a Picture:
11:35:21 <iturk> rotate_a :: Picture -> Picture
11:35:21 <iturk> rotate_a = flipH . zip
11:35:48 <iturk> its a python style but what i want is to flipH horizontal the picture
11:35:55 <iturk> then zip the list
11:36:07 <iturk> Picture its a list of Strings
11:39:13 <RyanT5000> i put ld-options: -Lc:/msys/1.0/local/lib @SDL_LIBS@ in the buildinfo.in
11:39:31 <RyanT5000> but it still can't find libSDL_ttf.a, which is in that directory
11:39:37 <RyanT5000> any ideas?
11:44:47 <palomer> man, I have to start waking up earlier
11:47:40 <Cale> palomer: did you see my GADT example?
11:48:00 <Cale> (I think it's originally Conor McBride's idea)
11:48:17 <dcoutts> vincenz, great! pics?
11:48:22 <vincenz> dcoutts: making one
11:48:35 <Cale> iturk: oh, sorry
11:49:10 <Cale> iturk: perhaps you mean transpose rather than zip?
11:50:03 <Cale> @type zip
11:50:05 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
11:50:07 <Cale> @type transpose
11:50:08 <lambdabot> forall a. [[a]] -> [[a]]
11:50:27 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
11:50:28 <lambdabot> [[1,4,7],[2,5,8],[3,6,9]]
11:50:52 <RyanT5000> how can i make configure tell me where it's looking for libraries?
11:55:20 <akyto-> can somebody help me with a quicksort on a list of [(Char,Int)] ?
11:55:35 <SamB> JohnMeacham: I think I found a bug, but I have no idea what it is
11:56:09 <akyto-> my one doesnt work correctly
11:56:42 <SamB> why would your quicksort be for a list of [(Char,Int)] rather than general?
11:57:45 <akyto-> i want to sort in the Int argument
11:57:54 <akyto-> on the
11:59:07 <Cale> qsortBy f [] = []
11:59:25 <Cale> qsortBy f (x:xs) = less ++ [x] ++ greater
11:59:37 <RyanT5000> do you actually need to write the sort algorithm?
11:59:43 <akyto-> but it does not work
11:59:48 <akyto-> and i don't know why
11:59:51 <akyto-> heres my code :http://nopaste.php-q.net/210169 
12:00:01 <akyto-> yes, its fpr university
12:00:22 <RyanT5000> so no using List.sortBy
12:00:33 <iturk> Cale: i have to define the functions transpose right so its like transpose :: [a] -> [a] ??
12:00:44 <Cale> iturk: no, transpose is in Data.List
12:00:55 <Cale> just import Data.List
12:01:00 <iturk> ok
12:01:06 <akyto-> Ryan: unfortuately not
12:01:39 <Cale> why are you comparing with head strt
12:01:44 <Cale> and not str
12:01:53 <Cale> er
12:02:00 <Cale> hmm, what are you doing here? :)
12:02:24 <Cale> you want to compare higher or lower with str actually
12:02:27 <akyto-> strt would be the rest of the list
12:02:39 <akyto-> how can i compare with the complete rest
12:03:02 <Cale> okay, let's break the definition up a bit
12:03:07 <RyanT5000> ok, so i'm trying to use Setup.lhs's configure
12:03:14 <akyto-> but, ok
12:03:15 <RyanT5000> when i use ./configure LDFLAGS=stuff, it works
12:03:21 <Cale> sortByNumber (str:strt) = higher ++ [str] ++ lower
12:03:21 <RyanT5000> how do i pass that stuff through cabal?
12:03:23 <monochrom> Aww, why would you stick a colon just before your url?
12:03:25 <Cale>    where higher = ...
12:03:33 <akyto-> would snd strt always be the second argument of each tuple ?
12:03:36 <Cale>          lower = ...
12:03:51 <Cale> snd strt is a type error
12:04:06 <psi> RyanT5000: LDFLAGS=stuff ./Setup.lhs maybe?
12:04:17 <RyanT5000> hm...
12:04:23 <Cale> let's define 'higher' in my definition there
12:04:26 <akyto-> without head there is a type error
12:04:58 <Cale> the problem is that you're not actually putting a condition on the elements of the list you're generating at all
12:05:12 <Cale> you'll either get the whole list, or the empty list
12:05:13 <akyto-> yes, but how can i :D
12:05:26 <Cale> higher = [h | h <- strt, ...]
12:05:36 <Cale> where ... is some condition comparing h with str
12:05:48 <akyto-> the condition i am searching for
12:05:51 <monochrom> [ higher | higher <- strt, snd higher > snd str ]    doesn't this make more sense?
12:06:30 <akyto-> snd need a tuple as argument
12:06:36 <akyto-> higher wohl be a list of touples
12:06:43 <monochrom> higher is a tuple. not a list
12:06:54 <Cale> higher is being picked from strt
12:07:15 <Cale> so it has the same type as an element of strt
12:07:26 <monochrom> > [ x | x <- [1,2,3], x>=3 ]
12:07:27 <lambdabot> [3]
12:07:29 <monochrom> QED
12:08:30 <monochrom> [ y | (x,y) <- [ (1,2), (3,4) ] ]
12:08:37 <monochrom> > [ y | (x,y) <- [ (1,2), (3,4) ] ]
12:08:38 <lambdabot> [2,4]
12:09:16 <monochrom> This shows that when you write ___ <- [ (1,2), ... ]   the ___ will receive one tuple not a list of tuples.
12:09:24 <monochrom> > [ y | [(x,y)] <- [ (1,2), (3,4) ] ]
12:09:25 <lambdabot> Couldn't match `(a, b)' against `[a1]'
12:09:33 <monochrom> Now that's a type error for you.
12:10:11 <Cale> > [(x,y) | (x,y) <- [(1,2),(3,4),(5,6)], y <= 5]
12:10:12 <lambdabot> [(1,2),(3,4)]
12:11:01 <vincenz> how do I take a screenshot of an app in gnome?
12:11:02 <monochrom> If you think about it, the whole point of list comprehension would be defeated if in ___ <- list  the ___ receives the whole list rather than one time.
12:11:06 <monochrom> s/time/item/
12:11:10 <vincenz> nm
12:12:37 <akyto-> snd higher causes an type error
12:13:36 <monochrom> > [ higher | higher <- [ ('x',1), ('y',2), ('z',3) ], snd higher >= snd ('a',2) ]
12:13:37 <lambdabot> [('y',2),('z',3)]
12:13:42 <akyto-> so, how to go over every second arguemtn in the tuples
12:14:16 <monochrom> No type error.
12:14:39 <monochrom> You can argue with me but you can't argue with lambdabot.
12:15:10 <akyto-> http://nopaste.php-q.net/210171 <-- type error in ghci
12:15:13 <xerox> Modulo programming errors.
12:16:54 <RyanT5000> how is it that a package builds perfectly without -p, and gets a ton of C errors with it?
12:17:06 <monochrom> [ h | h <- strt, snd h > snd str ]
12:17:34 <akyto-> mine: higher = [ h | h <- strt, snd higher > snd str ]
12:17:48 <monochrom> Just listen to me and use mine ok?!
12:17:54 <akyto-> ahhhhhhhhhh
12:17:55 <xerox> dcoutts: WOW - the SVG backend is "working" now!
12:17:59 <akyto-> i think i understand it
12:18:21 <akyto-> works ;-)
12:18:33 <dcoutts> xerox, of of cairo. yes.
12:18:45 <RyanT5000> huh.... i should make a SVG output mode for my GUI engine
12:18:46 <xerox> dcoutts: nice.
12:18:50 <RyanT5000> screenshot on crack :)
12:19:04 <dcoutts> xerox, we need to update the cario bindings to add the ps & pdf backends and add the new 1.2 apis
12:19:15 <dcoutts> xerox, add a tciket in our new trac system ! :-)
12:19:16 <akyto-> but the algorithm does not work right
12:19:24 <RyanT5000> are there "pixel shaders" for printers? like in postscript?
12:19:25 <xerox> dcoutts: cool!  Where is it?
12:19:48 <dcoutts> xerox, there's a link on the development page
12:20:13 <monochrom> I can see a problem.
12:20:22 <akyto-> [('a',4),('d',5),('s',5),('A',3),('D',2),('F',1),('H',3),('I',2),('S',3),('f',1),('g',3),('h',2),('i',1),('j',1),('u',2)] <-- bad result
12:20:41 <monochrom> [ l | l <- strt, snd l <= snd str ]   That <= is asking for non-termination.
12:20:43 <xerox> Nice!
12:20:48 * xerox -> shower; addTicket
12:20:59 <dcoutts> heh
12:21:09 <monochrom> You will think about how to fix it.
12:21:13 <dcoutts> can't add a ticket while being dirty :-)
12:21:40 <akyto-> sry, i'm no functional programming guru
12:22:51 <SamB> RyanT5000: not afaik...
12:23:31 <RyanT5000> yeah it'd probably require too much computing on the part of the printer
12:23:45 <RyanT5000> and printers aren't exactly real-time devices anyway
12:23:46 <SamB> maybe, maybe not
12:24:10 <RyanT5000> well you're talking about like 600dpi rather than 100 or so, and a surface about the same size physically
12:24:15 <RyanT5000> so it'd be 36 times as many pixels
12:24:31 <RyanT5000> of course it's also going a lot slower
12:24:32 <RyanT5000> i dunno
12:25:07 <akyto-> anybody a solution ?
12:25:44 <mauke> what's the problem?
12:25:47 <monochrom> akyto-: It is still within your capability to just think what can go wrong with <= and what you should do, purely considering the algorithm, devoid of any functional vs imperative vs whatever consideration.
12:27:04 <monochrom> It is going to be the same problem and the same solution in any language or paradigm.
12:29:32 <tautologico> hi
12:29:41 <akyto-> I'm really sorry, but I don't understand what you mean with the non termination thing
12:30:19 <monochrom> Sorry, <= will not cause a non-termination problem.
12:30:29 <monochrom> But now I can't see anything wrong.
12:30:43 <tautologico> another parsec question: I'm using makeTokenParser for the lexer, is there a way to differentiate between identifiers that begin with an uppercase letter and identifiers that begin with lowercase, without having to modify makeTokenParser?
12:30:43 <akyto-> same as me ...
12:30:56 <monochrom> Then it is correct.
12:31:06 <akyto-> but it does not work correctly
12:31:11 <akyto-> thats why i came here
12:31:37 <SamB> monochrom: or, you do not remember how to sort?
12:32:41 <RyanT5000> gah; how do i add an include directory with Cabal?
12:33:13 <akyto-> http://nopaste.php-q.net/210176 <---
12:33:22 <monochrom> Oh haha I see.  You forgot recursive calls.
12:33:24 <akyto-> the sort algorythm is from wikipedia
12:34:02 <monochrom> I do forget how to sort. (Why do I have to remember? There are libraries.  I have more important things to remember such as what is an arrow.)
12:34:17 <akyto-> thats what i did
12:34:29 <akyto-> thanks
12:34:34 <akyto-> i think now it works correct
12:34:40 <akyto-> thak you very mich
12:34:41 <akyto-> much
12:36:51 <jlhamilton> akyto: try sortBy (\x y -> compare (snd x) (snd y))
12:37:36 <Cale> jlhamilton: yeah, he's not allowed to use Data.List
12:37:47 <akyto-> monochrom: Why do I have to remember? There are libraries <- it's fast sometimes to self implement it
12:37:57 <jlhamilton> Cale: oh, i see
12:38:08 <monochrom> Yes I have just seen how fast it is.
12:38:11 <tautologico> I guess I will have to hack makeTokenParser
12:38:43 <monochrom> Half an hour is really fast.
12:39:19 <Cale> heh
12:39:44 <RyanT5000> i'm pretty sure my .buildinfo file is not being used
12:39:44 <Cale> I think it would have been faster to implement sortBy
12:39:47 <RyanT5000> how do i make it get used?
12:40:34 <RyanT5000> oh wait, cc-options and ld-options are irrelevant when using ghc to compile, arent' they
12:41:20 <SamB> well, sometimes GHC drives GCC..
12:41:31 <RyanT5000> yeah but they aren't getting passed :-/
12:42:19 <SamB> I really don't know what a .buildinfo file is; maybe GHC dosn't either?
12:42:49 <RyanT5000> it's a cabal thting
12:42:56 <RyanT5000> it gets spliced into all the .cabal files in the tree
12:42:56 <SamB> oh
12:46:50 <eivuokko> Hmh
12:47:04 <RyanT5000> eivuokko, do you know what's up with that?
12:47:07 <eivuokko> buildinfo file, afaik, must be next to .cabal
12:47:11 <RyanT5000> it is
12:47:17 <RyanT5000> and it's right, i think
12:47:26 <RyanT5000> i even put in ghc-options: in hopes that it would use that
12:47:36 <RyanT5000> it doesn't do anything different
12:47:40 <eivuokko> I also don't use ld-options, but extra-libraries field
12:47:45 <eivuokko> (on my projects)
12:47:53 <RyanT5000> well the linker i've fixed now
12:47:57 <eivuokko> Ah, ok
12:47:59 <RyanT5000> i can use LDFLAGS
12:48:06 <RyanT5000> but i can't use CPPFLAGS for a -I
12:48:36 <eivuokko> cc-options: -Id:\source\dxsdk\dec2005\Include
12:48:43 <eivuokko> That's what I have in one buildinfo
12:48:47 <RyanT5000> huh
12:49:04 <eivuokko> Not sure it works for ghc
12:49:26 <eivuokko> It works for hsc2hs and c-files
12:49:31 <RyanT5000> hm
12:49:34 <RyanT5000> i put it in ghc-options too
12:51:51 <eivuokko> Btw, did you try running setup build with -v or -v2 or bigger?
12:54:21 <RyanT5000> eivuokko yeah
12:54:32 <RyanT5000> now i see that certain stuff is getting through
12:54:35 <RyanT5000> but i'm still confused
12:54:38 <RyanT5000> here's the error:
12:55:00 <RyanT5000>  /mingw/include/stddef.h:6:24: 
12:55:01 <RyanT5000>      no include path in which to search for stddef.h
12:55:17 <eivuokko> Hmm
12:55:58 <eivuokko> That is very wierd..
12:56:21 <eivuokko> ..I dunno, I don't use msys as my shell unless I need to run configure or something, tho
12:57:30 <eivuokko> It is like you got something to use your gcc and gcc's preprocessor instead of one that comes with ghc.  How'd you do that..no idea..and error still makes no sense.
12:57:51 <RyanT5000> well what it's doing is using #include_next
12:59:40 <eivuokko> Can you try setting INCLUDE to nothing?
12:59:59 <eivuokko> nvm, it isn't probably set
13:01:57 <RyanT5000> oh i think i know the problem
13:02:13 <RyanT5000> #include_next works from the current index into the include path, forward
13:02:28 <eivuokko> Yeah, that seems likely.
13:02:33 <RyanT5000> so if mine isn't after the one it's working on
13:02:36 <RyanT5000> it gets messed up
13:04:17 * mahogny wishes that his robo burns in hell. third time a circuit is toasted :(
13:10:54 <SamB> mahogny: circuits get toasted worse if robot burns!
13:11:18 <mahogny> SamB, well, it would give me a good reason to give up though :)
13:12:05 <SamB> what sort of robot are you making?
13:13:34 <ADEpt> SamB: read your submission for SoC. just wanted to say that conjure repo had moved to http://darcs.haskell.org/~lemmih/conjure/
13:13:50 <mahogny> just a simple one for a school project. it runs around on two wheels and explores the environment. it's supposed to locate objects placed in a "mine" and then get back to the start as fast as possible
13:15:39 <kzm_> Aargh.  Am I the only one having problems finding stuff on Google SoC?
13:15:43 <kzm_> What
13:15:47 <mahogny> kzm, like what?
13:16:02 <kzm_> ...'s the url of the mentor_home (where one can view the list of applications)?
13:16:27 <ADEpt> kzm_: http://code.google.com/soc/mentor_home.html
13:16:47 <kzm_> Thanks.
13:17:19 <kzm_> ...sometimes it is available from the menu, sometimes only the FAQs.
13:17:33 * kzm_ made sure he was logged in, too.
13:17:54 <SamB> ADEpt: ah
13:18:25 <ADEpt> SamB: i googled it up by chance :)
13:18:29 <kzm_> lots of votes already, too.
13:18:37 <ADEpt> SamB: btw, are you still interested in that project?
13:18:40 <kzm_> The competition is going to be hard, I think. :-)
13:18:45 <RyanT5000> .... "ignoring nonexistant directory "a directory that definitely exists""
13:19:12 <SamB> ADEpt: you mean Conjure?
13:19:21 <ADEpt> SamB: yes
13:19:37 <SamB> I think so
13:20:09 <eivuokko> RyanT5000, path-formatting issue again?
13:20:15 <RyanT5000> yep
13:20:27 <RyanT5000> at least now i know it's getting passed to GHC properly
13:20:34 <RyanT5000> but it's throwing it away cause it thinks it doesn't exist
13:20:45 <ADEpt> SamB: well, we could hijack it from Lemmih :)
13:22:52 <psi> how many applications have been submitted so far?
13:23:37 <dcoutts> psi, SoC ones you mean?
13:23:42 <RyanT5000> psi: 1
13:23:53 <ADEpt> psi: about 20
13:24:06 <psi> alright, cool
13:24:16 <dcoutts> 17
13:24:28 <RyanT5000> somehow i get the impression i should submit more....
13:25:09 <psi> I'm focusing on just one. Maybe two.
13:26:11 <psi> I wonder how many students google will admit this year
13:26:19 <SamB> ADEpt: I haven't had time for it with school
13:26:30 <SamB> psi: I hope a lot of Haskell.org students ;-)
13:26:52 <psi> me too :)
13:27:03 <SamB> ADEpt: so, do you think I should change my app?
13:28:43 <ADEpt> SamB: you mean SoC app? what do you have in mind?
13:29:36 <SamB> I mean, do you think I ought to add the conjure repo URL now that I know it?
13:31:09 <ADEpt> SamB: I dont think that you could technically do it, unless someone comments on your entry
13:31:32 <psi> how much are you people writing in your applications?
13:31:51 <SamB> ADEpt: I know that ;-)
13:32:26 <ADEpt> SamB: i commented upon. decide whether you want it updated or not
13:32:31 <SamB> okay then
13:33:05 <ADEpt> psi: there are people that write quite a lot
13:35:43 <SamB> I didn't write a whole lot
13:36:18 <SamB> but then again I'm not *too* sure where this project will take me
13:39:26 <psi> SamB: what're you doing?
13:41:20 <SamB> I want to do a monad-transformer version of Parsec
13:42:58 <psi> would that mean, for instance, that you could perform IO while parsing? I'm not familiar with monad tranformers.
13:42:59 <SamB> ADEpt: I think it is fine as-is, with your comment telling where the repo is :-)
13:43:05 <SamB> yes!
13:43:07 <SamB> it would.
13:43:20 <psi> cool
13:43:33 <SamB> that is the principle motivation, in fact ;-)
13:43:42 <psi> hehe, ok :)
13:44:26 <SamB> I don't remember what I was doing when I decided I wanted it, unfortunately. I might have been trying to write a Self implementation...
13:49:40 <MarcWebe1> Is there already a monad for applying one argument to each function?
13:50:06 <SamB> you mean Monad (-> a)?
13:50:14 <ADEpt> usually it's vice versa
13:50:16 <SamB> er...
13:50:18 <SamB> yeah.
13:50:38 <SamB> confused by the Infixity of -> I am!
13:50:57 <MarcWebe1> I have this : fun bh = do { a <- get bh; b <- get bh; return Constr a b }
13:52:15 <MarcWebe1> and I want something to add the argument bh automatically.. I think I just have to try...
13:52:25 <MarcWebe1> writing my own.
13:52:51 <sjanssen> MarcWebe1: I think the (a ->) monad does that for you
13:53:28 <MarcWebe1> Let me see wether I can find it using tags or hoogle.. ;)
13:53:35 <xerox> Yep.  The Reader Monad is also known as the Environment Monad
13:53:53 <SamB> you might need another do, though
13:54:04 <SamB> or something...
13:54:08 <xerox> > runReader (do { e <- ask; return (e + 1) }) 1
13:54:09 <lambdabot> 2
13:54:58 <SamB> > (do { e <- ask; return (e + 1) }) 1
13:54:59 <lambdabot> 2
13:56:12 <sjanssen> @djinn (a -> b) -> (b -> a -> c) -> a -> c
13:56:12 <lambdabot> f a b c = b (a c) c
13:56:24 <sjanssen> @pl  f a b c = b (a c) c
13:56:25 <lambdabot> f = flip flip id . (ap .) . flip (.)
13:58:34 <sjanssen> funny that @pl doesn't reduce that to (>>=)
13:59:46 <SamB> @type flip flip
13:59:47 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
14:00:04 <SamB> @type flip flip id
14:00:05 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
14:01:22 <SamB> @type (ap .)
14:01:23 <lambdabot> forall (m :: * -> *) a b a1.
14:01:23 <lambdabot>     (Monad m) =>
14:01:23 <lambdabot>     (a1 -> m (a -> b)) -> a1 -> m a -> m b
14:01:35 <SamB> @type (flip (.))
14:01:36 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
14:02:33 <sjanssen> the ap is even using the (->) a Monad
14:02:52 <SamB> yeah... figured
14:04:45 <SamB> so did anyone else notice that JHC errors out badly when you try to compile Parsec with it?
14:07:38 <MarcWebe1> xerox, SamB sjanssen : Someething like this? let m=Reader (\a -> return  a+1) in runReader ( do { a <- m; b <- m; return (a+b)}) 2::Int
14:10:53 <RyanT5000> whoever is in charge of packaging the mingw snapshots of 6.5 better not live in north america
14:11:09 <xerox> > let m = ask >>= return . (+1) in runReader (do { a <- m; b <- m;  return (a+b) }) 2
14:11:11 <lambdabot> 6
14:11:16 <xerox> MarcWebe1: you can do better, too.
14:11:20 <RyanT5000> i just spent like an hour trying to figure out why a #include of stddef.h doesn't work
14:11:28 <MarcWebe1> xerox: I know, it doesn't compile ;)
14:11:34 <RyanT5000> answer: it isn't in ./gcc-lib/include
14:11:37 <RyanT5000> becuase nothing is there
14:11:39 <RyanT5000> gah
14:12:26 <xerox> MarcWebe1: no sorry, I meant another thing on which I'm still investigating.
14:12:35 <xerox> MarcWebe1: did you see the version I ran in lambdabot a moment ago?
14:12:36 <MarcWebe1> RyanT5000: If you assist me I can try to package..
14:12:53 <RyanT5000> ok, what do you need?
14:12:57 <MarcWebe1> the +1 thing. of cause.
14:13:07 <vincenz> > +1 1
14:13:07 <lambdabot>  parse error on input `+'
14:13:11 <vincenz> > +1 $ 1
14:13:12 <lambdabot>  parse error on input `+'
14:13:17 <RyanT5000> what are you trying to do?
14:13:19 <MarcWebe1> RyanT5000: The settings how to configure the make system.. ;)
14:13:35 <RyanT5000> btw i already solved my problem by copying from 6.4.1 :)
14:13:38 <xerox> MarcWebe1: you can also run m in a slightly differnt context.
14:14:51 <xerox> > let m = do { e <- ask; return (e^2) } in runReader (do { a <- local (+1) m; b <- local (*2) m; return (a+b) }) 1
14:14:52 <lambdabot> 8
14:15:15 <xerox> (1+1)^2 + (1*2)^2 = 8
14:16:26 <psi> @pl palin n = let s = show n in s == reverse s
14:16:27 <lambdabot> palin = ap (==) reverse . fix . const . show
14:17:52 <xerox> > ap (+) (*2) 2
14:17:53 <lambdabot> 6
14:18:28 <psi> @index ap
14:18:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
14:18:29 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
14:18:39 <psi> yikes
14:18:50 <MarcWebe1> xerox: Thx! Got it.
14:18:58 <xerox> MarcWebe1: you're welcome!
14:19:39 <xerox> ?type Control.Monad.ap
14:19:40 <lambdabot> forall b (m :: * -> *) a.
14:19:40 <lambdabot>        (Monad m) =>
14:19:40 <lambdabot>        m (a -> b) -> m a -> m b
14:22:45 <psi> > ap (Just length) (Just "foobar")
14:22:46 <lambdabot> Just 6
14:23:10 <RyanT5000> is there any way to make vim save to stdout?
14:23:25 <RyanT5000> i want to pipe the output of a command through vim
14:23:32 <RyanT5000> and into another command
14:24:06 <xerox> psi: nice one!
14:24:20 <xerox> > ap (Just length) Nothing
14:24:21 <lambdabot> Nothing
14:24:27 <xerox> Great.
14:25:01 <psi> > liftM length Nothing
14:25:02 <lambdabot> Nothing
14:25:08 <psi> :)
14:25:56 <xerox> I wonder if it would make sense for ap to have the type |(Monad m, Monad n) => m (a -> b) -> n a -> n b| (possibly more constrained.)
14:26:31 <SamB> don't think so!
14:26:44 <SamB> because it has to sequence its arguments, you know...
14:27:33 <xerox> But maybe it would be convenient to have, say a List of function but the 'a' coming off from another kind of computation.
14:32:06 <psi> what is a real use case of ap? I don't really understand.
14:32:21 <SamB> it is used to implement liftM*
14:32:22 <SamB> iirc
14:32:37 <psi> oh
14:32:45 <SamB> can be, anyway...
14:35:28 <Cale> return f `ap` x1 `ap` x2 `ap` ... `ap` xn
14:36:53 <xerox> Cale: that is liftMn ?
14:39:09 <monochrom> kind of
14:40:52 <araujo> Hi!
14:41:29 <xerox> > return (+) `ap` (return 1) `ap` (return 1) :: [Int]
14:41:30 <lambdabot> [2]
14:41:42 <xerox> > return (+) `ap` (return 1) `ap` [2,3] :: [Int]
14:41:43 <lambdabot> [3,4]
14:42:03 <xerox> Could one imagine a language where ($) = ap ?
14:42:05 <araujo> xerox!
14:42:10 <psi> why "kind of"?
14:42:13 <xerox> Howdy araujo!
14:42:18 <araujo> :-)
14:48:27 <psi> @pl func f l = return f `ap` l
14:48:27 <lambdabot> func = fmap
14:48:50 <psi> smart
14:49:34 <xerox> ("TheHunter is"++)
14:51:05 <psi> did he write pl?
14:51:29 <xerox> Yup.
15:04:33 <DeliQ> @hoogle [(a, b)] -> b -> Maybe a
15:04:33 <lambdabot> No matches, try a more general search
15:04:40 <DeliQ> hmm, bummer :P
15:04:52 <DeliQ> @hoogle [(a, b)] -> a -> Maybe b
15:04:52 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:10:11 <psi> gah, I was trying to track down an error that seem to be layout related, but everything was lined up perfectly. turns out my monospaced font is not really monospaced.
15:11:09 <int80_h> hi mahogny :)
15:11:13 <xerox> haha.
15:11:22 <mahogny> int80_h, hello :)
15:11:32 <SamB> psi: oh?
15:11:34 <xerox> int80_h: may you go for adding your contact information on the People page?
15:11:50 <int80_h> oooh I thought I did, sure
15:11:58 <int80_h> I'll do that right now
15:12:19 <xerox> Dankel.
15:12:23 <int80_h> the soc wiki should be in the topic 
15:12:28 <int80_h> bitte
15:12:38 <psi> SamB: emacs' highlighting is doing something funky
15:12:48 <xerox> It is in the topic.
15:12:55 <int80_h> oh doh!
15:14:20 <int80_h> I don't see the mechanism by which I modify the people page
15:14:33 <SimonRC> hi
15:14:53 <ihope_> > minBound
15:14:53 <lambdabot> Add a type signature
15:14:56 <ihope_> > minBound :: Double
15:14:57 <lambdabot>  add an instance declaration for (Bounded Double)
15:14:57 <lambdabot>   In the expression: minBound :: Double
15:14:57 <lambdabot>   In the definition of `qiw': qiw = minBound :: Double
15:15:07 <ihope_> qiw! qiw! qiw!
15:15:24 <int80_h> oh yeah I had to login newhvermind
15:16:33 <int80_h> heh we are really asking for spam, leaving our email so obvious
15:17:30 <int80_h> mahogny, I don't think I'm going to have a proper proposal done in time. However I am using the tutorial you gave me. I find it far more intersting than the book I'm using. I'm glad I didn't buy it.
15:17:42 <ihope_> I don't see any email addresses.
15:17:45 <int80_h> although, in ignorance I suggested to a friend of mine that *he* buy it. And he did.
15:18:26 <mahogny> int80_h, ok. well, that book is ok for the first three weeks of introduction. but then you oughta move on
15:19:24 <int80_h> well I got up to chapter seven
15:19:46 <MarcWebe1> xerox: even this works: let m=do{ m <- ask; return (m+1) } in runReader (liftM2 (+)  m m)  2::Int
15:19:49 <int80_h> I think I will print out and bind this other book
15:20:20 <int80_h> hey can we talk a minute about the technical aspects of the mud engine?
15:20:28 <int80_h> I have vague ideas and I want to sort them out
15:20:41 <MarcWebe1> but I can't define this for m: rget= do  { binhandle <- ask; get binhandle}
15:21:01 <MarcWebe1> error:  No instance for (MonadReader BinHandle IO)
15:21:05 <ihope_> > let m=do{ m <- ask; return (m+1) } in runReader (liftM2 (+) m m) 2
15:21:06 <lambdabot> 6
15:21:53 <MarcWebe1> the function m is applied 2 two times.. the results are beeing added.
15:21:57 <int-e> > liftM2 (+) (+1) (+1) 2
15:21:58 <lambdabot> 6
15:22:57 <int80_h> mahogny?
15:23:20 <mahogny> int80_h, ah. sure
15:24:18 <int80_h> I want to keep the engine abstract enough such that the details of any implemented game are defined with the mudlib
15:29:53 <MarcWebe1> I have to go to bed and think about it again tomorrow.
15:41:38 <xerox> 'night
15:49:54 <petekaz> Does anyone have a suggestion for a very simple monad that I can write?  I just want to see if I'm "getting" it yet.  Something fairly simple, perhaps akin to Maybe?
15:55:22 <petekaz> Are there not any canonical examples/exercises that are used in the classroom?  I'm learning this for self-enlightenment.  It doesn't have to be useful.  Just to test my understanding of this "combining computations".
15:56:17 <Lemmih> How about the list monad?
15:56:48 <vincenz> MonadSupply by Cale is rather nice
15:56:56 <vincenz> @oldwiki MonadSupply
15:56:57 <lambdabot> http://www.haskell.org/hawiki/MonadSupply
16:04:51 <ihope_> @type lifmM2
16:04:52 <lambdabot> Not in scope: `lifmM2'
16:04:57 <ihope_> @type Control.Monad.liftM2
16:04:58 <lambdabot> forall r (m :: * -> *) a2 a1.
16:04:59 <lambdabot>         (Monad m) =>
16:04:59 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:05:42 <ihope_> > liftM2 (liftM2 (+)) (+) (+)
16:05:43 <lambdabot> Add a type signature
16:06:00 <ihope_> @type Control.Monad.liftM2 (Control.Monad.liftM2 (+)) (+) (+)
16:06:01 <lambdabot> forall a.
16:06:01 <lambdabot>                     (Num a) =>
16:06:01 <lambdabot>                     a -> a -> a
16:06:14 <ihope_> > liftM2 (liftM2 (+)) (+) (+) 2 3
16:06:17 <lambdabot> 10
16:07:49 <ihope_> > liftM2 (liftM2 (^)) (^) (^) 2 2
16:07:50 <lambdabot> 256
16:08:04 * ihope_ wonders what that's doing
16:08:25 <ihope_> > (2^2) ^ (2^2)
16:08:26 <lambdabot> 256
16:08:32 <ihope_> > liftM2 (liftM2 (^)) (^) (^) 2 3
16:08:33 <lambdabot> 16777216
16:08:41 <ihope_> > (2^2) ^ (3^3)
16:08:42 <lambdabot> 18014398509481984
16:08:47 <ihope_> > (2^3) ^ (2^3)
16:08:48 <lambdabot> 16777216
16:08:53 <ihope_> There we go.
16:12:44 <Cale> > (2^8)^3
16:12:45 <lambdabot> 16777216
16:14:10 <ihope_> > (^) (^) 2 3 (^) 2 3
16:14:11 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
16:18:53 <jfoutz> > "\\\\"
16:18:53 <lambdabot> "\\\\"
16:20:20 <ihope_> > show "\\\\"
16:20:21 <lambdabot> "\"\\\\\\\\\""
16:20:26 <ihope_> @type fix read
16:20:27 <Lemmih> > "////"
16:20:28 <lambdabot> String
16:20:28 <lambdabot> "////"
16:20:36 <ihope_> @type read (fix read)
16:20:37 <lambdabot> forall a. (Read a) => a
16:21:11 <ihope_> @type let fix' x = x (fix x) in (fix read, fix' read)
16:21:12 <lambdabot> (String, String)
16:21:19 <ihope_> Hmm...
16:21:48 <mathewm> @type 1
16:21:50 <lambdabot> forall t. (Num t) => t
16:22:03 <mathewm> cool :)
16:22:12 <ihope_> @type let fix' x = x (fix x); fix' :: Read a => (String -> a) -> a in (fix read, fix' read)
16:22:13 <lambdabot>   Couldn't match the rigid variable `a' against `String'
16:22:13 <lambdabot>   `a' is bound by the type signature for `fix''
16:22:23 <ihope_> Whoo.
16:22:36 <ihope_> @type let fix' x = x (fix' x); fix' :: Read a => (String -> a) -> a in (fix read, fix' read)
16:22:37 <lambdabot>   Couldn't match the rigid variable `a' against `String'
16:22:38 <lambdabot>   `a' is bound by the type signature for `fix''
16:23:00 <ihope_> Okay, enough of that...
16:26:16 <ihope_> @type asTypeOf fix (undefined :: Read a => (String -> a) -> a) -- maybe not? :-)
16:26:17 <lambdabot> (String
16:26:17 <lambdabot>                      -> String)
16:26:17 <lambdabot>                     -> String
16:27:30 <mathewm> how tolerent of newbie questions are we here?
16:28:36 <psi> very
16:30:30 <jfoutz> tolerance of newbie questions is inversely proportional to the strength of typing
16:30:59 <mathewm> I am trying to figure out how to have my haskell program exit with a particular exit code:   'main = exitWith 1' and 'main = return 1' do not do what I hoped
16:31:09 <lisppaste2> jethr0 pasted "pattern weirdness" at http://paste.lisp.org/display/19736
16:31:42 <jethr0> i've got a weird problems with a case statement. could someone be so nice and have a look, puh-lease?
16:32:01 <Lemmih> mathewm: exitWith (ExitFailure 1)
16:32:49 <RyanT5000> could someone point me to a tutorial on ghc's profiler?
16:33:09 <jethr0> RyanT5000: as far as i know there's no real tutorial
16:33:19 <jethr0> there's a paper about profiling though
16:33:20 <RyanT5000> hm
16:33:22 <Lemmih> RyanT5000: The manual isn't good enough?
16:33:37 <RyanT5000> Lemmih: the manual doesn't google well
16:33:53 <RyanT5000> figured i'd ask in here for a tutorial while tracking down more manual pages
16:33:59 <RyanT5000> but no, the pages i've found so far aren't
16:34:19 <Lemmih> RyanT5000: http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
16:34:33 <RyanT5000> thanks
16:34:57 <jethr0> Lemmih: any ideas in respect to my case problem?
16:35:08 <Lemmih> mathewm: You can ask Hugs and GHC about the types of functions.
16:35:40 <RyanT5000> does profiling inhibit optimizations?
16:35:48 <RyanT5000> i.e.: do  -prof and -O2 not mesh well?
16:36:00 <mathewm> are there man pages for GHC libraries?
16:36:45 <jethr0> RyanT5000: when you've played around with the profiler you'll see that this is not so much of an issue. at least for me, the bigger problem was making sense of the profiling information
16:37:15 <RyanT5000> well, my algorithm's efficiency depends on, e.g., deforestation (or so i've been told)
16:37:20 <jethr0> profiling, speeding-up, patching space leaks and optimization in general are quite a challenge in haskell
16:37:43 <Lemmih> jethr0: What happens when one of the args to 'diff' is null?
16:37:44 <RyanT5000> so if profiling stops it from using those transformations, then it will suck
16:37:49 <jethr0> unless one knows already beforehand exactly what's happening in terms of GC, etc
16:38:17 <jethr0> Lemmih: you're right
16:38:24 <Lemmih> mathewm: No, but we got online documentation.
16:38:31 <jethr0> sry, but sometimes i just can't the forest for all the trees
16:38:32 <jethr0> :)
16:38:36 <Lemmih> mathewm: http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:39:03 <vincenz> hgialoha
16:39:05 <vincenz> aloha
16:39:32 <jethr0> Lemmih: thx a lot
16:40:56 <Lemmih> jethr0: No problem (:
16:42:22 <jethr0> i just hate it when i have to ponder over some error message and however often i go over the code it just seems to be the compiler's fault. sadly (or should i say luckily) it never is :)
16:46:21 <jfoutz> very very lucky
16:46:58 <jfoutz> so, is there a nicer way to write this? 
16:47:14 <jfoutz> schemeStr = liftM3 (\x y z -> x ++ y ++ z) (string "\"") (many stringElement) (string "\"")
16:47:27 <jfoutz> it seems like i should be doing a fold over ++
16:48:15 <jfoutz> @pl (\x y z -> x ++ y ++ z)
16:48:15 <lambdabot> (. (++)) . (.) . (++)
16:48:49 <monochrom> I think it's just fine.
16:48:58 <jfoutz> ok
16:50:04 <monochrom> I actually write schemeStr = do { x <- string "\""; y <- many stringElement; z <- string "\""; return (x ++ y ++ z) }
16:51:32 <ihope_> Yeah, that's what I'd do.
16:51:41 <jfoutz> do is so opaque. i'm shaky on monads. I don't know if using that syntax will help me pack/unpack those in my head.
16:52:56 <ihope_> do {run the parser (string "\"") and call the result x; run the parser (many stringElement) and call the result y; run the parser (string "\"") and call the result z; return (x ++ y ++ z)}
16:53:41 <RyanT5000> i have a function f, which calls a function g exactly once; my profiler says that f has 41 entries (which is reasonable), and that g has 620,000 entries
16:53:48 <jfoutz> so, listM is more of an obfuscation?
16:54:06 <RyanT5000> does anyone know how to explain that?
16:54:11 <ihope_> jfoutz: well, it depends on what you're used to seeing.
16:54:28 * jfoutz is new here
16:54:41 <jfoutz> so, it's hard to tell what i'm used to :)
16:54:51 <ihope_> :-)
16:55:53 <jfoutz> so, should i use do by default?  
16:56:02 <ihope_> Well, do is often more readable.
16:56:47 <ihope_> The liftM family is probably better for writing shorter things, like liftM2 (+) [1,2,3] [4,5,6]
16:57:01 <monochrom> I still advice using do.  It is very general and uniform.
16:57:14 <ihope_> True, it is.
16:57:28 <jfoutz> ok. sort of like single and multiline if.
16:57:41 <ihope_> I suppose so.
16:57:58 <ihope_> There's More Than One Way To Do It :-)
16:58:02 <jfoutz> multiline is "do" oneliners could use some special syntax
16:58:08 <jfoutz> heh clearly :)
16:58:30 <RyanT5000> how come list comprehensions can no longer be used for nonlist monads?
16:58:33 <jfoutz> er, not syntax, i mean function
16:58:40 <monochrom> If you change from do{x<-a; y<-b; return (x+y)} to do{x<-a; y<-b; z<-c; return (x+y+z)} you just carry out that change.  Add one more item, patch the return line.
16:59:07 <jfoutz> but the lift is a whole rewrite.
16:59:15 <ihope_> RyanT5000: maybe people were confused by stuff like [ a+b | a <- readLine, b <- readLine ]
16:59:31 <RyanT5000> but if they're confused, just don't use it
16:59:34 <monochrom> If you change from liftM2 (+) a b to liftM3 (\x y z -> x+y+z) a b c, you not only add one more item and patch the return line, you also have to re-count and change from 2 to 3.
16:59:41 <ihope_> What if it's not their code?
16:59:43 <RyanT5000> there's the "need to read other people's code" argument, i suppose
17:00:01 <monochrom> And then after you have 5 or more items you are out of luck.
17:00:01 <RyanT5000> but if i run my code through @pl, that's much worse
17:00:09 <ihope_> @hoogle Num a => a -> a -> a -> a
17:00:09 <lambdabot> No matches, try a more general search
17:00:30 <RyanT5000> i disagree with the idea of arbitrary restricting syntax because some people might not understand it
17:00:30 <monochrom> But you can now argue that you can use ap in the first place.
17:00:34 <jfoutz> i think, if i have a named function that does what i want, i'll do lift. if i don't ill use do
17:00:51 <ihope_> jfoutz: sounds good
17:01:00 <RyanT5000> anyone know what's up with my profiling issue?
17:01:01 <jfoutz> liftM (+) [1][2] looks so nice
17:01:18 <monochrom> Then I'll argue that ap is slower than >>= and do is translated into >>= not ap. :)
17:01:46 <ihope_> A somewhat weirdish way to do things would be sum (sequence [readLine, readLine]).
17:01:50 <jfoutz> i think the standard response is "if i wanted it fast i'd do it in C"
17:01:57 <ihope_> Or... wait...
17:02:04 <jfoutz> but i wouldn't say that because it's snarky :)
17:02:22 <RyanT5000> here's the thing: my code is fast
17:02:35 <RyanT5000> it's just getting run 15000 more times than i expect it to run
17:02:35 <ihope_> @type liftM sum (sequence [readLine, readLine])
17:02:36 <lambdabot> Not in scope: `readLine'
17:02:37 <lambdabot>  
17:02:37 <lambdabot> <interactive>:1:31: Not in scope: `readLine'
17:02:38 <jfoutz> your algorithm is fast.
17:02:49 <RyanT5000> no, the code is fast
17:02:55 <ihope_> @type liftM sum (sequence [readLn, readLn])
17:02:56 <lambdabot> forall a.
17:02:56 <lambdabot>               (Num a, Read a) =>
17:02:56 <lambdabot>               IO a
17:02:58 <RyanT5000> time per run is almost nothing
17:03:09 <RyanT5000> but 620k executions when it should have 41 is retarded
17:03:19 <RyanT5000> but i think i might be misunderstanding the profiler
17:03:35 <RyanT5000> entries is calls, right?
17:04:42 <monochrom> Remember the tension between the monad-as-computation camp and the monad-as-container camp?
17:04:59 <jfoutz> ihope_, monochrom Thanks for the advice. 
17:05:26 <jfoutz> me?
17:05:28 <monochrom> do favours the former view, comprehension favours the latter view.  The adoptation of the notation reflects the domination of one view.
17:06:24 <jfoutz> hehehe. the monad-as-container on the wikki is what opened my eyes about monads.
17:06:51 <jfoutz> i still don't follow the monad-as-computation model. that would explain my resistance to do
17:06:55 <liyang> monochrom: I suggest you read Conor McBride's aborted Idiom paper. (as opposed to the published `Applicative Functors' aka `Idiom Lite'.)
17:07:14 <ihope_> jfoutz: have you seen parser monads? Those guys are fun :-)
17:07:35 <jfoutz> *sigh* i'm doing the scheme 48 tutorial
17:07:40 <monochrom> I suggest McBride to come here and listen to me.
17:07:51 <jfoutz> but the whole language. so i'm doing lots of parsing
17:08:08 <jfoutz> Parsec is bitchin' by the way
17:08:21 <jfoutz> way easier than lex/yacc
17:08:28 <ihope_> Hmm, wait...
17:08:49 <ihope_> Your original code bit was inside a parser monad, wasn't it?
17:08:51 <ihope_> Silly me...
17:09:21 <monochrom> Thus, finally I have found the best immediate response to all "you should read ____" assertions. :)
17:09:25 <jfoutz> :)
17:10:00 <jfoutz> until someone shows up and demands to be talked to.
17:10:30 <monochrom> I can be talkative and opinionated, don't worry.
17:11:01 <jfoutz> hehehe
17:11:57 <liyang> monochrom: well, once you've stopped being offensive, this might interest you: http://www.cs.nott.ac.uk/~ctm/idiom.ps.gz
17:13:18 <monochrom> What is its gist though?
17:13:45 <liyang> What you went on about liftM{n} for various values of n.
17:13:51 <mathewm> Is there no-op?   if ( ... ) then ( ... ) else ( doNothing ) 
17:14:10 <liyang> mathewm: return ()
17:14:38 <mathewm> ah, right return lifts the ()
17:14:41 <mathewm> thanks
17:15:34 <liyang> or the more common way to write a monadic if-then-else block where one branch is return () is to use when and unless, both in Control.Monad.
17:15:46 <liyang> @index when
17:15:46 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:16:01 <liyang> @type when
17:16:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:16:10 <mathewm> @help
17:16:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:19:28 <maxo> hi anybody here ?
17:19:44 <maxo> x-pert in haskell
17:20:00 <mathewm> nope just us Perl programmers...
17:20:03 <mathewm> ;)
17:20:15 <maxo> lol
17:20:31 <maxo> i need hasklers
17:21:23 <mathewm> just ask - answers come out of the woodwork
17:21:48 * sjanssen comes out of the woodwork
17:24:01 <monochrom> liyang: do you know why McBride aborted the work?
17:35:55 <liyang> because there's now an Idiom Lite paper.
18:06:59 <dons> moin
18:09:30 <Lemmih> moinmoin.
18:09:42 <Lemmih> How's code, dons?
18:09:56 <dons> good
18:10:07 <dons> dcoutts_: ? 2 `compare` 1 == GT..
18:10:13 <dons> > 2 `compare` 1
18:10:14 <lambdabot> GT
18:10:24 <dons> and so does compare (P.packByte 2) (P.packByte 1)
18:11:11 <dons> Lemmih: well donw on DownNova :)
18:11:15 <dons> done
18:47:23 <RyanT5000> what's the most efficient way to take an associative list [(i, e)] and convert it to a Storable array?
18:48:09 <RyanT5000> to be more specific, i have an associative list of pixel values, and i want to throw them into ram so i can hand them off to OpenGL
18:48:44 <eivuokko> Write your own poke-recursion on the list.
18:49:12 <Lemmih> newArray . map snd?
18:49:24 <RyanT5000> it's not ordered
18:49:38 <RyanT5000> what i'm currently doing is mapM_ writeArray
18:49:40 <dons> hmm, write a packing function. using pokeElem?
18:49:48 <dons> ah , yes, as eivuokko says
18:50:24 <RyanT5000> eivuokko using pokeElem?
18:50:51 <RyanT5000> right now this is about 85% of the total time spent in my program (not count spinning waiting for vsync)
18:51:28 <eivuokko> I think Simon said increasing ptr and passing it forward is optimised better by ghc, but I am not sure.
18:51:43 <RyanT5000> well the list isn't sorted
18:51:50 <RyanT5000> well, it's "semisorted"
18:52:02 <RyanT5000> it has maybe 8 regions, each of which is sorted
18:52:35 <palomer> so merge them
18:52:45 <eivuokko> Takes more time than writing with pokeElem, heh
18:52:54 <RyanT5000> yeah
18:53:12 <eivuokko> Out of curiosity, what data is that?
18:53:16 <RyanT5000> it's a bitmap
18:53:19 * eivuokko is playing around with D3D
18:53:22 <monochrom> An associative list is readily convertible to an immutable array by Array.array.
18:53:35 <RyanT5000> are immutable arrays storable? is it efficient?
18:53:51 <monochrom> An immutable array is readily convertible to a storeable array (which is a mutable array too) by unsafeThaw.
18:54:07 <RyanT5000> hm, i'll give that a shot
18:54:10 <drakioned> can I ask a quick question about case expressions?
18:54:29 <eivuokko> drak, yeah.
18:54:45 <eivuokko> drak, always just ask such questions, it is likely someone will answer :)
18:54:48 <monochrom> Some copying may be involved.
18:55:24 <RyanT5000> hm... maybe this is a pointless exercise
18:55:41 <drakioned> if I define something like foo e = case (head e) of
18:55:42 <drakioned>                                                       'x' -> whatever, inside the whatever, is it possible to still access the value of e, and if so, how?
18:55:53 <eivuokko> RyanT5000, anyway, if that 85% is important, it sounds your data might benefit from being in correct format from the beginning, ie serialised into memory buffer.
18:56:02 <RyanT5000> lol it is :)
18:56:08 <RyanT5000> i was playing with this algorithm
18:56:18 <RyanT5000> it just needs to be resized and flipped
18:56:26 <RyanT5000> or, actually, just resized
18:56:36 <heatsink> > let {foo x = case (head x) of y -> x} in foo "abc"
18:56:37 <lambdabot> "abc"
18:56:41 <RyanT5000> i was just trying this out to see if it was going to be efficient at alll
18:56:45 <RyanT5000> answer: no
18:56:56 <heatsink> drakioned, just use the variable name
18:56:57 <eivuokko> RyanT5000, hehe
18:57:27 <RyanT5000> eivuokko: the point of this is that it makes resize . flip very efficient
18:57:44 <RyanT5000> (flip :: Bitmap -> Bitmap)
18:58:30 <RyanT5000> is there a way to make resize.flip automatically composed efficiently without a difficult conversion before and after?
18:58:33 <monochrom> I cannot confidently say my suggestion will run faster.
18:58:35 <drakioned> ok
18:59:50 <RyanT5000> monochrom: yeah, but i'm going to rewrite as blit code
19:00:16 <RyanT5000> actually... this is probably easier in C
19:00:37 <RyanT5000> hm
19:01:43 <eivuokko> It isn't neccesarily hard to do with help of Foreign.Storable, but efficiency might drop a little (or not).
19:01:56 <RyanT5000> yeah
19:02:07 <RyanT5000> i think it should really be done in a DSL
19:03:06 <RyanT5000> where the blit operations are builtin operators
19:03:09 <eivuokko> If you can pick nice functions for it, it might be possible to get ghc optimise it.  Maybe with help of rules-pragmas.
19:03:16 <RyanT5000> hm
19:03:32 <eivuokko> DSLs inside haskell are nice
19:03:41 <RyanT5000> well for now i'll just use peek/poke
19:03:45 <RyanT5000> is there a memcpy?
19:03:55 <RyanT5000> i might as well copy whole rows at once
19:04:20 <eivuokko> copyArray/moveArray
19:04:27 <eivuokko> (in somewhere Foreign)
19:04:45 <RyanT5000> i love hoogle
19:04:51 <eivuokko> Hehe
19:05:04 <eivuokko> I just wish it was integrated in Visual Studio..
19:05:19 <RyanT5000> i presume the "storable" stuff for, e.g., Word32, is pretty well optimized?
19:08:11 <eivuokko> Yeah, probably.
19:08:26 <RyanT5000> actually, maybe it doesn't store/unstore stuff
19:08:37 <RyanT5000> maybe it just uses the sizeof function
19:08:50 <eivuokko> for copy/moveArray, I surely hope so
19:09:36 <drakioned> quick question: is it possible to do something like foo a b = SomeConstructor { a, b } ?
19:10:04 <eivuokko> drakioned, what do you mean by {}?
19:10:34 <RyanT5000> yeah, although i don't think there's any stated constraint that Storables need to have a value that depends only on the bytes in the pointer given to them to deserialize from
19:10:43 <drakioned> well, if I have a declaration further up saying data SomeData = SomeConstructor { Int, Int }
19:10:49 <RyanT5000> without that constraint, you technically need to store/unstore them
19:11:04 <eivuokko> RyanT5000, uhm, I think the intent is pretty clear, if not specified.
19:11:16 <RyanT5000> true
19:11:21 <RyanT5000> but it should be specified
19:11:29 <eivuokko> Well, check ffi spec :)
19:11:39 <RyanT5000> i guess hoogle docs aren't authoritative?
19:11:52 <RyanT5000> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html#t%3AStorable
19:12:44 <RyanT5000> it talks about alignment, but not nondependence on IO other than peek/poke
19:12:47 <eivuokko> drakioned, that constructor has invalid syntax without giving field names (the record syntax - {})
19:13:16 <eivuokko> drakioned, if you have record, you can still use positional arguments like SomeConstructor a b
19:13:28 <drakioned> oh, ok
19:14:26 * drakioned is new to the record concept.
19:15:00 <eivuokko> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-320005.7
19:15:45 <eivuokko> RyanT5000, sizeOf and alignment are constants and may not evaluate their arguments.  Also continiguoussness of array if guaranteed.
19:16:32 <RyanT5000> yeah
19:17:57 <eivuokko> Storable isn't clearly meant for any fancy data structures.
19:18:13 <RyanT5000> yeah
19:18:43 <eivuokko> Wierd requirement that size is divisible by alignment.
19:19:00 <RyanT5000> it's so arrays are aligned
19:20:20 <araujo> boo
19:20:37 <araujo> :-)
19:24:32 <dons> afternoon araujo.
19:24:36 <dons> ?uptime
19:24:36 <lambdabot> uptime: 2 days, 21 hours, 53 minutes and 44 seconds
19:24:50 <araujo> helo dons !!
19:25:01 <araujo> dons, how your coding goes?
19:25:26 <dons> good. writing quick check propertiers and making fps faster :)
19:25:34 <araujo> yay!!
19:25:44 <araujo> @karma+ dons 
19:25:44 <lambdabot> dons's karma raised to 33.
19:26:48 <dons> oh, it was dcoutts and sjanssen prodding me on concat and append.
19:27:03 <dons> ?karma+ dcoutts -- for complaining about concat
19:27:03 <lambdabot> dcoutts's karma raised to 10.
19:27:39 <tuxplorer> Hi ppl! is there a way to handle POST data in HSP? couldnt find one.. :(
19:28:45 <Lemmih> That's one of the reasons I forked it, iirc.
19:33:21 <RyanT5000> aw, Lemmih, no "withLockSurface"
19:33:22 <RyanT5000> :P
19:33:36 <Lemmih> RyanT5000: Send a patch (:
19:33:55 <RyanT5000> haven't learned darcs yet
19:33:58 <RyanT5000> i'll do it asap
19:34:02 <dons> darcs record ; darcs send ...
19:34:04 <RyanT5000> i'll need to use it for SoC i'm sure
19:34:04 <dons> easy peasy
19:34:19 <RyanT5000> also.... i'm not confident in my ability to build it
19:34:26 <dons> actually, i have a 5 min intro to darcs somewhere. .. let me see.
19:34:28 <RyanT5000> fixing the build would be the first priority, imo
19:34:44 <RyanT5000> i had to do like 3 manual fixes to get it to install
19:35:03 <RyanT5000> and it thinks my prefix is c:\Program Files\Haskell :(
19:35:12 <eivuokko> RyanT5000, that is cabal default
19:35:15 <RyanT5000> (yeah, i know i can change that)
19:35:26 <eivuokko> But yes, it sucks.
19:35:34 <RyanT5000> it's actually kind of reasonable, except that only cabal uses it
19:36:25 <tuxplorer> anyone uses HSP?
19:36:40 <RyanT5000> what is it? haskell server pages/
19:36:41 <RyanT5000> ?
19:36:44 <tuxplorer> ya
19:36:57 <RyanT5000> (not that i've used it; just guessed from context)
19:37:04 <tuxplorer> :)
19:39:01 <Cale> palomer: ?
19:41:17 <mathewm> @type sepBy parseExpr spaces
19:41:18 <lambdabot> Not in scope: `sepBy'
19:41:18 <lambdabot>  
19:41:18 <lambdabot> <interactive>:1:6: Not in scope: `parseExpr'
19:42:03 <RyanT5000> hm, i wonder what it would take to make an industrial-strength distributed "map"
19:42:12 <Korollary> ahah. "middle endian" : http://www.catb.org/jargon/html/M/middle-endian.html
19:42:16 <RyanT5000> e.g.: allow the function to be changed in real-time
19:43:14 <RyanT5000> i think the byte order should be 2 3 1 4
19:43:42 <Cale> RyanT5000: with inconsistent results?
19:43:53 <RyanT5000> OOOH: the position of a given bit should be it's place-value, in gray-code, taken as non-gray-code binary
19:43:54 <Korollary> random byte ordering on every op
19:43:54 <Cale> (what happens to already processed data when the function changes?)
19:44:15 <RyanT5000> Cale: the invariant would be slightly different
19:44:30 <RyanT5000> you wouldn't replace it with a diffferent function, but an updated version
19:44:44 <jlhamilton> what's a good way to create a bitmap and save it to a file?
19:44:49 <RyanT5000> so you'd just have the normal versioning problems
19:45:05 <RyanT5000> so you don't reprocess data when the function changes
19:45:08 <jlhamilton> i've been using cairo and gtk2hs for vector graphics
19:45:09 <Cale> okay
19:45:13 <RyanT5000> but you do make sure that everything's atomic
19:45:17 <Cale> I think that's doable.
19:45:32 <RyanT5000> and perhaps you ensure that version1 and version2 results are cleanly broken in the list
19:45:41 <RyanT5000> (i.e.: all the version1 results come before all the version2 results)
19:46:16 <RyanT5000> hm, and how about  a foldb: binary fold
19:46:17 <Cale> you could easily enough write a version of mapM which worked that way
19:46:36 <Cale> just read the function to apply from an IORef or MVar
19:46:37 <RyanT5000> folds every other item in the list, then repeats until there's only one left
19:46:54 <RyanT5000> with those two functions you could write google's mapReduce
19:47:25 <RyanT5000> add instance Storable (a -> b) and you're set :)
19:48:43 <Cale> mapMR rf [] = return []; mapMR rf (x:xs) = do f <- readMVar; f x; mapMR rf xs
19:49:00 <Cale> er
19:49:04 <Cale> mapMR rf [] = return []; mapMR rf (x:xs) = do f <- readMVar rf; f x; mapMR rf xs
19:49:17 <RyanT5000> yeah
19:49:35 <RyanT5000> but then you have to make it distributed :)
19:49:41 <RyanT5000> that's the tough part
19:49:48 <RyanT5000> (comparatively speaking)
19:49:52 <Cale> well, that's the compiler's job :)
19:49:59 <RyanT5000> hm i guess so
19:50:48 <Cale> Or the operating system's. :)
19:51:11 <Cale> MVars work fine with concurrency across threads of course.
19:51:13 <RyanT5000> i don't know if a general-purpose OS can do a good job of distributing arbitrary binaries
19:51:49 <Cale> Oh, no, but I believe I've seen things where explicitly threaded applications could be automatically distributed.
19:52:05 <RyanT5000> true, but there are NUMA issues
19:52:26 <RyanT5000> ghc could deal with them, but the OS would have to use some kind of statistics/heuristics
19:52:38 <Cale> yeah
19:56:29 <Korollary> DownNova eh
19:56:38 <RyanT5000> is there a fillArray?
19:59:36 <dons> memset ? ;)
19:59:45 <RyanT5000> yah
19:59:54 <RyanT5000> ew
19:59:57 <RyanT5000> it's in System.Win32
20:00:12 <RyanT5000> @hoogle memset
20:00:12 <lambdabot> System.Win32.Mem.memset :: Ptr a -> CInt -> CSize -> IO ()
20:00:21 <dons> /dev/wd0g     21.2G   20.1G   36.4M   100%    /home
20:00:25 <dons> yikes!
20:00:31 * dons should get a bigger laptop
20:00:51 <RyanT5000> lol i had the same circumstance earlier today
20:01:05 <RyanT5000> ghc was like "no, you don't have enough space to install me"
20:02:05 <dons> hmm, $ du -hs mp3
20:02:05 <dons> 14.1G   mp3
20:02:20 <dons> should get some external storage.
20:03:08 <Korollary> or switch to aacPlus 24kbit ;)
20:03:24 <dons> or that.
20:03:34 <vincenz> grr
20:03:41 <RyanT5000> pah, lossy compression
20:03:43 <RyanT5000> flac ftw
20:03:53 <Korollary> abx for the win
20:03:58 <RyanT5000> abx?
20:03:59 <dons> $ du -hs src
20:04:01 <dons> 3.2G    src
20:04:06 <dons> so that's where it all is. hmm.
20:04:21 <Korollary> ab/x the original with pretty much any recent codec and I can't tell which is which.
20:04:26 <petekaz> I'm learning about monads and playing with the list monad.  But I'm stumped by something, how do I write the following using 'return' instead of the list constructor directly? [1,2,3] >>= \e -> []?  'return' seems to be expecting an arg, how do I say return nothing?
20:04:41 <Korollary> nonetheless I still encode into flac and burn them onto dvds
20:04:52 <RyanT5000> yeah, flac is pretty decent anyway
20:04:54 <dons> > [1,2,3] >>= return
20:04:55 <lambdabot> [1,2,3]
20:04:58 <RyanT5000> what, 2:1 or 3:1 usually?
20:04:58 <dons> ?
20:05:00 <heatsink> petekaz: that's not return that you want.
20:05:04 <eivuokko> petekaz, fail or mzero in MonadPlus class.
20:05:36 <Korollary> RyanT5000: for my kind of music, I get about 50% reduction
20:06:05 <RyanT5000> not bad; 160kbps is totally reasonable for full-quality
20:06:15 <RyanT5000> most of my MP3s are 192kbps
20:06:52 <heatsink> Is there a (isFinite :: Floating a => a -> Bool) or something similar?
20:07:00 <Korollary> nero just released a free aac encoder. Once the linux version is out I will probably switch
20:07:10 <petekaz> I thought: [1,2,3] >>= \e -> return $ e+1 was the same as: [1,2,3] >>= \e -> [e+1]  But this didn't work: [1,2,3] >>= \e -> return when this works: [1,2,3] >>= \e -> []
20:07:47 <RyanT5000> so, uh, anyone have a memory-filling function for me?
20:08:17 <heatsink> um..... memset?
20:08:24 <RyanT5000> @hoogle memset
20:08:24 <lambdabot> System.Win32.Mem.memset :: Ptr a -> CInt -> CSize -> IO ()
20:08:31 <RyanT5000> is there a nonwin32 version?
20:08:50 <vincenz> ping
20:09:09 <Lemmih> pong
20:09:28 <dons> heatsink: that was a joke.  write a loop.
20:09:29 <heatsink> RyanT5000: try this: foreign import ccall "string.h memset" memset :: Ptr a -> CInt -> CInt -> IO ()
20:09:33 <dons> or use newArray_ or friends
20:09:52 <dons> unless you really have a Ptr that you want to memset
20:09:56 <heatsink> actually, I don't really know what you're trying to do. listen to dons.
20:10:02 <RyanT5000> i really have a pointer
20:10:16 <RyanT5000> i have a texture in memory, and i want to fill it with a color
20:10:18 <dons> foreign import ccall unsafe "string.h memset" memset
20:10:19 <dons>     :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
20:10:24 <dons> i.e. do a replicate n :)
20:10:38 <dons> and make sure you get the right * sizeOf in there..
20:10:45 <RyanT5000> yeah...
20:11:03 <dons> replicate in fps is actually a memset. its fun :)
20:11:34 <RyanT5000> fps?
20:11:40 <heatsink> first person shooter?
20:11:44 <dons> you know, Data.ByteString.
20:11:45 <Korollary> ByteString
20:11:52 <RyanT5000> ah
20:11:56 <monochrom> petekaz: clearly, "return" is not the same as "[]".
20:11:59 <dons> the library formerly known as fps
20:12:12 <dons> but now represented by some weird latin-1 umlaut symbol
20:12:21 <jlhamilton> haha
20:12:25 <heatsink> :)
20:12:48 <petekaz> monochrom: this returns the empty list as I would expect: [1,2,3] >>= \e -> []
20:13:00 <monochrom> That's right.
20:13:16 <monochrom> I'm saying you're making a wrong leap of faith.
20:13:40 <petekaz> monochrom: and while learning about monads, that function to the right is supposed to return a monad, which in this case is the List monad, which I construct using the list constructor.
20:13:49 <dons> -ddump-simpl-stats is my new favourite ghc flag
20:13:57 <petekaz> But 'return' is suposed to created the monad for me right?
20:14:21 <monochrom> [] is fail
20:14:22 <petekaz> which is why this works: [1,2,3] >>= \e -> return (e+1)
20:14:35 <petekaz> oh.
20:14:37 <monochrom> return (e+1) is the same as [e+1]
20:14:44 <petekaz> I have not gotten to this fail stuff yet.
20:14:54 <petekaz> only >>= and return
20:15:02 <petekaz> right!
20:15:05 <eivuokko> > [1,2,3] >>= const Control.Monad.mzero
20:15:06 <lambdabot> Add a type signature
20:15:17 <petekaz> so whats the same as [] using 'return'?
20:15:26 <eivuokko> petekaz, there is no such thing
20:15:27 <monochrom> Nothing.
20:15:36 <petekaz> Ahh ...
20:15:42 <monochrom> You also make wrong type inferences.
20:15:44 <petekaz> so return MUST take something.
20:15:46 <RyanT5000> how do you use two "with" functions on the same block? (nested)
20:16:03 <monochrom> [] :: [a].  return :: a -> [a].   [a] is not a->[a].
20:16:04 <heatsink> petekaz: return must return something.  [] doesn't have anything in it.
20:16:18 <eivuokko> RyanT5000, with foo $ \foo -> with bar $ \bar -> do ..
20:16:25 <RyanT5000> ah ok
20:17:11 <eivuokko> RyanT5000, You can write your own combinators for with-style functions, but afaict there's nothing much in Foreign or other libs
20:17:42 <RyanT5000> yeah; closure-style will do quite nicely though
20:17:43 <heatsink> petekaz, (return 1 >>= myFunction) passes the value 1 to myFunction.  ([] >>= myFunction) doesn't pass any value to myFunction.  Computation stops at the [].  That's what "fail" means.
20:18:15 <petekaz> Ok.  I understand now.  My confusion is that I thought a monad only consisted of defining >>= and return, and then I was thinking about how on earth the list monad could drop things from the original list.  The only way I was able to do that was by not using 'return', and just use [] directly.  So I thought I was doing something wrong as I had the wronig impression that 'return' was used.
20:19:41 <petekaz> Moral of the story, I should continue reading 'all about monads' before experimenting.
20:20:40 <heatsink> monads are hard to grok, don't worry about getting it wrong in the beginning.
20:21:55 <dons> yeah, its such a fundamental thing, learnign to abstract over sequencing of computation. such a strange concept never taught to the average undergrad. its not surprising it takes a while to get. like recursion in some ways.
20:25:06 <petekaz> I asked earlier, but didn't get what I was looking for.  What would be a simple monad to write?  I don't want to write one that exists (like Maybe or List).  I'm more interested in trying to see if I can grok the abstracting over a sequence of computation as dons just mentioned.
20:25:24 <monochrom> You can use mzero for [].  Remember to import Monad.
20:25:29 <petekaz> I don't care if it's completely useless.
20:26:28 <monochrom> ([1,2,3] >>= \e -> []) ++ ([4,5,6])   You know what this does.
20:26:33 <petekaz> Just something tangible I can try to wrap my head around?  Any teachers here?  What do you use in class?
20:26:50 <monochrom> ([1,2,3] >>= \e -> mzero) `mplus` ([4,5,6])   This is the monadic equivalent.
20:27:25 <petekaz> monochrom: haven't got to mzero or mplus stuff yet.  just bind and return.
20:27:43 <heatsink> petekaz, One thing you can do is write a specialized instance of a state monad.  People do this frequently in practice.
20:27:56 <tennin> monads are what attracted me to Haskell though
20:28:14 <RyanT5000> tennin: me too
20:28:31 <petekaz> heatsink: specialized in what sense (haven't used the state monad)
20:29:00 <RyanT5000> which is faster: pred or (-1)?
20:29:03 <RyanT5000> for Ints
20:29:18 <RyanT5000> i have a "very tight loop" using this
20:29:23 <heatsink> petekaz, It's a sequential monad like IO, so (>>=) and return do the obvious things if you know how to use IO.  The difference is that there's some extra invisible variables, and special functions to access them within the monad.
20:29:40 <Korollary> RyanT5000: Is your program running yet?
20:29:48 <RyanT5000> it will be in a moment
20:29:57 <dons> 131M  131M sleep    poll     0:24 64.70% ghc-6.4.2
20:29:58 <RyanT5000> or do you mean compared with yesterday?
20:30:18 <heatsink> petekaz, e.g., clearCounter :: CounterMonad (), incrementCounter :: CounterMonad (), readCounter :: CounterMonad Int
20:30:24 <dons> oh, even gcc gets to 50M< compiling this file. hmm.
20:30:29 <Korollary> Korollary: If speed is such a concern, you'll need to pay attention to unboxing of ints.
20:30:34 <Korollary> err
20:30:37 <RyanT5000> hm
20:30:47 * Korollary is crazy talking to himself
20:30:49 <RyanT5000> well i'll wait until i have a clue what i'm doing :P
20:30:59 <petekaz> heatsink: ok, thanks for the suggestion.  I'll use that as an example
20:33:49 <tennin> also, for me going from monads to arrows was almost as hard as learning monads in the first place
20:34:00 <tennin> that doesn't seem to be the case for most people though
20:34:31 <petekaz> One more question about haskell.  In my experience, there are generally 2 classes of programmers when it comes to debugging a program.  One class uses a debugger, the other simple uses print statements.  I fall into the latter, but in haskell, I can't arbitrarily add print statements in pure functions.  What do people do?
20:34:43 <Korollary> you can add trace
20:34:48 <Korollary> @index trace
20:34:49 <lambdabot> Debug.Trace
20:35:07 <petekaz> Ok, thanks.  I'll read up on it.
20:35:11 <Korollary> I despise debuggers myself
20:35:15 <petekaz> Me too.
20:35:41 <petekaz> I abhor them.
20:35:51 <monochrom> You forgot there is a third class.
20:36:00 <Korollary> also QuickCheck is very popular
20:36:07 <petekaz> you don't make mistakes?
20:36:40 <monochrom> I do unit test on very fine grain units, i.e., I write small functions and test them (in ghci say).
20:37:20 <monochrom> Also I make mistakes rarely.  A little bit of unit testing suffices.
20:37:47 <RyanT5000> i don't see how anyone could use C++ for anything real without a debugger
20:37:54 <RyanT5000> well, i see how
20:38:00 <RyanT5000> but it involves wasting huge amounts of time
20:38:03 <monochrom> That's right, that's C++.
20:38:08 <eivuokko> Uhm
20:38:11 <Korollary> I have
20:38:13 <petekaz> re: unit testing.  I use unit testing in other languages, but that was never enough because of the various amount of side-effects that take place.  I suppose in haskell, this is not a problem, and thus using only unit tests might be more than enough.
20:38:15 <Korollary> no debugger c++
20:38:22 <RyanT5000> i know it can be done; i've done it too
20:38:23 <eivuokko> Not neccesarily.  I write C+++ daily and don't use debugger all the time.
20:38:27 <RyanT5000> but why would anyone ever choose to?
20:38:39 <monochrom> If there were g++i, I would not need a debugger for c++ either.
20:38:45 <Korollary> because the debugger doesnt help me any more than I need
20:38:58 <RyanT5000> monochrom: i disagree; you don't have referential transparency
20:39:03 <petekaz> RyanT5000: I haven't programmed in C/C++ for many years.  My debugging comment relates to python, perl, ruby, java.
20:39:18 <dons> petekaz: in Haskell we usually write QuickCheck properties for our unit tests, and we get our test data generated for us.
20:39:37 <monochrom> But I would write programs with almost referential transparency in any language.
20:39:49 <dons> so you just work out all the algebraic properties of the functions in your code, and write them down, then QC tests these properties.
20:39:51 <RyanT5000> hm, true, but there's not good support for that in C++
20:40:02 <monochrom> Even in Haskell I write imperative code.  The upshot is side effects are localized.
20:40:24 <dons> petekaz: I write tests like: prop_sort3 xs = (not (null xs)) ==> (P.last . P.sort . pack $ xs) == maximum xs
20:40:26 <monochrom> All I need to do is to bring that habit to any programming.
20:40:45 <RyanT5000> i wish i had learned haskell after knowing C++ for like 2 years rather than 7
20:40:53 <petekaz> monochrom: I find myself actually writing in a more functional style these days when programming in other language (I use python extensively at work these days) just from my few months experience with Erlang.
20:40:57 <RyanT5000> enough to appreciate it, but not so much wasted time in between
20:40:59 <dons> petekaz: and then QuickCheck generates and tests this property. its a great way to semi-verify your code.
20:41:22 <monochrom> A little bit of OOP helps localizing side effects too.
20:41:46 <petekaz> dons: nice, so it takes the tedium out of writing a ton of test cases manually?
20:42:13 <dons> right. you just work out the high level properties you wanted handled, and QuickCheck will generate N random tests for you.
20:42:34 <dons> this is how most new library code in Haskell is tested.
20:42:42 <petekaz> so much too learn ...
20:42:48 <dons> there's QuickCheck for Java too.
20:42:51 <dons> it got ported.
20:43:05 <petekaz> thanks for all of the input everyone.  Time to get back to all about monads.
20:45:18 <monochrom> I must not give you the impression that I never use a debugger.
20:45:44 <monochrom> When I examine someone else's poorly written program, that's when I need a debugger.
20:46:52 <monochrom> "There are two ways of designing a system...
20:48:04 <monochrom> "You can make it so simple that it obviously has no errors..."  <-- that's my code, you don't need a debugger, just review the code, and use a few test cases to make sure your review is on track...
20:48:26 <monochrom> "Or you can make it so complicated that it has no obvious errors."  <--- that's when you need a debugger.
20:54:27 * araujo looks around
20:57:13 <araujo> @keal
20:57:14 <lambdabot> bot seems useless
20:57:59 <dons> hehe
20:58:34 <araujo> :-)
20:59:25 * araujo thinks that with this 1024x780 res. his eyes will suffer less
21:04:18 <eivuokko> Is there a big dangerous downside on using overlapping instances and incoherent instances?
21:04:31 <Cale> yes
21:04:36 <eivuokko> And it is?
21:04:41 <Cale> incoherent in particular
21:05:03 <Cale> you can use it to break the safety of ST and lose referential transparency
21:05:13 <eivuokko> Uhm.
21:05:58 <eivuokko> I don't really get it, but thanks.
21:06:22 <Cale> Let me find the relevant post
21:07:44 <Cale> ah, here it is
21:08:02 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.general/13175/
21:08:58 <eivuokko> I am trying to make a lib to write d3d shaders inside haskell, but statically preserving properties about register and required shader versions.  I need overlapping for similar stuff region stuff as Oleg uses (but my values can be used in regions that nest) and incoherent for not forcing user to write signatures (which are annoyance to do).  I got it working other way, but it require no-monomorphism restriction (and overlapped instances)
21:09:04 <eivuokko> Thanks!
21:11:44 <Cale> no-MR is certainly safe, I think overlapped instances are considered okay for the most part.
21:12:58 <eivuokko> Yeah, I am not scared by infinite compilations or such things.  This ST stuff is disturbing tho
21:25:49 <RyanT5000> so i just finished rewriting to combine all my blit operations
21:25:59 <RyanT5000> they're easily 1000x faster than the associative list way
21:26:58 <RyanT5000> is there an irc channel for freetype?
21:27:19 <RyanT5000> i have no clue how to tell it "I need a texture x pixels high"
21:27:29 <RyanT5000> maybe someone in #sdl will know...
21:44:54 <araujo> Hi!
21:58:17 <petekaz> I'm sure this is all wrong, but don't tell me that part, I want to figure it out.  However, I need help to print out the value 'c' so I can see if it's working or not.
21:58:23 <petekaz> http://paste.lisp.org/display/19739
22:00:17 <petekaz> or am I doomed?
22:01:03 <Lemmih> dons: Neat WC example.
22:01:11 <falconair> i'm trying to learn how to program a very simple database engine in haskell (this is my motivating exercise to learn haskell)...can anyone recommend some existing source code I can read to get ideas?
22:03:07 <Lemmih> petekaz: Make CounterMonad an instance of Show?
22:03:31 <Lemmih> petekaz: print (return 0 >>= ...)
22:03:34 <dons> Lemmih: yeah, now that length . P.lines fuse. :)
22:04:39 <petekaz> Lemmih: is it not possible to print from within the lambda?  I want to continue the example with more incrementCounter calls after the print, and then print again.
22:05:35 <Lemmih> petekaz: You could make CounterMonad transformer.
22:05:53 <petekaz> oh boy, more words I don't know ...
22:07:24 <petekaz> let me ask another way, how can I see if my counter monad is actually working if printing values is not possible.  Again, please do not tell me if the counter is right/wrong, I want to figure that part out, but I can't figure out how to tell if its working.
22:10:36 <Cale> petekaz: you can return a value which captures the value of the counter at various points
22:11:16 <Lemmih> petekaz: Perhaps you'd be interested in Debug.Trace.
22:11:55 <Cale> > let {inc = do {x <- get; put (x+1); return x}} in runState (do {x <- inc; y <- inc; z <- inc; return [x,y,z]}) 0
22:11:56 <lambdabot> ([0,1,2],3)
22:12:42 <Cale> but yeah, Debug.Trace can be handy when this is impractical
22:13:23 <petekaz> ok ... I'll save this and try to digest in the morning.  Haskell is hard.
22:13:31 <Cale> (though please don't use it if you actually care about the output messages -- it's really only good for debugging)
22:14:04 <Cale> petekaz: a counter monad?
22:14:25 <Cale> Have you seen my monads on the old wiki?
22:14:36 <Cale> @oldwiki MonadUnique
22:14:36 <lambdabot> http://www.haskell.org/hawiki/MonadUnique
22:14:39 <Cale> @oldwiki MonadSupply
22:14:39 <lambdabot> http://www.haskell.org/hawiki/MonadSupply
22:14:56 <petekaz> I'm just trying to test my knowledge of what little I've read of all about monads.
22:15:20 <petekaz> I saw yours, but I wanted to make my own to see if I could grasp the concept.
22:15:26 <Cale> cool
22:15:34 <petekaz> Looking at yours was no good because the answer was right there :-)
22:16:08 <petekaz> I asked for any pointless example that I could try.  Someone suggested this.
22:16:27 <Cale> did you do my tree monad example?
22:16:48 <petekaz> I don't think I've seen that one.
22:16:53 <Cale> data Tree a = Leaf a | Branch [Tree a]
22:17:00 <Cale> write a monad instance for that :)
22:17:11 <Cale> or even just
22:17:17 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
22:17:44 <petekaz> Ok, that's a good idea.
22:18:24 <petekaz> I am still having a hard time thinking in terms of the combination of computations.  What type of computations am I combining for this example?
22:18:47 <Cale> nondeterministic results
22:18:59 <Cale> (it's rather similar to the list monad in that respect)
22:19:04 <petekaz> or rather, can you show me a line of code that would use this monad?
22:19:23 <petekaz> It seems to help if I see the end use of it.
22:19:45 <Cale> well, you could use it for manipulating trees in a possibly convenient way
22:20:22 <petekaz> By adding one to all the elements for example if it were a tree of ints?
22:20:43 <Cale> do x <- myTree; return (x+1)
22:21:10 <dons> dcoutts_: ah, interesting. I get too many Eqs withn using -O and ghc 6.5. I think that must be the compare bug you spotted.
22:21:34 <Cale> do x <- myTree; Branch (return $ 2*x) (return $ 2*x+1)
22:21:52 <Cale> see if you can sort out what that would do
22:22:44 <dons> dcoutts_: hmm. I think ghc is miscompiling it!
22:23:26 <Cale> (or just write the monad instance and try it -- you won't have many options as to how to write it, so long as you keep things passing the typechecker)
22:23:29 <petekaz> for each leaf, turn it into a branch with two leaves (one doubled the orig value, and the other, one more than the other)
22:23:35 <Cale> yes
22:23:43 <Cale> exactly :)
22:23:46 <petekaz> neat.
22:23:55 <petekaz> now lets see if I can write it.
22:24:01 <petekaz> Thanks for the help.
22:24:06 <Cale> no problem
22:24:35 <petekaz> I'm going to sleep now (its 1am here, been up since 4am), but I'll sleep on it.
22:24:54 <Lokadin> ??flexible knees
22:24:54 <lambdabot> Unknown command, try @list
22:24:58 <Lokadin> oops
22:28:38 <dons> hmm. can't use inlinePerformIO on packByte. very interesting.
22:30:15 <dons> Hairy McScary
22:30:58 <Lemmih> You can't?
22:33:17 <dons> well. its turning packByte 1 `compare` packByte2 --> x <- newForeignPtr ; writeIntOffAddr x 0 1 ; writeIntOffAddr x 2 ; compare x x !!
22:33:48 <dons> only in the head.
22:34:29 <dons> must be a bug, surely.
22:40:16 <dons> this is amazing to me:
22:40:17 <dons> -- packByte 255 `compare` packByte 127
22:40:17 <dons> --
22:41:46 <Lemmih> eh?
22:45:12 <dons> -- case mallocByteString 2 of                                                                         --      ForeignPtr f internals -> 
22:45:16 <dons> --           case writeWord8OffAddr# f 0 255 of _ -> 
22:45:18 <dons> --           case writeWord8OffAddr# f 0 127 of _ ->
22:45:21 <dons> --           case eqAddr# f f of 
22:45:23 <dons> pretty amazing thing to do.
22:45:25 <dons> --                  False -> case compare (GHC.Prim.plusAddr# f 0) 
22:45:27 <dons> --                                        (GHC.Prim.plusAddr# f 0)
22:45:30 <dons> sorry. got distracted.
22:47:19 <sethk> dons, If I want to treat a string as a bunch of four byte chunks, I can do this in a pattern?   (x1:x2:x3:x4:xs)     ?
22:48:05 <Cale> sethk: you can pattern match a list like that yes
22:48:50 <sethk> Cale, what I'm doing is calling a function for each chunk of four bytes.  I know the buffer is a multiple of four (it's a 1024 byte buffer).  Is that a reasonable way to approach it?
22:50:09 <Cale> sure
22:50:33 <dons> explicit matching is pretty efficient.
22:52:02 <sethk> It's going to an ffi call into my device driver.  I could just pass the entire 1024 bytes as a CString, but I think I have less C pointer exposure by passing each 4 byte chunk as a CString.
22:53:08 <sethk> can I say:  cstring = newCString [x1:x2:x3:x4]  ?
22:53:25 <Cale> cstring = newCString (x1:x2:x3:x4:[])
22:53:55 <Cale> but if newCString is an IO action, you'll probably want to run that
22:54:05 <sethk> why?
22:54:50 <Cale> because you likely want the actual string and not just an IO action for computing it :)
22:55:10 <sethk> yes, but won't it be forced by the call to the C function?
22:55:39 <Cale> no, you'll have a type error
22:55:45 <Cale> I just mean
22:55:51 <Cale> cstring <- newCString (x1:x2:x3:x4:[])
22:55:54 <Cale> in a do-block
22:56:12 <sethk> oh, newCString is IO CString?
22:56:26 <sethk> right
22:56:30 <Cale> yeah, it's String -> IO CString
22:57:19 <dons> hmm. running these fps benchmarks keeps melting the stickers off the bottom of my laptop :/
23:03:18 <Lemmih> You guys know of a program for distributed testing? Kinda like SETI@HOME, except that people donate CPU time for testing OSS?
23:08:13 <dons> oh, that'd be cool..
23:09:15 <araujo> dons!
23:09:17 <araujo> :-)
23:15:06 <Korollary> Lemmih: Such a program would be quite risky from a security PoV, yes?
23:15:55 <Cale> Not if the programs could do no IO :)
23:16:22 <sethk> distributed programs doing no io would have a somewhat limited area of application  :)
23:16:28 <Cale> Distributed QC
23:16:43 <sethk> but don't tell anyone the results?
23:16:48 <Cale> hm?
23:17:05 <sethk> no i/o, nobody can discover anything done by any of the programs
23:17:08 <Korollary> That's not really a safety because GHC itself may have flaws that could be exploited.
23:17:17 <Cale> sethk: only the test harness does any IO
23:17:26 <Lemmih> Korollary: Yeah, I thought about writing a EDSL for writing tests that could be proven safe.
23:17:29 <dons> well, no more unsafe than passing around seti programs.
23:18:15 <Cale> sethk: you give it a pure function and some properties to check, and it gets computers to test them
23:18:16 <dons> we have the technology though. you could probably only does this in haskell 
23:18:57 <dons> so a OS Haskell distributed QuickCheck could work, I think.
23:19:10 <dons> as long as the end user could run the typechecker themselves to verify things. oh, but this is just proof carrying code, right?
23:19:32 <Korollary> Is there a case for an enormous testcase suite that has to be distributed and DOES provide value?
23:19:33 <dons> it just might be easier to state the no-IO proof in Haskell. source.
23:20:20 <Cale> dons: yeah, that's what I was thinking -- basically lambdabot's security model :)
23:21:07 <Cale> > readFile "/etc/passwd" >>= putStrLn
23:21:08 <lambdabot> No IO allowed
23:21:26 <sethk> Cale, still, if it "gets computers to test them" (the properties), either those computers report the result, which is i/o, or the harness never discovers the result, which would seem to be a drawback of the approach
23:21:55 <Cale> sethk: but the IO involved in reporting the result isn't part of the distributed code
23:21:56 <dons> right. one simple proof: no IO. one simple proof encoding: the Haskell type system. one simple proof checker, the H98 type checker and inference.
23:21:59 <Cale> it's trusted code
23:23:03 <dons> we call it "Practical PCC for the Masses" :)
23:23:15 <dons> with Class, perhaps.
23:23:25 <Korollary> But what is the problem that this solves? Do tests currently provide insufficient coverage due to lack of cpu power?
23:23:44 <dons> i've been known to do distributed ghc nightly builds and testsuite (+ nofib)
23:23:52 <dons> that takes about 6 hours these days, it used to take nearly 24
23:24:03 <Lemmih> Almost none of my code has been testing on anything else than Linux-x86.
23:24:05 <dons> so I'd run the testsuite ways and nofib across a cluster
23:24:29 <dons> but i think Lemmih's interested in different archs, not in speeding up large test sets
23:24:47 <Korollary> Lemmih: Pure code is unlikely to run differently on a different arch anyway
23:25:11 <dons> well...
23:25:22 <Lemmih> Korollary: Many of my projects don't even build on MacOS and Windows.
23:25:42 <dons> Int is an Int is an Int? or an Int64...
23:25:55 <dons> but yeah, in Haskell, its more just checking it builds that is important
23:26:10 <Korollary> Lemmih: That's a separate problem. If they did build and run, the majority of the differences would be caused by code that does IO.
23:26:50 <Cale> Not to mention doing performance testing
23:26:57 <palomer> Cale: ?
23:27:10 <Cale> palomer: did you see the parsing example
23:27:12 <Cale> ?
23:27:20 <palomer> given by edwinb?
23:27:33 <Cale> palomer: the one I put on the GADTs page on Haskell.org
23:28:40 <heisenbug> Cale: URL?
23:28:49 <palomer> yeah, URL?
23:29:47 <palomer> ahh, that is a good example
23:29:52 <palomer> because we write parsers in the meta language
23:30:42 <palomer> good point
23:31:26 <Lemmih> Korollary: Hm, right. We can use the different archs for build testing and the CPU power for crunching through QC tests.
23:31:59 <Cale> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype in case anyone hadn't found it
23:32:25 <Korollary> Lemmih: How long does it take currently for the QC tests on your machine?
23:33:46 <palomer> Cale: if ever you find more examples, put them on the page
23:33:48 <Cale> palomer: it's quite possible to do that with typeclasses, but GADTs happen to be particularly nice for it, and provide the ability to decompose parsers structurally to some extent after they've been built
23:33:49 <palomer> I'll do the same
23:33:56 <Lemmih> Korollary: If I ran each test a thousand times, quite a while I'd think.
23:34:05 <palomer> Cale: decompose structurally?
23:34:28 <palomer> well, that's the thing, I can't find an example where typeclasses wouldn't suffice
23:34:53 <Cale> The nice thing about implementing an EDSL as a GADT is that you essentially have the parse tree for your metaprograms, and so you could do lots of transformations which would be impossible in other representations.
23:35:33 <Cale> code -> code transformations before anything is run -- sort of like arrows give you, but without quite so much complication.
23:36:06 <palomer> you might have the type tree
23:36:21 <palomer> EDSL=domain specific language?
23:36:30 <Cale> embedded domain specific language
23:36:31 <Cale> yeah
23:36:36 <palomer> Cale: can you give an example of what you're talking about?
23:37:35 <ADEpt> is Leandro Lisboa Penz (lpenz) somwhere here on irc?
23:37:37 <ADEpt> morning
23:37:41 <Cale> well, in the parsing example, you could transform your parser in order to make it more efficient before parsing
23:38:06 <Korollary> Lemmih: There also needs to be a case for running the test a million times. How many defects does that catch, etc. If it's churning cycles without adding value, there's not much point.
23:38:08 <Lemmih> Korollary: Imagine tens of projects (hunreds if we integrated this into HackageDB), each with large test sets. It'd be nice to have some cpu power for tracking down erroneous patches.
23:38:14 <Cale> (the primitives I have in that example are not ideal for that, but you could still do a few things)
23:38:27 <palomer> Cale: you can't do that with typeclasses?
23:38:38 <Cale> no
23:38:57 <palomer> or you can't do it safely with typeclasses
23:39:18 <palomer> there are some transformations which would simply not work with typeclasses?
23:39:29 <palomer> are they intermediate steps?
23:39:33 <Cale> well, with the typeclass version, you have a bunch of functions you use to build up a parser
23:39:37 <Cale> but they're not constructors
23:39:48 <Cale> you can't go and decompose your parser again once it's uilt
23:39:50 <Cale> built*
23:40:33 <Lemmih> Korollary: It would still be quite a lot of work with the normal 100 test runs.
23:40:50 <palomer> oh, I see, the parser is the program
23:40:57 <Cale> yeah
23:41:04 <palomer> or, rather, the parser is the program in the object language
23:41:08 <Cale> right
23:41:45 <Cale> and here, we have the parser producing the interesting bits of what it parsed, as a Haskell data structure.
23:41:48 <palomer> you can't do that with typeclasses?
23:42:11 <Cale> you can't do it in such a way as to allow the parser to be decomposed
23:42:23 <palomer> hrm
23:42:28 <Korollary> Lemmih: I'd be more interested in something that only tests code that has changed since it was last tested.
23:42:33 <palomer> I'd have to see a parser written with typeclasses
23:42:36 <Cale> (at least, not to the extent that GADTs allow)
23:42:45 <palomer> I'm guessing it builds the monad in a similar fashion to state?
23:42:48 <palomer> State, rather
23:43:00 <palomer> could we write a parser which handles left recursion this way?
23:43:42 * palomer is thinking we could
23:43:48 <Cale> yeah
23:44:10 <Lemmih> Korollary: Of course, if no tests failed with the latest patch then there's no need to test the intermediate patches.
23:44:35 <palomer> hrmph
23:44:48 <palomer> are you sure? this could make for an interesting SoC  project
23:44:51 <palomer> willing to mentor me?
23:44:54 <Lemmih> Korollary: Or is that not what you meant?
23:46:25 <Cale> well, we'll have to look a little closer -- I'm pretty sure it can be done without *too* much hassle, but there's a big gap between regular-expression type parsing and CFG parsing :)
23:46:36 <Korollary> Lemmih: No, what I mean is that when you run quickcheck it annotates the source (with a checksum or something) that when you attempt to run the test again, it does nothing. That should cut down a lot of cpu time since only new code is tested. (I suppose you may want to override this decision, etc.)
23:46:53 <Cale> also, you'd probably want to be able to project out more meaningful results.
23:47:38 <palomer> project out?
23:47:39 <Cale> so some way of folding in transformations on the result of a parser into the parser itself would be in order (and whether or not that gets in the way of optimisation is a concern)
23:47:47 <araujo> :-)
23:48:21 <palomer> the deadline for SoC proposals is may 8th, 5pm pacific time
23:48:38 <palomer> I'll write out a proposal and send it to haskell.org through google
23:48:44 <palomer> and then I'll put it on the wiki
23:49:03 <Cale> Like, in my examples, the return value of the generated parser is predetermined entirely by its structure, and there's no way to do anything with it during parsing, or even to manipulate it at all before it's returned by parse
23:49:05 <palomer> it'll simply state that I want to write a version of Parsec which supports left recursion, and whatever that would entail
23:49:22 <palomer> Cale: why can't you do anything during parsing?
23:49:44 <Cale> palomer: because my current metalanguage has no syntax for it
23:50:01 <Cale> so you'd need to construct some...
23:50:32 <Cale> Map :: (a -> b) -> Parser tok a -> Parser tok b
23:50:40 <Cale> and perhaps even
23:51:01 <Cale> Bind :: Parser tok a -> (a -> Parser tok b) -> Parser tok b
23:51:57 <Cale> basically, squeeze the thing into a monadic framework :)
23:52:05 <palomer> sure
23:52:35 <Cale> but higher-order things like that might affect how well we can do as far as rewriting goes
23:52:43 <Cale> *especially* bind
23:53:30 <Cale> though, if we interleaved rewriting with parsing, it wouldn't be so much of a problem
23:54:17 <Cale> (the issue is that you have a parser on the right hand side of a function arrow that you can't access because you don't know what it is yet)
23:54:42 <palomer> what if we changed our arrow?
23:55:14 <Cale> well, the only things we can really do is compose on the left and right
23:55:35 <palomer> compose parsers?
23:55:40 <Cale> compose functions
23:56:06 <Cale> If we have a parser (Bind x f)
23:56:22 <palomer> ah, the right side of f
23:56:24 <Cale> then we can fiddle with x all we like
23:56:35 <Cale> but the result of f is less accessible
23:56:38 <Cale> however
23:56:48 <Cale> we could inject a composition with our rewriter
23:57:01 <Cale> (Bind x (optimise . f))
23:58:15 <palomer> why not have it as Bind :: Parser tok a -> (a --> Parser tok b) -> Parser tok b
23:58:53 <palomer> where (a --> Parser tok b) is something written in another EDSL
23:58:57 <Cale> yeah
23:59:01 <Cale> that's an option :)
