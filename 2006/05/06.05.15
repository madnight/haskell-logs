00:00:02 <dons> Arbitrary instance, I  mean
00:00:04 <ADEpt> dons: then defrag should effectively produce "different fragmentation"
00:01:12 <dons> group's really inefficient anyway. I'm going to comment it out for now.
00:02:20 <osqulda> I can think about a very naive string matcher that creates a list of matchings [t,f,t,f,f,f,f,f,f,t,...] for a string, indicating each occurrence. I'd create
00:02:45 <osqulda> this list using \x -> scanl (scanr (==s))) or something like that.
00:03:13 <Korollary> osqulda: Why not use Text.Regex?
00:03:15 <osqulda> The result would probably be O(n^4) in the max of the two string lengths.
00:03:26 <osqulda> Aha, but it is interesting to try myself first.
00:03:34 <osqulda> I am going to advise two students...
00:03:46 <Korollary> oh ok
00:04:13 <shapr> Coarbitrary for scaling, yeah?
00:05:24 <Korollary> osqulda: Data.List has span, splitAt, etc. that might be useful.
00:05:44 <dons> ADEpt: you workign on the random seed for the QC tests? Or should I just hack it up now.
00:06:16 <osqulda> so you do not like my scanl.scanr approach? ;-) It is horrible, I admit it.
00:06:21 <osqulda> But maybe it can do for a spec.
00:07:35 <dons> ADEpt: the problem was it was using mkStdGen seed, instead of getStdGen
00:07:38 <ADEpt> dons: patch is 99% ready :)
00:07:43 <osqulda> the optimal program is probably span + some clever foldr
00:08:29 <dons> ADEpt: oh, already one :)
00:08:32 <dons> but send anyway
00:08:46 <dons> I'll revert mine.
00:08:53 <osqulda> is there a string matcher somewhere that I can have a look at?
00:09:26 <dons> I just wrote: mycheck config a = do
00:09:26 <dons>     rnd <- getStdGen
00:09:27 <dons>     mytests config (evaluate a) rnd 0 0 []
00:09:38 <dons> which seems to work
00:09:59 <lisppaste2> osqulda pasted "assoc law for list monad" at http://paste.lisp.org/display/20030
00:10:40 <osqulda> This is my second question: how to make progress on these two equations (how to equate them) - the list monad laws can easily be proved by induction, but I stubbornly want to get away induction-less using fold-laws and fusion instead.
00:10:43 <ADEpt> dons: newStdGen is better (if i recall properly)
00:10:51 <osqulda> Somehow the list monad assoc should depend on the assoc of ++ etc.
00:11:44 <dons> ADEpt: ah, I see. it is a wrapper over getStdGen
00:11:59 <dons> so that you can use multiple stdGens 
00:12:16 <dons> much the same result in this case, but in a program with multiple Randoms, it would matter, I think.
00:13:32 <dons> ADEpt: sent? how's the patch goign?
00:13:49 <dons> you'll want to pull the patch to disable group I just comitted.
00:14:47 <dons> ADEpt: also, make sure to patch Quick.hs too. It  uses the same seed.
00:16:18 <ADEpt> dons: i did better. see patch :)
00:16:26 <ADEpt> dons: sent
00:17:37 <osqulda> sorry guys, there were some mistakes in the paste, never mind.
00:17:40 <dons> I love gettign patches. thanks.
00:17:54 <dons> oh, very good, ADEpt. cheers!
00:19:37 <osqulda> I also need some volunteers for proof-reading a take-home exam... For that purpose please contact me with a personal message.
00:20:58 <dons> osqulda: where are you teaching?
00:21:02 <osqulda> AFP
00:21:27 <dons> oh, is that the subject , Adv. Functional Programming?
00:21:29 <ADEpt> dons: I sent before pulling. Could you resolve conflicts in Lazy.hs?
00:21:33 <osqulda> I do not like the logging here, so I say not so much! :-) 
00:21:37 <dons> ADEpt: done so. almost done.
00:21:41 <dons> osqulda: oh. ok.
00:21:52 <dons> I'm at UNSW. I love the logs!
00:22:00 <osqulda> I hate to get hits on myself on haskell logs.
00:22:09 <osqulda> I say such nonsense! ;-)
00:22:12 <dons> hehe
00:22:28 <dons> well, if you say enough nonsense, I get to write a lambdabot command for you.
00:22:30 <dons> @keal
00:22:31 <lambdabot> antiparsimony were 100% correct...
00:22:32 <dons> @palomer
00:22:32 <lambdabot> That's nuts!
00:22:40 <dons> so there's always that option.
00:22:47 <osqulda> cheers! ;-)
00:23:35 <dons> oh, I know where you are, possibly.
00:23:54 <palomer> <:O
00:24:03 <palomer> dons: how are my chances looking for the SoC?
00:24:27 <dons> palomer: shrug. its hard to know yet. we don't know how many slots google's goign to give us. we'll find otu in the next few days.
00:24:37 <dons> i've said i'll mentor your project. so its in with a chance
00:25:14 <palomer> k
00:25:17 <palomer> I'm off to bed
00:25:25 <palomer> and I sign off with a palomerism
00:25:27 <palomer> @palomer
00:25:27 <lambdabot> Category theory is the Paris Hilton of mathematics
00:25:34 <palomer> yes!
00:26:49 <neologism> hehe
00:29:03 <ADEpt> @seen dcoutts
00:29:03 <lambdabot> dcoutts is in #haskell-overflow, #gentoo-haskell, #haskell-blah and #haskell. I last heard dcoutts speak 8 hours, 57 minutes and 48 seconds ago.
00:32:48 <osqulda> what can be said about the strictness of   foldr ((++) . h) []
00:33:44 <osqulda> I think: nothing.
00:33:44 <dons> hmm. well, it will force the spine of the list
00:34:18 <dons> its no foldl' though.
00:34:32 <osqulda> sorry, spine?
00:35:15 <dons> well, you have to get to the end of the list to fold right. that's all
00:35:27 <osqulda> but the list could be infinite!
00:35:36 <osqulda> aha!
00:35:44 <osqulda> so you say foldr is strict, but not foldl?
00:35:46 <dons> > foldr ((++) . id) [] [1..]
00:35:46 <lambdabot>  add an instance declaration for (Num [a])
00:36:35 <dons> > oldr (\_ b -> b + 1) 0 [1..]
00:36:35 <lambdabot>  Not in scope: `oldr'
00:36:38 <dons> > foldr (\_ b -> b + 1) 0 [1..]
00:36:40 <lambdabot> Exception: stack overflow
00:36:49 <dons> > foldl (\b _ -> b + 1) 0 [1..]
00:36:53 <lambdabot> Terminated
00:37:04 <dons> oh, we'd actually get some output if I accumulated
00:37:20 <dons> > foldl (\b a -> a:b) [] [1..]
00:37:25 <lambdabot> Terminated
00:37:34 <dons> nope. but you see the difference
00:37:46 * vincenz pats dons on the back
00:37:58 <dons> this has come up several times, actually.
00:38:08 <dons> but its not strict in the way foldl' is.
00:38:14 <osqulda> very interesting!
00:38:18 <dons> i.e. it won't force bottoms in the list
00:38:29 <dons> > foldl (\b a -> a:b) [] [undefined]
00:38:30 <lambdabot> Add a type signature
00:38:34 <dons> > foldl (\b a -> a:b) [] [undefined::()]
00:38:35 <lambdabot> Undefined
00:38:42 <dons> well, it will if I try to show them. sigh
00:39:00 <dons> > foldl (\b _ -> b + 1) 0 [undefined::()]
00:39:01 <lambdabot> 1
00:39:06 <dons> > foldl' (\b _ -> b + 1) 0 [undefined::()]
00:39:07 <lambdabot> 1
00:39:10 <dons> argh.
00:39:15 <osqulda> too fast now.
00:39:21 <osqulda> foldr is strict, right?
00:39:39 <osqulda> foldl is non-strict "in more cases" ?
00:39:50 * dons waves his hands
00:40:02 <dons> really, you worry more about if the fold is strict on the elements of the list
00:40:13 <dons> will it force them or not. foldl/foldr just fold from different ends
00:40:29 <dons> but the effect is similar to a strict list, in that you have to get the whole list before you can foldr it.
00:40:42 <osqulda> Instantiate foldl/foldr with a constant function for the first argument and [] for the second.
00:40:48 <dons> foldr is roughly similar to doing a length ls `seq` ...
00:41:20 <osqulda> it is forced
00:41:43 <osqulda> but if it is forced on an infinite list, it will not terminate
00:42:09 <osqulda> hmmm.
00:42:59 <dons> more interesting are:
00:43:00 <dons> > foldl' (\b _ -> b + 1) 0 [1..1000000]
00:43:01 <lambdabot> 1000000
00:43:03 <dons> > foldl (\b _ -> b + 1) 0 [1..1000000]
00:43:04 <lambdabot> Exception: stack overflow
00:44:13 <dons> > foldl (\b _ -> let x = b + 1 in x `seq` x) 0 [1..1000000]
00:44:14 <lambdabot> Exception: stack overflow
00:44:22 <vincenz> Why is this a problem
00:44:23 <vincenz>     Cycle in type synonym declarations:
00:44:23 <vincenz>       ./Parser.hs:27:0-44: type ParseStm = Stm ParseExp ParseStm
00:44:36 <dons> can't cycle in type synonyms
00:44:38 <dons> use a newtype
00:44:40 <vincenz> pfft
00:44:47 <vincenz> newtype require extra dataconst
00:45:09 * vincenz uses the concept of ... something something indirection
00:45:21 <vincenz> data Program decl = Program {[decl]}
00:45:37 <vincenz> data Declaration ident stm = Declaration {name :: ident, body :: [stm]}
00:45:41 <vincenz> indirect composite
00:45:42 <dons> newtype needs a constructor, yeah, but not a data constructor, really. its purely for the typechecker
00:46:35 <vincenz> it's annoying
00:46:43 <vincenz> so
00:46:59 <vincenz> newType ParseStm = ParseStm { unParseStm :: Stm ParseExp ParseStm}
00:46:59 <vincenz> ?
00:47:27 <dons> hmm, can you use record syntax in a newtype? I'm not sure.
00:47:37 <dons> I wonder if it's reasonable to do so.
00:48:07 <vincenz> why wouldn't it be?
00:48:15 <vincenz> otherwise you have to patternmatch
00:48:58 <kosmikus> osqulda: do you have an answer yet to your lhs2TeX question?
00:50:21 <vincenz> dons: ype works
00:50:31 <vincenz> dons: ever used indirect composite, and if not, hwo do you typically decorate ASTs
00:50:50 <dons> ah actually, i have record syntax newtypes in lambdabot. they're sometimes used when defining new monads
00:51:14 <dons> just for fun: newtype LB a = LB { runLB :: ReaderT (IORef (Maybe IRCRState),IORef IRCRWState) IO a }
00:51:27 <vincenz> @hoogle liftM
00:51:27 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
00:51:27 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
00:51:27 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
00:51:49 <osqulda> kosmikus, nope
00:53:07 <osqulda> dons, I think I got it now!
00:53:09 <osqulda> thanks!
00:54:39 <vincenz> @pl \a b -> return . ParseExp $ Not a b
00:54:39 <lambdabot> ((return . ParseExp) .) . Not
00:54:54 <vincenz> @pl return \a b -> ParseExp $ Not a b
00:54:54 <lambdabot> (line 1, column 8):
00:54:54 <lambdabot> unexpected "\\"
00:54:54 <lambdabot> expecting variable, "(", operator or end of input
00:54:58 <vincenz> @pl return $ \a b -> ParseExp $ Not a b
00:54:58 <lambdabot> return ((ParseExp .) . Not)
00:56:11 <kosmikus> osqulda: I can't see any simple way ...
00:58:24 <lisppaste2> kosmikus pasted "format arrow as dot in lhs2TeX" at http://paste.lisp.org/display/20034
00:58:40 <kosmikus> osqulda: ^^ this should work
00:59:47 <kosmikus> osqulda: note however, that this will cause an error if the \ and -> do not appear in the same alignment context
01:02:30 <osqulda> kosmikus, is it not possible to change \? -> ?? into \lambda ?.?? using a macro?
01:02:42 <osqulda> oops wait
01:02:55 <osqulda> this is what you did, good! ;-) thanks
01:04:47 <osqulda> kosmikus, can def actually pattern match? 
01:06:37 <kosmikus> not in the Haskell sense of the word (you cannot make a decision based on a pattern), but in a limited form, yes
01:07:02 <osqulda> interesting,
01:07:04 <osqulda> thanks.
01:07:29 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles -- would anyone like to try a new puzzle of mine?
01:08:55 * vincenz peers at Cale 
01:09:27 <kosmikus> er, I don't understand the explanation
01:09:55 <kosmikus> Cale: that small circle in the "map", is that just another region?
01:09:59 <Cale> yes
01:10:32 <kosmikus> ok
01:10:43 <kosmikus> would be nice if one could edit the puzzle online
01:11:33 <vincenz> Cale: is the information of the circles required to solve it?
01:11:43 <Cale> yep
01:12:00 <Cale> all of the rules are required, as far as I can tell
01:12:03 <vincenz> Cale: is there some sort of format?
01:12:21 <Cale> hm?
01:12:30 <kosmikus> the border of the board does delimit a region even if there are no walls?
01:12:36 <Cale> no
01:12:48 <Cale> cells can be "outside"
01:12:48 <vincenz> Cale: do you know of any typical format to denote the concept that those circles denote
01:13:02 <kosmikus> hm, ok
01:14:25 <Cale> vincenz: I'm not sure
01:16:17 <Cale> I suppose you could say that the walls in the grid are homeomorphic to the "map".
01:16:36 <Cale> (as topological spaces)
01:16:43 <shapr> Cale: looks like minesweeper.
01:16:59 <Cale> It looks even more like slither link :)
01:17:21 <shapr> speaking of which, have you seen http://www.maa.org/editorial/mathgames/mathgames_12_13_04.html ?
01:17:31 <tic> *yawn*
01:17:33 <shapr> and http://swiss.csail.mit.edu/~bob/sliding-blocks.pdf ?
01:18:42 <kosmikus> Cale: an empty entry in a cell indicates "unknown" rather than "0", yes?
01:18:48 <Cale> right
01:19:08 <kosmikus> so there's probably no unique solution
01:19:09 <shapr> Cale: I've been playing with Amazon's Mechanical Turk lately, seems to me that there must be a better way to leverage humans innate advantages over computers by turning computer-difficult problems into puzzles like this.
01:21:04 <Cale> hmm
01:21:37 <Cale> kosmikus: hm?
01:22:00 <Cale> kosmikus: I checked that the solution is unique -- if you can find two, let me know, because it means I made a mistake :)
01:22:32 <kosmikus> well, you can at least add single walls that are connected to an already existing region wall, but don't lead anywhere ... (if you understand what I mean)
01:23:09 <kosmikus> but I'll first solve it and then complain
01:23:11 <Cale> oh, oops
01:23:15 <Cale> Every wall is part of the boundary of some region.
01:23:33 <dcoutts> ADEpt, pong
01:23:36 <Cale> I should have included that
01:23:56 <dcoutts> dons, ping
01:23:57 <kosmikus> Cale: I was going using your "homeomorphic" definition
01:24:04 <dcoutts> shapr, pong
01:24:40 <dcoutts> juhp, yay!
01:24:55 <Cale> hmm, then you should have come to the same conclusion. I don't mean homotopic.
01:26:24 <Cale> you can't add a wall sticking off randomly because the endpoint of the wall would have a neighbourhood that didn't look like anything in the map.
01:27:12 <Cale> it'd look like [0,infinity)
01:27:30 <kosmikus> Cale: oh sorry, I misread. I thought you said the *regions* should be homemorphic, but you said the *walls* should be ...
01:27:42 <Cale> yeah
01:28:38 <Lokadin> say, if i have a pid handle, how do i check if the process is still running, 
01:34:31 <Cale> Lokadin: you could run getProcessExitCode processHandle, which would give you Nothing if the process is still running, and Just e if not
01:36:30 <Cale> "Subsequent calls to getProcessExitStatus always return Just ExitSuccess, regardless of what the original exit code was."
01:36:43 <Cale> I wonder why that is.
01:37:20 <Lokadin> Cale: thanks :)
01:37:42 <Lokadin> oh really?
01:37:46 <Lokadin> even if it was an error?
01:38:15 <Cale> yeah
01:38:30 <Cale> it'll only give you the error the first time
01:38:36 <Lokadin> oh okay
01:38:38 <Lokadin> cool
01:38:42 <Lokadin> :) thanks
01:40:43 <shapr> dcoutts: yow!
01:40:57 <dcoutts> shapr, you rang I believe.
01:41:04 <dcoutts> shapr, Language.C ?
01:41:12 <shapr> And GtkDarcs, yes
01:51:34 * shapr boings
01:53:49 <shapr> cute - http://www.mutantlemon.com/omegagb/devlog/
01:54:06 <juhp> dcoutts: :-)
01:54:50 <dcoutts> juhp, so is that it? we're in?
01:54:59 <juhp> dcoutts: yep :-)
01:55:10 <dcoutts> juhp, do we do anything special for updates / new versions ?
01:55:15 <juhp> dcoutts: packages should be available for fc4 and fc5 shortly
01:55:39 <juhp> dcoutts: just build them :)
01:55:44 <dcoutts> juhp, cool, I'll update the gtk2hs download page
01:56:11 <juhp> dcoutts: ok, shortly may mean a few days :)
01:56:30 <dcoutts> juhp, will there be a particular url? I should just say that they're in "Fedora Extras" ?
01:56:48 <dcoutts> ok ping me when you think I should update the page
01:57:12 <juhp> dcoutts: yeah, just saying they're in Fedora Extras should be fine: you could mention something like "yum install ghc-gtk2hs"
01:57:31 <juhp> dcoutts: sure
01:58:15 <dcoutts> juhp, so ghc-gtk2hs pulls in all the other packages or just the core ones?
01:58:26 <dcoutts> how did you split it in the end?
01:58:47 <juhp> dcoutts: ghc-gtk2hs should pull in ghc642-gtk2hs
01:59:15 <juhp> dcoutts: in the end gemi thought I over-subpackaged, so currently only mozembed is split out
01:59:16 <dcoutts> juhp, we've talked before how it'd be nice to split gtk2hs into individual Cabal packages in future
01:59:22 <dcoutts> right, ok
01:59:23 <juhp> yeah
01:59:45 <dcoutts> so when it splits upstream you can revisit that issue
02:00:07 <juhp> dcoutts: probably most users will find it easier to just install a single package, than half a dozen
02:00:12 <juhp> dcoutts: sure :)
02:00:25 <juhp> (currently at least)
02:00:31 <dcoutts> juhp, that's true
02:00:53 <juhp> dcoutts: ah so you're thinking of splitting up the tarball
02:00:54 <juhp> ?
02:01:28 <dcoutts> juhp, not sure. but I'd like to have several Cabal packages
02:01:33 <juhp> dcoutts: I had mixed feelings about undoing the subpackaging.... it seems elegant to have one per ghc package and -devel dep
02:01:35 <dcoutts> perhaps in one tarball, perhaps seperate
02:01:40 <juhp> okay
02:01:51 <dcoutts> which would you prefer?
02:02:05 <juhp> probably one tarball would be sufficient, I suspect :)
02:02:25 <dcoutts> but for say hackage, it'd want to be individual tarballs
02:02:36 <juhp> ah, I see
02:02:46 <dcoutts> of course for people downloading & installing manually then a single tarball is obviously preferable
02:03:10 <juhp> dcoutts: well for packaging it doesn't matter so much I think
02:03:18 <basvandijk> Hi, I have a quick question: I would like to pretty print the AST that comes out Language.Haskell.Parser. However I don't like the default string that comes out of show. Is there a standard function that pretty prints a value with nice indentation?
02:03:19 <juhp> yea
02:03:32 <dcoutts> to be able to make best use of deps etc we really need gtk2hs to be split into its components
02:03:46 <norpan> häpp
02:04:01 <dcoutts> quite appart from people wanting to be able to use cairo without gtk
02:05:39 <dcoutts> basvandijk, you're using Language.Haskell.Pretty ?
02:06:25 <ADEpt> ping
02:07:11 <dcoutts> ADEpt, who's that to? :-)
02:07:23 <basvandijk> dcoutts_: No, I don't want to transform the AST to a Haskell String... I would like to pretty print the AST... So that I see all the constructors in a hierarchy
02:07:37 <ADEpt> dcoutts, apparently, for my irc gateway :)
02:07:40 <dcoutts> basvandijk, ah, can't help there.
02:07:57 <ADEpt> dcoutts: but since you are here... have you seen the latest mail to haskell-soc m.l.?
02:08:07 <dcoutts> ADEpt, let me check...
02:09:59 <dcoutts> ADEpt, yes I've seen. No probs.
02:11:16 <Lemmih> basvandijk: Isn't that the same thing?
02:11:47 <Lemmih> Oh, now I get it.
02:11:48 <ADEpt> dcoutts: cool
02:12:42 <basvandijk> Lemmih: No, I don't want to see the Haskell code, I would like to see the actual AST. But the default show instanc 
02:12:46 <dons> dcoutts: pong
02:12:51 <basvandijk> is not very nice
02:14:18 <dcoutts> dons, hia, I saw you turned down the chunk size. that's better I think.
02:14:44 <dcoutts> dons, I was also hoping I could enlist you to help me persuade Manuel to mentor a Language.C SoC project
02:15:00 <dons> ok. I think almost certainly he'd be ok with it.
02:15:09 <dcoutts> I think he'd be a better mentor
02:15:32 <dons> ok. just mail him, CC me. He's in NYC, so I can't actually speak to him about it.
02:15:35 <dcoutts> you'd just need to explain the system to him and show him where to sign up
02:15:35 <dons> ChilliX: ping?
02:15:39 <dons> yep.
02:15:41 <Lemmih> basvandijk: You can parsed the result of show.
02:15:56 <dcoutts> dons, yes, I've mailed him and cc'ed you already. :-)
02:16:02 <dons> ok.
02:16:11 <vincenz> so re
02:16:14 <dcoutts> dons, what was wrong with group/by
02:16:17 <vincenz> dons: have you ever used indirect composite?
02:16:21 <Lemmih> basvandijk: let ParseOk mod = parseModule {your module}; ParseOk mod' = parseModule ("x = " ++ show mod) in prettyPrint mod'
02:16:21 <basvandijk> Lemmih: Ok, you mean parsing the string... and applying my own formatting?
02:16:38 <dons> dcoutts: it broke when I reduced the chunk size to 1 byte
02:16:48 <dons> nothing else did though. so needs investigation
02:16:53 <dcoutts> dons, ah ok, hmm.
02:17:16 <ADEpt> dcoutts: for me, it brokes with chunks of 6 bytes as well.
02:17:19 <norpan> anything new on the lazy bytestring front?
02:17:47 <dcoutts> dons, so I missed a few places where the invariant need re-establishing, hence adding the pesky filter (not.null) in various places
02:17:50 <vincenz> ..
02:18:16 <azuroth> they're made out of meat
02:18:22 <Lemmih> basvandijk: Mind if I PM you?
02:18:36 <basvandijk> Lemmih: go ahead
02:18:39 <dons> dcoutts: yep. sure. fusing them makes a big difference :)
02:19:02 <dcoutts> dons, do you think it's better to have them mostly as explicit recursions or as instances of fold etc?
02:19:23 <dons> hmm. have what as ?
02:20:30 <dcoutts> well many of the .Lazy functions are like: foo = fold (\_ -> P.foo ...)
02:20:58 <dcoutts> dons, but the rest are written out as explicit recursion on a worker function
02:21:06 <dcoutts> is it right that we'll only get automagic fusion when we explicitly use folds etc?
02:21:38 <dons> well, i'm not sure we get automagic fusion all the time anyway
02:21:41 <dons> i haven't tested it.
02:21:57 <dons> but only if you use P.fold, P.filter or P.map will you be able to fuse an array 
02:22:18 <dons> then there's loop fusion, you'll only get that without using recursion, right.
02:22:23 <dons> s/list fusion/
02:22:24 <dcoutts> It'd be nice to be able to use as many fold-like combinators as possible rather than explicit recursion
02:22:43 <dons> yep
02:22:49 <dons> but you have to be careful with performance
02:23:03 <dons> (note then new 'make plot' target, for checking this visually)
02:23:19 <dcoutts> I was hoping we'd get some common patterns and then be able to convert to using them
02:23:23 <dcoutts> right, ok.
02:23:46 <dons> well, filterMap was one. but there's not a lot of them.
02:23:50 <norpan> if you ask me, use fold if you can
02:23:58 <dcoutts> dons, did you try that logfile analysis example?
02:23:58 <norpan> much easier to read
02:24:23 <dons> dcoutts: well, I wrote one example, and it was fvery fast. but they seem to ignore my contributions to taht thread :}
02:24:31 <dcoutts> dons, finding the repeated lines in a log file
02:24:48 <dons> its really a problem for byte strings, so i don't know why they just don't do that.
02:25:01 * dons shrugs
02:25:17 <dcoutts> dons, but you didn't write the whole prog right? it did some other thing for each line
02:25:17 <dons> you write the code, its up to the users to actually use it after that.
02:25:25 <vincenz> dons: have you ever used indirect composite?
02:25:31 <dons> vincenz: no.
02:25:38 <vincenz> ok
02:25:42 <dons> dcoutts: right.
02:25:57 <dons> just the bare structure, to illustrate it wasn't terribly difficult to convert to byte strings
02:30:35 <vincenz> indirect composite rocks :)
02:30:51 <norpan> dons, dcoutts: i'm looking at your pack code
02:31:32 <norpan> it would seem like a performance hit to traverse the string twice (you get an intermediate string from chunk)
02:31:56 <norpan> but maybe it's not so bad
02:34:39 <dcoutts> norpan, hmm, yes because pack needs the string length
02:34:50 <norpan> yes
02:35:09 <dcoutts> norpan, dons, you're probably right that we could do better there.
02:35:28 <norpan> i was just looking at it to see if you divide it in chunks
02:36:05 <norpan> and it seems you do, but i suppose QC doesn't generate 64k strings :)
02:36:29 <dcoutts> aye
02:36:43 <dcoutts> but the QC arbitrary instance generates fragmented strings
02:36:55 <dcoutts> even though pack doesn't
02:37:59 <norpan> of course
02:48:23 <vincenz> Anyone know in which way HM for ML and haskell differ (in a non-too-expert explanation)
02:51:13 <azuroth> HM?
02:51:22 <vincenz> hindley milner
02:51:39 <Cale> typeclasses, for one :)
02:52:04 <vincenz> Cale: correct...but that's typeclasses vs module system no?
02:52:11 <vincenz> what is the fundamental difference?
02:52:28 <vincenz> algorithmically speaking
02:52:29 <Cale> well, I actually don't know ML's type system that well
02:52:51 <norpan> i would say there is no fundamental difference :)
02:52:56 <vincenz> norpan: I read differently
02:53:16 <vincenz> there is a fundamental difference in approach
02:53:18 <vincenz> I remember raeding that somewhere
02:53:22 <vincenz> oh well
02:53:24 <vincenz> lunchtime
02:53:44 <dons> they like functors more than we do. and the syntax is wacky ;)
02:54:03 <azuroth> http://en.wikipedia.org/wiki/Hindley-Milner_type_inference : it says "length (x:xs) = 1 + length xs" is obviously [a] -> Int... but might it actually be (Num i) => [a] -> i ..?
02:54:05 <norpan> depends on what you mean by fundamental
02:54:42 <Cale> azuroth: exactly :)
02:54:42 <azuroth> I should probably read the whole thing before asking questions...
02:54:59 <Cale> azuroth: in fact, you're making a good point in this discussion :)
02:55:21 <norpan> well, it all depends if 0 has type Int or if it has type (Num a) => a
02:55:47 <azuroth> hum, okay
02:56:19 <norpan> but the type inference works the same for both
02:56:58 <norpan> well, type classes is a small extension to the algorithm of course
02:59:34 <azuroth> does haskell have any way of overloading a func, I wonder?
02:59:41 <azuroth> errr! s/haskell/ML/
03:01:51 <azuroth> I think c++0x is going to have some form of type inference, too. which will be awesome for the STL
03:02:53 <ADEpt> azuroth: what's this?
03:02:59 <ADEpt> azuroth: new C++?
03:03:33 <azuroth> yeah, the next standard. should be finalised sometime this decade, according to the name
03:04:22 <azuroth> it'll also have like, vector<int> v = {0,1,2,3,4}; doing the right thing. :-)
03:14:40 <azuroth> sorry for bringing down the mood, I didn't realise C++ was such a sedative :-(
03:14:44 <wilx> I wonder how are the internals of the vector going to look like to accept this declaration.
03:14:51 <wilx> Heh.
03:17:00 <azuroth> apparently some specific sort of constructor: a sequence ctor
03:19:12 <Lokadin> say just a quick question, i was wondering if anyone knew wether or not you could make yi into almost a screen type thing, running a shell in another tabbed window say
03:19:27 <Lokadin> or er split screen
03:20:26 <Lokadin> hmmm i guess i can just email dons and ask him
03:24:10 <Lokadin> kk well i'm going to sleep so cya guys, i emailed dons *crossse fingers* hopefully got through the spam filters and he'll reply lol
04:11:14 <vincenz> azuroth: I checked
04:11:19 <vincenz> azuroth: it's not type inference
04:11:28 <vincenz> azuroth: only some very minor stuff for auto stuff for iterators
04:12:00 <vincenz> auto iterator x = myvec.begin()
04:12:02 <azuroth> oh, that isn't type inference?
04:12:11 <vincenz> a degenerate case at best
04:12:20 <vincenz> there's no unification
04:12:32 <vincenz> auto iterator = myvec.type::iterator
04:12:43 <azuroth> unification?
04:12:55 <vincenz> @google type inference
04:12:57 <lambdabot> http://en.wikipedia.org/wiki/Type_inference
04:19:19 <azuroth> it's not like we're writing banking software or anything, but
04:19:56 <azuroth> we should be using some sort of base ten float or fixed point, right?
04:20:05 <vincenz> is there any simple way of doing dupchecking?
04:20:12 <azuroth> nub?
04:20:18 <vincenz> > nub [1,2,1]
04:20:19 <lambdabot> [1,2]
04:20:25 <vincenz> hmm
04:20:42 <vincenz> > nub ([1..4] ++ [1..3] ++ [1..2]) == [1..4]
04:20:43 <lambdabot> True
04:20:51 <vincenz> > nub [2,1]
04:20:52 <lambdabot> [2,1]
04:20:57 <vincenz> thanks
04:20:58 <azuroth> (err, for prices I mean)
04:21:09 <azuroth> :-)
04:21:13 <vincenz> tho... I was hoping for something that would return on first duplicate
04:21:32 <vincenz> it's easy to check dups or not, but not to note which one is duped
04:21:39 <vincenz> s/duped/dupped/
04:21:57 <azuroth> hmm what do you want to do when you find the dup?
04:22:09 <vincenz> get back what is dupped for an error message
04:22:24 <azuroth> ?hoogle nubBy
04:22:24 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
04:22:40 <azuroth> ?hoogle (Eq a) => [a]
04:22:41 <lambdabot> List.nub :: Eq a => [a] -> [a]
04:22:41 <lambdabot> Prelude.repeat :: a -> [a]
04:22:41 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
04:22:46 <vincenz> nope
04:22:50 <vincenz> ideally somethng like
04:22:53 <vincenz> [a] -> Maybe a
04:23:08 <vincenz> Nothing = no duplicates, Just x => x = firs tduplicated ting
04:23:13 <vincenz> but I'll write something from scartch
04:23:19 <vincenz> and my typing is going to hell
04:23:20 * vincenz mutters
04:24:05 <azuroth> tell me what you come up with :-)
04:24:23 <vincenz>   -- generateVars for all toplevel functions
04:24:23 <vincenz>   -- unify
04:24:23 <vincenz>   -- check no generic vars left
04:24:25 <vincenz> whoops
04:24:31 <vincenz> checkDup (x:xs) = if x `elem` xs then Just x else checkDup xs
04:24:31 <vincenz> checkDup [] = Nothing
04:25:58 <Saulzar> Maybe a Set is a better structure, or at least you could implement it with a set easily.
04:26:13 <vincenz> Saulzar: nah
04:26:15 <vincenz> it's more painfu
04:26:25 <vincenz> see I'm parsing func-defs
04:26:31 <vincenz> I want to post-parse check I don't have duplicate defs
04:26:41 <Saulzar> Hmm..
04:27:01 <vincenz>   ruleInstances <- many . offside $ definitionP
04:27:01 <vincenz>   eof
04:27:20 <Saulzar> Hehe, I think I have some ungodly inefficient function I made for that somewhere for a 10 second job :)
04:27:50 <vincenz> ??
04:27:51 <lambdabot> Maybe you meant: . v
04:28:08 <vincenz> I know I know
04:28:12 <vincenz> it's O(n^2)
04:28:15 <vincenz> but it's simple
04:28:22 <Saulzar> I think I did worse, using nub more than once
04:28:31 <vincenz> well to be fair
04:28:35 <vincenz> n^2/2
04:28:45 <vincenz> (triangle structure)
04:29:37 <Saulzar> Still n^2 :)
04:29:46 <Saulzar> How inefficient is this? let dups = nub (foldr delete ids (nub ids))
04:30:27 <vincenz> not familiar with nub
04:30:36 <vincenz> tho I take it that nub on it's own is already O(n^2)
04:30:38 <vincenz> unless it uses a et
04:30:38 <Saulzar> If nub is n log n (if it used a set)
04:30:39 <vincenz> set
04:30:42 <vincenz> in which case it's nlogn
04:30:44 <vincenz> right
04:30:45 <Saulzar> I bet it's good. At least n^2 (n log n) ^2
04:30:57 <vincenz> :D
04:34:11 <vincenz> @pl \x -> (a x, b x)
04:34:11 <lambdabot> liftM2 (,) a b
04:37:08 <dcoutts> @type nub
04:37:09 <lambdabot> forall a. (Eq a) => [a] -> [a]
04:37:26 <dcoutts> so it must be O(n^2) since it's not using a Set
04:37:44 <Saulzar> Ah, since that would require Ord
04:37:54 <dcoutts> exactly
04:38:08 <vincenz> ouch
04:38:10 <vincenz> stupid question
04:38:14 <Saulzar> Well my horrible example would be summed not a product, but still not good.
04:38:26 <vincenz> compile: text -> lex -> parse -> type check -> ??? -> output
04:38:30 <vincenz> what's that step called
04:38:32 <vincenz> compile as well?
04:38:43 <vincenz> trying to think of a good name for a function
04:38:45 <Saulzar> code gen?
04:38:48 <vincenz> as the whole thing is already called compile
04:38:54 <vincenz> blegh I guess
04:39:03 <vincenz> except I generate one monadic cation to be used later
04:39:22 <vincenz> s/cation/action
04:39:24 * vincenz sighs
04:39:33 <norpan> codegengen? :)
04:41:08 <vincenz> grr
04:41:10 <dcoutts> norpan, no, that'd be a partial evaluator, a code generator generator
04:41:10 <vincenz> it doesn't like where
04:41:40 <vincenz> http://rafb.net/paste/results/Gv3RxE84.html
04:41:42 <vincenz> complains on line 3
04:41:45 <vincenz> on the 'where'
04:42:19 <dcoutts> that's because you've got 2 opening brackets and only one colsing on
04:42:26 <vincenz> I do?
04:42:33 <dcoutts> colsing on/closing one
04:42:43 <dcoutts> map (\x -> (declName x, declIterator x) ...
04:42:53 <vincenz> ah yeah
04:55:15 <vincenz> is it possible to fmap over a Map?
04:55:50 <vincenz> > M.toList. fmap (join (,)) . M.fromList [(1,"a"), (2,"b")]
04:55:50 <lambdabot> Couldn't match `Data.Map.Map k a' against `t -> t1'
04:56:06 <vincenz> yup
05:00:02 <vincenz> dum dum
05:00:04 <norpan> vincenz: Map is an instance of Functor so it should be possible
05:00:07 <vincenz> time for unification
05:00:47 <azuroth> that's right, I was supposed to read that link! *reads*
05:00:56 <vincenz> what link?/
05:01:41 <azuroth> the wiki article on type inference
05:02:46 <azuroth> I don't think I understand what to call what C++0x does though
05:02:55 <vincenz> azuroth: a lame attempt at inference?
05:03:03 <norpan> ad hoc inference :)
05:03:06 <vincenz> it's nothing really grand
05:03:12 <vincenz> I mean it's a purely casual chain
05:03:25 <vincenz> you know the type of the container -> you know the type of the iterator
05:03:31 <vincenz> no type variables that have to be unified later
05:04:43 <pejo> Considering that the error messages for type errors are pretty bad in our functional compilers maybe thats a sane choice for a mainstream language. 
05:05:04 <vincenz> pejo: LOL
05:05:10 <vincenz> pejo: I guess you've never done complex template programming
05:05:26 * vincenz has had PAGES and PAGES and PAGES of gcc errors scroll by his screen for a simple mistake in one of his templates
05:05:37 <pejo> vincenz, obviously the C++-compilerfolks didn't get the template error messages right either. Do they really need another hard problem to solve?
05:05:43 <vincenz> with disgustingly ugly symbolnames
05:05:52 <Saulzar> Heck, you get nearly 5 pages for just mis-using vector.
05:06:06 * vincenz also made gcc 3.3 crash 
05:06:08 <vincenz> :D
05:06:15 <vincenz> 3.4 compiles my piece of code correctly
05:06:21 <Saulzar> Segfault and not ICE? :)
05:06:21 <pejo> Everything crashes, it's the way software works as of today. Including twm.
05:06:28 <vincenz> Saulzar: can't remember
05:06:33 <vincenz> hmm
05:06:40 <vincenz> Saulzar: I think so yeah
05:06:46 <vincenz> but I lost it :/
05:06:48 <Saulzar> I have gotten plenty of ICE's
05:07:08 <azuroth> intrusion countermeasure electronics?
05:07:17 <vincenz> internal compiler error
05:07:24 <azuroth> ahh
05:08:02 <vincenz> another thing that bugs me is this:
05:08:31 <vincenz> http://rafb.net/paste/results/sRKhmY46.html
05:08:44 <vincenz> the need for that ugly static_cast
05:09:18 <vincenz> just cause it can't read through a type operator, then [] operator, then another type operator
05:10:33 <vincenz> or the fact that ?: . and .* are not overloadable
05:10:55 <azuroth> why do you want to overload ?: ?
05:11:16 <vincenz> azuroth: functor generation?
05:11:51 <vincenz> as for . and .*, for a completely transparent wrapper
05:12:04 <azuroth> functor gen, how?
05:12:07 * vincenz has a wrapper he's gonna present at ICME
05:12:11 <vincenz> but ssadly it can't wrap structs
05:12:14 <vincenz> due to the problem with . and .*
05:12:20 <vincenz> azuroth: boost lambda?
05:12:49 <azuroth> no but, what would it look like?
05:13:16 <vincenz> Functor exp1 = SomeExp(..);
05:13:21 <vincenz> Functor exp2 = SomeExp(..);
05:13:28 <vincenz> Functor exp3 = SomeExp(..);
05:13:41 <vincenz> Functor cond = exp1 ? exp2 : exp3;
05:13:48 <vincenz> cout << cond(lol);
05:14:11 <azuroth> ohhh, well that's awesome
05:14:29 <vincenz> anyways
05:14:32 <vincenz> concerning type inference
05:14:36 <vincenz> does this lok like a good approach
05:14:42 <vincenz>   -- generateVars for all toplevel functions
05:14:42 <vincenz>   -- unify
05:14:42 <vincenz>   -- check no generic vars left
05:14:42 <vincenz>   -- generateVars for all toplevel functions
05:14:42 <vincenz>   -- unify
05:14:45 <vincenz>   -- check no generic vars left
05:14:47 * vincenz coughs
05:14:50 <vincenz> sorry for dual paste
05:17:38 <vincenz> Saulzar: thoughts?
05:17:47 <vincenz> gotta love haskell tho
05:18:18 <vincenz> I first wrote the toplevel structured, typed the different phases and made them undefined, then made the first step, compiled, ran and tested with an input that would make that step fail, and tada I get a nice failure error ;)
05:18:20 <Saulzar> I don't know much about type inference.
05:18:51 <xerox> @yow!
05:18:52 <lambdabot> Where's the Coke machine?  Tell me a joke!!
05:20:15 <vincenz> azuroth: I actually have my own functor library, however without the operator overloading, so construction of functors is a bit more explicit
05:20:24 <vincenz> but I do have a way to curry functions :)
05:20:45 <Saulzar> Though it would be nice to know something about...
05:20:54 <Saulzar> What is that template code used for?
05:21:13 <azuroth> finding weirdness in the C++ spec? ;-p
05:21:15 <vincenz> oh... well at first I thought I would need functors for some transformational reasons 
05:21:22 <vincenz> but in the end it wasn't that usefufl
05:21:24 <vincenz> however
05:21:30 <vincenz> p(f)(c)(3)(4)(&Simple::get)(5)
05:21:35 <vincenz> f is a factory
05:21:46 <vincenz> c is something extraneous
05:21:50 <vincenz> 3 and 4 are the constructor arguments
05:21:52 <vincenz> then the method
05:21:54 <vincenz> then the method args
05:21:59 <vincenz> (only one in this case, but it could be curried)
05:22:09 <vincenz> :D
05:22:27 <vincenz> http://rafb.net/paste/results/WQufpz47.html
05:23:26 <Saulzar> !
05:23:49 <vincenz> I love the Chainer<Saver, Maker>
05:23:52 <vincenz> one allocates
05:24:00 <vincenz> the other ensures that it's put in a smart pointer
05:24:09 <vincenz> My creator knows that it has to alloc for T*
05:24:29 <vincenz> like it?
05:25:01 <Lemmih> Hiya Oeje1.
05:25:14 <vincenz> Hello Oeje1 and Lemmih :)
05:25:22 <Oeje1> Hello, Lemmih and vincenz.
05:26:31 <vincenz> Saulzar: I never got around to a decurrier tho
05:26:35 <vincenz> except that would be even cooler
05:26:48 <vincenz> p(f, c, 3, 4, &Simple::get, 5)
05:27:15 <Saulzar> Nice. Haven't looked at templates for a while, thankfully :)
05:28:14 * Saulzar was beginning to wonder why all the brackets. Before realising that ( ) is required for function application.
05:28:35 <vincenz> those are just typedefs
05:29:49 <pejo> vincenz, Chapter 9 of one  of the books SPJ wrote contains a good overview of a simple type checker with unification, written in Miranda. 
05:30:14 <vincenz> pejo: thanks
05:30:17 <pejo> vincenz, (I can make the pdf avail if you want it, I get 30 kb/s when downloading from SPJ:s homepage).
05:30:21 <vincenz> sure
05:30:24 <vincenz> that would be great
05:30:31 <vincenz> or I'll look at SPJ's page
05:30:32 <vincenz> got a lin?
05:31:02 <pejo> It's a 40Mb pdf, not for the faint of heart. :-) http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
05:31:33 <vincenz> oh yay...
05:31:37 <vincenz> our proxy virus checker
05:31:39 <vincenz> that even checks pdfs
05:31:41 * vincenz mutters
05:32:44 <pejo> Heh, have a coffee in hte meantime, it'll take quite a while to download that if you get the same phenomenon with the download speed as I do. (Pending between 20 and 200 kb/s).
05:32:55 <vincenz> the slowness is not due to download
05:32:59 <vincenz> but our fricking proxy
05:33:15 <vincenz> whenever we download something, it's viruschecked at the proxy
05:33:18 <vincenz> even pdfs
05:33:39 <vincenz> so we get a refreshing webpage "Please wait...blabla...x seconds elapsed... x Kb/ y kb"
05:33:47 <azuroth> ugh
05:33:50 <vincenz> Progress:  	9254 KB/30632 KB
05:33:50 <vincenz> Time elapsed: 	144
05:34:06 <vincenz> grr
05:34:12 <azuroth> surely it's just on the lan though? :-p
05:34:13 <vincenz> now I remember why I no longer frequence ##C++
05:35:56 <vincenz> people in ##C++ are incredibly aggressive
05:36:04 <vincenz> especially a guy named 'pwned'
05:36:42 <vincenz> time for coffee, this virus scanner is seriously slow
05:36:50 <Saulzar> Yep, it's great around here. Game in C++ chans is fun with ops usually.
05:36:56 <azuroth> hmm. should get an IRC bot to bridge between ##C++ and ##java
05:37:18 <davidhouse> hehe
05:37:22 <Saulzar> To create flamewars?
05:38:13 <azuroth> aggressive C++ites + agressive javalets. I think it could be fun
05:38:54 <davidhouse> what's a first class value?
05:39:20 <xerox> davidhouse: a value you can pass and return from functions
05:39:30 <davidhouse> hmm
05:39:37 <davidhouse> so what's an example of a value that isn't first class?
05:39:56 <xerox> Types?
05:40:01 <davidhouse> ah,
05:40:07 <xerox> Classes...
05:40:12 <xerox> Modules...
05:40:14 <davidhouse> so "value" not meaning "data value".
05:40:22 <xerox> data value = first class value :-)
05:40:27 <davidhouse> yes.
05:41:21 <xerox> Examples of first class values of different types are: numeric literals, functions, data constructors, ...
05:43:51 <norpan> people in #haskell are super-nice
05:43:53 <norpan> i love you all
05:43:58 <azuroth> relax, don't do it! when you wanna go do it!
05:44:08 <azuroth> they even don't mind my singing :-)
05:44:21 <norpan> in fact, we like it
05:47:32 * xerox hugs norpan 
05:47:46 <azuroth> both perl6 and haskell communities seem pretty good, actually. I don't think I've ever met any regulars who are at all mean :s
05:47:54 <norpan> oh
05:47:58 <davidhouse> they're not that nice. xerox stabbed me yesterday.
05:48:10 <xerox> davidhouse, that's part of the learning process!
05:48:11 <azuroth> s/mean/mean to me/
05:48:19 <norpan> i can be mean to people who just wants someone to do their homework
05:48:43 <davidhouse> xerox, ah, that's okay then. :)
05:48:53 * xerox gives davidhouse a lambda-cookie
05:48:57 <vincenz> azuroth: oy...it's a set f images, not a pdf
05:49:00 <davidhouse> :)
05:49:07 <azuroth> don't azuroth me!
05:49:18 <vincenz> Saulzar: and yeah... ##C++ == flame war central / OT central
05:49:29 <vincenz> and they typically can only flame you with ISO references
05:49:36 <vincenz> but ask em anything and they won't be able to help
05:49:42 <vincenz> there's a reason I stopped frequenting there
05:49:45 * davidhouse is reading an interesting paper about implementing UIs with arrows.
05:49:51 <vincenz> davidhouse: frantk?
05:49:53 <davidhouse> but my eyes just glazed over because it mentioned the Y combinator
05:50:04 <xerox> davidhouse: yampa?
05:50:06 <vincenz> davidhouse: Y combinator = fix
05:50:11 <vincenz> xerox: oh, right, yampa
05:50:18 <davidhouse> vincenz: yes, precisely why my eyes glazed over.
05:50:32 <xerox> !
05:50:58 <davidhouse> xerox, err, it's "Genuinely Functional User Interfaces" by Courtney and Elliott
05:51:20 <norpan> fruit
05:51:23 <davidhouse> yes.
05:51:27 <vincenz> norpan: fruit yourself!!!
05:51:37 * vincenz sends norpan to the nuthouse along with some bananas
05:51:49 <norpan> fruit flies like a banana
05:51:55 <vincenz> :D
05:52:09 <norpan> and there is the connection to arrows
05:52:13 <norpan> it all makes sense
05:52:23 <vincenz> all we need now is a barbed wire to catch it all
05:52:31 <jip> yampa is awesome
05:52:49 * vincenz tried it but was stumbled
05:53:50 <vincenz> does anyoone know why DJVU is so much smaller typically?
05:54:26 <norpan> i remember something called fudgets
05:54:31 <norpan> they were arrow-like
05:55:14 <vincenz> most functional things are arrow like
05:55:22 <vincenz> instance Arrow (->)
05:55:46 <norpan> i remember back in 1994 or something, we made a spread sheet where each cell was a fudget
05:55:47 <azuroth> hum. I should sleep soon.
05:56:09 <norpan> err, not 1994
05:56:10 <vincenz> @localtime azuroth 
05:56:11 <norpan> 1998
05:56:17 <norpan> i'm not that old
05:56:33 <azuroth> it's only 11, but I was half-asleep all day today
05:56:48 <vincenz> azuroth: which chapter?
05:57:07 <azuroth> the pm one?
05:57:22 <azuroth> vincenz: what?
05:57:51 <vincenz> the thing in SPJ's book
05:58:25 <vincenz> whoops, pejo 
05:58:26 <azuroth> oh,... I don't know :-p pejo linked it?
05:58:56 <pejo> vincenz, Chapter 9
05:59:54 <vincenz> thx
06:05:03 <azuroth> night all
06:05:24 <vincenz> cya azuroth 
06:05:40 <Lemmih> JaffaCake: Do you know why SimonPJ never IRC's?
06:06:04 <JaffaCake> Lemmih: he's too busy most of the time, I guess
06:08:09 <pejo> JaffaCake, got a few minutes to answer some questions about your knot tier? :-)
06:08:31 <JaffaCake> pejo: maybe, if I can remember how it works
06:10:07 <pejo> JaffaCake, figure 5.8 (pp 118) in your thesis contains some pseudo code for it. 
06:10:26 * JaffaCake pulls thesis off shelf, blows off dust
06:11:18 <pejo> JaffaCake, if f \in used then (...) - you add a new definition for f according to my interpretation. IS the last component supposed to be <f = ...>:defs instead of just <f = ...>?
06:13:46 <JaffaCake> pejo: looks like it
06:14:30 <pejo> JaffaCake, and for the else case, do you need the middle component to be f:used instead of just used?
06:18:55 <davidhouse> anyone happen to know if --ignore-all-exports is implemented in haddock? i seem to be getting unrecognised option errors when using it
06:19:58 <JaffaCake> pejo: I don't know right now, I tried to page this back in but got /dev/brain: device full
06:20:21 <JaffaCake> if you like, I can try to look later, drop me an email
06:20:44 <pejo> JaffaCake, nah, it's not that important. Thanks for your time though. :-)
06:20:52 <eivuokko> JaffaCake, Did you get my email with ssh-key?  It was sent from maybe a bit unexpected email address, ei@vuokko.info
06:21:24 <JaffaCake> eivuokko: yes, got it thanks
06:21:29 <pejo> (I don't remember what I did 2 years ago, asking you to remember what you did 10 years ago was a long-shot which I thought was worth trying).
06:21:44 <JaffaCake> eivuokko: actually if you could resend as an attachment, that would probably help (line breaks got inserted somewhere)
06:21:48 <vincenz> JaffaCake: with me it's even worse
06:21:54 <vincenz> /dev/brainmemory : device null
06:21:54 <dcoutts> Lemmih, and probably the other reason is to avoid getting bombarded with Qs as JaffaCake does every time he turns up here ;-)
06:22:23 <eivuokko> JaffaCake, Okey, thanks.
06:24:22 <pejo> dcoutts, life as an oracle must be rough.
06:24:42 <dcoutts> heh, indeed
06:24:45 <vincenz> hmm
06:25:19 <vincenz> JaffaCake: not to intrude (just realized whom you were ...) have you by any chance read the post on haskell-cafe regarding dynamically stackable monads?
06:25:34 * vincenz coughs
06:25:44 <JaffaCake> nope, haven't read it
06:25:48 * JaffaCake goes to have a look
06:25:54 <vincenz> it's about a week old
06:26:00 <vincenz> maybe 2
06:26:03 <JaffaCake> what's the subject?
06:26:11 <vincenz> well I was curious whether it's feasible to dynamically stack monads
06:26:18 <vincenz> maybe through the use of typeclass hackery
06:26:27 <vincenz> given some monad transformer t
06:26:32 <davidhouse> vincenz: i still think it should be possible to bind those together somehow. a bit of parametrisation or something.
06:26:40 <vincenz> dynamically choose how many t's to stack on top of each other before stacking it onto a bottom m
06:26:42 <davidhouse> and it's "just realised _who_ you were" ;)
06:26:50 * davidhouse stops splitting hairs
06:27:28 <vincenz> http://www.haskell.org//pipermail/haskell-cafe/2006-May/015566.html
06:27:32 <JaffaCake> vincenz: still not sure which msg you're referrring to... do you have a link?  or the subject?
06:27:36 <JaffaCake> ah, thanks
06:27:51 * vincenz had hoped somoene would answer that
06:27:57 <vincenz> tho I know it's a tricky subject
06:28:23 <vincenz> one can imagine an 'internal lift' for one t to the t below it
06:28:25 <vincenz> and an external lift
06:28:31 <vincenz> directly down to the monad under the stack of t's
06:30:04 <genneth> has anyone seen this: http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html
06:30:26 <norpan> huh, it's not april 1?
06:31:01 <vincenz> genneth: yeah I saw that
06:31:02 <JaffaCake> vincenz: so what goes wrong when you try to have a dynamically sized stack? 
06:31:12 <vincenz> JaffaCake: you can't do that
06:31:32 <vincenz> dynamically stacked monads: t (t ( t...(m a))
06:31:40 <vincenz> with number of t's being runtime dpenedent
06:31:53 <vincenz> where t is a monad transformer
06:31:58 <JaffaCake> I see... probably existentials would help then
06:32:03 <norpan> if you can't learn haskell, then you're not a good developer anyway :)
06:32:04 * vincenz nods
06:32:12 <vincenz> I was thinking something along that line, but my type-fu is not that strong yet
06:32:13 <JaffaCake> so the inner ts are hidden inside the constructor
06:32:14 <norpan> so people should just switch and train
06:32:33 <norpan> s/people/companies
06:32:54 <vincenz> JaffaCake: I was thinking some typeclass with two different lifts 'intraLift' 'extraLift'
06:32:57 <JaffaCake> genneth: the Linspire thing is great!
06:33:12 <vincenz> and then yeah, existentials...but there my wisdom stops :/
06:33:26 <genneth> it's almost surreal to think about a hardware detection in haskell
06:33:27 <genneth> :p
06:33:34 <dcoutts> I wonder if the Linspire people know that there's already an OS package manger written in Haskell...
06:33:40 <davidhouse> that's not a joke?
06:33:42 <genneth> but i guess actually complex algos are exactly where haskell rocks
06:33:43 <dcoutts> kosmikus, ping
06:33:44 <norpan> do { monitor <- detectMonitor
06:33:55 <JaffaCake> dcoutts: I was assuming someone would point that out to them..
06:34:27 <dcoutts> JaffaCake, I would but it's kosmikus's project
06:34:39 <vincenz> does anyone know if there are any plans for GHC to trade-off between code duplication and keeping type-class methods polymorphic at runtime?
06:34:52 <vincenz> (the first one being sort of like the template system in c++)
06:35:10 <dcoutts> vincenz, you can already use the specialise pragma
06:35:18 <shapr> stepcut: You did this?
06:35:19 <kowey> howdy... who would i ask in order to have lambdabot grace our presence in #darcs?
06:35:27 <dcoutts> kowey, ask dons
06:35:29 <JaffaCake> vincenz: yes, try -funfolding-creation-threshold=200 -funfolding-use-threshold=200 :-)
06:35:31 <vincenz> dcoutts: right but one would imagine that whole-flow analyzer would be ideal for this
06:35:35 <kowey> dons: well, could it?
06:35:36 <vincenz> JaffaCake: thanks!
06:35:51 <davidhouse> kowey, or run your own.
06:36:15 * kowey is too lazy
06:36:26 <kowey> well, i'll check back later for the response, thanks to all
06:36:37 <dcoutts> JaffaCake, I wonder if profile feedback would help with that, ie choosing when it pays off to inline & specialise
06:37:55 <JaffaCake> dcoutts: sure, I think we've always had the vague notion that the amount of inlining & optimisation could be directed by profile feedback, but we've never tried it
06:37:56 <vincenz> dcoutts: not certain... after all the cost of polymorphic call is not very data dependent
06:38:09 <vincenz> and the footprint increase is compiletime decideable
06:38:31 <dons> ?join #darcs
06:38:36 <dons> kowey: how's that?
06:38:36 <dcoutts> vincenz, but you often don't know statically which are the 'hot spots' of the program
06:38:53 <vincenz> dcoutts: hmm, true
06:39:09 <dcoutts> vincenz, so often inlining / specialising just makes you binary bigger with no speed increase because it's optimising parts of the code that don't get run much.
06:39:24 <vincenz> yup
06:39:24 <kowey> thanks, dons!
06:40:00 <dcoutts> vincenz, and you could find out which types a polymorphic function is being called with often and try to specilise for the top few
06:40:12 <vincenz> dcoutts: no I fully agree
06:40:15 <dons> kowey: i'll put it in the config file so it automatically joins
06:40:44 <kowey> super
06:40:53 <vincenz> dcoutts: be neat if there were also data-access information in the profile, such that it could be used to tune deforestation
06:41:16 <dcoutts> vincenz, and it could be used for branch prediction, gcc does that.
06:41:36 <dcoutts> but obviously it's a big project
06:41:53 <vincenz> dcoutts: I thought gcc used static branch prediction based on compile-time decideable features
06:42:06 <kosmikus> dcoutts: pong
06:42:12 <dcoutts> yes it does, but if you give it a profile then it uses that too
06:42:28 <dcoutts> kosmikus, oh just about the Linspire thing and exi
06:43:05 <dcoutts> it'd be nice to point out that their decision is a reasonable one citing existing projects
06:43:13 * vincenz is personally researching deforestation for sequences in multimedia (non-functional) code
06:43:35 <vincenz> would be neat if after the fact I could somehow work that into ghc
06:44:11 <kosmikus> dcoutts: exi has alpha-status at best, and is currently dormant. I'm not sure if you can use exi to argue that their PL decision is right.
06:45:15 <dons> this linspire thing is real? 
06:45:25 <dcoutts> kosmikus, yeah, fair enough, I just thought it might be nice to point out that they're not alone, that people have done experiments in that direction
06:45:40 <dons> and only a couple of months after I saw debian guys joking they should be using haskell instead of perl in the base system, since its faster and more stable
06:45:48 <kosmikus> dcoutts: I'll think about it. Maybe I'll reply to them.
06:46:06 <dcoutts> kosmikus, avoiding publicity? ;-)
06:47:57 <kosmikus> could be ;) that's bad, isn't it?
06:48:13 <dcoutts> pimp y'er code!
06:48:27 <vincenz> JaffaCake: any idea how good deforestation currently is in GHC?
06:48:46 <JaffaCake> vincenz: it's pretty good, but limited to only a  few functions
06:48:53 <vincenz> it's combinator based, no?
06:49:06 <dons> hehe. /me imagines dcoutts doing the  "pimp yer code" show, where he takes bad programs, and rewrites^h^h^hpimps them out as haskell programs
06:49:15 <dcoutts> hah
06:49:31 <JaffaCake> vincenz: yes
06:49:32 <vincenz> aka, only functions written in term of 3 specific functions (combinators)
06:49:42 <dcoutts> dons, we get resistance in gentoo land to writing core thing in haskell partly because of the percieved weight & difficulty in building ghc
06:49:52 <vincenz> oki :) just like the paper 
06:50:06 <dcoutts> though they're perfectly happy with python, go figure
06:50:26 <dons> dcoutts: yes, i can imagine. how can we change this perception?
06:50:35 <dons> yeah, python's a beast too.
06:50:38 <dons> :(
06:50:48 <jip> make a lightweight haskell interpreter written in c :O
06:51:06 <kosmikus> dcoutts: you're welcome to convince me that I should do more advertisement ...
06:51:10 <vincenz> yeah H98 only... then write GHC in H98
06:51:17 <norpan> like hugs?
06:51:24 <dcoutts> dons, slimming ghc is one good direction. making hc build work reliably is another. and good arch portability is another.
06:51:25 <davidhouse> or a haskell -> c compiler.
06:51:33 <dcoutts> dons, yhc is another way
06:51:45 <davidhouse> you could even write such a compiler in haskell.
06:51:58 <davidhouse> then convert GHC to C dynamically with every release.
06:51:58 <dons> yeah, no one asks for C interpreters jip. just keep making it easier to port.
06:52:26 <dcoutts> kosmikus, if you're worried about g.o reaction I'd say it's still ok to mention on the haskell lists
06:52:27 <kosmikus> dcoutts: Gentoo isn't perfectly happy with Python. The use of Python is a reality at the moment, but part of the reason for Paludis is to get rid of the Python dependency ...
06:52:30 <vincenz> well if you had haskell -> c then it would be trivial to write a haskell compiler in c
06:52:47 <dcoutts> vincenz, we do have haskell -> c
06:52:55 <dcoutts> that's what ghc does on most arches
06:53:02 <vincenz> hmm
06:53:03 <dcoutts> it's just not portable c
06:53:05 <norpan> that's how you port ghc to a new platform, right?
06:53:05 <pejo> dcoutts, the "building ghc is hard"-perception, isn't that something that could be helped with more documentation?
06:53:06 <davidhouse> then use GHC to compile itself
06:53:09 <vincenz> dcoutts: ah...
06:53:28 <davidhouse> oh, it's not portable.
06:53:29 <Igloo> pejo: There are step-by-step instructions
06:53:33 <vincenz> dcoutts: why not make a crappy portable version...
06:53:35 <kosmikus> dcoutts: I'm worried about a couple of things, but I'm afraid it's quite complicated ...
06:53:37 <vincenz> dcoutts: then distribute that
06:53:39 <dcoutts> pejo, not really. We're talking about in a distro, bot people building themselves.
06:53:41 <vincenz> dcoutts: then ghc can bootstrap itself
06:53:50 <vincenz> from gcc
06:53:53 <davidhouse> ghc already does bootstrap itself.
06:54:00 <davidhouse> from .hc files.
06:54:02 <vincenz> yea, presupposing an exiting ghc
06:54:06 <dons> no.
06:54:07 <norpan> how is gcc distributed in such a distro?
06:54:11 <dons> presupposing gcc.
06:54:19 <pesco> dons: Interesting idea, lightweight C interpreter written in Haskell. Or did I get something wrong? :-P
06:54:31 <dons> um. that's called hugs, no?
06:54:36 <dons> oh. sorry.
06:54:41 <dons> hehe
06:54:42 <norpan> sguh
06:54:53 <pejo> Igloo, nod, I've read them. 
06:54:54 <dons> pesco, you want to do *that* for SoC :)
06:55:15 <pesco> Ah dang, why's the submission deadline over already?!
06:55:23 <norpan> but ghc is maybe overkill for a simple script language
06:55:30 <norpan> won't hugs do?
06:55:34 <dcoutts> try yhc
06:55:58 <vincenz> dons: Bootstrapping GHC on a system without GHC already installed is achieved by taking the intermediate C files (known as HC files) from another GHC compilation, compiling them using gcc to get a working GHC.
06:55:59 <kosmikus> Cale: I believe I've solved your puzzle (manually). Very nice ...
06:56:07 <dons> i don't even know what a simple script language is supposed to be. they always get used in more and more exciting ways, and then they're not so simple. and you end up with perl.
06:56:12 <vincenz> dons: that's hardly bootstrapping from gcc...you need ghc on a similar system
06:56:24 <vincenz> so if you're porting to a completely new arch..
06:56:25 <dons> no. on any system.
06:56:41 <vincenz> HC files are platform-dependent, so you have to get a set that were generated on the same platform
06:56:44 <dons> doesn't have to be the same arch. how do you think we ported to mips64?
06:56:53 <vincenz> that's what it says on the ghc page
06:56:53 <dons> no no.
06:56:58 <vincenz> I'm copy pasting!
06:57:03 <vincenz> http://www.haskell.org/ghc/dist/current/docs/building/sec-porting-ghc.html#sec-booting-from-hc
06:57:06 <vincenz> hence my confusion
06:57:14 <pesco> vincenz: The trick is to take _unregisterized_ HC files. (Yeah, that's supposed to sound a little laconic. ;))
06:57:43 <vincenz> oh
06:57:45 <norpan> yeah, don't register your HC files!
06:57:57 <davidhouse> vincenz: yeah, read the rest of that page
06:58:39 <dons> really, how do you think we ported to mips64, or powerpc. ghc wasn't born runnign on those systems  :)
06:58:45 <vincenz> dunno
06:58:49 <vincenz> lot of manual work?
06:59:12 <dons> or was it!? maybe it came fully formed in perfect beauty. with the power of 20 architectures!!
06:59:29 <vincenz> dons: lazy evaluation
06:59:32 <norpan> i think we should generate architecture-independent machine code
06:59:37 <dons> vincenz: nah, you just generate neutral C code, and compile it with gcc on the target.
06:59:39 <pesco> er.
07:00:01 <vincenz> dons: or just (fix ghc)
07:00:10 <dons> its fun how bootstrapping makes so many people so funny in the head.
07:00:10 <jip> didn't spj start the c-- project specifically as a compiler target for ghc?
07:00:14 * pesco just sits down and waits until jhc can compile GHC.
07:00:21 <xerox> There also is that vm-like thing somebody pasted here some time ago
07:00:46 <xerox> http://llvm.org/
07:00:48 <dons> like that fully nerd guy who just wacked out with the recursion.
07:00:56 <dons> and had a stack overflow in his brain. 
07:01:01 <vincenz> dons: ?
07:01:03 <pesco> Huh?
07:01:10 <ndm> ah, was just about to @seen dons, then you talk :)
07:01:18 <xerox> hehe
07:01:25 <xerox> dons++
07:01:28 <ndm> dons, ByteString on Windows is pretty large, takes up about 1Mb of size
07:01:36 <dons> hmm. strip?
07:01:38 <ndm> including Char8.dll and ByteString.dll
07:01:44 <ndm> can that be done on windows?
07:01:48 <dons> do you have split objs?
07:01:52 <ndm> hugs
07:02:05 <ndm> just as made using the base library setup
07:02:10 <dons> hmm. ok.
07:02:19 <dons> I could tune the inlining.
07:02:49 <dons> it is a fairly big library though. its 2.5k loc or something.
07:03:11 <ndm> i doubt its the inlining
07:03:12 <dons> though i've only noticed 100k objects here.
07:03:19 <ndm> probably GCC on Windows, it likes big files
07:03:24 <dons> ah. maybe.
07:03:26 <eivuokko> Did you strip?
07:03:31 <ndm> eivuokko: how?
07:03:41 <ndm> i just did make from the root of hugs
07:03:50 <eivuokko> I have no idea how hugs is compiled.
07:03:56 <ndm> me neither :)
07:04:08 <eivuokko> In fact I can't get anything sensible working with hugs.
07:04:23 <eivuokko> Anyway, mingw binutils has strip.exe, which can handle .exe and so probably .dll too
07:04:23 <ndm> i am probably going to have to remove ByteString from MinHugs, unless it can be prodded into a lot smaller package
07:04:53 <ndm> 2.5KLoc under Visual Studio is around 8kb, so that might be teh way forward
07:04:55 <dons> ndm, hmm, ByteString.so here is only 22k.
07:05:07 <ndm> dons, that size would be good
07:05:11 <dons> in hugs' lib dir.
07:05:19 <ndm> that size would make it into minhugs
07:05:57 <dons> $ pwd
07:05:57 <dons> /home/dons/lib/hugs/packages
07:05:57 <dons> $ du -hs fps
07:05:57 <dons> 210K    fps
07:06:07 <dons> so I don't know what's happening on windows.
07:06:15 <eivuokko> ndm, Are there docs how to build hugs or your distro in Windows?
07:06:19 <dcoutts> dons, btw, I've got another group/groupBy which I think works
07:06:27 <ndm> is the official bytestring library in teh base package?
07:06:33 <ndm> and if so, where is teh .c bits of it?
07:06:33 <dons> dcoutts: ok. cool. i'll pull whatever you have in the morning.
07:06:42 <dons> ndm, yes, and in cbits/
07:06:46 * dcoutts darcs sends to dons
07:06:54 <ndm> eivuokko: yes, and they are wrong, i'm working on them now
07:06:57 <dons> oh, darcs send is ok too.
07:07:20 <eivuokko> ndm, Ah ok.  Cool :)
07:07:41 <ndm> dons, ok, will try to build with ffihugs with visual studio, and see if i can do better...
07:07:53 <eivuokko> ndm, Have you compiled Cabal in Windows with hugs?
07:08:10 <dons> ?localtime dons
07:08:12 <ndm> eivuokko: no idea, perhaps...
07:08:13 <lambdabot> Local time for dons is Tue May 16 00:03:22 2006
07:08:15 <dons> ah, bed time!
07:08:18 <dons> night guys!
07:08:30 <norpan> your clock is off
07:08:32 <dcoutts> g'night dons 
07:08:39 <eivuokko> Good night, dons.
07:09:01 <norpan> ?localtime norpan
07:09:05 <lambdabot> Local time for norpan is Mon May 15 16:08:38 2006
07:09:52 <davidhouse> dons lives 10 minutes ahead of the rest of his timezone.
07:10:35 <norpan> it's coffee time
07:11:11 <ndm> woot, 26Kb when compiled again with Visual Studio
07:11:29 <ndm> which is certainly reasonable, although too late to make it into this Hugs release, sadly
07:15:09 <araujo> Good morning!
07:15:31 <_roconnor> morning
07:17:05 <jip> @type 3.2
07:17:06 <lambdabot> forall t. (Fractional t) => t
07:17:27 <jip> @hoogle forall t. (Fractional t) => t -> t -> t
07:17:28 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:17:28 <lambdabot> Prelude.const :: a -> b -> a
07:17:28 <lambdabot> Prelude.seq :: a -> b -> b
07:18:32 <dialtone> hi all, is there any reason why I get random 'weird activation frame' errors or segmentation faults or bus errors under OSX?
07:18:43 <dialtone> (10.4.last_one)
07:18:43 <shapr> I am tempted to switch to Freespire.
07:19:43 <dialtone> I compiled from source (using darwinports) ghc 6.4.2 twice, the first time the segmentation faults were quite frequent, but tonight I recompiled it (G4) and they are a lot less frequent (but still they happen)
07:19:56 <araujo> shapr, very interesting right?
07:21:06 <ndm> jip, hoogle doesn't like forall's
07:21:19 <ndm> and in fact, if you use them, it will hate you forever
07:21:20 <xerox> ndm: could hoogle use GHC-api for that?
07:21:31 <ndm> xerox, to be just like GHC, ye
07:21:46 <ndm> but to retain its hoogle goodness, and the unique matching algorithm, not really
07:21:53 <ndm> its much more than just a type checker
07:22:06 <ndm> or much less, depending on how you see a type checker
07:22:22 <ndm> and in general, you don't search for something with a higher rank type, you know about it already
07:22:30 <xerox> I mean, if one can get the parsing done by GHC, it's halfway done.
07:22:33 <jip> ndm: are you the guy who is responsible for this hoogle thing?
07:22:38 <ndm> jip, yep
07:22:45 <jip> cool :)
07:22:54 <ndm> xerox, i may use Language.Haskell, which is the GHC parser, so yep, might do that
07:23:05 <ndm> then throw away all forall's (with an appropriate message to the user)
07:23:17 <shapr> araujo: Yes, definitely.
07:23:29 <xerox> Lemmih did write a gardener in very few lines of code, I think it could be a worthy approach.
07:24:04 <xerox> (With GHC-api, I mean.)
07:24:05 <ndm> yes, it might be a cool approach
07:24:11 <ndm> worth trying at some point
07:24:18 <ndm> but i'm not sure it would have the speed required
07:24:29 <ndm> and to be honest, most searches are purely text based
07:24:34 <xerox> ...to parse one single type signature?
07:24:43 <ndm> (i'm optimising text searches in 4.0)
07:24:52 <ndm> oh, i thought you meant to do the type search as well
07:24:59 <ndm> to parse one type signature, its plenty fast enough
07:25:09 <ndm> but the parser for GHC-api is already split off
07:25:21 <ndm> and can be used without GHC-api, under Language.Haskell in teh haskell-src package
07:25:30 <Lemmih> Really?
07:25:31 <xerox> Okay.
07:25:52 <ndm> Lemmih: really, about the Language.Haskell?
07:25:56 <jip> Lemmih: hi, how is hIDE going?
07:26:08 <Lemmih> jip: Not so good.
07:26:16 <jip> :O why not? :(
07:27:37 <Lemmih> I'm still not sure how the plugin system should be designed.
07:28:14 <jip> are there any technical problems?
07:28:24 <vincenz> Lemmih: care to brainstorm?
07:28:27 <Lemmih> ndm: What's the point of haskell-src-exts, then?
07:28:59 <ndm> Lemmih: i believe haskell-src has forall, i may be wrong though - my haskell-src is a Hugs port done ages ago by the person who sits next to me
07:29:18 <ndm> i have never used Language.Haskell directly
07:31:27 <Lemmih> vincenz: About plugins in hIDE?
07:31:52 <vincenz> Lemmih: yeah
07:34:44 * Lemmih tries to remember the problem.
07:36:32 <Lemmih> Oh yeah, we somehow need to avoid lots of global variables.
07:38:27 <Lemmih> I'm not sure if that's a problem anymore. Perhaps we just need someone to hack it.
07:39:26 <sjanssen_> @yow!
07:39:26 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
07:39:26 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
07:40:23 <shapr> xerox: gardener?
07:41:13 <Lemmih> shapr: http://darcs.haskell.org/~lemmih/gardener/
07:42:12 <norpan> apart from the plugin issues, are there any ideas on how hIDE would look/work and so on
07:43:09 <shapr> Lemmih: cute!
07:43:41 <dcoutts> norpan, yes
07:44:11 <norpan> in a tangible form?
07:44:23 <Lemmih> norpan: It will hopefully look something like this (again): http://darcs.haskell.org/~lemmih/HideUnicodePretty.png
07:44:26 <dcoutts> in the code and on the wiki
07:45:10 <dcoutts> but mostly in the heads of various people
07:45:23 <norpan> ah
07:45:52 <dcoutts> norpan, the wiki is a good start, after that check out the code and ask questions
07:46:10 <dcoutts> I think the pluging issue isn't so bad as Lemmih thinks it is.
07:47:52 <norpan> http://darcs.haskell.org/~lemmih/hIDE is the place to find the latest code?
07:48:03 * roconnor wonders if type variables should be in italics
07:49:08 <dcoutts> norpan, that or http://darcs.haskell.org/hIDE/
07:49:39 <norpan> oh
07:50:57 <Lemmih> dcoutts: And I still believe plugins aren't just modules linked at run-time. (:
07:51:17 <Lemmih> dcoutts: We tried that and it went bad.
07:52:18 <dcoutts> yeah I think we need a better abstraction and no load order deps, but I think the basic approach was ok
07:53:27 <dcoutts> the main problem was just hs-plugins and reliability right? (that and the time taken to load the plugins)
07:54:19 <Lemmih> The main problem was global variables and a complete lack of abstractions.
07:54:30 <dcoutts> aye
07:55:21 <Lemmih> We can't load plugins faster than hs-plugins. Not without loading .a's instead of .o's.
07:56:00 <dcoutts> you mean .so's
07:57:28 <shapr> I'll start using yi or hIDE or whatever as long as it has syntax highlighting.
07:57:34 <shapr> I'm tired of emacs.
07:58:12 <Lemmih> I do? Yeah, perhaps I do. It's all a bit fuzzy to me.
07:58:23 <eivuokko> Lemmih, Why would loading .a be faster than .o/.so, or do you refer to the diffrent linking model (linking locally vs globally)?
07:58:48 <Lemmih> shapr: I couldn't live without emacs' auto-indentation.
07:59:22 <shapr> It's not that great :-/ Plus it wouldn't be too hard to port it to Haskell.
07:59:46 <shapr> Admittedly, I wouldn't want to line it up manually.
08:00:26 * araujo does fine with emacs, though he would like a Haskell editor
08:00:55 * mnislaih recommends Visual Haskell to araujo
08:00:57 <pejo> Anyone tried the  Eclipse plugin for Haskell?
08:01:03 <mnislaih> I did
08:01:12 <mnislaih> The 0.8.0 version or so was fine
08:01:16 <norpan> i'll use any editor that has good vi bindings
08:01:16 <mnislaih> again, only in Windows
08:01:25 * araujo doesn't use anything that has Visual peceded in its name
08:01:36 <dcoutts> hah
08:01:53 <mnislaih> araujo: that's pure nonsense...
08:01:55 <shapr> norpan: yi has that already.
08:01:57 * jip uses vim
08:02:29 <norpan> i'll have to try yi then
08:02:43 <norpan> vim rocks
08:03:06 <araujo> mnislaih, ive been doing very well so far :-)
08:04:03 <araujo> i use vim for fast editing
08:04:08 <araujo> manly config files
08:04:26 <Saulzar> Hmm, I tried the Eclipse plugin recently - seemed to work pretty well, but misparsed the compiler errors which made it hard to use.
08:04:28 <dcoutts> yeah config files are manly ;-)
08:04:32 <mnislaih> I'm not interested in starting such an argument, but I thought you asked for a 'Haskell editor', and VH is a fine one
08:04:47 <mnislaih> no matter the name or the platform
08:05:37 <mnislaih> it's an inconvenience if you don't like / can't stand the said platform, of course
08:05:38 <shapr> It's snowing here. When will summer arrive?
08:06:04 <pejo> shapr, oh, sorry, you've missed it this year. Was last monday.
08:06:12 * shapr cries
08:08:54 <wchogg> There's something that's really bugging me about TH.  [|(+)|] works exactly as I'd expect, but (\x -> [|x|]) (+) doesn't.  Shouldn't it be the same?
08:09:45 <norpan> wchogg: in one case you are [|-ing x, in the other case (+). They are not the same thing?
08:10:40 <wchogg> Eh?  It works just fine for literals, but it fails for functions.
08:11:04 <dialtone> ghc -I/opt/local/include -cpp  -package QuickCheck -package util -package parsec -O -funbox-strict-fields -I/opt/local/include -Wall -Werror -I. -I/opt/local/include -DHAVE_CURSES -DHAVE_CURL -c SlurpDirectory.lhs
08:11:04 <dialtone> make: *** [SlurpDirectory.o] Segmentation fault
08:11:12 <wchogg> And I'm just applying a function to a value.  By all rights, should it not be the same?
08:11:35 <dialtone> (on a G4 ppc with OSX 10.4) anyone has any idea of what could possibly be wrong?
08:11:45 <dialtone> the error happened while compiling darcs
08:12:10 <dialtone> (and sometimes darcs compilation fails directly in the configure step when checking for ghc)
08:13:05 <pejo> dialtone, it sounds like you have broken hardware to me, random segfaults isn't "expected".
08:13:47 <dialtone> any way I can find out what might be broken?
08:14:18 <pejo> Usual suspects is memory, or fans. 
08:14:32 <dialtone> although ghc is the only software that randomly breaks
08:15:15 <resiak> Probably the only thing that uses all your ram ;)
08:15:23 <norpan> wchogg: what i mean is that syntactically, x is not the same as (+)
08:16:11 <wchogg> Ah!  I think I see what you mean.
08:16:13 <dialtone> resiak: uhmm :)
08:16:19 <ADEpt> dialtone: try zipping/rar/tar-bz2-in large file(s), look out for sigsegvs.
08:18:22 <dialtone> ok, trying to tar-bz2 an 800MB file
08:19:07 <norpan> hmmm, is there a way to get ghc to show a data type like "show" even though it has no Show instance?
08:19:37 <norpan> or in this case ghci
08:21:02 <davidhouse> no.
08:21:18 <davidhouse> norpan: if you made up the datatype, you can normally derive Show.
08:21:31 <davidhouse> but everything that could sanely be shown is an instance of Show.
08:23:37 <norpan> okidoki
08:23:42 <ndm> norpan: you can with hugs
08:24:01 <ndm> if you flick a special switch, to say use automatic special show instances
08:24:12 <norpan> ok thanks
08:24:16 <norpan> i'll just derive it then
08:24:19 <ndm> which is very handy, if your show doesn't terminate
08:25:48 <flowolf> hi all
08:35:33 <norpan> hey, this Yi stuff works
08:35:47 <davidhouse> it does?
08:35:49 <norpan> although a lot of the vi bindings were not implemented yet
08:35:52 <davidhouse> it didn't last time i tried it
08:36:40 <norpan> :x and c so far
08:38:26 <davidhouse> well i wouldn't have tried the vim bindings
08:39:30 <norpan> dw did not do what i expected either
08:39:32 <norpan> well well
08:39:35 <Lemmih> SyntaxNinja: Hiya.
08:43:55 <davidhouse> @where haxml
08:43:55 <lambdabot> http://haskell.org/HaXml
08:44:04 <davidhouse> is haxml cabalized?
08:44:07 <davidhouse> *cabalise
08:44:14 <davidhouse> *cabalised :) got there eventualy
08:44:26 <davidhouse> *eventually. /me gives up
08:46:02 <davidhouse> would people recommend haxml as a library for parsing HTML?
08:46:40 <kowey> i don't know if this helps, but i'm a pretty big fan of haxml's DtdToHaskell tool
08:46:58 <kowey> (which has a useful side effect of helping you debug DTDs)
08:47:34 <jip> i thought the best one was haskell xml toolbox
08:47:45 <davidhouse> i don't think i need anything as full as DTD support. i just want to parse HTML.
08:47:56 * davidhouse considers just using regexes
08:48:10 <davidhouse> i actually only want to extract one or two strings from a pagefull of HTML.
08:48:28 <eivuokko> In such cases I have written Parsec-parser.
08:48:40 <eivuokko> But it's pretty much matter of taste, I think.
08:49:11 <norpan> it depends on the html
08:49:23 <norpan> most html you see on the web is not xml
08:49:29 <davidhouse> i really wish there were better PCRE support in haskell. bundling JRegex would be a nice touch.
08:50:02 <davidhouse> norpan: yes. HaXML contains a more lenient parser though.
08:50:14 <norpan> oh, it does
08:51:35 <davidhouse> is cabal ideal for distributing whole applications? i.e. not libraries
08:52:32 <Lemmih> It tries to be.
08:53:00 <davidhouse> what does that mean?
08:53:38 <shapr> It means that we hope it will do that soon, but it doesn't yet.
08:53:55 <shapr> davidhouse: Do you mean distributing via the web?
08:54:18 <shapr> SyntaxNinja: y0!
08:54:24 <davidhouse> i haven't really decided yet. does it matter?
08:54:37 <SyntaxNinja> y0 Lemmih
08:54:43 <SyntaxNinja> y0 shapr
09:14:50 * shapr boings
09:48:30 <the_lord> how do I print in haskell and then return what I want
09:48:33 <the_lord> ???
09:48:34 <lambdabot> Maybe you meant: . id pl v wn
09:49:02 <ndm> the_lord: can you be a bit more specific?
09:50:42 <the_lord> I want a function like this a -> b
09:50:54 <the_lord> receive the a, print something, return b
09:51:32 <TuringTest> you would usually need to have type "a -> IO b" to do this
09:51:42 <TuringTest> What do you mean by "print"?
09:51:55 <the_lord> print, show something in the stdout
09:52:32 <TuringTest> Are you debugging with this?  Or is it the purpose of the function?
09:53:22 <the_lord> is the purpose
09:54:01 <TuringTest> So this function needs to perform Output and must be (at some level) an instance of the IO monad.
09:54:05 <the_lord> or, another alternative, how do I return nothing?
09:54:25 <the_lord> yes, but I need to return b
09:54:27 <the_lord> not IO b
09:54:43 <psi> you can't
09:54:54 <TuringTest> Then you *can* if and only if you use "unsafePerformIO"
09:55:03 <TuringTest> or "unsafeInterleaveIO"
09:55:10 <jip> or Debug.Trace
09:55:46 <TuringTest> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
09:56:04 <TuringTest> jip: He is not debugging and want stdout and not stderr
09:56:36 <the_lord> thx
09:57:24 <psi> "For this to be safe, the IO computation should be free of side effects and independent of its environment.". Note that your functions is NOT free of side effects so it's not safe to use.
09:57:48 <the_lord> why it's not free of side effects?
09:57:52 <TuringTest> psi: Sending text to stdout is usually totally safe.  (Like Debug.trace)
09:57:56 <xerox> ./foo 2>&1
09:58:03 <TuringTest> the_lord: Printing is a side effect!
09:58:07 <xerox> And you get stderr on stdout.
09:58:18 <SyntaxNinja> TuringTest: unless you actually want to count on that text being printed for some strange reason.
09:58:53 <TuringTest> SyntaxNinja: The only problem is if stdout has been closed and printing throws an error.
09:59:33 <SyntaxNinja> TuringTest: you can certainly have situations, with lazy evaluation, where your IO computation will not get executed, and so your output not printed.
09:59:59 <TuringTest> True
10:00:03 <sjanssen_> inling can also cause your IO code to execute several times
10:00:11 <Philippa_> in the case of Debug.Trace it's "safe" because that's intended semantics
10:00:32 <TuringTest> SyntaxNinja: But the_lord already has an arguably unintelligent design
10:01:06 <psi> the_lord: why is IO b not ok, by the way?
10:01:44 <Philippa_> given the original question? Almost certainly "because I hadn't considered IO before and I don't understand IO b" :-)
10:01:57 <Philippa_> (granted it's a little scary 'til you get the hang of it
10:01:58 <Philippa_> )
10:02:05 <monochrom> Yeah I think you have been designing too imperatively.
10:02:27 <psi> I was going to suggest to him to read about IO in haskell.
10:02:36 <Philippa_> psi: he's *asking* about IO in haskell
10:02:38 <SyntaxNinja> the_lord: think of the unsafePerformIO like an unsafe cast in C.  IO is _a part_ of the type.  if you want to change the type, it's risky.  the type system is there for a reason.  you should bite the bullet and put it in the IO monad. that's it's type.
10:03:25 <Philippa_> the_lord: you appear to want something like myFunc a = do print "blah"; return (f a)
10:03:58 <Philippa_> that'll have the type a -> IO b, but this is probably what you "really" want
10:04:30 <psi> I don't think showing the unsafe function is a great idea, to begin with
10:04:42 <psi> functions
10:05:18 <TuringTest> psi: I see what you mean, but...
10:05:35 <monochrom> I have written briefly on this topic in http://groups.google.com/group/comp.lang.functional/msg/9a4a844e63d6feed
10:05:56 <TuringTest> I think the_lord came here for help, and I would rather give him what he thinks he needs instead of a lecture.  If he keeps using Haskell then he will learn the rest in time.
10:06:22 <Philippa_> TuringTest: I don't think he thought he needed that. I just think he had an expectation as to the likely type
10:06:41 <Philippa_> because unless you know otherwise, that *is* what you expect
10:06:55 <monochrom> My definition of "help" is different.
10:07:00 <the_lord> TuringTest, I really don't have much time :S
10:07:16 <the_lord> how do I say a function returns nothing?
10:07:21 <the_lord> kinda like error
10:07:26 <TuringTest> Why?
10:07:28 <the_lord> the function error
10:07:39 <Philippa_> the_lord: you don't. You say it returns the type (), which has two values: _|_ ("not really a value") and ()
10:08:06 <Philippa_> _|_ is the "value" of code that doesn't terminate or fails a pattern-match somewhere
10:08:19 <TuringTest> Ceci n'est pas une pipe
10:08:38 <monochrom> Well you can use "error".  I don't understand the question.
10:08:46 <Philippa_> @type error
10:08:47 <lambdabot> forall a. [Char] -> a
10:08:52 <sjanssen_> the_lord: I bet you mean "how do you say that a function does IO, but doesn't return a value".  In this case, it has the type "IO ()"
10:08:54 <Philippa_> but error is... special
10:08:58 <TuringTest> the_lord: Could you take a minute to tell us what your function(s) are actually computing?
10:09:06 <sethk> there is also ioError
10:09:41 <the_lord> I using alex
10:10:13 <the_lord> so, I need to report errors and continue evaluating
10:11:09 <Philippa_> fundamentally, you don't do it like that. You return both any errors you found and the final result
10:11:19 <Philippa_> then the code that called you decides whether to print 'em or not
10:11:28 <Philippa_> (alternatively, you do it all in the IO monad)
10:11:59 <monochrom> I agree with Philippa_'s first statement.  It's also what I advocate in http://groups.google.com/group/comp.lang.functional/msg/9a4a844e63d6feed
10:12:18 <monochrom> It's also what everyone advocates.
10:13:20 <xerox> monochrom: isn't the program in the c.l.f post wrong?  I think it should be foldl max 0 (scanl op 0 l).
10:13:52 <jip> @seen Lemmih 
10:13:52 <lambdabot> Lemmih is in #haskell-blah, #haskell-overflow and #haskell. I last heard Lemmih speak 42 minutes and 26 seconds ago.
10:13:54 <monochrom> Ha!  It's way too late to correct it now :)
10:14:20 * xerox pats monochrom (:
10:14:42 <monochrom> Since I specified "non-empty list", I was thinking foldl1
10:14:59 <xerox> Right.  Nice code.
10:15:34 <SyntaxNinja> the_lord: are you in a hurry? is this for an assignment?
10:15:48 <the_lord> yes
10:16:14 <the_lord> SyntaxNinja, do you know Alex?
10:16:59 <SyntaxNinja> the_lord: here's the way it breaks down, IMO.  You could learn to use unsafePerformIO, but it's likely to take you more time than you expect, and it probably won't work.  the only real solution is to move the correct bits of code into the IO monad.  take an hour to read up on the IO monad (without trying to solve your problem) and try some simple exercises on it.
10:17:03 <the_lord> here's what the teacher told me, "In the errors you don't really return a Token, you redirect them"
10:17:17 <Lokadin> say make html doesn't seem to work in yi
10:17:18 <SyntaxNinja> the_lord: not really. I've used it once for a parser, but that was a while ago.
10:17:21 <Lokadin> does anyone know why?
10:17:30 <the_lord> kinda, UNIX
10:18:43 <the_lord> it's like the stdout and stdin, all the good ones I'll pass them trough stdout (Tokens), the errors through stderr (print them)
10:19:22 <sjanssen_> the_lord: right now, your lexer is returning something like [Token]?
10:19:32 <the_lord> yes
10:20:09 <sjanssen_> the_lord: perhaps you can turn it into [Either String Token], which is either a string explaining the bad token, or a successful token
10:20:17 <the_lord> omfg got to go, I'll be back in an hour
10:20:19 <the_lord> bye
10:20:26 <SyntaxNinja> heh
10:21:03 <shapr> Is there a fast SHA1 specifically for ByteString aka FastPackedString?
10:21:36 <dcoutts_> shapr, steal one out of darcs
10:21:38 <monochrom> In my experience, a case of hurrying for homework is a lost cause.  Can't be helped.  Because of the anxiety, the student is freaking out and not listening.
10:21:40 <shapr> I think there's one in darcs, is there anything more recent?
10:21:43 <shapr> dcoutts_: ok, thanks.
10:21:48 <Lokadin> so i take it no one here has generated the yi haddock recently?
10:22:26 <monochrom> But by definition all programming students proscratinate.  Therefore all programming homework can't be helped.
10:22:52 <SyntaxNinja> monochrom: yeah. it's painful to watch.
10:23:10 <SyntaxNinja> how many times on this channel have I wanted to say "get off of IRC and learn IO!"
10:23:29 <pejo> mono, like that's something typical of programming students.
10:23:34 <SyntaxNinja> maybe I should say that.  but I also want to shake them while I say it, which I can't.
10:23:38 <Philippa_> I could be made to listen if told that a) what I was being taught could be learnt in the time available and that b) the rest of the solution was reasonably easy
10:23:54 <shapr> But that would require starting early enough.
10:23:54 <Philippa_> then again, I was otherwise a fairly clueful student
10:24:10 <SyntaxNinja> Philippa_: would shaking you help?
10:24:26 <Philippa_> probably not. Depends whether you were trying to have your arms removed :-)
10:24:35 <monochrom> part (a) takes an afternoon in all cases.  part (b) is always true after part (a).
10:24:50 * Philippa_ nods
10:24:55 <Philippa_> which was why I usually got away with it
10:25:12 <monochrom> So, it comes down to, "if only you consulted us yesterday..."
10:26:41 <Philippa_> see, I'd be doing it the night before it was due in, not the day it was
10:26:50 <Philippa_> admittedly because I wouldn't expect to have sufficient time awake on the day
10:27:54 <Lokadin> who needs sleep at night anyway
10:27:54 <Lokadin> lol
10:29:05 <Philippa_> IME it tends to leave you in a better state than sleeping during the day does
10:29:14 <jip> is it ok if a function name is 37 letters long?
10:29:15 <Philippa_> but my body clock used to be pretty severely screwed up
10:29:33 <Philippa_> jip: depends. Personally, I'd probably also bind the function to an acronym of its full name
10:29:49 <sjanssen_> jip: perhaps you should ask your fingers ;-)
10:29:54 <Lokadin> i dono, i have to program during the night because i simply don't have time with work and gf friends and chores during the d ay
10:30:06 <jip> my fingers don't mind since vim has autocompletion :D
10:30:35 <Saulzar> jip, Badness :)
10:30:59 <sjanssen_> jip: how does one get vim autocompletion with Haskell?
10:31:01 <Philippa_> Lokadin: you'll still function better if you sleep before dawn and get up before dark
10:31:21 <Philippa_> when I'm regularly going to sleep after dawn, I know all about it in a matter of days...
10:31:24 <jip> sjanssen_: control+p/n works with anything
10:31:30 <Philippa_> ...regardless of how much actual sleep I'm getting
10:32:14 <Saulzar> Yes, waking up after dark is bad.
10:33:35 <Lokadin> Philippa_: what do you mean that you know all about it?
10:33:53 <Lokadin> Saulzar: what if you take a nap?
10:34:00 <vincenz> re
10:35:07 <Lokadin> yea, so we're pretty OT, so does anyone know anything about yi haddock ? anyone have a working copy?
10:35:16 <Philippa_> Lokadin: I get run down real fast. Depressed (or more depressed if already suffering), less energy, all kinds of not-fun stuff like that
10:35:32 <Lokadin> Philippa_: :( that's terrible
10:35:42 * Lokadin gives Philippa_ a hug
10:35:44 <Lokadin> :)
10:35:53 <Philippa_> nah, terrible's when you realise how much work it is to fix it again afterwards. Oh well
10:36:03 <Philippa_> at least my body clock's not as screwed up as it was throughout my teens
10:36:48 <Lokadin> i found if i don't drink any caffiene going to bed at the right time every now and again isn't too hard
10:37:18 <Lokadin> but sometimes it is
10:37:53 <pejo> Lokadin, err, isn't it falling asleep that becomes harder from caffeine, not going to bed?
10:38:38 <Lokadin> pejo: yea is what i mean lol
10:38:44 * Cale stayed up last night creating puzzles, then went to the store to get milk after it was light out, then had a coffee around 7am, then immediately went to sleep.
10:39:25 <pejo> Cale, some lucky sods find it harder to sleep after coffee though. :-)
10:39:27 * Lokadin thinks Cale_ triumphed over caffiene
10:40:04 <Philippa_> Lokadin: yup, caffeine is a major part of it if I mess up now
10:40:09 <Saulzar> Hehe, if you're absolutely exausted you can sleep through any amount of caffine
10:40:17 <vincenz> Saulzar: hi
10:40:23 <Cale> At a point, coffee doesn't do so much to keep me awake.
10:40:28 <palomer> <:O
10:40:31 <Lokadin> Saulzar: true that
10:40:37 <Philippa_> at a point it sure doesn't do much to keep me /usefully/ awake
10:40:39 * palomer _refuses_ to drink coffee
10:40:49 <palomer> @palomer
10:40:49 <lambdabot> Pfft
10:40:59 <Lokadin> palomer: what about tea?
10:41:03 <Cale> But I am basically on Australia time, despite living on the other side of the world :)
10:41:04 <palomer> love tea
10:41:14 <Saulzar> vincenz, hey.
10:41:19 <vincenz> busy busy
10:41:27 <vincenz> just found out I'm coauthoering another paper due tomorrow
10:41:33 <vincenz> and I get to reveiw it/fix it now
10:41:45 <pejo> Heh. "Oh, did I write this?". 
10:41:48 <Saulzar> I am basically on India time, living over the other side of the world
10:41:50 <Lokadin> vincenz: cool :)
10:42:02 <vincenz> Lokadin: yeah except I gotta fix it, lots of minor mistakes
10:42:08 <Lokadin> vincenz: oh
10:42:19 <vincenz> pejo: it's cause I built this entire experimental framework on which a lot of papers are published
10:42:22 <Lokadin> vincenz: still, i'm not coauthoring any papers
10:42:25 <Lokadin> :P
10:42:30 <vincenz> Lokadin: I'm a phd student...
10:42:41 <Lokadin> well yea, is true, but i want to eventually
10:42:47 * vincenz has his first paper (as first author) at ICME /D
10:42:55 <vincenz> Lokadin: undergrad?
10:42:59 <Lokadin> yep
10:43:04 <shapr> me too!
10:43:04 <vincenz> Lokadin: pre-master year?
10:43:09 * shapr hasn't graduated yet
10:43:11 * vincenz is always looking for possible master students
10:43:19 <Lokadin> vincenz: just finished first year
10:43:25 <vincenz> ah
10:43:35 <Lokadin> yea
10:43:40 <vincenz> heh
10:43:43 <vincenz> yhou're ahead of me
10:43:52 <vincenz> I only learned haskell after I graduated from uni
10:44:12 <shapr> Can I pattern match on the first byte of a ByteString as if it were a Char ?
10:44:23 <vincenz> shapr: that would rock
10:44:27 <vincenz> shapr: something like a Char class
10:44:30 <vincenz> just like Num
10:44:45 <Cale> You'd need to have something like Views for that.
10:44:55 <vincenz> Cale: how does it work for Nums then
10:45:17 <vincenz> something similar could in principle also be applied to Char and ByteSTring and whatnot
10:45:25 <vincenz> instance Character Char
10:45:28 <Cale> Oh, for Nums it's defined as part of the language :)
10:45:30 <vincenz> instance Character ByteString.byte
10:45:33 <Saulzar> It's not a list, either - though
10:45:36 <shapr> I want to pattern match (to a Char) on the first byte of a ByteString, how do I do that?
10:45:49 <shapr> Plus I want to do it now, not after implementing a Char typeclass =)
10:45:50 <vincenz> shapr: very carefullly
10:45:58 * shapr smacks vincenz with a trout
10:46:01 <vincenz> :D
10:46:11 * vincenz retaliates with a recursive tail
10:46:16 <Lokadin> lol
10:46:30 <Cale> shapr: extract the first char and use case
10:46:31 <vincenz> feel that endless whip fix'ing your face
10:46:52 * vincenz cough
10:47:15 <ADEpt> vincenz: now we all see that co-authoring a paper is all hard work and no fun ;)
10:47:23 <Lokadin> lol
10:47:41 <vincenz> ADEpt: yeah
10:47:48 <Cale> head :: ByteString -> Char
10:47:51 <shapr> Cale: Data.ByteString.Char8.head ?
10:47:52 * vincenz had a cool idea for another thing to explore today
10:47:55 <shapr> ah
10:47:57 <Cale> yep
10:47:57 <shapr> Cale: thanks!
10:48:11 <Lokadin> vincenz: what was that?
10:48:29 * vincenz ponders
10:48:38 <vincenz> the theoretical minimum storage requirement of an application
10:49:06 <vincenz> I bet it's calculatable
10:49:24 <Lokadin> vincenz: what would you consider an application? or do you mean a program like hello world?
10:49:37 <vincenz> a program
10:49:42 <vincenz> but preferably something bigger than hello world
10:49:46 <vincenz> like a video codec
10:49:48 <vincenz> or a 3d gam
10:50:04 * vincenz works on optimizations of embedded multimedia software
10:50:30 <vincenz> on that note, anyone know some good open sources that I could use as drivers that tend to use dynamic data structures?
10:50:48 <vincenz> I looked at UT and quake and such, but they're all lowlevel optimized c and assembly
10:51:49 * vincenz peers at the silence and sighs and leaves for dinner
10:51:58 <vincenz> looking for drivers is worse than looking for related work
10:52:00 * vincenz mutters
10:52:14 <Lokadin> lol
10:52:45 <vincenz> and anyone in academia will tell you that the related work section of any pape ris the biggest pain
10:53:01 <shapr> How so?
10:53:19 <vincenz> shapr: it's the most time consuming part to write
10:53:30 <vincenz> and the most time consuming to validate during a review
10:53:39 <jip> what happens if i omit a field during construction of a record?
10:53:49 <vincenz> anyways I'm off... or I'll be late for my dinner appt, bbl!
10:53:55 <Lokadin> vincenz: later
10:53:56 <sjanssen_> jip: the field is filled with bottom
10:54:05 <Cale> Related Work: http://www.google.com
10:54:06 <Cale> hehe
10:54:11 <Lokadin> lol :)
10:54:15 <jip> Cale: what happens?
10:54:19 <xerox> Uh? :)
10:54:40 <Cale> hi xerox 
10:54:45 <xerox> Hello Cale.
10:54:47 <Cale> have you seen my puzzle?
10:54:50 <xerox> Nope!
10:54:57 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles
10:55:03 * xerox jumps up and down, puzzle puzzle puzzle!
10:55:11 <shapr> What's the difference between Data.ByteString and Data.ByteString.Char8 ?
10:55:50 <Cale> ByteString works on Word8's
10:56:16 <xerox> http://haskell.galois.com/~paolo/tmp/HaskellSoC.text -- do you think I should mention anything else?
10:56:21 <Cale> ByteString.Char8 is a thin candy shell around that which works on Chars in the 0-255 range
10:56:24 <xerox> For the HCAR entry, that is.
10:56:37 <shapr> Should I consistently use the same type whether Char8 or ByteString?
10:56:41 <shapr> Seems likely...
10:56:58 <Cale> Well, it's likely one will be more convenient.
10:57:32 <shapr> I replaced all the FastPackedString imports with ByteString in Conjure, but anything that wants to match with a Char is unhappy.
10:57:37 <sjanssen_> shapr: they're the same type
10:58:12 <sjanssen_> Char8 re-exports the same ByteString
10:58:19 <shapr> So, is there something that casts a Word8 to Char?
10:58:25 <defcon8> what is monad?
10:58:31 <shapr> It's an abstraction.
10:58:32 <TuringTest> Cale: Does your puzzle have a unique solution?
10:58:57 <shapr> defcon8: Monads are an abstraction like objects, they let you focus on just one part of the code at a time.
10:59:07 <defcon8> can you give an example?
10:59:31 <shapr> Yeah, you can replace nested if-then-else statements with a pipeline that checks for failure.
10:59:46 <shapr> data Maybe a = Just a | Nothing
11:00:34 <shapr> Then when you define the monad instance, >>= works like Nothing >>= f = Nothing ; (Just a) >>= f = f a
11:01:08 <shapr> defcon8: Clear enough?
11:01:22 <shapr> If you want lots more detail, check out http://www.nomaware.com/monads/html/index.html
11:02:06 <jip> what is arrow?
11:02:28 <shapr> It's an abstraction much like a monad, but it works more like a first class transformer.
11:02:37 <sjanssen_> shapr: you probably want to just change your import from FPS to Data.ByteString.Char8
11:02:50 <shapr> Thanks, I'll try that.
11:02:52 <jip> can i replace nested if-then-else statements with an arrow pipeline that checks for failure?
11:02:56 <shapr> Yeah, you can.
11:02:59 <jip> what does Maybe as an arrow look like?
11:03:11 <shapr> Looks pretty much the same.
11:03:15 <Saulzar_> You can transform a monad into an arrow
11:03:26 <shapr> But not all arrows are monads.
11:03:37 <dcoutts_> in fact that's rather the point
11:03:52 <shapr> This was discovered long ago by Swierstra & Duponcheel.
11:04:05 <sjanssen_> Maybe doesn't have the correct kind to be an arrow
11:04:26 <xerox> Cale: the wiki is great :)
11:05:54 <Saulzar_> shapr: Re: Haskell pygame, I think much of the haven/fruit design would be great for such a thing. The trick would be making collections easy (which can interact).
11:06:21 <defcon8> shapr, no
11:06:40 <defcon8> i think ill just read the tutorial
11:06:48 <shapr> defcon8: Do you understand how "data Maybe a = Just a | Nothing" represents failure or a result?
11:06:58 <defcon8> does haskell have such a thing is an image manipulation library?
11:06:59 <dcoutts_> xerox, I'd change "A big number of very cool people volunteered for the various roles needed." / "Many community members volunteered for the organising and mentoring roles needed."
11:07:05 <shapr> Saulzar_: Can't yampa's collection arrows already do that?
11:07:12 <shapr> defcon8: Yes, several.
11:07:12 <defcon8> shapr, dont worry ill learn it myself
11:07:21 <shapr> defcon8: Ok, feel free to ask questions.
11:07:27 <defcon8> just i want to experiment a bit with cellular automata
11:07:28 <defcon8> cheers
11:07:56 <Saulzar_> shapr, Sure. I think they can use some higher level wraping though.
11:08:29 <xerox> Okay.
11:08:37 <shapr> I agree, I just have no clue how to approach such a wrapping :-)
11:09:05 <xerox> Cale: you should provide an interactive interface for the puzzles! (-:
11:09:43 <Saulzar_> I like the way fruit does it - a widget has no "position", but at each level there are transformations into/out of.
11:09:59 <shapr> Poo, ByteString.Char8 doesn't have fromForeignPtr
11:10:21 <Saulzar_> In a Yampa game, if you give each object the responsibility of maintaining it's state entirely - eg. it's position, rotation etc. Making objects interact is hard work.
11:10:26 <eivuokko> shapr, Isn't constructor exported?
11:10:44 <sjanssen_> shapr: that operation is in Data.ByteString
11:11:10 <Saulzar_> In fact the only way you can do so is by passing messages in and out, but then you get bitten badly by the delay that takes
11:11:13 <jip> Saulzar_: did you see my yampa interactive 3d car sim?
11:11:28 <Saulzar_> jip, Yeah
11:11:52 <Saulzar_> jip, What approach did you take there?
11:12:30 <shapr> sjanssen_: Any reason Char8 doesn't match ByteString exactly?
11:12:36 <jip> Saulzar_: i coded most of the physics logic as (CarState -> CarState) functions and then i just wrapped a yampa arrow around it :|
11:12:42 <Saulzar_> To do something like collision reaction properly, you need to have something which integrates multiple objects "simultaneously"
11:12:53 <jip> Saulzar_: yeah, i also did a yampa tetris
11:13:12 <jip> Saulzar_: which sort of benefitted from the arrow stuff
11:13:19 <shapr> Is your code online?
11:13:31 <jip> shapr: not really, but maybe i'll put it online tonight
11:13:39 <shapr> Hm, what happened to indexWord8 ?
11:13:47 <Philippa_> Saulzar_: at that point, I'm not convinced you gain much from the arrow-based system any more. A more conventional-looking setup (albeit implemented haskell-style) seems more sensible
11:14:05 <jip> the cool thing about the tetris, is that i was able to build the behaviour of a single falling brick as a single component
11:14:09 <sjanssen_> shapr: the only operations that are in Char8 are those that have 'Char' in the type somewhere, Char8 is just a wrapper to ByteString that does the char/wor8 conversions for you
11:14:24 <shapr> sjanssen_: thanks
11:14:27 <jip> then i was able to make bricks fall one after the other by composing this componet recursively
11:14:33 <jip> so it was very functional style :)
11:15:06 <shapr> Philippa_: I'd like to see some prototypes compared.
11:15:25 <shapr> Philippa_: What sort of more conventional-looking setup?
11:15:27 <Philippa_> shapr: I'd like to have the energy to write some. Life as usual, I guess
11:15:29 <shapr> heh
11:15:38 <Saulzar_> I've been frustrated trying to make this AI game, it all works but it's ugly as dirt right now. I think with some careful thought something much better can be crafted
11:15:46 <Philippa_> um. Ideas akin to, say, implementing UnrealScript as an EDSL
11:15:51 <Lokadin> say does anyone know what {-# LINE 333 "Curses.hsc" #-} means?
11:16:13 <Lokadin> does it do anything? or is it just a comment?
11:16:21 <shapr> Lokadin: It means that Curses.hs was generated automatically from Curses.hsc
11:16:25 <shapr> using hsc2hs
11:16:29 <Lokadin> oh
11:16:34 <Lokadin> thanks :)
11:16:45 <jip> back when i was working with yampa, i did a lot of thinking about how it could be used as a scripting language for a game engine
11:16:48 <eivuokko> ghc uses those comments to show correct error messages that refer to curses.hsc nor curses.hs
11:16:55 <shapr> jip: Came up with anything interesting?
11:16:56 <waern> jip, any url for that car sim thing?
11:17:11 <jip> waern: just a screenshot
11:17:17 <shapr> hiya stepcut 
11:17:44 * shapr pretends to be able to read some crazy conjure code
11:17:49 <waern> jip, where? :)
11:18:04 <the_lord> Hi! does someone remember my problem?
11:18:37 <TuringTest> the_lord: You are trying to learn Haskell + Alex without enough time?
11:18:49 <Lokadin> shapr: is hsc2hs part of ghc? or is it a seperate package?
11:19:14 <the_lord> TuringTest, indeed
11:19:35 <Lokadin> shapr: nm i hoogled it
11:19:39 <the_lord> TuringTest, did I tell you what the teacher told me
11:19:47 <Lokadin> bah g2g pick up my lil bro
11:20:24 <stepcut> hiya shapr
11:20:41 <TuringTest> the_lord: It will not help -- I never took a course on this.
11:21:03 <mgoetze> good evening
11:21:17 <jip> waern: http://img145.imageshack.us/img145/7513/drivedrive0020dn.png
11:21:33 <the_lord> he told me that I should redirect the errors so I dont have to return a Token
11:21:50 <the_lord> but alex expects that the function return Token
11:22:06 <the_lord> there's the tricky part, he said
11:25:01 <jip> waern: and here's the tetris :D http://img220.imageshack.us/img220/5016/hstetris0014es.png
11:25:22 <TuringTest> the_lord: Does your program abort and quit when an error is encountered, or does it try to recover somehow?
11:25:45 <the_lord> I wish I could abort\
11:25:56 <the_lord> I have to look for all lexical errors
11:26:18 <the_lord> If i could abort, I could simply use "error"
11:27:15 <TuringTest> Alex has different interfaces, which are you using?
11:27:48 <the_lord> posn
11:27:54 <the_lord> and I have to use posn
11:29:24 <TuringTest> So Alex generates code like in section 5.2.2  of http://www.haskell.org/alex/doc/html/wrappers.html ?
11:29:57 <the_lord> yep
11:30:12 <TuringTest> Are you looking for "all valid tokens and all lexical errors" or just "all lexical errors" ?
11:30:36 <the_lord> everything
11:30:46 <the_lord> see, alex returns a [Token]
11:30:56 <the_lord> I have to return a [Token]
11:31:11 <the_lord> and print all lexical errors
11:31:46 <TuringTest> the_lord:  So you need to replace the "error ..." expression.
11:32:11 <the_lord> nope, that aborts
11:32:35 <TuringTest> What?
11:33:01 <the_lord> TuringTest, sorry, you say something like this?
11:33:15 <Saulzar_> Yes, as it is error will abort - replace it and you can change what is returned.
11:33:38 <the_lord> AlexError _ -> print "there's your error you moth****er"
11:33:41 <the_lord> ???
11:33:41 <lambdabot> Maybe you meant: . id pl v wn
11:34:44 <Igloo> the_lord: Can't alex work in an arbitrary monad? That's probably what you want
11:35:16 <TuringTest> Igloo: the_lord claims his teacher is forcing him to use the posn interface to solve this instead of the smart way.
11:35:55 <the_lord> TuringTest, in fact my teacher told me I didn't need to override that function
11:36:02 <the_lord> BUT, I'll do it
11:36:56 <the_lord> how do I override alexScanTokens?
11:37:01 <TuringTest> the_lord: The problem, as you present it here, does not look correct.
11:37:29 <TuringTest> the_lord: I have never used Alex, I merely looked at that web page.
11:37:34 <TuringTest> So I Do Not Know
11:39:03 <TuringTest> But I would guess "override" is accomplished by "editing the code that Alex generates"
11:40:05 <TuringTest> But if you were told not to edit the generated code...then I think you have misunderstood something about the assignment and you need to talk to other students or teaching staff.
11:44:22 * TuringTest leaves for dinner
11:47:10 <jip> i do i generate a [(Double, Double)] that forms a circle around the origin with radius r?
11:47:22 <jip> n length
11:47:28 <shapr> Was packWords the old name of pack :: [Word8] -> ByteString ?
11:47:32 <shapr> @hoogle packWords
11:47:33 <lambdabot> No matches found
11:49:52 <shapr> Sure looks like it.
11:53:22 <stepcut> anyone know of a pretty-print/AST library for generating GNU Makefiles ?
11:53:58 <ADEpt> stepcut: i doubt that such thing exists
11:54:13 <shapr> stepcut: Have you reimplemented any amount of apt in Haskell?
11:54:54 <shapr> Eelco Dolstra's maak is a pure Haskell make replacement using DAGs.
11:55:03 <stepcut> shapr: regarding apt, yes, some in haskell, some in ocaml
11:55:23 <stepcut> shapr: Though, there is still a lot that apt does that I do not
11:55:40 <shapr> What do you think about the fat-client thin-server approach? Do you think it would make more sense to have a smart server and a dumb client?
11:56:36 <stepcut> shapr: apt does not even really have a server
11:57:49 <stepcut> shapr: I am not really sure what would be gained by having a smart server
11:58:01 <shapr> Clients would be simpler and easier to implement.
11:58:11 <shapr> Apt is often considered complex and scary.
11:58:45 <shapr> Do you think that would be a benefit?
11:59:23 <sethk> vim has indentation for gnu makefiles, if that is of any use
11:59:24 <Igloo> Once you have a smart module it should be easy enough to make both client and server smart, just in the latter case you need more protocol
11:59:26 <stepcut> What apt really needs is a good stand-alone library version and general purpose dependency library 
11:59:57 <stepcut> apt is scary and complex because it is written in C++ :p
12:00:01 * shapr grins
12:00:02 <stepcut> and undocumented
12:00:30 <stepcut> well, the policy documents what it is supposed to do, but what it actually does is not quite the same
12:00:38 <kep> re
12:00:38 <stepcut> and it has magic like the ~ operator
12:00:57 * shapr doesn't know what that does
12:01:57 <stepcut> operator is not really the right word. You can have version numbers with ~ in them. 1.0~1 is less that 1.0, but greater than 0.99999999999999<etc>
12:02:33 <shapr> It does sound like a general purpose dependency library would help.
12:02:56 <davidhouse> err, 0.999... = 1.0 :S
12:03:11 <Igloo> ~ isn't magic
12:03:11 <stepcut> davidhouse: not in debian it doesn't ;)
12:03:30 <stepcut> Igloo: s/magic/not in debian policy manual as far as I can tell/
12:04:14 <Igloo> If that's so it's because the policy editors have an odd policy; I'm sure it's specified somewhere, and will be in the manual when the Debian archive accepts versions containing ~
12:04:26 <davidhouse> stepcut: well, what else could go in the middle?
12:04:46 <stepcut> davidhouse: 1.0~
12:05:05 <davidhouse> ah, i see.
12:05:30 <davidhouse> i thought the ~ operator matched version numbers in that range. i didn't realise it actually formed part of a version number.
12:05:51 <stepcut> yeah, its part of the version number
12:06:33 <stepcut> and it is odd because it is the only character than you can append to a version to make the version number lower
12:07:20 <vincenz> re
12:07:20 <vincenz> re
12:07:59 <stepcut> It can be used to do things like: 1.0~rc1 < 1.0~rc2 < 1.0
12:10:30 <davidhouse> ah, clever.
12:11:23 <stepcut> shapr: in any case, I think a good set up libraries would solve most problems. Apt can install from local directories, cdroms, etc. And many people put debs on shared web servers where they do not have the authority to run a smart server. Seems best to make the client smart and use plugins for accessing the different media that hold the debs (and, indeed that is how apt does it)
12:13:06 * stepcut goes to make lunch
12:14:52 <davidhouse> i'm writing an application for which portability is fairly key (mostly to other archs/OSs, not necessarily to other compilers). i want to make some GET and POST requests that should simple enough.
12:15:13 <davidhouse> would people recommend i use the haskell HTTP library with all its nasty deps or just craft my own out of Network?
12:15:46 <BetaTEST> hi! would you help me with making ghc/ghci "show" cyrillic characters?
12:16:07 <BetaTEST> it displays them as '\238' etc
12:18:33 <dcoutts_> BetaTEST, sorry, ghc doesn't do unicode yet, it will do in the next version.
12:19:13 <BetaTEST> it's not even unicode :(
12:19:13 <palomer> it doesn't?
12:19:31 <palomer> oh, it doesn't show them
12:19:31 <dcoutts_> (or rather it does handle unicode, just not in string literals or IO functions)
12:20:02 <the_lord> @type error
12:20:03 <lambdabot> forall a. [Char] -> a
12:20:06 <dcoutts_> > chr 238
12:20:08 <lambdabot> '\238'
12:20:13 <dcoutts_> > chr 127
12:20:14 <lambdabot> '\DEL'
12:20:37 <the_lord> what's the typr of the error function?
12:20:43 <the_lord> *type
12:20:43 <dcoutts_> @type error
12:20:44 <lambdabot> forall a. [Char] -> a
12:21:22 <davidhouse> any ideas about my HTTP question?
12:21:32 <BetaTEST> does hugs support unicode or "not-latin" characters?
12:22:19 <dcoutts_> BetaTEST, the show function for Char/String does this escape encoding for chars > 127
12:22:42 <dcoutts_> BetaTEST, try putStr "\238"
12:23:07 <dcoutts_> davidhouse, try the new slimed down http lib, it doesn't depend on crypto anymore
12:23:16 <BetaTEST> it works :) the thing you told me about >127 is written in Haskell 98?
12:23:28 <dcoutts_> BetaTEST, yes
12:24:43 <kzm_> BetaTEST what exactly do you need?
12:24:56 <davidhouse> dcoutts_, where's that?
12:25:06 <kzm_> Not sure it is possible to override the default Show instances for String and Char...
12:25:08 <BetaTEST> [('\238',"111"),('\241',"1101"),('\247',"110011"),('\227',"110010"),...]
12:25:14 <dcoutts_> davidhouse, try the same place, otherwise ask shapr 
12:25:19 <BetaTEST> i want that to be printed in russian :)
12:25:34 <kzm_> ...but you can use ByteStrings to output differently-encoded text.
12:25:57 <davidhouse> the HTTP page links to a "simple bundle of all the necessary modules", that might be it
12:26:12 <shapr> davidhouse: The darcs version of HTTP no longer requires crypto.
12:26:21 <BetaTEST> looks like i will just use perl for post-processing
12:26:51 <davidhouse> shapr, is it stable?
12:27:12 <palomer> I dreamt that I was using yi
12:27:13 <palomer> no kidding
12:27:37 <sjanssen_> BetaTEST: you can make a newtype of String that has a different instance for Show
12:27:47 * vincenz had a freaky experience last night....
12:28:01 <vincenz> the start of an REM cycle while being conscious
12:28:15 <vincenz> my body instinctively panicked as my heart raced to twice it's speed in less than a minute
12:28:18 <BetaTEST> my program has just 7 lines, i dont want to make it uglier just because cyrillic is not supported yet :)
12:28:49 <shapr> davidhouse: Yeah, Bringert is maintaining HTTP.
12:29:00 <dcoutts_> BetaTEST, of course if you print the chars out then it's ok
12:29:01 <sjanssen_> BetaTEST: cyrillic is supported, it's just that certain characters are supposed to show up as control codes
12:29:25 <kzm_> BetaTEST, are you using UTF8?
12:29:40 <dcoutts_> ie even though ghci shows them as control codes when you 'show' them, doesn't stop your prog from outputting whatever bytes you like
12:29:47 <vincenz> hey
12:29:50 <vincenz> what's the verb for 'thought'
12:29:56 <pjd> think?
12:30:03 <vincenz> it has been "thought" specifically for this purpose
12:30:06 <vincenz> not quite designed but...
12:30:16 <pjd> thunk?
12:30:21 <dcoutts_> hah
12:30:21 <vincenz> designed is more for software, but when it's a methodology it's.... conceptualized?
12:30:29 <sjanssen_> conceived?
12:30:32 <vincenz> sjanssen_: thanks
12:30:33 <davidhouse> shapr, thanks.
12:30:39 <BetaTEST> kzm_, cp1251. when ghc sees utf it screams something about incorrect symbols
12:30:48 <pjd> invented?
12:30:48 <shapr> davidhouse: Bringert writes really good code.
12:30:55 <vincenz> no...won't due
12:30:58 <vincenz> conceived for any xxx 
12:31:01 <vincenz> doesn't sound right
12:31:20 <dcoutts_> BetaTEST, so you'll be fine, just avoid using show, output to the terminal/file instead
12:31:33 <vincenz> dcoutts_: any suggestions?
12:31:45 <dcoutts_> BetaTEST, besides show adds " chars around your string too, which you don't want for presentation purposes.
12:32:01 <vincenz> "All these proposals are very relevant for XXX where the YYY can still be changed, while our work is 'thought' for any fixed ZZZZ, ..."
12:32:14 <BetaTEST> well, i didn't need presentation actually. just ability to read symbols :)
12:32:28 <pjd> vincenz: designed, it sonuds like
12:32:31 <dcoutts_> BetaTEST, the point of the show function is more to show a value in a form that is suitable to use again as Haskell code which is why it has the string encoding
12:32:34 <pjd> sounds, even
12:32:37 <vincenz> pjd: designed is more for software, it's a methodology
12:32:37 <BetaTEST> but perl program with 4 lines saved me :)
12:32:46 <pjd> methodologies get designed too :)
12:32:51 <pjd> and cars, and toasters
12:32:55 <vincenz> ...
12:33:03 <vincenz> it's research... designed is more alpha work, not prealph
12:33:10 <pjd> "contrived"?
12:33:12 <pjd> heh
12:33:22 <vincenz> it's a toss between designed and conceived
12:33:23 <pjd> vincenz: i don't think the word is that narrow
12:33:23 <jyp> vincenz: cooked
12:33:25 <jyp> :)
12:33:27 <pjd> it's pretty general
12:33:32 <vincenz> alrightt
12:33:39 <vincenz> thought just sounds wrong
12:33:40 <pjd> "planned"?
12:33:53 <pjd> "intended"?
12:33:58 <vincenz> oooh
12:34:01 <pjd> "created"?
12:34:10 <pjd> "meant"?
12:34:12 <vincenz> intended sounds good
12:34:26 <dcoutts_> BetaTEST, so what is your example that doesn't work now?
12:34:55 <BetaTEST> it does work, just '\238' is not what i want..
12:35:10 <BetaTEST> problem solved, i converted everything using perl :)
12:35:47 <dcoutts_> well ok, but I was heoping we could sove this for next time you run into this issue
12:35:58 <dcoutts_> I think it will work fine
12:36:33 <dcoutts_> basicly by using 'putStr' rather than 'print'
12:36:54 <BetaTEST> putStr can't print [(Char, [Char])]
12:37:08 <shapr> So, does anyone else here use LinkedIn?
12:37:46 <xerox> shapr: do you think it is worth using?
12:38:59 <shapr> I don't know for certain. John Hughes is on it, and asked to connect to me.
12:39:34 <dcoutts_> BetaTEST, true.
12:39:57 <dcoutts_> you'd have to convert [(Char, [Char])] -> String first
12:39:58 <dcoutts_> ho hum
12:40:22 <vincenz> dcoutts_: 'divided into' right?
12:40:33 <dcoutts_> what?
12:40:41 <vincenz> xxx is divided into yyy and zzz
12:40:55 <dcoutts_> I've no idea what you're talking about
12:40:59 <vincenz> english
12:41:50 <BetaTEST> dcoutts_, i've got the point :)
12:42:23 <dcoutts_> BetaTEST, sadly that's not going to be supported for other charsets unless the language definition is changed because we can't make the encoding depend on the locale because that's not pure
12:42:31 * dcoutts_ shuts up
12:42:37 <shapr> xerox: Are you on LinkedIn?
12:43:02 <xerox> Nope, I don't exactly see the point of these "eyecandy web services."
12:43:53 <BetaTEST> dcoutts_, that's understandable... especially for computers with just couple of code pages :)
12:44:52 <dcoutts_> they might change it to utf8 some time
12:45:09 <BetaTEST> would be great :)
12:45:22 <davidhouse> @hoogle exitFailure
12:45:22 <lambdabot> System.exitFailure :: IO a
12:45:22 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
12:45:39 <dcoutts_> but that's a language spec thing rather than a ghc feature
12:46:41 <BetaTEST> probably it's good time to write a petition...
12:47:07 <BetaTEST> well, anyway, it's solvable. just additional couple of lines of code..
12:47:08 <davidhouse> am i the only one who always misspells buffering as buggering?
12:47:40 <stepcut> davidhouse: I was going to say that f and g are not next to each other on dvorak -- except they are :-/
12:48:28 <davidhouse> heh
12:48:46 <monochrom> In the 22nd Century, we will meet an outerspace race, let's call them ETs.  The ETs use radix 16.  (We use 10.)  The new Haskell standard will seem have a problem: "show" for numbers will depend on locales, namely, in the Earth locale it should use base 10, and in the ET locale it should use base 16.
12:49:14 <monochrom> Fortunately, that problem has already been solved in the 20th Century.  There is Numerics.showIntAtBase.
12:49:23 <stepcut> :p
12:50:01 <davidhouse> that's a load off my mind, monochrom.
12:51:26 <monochrom> A typical newbie CS student in the 22nd Century will complain, "why doesn't 'show' output in *my* base?"  The answer, true though it sounds smartass, is: "there are so many functions satisfying Int->String, we have to pick one for 'show', and surely one single choice can't please everybody."
12:52:21 <Cale> Oops, for anyone working on my puzzle -- there was an important clue missing which caused the solution to be ambiguous. The problem's fixed now ;)
12:52:28 <monochrom> But anyway.  Thus, to "show" a string in a locale-specific manner, perhaps you can borrow ideas from Numerics.showIntAtBase.
12:52:32 <stepcut> monochrom: http://www.eecs.harvard.edu/~ccshan/prepose/prepose.pdf
12:52:34 <mauke> expectation-based overloading: the DWIM class
12:52:38 <davidhouse> Cale, puzzle?
12:52:46 <monochrom> what's that for, stepcut?
12:52:56 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles
12:53:17 <davidhouse> hey xerox
12:53:18 <stepcut> monochrom: a method for picking your 'show' base (though, in their example, they are picking the modulo value) 
12:53:19 <stepcut> :p
12:53:52 <the_lord> Hi again
12:54:09 <xerox> Hey there.
12:56:35 <monochrom> Hmm, so we can do a similar thing for locales like (Show a, Locale s a) => a -> String ?
12:56:40 <the_lord> I want to make a function that returns nothing, is it possible?
12:56:53 <dcoutts_> @type \_ -> ()
12:56:55 <lambdabot> forall t. t -> ()
12:57:02 <mauke> the_lord: no
12:57:10 <dcoutts_> in the sense that () represents nothing :-)
12:57:11 <monochrom> It will not look too bad, it seems.
12:57:16 <mauke> every function returns a value
12:57:24 <jip> @type \_ -> error "nothing"
12:57:25 <lambdabot> forall a t. t -> a
12:57:27 <monochrom> It is a bit more convenient than showIntAtBase.
12:57:28 <mauke> yeah, ok
12:57:38 <palomer> oh boy, I have to implement the substitution combinator
12:57:38 <palomer> ugh.
12:57:42 <mauke> some functions don't return :-)
12:58:15 <dcoutts_> the_lord, you can make a function never returns if that helps, otherwise it must return a value
12:58:31 <dcoutts_> though that value can mean nothing and be discarded, eg ()
12:58:35 <the_lord> how do I do that?
12:58:44 <dcoutts_> > ()
12:58:45 <lambdabot> ()
12:59:13 <monochrom> > (\x -> ()) "hello"
12:59:14 <lambdabot> ()
12:59:17 <mauke> what use is a function that returns ()?
12:59:25 <dcoutts_> not much :-)
12:59:30 <monochrom> (\x -> ()) is a function that returns ().
12:59:45 <ldas> hello
12:59:45 <ldas> is there a regex library that I could use?
12:59:57 <dcoutts_> the_lord, you probably don't really want a function that returns nothing because it would not have much point
13:00:18 <monochrom> "returns nothing" is ambiguous, to be honest.
13:00:27 <dcoutts_> the_lord, why do you want a function that returns nothing?
13:00:34 <the_lord> isn't there any super type
13:00:38 <dcoutts_> > (\_ -> Nothing) ()
13:00:39 <lambdabot> Add a type signature
13:00:46 <the_lord> kinda the one error returns?
13:00:49 <sjanssen_> > return Nothing :: Maybe (Maybe Int)
13:00:50 <lambdabot> Just Nothing
13:00:55 <davidhouse> Idas, either Text.Regex or try googling for JRegex
13:01:06 <monochrom> To mince more words, let's debate whether "f :: Int -> Int; f x = f x" returns an int or not.
13:01:08 <dcoutts_> the_lord, you can use the error function if that's what you mean
13:01:16 <davidhouse> > (\_ -> Nothing) () :: Maybe Int -- it needs to know what type it's holding
13:01:17 <lambdabot> Nothing
13:01:28 <dcoutts_> monochrom, sure it does, it returns _|_ :: Int
13:01:28 <monochrom> There is no supertype.
13:01:56 <monochrom> Please direct the debate to the Mr. Speaker. :)
13:02:02 <dcoutts_> heh :-)
13:03:02 <monochrom> "error" does not return a supertype.  Rather, "error" is polymorphic.
13:03:34 <monochrom> err sorry "polymorphic" is ambiguous too.  I mean "parametrically polymorphic".
13:04:26 <Cale> davidhouse: what do you think of the puzzle idea?
13:04:49 <davidhouse> Cale, it looks fun :)
13:04:55 <the_lord> dcoutts_, cant do it, error aborts
13:04:56 <ADEpt> Cale: which puzzle?
13:05:02 <dcoutts_> the_lord, yes
13:05:06 <the_lord> I don't want to abort
13:05:15 <dcoutts_> the_lord, you'll have to explain what you want
13:05:19 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles
13:05:27 * shapr is tempted to say something like "Lord have mercy chile"
13:05:28 <davidhouse> Cale, a nice idea would be to give some examples of small puzzles with sample solutions, so people can get a couple of tactics under their belts.
13:05:40 <the_lord> where do I paste?
13:05:42 <davidhouse> it's hard to start out at something you don't know how to approach.
13:05:50 <davidhouse> @where past
13:05:50 <lambdabot> I know nothing about past.
13:05:52 <davidhouse> @where paste
13:05:53 <monochrom> I think the requirements that (1) type String->[Token]  (2) must report error details  (3) must not abort   are inconsistent.
13:06:00 <lambdabot> http://paste.lisp.org/new/haskell
13:06:05 <dcoutts_> the_lord, or try explaining, we don't necessarily need to see code
13:06:31 <Cale> davidhouse: yeah, I should probably describe the solution to that sample puzzle
13:06:32 <monochrom> code is the last thing any human wants to see.
13:06:33 <the_lord> dcoutts, have you ever used alex?
13:06:38 <dcoutts_> yep
13:07:30 <monochrom> I think whoever specified those requirements is crazy.
13:07:30 <davidhouse> Cale, have you written a solver? presumably those puzzles were generated by something?
13:07:38 <Cale> no, I generated these by hand
13:07:43 <davidhouse> ah
13:08:02 <davidhouse> would make an interesting problem.
13:08:11 <davidhouse> not least because of the challenge of encoding that little pictogram
13:08:20 <lisppaste2> the_lord pasted "ALEX" at http://paste.lisp.org/display/20048
13:08:52 <sjanssen_> @djinn IO a -> a
13:08:52 <lambdabot> f = unsafePerformIO
13:09:32 <shapr> @YOW!
13:09:32 <lambdabot> Unknown command, try @list
13:09:37 * shapr smacks lambdabot 
13:09:41 <mauke> @zow
13:09:41 <lambdabot> Can you MAIL a BEAN CAKE?
13:10:19 <the_lord> monochrom, indeed he is crazy but he did it
13:11:55 <the_lord> monochrom, he said something like the function must redirect so it doesn't have to return anything
13:11:55 <dcoutts_> the_lord, perhaps you could have an error token
13:11:56 <davidhouse> eurgh.
13:12:02 <davidhouse> what can cause a segfault?
13:12:02 <the_lord> I do have it
13:12:08 <the_lord> it's Boom
13:12:17 <davidhouse> i'm not using anything like unsafePerformIO
13:12:26 <the_lord> davidhouse, programming in C
13:12:28 <davidhouse> there were no compiletime errors
13:12:37 <monochrom> In your Token type, because there is a case "Boom", it can be used to store errors.  I am sure the comment says that too.
13:12:51 <dcoutts_> the_lord, then use that. Is there any problem with that?
13:12:53 <davidhouse> i'm not really using anything funky at all (no FFI, etc). just using Network.HTTP
13:13:24 <the_lord> it "stores" the error, it doesn't show them
13:13:41 <the_lord> I need to show them
13:13:54 <monochrom> What is meant by "show them"?
13:14:35 <monochrom> As far as I am concerned, these two facts together already prints out errors to my satisfaction.
13:14:36 <akyto-> how can I use List.sortBy on a List of [String]
13:14:57 <davidhouse> it sorts alphabetically.
13:15:00 <monochrom> 1. the Token type, which has the Boom case, is deriving Show
13:15:07 <the_lord> print "lexical error " ++ extraerPos p
13:15:17 <davidhouse> akyto-: what do you want to do?
13:15:20 <ADEpt> the_lord: right now your Boom stores one item. Make it store a list. Print list after parsing. Bingo!
13:15:21 <monochrom> 2. eventually you do "print (alexScanTokens s)".
13:15:22 <davidhouse> akyto-: just sort a list of strings?
13:15:27 <akyto-> yes
13:15:36 <akyto-> but don't know with which ordering
13:15:37 <davidhouse> > sort ["hello", "world", "aaa", "zzz"]
13:15:37 <lambdabot> ["aaa","hello","world","zzz"]
13:15:44 <the_lord> ADEpt, that approach is not good
13:15:44 <davidhouse> that's alphabetical
13:15:50 <akyto-> ah, just use sort
13:15:56 <akyto-> that was easy ...
13:16:05 <davidhouse> > sortBy compare ["hello", "world", "aaa", "zzz"]
13:16:05 <lambdabot> ["aaa","hello","world","zzz"]
13:16:14 <the_lord> ADEpt, it has to be on the fly
13:16:16 <davidhouse> that would also work, as String is an instance of Ord
13:16:22 <davidhouse> and thus has compare defined on it
13:16:28 <davidhouse> but sort is cleaner.
13:17:04 <the_lord> @list
13:17:05 <lambdabot> list [module|command]. Where modules is one of:
13:17:05 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
13:17:05 <lambdabot> version vixen where
13:25:09 <xerox> monochrom: your piece on intuition is very profound.
13:25:28 <monochrom> Thank you very much.  Glad you like it.
13:28:32 <lisppaste2> monochrom annotated #20048 with "Boom handling" at http://paste.lisp.org/display/20048#1
13:28:43 <monochrom> That is for the_lord
13:28:51 <stepcut> make is scary
13:28:54 <sjanssen_> I've added these definitions to Djinn: "data List a" and "foldr :: (a -> b -> b) -> b -> List a -> b".  Why can't Djinn figure this out:
13:29:04 <sjanssen_> @djinn List (Maybe a) -> Maybe a
13:29:05 <lambdabot> f = void
13:29:11 <davidhouse> @djinn-env
13:29:11 <lambdabot> data () = ()
13:29:12 <lambdabot> data Either a b = Left a | Right b
13:29:12 <lambdabot> data Maybe a = Nothing | Just a
13:29:12 <lambdabot> data Bool = False | True
13:29:12 <lambdabot> data Void
13:29:13 <lambdabot> type Not x = x -> Void
13:29:16 <lambdabot> data List a
13:29:18 <lambdabot> foldr :: (a -> b -> b) -> b -> List a -> b
13:30:12 <davidhouse> shouldn't that be data List a = Nil | Cons a (List a)?
13:30:23 <sjanssen_> davidhouse: djinn can't do recursive definitions
13:30:31 <the_lord> monochrom, that's not on the fly
13:30:51 <davidhouse> @djinn List a
13:30:51 <lambdabot> -- f cannot be realized.
13:31:03 <davidhouse> sjanssen_: then it's a bit limited
13:31:12 <davidhouse> @djinn Bool -> List a
13:31:13 <lambdabot> -- f cannot be realized.
13:31:21 <davidhouse> @djinn Bool -> List Bool
13:31:21 <lambdabot> -- f cannot be realized.
13:31:22 <sjanssen_> @djinn-add null :: List a
13:31:29 <sjanssen_> @djinn List a
13:31:29 <lambdabot> f = null
13:31:49 <davidhouse> @djinn-add cons :: a -> List a  -> List a
13:31:56 <davidhouse> @djinn List a
13:31:56 <lambdabot> f = void null
13:32:00 <sjanssen_> davidhouse: don't add head
13:32:12 <davidhouse> argh. i broke it.
13:32:17 <sjanssen_> @djinn-del cons
13:32:50 <sjanssen_> @djinn (a -> b) -> List a -> List b
13:32:50 <lambdabot> f = void null
13:32:54 <shapr> stepcut: I have a copy of Eelco Dolstra's maak if it'll help :-)
13:33:02 <sjanssen_> @djinn-del null
13:33:10 <sjanssen_> @djinn (a -> b) -> List a -> List b
13:33:10 <lambdabot> f _ a = a
13:33:18 <jip> i do i generate a [(Double, Double)] that forms a circle around the origin with radius r?
13:33:20 <jip> n length
13:33:30 <davidhouse> are you sure it can't do recursive definitions?
13:33:35 <davidhouse> i'm sure this used to work
13:33:55 <davidhouse> @djinn-del List a
13:33:55 <lambdabot> Cannot parse command
13:33:57 <davidhouse> @djinn-del List
13:34:04 <sjanssen_> @djinn-add data List a = Nil | Cons a (List a)
13:34:13 <davidhouse> @djinn List a
13:34:14 <lambdabot> Cannot parse command
13:34:14 <lambdabot> -- f cannot be realized.
13:34:28 <sjanssen_> @djinn-env
13:34:28 <lambdabot> data () = ()
13:34:28 <lambdabot> data Either a b = Left a | Right b
13:34:28 <lambdabot> data Maybe a = Nothing | Just a
13:34:28 <lambdabot> data Bool = False | True
13:34:28 <lambdabot> data Void
13:34:30 <lambdabot> type Not x = x -> Void
13:34:32 <lambdabot> Error: Recursive types are not allowed: List
13:34:34 <lambdabot> foldr :: (a -> b -> b) -> b -> List a -> b
13:34:36 <davidhouse> ah.
13:34:42 <shapr> Yow, Conjure is the fastest bittorrent client I've ever seen.
13:34:48 <sjanssen_> @djinn-clr
13:34:51 <Guest15207> Is it?
13:34:56 <sjanssen_> shapr: Conjure actually works?
13:34:57 <the_lord> shapr, MLDONKEY
13:35:05 <Muad_Dib> shapr: how is it fast? In downloading? or in running?
13:35:11 <shapr> the_lord: Sorry no, mldonkey is nowhere close to as fast as conjure.
13:35:24 <shapr> Muad_Dib: It's faster than my connection, that much I can tell.
13:35:30 <shapr> In both downloading and running.
13:35:36 <davidhouse> jip, not easily
13:35:54 <davidhouse> jip, you probably need a different tactic.
13:36:01 <the_lord> shapr, I've downloaded at 300KBps that's all my connection can give
13:36:05 <davidhouse> like, type Region = Point -> Bool
13:36:11 <shapr> sjanssen_: I just grabbed Lemmih's repo and updated it to use ByteString, thus all my FPS <-> ByteString questions earlier :-)
13:36:19 <vincenz> is it 'trade-offs' or 'tradeoffs'
13:36:27 <sjanssen_> I didn't know it was actually in a working state
13:36:30 <sjanssen_> that is really cool
13:36:36 <shapr> the_lord: Compared to conjure, mldonkey uses more memory and cpu.
13:36:49 <Muad_Dib> shapr: hehe
13:36:53 <Muad_Dib> @where conjure
13:36:53 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
13:37:09 <the_lord> don't care with MLdonkey I have all the networks
13:37:12 <shapr> You want Lemmih's repo from http://darcs.haskell.org/~lemmih/conjure/
13:37:25 <shapr> the_lord: Yes, but conjure is written in Haskell :-)
13:37:29 <davidhouse> jip, then circle (x, y) r = \x1 y1 -> (x-x1)^2 + (y-y1)^2 <= r
13:37:44 <Muad_Dib> shapr: that'd just be darcs get .. right?
13:38:01 <the_lord> shapr, MLdonkey is in CAML
13:38:03 <shapr> Muad_Dib: Yeah, but it doesn't have the latest ByteString updates, I'll mail those to Lemmih lateron.
13:38:04 <the_lord> I think
13:38:08 <jip> > let (r, n) = (1, 4) in map (\i -> ((cos (2*pi/n*i))*r, (sin (2*pi/n*i))*r)) [0..n]
13:38:08 <the_lord> or OCAML
13:38:09 <lambdabot> [(1.0,0.0),(6.123031769111886e-17,1.0),(-1.0,1.2246063538223773e-16),(-1.836909530733566e-16,-1.0),(1.0,-2.4492127076447545e-16)]
13:38:16 <shapr> the_lord: I am aware of that, OCaml in fact.
13:38:18 <vincenz> ocaml
13:38:28 <vincenz> or O'Caml to be facetious
13:38:34 <shapr> But Conjure is in Haskell, and this is #haskell, thus Conjure has inherent advantages here.
13:38:45 <vincenz> shapr: political advantages :P
13:38:50 <shapr> Anyway, I'm off to watch a movie.
13:38:51 <davidhouse> jip, make sense?
13:38:55 <vincenz> cya shapr 
13:39:03 <the_lord> lol, conjure rules!!!
13:40:01 <monochrom> the_lord: about "on the fly".  1. I don't think anyone cares.  2. If you actually know the execution order of Haskell, you may find that it is on-the-fly.
13:40:42 <the_lord> monochrom, whatever
13:43:15 <monochrom> Well if you say that, then I'm discouraged from "helping" you.
13:43:53 <the_lord> monochrom, I can't do that, that's not what I was requested
13:44:37 <the_lord> thursday night I'll give the answer
13:44:47 <monochrom> If someone assures me that Alex is lazy, I will assure you mine is on-the-fly.
13:45:14 <the_lord> monochrom, here's the thing
13:45:30 <the_lord> alex's output is happy's input
13:45:51 <the_lord> alex's output is a [Token]
13:46:36 <sjanssen_> shouldn't a lexing error result in an error report followed by bailing out?
13:46:54 <sjanssen_> you can't parse something with errors in it, anyway
13:47:01 <the_lord> sjanssen_, have you ever used C or Java?
13:47:12 <the_lord> sjanssen_, yes you do
13:47:30 <the_lord> gcc or javac report all errors
13:47:41 <the_lord> they don't bail out
13:48:09 <jip> davidhouse: actually what i wrote works :D
13:48:56 <the_lord> monochrom, do you understand what I mean with on the fly?
13:49:36 <monochrom> I don't think you have finished your description.  You have to feed the tokens to happy.  So?
13:50:21 <davidhouse> jip, how does that work?
13:50:27 <the_lord> the function that generates the tokens must be the one that points the errors, not wait til alex finishes
13:51:00 <jip> davidhouse: read it and weap :P
13:51:40 <monochrom> You can program Happy to process Boom's and print error messages.
13:52:02 <davidhouse> jip, i did read it and i didn't understand it.
13:52:31 <the_lord> monochrom, I wont argue with you anymore
13:52:42 <davidhouse> oh, hang on
13:52:54 * davidhouse might get it
13:52:57 <jip> i just want the points on the perimiter of the circle
13:53:05 <the_lord> monochrom, I just can't do it the way you want me to do it
13:53:32 <davidhouse> ah.
13:53:40 <davidhouse> i still like my Region approach.
13:53:59 <davidhouse> especially as there are an infinite amount of points and your method can't therefore find them all :)
13:54:18 <jip> i don't want them all, just n of them :)
13:55:14 <davidhouse> oh, that's what you meant by "n length". i understand now.
13:55:21 <davidhouse> fair enough, stick with your method then.
14:07:59 <sjanssen_> > let r = 2 in [(x, sign * sqrt (r^2 - x^2)) | x <- [-r .. r], sign <- [-1, 1], abs x /= r || sign == 1]
14:08:00 <lambdabot> [(-2.0,0.0),(-1.0,-1.7320508075688772),(-1.0,1.7320508075688772),(0.0,-2.0),(0.0,2.0),(1.0,-1.7320508075688772),(1.0,1.7320508075688772),(2.0,0.0)]
14:11:53 <jip> is there a function for converting degrees to radians?
14:12:56 <pjd> jip: pi * degrees/180
14:13:24 <norpan> > (*pi/180) 360
14:13:25 <lambdabot>   The operator `*' [infixl 7] of a section
14:13:25 <lambdabot>    must have lower precedence than the operand `(/)' [infixl 7]
14:13:25 <lambdabot>    in the section: `(* (pi / 180))'
14:13:29 <norpan> bah
14:13:41 <norpan> > (/180*pi) 360
14:13:42 <sjanssen_> @pl \deg -> deg * (pi / 180)
14:13:42 <lambdabot>   The operator `/' [infixl 7] of a section
14:13:42 <lambdabot>    must have lower precedence than the operand `(*)' [infixl 7]
14:13:42 <lambdabot>    in the section: `(/ (180 * pi))'
14:13:42 <lambdabot> ((pi / 180) *)
14:13:43 <jip> but is there something in the prelude?
14:13:48 <pjd> (sorry, that's wasn't haskell)
14:13:55 <pjd> ("that", even)
14:13:57 <monochrom> No, not in the prelude or anywhere.
14:14:37 <jip> why not?
14:14:43 <norpan> > (*(pi/180)) 360
14:14:44 <lambdabot> 6.283185307179586
14:14:54 <norpan> why should there be
14:15:08 <jip> ok well, if it were in the prelude, what would it be called?
14:15:29 <norpan> i see absolutely no reason to have such a function in the prelude
14:16:12 <jip> yeah, but what should i call it? :)
14:16:20 <norpan> deg2rad
14:16:31 <sjanssen_> degreesToRadians is most consistent with Haskell naming
14:16:38 <vincenz> d2r
14:16:48 <vincenz> or just plain 'detour'
14:17:02 <sjanssen_> or just toRadians if one can assume the input is in degrees
14:17:02 <norpan> is there a consistent haskell naming?
14:17:09 <sjanssen_> or perhaps xj31541
14:17:14 <jip> please vote on it guys, and report to me the final name
14:17:14 <norpan> fromDegrees
14:17:23 <sjanssen_> norpan: camelCase is one common convention
14:17:24 <norpan> since radians is the "natural" measurement
14:17:48 <norpan> jip: are you serious? should we vote?
14:18:08 <jip> how else am i supposed to know which name to use?
14:18:22 * Oejet votes for degToRad.
14:18:26 <eivuokko> Just choose which one you like and reads out nicely on your code?
14:18:27 <sjanssen_> I vote yhjulwwiefzojcbxybbruweejw!
14:18:30 <sjanssen_> @yhjulwwiefzojcbxybbruweejw
14:18:31 <lambdabot> "\"#$%&'()*+,\""
14:18:32 <vincenz> I vote paris
14:19:18 <jip> hm... what about a function that converts radians to degrees?
14:19:23 <norpan> fromRadian
14:19:27 <norpan> no
14:19:29 <norpan> toDegree
14:20:23 <norpan> class AngleMeasurement a where fromRadian :: Radian -> a; toRadian :: a -> Radian
14:20:32 <eivuokko> Hehe
14:20:37 <sjanssen_> then fromAngular
14:21:17 <jip> what's a functor?
14:21:21 <stepcut> hrm, creating an AST for a language that supports self-modifying code is tricky :p
14:21:27 <mathrick> what's that?
14:22:37 <vincenz> stepcut: not perse
14:22:40 <monochrom> No, it is not tricky.  The self-modification happens during execution.
14:22:42 <vincenz> stepcut: you can define a core syntax
14:22:55 <vincenz> stepcut: then have syntactical sugar and make the modifying bits generate new sugar
14:23:08 <monochrom> Self-modification is semantics not syntax.  No impact to the parse tree.
14:23:14 <vincenz> unless it's what monochrom is referring to
14:23:17 <stepcut> well, in this case, the language is Make
14:23:46 <stepcut> and the 'problem' is you can put ifdefs in all sorts of places
14:24:02 <monochrom> Your semantics intepreter/executor can take the parse tree, make it mutable, and execute by mutating it.
14:24:14 <stepcut> and you often you can tell if something is syntactically valid unless you expand the macros
14:24:37 <norpan> so expand them :)
14:24:59 <stepcut> In this case I actually want to generate Makefiles, not execute them
14:25:13 <sjanssen_> jip: a functor f is something that you can define fmap :: (a -> b) -> f a -> f b
14:25:34 <norpan> so don't generate macros
14:25:47 <jip> hm...
14:26:04 <sjanssen_> jip: conceptually a container that allows you to modify all the things it contains
14:26:12 <jip> what should i call a module that contains functions fromDegrees and toDegrees
14:26:13 <stepcut> norpan: i still need to put ifdefs in odd places 
14:26:27 <norpan> jip: Radians
14:26:42 <TuringTest> Data.Radians
14:26:49 <sjanssen_> Numeric.Angular
14:26:59 <sjanssen_> Data is an overused category
14:27:09 <monochrom> If you generate a make file with ifdefs, you can ensure the expansion will be valid by design.
14:27:11 <TuringTest> Numeric.Units.Angular.Radians
14:27:30 <TuringTest> sjanssen_: True...it does not define new data, just a class
14:27:33 <norpan> Jip.Computations.FloatingPoint.RadianSpecialFunctions
14:28:11 <sjanssen_> Control.Monad.NothingToDoWithMonads.Angular
14:28:37 <ldas> hi, how can I use regex in Haskell?
14:28:53 <sjanssen_> ldas: carefully
14:29:13 <ldas> is there a library for such?
14:29:15 <TuringTest> ldas: To do what?
14:29:27 <ldas> extract data from a file
14:29:27 <norpan> ldas: Text.Regex?
14:29:34 <TuringTest> ldas: There is Text.Regex (which sucks) and the one I wrote
14:29:59 <norpan> oh, it sucks does it
14:30:01 <TuringTest> Text.Regex.Lazy
14:30:05 <ldas> what's the problem with text.regex?
14:30:06 <roconnor> Presumably Parsec is better than Regex in most situations?
14:30:14 <jip> right... so back to functors
14:30:28 <jip> is a list a functor?
14:30:31 <TuringTest> norpan: It convers (marshals) the whole [Char] into a C-array for each call to regex
14:30:37 <norpan> jip: certainly
14:30:46 <jip> what other functors are there?
14:30:55 <norpan> Maybe
14:30:56 <TuringTest> norpan: Which makes it unfathomably slow for searching large strings several times
14:31:02 <sjanssen_> jip: all Monads can be functors
14:31:02 <norpan> jip: all monads
14:31:18 <TuringTest> ldas: What are you using regex's for?
14:31:26 <norpan> TuringTest: then again it may be fathomably fast for searching short strings one time
14:31:37 <jip> freaky... what other "containers" are there, that can contain an arbitrary number of elements, like list?
14:31:44 <ldas> extract e-mail addresses
14:31:46 <TuringTest> norpan: Everything is fast for that
14:31:48 <ldas> but that's not the point
14:31:49 <monochrom> So, without knowing in depth your makefile problem, I'll just say this.  fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist)  can be seen as self-modifying code.  In general I conjecture that Haskell can be given a self-modification semantics and it is bisimilar to the standard semantics.  If Haskell can do this, so can you.  You just have to know how to separate your concerns.
14:31:50 <norpan> jip: Set, Map, ...
14:32:06 <sjanssen_> Set is not an instance of functor
14:32:16 <TuringTest> norpan: But Text.Regex is not lazy, which is the main semantic benefit of the library I posted.
14:32:21 <ldas> it's a schools assigment, I should be able to use all kind of regex
14:32:25 <sjanssen_> because Set needs Ord
14:32:41 <monochrom> Or, alternatively, you just have to know how not to be intimidated by mind-boggling ideas.
14:33:00 <monochrom> And damn all school assignments.
14:33:15 <TuringTest> ldas: For a school assignment, just use Text.Regex
14:33:21 <azuroth> argh. KDE is so bad at mounting and unmounting.
14:33:24 <norpan> sjanssen_: sure, but it's a container :)
14:33:40 <norpan> jip: arrays, ...
14:33:51 <sjanssen_> trees
14:33:52 <vincenz> jip: Map
14:33:55 <vincenz> jip: Set
14:33:57 <sjanssen_> functions
14:34:15 <sjanssen_> state monads
14:34:18 <sjanssen_> IO actions
14:34:25 <vincenz> dutchmen
14:34:29 <sjanssen_> vincenz
14:34:29 <norpan> norwegians
14:34:36 <norpan> tigers
14:34:37 <norpan> monkeys
14:34:40 <monochrom> Set would be a functor if not for its reliance on Ord.
14:34:41 <norpan> and bananas
14:34:43 <vincenz> sjanssen_: dutch?
14:34:46 <kzm_> Uh?
14:34:58 <vincenz> monochrom: well I disagree with it being a functor
14:35:01 <TuringTest> ldas: If you need lazy regex semantics then https://sourceforge.net/projects/lazy-regex will help.
14:35:09 <vincenz> monochrom: cause fmap'ing should be structure preserving while for Set it's clearly not
14:35:22 <ldas> thanks, I'll look into it
14:35:25 <norpan> vincenz: it depends on how you implement the set
14:35:34 <vincenz> norpan: no matter how you implement it
14:35:35 <roconnor> vincenz: structure preserving?
14:35:37 <norpan> type Set a = [a]
14:35:38 <vincenz> you can fmap something to have less elements
14:35:42 <vincenz> norpan: that's not a Set
14:35:49 <norpan> vincenz: isn't it?
14:35:55 <ldas> this is what they gave me: http://students.info.uaic.ro/~rammy/proiect2/regexp&automata/
14:35:56 <norpan> it all depends on semantics you know
14:35:58 <vincenz> set = collection of -unique- elements
14:36:22 <norpan> vincenz: yeah, so only store unique elements in the list
14:36:25 <vincenz> {1, 2, 3, 4} `fmap` isodd
14:36:27 <norpan> is that so hard
14:36:30 <vincenz> -> set with 2 elements
14:36:38 <newsham> python 2.5 will have partial application.
14:36:40 <sjanssen_> norpan: what if you fmap (const 2)?
14:36:41 <monochrom> Can you give an example of Set not preserving structures.  Here by Set I mean an ideal abstract data type.
14:36:42 <norpan> vincenz: no, set with 4 bools
14:36:47 <vincenz> norpan: then it's not a set
14:36:55 <norpan> bah
14:37:09 <norpan> just ignore the duplicates
14:37:15 <vincenz> then it's not a set
14:37:18 <monochrom> And I'm sorry but this debate is so much more interesting than homework :)
14:37:40 <norpan> i never said Set should be a functor though, just that it is a container
14:37:42 <ldas> ok
14:37:51 <vincenz> norpan: I never disclaimed it being a container
14:37:55 <vincenz> or more specifically a collection
14:37:56 <jip> isn't python 2.5 already out?
14:37:58 <vincenz> read up on Edison
14:38:07 <ldas> thanks
14:38:08 <vincenz> it's got a nice break down of the collection hierarchy
14:38:23 <vincenz> which is observed even in imperative libs
14:38:26 <vincenz> like stl or Java.Collections
14:38:51 <monochrom> (fmap s) can have fewer members than s.  But how does this not preserve structure?  Tell me which equation is violated.
14:39:09 <monochrom> err (fmap f s)
14:39:28 <vincenz> size
14:39:30 <vincenz> for one
14:39:35 <vincenz> size is different
14:39:50 <sjanssen_> what is the contract for fmap?
14:39:52 <vincenz> fmap maps unique elements without modifying the 'tree' or 'structure' of the thing
14:39:58 <sjanssen_> are there laws just like Monad?
14:40:23 <vincenz> well what stpos you then from making an fmap that maps a Node to a Leaf
14:40:25 <vincenz> in a Tree
14:40:40 * vincenz would assume fmap to require structure preserval
14:40:53 <roconnor> fmap id = id
14:41:05 <norpan> yes
14:41:06 <roconnor> fmap (f . g) = (fmap f) . (fmap g)
14:41:11 <monochrom> Yes we usually require fmap to be a natural transformation.
14:41:26 <vincenz> monochrom: not too keen with ct, but yeah Iwould think that breaks down with sets
14:41:41 <roconnor> is that all?
14:41:46 <norpan> roconnor: yes, those are the two functor laws
14:42:50 <sjanssen_> seems an instance for Set would obey those laws
14:43:15 <monochrom> Alright I'm satisfied with the "size does matter!" argument for the moment. :)
14:43:20 <roconnor> sjanssen_: The only reason Set is not a Functor is that Set a requires a to be an instance of Ord.
14:43:27 <tbfg> hi
14:43:35 <vincenz> monochrom: basically fmap retains the internal (hidden) structure for all instances of Functor
14:43:51 <roconnor> sjanssen_: It is a deficency of Haskell that Set is not somehow a Functor.
14:43:51 <sjanssen_> vincenz: that isn't part of the Functor contract, it seems
14:43:51 <vincenz> for Set this would break down
14:44:04 <tbfg> data Code = Nil | Ldc Integer, how can I match the Ldc Integer ?
14:44:05 <vincenz> sjanssen_: maybe the fact that Ord is not a requirement is an implicit thing
14:44:16 <tbfg>  | c == Ldc = does not work
14:44:21 <norpan> actually, a functor can be from one category to another
14:44:30 <vincenz> emr no
14:44:39 <sjanssen_> roconnor: right, that's why we have proposals to make Functor a MPTC
14:44:54 <vincenz> MPTC?
14:45:10 <_roconnor> @whatis MPTC
14:45:11 <lambdabot> I know nothing about mptc.
14:45:12 <sjanssen_> Multi-paramater type class
14:45:13 <vincenz> monochrom: how strong is your existential type foo
14:45:16 <norpan> so fmap :: (a -> b) -> [a] -> Set b could be a functor in category theory
14:45:27 <monochrom> Non-existent.  (pun intended)
14:45:37 <cathper> Well, I'm a total newbie and tried to make my own version of map (and reverse) using tail-recursion -- did I succeed? http://pastebin.ca/56041
14:45:45 <vincenz> norpan: ah but depending on how Eq is defined.... the fmap (f.g) law might no longer hold!!!
14:45:59 <vincenz> f :: b -> c, g :: a -> b
14:46:05 <vincenz> depending on how Eq of b is defined
14:46:08 <sjanssen_> vincenz: but then we've violated the Eq law
14:46:16 <vincenz> fmap (f . g) = fmap f . fmap g might fail
14:46:23 <vincenz> erm
14:46:24 <vincenz> Ord even
14:46:39 <vincenz> cause Set uses Ord, not Eq
14:46:42 <norpan> if it fails then it's not a functor
14:47:13 <akyto-> how can i cast an Integer to a Double ?
14:47:16 <vincenz> fmap (f . g) = fmap f . fmap g might fail
14:47:23 <vincenz> if b is smaller than a
14:47:27 <_roconnor> @type fromInteger
14:47:28 <akyto-> or divide Integer trough Integer and get a Double
14:47:28 <lambdabot> forall a. (Num a) => Integer -> a
14:47:31 <vincenz> then it'll fail for Set
14:47:40 <vincenz> aka if g is not one-to-one
14:47:56 <norpan> vincenz: but as usual a haskell Functor is a property on the category and not on the mapping function
14:47:57 <vincenz> but I'm tired so I coudl be confused
14:48:07 <norpan> so they are not the same thing
14:48:08 <sjanssen_> vincenz: if f and g are functions, then that isn't a problem
14:48:25 <vincenz> sjanssen_: depends on how Ord of the target domain of g is defined
14:48:35 <vincenz> for Sets
14:48:46 <norpan> it's not Set that is the functor, it's (fmap f)
14:48:47 <sjanssen_> we have to assume that the instance for Ord is sane
14:49:08 <vincenz> sjanssen_: Ord could lead to fewer equality classes
14:49:10 <vincenz> than Eq
14:49:32 <vincenz> and in that specific case it breaks down
14:49:39 <norpan> so the laws are: fmap f (id a) == id (fmap f a)
14:49:58 <vincenz> no
14:50:01 <vincenz> fmap id = id
14:50:03 <vincenz> not quite the same
14:50:21 <norpan> and fmap (f.g) a == fmap f (fmap g a)
14:50:25 <vincenz> the law you mentioned is just a property of id
14:50:38 <norpan> huh?
14:50:39 <vincenz> fmap f (id a ) = fmap f a = id (fmap f a)
14:50:43 <_roconnor> If f takes equal things to unequal things, then it isn't much of a function, now is it.
14:50:44 <vincenz> has nothing to do with fmap properties
14:51:08 <eivuokko> Can I interest people using ghc in Windows to try my tracer-program?  It "debugs" given executable built with ghc and shows "stack traces" (evaluation traces might be better term) on user specified symbols.  It requires mingw binutils for nm.exe.  Darcs repo is at http://tamelambda.net/darcs/tracer/
14:51:51 <vincenz> _roconnor: no....g :: a -> b... if b has Ord with fewer equality classes than Eq b, then fmap (f . g) = fmap f. fmap g with a set in the middle will no longer hold
14:52:04 <norpan> vincenz: well good, then the law is always satisfied
14:52:39 <vincenz> but more intuitively, Functors are structure preserving, which does not hold for Functor Set
14:53:00 <vincenz> except that's a thing about the internal stuff and can therefore not be easily represented in a law, except perhaps teh fact that Functor does not require Ord
14:53:10 * vincenz shrugs
14:53:31 <roconnor_> frigin' network. ... grr
14:53:37 <jip> whoah, i hit a bug in ghci
14:53:58 <roconnor_> compare x y = Eq <=> x == y
14:54:16 <sjanssen_> vincenz: your fewer equality classes argument doesn't hold
14:54:22 <vincenz> I guess
14:54:23 <vincenz> it just feels wrong
14:54:26 <vincenz> but I'm too tired to argue
14:54:26 <roconnor_> (compare x y == Eq) = (x == y)
14:54:30 <vincenz> midnight and I'm up since 6am
14:54:32 <roconnor_> (compare x y == Eq) == (x == y)
14:54:58 <jip> ghci bug: http://rafb.net/paste/results/R6kp5L37.html
14:54:59 <norpan> i may well define fmap f (x:y:rest) = f y:f x:fmap f rest
14:55:10 <norpan> don't need Ord
14:55:19 <vincenz> norpan: that would never pass the fmap f. fmap g law I think
14:55:38 <norpan> that depends on how you define equality
14:56:05 <vincenz> norpan: it's a list
14:56:08 <vincenz> Eq is defined for Lists
14:56:21 <norpan> yeah, so is fmap, but i just redefined it :)
14:56:23 <vincenz> which is lexicographic I would believe
14:56:27 <monochrom> cathper: I have simplified the code a bit. http://pastebin.ca/56044   But anyway yours is tail-recursive, is correct, and pretty good.
14:56:35 <vincenz> anywas
14:56:37 * vincenz sleep
14:56:42 <norpan> night
14:57:06 <vincenz> cya 
14:57:11 <vincenz> thanks for the discussion
14:57:18 <vincenz> if I coome up with something saner tomorrow I'll bring it up
14:57:20 <roconnor> vincenz: sleep well
14:57:50 <jip> what else besides fmap does functor have?
14:57:57 <vincenz> jip: nothing
14:58:29 <jip> hm..... interesting
14:59:13 <jip> what's the point of having an entire typeclass then, why not just pass around an appropriate "fmap" function whenever you need it?
14:59:25 <vincenz> jip: cause fmap is structure dependent
14:59:47 <vincenz> fmap f x:xs = f x:fmap f xs
14:59:49 <vincenz> then for Maybe
14:59:53 <vincenz> fmap f Nothing = Nothing
15:00:01 <vincenz> fmap f (Just x) = Just . f $ x
15:00:15 <vincenz> each fmap instance has a different type, hence the need for a typeclass
15:00:42 <cathper> monochrom: oh yes, of course, neither myMap nor myReverse needs the first line of their definition. Thanks for your comment! It's highly appreciated.
15:01:26 <vincenz> monochrom: you knnow... coming from ocaml I was always a tailcaller...however I have noted cases where non tail call is more efficient in haskell than tailcall
15:01:37 <vincenz> due to lazy evaluation
15:01:41 <vincenz> tail callforces it all into memory
15:01:44 <monochrom> That is right.
15:01:47 <vincenz> lazy list building doesn't
15:01:58 <vincenz> :)
15:02:28 <norpan> tail calling is evil
15:02:33 <norpan> tail recursion
15:02:38 <vincenz> especially the necessity for the reverse at te end
15:03:14 <vincenz> Day changed to 16 May 2006
15:03:18 <vincenz> irssi is telling me to leave
15:03:20 * vincenz waves
15:03:52 <cathper> Nevertheless it will sometimes be faster -- and sometimes not.
15:04:12 <monochrom> If `op` is a non-strict constructor, "f x `op` xs" is preferred to "map f (...xs...)".  The difference is incremental evaluation vs. monolithic evaluation.
15:04:21 <cathper> That's all about eager vs. lazy evaluation, as far as I understand.
15:04:38 <monochrom> If `op` is a very strict function, e.g., (+), it doesn't really matter.
15:05:35 <monochrom> Because of the former case, in Haskell we actually use "tail-recursion" to describe "f x : map f xs".
15:06:35 <cathper> Uhm, can you define strict (or non-strict) constructor for me?
15:07:35 <cathper> Strict means "requires/results in eager evaluation"?
15:07:37 * sh10151 always wonders why people type filler syllables like um or er in textual media
15:07:59 <monochrom> For newbies, all constructors are non-strict.
15:08:33 <norpan> a strict function is one that needs to evaluate its argument to produce its result
15:08:39 <monochrom> The ";" for lists is a constructor.
15:09:08 <monochrom> And of course I meant ":"
15:09:12 <eivuokko> sh10151, Very likely for same reason you used action instead of straight question.
15:09:22 <cathper> I see.
15:10:09 <cathper> Can one even define a function to be strict?
15:10:42 <cathper> (by some built in construct)
15:10:45 <monochrom> Yes.  f x = x `seq` "hello"
15:11:16 <monochrom> > let f x = "hello" in f (0/0)
15:11:17 <lambdabot> "hello"
15:11:25 <monochrom> This f is non-strict.
15:11:42 <monochrom> > let g x = x `seq` "hello" in g(0/0)
15:11:43 <lambdabot> "hello"
15:11:54 * monochrom scratches his head
15:12:05 <monochrom> > let g x = x `seq` "hello" in g(undefined)
15:12:06 <lambdabot> Undefined
15:12:14 <monochrom> This g is strict.
15:12:16 <norpan> > 0/0
15:12:17 <lambdabot> NaN
15:12:18 <alar> > 0/0
15:12:20 <lambdabot> NaN
15:12:24 <alar> (0/0)
15:12:25 <monochrom> Oh!
15:12:35 <monochrom> > let f x = "hello" in f (0 `div` 0)
15:12:36 <lambdabot> "hello"
15:12:42 <alar> NaN is not an exception :)
15:12:43 <monochrom> > let g x = x `seq` "hello" in g(0 `div` 0)
15:12:44 <lambdabot> Exception: divide by zero
15:12:52 <monochrom> Now I get them right.
15:14:35 <shapr> d00d
15:14:42 <norpan> > True && undefined
15:14:43 <lambdabot> Undefined
15:14:53 <Cale> > True || undefined
15:14:53 <monochrom> If you work with composite data types such as lists, you also need to be aware of the entire spectrum between strict and non-strict, i.e., how many elements of the list does a function evaluates.
15:14:53 <norpan> > True || undefined
15:14:54 <lambdabot> True
15:14:54 <lambdabot> True
15:15:00 <norpan> hey
15:15:21 <shapr> > head [1,1/0]
15:15:23 <lambdabot> 1.0
15:15:35 <norpan> normaly head-strict or full strict
15:15:38 <Cale> > head [1,1 `div` 0]
15:15:39 <lambdabot> 1
15:15:50 <monochrom> Don't forget take 192834
15:16:33 <norpan> monochrom: take 192834 is not strict at all
15:16:55 <monochrom> oh well
15:16:57 <norpan> or maybe head strict
15:17:10 <norpan> since it just does [] or (x:xs)
15:17:39 <norpan> anyway
15:17:52 <norpan> the tail recursive variants are often too strict
15:17:55 <Cale> take 192834 (1:2:3:undefined)
15:17:59 <Cale> > take 192834 (1:2:3:undefined)
15:18:00 <lambdabot> Undefined
15:18:11 <norpan> > head (take 192834 (1:2:3:undefined))
15:18:12 <lambdabot> 1
15:18:34 <Spark> > tail []
15:18:36 <lambdabot> Add a type signature
15:18:40 <cathper> `take n l' will return a list containing the first n elements of the list l, right?
15:18:46 <Cale> yep
15:18:49 <Spark> take 0 []
15:18:52 <Spark> > take 0 []
15:18:53 <lambdabot> Add a type signature
15:18:56 <tbfg> data Code = Nil | Ldc Integer
15:19:02 <tbfg> i can now match with | c == Ldc 1 =
15:19:07 <Cale> or if the list is shorter than n elements, it returns the whole list
15:19:09 <tbfg> but need to name the integer
15:19:16 <tbfg> this can't be it ?
15:19:25 <xerox> tbfg: foo (Ldc x) | c == x = ...
15:20:09 <tbfg> xerox foo takes a [Code]
15:20:22 <cathper> Cale: ok, and n must be of type Int (which btw. is [0..] or [1..]?)
15:20:23 <tbfg> i can match | c == Stop =
15:20:34 <tbfg> do i need to have 2 "bodies" ?
15:20:37 <xerox> tbfg: what do you want to do exactly?
15:20:40 <tbfg> one for the Ldc case ?
15:20:48 <Cale> Ints are signed machine integers.
15:20:55 <Cale> > take (-5) [1,2,3]
15:20:56 <lambdabot> []
15:21:00 <cathper> oh
15:21:16 <xerox> tbfg: you need a pattern matching case for each data constructor, in general.
15:21:57 <tbfg> xerox so far okay, I have a few only Constructor, and a few parametrized with Integer
15:22:06 <tbfg> xerox i want to match the Con AND the Integer
15:22:22 <tbfg> xerox as well as Con without parameter
15:22:42 <tbfg> foo :: [Code] -> Bool
15:22:48 <tbfg> foo (c:cs) 
15:22:59 <tbfg>  | c == Nil = --no parameter
15:23:19 <tbfg>  | c == Ldc x = -- don't know how to bind the parameter to x
15:23:24 <xerox> You want to collect the integers?
15:23:31 <xerox> That's not currect anyway.
15:23:55 <cathper> Ahh, there is Natural too :-)
15:24:27 <xerox> foo :: [Code] -> [Int]
15:24:29 <xerox> foo [] = []
15:24:29 <xerox> foo (Nil:cs) = foo cs
15:24:29 <xerox> foo ((Ldc x):cs) = x : foo cs
15:24:51 <tbfg> xerox okay, 2 bodies so to say ?
15:26:03 <xerox> Another way to do it is this nice-looking one:
15:26:17 <xerox> foo cs = [x | (Ldc x) <- xs]
15:26:43 <tbfg> xerox i want to do some more than collecting Ints...
15:27:10 <xerox> Like?
15:27:15 <kosmikus> Cale: I don't know if you've seen my message. Thank you for the puzzle. I liked it a lot.
15:27:31 <norpan> huh
15:27:53 <tbfg> xerox implement a virtual machine for some toy language
15:28:46 * cathper goes to bed and is thankful for the help!
15:28:55 <xerox> Nice.  Well, keep in mind how to pattern match in general.
15:30:15 <tbfg> xerox it's working now, with 2 bodies (or however they are called)
15:33:29 <shapr> pattern matching
15:42:50 <ndm> hi, is there a decent tool to view the GHC generated profile information?
15:43:03 <shapr> gv
15:43:32 <ndm> gv?
15:43:32 <shapr> There's a tool that comes with GHC that turns profile information into pretty color PostScript graphs
15:43:36 <ndm> on windows
15:43:50 <shapr> No postscript viewer on windows?
15:44:31 <hyrax42_> you can get afpl ghostscript for windows
15:45:29 <jip> you can convert postscript to pdf
15:45:38 <shapr> I use ps2pdf on Linux.
15:45:57 <shapr> Hiya mrevelle 
15:46:14 <shapr> orbitz: Doing cool stuff with oort?
15:46:25 <orbitz> no
15:46:48 <orbitz> ##c has some annoyance, i thoguht oort had @ in ##c so i was going to swtich ot him to remov ehtem, but aarently he doenst:(
15:47:01 <shapr> ah well
15:48:40 <orbitz> shapr: i do ened to write some stuff for oort
15:48:48 <thelsdj> hrm, mp3 decoder in haskell, insane idea?
15:49:29 <jip> there is an ogg decoder in java
15:50:42 <thelsdj> might be a too ambitious project, but i want something interesting to work on
15:50:57 <jip> go for it
15:51:00 <shapr> mp3 decoder wouldn't be too hard.
15:51:42 <thelsdj> wish i could find a good version of the mp3 specs, the .doc file i have is terribly formatted
15:52:02 <jip> that's why you should go with ogg vorbis
15:52:07 * shapr agrees
15:52:09 <stepcut> thelsdj: I personally find it hard to justify writing a mp3 decoder instead of using using libmad
15:52:55 <thelsdj> yea i agree, but i haven't thought of anything better to work on to keep myself interested in haskell
15:53:00 <xerox> thelsdj! Again!
15:53:04 <thelsdj> xerox: duh
15:53:10 <stepcut> thelsdj: :p
15:53:12 <shapr> thelsdj: http://haskelldsp.sourceforge.net/
16:09:33 <xerox> Goodnight.
16:14:33 <shapr> stepcut: Hey, is freespire going to be debian with the infrastructure redone with Haskell?
16:14:38 <shapr> I could really go for that idea.
16:19:52 <jip> yes
17:42:45 <jip> Cale: isn't your sample puzzle also ambiguous?
17:43:06 <Cale> jip: I hope not
17:43:22 <Cale> jip: what's the other solution?
17:43:28 <jip> Cale: oh no, oops my bad
18:26:37 <hyrax42_> is there an isomorphism between [m a] and m [a]?
18:28:33 <jip> don't think so
18:29:28 <Pseudonym> There might be "an isomorphism" for all such m, but it might be different for each m.
18:29:34 * Pseudonym isn't sure
18:29:56 <Pseudonym> But [m a] and m [a] are different in general, if that's what you meant.
18:30:02 <hyrax42_> ok
18:30:05 <lispy> very different
18:30:06 <hyrax42_> yeah more or less
18:30:44 <Pseudonym> I believe that [m a] and m [a] are "the same" if m is abelian.
18:30:58 <Pseudonym> That is, if x >> y is the same as y >> x
18:31:06 <Pseudonym> Or something.
18:31:07 <lispy> for exampple, [IO ()] compared to IO [()]
18:31:35 <lispy> side effects are weird
18:32:07 <hyrax42_> hm
18:32:33 <lispy> (I don't have a concrete example, I just wanted to remind that in haskell monads are used for IO)
18:32:50 <lispy> can be used*
18:38:33 <bsmntbombdood> what does " Non-exhaustive patterns in function foo" mean?
18:39:47 <hyrax42_> what's the function defn
18:39:57 <hyrax42_> or the pattern matchign parts
18:40:08 <hyrax42_> I believe typically means you're missing a wild card in it
18:40:08 <bsmntbombdood> ( a simple one):
18:40:12 <bsmntbombdood> let qsort (x:xs) = qsort(filter (<x) xs) ++ [x] ++ qsort( filter (>=x) xs)
18:40:33 <hyrax42_> or not a wild card, but not catching all possibilities
18:40:34 <hyrax42_> yeah
18:40:38 <hyrax42_> you need a case for the empty list
18:40:55 <jip> that warning is sometimes incorrect though
18:41:05 <bsmntbombdood> let qsort [] = []
18:41:12 <bsmntbombdood> let qsort (x:xs) = qsort(filter (<x) xs) ++ [x] ++ qsort( filter (>=x) xs)
18:41:17 <hyrax42_> > let qsort (x:xs) = qsort(filter (<x) xs) ++ [x] ++ qsort( filter (>=x) xs); qsort [] = [] in qsort [3,2,66,1,-10]
18:41:18 <lambdabot> [-10,1,2,3,66]
18:42:16 <hyrax42_> I think they need to be in the same let
18:42:24 <hyrax42_> although if you're in ghci, probably not
18:42:34 <bsmntbombdood> I am in ghci
18:43:42 <hyrax42_> then I think you can do lets without the in
18:43:49 <bsmntbombdood> yea
18:43:52 <hyrax42_> as everything is sequenced in IO
18:43:56 <hyrax42_> (I think)
18:45:05 <bsmntbombdood> "let qsort (x:xs) = qsort(filter (<x) xs) ++ [x] ++ qsort( filter (>=x) xs); qsort [] = []" works
18:45:55 <hyrax42_> oh they do need to be in the same let
18:46:00 <bsmntbombdood> ok
18:46:40 <bsmntbombdood> thanks
18:46:53 <hyrax42_> but I can't definitively say why
19:58:34 <dons> ?yptime
19:58:34 <lambdabot> uptime: 5 days, 20 hours, 33 minutes and 33 seconds
20:24:12 <palomer> man
20:24:31 <palomer> I know if I  start coding now, I won't be able to sleep properly
20:24:46 <monochrom> don't start coding now :)
20:33:08 <palomer> :/
20:48:51 <jfoutz> if i was to count the number of words in a file, my first implementation would be just a hashtable of words, as keys and counts as values. Is that the right approach in haskell? should i use an alist? something else crazy?
20:51:58 <skew> yeah, except usually Data.Map instead of a hash table
20:52:34 <jfoutz> ahhh, that's not all IO ified. much better. thank you.
20:53:00 <skew> be careful with the laziness of the counts, if you have big files
20:53:21 <skew> and don't like using unary numbers
20:54:00 <jfoutz> i'm not sure what unary number means.
20:54:39 <SamB> data Nat = Z | S Nat
20:54:41 <skew> you know, 1 11 111 1111 11111 111111, etc
20:55:13 <jfoutz> oh. hmmm. so i was looking at big files, yes. 
20:55:30 <SamB> also (1+(1+(1+(1+(1+(...))))))
20:55:32 <jfoutz> 1 11 111 is better than 1 2 3?
20:56:03 <jfoutz> something like get "monkey
20:56:10 <jfoutz> heh, typo there
20:56:13 <jfoutz> something like
20:56:35 <jfoutz> put get "monkey" (1+) map 
20:57:56 <skew> it's just if you do something like Map.insertWith (+) newWord 1 oldMap, then you end up building a map full of thunks, like {"cat"-><1+(1+(1+(1+(1+(1+1)))))>,"dog"->1+(1+1)}
20:58:01 <jfoutz> that should stack up all of the actual additions until i look up the value, right? is that a good thing?
20:58:11 <skew> that would be a bad thing
20:58:14 <jfoutz> ok
20:59:45 <skew> I think the best you can do there is make strict version of the function you want, do a lookup to get out the old value if there is one, then use seq on the computation of the new value and building the map that includes the new value
21:00:23 <jfoutz> i don't see how Nat Nat Nat Z gets around that problem.
21:00:45 <jfoutz> or S S S Z rather
21:02:24 <skew> rather, that is the problem - you think you are using machine words, but unless you squash the laziness you are actually building up thunks that look much like that kind of number
21:03:28 <jfoutz> ok, i get you. 
21:04:57 <jfoutz> if i seq the get and the put, i'll only have 1 thunk. that sounds fine to me.
21:05:54 <jfoutz> something like Map.insertWith (+) (seq newWord 1) oldMap
21:06:04 <jfoutz> not quite but close
21:06:21 <Lokadin_> what is the port number for darcs?
21:06:44 <dcoutts> darcs uses http or ssh
21:06:47 <skew> to make it work, you need to use seq on the new value and the map with the new value inserted
21:06:52 <Lokadin_> dcoutts: oh okay thanks :)
21:07:36 <skew> so then if anything is done with that map, the addition is forced
21:07:41 <jfoutz> duh. i see. fully evaluate oldvalue +1 ... then do other stuff
21:07:50 <skew> pretty annoying
21:08:04 <skew> or you could just buy lots of RAM
21:08:20 <jfoutz> hehehe
21:08:23 <vincenz> Good morning!
21:08:24 <jfoutz> cheaper every day
21:08:54 <skew> you can buy 4GB modules, if you can afford it
21:09:16 * jfoutz ponders the cost of 2^32 ints worth of ram
21:09:48 <tessier_> RAM is reasonably cheap.
21:09:55 <tessier_> Bandwidth is what we all need more of
21:10:17 <jfoutz> i'm pretty happy with my cable modem.
21:10:18 <SamB> Internet or bus?
21:10:58 <tessier_> Upstream on a cablemodem sucks. :(
21:11:00 <tessier_> DSL too.
21:11:26 <vincenz> hmm
21:11:27 <jfoutz> yeah, you sort of have to pay for hosting.
21:11:30 <SamB> well, I'm on 56k and 450 MHz...
21:11:44 <tessier_> You have to pay for cablemodem/DSL too
21:11:57 <tessier_> I am paying for business DSL so I can have some static IP's and no blocked ports
21:12:06 <tessier_> Need more bandwidth. In a month or two I will be moving into a colo.
21:12:39 <vincenz> tessier_: how much is colo/month
21:12:52 <vincenz> hi Lokadin_ 
21:13:11 <tessier_> vincenz: Depends on what you need. I think any sort of decent colo will start at $250/mo and the sky is the limit from there
21:13:19 <vincenz> O.O
21:13:26 <vincenz> 250 / month
21:13:29 <vincenz> you must be rich
21:13:36 <vincenz> that's a third of my rent
21:14:02 <tessier_> I'm pretty sure I can make that much in profit.
21:14:36 <vincenz> web developer?
21:16:52 <vincenz> dcoutts: still up or just up?
21:17:03 <dcoutts> just up
21:17:04 <tessier_> yeah
21:17:16 <vincenz> dcoutts: what time do you typically get up?
21:17:31 <dcoutts> 9 am
21:17:36 <dcoutts> @localtime dcoutts 
21:17:38 <lambdabot> Local time for dcoutts is Tue May 16 05:16:21
21:17:39 * vincenz counts on his fingers..
21:17:53 <vincenz> paper submission deadline?
21:18:01 <dcoutts> couldn't sleep :-)
21:18:06 <vincenz> ah
21:18:07 <vincenz> heh
21:18:13 <vincenz> I also auto woke up today at 5:30am
21:18:20 <vincenz> but I waited for my alarm at 6 :)
21:18:30 <vincenz> btw, if you wanna try something good to shake of the last bits of sleep
21:18:35 <vincenz> kum nye's a great thing
21:18:41 <dcoutts> so I'm fixing bugs that dons found in byteString.Lazy
21:18:45 <vincenz> it's this tibettan yoga thing but it's not easy
21:18:51 * vincenz gets some coffee
21:19:53 <tic> hmm..
21:20:27 <vincenz> but the first position is GREAT if you ever have aching shoulders
21:20:35 <vincenz> (stiff)
21:22:10 <vincenz> lol
21:22:19 * vincenz just got a cfp
21:22:24 <vincenz> gotta love how it places it's first priority
21:22:29 <vincenz> the first point they make
21:23:04 <vincenz> 1. XXXX will be held at the incredible Paradise Resort & Spa. Enjoy an unforgettable vacation before or after the conference at this beautiful resort.
21:23:12 <dcoutts> dons, fixed stilly groupBy bug
21:24:00 <dcoutts> dons, It was checking (P.unsafeHead s /= P.unsafeHead s') rather than (not (P.unsafeHead s `k` P.unsafeHead s'))
21:24:22 <dcoutts> copy'n'pasto bug from group
21:24:22 <hyrax42_> vincenz: any quality links for kum nye?
21:24:26 <hyrax42_> sounds interesting
21:24:32 <vincenz> hyrax42_: let me check
21:24:58 * vincenz mutters as google keeps defaulting dutch for him
21:25:18 <hyrax42_> oh if you have none bookmarked, I can probably manage to google for myself  :)
21:25:46 <vincenz> hyrax42_: this seems to be the site of the author of the book I'm using http://www.randomhouse.co.uk/minisites/kumnye/
21:25:51 <hyrax42_> @localtime vincenz
21:26:00 <hyrax42_> oh ok
21:26:02 <vincenz> http://www.metta.org.uk/therap/therapists/kum_nye.asp
21:26:04 <hyrax42_> I got that too
21:26:06 <vincenz> yeah I just googled
21:26:14 <vincenz> localtime: 6:23 am
21:26:16 <hyrax42_> but if you're using that book I'll think about it
21:26:24 <hyrax42_> recommended?
21:26:32 <hyrax42_> (I am AWFUL at waking up)
21:26:33 <dons> dcoutts: ah, right.
21:26:55 <vincenz> hyrax42_: it's small and cheap, but nicely details the steps
21:26:59 <dons> dcoutts: any idea of the performance of defining group in terms of groupBy
21:27:01 <dons> ?
21:27:05 * vincenz is awful at waking up too, but has changed that his week
21:27:18 <dons> dcoutts: also, chak is signed up to mentor Language.C
21:27:24 <vincenz> the trick is going to bed before midnight, at least for me
21:27:30 <hyrax42_> lol
21:27:35 <dcoutts> dons, yes, that's great, I've given it +2
21:27:37 * hyrax42_ whacks head
21:27:39 <hyrax42_> of course!
21:27:41 <hyrax42_> ;)
21:28:13 <vincenz> no I'm serious, it's not linear
21:28:15 <dcoutts> dons, for perf, you claimed that ByteString.group is 40% faster than groupBy
21:28:18 * tic yawns
21:28:24 <vincenz> I go to bed at 1-2 am, I'll be up by noon
21:28:31 <vincenz> go to bed at midnight, I'm up at 6am
21:28:49 <vincenz> that and have a clear work plan so you have something to get up for
21:28:52 <tic> vincenz, I recognize that.
21:29:05 <dcoutts> dons, and for ByteString.Lazy.group(By) the time is only slightly more than ByteString.group(By) so I assumed it was making a difference.
21:29:10 <dcoutts> dons, I'll check properly
21:29:13 <hyrax42_> vincenz: good point
21:29:27 <dons> dcoutts: yeah, but groupBy/group on the list structure mightn't be so much. though I guess calling P.group on the chunks is going to be worth it.
21:29:42 <dcoutts> that's what I figured
21:29:43 * vincenz also 'wastes' an hour in the morning sipping coffee, surfing and googling
21:29:49 <vincenz> and chatting in #haskell
21:29:53 <tic> vincenz, of course. :)
21:29:54 <dons> also, chak pointed me to a phd on fusion/chunked data for nested data parallelism
21:30:02 <dcoutts> oh, cool
21:30:03 <dons> i'll mail you the url .
21:30:04 <vincenz> @localtime tic
21:30:06 <lambdabot> Local time for tic is Tue May 16 06:36:35 2006
21:30:09 <tic> same as yours.
21:30:21 <vincenz> tic: which country
21:30:23 <tic> I got up like an hour ago though. I've been futzing with my IRSSI theme since ;)
21:30:26 <tic> vincenz, Sweden.
21:30:30 <dons> dcoutts: the problem of fusing lists of arrays is basically unsolved... :)
21:30:36 <vincenz> hmm
21:30:42 <vincenz> tic: student?
21:30:49 <tic> vincenz, yeah, at Chalmers.
21:30:54 <dcoutts> dons, hmm nice
21:30:58 <vincenz> tic: which year?
21:31:06 <palomer> chalmers: the bastion of haskellfulness
21:31:12 <dons> dcoutts: so something to keep in mind
21:31:15 <tic> vincenz, last.
21:31:18 <dcoutts> right'o
21:31:19 <vincenz> tic: on that note, I had a Masters student from there apply for a position
21:31:24 <vincenz> tic: Shijing
21:31:48 <tic> vincenz, doing what?
21:31:57 <vincenz> for a thesis under my supervision
21:32:12 <tic> vincenz, aha. about?
21:32:17 <vincenz> well he got referred to me by my promotor
21:32:29 <vincenz> well in the end we decided that there were some other things at our place that suit him better
21:32:34 * vincenz works on code-trafos
21:32:52 <vincenz> but I think his background was multimedia
21:32:52 <tic> yipes.
21:32:55 <tic> Ah.
21:33:21 * vincenz could still use a student next year tho
21:33:47 <Lokadin> is runhaskell good for anything other than Setup.hs ?
21:34:18 <tic> vincenz, for what?
21:34:21 <Lemmih> Lokadin: Yes.
21:34:22 <sjanssen> Lokadin: I use it for other little programs that I want to run
21:34:22 <dons> Lokadin: test scripts
21:34:29 <dons> short programs. lots of stuff
21:34:41 <dons> anything you run often, but not worth compiling
21:34:50 <vincenz> tic: well to test out the methodology, apply it to real applications, maybe extend with me in places where we find it inadequae
21:35:00 <tic> vincenz, aha.
21:35:03 <dcoutts> dons, btw why do you turn off the orphan warnings?
21:35:07 <Lokadin> oh okay, so how would i run it just, runhaskell Test.hs ?
21:35:22 <dons> dcoutts: oh, they were about orphan rules, and i don't know how to fix them
21:35:25 <vincenz> main req is a strong c++ background
21:35:32 <dcoutts> dons, hmm, ok
21:35:50 <vincenz> and haskell experience is always good, all my tools are written in haskell :d
21:36:07 <dons> and the possibly dicey thing is turning off the pattern matching warnings in Lazy.hs. the invariant means we end up with heaps, but it's too annoying to get the bogus warnings
21:36:08 <tic> vincenz, hehe.  I'm currently doing something eles, or I might've applied ;)
21:36:26 <vincenz> tic: well for thos ethat might be interested, we don't accept people for a stay of less than 6 months
21:36:30 <Lokadin> dons: btw, does generating haddock work for you in yi? cause i tried it and it gave me an error for Yi/Curses.chs
21:36:34 <tic> vincenz, *nod*
21:36:40 <vincenz> I think it's paid tho
21:36:42 <dons> Lokadin: it has worked in the past. probably not hard to fix.
21:36:50 <vincenz> internship/Master thesis
21:36:52 <dons> chase up the line number, and work out why it isn't makign haddock happy
21:36:58 <tic> vincenz, sounds better than my current deal, i.e. loan from the gov't. ;)
21:36:59 <sjanssen> @where yi
21:36:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
21:37:05 * tic is kinda happy doing what he's doing right now, though.
21:37:15 <vincenz> wooo... Skypeout is becoming free
21:37:21 <palomer> go yi!
21:37:22 <vincenz> tic: what are you doing?
21:37:28 <Lokadin> dons: kk :)
21:37:53 <bmedwar> anyone use hs-fastcgi with lighttpd
21:38:07 <tic> vincenz, generalizing the various undocumented requirements of a C++ API in order to more-or-less automatically generate foreign-language bindings based on a set of pre-defined rules.
21:38:20 * vincenz nods
21:38:32 * palomer shivers
21:38:43 <tic> vincenz, at this point, it's about SWIG.  The API is BeOS.
21:38:47 <tic> :w
21:38:56 <tic> Wrong window. :)
21:40:08 <dcoutts> dons, if you can figure out why Lazy.splitWith is so much slower than Lazy.split then I'll be much impressed
21:40:26 <sjanssen> oh no, Yi uses old FastPackedString
21:40:33 <dons> ok. i'll have a look. what about, what was it, findElem? findIndices?
21:40:43 <dons> sjanssen: oh, I thought there was a patch. in darcs.
21:40:58 <palomer> so I says to the president: "damn those red ants!
21:41:03 <palomer> woops, wrong channel
21:41:06 <dons> dcoutts: or was it find that was like 10x slower, but i can't see why.
21:41:10 <dcoutts> 19 0.072        0.088           # "split"
21:41:11 <dcoutts> 43 2.456        5.052           # "splitWith"
21:41:16 <dons> hmm. ok. a puzzle!
21:41:22 <sjanssen> dons: nope
21:41:23 * tic grabs some food.
21:41:30 <dcoutts> dons, mind you that's with ghc-6.4.1
21:41:31 <vincenz> tic: didn't know BeOS is an API
21:41:39 <tic> vincenz, well, the API of the BeOS.
21:41:41 <dons> sjanssen: where' you getting yi from?
21:41:41 <vincenz> dcoutts: I'd choose splitWith
21:41:52 <dcoutts> dons, your results may be better
21:42:02 <sjanssen> dons: http://www.cse.unsw.edu.au/~dons/yi
21:42:09 <dcoutts> dons, I assume you're benchmarking with ghc-6.5
21:42:41 <dons> sjanssen: oh, i forgot to push alson's patch...
21:43:03 <dcoutts> vincenz, that's showing that ByteString.Lazy.splitWith takes twice as long as ByteString.splitWith
21:43:04 <dons> ok, sjanssen , done. try that (untested).
21:43:34 <vincenz> dcoutts: sarcasm...
21:43:34 <dons> dcoutts: usually I use 6.4 (since its easier to develop outside of fptools)
21:43:37 <dons> 6.4.2
21:43:38 <vincenz> dcoutts: where can I look at this code?
21:43:45 <dons> but then sometimes I check with the head too.
21:43:57 <dcoutts> vincenz, in the main fps repo
21:44:03 <vincenz> @where fps
21:44:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:45:24 <hyrax42_> what is the purpouse of Monad.guard
21:45:48 <vincenz> hyrax42_: to fail in the case a condition is not met
21:45:49 <sjanssen> dons: there are still a few import Data.FastPackedString lines, did you miss a patch?
21:46:04 <vincenz> > [x | x <- [1..10], x > 5]
21:46:05 <lambdabot> [6,7,8,9,10]
21:46:09 <dons> sjanssen: i think it was only partially finished.
21:46:10 <vincenz> X > 5 is like Monad.guard
21:46:15 <dons> shouldn't be too hard to finish the port.
21:46:20 <dons> ... ;)
21:46:21 <sjanssen> dons: I'll do that
21:46:26 <dons> ?karma+ sjanssen 
21:46:26 <lambdabot> sjanssen's karma raised to 8.
21:46:39 <hyrax42_> > do x<-[1..10]; guard x > 5
21:46:40 <lambdabot> Couldn't match `[t]' against `Bool'
21:46:54 <vincenz> > [1..10] >> 
21:46:55 <lambdabot>  parse error on input `}'
21:46:58 <vincenz> > [1..10] >>= \x )
21:46:59 <lambdabot>  parse error on input `)'
21:47:09 <vincenz> > [1..10] >>= \x -> guard x > 5 >> return x
21:47:09 <hyrax42_> > do x <- [1..10]; guard x > 5; return x
21:47:10 <lambdabot> Couldn't match `m a' against `Bool'
21:47:11 <lambdabot> Couldn't match `[t]' against `Bool'
21:47:19 <vincenz> > [1..10] >>= \x -> guard (x > 5) >> return x
21:47:20 <lambdabot> [6,7,8,9,10]
21:47:31 <hyrax42_> I was writing the equivalent
21:47:54 <vincenz> you need {} around do notation on a single line
21:47:59 <hyrax42_> oh right
21:48:00 <vincenz> do {code}
21:48:04 <hyrax42_> argh
21:48:12 <dons> > do return (); return ()
21:48:12 <hyrax42_> but not for let?
21:48:12 <lambdabot>  add an instance declaration for (Show (m ()))
21:48:25 <dons> > do return "y"; return "x"
21:48:26 <lambdabot>  add an instance declaration for (Show (m [Char]))
21:48:30 <vincenz> not for let, no
21:48:38 <dons> i hate the list monad. but no, you don't need { }
21:48:49 <vincenz> dons: is there a reason the fps repo is slow?
21:48:52 <hyrax42_> why hate
21:48:55 <dons> ?type do return "y"; return "x"
21:48:56 <lambdabot> forall (m :: * -> *).
21:48:56 <lambdabot>           (Monad m) =>
21:48:56 <lambdabot>           m [Char]
21:49:16 <vincenz> > do return "y"; return "x" :: [[Char]]
21:49:17 <lambdabot> ["x"]
21:49:23 <dons> vincenz: hmm. kzm said it was slow too. however, i find it very fast, and no one else has complained either.
21:49:36 <vincenz> dons: took me nearly a minute to get the notifcation of the first patch
21:50:00 <dons> no idea why that would be. 
21:50:15 <dons> if someone can investigate or has any hints, i could perhaps look further into it.
21:53:00 <vincenz> btw, not being yet familiar with your code of ByteString
21:53:13 <vincenz> I would nonetheless suggest working as much as possible with 4bytes
21:53:28 <vincenz> memory is much more easily accessed on a word-boundary
21:55:32 <vincenz> dons: most c-memory code tends to do this and then they have a wrap up at the end or beginning for those last [..3] bytes
21:56:26 <dons> they're flat packed byte arrays, identical to C strings. i'm not sure what you're suggesting, but it would be a profligate waste of space to pad each byte with 3 more 
21:56:37 <vincenz> nono
21:56:39 <vincenz> you don't pad
21:56:45 <vincenz> you just loop with a stride of 4
21:56:48 <vincenz> and process 4 elements at a time
21:56:54 <dons> ah, now that is interesting.
21:56:56 <vincenz> and then handle the last 1-3 bytes at the end
21:57:04 <vincenz> accessing by word
21:57:07 <dcoutts> hmm
21:57:09 <vincenz> is much faster than byte accessing
21:57:14 <dcoutts> true
21:57:15 <dons> yes, quite possibly we could change some peek/poke::Word8 into Word32 versions.
21:57:17 <vincenz> for instance memcpy and cosort do this
21:57:36 <dons> and then take apart the Word with a shift 
21:57:42 <dons> very interesting idea, vincenz 
21:57:47 <vincenz> of course you'd need to know where the extra bytes are
21:57:52 <vincenz> in case your array is not word aligned
21:58:01 <vincenz> c-memory stuff tends to be word aligned
21:58:04 <dons> well, only at the end. so it wouldn't be too hard to check.
21:58:12 <dons> we could even ensure there's always padding at the end.
21:58:23 <vincenz> and process 3 extra elements
21:58:26 <dons> worth investigating.
21:58:27 <vincenz> thereby removing the if
21:59:13 <Korollary> dons: You may want to read the performance recommendations docs at intel.com
21:59:43 <dcoutts> hah, they'll say: don't use indirect jumps
21:59:45 <dons> yeah, now we've run out of obvious haskelly things to do, tuning on this kind of level is probably the next step
22:00:06 <dons> i notice map reads and writes Word8. we could improve that.
22:00:22 <vincenz> I do think that moving to word will already benefit a lot
22:00:31 <vincenz> without entering processor specific things
22:00:40 <Korollary> That's already processor specific
22:00:48 <vincenz> nah
22:00:50 <vincenz> architecture at best
22:00:57 <vincenz> tbh
22:01:07 <vincenz> I don't know any 32bit arch which does not follow that rule
22:01:39 <palomer> 64 bits is the future
22:01:44 <palomer> I read it on reader's digest
22:01:51 <palomer> s/on/in
22:01:56 <hyrax42_> @pl liftM
22:01:56 <lambdabot> fmap
22:02:04 <dcoutts> it's even more true for 64bit arches
22:02:13 <dcoutts> they prefer even bigger alignment
22:02:19 <vincenz> yep, but don't do 64 bit just yet
22:02:33 * vincenz would stick to 32 bit word-processing in ByteString for now
22:02:44 <palomer> and have it be obselete in 20 years?
22:02:48 <palomer> think ahead people!
22:03:17 * palomer hates prepositions
22:03:56 <vincenz> dons: if you ensure 3byte 00000 padding at the end you can probably remove the if remaining bytes < 4... and just work on 32bit stuff, for instance for the compare function you could then just compare 32words at a time
22:04:09 <vincenz> err 32bit word
22:04:39 <dons> hmm. what about endianess.
22:04:42 <vincenz> that prolly explains why the commented out compareBytes is 4 times slower
22:04:45 <dons> i guess its up to us to pack things right.
22:04:55 <vincenz> hmm
22:05:56 <vincenz> dons: well I think that's implict
22:06:06 <vincenz> if you use shifting as method to put the bytes
22:06:14 <sjanssen> vincenz: ensuring null padding at end of each string isn't compatible with the fast substring operations we have now
22:06:17 <vincenz> the only issue of course then is reading
22:06:27 <vincenz> sjanssen: sharing?
22:06:32 <dons> yeah, slices are no good.
22:06:43 <vincenz> it uses sharing at the moment?
22:06:48 <dons> you can't assume any padding at the end.
22:06:54 <dons> yeah, O(1) substrings
22:06:54 <sjanssen> vincenz: bytestrings are Ptr, offset, len
22:06:58 <vincenz> well still
22:07:01 <vincenz> get size
22:07:13 <dons> you can still read in chunks of 4 though. you just have to be careful near the end.
22:07:18 <vincenz> figure out how much to do in 4 byte stride
22:07:20 <vincenz> do the last 3 bytes
22:07:21 <dons> yep
22:07:41 <vincenz> of course it'll mean more code
22:07:58 <sjanssen> also, you can't be sure that the beginning of your slice is word aligned, so there's that case
22:08:08 <dons> hmm. that too.
22:08:20 <dons> fiddly bits.
22:08:20 <vincenz> sjanssen: erm...
22:08:28 <vincenz> sjanssen: most memory managers tend to word align stuff
22:08:36 <dons> vincenz: substrings..
22:08:39 <vincenz> ah
22:08:42 <dons> always with the substrings.
22:09:06 <vincenz> well
22:09:09 <vincenz> Ptr, offset, len
22:09:13 <vincenz> offset is the offset in Ptr
22:09:15 <vincenz> Ptr is word aligned
22:09:36 <vincenz> figure out how many bytes are not word aligned in offset
22:09:55 <vincenz> same concept as for len
22:12:28 <vincenz> let contrabytes = offset `mod` 4, let prebytes = (4- contrabytes) `mod`4, let post bytes = (len + contrabytes) `mod`4
22:12:30 <dons> ok, i've written  a 4-at-a-time map. let's see how it runs..
22:12:55 <vincenz> :)
22:13:39 <kzm_> I have a(nother) darcs issue; I can't always resolve conflicts.
22:13:39 <vincenz> and if mod is heavy, remove the extra mod from prebytes, and possibly do 4 bytes at the start of the string
22:14:06 <kzm_> I.e. i 'resolve' to mark the conflict, fix it, record, but when I 'resolve' again, it is still there.
22:14:12 <kzm_> Any clue?
22:14:23 <kzm_> This is with 1.0.4, so it may have been fixed?
22:14:36 * palomer has issues with darcs put
22:14:44 <palomer> wouldn't be surprised if my repo was corrupt
22:14:53 * kzm_ doesn't use 'put'.
22:14:59 <palomer> ever?
22:15:08 <palomer> what if you want to copy your repo?
22:15:17 <vincenz> push
22:15:19 <kzm_> cd foo; darcs get ...
22:15:30 <palomer> so put is useless?
22:15:35 <kzm_> ssh bar; darcs pull 
22:15:50 <kzm_> Well - it is redundant, I guess.
22:16:20 <vincenz> dons: any improvs?
22:16:42 * kzm_ started using darcs before we got all these fancy push operations.
22:16:58 <vincenz> kzm_: push is towards the place you pull from
22:17:05 <vincenz> for instance if it's remote
22:17:18 <kzm_> yes.
22:17:42 <dons> vincenz: segfault. ;) but we can at least unroll the checks. i think this is doable
22:17:56 <vincenz> vive la darcs
22:18:00 <kzm_> however, in order to push, you must have enough access to be able to pull instead.  Or can you now push over HTTP?
22:18:11 <vincenz> kzm_: you can with darcs-server 
22:18:13 <vincenz> which uses cgi
22:18:17 <dcoutts> dons, Lazy.group is about 30% faster than Lazy.groupBy (==)
22:18:18 <dons> so instead of checking each time around, you check the lenght at the start, and jump to either an unchecked word32 loop, or some variant that handles the end <3,2, or 1 bytes
22:18:22 <dons> dcoutts: cool.
22:18:34 <vincenz> dons: yep
22:18:37 <vincenz> dons: pre calculate
22:18:48 <vincenz> let contrabytes = offset `mod` 4, let prebytes = (4- contrabytes) `mod`4, let post bytes = (len + contrabytes) `mod`4
22:18:57 <vincenz> prebytes is amount of bytes a priori
22:19:03 <vincenz> post bytes = amount of bytes at end
22:19:06 <ADEpt> dcoutts: you fixed lazy group/groupBy? cool!
22:19:15 <dcoutts> ADEpt, yep
22:19:20 * dcoutts darcs sends...
22:20:09 <dons> ok vincenz, i like this idea. 
22:20:12 <dons> ?karma+ vincenz
22:20:12 <lambdabot> vincenz's karma raised to 4.
22:20:20 <dons> just have to sort out my little segfault first...
22:20:21 <vincenz> \o:
22:20:26 <vincenz> time given I can look at it a bit
22:20:30 <vincenz> memory optimizations is my domain
22:20:44 <dons> since there's no way ghc's optimising peek/pokes to word boundaries for us..
22:20:45 <vincenz> (but I have a few papers to review by the 30th of may so it'll have to wait for the weekend)
22:20:52 <kzm_> dons, is there much to be gained by using Ptr and friends, instead of UArrays?
22:21:16 <sjanssen> maybe with this technique we can get rid of the reverse() in cbits?
22:21:25 <dcoutts> kzm, that's what fps is using
22:21:27 <kzm_> vincenz, wouldn't it be even faster to use larger data sizes? 64bit, at least?
22:21:32 <vincenz> kzm_: no
22:21:36 <dons> sjanssen: yeah, and minimum, maximum too.
22:21:41 <jfoutz> if i have a list like [1,2,3,4,5] is there a fold that will do successive pairs? i want my function to be called with something like (1,2) (2,3) (3,4) (4,5)
22:21:55 <dcoutts> kzm, vincenz, not unless you're actually on a 64bit arch
22:21:59 <dons> just needs a peekWord8AsWord32 that returns a tuple (w1,w2,w3,w4)
22:21:59 <vincenz> kzm_: cause registers are 32 bit sized, and dma's and memories in general as well as bus's are 32 bit
22:22:03 <vincenz> right, what dons said
22:22:10 <vincenz> err
22:22:11 <vincenz> dcoutts: 
22:22:49 <vincenz> dcoutts: even then it's arguable
22:22:56 <vincenz> dcoutts: cause memory is still word-addressable
22:23:17 <kzm_> how about this for max/min:
22:23:19 <sjanssen> jfoutz: you can write a pairwise fold with foldr
22:23:20 <vincenz> s/addressable/addressed
22:23:41 <jfoutz> sjanssen: thanks, i'll go read up on that
22:24:14 <sjanssen> jfoutz: it'd be a bit tricky, and would involve using Maybe or Either in your accumulator
22:24:39 <jfoutz> oh, lame. i'm probably better off with a simple pattern match then
22:24:49 <kzm_> Is group/groupBy still the slowest operation in Bench?
22:25:05 <dons> ok, already i'm getting a 2x speed up
22:25:22 <vincenz> woo
22:25:29 <kzm_> nice!
22:26:07 <sjanssen> > let f x (Just x', xs) = (Nothing, (x, x'):xs); f x (Nothing, xs) = (Just x, xs) in foldr f (Nothing, []) [1, 2, 3, 4, 5]
22:26:08 <lambdabot> (Just 1,[(2,3),(4,5)])
22:26:28 <sjanssen> jfoutz: how about that?
22:26:36 <jfoutz> well, it misses the overlap
22:26:48 <sjanssen> oh, I didn't see that
22:26:59 <jfoutz> i think i'm just going to use take n, and do the natural recursion
22:27:17 <vincenz> sjanssen: kinky
22:27:46 <jfoutz> but, it's time for bed.
22:27:56 <jfoutz> g'night, and thanks again.
22:28:53 <sjanssen> > zip [1, 2, 3, 4, 5] (tail [1, 2, 3, 4, 5])
22:28:54 <lambdabot> [(1,2),(2,3),(3,4),(4,5)]
22:30:50 <dcoutts> dons, I get some wierd behaviour from ghc/ghci and group
22:30:57 <dons> ?
22:31:18 <dcoutts> dons, when I run the benchmark it works fine, when I run it in ghci (even though it's compiled code) I get a space leak
22:31:24 <dcoutts> dons, more precisely:
22:31:33 <dcoutts> length $ Data.ByteString.group fps
22:31:35 <dcoutts> works fine
22:31:40 <dcoutts> force $ Data.ByteString.group fps
22:31:48 <dcoutts> starts using >1GB heap
22:32:02 <dons> interesting!
22:32:14 <dcoutts> but the same thing is happening when we make runbench
22:32:17 <vincenz> dons: another word for "bugger!"?
22:32:17 <dcoutts> so I don't get it
22:32:33 <palomer> @palomer
22:32:33 <lambdabot> Soylent green is people
22:32:38 <dcoutts> dons, I mean make runbench also uses force
22:32:51 <vincenz> @hoogle force
22:32:51 <lambdabot> Control.Parallel.Strategies.force :: NFData a => a -> a
22:32:51 <lambdabot> System.Console.Readline.forcedUpdateDisplay :: IO ()
22:32:51 <lambdabot> Control.Parallel.Strategies.sforce :: NFData a => a -> b -> b
22:33:32 <vincenz> dcoutts: what's force?
22:33:44 <dcoutts> like deepseq
22:33:45 <Lokadin> what does "parse error in doc string: [TokPara]" mean?
22:33:52 <vincenz> Lazy.hs?
22:34:00 * vincenz can't find it anywhere
22:34:16 <dcoutts> vincenz, in the tests/Bench.hs
22:34:23 <Lokadin> in refernce to haddock compiling with Setup.hs
22:35:34 <vincenz> dcoutts: I would assume it's cause... lenght is lazy while force first asks the length, forcing it all into memory and only then uses the string?
22:39:25 <dcoutts> dons, aargh, it seems so random, it's not always repoducable
22:39:55 <dcoutts> dons, I've had it happen when doing make runbench and also not happen when in ghci
22:39:57 <palomer> night guys
22:41:57 <dcoutts> dons, I've no idea what's going on
22:42:28 <Lokadin> say is there any haddock documentation for haddock? i can't seem to find any on their website
22:45:17 * Lokadin decides he'll just get it from haddock
22:45:55 <dcoutts> dons, looks like force causes a big space leak when not compiling with -O
22:46:09 <dcoutts> but I'm sure I've seen it happen too when using -O
22:46:44 * dcoutts darcs sends fps patches to dons 
22:47:26 <dcoutts> dons, but at least it looks like it's only a problem with the benchmark system and not in the group code
22:52:39 <vincenz> dcoutts: I think it's due to the fact that force requires two things in memory
22:52:45 <vincenz> dcoutts: while length doesn ot
22:53:16 <dcoutts> vincenz, but the optimisatin level changes the behaviour
22:53:16 <vincenz> s/ot/not
22:53:45 <vincenz> dcoutts: lazy consumption of the group-list?
22:54:02 <vincenz> err, or rather
22:54:07 <vincenz> early deallocation of bytestring
22:54:29 <dcoutts> I reckon that with optimisations on, the force doesn't retain all the structure in memory
22:54:43 <dcoutts> while otherwise it does
22:55:02 <vincenz> well... with length
22:55:16 * vincenz thinks
22:55:35 <vincenz> maybe it just finds it easier to deallocate the bytestring halfway when you're also forcing it to gc the list of groups in the case of length
22:55:50 <vincenz> wihle in the case of force, the group list is still needed which has then some resilient link to the bytestring
22:56:33 <Lokadin> @where programatica
22:56:34 <lambdabot> I know nothing about programatica.
22:56:38 <Lokadin> hmmm
22:57:29 * vincenz is off to work
23:00:36 <palomer> programatica looks awesome
23:00:38 <palomer> night!
23:00:46 <Lokadin> what is it?
23:01:02 <Lokadin> palomer: good night
23:01:24 <Lokadin> or were you just stating the time of day?
23:14:41 <Lokadin> ooo, turns out i was using the wrong version of yi all this time :|
23:15:22 <Lokadin> possibly anyways
23:16:09 <sethk> what's the current status of yi?  Is it considered usable?  I've been waiting to try it until I get the word.
23:16:32 <Lokadin> sethk: well it's usable, if you can handle lack of syntax highlighting
23:16:41 <Lokadin> that's a SoC project from what i saw
23:16:47 <sethk> Lokadin, k, thanks
23:17:18 <xerox> @yow
23:17:18 <lambdabot> World War III?  No thanks!
23:17:19 <Lokadin> sethk: np
23:17:25 <Korollary> I think hIDE has highlighting
23:17:51 <Lokadin> @where hide
23:17:51 <lambdabot> http://haskell.org/haskellwiki/HIDE
23:19:54 <sethk> Korollary, hIDE has a different editor?
23:20:13 <sethk> Korollary, and is it considered ready to use for coding?  Not perfect, of course, but usable?
23:20:16 <Korollary> sethk: I think so. It's gtkhs based I think
23:22:03 <Lokadin> :|, i don't really understand why but i used darcs get http://www.cse.unsw.edu.au/~dons/yi 
23:22:13 <Lokadin> however all that is in directory yi is _darcs
23:22:32 <dcoutts> sethk, hIDE is not usable yet, it can't save files :-)
23:22:48 <sethk> dcoutts, hmm, I guess that would be a bit of a problem.  :)
23:23:12 <dcoutts> we didn't want to turn that on 'til we were sure it wasn't going to much your data
23:23:18 <dcoutts> much/munch
23:23:21 <Lokadin> anyone know how i could apply the patches in _darcs/patches
23:23:22 <Lokadin> ?
23:23:35 <sethk> dcoutts, ok, I'll suffer with vim for the moment.
23:25:20 * Lokadin is not very bright at looking at the output of ls
23:35:10 <Lokadin> the stable version has been updated more recently than the devel version
23:36:21 <Lemmih> dcoutts: It could in the old days.
23:37:48 * Lemmih added that feature just before he took it apart.
23:39:47 <Lokadin> @hoogle Data.ByteString.Char8
23:39:47 <lambdabot> No matches found
23:39:49 <dcoutts> Lemmih, ah right
23:40:30 <dcoutts> Lemmih, I should stop hacking on ByteString and get back to releaeing gtk2hs-0.9.11 and then get back to hIDE
23:40:44 <dcoutts> Lemmih, I was thinking a bit more about plugins
23:41:23 <dcoutts> I'm basically looking to find a better abstraction
23:41:36 <dcoutts> but still with just ordinary loadable module style
23:42:07 <dcoutts> but a plugin would be a more specific abstraction in a loadable module
23:42:38 <Lokadin> when i try to compile yi to complains about not being able to load module Data.ByteString.Char8, even though it was configured with fps 0.2 loaded
23:43:18 <Lemmih> Lokadin: You need a newer version of fps.
23:43:26 <Lokadin> oh
23:43:27 <vincenz> greetings Lemmih 
23:43:34 <Lokadin> Lemmih: thanks
23:43:35 <Lemmih> Hiya vincenz.
23:44:57 <Lemmih> dcoutts: Write it on the wiki if/when you figure something out.
23:44:58 <Lokadin> @where fps
23:44:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:45:59 <sethk> what functions are available for formatted output?  I have to print Word32 values padded to the same length.  The max length is 10.
23:47:03 <sethk> it's trivial to write but I think I remember that one exists
23:48:03 <Korollary> Text.Printf?
23:49:08 <sethk> Korollary, sounds like it
23:49:09 <Korollary> You'll need to convert to Integer, tho
23:49:32 <sethk> Korollary, not a problem as long as I can control the length and it doesn't mess up my value
23:56:02 <Lokadin> Could not find module `Data.FastPackedString' :(
23:57:29 <Lokadin> does that mean i have to both have an old and a new version of fps?
