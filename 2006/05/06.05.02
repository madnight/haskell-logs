00:08:48 * palomer will revamp his resume tomorrow
00:09:20 <palomer> well, night
00:16:17 <goltrpoat> later palomer
00:16:51 <goltrpoat> @pl (\m b -> (zipWith (\a c -> a ++ [c]) m b))
00:16:51 <lambdabot> zipWith ((. return) . (++))
00:16:56 <goltrpoat> duh
00:31:20 <lispy> @pl \f -> ((. return) . (f))
00:31:21 <lambdabot> ((. return) .)
00:31:38 <lispy> i expected that to have a name
00:31:56 <lispy> @type ((. return) .)
00:31:57 <lambdabot> forall (m :: * -> *) a c a1.
00:31:58 <lambdabot>       (Monad m) =>
00:31:58 <lambdabot>       (a1 -> m a -> c) -> a1 -> a -> c
00:51:43 <vincenz> hmm
00:51:51 <vincenz> how do you include another directory?
00:53:04 <vincenz> got it
00:55:39 * goltrpoat checks "write the least efficient gauss-jordan implementation in the world" off the list, and moves on to LU
01:09:09 <vincenz> Oejet: ping
01:27:42 <dcoutts> Bulat does come up with some interesting investigations & benchmarks
01:27:55 <dcoutts> see his latest on Optimizing locking with MVars
01:28:04 <dcoutts> on the haskell mailing list
01:28:42 <vincenz> erm
01:28:44 <vincenz> no?
01:28:49 <dcoutts> apparently most of the uverhead of withMVar is due to the exception handler and not the locking
01:29:29 <vincenz> dcoutts: I see nothing on haskell-cafe
01:29:51 <dcoutts> vincenz, that's why I said "the haskell mailing list" rather than haskell-cafe :-)
01:30:07 <vincenz> dcoutts: which one is that?
01:30:14 <dcoutts> the main haskell mailing list
01:30:19 <vincenz> I thought haskell-cafe == haskell mailing lit
01:30:22 <dcoutts> haskell@haskell.org
01:30:36 <dcoutts> vs. haskell-cafe@haskell.org
01:30:40 <vincenz> doh
01:30:50 <vincenz> how do I join?
01:31:02 <dcoutts> vincenz, same way as you joined -cafe
01:31:02 <vincenz> nm found it
01:33:00 <eivuokko> dcoutts, Yeah, that's an interesting mail.  Makes me want to remove block-calls in my ffi stuff and just say they are not async-exception safe.
01:36:37 <xerox> Good morning.
01:37:32 <vincenz> buongiorno
01:39:20 <hoan> hello haskell
01:39:37 <xerox> hi there!
01:39:38 <vincenz> hola
01:39:51 <hoan> xerox copied me
01:40:18 <xerox> Dang.
01:59:21 <vincenz> xerox: c6?
01:59:39 * xerox nods
01:59:52 <vincenz> xerox: how complicated is it to use glade with gtk2hs?
02:00:00 <xerox> It is not complicated.
02:00:02 <vincenz> (and what editor do you use?)
02:00:04 <dcoutts> it's easy
02:00:09 <dcoutts> glade-2
02:00:22 <xerox> Right, or even Gazpacho, if they fixed it (-:
02:00:33 <dcoutts> or glade-3 if they fixed that :-)
02:00:43 <dcoutts> glade-2 is probably still best
02:00:45 <vincenz> okies
02:00:51 <vincenz> and then?
02:00:58 <dcoutts> see the glade demo
02:01:01 <vincenz> will do
02:01:22 * vincenz has to make another gui
02:01:48 * vincenz started glade-2
02:01:57 <vincenz> why does it have a whole project window?
02:02:00 <vincenz> I just want one window
02:02:16 <xerox> dcoutts: I talked with the HOC guys about the SoC, and they have in mind a design for a non-IORef-style GUI layer.  It is pretty OS-X dependent, but it could be worth it talking together one time.
02:03:05 <dcoutts> vincenz, that's ok, you can just make one window. It allows you to have more than one window per-glade xml file that's all.
02:03:09 <dcoutts> xerox, sounds interesting
02:03:54 <xerox> dcoutts: given the Interface Builder tools, it's possible to make "codeless" guis, plugging Haskell in somehow.
02:04:19 <dcoutts> xerox, not sure what you mean
02:05:59 <xerox> dcoutts: in ObjC you have classes and instances, so you draw the GUI, instantiate the classes, and bind those to widgets.  Andre Pang was thinking about some ad-hoc monad to emulate the "instantiated" interface, so that you don't have to write any GUI code at all, just your algorithms and plug them in via the monadic interface.
02:06:01 <kzm> Hmm... my alter ego seems to flutter in and out at will.  (kzm_ is from my home computer, while I am currently at work..)
02:07:44 <dcoutts> xerox, I'd like to see more details of such a design
02:08:11 <xerox> dcoutts: indeed.  This is just what I have understood so far.
02:08:33 <vincenz> how do I resize stuff?
02:08:39 <dcoutts> morning JaffaCake 
02:08:44 <JaffaCake> hiya
02:09:18 <goltrpoat> xerox:  aren't you just talking about data-driven ui?
02:09:21 <goltrpoat> or am i missing something
02:09:42 <dcoutts> JaffaCake, oh I found a sparc niagra livecd, it's basically the recent gentoo 2006.0 + an updated kernel
02:09:51 <dcoutts> http://dev.gentoo.org/~gustavoz/sparc/experimental/
02:09:57 <JaffaCake> cool
02:10:51 <xerox> Hiya JaffaCake 
02:10:59 * JaffaCake waves
02:12:47 <vincenz> dcoutts: for some reason with glade 2 (I have a table of 2 cols, 3 rwos) it makes them equal width, even after I make all the stuff on the right side (buttons and entries)) like 25 pixels
02:14:26 <dcoutts> vincenz, did you set the table to be homogenous?
02:16:23 <vincenz> nope
02:16:25 <vincenz> but I found it
02:16:27 <vincenz> turned off x-expand
02:21:11 <dcoutts> JaffaCake, I'm trying to prepare a ghc patch to turn off gcc's hardened features. This turns out to be quite hard.
02:21:27 <dcoutts> I was hoping you'd give it a quick look over when I'm done.
02:22:02 <dcoutts> It's pretty gentoo-specific unfortunately so we'll only use it locally in the gentoo ebuild
02:22:14 <JaffaCake> sure
02:22:32 <dcoutts> the difficulty is that it's impossible to pick a static set of flags to disable PIE & the stack protector
02:22:45 <dcoutts> because people can change gcc after installing ghc
02:23:10 <dcoutts> and some gcc's don't support the -pie and so also don't support -nopie
02:23:26 <dcoutts> so we need to know if it's supported before trying to disable it
02:24:18 <dcoutts> the plan suggested by the gentoo hardened toolchian dev lead is to pass -specs=${gccinstpath}/vanilla.specs (if that file exists)
02:25:12 <dcoutts> and we need to call gcc --print-search-path to be able to find the gcc install path
02:28:46 <menki> Does anyone know of ghc equivalents of the hugs interact, ansiscreen and ansiinteract libraries?
02:29:03 <xerox> ?type interact
02:29:04 <lambdabot> (String -> String) -> IO ()
02:29:10 <xerox> Do you want something like that?
02:29:46 <vincenz> dcoutts: I only need the .glade, right?
02:29:50 <vincenz> dcoutts: not the .gladep
02:29:51 <menki> really all I need is a clearscreen function that works in windows console
02:29:55 <dcoutts> vincenz, that's right.
02:30:04 <vincenz> alright :)
02:30:37 <xerox> menki: maybe ncurses could do it... I'm not sure.
02:31:30 <vincenz> dcoutts: http://darcs.haskell.org/gtk2hs/demo/glade/Makefile
02:31:34 <menki> there's a haskell port of ncurses?
02:31:37 <vincenz> where is HCNEEDSEXTRAFLAGS defined?
02:31:45 <xerox> menki: there are bindings.
02:31:45 <vincenz> erm
02:31:47 <vincenz> HCNEEDSPACKAGE
02:31:56 <menki> thanks
02:32:14 <xerox> @where hscurses
02:32:14 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
02:32:19 <xerox> There you go!
02:34:52 <menki> it seems like it only works with unix/linux
02:35:06 <goltrpoat> system "cls" :)
02:35:25 <menki> theres a system command?
02:35:35 <menki> that speeds things along
02:35:46 <goltrpoat> in System.Cmd
02:36:00 <dcoutts> vincenz, that gets done by the make installcheck if you're using an older version of ghc
02:36:03 <dcoutts> vincenz, why?
02:38:51 <vincenz> nm
02:40:31 <menki> when I try and use 'do = system "cmd"', I get this error : Not in scope type constructor or class 'GHC.IOBase.ExitCode
02:40:47 <menki> and I have imported system.cmd
02:43:04 <joelr1> good morning! what's the best oracle interface these days? is it hsql or haskelldb?
02:45:37 <vincenz> dcoutts: where do I find a list of the casters?
02:45:45 <xerox> JaffaCake: did you see Ed Wesley's mail about STM?  I'm still going throught it.
02:46:02 <JaffaCake> not yet
02:46:14 <JaffaCake> still wading through my inbox this morning
02:46:32 <JaffaCake> dcoutts: I located the missing Cabal tag, should I push it?
02:46:38 <joelr1> xerox: is that on haskell or haskell cafe /email/?
02:46:54 <xerox> joelr1: no.
02:47:27 <agent_smith> hello, does a german haskell-channel exist (already tried haskell.de)? my english is not very good and i need some advice for handling nested lists
02:47:49 <norpan> ich habe keine ide
02:47:51 <joelr1> so can anyone recommend an interface to oracle /hopefully based on experience/
02:48:04 <norpan> kein anung
02:48:18 <xerox> agent_smith: try here anyway (-:
02:48:43 <ProfTeggy> agent_smith, your English seem sufficiently well -- go ahead
02:48:44 <norpan> joelr1: a haskell interface? haven't heard of any
02:48:49 <ProfTeggy> seems, rather :-}
02:49:01 <joelr1> norpan: there seems to be two: hsql and haskelldb
02:49:04 <xerox> joelr1: IIRC you can acces it via ODBC right?
02:49:24 <joelr1> xerox: no, unfortunately. or at least i think that i can't. don't have a linux odbc driver
02:50:14 <xerox> If it did ODBC you could've used HDBC
02:50:45 <norpan> i didn't know hsql had bindings for oravle
02:50:47 <norpan> oracle
02:51:03 <joelr1> http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
02:51:11 <joelr1> there's also takusen
02:51:57 <norpan> because i checked out hsql some time ago just to interface with oracle
02:52:07 <joelr1> norpan: really?
02:52:11 <norpan> but if it says it's supported then i suppose it is :)
02:52:23 <joelr1> HSQL is a simple library which provides an interface to multiple databases. MySQL, PostgreSQL, ODBC, SQLite and Oracle are currently supported.
02:52:26 <joelr1> dunno
02:52:27 <norpan> yes
02:52:40 <norpan> but i only found bindings for mysql, odbs, postgresql and sqlite
02:52:54 <norpan> but i'm okay anyway because that gave ma a reason to use postgre instead :)
02:53:02 <joelr1> that's misleading
02:53:03 <joelr1> actualy
02:53:19 <agent_smith> ok, i should define a polymorph datatype NestedList a and then write a function nestedElem for this data to look up if an element is in it. i tried to do it like a simiple tree, but always got some errors. perhaps it's a very simple problem, but i searched the haskell-wiki and google and didn't find any examples how to do it right :-(
02:53:20 <joelr1> hmm, or maybe i'm confused
02:53:26 <joelr1> i guess i'll just have to download and see
02:53:34 <norpan> yes, that's the spirit
02:54:02 <xerox> agent_smith: how does the NestedList a type look like?
02:54:20 <dcoutts_> JaffaCake, we found the tag too.
02:54:32 <JaffaCake> oh, I just pushed it
02:54:41 <JaffaCake> what tag did you find?
02:54:48 <dcoutts_> JaffaCake, ok, I'll see if it's the same as the one I got
02:55:13 <dcoutts_> we made a tag by going back to 1.1.3 and adding patches 'til we got the same version as in the 6.4.2 tarball
02:57:17 <xerox> agent_smith: or even, how deep should the lists be nested?
02:57:33 <xerox> agent_smith: e.g. list of lists, or deeper?
02:57:44 <agent_smith> i think deeper
02:58:08 <agent_smith> theoretically infinite deep
02:58:43 <xerox> data NestedList a = List [a] | Nested [NestedList a] -- maybe?
02:59:19 <dcoutts_> JaffaCake, ok, that's fine. I'll add the 1.1.4 tag too which has one extra patch in it (so the cabal standalone makefile works).
02:59:42 <dcoutts_> JaffaCake, I've diffed the two tags and there's only that one makefile patch different.
02:59:45 <agent_smith> xerox: i'm trying this out, one moment pls and thank you so far...
02:59:56 <JaffaCake> dcoutts: ok
03:00:21 <xerox> example = Nested [Nested [List [0,1,2],List [3,4,5]], List [6,7,8]]
03:03:00 <dcoutts_> JaffaCake, what did you think of a new cabal-devel mailing list?
03:03:15 <norpan> the first question is why do you want this NestedList data structure
03:03:50 <yozora> I've been playing with existentials, and it's my understanding you have to define a data type to use them
03:03:58 <xerox> data Tree a = Leaves [a] | Branch [Tree a]
03:04:00 <JaffaCake> dcoutts_: I'm abivalent, the volume on libraries@haskell.org isn't too high
03:04:34 <yozora> there's been some talk of introducing an exists quantifier,
03:05:02 <xerox> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
03:05:03 <yozora> anyone know if that would let you use existentials without introducing the data type?
03:05:31 <hoan> i'm new to haskell too, i've tried this before and got nowhere...
03:05:44 <xerox> hoan: 'this' being what?
03:05:52 <hoan> existentials
03:07:00 <yozora> I understand them, I think, I've been sort of mentally comparing them with OO
03:07:14 <yozora> (and OO comes out worse off) :)
03:08:05 <yozora> the haskell` section on allowing exists in type synonym declarations, does that mean existentials without introducing a new data type?
03:08:22 <yozora> as i understand it, type doesn't actually add anything new
03:08:39 <menki> alright, sweet, I worked out how to make system work the way I want, thanks xerox
03:08:48 <dcoutts_> JaffaCake, that's because we're reluctant to flood it :-). What we really want is a list to have patches sent to so that people can review them.
03:09:06 <yozora> so I'd be able to return exists a. ([a], (a->Int)) from a function
03:09:06 <JaffaCake> ok, fair enough
03:09:11 <dcoutts_> JaffaCake, at the moment patches are sent directly to Isaac.
03:09:21 <JaffaCake> right
03:09:24 <JaffaCake> I'll set it up
03:09:27 <dcoutts_> but he want's to share that job with me
03:09:42 <dcoutts_> and I think it's best for it to be public, to get wider review
03:10:17 <dcoutts_> that's the way we do it with gtk2hs, we've got gtk2hs-users, -devel & -commit
03:10:38 <dcoutts_> Cabal is at least as active as gtk2hs and has more contributers
03:11:10 <dcoutts_> so we keep cabal-users == libraries list, we've already got libraries-cvs
03:11:25 <yozora> hoan, how far did you get with existentials?
03:15:41 <yozora> ah, last example had existential scoping over Either argument
03:18:10 <agent_smith> xerox: i tried "nestedElem e (List x) = elem e x" with "nestedElem e (Nested (x:xs)) = nestedElem e x || nestedElem e (Nested xs)". it works for finding elements, but i get an execption if e is not in the NestedList
03:18:48 <dons> neologism: any figures for how much count is faster than fold?
03:19:04 <dons> 10x ? 100x? :)
03:22:37 <xerox> agent_smith: what exception?
03:23:34 <xerox> agent_smith: ah, you need a base case for (Nested [])
03:24:11 <agent_smith> xerox: oh, my fault, forgot it :-)
03:24:21 <xerox> agent_smith: or even write the second clause as: nestedElem e (Nested xs) = any (nestedElem e) xs
03:25:59 <agent_smith> xerox: thank you very much, it's working
03:26:07 <xerox> agent_smith: nice (-:
03:27:01 <xerox> (One could think of Foldable and Traversable instances for that datatype too.)
03:29:42 <dcoutts_> JaffaCake, 1.1.4 tarball is up and the cabal website has been updated. Ping me when the new dev list is up and I'll announce it along with 1.1.4.
03:29:53 <JaffaCake> ping :)
03:29:57 <dcoutts_> ta :-)
03:30:03 * dcoutts_ subscribes himself
03:32:17 * xerox too
03:53:31 <vincenz> re
03:55:47 <dcoutts_> JaffaCake, so we intend to make the list the target for cabal's darcs send, so we'll probably get non-subscribers sending patches to the list.
03:56:01 <vincenz> @seen shapr
03:56:01 <lambdabot> I saw shapr leaving #scannedinavian, #haskell-overflow, #haskell-blah, #haskell and #ScannedInAvian 4 hours, 25 minutes and 55 seconds ago, and .
03:56:09 <dcoutts_> JaffaCake, how should we deal with that? make it open? moderated for non-subscribers?
03:56:16 <vincenz> dons: ping!
03:56:28 <JaffaCake> dcoutts_: right, moderated for non-subscribers is the way to go
03:56:38 <JaffaCake> and somebody has to do the moderation
03:56:54 <dcoutts_> JaffaCake, I guess SyntaxNinja or I could do it.
03:57:01 <JaffaCake> generally you whitelist somebody the first time they send a patch
03:57:05 <dcoutts_> is it easy?
03:57:11 <JaffaCake> it's dead easy with mailman, yes
03:57:23 <dcoutts_> how does it work? do I get sent an email?
03:57:25 <JaffaCake> moderation is a minor PITA
03:57:45 <vincenz> dcoutts_: gtk2hs ml?
03:57:52 <JaffaCake> do you want to be a moderator?  I set Isaac as the list owner, he'd have to add you I think
03:58:11 <dcoutts_> JaffaCake, if Isaac doesn't minde then yeah, fine.
03:58:12 <dons> vincenz: ?
03:58:20 <JaffaCake> there's a web interface for moderation
03:58:37 <vincenz> dons: bug in lambdabot... Lambdabot.hs
03:58:45 <dcoutts_> vincenz, huh?
03:58:47 <JaffaCake> you get a list of messages, manually accept those you want to keep and discard the rest
03:58:52 <dons> vincenz: got the latest src?
03:58:53 <vincenz> dcoutts_: what are you two talking about?
03:58:55 <vincenz> dons: yeah...
03:59:01 <dons> yep, do tell then?
03:59:04 <vincenz> dons: checkRecip... it checks the target... and compares the end with bot
03:59:04 <dcoutts_> vincenz, a new cabal-devel mailing list
03:59:13 <vincenz> dons: I had oasisbot in #oasisbot, and it would not respond to anything
03:59:19 <vincenz> dcoutts_: ah, alright :)
03:59:34 <dcoutts_> JaffaCake, so is the new list currently set to being moderated by Isaac?
03:59:34 <JaffaCake> dcoutts_: I subscribed the list to GMane too, hope it worked
03:59:41 <vincenz> dons: might want to check who is actually a user and not a channel
03:59:43 <JaffaCake> dcoutts: yes
03:59:45 <dons> vincenz: ok. i'll have a look. note that lambdabot is runnign the same code.. so maybe you're not registered or identified?
03:59:57 <dcoutts_> JaffaCake, ok great. (I'm just writing the announcement email)
04:00:03 <vincenz> dons: nono, it was working fine in #oasis, not in #oasisbot
04:00:11 <vincenz> dons: and I bet it's checkRecip ni Lambdabot.s
04:00:17 <vincenz> .hs even
04:00:48 <vincenz> dons: for the rest I'm very pleased, it's no longer crashing and is VERY stable
04:01:13 <vincenz> hmm...odd
04:01:50 <vincenz> nm
04:02:08 <vincenz> anyways, yeah I now have it in #oasislog iso #oasisbot so it's nothing really high priority
04:02:29 <dons> ok. cool.
04:02:52 <dons> JaffaCake: going to have a look at ByteString today ? ;)
04:03:06 <vincenz> @seen alar
04:03:06 <lambdabot> I saw alar leaving #haskell 1 month, 18 hours, 1 minute and 14 seconds ago, and .
04:03:06 <JaffaCake> I hope so
04:03:08 <vincenz> o.O
04:03:14 <JaffaCake> busy w/ ICFP reviewing too
04:03:35 <dons> JaffaCake: ok good. i have a couple more patches up my sleeve to add group and groupBy (actually, sjanssen submitted them)
04:03:38 <vincenz> JaffaCake: ooh nice
04:03:38 <dons> ah ICFP. right
04:03:55 * vincenz is anxiously waiting for the icfp contest :D
04:04:10 <tromp> when is that?
04:04:16 <urthaur> why
04:04:27 <vincenz> tromp: icfp contest/
04:04:33 <urthaur> why
04:04:34 <vincenz> tromp: 21-24 july
04:04:34 <kosmikus> JaffaCake: I know the feeling ;)
04:04:40 <urthaur> why
04:04:45 * vincenz peers at urthaur 
04:04:47 <tromp> thx
04:04:51 <vincenz> tromp: check this out
04:04:54 <urthaur> why
04:05:00 <JaffaCake> kosmikus: heh
04:05:05 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
04:05:20 <vincenz> especially the Team
04:05:31 <urthaur> why
04:06:10 <vincenz> urthaur: feeling ok?
04:06:50 <urthaur> why
04:07:32 <tromp> put a lid on it...
04:07:59 <sonnenschein> why
04:08:40 * vincenz rolls his eyes
04:08:56 <vincenz> for those wishing to ignore: i=JavaUser@84-72-40-171.dclient.hispeed.ch
04:10:15 <vincenz> tromp: taken a look at the site?
04:11:23 <dons> is it just me, or are there more annoying people on the internets these days?
04:11:48 <vincenz> dons: I don't know, i guess it comes and goes
04:13:03 <dons> yeah, maybe. or maybe we've been enjoying the quiet time since you had to register and identify on freenode.
04:13:22 <vincenz> nah... I think the era of spamming irc has been past a bit... depasse
04:13:30 <vincenz> I guess it lost it's appeal
04:13:31 <tromp> looking now
04:13:44 <dons> vincenz: there were 2 this week though :)
04:13:52 <vincenz> well ups and downs
04:13:54 <dons> hence some of us having been op'ing up
04:14:09 <vincenz> dons: just as long as you don't d'op'e up
04:14:25 <dons> right :)
04:15:01 <vincenz> dons: btw what has changed to lambdabot in teh last few eweeks that he's suddenly so very stable
04:15:13 <vincenz> was it the ping-pong effect?
04:15:22 <dons> i chased some bugs down :)
04:15:45 <dons> and tried to sanify the main loop and exception handling a bit
04:16:00 <dons> mostly of offline mode, but the side effect is that she handles better online
04:16:06 <vincenz> :)
04:16:29 --- mode: ChanServ set -o dons
04:16:50 <dons> maybe we don't need this all the time.
04:17:24 <vincenz> feels annoying, doesn't it?
04:17:42 <vincenz> tromp: wanna join?
04:18:15 <vincenz> tromp: I'll need a md5 key (mkpasswd --hash=md5)  and a pubkey for the ssh to darcs repo
04:18:30 <vincenz> tromp: active channel = #oasis, darcs repo watch channel = #oasislog
04:18:39 <vincenz> md5 key is for wiki
04:18:44 <vincenz> so you have read/write access
04:27:27 <menki> is there any simple way to move a value to the left or right in a list?
04:27:49 <vincenz> menki: how do you fifnd the value?
04:27:55 <vincenz> by value
04:27:56 <vincenz> ?
04:28:16 <menki> by position within the list
04:28:19 <vincenz> oh
04:28:21 <menki> or by value
04:28:22 <vincenz> hmm
04:28:23 <menki> both are good
04:28:26 <tromp> it's simple but slow (linear in position)
04:28:29 <vincenz> yep
04:28:31 <vincenz> what tromp says
04:29:13 <tromp> i can join, but i'll be with my gf in canada in july
04:29:36 <tromp> won't be able to participate full time
04:29:41 <menki> is it faster to do by value?
04:29:54 <tromp> but wld be happy to do code review and algorithmic optimization
04:29:59 <vincenz> tromp: kewl :)
04:30:02 <vincenz> tromp: so yeah
04:30:14 <vincenz> tromp: md5 pw for wiki and pubkey for ssh
04:30:33 <menki> what about simply setting a value at a position in a list?
04:31:32 <tromp> haskell has no notion of setting for lists
04:31:39 <tromp> lists are immutable
04:32:01 <tromp> e.g. to swap first two elements, you return a new list
04:32:18 <vincenz> and even if you did... for instance by having a list of references, you'd still have a linear time to get to the position
04:32:19 <tromp> \(a:b:r) -> b:a:r
04:33:09 * pesco is getting a dizzy head from reading Oleg "messages".
04:33:11 <tromp> my linux box has no mkpasswd:(
04:33:12 <joelr1> is ghc 6.5 darcs-gettable?
04:33:21 <menki> that just gave me an idea
04:33:35 <vincenz> tromp: it doesn't o.O?
04:33:47 <tromp> not according to whereis
04:33:54 <vincenz> tromp: ok...make an ssh pubkey first, ssh to my box and then do mkpasswd on my box ;)
04:34:04 <vincenz> technical details for ssh are on Technical Details page
04:34:12 <vincenz> (I don't use port 22)
04:35:02 <tromp> also, i have yet to buy the machine i'll be connecting from in canada...
04:35:55 <vincenz> hmm
04:36:04 <vincenz> wel privkeys are transportable
04:36:09 <vincenz> just generate specifically for this
04:36:19 <vincenz> you can choose keys per site in .ssh/config
04:36:21 <joelr1> JaffaCake: ping
04:36:33 <vincenz> and put it on a usbstick
04:36:38 <JaffaCake> pong
04:38:19 <joelr1> JaffaCake: can i get 6.5 using darcs? i have a linux amd box, 2x 2Ghz and 16Gb of memory
04:38:32 <JaffaCake> sure
04:38:32 <joelr1> so i want to try to make use of shared multiprocessing
04:38:54 <JaffaCake> http://hackage.haskell.org/trac/ghc/wiki/GhcDarcs
04:39:12 <joelr1> i was just looking at that page
04:39:24 <joelr1> but it was not clear to me if it was 6.4 or 6.5 that i would be getting
04:39:34 <dons> 6.4 branch is in cvs, not darcs.
04:39:43 <joelr1> great
04:39:49 <dons> so yep. you get 6.5 :)
04:41:00 <joelr1> thanks
04:42:34 <joelr1> i have an interesting problem on my hands that i want to try to solve using haskell. oracle cannot cope :D
04:42:42 <Oejet> How well is Darcs working for GHC so far?
04:43:20 <joelr1> lisp is too tough multi-threading-wise
04:58:18 <vincenz> dcoutts_: ping
05:02:16 <joelr1> hmm
05:02:32 <joelr1> my 6.5 build is failing on some silly issue
05:02:42 <joelr1> g    cmm/CmmLex.x
05:02:42 <joelr1> make[1]: g: Command not found
05:02:46 <joelr1> what is this?
05:03:13 <joelr1> RTS -K2m -RTS -agc    cmm/CmmParse.y
05:03:13 <joelr1> make[1]: RTS: Command not found
05:03:22 <Lemmih> joelr1: Did configure find happy?
05:03:29 <hoan> hey everyone, i managed to make hws use ByteString (dons will be interested), and its faster than before, but not as fast as apache (very limited testing)
05:03:34 <joelr1> oh
05:03:46 <joelr1> Lemmih: i did not check, thanks for the pointer
05:05:18 <vincenz> ok stupid question
05:05:23 <vincenz> I have a list of elements of type a
05:05:26 <vincenz> and I have a function
05:05:28 <vincenz> a -> Render ()
05:05:32 <vincenz> (so monadic)
05:05:43 <vincenz> now I want to apply this function and sequence it
05:05:44 <vincenz> sure, easy
05:05:54 <vincenz> sequence_ $ map function $ listofelements
05:05:58 <vincenz> however
05:06:08 <vincenz> this function has two more arguments, and I want one to increase as I go up the list
05:06:20 <vincenz> (basically I want to draw a set of elements next to each other, each time updating the x position
05:07:05 <vincenz> @type scanl1
05:07:06 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
05:07:13 <vincenz> @type scanl
05:07:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
05:07:21 <vincenz> aha!
05:07:38 <vincenz> hmm nope that won't do it
05:09:45 <vincenz> renderSequence :: [Element] -> Render(),  renderElement :: Double -> Double -> Element -> Render )(
05:09:58 <vincenz> I want to map renderElement over renderSequence but basically increment x each time by a fixed value
05:10:11 <vincenz> over the list that renderSequence gets even
05:10:32 <vincenz> the only thing I can think of is
05:10:48 <vincenz> renderSequence l = renderSequence' 0 l where renderSequence n x:xs = ....
05:10:58 <vincenz> and then have a recurisve function, but it's not really clean
05:13:08 <shapr> joelr1: Sources are up, did you see?
05:13:30 <joelr1> shapr: nope, got a link? they are keeping promises :-) 
05:13:48 <vincenz> shapr: we have a test framework \o/
05:13:52 <shapr> vincenz: cool
05:14:00 <vincenz> thx to jyp
05:14:00 <shapr> joelr1: It's on LtU.
05:14:02 <joelr1> vincenz: creating a software renderer?
05:14:13 <vincenz> joelr1: hmm? no... Render is the monad of cairo
05:14:21 <joelr1> ah, ok
05:14:23 <shapr> JaffaCake: Peng Li's thread/event unification sources are online.
05:14:29 <vincenz> just making a gui thhat draws some stuff for me
05:14:43 <joelr1> shapr: i don't see any new posts on LtU
05:14:48 <joelr1> should i check the thread?
05:14:50 <shapr> It's a comment to the original post.
05:15:11 <Lemmih> JaffaCake: Hiya. I'd like to talk about the tagging of closures in GHC.
05:15:23 <joelr1> shapr: i see it now, thanks!
05:21:25 <ewsu> Someone who got good experience with Haskell, and can answer some general questions?
05:22:27 <kzm> ewsu, ask the questions, and find out?
05:22:34 <dcoutts_> vincenz, pong
05:23:19 <vincenz> anyway to clean up this: http://rafb.net/paste/results/hep9hM70.html
05:23:20 <ewsu> If so, I would like to know this: Can Haskell be trusted to be used in an industrial product, or is it still a baby that cannot walk?
05:25:05 <vincenz> @type sequence
05:25:06 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
05:25:18 <audreyt> ewsu: GHC has been in use for industrial products for some time.
05:25:24 <audreyt> I can't speak of other implementations
05:25:44 <ewsu> GHC is a copiler?
05:25:50 <audreyt> yeah.
05:25:52 <audreyt> haskell.org/ghc/
05:26:12 <ewsu> ok, thanks. I will read.
05:27:03 <vincenz> @type foldr
05:27:04 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
05:28:19 <ewsu> btw, before I leave, can you point me to a product where Haskell has the main function?
05:29:31 <audreyt> ewsu: http://homepages.inf.ed.ac.uk/wadler/realworld/
05:31:46 <ewsu> thanks
05:32:58 <audreyt> np :)
05:39:59 * dcoutts_ announces the new cabal-devel@haskell.org mailing list
05:40:55 <dcoutts_> sign up at http://haskell.org/mailman/listinfo/cabal-devel
05:41:22 <dcoutts_> it's for Cabal development discussion and patch review
05:41:54 <dcoutts_> so if you contribute to Cabal or might like to then sign up
05:42:05 * dcoutts_ pimps Cabal
05:42:19 <shapr> Will there be a gmane.org group as well?
05:42:23 <vincenz> dcoutts_: question regarding scroll-areas
05:42:27 <dcoutts_> shapr, yep, already done
05:42:31 <shapr> spiffy
05:42:37 <dcoutts_> shapr, thanks to JaffaCake.
05:42:43 <shapr> ewsu: darcs is nifty
05:42:43 <vincenz> dcoutts_: if I put a drawing area in a scroll area, how does it know the extent of the drawing area?
05:43:02 <dcoutts_> vincenz, the drawing area has a size, as does every widget
05:43:11 <dcoutts_> vincenz, you can set the size of the drawing area
05:43:20 <vincenz> so basically I'd reset it whenever I change what is being drawn
05:43:35 <vincenz> cool, thanks :)
05:43:36 <dcoutts_> yes, if the size changes
05:47:05 <vincenz> dcoutts_: 
05:47:05 <vincenz> (iterators:18466): Gtk-WARNING **: gtk_scrolled_window_add(): cannot add non scrollable widget use gtk_scrolled_window_add_with_viewport() instead
05:48:08 <dcoutts_> vincenz, do what it says
05:48:23 <dcoutts_> scrolledWindowAddWithViewport
05:48:26 <vincenz> erm
05:48:28 <vincenz> I'm using glade
05:48:59 <dcoutts_> glade automagically puts a viewport inside the scrolled window
05:49:04 <vincenz> apparently not
05:49:16 <dcoutts_> if you add a widget to the scrolled window
05:49:21 <dcoutts_> ok well do it yourself
05:49:24 <vincenz> hmm
05:49:24 <dcoutts_> in glade
05:49:27 <vincenz> how?
05:49:37 <vincenz> put a viewport in the scroll window
05:49:38 <dcoutts_> put a viewport in the scrolled windo
05:49:38 <joelr1> Lemmih: so i installed happy but i still can't find the g command. why would that be?
05:49:42 <vincenz> and then the drawing area in the viewport?
05:49:45 <dcoutts_> right
05:49:47 <vincenz> okies
05:50:15 <joelr1> trying to make clean and redo
05:50:29 <vincenz> woo, thx
05:51:32 <vincenz> dcoutts_: how to set the size?
05:51:53 <vincenz> I can't find it in drawingArea nor widget
05:52:25 <dcoutts_> setSizeRequest I think
05:52:25 <joelr1> rrrr, missing alex
05:54:17 <shapr> Is there a ghc 6.5 deb?
05:55:36 <dcoutts_> shapr, if you used gentoo you could use the ghc-darcs ebuild :-)
05:56:01 * shapr is too little to use Gentoo
05:56:15 <dcoutts_> nah
05:57:48 <vincenz> dcoutts_: two more questions A) feasible to limit input to textbox to be numeric?  B) how to make ENTER do something if I press enter in a textbox (textEntry)
05:57:51 * kolmodin subscirbes to cabal-devel
05:58:25 <dcoutts_> vincenz, hmm, it might be possible to intercept the input and do some validation
05:58:37 <vincenz> dcoutts_: yeah I feared such... and the Enter thingy?
05:58:54 <dcoutts_> vincenz, you might find that the activate signal will do it
05:59:00 <vincenz> kewl
05:59:04 <vincenz> dcoutts_: sorry for all the small questions
05:59:15 <dcoutts_> s'ok
05:59:49 <dcoutts_> vincenz, the gtk api tells you most of this stuff
05:59:57 <dcoutts_> I'm partly guessing
06:00:02 <vincenz> dcoutts_: ah.. :)
06:00:10 <vincenz> but erm...
06:00:13 <vincenz> didn't you write gtk2hs
06:00:20 <vincenz> or did you automate the generation of the wrapper?
06:00:30 <dcoutts_> I'm not that familiar with every last gtk function, there are >1000 of them
06:00:40 <dcoutts_> and we did automate some of it
06:00:58 * vincenz noddles
06:01:18 <dcoutts_> what I really know about is the memory management and api style etc, rather than actually how to use it :-)
06:01:22 <vincenz> i do hope that gtk docs do become more manageable
06:01:24 <vincenz> or searcahble
06:01:26 <dcoutts_> other people write more gtk apps that I do
06:01:27 <vincenz> it's impossible to find a function now
06:01:36 <vincenz> or just an index
06:01:38 <dcoutts_> we want to make them hooglable
06:01:46 <dcoutts_> and cut down on uselss stuff
06:01:57 <dcoutts_> there is an index of course
06:02:27 <vincenz> tehre is???
06:02:45 <dcoutts_> the haddock docs have a contents and an index
06:03:41 <vincenz> not by functoin
06:03:58 <dcoutts_> yes, the index
06:04:08 * vincenz did index.html to no avail
06:04:09 <dcoutts_> everything by name, sorted
06:04:26 <vincenz> ah there
06:04:32 <vincenz> :D
06:04:56 <dcoutts_> http://haskell.org/gtk2hs/docs/current/doc-index.html
06:05:06 <dcoutts_> http://haskell.org/gtk2hs/docs/current/index.html
06:05:13 <dcoutts_> index & contents
06:06:06 <shapr> @seen skew
06:06:07 <lambdabot> I saw skew leaving #haskell 11 hours, 10 minutes and 3 seconds ago, and .
06:10:33 <vincenz> hmm
06:10:51 <vincenz> parsec... how hard to use it for vertically-layed out code parsing/
06:11:14 <ihope> Like Haskell? :-)
06:11:15 <dcoutts_> JaffaCake, re a hyopthetical 6.4.3, would you want the same Cabal for that or could we get away with another update to get more recent fixes/features/api-wibbles?
06:11:45 <ihope> But I guess the Haskell preprocessor handles that.
06:11:50 <ihope> > (
06:11:50 <lambdabot>  parse error on input `}'
06:12:01 <ihope> Otherwise there would be no mention of }.
06:15:53 <joelr1> can i install cabal locally, without root permission?
06:16:19 <dcoutts_> yes
06:16:44 <joelr1> how do i do that exactly, because it wants to copy the package to /usr/local/...
06:16:53 <Igloo> dcoutts_: Half the point is to have a different cabal, surely?
06:17:08 <joelr1> i did copy --copy-dir=... but now i need to point register to that directory somehow, no?
06:17:23 <dcoutts_> Igloo, huh?
06:17:50 <Igloo> dcoutts_: re 6.4.3
06:18:39 <dcoutts_> Igloo, oh, well JaffaCake was talking about a possible .3 for other reasons (bugs on Solaris,BSD)
06:19:13 <dcoutts_> but SyntaxNinja was talking about trying to get an updated Cabal into any .3 release
06:20:10 <musasabi> Cabal should really get a freezed API.
06:20:16 <dcoutts_> joelr1, are you installing Cabal itself or some other cablised package?
06:20:24 <dcoutts_> musasabi, but which one?
06:20:30 <joelr1> dcoutts_: cabal itself
06:20:33 <musasabi> It is very painful to have multiple packages all depending on different Cabal versions.
06:20:58 <dcoutts_> musasabi, there are improvementes we need to make which sometimes break the hooks api
06:21:07 <joelr1> dcoutts_: i hid the global cabal 1.0, as per instructions but now can't install the local one in my home directory 
06:21:38 <musasabi> dcoutts_: trying to make the old one available in addition to the new one would be nice.
06:21:50 <dcoutts_> joelr1, so you're using the makefile to install
06:22:02 <dcoutts_> musasabi, that can be done by having the old cabal installed too
06:22:27 <joelr1> dcoutts_: no, i compiled myself ./setup and built it
06:22:39 <dcoutts_> joelr1, ok then use --user
06:22:41 <joelr1> dcoutts_: then i did the ./setup copy
06:22:46 <musasabi> dcoutts_: hmm, is multiple versions of Cabal for one GHC supported at last?
06:22:49 <joelr1> dcoutts_: install --user?
06:23:12 <dcoutts_> joelr1, check --help to see if you need it for install or configure or both. I forget
06:23:19 <dcoutts_> musasabi, yes
06:23:49 <dcoutts_> musasabi, well it should work, it worked in 6.4.1 except for some bad error messages
06:24:14 <joelr1> dcoutts_: you are absolutely right, it takes some time for me to get back into the haskell grove :-)
06:24:17 <joelr1> groove
06:24:40 * dcoutts_ wonders what a haskell grove might look like
06:24:51 <dcoutts_> sprouting lambdas all over the place probably
06:25:01 <joelr1> dcoutts_: does not work, 
06:25:02 <joelr1> ./setup configure --user
06:25:10 <joelr1>  ./setup install --user
06:25:17 <joelr1> setup: /usr/local/lib/Cabal-1.1.4: createDirectory: permission denied (Permission denied)
06:25:26 <dcoutts_> you need to specify an install location
06:25:44 <dcoutts_> the --user is for where to register, either globally or per-user
06:25:55 <dcoutts_> see ./setup configure --help
06:25:56 <joelr1> it tells me that --install-prefix is deprecated and that i need to use copy
06:26:15 <joelr1> so i did the copy but now how do i register the package? or do i need to do the copy again after reconfiguring?
06:26:18 <joelr1> wierd
06:26:38 <dcoutts_> it's just like ./configure; make; make install
06:26:47 <dcoutts_> you specify where to install to at configure time
06:28:04 <joelr1> finally! :) got t
06:28:05 <joelr1> thanks
06:28:06 <vincenz> anyone here that worked on hide?
06:28:10 <dcoutts_> yep
06:28:30 <vincenz> how does the highlighting work?
06:28:39 * vincenz has a textBox that he wants to highlight parse-errors in
06:28:45 <dcoutts_> using a lexer derived from the ghc one
06:29:05 <dcoutts_> vincenz, or you can use the SourceView widget
06:29:16 <dcoutts_> it's probably easier
06:29:18 <vincenz> it's not haskell tho
06:29:22 <joelr1> ugh, this is ugly
06:29:57 <dcoutts_> vincenz, true, but it makes defining the highliting language easy
06:30:13 <vincenz> kwel
06:30:21 <joelr1> ghc -package Cabal-1.1.4 Setup.lhs -o setup
06:30:25 <vincenz> dcoutts_: no I meant the language I'm parsing isnt haskell
06:30:27 <joelr1> Setup.lhs:7:28: Module `Distribution.Setup' does not export `BuildFlags'
06:30:36 <joelr1> what does this mean? do i need a newer copy of alex?
06:30:47 <joelr1> or to use cabal differently?
06:30:53 <vincenz> dcoutts_: how hard is it to do vertical parsing?
06:31:03 <dcoutts_> vincenz, the SourceView widget has an xml file to define the highliting
06:31:13 <dcoutts_> vincenz, you mean layout?
06:31:17 <vincenz> yeah
06:31:22 * vincenz is planning to use parsec this time
06:31:27 <vincenz> don't feel like going the whole happy alex route
06:31:33 <vincenz> the language is rather simple
06:31:56 <dons> hoan, that's interesting
06:32:01 <dons> have you seen HAppS?
06:32:23 <dons> musasabi's http server in there uses ByteString and outperforms apache, I think.
06:32:55 <dons> hoan, I'd expect with a bit of profiling, and carefully replacing some functions with more specialised ByteString versions, you should be able to improve things
06:33:12 <joelr1> i'm always suspicious of haskell web servers outperforming apache. i think the comparison is lopsided since the haskell servers _must_ use far more memory 
06:33:13 <dons> hoan, in particular, if you post a -prof output, I can give you some hints.
06:33:31 <dons> far more? not sure that's going to be true.
06:33:58 <dons> particularly in these days of packed strings.
06:34:08 <musasabi> joelr1: things are looking better and with 6.5 and ForeignPtr optimizations we are getting better each month.
06:34:33 <dons> musasabi: did you see hoan's comment on rewriting hws to use ByteString?
06:34:42 <dcoutts_> joelr1, dunno about alex. The alex I use doesn't use cabal at all.
06:35:01 <musasabi> joelr1: sure we might require some more memory but throwing 1gb -> 2gb memory is cheaper than to pay someone to optimize code usually.
06:35:11 <joelr1> musasabi: i'm with you, i just think the claims are not always... umm... all-encompassing :D
06:35:28 <dons> well. faster than apache, doesn't mean less memory than apache :)
06:35:41 <joelr1> dcoutts_: it does seem to use cabal
06:35:44 <kzm> joelr1, why must they use more memory?
06:35:57 <dcoutts_> joelr1, what verson of alex is that?
06:36:10 <kzm> (oh, I guess dons/musasabi covered it)
06:36:39 <joelr1> the darcs version
06:36:41 <kzm> anyway, apache isn't too high performance, is it?  At least, it's my impression that there are faster servers.
06:36:49 <joelr1> just got the tarball and that comes with configure
06:36:50 <vincenz> anyone... vertical parsing with parsec?
06:36:53 <musasabi> kzm: we must use more memory, because e.g. overhead of a ByteString vs apache strings.
06:36:58 <dons> musasabi: I actually tried the IORef-less ForeignPtr improvement JaffaCake hinted at on the libraries@ list. Got maybe another 10% for benchmarks like inits that allocate a lot.
06:37:31 <kzm> musasabi, what is the overhead?  (Yes, I really should know, but...)
06:37:56 <dons> JaffaCake: ^^ see above. I think it might be worth adding the PlainMallocPtr without IORef finalziers to the ForeignPtr code. I tried it with some good results on benchmarks with lots of strings. I can submit a patch if you'd like.
06:38:10 <JaffaCake> sure, please do
06:38:21 <musasabi> dons: what about GC overhead? omitting IORefs is going to help there too, although in 6.5 there is already the moving unaltered IORefs to old generation optimization.
06:38:21 <kzm> as the basic storage is an array of bytes, it shouldn't be much worse.
06:38:27 <JaffaCake> did you add a different way to create these ForeignPtrs?
06:38:34 <joelr1> has anyone implemented a cache datastructure with eviction?
06:38:49 <musasabi> kzm: there is a constant overhead for each ByteString.
06:39:02 <dons> no, but I think a mallocPlainPtr or something similar would be useful, yes. or a newPlainForeignPtr perhaps.
06:39:28 <dons> I just added enough for the mallocArray stuff in ByteString to use the IORef-less code. But its not much work to extend
06:39:41 <vincenz> anyone?
06:39:54 <JaffaCake> dons: the thing is, we can't use this optimised rep in general, because it breaks the properties that ForeignPtr is supposed to have w.r.t ordering of finalizers added with addForeignPtrFinalizer
06:40:00 <dons> right.
06:41:49 <vincenz> how do I do vertical layouting?
06:41:50 <JaffaCake> although, I did wonder about making addForeignPtrFinalizer use StableNames which would fix it again, but decided it was too much work given that nobody really cares about ordering of addForeignPtrFinalizers on these ForeignPtrs
06:41:54 <musasabi> dons: maybe use something like data ByteString = PS Addr# Int Int OptimizedForeignPtrContents ?
06:43:07 <dons> musasabi: that's basically it. Though I only tried: dataForeignPtrContents = ... | PlainMallocPtr (MutableByteArray# RealWorld)
06:43:57 <dons> musasabi: actually stepping inside the ForeignPtr guts like that seems a bit scary.
06:44:33 <dons> since we do need normal ForeignPtrs for a lot of the C interfacing stuff anyway.
06:44:52 <kzm> dons: what are the two Ints in the ByteString?
06:45:13 <dons> offset and length. to support slices.
06:45:21 <dons> i.e. O(1) substrings
06:45:56 <kzm> okay, so the string is basically ptr+a..ptr+a+b-1? 
06:46:12 <dons> yup
06:46:42 * vincenz hmms
06:47:01 <kzm> I'm thinking about UTF-8 (and other variable lenght encodings).
06:47:24 <kzm> Wonder if it'd make sense to keep a lazy list (or similar) of all multi-byte characters?
06:47:40 <dcoutts_> kzm, why?
06:47:40 <musasabi> kzm: implement ISO-2022-JP, after that most things look easy.
06:47:49 <dons> hehe
06:47:51 <xerox> çŒ«!
06:48:12 <kzm> dcoutts, for many uses, it probably could be left unevaluated.
06:48:13 <kzm> maybe
06:48:18 <dons> kzm, have you seen JaffaCake's UTF-8 code?
06:48:41 <dons> here: www.cse.unsw.edu.au/~dons/packedstring.tar.gz
06:48:54 <dcoutts_> kzm, I think one just has to accept that one can't do indexed operations on such encodings
06:48:58 <dcoutts_> only folds
06:48:59 <kzm> Ah thanks.  I googled, but didn't find that one.  Found some others.
06:49:31 <kzm> Hmm.. i think it'd be a shame not to support indexing, though.
06:49:38 <musasabi> indexed operations can be implemented with a fold.
06:50:18 <dons> musasabi: talking to some people today, i've got an idea to use some array fusion tricks from the nested data parallel stuff to fuse multiple ByteString functions. 
06:50:46 <ndm> dons, are your ByteStrings a win for shorter strings?
06:50:49 <dons> hopefully we gain squeeze some more out, with nice rewrite rules to fuse map . fold and friends 
06:51:05 <ndm> I'm just trying to figure out which bits of Hoogle to move to ByteString
06:51:19 <musasabi> getN :: Int -> ByteString -> Maybe Char; getN i ps = foldl (\(ci,r) ch -> if ci == i then (ci+1,Just ch) else (ci+1,r)) (0,Nothing) ps
06:51:20 <dons> ndm, seems fairly so. and hoogle's not so short..
06:51:22 <kzm> If multi byte chars are rare, it would probably still be worth it to keep an index of them.
06:51:34 <musasabi> (+ optimization)
06:51:53 <ndm> dons, Hoogle 4 has binary files, so it doesn't use as much string processing as before
06:52:07 <musasabi> kzm: that is going to break for a text with all the characters being multibyte.
06:52:23 <dons> musasabi: right! that looks roughly like the fusion function, yeah? a combination of map/filter and an accumulator
06:52:24 <ihope> @hoogle Eq a => [a] -> [a] -> Maybe [a]
06:52:24 <lambdabot> No matches, try a more general search
06:52:49 <dons> ndm, I'd think it will almost certainly be faster. try it out.
06:52:51 <ihope> @hoogle Eq a => IO [a]
06:52:52 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
06:52:52 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
06:52:52 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
06:53:04 <ndm> ihope, the web interface gives an ENTIRELY different answer to your query
06:53:10 <ndm> lots and lots of matches
06:53:14 <ihope> Hmm...
06:53:14 <ndm> which is weird....
06:53:14 <dons> ndm, here's a little example of what to expect :
06:53:16 <dons> ?wiki Wc
06:53:16 <lambdabot> http://www.haskell.org/haskellwiki/Wc
06:53:29 <ndm> dons, yeah, i saw that (its very impressive!)
06:53:30 <kzm> musasabi, true.  Then you'd be better off converting to a fixed multi byte format.
06:53:53 <ndm> dons, how come the following hoogle query is misbehaving on lamdabot
06:53:56 <ndm> @hoogle Eq a => [a] -> [a] -> Maybe [a]
06:53:57 <lambdabot> No matches, try a more general search
06:54:01 <dons> oh it is? hmm.
06:54:03 <ndm> http://haskell.org/hoogle/?q=Eq+a+%3D%3E+%5Ba%5D+-%3E+%5Ba%5D+-%3E+Maybe+%5Ba%5D
06:54:09 <dons> ?hoogle map
06:54:09 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
06:54:10 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
06:54:10 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
06:54:19 <dons> ndm, its an out of date hoogle, perhaps?
06:54:22 <ihope> > pruduct [0..]
06:54:23 <lambdabot>  Not in scope: `pruduct'
06:54:27 <ihope> > product [0..]
06:54:31 <lambdabot> Terminated
06:54:32 <ndm> dons, i think yours is pretty current
06:54:38 <ndm> it should never have done that
06:55:00 <dons> ndm, just check in the lambdabot scripts/hoogle repo. I should probably just resync it
06:55:09 <ihope> Anyway, I'm looking for a function that drops one list off the beginning of another.
06:56:01 <dons> dropPrefix a b = if a `isPrefix` b then drop (length a) b else b --?
06:56:08 <ndm> dons, maybe resyncing would help
06:56:16 <kzm> I must run.  Thanks for the input, everybody.
06:56:20 <dons> ndm, ok. will do so in the morning.
06:56:27 <ihope> dons: that'll work. Thanks.
06:56:44 <musasabi> kzm: most uses of UTF8 for nonenglish speakers will have 5% - 100% of multibyte characters.
06:56:53 <vincenz> anyone have any suggetsions on how to do offside parsing with parsec?
06:56:56 <kzm> Printed SM's UTF code, will read.
06:57:22 <musasabi> dons: have you thinked of adding a phantom type parameter to ByteString (for encoding) ?
06:57:28 <kzm> musasabi, Yep.  But I suspect most uses is closer to the 5% end of the scale.
06:57:38 <musasabi> kzm: just for european languages.
06:57:47 <musasabi> kzm: for everyone else it is >90%
06:58:07 <kzm> But is everyone else using UTF-8 (and not UCS-2/4 etc)?
06:58:43 <musasabi> kzm: then we should not advocate UTF-8 as the default if we don't make it suitable for the e.g. chinese and indian people.
06:58:49 <dons> musasabi: nope. encodings scare me.
06:58:49 <kzm> Anyway, step one is to get UTF-8 working at all, step to is to make it work well :-)
06:58:59 * kzm is not advocating. :-)
06:59:10 <dons> kzm, that sounds like a good plan.
06:59:37 <kzm> BTW, I ran the charsets over a binary file, and the tests (bench) worked out after I fixed a small bug.
06:59:54 <kzm> Arithmetic you know.  Hard to add those integers by hand. (sigh)
06:59:57 <dons> hehe
07:00:14 <dons> its so sad we have no hardware +
07:00:24 <kzm> The overhead isn't to bad, even for the table-based Win1252.
07:00:34 <dons> cool
07:00:43 <kzm> http://www.ii.uib.no/~ketil/src/{bench*.txt}
07:01:23 <ihope> dons: we have no what?
07:01:39 <kzm> must run.
07:01:43 <dons> little joke abotu kzm's inability to add numbers by hand.
07:02:29 <ihope> @docs Text.ParserCombinators
07:02:29 <lambdabot> Text.ParserCombinators not available
07:02:36 <ihope> @docs Text
07:02:36 <lambdabot> Text not available
07:02:47 <ihope> Burble.
07:02:49 <xerox> ?docs Text.ParserCombinators.Parsec
07:02:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
07:03:04 <shapr> Sometimes I think Plone is the Python world's idea of Malbolge or Befunge.
07:03:10 <dons> hehe
07:03:43 <ihope> Aha!
07:04:28 <joelr1> is "Bad eta expand" when compiling ghc 6.5 something that can be ignored?
07:04:33 * msph comes out of lurk mode
07:04:51 <msph> shapr: If I'm thinking of the right context, Plone is a Zope module for content management.
07:05:08 <msph> Which could be the same as saying that it is the equivalent of Malbolge.
07:05:38 <shapr> msph: After doing Plone professionaly for a few years, I think Plone is a method of slow torture.
07:06:05 <shapr> It really wouldn't be so bad if there were a reliable way to migrate data from one version to another.
07:08:37 <ihope> @index isPrefix
07:08:37 <lambdabot> bzzt
07:09:29 <ihope> @index isPrefixOf
07:09:30 <lambdabot> Data.List
07:10:37 <polinux> hi lambda friends
07:10:49 <ihope> Ello.
07:11:07 <polinux> > "hello" ++ "people"
07:11:08 <lambdabot> "hellopeople"
07:11:14 <polinux> > "hello " ++ "people"
07:11:15 <lambdabot> "hello people"
07:11:22 <xerox> Hello you!
07:11:24 <ihope> > unwords ["ello", "people"]
07:11:25 <lambdabot> "ello people"
07:11:29 <ihope> :-)
07:12:29 <dons> joelr1: yeah, I reckon so.
07:12:42 <dons> i asked about it once, hmm, the details would be in the logs
07:12:50 <dons> mailing list archives, i mean.
07:12:55 <ihope> What's the fixity of `mplus`?
07:12:59 <petekaz> @where fps
07:13:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:13:12 <polinux> @type foldr
07:13:13 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
07:13:16 <dons> hey petekaz. how's the new 'group' code? tried it?
07:13:29 <polinux> > foldr [1,2,3,4,5]
07:13:30 <lambdabot> Couldn't match `a -> b -> b' against `[a1]'
07:13:33 <isydor> :win 1
07:13:36 <polinux> > foldr 0 [1,2,3,4,5]
07:13:36 <lambdabot>  add an instance declaration for (Num (a1 -> [a] -> [a]))
07:13:42 <ihope> > foldr (++) 0 [1,2,3,4,5]
07:13:43 <lambdabot>  add an instance declaration for (Num [a])
07:13:43 <lambdabot>   In the list element: 5
07:13:45 <polinux> > foldr (+) 0 [1,2,3,4,5]
07:13:46 <lambdabot> 15
07:13:52 <ihope> There we go.
07:14:28 <mux> when I have a function with two arguments where order don't matter, can I express "either of the arguments is x" with pattern matching instead of ahving to do two lines: foo x _ = ... and foo _ x = ... ?
07:14:56 <petekaz> dons: not yet ... I have to check out the repo, didn't get to it yet.  Did you see my question regarding the deforrestation of intermediate lists the other day?  Someone told me that ghc (with -O) with eliminate intermediate lists (http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3153234), my question was, will that also apply to your BS map and filter?
07:15:13 <petekaz> Or would you have to manually write RULES for that?
07:15:30 <dons> petekaz: of intermediate lists yes. but we don't yet have RULES for deforesting ByteStrings (except a bit of unpack stuff)
07:15:41 <ihope> mux: well, if there's only one thing it could be other than x, then you could pattern match on that first.
07:15:50 <mux> yeah, sure
07:15:54 <mux> but other than that?
07:15:59 <dons> that's on my todo list. needs array fusion games, not so much list fusion (as cons isn't O(1) on arrays)
07:16:01 <ihope> I don't think so.
07:16:06 <mux> okay, thank you
07:16:23 <dons> @seen neologism 
07:16:24 <lambdabot> neologism is in #haskell. I last heard neologism speak 7 hours, 41 minutes and 20 seconds ago.
07:16:51 <petekaz> dons: I suppose that was obvious ... dumb question.  Thanks.
07:17:19 <dons> petekaz: not dumb. its a hard problem :)
07:22:33 <sjanssen> dons: do anything about ByteString.sort yet?
07:27:15 <dons> nope not yet. other than to think that counting sort is a good idea
07:27:31 <dons> and that a counting sort for any type in Enum would be kinda fun :)
07:27:56 <dons> sjanssen: please write it, if you've got your finals out of the way, that is.
07:28:20 <vincenz> @type sequence_ $ map
07:28:21 <lambdabot>   Couldn't match `[m a]' against `t -> t1'
07:28:22 <lambdabot>   Expected type: [m a]
07:28:35 <vincenz> @type \f l -> sequence_ $ map f l
07:28:36 <lambdabot> forall (m :: * -> *) a a1.
07:28:36 <lambdabot>            (Monad m) =>
07:28:36 <lambdabot>            (a1 -> m a) -> [a1] -> m ()
07:28:36 <dons> @type mapM_
07:28:37 <lambdabot> forall (m :: * -> *) a b.
07:28:38 <lambdabot>    (Monad m) =>
07:28:38 <lambdabot>    (a -> m b) -> [a] -> m ()
07:28:42 <vincenz> yeah I was thinking about that
07:28:45 <vincenz> wanted to compare types ;)
07:28:46 <vincenz> thx
07:28:49 <dcoutts_> @type sequence_ . map
07:28:50 <lambdabot>   Couldn't match `[m a]' against `t -> t1'
07:28:50 <lambdabot>   Expected type: [m a]
07:29:22 <dcoutts_> @type \f -> sequence_ . map f
07:29:23 <lambdabot> forall (m :: * -> *) a a1.
07:29:23 <lambdabot>          (Monad m) =>
07:29:23 <lambdabot>          (a1 -> m a) -> [a1] -> m ()
07:29:40 <sjanssen> @type concat . elems . accumArray (flip (:)) [] (low, high) . map (\x -> (x, x))
07:29:41 <lambdabot> Not in scope: `low'
07:29:41 <lambdabot>  
07:29:41 <lambdabot> <interactive>:1:48: Not in scope: `high'
07:29:45 <sjanssen> oh yes
07:30:00 <sjanssen> @type let ixsort low high = concat . elems . accumArray (flip (:)) [] (low, high) . map (\x -> (x, x))
07:30:01 <lambdabot> not an expression: `let ixsort low high = concat . elems . accumArray (flip (:)) [] (low, high) . map (\x -> (x, x))'
07:30:29 <sjanssen> @type let ixsort low high = concat . elems . accumArray (flip (:)) [] (low, high) . map (\x -> (x, x)) in ixsort
07:30:30 <lambdabot> forall a.
07:30:31 <lambdabot>                                      (Ix a) =>
07:30:31 <lambdabot>                                      a
07:30:31 <lambdabot>                                      -> a
07:30:31 <lambdabot>                                      -> [a]
07:30:32 <lambdabot>                                      -> [a]
07:30:35 <dons> hehe
07:31:00 <dons> take the low/high values from Bounded, perhaps
07:31:34 <dons> @type let ixsort = concat . elems . accumArray (flip (:)) [] (minBound,maxBound) . map (,) in ixsort
07:31:35 <lambdabot>   Couldn't match `(a1, a)' against `t -> t1'
07:31:35 <lambdabot>   Expected type: (a1, a)
07:31:39 <sjanssen> in that one I assumed that the things being sorted have identity, a Word8 sort won't need the list
07:31:48 <dons> hopefully not.
07:32:14 <dons> yes, I think this can be quite quick. but can we turn it into a sortBy ?
07:32:26 <musasabi> "STUArray Int Int" should be optimal for that.
07:32:53 <musasabi> sortBy needs a separate implementation.
07:33:31 <musasabi> Just copy the array and use some sort algorithm and mutate the array?
07:33:34 <dons> thing is, we already have a sort. (using qsort). a pure haskell version using counting sort or similar would be good though. and quite probably faster than qsort(3)
07:33:44 <dons> musasabi: right.
07:33:57 <dons> sort currently does a memcpy, then runs qsort()
07:34:20 <ihope> This doesn't make sense...
07:34:51 <dons> ihope: ?
07:34:52 <sjanssen> I had an idea for sortBy.  we can use a traditional algorithm to sort a string containing [0..255], then use that ordering to do counting sort
07:35:02 <ihope> Ah, I forgot to apply the constructor.
07:35:18 <ihope> I was getting some weird type error.
07:35:26 <ihope> Oh, wait...
07:35:29 <dons> sjanssen: ah, nice idea!
07:35:49 <dons> yeah, i like that.
07:36:01 <musasabi> sjanssen: what would happen with sortBy (\_ _ -> EQ) ?
07:36:01 <ihope> Aha. I was using ++ instead of mplus.
07:36:41 <sjanssen> musasabi: depends on the the algorithm we use to sort [0..255]
07:36:50 <sjanssen> which is already the case if we directly sorted
07:37:14 <joelr1> how do you configure ghc 6.5 for shared multiprocessing again? 
07:37:20 <musasabi> sjanssen: but it should not change the number of different elements, thus counting sort wouldn't work.
07:37:34 <sjanssen> musasabi: it won't change the number of elements
07:38:04 <dons> joelr1: i think the docs are on the ghc smp page.
07:38:13 <joelr1> looking
07:38:34 <dons> something like way=smp, iirc.
07:39:05 <dons> http://haskell.org/haskellwiki/GHC/Concurrency
07:39:19 <sjanssen> musasabi: the algorithm: first count the occurrences of each character.  then use Data.List.sortBy on [0.255].  use the order produced as the order to dump characters out
07:39:23 <dons> and use -threaded (which is synonymous with -smp!)
07:39:54 <joelr1> dons: but does it configure itself for smp automatically at build time?
07:40:21 <dons> well, the docs don't indicate any special build requirements
07:40:27 <musasabi> sjanssen: that would work. I was thinking of the reverse which wouldn't work.
07:41:19 <joelr1> ok, found it!
07:41:26 <joelr1> http://hackage.haskell.org/trac/ghc/wiki/GhcConcurrency
07:41:40 <eivuokko> Isn't ghc 6.5 in darcs automatically smp aware now?
07:42:03 <joelr1> eivuokko: i want to know! rebuilding takes a while
07:42:54 <joelr1> hmm
07:43:07 <joelr1> the wiki refers to mk/build.mk but mine is not even built
07:43:07 <dons> i think all the docs say the nightly snapshots are already smp.
07:43:07 <Igloo> sjanssen: You are trying to sort the characters in a bytestring, right?
07:43:16 <sjanssen> Igloo: yes
07:43:16 <dons> joelr1: you create mk/build.mk
07:43:24 <dons> its the user's custom file for adding flags
07:43:24 <joelr1> dons: ok
07:43:29 <Igloo> sjanssen: Why do you need the sortBy on [0..255] then?
07:43:51 <dons> Igloo: we're tryign to write a linear sortBy on byte strings.
07:43:53 <Igloo> Surely you just construct an array indexed on (0, 255) to count them and then walk over the array to produce the string?
07:44:09 <Igloo> Oh, sortBy
07:44:13 <dons> that's the basic linear sort. yep. but not sortBy.
07:44:17 * jethr0 is going crazy, looking for a nice matrix library usable with haskell that will allow inverting matrices *argh*
07:44:19 <vincenz> joelr1: Hi1
07:44:28 <joelr1> vincenz: hi
07:44:53 <jethr0> hey vincenz 
07:45:03 <vincenz> :)
07:45:06 <Igloo> The above algorithm isn't going to stable then, if I understand it correctly?
07:45:18 <musasabi> of course there should be an optimization for the case length ps < 255.
07:45:30 <dons> sjanssen: nonethesless, i'm suspicious now that a haskell counting sort is going to be faster than the existing qsort(3) we're using. so we should check that.
07:45:45 <vincenz> jethr0: making another gui :)
07:45:53 <jethr0> you are?
07:45:58 <vincenz> well not for contest
07:45:59 <vincenz> for work
07:46:00 <isydor> :win 1
07:46:00 <dons> it should almost certainly be faster.
07:46:02 <jethr0> ah
07:46:02 <vincenz> I need to experiment with something
07:46:12 <vincenz> jethr0: btw, check out jyp's test framework
07:46:17 <vincenz> jethr0: I mvoed it to test/
07:46:20 <jethr0> anyone have any ideas for a robust haskell matrix inversion library?
07:46:25 <vincenz> jethr0: however... look at MetaTest and Main in src/
07:46:28 <vincenz> jethr0: the prop_ stuf
07:46:39 <jethr0> k
07:46:45 <dons> jethr0: checked the libraries page on haskell.org under math?
07:46:50 <sjanssen> dons: I agree.  qsort is almost certainly going to be faster than counting on small strings
07:47:05 <sjanssen> unless the constant factor on counting sort is incredibly small
07:47:27 <jethr0> dons: yes, but i'm not so keen on binding to GSL and even then i'm not sure if LU decomposition (that gsl uses) will find all inverse matrices :(
07:47:48 <dons> well. at least on the large strings it should be much faster (currently qsort takes 13s to sort 20M, and other linear operations like map, take around 0.8s on the same box)
07:48:02 <dons> so hopefully there's a bit of room to squeeze in there.
07:48:25 <dons> jethr0: apply for a google SoC proejct and write it yourself :)
07:48:58 <jethr0> he. i've already written that stuff once in c++. but matrix operations are so _damn_ numerical that it's not really my favorite pasttime
07:49:21 <jethr0> it's really hard to test whether your solution is numerically robust :(
07:49:42 <vincenz> stupid question
07:49:46 <vincenz> quitting early in a list
07:49:54 <vincenz> here's the context
07:50:01 <dons> night all!
07:50:02 <vincenz> I have a drawing area... with a set of circles spaced evenly on a horizontal line
07:50:05 <jethr0> nite
07:50:11 <vincenz> I'm clicking
07:50:15 <vincenz> I would like to find out which circlke
07:50:44 <joelr1> night
07:51:37 <joelr1> is there a way to programmaticaly find out how much memory your program is using at a given time?
07:51:40 <jethr0> vincenz: what's the problem. if they are spaced out evenly it's a strictly 1-dimensional problem, no?
07:51:52 <vincenz> jethr0: no it's a 2d canvas
07:51:56 <ihope> @hoogle IO Integer
07:51:56 <vincenz> jethr0: it's mostly the bailing out early bit
07:51:56 <lambdabot> CPUTime.getCPUTime :: IO Integer
07:51:57 <lambdabot> IO.hFileSize :: Handle -> IO Integer
07:51:57 <lambdabot> System.IO.hTell :: Handle -> IO Integer
07:52:04 <jethr0> vincenz: you said horizontal line
07:52:06 <ihope> @hoogle IO Int
07:52:06 <lambdabot> System.Console.Readline.getCompletionQueryItems :: IO Int
07:52:06 <lambdabot> System.Console.Readline.getEnd :: IO Int
07:52:06 <lambdabot> System.Console.Readline.getMark :: IO Int
07:52:11 <vincenz> jethr0: once distnace increases again (cause they're ordered frm left to right) I should stop looking
07:52:16 <vincenz> jethr0: yes they're on a horizontal line
07:52:20 <vincenz> jethr0: but I'm clicking ona drawing area
07:52:21 <jethr0> joelr1: /usr/bin/time
07:52:30 <vincenz> here let me make a screnshot
07:52:33 <jethr0> joelr1: in theory at least, or do you mean inside the program?
07:52:48 <joelr1> inside the program of course
07:52:56 <jethr0> he
07:53:10 <joelr1> inside a haskell program. to implement cache eviction for example. to trigger cache eviction, rather
07:53:36 <jethr0> joelr1: maybe reading from /proc?
07:53:48 <vincenz> jethr0: http://oasis.yi.org:8080/Screenshot-DDT%20Simulator.png
07:54:08 <joelr1> jethr0: that's waay to radical for me 
07:54:43 <vincenz> joelr1: you can't have tight cache control from haskell anyways, you can't layout your data.
07:55:01 <vincenz> jethr0: see the second one with green circles?
07:55:04 <jethr0> vincenz: why can't you just do "(clicked_position.x - circles_start) / circles_distance" or sth like that?
07:55:13 <musasabi> vincenz: actually one can decide partially on the layout.
07:55:15 <vincenz> jethr0: hmm good idea
07:55:22 <vincenz> musasabi: hows that?
07:55:36 <vincenz> jethr0: yeah good idea :) use that as crude selection and then doo a radius check, thanks!
07:56:25 <jethr0> vincenz: not even that. you can do the same with modulo and accept only if the remainder is in a certain (radius-dependant) range, i think
07:56:33 <vincenz> jethr0: they're circles
07:56:36 <joelr1> vincenz: well, what i would do is try to keep total memory usage within 4-5gb for example
07:56:39 <jethr0> i know
07:56:50 <joelr1> and trigger massive cache eviction when i'm over
07:57:07 * joelr1 is afraid of not fitting into 16Gb of memory
07:57:29 <jethr0> yes, i've frequently run into that 16GB barrier, too :)
07:57:41 <jethr0> ll
07:58:08 * SamB 's mind blows at the idea of 5GB of memory usage
07:58:49 <sjanssen> how can I quickly convert from a Word8 to a Word32?
07:58:55 <SamB> though I suppose it is only a matter of time before JHC starts to use that much
07:59:00 <SamB> fromIntegral
07:59:10 <SamB> make sure to build with -O
07:59:21 <joelr1> SamB: that's an easy one. i have 1 million poker games to score and i need to do it _really_ fast. and for each game and pair of players i need to track 20-30 counters. like how many times x played with y or how many raises in game z
07:59:43 <jethr0> joelr1: have you resumed your haskell efforts for the poker bot again?
08:00:11 <joelr1> SamB: the problem is that saving these counters to oracle after every game makes things really slow. so i'm thinking of keeping them in memory and evicting to oracle if needed
08:00:30 <SamB> joelr1: that was a joking reference to my being on a 32-bit platform
08:00:48 <SamB> as if my brain were also 32-bit
08:01:08 <joelr1> jethr0: no, this is a different project. i failed the plain dumb approach in lisp (saving counters to oracle) and even when processing things game by game oracle starts to slow down drastically
08:01:33 <joelr1> either way i need to process 1mm games within hours, not weeks like right now
08:01:41 <jethr0> joelr1: when you say game, do you mean one hand of cards?
08:01:48 <SamB> have you tried sqlite ;-P?
08:01:54 <joelr1> jethr0: yes, with a bunch of players
08:02:01 <joelr1> SamB: good joke
08:02:21 <SamB> well, I hear sqlite is actually a better DBMS than MySQL...
08:02:46 * joelr1 is waiting for the punch line
08:02:55 <jethr0> joelr1: stupid question: couldn't you distribute it? having one server only handle a few hundred thousand games?
08:03:20 <joelr1> jethr0: the issue is that the scoring of 1 game depends on the counters of the game before it
08:03:38 <jethr0> ah
08:03:39 <joelr1> it's very important that counters are updated after every game. this has nothing to do with servers, this is fraud detection
08:03:47 <SamB> journaling?
08:03:48 <joelr1> statistical fraud detection over past data
08:03:54 <SamB> have you considered some kind of journaling?
08:04:02 <joelr1> SamB: what do you mean?
08:04:22 <joelr1> my idea right now is to have the counters wrapped in STM and just keep them in memory
08:04:28 <SamB> wait, what kind of counters are these?
08:04:40 <ihope> > logBase 2 (1 - 1/sqrt 2)
08:04:41 <lambdabot> -1.7715533031636117
08:04:45 <jethr0> joelr1: but you don't have to check those statistic _every_ hand, do you? it would suffice to collect the data, unify it hourly or so and check only every 10th game or so, no?
08:04:45 <joelr1> how many times i played with you, how many times a raise was made, etc
08:04:56 <joelr1> jethr0: no
08:05:00 <jethr0> oh
08:05:35 <joelr1> so i'm just gonna launch tons of threads and since the counters are going to be in STM updating them should not present a problem
08:05:51 <SamB> hmm...
08:06:16 <ihope> > logBase 2 (1/sqrt 2)
08:06:17 <lambdabot> -0.5000000000000001
08:06:19 <joelr1> SamB: what?
08:06:37 <joelr1> btw, remind me please, how do you convert a string to an integer
08:06:43 <SamB> you are going to update counters the same way every time?
08:06:59 <SamB> > read "100" :: Integer
08:07:00 <lambdabot> 100
08:07:07 <SamB> though probably that is slow
08:07:23 <joelr1> SamB: well, i guess, yes. at the beginning of every game i would update the number of times each player shared a hand/table with every other player in the same game
08:07:55 <joelr1> SamB:  have a huge csv file, thinking of quantifying each row
08:08:06 <dcoutts_> joelr1, so it's just a big in-memory DB that you occasionally sync to an on-disk DB?
08:08:09 <joelr1> don't remember how to do this fast
08:08:13 <SamB> csv file???
08:08:23 <dcoutts_> joelr1, why threads + STM?
08:08:29 <joelr1> dcoutts_: i guess that's what i'm gonna be building. i'll sync it to oracle when i'm done
08:08:38 <dcoutts_> rather than a centeral in memory DB
08:08:42 <SamB> why do you have a csv file?
08:08:44 <musasabi> joelr1: There is a person working on mutable disk based B+trees in Haskell.
08:08:47 <joelr1> dcoutts_: because processing everything in a single thread will be slower and i have 2 cpus on the machine
08:09:01 <musasabi> joelr1: in the mean time you could use your app to either qdbm or Judy.
08:09:15 <joelr1> SamB: a dump from oracle? :-) i don't have it on my laptop /oracle/ and remote editing is a pain
08:09:32 <musasabi> joelr1: you can have one cpu doing the actual computations and the other all the serialization stuff.
08:09:34 <joelr1> dcoutts_: i will have a central in-memory db, it's all within one process
08:09:51 <joelr1> musasabi: i need to dump to oracle after i'm done
08:09:58 <dcoutts_> joelr1, right, but do you really want an STM-based DB? that sounds tricky.
08:10:13 <musasabi> STM based DB is easy. Fast STM-based DB is hard.
08:10:26 <joelr1> dcoutts_: i don't really have a db, see. i just have a bunch of counters that need to be updated. so i'll stick them into some sort of a huge hash table or something
08:10:35 <joelr1> or a bunch of hash tables/trees
08:10:55 <joelr1> dcoutts_: i just want to keep everything in memory
08:11:04 <musasabi> joelr1: I would bind Judy and use that.
08:11:40 <SamB> do you actually need the transactional bit?
08:12:07 <joelr1> musasabi, dcoutts_: it's not a db. 1) i start up and grab a list of game ids from oracle, 2) i either start a bunch of threads and give them game ids for pulling the data or i'll read from a file and dispatch to running threads
08:12:34 <joelr1> 3) once a game is finished i'll need to update the counters 4) when i'm done with all games i 'll save everything back to oracle
08:12:58 <joelr1> SamB: because i'll have multiple threads scoring games and they would need to update counters atomically
08:13:06 <musasabi> What do you do if there is a crash between 3 and 4?
08:13:19 <joelr1> musasabi: i don't give a flying hoot :D i'll just re-run
08:13:20 <musasabi> update one counter or update multiple counters?
08:13:31 <joelr1> my goal is to score 1mm games in 2-3 hours
08:13:37 <joelr1> musasabi: multiple counters
08:13:55 <joelr1> there's a counter per fraud rule and i have ~20 fraud rules
08:13:58 <SamB> joelr1: well, if you don't need to update multiple counters together in one transaction, you probably don't need STM...
08:14:31 <joelr1> SamB: well, right, you mean i could use MVar's etc
08:14:33 <araujo> morning!
08:14:36 <dcoutts_> how does STM interact with IO? I mean they're different monads.
08:14:36 <musasabi> joelr1: can you use a linear order on the counters + MVars ? Or just use STM + optimizations.
08:14:45 <musasabi> dcoutts_: there is unsafeIOToSTM
08:15:06 <joelr1> i thought you just do atomically $ in your IO monad
08:15:47 <dcoutts_> musasabi, but we want thread doing IO and talking to the network and sharing an STM-based db. How would that work?
08:15:48 <SamB> dcoutts: also, STM is generally scattered in little pieces here and there in your IO code
08:16:00 <dcoutts_> where are the Refs made?
08:16:05 <dcoutts_> in which monad?
08:16:18 <musasabi> dcoutts_: they can be made in both with 6.5
08:16:19 <vincenz> is it possible to do this
08:16:25 <vincenz> type Sequence a = [Element a]
08:16:28 <vincenz> or must it be data?
08:16:35 <SamB> @hoogle TVar
08:16:36 <lambdabot> Control.Concurrent.STM.TVar :: module
08:16:36 <lambdabot> GHC.Conc.TVar :: data TVar a
08:16:36 <lambdabot> GHC.Conc.newTVar :: a -> STM (TVar a)
08:16:55 <SamB> dcoutts: apparantly in STM
08:17:27 <musasabi> newTVar :: a -> STM (TVar a)
08:17:32 <musasabi> newTVarIO :: a -> IO (TVar a)
08:17:39 <dcoutts_> musasabi, so one could make the STMRefs at the beginning, put them in a lookup structure and then have STM transactions which update a bunch of them?
08:17:55 <SamB> they are called TVars
08:17:59 <dcoutts_> oh ok
08:18:37 <musasabi> dcoutts_: possible. Depends on the exact problem.
08:18:54 <dcoutts_> joelr1, do you need to create more counters during a run or is it fixed at startup time?
08:19:15 <vincenz>       (hd, e:tl)  = splitAt (n-1) seq
08:19:15 <vincenz>       newSeq      = hd ++ ((e{active = not . active $ e}):tl)
08:19:20 <vincenz> it says that e is of type []
08:19:24 <vincenz> not of type of the actual data element in the []
08:19:25 <joelr1> dcoutts_: i create more. if i have not seen this pair of players then i would need to create a counter for them
08:19:37 <vincenz> why does it infer e to be a list?
08:19:39 <joelr1> dcoutts_: and then bump it every time i see this pair of players again
08:22:25 <musasabi> Not sure if I know the whole problem but: 1) partition the set of player IDs in use to few blocks, 2) updates on the blocks can work in parallel, 3) inside each block we have only one thread, 4) so we can use a fast mutable structure for the "(Int,Int) -> Int" mapping and don't need locking, 5) write the trivial FFI binding to Judy, 6) happiness.
08:23:30 <joelr1> musasabi: why do i need judy? i already have oracle and that's what the client is comfortable with
08:23:35 <petekaz> what is this "Judy" thing?
08:23:52 <joelr1> musasabi: i don't know the set of players in advance, i deal with events like player joining a game, folding, betting, etc.
08:23:53 <musasabi> petekaz: basically just a very fast Data.HashTable in C.
08:23:57 <pesco> I want type functions. Can I have type functions?
08:23:59 * pesco whines.
08:24:04 <joelr1> musasabi: so i need to process things event by event
08:24:22 <joelr1> musasabi: or at least start a thread per game and have that pull its own events from oracle, something like that
08:24:23 <musasabi> pesco: you can have logic programming with types which can be used to have functions in addition to relations.
08:24:29 <joelr1> i'm not sure what i can partition here
08:24:31 <musasabi> pesco: i.e. fundeps
08:24:58 <SamB> joelr1: well, then you might as well have one CPU...
08:25:09 <pesco> musasabi: Yes, but I can't get it to work. ;)
08:25:25 <joelr1> SamB: I have two so, hopefully, i have run two threads at a time
08:25:30 <musasabi> joelr1: partition by the "player x player" space?
08:25:37 <joelr1> SamB: and maybe score two games at a time
08:25:40 <pesco> (Apart from the fact that the notation is very near to unbearable.)
08:25:40 <SamB> you could decide to just add up the number of times some occurrence happens in the games under consideration...
08:25:43 <joelr1> musasabi: i don't know that space in advance
08:25:55 <joelr1> SamB: that's what i'll be doing
08:25:56 <musasabi> joelr1: you can do a statistical estimation of it.
08:26:03 <joelr1> musasabi: no, cannot
08:26:08 <joelr1> i have exact rules
08:26:13 <joelr1> a set of them
08:26:16 <SamB> joelr1: so you could split the games in half and do it twice
08:26:41 <joelr1> to calculate how many times two people shared a table (i.e. one joined the game and another did not), how many times both joined the game (shared a hand), etc.
08:27:03 <joelr1> what's wrong with the simple approach that i'm planning to take
08:27:19 <joelr1> i.e. with keeping a bunch of counters in memory in some tree/hash indexed by game and player pair
08:27:44 <musasabi> joelr1: avoiding locking whenever you can is very important for concurrent things.
08:27:47 <SamB> interdependencies between threads?
08:28:04 <SamB> those tend to be *baaaaad* for performance
08:28:07 <pesco> The problem is that I want to pattern-match on the "argument" types.
08:28:10 <pesco> @get-oleg
08:28:10 <lambdabot> Unknown command, try @list
08:28:13 <pesco> Damn.
08:28:22 <musasabi> joelr1: if you find a way to have independent concurrent computations then you are winning, otherwise things are more involved.
08:29:26 <musasabi> pesco: you can probably do all kinds of wizardy there, but it is a black art.
08:29:38 <SamB> see, if you do it my way you can just use whatever mutable (or otherwise) data structure, and it doesn't need to deal with threading...
08:30:04 <joelr1> musasabi: i have independent concurrent computations indeed. i can compute each game separately.
08:30:31 <SamB> joelr1: that sounds like too much concurrency, considering you have just two CPUs...
08:30:32 <joelr1> SamB: what is your way again? i did not understand. 
08:31:37 <SamB> well, basically, you split the set of games in two
08:32:00 <SamB> you process each half in one thread
08:32:14 <joelr1> SamB: oh, sure i can do that
08:33:02 <SamB> you accumulate statistics in each thread, using a nice, fast, non-STM datastructure...
08:33:18 <SamB> ...and add them up at the end
08:33:32 <joelr1> SamB: no, can't do that. the structure needs to be shared. 
08:33:36 <joelr1> anyway, thanks for the tips!
08:33:47 <SamB> why does the structure need to be shared?
08:34:05 <musasabi> joelr1: how about this: have a few threads fetch things from DB and compute the results of the games, then have one thread taking the results from a fixed length queue and mutating the datastructure. Does this work for you?
08:34:39 * SamB wonders how you get a fixed length queue
08:36:01 <musasabi> SamB: newtype QueueWithMax a = Q (MVar (Int,[a]))
08:36:11 <musasabi> SamB: + a list of waiters
08:37:11 <timbod> Does the --user flag in cabal work at present? (It doesn't seem to for me)
08:37:31 <SamB> I don't suppose "data Q a = Q (MVar Int) (Chan a)" would be better?
08:38:32 <musasabi> SamB: Chan is not a performance wonder.
08:38:37 <SamB> true.
08:38:55 <SamB> depends on the length of the queue, I guess...
08:39:18 <SamB> because if it was a long queue, getting to the back might take a while
08:40:07 <musasabi> SamB: but if you don't care about the order you can use LIFO.
08:40:13 <SamB> oh, true.
08:40:20 <SamB> that isn't quite a queue, though ;-)
08:42:07 <musasabi> or just "data Q a = Q [a] [a]; take (Q (f:fs) r) = Just (f,Q fs r); take (Q [] []) = Nothing; take (Q [] r0) = let (r:rs) = reverse r0 in Just (r,Q rs [])"
08:42:20 <musasabi> put x (Q a b) = Q a (x:b)
08:43:16 <SamB> I suppose that is from Okasaki?
08:44:01 <musasabi> that is the basic "usually fastest functional queue if there is no persistence"
08:45:04 <musasabi> Okasaki should have that (but I am too lazy to go find the book).
08:45:09 <pesco> Woot, it's working!
08:45:14 * pesco slaps ghci.
08:45:37 * xerox slaps pesco
08:45:58 <kosmikus> more important than the SoC: submit to the Haskell Workshop :)
08:48:19 <xerox> Cool!
08:50:41 * pesco is just copying from Oleg.
08:51:43 <pesco> kosmikus: Hey, I saw you got a new lhs2TeX out! How'd you end up doing the pragma stuff?
08:56:11 * joelr1 is back 
08:57:46 <kosmikus> pesco: I didn't do very much about it, because I didn't really like any of the possibilities.
08:58:17 <joelr1> musasabi: why a fixed-length queue and a list of waiters? i mean, i'll be updating the structure very quickly, no?
08:58:31 <joelr1> SamB: the stats of each game depend on the stats of games that ran before it
08:58:44 <kosmikus> pesco: we could discuss it again sometime soon, however. maybe we can come up with a good solution. I hope to release slightly more frequently in the future ...
08:58:50 <joelr1> that is i need to incrementally calculate averages and standard deviations
08:58:56 <kosmikus> pesco: right now I have to go, though ...
08:59:17 <joelr1> i like the idea of "stats generators" and a "stats consumer" thread 
08:59:40 <joelr1> does hsql have a connection pool? anybody knows?
09:01:47 <joelr1> cc1: unrecognized option `-fno-unit-at-a-time'
09:01:48 <joelr1> make[1]: *** [Apply.o] Error 1
09:01:56 <joelr1> has anybody seen this error when building 6.5?
09:02:35 <musasabi> joelr1: sounds like "a bad version of gcc"
09:02:51 <joelr1> gcc version 3.2.3 20030502 (Red Hat Linux 3.2.3-49)
09:03:00 <musasabi> joelr1: if you can guarantee that the updates are fast enough(tm) then just use a "MVar [a]" as the queue.
09:03:28 <joelr1> musasabi: sure
09:03:31 <musasabi> the really should be a -fuse-if-defined-<option-name>
09:04:03 <joelr1> musasabi: what do you mean? i mean, ok, it should be but that's not what ghc seems to be using
09:04:36 <joelr1> that's some internal thing when compiling Apply
09:04:55 <joelr1> because it's not in the parameter list to ghc
09:05:20 <joelr1> ../compiler/ghc-inplace -H16m -O -optc-O2 -static -I. -#include Prelude.h -#include Rts.h -#include RtsFlags.h -#include RtsUtils.h ... -#include OSThreads.h -#include Apply.h -#include SMP.h -fvia-C -dcmm-lint     -c Apply.cmm -o Apply.o
09:05:25 <joelr1> and then bummer
09:06:36 <joelr1> JaffaCake: ping
09:06:50 <JaffaCake> pong
09:06:57 <JaffaCake> I have about 2 minutes... got to go soon
09:06:59 <joelr1> JaffaCake: have you seen the culprit?
09:07:16 <joelr1> cc1: unrecognized option `-fno-unit-at-a-time'
09:07:16 <joelr1> make[1]: *** [Apply.o] Error 1
09:07:20 <JaffaCake> sorry, what?
09:07:33 <joelr1> i'm compiling ghc 6.5 and get the error above
09:07:41 <JaffaCake> ah, what platform?
09:07:43 <joelr1> ../compiler/ghc-inplace -H16m -O -optc-O2 -static -I. -#include Prelude.h -#include Rts.h -#include RtsFlags.h -#include RtsUtils.h ... -#include OSThreads.h -#include Apply.h -#include SMP.h -fvia-C -dcmm-lint    -c Apply.cmm -o Apply.o
09:07:47 <joelr1> linux
09:07:50 <joelr1> 64-bit 
09:08:00 <joelr1> Thread model: posix
09:08:00 <joelr1> gcc version 3.2.3 20030502 (Red Hat Linux 3.2.3-49)
09:08:04 <JaffaCake> hmmm
09:08:24 <joelr1> can i work around that somehow?
09:08:25 <JaffaCake> can you drop it in an email?
09:08:28 <joelr1> sure
09:09:19 <JaffaCake> the flag comes from compiler/main/DynFlags.hs, just remove it from there
09:09:22 <joelr1> sent
09:09:25 <joelr1> will do, thanks
09:09:25 <JaffaCake> thx
09:09:30 <JaffaCake> bye!
09:09:33 <joelr1> bye
09:18:36 <Lemmih> Greetings SyntaxNinja.
09:19:06 <SyntaxNinja> y0
09:24:14 <psi> hi
09:24:40 <pesco> kosmikus: Okay. :)
09:25:56 <psi> why does this example use so much stack space? it seems to me it should use very little.
09:26:06 <psi> http://pastebin.com/694400
09:26:15 <neologism> dons: did you want anything?
09:31:46 <Lemmih> psi: Make 'init' strict.
09:35:00 <psi> aha. it actually builds a huge expression like (((init `xor` 1) `xor` 1) ...)?
09:35:07 <Cale> yes
09:35:12 <Cale> that's exactly what it's doing
09:35:38 <lightstep> where can i get gtk2hs for ubuntu (or debian)?
09:36:16 <lightstep> psi, using pattern matching without computing xors will probably be even faster
09:37:34 <Cale> also, it's currently a left fold
09:37:46 <psi> how do I make it strict?
09:37:53 <Cale> you could write it in terms of foldl', and that would get rid of your problem
09:38:56 <Cale> > let manyx init n = foldl' xor init (replicate n 1) in manyx 1 1000000
09:38:57 <lambdabot> Add a type signature
09:39:13 <Cale> > let manyx init n = foldl' xor init (replicate n 1) in manyx 1 1000000 :: Int
09:39:13 <Cale> hmm
09:39:14 <lambdabot> 1
09:39:39 <psi> cool
09:39:59 <Cale> You could also just add a seq
09:40:26 <psi> could you show how? I tried
09:40:34 <Cale> > let manyx init n = init `seq` if n == 0 then init else manyx (init `xor` 1) (n-1) in manyx 1 1000000 :: Int
09:40:35 <lambdabot> 1
09:41:01 <psi> ah
09:41:04 <psi> thanks
09:41:08 <Cale> The one with foldl' seems a bit faster on my machine
09:42:12 <psi> do situations like this often arise? I was just toying around.
09:42:20 <SyntaxNinja> cabal-devel mailing list: http://www.haskell.org/mailman/listinfo/cabal-devel
09:42:22 <psi> I've never thought about it before.
09:42:35 <Cale> They occur every once in a while
09:42:45 <christastrophe> hello
09:42:50 <Cale> hi
09:43:11 <christastrophe> im new to Haskell, I was hoping someone could help me with a problem
09:43:12 <Cale> Really, the places where you want to add strictness to your program is where you're collapsing a large structure into a small one
09:43:20 <Cale> christastrophe: sure
09:43:27 <christastrophe> oh good
09:43:39 <christastrophe> its probably really simple. I'm implementing my own version of map
09:43:49 <christastrophe> and I came up with this:
09:44:00 <vincenz> Cale: we have a test frameworkk
09:44:03 <christastrophe> my_map f [] = []
09:44:16 <christastrophe> my_map f (x:xs) = f x : my_map f xs
09:44:33 <christastrophe> but ghci gives me some error about print and (Show (a -> a))
09:44:47 <christastrophe> and I really have no idea how to fix that
09:45:01 <jethr0> christastrophe: do you have that code in a separate file?
09:45:06 <christastrophe> yes
09:45:14 <ProfTeggy> Your definition looks reasonable, christastrophe
09:45:19 <kpreid_> christastrophe: that error means you tried to print a function
09:45:32 <christastrophe> hmm
09:45:33 <jethr0> > let my_map f [] = []; my_map f (x:xs) = f x : my_map f xs in my_map (+1) [1,2,3]
09:45:34 <lambdabot> [2,3,4]
09:45:36 <Cale> Yeah, that's a perfectly fine definition -- let's see how you're testing it?
09:45:37 <christastrophe> well i didn't intend to
09:45:46 <christastrophe> the file is only three lines
09:45:49 <christastrophe> the two I just put here,
09:45:59 <christastrophe> and the first line is: module Heller.MyMap where
09:46:14 <christastrophe> I load it into ghci with :l Heller.MyMap
09:46:26 <christastrophe> I tried this in ghci:
09:46:36 <christastrophe> *Heller.MyMap> my_map (+) []
09:46:46 <christastrophe> which should give my the empty list
09:46:56 <ProfTeggy> Hehe
09:46:58 <christastrophe> and infact if I dont' define my_map f (x:xs) ... than it works
09:46:59 <jethr0> map expects a unary function
09:47:10 <christastrophe> ah! 
09:47:21 <christastrophe> damn yeah i knew it was something stupidly simple...
09:47:32 <ProfTeggy> Well, you can pass an n-ary function to my_map and it will (partially) apply it
09:47:34 <christastrophe> should have just tried to do my_foldr ... bah
09:47:39 <ProfTeggy> But ghci cannot show the result
09:47:50 <ProfTeggy> (a list of partially applied functions)
09:47:53 <Cale> Yeah, the result there is an empty list of functions
09:48:00 <christastrophe> i see
09:48:35 <christastrophe> ghci's error was very mileading 
09:48:39 <ProfTeggy> Why?
09:48:49 <ProfTeggy> It says exactly what happens
09:49:02 <Cale> christastrophe: it said that there was no instance of Show (a -> a)
09:49:05 <ProfTeggy> "I don't know how to show a function."
09:49:13 <jethr0> all ghci says is, that it can't print a list of functions...
09:49:15 <profmakx> re
09:49:27 <christastrophe> oh ok. well I can't say I fully understand it, but thats not ghci's fault
09:49:44 <christastrophe> so  a -> a means a is a function?
09:49:47 <psi> what is the lambdabot command to find the module of a certain function?
09:50:07 <ProfTeggy> The type a -> a denotes functions of identical input and output types 
09:50:11 <ProfTeggy> The general form is a-> b
09:50:25 <christastrophe> ok , so a -> a is a function a which returns a function a
09:50:31 * ProfTeggy nods
09:50:36 <ProfTeggy> No
09:50:40 <ProfTeggy> :-)
09:50:44 <christastrophe> hah, ok
09:50:45 <ProfTeggy> This notation is about types, not names
09:50:47 <Cale> (a -> b) is the type of functions which take a parameter of type a, and return a value of type b
09:51:03 <ProfTeggy> even :: Integer -> Bool 
09:51:03 <jethr0> it denotes a function that takes one parameter of type "a" and returns a result of type "a"
09:51:07 <Cale> @type even
09:51:08 <shapr> psi: What's the English word for hyresgaster?
09:51:08 <lambdabot> forall a. (Integral a) => a -> Bool
09:51:25 <jethr0> @type id
09:51:30 <shapr> psi: @index
09:51:42 <psi> @index foldr'
09:51:45 <shapr> aha, tenant!
09:51:54 <psi> yep :)
09:52:17 <christastrophe> ok, like an identity function?
09:52:18 <shapr> Man, it's getting easier to think in Swedish than in English. I've been in this country too long! I need a vacation in the USA.
09:52:22 <lambdabot> forall a. a -> a
09:52:24 <lambdabot> bzzt
09:52:34 <shapr> @index foldr
09:52:34 <lambdabot> Data.List, Prelude
09:52:39 <psi> haha, I often feel the opposite
09:52:40 <jethr0> christastrophe: no, it's only the types that are the same
09:53:22 <shapr> psi: There's a really good reason that foldl' exists, but not foldr', I just can't remember.. something to do with infinite lists.
09:53:35 <jethr0> christastrophe: there's two different notations. one for types and one for implementations, values, ...
09:54:04 <psi> shapr: ah, I was actually looking for foldl' :-)
09:54:04 <christastrophe> ah yes, the values aren't under consideration here... Num -> Num is just as valid as a -> a
09:54:09 <psi> @index foldl'
09:54:09 <lambdabot> Data.List
09:54:09 <jethr0> yes
09:54:21 <jethr0> "a -> a" is just more general
09:54:22 <psi> aha, I was importing List
09:54:32 <christastrophe> ghci just chose a , because it could choose whatever symbol it whises?
09:54:33 <Cale> well, the primary reason that one would want to use foldl over foldr in the first place is because it's tail recursive
09:54:53 <Cale> but due to laziness, the benefit of tail recursion is usually lost
09:55:11 <Cale> you end up constructing some huge expression as large as the usual list, and then evaluating it
09:55:14 <ProfTeggy> christastrophe, exactly.  a -> a and z -> z are identical types
09:55:20 <Cale> the original*
09:56:03 <psi> I see
09:56:04 <Cale> but foldl' forces the evaluation to occur as you proceed, so you get back that benefit in terms of memory consumption and time.
09:56:29 <psi> foldl' is also quite a bit faster than the seq version, like you said
09:56:44 <christastrophe> yeah, thanks for the explanation, its making sense to me now
09:57:05 <psi> I don't really understand why
09:57:08 <vincenz> GRRR
09:57:12 <christastrophe> thanks. don't be surprised if I'm back here asking more questions later... I'm off to work through some more of this tutorial
09:57:15 <vincenz> Anyone know why some installshield programs randomly quit 
09:57:21 <vincenz> at not always at the sametime
09:57:29 <shapr> vincenz: Windows?
09:57:31 <vincenz> shapr: yeah
09:57:35 <vincenz> but it makes no sense
09:57:38 <vincenz> I mean truly randomly
09:57:45 <shapr> That's been my experience with windows...
09:57:50 <vincenz> anywhere before the first time you have to click next,until it actually starts with the proggy
09:58:07 <vincenz> what is it, a second thread that does a randomWait and kill/
09:58:13 <Cale> psi: neither do I really
09:58:25 * vincenz would think installers are monothreaded so tey should 'crash' at one specific point if at all
09:58:55 <Cale> psi: possibly, ghc isn't finding the tail recursion
10:00:03 <Cale> psi: which is why it's safer to use nice combinators like foldl' whenever possible -- they have predictable performance.
10:00:27 <Cale> (not to say that you should make all your code strict, just that higher order functions are good)
10:01:05 <psi> *nod*. shouldn't it be easy to find it there, though?
10:01:35 <Cale> I'd think so, but I'm only using ghci
10:01:45 <psi> I'm compiling
10:01:48 * vincenz kicks Cale and shapr to #oasis
10:01:52 <Cale> with -O ?
10:02:03 <vincenz> Cale: no, with my foot :P
10:02:19 <psi> no, let me try
10:02:21 <Cale> vincenz: heh, that was to psi
10:02:26 <vincenz> I know ;)
10:02:57 <psi> ah, much better now
10:03:02 <lightstep> psi, using pattern matching without computing xors will probably be even faster
10:03:06 <lightstep> oops
10:03:36 <Cale> well, yeah, you could match on whether n is even or odd
10:03:44 <Cale> but the point wasn't the xor :)
10:03:57 <psi> no, it was a remnant from something else
10:04:14 <psi> the seq version is faster now :)
10:04:40 <Cale> yeah, probably fewer reductions overall
10:07:42 <SamB> Cale: so can anyone see my app yet?
10:08:17 <Cale> SamB: I'll try and see
10:10:52 <Cale> yep
10:11:41 <Cale> I also offered to mentor on it :)
10:12:49 <SamB> ooh, sweet ;-). "Interest being shown"
10:17:20 <SamB> so how many apps are there?
10:17:27 <SamB> and how many applicants?
10:17:55 <Cale> currently there seem to be 4 there.
10:18:14 <dcoutts_> hia SyntaxNinja 
10:23:07 <dreamEye> hi
10:23:32 <Cale> hello
10:23:35 <SyntaxNinja> heya dcoutts_.  I was going to tell you about the new mailing list, but that's just because I hadn't read all of my email yet ;)
10:23:41 <SyntaxNinja> dcoutts_: excellent work.  thanks!
10:23:52 <dcoutts_> :-)
10:24:22 <dcoutts_> SyntaxNinja, so you're happy to admin the new list?
10:24:32 <dreamEye> anyone know any haskell library that combine transactions and caching?
10:24:37 <SyntaxNinja> dcoutts_: yeah, no problem. there's not much overhead in that.
10:24:57 <dcoutts_> SyntaxNinja, it'll probably mean white-listing people when they darcs send their first patch
10:25:58 <SamB> dcoutts: what about all the spam?
10:26:10 <dcoutts_> SamB, it's a moderated list
10:26:27 <SamB> *somebody* has to moderate it, you know
10:26:39 <dcoutts_> SamB, SyntaxNinja has been volunteered :-)
10:26:58 <dreamEye> can I have pointer to a haskell object?
10:27:04 <Cale> dreamEye: hmm. What sort of transactions?
10:27:18 <SyntaxNinja> dreamEye: you can use an IORef.
10:27:19 <SamB> dreamEye: what for?
10:27:29 <Cale> dreamEye: haskell values are all internally represented by pointers
10:27:29 <dcoutts_> dreamEye, Haskell works with values not references
10:27:49 <Cale> hehe, how's that for a confusing array of answers? :)
10:27:58 <SyntaxNinja> dcoutts_: actually, what if i make you a moderator? :)
10:27:58 <SamB> that is, depending on what you want to do, you might want one of many kinds of things
10:28:02 <dreamEye> Cale: I need a sort of  concurrently updated cache o
10:28:09 <SamB> TVar?
10:28:15 <Cale> dreamEye: have you looked at STM?
10:28:16 * dcoutts_ notes that his and Cale's answer are consistent
10:28:23 <dreamEye> Cale: I need a sort of  concurrently updated cache . but the cache must be searchable
10:28:33 <dcoutts_> SyntaxNinja, you'll have to tell me how to work it
10:29:02 <dreamEye> i need a sor of finitemap structure with TVars that can be concurrently updated
10:29:11 <Cale> hmm
10:29:13 <dreamEye> but finitemaps are not mutable
10:29:21 <mnislaih> Lemmih: trying the breakpoints in ghci now
10:29:38 <dreamEye> so i can not really update the same TVar in a finitemap
10:29:39 <Cale> Well, they're not mutable, but they also don't cost much to modify
10:29:41 <mnislaih> Lemmih: does this preserve evaluation order ?
10:30:04 <Lemmih> mnislaih: Yes.
10:30:09 <dcoutts_> dreamEye, how about using an MVar containing a finite map?
10:30:25 <dreamEye> that´s what i do
10:30:25 <mnislaih> Lemmih: what does it say when you ask for the value of something not evaluated yet
10:30:38 <dreamEye> but MVars blocks
10:30:39 <Cale> insert into a Data.Map is O(log n)
10:31:01 <dcoutts_> dreamEye, of course that serialises modiications to the map
10:31:03 <ndm> hi, i want to write a monad that wraps the IO monad, and provides certain operations (a limited few)
10:31:17 <Cale> ndm: which ones?
10:31:22 <ndm> any idea how? I want a wrapper round putStrLn, and hPutStrLn
10:31:25 <Lemmih> mnislaih: It only preserves evaluation order if you don't ask it to evaluate anything (:
10:31:38 <Cale> ndm: sure -- you want it to be like a monad transformer?
10:31:49 <ndm> Cale, and i also want to "store" a non-mutable handle in this monad
10:31:51 <mnislaih> Lemmih: ok
10:32:15 <mnislaih> Lemmih: no support for step-by-step execution at this point I guess
10:32:21 <ndm> Cale, I want it to be as simple as possible - its even ok if its not entirely type safe, (i.e. doesn't restrict the user)
10:32:51 <dreamEye> the solution may be a mutable finitemap
10:33:20 <Cale> ndm: something like ReaderT Handle IO ?
10:33:31 <Lemmih> mnislaih: No, and there probably won't be for a very long time. Maybe never.
10:33:43 <ndm> Cale, possibly, I don't know much about ReaderT
10:33:59 <ndm> I'll go take a look :)
10:34:09 <mnislaih> Lemmih: really? I had planned for that already. Actually I was promising Google that there would be :O
10:34:49 <Lemmih> mnislaih: step-by-step execution doesn't make much sense in Haskell.
10:35:15 <mnislaih> Lemmih: right
10:35:43 <dreamEye> anyone has the hat debugger compiled for GHC windows?
10:36:08 <ndm> dreamEye: the hat-trans or the tools?
10:37:25 <Lemmih> mnislaih: This paper describes a GDB-style debugger for Optimistic Haskell: http://www.cambridge.intel-research.net/~rennals/hw2003.pdf
10:37:31 <dreamEye> ndm: I don´t know. to have all the sfuff would be nice
10:37:55 <ndm> dreamEye, hat-trans works easily enough, i think
10:38:08 <ndm> its just that without hmake, which is Linux only, its a bit of a fiddle
10:38:23 <ndm> the tools don't work, but they aren't far off - i managed to get a couple of them together quite easily
10:39:02 <ndm> but of course, Yhc will have hat generation support soon, and once thats in, I'll definately fix up the hat-tools for windows
10:39:15 <ndm> since then they'll be useful - hat-trans is reasonably painful to use i find
10:41:00 * shapr finds a typeclass hack with O(leg) K complexity.
10:43:06 <shapr> Bah, I thought it was funny :-)
10:43:11 <SyntaxNinja> hehe
10:44:15 <xerox> haha.
10:46:24 <beelsebob_> > lookup "a" [("a",5),("b",6),("a",7)]
10:46:25 <lambdabot> Just 5
10:46:39 * beelsebob_ wonders if that behavior is guarenteed
10:46:53 <ndm> beelsebob_, it is
10:47:00 <beelsebob_> useful :)
10:47:00 <xerox> > lookup "not existing" [("here",0)]
10:47:01 <lambdabot> Nothing
10:47:07 <xerox> Is that what you mean?
10:47:09 <beelsebob_> no
10:47:21 <beelsebob_> what I mean is that it's guarenteed to return Just 5, and not Just 7
10:47:30 <xerox> Ah, woops.
10:47:48 <ndm> beelsebob_, but if you use a Data.Map or something then i'm not sure what guarantees you get
10:47:49 <beelsebob_> it saves a nub call
10:48:13 <beelsebob_> ndm: I can't be arsed with that kind of thing at the moment, mostly because I'm already wrestling with a bit of a complex algorithm
10:48:23 <beelsebob_> my brain explodes when the result gets passed in as an argument
10:48:24 <ndm> beelsebob_, hat-delta?
10:48:28 <beelsebob_> ish
10:48:49 <beelsebob_> I'm trying to get it to display lambda expressions nicely in a variety of ways
10:49:15 <beelsebob_> or more to the point... all the hat tools
10:49:39 <ndm> started your hat tool rewrite yet?
10:49:39 <shapr> beelsebob_: You could use the lambda birds.
10:50:04 <beelsebob_> I'm not sure I want to know about what shapr's on about
10:50:17 <beelsebob_> ndm: no - more important things to do... research and the like :)
10:50:41 <ndm> beelsebob_, whats this research thing? :)
10:50:49 <dreamEye> ndm: so yoy know how to download the binaries of  Hat-trans for windows?
10:50:50 <beelsebob_> dunno, olaf keeps telling me to do some
10:51:05 <ndm> dreamEye: no binaries for windows
10:51:06 <beelsebob_> dreamEye: you don't
10:51:25 <shapr> beelsebob_: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction - http://users.bigpond.net.au/d.keenan/Lambda/
10:51:25 <dreamEye> ok
10:51:28 <ndm> dreamEye: cvs checkout, then random luck to build them
10:51:28 <beelsebob_> my prefered solution is to install linux, but compiling yourself is an option I guess
10:51:47 <beelsebob_> shapr: interesting, I'll look at that
10:51:57 <beelsebob_> shapr: but at the moment I'm trying a couple of things
10:52:07 <beelsebob_> (a) reconstruct what the lambda was from the trace
10:52:19 <beelsebob_> and (b) show a series of mappings for it, rather than a function)
10:52:23 <shapr> Hey, you said "display lambda expressions nicely in a variety of ways" so I thought birds would definitely add variety.
10:52:43 <beelsebob_> shapr: yes indeed, and relevant looking
10:52:46 <beelsebob_> I'll play with that
10:54:19 <beelsebob_> basically what I want to do is stop it displaying "\.. 2 == 4?" and make it display "(\x -> square x) 2 = 4?"
10:54:21 <kolmodin> waern: hey! how's code?
10:54:44 <shapr> I think I saw some code for that on the mailing list long ago.
10:54:56 <beelsebob_> or "map (\x -> x * x) [1,2] = [2,4]" instead of "map (\..) [1,2] = [2,4]"
10:55:09 <beelsebob_> I think it should be recoverable from the trace
10:55:33 <waern> kolmodin, hey.. I'm sitting in NC right now and coding
10:55:42 <beelsebob_> but the other option is to make it do "map (\{1 |-> 2, 2 |-> 4}) [1,2] = [2,4]
10:55:48 <beelsebob_> which would be fun
10:56:06 <kolmodin> waern: good to hear :)
10:56:45 <waern> kolmodin, how's your code doing? 
10:56:59 <kolmodin> waern: my code is on ice
10:57:12 <davidhouse> shapr, that looks fun :)
10:57:23 <kolmodin> I should probably release a version to get some feedback
10:57:23 <waern> kolmodin, not good at all ;)
10:57:24 <dreamEye> anyone using visual Haskell?
10:57:38 <kolmodin> waern: school is about to take a lot more time
10:58:03 <waern> kolmodin, ah.. right
10:58:59 <dreamEye> anyone using Visual Haskell and/or haskell IDE for Eclipse?
10:59:14 <kolmodin> waern: three projects going, suit, oosu and topics in computer languages
10:59:23 <ndm> Cale, I managed to get a monad doing what I want - not as scary as I suspected! Thanks a lot
10:59:25 <ndm> @karate+ Cale
10:59:25 <lambdabot> Unknown command, try @list
10:59:30 <ndm> @karma+ Cale
10:59:31 <lambdabot> Cale's karma raised to 9.
10:59:50 <ndm> (its funny how my fingers move on their own)
11:01:05 <waern> kolmodin, ouch
11:01:59 <lesshaste> hi.. do you people have a favourite way to typeset small pieces of haskell code  in latex?
11:02:26 <lesshaste> For example,  The type \code{Maybe a}, contains
11:02:26 <lesshaste>   either an item \code{Just} of type \code{a}
11:02:29 <davidhouse> hey RyanScheuermann :)
11:02:32 <davidhouse> @where yaht
11:02:32 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
11:03:24 <davidhouse> you should pick that up. that's how i learnt, and it explains the basic concepts well. it's lacking a bit in the more advanced stuff, but it's a really good intro.
11:03:38 <davidhouse> if you just want to have a play, then i still suggest that tutorial.
11:03:50 <RyanScheuermann> Thanks
11:04:04 <davidhouse> any questions, ask in here. the #haskell folks are good people. :)
11:04:23 <RyanScheuermann> Good to know :-)
11:05:02 <davidhouse> lets have some example code.
11:05:53 <davidhouse> > [ (x, y, z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2 ]
11:05:54 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
11:06:03 <davidhouse> (pythagorean triples)
11:09:25 <davidhouse> > let isPrime x = all (\y -> x `mod` y /= 0) $ takeWhile (\y -> y^2 <= x) [2..] in filter isPrime [1..50]
11:09:26 <lambdabot> [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
11:09:32 <davidhouse> (primes from 1 to 50)
11:10:05 <lesshaste> hi.. do you people have a favourite way to typeset small pieces of haskell code  in latex?
11:10:46 <SamB> you must be getting us mixed up with the, uh, academics?
11:10:52 <SamB> we are just the users ;-)
11:11:39 <SamB> well, mostly, anyway
11:11:56 <lesshaste> :)
11:12:07 <petekaz> speaking of which, I meant to ask, does the bird book, Intro to Func Prog, use mathematics for most of the examples?  If so, I don't think I want to buy the book.
11:12:10 <lesshaste> I assume people in #haskell have no limits :)
11:12:18 <lesshaste> petekaz, no it doesn't
11:12:25 <petekaz> Good!
11:12:28 <lesshaste> petekaz, unless you include haskell as part of mathematics :)
11:12:40 <SamB> yeah, mathematics is a pretty stupid application of mathematics
11:13:02 <petekaz> I just want the examples and lessons to be meaningful and more importantly _practical_
11:13:03 <davidhouse> SamB: was the second mathematics meant to be a haskell?
11:13:17 <SamB> davidhouse: yes ;-)
11:13:27 <davidhouse> right. :)
11:13:34 <davidhouse> in which case, i disagree.
11:13:45 <petekaz> I am not an academic, I have a day job, and want to see if I can use haskell for things that I currently use python and ruby for.
11:14:54 <jethr0> petekaz: i don't mean to "dis" haskell or discourage you from haskell, but at some point one needs to feel at least a little academic when learning haskell.
11:14:58 <SamB> Cale: is there anything about my app that could use work?
11:15:10 <MarcWeber> how would you do a while not eof do append character to array with NewBinary lib? mapM get_ [1..]   and let fail end the array?
11:15:29 <SamB> ?
11:15:44 <jethr0> petekaz: by all means give it a try with one of the 2-3 good tutorials, but the first 5-10 programs are just hard work to write. much harder than most "mainstream" languages.
11:16:33 <SamB> I'm told my BF interpreter is really nice to look at ;-)
11:16:42 <jethr0> petekaz: after that it's a great language. but coming to grips with some of its "unusual" aspects takes its toll on motivation ^_^
11:16:51 <jethr0> SamB: yes, i keep telling you that
11:16:52 <SamB> although maybe it only serves as motivation to learn what in the world all these things do
11:16:56 <petekaz> Not a problem, my learning process is a long drawn out one.
11:17:19 <SamB> it is a very short program that uses a lot of cool features ;-)
11:17:26 <SamB> and libraries
11:18:03 <petekaz> What's the BF programe?
11:18:07 <SamB> @google BFInterpreter
11:18:10 <lambdabot> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
11:18:14 <jethr0> SamB: i'd call it advanced though, because the parsing and looping is not exactly apparent to a novice (at least to me it wasn't)
11:18:18 <petekaz> thx
11:18:39 <jethr0> s/apparent/self-explanatory/
11:18:59 <SamB> anyway, if you don't understand it now, you can always try again later and see how much you've learned ;-)
11:19:11 <jethr0> SamB: i keep coming back to that program and finding new cool twists and tricks.
11:19:32 <jethr0> by now i think i've pretty much assimilated the whole thing into my haskell mode :)
11:19:38 <palomer> <:O
11:20:10 <SamB> I think the point of this program is to make the reader say "wow"
11:20:34 <palomer> or "blargh"
11:20:35 <palomer> @palomer
11:20:36 <lambdabot> hrmph
11:20:39 <SamB> haha
11:21:24 <jethr0> SamB: i think there's a function somewhere to memset a whole region of memory. instead of looping over it, i mean
11:22:01 <davidhouse> SamB: are peek and poke from Foreign?
11:22:07 <SamB> jethr0: oh, probably ;-)
11:22:18 <SamB> davidhouse: think so
11:22:23 <SamB> @hoogle peek
11:22:23 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
11:22:24 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
11:22:24 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
11:22:34 <SamB> yeah
11:22:36 <davidhouse> @type toEnum . fromEnum
11:22:37 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
11:22:57 <davidhouse> > toEnum $ fromEnum 4
11:22:58 <lambdabot> Add a type signature
11:23:10 <davidhouse> > toEnum $ fromEnum 4 :: Int
11:23:11 <lambdabot> 4
11:23:15 <davidhouse> odd...
11:23:23 <davidhouse> > toEnum $ fromEnum 4 :: Char
11:23:24 <lambdabot> '\EOT'
11:23:27 <davidhouse> ah.
11:23:32 <davidhouse> > toEnum $ fromEnum 4 :: Bool
11:23:33 <lambdabot> Exception: Prelude.Enum.Bool.toEnum: bad argument
11:23:38 <SamB> > chr 4
11:23:38 <lambdabot> '\EOT'
11:23:49 <palomer> sleeping until 2 is not a good idea
11:23:57 <davidhouse> i would have used chr and ord, but whatever.
11:24:00 <SamB> palomer: no, it is not
11:24:04 <SamB> palomer: do you live alone?
11:24:18 <palomer> nope
11:24:19 <palomer> parents
11:24:30 <SamB> you don't have good parents?
11:25:05 <jethr0> SamB: couldn't you do the initialization with "pokeArray ptr (replicate 1000 0)"?
11:25:17 <jethr0> or sth like that?
11:25:26 <SamB> jethr0: probably!
11:25:29 <davidhouse> replicate 1000 0?
11:25:42 <davidhouse> oh. yeah.
11:25:45 <SamB> @hoogle memset
11:25:45 <lambdabot> System.Win32.Mem.memset :: Ptr a -> CInt -> CSize -> IO ()
11:25:53 * davidhouse was getting replicate and repeat confused
11:25:57 <jethr0> yes, i was looking for that too :)
11:26:09 <davidhouse> > take 1000 [0,0..] == replicate 1000 0
11:26:10 <lambdabot> True
11:26:20 <jethr0> davidhouse: me too. i always only remember "repeat" and have to look up replicate, knowing only that it starts with "re" ^_^
11:26:36 <SamB> well, I suppose I could just foreign import it
11:26:36 <davidhouse> i like the [0,0..] syntax
11:26:52 <jethr0> hmm
11:26:58 <jethr0> > take 10 $ repeat 0
11:26:59 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
11:27:04 <jethr0> i just like plain replicate
11:27:17 <davidhouse> yeah, i'd normally stick with replicate
11:27:20 <joelr1> has someone managed to compile ghc 6.5 on a 64-bit linux?
11:27:33 <davidhouse> but [a,a..] is nice instead of repeat
11:27:47 <joelr1> i get a segmentation fault at a certain point in the compilation process
11:28:17 <Igloo> joelr1: What arch/OS?
11:28:34 <davidhouse> @hoogle readFile
11:28:35 <lambdabot> Prelude.readFile :: FilePath -> IO String
11:28:35 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
11:28:35 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
11:28:37 <joelr1> redhat 
11:28:45 <davidhouse> @hoogle writeFile
11:28:46 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
11:28:46 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
11:28:46 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
11:28:48 <jethr0> SamB: do you mind me changing the initialization on the wiki, if it works with pokeArray?
11:29:08 <RyanScheuermann> davidhouse: thanks for the intro and tutorial, bed reading material for sure :-) - gotta get back to more pressing work though, see ya
11:29:09 <SamB> jethr0: fine, go ahead...
11:30:11 <davidhouse> RyanScheuermann: sure.
11:30:14 <davidhouse> RyanScheuermann: have fun :)
11:31:00 <SamB> is "bed reading material" that which makes one go to sleep?
11:32:08 <davidhouse> i hope not.
11:32:12 <davidhouse> that was YAHT he was refering to
11:32:16 <SamB> hehe
11:32:59 <SamB> for some reason, when I try to read the Inform Designer's Manual in bed, I usually start to fall asleep
11:33:29 <SamB> however, I can't actually stay asleep with a book in my hands, so I wake up again pretty quickly
11:34:28 <jethr0> SamB: i've changed it. but i can undo it if you would rather not have me break your code...
11:36:24 <jethr0> oh yeah, and decr,incr,prev and next could be nicely done using "modify"...
11:37:09 <davidhouse> and use chr and ord instead of the toEnum . fromEnum type hackery
11:37:15 <jethr0> hehe
11:37:28 <jethr0> now everyone is picking at samb's nice code :(
11:38:32 <jethr0> @type modify
11:38:33 <lambdabot> forall (m :: * -> *) s.
11:38:33 <lambdabot>     (MonadState s m) =>
11:38:33 <lambdabot>     (s -> s) -> m ()
11:42:11 <palomer> where's the code so I can join in the forray?
11:42:22 <jethr0> @google BFInterpreter
11:42:23 <lambdabot> http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
11:42:31 <davidhouse> @hoogle runReaderT
11:42:32 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
11:42:44 <jethr0> but chr and ord don't work because they return Int and the program works on Word8. so you'd need a fromIntegral :(
11:43:16 <davidhouse> ah.
11:44:27 <jethr0> and my modify idea was stupid... i guess that code is pretty good as it is already :)
11:45:00 <davidhouse> jethr0: well, i'd do prev and next with a modify
11:45:09 <jethr0> yes, working on it :)
11:45:26 <jethr0> but it involves non-perfect "`advancePtr` (-1)" trickery
11:45:35 <davidhouse> prev = modify (\p -> advancePtr p (-1))
11:45:36 <jethr0> and that doesn't improve it significantly
11:45:41 <jethr0> yes, or that
11:45:45 <jethr0> i was thinking of
11:45:52 <davidhouse> i like the lambda for readability.
11:45:54 <jethr0> prev = modify (`advancePtr` (-1))
11:46:03 <davidhouse> although your infix-pointsfree is nice.
11:47:28 <d0c> hey, i'm trying to change the default RTS options for my program but can't figure out the linking part :$
11:47:37 <d0c> can anyone help?
11:48:06 <kzm_> d0c, yep.  Just add it to the ghc command line
11:48:07 <jethr0> davidhouse: are you editing? :)
11:48:15 <kzm_> ghc --make Foo.hs hooks.o
11:48:24 <d0c> thx
11:48:25 <jethr0> using an array instead of pointers would indeed be nice too
11:48:38 <kzm_> and compile hooks.c with ghc as well, that way you don't have to worry about include paths.
11:48:51 <jethr0> SamB: still here?
11:48:53 <kzm_> (ghc knows where it has Rts.h etc, gcc doesn't)
11:49:02 <d0c> i knew it had to be easy.. otherwise google would have helped ;)
11:49:31 <kzm_> Heh - usually, google has too many of the easy answers.
11:50:09 <d0c> thx again, worked like a charm
11:50:36 * kzm_ is happy to be of service.
11:51:12 <msph> Okay, newbie question: how are $ and . different?
11:51:51 <davidhouse> this should be a wiki FAQ.
11:51:55 <davidhouse> msph, basically, in their types.
11:51:58 <davidhouse> @type ($)
11:51:59 <lambdabot> forall b a. (a -> b) -> a -> b
11:52:03 <davidhouse> @type (.)
11:52:04 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
11:52:32 <davidhouse> in other words, what appears on the right of $ must be a _value_, but what appears on the right of . must be a _function_
11:52:51 <sjanssen> msph: ($) is a precedence hack.  When you see it think application
11:52:54 <msph> Oh, that makes it obvious.
11:52:59 <davidhouse> when stringing together long chains of things, it's a matter of taste whether you use . or $
11:53:07 <davidhouse> but sometimes you have to use one or the other.
11:53:09 <jethr0> davidhouse: that's a little ambiguous...
11:53:18 <jethr0> > (+1) $ (+1) $ 2
11:53:19 <lambdabot> 4
11:53:28 <davidhouse> long chains of function composition.
11:53:38 <davidhouse> right, but:
11:53:49 <davidhouse> @type (+1) $ (+1)
11:53:51 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
11:54:05 <jethr0> i know, just being annoying ^_^
11:54:12 <davidhouse> (that's a type error to you and me, when was the last time a -> a was an instance of Num ;))
11:54:20 <davidhouse> @type (+1) . (+1)
11:54:21 <lambdabot> forall a. (Num a) => a -> a
11:54:48 <sjanssen> davidhouse: the only hard part about making a -> a an instance of Num is that it also has to be an instance of Eq
11:54:50 <davidhouse> msph, so the only time they're interchangeable is when you're chainging together functions, like jethr0 just did.
11:55:18 <davidhouse> sjanssen: Show, isn't it? i'd like to see (f + g) v, etc.
11:55:34 <davidhouse> sjanssen: class (Eq a, Show a) => Num a
11:55:43 <sjanssen> both are problematic
11:55:45 <davidhouse> yes.
11:56:06 <SamB> jethr0: oh?
11:56:09 <sjanssen> I wonder why Show is there?
11:56:23 <sjanssen> Eq makes sense -- so we can have k-patterns
11:56:23 <jethr0> msph: one usually uses ($) instead of parens
11:56:40 <davidhouse> yes.
11:57:02 <davidhouse> > sin (pi + pi)
11:57:03 <lambdabot> -2.4492127076447545e-16
11:57:08 <davidhouse> > sin $ pi + pi
11:57:09 <lambdabot> -2.4492127076447545e-16
11:57:11 <jethr0> (f 1 (g 2 (h 3)) == f 1 $ g 2 $ h 3 -- unless is just did sth stupid
11:57:22 <psi> do you people like the following project idea: gstreamer bindings for haskell. I  haven't seen a lot of haskell multimedia apps, maybe it would be fun.
11:57:32 <jethr0> SamB: "oh?"
11:57:54 <vincenz> dum dum dum
11:58:02 * vincenz waves at his teammates, davidhouse and jethr0 
11:58:10 * jethr0 waves back
11:58:14 <davidhouse> when is 'as' a keyword in haskell? i just used it as an abbreviation of 'args', but emacs highlighted it :)
11:58:16 <davidhouse> hey vincenz 
11:58:30 <psi> davidhouse: import foo as bar
11:58:31 <Lemmih> davidhouse: import X as Y
11:58:31 <vincenz> davidhouse: import qualified X as Y
11:58:35 <davidhouse> of course,.
11:58:36 <musasabi> davidhouse: import Long.Name.Of.Module as Short
11:58:47 <jethr0> davidhouse: import Y as Z
11:58:52 <vincenz> or if you're evil
11:58:58 <vincenz> import Short as LongEvilNameOfModule
11:59:02 <davidhouse> thanks psi, Lemmih, vincenz and musasabi. and jethr0, your contribution was especially valuable.
11:59:06 <psi> :-)
11:59:27 <jethr0> welcome
11:59:44 * palomer ponders adding nested patterns to his language
11:59:46 <palomer> nah
11:59:47 <joelr1> folks, is there a fast way to convert from string to number?
12:00:00 <davidhouse> read is the best you've got
12:00:09 <davidhouse> but it's particularly fast
12:00:09 <jethr0> joelr1: read, parsec, happy
12:00:18 <davidhouse> *not particularly fast
12:00:29 <davidhouse> palomer: what are you building?
12:00:29 <palomer> @hoogle String -> Int
12:00:29 <lambdabot> No matches, try a more general search
12:00:30 <joelr1> well, i just have a string ike "10", "20", "30"
12:00:37 <jethr0> reads
12:00:46 * vincenz kicks davidhouse to #oasis
12:00:55 <palomer> davidhouse: a type system with GADTs
12:01:33 <davidhouse> palomer: funky.
12:02:04 <shapr> > read "10" :: Integer
12:02:05 <lambdabot> 10
12:02:07 <davidhouse> i once did a lambda intepreter to test my knowledge of Reader.
12:02:09 <davidhouse> it was nice :)
12:02:57 <musasabi> joelr1: if you use FPS then readInt is fast enough for most purposes.
12:03:12 <asiekiel> hi. what do you think about current SOC proposals? what directions are interesting? bindings, extending libraries, new apps?...
12:03:19 <joelr1> musasabi: that's what i need. i'm reading strings from a file
12:03:38 <davidhouse> asiekiel: "interesting" is in the eye of the beholder.
12:04:26 <davidhouse> hm.
12:04:32 <davidhouse> i wish records used some form of namespacing.
12:04:48 <asiekiel> davidhouse: hm, I don't know Haskell community and what is cool for you :)
12:04:53 <musasabi> asiekiel: I think all mentors think that their projects tend to be interesting ;)
12:05:14 <davidhouse> what do people tend to use instead of real namespacing for records?
12:05:32 <davidhouse> e.g. i want a type to represent the state of my program.
12:05:37 <davidhouse> data    PMEnv   = PMEnv { hunks :: [Hunk], 
12:05:37 <davidhouse>                           opts  :: [Flag], 
12:05:37 <davidhouse>                           args  :: [String] }
12:05:40 <asiekiel> i'm a little surprised that most of the proposals are very technical, they are about doing a concrete thing
12:05:50 <davidhouse> ^^ that's what i have. but those names clash a lot.
12:05:58 <sjanssen> asiekiel: I think that is what Google wants
12:06:04 <vincenz> @seen shapr 
12:06:04 <lambdabot> shapr is in #haskell. I last heard shapr speak 4 minutes ago.
12:06:08 <shapr> vincenz: You screamt?
12:06:09 <musasabi> asiekiel: personally I think that things that are novel in some respect are good, but there is also a great deal of work that is needed to build more cool stuff. But other people will certainly have different opinions.
12:06:09 <vincenz> shapr: #oasis!
12:06:25 <vincenz> shapr: we're out in force
12:06:43 <yaarg> shapr: incidently did the bug i pointed out earlier solve your problem?
12:07:15 <shapr> yaarg: No, but I'm not sure if that's because I haven't restarted ion3 yet.
12:07:56 <yaarg> shapr: okay :)
12:08:11 <shapr> asiekiel: I think the parsers for languages like Python,C,etc are concrete.
12:08:59 <psi> how much work is it to create a binding to a library written in C?
12:09:21 <asiekiel> musasabi: I agree, but I'm afraid we are doing the same tools, libs etc. that rest of the world has done long ago. maybe what should do something new?
12:09:29 <shapr> psi: http://www.haskell.org/hawiki/FfiTutorial
12:09:29 <sjanssen> psi: how big is the library?
12:10:12 <sjanssen> Haskell's FFI is pretty nice, and there are also good tools to help you (like c2hs)
12:10:14 <psi> sjanssen: currently I am thinking about gstreamer. I just proposed it as a possible SOC project.
12:10:19 <ihope> @hoogle Int -> [a] -> ([a],[a])
12:10:20 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
12:10:34 <ihope> > splitAt 3 "Hello, world"!
12:10:35 <lambdabot>  parse error on input `}'
12:10:40 <ihope> > splitAt 3 "Hello, world!
12:10:40 <lambdabot>  lexical error in string/character literal
12:10:44 <ihope> > splitAt 3 "Hello, world!"
12:10:44 <lambdabot> ("Hel","lo, world!")
12:10:56 <asiekiel> another question: how can I connect Java and Haskell? I want to call Haskell from Java.
12:11:02 <palomer> let {toI = toInt . reverse ; toInt [i] = ord i - ord '0'; toInt (x:xs) = ((ord x) - (ord '0'))+ 10*(toI $ reverse xs)} in toI "239487"
12:11:15 <palomer> > let {toI = toInt . reverse ; toInt [i] = ord i - ord '0'; toInt (x:xs) = ((ord x) - (ord '0'))+ 10*(toI $ reverse xs)} in toI "239487"
12:11:16 <lambdabot> 239487
12:11:17 <davidhouse> asiekiel: via the shell?
12:11:38 <asiekiel> i don't understand. via some FFI
12:11:44 <palomer> joelr1: there's your function
12:12:02 <davidhouse> that would be a java question really.
12:12:12 <ihope> > read "239487" :: Int
12:12:13 <lambdabot> 239487
12:12:17 <asiekiel> davidhouse: hmm...
12:12:32 <musasabi> asiekiel: actually the current situation is not that bad.
12:12:34 <joelr1> palomer: thanks :D
12:12:40 <palomer> > read "29387492837492837498237498237492837492837492834792837492834792387492834792387492834787234283479274982374"
12:12:41 <lambdabot> Add a type signature
12:12:45 <palomer> > read "29387492837492837498237498237492837492837492834792837492834792387492834792387492834787234283479274982374" :: Int
12:12:46 <lambdabot> 1218022374
12:12:50 <vincenz> Integer
12:12:51 <asiekiel> is IDL compiler for Haskell working now?
12:12:52 <palomer> > read "29387492837492837498237498237492837492837492834792837492834792387492834792387492834787234283479274982374" :: Integer
12:12:53 <lambdabot> 29387492837492837498237498237492837492837492834792837492834792387492834792387492834787234283479274982374
12:13:12 <musasabi> asiekiel: at least the visual haskell people are using a version of it.
12:13:25 <asiekiel> musasabi: a version of what?
12:13:41 <musasabi> Usually one can fuse together doing something usefull and library work.
12:14:03 <musasabi> asiekiel: hdirect I think. (have not used it, just remember reading the visual haskell paper)
12:14:14 <palomer> my function is probably faster for smaller numbers
12:14:18 <palomer> since I don't have to parse
12:14:23 <asiekiel> musasabi: i think it is about calling java from haskell
12:14:33 <asiekiel> musasabi: i want the opposite
12:14:53 <ihope> > maxBound - minBoumd
12:14:54 <lambdabot>  Not in scope: `minBoumd'
12:14:58 <ihope> > maxBound - minBound :: Int
12:14:59 <lambdabot> -1
12:14:59 <asiekiel> musasabi: I am using now stdin/stdout :)
12:15:03 <musasabi> asiekiel: that is about COM bindings.
12:15:16 <asiekiel> musasabi: so Windows only?
12:15:22 <ihope> > maxBound + maxBound :: Int
12:15:23 <lambdabot> -2
12:16:45 <davidhouse> > minBound - maxBound :: Int
12:16:46 <lambdabot> 1
12:16:54 <musasabi> asiekiel: yes, I think. I don't think anyone recently has had a need for CORBA. That would certainly make a nice project, but it seems like few people are actually using it these days.
12:17:05 <ihope> > minBound + minBound
12:17:06 <lambdabot> Add a type signature
12:17:13 <ihope> > minBound + minBound :: Int
12:17:13 <lambdabot> 0
12:18:20 <ihope> > let x ++ y = foldr (:) y x in "Hello, " ++ "world!"
12:18:21 <lambdabot> "Hello, world!"
12:18:43 <asiekiel> so I have the next SoC proposal: Haskell for JVM :)
12:18:53 <ndm> asiekiel: too late, Yhc already has that :)
12:19:01 <ndm> and for .NET as well
12:22:26 <asiekiel> ndm: hmm, is it really working or is it only a toy? I cannot find a web site of it.
12:22:31 <musasabi> nib
12:22:37 <musasabi> grah. ignore that.
12:22:41 <ndm> asiekiel: Yhc, or Yhc JVM
12:22:47 <ndm> @where Yhc
12:22:47 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
12:22:53 <ndm> @google Yhc JVM Java
12:22:54 <lambdabot> http://yhc06.blogspot.com/2005/11/yhc-jvm.html
12:23:09 <asiekiel> a blog entry only
12:23:13 <ndm> its really working, its more a port of the runtime
12:23:21 <ndm> rather that native JVM bytecodes
12:23:26 <ndm> but thats been worked on
12:23:32 <ndm> for .NET we have 100% native bytecodes
12:23:40 <asiekiel> so it isn't JVM
12:24:01 <ndm> that one runs Haskell in Java, there is a proper JVM port underway
12:24:05 <asiekiel> but the idea is cool
12:24:20 <asiekiel> but I want to call Haskell from Java :)
12:24:39 <ndm> asiekiel: with the interpetter as it stands, thats 100% possible
12:24:54 <ndm> you just import the interp written in Java into your code
12:25:05 <ndm> then fire it off with your haskell
12:25:28 <flux__> hmm.. how large is the yhc runtime?
12:25:47 <asiekiel> ndm: hm, thanks for info
12:25:56 <flux__> apparently the byte code programs themselves aren't very big
12:26:01 <ndm> flux__: 100Kb ish
12:26:05 <flux__> wow, that's small
12:26:07 <ndm> actually, maybe 200K
12:26:13 <flux__> well, not that small but still small
12:26:16 <ndm> about 25% of that is libgmp
12:26:17 <flux__> I think lua is around 200k
12:26:37 <flux__> I'm thinking about its suitability for embedded environment
12:27:01 <ndm> so if you either provide your own bigint, or don't use them, it can be smaller
12:27:05 <ndm> it could certainly be reduced in size
12:27:07 <asiekiel> mobile phones with Haskell? :)
12:27:16 <ndm> most of the core code is one single module, hardly anything
12:27:20 <Igloo> ndm: Why does it statically link?
12:27:25 <ndm> the rest is for runtime linking and dynamically loading
12:27:27 <flux__> so that would include the prelude, but not much else?
12:27:29 <musasabi> Haskell < Java, and java for them is possible.
12:27:34 <ndm> Igloo: it doesn't, i think...
12:27:48 <musasabi> (for runtime size)
12:27:57 <Igloo> OK; just seems odd to include it in the size, then  :-)
12:28:02 <ndm> flux__: no, you need the libs as well, prelude is ~40K
12:28:20 <ndm> oh, you mean to libgmp?
12:28:34 <flux__> ndm, do other libraries in general work fine with yhc (already)?
12:28:44 <ndm> flux__: not enough
12:28:49 <ndm> some do, some don't
12:29:00 <flux__> networking? parsing?
12:29:04 <ndm> there isn't much more work required, hardly anything, but its just time consuming
12:29:29 <ndm> Haskell 98 minus Directory and Random work
12:29:30 <ndm> FFI is nearly there
12:29:40 <ndm> once we have all of that, then most libraries should work, with the appropriate #ifdef's
12:29:49 <flux__> ffi would be essential for such environments
12:30:03 <ndm> indeed, and we have 90% of FFI done
12:30:32 <ndm> and are working on a pre-linker for haskell bytecodes, which will drop most of the prelude etc. for bytecodes, reducing the libraries required
12:30:49 <flux__> nice, you're really aiming for small :)
12:31:08 <ndm> we're based on nhc98, and that aims for small a lot more
12:31:31 <ndm> we're aiming for small, but our primary goals are simple, portable and debugging
12:34:47 <ihope> > splitAt 200 "Hello, world"!
12:34:47 <lambdabot>  parse error on input `}'
12:34:49 <ihope> > splitAt 200 "Hello, world!"
12:34:50 <lambdabot> ("Hello, world!","")
12:48:15 <yaarg> is there a ghci 6.4 backport for Debian stable?
12:49:14 <musasabi> yaarg: I don't think so, but the tarballs should just work.
12:49:36 <MarcWeber> In NewBinary there is get:: handle -> IO a and isEOFBin. I want to get a list [a] containing all elements. How is this done in an a nice way? Is there a better option than writing your own recursive function?
12:51:10 <yaarg> okay packages would be just be more convenient
12:51:13 <yaarg> perhaps i'll make one
12:51:19 <davidhouse> @hoogle while
12:51:19 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
12:51:19 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
12:51:19 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
12:51:26 <davidhouse> @hoogle until
12:51:27 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
12:51:27 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
12:51:47 <davidhouse> MarcWeber: perhaps using until? unless isEOFBin is monadic.
12:52:15 <musasabi> yaarg: you will most probably want 6.4.2 and that was released a short time ago.
12:52:53 <yaarg> musasabi: yeah
12:57:27 <davidhouse> hnn
12:57:29 <davidhouse> *hmm
12:57:42 <davidhouse> so why can't bootfiles be generated automatically??
12:58:02 <davidhouse> oops, i didn't mean to use The Bane Of Punctuation (two adjacent question marks)
13:06:15 <ndm> davidhouse: they can, if anyone was willing to put in the work
13:06:28 <ndm> both programatica and JHC get away without bootfiles
13:06:39 <davidhouse> it would seem to be very easy.
13:06:42 <ndm> and there is a paper that gives full specs for them
13:06:59 <ndm> davidhouse: you need to typecheck two files at the same time, which is hard if your compiler is full of gunk
13:07:03 <davidhouse> all you need to do is grep through a file for its function types and the names of the types it declares.
13:07:18 <davidhouse> and there you have a bootfile.
13:07:22 <ndm> davidhouse: type inference? you don't have to give types
13:07:42 <davidhouse> oh, true.
13:07:46 <davidhouse> hmm... what is required in a boot file?
13:07:50 <ndm> but i'm shocked no one has done even that so far
13:07:56 <ndm> types of everything exported
13:08:16 <ndm> i'd have thought that would be a 10 minute patch to haddock, and quite useful
13:11:27 <ihope> Ahh, this is no much nicer.
13:11:29 <ihope> s/no/so/
13:12:13 <ihope> literal x = do {y <- pop (length x); if x == y then epsilon x else noParse}
13:13:25 <davidhouse> ihope, what's that?
13:13:48 <ihope> It's a parser from my experimental parsey thingy.
13:15:14 <Cale> ndm: any luck with that monad?
13:15:25 <ndm> Cale, yep, its working perfectly, thanks very much
13:15:26 <Cale> ndm: I wasn't quite sure what features it was that you wanted
13:15:29 <ihope> ...Nice, it turns out to be pretty much exactly the same as ReadP.
13:15:32 <Cale> ah, good :)
13:15:53 <ndm> it wasn't too hard,  once i found http://www.haskell.org/hawiki/MonadState
13:16:06 <ndm> which is a really nice reference
13:17:16 <ihope> And not as good, at that.
13:20:42 <davidhouse> hmm... a bootfiles question.
13:21:33 <davidhouse> the GHC docs specify not to put instance decls in bootfiles
13:22:34 <davidhouse> but what if i need to?
13:23:31 <davidhouse> if in module B i  import {-# SOURCE #-}B in which are some instance decls i need in A, that's a problem.
13:25:55 <davidhouse> err, *if in module A I ...
13:28:07 <mauke> how do I overflowed stack
13:28:51 <mauke> I've written a program that's supposed to deal with infinite streams, but I get a stack overflow just trying to (take 1 (show x)) the result
13:29:20 <mauke> is there a simple way to find out where the laziness disappears?
13:30:01 <vincenz> @seen alar
13:30:01 <lambdabot> I saw alar leaving #haskell 1 month, 1 day, 3 hours, 28 minutes and 8 seconds ago, and .
13:30:12 <ndm> mauke, black holes and non-termination are the usual causes of stack overflow
13:30:16 <Cale> mauke: chances are you're building a large expression somewhere
13:30:33 <Cale> ndm: really?
13:30:45 <Cale> Normally if you hit a black hole, you'll get an exception
13:30:56 <ndm> Cale, yep, in my experience - I don't think i've ever had another one
13:31:08 <ndm> maybe thats Hugs vs GHC - in Hugs you don't get blackhole messages
13:31:08 <Cale> > iterate (+1) 0 !! 1000000
13:31:10 <lambdabot> Exception: stack overflow
13:31:30 <Cale> that's an example of the most common case, in my experience
13:31:39 <mauke> I only know it's related to this line: gen (Loop a b) = combineLen (gen b) (setFin Infinite (gen a))
13:31:52 <xerox>  dwim $ iterate (+1) 0 !! 1000000 ==> 0+1000000 :: ExpQ
13:31:54 <mauke> where a contains something that contains (Loop a b) itself
13:32:35 <Cale> mauke: remember that if you're trying to form an infinite data structure, some of the structure should be apparent after finitely many steps
13:33:08 <mauke> hmm?
13:33:36 <Cale> well... can I see your code?
13:33:49 <mauke> the data structure is let x = Loop (Literal 'a' x) Null in x
13:33:54 <mauke> sec, let me try something
13:36:05 <mauke> hmm, replacing combineLen by a dummy function doesn't help
13:37:32 <Cale> what does combineLen do?
13:37:58 <mauke> it joins two infinite streams by length
13:38:25 <mauke> i.e. ["a", "aa", "aaa", ...] `c` ["b", "bb", "bbb", ...] => ["a", "b", "aa", "bb", ...]
13:38:57 <xerox> c = flatten . transpose -- I think
13:39:16 <Cale> where it's guaranteed that the elements of the streams are in order of nondecreasing length?
13:39:23 <mauke> yes
13:39:35 <mauke> ah, it seems to be related to prepend
13:42:18 <mauke> ok, the file is at http://rafb.net/paste/results/sruXPW55.html but you won't be able to run it without Util or Gradef
13:45:08 <palomer> @hoogle intersperse
13:45:09 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:46:15 <mauke> whoa, now the stripped version does something completely different
13:47:01 <palomer> always a good sign
13:47:38 <mauke> no, I'm just stupid
13:47:50 <mauke> Cale: self-contained file: http://rafb.net/paste/results/lCm8au75.html
13:51:53 <goltrpoat> does !! basically just perform a linear search?  or is it accelerated in any way
13:52:58 <goltrpoat> also.. is there some sort of an equivalent of zipWith on Array?
13:53:40 <palomer> proofs are not frigging programs
13:53:46 <palomer> and programs are not frigging proofs
13:54:01 <palomer> gah!
13:54:07 <davidhouse> @palomer
13:54:08 <lambdabot> hrmph
13:55:04 <davidhouse> goltrpoat: you could define (x:xs) !! 0 = x; (x:xs) !! n = xs !! (n - 1), but it could be optimised, i'm not sure.
13:55:11 <davidhouse> @fptools Prelude
13:55:12 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
13:55:25 <davidhouse> @fptools Data.List
13:55:26 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:55:54 <davidhouse> @fptools GHC.List
13:55:54 <lambdabot> GHC.List not available
13:56:06 <ndm> goltrpoat: its just a linear search
13:57:21 <davidhouse> the report defines it as i did. GHC uses a slightly optimised version, i think/
13:58:06 <goltrpoat> yah i was mainly wondering if ghc was doing something funky like implementing lists as dynamic arrays behind your back
14:00:33 <ndm> goltrpoat: nope, they are still lists
14:00:37 <ndm> and its still O(n)
14:02:14 <goltrpoat> -nod-
14:02:14 <goltrpoat> thanks
14:06:40 <kzm_> hi, tuxplore1 
14:06:48 <tuxplore1> hi kzm
14:07:50 <joelr1> can i restrict the value type in a map to a particular constructor?
14:08:13 <joelr1> sorry, i forgot all about haskell over the course of 3 months :-)
14:08:19 <joelr1> gotta re-learn it
14:08:41 <Lemmih> Only with GADTs, I think.
14:08:54 <joelr1> umm... right
14:08:57 <joelr1> ok
14:09:10 <kzm_> joelr1, or you can wrap the type and hide one constructor?
14:09:36 <joelr1> nah, i'll probably have to split each constructor into a different type
14:09:46 <joelr1> well, here's what i'm trying to do
14:10:12 <joelr1> i have a bunch of counters. they all have a value or two and a "composite index" in the form of a few other values
14:10:51 <joelr1> i quickly typed up a counter type with a bunch of different constructors but i now realize that most of the values in the constructor are actually part of the key and i would be duplicating them in the map key
14:11:25 <joelr1> so now i'm thinking of seting up separate types for the composite keys and for each type of value (one value, two, etc.)
14:12:23 <joelr1> does that sound like a good idea?
14:12:58 <mux> @hoogle unlift
14:12:59 <lambdabot> No matches found
14:15:22 <kzm_> joelr1, yes, why not?  Not that I am an expert, and it depends on many things, of course.
14:18:50 <joelr1> damn, i can't build haskell on linux 64 :-(
14:18:53 <joelr1> not 6.5
14:21:11 <araujo> Hello!
14:24:50 <MarcWeber> davidhouse: sure it is ;)
14:24:56 <tuxplorer> kzm_ I had been reading YAHT, but i find it to be more of a preliminary text book.. can u suggest me something that would be ideal for me to start off with ur code?
14:26:57 <davidhouse> MarcWeber: sorry, what was that in respsonse to?
14:31:35 <joelr1> haskell is suprisingly easy to forget
14:31:56 * joelr1 is trying to remember how to read and process a text file line by line
14:32:12 <joelr1> books and tutorials to the rescue
14:32:39 <mahogny> joelr1, how much syntax is there to forget? =?
14:32:41 <mahogny> :)
14:33:11 <wchogg> I just use the listing of functions on zvon when I'm blanking how to do something.
14:33:14 <joelr1> mahogny: it's not about syntax, witness my figuring out how to read a file line by line. and i used to be pretty good at this just 3 months ago
14:33:22 <ndm> wchogg: use Hoogle :)
14:33:48 <ndm> before Hoogle, I used zvon all the time
14:33:57 <ndm> now i never do
14:34:43 <wchogg> Hoogle does seem pretty cool.  I should try using it more.
14:39:29 <tuxplorer> import Data.Set hiding (filter,map,null)
14:39:35 <tuxplorer> wat does the hiding do?
14:40:39 <ndm> tuxplorer: it doesn't put filter, map and null into scope
14:40:51 <ndm> so you can't use Data.Set.null in your module
14:41:02 <ndm> - useful if there is a clash of names, i.e. null's
14:41:10 <liyang> Qualified!
14:41:16 <joelr1> ok, i give up
14:41:27 <joelr1> how do i read every line of a file and do something with it?
14:41:29 <liyang> import qualified Data.Set as Set always!
14:41:34 <liyang> Raaaaaaaaaaawwwwwrrrr!
14:41:35 <tuxplorer> oh! ok
14:42:06 <araujo> joelr1: getLine 
14:42:31 <araujo> I also use to do, getContents >>= return . lines
14:42:37 <jip> @seen Saulzar 
14:42:38 <lambdabot> Saulzar is in #haskell. I last heard Saulzar speak 17 hours, 54 minutes and 57 seconds ago.
14:42:47 <joelr1> araujo: not that, how do i loop until the end of a file and collect strings into a list? i actually want to return a map so i figure i'll collect into a list and then return a map
14:43:34 <araujo> joelr1: isn't the idea to get all the lines of the file inside a list?
14:44:13 <joelr1> i need to use Data.ByteString to split each line on a comma and grab my key and value for the map
14:44:21 <joelr1> and then return the map itself after reading the file
14:45:12 <joelr1> there's hGetLine ...
14:46:32 <goltrpoat> joelr1..  putFileInList startList fileName = bracket (openFile fileName ReadMode) (hClose) (\handle -> hGetContents handle >>= (addStringToList startList) )
14:46:35 <goltrpoat> or somesuch
14:47:10 <joelr1> goltrpoat: the file is 4Gb big
14:47:22 <joelr1> but then hGetContents is lazy, right?
14:47:45 <goltrpoat> hmm.. not sure
14:48:05 <goltrpoat> there's probably a blockread version somewhere
14:48:22 * tuxplorer goes to sleep
14:49:28 <goltrpoat> ah
14:49:36 <goltrpoat> hSetBuffering
14:50:27 <goltrpoat> hSetBuffering :: Handle -> BufferMode -> IO(), and BufferMode has the constructor BlockBuffering (Maybe Int)
14:51:55 <goltrpoat> so im guessing just set the block size to something substantial
14:54:05 <jethr0> *GREAT*, i've just spent half an hour trying to find the bug in:
14:54:25 <jethr0> if x < 0 then x + pi else x in x = atan2 y x
14:54:31 <jethr0> *arghhhhh*
14:55:46 <goltrpoat> the bug being that x = atan2 y x is recursive?
14:56:25 <jethr0> yes, but haskell just accepted it and i simply didn't get it :(
14:56:44 <goltrpoat> hehe
14:56:57 <mauke> deja v
14:57:02 <goltrpoat> did it terminate?
14:57:15 <jethr0> not in ghci. ghc said <<loop>>
14:57:28 <jethr0> but i just didn't look at the name of the temporary variable...
14:57:47 <goltrpoat> what DOES x_i = tan^-1 (y / x_{i-1}) converge to anyway
14:57:48 <goltrpoat> or does it
14:57:48 <goltrpoat> hehe
14:58:06 <jethr0> no idea. not exactly what i wanted to calculate
14:58:13 <goltrpoat> :)
14:58:44 <jethr0> and it being tangens i'd be surprised if it converged in a sensible manner. but then again, i've been surprised by math time and time again
15:00:53 <mwc> Lot of folk here in real science, any of you ever taken a social science course? I need to take one for a breadth requirement, and don't know what to expect
15:01:51 <jethr0> "breadth requirement", nice! with my daily intake of sweets i should pass that even w/o additional courses ^_^
15:02:03 <wchogg> What do you mean by social science?  You mean history, anthropology, what?
15:02:16 <mwc> I took economics, thinking it would be the most mathematical one
15:02:24 <mwc> I'm used to applied math and physics courses
15:02:38 * mahogny feels sorry for mwc. social science :(
15:02:42 <mwc> topic more appropriate for #haskell-blah 
15:02:44 <wchogg> ...economics is often pretty shady mathematically, at least from what I've seen.
15:03:04 <mahogny> depends on who you ask
15:03:07 <goltrpoat> in what way?
15:03:15 <mahogny> there is pretty decent math in what economics I work on
15:03:16 <Adamant> anything from reasonably respectible science (economics, experimental psych, couple others) to total handwaving (sociology)
15:03:22 <jethr0> certainly business studies is _most_ shady when it comes to math. they add percentages as if were nothing
15:03:38 <Adamant> well, a lot of sociology
15:03:40 <Adamant> not all
15:04:17 <mahogny> econometrics. there you have actually have something that is currently driving the development of mathematics
15:04:20 <wchogg> Well, when I had some exposure to more mathematical economics I remember they basically assumed that any economic system could be modeled by *linear* PDEs.  That seemed odd to me.
15:04:43 <mahogny> not any, but many
15:05:31 <jethr0> i forgot what metric it was. but for some case the prof really added "40% + 60% + 70% = 170%" of totally unrelated percentages and used that number to interpret some business process. it was pretty awful watching that :)
15:05:37 <mahogny> the sole reason for settling with a linear one is because the parameter fitting is so much easier
15:05:41 <mahogny> and the theory as well
15:05:49 <mahogny> lol
15:06:10 <wchogg> mahogny:  I guess that just doesn't sit well with me.  Might just be a comfort issue.
15:06:16 <mwc> jethr0, you're kidding
15:06:35 <mwc> jethr0, as Clemens put it: there are lies, damn dirty despicable lies, and statistics.
15:06:51 <jethr0> nope, happened in real life and my uni is even considered pretty decent in business studies. it's one of their wacko metrics
15:07:29 <wchogg> jethr0:  I guess it kindof makes sense if you're not interpreting at as really a percentage of anything.
15:08:11 <jethr0> you just have to love their method: "how do you find the value of a startup? you find another startup which is identical in all parameters whose value you already know!" :)
15:08:30 * SamB spies what looks like Jabber, with stuff that looks like he might find it in his inbox, coming across the wire...
15:08:34 <jethr0> wchogg: i'm not even saying that their weird metric isn't usable in real life. but mathematically it made less than no sense
15:09:05 <mwc> Alright, well, I'm gonna go to my doom
15:09:11 <mwc> talk to you gents later
15:14:38 <wchogg> shapr:  Thanks for posting that paper up on LtU.  It's the one you thought was fun reading a few days ago, yes?
15:17:27 <shapr> wchogg: Yeah, that's the one.
15:17:57 <shapr> It's way nifty, and makes me want to read the rest of Wadler's history papers.
15:18:00 <shapr> franka: y0
15:18:52 <shapr> g'day doublec 
15:18:55 * mahogny has run out of post-it notes :(
15:19:01 <doublec> hi shapr
15:19:38 <mahogny> Mark Reitblatt. is he in this chan?
15:19:41 <shapr> I played with Aardappel some today, that's fun and confusing.
15:20:09 <shapr> xerox__: awake?
15:20:09 <doublec> shapr, Thanks for progressing access to the unify sources. It's great to see the source.
15:20:14 <shapr> xerox: ping?
15:20:22 * palomer wishes there was an if statement withoun an else for monads like nondet
15:20:25 <xerox> shapr: pooong
15:20:31 <shapr> doublec: Yeah, it's spiffy code. It'll make a variety of tasks easier.
15:20:39 <jethr0> "when"?
15:20:56 <shapr> xerox: Hey, um... SoC question.
15:21:10 <xerox> Yes?
15:21:35 <SamB> shapr: aren't you a little old for that?
15:21:48 <mahogny> xerox, you know Mark Reitblatt?
15:22:09 <jethr0> SamB: that hurts...
15:22:19 <shapr> Marc van Woerkom wants to write a language parser, one of C/PHP/Java. I figure PHP is the best choice, since there are existing parsers for C and Java. What do I do next?
15:22:25 <shapr> SamB: huh?
15:22:56 <SamB> shapr: silly joke probably ruined by lag!
15:22:56 <mahogny> shapr, sign up, mentor? :)
15:23:00 <jethr0> shapr: get the language specs/report for php?
15:23:20 <shapr> I can handle the mentor and specs part, I'm just not sure about the SoC process.
15:23:26 <jethr0> ah
15:23:43 <shapr> Do I need to get google to approve specific projects?
15:23:44 <xerox> shapr: for the official side - he is going to submit his proposal thought the Google form, and the request will arrive to us.
15:23:53 <shapr> Ah, cool.
15:24:08 <xerox> shapr: then, we'll be rating and approving applicants officially.
15:24:18 <shapr> Cool
15:25:57 <shapr> SamB: I still didn't get it. I'm too old for SoC tasks?
15:26:17 <SamB> shapr: it was a *silly* joke
15:26:24 <wchogg> I just wish I knew how many students could actually get taken for haskell.org
15:26:41 <SamB> how many have applied now?
15:26:46 <ADEpt> xerox: who rates proposals - all mentors or admins only?
15:26:53 <ADEpt> btw, hi everybody
15:26:59 <xerox> ADEpt: dunno yet
15:27:01 <SamB> hello
15:27:06 <wchogg> SamB:  Well aren't there ~20 students who have said they were interested on the site?
15:27:19 <SamB> well, Cale said four had applied earlier
15:28:04 <wchogg> I haven't finished my applications yet.  I thought it'd do that tonight or wednesday.
15:28:50 <wchogg> xerox:  We are supposed to submit a separate application for each project we'd like to work on, right?
15:29:39 <shapr> Too many questions overloaded xerox!
15:29:54 <shapr> He's back! Or is it just a xerox copy?
15:29:58 <wchogg> xerox:  We thought you were trying to run from the questions.
15:30:05 * shapr grins
15:30:13 <wchogg> Oh snap.
15:30:55 <shapr> wchogg: Did you read the 'proofs are programs' paper?
15:30:59 <xerox> Argh.
15:31:01 <xerox> May you repeat?  Damn client.
15:31:49 <wchogg> shapr:  I'm almost done with my first run through of the frege paper.  Are you talking about a different one?
15:31:56 <shapr> That's the one.
15:32:30 <wchogg> xerox:  I just wanted to ask if we were definately supposed to have different applications for each project we wanted to do.
15:32:42 <xerox> wchogg: yes, absolutely.
15:33:04 <wchogg> xerox:  Thanks, I appreciate it.
15:33:11 <xerox> You're welcome.
15:33:14 <shapr> I was amazed at how much the standard type theory proofs resemble Frege's original notation.
15:33:55 <wchogg> shapr:  I know!  That's what I first thought actually.  It's pretty neat.  This paper is also a pretty nice introduction to basic logic and lambda calc I think.
15:34:11 <shapr> Yeah, I agree.
15:34:39 <shapr> doublec: Any other Haskell projects you want source for? :-)
15:35:08 <shapr> Oh, I gotta reply to the Dance guys. I think they offered me source if I didn't mind a beta version.
15:35:49 <jethr0> how do i get the truncated part of a float? like "f (-1.333) = 0.333"?
15:38:20 <jethr0> i really miss an "fmap" function in the prelude...
15:38:23 <mahogny> well. floor it, and subtract
15:38:23 <doublec> I think playing with unify will keep me busy :) 
15:38:46 <shapr> Have you tried Oleg's ZFS?
15:38:55 <doublec> There's too much good stuff out there - I can't keep up. I want to have a go at playing with Happs too when I get some free time.
15:38:55 <jethr0> mahogny: thx, but that's not exactly nice. especially since it doesn't work transparently with negative numbers
15:39:06 <doublec> I've looked at ZFS but haven't tried it. 
15:39:26 <shapr> doublec: I put research papers and code on my Nokia 770 so I can read on the bus, while waiting for appointments, etc.
15:39:33 <doublec> It's ZFS and Happs that got me diving it haskell more fully
15:39:46 <mahogny> jethr0, less nice then; convert to string, drop until ., convert back? :)
15:39:53 <doublec> shapr, good idea. I used to have a Zaurus C760 and did similar. The nokia 770 looks nice.
15:40:00 <jethr0> mahogny: hmm
15:40:06 <mahogny> jethr0, or just check first if it is negative or not. consider two cases
15:40:40 <shapr> JHC produces ANSI C that builds for the 770. I have not yet tried to build any decent sized Haskell programs with JHC yet.
15:40:56 <goltrpoat> so i came up with a little optimization/style exercise for myself..  gauss-jordan elimination on a list-based vector/matrix representation
15:41:09 <jethr0> yes, but i was hoping for sth standard like anti-truncate or fmap. well, maybe i can get sth working with truncate
15:41:13 <jethr0> thx, bbl
15:41:26 <doublec> I should try jhc with my fledgling space invaders emulator in Haskell and see how it goes.
15:41:31 <shapr> But I have a JHC produced 'hello world' binary that's 5k or something.
15:41:44 <goltrpoat> can someone take a look at http://rafb.net/paste/results/JMsTog66.html and tell me if my first optimization attempt is actually an optimization, and if anything jumps as far as further optimization is concerned?
15:42:15 <goltrpoat> i'm guessing the two indexing operations are the bottleneck
15:42:43 <goltrpoat> er.. jumps = jumps out
15:43:24 <shapr> goltrpoat: Have you profiled it?
15:43:37 <mahogny> indeed. the !! are pure evil. but I think you can get away quite cheap if you do it right
15:44:10 <goltrpoat> shapr:  no, but i'd be surprised if the bottleneck was someplace else
15:44:28 <mahogny> the other evility is keeping to rebuild the matrix. immutability is another key to speed
15:44:49 <goltrpoat> oh, good point.. thanks
15:45:45 <mahogny> seq'ing some might improve further, since you should be quite aware of what really has to be touched without having to rely on laziness. but I can't tell how much you gain by it
15:46:32 <goltrpoat> seq'ing where?
15:47:00 <mahogny> a bit everywhere. I don't dare say where is the best places since I have so little experience with it
15:47:07 <goltrpoat> ah
15:47:14 <shapr> Anyone know if type theory has been applied to martial arts?
15:47:20 <goltrpoat> k i'll meditate on that
15:47:28 <shapr> hah
15:47:56 <SamB> ???
15:47:56 <lambdabot> Maybe you meant: . id pl v wn
15:48:02 <mahogny> shapr, I'd like to see you infer types to make the proper moves during a fight :)
15:48:15 <shapr> Actually, that's why I want the Dance source.
15:48:21 <goltrpoat> martial arts violate referential transparency
15:48:29 * shapr snickers
15:48:38 <wchogg> shapr:  Well the obvious question when applied to eastern philosophy would be what is the type of the Tao.  (I think it's IO () )
15:48:47 <doublec> That's the first thing I thought of when I looked at that paper
15:48:49 * shapr laughs
15:48:59 <shapr> doublec: Seriously?
15:49:03 <mahogny> martial art makes lots of use of unsafeperformIO. at least if you mess around with them
15:49:27 <doublec> shapr, yes. I do taekwondo and brazilian jiu jitsu
15:49:46 <shapr> Nifty. So it's not just me that thought of building a type theory of martial arts.
15:50:31 <shapr> I suspect there's an equivalent of Goedel's Incompleteness Theorem in martial arts.
15:50:46 <shapr> doublec: Do you know of any theoretical systems built from martial arts?
15:51:04 <doublec> shapr, not that I know of.
15:51:40 <goltrpoat> i think there's a bit of formal theory in fencing
15:52:07 <shapr> Any pointers?
15:52:14 <ihope> @type par
15:52:15 <lambdabot> Not in scope: `par'
15:52:19 <ihope> @index par
15:52:19 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
15:52:26 <ihope> @docs GHC.Conc
15:52:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
15:52:39 <goltrpoat> http://www.fencingonline.com/academy/fencingtheory.htm#Convention_of_foil_fencing seems to talk about it.. i don't know anything about fencing, studied other martial arts for about 7 years though
15:53:00 <ihope> ...So what does par do?
15:53:16 <wchogg> shapr:  Got any other recommendations for papers after that one?
15:53:57 <shapr> Hm, I read a bunch of papers...
15:54:15 <shapr> Any particular subject you prefer?
15:54:27 <shapr> goltrpoat: Good link, thanks.
15:54:54 <wchogg> shapr:  Well I like category theory, to be honest.  I'm trying to understand the formal aspect of writing programs better.
15:55:26 <shapr> Hm, have you seen the bananas, lenses, barbed wire & envelopes papers?
15:55:44 <wchogg> ...oddly enough, I always thought category theory was fun because you can apply it to theoretical physics rather nicely.
15:55:56 <shapr> CT works for a lot of things.
15:55:57 <wchogg> shapr:  Someone just linked to it on LtU, but I hadn't read it yet.
15:56:49 <shapr> Those papers are worth trying at least.
15:57:13 <shapr> Oh, you may want to check out the Epigram papers next.
15:57:24 <shapr> 'Why Dependent Types Matter' and 'The View from the Left'
15:57:38 <shapr> Epigram is the next step from Haskell towards proof programming.
15:58:05 <wchogg> Oh yeah...I need to check the epigram dev blog.  I've been waiting for v2.0 to come out before I really got into it.
15:58:53 <shapr> Charles A. Stewart extended the CH correspondence into a subset of the formalisms used in philosophy - http://www.linearity.org/cas/thesis/
15:59:07 <shapr> I've been drowning in that thesis for weeks.
15:59:28 <shapr> I mean, Prawitz's inversion principle? Do what?
15:59:44 <shapr> "We show how to situate the formulae-as-types correspondence within the proof-theoretic account of logical semantics arising from the work of Michael Dummett and Dag Prawitz, and demonstrate that the admissibility of Prawitz's inversion principle, which we argue should be strengthened, is essential to the good behaviour of intuitionistic logic."
16:00:23 <wchogg> I'm in theoretical physics and even *I* think philosophy is too out there. ;-)
16:00:31 <shapr> "By regarding the rules which determine the deductive strength of classical logic as structural rules, as opposed to the logical rules associated with specific logical connectives, we extend Prawitz's inversion principle to classical propositional logic, formulated in a theory of Parigot's lambda-mu calculus with eta expansions."
16:00:41 <shapr> Um, yeah, what he said.... I think.
16:01:34 <shapr> Anyway, it took me two years or so to understand arrows, so I figure it'll take me that long or longer to understand this thesis.
16:02:03 <wchogg> I actually have this book from the library I'm working on called "Algebraic and Coalgebraic Methods in the Mathematics of Program Construction".  It looks fun.
16:02:21 <shapr> But I'm willing to erode away the frontiers of my knowledge until I can't click the mouse.
16:02:30 <shapr> Oh that does sound like fun.
16:02:47 <shapr> That vaguely reminds me of the 'Haskell Road to Logic & Maths' seen it?
16:03:03 <wchogg> Yeah, I have that book actually.
16:03:11 <wchogg> This book is alot more hardcore though.
16:03:11 <shapr> You like it?
16:03:25 <shapr> I keep getting distracted from 'Haskell Road'
16:03:29 <wchogg> I think it's decent.  I didn't read through the whole thing though.
16:03:41 <ndm> @seen ihope
16:03:41 <lambdabot> ihope is in #haskell. I last heard ihope speak 10 minutes and 40 seconds ago.
16:03:47 <ndm> ping ihope
16:03:50 <ihope> Pong.
16:04:14 <shapr> My goal of the last year or so has been to truly understand proof programming. I expect that to take a few years.
16:04:24 <shapr> hiya laurence, learning Haskell?
16:04:41 <ndm> ihope, "Win32 console handler thingy" - expand :)
16:04:52 <ihope> :-)
16:05:07 <ndm> i have written "console handler thingy's" and might be able to point you at some code, depending on your definition of thingy
16:05:15 <shapr> hiya beschmi, ltns
16:05:25 <wchogg> shapr:  I mostly just care about trying to understand the mathematics of CS enough that I can apply it to theoretical physics in a much more effective way.
16:05:41 <shapr> Sounds like a worthwhile goal.
16:05:41 <ihope> Well, I was wanting to open a console, write text to it, read from it, and in general handle it via the IO monad.
16:05:43 <beschmi> hi shapr, was pretty busy with school
16:05:46 <beschmi> hi all
16:06:09 <ndm> ihope, so a wrapper, WinHaskell does that
16:06:29 <laurence> shapr: That may be a subject for debate. :-)
16:06:32 <ndm> and the code is very complex, so i recommend copying it :)
16:06:41 <shapr> Oh, I've been looking at Yong Luo's dependent type system with partial functions instead of eliminators, trying to figure out what that's all about.
16:06:53 <ndm> @where+ WinHaskell http://www-users.cs.york.ac.uk/~ndm/projects/winhaskell.php
16:06:53 <lambdabot> Done.
16:07:33 <dons> moin
16:07:36 <shapr> g'day dons
16:07:49 <shapr> laurence: You want to learn Haskell but need help?
16:08:00 <araujo> morning dons , shapr 
16:08:00 <dons> neologism: hey, i was wondering how much faster 'count' improved your code?
16:08:08 <ndm> ihope, http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=winhaskell;a=headblob;f=/Console.cpp
16:08:32 <shapr> araujo: You heard xerox say you have to submit your project application to Google so the haskell.org mentors get it, yeah?
16:08:41 <laurence> shapr: I was kind of making a joke.  I'm playing with the "Scheme in 48 hours" tutorial, at any rate, so I guess I'm learning Haskell for suitably small values of $learn.
16:08:43 * laurence grins.
16:08:46 <shapr> Ah, cool.
16:08:50 <ihope> ndm: that doesn't look like Haskell.
16:09:05 <araujo> shapr: yay! .... i hope to do that with my next appli within a few hours or so
16:09:10 <shapr> spiffy
16:09:20 <laurence> shapr: According to the "real programmers can write fortran in any language" theorem I should eventually be able to write fortran in Haskell.
16:09:23 <ndm> ihope, its not, but the API wrapper is so direct its almost a line by line conversion
16:09:24 * laurence runs.
16:09:47 <ihope> So just what do I do with that file?
16:09:59 <shapr> laurence: I see :-)
16:10:02 <ndm> read it, copy the bits you can, as it will probably save you some time later
16:10:11 <ndm> it took _ages_ to figure out that code
16:10:27 * laurence cautiously pokes his head back around the corner.
16:10:39 <ndm> lots of API calls with weird flags, and even slightly changing one bit breaks it all
16:11:00 <ndm> and then use System.Win32 to reimplement it
16:11:25 <ihope> Where can I find stuff on System.Win32?
16:11:57 <Cale> laurence: of course you can
16:12:01 <ndm> @index System.Win32
16:12:01 <lambdabot> bzzt
16:12:09 <ihope> @docs System.Win32
16:12:09 <lambdabot> System.Win32 not available
16:12:43 <ndm> ihope, install GHC on your windows machine, and the documentation shouold be present
16:12:52 * ihope looks
16:13:12 <ndm> the we ones are all built under Linux, and hence lack win32 docs
16:13:33 <palomer> <:o
16:13:41 <ihope> Here we go!
16:14:13 <ndm> from a brief look, it appears incomplete, but i'm not sure
16:15:05 <dons> laurence: fortran versus haskell: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all ;)
16:15:23 <ihope> So now do I have to translate that .cpp stuff into Haskell?
16:16:03 * shapr sleeps
16:16:05 * shapr &
16:16:05 <dons> laurence: or http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all (even better)
16:16:08 <ndm> ihope, maybe, i'm not sure that API will have all the required bits in it
16:16:08 <laurence> dons: Jokes aren't funny when you explain them, of course, but it's all about style not performance.  Six-character identifiers in all caps, no indentation, that sort of thing.
16:16:23 <dons> ah. i c.
16:16:39 <ihope> I'll try it.
16:16:48 <ihope> Thanks.
16:17:05 * laurence hasn't written more than three lines of fortran since DEC's f77 extensions were the great thing for adventurous programmers.
16:17:30 * laurence would say what performance language he uses, but he is too sensitive to tribal customs and taboos.
16:17:40 * laurence chuckles.
16:17:47 <dons> heeh
16:18:08 <dons> the nsieve benchmark still blows me away on the shootout. some serious magics from ghc there
16:18:53 <ndm> that looks incredible, the nsieve, 4 times less memory than GCC, thats pretty incredible
16:19:07 <Saulzar> Well you're stuffed for all caps identifiers in haskell, at least
16:19:16 <Saulzar> You can go for all caps constructors and types though
16:19:45 <wchogg> Saulzar:  He can capture the "wtf?!" feel of reading fortran77 by using all point-free style.
16:20:07 <dons> ndm, it was hand tweaked after lookign at the Core, but otherwise fairly natural, I suppose.
16:20:43 <laurence> Saulzar: As long as I can make it somewhat unreadable and most importantly flatten out every hint of style and taste, the theorem holds. :-)
16:20:58 <wchogg> dons:  I don't think that's really cheating though.  If absolute performance is necessary, at least that's still an option.
16:21:10 <dons> right. its not cheating until you use the ffi
16:21:14 <Saulzar> Ah, well you can do that well enough. Make good use of brackets rather than indents and @pl, you'll be right at home
16:22:17 <laurence> dons: I regard that as a bug in the C compiler or the code.  Note how the C++ version used less memory.
16:22:21 <dons> of course, we clean up on the concurrency benchmarks too http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
16:23:18 <laurence> Saulzar: If pressed, I can defend the integrity of the theorem with a little CPP magic.  Presto, all caps. =8-O
16:24:15 * laurence wonders if that would really be an instance of the much lesser known theorem "real programmers can write RATFOR in any language".
16:24:45 <wchogg> I don't even know what RATFOR means.
16:25:05 <dons> looks like HAskell's just good for packed unboxed bit arrays.all the haskell entries there have good memory usage.
16:25:38 <laurence> wchogg: A long time ago, in a galaxy far away, someone tried to rationalize fortran syntax with (IIRC) a fancy preprocessor.
16:26:16 <wchogg> laurence:  I'm guessing that was probably *way* before my time.
16:27:37 <laurence> wchogg: Probably. :-)  The only evidence left is archeological.  Take a gander at GNU make's rules for .r and .F files: http://www.cs.utah.edu/dept/old/texinfo/make/make.html#SEC88
16:27:38 <palomer> celebrate good times come on!
16:28:10 * laurence is too young to have used ratfor too, but has a good memory for useless things.
16:29:11 <jethr0> i'm amazed how well clean fared in the shootout. too bad it's not a "free" language
16:30:02 <ndm> the clean code also looks nicer than the Haskell in several cases
16:30:09 <jethr0> yup, i saw
16:30:19 <ndm> whats non-free about Clean?
16:31:02 <jethr0> ndm: i don't really know, but i had this feeling there were strings attached. shouldn't propagate such prejudices in here, i guess
16:32:30 <gripe> hi wolverian, metaperl, Maddas, and all
16:32:45 <jethr0> you gotta register before you can download the compiler :(
16:33:16 <gripe> <-- Haskell day 1 - initial feelings: scared. outlook: positive.
16:33:23 <ndm> jethr0: http://www.cs.ru.nl/~clean/Download/License_Conditions/body_license_conditions.html
16:33:39 <doublec> I've built jhc but doing a make install results in it not being able to install base-0.1.hl because it can't find it. Any idea what I might be doing wrong?
16:33:39 <ndm> you have to release your source, or pay money
16:33:46 <ndm> thats not particulary free
16:33:55 <musasabi> doublec: make fetch-libs
16:34:03 <doublec> thanks musasabi 
16:34:30 <palomer> shapr: who selects the projects for SoC?
16:34:39 <musasabi> (if that doesn't work then shout and I'll look at what is wrong)
16:34:50 <mwc> palomer, lambdabot selects the projects
16:34:53 <palomer> actually, this question is for any mentor
16:34:57 <palomer> @seen shapr
16:34:57 <lambdabot> shapr is in #haskell. I last heard shapr speak 18 minutes and 52 seconds ago.
16:35:05 <mwc> dons is actually an android avatar used by lambdabot
16:35:13 <Lemmih> palomer: The students.
16:35:30 <palomer> I mean, who selects which students get accepted
16:35:41 <laurence> ndm: Hmm, looks free on the surface.  Looks like a standard dual-licence, no different than (say) MySQL.  What did I miss?
16:35:50 <jethr0> ndm: i wouldn't say that. lgpl isn't such a bad license...
16:35:59 <Lemmih> palomer: The mentors can rate student projects.
16:36:00 <doublec> musasabi, that worked. Thanks.
16:36:06 <ndm> laurence: its more restrictive than most compilers
16:36:25 <Lemmih> (student proposals, really)
16:36:36 <laurence> ndm: Uh, GCC is plain GPL'd, and nobody has ever sanely claimed it isn't free.
16:36:58 <jethr0> ndm: i just couldn't find anywhere to download the compiler sources. but i guess they're somewhere in that registration form
16:37:00 <ndm> laurence: the way they say it, it sounds like the executable generated is also covered by the LGPL
16:37:08 <musasabi> and in addition one has to sign a scary legal agreement for contributions (for GCC).
16:37:14 <jethr0> ndm: that's not how lgpl works
16:37:17 <ndm> whereas GCC explicitly states that no additional license is added to the exe
16:37:25 <palomer> Lemmih: who makes the decisions though?
16:37:42 <ndm> from the Clean page: "A commercial license has the advantage that one is not obligated to make source code available"
16:38:17 <laurence> ndm: If it's straight LGPL, that wouldn't be the case.  It would only cover parts of the runtime and translator that are put into the compiler's output: the LGPL, by design, doesn't affect your code (well, OK, except that you're supposed to be able to replace the LGPL'd part, that would be a potential gotcha).
16:38:32 <ndm> yeah, i know thats the usual menaing
16:38:39 <musasabi> laurence: LGPL + static linking is the issue.
16:38:56 <ndm> but hte way they've phrased it, they seem to say pay money to keep your stuff closed source
16:38:59 <musasabi> at least that is the usual problem with LGPL.
16:39:06 <doublec> nice, a 5Kb hello world from jhc.
16:39:07 <laurence> musasabi: I can't imagine what is scary about the gcc contribution system.  It's the only reason a project as big as GCC works.
16:39:38 <ndm> GCC deliberately won't take patches to simplify their compiler in certain aspects, as they think it will make them easier to be ripped off
16:39:43 <Lemmih> palomer: I think Google have to give their okay for each project but I'm not sure.
16:39:44 * laurence didn't mean to step in a GPL quarrel.
16:39:58 <ihope> doublec: yow
16:40:09 <laurence> ndm: If you mean the "no opaque intermediate language," I happen to agree with them.  Steve Jobs convinced me completely. :-)
16:40:13 <ihope> That's... bigger than the source, isn't it?
16:40:37 <ndm> laurence: when politics comes before code, politics is broken
16:40:45 <musasabi> laurence: the FSF legal agreement is not something I personally like very much. Then again usually I tend to prefer BSD3 or MIT license.
16:40:49 <laurence> ndm: I think I'll just not get into that one.
16:41:16 <goltrpoat> is there some sort of a major difference between clean and haskell?  the code in intro on the clean site looks like haskell code with a couple of minor differenes
16:41:17 <doublec> I'll try the 8080 cpu emulator with jhc soon and comapre with ghc. 
16:41:31 <ndm> goltrpoat: uniqueness types is the biggie
16:41:32 <doublec> I just need to convert the rom somehow since jhc doesn't do binary i/o
16:41:39 <laurence> musasabi: I'd happily sign it.  I'd rather Eben Moglen organize the defense in case my copyright is violated.  That, to me, is putting my personal coding first. :-)
16:42:11 <jethr0> goltrpoat: they use uniqueness typing instead of IO monad
16:42:19 <laurence> musasabi: 
16:42:20 <goltrpoat> oh i see
16:42:35 <laurence> musasabi: Sorry, at least we probably agreed about the bison licence change being a good idea. :-)
16:42:38 <goltrpoat> uniqueness types being a guarantee on an object that states that the object is used in exactly one place?
16:42:46 <jethr0> although i haven't looked at clean, i think that's the major difference. and also they might not be as reliant on monads in general, but that's just a guess of mine
16:43:28 <musasabi> laurence: I just want to share ideas not fight about copyrights and other stuff. Basically mixing legal agreements and thinking what their combination means with the local law is not something I enjoy doing very much.
16:43:32 <ndm> they use very little monads, if any
16:43:38 <ndm> although they can easily be implemented
16:43:56 <goltrpoat> yah
16:44:04 <jethr0> goltrpoat: i really don't know. it just makes sure that ref. transparency is obeyed and supposedly gets less in the way than the IO monad
16:44:22 <laurence> musasabi: We'd probably agree that actually having to think about and write licences was a loss of innocence for hackers.
16:44:52 <goltrpoat> ah
16:45:08 <jethr0> laurence: i don't necessarily agree. if by hackers you mean "innocent" people who do software just for fun, it's not much consideration there to choose between BSD and GPL.
16:45:25 <musasabi> laurence: yes, usually I just want to use a "don't claim you have written this and it is not my fault if it eates your computer for breakfast."
16:45:32 <jethr0> if any (even future) business interests are involved it all gets a lot more tricky
16:46:32 <musasabi> of course usually I have to cross check all the business agreements and non-competition things etc, which makes additional contracts like the FSF one extra pain.
16:46:45 <jethr0> i even think that the FSF and BSD in a way empowered the community. it gave them much more a feeling of a common goal instead of everybody just anonymously dumping stuff in the public domain
16:46:50 <laurence> jethr0: I guess I don't mean "just for fun" when I say hacker.
16:48:06 <jethr0> but i agree, at a project at my university we never could be sure which licenses would be ok with our funding and the employment contracts.
16:48:13 <laurence> musasabi: Erk, I should stop.  But I think the FSF assignment makes it *easier*; you have one copyright holder to deal with, not like the Linux kernel.  Someday someone's going to be legally obligated to obtain forgiveness from several thousand people, including dead ones, before they have the legal right to distribute Linux after an inadvertent error. :-)
16:48:41 * laurence tries to stop defending the FSF.
16:49:02 <musasabi> laurence: it makes it easier for the offending users, harder for the developers.
16:49:08 * laurence checks and is thankful he's not wearing his "GPL3: Free as in Freedom" shirt today.
16:49:14 <jethr0> hehe
16:49:35 <jethr0> is the gpl3 even finalized yet?
16:49:40 <laurence> musasabi: Fair enough, there is no doubt that extra red tape is involved.
16:50:02 <musasabi> But then again FSF has the right to do so, and it is not a bad thing.
16:50:10 <musasabi> just extra hasle.
16:51:05 <laurence> musasabi: I only meant to say I agree with why they do it, and GCC is IMO the most important Free software project there is.  But I don't mean to say it isn't bureaucracy, of course you are absolutely right there.
16:51:49 * musasabi hopes GPL3 will have the non-free optional clauses killed and the DRM bits removed.
16:52:01 * laurence ruefully realizes he would have gotten further than the "kill whitespace" version of the parser if he weren't nattering about licencing!
16:52:02 <musasabi> laurence: I can agree with that.
16:52:50 <laurence> musasabi: GCC is, rather indirectly, one reason I'm playing with Haskell today (maybe tomorrow too).  But that's a story for a different day.
16:53:40 <musasabi> ok, have fun hacking the parser. I should probably try to sleep.
16:55:16 <laurence> musasabi: And I thought it was a better idea for a tutorial than most, too.  Who needs to study syntax and semantic structure when you can just hack away in a guided fashion?
16:55:33 * laurence grins wickedly.
16:59:10 <goltrpoat> hmm.. doesn't look like System.Win32 is documented in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html .. never heard of it until a minute ago, as a result
17:02:29 <jethr0> nite
17:04:47 <newsham> any good ssl libs?
17:06:24 <prionic> i have a problem with ghci, maybe someone can point me into the right direction
17:22:30 <goltrpoat> does pl support undeclared functions in the expression?
17:22:38 <goltrpoat> i guess i could just try it
17:22:43 <goltrpoat> @pl \(i, m) -> rowOp n i m
17:22:43 <lambdabot> uncurry (rowOp n)
17:23:02 <goltrpoat> ok, why did that not occur to me
17:23:36 <Cale> prionic: what problem?
17:38:35 <Fromage> Hello
17:38:38 <Fromage> I was wondering ...
17:39:02 <Fromage> Does Haskell have a Prelude operator to get the lower integer part from a fractionary number ?
17:39:33 <Fromage> Because I have to perform an operation that requieres an integer number as a parameter
17:40:06 <M3wkuskerekHarc> floor?
17:41:11 <Fromage> Yeah, that
17:41:15 <Fromage> Is floor that suitable operator ?
17:44:11 <dons> > floor pi
17:44:12 <lambdabot> 3
17:45:03 <dons> if in doubt, try it out! :)
17:48:20 <Fromage> Thanks, don
17:48:33 <Fromage> length [1,2,3,4,5]
17:48:39 <Fromage> Hey
17:48:43 <Fromage> The lambdabot does not obey me
17:48:43 <Fromage> !!!
17:48:44 <Cale> > length [1,2,3,4,5]
17:48:45 <lambdabot> 5
17:48:51 <Fromage> Ohh
17:48:58 <Fromage> I must put the right arrow before
17:49:04 <Cale> yeah, and then a space
17:49:12 <Fromage> > length "Iwannaholdyourhand"
17:49:13 <lambdabot> 18
17:49:17 <Fromage> It's fantastic
17:49:31 <Fromage> How created this wonderful bot ?
17:49:54 <Cale> dons did most of the work
17:50:31 <Cale> Also, it uses his hs-plugins to evaluate Haskell expressions safely
17:51:07 <Cale> note that because of the type system, it's obvious which expressions are IO actions, and those actions are not executed.
17:51:10 <dons> astonishingly, there's two papers in which lambdabot's mentioned.
17:51:11 <Cale> > print "Hello"
17:51:11 <lambdabot> No IO allowed
17:52:25 <Fromage> Why are IO not permitted ?
17:52:48 <dons> writeFile "/etc/passwd" "random string"
17:53:26 <Cale> well, not that the bot would be allowed to write to /etc/passwd anyway, but still, that sort of thing would be trouble
17:54:25 <Adamant> writeFile "/dev/kmem" "rootkit code goes here"
17:55:00 <Fromage> I see
17:55:07 <dons> or writeFile "/tmp/kill" $ repeat '!'
17:55:17 <Fromage> Is lambdabot hosted in a computer of your property, dons?
17:55:33 <dons> would be enough to cause me headaches.
17:55:54 <Adamant> of course, lambdabot doesn't have root access
17:55:57 <Adamant> I hope
17:55:59 <Fromage> Now I understand, it can be quite dangerous
17:56:11 <dons> its a general principle that you don't allow unrestricted ability to run programs as local users by remote, random people :)
17:56:19 <Fromage> Maybe it was given root permission in order to perform some obscure tasks, Adamant
17:56:23 <Fromage> Who knows :)
17:56:26 <Adamant> true
17:56:30 <dons> i hope not.
17:56:39 <Adamant> it would be bad design
17:56:58 <Fromage> Where are you from, dons?
17:57:10 <dons> at the very least, i'd do some priv separation into two processes if that was the case.
17:57:13 <Adamant> if you're just executing code, which doesn't require any root privs
17:57:14 <dons> ?version
17:57:15 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
17:57:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:57:35 <Adamant> yeah
17:58:15 <Fromage> I've never tried GHC, how it works ?
17:58:19 <dons> Fromage: I'm in Sydney :)
17:58:24 <Adamant> thing of the online language REPL's as sort of a RPC mechanism... only you're exposing it to a IRC channel full of random strangers with unknown intentions
17:58:29 <Adamant> think
17:58:36 <Fromage> Is it better to compile Haskel code, or just testing it in the better-looking HUGS enviroment ?
17:58:42 <Fromage> Nice place, dons
17:59:07 <Fromage> Actually, a much better place to live than mine
18:00:05 <mwc> Fromage, I'm not sure what the hugs environement gives you that ghci doesn't
18:00:17 <Cale> Fromage: people do both -- also GHC comes with an interactive environment which is similar to hugs called GHCi. It can load code which has been compiled as well as interpreting it.
18:00:35 <Fromage> The possibility to test my functions very quickly
18:00:49 <Cale> I tend to consider GHCi/hugs as debuggers.
18:01:12 <Fromage> I'm curious about GHC, Cale
18:01:25 <Cale> They're good for testing code that you've written, as well as avoiding having to design a user interface
18:01:29 <Fromage> Does it convert Haskell source coude into a binary computer-exectuable format ?
18:01:35 <Cale> yes
18:01:36 <Fromage> Like GCC does with standard C code
18:01:39 <Cale> yeah
18:01:43 <Fromage> Quite nice
18:02:01 <Fromage> Well, I have a University subject abou compiler design the following year, I think
18:02:01 <Cale> It can compile via C or directly to assembler for a variety of platforms
18:02:02 <Pseudonym> Greetings.
18:02:12 <Cale> (Intel, PPC, Sparc, a few others)
18:02:24 <Fromage> Would be nice having such a masterpice of freesoftware available for learning about that topic
18:03:34 <Adamant> lots of free/open, high-quality compilers out there for many language
18:04:00 <Pseudonym> I'd recommend one of the ones that comes as a book.
18:04:08 <Pseudonym> More or less.
18:04:17 <Pseudonym> The LCC book is particularly good.
18:04:52 <Pseudonym> http://www.cs.princeton.edu/software/lcc/
18:05:00 <Adamant> I have "Engineering a Compiler" by Cooper and Torzcen, I need to finish more than the first half
18:05:46 <Pseudonym> I also recommend Appel's "Modern Compiler Implementation in ML" and "Compiling with Continuations".
18:06:13 <Pseudonym> Get the ML version because the Java and C versions are... well... the Java/C code makes more sense if you translate it back into the original ML.
18:06:36 <Pseudonym> Of course, when I say "get", I mean "borrow from your university library".
18:07:46 <Pseudonym> I haven't read "engineering a compiler".
18:07:55 <Pseudonym> I have read the old Alan Holub book multiple times, though.
18:08:12 <Pseudonym> And Steven Muchnick's book on optimisation is nothing short of brilliant./
18:08:51 <Adamant> Muchnick's stuff is still the standard for optimization
18:08:54 <Fromage> Pseudonym In my country, when we say "get", we mean "download it from the internet"
18:08:54 <Pseudonym> Yeah.
18:08:58 <Pseudonym> Ah. :-)
18:09:02 <Fromage> Or even "steal it, if you can"
18:09:09 <Pseudonym> Which country is that?
18:09:12 <Fromage> Spain
18:09:16 <Pseudonym> Gotcha.
18:09:30 <Fromage> I never buy books, music CD's or cinema tickets
18:09:31 <Pseudonym> "Fromage" is not a Spanish word.
18:09:34 <Pseudonym> AFAIK
18:09:44 <Fromage> Yeah, actually it's a French one
18:09:48 <Pseudonym> I know.
18:09:56 <Adamant> I think, it was recommended to me to read after the Cooper/Torzcen one
18:09:56 <Fromage> Tu parles français ? :)
18:10:09 <Pseudonym> No, but my surname is "Bromage", and people keep mispronouncing it.
18:10:55 <Adamant> I thought it was a Monty Python reference
18:11:06 <Adamant> for Fromage
18:11:23 <Pseudonym> Brie, Rocquerfort, Port L'evec...
18:11:33 <Pseudonym> Should I admit that I once knew that entire sketch?
18:11:33 <Fromage> lol
18:11:40 <Fromage> You know a lot about cheese
18:11:57 * Adamant serves whine with cheese
18:12:05 * Adamant ducks
18:12:07 <Pseudonym> Even scarier was that it was once my mission to eat every cheese in the sketch.
18:12:20 <Pseudonym> Venezuelan beaver cheese is hard to find.
18:12:38 <Adamant> I thought they had capybaras
18:12:43 <Adamant> or is that the Brazilains
18:13:09 <Pseudonym> Goodness, spontaneous Jimmy Neutron moment.
18:13:19 <Pseudonym> Haven't had one of those before.
18:13:23 <Fromage> I'm currently working on a quorums' system administration packet
18:13:30 <Fromage> It's entirely designed in Haskell
18:13:34 <Adamant> think... think... brain blast!
18:14:38 <Adamant> no idea what you are saying... packet as in "network packet"? packet as in "group of papers?"
18:15:28 <Fromage> It's a set of .hs files I'm writing with a group of University friends
18:15:46 <Fromage> Intended as a practical work for a subject focused on the functiona programming paradign
18:15:50 <Fromage> And it rokcs !
18:15:52 <Adamant> ah
18:15:53 <Adamant> cool
18:15:54 <Fromage> *rocks
18:16:06 <Pseudonym> Yup, functional programming rocks.
18:16:12 <Pseudonym> I'm sure your code does too. :-)
18:16:37 <Fromage> It doesn't yet, lol
18:16:43 <Fromage> It's still pretty unmature
18:17:34 <Fromage> > length [1,2,3] == floor(4/2) + 1
18:17:35 <lambdabot> True
18:19:11 <prionic> is there a better module for parsing the directory structure than System.Directory?
18:23:52 <Fromage> Instance of RealFrac Int required for definition of fPredicado
18:24:11 <Fromage> Does it mean I have to load that module before using floor predifined operation ?
18:24:18 <Pseudonym> At the risk of stating the obvious, Int isn't a real fraction.
18:24:58 <Fromage> I see
18:25:19 <Pseudonym> Almost certainly what's happening here is you're using the '/' operator on Itns.
18:25:21 <Pseudonym> Ints
18:25:26 <Pseudonym> @type (/)
18:25:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:25:30 <Pseudonym> What you want is:
18:25:32 <Pseudonym> @type div
18:25:33 <lambdabot> forall a. (Integral a) => a -> a -> a
18:26:00 <Pseudonym> Or possibly:
18:26:02 <Pseudonym> @type rem
18:26:03 <lambdabot> forall a. (Integral a) => a -> a -> a
18:26:14 <Fromage> So I should be using 'div' operator instead of '/', shouldn't I ?
18:26:17 <Pseudonym> Depending on how you want to round division by negative numbers.
18:26:23 <Pseudonym> Almost certainly, yes.
18:27:00 <Fromage> So take for instance that I want to divide these numbers, both integers : 3 and 2
18:27:06 <Fromage> 3 `div` 2
18:27:20 <Pseudonym> > 3 `div` 2
18:27:21 <lambdabot> 1
18:27:25 <Pseudonym> > 3 `rem` 2
18:27:25 <Fromage> What will be the return value ?
18:27:26 <lambdabot> 1
18:27:26 <Fromage> Ohhh
18:27:29 <Pseudonym> > 3 `divMod` 2
18:27:30 <lambdabot> (1,1)
18:27:39 <Pseudonym> Also handy sometimes if you need both quotient and remainder.
18:27:41 <Pseudonym> Sorry, not rem.
18:27:46 <Fromage> So it rounds the result to the floor, as far as I can see
18:27:54 <Pseudonym> Kind of.
18:28:09 <Pseudonym> It gets complicated when you divide by a negative number.
18:28:15 <Pseudonym> But for positive numbers, that's right.
18:28:30 <Fromage> I won't have to worry about it, it's impossible that my function gets a negative number
18:28:36 <Pseudonym> The semantics of div are actually "round towards zero".
18:28:46 <Pseudonym> Which is what you'd normally expect.
18:28:50 <Fromage> It ought to finish with an error in such a situation, because, well ..
18:29:10 <Fromage> The function is intended to generate a set of elements from a given value passed as a parameter
18:29:13 <Pseudonym> Don't worry about it.  I'm just being unnecessarily complete.
18:29:20 <Fromage> And I cannot imagine a set of elements with a negative size
18:29:29 <Fromage> You are quite helpful, Pseudonym
18:29:31 <Fromage> Thank you very much
18:29:40 <Pseudonym> I'm just commenting that it's not true that div is the same as floor.
18:29:49 <Pseudonym> It's actually the same as trunc.
18:30:27 <Fromage> Perhaps I should also round the result of `div` with floor
18:30:52 <Fromage> To avoid any kind of anomalous situation
18:31:05 <Pseudonym> It won't help.
18:31:08 <Pseudonym> > type floor
18:31:09 <lambdabot>  parse error on input `type'
18:31:13 <Pseudonym> @type floor
18:31:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:31:26 <Pseudonym> As previously noted, Int isn't a RealFrac.
18:31:36 <Pseudonym> So that would actually be a type error.
18:31:38 <Fromage> Yeah, it was a Int
18:32:07 <Pseudonym> If it helps, ignore what I said about negative numbers because it doesn't apply to you. :-)
18:35:35 <ewsu> It's not enough that it works. If you don't know how it works, don't use it. It's no good for anything but to play with.
18:43:00 <Fromage> trunc 3.5
18:43:03 <Fromage> > trunc 3.5
18:43:04 <lambdabot>  Not in scope: `trunc'
18:43:29 <Pseudonym> Errr...
18:43:34 <Fromage> It doesn't exist
18:43:43 <Fromage> > 3 `div` 2
18:43:44 <lambdabot> 1
18:43:52 <Fromage> > 4 `div` 2
18:43:53 <lambdabot> 2
18:44:05 <Pseudonym> > truncate 3.5
18:44:06 <lambdabot> 3
18:44:10 <Pseudonym> That's it.
18:44:14 <Pseudonym> > floor -3.4
18:44:14 <lambdabot>  add an instance declaration for (Fractional (a -> b))
18:44:22 <Pseudonym> > floor (-3.4)
18:44:23 <lambdabot> -4
18:44:26 <Pseudonym> > truncate (-3.4)
18:44:27 <lambdabot> -3
18:44:42 <Fromage> > 5 `div` 2
18:44:43 <lambdabot> 2
18:45:31 <Fromage> So div appears as the standard division algorithm I was taught at elementary school, before starting to deal with decimal ciphers
18:45:43 <Fromage> Just the operation I was looking for.
18:45:47 <Fromage> Thanks again, Pseudonym
18:45:53 <Pseudonym> No problem.
18:45:57 <Pseudonym> 5 `div` (-2)
18:46:00 <Pseudonym> > 5 `div` (-2)
18:46:01 <lambdabot> -3
18:46:20 <Pseudonym> > 5 `quot` (-2)
18:46:21 <lambdabot> -2
18:46:29 <Pseudonym> That's where it gets complicated.
18:46:33 <Pseudonym> But you don't have to worry about it.
18:47:11 <Fromage> Yeah, I don't have to
18:47:15 <Fromage> Where are you from, Pseudonym
18:47:24 <Pseudonym> Melbourne, Australia
18:47:42 <Fromage> Sorry if I always show myself interested in other people's geographical background :)
18:47:54 <Fromage> Ohhh, an Aussi again
18:48:07 <Pseudonym> Well, it's Australian work hours at the moment.
18:48:09 <Pseudonym> So don't be shocked.
18:49:38 <Fromage> Here it's almost 4 o'clock AM
18:49:40 <Fromage> And I can't sleep
18:52:43 <Fromage> Pseudonym
18:52:54 <Fromage> Do you work at anything releated to computers ?
18:54:08 <Pseudonym> Yup.
18:54:38 <Pseudonym> I think you'll find pretty much everyone here is either a programmer (or similar), or studying/teaching/researching something in computer science/software engineering.
18:55:30 <Fromage> Yeah
18:55:33 <Adamant> you don't frequent a functional programming channel for the chicks
18:56:05 <Fromage> Haskel, and Functional programming in general, is not something very attractive to the non-scientifical public
18:56:24 <Pseudonym> Although in my experience, girlgeeks often like functional programming more than imperative.
18:56:42 <Fromage> Hehe.
18:56:44 <Fromage> Well ..
18:56:48 <Fromage> That's not a matter here in Spain
18:57:14 <Fromage> As a living proof of how a Third World country works, my University has a 1/100 rate of female students
18:57:49 <Pseudonym> Spain is third world?
18:57:53 <Adamant> when did Spain become third world?
18:57:58 <Fromage> So one of the first tips I learned just after becoming a new student was switching myself into an Asexual
18:58:12 <Pseudonym> You can hardly be a third world country if you used to run half the known world.
18:58:15 <Fromage> Actually it has always been a third world country
18:58:24 <Pseudonym> (The half not run by Portugal.)
18:58:25 <Fromage> You know, what Frenchies used to say until very recently ?
18:58:40 <Fromage> "Europe ends in the Pirinees"
18:58:49 <Adamant> I thought it was doing fine since Franco kicked the bucket and they liberalized
18:58:53 <Pseudonym> I always thought that was a dig at the British.
18:59:21 <Pseudonym> Actually, I suppose Mongolia might count as a third world country which used to run half the known world.
18:59:28 <Adamant> the French need to concentrate on their own problems
18:59:50 * Pseudonym wonders where they thought Europe ended in the other direction
18:59:52 <Pseudonym> The Elbe?
18:59:54 <Fromage> But, Adamant
19:00:06 <Adamant> nope, Urals in Russia
19:00:18 <Fromage> Experience has shown me that, very frequently, French problems tend to become also Spanish problems quite rapidly
19:00:21 <Adamant> the technical end, at least
19:00:22 <Pseudonym> Oh, that's right.  I remember from "Russian Ark" now.
19:00:46 <Pseudonym> I say send the Basque separatists to France and see how they like it.
19:00:53 <Fromage> Erm ...
19:01:00 <Fromage> Basque separatists are not a problem any more
19:01:06 <Pseudonym> Ah, OK.
19:01:12 <Pseudonym> That's a relief.
19:01:21 <Adamant> Basque seperatists were very, very weird
19:01:29 <Adamant> from what I heard of them
19:02:00 <Fromage> I think they can be considered  to be whatever you want except the so-called terrorist group they used to be thirty years ago
19:02:24 <Adamant> yeah, there were never really successful as terrs, were they?
19:02:29 <Fromage> No, never
19:03:33 <Fromage> Their most 'successful' operation was an explosion inside a well regarded supermarket in Barcelona, 15 years ago
19:03:40 <Fromage> And they killed not more than 14 people, I think
19:03:47 <Fromage> Of course it was an error
19:03:55 <Fromage> The bomb was not inteded to kill innocent people
19:04:03 <Fromage> So ... you can see, how weird they used to be
19:04:29 <Pseudonym> I guess "incompetent" isn't so bad as "evil", though that's little comfort for the victims and families thereof.
19:04:55 <Adamant> yeah
19:05:23 <Adamant> one of the things I wish we (USA) would do more of is learn from the Euro experiences with terrorism in the 70's-80's
19:06:20 <Adamant> we tend either be in total nonchalant mode, or bug-eyed freakout mode, instead of being somewhere inbetween
19:06:36 <Fromage> Unfortunately, our govermented has been taking advantage of the Basque 'problem' to strength its power over Spanish society, for the last three decades
19:06:43 <Adamant> yeah
19:06:56 <Adamant> Patriot Act - a - likes?
19:07:00 <palomer> those basque are problematic
19:07:30 <palomer> canada had terrorism problems 30 years ago
19:07:38 <dons> petekaz: btw, if you are still having problems with 'group'. It runs 2.5x faster with ghc 6.5
19:07:39 <Adamant> from who?
19:08:06 <Fromage> From Quebecoise Revolutionary Army, I suppose
19:08:10 <Fromage> Or the Inuit Liberation Forces
19:08:11 <Fromage> :))))
19:08:11 <Adamant> I heard about a Sikh bombing of airliners
19:08:11 <dons> maybe this should go to #haskell-terror ?
19:08:15 <Adamant> ah
19:09:16 <Pseudonym> dons: This conversation will end as soon as someone mentions something Haskell-related.
19:09:17 <Fromage> So you are a North American citizen, Adamant
19:09:26 <Adamant> indeed
19:09:26 <palomer> yeah
19:09:32 <palomer> we also had amerindian terrorism
19:09:33 <Fromage> That's quite nice
19:09:38 <Pseudonym> That's always the way it happens.
19:09:54 <Fromage> I'd really like to move there, Adamant
19:09:56 <dons> Pseudonym: I already did though..
19:10:06 <Adamant> so, did Haskell Curry live under the Blitz?
19:10:08 <Fromage> My country seems to be as a cheap factory for producing fast code
19:10:22 <Fromage> Salaries are miserable in IT sector
19:10:23 <palomer> dons: do you know who decides which students are picked for the SoC?
19:10:30 <dons> google, iirc
19:10:39 <palomer> so I need to post a resume?
19:11:01 <palomer> and how are the submissions judged?
19:11:58 <Adamant> Fromage - not an expert on that... there is a long line for legal immigration, be it visas or citizenship, and you will deal with some real d*ckheads... the INS is one of the most obnoxious bureaucracies in the entire federal gov
19:12:23 <Pseudonym> Ah, good point.
19:12:36 <Fromage> I see, Adamant
19:12:51 <Fromage> Well, I could apply myself for the Spanish teaching project in the US
19:13:01 <Fromage> Once a year, more than a thousand Spanish teachers from Iberian Peninsula travel to the US
19:13:22 <dons> using a StudentRank algorithm.
19:13:41 <dons> palomer, have a look at the Apache page. they have lots of good advice (they had 40 students accepted last year!)
19:13:47 <Adamant> if you do try, remember, the average guy on the street is a lot nicer tha your average INS agent
19:13:52 <palomer> whoa
19:13:53 <palomer> will do
19:14:19 <Adamant> Fromage, cool deal
19:14:34 <Fromage> I'll keep that in mind, Adamant. Thanks for the advice :)
19:14:54 <dons> (which is kind of sick, imo)
19:15:33 <Adamant> Europeans really get screwed on immigration to the U.S... there is a proportional representation system, so you get so many people coming in from different areas of the world, based on world population
19:16:55 <Adamant> so, since Europe has a relatively small pop compared to a lot of other world places, Euros have it harder getting their shot in
19:17:20 <Adamant> of course, the flip side is more Euros meet all the requirements
19:17:36 <Adamant> so it balances somewhat
19:18:04 <Fromage> Having a relative profinciency in English is regarded as a requirement ?
19:18:17 <Adamant> it definitely helps
19:18:33 <Fromage> I must confess Spaniards are hardly ever able to speak a single word in English
19:18:55 <Adamant> well, you can process it written pretty well, which is great start
19:19:16 <Adamant> at this point, we're just happy immigrants try to speak English. :)
19:19:31 <Fromage> Hehe
19:20:13 <Fromage> I'd like to spend a couple of years there in the US
19:20:14 <Adamant> sorry for the total OT nature of this conversation, #haskell
19:20:36 <Korollary> #haskell-blah is the place
19:20:36 <Adamant> go all over the country!
19:20:49 <Adamant> Fromage, want to move over there?
19:20:59 <Fromage> Yes
19:21:02 <palomer> dons: get my message?
19:21:03 <Fromage> Of course I want
19:21:23 <Fromage> But I think it's impossible for a Spaniard to get definitely used to North American way of life
19:21:32 <Fromage> We are very different in our costumes and traditions
19:21:47 <Fromage> But spending a couple of years there would be a quite profitable experience
19:22:16 <Adamant> Fromage - I think we should take this to #haskell-blah
19:22:23 <Fromage> OK, Adamant, as you wish
19:22:28 <Adamant> that was what I meant by move
19:22:38 <Fromage> I can't believe that channel actually exists !
19:22:42 <Fromage> Hahahahahaha
19:22:55 <Fromage> I though you were mocking me :)
19:23:16 <Pseudonym> No, but if you want to be mocked, we can certainly do that.
19:23:31 * Korollary mocks your clothes and traditions
19:23:35 <Pseudonym> There is no #haskell-mocking, but we could make one.
19:33:59 <Pseudonym> Not strictly Haskell, but some cool papers here:
19:34:02 <Pseudonym> http://theory.lcs.mit.edu/~edemaine/papers/
19:34:28 <Pseudonym> Interestingly, optimising your Tetris moves is NP-complete.
19:36:17 <Fromage> Determining an algorithm to discover prime number series is also NP-Complete ?
19:36:31 <Cale> hm?
19:36:49 <Cale> Primes is in P.
19:37:56 <Pseudonym> Sliding-block puzzle solving is apparently PSPACE-complete.
19:38:09 <Pseudonym> Which is a bit of a surprise.
19:50:34 * Cale adds Haskell code to http://en.wikipedia.org/wiki/Prime_number#Programs_to_find_primes
19:50:43 <palomer> hrmph, is there a nicer combinator to use then foldl1 (>>) ?
19:50:53 <Cale> sequence
19:51:00 <Cale> @type sequence
19:51:01 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:51:11 <Cale> @type foldl1 (>>)
19:51:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
19:51:23 <Cale> oh, you're throwing away all but the last result?
19:51:34 <palomer> yeah
19:51:47 <palomer> I'm threading them
19:52:05 <palomer> (the a is a Unit)
19:52:25 <Cale> oh, so you don't care about the end results of any of them, just the side effects?
19:52:31 <Cale> @type sequence_
19:52:32 <palomer> yup
19:52:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:52:43 <Cale> that one then :)
19:53:16 <palomer> so it's equivalent to foldl1 (>>), right?
19:53:22 <Cale> basically
19:53:28 <Cale> foldl1 (>>) >> return ()
19:53:31 <Cale> er
19:53:37 <Cale> \xs -> foldl1 (>>) xs >> return ()
19:54:06 <palomer> working with monads is fun!
19:54:56 <sjanssen> dons: I had a go at counting sort
19:56:03 <sjanssen> considerably faster when sorting an entire dictionary, but considerably slower when sorting individual words in the dictionary
19:56:46 <Lokadin> how can i set environment variables temporarily for one command/
19:56:47 <Lokadin> ?
19:56:58 <Lokadin> in bash or zsh
19:57:05 <araujo> VAR="val" command
19:57:11 <Korollary> SOMEVAR=somevalue /bin/ls
19:57:18 <araujo> hi all
19:58:01 <Cale> hi araujo -- I saw your SoC proposal, looks pretty ambitious :)
19:58:04 * Korollary throws a frisbee at araujo
19:58:06 <Lokadin> VAR="aoeu" echo $VAR 
19:58:07 <Lokadin> doesn't work
19:58:10 <Lokadin> :(
19:58:35 <Cale> Lokadin: that's because variable expansion occurs before anything runs
19:58:50 <Lokadin> oh
19:59:40 <Lokadin> PWD="/home/loki/bin" ls
19:59:51 <Lokadin> well that doesn't work either
20:00:22 <Lokadin> just gives me current directory
20:00:52 <Cale> huh
20:01:25 <Lokadin> well if i export PWD
20:01:31 <Lokadin> then it changes my directory
20:02:25 <Cale> you can make any sequence of commands local by enclosing them in parens
20:02:33 <Cale> (cd /; /bin/ls)
20:02:36 <Cale> try that
20:03:20 <Cale> cale@zaphod[~]$ VAR="goodbye";(VAR="hello"; echo $VAR); echo $VAR
20:03:20 <Cale> hello
20:03:20 <Cale> goodbye
20:03:30 <Lokadin> cool thanks :)
20:05:16 <Korollary> somebody is a hitchhiker's fan
20:05:39 <Cale> :)
20:07:48 <Lokadin> say how would i store an environment? as those are variables that can change, or do i just add them in as another function variable?
20:07:54 <palomer> pfft, my type inference algorithm takes hours on a 2 line program:/
20:08:10 <dons> sjanssen: wnat to create some strings from 0 to say, 2 M, and work out when qsort  wins or loses?
20:11:23 <Cale> Lokadin: I suppose you could run set and save its output to a file
20:11:42 <Cale> Lokadin: which you could then source to reconstruct the entire environment
20:12:16 <Lokadin> Cale: but wouldn't that be a lot of writing and reading to the disc? can i keep a virtual file in RAM?
20:12:40 <Cale> hmm
20:12:54 <Korollary> Lokadin: People use configuration files for that kind of stuff.
20:13:31 <Lokadin> well if i'm using sh -c, then i want to still be able to change directories 
20:13:43 <Cale> what exactly is it that you're doing?
20:14:38 <Lokadin> initially, i was trying to run a helperAi over bash, now i'm just running the helper, and it executes shell commands with sh -c
20:15:25 <Cale> hmm
20:15:38 <Cale> ideally, you'd just keep one bash running?
20:15:44 <Lokadin> yea
20:16:01 <Lokadin> that would be woderfull but i dono how to do that
20:16:11 <Cale> mkfifo myfifo
20:16:20 <Cale> bash < myfifo
20:16:33 <Cale> then write to the fifo
20:17:38 <Lokadin> bash seems to exit after one command
20:17:49 <Cale> it'll end when you send it an EOF
20:18:36 <Cale> if you're trying this by hand, try using cat > myfifo
20:20:06 <Cale> programmatically, it won't be a problem
20:20:26 <Lokadin> oh
20:20:49 <Lokadin> so how would i write to the pipe then?
20:21:06 <Lokadin> and would i recieve output from their to?
20:21:21 <Cale> which language are you doing this from? bash?
20:21:39 <Lokadin> er well i'm making the program in haskell
20:21:43 <dons> @localtime sjanssen
20:21:53 <sjanssen> dons: gaim doesn't support it
20:22:00 <sjanssen> it's 10:24 PM
20:22:05 <dons> ah ok :)
20:22:10 <Korollary> ?time sjanssen 
20:22:21 <dons> so what's the plan to move forward with the sorting stuff? 
20:22:44 <dons> do you want to work out the switchign bpoint? or just submit the new sort to me, and i'll run and graph some numbers this afternoon?
20:22:49 <Cale> Lokadin: well, from Haskell, you can just get an input and output handle to your running copy of bash
20:23:03 <Lokadin> with runInteractiveCommand?
20:23:18 <Cale> yeah
20:23:30 <Lokadin> but i don't get the output :(
20:23:37 <Cale> so you shouldn't even need a fifo
20:23:45 <Cale> make sure the buffering is set correctly
20:24:20 <sjanssen> dons: I'm working on it.  It's hard to observe the differences for inputs less than a couple k
20:24:53 <Lokadin> so hSetBurring out LineBuffering -- if the runinteractivecommand output handle is out
20:25:13 <dons> yeah. hmm. would we just then use whichever is faster after 2k or so? (I'm guessing there's two nice curves, and linear sort starts to win hands down after a while, but maybe loses early on?)
20:25:33 <Cale> yeah
20:25:41 <Lokadin> let me try that one sec
20:25:50 <Cale> or NoBuffering even
20:26:06 <sjanssen> dons: countSort is really bad on English words, about twice as slow
20:26:32 <dons> ah interesting. i guess the allocation of the 256 char array?
20:26:41 <dons> and a bit slower mapping over the string too
20:28:02 <sjanssen> dons: it has to be an allocation of 256 ints
20:28:06 <sjanssen> so about 1k
20:29:06 <Lokadin>    (inp,out,err,pid) <- runInteractiveCommand "/bin/bash"
20:29:06 <Lokadin>    hSetBuffering out NoBuffering
20:29:06 <Lokadin>    hPutStrLn inp "echo asdf"
20:29:06 <Lokadin>    putStrLn =<< hGetLine out
20:29:08 <dons> ah. using an IOUArray or similar?
20:29:31 <Lokadin> doesn't work :( just seem to not do anything, when i run it
20:30:20 <tennin> wait... compiler optimization?
20:30:36 <Lokadin> Cale: ^
20:30:43 <Cale> mapM (flip hSetBuffering NoBuffering) [inp,out,err]
20:30:45 <Cale> try that
20:30:59 <Lokadin> o okay one sec
20:31:40 <palomer> http://www.haskell.org/haskellwiki/Stateful_Nondeterminism <--if anyone could clean up this page, it would be great
20:31:40 <sjanssen> dons: I'm using a Ptr CSize for now.  Not sure much zero indexing helps
20:31:48 * Lokadin hugs Cale :) yay it worked
20:32:08 <Lokadin> @hoogle mapM
20:32:08 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:32:09 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:32:09 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:32:37 <Lokadin> @hoogle flip
20:32:37 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
20:32:54 <sjanssen> lisppaste2: url
20:32:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:33:26 <lisppaste2> sjanssen pasted "counting sort" at http://paste.lisp.org/display/19632
20:34:02 <dons> looking ..
20:34:04 <sjanssen> dons: it's pretty ugly right now, and there are things I'm not sure of yet.  Especially, are the fromIntegral's I have optimized out?
20:34:50 <dons> hmm. probably mostly. some might turn into narrowings. only way is to look at the Core
20:35:06 <dons> that doCount loop should get a STTICT() pragma
20:35:33 <dons> and the go loop. STRICT1() and STRICT@()
20:35:57 <dons> s/@/2/ grr mumble
20:36:51 <dons> those memset's look good. nice idea.
20:39:21 <sjanssen> is there a way to get simplifier output with Cabal?
20:39:42 <mlh> Lokadin: here's a hack so that bash doesn't see an EOF: sleep 2000000 > BASHFIFO &
20:39:50 <dons> add -ddump-simpl to the cabal ghc-options line
20:40:40 <Lokadin> mlh: thanks
20:42:01 <mlh> it'll see the EOF eventually of course; after about 23 days for that number of secs
20:42:35 <palomer> http://www.rafb.net/paste/results/5OcYqi10.html <--I have no idea how to fix this
20:44:46 <palomer> hrmph, looks like I killed the channel
20:48:04 * palomer casts +4 resurrection
20:48:18 <lisppaste2> machack666 pasted "PartialKey code" at http://paste.lisp.org/display/19633
20:48:38 <machack666> anyone want to help optimize the above paste?
20:48:46 <Cale> palomer: what's the type of rlst?
20:49:04 <palomer> (t,[a,s])
20:49:06 <palomer> err
20:49:10 <palomer> [(a,s)]
20:49:23 <Cale> okay, so you need Eq a and Eq s
20:49:30 <Cale> in order to apply nub
20:49:35 <palomer> hrmph
20:49:41 <palomer> how can I add Eq a?
20:49:47 <Cale> I don't think you can
20:50:11 <Cale> There's a reason that Data.Set isn't an instance of Monad, and this is it
20:50:33 <palomer> hrmphrmprhprmp
20:50:37 <palomer> this is a huge bummer
20:51:33 <Cale> You can't define monads which apply to a subcategory of the full category of Haskell types.
20:51:34 <sjanssen> dons: you mentioned narrowings earlier.  One of my fromIntegrals turned into narrow8Word#, is this good or bad?
20:51:38 <Cale> It's all-or-nothing
20:51:40 <palomer> if I have a SuperState s t a, how do I nub it?
20:52:09 <palomer> (ie, reduce the search space)
20:52:44 <dons> sjanssen: you have to check the C code to see if its an op or jsut a cast
20:52:56 <dons> I think its just a cast.
20:53:17 <palomer> gah, there's no way to do it
20:53:25 <palomer> I'll just have to be careful about my search space:/
20:58:51 * palomer is getting a search space super explosion
20:59:32 <Cale> I believe there ought to be a function of type (Eq a, Eq s) => SuperState s t a -> SuperState s t a which does it.
20:59:45 <Cale> but only for one level of computation
21:00:05 <Lokadin> Cale: say, it seems to stop after i putStrLn =<< hGetContents out, 
21:01:12 <Lokadin> i mean a putStrLn "hello" line right after it doesn't show up
21:01:27 <Lokadin> Cale: want me to paste?
21:01:35 <Cale> Lokadin: no, that makes sense
21:01:55 <Lokadin> oh okay, so what should i do?
21:02:42 <Lokadin> or why does it not work?
21:02:44 <Cale> Using up a string gotten from hGetContents (i.e. forcing the last cons, or it might be the [] at the end) will close the handle
21:03:18 <Cale> so basically, you should never reuse a handle which you've passed to hGetContents
21:04:23 <Lokadin> oh, so i should never execute hGetContents on out again? then how would i get the output for the next program? i tried hGetLine and had the same issue
21:05:36 <palomer> Cale: and how would I use such a function?
21:05:58 <palomer> in a do statement, for example
21:07:45 <sethk> Lokadin, I use hGetContents in some situations, because it has the behavior I want.  In your case I think I'd use hGetLine.
21:07:46 <Cale> Lokadin: you shouldn't use it the first time -- just read characters in a loop until hReady out fails
21:08:18 <Lokadin> kk thanks i'll try that :)
21:08:46 <Cale> palomer: you'd apply it to some action you were running to reduce the options it generated
21:08:51 <palomer> is there a function m a -> m b -> t m a -> t m b ?
21:09:26 <palomer> make that MonadTrans t, Monad m => m a -> m b -> t m a -> t m b
21:09:32 <Cale> parens?
21:09:43 <palomer> make that MonadTrans t, Monad m => (m a -> m b) -> t m a -> t m b
21:10:13 <Cale> hmm...
21:10:20 <palomer> I could probably build it from m a -> t m a
21:10:37 <Cale> well, there's lift
21:10:41 <Cale> however
21:10:41 <palomer> @hoogle lift
21:10:42 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
21:10:42 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
21:10:42 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
21:10:48 <palomer> ahh, righto
21:11:06 <Cale> you'd also need something  t m a -> m a  which is not possible
21:12:01 <palomer> because I'm using a ReaderT (SuperState ...) a
21:12:57 <palomer> so you can't build it? 
21:15:35 <palomer> that would be very odd>:O!
21:17:04 <Lokadin> how do i change an IO Bool into a Bool? to use in an if statement?
21:17:46 <Lokadin> @type hReady
21:17:47 <lambdabot> Not in scope: `hReady'
21:18:03 <Cale> Lokadin: you run the IO action
21:18:18 <Cale> (or, really, you use >>=)
21:18:41 <Lokadin> (\x -> x) =<< hReady
21:18:41 <Lokadin> ?
21:18:54 <sjanssen> dons: according to my measurements, countSort starts winning with strings around 30 characters long
21:19:08 <dons> excellent!
21:19:17 <sjanssen> once you enter the hundred range, it's countSort hands down
21:19:31 <dons> wow. much earlier than I thought. 
21:20:27 <dons> definitely worth submitting then. and if you have a nice program to do the benchmarks, that would be worth going in tests/ too, so that in future we know if things are still working 
21:23:02 <Lokadin> Cale: what do i >>= into?
21:24:10 <palomer>  whew, my program runs _much_ faster with trimming
21:25:48 <newsham> If I upgrade 6.4.1 to 6.4.2, do I have to rebuild all the packages I added?
21:27:09 <dons> newsham: yup.
21:27:16 <newsham> joy
21:27:32 <newsham> guess they cant keep bin compatibility between minor versions?
21:27:53 <dons> all sorts of things change, besides the published api.
21:28:11 <dons> anything internal might end up in the .hi files, for one.
21:29:56 <dons> ?quit new palomer-isms
21:31:39 <Cale> Lokadin: do b <- hReady hdl; if b then ... else ...
21:31:52 <Cale> @palomer
21:31:53 <lambdabot> Learning vim is pointless
21:31:56 <Cale> @palomer
21:31:57 <lambdabot> Scalliwags!
21:31:59 <Cale> @palomer
21:32:00 <lambdabot> Pfft
21:32:01 <Cale> @palomer
21:32:02 <lambdabot> Learning vim is pointless
21:32:04 <newsham> wish there was a native ssl impl.
21:32:13 <Lokadin> Cale: thanks :)
21:35:26 <newsham> how much advantage would there be in double-building the latest version of ghc?
21:36:12 <dons> ?
21:36:33 <newsham> building ghc 6.4.2 with 6.4.1, installing, then rebuilding with 6.4.2 and installing
21:37:02 <palomer> @seen Lemmih 
21:37:02 <dons> none. since the compiler gets built twice anyway
21:37:02 <lambdabot> Lemmih is in #haskell-overflow, #haskell-blah and #haskell. I don't know when Lemmih last spoke.
21:37:10 * palomer slaps lambdabot 
21:37:12 <newsham> ahh..
21:37:38 <Lemmih> lambdabot: I spoke just now!
21:38:29 <Cale> @seen Cale
21:38:29 <lambdabot> You are in #haskell. I last heard you speak just now.
21:42:11 <sethk> Lemmih, auditory halucination
21:45:00 <palomer> Lemmih: mind I priv msg you?
21:45:27 <newsham> palomer: can I ask you a question?
21:45:30 <Lemmih> Not at all.
21:45:38 <palomer> newsham: sure
21:45:43 <newsham> thanks.
21:46:01 <mwc> Since tail recursive functions on a list are effectively loop iterations over the elements in an imperative language; there should be a straight forward way of combining them
21:46:18 <mwc> I just can't see it
21:47:05 <Lemmih> mwc: Combining lists?
21:49:33 <mwc> Lemmih, yeah, I'm trying to figure out how to write out the list of suffixes of a given list (longest at head) tail recursively and in linear time
21:51:57 <mwc> so far I'm reversing a list (foldl (flip (:)) []) that I get by a tailrecursive function that generates the suffixes in the wrong order
21:56:30 * Lemmih stops trying to understand what mwc said and heads to bed.
21:56:54 <mwc> tail_suf acc [] = []:acc ; tail_suf acc xxs@(_:xs) = tail_suf (xxs:acc)  xs ; 
21:56:59 <mwc> and then reverse taht
21:57:06 <mwc> best I can do
21:58:04 <dons> night Lemmih
21:58:08 <dons> ?localtime Lemmih
21:58:09 <lambdabot> Local time for Lemmih is Wed May  3 07:02:04 2006
21:58:42 <jewel> ?localtime jewel
21:58:43 <lambdabot> Local time for jewel is Wed May  3 12:04:31
22:01:02 <laurence> Heh.  I believe I'm going to go find the most unrelentingly imperative channel in existence and let off some steam.
22:01:25 <palomer> <:o
22:01:34 * laurence changes the value of a constant just for fun.
22:01:37 <dons> oh, #haskell-monads?
22:02:35 <laurence> Maybe #haskell-change-variable-change-change-change. :-)
22:04:05 * laurence sets G, c, and h-bar all to 1 just for fun.
22:10:17 <cge> laurence: temporarily unavailable, unfortunately
22:11:08 <laurence> cge: Ah, well, then we must soldier on. :-)
22:11:47 <laurence> I had a professor who once recommended setting pi = i = 1 to simplify contour integration. :-)
22:11:48 <Adamant> #haskell-mutable-state-borked-borked-borked
22:12:00 <Adamant> ;)
22:12:30 * laurence types '/join #haskell-mutable-state-borked-borked-borked' and waits hopefully.
22:13:04 <Adamant> that's one thing IRC doesn't have enough of... references to Usenet
22:13:33 * laurence looks to see if he has any MAKE MONEY FAST posts saved anywhere.
22:13:53 <Cale> hmm, I can't join #alt-adjective-noun-verb-verb-verb
22:14:06 <Pseudonym> For some reason, it's not as funny when expressed as an IRC channel name.
22:14:32 <laurence> Well, #.cabal is even less funny on IRC.
22:14:43 <laurence> Plus, nothing breaks. :-(
22:14:57 <Pseudonym> That's interesting, because it used to be that everything was less funny on Usenet.
22:15:05 <sjanssen> dons: You've got patches! (end AOL voice)
22:16:39 <Adamant> "You've got spam, d*ckhead!"
22:16:55 <Adamant> anyone remember that mock commerical?
22:19:30 * sjanssen sleeps
22:21:22 <araujo> hiya!
22:21:38 <dons> yay. patches!
22:22:41 <Lokadin> i have a really odd problem where my output comes only after another line
22:23:55 <Cale> Lokadin: buffering settings again
22:24:05 <Lokadin> oh yea?
22:24:11 <Cale> you probably have output line buffered and aren't finishing the line
22:24:24 * laurence suddenly realizes that when dealing with alien syntax, it's not a bad idea to canonicalize the expression.
22:24:33 <Lokadin> how do i finish the line?
22:24:41 * laurence hopes nobody heard him mutter that Haskell's syntax is alien.
22:26:14 <Cale> Lokadin: with a '\n'. If you want to flush the handle before that, you can use hFlush hdl (probably stdout)
22:26:31 <Lokadin> thanks :)
22:26:34 <Cale> You could also just hSetBuffering NoBuffering
22:26:54 <Lokadin> say, does buffering stay cross functions
22:26:55 <dan> =o
22:27:05 <Lokadin> if i set buffering of stdout say
22:27:26 <Lokadin> or do i have to set it in every function that derived frome function a that had buffering set
22:29:14 <Lokadin> Cale: doesn't seem to work
22:29:30 <Cale> you only have to set it once
22:29:31 <Cale> hmm
22:30:45 <Lokadin> you want a paste?
22:31:29 <Cale> sure
22:31:33 <Lokadin> @where paste
22:31:33 <lambdabot> http://paste.lisp.org/new/haskell
22:32:49 <lisppaste2> Lokadin pasted "Haish" at http://paste.lisp.org/display/19635
22:35:21 <Lokadin> maybe my getCont is flawed?
22:37:35 <laurence> OK, I guess I've done my due diligence.  Anybody want to be the answer key? :-)
22:37:52 <Cale> laurence: hm?
22:37:56 <Lokadin> what's the question lock?
22:37:59 <Cale> Lokadin: looking
22:38:13 <Lokadin> Cale: kk thanks :) 
22:39:00 <Korollary> Lokadin: I don't think bash reads it stdin in interactive mode.
22:39:49 <Lokadin> Korollary: well i can run commands like ls and exit quits the program after i return twice
22:40:01 <Lokadin> so i get one last prompt before it actually exits
22:40:16 <laurence> Cale: Oh, I'm just working through the Scheme-in-Haskell tutorial without benefit of, say, knowledge.  I've reached the limit of what I can learn by terse examples, so I want to check the answer key. :-)
22:40:45 <Cale> laurence: I haven't gone through that tutorial, but what's the question?
22:41:08 <dan> does anyone know like, who to contact about summer of code ideas?
22:41:35 <Lokadin> @where soc
22:41:36 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
22:41:36 <Lokadin> ?
22:41:56 <laurence> Cale: I'm sure there's no need.  We have an example parser (lexer, I'd call it) for numbers:
22:42:06 <dan> thanks
22:42:09 <laurence> parseNumber :: Parser LispVal
22:42:28 <laurence> parseNumber = liftM (Number . read) $ many1 digit
22:42:56 <laurence> So the assignment is to rewrite in a do-expression.
22:43:02 <Cale> okay
22:43:44 <laurence> But since I don't *really* understand such things, and this isn't for a grade, I'm probably better off getting the answer and then trying to use that to understand do-expressions (and more importantly a bit more about Haskell types).
22:43:49 <Cale> parseNumber = do x <- many1 digit; return . Number . read $ x
22:44:30 <dons> ?karma+ sjanssen --very nice counting sort :)
22:44:30 <lambdabot> sjanssen's karma raised to 6.
22:44:31 <Cale> (or any equivalent composition/application/bracketing)
22:44:54 <dons> i really like it when code goes from 3s (using C's qsort) to 0.1s using Haskell :)
22:46:02 <Cale> dons: nice :)
22:46:23 <dons> (to sort 20M, too :)
22:46:48 <Korollary> isn't that the famous soft spot of C?
22:46:56 <Korollary> qsort that is
22:47:07 <dons> I think qsort is fairly infamous, anyway
22:47:14 <skew> hey, I could use a fast sort
22:47:33 <laurence> Cale: Ah, yes, that checks out.  Now, why is it equivalent?
22:47:34 <skew> I've discovered recently just how slow read is for large files
22:47:50 <dons> read is slow in general.
22:48:00 <dons> better to use a real lexer or parser for such tricks
22:48:18 <dons> i.e. alex will lex out of a memory buffer.
22:48:39 <skew> actually, I just need the stuff scanf will do
22:48:58 <Cale> laurence: because what liftM does is to apply a function to the result of a computation
22:49:09 <Cale> laurence: (producing a new computation)
22:49:09 <skew> like reading a float - maybe there's a better way but I've always used read for that even with alex
22:49:16 <Cale> @type liftM
22:49:17 <lambdabot> forall r (m :: * -> *) a1.
22:49:17 <lambdabot>    (Monad m) =>
22:49:17 <lambdabot>    (a1 -> r) -> m a1 -> m r
22:49:26 <Cale> (ignore the first line of that)
22:50:42 <Cale> so the do-expression I wrote first runs the computation, then returns the value of the function applied to the result
22:52:26 <laurence> Cale: First, I don't yet know Haskell types well enough for that signature (or whatever it's called in the Haskell world) to help me that much.
22:52:55 <laurence> Cale: That's a hazard of playing with a "learning by doing" style tutorial instead of a textbook style presentation.
22:53:05 <Lokadin> dons: do you know why when using readline, i get the output of the first prompt only after entering something into a second prompt?    if bool
22:53:13 <Cale> Okay, it says that if m is a monad
22:53:21 <Lokadin> dons: do you know why when using readline, i get the output of the first prompt only after entering something into a second prompt?   http://paste.lisp.org/display/19635
22:53:23 <Cale> then it takes a function of type (a1 -> r)
22:53:26 <Lokadin> oops
22:53:31 <Cale> and a value of type m a1
22:53:39 <Cale> and gives a value of type m r
22:53:55 <Cale> In your case, m = Parser
22:54:14 <Cale> Lokadin: hmm, not sure
22:54:28 <Lokadin> Cale: kk :(
22:54:31 <Cale> oh
22:54:36 <GeniXPro> :(
22:54:41 <laurence> Cale: Mmm, => is more or less a lower-priority ->.  OK....
22:54:46 <Cale> hSetBuffering stdout NoBuffering
22:54:49 <dons> Lokadin: hmm. no. hFlush maybe?
22:55:00 <Cale> laurence: it's used to apply class constraints
22:55:35 <Cale> Lokadin: you did try setting NoBuffering on stdout, eh?
22:55:38 <Lokadin> Cale: it's already there, tried it on a different line same output
22:55:41 <Lokadin> yea
22:55:43 <Cale> hmm
22:55:50 <Lokadin> dons: tried taking hFlush out, no effect
22:55:59 <Cale> that's really odd then
22:56:13 <Lokadin> yea
23:00:16 <Lokadin> hmmm i think it has something to do with readline, because if i add another readline after i give input but before any of the getCont's i see the second readline and when i return it gives be output to first readline
23:01:52 <Lokadin> and for some reason if i have the readline before the bash input. the second readline passes the command to the inp and not the first
23:01:54 <skew> :t
23:02:25 <Korollary> Lokadin: testing it with 'cat' may be easier than with bash.
23:03:11 <Lokadin> Korollary: er, well i don't really know how i would do that
23:03:31 <Korollary> Lokadin: replace "/bin/bash" with it
23:04:41 <Lokadin> Korollary: same thing happens with cat
23:05:38 * shapr yawns
23:05:42 <shapr> Good morning #haskell!
23:06:05 <Lokadin> shapr: hello
23:06:21 <Korollary> Lokadin: I concur.
23:06:41 <Korollary> Lokadin: It's one line behind.
23:06:52 <Lokadin> Korollary: yea, it's very odd
23:08:56 * laurence decides he'd better leave the do-expression problem behind for now.
23:09:42 <Korollary> laurence: I have a feeling you'd save time going through a tutorial first.
23:10:08 <skew> hi shapr
23:10:21 <laurence> Korollary: Probably, but I hadn't really intended to play with Haskell at all.  I just liked the approach, so decided to try it in some spare time.
23:10:27 <shapr> hey skew, I was playing with Aardappel yesterday... I couldn't write a program, but I got pretty pictures.
23:10:44 <shapr> Bah, time to go to the bookkeeper.
23:10:54 <skew> yeah, that's about as far as it worked for me
23:10:58 <laurence> Korollary: It isn't like I'm not learning anything--just not everything.
23:12:41 <laurence> I would like to know if ghci can report types like Cale did with the lambdabot, though.  I think the question got lost in the netsplit.
23:12:51 <Korollary> It does. Use :t <expr>
23:13:30 <laurence> Thought so.  I also tried to import a package and it didn't work, so either the syntax is different or it isn't present.
23:13:47 <skew> laurence: that's :m + Module
23:13:48 <Cale> in ghci, you can use :m + Module.Name
23:14:03 <skew> try :help
23:14:54 <laurence> Heh.  OK, makes sense.  I hadn't tried it until now, so the only thing I knew was how to quit it.  It's slightly nicer than vi that way.... :-)
23:15:27 <skew> one slightly obscure thing - :set +r is useful for resetting stdin after using getContents
23:15:51 <Korollary> @index hReady
23:15:51 <lambdabot> System.IO
23:16:11 * laurence discovers why the prompt has a funny name and is enlightened.
23:16:43 <laurence> Comparing the :help output to your suggestions, I see that unique prefixes are sufficient.
23:16:50 <Korollary> Lokadin: I got it
23:16:56 <Lokadin> Korollary: !!!
23:17:04 <Lokadin> :) what is it?
23:17:36 <Korollary> Lokadin: That hReady in getCont is not guaranteed to return IO true as soon as you print something into the shell's input.
23:18:11 <Korollary> Lokadin: i.e. it's a nonblocking call, so some time will need to pass before there are characters in the buffer.
23:18:16 <workbean> I need an opinion. Which books is better for an experienced C programmer with time to read? "The Craft of Functional Programming"  or "The Haskell School of Expression"
23:19:02 <Lokadin> Korollary: so should i use hWaitForInput?
23:20:46 <Korollary> Lokadin: Yes. But note that if the program doesn't produce any output, you'll sit there forever.
23:20:55 <laurence> I see that the major weakness of the Scheme-in-Haskell idea is probably the fact that it's inevitably very io-dependent, which isn't a priori a great place to start.
23:21:03 <goltrpoat> workbean, "the haskell road to logic, maths and programming" is an excellent intro
23:21:17 <goltrpoat> SoE may or may not be a good first book, sort of depends on where you're at
23:21:27 <goltrpoat> haven't read the craft of functional programming
23:21:28 <Korollary> goltrpoat: He just left.
23:21:49 <Korollary> Maybe he'll check the logs tho
23:21:54 <Lokadin> Korollary: what doesn't produce output?
23:21:59 <goltrpoat> well that doesn't work at all, does it.
23:22:13 <goltrpoat> i mean, the guy has to be here in order for me to talk to him.
23:22:30 <skew> is there anything good for people with just C experience?
23:22:42 <skew> maybe the spineless tagless G-machine paper?
23:22:51 <Korollary> skew: I have school of expr and it doesn't require a particular experience.
23:22:53 <Cale> Why did workbean leave so quickly?
23:23:01 <Cale> I guess we'll never know
23:23:06 <goltrpoat> i think haskell road will throw them far enough off course that they won't try to apply their C experience to it
23:23:16 <skew> well, C experience is different from no experience
23:23:27 <Cale> laurence: yeah, you might try YAHT
23:23:28 <Korollary> Lokadin: I mean, if the consumer of your line doesn't produce an output for it, you'll just wait there.
23:23:35 <Cale> @where yaht
23:23:35 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
23:24:05 <skew> oh, there's a follow-up paper to non-stop Haskell
23:24:17 <Lokadin> Korollary: so what would be an example? if a person types no input?
23:25:03 <Lokadin> Korollary: thanks a lot for the fix btw :)
23:25:06 <Korollary> Lokadin: "cat > /dev/null" for instance will eat your input without producing any output.
23:25:11 <laurence> Oddly enough, I find that mathematical experience is an obstacle too.
23:25:50 <goltrpoat> laurence:  in what sense?
23:26:06 <Cale> laurence: perhaps wanting too much?
23:26:21 <Lokadin> Korollary: hmmm i get ya
23:26:28 <Korollary> That's unlikely considering that people who slurp haskell the fastest usually have a quite strong math background.
23:26:36 <laurence> Cale: I have that open in a PDF reader. :-)
23:26:37 <Cale> I found that a lot of my mistakes early on were actually trying to do impossible things with laziness :)
23:27:10 <laurence> Korollary: Only in a surface sense.  If you've done much continuous mathematics, then operation groups right to left.
23:27:18 <Cale> A lot of things which are blindingly obvious to a mathematician are still impossible for a Haskell compiler.
23:27:21 <Lokadin> skew: what is non-stop haskell?
23:27:35 <laurence> Korollary: I was a physics graduate student.  Think how instinctively I read operators. :-)
23:27:42 <skew> an incremental garbage collection algorithm
23:27:43 <Cale> like, computing product [1,1..] in finite time :)
23:27:55 <Korollary> laurence: My background is mostly in continuous math, but you're right that discrete math & algebra/logic is more relevant.
23:28:06 <Lokadin> laurence: the answers for YAHT are at the bottom of the pdf
23:28:20 <skew> laurence: ah, that's quite different math
23:28:24 <laurence> Korollary: Er, that wasn't clear.  My point was that the surface syntax groups backwards.
23:28:40 <skew> discrete math is nice, especially abstract algebra
23:29:14 <laurence> skew: I was a CS student until I tossed it for a "real" degree.  Granted, that was more about the relative department quality.  It would have been nice to have time for more discreet math.
23:29:40 <goltrpoat> i used to hate CS with a passion until i discovered FP
23:29:45 <Korollary> laurence: You've lost me.
23:30:03 <laurence> Korollary: Quick, what does f x y mean? :-)
23:30:15 <goltrpoat> and i have 17-18 years of programming, never done anything else for a living.  weird how things work out.
23:30:25 <Korollary> laurence: You mean associativity?
23:30:32 <kzm> hah.  ghc-cvs is officially removed from Ubuntu (dapper).
23:30:37 <laurence> Korollary: You may choose: (a) (f x) y or (b) f(x(y))
23:31:33 <goltrpoat> huh?  f(x,y).
23:31:34 <skew> I switched a system from ubutntu to debian just to get ghc packages
23:31:37 <laurence> Cale: It seemed like a good tutorial.  The problem is I didn't expect to have enough time to benefit from it properly.
23:32:26 <laurence> goltrpoat: OK, fine, that's (c).  Though I was under the impression that f(x, y) is pretty much equivalent to (f x) y in Haskell.
23:32:53 <Lokadin> has anyone ever made a terminal or a shell in haskell?
23:33:05 <goltrpoat> f x y ~ f(x,y).  if you want to write (f x) as a partial function, write g(y) = f(x,y) for some fixed y, then (f x) = g
23:33:14 <goltrpoat> or that's my take on it anyway
23:33:35 <mahogny> Lokadin, no. but it is probably not very hard
23:33:55 <laurence> goltrpoat: Is there a semantic difference in Haskell between (f x) y and f(x, y)?
23:34:33 <goltrpoat> f(x,y) as a haskell expression?  yes, the first expression has f :: a -> a -> something, the second one has f :: (a, a) -> something
23:34:54 * laurence guesses Korollary may choose (a).
23:35:26 <dons> one form is curried, and the other is uncurried
23:35:32 <dons> in fact, we have functions to convert between the two
23:35:34 <dons> ?type curry
23:35:35 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
23:35:47 <dons> ?type uncurry
23:35:49 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
23:36:05 <dons> > uncurry (+) 1 2
23:36:05 <lambdabot>  add an instance declaration for (Num (t -> a, t -> a))
23:36:09 <laurence> dons: Right, but do they produce the same results?
23:36:33 <dons> > uncurry (+) (1,2)
23:36:34 <lambdabot> 3
23:36:44 <dons> > curry snd 7 9
23:36:46 <lambdabot> 9
23:36:53 * laurence goes off to find his interpreter.
23:37:11 <dons> laurence: yeah. same results. its a very early result in computer science
23:37:30 <dons> that you can turn a function of n arguments into a function of 1 argument taking an n-tuple
23:37:35 <laurence> dons: That is what I meant, then.  They are mathematically equivalent.
23:37:42 <dons> right.
23:38:23 <laurence> dons: And thus my question: quick, without thinking, what f x y in canonical form with manifest grouping?
23:38:49 <laurence> If I write that as F X |y> you might be able to guess my answer. :-)
23:38:51 <dons> ? f x y == f x $ y
23:38:55 <Korollary> laurence: f x y in cont. math looks like multiplication. a haskell function x may very well consume a pair (x,y) instead of partially applying itself to x first, but you'll see that partial application is more convenient.
23:39:05 <dons> i.e. (f x) y
23:39:24 <dons> yeah, the partial form is preferred
23:39:35 <dons> death to tuples!
23:39:42 <laurence> dons: Yes.  See, I did learn something about Haskell.  Enough to translate operation from a foreign language, at any rate.
23:39:49 <dons> :)
23:39:52 * laurence prepares to leave before the natives get ugly.
23:40:27 <Korollary> laurence: If you'd like to learn more, you can look into lambda calculus itself. Very interesting.
23:40:33 <laurence> In the problem Cale was helping me with, while I don't understand "do" well enough to do it, I did find one alternate form.
23:40:50 <laurence> Korollary: Depends: can I write a Linux kernel module with it? :-)
23:41:10 <Korollary> laurence: Technically yes since LC is turing equivalent.
23:41:17 * laurence enjoys not having to do that kind of thing now that he's not in graduate school.
23:41:50 <goltrpoat> one thing that throws people (or so it seems) is ..  say inner :: Num a => [a] -> [a] -> a.  this suggests, if you read it in a certain way, that inner is a function of two arrays that produces an element of the array.  so inner u v = sum $ zipWith(*) u v, and the type of (inner u v) is a
23:42:06 <laurence> dons: (liftM (Number . read)) (many1 digit), which tested out to do the same thing.  That's why I was fairly sure I know how ajacency groups in Haskell.
23:42:11 <ADEpt> dons: seems like you did a lot of editing on http://www.haskell.org/haskellwiki/Books_and_tutorials, so I will ask you. I want to add my tutorial there. What's the best way: just edit this page?
23:42:22 <goltrpoat> but then, we can also write it as inner u = sum $ zipWith (*) u, at which point, the type of the definition you just made is [a] -> a
23:42:32 <goltrpoat> in other words, the domain and the range aren't really differentiated
23:42:48 <dons> ADEpt: yep. just add it to the tutorial list
23:42:56 <Cale> goltrpoat: sum . zipWith (*) u
23:43:03 <laurence> goltrpoat: If I even read your notation at all, why would that be confusing?
23:43:19 <goltrpoat> cale:  oops.  yah
23:43:20 <mlh> ADEpt: where's your tutorial?  Can I have a look?
23:43:28 <goltrpoat> laurence:  i thought that's where you were going with the f x y, (f x) y, f(x, y) bit.
23:43:42 <ADEpt> mlh: http://www.haskell.org/haskellwiki/?title=Hitchhikers_Guide_to_the_Haskell&redirect=no
23:43:42 <Korollary> goltrpoat: It's about how -> associates. a -> b -> c == a -> (b -> c)
23:44:08 <laurence> goltrpoat: I wasn't going anywhere, there's nothing wrong with it except that I am highly trained to assume right-associativity. :0(
23:44:19 <laurence> s/:0(/:-)
23:44:40 <Korollary> I liked the slashed nose
23:45:16 <laurence> Korollary: I think that was after he'd been hitting the sauce. :0)
23:45:54 <goltrpoat> laurence:  but you come across both left-associative and right-associative operations in algebra
23:45:54 <mlh> ADEpt: ah  thanks, i've read it :-)
23:46:09 <laurence> goltrpoat: That ain't the point.  Do a few years of quantum mechanics and then come talk to me. :-)
23:46:32 <goltrpoat> ...
23:46:33 <goltrpoat> ok
23:46:57 <Korollary> old habits die np-hard. (ok,kill me)
23:47:01 <laurence> goltrpoat: Anyway, I never really forgave the C library for naming ln() log(), so let's just say I'm a stubborn sort.  Don't worry about it.
23:47:35 <mahogny> goltrpoat, then at least you won't have any funny ideas about using commutativity to simplify your expressions :)
23:47:42 <mahogny> ehr laurence 
23:48:18 <laurence> mahogny: Certainly not with operators, unless I know their commutator vanishes!
23:48:48 <goltrpoat> (i'm still confused about how one can work with spinors and then with quaternions and then be confused by things associating to different sides, but i guess i should do a few years of quantum mechanics first)
23:49:12 <mahogny> laurence, big question: can you observe all parts of your program at the same time? :)
23:49:13 <laurence> goltrpoat: Only because after a while one learns how God writes his mathematics and always expects it to be done the same way. ;-)
23:49:40 <goltrpoat> i thought he was more into natural sciences.
23:49:45 <mahogny> lol
23:50:04 <Cale> laurence: oh? I like it to be log.
23:50:06 <mahogny> theoretical prophetic quantum mechanics
23:50:09 <laurence> mahogny: I can know the text exactly, but then I never know what it will do.  On the other hand, if I know what it will do, I have no idea what the source is.
23:50:12 <Cale> Nobody uses anything other than the natural logarithm anyway
23:50:27 <Cale> I suppose there are some applications for log_2
23:50:32 <mahogny> Cale, no. in fact: way too many use it :(
23:50:42 <Korollary> Cale: There's a convention where log without specifying the base stands for log 10.
23:50:55 <Cale> Korollary: yeah, that's a stupid convention
23:51:20 <laurence> Cale: I have never willingly written ln as log in my life, nor is it written that way in any textbook I own.  And I write log_2 as lg, but I realize that's not so common so I'm not able to be so unreasonably snooty about it. :-)
23:51:23 <Cale> In pure mathematics, the convention is generally that log without specifying the base is the natural logarithm
23:51:40 <Korollary> Cale: I am used to ln for natural log.
23:52:19 <laurence> Cale: If your textbooks use that convention, then they weren't written in the US at any rate.  I have a good number.
23:52:33 <Cale> laurence: they were
23:52:51 <Cale> laurence: Physicists use the ln convention
23:52:55 <Korollary> oh my god, a fried twinkie!
23:53:08 <Cale> in pure mathematics, it's way more common to use log for the natural logarithm
23:53:11 <laurence> Cale: Well, I have a pile from both the math and science department.  I was a math minor.
23:53:20 <goltrpoat> i haven't seen lg used anywhere that was published after the 1920s
23:53:44 <laurence> goltrpoat: Yes, I admit it's eccentric of me.  I use it simply because I like it.  The ln isn't negotiable, though. :-)
23:54:30 <laurence> goltrpoat: I expect to singlehandedly turn back the tide of history and reintroduce lg(). :-)
23:54:31 <skew> goltrpoat: I've seen that all over the place in CS stuff
23:54:35 <Cale> laurence: it's exactly the same with me, only the other way round
23:55:09 <palomer> hrmph
23:55:10 <goltrpoat> -nod- just changing it to log_base all over the place, and using log_e by default, i'd be perfectly fine with that.
23:55:19 <Cale> log base 10 is log_10, natural log is log, log base 2 is lg or log_2
23:55:22 * palomer discovered that his type inference algorithm was incomplete beyond repair
23:55:26 <palomer> quite discouraging
23:55:30 <laurence> Cale: Try not to look at the math library of any language I design.  Not only would it contain ln(), but it would hurl gratuituous and unfair imprecations at the false religion. ;0)
23:55:31 <Korollary> @palomer
23:55:32 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
23:55:35 <Cale> and the full complex logarithm relation is Log
23:55:47 <palomer> well, I fixed that bit
23:56:14 * palomer uses ln for the natural logarithm
23:56:16 <laurence> goltrpoat: Too much typing. :-)
23:56:17 <dancor> can i tell lambdabot to import
23:56:48 <palomer> @seen shapr
23:56:48 <lambdabot> shapr is in #haskell. I last heard shapr speak 46 minutes and 4 seconds ago.
23:56:59 <palomer> lambdabot: import
23:57:03 <Korollary> dancor: It's got everything imported that don intended.
23:57:06 <Cale> dancor: no, it has to be configured
23:57:25 <kzm> dons?
23:57:31 <Cale> dancor: if you could tell it to import anything, then you could tell it to import System.IO.Unsafe
23:57:46 <Cale> and then use unsafePerformIO to run any code you like on dons machine
23:58:24 * laurence waits for Cale to point out the bad part.
23:58:30 <Cale> heh
23:58:54 <Cale> @karma dons
23:58:55 <lambdabot> dons has a karma of 32
23:59:02 <laurence> Cale: Since you speak an alien tongue, let's experiment.  Is x! defined for non-integral x?
23:59:18 <Cale> laurence: depends on context, but generally, yes
23:59:25 <Korollary> maybe dons' machine is a virus infected mess
23:59:31 <laurence> Cale: Good. :-)
23:59:32 <palomer> so lambdabot is safe inasmuch that functions returning IO objects are not reachable?
