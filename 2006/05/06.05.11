00:32:13 <ADEpt> morning
00:32:29 <ValarQ> mornin
00:34:45 <dons> morning europe :)
00:37:06 <Oejet> Morning continent of Australia!
00:38:28 <dons> hehe
00:38:48 <amiddelk> morning (...)
00:39:59 <shapr> hiya
00:58:22 <ulfdoz> Ich war eher so an low level details wie algorithmen interessiert.
00:58:25 <ulfdoz> ECHAN, sorry
01:04:54 <dcoutts> vincenz, pong
01:05:04 <dcoutts> hia dons 
01:06:24 <dcoutts> dons, about ByteString(.Lazy), some of the functions in .Lazy are perhaps not appropriate
01:09:01 <dcoutts> because they take a symetric viewpoint of strings, but lazy strings are aysemetric
01:09:33 <dcoutts> basically the operations that work from the back are perhaps innapropriate
01:09:44 <dcoutts> since they force the whole stream
01:12:01 <dons> dcoutts: yeah, I was thinking about this too. ITs fine to provide only the reasonable subset, I think
01:12:08 <dons> also, pull my patches, QuickCheck spotted two bugs :)
01:12:16 <dcoutts> oh good :-)
01:12:28 <dcoutts> do said bug still need fixing?
01:14:59 * dcoutts loves patches like:
01:15:00 <dcoutts> Tue May  9 03:14:50 BST 2006  Don Stewart <dons@cse.unsw.edu.au>
01:15:00 <dcoutts>   * Critical INLINE on words exposes splitWith and halves running time
01:15:37 <dons> dcoutts: no longer need fixing.
01:15:44 <dcoutts> dons, ok
01:15:47 <dons> and the Lazy code runs through QuickCheck on both ghc and hugs :)
01:15:51 <dons> check tests/Lazy.hs
01:15:55 <dcoutts> ok
01:15:58 <dcoutts> great
01:16:23 <dons> there was a pasto in foldr1, and a corner case in take, iirc.
01:16:37 <dcoutts> ok
01:16:38 <dcoutts> dons, what did you decide to do about the extra internal func I needed?
01:16:50 <dcoutts> indexOfTHingOrEnd iiirc
01:17:12 <dons> I just exported it for now.
01:17:23 <dcoutts> right
01:17:40 <dcoutts> so we could split that into base later
01:17:51 <dons> yeah. 
01:27:47 <Lemmih> JohnMeacham: ping.
01:29:19 <JohnMeacham> pong.
01:29:28 <JohnMeacham> (Warning: drunk)
01:32:01 <Lemmih> JohnMeacham: I'm having problems building jhc from darcs. Something about a few functions in E/SSimplify.hs which aren't in scope.
01:34:25 <Lemmih> JohnMeacham: 'isIsBoundTo', 'envInScope_u' and 'envSubst_s'. I tried grepping them without any luck.
01:36:58 <norpan> dons: you have to make Lazy work from both en
01:36:59 <norpan> ds
01:45:28 <dcoutts> dons, the instance Arbitrary L.ByteString needs improving
01:45:35 <dcoutts> dons,   arbitrary = L.pack `fmap` arbitrary
01:46:12 <dcoutts> dons, that will just make a single chunk, but all the tricky cases are with multiple chunks
01:46:15 <dons> yeah, we need large strings.
01:46:18 <dons> its on my todo list
01:46:44 <dons> unless you want to work on that today. go for it if you like.
01:46:59 <dcoutts> and there are some subtle ones, eg look at group/groupBy
01:47:33 <dcoutts> I mean small multi-chunk LPSs, not large ones especially
01:48:11 <dcoutts> generating test cases to find the corner case in group/groupBy might be hard
01:48:43 <dcoutts> it needs [[a,b,c], [c,d]]
01:52:23 <dons> ah, yes,. so we generate a random list of random lists, and use that to pack some things.
01:52:49 <dons> ok, i'll add that now if you like.
01:53:49 <dons> also, do we need the x==nul cases in foldl1 foldr1? or are they handled by the invariant.
01:54:04 <dons> that's another thing to check, that the invariant is preserved by all functions
01:56:09 <dcoutts> dons, yes, that needs checking
01:56:46 <dcoutts> sure, patch that now if you like
01:56:54 * dcoutts is adding "Searching ByteStrings"
01:57:16 <dons> ok. i'll continue on the QC stuff while I make dinner.
01:57:28 * dons -> offline for a while.
02:08:26 <dcoutts> dons, foldl1/foldr1: "can't be true can it?" Correct. LPS (x:xs) -> not (P.null x) is part of the invariant.
02:14:22 <norpan> where is your bytestring repo?
02:19:35 <dons> dcoutts: better Arbitrary instance just pushed. 4 tests now fail the QCs
02:19:44 <dcoutts> that's better :-)
02:20:09 <dons> join.split/id, splitWith, foldr1/last, foldr1/head, foldl/reverse
02:20:16 <norpan> is this the new lazy stuff?
02:20:21 <dons> you might want to chase them up.
02:20:24 <dcoutts> norpan, yep
02:20:25 <dons> norpan: yeah, 
02:20:27 <dcoutts> dons, sure
02:20:40 <norpan> http://www.cse.unsw.edu.au/~dons/code/fps ?
02:20:43 <dons> its getting late here, and I'm a bit too tired  to debug new code 
02:20:50 <dons> norpan: yep. its in the re
02:20:53 <dcoutts> np
02:20:59 <norpan> nice
02:21:27 <norpan> what will happen if i pull and then kzm pulls and the i pull from him?
02:21:44 <norpan> will everything work by magic
02:21:52 <dons> well, the patches are unique, so darcs should just know what to do
02:22:09 <norpan> i'll dare
02:22:11 <dons> keeping things in sync does help though, so try not to drift too far.
02:22:28 <norpan> i won't drift
02:22:33 <norpan> i only work on existing files so far
02:22:58 <dons> i was thinking more that if you hack on ByteString.hs, then don't submit back to me, pretty soon you'll have conflicts
02:23:00 <norpan> i know Char8 was splitted up though
02:23:24 <norpan> ok what should i do with patches?
02:24:06 <dons> depends. patches to Data.ByteString.hs or Lazy.hs go to me. stuff to do with encodings goes to kzm's separate branch
02:25:19 <dons> kzm's basically working on all the encoding layers for Chars over a Word8 bytestring, dcoutts and I are workign on lazy Word8 bytestring vectors, a new data type. so they're separate branches for a while.
02:25:44 <dons> ok. now I really go and have dinner. night!
02:25:56 <dcoutts> g'night dons 
02:33:02 <araujo> morning!
02:34:09 <kolmodin> araujo: morning!
02:34:52 <araujo> kolmodin!!
02:34:55 <araujo> :-)
02:35:02 <kolmodin> :)
02:35:02 <norpan> and then we'll have different encodigns over lazy bytestrings too
02:40:51 * dcoutts sends more CInt/Int fixes to dons
02:45:34 <norpan> lot's of warnings when building with -Wall
02:45:41 <norpan> lots
02:47:30 <dons> norpan: there should be 4 warnings.
02:47:57 <norpan> there are warnings about importing stuff more than once
02:48:09 <dons> oh, you have 6.4 compiler?
02:48:25 <dons> because I don't see those here.
02:48:26 <norpan> oh, i suppose I have
02:48:34 <norpan> should I use 6.5
02:48:35 <dons> update. 6.4.2 is out now :)
02:48:48 <dons> 6.4.0 gave some bogus warnings.
02:49:01 <dons> there's no need to use 6.5 though.
02:49:24 <norpan> i might as well use that since I have it compiled
02:49:38 <norpan> 6.4.2 i have not
02:53:18 <pejo> What are you guys working on, performance for bytestrings?
02:53:45 <norpan> yes
02:54:19 <pejo> Nice!
02:54:28 <dons> a new data structure dcoutts thought up, a lazy bytestring, essentially a list of strict bytestring chunks, so we can handle strings larger than memory
02:54:31 <norpan> i'm working on UTF-8 encoded bytestrings
02:55:14 * dcoutts fixes ByteString.Lazy.reverse (doh!)
02:55:52 <norpan> reverse = L.reverse . map B.reverse?
02:56:00 <dcoutts> dons, with the quick check stuff we've got to check if the tests are [Word8] -> Bool or ByteString -> Bool
02:56:23 <dcoutts> dons, because both the existing reverse tests were [Word8] -> Bool, they didn't catch the bug.
02:56:33 <dcoutts> I added another that did catch it.
02:57:07 <dons> ah, right. oops.
02:57:10 <dcoutts> it's basically because using L.pack doesn't generate the tricky forms of ByteString.Lazy
02:57:20 <dons> right.
02:57:27 <dcoutts> dons, I think for testing I should make L.pack use very short chunks
02:57:58 <dcoutts> but of course random chunk sizes are best
03:00:44 <norpan> make a packWith and a list of chunkSizes
03:01:18 <dons> norpan:
03:01:20 <dcoutts> or just change the tests to start from ByteString.Lazy which now has a good random generator
03:01:20 <dons> > reverse . map reverse $ [[1,2,3],[4],[5,6,7]]
03:01:21 <lambdabot> [[7,6,5],[4],[3,2,1]]
03:01:26 <dons> :)
03:01:38 <norpan> dons: yes?
03:01:42 <dons> dcoutts: yeah, that's probably a better idea.
03:01:54 <dons> norpan: oh, just pondering what you mean by "reverse = L.reverse . map B.reverse?"
03:02:06 <norpan> dons: yes, that's what i meant
03:02:14 <norpan> L.map actually
03:02:20 <dons> ah, yes!
03:02:45 <dons> oh, did you spot this dcoutts?
03:03:08 <dcoutts> dons, spot what?
03:03:12 <dcoutts> that L.reverse is broken?
03:03:15 <dons> reverse (LPS xs) = LPS (L.map P.reverse xs) can't be right, can it?
03:03:30 <dcoutts> dons, yes, that's what I was talking about
03:03:42 <dons> ah, right.
03:03:49 <dcoutts> I've fixed that and discovered that the QC didn't catch it
03:04:10 <dons> I think changing to use the Lazy.ByteString generator is a good idea.
03:04:16 <dcoutts> reverse (LPS xs) = LPS (L.reverse $ L.map P.reverse xs)
03:04:18 <norpan> smallest test case [[a],[b]]
03:04:19 <dons> or else use a local packNasty
03:05:06 <norpan> all checks can use Lazy pack and then flatten
03:05:21 <dcoutts> cleaner to just modify the tests to start from a ByteString, that way they'll use the good generator
03:06:36 <norpan> pack . L.f . unpack x = P.f x instead?
03:06:39 <dcoutts> dons, hmm foldr1 is still broken
03:06:53 <dcoutts> norpan, right
03:06:59 <dcoutts> something like that
03:07:00 <norpan> yeah why not
03:07:04 <dcoutts> I changed:
03:07:20 <dcoutts> prop_reverse  xs = reverse xs          == (unpack . L.reverse . pack) xs
03:07:23 <dcoutts> prop_reverse2 xs = reverse (unpack xs) == (unpack . L.reverse) xs
03:07:41 <dcoutts> prop_reverse :: [Word8] -> Bool
03:07:44 <dcoutts> prop_reverse2 :: ByteString -> Bool
03:07:52 <norpan> yeah, you don't need to test pack all the time
03:07:57 <dcoutts> and so prop_reverse2 caught the bug but prop_reverse didn't
03:08:32 <dcoutts> it's one of those catrgoty diagrams
03:08:49 <norpan> because your bytestring arbitrary generates fragmented strings, but pack does not?
03:08:55 <dcoutts> we can either go 2 sides in each direction, or three sides and one side
03:09:04 <dcoutts> norpan, correct
03:09:16 <norpan> hey, i'm not so stupid after all :)
03:09:26 <dcoutts> of course not! :-)
03:15:23 <eivuokko> Not really related, but I am curious.  Could you make it part of the property to give you those unpack and pack, and generate (unpack,id) and (id,pack) pairs so that such tests would get generated more automatically?  prop_reverse (unpack',pack', xs) = reverse (unpack' xs) == (unpack . L.reverse .pack') xs
03:17:10 <norpan> i'm not sure i follow what you mean
03:17:19 <norpan> generate different unpack functions?
03:18:15 <eivuokko> No, give the property diffrent functions, always as pairs of (id,pack) and (unpack,id)
03:18:47 <norpan> but all inputs to properties are generated by quickcheck
03:18:59 <norpan> or you mean have some sort of generic property?
03:19:36 <eivuokko> Yeah, it seems that the diffrence between prop_reverse and prop_reverse2 must be generaliseable
03:20:16 <norpan> i see no reason to ever prefer prop_reverse
03:20:24 <eivuokko> And moving it to generator seems like natural thing to do.  But I am not sure if it's sensible in this case or in general.
03:20:27 <eivuokko> Ah, ok.
03:21:33 <norpan> the bytestrings generated by pack are a strict subset of those generated directly
03:22:01 <eivuokko> Translation: they are one chunk long
03:22:06 <eivuokko> ?
03:22:07 <norpan> yeah
03:22:43 <norpan> so unless you want prop_reverse to also check the pack function it gives you nothing extra
03:23:00 <eivuokko> Ok, I see.  Thanks :)
03:26:54 <dcoutts> yes, I should just discard prop_reverse and use prop_reverse2
03:27:09 <dcoutts> and the same for many other of the QC checks I expect
04:03:43 <ADEpt> @seen Lemmih
04:03:43 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 1 hour, 48 minutes and 36 seconds ago.
04:05:23 <ADEpt> any SOC mentors around?
04:13:48 <dcoutts> ADEpt, aye
04:14:23 <resiak> Is there an obvious way to find all sublists of size n? So, say n = 3, I want f "abcdef" = ["abc","bcd","cde","def"]
04:14:33 <ADEpt> dcoutts: information about you on trac is correct with respect to what you intend to mentor?
04:14:44 <dcoutts> probably not
04:14:48 * dcoutts checks
04:15:08 <ADEpt> dcoutts: could you say which areas you intend to mentor? i'm updating my tables.
04:15:12 <resiak> (all of the solutions that come to mind for me involve using zip_n)
04:15:29 <dcoutts> ADEpt, on the trac or to you here?
04:15:32 <tromp> > map (take 3) $ tails "abcdef"
04:15:33 <lambdabot> ["abc","bcd","cde","def","ef","f",""]
04:15:38 <ADEpt> dcoutts: to me here
04:15:49 <tromp> just ignore the last 3 entries:)
04:16:29 <dcoutts> ADEpt, DBus, DarcsUI, GStreamer (but Lemmih is also interested in Gstreamer)
04:17:06 <dcoutts> ADEpt, if we're missing mentors for areas that we want to take on then I'll look at it
04:17:23 <ADEpt> dcoutts: that's exactly what im going to find out
04:17:34 <ADEpt> dcoutts: i'm mapping areas to mentors right now
04:17:36 <dcoutts> ok, good, thanks
04:18:01 <resiak> tromp: Awesome, thanks :-)
04:20:16 * musasabi_ tried to write summaries of things, maybe put them into wiki?
04:20:52 <musasabi_> But that is in the open, so just the mailing list. Feel free to ignore my analysis just did it to make things clear for myself.
04:21:24 <ADEpt> musasabi_: what are you going to mentor?
04:23:19 <musasabi> ADEpt: the JHC thing, if it does not get selected then I can help with things involving concurrency/data structures if it looks like too many projects for dons.
04:23:44 <ADEpt> musasabi: that we will soon find out :)
04:24:19 <musasabi> Knowing whether we have 5,10,20 or 30 projects would make things much more simple.
04:24:23 <pejo> Does anyone by chance have a clue what a triangle with a tilde (~) below might be called in Latex?
04:25:34 <ADEpt> pejo: there is a file in the amsmath distibution that lists all symbols along with their names
04:26:11 <ADEpt> anyone know a nick handle for Niklas Broberg?
04:26:14 <pejo> Adept, I know, I just can't find the symbol in it. 
04:26:46 <musasabi> ADEpt: I think he does not irc.
04:27:05 <ADEpt> musasabi: ok. he will be listed as niklas then :)
04:27:29 <pejo> adept, who is 'nibro'?
04:27:38 <ADEpt> same for Bjorn Bringert, right?
04:27:44 <ADEpt> pejo: where?
04:27:47 <ADEpt> @seen nibro
04:27:48 <lambdabot> I saw nibro leaving #haskell 1 day, 13 hours, 28 minutes and 41 seconds ago, and .
04:27:53 <ADEpt> might be him
04:28:10 <pejo> adept, I'd guess "bringert".
04:28:16 <ADEpt> unfortunately i'm not on irc, so i cant whois him
04:28:28 <ADEpt> @seen bringert
04:28:28 <lambdabot> I saw bringert leaving #haskell 14 hours, 27 minutes and 59 seconds ago, and .
04:29:14 <ADEpt> dcoutts: "ide" area is also yours?
04:29:32 <dcoutts> ADEpt, yeah, but I don't think any of them are much good.
04:30:21 <musasabi> Maybe vote the "bad" proposals to negative and drop them from the iteration?
04:30:25 <ADEpt> dcoutts: but for the record, i'll list you, alright?
04:30:32 <dcoutts> ADEpt, ok
04:31:03 <ADEpt> I think that we should split the word somehow and mark apllications as "ineligible" - that's too many of them right now.
04:31:31 <ADEpt> that's why i'm collecting the list - should help in splitting the work
04:31:48 <ADEpt> even if we dont follow that path, will be usefull anyway
04:44:20 <ADEpt> seems like we have 45 applications "unattended"
04:45:31 <kolmodin> nibro is Niklas Broberg and bringert is Brˆrn Bringert
04:45:55 <kolmodin> Brˆrn/Bjˆrn
04:54:00 <ADEpt> kolmodin: thank you
04:54:16 <ibid> pejo: have you seen http://www.ctan.org/tex-archive/info/symbols/comprehensive/ ?
04:56:01 <pejo> ibid, yeah, couldn't find it in there. No big deal though.
04:59:43 <ibid> ok
05:14:46 <shapr> What do you call a proof made by testing each possibility?
05:14:50 <shapr> proof by elimination?
05:14:59 <resiak> exhaustion?
05:15:28 <shapr> ah,thanks! http://en.wikipedia.org/wiki/Proof_by_exhaustion
05:16:48 <pjd> proof ad nauseum
05:17:58 <pjd> nauseam, even
05:24:53 <xerox> „ÅäÊó©„ÅÜ
05:24:58 <shapr> ~~~!
05:28:21 <kzm> Gesundheit!
05:29:03 <norpan> prosit!
05:32:39 <kzm> norpan, any UTF news?
05:32:51 <norpan> nope
05:53:34 <norpan> kzm: actually i have pushed a few changes now
06:11:02 <kzm> norpan, what's the status?  Working?  Fast?  Complete?
06:11:29 <norpan> working
06:11:38 <norpan> i made the changes to make it lazy
06:11:45 <norpan> this makes it a tad slower on the benchmarks
06:12:15 <norpan> unpack, that is
06:14:59 <kzm> Okay.
06:15:46 <kzm> I'm pulling from dons now, and will pull your repo after that. And then dcoutts.  And if everything works, I'll update my public.
06:15:48 <norpan> i think it's time to go about this systematically
06:16:00 <norpan> :)
06:16:00 <kzm> :-)
06:16:11 <norpan> find a good UTF-8 benchmark
06:16:46 <norpan> consolidate function lists
06:17:53 <norpan> btw have you tried just to make a ByteString but with Word16 instead?
06:18:32 <audreyt> JaffaCake had a version of that somewhere
06:18:43 <audreyt> I wonder if ByteString.Char16 makes sense
06:20:03 <norpan> Char16 would be the same as UCS-2
06:21:53 <kzm> audreyt, I have it half-way implemented, but if you want, feel free to go at it.
06:22:19 <norpan> kzm: but UCS-2 should be just ByteString but using Word16 instead?
06:22:38 <kzm> Yes.
06:22:43 <norpan> ok good
06:22:50 <audreyt> kzm: can I take a look at the halfway code somewhere?
06:22:58 * audreyt wonders if we can get it into dons's repo
06:22:59 <kzm> Just need to add some multipliers here, divisions there.
06:23:21 <kzm> dons is skeptical of the encodings stuff, but if we can make it work nicely, I think he can be convinced. :-)
06:23:22 <audreyt> nodnod.
06:23:23 <norpan> yeah
06:23:26 <kzm> @seen dons
06:23:26 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours, 19 minutes and 5 seconds ago.
06:23:32 <audreyt> Pugs can really use Char16.
06:23:42 <norpan> why is he sceptical?
06:23:47 <audreyt> I can hack in surrogates too
06:23:54 <audreyt> which makes it UTF16 instead of UCS2
06:24:02 <norpan> which makes it much harder :)
06:24:05 <kzm> You know, if you guys voted for my SoC projects, I could spend less time arguing about that, and more time on ByteStrings :-)
06:24:17 <norpan> you can vote?
06:24:52 <kzm> skeptical - and rightly so - because Unicode is a can of worms. 
06:24:55 <audreyt> uhm, I don't see your proposal...
06:25:04 <kzm> FPS/BS is about to go into base, encodings - well.
06:25:13 <kzm> audreyt, the bioinformatics stuff.
06:25:16 <audreyt> well, haskell Char _is_ unicode
06:25:18 <norpan> it's a can of worms, granted, but it needs to be opened and dealt with
06:25:22 <audreyt> so the can of worms is already there, so to speak
06:25:32 <kzm> audreyt, in name and bitwidth only.
06:25:35 <audreyt> it's just we lack a good strict/packed unicode string.
06:25:42 <audreyt> also in isAlpha and stuff now.
06:25:51 <audreyt> but I think we are in vehement agreement
06:25:59 <kzm> Char is a mess, IMHO.  Pretends to be UC, but you only get chopped-off characters.
06:26:16 <norpan> Char is not a mess, putStr and friends are :)
06:26:26 <ADEpt> audreyt: ther worms are already there, agreed. Now we need a can :)
06:26:33 <kzm> ByteStrings will be nice, because you'll be able to deal with strings in a UC way, while keeping the data in the original encoding.
06:26:35 <audreyt> well, I did lots of hacking to get unicode+encoding+cjk support into Perl5.8
06:26:47 <audreyt> I wouldn't mind doing the same to Haskell :)
06:27:03 <norpan> i definitely think there is room for both UTF-8, UCS-2, UCS-4 and possibly UTF-16
06:27:13 <kzm> I'm trying to maintain a half-official repo at http://www.ii.uib.no/~ketil/src/fps-i18n
06:27:40 <kzm> And keep it updated with dons, norpan and dcoutts (who is working on a lazy bytestring, storing [BS]
06:27:40 <norpan> and various 8-bit encodings of course
06:28:19 <audreyt> well, there is something called .ucm
06:28:23 <norpan> and we also want lazy+all encodings
06:28:33 <audreyt> and things like ISO8859_16.hs should probably be derived from that
06:28:40 <norpan> .umc?
06:28:41 <norpan> .ucm?
06:28:42 <audreyt> instead of written by hand for each and every encoding
06:28:50 <audreyt> encoding specification format
06:28:55 <kzm> Yep, the thought has struck me.
06:28:56 <audreyt> used by ICU, Tcl, Perl, etc
06:29:00 <norpan> ah
06:29:07 <kzm> Did you look at my 8-bit modules yet, then?
06:29:14 <audreyt> I just did
06:29:21 <kzm> Right.
06:29:31 <norpan> for 8 bit encodings the encoding could even be dynamic
06:29:40 <norpan> since there are just a few functions that needs to be defined
06:29:48 <kzm> The conversion is trivial (that is - I just looked at .txt files, not .ucm).  
06:30:26 <kzm> There is an advantage to hand-coding it, in that often you can optimize things.  Many have use ASCII subset, and it's easy to test for c < 128 and short-circuit.
06:30:33 <audreyt> .ucm parsing is trivial also
06:30:45 * kzm haven't looked at them.
06:30:55 <audreyt> there is also CharMapML
06:31:01 <audreyt> which is isomorphic, but is in preparsed form
06:31:05 <audreyt> (XML)
06:31:29 <audreyt> http://search.cpan.org/dist/Convert-CharMap/ # my module to convert between CharMapML, UCM, and YAML
06:33:21 <norpan> if ascii subset is common, this could be a flag in the encoding data structure
06:33:57 <norpan> the obvious advantage being that users can define their own encodings
06:34:13 <audreyt> yeah. "enc2xs" in perl implements a quite efficient sharing algorithm for user-defined as well as static .ucm encodings
06:34:18 <audreyt> ICU does something similar too.
06:35:30 <kzm> Okay.
06:35:45 <norpan> UTF-16 is problematic in the same way that UTF-8 is, in that a character may be more than one word
06:36:05 <kzm> One option is to write a more generic module, with functions taking charsets as parameters.
06:36:20 <kzm> If benchmarks show it is equally fast, we can scrap my specific modules.
06:36:35 <audreyt> well. I don't know
06:36:35 <kzm> If not, it is still useful for rare or user defined charsets.
06:36:41 <audreyt> I think typeclasses is the right call really
06:36:53 <audreyt> since {#- SPECIALIZE #-} can guarantee no speed loss
06:36:53 <musasabi> btw UTF16BE or UTF16LE ?
06:37:08 <audreyt> whatever that is native, I hope.
06:37:22 <kzm> audreyt, hmm...okay.  
06:37:53 <musasabi> audreyt: but if we want to support mmapped files in future isn't that kind of problematic?
06:38:05 <audreyt> well, you need to read BOM anyawy
06:38:08 <kzm> It'd be nice to put string (and list) operations in a typeclass anyway, of course.  But perhaps too ambitious?
06:38:08 <audreyt> so no, it's not problematic
06:38:25 <audreyt> in all cases you start off reading BOM
06:38:44 <audreyt> so to the user it's just .UTF16
06:38:58 <audreyt> but LE/BE is accessible also if explicitly requested
06:39:20 <musasabi> ok, that is enough.
06:39:44 <kzm> I must run.
06:40:10 <kzm> We should have a mailing list and/or wiki to discuss this.
06:40:21 <norpan> audreyt: UTF-16 makes packed strings a bit more problematic, but UCS BE/LE would be no problem, just a different mapping from char->word16
06:40:31 <norpan> UCS-2 that is
06:40:38 <audreyt> norpan: I'd propose starting with UCS too
06:41:02 <audreyt> another line of thought is autoupgrading
06:41:36 <audreyt> that is, if you perform some operation on a UCS2 that makes UCS4 required
06:41:41 <audreyt> then it promotes into UCS4
06:41:50 <audreyt> this is especially useful for a Data.Rope-like string
06:42:01 <audreyt> where each segment are in the most space-efficient fixed width encoding
06:42:13 <norpan> Data.Rope?
06:42:13 <audreyt> that is, latin1, ucs2, or ucs4.
06:42:33 <audreyt> concat trees. O(1) space/time concat
06:42:44 <audreyt> boehm's paper: http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
06:42:55 <audreyt> Pugs is going to use that as the native data structure in 6.28.x, I think.
06:43:27 * xerox pokes audreyt 
06:43:34 <norpan> ByteString.Lazy is one level ropes then
06:43:37 <audreyt> what? :)
06:43:45 <audreyt> norpan: not quite, it's biased toward the front
06:44:05 <norpan> yes, one level :)
06:44:25 <norpan> so replace [] with Tree
06:44:32 <norpan> and you have a Rope
06:44:35 <audreyt> but ropes are strict
06:44:51 <audreyt> and have position indexes
06:45:03 <audreyt> so random access doesn't need to traverse that much
06:45:20 <audreyt> also, Tree needs rebalancing on concat, iiirc
06:45:33 <norpan> ByteString.Lazy is maybe inappropriately named
06:45:45 <norpan> it's not just lazy, it supports fast concat
06:46:01 <norpan> relatively fast anyway
06:46:45 <norpan> and it also has length indexes
06:47:16 * audreyt relooks
06:47:25 <norpan> it's just [ByteString]
06:47:31 <norpan> but a ByteString has a length index
06:47:44 <audreyt> oh hm.
06:47:52 <musasabi> Lazy does not help against constantly using append.
06:48:08 <audreyt> list append is not O(1)
06:48:14 <norpan> exactly
06:49:16 <norpan> using a tree seems much better, and then we have something like your Rope
06:49:30 <musasabi> and e.g. "unwords . words" is going to make the resulting Lazy quite inefficient. On the other hand Lazy is very usefull if used for input/output.
06:49:50 <norpan> and the worst case tree is a list
06:49:58 <norpan> and so trees are no worse than []
06:51:10 <norpan> is this Rope thing implemented in Haskell somewhere?
06:52:39 <musasabi> norpan: SoC hopefully.
06:52:45 <norpan> oh
06:53:05 <xerox> Rope?
06:53:19 <audreyt> xerox: http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
06:53:34 <audreyt> larry's idea is to tag rope fragments with language and encoding info
06:53:50 <norpan> language?
06:53:55 <audreyt> language. as in collation
06:54:10 <audreyt> and grapheme logic
06:54:21 <norpan> encoding i can understand
06:54:24 <audreyt> as perl6 strings default to grapheme-level
06:54:52 <norpan> as in 8,16 or 32 bits
06:54:57 <musasabi> grapheme level is very good. Much beter than the Haskell Char level.
06:55:23 <norpan> what is a grapheme
06:55:33 <audreyt> it's a base codepoint with some combining characters.
06:56:06 <audreyt> usually with a preferred normalization
06:56:19 <norpan> is it the same as unicode decomposition?
06:57:33 <audreyt> decomposition is one way to do normalization
06:57:39 <audreyt> but anyway. :)
06:58:34 <norpan> yes, but i mean, unicode decomposition maps unicode chars to base char + combining characters
06:58:45 <audreyt> some unicode chars.
06:58:52 <norpan> yes, of course not all
06:59:02 <audreyt> yes. but normalization can work the other way
06:59:13 <audreyt> by specifying you want precomposed chars whenever plausible
06:59:17 <norpan> unicode normalization is basically compose . decompose
06:59:58 <norpan> normalization form c
07:01:29 <xerox> I ever thought it would have been good to represent strings as trees like that.
07:01:42 <audreyt> s/ever/never/ ?
07:01:48 <xerox> always
07:01:52 <xerox> Oops :-)
07:02:11 <xerox> But I never further investigated, very nice.
07:02:23 <norpan> we should do it, SoC or not
07:02:44 <norpan> and having fragments of byte size 8,16, and 32 is a good idea too i think
07:03:04 <norpan> the composition/decomposition i don't know about
07:03:21 <xerox> Would it be a pure Haskell implementation of Ropes?
07:03:27 <norpan> i think maybe that should be separate
07:03:46 <norpan> we can well use ByteString fragments
07:04:03 <audreyt> norpan: normalization in perl6 is specced to happen on I/O boundaries
07:04:16 <audreyt> so the in-memory structure doesn't need to care
07:04:22 <audreyt> just static 8/16/32 would do.
07:04:29 <norpan> yes
07:05:21 <norpan> so we'd have data Rope = Concat Int Rope Rope | Leaf Encoding ByteString
07:05:42 <norpan> where the Int is the length of the left Rope
07:07:03 <audreyt> I'll keep two Ints.
07:07:09 <audreyt> (substr from rightward.)
07:07:15 <audreyt> (reverse)
07:07:50 <norpan> substr from rightware? i didn't read the article yet
07:09:14 <norpan> the Int could be the length of the full Rope of course
07:10:02 <audreyt> but then, you don't know which half to go into
07:10:06 <audreyt> so I think we need two Ints.
07:10:11 <norpan> you'd just check length left
07:10:19 <audreyt> that works too.
07:10:39 <norpan> it will be either a concat or a bytestring both of which has length parameters
07:10:43 <audreyt> indeed. so =ropelength works
07:10:49 <audreyt> yup. forgot bytestring carries its own len
07:10:59 <norpan> maybe bytestring is to heavyweight
07:11:06 <audreyt> I think it's just right.
07:11:12 <norpan> it also has a start param
07:11:17 <audreyt> but that's good
07:11:17 <norpan> so that you can do O(1) slice
07:11:25 <audreyt> which you can still do on ropes
07:11:39 <audreyt> [--fragA--][--fragB--]
07:11:42 <audreyt>    [--slice--]
07:11:51 <audreyt> can simply adjust the "start" in fragA's bytestring
07:11:56 <norpan> yes then bytestring is just right yes
07:11:57 <audreyt> and "length" in fragB's
07:12:18 <audreyt> yeah. this looks much more attractive than .Lazy
07:12:38 <norpan> we should have a wiki, write this down
07:13:38 <shapr> How do Ropes compare to Finger Trees?
07:13:47 * shapr checks the logs
07:13:52 <audreyt> it is a kind of finger tree, I think
07:14:24 <norpan> finger tree, is that Data.Sequence?
07:14:44 <audreyt> ...someone once told me that the word "Wiki", in original Hawaiian, means "can't find that damned thing"
07:14:49 <shapr> Are these Ropes you're discussing the same as http://www.sgi.com/tech/stl/Rope.html ?
07:14:55 <shapr> haha
07:15:11 <norpan> shapr: i suppose so
07:16:15 <musasabi> One good side of Ropes would be infinite ByteStrings.
07:16:30 <norpan> yes, lazy :)
07:17:08 <norpan> and repeat 'x' would take constant space
07:17:15 <audreyt> which is wonderful.
07:17:30 <audreyt> it also enables common-substring sharing
07:18:38 <norpan> but it can't be infinite if we store the length
07:18:48 <audreyt> it can if we use Integer ;)
07:18:55 <xerox> Right, I was wondering what kind of smart implementation could do it
07:18:57 <norpan> no, even an Integer is finite
07:19:11 <audreyt> well, a special Len data field then
07:19:17 <xerox> It's clecer trick time!
07:19:21 <audreyt> sorry. was thinking of Ratio
07:19:23 <xerox> *v
07:19:24 <audreyt> (which can store Inf)
07:19:40 <musasabi> or just preserve String semantics.
07:19:57 <audreyt> you mean, store undefined there?
07:20:02 <audreyt> sounds... haskellish
07:20:34 <musasabi> let infinite = Concat (lenth l) l (length infinite) infinite
07:20:45 <audreyt> yeah.
07:21:08 <audreyt> let inf = Concat (error "length is infinite") inf inf
07:21:17 <audreyt> let inf = Concat (error "length is infinite") sub inf
07:22:11 <norpan> repeat a = let inf = Concat infinite (packChar a) inf in inf
07:22:35 <shapr> length :: Maybe Integer ?
07:22:40 <norpan> repeat a = let inf = Concat infinite (Leaf (packChar a)) inf in inf
07:22:55 <musasabi> shapr: Int rather than Integer.
07:22:58 <audreyt> shapr: I'm not comfortable with Nothing standing for Everything
07:23:33 <audreyt> just a simple Int would do... even -1 works.
07:23:49 <norpan> maxBound would do
07:23:54 <audreyt> that too.
07:23:58 * musasabi thinks an error is better for code.
07:24:03 <norpan> maxBound is infinite enough
07:24:09 <audreyt> but sometimes you want to test if it's >10
07:24:12 <audreyt> in length
07:24:17 <audreyt> and an error is not helpful.
07:24:32 <norpan> if integer == pointer size, then infinite == maxBound or slightly less
07:24:40 <musasabi> audreyt: for that you have a separate isLongerThan
07:24:50 <audreyt> how do you code isLongerThan?
07:24:59 <audreyt> if the len field is error?
07:25:14 <audreyt> keep doing 'head'?
07:25:15 <norpan> catch? :)
07:25:16 <xerox> audreyt: counting the bytestring len?
07:25:36 <audreyt> point.
07:25:37 <norpan> i think having a simple Int and using maxBound would be sufficient
07:25:40 <musasabi> audreyt: isLongerThan (-1) _ = True; isLongerThan k x = if null x then False else isLongerThan (k-1) (tail x)
07:26:22 <audreyt> norpan: but beware that maxBound+1 wraps
07:27:02 <audreyt> so the concat calculator needs to take that into account
07:27:03 <norpan> audreyt: the Rope code would treat maxBound specially of course
07:27:15 <musasabi> norpan: that would cause problems. e.g. let len = length infi + 1; withCStringLen (ptr,len) ...
07:27:30 <norpan> musasabi: not more than an error would
07:27:42 <musasabi> norpan: silent bug vs error.
07:28:02 <norpan> both are fatal
07:28:12 <norpan> ie there is a bug in that code
07:28:15 <musasabi> One is easy to detect during testing.
07:28:16 <audreyt> silent bug is more fatal than fatal
07:28:32 <norpan> i'd say the other one is also easy to detect during testing
07:28:57 <musasabi> norpan: not necessarily, it can easily lead to silent data corruption.
07:29:14 <norpan> i don't buy it
07:29:37 <audreyt> ...if Int supports explicit +-Inf, we won't be discussing this... :)
07:29:50 <audreyt> (or Word vs +Inf)
07:29:52 <musasabi> norpan: e.g. take the length of a bytestring + 1. Allocate a buffer of that size. Write the ByteString suplied from user into that buffer. "oops, a buffer overflow attack"
07:30:21 <norpan> users don't supply ByteStrings, they supply input
07:30:40 <audreyt> norpan: if you are going to specially treat it, I think a new datatype is best.
07:30:59 <audreyt> data Len = Inf | Fin Int
07:31:10 <norpan> sure, but that will take more space
07:31:23 <audreyt> well, then use -1
07:31:35 <audreyt> which is conceptually also Inf
07:31:39 <audreyt> according to some concepts :)
07:31:55 <norpan> then it will again fail silently
07:32:03 <norpan> just as with maxBound
07:32:18 <audreyt> true. 
07:32:20 <norpan> but maxBound is better because things like length string > 10 will work
07:32:37 <norpan> and the string conceptually has that length
07:32:53 <musasabi> of coursde "length string + 1 < length string2" won't work.
07:33:04 * audreyt thinks error is more attractive now :)
07:33:12 <audreyt> but either way, we can play with it when there is code :)
07:33:23 <norpan> this is something that is easy to change
07:33:40 <audreyt> yup
07:33:40 <norpan> so we can have three different libraries :)
07:33:46 <norpan> to each his own
07:34:03 <audreyt> #if NICKNAME == "musasabi"
07:34:18 <audreyt> #define INFLEN (error "infinite length")
07:34:19 <audreyt> #endif
07:34:39 <norpan> also having error there means we can't make that field strict
07:34:52 <audreyt> you want to make it strict?
07:34:56 <norpan> or unboxed
07:35:03 <audreyt> what good is lazy parts with strict length fields?
07:35:35 <norpan> well
07:35:38 <norpan> maybe not
07:35:50 <norpan> lazy but of known length
07:36:05 <audreyt> maybe.
07:36:15 <audreyt> stat() on a file but delay reading
07:36:17 <audreyt> or something
07:36:29 <audreyt> not sure it's that useful a concept
07:37:16 <norpan> of course doing something like (packRope (repeat 'a')) won't work with strict length
07:37:37 <audreyt> I think either all-lazy or all-strict
07:37:56 <audreyt> and lazy is quite attractive
07:38:10 <norpan> then Maybe Int is an alternative
07:38:28 <norpan> or your Len type which is isomorphic
07:38:40 <audreyt> yeah. though, not sure if it helps in the (packRope (repeat 'a')) case.
07:38:56 <audreyt> tht case is just an error, pure and simple
07:39:00 <audreyt> in the Int field
07:39:05 <norpan> not at all
07:39:23 <audreyt> mmm?
07:39:45 <norpan> it will be Rope (Just (1+unevaluated)) (Leaf 'a') unevaluated
07:40:03 <norpan> so doing head on it will work for instance
07:40:12 <norpan> if head doesn't check the length first
07:40:21 <audreyt> but you don't need the Just
07:40:25 <audreyt> you can achieve the same thing
07:40:30 <norpan> yeah
07:40:40 <audreyt> so I think your original line is still correct
07:40:59 <shapr> Where'd @remember go?
07:41:10 <norpan> yeah, we just can't make the int field strict or unboxed or whatever it's called
07:41:13 <musasabi> audreyt: couldn't we make reading a file semi-strict?
07:41:38 <norpan> of course, packing stuff byte-by-byte is not optimal either
07:41:45 <musasabi> audreyt: just special-case that to fill the length fields in an eager fashion instead of lazy.
07:41:45 <audreyt> musasabi: it's naturally fallen out of the readFile being one chunk
07:42:05 <audreyt> or multiple 64k chunks if that turns out to be faster
07:42:11 <audreyt> (each chunk is a strict ByteString)
07:42:17 <musasabi> multiple 64k chunks.
07:42:25 <audreyt> concur.
07:42:42 <audreyt> which means the len field can be $!'ed.
07:42:48 <musasabi> e.g. I have code which reads 300mb files as [ByteString] with unsafeInterleaveIO and needs the length at the start.
07:42:58 <audreyt> yup.
07:43:14 <audreyt> the cool thing is
07:43:19 <audreyt> if you need the "middle" char
07:43:24 <audreyt> it only reads on 64k
07:43:26 <audreyt> instead of half of it.
07:43:34 <audreyt> (conceptually it does a seek first.)
07:43:54 <norpan> so each chunk would be a (seek n >> read)
07:44:10 <norpan> random access!
07:44:21 <audreyt> yeah.
07:44:31 <norpan> that is good shit
07:44:38 <musasabi> audreyt: I would provide them as separate functions or add a Hint parameter.
07:45:20 <norpan> throwing in seek n when we already are at n would be a negible cost so why not do it always
07:45:44 <audreyt> musasabi: I agree.
07:45:56 <musasabi> norpan: actually we need either pread (non-portable) or locking.
07:45:58 <audreyt> it's sad that open data types is not the norm
07:46:11 <audreyt> otherwise we can take Data.Sequence
07:46:17 <audreyt> and introduce the Length field to it.
07:46:36 <audreyt> as it stand, (Sequence ByteString) won't do
07:47:01 <audreyt> but anyway, who needs rebalancing
07:47:10 <shapr> unicycles!
07:47:11 <audreyt> lopsided binary trees `r` us
07:47:19 * shapr boings hoppily
07:48:08 <audreyt> norpan: you up to code this up? :)
07:48:08 <musasabi> audreyt: one could still write a manual "rebalance" function.
07:48:20 <norpan> audreyt: wasn't it a SoC project?
07:48:22 <audreyt> musasabi: but then the use is heuristics driven
07:48:56 <audreyt> norpan: true.
07:49:21 <norpan> then someone else might code it up and i can do other things :)
07:49:24 <audreyt> is Spencer on #haskell?
07:49:45 <xerox> @seen sjanessen
07:49:45 <lambdabot> I haven't seen sjanessen.
07:49:54 <xerox> @seen sjansen
07:49:54 <lambdabot> I haven't seen sjansen.
07:49:54 <shapr> @seen sjanssen
07:49:55 <lambdabot> I saw sjanssen leaving #haskell 5 hours, 42 minutes and 52 seconds ago, and .
07:50:01 <xerox> Names.
07:50:11 <shapr> Who needs 'em with lambda cal?
07:50:30 <norpan> @seen (\x -> x)
07:50:31 <lambdabot> I haven't seen (\x.
07:55:12 <xerox> I should use ropes for my throusers, I coudln't find where I've left my pocket... gawk.
07:55:17 <xerox> To the shops!
07:55:43 <shapr> whee!
07:57:38 <audreyt> actually, the SoC application proposes to use something like
07:57:44 <audreyt> Seq ByteString
07:57:50 <audreyt> for O(logn) concat
07:58:10 <audreyt> instead of this simplistic O(1) concat with explicit rebalancing that we talked about here
08:09:07 <dons> hmm, that reminds me, length of ByteString.Lazy should not return an Int.
08:09:34 <dons> since how ever am I going to find the length of a big file that way.
08:10:24 <dons> dcoutts: ^^ we should do a bit of a scan for Int assumptions that no longer hold for Lazy.hs 
08:10:53 <musasabi> dons: of course the problem is going away. (platforms with 64 bit Int)
08:11:01 <dons> yeah. that's true.
08:11:09 <dons> but I want to filter 8G files tomorrow!
08:11:23 <musasabi> dons: make the summation check for overflow and abort on? Or Int64?
08:11:36 <dons> Int64, hmm. 
08:12:00 <dons> Integer is more kosher around here, though.
08:12:12 <dons> and it really could be potentially infinite input.
08:13:02 <dons> the leaves keep their Int length, since none can be bigger than memory anyway, but the sum of the leaves needs to be bigger.
08:13:25 <dons> its an exciting time to be hacking haskell!
08:13:26 <xerox> > length xs where xs = 'x':xs
08:13:30 <lambdabot> Terminated
08:14:13 * dons goes back to sleep to dream about haskell and really big data
08:17:20 <audreyt> I've got Rope (based on Seq ByteSting) implemented.
08:17:29 <norpan> 64 bit ints ought to be enough for anybody!
08:17:51 <norpan> audreyt: smashing!
08:18:02 <audreyt> is Bench.hs the canonical benchmark?
08:18:23 <norpan> we need to consolidate the benchmarks
08:20:33 <norpan> audreyt: do you have the code somewhere public?
08:21:16 <audreyt> a sec.
08:22:04 <shapr> @timein dons 
08:22:05 <lambdabot> Local time for dons is Fri May 12 01:17:55 2006
08:22:36 <norpan> so Seq ByteString will be approx. what we want but without the length?
08:24:04 <norpan> not that i really need to see your code, i would suspect the implementation is pretty straight-forward :)
08:25:20 <norpan> Seq is also strict, right?
08:30:23 <norpan> hmmmm these classes Data.Foldable and Data.Traversable should be useful for all these data structures, but they are not the right type
08:30:47 <davidhouse> norpan, how so?
08:31:13 <norpan> the type needs to have a type parameter
08:31:34 <xerox> Hm?
08:31:37 <norpan> so ByteString will not do, it'll have to be ByteString Word8
08:32:05 <xerox> @docs Data.Traversable
08:32:05 <lambdabot> Data.Traversable not available
08:32:15 <norpan> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Traversable.html
08:32:33 <norpan> likewise with Functor et al
08:32:41 <DeliQ> does somebody know how you can dash underline text in latex
08:33:21 <norpan> they would need to be Multi parameter
08:33:32 <norpan> i'm sure this has been up before
08:37:25 <musasabi> norpan: it needs restricted kinds, really the same problem as with Functor+Set.
08:37:37 <musasabi> or the Ctx class trick.
08:38:29 <davidhouse> how can you traverse across something that isn't a container?
08:38:49 <norpan> davidhouse: you can't?
08:39:13 <davidhouse> norpan, right, so why are you complaining that instances of Data.Traversable need a type parameter?
08:39:25 <norpan> because ByteString is a container of Word8
08:39:33 <norpan> but it has no type parameter to show that
08:39:55 <davidhouse> ah. a non parametrised contained.
08:39:58 <davidhouse> *container
08:40:34 <Beelsebob> o.O
08:40:42 * Beelsebob does a google image search for Haskell
08:41:10 <audreyt> http://svn.openfoundry.org/pugs/src/Data/ByteString/Seq.hs
08:41:42 <audreyt> norpan: this uses GHC 6.5's "Seq" type; a copy is at  http://svn.openfoundry.org/pugs/src/Data/Seq.hs
08:41:51 <norpan> http://www.rootsweb.com/~usgenweb/maps/texas/countymap/haskell.jpg
08:42:00 <norpan> audreyt: yes i know it
08:42:27 <davidhouse> yeah! http://www.google.com/trends?q=haskell%2C+ocaml&ctab=0&date=all&geo=all
08:42:48 <shapr> Cool, I didn't know about trends.
08:43:16 <shapr> I like how they reported on the Alex lexer ;-)
08:43:17 <davidhouse> it's new.
08:43:44 <shapr> "Haskell goes from serious fall to the Super Bowl" "Alex likely for Haskell"
08:44:06 <norpan> audreyt: good start
08:44:48 * audreyt curtsies
08:44:58 <norpan> but the question is should we use Seq or code it up ourselves (using optimization for chars)
08:45:07 <shapr> Lisp is only a tiny bit higher than Haskell. I'm surprised.
08:45:09 <davidhouse> shapr, well, that's O'Caml's fault for chosing a silly name :)
08:45:23 <Beelsebob> http://www.google.com/trends?q=haskell%2C+porn&ctab=0&date=all&geo=all
08:45:34 <audreyt> :r
08:45:52 <davidhouse> http://www.google.com/trends?q=emacs%2C+vim&ctab=0&date=all&geo=all really close
08:46:00 <norpan> wth is Lawrence
08:46:09 <davidhouse> Beelsebob: can't win 'em all.,
08:46:17 <Beelsebob> lol
08:46:20 * shapr entertains himself with http://www.google.com/trends?q=erisson%2C+shae&ctab=0&date=all&geo=all
08:46:34 <davidhouse> http://www.google.com/trends?q=vin+diesel%2C+chuck+norris&ctab=0&date=all&geo=all the essential
08:46:46 <shapr> Hong Kong wants erisson??
08:47:01 <shapr> Have you guys tried Google calendar? It's way spiffy!
08:47:15 <norpan> yes it's goot
08:47:22 <norpan> even though it has a few bugs left
08:47:22 <audreyt> norpan: if you refresh, I've filled in all the XXXs
08:47:54 <davidhouse> shapr, why?
08:48:09 <norpan> i have to rush now i'll look at it tonight
08:48:20 <shapr> Because I can share my calendar with my girlfriend, and request meetings with her, see when she's buys, get email reminders, etc.
08:48:27 <norpan> perhaps we can do with this instead of brewing our own rope (metaphore :)
08:49:10 <norpan> shapr: it has some annoying "features" for instance if i invite people to a meeting and the reply yes, then if i just change something in the description they have to reply yes again
08:49:13 <shapr> So, how do I create a Haskell context in the Co-op?
08:49:27 <mathewm> anyone know of a good description of how Haskell's monads are related to those in category theory?
08:50:00 <shapr> They're the same, just used for software engineering?
08:50:28 <mathewm> I guess I am a little too dense to get the metaphore...
08:50:45 <shapr> I don't know much about category theory, but I understand Haskell's monads.
08:50:57 <davidhouse> i'd really like to see a paper outlining some basic category theory and showing how the metaphor works out in haskell.
08:51:06 <mathewm> I kinda know how to use monads in haskell, but the descriptions in category theory seem completely different to me
08:51:21 <shapr> davidhouse: Basic category theory - http://www.xp123.com/wwake/dissertation/model.shtml
08:52:09 <davidhouse> shapr, thanks.
08:56:13 <pjd> shapr: thanks for that link
08:56:41 <audreyt> norpan: re wiki:
08:57:01 <audreyt> http://hackage.haskell.org/trac/summer-of-code/ticket/12
09:03:04 <psi> I have a book called "Computational category theory" (introduces the basic concepts and constructions of category theory and their interpretations as computer programs). haven't dared to read it yet, though :)
09:05:59 <davidhouse> this http://www.cse.unsw.edu.au/~pls/thesis-topics/hs-wiki.html looks like a really fun project
09:10:21 <Philippa> it is
09:10:37 <Philippa> I didn't aim for "state of the art" with Flippi, although SyntaxNinja might be about to say I managed it in one regard :-)
09:11:20 <xerox> So you have to tell us which regard now (-:
09:11:49 <Philippa> SyntaxNinja said something about a "pluggable back end". Even I wouldn't have put it quite like that, but hey :-)
09:19:57 <shapr> pjd: sure
09:21:37 <tromp> hi guys
09:23:16 <shapr> hoi tromp 
09:23:37 <tromp> any c programming skills left, shae?
09:23:42 <shapr> A bit, why?
09:24:04 <tromp> wondering how to declare a struct in a library header file
09:24:14 <shapr> I wrote a bit of C a few days ago just to remind myself how those pointer thingies work :-)
09:24:18 <tromp> without revealing contents
09:24:58 <shapr> Can't think of it off the top of my head.
09:25:01 * shapr grabs K&R
09:25:04 <tromp> like how do you define FILE in stdio while hiding contents?
09:25:22 <musasabi> tromp: struct foo;
09:25:45 <vincenz> meaning you can only ever pass around pointers to it
09:25:51 <vincenz> cause it desn't know the size of the structure
09:26:01 <SyntaxNinja> hey all.
09:26:07 <musasabi> typedef struct foo * FOO;
09:26:13 <musasabi> hello SyntaxNinja 
09:26:15 <shapr> hiya SyntaxNinja 
09:26:31 <SyntaxNinja> Philippa still can't get over my pluggable back end... comment.
09:27:03 <xerox> haha.
09:27:06 <musasabi> :-)
09:27:11 <vincenz> lol
09:27:16 <tromp> i want the implementation to include the include file
09:27:48 <tromp> but if the .h file has typedef struct _jtset jtset;
09:28:10 <mauke> _jtset is a reserved identifier
09:28:13 <tromp> then you cannot include that and try to define typedef struct { .. } jtset
09:28:42 <mauke> nope, you have to say struct _jtset {...};
09:28:44 <tromp> is anything with _ reserved?
09:28:55 <mauke> in the global namespace, yes
09:29:18 <mauke> and _[A-Z_]\w* is reserved for all identifiers
09:30:03 <tromp> ok, let's say my .c file includes the corresponding .h file and then defines
09:30:09 <tromp> typedef struct { .. } jtset
09:30:24 <mauke> no, wrong
09:30:29 <mauke> you can't define jtset twice
09:31:21 <tromp> so i have to define a type that already is a pointer to that struct?
09:31:32 <mauke> it sounds like you want typedef struct jtset jtset; in the .h file, and struct jtset {...}; in the .c file
09:32:06 <SyntaxNinja> has anyone gotten strange bounces from the soc-mentors list?
09:32:25 <tromp> but then i cannot include the .h in the .c
09:32:38 <mauke> why not?
09:32:58 <tromp> it says confliting types for jtset
09:33:10 <tromp> double definition
09:33:49 <tromp> i'll just declare a jtsetptr in the .h then...
09:34:49 <mauke> it works here; you must be doing it wrong
09:35:54 <vincenz> tromp: What are you trying to accomplish
09:36:27 <tromp> allowing files to use jtset pointers while hiding struct contents
09:36:27 <vincenz> just put
09:36:32 <vincenz> struct jtset;
09:36:34 <vincenz> in .h
09:36:39 <vincenz> and struct jtset { .... };
09:36:40 <vincenz> in .c
09:36:57 <mauke> yeah, the typedef struct jtset jtset; is optional
09:37:37 <vincenz> tromp: make sure not to pass around a copy anywhere or to call sizeof
09:37:41 <vincenz> only pointers
09:37:47 <tromp> oh, so you cannot have the typedef without the struct jtset;
09:37:56 <vincenz> typedef is just aliasing
09:37:59 <mauke> I think you can
09:38:08 <vincenz> nope
09:38:10 <vincenz> you can not
09:38:13 <tromp> i tried and failed
09:38:14 <mauke> yes, I can
09:38:16 <mauke> I just did it
09:38:17 <vincenz> typedef struct {...\ xxx;
09:38:23 <vincenz> is shorthand for typedefing an anonymous struct
09:38:31 <vincenz> but then the decl is in the .h
09:38:32 <davidhouse> getChar doesn't return as soon as the user types a char, does it? what would i use if i wanted that?
09:38:42 <vincenz> erm, def even
09:38:55 <tromp> change the bugffering mode
09:39:12 <mauke> my code: http://rafb.net/paste/results/4A8Jfg68.html
09:39:17 <vincenz> typedef struct { xskfjsk } xxx; = declare and define a nameless struct and then typedef the internal name to be xxx
09:39:41 <vincenz> mauke: yeah ok
09:39:50 <vincenz> mauke: but then you're still having to declare struct jtset
09:40:03 <vincenz> in this case you declare and define at once
09:40:06 <vincenz> at struct jtset { ...};
09:40:26 <vincenz> you need a declaration
09:40:31 <vincenz> for what tromp wants
09:40:35 <vincenz> and that is missing in that code sample
09:40:50 <mauke> why do I need a declaration?
09:40:57 <vincenz> tromp needs a declaration
09:41:19 <vincenz> anyways I have to get some stuff before the shop closes
09:41:23 <vincenz> got 20 mins left
09:41:53 <mauke> this compiles: http://rafb.net/paste/results/u6lnl511.html
09:42:01 <mauke> (it doesn't link, of course)
09:42:22 <tromp> ok, mauke, that works
09:42:49 <tromp> first time i actually needed struct tags
09:43:03 <tromp> always used anonymous tags before
09:43:13 <tromp> and that way it wldn't work of course
09:45:33 <davidhouse> getChar doesn't return as soon as the user types a char, does it? what would i use if i wanted that?
09:47:39 <davidhouse> like darcs does when recording patches
09:47:48 <davidhouse> @where darcs
09:47:48 <lambdabot> http://darcs.net/
09:50:26 <psi> it has to do with the terminal, I think. you have to do something so line buffering is not used.
09:50:42 <psi> I'm not sure how...
09:51:08 <psi> I know curses has a mode for it.
09:57:17 <psi> hSetBuffering stdin NoBuffering?
09:58:39 <davidhouse> yeah, i figured it out.
09:58:53 <davidhouse> it's that, but you have to set it on stdout as well
09:59:24 <davidhouse> otherwise, for example, putStr "hello" >> getChar will prompt for a char before printing the string
10:00:01 <psi> aha
10:02:15 <dcoutts_> @yarr!
10:02:16 <lambdabot> Yo ho ho, and a bottle of rum!
10:02:37 * dcoutts_ is exhausted after a marathon paractical sign-off session
10:02:45 <vincenz> re
10:04:37 <dcoutts_> dons, yes, appart from FFI Int/CInt I guess some others might need to be Int64 if we're streaming.
10:05:14 <dcoutts_> dons, I think Int64 is enough, no need for Integer
10:05:34 <dcoutts_> dons, and of course on a 64bit arch Int is 64bit anyway
10:06:05 <dcoutts_> but I guess for .Lazy we can stream files bigger than 4GB so we'd need Int64 even on 32bi machines
10:06:25 <mahogny> omg what are you up to now?
10:06:26 <dcoutts_> but for Data.ByteString you're safe with Int
10:06:35 <mahogny> .Lazy?
10:06:40 <dcoutts_> Data.ByteString.Lazy
10:06:44 <mahogny> aha
10:06:59 <dcoutts_> infinite packed byte strings ;-)
10:07:08 <pejo> dcoutts, you use mmap() for streaming files?
10:07:14 <dcoutts_> pejo, nope
10:07:20 <mahogny> *suicidal*
10:07:37 <dcoutts_> you can't mmap bigger than your address space
10:07:46 <dcoutts_> no, you'd just use read
10:07:52 <pejo> dcoutts, yeah, hence the 4Gb limit - and my question.
10:08:06 <mahogny> the limit is usually well below 4gb
10:08:31 <dcoutts_> pejo, so yes for Data.ByteString that's a problem but for Data.ByteString.Lazy we can process arbitrarly large files if we can do it lazily
10:08:45 <dcoutts_> so we'd read using ordinary read
10:08:49 <dcoutts_> not mmap
10:08:59 <davidhouse> is there a function other than error to end execution of your program, right there and then?
10:09:03 <pejo> dcoutts, ah, and some largefile stuff.
10:09:17 <dcoutts_> pejo, right, GHC does that already
10:09:29 <dcoutts_> @type exitWith
10:09:30 <lambdabot> Not in scope: `exitWith'
10:09:37 <davidhouse> @hoogle exit
10:09:37 <lambdabot> System.Exit :: module
10:09:38 <lambdabot> System.exitFailure :: IO a
10:09:38 <lambdabot> System.exitWith :: ExitCode -> IO a
10:09:39 <dcoutts_> @type System.Exit.exitWith
10:09:41 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
10:09:43 <dcoutts_> right
10:09:48 <mahogny> hm. someone should write a package for infinite precision numbers in R :)
10:09:50 <davidhouse> hoogle > type :)
10:09:57 <dcoutts_> indeed
10:10:07 <mahogny> would be easy in haskell
10:10:16 <davidhouse> exitWith 0 would be exitSuccess then.
10:10:30 <dcoutts_> mahogny, pejo: newtype LazyByteStrng = LBS [ByteStrng]
10:10:32 <Cale> @hoogle runST
10:10:32 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
10:10:32 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
10:10:32 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
10:10:43 <Cale> it gets the type of runST wrong though
10:11:11 <dcoutts_> that representation gives us a balance of the performance of ByteStrng with the streaming/lazyness of [a]
10:11:19 <davidhouse> Cale, what is it?
10:11:23 <dcoutts_> at least, it should do
10:11:27 <Cale> @type runST
10:11:28 <davidhouse> ST s a -> s -> a?
10:11:28 <lambdabot> Not in scope: `runST'
10:11:37 <Cale> @type Control.Monad.ST.runST
10:11:38 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
10:11:54 <Cale> (forall s. ST s a) -> a
10:12:17 <davidhouse> why is it such a weird type?
10:12:37 <Cale> so that you can't return STRefs
10:12:40 <davidhouse> and why is it qualified seperately? i.e., why can't it be forall a s. ST s a -> a
10:13:04 <Cale> well, because you could do something like
10:13:30 <Cale> r = runST (newSTRef 0)
10:13:50 <davidhouse> @hoogle ExitCode
10:13:51 <lambdabot> System.Exit.ExitCode :: data ExitCode
10:13:51 <lambdabot> System.Process.getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
10:14:09 <Cale> x = runST (do x <- readSTRef r; writeSTRef r (x+1); return x)
10:14:33 <Cale> then x will evaluate to something different each time (so long as it's not memoised)
10:14:45 <Cale> it breaks referential transparency
10:14:56 <dcoutts_> the forall prevents sharing of refs outside of that run
10:15:13 <Cale> @type newSTRef
10:15:14 <lambdabot> Not in scope: `newSTRef'
10:15:21 <Cale> @type Data.STRef.newSTRef
10:15:22 <lambdabot> forall a s.
10:15:22 <lambdabot>         a -> GHC.ST.ST s (GHC.STRef.STRef s a)
10:15:50 <Cale> the s tag on the STRef is the same as the one for the ST monad it's in
10:16:23 <Cale> but since the result type of runST can't depend on s, you can't return an STRef
10:16:31 <Cale> (or anything containing one, for that matter)
10:16:34 <davidhouse> i see.
10:17:01 <davidhouse> well, for things outside of ST, hoogle > type :)
10:17:16 <dcoutts_> and all together that allows you to use mutable refs in pure code
10:17:24 <dcoutts_> because the refs can't escape
10:17:29 <Cale> outside of ST and other things which need higher rank quantification :)
10:17:32 <dcoutts_> it's all rather neat
10:23:53 <mahogny> xerox, know the stats of SoC?
10:24:07 <xerox> mahogny: no new official news so far
10:24:10 <mahogny> ok
10:25:01 * psi is getting anxious
10:25:08 <davidhouse> it's very tense.
10:26:20 <dcoutts_> there's been plenty of actvity on the soc-mentors list
10:26:24 <mahogny> some of my students have already got going so it's not very tense at all. if they become official SoC projects, then that's just a bonus
10:26:49 <mahogny> soc-mentors? is that some google group or what?
10:27:01 <dcoutts_> the haskell soc mentors list
10:27:30 <davidhouse> mahogny: mailing list.
10:27:31 <mahogny> hrm. did I miss something? where is that list?
10:27:37 <dcoutts_> it's private!
10:27:41 <dcoutts_> ;-)
10:27:43 <mahogny> lol
10:28:13 <dcoutts_> we're discussing the applications and ranking them etc
10:29:13 <psi> mahogny: a very cool bonus! I have started a bit, too, but other people have applied for the same thing.
10:29:54 <psi> if they get it it would suck a bit, otherwise I could still do it whatever happens
10:30:00 <musasabi> "Why we should choose A over B" really better to do with technical issues only, with an open group there would be a lot more social pressure in the selections.
10:30:09 <mahogny> psi, learn where they live. plant a bomb
10:30:16 <psi> :P
10:34:05 <musasabi> That is quite easy with Google.
10:41:03 <palomer> in the expression (\f -> t) A B, is the head-most redex always the first to be reduced?
10:48:42 <xerox> > 2+2
10:48:42 <xerox> palomer: I was asking myself that too sometime
10:48:43 <lambdabot> 4
10:51:52 <davidhouse> you know what would be a nice combinator?
10:52:06 <davidhouse> an equivalent of when that took an m Bool as the first parameter.
10:52:32 <davidhouse> whenM pM a = do p <- pM; when p a
10:53:03 * palomer would have to get used to M first
10:53:09 <davidhouse> @hoogle m Bool -> m () -> m ()
10:53:20 <palomer> s/M/when
10:53:29 <davidhouse> > 2 + 2
10:53:29 <palomer> ok guys, I have this type, called Term
10:53:36 <davidhouse> lambdabot's dead.
10:53:42 <palomer> it takes one type parameter
10:53:50 <lambdabot> No matches, try a more general search
10:53:52 <lambdabot> 4
10:53:58 <palomer> and I have a function Term (a -> b) -> Term a -> Term b
10:54:04 <palomer> and I'd like to turn Term into an Arrow
10:54:07 <palomer> how woud I do this?
10:54:32 <davidhouse> palomer: newtype Term a = Term a?
10:55:11 <xerox> Quite.
10:55:21 <palomer> well, it would be newtype TermM a b = Term (a -> b)
10:55:31 <palomer> but I'm trying to find the instance for TermM
10:55:43 <palomer> (the arrow instance, that is)
10:56:33 <davidhouse> newtype TermM a b = Term { unTerm :: a -> b }
10:56:47 <davidhouse> err, disregard that.
10:57:06 <davidhouse> instance Arrow Term where pure = Term; (Term f) >>> (Term g) = Term (g . f)
10:57:22 <palomer> I'm using GADTs
10:57:27 <palomer> so f and g are not functions
10:57:38 <davidhouse> you just said they are. Term (a -> b).
10:57:52 <palomer> data Term where A :: Term (int -> bool)
10:58:03 <palomer> is a a function?
10:58:52 <davidhouse> eurgh. have to make this complicated. :)
10:58:55 <palomer> anyways
10:59:00 <palomer> I already have a function of that type
10:59:16 <palomer> term (a -> b) -> term a -> term b <--this is what we want?
10:59:17 <palomer> I have it
10:59:40 <davidhouse> can it be data Term where A :: Term { unA :: Int -> Bool }?
10:59:58 <davidhouse> apart from that would be hideoue.
11:00:01 <davidhouse> *hideous.
11:00:27 <davidhouse> and more importantly not fix the problem
11:01:01 <palomer> oh, wait, I'm an idiot
11:01:19 <davidhouse> ?
11:02:28 <palomer> a b c -> a c d -> a b d translates too Term (b->c) -> Term (c -> d) -> Term ( b -> d)
11:02:54 <palomer> ahh wait, I don't quite have it
11:03:14 <davidhouse> could you pastebin some more code?
11:03:21 <davidhouse> i think your Term definition is a little off.
11:03:54 <shapr> @yow !
11:03:55 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR
11:03:55 <lambdabot> REGIONS!
11:03:56 <palomer> I should put more thought into it
11:04:07 <palomer> my definition is off?
11:04:13 <palomer> @hoogle >>>
11:04:14 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
11:05:12 <palomer> bbl
11:09:18 <shapr> hiya jethr0_
11:17:47 <SamB> hmm, I wonder if IE can have tabs ... without a wrapper...
11:19:13 <mahogny> why would you want to use IE?
11:21:54 <hyrax42> hrmmm
11:22:00 <SamB> hmm. well, see, Inform 7 embeds it
11:22:03 <hyrax42> shouldn't I be able to eta reduce here
11:22:07 <hyrax42> parseNumber = (many1 digit) >>= \str -> return $ (Number . read) str
11:22:11 <hyrax42> in the second arg to >>=
11:22:42 <hyrax42> compiler complains if I try
11:22:43 <SamB> I would be happy to use firefox instead, if it can perform the same function ;-)
11:22:51 <Cale> hyrax42: it's the $
11:23:05 <hyrax42> d'oh
11:23:06 <xerox> parseNumber = many1 digit >>= return . Number . read
11:23:19 <hyrax42> ohhh right
11:23:22 <hyrax42> I see it now
11:23:25 <hyrax42> thanks
11:23:28 <Cale> see what I mean about $ being slightly evil? :)
11:23:32 <hyrax42> yeah
11:23:40 <hyrax42> it looks so helpful
11:23:46 <xerox> parseNumber = liftM (Number . read) (many1 digit) -- maybe?
11:23:50 <hyrax42> yeah, that's one
11:23:57 <hyrax42> and a do notation one as well
11:24:00 <hyrax42> :)
11:24:21 <xerox> 'liftM' is ugly, tho (-:
11:24:34 <audreyt> fmap :)
11:24:41 <Cale> (.) has better properties with respect to refactoring, so I try to use it as much as possible -- to avoid brackets, you can put a $ right near the end
11:24:53 * xerox nods
11:25:08 <audreyt> fmap fits my brain much better. I wonder why.
11:25:22 <davidhouse> because it's preluded.
11:25:23 <xerox> audreyt: that 'map' is so tied to lists in my mind... hmpf.
11:25:33 <davidhouse> i like liftM.
11:25:59 <xerox> I think map should just have the most general type.
11:26:11 <mahogny> ghc 6.4.4-ubuntu dying on compiling FPS from darcs, is that normal?
11:26:25 <audreyt> there is a 6.4.4?
11:26:36 <mahogny> that's what it says
11:26:54 <Cale> xerox: me too
11:27:00 <audreyt> Ubuntu people are so advanced.
11:27:57 <mahogny> an automatic update screen appeared, and I didn't bother and just klicked "upgrade". really advanced user ;)
11:28:05 <davidhouse> here's a quick question for all you category theorists out there:
11:28:07 <xerox> Cale: did you see those <http://video.google.com/videosearch?q=Bay+Area+Discrete+Math+Day> ?
11:28:55 <davidhouse> is an instance of Functor really a functor in the category-theoretic sense? i thought a function was a mapping between categories, i.e. in actual fact fmap is a functor and Functor should be renamed Functorable
11:29:13 <Cale> xerox: no, I haven't
11:29:46 <xerox> Cale: tell me what you think if you have some time (-:
11:29:50 <Cale> davidhouse: yes it is
11:30:07 <Cale> davidhouse: The type constructor is the mapping on objects
11:30:17 <Cale> fmap is the part of the functor which acts on the arrows
11:31:17 <davidhouse> hmm.
11:31:35 <davidhouse> fmap acts on the arrows?
11:31:41 * davidhouse would expect it to act on the objects
11:31:51 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
11:32:15 <davidhouse> ah.
11:32:48 <davidhouse> an an arrow is haskellily represented by... ?
11:32:57 <Cale> a function
11:32:59 <davidhouse> (aside, what a fantastic word i just made up :))
11:33:06 <Cale> hehe
11:33:12 <Cale> Objects are types
11:33:19 <Cale> Arrows are Haskell functions
11:33:49 <davidhouse> i see. so fmap takes an arrow in one category and returns it in another.
11:33:57 <davidhouse> and categories themselves aren't represented.
11:34:07 <Cale> or possibly the same category, in this case, it's the same category
11:34:26 <Cale> A better name for Functor would be Endofunctor
11:34:44 <Cale> but that's possibly getting overly technical :)
11:36:30 <davidhouse> and Functor is the part of the functor that acts on the objects (types), because it has kind * -> *, i.e. it takes one object (type) and returns another.
11:36:39 <davidhouse> again, the change in category isn't explicity mentioned.
11:36:50 <Cale> there is no change in category
11:37:09 <Cale> instances of Functor are functors  C -> C, where C is the category of Haskell types.
11:38:40 <davidhouse> @kind Functor
11:38:41 <lambdabot> Class `Functor' used as a type
11:38:45 <davidhouse> oops.
11:38:54 <davidhouse> right, yes, i think i get it.
11:39:29 <davidhouse> it doesn't seem a very general implementation of a functor though.
11:39:45 <Cale> well, it's the sort of Functor you're usually concerned with here
11:40:18 <davidhouse> yes.
11:40:26 <Cale> though it would be nice to consider subcategories of the category of Haskell types given by class constraints
11:41:47 <davidhouse> thanks, Cale.
11:42:02 <Cale> any time :)
12:02:57 <norpan> audreyt: still here?
12:04:38 <norpan> audreyt: i saw your comment
12:17:50 <davidhouse> the user guides for GHC and haddock seem to be quite similar. is it just a set of common stylesheets, or are they generated from some other format?
12:18:11 <Cale> I think they're generated
12:18:27 <norpan> it's docbook
12:18:31 <Cale> maybe docbook?
12:18:33 <Cale> yeah
12:18:38 <davidhouse> @where docbook
12:18:39 <lambdabot> I know nothing about docbook.
12:18:45 <norpan> @google docbook
12:18:47 <lambdabot> http://www.docbook.org/
12:18:51 <davidhouse> is this a haskell thing?
12:19:05 <davidhouse> it seems not.
12:19:25 <norpan> nope, it's xml
12:19:32 <ValarQ> xslt i believe
12:21:28 <davidhouse> in haddock, can @...@ be used to display inline code?
12:21:35 <davidhouse> so, for example, can i say something like:
12:21:37 <Cale> It's SGML
12:21:46 <davidhouse> -- | @show@ isntance for Foo
12:22:57 <norpan> sgml, xml, who cares :)
12:27:21 <ihope_> @type sum
12:27:22 <lambdabot> forall a. (Num a) => [a] -> a
12:27:30 <ihope_> > sum (replicate 1000000 1)
12:27:31 <lambdabot> Exception: stack overflow
12:27:40 <ihope_> > foldr (+) 0 (replicate 1000000 1)
12:27:42 <lambdabot> Exception: stack overflow
12:27:50 <ihope_> > foldr' (+) 0 (replicate 1000000 1)
12:27:51 <lambdabot>  Not in scope: `foldr''
12:28:20 <kombinator> > foldl' (+) 0 (replicate 1000000 1)
12:28:21 <lambdabot> 1000000
12:28:47 <ihope_> Yep, that works...
12:33:43 <norpan> i've now read part of the finger tree article and it seems so unelegant in some manner
12:36:39 <dcoutts_> norpan, really?
12:36:44 <dcoutts_> how so
12:37:31 <norpan> so many cases
12:37:41 <norpan> node1 to node4
12:38:53 <norpan> but maybe i just need to get it
12:39:14 <dcoutts_> I think you'd find avl & red-black trees just as bad.
12:39:41 <norpan> maybe
12:39:54 <norpan> but i get those :)
12:40:01 <norpan> and splay trees :)
12:40:46 <norpan> but for storing bytestrings, to get efficient indexing we need to store length in concat nodes
12:41:11 <norpan> maybe this can be incorporated in the Seq
12:41:44 <sjanssen> norpan: don't bytestrings already store the length?
12:42:02 <norpan> they do, but then you need to recurse down to all of them and add
12:42:16 <norpan> maybe that's not so bad after all
12:42:55 <Cale> xerox: I liked the talk on the colouring torus of a graph.
12:42:58 <dcoutts_> you want Seq's of ByteStrings?
12:43:08 <xerox> Cale: I've got it on the iPod, will watch tomorrow.
12:43:09 <norpan> http://svn.openfoundry.org/pugs/src/Data/ByteString/Seq.hs
12:43:10 <shapr> I like finger trees, they're good at many different things.
12:43:15 <dcoutts_> norpan, is this for the utf8 stuff?
12:43:15 <norpan> audreyt wanted it
12:43:29 <norpan> http://hackage.haskell.org/trac/summer-of-code/ticket/12
12:43:47 <norpan> no, not for utf8
12:43:58 <norpan> for efficient strings
12:43:59 <TOM-> hi all
12:44:14 <TOM-> is there anyone who saw Dendio before ?
12:44:23 <dcoutts_> norpan, but not for lazy strings
12:44:34 <sjanssen> norpan: what is Data.Seq?
12:44:43 <norpan> Data.Sequence right?
12:44:55 <dcoutts_> it's an implenetation of finger trees to represent sequences
12:45:01 <TOM-> is there anyone who saw Dendio before ?
12:45:02 <sjanssen> your source says Data.Seq
12:45:30 <norpan> well it's not my source, but yes it seems like that, but that's the same i supose
12:45:46 <norpan> the data type is called Seq anyway
12:46:07 <norpan> dcoutts_: yes, not for lazy strings, as Seq is strict
12:46:53 <dcoutts_> but you want to have Seq's of ByteStrings
12:47:01 <norpan> audreyt wants it :)
12:47:05 <dcoutts_> so what opes go faster there? concat
12:47:18 <norpan> i would suppose all ops
12:47:27 <xerox> dcoutts: and substring searching
12:47:31 <norpan> lists are like degenerated trees
12:47:39 <sjanssen> I don't think substring searching would be any faster
12:47:39 <xerox> dcoutts: and indexing I'd say
12:47:48 <sjanssen> nope, indexing is already O(1)
12:47:49 <xerox> Ah, you're not talking about ropes?
12:47:55 <sjanssen> only concatenation is faster
12:48:14 <norpan> we should clear up the concepts here
12:48:17 <sjanssen> indexing is actually slightly slower, O(log n) where n is the number of chunks
12:48:17 <Spark> i hate type systems that generate a set of constraints
12:48:30 <TOM-> hi xerox
12:48:32 <dcoutts_> Spark, I love 'em :-)
12:48:37 <xerox> Spark: you don't like type classes?
12:48:37 <norpan> it makes sense to have a collection of bytestrings
12:48:39 <Spark> its like being slowly shot in the face with burning projectile snails
12:48:43 <dcoutts_> heh
12:48:46 <xerox> Hello TOM- 
12:48:47 <norpan> and one alternative is your [ByteString]
12:48:54 <norpan> another is Seq ByteString
12:48:56 <TOM-> do you remember Dendio ?
12:49:01 <xerox> TOM-: sure I do.
12:49:05 <TOM-> nice
12:49:07 <TOM-> it was me
12:49:11 <TOM-> this is my real nickname
12:49:12 <xerox> TOM-: welcome back!
12:49:14 <dcoutts_> Spark, what type system is that one?
12:49:16 <TOM-> thanks
12:49:16 <Spark> dcoutts_: for that kind of stuff i prefer using analysis, to do the same thing
12:49:25 <xerox> TOM-: how's code?
12:49:25 <Igloo> TOM-: I think you have me confused with lambdabot
12:49:25 <norpan> and a third one is my suggestion Str = Concat Int Str Str | Leaf ByteString
12:49:38 <TOM-> yes , i think igloo :))))
12:49:39 * xerox laughs in Igloo's direction
12:49:49 <norpan> maybe we should move this to #haskell-overflow
12:49:53 <sjanssen> norpan: finger tree's should be as good or better
12:50:01 <xerox> Right (-:
12:50:07 <norpan> sjanssen: better than what?
12:50:14 <TOM-> i think i did well xerox
12:50:21 <sjanssen> norpan: than your binary tree data type you suggested
12:50:29 <TOM-> but we don't have enough time to practise on Haskell
12:50:32 <Spark> dcoutts_: i'm reading http://www.cs.umd.edu/~polyvios/publications/transact06.pdf
12:50:33 <norpan> except that i store the total length in the concat node
12:50:46 <xerox> TOM-: practice on your own, if you got enough interest it is much fun
12:50:59 <TOM-> absolutely
12:51:01 <sjanssen> norpan: the finger tree implementation by Paterson/Hinze stores the total length also
12:51:06 <norpan> no
12:51:07 * mahogny would almost like to serialize entire functions :(
12:51:16 <dcoutts_> Spark, looks rather useful
12:51:17 <norpan> it doesn't store the string length, it stores the tree size
12:51:28 <TOM-> i have another project and this one is very interesting and important too : Parsers
12:51:31 <xerox> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf <- ?
12:51:44 <xerox> TOM-: great, Haskell is very good at that.
12:52:00 <TOM-> but i think we have to do it in C or C++
12:52:07 <TOM-> how can i make an implementation of parsers in C or C++ ? is there a real code ?
12:52:10 <norpan> sjanssen: but the elements in the tree here is not chars, it's bytestrings of various lengths
12:52:12 * xerox Eeeks
12:52:24 <norpan> so i want to store the sum of their lengths
12:52:38 <sjanssen> norpan: you've seen http://www.soi.city.ac.uk/~ross/papers/FingerTree.html, right?
12:52:52 <norpan> yes
12:53:06 <norpan> but as i said, the elements are not chars, but have various lengths
12:53:16 <norpan> i want to store the sum of their lengths somewhere
12:53:22 <norpan> otherwise indexing will be tough
12:53:22 <sjanssen> check out the Measured class in Data.FingerTree, you instance that class for ByteString, and things will work correctly
12:53:33 <norpan> measured?
12:53:40 <norpan> i haven't gotten that far :)
12:53:48 <norpan> i'll check it out
12:54:23 <TOM-> i know it is not related with haskell but can you help me about my project xerox ?
12:54:24 <norpan> is that in the Data.Seq too?
12:54:43 <sjanssen> norpan: yeah.  in Data.Seqeunce you have something like "newtype Sequence a = FingerTree (Singleton a)", singleton implements measured and always returns 1
12:54:49 <xerox> TOM-: I'm not sure. You'd have better luck asking on #c or #c++ or whatever are called, I think.
12:55:00 <TOM-> ok
12:55:05 <TOM-> i am there too
12:55:06 <sjanssen> norpan: I don't know.  Data.Seq must be some pugs fork of this code
12:55:18 <TOM-> but they are busy or whatever
12:55:26 <norpan> Data.Sequence is in the haskell libraries
12:56:32 <sjanssen> norpan: yeah, and Data.FingerTree exposes the internals you need to build your data structure
12:56:51 <sjanssen> (I've submitted a proposal for SoC to do this, btw)
12:57:00 <norpan> i don't have Data.FingerTree
12:57:25 <norpan> i have Data.Sequence
12:58:07 <sjanssen> the source is available at that URL.  You either yank that, or you might have to do a copy and paste job from Data.Seq
12:58:56 <norpan> well Data.Sequence contains the FingerTree data type if that's what you mean
12:59:18 <sjanssen> it doesn't export it though
12:59:26 <norpan> no it doesn't seem so
12:59:41 <norpan> and no mention of Measured
13:00:12 <sjanssen> the name might be different, it's there somewhere
13:00:26 <sjanssen> might be Sized or Sizable
13:00:27 <norpan> but if it's possible to use that data structure then it's much better than cooking your own of course
13:00:37 <sjanssen> exactly
13:00:40 <norpan> yeah, sized
13:00:44 <norpan> great
13:01:24 <norpan> ok, it will actually store the size
13:01:56 <araujo> Hi around here
13:02:01 <norpan> then it seems very good
13:02:23 <norpan> but it's still strict
13:02:32 <norpan> could you make it lazy?
13:02:34 <xerox> Cale: do you have any pointers about what and how make Cellular Automata unpredictable?
13:02:40 <sjanssen> norpan: I don't think so
13:02:45 <norpan> or does the fingertree algorithm require strictness
13:03:02 <sjanssen> pretty tricky to build a balanced tree entirely lazy
13:03:08 <norpan> yeah
13:03:16 <norpan> then we need a lazy version also
13:03:30 <dcoutts_> why?
13:03:33 <norpan> and [ByteString] is one suggestion and some tree like structure is another
13:03:39 <sjanssen> norpan: like dcoutts' [ByteString]?
13:03:43 <norpan> yes
13:03:56 <sjanssen> I don't think trees are the way to go for laziness
13:04:01 * dcoutts_ agrees
13:04:03 <norpan> why?
13:04:36 <dcoutts_> I don't see how it'd work, but perhaps it could be done
13:04:41 <sjanssen> norpan: how can you balance it if you don't look at the whole input?
13:04:50 <norpan> you don't have to balance it
13:05:07 <norpan> you don't balance lists do you?
13:05:29 <sjanssen> no, but without balancing, what's the point?  you've just degenerated to a linked list anyway
13:05:42 <Excedrin> ubalanced lazy tree
13:05:43 <dcoutts_> except that you get O(1) cat
13:05:44 <norpan> you have O(1) concat
13:05:53 <sjanssen> ah, yes
13:06:33 <norpan> but with lists and laziness you have O(1) concat too, conceptually :)
13:06:47 <norpan> since you pay for the concat when you index
13:07:27 <mahogny> anyone remember the name of the haskell library that makes data structures ACID by serialization? similar libraries exist for java etc but I forgot all names :P
13:07:47 <sieni__> mahogny: what do you mean?
13:08:06 <sieni__> mahogny: like "software transactional memory"-stuff?
13:08:18 <norpan> well see how the [ByteString] works out
13:08:26 <mahogny> sieni__, no. but it can be used to write custom databases
13:09:33 * mahogny found
13:10:08 <norpan> also, even if you want to be able to use the tree lazily, when you do know the size you can balance
13:12:05 <TOM-> i have to go now
13:12:11 <TOM-> take care xerox and everyone
13:16:58 <nomeata> Hi. Is there a way to use ":t" to find out the type of a function defined in the where of a "global" function?
13:17:42 <norpan> nomeata: i don't think so, but you can move it outside the where clause
13:17:42 <dcoutts_> nomeata, no, you'd need to lift it out of the where and make it top level
13:18:42 <nomeata> which is a bit hard if it uses other variables local to the function with the where. but thanks for the info
13:19:03 <norpan> you can also put a type there
13:19:16 <norpan> if the function is f then you can do f :: a
13:19:29 <norpan> and ghci will tell you which type a doesn't match :)
13:20:28 <mahogny> irc really is one evil protocol
13:20:43 <norpan> it is?
13:20:47 <mahogny> yeah
13:21:06 <mahogny> 100% ad hoc design
13:21:06 <hyrax42> ReadS a === [(a, String)]?
13:21:06 <norpan> protocols are not evil, people are evil
13:21:16 <mahogny> norpan, I guess would be the one exception
13:21:19 <mahogny> +this
13:21:44 <hyrax42> gah
13:21:47 <hyrax42> must not ask
13:21:54 <hyrax42> before scrolling down 2 lines
13:22:02 <norpan> that's right
13:22:36 <hyrax42> it is strange
13:22:57 <hyrax42> also it's apparently String -> [(a, String)]
13:22:59 <hyrax42> why the list
13:24:50 <norpan> sjanssen: Seq seems like a great data structure
13:24:53 <monochrom> To accomodate for these possiblities: parse error (use []), ambiguous parses (use list of length > 1)
13:25:44 <monochrom> People are the root of all evils.
13:25:44 <hyrax42> ah
13:25:55 <sieni__> monochrom: you misspelled "accommodate"
13:26:14 <norpan> ReadS could return a Monoid instead
13:27:10 <monochrom> Give the ReadP library a consideration.
13:27:43 <norpan> hmmm is that Parsek?
13:27:55 <norpan> Parsek is very good
13:28:03 <norpan> i haven't been following the latest news
13:28:10 <monochrom> I heard yes, very similar if not entirely same.
13:28:27 <monochrom> ReadP comes with ghc.
13:28:28 <Cale> Parsek is ReadP with a more Parsec-like interface
13:28:31 <norpan> it sounds like it by the description :)
13:28:46 <Cale> Parsek also has some interesting ways to evaluate parsers
13:30:02 <the_lord> Hi!
13:30:06 <Cale> hi
13:30:12 <the_lord> someone with experience in ALEX?
13:30:22 <norpan> Cale: it has but you only use the one which seems to be in ReadP :)
13:30:41 <mahogny> ok, ideas wanted. I have a server running and I want a web application to interface it (say php). is there an *easy* way to do it?
13:30:55 <mahogny> *server=daemon
13:34:34 <monochrom> What is a "web application"?  From the web server point of view, is it just another cgi script?
13:34:48 <mahogny> you could say
13:35:23 <monochrom> And this cgi script needs to talk to the daemon.  I think it's socket programming again.
13:35:25 <palomer> hrmph
13:35:32 <palomer> someone should write an article on the continuation monad
13:35:34 <palomer> so I can get it
13:35:49 <mahogny> monochrom, yeah. it turns out to be an entirely new project if one wants to be able to read anything in the servers memory
13:36:05 <mahogny> palomer, "the poor mans concurrency monad" is good
13:36:21 <monochrom> OTOH, not knowing what I am saying, you may like to consider the recent "web without tiers" paper.
13:36:32 * mahogny googles
13:36:53 <monochrom> LtU mentioned it within the last 14 days
13:37:36 <mahogny> hm. it doesn't apply here. 
13:37:43 <monochrom> Probably another Wadler production too.
13:37:57 <monochrom> Alright, I knew I didn't know what I was saying. :)
13:38:01 <mahogny> :)
13:38:27 <mahogny> well, I consider putting a web server into the daemon instead. that solves the problem by creating a new one :P
13:38:46 <mahogny> or I just go with my old solution :/
13:38:57 <monochrom> There are too many web servers.
13:39:06 <mahogny> indeed
13:39:12 <mahogny> but no good ones yet
13:39:19 <palomer> A poor man's concurrency monad seems to talk about a monad transformer
13:39:52 <mahogny> palomer, well, it can lift IO but it's essentially a nice example of what you can do with CPS
13:39:57 <monochrom> palomer: if one knows continuations, doesn't one easily pick up the continuation monad?
13:41:27 <palomer> but what's the current continuation?
13:41:46 <mahogny> palomer, huh? rephrase
13:42:14 <palomer> the (a -> r) part of data Cont = Cont {runCont  :: ((a->r)->r)} ?
13:42:40 <xerox> It is the continuation!
13:42:57 <norpan> because it's a monad you just do normal monadic operations
13:43:04 <palomer> I have to admit, I'm very confused when it comes to Cont
13:43:13 <palomer> yes, but what does callCC do?
13:43:29 <palomer> how would I use it?
13:43:32 <palomer> there's the rub
13:43:58 * mahogny doesn't like the plain haskell98 continuation monad
13:44:02 <palomer> (and how is return defined?)
13:44:08 <ValarQ> palomer: that "All about monads" doc had some Cont examples
13:44:26 <Cale> @type Control.Monad.Cont.callCC
13:44:27 <lambdabot> forall (m :: * -> *) a b.
13:44:27 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
13:44:27 <lambdabot>           ((a -> m b) -> m a) -> m a
13:44:28 <xerox> monochrom: mind to give us an explanation of Cont? (-:
13:44:33 <ValarQ> thought i must admit im having problems wrapping my head around it myself :/
13:44:45 <mahogny> those examples don't make much sense. I think the paper I gave makes much more sense
13:45:21 <monochrom> I don't know continuations.  I don't know the continuation monad.
13:45:38 <mahogny> palomer, for the original Cont monad, return is essentially "id"
13:45:55 <palomer>  return a       = Cont $ \k -> k a  
13:46:13 <norpan> exactly
13:46:42 <palomer> that's not id
13:46:46 <palomer> \k -> a k is id
13:46:58 <mahogny> palomer, id (\k -> k id). there you go :)
13:47:00 <palomer> (this looks mightily like CPSification)
13:47:08 <norpan> it's not id, it's ($)
13:47:20 <norpan> or rather flip ($)
13:47:25 <mahogny> ehr. last id=a
13:48:49 <Cale> it's flip id :)
13:49:10 <norpan> how can you flip id
13:49:19 <Cale> @type flip id
13:49:20 <lambdabot> forall b c. b -> (b -> c) -> c
13:49:25 <Cale> easily :)
13:49:27 <norpan> oh, that way
13:49:54 <palomer> this totally looks like CPSification
13:50:05 * mahogny loves CPS
13:50:05 <xerox> Agreed.
13:50:16 <xerox> Why?
13:50:16 <Cale> so what is return doing?
13:50:28 <norpan> return applies the continuation on the value
13:50:37 <mahogny> xerox, me?
13:50:38 <palomer> return takes an apple and puts it in a box?
13:50:40 <palomer> :P
13:50:42 <Cale> It's taking a value, and turning it into a function which takes a question about the value, and supplies an answer to that question.
13:50:45 <xerox> mahogny: yes.
13:51:08 <Cale> this is the sort of box which we're talking about
13:51:17 <mahogny> xerox, easy to build high-performance applications. very suitable for implementing scripting languages for games etc
13:51:55 <palomer> so m a is an object for which you ask a question about a and it supplies an answer, right?
13:52:20 <Cale> (Cont r a) is a sort of box where you supply a question of type a -> r, and it will answer it with an r.
13:52:37 <Cale> If r is Bool, for instance, then you can ask only True/False questions.
13:52:46 <norpan> and callCC is for accessing the question from within the monad?
13:52:57 <xerox> Cale: so the 'a' is right in, and it isn't polymorphic anymore?
13:53:49 <dcoutts_> dons, ping me when you're about
13:53:52 <Cale> xerox: I'm thinking about a particular 'a'
13:54:17 * xerox thinks more
13:54:30 <Cale> so for Cont Bool Int, say
13:54:35 <dcoutts_> dons, we need to tune the Arbitrary instance for ByteString.Lazy because it's not finding bugs that I deliberately introduce
13:54:40 <Cale> you can ask questions about the Int
13:54:44 <dcoutts_> dons, eg finding the bugs in split is hard
13:54:52 <Cale> which are yes/no type questions
13:55:14 <xerox> So the a can't change in a given do block.... right
13:55:21 <palomer> maybe we should fix r to Bool for now
13:55:24 <Cale> no, the a can change
13:55:26 <dcoutts_> dons, because all the corner cases need the splitting char to appear in the string and do so one chunk boundaries.
13:55:30 <Cale> the r can't
13:55:33 <xerox> Uh!  I'm missing how.
13:56:03 <dcoutts_> dons, when I deliberately introduce bugs I only occasionally find then with the current QC checks. That's not inspiring :-)
13:56:09 <Cale> @type (>>=)
13:56:10 <lambdabot> forall (m :: * -> *) b a.
13:56:10 <lambdabot>    (Monad m) =>
13:56:10 <lambdabot>    m a -> (a -> m b) -> m b
13:56:14 <Cale> like that :)
13:56:16 <xerox> Ah-ha.
13:56:20 <xerox> Cheater :-P
13:56:48 <dcoutts_> dons, on the plus side I think I do have a working lazy split. Which is actually rather hard I think. It's taken me ages to work something out.
13:57:36 <palomer> ok, how does bind work with our little linguistic metaphor?
13:59:00 <xerox> @fptools Control.Monad.Cont
13:59:00 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
13:59:55 <palomer> http://www.nomaware.com/monads/html/contmonad.html
14:00:16 <xerox> What's the purpose of the Functor instance of Cont?
14:00:54 <norpan> all monads are functors :)
14:00:58 <norpan> or can be
14:01:05 <xerox> I mean purpose in a pragmatic way
14:01:13 <norpan> oh
14:01:19 <norpan> to bea ble to do fmap?
14:01:58 <palomer> why isn't  bind like so: (Cont c) >>= f = f $ (runCont c) id ?
14:04:00 <xerox> @type let run = undefined :: ((a -> r) -> r) in \c f -> f $ (run c) id
14:04:01 <lambdabot> ((a -> r) -> r) in \c f -> f $ (run c) id :: forall a
14:04:01 <lambdabot>                          b
14:04:03 <lambdabot>                          a1
14:04:05 <lambdabot>                          a2.
14:04:07 <lambdabot>                        (a1 -> (a2 -> a2) -> a)
14:04:09 <lambdabot>                        -> (a -> b)
14:04:11 <lambdabot>                        -> b
14:04:32 <palomer> err, make that (Cont c) >>= f = f $ c id
14:04:46 <Cale> (x >>= f) c = x (\ d -> f d c)
14:05:03 <palomer> my function has the right type and it seems to do the right thing
14:05:06 <Cale> removing the extra newtype boxes
14:05:09 * mahogny wonders why the heck HSQL <- HToolkit
14:05:10 <xerox> @type (\c f -> f $ c id)
14:05:11 <lambdabot> forall a b a1.
14:05:11 <lambdabot>         ((a1 -> a1) -> a) -> (a -> b) -> b
14:06:18 <palomer> oh, that's right
14:06:41 <Cale> so basically, it asks the box on its left the question which given a value of type a, passes that value to the function, getting a question/answer box for values of type b
14:06:58 <Cale> which it then passes its own question to
14:07:08 <Cale> (the one it's eventually given)
14:07:20 <Cale> It's a little bizarre :)
14:07:44 <palomer> passes the value to the function?
14:07:53 <palomer> the function is of type a -> m b
14:07:57 <palomer> the answer will have type r
14:07:58 <Cale> yeah
14:08:17 <palomer> a != r
14:08:19 <Cale> we're not working with the answers directly here
14:08:35 <palomer> ahh
14:08:43 <Cale> (x >>= f) c = x (\ d -> f d c)
14:10:25 <palomer> but wait
14:10:29 <palomer> you're asking a question about b
14:10:35 <palomer> (for the return value of bind)
14:11:07 <palomer> how can you pass it to the left most m a?
14:12:09 <palomer> @type (>>=)
14:12:10 <lambdabot> forall (m :: * -> *) b a.
14:12:10 <lambdabot>    (Monad m) =>
14:12:10 <lambdabot>    m a -> (a -> m b) -> m b
14:12:56 <palomer> so you take the result of a >>= f takes a question about an element of b and does what with that question?
14:13:29 <palomer> that was so ungrammatical it's not funny
14:13:51 <monochrom> haha
14:14:21 <ruffneck> I guess i it would be easy to count monthly downpayment of a loan with haskell ?
14:15:08 <palomer> you have a question about an element of b, what the blazes can you do with it?
14:15:15 <palomer> m a takes questions about elements of a
14:15:21 <palomer> and a -> m b takes elements of a
14:16:03 <norpan> i see it like this: Cont r a is a computation that eventually will produce r, but right now all you can get is an a
14:16:12 <norpan> it that a good picture?
14:16:49 <palomer> err no
14:16:55 <norpan> and so go from a to b you bind
14:16:59 <palomer> you can assume that r is Bool if you like
14:17:12 <palomer> r doesn't come into the picture
14:17:21 <norpan> and eventually b will be your desired type and then you'd runCont id :)
14:18:03 <norpan> and by callCC you can access the continuation at that point and inside the callCC block you can return to it if you like
14:18:52 * palomer slaps norpan with a large chair
14:19:07 <norpan> gee that hurts
14:19:14 <palomer> prefer trouts?
14:20:39 <norpan> i prefer not being slapped at all actually
14:22:06 <palomer> chairs or trouts, take your pick
14:22:46 <monochrom> My analogy has corrupted palomer's mind :)
14:23:08 <palomer> the question analogy?
14:23:11 <palomer> it boggles me
14:23:13 <monochrom> yeah heh
14:23:19 <palomer> I don't think it can work with bind
14:25:28 * monochrom has implemented the Ackermann function.
14:25:37 * monochrom kills his computer with "ack 5 5"
14:25:58 <palomer> that's a pretty big number, fella
14:26:21 <palomer> gah! this question analogy is driving me nuts
14:26:41 <norpan> it's a mind virus
14:26:43 <xerox> Might someone restate it?
14:26:45 <norpan> it will eat your brain
14:27:55 <palomer> xerox: an element of Cont Bool x  is something which takes questions about elements of x and returns yes/no
14:28:13 <Cale> ruffneck: sure
14:28:55 <palomer> actually, it asks a question about a specific x
14:29:03 <palomer> (or, rather, a specific element of x)
14:29:15 <Cale> yes
14:29:40 <ruffneck> we found it pretty tricky to do on paper with regular math ;P
14:29:50 <Cale> but one which is not really known (and might not be determined until later)
14:30:12 <xerox> palomer: right, and?
14:30:28 <palomer> xerox: how the blazes does that work with bind
14:30:33 <palomer> (the analogy)
14:30:44 <Cale> palomer: you ask an elaborate question
14:30:45 <xerox> I wonder how much could I compress 30 chars to "not have" collisions in my hash.
14:30:48 <xerox> (And how)
14:30:54 <goltrpoat> what are injection and projection on types?  coercion between supertype/subtype pairs?
14:31:07 <xerox> No subtyping )-:
14:31:16 <monochrom> I think I have once written a few recursions in CPS, e.g., factorial.
14:31:35 <Cale> goltrpoat: an injection is a function which lets you see one type as a subset of another type
14:32:00 <xerox> Any ideas on the hash question?  It's like UTF-8 strings of max 30 chars.
14:32:25 <norpan> the hash question?
14:32:34 <Cale> while a projection is a function which allows you to see values of one type as components of values of another
14:32:45 <monochrom> You can always first decode from UTF-8 to unicode Char.
14:32:53 <xerox> norpan: I'm searching for a good way to hash them.
14:33:08 <norpan> can't you just use normal string hashing?
14:33:16 <xerox> norpan: like?
14:33:21 <xerox> monochrom: what's the difference exactly?
14:33:38 <norpan> there are plenty :)
14:33:40 <monochrom> The actual unicode characters are more compact.
14:33:51 <goltrpoat> cale:  oh, so not necessarily in a subtype/supertype relationship, but injection is basically lifted from the algebraic term, like i thought?
14:33:54 <monochrom> Steal code from the Java library. :)
14:34:12 <norpan> djb2 is one i know the name of at least :)
14:35:17 <xerox> norpan: how big is djb2's output?
14:36:05 <Cale> More formally, suppose that you have a collection of types T_1, ..., T_n. If there is a type U and maps i_1,...,i_n where i_k :: T_k -> U, such that for any collection of functions f_k : T_k -> V, there is a function F : U -> V so that F . i_k = f_k, then the i_k's are called injections.
14:36:06 <norpan> it's an integer
14:36:18 <Cale> and U is called the sum of the T_k
14:36:19 <xerox> norpan: nice :-)
14:36:57 <mahogny> can anyone tell me about the performance of STM?
14:37:28 <norpan> djb2 (x:xs) = djb2 xs * 33 `xor` (ord x)
14:37:39 <norpan> djb2 (x:xs) = (djb2 xs * 33) `xor` (ord x)
14:37:53 <norpan> and djb2 [] = 
14:37:59 <norpan> 5381
14:38:10 <norpan> it seems
14:38:20 <Cale> Now, again supposing that you have a collection of types T_1, ..., T_n, if there is a type P and maps p_1,...,p_n where p_k :: P -> T_k, such that for any collection of functions f_k : V -> T_k, there is a function F : V -> P so that p_k . F = f_k, then the p_k's are called projections, and P is called the product of the T_k.
14:38:44 <xerox> norpan: many thanks.
14:38:53 <Cale> oh, and in each case, it should be a unique map
14:39:00 <Cale> (F should be unique)
14:39:20 <Cale> the canonical example of product types are tuple types
14:39:21 <norpan> and x*33 is of course (x `shiftL` 5) + x
14:39:37 <norpan> and i suppose you work with Word32 or something
14:39:47 <Cale> say, (a,b) is the product of a and b with p_1 = fst, and p_2 = snd
14:40:00 <goltrpoat> cale:  i was actually about to ask about products next :)
14:40:24 <Cale> for a sum, I suppose that the canonical example is the Either type
14:40:37 <Cale> with injections being the constructors Left and Right
14:41:23 <goltrpoat> right, makes sense
14:41:52 <goltrpoat> thanks
14:42:00 <Cale> no problem
14:42:22 <norpan> actually it seems you should use djb2 (x:xs) = let hash = (djb2 xs) in ((hash `shiftL` 5) + hash) + ord c
14:42:28 <Cale> palomer: as to the analogy/bind thing
14:43:12 <Cale> bind takes a question/answer box of type (Cont r a) and a function from values of type a, to question/answer boxes of type (Cont r b)
14:43:30 <Cale> It's got to produce a question/answer box of type Cont r b
14:43:38 <Cale> so what does it do?
14:43:42 <xerox> So the first box is stacked in the middle of the 'a' and the 'b' box?
14:44:03 <xerox> s/'b'/'(Cont r b)'/
14:44:24 <Cale> Well, it produces a box where, given a question about values of type b, it asks the first box an elaborate question
14:44:28 <shapr> oh, excellent LtU article - http://lambda-the-ultimate.org/node/1472
14:44:40 <shapr> All about building interpreters by composing monads.
14:45:21 <goltrpoat> i was just reading that paper
14:45:32 * xerox 's head explodes too
14:45:37 <Cale> It asks the first box: What would the box (of type Cont r b) returned by this function of type (a -> Cont r b) do when given your value of type a?
14:45:38 <goltrpoat> (hence the injection/projection question earlier)
14:45:57 <Cale> (i.e. what would its answer be?)
14:46:18 <xerox> So the answer isn't really an 'r' but a (Cont r b) ?
14:46:37 <Cale> the result of bind is a (Cont r b)
14:47:14 <xerox> a :: (Cont r a); b :: (Cont r b)
14:48:04 <xerox> a :: (Cont r a); b :: a -> (Cont r b)
14:48:33 <Cale> x :: Cont r a
14:48:38 <xerox> Hmmmm.
14:48:39 <Cale> f :: Cont r b
14:48:42 <Cale> er
14:48:44 <xerox> I can't plug them.  Hmpf.
14:48:44 <Cale> f :: a -> Cont r b
14:48:57 <Cale> x >>= f :: Cont r b
14:49:04 <xerox> Yes.
14:49:08 <Cale> @djinn-env
14:49:08 <lambdabot> data () = ()
14:49:09 <lambdabot> data Either a b = Left a | Right b
14:49:09 <lambdabot> data Maybe a = Nothing | Just a
14:49:09 <lambdabot> data Bool = False | True
14:49:09 <lambdabot> data Void
14:49:10 <lambdabot> type Not x = x -> Void
14:49:25 <Cale> @djinn-add type Cont r a = (a -> r) -> r
14:49:28 <monochrom> http://www.cs.utoronto.ca/~trebla/calculator/Calculator.html
14:49:36 <monochrom> "please don't use the Ackermann function!"
14:49:51 <Cale> @djinn (Cont r a) -> (a -> Cont r b) -> (Cont r b)
14:49:51 <lambdabot> f a b c = a (\ d -> b d c)
14:50:00 <Cale> see? djinn gets it :)
14:50:30 <ihope> > (9/10)^25
14:50:31 <lambdabot> 7.178979876918534e-2
14:51:06 <xerox> Cale: is there an extra argument?
14:51:10 <ihope> Just a second here...
14:51:15 <ihope> @djinn-del Cont
14:51:30 <ihope> @djinn-add newtype Cont r a = Cont ((a -> r) -> r)
14:51:30 <lambdabot> Cannot parse command
14:51:38 <ihope> @djinn-add data Cont r a = Cont ((a -> r) -> r)
14:52:44 <Cale> @djinn (Cont r a) -> (a -> Cont r b) -> (Cont r b)
14:52:44 <lambdabot> f a b =
14:52:45 <lambdabot>   case a of
14:52:45 <lambdabot>   Cont c -> Cont (\ d ->
14:52:45 <lambdabot>        c (\ e ->
14:52:45 <lambdabot>         case b e of
14:52:46 <lambdabot>         Cont f -> f d))
14:53:31 * xerox falls over
14:53:49 <Cale> palomer: did you get all that? (above)
14:56:17 <xerox> \(Cont c) >>= f = Cont $ \d -> c $ (runCont f) d -- ?
14:58:46 <ihope> @djinn-add runCont :: Cont r a -> (a -> r) -> r
14:58:53 <ihope> @djinn (Cont r a) -> (a -> Cont r b) -> (Cont r b)
14:58:53 <lambdabot> f a b =
14:58:53 <lambdabot>   case a of
14:58:53 <lambdabot>   Cont c -> Cont (\ d ->
14:58:53 <lambdabot>        c (\ e ->
14:58:53 <lambdabot>         case b e of
14:58:55 <lambdabot>         Cont f -> f d))
14:59:00 <ihope> Ack.
15:29:40 <xerox> Goodnight, silent ones.
15:47:54 <palomer> check this out, ghc can't infer a type for joinT (Merge (Foo :@ x)) = Merge (Foo :@ x)
15:50:34 * palomer is shocked!
15:50:36 <Cale> what's the type of Merge?
15:50:45 <palomer> MTerm a a a -> Term a
15:51:17 <mwc> I like the use of :@ as an operator
15:51:30 <palomer> it's the screaming operator
15:51:35 <mwc> @karma+ palomer 
15:51:35 <lambdabot> palomer's karma raised to 4.
15:51:38 <palomer> weee
15:51:41 <palomer> @palomer
15:51:41 <lambdabot> That's nuts!
15:51:50 <Cale> It screams "APP!!"
15:52:19 <palomer> I don't actually want that combinator
15:52:27 <Cale> so what are the types of the other things?
15:52:27 <palomer> I just thought it funny that ghc couldn't infer a type
15:52:43 <palomer> Foo : MTerm (a -> b) a c
15:52:48 <Cale> Is MTerm a GADT?
15:52:52 <palomer> of course
15:52:58 <Cale> well, there you go
15:53:09 <palomer> hmm?
15:53:21 <Cale> It might not even have a principal type.
15:53:54 <palomer> I didn't know ghc cared about non-principally typed terms
15:54:26 <palomer> hrmph, I'll work a little more on this thing
15:54:27 <palomer> bbl
15:54:35 <Cale> well, it sure doesn't infer types for them :)
16:31:53 * palomer wishes djinn had support for typeclasses
16:31:56 <palomer> that would _rock_
16:32:01 <palomer> or at least GADTs
16:32:10 <palomer> that would super rock
16:32:40 <Cale> non-recursive GADTs?
16:32:53 <Cale> It doesn't even have support for recursive types as it is.
16:33:33 <palomer> true, true
16:33:39 <palomer> almost makes me want to write my own theorem prover
16:33:40 <palomer> almost
16:34:09 <palomer> I can't believe it doesn't support recursive types
16:34:17 <palomer> it doesn't add to the complexity!
16:34:52 <Cale> sure it does
16:36:35 <Cale> It might even make it nonterminating in some cases.
16:37:01 * palomer thinks about it
16:37:47 <palomer> theorem proving in System F is decidable
16:38:12 <Cale> decidable in which sense?
16:38:35 <Cale> I can see proof-checking being decidable
16:39:29 <palomer> actually, I'm not so sure about that fact
16:39:30 <Cale> but actually finding a proof with an arbitrary set of axioms seems quite hard - seems like it would be at least exponential
16:39:33 <palomer> (though I'm pretty sure)
16:39:46 <palomer> oh, it's PSPACE complete
16:39:50 <palomer> I believe
16:39:50 <monochrom> Proving theorems is decidable.  In the same sense that factoring primes takes no time. :)
16:40:10 <palomer> monochrom: program synthesis in System F is decidable, right?
16:40:21 <monochrom> I am joking!
16:42:46 <Cale> I'm not sure you can do anything with reasonable time guarantees.
16:43:04 <monochrom> Does System F have subtyping and recursive types?
16:44:03 <palomer> monochrom: nope and nope
16:44:05 <monochrom> (In the community of verification and proving, PSPACE-complete is more than reasonable :) )
16:44:39 <palomer> Cale: the theorems we want to prove are never very large
16:45:50 <monochrom> http://www.google.com/musica?aid=Rl92F9_PM4N&sa=X&oi=music&ct=result  "System F"
16:46:59 <palomer> make love, not war; unless you love to kill
16:47:08 <palomer> gah!
16:47:13 <palomer> the same old story
16:47:17 <palomer> I have a bunch of functions
16:47:24 <palomer> and I need to create a function with a certain type
16:47:30 <edwinb> A quick google reveals that type inhabitation is undecidable for system F...
16:47:47 <Cale> I thought so
16:47:54 <palomer> that's very, very strange
16:47:59 <edwinb> http://www.seas.upenn.edu/~sweirich/types/archive/1996/msg00387.html
16:48:02 <palomer> I don't believe it
16:48:04 <edwinb> it doesn't seem strange at all to me...
16:49:11 <palomer> that would mean that djinn would not terminate
16:49:25 <palomer> ah, no, it wouldn't
16:49:35 <palomer> very subtle
16:49:38 <Cale> djinn isn't working with System F
16:50:00 <palomer> actually, I don't believe it!
16:50:05 <palomer> Cale: what is it working in?
16:51:18 <Cale> a simply-typed lambda calculus
16:52:21 <palomer> from my understanding, system F = simply-typed lambda calculus + let polymorphism
16:52:42 <palomer> oh, I'm an idiot
16:52:45 <palomer> never mind me
16:53:06 <palomer> I'm just tired
16:53:40 <monochrom> Could you also explain to me?  What is extra in System F (comparing with say HM or simply-typed lambda calculus) that makes type inference undecidable?
16:54:54 <palomer> System F allows quantifiers anywhere
16:57:59 <Cale> ftp://ftp.mimuw.edu.pl/People/urzy/loeb.dvi.Z
16:58:20 <palomer> I hallucinated and thought system F == HM
16:58:22 <palomer> I was nuts!
16:58:40 <Cale> @palomer
16:58:40 <lambdabot> They're telling you lies!
16:59:54 <Cale> I'm going to have to start saying zany things so I can get my own lambdabot command :)
17:01:36 <Cale> problems like type inhabitation look a lot like the word problem for groups to me, which makes me tend to be pessimistic about their tractability
17:01:45 <monochrom> Interesting.
17:02:27 <Cale> (I'm not sure exactly why they look like that)
17:03:30 * ihope would like an !ihope command :-)
17:03:54 <monochrom> @monochrom
17:03:54 <lambdabot> Unknown command, try @list
17:04:00 <Cale> @keal
17:04:00 <lambdabot> can GMP support KealDigit? I invent KealDigit
17:04:09 <Cale> @keal
17:04:09 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
17:04:25 <Cale> @keal
17:04:25 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
17:05:16 <gzl> hahaha
17:05:22 <Cale> @keal
17:05:22 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
17:05:26 <monochrom> yeah that one was good.
17:05:31 <Cale> @keal
17:05:31 <lambdabot> ithink has to do with hardcased government failsafe in chip
17:05:38 <Cale> @keal
17:05:39 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
17:06:22 <Lemmih> @keal
17:06:23 <lambdabot> T could perform expressions 600mb and bigger
17:06:27 <ihope> @keal
17:06:28 <lambdabot> there is no way to prove the failsafe exists
17:06:32 <ihope> @keal
17:06:32 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
17:06:46 <Cale> @keal
17:06:46 <lambdabot> 99% of my book has been erased by faulty hdd's
17:06:54 <ihope> @keal
17:06:55 <lambdabot> how do i search for someone saying 'Keal' in mirc
17:07:05 <Lemmih> Does keal have a weblog?
17:07:16 <ihope> @google keal weblog
17:07:18 <lambdabot> http://www.49media.com/mediaid=535984_st=1_sw=century_adt=n_ct=-2_mt=-1_cs=0
17:07:41 <ihope> Um.
17:09:08 <Cale> @keal
17:09:08 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
17:09:24 <Cale> @keal
17:09:24 <lambdabot> it is very easy to go off topic
17:09:33 <Cale> @keal
17:09:34 <lambdabot> my proof show math is broken right now
17:09:40 <Cale> heh
17:09:45 <Cale> I like the 'right now'
17:09:49 <edwinb> Hmm, I like that one ;)
17:10:02 * edwinb makes a note to use it where necessary
17:11:14 <Pseudonym> G'day.
17:11:37 <Pseudonym> Marginally off-topic question...
17:12:38 <Pseudonym> Does anyone know what standards apply to stadium displays?
17:12:49 <Pseudonym> I know that they're all going to digital video these days.
17:13:47 <Pseudonym> But I'm writing the software for a new sport, so I'm curious how I could "hook into" existing display systems easily.
17:15:15 <Cale> a new sport?
17:16:32 <Pseudonym> Yup.
17:16:47 <Pseudonym> We can take this to haskell-blah if you want a fuller explanation.
17:17:01 <palomer> http://www.rafb.net/paste/results/dfiAhY25.html <--tough GADT questions
17:18:00 <palomer> woops, misparenthesized
17:18:03 <palomer> http://www.rafb.net/paste/results/IZKZ8t81.html
17:18:12 <Pseudonym> palomer: Looks to me like iPerce's law.
17:18:15 <Pseudonym> Pierce's
17:18:24 <palomer> it is
17:18:43 <Pseudonym> I don't believe that Pierce's Law is provable in intuitionistic logic.
17:18:57 <palomer> it isn't
17:19:24 <Pseudonym> Rather than trying to decipher your terms, why don't you try depth-first-searching for it, like djinn does?
17:19:29 <Cale> @type Control.Monad.Cont.callCC
17:19:30 <lambdabot> forall (m :: * -> *) a b.
17:19:30 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
17:19:30 <lambdabot>           ((a -> m b) -> m a) -> m a
17:20:28 <Cale> shouldn't UnMerge :: Term a -> MTerm a a a ?
17:20:38 <palomer> nope
17:20:59 <palomer> that's the beauty of it
17:22:46 <palomer> I can create a term of type Term (((a -> b) -> a) -> a)
17:23:23 <palomer> (if that helps anyone)
17:23:41 <palomer> Pseudonym: depth-first-searching with recursive GADTs?
17:23:49 <palomer> mutually recursive GADTs at that
17:24:00 <Pseudonym> OK, breadth-first-searching.
17:24:03 <Pseudonym> :-)
17:24:57 <palomer> if only it was that simple
17:26:21 <tuxplorer> good morning ! ;) 
17:26:31 <palomer> mornin'
17:26:46 <palomer> I also have a term Term (a -> b) -> Term a -> Term b
17:26:46 <tuxplorer> can anyone tellme where the darcs for FMIndex and LZIndex are?
17:26:50 <palomer> if that helps anyone
17:44:28 <dons> moin
17:49:36 <tuxplorer> @localtime dons
17:49:38 <lambdabot> Local time for dons is Fri May 12 10:45:24 2006
17:54:48 <dons> dcoutts_: ok, i'll try to think up a more thorough Arbitrary
17:57:42 <araujo> morning dons 
17:57:59 <dons> morning araujo 
18:03:29 <araujo> dons, how your code goes? :-)
18:06:41 <Smokey`> sweet, assignment #2 complete, love haskell more because of it, and didn't have to go into uni to submit it (ssh into uni server, and submit :D)
18:08:31 <dons> araujo: bug hunting!
18:10:47 <araujo> dons, wow!
18:13:04 <dons> well, there not my bugs ;)
18:14:42 <dons> i like this new darcs ghc. if someone breaks the tree, you just unpull their patch until its fixed.
18:14:54 <dons> was a real pain with cvs. things just stayed broked
18:17:53 <wchogg> I didn't know you could do that in darcs
18:20:44 <heatsink> Is [] :: forall a. [a] a CAF?
18:28:20 <eivuokko> I am by no means expert, but wouldn't it need to have something to evaluate to be a CAF?
18:29:41 <heatsink> What I mean is, would that expression be evaluated at most once if it were declared at module scope?
18:30:16 <eivuokko> Not sure how that applies to constructors.
18:31:50 <heatsink> You could allocate multiple chunks of memory that are all [], or you could allocate exactly one chunk of memory and reference it multiple times.
18:32:25 <heatsink> For a monomorphic [] at module scope, I'm pretty sure it's the latter.
18:33:49 <heatsink> The allocation, to me, seems to be like creating a new unevaluated thunk... which is why I talk of evaluating multiple times.
18:35:27 <tuxplorer> someone plz tell me where the FMIndex and LZIndex darcs are
18:35:34 <ihope___> @hoogle r -> Cont r a
18:35:34 <lambdabot> No matches, try a more general search
18:35:51 <ihope___> @hoogle (r -> r) -> Cont r ()
18:35:51 <lambdabot> No matches, try a more general search
18:35:59 <tuxplorer> ?hoogle FMIndex
18:36:00 <lambdabot> No matches found
18:36:08 <ihope___> @djinn (r -> r) -> Cont r ()
18:36:08 <lambdabot> f a = Cont (\ b -> a (b ()))
18:36:29 <ihope___> 'Ere we go!
18:36:33 * ihope___ hugs Djinn
18:41:54 <Lemmih> tuxplorer: The Haskell bindings?
18:59:03 <the_lord> Hi!
19:00:00 <Cale> hi
19:00:26 <the_lord> please anyone with experience with Alex
19:00:50 <Cale> I've never used it myself, but if you ask a question, probably someone will know
19:02:35 <Cale> (or we can sort it out)
19:02:53 <the_lord> I'm using the "posn" wrapper, and I need to report lexical problems with details, where details = char #, line #, column #
19:02:56 <the_lord> :S
19:05:15 <Cale> okay
19:07:12 <tuxplorer> Lemmih: sorry i was away.. Yes!
19:08:48 <tuxplorer> @seen Lemmih!
19:08:49 <lambdabot> I haven't seen Lemmih!.
19:08:50 <Cale> hmm, alexScanTokens seems to not report it, though it has the necessary information
19:08:56 <tuxplorer> @seen Lemmih
19:08:57 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 27 minutes and 2 seconds ago.
19:09:07 <tuxplorer> @localtime Lemmih
19:09:09 <lambdabot> Local time for Lemmih is Fri May 12 04:08:57 2006
19:09:13 <Cale> you could easily steal that copy of alexScanTokens from the documentation and modify it so that it did though
19:09:41 <Lemmih> tuxplorer: I don't think they exist yet.
19:09:54 <tuxplorer> ok. The C ones?
19:10:45 <tuxplorer> I just want to build a library of interfaces to them using FFI..
19:10:46 <Lemmih> Not many C projects use darcs.
19:11:12 <tuxplorer> Lemmih: I just need the C code for FMIndex and LZIndex atleast..
19:13:05 <Lemmih> http://pizzachili.dcc.uchile.cl/
19:13:55 <tuxplorer> Thanks Lemmih! This pizzachilli, i heard about from someone. but didnt know the URL.. thanks a lot..
19:15:48 <Lemmih> tuxplorer: Are you Rajagopal?
19:15:54 <tuxplorer> yes.
19:28:05 <the_lord> Alex anyone?
19:31:48 <petekaz> @seen shapr 
19:31:49 <lambdabot> shapr is in #haskell-overflow and #haskell. I last heard shapr speak 4 hours, 47 minutes and 6 seconds ago.
19:37:16 <Cale> the_lord: did you see my response?
19:45:14 * innit is away: away
19:46:56 <hask-ell> question: why, in monads, can I do something like feed a var :: [t] as an input to to a function f :: t->[t]
19:47:18 <Cale> because of the type of bind?
19:47:29 <Cale> I'm not quite sure what you're referring to
19:47:35 <Cale> could you give an example
19:47:37 <Cale> ?
19:48:06 <hask-ell> I am going through a tutorial, http://www.nomaware.com/monads/html/exercises.html
19:48:37 <Cale> okay
19:48:42 <hask-ell> And the 3rd exercise has this solution: grandparents s = do p <- parents s ; parents p
19:48:47 <Cale> right
19:49:14 <Cale> do you know what that desugars to?
19:49:16 <hask-ell> so, type of 'p' is [Sheep] while function parents is of type Sheep -> [Sheep]
19:49:28 <Cale> p is of type Sheep
19:49:51 <Cale> and parents is indeed of type Sheep -> [Sheep]
19:49:52 <hask-ell> ?  No, p receives a result from function parents :: Sheep -> [Sheep]
19:49:56 <hask-ell> Ok
19:50:03 <hask-ell> So how is p of type Sheep?
19:50:13 <Cale> because it's a result
19:50:25 <Cale> if you have in a do block something which looks like
19:50:32 <Cale> v <- x
19:50:37 <hask-ell> Humm.. trying to follow, why isn't the result [Sheep]?
19:50:38 <Cale> and x :: m a
19:50:42 <Cale> then v :: a
19:50:55 <Cale> why is this?
19:51:16 <Cale> It's because do notation is really sugar for some applications of the bind function
19:51:26 <Cale> do p <- parents s ; parents p
19:51:41 <Cale> = parents s >>= parents
19:51:58 <Cale> and the type of >>= is m a -> (a -> m b) -> m b
19:52:17 <Cale> maybe I should show the lambda :)
19:52:28 <Cale> do p <- parents s ; parents p
19:52:37 <Cale> = parents s >>= \p -> parents p
19:53:26 <hask-ell> :)  still digesting.... thank you...
19:53:41 <Cale> Actually, have you read Monads as Containers?
19:53:47 <dons> dcoutts_: yay, got Lazy.hGetContents working :)
19:53:50 <Cale> @wiki Monads as Containers
19:53:50 <lambdabot> http://www.haskell.org/haskellwiki/Monads as Containers
19:53:54 <dons> it filters 50M using 1M heap :)
19:53:56 <hask-ell> No... I didn't like "What the hell are monads though
19:54:06 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
19:54:08 <Cale> there :)
19:54:23 <Cale> that's a good starting place
19:55:07 <dons> dcoutts_: yeah, really nice, running an infinite list through it now, constant heap space :)
19:55:40 <Cale> dons: what lazy shenanigans are you up to now?
19:55:42 <hask-ell> Cale: thanks, I'm bookmarking it for the next evening of study.
19:56:04 <dons> Cale, oh, lazy IO for Lazy bytestrings.
19:56:17 <Cale> hask-ell: great :) It should make things a bit clearer
19:56:27 <dons> i.e. read bytestring chunks on demand
19:56:27 <Cale> dons: oh, so you took my suggestion?
19:56:43 <Cale> (or something related to it?)
19:56:47 <dons> well, this lazy io stuff was what dcoutts and I've been hacking on the last couple of days
19:57:03 <dons> we have a newtype ByteString = LPS [P.ByteString]
19:57:08 <dons> and everything goes from that
19:57:18 <Cale> how are chunks allocated?
19:57:20 <dons> so a lazy list of strict chunks, in effect
19:57:31 <dons> they're normal bytestrings, so on the haskell heap
19:57:47 <Cale> Do they get larger as the list grows?
19:57:58 <Cale> or are they all the same size?
19:58:02 <dons> no, you just add more chunks to the end.
19:58:11 <dons> all the same size, currently 4k, but will be tunable
19:58:26 <dons> i.e. 1M chunks might be good for some cases.
19:59:03 <dons> (and I finally find a use for my 'cycle' shell program from h4sh -- generating input for benchmarking lazy programs)
19:59:13 <Cale> Making it a function of the chunk number might be an idea, if it's not too insane to do.
19:59:52 <Cale> I can imagine cases where you'd want, say, fibonacci growth.
20:00:01 <dons> so I think this may well be the first time we can deal with > 1G files effectively in haskell.
20:00:06 <Cale> :)
20:00:08 <dons> oh, yeah, that wouldn't be too hard to add
20:02:02 <Cale> hehe, someone should go and write a video codec or something crazy like that.
20:02:19 <dons> basically, hGet :: (Int -> Int) -> Handle -> IO ByteString
20:02:30 <dons> and then use that function on the chunksize each time around
20:02:52 <dons> Cale: hmm, yeah, a streaming program. hmm.
20:12:19 <dons> funny comment: The computation 'writeFile' @file str@ function writes the string ..
20:12:28 <dons> computation functions :)
20:12:40 <Cale> heh
20:31:48 <sethk> dons, did you ever get a chance to look at that posting?
20:34:31 <palomer> hrmph, turns out it's a monad, I think
20:36:06 <dons> sethk: i've got the window open here. haven't looked at it yet, though. sorry.
20:36:59 <sethk> dons, no problem, let me know if you get a chance to look at it.
20:36:59 <dons> ok.
20:37:27 <sethk> dons, I also wanted to ask your opinion of some database stuff I'm thinking of implementing.  Do you know database theory?  I don't want to send you something long with stuff you already know, but if you aren't familiar with it, it makes no sense at all without the background
20:38:14 <sethk> dons, that's somewhat vague, I realize  :)
20:38:51 <dons> no, I haven't done any database stuff. :) I tried, in the end successfully, to avoid it in my undergrad days
20:39:07 <dons> and picked all the programming lang and compiler courses instead
20:39:49 <sethk> dons, ok.  database stuff does tend to be dull, but I'm at the point where I have to deal with the persistent storage requirements of my app, so I can't avoid it forever  :)
20:40:06 <sethk> I'll try not to be as verbose as usual
20:41:04 <dons> ok :)
20:42:45 <palomer> yes!
20:42:46 <palomer> I found the combinator!
20:42:46 <palomer> omg that was hard
20:44:08 <palomer> whew.
20:44:16 <rasterfar> hrmph
20:44:51 <palomer> brump!
20:44:53 <palomer> @palomer
20:44:53 <lambdabot> Brump!
20:44:55 <palomer> yes!
20:45:30 <rasterfar> "As someone who's studied GADTs, I've never found a use for them." ??? palomer did you write a new @palomer plug?
20:45:52 <monochrom> I don't know continuations.
20:45:55 <monochrom> @monochrom
20:45:55 <lambdabot> Unknown command, try @list
20:46:15 <rasterfar> @list
20:48:38 <lambdabot> list [module|command]. Where modules is one of:
20:48:38 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
20:48:38 <lambdabot> version vixen where
20:48:46 <rasterfar> I am facing a dilemma, whether or not to use Haskell for some intensive coding i'm embarking on.
20:48:48 <palomer> well, I've actually never found a use for them
20:48:48 <rasterfar> It involves many updates to a large tree, and I'd like to use it as a backend to a GUI so the updates have to be fast.
20:48:48 <palomer> typeclasses have always seemed a better choice
20:48:50 <palomer> by useful, I mean "for getting something done"
20:48:59 <dons> rasterfar: speed wouldn't be a problem. haskell's damn fast
20:49:05 <dons> check the tree benchmarks on the great language shootout
20:49:06 <palomer> as opposed to "finding cool tricks which remind me of my loneliness"
20:49:09 <rasterfar> The current code uses a naive tree datatype -- is it true that the tree needs to be reconstructed each update?
20:49:32 <dons> I wouldn't think so, no. a node would be replaced on each update, surely.
20:49:43 <dons> its just ptr swizzling.
20:49:48 <dons> ?shootout
20:49:48 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
20:49:58 <dons> there's a tree benchmark in there somewhere
20:50:15 <dons> anyway, do you have an actual speed problem yet? or are you just suspicious :)
20:51:29 <palomer> the haskell code on the shootout looks like extraterrestrial assembly
20:51:29 <dons> and what would your alternative be anyway? c++, python, java are all slower. C is too dangerous for large data structures
20:51:30 <rasterfar> Yes, I believe you it's fast.  I guess I'm wondering if I need to use special fast datatypes of GHC?
20:51:30 <monochrom> I would think the opposite.  backend to a GUI can be slow.  GUI is slow.  Human is slow.
20:51:30 <dons> palomer: ?karma -
20:51:30 <palomer> OH NOES
20:51:31 <rasterfar> I have similar code in Java, but it is awefully bloated so I'm starting fresh.
20:51:31 <dons> rasterfar: no, normal data types should be fine. depending on the load, and the tree size, you might want strict node fields.
20:51:47 <rasterfar> i'm using C++/Qt/OpenGL for the front-end.  I'd start from scratch in C++ to be on the safe side...
20:51:58 <rasterfar> ... but I also have a good start on the backend in Haskell from 2003.
20:52:26 <rasterfar> normal datatypes fine ... this is what I like to hear.  (The current version has normal datatypes.)
20:52:32 <palomer> @karma
20:52:32 <dons> well, get cracking then. if you end up having some bottleneck in the tree code, come back to us and we can tune it. i'd say you'll probably never hit that point though.
20:52:32 <lambdabot> You have a karma of 4
20:52:40 <dons> there's also Data.Tree, you could use.
20:53:10 <palomer> hrmph
20:53:14 <dons> yeah, here's the tree benchmark: http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
20:53:34 <rasterfar> okay awesome, I'm going for it.
20:54:30 <dons> lesson: don't write your binary tree code in python, perl or ruby.
20:54:32 <palomer> oh, that code doesn't look too bad
20:54:32 <monochrom> heh heh heh
20:54:32 <dons> palomer: thankyou. its only the io intensive ones that go nuts. and now with ByteString its redundant anyway.
20:55:02 * dons thinks people should write libraries instead of complaining.
20:57:28 <palomer> what would #haskell become without my constructive input?
20:58:48 <dons> the constructive input is fine. i don't mind the constructive input. its the trolling thats annoying ;)
21:00:59 <palomer> moi? troll!
21:01:12 <palomer> or, rather
21:01:14 <palomer> moi! troll?
21:01:39 <dons> the first was funnier :)
21:01:49 <palomer> but untrue
21:01:55 <palomer> these combinators are twisting my brain
21:02:43 * palomer never knew that finding combinators could be so much work
21:02:43 <monochrom> Haskell is utterly useless for anything requiring more than 1 million lines of Haskell code.
21:02:56 <monochrom> I have a proof too.
21:04:02 <dons> hehe 
21:04:16 <sethk> monochrom, how many lines are in the proof?
21:04:26 <monochrom> Two lines.
21:05:04 <sethk> monochrom, too bad, I only understand one line proofs  :)
21:05:05 <dons> dcoutts_: cool, lazy io uses 1M heap to map over 0.5G, in 7s. it takes 8s and 500M use  strict ByteString :D
21:05:14 <dons> as always, the solution is to add MORE LAZYNESS
21:05:40 <dons> now, to find enough disk space to build an 8G file..
21:06:22 <mlh> will making one with holes do?  you know - the lazy option
21:06:34 <monochrom> It is not complicated.  Haskell is so cool, 1 million lines of Haskell code corresponds to 1 biillion lines of C++ code.  As our civilization is not advance enough to need such a large system yet, it is useless.
21:07:53 <wolverian> dons, laziness .. 
21:09:14 <dons> well, i could stream it, but I want a nice example of a haskell program dealing with files bigger than memory efficiently.
21:09:14 <dons> ah, found 10G free. good good
21:09:14 <monochrom> Do you like my proof? :)
21:10:51 <dons> well, its certainly interesting.
21:10:51 <dons> i'm not sure if its a proof of forall a . Useless a. though.
21:11:02 <dons> i'm not sure if its a proof of forall a . a < 1M loc,  Useless a. though.
21:11:06 <edwinb> I'm interested in the 1:1000 claim....
21:11:20 <dons> yeah, that's a bit high. more like 1:10,  I think according to the literature
21:11:25 <Korollary> mathewm: Would you happen to be the same mathewm who's going to present someone else's paper titled "A Language Based Approach..." later this month?
21:11:28 <monochrom> heh
21:12:14 <edwinb> 1:10 I am prepared to believe
21:12:51 <edwinb> I was trying to find some claim of billion line software somewhere but have so far failed...
21:12:52 <dons> I have a theory that as the programs start to become large, haskell's ratio improves as abstraction and monadic stuff comes into play
21:13:02 <dons> for programmign in the small, 1:10 seems reasonable
21:13:09 <dons> but for large programs, it may be much more.
21:13:22 <dons> as some things quickly become infeasible in C.
21:13:30 <dons> but maybe this is a productivity argument,
21:13:39 <edwinb> I think it's hard to measure since once I've written a large haskell program I have no intention of writing it in anything else...
21:14:13 <dons> yeah, we usualyl only have examples of large programs in C rewritten into small programs in Haskell
21:14:19 <dons> not hugh programs in C rewritten to large programs in Haskell
21:14:25 <sethk> edwinb, you have to work the other way.  I'm seriously thinking about rewriting in Haskell a very large program in C
21:14:26 <edwinb> Nobody is mad enough to go the other way, as far as I have heard...
21:14:30 <sethk> c++ actually ...
21:14:35 <edwinb> oh, I spoke too soon! ;)
21:14:44 <edwinb> ohm no, sorry, misread
21:15:03 <sethk> edwinb, If I were going in the other direction, do you think I'd admit it here?  :)
21:15:04 <edwinb> heh
21:15:22 <edwinb> go on, it'd be an interesting experiment ;)
21:15:23 <Cale> rasterfar: If you make updates to a tree, you can expect to reconstruct O(log n) nodes.
21:16:21 <palomer>     Equations for `pierce10' have different numbers of arguments <--ok, what the blazes is this supposed to mean?
21:17:18 <sethk> palomer, that you have more than one implementation (with different patterns) of a function, and the number of arguments are not the same
21:17:41 <palomer> ah, righto
21:17:52 <sethk> that's one of the few error messages that actually makes sense  :)
21:17:55 <rasterfar> Cale: thanks.  that is the part of the tree you traverse to get to the node you're updating?
21:18:05 <Cale> rasterfar: yeah
21:19:02 <sethk> Cale, not necessarily.  you may have to rework nodes deeper in the tree than the one you reach to find the update point.
21:19:02 <rasterfar> that's certainly no problem.  but -- I would share my code, but I haven't really read it since 2003, although I did take pains with it then -- but, there was something definitely wonky about my approach.
21:19:16 <rasterfar> (will share soon!...)
21:19:25 <Cale> what are you using the tree to implement?
21:19:41 <rasterfar> well, it is a visual language
21:20:08 <sethk> now every say together:   ah, I see
21:20:36 <rasterfar> the user manipulates a visual representation of a tree -- the edits have to refresh in real time
21:20:38 * palomer still doesn't know how to understand Cont's bind in terms of the question analogy
21:21:18 <rasterfar> definitely I remember having major issues with the code -- i'll come back when i've refreshed on what they were
21:21:43 <rasterfar> (just needed the encouragement.  thanks, you folks are the best)
21:23:49 <palomer> YES!
21:26:24 <Cale> sethk: but actually replacing them? If the subtree containing a node isn't changed, then you should be able to share it.
21:27:56 <sethk> cale, yes, but what I meant is that if you rebalance, which is common, you may need to change nodes both above and below the update position
21:27:59 * dons watches 6G strings run through Haskell
21:27:59 <monochrom> Who in the hell would rebalance a tree of a visual language?!
21:27:59 <sethk> Cale, and if you don't rebalance, then your o(log n) may not be correct
21:27:59 <sethk> monochrom, me
21:28:11 <sethk> monochrom, because the language is representing a real tree, presumably
21:29:37 <rasterfar> sethk, are you also an arbourist?
21:29:37 <Cale> sethk: ah, okay
21:29:47 <sethk> rasterfar, yes, my database servers are very tree heavy
21:30:22 <monochrom> Like this?  You are looking at the AST for "print x >> (print y >> (print z >> (print a >> print b)))" and you go "this is so one-sided, let me apply monad associative laws to re-balance it!" ???
21:31:05 <rasterfar> interesting
21:31:37 <sethk> monochrom, my trees are composed of data, not strings which, when compiled, might be used to produce a tree
21:35:07 <goltrpoat> i think the point is that when you're drawing a program as a DAG, rotating a node changes the program
21:36:24 <monochrom> heh heh heh
21:37:31 <hyrax42> using readHex... do you just take fst . head of the result?
21:37:36 <hyrax42> or readOct
21:37:41 <monochrom> Yes.
21:37:46 <sethk> hyrax42, you can
21:37:53 <sethk> hyrax42, if you know the first parse is the correct one
21:38:03 <sethk> hyrax42, or you know there is only one, which is the same thing
21:38:08 <hyrax42> how likely are ambiguous parses in hex or oct?
21:38:13 <hyrax42> are they even possible?
21:39:05 <rasterfar> goltrpoat, yeah -- there may be "rotational transformations" which preserve the semantics, but it wouldn't be the same program syntactically, so i wasn't considering rebalancing.
21:39:33 <Cale> > readHex "aba52"
21:39:37 <lambdabot> [(703058,"")]
21:40:04 <monochrom> I think there is no ambiguity.
21:40:04 <Cale> > readHex "aba52hello"
21:40:04 <lambdabot> [(703058,"hello")]
21:40:16 <Cale> interesting
21:40:17 <hyrax42> > readHex "aba52allo"
21:40:18 <monochrom> maximal munching
21:40:26 <lambdabot> [(11248938,"llo")]
21:40:40 <rasterfar> still, would be really neat if the program could suggest semantics-preserving rewrites which balance your code!
21:40:45 <goltrpoat> and last but not least..
21:40:48 <goltrpoat> > readHex "x"
21:40:56 <lambdabot> []
21:41:01 <hyrax42> is lambdabot lagging?
21:41:02 <hyrax42> or am I?
21:41:20 <dons> oh... hmm.. i'm doing some big file tests on lambdabot's box...
21:41:29 <dons> might be a bit of a lag..
21:41:33 <monochrom> haha
21:41:49 <dons> ok. all done.
21:42:26 <hyrax42> ah ok
21:42:27 <hyrax42> no worries
21:43:51 <dons> ok, I just filtered all 'e's from a 4G file in 2mins 20s.
21:43:55 <dons> using a constant 1M heap. very much fun :)
21:44:04 <dons> tuning the GC would probably help a bit.
21:45:14 <dons> now, what would happen if we used [Char].
21:46:25 <dons> oh, much much higher cpu load.
21:48:19 <hyrax42> @index octDigit
21:48:20 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
21:48:23 <hyrax42> oh huh
21:48:26 <hyrax42> thanks parsec
21:48:40 <goltrpoat> what do they use automatic program differentiation anyway
21:49:10 <hyrax42> I was surprised when that compiled without me specifying
21:49:10 <goltrpoat> +for
21:49:10 <hyrax42> what i meant by octDigit
21:49:30 <goltrpoat> second time i came across it in a few weeks
21:50:37 <hyrax42> @index toLower
21:50:51 <lambdabot> Data.Char
21:54:38 <kzm_> dons - congrats on the 4G file.
21:55:01 <kzm_> presumably with dcoutts's lazy bs? 
21:55:04 <dons> yes.
21:55:15 <dons> using [Char] took 8 minutes on the same file. 
21:55:19 <kzm_> how does it compare to extrapolated raw bs?
21:55:25 <dons> presumably by tweaking the chunk size, we can increase the speed.
21:55:42 <dons> extrapolated?
21:56:15 <dons> well, normal Data.ByteString can't do this, since it needs to strictly allocate the entire ByteString
21:56:24 <kzm_> well - how fast would non-lazy BS go, if it scaled linearly, and you had enough memory/addr space?
21:56:39 <kzm_> ie. what is the price for laziness?
21:56:52 <kzm_> and is there a C comparison?
21:56:56 <dons> right. need to benchmark that on something that actually fits in memory
21:57:13 <dons> hmm. perhaps a C program that does the same job? a lazy filter. sed ?
21:57:32 <dons> i'll compare it against sed, see how we go.
21:58:28 <kzm_> cool
21:58:51 * kzm_ thought sed would be too line-oriented to count e's?
21:58:51 <dons> ?localtime kzm_
21:58:51 <lambdabot> Local time for kzm_ is Fri May 12 06:57:31
21:58:51 <kzm_> good morning to you too
21:58:51 <dons> kzm, no I'm filtering 'e's out.
21:58:51 <kzm_> :_)
21:58:53 <goltrpoat> like this link:  http://www-unix.mcs.anl.gov/autodiff/AD_Tools/ .. quote: "It exploits the fact that every computer program, no matter how complicated, executes a sequence of elementary arithmetic operations such as additions or elementary functions such as exp()."  that's great, but say f x n = (0.5**n cos(a**n * pi * x)) + f x (n+1)
21:58:53 <dons> you just work up. early bird, eh?
21:58:53 <dons> woke.
21:58:53 <goltrpoat> how on earth are they planning on differentiating f x 0
21:58:53 <kzm_> woke, yes.  work will be a bit later :-)
21:58:53 <goltrpoat> er.. make a=20 there
21:58:53 <kzm_> (the _ is my home logon)
21:59:09 <hyrax42> has anyone here looked at the scheme in 48 hours tutorial?
21:59:21 <Pseudonym> More tot he point, goltrpoat, how are you even going to _evaluate_ that?
21:59:54 <Pseudonym> I don't think it claims that the differentials are going to be numerically adequate.
22:00:17 <kzm_> isn't f x (n+1) > f x n  -- generally?
22:00:29 <Cale> hyrax42: I looked at it briefly
22:00:34 <goltrpoat> it's an example of a nowhere differentiable function :)
22:01:22 <hyrax42> @where paste
22:01:22 <lambdabot> http://paste.lisp.org/new/haskell
22:02:33 <Pseudonym> But it's also a nowhere evaluable function.
22:02:38 <Pseudonym> So the fact that it doesn't return derivatives is irrelevant.
22:02:38 <goltrpoat> if you don't like evaluating it, make it generate a list of intermediate results, and then differentiate \k -> take k $ f x 0
22:02:38 <Pseudonym> I do wonder if it deals with the L'Hospital's rule cases.
22:02:41 <goltrpoat> \k x -> crap rather.  wrt x.
22:02:41 <Pseudonym> Well in that case, each element is going to have reasonable derivatives.
22:02:41 <Cale> goltrpoat: are you sure you want the recursive call to increase n?
22:02:41 <lisppaste2> hyrax42 pasted "Does this really work?" at http://paste.lisp.org/display/19922
22:02:50 <goltrpoat> cale:  pretty sure.. it's something like sum_{n=0}^inf b^n cos(a^n pi x)
22:03:30 <Cale> hyrax42: good point, add # to the list of symbols :)
22:04:35 <hyrax42> my first solution was to through '#' into symbol
22:04:35 <hyrax42> but!
22:04:35 <Pseudonym> That's fine, but you still can't evaluate f.
22:04:35 <hyrax42> (there's a but)
22:04:35 <Pseudonym> You need to find another method of computing the series.
22:04:35 <Cale> goltrpoat: for some values of a and b, that isn't differentiable of course
22:04:35 <Cale> (it's a classic example)
22:04:35 <hyrax42> when you get to the part where you want to extend number parsing to catch #xa as Number 10, having the # allow parsing to an Atom makes things no good
22:04:35 <Pseudonym> Cale, I think we can assume |b| < 1
22:04:35 <int-e> hyrax42: btw, you can write a:b instead of [a] ++ b
22:04:55 <goltrpoat> cale:  yah, i was asking how are they planning on differentiating programs that aren't differentiable
22:04:55 <hyrax42> int-e: yeah I know... I did in mine, just that's copy/pasted from the tut
22:05:09 <int-e> aha.
22:05:19 <hyrax42> anyway, I think I need backtracking for that?
22:05:19 <Cale> goltrpoat: but you'll note that the program doesn't actually define a function at all, since it's nonterminating.
22:05:23 <Pseudonym> goltrpoat: If they're not evaluable...
22:05:38 <Pseudonym> An example of a non-differentiable function is a fractal.
22:05:39 <goltrpoat> cale:  yah, i back-pedalled by writing that lambda expression afterwards
22:05:54 <hyrax42> #t is a bool, but #xab and #o73 are both numbers
22:05:57 <Pseudonym> But you don't really compute fractal functions, merely approximations to them.
22:06:08 <Cale> goltrpoat: at which point, of course you can differentiate, since you have a finite approxmation
22:06:11 <goltrpoat> which is differentiable for any finite k, but k is unbound
22:06:14 <Pseudonym> Right.
22:06:28 <Cale> the derivative is a horrible function :)
22:06:46 <Cale> hyrax42: hmm
22:07:14 <Cale> hyrax42: if you want to be cheap, you can add the strings "#t" and "#f" to the grammar explicitly
22:07:17 <Pseudonym> Incidentally, sum_{n=0}^inf b^n cos(a^n pi x) has an analytic derivative.
22:07:43 <goltrpoat> it's nowhere differentiable for certain values of a and b, pseudonym.
22:07:55 <hyrax42> well it gets a little worse, as #\a is the character a, but I'm leaving that for noww
22:07:55 <goltrpoat> classic example from analysis.
22:07:55 <Pseudonym> Sure.
22:07:55 <Cale> http://mathworld.wolfram.com/WeierstrassFunction.html
22:08:07 <hyrax42> Cale: forgive my ignorance, but hwo would I do that
22:08:14 <Pseudonym> Even more seriously, though, a numerical method optimised for computing f might be horrible for computing f'
22:08:31 <Pseudonym> So you might get analytic derivative, but it's numerically useless.
22:09:18 <Cale> parseAtom = booleanValue <|> otherAtom
22:09:48 <goltrpoat> that site is talking about augmenting a program with its analytic derivatives.
22:10:01 <goltrpoat> i was picking on that.  in this case, there is no analytic derivative, but ok, it's an infinite series and we can't actually evaluate the function (although one might argue that no one claimed that you have to be able to evaluate it to differentiate it, from what they're saying)
22:10:26 <Cale>   where booleanValue = do b <- string "#t" <|> string "#f"; return $ case b of "#t" -> Bool True; "#f" -> Bool False
22:10:41 <Cale> and otherAtom would be somewhat like your existing code
22:10:42 <rasterfar> seeing as this is #haskell, maybe people would find this useful: http://www.math.mcgill.ca/rags/difftl/difftl.abstract.html
22:10:54 <Pseudonym> Actually, thinking about it, an error in, say, a Chebyshev approximation is going to get amplified in the derivative.
22:11:07 <hyrax42> Cale: thanks
22:11:11 <Pseudonym> And the higher order the approximation, the worse the relative error might get.
22:11:24 <hyrax42> actually I think parseAtom shouldn't be taking care of bools anyway
22:11:34 <Pseudonym> Just thinking about the properties of Chebyshev approximations.
22:11:48 <goltrpoat> a chebyshev approximation of the original function?
22:11:53 <Pseudonym> Sure.
22:12:09 <goltrpoat> one of the nice things about it is precisely the fact that higher order approximations don't get as wonky as just fitting an arbitrary higher order polynomial to the function
22:12:14 <Pseudonym> Because the error curve is typically going to "wiggle" around the approximated function.
22:12:45 <Pseudonym> Higher order approximation == more wiggles.
22:13:14 <Pseudonym> I can also imagine that it won't help with Fourier synthesis, either.
22:13:45 <goltrpoat> i.e. if you sample a function at n points, and fit f(x) = sum_k a_k x^k to it, it gets pretty wild, in terms of the "wiggles", as n goes above 4 or 5
22:14:02 <goltrpoat> chebyshev approximations are much more well-behaved
22:14:59 <Pseudonym> An analytic derivative of the Gibbs phenomenon is going to be even more useless than the ringing in the approximation itself.
22:14:59 <Pseudonym> goltrpoat, I'm not arguing that Chebyshev approximations are badly behaved.
22:16:39 <Pseudonym> What I'm thinking (and I haven't checked!) is that using a Chebyshev approximation to evaluate a function might give a very poor approximation of that function's derivative.
22:16:40 <goltrpoat> <Pseudonym> And the higher order the approximation, the worse the relative error might get.
22:16:40 <goltrpoat> that's simply not the case
22:16:40 <Pseudonym> We're talking analytic derivatives here.
22:16:41 <Pseudonym> The higher order the approximation, the worse the relative error of the _derivatives_ might get.
22:16:41 <dons> it would be fun if computer scientists named more functions and data structures after themsevles. 
22:16:41 <dons> we could all be using Moggi Phenomena..!@
22:16:50 <dons> and Peyton-Jones Analysis
22:18:45 <dons> lambdabot would be known as the Bromage Bot
22:18:46 <goltrpoat> pseudonym:  the only case i can think of is if the function is not differentiable in sufficiently many places
22:18:46 <Pseudonym> Well, I do use the Hughes context passing transformation.
22:18:46 <Pseudonym> I thinkRalf Hinze even called it that.
22:18:46 <Pseudonym> goltrpoat: You might be right.
22:18:46 <dons> and edision, boo. should be the Okasaki Occultation
22:18:46 <Pseudonym> I think I'm right about the Gibbs phenomenon, though.
22:18:47 <Pseudonym> If there's a discontinuity in the derivative, it's going to show Gibbs ringing.
22:18:48 <Pseudonym> If you're doing a Fourier synthesis.
22:22:33 <mahogny> if Gibbs is a problem, consider using a better basis
22:23:19 <goltrpoat> good point
22:23:39 <Pseudonym> No, you're missing my point.
22:23:58 <Pseudonym> If you have a function which is continuous, a Fourier approximation might be very appropriate.
22:24:17 <Pseudonym> But if the derivative isn't continuous, using that same approximation to compute an analytic derivative might be horrible.
22:24:48 <goltrpoat> well.. picking a random approximation scheme without looking at what the function is, is probably a bad idea in general
22:25:15 <Pseudonym> I agree.  My point is that using this autodiff tool is a bad idea.
22:26:04 <mahogny> it is clear that the appropriate approximation is very dependent on the function AND what you are gonna use the approximation for :)
22:26:04 <Pseudonym> Precisely because it doesn't look at what the function is.
22:26:32 <goltrpoat> oh.. they're not approximating the derivative though
22:26:33 <mahogny> there are ways out without looking at the function. just take a more general scheme, assume less
22:26:36 <goltrpoat> all the links ive found claim that you basically take a program, and analytically differentiate it with respect to some or all inputs
22:26:43 <Pseudonym> Yes, I see that.
22:27:01 <Pseudonym> But if the program is an approximation to begin with.
22:27:16 <Pseudonym> Even if it's a good one...
22:27:25 <Pseudonym> The analytic derivative might not be a good approximation to the "true" derivative.
22:27:44 <goltrpoat> huh?
22:27:44 <mahogny> well, if you just wanted a point differential estimate, I would go with the simplest imaginable test function; a hyperplane under L2
22:28:39 <goltrpoat> the point isn't to generate the derivative of whatever the program is trying to model, it's to generate the derivative of the program.  i was/am confused on two points:  a) what does one use this for, b) what does one do about degenerate cases
22:28:48 <Pseudonym> Right.
22:29:10 <Pseudonym> I was just finding anothe reason why it's a dumb idea.
22:29:16 <goltrpoat> oh
22:29:34 <Pseudonym> You can think of it as another degenerate case.
22:29:50 <mahogny> this is like any case when you want a numerical differential. nothing new or strange about it
22:30:44 <goltrpoat> mahogny:  the page has links to packages for automatic differentiation of c++ and fortran.  it's not just automatic symbolic differentiation in the usual sense
22:31:10 <mahogny> goltrpoat, numerical differential yes. used them plentiful
22:31:10 <kzm_> dons: one question about a patch..
22:32:22 <goltrpoat> mahogny:  i don't think we're talking about the same thing
22:34:11 <goltrpoat> ive had to differentiate/integrate things numerically, to, say, solve a PDE on a lattice.  i've had to differentiate a simple AST analytically, to write a little geometric primitives language where you could pass a curve, and it'd automatically find the tangent basis for it and build a tube around it, or some such
22:34:20 <goltrpoat> i don't think this has anything to do with either of those things.
22:34:57 <Pseudonym> Solving PDEs on lattices is fun.
22:35:07 * mahogny loves PDE
22:35:32 <Pseudonym> http://andrew.bromage.org/fluid.mpeg <- Navier-Stokes
22:35:43 <Pseudonym> Not written in Haskell, though.
22:35:56 <mahogny> NS is one evil bitch
22:36:07 <Pseudonym> It is.
22:36:15 * mahogny is working on it now
22:36:22 <Pseudonym> What method are you using?
22:36:29 <mahogny> lattice boltzmann
22:36:36 * Pseudonym nods
22:36:43 <Pseudonym> I used a semi-Lagrangian method.
22:36:51 <Pseudonym> Which is nice because it's unconditionally stable.
22:37:06 <Pseudonym> It dissipates quite a bit, though.
22:37:13 <Pseudonym> Looking into SPH next.
22:37:29 <mahogny> I'm working on a new model for NS that also accounts for heat in an acceptable way. LBE has the nice property that all turbulent terms become easy to handle
22:38:11 <Pseudonym> Right.
22:38:24 <Pseudonym> Actually, I saw one method which had an interesting approach for handling turbulence.
22:38:25 <Pseudonym> Basically, you advect the "curl" of the velocity field too.
22:38:26 <mahogny> hm
22:38:40 <Pseudonym> It's not valid if you want an accurate solution, but for animation (where it just has to look right) it's quite convincing.
22:38:47 <mahogny> is this in any way similar to normal k-eps modeling?
22:38:54 <Pseudonym> Not sure.
22:39:28 <goltrpoat> pseudonym:  was that the jos stam paper?
22:40:01 <Pseudonym> Kind of.
22:40:13 <Pseudonym> I used the Stam paper, but I used a MAC grid.
22:40:22 <Pseudonym> Stam used cell-centred velocities.
22:41:15 <goltrpoat> ah ok
22:41:16 <Pseudonym> It makes the dissipation equation more horrible.
22:41:16 <Pseudonym> MAC grids make central differencing nice.
22:41:31 <goltrpoat> i used it a while back, i remember there was some room for optimization as well
22:41:38 <Pseudonym> Yeah.;
22:41:57 <Pseudonym> SPH looks very interesting.
22:42:11 <Pseudonym> SPH and variations thereof.
22:42:26 <Pseudonym> I think it'd be interesting to make a hybrid of SPH and lattice methods.
22:42:57 <goltrpoat> ive been playing with a boundary-element method actually
22:43:08 <Pseudonym> That also looks cool.
22:43:17 <Pseudonym> The trouble is what to do when the boundary becomes complex.
22:43:27 <goltrpoat> indeed
22:43:50 <Pseudonym> Maybe you could track the boundary with a level set.
22:44:38 <mahogny> you know any good programs for 3d visualization of data? I consider using matlab as usual but it's a bit slow
22:44:53 <hyrax42> I thikn I "left factored" that mess with the #
22:44:54 <Pseudonym> I just use Renderman. :-)
22:44:58 <mahogny> omg
22:45:04 <goltrpoat> im tracking the boundary with a triangle mesh and re-tesselating on self-intersection.. it looks nice for a while, but the number of triangles goes to shit after a while
22:45:06 <hyrax42> I take the # by itself, and decide what to do based on what follows
22:45:12 <hyrax42> (dunno if that's the right term)
22:45:19 <goltrpoat> minus one of the "after a while"s
22:49:09 <goltrpoat> it only models incompressible fluids, but the nice thing is that you have direct control over the volume and over whatever interface parameters there might be
22:49:47 <goltrpoat> ("only" in contrast to SPH i mean)
22:50:59 <Pseudonym> Right.
22:51:09 <Pseudonym> Well, I'm personally only interested in incompressible fluids.
22:51:21 <Pseudonym> Though I'm interested in fluids with non-constant viscosity.
22:51:41 <Pseudonym> Like melting solids.
22:54:17 <goltrpoat> pseudonym:  things get weird with non-linear viscoelastics, iirc..  reciprocity doesn't apply, things stop being symmetric, etc.
22:55:24 <goltrpoat> but i guess FEM methods don't particular care about that, as long as each element is linear
22:55:31 <goltrpoat> particularly, rather
22:55:33 <goltrpoat> can't type for some reason
22:59:43 <hyrax42> @type >>=
22:59:45 <lambdabot> parse error on input `>>='
22:59:55 <hyrax42> @type (>>=)
22:59:56 <lambdabot> forall (m :: * -> *) b a.
22:59:56 <lambdabot>    (Monad m) =>
22:59:56 <lambdabot>    m a -> (a -> m b) -> m b
23:10:00 <dons> kzm_: constant space handling of 10G files is fun. I wonder if we could code up some bioinformatics benchmarks in Data.ByteString.Lazy?
23:12:47 <Korollary> dons, you seem to be obsessed with large... strings.
23:13:36 <dons> well, its something people complain about, and we haven't done well in the past
23:14:27 <dons> "Boo boo, Haskell is stoopid, it can't handle my 4G blah blah file. I'll come back when its' less experimental. Lusers!" or something like that.
23:16:21 <dons> but this is how we advance thing: fix $ find things that don't work >>= make them work.
23:16:57 <dons> but the main benefit is being able to flame people who complain
23:16:59 <dons> ;)
23:19:36 <goltrpoat> people actually say "boo boo" ?
23:20:10 <dons> some do, I suppose :}
23:20:25 <Pseudonym> dons just did
23:20:28 <Pseudonym> And so did you.
23:20:36 <dons> its spreading!!
23:20:50 <Saulzar> Boo boo!
23:20:52 <goltrpoat> i guess i'll use that expression when it's less experimental
23:20:59 <dons> hehe!
23:21:02 <goltrpoat> :)
23:21:10 <Pseudonym> Presumably "boo hoo" is deprecated.
23:21:35 <dons> yeah, the 'hoo' was redundant.
23:22:00 <Korollary> poo poo, perhaps?
23:28:41 <hyrax42> >>= no longer scares me
23:29:16 <dons> cool :)
23:29:46 <dons> hyrax42 reaches level 2 monad hacker
23:29:46 <hyrax42> though I've only used it in IO and Parser much
23:29:49 <hyrax42> yay :)
23:30:17 <hyrax42> I just realised a given thing in this tutorial that was in do notation
23:30:28 <hyrax42> I thought would be nicer with explicit bind
23:33:13 <Cale> hyrax42: I did get you to read Monads as Containers, right?
23:33:23 <hyrax42> yeah
23:33:30 <Cale> good, just checking :)
23:33:33 <hyrax42> but I stopped half way (woops)
23:33:39 <hyrax42> I should go back and read the ST part
23:33:53 <hyrax42> (in my defense, I was in the middle of exams)
23:33:59 <Cale> I wrote about ST? :)
23:34:18 <Cale> Probably the Reader/State part
23:34:26 <kzm> dons - sorry 'bout the delay, had to go to work :-)
23:34:37 <Cale> (ST is something else)
23:35:21 <hyrax42> oh
23:35:21 <hyrax42> my bad
23:35:21 <kzm> Big string benchmarks is my middle name.
23:35:21 <kzm> But I guess you don't want to spend too much actually computing on the string :-)
23:35:25 <Cale> You have three middle names?
23:35:33 <Cale> I only have two
23:35:48 <hyrax42> I have 0+
23:35:57 <kzm> Huh, how can you have two *middle* names? 
23:36:18 <kzm> I'd think it'd be one slightly-left-of-middle-name, and another slightly-right-of?
23:37:04 <hyrax42> first middle* last
23:37:04 <Cale> A name is said to be 'middle' if it is not the first name or the last.
23:37:04 <kzm> And if you call the tail a leg...
23:37:13 <kzm> :-)
23:40:23 <hyrax42> ack my bind thingy doesn't work :(
23:40:24 <hyrax42> back to level 1 for me
23:40:41 <hyrax42> parseQuoted = char '\'' >> parseExpr >>= (return . List . (Atom "quote":))
23:41:13 <sieni__> I had two middle names, but got rid of both, since my bank was being an asshole and refused to remove the middle names from the mail they send me otherwise
23:41:24 <sieni__> idiots
23:41:33 <hyrax42> can't figure out what's wrong
23:41:58 <Cale> hyrax42: what's the type of parseExpr?
23:42:12 <hyrax42> Parser LipsVal
23:42:28 <Cale> Is LispVal a synonym for a list type?
23:43:09 <hyrax42> List is a constructor for LispVal that takes [LispVal]
23:43:09 <hyrax42> no
23:43:10 <hyrax42> it's some value for the scheme... can be numbers lists, characters, strings etc.
23:43:25 <Cale> then it won't work, since the first thing you're doing is trying to cons (:) the Atom "quote" onto that LispVal
23:43:44 <hyrax42> d'oh!
23:45:20 <hyrax42> har
23:45:28 <hyrax42> added a . (:[]) on there
23:45:34 <hyrax42> I get the feeling it's reaching unreadabilty
23:48:59 <Cale> You could write return instead of (:[]) too ;)
23:50:25 <hyrax42> how does that work?
23:50:26 <hyrax42> I'm in parser monad, can't mix returns?
23:50:28 <Cale> well, you can apply return wherever it would have a reasonable type
23:50:34 <Cale> it's polymorphic
23:50:48 <hyrax42> magic
23:51:01 <hyrax42> gah
23:51:01 <hyrax42> 3am!
23:51:05 <Cale> you can actually use as many monads as you like all at once, though if you do it randomly, it can get confusing :)
23:51:12 * hyrax42 having too much fun
23:52:21 <dcoutts> dons, I thought the flamers/complainers said "are you fully nerd????"
23:52:24 <ulfdoz> Although my problem is not related to haskell directly, you probably can help: I want to describe a directed acyclic graph. How can I ensure that it doesn't contain cycles at construction?
23:53:33 <ulfdoz> Actually it is a dependency graph.
23:54:25 <goltrpoat> never add an edge from a to b when b already has an incident edge?
23:54:40 <goltrpoat> oh wait.. i'm on crack, that's too strict
23:55:09 <dcoutts> dons, oh, 4GB! You've added some IO functions then?
23:56:17 <ulfdoz> The thing is, I read in a textual representation of that graph and do not have an easy way to postprocess the constructed graph afterwards.
23:56:52 <goltrpoat> google for strongly-connected components i guess
23:56:52 <Cale> Add a vertex along with its inarcs, and only allow inarcs from existing vertices.
23:57:14 <dons> dcoutts: yeah, I added all the io functions. and 10G benchmarks..
23:57:23 <dcoutts> cool :-)
23:57:30 * dcoutts darcs pulls
23:57:52 <dcoutts> dons, did you see that tricky split one I was burbling about last night?
23:58:08 <dons> yeah, looks tricky. i see that splitWith is still borked too. its hard as well.
23:58:12 <hyrax42> all right, bed for me
23:58:18 <hyrax42> thanks guys
23:58:22 <Cale> 'night
23:59:02 <dcoutts> dons, oh yes. I fixed split and presumably splitWith will work the same way, but I was too tired.
23:59:11 <goltrpoat> actually.  is the problem basically along the lines of..  you have a graph, you're adding a vertex along with some edges that either start or end at that vertex, and you want to make sure that that addition is valid?
23:59:28 <goltrpoat> because then you can just do a DFS and see if you reach the newly added vertex.. if so, it's broken
23:59:32 <dons> dcoutts: the api is almost all done:) its looking very nice.
