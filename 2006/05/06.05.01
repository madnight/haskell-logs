00:00:23 <palomer> oh, no, it's not true
00:00:33 <Cale> A set I is called directed if for every x, y in I, there is some z in I such that x <= z and y <= z.
00:00:39 <palomer> check it out
00:00:47 <palomer> \x -> error "hello"
00:01:03 <palomer> or, even better
00:01:04 <palomer> \x -> x
00:01:15 <palomer> bool -> bool and int -> int are in the set that types that term
00:01:19 <Cale> sure
00:01:21 <palomer> yet they're incomparable
00:01:24 <Cale> so is a -> a
00:01:35 <palomer> oh wait, we're looking for on upper bound
00:01:50 <palomer> well, the principle type is the upper bound
00:01:58 <Cale> supposing that it exists :)
00:02:20 <Cale> However, if you don't have that, you'd probably at least like the types for a term to form an ideal.
00:02:36 <palomer> very interesting
00:03:18 <Cale> I'm not sure if you'll get it though
00:03:37 <palomer> I'm pretty sure I won't
00:03:54 <palomer> actually, I'm positive I won't
00:04:07 <palomer> (you definitely don't with GADTs in general)
00:05:08 <Cale> I suppose that for it to be directed, but nonprincipal, there would have to be an infinite ascending chain of types for the term.
00:05:27 <Cale> (well, really, many such chains)
00:06:09 <Cale> no, just one is sufficient
00:06:11 <palomer> there isn't
00:06:14 <Cale> it's also necessary
00:06:24 <Cale> so that's out of the question then
00:06:25 <palomer> actually, there is
00:06:34 <palomer> well, it depends
00:06:34 <Cale> really?
00:06:41 <palomer> do you allow infinite types?
00:06:43 <palomer> if not, then no
00:07:04 <Cale> well, not infinite types -- but I don't see that you'd need them
00:07:13 <palomer> I'm being silly, of course you have infinite ascending chains
00:07:31 <palomer> a ~> (b -> b) ~> (c->c)->(c->c) ~> ...
00:07:55 <Cale> that's descending
00:08:02 <palomer> nope, ascending
00:08:10 <palomer> a subsumes b -> b
00:08:16 <Cale> right.
00:08:23 <Cale> a > (b -> b)
00:08:27 <palomer> oh, righto
00:08:29 <palomer> descending
00:08:34 <palomer> you have no ascending chains
00:08:39 <palomer> (infinite)
00:08:55 <Cale> hmm...
00:09:56 <Cale> Is forall a. b -> a comparable with forall a. a -> a ?
00:10:16 <Cale> (I doubt it)
00:10:27 <palomer> you mean forall a b.  b -> a ?
00:10:29 <Cale> no
00:10:42 <Cale> b is some other arbitrary type
00:10:42 <palomer> so you have uninstantiable variables
00:10:57 <Cale> like, it could be Bool or somethign
00:11:00 <Cale> something*
00:11:12 <Cale> forall a. Bool -> a
00:11:25 <palomer> nope, they're noncomparable
00:11:32 <palomer> they are, however, unifiable
00:11:33 <Cale> right, okay
00:11:37 <palomer> which means they have a least upper bound
00:12:18 <Cale> yeah, I was just confusing myself with a finer order on types which I once read about.
00:13:21 <Cale> okay, then I agree, I don't think there are any infinite ascending chains
00:13:30 <Cale> hmm
00:14:14 <palomer> it's not a priori obvious, though
00:14:29 <palomer> I think you could argue from an information theory point of view
00:15:03 <palomer> keep in mind that a -> b and b -> a are equivalent types
00:15:42 <palomer> and that a < a -> a
00:17:16 <palomer> this is how I would go about proving it:
00:17:46 <palomer> if tau < sigma and both tau and sigma have the same structure, then tau must have a variable not in sigma
00:18:36 <palomer> if tau < sigma and they don't have the same structure, then tau has a "smaller" structure, for some definition of the word smaller
00:22:37 <palomer> ugh, have to submit a proposal by may 8th
00:22:40 <Cale> hmm
00:24:22 <palomer> rather, if tau < sigma, and both tau and sigma have the same structure, then tau is alpha equivalent to a type which contains all the variables in sigma and at least one more
00:24:45 <Cale> hmm
00:25:03 <Cale> sigma subsumes tau, but tau has more variables?
00:25:12 <palomer> tau subsumes sigma
00:25:21 <palomer> the more general types are at the bottom
00:25:29 <Cale> that's odd :)
00:25:38 <palomer> we agreed upon this before!
00:26:02 <palomer> oh wait, we hadn't
00:26:08 <palomer> I was right, no ascending chains
00:26:10 <Cale> I've been putting more general types at the top for the whole discussion, otherwise I'd have been talking about filters instead of ideals.
00:26:29 <palomer> yeah, more general on the bottom was a trend started by plotkin
00:26:47 <palomer> I believe
00:27:17 <palomer> set-wise it doesn't make sense, since the set of types instantiables decreases as you instantiate
00:27:23 <palomer> so you should be moving down the lattice
00:27:55 <palomer> s/instantiables/instantiable
00:28:27 <palomer> however, if you look at it in terms of unifiers, it makes sense
00:28:49 <Cale> I'll chalk it up to how CS people always like to draw things upside down -- trees especially :)
00:28:53 <palomer> if you add, set wise, to a unifier, it should go up
00:29:12 <Cale> directed sets are kind of like trees :)
00:29:25 <palomer> there's a good reason why proof trees are upside down
00:29:33 <palomer> because one reasons top to bottom
00:29:43 <Cale> though I suppose in this case, they actually have it more like a right-side up tree
00:29:55 <palomer> you'd like to see the premise before the conclusion, no?
00:29:59 <Cale> sure
00:30:06 <palomer> so you put the premise on top
00:30:44 <Cale> proof trees barely look like trees anyway :)
00:30:49 <palomer> anyways, if you look at substitutions as sets, then when you add to the substitution you should go up, thus most general substitutions at the bottom
00:30:57 <palomer> they branch! what more do you want?
00:31:01 <Cale> hehe
00:31:26 <palomer> so we associate generality with bottomness, I guess
00:32:12 <Cale> okay, then we're looking at whether the set of types which a term satisfies is a filter
00:32:23 <palomer> how many students is haskell.org going to get, do you guys think (ie, what are my chances)
00:32:30 <palomer> Cale: with or without gadts?
00:32:46 <Cale> palomer: well, without, it's certainly true
00:32:51 <Cale> with, I doubt it
00:32:57 <Cale> (but it would be nice)
00:33:06 <palomer> we need lower bounds?
00:33:08 <palomer> we have lower bounds
00:33:19 <palomer> we have a bottom, after all
00:34:17 <Cale> We need:
00:34:31 <palomer> oh, the lower bound needs to be part of the filter
00:34:34 <Cale> For every x, y in F, there is some z in F such that z <= x and z <= y.
00:35:01 <Cale> For every x in F, if x <= y, then y is in F.
00:35:51 <palomer> I can construct a term with the following types: Term (a,b) -> a and Term (a,b) -> b
00:35:56 <Cale> The second one is easy, you'd always want that to be true, or your subsumption relation or typing relation, or something is broken.
00:36:33 <palomer> the greatest lower bound of that is Term (a,b) -> c
00:36:39 <Cale> yeah
00:36:48 <Cale> and it's probably not in there.
00:37:03 <palomer> actually, hrm, lemme think if I can actually construct it
00:37:24 <palomer> yes, quite easily
00:37:51 <palomer> though Term (a,b) will only be inhabited when a == b
00:38:02 <palomer> (meaning those two types are really the same)
00:38:21 <palomer> I've constructed more complicated terms for which this doesn't hold
00:38:24 <palomer> so it's not a filter
00:38:47 <palomer> indeed, if it was a filter it would be principly typed ,no?
00:39:05 <palomer> s/principly/principally
00:39:35 <Cale> not necessarily, depending on the nature of the type poset.
00:40:21 <palomer> you see, it has a finite number of minimal types
00:40:46 <palomer> so principal typeness follows
00:40:54 <Cale> (in general, filters need not be principal though)
00:41:15 <palomer> you'd need an infinite number of minimal types
00:41:23 <Cale> yes
00:41:41 <palomer> so it's not a filter
00:42:59 <Cale> I wonder if there's anything more that we can say apart from "it's an upper set"
00:43:06 <palomer> data Term :: * -> * -> * where C :: a -> Term a a ; foo (C x) = x; <--foo is not principally typed
00:43:53 <palomer> it has types Term a a -> a, Term a b -> a and Term a b -> b
00:44:07 <Cale> hmm
00:44:09 <palomer> the last 2 are minimal
00:45:16 <palomer> (though, in my system, it is principally typed)
00:45:42 <palomer> man, I need to get to bed
00:45:46 <palomer> night!
00:45:47 <Cale> me too
00:45:48 <Cale> night
01:02:13 <lightstep> the Data.ByteString documentation says that there is a function hash :: ByteString -> Int32, but the sources don't contain this function
01:06:25 <dons> its been removed from the darcs src, as it isn't portable to some haskell implementations. however, its still in the tarballs for 0.5, and in the tests/spellcheck.hs file.
01:06:52 <lightstep> cool
01:07:08 <dons> if you need it (primarily it would be used to insert into Data.HashTables)
01:07:33 <lightstep> i was just interested what it was
01:07:53 <dons> just a string hashing function
01:08:11 <dons> ord (ps `P.unsafeIndex` n) + acc * 128 `rem` fromIntegral prime
01:08:58 <lightstep> except no modulo by a prime (it won't buy you anything anyway)
01:09:15 <lightstep> won't it be slow on large strings?
01:10:07 <dons> haven't tried it on large strings. only on the spellcheck benchmark.
01:10:16 <dons> i'd imagine you wouldn't be using very large strings as hash keys, though?
01:10:34 <lightstep> lua does that
01:10:46 <dons> shrug. its not terribly useful, and its not in the src anymore. 
01:10:46 <lightstep> well, actually they internalize all strings
01:10:58 <dons> internalize?
01:11:12 <lightstep> like symbols in lisp
01:11:17 <lightstep> (or so they say)
01:20:03 <neologism> I am thinking about chosing master thesis - implementation of OO Haskell
01:20:08 <neologism> what do you think? is it hard?
01:22:01 <sieni> neologism: like
01:22:15 <neologism> like?
01:24:59 <Lokadin> say is there any way of displaying a pdf file different from what it actually is, say changing background and text and taking out pages, so it's an easily readable format? i mean besides ripping out the text
01:51:40 <Lokadin> how can i add a prompt?
01:51:59 <Lokadin> like make a prompt
01:52:33 <Lokadin> why does it always no matter what i do, instead of being a prompt append itself to the next piece of output
01:53:31 <Cale> Lokadin: probably either there's a problem with your terminal or with the buffering setting
01:53:46 <Lokadin> well i set LineBuffering
01:53:52 <Lokadin> let me try xterm
01:54:20 <Cale> LineBuffering won't do for a prompt
01:54:42 <Cale> since you won't flush the output buffer until the line is finished
01:54:50 <Lokadin> oh
01:55:26 <Cale> either set NoBuffering, or use hFlush on stdout
01:55:42 <Lokadin> kk thanks :) 
01:57:27 <Lokadin> @type hFlush
01:57:28 <lambdabot> Not in scope: `hFlush'
01:57:36 <Lokadin> hmmm
01:57:39 <Cale> @type System.IO.hFlush
01:57:40 <lambdabot> GHC.IOBase.Handle -> IO ()
01:57:46 <Lokadin> kk thanks :)
01:58:13 <Lokadin> yay!! *hugs Cale*
02:00:52 <Cale> I take it you got it working :) What are you writing?
02:05:13 <Lokadin> er i'm writing a shell
02:05:15 <Lokadin> of sorts
02:05:26 <Lokadin> though i want it to be a smarter shell than the usual
02:05:36 <Lokadin> some plain english support
02:05:48 <Lokadin> thought that's a long term goal
02:06:20 <Lokadin> meanwhile just smart tab-completion, and multi-script support
02:18:18 <goron> ghc --make Modulename does not give me a binary on Windows. Is that normal? I do get an objectfile. 
02:18:37 <Heffalump> did you give it a -o flag?
02:18:49 <goron> Heffalump: no
02:19:00 <Heffalump> I don't know what name it picks by default on Windows.
02:19:08 <Heffalump> but are you sure that name isn't there?
02:19:22 <Heffalump> on Linux you'd get a file called a.out if you didn't use -o
02:19:38 <goron> Heffalump: I know how it works on Linux.
02:19:59 <goron> Heffalump: I get an interface file (hi) and an object file .o
02:20:01 <Lokadin> @hoogle runInteractiveCommand
02:20:02 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
02:21:02 <goron> Heffalump: I already see the problem.
02:22:45 <Lokadin> say what is the general ethical usage of $, like can i just use it whenever i can, or is that not as readable?
02:23:02 <Heffalump> I think it's a matter of taste rather than ethics :-)
02:23:10 <Heffalump> different people prefer different things
02:23:16 <Lokadin> kk
02:23:50 <Heffalump> goron: fair enough, what was it?
02:23:53 <ellism> Trying to build the two most recent dev snapshots of GHC yield errors in stage2.  The error is that the module `System.Consloe.Readline' could not be found.  It looks like it is  trying to build something related to GHCi
02:24:04 <Heffalump> does it really say Consloe?
02:24:08 <Heffalump> or did you retype it?
02:24:49 <ellism> Console, sorry
02:25:39 <Lokadin> should this work? putStrLn =<< return =<< hGetContents out
02:26:02 <Heffalump> the return looks a bit fishy to me
02:26:07 <Heffalump> well, unnecessary
02:26:21 <Heffalump> @type putStrLn =<< return =<< hGetContents out
02:26:23 <lambdabot> Not in scope: `hGetContents'
02:26:23 <lambdabot>  
02:26:23 <lambdabot> <interactive>:1:37: Not in scope: `out'
02:26:30 <Heffalump> @type \out -> (putStrLn =<< return =<< hGetContents out)
02:26:31 <lambdabot> Not in scope: `hGetContents'
02:26:38 <Heffalump> @type \out -> (putStrLn =<< return =<< System.IO.hGetContents out)
02:26:39 <lambdabot> GHC.IOBase.Handle
02:26:39 <lambdabot>                       -> IO ()
02:26:46 <Heffalump> I expect it'll work then.
02:26:58 <Lokadin> kk
02:27:07 <Heffalump> @type \out -> (putStrLn =<< System.IO.hGetContents out)
02:27:08 <lambdabot> GHC.IOBase.Handle
02:27:08 <lambdabot>                   -> IO ()
02:27:18 <Heffalump> but the return is completely unnecessary unless I'm very confused
02:27:23 <Lokadin> thanks :) cause it compiled just doesn't seem to produce output, but that actually could be because of ...
02:27:26 <Lokadin> kk thanks :)
02:27:35 <Lokadin> return is unnecessary
02:27:42 <Lokadin> i tried it without :)
02:27:45 <Lokadin> thanks
02:35:38 <Lokadin> hmmm any way of making the command shell to support colors?
02:36:25 <Oejet> Yay, 200 people!
02:37:19 <goron> Heffalump: I did not have a Main module. 
02:37:47 <Oejet> Wow, #java has grown too.
02:40:26 <Lokadin> well we are close on their tails
02:40:28 <Heffalump> goron: ah, ok
02:40:36 <Lokadin> :P
02:40:37 <Lokadin> :)
02:40:59 <Lokadin> say how do i put if a list is not full then true
02:41:08 <Lokadin> cause null list will be true
02:42:00 <tromp> > null []
02:42:01 <lambdabot> True
02:42:05 <liyang> full? in what sense?
02:42:47 <Lokadin> er not full as in it's not empty
02:42:50 <tromp> > null (undefined:undefined)
02:42:52 <lambdabot> False
02:43:16 <Muad_Dibber> > not $ null []
02:43:18 <lambdabot> False
02:43:27 <Lokadin> thanks :)
02:43:42 <tromp> > null "null"
02:43:43 <lambdabot> False
02:43:45 <tromp> :-)
02:47:57 <yozora> Are there any plans to allow existential quantification without having to define a datatype?
02:48:14 <MarcWeber> Is there any package to add to the dependency list in a cabal file to import Char?
02:51:39 <Lokadin> do you have to have an else statement in an if?
02:51:58 <jyp> yes
02:52:05 <Lokadin> oh
02:52:07 <Lokadin> wow
02:52:16 <Lokadin> er so do i just return () if i don't need anything?
02:52:41 <jyp> you can also use the when function in that case
02:52:46 <jyp> @hoogle when
02:52:47 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
02:52:47 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
02:53:02 <Lokadin> oh
02:53:07 <Lokadin> thanks :)
02:53:17 <jyp> np
02:57:31 <dcoutts_> xerox, did you ping me?
02:57:57 <dcoutts_> (or maybe that was ages ago)
02:57:59 <xerox> Hmmm.
02:58:08 <dcoutts_> xerox, oh but I'm now listed as a haskell.org mentor
02:58:17 <dcoutts_> and can see all zero of our applications
02:58:34 <dcoutts_> or maybe since it's now Monday there are >0 student applicatiuons :-)
02:58:37 * dcoutts_ checks
02:58:57 <xerox> It depends upon the students I fear :-)
02:59:37 <psi> when do all the applications have to be in?
03:00:14 <thaldyron> psi: 8th May
03:00:38 <psi> okay
03:01:59 <psi> hIDE looks interesting. could someone estimate the level of experience needed to work on that? :-)
03:03:06 <dcoutts_> psi, depends on which part
03:03:07 <xerox> psi, hIDE isn't exacly working atm http://haskell.org/hIDE
03:03:19 <dcoutts_> psi, what aspect are you interested in?
03:03:26 <xerox> But there are some projects that needs to be done in order to get hIDE back on track
03:03:32 <dcoutts_> eg GUI bits, ... etc
03:04:17 <dcoutts_> I had hIDE working not so long ago
03:04:33 <dcoutts_> there are bits that depend too heavily on hs-plugins that tend to break
03:05:09 <psi> dcoutts_: I'm not sure what it's capable of currently, but I'd like to see things such as "real-time" type checking and similar coding assistance things
03:05:31 <dcoutts_> psi, it does real time type checking
03:05:46 <dcoutts_> but there's room for lots more similar coding assistance things
03:06:03 <dcoutts_> eg jump to definition, jump to documentation
03:06:13 <psi> ok
03:06:29 <psi> I assume it does syntax checking?
03:06:33 <dcoutts_> psi, if you go for that, to keep things sane, try avoiding the plugins aspect
03:06:47 <DeliQ> say i want to compose other things than functions, can i overload (.) ?
03:06:48 <dcoutts_> psi, yes, it uses ghc-api for syntax & type checking
03:06:59 <dcoutts_> DeliQ, no
03:07:10 <DeliQ> hmm, bummer :P
03:07:12 <lightstep> DeliQ, you can, but it's very hard, and doesn't do much good, usually.
03:07:25 <DeliQ> ok, thank you!
03:07:30 <dcoutts_> not unless you make a new (.) in a new module and use it like: f Foo.. x
03:07:42 <psi> xerox: what other things need to be done?
03:07:52 <lightstep> dcoutts_, or hide Prelude..
03:07:54 <dcoutts_> psi, ask Lemmih about hIDE hacking tasks
03:07:58 <xerox> psi: ghc-plugins.
03:07:59 <dcoutts_> lightstep, indeed
03:08:07 <xerox> And yes, absolutely, ask Lemmih.
03:08:11 <psi> ok
03:08:58 <Lokadin> return String IO
03:09:01 <Lokadin> hmmm
03:09:27 <davidhouse> @localtime dons
03:09:28 <dcoutts_> Lemmih, did I say that I'm getting closer to having a decent file tree browser widget?
03:09:30 <lambdabot> Local time for dons is Mon May  1 20:10:39 2006
03:09:34 <davidhouse> dons, ping
03:09:41 <Lokadin> @localtime lokadin
03:10:08 <Lokadin> @localtime Lokadin
03:10:10 <Lokadin> hmmm
03:10:14 <lambdabot> Local time for Lokadin is Mon May  1 06:09:47 2006
03:10:22 <Lokadin> crazy
03:10:25 <Lokadin> it works!
03:10:26 <Lokadin> :)
03:12:03 <DeliQ> @localtime DeliQ
03:12:05 <lambdabot> Local time for DeliQ is Mon May  1 12:11:59
03:12:14 <lightstep> @localtime lightstep
03:12:14 <DeliQ> hehe
03:12:15 <lambdabot> Local time for lightstep is Mon May  1 13:11:54
03:12:40 <lightstep> does time sometimes walk backwards?
03:12:47 <Lokadin> @type return
03:12:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
03:12:56 <Lokadin> @type read
03:12:57 <lambdabot> forall a. (Read a) => String -> a
03:13:41 <Lokadin> so how do i convert an IO String to normal string in a let statement?
03:14:13 <mauke> you don't
03:14:21 <Lokadin> (\x -> x) <- hGetContents out
03:14:22 <neologism> how do I Int -> Float ?
03:14:34 <Lokadin> mauke: why not? :(
03:14:38 <davidhouse> Lokadin: oh, it's easy in a do statement.
03:14:40 <Igloo> neologism: fromIntegral
03:14:43 <mauke> Lokadin: what are you trying to do?
03:15:07 <neologism> thnx
03:15:48 <Lokadin> mauke: well trying to get the stdout to be a String so if it's non empty i can output some text
03:16:16 <neologism> Igloo: and back?
03:16:19 <Lokadin> and i wanted to use let so it' doesn't perform the transformation twice
03:16:24 <mauke> Lokadin: that doesn't make any sense
03:16:28 <mauke> try again
03:16:42 <Lokadin>  when (not $null output) $ putStrLn "Output: " ++ output
03:16:49 <Lokadin> output being stdout
03:16:53 <Igloo> neologism: floor, ceiling, round, truncate
03:16:54 <JohnMeacham> is Keith Wansbrough on this channel ever?
03:16:56 <davidhouse> Lokadin: because haskell is a "pure" language meaning that if you call a function with some parameters, and then some time later call the same function with the same parameters, it should have _exactly_ the same response. this isn't true in general when messing around with IO (for example, the result of a function may depend on the contents of some file, or the input of a user). so, any functions that do IO have to have 
03:17:02 <mauke> stdout is a filehandle, not an IO String
03:17:37 <davidhouse> Lokadin: also, you probably mean putStrLn $ "Output: " ++ output
03:17:47 <Lokadin> mauke: i'm aware so, hGetContents stdout gives me IO String
03:17:56 <mauke> that's probably invalid
03:18:00 <mauke> you can't read from stdout
03:18:01 <Igloo> Lokadin: do output <- the_io_string; unless (null output) $ putStrLn "Output: " ++ output
03:18:13 <Lokadin> mauke: er it's from interactive command
03:18:17 <davidhouse> Igloo, missed a $
03:18:26 <davidhouse> do output <- the_io_string; unless (null output) $ putStrLn $ "Output: " ++ output
03:18:29 <mauke> Lokadin: what?
03:18:42 <Lokadin> Igloo: kk thanks :)
03:18:56 <flux__> davidhouse, fyi, your (long) message was truncated at 'that do IO have to have'
03:18:57 <Igloo> davidhouse: That'll teach me to copy+paste  :-)
03:19:49 <mauke> *** Exception: <stdout>: hGetContents: illegal operation (handle is not open for reading)
03:20:48 <davidhouse> ... have to have this "IO" tag.
03:21:04 <Lokadin> (inp,out,err,hdl) <- runInteractiveCommand "echo asdf"
03:21:33 <Lokadin> putStrLn =<< hGetContents out
03:21:55 <davidhouse> yes, that would work.
03:21:59 <A-Tui> hi, anyone with experience in building parsers?
03:21:59 <Lokadin> :)
03:22:05 <davidhouse> because that's not stdout, that's the output of another command.
03:22:15 <davidhouse> stdout is what YOUR program prints to.
03:22:17 <davidhouse> A-Tui: just ask ;)
03:22:21 <A-Tui> ok
03:22:24 <A-Tui> thanks
03:22:31 <Lokadin> davidhouse: thanks for clearing that up
03:22:36 <A-Tui> i'm building a SLR parser
03:22:51 <A-Tui> i'm implementing the Follow function
03:23:07 <Lokadin> what is an expression?
03:23:16 <A-Tui> my ask is if that function should we executed with the extended grammar or not
03:24:39 <A-Tui> i think that when building the follow sets i should use the initial grammar but i'm not sure
03:25:49 <Lokadin> it says i need to end the do statement with an expression but i don't know what an expression is.. my other do statements end with function calls
03:26:10 <davidhouse> Lokadin: pastebin some code.
03:26:26 <davidhouse> basically, the last line in your do statement needs to have type IO Something.
03:26:27 <Lokadin> @where paste
03:26:27 <lambdabot> http://paste.lisp.org/new/haskell
03:26:50 <davidhouse> if you have a Something and want to make it an IO Something, you can use return.
03:27:00 <davidhouse> @type "hello"
03:27:01 <lambdabot> [Char]
03:27:02 <lisppaste2> Lokadin pasted "expressionless do statement" at http://paste.lisp.org/display/19565
03:27:11 <davidhouse> @type return "hello" :: IO String
03:27:12 <lambdabot> IO String :: IO String
03:27:39 <davidhouse> odd... that should work
03:28:03 <Lokadin> oi
03:28:05 <Lokadin> i fixed it
03:28:17 <Lokadin> turned out the ( was one space ahead of the others
03:28:32 <davidhouse> oh yeah. heh.
03:28:35 <Lokadin> thanks :)
03:28:41 <davidhouse> Lokadin: by the way, unless is a nice shortcut for when (not $ ...). you could use unless (null output) ...
03:28:58 <Lokadin> oh :) thanks 
03:32:03 <neologism> Evo> piMax' "111111111111111111111111111111"
03:32:03 <neologism> inf
03:32:03 <neologism> Evo> isInfinite $ piMax' "111111111111111111111111111111"
03:32:03 <neologism> False
03:32:07 <neologism> hows that?
03:32:43 <Lokadin> say is there any way of getting the first 2 characters of a string?
03:32:58 <Lokadin> or only the first one?
03:33:00 <musasabi> > take 2 "123456789"
03:33:01 <lambdabot> "12"
03:33:02 <bolrod> > take 2 "te"
03:33:03 <lambdabot> "te"
03:33:08 <Lokadin> wow thanks :)
03:33:09 <bolrod> >:/
03:33:11 <bolrod> :)
03:33:24 <neologism> can anyone explain me why I got this?
03:33:26 <Lokadin> > take 2 ""
03:33:27 <lambdabot> ""
03:33:40 <musasabi> Lokadin: what do you think it should produce?
03:34:03 <Lokadin> well i think that output is fine
03:34:28 <Lokadin> what do you mean?
03:34:40 <musasabi> s/Lokadin/neologism
03:34:49 <davidhouse> > head "hello" -- this gets the first element from a list
03:34:50 <lambdabot> 'h'
03:35:15 <davidhouse> head and take 1 are slightly different in that head :: [a] -> a, but take 1 :: [a] -> [a].
03:35:35 <neologism> musasabi: true?
03:35:56 <neologism> isInfinite inf = true... Id say
03:37:40 <Lokadin> is there any way to get color in console?
03:40:30 <dcoutts_> Lokadin, yes
03:40:49 <Lokadin> how could i do that?
03:41:02 <dcoutts_> be more specific
03:41:14 <Lokadin> er well i want to run sh -c ls --color
03:41:22 <Lokadin> and have color output on in the console
03:41:41 <Lokadin> run it under runInteractiveCommand
03:41:53 <Lokadin> using the output i get from the stdout handle..
03:42:05 <Lokadin> or if there is a better way, i'm all eyes :)
03:42:05 <dcoutts_> ls turns off colour if it notices it's talking to a pipe rather than a terminal
03:42:18 <Lokadin> oh
03:42:19 <dcoutts_> it uses ascii and escape codes
03:42:45 <dcoutts_> so if ls gives you the escape codes and you write them to the console then you'll get colour
03:42:56 <dcoutts_> but ls turns it off I think
03:43:02 <Lokadin> yea it does 
03:43:11 <flux__> --color=off|auto|on
03:43:21 <flux__> (or something to that effect)
03:44:07 <dcoutts_> sh -c "ls --colour=yes"
03:44:29 <Lokadin> kk thanks :)
03:44:50 <dcoutts_> 'ls --colour=auto | cat' gives no colour since it's talking to a pipe
03:45:07 <dcoutts_> 'ls --colour=yes | cat' forces colour output anyway
03:46:04 <Lokadin> hmmm :( still colorless in console though
03:46:16 <Lokadin> doesn't even show the command characters
03:46:29 <Lokadin> oo
03:46:30 <Lokadin> one sec
03:47:02 <davidhouse> dcoutts_, --color, not --colour, i think.
03:47:14 <dcoutts_> er, yeah probably
03:47:34 <xerox> Those british... :-)
03:47:39 <flux__> it might even support both :)
03:47:43 <Lokadin> for some reason it's only taking the first word of what i type
03:47:47 <dcoutts_> Those americans... :-)
03:47:49 <araujo> Morning!
03:47:51 <xerox> heh.
03:47:53 <flux__> nope, it doesn't :)
03:47:57 <flux__> I remember some program that did
03:48:06 <Heffalump> bloody illiterate merkins ;-)
03:49:19 <Lokadin> hmmm
03:49:30 <dcoutts_> Heffalump, you're lucky they're not awake yet :-)
03:50:07 <Heffalump> I expect some people on the west coast won't have gone to bed yet
03:50:48 <davidhouse> living in a country spanning more than one timezone must be weird.
03:51:00 <psi> heh, have you guys seen this - http://www.break.com/index/livemario29.html
03:51:09 <psi> live version of super mario bros.
03:52:05 <Lokadin> hmmm how do i add in " to pass on to the sh?
03:52:18 <dcoutts_> > "\""
03:52:19 <lambdabot> "\""
03:52:29 <dcoutts_> > head "\""
03:52:30 <lambdabot> '"'
03:52:50 <Lokadin> head \"
03:52:52 <Lokadin> er
03:52:55 <Lokadin> > head \"
03:52:56 <lambdabot>  parse error on input `\'
03:53:00 <Lokadin> o
03:53:13 <Lokadin> so
03:53:36 <Lokadin> "bash -c \" ls --color \""
03:53:37 <Lokadin> ?
03:54:34 <xerox> I'd use concat :-)
03:55:03 <Lokadin> @type concat
03:55:05 <lambdabot> forall a. [[a]] -> [a]
03:55:25 <Lokadin> how would that help?
03:59:13 <davidhouse> heh :) Konversation picks up [[a]] and links it to wikipedia.org/wiki/a :)
03:59:41 <Lokadin> say can i have wild cards in case statements? 
03:59:54 <Lokadin> like er ":" ++ _
03:59:57 <Lokadin> or some such?
03:59:58 <davidhouse> Lokadin: kind of
04:00:13 <davidhouse> you can use constructors of whatever type you're matching against
04:00:24 <davidhouse> the constructors of a list are : and [].
04:00:43 <Lokadin> so say
04:00:50 <davidhouse> so you can say 'a' : _ to match an 'a' character at the beginning of a list
04:01:10 <Lokadin> do you have to add the []
04:01:13 <Lokadin> at the end?
04:01:21 <Lokadin> or just leave it as 'a' : _
04:01:31 <davidhouse> 'a':_ is fine
04:01:39 <Lokadin> davidhouse: :) thanks
04:01:46 <davidhouse> but, say you want to match the string "abc"
04:01:53 <davidhouse> you'd use 'a':'b':'c':[]
04:02:04 <davidhouse> (or you can use the syntatic sugar, "abc" :))
04:02:19 <Lokadin> :)
04:02:36 <Lokadin> that makes perfect sense lol
04:02:39 <mauke> I want p ++ l patterns
04:02:50 <davidhouse> muake, me too.
04:06:26 <Lokadin> kk well local time is 7:02 so i should be heading to sleep
04:06:40 <Lokadin> cya guys :) and thanks for all the help!
04:07:26 <Lemmih> dcoutts_: Neat, too bad HIDE is in no shape to use it.
04:08:04 <dcoutts_> Lemmih, so what are you doing with these plugins at the moment?
04:08:16 <dcoutts_> I was having difficulty following as I recall
04:09:14 <DeliQ> how you pattern-match on the same variables ?
04:09:45 <davidhouse> DeliQ, what do you mean?
04:09:50 <dcoutts_> DeliQ, you mean: foo x y | x == y = ... ?
04:09:58 <DeliQ> yup
04:10:02 <DeliQ> you cant say foo x x
04:10:07 <dcoutts_> indeed
04:10:09 <davidhouse> ah.
04:10:28 <DeliQ> so i have to use a eq test in guards ?
04:10:40 <davidhouse> it appears so.
04:12:36 <tromp> right
04:13:52 <Lokadin> say what's a good pdfviewer, that can actually save where you last were, maybe even change the page color and stuff
04:13:55 <Lokadin> ?
04:14:27 <DeliQ> i always use acroread, but i don't know if you have that features in adobe reader
04:14:31 <wolverian> any self-respecting viewer can do the former. haven't seen the latter anywhere
04:15:01 <Lokadin> i dono, i usually finish reading books when i'm too tired to remmber my name
04:15:07 <Lokadin> much less a page number
04:15:11 <Lokadin> hmmm
04:15:15 <dcoutts_> Lokadin, I use evince
04:15:22 <Lokadin> so do i :)
04:15:35 <Lemmih> dcoutts_: I'm not sure what a properly designed GhcPlugins library would look like.
04:15:42 <Lokadin> it's far better than acroread IMHO
04:16:01 <DeliQ> Lokadin: explain...
04:16:20 <dcoutts_> Lemmih, what do we want from it? I think for "big" plugins that the cabal + loading is ok.
04:16:35 <dcoutts_> Lemmih, but for that we have to accept no unloading
04:16:47 <dcoutts_> Lemmih, and no prescribed initialisation order
04:17:03 <DeliQ> maybe i will turn to evince then, since acroread is a bit "heavy"
04:17:04 <dcoutts_> but there's certainly a gap for lighter plugins
04:17:22 <dcoutts_> Lemmih, eg tiny source-based plugins that can be loaded & run & unloaded
04:17:26 <dcoutts_> Lemmih, ghci-style
04:17:36 <Lokadin> DeliQ: because it loads faster, works faster, and lets you browse your document in a more natural manner
04:17:44 <Lokadin> DeliQ: yep
04:17:58 <Lemmih> dcoutts_: I don't really like that.
04:18:09 <dcoutts_> Lemmih, though it may make more sense to statically link most of the big chunks
04:18:22 <DeliQ> hmm, let's see if there is a slack pkg
04:18:26 <dcoutts_> Lemmih, and use a minimal loader, ie no hs-plugins
04:18:34 <Lemmih> dcoutts_: Plugins as Cabal projects encourage them to depend on each other.
04:18:45 <davidhouse> Lokadin: KPDF
04:18:46 <dcoutts_> Lemmih, that's right. I think that's essential.
04:19:07 <Lemmih> dcoutts_: Hard coding the dependencies is a major problem, IMHO.
04:19:10 <Lokadin> davidhouse: i don't use kde
04:19:11 <dcoutts_> Lemmih, and I think that's ok so long as they don't need initialising in any order
04:19:30 <Lemmih> dcoutts_: I think plugins should depend on interfaces and not implementations.
04:19:46 <dcoutts_> Lemmih, that's fair enough, that can be done too
04:19:56 <Lemmih> dcoutts_: Not easily.
04:20:09 <dcoutts_> Lemmih, eg define an interface in A and implement it in B & C
04:20:12 <Lemmih> dcoutts_: Or, at least, I don't know how.
04:20:55 <dcoutts_> each of B & C register their implementations and A dispatches
04:21:02 <Lemmih> dcoutts_: I don't follow.
04:21:24 <mnislaih> it is all very similar to the Eclipse platform
04:21:35 <mnislaih> they use something called Extensions and Extension points
04:21:42 <Lemmih> dcoutts_: A = module A where fun1 = undefined :: SomeType?
04:22:35 <dcoutts_> Lemmih, I make a "file system change notification" manager in some base package. Then hide-intofiy and hide-poll both provide implementations. When either are loaded they reigster themselves as providing that interface. Then calls to the notification interface go to which ever implementastion got registered. 
04:22:47 <jyp> You'll end up with first class modules in haskell... yay :)
04:22:54 <dcoutts_> so there is runtime indirection
04:22:58 <dcoutts_> that's ok
04:23:27 <Lemmih> dcoutts_: A = module A where fun1 = getFunc1FromGlobalEnv :: SomeType?
04:23:28 <dcoutts_> because often we can have more than one impl loaded and use either in different cirumstances, ie they may not be mutually exclusive
04:23:56 <mnislaih> you still need a model to define how does a plugin register as providing a service
04:24:13 <Lemmih> dcoutts_: And I'd really love to export partially applied closures instead of top-level functions.
04:24:38 <DeliQ> Lokadin: does evince depend on GNOME ?
04:24:45 <DeliQ> because i use xfce
04:24:56 <dcoutts_> DeliQ, it depends on some gnome libs
04:25:03 <DeliQ> hmm, sucks :P
04:25:11 <dcoutts_> Lemmih, how might that work?
04:25:59 <Lemmih> module A where init = newIORef 0 >>= \ref -> export ("myFunc", modifyIORef succ ref)
04:26:04 <dcoutts_> as far as I can see, this plugin stuff is just the same as how you'd do it statically
04:26:25 <dcoutts_> with an emphasis on loosely coupled modules
04:27:20 * Lemmih wants something more advanced than runtime indirection.
04:27:22 <Lokadin> DeliQ: i use wmii3
04:27:25 <dcoutts_> so modules can depend on each other, but you try to keep things loosly coupled by seperating things with interfaces
04:27:44 <dcoutts_> so the static deps are just impl depending on interface
04:28:33 <dcoutts_> one tricky thing is trying to avoid lots of top level IORefs
04:28:42 <dcoutts_> I think that can be done
04:29:17 <DeliQ> Lokadin: do you also have a basic gnome install then ?
04:29:37 <dcoutts_> eg by passing an app instance value when registering modules/plugins
04:30:32 <Lokadin> DeliQ: yep
04:31:02 <Lemmih> dcoutts_: App instance value when registering plugins?
04:31:08 <DeliQ> Lokadin: that explains it... ;)
04:31:09 <Lokadin> DeliQ: though it's not necessary
04:31:27 <DeliQ> i just tried to compile it, asks for gnome-doc-tools or whatever
04:31:29 <Lokadin> DeliQ: i just use gnome apps
04:32:02 <Lokadin> yea, gentoo would get it all for you ;)
04:32:13 <DeliQ> hehe
04:32:24 <DeliQ> was waiting for such a comment :P
04:32:36 <Lokadin> :)
04:33:26 <mnislaih_> You can pass an instance to the plugin registry
04:33:52 <DeliQ> let's just be happy that there are microsoft alternatives :P
04:34:06 <DeliQ> don't you think Lokadin ? :P
04:34:14 <Lokadin> :)
04:34:15 <Lokadin> yep
04:34:17 <Lokadin> definatly
04:34:17 <Lokadin> lol
04:34:18 <DeliQ> lol
04:35:03 <dcoutts_> Lemmih, right, so that we don't need each plugin registery to keep a global IORef or registered impls we want them to be able to make a newIORef when they're initialised
04:35:14 <dcoutts_> but that needs passing something in from the top
04:35:26 <dcoutts_> Lemmih, I've not fully worked it out yet
04:35:54 <dcoutts_> so the idea is that you only need to create global state in main and then you pass it down
04:35:55 <Lemmih> dcoutts_: I really don't understand you.
04:36:13 <dcoutts_> Lemmih, we want to avoid lots of top level IOrefs right?
04:36:18 <Lemmih> dcoutts_: Yes.
04:36:24 <dcoutts_> so, I'm thinking of how we might do that
04:36:46 <Lemmih> dcoutts_: I got that far. I don't how you solve it.
04:36:55 <dcoutts_> and I think it needs some value to be passed down to identify the context
04:37:07 <Lemmih> pass down?
04:37:44 <dcoutts_> the analogy is stdout :: Handle
04:37:51 <dcoutts_> instead of it being globally available
04:38:04 <Lokadin> have you guys herd of Accelerando?
04:38:06 <Lokadin> the book?
04:38:08 <dcoutts_> we'd make it in main and pass it to each bit of code that needed it
04:38:11 <Lokadin> it's absolutly amazing
04:38:45 <Lemmih> dcoutts_: 'stdout' is defined with unsafePerformIO.
04:38:50 <dcoutts_> Lemmih, but I'm not quite sure yet how to make the types work out
04:39:00 <dcoutts_> Lemmih, indeed, but it neededn't be that way
04:39:22 <dcoutts_> Lemmih, it could be made in main and passed about, then no unsafePerformIO is needed
04:39:34 <dcoutts_> this is the same idea, but more tricky because of the different types
04:39:35 <Lemmih> dcoutts_: So the other plugins can only access partially applied closures?
04:39:55 <dcoutts_> I don't know what you mean
04:39:57 <Lemmih> Like: module A where init = newIORef 0 >>= \ref -> export ("myFunc", modifyIORef succ ref)
04:40:21 <dcoutts_> no, I'm not talking about a mechanism like that
04:40:56 <dcoutts_> the top level IORef problem is independent of the plugin problem
04:41:13 <dcoutts_> well, mostly independent
04:41:59 <Lemmih> How would you make the state accessible from the exported functions?
04:42:48 <dcoutts_> Lemmih, I think the point is that we'd pass something in to init
04:42:58 <dcoutts_> so that it's only local to that "app instance"
04:43:07 <Lemmih> init :: a -> IO ()?
04:43:09 <dcoutts_> and we could init a plugin more than once
04:43:13 <mnislaih_> make exported functions be arrows. taking some state and some registry plugins
04:43:15 <Lemmih> Be more specific.
04:43:37 <dcoutts_> Lemmih, I'm not sure how the types work out though
04:43:53 <Lemmih> mnislaih_: So plugin functions should have type :: a -> b where 'a' is some state?
04:44:01 <dcoutts_> Lemmih, you want something like a plugin being able to attach it's state to the app instance
04:44:11 <Lemmih> mnislaih_: Then users of the plugin should pass around the state?
04:44:17 <mnislaih_> some global state for the app yes,
04:44:18 <roconnor> > take 5 $ iterate (\x -> (69069*x +3) `mod` (2^31)) 10
04:44:20 <lambdabot> [10,690693,460834564,1527353911,1968038158]
04:44:24 <mnislaih_> yes, but it would be hidden by the arrow mechanism
04:44:29 <Lemmih> dcoutts_: So a single global variable instead of many?
04:44:36 <dcoutts_> Lemmih, right
04:44:52 <dcoutts_> Lemmih, and that's ok because it can be created in main. So no top level vars.
04:45:00 <dcoutts_> so no unsafePerformIO
04:45:08 <Lemmih> How would you access the state?
04:45:16 <dcoutts_> not sure yet :-)
04:45:21 <mnislaih_> you don't think arrows could work ?
04:45:28 <Lemmih> mnislaih_: No.
04:45:34 <dcoutts_> mnislaih_, possibly.
04:45:41 <Lemmih> dcoutts_: init = newState "mystate" 10; somefunc = do n <- getState "mystate"; print n ?
04:45:56 <Lemmih> dcoutts_: How does 'getState' access the global state?
04:47:29 * Lemmih is still very unconvinced.
04:47:37 * dcoutts_ is thinking about it
04:47:46 <norpan> what are you discussing?
04:48:14 <Lemmih> norpan: Plugin systems for hIDE.
04:48:16 <dcoutts_> Lemmih, if a plugin is just registering with interfaces then it's easy.
04:48:24 <dcoutts_> what's harder is for exported funcionts
04:48:40 <dcoutts_> because they'd need the same state token passed in
04:49:11 <Lemmih> I don't want to export top-level functions.
04:49:19 <dcoutts_> well that's ok then
04:49:39 <dcoutts_> if you're just returning cloaures then it's ok
04:50:02 <norpan> hmmm, plug-ins
04:50:08 <dcoutts_> but I want modules to be able to depend on each other in the normal manner
04:50:17 <neologism> how can I compile progam to be fastest using ghc?
04:50:24 <Lemmih> dcoutts_: So, init = newIORef () >>= \ref -> export ("myFunc",something using ref here)?
04:50:41 <Lemmih> neologism: -O2
04:50:58 <dcoutts_> Lemmih, something like that. Though I have to say I don't like the extra export thing.
04:51:04 <neologism> Lemmih: nothing like -fvia-c etc?
04:51:15 <Lemmih> neologism: -O2 implies -fvia-c.
04:51:22 <dcoutts_> Lemmih, I want to register ordinary closures with existing interfaces
04:51:26 <neologism> ah :)
04:51:49 <dcoutts_> so that it's just like coding static modules, but they can be loaded at runtime
04:51:51 <Lemmih> dcoutts_: How?
04:52:10 <dcoutts_> I don't think an additional dynamic/runtime mechanism like export is needed
04:52:16 <Lemmih> I disagree.
04:52:28 <dcoutts_> I know :-)
04:53:43 <Lemmih> Plugins aren't just modules linked at run-time, IMHO.
04:54:02 <mnislaih_> Indeed, of course they arent
04:55:13 * dcoutts_ thinks they are
04:56:00 <mnislaih_> That's completely wrong imho
04:56:15 <dcoutts_> though I accept that small source snippt style "plugins" are different
04:56:26 <dcoutts_> eg ghci command line style things
04:57:09 <norpan> who are working on this hide thingy
04:57:22 <dcoutts_> mnislaih_, why? The advantage as I see it if we can do it that way is that we can re-use existing coding techniques.
04:57:26 <mnislaih_> Can I recommend a very relevant document from the Eclipse platform ?
04:57:30 <Lemmih> norpan: I am.
04:57:34 <dcoutts_> mnislaih_, sure
04:57:34 <mnislaih_> http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html#2.
04:57:45 <mnislaih_> just section 2, not the whole document
04:58:02 <mnislaih_> I think it would be a mess if you didn't consider plugins as 'something more'
04:58:08 <mnislaih_> call it components or whatever
04:59:10 <mnislaih_> when you read it check the Extension and Extension Point notions
04:59:32 <mnislaih_> there is a very defined language to state how plugins interact with each other
05:00:02 <mnislaih_> and a haskell platform would need a much more exhaustively defined language imho
05:00:18 <doublec> I'm writing a space invaders emulator in Haskell and so far, unoptimised and probably badly written, it emulates the 8080 instruction set at a good speed.
05:00:32 <dons> you using ghc? and -O ?
05:00:37 <doublec> Strangely (to me) using DiffUArray for memory access is slower than UArray.
05:00:40 <doublec> ghc
05:00:50 <dons> -O turned on?
05:00:55 <doublec> Yes
05:01:08 <doublec> With -O2 I get 1,000,000 instructions emulated in 1. seconds
05:01:10 <dcoutts_> mnislaih_, that's all fine, I'm happy with a plugin abstraction/notion I'm not happy with additional dynamic language semantics, ie export which turns a string into a program symbol
05:01:17 <dons> cool.
05:01:19 <doublec> 1.5 seconds, sorry. On an athlon 2500.
05:01:21 <mnislaih_> aha
05:01:43 <mnislaih_> I misunderstood that
05:02:00 <doublec> My emulator written in Factor gets 1.7 seconds for 1,000,000 instructions - and that uses mutable state everywhere.
05:02:19 <Lemmih> doublec: DiffUArray is using an MVar. That makes it pretty exspensive.
05:02:30 <dons> yeah, that'd be it.
05:02:41 <doublec> Ok, thanks Lemmih. I was curious at what the speed difference between the different array types would be.
05:03:11 <doublec> Without -O I get about 3 seconds. So twice as slow.
05:03:58 <dons> have you profiled it yet?
05:04:03 <doublec> No, not yet
05:04:12 <dons> very encouraging ,though. good work
05:04:30 <doublec> thanks. Once I've got a simple GUI going I'll put the code up.
05:05:06 <dons> yeah, you should add it to the games page on haskell.org
05:05:37 <dons> ?wiki Libraries_and_tools/Games
05:05:38 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Games
05:05:49 <doublec> Ok, will do
05:05:55 <nattfodd> hi
05:06:10 <dons> maybe you could steal the ansi terminal space invaders ui?
05:06:10 <nattfodd> this is certainly a stupid question, but why isn't there a Data/FastPackedString.hs in fps-0.5?
05:06:19 <dons> ? there is.
05:06:25 <dons> ah sorry.
05:06:28 <dons> I see what you mean.
05:06:44 <nattfodd> it amkes yi fail at compilation
05:06:48 <nattfodd> *makes
05:06:49 <dons> there was a long discussion on the libraries@haskell.org list about the name, and Data.ByteString was decided upon
05:07:14 <dons> so now its going into the base libs, i had to phase out the old name
05:07:17 <nattfodd> but sed -e s@FastPackedString@ByteString@ in yi doesn't help
05:07:34 <dons> no. you'd have to change the FastString name to ByteString as well.
05:07:45 <dons> and change import Data.FastPackedString to import Data.ByteString.Char8
05:07:51 <doublec> I'll probably look at using opengl for the gui assuming I can get access to glDrawPixels. Then I can write direct to the opengl biffer and draw it on every 8080 vblank interrupt.
05:08:20 <dons> nattfodd: or just use fps 0.4...
05:08:52 <nattfodd> dons: thanks
05:09:12 <dons> even 0.2 would be fine. or 0.1 :)
05:09:23 <dons> the joys of bleeding edge software
05:10:29 <davidhouse> dons!
05:10:35 <dons> davidhouse: hi
05:10:42 <dons> you've been pinging me every couple of days?
05:11:00 <davidhouse> dons, well, since last night or so.
05:11:09 <davidhouse> i'm having trouble getting lambdabot to make.
05:11:17 <dons> oh how so?
05:11:26 <dons> don't tell me: fps ?
05:11:30 <davidhouse> originally i was also having trouble getting FPS, but then i used a tarball (0.5) and everything was dandy.
05:11:34 <davidhouse> but, http://paste.lisp.org/display/19543
05:11:47 <davidhouse> and yes, it appears to be a ByteString problem
05:13:51 <neologism> @where fps
05:13:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:13:52 <dons> looks like a ghc 6.4 build error message. remove -Werror in conifig.mk
05:15:51 <neologism> does ghc65 contain fps?
05:16:58 <dons> this was a wibble bug in 6.4 that's fixed in 6.4.1 and later.
05:16:58 <davidhouse> dons, seems to be going okay. thanks very much. :)
05:17:09 <dons> neologism: should be comitted today
05:17:27 <neologism> wow :)
05:17:36 <dons> simon is reviewing it.
05:18:26 <davidhouse> dons, fantastic, it all works :) thanks again for your help.
05:18:45 <dons> well, too many projects need it (i.e. darcs, hugs) for ByteString not to be in the base libs (that's the argument, anyway)
05:18:48 <dons> david	ah, great.
05:18:58 <dons> s/hugs/pugs/ oops
05:20:29 <neologism> I am going to use fps for the very first time today
05:21:00 <psi> Lemmih: hey! I was wondering about working on hIDE for SOC. do you have suggestions for suitable tasks? I am perhaps mostly interested in features for coding convenience. I hear it does syntax & type checking already, but I bet there are loads of other things one can come up with. also, xerox mentioned that hIDE wasn't really working right now...
05:21:05 <norpan> would it make sense to have a String typeclass for this
05:21:18 <psi> I haven't really thought about it much - I got interested earlier today :)
05:22:19 <neologism> witten ~/fps-0.5# ./Setup.hs --prefix=/usr/local/
05:22:19 <neologism> No command given (try --help)
05:22:21 <neologism> uh?
05:22:35 <neologism> shit.. sorry
05:22:36 <davidhouse> ./Setup.hs configure --prefix=/usr/local
05:22:36 <psi> configure
05:22:51 <neologism> I am blind today
05:24:33 <neologism> I wonder how long will take it to rewrite [String] program to FPS
05:25:01 <norpan> [Char]?
05:25:03 <dons> neologism: well, you can always just partially rewrite it. and use unpack/pack at the interface.
05:25:20 <neologism> norpan: I said I am blind today :)
05:25:33 <dons> lambdabot does this for example. it does packed string io, then unpacks it into [Char] for some legacy parsing code.
05:26:02 <neologism> I want all my code to use ByteString for performance reasons
05:26:16 <dons> a noble goal :)
05:26:28 <neologism> its very short code
05:26:36 <neologism> 151 lines
05:26:41 <dons> oh, should be easy then.
05:26:48 <neologism> actual code is less then 100 I guess
05:26:50 <dons> most of the list functions will just get a P. prefix
05:27:04 <dons> and any pattern matching has to become explicit head/tail/null tests
05:27:15 <dcoutts_> oh, for views
05:27:19 <dons> or , use null, then use unsafeHead/unsafeTail, when safe.
05:27:27 <dons> dcoutts_: :)
05:28:14 <dcoutts_> why did views not get any support?
05:28:19 <dons> neologism: there's a few example programs in the fps/tests dir. and also on the wiki is a bit of a tutorial.
05:28:20 <neologism> dons: is %s/String/ByteString good first step?
05:28:25 <dons> ?wiki Wc
05:28:25 <lambdabot> http://www.haskell.org/haskellwiki/Wc
05:28:38 <dons> neologism: i'd do it bit by bit. but roughly, yes.
05:29:15 <neologism> I have to unpack for IO right?
05:29:29 <dons> no
05:29:36 <dons> you definitely don't want to do that.
05:29:42 <neologism> ?
05:29:45 <dons> use the ByteString IO functions you need
05:29:53 <dcoutts_> you especially want it packed for IO
05:29:58 <dons> P.readFile or P.getLine or whatever..
05:30:10 <xerox> Why `P'?
05:30:21 <neologism> well.. this is just putStrLn result at the end of the code.. definitelyu not performance sensitive :)
05:30:34 <dons> oh, import qualified Data.ByteString as P -- since it used to be called PAckedString :}
05:31:01 <xerox> ByteString is certainly nicer, yea.
05:31:01 <dons> neologism: , so use Data.ByteString.putStrLn, if all your strings are ByteStrings anyway.
05:31:26 <neologism> yeah..doing so
05:32:01 <neologism> dons: I suppose I cannot use foldr on ByteString
05:32:12 <dons> of course you can
05:32:17 <dons> ?where fps
05:32:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:32:19 <dons> read the haddocks :)
05:32:29 <neologism> hm... I should read it more carefully
05:32:43 <neologism> I wonder if %s/String/ByteString and prefixing all functions with P will work
05:33:08 <dons> mostly, but your pattern matches will break
05:33:35 <xerox> Maybe TH hackery could do it :-)
05:33:44 <dons> i.e.f (x:xs)  becomes  f ps  where (x,xs) = (unsafeHead ps, unsafeTail ps)
05:33:53 <dcoutts_> ndm, do you have anything to do with the register-based yhc bytecode work?
05:34:07 <ndm> dcoutts_, no, but it looks very interesting :)
05:34:25 <ndm> i have talked to malcolm about it a bit, but more in curious lunch time chat, than actually doing anything
05:34:36 <dcoutts_> ndm, yeah I saw it in malcom's blog this mornging. it does look interesting
05:34:50 <neologism> hm.. also s/++/`append`
05:34:54 <ndm> if it really is 2x in all circumstances, we'll make it the primary bytecode :)
05:34:58 <dons> hmm. is malcolm's blog on planet.haskell ?
05:35:01 <dcoutts_> especially the fact that it makes some low level optimisations easier/possible
05:35:07 <dons> neologism: yeah. and avoid `cons` if you can.
05:35:12 <dcoutts_> ndm, (and it's better for jitting :-) )
05:35:17 <dons> some code has to be slighly rewritten because ops have different complexity
05:35:20 <ndm> i suspect its implemented as a translator from .hbc to a new one, so not actualy in teh compiler
05:35:37 <ndm> which will make it more work to port over, but definately worth it :)
05:35:46 <neologism> dons: do you think its possible to write translator from String to ByteString?
05:35:59 <dcoutts_> dons, yes malcolm's blog is on planet.haskell
05:36:19 <dons> neologism: shrug. yeah. but would it be very interesting?
05:36:28 <ndm> dons, yep, i saw it on the haskell planet RSS earlier
05:36:49 <dcoutts_> neologism, not if you rely on lazyness or sharing
05:37:14 <dons> yeah. that doesn't translate well.
05:37:35 <dcoutts_> ndm, so where would one steal a jit from if one were after that? :-) valgrind?
05:37:40 <dons> but you can be happy when your drop/take and other substring ops suddenly have O(1).
05:37:54 <davidhouse> dons, that wc wiki page is quite fun
05:38:00 <ndm> dcoutts_, not sure what you mean?
05:38:11 <dons> davidhouse: cool :)
05:38:18 <Igloo> dcoutts_: re views, no-one put together a spec/impl, did they?
05:38:31 <dons> no impl. iirc.
05:38:31 <davidhouse> although my eyes glossed over when we hit anything as low-level as Ptr hackig.
05:38:33 <dcoutts_> ndm, I was thinking the other day, why are jit's so hard? why are there so few implementations?
05:38:51 <dcoutts_> ndm, but valgrind has one under the GPL on x86. amd64 & ppc32
05:38:52 <ndm> dcoutts_, portable C# project had a libjit, that was meant to abstract over all jit's
05:39:00 <neologism> @where sortBy
05:39:00 <lambdabot> I know nothing about sortby.
05:39:04 <dcoutts_> Igloo, I think that's right
05:39:08 <dons> @index sortBy
05:39:08 <lambdabot> Data.List
05:39:17 <dons> neologism: hmm. you use sortBy ?
05:39:20 <davidhouse> @hoogle sortBy
05:39:21 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
05:39:28 <ndm> @hoogle copy
05:39:29 <lambdabot> hoogle: BItem ::
05:39:29 <lambdabot>  
05:39:29 <neologism> yes.. I use sortBy
05:39:40 <dons> yeah, that's currently missing.
05:39:48 <dcoutts_> ndm, you mean mono or something else?
05:39:49 <neologism> so I have to pack/unpack?
05:39:57 <dons> you'll have to use: pack . List.sortBy foo . unpack
05:40:24 <dcoutts_> ndm, I expect part of the problem is that everyone wants their jit to be quick so make it less generic
05:40:45 <ndm> dcoutts_, not mono, it was a copmeting project
05:40:48 <dcoutts_> oh right
05:40:52 <davidhouse> @localtime vincenz
05:41:05 <ndm> but as part of the project they did an entirely abstract and generic libjit
05:41:26 <dcoutts_> ndm, in C?
05:41:44 <Lemmih> psi: Yeah, hIDE isn't working. We need to write the plugin system first.
05:41:48 <ndm> dcoutts_, yep, the entire portable C# project was C (unlike Mono which is a lot of C#)
05:42:07 <dcoutts_> ndm, hmm, intersting, did libjit turn out ok?
05:42:23 <ndm> http://www.southern-storm.com.au/libjit.html
05:42:23 * dons -> sleep. night lambda folks!
05:42:27 <xerox> Goodnight dons
05:42:29 <dcoutts_> g'night dons 
05:42:35 <ndm> dcoutts_, no idea, it was a while since i checked up on it
05:43:15 <ndm> last release was 16 Jan 2006, so its obviously not that dead
05:43:35 <neologism> will map (\x -> if x == 'a' then 'x' else 'y') ByteString work?
05:44:09 <davidhouse> i guess you need to use ByteString's map.
05:44:43 <neologism> lets see
05:46:00 <neologism> all that doesn compile is the pattern matching
05:46:16 <dcoutts_> ndm, looks interesting. What license is yhc?
05:46:25 <ndm> dcoutts_, GPL
05:46:30 <dcoutts_> that's ok then :-)
05:51:00 <lumi> ghc doesn't like me
05:52:30 <davidhouse> lumi, why, what have you done to it?
05:52:40 <lumi> I built it
05:52:57 <ndm> lumi, why not just download a prebuilt one?
05:52:57 <lumi> I don't think that's so evil, I built it with gcc4 and it didn't work, and now with gcc3.3
05:53:03 <lumi> I nunno
05:53:06 <lumi> I got it off ports
05:53:08 <ndm> its kind of tricky to get it working
05:53:21 <psi> Lemmih: ok. does that mean other things are not really suitable as projects, or will that be done soon?
05:53:30 <lumi> I suppose it's some kinda compiler bug
05:55:51 <lumi> No binary for my platform
05:56:11 <davidhouse> lumi, which platform?
05:56:18 <lumi> Mac OS X
05:56:38 <neologism> uh.. how can I P.putStr Int?
05:56:50 <neologism> now I do putStr . show
05:56:56 <neologism> how to do this in FPS?
05:56:59 <adu> MacOSX? 
05:57:01 <lumi> I'll get a 6.4.1 maybe..
05:57:02 <adu> i'm on MacOSX
05:57:11 <lumi> And you got 6.4.2 up?
05:57:15 <psi> lumi: did you have trouble building it?
05:57:28 <davidhouse> neologism: is there a P.print?
05:57:30 <psi> I tried to, it failed with something related to opengl
05:57:34 <psi> too*
05:57:35 <lumi> No, it built fine with either compiler, but it keeps puking:
05:57:46 <lumi> ghc-6.4.2: internal error: scavenge_stack: weird activation record found on stack: 26880
05:58:10 <lumi> (Different number every time) and tells me to report as a compiler bug, but I can't figure out if someone reported this
05:59:01 <lumi> It seems to do it at random, sometimes it loads, and sometimes it segfaults
05:59:03 <neologism> davidhouse: no
06:01:19 <araujo> morning
06:02:24 <neologism> wow.. 1 compile error left
06:02:58 <doublec> A quick post about the emulator: http://www.bluishcoder.co.nz/2006/05/space-invaders-emulator-in-haskell.html
06:04:33 <neologism> may I use FPS in ghci?
06:04:40 <neologism> if so.. how?
06:06:55 <neologism> got it :)
06:13:33 <neologism> Warning: Pattern match(es) are overlapped
06:13:35 <neologism> what is this?
06:13:51 <ndm> neologism: this means that you might have written some dead code
06:13:54 <davidhouse> more than one pattern can match the same thing
06:13:57 <ndm> for example:
06:14:06 <ndm> f (x:xs) = x
06:14:10 <ndm> f [x] = True
06:14:13 <neologism> flipMax ps = if s1 == s2 then flipMax (s2`P.cons`ss) else 1 + flipMax (s2`P.cons`ss) where (s1, s2, ss) = (P.unsafeHead ps, P.unsafeHead $ P.unsafeTail ps, P.unsafeTail $ P.unsafeTail ps)
06:14:16 <ndm> the second pattern match is redundant
06:14:18 <neologism> flipMax _ = 0
06:14:21 <neologism> I wrote this
06:14:36 <ndm> well ps matches everything
06:14:37 <davidhouse> there are no constraints on ps.
06:14:42 <ndm> so nothing ever hits flipMax _
06:14:52 <davidhouse> you probably want (p:ps) or a guard or something
06:15:22 <neologism> davidhouse: I cannot use pattern matching as this is FPS
06:15:49 <davidhouse> a guard then.
06:16:43 <davidhouse> flipMax ps | P.length ps > 0 = ...
06:16:53 <davidhouse> then instead of flipMax _ = 0, use | otherwise = 0
06:17:16 <davidhouse> (although the former would still work, actually)
06:17:33 <ndm> is there not a P.null command or something?
06:17:54 <musasabi> use one large case or patterns, rather than pattern + if.
06:18:07 <musasabi> ndm: there is P.null.
06:18:26 <ndm> then use that as teh guard, not (P.null ps)
06:20:05 <neologism> wow... FPS is faaaasat
06:20:28 <davidhouse> neologism: what does your program do?
06:21:39 <neologism> evolution
06:25:03 <swiert> Any ideas how to assign a type to the (identity) function that takes any monad, forgets about the monadic structure, and leaves you with a functor? 
06:25:45 <swiert> As a first approximation I've got: forget :: (Monad m, Functor f) =>  m a -> f a
06:26:27 <musasabi> not possible.
06:26:32 <Igloo> If you want the two types to be the same then you probably need a class
06:26:39 <petekaz> dons: thanks (re: group and groupBy)
06:26:50 <swiert> musasabi: why not?
06:27:09 <musasabi> "forget :: Monad m => m a -> F a" is possible where F is an instance of Functor.
06:28:18 <davidhouse> because, for example, you can't have a function IO a -> [a].
06:28:25 <davidhouse> without unsafePerformIO, that is.
06:29:05 <davidhouse> because [] is easy to get out of, so if you could, you've just written a way out of the IO monad.
06:29:14 <swiert> Ok - what about forget :: Monad m => m a -> Forget (m a)
06:29:21 <neologism> hm.. 30seconds (fps) vs 45seconds (String)
06:29:34 <swiert> where Forget lifts the functor through, but not not the monadic structure of m.
06:30:48 <musasabi> swiert: one could have something like: data F a where F :: Monad m -> m a -> F a
06:31:04 <neologism> is there profiler for ghc?
06:31:08 <musasabi> data F a where F :: Monad m => m a -> F a
06:31:09 <musasabi> that is
06:31:45 <musasabi> instance Functor F where fmap f (F m) = F (liftM f m)
06:32:12 <swiert> musasabi: but every monad is also a functor (with fmap f ma = ma >>= (return . f)).
06:32:49 <musasabi> swiert: but every monad is not every functor.
06:33:50 <ellism> xerox: Ping?
06:33:57 <swiert> musasabi: yes. But the question is how to forget the monadic structure, and only leave behind a functor.
06:34:18 <musasabi> swiert: thus forall m f. is wrong, you mean something like forall m. exists f.
06:34:25 <audreyt> Data.Yaml.Syck has just been cabalized :)
06:34:53 <audreyt> http://svn.openfoundry.org/pugs/third-party/HsSyck/ # so far only tested in GHC 6.4.2
06:35:08 <audreyt> I wonder if Hugs YHC JHC etc can use it.
06:35:44 <musasabi> audreyt: what extensions does it use?
06:36:09 <neologism> ghc -prof -auto-all doesnt work for me
06:36:15 <neologism> saying Main.hs:1:0:
06:36:15 <neologism>     Failed to load interface for `Prelude':
06:36:15 <neologism>         Could not find module `Prelude': use -v to see a list of the files searched for
06:36:31 <swiert> musasabi: Unfortunately, you can't qualify existential types. So you essentially are forced to forget about the functorial structure as well.
06:36:46 <audreyt> musasabi: just FFI
06:37:11 <audreyt> so theoretically should be Just Fine, but havn't tested
06:37:53 <musasabi> audreyt: the import of GHC.Ptr will cause problems.
06:38:11 <musasabi> Data.Generics is another suspect.
06:38:41 <audreyt> is it possible to probe for Data.Generics and only derive Data when it's there?
06:39:18 <audreyt> @index Ptr
06:39:18 <lambdabot> Foreign.Ptr, Foreign, GHC.Exts, GHC.Exts
06:39:25 <araujo> Hi!
06:39:31 <araujo> dons, ping
06:39:57 <musasabi> other compilers provide the Foreign.* modules.
06:40:24 <musasabi> audreyt: most likely just a #if defined(__GLASGOW_HASKELL__) (might have a typo in there)
06:40:25 <audreyt> the Ptr constructor is used to write inline C-string literals
06:40:51 <davidhouse> araujo: he's gone to bed, i think.
06:41:00 <araujo> oh, ok thanks davidhouse 
06:41:39 <musasabi> audreyt: those are non-portable. I think that when someone needs it for non-ghc they will provide a patch to make it work with CPP magicks.
06:42:03 <audreyt> gotcha.
06:42:23 <audreyt> or maybe I should just inlinePerformIO newCString.
06:43:02 <musasabi> the Ptr ones are usually faster.
06:43:31 * musasabi changed code to use Data.ByteString.Char8.unsafePackAddress after benchmarking.
06:44:01 <audreyt> how do I use unsafePackAddress again?
06:44:36 <audreyt> oh wow.
06:44:44 <audreyt> nvm, I see that.
06:45:17 <musasabi> unsafePackAddress 6 "foobar"#
07:03:56 <Lemmih> neologism: You need the profiling libraries.
07:04:48 <neologism> yeah.. have found that
07:05:13 <davidhouse> yay!
07:05:23 * davidhouse finishes his unified diff parser
07:16:18 <araujo> hi xerox_ 
07:17:01 <xerox_> Hi there!
07:41:17 <jyp> Hahahaaa, I can now juggle 4 balls :)
07:43:42 <xerox> Cool :-)
07:43:49 <xerox> ?karma+ jyp 
07:43:50 <lambdabot> jyp's karma raised to 1.
07:43:54 <davidhouse> heh
07:44:30 <tuxplorer> ?karma+ jyp
07:44:31 <lambdabot> jyp's karma raised to 2.
07:44:38 <tuxplorer> wats this karma?
07:44:55 <tuxplorer> ?karma- jyp
07:44:56 <lambdabot> jyp's karma lowered to 1.
07:45:01 <davidhouse> if you do something good, people give you karma.
07:45:12 <tuxplorer> ?karma* jyp
07:45:13 <lambdabot> Maybe you meant: karma karma+ karma-
07:45:37 <tuxplorer> ?karma
07:45:38 <lambdabot> You have a karma of 0
07:53:22 <jyp> argh
07:53:28 <jyp> thanks :)
07:56:43 <petekaz> > map (head &&& length) . group . sort . filter isAlpha . map toLower $ "PetE's heRe"
07:56:44 <lambdabot> [('e',4),('h',1),('p',1),('r',1),('s',1),('t',1)]
07:57:32 <petekaz> Is there a better way to write the above?  The 'map toLower' and 'filter isAlpha' part?  Both have to scan the whole list, is there a simple way of combining both in one?
07:57:45 <petekaz> (still using a one-liner?)
07:59:44 <jyp> petekaz: i think the "intermediate list" will be deforested with ghc
07:59:52 <petekaz> oh, neat.
08:00:11 <jyp> wait a minute...
08:01:25 <jyp> petekaz: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3153234
08:02:47 <petekaz> neat.
08:03:15 <xerox> petekaz: sure.
08:03:17 <petekaz> Now, would something like that apply to Data.ByteString's map and filter?
08:03:32 <xerox> Ah, no, nevermind.
08:04:11 <petekaz> Because I'm actually using ByteStrings, not regular Strings as my example above shows.
08:09:55 <neologism> the number of warnings in ghc compilation scares me :(
08:10:32 * Igloo sent patches for a few but stopped when I hit some that were emitted due to bugs in GHC
08:11:02 <sowhat> does anyone know any tool/library, to pretty-print data in tex, e.g. functions to render TeX tables?
08:11:23 <petekaz> Does anyone else get an error retrieving the FPS repo?
08:11:30 <lisppaste2> petekaz pasted "Darcs get of FPS repo" at http://paste.lisp.org/display/19569
08:12:25 <neologism> Igloo: I mean those... "dont use that its deprecated and will be removed!" etc
08:17:08 <neologism> hm.. I recmpiled ghc and now I cannot import Data.ByteString.Char8
08:17:31 <neologism> ah.. I dont have profiled fps
08:18:39 <neologism> how do I compile profiled fps?
08:19:44 <ellism> xerox: That Intel OSX build you pointed me at, did you build that?
08:19:47 <xerox> Usually dons uses "make way=foo", where foo is the mode... but I don't know if it's the case.  Check the docs?
08:19:50 <xerox> ellism: nope.
08:20:37 <ellism> xerox: Okay, Thanks :-)
08:20:46 <xerox> ellism: do you need something?
08:20:59 <neologism> xerox: dont see it in the docs
08:21:18 <xerox> @where fps
08:21:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
08:21:43 <xerox> Ah, it is Cabal-ized.
08:21:56 <ellism> xerox: I (was/am) trying to build the latest nightly, and was running in to some OS X problems I think.  I just started over but if I had some problems, I was hoping you'd be able to provide some insights
08:22:06 <xerox> Maybe add the profiling options to ghc-options, neologism.
08:22:33 <xerox> ellism: oh, no, sorry.  Wolfgang surely can.
08:23:03 <neologism> hm... I have someMax :: String -> Char -> Int
08:23:03 <neologism> someMax s c = foldr (\x y -> if x==c then y + 1 else y) 0 s
08:23:10 <ellism> xerox: How does one go about contact him?  Does he read the cvs-ghc mailing list?
08:23:12 <neologism> but its very slow.. any idea how to speed this up?
08:23:24 <xerox> ellism: you can find his contact informations on GHC's trac
08:23:30 <ellism> Thanks
08:23:57 <xerox> ellism: I would love if you could Cc paolo at nemail it, if you're up to.
08:24:08 <ellism> not a problem
08:24:51 <xerox> Danke.
08:25:24 <ellism> I'm trying to get to a point where I can build things nightly just to do it.
08:25:49 <lightstep> @type Data.ByteString.count
08:25:50 <lambdabot> Word8 -> Data.ByteString.ByteString -> Int
08:28:13 <SimonRC> I've managed to make the Haskell typechecker prove that a program does not terminate (in a limited case).
08:28:22 <xerox> Oh.
08:28:35 <SimonRC> It says my function has type "forall t. [()] -> RecCont -> ContT () IO t"
08:29:03 <SimonRC> i.e. it can return any type I like, because it never returns (this is, in fact, correct)
08:29:26 <ellism> Is there anyway to add a line to the build.mk file to allow extra options to be passed to hsc2hs-inplace during the build process?
08:34:01 <ndm> SimonRC, cool :)
08:34:05 <vincenz> dons: ping
08:34:16 <ndm> SimonRC: any more details on your approach or anything?
08:34:44 <lispy> @localtime lambdabot 
08:34:55 <lispy> @localtime dons
08:34:58 <lambdabot> Local time for dons is Tue May  2 01:36:07 2006
08:35:08 <lispy> interesting, lambdabot can't localtime itself
08:35:13 <ihope> :-)
08:35:38 <lispy> @vixen what time is it?
08:35:39 <lambdabot> let's don't talk about that
08:35:48 <lispy> @vixen ah, but please?
08:35:49 <lambdabot> you're so polite :)
08:36:03 <SimonRC> ndm: it was a trivial case for a computer... basically it was like ``let f = putStrLn "hi" >> f in f''
08:36:07 <SimonRC> @type let f = putStrLn "hi" >> f in f
08:36:08 <lambdabot> forall b. IO b
08:36:13 <SimonRC> see?
08:36:37 <ndm> so whats the proof?
08:36:43 <lispy> so it's essentially undefined?
08:36:48 <ndm> functions can have IO b as a type, and be terminating, surely?
08:36:58 <ihope> Um...
08:37:01 <SimonRC> ndm: yeah, but what would they return?
08:37:07 <ihope> return . unsafeCoerce#
08:37:12 <ndm> error
08:37:18 <SimonRC> hmm
08:37:21 <SimonRC> oh, maybe not
08:37:42 <ihope> I always said that errors are thunks, not values...
08:37:52 <ihope> s/I/I've/
08:38:00 <lightstep> but is you disregard bottom, that would be a proof
08:38:00 <SimonRC> well, having a type like that does show it's not like most functions
08:38:22 <ndm> yes, sounds a bit like the theorems for free paper
08:38:26 <SimonRC> most functions have a restrained return type
08:38:42 <SimonRC> "free paper"?
08:38:54 <ndm> i guess if you have a return type that is independant of the input, then bottom is the only result
08:38:54 <lightstep> @google theorems for free
08:38:56 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
08:39:03 <lispy> that return type almost looks like a phantom type
08:39:04 <ndm> yep, its wadlers paper
08:39:21 <SimonRC> oops, got the precedence of the phrase wrong
08:39:25 <ihope> @djinn forall a b. (forall c d. ((c -> d) -> c) -> c) -> ((a -> b) -> a) -> a
08:39:26 <lambdabot> -- f cannot be realized.
08:39:31 <ihope> Whee.
08:39:36 <SimonRC> (theorems) for (free paper)
08:39:50 <ndm> (theorems for free ) paper :)
08:39:54 <SimonRC> heh
08:40:20 <ihope> So just how do I load a DLL and call its functions with FFI?
08:41:13 <ndm> ihope, ghc or hugs?
08:41:15 <norpan> that's what the curry-howard isomorphism tells us
08:41:18 <ihope> GHC.
08:41:22 <lispy> ihope: there is a webpage (example from ghc manual, iirc) that does just that
08:41:31 <ndm> i don't know that one, but i've been working on that in hugs all morning :)
08:41:41 <lispy> @google ghc dll ffi example
08:41:43 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
08:42:31 <lispy> that's not the example i was looking for
08:42:35 <lispy> but it might still help you
08:42:46 <ihope> I'll take a look at it.
08:46:01 <norpan> @djinn a -> [a] -> [a]
08:46:02 <lambdabot> f _ a = a
08:46:07 <norpan> indeed
08:46:16 <davidhouse> methinks hoogle would be more useful.
08:46:21 <neologism> is it correct that foldl seems to be faster then foldr?
08:46:25 <davidhouse> @hoogle a -> [a] -> [a]
08:46:26 <lambdabot> List.intersperse :: a -> [a] -> [a]
08:46:26 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
08:46:26 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:46:46 <norpan> i know hoogle, i just wanted to test the djinn
08:47:28 <davidhouse> djinn is fairly rubbish
08:47:34 <DeliQ> neologism: in some cases foldl is more efficient than foldr
08:48:41 <ihope> Well, Djinn doesn't support lists.
08:49:16 <DeliQ> ihope: what does djinn ?
08:49:16 <neologism> DeliQ: it seems to cause 25seconds vs 30seconds speedup here
08:49:34 <ihope> @djinn-env
08:49:34 <lambdabot> data () = ()
08:49:34 <lambdabot> data Either a b = Left a | Right b
08:49:34 <lambdabot> data Maybe a = Nothing | Just a
08:49:34 <lambdabot> data Bool = False | True
08:49:34 <lambdabot> data Void
08:49:36 <lambdabot> type Not x = x -> Void
08:49:44 <ihope> It supports all that.
08:50:05 <ihope> @djinn Int
08:50:06 <lambdabot> -- f cannot be realized.
08:50:14 <DeliQ> neologism: i think it has to do something with the stack
08:50:17 <ihope> It no work, you see...
08:50:34 <DeliQ> ihope: i see, but what is the use of djinn ?
08:51:05 <xerox> ?. pl djinn (b -> c) -> (a -> b) -> a -> c
08:51:05 <lambdabot> f = (.)
08:51:11 <ihope> Well, it can generate values out of types that it supports.
08:51:24 <ihope> Hmm...
08:51:26 <DeliQ> hmm, i get it
08:51:27 <ihope> @type folrd
08:51:29 <lambdabot> Not in scope: `folrd'
08:51:30 <ihope> @type foldr
08:51:31 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
08:51:37 <ihope> Aha!
08:51:50 <ihope> Oh, wait.
08:52:18 <ihope> Hmm...
08:52:51 <ihope> @djinn-add data List a b = List ((a -> b -> b) -> b -> b)
08:53:12 <ihope> @djinn a -> List a b -> List a b
08:53:13 <lambdabot> f a b =
08:53:13 <lambdabot>   case b of
08:53:13 <lambdabot>   List c -> List (\ d e -> c (\ _ f -> f) (d a e))
08:53:22 <lispy> isn't foldl strict in some cases that foldr is not?
08:53:27 <xerox> hah
08:53:32 <DeliQ> foldl' is strict
08:53:34 <lispy> if so, that might explain the speed up
08:53:36 <DeliQ> note the '
08:53:55 <xerox> Does it make any sense?
08:54:02 <lispy> right, but sometimes a lazy function is compiled as strict due to strictness inference
08:54:11 <ihope> xerox: good question
08:54:42 <lispy> neologism: does foldl' make a difference over foldl
08:55:00 <norpan> @djinn-add data L a = E | C a (L a)
08:55:09 <norpan> @djinn a -> L a -> L a
08:55:09 <lambdabot> Cannot parse command
08:55:09 <lambdabot> f :: a -> L a -> L a
08:55:09 <lambdabot> f _ a = a
08:55:17 <norpan> bah
08:55:23 <ihope> Djinn doesn't support recursive types.
08:55:34 <ihope> @djinn-del L
08:55:35 <lambdabot> Cannot parse command
08:55:38 <ihope> @djinn-env
08:55:39 <lambdabot> data () = ()
08:55:39 <lambdabot> data Either a b = Left a | Right b
08:55:39 <lambdabot> data Maybe a = Nothing | Just a
08:55:39 <lambdabot> data Bool = False | True
08:55:39 <lambdabot> data Void
08:55:41 <lambdabot> type Not x = x -> Void
08:55:43 <lambdabot> Error: Recursive types are not allowed: L
08:55:45 <lambdabot> data List a b = List ((a -> b -> b) -> b -> b)
08:55:48 <ihope> Bleh.
08:55:51 <ihope> @djinn-clr
08:56:07 <ihope> @djinn-add data List a b = List ((a -> b -> b) -> b -> b)
08:56:18 <ihope> 'Ere we go.
08:56:36 <lispy> how is that a list?
08:56:43 <norpan> list by name
08:57:41 <ihope> lispy: it takes cons and empty and returns the completed list, which will be of type b
08:57:50 <norpan> @djinn Either a (Not a)
08:57:51 <lambdabot> -- f cannot be realized.
08:57:57 <ihope> :-)
08:58:12 <ihope> @djinn Not (Not a) -> a
08:58:13 <lambdabot> -- f cannot be realized.
08:58:26 <ihope> @djinn Not (Not Void)
08:58:26 <lambdabot> -- f cannot be realized.
08:58:29 <lispy> @djinn Not a -> Void
08:58:30 <lambdabot> -- f cannot be realized.
08:58:41 <ihope> @djinn a -> Not a -> Void
08:58:42 <lambdabot> f a b = b a
08:59:05 <lispy> heh, djinn rarely works like i expect :)
08:59:14 <SimonRC> hmm, my linker is playing up
08:59:17 <norpan> @djinn a -> Not Not a
08:59:26 <ihope> @djinn a -> Not (Not a)
08:59:27 <lambdabot> f a b = b a
09:00:07 <SimonRC> Coroutines.o(.text+0xddd): In function `__stginit_Main_':
09:00:07 <SimonRC> : undefined reference to `__stginit_ControlziMonadziCont_'
09:00:07 <SimonRC> Coroutines.o(.text+0xde7): In function `__stginit_Main_':
09:00:07 <SimonRC> : undefined reference to `__stginit_ControlziMonadziTrans_'
09:00:07 <SimonRC> collect2: ld returned 1 exit status
09:00:23 <SimonRC> ghc is installed in ~/bin, could that be why?
09:00:23 <norpan> @djinn (Not a)
09:00:23 <lambdabot> -- f cannot be realized.
09:00:39 <ihope> That'd be forall a. a -> Void
09:00:56 <ihope> And that's equivalent to Void.
09:01:44 <xerox> SimonRC: -package mtl
09:01:51 <ihope> Maybe I'll plug in Djinn's a -> List a b -> List a b into GHC and see if it works...
09:02:21 <SimonRC> xerox: now why isn't *that* automatic?
09:02:27 <SimonRC> xerox: thanks, BTW
09:02:27 <lispy> @djinn a -> Not a
09:02:28 <lambdabot> -- f cannot be realized.
09:02:29 <xerox> SimonRC: it is if you use --make.
09:03:00 <lispy> i tried --make with ffi and it seemed broken
09:03:20 <lispy> (as in, I failed to get my project to build correctly)
09:05:47 <shapr> yow!
09:06:04 <xerox> Pa-ching!
09:06:18 <shapr> What was I doing?
09:06:26 * shapr remembers
09:08:34 * SimonRC wonders if his program will use up memory as much as it can or if it will stabilise at some point.
09:08:49 <SimonRC> ah
09:09:09 <SimonRC> it has 64k virtual memory and shows no signs of stopping
09:10:40 <Lemmih> shapr: Still working on cabal-get?
09:10:53 * xerox boings
09:12:05 <SimonRC> 124Meg
09:12:19 <SimonRC> darn, I think it has a leak
09:14:36 <shapr> Lemmih: I haven't done anything to it this last weekend, but I do plan on working on it more.
09:14:40 <shapr> y0 SyntaxNinja 
09:16:19 <SyntaxNinja> heya shapr
09:16:22 <shapr> Hm, gmail isn't forwarding mail to me...
09:24:40 <xerox> Yow.
09:30:57 <shapr> @YOW! JALAPEÑOS!
09:30:58 <lambdabot> Unknown command, try @list
09:31:04 <palomer> @yow
09:31:05 <lambdabot> Yow!  I threw up on my window!
09:32:36 <shapr> Yay, 209 clients!
09:34:55 <mnislaih> anyone knows why GHC 6.4.2 gives a lot less info on interface files when using "--show-iface" than v6.4.1 ?
09:37:39 <mnislaih> oh wait, I probably forgot the -O2 flag
09:39:21 <shapr> So, anything exciting happening?
09:40:10 <int80_h> I have a long shot project. It's like the seabiscuit story. It will be a miracle if google accepts it. ;)
09:40:25 <shapr> Oh, the unified threads/events guys (Peng Li, Steve Zdancewic) said they'll release their code next tuesday.
09:41:18 <shapr> But, 'Next N' means the immediately following in some cultures or (drop 1 . take 1) in some cultures.
09:41:58 <mauke> @type drop 1 . take 1
09:42:00 <lambdabot> forall a. [a] -> [a]
09:42:22 <mauke> ah, I get it
09:42:42 <DeliQ> > drop 1 . take 1 $ [1..10]
09:42:44 <lambdabot> []
09:42:47 <DeliQ> haha
09:42:55 <shapr> Ok, I said it wrong :-P
09:42:57 <mauke> it's const []
09:43:43 <shapr> > (take 1 . drop 1) [1..10] 
09:43:45 <lambdabot> [2]
09:43:48 <xerox> > const [] undefined
09:43:49 <lambdabot> Add a type signature
09:43:58 <xerox> > (take 1 . drop 1) undefined :: [Int]
09:44:00 <lambdabot> Undefined
09:44:03 <xerox> > const [] undefined :: [Int]
09:44:04 <lambdabot> []
09:45:05 <drakioned> ooh, int_80h is here again.
09:46:00 <int80_h> hi drak
09:46:12 <shapr> You guys done anything nifty with Haskell lately?
09:46:34 <drakioned> nothing exciting..
09:47:02 <int80_h> discovering haskell was nifty for me, I'm slogging through the tutorial I have so I can get to the good stuff
09:47:17 <xerox> SimonRC got the Haskell type checker finding nontermination in some special case, shapr!
09:47:18 <wchogg> int80_h:Which tutorial?
09:47:20 <drakioned> shapr: I came up with factorial function. that count.
09:47:27 <shapr> I guess so
09:47:34 <shapr> xerox: Wah cool! What cases?
09:47:44 <shapr> Oh, I've been reading this way cool paper - http://homepages.inf.ed.ac.uk/wadler/papers/frege/
09:47:46 <mauke> I wrote a simple regex-based string generator
09:47:50 <int80_h> The craft of functional programming by thompson. People keep bagging on it but it's what I have right now ;)
09:47:52 <shapr> mauke: nifty!
09:47:53 <Lemmih> I've got my first student.
09:48:01 <xerox> Lemmih: yay, who's him?
09:48:06 <shapr> Lemmih: Cool! Who and what for?
09:48:10 <Oejet> Lemmih: Uuuuh.
09:48:34 <drakioned> int80_h: read Graham Hutton's book.
09:48:38 <Lemmih> shapr, xerox: Pepe for debugging with GHC(i).
09:48:39 <wchogg> When can we start even sending applications to google anyway?  I thought they were going to provide an online application this year.
09:48:49 <xerox> Lemmih: oh yeah!!
09:48:55 <int80_h> you can start now, we have until the 8th
09:48:56 <drakioned> well, I think it's from today, isn't it?
09:49:01 <shapr> wchogg: Talk to the project mentors.
09:49:11 <int80_h> I'm puttig my proposal together for my mentor to read over
09:49:53 <wchogg> int80_h:  What project are you thinking of working on?
09:50:09 <int80_h> the one I proposed, the haskell mud engine
09:50:17 <shapr> y0 jethr0 
09:50:21 <wchogg> int80_h:  Ah!  That was you.
09:50:29 <int80_h> I'm already on it. Google accepting it as official would just be bonus.
09:50:37 <jethr0> re shapr
09:51:05 <int80_h> which they won't. But a man can dream, can't he?
09:51:17 <jethr0> shapr: how's life treating you? i'm just back from a trip to northern italy...
09:51:24 <wchogg> int80_h:  Who's going to mentor your mud project?
09:51:37 <shapr> jethr0: It's pretty much the same, but the sun is back!
09:51:39 <int80_h> erm, a guy named johan, I forget his nick
09:51:44 <drakioned> wchogg: mahogany
09:51:49 <int80_h> that's him
09:51:50 <wchogg> Ah, okay.
09:51:56 <jethr0> hehe, sounds much less depressing that way
09:52:05 <drakioned> I'm probably applying for the same project.
09:52:11 <int80_h> sweet :)
09:52:25 <int80_h> drakioned have you thought about Interactive Fiction?
09:52:25 <wchogg> I guess I'll just send out some e-mails today to the people who said they'd mentor the projects I'd like to do.
09:52:33 <shapr> I've been reading this Wadler paper about the Curry-Howard correspondence, it's way cool. He shows pix of the history of type theory.
09:52:36 <drakioned> hmm? what's that?
09:52:45 <shapr> Those crazy angle symbols came from Frege, I had no idea.
09:52:47 <int80_h> it's like mudding but just one person plays.
09:53:08 <drakioned> er...
09:53:13 <drakioned> that sounds kinda.. dull
09:53:20 <int80_h> I considered it instead of the mud engine. It would accomplish the same Haskell promotion and education goals I think. Which is what Im after.
09:53:21 <jethr0> nice, i think i've glanced at that paper shortly. but somehow my haskell motivation has been exceptionally low recently :(
09:53:35 <int80_h> with the right storyteller it's alot of fun
09:53:44 <shapr> Well, this isn't Haskell exactly, but it's worth reading - http://homepages.inf.ed.ac.uk/wadler/papers/frege/frege.pdf
09:53:53 <xerox> Frege?
09:53:59 <xerox> Yay.
09:54:05 <shapr> jethr0: It's a version of his Dr. Dobbs article, and he got interviewed on Netcast too.
09:54:08 <drakioned> are you planning on doing it irrespective of Google?
09:54:14 <shapr> http://homepages.inf.ed.ac.uk/wadler/topics/history.html#drdobbs
09:54:23 <int80_h> the mud engine, yup. Now that I have someone to guide my efforts.
09:55:10 <drakioned> were you thinking of doing it purely on your own?
09:55:11 <wchogg> int80_h drakioned:  Am I wrong though that google is eventually going to put up an online application system?  Their soc webpage still says they're not taking applications and you can't sign in either.
09:55:30 <drakioned> wchogg: give it a few more hours?
09:55:57 <int80_h> drakioned: I'd like help once I get things organized. Too many cooks too soon will wreck the plan.
09:56:16 <int80_h> But I want to work out the scope, and the design
09:57:29 <int80_h> I'm only doing the driver for the mud, I'll have a primitive mudlib but for demo purposes only. This will be a tool for others to write muds
09:57:40 <drakioned> I've sorta mapped out a way of organising the objects in my head, and I think that once that data structures are done, it'll just guide the coding.
09:58:06 <int80_h> objects? does FP uses objects ?
09:58:30 <int80_h> in my understanding FP has no state, therefor no objects
09:58:41 <drakioned> FP can have state.
09:59:07 <int80_h> hmm, is it ugly though?
09:59:19 <int80_h> would a pro step in to this discussion please?
09:59:25 <int80_h> shapr?
09:59:37 <jethr0> i'm not a pro
09:59:38 <sethk> int80_h, you have many ways to have state
09:59:42 <drakioned> it's not really ugly..
09:59:50 <jethr0> but i'd say that for simple stuff you won't need state
09:59:50 <sethk> int80_h, you have IORef, 
09:59:53 <sethk> you have state monads
09:59:57 <sethk> you have monads in general
09:59:57 <drakioned> STRefs
10:00:00 <jethr0> and for complex stuff you'd use very specialized monads/arrows
10:00:03 <int80_h> ahhh
10:00:07 <sethk> you have mutable arrays
10:00:25 <sethk> and with a ref you can turn anything into state.
10:00:25 <drakioned> I wrote a factorial function using STRefs, it looked oddly like C.
10:00:33 <int80_h> Okay looks like I'll be making friends with monads this summer, I hope
10:00:45 <sethk> int80_h, don't look to monads first
10:01:04 <sethk> int80_h, much more frequently what you want is an IORef, or an MVar, or such things
10:01:14 <int80_h> ah okay will keep that in mind
10:01:15 <jethr0> sethk: which lie inside a monad
10:01:27 <sethk> jethr0, in a sense, but not one you explicitly code
10:01:41 <drakioned> er.. I was trying to try and make use of a TVar, but mahogny thought it might be overkill.
10:01:43 <sethk> jethr0, you start off in the IO monad, so that's inescapable
10:01:52 <sethk> drakioned, why?
10:02:07 <sethk> drakioned, does it do more than you need?
10:02:21 <drakioned> sethk: well, the load wouldn't need it.
10:03:03 <sethk> drakioned, ok.  I don't know what you are working on, so I don't have context for that statement
10:03:25 <drakioned> sethk: well, it'll be a server and maybe 20 clients shooting text at each other.
10:03:50 <sethk> drakioned, what's done with the text?
10:05:08 <drakioned> well, stuff from the clients will get parsed into commands, which will be some sort of functions that act like mudState -> mudState, with mudState being stored inside a MVar
10:06:10 <drakioned> and the text shot to the clients will just be sucess or failure messages (dressed up in the context of the mud)
10:06:16 <sethk> drakioned, I use MVars and also Chan in my client/server apps, generally speaking
10:07:23 <drakioned> sethk: yeah, I think MVars would be more than enough for the job.
10:08:05 <drakioned> int80_h: how were you planning to do it without state?
10:08:20 <sethk> drakioned, then stick with them.  One of the things I've found with haskell is that refactoring is generally much easier than with other languages, and I worry less about future capabilities.
10:08:50 <SyntaxNinja> why is everone opped all the time these days?
10:08:51 <int80_h> drakioned: I had no idea ;)
10:09:02 <int80_h> to keep us nebies in line
10:09:24 * int80_h gets back to the coal mines and starts a'workin'.
10:09:26 <sethk> SyntaxNinja, no idea, maybe they have an alarm on whenever my nic appears  :)
10:09:36 <xerox> SyntaxNinja: we're experiencing spammers so often :-(
10:10:14 <SyntaxNinja> xerox: ahh
10:14:45 <SimonRC> @type let f = putStrLn "hi" >> f in f
10:14:46 <lambdabot> forall b. IO b
10:14:50 <SimonRC> shapr: that one ^^^
10:15:29 <SimonRC> It's certainly worked out that the function does not return in the normal manner.
10:16:08 <sethk> right, the >> operator requires IO something on the right side
10:16:41 <sethk> it returns in a perfectly normal manner, by the return type is IO b
10:16:44 <xerox> (>>) Monad m => m a -> m a -> m a
10:16:48 <xerox> Add a '::' :-)
10:17:31 <Lor> and change the first a to b
10:18:12 <sethk> Lor, in what, in lambdabot's type?
10:18:38 <Lor> @type (>>)
10:18:40 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
10:19:03 <Lor> The left-hand argument's type can be anything, since it's executed for side effects only and the return value is ignored.
10:19:53 <xerox> That's right.
10:22:18 <akemp> @seen SyntaxNinja
10:22:18 <lambdabot> SyntaxNinja is in #haskell-overflow, #haskell and #haskell-blah. I last heard SyntaxNinja speak 1 minute and 35 seconds ago.
10:22:40 <akemp> SyntaxNinja: a couple of questions about cabal-install?
10:22:42 <int80_h> haskell-overflow?
10:22:52 <int80_h> we have so many people we need an overflow channel?
10:23:09 <seba> hi... i need to test my hugs program and I prepared a test text file as an input... what is the best way to pass this file to hugs?
10:24:24 <seba> foldl
10:26:15 <drakioned> seba: umm. test <- readFile "somefilename" ?
10:26:27 <drakioned> then yourfunction test
10:26:54 <drakioned> haven't used hugs in ages, but that's the way it works in ghci
10:27:15 <dcoutts_> that's a ghci extension
10:27:41 <seba> ok. thanks!
10:28:10 <drakioned> dcoutts: howse it done in hugs then?
10:28:42 <dcoutts_> do {test <-  readFile "somefilename"; ... }
10:28:59 <drakioned> ah
10:29:13 <dcoutts_> ghci also has: let foo = 3
10:29:34 <dcoutts_> as opposed to requiring: let foo = 3 in ...
10:29:36 <lispy> > let foo = 3
10:29:36 <lambdabot>  parse error on input `}'
10:29:53 <lispy> dcoutts_: that's becaus everything is implicitly in a monad
10:30:03 <dcoutts_> lispy, yes
10:30:09 <norpan> ghci also has x <- return 10
10:30:22 <lispy> dcoutts_: i geuss you're a veteran and would know that :)
10:30:24 <dcoutts_> norpan, yep, that's where we came in :-)
10:30:44 <norpan> yes
10:30:49 <dcoutts_> lispy, it's sort of the IO monad
10:31:00 <norpan> it's like it's in a big do statement
10:31:11 <dcoutts_> with some extra magic for things that are not of type IO
10:31:14 <lispy> dcoutts_: why only sort of?
10:31:16 <lispy> ah
10:31:19 <dcoutts_> but are an instance of Show
10:31:23 <shrimpx> i wonder how many lines of IRC log are dedicated to explaning monads to people in this channel
10:31:39 <dcoutts_> shrimpx, I'd guess 10-20% :-)
10:31:41 <lispy> shrimpx: a lot
10:31:52 <lispy> just like types
10:32:03 <shrimpx> probably a good (inverse) measure of how easy they are to understand
10:32:04 <drakioned> are there many for explaining co-monads?
10:32:15 <dcoutts_> shrimpx, I wonder how many lines of #java IRC log are dedicated to explaing OOP :-)
10:32:24 <shrimpx> you think?
10:32:31 <shrimpx> hmm
10:32:36 <lispy> dcoutts_: explaining or poorly explaining ;)
10:32:37 <shrimpx> yea i guess
10:32:39 <Lemmih> akemp: Questions?
10:32:40 <dcoutts_> heh
10:32:47 * lispy shurgs
10:32:58 <lispy> i find OO just as confusing as FP once you get past the basics
10:33:00 <sethk> discussing
10:33:10 <dcoutts_> lispy, inheritance is the best thing since sliced bread because ....
10:33:20 <sethk> lispy, oh, much more confusing, because when you get into the details, you find big holes
10:33:37 <shrimpx> OOP is confusing for sure
10:33:41 <dcoutts_> ... it tightly couples your program?
10:33:53 <lispy> but in FP you can write some really weird code, take for example the output of @pl
10:34:02 <ndm> i find OOP far less confusing than Monads :)
10:34:04 <dcoutts_> that's cool, not wierd :-)
10:34:14 <drakioned> incidentally, what does the @ sign do anyway?
10:34:21 <shrimpx> ndm: monads are simple; but people fail to explain them well
10:34:28 <lispy> dcoutts_: heh, yeah...i have this rant about a java api i've been using at work...factories galore and yet you have no flexibility or extensibility
10:34:29 <shrimpx> first, the name is retarded
10:34:38 <ndm> shrimpx: everyone on this channel has at one point or another tried to explain them to me
10:34:51 <shrimpx> imagine if "object" as called "bliploop"
10:35:03 <ndm> (although i'm finally starting to get them :) )
10:35:08 <Oejet> shrimpx: Or "warm fuzzy thing"?
10:35:09 <dcoutts_> lispy, yeah, OOP allows you to easily extend in some dimensions and not others.
10:35:27 <lispy> shrimpx: i'd like to call it PiInstanceCombinator instead of Object
10:35:34 <shrimpx> sweet!
10:35:37 <dcoutts_> lispy, where as functions on concrete date are sort of the other way around
10:35:38 <lispy> shrimpx: then see if people get confused :)
10:35:38 <ndm> dcoutts_, OOP models the real world - it has an easily understandable metaphore
10:36:01 <shrimpx> except it doesn't when you really start working with it
10:36:06 <akemp> Lemmih: FYI I moved cabal-get into Cabal-darcs and Isaac renamed it to cabal-install.
10:36:07 <dcoutts_> ndm, yeah, at first perhaps. I think it's only skin deep.
10:36:08 <shrimpx> wtf is a virtual method in the real world
10:36:10 <Oejet> ndm: Yeah, Dan Ingells calls that "simulation".
10:36:23 <SyntaxNinja> hi akemp
10:36:32 <sethk> ndm, oop hardly models the real world in any meaningful way
10:36:43 <lispy> personally, i think every paradigm is good for some thing and the best languages recognize that a straight jacket shouldn't be worn by most people
10:36:47 <shrimpx> http://www.daimi.au.dk/~madst/tool/papers/expression.txt
10:37:00 <ndm> sethk, it models the world in the way people think about the world, which is the most important one
10:37:09 <akemp> Lemmih, SyntaxNinja: where is the *proper* place to store system-wide cabal-install configuration and package files.
10:37:12 <sethk> ndm, no, the important models are those that are accurate.
10:37:32 <SyntaxNinja> akemp: /etc/cabal-install on unix. i'm not sure what to do for windows.
10:37:36 <shrimpx> maybe that's not the right msg
10:37:51 <jethr0> ndm: that is the biggest lie of OO ever
10:37:58 <akemp> Currently, they're in /etc/cabal-install or ~/.cabal-install.  Wouldn't they be better hosted in one of the Haskell directories?
10:38:15 <jethr0> at some point the OO paradigm just breaks down when faced with how humans model processes
10:38:16 <lispy> shrimpx: oh, this still looks interesting
10:38:25 <ndm> SyntaxNinja: Documents and Settings/All Users/Application Data/Cabal for windows users
10:38:36 <sethk> jethr0, it breaks down as soon as the problem is not unidimensional
10:38:49 <shrimpx> lispy: yea that msg was illuminating for me
10:38:57 <jethr0> that might be the humans' fault or the paradigms, but there's nothing i more strongly object to that saying "OO models exactly how a human perceives the specification"
10:39:06 <sethk> jethr0, usually referred to as "the tyranny of the primary  decomposition"
10:39:17 <akemp> ndm: hmmm...  I was thinking along the same lines for *nix.  cabal-install files should be hosted in $prefix/Cabal/ghc-version.
10:39:22 <lispy> does anyone program in GJ?
10:39:28 <lispy> i've never heard of it
10:39:46 <shrimpx> so i fear the rigidity of the subclassing structure in OOP
10:40:02 <ndm> akemp, well for application data that is systemwide, Documents and Settings/All Users/Application Data/ is $prefix
10:40:12 <ndm> on Windows, if you want to follow the guidelines
10:40:14 <shrimpx> when you have a huge class tree it becomes close to impossible to making big structural changes
10:40:25 <lispy> shrimpx: yeah :(
10:40:27 <shrimpx> s/making/make
10:40:29 <SyntaxNinja> ndm: akemp, it woudl be great if System.FilePath had this concept, if it doesn't already.
10:40:34 <jethr0> when looking at liskov's substitution principle and how complex object interaction can quickly become, the idea of OO representing human modeling just seems like a farce
10:40:39 <akemp> SyntaxNinja: since most of GHC's information is hosted in $prefix/lib/*, it seemed to make sense to host cabal-install's information there, too.
10:40:49 <lispy> shrimpx: nice to bump into you again, BTW
10:40:54 <shrimpx> lispy: yea :)
10:41:08 <shrimpx> lispy: i wasn't on irc for many months
10:41:28 <akemp> ndm: true.  GHC hosts system-wide data at /usr/local/lib/ghc* on my Linux boxen.
10:42:08 <SyntaxNinja> akemp: why? cabal-install isn't ghc, it isn't a library.
10:42:09 <davidhouse> can anyone access http://carwash.cs.nott.ac.uk:992/~lyh/gtk2hs/ ?
10:42:22 <jethr0> sethk: i certainly haven't come across _any_ problem that was "cleanly" modellable in OO. and that pretty much freaked me out because i had believed that OO was supposed to do away with paradigm-compromising situations. but clearly it's not!
10:42:25 <gog> hello, I'm trying to write a program that prints the contents of an mysql table. the code (not much) is here: http://rafb.net/paste/results/DzuAG131.html  Unfortunately, ghc aborts with an error: Ambiguous type variable `a' in these top-level constraints: `SqlBind a' arising from use of `getFieldValue' at junk.hs:20 / `Show a' arising from use of `show' at junk.hs:20
10:42:38 <SyntaxNinja> akemp: cabal-install is just a program like any other.  just because it's written in Haskell doesn't mean it should go someplcae funny ;)
10:42:39 <lispy> shrimpx: me either strangley enough
10:42:42 <drakioned> davidhouse: I can't.
10:42:49 <davidhouse> drakioned: thanks.
10:42:53 <sethk> jethr0, the literature on the failures of OO is legion.  no knowledgable person would claim it is accurate
10:42:56 <dcoutts> davidhouse, me neither
10:43:14 <davidhouse> ah, dcoutts. that would be the location of the debian rpms for gtk2hs. :)
10:43:25 <drakioned> davidhouse: are you at Nottingham?
10:43:27 <dcoutts> davidhouse, hmm
10:43:41 <akemp> SyntaxNinja: I guess I'm trying to figure out where the correct place to store cabal-install files would be.  cabal-install is part of Cabal, so it seems as though it should fit into /usr/local/lib/Cabal* or /usr/local/share/ghc*.
10:43:50 <dcoutts> SyntaxNinja, can I change the cabal release to have a versioned tarball? cabal-1.1.4.tar.gz with cabal-1.1.4 as it's subdir.
10:43:52 <davidhouse> drakioned: nope.
10:43:57 <akemp> s/ghc/Cabal
10:44:00 <drakioned> ok
10:44:20 <dcoutts> SyntaxNinja, unversioned tarballs are a pet peve of mine (and it's how everyone else does it - even cabal sdist :-) )
10:45:12 <SyntaxNinja> dcoutts: that's fine. 
10:45:33 <dcoutts> cool
10:45:38 <norpan> gog: it's because getFieldValue can return different types and you haven't specified which one you want
10:46:14 <SyntaxNinja> akemp: it does depend on the system somewhat. properly, cache files like the packages tarballs should probably go somewhere into /var, config files should go into /etc.  It definitely doesn't seem right for tarballs to go into share or lib anywhere.
10:46:25 <SyntaxNinja> but what do you mean by cabal-install files?
10:46:42 <akemp> SyntaxNinja: server.list, package.list, packages/
10:47:23 <davidhouse> dcoutts, would it be easy to build gtk2hs from source or would that require a whole host of extra dependencies?
10:47:59 <dcoutts> davidhouse, no, no extra deps I think. You need the *-devel packages to use gtk2hs anyway
10:48:35 <davidhouse> lets give that a shot then.
10:49:18 <akemp> SyntaxNinja: for example, ghc stores some data files at /usr/local/share/ghc-.../ on my machine.  I think that Cabal considers /usr/local/share the 'data-dir' on my machine.
10:49:27 <norpan> gog: if I remember correctly you could do something like x :: String <- getFieldValue ... and then not use show on x but use x directly
10:50:08 <gog> norpan, I want to be independent of the value type (e.g. the first column could have type String and the second Int), that's also why I'm using show
10:50:21 <SyntaxNinja> akemp: really, they should go into /var/cache/cabal-get.
10:50:44 <SyntaxNinja> oh, but server.list should go into /etc
10:51:06 <SyntaxNinja> if the user configures it, like server.list, it goes into /etc.  if "cabal-get update" modifies it (like package.list, I think) it should go into /var
10:51:49 <akemp> Hmm...  Will that map onto Windows?  (not that I particularly care...)
10:52:01 <tibbe> How can I programatically get get hold of (and open) a view I've added to my plugins.xml?
10:52:12 <norpan> gog: but it needs a type because the show function is different for each type
10:52:20 <norpan> so it needs to know which show function to use
10:52:33 <SyntaxNinja> ndm: opinion?
10:53:10 <SyntaxNinja> akemp: I thiknk the Right Thing would be to fix Sytsem.FilePath to have configFileDir and varDir or something, which points you to the right place on unix and different versions of windows.  I'm nto sure even if other linux versions use var or var/cache or whta.
10:53:29 <ndm> SyntaxNinja: on windows you can put anything anywhere you like, so long as its beneath Documents and Settings\All Users\Application Data\Cabal
10:53:48 <ndm> or Documents and Settings\<user name>\Application Data\Cabal for user specific things
10:54:05 <ndm> if its easier, you can just create /var /lib /etc under that path
10:54:12 <ndm> the user is never expected to go there
10:54:18 <gog> norpan, ok, thanks
10:54:30 <akemp> My recommendation would be to put server.list, package.list, package/ into /usr/local/lib/Cabal-*.  That bolts cabal-install's files into an existing structure.
10:54:35 <davidhouse> dcoutts, getting some build errors:
10:54:39 <davidhouse> tools/c2hs/base/general/GetOpt.hs:1:0:
10:54:40 <davidhouse>     Module `GetOpt' is a member of package util-1.0.
10:54:40 <davidhouse>     To compile this module, please use -ignore-package util-1.0.
10:55:03 <tibbe> oops, misspost
10:55:21 <dcoutts_> davidhouse, what ghc version?
10:55:37 <davidhouse> 6.4.1
10:56:01 <dcoutts_> davidhouse, you've got a package registered that is exposed and depends on the old util package
10:56:08 <akemp> That said, it seems to be a challenging topic.  I'll create a ticket to capture the discussion.
10:56:22 <mauke> let x = read . show doesn't compile. is this the monomorphism restriction?
10:56:36 <dcoutts_> danly, this breaks other packages because it effectively exposes the util package which should not be exposed because it clashes with other things.
10:56:47 <xerox> mauke: yes.
10:56:48 <dcoutts_> err davidhouse not danly , oops
10:57:07 <davidhouse> dcoutts, the extra packages i've installed are hs-plugins, cabal, fps and jregex.
10:57:41 <dcoutts_> davidhouse, use ghc-pkg field ${pkg} depends on each of those to find the one that exposes util
10:58:35 <davidhouse> cabal, it seems.
10:58:49 <davidhouse> dcoutts, can i use a --with-hcflags to sort this out?
10:58:51 <dcoutts_> davidhouse, you've got an old version of cabal installed?
10:59:04 <dcoutts_> what version?
10:59:34 <dcoutts_> you must have something >1.0 but less than 1.1.4
10:59:41 <Cale> mauke: basically, since it's a pattern binding, the MR says that it must have some monomorphic type, but there's no defaulting mechanism for the class Read, and so it doesn't know which type to pick.
10:59:49 <davidhouse> dcoutts, it just says 1.0
11:00:11 <palomer> anyone know what the ConfigSize field of Config does in quickcheck?
11:00:13 <dcoutts_> davidhouse, hmm, that's odd. the 1.0 that came with ghc didn't have that problem
11:00:22 <dcoutts_> davidhouse, I suggest you upgrade cabal
11:00:37 * dcoutts_ is just about to roll a cabal-1.1.4 tarball
11:00:52 <sethk> wasn't there a paste 'bot url in the topic?  anybody remember it?
11:01:00 <dcoutts_> @paste
11:01:01 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:01:08 <dcoutts_> hmm, not that one
11:01:18 <davidhouse> dcoutts, okay. my cabal didn't actually come with ghc
11:01:20 <davidhouse> @where paste
11:01:21 <sethk> yes, the lispish one
11:01:21 <lambdabot> http://paste.lisp.org/new/haskell
11:01:29 <sethk> that one?
11:01:31 <dcoutts_> davidhouse, that'll explain it
11:02:29 <davidhouse> @where cabal
11:02:30 <lambdabot> http://www.haskell.org/cabal
11:03:01 <davidhouse> odd.
11:03:08 <xerox> ?type odd
11:03:09 <lambdabot> forall a. (Integral a) => a -> Bool
11:03:10 <davidhouse> http://www.haskell.org/cabal/download.html points to 1.0 as the latest stable version
11:05:03 <davidhouse> where can i get a later version?
11:06:05 <dcoutts_> @where cabal
11:06:05 <lambdabot> http://www.haskell.org/cabal
11:06:43 <dcoutts_> http://www.haskell.org/cabal/release/rc/cabal-1.1.3.tar.gz
11:07:26 <davidhouse> thanks, dcoutts.
11:11:34 <lisppaste2> sethk pasted "can I make this polymorphic?" at http://paste.lisp.org/display/19577
11:12:24 <davidhouse> dcoutts_, cabal 1.1.3 installed, but it still depends on util-1.0
11:13:43 <Cale> sethk: Despite the fact that you're discarding the return value, the type still matters.
11:13:51 <sethk> Cale, yes, I know
11:13:54 <sethk> Cale, that's the problem
11:13:57 <Cale> sethk: It determines which instance of the class will e used.
11:13:59 <Cale> be*
11:14:16 <Cale> Without that knowledge, it's impossible for the compiler to know which code to compile
11:14:17 <sethk> Cale, yes I know, although in this case I don't care, but there is no way for the compiler to know that.
11:14:40 <sethk> Cale, can I lie to the compiler and tell it that the response is a different class?
11:15:16 <Cale> not unless you want to use unsafe functions, and even then you'll probably have a segfault when it actually comes time to run the code
11:15:28 <sethk> Cale, well, obviously, that does no good.
11:15:58 <sethk> Cale, can I use a class method on the Server class to do it?
11:16:10 <dcoutts_> davidhouse, oh yeah, I forgot that I patched that specially. Try cabal-1.1.4
11:16:13 <Cale> hmm, actually, can I see the error?
11:16:25 <dcoutts_> davidhouse, you can be the first to test my new 1.1.4 release :-)
11:16:30 <sethk> Cale, sure, give me a minute to take the type annotation out and compile it.
11:16:34 <davidhouse> dcoutts_, excellent :) got a URL?
11:16:42 <dcoutts_> davidhouse, same as before but 1.1.4
11:16:47 <dcoutts_> http://www.haskell.org/cabal/release/rc/cabal-1.1.4.tar.gz
11:16:58 <Cale> sethk: the Server class -- does the request type determine the response type uniquely?
11:17:13 <sethk> yes
11:17:17 <Cale> you might try adding a fundep  | request -> response
11:17:20 <dcoutts_> SyntaxNinja, see http://www.haskell.org/cabal/release/cabal-1.1.4/
11:17:24 <Cale> and see if it clears up the problem
11:17:31 <sethk> Cale, ok, I will try that.
11:18:32 <Cale> because then it will restrict you so that at most one instance of Server request response can be given for any particular request type, but it will be able to use that instance to infer the response type
11:18:37 <Cale> which might be your problem
11:18:54 <sethk> Cale, that sounds promising, yes.
11:19:14 <sethk> Cale, that is the problem, it can't infer the response type, but I didn't know about fundep, I'll look at how to use it.
11:19:40 <Cale> See, the problem is that currently, you could have two instances (Server r s1) and (Server r s2) which use completely different code
11:19:57 <Cale> so without knowing that second type parameter, it doesn't have any idea what to do.
11:20:02 <sethk> Cale, yes, I see.  I don't do that, but the compiler has no way to know that I don't.
11:20:06 <Cale> right
11:20:18 <Cale> (and there's no guarantee that a future module won't)
11:23:16 <sethk> Cale, yes, of course.  I could tell the compiler to "trust me".  :)   I guess actually that the fundep does tell the compiler that it can rely on the behavior.
11:24:20 <Cale> yeah, and the compiler will prevent you if you actually do try to create an instance which violates the fundep
11:25:25 <sethk> hmm, fundep doesn't occur in the report.  I'll google for it.
11:26:30 <davidhouse> sethk, it's a GHC extension
11:26:44 <davidhouse> sethk: http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
11:26:48 <Cale> It's documented in the GHC User Guide.
11:26:52 <Cale> er, yeah :)
11:26:54 <sethk> davidhouse, cale, thanks
11:27:25 <sowha1> anyone aware of a library for pretty printing list of values to Tex? sort of renderTexTable:: [[String]] -> String function
11:28:44 <davidhouse> dcoutts_, i think it's working. many thanks for your help :)
11:34:49 <SyntaxNinja> dcoutts_: looking...
11:35:02 <dcoutts_> davidhouse, great
11:39:31 <SyntaxNinja> dcoutts_: building now... so in the future, my plan is to make, for instance 1.1.5 the darcs version, and so the next release should be 1.1.6
11:39:43 <dcoutts_> SyntaxNinja, yep
11:39:45 <SyntaxNinja> so for a release, you bump the version, make the release, then bump it again. 
11:39:50 <dcoutts_> yes
11:39:53 <SyntaxNinja> OK cool. 
11:40:28 <dcoutts_> so that there is no confusion over released versions
11:40:43 <dcoutts_> only devel versions cover a range of time/patches
11:40:43 <SyntaxNinja> dcoutts_: oh, we definitely need to get rid of cabal-install, and the build target for it doesn't work.
11:40:47 <SyntaxNinja> right.
11:41:06 <SyntaxNinja> 1.1.4 should not have cabal-install.
11:41:17 <dcoutts_> so what's the naming system now? cabal-(install|setup|get|...?)
11:41:48 <dcoutts_> SyntaxNinja, so the current 1.1.4 release has cabal-install? and it shouldn't. Is that a big problem?
11:41:58 <dcoutts_> do we need to respin the tarball?
11:42:41 <SyntaxNinja> yeah, need to respin it.  this cabal-install should definitely not go into a release.  GHC doesnt' come with it, I assume? so it's not a worry.
11:43:08 <SyntaxNinja> old cabal-get is now cabal-install, and will be expanded to include more stuff.  cabal-setup is basically a Setup.lhs script.
11:43:16 <dcoutts_> so delete it from the makefile and the tarball?
11:43:18 <SyntaxNinja> old cabal-install goes away.
11:43:19 <SyntaxNinja> yep
11:43:30 <dcoutts_> but leave darcs alone?
11:43:39 <SyntaxNinja> until we've got the new cabal-install going, I definitely don't want to pollute the world w/ this version.
11:43:42 <dcoutts_> sure
11:43:50 <SyntaxNinja> dcoutts_: yeah, a bit ugly for the tag, but I don't have any better ideas.
11:44:06 <dcoutts_> so the 1.1.4 darcs tag will have it but the tarball will not. that's ok I guess
11:44:14 <SyntaxNinja> dcoutts_: I hope this hasn't taken you too much time?
11:44:18 <SyntaxNinja> dcoutts_: right.
11:44:18 <kosmikus> I have to admit that I'm completely confused regarding all the Cabal versions at the moment ... 
11:44:20 <dcoutts_> most people won't poke at the old darcs version
11:44:32 <dcoutts_> kosmikus, yeah, we're trying to clean that up
11:44:46 <dcoutts_> kosmikus, the situation is 1.1.4 is the ghc 6.4.2 one
11:44:47 <SyntaxNinja> kosmikus: 1.1.3 is the last release, 1.1.4 will be the next release, and the version that came w/ ghc 6.4.2
11:44:51 <dcoutts_> 1.1.5 is the new devel version
11:44:53 <kosmikus> ok, please publish an RFC once you're done ;)
11:45:04 <SyntaxNinja> Request For Criticism 
11:45:20 <SyntaxNinja> I'm off to lunch be back in about an hour. dcoutts_ msg me with questions.
11:45:26 <dcoutts_> ok
11:45:38 <kosmikus> what's the 1.1.4 that I've been working with (that used to be darcs current)? that's going to be 1.1.5 now, but ghc-6.4.2's 1.1.4 is something older?
11:47:33 <palomer> <:o
11:47:39 <palomer> this'll take a while to check
11:47:43 <palomer> better sit back and enjoy the coffee
11:47:58 * palomer still hasn't run his code
11:48:58 <dcoutts_> kosmikus, right.
11:50:05 <dcoutts_> SyntaxNinja, new tarball is up, I'd apreciate if you could test it. I removed the cabal-install dir from the tarball and a line from make install
11:50:21 <dcoutts_> that is a line from the Makefile for the install target
11:51:00 <palomer> > [0..-1]
11:51:01 <lambdabot>  Not in scope: `..-'
11:51:09 <palomer> > [0..(-1)]
11:51:11 <lambdabot> []
11:51:28 <kosmikus> > [0.. -1]
11:51:30 <lambdabot> []
11:52:44 <sieni> > [0,-4..(-12)]
11:52:45 <lambdabot> [0,-4,-8,-12]
11:53:15 <palomer> nice
11:53:28 <ihope> Whee!
11:53:30 <ihope> That was weird.
11:53:32 <ihope> > [0..(-1)]
11:53:33 <lambdabot> []
11:53:34 * ihope waits for the other []
11:53:38 <ihope> > let enumFromTo x y = [x,y] in [0.. -1]
11:53:39 <lambdabot> []
11:53:40 <ihope> enumFromThenTo?
11:53:42 <ihope> Hmm...
11:53:44 <ihope> > [..2]
11:53:44 <lambdabot>  parse error on input `..'
11:53:52 <ihope> @bot
11:53:53 <lambdabot> :)
11:55:40 <palomer> is there a function Int -> m a -> m [a] ?
11:55:51 <palomer> @hoogle Int -> m a -> m [a]
11:55:52 <lambdabot> No matches, try a more general search
11:56:09 <palomer> I want to generate random elements
11:56:10 <araujo> Hello!
11:56:11 <palomer> n random elements
11:56:22 <palomer> and m a computes a random element of type a
11:57:02 <palomer> and I want to compute many arndom elements of type a
11:57:10 <palomer> brb
11:58:59 <Igloo> replicateM
11:59:19 * Igloo wonders why hoogle didn't find it
11:59:56 <ihope> @index randoms
11:59:56 <lambdabot> System.Random
12:00:06 <ihope> @type System.Random.randoms
12:00:07 <lambdabot> forall a g.
12:00:07 <lambdabot>          (Random a, RandomGen g) =>
12:00:07 <lambdabot>          g -> [a]
12:00:31 <ihope> @docs System.Random
12:00:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
12:00:52 <ihope> System.Random.getStdGen :: IO StdGen
12:02:34 <ihope> Oh, right, new idea: class classes.
12:03:14 <ihope> class NumClass n where add :: n a => a -> a -> a
12:03:25 <ihope> instance NumClass Num where add = (+)
12:03:29 <ihope> :-)
12:09:20 <amiddelk> ihope: you can do that already by making Num a superclass of NumClass ;)
12:09:56 <ihope> You mean making NumClass a superclass of Num?
12:11:31 <amiddelk> no, just: class Num a => NumClass a where add :: a -> a -> a; add = (+)
12:12:21 <ihope> Um...
12:12:34 <ihope> class NumClass a where add :: a -> a -> a
12:12:48 <ihope> instance Num a => NumClass a where add = (+)
12:15:12 <mauke> > [()..()]
12:15:13 <lambdabot> [()]
12:15:20 <ihope> But that's not what I mean. I meant class classes!
12:15:40 <ihope> class ClassClass c a where classClass :: c a => a
12:16:10 <ihope> So classClass :: (ClassClass c a, c a) => a.
12:18:59 <ihope> Give classes kinds, too.
12:19:06 <ihope> Num :: * -> %
12:19:15 <ihope> Monad :: (* -> *) -> %
12:22:25 <Lor> MonadPlus: forall m : (* -> *), Monad m -> %
12:23:43 <Lor> Hm, actually, % is the kind of _instances_, right? Num Int : %
12:24:36 <Saulzar> Morning, haskellers
12:24:39 <ihope> Yeah, I guess so.
12:24:50 <ihope> Unless you happen to have "class Foo where ..."
12:24:53 <ihope> :-)
12:25:33 <Lor> Are nullary classes legal?
12:25:40 <Lor> Anyway, then you'll just have at most one instance.
12:26:54 <ihope> Now, with this, you could also get weird stuff like "type Foo c = forall a. c a => a", so "Foo :: (* -> %) -> *" :-)
12:32:03 <glauber_sp> hi guys! who's responsable for the portage ebuild in http://www.haskell.org/~gentoo/gentoo-haskell/ ? I need to report a bug and I don't know where =)
12:32:27 <jyp> dcoutts, afaik
12:32:51 * Saulzar has just been using Haskell for a 48 hour game devel competition, the odd one out
12:32:56 <gog> any idea why this small programm causes a segfault?  http://rafb.net/paste/results/NHP0Xd42.html
12:34:05 <Lor> Is that how HSQL is used? You construct sql queries with plain string appending?
12:34:12 <gog> (ghc-6.2.2)
12:35:20 <shapr> I want Haskell to have something like PyGame.
12:36:11 <stepcut> gog: I used to know -- I think you might have to make some other call between query and getFieldValue or something :-/
12:36:14 <gog> Lor, the second argument to query is the text of the sql query, yes
12:36:20 <ihope> shapr: a what?
12:36:24 <Saulzar> Yeah, there were 50 C++ entries and 50 PyGame - still I don't quite know what PyGame does. I thought it was just a SDL binding or?
12:36:38 <shapr> ihope: http://www.pyweek.org/
12:36:57 <shapr> Saulzar: PyGame is a whole game toolkit.
12:37:11 <Saulzar> This one was ludumdare.com, instead of a week it's just a weekend
12:37:21 <shapr> I've found six or seven really cool innovative games written with PyGame.
12:37:59 <shapr> '20,000 Light Years Into Space' is really addictive until you beat Expert level.
12:38:13 <ihope> > 0^0
12:38:14 <lambdabot> 1
12:38:23 <ihope> > 0.0^^0.0
12:38:24 <lambdabot> Add a type signature
12:38:31 <ihope> > 0.0**0.0
12:38:32 <lambdabot> 1.0
12:38:56 <mauke> > [[]..[]]
12:38:57 <lambdabot>  add an instance declaration for (Enum [a])
12:38:57 <lambdabot>   In an arithmetic sequence: [[] .. []]
12:38:57 <lambdabot>   In the definition of `dhz': dhz = [[] .. []]
12:39:03 <ihope> :-)
12:39:16 <ihope> > (()..())
12:39:17 <lambdabot>  parse error on input `..'
12:39:25 <ihope> > [..]
12:39:26 <lambdabot>  parse error on input `..'
12:39:31 <ihope> > enum
12:39:32 <lambdabot>  Not in scope: `enum'
12:40:50 <shapr> Saulzar: Is the competition over?
12:41:16 <Saulzar> shapr, Yeah - about 16 hours ago - of which I have slept most :)
12:42:15 <shapr> Sounds like fun!
12:43:03 <Saulzar> It was, exausting though. Now they games have to be played which should not be such a strain!
12:45:14 <Saulzar> I need to pester somone with hsSDL to compile my game for windows. Maybe olliej when he wakes up. Under what situations is hsSDL broken in windows?
12:46:55 <eivuokko> Last time I tried, only graphics works and it's jsut build issue
12:47:07 <gog> stepcut, it works when I call fetch before using getFieldValue. still, it shouldn't segfault
12:50:58 <stepcut> gog: yeah -- there is a bug in HSQL -- i think it passes a null pointer or something via the FFI
12:57:06 <glauber_sp> guys, is anyone using gentoo ~x86 and ghc 6.4.2 from the oficial ebuild?
13:02:38 <RyanT5000> is there a way to look up the open handles of the current process?
13:02:52 <RyanT5000> (haskell handles, that is)
13:02:59 <ValarQ> glauber_sp: probably some of the guys in #gentoo-haskell
13:03:20 <RyanT5000> i'm looking for a haskell solution not a "/proc" solution
13:04:02 <norpan> i don't even know if there is a way from c
13:04:16 <RyanT5000> crap
13:04:30 <glauber_sp> ValarQ, thanks =) I didn't know that channel =)
13:05:09 <ValarQ> RyanT5000: it must be easier to read /proc than to do a syscall anyway
13:05:12 <RyanT5000> norpan: the goal is to get ahold of the RTS's handle to program.prof, and make it unbuffered
13:05:33 <RyanT5000> ValarQ: also i'm on windows :)
13:05:54 <norpan> RyanT5000: gah
13:05:59 <RyanT5000> yeah
13:06:09 <RyanT5000> basically, i can't for the life of me figure out how to make my program not crash on exit
13:06:14 <RyanT5000> and i need to get profiling information out
13:06:27 <RyanT5000> i'm using SDL and for some reason it just refuses to not crash
13:06:34 <RyanT5000> i think that's partially because its on windows
13:07:10 <ValarQ> RyanT5000: i guess that means that windows doesn't have /proc ...
13:07:17 <RyanT5000> ValarQ: right
13:07:24 <ValarQ> tricky
13:07:31 <ValarQ> what does it use instead?
13:07:37 <RyanT5000> uh, shitty cryptic APIs?
13:07:49 <RyanT5000> filesystems are not made lightly on windows
13:07:51 <RyanT5000> the devkit is $1000
13:08:09 <RyanT5000> (very difficult to "magically find" too)
13:08:20 <ValarQ> ow
13:08:24 <RyanT5000> yeah
13:08:37 <RyanT5000> and afaik there's no equivalent of user-mode file systems
13:08:45 <RyanT5000> we don't even have symlinks, except for directories
13:08:54 <RyanT5000> and we only have hardlinks for files
13:09:01 <RyanT5000> and you have to use special tools for both
13:09:36 <RyanT5000> hm, if i try to open the same file twice, will it return the same handle?
13:09:46 <norpan> no
13:09:47 <ValarQ> you can still use /proc if your end product doesn't need to run on windows
13:09:56 <RyanT5000> no, it does
13:10:06 <RyanT5000> it's a game, and i want to sell it to the 94% of people who use windows :)
13:10:14 <RyanT5000> that's the only reason i'm even running windows now
13:10:55 <RyanT5000> but i don't think /prof would help anyway
13:11:42 <RyanT5000> i need to take over the handle and make it unbuffered
13:11:46 <RyanT5000> which i don't think i could do from /prof
13:11:53 <RyanT5000> */proc
13:12:03 <RyanT5000> (i'm using -prof in my other window)
13:12:18 <ihope> ?? force
13:12:19 <lambdabot> Not enough arguments to @.
13:12:22 <ihope> Oops.
13:18:44 <sjanssen> RyanT5000: still trying to get your segfaulting program to print profiling info?
13:19:09 <RyanT5000> yep
13:19:39 <RyanT5000> i now know that it's crashing in RTS code somewhere
13:19:53 <sjanssen> ooh, that sounds nasty
13:19:55 <RyanT5000> becuase it crashes after i call exit
13:20:00 <RyanT5000> exitWith, rather
13:20:11 <SyntaxNinja> dcoutts_: I think this cabal tarball looks good
13:20:12 <RyanT5000> and i debugged and it was in the .exe module
13:20:20 <RyanT5000> oh i guess it could be in sdl.lib though
13:20:30 <RyanT5000> however i don't think there's much to SDL.lib
13:20:57 <RyanT5000> in any case i'm pretty sure it's a problem with conflicting at_exit handlers
13:22:11 <araujo> Hello!
13:22:18 <RyanT5000> hi
13:26:04 <kzm_> @seen
13:26:05 <lambdabot> Lately, I have seen araujo, arjanoosting, glauber_sp, ihope, kosmikus, kzm_, lemmih, ryant5000, shapr, sjanssen, syntaxninja and xerox.
13:26:17 <kzm_> busy night?
13:26:57 <kzm_> I'm having some cabal trouble; I thought --user would allow me to install packages without involving root.
13:27:02 <kzm_> Is that incorrect?
13:27:16 <eivuokko> It should be correct.
13:27:26 <kosmikus> that's the idea, I think
13:27:44 <kzm_> I.e Setup.hs configure --user --prefix=/foo/bar
13:28:09 <eivuokko> I think it's install that takes --user
13:28:22 <kzm_> Ah, of course!
13:28:43 * kzm_ thanks eivuokko.
13:29:14 <SyntaxNinja> kzm_: depends on cabal version, but if you tell configure --user, then install will also respect --user.
13:29:19 <SyntaxNinja> but I think that's new in 1.1.4
13:29:34 <SyntaxNinja> s/respect/assume
13:30:02 <kzm_> I see.  Somehow, I thought I'd configure everything in "configure".
13:30:15 <SyntaxNinja> kzm_: ./setup configure --help|grep user # explains what that version of user does
13:31:09 <SyntaxNinja> kzm_: I really have no idea why configure --user didn't used to imply install --user... but in any case, the user flag on install makes htings more flexible.
13:31:17 <kzm_> Is there a binary search for arrays lying around somewhere?
13:31:47 <kzm_> Well..I suppose it is possible that you want to depend on user packages, but still install in the trunk?
13:31:54 <kzm_> But probably not :-)
13:32:04 <eivuokko> Hmmm.  That sounds *tricky*
13:32:54 <SyntaxNinja> kzm_: right, it's a bad idea. but the other way is quite possible.
13:32:57 <kzm_> It is probably not what you want - perhaps there should be a --put-it-in-the-main-anyway for install, which overrides --user from configure
13:33:12 <kzm_> Or, in line with Haskell tradition --unsafe-nonuser :-)
13:33:12 <SyntaxNinja> kzm_: like I said, the new version of cabal does the right thing[
13:33:29 <kzm_> Yep.
13:33:51 <kzm_> (how can I tell the cabal version anyway?)
13:34:09 <SyntaxNinja> ghc-pkg -l |grep Cabal
13:34:48 <kzm_> Hmm.. 1.0.  Should I upgrade?
13:35:26 <dcoutts> SyntaxNinja, ok, great
13:35:31 <eivuokko> SyntaxNinja, what is the desgined way to use hooks to implement new parameters for configure in Cabal?  I have found myself writing preConf-hook to do the work and overwrite postConf not to get error from extra params.
13:35:34 <SyntaxNinja> kzm_: the new ghc (6.4.2) comes w/ 1.1.4 (for better or worse) which dcoutts is just in the midst of packaging as a standalone tarball.  so you might try that one :)
13:36:19 <kzm_> I just installed Ubuntu Dapper.  It would be really nice if they could package all of that before release.
13:36:22 <SyntaxNinja> eivuokko: I thought configure ignored extra params.
13:36:33 <SyntaxNinja> down with ubuntu! up with debian!
13:36:35 <SyntaxNinja> ;)
13:36:38 <eivuokko> SyntaxNinja, only if it can run ./configure (autoconf-generated or similar)
13:36:56 <kzm_> ..but unless there are evil bugs lying around, I'm not going to bother with a manual install.
13:36:58 <SyntaxNinja> eivuokko: you can override the configure command itself.
13:37:10 <jyp> Is Igloo still working on debian packaging ?
13:37:19 <kzm_> Ubuntu is pretty much Debian.  Which is why it is so nice.
13:37:24 <kzm_> jyp, I think so.
13:37:30 <eivuokko> SyntaxNinja, yes, I know.  But it seems funny to overwrite two hooks where one is "return ExitSuccess"
13:37:33 <jyp> cool
13:37:47 <kzm_> And 6.4.2 is there, so Ubuntu can just snarf it.
13:38:12 <SyntaxNinja> eivuokko: I'm not sure I understand. can you send me email?
13:38:27 <SyntaxNinja> yeah, once dcoutts_ makes a tarball I guess I'll package cabal for debian.
13:38:51 <dcoutts> SyntaxNinja, I've put up the tarball, it's done!
13:39:23 <dcoutts> http://haskell.org/cabal/release/cabal-1.1.4/cabal-1.1.4.tar.gz
13:39:26 <jyp> kzm: Is it really there?
13:40:01 <dcoutts> SyntaxNinja, if you think the tarball is ok then I'll update the Cabal download webpage
13:40:02 <SyntaxNinja> dcoutts: do you want to put together an annoucement?
13:40:26 <SyntaxNinja> dcoutts: yeah. I played with it, seems good!
13:40:58 <jyp> kzm: Package Search Results ... GHC - the Glasgow Haskell Compilation system 6.4.1-2.1: alpha amd64 hppa i386 ia64 kfreebsd-i386 powerpc s390 sparc
13:41:52 <dcoutts> SyntaxNinja, sure ok. But first I've got to watch the last in the "Pink Panther" series on dvd with my gf :-)
13:41:53 <eivuokko> SyntaxNinja, if you don't mind, this is sort of what I do: main = defaultMainWithHooks defaultUserHooks{preConf=conf, postConf=ok} where ok _ _ _ _ = return ExitSuccess .. and some preConf-thingy to handle extra param --dx-sdk=foo/path and write it in a dx.buildinfo.  Point being, I have to rewrite postConf so that it doesn't exit with error due to extra commandline params to setup configure.
13:42:38 <SyntaxNinja> dcoutts: sounds great :) maybe I should do that too.  my gf and I just saw "before sunrise" which is v. romantic movie, and now we have "before sunset" in hand from netflix.
13:43:05 <SyntaxNinja> eivuokko: can you remind me what postconf does if you don't override it?
13:43:10 <SyntaxNinja> this is the defaultUserHooks?
13:43:19 <SyntaxNinja> eivuokko: OTOH, I think that's fine, I dont' see anything wrong w/ it.
13:43:42 <eivuokko> SyntaxNinja, It runs ./configure.  If it can't run it, it errors from extra commandline param for configure.  It seems silly to me, that's all.
13:44:07 <eivuokko> (Yes, it works)
13:44:33 <SyntaxNinja> eivuokko: oh,so postconf is the part that runs ./confgiure?
13:44:40 <eivuokko> SyntaxNinja, Yeah
13:46:00 * araujo next to submit first proposal
13:47:45 <SyntaxNinja> eivuokko: OK. that's the part I forgot. I figured confHook did that.
13:48:14 <SyntaxNinja> eivuokko: so I guess the question is does configure check for bad flags, and if so, why does postConf also check
13:48:17 <eivuokko> SyntaxNinja, Well, I guess my original question was: Is there better way to register a parameter used by setup configure
13:49:14 <SyntaxNinja> eivuokko: I don't think so.
13:49:26 <eivuokko> SyntaxNinja, Ok, thanks.
13:50:07 <SyntaxNinja> eivuokko: sory
13:50:46 <eivuokko> SyntaxNinja, Heh, no problem.  It's just often puzzling how to do these things in Cabal.
13:51:43 <psi`> what do people think about the following suggestion for a SOC project: a (full speed) emulator for some classic gaming system. I have thought about it earlier, and I was encouraged by the (haskell) GB emulator project I came across today.
13:51:57 <psi`> the NES is most interesting to me
13:52:34 <SyntaxNinja> psi`: sounds like fun, but personally, I'd like to see more stuff that benefits the core Haskell community.
13:52:44 <SyntaxNinja> other mentors may have other priorities
13:54:13 <Saulzar> shapr, I wonder what a pygame for Haskell would look like. Just IO level stuff?
13:54:13 <psi`> right. however, if it can be done successfully, I think it would have promotional benefits for haskell.
13:54:43 <psi`> but I don't know about that, how well suited haskell is currently.
13:55:03 <Saulzar> shapr, Some way to integrate parts with higher levels would be nice, but there are so many ways...
13:57:00 <Heffalump>  
13:57:08 <Heffalump> sorry
13:57:19 <psi`> I mean in terms of efficiency of the current implementations. can it be done?
13:59:57 * kzm_ killed his wifi access point.  Oops.
14:02:41 <monochrom> @djinn ((a->b)->c)->d
14:02:42 <lambdabot> -- f cannot be realized.
14:03:31 <flux__> @djiin (a->b)->(b->a)
14:03:32 <lambdabot> -- f cannot be realized.
14:03:33 <flux__> ;(
14:03:38 <flux__> that would be cool.
14:03:50 <davidhouse> @hoogle (a->b)->(b->a)
14:03:51 <lambdabot> No matches found
14:03:55 <davidhouse> @hoogle (a->b)->b->a
14:03:56 <lambdabot> No matches found
14:04:18 <davidhouse> @type ($)
14:04:19 <lambdabot> forall b a. (a -> b) -> a -> b
14:04:36 <eivuokko> @djinn (a->b->c) -> b -> a -> c
14:04:37 <flux__> come - on, there is no function that inverses any given function?-)
14:04:37 <lambdabot> f a b c = a c b
14:04:39 <davidhouse> @type \f a -> flip f a
14:04:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:05:22 <monochrom> @djinn ((a->a)->a)->a
14:05:23 <lambdabot> f a = a (\ b -> b)
14:05:30 <sjanssen> @. pretty . pl djinn (a->b->c) -> b -> a -> c
14:05:31 <lambdabot>  f = flip
14:05:48 <eivuokko> Oh, horror. :)
14:32:06 <shapr> Saulzar: Maybe Yampa plugged into some useful widgets?
14:32:56 <shapr> Saulzar: like a prebuilt generic mario brothers platform game, a prebuilt simple 3D simulation, maybe billiards? That sort of thing.
14:33:25 <Saulzar> Hmm..
14:33:43 <Saulzar> I don't think such specifics should be part of any core .. maybe as "examples"
14:34:01 <shapr> Yeah, they'd be simple examples.
14:35:42 <shapr> But that's the sort of thing that should be easy as falling off a log with a game framework.
14:36:35 <Saulzar> Hmm, how easy are arrow transformers to work with? Something like Yampa with state (eg. ability to provide ids, random numbers etc.) would be great
14:36:39 <araujo> shapr!!
14:37:03 <shapr> hello araujo 
14:37:26 <Saulzar> shapr, Right.. it needs to be the glue to combine the logic/rendering/input etc.. so that getting started is a piece of cake
14:37:37 <palomer> monads rock!
14:37:51 <palomer> that was my public service announcement of the day
14:41:02 <Saulzar> Now go out and announce that in public :)
14:42:11 <palomer> @pl \i x -> mapM (const x) [1..i] 
14:42:11 <lambdabot> flip (mapM . const) . enumFromTo 1
14:42:15 <palomer> hrmph
14:42:19 <palomer> is there a prettier way of writing that?
14:43:40 <xerox> mapM (const x) = map (return . const x)
14:44:24 <Saulzar> Yep ..  replicateM_ i x   (replicateM_ = \i x -> mapM (const x) [1..i])  :)
14:44:36 <SamB> so how many SoC slots do we have? do we know yet?
14:44:48 <palomer> ahh, replicateM
14:44:56 <xerox> @type replicateM
14:44:58 <lambdabot> forall a (m :: * -> *).
14:44:58 <lambdabot>      (Monad m) =>
14:44:58 <lambdabot>      Int -> m a -> m [a]
14:44:59 <Saulzar> (Does not exist I think)
14:45:02 <Saulzar> Oh, it does.
14:45:05 <xerox> !
14:45:12 <Saulzar> @type replicateM_
14:45:13 <lambdabot> forall (m :: * -> *) a.
14:45:13 <lambdabot>      (Monad m) =>
14:45:13 <lambdabot>      Int -> m a -> m ()
14:45:16 <xerox> Yay.
14:45:18 <Saulzar> What do you know..
14:47:04 <Cale> repeatM is the one that's missing
14:51:03 <jethr0> shapr: i see you've been talking about a game using yampa...
14:51:57 <jethr0> shapr: i've been hard pressed to even get an initial pong game working. yampa in combination with hopengl certainly takes some time getting used to
14:52:36 <jethr0> and i'm still not sure how well it would cope with arbitrary (unforeseen) complexity thrown at it
14:53:11 <davidhouse> repeatM = sequence . repeat (or even liftM repeat), but it would be nice if it existed.
14:53:18 <stepcut> jethr0: yampa is pretty tricky, IMO
14:53:37 <davidhouse> hmm... are the two equivalent?
14:53:49 <Cale> no, sequence . repeat is the one we want
14:53:51 <stepcut> there are a lot of M things that would be nice, like mapMaybeM
14:54:12 <jethr0> yup. i'm certainly one of its first fans, but i'm not sure if i'd want to risk the gamble if i were starting to write doom3 - even apart from some performance issues
14:54:16 <stepcut> actually, almost everything in Data.List, Data.Maybe, and Data.Either would be nice in M form ;)
14:54:33 <jethr0> s/first/best
14:54:39 <stepcut> jethr0: have you looked at frantk at all ? 
14:54:43 <davidhouse> > take 10 (liftM repeat $ Just 5) = take 10 (sequence . repeat $ Just 5)
14:54:44 <jethr0> yes
14:54:44 <lambdabot>  parse error on input `='
14:54:50 <davidhouse> > take 10 (liftM repeat $ Just 5) == take 10 (sequence . repeat $ Just 5)
14:54:51 <lambdabot> Couldn't match `[]' against `Maybe'
14:54:58 <stepcut> jethr0: I have no idea if it is better for your needs or not -- but it looks simpler
14:55:08 <jethr0> and i'd absolutely love it if some fran-like binding were to come out for a little nicer looking toolkit like gtk
14:55:36 <davidhouse> @type liftM repeat
14:55:36 <jethr0> stepcut: no, i think yampa is definitely better suited for games. AFAIK yampa is the successor of fran in many ways
14:55:38 <lambdabot> forall a1 (m :: * -> *).
14:55:38 <lambdabot>       (Monad m) =>
14:55:38 <lambdabot>       m a1 -> m [a1]
14:55:49 <davidhouse> @type sequence . repeat
14:55:50 <lambdabot> forall (m :: * -> *) a.
14:55:50 <lambdabot>        (Monad m) =>
14:55:50 <lambdabot>        m a -> m [a]
14:55:52 <Cale> runState ((sequence . repeat) (do x <- get; put (x+1); return x)) 0
14:55:55 <stepcut> jethr0: i think they are each other successors, or something like that :)
14:55:55 <Cale> > runState ((sequence . repeat) (do x <- get; put (x+1); return x)) 0
14:55:57 <lambdabot> ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,
14:55:57 <lambdabot> 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
14:55:57 <lambdabot> 126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
14:55:57 <lambdabot> 175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
14:55:59 <lambdabot> 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,
14:56:01 <jethr0> :)
14:56:02 <lambdabot> [6 @more lines]
14:56:06 <jethr0> sry, gotta run. bbl
14:56:17 <Cale> the default number of lines should be decreased...
14:56:25 <davidhouse> indeed.
14:56:37 <stepcut> maybe the number of lines should be a function of your karma ?
14:57:30 <davidhouse> in terms of side effects, are liftM repeat and sequence . repeat equivalent?
14:57:36 <Cale> no
14:57:43 <davidhouse> i didn't think so.
14:57:48 <Cale> > take 10 $ evalState ((sequence . repeat) (do x <- get; put (x+1); return x)) 0
14:57:49 <lambdabot> [0,1,2,3,4,5,6,7,8,9]
14:58:01 <Cale> > take 10 $ evalState ((liftM repeat) (do x <- get; put (x+1); return x)) 0
14:58:02 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
14:58:53 <davidhouse> hmm.
14:59:11 <mauke> ah, repeat creates a list and liftM puts it into a monad
14:59:43 <Cale> liftM is the same as fmap
15:00:11 <Cale> liftM repeat just applies repeat to the result(s) of the computation
15:00:45 <Cale> whereas sequence . repeat will first construct a list with copies of the computation, and then run each in sequence
15:01:20 * SamB wonders why Google can't use his residence address to find his map location...
15:01:38 <monochrom> You don't exist!
15:01:53 <SamB> no, I mean, why do they want me to find it manually on the SoC app?
15:03:14 <eivuokko> Maybe they are building database for address <-> location that doesn't cost them anything.
15:03:31 <monochrom> You have to provide a map location?
15:03:41 <SamB> but ... they already know *exactly* where my house is
15:03:45 <SamB> monochrom: no, its optional
15:04:19 <monochrom> Type in "Nothing" in that field. XD
15:04:51 <SamB> hehe, you can't type in that field -- its embeds a full-fledged map ;-)
15:05:11 <SamB> hmm, why do they need to know my graduation?
15:05:12 <Cale> hehe, you could point it to the middle of the Atlantic ocean though
15:05:19 <SamB> I haven't planned that far ahead!
15:06:11 <monochrom> Enter "Nothing" in that field too. XD
15:06:14 <ihope> > 71-24
15:06:16 <lambdabot> 47
15:06:34 * SamB makes up kind-of plausible month and year
15:06:40 <lscd> Hi.  I'm reading "haskell for c programmers", http://www.haskell.org/~pairwise/intro/section2.html -- two type declarations are given, fib :: Num a, Num b => a -> b    and fibGen :: Num a, Num b => b -> b -> a -> b -- but ghci and hugs both complain about the comma between Num a and Num b - what's the correct syntax?
15:06:58 <mauke> lscd: :: (Num a, Num b) =>
15:07:06 <lscd> mauke: thanks!
15:07:08 <monochrom> Yeah put in parentheses
15:07:23 <monochrom> That's the problem with c programmers.
15:07:25 <mauke> I always use parens, even for a single class
15:07:41 <lscd> monochrom: what is?
15:07:42 <monochrom> They put in parentheses where there needs none, e.g., f(x)
15:07:51 <lscd> and leave out ones that need to be there?
15:08:00 <monochrom> and they omit parentheses where there need some.
15:08:06 <lscd> uh-huh
15:08:21 <lscd> i'll claim status as a refugee python and ruby programmer then ;)
15:08:24 <monochrom> They can't be saved.
15:09:40 <lscd> [python for the tuples, and ruby as function calls don't need parentheses]
15:11:03 <Lemmih> Hiya lscd.
15:11:16 <SamB> hmm. are they going to mail me that tax form?
15:11:19 <lscd> hey Lemmih, ltns - what're you hacking on these days?
15:11:31 <Lemmih> lscd: Wanna participate in Google's SoC?
15:11:37 * SamB notices that he never had to log in
15:11:43 <lscd> hm.. i'm planning to do research at my uni this summer
15:11:54 <lscd> so...... maybe, but i'm not dying to
15:12:02 <lscd> why, got something cool? ^-^
15:12:24 <SamB> Lemmih: do we know how many slots we have yet?
15:14:00 * SamB wonders if his app is okay...
15:14:29 <hyrax42> May 8 is deadline, right?
15:14:35 <psi`> hyrax42: yes
15:14:49 <Lemmih> SamB: No, but I doubt we have enough students.
15:14:52 <hyrax42> I want to put an app in, but I feel sort of wrong about it given I know 0.00031 Haskell
15:15:26 <SamB> hyrax42: learn quick!
15:15:30 <SamB> quick quick!
15:15:54 <hyrax42> trying!
15:16:00 <hyrax42> well not yet, but starting really soon
15:16:03 <hyrax42> just finished last exam
15:16:08 <SamB> oh?
15:16:18 <SamB> I have exams next friday :-(
15:16:31 <hyrax42> yeah, in Canada we always finish end of April
15:16:35 <hyrax42> this was a deferred exam
15:16:38 <hyrax42> exams ended on friday
15:17:11 <araujo> hi!
15:17:18 <hyrax42> SamB: which project are you applying for?
15:17:22 <hyrax42> project(s), even
15:17:29 <hyrax42> hullo
15:17:34 <lscd> Lemmih: what kinds of applications do you want?
15:18:11 <goltrpoat> @pl \a b -> a ++ (drop 1 b)
15:18:12 <lambdabot> (. drop 1) . (++)
15:18:16 <SamB> hyrax42: I'm applying to do ParsecT
15:18:41 <SamB> so, if I were to paste the URL of an app, who would be able to read it?
15:18:47 <Lemmih> lscd: We got a list of project suggestions here http://hackage.haskell.org/trac/summer-of-code/
15:19:38 <mauke> (. tail) . (++)
15:19:41 <hyrax42> so currently in Parsec... you can't "do" stuff while parsing?
15:19:49 <SamB> hyrax42: nope!
15:19:49 <hyrax42> can't "do" what stuff
15:19:56 <SamB> nothing but parse!
15:20:08 <mauke> you can also putState
15:20:14 <goltrpoat> mauke:  b can be empty
15:20:19 <goltrpoat> so tail won't work
15:20:20 <SamB> mauke: that doesn't really count
15:20:23 <hyrax42> and what might you want to "do"?
15:20:26 <sethk> hyrax42, you have to know at least .0004
15:20:30 <SamB> well, read a file...
15:20:44 <hyrax42> I'll know 0.0004 by tonight, I think
15:20:50 <SamB> construct mutable objects in memory...
15:21:00 <SamB> (for, say, a Self implementation)
15:21:04 <sethk> hyrax42, you can attach actions to parse contructs, of course, otherwise it would be useless
15:23:53 <cmarcelo> audreyt && JohnMeacham: any of you are interested in put your name as "interested mentor" for http://hackage.haskell.org/trac/summer-of-code/ticket/61 [fast mutable data collections]? =)
15:25:55 <xerox> cmarcelo: did you mail them, perchance?
15:25:59 <mahogny> the current ones are slow?
15:26:44 <SamB> mahogny: or non-existant, or clumsy...
15:26:46 <xerox> cmarcelo: I would suggest you to mail them, Cc: paolo at nemail it if you want.
15:27:07 <mahogny> hm. sounds interesting. but I have some problem seeing how you would get the types in without doing some compiler hacking
15:27:25 <lscd> Lemmih: several of those projects look really cool, including all 4 of yours
15:27:43 <mahogny> it actually sounds like you want a ghc hacker as a mentor, if you want to get an optimal solution
15:27:55 <cmarcelo> xerox: ok.
15:28:09 <hyrax42> there are a lot of projects there!
15:28:21 <goltrpoat> @pl \n -> (uncurry (\a b -> a ++ (drop 1 b))) . (splitAt n)
15:28:22 <lambdabot> (uncurry ((. drop 1) . (++)) .) . splitAt
15:28:39 <SamB> hyrax42: yeah ;-)
15:28:54 <hyrax42> there are a couple that sound cool
15:29:02 <hyrax42> but cool also = way the hell out of my league!
15:29:17 <mahogny> hm. what haskell needs: a function toBinary :: a -> [Int]. (and fromBinary). then these kind of things would be really easy. please add it to ghc!
15:29:35 <SamB> hahaha
15:29:42 <SamB> why [Int]?
15:29:55 <mahogny> arbitrary number of bytes. compiler decides
15:30:02 <goltrpoat> just in case you're on a 2987342012-bit word machine
15:30:02 <mahogny> if you know a better type, tell ;)
15:30:10 <xerox> ByteString :-)
15:30:18 <SamB> um, what about Binary?
15:30:36 <mahogny> haven't done much binary hacking in haskell so I dunno. I usually end up using C instead
15:31:28 <xerox> There are some Binary I/O devices.  Like NewBinary
15:31:30 <SamB> have you heard of the Binary module? it is unfortunately floating around in source form in various projects, mostly...
15:31:33 <xerox> @where NewBinary
15:31:34 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
15:31:34 <mahogny> but if we had these functions... hm. and some binarySize :: a -> Int. then it would be easy to pack arbitrary types and send to FFI
15:32:03 <mahogny> and if we can get it to FFI, then we can use any external collection library and still make our own types easily. I don't see how one would do that now
15:32:07 <SamB> um... sending to FFI would require you to pack them in the right format, wouldn't it?
15:32:27 <mahogny> if you aren't interested in actually reading the content, then no
15:33:06 <sethk> you can use the marshalling code to do essentially that
15:33:28 <mahogny> sethk, even with your own custom types?
15:34:41 <sethk> mahogny, I'll have to look at it again, but I think so.  I was planning on doing something there but got sidetracked on some paying work
15:35:27 <mahogny> sethk, hm. as far as I have seen, you would have to write your own marshaller or something. but I can be wrong
15:35:46 <sethk> mahogny, my memory is a bit hazy, I'll have to find the notes I made a few months ago
15:36:00 <hyrax42> is pugs the only implementation of perl 6 in existence?
15:36:55 <Cale> hyrax42: yeah, afaik
15:37:56 <mahogny> hyrax42, the real one is on the way I guess
15:38:05 <mahogny> hyrax42, pugs was only for bootstrapping after all
15:38:25 <hyrax42> ah ok
15:38:47 <hyrax42> wait... bootstrapping?  is perl6 going to be implemented primarily in perl6?
15:38:54 <mahogny> I have never understood why the compiler has to be implemented in the own language though. I mean, who the heck would write a c compiler in c when there is haskell??
15:38:59 <hyrax42> I thought perl/python/ruby were primarily implemented in C
15:38:59 <mahogny> hyrax42, I guess
15:39:13 <mahogny> hyrax42, if someone ever get that far
15:39:37 <hyrax42> well I guess perl6 will be some sort of VM-based system?
15:39:47 <mahogny> bytecode? yes. sad story
15:40:08 <lscd> hyrax42: based on something called 'parrot', which python/etc may use as well, if my memory serves
15:40:12 * int80_h works on his SoC proposal
15:40:17 <mahogny> yup
15:40:22 <hyrax42> oh yea parrot
15:40:23 <int80_h> hi mahogny
15:40:25 <mahogny> yo
15:40:38 <hyrax42> int80_h: did you get the links to the drupal advice thingy for proposals?
15:40:40 <int80_h> so should I list all the libraries I think I will be using for this project?
15:40:57 <int80_h> yeah I did. It looks like I should have library level details for my prposal
15:41:07 <lscd> hyrax42: there's pypy, which is python on python; but in general, languages generally tend to move towards being 'self hosting', for whatever reason
15:41:14 <mahogny> int80_h, I don't think it's very useful knowledge for google, but go at it if you have the info
15:41:36 <hyrax42> I would suppose it has something to do with the designer/implementer feelin gmost comfortable in that language
15:41:48 <int80_h> Well mahogny, the proposal advice suggests details. And since I don't have an organizational vision right now, all I have to give them are libraries I would use.
15:41:55 <int80_h> I don't have a spec.
15:41:56 <hyrax42> haskell (ghc/hugs) are self-hosted, no?
15:42:05 <mahogny> int80_h, doesn't hurt
15:42:18 <mahogny> hyrax42, ghc yes, hugs no
15:42:26 <int80_h> Is it the best use of my time, considering this is due on the 8th
15:42:30 <hyrax42> hugs is written in?
15:42:31 <hyrax42> C?
15:42:35 <mahogny> hyrax42, yes
15:42:39 <hyrax42> eeps
15:42:51 <dcoutts> hyrax42, but it is quick to compile!
15:43:00 <hyrax42> goddamn
15:43:06 * int80_h blushes
15:43:07 <mahogny> hugs >> /dev/nul
15:43:16 <hyrax42> my last update from darwinports gave me a ghci that segfaulted
15:43:19 <hyrax42> after about 8 hours
15:43:39 <int80_h> oh yeah, I had to use a package made by someone form this channel when I was installing on Mac
15:43:49 <hyrax42> well
15:44:02 <hyrax42> if you ever think about compiling it
15:44:04 <hyrax42> think twice
15:44:10 <hyrax42> I sort of innocently did
15:44:14 <hyrax42> sudo port install darcs
15:44:20 <hyrax42> that took about half a day
15:44:27 <int80_h> and then died
15:44:33 <hyrax42> no, it finished at least
15:44:35 <int80_h> oh wait no ghci died
15:44:50 <lscd> doesn't ghc have 40k lines or so of c as well?
15:44:54 <hyrax42> well it's only the latest ghci that is broke
15:45:15 <mahogny> sounds like a lot, but it makes sense that it contains some c
15:45:17 <hyrax42> what is the ghc bootstraping process
15:46:46 <monochrom> bootstrapping ghc: there are some C files, you can make do with gcc.  The C files are produced by an existing installation of ghc (it takes in haskell and emits C).
15:48:23 <hyrax42> so you build ghc via C then via .hs?
15:50:15 <jethr0> ll
15:54:41 <jethr0> cd
15:55:01 <goltrpoat> c is a terrible language to write a compiler in
15:55:15 <jethr0> yes, but it's quite portable...
15:55:43 <goltrpoat> writing one in c++ is a LOT easier, if you're into writing compilers in imperative languages for some reason
15:55:47 <jethr0> and more or less well suited for assembly-esque micro-optimization. but in general i wholeheartedly agree
15:56:31 <jethr0> although table-based LALR parsers/compilers aren't _that_ bad in c
15:56:58 <jethr0> but for lookup tables, linked lists, etc c++ _does_ have some advantages, true
15:57:03 <SamB> jethr0: personally, I can't help but think of them as being _that_ bad in *anything*
15:57:19 <SamB> the table-based parsers, I mean
15:57:37 <SamB> they are so much work!
15:58:01 <jethr0> yup, and compilers have been written in languages like c for more than 20 years, so the techniques have partially also adapted for the language's/paradigm's shortcomings
15:58:08 <palomer> >:o
15:58:13 <int80_h> wuts all this here talkin' about C in the haskell channel?
15:58:17 <mahogny> it's ok if they are generated automatically
15:58:23 <mahogny> the tables
15:58:24 <SamB> well, I don't think Happy is much better
15:58:25 <goltrpoat> jethr0:  well, here's an example.  i wrote a compiler for a c++-style language with operator overloading.  in c++, the abstraction layer for writing built-in operators came naturally to begin with, so adding operators on user-defined types and user-defined operators on user-defined types was trivial
15:58:32 <xerox> Goodnight
15:58:38 <SamB> mahogny: of course the tables are generated automatically!
15:58:43 <SamB> that is a given!
15:58:51 <mahogny> SamB, still a lot of work then? :)
15:58:57 <SamB> I think so!
15:58:59 <mahogny> hm
15:59:02 <jethr0> goltrpoat: sounds more like an interpreter...
15:59:16 <goltrpoat> i guess the point is that abstraction is a must when you're writing a compiler incrementally, and C doesn't really have nice abstraction mechanisms
15:59:22 <SamB> then again, languages with complicated syntax tend to be a lot of work however you slice it...
15:59:31 <goltrpoat> jethr0:  hmm?  no, it dumped out x86-style bytecode
15:59:54 <jethr0> goltrpoat: but neither has c++. writing nice, real abstractions in c++ is far from acceptable
16:00:00 <jethr0> k
16:00:10 <SamB> well, C++ at least might do a better job of faking it
16:00:35 <goltrpoat> well.. separating interface from implementation comes naturally in c++, and swapping out implementations behind the interface
16:01:10 <jethr0> well, C simply abstracts by "everything is a pointer". it sure ain't nice, but you can get lots done that way (obviously in an ugly and non-robust manner)
16:01:26 <goltrpoat> ew.
16:01:49 <jethr0> goltrpoat: i don't agree. c++ has the same idea of interface and implementation files as c
16:02:02 <jethr0> and templates can't be divided properly into header and impl
16:02:35 <jethr0> and you soon start adding "class A; class B" into your headers just to "reduce compilation time and cross-dependencies"
16:04:49 <SamB> did you guys here what nintendo says they are calling their new system?
16:05:00 <jethr0> personally i haven't exactly made friends with the implementation issues of templates and without them c++ just doesn't allow "real" abstractions
16:05:20 <jethr0> SamB: <parse error>
16:06:34 <SamB> jethr0: huh?
16:06:41 <SamB> er, hear
16:08:34 <jethr0> SamB: nope. but BTW, every time i read your BFInterpreter i find sth new to be amazed about. it's really an exceptionally clean, well-thought-through piece of code. kudos again!
16:08:48 <Cale> SamB: yes, it's terrible
16:09:07 <jethr0> ah, you mean the one with the horrible name?
16:09:21 <SamB> yes! that one!
16:09:57 <SamB> hmm, someone in #twisted claims that the entire internet was over that by saturday...
16:10:02 <jethr0> i had to reread that name 5 times and still have to shudder when i think about it. what's it called?
16:10:34 <SamB> you really want me to say the name?
16:10:46 <jethr0> yes, just for the cold, non-fuzzy fealing
16:10:58 <ihope> Ah, yes.
16:10:59 <jethr0> s/fealing/feeling/
16:11:04 <ihope> Haskell needs a mascot.
16:11:07 <SamB> okay... it is... the Wii :-(
16:11:13 <jethr0> *brrr*
16:11:38 <int80_h> well haskell rhymes with rascal. I think a cyote should be the mascot.
16:11:51 <int80_h> oops spelling
16:11:54 <ihope> Sounds good.
16:11:55 <jethr0> i hope that means sth impressive in japanese at least
16:12:07 <hyrax42> feh who cares what it's called
16:12:08 <hyrax42> it's dumb
16:12:08 <int80_h> cayote?
16:12:11 <jethr0> i thought lambda was our mascot :)
16:12:15 <hyrax42> but really
16:12:19 <int80_h> oh yeah lambda is better
16:12:24 <hyrax42> just callit your "nintendo"
16:12:37 * Igloo disagrees with int80_h's pronunciation of either Haskell or rascal  :-)
16:12:39 <SamB> I liked Revolution
16:12:44 <hyrax42> lol
16:12:47 <ihope> jethr0: I thought lambda was our logo.
16:12:53 <hyrax42> a friend of mine was told that haskell is pronounced like rascal
16:12:59 <hyrax42> and he thought with the r
16:13:05 <jethr0> well, at least at o'reilly it can be both
16:13:05 <SamB> and actually, it seems to come out to
16:13:17 <SamB> わいい
16:14:10 <jethr0> just has to be an animated/alive lambda, jumping around like a kanguroo
16:14:48 <int80_h> ewe...no..too much like clippy
16:14:55 * int80_h starts twitching
16:14:57 <jethr0> *yeah*, clippy
16:15:07 <sethk> cale, still around?
16:15:08 <ihope> Clippy should be Haskell's mascot!
16:15:13 * ihope hugs int80_h
16:15:22 <jethr0> "i see you are trying to start a flamewar. would you like some assistance?"
16:15:23 <int80_h> I think ihope is some kind of spy!
16:15:41 <Cale> sethk: yeah
16:16:04 <sethk> Cale, I tried the fundep, and I got a message that I don't quite understand.  I'll paste it...
16:16:06 <hyrax42> http://www.youtube.com/watch?v=HwMmdnezhik&search=clip%20microsoft
16:16:20 <hyrax42> nsfw if you have sound up
16:17:14 <sethk> cale:  /ClientServer.hs:85:9:
16:17:15 <sethk>     Ambiguous type variable `response' in the constraints:
16:17:15 <sethk>       `HasStatus response'
16:17:15 <sethk>         arising from use of `getResponse' at ./ClientServer.hs:85:9-19
16:17:15 <sethk>       `Response response'
16:17:15 <sethk>         arising from use of `getResponse' at ./ClientServer.hs:85:9-19
16:17:54 <ihope> Add a type signature?
16:17:55 <Cale> can I see that file?
16:18:05 <sethk> Cale, yes, I'll post it again.
16:18:15 <sethk> ihope, that's what I'm trying to avoid doing
16:18:23 <ihope> Oh.
16:18:33 <sethk> ihope, because I want it to be polymorpic
16:18:40 <sethk> polymorphic, even
16:18:54 <ihope> Add some type signatures somewhere else? :-)
16:18:57 <ihope> s/)/P/
16:19:52 <hyrax42> does Either form a monad?
16:20:08 <Cale> Either a for any particular type a forms a monad
16:20:16 <lisppaste2> sethk pasted "Polymorphic?" at http://paste.lisp.org/display/19591
16:20:19 <hyrax42> ok I was wondering if I should ask it like that
16:20:48 <hyrax42> oh and Cale, thanks for that Monads as Containers thing
16:21:01 <hyrax42> I've read half, but it increased my understanding substantially
16:21:15 <Cale> :)
16:21:18 <hyrax42> rather than being scary things with crazy >>= stuff going on
16:21:44 <sethk> hyrax42, I like the >>= stuff, I find it easier to follow
16:22:07 <hyrax42> they're just slightly misunderstood blobs
16:22:15 <hyrax42> didn't get to the ST part yet
16:22:24 <hyrax42> sethk: well sure
16:22:31 <hyrax42> so long as you actually know what it even dong
16:22:32 <hyrax42> doing
16:22:52 <hyrax42> as an outsider, it's a really strange operator, doing something really strange in something really strange
16:23:42 <Cale> sethk: ah, you're applying getResponse to a Handle -- how is it supposed to know which kind of response you want?
16:23:45 <sethk> hyrax42, I like it because it makes the data flow explicit.  It looks stranger than the do notation, but the do notation hides some of what's going on
16:23:58 <sethk> Cale, that's the problem, definitely.
16:24:10 <palomer> using sTrace is confusing the bejebus out of me
16:24:13 <sethk> Cale, but the first version, that actually returns the response, works fine
16:24:15 <palomer> s/sTrace/trace
16:24:26 <Cale> either you're forced to include a type signature, or bundle the request and response together
16:24:29 <sethk> Cale, because I use the returned value and it can infer the type
16:24:32 <hyrax42> well I've still got a ways to go before I'm comfortable with it all
16:24:35 <Cale> right
16:24:57 <Cale> _ <- getResponse handle
16:25:00 <sethk> Cale, so the version that returns the type is polymorphic, but the version that discards it has to be rewritten for each instance
16:25:01 <Cale> looks suspicious :)
16:25:20 <sethk> be nice if there's a trick to avoid the repetative coding
16:25:45 <sethk> Cale, I'm willing to change the classes if there is a better way to do things
16:25:52 <Cale> well, who cares about the one which discards it, really? Can't you just discard the response that's returned anyway?
16:26:21 <jethr0> @pl \x -> (+) x x
16:26:22 <lambdabot> join (+)
16:26:24 <sethk> Cale, yes, I can do   (_ :: Whatever) <-
16:27:02 <Cale> or just  putRequestDR :: IO Foo
16:27:10 <Cale> er
16:27:13 <Cale> GR
16:27:22 <sethk> Cale, then I can't use it with different instances
16:27:23 <Cale> (and pass the parameters of course)
16:27:34 <palomer> woot, my algorithm works!
16:27:54 <jethr0> @pl \x -> x + (f x)
16:27:54 <lambdabot> ap (+) f
16:28:06 <sethk> Cale, You can't say "this things returns an instance of Response".  If that is even a sensible thing to think about.
16:28:23 <Cale> sure you can
16:28:27 <sethk> Cale, like returning a base class in OO.  No huge thing if I can't do it, but if there is a way ...
16:28:47 <Cale> do you care which instance of Response?
16:29:19 <sethk> Cale, when I'm throwing the value away, no
16:29:30 <sethk> Cale, when I care I use putRequestGR
16:29:57 <Cale> You could use an existential type, but then you'd have no access to the returned value except via class methods.
16:30:12 <Cale> (and there's no down-casting)
16:30:15 <sethk> Cale, that's ok, I don't even have a handle to it, can't reference it anyway
16:30:25 <sethk> Cale, so how do you return an existential type?
16:30:31 <hyrax42> @type join
16:30:33 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:30:50 <Cale> sethk: that won't get rid of your ambiguity in this case though.
16:30:59 <Cale> Actually, I think I know how to solve your problem
16:31:07 <sethk> ok ...
16:31:09 <hyrax42> can everything be point-freed?
16:31:22 <hyrax42> just with varying levels of readabiliyt?
16:32:50 <Cale> sethk: add a (Server request response) constraint to the type of putRequestDR and possibly use a scoped type variable...
16:32:55 <Cale> I have to go to dinner though
16:33:14 <sethk> Cale, ok, thanks, I'll write that down and you can elaborate next time we speak.
16:35:26 <stepcut> can yhc compile itself yet?
16:40:43 <lscd> hm, would someone tell me what's wrong with this?
16:40:52 <lscd> c2f :: Num a => a -> a
16:40:58 <lscd> c2f n = n * 9 / 5 + 32
16:41:16 <int80_h> mahongy are you busy?
16:41:16 <lscd> ERROR "c2f.hs":4 - Inferred type is not general enough  ... *** Inferred type : Num Double => Double -> Double
16:41:46 <rasfar> lscd: division isn't defined for all Num
16:42:27 <lscd> rasfar: ahh, ok; which ones isn't it defined for, and why? [i'm assuming you mean classes/subtypes of Num, not just 0, yes?]
16:43:26 * rasfar checks the Report...
16:43:53 <Lemmih> @type \n -> n * 9 / 5 + 32
16:43:55 <lambdabot> forall a. (Fractional a) => a -> a
16:44:15 <jethr0> any suggestions for a vector cross product operator? "|x|" doesn't work, so i'm thinking about using "|#|"...
16:45:19 <lscd> k, so it looks like i should use fractional - thanks for the suggestion / way of finding out :)
16:45:29 <Lemmih> jethr0: You can use unicode in newer versions of GHC (:
16:45:55 <jethr0> hmm, question is whether that's a lot of hassle and how well vim handles unicode...
16:46:03 <jethr0> and my xterm of course
16:46:21 <liyang> Might be an idea just to use `cross` and typeset it to something fancier with lhs2TeX.
16:46:37 <liyang> gnome-terminal handles UTF-8.
16:46:46 <lscd> how do i find out if Fractional or Double is more general?
16:46:49 <jethr0> hmm, i had that before but having nice infix operators seems like quite a nice idea...
16:46:55 <liyang> Vim had seamless UTF-8 support for ages.
16:47:04 <jethr0> k, never tried. good to know
16:47:17 <sethk> lscd, more general how?
16:47:27 <sethk> lscd, applies to more types?
16:47:36 <lscd> sethk: sure, or if one is a subset of the other, etc
16:47:37 <liyang> (xterm does too, but it doesn't like random TTF fonts, which I want.)
16:47:58 <Lemmih> lscd: Fractional is a type-class, Double is a type.
16:48:05 <sethk> lscd, the documentation will show a list of instances for a class
16:48:11 <lscd> Lemmih: ahh, ok, that makes sense
16:48:20 <lscd> sethk: ok, so there's no way to just ask the environment?
16:48:25 <sethk> Plus lemmih has a point :)
16:48:31 <sethk> lscd, not that I know of.
16:48:40 <Lemmih> lscd: :info Symbol will tell you about the symbol.
16:48:43 <lscd> can i at least ask it if something is a type class or a type?
16:49:07 <lscd> Lemmih: cool, that's the kind of thing i was wanting to find
16:49:48 <lscd> sethk: it looks like Double is an instance of Fractional
16:50:48 <palomer> let's have a canadian haskell get-together!
16:50:50 <palomer> who's with me?
16:51:07 <jethr0> palomer: if i lived anywhere close to canada i'd come :)
16:51:10 <rasfar> Canada's rather big -- where is this get together to be??
16:51:19 <lscd> palomer: i'd come, but i've moved to europe, and i barely know haskell ;)
16:51:24 <palomer> montreal, of course
16:51:29 <lscd> pffffft
16:51:34 <lscd> western canada ;)
16:51:47 <hyrax42> palomer: when
16:51:47 <rasfar> well, montreal's always worth it -- but western would be closer
16:52:03 <hyrax42> are you thinkign
16:53:16 <rasfar> > f::Fractional a=>a;f=1::Double
16:53:17 <lambdabot>  a
16:53:17 <lambdabot>   Inferred type: Double
16:53:17 <lambdabot>   In the expression: f :: (Fractional a) => a
16:53:40 <rasfar> was that an error?
16:54:05 <rasfar> I guess if I can't tell, then it's not a reliable way to find out...
16:54:44 <sethk> lscd, sorry, phone call from a client.  Yes, Double is an instance of fractional, that makes sense.
16:55:04 <lscd> so, once i switched Num to Fractional, it worked - thanks
16:55:25 <lscd> sweet, i can even do things like :info /
16:55:39 <palomer> what about next tuesday?
16:55:55 <palomer> ok, I've neglected my haskell duties for far too long
16:55:56 <rasfar> @info /
16:55:57 <lambdabot> Unknown command, try @list
16:56:08 <int80_h> yes, and you must now repent
16:56:19 <hyrax42> how many haskellers are there in/around montreal anyway
16:56:32 <palomer> 1
16:56:35 <palomer> but he's a really good one
16:56:47 <palomer> in fact, the best 1 I've met
16:57:07 <hyrax42> hm
16:57:35 <int80_h> your repentence begins by learning the difference between the word one, and the number 1.
16:58:32 <palomer> ok, I'm going to write the GADT page for the wiki
16:58:55 <palomer> gah, I forgot I didn't know how to create a new page
17:12:43 <dons> moin
17:15:20 <stepcut> morning
17:16:59 <sethk> hey, -- doesn't work as a comment delimeter in a korn shell script.
17:17:04 <sethk> :)
17:17:05 <dons> hehe
17:17:08 <dons> ?karma+ sethk
17:17:09 <lambdabot> sethk's karma raised to 4.
17:17:10 <araujo> dons: moening!!
17:17:21 <dons> hey araujo 
17:17:31 <araujo> dons: how it goes?
17:19:25 <dons> good. trying to find me coffee
17:20:06 <araujo> hah
17:20:15 * araujo got several liters of tea here
17:39:28 <dons> @seen neologism
17:39:29 <lambdabot> neologism is in #haskell. I last heard neologism speak 8 hours, 50 minutes and 8 seconds ago.
17:40:44 <palomer> dons!
17:40:51 <palomer> dons: how do you write types on the wiki?
17:41:29 <dons> neologism: foldr (\x y -> if x==c then y + 1 else y) 0 s is equiivalent to a few things:
17:41:32 <dons> length (filter (==c) s)
17:41:42 <dons> Data.ByteString.Char8.count c s
17:41:50 <dons> pick the fastest one you want (my suggestion: count)
17:41:57 <dons> palomer: how do you write types??
17:42:07 <dons> do you mean, inside <haskell></haskell> tags?
17:43:01 <palomer> nono, outside
17:43:29 <palomer> I'm guessing I have to use mathb
17:43:35 <dons> indent them by a space from the start of the line, and you'll get it in courier/texttt font.
17:43:58 <dons> otherwise, troll through the MediaWiki docs at the bottom of the wiki pages
17:44:17 <palomer> nice, <math> \rightarrow does the trick
17:45:09 <jethr0> palomer: are you aware that there are latex packages for typesetting haskell?
17:45:33 <dons> this is on the wiki
17:45:37 <jethr0> ah
17:46:38 <tuxplorer> jethr0: those lhs files are latex typeset haskell files? wats the advantage? 
17:47:13 <jethr0> tuxplorer: i was thinking along the lines of writing a haskell-based paper...
17:47:35 <jethr0> i guess those packages were pretty much developped for doing the lhs thing
17:47:39 <tuxplorer> lhs is used only for publishing purposes ?
17:48:05 <jethr0> depends how you mean that, but not really
17:48:42 <jethr0> it's an implementation of knuth's "literate programming" idea, i think
17:50:19 <tuxplorer> instead of specifying like the indentation should be 8 spaces and not a tab, and stuff lke that, using latex does the job to maintain consistency of the code alignment and stuff?
17:50:22 <dons> petekaz: fixed the darcs 404 issue. i'd pushed a patch with the wrong perms
17:51:28 <ihope> Is literate Haskell generally used for heavily commented code, or some fancy stuff?
17:51:53 <jethr0> tuxplorer: not really. latex is only used for having annotated code and ultimately printing it out in a very verbose manner. it doesn't do anything to your editing environment apart from IMHO cluttering things up a lot
17:52:14 <tuxplorer> oh! k
17:52:37 <palomer> dons: finally got around to writing that GADT page: http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype
17:52:44 <jethr0> ihope: i think it's used when you generally have more comments/annotations than code. like a code-driven tutorial or so. but as i haven't used it yet, i really don't know
17:53:26 <palomer> dons: is it ok to remove the rest of the page?
17:53:55 <dons> yes. feel free to edit it for clairty. we want haskell.org wiki pages to be very well maintained
17:54:06 <dons> and not get all comment/old-stuff-ified
17:54:09 <jethr0> dons: who doesn't :)
17:54:31 <palomer> ok, the rest is getting deleted!
17:54:36 <dons> some of the old wiki stuff feels overly annotated, i think.
17:55:15 <jethr0> yep, and a little chaotic too. like having several discussions interleaved and some people pointing to other wiki pages, while others simply continue on the same page
17:55:34 <jethr0> IMO, wiki discussion pages of more than 5 pages are generally completely unreadable!
17:55:51 <jethr0> make that 3 pages
17:56:22 <dons> yeah, i've genernally been more brutal editing stuff on the new wiki + its a bit of a more formal, visible world, so has discouraged lots of annotation stuff. rather complete contributions from single people, with a few typo/fixing edits from others, seems to be the way for the articles
17:56:42 <palomer> should one sign the wiki page?
17:56:53 <dons> nah.
17:56:55 <dons> its in the logs
17:56:58 <palomer> kay
17:57:04 <jethr0> dons: i agree. but on some discussion-ish topics that might be hard to enforce
17:57:34 <dons> so far we haven't had many of these. and those that have take place on 'Talk:FooPage' pages
17:57:34 <palomer> well, that's one thing off my todo list
17:57:41 <dons> rather than the main page, which is a good MediaWiki thing
17:57:55 <dons> thanks palomer 
17:58:03 <palomer> np
17:58:22 <palomer> note that the more I work with GADTs, the less I'm convinced of their usefulness
17:58:26 <dons> hehe
17:58:34 <dons> but what if you want to write an interpreter :)
17:58:52 <dons> palomer: oh, you should always make a little comment about your change
17:58:52 <palomer> you'll need to write your terms in the meta language
17:59:07 <dons> so when we read the logs we can work out what people are doing
17:59:13 <dons> http://www.haskell.org/haskellwiki/Special:Recentchanges
17:59:21 <palomer> dons: check out the page, it shows the problems you'll have when parsing
17:59:34 <dons> i'm just teasing
17:59:47 <dons> I don't use GADTs. Maybe I will one day, but haven't needed them yet.
17:59:58 <dons> perhaps if i want some really strong guarantees.
18:00:05 <dons> do you know of darcs' use of GADTs?
18:00:32 <dons> to enforce various commutavitity and associativity properties on patches statically?
18:00:46 <jethr0> dons: it would be nice if one could put several consecutive diffs into one big one. i always feel bad if i've just spammed the recent changes with thousands of tiny commits :(
18:01:02 <dons> yeah. i usually work offline, then just upload the final version
18:01:05 <palomer> dons: I did not
18:01:21 <dons> palomer: I think darcs' use must be one of the most useful GADT applications
18:01:33 <dons> since they had an existign patch theory they wanted to lift into the type system to be checked
18:01:53 <palomer> hrmph, I'll have to look into it
18:01:59 <palomer> where do I add the little comments?
18:02:09 <palomer> in the "Summary" box?
18:02:19 <jethr0> yes, i've started doing that as well. mozex helps a lot in that respect
18:02:21 <dons> when you commit the page. there's a little box. Yeah, I think it's 'summary'
18:02:48 <jethr0> i don't even want to think about how often i lost long texts due to some user error or browser malfunction *argh*
18:03:08 <palomer> it seems that ghc takes the exact same approach to GADTs as me
18:03:15 <palomer> (though mine is _much_ cleaner)
18:03:15 <dons> cool. i can't believe it. i ordered an item to an internet store, and its delivered the next morning!
18:03:31 <dons> what's happening to the world.
18:03:44 <skew> shrinking
18:03:49 <dons> seems like.
18:03:54 <liyang> TIEM PARADOX!!!
18:04:07 <dons> ah, that might be it. finally we have some evidence!
18:04:27 <skew> transportation speeds are not bound by c
18:04:52 <skew> even if network latency is
18:05:42 <jethr0> my brother always orders digital photo printouts at a company that guarantees delivery the next day (if you order before noon). that's quite amazing.
18:06:26 <jethr0> as is amazon who send you shipping confirmation 5 minutes after ordering, even sundays at 3am, which generally is quite an exceptional thing here in germany
18:07:14 <skew> do they actually start shipping stuff?
18:07:47 <jethr0> yup, at least that's what they say in the mail: given over to the delivery company. and i have no reason to disbelieven them...
18:07:59 <skew> big customers can issue their own shipping numbers, even if the package isn't picked up right away
18:08:44 <jethr0> hmm, maybe, but even so shipping can be blazingly fast. like arriving the next day if you don't order too late on the previous day
18:09:13 <dons> yeah, there's a linux hardware company in sydney that sends it same day if you order before 3pm
18:09:27 <dons> which is kind of cool, if you just need some more ether cable 
18:10:17 <dons> same day, but to only inner sydney i guess. probably not same day to .de
18:10:18 <jethr0> even standard "non-airmail" mail from the US to germany arrives just in a few days. and i'm pretty sure that german customs are not speeding up that delivery. so, indeed the world is shrinking; at least wrt mail
18:10:33 <jethr0> hehe
18:15:06 <jethr0> g'night
18:29:24 <sethk> skew, a small company can just read the tracking number from a preprinted shipping form.
19:04:46 <dons> ?version
19:05:05 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
19:05:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:05:18 <dons> ?v
19:05:18 <lambdabot> Just 'J'
19:05:21 <dons> ?v
19:05:21 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:05:24 <dons> ?v
19:05:24 <lambdabot> Just 'J'
19:05:28 <dons> oh, the memories!
19:05:35 <sjanssen_> @yjuhl
19:05:36 <lambdabot> Unknown command, try @list
19:05:53 <dons> ?karma+ sjanssen -- always get karma points for writing new lambdabot code
19:05:54 <lambdabot> sjanssen's karma raised to 5.
19:06:12 <dons> ?y
19:06:12 <lambdabot> Maybe you meant: yhjulwwiefzojcbxybbruweejw yow . v
19:06:17 <dons> ?yh
19:06:17 <lambdabot> "\"#$%&'()*+,\""
19:06:20 <dons> hehe
19:08:27 <dons> $ length ByteString.hs
19:08:27 <dons> 2048
19:08:29 <dons> magic
19:16:00 * araujo back
19:52:15 * araujo thinks it has been a quite night
19:53:39 <araujo> @yarr!
19:53:39 <lambdabot> This is the END for you, you gutter-crawling cur!
19:59:19 <dons> yeah. 
20:39:56 <sjanssen_> @keal
20:39:57 <lambdabot> better be atleast 16x16 color with extended ascii set
20:40:01 <sjanssen_> @quote
20:40:01 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
20:41:00 <Korollary> I'm ith JaffaCake on that one.
20:41:02 <Korollary> +w
20:49:16 <araujo> Hi!
20:57:11 <sjanssen_> ?where fps
20:57:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:02:13 * palomer wonders when the arrows based version of parsec is coming out
21:03:02 <sjanssen_> there is an arrow based parsing library, if I remember correctly
21:25:28 <mwc> in general, if I have two tail recursive functions that operate on list, is their composition tail recursive
21:25:40 <mwc> is there some sort of result that allows me to assume such a composition exists?
21:28:28 <sjanssen_> mwc: do you mean something like: f :: [a] -> [b]; g :: [b] -> c; and you want to know whether g . f is also tail recursive?
21:34:11 <mwc> sjanssen, yeah, specifically, [b] -> [c] for the last one
21:34:27 <mwc> the second function is a simple foldl reverse
21:35:11 <sjanssen_> I think their compositions must be tail recursive
21:35:17 <Lokadin> @seen brigert
21:35:18 <lambdabot> I haven't seen brigert.
21:35:24 <sjanssen_> modulo laziness, perhaps
21:35:27 <Lokadin> @seen bringert
21:35:28 <lambdabot> I haven't seen bringert.
21:35:36 <Lokadin> :|
21:35:43 <Lokadin> where is bringert!
21:36:46 <Lokadin> :(
21:36:50 <Lokadin> @seen dons
21:36:51 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 37 minutes and 31 seconds ago.
21:38:58 <mwc> sjanssen, yeah, I mostly care about not blowing the stack
21:39:20 <mwc> as long as it's not linear stack usage wrt to the size of the input list, I'm happy
21:39:25 <sjanssen_> maintain strictness and you should be okay
21:39:39 <mwc> huh? I thought lazyness would have been safer
21:40:31 <sjanssen_> strictness will be linear heap usage, but constant stack
21:40:43 <mwc> foldl (\xs x -> x:xs) [] is the outer function, I suppose that could be made strict by foldl'.
21:41:23 <sjanssen_> mwc: that is reverse, right?
21:41:37 <mwc> yep
21:41:58 <mwc> foldl is tail recursive
21:43:25 <dons> re.
21:43:27 <sjanssen_> foldl' should be better there
21:43:44 <hyrax42> preferred haskell-hacking environment: haskell-mode?
21:43:51 <hyrax42> (don't say yi)
21:43:53 <hyrax42> (!)
21:43:55 <dons> vim?
21:43:59 <mwc> yeah, I suppose it's nonsensical to reverse an infinite list
21:44:04 <sjanssen_> you have the option of a giant list or a giant thunk, the list should be better
21:44:15 <dons> mwc, yeah, it takes some time to find the end :)
21:44:16 <Lokadin> has anyone seen a haskell readline implementation?
21:44:16 <mwc> since the first element could never be computed
21:44:18 <dons> > reverse [1..]
21:44:22 <lambdabot> Terminated
21:44:29 <dons> ?hoogle Readline
21:44:29 <hyrax42> @index readLine
21:44:29 <lambdabot> System.Console.Readline :: module
21:44:30 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
21:44:30 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
21:44:30 <lambdabot> bzzt
21:44:48 <mwc> Lokadin, implementation, or binding
21:45:02 <sjanssen_> I always hear an Arnold Schwarzeneger voice when lambdabot says "Terminated"
21:45:12 <sjanssen_> I hope I spelled the Governator's name correctly
21:45:17 <Lokadin> mwc: implementation
21:45:17 <mwc> Tuhmunatud
21:45:31 <mwc> Lokadin, nope
21:45:33 <Lokadin> mwc: someone that has used readline in a haskell program
21:45:40 <mwc> that would be a binding
21:45:43 <Lokadin> oh
21:45:44 <Lokadin> okay
21:45:49 <Lokadin> well that's what i wanted
21:46:01 <Lokadin> i'm not really sure of the terminology
21:46:04 <mwc> binding is a set of haskell function defintions that interface to an underlying c library
21:46:12 <mwc> an implementation would be readline completely redone in haskell
21:46:26 <mwc> something dons probably wrote over lunch last week
21:47:04 <Lokadin> lol
21:47:21 <Lokadin> well er then i need just an example of someone that has used readline in a haskell program
21:47:29 <Lokadin> what would that be called?
21:47:37 <dons> its dead easy. like 2 lines.
21:47:45 * dons hunts for readline examples
21:48:03 <dons>         s <- readline "lambdabot> " -- read stdin
21:48:03 <dons>         case s of
21:48:03 <dons>             Nothing -> error "<eof>"
21:48:03 <dons>             Just x -> let s' = dropWhile isSpace x
21:48:03 <dons>                       in if null s' then putMVar syncR () >> readerLoop' else do
21:48:06 <dons>                 addHistory s'
21:48:09 <dons> from lambdabot's offline mode
21:48:31 <dons> you just replace 'getLine' with 'readline', and do a case on the result
21:50:02 <Lokadin> er one sec let me get that
21:50:16 <Lokadin> oh okay
21:50:22 <Lokadin> :)
21:50:41 <sjanssen_> why can't I find the definition for reverse in GHC's source?
21:50:54 <dons> its in GHC.List ?
21:51:04 <sjanssen_> aha!
21:51:09 <dons> reverse                 :: [a] -> [a]
21:51:09 <dons> #ifdef USE_REPORT_PRELUDE
21:51:09 <dons> reverse                 =  foldl (flip (:)) []
21:51:09 <dons> #else
21:51:09 <dons> reverse l =  rev l []
21:51:11 <dons>   where
21:51:14 <dons>     rev []     a = a
21:51:14 <sjanssen_> I grepped for .hs, not .lhs
21:51:17 <dons>     rev (x:xs) a = rev xs (x:a)
21:51:19 <dons> #endif
21:51:22 <dons> ah yes.
21:51:36 <dons> you want to write a Haskell reverse for fps, by chance?
21:51:50 <dons> actually, what we need is sortBy
21:52:03 <dons> that's something that lots of people use that's currently missing from ByteString
21:52:36 <sjanssen_> hmm
21:52:51 <sjanssen_> how do callbacks from C to Haskell work?
21:52:53 <sjanssen_> are they slow?
21:52:53 <RyanT5000> is there a way to force the RTS to GC?
21:53:01 <dons> RyanT5000: performGC
21:53:09 <dons> ?index performGC
21:53:09 <lambdabot> System.Mem
21:53:13 <RyanT5000> thanks
21:53:26 <dons> sjanssen_: hmm. i think they're slowish if you do O(n) of them.
21:53:26 <RyanT5000> how about output profiling stats?
21:53:35 <RyanT5000> i think i asked that this morning while you weren't on, dons
21:53:39 <dons> +RTS -p , that's the only way.
21:53:42 <RyanT5000> crap
21:53:48 <dons> unless you tweak the rts 
21:53:52 <RyanT5000> my program crashes while (i think) running at_exit stuff
21:53:57 <dons> yeah, i know.
21:54:02 <RyanT5000> ah ok 
21:54:07 <sjanssen_> dons: it'd be worse, O(n log n).  so I guess the best way is to write an imperative sort in Haskell
21:54:09 <RyanT5000> i guess i've been going on about it for a few days now :P
21:54:15 <dons> i have a beeper that goes off whenever some has a Haskell bug
21:54:25 <RyanT5000> :P
21:54:33 <dons> sjanssen_: yes. that's what I'd like to see.
21:54:48 <sjanssen_> I'll look in to it, tomorrow
21:54:54 <dons> basically take mergesort for C, and translate it to peek/poke/withForeingPtr semantics
21:55:00 * sjanssen_ has a 7:30 AM final tomorrow
21:55:03 <dons> sjanssen_: nah, its ok. i'll do it today.
21:55:17 * dons hunts around for Cormen
21:55:49 <dons> ooh. so many fun sorting algorithms
21:56:41 <sjanssen_> what sort does ByteString use now?
21:56:50 <dons> sort is a little bit evil
21:56:54 <dons> unlike:
21:56:57 <dons> ?type sort
21:56:59 <lambdabot> forall a. (Ord a) => [a] -> [a]
21:57:05 <dons> which lets you extend with an Ord instance
21:57:12 <dons> ?type Data.ByteString.sort
21:57:13 <lambdabot> Data.ByteString.ByteString
21:57:14 <lambdabot>         -> Data.ByteString.ByteString
21:57:15 <dons> just calls qsort
21:57:18 <sjanssen_> oh
21:57:28 <dons> so its really a sortEqBytes or something
21:57:37 <sjanssen_> we could use a linear sort!
21:57:45 <dons> yeah, just thinking that
21:57:50 <dons> a radix sort or such
21:58:19 <sjanssen_> counting sort is likely the best
21:58:42 <dons> doesn't counting sort need some range requirement?
21:58:43 <Lokadin> @hoogle dropWhile
21:58:43 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
21:58:43 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
21:59:04 <dons> ah, yes. an integer in the rang 1 to k.
21:59:16 <dons> ?karma+ cormen
21:59:16 <lambdabot> cormen's karma raised to 1.
21:59:22 <sjanssen_> 256 is a reasonably small k
21:59:37 <sjanssen_> well, maybe not
21:59:58 <sjanssen_> what kind of programs will sort a string?  will they use very large strings?
22:00:07 <dons> i'd think not.
22:00:15 <dons> i'd say mostly /usr/share/dict/words length.
22:00:18 <dons> but who knows?
22:00:25 <dons> esp. once people realise that sorting 1G works...
22:00:51 <sjanssen_> actually, I meant small strings
22:00:54 <dons> i think though that we could code up a couple or 3 examples and try them out.
22:01:08 <dons> yeah, i meant the length of words in the dict.
22:01:13 <dons> that'd be the average case.
22:01:28 <Korollary> Individual strings are rarely sorted.
22:01:49 <dons> ah, but even then, that's not Data.ByteString.sort, that's List.sort
22:01:56 <dons> using memcmp
22:01:58 <Korollary> Yes
22:02:05 <dons> i.e. mostly it'll be sort . lines
22:02:25 <dons> anyway, we can code up a few algos and try them out
22:03:51 <Korollary> yeah, python doesn't even provide sort() for strings.
22:04:28 <dons> huh
22:05:00 <Korollary> nor does Java.lang.String have a sort().
22:05:20 <dons> ByteString++ :)
22:06:03 <Korollary> is ByteString a monad instance?
22:07:14 <sjanssen_> Korollary: can't, wrong kind
22:07:30 <sjanssen_> @kind Data.ByteString.ByteString
22:07:31 <lambdabot> *
22:07:39 <Korollary> oh right
22:07:52 <Korollary> I forgot that it wasn't parametric
22:08:00 <dons> Korollary: yeah. can't do it :(
22:08:11 <dons> i'd love a Functor ByteString. if only.
22:08:25 <dons> @kind Data.Array.Unboxed.UArray
22:08:27 <lambdabot> * -> * -> *
22:08:34 <dons> @kind []
22:08:35 <lambdabot> * -> *
22:08:55 <dons> with an index type, I guess you could have a Functor (UArray Int) or such
22:09:06 <dons> behaving like a list monad
22:12:41 <RyanT5001> i got disconnected; when is my old nick's connection going to sign off?
22:13:43 <palomer> http://www.rafb.net/paste/results/RPWOKV80.html <--grrr, this type grammar is driving me nuts
22:13:48 <dons> sjanssen: yeah, counting sort looks good for Word8 types
22:14:01 <Korollary> That depends on the irc server's timeout settings, but eventually your old connection will time out and be dropped.
22:14:01 <dons> and we can build the histogram as a separate function. maybe 10 lines of code.
22:14:20 <palomer> ahh, found the fix
22:14:25 <Lokadin> dons: if i'm making a fully dynamic application, would you recommend that i make it dynamic from the begining or just add it in later as you did with lambdabot
22:15:20 <palomer> yes, it works!
22:15:22 * palomer high fives everyone
22:15:46 <palomer> dons: mind I private message you?
22:17:39 <dons> palomer: go for it. but i won't be online for about 4 hours. off to a meeting
22:18:06 <palomer>  a priv for another day
22:18:36 <Lokadin> dons: so should i just make it fully dynamic later?(don't have any modules yet)
22:24:46 <RyanT5001> is it bad to call peekByteOff once for each byte in a huge array?
22:24:53 <RyanT5001> or does that kind of thing get optimized
22:25:12 <RyanT5001> also, is there a better way of doing it?
22:25:36 <RyanT5001> (like, using a Storable array)
22:26:51 <sjanssen> what is wrong with peekByteOff?
22:27:18 <Lokadin> @hoogle readline
22:27:18 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
22:27:18 <lambdabot> System.Console.Readline :: module
22:27:18 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
22:29:07 <Lokadin> @hoogle isSpace
22:29:07 <lambdabot> Char.isSpace :: Char -> Bool
22:31:30 <RyanT5001> ok, so after rebuilding with debug libraries, i find that my crash is occurring inside of __heap_select
22:31:39 <RyanT5001> i have no idea what that means
22:32:04 <Korollary> you could look up which library that symbol comes from
22:32:16 <RyanT5001> it's from the C common runtime
22:32:24 <Korollary> is that windows?
22:32:29 <Korollary> msvcrt?
22:33:05 <RyanT5001> oh i guess i don't know which exact .lib it's from
22:33:27 <RyanT5001> yeah, msvcr71.dll
22:35:48 <RyanT5001> hm, actually i don't think that's right
22:35:51 <RyanT5001> i think the stack trace is totally wrong
22:36:02 <RyanT5001> it's not really on a "real line" in that function
22:36:33 <RyanT5001> oh wait, yeah it is
22:36:40 <RyanT5001> it's within GetEnvironmentVariableA
22:37:16 <Korollary> that would be really weird
22:37:41 <RyanT5001> what would?
22:37:53 <Korollary> arent you debugging an opengl app?
22:37:59 <araujo> hiya!
22:38:19 <RyanT5001> it is using OpenGL with SDL
22:39:01 <goltrpoat> is there a common pattern for restricting operator properties?  in the sense of "any instance of this class that implements this operator must make sure that the operator is commutative", say
22:39:30 <RyanT5001> goltrpoat: i doubt it, because i don't think there's any way the type system could enforce that
22:39:33 <Korollary> not that I know of. How could that be enforced?
22:40:40 <RyanT5001> a lot of functions that are commutative use noncommutative operations to achieve their results
22:40:49 <RyanT5001> e.g.: multiplication of large numbers
22:40:58 <goltrpoat> yah i was trying to figure out how it would be enforced, and i have no clue how it would work..
22:41:03 <goltrpoat> right, exactly
22:41:28 <RyanT5001> so it would essentially boil down to a comment
22:41:40 <sethk> goltrpoat, you could define a type class to represent that
22:41:43 <sjanssen> goltrpoat: proving that a function is commutative sounds like one of those tasks a computer just can't do
22:42:19 <RyanT5001> sjanssen: probably "many" cases can be solved automatically, though
22:42:23 <sethk> goltrpoat, it is actually similar to the restrictions on a monad, although the language doesn't enforce those, the programmer does
22:42:28 <goltrpoat> sjanssen:  is f x y ~ f y x undecidable then?
22:42:40 <sethk> it isn't undecidable, no
22:42:59 <goltrpoat> then why would it be one of those tasks that it just can't do
22:43:06 <RyanT5001> sethk it isn't? it seems like it would be
22:43:06 <sethk> goltrpoat, I don't think that it is
22:43:12 <goltrpoat> ah
22:43:29 <sjanssen> maybe I'm wrong, I said "sounds like", don't take that comment too seriously
22:43:33 <goltrpoat> hehe
22:43:36 <sethk> RyanT5001, probably in the most general case it is hard, but I think in the restricted cases the language would have to deal with it's possible
22:43:42 <sethk> hey, I could be wrong also
22:44:21 <RyanT5001> sethk: that sounds reasonable to me
22:44:36 <sethk> if you restrict yourself to the built in types I think it is manageable, certainly
22:44:39 <RyanT5001> i think you might be able to prove some stuff if you already have tons of commutative-annotations
22:45:07 <RyanT5001> although you'd also need inverse-annotations, i think
22:45:10 <sethk> RyanT5001, yes, indeed, we have a bunch of operators that we know are communative and some that aren't
22:46:12 <RyanT5001> e.g.: f (x, y) = (exp x, log y); g (y, x) = f (x, y)
22:46:25 <goltrpoat> the way it came up was i started writing a small numerical analysis / matrix library type deal..  wrote the vector/matrix operations, and realized that it'd be a lot nicer if i could say this is a field, this is a vector space over a field, this is a linear operator, etc..  making things entirely generic
22:46:29 <RyanT5001> f . g is commutative, but without knowing exp is the inverse of log, you can't prove it
22:46:30 <sethk> I think that stuff written in ML ages ago was proving properties of that sort
22:47:41 <sethk> what you would have to do is look at how an inductive proof would be structured, and then see if there is a reasonable way to map it to a machine.
22:47:52 <sethk> that was the original purpose of ML
22:48:19 <sethk> stood for meta-language, because it was designed to automate proofs
22:48:23 <goltrpoat> -nod-
22:51:36 <sethk> unfortunately I have to solve a much more difficult and infinitely less interesting problem by morning.
22:51:37 <goltrpoat> the point is also a little moot, because floating-point arithmetic isn't commutative or associative in the places you'd expect it to be..
22:52:26 <sethk> goltrpoat, you could start, then, by figuring out how to prove that those cases are not communative.
22:52:50 <sethk> goltrpoat, give us an example, something that "seems" like it would be communative but isn't
22:53:26 <Korollary> capitalism
22:53:31 <goltrpoat> well, what i mean is, for all intents and purposes, a vector space over 32-bit floats as a "field" (a broken one) is fine, so we should be able to define it -- and any LA app will happily operate on these "vectors"
22:53:42 <sethk> Korollary, leave my spelling out of this.  :)
22:56:51 <goltrpoat> i think i'll just keep working on the "unsafe" version of the library, and keep the whole thing in mind for later.. i think it'd go over my head pretty quickly right now
22:57:07 <sethk> goltrpoat, it's an interesting question.
22:57:17 <goltrpoat> -nod-
23:11:55 <Korollary> Wow. What a lame Mac tv ad
23:24:32 <SubStack> Korollary, is there any other kind?
23:24:50 <Korollary> SubStack: I haven
23:25:10 <Korollary> SubStack: I haven't seen many, but this one (with the pc represented by a sneezing guy) was lame beyond boundaries.
23:25:26 <SubStack> heh, sneezing guy
23:25:38 <SubStack> I hate it when companies with otherwise decent products do that
23:25:52 <rafael> Hi
23:26:11 <Korollary> It's a braindead idea. Who are the adwizards who came up with that one? Third graders?
23:26:26 <rafael> if i want to subtract two from a list of numebers, would map (\x -> x-2) list be the better way to do it?
23:27:18 <Korollary> rafael: That's as good as it gets
23:27:56 <vincenz> dons: ping
23:28:51 <rafael> ok, thanks
23:32:46 <vincenz> Oejet: ping
23:35:01 <neologism> dons: P.count is MUUUCH faster
23:46:14 <palomer> >:o
23:46:20 <palomer> @palomer
23:46:21 <lambdabot> learning vim is pointless
23:46:27 <Korollary> lol
23:46:38 <vincenz> hmm
23:46:42 <vincenz> @vincenz
23:46:42 <lambdabot> Unknown command, try @list
23:46:54 <Korollary> @keal
23:46:54 <lambdabot> i cant think anymore
23:47:01 <palomer> @palomer
23:47:02 <lambdabot> blargh!
23:47:14 <palomer> learning vim IS pointless
23:47:34 <vincenz> palomer: what do you use?
23:48:18 <vincenz> Btw
23:48:26 <vincenz> are new computers more power-saving?
23:48:33 <palomer> emacs
23:48:38 <palomer> of course
23:48:45 <palomer> though I'm thinking of switching to yi
23:48:49 <vincenz> cause I checked my consumption
23:49:08 <vincenz> and I went up from 2600 kWh in 2004 to 3400 kWh in 2005
23:49:15 <vincenz> having my computer on constantly
23:49:29 <vincenz> that's like 300 euros more
23:50:28 <palomer> didn't europe have an exceptionally cold winter?
23:50:34 <vincenz> I heat on gas
23:50:39 <vincenz> so that's a separate thing
23:50:59 <palomer> but the heating from the computer probably saved some gas
23:52:19 <vincenz> lo
23:52:20 <vincenz> l
23:52:50 <goltrpoat> this is probably the most off-topic thing i've ever said on irc, but what was that extension of goedel's incompleteness theorems to ethics called?
23:52:56 <goltrpoat> h-something
23:53:22 <palomer> they're extended to ethics
23:53:23 <palomer> ?
23:53:30 <goltrpoat> yeah
23:53:58 <palomer> ethical completeness?
23:54:55 <goltrpoat> it's an argument for moral relativism
23:55:39 <Korollary> goltrpoat: it's gotta be on his wikipedia entry
23:56:24 <goltrpoat> doesn't seem to be..  it was a later development, and doesn't really have to do with goedel per se
23:56:40 <goltrpoat> i don't see it in the moral relativism entry though
23:56:50 <goltrpoat> anyway, not hugely important, just thought someone might know off the top of their head
23:57:01 <Korollary> I remember reading about his attempts to prove god's existence.
23:58:32 <palomer> when he became nuts?
23:59:03 <Korollary> yeah around that time
