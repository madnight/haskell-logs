02:49:51 <dons> quiet night.
02:56:13 <basti_> quite midday.
03:24:06 <Skymarshal> I have to define a function which uses a second function on each pair of a given list. Example: condense (-) [1,3,2,5,9] would become [-2,1,-3,4]. I have no idea how to give the function name into the first function. Any ideas?
03:25:37 <basti_> "how to give the function name into the first function"?
03:25:44 <basti_> > map (-) [1,2,3]
03:25:44 <lambdabot> Add a type signature
03:25:50 <basti_> > map (-) [1::Integer,2,3]
03:25:51 <lambdabot> [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
03:25:54 <basti_> argh
03:26:01 <basti_> > map (0-) [1::Integer,2,3]
03:26:02 <lambdabot> [-1,-2,-3]
03:26:07 <basti_> like that?
03:26:20 <nomeata> > :t ["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]
03:26:20 <lambdabot>  parse error on input `:'
03:26:30 <nomeata> @type ["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]
03:26:30 <lambdabot> [[Char]]
03:26:38 <nomeata> shouldn't that say "Topic"? :-)
03:26:50 <basti_> nomeata: >_<
03:27:28 <neologism> let f x = [ y | z <- [1..length x-1], a <- x!!z, b <- x!!(z+1), y <- a - b]
03:27:38 <neologism> let f x = [ y | z <- [1..length x-1], a <- x!!z, b <- x!!(z+1), y <- a - b] in f [1,3,2,5,9]
03:27:49 <basti_> you forgot >.
03:28:01 <neologism> > let f x = [ y | z <- [1..length x-1], a <- x!!z, b <- x!!(z+1), y <- a - b] in f [1,3,2,5,9]
03:28:02 <lambdabot>  add an instance declaration for (Num [[a]])
03:28:02 <lambdabot>   In the list element: 9
03:28:11 <neologism> eh?
03:32:10 <neologism> > let f x = [ ((x!!z) - (x!!(z+1))) | z <- [0..length x-2]] in f [1,3,2,5,9]
03:32:11 <lambdabot> [-2,1,-3,-4]
03:32:17 <neologism> Skymarshal: this?
03:32:26 <isaacd> For non-null, lists, condense xs = zipWith (-) xs (tail xs)  ?
03:32:35 <isaacd> For non-null, lists, condense f xs = zipWith f xs (tail xs)  ?
03:33:05 <isaacd> > let condense f xs = zipWith f xs (tail xs) in condense (-) [1,3,2,5,9]
03:33:06 <lambdabot> [-2,1,-3,-4]
03:35:19 <isaacd> @pl \f xs -> zipWith f xs (tail xs)
03:35:20 <lambdabot> (`ap` tail) . zipWith
03:37:04 <isaacd> let condense f xs = zipWith f xs (tail xs) in let l = 1:1:condense (+) l in take 20 l
03:37:08 <isaacd> > let condense f xs = zipWith f xs (tail xs) in let l = 1:1:condense (+) l in take 20 l
03:37:09 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
03:39:02 <isaacd> @pl fix (\l -> 1:1:((`ap` tail) . zipWith) (+) l)
03:39:03 <lambdabot> fix ((1 :) . (1 :) . (zipWith (+) `ap` tail))
03:43:56 <Skymarshal> just a second. got a bit confused. have to sort it out.
03:44:42 <mahogny> hm. anyone know a nice way for finding space leaks?
03:44:57 <basti_> did you try the profiler?
03:45:12 <mahogny> no. that's the place to start?
03:45:31 <basti_> I'd give it a try at least
03:59:38 <Skymarshal> all: basti_ helped me in a private session. Gee... Haskell is one strange mirrakle!
04:01:18 <basti_> you didnt even scrape the strange parts.
04:53:47 <psnl> is there a way of seeing what functions are in a type class?
04:54:01 <basti_> "info"
04:54:03 <basti_> :i
04:54:06 <basti_> i think.
04:54:07 <psnl> ta
04:54:26 <psnl> thanks, that works
04:54:37 <basti_> :)
04:55:28 <davidhouse> can you make parsec's string function case-insensitive?
04:55:38 <mahogny> make your own?
04:56:13 <davidhouse> hmm.
04:57:21 <davidhouse> stringi = foldl (>>) (return ()) . map (uncurry (<|>) . (toUpper *** toLower))
04:57:46 <mahogny> x_x
04:58:13 <davidhouse> or perhaps use mapM instead of the fold.
04:58:29 * davidhouse isn't quite sure how mapM works with parsec
04:58:49 <int-e> not sequence_?
04:59:05 <davidhouse> mapM = map . sequence
04:59:11 <davidhouse> err, sequence . map
04:59:20 <davidhouse> up to number of parameters.
04:59:25 <int-e> ah, didn't see the map. right.
04:59:56 <davidhouse> @hoogle parser
04:59:56 <lambdabot> Language.Haskell.Parser :: module
04:59:57 <lambdabot> Text.ParserCombinators.Parsec.Prim.Parser :: type Parser a
04:59:57 <lambdabot> Distribution.InstalledPackageInfo.ParseResult :: data ParseResult a
04:59:58 <davidhouse> @hoogle parse
04:59:58 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
04:59:59 <lambdabot> Data.Version.parseVersion :: ReadP Version
04:59:59 <lambdabot> Distribution.InstalledPackageInfo.parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
05:00:11 <int-e> @type (mapM, mapM_)
05:00:12 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1.
05:00:12 <lambdabot>       (Monad m, Monad m1) =>
05:00:12 <lambdabot>       ((a -> m b) -> [a] -> m [b], (a1 -> m1 b1) -> [a1] -> m1 ())
05:00:26 <davidhouse> > either (error "Aargh") id $ parse (mapM char "hello") "" "hello"
05:00:26 <lambdabot>  Not in scope: `char'
05:00:35 <davidhouse> > either (error "Aargh") id $ parse (mapM Text.ParserCombinators.Parsec.char "hello") "" "hello"
05:00:36 <lambdabot>  Not in scope: `Text.ParserCombinators.Parsec.char'
05:00:45 <davidhouse> @hoogle char
05:00:45 <lambdabot> Text.ParserCombinators.ReadP.char :: Char -> ReadP Char
05:00:45 <lambdabot> Text.PrettyPrint.HughesPJ.char :: Char -> Doc
05:00:45 <lambdabot> Text.ParserCombinators.Parsec.Char.char :: Char -> CharParser st Char
05:00:52 <davidhouse> > either (error "Aargh") id $ parse (mapM Text.ParserCombinators.Parsec.Char.char "hello") "" "hello"
05:00:52 <lambdabot>  Not in scope: `Text.ParserCombinators.Parsec.Char.char'
05:00:55 <davidhouse> grr.
05:01:15 <davidhouse> @fptools Text.ParserCombinators.Parsec
05:01:15 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec.hs
05:01:30 <davidhouse> @fptools Text.ParserCombinators.Parsec.Char
05:01:30 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec/Char.hs
05:02:09 <int-e> runplugs doesn't import Parsec *shrugs*
05:02:48 <davidhouse> works on GHCi.
05:02:52 <davidhouse> right, so mapM will do.
05:03:20 <davidhouse> @type mapM (uncurry (<|>) . toUpper *** toLower))
05:03:21 <lambdabot> parse error on input `)'
05:03:28 <davidhouse> @type mapM (uncurry (<|>) . toUpper *** toLower)
05:03:29 <lambdabot> Not in scope: `<|>'
05:03:34 <davidhouse> eurgh, never mind.
05:05:10 <davidhouse> mapM (uncurry (<|>) . (char . toUpper &&& char . toLower)) -- this works.
05:05:36 <davidhouse> @. hoogle type \f (a, b) -> (f a, f b)
05:05:38 <lambdabot> Did you mean: Forall b A. (b -> a) -> (b, b) -> (a, a)
05:06:02 <davidhouse> @type \f (a, b) -> (f a, f b)
05:06:03 <lambdabot> forall b a. (b -> a) -> (b, b) -> (a, a)
05:06:12 <davidhouse> @hoogle (b -> a) -> (b, b) -> (a, a)
05:06:13 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:06:26 <davidhouse> (it seems hoogle can't handle quantifiers)
05:06:58 <davidhouse> (>>> (f *** f)) would do it, i suppose. but that's ugly.
05:07:39 <davidhouse> @hoogle a b (c, c) -> (c -> d) -> a b (d, d)
05:07:39 <lambdabot> No matches, try a more general search
05:07:43 <davidhouse> ah well.
05:07:47 * davidhouse <- food
05:21:42 <nomeata> I was recently wondering: Is there a good reason that there is no function like iterate, but where the "inner" function returns a tupel: one for the result list, and one for the next iteration. So, something with a siganture of (a -> (a,b)) -> a -> [b].
05:22:36 <basti_> i think you can assemble that from more primitive funktions
05:28:23 <nomeata> probably, but I had expected it to be relatively common. For example, splitAt would be nice if it could be repeated, to cut a list up into even blocks
05:28:37 <basti_> write one :)
05:43:07 <davidhouse> @spell ordeal
05:43:08 <lambdabot> ordeal
05:52:06 <cm> nomeata: unfoldr
05:52:20 <davidhouse> @type unfoldr
05:52:21 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
05:52:24 <xerox> @yow!
05:52:25 <lambdabot> Excuse me, but didn't I tell you there's NO HOPE for the survival of
05:52:25 <lambdabot> OFFSET PRINTING?
05:52:56 <nomeata> cm: oh, nice
05:53:15 <davidhouse> > take 20 $ unfoldr (\x -> Just (chr x, x+1)) 1
05:53:16 <lambdabot> "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4"
05:53:30 <davidhouse> > map chr [1..20]
05:53:31 <lambdabot> "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4"
05:53:36 <davidhouse> nice.
05:53:44 <integral> wow, \SOH etc are haskell escapes?  nice!
05:53:52 <davidhouse> > unfoldr (\x -> if x < 20 then Just (chr x, x+1) else Nothing) 1
05:53:53 <lambdabot> "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3"
05:53:55 <basti_> yes we're cool.
05:54:03 <davidhouse> that's the purpose of the Maybe.
05:54:45 <basti_> another loop abstraction.
05:55:11 <nomeata> > unfoldr (\x -> if x = [] then Nothing else Just (splitAt 3 x)) "This is a string"
05:55:11 <lambdabot>  parse error on input `='
05:55:17 <nomeata> > unfoldr (\x -> if x == [] then Nothing else Just (splitAt 3 x)) "This is a string"
05:55:18 <lambdabot> ["Thi","s i","s a"," st","rin","g"]
05:55:22 <nomeata> kewl
05:55:24 <davidhouse> nice :)
05:56:05 <nomeata> > let nullstop f []  = Nothing; nullstop f l = Just (f l)
05:56:05 <lambdabot>  parse error on input `}'
05:56:19 <davidhouse> you need an in block.
05:56:30 <nomeata> > let nullstop f []  = Nothing; nullstop f l = Just (f l) in  unfoldr (nullstop (splitAt 3)) "This is a string
05:56:30 <lambdabot>  lexical error in string/character literal
05:57:00 <nomeata> > let nullstop f []  = Nothing; nullstop f l = Just (f l) in  unfoldr (nullstop (splitAt 3)) "This is a string"
05:57:01 <lambdabot> ["Thi","s i","s a"," st","rin","g"]
05:57:12 <nomeata> we need nullstop in Prelude :-P
05:57:20 <davidhouse> nullstop f = fmap . listToMaybe
05:57:25 <davidhouse> oh, err, not quite.
05:57:38 <davidhouse> i meant fmap f, but it's still not quite right.
05:57:52 <nomeata> or better: stop when func arg = if (when arg) then Nothing else Just (func arg)
05:57:54 <cm> nullstop is not a very good name ;)
05:58:07 <davidhouse> if when arg? ;)
05:58:24 <nomeata> > let stop when func arg = if (when arg) then Nothing else Just (func arg) in  unfoldr (stop null (splitAt 3)) "This is a string"
05:58:25 <lambdabot> ["Thi","s i","s a"," st","rin","g"]
05:58:28 <davidhouse> @hoogle boolToMaybe
05:58:29 <lambdabot> No matches found
05:58:45 <nomeata> @hoogle [a] -> Maybe [a]
05:58:45 <lambdabot> No matches, try a more general search
05:58:58 * nomeata has to go, thx for the unfoldr tip
05:59:10 <davidhouse> @type let stop when func arg = if (when arg) then Nothing else Just (func arg) in stop
05:59:10 <lambdabot> forall t
05:59:11 <lambdabot>                                a.
05:59:11 <lambdabot>                             (t -> Bool)
05:59:11 <lambdabot>                             -> (t -> a)
05:59:11 <lambdabot>                             -> t
05:59:12 <lambdabot>                             -> Maybe a
06:00:45 <davidhouse> > let chunkify n s | length s < n = s | otherwise = take n s : chunkify n (drop n s) in chunkify 3 "This is a string"
06:00:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:00:46 <lambdabot>   Expected type: [[a]]
06:00:46 <lambdabot>   Inferred type: [a]
06:01:04 <davidhouse> > let chunkify n s | length s < n = [s] | otherwise = take n s : chunkify n (drop n s) in chunkify 3 "This is a string"
06:01:05 <lambdabot> ["Thi","s i","s a"," st","rin","g"]
06:02:58 <cm> chunks might be a good name, like "lines" in Prelude ;-)
06:06:22 <Philippa_> 'lo cm
06:06:54 <cm> heya
06:52:39 <araujo> morning
07:15:43 <shapr> dons: ping?
07:16:48 <shapr> I just had this nutty idea about specifying the 'required laziness' of a bunch of code by lifting the functions into arrows only for the purpose of stick properties onto them.
07:18:55 <shapr> What are the really important laziness properties of a chunk of code? I can immediately think of whether it must evaluate an entire list before it produces output, basically whether it can handle infinite structures without blowing the stack.
07:21:14 <shapr> I'd rather put that sort of info into a type, like StrictOnLists a or something.
08:27:30 <mcnster> good morning :)
08:30:24 <mcnster> newbie q of the day:  is there a 'readFile'-type fn that will correctly translate utf-8 into appropriate Char's?
08:30:58 <mcnster> (in ghc)
08:33:11 <Igloo> I don't think so, but there a libraries around
08:33:34 <vincenz> isn't Char utf-8 by default?
08:33:54 <Igloo> readFile reads 8-bit bytes
08:33:58 <vincenz> ah
08:33:59 <mcnster> vincenz, it appears that Char is utf-8
08:34:12 <mcnster> ahso
08:34:12 <vincenz> it's the reading that's the problem
08:34:36 <vincenz> > chr 255
08:34:37 <lambdabot> '\255'
08:34:39 <vincenz> > chr 256
08:34:40 <lambdabot> '\256'
08:34:42 <vincenz> > chr 257
08:34:43 <lambdabot> '\257'
08:35:46 <mcnster> well i guess i'll have to do it The Hard Way[tm].  later
08:42:53 <vincenz> hey people
08:42:56 <vincenz> we have a new haskell convert
08:43:03 <vincenz> however he's hahving issues with compiling opengl with ghc
08:43:07 <vincenz> anyone having experience with this?
08:44:16 <ADEpt> platform?
08:44:32 <vincenz> here is the error he gave me
08:44:33 <vincenz> 20Pix/10303.jpg
08:44:35 <vincenz> http://www.xs4all.nl/~weegen/eelis/t.png
08:44:51 <vincenz> Eelis: ADEpt asked which platform
08:44:56 <Eelis> greetings. i'm having trouble compiling ghc-6.4.2. i've made a screenshot showing the error: http://www.xs4all.nl/~weegen/eelis/t.png
08:45:07 <Eelis> platform is athlon 64, suse 10.0
08:45:20 <vincenz> Eelis: btw, what os is that, it looks neat those windows
08:45:22 <vincenz> hwo do you do that
08:45:32 <Eelis> i use the Ion3 window manager
08:45:44 <vincenz> so hwo do you get the terminals nicely tiled, or is that a custom terminal proggy?
08:45:51 <Eelis> Ion3 is a tiling window manager
08:45:59 <Eelis> tiling is its primary means of window organization
08:46:00 <vincenz> ah nice
08:46:58 <ADEpt> Eelis: isnt there prebuilt libraries out there?
08:47:23 <ADEpt> /libr/bin/
08:47:49 <vincenz> that looks like a bug, tho
08:48:12 <Eelis> ADEpt: i downloaded the ghc-6.4.2-x86_64-unknown-linux.tar.bz2 package, but it doesn't include the opengl library, which is why i'm using it to compile the source distribution which does seem to include the opengl library
08:48:13 <wolverian> ratpoison is another, even simpler than ion
08:49:01 <vincenz> back to my c++ code :/
08:49:31 <millhouse> If I'm in ghci and I've got some main function that expects command-line arguments, does anyone know how I can get ghci to simulate the command line args?
08:50:12 <Saulzar> Eelis, I've seen various mailing list posts referring to OpenAL not compiling - maybe there's something useful there
08:50:31 <mauke_> :set args
08:50:46 <Eelis> Saulzar: i'll have a look, thanks
08:51:15 <millhouse> mauke_: I thought that command changes the args to ghci itself
08:51:30 <mauke_> :set args <arg> ...         set the arguments returned by System.getArgs
08:51:39 <millhouse> ah
08:51:44 <millhouse> ok, thanks
08:52:41 <vincenz> > let fib = 1:1:zipWith (+) fib (tail fib) in take 10 fib
08:52:42 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
08:53:16 <vincenz> Eelis: and that is lambdabot, including haskell interpreter, type information, google, as well as a haskell specific google named aptly hoogle
08:53:22 <vincenz> @hoogle a -> a -> a
08:53:23 <lambdabot> Prelude.asTypeOf :: a -> a -> a
08:53:23 <lambdabot> Prelude.const :: a -> b -> a
08:53:23 <lambdabot> Prelude.seq :: a -> b -> b
08:53:23 <Eelis> http://cvs.haskell.org/trac/ghc/ticket/715 <-- this ticket suggests that the compilation failure is due to OpenAL header versions being too old. do i really need to upgrade my OpenAL installation, or can i just instruct the build not to include OpenAL ?
08:53:33 <Eelis> vincenz: cute :)
08:54:07 <vincenz> @djinn a -> (a -> b) -> b
08:54:08 <lambdabot> f a b = b a
09:06:00 <tnks> I just saw an undergraduate's draft paper on-line that illustrated a technique of memoization using open recursion.  Is this a commonly known/employed technique?  It seems memoization in Haskell is pretty important and there are a few ways to do it.
09:06:33 <Eelis> hmm, i upgraded my OpenAL, but the problem remains. isn't there some way to instruct configure or make to skip the OpenAL library?
09:06:49 <ADEpt> Eelis: --help?
09:07:12 <Eelis> ADEpt: you're right, i should have checked first. i'm sorry
09:07:35 <tnks> wait a second.
09:07:44 <tnks> I think I misread the draft.
09:08:20 <tnks> I think open recursion is used for another purpose.  sorry about the confusin question.  Let me stare at this some more.
09:08:30 <vincenz> tnks: you mean something like this
09:08:57 <tnks> vincenz: http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf  (section 2.2)
09:09:00 <vincenz> > let myiterate f x = x:myiterate f (f x) in take 10 $ myiterate (*2) 1
09:09:01 <lambdabot> [1,2,4,8,16,32,64,128,256,512]
09:11:14 <tnks> I for the form of the fix-point operator's definition, so I forget how it evaluates lazily.
09:11:37 <tnks> s:/I for/I forget/
09:12:20 <vincenz> > let fix f = f (fix f) in fix (1:)
09:12:21 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
09:12:21 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
09:12:21 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
09:12:21 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
09:12:23 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
09:12:24 <vincenz> whoops
09:12:26 <lambdabot> [6 @more lines]
09:14:59 <deadbeef> hi there, excuseme
09:15:09 <deadbeef> i'm trying to generate a parser using "bnfc"
09:15:28 <deadbeef> but i can't get the difference between [], (:[]) and (:)
09:15:42 <deadbeef> [] is like empty list ?
09:15:57 <mauke> [] is the empty list
09:16:01 <deadbeef> (:[]) one element list, and (:)
09:16:08 <deadbeef> wait
09:16:10 <mauke> (:) is an operator/function
09:16:24 <mauke> it prepends something to an existing list
09:16:28 <vincenz> @type (:)
09:16:30 <lambdabot> forall a. a -> [a] -> [a]
09:16:33 <vincenz> @type (:[])
09:16:34 <lambdabot> forall a. a -> [a]
09:16:40 <vincenz> @type []
09:16:41 <lambdabot> forall a. [a]
09:16:44 <deadbeef> vincenz: consider i don't know haskell
09:16:58 <vincenz> deadbeef: (:) is used like element:tail
09:16:59 <deadbeef> i'm only using bnfc to make a c++ parser for a production system
09:17:08 * vincenz peers at deadbeef 
09:17:08 <deadbeef> ah, got it
09:17:10 <deadbeef> thanks
09:17:11 <mauke> what is bnfc?
09:17:18 <vincenz> deadbeef: parsing C++?
09:17:21 <vincenz> o.O
09:17:31 <deadbeef> parsing something similar to clips/jess
09:17:34 <deadbeef> in c++
09:17:36 <vincenz> oh
09:17:39 <vincenz> heh
09:17:47 <vincenz> c++ is pretty unparseable
09:17:59 <deadbeef> but it's like 2 days i'm trying to do something decent with bnfc
09:18:03 <vincenz> that explains the lack of good open source implementations
09:18:09 <vincenz> @google bnfc
09:18:10 <lambdabot> http://www.bnfc.nhs.uk/
09:18:21 <deadbeef> @google bnfc lbnf
09:18:23 <lambdabot> http://www.cs.chalmers.se/~markus/BNFC/
09:18:27 <deadbeef> it is
09:18:38 <vincenz> aha
09:18:52 <deadbeef> lbnf is a variant of BNF bnfc uses 
09:18:54 <vincenz> BNF -> (lexer,parser)
09:18:57 <deadbeef> yes
09:19:25 * vincenz sighs at the beauty of haskell, you can use types to clearly convey idea
09:20:12 <vincenz> ooh nice
09:20:15 <vincenz> it can use GLR
09:20:15 <sjanssen> vincenz: in the type you wrote, there needs to be more class constraints or the pair must contain bottoms
09:20:32 <sjanssen> BNF -> (Lexer, Parser), perhaps
09:20:39 <vincenz> oh right
09:20:42 <vincenz> capitalization
09:20:49 <vincenz> BNF -> (!Lexer, !Parser)
09:21:54 <deadbeef> but it doesn't allow me to do something like
09:22:02 <deadbeef> A ::= B*
09:22:36 <deadbeef> afaik it only allows to define lists
09:22:48 <deadbeef> but i didn't know haskell's syntax
09:22:56 * vincenz sighhs at his c++ code
09:23:09 <vincenz> there should be a haskell->c++ generator
09:23:54 <vincenz> makeTemplate $ do mapM_ createFunction [...]
09:24:42 <mahogny> compile to C?
09:24:58 <deadbeef> []. [Def] ::= ;
09:24:59 <deadbeef> (:). [Def] ::= Def ";" [Def] ;
09:25:04 <deadbeef> ^- how do i read this ?
09:25:49 <vincenz> it's taking the first ne
09:25:50 <psnl> deadbeef: is that supposed to be haskell, or what?
09:25:51 <vincenz> and then attacing the rest
09:25:54 <vincenz> psnl: BNF
09:25:58 <vincenz> [Def] ::= ;
09:26:01 <vincenz> make an empty list
09:26:02 * psnl hasn't been paying attention
09:26:03 <vincenz> => []
09:26:14 <vincenz> [Def] ::= Def ";" [Def];
09:26:20 <vincenz> => attach first:remaining
09:26:22 <vincenz> with (:)
09:26:27 * vincenz is just going on presumption
09:26:30 <vincenz> but that seems logical
09:26:41 <vincenz> http://www.cs.chalmers.se/~markus/BNFC/
09:26:56 <deadbeef> for example, i didn't get what have i to do
09:27:06 <deadbeef> to make something like A ::= B* 
09:27:10 <deadbeef> or A ::= B+
09:27:16 <deadbeef> using LBNF
09:27:48 <vincenz> read their docs?
09:27:58 <deadbeef> did it like 3-4 times
09:32:29 <deadbeef> maybe i could try with monomorphic lists
09:32:42 <deadbeef> something like
09:32:51 <deadbeef> A := B
09:33:04 <deadbeef> B :=
09:33:05 <deadbeef> B := B B
09:33:08 <deadbeef> or something
09:34:07 <vincenz> I fail to see why you have to specify haskell actions if you're making a c++ parser with it
09:34:45 <deadbeef> because bnfc is capable to generate .y and .l files (for bison and flex)
09:36:41 <vincenz> and if you read the docs
09:36:44 <ADEpt> what's the modern way nowadays to load non-latin1 data into Strings?
09:36:49 <vincenz> because you're then generating a c++ parser with lex and bison
09:36:53 <vincenz> you'll need to specify c++ actions
09:36:56 <vincenz> not haskell
09:37:09 <vincenz> http://www.cs.chalmers.se/~markus/BNFC/BNF_Converter_CPP_Mode.html
09:38:20 <deadbeef> yes i know
09:38:29 <deadbeef> i'll modify it then
09:39:48 <vincenz> Eelis: how's it going
09:40:21 <Eelis> just had dinner :) trying to find a list of package names that one can use with ./configure --without-PACKAGE
09:40:50 <Eelis> since i don't want to just guess the package name for OpenAL and risk compiling for an hour only to find that the name includes the path :)
09:42:23 <vincenz> dons: ping
09:42:29 <vincenz> @seen dcoutts 
09:42:29 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 1 day, 22 hours, 39 minutes and 24 seconds ago.
09:42:32 <vincenz> @seen dons 
09:42:32 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 6 hours, 52 minutes and 39 seconds ago.
09:42:41 <ndm> Eelis: i think it was --disable-openal
09:42:43 <deadbeef> damnit, i'm an idiot
09:42:49 <deadbeef> i can use regex in tokens
09:42:56 <ndm> and i needed --disable-<something else> as well
09:42:59 <vincenz> anyone here know if I can use FPS on multi-GB files?
09:43:07 <Eelis> ndm: i'll give that a try, thanks
09:44:07 <ndm> Eelis: http://www.mail-archive.com/haskell@haskell.org/msg18485.html
09:44:20 <ndm> --disable-alut seems to be needed by most people as well
09:45:23 <Eelis> i hope that's not too related to glut, which i intend to use
09:45:40 <vincenz> I think alut is the glut for audio
09:45:43 <vincenz> so most likely orthogonal
09:45:45 <Eelis> ah, ok
09:46:43 <vincenz> iirc someone redid those famous 3d tutorial examples with hopengl
09:46:48 <vincenz> the nehe ones
09:47:31 <vincenz> yep, Lemmih 
09:47:40 <Eelis> got a link?
09:47:49 <vincenz> don't know his new site, you might have to ask him
09:47:52 <vincenz> Lemmih: ping
09:47:52 <ndm> has anyone ever tried programming with Graph's and Haskell
09:48:12 <vincenz> ndm: yep
09:48:19 <ndm> vincenz: any tips?
09:48:27 <ndm> did you use the built in Data.Graph stuff?
09:48:31 <vincenz> eelis: http://darcs.haskell.org/~lemmih/aboutMe.html
09:48:34 <vincenz> ndm: indeed I did
09:48:43 <ndm> vincenz: successfully?
09:48:49 <vincenz> hmm damn, link seems to be incorrect
09:48:50 <vincenz> ndm: yep
09:49:14 <ndm> vincenz: ok, will take a shot at using that then
09:49:36 <vincenz> ndm: I admit, they aren't too well docced
09:49:49 <vincenz> but they're pretty good
09:50:12 <ndm> ok, thats nice to know - my graphs are probably going to get pretty complicated...
09:50:23 <ndm> is there a nice pretty printed output availabel for the graphs?
09:50:37 <vincenz> I doubt it
09:50:44 <vincenz> there's a whole area of research on that
09:50:46 <ndm> :(
09:50:55 <ndm> i konw
09:51:52 <vincenz> Eelis: http://darcs.haskell.org/~lemmih/haskellnehe/
09:52:10 <Eelis> vincenz: fantastic, thanks!
09:52:26 <vincenz> ndm: in addition, it's rather rendering related... if you're ging to cairo, to opengl...
09:52:35 <vincenz> ndm: so it wouldn't make much sense to be in Data.Graph
09:52:40 <Eelis> i plan to port my minesweeper 3d game to haskell. i'm sick and tired of gcc's crap C++ implementation
09:52:49 <vincenz> yeah don't tell me about it
09:52:59 * vincenz is sick about the maximum one type-conversion rule
09:53:20 <ndm> vincenz: SVG would be sufficient, or anything really
09:53:21 <Eelis> that's a language rule, not a compiler limitation, isn't it ? :)
09:53:34 <ndm> but i guess i can write a .dot file creator for GraphViz
09:53:36 <vincenz> Eelis: right, but who defined the rule? a group of compiler implementers
09:53:54 <Eelis> hehe
09:54:41 * vincenz continues on his copy of std::vector
09:54:53 <Eelis> how does it differ from std::vector ?
09:55:19 <vincenz> it adds profiling
09:55:30 <vincenz> highlevel profiling to be specific
09:55:42 <vincenz> it's a continuation of the stuff in my icME paper
09:55:43 <Eelis> as in: instrumentation that aids a profiling tool?
09:55:47 * vincenz nods
09:55:50 <Eelis> i see
09:55:52 <vincenz> well not quite
09:55:55 <vincenz> just plain profiling
09:56:01 <vincenz> but it's templatized and retargetable
09:56:17 <vincenz> vector<typename T, typename Logger>
09:56:31 <vincenz> , typename Allocator>
09:56:46 <Eelis> does it measure invocations and time spent and such, and write it to a Logger instance?
09:56:52 <vincenz> the thing is that you can't just wrap vector cause you also have to fix the iterators
09:56:58 <vincenz> it's not for timing but for data profiling
09:57:20 <vincenz> and because data profiling is very heavy
09:57:23 <vincenz> timing is rather useless
09:57:30 <Eelis> what kind of data profiling?
09:57:35 <vincenz> with my old variable profiler 
09:57:39 <vincenz> I'd get gigabytes of data
09:58:06 <vincenz> if it interests you, the variable profiling is described here http://www.notvincenz.com/wiki/uploads/Main/icme2006.pdf
09:58:17 <vincenz> as for the vector, basically I profile when I'm getting, when I'm duplicating, etc...
09:58:45 <Eelis> i'll have a look while ghc compiles :)
09:58:59 <Eelis> ndm: those two --disable switches seemed to have done the trick, thanks again
09:59:25 <ndm> no probs
10:07:30 <Eelis> hmm. i can't help but feel that the most appropriate place for profiling is in a profiling tool. the paper mentions gprof and valgrind's limitations, but it seems to me that those limitations would be better addressed by modifications to the tools rather than modifications to the source. of course, this is just my 5-minute completely unfounded layman opinion :)
10:07:40 <Maddas> vincenz: neat :)
10:09:25 <akemp> @seen SyntaxNinja
10:09:25 <lambdabot> I saw SyntaxNinja leaving #haskell 3 days, 19 hours, 50 minutes and 36 seconds ago, and .
10:09:26 <vincenz> Eelis: this paper was first sent to CGO (although then it was more of a 22 page paper and was more a library description) where it was rejected by a guy stating valgrind, so I tried to ellaborate on the limitations.  I'll admit that it's a minor scientific contribution, but it has helped us greatly with other things, such as custom DMMR stuff (papers about it can be found on the same site)
10:10:24 <vincenz> Eelis: and yes maybe it could be worked into valgrind, but atm it's not
10:10:30 <vincenz> tho it would prolly require a shitload of settings
10:10:45 <Eelis> at the very least it's a neat application of templates :)
10:10:47 <vincenz> on a positive note, because we use retargetable loggers, it could probably be tied into the valgrind freamework
10:10:59 <vincenz> Eelis: now you see why I bitch about the lack of the . operator overloading
10:11:27 <vincenz> Eelis: and in my world, the manual way of doing profiling is the defacto
10:11:31 <Eelis> yes, i do. you're trying to introduce a fully transparent wrapper, which is impossible in C++ because of things like the lack of an overloadable operator.
10:11:36 * vincenz nods
10:12:03 <vincenz> now for the vector profiling, it's less about the actual data
10:12:07 <vincenz> but more about the usage of vector
10:12:08 <vincenz> HOWEVER
10:12:12 <vincenz> and this is a cool thing
10:12:15 <vincenz> nothing stops you from doing
10:12:18 <vincenz> vector<var<T> >
10:12:51 <vincenz> except that you might get a few superflouous accesses due to the fact that vector also uses it's T for the parameters of methods
10:13:06 * vincenz originally ahd vector<T, IT>  suc that vector<var<T>, T>
10:13:16 <vincenz> but I stepped off of it as the actual accesses are of less interest atm
10:13:40 <vincenz> s/suc/such
10:15:07 <Eelis> i see
10:18:43 <vincenz> and, Maddas thx
10:20:15 <ADEpt> > map toUpper "¡¬◊"
10:20:16 <lambdabot> "\193\194\215"
10:20:33 <ADEpt> > putStrLn $ map toUpper "¡¬◊"
10:20:34 <lambdabot> No IO allowed
10:20:43 <ADEpt> > "¡¬◊"
10:20:45 <lambdabot> "\193\194\215"
10:20:51 <ADEpt> hmm
10:20:58 * vincenz just sees the little UTF <?>
10:21:10 <vincenz> > "√Ø¬ø¬Ω√Ø¬ø¬Ω√Ø¬ø¬Ω"
10:21:11 <lambdabot> "\195\175\194\191\194\189\195\175\194\191\194\189\195\175\194\191\194\189"
10:21:13 <vincenz> yep
10:21:15 <vincenz> my client is messed
10:21:20 <vincenz> that was a copy from Adept's line
10:21:38 <ADEpt> and my UTF8.hs is messed. Or my brain is messed.
10:22:10 <ADEpt> I cant seem to be able to get "proper" string from utf8-encoded file
10:22:26 <BCoppens> hmmm that's not really UTF-8 specific text, actually?
10:22:31 <ADEpt> (perhaps, shoudn't program after sleepless all-nighter :)
10:22:42 <ADEpt> BCoppens: no, not at all
10:23:43 <BCoppens> >"‚Ñï‚Ñö‚ìä‚ìù‚ìò‚ìí‚ìû‚ìì‚ìî"
10:23:52 <BCoppens> > "‚Ñï‚Ñö‚ìä‚ìù‚ìò‚ìí‚ìû‚ìì‚ìî"
10:23:52 <lambdabot>  lexical error in string/character literal
10:23:57 <BCoppens> bah
10:23:59 <ADEpt> vincenz: you have experience working with UTF8 (from any source)?
10:24:03 <vincenz> fraid not
10:24:17 <BCoppens> does haskell actually know UTF-8/Unicode?
10:24:27 <vincenz> > "NQ(U)(n)(i)(c)(o)(d)(e)"
10:24:27 <lambdabot> "NQ(U)(n)(i)(c)(o)(d)(e)"
10:24:32 <vincenz> why didn't that work for you BCoppens 
10:24:37 <vincenz> or am I just displaying wrong unicode?
10:24:50 <int-e> vincenz: you pasted ascii ...
10:24:55 * vincenz kicks his client
10:24:58 <BCoppens> vincenz: heh, that's cool, you converted my unicode chars to their ASCII representations :D
10:25:09 <vincenz> gnometerminal, screen and irrsi...now which one is the culprit?
10:25:16 <vincenz> BCoppens: that's how I saw it
10:25:22 <BCoppens> I'd say irrsi then :)
10:26:00 <vincenz> or ssh
10:26:11 <ADEpt> @seen dons
10:26:12 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 36 minutes and 18 seconds ago.
10:26:15 <vincenz> gnometerminal(ssh(screen(irssi)))
10:26:31 <BCoppens> well, could'nt it be that irrsi just is 'smart' and thinks nobody else understands utf8 ;)
10:26:54 <vincenz> BCoppens: I do sometimes get the litlte <?>
10:27:00 <BCoppens> ah odd then :)
10:27:07 <BCoppens> vincenz: http://www.bartcoppens.be/utf-8.png <- that's how it looks here ;)
10:27:25 <vincenz> BCoppens: what client?
10:27:32 <BCoppens> Konversation ;)
10:28:06 <BCoppens> but afaik xchat and co do unicode the same way
10:28:25 <vincenz> yeah but I never run irc locally, always on my desktop, so I can ssh to it from everywhere (read work)
10:28:47 <BCoppens> :-)
10:28:52 <BCoppens> maybe it's just an irrsi setting?
10:29:02 <thelsdj> vincenz: most likely screen/irssi together are wrong
10:29:09 <vincenz> :(
10:29:09 <thelsdj> i use the exact same setup, and works fine for me
10:29:20 <vincenz> irssi 0.8.10-rc5 (20040901 1719)
10:29:44 <thelsdj> vincenz: try this: http://jerakeen.org/blog/2005/06/23/screen-irssi-utf8/
10:31:18 <vincenz> it doesn't know term_type
10:31:27 <thelsdj> your irssi doesn't?
10:31:35 <vincenz> nope
10:31:48 <thelsdj> irssi 0.8.10 (20051211 0941)
10:32:22 <vincenz> type some unicode?
10:32:46 <BCoppens> ‚Ñï‚Ñö‚ìä‚ìù‚ìò‚ìí‚ìû‚ìì‚ìî
10:32:48 <thelsdj> ÁßÅ„ÅØ„Ç¢„ÉÄ„É†„Åß„Åô„ÄÇ
10:32:48 <BCoppens> ;)
10:32:50 <vincenz> wot!
10:32:55 <vincenz> ‚Ñï‚Ñö‚ìä‚ìù‚ìò‚ìí‚ìû‚ìì‚ìî
10:33:02 <BCoppens> \o/ :P
10:33:06 <vincenz> ./set term_charset utf-8
10:33:16 <BCoppens> heh :)
10:33:25 <vincenz> thanks thelsdj 
10:33:37 <BCoppens> ‚ò∫
10:33:40 <BCoppens> more appropriate ;)
10:33:47 <vincenz> how do you type unicode?
10:34:05 <BCoppens> wel, either using input methods (skim/scim), or a special character insertion thingie ;)
10:34:45 <BCoppens> like you can type japanese(Êó•Êú¨Ë™û) easily
10:35:19 <BCoppens> but for the fun characters just use a suitable kcharselect equivalent ;)
10:35:24 * vincenz nods
10:38:56 <lightstep> @seen igloo
10:38:56 <lambdabot> igloo is in #darcs, #haskell-overflow and #haskell. I last heard igloo speak 2 hours, 5 minutes and 1 second ago.
10:41:00 <lightstep> Igloo, are you the maintainer of debian's haskell packages?
10:41:40 <Igloo> Some of them, yes
10:42:13 <lightstep> version 1.6.0.1 of haskell-utils in debian depends on hugs
10:42:27 <lightstep> which is funny, since ghc6 depends on haskell-utils
10:45:42 <vincenz> \o/
10:45:50 <vincenz> C++ compile erros in all their beauty
10:46:15 <vincenz> http://rafb.net/paste/results/pCXLlQ93.html
10:47:23 <Igloo> lightstep: Yes, it uses hugs ATM
10:47:59 <BCoppens> vincenz: =)
10:54:44 <dieter> Hi. I want to use Haskell for computations over galois fields. I try to write a small library. In some funktions I need to know some values (the zero, and the one of a ring), which are constant for a given ring or galois field. How do I handle such values? 
10:54:56 <vincenz> dieter: define a Monoid
10:55:07 <vincenz> err...instantiate one
10:55:24 <vincenz> instance Monoid Mytype where
10:55:29 <vincenz>   mzero = ...
10:55:31 <vincenz>   msum = ...
10:55:49 <vincenz> oh wait... its a ring, well yes, define a typeclass
10:55:57 <vincenz> class Ring x where
10:56:00 <vincenz>   rzero :: x
10:56:04 <vincenz>    rone :: x
10:56:08 <vincenz> and the other opterations
10:56:09 <vincenz> then instantiate it
10:56:13 <vincenz> for different ring types
10:56:36 * vincenz thinks that there is a definite need of the expansion of mathematical typeclasses in the libs
10:57:44 <Eelis> yay, lemmih's lesson 2 example compiles and runs!
10:57:52 <vincenz> \o/
10:57:58 <vincenz> haskell is stable like that ;)
10:58:00 <Eelis> next challenge: using a glcanvas in gtk
10:58:10 <vincenz> have you looked at gtk2hs?
10:58:16 <Eelis> not yet
10:58:18 <vincenz> @where gtk2hs
10:58:19 <lambdabot> http://haskell.org/gtk2hs/
10:58:25 <vincenz> if you need help with it, lemme know
10:58:30 <Eelis> ok, will do
10:58:56 <Eelis> ah yes, i actually did stumble upon that url. looks good. i will also need the SVG cairo stuff i think
10:59:08 <Eelis> unless there is a haskell binding for librsvg
10:59:17 <vincenz> yep
10:59:21 <vincenz> there is cairo in gtk2hs
10:59:32 <Eelis> yeah that's what i was referring to
11:00:29 <vincenz> http://haskell.org/gtk2hs/archives/2006/03/24/debugging-red-black-trees/#comments
11:01:58 <dieter> Can I use the +, * from the Num class in my Ring class ?
11:02:21 <Eelis> uh-oh, gtk2hs does not seem to include a GL canvas widget
11:02:44 <int-e> Num is basically a ring (fromInteger 0 = zero, fromInteger 1 = one)
11:02:59 <dieter> I need a finite Ring
11:03:20 <vincenz> Eelis: I think it doe
11:03:37 <vincenz> dieter: it's best to define your own typeclass
11:03:48 <vincenz> xerox__: ping
11:03:51 <vincenz> dcoutts: ping
11:04:08 <vincenz> @hoogle gl
11:04:09 <lambdabot> Data.Generics.Schemes.glength :: GenericQ Int
11:04:09 <lambdabot> Language.Haskell.TH.global :: Name -> ExpQ
11:04:09 <lambdabot> System.Win32.Mem.globalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
11:04:20 <vincenz> oh wait, gtk2hs isn't yet in hoogle
11:05:14 <dieter> Can I use in my own typeclass infix-Funktion with the name + and *?
11:05:18 <vincenz> Eelis: http://darcs.haskell.org/gtk2hs/demo/opengl/RotatingCube.hs
11:05:45 <Eelis> vincenz: ah, that looks fantastic
11:06:30 <vincenz> I guess it's not yet in the docs
11:06:53 <Eelis> that's alright, i don't mind using experimental gizmo's
11:07:03 <vincenz> for the rest it's quite stable
11:07:05 <vincenz> ;)
11:07:18 <vincenz> dcoutts and xerox made it
11:07:47 <lightstep> dieter, yes, but you need to hide (+) and (*) of the Prelude
11:08:23 <dieter> that would mean, I cannot add to Integers anymore?
11:08:57 <Igloo> You could use the qualified name Prelude.+ etc
11:08:58 <lightstep> you can rename them, if you wish
11:09:05 <int-e> right. Unless you import the operators qualified - then you could write stuff like  1 Prelude.+ 2 ...
11:09:08 <int-e> (argh)
11:10:18 <dieter> So I can only choose if the addion of the ring elements looks ugly or the normal addion!?
11:10:48 <resiak> You could make the integers an instance of Ring, right? =)
11:11:38 <dieter> I hope I could 8).
11:13:20 <Igloo> If you want to use + with type a -> a -> a for some particular a then you can make that type an instance of Num
11:14:06 <int-e> Hmm, <+>, <->, <*> would look quite neat actually.
11:14:16 <dieter> I want to use + for any a.
11:15:31 <dieter> But if I make a an instance of Num, I have no acces to zero and one.
11:16:03 <int-e> hmm? fromInteger can be defined - it's the homomophism from integers into your ring, and gives you access to 0 and 1
11:16:38 <vincenz> ARRRRRRRRRRRRRRRRRRRRRRRRRGH
11:16:43 <int-e> you can even write 0 and 1 then
11:16:55 <dieter> If I make a an instance of Num and of Ring, I have ambiguous type variables in my code.
11:17:32 <Igloo> You aren't being clear enough for us to understand what you're trying to do
11:17:52 <int-e> vincenz: ? The only nasty thing about it is that there's no reasonable Ord instance for most rings.
11:18:07 <vincenz> int-e: not certain he needs Ord
11:18:08 <dieter> Yes, but then I need to know the modulo or the characteristic of the ring.
11:18:17 <vincenz> but my scream was about the lack of deriving(Show) in c+=
11:18:33 <int-e> vincenz: Oh. I misremembered that. Num only wants Eq and Show.
11:18:59 <int-e> vincenz: ah. please give more context when you scream :)
11:19:20 <dieter> Ok. What I trying to do is the following: I try to implement a finite ring or field.
11:19:39 <vincenz> int-e: this is the context: http://rafb.net/paste/results/r0OKEM66.html
11:19:44 <vincenz> now imagine about 20 or so more
11:19:54 <vincenz> and then having ot duplicate this for another logger which logs to custom binary format
11:20:04 <vincenz> cause my logfiles otherwise would range in the > 10GB range
11:20:08 <vincenz> erm> 100GB
11:20:53 <int-e> the thing that's nasty about using Num is that Num wants a signum and abs function. (but I wouldn't feel to bad about defining abs = error "arbitrary rings have no absolute value")
11:21:07 <xerox> @yow!
11:21:09 <dieter> So I need a structure in which I can describe Z/mZ and a Polynomring.
11:21:09 <lambdabot> My life is a patio of fun!
11:21:15 <vincenz> xerox: hi
11:21:25 <vincenz> xerox: is there a plan to add the GTk.GL stuff to the docs?
11:21:36 <xerox> vincenz - yes, sure.
11:22:49 <xerox> Did you check wether the current version has it documented?
11:23:17 <dieter> There are already some functions I need (gcd, sum, mod, div) and I do want to reimplement this functions for my ring structure.
11:23:35 <dieter> The is a not missing.
11:24:27 <int-e> you're out of luck for div and mod - they're part of the Integral class.
11:24:40 <vincenz> xerox: I did, there was a new haskeller that wanted to use gtk2hs and didn't find opengl, though I was certain it was in there, so I checked the demos, but it wasn't in the docs
11:24:53 <Eelis> (still here ;) )
11:26:17 <xerox> vincenz - patches are welcome =)
11:26:26 <vincenz> xerox: I would if I wasn't so busy :
11:26:29 <vincenz> :/
11:26:41 <vincenz> but aren't docs generated?
11:27:14 <dieter> Should I make I complete new class or use existing ones? I want a structure (R, 0, 1, +, *, /, -, mod, div, gcd, sum)
11:27:43 <vincenz> dieter: erm... isn't GCD a derivative thing
11:27:48 <vincenz> as well as sum
11:27:53 <xerox> vincenz - yes, they are generated from comments in the code, through Haddock.
11:28:09 <vincenz> xerox: so in that case, at least the plain docs with no comments should be generated for the gl bit, no/
11:28:14 <int-e> @type gcd
11:28:16 <lambdabot> forall a. (Integral a) => a -> a -> a
11:28:25 <xerox> vincenz - haddock parses the Haskell modules' sources.
11:28:31 <vincenz> what I meant is, it sholdn't go in the typeclasses
11:28:36 <int-e> it's built from mod
11:28:37 <vincenz> /classes/class
11:28:44 <int-e> vincenz: right
11:29:06 <vincenz> but yeah, Integral combines too much, the mathematical stuff in haskell should really be orthogonalized more
11:29:10 <dieter> How can I use the builtin gcd?
11:29:18 <xerox> Number Theory is fun!
11:29:24 <dieter> Yes!
11:29:29 <vincenz> dieter: well if you make your own typeclass, you can't, but the algo is straightforward
11:29:29 <int-e> dieter: I think it makes sense to use the Num (for 0, 1, +, -, *) and Integral (for div and mod) classes.
11:29:53 <vincenz> and just give bs implementations for abs?
11:29:58 <int-e> dieter: and if you do that, you can use the builtin gcd, because that uses mod from the Integral class.
11:30:00 <dieter> How do I use Num for 0 and 1?
11:30:02 <int-e> vincenz: yes
11:30:12 <vincenz> dieter: define fromIntegral
11:30:19 <vincenz> or fromInteger
11:30:20 <vincenz> can't remember now
11:30:27 <vincenz> @hoogle (Integral a) => Int -> a
11:30:28 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
11:30:28 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
11:30:28 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
11:30:29 <int-e> dieter: fromInteger 0 = 0, fromInteger 1 = 1
11:30:38 <vincenz> @type fromInteger
11:30:39 <lambdabot> forall a. (Num a) => Integer -> a
11:31:02 <vincenz> dieter: maybe start with the basics
11:31:05 <vincenz> dieter: what's the type of  your elements
11:31:47 <int-e> dieter: and, because the literals 0 and 1 are actually translated to (fromInteger 0) and (fromInteger 1), you can use them directly in your code.
11:31:54 <dieter> If a have a Ring where the one is (K 1 23) and the zero is (K 0 23) and an other time a have a ring where the one is (K 1 X^2+X+1) and the zero (K 0 X^2+X+1), how can a define formInteger then?
11:32:09 <vincenz> fromInteger 0 = K 0 23
11:32:13 <vincenz> fromInteger 1 = K 1 23
11:32:39 <dieter> So I have to redefine for every Ring the one and the zero?
11:33:06 <xerox> dieter - you define a different datatype for each ring, and instantiate it.
11:33:48 <dieter> And then another one, for ring of a ring?
11:35:05 <xerox> Yup.
11:36:26 <xerox> Mumble, maybe if you have a class Ring r, then you could do instance (Ring r) => Integral r ?
11:36:48 <xerox> I am not sure.
11:44:32 <int-e> xerox: not really. consider the ring generated by 1 and pi; you can't define div for that (there are approximations to 1/pi as close as you like but it has no exact representation).
11:45:15 <dieter> I want to work with algebraic numbers.
11:46:06 <xerox> int-e - aside from that, can one provide such a general instance?
11:46:23 <dieter> If a have a rings of the form Z/mZ and R[X] and R[X]/(f) and rings of this rings, then I will be happy.
11:46:34 <int-e> xerox: sure. div = undefined, mod = undefined ... *grins foolishly*
11:46:49 * xerox launches pointy lambdas to int-e
11:47:39 <int-e> xerox: I could have written 'no', but where'd be the fun in that?
11:48:19 <xerox> int-e - stay still or I'll hit you! *swing*
11:48:39 <dieter> My mean intrest is in the finite fields (or galois fields). So I need the rings of the form R[X]/(f) and the rings (R[X]/(f))[Y]
11:48:40 * int-e dodges xerox 
11:49:13 <dieter> where R is a ring of Z/mZ.
11:50:48 <isaacd> GHC doesn't seem to like lines starting with # in .lhs files ("lexical error") -- why not, Hugs and the Report allow them...
11:50:49 <int-e> dieter: Z/mZ is hard if you don't want to define individual types for each ring; you can save that work with some type trickery (where you encode integers as types ... I've lost the references to that though, unfortunately.).
11:51:30 <vincenz> Eelis: how's it going
11:54:07 <ndm> isaacd: you aren't allowed tehm at the top
11:54:35 <isaacd> ndm: why not?
11:54:50 <ndm> isaacd: there was a reason, but i can't remember it now :)
11:55:07 <ndm> possibly to do with #PRAGMA directives
11:55:21 <isaacd> maybe so that it's compatible with using C pre-processor on the file?
11:55:28 <isaacd> even though it's not being used on it
11:55:46 <ndm> i doubt it, shouldn't matter unless -ffi is specified
11:55:51 <ndm> * -cpp
11:59:27 <int-e> dieter: http://okmij.org/ftp/Haskell/number-parameterized-types.html  demonstrates the technique.
12:03:41 <dieter> int-e: thanks.
12:08:57 <dieter> Can I define a class, which derives the function +, * from Num?
12:10:34 <xerox> dieter - if you want to constraint your class members to members of the Num class, write |class (Num a) => Foo a where ...|.
12:11:54 <vincenz> Anyone know how to generate an overview of repos
12:11:57 <int-e> You'd define a type   Nat i => Ring i (where Nat is the type class that encodes the numbers; Nat has a member nat :: Integer) and then a Num instance for Ring i.
12:12:03 <vincenz> like this http://neugierig.org/software/darcs/browse/
12:13:56 <xerox> int-e - are you suggesting to define Nat or some i?
12:14:52 <int-e> give me a moment, I'll see if I can hack this together in a few minutes.
12:15:04 <xerox> No hurry.
12:15:13 <xerox> Pizza!  ~~
12:15:56 <jethr0> http://auriga.wearlab.de/~alb/darcsweb/
12:16:03 <jethr0> *vincenz:
12:18:22 <hyrax42> jethr0: cool :)
12:18:22 <hyrax42> thanks
12:18:32 <hyrax42> (and on vincenz's behalf :p)
12:20:18 <dieter> If a define: class Num a => Ring a where ... could I overload the function + for all instances of Ring?
12:20:47 <jethr0> welcome
12:21:06 <vincenz> jethr0: yeah found it, any clues on how to config i
12:21:10 <vincenz> documentation = sparse
12:22:30 <sjanssen> dieter: not exactly
12:23:37 <sjanssen> dieter: you want to have a + operator that works on Rings?
12:23:49 <dieter> sjanssen: yes.
12:24:46 <sjanssen> do you understand that classes in Haskell are entirely different from classes in OO languages?
12:25:01 <dieter> No.
12:25:12 <sjanssen> okay, they are
12:25:45 <jethr0> vincenz: not really, i just googled it for you ^_^
12:25:51 <vincenz> ;)
12:27:51 <sjanssen> dieter: the class definition you gave above should work, but you define (+) inside the Num instance, not the Ring instance
12:28:12 <vincenz> anyone a apache expert?
12:28:17 <vincenz> how do I tell apache that in directory /browse
12:28:25 <vincenz> I want it to automatically show some cgi script
12:28:27 <vincenz> err..execute it
12:28:45 <sjanssen> dieter: does Ring have more operations than Num does?
12:28:47 <jethr0> vincenz: you can set the index page to some cgi script
12:29:04 <sjanssen> alternatively, does Num contain operations that a Ring can't do?
12:29:05 <vincenz> how do I do that?
12:29:14 <jethr0> DirectoryIndex index.html index.php
12:29:27 <dieter> sjanssen: No, but they have constants.
12:29:38 <jethr0> vincenz: i hope that helps, gotta go
12:29:52 <vincenz> jethr0: that did it, except it's not executing :/
12:29:55 <dieter> sjanssen: sorry, the have also the functions div and mod.
12:30:59 <sjanssen> dieter: have you looked at the Integral class?
12:31:34 <dieter> sjanssen: my main problem is the constants.
12:31:40 <vincenz> \o/
12:32:43 <sjanssen> class (Integral r) => Ring r where theConstant :: r -- how about this?
12:32:59 <sjanssen> rings have a 1 and a 0, right?
12:33:09 * sjanssen doesn't know abstract algebra
12:33:12 <dieter> I want to modify the functions in dependence to the constants. But the are diffrent for diffrent rings.
12:33:37 <dieter> Yes, rings have a 1 and a 0. But that ist just a name.
12:34:47 <sjanssen> dieter: you can also overload the behavior of fromInteger in the Num class, such that when you write a literal '1' in your program, it turns into the corresponding value in your ring
12:38:28 <dieter> sjanssen: there will remain a constant for the modulo, if the ring is finite.
12:39:04 <sjanssen> ah, then you need a ring class like I proposed above
12:39:56 <sjanssen> if you're worried about operations in a Num instance depending on constants in a Ring instance, you don't have to.  Haskell can handle that
12:40:15 <dieter> But I do not want to write the function sum, and gcd, etc. again. Can I use the existing ones?
12:40:25 <sjanssen> yep
12:40:42 <sjanssen> sum uses your definition of (+)
12:41:06 <dieter> And does not terminate ... .
12:41:24 <dieter> In my momentan implementation.
12:41:30 <sjanssen> you're summing an infinite list?
12:41:36 <dieter> No.
12:42:07 <dieter> It a problem with the constants.
12:42:13 <dieter> With 0.
12:42:31 <sjanssen> can you paste it somewhere?
12:43:33 <The_thing> http://www.ssrc.org/wiki/POSA/index.php?title=Main_Page
12:43:33 <sjanssen> it's probably something simple, a computation is accidentally cyclic, perhaps
12:43:35 <The_thing> Please?
12:43:36 <The_thing> http://www.ssrc.org/wiki/POSA/index.php?title=Main_Page
12:43:43 <The_thing> PLEASE???
12:44:07 <sjanssen> The_thing: hmm?
12:44:16 <The_thing> Hi
12:45:13 <dieter> Perhaps.
12:45:32 <sjanssen> @fptools
12:45:32 <lambdabot>  not available
12:45:39 <sjanssen> @fptools Data.List
12:45:39 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:45:56 <dieter> I will think about it, and then I will come again.
12:46:36 <vincenz> woo
12:46:40 <vincenz> streams is an impressive li
12:46:41 <vincenz> lib
12:46:57 <sjanssen> vincenz: you're talking about Bulat's lib?
12:47:03 <vincenz> yep
12:47:14 <sjanssen> what's impressive about it?
12:47:19 <vincenz> the clean modularity
12:47:26 <int-e> @paste
12:47:27 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:47:32 <vincenz> @pastebin
12:47:32 <lambdabot> Unknown command, try @list
12:47:37 <vincenz> http://rafb.net/paste
12:47:49 <sjanssen> we should have @paste give the URL for lisppaste
12:48:01 <vincenz> @where+ paste http://rafb.net/paste
12:48:02 <lambdabot> Done.
12:48:03 <sjanssen> it's much better than a wiki page
12:48:03 <vincenz> @where paste
12:48:04 <lambdabot> http://rafb.net/paste
12:48:24 <lisppaste2> int-e pasted "Z/mZ implementation" at http://paste.lisp.org/display/20241
12:49:05 <vincenz> int-e: what is this
12:49:06 <vincenz> data Nat m => Ring m = Value Integer deriving (Show, Eq)
12:49:21 <int-e> vincenz: a Z/mZ :)
12:49:32 <int-e> (Ok, Ring is too generic a name.)
12:49:34 <vincenz> nono
12:49:36 <vincenz> I don't get the
12:49:40 <vincenz> data Nata m =>
12:49:46 <vincenz> shouldn't it be
12:49:48 <int-e> Nat is a type class, defined above
12:49:48 <vincenz> (Nat m) =>
12:50:03 <vincenz> oh wait... the data belongs the Ring after
12:50:06 <vincenz> nasty syntax
12:50:20 <vincenz> it almomst looks like data Nat m
12:50:27 <vincenz> and then you see the => and your context becomes undefined
12:50:42 <vincenz> :D
12:50:50 <int-e> Hmm. You can get used to that.
12:51:09 <int-e> It's not like the information becomes irrelevant out of sudden.
12:51:16 <vincenz> int-e: btw...
12:51:18 <vincenz> why not just pass on the arg
12:51:23 <vincenz> nat x = 2 * nat x
12:51:32 <vincenz> oh wait nm
12:51:35 * vincenz shuts up
12:51:38 <int-e> vincenz: because it has the wrong type :)
12:51:41 <vincenz> yeah
12:51:46 <vincenz> nat (Twice x) => 
12:51:47 <int-e> vincenz: but you have a point
12:51:54 <int-e> vincenz: right, I could do that.
12:52:05 <int-e> vincenz: but I wanted to be able to pass undefined of the right type.
12:52:21 <int-e> vincenz: it is, after all, just a dummy argument.
12:52:22 <sjanssen> Twice and Succ could also be newtypes
12:52:23 <vincenz> yeah...cause you know how undefined has a zillion types
12:52:27 <vincenz> :D
12:52:38 <int-e> sjanssen: hmm. let me try that
12:52:53 <vincenz> sjanssen: what does that change?
12:53:04 <int-e> sjanssen: right, that works (nasty)
12:53:19 <vincenz> heh
12:53:24 <vincenz> that spammier from before actually had a useful page
12:53:26 <vincenz> silly idiot
12:53:28 <sjanssen> vincenz: it guarantees that you don't waste a bunch of memory in the Succ structures
12:53:32 <vincenz> sjanssen: aha
12:53:43 <sjanssen> only Zero will exist at runtime
12:53:43 <vincenz> cause only brainless people Succ
12:53:55 * vincenz coughs
12:54:01 <int-e> sjanssen: yes, newtype is better
12:54:33 <lisppaste2> int-e annotated #20241 with "newtype is better :)" at http://paste.lisp.org/display/20241#1
13:12:14 <lisppaste2> int-e annotated #20241 with "[Z/mZ] different encoding for the numbers" at http://paste.lisp.org/display/20241#2
13:19:36 <int-e> actually, Ring can be made a newtype as well.
13:25:07 <lisppaste2> dieter annotated #20241 with "Ring implementation" at http://paste.lisp.org/display/20241#3
13:26:24 <dieter> Now I do not really know how to continue.
13:33:20 <int-e> A short note on the code I pasted: This really defines a whole bunch of types for the various Z/mZ rings. The type for Z/23Z is really Ring (B1 (B0 (B1 (B1 (B1 Bin))))) (note that 23 = 10111b)
13:35:58 <int-e> Dieter: if you want Num and Integral instances (to use sum, ^, gcd, and maybe other stuff) and not define a newtype for every single ring you ever encounter, I think you have to do something similar to what I did :/
13:37:30 <sjanssen> @ttow
13:37:31 <lambdabot> Has everybody got HALVAH spread all over their ANKLES??
13:37:51 <mathewm> ack
13:42:24 <dieter> Ok, I think I will define a new datatype for every single ring.
13:42:44 <dieter> But I cannot work with the constants.
13:44:01 <lisppaste2> dieter annotated #20241 with "Ring" at http://paste.lisp.org/display/20241#4
13:44:28 <dieter> ghci say Ambiguous type variable.
13:44:51 <dieter> ... arising from use of `rmodul'
13:46:45 <maus> hi, all
13:46:47 <int-e> rmodul==rzero
13:47:00 <int-e> <-- which type should that rmodul and rzero have?
13:47:59 <dieter> The type of a.
13:48:14 <maus> does anybody know, is it possible to accept raw volumes using openBinaryFile on Win32 or one have to use CreateFile directly?
13:48:33 <int-e> dieter: it can't know that :)
13:48:50 <dieter> how let I know him?
13:48:54 <int-e> addRing (b :: t) c | (rmodul :: t)==rzero = b+c
13:48:57 <int-e> probably.
13:49:21 <xerox> Wee, publish this code thereafter, okay? (:
13:50:14 <dieter> It seems that it is no standard, I have to use -fglasgow-exts.
13:50:38 <dieter> xerox: do you mean me?
13:50:46 <xerox> Yes.
13:50:53 <int-e> right. the standard way needs dummy functions and arguments.
13:51:22 <dieter> What are dummy functions?
13:51:33 <int-e> you could make a function equal_type :: a -> a -> a; equal_type _ a = a; and then use   addRing b c | equal_type b rmodul == rzero
13:51:58 <dieter> Ok.
13:52:03 <int-e> functions that don't actually do anything besides helping the type checker.
13:52:49 <xerox> We want type (in)equality!
13:52:58 <dieter> :r
13:53:06 <dieter> sorry, wrong buffer.
13:53:55 <xerox> ...and dependent types, to finally reach the farthest vertex of the lambda cube!
13:54:13 <dieter> It seems to work, thank you.
13:54:24 <jethr0> *aaaahhhh* lambda cube ^_^
13:54:37 <Philippa_> doing that the "obvious" way'd lead to a non-terminating typechecker
13:54:51 * vincenz pokes Philippa_ 
13:54:53 <Philippa_> the Calculus of Constructions only typechecks OK because terms're guaranteed to terminate anyway
13:54:56 <Philippa_> 'lo vincenz
13:55:03 <vincenz> hello 
13:55:16 <Philippa_> am just reading LtU and noticing I may be getting a reputation away from IRC :-)
13:55:25 <vincenz> oh, hows that?
13:55:30 <vincenz> I haven't read LTu lately
13:56:24 <Philippa_> oh, just somebody commenting on something I wrote having realised I'm the one who wrote the Impure Thoughts column
13:56:38 <xerox> ``Ah ... you're the one who wrote that article for the Monad.Reader. 'Nuff said.''
13:56:45 <xerox> /that/
13:57:27 <Philippa_> yeah
13:58:31 <int-e> wee.    print $ (equal_type (ring_type $ B1 $ B0 $ B1 $ B1 $ B1 Bin) 10^1000000000)
13:58:39 <int-e> --> Value 16
13:58:53 * vincenz peers at int-e 
13:58:55 <vincenz> what are you doing
13:59:05 <int-e> where ring_type :: Nat m => m -> Ring m; ring_type _ = undefined
13:59:15 <int-e> vincenz: writing type annotations as expressions
13:59:25 <vincenz> int-e: got a sample
13:59:30 <Philippa_> vincenz: were you poking me for any particular reason?
13:59:35 <vincenz> Philippa_: to say hello
13:59:48 <Philippa_> :-) Fair enough, just wondering if you wanted me for anything
13:59:58 <vincenz> nah, I don't poke repeatedly unless I'm intimate with someone
14:00:31 <vincenz> blegh, that was bad
14:01:52 <Eelis> vincenz: i watched a movie :) in reply to your 20:51 inquiry: i compiled and installed gtk2h, but when i try to compile the rotating cube example ghc is unable to find the module. i'm trying to find out whether i need to add module paths or something
14:03:17 <xerox> Eelis - I think you shouhd use either `-package gtk2hs', or `--make', or Cabal (:
14:03:54 <Eelis> xerox: i'm using the makefile provided with the rotating cube example, which invokes ghc with --make
14:04:15 <xerox> Ah!  What does GHC not find exactly?
14:04:29 <Eelis> "Could not find module `Graphics.UI.Gtk.OpenGL'"
14:05:00 <xerox> I am not sure wether this is installed as a separate package or not.  Does `ghc-pkg list' show up something sensible?
14:05:36 <Eelis> it doesn't show any gtk packages
14:05:52 <xerox> That's not good.  Did you perform a `make install' ?
14:06:14 <Eelis> yes, i did. i now have a /usr/local/lib/ghc-6.4.2 as well as a /usr/local/lib/gtk2hs
14:06:43 <xerox> Maybe try again and watch carefully when he does register the packages.
14:07:11 <xerox> It could also help checking what packages it has built, if you didn't specify explicitly them in the configure's command line.
14:07:17 <Eelis> should there really be two separate directories? shouldn't files like HSgtk.o end up in /usr/local/lib/ghc-6.4.2 ?
14:07:36 <xerox> Separate directories for packages are okay.
14:07:48 <xerox> Well, as long as those are registered.
14:08:12 <xerox> IIRC there is a `register' targed in Gtk2Hs Makefile.  I am not sure.
14:08:19 <xerox> target, even.
14:08:19 <Eelis> i'll try
14:08:45 <Eelis> nope, "No rule to make target `register'."
14:09:17 <xerox> `make install' should do it.
14:09:32 <xerox> Would you care to do it and paste the result on the pastebin?
14:09:50 <Eelis> hmm, i have a theory. give me a minute
14:10:54 <vincenz> Eelis: woo.. .a minute to publish a paper on a theory?
14:16:07 <Eelis> i think it got confused by the presence of the original binary ghc that i used to compile ghc with. after cleaning up a bit "ghc-pkg list" now does show the gtk package, but the "Could not find module `Graphics.UI.Gtk.OpenGL'" error is still there
14:16:25 <Eelis> that is, after cleaning up a bit and rerunning gtk2h's make install
14:17:00 <Eelis> perhaps i ought to reconfigure and compile the whole thing to make sure it isn't still partially confused
14:17:46 <Eelis> in retrospect i should have done an in-place installation of the binary package
14:18:27 <Eelis> i'll have another go at it tomorrow, i've run out of time for today
14:18:39 <Eelis> xerox, vincenz: thanks for your help
14:30:01 * mahogny got an exam tomorrow in solid mechanics. he's a bit tempted to use lambda calculus for notation. he will be shot on sight >_<
14:30:34 <stepcut> :p
14:31:06 <mahogny> well, I have always wanted a nice notation for partial application...
14:32:23 <xerox> Do so!
14:33:09 <mahogny> I might if I see that it will go bad anyway ;)
14:33:43 <mahogny> I can kind of see his face when he figure "a b" doesn't mean a times b...
14:34:06 <mahogny> hm. and then put in a $ somewhere in there
14:34:38 <mahogny> answer <- integrate 0 10 $ (\x -> x*x)
14:35:00 <mahogny> return the answer as a collection of formers, and be lazy and let the teacher insert all values and compute? :)
14:35:08 <mahogny> *formulas
14:36:01 <int-e> teachers prefer eager evaluation though.
14:36:16 <mahogny> yeah. they are so unmodern :(
14:37:10 <xerox> Show them your genius!
14:37:25 <mahogny> yeah. and they me my F :)
14:37:35 <mahogny> +show
14:41:10 <vincenz> Eelis: welcome
14:41:22 * vincenz is reading a book he bought this weekend "Prefactoring"
14:41:24 <vincenz> it's rather appalling
14:41:42 <vincenz> I think that strong typing and a rich typing system can remove a lot of validation needs
14:42:39 <mahogny> I'm doubting that, but it makes validation 1000% easier
14:45:15 <stepcut> 'F' for 'Functional' right ?
14:45:33 <mahogny> lol
14:45:55 <mahogny> yeah. I'm gonna tell that if I ever apply for a job at Galois. "look! I got Functional in all these courses!"
14:46:17 * vincenz snickers
14:47:31 <Philippa_> vincenz: I think they'll remove a lot of 'internal' validation, yeah. More importantly, the rest of the time they'll make you validate when you need to
14:47:40 <vincenz> yup
14:47:44 <Philippa_> that was one of the things that struck me about Epigram. It very much does that
14:47:59 <vincenz> well so does haskell
14:48:07 <vincenz> w.r.t. pruthon
14:48:16 <Philippa_> "pruthon"?
14:48:21 <mahogny> pruthon is evil
14:48:22 <vincenz> perl ruby python
14:48:25 <Philippa_> ah
14:48:39 <vincenz> Philippa_: out of curiousity, where do you know all your type-fu from
14:48:43 <mahogny> I would have used python any day over java if it wasn't for the type system
14:48:45 <Philippa_> Haskell improves a bit, but really it only encourages you. Epigram really does *make* you do it
14:48:57 <basti_> philippa fell into the type cauldron when she was young.
14:48:59 <vincenz> is that the one with vertical types?
14:48:59 <Philippa_> much background reading. TaPL and ATTaPL've been good
14:49:07 <vincenz> CS studies?
14:49:28 * vincenz sometimess feels the lack of CS studies :/
14:49:41 * jethr0 thinks epigram could improve a little in real world usability (without ever having used it *cough*). but generally i like the idea *a lot*
14:49:50 * vincenz has an ee degree
14:49:53 <Philippa_> "vertical"? The main thing about epigram is it's dependantly typed and interactive. If you didn't validate at all (get the types to match), it throws an error. If you only included the path for passing validation, it lets you know you don't have a complete function
14:50:19 * vincenz remembers some language where type annotations wehre multiline
14:50:24 <vincenz> aka, textual diagrams
14:50:30 <vincenz> pretty sure it was epigram
14:50:32 <Philippa_> I learnt very little type-fu on my degree. The degree pointed me at Haskell and Haskell at various extensions though, and when I started playing with some simple possible extensions I started reading around
14:50:36 <jethr0> but i guess "usability" is what people complain about wrt haskell, so maybe i shouldn't adopt that tone :)
14:50:40 <Philippa_> Epigram can have type annotations like that, yeah
14:50:48 <mahogny> multiline... reminds me of JIF, horrible types and it still falls short
14:51:16 <Philippa_> jethr0: FCVO "usability" Epigram is a huge leap over previous languages
14:51:22 <vincenz> My main issue with Type-theoretic papers and documents is that I never really learned how to do proofs and sometims I'm like "yes these small steps are so obvious, why do they do it, but when they have something like "proof xyz" I get stuck"
14:51:23 <Philippa_> bear in mind it's a research vehicle
14:51:35 <vincenz> maybe we can use Redner ()
14:51:36 <Philippa_> yeah, I tend to skip a lot of the proofs. This is bad of me
14:51:39 <vincenz> Render () -> Type
14:51:40 <jethr0> Philippa_: afaik writing complex programs isn't yet possible in epigram, right?
14:51:52 <Philippa_> jethr0: writing programs that do IO isn't. Not the same thing
14:51:54 <vincenz> and have cairo instructions that draw a type
14:52:08 <Philippa_> they could get haskell-level IO easily, it's being able to reason about IO that they're working on
14:52:33 <jethr0> Philippa_: hmm, from reading the papers i thought that there were still limitations of the prooving mechanisms. but i must admit i haven't delved very deeply *blushes*
14:52:37 <vincenz> so is epigram the holy grail of static typing with inference?
14:53:30 <zimbatm> hello
14:53:39 <Korollary> hello
14:53:55 * vincenz looks at the addition code on wikipedia "That can never become efficient"
14:53:58 <Philippa_> jethr0: there're quirks, but you could do Real Code (tm) in it. It's true that the language isn't turing complete at the mo
14:53:58 <vincenz> http://en.wikipedia.org/wiki/Epigram_programming_language
14:54:05 <vincenz> unless they use rule-based optimization
14:54:06 <zimbatm> i'm trying to learn haskell but it's really far from procedural programming
14:54:07 <vincenz> which imo is limited
14:54:20 <Philippa_> however, you don't need general recursion a lot of the time, especially away from IO - most non-terminating apps are doing an IO loop
14:54:23 <zimbatm> are you all really good in math ?
14:54:41 <vincenz> not as good as the people in #math
14:54:45 <Philippa_> most of us are "mathematically minded", but that's not the same thing
14:54:49 <Korollary> zimbatm: many of us are, but it's not that necessary.
14:55:02 <Philippa_> vincenz: add a CPU-implemented integer type, what else is new?
14:55:02 <vincenz> Korollary: except when doing a checking of your savings account
14:55:14 <vincenz> touche
14:55:14 <Korollary> vincenz: I don't check my accounts.
14:55:25 <Philippa_> it's also known how to map a Nat = Zero | Succ Nat type onto CPU integers while preserving pattern-matching
14:55:31 <vincenz> ah
14:55:32 <vincenz> neat
14:55:32 <zimbatm> i see lot of mathematic like explanations in the turorials
14:55:43 <Philippa_> theoretically, some really sick things could be done with optimising list storage in Haskell
14:55:49 <zimbatm> i wish i had listen more in my methematic lessons :-p
14:55:54 <vincenz> Philippa_: yep
14:56:00 <Philippa_> zimbatm: yeah, a lot of haskell's better tricks are derived from mathematics
14:56:02 <vincenz> Philippa_: deforestation taken to the extreme
14:56:14 <Philippa_> vincenz: right, who needs to store the constructors if the list length is known?
14:56:25 <vincenz> ah worst-case analysis
14:56:28 <vincenz> erm, bounds
14:56:40 <vincenz> afaik for c they do it
14:56:47 <vincenz> while haskell, imo, is much easier to optimize
14:56:51 <vincenz> given it's clean semantics and typing system
14:56:58 <Philippa_> zimbatm: what kinds of things're causing you problems?
14:57:09 <vincenz> but yeah the world of optimization and haskell is disjoin :/
14:57:16 <Philippa_> vincenz: yep. Which reminds me, I've some thinking to do about impredicativity, type classes and optimisation
14:57:31 <vincenz> Philippa_: meaning?
14:57:42 <jethr0> vincenz: i don't find optimization in haskell so easy. you have to know a LOT of the runtime and GC behaviour to know where your leaks are...
14:57:43 <Philippa_> there's a strict/lazy divide that's pretty serious there, but the ML crowd've looked at it in depth
14:57:51 <vincenz> what I don't get is why they stick to oo-style solutions
14:57:53 <vincenz> for typeclasses
14:58:11 <zimbatm> Philippa_: i'm just reading the hitchiker's tutorial but many things still are obscure to me
14:58:14 <Philippa_> it's the "most natural" solution. The main alternative's what jhc does
14:58:22 * vincenz is missing context
14:58:24 <Philippa_> zimbatm: ah. Don't think I've read that tutorial
14:58:36 <vincenz> zimbatm: tbh my fave tutorial was YAHT
14:58:40 <jethr0> zimbatm: anything specific we can help with
14:58:41 <vincenz> I found it great
14:58:41 <jethr0> ?
14:58:50 <Philippa_> JHC passes a typeid around with values instead of a dictionary. Often it optimises the typeids out or coalesces a lot of the branching outwards
14:58:57 <zimbatm> vincenz: do you have a link ?
14:59:01 <vincenz> Philippa_: which makes sense
14:59:08 <Philippa_> yep
14:59:25 <vincenz> if you want to suffer the code-bload
14:59:27 <jethr0> @google yet another haskell tutorial
14:59:29 <lambdabot> http://www.isi.edu/~hdaume/htut/
14:59:30 <vincenz> you could just instantiate everything
14:59:34 <vincenz> like templates
14:59:36 <Philippa_> yep
14:59:40 <zimbatm> thx
14:59:41 <zimbatm> brb
14:59:43 <Philippa_> there's a semantics for Standard ML that does exactly that
14:59:54 <vincenz> why is this an issue for SML?
14:59:57 <vincenz> they don't ahve typeclasses
15:00:06 <vincenz> and afaik functors are done in the template way
15:00:08 <Philippa_> they do have parametric polymorphism though
15:00:16 * vincenz ponders
15:00:17 <vincenz> SML?
15:00:21 <vincenz> in what form
15:00:25 <sjanssen> the typeid approach doesn't seem much different from the dictionary approach to me.  You can optimize dictionaries out with specialisation and inlining
15:00:28 <Philippa_> and one semantics for it is to effectively build a new module for each type
15:00:54 <Philippa_> sjanssen: it puts a 'name' to the dictionary, which is relevant for JHC's other optimisations
15:01:30 <vincenz> I think with some good heuristics you should be able to choose
15:01:34 <Philippa_> also, typeid scales better when you need multiple instances
15:02:02 <vincenz> what's the diff?
15:02:05 <sjanssen> vincenz: GHC already has such heuristics
15:02:09 <vincenz> sjanssen: neat
15:02:17 <vincenz> like
15:02:27 <vincenz> class Stupid a where
15:02:34 <vincenz>   succ :: a -> Succ a
15:02:39 <vincenz> instance 1..1000
15:02:52 <Philippa_> nah, I mean instances for different (non-related) classes
15:02:55 <vincenz> instance (Stupid a) => (Stupid (Succ a))
15:03:13 <Philippa_> with dictionaries, you pass a dictionary for each one. With typeid, you still only pass the typeid
15:03:27 <vincenz> a pointer iso a typeid...
15:03:52 <Philippa_> eh?
15:04:02 <vincenz> I don't much see the difference
15:04:09 <vincenz> you trade a typeid bound to a value for a pointer to a dictionary
15:04:13 <vincenz> on most systems that's 4 bytes each
15:04:28 <Philippa_> the difference is that you can need to pass more than one dictionary for a type into a function
15:04:39 <vincenz> oh
15:04:43 <vincenz> so it doesn't use tricks like in c++
15:04:48 <vincenz> where they make dictionaries/type?
15:04:51 <Philippa_> (A t, B t, C t) => t -> t -- three dictionaries go in
15:04:56 <vincenz> hmm
15:05:02 <vincenz> was thinking oo context
15:05:13 <sjanssen> what about the cost for getting an overloaded function from a typeid?
15:05:42 <Philippa_> sjanssen: in JHC? One case analysis, which is amenable to various GRIN optimisations due to the points-to analysis
15:06:45 <Philippa_> vincenz: the OO context has some additional issues, although they're solvable with a sufficiently smart linker
15:06:51 <sjanssen> okay.  I don't know enough to ask further questions ;)
15:06:55 <Philippa_> or rather, taking the OO approach does
15:07:05 <vincenz> yeah, especially the ugly hacks to do MI
15:07:36 * vincenz goes to get a pack of cigarettes
15:07:39 <vincenz> erugh
15:07:44 <vincenz> I have 3500 euros in my backpocket
15:07:47 <vincenz> leave it at home or take it with me
15:07:56 <basti_> o.0
15:08:08 <Philippa_> sjanssen: basically, worst case we're comparing n-way branching to indirection. Best case is, of course, it figuring out the only possible instance - but there're interesting ones in the middle like working out it's a two-way call
15:08:36 * Lemmih grabs a skimask and takes off towards vincenz.
15:08:39 <vincenz> out of curiousity
15:08:40 <sjanssen> vincenz: what are you doing with that kind of cash?
15:08:48 <vincenz> if you have multiple dictionaries
15:08:54 <vincenz> how does the function that takes for instance (num a)
15:08:58 <vincenz> know which dictionary to loko at 
15:09:04 <vincenz> sjanssen: my mother came by 
15:09:09 <Philippa_> additionally, case-floating means you get an "only look it up once" behaviour
15:09:12 <vincenz> I need to drop it in the bank tomorrow
15:09:37 <Philippa_> vincenz: the obvious translation is to take the order the classes're given in the type as the order the dictionaries're passed in
15:09:56 <Philippa_> you only pass the num dictionary in if the function only takes num, of course
15:09:59 <vincenz> Philippa_: yeah but how does the called function know that the value it's getting is one of 3 typeclasses
15:10:11 <Philippa_> you mean "one of three instances"?
15:10:12 <sjanssen> vincenz: I see.  In regards to your previous question, I advise that you stay at home, find your shotgun, and wait for Lemmih
15:10:18 <vincenz> Philippa_: yes
15:10:28 <Philippa_> the called function doesn't. The heap points-to analysis does
15:10:30 * vincenz hides his money in a fire safe place and runs to get cigarettes
15:10:49 <Philippa_> it's a (decidable) whole-program flow analysis
15:10:59 <vincenz> I see
15:17:10 <zimbatm> what editor do you generally use to code in haskell ?
15:17:49 <zimbatm> hIDE v2 seems nice but also unfinished
15:17:54 <Philippa_> personally I use TextPad. Any good text editor with customisable syntax highlighting is a good starting point
15:18:39 * vincenz reutrns
15:18:46 <vincenz> 7 minutes roundtrip
15:19:18 <vincenz> sjanssen: heh... even cooler is that this year I'm getting 3000 euros back from the state
15:19:28 <vincenz> aka tax-refunds
15:19:58 * vincenz only worked first 3 months of 2004 and then started his phd
15:20:03 <vincenz> \o/
15:21:00 * vincenz gets the money out of the freezer and shuts up
15:27:54 <Eelis> vincenz: you asked if epigram was the holy grail of static type checking. it is not; there are many competing systems. i have recently been introduced to one such system called Coq which is one of heavyweights in this area, and have grown quite fond of it
15:29:24 <Philippa_> Eelis: Epigram's actively trying not to be in the same area as the proof assistants though
15:29:28 <Eelis> true.
15:29:42 <psnl> Philippa_: I assume you know conner
15:30:00 <Philippa_> I don't actually, I've not really been around campus much in a few years and haven't knowingly met him
15:30:10 <araujo> Hi
15:31:03 <psnl> Philippa_: are the fp people in notigham improving epigram?
15:31:25 <Philippa_> psnl: yeah, part of the epigram team're under the FoP group here
15:31:55 <psnl> cool, it would be nice to see epigram get better
15:31:56 <Philippa_> hell, Thorsten taught my maths lectures, at least the ones I made it to
15:32:13 <Philippa_> (all Roland Backhouse's lectures were at the kind of time I tended not to make lectures at, which I kinda regret)
15:39:10 <psnl> I know that feeling
15:41:46 <Philippa_> I used to have really awful sleep patterns. To be honest, they're not really fixed now, it just doesn't matter when you're unemployed and unemployable
15:42:21 * jethr0 always fell asleep in the math lectures because things just tended to go over my head. in hindsight i should've made even more of an effort :(
15:43:31 <jethr0> the lectures were always at 8am and held blazingly fast (at least for us attending sophomores). not to mention that 8am is not my mental high point :)
15:43:45 <psnl> I did a module of "real maths" and slept in those lectures, but the discrete maths in compsci is fun
15:43:46 <Korollary> jethr0: It's nobody's mental high point.
15:44:09 <psnl> jethr0: I can only do 8am without sleeping and being on a suger and caffine high
15:44:10 <Korollary> I used to be a morning person, and it was tough for me, too.
15:44:20 <psnl> anything else is a nightmare
15:44:23 <jethr0> s/sophomore/freshmen/
15:44:46 <jethr0> "korollary: 8am is nobody's mental high point" ^_^
15:45:17 <Korollary> The absurd thing for me was that I mostly learned from the textbooks, so at some point I actually stopped going to the classes.
15:45:33 <jethr0> "lemma: holding fast algebra lectures to people who can't follow is torture"
15:46:18 <jethr0> we had the option to either write everything down or actually listen and try to follow. there just wasn't a chance of doing both...
15:46:34 <msph>  /join #theas-room
15:46:36 <Korollary> If you really value your time, the right thing to do is to prepare for one hour before every hour of lectures. Going unprepared to the class is expecting too much from any professor.
15:46:43 <msph> arg...
15:47:08 <Philippa_> jethr0: yuck, if you're going to do that you *need* to provide full notes, preferably in advance
15:47:28 <jethr0> but usually after 10 minutes i'd completely lost count of what was happening and was only hearing jacobi-this and eigenvector-that
15:47:51 <Korollary> jethr0: Don't worry. I remember nothing from linear algebra. almost.
15:48:01 <Philippa_> the rcb module I did well at, I learnt all the actual maths from the book given - I missed all the lectures with maths in and caught all the "blurb" lectures
15:48:09 <jethr0> Korollary: i absolutely agree, but i didn't know i'd be so fascinated with maths and preparing that diligently takes inhuman amounts of discipline (at least for me)
15:48:58 * Philippa_ liked Thorsten Altenkirch's lectures partly because a) they weren't so fast you could miss stuff and b) they tended to hint at stuff so you could find stuff for your brain to do when you were following them all
15:48:59 <Korollary> jethr0: Yes. Now that I study on my own for the heck of it, I see that I can't always focus when I want to. But when I do, it's ok.
15:49:08 <Philippa_> though at that point there wasn't really any 'heavy' algebraic work to do
15:49:27 <jethr0> i really envy people who can *really* advance in algebra... for me, i usually get lost around ideals, integer rings and galois fields :((
15:49:33 <Philippa_> tbh, most of the time I think that's... pointless. The bulk of rearranging is monkey work, the problem's when there isn't a clear way to state how you're rearranging
15:49:49 <Korollary> jethr0: What are you trying to be? are you in a graduate program?
15:49:51 * Philippa_ wants to learn abstract algebra, universal algebra, stuff like that
15:49:52 <vincenz> Philippa_: where are these courses
15:50:14 <vincenz> Eelis: thank you
15:50:18 <Philippa_> vincenz: University of Nottingham. And they were fresher courses covering fairly basic stuff
15:50:25 <jethr0> Korollary: right now i'm learning for my 1 hour oral cryptography and channel coding(?) exam.
15:50:39 <vincenz> oh
15:50:39 <vincenz> damn
15:50:40 <jethr0> but usually i'd just love to "get" the algebra stuff just out of pure interest
15:50:56 <Korollary> jethr0: ok, you're still in school. You'll find the time.
15:50:56 <Philippa_> I don't know what he's like lecturing at postgrad level. I'd like to find out, though
15:51:03 <jethr0> he
15:51:22 <vincenz> Philippa_: yeah but kinda hard for me to get there
15:51:27 <Philippa_> jethr0: unless you've specific need for it, don't worry too much about all the stuff that uses numbers, 'k?
15:51:30 <jethr0> Korollary: well, finishing my masters, but in a way that's still school :)
15:51:54 <vincenz> jethr0: which year are you
15:51:57 <vincenz> ...from
15:52:11 <Korollary> jethr0: Yes. Once you start working, it's significantly harder.
15:52:18 <jethr0> vincenz: ?
15:52:23 <vincenz> jethr0: '79...
15:52:27 <jethr0> yes
15:52:29 <vincenz> Korollary: well not always... I stopped working to get a degree
15:52:36 <Philippa_> granted there's a part of me'd like to be handy with tensors. There's a maths+CS student from UoN who shows up here sometimes, it was a bit sad that I seemed to be grokking more from a trawl through mathworld and wikipedia + some exposure to basic linear algebra at A level than he had actually doing the course :-(
15:52:37 <vincenz> erm a ph
15:52:38 <vincenz> d
15:52:59 <vincenz> mathworld?
15:53:10 <vincenz> and is wikipedia really that good?
15:53:15 <jethr0> tensors aren't so bad (at least what little i know about them). they are just matrices on drugs :)
15:53:16 <Korollary> wikipedia is ok
15:53:25 <vincenz> it is if you know what you're looking for
15:53:32 <jethr0> but then again i'm pretty clueless wrt math
15:53:38 <Philippa_> (and I can see the value, and right up until I have to do hard work the immediate response is "ooh, fun toy that fills a gap I've just about seen in my knowledge" (IANA anything to do with mechanics, so my use is minimal)
15:53:53 <Korollary> Philippa_: There are abstract algebra books online.
15:53:54 <Philippa_> vincenz: wikipedia is enough to give you keywords for a further search
15:54:03 <Korollary> I have two or three
15:54:08 <vincenz> Korollary: links!
15:54:24 <vincenz> I should make more time for study
15:54:28 <Philippa_> Korollary: yeah. In practice I'm not too good at picking stuff up from books like that on screen. I should sort out a good way of reading them in bed, I got a lot of my better thinking and understanding re type theory that way
15:54:34 <vincenz> even if it's not really related to my research area
15:54:42 <Korollary> vincenz: http://us.geocities.com/alex_stef/mylist.html
15:54:49 <Philippa_> getting to find the relationships is fun
15:54:51 <vincenz> Philippa_: I can't wait until they get e-paper
15:55:03 <jethr0> vincenz: me neither
15:55:04 <vincenz> Korollary: nice list
15:55:07 <Philippa_> as is having some unusual viewpoints to bring. Certainly that's where I get to do useful stuff
15:55:21 <Korollary> I print them out chapter by chapter.
15:55:35 <vincenz> Korollary: daunting list.
15:55:36 <jethr0> it would be awesome to read digital content in a book-like form. i've been waiting for years and probably will go on waiting for quite a while :(
15:55:43 <vincenz> yeah
15:55:48 <vincenz> just have like 10 pages
15:55:48 <Korollary> vincenz: Yes, it is. "All this stuff you don't know!"
15:55:50 <vincenz> so you can flip
15:55:53 <vincenz> but choose which content to have on each
15:55:58 <jethr0> yup
15:55:59 <Philippa_> shapr's mentioned the Nokia 770 as a pdf viewer. If I had a couple of hundred quid spare I'd do it
15:56:11 <vincenz> Korollary: yeah :/
15:56:33 <Korollary> Philippa_: That wouldn't work for me. I print them out and put them in an organizer. I have to make notes, and the margins don't suffice.
15:56:42 <vincenz> and it's hard to coose which to read first, you want to get a nice general one before you go onto a deep going technical one
15:56:46 * vincenz prints out a shitload too
15:56:55 <vincenz> I never note tho
15:56:58 <Philippa_> Korollary: I think that's what shapr has FLM for :-)
15:57:09 <vincenz> FLegM?
15:57:27 <Philippa_> Fermat's Last Margin. The hack he wrote on top of Flippi for annotating papers
15:57:43 <vincenz> Philippa_: you're the queen of acronyms
15:57:47 <psnl> cool, I want that
15:57:58 <Korollary> Philippa_: I actually did find another tool to annotate pdf's and ps's. It was just clunky, though.
15:58:01 * psnl has piles of papers all over the place
15:58:05 * vincenz too
15:58:12 <vincenz> and sadly pdfs dont contain metadta
15:58:14 * vincenz mutters
15:58:17 <Korollary> vincenz: they do
15:58:23 <vincenz> how do you get it out
15:58:26 <Korollary> you can annotate pdf's if they are enabled.
15:58:31 <vincenz> erm no
15:58:41 <vincenz> I mean like "title" "author" "date" "citings"
15:58:43 <Korollary> ah
15:58:45 <vincenz> "keywords" if present
15:59:11 <Korollary> There's got to be a way because you can store it.
15:59:25 <vincenz> pdf -> (Maybe Title, Maybe Author, Maybe Date, [Citing], [Keyword])
15:59:56 <vincenz> and then autogenerate graphs
15:59:59 <vincenz> or categorizations
16:00:01 * jethr0 's got over 4000 pages of pdfs he'd like to read but by now has totally lost any overview...
16:00:09 <vincenz> yeah
16:00:19 <vincenz> I also have a stack of papers-to-read that is constantly exploding
16:00:27 <psnl> same
16:00:33 <jethr0> i usually only print out what i intend to read right away
16:00:38 <vincenz> likewise
16:00:39 <Philippa_> vincenz: FLM's been talked about as FLM here before :-) Ask shapr where he's keeping it?
16:00:42 <jethr0> otherwise i'd drown in paper
16:00:49 <vincenz> Philippa_: will do!
16:00:55 <psnl> I'm planning to do a prinitng and reading run after exams
16:01:05 * vincenz already has a whole deep drawer of files full of papers on memory caching and crap like tat
16:01:24 <Korollary> vincenz: once you're done with those, head over to arxiv.org and drown!
16:01:33 <vincenz> NOooooooooooooooooooooo
16:01:55 <vincenz> they should define a USB-3
16:02:02 <vincenz> Universal Serial Brain adapter
16:02:19 <vincenz> like in the matrix
16:02:29 <Philippa_> really bad idea
16:02:32 <Korollary> it would have to be taken care of evolution, which means it's not going to happen.
16:02:36 <vincenz> reading is limited by the fact our eyes have to parse
16:02:38 <Korollary> s/of/by
16:02:41 <Philippa_> you don't want anything trying to feed data directly into your brain
16:02:53 <Korollary> vincenz: I don't think so. I think it's at the speed you parse speech.
16:02:55 <vincenz> Philippa_: pull system then not psh syste
16:03:01 <vincenz> Korollary: I meant when reading papers
16:03:04 <Philippa_> you don't want it even on request
16:03:09 <Korollary> vincenz: So did I
16:03:12 <vincenz> Korollary: oh right, internal speech
16:03:19 <jethr0> vincenz: depends. when reading technical stuff i'm definitely limited more by brain power than reading speed. BIG TIME
16:03:32 <vincenz> jethr0: I typically ... at least in my domain can do reading at the speed of parsing
16:03:44 <vincenz> typechecking and compilation is neglible
16:04:06 <jethr0> i'm reading lots of maths at the moment and often i have to stare for minutes at a single paragraph just to get an idea what it's about :)
16:04:21 <vincenz> the bad thing is that I don't have things hanging around in my parse-stack... so if people ask me 10 minutes later what I read... I'd have to reread the paper
16:04:26 <vincenz> I automatically compile to internal byte code
16:04:38 <jethr0> he
16:04:45 <Korollary> technical text is so terse that one page takes sometimes 30 minutes. Considering the text takes 30 seconds, bandwidth is not the bottleneck here.
16:04:52 <jethr0> that's an interesting feature
16:05:15 <vincenz> Korollary: that happens to me whe nreading CT
16:05:26 <vincenz> as for type-theoretic papers... as soon as they have those
16:05:27 <jethr0> although i must say that the SPJ papers are nice to read without being shallow at all. kudos for that
16:05:33 <vincenz> DELTA:L:x -> y
16:05:34 <vincenz> I get lost
16:05:40 <Korollary> jethr0: Yes, SPJ writes quite clearly
16:05:44 * vincenz never got around to understanding that notation
16:06:03 <Philippa_> the SPJ papers tend to separate out the "grunt-work" of the maths from the interesting points nicely
16:06:08 <vincenz> yep
16:06:11 <Philippa_> and without forcing you to make huge leaps
16:06:14 <vincenz> implemetation and theoretical
16:06:25 <vincenz> so depending on your understanding mode, you can skip to the right part
16:06:30 <jethr0> Korollary: it's not only clarity but you also get a feeling that he's having fun with his research. and usually you just get a feeling that papers are done out of necessity and full of half-truths
16:06:44 <vincenz> I'm always impressed with those papers that have a foot note like
16:06:49 <Philippa_> vincenz: "with the context Delta, it entails that L :: x -> y"
16:06:51 <vincenz> 1) exercise: check that blabla
16:07:22 <jethr0> the STM paper by SPJ was really nice for example
16:07:32 <vincenz> jethr0: or the one on the typechecker
16:07:49 <vincenz> Philippa_: what about the squiggly arrow?
16:07:50 <Philippa_> jethr0: yeah, it seems SPJ conveys a lot of his understanding in his papers which is good
16:07:52 <vincenz> ~~>
16:07:52 <jethr0> haven't read that yet. i'm pretty scared of type checking in general :)
16:08:14 <Philippa_> vincenz: in which papers? I imagine that's some other two place relationship, possible subsumption?
16:08:17 <vincenz> or ->_uparrow and ->_downarrow
16:08:21 <jethr0> vincenz: which type checking paper is that?
16:08:25 <vincenz> that last one was used in the type checking paper
16:09:57 <vincenz> " Practical Type Inference for Arbitrary-rank TypeS" SPJ et al
16:10:29 <vincenz> anyone know the complexity of hacking together a simple h98 compiler
16:10:34 <vincenz> well without backend
16:10:54 <vincenz> maybe I should try it out to better understand type-inference
16:10:59 <Philippa_> vincenz: those're defined in those papers, I believe. The up/down arrow's whether the checker's in checking or inference mode
16:11:05 <vincenz> jethr0: would you be interested in collaboration ala icfp05 for tat?
16:11:07 <Korollary> vincenz: Just get TaPL
16:11:16 <vincenz> Korollary: I have it, just haven't had time to read through it
16:11:23 <Philippa_> Korollary: TaPL doesn't cover those bits of notation, they're specific to the algorithms being discussed
16:11:24 <vincenz> but typically I understand things better if I have the implementation point of view
16:11:29 <vincenz> my understanding is bottom-up
16:11:30 <vincenz> not top-down
16:11:31 <jethr0> vincenz: i guess the type checker would be a bit of work and of course code generation. would you want to compile to C?
16:11:40 <Korollary> Philippa_: I meant for type inference and checking in general.
16:11:41 <vincenz> jethr0: initially without backend
16:11:59 <vincenz> jethr0: then we can specify a backend interface and hack up the easiest one, be that c or something else
16:12:15 <jethr0> vincenz: sure, but right now i'm totally usurped by my upcoming exam. maybe in two weeks. i'd love to try sth like that sometime
16:12:20 <vincenz> so am i
16:12:21 <Philippa_> Korollary: for inference it only covers as far as H-M
16:12:26 <vincenz> yep
16:12:35 <vincenz> and more the sml-like h-m
16:12:36 <vincenz> I think
16:13:00 <vincenz> jethr0: OHC "Oasis Haskell Compiler"
16:13:02 <Philippa_> ATTaPL goes a bit further, but it's going in an ocaml-like direction - handles type classes, subtyping etc but not rank-n type stuff or GADTs
16:13:11 <Korollary> it's cart before the horse still if you don't know the basics, tho.
16:13:15 <Philippa_> (granted at the time of publication there wasn't an HM(X) style algo for GADTs)
16:13:23 <jethr0> vincenz: but medium-term i'd love to, although i have no prior knowledge of haskell type checking, although i have decent background in compiler construction
16:13:34 <vincenz> Philippa_: I thought ATTapl, at least from review, looked at specific projects without having a good flow, like the typed asm and other projects
16:13:55 <vincenz> Korollary: well I know -some- basics nd obviously I'd refer to TAPL as I go
16:14:10 <vincenz> Korollary: but implementing something gives me a more solid understanding
16:14:22 <jethr0> Korollary: jhc started out as a small project afaik and it's gotten somewhere too
16:14:26 <vincenz> cause otherwise you easily brush over the details
16:14:29 <Philippa_> vincenz: it does, although it's not all projects as such - the chapters on dependant typing and ML-style module systems are more overviews of fields
16:14:39 <Philippa_> the HM(X) bit is also worth reading
16:14:49 <vincenz> HM(X) ==?
16:15:00 <Philippa_> and the bit on type definitions looks like a useful piece of what should be formalised folklore
16:15:19 <Philippa_> an extended Hindley-Milner system, parameterised on a constraint system X
16:15:29 <vincenz> ah
16:15:40 * vincenz still isn't sure on whether to get ATTaPL
16:15:54 <Philippa_> jethr0: there's a paper "Typing Haskell In Haskell" - you may enjoy it
16:16:01 <Philippa_> I rate ATTaPL
16:16:04 <vincenz> Philippa_: yeah it's a nice paper
16:16:14 <vincenz> Philippa_: ... as?
16:16:17 <Philippa_> it's worth following up some of the stuff in the dependant types chapter on Pure Type Systems too IMO
16:16:54 <vincenz> just that an overview of the field is more something one would download as a pdf or paper or as a webpage, than buying a book
16:17:21 <vincenz> I never really liked the collection-of-papers type of books
16:17:22 * jethr0 was a bit overwhelmed by TaPL, more abstract than i had expected
16:17:51 <hyrax42> it's about as I expected
16:17:55 <Philippa_> that was pretty much what I expected
16:18:02 <hyrax42> but unfortunately only on reserve at our library
16:18:02 <Philippa_> it's the right level of abstraction, that's where all the theory is
16:18:25 <Philippa_> it's worth maybe a little bit more on "building a real language", but I hope you could see how to start on that from the details it gives about things like references?
16:23:45 <msph> Mind if a relative newbie jumps in to ask questions right now?
16:24:33 <jethr0> msph: not at all
16:24:55 <msph> Okay, this is sorta borne out of the "advanced datatypes" section of  YAHT, but is really just about using the "class" keyword.
16:25:20 <jethr0> k
16:25:31 <msph> I've run into several situations in which I define a class, and we'll say the type variable is "c".  Then one of my methods has this sort of declaration:
16:25:36 <msph> success :: a -> c a
16:26:18 <msph> But then, any time I try to use the class, ghc comes back and says that c is an ambiguous type variable.
16:26:47 <psnl> don't you need a (Foo c)=>a->c a
16:26:49 <psnl> ?
16:26:55 <msph> I'm not sure.
16:27:05 <msph> In this case, I'm actually copying straight out of YAHT.
16:28:06 <vincenz> good thing gmail has good spam management
16:28:09 * vincenz gets like 50 spams a da
16:28:18 <msph> That said, though, I would think that is redundant in this case because "success" is being defined in the where clause of my class.
16:29:26 <msph> No, that doesn't work.  I start getting compile-time errors instead of run-time errors.
16:35:52 <msph> ...
16:38:11 <Philippa_> msph: put the code in a paste-bin and maybe tell us any further stuff about intent in here?
16:40:05 <msph> @where pastebin
16:40:05 <lambdabot> http://rafb.net/paste
16:41:36 <araujo> Hi!
16:43:29 <msph> http://rafb.net/paste/results/kS8x7L19.html
16:43:46 <msph> So, the idea of this code is to use a type class to start representing a computation.
16:44:09 <msph> Hence class Computation at the beginning, followed by instances for Maybe, Failable, and []
16:44:44 <msph> and then a searchAll function at the end.  incidentally, I don't know how to call that function because I haven't looked up the Graph type or how to construct a graph.
16:45:39 <vincenz> erm
16:45:42 <vincenz> msph: that's just MonadPls
16:45:44 <vincenz> MonadPlus
16:46:00 <msph> What do you mean?
16:46:01 <vincenz> success = return
16:46:04 <vincenz> failure = fail
16:46:08 <vincenz> combine = msum
16:46:10 <Philippa_> it's isomorphic to an existing typeclass
16:46:19 <Philippa_> vincenz: still, may as well figure out the syntactic problems
16:46:28 <msph> Yes, but it's an example that future parts of the tutorial are dependent upon.
16:46:47 <Philippa_> okay, what error message do you get with that code?
16:46:48 <vincenz> Philippa_: true
16:48:01 <msph> So, i've defined a as (Just 5)
16:48:06 <msph> let b = success a
16:48:19 <msph> I get "Ambiguous type variable `c' in the constraint:"
16:48:28 <msph> `Computation c' arising from use of `success' 
16:48:39 <msph> As well as the suggestion to fix it in the type signature.
16:49:30 <msph> Incidentally, if you copy and paste that into an editor, the code actually needs another close-paren on line 36
16:51:01 <Philippa_> msph: that sounds a lot like the monomorphism restriction to me
16:51:12 <Philippa_> which I'd really love to see gone from the language
16:51:28 <hyrax42> what is it
16:51:36 <Philippa_> RTFReport :-)
16:51:44 <Philippa_> "A pain in the arse" is the best you're likely to get out of me
16:51:46 <hyrax42> heh
16:51:52 <hyrax42> fair nuff
17:01:38 <msph> So, is there a  way to fix this, or is the example just unrecoverably wrong?
17:02:51 <Cale> hyrax42: it says that a pattern bound variable without a type signature must be monomorphically typed (that is, it will either be defaulted to something, in the case of things like numbers, or be considered ambiguous)
17:03:20 <Cale> msph: I'll have a look
17:03:23 <hyrax42> hm
17:03:51 <hyrax42> can't it be figured out from the use on the rhs?
17:04:03 <Cale> hyrax42: it can, and you can turn the MR off
17:04:12 <Philippa_> msph: add a type annotation for b, or substitute for b in the code after the "in"
17:04:20 <hyrax42> I should find the code of mine that was giving it
17:04:23 <hyrax42> so I can see what the deal was
17:04:41 <Cale> hyrax42: but without the MR, there are certain cases where not including a more specific type signature results in an exponential lowup in complexity
17:04:45 <Cale> blowup*
17:05:06 <Cale> msph: what was the problem with the code?
17:05:18 <vincenz> how are RULES used in ghc?
17:05:23 <vincenz> quickcheck tests?
17:05:35 <Cale> vincenz: they're used to do optimisations, mostly
17:05:47 <Cale> like fusion transformations
17:06:02 <vincenz> oh right
17:06:06 <vincenz> how about monad rules
17:06:21 <Cale> I'm not sure there are any rules applied there
17:06:26 <vincenz> stuff like
17:06:27 <msph> Cale: Trying to execute the success function in the Computation class yields "Ambiguous type variable 'c' in the constraint".
17:06:28 <vincenz> f >>= id = f
17:06:30 <Cale> but you conceivably could
17:06:56 <Cale> msph: in what context? It's complaining that it doesn't know what type of computation you're talking about
17:07:26 <Cale> msph: probably just adding a type signature will fix things
17:07:29 <vincenz> @djinn ((a->b->b) -> b -> b) -> Int -> a
17:07:30 <lambdabot> -- f cannot be realized.
17:08:16 <hyrax42> Cale: how long have you been programming in haskell
17:08:26 <Cale> hyrax42: a couple of years
17:08:57 <hyrax42> hm
17:12:31 <msph> I see.  So, really, executing this code is requiring more context than is available in an interactive session.
17:13:52 <Cale> msph: yeah -- well, you can provide it
17:14:04 <Cale> just do  success 5 :: [Int]
17:14:08 <Cale> say
17:14:21 <msph> Right.  I forget that I can do that inline.
18:15:05 <dons> @seen vincenz
18:15:05 <lambdabot> vincenz is in #haskell-blah and #haskell. I last heard vincenz speak 1 hour, 7 minutes and 35 seconds ago.
18:15:17 <dons> vincenz: did you get an answer to your multi-gigabyte question?
18:15:29 <dons> (the answer being, yes. though you'll need to use Data.ByteString.Lazy)
18:42:30 <Lokadin> what is a good 2 player go client?
18:43:28 <swoolley> I find a large slab of wood
18:43:31 <swoolley> with pencil lines with it
18:43:40 <swoolley> then a bunch of colored stones
18:54:39 <Pseudonym> I simulate my wood in Haskell, personally.
18:54:53 * Pseudonym just realised that could be taken several ways
18:55:31 <dons> oh dear.
19:15:17 <catch23> does your partner like the simulation?
19:17:06 <Cale> Lokadin: I just use cgoban2/KGS
19:17:35 <Cale> (it's not 2-player only, but that doesn't tend to matter -- you can have private games if you want)
19:23:09 <hyrax42> @hoogle (a,b,c) -> b
19:23:10 <lambdabot> No matches, try a more general search
19:27:04 <Cale> @djinn (a,b,c) -> b
19:27:04 <lambdabot> f (_, a, _) = a
19:27:23 <hyrax42> thanks djinn :p
19:27:51 <Cale> (basically, just use pattern matching, either with parameters to your function, or with case)
19:28:00 <hyrax42> was just wondering if there were built-in equivalents of fst snd for triples
19:28:05 <hyrax42> oh, it's no problem
19:28:13 <Cale> there used to be, but they were removed
19:48:42 <ihope> How can I get a random element of a list?
19:49:19 <Cale> construct a random number from 0 to length xs - 1, and use !!
19:49:31 <Cale> @type randomRIO
19:49:34 <lambdabot> forall a. (Random a) => (a, a) -> IO a
19:50:03 <Cale> @type let xs = [1,2,3,4] in randomRIO (0 :: Int, length xs - 1)
19:50:04 <lambdabot> IO Int
19:50:17 <ihope> That'll work. Thanks.
19:50:29 <hyrax42> is there no way to get a random number somewhere other than IO?
19:50:41 <ihope> hyrax42: find a generator and use that.
19:50:41 * hyrax42 was reading that tmr article on treaps
19:50:45 <Cale> Well, you can avoid IO somewhat
19:50:45 <hyrax42> yeah
19:50:47 <hyrax42> that's what they did
19:50:56 <Cale> you can construct a generator using IO
19:51:01 <Cale> and then pass that around
19:51:04 <ihope> @hoogle getStdGen
19:51:04 <hyrax42> what happened to tmr anyway
19:51:05 <lambdabot> Random.getStdGen :: IO StdGen
19:51:27 <ihope> There. Get that, then make some Random monad.
19:52:08 <ihope> data Random a = RandomGen g => Random (g -> (a, g))
19:52:34 <Cale> if you want a premade Random monad, there's one on the wiki
19:52:41 <ihope> return x = Random (\g -> (x, g))
19:52:54 <Cale> just use State
19:52:56 <hyrax42> looks like state
19:52:59 <ihope> Oh yeah.
19:55:16 <hyrax42> well at least I can recognise state...
20:08:53 <hyrax42> > foldr (+) 0 [1..10]
20:08:55 <lambdabot> 55
20:09:08 <hyrax42> > (+) `foldr` 0 [1..10]
20:09:09 <lambdabot>  add an instance declaration for (Num ([a] -> b))
20:09:34 <ihope> > (+) `foldr` 0 $ [1..10]
20:09:35 <lambdabot> 55
20:09:38 <ihope> > ((+) `foldr` 0) [1..10]
20:09:39 <lambdabot> 55
20:09:42 <hyrax42> ahh
20:09:43 <hyrax42> ok
20:12:59 <hyrax42> @hoogle elemBy
20:13:00 <lambdabot> No matches found
20:13:26 <hyrax42> @hoogle (a -> Bool) -> [a] -> Bool
20:13:27 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
20:13:27 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
21:10:34 <lambdabot> Haskell Weekly News out now: http://sequence.complete.org/
21:11:06 <sjanssen> how does lambdabot know?
21:11:16 <dons>  @msg ;)
21:11:33 <dons> unfortunately we don't yet have an rrs aggregator/notify plugin
21:11:37 <dons> rss
21:12:02 <Cale> HGAL sounds really cool
21:12:17 <Cale> I remember using nauty quite a bit in my graph theory course.
21:18:50 <Bobstopper> Can somebody explain what the mogul stuff in gtk2hs is intended for?
22:03:18 <hyrax42> I think the definition of bind in state would be clearer if given with a where clause instead of a let
22:03:43 <hyrax42> or do I
22:10:15 <palomer> @seen dons
22:10:15 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 58 minutes and 38 seconds ago.
22:11:40 <sjanssen> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))
22:11:40 <lambdabot> f a b c =
22:11:40 <lambdabot>   case a c of
22:11:40 <lambdabot>   (d, e) -> b e d
22:11:57 <sjanssen> hyrax42: looks like djinn prefers case
22:12:49 <hyrax42> indeed
22:13:02 * palomer pokes dons
22:14:59 <sjanssen> @pl \f g s -> g (snd $ f s) (fst $ f s)
22:14:59 <lambdabot> ap (flip . (ap .) . flip (.) . (snd .)) (fst .)
22:15:15 <dons> palomer: ?
22:15:16 <sjanssen> hyrax42: that is clearly the best alternative
22:16:02 <palomer> dons: I checked my SOC applications and some of them are editable
22:16:09 <palomer> dons: would you happen to know why this is?
22:18:10 * palomer has been out of the loop as of late
22:20:53 <dons> editable, what do you mean?
22:21:43 <palomer> oh, someone commented on it
22:21:44 <palomer> crap
22:21:50 <dons> anyway, the final announcement from google is in around 20 hours or so. we're in the final stages of sorting through the projects.
22:22:02 <palomer> the comment says I can do this with the ghc api
22:22:08 <palomer> I doubt this is true
22:22:18 <palomer> the comment is written by simon marlow
22:22:49 <palomer> do you think this can be done with the ghc api?
22:23:01 <dons> yeah, I reckon. and you get to reuse the infrastructure.
22:23:25 <dons> Lemmih has done stuff in a similar area in hIDE, though not as sophisticated, as your propose
22:23:31 <palomer> the ghc api let's you inspect the type of every subexpression?
22:23:34 <palomer> I really doubt it
22:23:53 <dons> you get access to the ASt, and you can invoke the type checker (i.e. GHC.typeOf expr)
22:24:39 <sjanssen> @yow -- 20 hours!
22:24:39 <lambdabot> Is this the line for the latest whimsical YUGOSLAVIAN drama which also
22:24:39 <lambdabot> makes you want to CRY and reconsider the VIETNAM WAR?
22:24:46 <palomer> but it won't give you the types of the subexpressions!
22:24:46 <dons> there's a typeOf (or something similarly named) function in the ghc-api, of :: HsSyn -> Type, or something like that.
22:25:23 <dons> you should be able to annotate the tree fully, with the api. i don't see why not.
22:26:05 <dons> sjanssen: yeah, haskell.org finishes in 12 hours or so, then google has a few hours to collate things. 
22:26:23 <palomer> what's HsSyn?
22:26:59 <dons> the AST type.
22:27:03 <dons> "Haskell syntax"
22:33:53 <palomer> what plugins are needed for Yi?
22:34:19 <palomer> (since this simplifies my task tremendously, I need to find other ways to fill in my application)
22:35:59 <dons> so it then comes down to binding yi to the ghc-api. and implementing over that all the type-based features you'd like to see.
22:36:47 <palomer> is this a reasonable project?
22:37:04 <palomer> type based features?
22:38:15 <palomer> wait, if there's a type error, will ghc-api still work?
22:38:55 <dons> you're told where the type error is, of course. like visual haskell does. how you're told might be via some highlighting or whatever. overall though, the editor continues running .
22:39:32 <palomer> will it still accept to annotate nodes if there's a type error?
22:39:34 <hyrax42> @hoogle (a -> b) -> (a, a) -> (b, b)
22:39:35 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
22:39:53 <hyrax42> @djinn (a -> b) -> (a, a) -> (b, b)
22:39:53 <lambdabot> f a (b, _) = (a b, a b)
22:39:57 <palomer> @type \x y -> y y (x + 1)
22:39:58 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
22:39:58 <lambdabot>   Expected type: t
22:40:01 <Cale> @type (&&&)
22:40:02 <lambdabot> forall (a :: * -> * -> *) c' c b.
22:40:02 <lambdabot>    (Arrow a) =>
22:40:02 <lambdabot>    a b c -> a b c' -> a b (c, c')
22:40:08 <palomer> in that expression, x clearly has type (Num a) => a
22:40:17 <palomer> and I want my user to be able to see that
22:40:18 <Cale> @type (***)
22:40:24 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
22:40:24 <lambdabot>    (Arrow a) =>
22:40:24 <lambdabot>    a b c -> a b' c' -> a (b, b') (c, c')
22:40:25 <palomer> even if there's an error
22:40:27 <Cale> @type join (***)
22:40:28 <lambdabot> forall (a :: * -> * -> *) b c.
22:40:28 <lambdabot>      (Arrow a) =>
22:40:28 <lambdabot>      a b c -> a (b, b) (c, c)
22:40:42 <Cale> @type join (***) :: (b -> c) -> (b,b) -> (c,c)
22:40:43 <lambdabot> (b -> c) -> (b,b) -> (c,c) :: forall b c.
22:40:43 <lambdabot>                (b -> c) -> (b, b) -> (c, c)
22:41:05 <Cale> that's a bit of a hackish way to use join :)
22:41:14 <Cale> (you need to import Control.Monad.Reader)
22:41:35 <Cale> dons: it should really cut after the last ::
22:41:39 <dons> though in 6.6 it will be in Control.Monad.Instances, in the base package.
22:41:51 <dons> Cale, yeah, known bug/todo
22:41:53 <Cale> Should be in the Prelude :)
22:42:20 <dons> there would be no term-level haskell, if we left it to you ;)
22:42:29 <Cale> hehe
22:42:34 <Cale> not quite true
22:42:52 <dons> oh, we'd be able to program in dictionaries, i guess.
22:42:57 <dons> that's enough for anyone.
22:42:58 <Cale> But that instance is actually pretty cool for the same reason that reader is useful.
22:43:07 <dons> oh, i agree.
22:43:11 * palomer doubts ghc-api is very useful when the program has type errors
22:43:12 <Cale> (and that join thing)
22:43:26 <palomer> does anyone have example code using typeof?
22:43:50 <dons> palomer: its cutting edge. if you want to chase this stuff up, visual haskell is the best user of the api.
22:44:01 <palomer> oh, so it's in 6.5?
22:44:26 <palomer> (and not 6.4)?
22:44:34 <hyrax42> @hoogle (a -> Bool) -> [a] -> Maybe a
22:44:35 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
22:44:35 <Cale> Last time I saw the ghc-api, it needed lots of cleaning up
22:45:35 <Lemmih> Still do.
22:45:41 <hyrax42> @hoogle (Either a b -> a)
22:45:41 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
22:45:51 <Lemmih> It's getting better, slowly.
22:45:58 <palomer> Lemmih: know how to use it?
22:46:02 <hyrax42> I should get lambdabot running on here
22:46:33 <Lemmih> palomer: Sure, it's just another Haskell library.
22:46:37 <dons> hyrax42: ? you can install it locally. and use it on the command line.
22:46:41 <palomer> twould be great if you could print out the typeof of every subexepression of \x y -> y y (x + 1)
22:46:56 <hyrax42> yeah I know
22:46:59 <hyrax42> I'm just saying I should
22:47:02 <hyrax42> :)
22:47:06 <palomer> (that was directed towards lemmih)
22:47:26 <palomer> I have a sneaking suspicion that it'll simply fail every time
22:48:10 <Lemmih> Yeah, it can't do that.
22:48:14 * dons notes he's written 22,000 works for HWN (including building the old news from the achives).
22:48:19 <palomer> right
22:48:24 <palomer> so I can't use ghc-api for this project
22:48:35 <Lemmih> dons: works?
22:48:38 <dons> words
22:48:49 <dons> oh, actually, i have 22k secret haskell works for you to try
22:49:12 <dons> all the haskell problems of the next 20 years are already solved. pity i can't put it in darcs for copyright reasons.
22:49:35 <Lemmih> The lost treasures of dons.
22:50:07 <palomer> Lemmih: what happens when you try to print out the type of every subexpression of \x y -> y y (x+1) ?
22:50:08 <sjanssen> @yarr -- hope this quote mentions treasure
22:50:09 <lambdabot> I want me grog!
22:50:31 <dons> hehe
22:51:12 <Lemmih> palomer: You can't. It doesn't type-check.
22:51:35 <palomer> Lemmih: so you can't even generate the HsSyn ?
22:51:46 <Lemmih> palomer: You can parse it, sure.
22:52:10 <palomer> so typeof returns bottom?
22:52:55 <Lemmih> It fails, yeah.
22:53:09 <palomer> positive?
22:53:15 <palomer> I'm about to right to Marlow about it
22:53:18 <Lemmih> @type \x y -> y y (x+1)
22:53:19 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
22:53:19 <lambdabot>   Expected type: t
22:54:03 <Lemmih> You could get the type of \x y -> x+1, though.
22:54:21 <palomer> can you extract the HsSyn associated with x and then run typeof on that?
22:57:16 <palomer> dons: do you still have a link to the haskell workshop paper for the graphical type analyzer?
22:57:54 <dons> ah, that was 2004. check the proceedings in scholar.google.com. it was Thiemann and um, Neubauer, iirc.
22:59:17 <palomer> found it
23:02:09 <palomer> ok
23:02:14 <palomer> resubmitted my applications
23:02:29 * palomer hopes marlow sees it in time
23:09:39 <Lemmih> You have to beat quite a few good applications to make the cut.
23:10:24 <dons> yeah, we'll have around a 92% rejection rate, unfortunately. 
23:10:38 <dons> making this harder than icfp to get into ... 
23:11:00 <hyrax42> how do you match multiple patterns in a lambda
23:11:12 <dons> hyrax42: multiple patterns, how do you mean?
23:11:16 <palomer> dons: what are my chances?
23:11:17 <hyrax42> as in something like
23:11:30 <mahogny> sounds like you should use case
23:11:35 <hyrax42> \(Just x) -> x; Nothing -> 0
23:11:36 <hyrax42> oh ok
23:11:42 <hyrax42> yeah
23:11:44 <palomer> hyrax42: I wish
23:11:54 <palomer> that kind of syntax would subsume both case and lambda
23:12:18 <dons> palomer, we'll announce the final list tomorrow. until then i don't want to comment on how the ranking is going.
23:13:00 <palomer> could you send emails when you respond to applications?
23:13:06 <palomer> s/could you/could you guys
23:13:19 <palomer> (so I'm not left in the dark that I should update them)
23:13:42 <dons> oh, unlikely. anyway, its moot at this point. 98% of the work is done. in the future, i would hope google's web app would send mail notification
23:15:07 <palomer> but I just updated my application (not knowing I had to update it before)!!!
23:15:25 <palomer> I guess this means I don't stand a chance :/
23:15:47 <palomer> (and I was checking the site daily!)
23:15:51 <dons> and your updated work is on the list now. 
23:16:03 <dons> simon's comment must have been recent.
23:16:28 <palomer> 15th
23:17:05 <palomer> (according to google)
23:48:00 <falconair> if i have a list of numbers which is being continuously being updated (like a stock quote feed), I want to do normal list operations (filter,map, fold) ... but do them for a list which is being updated (unbound end?) ... how can i do that in haskell?  i don't need a language with futures and promises do i?
23:48:37 <dons> lazy io, perhaps?
23:48:50 <dons> just a hGetContents on the input handle.
23:48:58 <dons> should be fine for potentially infinite input
23:49:39 <dons> i've streamed infinite input through lazy programs. works well.
23:50:21 <falconair> so if i have a sum on a list, each time a new number is added, i can get the updated sum? 
23:50:44 <dons> ah, no. not like that.
23:50:54 <Itkovian> meuning
23:50:54 <dons> if its a reduction operation, where you need to consume all input to get a result
23:51:01 <dons> you'll need to do something trickier
23:51:12 <dons> maps and filters work fine with infinite input. but something like 'sum' is a fold
23:51:23 <falconair> just what i was afraid of
23:51:36 <dons> how about just rereading every n seconds, using a forkIO timer?
23:51:47 <dons> in fact, you can wait on the handle
23:52:30 <falconair> from what i understand Mozart/Oz does it well, it is even harder to setup than haskell :)
23:53:03 <Cale> falconair: each time a new number is "added"?
23:53:17 <Cale> do you mean like scanl (+) 0 ?
23:53:28 <Cale> > scanl (+) 0 [1..30]
23:53:30 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465]
23:53:44 <dons> still seems like a couple of lines only.
23:54:09 <dons> falconair: you can certainly read more items and recompute, as they become available
23:54:25 <falconair> well, let's say each time item is pushed onto a stack (I'm thinking of an sql statement which, instead of returning a static set of data, updates the results each time an record is inserted....in haskell)
23:54:25 <dons> threadWait on the handle, when data arrives it wakes up a thread, recomputes with the new data, loop
23:54:47 <Cale> so, something in IO then
23:56:16 <falconair> yeah IO, but for a simple test i was thinking of using some sort of a stack which can have items popped into it
