01:11:31 <Myth0> hi. What is this about?
01:12:22 <Myth0> How did I get here trough searching for a martial art chat?:-P
01:16:10 <ValarQ> ...
01:18:26 <int-e> funny :)
01:27:34 <Korollary> because we hack stuff
01:47:28 <dons> there's a lot of Haskell-Fu in the room.
01:55:51 * int-e wonders if  iterateL, iterateR :: (MonadPlus m) => (a -> m a) -> a -> m a; iterateL f a = (f a >>= iterateL f) `mplus` return a; iterateR f a = return a `mplus` (f a >>= iterateR f)  would be generally useful.
01:58:17 <int-e> (All I actually need right now is iterateL for the Maybe monad - apply a function until 'Nothing' is returned and take the last non-Nothing result.)
01:59:36 <dons> sounds a bit like an unfold
01:59:38 <dons> ?type unfold
01:59:39 <lambdabot> Not in scope: `unfold'
01:59:48 <dons> ?type Data.List.unfold
01:59:49 <lambdabot> Not in scope: `Data.List.unfold'
01:59:53 <dons> ?index unfold
01:59:53 <lambdabot> bzzt
01:59:56 <dons> ?type unfoldr
01:59:57 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:02:08 <int-e> \f x -> last $ x:unfoldr (f >>= \x -> return (x,x)) x does that job, yes.
02:03:54 <int-e> but  iterateMaybe f x = maybe x (iterateMaybe f) (f x)  is more elegant and that use of maybe is close to `mplus` return x - that's how I arrived at the iterateL above.
02:13:15 <int-e> and we have  iterate f == iterateR (return . f)
02:13:24 * int-e shrugs
02:28:51 <psnl> thank you edwinb 
03:35:48 <dsacode> Hello! Is there some built-in function for lists that will delete duplicate elements from list?
03:36:55 <basti_> nub or something?
03:37:03 <basti_> > nub "abkjgdshdfjhdkjghlausfgalskgjhk"
03:37:03 <lambdabot> "abkjgdshflu"
03:37:05 <basti_> yep
03:37:10 <basti_> O(n^2) time though
03:37:35 <mahogny> if you need performance, write your own and you get down to nlogn
03:37:51 <basti_> or use Data.Set
03:37:57 <basti_> which is n log n, too
03:38:21 <mahogny> yeah, if a set applies
03:38:29 <basti_> yes.
03:40:59 <dsacode> thanks! it seems to work
04:15:02 <seba> newbie question
04:15:13 <vincenz> newbie answer
04:15:30 <seba> in ghci,if i do ":t digit", i get "digit :: CharParser st Char*
04:15:41 <seba> erase that * in the end
04:15:52 <seba> what does that mean?
04:16:03 <vincenz> digit has the type CharParser st Char
04:16:03 <seba> is digit a function, a data type, or what?
04:16:11 <vincenz> it's a CharParser
04:16:21 <psnl> seba: where are you using digit?
04:16:36 <seba> i'm doing the Hitchhiker's guide to haskell tutorial
04:16:44 * vincenz ponders
04:16:52 <vincenz> they go over parsec?
04:16:59 <seba> dirAndSize = 
04:17:00 <seba>         do size <- many1 digit
04:17:00 <seba>            spaces
04:17:00 <seba>            dir_name <- anyChar `manyTill` newline
04:17:00 <seba>            return (Dir (read size) dir_name) 
04:17:04 <vincenz> ah
04:17:05 <vincenz> yep
04:17:10 <vincenz> well digit is a CharParser
04:17:15 <vincenz> no more no less
04:17:20 <vincenz> parsec uses parsers to generate output
04:17:25 <seba> ok
04:17:40 <vincenz> internally it'ill probably be
04:18:28 <vincenz> grr can't remember
04:18:33 <vincenz> well a function that also has a state st
04:19:09 <seba> so digit generates output?
04:19:30 <vincenz> no digit takes a string, matches it with a number and if so returns it
04:20:00 <seba> i see
04:21:13 <vincenz> CharParser st Char = st -> (st, Char)
04:21:16 <vincenz> or some variant
04:21:32 <vincenz> but that matters little, you don't have access to the fact it's a function
04:21:37 <vincenz> that's done by the parser monad
04:22:12 <vincenz> I gotta go
04:22:21 <seba> ok, thanks a bunch
04:22:25 <vincenz> but there's this paper that describes building a parser library from the ground up
04:22:28 <vincenz> and it gives more insight
04:22:36 <vincenz> if I find it later I'll tell you
04:23:00 <vincenz> seba: do you know about monads?
04:23:12 <seba> well, what I read on the tutorials
04:23:18 <vincenz> ok
04:23:24 <seba> never built one myself. i guess.
04:23:51 <seba> they seem to be this mysterious thing about hiding contexts
04:24:01 <vincenz> here it is
04:24:01 <vincenz> http://www.cs.nott.ac.uk/~gmh/monparsing.ps
04:24:08 <seba> that was fast
04:24:14 <vincenz> yeah I have it in my personal library
04:24:19 <vincenz> just had to find the titlte and google it
04:24:44 * vincenz is off
04:47:28 <pflanze> Hello. I'm wondering: can types be parametrized (upon module import or some such)?
04:48:08 <pflanze> (So that each module can use the same type names but they are private.)
04:48:34 <pflanze> (and defined by the client of a module)
04:48:44 <pflanze> (I guess yes)
04:50:26 <basti_> uhm
04:50:46 <basti_> i don't see what exactly you are up to
04:51:26 <basti_> first, types CAN have a parameter. The List type, for example, has one.
04:51:40 <pflanze> Maybe me neither, in the end. What I meant was: use a type like Cell, defined to be a tuple of 2 parts, in a module.
04:51:54 <pflanze> But the type name "Cell" used there could be used by other modules as well.
04:52:49 <basti_> oh
04:52:54 <basti_> no that isn't possible
04:52:56 <pflanze> And a client using the cell-handling module could tell it to export functions working on Othercell types exactly as on Cell types.
04:52:57 <basti_> uhm
04:52:58 <basti_> well it is
04:53:10 <basti_> but you can't have the same exact name for two things
04:53:16 <pflanze> Since the client has defined it's Othercell type for the same purpose.
04:53:21 <basti_> hmm
04:53:30 <basti_> i think you're talking about different instances of a type class
04:53:40 <pflanze> hm I guess yes
04:53:56 * pflanze is a newbie really
04:54:42 <basti_> type classes work a little different in haskell than they do in most imperative languages
04:54:48 <basti_> they're about the same ideas though
04:55:30 * pflanze will play and read a bit more
04:56:10 <basti_> basically the idea is very simple.
04:58:08 <basti_> for example, you could make a "Collection" class, whose members are supposed to contain several values, and then have the instances declare a "count" function that would count the values and return an int
04:59:50 <pflanze> Basically the idea of functors (in the ML module sense) struck me: use functors not for mapping functions, but for mapping types, upon import of modules.
05:00:30 <pflanze> But in such cases where you can freely replace types, it's just polymorph, and there's no sense defining a particular type name in the module.
05:00:44 <pflanze> So the idea is moot.
05:02:21 <basti_> hmmm
05:02:25 <basti_> no its not, why?
05:02:34 <basti_> first, we have a Functor typeclass in haskell.
05:02:38 <vincenz> basti_: nono
05:02:42 <vincenz> basti_: he means functor in the ml sense
05:02:45 <vincenz> totally different
05:02:47 <basti_> oh.
05:02:49 <dons> completely different
05:02:49 <basti_> i didn't know.
05:03:10 <vincenz> but it's provable or so they have said that functor modules and typeclasses are nearly as expressive
05:03:20 <basti_> ah ok
05:03:21 <dons> there's an interesting paper comparing ml functors to type classes with associated types, though.
05:03:26 <vincenz> yep
05:03:32 <vincenz> by leroy?
05:03:36 <sieni> dons: url?
05:03:40 <dons> you need associated types, or function dependencies, and away you go.
05:03:44 <dons> sieni: looking ...
05:03:45 * vincenz forgot
05:04:27 <dons> here: http://www.informatik.uni-freiburg.de/~wehr/diplom/
05:04:47 <vincenz> dons: does it do functors?
05:05:16 <mahogny> is it possible to specify a custom finalizer for a variable? I know how Ptr and friends can do it, but is there a way to do it in general?
05:05:28 <basti_> a FINALIZER?!
05:05:32 <dons> have to check the paper, i dont' remember the role functors play in that translation.
05:05:36 <basti_> ;)
05:05:37 <mahogny> basti_, yeah. hate me .)
05:05:42 <dons> mahogny: ForeignPtr ?
05:05:47 <basti_> haskell variables are eternal.
05:05:58 <vincenz> holy cow
05:06:05 <dons> make a ForeignPtr to your 'a', then add whatever finalizers you want.
05:06:11 <int-e> basti_: haskell VARIABLES?
05:06:14 <vincenz> his sources has a complete type and kind inferencer
05:06:17 <vincenz> O.O
05:06:18 <basti_> ;)
05:06:21 <mahogny> dons, hm. will consider it
05:06:27 <basti_> even their values are eternal!
05:06:40 <vincenz> not sure for which languages tho
05:06:43 <dons> vincenz: stefan also wrote a couple of lambdabot plugins last year.
05:06:54 <dons> the darcs patch watcher, for one.
05:06:58 <vincenz> neat :)
05:07:05 <int-e> everything is constant. all you need to do is figure out which constants you need. (lazy evaluation in a nutshell)
05:07:21 * vincenz is off to get something to eat (2PM)
05:07:40 <basti_> but, tbh, mathematicans also call their things "variable" even though they aren't, usually.
05:07:41 <vincenz> dons: got any heavy algo based purely on lists of integers?
05:07:50 <vincenz> like simplex or something
05:07:55 <vincenz> but only based on lists
05:07:56 <dons> hmm. there's the pidigits in the shootout
05:08:02 <dons> its lists of Integer, iirc
05:08:11 <vincenz> preferably quite clean with not complex functions
05:08:15 <vincenz> just map, foldr, etc...
05:08:31 * vincenz is thinking of doing it in templates @ compile time
05:08:34 <vincenz> see how fast it goes
05:09:11 <vincenz> I mean stuff like drop, or take, or map or foldr can all be perfectly be done with templates :)
05:09:31 <vincenz> but... lunch!
05:09:37 <vincenz> hasta luego
05:22:54 <dsacode> Hello! I want to "zipWith" (+) two arrays with different length.. Is it possible to extend smaller array with `0'-s to common length? I mean, if there's some special zipWith for it or may be there's function to perform extending of array
05:23:23 <Lemmih> dsacode: zipWith zips lists, not arrays.
05:23:53 <Lemmih> > zipWith (+) [1,2,3,4,5] ([1,2,3]++repeat 0)
05:23:54 <lambdabot> [2,4,6,4,5]
05:24:15 <dsacode> Lemmih: thanks!
05:24:28 <resiak> That does of course need you to know which is the shorter.
05:24:43 <dsacode> yeah.. i just wanted to mention this..
05:37:04 <sieni> slightly offtopic, but do I have to update the package index with DarwinPorts with something like "fink update" in fink
05:37:13 <sieni> "slightly"
05:38:16 <sieni> ahh, port syncx
05:38:18 <sieni> -x
05:52:21 <roods> "In practice, however, functional languages are not necessarily conducive to concurrency. The parallelism exposed in functional programs is typically at the level of procedure calls, which is impractically fine-grained for conventional parallel processors. Moreover, most functional languages allow some side effects to mutable state, and code that uses these features is difficult to parallelize aut
05:52:22 <roods> omatically."
05:52:27 <roods> would people in here agree with this?
05:52:33 <Dreadshoot> no
05:52:49 <roods> Dreadshoot: why not?
05:54:00 <Dreadshoot> dunno, i just joined :)
05:55:42 <basti_> roods: you're aware that haskell has a method of controlling side effects?
05:55:56 <roods> i am.
05:56:34 <roods> I'm also aware that in a purely functional language, aggregate data structures, such as arrays or trees, are updated by producing a copy containing a modified value. This technique is semantically attractive but can be terrible for performance (linear algorithms easily become quadratic).
05:57:14 <roods> i don't know much haskell however. i'm just a beginner.
05:57:19 <basti_> so why do you ask?
05:57:29 <basti_> do you research functional parallelism?
05:57:35 <roods> one day i want to no be a beginner?
05:57:38 <roods> *not
05:57:58 * Oeje1 still feels like a beginner.
05:58:02 <roods> i guess i'm just curious. nawh i work on other things. what do you work on?
05:58:12 <basti_> I work on my diplom.
05:58:31 <roods> are you a haskell expert?
05:58:57 <basti_> i'm some good in haskell
05:59:43 <basti_> I'm some good in programming, generally, and i know that parallelism is just about the last question to ask ;)
06:00:10 <basti_> i think haskell is good because you can write very concise yet clear code in it.
06:00:49 * roods runs to learn something else.
06:01:06 <basti_> why? :P
06:01:32 <basti_> > let fibs = 1:1: zipWith (+) fibs (tail fibs) in take 15 fibs
06:01:33 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
06:01:39 <basti_> fibonacci numbers
06:01:43 <basti_> isnt that sweet?
06:01:46 <Oeje1> roods: Yeah, come back, we're not finished with you.  X-)
06:01:55 <Rolling> > let a=1
06:01:55 <lambdabot>  parse error on input `}'
06:02:41 <Rolling> > let  f x = x + 1
06:02:41 <lambdabot>  parse error on input `}'
06:02:52 <seba> why might haskell be good in generating parallel code?
06:03:04 <Rolling> > let  f x = x + 1;
06:03:04 <lambdabot>  parse error on input `}'
06:03:08 <basti_> because haskell is functionally transparent
06:03:20 <basti_> roods: you're missign an "in"
06:03:43 <seba> wasn't that *referentially* transparent?
06:04:14 <seba> off the topic, what happens if we ask lambdabot to evaluate an infinite list?
06:04:15 <Oeje1> seba: Haskell threads are light weight (at least somewhere between Java and Erlang).
06:04:18 <basti_> uhm yes.
06:04:21 <Rolling> > let a=1 in a
06:04:22 <lambdabot> 1
06:04:30 <basti_> seba: it has a runtime limit, and an output limit
06:04:35 <Oeje1> > [1..]
06:04:36 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,
06:04:36 <lambdabot> 70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,
06:04:36 <lambdabot> 127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
06:04:36 <lambdabot> 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
06:04:37 <seba> i see
06:04:38 <lambdabot> 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,
06:04:41 <lambdabot> [6 @more lines]
06:05:45 <roods> i can write much smaller code in J then i can in Haskell, but i do think Haskell is more readable.
06:06:28 <seba> repeat "lambdabot exploding"
06:06:42 <seba> > repeat "lambdabot exploding"
06:06:43 <lambdabot> ["lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding",
06:06:43 <lambdabot> "lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","
06:06:43 <lambdabot> lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","
06:06:43 <lambdabot> lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","
06:06:43 <mahogny> if small code was everything that counted, we would simply just reduce the font size :)
06:06:46 <lambdabot> lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","lambdabot exploding","
06:06:49 <lambdabot> [6 @more lines]
06:08:40 <roods> mahogny: ? that is just silly
06:09:02 <mahogny> roods, right :)
06:09:22 <roods> i should of said the code in J is more compact then in haskell.
06:09:45 <roods> i'll let you pick the font :)
06:09:50 <Oeje1> Uh, Perl can be quite compact too.
06:10:05 <basvandijk> Hi guys, I have a little question: Is it possible to use Template Haskell at runtime? The reason I'm asking is because I would like to parse some Haskell code (at runtime) and I don't like to use Language.Haskell.Parser.parseModule.
06:10:13 <mahogny> compactness can be a problem though, even in haskell
06:10:23 <Lemmih> basvandijk: No.
06:11:47 <basvandijk> ok... to bad... I think the AST of Template Haskell is much easier to work with then the AST of Language.Haskell.Syntax
06:13:15 <roods> what is haskell written in?
06:13:24 <mahogny> roods, depends on compiler
06:14:03 <Lemmih> roods: Haskell is a language, not an implementation.
06:14:29 <Oeje1> GHC is mostly Haskell, and some C, and a bit of Perl.
06:14:36 <Oeje1> Hugs is C.
06:14:40 <Oeje1> Right?
06:14:45 <mahogny> IIRC yes
06:15:59 * mahogny is yet again tempted to get working on a high performance matlab style FP. but oh the work :(
06:17:25 <mahogny> are there any FP's aimed primarily at performance yet?
06:17:30 <mahogny> in use that is
06:17:51 <Oeje1> Yes, I think so.
06:17:53 <Lemmih> SML, Ocaml?
06:18:07 <mahogny> Lemmih, those are for general programs, not scientific computing
06:19:31 <sieni> mahogny: I think that e.g. MLton is well suited for scientific computing
06:19:42 <mahogny> hm
06:21:29 <sieni> http://mlton.org/Features
06:21:57 <mahogny> well, read that. probably not really what I want
06:22:05 <mahogny> in the right direction, but not all the way
06:24:56 <Rolling> does anybody know which companies use Haskell?
06:25:51 <mahogny> IIRC haskell.org has a list, or used to
06:26:52 <Rolling> which?
06:31:32 <sidd178> Rolling, here is one interesting link. http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html
06:31:32 <mahogny> Rolling, hm. maybe not. might have mixed it up with the "haskell in practice link"
06:31:42 <sidd178> Rolling, linspire will be using haskell.
06:31:47 <Rolling> thanks
06:32:22 <eivuokko> Jobs-link lists some companies.
06:54:26 <pejo> Rolling, Galois connections is the one company that always is mentioned when it comes to using haskell
06:54:52 <Rolling> pejo,thanks
06:58:26 <sidd178> people .. I am new to the world of FP and Haskell.  Any pointers to get a good start ?
06:59:22 <sieni> sidd178: Yet Another H
06:59:36 <sieni> sidd178: Yet Another Haskell Tutorial might be a good pick
07:01:14 <sidd178> sieni, thanks. 
07:02:42 <eivuokko> As a motivation to FP in general and as a peek into ideas and style, maybe quickly read Why Functional Programming matters.
07:04:23 <neologism> whyFPmatters is great
07:06:28 <sidd178> thanks
07:08:28 <eivuokko> Yeah, and you can always come on this channel and ask.  There's almost always someone to answer questions. :)
07:08:51 <sidd178> yes sure.  :)
07:26:04 * mahogny is beginning to like Coq
07:28:09 <vincenz> mahogny: good thing that irc is written and not spoken
07:28:30 <mahogny> vincenz, indeed. the worst thing about this tool is the name :P
07:29:34 <vincenz> well
07:29:36 <vincenz> time to work
07:32:34 <mahogny> has anyone used CoqIde?
07:33:04 <vincenz> afraid not
07:33:12 <vincenz> tho I do think you'll get more coq support in #ocaml
07:33:24 <mahogny> ooh
07:33:24 <vincenz> "hehe hehe...beavis...hehehe... he said cocksupport"
07:33:38 <mahogny> lol
07:33:51 <mahogny> someone rename this program before it ruins our reputation :)
07:33:58 <vincenz> well it's ocaml
07:34:08 <vincenz> maybe we could port it to haskell
07:34:10 <vincenz> and call it "hen"
07:34:32 <mahogny> yeah. I'm on it :P
07:34:38 <vincenz> what?
07:34:42 <mahogny> porting :)
07:34:47 <vincenz> the complex part SURELY is the theory
07:34:56 <vincenz> once it's coded, porting should not be THAT difficult, should it?
07:35:10 <vincenz> especially given the similar languages
07:35:13 <mahogny> I don't even want to think what kind of theory they put into this
07:35:23 <vincenz> well certainly not chicken
07:35:25 <mahogny> I know what logic looks like after you pass a certain level
07:35:40 <vincenz> mahogny: what does it look like?
07:35:45 <mahogny> it looks like omfg
07:35:52 <vincenz> that's rather succint
07:35:55 <vincenz> just 4 letters
07:35:59 <mahogny> :)
07:36:08 <vincenz> HEH
07:36:09 <mahogny> I wish I could have that standpoint :)
07:36:12 <vincenz> I was at fnac today
07:36:35 <vincenz> looking through books, they don't really have a great selection on computer books, but what the hell I bought one on code design and such
07:36:59 <mahogny> code design... *gulp*
07:37:02 <vincenz> anyways, what bugs me is that most books nowadays, at least mainstream how to do development, focus WAY too much on tool x, tool y"look here you have the window and you can add a button"
07:37:29 <vincenz> mahogny: no just... refactoring taken to the extreme, browsed through it, it read easily, I like reading these kind of books, they read like stories
07:37:31 <mahogny> I think that problem already existed back in 90
07:37:42 <vincenz> why can't they focus on the metapatterns of development???
07:38:16 <vincenz> you need a test tool and it should do this and this, and it's cause of this and this and tied to that and that
07:38:22 <mahogny> because way too many people can't handle it. OTOH, way too many people who shouldn't code, do code
07:38:27 <vincenz> I don't care about product x has this window and product y has this button
07:38:32 <vincenz> true
07:38:50 <mahogny> aka "the java generation"
07:38:51 <vincenz> too many people are too close to the monitr
07:39:01 <vincenz> if that makes sense
07:39:04 <mahogny> yeah
07:39:14 <vincenz> I'd love to do project management with a capable team
07:39:35 <mahogny> with a capable team, you probably don't need to do project management ;)
07:39:49 <vincenz> but not in a world where people need the type of books with step by step development with xxx
07:39:58 <vincenz> mahogny: well project steering
07:40:09 <vincenz> and tbh I'm already doing it ;)
07:40:13 <vincenz> with a VERY capable team
07:40:16 * mahogny would kill for a team of OSS hackers
07:40:19 <vincenz> the #oasis icfpc team
07:41:00 <vincenz> oh yeah today I came up with a neat annecdote
07:41:33 <vincenz> c++ has a fractal language interface... every time you look at a feature and start to understand it, you see it's no longer a straight line but has small exceptions here and there, ad infinitum
07:41:52 <mahogny> lol
07:41:55 <vincenz> fractalic
07:42:01 <vincenz> or whatever the adjective is
07:42:09 <mahogny> FOP
07:42:30 <vincenz> for instance operator overloading... you can do them all.... except . and .*
07:42:36 <vincenz> or auto-conversions
07:42:44 <vincenz> it does it everwhyere... but not if you have it 3 levels deep
07:43:04 <vincenz> (oh yeah and except ?:)
07:43:05 <mahogny> C++ has too much historic crap to even be considered a serious effort
07:43:05 <vincenz> (oh yeah and except ?:  )
07:43:13 <mauke> you can't overload sizeof either
07:43:17 <vincenz> mahogny: yeah I know but the features of which I speak are the modern ones
07:43:26 <mahogny> mauke, if someone overloads sizeof, I would kill them
07:43:31 <vincenz> templates, operator overloading etc
07:43:34 <mauke> #define sizeof(x) rand()
07:43:44 <mahogny> mauke, :D
07:43:44 <vincenz> but the fact you can't overload . is a bitch
07:44:00 <vincenz> mauke: don't touch sizeof... I use it in my dm library
07:44:00 <mauke> how would you overload .?
07:44:04 <vincenz> erm
07:44:10 <vincenz> by overloading it
07:44:12 <mahogny> vincenz, well, C++ if any language is a language by evolution, except they kept the precambrian swamp in the middle of it
07:44:16 <mauke> what's the interface?
07:44:22 <mauke> . is really a metaoperator
07:44:28 <vincenz> mauke: rather like the ->
07:44:45 <eivuokko> overloading . would force implementation to show that references are implemented as pointers.
07:44:55 <vincenz> mahogny: yeah, they didn't get that evolution needs both mass births as well as mass deaths
07:45:12 <eivuokko> s/implementation/spec/
07:45:13 <vincenz> it's still useful as hell 
07:45:19 <mahogny> C++ is the trilobite of computer languages; old like hell, but still crawls around. no one knows why
07:45:39 <mahogny> s/trilobite/<forgotname>
07:45:47 <vincenz> kilobyte
07:45:53 <mahogny> ...probably not
07:45:56 <mahogny> :)
07:46:13 * vincenz saw something cool on friday
07:46:13 * mahogny has a whoppin trilobite disk space
07:46:21 <vincenz> a chip with 1 Tbit/s data throughput
07:46:33 <BCoppens> mahogny: coelacanth?
07:46:33 <mahogny> chip doing what?
07:46:34 <vincenz> and only consuming a few milliwat
07:46:44 <vincenz> mahogny: pixel operations
07:46:48 <mahogny> BCoppens, maybe. I just realized I walked outside my field :)
07:46:55 <BCoppens> heh :)
07:47:07 <vincenz> they had 320 identical cores
07:47:11 <vincenz> working on a very wide memory
07:47:30 <mahogny> vincenz, doesn't sound very hard to make, if you are ready to design the thing from scratch
07:47:45 <vincenz> mahogny: right...
07:47:46 <mahogny> I'd be more impressed if it ran x86 opcodes ;)
07:47:54 <vincenz> mahogny: it is rather hard to make
07:48:46 <mahogny> well, I have only done minor hw design. I'm not at that level yet :/
07:49:02 * mahogny thinks producing chips is waaaaay too costly for an amateur :(
07:49:15 <vincenz> yep
07:49:20 <vincenz> it only costs like 10 mil / mask
07:50:05 <vincenz> mahogny: with chip making the difficulty is not in getting those high levle interfaces
07:50:06 <mahogny> I know some universities has come together to cover up their costs. sharing a disk, the company doing it essentially for free, one chip "only" costs about $2000
07:50:09 <vincenz> it's in the details
07:50:25 <vincenz> mahogny: making it work fast enough, getting the data where it needs to be, making sure it doesn't suck energy like an intel
07:50:42 <mahogny> yeah. energy is a bitch. I know really little about that
07:51:07 <vincenz> with some back of the hand calculation they could prove another chip they had which was multicore would give 1 TOP/s at 200 Watt
07:51:34 <vincenz> 1TOP ... it blew my mind
07:51:36 <mahogny> but those are rather specialized operations
07:51:42 <vincenz> huh
07:51:44 <vincenz> nnono
07:51:46 <vincenz> another system
07:51:46 <mahogny> no?
07:51:47 <vincenz> not the pixel one
07:51:49 <vincenz> generic system
07:51:51 <vincenz> multicore
07:51:53 <mahogny> :o
07:51:56 <vincenz> could be programmed like one virtual chip
07:52:07 <vincenz> of course then delving deeper will give more optimizations
07:52:11 <vincenz> but they could map c code onto it
07:52:12 <mahogny> well, multicore is the way for certain
07:52:17 <vincenz> of course
07:52:22 <vincenz> heterogenous is the way to go
07:52:50 <mahogny> 100 cores please. then I wanna see the C++ coders live in pain over their lack of good low level concurreny :)
07:52:56 <mahogny> +c
08:01:06 <kowey> is there a way to build profiling-enabled versions of cabal packages?
08:02:00 <Lemmih> kowey: configure with --enable-library-profiling
08:02:47 <kowey> Lemmih: hmm... Unrecognised flag
08:02:54 * kowey tries configure --help
08:03:17 <Lemmih> kowey: Upgrade cabal (:
08:03:34 <kowey> ahah :-D
08:05:33 <araujo> morning!
08:05:39 <mahogny> yo
08:07:27 <araujo> :-)
08:13:59 <vincenz> <person in #C++ channel> I know haskell, I can't program it
08:14:08 <vincenz> <other person in #C++> noone can
08:14:08 <mahogny> :D
08:14:35 <mahogny> haskell shows which coders are the weak ones :)
08:14:42 <vincenz> :D
08:14:52 <Dreadshoot> the haskell ones? ;)
08:14:57 <vincenz> I wonder why the imperative world is so much more "all other languages besides mine suck"
08:15:01 <mahogny> probably not :)
08:15:16 <vincenz> I mean most haskell users don't kick against non haskellers
08:15:56 <mahogny> vincenz, because imperative coders usually don't select their language, their language select them and then twist their minds
08:16:19 <mahogny> why else would VB be used? :)
08:16:36 <vincenz> mahogny: don't fall into the same flaw
08:16:48 <Dreadshoot> and functional coders choose their language? probably most of them their university forces them to use like lisp and stuff
08:16:57 <vincenz> lisp
08:16:58 <woggle> vincenz: Maybe because it's harder to see the reasons behind the different language designs in the imperative world.
08:16:59 <vincenz> OY
08:17:21 <vincenz> woggle: or just cause the world there is more swamped with "I'll become a programmer in a week" people
08:17:49 <vincenz> anyways
08:17:58 <vincenz> I want to make a mini haskell in C++ templates :D
08:17:59 <mahogny> no. I would just say the community is inbread. as soon as you pick up one language, you don't have much of a reason to switch. from their point of view. then after a few years they will find anything else highly esoteric
08:18:07 <vincenz> I dunno
08:18:10 <vincenz> I switched languages often
08:18:24 * vincenz knows more languages than he has fingers
08:19:01 <woggle> Hm. Probably also because the imperative langauges have more high-profile commericial exposure. ("Of course, C++ is best! All those games use it!")
08:19:18 <vincenz> perhaps
08:19:22 <mahogny> that too
08:19:31 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
08:22:22 * Philippa ended up with the language she'd been taught a bit of at uni, but more because she found good tools to do what she wanted in it quickly
08:22:48 <Dreadshoot> vincenz: how is the contest about?
08:22:51 <Dreadshoot> what*
08:22:59 <Philippa> I'd been seriously considering ocaml for my third year project as well. I guess not having been forced to use a lisp means I've still got the "argh, where's the syntax?" hump to get over, but there're other reasons I'm not so interested in lisps
08:23:16 <vincenz> Philippa: dynamic scoping
08:23:21 * vincenz shudders
08:23:32 <Philippa> heh
08:23:43 <Philippa> scheme would likely be my lisp of choice, funnily enough
08:23:51 <vincenz> likewise
08:24:34 <mahogny> those macros in lisp are waaay to powerful
08:24:41 <vincenz> so?
08:24:42 <Dreadshoot> hmmf is it game developement?
08:24:45 <vincenz> scheme has macros too
08:24:52 <mahogny> vincenz, same for scheme :)
08:24:57 <vincenz> but syntactically clean ones
08:25:27 * Philippa likes staged computation
08:25:36 <Philippa> but I'd rather be doing it in a statically typed environment
08:25:40 <vincenz> TH?
08:25:53 <Philippa> TH's a good start
08:25:59 <vincenz> or wait wait ... C++ templates
08:26:02 <vincenz> *evil grin*
08:26:14 <mahogny> I fail to see the need for anything more involved than partial application and higher order functions. well, there are probably times but I wouldn't want to use that mess other than in special cases
08:26:43 * vincenz sighs as he has to do his dishes and then work
08:27:12 <Philippa> the special cases turn out to include just about any interactive enterprise-ish system
08:27:27 <Philippa> though really you want dynamic loading of code as well
08:27:56 <vincenz> Philippa: seen jocaml?
08:28:04 <mahogny> hmm.. I think I'd need to actually look at one of those cases before I consider myself convinced
08:28:51 <vincenz> lol
08:28:52 <vincenz> SO Typicall
08:28:54 <vincenz> 17:27 < _prophecy> So what would cause pthread_create to not actually call the start function but return zero as if everything was ok?
08:29:01 <vincenz> 17:27 < PlasmaHH> _prophecy: we dont know, we do standard c++ here
08:29:20 <mahogny> ie they do nothing?
08:29:24 <vincenz> heh... "yes us c++ are much closer to the platform... we can do a shit load of stuff more than you haskellers."   
08:29:28 <vincenz> and then you get shit like this
08:29:35 <Philippa> vincenz: I haven't, I probably should sometime
08:29:36 <vincenz> the std is nearly completely platform independent
08:29:44 <vincenz> Philippa: it's rather outdated, based on ocaml 2.0
08:29:48 <vincenz> Philippa: but it's e very neat concept
08:29:59 <vincenz> s/e/A
08:30:14 <woggle> vincenz: C++ does get the much closer to the platform. Adds all the extra non-portablity.
08:30:26 <vincenz> woggle: that's not in the std
08:30:35 <Philippa> I keep wanting to smack the "we're closer to the platform" crowd around with a hyped up IO monad, except so far there aren't any implementations with sufficient memory control
08:31:06 <Philippa> woggle: debatable. Manual memory management, sure, but beyond that? It's not so much closer if you're on a platform without a hardware stack (so that's MIPS including the PS2, then)
08:31:38 <mahogny> I have to agree that C++ is closer to the platform, but to what purpose? in 95% of the cases, you start coding by moving as far away from the hardware as possible
08:31:39 <vincenz> besides manual memory management sucks
08:31:40 <woggle> Oh, I'm not saying any of this apparent "closeness" is a good thing.
08:31:47 <vincenz> ther's been studies that prove that GC are always more efficient
08:31:57 <Dreadshoot> mahogny: ehh no you dont
08:32:10 <vincenz> woggle: did you catch my earlier comment regarding c++
08:32:23 <mahogny> Dreadshoot, you don't like new? :)
08:32:26 <Beelsebob> vincenz: where, I'd like that evidence in arguments
08:32:28 <vincenz> 16:40 < vincenz> c++ has a fractal language interface... every time you look at a feature and start to understand it, you see it's no longer a straight line but has small exceptions here and there, ad infinitum
08:32:35 <vincenz> Beelsebob: several papers
08:32:37 <int-e> vincenz: compared to what?
08:32:39 <woggle> No, I didn't catch that.
08:32:44 <Beelsebob> vincenz: can you point me at them
08:32:50 <vincenz> Beelsebob: I'd have to look for em
08:32:52 <Philippa> vincenz: you're thinking of Appel's paper?
08:33:00 <Dreadshoot> mahogny: new..? sure i like new why wouldnt i
08:33:02 <vincenz> Philippa: I think so yes
08:33:03 <Philippa> it only shows it for a drastically over-simplified environment
08:33:11 <Philippa> on real hardware, caching matters
08:33:35 <vincenz> I don't have the paper here
08:33:38 <vincenz> it's most likely at work
08:33:40 <mahogny> Dreadshoot, that's one case when you don't work towards the hardware, you are tossing in code in between to make life easy
08:33:43 <Philippa> also, a lot of real software cares too much about space usage to take Appel's approach
08:33:49 <vincenz> Philippa: but I do think the one I read included caching
08:33:56 <Dreadshoot> you could also say that a higher level language moves further away from the hardware(in general)
08:34:05 <vincenz> Philippa: so perhaps it wasn't him
08:34:10 <Dreadshoot> at least the control of it
08:34:18 <Philippa> Appel's original paper just shows that a stop-and-copy plus shitloads of memory ends up more time-efficient because your time taken doesn't depend on the amount of garbage
08:34:22 <Beelsebob> indeed... saw an interesting paper on functional virtual machines that automatically re-organise code to get cache its
08:34:26 <Beelsebob> hits
08:34:41 <Philippa> it's true that many schemes implemented on top of manual management are essentially slow, sucky GC
08:34:43 <vincenz> Philippa: then it wasn't that one
08:35:05 <Philippa> pooling's important though
08:35:08 <vincenz> anyways
08:35:08 <psnl> Beelsebob: got a link?
08:35:10 <mahogny> Dreadshoot, yes. my point being, if you already want to abstract away the hardware, you might as well use a language that already has done this in a clean manner than try to fit it into a language suited for portable low-level programming
08:35:11 <vincenz> in a GOOD system
08:35:14 <vincenz> the GC should be in the central OS
08:35:16 <Beelsebob> psnl: give me two mins
08:35:41 <Philippa> vincenz: that's really not applicable in a large chunk of the embedded space, or on a games console
08:35:43 <Beelsebob> psnl: http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/02-Grabmueller-GenericModelOfFPWithDynOpt.pdf
08:35:52 <vincenz> Philippa: most systems have a os
08:36:00 <vincenz> Philippa: including embedded
08:36:02 <mahogny> vincenz, let's wait until program stops SIGSEGVing before we take that to the extreme :)
08:36:07 <Philippa> I didn't say otherwise
08:36:09 <psnl> Beelsebob: thanks
08:36:18 <psnl> most things by nhn are good
08:36:23 <vincenz> Philippa: then I fail to see how it's a problem to use a GC instead of a normal memory manager
08:36:25 <Philippa> however, many systems care too much about their maximum memory footprint
08:36:25 <Dreadshoot> mahogny: true, abstraction away from the hardware may be good, but a result is often lack of control or performance chokes
08:36:43 <vincenz> Philippa: well I'm talking about the dynamic memory
08:36:46 * int-e thinks GC is too tricky for one garbage collector to be sufficient for all kinds of applications.
08:37:01 <vincenz> Philippa: obviously that which is mapped statically remains mapped staticall
08:37:17 <Beelsebob> psnl: it isn't by nhn
08:37:23 <ndm> int-e: but all GHC applications have teh same GC, even if thats entirely inappropriate...
08:37:27 <vincenz> and it's not like manual allocation is the end all be all
08:37:28 <Philippa> vincenz: you're oversimplifying
08:37:34 <Beelsebob> it's just he had the whole of TFPs website in his home dir
08:37:37 <mahogny> Dreadshoot, that's something you have to live with. if you are gonna do abstract programming, use an abstract language. if you are gonna do low-level programming, use C/C++. there's no point trying to cover the whole spectrum with C++ alone
08:37:38 <vincenz> you've got a lot of internal and external fragmentation there as well
08:37:46 <int-e> ndm: aimed at the 'gc should be in the OS' remark.
08:38:05 <psnl> Beelsebob: yeah, I noticed that when I started reading. oh well  ;-)
08:38:15 <ndm> int-e: but if everyone should write in haskell, you get back to the same problem
08:38:40 <vincenz> Philippa: I disagree
08:38:54 <Philippa> vincenz: again, you're oversimplifying.
08:38:56 <Dreadshoot> mahogny: heh well yes and no, it takes time to lern loads of languages. And after a while in c++ you tend to have made your own libs thats speeds up developement pretty much so you can use it even for non "low level" stuff also
08:38:59 <int-e> ndm: well, noone says ghc will be the only haskell compiler people use.
08:39:10 <Philippa> oops, sorry. Had banged page up when I wasn't looking
08:39:26 <ndm> int-e, least of all me :) but i think very few people understand their app enough to pick the best garbage collector
08:39:32 <mahogny> Dreadshoot, yeah, but if you can be even more efficient with a better language, it is still worth the transition
08:39:37 <ndm> and perhaps one that was self-tuning would be best for everyone
08:39:38 <Beelsebob> int-e: hehe, he probably knows that pretty well, when he's writing yhc
08:39:47 <ndm> Beelsebob: and Hugs :)
08:39:51 <Philippa> but yes, you're still oversimplifying. And unless you know how the people who're good at it go about implementing what they need on top of manual memory management, you're going to keep oversimplifying
08:39:51 * vincenz ponders
08:40:02 <Philippa> short version: think "staged static", pooling, stuff like that
08:40:03 <Beelsebob> ndm: incidentally... I did fire that paper at Tom to see if it's any use for the runtime
08:40:09 <vincenz> Philippa: I know about pooling
08:40:16 <Philippa> many GCed languages just *can't do pooling*
08:40:27 <vincenz> Philippa: there's no reason why they shouldn't be able to
08:40:29 <Beelsebob> really?
08:40:32 <Beelsebob> why not?
08:40:35 <Beelsebob> it's dead simple
08:40:42 <mahogny> GC in the OS is certainly possible and a good thing. just make sure the GCing is flexible and can be overriden by the programs
08:40:45 <int-e> ndm: true, but putting the GC in the OS would make it impossible for applications to fix bad GC behaviour (well, of course not; they can allocate a big chunk of memory and do their own memory management. But then the advantage of the GC in the OS would be gone)
08:40:49 <Philippa> Beelsebob: OK, I'll rephrase - user-controlled pooling
08:40:49 <ndm> Beelsebob: i doubt he'll read it, he's quite busy
08:40:53 <Dreadshoot> mahogny: remembers me of a "over optimizing discussion i saw a day ago) sure it can be so, it have both adventages and disadventages and a big one use to be time needed for developement, you have to make a choice there
08:41:11 <int-e> ndm, Beelsebob: ah, woops. I had forgotten that :)
08:41:12 <Philippa> and yes, in practice you can pull a pile of kludges - but you end up with either space leaks or a potentially unsafe system in practice still
08:41:15 <mahogny> Dreadshoot, right
08:41:27 <ndm> int-e, but often 50% of a heap with GC is wasted, if the OS could share that space, perhaps it could reduce memory pressure
08:41:27 <vincenz> Philippa: user controlledp ooling reads just like user-parametrized gc
08:41:29 <Beelsebob> mahogny: interestingly... in OS X 10.4 a lot of docs appeared saying "this may be replaced by a GC at some point, code so that it'll still work then"
08:41:46 <ndm> int-e, and use any automatic hardware instructions, if available
08:41:53 <Philippa> vincenz: there isn't a parameterised GC good enough to shove in the OS at the mo
08:41:55 <mahogny> Beelsebob, hm. that sounds evil
08:42:07 <vincenz> Philippa: I was talking ideal case not atm
08:42:35 <vincenz> conceptually there's no qualm against it
08:42:53 <vincenz> I should have used IDEAL instead of GOOD
08:42:59 <Philippa> sure. Conceptually, pragmatics don't matter
08:43:11 <vincenz> they do but they're a matter of time
08:43:20 <Philippa> I'm not convinced by that
08:43:29 <vincenz> then we agree to disagree
08:43:54 <Philippa> not until you're at a bare minimum recompiling the GC with each app s.t. it's partaking of the same whole-program optimisation as everything else
08:43:58 <Philippa> I don't think it's part of the OS at that point
08:44:30 <mahogny> Philippa, if you consider the optimizations hints to an OS-wide GC, then you're at it
08:44:53 <Beelsebob> Philippa: the way it's looking to be done in cocoa is certainly that the GC is in the cocoa framework and linked in dynamically as the app runs
08:45:00 <Philippa> mahogny: I don't think you understand the extent of whole-program optimisation. What you describe would fundamentally *not* be whole-program
08:45:04 <vincenz> I will admit this
08:45:10 <vincenz> I'm the preacher preaching the devil
08:45:19 <vincenz> xcause I've published papers on application custom dmms
08:45:26 <Philippa> heh
08:45:38 <Philippa> I do agree with you for a significant proportion of existing apps, FWIW
08:45:45 <mahogny> Philippa, why not?
08:46:06 <mahogny> Philippa, you always have constraints during optimization. this is another one
08:46:14 <vincenz> Philippa: I was also envisioning general purpose... embedded systems might be more hardpressed
08:46:14 <Philippa> mahogny: because the GC is still part of the OS rather than the program. The GC code isn't integrated into the program itself
08:46:30 <vincenz> however possibly one could dual stage it
08:46:33 <Philippa> mahogny: it doesn't have to be
08:46:34 <vincenz> have a os wide gc for large chunks
08:46:49 <ndm> Beelsebob: me and Tom have looked at profile driven dynamic optimisation before (in our "lets beat GHC" talks), but it seems JIT would be a bigger win, and profile driven stuff makes more sense with JIT
08:46:52 <vincenz> tho I'm not certain if that would be efficient
08:46:56 <Philippa> how does that differ from "when a process dies, claim all its memory back"?
08:47:10 <vincenz> Philippa: fixed size chunks requested by the apps gc
08:47:20 <Beelsebob> ndm: fair enough
08:47:23 <vincenz> and given back asap
08:47:29 <Philippa> which is your worst case in practice for any sufficiently misbehaving app anyway. Space leaks are our friends, just like The Computer is :-)
08:47:32 <mahogny> Philippa, no, but under the assumption that you can only give hints, then it for certainly can be called whole program optimization. anyway, I think the definition isn't worth arguing about
08:47:34 <ndm> Beelsebob: but the paper may help us on that
08:47:41 <ndm> we had reasonably informal discussions
08:47:45 <Philippa> mahogny: No it can't be called whole program optimisation
08:47:45 <ndm> (i think i was drunk)
08:47:58 <Beelsebob> lol
08:48:03 <edwinb> best time to have ideas and discussions ;)
08:48:18 <psnl> heh
08:48:19 <ndm> indeed, thats the only reason i'm in work today
08:48:21 <Philippa> mahogny: whole program optimisation is what happens when *the entire program* is taken into account when doing your optimisation. What you're describing clearly doesn't do that
08:48:37 <vincenz> whole program optimisation doesn't suffice for memory issues
08:48:39 <vincenz> you need profiling
08:48:45 <mahogny> Philippa, so by your definition you can't do whole program optimization if you link to an external library?
08:48:47 <psnl> I haven't had a good drunk idea since the time we all rushed off to try and crack a small RSA key
08:49:10 <Philippa> mahogny: Depends on the nature of the external library. Not if it's object code only
08:49:20 <Philippa> there's a reason for the .hi files GHC spits out
08:49:27 <Philippa> JHC's even more aggressive
08:49:32 <vincenz> hi is not interface only?
08:49:43 <ndm> vincenz: it also contains function definitions (for inlining)
08:49:46 <vincenz> ah nice
08:49:51 <ndm> its way beyond an interface :)
08:49:54 <eivuokko> Way.
08:50:01 * vincenz is a strong advocate for something that is NOT .o until linkage
08:50:06 <mahogny> Philippa, ok. then... your definition doesn't sound very relevant for the topic of OS-wide GC's :)
08:50:07 <int-e> and also rules to apply ... for specializations, say.
08:50:14 <vincenz> ndm: cause ocaml for instance doesn't do cross module optimizations sadly
08:50:29 <vincenz> .cmi = purely interface
08:50:30 <Philippa> mahogny: oh FFS. I'm *arguing against OS-wide GCs*. This is a relevant argument.
08:50:35 <vincenz> and if you're doing native compilation it's .cmi and .o
08:50:52 <vincenz> what is FFS?
08:50:56 <Philippa> For Fuck's Sake
08:50:58 <vincenz> ah
08:51:13 <mahogny> Philippa, and you also argue against dynamic linking? :)
08:51:16 * int-e thinks some GC hints from the OS would be neat though - 'hey, we're running out of file descriptors, could you all please check your garbage for fds to close?'
08:51:31 <Philippa> mahogny: I argue against being forced to support dynamic linking in all situations
08:51:58 * vincenz hugs Philippa 
08:52:00 <Philippa> much as I like dynamic linking, it's not suitable for every application
08:52:12 <mahogny> Philippa, well, if you want to be *that* extreme, just ask the GC for a major chunk and use your own malloc
08:52:21 <vincenz> mahogny: that's what we advocate
08:52:41 <mahogny> the OS GC would need a good realloc function though
08:53:17 <vincenz> http://www.notvincenz.com/wiki/uploads/Main/sips2004.pdf
08:53:38 <Philippa> mahogny: I still take the cost of the OS GC poking its nose in once in a while. If I can hint it to sod off 'til the process ends I guess that's tolerable for the most part, but it's also not so hot a GC any more
08:53:58 <vincenz> besides
08:54:06 <vincenz> with virtual memory addresses
08:54:14 <Philippa> (not so hot in the sense that it no longer gives any useful OS-wide guarantees)
08:54:14 <vincenz> the OS GC can play at that level to forego reallocing
08:54:26 <Philippa> yep, virtual addressing good
08:54:32 <mahogny> Philippa, no, but you are considering a minority of programs. a majority still motivates the use of an OSGC
08:54:41 <eivuokko> Don't GC's take use of virtual addressing?
08:54:54 <Philippa> mahogny: not in *every application ever*, which was the original statement
08:55:00 <mahogny> eivuokko, you can do with and without
08:55:13 <Philippa> I've already said I agree there's a wide range of apps for which an OS-wide GC'd be suitable and potentially beneficial
08:55:22 <mahogny> Philippa, well, it's still in your program. you are just not using it very much :P
08:55:24 <eivuokko> mahogny, I want to know if they do or if they don't, not if they can.  They clearly can.
08:55:28 <vincenz> I think some team even worked on a hardware GC by making the DMA slightly more programmable :D
08:55:34 <Philippa> but we were already talking about some of the spaces where that's not so immediately the case
08:55:47 <Philippa> vincenz: that sounds like a PS2 project, the DMAC on that thing's scary
08:55:49 <mahogny> eivuokko, a userspace GC has no need to use virtual adresses as far as I can see
08:55:56 <int-e> how would an OS-like GC even work? How do you know what's a pointer and what isn't? How do you know the application isn't storing pointers in some strange format for algorithmic reasons?
08:56:14 <vincenz> Philippa: oh?
08:56:28 <mahogny> int-e, language support preferably
08:56:30 <Philippa> int-e: good questions :-)
08:56:34 <int-e> if the OS has to ask the applications what their pointers are, there's no advantage anymore.
08:56:47 <vincenz> int-e: it's assuming one unique common format
08:56:52 <Philippa> and yeah, lang-level issue. You don't get a fully general-purpose OS
08:56:53 <int-e> vincenz: bad :)
08:56:55 <vincenz> int-e: the system I idealized is FAR off in the future
08:57:12 <Philippa> vincenz: I *think* the PS2's DMA controller + a memory bank is a turing complete system
08:57:17 <Philippa> I could be wrong
08:57:19 <int-e> bad unless you're fixing a virtual machine for everyone - which could be interesting.
08:57:20 <mahogny> Philippa, you can. you just need to hook all your languages up to a common OS function do to the dirty work
08:57:25 <vincenz> nice
08:57:46 <int-e> (that would be aimed at security, not performance, though)
08:57:57 * vincenz nods at int-e 
08:57:59 <Philippa> mahogny: that's not fully general-purpose any more. That's a bit more of a restriction from arbitrary machine code than "don't fuck with interrupts or memory you've not been given access to"
08:58:21 <eivuokko> mahogny, User-space GC could still use OS-interface to mapping memory instead of using allocation functions (both to allocate and free.)
08:58:28 <Philippa> also, if it's the OS keeping track of what's a pointer, that means the info's in separate structures. That's likely to be slow
08:59:05 <ndm> Philippa: once you have this OS GC, you can get hardware support, and make it faster than most other things
08:59:14 <eivuokko> mahogany, That could also be used by compacting in some cases.
08:59:17 <vincenz> ndm: YAY
08:59:21 <vincenz> ndm: and consume 1kW
08:59:28 <mahogny> I think the concept of an OSGC *assumes* that you have good languages that makes fucking up memory hard. otherwise I don't see a major point with it
08:59:33 <Philippa> ndm: that's true, I'd been about to mention possibilities like dumping a couple of extra bits on the bus and using them for OS flags on pointers/ints/what have you
08:59:48 <eivuokko> Typed asm :)
09:00:01 <mahogny> BEEEEP *major contradiction*
09:00:02 <vincenz> eivuokko: people would complain cause it's dynamically typed
09:00:03 <mahogny> :)
09:00:06 <Philippa> how far've they got on that?
09:00:09 <Philippa> mahogny: no, it's not
09:00:18 <Philippa> hell, the subject's even discussed in TaPL
09:00:23 <vincenz> TAPL2
09:00:25 <Philippa> sorry, ATTaPL
09:00:30 <Philippa> :-)
09:00:36 <mahogny> Philippa, for the majority of people, I would say it is :)
09:00:50 <vincenz> mahogny: oh so contradictions are observer dpendent?
09:00:57 <mahogny> vincenz, of course
09:01:09 <SamB> maybe you don't understand the meaning of the word "ASM"?
09:01:18 <vincenz> SamB: asexual SM
09:01:23 <Philippa> heh
09:01:24 <mahogny> vincenz, I'm not giving you a full proof of contradiction, I'm talking to you :)
09:01:25 <SamB> not it!
09:01:32 <Philippa> vincenz: that's my job, dammit! :-)
09:01:37 <vincenz> :D
09:01:38 <SamB> how about the highlight reel!
09:01:50 <Philippa> mahogny: the ignorance of the majority doesn't make them right
09:02:21 <mahogny> Philippa, I didn't say it was right, I just stated that it is the common way of looking at it. you interpreted it otherwise
09:02:31 <vincenz> Philippa: good thing you weren't here then when we were talking about support for <insert famous theorem prover>
09:02:52 <Philippa> it's true that until recently there wasn't any way for an assembler's type system to do any more than check pre-defined data is of the right size for the opcode
09:03:24 <Philippa> vincenz: heh. Where do you want it inserted?
09:03:29 <vincenz> hehe
09:03:57 <Philippa> mahogny: it boils down to most people not having been aware there was a potential for a typed assembler to do anything more than annoy
09:04:25 <vincenz> mahogny: contradictions imply paradoxes imply things conceptually impossible implies not based on the observer
09:05:14 <mahogny> vincenz, I think you missed that there are several meanings for the word "contradiction" :)
09:05:17 <vincenz> Philippa: you competing with icfpc?
09:05:23 <ndm> Philippa: surely the next step after typed ASM is a garbage collector for ASM :)
09:05:30 <mahogny> lol
09:05:31 <vincenz> mahogny: contradiction, against what it's saying
09:05:46 <mahogny> vincenz, :)
09:05:51 <ndm> so far everyone i asked for icfpc has turned me down :(
09:06:00 <vincenz> ndm: I have a huge team that's why
09:06:18 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
09:06:19 <ndm> vincenz: they said no, they don't want to partake at all
09:06:23 <vincenz> oh
09:06:26 <vincenz> :/
09:06:37 <vincenz> ndm: people that are colo'd with you?
09:06:44 <ndm> vincenz: yep
09:07:04 <ndm> vincenz: that is a pretty big team...
09:07:06 <psnl> edwinb: have you taken part in icfpc?
09:07:18 <edwinb> psnl: No. I always manage to be away or otherwise occupied...
09:07:30 <vincenz> edwinb: you make it sound like an achievement
09:07:34 <edwinb> heh
09:07:41 <edwinb> I don't do it deliberately ;)
09:07:50 <ndm> last time for icfpc i was up a mountain with no network
09:07:55 <int-e> Is the haskell parser that is mentioned on the happy homepage available anywhere? I don't know where I should look for it.
09:08:04 <edwinb> I can't remember my excuse last year
09:08:11 <psnl> its in the happy vcs, I belive
09:08:14 <vincenz> my excuse last year was the fact I was on the beach
09:08:42 <vincenz> blegh, I had an argument with a colleague yesterday when I told him to use darcs, he said he liked the system but prefers lock-systems
09:08:50 <vincenz> anyone give me some good clout against lock-based systems?
09:09:02 <ndm> vincenz: darcs is inherently unsafe, thats not a good thing
09:09:10 <ndm> a bit more locked would be most useful!
09:09:19 <vincenz> how can you lock a distributed system?
09:09:35 <ndm> vincenz: you can lock each repo individually as you apply a patch
09:09:39 <ndm> not the entire system
09:09:42 <psnl> vincenz: normally with a master somewhere, but that doesn't work for darcs
09:09:49 <vincenz> psnl: let's not go back to ASM
09:09:57 <Igloo> ndm: The repo does get locked when a patch is applied
09:10:00 * vincenz winks at Philippa 
09:10:16 <ndm> Igloo: a competitiveness lock, not a correctness lock
09:10:22 <Igloo> ndm: Huh?
09:10:36 * vincenz is referring to a "working on X don't work on it" lock
09:10:55 <psnl> vincenz: was that a sly reference to the Asexual SM gag?
09:11:00 <ndm> Igloo: if a program aborts, it can abort without a lock, btu with the repo in an inconsistent state - there is a bug filed about it on the darcs bug tracker
09:11:00 <vincenz> psnl: yeah
09:11:11 <vincenz> psnl: "master"
09:11:18 <ndm> Igloo: it happened to the Yhc master repo, was most annoying!!
09:11:35 <Igloo> Ah, right
09:11:37 <vincenz> ndm: not only that... it can sometimes leave the lock there
09:11:54 <ndm> vincenz: thats not soooo bad, breaking the repo is worse
09:12:05 <Igloo> That's not really locking, though, that's a flag to say the repo may be in an inconsistent state
09:12:07 <vincenz> just remove the last .gz?
09:12:09 <ndm> darcs does seem very prone to non-termination
09:12:22 <ndm> or too termination in a non-feasible amount of time
09:12:28 <vincenz> ndm: especially if you specify a http_proxy when you shouldn't 
09:12:37 <vincenz> you can only kill -9 it
09:12:38 <ndm> vincenz: nope, just when playing with Yhc :)
09:12:41 <vincenz> not even CTRL+C
09:12:59 <psnl> vincenz: it could be done by passing around lockfiles as patches
09:12:59 <ndm> Ctrl+C is interceptted by darcs/GHC and handled
09:13:17 <vincenz> psnl: I don't see how.
09:13:25 <vincenz> psnl: unless there's constant communication
09:13:51 <vincenz> but! I'm not arguing for lock systems
09:13:58 <int-e> psnl: ah, found it. libraries/haskell-src uses happy.
09:13:58 <vincenz> I'm asking for an argument against em
09:14:18 <ndm> int-e: yes, thats teh GHC parser
09:15:54 <psnl> vincenz: putting on my SE hat, I would say that forcing a techical solution to the problem of people not saying what they are working on is bad and a sign of not enough communication in team
09:16:16 <vincenz> psnl: yeah but that's a weak reason
09:16:22 <vincenz> at best
09:16:42 <int-e> ndm: I wish http://www.haskell.org/happy/ would mention it.
09:17:08 <ndm> int-e: i hate happy anyway :)
09:17:48 <Igloo> ndm: The GHC parser is in ghc/compiler/parser/
09:19:06 <int-e> hmm. haskell could use some sort of array literals.
09:19:13 <psnl> vincenz: I really can't think of a good argument, but if you do find one, pass it on
09:19:31 <vincenz> heh
09:19:32 <vincenz> that was funky
09:19:40 <vincenz> if you're in a channel in which you don't have voice
09:19:42 <vincenz> you can't rename
09:19:51 * psnl takes off the SE hat
09:20:03 <vincenz> psnl: what do you do?
09:20:11 <psnl> CompSci
09:20:20 <int-e> *looks at happy -g -a output*
09:20:55 <psnl> I'm an Undergrad, which is why I feel I should pratice bullshitting for my SE exam
09:21:39 * int-e decides looking at that was a bad idea.
09:22:41 <vincenz> : \o) 
09:22:41 <vincenz> :  |   Haskell this way!
09:22:41 <vincenz> : / \
09:25:41 <hyrax42> @hoogle index
09:25:41 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
09:25:41 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
09:25:41 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
09:25:56 <vincenz> Food for thought: Are haskellers in general more capable programmers than their java counterparts, or does haskell just make it so much easier to code that we don't need fancy IDE's
09:26:51 <psnl> I don't think I have ever met anyone who is a) good and b) only a java coder 
09:27:05 * vincenz snickers
09:27:25 <Philippa> vincenz: I think Haskell exposes more useful structure for us to latch on
09:27:34 <Philippa> +to
09:27:36 <int-e> . o O ( "I know C, C++ (but templates scare me) *and* Java." )
09:27:42 <vincenz> I tend to agree
09:27:54 <Philippa> being able to see how to take advantage of it makes you a better programmer than not being able to
09:28:17 <hyrax42> @hoogle (a -> Bool) -> [a] -> Int
09:28:18 <lambdabot> No matches, try a more general search
09:28:50 <hyrax42> oops
09:28:52 <vincenz> Philippa: so did you get a chance to look at that code I had that demonstrated the c++ currier?
09:28:53 <mauke> @type (length .) . filter
09:28:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
09:29:04 <hyrax42> @hoogle (a -> Bool) -> [a] -> Maybe Int
09:29:05 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:29:10 <ndm> vincenz: comerical companies produce good ide's, haskell is not popular enough to make it worth while
09:29:30 <vincenz> ndm: yeah but with java I felt like eclipse was a necessary tool
09:29:38 <monochrom> I would still love an IDE.
09:29:41 <vincenz> ndm: I hardly feel such thing is lacking when I vim haskell code
09:29:48 <ndm> vincenz: if you had never had eclipse, you would probably never have missed it
09:29:59 * araujo would prefer a Haskell editor
09:30:00 <ndm> wait til Haskell IDE 6.0, and you'll wonder how you ever did without it
09:30:13 <ndm> but i think much more critical to haskell would be a good debugger
09:30:14 <vincenz> ndm: that a product launch statement?
09:30:14 * araujo doesn't like IDEs
09:30:25 <psnl> ndm: sounds like a challange for the authors
09:30:28 <vincenz> the problem with IDE's is simple
09:30:30 <ndm> vincenz: have you seen WinHaskell? it 10% of the way their
09:30:37 <vincenz> they lack all the textual features of normal editors like vim or emacs
09:30:44 <eivuokko> ndm, I agree.  Debuggers are needed.
09:30:46 <monochrom> The problem with "do you need/want an IDE" is that an IDE provides so many things that the question doesn't say which ones you're referring to.
09:31:10 <vincenz> monochrom: one that codes for me ;)
09:31:10 <monochrom> (Do you want an IDE for its auto-completion?  Do you want an IDE for its tracer? ...)
09:31:13 <ndm> vincenz: i use a simple editor, i would be happy with a simple (but consistent!) editor
09:31:45 <vincenz> simple editors require mouse gestures
09:31:49 <vincenz> mouse is bad
09:31:55 <ndm> vincenz: thats entirely wrong
09:31:57 <eivuokko> Mouse is the right tool sometimes.
09:32:05 <int-e> vincenz: you have a weird idea of 'simple'.
09:32:09 <vincenz> not for many tasks they make you use the mouse
09:32:11 <vincenz> like
09:32:17 <ndm> my editor of choice is textpad, it gives you choice to use a mouse or not
09:32:29 * araujo thinks most IDE get in your way too much
09:32:29 <monochrom> An IDE provides boilerplate code.  I think we don't need that for Haskell.  And I think it is fair to say we appreciate everything else.
09:32:30 <vincenz> ESC v/plopENTER/fooENTERy
09:32:53 <vincenz> whoops that v should come before the first grep
09:33:03 <ndm> Ctrl+R plop TAB foo ENTER
09:33:10 <eivuokko> Hehe
09:33:11 <vincenz> CTRL+R is?
09:33:13 <ndm> its the same thing, just allows choice
09:33:16 <ndm> Ctrl+R is replace
09:33:22 <araujo> my IDE, emacs file.hs && ghc -o file file.hs 
09:33:22 <vincenz> I'm not doing replace
09:33:27 <vincenz> I'm copying something
09:33:37 <ndm> Ctrl+C, Ctrl+V
09:33:39 <vincenz> all the text between plop and foo
09:33:42 <ndm> same difference
09:33:46 <vincenz> ndm: selection requires mouse
09:33:51 <mauke> doesn't /plop<CR>y/foo<CR> work?
09:33:51 <vincenz> ndm: or SLOW per char movement
09:33:52 <ndm> vincenz: not at all
09:34:02 <ndm> Ctrl+left, right goes by a word
09:34:07 <ndm> up down goes by line
09:34:12 <ndm> page up/page down goes by page
09:34:22 <vincenz> and you're doing binary search
09:34:26 <esap> IDE = Emacs + xterm
09:34:31 <ndm> you have perfect control over the selection medium
09:34:42 <vincenz> ndm: likewise with vim
09:34:47 <vincenz> except you have MORE
09:34:57 <ndm> vincenz: but less GUI fallback options
09:34:59 * vincenz would never give up vim
09:35:07 <vincenz> ndm: hmm?
09:35:30 <ndm> vincenz: if you don't know how to do something, you look it up - i just hit the menu item and it guides me thougth with a GUI (no need to learn)
09:35:48 <ndm> vincenz: anyway, WinHaskell allows you to use your existing text editor
09:35:55 <ndm> and gives you a few IDE style features
09:35:59 <vincenz> I remember in college I had to make a HUGE blackbox test... lots of test cases were very similar, so copy paste, but I wanted to give each a uniqe number, so I just put XXX everywhere and tada vim filled in sequential numbers
09:36:17 <ndm> once I get Hat integrated, it will give me 75% of an IDE
09:36:22 <vincenz> Hat?
09:36:26 <ndm> @where Hat
09:36:26 <lambdabot> http://www.cs.york.ac.uk/fp/hat
09:36:36 <ndm> the best haskell debugger, and it still doesn't work properly ':)
09:36:50 <ndm> its great at the theory, and its great at the framework, and at the research
09:36:54 <vincenz> shouldn't that be a :(
09:37:00 <ndm> its just a bit of polish short of being "the answer"
09:37:13 <ndm> at 95% of the way there, i give it a :)
09:37:20 <monochrom> don't worry be happy ==> :) not :(  :)
09:37:21 * vincenz hasn't felt the need for a debugger yet in haskell
09:37:39 <ndm> vincenz: because you haven't had one available? rather than because it wouldn't be helpful
09:37:44 <vincenz> nope
09:37:53 <vincenz> ndm: I'm not a simpleton
09:37:57 <sjanssen> vincenz: do you use debuggers with other languages?
09:37:57 <monochrom> Example.  "I flunked my thesis oral defense! :)"  XD
09:38:04 <vincenz> sjanssen: rarely but sometimes
09:38:12 <Philippa> monochrom: :)!:( ?
09:38:15 <vincenz> I just tend to code with few bugs / line count
09:38:27 <Philippa> or maybe !:(>>:)?
09:38:35 <ndm> vincenz: what about when you are debugging someone elses code?
09:38:37 <monochrom> I think there is wisdom in smiling everything off.
09:38:50 <sjanssen> I think most programmers (especially me!) aren't trained to use debuggers
09:39:04 <Philippa> there're times I could've used a good debugger, or at least a good execution trace
09:39:05 <esap> Debugging is not needed mostly in Haskell, because Haskell has very good type system.
09:39:08 <vincenz> sjanssen: I've had to use it
09:39:15 <monochrom> YES! When it is someone else's code, you need a tracer.
09:39:15 <vincenz> sjanssen: when designing custom memory allocators
09:39:34 <Philippa> or even when it's your own and you've done something moronic that the type system couldn't catch (or you mis-specified the type in the first place)
09:39:35 <vincenz> sjanssen: but I tend to have a low bug count and for some reason with haskell that's even lower
09:39:38 <ndm> monochrom: Hat is a tracer (Haskell Tracer is the acronym)
09:39:51 <vincenz> sjanssen: as well as intermediate testing
09:39:52 <ndm> vincenz: low /= 0
09:40:09 <vincenz> ndm: look I know what I need, so far I haven't needed one
09:40:10 <ndm> if this was C, i would have cried by now for a lack of a debugger
09:40:13 <xerox> low >= 0
09:40:20 <monochrom> Yes I know it's a tracer, and you see I never say "debugger" in the past ten minutes, always "tracer".
09:40:24 <ndm> haskell makes me cry less, but there are still tears there
09:40:34 <sjanssen> vincenz: right, having a REPL like GHCI lets you unit test by hand very easily
09:40:37 <vincenz> I HAVE used haskell to debug c++ code
09:40:45 <Philippa> a full-blown debugger'd have to be aware of all the compiler-implemented monads
09:40:51 <vincenz> when my RB tree was borking
09:41:17 <Philippa> (ones implemented in Haskell can be traced out reasonably already, especially if the tracer's helpful enough to maintain a reasonable amount of sugar)
09:41:28 <monochrom> To people on the street I say "debugger" because that's the word they know.  But to you I say "tracer" because you know it is a tracer and you don't call Eclipse a programmer. XD
09:41:46 <vincenz> monochrom: I don't?
09:41:51 <Philippa> most debuggers're tracers + the ability to query the state that isn't present 99% of the time, in fairness
09:42:27 <monochrom> hmm, what does "the ability to query the state that isn't present 99% of the time" mean?  Sounds like making things up?
09:42:29 <eivuokko> I think real haskell debugger needs runtime support for forcing evaluation.
09:42:47 <ndm> eivuokko: that changes the semantics, and might mask/introduce bugs
09:42:51 <monochrom> Or do you just mean snapshots of states?
09:43:07 <ndm> its better to do post-execution tracing, when the state has been evaluated naturally
09:43:13 <monochrom> Hmm you can force evaluation and then roll back XD
09:43:20 <psnl> thats the thinking in hat and hood
09:43:26 <eivuokko> ndm, It still is very very very hard to debug with unevaluated state.  And it is very very very tedious to make statemachines to trace only under certain conditions.
09:43:26 <vincenz> eivuokko: yeah otherwise you juse see one huge thunk
09:43:27 <xerox> Use prolog.
09:43:53 <ndm> eivuokko: if you debug after, you have evaluated state, but the same evaluation result as normal
09:43:59 <ndm> the best of both worlds
09:44:19 <eivuokko> ndm, Yeah, this requires either a lot of user interaction or statemachine made by user
09:44:37 <ndm> eivuokko: Hat does it automatically and with no user interaction
09:44:37 <eivuokko> ndm, Which is not really, ime based on other languages, enough.
09:45:38 <eivuokko> ndm, I understand it can be done automatically often, but it cannot be done automatically always, especially in presence of unsafe-functions and concurrency.
09:45:41 <Philippa> monochrom: most languages with debuggers're stateful, Haskell (module IO and ST) isn't
09:45:52 <eivuokko> ndm, Or maybe I am jsut stupid and there is some magic...
09:46:02 <Philippa> an IDE might allow options like breakpoints
09:46:05 <Philippa> that'd be useful
09:46:41 <Philippa> to really crack debugging Haskell you need to crack debugging IO as well
09:46:46 <eivuokko> I am just writing a sort of tracer (more like standard debuggers) for ghc built binaries and most of the time the values it has make no sense at all.
09:46:59 <monochrom> ah
09:47:26 <eivuokko> They are just closures/thunks which are next to impossible to put together by looking the code
09:48:05 <ndm> eivuokko: there is no reason it can't be done automatically always, Hat doesn't get there entirely, but yhc-hat should do
09:48:08 <eivuokko> And that's without optimisations.  Most of prelude is gone by time ghc has optimised anything.
09:48:32 <Philippa> "evaluate this thunk (but don't necessarily write the update)" might be useful too
09:48:39 <eivuokko> Yes.
09:48:57 <Philippa> certainly being able to figure out WTF the thunk came from would
09:49:06 <eivuokko> I was thinking adding ghc runtime a special thunk for that, so that I could put that on top of rts/stg stack and get value from it by breakpoint
09:49:23 <eivuokko> (put = put when debugged program is stopped)
09:50:15 <eivuokko> ndm, yeah, I guess in interpreted/bytecode/so on system that is true.
09:58:42 <xerox> Where does second-order logic appear in Haskell?
09:59:17 <kombinator> System-F is second-order logic
09:59:40 <xerox> For example the foralls?
09:59:50 <kombinator> yes
10:00:34 <xerox> So types are predicates and not values?
10:01:33 <kombinator> yes, something like this
10:01:39 <xerox> Gotcha.
10:24:00 <eivuokko> Can Text.PrettyPrint.HughesPJ render tables?
10:28:12 <vincenz> woo
10:28:20 <vincenz> gotta love the napkin look and feel
10:28:26 <vincenz> sadly it's only for java :/
10:28:55 <monochrom> in no time the gnome fans will duplicate it :)
10:29:27 <vincenz> http://napkinlaf.sourceforge.net/NapkinButtons.jpg
10:30:04 <BCoppens> :D
10:30:10 <int-e> eivuokko: I don't think so.
10:30:12 <vincenz> cute, no?
10:30:36 <BCoppens> vincenz: very cute, I especially like how it looks so neatly randomized :)
10:30:52 <vincenz> yeah
10:31:00 <vincenz> wait there's a better one
10:31:14 <vincenz> check out the progress bar on this
10:31:15 <vincenz> http://napkinlaf.sourceforge.net/NapkinProgress.jpg
10:31:34 <BCoppens> lol :D
10:31:48 * vincenz wants it as std interface
10:32:04 <vincenz> http://napkinlaf.sourceforge.net/NapkinTree.jpg
10:32:42 <vincenz> the scrollbar is neat too
10:32:43 <eivuokko> int-e, Thanks.
10:32:47 <BCoppens> heh yeah :)
10:33:09 <monochrom> haha, krad
10:33:10 <vincenz> BCoppens: belg?
10:33:15 <BCoppens> vincenz: ja
10:33:19 <vincenz> aha van waar/
10:33:32 <BCoppens> Lebbeke, streek van Dendermonde ;)
10:34:35 <BCoppens> you too, obviously ;)
10:35:59 <vincenz> leuven
10:37:28 <BCoppens> ah, the other side of flanders :)
10:37:53 <BCoppens> on irc, I see relatively much people from leuven, and relatively few from ghent
10:38:35 <vincenz> the ghent people are in haskell-blah
10:38:43 <vincenz> BCoppens: and tbh I'm the only person from leuven I know on irc
10:39:11 <BCoppens> heh :)
10:39:53 * BCoppens can't remember who exactly was from leuven, though
10:40:24 <BCoppens> vincenz: I know a couple of persons here are from Ghent indeed, making this the 'ghentiest' channel I know of ;)
10:41:29 <vincenz> yeah I totallyagree, it's a really bad curse
10:41:39 <BCoppens> :P
10:41:43 <vincenz> but you have to take it with the good side of this channel
10:41:53 <BCoppens> hehe ;)
10:41:59 <vincenz> ;)
10:42:51 <BCoppens> and it's a nice channel indeed, so I guess the influence is rather low ;)
10:43:04 <ell-hask> I'm trying to learn monads but obviously have a misunderstanding
10:43:20 <ell-hask> Probably a misunderstanding with something more fundamental, but I hit it now.
10:43:35 <ell-hask> instance Monad State where
10:43:35 <ell-hask>         (State (a,True)) >>= f = f a
10:43:35 <ell-hask>         (State (a,False)) >>= f = State (a,False)
10:43:35 <ell-hask>         return = \a -> State (a,True)
10:43:58 <ell-hask> That 2nd line (the one with 'False') does not work, can someone help me out?
10:43:59 * vincenz peers
10:44:28 <mauke> how does it not work?
10:44:36 <ell-hask> From GHCI:
10:44:46 <ell-hask>     Couldn't match the rigid variable `b' against the rigid variable `a'
10:44:47 <ell-hask>       `b' is bound by the type signature for `>>='
10:44:47 <ell-hask>       `a' is bound by the type signature for `>>='
10:44:47 <ell-hask>       Expected type: b
10:44:48 <ell-hask>       Inferred type: a
10:44:48 <ell-hask>     In the first argument of `State', namely `(a, False)'
10:44:49 <ell-hask>     In the definition of `>>=': >>= (State (a, False)) f = State (a, False)
10:45:00 <vincenz> ah yes
10:45:05 <mauke> the type is wrong
10:45:09 <vincenz> yep
10:45:14 <vincenz> f is of type a -> b
10:45:16 <mauke> >>= must return m b, not m a
10:45:19 <vincenz> ermm
10:45:21 <vincenz> a -> m b
10:45:30 <vincenz> and you're returning the same as the input, m a
10:46:15 <ell-hask> Humm... to me it looks the same as the line above it; (State (a,True)) >>= f = f a
10:46:33 <ell-hask> because (f a) returns... no wait... I am seeing that
10:46:54 <vincenz> f :: a -> m b
10:49:23 <ell-hask> But why can't I just do (State (a,False)) >>= f = (\_ -> State (A,False))?
10:50:01 <vincenz> cause depending on the input
10:50:03 <vincenz> the type is different
10:50:04 <vincenz> you have
10:50:11 <vincenz> State >>= function 
10:50:17 <vincenz> now if the state is true, you return tyoe m b 
10:50:22 <vincenz> and if it's false the original type m a
10:50:25 <vincenz> this is not welltyped
10:50:33 <ell-hask> but a = b
10:50:38 <vincenz> ah
10:50:40 <ell-hask> type a is type b
10:50:49 <esap> ell-hask: no, a is not the same type as b.
10:50:58 <vincenz> esap: maybe it is for his system
10:51:16 <vincenz> ell-hask: that's the limitation I think...
10:51:26 <int-e> then it's not a monad. a monad supports >>= of type m a -> (a -> m b) -> m b for arbitrary types a and b
10:51:28 <vincenz> ell-hask: cause the typeclass monad is typed that way
10:51:29 <esap> vincenz: I assume he means a and b in (>>=) :: m a -> (a -> m b) -> m b. In there, a and b cannot be the same.
10:51:35 <vincenz> esap: nono
10:51:48 <vincenz> m a -> (a -> m b) -. m b
10:51:52 <vincenz> if your func is a -> m a
10:51:57 <vincenz> you can't take advantage of this internally
10:52:09 <vincenz> cause the monad is generally typed as a -> m b
10:52:17 <vincenz> it doesn't know you're passing it a (a -> m a)
10:52:28 <vincenz> you might pass it a (a -> m b) somewhere else
10:52:45 <ell-hask> Ok, but how do I get this to do what I want?  I just want it to pass the state and a "False" if (snd s) is false
10:53:02 <vincenz> first of all
10:53:15 <vincenz> ell-hask: this is an incorrect monad
10:53:18 <vincenz> where is the VALUE of the monad action
10:53:20 <vincenz> it's not there
10:53:23 <ell-hask> I know I can use Maybe, but that isn't as useful.
10:53:25 <vincenz> you equate state and value and hence run into this
10:53:38 <vincenz> a proper state monad is
10:53:43 <vincenz> State -> (SOMEVALUE, State)
10:54:04 <vincenz> or is the Bool your state?
10:54:10 <int-e> ell-hask: maybe you want the either monad.
10:54:31 <ell-hask> Well, I could invert my current definition of State.  My State is a list: data State a = State (a,Bool) deriving Show
10:54:31 <vincenz> int-e: EIther is not a monad, is it?
10:54:54 <vincenz> int-e: pretty certain it's not
10:54:57 <ell-hask> where 'a' is typically [Items]
10:54:59 <int-e> vincenz: hmm. it ought to be.
10:55:04 <vincenz> ell-hask: that's not a state
10:55:10 <mauke> Either String might be
10:55:19 <vincenz> ell-hask: a monad needs a return value
10:55:20 <vincenz> mauke: nope
10:55:26 <vincenz> mauke: Either ErrorMgsg
10:55:28 <ell-hask> Yes, the return value - that is the Bool
10:55:34 <vincenz> oh
10:55:36 <ell-hask> in my mind
10:55:40 <vincenz> well erm
10:55:48 <vincenz> then the design is completely borked
10:56:07 <ell-hask> Well... good thing Haskell isn't my day job... yet :-)
10:56:11 <esap> In Monad, the *user* of the monad decides the *type* of the return value. You can't fix it within the monad.
10:56:23 <vincenz> esap: and... his actions return teh state as well
10:56:27 <vincenz> esap: it's not hidden under the monad
10:56:41 <vincenz> if you get what I mean
10:56:43 <vincenz> can't formulate it properly
10:56:55 <mauke> isn't this like Maybe, only borken?
10:56:57 * esap didn't understand that.
10:57:12 <vincenz> mauke: yeah
10:57:17 <vincenz> State should be some sort of
10:57:20 <ell-hask> Yes - mauke, I wanted a Maybe that would return the state and False instead of "Nothing"
10:57:21 <vincenz> State st a = \st -> (st, a)
10:57:27 <vincenz> state monads must be fucntions 
10:57:43 <ell-hask> ok
10:57:50 <vincenz> and then you make extra actions
10:57:52 <vincenz> to return the state
10:57:53 <vincenz> something like
10:57:58 <vincenz> get :: State st st
10:58:06 <vincenz> which does internall \st -> (st,st)
10:58:28 <vincenz> should really read the nomaware course on monads
10:58:40 <vincenz> http://www.nomaware.com/monads/html/
10:58:43 <ell-hask> Thanks
10:59:04 <vincenz> welcome
10:59:08 * int-e thinks there is confusion about the meaning of 'state'.
10:59:23 <shoJitou> Is there any page like that for arrows?
10:59:33 <ell-hask> Perhaps there is: int-e, I'd be happy to listen to what you might have to say on it.
10:59:46 <vincenz> http://www.haskell.org/arrows/
11:00:23 <int-e> ell-hask: the state monad carries a state through the monad calculation in addition to the value of the computation (the value is what you can affect with 'return' and extract with '>>=')
11:00:27 <kowey> shoJitou: i also started trying to write a tutorial http://en.wikibooks.org/wiki/Programming:Haskell_arrows
11:00:42 <kowey> shoJitou : but then again, i haven't the slightest clue what i'm talking about, it was more a learning exercise for me
11:00:45 <shoJitou> vincenz, I read it,but I wasn't really clear on how they isolated real side-effects like IO
11:00:55 <shoJitou> kow, thanks
11:01:16 <kowey> i also ran out of time and so never got beyond the bare basics
11:01:25 <shoJitou> kowey, oh, I actually read that:)
11:02:33 <vincenz> LOL
11:02:35 <vincenz> clonematic 3000
11:02:52 <xerox> The latter part of the wikibook looks like shapr's article.
11:03:16 <kowey> it is
11:03:21 <xerox> !
11:03:28 <kowey> (with his permission, of course)
11:03:33 <xerox> Great =)
11:04:41 <int-e> ell-hask: What I think you wanted is this: data Computation a b = Return a | Value b; instance Monad (Computation b) where Return a >>= _ = Return a; Value a >>= f = f a; return = Value ... and then have a  abort :: a -> Computation a a; abort a = Return a.
11:05:25 <int-e> maybe s/Return/Aborted/g
11:09:02 <int-e> (and that is isomorphic to Either. I still don't understand why it doesn't have a Monad instance.)
11:11:08 <int-e> hmm. instance (Error e) => Monad (Either e) where ...
11:11:20 <int-e> ah, too sad. this wouldn't have happened if there were a MonadFail class.
11:14:54 <xerox> MonadError IIRC
11:16:01 <int-e> xerox: I was quoting from Control.Monad.Error; the Error class is used to implement 'fail' for Either e ...
11:16:04 <shoJitou> If I create my own length function, how do I access the length in Data.List?
11:16:43 <mauke> Data.List.list
11:16:54 <int-e> xerox: and that wouldn't be necessary if fail where in its own class
11:17:29 <int-e> were.
11:17:32 <shoJitou> it says, 'Not in scope: `Data.List.length''
11:18:15 <mauke> import qualified Data.List
11:18:56 <shoJitou> oh, I have to import it to use it like that? I thought it would be like C#. Thanks.
11:19:10 <int-e> hmm, Prelude.length should work though?
11:19:38 <eivuokko> shoJitou, in general, import qualified Prelude; import Prelude hiding (foo); foo = ..
11:19:41 <shoJitou> indeed, it does:)
11:19:50 <int-e> but yes, you have to import it. Prelude just happens to be imported automatically.
11:20:07 <int-e> unless you do it explicitely like eivuokko suggests.
12:07:46 <yip> hm.... c# programmer upgrades to haskell
12:10:03 <araujo> all programmers are upgrading to haskell
12:10:06 <araujo> :-)
12:11:46 <yip> haskell programmer upgrades to visual basic:
12:12:01 <yip> http://blogs.msdn.com/sriram/archive/2006/04/11/573731.aspx
12:12:41 <vincenz> hah
12:18:05 <kolmodin> waern: how's code?
12:31:50 <Spark> yip: my research group read that paper recently
12:31:59 <Spark> i was in the dentist during the meeting though
12:33:27 <vincenz> aha
12:33:29 <vincenz> there you re mauke 
12:33:36 <mauke> huhu
12:33:38 * vincenz had detached the two names
12:34:03 <vincenz> haskell's great \o/
12:35:12 <mauke> that reminds me, I need to look at hat
12:37:22 <yip> Spark: what do you think of that paper?
12:37:39 <Spark> i didnt read it unfortunately
12:37:44 <Spark> ive had it on my desk though for a while
12:37:49 <Spark> i'll probably read it eventually
12:39:01 <Spark> basically the idea is that the vb people realise that everyone thinks vb is a joke, so they are a lot more willing than say the c# people, to put research ideas into the language
12:39:50 <Dreadshoot> Spark: i dont believe that at all
12:40:47 <Dreadshoot> vb is often used by beginners who dont even care. c# is an example that some c++ people would use for some developement to get a little more high level
12:41:17 <Dreadshoot> and also much used generally today, since companies seem to like it
12:42:06 <Spark> what are you saying exactly?
12:44:24 <Dreadshoot> that your last statement is wrong, beginners top priority is nothing close to research ideas. They want to develope stuff real fast, that works descent and with as little manual/ref reading as possible
12:44:53 <Dreadshoot> and you can replace beginners with "most VB people" in that sentence if you like
12:44:54 <Spark> by vb people, i mean the people at MS who control the language and implementation
12:47:53 <Dreadshoot> hmm, how would you know that?
12:49:08 <Dreadshoot> mms://wm.microsoft.com/ms/msnse/0604/27530/Brandon_Bray_VC2005_MBR.wmv this is a video i saw earlier, its from one of the c++ compiler developers at MS, looks like they spend pretty much time into research
12:51:00 <Dreadshoot> c# takes much of the market from vb today, and i would think the c# poeple put at least or more research ideas into the language than vb because its developing much more and much more people draws to it
12:52:12 <Spark> Dreadshoot: because its what erik said to my supervisor
12:52:29 <Dreadshoot> erik?
12:52:44 <Spark> the guy who wrote the paper referenced above
12:52:52 <Spark> who works at ms research, cambridge
12:53:07 <Spark> and is into haskell and compilers and FLI and stuff
12:54:16 <Dreadshoot> ah well, c# is growing so way much faster so there's not much logic why vb would research more. basic is an OLD language
12:55:00 <Spark> its only an old language if they dont change it
12:55:27 <Dreadshoot> no, its old as it has existed for a long time
12:55:47 <Maddas> Haskell wasn't exactly invented yesterday either :-)
12:55:56 <damg> except keywords vb.net has nothing to do with vb and older basic-derivates anymore :)
12:58:03 <damg> thus it is easier to get a java programmer and to tell him to code c# than to get a vb6 (or other basic-) programmer and to tell him to code vb.net - that's why c# is growing much faster ;) vb-people stayed on vb or switched to c#
13:00:24 <Spark> vb is just a deeply unpopular brand at the moment
13:05:26 <Spark> if they changed the syntax (which is just branding) and renamed it c% it would probably be used more ;)
13:05:41 <Dreadshoot> at the moment? do you really think it will pop up and grow in some weird way?
13:05:43 <damg> same as f# :)
13:06:38 <Dreadshoot> MS has hardly even bothered to write much about f# in public/commercial
13:06:54 <damg> the most thing which annoys me that all the pascal developers have to switch to java etc just because the managers heard that delphi will be unsupported and never heard of freepascal. So much knowledge/time wasted
13:07:29 <Dreadshoot> pascal was fun when you used like turbo pascal in console environment for developement :)
13:09:03 <Cale> How is VB.net really all that different from previous versions of VB? They added a few neat language features, but it doesn't look all that different to me.
13:09:09 <damg> hehe, freepascal is as powerful as its c++/java counterparts and nevertheless I've seen a lot of firms abandon their (huge) old code bases just because they weren't aware of freepascal :)
13:10:04 <araujo> Cale, it isn't
13:10:08 <araujo> Hi
13:10:12 <Cale> Probably the most significant change that I can see in this list is the addition of generics.
13:10:29 <Cale> (basically universally quantified type variables)
13:11:38 <damg> Cale, the old vb codebase is fully incompatible with vb.net
13:12:09 <damg> basically vb.net is a search-and-replace of c# keywords with vb ones :)
13:12:18 <Cale> But it's not so different that VB programmers couldn't write it.
13:12:53 <Cale> (this is assuming that they knew what they were doing in the first place)
13:13:36 <Dreadshoot> Cale: probably anyone could write it, after picking it up from the trash can
13:14:03 <Dreadshoot> its the asp.net that could be usable
13:14:07 <araujo> Cale, im not sure if that's good to assume wih VB programmers...
13:14:11 * araujo boings
13:14:14 <Cale> It doesn't really look much worse than C# or Java
13:14:24 <eivuokko> There's plenty of peopel who aren't really programmers that use vb for convience tasks, not real applications in any sense.
13:14:35 <eivuokko> Changing anything breaks those people's routines.
13:14:38 <Dreadshoot> it looks much worse, especially the syntax
13:14:45 <Cale> really?
13:14:57 * Dreadshoot wants the ;
13:14:59 <Cale> the examples I'm seeing look pretty much how I remember VB looking.
13:15:00 <Dreadshoot> :P
13:15:07 <araujo> eivuokko, That's what VB shoud be used for.
13:15:14 <damg> :P
13:15:18 <eivuokko> araujo, Yeah, like shell scripts.
13:15:27 <Cale> Non-optional semicolons are annoying.
13:16:24 <Dreadshoot> Cale vb must be like reading a book without any sentences/dots
13:16:32 <araujo> eivuokko, VB is a development IDE for non-programmers.
13:16:47 <Dreadshoot> like a kids book with just images :)
13:16:52 <Spark> its no more for non-programmers than php is
13:17:29 <Spark> the difference is no insecure geek wants the stigma of being a vb programmer
13:17:29 <araujo> is php a language?
13:17:31 <araujo> :-)
13:18:04 <Dreadshoot> no uni's wants vb either
13:18:05 <damg> php is a language by definition ;)
13:18:19 <Dreadshoot> not any good ones at least
13:18:25 <damg> yeah, unis jumped onto the c#/java train, too
13:18:44 <Dreadshoot> c/c++/java/c#/lisp
13:18:46 <Cale> I don't see why they care, if they'll pick C# or Java.
13:18:49 <araujo> mm.. well, that's because they are jumping to c#/java
13:18:57 <Cale> (which are both languages which are just as terrible)
13:19:08 <araujo> Sun got a worldwide campaign for promoting java in the univ.
13:19:27 <Cale> Yeah, it's probably got more to do with money than anything.
13:19:39 <eivuokko> And good base of basic services.
13:19:41 <Spark> you know what gilad said about static typing?
13:19:47 <eivuokko> Like application servers etc
13:20:06 <Cale> I'd hate to have to teach using Java.
13:20:09 <Dreadshoot> i think as eivuokko said also, not as crappy as vb, but at least faster developement than c
13:20:14 <Spark> "there would be no static typing in mainstream programming languages if it did not give you speed advantages -- the documentation / error detection advantages mean nothing"
13:20:18 <Dreadshoot> with a descent code base
13:20:24 <Cale> Spark: haha
13:20:36 <araujo> eivuokko, i still don't know why they say java is good for servers..... or internet,
13:20:51 <araujo> i can think of many more languages best suited for internet.
13:21:17 <Spark> because of web applets
13:21:23 <eivuokko> araujo, They are selling it, of course they say that.  You know newspaper or something salesmen that call you?  Do you think they always even read magazines they read? :)
13:21:28 <Spark> and the "write once run anywhere" thing
13:21:34 <araujo> bah, that old technology Spark ? :-)
13:21:38 <eivuokko> *they sell
13:21:48 <Spark> hardly anyone uses web applets though, everyone wants to use flash :)
13:22:00 <eivuokko> Heh.
13:22:08 <eivuokko> Even worse environment to develop ;)
13:22:14 <eivuokko> +in
13:22:15 <kane77> OK... I have to choose a subject for next semester... should I choose something called Functional and object programming... I'm doing OK with C...
13:22:19 <araujo> eivuokko, i know. But i wonder from a techincal point of view.
13:22:30 <Maddas> kane77: Depends on your motivation, I guess :-)
13:22:45 <Spark> how well does haskell compile to jvm code? :)
13:22:54 <kane77> Maddas is Haskell hard??
13:23:00 * Maddas shrugs :-)
13:23:12 <eivuokko> Spark, I recall there was some problems in presenting closures in jvm.
13:23:12 <Dreadshoot> kane77: semester? take a scuba diving subject or something instead :)
13:23:32 <kane77> Dreadshoot, verry funny...
13:23:33 <eivuokko> Spark, very slow and akward or something.
13:23:36 <Spark> eivuokko: java almost has closures with its anonymous classes - it cant be that hard
13:23:49 <Spark> maybe it is slow
13:23:53 <eivuokko> Spark, Yeah, I know.  But that's what I recall...might I remember wrong.
13:24:01 <araujo> Spark, you know, i think it'd be nice a compiler from Haskell to jvm bytecode.
13:24:02 <Dreadshoot> kane77: not that bad
13:24:14 <Cale> kane77: Haskell is really not any harder than C, but the manner in which your knowledge as a C programmer transfers is not very direct, so it's probably best to forget that you know anything about programming when learning it.
13:24:18 <araujo> Spark, i could have fun in my univ then.
13:24:21 <Maddas> kane77: It's very different from C, really. 
13:24:46 * mux heartily agrees
13:24:50 <Dreadshoot> if you know c, you should learn c++ and oo
13:24:55 <kane77> Maddas I've heard...
13:25:03 <Cale> In fact, I think C might even be considerably harder for someone who knew nothing about programming already.
13:25:23 <Maddas> I wouldn't want to label languages as hard or easy, some people find some languages easier to learn, other people others... especially if you've already got a certain background.
13:25:24 <araujo> Dreadshoot, wat kind of deadly piece of advice is that?
13:25:30 <Spark> if you already understand induction / recursion then functional programming is probably easier than imperative
13:25:31 <mux> I find Haskell much harder than C, but I've done C for more than 10 years before startng haskell
13:25:32 <Maddas> Dreadshoot: Why?
13:25:33 <yip> it's good to know c AND haskell
13:25:34 <kane77> Dreadshoot, there's no such option... (apart from Java which I'm taking
13:25:51 <woggle> Java is almost C++. (;
13:25:56 <Cale> Well, it's good to know as many languages as you have time to learn :)
13:25:58 <araujo> mux, you are to biased ;-)
13:26:03 <Dreadshoot> araujo: hehe maybe the wrong channel for it, but c++ rules and and is better than c.
13:26:06 <yip> i think it's even more important to know c then to know haskell
13:26:07 <mux> probably yeah
13:26:16 <Maddas> araujo: Anybody knowing Haskell is very biased too, since you already succeeded in learning it :-)
13:26:16 <mux> Dreadshoot: WHAT?
13:26:27 <mux> this is the stupidest thing I've read in this channel yet
13:26:44 <araujo> Maddas, it isn't biased to know the 'light'
13:26:45 <Spark> c++ was a good first attempt at fast OOP
13:26:47 <araujo> :-]
13:26:48 <Maddas> kane77: see, this is what I meant with opinions being very relative ;-)
13:26:58 <Cale> C++ and Java look like the same language, and C doesn't look too different from them when you also know Haskell.
13:27:08 <Dreadshoot> mux: nothing stupid with it, you dont know much if you think that is stupid, c++ is VERY widely used
13:27:15 <Spark> C is annoying because you cant do things like put initial values into a struct
13:27:20 <mux> Dreadshoot: hahahaha
13:27:25 <Maddas> Dreadshoot: You're confusing popularity with quality.
13:27:27 <mux> thank you for making my day better
13:27:28 <Cale> Spark: yeah, that is annoying
13:27:30 <Spark> you have to write a my_struct_init(my_struct *this) function
13:27:33 <kane77> WOW it's starting to get hot in here...
13:27:46 <eivuokko> Heh.
13:27:48 <Cale> hehe
13:27:53 <Dreadshoot> Maddas: No i aind, the popularity of it is pretty much based on the quality
13:27:55 <Maddas> Cale: Wouldn't you say that C++ still looks very different from C even if you know Haskell?
13:28:09 <mux> Dreadshoot: if you don't have any other argument than "you must not know much about X", you're in trouble
13:28:11 <Cale> Maddas: not nearly as different as when you don't
13:28:22 <yip> a lot of the main improvements that c++ made to c were "backported" to c
13:28:33 <Dreadshoot> mux: no i aint cause its alost better than yours "hahahahah, i got no argument at all"
13:28:41 <araujo> Cale, java is Sun's C++
13:28:47 <mux> you are the one who stated "C++ rules, it's better than C"
13:28:48 <Cale> araujo: yeah, basically
13:28:49 <Maddas> Cale: But when you do know Haskell, you can better see why e.g. C++ templates are used in certain ways
13:28:53 <mux> you are the one who needs to show proofs
13:28:55 <mux> and arguments
13:29:01 <Cale> Maddas: sure
13:29:09 <Maddas> Cale: And I'd think that you'd also miss them a lot more when going 'back' to C
13:29:15 <mux> comparing C and C++ like you do, without any context, makes no sense, at best
13:29:21 <Cale> Well, you'd miss other stuff just as much
13:29:32 <Maddas> Right, that's what I mean  :)
13:29:35 <Dreadshoot> mux: no i dont, most c code will probably be valid c++ code, just c++ has ALOT of extra that you can choose to or not include in your projects, and that adds benefits like faster developement and OO
13:29:54 <Cale> So, C++ and C would be about equally irritating to write code in, at least for me.
13:30:22 * araujo could still write code in C, but not in C++ or java
13:30:22 <Dreadshoot> mux: you havent added one real argument yet so
13:30:22 <Cale> C++ has a bunch of extra features, but they tend to be handled in somewhat broken ways.
13:30:25 <Maddas> Cale: Okay, I could agree with that :-)
13:30:42 <Dreadshoot> Cale: broken in what ways?
13:30:43 <Spark> you know what really suprises me about java?  covariant arrays
13:30:46 <eivuokko> Cale, I think you'd find C++ pretty diffrent if you made significantly sized project in it and had exposure to people who don't go around singing hallelujah for oop.
13:30:48 <Spark> what the hell is that about?
13:30:50 <mux> Dreadshoot: argument for what? *I* didn't make any claim besides that your comparison makes no sense
13:31:00 <Spark> you dont even get contravariant arguments but you get covariant arrays!
13:31:05 <Spark> whats next, covariant fields?
13:31:07 <mux> you cannot just say stuff like "C++ > C"
13:31:10 <mux> the world is not that simple
13:31:17 <Dreadshoot> mux: exacly and all your childish behavior with "Hhahahaha and all uppercase answers"
13:31:22 <mauke> C++ > C? zomg UB!
13:31:24 <eivuokko> Cale, pretty diffrent from C, that is.
13:31:25 <Maddas> Dreadshoot: You can't add things to a language without losing other things. With C++, you lost a *lot* of the conceptual simplicity you have in C when looking at code
13:31:27 <Cale> eivuokko: I'm aware of the differences -- they're significant if you're a C or C++ programmer.
13:31:43 <Maddas> mauke: UB? :)
13:31:48 <Spark> luckily i suspect hardly anyone uses covariant arrays
13:31:49 <esap> C++ has lots of broken features: 1) sizeof 2) the this pointer 3) default implementations of class members ....
13:31:51 <mauke> undefined behavior
13:31:51 <mux> omg
13:31:54 <Cale> They're just not such large differences when you see how many features both languages lack.
13:32:07 <mauke> C++ > C violates sequence point rules
13:32:13 <Spark> and with generics, theyre probably redundant anyway
13:32:16 <Dreadshoot> Maddas: not really, STL/classes is giving you a better/earlier look to work with in large projects
13:32:17 <Maddas> mauke: ah :)
13:32:23 <sjanssen> mauke: hahaha
13:32:33 <Cale> Templates could be far far cleaner.
13:32:39 <Maddas> mauke: or "C++ adds to C but returns the same value", as they say.
13:32:44 <Spark> templates arent even type-checked are they?
13:33:06 <esap> Spark: Templates in C++ are type checked.
13:33:07 <mauke> yeah, templates are like dynamic typing at compile time
13:33:24 <Dreadshoot> Cale: thats true, and some people dont use them, or dont use them in some projects/platforms. But stl/company alternative for example is very commonly used
13:33:50 <Cale> Well, they're a good idea, but they're broken.
13:34:04 <Cale> not to mention that the syntax is painful
13:34:12 <eivuokko> Are you sure it's not template's interaction with other language features are broken?
13:34:45 <Dreadshoot> I wouldnt go that far, they are very good for certain stuff, and the syntax aint that hard, just a little messy at the start
13:35:06 <eivuokko> I don't find C++ templates really broken, they are fairly intuitive except when you have to mix them with some other features like inheritance, some overloading rules and conversion rules.
13:35:08 <mauke> and horrible at the end
13:35:09 <mux> live with it, C++ is the most bloated language in the universe
13:35:13 <yip> c++ designer admitted that the design of templates was rushed
13:35:17 <sjanssen> two C++ debates in two days?  not a great trend . . .
13:35:18 <mux> that does not mean that it's necessarily bad
13:35:42 <mauke> anything nontrivial with templates is just painful :(
13:35:45 <mux> but it's certainly not good at anything, and you certainly cannot assert harshly that "C++ is better than C"
13:35:46 <yip> templates complicate the compilation and linking process of c++ do to problems with template instantiation
13:35:55 <Maddas> sjanssen: One would expect people to be busy discussing the Eurovision song context now, isn't it :)
13:35:55 <esap> C++ templates interact very badly with other features of C++. The template instantiation system is a mess.
13:36:02 <Cale> Well, the typing system for templates is Turing complete.
13:36:15 <mauke> for example, try writing a compile-time parser in templates
13:36:20 <Spark> esap: yeah i mean the instantiation is checked, but not the template itself
13:36:25 <Spark> esap: its just a glorified #define isnt it?
13:36:33 <yip> mux: when c++ was first designed, one of the major goals was to fix the tying in c, making it more static. this was a success and the results were ported back to c
13:36:37 <Dreadshoot> mux: "<mux> but it's certainly not good at anything" this just shows you know nothing what you are talking about
13:36:39 <Cale> and I think the fact that they operate at compile time, and actually generate extra code based on where they're instantiated in the full program seems silly
13:37:00 <mux> Dreadshoot: oh, I'm a fool to think that C++ sucks at some stuff?
13:37:00 <esap> Spark: There are also constraints that apply to the template itself, not its instantiations.
13:37:09 <mux> great news
13:37:10 <esap> Spark: Like the name lookup rules.
13:37:16 <Dreadshoot> the fact stands that generally c++ could be said to be c + extras which you choose to use/not use or partially use
13:37:18 <Maddas> Dreadshoot: You didn't exactly provide detailed arguments either.
13:37:20 <eivuokko> Spark, it sounds like you have been using few year old compilers, with correct two-phase template lookup a lot is checked on templates.
13:37:20 <Cale> Especially when the primary thing that they're used for is to get the equivalent of universally quantified types.
13:37:22 <mux> Dreadshoot: you should learn more about who you're talking to when spouting attacks liek this
13:37:39 <Dreadshoot> mux: you said its not good at anything
13:37:41 <Spark> i havent written any c++ for err about 6 years :)
13:37:48 <Spark> and i dont think i used templates much back then
13:37:51 <Spark> as i was just a kid
13:37:53 <mux> Dreadshoot: doesn't that mean the same as "it sucks at some things" ?
13:37:55 <araujo> esap, I think that's because they have been designing sub-systems inside C++ to extend the language. And definetly , imperative languages aren't enough flexible to do that so they get messy 
13:37:57 <Dreadshoot> mux: i know about this, thats the defference, you obviously dont
13:37:59 <basti_> advocacy again?
13:38:11 <mux> Dreadshoot: you seem to be the only one convinced of this
13:38:43 <esap> araujo: I think C++ was intended not to be extensible. It was instead intended to be complete (e.g. you should be able to write basically any kind of program with C++)
13:38:44 <Cale> C++ certainly is a different language from C, in that to write what is considered good C++ code, you do a very different thing from what you do when you write what is considered good C code.
13:38:50 <Dreadshoot> mux: no thats not the same thing, it sucks at all things is the same meaning
13:39:01 <mux> my bad, s/anything/everything/
13:39:15 <Dreadshoot> mux: no, all the other millions of c++ coders also
13:39:16 <Spark> i think bjarne would have liked them to be more similar but there were differences that emerged and solidified
13:39:18 <Dreadshoot> and companies
13:39:19 <Spark> i read that somewhere
13:39:33 <Spark> things like casting malloc
13:39:37 <Cale> But they're both pretty awful to have to write code in, and the list of capabilities that they both lack is longer than the list of differences between them.
13:39:54 <mauke> I never cast malloc
13:39:54 <Dreadshoot> its millions of c++ coders vs mux
13:39:56 <Maddas> Dreadshoot: Many people use it out of necessity.
13:40:03 <lumi> How many PHP coders are there?
13:40:04 <mux> Dreadshoot: you are completely off track
13:40:08 <Dreadshoot> Maddas: as with everything
13:40:20 <mux> you seem to be thinking I said "C++ sucks" while I never, ever said that
13:40:24 <esap> araujo: The thing is, the C++ design attempts to cover all combinations of its features. But they are pretty bad at being orthogonal, so the interaction is complex.
13:40:25 <araujo> esap, it wasn't designed for that precisely (and neither for pure OO), but they are too stubborn to seee the  facts.
13:40:27 <Dreadshoot> mux: no you are, when you say all people that use c++ are wrong
13:40:34 <mux> Dreadshoot: I never said that either
13:40:35 <Spark> mux, Dreadshoot: yawn
13:40:38 <mux> at that point I'll stop arguing
13:40:41 <Dreadshoot> mux: you did
13:40:42 <mux> if you can't even read properly
13:40:46 * mux &
13:41:19 <Dreadshoot> mux: c++ coders thinks its better than c, thats why they use it.
13:41:36 <tolik> oh, don't fight, the Right Way to improve C code is to make Haskell bindings
13:41:39 <araujo> esap, That's because they have followed the path of 'multiparadigm' programming in a not extensible programming language.
13:41:42 <eivuokko> Dreadshoot, I doubt that's true.  Most coders don't really think, it's just a job and they do it best they can.
13:41:43 <Maddas> Dreadshoot: No, many use it out of necessity.
13:41:44 <mauke> Dreadshoot: and vice versa
13:41:49 <esap> araujo: It's clearly not possible to change C++ to the better for many of its defects, because it's already too widely used.
13:41:55 <Cale> C++ gives you various abstractions which you can use to get some pretty impressive stuff happening if you know what you're doing, but the amount of trouble you normally have to go to, in order to even get some pretty simple things is ridiculous.
13:42:00 <Cale> Look at Boost.Lambda
13:42:07 <Maddas> Dreadshoot: I use it because the existing code was written in C++. That because required libraries were written in it.
13:42:08 <Dreadshoot> eivuokko: you think most coders work with it? i can tell you that is wrong
13:42:47 <eivuokko> Dreadshoot, I can't possibly how you came up with that quoestion from my comment, please elaborate.
13:42:59 <esap> araujo: actually, C++ has been too widely used to be changed for about 20 years :-)
13:43:14 * Maddas was intrigued by Oleg's definition of lambda (using #define )
13:43:20 <Dreadshoot> eivuokko: you said "its just a job"
13:44:13 <Philippa> the majority're in Java, sure
13:44:18 <araujo> esap, i don't argue that, though it isn't also the only widely used language atm. 
13:44:21 <esap> The big advantage of C++ over many other languages is that it supports many different paradigms, which you can mix in the same program if you want. It's not possible in, say, Java.
13:44:24 <Philippa> but C++ isn't really *good* at anything. It's very much jack-of-all-trades
13:44:53 <eivuokko> Dreadshoot, Ok, I meant that: Most coders do not think <insert language, buzzword and so on> and just want to get their job done so they can go home.  Meaning: they don't really care about programming languages.
13:45:07 <Philippa> Java's very distinctly single-paradigm though. More so than smalltalk, if you're in that kind of mood
13:45:12 <Cale> A lot of the Boost libraries use insane tricks to get some admittedly neat things going, but they're all things which you can do in Haskell with far less complication.
13:45:13 <eivuokko> *think about
13:45:43 <Philippa> Cale: bingo. The abstraction cost in C++ gets pretty high the moment object/class aren't the appropriate abstraction
13:45:56 <Cale> right
13:46:06 <Philippa> C++ makes a shitty metalanguage
13:46:08 <joe_k> eivuokko: do you make the distinction between "coder", "software engineer", "designer", "architect".... if you are any step above a fill-out-the-code-template monkey you want power
13:46:11 <esap> Even in Haskell, writing OO code is somewhat a pain. The syntactic sugar is just not there :-)
13:46:35 <Philippa> that, and the type system actively gets in your way still. Though we know ways to fix that one
13:47:02 <araujo> esap, That was my point, c++ is an imperative language that isn't designed for being multiparadigm without introducing lot of sub-systems and getting bloated 
13:47:11 <Philippa> (why yes, I do consider HList and its descendants to be as "bad" as some of Boost. Admittedly the less insane parts of Boost)
13:47:15 <eivuokko> joe_k, it is hard to say, because I find many of the designer and architect level people don't write that much day-to-day code and engineer is more title based on paper from univ or school.  
13:47:22 <araujo> esap, and that's because, it isn't extensible, as you also said
13:47:39 <araujo> the whole model is doomed to be bloated forever.
13:47:43 <eivuokko> joe_k, But in my experience, no most of the people writing code in any role, don't care about things like what programming language it is in, if they know it enough already.
13:47:45 <Philippa> eivuokko: software engineer's not a paper-based title though
13:47:51 <Dreadshoot> Cale: well, when you get a big code base and stuff like boost it speeds up developement, its also most of the time coding is probably not hitting the keyboard.. but thinking/organizing and so on
13:47:56 <eivuokko> Philippa, Eh?
13:48:10 <Philippa> eivuokko: I'd run like hell from writing anything resembling a compiler in Java...
13:48:31 <esap> araujo: OTOH, it's unavoidable once people start to use the language. You can only extend it in conservative ways, which means you can't fix any really major problems.
13:48:31 <eivuokko> Philippa, You obviously care aren't one of the pople I was describing
13:48:31 <Cale> http://www.boost.org/boost/math/octonion.hpp -- who made this? I can't believe that a human being would actually sit down and type all this out.
13:48:38 <Cale> and that's just the header
13:48:39 <Philippa> eivuokko: you can't call yourself, say, a civil engineer in the UK without paper. You can call yourself a software engineer
13:48:49 * araujo wanted to assign the 'Haskell to jvm bytecode' task to Philippa :-)
13:48:52 <joe_k> as a programmer I am a designer of programs, algorithms, and systems.... and then I code them.... i think "coder" tends to imply something less
13:48:55 <Philippa> eivuokko: I cared back before I was a PLT geek though. It's just damn painful
13:49:20 <araujo> esap, But why to doit like that?, why not to use a better language then?
13:49:24 <Philippa> joe_k: depends who you're talking to. You seem to have "coder" synonymous with what I'd call "code monkey"
13:49:26 * esap wonders how C++ templates would work currently if C didn't have 'sizeof'. I bet it would be way different :-)
13:49:38 <joe_k> yes thats what I think of as "coder"
13:49:42 <joe_k> like "typist"
13:49:50 <Philippa> Forcibly boxing C++ would seriously break the language in many other ways
13:49:51 <joe_k> different from "author"
13:50:04 <Philippa> to me, "coder" may well design, but isn't someone who architects
13:50:29 <Philippa> they probably don't design new algorithms very often, but then a lot of people don't really
13:50:30 <esap> araujo: There are problems with all languages. C++ has advantages due to it being widely used [say because it's clear it will be around for the next 30 years...]
13:50:40 <eivuokko> Philippa, I didn't mean to say software engineer is passed-test-title.  It is a title most people get for their job description *because* they have done right whatever-choose-your-course in univ or school.
13:51:10 <araujo> esap, widely used?, that's not an unique point of C++. 
13:51:12 <Philippa> eivuokko: Ah, sorry. But so're most titles that involve actual thinking
13:51:21 <eivuokko> Philippa, And I've heard that there is strong movement in UK to make software-related job titles restricted (I happen to follow C++ world).
13:51:37 * Philippa nods
13:51:41 <esap> araujo: I'm not saying it's unique point. I'm saying it's one thing.
13:51:54 <Philippa> there're some really serious problems I can see with that at present. Software engineering still isn't a sufficiently formalised discipline
13:52:02 <eivuokko> Philippa, Indeed!
13:52:04 <araujo> esap, but i still don't see how that makes c++ a good language.
13:52:07 <Philippa> the piece of paper'd likely be equivalent to UML-and-GoF-monkey
13:52:25 <Philippa> araujo: it's a better C. For many tasks, that's all that matters
13:52:30 <esap> araujo: It's not about whether C++ is a good language. C++ is clearly a horribly broken language.
13:52:36 <araujo> hah
13:52:37 <Philippa> it's a better C that'll live long enough. So it's a safe choice
13:52:47 <araujo> Philippa, wanna bet?
13:52:49 <araujo> ;-)
13:52:59 <Philippa> bear in mind that its main competitor is the other "better C"
13:53:03 <Philippa> namely Java
13:53:16 <eivuokko> C++ lives long just because it is chosen by Ms as core language for their OS.
13:53:16 <esap> araujo: However, there are other things that must be considered when you consider what to use.
13:53:53 <Dreadshoot> eivuokko: thats not true
13:53:56 <eivuokko> Hmh, that sounded exclusive.  It's one reason C++ lives long for certain.
13:53:57 <Philippa> eivuokko: that, and until comparatively recently you couldn't really touch it for 'big' GUI apps - the VB-style languages didn't have the flexibility in their form models
13:54:06 <Philippa> Dreadshoot: it's true on the PC desktop
13:54:12 <joe_k> programming languages dont die, they get ported.... or their hardware gets emulated and they live on
13:54:18 <Dreadshoot> Philippa: no it aint
13:54:23 <joe_k> consider you can download CADR machine emulator running LISP
13:54:26 <araujo> i think that neither C nor C++ will be replaced between themselves. I actually think that C++ could be more in danger of being replaced because of its direct competitor java. 
13:54:29 <eivuokko> Philippa, Yeah, and it is suprising how much latency abstractions in gui apps cause, and how fast they actually have to be.
13:54:31 <Philippa> Dreadshoot: think about it... and ignore gamedev for a mo, that's a niche market
13:54:40 <esap> Another point to consider is that C++ has been developed for a very long time. In fact, I bet it's the language whose development has took more man-hours than design of any other language.
13:54:41 <araujo> C still got a very big and loyalty community worldwide.
13:55:00 <Philippa> araujo: Java's exactly what's punishing C++ most, yes
13:55:09 <araujo> Right Philippa 
13:55:15 <Philippa> Java very much ate C++'s desktop-and-server-app lunch
13:55:33 <Dreadshoot> Philippa: no need, short gamedev aint the biggest part, but it is one. And that MS choose it is one part also, but there is shitloads of coders in linux that uses it also
13:55:46 <eivuokko> Philippa, Huh?
13:55:57 <Philippa> Dreadshoot: outside the server market, linux fails to be sufficiently significant
13:55:58 <Spark> a lot of game code is written in dynamically typed scripting languages
13:56:01 <esap> And C++ is still being developed.
13:56:02 <Spark> farcry used lua i think
13:56:08 <Spark> unreal has its own script
13:56:15 <Philippa> yeah, though UnrealScript's statically typed
13:56:16 <Spark> how did quakec work?
13:56:26 <Philippa> compiled to bytecode
13:56:29 <Dreadshoot> Philippa: it does, but you can use other languages in win also if you like without any problem at all
13:56:30 <Spark> ah right
13:57:12 <Philippa> Dreadshoot: no shit. But until comparatively recently, the only one that could seriously compete was Borland's Object Pascal
13:57:26 <Philippa> VB was playing a very different game
13:57:50 <araujo> And my *own* personal experience is the following, i use to find far far more embedded systems using C than C++.
13:57:58 * Philippa nods
13:58:04 <Dreadshoot> Philippa: yes ofc, but much people still likes c++, they aint only forced to use it
13:58:04 * Maddas nods too
13:58:34 <esap> araujo: For embedded systems, the expense at writing a compiler is the big decisive factor.
13:58:46 <Philippa> Dreadshoot: IME many of them have problems with it but don't know of anything better they can get a job doing. But hey, I never said nobody likes C++
13:59:00 <mahogny> omg. icky C++ again?
13:59:11 <araujo> mahogny, join us!
13:59:14 <Philippa> hell, once upon a time I liked C++. Then I rapidly overshot its ability to abstract
13:59:39 <Dreadshoot> I know of better, it usually is good at performance tests and there is huge resources for the languages, and its still developing the standard
13:59:56 <Philippa> any language worth using has another standard in the pipeline
14:00:06 <mahogny> I use C when I want to do anything low-level. if I don't do low-level shit, then I use about any other language than C/C++ :P
14:00:07 <Maddas> Philippa: I disagree...
14:00:12 <Philippa> thing is, C++ *can't get it right* from my point of view. It's starting on the wrong foot
14:00:16 <esap> Philippa: Heh, me too. I switched to other languages when I discovered how C++ sizeof and templates interact.
14:00:18 * joe_k tosses objective-c into the mix
14:00:31 <Philippa> Maddas: name me a counterexample? "We're expecting to do it in a while, but the new one's out" counts as in the pipeline
14:00:36 <Maddas> Philippa: Common Lisp
14:00:43 <isaacd> how do sizeof and templates interact badly?
14:00:55 <araujo> mahogny, same here, C is my *assembly* language.
14:01:09 <mahogny> araujo, yeah, it's the perfect assembly
14:01:09 <eivuokko> Philippa, well, most languages aren't actually standardised in such organisation as ISO.  And language that has standard in ISO cannot revise it on first five years, iirc.
14:01:11 <Philippa> OK, Common Lisp I might let get away with it - but I'd want to go over the standard with a comb before I'm happy to say that should be left as-is with no revision ever
14:01:42 <Maddas> Philippa: I'd certainly never claim that it should be left as-is, but there is no standard in the pipeline.
14:02:00 <esap> isaacd: you can use sizeof and overloading to compute all kinds of compile-time values based on "computation" the C++ compiler does during template instantiation and overload resolution.
14:02:04 <Philippa> and give it five years of that being true and I suspect that's going to turn into an increasingly good reason not to pick Common Lisp
14:02:05 <Maddas> (or rather, there is no more pipeline ;-)
14:02:34 <isaacd> esap: oh, just that it's a ridiculous hack?
14:02:37 <Philippa> esap: I wouldn't mind so much if it weren't for all the things you then can't do due to linker restrictions
14:02:40 <Philippa> isaacd: that's C++ :-)
14:02:50 <Philippa> most of the really powerful abstractions involve a ridiculous hack
14:03:08 <araujo> hah
14:03:57 <Philippa> that's one of the reasons I've no intention of touching serious C++ metaprogramming
14:04:16 <Philippa> you can *tell* it was an accident
14:04:21 <mahogny> lol
14:04:23 <esap> isaacd: The ridiculous hack is actually used in many libraries, because C++ lacks the corresponding native facilities for compile-time metaprogramming. It's just that C++ happened to have sizeof, so it was adopted for that purpose.
14:04:43 <mahogny> I use haskell as a metalanguage for C. really powerful meta :D
14:05:27 <esap> isaacd: Of course, I think those metaprogramming facilities are (I think) being considered in next version of C++, but nonetheless, it's ugly.
14:05:37 <tolik> mahogny: seconded :)
14:05:46 <Philippa> they're going to remain ugly and/or limited in the next version, I suspect. They'll just be a little safer
14:06:01 <Philippa> "turing complete" is no good if you can't feed it the right input in a comfortable manner
14:07:32 * esap wonders how a useful 'sizeof' like facility could be added to Haskell :-)
14:07:34 <mahogny> I think C++ pretty much live up to my expectations of industrial programming; tons of shitty hacks made by "pros". no wonder we have bugs
14:08:08 <mahogny> esap, there are stuff like that for marshalling
14:08:22 <eivuokko> mahogny, it is nothing like sizeof and how it's used in c++
14:08:29 <Philippa> esap: here, have an ImplementationIntrospectable typeclass
14:08:33 <mahogny> no, but please leave crap to C++ :)
14:08:35 <esap> mahogny: right, sizeOf is part of Storable. I mean the compile-time aspect of it.
14:08:53 <mahogny> marshalling hacks + template haskell = yay :P
14:08:58 <Philippa> mmm, point. That seems an Epigram-flavoured thing to me
14:09:51 <Philippa> mahogny: IO includes the right to shoot yourself in the foot, what else is new? :-)
14:10:05 <mahogny> Philippa, lol
14:10:22 <mahogny> Philippa, and then you can cast if you also want to aim for the head :)
14:10:41 <mahogny> if I wanted to implement a language like haskell, what would be the best parser library to use?
14:10:56 <Philippa> depends what you want out of it. Do you want to do the layout rule?
14:11:02 <mahogny> something like it
14:11:09 <Philippa> that's the big consideration. Beyond that, something like Parsec works fine
14:11:19 <Philippa> but then so'll most parsing libs
14:11:24 <mahogny> yeah, parsec would be my first bet
14:12:01 <mahogny> but I know parsec resorts to a hackish way to handle expressions an similar. I'm just a bit worried that it'll come and bite me
14:12:10 <mahogny> I mean, with priorities etc
14:12:48 <Philippa> "hackish way"?
14:13:02 <mahogny> well; semi-noncombinatoric style
14:13:04 <Philippa> you talking about chainl et al? That's not something to worry about
14:13:13 <mahogny> ok
14:13:28 <Philippa> eh? It's still combinatorial, you just want to use a particular combinator
14:13:48 <mahogny> well, just taking from memory. been a long time since last
14:14:10 <Philippa> really, it's not too hard to do expressions in it. Especially as there's an additional library for it that builds expression parsers :-)
14:14:38 <mahogny> ah. yes. that's the one I was thinking about. hm. I have to read up on it again
14:14:55 <Philippa> I've not used it myself, chainl1 was good enough
14:15:58 <mahogny> I might have found a summer project; implement a functional language for scientific programming
14:16:06 <mahogny> matlab is starting to feel limited at times
14:17:10 <mahogny> I guess you don't know of any such languages?
14:18:13 <tolik> mahogny: maple?
14:18:20 <Philippa> I'm not the person to ask
14:18:33 <mahogny> tolik, is that functional, yet high performance?
14:18:57 <tolik> er, don't about performance :)
14:19:02 <tolik> I think, no
14:19:22 <mahogny> hm. I'd like to make a FP language that can compete with fortran, yet be as easy to use as matlab
14:20:10 <tolik> Guy Steele is doing this now, iirc
14:20:20 <mahogny> oh? who's that guy?
14:20:37 <Maddas> Fortress? That isn't strictly functional, is it?
14:21:31 <mahogny> well. hm. let's see if I can beat him to it then :)
14:21:49 <Maddas> mahogny: him and whatever number of people Sun has on his team ;-)
14:22:08 <mahogny> Sun made java. just look at it; I have nothing to worry about ;)
14:22:19 <Maddas> mahogny: Guy Steele also made Scheme :-)
14:22:34 <mahogny> ok. that's makes the odds worse
14:22:49 <Maddas> mahogny: http://research.sun.com/minds/2005-0302/ (Fortress)
14:23:24 <Maddas> (Though the very first sentence sounds rather ludcrious)
14:24:26 <mahogny> hmm.. still. java. naah, I'll see what happens
14:24:54 <Maddas> Oh, by all means go ahead, I was not trying to discourage you.
14:25:34 <mahogny> it takes a train in my direction to discourage me :P
14:26:07 <Spark> fortress is quite a parallel language
14:26:22 <Spark> but otherwise very down-to-earth
14:26:26 <Spark> it has an atomic block i think
14:26:27 <mahogny> yeah. I will make my language automatically parallell wherever possible
14:26:34 <Spark> its explicitly parallel
14:26:35 <mahogny> I lack that feature in matlab
14:26:49 <Spark> e.g. there are constructs for doing things to every element of an array in parallel
14:26:52 <Spark> and stuff like that
14:31:29 <tolik> I am trying to implement xmpp streaming, what xml parser whould be good for this?
14:31:45 <mahogny> interesting language. seems quite different from mine; will be cool to compare later
14:31:45 <tolik> *would
14:36:10 <ihope> \f -> a list where each element is f applied to all the previous elements
14:36:26 <ihope> I still can't think of a good way to do that.
14:37:34 <ihope> Well, I could try anyway.
14:37:37 * ihope tries anyway
14:38:04 <mahogny> sounds like you should start from the right at least. make plenty of use of (.)
14:38:15 <Spark> isnt that just a fold?
14:38:30 <mahogny> doesn't sound like it
14:38:34 <tolik> you mean f :: [a] -> a?
14:38:42 <ihope> tolik: yeah
14:38:49 <mahogny> or...
14:38:56 <mahogny> ihope, such as summing a list, f=+?
14:38:56 <integral> iterate?
14:39:21 <ihope> This function would have type ([a] -> a) -> [a]
14:39:44 <integral> @type scanl
14:39:44 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:40:23 <mahogny> that type... makes no sense to me x_x
14:40:45 <integral> @type flip scanl [] :: ([a] -> a -> [a]) -> [a] -> [[a]]
14:40:46 <lambdabot> ([a] -> a -> [a]) -> [a] -> [[a]] :: forall a.
14:40:46 <lambdabot>                   ([a] -> a -> [a]) -> [a] -> [[a]]
14:41:05 <ihope> Wuh?
14:41:28 <ihope> @type flip scanl []
14:41:29 <lambdabot> forall b a. ([a] -> b -> [a]) -> [b] -> [[a]]
14:42:48 <tolik> @type iterate
14:42:49 <lambdabot> forall a. (a -> a) -> a -> [a]
14:42:57 <ihope> Okay, suppose our list is [a, b, c, d...]
14:43:25 <tolik> iterate (\lst -> lst ++ [f lst]) []
14:43:54 <ihope> @type \f -> iterate (\lst -> lst ++ [f lst]) []
14:43:55 <lambdabot> forall a.
14:43:55 <lambdabot>                ([a] -> a) -> [[a]]
14:44:10 <tolik> only last element
14:44:24 <ihope> Only the last element of that infinite list...
14:44:33 <ihope> Well, how do we turn [a, b, c, d] into [f [], f [a], f [a, b], f [a, b, c], f [a, b, c, d]]?
14:44:35 <tolik> yeah :)
14:45:10 <Cale> map f . inits
14:45:31 <ihope> > inits [1,2,3,4]
14:45:32 <lambdabot> [[],[1],[1,2],[1,2,3],[1,2,3,4]]
14:45:37 <tolik> I love Haskell :)
14:45:39 <ihope> Ah, thanks!
14:48:48 <ihope> Hmm, something's not right here.
14:49:57 <hyrax42> can guards be used with case?
14:50:04 <ihope> I think so.
14:51:06 <ihope> > take 20 $ inits [1..]
14:51:07 <lambdabot> [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10,11],[1,2,3,4,5,6,7,8,9,10,11,12],[1,2,3,4,
14:51:07 <lambdabot> 5,6,7,8,9,10,11,12,13],[1,2,3,4,5,6,7,8,9,10,11,12,13,14],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],[1,2,3,4,5,6,7,8,
14:51:07 <lambdabot> 9,10,11,12,13,14,15,16,17,18],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
14:51:27 <eivuokko> hyrax42, yes
14:52:00 <tolik> @type fix (map f . inits)
14:52:01 <lambdabot> Not in scope: `f'
14:52:16 <tolik> @type \f -> fix (map f . inits)
14:52:16 <lambdabot> forall b. ([b] -> b) -> [b]
14:52:41 <tolik> @type sum
14:52:42 <lambdabot> forall a. (Num a) => [a] -> a
14:52:53 <ihope> That seems to stack overflow, though.
14:54:01 <ihope> There must be a bit too much strictness there...
14:54:42 <hyrax42> @type fix
14:54:43 <lambdabot> forall a. (a -> a) -> a
14:56:37 <ihope> Ahh, I love unsafeCoerce#.
14:57:43 <yip> Cale: how would a haskell implementation of octonians compare?
15:01:18 <ihope> Hmm, it coerces [] into Nothing just fine. But if I try to coerce, say, [3] into a Maybe (Int, [Int])...
15:02:01 <ihope> ...it only gets as far as "Just (" before crashing.
15:08:01 <tolik> ihope: if you still need it, fixInits f = fix (map f . inits) where inits ~(x:xs) = [[]] ++ map (x:) (inits xs)
15:08:33 <ihope> Ah, thanks.
15:12:04 <tolik> so, what would be recommended as an xml parser for xmpp?
15:12:28 <mahogny> last time I tried to an xml lib, it crashed during installation. so... no, can't recommend one :P
15:13:24 <tolik> I was more successful :) I installed hxml
15:13:36 <hyrax42> I have haxml working
15:13:47 <hyrax42> but I think I'm using it really clunky
15:13:49 <yip> haskell xml toolbox
15:13:53 <isaacd> I have HXT working
15:14:11 <hyrax42> haxml was in darwinports, hxt wasn't
15:14:15 * hyrax42 lazy
15:14:26 <tolik> are they purely functional?
15:14:41 <hyrax42> as opposed to?
15:14:56 <tolik> expat ;)
15:15:02 <hyrax42> well haxml's parser functions has type sigature
15:15:09 <hyrax42> xmlParse :: String -> String -> Document
15:15:26 <tolik> I mean, I need something in IO
15:15:39 <hyrax42> so just use this in IO
15:16:39 <hyrax42> I dont' erally know what differences are between HXT and HaXml
15:16:53 <ihope> Hmm, realWorld#.
15:17:13 <hyrax42> the page for HXT makes it sound like it took lessons from haxml and improved (well they say it's "more general")
15:17:34 <isaacd> hyrax42: HXT also uses arrows (but equivalent to monads)
15:17:53 <hyrax42> but my tinkering with haxml is just getting away from the fact that I still dont' really know how to approach my problem
15:18:28 <tolik> hyrax42: what's your problem?
15:18:30 <hyrax42> isaacd: I think I remember reading that...
15:18:57 <hyrax42> well my "project" is intended to be a Diplomacy (boardgame) adjudicator
15:19:10 <hyrax42> my problem is more or less all of it
15:19:17 <isaacd> I think HXT is also more XML-conformant (standards wise)
15:19:23 <hyrax42> but more specifically, a satisfactory representation of the map
15:19:50 <Cale> yip: It would be far shorter. You'd have a data declaration, an instance of Num, Fractional, and Floating, and that would be it.
15:20:51 <yip> Cale: that header seems to do quite a bit more, and is apparently designed to be very efficient. also in c++ you could do a much simpler implementation but it wouldn't be as efficient i think
15:21:16 <isaacd> Is Control.Monad.RWS just (equivalent to) a convenient composition of the Reader, Writer, and State monad transformers?
15:22:23 <Cale> yip: no, it's just really long because they have the code for floats, doubles and long doubles separated
15:23:26 <yip> that too :D
15:25:11 <Cale> but in the end, it's not doing anything too spectacular.
15:26:07 <Cale> looks like there might be an instance of Read and Show in there too
15:26:43 <Cale> but I mean, look at the code for the istream operator >>
15:29:56 <Cale> the instance of Eq is just the derived one, so you wouldn't even have that code
16:31:50 <damg> hmm, I got stuck with own data types ... yet another hs tutorial doesn't show it (or ive overseen it). data List a = Nil | Cons a (List a). How do I now create a list and assign it to a variable? :rolleyes:
16:35:33 <eivuokko> You'd create list by, for example (Cons 1 (Cons 2 (Cons 3 Nil))) (outermost parens are not always neccesary, depending on context).  If you are in ghci prompt, let foo = ...  would bind foo to whatever expression.  In module scope, youd' simply say foo=... and in function you might say bar = let foo= .. in use foo or bar = use foo where foo = ...
16:37:43 <stepcut> toList l = case l of [] -> Nil ; (h:t) -> Cons h (toList t)
16:38:24 <damg> ah, thx.
16:40:03 <damg> ok, my problem were parentheses :)
17:21:00 <goltrpoat> how do type signatures work in ocaml?  it's complaining about something like fun : int -> int -> int -> unit
17:21:12 <goltrpoat> (not really sure where else to ask)
17:21:33 <lispy> goltrpoat: well, there is #ocaml :)
17:21:40 <goltrpoat> oh there is?  doh
17:21:58 <lispy> goltrpoat: hmm...i don't see anything wrong with that, other than perhaps unit has the wrong case
17:22:54 <goltrpoat> running ocamlc on that returns an error on that line, at the characters " :"
17:24:18 <lispy> i only did a microscopic amount of ocaml and it was a while ago, so I don't think i'm qualified to help :(
17:36:05 <goltrpoat> lispy:  turns out type signatures have to be in an .mli file :)
17:42:11 <stepcut> goltrpoat: yeah, that is one of the top-ten reasons to use haskell instead of ocaml :p
17:42:26 <goltrpoat> haha
17:42:31 <goltrpoat> yah, i don't like that at all
17:43:12 <dons> ?uptime
17:43:12 <lambdabot> uptime: 2 days, 21 hours, 15 minutes and 46 seconds
17:43:32 <stepcut> ?downtime
17:43:32 <lambdabot> Unknown command, try @list
18:03:22 <dons> stepcut is funny :)
18:07:09 <bmp> Is there a reason why the Mac OS X binary for GHC 6.4.2 isn't out, but the source code compiles fine? I tried to find whether there's some major as-yet-unpatched bug, but I didn't see any referenced anywhere.
18:07:29 <stepcut> bmp: OS X for PPC or x86 ?
18:07:33 <bmp> PPC
18:07:56 <stepcut> no idea
18:08:40 <bmp> There isn't a version for OS X x86 period, is there?
18:11:44 <Korollary> Check the ghc-user mailing list archives. Some progress has been made, but I don't think it's there yet.
18:33:51 <DukeDave> urm, I may be nuts but:  f . (g . h) x     is the same as   (f . (g . h)) x    right?
18:36:16 <dons> > id . (id . id ) 'x'
18:36:17 <lambdabot> Couldn't match `a -> b' against `Char'
18:36:25 <dons> > (id . (id . id )) 'x'
18:36:26 <lambdabot> 'x'
18:36:37 <dons> > id . id . id $ 'x'
18:36:38 <lambdabot> 'x'
18:37:42 <DukeDave> gah - sometimes, this language, sometimes!
18:37:47 * DukeDave bangs head on desk
18:39:34 <dons> ?
18:39:47 <DukeDave> ... am trying to revise for an exam
18:40:00 <dons> its just the parens missing in your f . (g . h) x example
18:40:26 <DukeDave> I know; but I still keep messing up the parens
18:40:42 <DukeDave> it's this right associativity business  *_*
18:40:51 <dons> perhaps avoid parens more often using $ ?
18:40:57 <dons> then you don't have to worry about it.
18:41:12 <dons> or play with ghc's -ddump-parse flag, to see how it parses things
18:41:14 <DukeDave> I don't even wanna think about $  :)
18:41:24 <DukeDave> ah cool
18:41:31 <DukeDave> I'll investigate... cheers ..
18:41:34 <dons> i made a wiki page on the topic,
18:41:37 <dons> ?wiki Indent
18:41:37 <lambdabot> http://www.haskell.org/haskellwiki/Indent
18:41:38 <dons> I think.
18:42:15 <dons> the idea was to get ghc to indent code for you, but the same applies to seeing how ghc resolves parsing
18:42:32 <dons> ?pretty id . id . id $ 'x'
18:42:32 <lambdabot> "Parse error" at column 19
18:42:39 <dons> ?pretty let j = id . id . id $ 'x'
18:42:39 <lambdabot> "Parse error" at column 27
18:42:44 <dons> ?pretty j = id . id . id $ 'x'
18:42:45 <lambdabot>  j = id . id . id $ 'x'
18:42:50 <dons> bah, no parens.
18:43:03 <DukeDave> hehe, see what I mean ;)
18:43:54 <dons> well, lambdabot's code-eating plugins tend to be slighly different. some accept expressions, some accept declarations. its hard to know which one is which.
18:43:58 <Cale> f . (g . h) x = f . ((g . h) x)
18:44:20 <Cale> which is not the same as (f . (g . h)) x
18:44:38 <Cale> function application binds tighter than any operator
19:25:59 * Rolling o
19:39:24 <SamB> okay, why has haskell direct apparantly not been touched since '04?
19:40:17 <SamB> er, HaskellDirect, I guess
20:03:29 <Cale> SamB: sounds obscure enough
20:03:40 <Cale> and we have the FFI
20:03:50 <SamB> well, what about XPCOM?
20:03:56 <SamB> do we have XPCOM?
20:04:01 <Cale> what's XPCOM?
20:04:13 <SamB> Mozilla's take on COM
20:04:46 <Cale> so, for creating components for Firefox and the like?
20:05:19 <SamB> or for manipulating an instance of some Mozilla embedded in an application
20:05:41 <Cale> We have MozEmbed
20:06:16 <SamB> yes, but there isn't a whole lot you can do just poking at the GTK methods...
20:06:33 <Cale> hmm, I suppose I've never used it, so I wouldn't know
20:07:45 <SamB> Did you see http://www.thewhitelion.org/inform7 ?
20:08:30 <Cale> nope, looks interesting
20:08:57 <SamB> its especially interesting to me because I was playing around with Inform 7 already when I heard about it
20:10:42 <SamB> there are some annoyances with it, though, such as the fact that I can't seem to get a context menu by right clicking...
20:11:20 <SamB> (in the gecko panes)
20:11:46 <SamB> which works fine in the Windows version, which embeds IE.
20:12:55 <SamB> also, NI is emitting inform:/ resource references, and it would be nice if those would work right without (unreliable) munging...
20:14:00 <SamB> it looks rather as if, to do any of that, someone will have to break out C++ or javascript, and I have no idea how one would inject the latter without the use of the former...
20:19:30 <Cale> SamB: I've only ever played games written with inform 5 and earlier.
20:19:52 <Cale> Speaking of which, have you played "For A Change" and "The Gostak"?
20:20:17 <SamB> Yes!
20:20:27 <SamB> But I think I had to cheat on the gostak...
20:20:47 <Cale> Yeah, the Gostak was quite hard.
20:21:08 <SamB> I liked The Ediface (if that is the right name?), though ;-)
20:21:14 <Cale> I eventually had about 2 pages filled with prospective definitions :)
20:21:24 <Cale> oh, I haven't played it
20:21:46 <mathrick> anyone familiar with prolog?
20:21:48 <SamB> tangentially based on 2001: A Space Oddessy
20:23:41 <SamB> someone must be!
20:25:06 <mathrick> well, I mean here, I have a practical question, and all #prolog's I found seem to be dead
20:25:57 <SamB> you could try asking it, that might work better. but then again maybe you would have more luck asking in #c!
20:26:00 <SamB> er, ##C
20:26:24 <SamB> and I'm not really kidding about that
20:26:30 <Cale> really?
20:26:33 <mathrick> really?
20:26:38 <SamB> could be WRONG
20:26:41 <Cale> I think that there are a number of people here who know prolog
20:26:47 <mathrick> well, okay, lemme try
20:26:51 <SamB> anyway, asking questions is better than asking if people know languages
20:26:54 <Cale> What's the question? I know a little.
20:27:00 <mathrick>  I need to add sanity check to a 'move' predicate, and make it fail if src and dest are the same
20:27:09 <mathrick>  however, it doesn't seem to have any effect:
20:27:24 <mathrick> move(_,X,X,_) :-
20:27:24 <mathrick>   \+ true,!.
20:27:49 <mathrick> ?- move(1,asd,asd,asd).
20:27:50 <mathrick>  "Move top disk from asd to asd"
20:27:50 <mathrick> Yes
20:27:50 <lambdabot> Maybe you meant: . v
20:28:16 <mathrick> there are other clauses of course
20:28:28 <mathrick> but that's why I tried to shortcut it with !
20:29:30 <mathrick> Cale: now, the question I really want to ask is, I think, do I need to put that sanity check inside each move definition? Or can I somehow extract it into a separate clause like I tried above?
20:29:39 <mathrick> I guess I was operating in haskell mode
20:29:43 <mathrick> where it'd just work
20:30:30 <Cale> hmm, your cut there is the last thing in the list
20:30:40 <Cale> so will it actually get used?
20:30:46 <mathrick> I moved it to the top
20:30:53 <mathrick> but that doesn't seem to have any effect
20:30:59 <Cale> right, it wouldn't
20:31:12 <mathrick> so, how should I do it properly?
20:31:19 <Cale> I think it's only effective if you put it between two things.
20:31:34 <Cale> It makes sure that backtracking doesn't proceed back through it.
20:31:46 <mathrick> hmm, I was reading wikipedia
20:31:59 <mathrick> and got impression from there that ! just cuts any further clauses
20:32:23 <mathrick> (they call it "red" cutting, since it's not really safe and depends on whether the order of clauses is significant)
20:32:39 <mathrick> but in my implementation, it seems to be
20:33:18 <mathrick> notanotheridiot: I'm not sure if you really want to irc as root
20:33:22 <mathrick> in fact, I know you don't
20:34:36 <Cale> hmm, it does seem like you can put it at the end
20:35:21 * notanotheridiot is ssh tunneling - for some reason it always shows me up as root
20:35:48 * notanotheridiot wishes he was though :)
20:36:10 <mathrick> heh
20:36:30 <Cale> (I haven't actually written very much prolog code)
20:36:56 <mathrick> yeah, but the problem of expressing false is quite fundamental
20:37:08 <mathrick> prolog only knows about truth :\
23:46:10 <dons> ?yow
23:46:11 <lambdabot> Is it clean in other dimensions?
