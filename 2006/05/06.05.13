00:00:11 <palomer> http://research.nii.ac.jp/~tatsuta/proof.sty
00:02:30 <Cale> okay, it works here, but the tree is really wide, so of course you have to set an insane magnification to see anything
00:02:55 <Cale> well, I had to rearrange a couple of things there -- \documentclass should always be the first line
00:03:18 <mwc> w00t, I fixed the parser... 1 shift/reduce thanks to the dangling else
00:03:45 <palomer> Cale: that changes something?
00:03:59 <mwc> Cale, you're in the same timezone... why are you still up
00:04:10 <Cale> mwc: meh :)
00:04:20 <mwc> palomer, I think some styles and the like refer to information set by the \documentclass macro
00:04:20 <Cale> my hours are strange
00:04:21 <dons> Cale works on .au time, i've noticed.
00:04:26 <mwc> me too
00:04:33 <palomer> me tree
00:04:33 <Cale> dons: yeah, pretty much :)
00:04:39 <mwc> if that's get up at noon EST, go to bed at 4 am EST
00:04:50 <Cale> I should move there, there'd be no jet lag :)
00:04:50 <dons> its good, otherwise i'd have no one to talk to all day.
00:04:51 <palomer> Cale: but I don't want the tree to look really small, though
00:05:22 <palomer> what else did you change, though?
00:06:06 <mwc> Yeah, finally, a head shot
00:06:18 <mwc> you'd think this dweeb didn't know how to kill a zombie
00:06:24 <mwc> pathetic.
00:06:27 <Cale> cale.yi.org/autoshare/proofeg.tex
00:06:52 <Cale> at least in acroread you can zoom in enough to read it comfortably
00:07:12 <palomer> pdflatex?
00:07:18 <Cale> yep
00:07:38 <Cale> if you want, I can give you the generated pdf for comparison
00:07:42 <palomer> ahh, so that's what that blur is
00:07:48 <palomer> >:o
00:07:52 <palomer> that's what it would output for me too
00:07:56 <Cale> you need to zoom in to something like 1600%
00:08:50 <palomer> 2400%
00:08:58 <Cale> or that :)
00:09:11 <palomer> crazy.
00:09:35 <palomer> but, yeah, I just want to make the page larger
00:09:40 <Cale> it might be worth the trouble to figure out a sane way to simplify the proof trees
00:10:19 <palomer> the proof tree will be as big as the AST
00:10:40 <palomer> no kidding
00:11:01 <palomer> so it'll get pretty wide
00:11:08 <palomer> (and tall)
00:11:59 <Cale> well, at least with this, we have the whole tree inside the bounding box for the page, whatever that bounding box happens to be, so by setting both, we can scale things
00:13:14 <palomer> but that'll mean simple trees are going to be huge
00:13:16 <dons> oh, hmm, with a new Cmm loop-identifying patch for ghc head, i have some bytestring benchmarks running 10x faster :)
00:13:43 <Cale> wow
00:14:12 <Cale> those benchmarks were already quite fast iirc
00:15:30 <dons> right. thiis is a new patch from roman l, working on the ndp fusion branch. it rewrites some Cmm loops into a form gcc can recognise as a loop
00:15:36 <dons> i'll post some graphs.
00:16:32 <palomer> oh my, I need to get sleeping
00:16:33 <palomer> night guys
00:16:35 <palomer> thx cale
00:17:15 <Cale> palomer: quite welcome -- I'll let you know if I come up with anything wrt determining the extents of the image. It would be handy to know
00:18:29 <palomer> yeah
00:18:41 <palomer> I emailed Dr. Tatsuta, maybe he has some insight
00:18:48 * palomer collpases
00:18:51 <palomer> collapses
00:54:02 <Lokadin> say is getHomeDirectory not supported in 6.4.1?
00:56:09 <Lokadin> is there any way to grep, lines around a particular output? say output 3 lines before and after
01:00:15 <newsham> if you use agrep you can use arbitrary record delimiters (ie "two newlines" rather than "newline" for grep) which might do what you want depending on yoru data.
01:00:50 <Lokadin> newsham: thanks :)
01:00:52 <newsham> more directly to your answer, you can whip up what you want fairly easy with a scripting language (perl, python, awk, haskell, etc..) but i dont think you'll find a pre-canned command
01:01:06 <newsham> err.. to your question
01:01:28 <Cale> Lokadin: -C
01:01:39 <Lokadin> Cale: ?
01:02:06 <Cale> -C5 will give 5 lines of output context around a match with grep
01:02:14 <newsham> oh, hah..  yup, -C in gnu grep.  now i feel dumb.
01:02:21 <Lokadin> oh wow thanks :)
01:02:28 <newsham> sorry
01:02:48 <Cale> -B and -A control the amount of context before and after a match
01:03:08 <Lokadin> :)
01:04:23 <Lokadin> i made a `note` of that! :)
01:04:27 <Lokadin> lol
01:08:27 <Lemmih> Oeje1!
01:08:46 <Oeje1> Lemmih: :-)  Already up?
01:11:04 <Lemmih> Oeje1: I was out in OEsteranlaeg at 5am to see the sunrise.
01:11:30 <Oeje1> Oh, some special occation?
01:12:40 <Lemmih> Nah, just hadn't seen a runrise for quite a while.
01:12:41 <Oeje1> Hi, boegel.
01:16:45 <Lokadin> say would anyone mind looking at my hWaitForInput problem?
01:17:29 <Lokadin>  Lokadin pasted "hWaitForInput ALWAYS True" at
01:17:30 <Lokadin>                     http://paste.lisp.org/display/19934
01:19:20 <Cale> huh?
01:19:23 <Cale> it works for me
01:19:32 <Lokadin> really?
01:19:36 <Lokadin> :|
01:20:16 <Cale> 50 is a really short time interval
01:20:35 <Lokadin> well it always returns true for me, and i don't know why
01:20:36 <Lokadin> hmmm
01:20:43 <Lokadin> one sec let me try something
01:20:46 <Cale> when I do hGetCont stdin, I get the empty string almost immediately
01:21:01 <Cale> hGetCont stdin >>= print
01:21:31 <Cale> by tweaking the time, I can type some characters before it times out, and it'll echo the characters back at me after the timeout
01:22:16 <Lokadin> oo
01:22:39 <Lokadin> so i have to increase time, so what would be a good time to set it at?
01:22:53 <Cale> what are you reading from?
01:22:57 <Lokadin> for recieving output from say runInteractiveCommand
01:23:34 <Cale> basically, you're setting the largest pause in the output
01:24:06 <Lokadin> so how long a pause you think?
01:24:07 <Cale> if the output stops for as long as that delay time, then the thing stops reading
01:24:16 <Lokadin> hmmm
01:24:28 <Lokadin> and it's measured in millionths of a second?
01:24:39 <Lokadin> er hundreds
01:24:42 <Lokadin> milliseconds
01:24:46 <Cale> milliseconds
01:25:01 <Cale> (1000ths)
01:25:05 <Lokadin> damn
01:25:33 <Lokadin> it doesn't seem to be helping
01:25:38 <Lokadin> here i can paste whole program
01:26:38 <Lokadin> wait
01:26:43 <Lokadin> so that paste
01:26:49 <Lokadin> when compiled.. worked?
01:26:50 <Cale> one thing to check if you're using it to interact with another program is to be sure that if the program needs input on stdin before producing output, to flush the output handle
01:26:59 <Cale> yeah
01:27:16 <Lokadin> hmmm. 
01:27:29 <Cale> when I tried it, it waited 50ms for me to type a character, and then returned the empty string
01:27:42 <Cale> (I used it with stdin)
01:28:38 <Cale> then I changed it to 1000ms, and now I can type whatever I want, until I stop for a second, and then it stops reading and returns the string
01:28:52 <Lokadin> cool
01:29:17 * Lokadin is trying to figure out the difference between that file and current implementation
01:30:41 <Cale> 'night
01:30:49 <Lokadin> your going?
01:31:06 <Lokadin> hmmm, i should to, i have work in 4 hours :|
01:31:08 <Cale> well, soonish anyway :)
01:31:24 <Lokadin> oi, haskell keeps me up real long
01:31:31 <Lokadin> lol
01:32:20 <Lokadin>     (inp,out,err,hdl) <- runInteractiveCommand line
01:32:20 <Lokadin>     output   <- hGetCont out
01:32:21 <Lokadin>     errorout <- hGetCont err
01:32:35 <Lokadin> is the current implementation,
01:32:44 <Lokadin> fails saying hGetChar read EOF
01:33:17 <Lokadin> line being "ls"
01:33:28 <Cale> oh, you're on Windows, right?
01:33:33 <Lokadin> er no
01:33:35 <Lokadin> i'm on linux
01:33:39 <Lokadin> gentoo
01:33:39 <Cale> hmm
01:33:43 <Cale> http://cvs.haskell.org/trac/ghc/ticket/48
01:34:00 <Cale> hmm, also, that bug is closed
01:34:39 <Lokadin> odd
01:35:13 <Lokadin> i can't pretend that computers have ever worked the way their supposed to for me anyways
01:35:32 <Lokadin> that's why i use linux, at least it can handle the strain lol
01:35:51 <Lokadin> :|
01:36:14 <Cale> hmm
01:36:29 <Cale> does your program have multiple threads?
01:36:44 <Lokadin> i don't think so, i didn't declare any or anything
01:36:47 <Cale> okay
01:36:59 <Lokadin> unless runInteractiveCommand runs as a seperate thread
01:37:22 <Cale> well, it spawns a new process, but that's another thing
01:37:30 <Lokadin> kk
01:38:07 <Cale> in ghci, type hWaitForInput stdin 2000
01:38:23 <Cale> and see if it waits two seconds
01:38:32 <Cale> better yet
01:38:39 <Cale> hWaitForInput stdin 2000 >>= print
01:38:48 <Lokadin> what do i have to import?
01:38:57 <Cale> :m + System.IO
01:39:00 <Lokadin> kk
01:39:36 <dons> @seen pesco
01:39:36 <lambdabot> pesco is in #haskell. I last heard pesco speak 17 hours, 1 minute and 6 seconds ago.
01:39:45 <dons> pesco, ping?
01:39:51 <Lokadin> it works, as in waits for 2 seconds and says False
01:40:10 <Cale> if you type a character before the timeout, it should return True, and you should see the character appear on the commandline
01:40:41 <Lokadin> but doesn't wait if i type a single character, after first character saysTrue
01:40:42 <Lokadin> er
01:40:48 <Cale> right
01:40:59 <Lokadin> Prelude System.IO> hWaitForInput stdin 2000 >>= print
01:40:59 <Lokadin> lTrue
01:40:59 <Lokadin> Prelude System.IO>
01:41:16 <Lokadin> doesn't print though
01:41:25 <Cale> I also get an l after the > on the last line there
01:41:25 <Lokadin> or is that the True
01:41:26 <Lokadin> oh
01:41:33 <Lokadin> o
01:41:34 <Lokadin> really?
01:41:37 <Cale> that's the True that's printed
01:41:44 <Lokadin> yea i thought so
01:42:49 <Cale> yeah, readline in ghci gets hold of the l because hWaitForInput doesn't eat the character
01:43:03 <Cale> so it prints it again, where it's supposed to appear
01:43:15 <Cale> I don't think it's a big deal if it doesn't do that for you
01:43:33 <Cale> it seems like your hWaitForInput is working, so it must be something else
01:44:26 <Lokadin> hmmm
01:44:40 <lisppaste2> Lokadin annotated #19934 with "new full program" at http://paste.lisp.org/display/19934#1
01:44:54 <Cale> like maybe the handle is closing prematurely after making a character available, so that the hWaitForInput finishes with True, and before the hGetChar, the program dies and the handle closes
01:44:58 <Lokadin> wow, i'm lagging really bad
01:45:55 <Lokadin> hmmm
01:46:04 <Lokadin> or maybe not too, bad. dono
01:46:47 <Lokadin> it could be, it's just i remmber once i was getting it to read the entire ls, then quit on last character, now it doesn't even do that, but i don't remmber any big difference
01:47:29 <Lokadin> i changed the code quite a few times as i was trying different ways of getting cd to work
01:47:33 <sethk> I've found in a couple of cases that increasing the delay of hWaitForInput improved performance.  If that value is too short, then things tend to get processed character by character rather than taking advantage of whatever buffering is available.
01:47:51 <sethk> I don't know that this applies here, but I was doing some extensive testing today showing this behavior.
01:48:23 <Lokadin> o maybe it's the buffering
01:49:07 <sethk> Lokadin, it can certainly be a factor, and I found some of the behavior a bit counterintuitive.
01:49:11 <Cale> anyway, hGetCont is probably not quite what you're looking for...
01:49:15 <sethk> although perhaps your intuition is better than mine  :)
01:49:53 <Lokadin> Cale: really? well what would be good, to be honest' i just want it to do what a shell does, run programs.. like vim and others,
01:50:31 <sethk> Cale, I've had excellent results with hGetContents with very large data sizes.  You are correct that it isn't a good choice for line oriented i/o.
01:50:41 <Lokadin> but i couldn't figure out how to even trick ls into thinking i'm not a pipe
01:51:05 <sethk> Lokadin, what's wrong with appearing to ls as a pipe?
01:51:18 <Cale> sethk: this isn't hGetContents
01:51:26 <Lokadin> sethk: i guess it's not too bad, but if vim thinks i'm a pipe to..
01:51:28 <sethk> Cale, oh, ok
01:51:29 <Cale> http://paste.lisp.org/display/19934
01:52:20 <sethk> hmm, not a good name for that, but I was obviously thinking of something else entirely.
01:52:37 <sethk> my function for doing something similar is not terribly different.  let me see ...
01:53:09 <Lokadin> sethk: kk :)
01:54:10 <sethk> I use hWaitForInput handle 200, then if there is no input, I use a threadDelay 250000
01:54:10 <Lokadin> no way of running a command in the foreground is there?
01:54:20 <Lokadin> i mean that would be perfect..
01:54:30 <sethk> Lokadin, you have unix fork/exec available, so you can do just about anything
01:54:50 <sethk> Lokadin, you have the same resources available to you as a shell program written in C
01:55:16 <Lokadin> oh okay
01:56:56 <sethk> Lokadin, I'll paste the functions I use to run a process from my program if you like.
01:57:21 <Lokadin> sethk: if i could use it :)
01:57:30 <Lokadin> i'd love it :)
01:57:39 <Lokadin> i mean as in you didn't copyright it or anything
01:57:46 <lisppaste2> sethk pasted "running process from haskell program" at http://paste.lisp.org/display/19958
01:58:30 <sethk> Lokadin, use away.  I'm not asserting that it is the best way to do things, but it is working well in a set of programs that I've deployed and are used extensively
01:59:24 <sethk> Lokadin, I don't think I've used any types defined in other files, but if I have let me know and I'll post
01:59:36 <Lokadin> kk one sec 
02:00:18 <sethk> Lokadin, note the tricks I used in startProcess2.  I found that waitForProcess or getProcessReturnValue do not work if you return from the function and then use them in the caller
02:01:09 <sethk> sorry, getProcessExitCode is the name of the function (in System.Process) I was talking about
02:01:30 <sethk> I'm using waitForProcess, but the problem applies to both functions.
02:01:42 <Lokadin> Could not find module `UTrace'
02:01:55 <sethk> Lokadin, ok, I'll post it.  all it does is print trace statements
02:02:08 <Lokadin> kk
02:02:13 <Lokadin> :) thanks
02:02:29 <lisppaste2> sethk pasted "UTrace" at http://paste.lisp.org/display/19959
02:02:52 <sethk> I hope I don't have cascading dependencies here.  No, UTrace only imports library things, so it should be ok
02:03:16 <Lokadin> damn slow firefox not loading page :(
02:03:28 <Lokadin> i think it froze :(
02:03:31 <sethk> Lokadin, the latest firefox has a major league memory leak
02:03:46 <sethk> Lokadin, I left it running last night and this morning it was using 70% of cpu
02:03:58 <Lokadin> :|
02:03:59 <Lokadin> oh man
02:04:14 <sethk> I was saying, damn this is supposed to be a fast machine.  :)
02:04:26 <Lokadin> lol
02:04:33 <sethk> seems to be ok for a few hours, then it goes nuts.
02:05:04 * Lokadin checks top
02:05:26 <Lokadin> hmmm, ghc is compiling, that seems to be the load issue
02:08:53 <Lokadin> sethk: so how would i use it? i'm a little confused, i loaded it into ghci
02:09:45 <Lokadin> what is commandString args mvPhandle mvResult
02:10:09 <Lokadin> ("ls") ("") (?) (?)
02:10:21 <sethk> commandString and args are the same types you'll see in System.Process 
02:10:39 <Lokadin> hmmm
02:10:51 <sethk> originally I was using a function in System.Process that uses a separate array for arguments
02:10:54 <Lokadin> could you give me an example? sorry i'm not very expert in this
02:11:01 <Lokadin> oh
02:11:02 <sethk> then I changed it to use runCommand, which just takes a string
02:11:24 <sethk> so I just appended the arguments to the string
02:11:46 <sethk> the other two arguments are to allow the caller to get information, which you probably don't need to do.
02:12:27 <sethk> I store the process handle in an MVar.  The caller uses it with terminateProcess if the user kills the process (in a shell that would be a control-c)
02:12:45 <sethk> but I would not try to use it, treat it as an idea of how it might be done
02:13:11 <Lokadin> hmmm
02:13:12 <Lokadin> kk
02:13:29 <Lokadin> well i'm gonna have to sleep on that because work starts in 3 hours
02:13:35 <Lokadin> :) thanks for the help
02:29:49 <pesco> dons: pong
02:49:03 <good_boy> hi, how can i "show" a tupel? im using show but it doesnt work.
02:49:46 <mahogny> show only turns it to text. is that what you want?
02:49:50 <mahogny> putStr to print it out
02:50:10 <good_boy> i want to print it out
02:50:19 <mahogny> then putStr or putStrLn
02:50:35 <Lemmih> Or print.
02:50:46 <mahogny> bbl
02:51:39 <good_boy> what if i have a list of tupels?
02:51:59 <good_boy> it doesnt work neither with putStr nor with show
02:53:27 <Lemmih> good_boy: 'print' will do.
02:53:42 <dons> pesco: yo
02:54:03 <dons> i see henrik's joined up as a mentor. i've just mailed him with the procedure for actually agreeing to mentor your submission.
02:55:17 <pesco> dons: Yeah. He mailed Isaac last night, after I'd given him a heads-up.
02:55:28 <dons> ok. all good then.
02:55:35 <pesco> dons: He said, he'd be away over the weekend, though.
02:56:35 <dons> ok, well, as soon as possible is best, if he can indicate his mentorship . there's a few more days.
02:57:00 <pesco> Yep. Since you've mailed him, I'm sure he'll react as soon as he sees it.
02:57:52 <pesco> He should know the deadline is 22, I pointed it out to him in our initial exchange.
03:20:03 <Lemmih> JohnMeacham: ping.
03:21:47 <jip> @seen Igloo
03:21:47 <lambdabot> Igloo is in #haskell-overflow and #haskell. I last heard Igloo speak 18 hours, 2 minutes and 9 seconds ago.
03:37:26 <xerox> @yow!
03:37:27 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
03:47:22 <xerox> @yow?
03:47:22 <lambdabot> A dwarf is passing out somewhere in Detroit!
03:47:51 <tuxplorer> xerox:does yow generate random sentences like why in matlab?
03:48:03 <User22> jk
03:48:26 <xerox> tuxplorer: it does generate yows like emacs :-)
03:49:38 <tuxplorer> xerox: does emacs offer better indentation than vi for haskell?
03:50:07 <xerox> tuxplorer: it offers some flavours
03:51:22 <tuxplorer> xerox: i want to start using emacs.. heard it gives  a shell of its own.. can u give me some good starter?
03:51:28 <xerox> And I think that interaction with the interpreters is overall better.
03:51:59 <xerox> tuxplorer: sure, it's quite simple, do: C-h t (C- means "hold down the ctrl key while pressing..")
03:52:59 <tuxplorer> oops! wait a min.. emacs is not installed in my new FC5 installation.. let me install it..
03:53:37 * jip prods Igloo
03:53:45 <jip> (wake up!)
03:55:27 <tuxplorer> xerox: ya. got it now.. i get a buffer..
03:55:45 <xerox> C-h t
03:56:26 <tuxplorer> oh! ya got a tutorial.
03:56:50 <tuxplorer> xerox: will read it and ask u any doubts..
03:57:07 <xerox> Read carefully, you'll be able to work in very short time
03:57:25 <tuxplorer> thanks xerox
03:57:36 <xerox> Hope it serves you well
03:58:04 <xerox> (There also is an #emacs channel with nice people in it.)
03:58:19 <tuxplorer> xerox: ok.
03:58:38 * tuxplorer joined #emacs
04:00:09 <xerox> Cale: `the coloring torus of a graph' seem very nice, but the terminology is above my head at times.  I very much liked the `integer programming' one, btw.
04:13:28 <vincenz> xerox: dove?
04:21:13 <araujo> morning!
04:24:04 <metaperl> skew: ping?
04:24:17 <metaperl> tuxplorer: ping?
04:24:28 <tuxplorer> metaperl: pong
04:25:55 <metaperl> tuxplorer: I use the shell within emacs
04:25:55 <metaperl> XEmacs actually
04:26:47 <tuxplorer> metaperl: ok.. does it actually send the commands to the terminal? or does it have all stuff coded in itself?
04:27:36 <metaperl> it has history
04:27:36 <metaperl> it's pretty nice
04:27:36 <metaperl> emacs also has bookmarks which are nice
04:27:36 <metaperl> to remember where files are
04:27:36 <metaperl> do you want to emacs or xemacs?
04:27:42 <metaperl> i'm not sure about the implementation
04:27:44 <metaperl> M-x shell 
04:27:48 <metaperl> is how you run it
04:31:03 <tuxplorer> metaperl: I'm right now learning emacs.. i'll try the gui enabled one later.. commandline gives the real flavor right? :)
04:32:11 <tuxplorer> metaperl: the previous response was for the emacs or xemacs one.. I'll try the M-x thing for that shell.. 
04:34:46 <metaperl> they are both gui enabled
04:34:48 <metaperl> emacs and xemacs are functionally 99% the same
04:34:53 <metaperl> in all respects... the lisp underlying them is different in some respects
04:34:58 <metaperl> but both can operate from terminal and X
04:35:02 <metaperl> the shell works on both
04:35:06 <metaperl> same command
04:35:08 <metaperl> there is a nice utility I got a long time ago
04:35:10 <metaperl> called shell-current-directory
04:35:14 <metaperl> it allows you to open numerous shells within emacs, one per directory
04:35:17 <metaperl> also dired is great for all sorts of file manipulations within emacs/xemacs
04:36:27 <psi> how do you copy a directory with dired? 'C' seems to do the wrong thing
04:39:53 <metaperl> psi: hmmm
04:42:53 <metaperl> psi: I dont know. from google, it did not work in v19, but I would be surprised if there is no way to do it now
04:46:29 <psi> found it: set dired-recursive-copies to t, and 'C' will ask if you want to copy recursively
04:48:44 * psi leaves for school
04:52:00 <jip> this shit is never gonna be fast enough :(
04:53:16 <xerox> vincenz: google video
04:55:07 <jip> i've commented out almost all of the functionality in my code, and it still runs about 3 times as slow as it needs to :|
04:58:21 <azuroth> someone help meeee
04:59:30 <xerox> azuroth: what's your problem?
04:59:57 <Saulzar> jip, I suspect it will need a careful look at how memory/state are accessed/updated and the granularity,  .. that seems to be where all the cost is coming from
05:00:21 <azuroth> I've got a three-sided incomplete convex face, and I know everything about the side I want to add except what direction to make the normal (so it's facing inwards)
05:01:43 <azuroth> is there a better way than, I dunno, trying both normal directions and checking whether an inside-point is inside?
05:02:25 <jip> Saulzar: either that or coding some functions in c :O
05:03:19 <xerox> azuroth: beats me, maybe you could try to ask on #math
05:03:25 <Saulzar> jip, Yeah.. maybe stuff like blitting and readscanline etc. can be done that way
05:05:14 <azuroth> #math? cool :D
05:05:29 <jip> Saulzar: i want to try to avoid c if at all possible though :|
05:06:13 <jip> is {-# INLINE #-} any good?
05:06:39 <Saulzar> Seems to help in some cases, though GHC inlines a fair amount already 
05:06:39 <jip> does it inline across modules?
05:06:45 <metaperl> psi: good job
05:07:06 <Saulzar> Not sure, that's another thing which might be extremely important.
05:07:17 <metaperl> good morning... looks like we have some activity
05:07:45 <metaperl> I wrote my first progra using I/O and would like some help getting the IO completely out of most of the functions: http://rafb.net/paste/results/gJD8Qw97.html
05:07:54 <int-e> jip: it can inline across modules but most likely will only do that for small functions and functions with {-# INLINE #-}
05:07:58 <Saulzar> jip, I'm sure it's possible. The numeric stuff for the shootout seemed to do comparably to C using ST or IO arrays
05:08:42 <xerox> azuroth: many Haskellers hang out on #math too (-:
05:09:02 <jip> Saulzar: maybe i should read that code to see if there are any tricks
05:09:05 <metaperl> ok I'm going to my blog since no-one here will help me
05:09:37 <jip> if a function really is being inlined, would it still show up in the profiling results?
05:09:46 <int-e> metaperl: do you want codeToState >>= \db -> lookup stateName db ?
05:09:59 <metaperl> int-e: I'm not sure
05:10:21 <metaperl> where are you talking?
05:10:38 <metaperl> oh wait that is an old paste I think
05:10:55 <Saulzar> jip, I think it would appear in the parent function, though perhaps not - you can also use pragmas to make explicit cost centers too "SCC" I think 
05:11:03 <int-e> metaperl: hmm. yes, it looks like it is - it has nothing to do with your question now that I think about i.
05:11:08 <int-e> *it.
05:11:20 <metaperl> int-e: actually that function is still failing.. hmm
05:11:22 <azuroth> xerox: I'm not surprised, to be honest
05:12:00 <jip> Saulzar: well, i see the inlined function being listed in the profiling results, so i'm wondering if it really is being inlined
05:13:24 <Saulzar> Yeah, I'm not 100% sure what's going on there. I tried scattering inline all through everything, didn't seem to make much difference.
05:13:28 <metaperl> int-e: I tried it your way but still get a type mismatch : http://rafb.net/paste/results/1r5oCE89.html
05:13:35 <dons> jip, INLINE can really speed some functions up, as it will expose all sorts of things to further simplification
05:13:45 <dons> i've seen plenty of 2x speed ups with careful INLINE use
05:14:13 <delinka> hi *gulp* everyone? (that's a buncha folks in one room...); I'm a n00b w/ questions...
05:14:37 <metaperl> could someone please help me get the IO out of my program: http://rafb.net/paste/results/1r5oCE89.html
05:14:38 <Saulzar> delinka, Ask away :)
05:14:40 <dons> oh, we're actually under 200. first time in a while.
05:15:49 <jip> dons: INLINE definitely works across modules?
05:15:59 <dons> sure.
05:16:08 <dons> the defn gets unfolded into the .hi file, iirc
05:16:17 <dons> only with -O though
05:16:42 <jip> dons: when i modify a INLINE function, and then do ghc --make, then only it's module is recompiled, none of the other modules that call the function
05:16:43 <delinka> I'm reading the introduction on the wiki and it mentions '[A]pplications where performance is required at any cost [...] and imperative language [...] would probably be a better choice'; so my question for this is: can Haskell make use of code in other languages via linking? Does that even make sense with regard to how Haskell evaluates programs?
05:16:43 <dons> if in doubt, check the Core syntax. with -ddump-simpl
05:17:05 <delinka> s/[...] and/[...] an/
05:17:18 <dons> jip, well you can always say -no-recomp to force recompilation
05:17:37 <dons> delinka: yes. we use the foreign function interface
05:17:38 <xerox> delinka: 1. Haskell has got a pretty Foreign Function Interface to C. (and many bindings to C libs) 2. Haskell is pretty fast nevertheless.
05:17:54 <dons> probably the best foreign interface around, in fact.
05:18:19 <basti_> actually haskell isn't all that fast, but it doesnt matter a lot that it isn't.
05:18:29 <dons> basti_: i'd strongly contest that.
05:18:34 <dons> ?shootout
05:18:34 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
05:18:40 <dons> also,
05:18:42 <dons> ?wiki Wc
05:18:42 <lambdabot> http://www.haskell.org/haskellwiki/Wc
05:18:59 <dons> generally its possible to code around C speed, with some practice
05:19:02 <delinka> I'm thinking about high CPU usage stuff like crypto (RSA) where there are already efficient libraries in C but I want to an app in Haskell. Thanks for the answers.
05:19:11 <dons> with some tricks, like array fusion, its possible to beat C.
05:19:13 <basti_> wow.
05:19:42 <basti_> but uhm, would a mortal haskell programmer be able to get the ideas that made the shootout samples so fast?
05:19:50 <dons> yeah, check the Wc link.
05:20:02 <dons> i distilled much of what we learnt in the shootout into the Data.ByteString library
05:20:08 <dons> for all the mere mortals, as you say
05:20:35 <dons> here, for example: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
05:20:38 <dons> also
05:20:39 <dons> ?wiki Performance
05:20:39 <lambdabot> http://www.haskell.org/haskellwiki/Performance
05:20:47 <dons> has a lot of knowledge documented
05:20:55 <delinka> from the shootout page: "D Digital Mars - 64.5", people are using D??
05:21:16 <dons> here's another good one: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
05:21:43 <dons> and here: http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
05:22:00 <xerox> dons is the Performance semigod.
05:22:04 <dons> so, any myths about performance should be laid to rest. most are just left overs from days of hugs.
05:22:04 <int-e> metaperl: hmm. String -> IO (Maybe String) is what that type should be. Is there anything else wrong with the code apart from the fact that it's probably better to have a readDB :: String -> IO [(String, String)] instead of doing the reading in the lookup function?
05:22:37 <metaperl> int-e: I think all the functions in the program should be pure - with no hint of IO
05:22:51 <basti_> dons: hmm ok it isn't all that outworldly
05:22:54 <delinka> heh, Haskell beats out C++, Java, C#, Python, Perl... nice
05:23:01 <int-e> metaperl: (or even parseDB :: String -> [(String, String)], used with readFile file >>= return . parseDB ... (or, fmap parseDB (readFile file))
05:23:42 <int-e> metaperl: but you're doing IO. apart from unsafePerformIO hacks, there's no way you can get out of the IO monad then.
05:24:18 <dons> delinka: right, performance concerns woudl be the last of your worries. and you'd just use the ffi to bind to any optimised C or asm you need
05:24:25 <metaperl> so you mean all my functions need some hint of IO  awareness?
05:24:41 <Saulzar> It's probably simpler to separate them into two distinct functions 1) to do io 2) a pure function to do some stuff with the data
05:24:48 <metaperl> I cant write them in a pure fashion? I need to work on this myself... it has to be possible
05:24:59 <metaperl> Saulzar: that's what I want
05:25:11 <int-e> metaperl: uhm. no. it's possible to have a pure function that takes the file contents and parses it into a db and a pure lookup function, as I wrote before
05:25:14 <delinka> oh, and (I haven't seen this in the wiki yet) Haskell compiles to hative code, yes?
05:25:17 <delinka> native
05:25:22 <dons> delinka: yes, of course.
05:25:36 <dons> via C or via the ghc native code generator, for a wide range of architectures
05:25:39 <dons> ?where ghc
05:25:40 <lambdabot> http://haskell.org/ghc
05:25:40 <int-e> metaperl: but you have to read the file in the IO monad and you'll have to pass around the parsed db.
05:25:50 <Saulzar> So instead of connecting all your functions directly to the IO source - eg   a(b(c(d(io stuff))))   you should do  foo <- io stuff; return (a (b (c (foo))) 
05:26:00 <delinka> already using ghc, thanks ;-)
05:26:05 <metaperl> oh
05:26:09 <dons> you can also use the interactive environment for exploration, which mixes both interpeted and compiled code, ghci.
05:26:16 <metaperl> the return will promote it back to the IO monad I take it
05:26:18 <Saulzar> That way a b c can all be pure functions acting on the data you've gained through IO
05:26:24 <delinka> dons: ooooo ... nifty
05:26:25 <Saulzar> metaperl, Right :)
05:26:41 <dons> or even lambdabot, which compiels to native code too:
05:26:47 <metaperl> I see... Ok, I'm going to rework the code
05:26:49 <dons> > map (+1) [1..10]
05:26:50 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
05:26:56 <jip> dons: is there a faster way to do arrays then IOUArray?
05:27:24 <dons> raw Ptr arrays via Foreign.* can sometimes be faster.
05:27:37 <jip> dons: a lot faster?
05:27:38 <dons> jip, also, be sure to use unsafeRead/Write to avoid redundant bounds checks
05:27:47 <jip> dons: hm....
05:27:49 <dons> unsafeRead/Write can be worth 2x or more.
05:27:58 <dons> as long as you know the boudns are ok.
05:28:07 <dons> (i.e. you've checked yourself)
05:28:21 <jip> ah yes, i'll try that now
05:28:25 <dons> but IOUArrays can be very fast, this one beats gcc: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=ghc&id=0
05:28:36 <Saulzar> From the code I had it was all the wrapping slowing things down, I tried unsafeRead/Write
05:28:38 <dons> probably some good examples there of how to code fast arrays, too.
05:28:56 <jip> dons: is there a way to do unsafe reading of UArray?
05:29:11 <dons> unsafeRead/Write, its overloaded.
05:29:19 <Saulzar> Maybe some level of strictness could help things, I don't think any of it depends on laziness
05:29:37 <dons> using strictness on functions taking arrays can help, as ghc can then unfold the array definition to get the underlying machine pointer.
05:29:53 <jip> how do you use strictness on functions?
05:29:57 <dons> so your Array a -> function, end up as Ptr a ->
05:30:07 <dons> oh, using `seq` like in the example above (the url)
05:30:20 <dons> check the performance page of the wiki for more on this story
05:30:25 <dons> ?where Performance
05:30:25 <lambdabot> I know nothing about performance.
05:30:31 <dons> ?wiki Performance
05:30:31 <lambdabot> http://www.haskell.org/haskellwiki/Performance
05:30:35 <jip> @hoogle unsafeRead
05:30:35 <lambdabot> No matches found
05:30:47 <dons> its in Data.Array.Base
05:31:19 <jip> oh yeah, unsafeRead only works with Int indexes!
05:31:46 <dons> @type Data.Array.Base.unsafeRead
05:31:47 <lambdabot> forall e
05:31:47 <lambdabot>              (a :: * -> * -> *)
05:31:47 <lambdabot>              (m :: * -> *)
05:31:47 <lambdabot>              i.
05:31:47 <lambdabot>           (Data.Array.Base.MArray a e m, Ix i) =>
05:31:49 <lambdabot>           a i e -> Int -> m e
05:31:57 <jip> hm... maybe Int indexes will be faster then Word16 indexes anyway?
05:32:12 <dons> probably ghc has special optimisations in that case.
05:32:20 <dons> I'd not bother with worrying about the index type.
05:32:23 <delinka> are there rules against mucking with lambdabot in private?
05:32:26 <dons> its the element type that's the issue.
05:32:29 <dons> delinka: nope.
05:32:38 <dons> its encouraged.
05:32:38 <Saulzar> delinka, You need to be registered to send priv messages though
05:32:53 <dons> you can also install lambdabot locally, and it rusn on the command line.
05:33:33 <dons> lambdabot> > 1+2
05:33:33 <dons> 3
05:33:33 <dons> lambdabot> ?palomer
05:33:33 <dons> Soylent green is people
05:33:43 <xerox> "Note that the tight C loop didn't give us anything in the end over the naive ByteString code, which is a very satisfying result."
05:33:50 <xerox> @karma+ dons
05:33:50 <lambdabot> dons's karma raised to 34.
05:33:59 <dons> you like that xerox? :)
05:34:07 <xerox> Indeed!
05:34:11 <jip> dons: unsafeRead only works for mutable arrays, is there some way to do unsafe reading for UArray?
05:34:17 <xerox> Going gigabytes now, dons? (-:
05:34:23 <jip> dons: or should i not use UArray, even for read-only arrays?
05:34:34 <dons> xerox: did you see my post the other day? yesterday? on 10G data files.
05:34:39 <tuxplorer> metaperl: thanks for the info u gave.. i did not read it then and respond to u, as i was reading the emacs tutorial and didnt see my messenger.. thanks
05:34:51 <metaperl> oh sure np
05:34:52 * xerox and mailing lists - part three
05:34:57 <xerox> Hrrrrmmpf.
05:34:59 <dons> xerox, oh right.
05:35:19 <xerox> dons: -cafe?
05:35:25 <dons> jip. hmm. no. hmm. 
05:35:59 <dons> xerox, libraries@
05:36:05 <xerox> Okay.
05:36:23 <dons> basicalyl, with Data.ByteString.Lazy, you can filter 10G files in about 4 minutes on my box, with 1M heap
05:36:39 <dons> sed takes at least 5 x that long :)
05:36:47 * xerox grins evilly
05:37:15 <dons> jip, try out IOUArray then. I didn't know about this restriction on unsafeRead to mutable arrays.
05:37:24 <dons> perhaps, if you look in the src, there's some back door.
05:37:39 <xerox> Strongly typed lambda calculus with sugar ontop beats the two-state automata! 
05:37:49 <dons> hehe
05:38:18 * delinka wonders what *wouldn't* beat two state automata
05:38:44 <xerox> A one-state automata perhaps.
05:38:50 <delinka> lol
05:40:04 <int-e> @index unsafeThawSTUArray
05:40:05 <lambdabot> bzzt
05:40:24 <delinka> now *that's* funny
05:44:07 <vincenz> xerox: I'm watching another googletech movie that's too funny, the guy makes funny comments
05:44:25 <vincenz> "The Paradox of Choice - Why More is Less"
05:52:59 <azuroth> lisppaste2: paste
05:53:06 <metaperl> does Haskell have parametric polymorphism? I would like to see a reverse function for 2-tuples... or write one
05:53:19 <metaperl> reverse (x,y) = (y,x)
05:53:26 <metaperl> is that OK or is it a conflict?
05:53:50 <mux> it's OK
05:53:54 <Saulzar> That's fine... reverse :: (a, b) -> (b, a)
05:54:03 <metaperl> will list reverse still work?
05:54:22 <Saulzar> Ah, no - the name will conflict. 
05:54:25 <mux> yes, but you'll need to qualify it
05:54:28 <mux> to avoid namespace conflicts
05:57:21 <psi`> do you actually mean overloading?
05:57:59 <dons> metaperl: yeah, of course we have parametric polymorphism :)
05:58:09 <metaperl> :)
05:58:21 <dons> > let f (x,y) = (y,x) in f (2,'a')
05:58:21 <lambdabot> ('a',2)
05:58:50 <dons> you'd want to give it another name though.
05:59:17 <dons> since picking a name that's in the prelude is bad form.
06:05:14 <metaperl> someone please help me write the program the way a skilled haskeller would: http://rafb.net/paste/results/2fqe0J11.html
06:10:33 <metaperl> I've reworded the problem a bit. But the problem still remains: 
06:10:40 <metaperl> http://rafb.net/paste/results/Scd9zf20.html
06:15:27 <metaperl> ok I'm heading to my blog. no one's helping me
06:17:26 <delinka> 'nother question: the modern GUI app doesn't *do* anything until the user interacts with it -- it processes events, otherwise there's not really any application code running. Con one write a GUI app in Haskell? This applies to server processes, too. I'm trying to further explore the sentence from the wiki "A functional program is a single expression, which is executed by evaluating the expression." 
06:17:57 <araujo> metaperl, mm..
06:18:04 <araujo> metaperl, what exactly do you want?
06:18:05 <metaperl> ?
06:18:36 <metaperl> my two dictionaries
06:18:43 <Saulzar> I don't understand either sorry, had a look but not sure what you mean
06:19:01 <metaperl> I want to to be able to say lookup codeToStateDictionary "WA"
06:19:07 <metaperl> and have it return "washington"
06:19:31 <metaperl> but the issue is how to create a dictionary whcih is not wrapped in the IO monad...
06:19:38 <araujo> well, i only can see that you might probably use point free in a few definitions, use local declarations for other functions, but that'd be mostly syntactic sugar i suppose.
06:19:40 <araujo> mm...
06:19:40 <Saulzar> Ok - so you have a function to read it in, a function to make a dictionary...
06:20:05 <metaperl> or do I have to do fmap (\db -> lookup db "WA") containerizedDB
06:20:23 <metaperl> Saulzar: you mean a pure function which operates on a pure string?
06:20:29 <metaperl> my string is IO-tainted
06:20:33 <vincenz> google tech talks rock
06:20:51 <araujo> you mean that you wanna return String, instead of IO String?
06:21:08 <metaperl> the comments at the top say what I want to do... is that possible
06:21:13 <metaperl> I just said it again also
06:21:19 <metaperl> I want to to be able to say lookup codeToStateDictionary "WA"
06:21:24 <metaperl> and have it return "washington"
06:21:35 <Saulzar> do  lines <- codeFileToLines; let dict = codeToStateDict lines;  return (dosomethingWithDict dict ...)
06:21:56 <metaperl> what I return will be IO tainted no?
06:22:01 <metaperl> via the return call
06:22:13 <Saulzar> Right - but at the top level you never get out of that, impossible
06:22:25 <metaperl> that is the craziest thing I have ever heard
06:22:28 <araujo> @hoogle lookup
06:22:28 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:22:28 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:22:28 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
06:22:43 <metaperl> I'm using the Prelude one
06:22:52 <Saulzar> metaperl, But the intermediate values are not of the IO type, so you can use them as you like with pure functions
06:23:00 <metaperl> I think Philippa read a config file in her Flippi wiki... and managed to use it in her program
06:23:29 <araujo> metaperl, you need to remenber something, the IO monad is a one-monad, once you get into it, you can't (safely) get out of it.
06:23:40 <metaperl> is that useful?
06:23:44 <araujo> one-way-monad even
06:23:44 <Saulzar> main is of type IO () - so everything returns to IO in the end, you can have most of your program as pure functions though
06:23:46 <metaperl> why the paranoia around IO
06:23:59 <metaperl> I understand the theoretical reasons, but are there any good practical reasons for that?
06:24:09 <araujo> metaperl, yes, it is useful to preserve the language purely functional 
06:24:16 <metaperl> that's theoretical
06:24:22 <Saulzar> metaperl, There's no paranoia - when you're inside IO you can use the values as you please
06:25:13 <Saulzar> You never _need_ to get out of IO - since you can always use pure functions in expressions, you might have a main which looks like this:
06:25:28 <araujo> metaperl, IO is juat a way of encapsulating input-output operations inside a purely functional language.
06:25:37 <eivuokko> metaperl, experience has shown that not using IO everywhere makes programs easier to debug and read.  It is also common style in haskell to restrict state severely, and with IO all bets are off in that account.
06:25:56 <metaperl> I see
06:26:07 <metaperl> in 28 years of programming I have never dealt with this
06:26:07 <araujo> But you can apply pure functions inside that encapsulation. Nevertheess, you can' safely take impure operations out of it.
06:29:05 <xerox> vincenz: downloading it now (-:
06:36:00 <metaperl> could someone please help me get do-notation working for my program... I can't extract things from the IO monad: http://rafb.net/paste/results/A7dgZa25.html
06:37:20 <Saulzar> lookup "WA" (codeToStateDict l)  is a non IO value, so you need to give it a name like ... 
06:37:29 <Saulzar> let foo = lookup "WA" (codeToStateDict l); return foo
06:37:37 <Saulzar> or just return (lookup "WA" (codeToStateDict l))
06:38:08 <delinka> is this the place to get help with compiling lambdabot?
06:38:30 <metaperl> do { l <- codeFileToLines; let lu = lookup "WA" (codeToStateDict l) ; re\
06:38:30 <metaperl> turn lu} 
06:38:43 <metaperl> <interactive>:1:79: parse error on input `}' 
06:38:52 <metaperl> Saulzar: it didn't work
06:40:12 * metaperl steals a glance at Application Development with Ocaml
06:42:12 <metaperl> # read_line ;;
06:42:12 <metaperl>  
06:42:12 <metaperl> - : unit -> string = <fun>
06:42:19 <metaperl> ooh, sweet
06:42:21 <tuxplorer> emacs' eshell takes elisp expressions right? can i make it take haskell expressions as well? is there any plugin for that?
06:42:51 <Saulzar> Err.. parse error?
06:43:07 <araujo> codeFileToLines >>= return . lookup "WA" . codeToStateDict
06:43:12 <araujo> metaperl, give it a try
06:43:31 <Saulzar> Ah - metaperl, that's because the let block also works with brackets/semicolons
06:44:10 <Saulzar> So the first semicolon after the let is taken by the let... I'd just use the block layout, much simpler - alternatively you can surround the let with { } too
06:44:16 <metaperl> araujo: it worked
06:44:53 <araujo> metaperl, yes, the problem was that you were trying to return a Maybe value outof the IO monad
06:45:34 <xerox> tuxplorer: Emacs shell?
06:45:40 <araujo> preceding return before the lookup functions encapsulate the value into it.
06:45:42 <tuxplorer> xerox:  yes
06:45:58 <xerox> tuxplorer: to evaluate elisp expressions just put the point after the last closed paren and press C-x C-e
06:46:09 <xerox> tuxplorer: in order to work with Haskell you have to have haskell-mode.
06:46:26 <tuxplorer> xerox: how do i get that haskell-mode?
06:46:35 <xerox> (There also is M-x ielm which gives you an elisp prompt.)
06:46:49 <xerox> What happens if you open an .hs file?
06:46:59 <tuxplorer> xerox: i'm able to get to elisp prompt.. i want to get something like that for haskell
06:47:00 <xerox> Justo to check wether you Emacs come with it installed or not.
06:47:13 <tuxplorer> xerox: all appear int the same color
06:47:25 <xerox> Well yes, it has to be configured, but it's simple.
06:47:32 <xerox> So you have to download the Haskell-mode tarball.
06:47:32 <metaperl> tuxplorer: you can type ghci in the emacs shell
06:47:40 <metaperl> tuxplorer: I dont use eshell... I use comint
06:47:45 <xerox> @where haskell-mode
06:47:45 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
06:48:04 <xerox> Download the 2.1 version.
06:48:12 <metaperl> tuxplorer: haskell mode is standard with xemacs and I would guess emacs as well
06:48:17 <tuxplorer> metaperl: yes. i can type ghci.. but just curious to find something like elisp mode for haskell :)
06:48:19 <metaperl> you should not have to d/l it
06:48:30 <xerox> tuxplorer: tell me when you got it
06:48:32 <metaperl> tuxplorer: open a file with a .hs extension
06:48:37 <Saulzar> metaperl, and yes - ocaml does seem easier if you are starting out, but the syntax and the inconsistancy resulting from mutability really got to me before long.
06:48:40 <tuxplorer> xerox: just today
06:48:57 <metaperl> Saulzar: interesting
06:49:06 <xerox> Now do something like mkdir ~/.elisp
06:49:14 <jip> delinka: you still looking for an answer to your gui question?
06:49:22 <tuxplorer> xerox" ok..
06:49:22 <delinka> yup
06:49:32 <xerox> cd ~/.elisp; tar xvfz /path/to/haskell-mode-2.1.tar.gz
06:50:47 <jip> delinka: that sentance you quoted isn't the entire truth. haskell has this thing called the IO monad, that basicly let's you do things very similar to what you do in the programming languages you are familiar with
06:51:34 <xerox> tuxplorer: now open your ~/.emacs (create one if needed) and write something like this, which is what I use:
06:51:35 <araujo> jip, and in a *safer* way
06:51:35 <xerox> (load "~/.elisp/haskell-mode-2.1/haskell-site-file.el")
06:51:35 <xerox> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
06:51:35 <xerox> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
06:51:35 <xerox> (setq-default haskell-program-name "/usr/local/bin/ghci")
06:51:45 <psi`> metaperl: gnu emacs doesn't come with haskell mode
06:51:48 <jip> delinka: so a haskell program that uses IO monad is not an expression that is evaluated, but it is like a c program, a sequence of instructions that are executed
06:52:03 <metaperl> psi: I see. XEmacs does
06:52:05 <delinka> jip: ok, thanks
06:52:08 <psi`> unfortunatly...
06:52:09 <xerox> (We call them actions.)
06:52:27 <metaperl> as long as you install the package tarball it does
06:52:58 <Saulzar> delinka, But the difference is you join the instructions as an expression (and the same abstraction used is useful in placs other than IO) 
06:53:04 <jip> delinka: there are haskell bindings for wx and gtk+, that use the IO monad, so you program with them in a similar way as you are used to
06:53:16 <tuxplorer> xerox: ok. i'll do that and see if it works.. :)
06:53:32 <xerox> tuxplorer: then either evaluate the buffer/file or close and reopen emacs.
06:53:47 <tuxplorer> xerox: ok
06:54:26 <jip> delinka: some people consider the IO monad to be "evil", and recommend to try to avoid using it as much as possible. their goal is to try to figure out "pure functional" ways of doing things. for example, some people are doing research into doing gui programming in a purely functional way
06:55:38 <xerox> Monads are purely functional in Haskell.-
06:55:44 <xerox> s/-$//
06:55:58 <jip> yeah, but IO isn't
06:56:10 <araujo> ?
06:56:18 <sieni> jip: ?
06:56:29 <xerox> Well, it is from the programmer perspective.
06:56:30 <araujo> IO is a monad
06:56:36 <delinka> jip, Saulzar: I figure if you "expression" needs IO (say, user input) then it's going to block until it gets it anyway. Not sure how that's not 'pure functional'
06:57:09 <xerox> jip: maybe it's better to say that IO is done in such a fashion that preserves referential transparency.
06:57:59 <psi`> delinka: a pure function will always return the same value given the same input. if you read user input that's not going to be the case.
06:58:01 <araujo> That's why i usually like to explain the IO monad like a kind of encapsulation for impure operations.
06:58:32 <araujo> But preserving referential transparency of course.
06:58:46 <araujo> Inside a purely functional language.
06:58:56 <delinka> psi`: guess I didn't realize that was part of the definition of 'pure function' ... more to think about
07:00:08 <xerox> delinka: '=' has a rather special meaning in Haskell. RHS = LHS means that RHS and LHS are the same thing no matter what. Every time you see RHS you can replace it with LHS and vice-versa. It gives you a powerful substitution model for evaluating expressions.
07:00:16 <araujo> well, here, the 'pure function' definition is related to the mathematical definition of a function.
07:00:36 <xerox> delinka: take for example evens = 0 : map (+1) odds; odds = map (+1) evens (-:
07:00:51 <delinka> araujo: guess that makes sense, since it's based in lambda calc.
07:00:58 <araujo> delinka, right
07:01:19 <Saulzar> delinka, the conceptual model for IO is of passing the "Real world" around, so if you get a new real world you could have different input for example
07:01:32 <delinka> fyi, I'm just reading about Haskell for the first time today.
07:02:24 <araujo> cool
07:02:34 * delinka still can't get lambdabot to compile
07:03:11 <sieni> delinka: what's your problem?
07:03:33 <delinka> output: http://pastebin.com/715273
07:03:58 <delinka> and I've compiled and installed hs-plugins
07:04:49 <sieni> didn't it need also the fps package? (i.e. fast packed strings)
07:05:09 <delinka> I dunno ... didn't see that in the README ... looking
07:05:57 <delinka> "Build the Data.ByteString library..." -- crap
07:07:22 <delinka> gtgfk, bbl
07:07:54 <azuroth> gotta go fight krime?
07:08:27 <xerox> @vixen gtgfk?
07:08:27 <lambdabot> nevermind about that
07:11:03 <delinka|out> ...for know
07:11:18 <delinka|out> fight krime was good tho...
07:11:34 <tuxplorer> xerox: still it doesnt give me syntax highlighting.. 
07:11:36 * delinka|out really isn't here
07:12:01 <xerox> tuxplorer: that is a main Emacs configuration, namely (global-font-lock-mode t)
07:12:37 <xerox> s/t/1/ maybe
07:12:47 <tuxplorer> xerox: ok
07:13:30 <xerox> I also like iswitchb-mode, column-number-mode, line-number-mode, show-paren-mode, transient-mark-mode and display-time :-)
07:14:09 <xerox> (Each of these has to be put as (...-mode 1) in ~/.emacs, the last one is just (display-time)--experiment with your own ones, and read http://www.emacswiki.org/ :-))
07:14:52 <tuxplorer> xerox: ok. thanks :)
07:15:52 <xerox> Maybe read up on those before enabling them, the second-last just highlights selections while you're taking them (by default you don't see what you're selecting, strangely enoough.)
07:27:59 <ADEpt> any HaXml wizards here at this time? :)
07:32:03 <sieni> no?
07:32:18 <jip> what about haskell xml toolbox?
07:32:20 <sieni> isn't hsxml the word of the day? :-)
08:07:08 <vincenz> someone call?
08:07:25 <vincenz> xerox: ah, backtraced, did you see it?
08:08:13 <xerox> Still watching another :-)
08:08:34 <vincenz> how do I get a listing of google tech talk shows
08:32:51 <vincenz> happy is fully GLR?
08:34:10 <xerox> vincenz: hmpf, some times the slides aren't showed, each time people laugh more or less :-)
08:34:41 <vincenz> xerox: cartoons
08:41:28 <cogumbreiro> hello
08:41:36 <cogumbreiro> anyone knows why is this error appearing? http://rafb.net/paste/results/4PCoJX13.html
08:41:38 <xerox> Yo.
08:41:48 <cogumbreiro> (i have the example wich raises it)
08:41:58 <xerox> You need to indent then and else clauses a bit more
08:41:59 <cogumbreiro> (in the same paste)
08:42:49 <xerox> @pl (==[]) -- is also called null
08:42:49 <lambdabot> ([] ==)
08:43:00 <xerox> Hmpf, well, it's called null :-)
08:43:42 <cogumbreiro> http://rafb.net/paste/results/PjIOlt27.html <- same error now on the 'else'
08:44:03 <cogumbreiro> i tried surrouding the 'return ()' with parenthisis but it didn't work
08:44:08 <xerox> if <a> then <b> else <c>
08:44:16 <xerox> if <a>
08:44:17 <xerox>   then <b>
08:44:17 <xerox>   else <c>
08:44:31 <cogumbreiro> oh
08:44:41 <cogumbreiro> then why was the first one failling?
08:44:44 <xerox> You indent relatively to the scope
08:45:01 <xerox> Because, as I said, you have to indent more the then and the else part of the if expression.
08:45:08 <sieni> cogumbreiro: haskell is a bit sensitive about indentation. you can disable it using braces and semicolons
08:45:33 <cogumbreiro> i like indentation, I am trying to understand how it works
08:45:49 <cogumbreiro> I think i might of skipped that part on the book i'm reading...
08:46:08 <xerox> Wrong:     Right:
08:46:09 <xerox> if <a>     if <a>
08:46:09 <xerox> then <b>     then <b>
08:46:09 <xerox> else <c>     else <c>
08:46:40 <cogumbreiro> oh, now i understand
08:46:44 <sieni> cogumbreiro: in the first example, if you indent the lines 5 and 6 with one space to the right, then it works ok
08:47:17 <cogumbreiro> thanks alot :)
08:47:23 <xerox> You're welcome.
08:47:33 <sieni> I really think that the indentation-sensitive syntax is a pain in the ass, but with haskell I'm ready to tolerate it, since the language is otherwise very nice
08:48:16 <cogumbreiro> i'm learning the language and I find it very interesting
08:48:30 <cogumbreiro> made finally understand how to do functional programming
08:48:31 <sieni> and you can force haskell to ignore indentation with {, ; and }, so it's not that big a deal as opposed to the other popular language, which is just completely annoying
08:48:36 <xerox> loop = do line <- getLine
08:48:36 <cogumbreiro> which scheme failed to
08:48:37 <xerox>           guard (null line)
08:48:37 <xerox>           loop
08:48:37 <xerox> Maybe this way.
08:48:40 <jewel> you should use a decent editor (if you're not already)
08:48:48 <xerox> @type when
08:48:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:49:19 <cogumbreiro> jewel, is there a decent free editor for linux? i'm using gvim
08:49:22 <xerox> loop = do line <- getLine
08:49:22 <xerox>           when (not (null line)) loop
08:49:22 <xerox> Or this.
08:49:32 <cogumbreiro> sieni, true
08:49:49 <psi> cogumbreiro: emacs
08:49:50 <cogumbreiro> sieni, although i'm used to that since I'm mostly a python programmer
08:50:04 <cogumbreiro> psi, that's too hard to understand :P
08:50:12 <cogumbreiro> harder then learning a new language
08:50:17 <cogumbreiro> (kidding)
08:50:25 <sieni> cogumbreiro: oh, hehe :-)
08:50:27 <xerox> cogumbreiro: open it and press C-h t (C- means "hold the ctrl key while pressing...")
08:50:28 <jewel> dude, emacs!!!
08:50:46 <psi> that will give you a tutorial
08:51:01 <xerox> I think it's a pretty good one, you'll be able to use it in a short time.
08:51:03 <sieni> cogumbreiro: But I found it useful to learn scheme first and then haskell (although I don't claim to be very fluent in either)
08:51:40 <cogumbreiro> sieni, for example learning how to do proper Continuation Passing Style was natural on haskell
08:51:55 <xerox> Er?
08:52:06 <cogumbreiro> sieni, the same didn't happen before when I was learning how to do it using Scheme...
08:52:40 <sieni> cogumbreiro: it might be that you already knew some of the stuff so you found it easier to learn completely with haskell
08:53:02 <cogumbreiro> sieni, yes that's what happened
08:53:17 <cogumbreiro> sieni, and certainly due to a saner language with a cleaner syntax
08:54:29 <sieni> cogumbreiro: well... the haskell and scheme syntaxes are quite different. after all scheme is a lisp
08:55:05 <cogumbreiro> Another problem with scheme is macros, which make the language more implicit
08:55:25 <cogumbreiro> for example, they can allow some arguments of a function to be lazy evaluated and others not (like the if)
08:55:34 <cogumbreiro> on haskell it just makes more sense
08:55:42 <sieni> cogumbreiro: ahh, yes
08:56:09 <sieni> cogumbreiro: but you really can't implement if as a function in scheme, since it's strictly evaluated
08:56:29 <cogumbreiro> yes
08:56:32 <cogumbreiro> u're correct
08:56:59 <sieni> in haskell if-then-else is just a plain old function
08:57:11 <cogumbreiro> :)
08:57:50 <sieni> but scheme and lisp macros are very powerful and worth of study as such
08:58:10 <cogumbreiro> but are barely readable
08:58:24 <jip> what about template haskell?
08:58:26 <cogumbreiro> oh, i have to run, was loving the chat :)
08:58:35 <cogumbreiro> jip, still didn't meet it :)
08:58:40 * cogumbreiro is gone
08:59:22 <sieni> jip: the s-expression syntax of lisps make it especially nice for syntactic manipulation
09:00:23 <sieni> (I'm not expressing here an opinion about template haskell, since I don't know much about it besides that it exists and is supposed to provide compile-time meta-programming)
09:01:22 <sieni> also lisp systems allow nicely to develop software so that you keep a lisp image running and patch the software continuously
09:01:41 <sieni> which is not that easy when you have static typing and all that
09:02:31 <jip> don't see how static typing is much of a problem there
09:03:31 <ADEpt> @hoogle [a] -> [a] -> Maybe Int
09:03:32 <lambdabot> No matches, try a more general search
09:04:15 <sieni> well, if you have a reference to a function and want to change that in runtime, you hit into monomorphism restriction
09:04:27 <sieni> well, if you have a reference to a function and want to change that in runtime, you hit into monomorphism restrictioni
09:04:31 <sieni> oops
09:04:31 <sieni> sorry
09:12:11 <jip> monomorphism restriction has bitten me in the past
09:12:17 <jip> but you can get around it
09:15:30 <ADEpt> stupid questions: the fastes way you'd code removal of substring from a string?
09:15:48 <sieni> but anyway repl-style development is easier in lisps. but i'm just saying that it's a drawback. i don't like dynamic typing since i want to catch type errors during compile time, since those are the most common mistakes i do
09:16:26 <sieni> ADEpt: that probably depends on the fundamental implementation of strings
09:16:54 <ADEpt> sieni: well, lets take your basic everyday String (which is [Char])
09:18:53 <sieni> ADEpt: you need to keep make a copy of the beginning of the string while you scan and then just cons the stuff you have found in the beginning of the string
09:19:02 <sieni> when you've found the match
09:19:53 <ADEpt> sieni: i thought that probably one can do fast fusion of some Data.List functions. splitAt apparently is not the best candidate here
09:43:25 <malcolm> Anybody around who knows about the organisation of the summer-of-code?
09:43:48 <xerox> Howdy malcolm!
09:43:54 <xerox> You're the YHC guy right?
09:44:12 <malcolm> Errm, well more nhc98, but I tease the yhc people from time to time
09:44:27 <xerox> (Yes, I did organize the initial effort to get Haskell.org to mentor students :-)
09:45:04 <malcolm> But yeah, ndm was telling me that my proposed SoC project (typechecker for yhc) needs me to register somewhere as a mentor
09:45:16 <xerox> Right, go here <http://code.google.com/soc/mentor_step1.html>
09:45:23 <malcolm> I put my name on the trac wiki
09:45:29 <xerox> Yup, that too.
09:45:41 <malcolm> but I couldn't find any instructions to do anything else official
09:46:02 * malcolm follows the link given by xerox
09:46:21 <ADEpt> malcolm: 1)register on goolge; 2)poke shapr, syntaxpolice or dons to approve you; 3)start ranking applications and taking them for mentorship
09:46:48 <malcolm> OK
09:47:01 <xerox> As soon as you'll be officially mentor you'll be in the mentors mailing list too 
09:49:44 <malcolm> Hmm, I'm confused.  The link xerox gave asks me to sign up as a mentor *organisation*, but I thought haskell.org had already done that
09:50:10 <xerox> Err?
09:50:28 <xerox> Haskell.org *is* a mentoring organization.
09:50:52 <xerox> "Hi, you are about to sign up to be a Summer of Code 2006 Mentor, ..."
09:51:44 <malcolm> quote: By submitting an application (an "Application"), you hereby agree and notify us that you wish to participate in the Summer of Code as a Mentor Organization
09:52:14 <musasabi> malcolm: that is just confusing text.
09:52:19 <xerox> Indeed.
09:52:28 * musasabi wondered about the same thing
09:52:56 <malcolm> I read the whole agreement, and none of it mentioned anything about being a individual associated with a mentoring organisation.
09:53:08 <xerox> That's said to be the "MENTORING ORGANIZATION principal agreement"
09:53:22 <xerox> Well, dunno.
09:56:48 <malcolm> The FAQ says that mentors should sign up "using the Summer of Code online application system.", but does not give a link to it.  
09:57:25 <xerox> (Right, everybody went throught that url anyway.)
09:57:41 <musasabi> malcolm: I think all of used that form. It will later ask you for the organisation.
09:57:49 <musasabi> *all of us
09:59:35 <malcolm> OK, then it asks me to create a google ID, and only after that, do I get a sign-up form as a mentor.
09:59:47 <xerox> Yes.
10:00:02 <davidhouse> hmm. i really think my haskell productivity will be going down in the near future.
10:00:24 * davidhouse has just discovered a SNES emulator and an old Zelda game
10:00:28 <xerox> Last year they didn't request that silly ID thing, but it probably helps them to organize things better.
10:00:55 <mux> davidhouse: zelda 3?
10:01:17 <davidhouse> mux, a link to the past, whichever one that was.
10:01:23 <mux> yep, that's the 3 :-)
10:01:29 <mux> it's great, I finished it with zsnes
10:01:36 <davidhouse> that's what i'm playing it with.
10:01:41 <mux> I had it (physically) years ago
10:01:43 <davidhouse> anyway, gotta dash, pizza's ready.
10:03:49 <malcolm> xerox: thanks for your help, I'm all signed up now
10:04:01 <xerox> You're very much welcome.
10:04:39 <xerox> You just need to go through the ranking process, I think the other mentors can give you advices about that.  Well, as soon as an admin takes care of working out your subscription.
10:07:55 <metaperl> Philippa_: where is the latest version of FLippi at?
10:08:54 <metaperl> http://www.flippac.org/projects/flippi/ i presume
10:14:53 <ADEpt> malcolm: you could ask me, for instance
10:15:34 <malcolm> ADEpt: ask you what?
10:15:55 <ADEpt> malcolm: about SoC ranking details
10:16:15 <malcolm> ADEpt: tell me about SoC ranking details :-)
10:16:43 <ADEpt> malcolm: can you already see the list of applications?
10:17:04 <ADEpt> malcolm: at http://code.google.com/soc/haskell/open.html ?
10:17:07 <malcolm> Where would I look?
10:17:10 <malcolm> Oh
10:17:43 <malcolm> It tells me "students cannot sign in as mentors"
10:18:20 <metaperl> very bizarre. why didn't Philippa_ use strings?
10:18:23 <metaperl> case m of
10:18:23 <metaperl>               'G':'E':'T':[] -> handleGet qs env
10:18:23 <metaperl>               'P':'O':'S':'T':[] -> handlePost qs env              
10:18:23 <metaperl>               _ -> malformedQueryPage env
10:18:41 <ADEpt> malcolm: then you are not approved by community adminst yet
10:18:46 <ADEpt> @seen shapr
10:18:47 <lambdabot> shapr is in #ScannedInAvian, #haskell and #haskell-overflow. I last heard shapr speak 1 day, 2 hours, 18 minutes and 53 seconds ago.
10:18:51 <ADEpt> @seen Lemmih
10:18:52 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 5 hours, 14 minutes and 57 seconds ago.
10:18:57 <ADEpt> @seen dons
10:18:58 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 4 hours, 19 minutes and 39 seconds ago.
10:19:08 <ADEpt> @seen SyntaxPolice
10:19:08 <lambdabot> I haven't seen SyntaxPolice.
10:19:17 <ADEpt> @get-shapr
10:19:18 <lambdabot> shapr!!
10:21:15 <ADEpt> malcolm: as soon as you are approved, you'll see the list of applications by following that link. 25 links to applications per page. By opening application page you could read it in full and rank it by modifying it's score +4,+2,0 or -2. You could rank all of them (takes time, preferrable)
10:21:37 <ADEpt> malcolm: or you could just select those that you want and choose "i will mentor this application"
10:21:47 <ADEpt> malcolm: that's pretty much it, in a nutshell
10:21:55 <malcolm> looks easy enough
10:27:02 <Cale> If you rank something multiple times, the rankings stack.
10:29:04 <xerox> Cale: does it improve the system or what?
10:39:23 <norpan> wassup
10:39:31 <Cale> xerox: It's just strange
10:39:40 <xerox> Okay (-:
10:40:37 <Cale> xerox: You'd kind of expect that if you rerate an application to something lower than you originally did, that the ranking would decrease, but it actually goes up (unless you chose a negative ranking)
10:40:44 <tuxplorer> i need a good tutorial for learning FFI.. 
10:41:02 <xerox> Cale: woops.  I see what you mean.
10:41:25 <xerox> Cale: maybe it makes things more "stable"?
10:41:40 <xerox> But I agree it's kind of strange.
10:41:48 <Cale> Well, it basically means that a mentor is able to set any ranking that they like
10:41:59 <Cale> I would have preferred an editbox for that.
10:42:16 <xerox> Given that it's an even number :-)
10:42:31 <Cale> no, you can set odd numbers too
10:42:50 <Cale> isn't there a ranking which gives it +1 ?
10:42:55 <xerox> Seems not to me.
10:43:10 <Cale> maybe it was changed
10:43:19 <xerox> But it's filtered informations what I have :-)
10:43:24 <tuxplorer> xerox: can u give me a good tut for learning FFI? is there something better than http://www.reid-consulting-uk.ltd.uk/docs/ffi.html ?
10:44:16 <xerox> http://haskell.org/ghc/docs/latest/html/users_guide/ffi.html
10:44:21 <Cale> xerox: then how are there odd scores in the list?
10:44:48 <Cale> ah, yeah, it's +4, +2, +1, 0, or -2
10:44:55 <xerox> Ah, what is +1 ?
10:45:00 <tuxplorer> xerox: thanks
10:45:07 <Cale> "I find this application interesting"
10:45:07 <xerox> tuxplorer: yw
10:45:11 <xerox> Cale: okay.
10:45:24 <Cale> +2 is "I believe this application should be mentored"
10:46:18 <xerox> I wonder why everybody didn't report the +1.
10:47:28 <Cale> looks like SamB's proposal has been assigned to me
10:47:40 <xerox> Oh (-:
10:47:57 <Beelsebob> ahhh, that's how you work forgien export!
10:48:49 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:49:21 <Cale> the FFI addendum is actually pretty easy to read, and is probably the best reference
10:49:29 <Beelsebob> XHoogle should be pretty straight forward then
10:50:18 * Beelsebob wonders how more complex types cross the devide
10:50:24 <metaperl> How do you convert this to do-notation:
10:50:25 <metaperl> codeFileToLines >>= return . lookup "WA" . codeToStateDict
10:50:32 <metaperl> @pl codeFileToLines >>= return . lookup "WA" . codeToStateDict
10:50:32 <lambdabot> (lookup "WA" . codeToStateDict) `fmap` codeFileToLines
10:51:12 <Cale> do x <- codeFileToLines; return . lookup "WA" $ codeToStateDict x
10:51:19 <xerox> do lines <- codeFileToLines
10:51:19 <xerox>    return (lookup "WA" (codeToStateDict lines))
10:51:24 <ADEpt> metaperl: do x <- codeFileToLines; return $ lookup "WA" $ codeToStateDict x 
10:52:18 <metaperl> thanks
10:52:32 <metaperl> you guys have just allowed me to slag Haskell...
10:52:41 <xerox> action1 >>= action2  ===  do { x <- action1; action2 x }
10:52:43 <metaperl> I hate to be mean like that
10:52:56 <Beelsebob> what does that allow you to slag?
10:53:15 <xerox> I wonder why you want to do everything into IO.
10:53:18 <metaperl> I'm writing an article for Lamdba the Ultimate entitled: "Haskell's myopic adherence to functional purity leads to gross violation of basic software design principles"
10:53:28 <Cale> what?
10:53:41 <Beelsebob> so what software design principle does it violate?
10:54:01 <Cale> and how is Haskell's adherence to functional purity myopic?
10:54:10 <xerox> I think he's upset because in order to use IO somewhere one needs to perform a global transformation on the whole code.
10:54:12 <tuxplorer> thanks Cale saw ur reply just now.. :)
10:54:53 <Beelsebob> xerox: except one doesn't... one needs to confirm that it's safe to do so and break out the unsafePerformIO functions
10:55:09 <Cale> You don't use unsafePerformIO either :)
10:55:13 <metaperl> Cale: here is a preprint of my article http://rafb.net/paste/results/QwsvWW33.html
10:55:24 <xerox> Beelsebob: I know, but there is some flaw either.
10:55:27 <Beelsebob> this is an argument for another time... but yes I do...
10:55:39 * Beelsebob goes
10:56:26 <Cale> metaperl: the idea is to do just the IO in the IO monad, not your whole application
10:56:41 <Cale> all of the real computation should be handled by pure functions
10:57:02 <Cale> It's always possible to do this because pure functions easily lift into IO
10:57:05 <metaperl> that is impossible. look a Philippa_'s wiki: the whole program is nothing but a bunch of do-notation
10:57:25 <metaperl> you should refer to objects with promises not functions with pure values
10:57:26 <xerox> I don't think Philippa's do's are IO ones.
10:57:52 <xerox> (`do' blocks are just a syntactic sugar over Monads, IO is just one of them.)
10:58:23 <metaperl> look how much simpler it is in Ocaml to convert a file to [String]
10:58:36 <metaperl> and then create a [(a,a)] out of it
10:59:49 <Saulzar> Only difference is that one has an IO type. It's really no big deal, all it does is force you to structure your program well.
11:00:16 <Cale> Sure, you *can* code everything in the IO monad, but nobody does.
11:00:20 <xerox> do contents <- readFile filename
11:00:21 <xerox>     doSomethingWith (lines contents)
11:00:21 <xerox>     ...
11:00:21 <xerox>     eventuallyDoMore
11:00:31 <ADEpt> metaperl: your article just proves that it is possible to write ugly code in any language, given enough motivation :)
11:00:56 <metaperl> Saulzar: I already said, good program structur separates interface from implementation... you spend most of your time in Haskell trying to pick things out of the IO monad, which means that the way the data was got is always staring you in the face
11:01:09 <metaperl> ADEpt: you guys just gave me the ugly code
11:01:13 <Saulzar> It makes the intent of your code clear. In Ocaml you have to dodge around mutability everywhere. Haskell you _know_ by the type.
11:01:17 <xerox> metaperl: I think the monads help you in dividing that interface.
11:01:27 <Cale> metaperl: you wouldn't have to if you didn't write them in the IO monad in the first place
11:01:37 <metaperl> Cale: what other choice did I have?
11:01:41 <Cale> Only do IO in IO
11:01:50 <Cale> that is, read the file as a String in IO
11:01:58 <Cale> and print whatever output you have
11:02:03 <Cale> but nothing else
11:02:13 <Cale> no other processing should have an IO type attached to it
11:03:02 <metaperl> Cale, how do I use my module in another module without needing to know the fact that LocaleUS got it's data via  IO?
11:03:30 <xerox> main = do { contents <- readFile "..."; writeFile "..." (process contents) } -- and then `process' is a pure function which does your computation.
11:03:31 <metaperl> here is my LocaleUS module: http://rafb.net/paste/results/dZpEVs96.html
11:03:43 <Cale> By having your functions take a (pure) data structure which is returned by some IO action in your module
11:04:02 <xerox> Right!  Like `process' there.
11:04:07 * tuxplorer goes to sleep
11:08:06 <jip> Philippa: hey, folks were just talking about you :)
11:08:37 <metaperl> very bizarre. why didn't Philippa use strings?
11:08:52 <Cale> she used proper datastructures
11:08:52 <metaperl> case m of
11:08:52 <metaperl>               'G':'E':'T':[] -> handleGet qs env
11:08:52 <metaperl>               'P':'O':'S':'T':[] -> handlePost qs env              
11:08:52 <metaperl>               _ -> malformedQueryPage env
11:09:11 <Cale> oh, in that case, she could match against strings, sure
11:09:27 <metaperl> she couldnt have written "GET" -> handleGet qs env
11:09:28 <Cale> I thought you were referring to the use of HTML datastructures.
11:09:33 <Cale> she could have
11:09:46 <metaperl> why didn't she?
11:10:10 * metaperl investigates how clean does I/O
11:11:45 <newsham> re: linspire.  wow!  neat.
11:11:58 <mwc> linspire? Huh?
11:12:05 <metaperl> I/O should be seen as just another sequence
11:12:14 <metaperl> you dont have a guarantee about the elements of a list
11:12:21 <metaperl> oh, but a list is a monad
11:12:23 <metaperl> hmm
11:12:26 <xerox> Indeed.
11:12:36 <metaperl> but it doesnt get all the separation that IO does
11:12:41 <metaperl> you can use lists anywhere
11:12:49 <metaperl> IO is just a list of data
11:13:02 <metaperl> a file is just a list of strings
11:13:06 <metaperl> IO is handled wrong in Haskell
11:13:44 <mwc> it is?
11:13:47 <delinka> ooooo
11:13:55 <delinka> lambdabot compiled
11:14:04 <newsham> hmm.. msg isnt in the h-c archive yet.  linspire announced they're moving to haskell as their core language for developing utilities for linspire
11:14:15 <Saulzar> metaperl, You might want to look at 1 simple function to use for IO initially - interact, it does just that - you give it a function from String -> String
11:14:18 <mwc> wow! neat.
11:14:39 <metaperl> Clean is the only functional language in the world which offers uniqueness typing. This type system makes it possible in a pure functional language to incorporate destructive updates of arbitrary data structures (including arrays) and to make direct interfaces to the outside imperative world.
11:14:43 <metaperl> @type interact
11:14:44 <lambdabot> (String -> String) -> IO ()
11:14:44 <mwc> metaperl, I don't think looking at IO as a list of data is correct
11:14:54 <mwc> what about IO actions that don't depend on data
11:14:57 <metaperl> mwc: but a file is
11:15:00 <mwc> yeah
11:15:16 <metaperl> so why not look at a file as a list of strings
11:15:18 <mwc> so there's that interact function mentioned above that provides that abstraction for you
11:15:26 <metaperl> i dont understand it
11:16:01 <Saulzar> metaperl, Because a lot of programs require much more flexibility than to read files or streams. 
11:16:04 <xerox> lisppaste2: url
11:16:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:16:18 <metaperl> so why not make simple things simple?
11:16:18 * Heffalump reads debian-haskell and briefly wonders if it's April 1st
11:16:24 <metaperl> lol
11:16:31 <mwc> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Ainteract stdin is passed to a function which maps that to a string, which is output to stdout
11:16:36 <Saulzar> metaperl, But if that's all you need - use main = interact (your function string -> string)
11:17:06 <newsham> http://www.haskell.org//pipermail/haskell-cafe/2006-May/015642.html <- linspire
11:17:20 <mwc> metaperl, because providing a more general facility is better than providing an easy one. The easy abstraction should be built on the general one
11:17:34 <Cale> lisppaste2: url
11:17:34 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:17:51 <metaperl> interact does not cut it
11:17:57 <lisppaste2> Cale pasted "locale" at http://paste.lisp.org/display/19970
11:18:41 <Saulzar> metaperl, Well, the point is you can make an _extremely_ simple IO function to do just what you need (and nothing else)
11:18:49 <Saulzar> Then nothing else in your program need refer to IO at all
11:18:52 <Cale> oops, hang on :)
11:19:11 <Saulzar> My first haskell program was a raytracer, it had precisely 1 line of IO in the whole program
11:19:32 <heatsink> wow
11:19:48 <jip> hey, that was my first haskell program!
11:20:09 <lisppaste2> Cale pasted "corrected" at http://paste.lisp.org/display/19971
11:20:46 <newsham> saulzar: nice when you can get away with it.  try a web server, though. :(
11:20:46 <xerox> Oh, Cale beats me.
11:20:48 <Cale> metaperl: see that paste
11:20:52 <xerox> Hmpf. (-:
11:20:58 <Cale> (the one labelled "corrected")
11:21:09 * metaperl eyes are blistering
11:21:11 <metaperl> wow
11:21:12 <Saulzar> newsham, Hehe, yes of course :)
11:21:13 <mwc> so metaperl, if you want a list of strings, how about: interact' f = f . lines, f :: [String] -> String
11:21:14 <metaperl> professional code
11:21:19 <Cale> the idea is to get a datastructure which has all the information in the file in a convenient form
11:21:23 <Cale> I used a Map
11:21:28 * metaperl looks closer
11:21:30 <xerox> I'll complete my version anyway.
11:21:33 <Cale> you could use a list of pairs, but it's slower
11:21:43 <xerox> I could probably avoid okay... pfft :-)
11:22:03 <metaperl> this line is sweet
11:22:04 <metaperl> let (code,c:name) = break (==':') xs
11:22:10 <Cale> then all you have to do is call loadLocaleDict *once* in your main
11:22:14 <metaperl> instead of calling drop later, you did it right in the pattern match
11:22:15 <metaperl> very nice
11:22:21 <Cale> then pass the dictionary to whatever code needs it
11:22:38 <metaperl> Cale: in an oo language, the constructor of the Locale module would do that
11:22:44 <Cale> lookupCode and lookupName will provide that service
11:22:50 <metaperl> that Locale module would handle it's own initialization
11:23:03 <metaperl> main should not know or care about how Locale does its business
11:23:29 <Cale> Any program should care about what IO is taking place.
11:23:35 <Saulzar> loadLocaleDict is more or less doing the same thing as a (named) constructor
11:23:47 <Cale> If something could be different next time the program is run, you should want to know about that.
11:23:58 <Cale> yes
11:24:13 * xerox -> dinner
11:24:17 <Saulzar> instead of foo = new localeDict("filePath"),  you have  foo <- loadLocaleDict "filePath"    -- not much difference
11:24:32 <newsham> cale: so why does s.marlow use unsafePerformIO when reading config files in similar situation?
11:24:49 <metaperl> yes ... my next goal is to support various locales... US, Australia, Canada
11:24:54 <Cale> newsham: no idea :)
11:25:13 <skew> using unsafePerformIO like that is pretending that the config file is a constant
11:25:33 <Cale> unsafePerformIO is a pretty hackish way to do something like that
11:25:49 <newsham> yes.  i'm just pointing out that you dont always "want to know" when "something coudl be different next time the program is run"
11:26:18 <Cale> Well, if you're lazy, then you don't, but if you actually care about whether the program works, you should :)
11:27:08 <newsham> when a file is "near constant" you can pretend as a kind of optimization (optimize how i write my code).  you can still check correctness.
11:27:14 <delinka> someone said earlier "calling the same function with the same input should produce the same result
11:27:17 <delinka> "
11:27:21 <metaperl> why don't you people use Clean instead of Haskell?
11:27:35 <Cale> metaperl: because Haskell is where everything is happening
11:27:44 <metaperl> you mean more research?
11:27:47 <Cale> yeah
11:27:51 <newsham> metaperl: why choose one haskell over another? ;-)
11:27:58 <delinka> and mentioned the mathematical definition of 'function'
11:28:05 <Cale> also, Clean has license issues, iirc.
11:28:27 <newsham> I honestly havent had the time to look into clean, myself.  but it seems there is a larger haskell community (which is already a bit on the small side for my liking).
11:28:51 <Cale> also, I really like monadic IO
11:28:53 <newsham> i've wondered, if clean and haskell are so similar, how feasible is it to support both constructs in a single compiler?
11:29:03 <newsham> ie. uniqueness typing as an option in ghc?
11:29:19 <delinka> this was around discussions about IO; anyway, I'm asking, why doesn't that still hold true in the case if IO - you give it the same input and always get the same output.
11:29:37 <SyntaxNinja> y0
11:30:07 <newsham> delinka: every time you run a "function" which asks for a keypress, you cant expect the user to hit the same key
11:30:12 <newsham> (if you could, the function wouldnt be very useful)
11:30:42 <pejo> newsham, shoehorning another language into ghc isn't exactly the same task as building a compiler that handles both languages from scratch.
11:30:52 <Saulzar> delinka, IO is modelled as RealWorld -> (RealWorld, a), so if you pass a new realworld you can get a different output.
11:30:53 <delinka> right, but the keypress is part of the "input" and if the user presses the same key as before, the same result as before is produced.
11:31:31 <newsham> pejo: i thought the clean is a variant of haskell already (ie. similar or same syntax)
11:31:32 <Cale> delinka: it's about what you want to consider as "input". The keypress is not a Haskell value.
11:31:33 <Saulzar> But, because it is trapped inside a monad - once you make use of your real world you can't get the old one back. 
11:31:46 <Cale> And it's certainly not an explicit function parameter
11:32:09 <delinka> ok, I'll continue exploring. thanks, follks
11:32:26 <Cale> I kind of hate the RealWorld value analogy, since you really can't treat RealWorlds like other values
11:32:42 <newsham> delinka: with a true function, you can compute the result once and reuse it many times.  you can change the order of the computation (compute it before another function or after) and get the same result.
11:32:43 <Saulzar> A _specific_ keypress is a haskell value, but a keypress in general requires IO itself to read the keypress
11:32:56 <Cale> Saulzar: a user pressing a key isn't
11:32:59 <newsham> delinka: you cant do that with a "function" that relies on the state of things outside of the program.
11:33:11 <newsham> ie. changing the order of two write functions gives different output
11:33:23 <Cale> Let's say we modelled IO as functions RealWorld -> (Result, RealWorld)
11:33:32 <Saulzar> Cale, Right, and people laugh at it as if it is some kind of joke language :)
11:33:42 <Cale> so that getChar :: RealWorld -> (Result, RealWorld)
11:33:46 <Cale> er
11:33:49 <Cale> so that getChar :: RealWorld -> (Char, RealWorld)
11:33:53 <delinka> "state ... outside of the program" -- that helps, thanks
11:34:48 <Cale> then what should \rw -> let (c1,rw') = getChar rw; (c2, rw'') = getChar rw in [c1,c2] return?
11:34:58 <newsham> (that "state outside of the program" is what the "RealWorld" parameter they're talking about is supposed to represent)
11:35:15 <skew> delinka: becuase IO is set so it never does get the same inputs
11:35:24 <Cale> theoretically, it ought to return a string with two equal characters
11:35:40 <Cale> because the same real world was passed in
11:36:03 <pejo> newsham, I can't answer what it would take, I was only pointing out that two similar languages doesn't necesarily mean that you easily can get an existing compiler to handle them both.
11:36:24 <skew> delinka: any monad, you don't really have "the same thing" happening twice, maybe you have the same value sequenced together with >>
11:36:30 <Saulzar> Right. But it's impossible to actually use the RealWorld outside of a concept..
11:37:10 <Cale> right, this is going to be really unimplementable :)
11:37:13 <skew> but actions have to be sequenced into main to do anything, and you cas see that the actions are being sequenced in at different places
11:37:29 <skew> like, let x = getChar >>= putChar in x >> x
11:38:09 <Cale> really, a function  String -> IO ()  is still a pure function -- it returns the same IO action every time it's given the same string.
11:38:15 * delinka ponders the meaning of life^H^H^H^H all that hath been spoken
11:38:22 <skew> specifying the order breaks the symmetry and lets the different x do different things
11:38:27 <newsham> pejo: I'm aware (have some compiler background).  It just seems (from what i read) that the two "languages" are really just two dialects of the same.
11:38:55 <Cale> newsham: they're different enough that it would be awkward
11:39:00 <Saulzar> delinka, It's a bit much to try and figure out "everything" without a little practice at the basics :)
11:39:01 <skew> or rather, when you stick two actions together in IO it's not really "the same thing twice", but running an IO action made by sticking the two parts together
11:39:26 <delinka> getting to it, phear not
11:40:29 <skew> or think of example l r = (l 1, r 2)
11:40:38 <skew> then example (1+) (1+) -> (2,3)
11:40:38 <Saulzar> Cale, Yeah - that is a nicer way to put it. You're returning stuff which does IO, rather than actually _doing_ IO.
11:41:07 <skew> just like liftM2 getChar getChar can return ('l','s')
11:41:37 <Saulzar> All you're doing is connecting the pipes and returning something which can be run externally
11:42:20 <newsham> isnt that how io used to be done in haskell?  return a list of input and output directives from main?
11:42:32 <Cale> yeah
11:42:38 <Cale> well, sort of
11:43:03 <Cale> it was done with a CPS-like setup
11:43:58 <ihope> Does print output a newline after printing?
11:44:08 <ihope> I.e. is it putStr . show or putStrLn . show?
11:44:31 <Cale> the latter
11:44:48 <ihope> So if I don't want a newline, I'll use putStr . show?
11:44:56 <Cale> yeah
11:45:02 <ihope> Okay, thanks.
11:45:13 <Cale> It would be kind of nicer to switch to having print and printLn
11:45:44 <Cale> but probably more trouble than its worth in compatibility-breaking
11:45:57 <newsham> printNoLn ;-)
11:47:13 <Saulzar> noPrint
11:47:28 <ihope> (putStr . show)
11:47:32 <ihope> :-)
11:47:33 <Cale> NoLnRyan :: Baseball -> Strike
11:47:37 <newsham> showPutStr
11:47:45 <ihope> putShow
11:48:14 <delinka> lambdabot question: how do I specify IRC info to put it "online"
11:48:55 <Cale> Config.hs
11:49:08 <Cale> and I think you now need a commandline parameter
11:49:10 <Cale> --online
11:49:42 <delinka> "...androids dream..." No, but they count them *really* fast
11:50:11 <delinka> yes, --online, just didn't know how to say "not THAT server, st00pid"
11:50:16 <Cale> http://www.electricsheep.org/
11:59:09 <metaperl> Cale: ping?
11:59:16 <Cale> hi
11:59:57 <metaperl> hi
12:00:13 <metaperl> do you know what ad hoc polymorphism is?
12:00:19 <metaperl> I do, I'm makign sure you do
12:00:20 <Cale> yep
12:00:21 <metaperl> ok
12:00:28 <metaperl> so, as you know...
12:00:44 <metaperl> that means that I can type $object->area() for any object, be it triangle, square, or circle
12:00:49 <metaperl> and get the area
12:00:57 <metaperl> now...
12:01:06 <Cale> no, that's subtype polymorphism
12:01:22 <newsham> @eww($_, `!!`);
12:01:22 <lambdabot> Unknown command, try @list
12:02:11 <Cale> ad-hoc polymorphism is when you have a function or value with multiple definitions at various types
12:02:46 <Cale> with no interface present
12:03:05 <Cale> (just any types, and what will be used is determined by context)
12:04:12 <metaperl> it's really hard to distinguish the two: http://www.answers.com/topic/polymorphism-computer-science
12:04:16 <metaperl> but anyway
12:04:19 <metaperl> my point is this
12:04:38 <Cale> The usual sort of polymorphism in OO comes from the fact that multiple types of objects inherit from some superclass.
12:04:53 <metaperl> yes
12:04:55 <metaperl> so anyway
12:05:15 <SyntaxNinja> CosmicRay: alive? any objection if I uplaod drift?
12:05:44 <metaperl> the problem with haskell is that I cannot get pure data back from my modules but must instead be concerned with whether they can return pure data or containerised data
12:06:47 <Cale> that is, whether they return data, or computations for producing that data
12:06:56 <newsham> sounds like its your problem, not "the problem" :)
12:07:16 <Cale> an IO action is nothing like a pure value
12:07:16 <metaperl> lol
12:07:42 <metaperl> no, but I need to abstract things as if it were... I just want pure data from my objects/modules, 
12:07:43 <Cale> (well, treated as one, it's an inert action, sure)
12:08:31 <SyntaxNinja> metaperl: what's the difference between "pure data" and computations for producing the data?
12:08:37 <Cale> an  IO Char  is a description of how to get a Char by doing some IO at runtime.
12:08:55 <metaperl> SyntaxNinja: if a certain set of computations does not require I/O a whole hell of a lot in Haskell
12:09:01 <SyntaxNinja> oh, I thought you were talking about thunks.
12:09:02 <Cale> It's not a Char, and shouldn't be treated like one.
12:09:26 <Cale> If a set of computations doesn't require doing IO, then it doesn't require doing IO
12:09:34 <newsham> metaperl: are you saying you have some functions which return Char, and some which are IO actiosn which return Char, and you want a uniform interface over all of them?
12:09:42 <metaperl> newsham: bingo
12:09:47 <Cale> I wouldn't
12:09:47 * xerox <- back
12:09:53 <metaperl> welcome back xerox
12:10:01 <Cale> IO Chars don't commute in time, Chars do
12:10:23 <CosmicRay> SyntaxNinja: nope, go right ahead
12:10:26 <newsham> metaperl: if thats really what you want, you can make IO Char's out of your Chars
12:10:36 <SyntaxNinja> hi xerox!
12:10:40 <delinka> k, so I hafta recompile lambdabot after changing Config.hs -- is there a reason configuration is not externalized?
12:10:43 <xerox> Howdy Ninja!
12:10:43 <Cale> (but that's unadvisable)
12:10:45 <metaperl> my main application code doesnot want that concern newsham
12:11:04 <Cale> metaperl: you saw my LocaleDict code, right?
12:11:10 <metaperl> Cale: yes
12:11:12 <SyntaxNinja> or (Monad m) => m Char
12:11:14 <metaperl> I ran it and it worked
12:11:26 <metaperl> but could not cope with having to use do-notation
12:11:26 <Cale> The idea there is that your program would do just enough IO to get a LocaleDict, and then it would be back in pure land.
12:11:59 <SyntaxNinja> metaperl: are you saying that you want to build an abstraction with char, but sometimes it's char and sometimes its IO char/
12:11:59 <Cale> You'd pass that LocaleDict off to some pure function which did whatever the heck needed doing
12:12:18 <xerox> delinka: in some sense it is.
12:12:45 <Cale> then you'd take the result of that pure computation, and show it to the user with a little more IO
12:12:50 <xerox> delinka: but anyway you should have to reconnect in order to change nick/user/whatelse
12:13:04 <Cale> but the part in the middle doesn't do IO, so it's not in the IO monad.
12:13:22 <delinka> sure, but 'restart' is different from 'recompile and restart'
12:13:52 <metaperl> SyntaxNinja: yes, that was the idea
12:14:29 <SyntaxNinja> metaperl: but for some reason, you dont' want to use IO char, which is actually the more general type?
12:14:33 <xerox> delinka: well, one could `read' the "config = { .. }" in theory, yes... poke dons :-)
12:15:04 <Cale> xerox: or just use hs-plugins :)
12:15:09 <xerox> SyntaxNinja: doing such a thing requires you to globally transform the program (and with program I mean the pure computations) -- it is quite not the right thing to do.
12:15:12 <delinka> xerox: not a huge deal, if nothing else, it'll give me a reason to learn more, and I'll change it myself
12:15:16 <xerox> Cale: that is what \bot does, no?
12:15:26 <Cale> xerox: not for its config
12:15:32 <xerox> Cale: oh.
12:15:33 <metaperl> who wrote lambdabot?
12:15:37 <xerox> delinka: go for it :-)
12:15:38 <delinka> xerox: I just wanted to know if there was a good reason for it.  thanks!
12:15:40 <Cale> a bunch of people
12:15:51 <Cale> mostly it's dons these days
12:16:29 <SyntaxNinja> hm. not really sure I understand metaperl's situation
12:16:40 <Cale> metaperl: do you get what I'm saying?
12:16:41 <SyntaxNinja> it's definiteyl good to restrict the locality of monadic functions
12:16:53 <metaperl> yes you are making good sense.
12:17:04 <metaperl> IO Char and Char are different because one can mutate temporally
12:17:07 <Cale> If your program was a planet, the stuff in the IO monad would be the crust, and the pure computation would be the mantle and core.
12:17:18 <metaperl> lol
12:17:24 <xerox> hehe.
12:17:30 <metaperl> uhhhhh OK Cale
12:17:44 <metaperl> do not quit Comp. Sci to become a poet please
12:17:50 <Cale> hehe
12:18:13 * xerox foresees Monadic Universe, Monadic Earth, and the Dual Monadic View.
12:18:19 <xerox> (by Cale gibbard, of course)
12:18:20 <Cale> You do enough IO computation to get the input you need, and the print the output to the screen, which is usually relatively small.
12:18:28 <newsham> MU!
12:18:37 <metaperl> Just like a pizza, it's the extra sauce and cheese that counts. The crust is just there to hold it all together
12:18:39 <xerox> 無！
12:19:33 <Cale> μ
12:19:35 <newsham> you say extra cheese / olives and pepperoni / dont forget the crust!
12:20:35 <Cale> okay, so do you get the idea? IO doesn't permeate most Haskell programs.
12:21:10 <Cale> If there's anything serious at all to be done, it can be done using pure functions, and only hooked up to the IO interface later.
12:21:35 <xerox> BUT we can do Serious IO too.  See ByteString.Lazy :-)
12:22:06 <Cale> yeah, I think dons was talking about working with 4GB files last night.
12:22:17 <xerox> Yes, see the post on libraries@ !  10Gb!
12:22:22 <Cale> ah, 10 :)
12:22:23 <newsham> @hoogle ByteString.Lazy
12:22:23 <lambdabot> No matches found
12:22:52 <Cale> this definitely needs to be in the next GHC :)
12:23:00 <xerox> http://www.haskell.org//pipermail/libraries/2006-May/005361.html
12:24:09 <newsham> how do you get laziness?  wouldnt that potentially interleave io?
12:24:38 <xerox> By the magic wand of dcoutts and dons (-;
12:25:00 <Cale> newsham: yes, it does
12:25:32 <newsham> so if you use ByteString.Lazy you take it on yourself to worry about interleave?
12:26:00 <Cale> well, you basically have to guarantee that the file you're reading from doesn't change as you're reading it
12:26:00 <Philippa> ByteString.Lazy'll do the worrying, I imagine
12:26:09 <Cale> which means, as you're processing it
12:26:15 <newsham> got it.  thanks.
12:26:15 <xerox> A ByteString is a newtyped Foreign Pointer, and many (all?) the functions on it rely on the C duals.
12:26:17 <Cale> that's about it
12:26:18 <metaperl> wow, that is a nice module
12:26:24 <Philippa> Cale: that, or that you don't care if it does I assume?
12:26:32 <Cale> I suppose
12:26:39 <Cale> you probably do care if it does though
12:26:47 <xerox> Exceptions?
12:26:54 <Philippa> depends: append-only writes I probably don't care about at all
12:27:35 <xerox> Isn't that the work of an Handle?
12:27:51 <Cale> You wouldn't be reading if you were just appending.
12:28:00 <Philippa> it might not be me who's appending
12:28:10 <Cale> oh, in that sense
12:28:12 <Philippa> (suppose I'm doing something map-like to a log file?)
12:28:12 <newsham> i think he means someone else is appending logs while reading lazily
12:28:17 <Cale> yeah, okay
12:28:23 <Philippa> I think newsham means she
12:28:34 <newsham> gender on irc?
12:28:42 <Philippa> yeah, funny that
12:29:01 <xerox> Yay, did you see the Linspire mail on -cafe?
12:29:02 <newsham> all references to he shall also apply to she, and him to her, yada yada.
12:29:12 <Cale> though you might worry a bit about hitting the end of the file in the middle of a line.
12:29:21 <newsham> xerox: http://www.haskell.org//pipermail/haskell-cafe/2006-May/015642.html
12:29:35 <Philippa> newsham: standard wimp-out line. If you really meant for gender neutrality you'd be using singular they instead
12:29:49 <Cale> or Spivak pronouns :)
12:30:00 <xerox> hehe.
12:30:16 <Philippa> Cale: or any of a large number of other pronoun groups, yeah :-)
12:30:47 <newsham> philippa: I dont use "they" like that.
12:30:55 <ADEpt> @seen dons
12:30:56 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 6 hours, 31 minutes and 36 seconds ago.
12:31:02 <jip> @seen Igloo 
12:31:03 <lambdabot> Igloo is in #haskell-overflow and #haskell. I last heard Igloo speak 1 day, 3 hours, 11 minutes and 20 seconds ago.
12:31:09 <newsham> reguardless,  i'm not one to worry about someone being offended by "he".
12:31:22 <Cale> Spivak pronouns sort of sound like a cockney accent to me.
12:31:42 <jip> what do you guys think about ocaml?
12:31:53 <newsham> jip: "people"!!!  ;-)
12:32:01 <Philippa> newsham: congratulations, aren't you lucky to be a guy and get to default to that position?
12:32:18 <jip> newsham: eh?
12:32:58 <Cale> jip: It's decent, though the syntax is ugly compared to Haskell, and it really needs typeclasses. :)
12:32:59 <newsham> philippa: sexism is a waste of my time.  "he" is the generic third person singular.  The fact that some people don't like it doesnt change that fact.
12:33:00 <Saulzar> jip, I believe he means "converts" !!! :)
12:33:28 <Philippa> newsham: enough people rejecting it would do, however
12:33:45 <jip> Cale: what other good languages are there, preferabbly not lazy?
12:34:04 <newsham> philippa: I honestly mean no slight to you buy it; but I also dont agree with your objection.
12:34:09 <jip> newsham: hm.... is "guys" racist or something?
12:34:23 <Cale> what qualifies as "good"?
12:34:29 <Cale> :)
12:34:29 <isaacd> newsham: "she" and "they" are also de-facto generic third person singlular pronouns
12:34:31 <jip> Cale: something you would consider using :D
12:34:33 <xerox> Cale evades!
12:34:43 <xerox> Launch 2d6...
12:34:45 <isaacd> sometimes
12:34:51 <newsham> isaacd: none of my textboox list "she" or "they" as generic third person.
12:34:52 <xerox> @dice 2d6
12:34:53 <lambdabot> 2d6 => 10
12:34:56 <Philippa> jip: "guys" is generally gender-neutral these days, "guy" generally isn't
12:34:57 <xerox> Evasion accomplished.
12:35:03 <isaacd> newsham: hence "de-facto"
12:35:16 <newsham> isaacd: not to mention the majority of legal contracts I read and sign have language saying "he shall also refer to she..." yada yada
12:35:21 <Philippa> newsham: your textbooks will've been written based on a prescriptivist approach to english that attempted to bolt on grammar from other languages and ruled out singular they on that basis
12:35:39 <Cale> Where did you learn English? The 19th century?
12:35:44 <jip> Philippa: yeah, well, i said "guys" :)
12:35:54 <isaacd> "she" is usually used in arbitrary alternation with "he" though
12:35:55 <jip> anyway, irc is gender-less
12:36:04 <newsham> jip: thats what I say!
12:36:09 <Philippa> IRC isn't genderless, as evidenced by the fact gender has just come into it
12:36:33 <newsham> philippa: enjoy your rare moment of sexual equality.
12:36:40 <newsham> it only goes down hill from here
12:37:13 <Philippa> and it doesn't occur to you that if the only way to get a moment of equality is to make a space genderless that it's not equality at all?
12:37:14 <Korollary> if it was genderless, it would be just "a/l?".
12:37:20 <Philippa> Korollary: quite
12:37:44 <newsham> korollary: hpoefully #haskell is also ageless.
12:38:09 <newsham> l = HI, btw.
12:38:11 <thedward> so there is only discrimination based on location?
12:38:30 <newsham> thedward: yah.  especially against those crazy irish!
12:38:47 <thedward> well, just don't hold it against me that I'm from Texas. :)
12:38:49 <Cale> I usually just use singular they
12:39:27 <newsham> so how about that haskell language, eh?
12:39:52 <thedward> Haskell doesn't have gender, it is much more sensible than english
12:40:05 * Saulzar starts refering to everyone as northener :)
12:40:18 <thedward> Saulzar: the term is "yankee" :)
12:40:21 <newsham> marklar
12:40:38 <Saulzar> thedward, I mean it in a much more general sense!
12:40:45 <Philippa> thedward: data Gender = ... -- it does now
12:40:46 <Philippa> :-)
12:41:04 <thedward> foiled again
12:41:31 <newsham> I object to this blatant discrimination against trans-gendered people.
12:42:11 <thedward> is Object a Monad?
12:42:14 <Korollary> Having gender in a language is not necessarily a bad idea since people care who is what. Otherwise names would be all unisex.
12:42:24 <isaacd> newsham: I agree, gender categorization is bad
12:42:59 <isaacd> Korollary: Names are gender-related for historical reasons
12:43:03 <Philippa> newsham: many of them would object to the form of your objection
12:43:07 <jip> so what other good languages are there?
12:43:18 <thedward> I like lojban
12:43:24 <newsham> philippa: and that fact warms my heart.
12:43:26 <Philippa> newsham: notice I left the details of the type blank :-)
12:43:42 <Philippa> transgender != no gender
12:43:55 <mahogny> illegal type cast!
12:44:07 <mahogny> at least in some countries I guess :P
12:44:10 <cyyoung> discussions of gender are hindered by indo-european-centrism
12:44:17 <newsham> its silly that there is a livelier debate over the use of "he" than over haskell.
12:44:34 <cyyoung> b/c in many languages 'gender' extends not only to male, female, etc. but also to kinds of things
12:44:40 <mahogny> newsham, count the number of "she" vs the number of "haskell users". might be a relation :)
12:44:41 <newsham> save the gender for netsex.
12:44:59 <cyyoung> cf swahili's gender system, chinese + japanese's classifiers, etc.
12:45:01 <newsham> mahogny: only goes to show that women will bitch about anything ;-)
12:45:04 <newsham> *hides*
12:45:09 <Philippa> cyyoung: in english, gender has two meanings, one of which is a technical term about languages matching the concept you're describing and the other of which is somewhat analogous to sex
12:45:09 <mahogny> :D
12:45:31 <Philippa> most "discussions about gender" in english are about the latter concept
12:46:30 <Philippa> newsham: there're plenty of other reasons gender might be relevant to an IRC conversation. Less so one about programming, granted
12:48:03 <basti_> actually, in chinese, names don't tell anything about the bearer's gender (or sex, for that matter)
12:48:34 <newsham> irc is one of the few places you can have a conversation without gender being an issue.  if this was a general chat room then perhaps gender would be more impmortant or if i had previously met people in this room..
12:49:21 <Philippa> newsham: when you say "without it being an issue", you're taking advantage of a certain little discrepancy about "he". You might wanna bear that in mind
12:49:50 <isaacd> newsham: I don't feel that gender is an issue when I'm having academic discussions with my peers in real life either
12:50:16 <basti_> since my academic discussions tend to be among men... ^^
12:51:48 <Philippa> basti_: yeah, there's a distinct tendency once you get past undergrad still. Oh well
12:52:25 <basti_> i suppose that's symptomatic for technical professions, sadly. I wouldnt mind more CS girls at all.
12:52:33 * basti_ ducks and runs
12:52:41 <Philippa> heh. Me either though :-)
12:54:23 <Saulzar> Secretly swap the course codes for CS with Psychology will help.
12:55:03 <ADEpt> @seen audreyt
12:55:04 <lambdabot> audreyt is in #haskell. I last heard audreyt speak 17 hours, 37 minutes and 2 seconds ago.
12:57:39 <Cale> People also don't tend to use gender-neutral pronouns when talking about someone specific whose gender is obvious.
12:57:48 <hyrax42> what would be a good small-medium application to read through the code of?
12:58:08 <hyrax42> I'm getting bored of just "learning" and want to start programming something
12:58:13 <Philippa> Cale: quite. My original correction wasn't about language, it was about my gender
12:58:33 <hyrax42> but would like to see how programs are organised etc. first
12:58:48 <Philippa> hyrax42: modules, usually based around one or more types and a set of basic operations
12:59:07 <newsham> http://haskell.org/hawiki/CodeExamples
12:59:09 <Philippa> most programs have an "IO on the outside passing stuff into/getting results from pure code on the inside"
12:59:31 <Cale> http://www.haskell.org/hawiki/TheGallery has some small programs
12:59:37 <xerox> ...design
13:00:09 <Cale> http://www.haskell.org/hawiki/ShortExamples actually has a few more, but even smaller :)
13:00:25 <isaacd> Cale: I've noticed that I tend to still use singular they when I'm not thinking so much about them as a person, so I like it better when I end up using he or she (as appropriate) instead
13:00:52 <Cale> sure
13:01:01 <hyrax42> thanks guys
13:01:02 <hyrax42> ...
13:01:03 <hyrax42> :p
13:01:35 <newsham> here's a slightly larger but not huge program: http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/haskell-ls/
13:01:35 <Cale> hyrax42: I'm not sure about good example medium-size applications
13:01:43 <cyyoung> so here's what I came to ask: physics simulation code in haskell -- is there any to read through?
13:01:44 <newsham> pretty io centric though
13:02:16 <Philippa> cyyoung: I'm not aware of any off-hand, what kind of thing do you have in mind?
13:02:20 <Cale> cyyoung: I recall a number of people working on physical simulations in Haskell, but I'm not sure where the code is
13:02:34 <xerox> L-Systems? (-:
13:03:08 <newsham> http://www.haskell.org/haskellwiki/Libraries_and_tools would be a good place to go fishing
13:04:25 <cyyoung> I saw lots of mentions of haskell for simulation while working through the tutorials, but haven't found any simulations like I'm thinking of
13:04:43 <xerox> http://haskell.galois.com/~paolo/nymphaea/
13:04:44 <Philippa> yes, that's not really the sort that the tutorials had in mind as such though it's doable
13:04:57 <cyyoung> ah
13:05:04 <xerox> (That does render a kind of Iterated Fractal Systems.)
13:05:05 <jip> a while ago i started doing a port of ODE from C to haskell, just for fun
13:05:12 <Philippa> heh, how'd that go?
13:05:18 <xerox> jip: Lemmih has bindings to that
13:05:18 <Philippa> (and how's the emulator going?)
13:05:41 <xerox> Oh right, the emulator!
13:05:52 <jip> xerox: yeah, but i wanted to see how things would work if implemented in pure haskell
13:06:06 <jip> the emulator... i worked on it some today, tried to optimize the sucker
13:06:27 <jip> i've pushed it as far as i can pretty much, and it's still not fast enough :(
13:06:38 <jip> i'm thinking of putting the project on hold for a while :\
13:06:47 <xerox> Oof )-:
13:06:57 <sjanssen> jip: get it on the computer languages shootout, then the mailing list will do your optimization ;-)
13:07:03 <jip> sjanssen: heh
13:07:10 <xerox> ....darcsify it and wait for patches (-:
13:07:25 <jip> i am thinking of quickly coding up an implementation in C, just to see what kind of performance i should be aiming for
13:07:41 <jip> xerox: problem is the code right now is a truly horrible mess
13:07:58 <jip> xerox: i've converted everything to be in the IO monad and use IORefs and IOArrays, for speed
13:08:06 <Philippa> is it so bad you can't see how to refactor it to make it sane?
13:08:20 <Philippa> hrmm, are you using unsafe array reads/writes to skip the bounds-checking?
13:08:41 <jip> Philippa: yep, where i can at least. it doesn't seem possible to do unsafe reads for UArrays though
13:09:36 <mgoetze> so, say i have this otherwise-constant program with a line l, which i'll be compiling with ghc 6.4.1
13:09:44 <jip> i've been profiling and profiling and i only manage to get small performance increases with my changes. the profiling results don't show any specific time hogs. it's just that the app needs overall optimizations everywhere i guess
13:09:50 <mgoetze> for l="import Data.Tree", the program compiles fine
13:10:18 <mgoetze> for l="import Data.Tree(Tree)", i get a bunch of error messages about data constructor 'Node' not being in scope
13:10:45 <mgoetze> but for l="import Data.Tree(Tree, Node)" i am told that module 'Data.Tree' does not export 'Node'
13:10:47 <xerox> mgoetze: use Tree(..)
13:10:49 <mgoetze> how can this be?
13:11:08 <xerox> ...or Tree(Node), or Tree(Node,Branch), or whatever.
13:11:33 <mgoetze> xerox: hm, ok, that works... bit weird if you ask me though
13:12:24 <xerox> mgoetze: TypeConstructor(DataConstructors)
13:17:10 <davidhouse> this proposed GHC hackathon is a physical meetup, right? (i.e., not on the internet
13:17:11 <mgoetze> weird, i have just "import Data.Maybe(fromJust, catMaybes)", but Just works anyway....
13:17:29 <Saulzar> mgoetze, It's in Prelude
13:17:39 <mgoetze> ah, ok
13:18:33 <Lemmih> davidhouse: Yeah.
13:18:58 <davidhouse> sham.
13:19:01 <davidhouse> *shame
13:26:45 <xerox> davidhouse: were are you located?
13:26:45 <mahogny> hm. not long ago, maybe a month, someone had an url to a nice phd thesis (I think) about using UML for FP. anyone have it, just happen to be the one posting it? :)
13:27:04 <mahogny> +or
13:27:46 * mahogny figures a good SoC project would be a tool to search IRC logs. a very useful tool :P
13:27:50 <ADEpt> HCAR submissions are overdue, right?
13:28:05 <davidhouse> mahogny: like google? (or grep if they're local)
13:28:36 <mahogny> davidhouse, I barely remember the title of it, and I tried grep but the logs are a bit too huge for a simple grep
13:28:42 <davidhouse> xerox, right in the middle of england, but it's just a bit of a pain to be treking across the country.
13:29:26 <Lemmih> ADEpt: No, not yet.
13:30:00 <ADEpt> Lemmih: it was 12th of May, no?
13:32:05 <xerox> 15th
13:34:44 <Lemmih> The deadline was extended to the 15th of May.
13:37:16 <Philippa> I should probably own up to Flippi being dead. I mean, I told my housemate to use MoinMoin instead
13:39:19 <stepcut> xb
13:39:38 <stepcut> oops, missed the C- part of that :p
13:39:42 <ADEpt> Lemmih: great
13:39:47 * ADEpt wrote HCAR entry
13:40:01 <xerox> ADEpt: about what?
13:40:13 <ADEpt> xerox: my "tutorial"
13:40:21 <xerox> Oh what is it?
13:40:57 <ADEpt> xerox: www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell
13:41:09 <xerox> Ah, that!  Nice one.
13:41:52 * ADEpt should write more chapters someday
13:49:23 <davidhouse> what are haddock's dependencies?
13:49:48 <davidhouse> ooh, never mind
13:49:51 * davidhouse just found a binary
13:56:17 <psnl> ADEpt: you know that bin-packing is NP-complete?
13:56:56 <ADEpt> psnl: yep
13:57:06 <psnl> good good
13:57:18 <ADEpt> psnl: it doesn't stop me from writing tutorial :)
13:57:37 <ADEpt> psnl: i'm not afraid of difficult tasks :))
13:57:37 <psnl> ""Modern" means that it is written in Haskell" <- This bit I like
13:58:21 <psnl> how well does your code scale?
13:59:28 <ADEpt> psnl: O(n*c)
13:59:45 <ADEpt> psnl: where n is number of items and c is knapsack size
14:00:00 <ADEpt> psnl: if i remember everything properly
14:00:22 <lisppaste2> davidhouse pasted "haddock error" at http://paste.lisp.org/display/19974
14:00:30 <ADEpt> psnl: but then, one can perform scaling of item sizes before packing and upscale result afterwards
14:00:31 <davidhouse> anyone help me out with that?
14:00:38 * ADEpt is out to sleep
14:00:48 <psnl> night
14:00:58 <davidhouse> i'm getting a "parse error in doc string: []" error, and i can't figure out why.
14:01:30 <Lemmih> davidhouse: \@, I think.
14:01:56 <davidhouse> Lemmih: thanks.
14:01:59 <davidhouse> grr, another error.
14:02:21 <davidhouse> oh, perhaps not. it's a warning, let's ignore it :)
14:02:28 <araujo> Hi
14:04:33 <davidhouse> huh. where does haddock's output go?
14:07:25 <davidhouse> never mind, got it.
14:13:07 <arjanoosting> @seen SyntaxNinja
14:13:08 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. I last heard SyntaxNinja speak 1 hour, 56 minutes and 26 seconds ago.
14:14:56 <skew> cyyoung: I think the nofib suite includes a barnes-hut N-body program
14:15:19 <delinka> does haskell do threads?
14:15:26 <palomer> <:o
14:15:46 <skew> Philippa: hi, do you have any recent news about first class modules?
14:16:02 <xerox> delinka: yes, and pretty fast too.
14:16:19 <xerox> delinka: GHC RTS' one are very lightweight
14:16:21 <alar> @seen shapr
14:16:21 <lambdabot> shapr is in #ScannedInAvian, #haskell and #haskell-overflow. I last heard shapr speak 1 day, 6 hours, 16 minutes and 26 seconds ago.
14:16:44 <skew> I'm trying to rewrite Guy Steele's "Building Interpreters by Composing Monads" in slightly more modern Haskell.
14:22:06 <palomer> Guy Steele has become a haskell hacker?
14:23:28 <Maddas> (The paper is from '94)
14:24:14 <Philippa> skew: I don't, no. I don't expect to see them as a haskell feature for a loooong time
14:25:35 <davidhouse> anyone happen to know which version of haddock --ignore-all-exports was implemented in?
14:26:07 <davidhouse> huh. the docs say they're describing 0.6, and my haddock is 0.6, but that option doesn't seem to exist
14:26:25 <skew> Too bad. Daan's MLF stuff looks pretty promising.
14:31:53 <Philippa> skew: a System F variant with records does seem to be the way to go, yeah. I was playing about with modules in a System F-like context for another reason and realised that pretty much straight away: modules become little more than records with both term and type components
14:35:35 <mahogny> xerox__, there?
14:35:43 <araujo> Hi!
14:35:50 <mahogny> yo
14:35:57 <newsham> hi
14:36:05 <araujo> :-)
14:38:13 <jip> @seen Igloo 
14:38:14 <lambdabot> Igloo is in #haskell-overflow and #haskell. I last heard Igloo speak 1 day, 5 hours, 18 minutes and 30 seconds ago.
14:41:36 <delinka> having DNS issues with my lambdabot - what should I be looking at? error: search module failed: getHostByName: does not exist (no such host entry)
14:42:05 <newsham> the hostname its trying to resolve is bad.
14:42:09 <newsham> or your dns is messed up
14:43:02 <delinka> on the server host and dig work great. what does lambdabot look at?
14:43:38 <newsham> not familiar with lambdabot, but i imagine it uses the same resolution mechanism
14:46:19 <delinka> can someone give me some sample code to punch into ghci to generate a DNS lookup and result?
14:46:20 <user317> is there a way to transform a function [a] -> [b] to [IO a] -> [IO b]
14:47:08 <jip> no
14:47:18 <jip> i mean yes
14:47:22 <mahogny> user317, define transform
14:47:53 <newsham> he wants to lift
14:48:22 <user317> yea, i want a lift of somekind
14:48:35 <newsham> you dont mean  [a]->[b]   =>   [a] -> IO [b] ?
14:48:38 <jip> oops, i am sticking with my original answer: no
14:48:39 <user317> i just started playing around with haskell, so i dont really know what i am doing
14:49:12 <user317> i have something that generates a list from some data it gets from a bunch of files, and the result looks like IO [IO Blah]
14:49:29 <newsham> mapM_ ?
14:50:02 <Philippa> user317: Not as such. You could use sequence on the input list and get IO [b] out though
14:50:11 <user317> well, i could make it into IO [Blah] with mapM, but then it reads everything in at once
14:50:28 <Philippa> sort-of. readFile's lazy anyway though
14:52:34 <user317> is there a way to get the last thing you read from readFile?
14:53:16 <user317> or peek at the next?
14:53:40 <newsham> if you're looking at a real file, you should be able to seek to any point in the file you want
14:55:15 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhSeek
14:55:58 <user317> thanks
15:05:10 <palomer> there should be a debugger that lets you state invariants about functions which are checked at runtime
15:05:49 <jip> you mean asserts?
15:06:13 <newsham> :)
15:06:44 <newsham> something that let you assert invariants would be very useful
15:08:00 <palomer> like, say you write a factorial function. you want to check that only positive numbers are passed to it, you'd say "input(factorial) > 0"
15:08:23 <newsham> or   assert (arg > 0)
15:09:17 <palomer> does this already exist?
15:09:40 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Aassert
15:10:31 <palomer> right
15:10:37 <palomer> but that's not nearly as handy
15:10:54 <newsham> as handy as?
15:11:12 <palomer> say your function is fac 0 = 1 ; fac n = n * (fac (n-1))
15:11:25 <palomer> how would you assert that the input is always positive?
15:11:30 <palomer> and that the output is always positive?
15:11:35 <palomer> you'd need to completely rewrite it
15:12:04 <cyyoung> there are python decorators for that sort of thing, fyi
15:12:10 <newsham> fac n = assert (n >= 0) n * (fac (n-1))  ?
15:12:31 <palomer> and how would you assert that the output is always positive?
15:12:36 <cyyoung> not that specifically, but they take a func and a pre or post condition thing and run them
15:12:36 <Maddas> cyyoung: in CL one could just declare the function type 9:
15:12:39 <Maddas> (:, even
15:12:57 <cyyoung> ie, call precondition on the func
15:13:17 <palomer> but I'd also like to state things like
15:13:28 <palomer> if the input is positive, then the output is greater than 0
15:14:17 <Philippa> yeah, so you want a second func that evaluates first and then does the assert checks with knowledge of the result
15:14:29 <newsham> like p-logic?
15:14:34 <palomer> p-logic?
15:15:00 <newsham> http://citeseer.ist.psu.edu/kieburtz02plogic.html
15:16:39 <palomer> p-logic looks like quickcheck
15:16:43 <jgraves> OK, it's going to take me a while to digest that paper.
15:17:01 <palomer> actually
15:17:18 <palomer> isn't this static analysis?
15:17:42 <palomer> it is
15:17:46 <palomer> I'm looking for runtime checking
15:18:13 <newsham> you can use asserts to do what you want, no?
15:18:25 <palomer> newsham: but they're checked at compile time
15:18:32 <newsham> asserts are checked at runtime
15:18:43 <newsham> (they have to be)
15:18:53 <palomer> oh, then probably
15:19:03 <palomer> I'm guessing this hasn't gone anywhere, has it?
15:20:23 <newsham> gone anywhere?
15:20:35 <palomer> ie, was implemented and made usable
15:20:55 <newsham> plogic?  or asserts?  both are implemented and in use.
15:21:13 <palomer> why haven't I heard about this?
15:21:22 <palomer> isn't this, like, the greatest thing in the world?
15:21:22 <newsham> http://www.cse.ogi.edu/~hallgren/ICFP2005/  is a paper that uses plogic in their project
15:21:59 <palomer> my apt-cache knows nothing of plogic!
15:22:21 <newsham> there are limits to what can be statically verified.  thanks a lot goedel/turing/etc..
15:23:03 <jgraves> Yeah, those bastards.  Where would CS be without them?  :-)
15:25:11 <jgraves> It sounds like you want something like Design by Contract for Eiffel.
15:29:34 <jgraves> Me, I'm still trying to understand the Zen of Monads.
15:29:48 <jgraves> I've learned a lot of stuff over the years...
15:30:21 <jgraves> but this one seems harder to wrap my head around.
15:30:50 <jgraves> But I don't feel bad because there are a bunch of tutorials out there that talk about this.
15:31:39 <jgraves> I've just downloaded the Wadler paper.  Better to start at the beginning, right?
15:32:16 <Philippa> jgraves: apparently despite being unfinished this is worth looking at (yeah yeah, I wrote it...): http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
15:32:37 <Philippa> it's more useful if you're looking to implement your own monads, but you might find the intuition useful
15:33:28 <jgraves> I kinda, sorta understand them now.  But I want to understand things all the way to the core.
15:33:46 <jgraves> And uber haskell hackers can implement their own monads, so I have to too!  :-)
15:33:52 <Philippa> um. Depending on what core you have in mind that may take some doing
15:34:00 <newsham> "the awkward squad" was the thing that opened my eyes the best
15:34:08 <newsham> but maybe it was just timing, after having read so many others :)
15:34:11 <Philippa> the awkward squad was good, yeah
15:34:56 <jgraves> You mean this one: http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf
15:36:03 <newsham> yes
15:36:24 <jgraves> Thanks for the pointer.  I haven't read this one yet either.
15:37:30 <franka> I have a question about Data.Set.
15:37:48 <franka> Is the Ord instance for Data.Set defined so that (<=) is the standard subset ordering?
15:38:15 <newsham> +http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf
15:38:20 <newsham> mispaste
15:39:17 <newsham> shouldnt Ord imply total ordering?
15:39:33 <franka> No.
15:39:41 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AOrd
15:39:46 <newsham> The Ord class is used for totally ordered datatypes
15:40:08 <franka> Oh wait, you're right.
15:40:34 <newsham> someone once bitched at me for Ord'ing something partially :)
15:41:26 <Philippa> in other news, how should I expect concurrency and ghci to play together?
15:41:50 <franka> Then my question changes to whether (<=) includes the subset order.
15:42:06 <Philippa> which class does <= come from?
15:42:16 <franka> Ord
15:42:31 <ihope> Haskell quine: module Main where main = putStr x >> print x where x = "module Main where main = putStr x >> print x where x = "
15:42:34 <ihope> Java quine: http://pastebin.com/716043
15:42:52 <ihope> Which is better? ;-)
15:43:48 <delinka> define "better"
15:44:13 <ihope> Of course, the Java subroutine thing I was defining may already exist.
15:44:44 <ihope> And it could be made shorter if I put it all on one line.
15:45:30 <ihope> And... stuff. But the Haskell quine looks better to me :-)
15:46:54 <jip> is anyone able to darcs get http://scannedinavian.org/~lemmih/SDLstable
15:46:58 <jip> @seen Lemmih 
15:46:58 <lambdabot> Lemmih is in #haskell-blah, #haskell-overflow and #haskell. I last heard Lemmih speak 1 hour, 6 minutes and 59 seconds ago.
15:47:26 <norpan> i just paid 78 NOK for a pint of guinness
15:47:32 <norpan> that's expensive :)
15:49:12 <jgraves> jip: no, can't resolve host name
15:50:51 <jethr0_> @seen vincenz
15:50:52 <lambdabot> vincenz is in #haskell-blah and #haskell. I last heard vincenz speak 7 hours, 16 minutes and 8 seconds ago.
15:52:12 <Philippa> norpan: ouch. Oh well, I guess if there's no real beer then guinness'll do as a substitute :-)
15:52:14 <jip> argh, i need those sdl bindings!
15:52:21 <Philippa> (both for the beer and your meal)
15:52:28 <norpan> huh
15:53:03 <Philippa> if you're drinking cask-conditioned or possibly bottled guinness I'll retract the "real beer" comment, but otherwise it stands :-)
15:53:07 <jgraves> IIRC, I've had problems accessing scannedinavian.org before.
15:53:26 <Philippa> yeah, it's been down a while
15:53:33 <norpan> it was quite good actually
15:53:36 <norpan> well tapped
15:53:44 <jgraves> Tried google's cache?
15:54:48 <Philippa> once in a while a pub around here'll have another stout available
15:54:57 <Philippa> nope, and I wouldn't want to - usually I'm looking for my own code
15:55:20 <Philippa> so worst case, the stuff on my HD becomes authoritative. Big loss :-)
15:55:41 <jip> who has the latest version of SDLstable?
15:57:02 <franka> Is Cale here?
15:57:38 <jip> all your SDL bindings are belong to us
15:57:44 <jethr0_> jgraves: have you tried scannedinavian.com, one of them was always working for me :). but maybe it's really down this time, who (except shapr) knows
16:03:24 <jip> jethr0_: the .com doesn't have lemmih's shit :(
16:03:53 <jethr0_> hmm
16:05:03 * jip needs those bindings
16:07:08 <jgraves> BTW, I really like "The Awkward Squad" paper by Jones a lot so far.  It's 60 pages, so I haven't finished it yet.
16:09:25 <Lemmih> jip: They moved to darcs.haskell.org/~lemmih
16:09:34 <Lemmih> @where hsSDL
16:09:34 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
16:09:50 <jip> woohoo! danke sehr!
16:10:26 <jip> someone should update this wiki page: http://www.haskell.org/hawiki/HaskellOpenGl
16:11:15 <mahogny> hm. any other mentors here currently?
16:13:39 <Lemmih> mahogny: Yes.
16:13:46 <jgraves> jip: since it is a wiki page, then you should update it.  That is "The Wiki Way" (tm).
16:13:49 <Lemmih> jip: It's a wiki. You do it (:
16:13:59 <mahogny> Lemmih, is it just me, or is it strange that we can vote 4+? :/
16:14:55 <jip> yeah but it's a wiki that required registering i think :(
16:15:38 <mahogny> the wiki way: no one updates, everyone complains (tm)
16:15:52 <psi> any word from google about how many they're accepting etc?
16:15:52 <palomer> this sucks!
16:16:11 <mahogny> psi, not to my knowledge
16:16:12 * palomer wonders where the p-logic site is
16:16:26 <mahogny> psi, but it's a lot of organizations this year
16:16:40 <Lemmih> mahogny: It's bit strage but Google wanted it that way.
16:16:57 <psi> but fewer applications, right?
16:17:11 <mahogny> psi, dunno about that. they are plenty enough >_<
16:17:17 <psi> heh
16:17:27 <mahogny> Lemmih, well, I kind of think no one should vote more than 4. I have seen a few boosted applications and I can't say I'm a fan of it
16:18:22 <palomer> boosted applications?
16:18:45 <palomer> mahogny: weren't you the one who wanted a static theorem prover for haskell?
16:18:53 <mahogny> palomer, ie one guy has even voted "8" on one application, whereas almost everyone else has voted 0 >_<
16:19:01 <mahogny> palomer, yeah. looking into programatica
16:19:12 <palomer> yeah, I was about to mention it
16:20:03 <mahogny> I would prefer to see the syntax going into haskell'. just let compilers without provers ignore it. it saves one dependency when distributing source to proof-unaware users
16:20:23 <mahogny> and it would make common ground for different proving tools
16:20:48 <Philippa> it needs to be something 'finished' to be considered for haskell' - last time I saw anything about programatica it wasn't that
16:21:04 <mahogny> Philippa, I think the syntax is pretty much finished. the prover is not
16:21:04 <Philippa> there's already syntax for comments and pragmas
16:21:19 <mahogny> I'm not a fan of syntax in comments :P
16:21:23 <Philippa> nevertheless, not what haskell' is for
16:21:25 <mahogny> rather, code in comments
16:21:55 <palomer> but it isn't code!
16:21:59 <palomer> it's invariants
16:22:06 <Philippa> the FD/AT debate's nasty enough, why should we privilege one set of out-of-language annotations?
16:22:10 <mahogny> it would indeed be easier to promote it to haskell' if ghc already did it
16:22:12 <palomer> does programmatica work with ghc?
16:22:32 <mahogny> palomer, to my knowledge yes. haven't yet started to use it though
16:22:44 <mahogny> Philippa, I think the set is quite important
16:23:16 <mahogny> Philippa, the same way it makes sense to have QuickCheck in haskell'
16:23:25 <Philippa> QuickCheck's a library though
16:23:31 <mahogny> and?
16:23:35 <jfoutz> what's the haskell way to say (map + '(1 2 3) '(4 5 6))  ?
16:23:54 <mahogny> it's to add a library though, you got a point there at least
16:23:58 <mahogny> +easier
16:24:04 <Philippa> so you're not asking for any privilege beyond being in the standard libs. It probably won't get that either based on the approach to standard libraries that looks likely to hold out
16:24:11 <Philippa> it's both easier and doesn't screw up as much if you get it wrong
16:24:19 <Philippa> the latter's what I mean about privileging one set of annotations
16:24:38 <Maddas> jfoutz: zipWith (+) [1,2,3] [4,5,6]
16:24:44 <mahogny> Philippa, you got a point there. though I think the syntax they have is rather mature already
16:24:50 <jfoutz> Maddas: thanks
16:25:07 <palomer> I wouldn't see the point of using quickcheck if I could use programatica
16:25:08 <Maddas> jfoutz: No problem. Note that zipWith isn't n-ary, though.
16:25:11 <Philippa> I still don't think it's haskell''s job to do that
16:25:38 <jfoutz> yeah, type says it's only 2. 
16:25:42 <Maddas> :)
16:25:43 <mahogny> palomer, programatica either gives a rock solid proof or fails. quickcheck always give a probabilistic proof
16:26:08 <jfoutz> but there's a zipwith3 if i need it :)
16:26:10 <mahogny> so... you want both
16:26:18 <palomer> mahogny: programatica also has runtime checks
16:26:25 <palomer> with assert
16:26:46 <mahogny> palomer, true that. but that's not enough
16:27:04 <mahogny> I mean... you implement a new fast sorter... are you gonna compare it with quicksort each time you use it? :)
16:28:11 <palomer> ok, personally, I would use programmatica over quickcheck 90% of the tmie
16:28:14 <palomer> s/tmie/time
16:28:23 <palomer> s/programatica/programmatica
16:28:39 <Maddas> jfoutz: :-)
16:29:35 <jfoutz> actualy... 
16:29:58 <jfoutz> > zipwith (+) zipwith (+) [1,2,3] [4,5,6] [7,8,9]
16:29:59 <lambdabot>  Not in scope: `zipwith'
16:30:18 <jfoutz> > zipWith (+) zipith (+) [1,2,3] [4,5,6] [7,8,9]
16:30:19 <lambdabot>  Not in scope: `zipith'
16:30:28 <jethr0_> [(1,(4,7)), ...], i think
16:30:31 <jfoutz> bah. but something like that should work.
16:30:38 <jfoutz> stupid fingers.
16:30:52 <jethr0_> > zipWith (+) [1,2,3] $ zipWith (+) [4,5,6] [7,8,9]
16:30:53 <lambdabot> [12,15,18]
16:31:03 <jfoutz> there ya go.
16:31:36 <jethr0_> there's zipWith3 in List i think
16:31:47 <palomer> Haskell' needs a sml-like module system
16:32:04 <palomer> who's with me?
16:32:06 <mahogny> palomer, I would use programatica and then qcheck as a fallback when it fails
16:32:17 <jethr0_> zipWith3 (\x y z -> x+y+z) [1,2,3] [4,5,6] [7,8,9]
16:32:19 <jethr0_> > zipWith3 (\x y z -> x+y+z) [1,2,3] [4,5,6] [7,8,9]
16:32:20 <lambdabot> [12,15,18]
16:32:21 <palomer> qcheck is so much more work to use
16:32:34 <mahogny> palomer, yes, but there is seldom a good alternative
16:32:41 <Philippa> palomer: I wouldn't want to leap into it without some thinking. I'm mostly with you, but I value mutually recursive modules as well
16:32:55 <jfoutz> jethr0_: i was thinking about n-ary versions. so currying zipwith seemed like a nice way to go.
16:33:02 <palomer> you can add mutually recursive modules to an sml-like module system
16:33:48 <palomer> there was a PhD on that, from some guy at CMU
16:34:00 <jethr0_> jfoutz: n-ary isn't that simple IMO. but you could pass a list of lists
16:34:23 <jfoutz> jethr0_: you're right, i cheated because it's just add.
16:34:33 <jethr0_> > map sum . transpose $ [[1,2,3],[4,5,6],[7,8,9]]
16:34:34 <lambdabot> [12,15,18]
16:35:19 <jfoutz> otoh, if i need more than three arguments to a function, i ought to be thinking about a data declaration anyway
16:36:36 <Philippa> palomer: "can do" != "it's easy to"
16:36:43 <Philippa> especially not if you want a terminating compiler
16:37:01 <Philippa> IOW, it's something to be looked at carefully, and there aren't any existing implementations - so it's not one for haskell'
16:37:37 <palomer> sml modules > recursive modules
16:40:19 <jfoutz> @pl (x,y):z
16:40:19 <lambdabot> (x, y) : z
16:41:41 <jethr0_> jfoutz: what're you trying?
16:42:01 <jfoutz> just fooling around with point free style
16:42:36 <jfoutz> this would be more clear:
16:42:38 <jfoutz> extendBindings :: Variable -> Data -> [(Variable,Data)] -> [(Variable,Data)]
16:43:02 <jfoutz> the implementation is the obvious one...
16:43:57 <jfoutz> i was looking for something more concise. but 2 lines is good :)
16:44:00 <Philippa> palomer: I *need* recursive modules for some of the stuff I've done. And a lot of the rest is easily fakeable
16:44:09 <jethr0_> looks like you might want to have a look at the reader monad, maybe
16:44:16 <Philippa> jfoutz: there's an "insert" function in Data.List, IIRC
16:44:56 <jethr0_> Philippa: what would that do? insert x xs = x:xs?
16:45:05 <araujo> oh, did you guys read themail about linspire using Haskell as the main OS language?
16:45:16 <jethr0_> yep, quite nice
16:45:21 <araujo> indeed
16:45:21 <Philippa> jethr0_: yep
16:45:52 * araujo happy to see this happening
16:45:52 <jethr0_> ah, insert is for a \in Ord
16:46:12 * stepcut stands around looking innocent
16:46:15 <jfoutz> yeah. really i just want to make a pair, and cons it onto the list
16:46:23 <jfoutz> order dosn't matter
16:46:58 <psi> how can I make haskell-mode recognize .chs files?
16:47:39 <jethr0_> jfoutz: as i said, the "reader monad" might come in handy for the kind of thing you're doing
16:47:55 <jfoutz> @pl \x y z -> (x,y):z
16:47:55 <lambdabot> ((:) .) . (,)
16:48:07 <jfoutz> jethr0_: i go look that up now.
16:48:09 <stepcut> psi: I have something like this in my .emacs: (setq auto-mode-alist (append auto-mode-alist '(("\\.chs$"    . haskell-mode))))
16:48:44 <psi> thanks!
16:49:02 <stepcut> you can add a bunch of different extensions inside the '()
16:49:16 <jethr0_> jfoutz: depends how comfortable you are with monads. but you gotta start somewhere and the reader monad is quite straight forward
16:49:18 <stepcut> also there is this mode: ("\\.l[hg]s$" . literate-haskell-mode)
16:51:33 <jfoutz> jethr0_: that's a cool monad. strange name for it though. i thought it was a parser looking thing.
16:52:30 <jethr0_> jfoutz: yes, the name is a little weird. but especially for carrying around and extending simple environments it's quite perfect
16:53:09 <jfoutz> yes, no nead for (case ... Nothing ... Just ) all over the place
16:58:33 <jethr0_> k, nite everyone
16:58:51 <jfoutz> night.
16:58:54 <jfoutz> thanks again.
17:00:52 <Philippa> jfoutz: the name's by analogy to writer. Writer is a variant of the state monad that's "output only" - you can't look into it. Reader is "read-only" - you can pass a modified state to code you call, but you can never cause the code that called you to see a state change
17:04:26 <Cale> (Reader r a) is a fancy name for (r -> a)
17:08:56 <jfoutz> hmm. with the monad as a container model Reader makes a lot of sense. Sort of tuck away a stack.
17:09:57 <Cale> well, the way I see it, a value of type (r -> a) is like a (probably giant) container which for each value of r, holds a value of type a.
17:11:23 <jfoutz> :t abs
17:11:29 <jfoutz> @type abs
17:11:30 <lambdabot> forall a. (Num a) => a -> a
17:11:44 <jfoutz> @type id
17:11:45 <lambdabot> forall a. a -> a
17:14:02 <jip> does haskell standard library have a function for calling gettimeofday?
17:14:24 <jfoutz> Cale: i think the asks part makes it slightly more magical. inside a local i can ask for anything, and get a maybe back. inside a (r -> a) i can't ask for anything. i can only ask for bound things.
17:14:56 <Cale> jip: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
17:15:12 <Cale> maybe?
17:15:28 <Cale> you can only ask for a value of type r, and you'll always get it
17:16:10 <jip> Cale: hm.... maybe that's it thanks
17:16:15 <jfoutz> hmm. no you're right.
17:16:37 <jfoutz> i'm looking at this sample. http://www.nomaware.com/monads/html/readermonad.html
17:17:14 <jfoutz> that ... user of reader ... uses Maybe 
17:17:24 <metaperl> if I have a module called Locale.hs and I have some support data I want for the United States, I want to put that in Locale.US.hs how would the directory structure look?
17:18:08 <Cale> metaperl: either flat, or optionally, you could have a directory called Locale in which you place US.hs
17:18:24 <metaperl> them import Locale.US would work?
17:19:49 <Cale> it should
17:20:19 <Cale> I believe that you can point GHC at whatever directories you want, too.
17:23:58 <metaperl> Is this how to define a multi-line string in Haskell: http://rafb.net/paste/results/2JGkiR56.html
17:24:14 <Cale> no, that won't work
17:24:41 <Cale> normally, I apply unlines to a list of strings when I have a large string constant
17:24:57 <metaperl> I just took a data file and tried to inline it
17:25:15 <metaperl> because I didn't want to try to get relative paths right at runtime
17:25:33 <metaperl> is the current default directory of a module its own directory? I doubt it
17:26:03 <metaperl> @type unlines
17:26:04 <Cale> for file access? It's the cwd of the program as a while
17:26:04 <lambdabot> [String] -> String
17:26:06 <Cale> whole*
17:26:42 <metaperl> I really couldnt image pre-loading a lot of data for a Haskell program
17:27:00 <metaperl> in mod_perl, we typically load up all sorts of things at server startup time
17:27:42 <Cale> It's easier to load it at the start than at the middle.
17:50:13 <ihope> foldr1 (zipWith (+))
17:50:19 <ihope> >:-)
17:52:52 <jfoutz> >foldr1 (zipWith (+)) [1,2,3] [4,5,6] [7,8,9]
17:53:12 <Cale> > foldr1 (zipWith (+)) [[1,2,3], [4,5,6], [7,8,9]]
17:53:13 <lambdabot> [12,15,18]
17:53:18 <jfoutz> sneaky.
17:55:20 <LordBrain> whats the # operator?
17:55:28 <palomer> @pl \a -> do{x <- a; return (a,2)}
17:55:28 <lambdabot> (line 1, column 9):
17:55:28 <lambdabot> unexpected "{"
17:55:28 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
17:55:35 <Cale> LordBrain: nothing in the prelude
17:55:38 <palomer> @pl \a -> do{x <- a; return (a,2);}
17:55:38 <lambdabot> (line 1, column 9):
17:55:38 <lambdabot> unexpected "{"
17:55:38 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
17:55:44 <palomer> eh?
17:55:51 <LordBrain> oh wait... yeah.. i just realized its being defined in the program
17:55:59 <metaperl> I am having problems using do-notation on my (Cale's :)) Locale module: http://haskell.metaperl.com/locale/
17:56:06 <metaperl> do { ld <- loadLocaleDict "Locale/US.dat"; lu <- lookupCode "SC" ld; ret\
17:56:06 <metaperl> urn lu }
17:56:41 <Cale> metaperl: Swap the parameters to lookupCode?
17:56:49 <metaperl> nah, I changed that
17:56:54 <metaperl> that's not the error
17:57:10 <metaperl> I wanted lookupCode to be very similar to the Prelude lookup so I switched the calling
17:57:15 <Cale> oh
17:57:23 <metaperl> do { } >>= print
17:57:32 <metaperl> Couldn't match `IO' against `Maybe' 
17:57:37 <metaperl> that's the problem
17:57:44 <metaperl> the lookupCode is returning a Maybe
17:57:54 <metaperl> but I suppose I am trying to exit the monadic computation with it
17:57:57 <metaperl> via return lu
17:58:07 <metaperl> instead of leaving with a return IO of some sort
17:58:09 <metaperl> ?
17:58:10 <metaperl> think so?
17:58:10 <Cale> lookupCode isn't monadic
17:58:14 <metaperl> right
17:58:19 <metaperl> nor are its results
17:58:22 <Cale> (well, it's Maybe-monadic)
17:58:30 <metaperl> but my do-notation must close with IO right?
17:58:34 <Cale> you can very well return a Maybe value
17:58:49 <Cale> every line of the do-notation must be an IO action
17:59:00 <Cale> (or a let)
17:59:38 <Cale> btw, when the parameters are the other way around, it's easier to partially apply the lookup to the dictionary, and then pass that function to the rest of your program
17:59:38 <metaperl> why is that?
17:59:45 <Cale> why is that?
17:59:52 <metaperl> oh I see
18:00:04 <Cale> do {x ; <stmts>} = x >> do {<stmts>}
18:00:04 <metaperl> yes, that makes sense ... harder to curry the other way
18:00:17 <Cale> do {v <- x ; <stmts>} = x >>= \v -> do {<stmts>}
18:00:39 <Cale> do {let <decls> ; <stmts>} = let <decls> in do {<stmts>}
18:01:52 <metaperl> do { ld <- loadLocaleDict "Locale/US.dat" ; { let lu = lookupCode "SC" l\
18:01:52 <metaperl> d } ; return lu } >> print 
18:02:22 <palomer> does nubBy keep the first occurrence?
18:02:32 <metaperl> my do still fails
18:02:34 <ihope_> @type Data.List.nubBy
18:02:35 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
18:02:58 <Cale> do { ld <- loadLocaleDict "Locale/US.dat" ; let { lu = lookupCode "SC" ld } ; return lu } >>= print
18:02:59 <Cale> or
18:03:08 <Cale> do { ld <- loadLocaleDict "Locale/US.dat" ; let { lu = lookupCode "SC" ld } ; print lu }
18:03:43 <metaperl> hooray!
18:11:00 <dons> moin
18:11:07 <Cale> morning dons
18:12:58 <palomer> hullo!
18:13:01 <palomer> @palomer
18:13:01 <lambdabot> Hrmph, looks like I killed the channel
18:22:25 <delinka> how do I get the a string out of a Network.URI?
18:22:38 * delinka issues noob alert
18:23:26 <metaperl> delinka: can you post your code so far?
18:23:29 <metaperl> paste
18:23:42 <Cale> delinka: show?
18:24:06 <Cale> or possibly the uriToString function
18:24:20 <Cale> uriToString id uri ""
18:24:28 <delinka> well, it's lamdabot code, trying to debug host lookup, want to dump the URI it's connecting to when someone says @google ...
18:25:13 <Cale> yeah, show should do
18:26:12 <delinka> k, trying show...
18:28:05 <palomer> hrmph
18:28:14 <palomer> now I have to figure out the black art of pretty printing types
18:28:43 * delinka passes palomer cauldron, magic wand, and eye of newt
18:32:39 <Philippa> palomer: what do you need to do to make them pretty? The rest's not too bad
18:32:42 <Philippa> (usually)
18:35:27 <metaperl> Philippa: hello
18:35:38 <metaperl> ghc --make Flippi.hs -o foo
18:35:42 <metaperl> did not create foo
18:35:53 <Philippa> what went wrong?
18:36:08 <metaperl> well no error msg
18:36:16 <Philippa> 'mafraid I'm not planning on staying up too much longer btw, if this takes any length of time I might have to go to bed and come back tomorrow
18:36:26 <Philippa> hrmm. Not good. Which platform're you on?
18:36:38 <Philippa> and are there any other magically-appearing files?
18:36:46 <Philippa> what do you get if you leave off the -o part?
18:37:03 <metaperl> Philippa: http://haskell.metaperl.com/flippi/Flippi-0.03/compile.out
18:37:31 <metaperl> ScriptSyntax.hi showed up ... the whole directory is web-browseable
18:37:35 <Philippa> that's... interesting
18:38:04 <metaperl> 6.4.1 version of ghc
18:38:31 <metaperl> what would I point to if I wanted to compile on the fly via ghci in a cgi script?
18:38:46 <Philippa> Flippi.hs is the main module if that's what you mean
18:38:57 <Philippa> (and it's an ordinary CGI program once compiled)
18:39:42 <metaperl> is the darcs repo up? there are warnings about the use of deprecated DAta.FiniteMap
18:39:44 <shrimpx> anyone know which scheme compiler does static typechecking upfront to eliminate dynamic checks later on?
18:39:46 <metaperl> I would be happy to patch it
18:39:48 <Philippa> so hypothetically if you put the obviously #! line at the top of Flippi.hs that should work
18:39:56 <metaperl> shrimpx: bigloo?
18:40:01 <shrimpx> metaperl: oh yea
18:40:03 <shrimpx> metaperl: thanks!
18:40:05 <Philippa> the darcs repo's down. Currently I've been ignoring that - the version in darcs is a little different anyway
18:40:24 <Philippa> and it's been a while since I really worked on Flippi and the darcs version is kinda half way through a major metamorphosis
18:40:47 <Philippa> and yes, 0.03's old enough that Data.Map wasn't about at the time :-)
18:41:05 <Philippa> what happens if you try ghc --make Flippi.hs?
18:41:19 <Philippa> (you can safely ignore the warnings for now, one of these years it'll stop compiling but hey)
18:41:49 <palomer> Philippa: I'm pretty printing type derivations
18:41:53 <palomer> might as well make the types pretty
18:42:01 <metaperl> not muc hdifferent: http://haskell.metaperl.com/flippi/Flippi-0.03/compile.out
18:42:15 <palomer> have you ever noticed the acute lack of type derivations in papers?
18:42:30 <palomer> they spend 6 pages describing a method, and dedicate a single page to examples
18:42:41 <Philippa> yeah. More something I'd expect to see in a technical report or something like that, admittedly
18:43:00 <Philippa> metaperl: ouch. I've honestly no idea what's happening there
18:43:05 <metaperl> hmm
18:43:07 <delinka> more lambdabot -- my DNS resolution issue was with the proxy in Config.hs - proxy doesn't exist, name resolution fails. So how do I *not* use a proxy?
18:43:31 <Philippa> you're sure stderror's going to the usual place?
18:43:33 <metaperl> it works fine via ghci 
18:43:35 <dons> use Nothing, delinka 
18:43:42 <dons> rather than Just "foo"
18:43:44 <metaperl> I'm just at the shell, so I would see it
18:43:58 <delinka> dons, that's "Nothing", correct?
18:44:00 <Philippa> I've no idea then. Seems more like ghc playing silly buggers
18:44:09 <dons> delinka: no. the Nothing constructor
18:44:14 <Philippa> delinka: that's the value "Nothing" in place of "Just \"foo\""
18:44:19 <delinka> ah, without quotes ... got it
18:44:22 <metaperl> oh well. thanks for your help
18:44:25 <dons> so rather than:         proxy           = Just ("www-proxy",3128)
18:44:33 <dons> you say: proxy = Nothing
18:44:53 <delinka> thanks!
18:45:09 <Cale> http://cale.yi.org/autoshare/flippi-build
18:45:19 <metaperl> Cale: that's one you did?
18:45:22 <Cale> yeah
18:45:23 <Philippa> metaperl: something's odd though, Flippi.hs isn't directly dependant on ScriptSyntax.hs so it should *know* to find more
18:45:40 <metaperl> it's a debian build on my web host... 
18:45:51 <metaperl> maybe something whacked with the debian build
18:46:04 <Philippa> btw, if anyone bugs me to do it I'll put up a 0.031 release that uses Data.Map, shouldn't take me long
18:46:25 <metaperl> I think Philippa is right. I have a b0rked ghci
18:47:13 <Cale> or ghc is running out of memory, but you'd think you'd see something like "Killed" or some such in that case.
18:47:17 <metaperl> I guess I do. I can't prove it... OH!
18:47:19 <metaperl> Cale: yes
18:47:25 <metaperl> I have strict resource limits here
18:47:29 <metaperl> that's probably it
18:47:37 <metaperl> let me exit the XEmacs I'm running the shell in
18:48:21 <metaperl> sweet
18:48:27 <metaperl> compiles just fine.
18:48:33 <metaperl> have a goodnigh'ts sleep Philippa
18:50:53 <palomer> well, now that I've mastered pretty printing types, time to master pretty printing terms
18:58:50 <metaperl> Philippa: it lives: http://flippi.metaperl.com/flippi.cgi
19:05:04 <palomer> do you guys usually display your code in verbatim?
19:06:05 <metaperl> palomer: what do you mean? where?
19:06:10 <palomer> in latex
19:06:19 <palomer> or do you use mathmode and display it with nice lambdas?
19:06:23 <metaperl> oh
19:06:23 <metaperl> never did that
19:06:52 <skew> The few times I typeset code, I used lhs2tex or lambdatex, or something like that
19:07:12 <metaperl> skew: thanks for pinging me this morning
19:07:23 <skew> verbatim works for non-haskell code, I guess
19:07:53 <JKnecht> isnt haddock TeX based?
19:07:59 <metaperl> I was napping fitfully at the time :)
19:08:32 <skew> metaperl: sorry, I fell asleep around sunrise. Looks like Cale rewrote the code how I was going to.
19:08:44 <metaperl> yes, he did a pro job on it
19:12:39 <hyrax42> what are valid array indices
19:12:43 <hyrax42> other than Char and Int
19:13:40 <skew> anything that implements Ix
19:14:03 <skew> tuples might be interesting
19:15:16 <palomer> @pl \a -> do{ x <- a; return (x,2)}
19:15:16 <lambdabot> (line 1, column 9):
19:15:16 <lambdabot> unexpected "{"
19:15:16 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
19:15:20 <palomer> @type \a -> do{ x <- a; return (x,2)}
19:15:20 <lambdabot> forall (m :: * -> *) a b.
19:15:21 <lambdabot>             (Num b, Monad m) =>
19:15:21 <lambdabot>             m a -> m (a, b)
19:15:25 <palomer> ok, pl is broken:O
19:15:35 <palomer> anyways, is there a more idiomatic way to write that combinator?
19:16:13 <dons> @pl \a -> a >>= \x -> return (x,2)
19:16:13 <lambdabot> (flip (,) 2 `fmap`)
19:16:23 <dons> it just doesn't do do-notation
19:16:32 <dons> feel free to patch
19:18:26 <skew> what about operator slices?
19:18:38 <skew> shouldn't that be (fmap (,2))?
19:18:49 <dons> ?type (,2)
19:18:50 <lambdabot> parse error on input `2'
19:18:59 <dons> ?type (,) 2
19:19:00 <lambdabot> forall a b. (Num a) => b -> (a, b)
19:19:10 <skew> hmm, I thought you could slice commas too
19:19:20 <dons> its a H' proposal, I thought
19:20:04 <jgraves> ? type (,)
19:20:16 <jgraves> ?type (,)
19:20:17 <lambdabot> forall b a. a -> b -> (a, b)
19:23:16 <palomer> yeah, you could use (,) and flip (,)
19:26:38 <metaperl> main :: IO () 
19:26:38 <metaperl> main = wrapper cgi 
19:26:38 <metaperl> -- what is wrapper and where is it defined?
19:27:31 <Philippa> Network.CGI
19:27:39 <Philippa> (I really should be in bed, where's my willpower?)
19:28:03 <metaperl> lol
19:28:09 <metaperl> it does work now Philippa. thanks
19:28:14 <metaperl> now to understand it :)
19:31:08 <palomer> I can now assert that you don't need a PhD to use monads effectively
19:31:12 <palomer> you only need a masters degree
19:31:22 <metaperl> :)
19:31:36 <metaperl> an M.S. is a necessary but not sufficient condition
19:31:47 <metaperl> I have an M.S. and I am barely staying about water with them
19:32:34 <jgraves> I have a B.S. in CS, and I intend to master monads... one day.
19:33:10 <Cale> I've taught monads to 11 year old kids :)
19:33:27 <jgraves> Yeah, but it is easier to learn when you are young.
19:33:33 <jgraves> I'm an old man.  37.
19:33:42 <palomer> to what extent was your teaching?
19:33:57 <palomer> did you dress up as a bumble bee and sing songs about monads?
19:34:02 <Cale> hehe
19:34:17 <metaperl> lol
19:34:18 <jgraves> I have over 25 years of imperative programming to unlearn too.
19:34:21 <Cale> Well, basically the content of Monads as Containers, and the use of IO. They could write small programs.
19:34:26 <metaperl> palomer: that is hilarious!
19:34:37 <metaperl> Cale: you should've used my pictures
19:34:45 <Philippa> metaperl: I don't have an MS, in fact I never finished my bachelor's
19:34:55 <Cale> I had similar pictures actually.
19:35:08 <Philippa> I think I understand monads, and I don't think the Feynman quote about quantum physics applies to them either
19:35:24 <palomer> Philippa: stop corroborating my evidence!
19:35:34 <metaperl> Philippa: what is the diff between GET and POST in Flippi?
19:36:01 <Philippa> metaperl: a GET edit request starts an edit, a POST edit request is the new content being sent back
19:36:32 <Cale> jgraves: I've pointed you at Monads as Containers, right?
19:36:32 <metaperl> and why did you print strings 'l':'i:':[]  instead of "li"
19:36:56 <Cale> @wiki Monads as Containers
19:36:57 <lambdabot> http://www.haskell.org/haskellwiki/Monads as Containers
19:37:00 <Cale> er
19:37:03 <Cale> @wiki Monads_as_Containers
19:37:03 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
19:37:13 <Philippa> 'cos they were patterns and I didn't want to look up if string patterns a) existed and b) allowed a tail
19:37:34 <Philippa> Cale: could the kids use State-likes as comfortable as Maybe or List?
19:38:05 <jgraves> Cale: I haven't seen that one yet.  But I'll check that one too.
19:38:30 <Philippa> jgraves: was the one I pointed you at helpful? Any comments as to where I could/should go with it?
19:38:32 <Cale> jgraves: ah, I recommend starting with it, and then reading All About Monads
19:38:40 <eivuokko> jgraves, imo it's good, I recommend reading it early.
19:38:49 <jgraves> OK, will do.
19:39:05 <Cale> Philippa: we didn't use statelikes too much, though they were okay with IO.
19:39:07 <dons> eivuokko: you might want to look at the new generate. I allocate on the haskell heap now, so no calls to malloc or free.
19:39:08 <Philippa> Cale: if I copied that WIP thing of mine onto the haskell wiki, would you be interested in helping me flesh it out further? I seem to be out of tuits
19:39:19 <Cale> sure
19:39:22 <Philippa> okay with IO is a good start :-)
19:39:42 <jgraves> Using this link, for those who are interested: http://www.nomaware.com/monads/html/
19:39:46 <dons> eivuokko: so then i wonder about needing to block. probably still useful.
19:40:18 <eivuokko> dons, Cool, I'll check it tomorrow...well today, after I've slept.
19:41:37 <dons> ok :) it made things abotu 10% faster, avoiding into C. so well worth it.
19:41:43 <eivuokko> !
19:42:14 <dons> the haskell heap is managed much better for haskell objects.
19:42:31 <dons> so tryign to ensure we keep all fps strings on the haskell heap is important.
19:42:49 <metaperl> what does +++ do in Haskell?
19:42:52 <dons> anyway, now reduction functions like filter, or unfold, can allocate on the haskell side too. they got faster.
19:43:31 <metaperl> @type (+++)
19:43:33 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
19:43:33 <lambdabot>    (ArrowChoice a) =>
19:43:33 <lambdabot>    a b c -> a b' c' -> a (Either b b') (Either c c')
19:44:56 <eivuokko> dons, That' really cool.  And yeah, ghc heap is pretty awesome.
19:45:56 <Cale> > ((+1) +++ (+5)) (Left 0)
19:45:57 <lambdabot> Left 1
19:46:01 <Cale> > ((+1) +++ (+5)) (Right 0)
19:46:01 <lambdabot> Right 5
19:46:19 <palomer> no many operators!
19:46:23 <palomer> s/so/no
19:46:53 <Cale> > ((+1) *** (+5)) (0,0)
19:46:53 <lambdabot> (1,5)
19:47:19 <Cale> @type (&&&)
19:47:20 <lambdabot> forall (a :: * -> * -> *) c' c b.
19:47:20 <lambdabot>    (Arrow a) =>
19:47:20 <lambdabot>    a b c -> a b c' -> a b (c, c')
19:47:38 <Cale> > ((+1) &&& (+5)) 0
19:47:39 <lambdabot> (1,5)
19:48:37 * palomer wishes -> was not a monad
19:48:46 <palomer> it makes reading type errors impossible
19:49:05 <Cale> It's only a monad if you import Reader
19:49:20 <Cale> ((->) e) is a monad, anyway
19:51:04 <Cale> > (do x <- (+10); y <- (+20); return (x,y)) 5
19:51:05 <lambdabot> (15,25)
19:51:28 <Cale> > (do x <- (+10); y <- (+20); (,) (x,y)) 5
19:51:29 <lambdabot> ((15,25),5)
19:54:33 <palomer> the last expression of the do block doesn't seem to be an element of e ->
19:55:11 <Cale> it sure is
19:55:25 <Cale> > (,) (15,25) 5
19:55:26 <lambdabot> ((15,25),5)
19:55:32 <palomer> ah, righto
19:55:50 <palomer> Cont and -> look quite similar
19:55:56 <palomer> or, rather, Cont r
19:56:00 <palomer> and r ->
19:56:41 <Cale> Cont is far more sublime
19:57:18 <palomer> which sense of the word?
19:58:12 <dons> the Kantian sublime.
19:58:56 <palomer> gotta run!
19:59:02 <Cale> in the sense of inspiring awe
19:59:25 <Cale> (and confusion :)
20:05:32 <hyrax42> where is Philippa's article on monads
20:05:43 <hyrax42> I thought I bookmarked it :/
20:06:56 <hyrax42> why is the reader monad called that
20:10:43 <Cale> because it's the type of computations which "read" from an "external" environment
20:10:59 <hyrax42> an example of use?
20:11:03 <Cale> (the value which you later provide)
20:11:13 <hyrax42> ah, like 5 above?
20:11:17 <Cale> yeah
20:11:23 <hyrax42> hmmm
20:11:31 <hyrax42> this one seems a bit subtle
20:11:52 <Cale> that's written in the stripped-down reader monad -- usually there's a bit of extra scaffolding
20:12:08 <hyrax42> well the reader monad in general
20:12:32 <Cale> > (do x <- ask; return (x+1)) 5
20:12:33 <lambdabot> 6
20:12:43 <Cale> hehe
20:12:46 <Cale> > (do x <- id; return (x+1)) 5
20:12:47 <lambdabot> 6
20:12:47 <hyrax42> :t ask
20:12:52 <hyrax42> @type ask
20:12:54 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
20:12:54 <Cale> @type ask
20:12:55 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
20:13:09 <Cale> in this case, ask = id
20:13:45 <Cale> in general, it gets the environment
20:14:09 <Cale> there's also local
20:15:16 <hyrax42> > (ask >>= return (+1) 5
20:15:17 <lambdabot>  parse error on input `}'
20:15:28 <hyrax42> > (ask >>= return (+1)) 5
20:15:29 <lambdabot> 6
20:17:06 <hyrax42> so is ask >>= return === id?
20:19:08 <Cale> > (ask >>= return) 5
20:19:08 <lambdabot> 5
20:19:13 <Cale> yeah, I suppose so :)
20:19:24 <hyrax42> hm
20:19:40 <Cale> > let lookupEnv x = do {e <- ask; return (lookup x e)} in (do Just x <- lookupEnv "x"; Just x' <- local (("x","goodbye"):) (lookupEnv "x"); return [x,x']) [("x","hello")]
20:19:41 <lambdabot> ["hello","goodbye"]
20:19:44 <Korollary> @type ask >>= return
20:19:45 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
20:20:09 <petekaz> @where fps
20:20:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:20:34 <hyrax42> @type local
20:20:36 <lambdabot> forall r (m :: * -> *) a.
20:20:36 <lambdabot>    (MonadReader r m) =>
20:20:36 <lambdabot>    (r -> r) -> m a -> m a
20:20:53 * dons attempts to filter 1 TB of data through haskell
20:21:06 <Cale> woo :)
20:21:22 <dons> 1 TB should be enough for anyone, right? ;)
20:21:32 <hyrax42> :)
20:21:39 <hyrax42> where areyou getting 1 TB?
20:21:43 <olliej> dons: what on earth are you doing?
20:21:49 <dons> I guess there are people even here perhaps, with 2 500M hds, though.
20:21:56 <Lemmih> olliej: He's showing off.
20:22:01 <olliej> hehe
20:22:05 <Cale> olliej: testing fps
20:22:14 <dons> 10G seems to low a limit for promotional purposes
20:22:34 * olliej looks at fps
20:22:36 <hyrax42> but where is your TB coming from
20:22:38 <dons> hyrax42: generating it on the fly.
20:22:41 <hyrax42> oh right
20:22:45 <dons> I have a 10G file, I'm unfolding
20:22:52 <olliej> dons: /dev/random?
20:22:58 <hyrax42> and sending to stdin?
20:23:02 <dons> that would be another option.
20:23:08 <dons> straight to /dev/null, actually :}
20:23:22 <dons> it is going to stdout though. and coming in via stdin
20:23:25 * olliej wonders how he broke functor
20:23:28 <hyrax42> yeah that's what I mean
20:24:04 <hyrax42> bioinformatics guys will like?
20:24:14 <dons> hopefully. kzm, you like?
20:24:31 <dons> streaming media stuff seems another option too.
20:24:35 <hyrax42> my roommate had to do a few hundred megs or a gig of data processing not too long ago
20:25:03 <hyrax42> BufferedReaders in Java
20:25:04 <hyrax42> iirc
20:25:25 <dons> hehe. 1G is the new 1M these days. fps laughs in the face of 1G ;)
20:25:37 <hyrax42> heh
20:29:51 * olliej thikns the type forall a b a b a b . a->b->(a,b) might be slightly wrong
20:30:53 <dons> ?type forall a b a b a b . a->b->(a,b)
20:30:54 <lambdabot> parse error on input `->'
20:31:03 <dons> ?type forall a b a b a b . a -> b -> (a,b)
20:31:04 <lambdabot> parse error on input `->'
20:31:10 <dons> ?type forall a b . a -> b -> (a,b)
20:31:11 <lambdabot> parse error on input `->'
20:31:14 <dons> bah
20:31:19 <dons> no -fglasgow-exts
20:31:26 <dons> hmm. or is that true.
20:31:59 <dons> ?kind forall a b . a -> b -> (a,b)
20:32:00 <lambdabot> *
20:32:01 <olliej> dons: my compiler is inventing things again is my guess
20:32:15 <dons> ?kind forall a b a b a b a b .  a -> b -> (a,b)
20:32:15 <lambdabot>   Conflicting definitions for `a'
20:32:16 <lambdabot>   In GHCi input
20:32:23 <dons> you want to do a nub ?
20:32:29 <dons> on the tyvar list.
20:32:56 <olliej> ?
20:34:46 <dons> just a hack i remember from a toy compiler I wrote once. it did 'List.nub' on the tyvar list for forall s
20:34:51 <dons> to remove duplicates.
20:34:52 <olliej> hehe
20:34:57 <olliej> compiler written in c#
20:35:13 <dons> oh. you've entered the 3rd ring of hell
20:35:32 <olliej> dons: there are reasons :)
20:35:42 <olliej> dons: 1) i'm really crap at haskell
20:36:02 <olliej> 2) it gives me access to .net libraries -- eg. the ability to examine assemblies
20:36:50 <hyrax42> @index ask
20:36:50 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
20:36:52 <dons> ah well. i'm still not convinced you shouldn't be using the world's only language designed for writing compilers.
20:37:02 <eivuokko> Heh
20:37:11 <olliej> dons: what, you mean perl ;)
20:37:20 <dons> structure pattern matching on abstract syntax is worth 10+ karma points.
20:38:09 <dons> since then you can do nice structural induction passes on the AST with little effort
20:38:16 <olliej> dons: :)
20:38:31 <olliej> dons: but i still ouldn't be able to look at the contents of other assemblies
20:38:46 <eivuokko> Just make ghc's .net interop work again ;)
20:38:48 <dons> Foreign.Ptr, right ?
20:39:04 <dons> ;) I joke.
20:39:08 <olliej> :)
20:39:25 <olliej> have come up with a small and pointless litle proglet
20:39:37 <olliej> that looks at an assembly then generates a core stub
20:39:48 <olliej> that ghc can compile to an hi file
20:40:00 <olliej> so that ghc can generate code that referecnes said functions
20:40:08 <olliej> and then i can link through it
20:40:18 <eivuokko> Pointless?
20:40:21 <dons> thats  really cool.
20:40:33 <olliej> yeah it breaks excitingly unfortunately
20:40:52 <olliej> as i assume all types are inside a CLI)Haskell workspace
20:41:08 <olliej> and i have no immediately obvious way of countering that
20:41:31 <olliej> adn it makes all functions "safe"
20:41:51 <eivuokko> Hmmm.
20:42:05 <olliej> eg. generate ye olde wrapper functions
20:42:46 <olliej> but all that's on the back burner as a try to unbork my compiler
20:57:17 <ihope_> Did somebody say +10 to karma?
20:59:22 <palomer> is it ok to simply cp -r a darcs repo?
20:59:33 <palomer> doing darcs put doesn't seem to do the job correctly
21:00:01 <Lemmih> Yeah, that should be fine.
21:01:04 <ihope_> Hmm, what was that, now...
21:01:19 <ihope_> (a -> b -> b) -> b -> b, musta been.
21:01:45 <ihope_> @djinn a -> ((a -> b -> b) -> b -> b) -> (a -> b -> b) -> b -> b
21:01:45 <lambdabot> f a b c d = b (\ _ e -> e) (c a d)
21:05:39 <ruffneck> cryptic
21:09:35 <palomer> @type \a b -> b
21:09:36 <lambdabot> forall t t1. t1 -> t -> t
21:13:57 <dons> loop fusion must be one of the most useful concepts in optimisation. i wish I'd understood it sooner.
21:14:09 <dons> or understood it in the fp context, at least
21:15:17 <palomer> what's it about?
21:17:55 <dons> turning, say, filter g . map f into a loop k (x:xs) = case f x of Nothing -> loop k xs ; Just y -> case g y of Nothing -> loop k xs ; Just e -> e : loop k xs -- rougly.
21:18:05 <dons> such that you only pass over the data once.
21:18:23 <dons> and using RULES to do do the fusing for you.
21:18:55 <dons> ?pretty loop k (x:xs) = case f x of Nothing -> loop k xs ; Just y -> case g y of Nothing -> loop k xs ; Just e -> e : loop k xs
21:18:55 <lambdabot>  loop k (x : xs)
21:18:55 <lambdabot>      = case f x of
21:18:55 <lambdabot>        Nothing -> loop k xs
21:18:55 <lambdabot>        Just y -> case g y of
21:18:55 <lambdabot>            Nothing -> loop k xs
21:18:57 <lambdabot>            Just e -> e : loop k xs
21:18:58 <dons> ah nice!
21:19:56 <hyrax42> is that new?
21:19:58 <palomer> nice
21:20:23 <dons> hyrax42: the plugin? somewhat.
21:20:32 <dons> it's underutilised, at least.
21:20:47 <hyrax42> yeah, that's pretty nice
21:28:05 * palomer 's haskell code is starting to look like scheme
21:28:28 <hyrax42> ?
21:30:05 <palomer> if you're only working in an edsl, then all you do is apply constructors
21:30:10 <palomer> EDSL
21:30:38 <hyrax42> E?
21:30:41 <hyrax42> embedded?
21:31:37 <palomer> yup
21:36:07 <dons> Extra-cool
21:41:51 <palomer> \x y -> concat $ intersperse x  y is a beautiful combinator
21:43:36 <palomer> @pl \x y -> concat $ intersperse x y
21:43:37 <lambdabot> (join .) . intersperse
21:44:16 <palomer> @type \x y -> concat $ intersperse x y
21:44:18 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:44:23 <palomer> @type (join .) . intersperse
21:44:24 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:44:30 <Cale> join = concat
21:44:36 <palomer> literally?
21:44:39 <palomer> @type join
21:44:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
21:44:42 <palomer> @type concat
21:44:42 <Cale> for the list monad
21:44:43 <lambdabot> forall a. [[a]] -> [a]
21:44:50 <palomer> @pl concat
21:44:50 <lambdabot> join
21:45:13 <Cale> it probably does that because it has more algebraic rules for join
21:45:22 * palomer slaps lambdabot
21:45:28 <palomer> Cale: then it should substitute back at the end
21:45:45 <Cale> @pl \x -> x x
21:45:45 <lambdabot> join id
21:45:48 <Cale> hehe
21:46:03 <palomer> @type join id
21:46:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
21:46:04 <lambdabot>   Expected type: a -> a -> a1
21:49:10 <palomer> latexifying proof terms is a huge pain
21:54:56 <araujo> Hello!
22:08:35 <dons> a breakdown of how Data.ByteString.Lazy performs against Data.ByteString is here: http://www.cse.unsw.edu.au/~dons/tmp/lazy.png
22:09:11 <dons> now, we know bytestring is fast. what's interesting is to see the cases where Lazy has effectively O(spine) performance.
22:09:19 <dons> versus ByteString, which would have O(n)
22:09:24 <Lemmih> What do those numbers mean?
22:09:33 <dons> y axis is running time
22:09:38 <dons> x axis is test number
22:09:43 <olliej> hmmm.. it would appear my compiler is inventing free types
22:09:43 <dons> i.e. test 0 is append
22:10:02 <dons> so whenever the green line is above the red line, lazy bytestrings are faster
22:10:29 <dons> this is on 10M data, of course once the data's around 0.5G, you can only use the lazy version
22:11:09 <eivuokko> Lazy is really fast :o
22:11:10 <dons> so, as expected, append, concat, cons all perform in O(spine).
22:11:28 <dons> however, for find/ findIndex, lazy is about 10x slower
22:11:35 <dons> not sure why, I expect to fix it though.
22:12:11 <dons> elsewhere, its within 10% of byte. 
22:12:28 <Cale> you're including the construction of the string in the strict case?
22:12:59 <dons> the big speed ups are in: join, cons, snoc, append.
22:13:20 <dons> Cale, yes, in both cases the result is forced. so it measures actual time to perform the operation.
22:13:30 <Cale> ah, okay
22:13:38 <dons> so for append, to copy the spine, or to memcpy the body
22:14:16 <dons> so, overall, i'd say quite nice. you get roughly the speed of a bytestring, but with the advantage you can extend it to infinite strings.
22:15:12 <Cale> yeah, it's quite good. I wonder how it compares with Data.Sequence
22:16:01 <Cale> actually, I wonder how well a Sequence of ByteStrings would work
22:17:23 <dons> the chunk size is tuned to my cache size, which can make a big difference (if you choose a chunk size > cache, you can get a 2 to 4x slow down)
22:18:34 <Cale> Interesting, I suppose that makes sense
22:18:44 <dons> i just love actually being able to see cache effects in haskell :) all this list of ptr stuff means we don't even want to ponder cache effects normally
22:19:06 <dons> actually, i have my cache size/chunk size graph somewhere.
22:20:25 <dons> ah, here: http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
22:20:32 <dons> 256k L2 cache
22:20:40 <dons> running time versus chunk size
22:21:08 <dons> so between 1/2 and 1x the L2 cache is best, if you go above this though, it falls away really quickly
22:22:21 <eivuokko> Hmm.
22:22:40 <dons> eivuokko: what you reckon? do these numbers make sense?
22:22:56 <Cale> How does it look as you head down toward 0?
22:23:24 <eivuokko> What operation is that (on the graph)?
22:23:27 <dons> oh, the smallest chunk size I measured was 1k, as you approach 1 byte, you approximate [Char] , of course.
22:23:30 <dons> I should have measured that.
22:23:33 <Cale> Right
22:23:45 <dons> [Char] is usally 4 to 8x slower, I've noticed.
22:24:02 <dons> so I'd expect a similar deterioration towards 0 too.
22:24:12 <dons> eivuokko: that was a filter.
22:24:40 <dons> so it pulls in a chunk, and copies a subset into another buffer.
22:24:44 <Cale> It would be interesting to see the smallest chunksize where it's still around 12
22:25:00 <dons> right, since that would affect the smallest heap size you can run with.
22:25:39 <Cale> It's interesting that it actually looks like it's getting better for smallish chunk sizes too.
22:26:07 <dons> i'll see if I can run the numbers from 1 byte upwards.
22:29:48 <eivuokko> Like you said, way cool that cache effects show up so dramatically in haskell code.  Thanks for doing so much work on benchmarks and overall FPS.
22:29:58 <eivuokko> @karma+ dons
22:29:59 <lambdabot> dons's karma raised to 35.
22:30:34 <dons> its become a bit of an obsession, i have to admit. i lose sleep over it :/
22:30:49 <eivuokko> Oh :-S
22:31:10 <dons> not too badly. i lost more sleep when hacking on yi last year.
22:31:14 <dons> or was it the year before.
22:31:18 <dons> :)
22:31:21 <eivuokko> Heh.
22:31:28 <dons> anyway, this is how we get things done.
22:33:47 <hyrax42> maybeToList (Just x) = [x]; maybeToList Nothing = []?
22:33:58 <Cale> yep
22:34:11 * hyrax42 looking at All About Monads now
22:34:48 <hyrax42> how often does one create a new monad when programming in haskell
22:35:14 <Cale> depends on your style and what you're trying to do
22:36:42 <Cale> Usually it's as easy as stacking a few monad transformers, newtyping that, and then building some custom operations.
22:37:18 <Cale> Completely novel monads are somewhat rare, but they can be done.
22:37:27 <hyrax42> sounds "easy"
22:37:30 <eivuokko> I think monads much like an abstraction similar to what dependencies between classes in oop tend to describe.
22:38:16 <Cale> http://www.haskell.org/haskellwiki/Sudoku
22:38:34 <Cale> have a look at my (admittedly naive) Sudoku solver
22:39:15 <hyrax42> cool
22:39:17 <Cale> It's naive, but the use of a special monad for sudoku solving makes the rest of the code look even more naive.
22:39:18 <hyrax42> this'll be interesting, Ihope
22:39:44 <hyrax42> as I made an attempt at a sudoku solver in java
22:40:03 <hyrax42> so the differenc ein approach will be good
22:40:30 <Cale> I like how in the end, the actual solving part comes down to 5 lines :)
22:40:39 <azuroth> ?hoogle [a] -> a
22:40:39 <lambdabot> Prelude.head :: [a] -> a
22:40:39 <lambdabot> Prelude.last :: [a] -> a
22:40:39 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
22:40:51 <azuroth> hoogle++ :-)
22:41:03 <Cale> @karma+ hoogle
22:41:03 <lambdabot> hoogle's karma raised to 1.
22:43:21 <hyrax42> how long does it take to solve a typical sudoku
22:43:46 <Cale> for most humanly solvable ones it's basically instantaneous.
22:44:06 <Cale> There are some really tough ones which it can't do in a reasonable time though.
22:44:34 <Cale> (and some which it has to grind on for a few seconds)
22:45:59 <Cale> probably if it used some heuristic to determine good places to start it would do a better job
22:46:13 <hyrax42> cool
22:46:18 <hyrax42> I'll look over it tomorrow
22:46:24 <hyrax42> I think I should go to bed now
22:46:28 <hyrax42> gnight
22:46:33 <Cale> 'night
22:53:04 <stepcut> Cale: i like the 'forM' function
22:53:34 <Cale> yeah, it's handy
22:53:34 <azuroth> lisppaste2: paste?
22:54:16 <azuroth> @paste
22:54:23 <azuroth> ?paste
22:54:55 <azuroth> hm
22:55:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:55:07 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
22:55:11 <azuroth> oh
22:55:11 <stepcut> heh
22:55:17 <palomer> @hoogle forM
22:55:17 <lambdabot> Text.Html.form :: Html -> Html
22:55:17 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
22:55:17 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
22:55:32 <palomer> @type forM
22:55:33 <lambdabot> Not in scope: `forM'
22:57:55 <azuroth> http://rafb.net/paste/results/QS569K28.html is there a better way to do `convToLines`? I dunno, maybe with a fold?
22:58:09 <eivuokko> ?type flip mapM
22:58:10 <lambdabot> forall a (m :: * -> *) b.
22:58:10 <lambdabot>      (Monad m) =>
22:58:10 <lambdabot>      [a] -> (a -> m b) -> m [b]
23:01:15 <palomer> azuroth: zipWith Line (lst) (tail lst) <--this should do it
23:01:59 <palomer> at least for the ls function
23:02:12 <azuroth> and then just ++ Line (last lst) (head lst)
23:02:22 <azuroth> that's awesome
23:03:56 * palomer is off to bed
23:03:56 <palomer> nigh
23:03:57 <palomer> t
23:04:15 <azuroth> convToLines lst@(f:ps) = zipWith Line (lst) (ps ++ f) # maybe?
23:04:57 <azuroth> night :-)
23:09:50 <azuroth> ?hoogle [a] -> [a]
23:09:50 <lambdabot> Prelude.cycle :: [a] -> [a]
23:09:51 <lambdabot> Prelude.init :: [a] -> [a]
23:09:51 <lambdabot> Prelude.reverse :: [a] -> [a]
23:10:40 <Cale> no tail?
23:11:24 <azuroth> yeah, that's weird. is init though
23:11:43 <azuroth> zipWith Line (lst) (cycle$tail lst)
23:12:32 <azuroth> no, tail (cycle lst)
23:13:09 <dons> ?hoogle+
23:13:09 <lambdabot> Prelude.tail :: [a] -> [a]
23:13:09 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:13:09 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
23:14:11 <azuroth> prelude.ninja... :x
23:14:38 <azuroth> oh, it's cons
23:22:22 <Cale> hehe
23:23:25 <dons> > let ninja = (:) in 'x' `ninja` 
23:23:25 <lambdabot>  parse error on input `}'
23:23:43 <dons> > let ninja = (:) in 'x' `ninja` "foo"
23:23:43 <lambdabot> "xfoo"
23:24:20 <dons> > let ninja :: Char -> [Char] -> [Char] ; ninja = (:) in ninja
23:24:20 <lambdabot> <Char -> [Char] -> [Char]>
23:25:29 <araujo> :-)
23:25:32 <araujo> hola dons 
