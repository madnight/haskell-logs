00:01:16 <goltrpoat> (assuming you start with a DAG to begin with)
00:01:17 <Cale> goltrpoat: that's true as well
00:01:17 <dcoutts> dons, I think we're missing some things compared to Data.List
00:01:17 <dcoutts> Fri May 12 04:33:30 BST 2006  Don Stewart <dons@cse.unsw.edu.au>
00:01:17 <dcoutts>   * HEADS UP: Add lazy IO functions. Haskell breaks the 4G barrier!
00:01:17 * dcoutts grins
00:01:17 <dons> hehe
00:01:17 <dcoutts> so what chunk size gives the best performance?
00:01:17 <Cale> also, you don't have to worry too much about painting visited vertices if you don't want to.
00:01:17 <Cale> (though it probably helps)
00:01:17 <dons> dcoutts: smaller seems better. <= 128k anyway
00:01:17 <goltrpoat> -nod-
00:01:17 <dons> for really big files.
00:01:17 <dcoutts> dons, right, that's good I guess
00:01:22 <dcoutts> I was expecting it to be around 64k or so
00:01:51 <dons> yeah, but not too small,otherwise we end up as a [Ptr Word8#]
00:01:59 <dcoutts> indeed
00:02:17 <dcoutts> dons, I guess it's what makes the 1st GC generation fit in the cache
00:02:45 <dons> now, i had a think about the Arbitrary instance, and modified it slightly to only generate a few different chars, not the full range, in the hope that pivot chars are more likely to appear at the start or end of chunks.
00:02:57 <dons> no new tests fail, but the tests generated did seem more useful 
00:03:37 <dcoutts> ok, and hat are the chunk sizes like now, generated by QC? I thought they were looking a little large
00:03:42 <dcoutts> hat/what
00:03:54 <dons> oh, from 0 .. 15 or so?
00:04:00 <dons> maybe there should be more smaller ones.
00:04:21 <dcoutts> the corner cases in .Lazy are all about chunk boundaries
00:04:36 <dcoutts> so smaller chunks should show up the bus more frequently
00:04:42 <dcoutts> bus/bugs
00:04:55 * dcoutts can't spell this early in the morning
00:05:28 <dons> no, show up the bus made perfect sense
00:05:34 <dcoutts> :-)
00:05:43 <dons> i quite like this whole "24 hours a day, someone's working on fps" model 
00:05:51 <Cale> all your bus are belong to us
00:06:02 * dcoutts ought to do some real work
00:06:08 <dons> make's me ponder an icfp 06 structure..
00:06:15 <goltrpoat> ulfdoz:  i guess in general..  say we start with a valid graph.  for each vertex v, compute the list of vertices reachable from v.  now, whenever you add an edge, from a to b, say, check if a is in b's list.  if so, discard the edge -- otherwise, add b to a's list.  that way you don't have to do a full DFS every time you add something.
00:06:16 <dcoutts> Cale, we have set up the bus
00:06:43 <Cale> you have no chance to survive make your bus
00:07:21 * dcoutts has friends who bought a bus off ebay
00:07:22 <goltrpoat> er.  add b, along with b's list, to a's list
00:07:55 <Saulzar> Can you sell your bus, then?
00:07:55 <dons> dcoutts: you can write quite fun filter programs, like hGetN 1000000 stdin >>= ...
00:07:55 <dons> that actually work and run in constant space.
00:08:28 <dcoutts> Saulzar, the could but noone would buy it, its a "1981 British Leyland double decker" and it's blue.
00:09:32 <dcoutts> dons, nice
00:09:41 <dons> cool!
00:09:41 <dcoutts> if only someone was qualified to drive it...
00:09:41 * dcoutts sniggers quietly
00:09:41 <ulfdoz> goltrpoat: Ok, that is the point where I must tune xml-validation. :)
00:10:00 <Saulzar> Hehe, I was referring to the bus you find fps, if there is a market... :)
00:10:33 <goltrpoat> ulfdoz:  tell me you're not trying to detect strongly connected components in an xml schema? :)
00:12:47 <ulfdoz> goltrpoat: Nope, I can't. :) I wanted to ensure that in schema.
00:15:03 <goltrpoat> how would that even work
00:15:24 <ulfdoz> goltrpoat: Indirectly that was my question.
00:15:30 <goltrpoat> hehe
00:16:14 <kzm> dons, pulling from your repo is slow, is there anything I (or you) can do?
00:16:51 <ulfdoz> bbl, must leave for a talk.
00:16:55 <goltrpoat> maybe there's some what to write a graph in such a way that any directed graph written in that manner is acyclic
00:17:03 <goltrpoat> what=way
00:17:29 <dcoutts> kzm, ask him not to live on the other side of the world?
00:18:07 <Cale> goltrpoat: I think I mentioned one such way
00:18:07 <kzm> yeah, dons.  Isn't it time you moved to somewhere civilized?
00:18:16 <kzm> I think the next-door sub-glacial cave is for sale.
00:18:32 * kzm think the rest of us should move to .au instead.
00:18:40 <goltrpoat> cale:  you did?
00:18:55 <Cale> Encode it as a list of vertices together with their inarcs, such that the tails of the inarcs are all vertices already in the list.
00:19:04 <goltrpoat> oh i missed that
00:20:16 <kzm> dcoutts, .au is theoretically only 0.1 second away, so I don't think that is the main problem.
00:20:31 <dcoutts> kzm, I'm sure you're right
00:21:25 <dcoutts> dons, for the API we could eliminate the back operators, eg snoc, fooFromEnd etc
00:21:27 <goltrpoat> cale:  that's pretty cool.
00:21:44 <dcoutts> dons, because that's not going to work well for our streaming application
00:21:51 <Pseudonym> Gotta go.  Nytol!
00:22:11 <dcoutts> dons, we might make it too easy to make mistakes if we provide those ops
00:22:29 <Cale> The only problem with it is that it basically requires the input to be topologically sorted, and one of the major reasons for constructing a dag in the first place is to do a topological sort.
00:22:47 <dcoutts> dons, if we keep them we must mark them as strict, where strict == bad for long streams
00:22:49 <Cale> of course, if that's not your goal, then it's fine :)
00:23:21 <dons> dcoutts: yeah, i think its reasonable to have only the safe ones, plus other common things (like length)
00:23:37 <dcoutts> yeah, length is ok
00:23:54 <dcoutts> it doesn't keep the whole thing in memory
00:23:54 <goltrpoat> i really want to know why my usb drive just decides to start randomly beeping once in a while
00:24:09 <dcoutts> (at least so long as you don't hold onto the head)
00:24:22 <dcoutts> but snoc does so necessarily
00:24:35 <dcoutts> hmm, or does it.
00:24:47 <dons> right. snoc is only there because its easy in ByteString. its not in List, so its ok to toss
00:25:22 <dcoutts> it's using ++ [x] which I guess is lazy
00:25:23 <dcoutts> as is concat
00:25:24 <araujo> morning
00:25:25 <shapr> good morning #haskell!
00:25:27 <dcoutts> hey araujo 
00:25:39 <araujo> shapr, morning!!
00:25:46 <araujo> dcoutts, morning!
00:25:48 <dcoutts> good morning shapr!!
00:26:07 <dcoutts> good evening dons :-)
00:26:12 <Cale> The only problem with (++[x]) is that it copies the list backbone of whatever list it's applied to.
00:26:29 <Cale> (but that's unavoidable of course)
00:27:01 <dcoutts> Cale, only if you hold onto the old onw
00:27:10 <Cale> well, it should still do the copy
00:27:10 <Cale> (unless ghc is incredibly clever)
00:27:10 <dcoutts> but the old one can simultaniously be discarded
00:27:10 <Cale> right
00:27:11 <dcoutts> in this case that's not so bad anyway
00:27:41 <dcoutts> since it's a list of big chunks, and the chunks would be shared
00:27:41 <Cale> yep
00:28:12 <Cale> The major problem happens when someone does 10000 or so of those snocs
00:28:22 <dcoutts> yes
00:28:32 <dcoutts> but we do say the complexity
00:29:07 * shapr boings!
00:29:14 <dons> dcoutts: i found it worthwhile to actually test the laziness of things with the lazyio.hs program in tests/ . my first version of hGet wasn't lazy, and that quickly showed. also, i couldn't get a constant space length, yet.
00:29:38 <dons> i presume due to the intermediate list being built by map P.length
00:29:38 <shapr> dcoutts: Oh, I have a unicycle gig tomorrow! I'm going to ride around and show off for a bunch of little kiddies.
00:29:48 <dcoutts> dons, yes, I was thinking we should do some tests to demo the lazyness
00:30:39 <dons> yes, definitely. if you install h4sh, you can use the 'cycle' program to generate useful infinite streams to pipe into Lazy.hs functions.
00:30:46 <dcoutts> dons, eg things that do (take n (op ++ [undefined]))
00:30:52 <dons> ie. cycle f.hs | ./lazy-test
00:31:13 <dons> ah , yes. that's another thing. need to check strictness on accumulators in ByteString.hs itself
00:31:16 <dcoutts> dons, so we should be able to demonstrate the strictness without needing large datasets
00:31:45 <dons> good idea!
00:32:21 <dcoutts> in fact the may be something we want to include in the documentation: complexity, strictness
00:32:48 <dons> right. i started adding "This function is /lazy/" to the comments. but a more thorough approach is a good idea.
00:33:04 <dons> to the comments on the io functions.
00:36:52 <dons> dcoutts: possibly we should just grab the strictness annotation from the -ddump-simpl output.
00:37:06 * dons tries this out.
00:37:09 <kzm> dons: tests/Lazy.hs - I get an error?
00:37:17 <dcoutts> dons, I'd like to try the analytical approach
00:37:21 <kzm> Lazy.hs:267:31:
00:37:22 <kzm>     Couldn't match `Int' against `GHC.Int.Int64'
00:37:22 <dcoutts> kzm, just fixing that...
00:37:27 <kzm> Okay.
00:37:28 <dons> oh, oops. my fault.
00:37:32 <dcoutts> fromIntegral (length ...)
00:37:55 <dcoutts> to convert Int -> Int64 so we can compare with the length of a lazy bytestring
00:38:11 <kzm> do you (dons) aggregate dcoutts's repo?  (So I only need to pull from you?)
00:38:30 <dons> kzm, i think so.
00:38:40 <dons> dcoutts: that's right, yes? all your patches are getting to me?
00:39:01 * dcoutts darcs sends to dons
00:39:05 <dcoutts> done
00:39:10 <dons> kzm, but during the day, while i'm asleep, you might need to pull some things from dcoutts.
00:39:21 <dons> got it.
00:39:41 <kzm> okay.  it probably will do no harm, anyway.
00:39:52 <dons> its great that mutt let s me apply mailed patches by hitting 'A'
00:40:23 <kzm> About the QC module - the unfoldr test tends to fail on encodings.
00:40:41 <kzm> IIUC, it is because it depends on the wrapping behaviour of Char8
00:41:20 <dons> oh. hmm. please do investigate.
00:41:20 <kzm> Is that correct?
00:42:03 <kzm> Well -it's a bit compact, but as far as I can tell, it picks an arbitrary character, and generates the next 100 characters.
00:43:23 <kzm> hmm..perhaps I'll just add a filter is_valid in there.
00:47:07 <dons> dcoutts: now, if you run 'make sbench2' ghc will compile the Lazy.hs file with -O, and if you watch the output carefully, there's some array fusion happening.. very interesting, no?
00:47:18 <dons> i should investigate further what's getting fused.
00:47:33 <dcoutts> oh, nice
00:47:38 <dcoutts> not just list fusion
00:48:04 <dons> right. so something's getting exposed such that the fusion rule fires.
00:49:00 <dcoutts> yes, it would be interesting to see what list function is causing array fusion opportunities
00:49:08 <shapr> Cale: ping? I have a newbie collaboration idea
00:49:42 <dons> dcoutts: ah, the Core knows all!
00:49:44 <dons>  Str: DmdType LLLLL]
00:49:45 <dons> Data.ByteString.$whPut
00:49:47 <dons> :)
00:49:54 <dons> L == lazy :)
00:50:05 <Cale> shapr: hm?
00:50:08 * dcoutts doesn't grok
00:50:24 <shapr> Cale: What about Daan's http://www.equational.org/darcs-server/ for newbie collab?
00:50:26 <dons> oh, DmdType is a core note on the strictness or not of a function argument.
00:50:33 <dons> in this case, hPut, when compiled, is fully lazy
00:50:40 <shapr> If it there were an open server where you could put or commit to any repo, for example.
00:50:50 <dcoutts> dons, so LLLLL] ?
00:50:54 <dons> so i can walk over the Core, and check everythings' lazy in its argument.
00:50:56 <dcoutts> L is lazy, LLLL = ?
00:51:01 <dons> when compiled it takes 5 args, 
00:51:05 <dcoutts> ah ok
00:51:10 <shapr> It'd be the ultimate paste site, with proper backups and better offline editing, and better syntax highlighting using your own editor.
00:51:11 <dons> the length of the bytestring and so on all get unwrapped
00:51:17 <dcoutts> nice
00:51:27 <Cale> shapr: that would be quite nice
00:51:55 <Cale> shapr: does darcs-server have online editing too?
00:51:58 <shapr> In fact, you'd get some emulation of shared editing if you hooked RSS feed changes up to a darcs pull script.
00:52:35 <Cale> If it was to be used as a paste site, you'd want probably also want online editing for convenience.
00:52:39 <shapr> True
00:52:56 <shapr> The great advantage of darcs-server is pure http usage, imho
00:53:16 <kzm> how can I check the value of a CPP macro using #if?
00:53:22 <shapr> Newbies and win32 users often don't have mail setup, and mail has unpredictable lag times as well.
00:54:03 <Cale> yeah
00:54:04 <dons> dcoutts, e.g.  Str: DmdType LL]
00:54:04 <dons> Data.ByteString.Lazy.snoc
00:54:17 <shapr> You'd also get optional paste announcements if lambdabot could monitor the darcs repos :-)
00:54:34 <dons> if it was running on the same box, lambdabot could do that, yes.
00:54:43 <dons> you'd just have a pastebot instance of lambdabto running
00:54:51 <dons> it would only need the darcs patch plugin loaded
00:56:00 <shapr> Only downsides I can think of is the possibility of spamming. Anything else?
00:56:03 <dcoutts> dons, sed 's/e//g' longer than 10 min! wow
00:56:12 <dons> yeah, way too slow. 
00:56:17 <dons> strange, eh?
00:56:28 <shapr> RSS polling for repo changes could slow down the server too?
00:56:35 <dons> since even lazy [Char] beats sed.
00:56:41 <dcoutts> heh
00:56:50 <dons> what we need a lazy buffer C program. but that's too much work :}
00:57:00 <dcoutts> dons, I wonder what a tuned C prog would be for be filter e case
00:57:05 <dcoutts> right
00:57:08 <kzm> dons did you try grep -c?
00:57:15 <kzm> (vs. count)
00:57:44 <dcoutts> dons, I think sed works on lines, that might explain it
00:57:57 <dons> kzm, grep -c. ah, like wc -l
00:58:07 <dons> yeah, its a small chunk size, effectively
00:58:12 <dons> and its using regex operators
00:58:21 <shapr> You'd get vaguely shared editing if the users had editor bindings for record, push, and pull.
00:58:21 <dons> kzm, i should check this..
00:59:01 <dons> kzm, haskell wc-l ,0.016s, grep -c , 0.022s
00:59:02 <shapr> Cale: Any more points? Online editing is a good one, I'll think about that.
00:59:12 <dons> real wc -l, 0.015s
00:59:55 <shapr> Gutentag ProfTeggy 
01:00:44 <Cale> I'm not sure what else would be good at the moment actually, but it sounds like a cool idea
01:01:12 * kzm is impressed by the numbers.
01:02:14 <Cale> an online and safe version of ghci would be neat, but probably way too much trouble
01:03:28 <dons> kzm, after the shootout experience, i'm not that surprised any more :)
01:03:40 <shapr> Pass state explicitly and only run one persistent process?
01:05:08 <shapr> Now, who do I ask to point paste.haskell.org to my server? ScannedInAvian.org was too successful for its own good.
01:07:54 <shapr> Oh, license! Do you think it would be legal to have a big statement saying "By pasting code here, you agree to license it under the BSD3 unless otherwise specified in the file." ? That way we wouldn't have the problem of finding nifty code on the PastePage and not being able to use it.
01:13:20 <kzm> dons, I ended up just commenting out the unfoldr test.  It doesn't make sense unless you have a direct mapping with wraparound, I think.
01:13:41 <kzm> that is, it is #ifdef'ed out if you specify ENCODING, if not you get normal Char8 tests.
01:18:02 <dons> ah, ok.
01:19:51 <dcoutts> dons, and we need to check the inariant at point in the QC checks
01:20:15 <dcoutts> dons, I can now reliably fail the split test by inserting subtle bugs
01:20:26 <dcoutts> which makes me feel much better
01:20:34 <dcoutts> prop_split c = equals (map L.unpack . map invariant' . L.split c)
01:20:34 <dcoutts>                       (map P.unpack . P.split c . P.pack . L.unpack)
01:21:15 <dcoutts> dons, I quite like the (.) style of test using: equals f g xs = f xs == g xs
01:25:17 <dcoutts> dons, btw, the comment on split in ByteString is wrong
01:25:29 <dcoutts> split 'a'  "aXaXaXa"    == ["","X","X","X"]
01:25:39 <dcoutts> it should be  == ["","X","X","X",""]
01:25:44 <dcoutts> I think
01:26:07 <dcoutts> so either the code or the comment is wrong
01:26:39 <dcoutts> I'd prefer the comment to be wrong. I think the code gives a more sensible answer.
01:30:44 <Lokadin> @hoogle FilePath -> Boolean
01:30:45 <lambdabot> No matches, try a more general search
01:30:54 <Lokadin> @hoogle FilePath -> Bool
01:30:54 <lambdabot> Distribution.Compat.FilePath.isAbsolutePath :: FilePath -> Bool
01:30:54 <lambdabot> Distribution.Compat.FilePath.isRootedPath :: FilePath -> Bool
01:30:54 <lambdabot> Distribution.Simple.Utils.matchesDescFile :: FilePath -> Bool
01:35:13 <dons> dcoutts: ah good. so changing the Arbitrary instance did the trick?
01:35:26 <dons> (the other solution was to run more tests, like n=1000)
01:35:33 <dcoutts> dons, that and checking the invariant in the QC test
01:35:48 <dons> ah good.
01:35:56 <dcoutts> dons, without checking the invariant I could only detect one introduced bug out of 4
01:36:33 <dcoutts> because many operations are insensitive to the invariant, eg unpack
01:36:46 <dcoutts> so you wouldn't notice much of the time
01:39:52 <dons> ok. so you're adding prop_foo_I =  invariant (foo) tests?
01:40:24 <dcoutts> well just adding invariant into existing one would be ok no?
01:40:33 <dcoutts> -- In a form more useful for QC testing
01:40:34 <dcoutts> invariant' :: L.ByteString -> L.ByteString
01:40:34 <dcoutts> invariant' lps | invariant lps = lps
01:40:34 <dcoutts>                | otherwise     = error ("invariant violation: " ++ show lps)
01:40:44 <dcoutts> then using:  foo . invariant' . bar
01:40:48 <dons> ah, yes. that's reasonable. good idea.
01:41:20 <dons> you should think up a name for this invariant
01:41:29 <dons> the Duncan Property, or something ;)
01:41:55 <dcoutts> not just  the "Lazy ByteString invariant" ? ;-)
01:42:01 <dons> (joke earlier in the day about why maths guys always name everything after themselves)
01:42:23 <dcoutts> what was the punchline?
01:42:46 <dons> oh, we just commented on it, and why don't we have 'Moggi Cycles' or such like.
01:43:30 <dcoutts> I think it was more normal for other people to name it after the discoverer/inventer
01:44:02 <dcoutts> I had a FP lecture one using the example of "Meertens numbers"
01:44:04 <dons> true, but in cse we don't even do that very often. we give the thing a useful name. like 'quicksort' or Data.Map
01:44:30 <dcoutts> turned out that Meerten was just a friend of the lecturer :-)
01:44:35 <dons> ha
01:45:12 <dcoutts> (I'm probably spelling that wrong, it's a Dutch name)
01:46:00 <dcoutts> dons, but we figured that when you're the head of the department you can do that kind of thing :-)
01:46:15 <dons> hehe
01:58:50 <kzm> I have a small darcs problem, that I am unsure how to handle.
01:59:25 <kzm> darcs resolve tells me I have a conflict.  If I do the merge, I can't record it because it is 'no changes'.
01:59:28 <kzm> So - now what?
01:59:55 <kzm> Any way to tell which patches are conflicting?
01:59:56 <Lokadin> is Distribution.Compat.FilePath located in any special package? cause i can't seem to import it, ghc tells me it can't find module
02:00:38 <Lemmih> @where FilePath
02:00:38 <Lokadin> er, i'm using it through cabal, and i do have base 
02:00:39 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath
02:01:00 <Lokadin> oh it's a package afterall?
02:03:02 <Lokadin> say, where do i have to put the compiled .a file?
02:03:12 <Lokadin> or o..
02:03:26 <Lemmih> 'runhaskell Setup.lhs install' will do that for you.
02:03:32 <Lokadin> oh thanks :)
02:18:40 * dcoutts darcs sends more patches to dons
02:18:55 <dcoutts> all QC tests currently pass
02:19:16 <dcoutts> but I'm only checking the invaraint in one of them
02:22:29 <Lokadin> say, how do i use hoogle outside of irc?
02:22:40 <eivuokko> haskell.org/hoogle
02:22:54 <Lokadin> thanks :)
02:24:18 <norpan> wow
02:30:55 <Lokadin> why can't i do when (isAbsolutePath maybePath) (return $ Just $ maybePath)
02:31:22 <Lokadin> it says, Couldn't match `()' against `Maybe FilePath' Expected type: m () Inferred type: m (Maybe FilePath)
02:31:52 <Lokadin> would i have to put it into an if statement?
02:32:38 <Saulzar> Consider what happens when the condition is false, it must return () 
02:32:41 <Saulzar> @type when
02:32:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:33:06 <Lokadin> oh
02:33:11 <Lokadin> yea, that makes sense
02:34:45 <Lokadin> say, there is no elif keyword is there? it's just else and another if statement?
02:34:48 <Saulzar> Yeah if is a good substitute.. 
02:36:03 <Lemmih> Lokadin: You can also do: case () of () | cond1 -> ... | cond2 -> ... | otherwise -> ...
02:37:15 <Lokadin> oh really? kk i'll try that
02:38:05 <dons> Cale: great. cheers
02:38:08 <dons> ?karma+ dcoutts
02:38:08 <lambdabot> dcoutts's karma raised to 12.
02:39:07 <dons> s/Cale/dcoutts/
02:39:27 <Lokadin> lol, it seemed a lil random at first
02:40:01 <dons> missed the 'd', hit 'c' then 'tab' and irssi did  the rest.
02:40:04 <norpan> karma whores
02:40:18 <Lokadin> lol
02:40:20 <dons> also helps that I wasn't looking at the screen. should look at what I'm typing.
02:40:26 <dons> norpan: well, if you send in patches...
02:40:31 <norpan> i'm only envious of course
02:40:48 <dons> you too can be my karma bitch :)
02:42:25 <dons> ?karma+ norpan --tireless hacking away on UTF8 support.
02:42:25 <lambdabot> norpan's karma raised to 2.
02:43:49 <norpan> wow inspirational
02:43:57 <Lokadin> Lemmih: what would be the proper indentantion of that? i'm getting all these parse errors
02:44:04 <norpan> just because of that i'll take my computer with me this weekend
02:44:07 <norpan> and hack
02:44:11 <dons> yay!
02:45:44 <dons> dcoutts: all tests pass here too. great.
02:51:04 <xerox> 'morning
02:53:01 <dcoutts_> dons, good good
02:53:36 <dcoutts_> dons, so I was slightly hazy with the QC tests, how were doing them in general. Are we comparing to the ByteString versions or to the List versions?
02:53:52 <Lokadin> > case () of { | True -> putStrLn "hello"}
02:53:53 <lambdabot>  parse error on input `|'
02:53:56 <dcoutts_> they looked slightly ad-hoc to me
02:54:20 <dcoutts_> > case () of () | True -> putStrLn "hello"
02:54:21 <lambdabot> No IO allowed
02:54:32 <dcoutts_> > case () of () | True -> "hello"
02:54:34 <lambdabot> "hello"
02:54:37 <norpan> dcoutts_: i pulled your changes and all tests work for me too (tests/Lazy.hs)
02:54:45 <dcoutts_> norpan, great
02:54:46 <Lokadin> dcoutts_:  :) thanks
02:56:48 <Lokadin> say how can i split that into two lines? it keeps telling me i have an indentation problem
02:56:58 <dcoutts_> dons, so we need to write some more things like wc -l using .Lazy and see how they compare
02:57:06 <dcoutts_> Lokadin, like so:
02:57:10 <dcoutts_> case () of
02:57:17 <dcoutts_>   () | blah -> ...
02:57:21 <Lokadin> kk thanks :)
02:57:23 <dcoutts_>      | foo -> ...
02:57:27 <Lokadin> o
02:58:23 <dcoutts_> dons, are there many shootout benchmarks that need lots of IO?
02:58:37 <dcoutts_> or rather, streamed IO
02:58:59 <dons> dcoutts_: i think we should be comparing against both models.
02:59:23 <dons> so, currently, bytestring compares against list, lazy uses bytestring and compares against list
02:59:30 <dcoutts_> dons, seperate QC properties comparing against List & against ByteString you mean
03:00:05 <dcoutts_> some have no List equivalents, what about split?
03:00:16 <dons> unless there's a proof that says if Byte == List, and Lazy == List, then Byte == Lazy.
03:00:41 <dcoutts_> yeah, comparing against both is good
03:00:50 <dcoutts_> rather than relying on trasativity
03:00:54 <dons> right.
03:01:11 <dons> relying on the tests for Byte to be also correct.
03:01:30 <dcoutts_> I suppose in the cases where there is no List equiv it'd be best to write one - a simple spec-like one
03:01:44 <dons> yep.
03:01:54 <dons> i've done that previously for Byte, check Quick.hs for those.
03:02:00 <dcoutts_> ok
03:02:07 <dons> usually simple  to translate the Quick.hs ones to Lazy.hs
03:02:21 <dcoutts_> seems to me that since we're comparing to List or ByteString ones that the tests could be more regular
03:02:33 <dcoutts_> perhaps we need more type classes :-)
03:02:54 <dons> ah yes. so instantiate the tests for both Byte and Lazy ?
03:03:00 <dcoutts_> prop_foo = compare List.foo ByteString.foo
03:03:15 <dcoutts_> prop_foo' = compare ByteString.foo ByteString.Lazy.foo
03:04:08 <dons> so to be convinced of the coverage, we need to make it the structure a bit clearer, you mean?
03:04:15 <dcoutts_> right
03:04:21 <dons> have tests grouped, and so on.
03:04:42 <dcoutts_> but I mean particularly to cope with the different types of functions, we should be able to do that in a regular manner
03:04:53 <dons> yeah, it seems a typeclassable thing.
03:05:01 <dcoutts_> eg with instances for (->) [] ByteString etc
03:05:29 <dcoutts_> it'd all overlap I guess, but that's ok for testing
03:06:02 --- mode: ChanServ set +o shapr
03:06:28 --- mode: shapr set -b *!*@.ipt.aol.com
03:06:53 --- mode: shapr set -b *!*@*.ipt.aol.com
03:13:55 * mgoetze wonders where the 38% who answered "Yes, but not in Amsterdam" want to meet
03:17:52 <mgoetze> so anyway, say i have an Array with an index type of (Int,Int)... what's the most convenient type to extract lists (1,1..n), (2,1..n), etc.?
03:24:22 <mgoetze> also, why does ghci have a parse error on "newtype Board = Array (Int,Int) Intersection"?
03:24:44 <xerox> Because you can't define types on the GHCi prompt.
03:24:57 <mgoetze> yeah but it's in a file i'm trying to load
03:25:01 <xerox> Just write them in a module, :load it, and :reload when necessary.
03:25:09 <xerox> Uh-oh.
03:25:14 <xerox> Right!
03:25:23 <mgoetze> Compiling AlphaBeta        ( alphabeta.hs, interpreted )
03:25:23 <mgoetze> alphabeta.hs:5: parse error on input `Intersection'
03:25:25 <xerox> It misses a Data Constructor for the newtype.
03:25:43 <dons> moeits not a valid newtype.
03:25:46 <xerox> The syntax is the same as Data, except you can have only one parameter.
03:25:51 <dons> sorry, again my tab didn't complete. 
03:26:04 <dons> newtype Board = Board (Array (Int,Int))
03:26:16 <xerox> That is: newtype <TypeCon> = <DataCon> <Type>
03:26:24 <dons> or if you just want a type synonym, then use 'type'
03:26:36 <mgoetze> alphabeta.hs:5: Type constructor or class not in scope: `Array'
03:26:38 <dons> but its not going to give you a new type distinct from the Array type.
03:26:40 <mgoetze> oh, duh
03:26:43 <mgoetze> need to import
03:26:49 <dons> that too :)
03:27:29 <mgoetze> sigh... not quite awake yet
03:27:56 <mgoetze> ok, so back to my problem of extracting array slices as lists....
03:29:22 <mgoetze> nevermind pattern-matching this ugly construct
03:32:08 <mgoetze> can i get the bounds of an array in a pattern match?
03:32:32 <dons> hmm, call 'bounds' ?
03:33:16 <mgoetze> ok, so otherwise, no ;)
03:33:56 <dons> i don't understand the question.
03:34:03 <dons> what do you mean' get it in a pattern match'?
03:34:06 <dons> > let s = array (0,10) (zip [0..10] (repeat 'x')) in case bounds s of (a,b) -> (a,b
03:34:06 <lambdabot>  parse error (possibly incorrect indentation)
03:34:09 <dons> > let s = array (0,10) (zip [0..10] (repeat 'x')) in case bounds s of (a,b) -> (a,b)
03:34:10 <lambdabot> (0,10)
03:34:43 <dons> > let s = array (0,10) (zip [0..10] (repeat 'x')) in s
03:34:44 <lambdabot> array (0,10) [(0,'x'),(1,'x'),(2,'x'),(3,'x'),(4,'x'),(5,'x'),(6,'x'),(7,'x'),(8,'x'),(9,'x'),(10,'x')]
03:36:11 <dons> > array (minBound,maxBound) (zip [0..] (repeat ())
03:36:11 <lambdabot>  parse error on input `}'
03:36:16 <dons> > array (minBound,maxBound) (zip [0..] (repeat ()))
03:36:16 <lambdabot> Add a type signature
03:36:24 <dons> > array (minBound,maxBound) (zip [0..] (repeat ())) :: Array Int ()
03:36:24 <lambdabot> internal error: evacuate: strange closure type 37792
03:36:24 <lambdabot>   Please report this as a bug to glasgow-haskell-bugs@haskell.org,
03:36:24 <lambdabot>   or http://www.sourceforge.net/projects/ghc/
03:36:28 <dons> !
03:37:05 <kzm> new lambdabot functionality: automatically report errors!
03:37:05 <xerox> O_o
03:37:09 <mgoetze> sorry, was on the phone
03:37:23 <dons> no problem, just crashing haskell for you.
03:37:28 <xerox> dons is crazy.
03:38:10 <dons> ok, that's still in 6.4.2 even. let's check the head.
03:38:37 <dons> $ ./a.out 
03:38:39 <dons> zsh: segmentation fault (core dumped)  ./a.out
03:38:44 <dons> fun fun in the sun.
03:39:03 <dons> i thought this was fixed.
03:39:06 <dcoutts_> Data.Array> array (minBound,maxBound) (zip [0..] (repeat ())) :: Array Int ()
03:39:06 <dcoutts_> array Segmentation fault
03:39:08 <dcoutts_> same for me
03:39:14 <dcoutts_> 6.4.2 on amd64 linux
03:39:20 <dons> yeah, i get it for 6.4.1, .2 and 6.5
03:39:31 <mgoetze> my array will have some bounds like ((1,1),(n,m)), i was just wondering whether i can grab the n and m right out of my pattern
03:39:32 <dons> i'm certain this has been reported and fixed back in 6.2 days.
03:39:51 * dons files a bug report anyway
03:41:13 <mgoetze> on 6.0.1 i get array <interactive>: internal error: scavenge_one: strange object 708
03:41:35 <dons> old compiler :)
03:41:55 <dons> musasabi: didn't you spot this bug once?
03:41:59 <mgoetze> good enough for me :)
03:42:12 <ProfTeggy> internal error: evacuate: strange closure type 426
03:42:27 <dons> its a different closure type every time :)
03:42:32 <ProfTeggy> heh
03:49:00 <mgoetze> i need an unlistArray function :(
03:49:02 <Saulzar> I got similar kinds of things when I used hs plugins with old plugins and a new program by mistake
03:50:03 <dons> oh bad Saulzar. that's super evil.
03:50:18 <dons> ?karma+ Saulzar for being super evil with plugins
03:50:19 <lambdabot> Saulzar's karma raised to 1.
03:53:58 <Saulzar> Yes, I noticed that was not a good idea :)
03:55:00 <mgoetze> ah! ixmap is what i need
03:55:45 <mgoetze> well, kinda, it doesn't make a list of it but at least it gives me the array splice i want
03:56:15 <mgoetze> then elems on that... hm hm
04:00:35 <kzm> one BS thing - should I try to merge the different QuickCheck modules?
04:01:25 <dcoutts_> kzm, I'm working on something related
04:01:37 <kzm> They contain mostly the same stuff, but there are examples of tests that are in one but not the others.
04:01:39 <kzm> Not so good.
04:02:01 <dcoutts_> I'm trying to make a more abstract & reusable presentation of the tests
04:02:07 <kzm> I'm pretty happy about how Quick.hs handles all the single-byte encodings.
04:02:18 * kzm hurries to push the latest patches.
04:02:40 * dcoutts_ gets out his commutable diagrams foo
04:06:39 <kzm> is there a way to make the build depend on the #included files as well?
04:06:44 <kzm> ghc --make-depend? :-)
04:07:41 <Lokadin> is String just syntax-sugar for [Char] ?
04:07:49 <kzm> yes.
04:07:57 <Lokadin> kk :) thanks
04:09:47 <kzm> dcoutts_, did you have the conflicting patch in your repo?
04:10:00 <dcoutts_> kzm, nope
04:10:03 <Lokadin> is it generally better to use, non IO, function or IO functions, or does it not matter?
04:10:19 <dcoutts_> Lokadin, non-IO is usually preferable
04:10:33 <dcoutts_> try and keep the IO parts of your program as small as possible
04:10:34 <Lokadin> kk
04:11:01 <dcoutts_> don't let IO 'infect' your whole program or you lose much of the advantages of pure functional prorgamming
04:11:36 <Lokadin> lol
04:12:48 * Lokadin goes and quickly starts taking apart all his IO functions
04:18:42 <kzm> dcoutts_, okay - I've renamed my repo from fps-i18n back to fps, to avoid confusion.
04:18:57 <kolmodin> @seen waern
04:18:57 <lambdabot> I saw waern leaving #haskell 1 day, 15 hours, 22 minutes and 21 seconds ago, and .
04:21:40 <shapr> Hey, I want to hear what you guys have to say about my soc-mentors post I just sent!
04:21:50 * dcoutts_ reads
04:22:53 <Lokadin> say, i have a function that executes any shell command and pastes the output to the terminal, does it have to be type IO () ?
04:23:11 <shapr> dcoutts_: Are Gstreamer or DBus useful on windows?
04:23:31 <shapr> I haven't used windows in so long I don't actually know.
04:23:40 <dcoutts_> shapr, GStreamer works on windows I think, let me check DBus...
04:24:21 <dcoutts_> I know DBus works at least on all unix-like OSs, let me see about win32..
04:24:30 <mauke> Lokadin: no, it could be IO Int, for example
04:24:54 <Lokadin> mauke: i meant, can it be a non IO
04:25:02 <mauke> I don't think so
04:25:16 <Lokadin> mauke: kk just checking :) thanks
04:26:16 <resiak> unsafePerformIO! *hides*
04:27:08 * shapr suggests anatomically impossible acts to Plone
04:27:11 <norpan> Lokadin: it can be non-io if you accept that it perhaps won't read the file and output to the terminal :)
04:27:39 <Lokadin> lol
04:28:01 <dcoutts_> shapr, it looks like the main gnome/win32 guy was porting it
04:28:09 <norpan> which is what will happen if you unsafePerformIO an IO ()
04:28:15 <dcoutts_> but it may not be functional yet
04:28:20 <shapr> hah
04:28:22 <shapr> punny
04:29:06 <dcoutts_> ;-)
04:29:39 <dcoutts_> shapr, there are gnomy programs that Novell want to port to win32 that use dbus I think, so it'll get ported too eventually I think
04:29:54 <shapr> Ok, that's good to hear.
04:30:10 <dcoutts_> shapr, so I'd say that it's about as portable as most other gtkish stuff
04:31:45 <dcoutts_> shapr, btw, I like your raking system
04:31:51 <dcoutts_> raking/ranking
04:32:15 <norpan> raking indeed :)
04:32:38 <Lokadin> at what point should i start spliting my program into modules?
04:33:02 <norpan> Lokadin: when you have stuff that is logically separated
04:33:35 <Lokadin> hmmm
04:33:51 <shapr> dcoutts_: I'm sure I've left out some criteria, I hope someone replies with a few more.
04:36:26 <xerox> mentors++!
04:39:20 <nibro> xerox: oh, who have you managed to snare? :-)
04:39:44 <xerox> err, karma+ mentors, that is :-)
04:40:31 <nibro> ah, I thought that was an update of the number...
04:42:30 <eivuokko> I hate Distribution.Compat, so messy preprocessor stuff - impossible to hack safely without having relevant compilers (ghc 6.2,6.4,6.5, nhc and hugs)
04:50:01 <Lokadin> can i have a case statement in a let or where?
04:50:27 <mauke> it's a case expression, not a case statement
04:50:34 <xerox> You can have a case expression wherever you want
04:50:46 <Lokadin> oh
04:50:47 <xerox> That is, where you could put an expression (-:
04:50:54 <mauke> aw :(
04:51:04 <tromp> > x where x = let a = case () of () -> 0 in a
04:51:06 <lambdabot> 0
04:52:10 <xerox> @pl \f n -> case f n of x -> x
04:52:11 <lambdabot> (line 1, column 23):
04:52:11 <lambdabot> unexpected ">" or "-"
04:52:11 <lambdabot> expecting variable, "(", operator or end of input
04:52:28 <Lokadin> i wonder why it's not working for me..
04:52:35 <Lokadin> hmmm
04:52:35 <xerox> Paste it!
04:53:35 <lisppaste2> Lokadin pasted " parse error on input `->'" at http://paste.lisp.org/display/19929
04:56:39 <Lokadin> say, would it be better, er, "standard"? if i used path and path' instead of maybePath and createdPath ?
04:57:34 <Lokadin> respectivley
04:58:52 <norpan> Lokadin: you are missing a )
04:59:21 <Lokadin> norpan: thanks :)
04:59:24 <norpan> exactly where it complains about the parse error
04:59:40 <norpan> i suppose, even if you don't give a position
05:00:48 <Lokadin> yea, but thanks anyways 
05:00:49 <Lokadin> :)
05:03:06 <Lokadin> hmmm, would it be better to use where in that case statement perhaps? because it doesn't have to be evaluated if the first case statement is true. or does let not force evaluation of createdPath
05:03:27 <Lokadin> er am i confused about the laziness
05:11:44 <alar> @seen reductor
05:11:44 <lambdabot> I haven't seen reductor.
05:14:54 <Lokadin> what is haskellwiki powered by?
05:19:37 <shapr> Lokadin: MediaWiki
05:19:44 <Lokadin> cool
05:21:59 <norpan> Lokadin: let does not force evaluation
05:22:13 <norpan> nothing does in haskell except for the seq operator
05:22:37 <norpan> of course pattern matching forces it and so on, but that's a different issue
05:22:45 <norpan> in fact even let pattern matching is lazy
05:22:53 <norpan> am i making sense?
05:23:11 <Lokadin> so if the first case is found to be true and createdPath is never needed, then it will never be created?
05:23:34 <norpan> exactly
05:23:40 <Lokadin> alright :)
05:23:54 <xerox> dcoutts: do you have a link for nymphaea used as schoolproject?
05:24:30 <dcoutts_> xerox, only on the gtk2hs site, nothing on the Oxford public web pages.
05:24:46 <xerox> Oh, I see.
05:24:53 <dcoutts_> xerox, what were you looking for exactly?
05:25:07 <xerox> dcoutts_: something "official" to proove what I was saying :-)
05:25:13 * dcoutts_ looks
05:25:28 <xerox> *hug*
05:26:14 <dcoutts_> http://web.comlab.ox.ac.uk/oucl/courses/topics05-06/fp/
05:26:23 <dcoutts_> that doensn't say much
05:26:45 <dcoutts_> because it was written before I'd finnished writing the 2nd practical :-)
05:27:10 <xerox> : D
05:27:28 <xerox> The other page with pictures was meant to remain internal right?
05:27:30 <dcoutts_> xerox, I can provide proof on demand of course, I just can't publish the practical description
05:27:42 <xerox> Right.
05:27:56 <dcoutts_> right, but I could email it someone if necessary
05:28:32 <dcoutts_> this is probably the best that is public:
05:28:33 <dcoutts_> http://haskell.org/gtk2hs/archives/2005/11/01/university-courses-using-gtk2hs-for-teaching/
05:30:05 <dcoutts_> and if you compare the pic on that page to your cairo pics
05:30:06 <dcoutts_> http://www.haskell.org/gtk2hs/gallery/Cairo-demo
05:30:14 <dcoutts_> you'll notice a remarkable similarity :-)
05:30:33 <xerox> Yup.  That will work.
05:31:10 <dcoutts_> xerox, though note that the oxford pic isn't using cairo because we couldn't get cairo installed on our solaris 9 boxes
05:31:18 <dcoutts_> so it's using gdk
05:31:21 <xerox> I do remember, yes
05:31:34 <dcoutts_> but the l-system stuff is obviously derived from yours
05:31:49 <olliej> anyone know how encodeFloat is implemented
05:31:56 <olliej> ?
05:32:05 <xerox> @index encodeFloat
05:32:05 <lambdabot> Prelude
05:32:16 <xerox> "Internally" :-)
05:32:23 <olliej> well, actually __encodeFloat
05:32:30 <olliej> the c function that does it
05:32:40 <xerox> Scrap GHC sources?
05:32:48 <olliej> hmmm
05:32:50 <olliej> probably best bet
05:40:01 <olliej> ick... i refuse to believe that what it does is particularly accurate
05:41:39 <eivuokko> Hmm
05:42:07 <good_boy> Hi, I have a [String] list. how do i use "compare" so that the function returns True when a String entered as an argument to the function is located in the list?
05:42:12 <eivuokko> If I recall correctly, it has bit-struct and takes float apart by peeking into that.
05:42:21 <eivuokko> (in c-code)
05:42:32 <good_boy> or who can recommend me a good haskell tutorial?
05:42:41 <mgoetze> good_boy: you're looking for the elem function, methinks
05:43:15 <Saulzar> good_boy, Yet another haskell tutorial is pretty good
05:43:17 <mgoetze> good_boy: actually, are you sure you mean compare and not, say, filter
05:43:19 <Saulzar> @where yaht
05:43:19 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
05:43:45 <mgoetze> (because compare doesn't return a Bool)
05:43:45 <good_boy> hm, compare is all we have used so far...
05:44:11 <mauke> > elem "bar" ["foo","bar","baz"]
05:44:13 <lambdabot> True
05:45:41 <mgoetze> good_boy: maybe you should give us a broader picture of what you're trying to do
05:47:37 <mgoetze> @index fromJust
05:47:37 <lambdabot> Data.Maybe
05:48:03 <good_boy> i am writing this program for my class. we have to enter a word as an argument to a function and the function should split it in strings of a predefined length. The splitted word is returned as a String list from the function. Now I dont want duplicate entries in this string list so I'm trying to figure out a way how to do this. 
05:48:33 * Lokadin has realized that he has been trying to unsuccessfully do what Directory could have done for him days ago
05:48:41 <mauke> > List.nub ["foo","bar","bar","baz","foo"]
05:48:43 <lambdabot> ["foo","bar","baz"]
05:49:13 <mgoetze> good_boy: uh, but it sounds like you're supposed to keep the duplicates
05:49:49 <good_boy> No.
05:50:00 <mgoetze> good_boy: for instance, if your split length is 2, do you want "gogogirls" to end up as ["go","go","gi","rl","s"] or ["go","gi","rl","s"]?
05:50:19 <good_boy> ["go","gi","rl","s"]
05:50:36 <mauke> @hoogle Int -> [a] -> [[a]]
05:50:37 <lambdabot> No matches, try a more general search
05:51:03 <mgoetze> good_boy: well, that's weird, but yes, you want nub
05:51:27 <good_boy> maybe i should write a function myself for this, but i thought i might use compare, the solution would have been much more elegant.
05:51:42 <good_boy> im not allowed to use List.nub since we havent treated it...
05:52:18 <Lokadin> say, how can i quit a case expression
05:52:28 <mgoetze> nub is easy enough to write yourself (nevermind that you could look up how it's defined in the prelude)
05:52:44 <Lokadin> nm
05:55:12 <mauke> I wish I knew how to quit case
05:55:44 <Lokadin> mauke: are you being sarcastic?
05:56:06 <mauke> borderline nonsensical maybe
05:57:15 <audreyt> to quit a case expression, use the "error" function
05:57:20 <Saulzar> Lokadin, a case must have some value, you can use a structure which provides a "nothing" though..
05:57:36 <azuroth> just wondering...
05:57:44 <azuroth> is there an uhm, natural number type?
05:57:46 <audreyt> case x of _|error "" -> neverReached
05:58:02 <Lokadin> well my case restarts the current function unless i quit with :q
05:58:14 <audreyt> azuroth: data Nat = Z | S Nat ?
05:58:16 <mauke> data Nat = Zero | Succ Nat
05:58:22 <mgoetze> azuroth: they're debating whether to include one in haskell prime
05:58:33 <Lokadin> so i figured return () would be fine to exit the case statement
05:58:46 <audreyt> Lokadin: nod
05:58:59 <azuroth> ah, okay. isn't that a bit... suboptimal for most cases?
05:59:19 <Saulzar> azuroth, Yes, there's no builtin natural
05:59:20 <audreyt> you can use Word
05:59:26 <audreyt> but it's not the same thing
05:59:44 <audreyt> there is no "Wordeger"
05:59:56 <mgoetze> you can also define a natural number type based on Integer, but it's a bit more complicated
06:00:18 <azuroth> ah yeah, I probably shouldn't've used natural number, and uint instead
06:00:23 <mgoetze> (i.e. you'll need an instance Num Natural where....)
06:01:06 <Saulzar> mgoetze, But it can't be enforced, you can always create invalid numbers
06:01:21 <audreyt> no, you just guard against that in fromInteger.
06:01:23 <Saulzar> Hmm, I guess you can if you limit the options
06:02:00 <mgoetze> Saulzar: you can prevent it, but actually it doesn't matter, since they are isomorphic
06:02:31 <Saulzar> Isomorphic to what? Natural numbers and Integers?
06:03:09 <mgoetze> well, as sets, not as groups (since natural numbers aren't a group)
06:03:34 <xerox> audreyt: the guard should error or abs the value?
06:03:41 <audreyt> xerox: yes.
06:04:21 <mauke> haha, fromInteger i = 2 * abs i - fromEnum (i < 0)
06:04:26 <musasabi> dons: yes, I think I hae gotten "evacuate: strange closure type <something>" with profiling + concurrency.
06:04:30 <audreyt> (as in, "yes, it should.")
06:04:40 <musasabi> (but no time to talk at the moment, meetings + work)
06:04:50 <pejo> mgoetze, that non-group, is it the sometimes lacking 0?
06:04:58 <mgoetze> you could even represent the natural numbers internally using both positive and negative integers, but then there goes your efficiency again
06:05:14 <mgoetze> pejo: there's no inverse element
06:05:17 <audreyt> "I must not attend meetings.  Meetings are the mind killer. Meetings are the little-death that brings total obliteration. I will face my meeting. I will permit it to pass over me and through me. And when it has gone past I will turn the inner eye to see its path. Where the wasted time has gone there will be nothing. Only I will remain."
06:05:22 <mgoetze> pejo: (even if you define them as including 0)
06:05:23 <xerox> mauke: heh.
06:05:51 <pejo> mgoetze, hah, ok, now I've made a fool out of myself for today. :-)
06:06:01 <mgoetze> pejo: np ;)
06:09:49 <BCoppens> Itkovian: OT question: do you know when davy gets back?
06:10:12 <Itkovian> He's sitting next to me with his new MacBook Pro :-)
06:10:20 <Itkovian> any questions you want me to ask him?
06:10:24 <BCoppens> oh
06:10:39 <BCoppens> Itkovian: has he gotten my mail with my prolog stuff ;)
06:10:45 <BCoppens> because I didn't get any confirmation
06:11:49 <Itkovian> he's got it, but he'll reply when the most students have submitted their stuff
06:11:54 <Itkovian> so now worries
06:11:59 <BCoppens> aah ok =)
06:12:09 <BCoppens> thanks :)
06:12:30 <Itkovian> np
06:12:43 <mgoetze> how do i get the opposite effect of map ((,) 'x') [1,2,3] ; that is i want 'x' to be snd, not fst?
06:13:14 <Itkovian> mgoetze: map (x `,`) ?
06:13:30 <Itkovian> > map ('x' `,`) [1,2,3]
06:13:30 <lambdabot>  parse error on input `,'
06:13:41 <Itkovian> @type (,)
06:13:43 <lambdabot> forall b a. a -> b -> (a, b)
06:13:53 <Itkovian> hmm
06:14:07 <Itkovian> > map (\x -> ('x',x)) [1,2,3]
06:14:08 <lambdabot> [('x',1),('x',2),('x',3)]
06:14:12 <Saulzar> > flip (,) 1 2
06:14:13 <lambdabot> (2,1)
06:14:15 <Itkovian> and thus
06:14:27 <mgoetze> hm... well i think i can do it with a list comprehension, anyway
06:14:33 <Itkovian> > map (\x -> (x,'x')) [1,2,3]
06:14:34 <lambdabot> [(1,'x'),(2,'x'),(3,'x')]
06:14:40 <mgoetze> ok, thanks
06:14:57 <Itkovian> a list comprehension would do just fine too
06:16:01 <xerox> > map (id &&& const 'x') [1,2,3,4]
06:16:02 <lambdabot> [(1,'x'),(2,'x'),(3,'x'),(4,'x')]
06:16:48 <mgoetze> hm, the funny thing about writing haskell is, no matter how complicated the task is going to be, it always ends up being just a little bit of code (after splitting into suitable subtasks)
06:16:50 <Saulzar> The heavyweight solution :)
06:33:56 * dcoutts_ bludgeons ByteString.Lazy quick check tests with -fallow-undecidable-instances
06:35:23 <mux> > [ (x,'x') | x <- [1..4] ]
06:35:24 <lambdabot> [(1,'x'),(2,'x'),(3,'x'),(4,'x')]
06:40:13 <dcoutts_> @localtime dons
06:40:14 <lambdabot> Local time for dons is Fri May 12 23:35:55 2006
06:40:32 * dcoutts_ wished dons were about
06:41:15 <xerox> What's happening?
06:49:06 <kzm> @rub dons's lamp
06:49:06 <lambdabot> Unknown command, try @list
06:49:18 <jip> hello haskell
06:53:28 <JKnecht> hi jip
06:54:19 <jip> do records and tuples have identical performance characteristics?
06:55:29 <Saulzar> Tuples are always lazy, record elements can be made strict (I think that's about it)
06:55:37 <Pupeno> Hello.
06:55:38 <Pupeno> [OT] Turning a raw (binary) stream into a structure (taking about dns messages or almost anything) is called parsing; am I right ?
06:55:52 <ADEpt> right
06:56:02 <Saulzar> For example representing a vector as (Double, Double) is not as fast as Vector !Double !Double - if you don't need the laziness
06:56:29 <mathewm> or unmarshalling
06:56:41 <Pupeno> How is it called the oposite procedure, turning a parsed piece of information in the form of a structure to be sent thru a socket or similar ?
06:56:54 <mathewm> marshalling
06:56:59 <Pupeno> well, marshalling if I call teh first one unmarshalling.
06:57:11 <ADEpt> unparsing, serialization
06:57:23 <mathewm> rb ( -shaled |?m?r??ld|, -shaling |?m?r?(?)l??|; chiefly Brit. -shalled, -shalling) [ trans. ]
06:57:26 <mathewm> 1 arrange or assemble (a group of people, esp. soldiers) in order 
06:58:22 <jip> Vector Double Double will produce identical results as (Double, Double)?
06:59:25 <Saulzar> Yeah
06:59:35 <shapr> darcs kicks serious butt :-)
06:59:40 * shapr boings cheerfully
07:00:52 <mathewm> are there emacs modules for darcs?
07:01:00 <dons> dcoutts?
07:01:08 <dcoutts_> dons, ah
07:01:21 <dcoutts_> dons, so I've got a cunning type class system
07:01:30 * shapr just ran 'darcs tag help' like a numbskull :-|
07:01:35 <dcoutts_> for comparing ByteString to [Word8]
07:01:44 <dcoutts_> ByteString.Lazy to [Word8]
07:01:49 <shapr> mathewm: yes, several
07:01:53 <dcoutts_> and ByteString.Lazy to ByteString
07:01:54 <ADEpt> mathewm: there were half year ago
07:02:08 <shapr> doh -> % darcs tag help \n Finished tagging patch 'TAG help'
07:02:12 <dons> ah, cunning, eh? how cunning?
07:02:18 <mathewm> How about eclipse plugins... 
07:02:21 <dcoutts_> dons, it means you can write things like:
07:02:25 <dcoutts_> prop_cons   = compare2 L.cons   P.cons
07:02:26 <shapr> mathewm: I think there's at least one.
07:02:40 <dons> ah! that looks very nice.
07:03:16 <dcoutts_> dons, yep. The types get tricker for the more complex examples, but it's generally good
07:03:27 <dcoutts_> in places we need to add explicit types
07:03:35 <dons> oh, that's ok. 
07:03:39 <dons> cool. 
07:03:52 <dcoutts_> eg: prop_concat     = compare1 L.concat    (concat    :: [[Word8]] -> [Word8])
07:04:18 <dons> oh, right. yep.
07:04:42 <ADEpt> what is this you are talking about? :)
07:04:49 <dcoutts_> but we can do those once and use them for both the ByteString & ByteString.Lazy
07:05:06 <dcoutts_> eg: concat = List.concat :: [[Word8]] -> [Word8]
07:05:12 <dons> ADEpt: QuickCheck checks for the lazy bytestring we're hackign on.
07:05:25 <ADEpt> dons: any darcs repo?
07:05:27 <dcoutts_> prop_concatL = compare1 L.concat concat
07:05:32 <dcoutts_> prop_concatP = compare1 P.concat concat
07:05:36 <dons> ADEpt, yeah, its in the fps head .
07:05:38 <dons> ?where fps
07:05:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:05:50 * ADEpt pulls
07:05:52 <mathewm> In a lazy language, do continuations still have value?
07:05:55 <dons> dcoutts_: looks very nice. so half as much code to write?
07:06:05 <dons> mathewm: well, we just fake them with laziness
07:06:10 <dcoutts_> dons, something like that yeah
07:06:58 <araujo> Hello!
07:07:13 <dcoutts_> hi araujo 
07:07:24 <araujo> dcoutts_!
07:07:27 <dcoutts_> araujo!!!
07:07:38 <araujo> :-)
07:09:41 <dons> do we have someone to write the SoC entry for HCAR?
07:09:58 <araujo> hello dons 
07:10:02 <dons> i have a few things to write for it, so i'm happy to add one more to the list.
07:10:09 <araujo> @localtime dons 
07:10:11 <lambdabot> Local time for dons is Sat May 13 00:05:51 2006
07:10:24 <dons> :)
07:10:26 <araujo> :-)
07:10:27 <dcoutts_> dons, fine with me, paerhaps check with xerox 
07:10:52 <dons> xerox: you writing a SoC entry for HCAR?
07:11:03 <xerox> Err HCAR?
07:11:22 <dons> community and activities report.
07:11:27 <xerox> Ah!
07:11:34 <xerox> I'm not doing it, but it is a good idea!
07:11:41 <dcoutts_> ok dons :-)
07:11:41 <dons> kosmikus asked about it on the mailing list.
07:12:13 <xerox> http://haskell.org/communities/
07:12:14 <dons> to wit: For this issue, I would propose that someone writes a summary of
07:12:14 <dons> haskell.org's SoC participation (please!), which could possibly
07:12:15 <dons> include a list of the accepted projects
07:12:34 <dons> well, i'm not sure we'll be able to do that.
07:12:47 <xerox> Hm, I think I can do it
07:12:52 <dons> but we can at least say something about how the process is going. i.e. the number of applications.
07:13:01 <dons> and the mentors and so on.
07:13:02 <xerox> Yeah!
07:13:11 <dons> ok. please write it up then :)
07:13:16 <xerox> Well, if you are about to it, I think it's okay if you do it
07:13:25 <dons> no, i'm about to go to bed :)
07:13:31 <xerox> Ah :-)
07:13:34 <araujo> :-)
07:13:37 <xerox> Hmm.
07:13:40 * araujo thinks it'd be nice
07:13:48 <dons> just check the deadline. its the 15th or so?
07:13:50 <xerox> What would it be a template of such a description?
07:14:05 <xerox> Yes, 15th
07:14:19 * xerox reads previous editions
07:14:27 <dons> check novemeber's entries. basically describe what the whole SoC story is, what it is for, how it helps haskell. and then an update on the current state.
07:14:46 <dons> i.e. we received blah blah applications, currently in the process of reviewing 
07:15:00 <mathewm> what is SoC?
07:15:00 <xerox> Right.
07:15:07 <xerox> http://code.google.com/soc/
07:15:21 <mathewm> oh, that
07:15:58 <xerox> Check the topic too :-)
07:16:53 <kosmikus> the HCAR is very informal. a very short entry with a link to further information would already be better than nothing.
07:17:10 <mathewm> funny how, with a little reading, one can answer their own questions...
07:17:31 <xerox> Wow, HCAR is cool nevertheless.
07:17:40 <xerox> How many projects!
07:18:07 <kosmikus> xerox: if you're not mentioned in the HCAR, you don't exist ;)
07:18:13 <xerox> hehe.
07:18:24 <xerox> I didn't knof of HCAR in fact until... now O_o
07:20:25 <the_lord> Hi!
07:20:38 <the_lord> how do 
07:21:27 <dons> xerox should read the mailing lists...
07:21:41 <azuroth> I'm good thanks, the_lord
07:21:55 <xerox> If only I could setup a proper mail account somewhere )-:
07:23:04 <the_lord> how do I concatenate actions?
07:23:18 <ADEpt> the_lord: which actions?
07:23:21 <mathewm> It seems to me that Haskell is a very dynamic language...
07:23:31 <mathewm> code examples from a year ago don't work today
07:23:34 <the_lord> I have this function a -> b
07:23:37 <mathewm> that makes me sad :(
07:23:55 <dons> kosmikus: we had 112 haskell project submissions. kind of stunning, don't you think. that's what... $4500*112 haskell dollars :)
07:24:06 <the_lord> I want to receive the a, print something and then return the b
07:24:09 <xerox> Yay.
07:24:19 <azuroth> really, mathewm? that's crazy
07:24:32 <mathewm> well, I guess they are more than a year old...
07:24:47 <mathewm> My Schools of Expression experience was poor
07:24:52 <dons> mathewm: that's strange. they're not written in H98?
07:24:52 <dons> nothing has changed much in that time. the apis are pretty stable.
07:25:07 <ADEpt> the_lord: have you read some tutorial?
07:25:19 <dons> if you write in H98 expect them to run in 10 years time. my code from 1999 still compiles.
07:25:19 <Igloo> dons: How many unique students?
07:25:23 <the_lord> :(
07:25:35 <mathewm> these seem out of date: http://www.nomaware.com/monads/html/examples.html
07:25:37 <ADEpt> the_lord: somef = do a <- getLine; putStrLn "aaaa"; return b
07:25:49 <kosmikus> dons: that's very promising at least
07:26:07 <the_lord> thx
07:26:15 <dons> hmm. somewhat less. 90 or so, Igloo.
07:26:50 <xerox> (Yes, we can't accept more than one proposal per student.)
07:26:58 <ADEpt> Igloo: 69
07:27:13 <dons> and anyway, google sponsers something less than 10%
07:27:24 <ADEpt> dons: that's why I assembled that file :)
07:27:26 <xerox> :-\
07:27:26 <dons> dependign on the quality, of course.
07:27:46 <xerox> Either way, we're doing better than last year.
07:27:49 <xerox> (-;
07:27:52 <dcoutts_> much better
07:27:55 <dons> indeed. much better.
07:28:38 <dcoutts_> shapr, I agree that we need to get as many distinct mentors signed up with projects since that should maxmimise our overall allocation
07:29:04 <dons> right.
07:29:26 <ADEpt> in short, we need more mentors
07:29:28 * xerox agrees too
07:29:37 <xerox> Where could we find more?
07:29:42 <dcoutts_> do we know exactly how many we've got signed up currently?
07:29:47 <dcoutts_> shapr, you know right?
07:30:19 <xerox> And maybe, what kind of projects are they going to be mentoring?  Better to ask people who is possibly interested on the topic.
07:30:26 <dcoutts_> of course
07:30:40 <ADEpt> dcoutts_: 13 active
07:30:52 <dcoutts_> what does active mean?
07:31:02 <xerox> "Seen on the ml" perhaps?
07:31:13 <ADEpt> dcoutts: taken an application of SOC site
07:31:19 <dcoutts_> I want to know how many actually have signed up with google
07:31:33 <xerox> dcoutts_: mail on the soc-mentors and Isaac could answer
07:31:34 <ADEpt> dcoutts_: then, "at least 13" :)
07:31:41 <dcoutts_> ADEpt, heh, right.
07:31:44 <xerox> dcoutts_: I think he has a comprehensive view on hin administering console
07:32:06 <dcoutts_> xerox, yes we;ll ask SyntaxNinja when he next appears
07:32:12 <dcoutts_> @seen SyntaxNinja
07:32:12 <lambdabot> I saw SyntaxNinja leaving #haskell 14 hours, 4 minutes and 53 seconds ago, and .
07:34:54 <dcoutts_> dons, for ByteString.Char8.lazy, surely it can be implemented as: split (c2w '\n')
07:35:15 <dons> .lazy ?
07:35:16 <dons> lines you mean?
07:35:24 <dcoutts_> err yeah, lines
07:35:40 <dons> doesn't tokens end up calling lines?
07:35:54 <dons> or is it splitWith
07:36:13 <dons> ah, it doesn't use tokens.
07:36:22 <dons> quite possibly, quite possible. try it out.
07:36:53 <dons> yeah, it looks like 'split' doesn't it.
07:37:22 <dcoutts_> dons, right. tokens would delete empty lines
07:37:30 <dons> oh. hmm.
07:37:50 <shapr> dcoutts_: How many mentors? yes.
07:38:20 <good_boy> what does fromIntegral do?
07:38:30 <dons> ?type fromIntegral
07:38:31 <lambdabot> forall b a. (Num b, Integral a) => a -> b
07:38:31 <dcoutts_> shapr, I thought you were one of the admins for "haskell.org" as a SoC mentoring organisation. so you could see the list of mentors who've signed up?
07:38:38 <shapr> dcoutts_: Yes, I'm an admin.
07:38:43 <shapr> You want the full list?
07:38:47 <dons> we have about 20 mentors
07:38:56 <dcoutts_> shapr, well just the count would do
07:39:04 <dons> didn't I mail the list the number?
07:39:10 <ADEpt> shapr: i want a full list. in email or in msg
07:39:13 <dcoutts_> shapr, but at some point we need to poke the ones who've been quiet so far.
07:39:24 <shapr> Yeah, true.
07:39:27 <dons> some point == now.
07:39:31 <dcoutts_> right
07:39:31 <shapr> hah, yes!
07:39:35 <ADEpt> yep. that's why i want a full list :)
07:39:49 <dcoutts_> shapr, we want them to take on a project, even if they think it's iffy.
07:40:10 <dons> i'd like around 30 with mentors signed up. maybe 40 would be good too.
07:40:14 <dcoutts_> shapr, becaus we want to maximise the number of applications we can reasonably accept
07:40:35 <ADEpt> not sure if this strategy will fly :)
07:40:46 <dcoutts_> shapr, that way if it's something like we get allocated half the number of projects we propose to accept...
07:41:17 <dons> they want to see how organised we are. having mentors ready to go will certainly help.
07:41:43 <dcoutts_> shapr, eg suppose we have 20 mentors and between them we accept 30 applications, that should boot out chances of getting the top 15 accpeted.
07:41:47 <shapr> hmm
07:41:55 <xerox> Evil.
07:42:00 <shapr> We have 19 mentors exactly, and one unconfirmed.
07:42:01 <dcoutts_> Cunning.
07:42:16 <shapr> SyntaxNinja has a duplicate entry somehow.
07:42:18 <xerox> shapr: bringert?
07:42:30 <ADEpt> xerox: already a mentro
07:42:31 <shapr> He's in and confirmed.
07:42:31 <dcoutts_> shapr, well he is important :-)
07:42:35 <shapr> heh, yes!
07:42:55 <xerox> (-:
07:43:08 <shapr> Who wants to contact Henrik Nilsson about being a Yampa mentor?
07:43:14 <shapr> Or has that already happened?
07:43:20 <xerox> I didn't contact him
07:43:21 <dcoutts_> shapr, is Malcolm signed up?
07:43:33 <dcoutts_> eg for yhc stuff
07:43:34 <shapr> Nope
07:43:41 <dons> shapr, not happened. mail away. 
07:43:44 <xerox> dcoutts_: any news from ndm?
07:43:46 <pesco> shapr: That's me.
07:43:50 <shapr> dons: You just sent a mail, yeah?
07:43:51 <dcoutts_> @seen ndm
07:43:51 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 20 hours, 25 minutes and 57 seconds ago, and .
07:44:01 <shapr> pesco: Have you contacted Henrik Nilsson already?
07:44:03 <dcoutts_> ndm was going to poke Malcolm
07:44:13 <dcoutts_> to get him to look after a yhc project
07:44:15 <pesco> shapr: Oh, I misread what you said.
07:44:34 <dons> shapr: nope. i'm saying, feel free to mail him. i haven't. he's a nice guy, and he'll probably be happy to mentor . we just need to get him to sign in as a mentor.
07:44:35 <xerox> shapr: so are you going to mail the mentors?
07:44:36 <pesco> shapr: Yes, I had mailed with him.
07:44:45 <dons> pesco, ah. and any response?
07:44:50 <xerox> Ah!
07:45:06 <dons> telling him how to sign in as a mentor, perhaps?
07:45:10 <shapr> I'd rather assign ADEpt to be the official correspondent :-)
07:45:19 <Lokadin> why does hWaitForInput not wait?!! :'( 
07:45:33 <ADEpt> shapr: why me? :)
07:45:37 <xerox> I can do it.
07:45:43 <xerox> I did contact them all so far :-)
07:45:44 <pesco> dons: I'd asked him beforehand whether he wanted to mentor and he said yes, but wasn't sure about the process. I told him what I could tell from the mentor faq and pointed him to that as well as our trac.
07:45:54 <ADEpt> shapr: not that i'm shying away, but why not choose native english speaker? :)
07:45:59 <xerox> pesco: then just point him to the url
07:46:05 <xerox> pesco: Cc me if you want
07:46:28 <dons> ok. perhaps find the mentor sign in url, and prod. tell him he needs to sign in, and indicate he'll mentor for the project to get up.
07:46:28 <ADEpt> Lokadin: it waits for me :)
07:46:29 <pesco> dons: We couldn't tell though, how the mentor signin works. I told him to ask the admins and he said he'd mailed... Isaac Jones I think.
07:46:33 <lisppaste2> Lokadin pasted "hWaitForInput ALWAYS True" at http://paste.lisp.org/display/19934
07:46:33 <shapr> ADEpt: Because you're motivated and you've shown that by building the ods files?
07:46:49 <xerox> pesco: http://code.google.com/soc/mentor_step1.html
07:46:54 <shapr> But I don't care who contacts the mentors as long as someone does it.
07:46:56 <ADEpt> shapr: well then. I'll do :)
07:47:01 <Lokadin> ADEpt: it wait's :P but it lies!!!
07:47:16 <shapr> Who has more time and fewer other SoC responsibilities? ADEpt or xerox?
07:47:19 <ADEpt> Lokadin: ah. about that i'm not sure
07:47:23 <pesco> xerox: Ahoj, thanks. :)
07:47:26 <xerox> ADEpt!
07:47:28 <ADEpt> shapr: xerox :)
07:47:34 <xerox> )-:
07:47:35 <ADEpt> damn. he is fast :)
07:47:39 <xerox> ^_^
07:47:40 * shapr grins
07:47:43 <ADEpt> which means that he has more time
07:48:03 <shapr> xerox: Do you want to do it?
07:48:10 <xerox> shapr: it's okay
07:48:27 <shapr> Wait, xerox isn't a mentor, he can't tell who's been active on the soc-mentors list, can he?
07:48:38 <xerox> No, I can't.
07:48:41 <ADEpt> shapr: right
07:48:48 <Lokadin> say where do i find the logs for this room?
07:48:49 <ADEpt> shapr: i'm just kidding, e
07:48:51 <ADEpt> ll do that
07:48:56 <shapr> ADEpt: Cool, thanks :-)
07:48:58 <xerox> I think you're right in searching for a mentor to do it right now.
07:49:00 <Lokadin> @where log
07:49:00 <lambdabot> I know nothing about log.
07:49:06 <psi`> Lokadin: see topic
07:49:07 <dons> Lokadin: check the wiki page
07:49:12 <dons> ?wiki IRC_channel
07:49:12 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
07:49:20 <ADEpt> shapr: meanwhile. we need mentor(s) for atlas/matlab/llvm bindings
07:49:22 <dons> ?google #haskell logs
07:49:23 <lambdabot> http://tunes.org/~nef/logs/haskell/
07:49:24 <Lokadin> long topic kk
07:49:33 <Lokadin> thanks :)
07:51:15 <xerox> A mail on darcs-users: "...is there any Darcs GUI that nicely shows the differences?"
07:51:27 <shapr> :-)
07:52:37 <Beelsebob_> hmm... surely you just pipe the differing files into your favourite diff program?
07:54:46 <ADEpt> Beelsebob_: in emacs/ediff :)
07:54:54 <Beelsebob_> or for me... FileMerge
07:55:33 <shapr> I'm off to spend time with my gf, I'll be back on Sunday morning.
07:55:51 <Muad_Dib> hf shapr :)
07:56:29 <xerox> shapr!
07:57:48 <Lokadin> it's soo odd, hWaitForInput used to work for me.., but now it's always true
07:58:08 <shapr> xerox: yes?
07:58:18 <pesco> xerox: Okay, mailed Henrik Nilsson, but forgot to cc you. ;-)
07:58:35 <xerox> I was wondering wether we sould update the People page on the trac since I'm linking it in the HCAR tinghie
07:58:45 <xerox> s/thinghie/entry/
07:59:20 <shapr> kosmikus: Hey, could we request a submission deadline extension so we can get the SoC accepted projects into HC&AR? Or maybe we can just submit late?
07:59:22 <xerox> And since you have the proper list, maybe you could do it?
07:59:37 <shapr> xerox: I have to go right this minute, sorry.
07:59:41 <xerox> Np.
07:59:42 * shapr disappears
07:59:48 <xerox> ~~
07:59:54 <Muad_Dib> Luckily we have @get-shapr
08:00:00 <xerox> haha
08:00:25 <ADEpt> anyone seen on irc the following people:
08:00:27 <ADEpt> Alberto Ruiz Garca
08:00:27 <ADEpt> Johan Henriksson
08:00:27 <ADEpt> Jorge Miguel de Matos Sousa Pinto
08:00:27 <ADEpt> Simon Thompson
08:00:46 <xerox> Johan is mahogny
08:00:54 <xerox> I contacted the others via mails.
08:01:22 <ADEpt> xerox: regarding SOC?
08:01:28 <xerox> Sure.
08:01:38 <xerox> (Or was contacted, in certain cases.)
08:02:26 <ADEpt> xerox: long ago or just now?
08:02:30 <xerox> Long ago.
08:02:50 <ADEpt> ah, allrighty
08:03:20 <xerox> Those people didn't rank yet?
08:03:54 <ADEpt> xerox: will have to double-check it, but it seems that no
08:04:11 <ADEpt> xerox: at least, they haven't took any app for mentoring (on SOC site)
08:04:25 <xerox> ADEpt: could you check for the others too?
08:04:29 <xerox> http://hackage.haskell.org/trac/summer-of-code/wiki/People
08:04:51 <hyrax42> should one avoid backtracking in Parsec?
08:05:12 <hyrax42> and to what lengths should one go to do so
08:05:26 <eivuokko> Make code readable, optimise later.
08:05:26 <kosmikus> shapr: I could make an exception for the SoC article. I basically explain the situation in my mail to the Haskell mailing list.
08:05:50 <hyrax42> kk
08:06:14 <ADEpt> xerox: there is Igloo there, and he is not on SOC site yet
08:06:18 <ADEpt> ?seen Igloo
08:06:18 <lambdabot> Igloo is in #haskell-overflow and #haskell. I don't know when Igloo last spoke.
08:06:24 <ADEpt> Igloo: ping?
08:06:25 <xerox> ADEpt: yes, Igloo isn't a mentor
08:07:15 <hyrax42> how many projects do you expect to get funded?
08:07:18 <hyrax42> or no way to judge?
08:07:26 * hyrax42 thinking he should have applied...
08:07:48 <ADEpt> as student or as mentor?
08:07:54 <hyrax42> student
08:09:01 <xerox> ADEpt: found others?
08:09:06 <hyrax42> parsec is pretty nifty
08:09:11 <xerox> hyrax42: why didn't you!!
08:09:15 * xerox cries
08:09:24 <hyrax42> stupid reasons
08:09:45 <xerox> hyrax42: did you know it or it is the first time you come about it?
08:09:47 <hyrax42> I decided I'd rather spend the summer doing my own thing, learning-wise
08:10:04 <azuroth> I was going to, but it overlaps heaps with my diploma :-(
08:10:21 <hyrax42> I knew
08:10:24 <xerox> SoC *can* be your own thing.  Students are requested to apply for their own projects.
08:10:26 <ADEpt> xerox: on the SOC site there are 19 ppl, on the trac there are 20. Igloo is the difference
08:10:38 <xerox> Organization's projects are a guide.
08:10:55 <xerox> ADEpt: right.  So those four are the only ones which didn't rank yet?
08:11:15 <ADEpt> xerox: no, not only
08:11:53 <xerox> ADEpt: could you tell me the others?
08:12:07 <ADEpt> xerox: in 2 minutes :)
08:12:15 <xerox> Thank you very much (-:
08:12:52 <xerox> Maybe hyrax42, azuroth, have any ideas about how could I have gone in order to contact more students?
08:13:37 <hyrax42> I don't know
08:13:48 <hyrax42> I knew before h.org got its application in to be an org
08:14:02 <hyrax42> but it was a bit last minute
08:14:28 <hyrax42> but 90 apps is a pretty good return, I think?
08:14:56 <ADEpt> hyrax42: 112
08:15:05 <hyrax42> even better
08:15:20 * xerox is happy
08:15:38 <hyrax42> I'll definitley apply next summer though
08:16:21 <hyrax42> unless I end up doing big travelling holiday, I guess
08:19:31 <azuroth> tosses her head and flicks her hair, she got a whole bunch of nothing up there
08:28:43 <the_lord> I have this function boomBoom :: AlexPosn -> String -> Token
08:29:12 <the_lord> and this, boomBoom p s = print (extraerPos p)
08:29:30 <the_lord> what do I put after to return a Token?
08:30:01 <the_lord> the Token that I want to return is Boom p s
08:31:00 <davidhouse> the_lord, what exactly should boomBoom do?
08:32:05 <the_lord> receive an AlexPosn and a String, print "error in the position " ++ (extraerPos p)
08:32:13 <the_lord> and then return a Token
08:32:32 <the_lord> AlexPosn is a data type with 3 integers inside
08:32:47 <musasabi> evening
08:32:55 <davidhouse> do you know about monads, the_lord
08:32:56 <davidhouse> ?
08:33:08 <hyrax42> in Parsec
08:33:08 <tuxplorer> evening musasabi :)
08:33:19 <hyrax42> if you have two string parsers that have a common prefix
08:33:22 <the_lord> nop
08:33:39 <hyrax42> if the first fails, has it consumed input?
08:33:40 <the_lord> I've tried do print blah; return Boom p s
08:34:03 <the_lord> and ghci bring an error
08:34:13 <davidhouse> the_lord, your function will have to be of type AlexPosn -> String -> IO Token if you want to do IO (like printing to the screen)
08:34:43 <Igloo> the_lord: You probably mean   return $ Boom p s   or, equivalently,   return (Boom p s)
08:34:57 <the_lord> yes
08:34:59 <jip> why isn't MArray an instance of IArray?
08:35:06 <the_lord> IO Token?
08:35:48 <Igloo> jip: Because you can't use the pure functions on mutable arrays
08:36:24 <jip> Igloo: why not, just freeze the mutable array and then apply the pure function
08:36:41 <jip> Igloo: but if you could directly apply ! on a pure array then the implementation could be optimized
08:37:04 <Igloo> jip: Because when the array gets frozen matters
08:37:37 * Igloo doesn't understand the last line
08:37:56 <jip> i guess it doesn't really matter
08:38:15 <jip> anyways
08:38:22 <pesco> xerox: Just got an answer from H. Nilsson, he says Isaac already pointed him to the URL and he did sign up... Should I forward you the mail?
08:39:53 <ADEpt> Igloo: would you be the SOC mentor? you are on the trac, but you are not on the SOC site
08:40:31 <the_lord> nothing
08:41:03 <the_lord> where can I paste?
08:41:33 <musasabi> @lisp-paste
08:41:34 <lambdabot> Unknown command, try @list
08:41:45 <tuxplorer> http://paste.lisp.org/
08:41:47 <Igloo> ADEpt: I can't commit to spending time ATM
08:42:16 <ADEpt> Igloo: ok. noted :)
08:43:18 <lisppaste2> the_lord pasted "HELP" at http://paste.lisp.org/display/19937
08:43:37 <the_lord> please :S
08:43:45 <the_lord> it's alex code
08:45:49 <azuroth> alex code?
08:45:59 <tuxplorer> the_lord: what is that alexScanTokens type?
08:46:12 <the_lord> it's a function
08:46:13 <tuxplorer> doesnt matter tho.. just to know
08:46:36 <the_lord> it takes the string you pass and returns a [Token]
08:46:55 <the_lord> evaluating the regular expressions
08:48:27 <tuxplorer> the_lord: u want the lexer to get the [Token] ?
08:48:34 <the_lord> yep
08:48:38 <the_lord> in boomBoom
08:48:56 <the_lord> no no no
08:49:23 <the_lord> what I want is that boomBoom returns a Token
08:49:36 <the_lord> the Boom token actually
08:50:08 <jip> how do i putChar to stderr?
08:50:23 <kosmikus> jip: hPutChar
08:50:32 <kosmikus> @hoogle hPutChar
08:50:32 <lambdabot> IO.hPutChar :: Handle -> Char -> IO ()
08:50:42 <tuxplorer> the_lord: I too am a learner.. but will try..
08:52:35 <jip> kosmikus: what should i use for the Handle?
08:53:41 <the_lord> stderr
08:53:45 <kosmikus> @hoogle stderr
08:53:45 <lambdabot> IO.stderr :: Handle
08:54:10 <jip> thanks
08:54:37 <jip> how come when i switch one of my main datastructures to use strict fields, my program is slightly slower?
08:55:24 <kosmikus> why not? strictness is often confused with speed, but in fact, strictness can make a program both slower and faster, depending on the situation.
08:56:17 <jip> my structure is like: data A = A { x :: IORef Word8, y :: IORef Word8, z :: IORef Word8 }
08:56:25 <jip> but with about 20 fields like these
08:56:29 <tuxplorer> the_lord: wats the problem u face there?
08:57:14 <the_lord> haskell tells me I'm returning two types, t, t1
08:58:24 <tuxplorer> wat is the return type of extraerPos? Int or String?
08:59:18 <the_lord> Couldn't match `Token' against `t t1'
08:59:22 <the_lord> String
09:01:49 <jip> kosmikus: why would strictness slow this data down?
09:03:46 <hyrax42> is there a way to case-insensitively parse a string in Parsec?
09:04:01 <kosmikus> jip: I don't have enough info, and I have to go home now ...
09:04:02 <musasabi> jip: because it might evaluate too much and be very expensive.
09:04:13 <hyrax42> as in a case-insensitive equivalent of string :: String -> Parser String
09:04:35 <musasabi> jip: think about "head $ map veryExpensiveFunction veryLongList
09:05:14 <musasabi> hyrax42: "parse . map toLower" ?
09:05:43 <hyrax42> well I can't quite do that
09:05:45 <jip> musasabi: hm.... this might explain things
09:06:03 <hyrax42> scheme has that weird case-sensitive but case-transforming thing going for symbols
09:06:17 <hyrax42> actually that's not my problem here
09:06:38 <hyrax42> I want to parse chars : #\space and #\sPaCE both
09:07:03 <hyrax42> I could probably do it with some sort of list thingy that gives every combination of uppe and lower
09:07:33 <the_lord> :'(
09:07:36 <musasabi> jip: and in general many times there are long lists that are never fully evaluated but just traversed and discarded.
09:07:49 <ADEpt> hyrax42: Parsec.Language has similar feature
09:07:59 <hyrax42> yeah I saw
09:08:16 <hyrax42> I was wondering if it could be done lower down, as then I'd ahve to rewrite most of my parser so far
09:09:01 <jip> musasabi: i am using something like the "A" data structure i showed a few lines up
09:10:35 <musasabi> ah, the IORefs.
09:10:58 <musasabi> are you writing them in one go or separately?
09:11:56 <hyrax42> > [[n,e,w] | n <- "nN", e <- "eE", w <- "wW"]
09:11:57 <lambdabot> ["new","neW","nEw","nEW","New","NeW","NEw","NEW"]
09:12:01 <hyrax42> ugh
09:12:44 <hyrax42> haskell: rascal or hask-ell
09:12:48 <hyrax42> as far as stress
09:13:17 <jip> musasabi: seperately. i am guessing that non-strict is faster since when passing this structure to a function, laziness allows only passing the IORefs that the function actually uses instead of passing all of them
09:13:37 <musasabi> jip: laziness is better also for GC effects.
09:14:23 <musasabi> jip: i.e. if some of them are modified quite rarely they get to the old generation and need not be traversed on each minor collection.
09:14:47 <the_lord> ok, no one here know how to do more than one action in a function and then return something?
09:14:57 <jip> musasabi: is it possible to hint to the GC that all these IORefs should be GCed together?
09:15:43 <dcoutts_> jip, put them all together in one structure
09:16:24 <jip> dcoutts: how do i do that?
09:16:53 <dcoutts_> by structure I meant a list or something
09:17:06 <Igloo> jip: IIUC then lazy won't be better for the reason you give as only a pointer to the structure will be passed anyway
09:17:10 <dcoutts_> assuming there's a variable number of them
09:17:43 <Igloo> I'd be surprised if lazy was better for you, and not surprised if strict was better
09:18:37 <jip> Igloo: i was hoping that just a pointer of the structure would be passed, but apparently it's not so
09:19:16 <musasabi> Usually there are three choices 1) lazy, 2) strict, 3) unpack. Try all and benchmark. It depends on the usage which one is the winner.
09:19:20 <jip> Igloo: in addition to a bunch of IORefs, "A" also has 2 Array fields
09:19:26 <jip> musasabi: what is unpack?
09:19:31 <Igloo> jip: Huh?
09:20:05 <azuroth> dot product...
09:20:25 <musasabi> jip: {-# UNPACK GHC pragma.
09:20:36 <jip> data A = A { x :: IORef Word8, y :: IORef Word8, z :: UArray Int Word8, m :: Array Int (IOUArray Int Word8) }
09:20:51 <mux> is there a way to get back the kind of an expression in GHCi?
09:21:06 <azuroth> :kind ?
09:21:44 <mux> hah, thanks :-)
09:21:46 <mux> missed it
09:23:27 <tuxplorer> mux: :t
09:23:33 <tuxplorer> u meant type right?
09:23:40 <mux> no, I meant kind
09:23:54 <mux> and I've been answered already :-P
09:24:01 <tuxplorer> oh!
09:25:17 <tuxplorer> mux: wats that kind for? can u give me some links to learn abt it?
09:25:37 <mux> I heard about it in some tutorial
09:25:39 <mux> let me look
09:26:17 <wilx> Isn't kind the * -> * thing?
09:26:58 <mux> yes
09:27:06 <mux> tuxplorer: yet another haskell tutorial talks about kinds
09:27:22 <mux> tuxplorer: you can find it from haskell.org
09:27:35 <tuxplorer> mux: oh! k.
09:27:50 <tuxplorer> mux:  I'm in the 95th page while kind comes in 126th :)
09:27:59 <tuxplorer> sorry 115th
09:28:38 <tuxplorer> mux: thanx
09:28:40 <mux> yeah, 115 in the tutorial but 127th page in the pdf :)
09:28:46 <tuxplorer> yup
09:29:58 <mux> I found it quite useful to know that Monads are always of kind * -> *
09:34:13 <xerox> tuxplorer: kinds are types of types.
09:34:58 <xerox> tuxplorer: complete types have kind *, can you imagine something that takes a type * and returns a type * ? (* -> *)
09:35:48 <tuxplorer> xerox: oh! but where would they be useful?
09:36:03 * tuxplorer shd first read about kinds in YAHT :)
09:36:14 <xerox> tuxplorer: what kind has the list type constructor [] ?
09:38:04 <hyrax42> no answers?
09:38:16 <hyrax42> is haskell pronounced like rascal or with stress hask-ell
09:38:41 <xerox> hyrax42: Haskell is the name of Haskell B. Curry (not sure about the B.)
09:38:51 <hyrax42> aye
09:38:53 <araujo> Brooks?
09:39:01 <hyrax42> but I don't know how to pronounce his name
09:39:10 <xerox> tuxplorer: [] takes an 'a' and returns [a], right?
09:39:20 <tuxplorer> xerox: yup. thats the type na?
09:39:21 <hyrax42> or that of th language named for him
09:39:38 <xerox> tuxplorer: the point is that [] isn't a type, but something that takes a type and returns a type.
09:40:00 <xerox> tuxplorer: hence kinds, Int :: *, [] :: * -> *, [Int] :: *
09:40:32 <tuxplorer> oh! but a or [a] arent types!!
09:40:43 <xerox> tuxplorer: sure they are!
09:41:00 <xerox> tuxplorer: forall (a :: *). a is all the types.
09:41:05 <tuxplorer> oops! ya
09:41:21 <tuxplorer> now i understand.. 
09:41:22 <xerox> forall (a :: *). [a] is also all the list types.
09:41:33 <xerox> [] is a type constructor that takes a type and returns a type.
09:41:35 <xerox> Great :-)
09:41:43 <tuxplorer> thanks xerox
09:41:51 <tuxplorer> :)
09:41:52 <xerox> You're welcome.
09:42:27 <mux> funny how this little thing really helped me understanding monads
09:43:21 <tuxplorer> mux: i'll ask u abt it when i come to monads.. plz tell me how u used it then.. :)
09:44:07 <xerox> What about monads?
09:44:14 <mux> it cleared some spots that I couldn't quite grasp, that is why the list and maybe types were monads while the state monad is a "function type"
09:44:56 <work_metaperl> what is the most direct way to call Haskell functions from Perl
09:45:16 * tuxplorer dreams how it'll be if some cosmic rays would impart haskell into his brain cells ;)
09:45:24 <work_metaperl> lol
09:45:31 <xerox> mux: ah-ha
09:45:59 <hyrax42> this monad business is sort of strange
09:46:04 <the_lord> anyone here knows how to do more than one action in a function and then return something?
09:46:07 <mux> xerox: am I not making sense?
09:46:19 <xerox> mux: no, I think I see what you mean (-:
09:46:24 <mux> the_lord: well with a do contrust or with >> and >>= bindings
09:46:36 <mux> xerox: ah, cool :-) quite hard to explain with words :p
09:46:57 <the_lord> mux, can you give me a sample?
09:47:10 <hyrax42> tuxplorer: when you come to monads, be sure to read Cale's Monads as Containers on the wiki
09:47:11 <mux> sure
09:47:13 <xerox> mux: that is, the type part of the monad is a type constructor, not a function.
09:47:24 <mux> foo = getLine >>= putStrLN
09:47:25 <hyrax42> helped me a good deal
09:47:35 <mux> xerox: yeah
09:47:35 <hyrax42> except I was coming ot monads before most of the rest of hte language
09:47:57 <tuxplorer> hyrax42: ok. thanks for that.. i'll be to monads by tomorrow morning.. :) hope u guys will be around..
09:47:58 <mux> I've been grumbling about monads during long, eating all the wadler papers and tutorials I could find
09:47:58 <xerox> the_lord: >>= feeds the result of the preceding action in the next one, >> discards it and sequences only.
09:48:08 <mux> and with time understanding fell into my mind
09:48:16 <mux> it helps to sleep :-)
09:48:18 <mux> and to shower :-)
09:48:21 <hyrax42> anyone: is (anyChar >>= return . return)) confusing?
09:48:25 <mux> I have great illuminations during showers.
09:48:27 <hyrax42> one is in List, other in Parser
09:48:31 <hyrax42> and bind is in Parser
09:48:33 <xerox> hyrax42: liftM return anyChar
09:48:52 <hyrax42> ooh
09:48:54 * hyrax42 tries
09:49:11 <xerox> @pl \f xs -> xs >>= return . f
09:49:11 <lambdabot> fmap
09:49:17 <xerox> @pl liftM
09:49:18 <lambdabot> fmap
09:49:26 <the_lord> yes, but my action is to print something and then call a constructor
09:49:49 <mux> can you paste some code on the paste site?
09:49:51 <xerox> the_lord: could you give us a more detailed explanation, or code?
09:50:21 <the_lord> it's alex
09:51:34 <xerox> Hi Alex!
09:51:35 <xerox> :-P
09:52:26 <lisppaste2> the_lord pasted "see boomBoom" at http://paste.lisp.org/display/19941
09:52:35 <the_lord> :S
09:52:49 <the_lord> I have hours fighting with the code
09:53:29 <the_lord> with boomBoom p s = Boom p s it works
09:53:29 <xerox> The 'lexer' looks right.
09:54:04 <the_lord> but before returning Boom p s I want to print that there was an error
09:54:27 <mux> print?
09:54:29 <mux> heh
09:54:31 <the_lord> how do I do?
09:54:40 <mux> yet another people who'll end up writing ParsecT ?
09:54:46 <xerox> the_lord: ah!
09:55:28 <the_lord> xerox, ah! what?
09:55:36 <xerox> the_lord: it is better to not do IO where it isn't needed
09:55:43 <xerox> That is, split up your code differently
09:55:58 <work_metaperl> CosmicRay: ping
09:56:01 <the_lord> but it is needed, I'm getting evaluated
09:56:06 <the_lord> :S
09:56:20 <xerox> the_lord: that print looks like debugging
09:56:21 <work_metaperl> CosmicRay: the spaces were left out of my code submission: http://sequence.complete.org/node/181
09:56:22 <the_lord> you mean construct the list and then serach for the errors?
09:56:24 <mux> woops
09:56:33 <the_lord> *search
09:56:38 <xerox> Doing debug like that means you have to globally transform your program
09:58:19 <xerox> the_lord: I'm not used to Alex, but what's your aim?
09:59:21 <the_lord> alex is a lexical analyser, then you move the results to happy that's a syntactical analyser and then you interpret or compile your language
09:59:30 <the_lord> I'm writing a language
09:59:41 <the_lord> It's an assignment
10:00:17 <dcoutts_> g'evening SyntaxNinja
10:00:35 <xerox> Howdy!
10:00:37 <mux> if you really really need to print errors at that point, use the integrated stuff in Parsec to generate the proper error messages
10:00:57 <SyntaxNinja> jheya
10:00:59 <xerox> mux: he isn't using Parsec, sigh )-:
10:01:03 <mux> oops
10:01:11 * mux blushes
10:01:14 <SyntaxNinja> every time I log in I have to close 5 tabs
10:01:17 <SyntaxNinja> so annoying
10:03:40 <xerox> Why?
10:06:41 <Oeje1> Notifications from the server?
10:09:24 <ADEpt> SyntaxNinja:
10:09:33 <ADEpt> xerox: you are Paolo Martini, right?
10:10:01 <xerox> Yes!
10:10:15 <xerox> /WHOIS
10:10:32 <SyntaxNinja> Oeje1: yeah.
10:10:39 <SyntaxNinja> ADEpt: yes, xerox he is paolo
10:11:07 <ADEpt> xerox: whois is not working for me
10:11:17 <ADEpt> xerox: why you are not on the trac?
10:12:20 <xerox> I got in at the very last moment
10:13:13 <xerox> Nobody were willing to do Cabal, and I think it has to be done
10:13:55 <work_metaperl> how do I turn a file into a list of strings, one string per line?
10:14:08 <xerox> work_metaperl: readFile and lines 
10:14:25 <Lemmih> @type fmap lines . readFile
10:14:25 <xerox> @type (lines =<<) . readFile
10:14:26 <work_metaperl> xerox: thanks
10:14:26 <lambdabot>   Couldn't match `[String]' against `IO String'
10:14:26 <lambdabot>   Expected type: FilePath -> [String]
10:14:27 <lambdabot> FilePath -> IO [String]
10:14:40 <xerox> Err, right.
10:17:13 <xerox> Have you read about the GHC Hackaton?  Wee!
10:17:27 <work_metaperl> xerox: that is a bit too succinct for me... I dont understand the "." after (lines =<<)   and also I dont know what =<< does... is that a reverse of bind?
10:17:48 <xerox> @type \filename -> fmap lines (readFile filename)
10:17:49 <lambdabot> FilePath
10:17:49 <lambdabot>                 -> IO [String]
10:18:06 <mux> @type liftM lines readFIle
10:18:07 <lambdabot> Not in scope: `readFIle'
10:18:10 <mux> @type liftM lines readFile
10:18:12 <lambdabot>   Couldn't match `String' against `IO String'
10:18:12 <lambdabot>   Expected type: FilePath -> String
10:18:12 <work_metaperl> @type fmap
10:18:13 <lambdabot> forall (f :: * -> *) b a.
10:18:14 <lambdabot>    (Functor f) =>
10:18:14 <lambdabot>    (a -> b) -> f a -> f b
10:18:32 <work_metaperl> @type lines
10:18:33 <lambdabot> String -> [String]
10:18:36 <mux> @type liftM lines . readFile
10:18:37 <lambdabot> FilePath -> IO [String]
10:19:01 <xerox> > typeOf (((return . lines) =<<) . readFile) == typeOf (fmap lines . readFile)
10:19:02 <lambdabot> True
10:19:13 <xerox> @pl \f xs -> xs >>= return . f
10:19:13 <lambdabot> fmap
10:19:22 <work_metaperl> ok, can we go step by step? after calling readFile filename something of type (IO String) is returned
10:19:35 <xerox> Right.
10:19:45 <work_metaperl> I guess I am trying to take something of type m a and extract the a and apply (a -> b) to it? no?
10:19:50 <xerox> do content <- readFile filename
10:19:50 <xerox>    ...
10:20:01 <work_metaperl> no dont switch to do notation please
10:20:04 <xerox> Yes.  And that something is 'fmap lines'
10:20:12 <xerox> @type fmap lines
10:20:13 <lambdabot> forall (f :: * -> *).
10:20:13 <lambdabot>      (Functor f) =>
10:20:13 <lambdabot>      f String -> f [String]
10:20:30 <xerox> It takes the IO String and returns the IO [String]
10:21:06 <xerox> (It isn't really needed to fmap lines, it is if you want to build a single action which only reads the file and splits it up.)
10:21:31 <work_metaperl> @type fmap
10:21:33 <lambdabot> forall (f :: * -> *) b a.
10:21:33 <lambdabot>    (Functor f) =>
10:21:33 <lambdabot>    (a -> b) -> f a -> f b
10:21:34 * mux wonders if the fmap and the liftM version end up the same once compiled
10:21:42 <xerox> mux: they *are* the same.
10:21:49 <mux> ok
10:22:03 <work_metaperl> ok, for that general fmap, f a is IO String
10:22:03 <mux> that's nice
10:22:05 <work_metaperl> @type unlines
10:22:07 <lambdabot> [String] -> String
10:22:08 <work_metaperl> @type lines
10:22:09 <lambdabot> String -> [String]
10:22:14 <work_metaperl> yes I see now
10:22:17 <xerox> Yes.
10:22:21 <work_metaperl> (a -> b) is lines
10:22:26 <xerox> (a -> b) -> (m a -> m b)
10:22:36 <work_metaperl> but there is one problem
10:22:48 <work_metaperl> (a -> b) -> f a -> f b implies the container does not change
10:23:06 <work_metaperl> the original container was IO the resultant container was List
10:23:19 <mux> you cannot remove something from the IO container
10:23:20 <CosmicRay> work_metaperl: pong
10:23:26 <mux> it's a one-way monad
10:23:31 <work_metaperl> CosmicRay: the spaces were left out of my code submission: http://sequence.complete.org/node/181
10:23:37 * CosmicRay checks
10:23:41 <mux> unless you use unsafePerformIO which is, of course, unsafe
10:23:46 <work_metaperl> no, I'm talking about the type signature
10:23:53 <work_metaperl> (a -> b) -> f a -> f b implies the container does not change
10:24:00 <work_metaperl> but the container changes from IO to List
10:24:09 <SyntaxNinja> hey CosmicRay!
10:24:22 <CosmicRay> hi SyntaxNinja
10:24:54 <SyntaxNinja> CosmicRay: how's life? run into any terror-ants lately?
10:25:02 <work_metaperl> why is everyone ignoring me?
10:25:07 <work_metaperl> I need help
10:25:43 <azuroth> what's up, work_metaperl
10:25:44 <azuroth> ?
10:25:55 <work_metaperl> (a -> b) -> f a -> f b implies the container does not change
10:25:59 <work_metaperl> @type fmap
10:26:00 <lambdabot> forall (f :: * -> *) b a.
10:26:00 <lambdabot>    (Functor f) =>
10:26:00 <lambdabot>    (a -> b) -> f a -> f b
10:26:03 <dcoutts_> yep
10:26:27 <CosmicRay> SyntaxNinja: heh.  nope, but staying plenty busy though, with moving and a baby coming up
10:26:37 <CosmicRay> work_metaperl: I think you may have wanted to use <pre> instead of <code>
10:26:49 <work_metaperl> but when f a is readFile and (a -> b) is lines, then supposedly f b is of type [String] but that means that f changed from being a container of IO to being a List container, which violates the type signature
10:27:03 <CosmicRay> SyntaxNinja: plus I'm setting up the new Bacula backup system here
10:27:12 <CosmicRay> SyntaxNinja: You may have read about that on debian-devel ;-)
10:27:23 <xerox> CosmicRay!
10:27:28 <work_metaperl> dcoutts_: can you help me?
10:27:31 <CosmicRay> hey xerox
10:27:39 <xerox> CosmicRay: did you vote from an ant and the other? (-:
10:27:46 <xerox> s/from/between/
10:27:57 <dcoutts_> work_metaperl, you'll have to explain your problem more precisely
10:28:00 <Cale> work_metaperl: what's the question?
10:28:11 <work_metaperl> but when f a is readFile and (a -> b) is lines, then supposedly f b is of type [String] but that means that f changed from being a container of IO to being a List container, which violates the type signature
10:28:13 <work_metaperl> @type fmap
10:28:14 <lambdabot> forall (f :: * -> *) b a.
10:28:14 <lambdabot>    (Functor f) =>
10:28:14 <lambdabot>    (a -> b) -> f a -> f b
10:28:23 <CosmicRay> xerox: ;-)
10:28:27 <work_metaperl> I'm trying to read a file and turn it into a list of lines
10:28:32 <Cale> no, IO [String]
10:28:40 <work_metaperl> @type readFile
10:28:41 <lambdabot> FilePath -> IO String
10:28:51 <Cale> @type fmap lines readFile
10:28:51 <lambdabot>   Couldn't match `String' against `IO String'
10:28:52 <lambdabot>   Expected type: FilePath -> String
10:28:52 <davidhouse> @type fmap line . readFile
10:28:53 <lambdabot> Not in scope: `line'
10:28:56 <Cale> @type fmap lines . readFile
10:28:56 <davidhouse> @type fmap lines . readFile
10:28:57 <lambdabot> FilePath -> IO [String]
10:28:57 <lambdabot> FilePath -> IO [String]
10:29:00 <davidhouse> grr.
10:29:04 <davidhouse> beaten to it :)
10:29:05 <work_metaperl> they used =<<
10:29:07 <SyntaxNinja> dcoutts_: did you whitelist eivuokko yet?
10:29:12 <Cale> sure
10:29:13 <dcoutts_> SyntaxNinja, yes
10:29:15 <work_metaperl> @type (=<<)
10:29:16 <lambdabot> forall b (m :: * -> *) a.
10:29:17 <lambdabot>    (Monad m) =>
10:29:17 <lambdabot>    (a -> m b) -> m a -> m b
10:29:25 <Cale> @type readFile >>= return . lines
10:29:26 <lambdabot>   Couldn't match `String' against `IO String'
10:29:27 <lambdabot>   Expected type: IO String -> FilePath -> b
10:29:30 <Cale> err
10:29:37 <Cale> @type \f -> readFile f >>= return . lines
10:29:38 <lambdabot> FilePath -> IO [String]
10:29:57 <Cale> keep forgetting about the obvious filename parameter :)
10:29:58 <work_metaperl> how can you compose lines with readFile? 
10:30:00 <dcoutts_> @type liftM lines readFile
10:30:01 <work_metaperl> @type lines . readFile
10:30:02 <SyntaxNinja> dcoutts_: thanks :)
10:30:02 <lambdabot>   Couldn't match `String' against `IO String'
10:30:02 <lambdabot>   Expected type: FilePath -> String
10:30:02 <lambdabot>   Couldn't match `String' against `IO String'
10:30:03 <lambdabot>   Expected type: FilePath -> String
10:30:07 <davidhouse> (>>= (return .)) == liftM, up to order of parameters.
10:30:14 <work_metaperl> wait, this is crazy
10:30:18 <dcoutts_> @type \name -> liftM lines (readFile name)
10:30:19 <lambdabot> FilePath -> IO [String]
10:30:33 <dcoutts_> @type liftM lines (readFile "foo")
10:30:34 <lambdabot> IO [String]
10:30:49 <work_metaperl> I dont know what liftM is. why did fmap lines . readFile work but @type lines . readFile fail?
10:31:07 <dcoutts_> @type liftM
10:31:08 <lambdabot> forall r (m :: * -> *) a1.
10:31:08 <lambdabot>    (Monad m) =>
10:31:08 <lambdabot>    (a1 -> r) -> m a1 -> m r
10:31:14 <dcoutts_> @type fmap
10:31:15 <lambdabot> forall (f :: * -> *) b a.
10:31:15 <lambdabot>    (Functor f) =>
10:31:15 <lambdabot>    (a -> b) -> f a -> f b
10:31:24 <work_metaperl> wait, can everyone just wait and let me explain it starting from where I understand things?
10:31:28 <davidhouse> work_metaperl: liftM is just fmap.
10:31:31 <work_metaperl> ok... here it goes:
10:31:37 <work_metaperl> @type readFile
10:31:38 <lambdabot> FilePath -> IO String
10:31:52 <work_metaperl> we have a container in which the element is of type String
10:32:01 <work_metaperl> @type lines
10:32:02 <lambdabot> String -> [String]
10:32:12 <work_metaperl> converts a string into a list of strings
10:32:16 <Cale> not just any container, but an IO container
10:32:42 <work_metaperl> so all we need to do is pluck the String out of the IO container and apply String -> [String] to it and fmap has just the type signature:
10:32:44 <work_metaperl> @type fmap
10:32:45 <lambdabot> forall (f :: * -> *) b a.
10:32:45 <lambdabot>    (Functor f) =>
10:32:45 <lambdabot>    (a -> b) -> f a -> f b
10:33:07 <work_metaperl> but one problem: fmap DEMANDS that the container for its second argument and output argument are the same
10:33:15 <dcoutts_> which is the case here
10:33:16 <work_metaperl> f a  and f b
10:33:31 <dcoutts_> you're going from IO String to IO [String]
10:33:39 <work_metaperl> f a = IO String.... f = IO .. a = String     f b = List String ... f = List ... b = String
10:33:39 <davidhouse> f is IO, here.
10:33:53 <work_metaperl> OH!
10:33:55 <work_metaperl> that's right
10:34:04 <work_metaperl> GOT IT
10:34:11 <work_metaperl> but one last thing
10:34:16 <davidhouse> remember that once you've fmapped the thing in the container, fmap slaps the container back on again.
10:34:35 <work_metaperl> yes
10:34:47 <work_metaperl> @type fmap lines
10:34:48 <lambdabot> forall (f :: * -> *).
10:34:48 <lambdabot>      (Functor f) =>
10:34:48 <lambdabot>      f String -> f [String]
10:35:00 <work_metaperl> bingo. f = IO
10:35:20 <work_metaperl> ... wrong. it was IO [String]
10:35:27 <work_metaperl> oops ignore that
10:35:29 <work_metaperl> thakns guys
10:39:21 <ralejs> @djinn (a,b) -> (b,a)
10:39:22 <lambdabot> f (a, b) = (b, a)
10:39:56 <ralejs> @djinn (a,a) -> (a,a)
10:39:56 <lambdabot> f a = a
10:40:24 <Cale> @djinn (a -> a) -> a -> a
10:40:24 <lambdabot> f a = a
10:42:12 <work_metaperl> fileToLines filename = fmap lines (readFile filename)  -- is there a more succinct way to do this?
10:42:45 <work_metaperl> using "." for instance
10:42:52 <xerox> fmap lines . readFile
10:43:10 <work_metaperl> xerox: I dont understand that totally
10:43:13 <xerox> f . g = \x -> f (g x)
10:43:17 <dcoutts_> @pl \filename -> fmap lines (readFile filename)
10:43:18 <lambdabot> fmap lines . readFile
10:43:19 <work_metaperl> yes
10:43:26 <xerox> Apply the definition
10:43:48 <xerox> With f = fmap lines and g = readFile
10:43:53 <xerox> ..and x = filename
10:44:03 <work_metaperl> dcoutts_: thanks for showing me how to fish :)
10:44:23 <xerox> He showed you how does lambdabot fish :-)
10:44:32 <dcoutts_> work_metaperl, note that @pl sometimes give you horrible code, though in this case it was nice
10:44:40 <work_metaperl> xerox: the reason I have a problem with that is that the output type of g is not the input type of f
10:45:02 <work_metaperl> the output tyhpe of g is IO String .. the input type of f is String
10:45:14 <work_metaperl> they cant be composed
10:45:25 <xerox> Yes it is.
10:45:28 <dcoutts_> no
10:45:31 <dcoutts_> @type fmap lines
10:45:33 <lambdabot> forall (f :: * -> *).
10:45:33 <lambdabot>      (Functor f) =>
10:45:33 <lambdabot>      f String -> f [String]
10:45:33 <work_metaperl> ?
10:45:39 <xerox> fmap lines :: Monad m => m String -> m [String]
10:45:40 <dcoutts_> @type readFile
10:45:41 <lambdabot> FilePath -> IO String
10:45:47 <xerox> fmap lines :: IO String -> IO [String]
10:46:19 <work_metaperl> oh so that composition was actually (fmap lines) . readFile
10:46:24 <xerox> Yes!!
10:46:26 <work_metaperl> not fmap (lines . readFile)
10:46:28 <work_metaperl> :)
10:46:32 <xerox> Function application binds tighter
10:46:59 <xerox> (That's why you have to use '$' in some places at times.)
10:47:26 * xerox chumps a cracker
10:53:04 <work_metaperl> I'm trying to get the head of a list I read in:  (fmap head) . (fileToLines "state-codes.txt")
10:53:15 <work_metaperl> but it says fileToLines is applied to too many args
10:56:13 <Cale> is there any code after that?
10:57:23 <work_metaperl> Cale: this is it: http://rafb.net/paste/results/MPFXdf47.html
10:58:53 <Cale> why the . ?
10:59:01 <work_metaperl> hmmm
10:59:06 <Cale> fmap head (fileToLines "state-codes.txt")
10:59:11 <work_metaperl> oh
10:59:20 <work_metaperl> thanks
10:59:34 <Cale> you use the (.) in fileToLines to avoid having to mention the extra filename parameter to readFile
11:07:37 <work_metaperl> *Main> fmap head (readFile "state-codes.txt")  -- why don't I see anything on the screen when I do this?
11:08:22 <Cale> because ghci doesn't show the results of IO actions -- it only executes them
11:08:34 <Cale> you can tack on a >>= print at the end to see the result
11:08:57 <work_metaperl> wait a minute, I'm only getting the first char from the first line: 
11:09:14 <work_metaperl> *Main> :t fmap head (readFile "state-codes.txt") 
11:09:15 <work_metaperl> fmap head (readFile "state-codes.txt") :: IO Char 
11:09:30 <work_metaperl> I wanted the first line
11:09:35 <Cale> yeah, readFile reads the file as a string
11:09:43 <work_metaperl> ih
11:09:49 <work_metaperl> I wanted fileToLines there
11:09:53 <Cale> yeah
11:10:18 <work_metaperl> *Main> :t fmap head (fileToLines "state-codes.txt") >>= 
11:10:18 <work_metaperl> <interactive>:1:45: parse error (possibly incorrect indentation) 
11:10:46 <Cale> :t fmap head (fileToLines "state-codes.txt") >>= print
11:11:14 <work_metaperl> *Main> fmap head (fileToLines "state-codes.txt") >>= print 
11:11:15 <work_metaperl> "AL:ALABAMA" 
11:11:15 <work_metaperl> -- hooray!
11:11:57 <work_metaperl> how do I take a string which represents two data items separated by a colon and turn that into a 2-tuple?
11:12:10 <work_metaperl> "AL:ALABAMA" -> ("AL", "ALABAMA")
11:12:43 <Cale> > break (==':') "AL:ALABAMA"
11:12:44 <lambdabot> ("AL",":ALABAMA")
11:12:52 <work_metaperl> @type break
11:12:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:13:01 <Cale> > let (x,y) = break (==':') "AL:ALABAMA" in (x,drop 1 y)
11:13:02 <lambdabot> ("AL","ALABAMA")
11:13:54 <work_metaperl> that's a sweet function
11:14:10 <Cale> yeah, it's handy
11:30:20 <good_boy> im trying to write a simple IO Program. why do i get a "Last generator in do(...) must be an expression" error?
11:31:01 <Cale> good_boy: because you can't end a do-block with something of the form  v <- x
11:31:18 <Cale> it has to end in just a monadic value
11:32:02 <Cale> (an IO action, in your case)
11:32:08 <Cale> the reason for this is that do-notation is really just a shorthand for a bunch of applications of (>>=) and lambdas
11:32:33 <sethk> good_boy, this is the same answer but in different terms:  x <- y really means y >>= \x -> ( ... )   and you haven't provided ( ... )
11:32:33 <Cale> and having v <- x at the end is like having an empty lambda
11:32:41 <work_metaperl> now, 30 minutes later, I think I see why that drop was there
11:33:00 <work_metaperl> the second element in the 2-tuple retains the break character
11:33:00 <good_boy> im not that clear about the "monads" concept and "monadic value"
11:33:17 <work_metaperl> good_boy: "Monads as Containers" is the best starting point
11:33:28 <karma_> Hello! Is there some simple effective algorithm for pattern matching (there're simple patterns: letters and star)?
11:33:30 <sethk> good_boy, that's a distraction.  you need the right hand part of   \x -> ( ...) and you haven't provided it
11:34:17 <good_boy> test :: IO ()
11:34:18 <good_boy> test = do a <- getLine
11:34:18 <good_boy> 		putStr a
11:34:18 <good_boy> 		return(a)
11:34:28 <sethk> good_boy, what he meant is that the last statement in the sequence must have the same type as the function, which in this case is main and has type IO ()  I hink
11:34:40 <Cale> as the action :)
11:34:42 <sethk> good_boy, lose the parentheses on return a and you are correct
11:34:44 <azuroth> ?nopaste
11:34:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:34:53 <good_boy> oh
11:35:31 <azuroth> ?lisppaste
11:35:31 <lambdabot> Unknown command, try @list
11:35:36 <Cale> lisppaste2: url
11:35:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:35:59 <azuroth> oh, cool
11:36:38 <lisppaste2> azuroth pasted "karma_ wildcard stuff" at http://paste.lisp.org/display/19943
11:38:48 <azuroth> assuming that's what you meant, karma_?
11:39:08 <work_metaperl> _lineToCodeAndName = (break (==':'))  
11:39:08 <work_metaperl> lineToCodeAndName str = (x, drop 1 y) 
11:39:08 <work_metaperl>     where (x,y) = _lineToCodeAndName str 
11:39:08 <work_metaperl> -- anyway to get rid of the "str" in this function def?
11:39:28 <work_metaperl> make it points-free
11:40:11 <Cale> @type (***)
11:40:11 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
11:40:12 <lambdabot>    (Arrow a) =>
11:40:12 <lambdabot>    a b c -> a b' c' -> a (b, b') (c, c')
11:40:37 <mauke> @pl \str -> ( \(x, y) -> (x, drop 1 y) ) (break (== ':') str)
11:40:37 <lambdabot> second (drop 1) . break (':' ==)
11:41:04 <Cale> yeah, second f = (id *** f)
11:41:12 <Cale> it's in Control.Arrow
11:43:05 <azuroth> hmm, it's almost five :x
11:45:38 <work_metaperl> I got more than I asked for.. I think I will stick with Kiddie Haskell for now :)
11:50:27 <Cale> work_metaperl: basically, second f (x,y) = (x, f y)
11:51:43 <mauke> @index mapSnd
11:51:43 <lambdabot> Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:51:49 <work_metaperl> @type second
11:51:51 <lambdabot> forall (a :: * -> * -> *) c d b.
11:51:51 <lambdabot>     (Arrow a) =>
11:51:51 <lambdabot>     a b c -> a (d, b) (d, c)
11:52:00 <work_metaperl> mauke: what do you do for a living?
11:52:12 <Cale> (->) is a special case of an Arrow in general
11:52:18 <mauke> nothing
11:52:30 <work_metaperl> I dont know about Arrows at all yet
11:52:37 <work_metaperl> where is the Arrow tutorial :)
11:52:56 <Cale> http://haskell.org/arrows/
12:02:53 <palomer> Arrows are cool
12:05:20 <azuroth> convex polygons are cool
12:05:24 <azuroth> -er
12:05:43 <stepcut> :p
12:05:44 <Cale> regular polygons are cooler
12:06:47 <azuroth> you can't split a regular polygon in two and always stay a regular polygon!
12:07:00 <JKnecht> so wrt to semiotics Arrows are more monadic than monads in a Category theoretic sense?
12:08:25 <stepcut> JKnecht: monads are a subset of arrows -- but I am not sure that makes arrows 'more monadic'
12:08:51 <JKnecht> I meant like "more catholic than the pope" :)
12:09:16 <stepcut> JKnecht: for example, even numbers are a subset of integers, but that does not make integers more even :)
12:09:47 <jfoutz> it does make them more "numbery"
12:10:00 <jfoutz> :)
12:10:04 <stepcut> Arrows can do everything monads can do and more -- but often times it is still easier and more clear to use monads
12:10:29 <stepcut> s/more clear/clearer/
12:15:47 * palomer is starting to get the coding itch
12:15:54 <palomer> note that I use the term "starting"
12:18:11 <azuroth> I'm starting to get the sleeping itch :-(
12:18:30 <azuroth> night
12:22:57 <Cale> heh, "The sign above the door reads 'Barracks keep out'. While an argument could be made that, as you are not a barracks, you can enter, it is unlikely that the soldiers here would accept the logic in that statement.
12:26:47 <sethk> Cale, you can claim that your intention was to inter to impel the barracks that are already inside to leave
12:27:00 <Cale> heh
12:28:15 <palomer> Cale: where's that fr om?
12:28:32 <Cale> The remake of Dark Ages in Dragon Hunt
12:30:29 <palomer> a book?
12:30:37 <Cale> no, a game
12:30:41 <Cale> http://emhsoft.net/dh.html
13:05:41 <work_metaperl> Can someone help me implement two lookup functions on a list of 2-tuples: http://rafb.net/paste/results/7xUMjZ80.html
13:06:30 <Cale> @type lookup
13:06:31 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
13:28:09 <vincenz> lookkup should be in a class
13:28:14 <vincenz> @type Data.Map.lookup
13:28:15 <lambdabot> forall a (m :: * -> *) k.
13:28:15 <lambdabot>        (Ord k, Monad m) =>
13:28:15 <lambdabot>        k -> Data.Map.Map k a -> m a
13:28:19 <vincenz> and have that signature
13:28:59 <vincenz> (Ord k, Monad m, Associative s) => k -> s k a -> m a
13:37:34 <hyrax42> @index putStrLn
13:37:35 <lambdabot> System.IO, Prelude
13:40:01 <mwc> Is there a way to include alex specs and happy grammars in a cabal source list?
13:40:23 <mwc> looking at the docs, I don't see a field that lends itself to that
13:40:42 <xerox> @arr
13:40:42 <lambdabot> Aye Aye Cap'n
13:41:15 <eivuokko> mwc, I don't know if it works, but it ought to wowk so that you put the module name that is generated by grammar in module list.
13:41:57 <mwc> hmm, i was trying that a few days ago and gave up
13:42:09 <eivuokko> If setup configure finding alex and happy?
13:42:13 <mwc> i'll have anoother go
13:42:20 <eivuokko> I'll see if I can read the source
13:42:20 <mwc> eivuokko, seem to remember it was
13:42:45 <mwc> for Lexer.x, I'd put in Lexer for the module?
13:42:51 <eivuokko> Yeah
13:43:22 <mwc> mustabeen a bad config then
13:43:36 <mwc> (mistake on my part)
13:43:50 <eivuokko> alex and happy are preprocessors in cabal source, .x and .y
13:46:25 <Cale> vincenz: better still would be MonadZero :)
13:47:00 <the_lord> how do I make more than one actions in a function and then return?
13:47:33 <Cale> the_lord: either using do-notation, or >> and >>= (which do-notation desugars into)
13:47:59 <the_lord> it doesn't work
13:48:04 <the_lord> at least for me :S
13:48:16 <Cale> what error
13:48:17 <Cale> ?
13:48:21 <the_lord> wait
13:48:26 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:49:03 <the_lord> Couldn't match `IO b' against `Token'
13:49:12 <Cale> okay
13:49:16 <ADEpt> the_lord: paste the code
13:49:25 <Cale> that means that you're trying to use a Token as an IO action
13:49:44 <ADEpt> the_lord: but probably you just need "return" somwhere there
13:49:46 <the_lord> where do I paste?
13:49:49 <ADEpt> Cale: not vice-versa?
13:50:00 <ADEpt> lisppaste2: url
13:50:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:50:02 <Cale> ADEpt: or vice versa
13:50:46 <ADEpt> Cale: IMO, he tries to use IO b as Token.
13:51:00 <lisppaste2> the_lord pasted "It's Alex code the problem is in boomBoom" at http://paste.lisp.org/display/19951
13:52:10 <Cale> the_lord: indent the return a little more perhaps
13:52:16 <Cale> or use a do-block
13:52:22 <Cale> do print ...
13:52:27 <Cale>    return (Boom p s)
13:53:04 <Lemmih> Use Debug.Trace?
13:53:09 <Cale> there also appears to be a spurious } after your lexer
13:53:14 <Cale> Lemmih: hm?
13:53:28 <Lemmih> Cale: boomBoom isn't an IO action.
13:53:37 <Cale> oh, right
13:53:40 <the_lord> if I make it inside a do, I get this: Couldn't match `Token' against `t t1'
13:53:42 <Cale> that would be another reason
13:53:42 <the_lord>       Expected type: Token
13:53:43 <the_lord>       Inferred type: t t1
13:53:55 <Cale> the signature you gave for boomBoom is incorrect
13:54:06 <Cale> it's of type AlexPosn -> String -> IO Token
13:55:16 <the_lord> how do I convert from IO Token to Token?
13:55:29 <the_lord> there's gotta be a way to do this
13:55:33 <xerox> do token <- actionReturningTheIOToken
13:55:35 <xerox>    ...
13:55:56 <the_lord> ???
13:55:56 <lambdabot> Maybe you meant: . id pl v wn
13:56:45 <Lemmih> thedward: You can use Debug.Trace.trace
13:58:01 <Lemmih> Arg.
13:58:16 <Lemmih> the_lord: You can use Debug.Trace.trace
13:58:59 <the_lord> point me to a manual on how to debug please
13:59:15 <Lemmih> @docs Debug.Trace
13:59:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
13:59:24 * Lemmih points at the above link.
13:59:27 <Cale> the_lord: you should possibly read "Introduction to IO" if you haven't already
13:59:56 <Cale> If you're just debugging, then Debug.Trace is fine, but you shouldn't rely on the messages it prints
14:00:50 <Cale> if you're reporting lexical errors in an input file to the user, then Debug.Trace isn't appropriate
14:02:14 <palomer> Debug.Trace shouldn't be in released code
14:02:31 <hyrax42> can you declare a type defined in one module as an instance of a class, but with the defintion in another moduel?
14:02:52 <norpan> hyrax42: yes
14:03:05 <hyrax42> brilliant
14:03:12 <Lemmih> I'd say no but perhaps I read it wrong.
14:03:15 <palomer> norpan: you sure?
14:03:32 <hyrax42> oh, no consensus
14:03:41 <palomer> I would have thought i would cause a mutually recursive modules
14:03:45 <palomer> s/i/it
14:04:02 <palomer> s/cause a.../couse the modules to become mutually recursive
14:04:13 <hyrax42> I have the type LispVal defined in Scheme.Parser, and instance Show LispVal declared in Scheme.Evaluator
14:04:18 <hyrax42> (yes, things will be reorganised)
14:04:20 * palomer is losing his linguistic ability
14:04:47 <hyrax42> and Evlauator imports Parser
14:04:54 <palomer> I would go with "no"
14:05:18 <palomer> because Scheme.Parser imports Scheme.Evaluator and vice versa
14:05:20 <hyrax42> ok, then I reorganise sooner rather than later
14:05:33 <hyrax42> well only one imports right now
14:05:47 <palomer> but if you were to implement the instance somewhere else, you'd need to import it
14:06:44 <mgoetze> @index foldll
14:06:45 <lambdabot> bzzt
14:06:53 <mgoetze> hm
14:07:49 <palomer> @type foldl
14:07:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:08:00 <palomer> my favourite is foldl1
14:08:03 <palomer> @type foldl1
14:08:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:08:09 <mgoetze> ah
14:08:09 <palomer> @type foldl1 (+)
14:08:10 <lambdabot> forall a. (Num a) => [a] -> a
14:08:24 <mgoetze> > foldl1 max [1..5]
14:08:26 <lambdabot> 5
14:08:31 <hyrax42> @type foldl (+) 0
14:08:31 <mgoetze> yes, that's what i wanted, thanks
14:08:32 <lambdabot> forall b. (Num b) => [b] -> b
14:08:56 <jfoutz> > foldl (+) [1..5]
14:08:57 <lambdabot>  add an instance declaration for (Num [a])
14:09:02 <hyrax42> is there a sentinel -inifinty value?
14:09:26 <Cale> hyrax42: in Float and Double
14:09:28 <mgoetze> > foldl1 max [-1..-5]
14:09:29 <lambdabot>  Not in scope: `..-'
14:09:34 <mgoetze> > foldl1 max [-5..-1]
14:09:35 <lambdabot>  Not in scope: `..-'
14:09:35 <Cale> hyrax42: but not in Integer
14:09:42 <hyrax42> that's... unfortunate
14:09:49 <mgoetze> > foldl1 max [(-5)..(-1)]
14:09:50 <lambdabot> -1
14:09:53 <Cale> no, it's probably good
14:09:57 <hyrax42> you can't mimic that foldl1 max with foldl then
14:10:04 <hyrax42> mimmic
14:10:05 <Cale> right, you can't
14:10:31 <hyrax42> why probably good?
14:10:33 * mgoetze thinks max ought to be of type (Ord a) => [a] -> a in the first place
14:10:43 <Cale> because -infinity isn't an integer
14:11:06 <Cale> and lots of properties will break if you try to add it
14:11:12 <hyrax42> but having the sentinel coul dmake certain things easier
14:11:27 <hyrax42> yeah I guess
14:12:18 <hyrax42> I guess I just assumed that foldl1 was a specialised form of foldl
14:12:21 <hyrax42> but I was wrong
14:12:52 <mgoetze> > foldl1 max []
14:12:53 <lambdabot> Add a type signature
14:13:09 <mgoetze> > (foldl1 max [])::Int
14:13:10 <lambdabot> Exception: Prelude.foldl1: empty list
14:13:20 <Cale> > maximum []
14:13:20 <lambdabot> Add a type signature
14:13:24 <Cale> > maximum [] :: Int
14:13:25 <lambdabot> Exception: Prelude.maximum: empty list
14:13:28 <Cale> > maximum [1,2,3] :: Int
14:13:29 <lambdabot> 3
14:13:35 <palomer> @type foldl1 max
14:13:36 <lambdabot> forall a. (Ord a) => [a] -> a
14:13:43 <mgoetze> oh hm, where did that come from...
14:13:53 <palomer> @type maximum
14:13:54 <lambdabot> forall a. (Ord a) => [a] -> a
14:14:09 <Cale> where did what come from?
14:14:18 <mgoetze> that maximum function...
14:14:26 <Cale> it's in the prelude
14:14:55 <mgoetze> yeah i was looking in the wrong part of the prelude (specifically, under the class Ord a where.... bit)
14:18:19 <palomer> if you ignore the existence of bottom, are Either a () and Maybe a isomorphic?
14:19:59 <Cale> yes
14:22:24 <jip> is the craft of functional programming a good book?
14:22:51 <SyntaxNinja> yes
14:23:55 <jfoutz> i didn't like it. it's like an introduction to programming level book. 
14:24:50 <jfoutz> it's acceptable, but it's not as good as structure and interpretation of computer programs, for that level of book.
14:26:35 <jfoutz> but it's more than good enough to start getting stuff done.
14:27:34 <the_lord> Cale, nothing I'm about to give up
14:27:48 <Cale> the_lord: hm?
14:28:23 <the_lord> I cant print something and return a type
14:28:30 <the_lord> in the same function
14:28:51 <Cale> If you need to print something, then that's doing IO, so you have to construct an IO action
14:28:55 <Lemmih> the_lord: trace "debug msg" (your value)
14:28:58 <Cale> the IO action can return a value
14:29:16 <Cale> if you're just debugging, then use Debug.Trace like Lemmih suggests
14:29:32 <the_lord> no, it's an assignment
14:29:40 <the_lord> it's not for debuggin'
14:29:44 <Cale> okay
14:30:25 <Cale> have you read Introduction to IO?
14:30:29 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:30:29 <Lemmih> He's gone...
14:30:32 <Cale> oh
14:31:20 <the_lord> it's not for debuggin'
14:31:27 <Cale> have you read Introduction to IO?
14:31:32 <psi> heh
14:31:33 <Cale> wtf?
14:31:39 <Cale> hehe
14:32:15 <ADEpt> we could do a flashmob thing
14:32:38 <ADEpt> tyoe "have you read Introduction to IO?", but not press <enter> until he connects :)
14:32:53 <ADEpt> at least some of us will get lucky :)
15:32:29 <sethk> can I do this? (all on one line so obviously not correct indentation):  catch (whatever) (\e -> do    .....  where ...  )   ?
15:32:47 <palomer> @type catch
15:32:48 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:32:52 <sethk> that is, can I have a where at the end of the block of code within (\e -> whatever )  ?
15:32:53 <Cale> where is not part of expression syntax
15:33:00 <Cale> let, however, is
15:33:18 <sethk> Cale, ok
15:33:28 <palomer> and the second argument to catch has to be of an IO type, not an -> type
15:33:33 <sethk> that makes sense, since where applies to multiple parts of a function with guards
15:33:39 <palomer> actually, nevermind
15:33:53 <sethk> palomer, right, I was going to say, where doesn't impact the type.
15:34:06 <sethk> palomer, well, I guess you can't say what where might do when where is illegal  :)
15:35:42 <sethk> this file is too big, 1019 lines
15:35:47 <palomer> where scopes over a top-level declaration, right?
15:35:55 <palomer> that's a lot of haskell code
15:35:59 <eivuokko> Yes.
15:36:44 <sethk> palomer, yes, it has grown.  I'll have to reorganize a bit.
15:37:37 <sethk> vim keeps adding blank lines to the end of my files.  Of course, that only accounts for 5 of 1019 ... :)
15:37:39 <palomer> @seen ski
15:37:39 <lambdabot> ski is in #haskell, #haskell-overflow and #haskell-blah. I don't know when ski last spoke.
15:37:55 * palomer pokes ski
15:39:26 <ihope> Hmm...
15:41:14 <jip> anyone know c--?
15:41:26 <ihope> @djinn (Either a b -> c) -> (a -> c, b -> c)
15:41:26 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
15:41:39 <mahogny> jip, know and know... it's nothing you code by hand :)
15:41:50 <ADEpt> jip: i know C :) Maybe. I am not sure anymore.
15:41:59 <Lemmih> jip: Yeah, superficially.
15:42:12 <jip> how does it compare with gnu lightning or libjit?
15:42:26 <ihope> @djinn ((a, b) -> c) -> Either (a -> c) (b -> c) -- can't be done :-(
15:42:26 <lambdabot> Cannot parse command
15:42:30 <ihope> @djinn ((a, b) -> c) -> Either (a -> c) (b -> c)
15:42:31 <lambdabot> -- f cannot be realized.
15:46:23 <kosmikus> ChilliX: thanks for the HCAR submissions
15:47:49 <Lemmih> jip: Well, C-- is a language and lightning is a library for generating assembly code at run-time.
15:48:22 * palomer wonders if C-- is becoming the standard intermediate language
15:48:44 <newsham> *wonders if the haskell-cafe shell discussion has considered the "monad" shell from microsoft*
15:49:17 <jip> is C-- usable right now?
15:49:43 <Lemmih> jip: Yes.
15:50:01 <Lemmih> (for some value of useable)
15:50:40 <newsham> how many values of useable are there?
15:50:51 <Lemmih> 42
15:51:26 <newsham> and how many of those qualify c--?
15:52:18 <mahogny> xerox, omg going through all these applications will take some time :(
15:52:41 <xerox> hehe
15:52:45 * xerox pats mahogny 
15:53:05 <mahogny> xerox, thanks. I will need it :)
15:54:54 <ADEpt> mahogny: little secret - if you do not rely on yourself being able to come up with judgement at once, be sure to open all five pages in five tabs/windows, and only then follow links - in separate window. Otherwise you would lose track on what's scored and what's not quite easily
15:55:21 <mahogny> ADEpt, yeah, I have guessed so
15:55:46 <ADEpt> Lemmih: have you decided with dcoutts who will take gstream binding applications?
15:59:48 <Lemmih> ADEpt: Nope.
16:00:05 <xerox> Goodnight Haskellers.
16:00:20 <jip> how good is template haskell?
16:00:22 <kosmikus> xerox: good night
16:01:26 <kosmikus> jip: define "good"
16:01:27 <ADEpt> jip: Good Enough(tm)?
16:01:42 <ADEpt> jip: i used it to derive instances and was happy
16:01:59 <newsham> depends on the task, no? :)
16:02:22 <jip> is it "useful", or is it like totally awesome and it will change the way you program in haskell?
16:02:44 <newsham> i wouldnt say the latter
16:02:50 <newsham> more like the former
16:03:11 <newsham> its a lot more messy than lisp's macros, necessarily.
16:04:19 <newsham> (and while people rant about lisp macros, i wouldnt say they are "change the way you program" great)
16:04:33 <ADEpt> jip: and you will need to read the Dark Book on Haskell AST
16:04:43 <ADEpt> jip: only such book does not exist yet
16:04:49 <ADEpt> jip: and this is the main trick
16:05:02 <newsham> at least the dark book on lisp AST is really thin
16:09:03 * SamB wonders if there is a way in Inform 7 to say that the same two buttons are on every elevator in a shaft...
16:09:40 * SamB doesn't suppose it is smart enough to map an elevator-only building's floors well
16:10:07 <ADEpt> SamB: ?
16:10:57 <SamB> well, I don't know of any IF-related channels to talk about this on
16:11:08 <SamB> @google "inform 7"
16:11:09 <lambdabot> http://www.inform-fiction.org/
16:11:20 * SamB patpats google
16:11:29 <work_metaperl> thanks for the help on lookup earlier today... now I am looking for a lookup which takes [(a,b)] -> b -> Maybe a
16:11:53 <SamB> and I don't feel like trying to start a thread on RAIF
16:12:10 <hyrax42> @hoogle [(a,b)] -> b -> Maybe a
16:12:11 <lambdabot> No matches, try a more general search
16:12:30 <SamB> especially considering that I am not actually trying to write a game with an elevator...
16:12:32 <work_metaperl> @type lookup
16:12:33 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
16:12:39 <SamB> oh, and I meant next to every elevator door door
16:12:43 <work_metaperl> @hoogle b -> [(a,b)] -> Maybe a
16:12:43 <lambdabot> No matches, try a more general search
16:12:44 <SamB> er. -door.
16:13:12 <work_metaperl> maybe I have to flip the [(a,b)] so it becomes [(b,a)]
16:13:28 <work_metaperl> @hoogle [(a,b)] -> [(b,a)]
16:13:29 <ADEpt> @hoogle (a,b) -> (b,a)
16:13:29 <lambdabot> No matches, try a more general search
16:13:29 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:13:40 <SamB> @hoogle swap
16:13:40 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
16:13:40 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
16:13:40 <lambdabot> System.Win32.Info.sM_SWAPBUTTON :: SMSetting
16:13:51 <SamB> @type swap
16:13:52 <lambdabot> Not in scope: `swap'
16:13:59 <SamB> arg.
16:14:16 <hyrax42> @type fst . find ((=) . snd)
16:14:19 <lambdabot> parse error on input `='
16:14:22 <ADEpt> @pl (\(a,b) -> (b,a))
16:14:23 <lambdabot> uncurry (flip (,))
16:14:24 <SamB> @pl (\(a, b) -> (b, a))
16:14:24 <lambdabot> uncurry (flip (,))
16:14:31 <hyrax42> @type fst . find ((==) . snd)
16:14:32 <SamB> oookay
16:14:33 <lambdabot>   Couldn't match `(a, b)' against `Maybe a1'
16:14:33 <lambdabot>   Expected type: [a1] -> (a, b)
16:14:36 <ADEpt> SamB: :)
16:15:25 <ADEpt> work_metaperl: so, its (lookup . (map (uncurry (flip (,)))))  :)
16:15:28 <SamB> ADEpt: remember when we both removed that overlapping instance from Conjure?
16:15:38 <work_metaperl> ouch
16:15:44 <work_metaperl> ADEpt: thanks... 
16:15:59 <ADEpt> SamB: yep. telepatic ppowers at work :)
16:16:01 <SamB> I would personally just write a "swap" and stick it somewhere
16:16:05 <ADEpt> @type lookup . (map (uncurry (flip (,))))
16:16:07 <lambdabot> forall b a b1.
16:16:07 <lambdabot>              (Eq [(b1, a)]) =>
16:16:07 <lambdabot>              [(a, b1)] -> [([(b1, a)], b)] -> Maybe b
16:16:25 <ADEpt> of course
16:16:44 <ADEpt> @pl (\k -> lookup k . (map (uncurry (flip (,)))))
16:16:44 <lambdabot> (. map (uncurry (flip (,)))) . lookup
16:17:01 <ADEpt> @type (. map (uncurry (flip (,)))) . lookup
16:17:02 <lambdabot> forall a b.
16:17:02 <lambdabot>               (Eq b) =>
16:17:02 <lambdabot>               b -> [(a, b)] -> Maybe a
16:17:13 <SamB> that looks awful, adept
16:17:22 <ADEpt> work_metaperl: here it is
16:17:28 <ADEpt> SamB: of course it does :)
16:17:37 <ADEpt> work_metaperl: just write 'swap' :)
16:17:41 * work_metaperl cowers in the corner
16:17:45 <SamB> I don't like sections of dots
16:17:47 <work_metaperl> this is intimidating
16:18:11 <ADEpt> work_metaperl: this is just good knowledge of lambdabot commands
16:18:12 <SamB> ... where swap (a,b) = (b,a)
16:18:27 <work_metaperl> now _that_ I understand :)
16:18:40 <work_metaperl> map (\(a,b) -> (b,a)) codeBase
16:18:54 <ADEpt> and rlookup x = lookup x . map swap
16:18:55 <SamB> or that
16:19:13 <Lemmih> ADEpt: I didn't know dcoutts were interested in the GStreamer projects.
16:19:42 <SamB> is it a project to increase the reliability of GStreamer using Haskell?
16:20:44 <ADEpt> Lemmih: he marked some of the applications with "I will mentor this" and confirmed that in private chat
16:21:38 <hyrax42> @pl \x -> ((== x) . snd)
16:21:38 <lambdabot> (. snd) . (==)
16:21:49 <Lemmih> ADEpt: I'm still the only one marked for Simon Sandlund's project.
16:22:47 <ADEpt> Lemmih: but that's 1 of 3 applications
16:23:21 <ADEpt> Lemmih: ...3 applications with GStreamer `isSubstr` title 
16:24:31 <Lemmih> ADEpt: Got an url?
16:25:48 <Lemmih> ADEpt: He hasn't requested ownership over the three applications I can find.
16:26:07 <ADEpt> Lemmih: me bad. it must be in the comments, then
16:26:09 <SamB> has anyone requested mine?
16:26:24 <ADEpt> Lemmih: i certainly haven't got this out of thin air
16:27:06 <Lemmih> SamB: Application title?
16:27:19 <ADEpt> SamB: ParsecT
16:27:22 <SamB> Haskell.org: ParsecT -- monad transformer version of Parsec 
16:27:23 <ADEpt> ?
16:27:58 <SamB> monad transformer version of Parsec
16:28:14 <Lemmih> SamB: Yep, Cale has.
16:28:27 <SamB> or maybe just the feature of supporting monad transformers
16:28:48 <SamB> okay ;-).
16:29:17 <SamB> I thought so, but the status field went back to a boring default, so I was a little worried...
16:32:20 <ADEpt> @djinn b -> (a,b) -> Maybe a
16:32:20 <lambdabot> f _ (a, _) = Just a
16:32:41 <ADEpt> lazy djinn :)
16:34:50 <Cale> @djinn b -> (a -> b) -> Maybe a -> b
16:34:50 <lambdabot> f a b c =
16:34:50 <lambdabot>   case c of
16:34:50 <lambdabot>   Nothing -> a
16:34:50 <lambdabot>   Just d -> b d
16:39:21 <work_metaperl> can I get some help with my attempt to use _forward_ lookup: http://rafb.net/paste/results/8Bwlza60.html
16:39:23 <work_metaperl> please
16:40:28 <work_metaperl> pretty please
16:40:35 <work_metaperl> pretty pretty please with ice cream on top
16:41:01 <Cale> hm?
16:41:12 <work_metaperl> I'm getting the error listed
16:41:13 <work_metaperl> http://rafb.net/paste/results/8Bwlza60.html
16:42:01 <Cale> okay
16:42:08 <ADEpt> Lemmih: i know where I got that idea about dcoutts - see mail <1147259949.14157.142.camel@localhost> in soc-haskell ml
16:42:22 <Cale> so what's the type of codeToState?
16:42:30 <work_metaperl> hmm
16:42:53 <work_metaperl> IO [(String,String)]
16:42:54 <work_metaperl> I think
16:43:22 <work_metaperl> *Main> :t codeToState 
16:43:22 <work_metaperl> codeToState :: IO [([Char], [Char])] 
16:43:26 <Cale> right
16:43:42 <work_metaperl> is that the same as IO [(String, String)]
16:43:47 <Cale> yes
16:43:55 <Cale> so fmap has to take a function from [(String,String)] to something
16:44:11 <work_metaperl> @type fmap
16:44:12 <lambdabot> forall (f :: * -> *) b a.
16:44:12 <lambdabot>    (Functor f) =>
16:44:12 <lambdabot>    (a -> b) -> f a -> f b
16:44:15 <ADEpt> from IO [(String, String)]
16:44:28 <Cale> ADEpt: no
16:44:34 <work_metaperl> no, he means the first argument to fmap
16:44:48 <work_metaperl> must be ([String,String] -> b)
16:44:59 <work_metaperl> rgiht?
16:45:01 <Cale> right
16:45:05 <work_metaperl> ok...
16:45:20 <Cale> in this case, b is String
16:45:32 <work_metaperl> yes a == b
16:45:37 <Cale> hm?
16:45:43 <work_metaperl> for (a -> b)
16:45:47 <work_metaperl> a is the same as b
16:45:48 <Cale> nope
16:45:53 <Cale> [(String,String)] -> String
16:45:55 <work_metaperl> oh right
16:45:56 <work_metaperl> yes
16:46:03 <Cale> is the type of \db -> lookup stateName db
16:46:07 <Cale> okay
16:46:19 <Cale> so, when we apply fmap to that function what's the type?
16:46:28 <Cale> er
16:46:33 <Cale> [(String,String)] -> Maybe String
16:46:34 <work_metaperl> @type lookup
16:46:36 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
16:46:37 <work_metaperl> yes
16:47:18 <work_metaperl> @type fmap (\db lookup "WA" db)
16:47:19 <lambdabot> parse error on input `)'
16:47:27 <work_metaperl> @type fmap (\db -> lookup "WA" db)
16:47:28 <lambdabot> forall (f :: * -> *) b.
16:47:29 <lambdabot>            (Functor f) =>
16:47:29 <lambdabot>            f [([Char], b)] -> f (Maybe b)
16:47:40 <Cale> in this case, f = IO
16:47:42 <work_metaperl> yes
16:47:56 <Cale> now look at the type signature you gave to stateNameFromCode
16:48:10 <work_metaperl> oh
16:48:20 <work_metaperl> IO (Maybe String)
16:48:24 <Cale> right
16:48:35 <work_metaperl> sucks
16:48:38 <work_metaperl> shucks
16:48:45 <work_metaperl> I really just want a string out
16:48:51 <Cale> You probably want to stop working in IO, as this can be reasonably separated from the part of the program which does IO
16:49:16 <work_metaperl> yes, you are right. how to do that?
16:49:23 <Cale> just don't use codeToState, have the stateNameFromCode function take the database as a parameter
16:50:00 <Cale> (of course, this is going to lead to it being the same as lookup)
16:53:59 <work_metaperl> I would ask about separating IO but I'm leaving work in 6 minutes
16:55:03 <Cale> basically, what it comes down to is that you shouldn't do IO in a part of the program whose function doesn't explicitly involve some IO taking place
17:06:10 <jip> how can i learn more about the template haskell optimization technique described here: http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Fraskell/
17:11:31 <Cale> jip: talk to Igloo maybe :)
17:13:27 * jip summons Igloo 
17:56:13 <psi> can't I do this with C->Haskell: {#import Gst.Element#}? It chokes on the '.'.
17:57:02 <psi> "The phrase `.' is not allowed here.". I've seen it used in Gtk2Hs, though.
18:03:10 <ChilliX> psi: c2hs doesn't do hierachical module names yet, sorry
18:03:29 <ChilliX> psi: I know it should. It is just a matter of finding the time to add it.
18:03:32 * SamB doesn't really see the point of Inform 7 generating a .eps of the map on windows...
18:04:30 * SamB opens it in PSP and discovers it looks ugly anyways
18:05:53 * palomer kicks latex
18:06:02 <psi> ChilliX: oh, okay. someone must've done something about it, though, because it is used in the Gtk2Hs sources.
18:06:25 <ChilliX> Maybe the Gtk2Hs fork of c2hs has a patch for it
18:06:59 <ChilliX> dcoutts: Do you know anything about that?
18:07:18 <ChilliX> If so, I'd be happy to add that patch to the mainline, too.
18:08:30 <ChilliX> I'll move the c2hs darcs repo to darcs/haskell.org soon, so that dcoutts can push patches, too.
18:08:41 <ChilliX> I hope that makes the process of getting patches in smoother.
18:09:22 <psi> alright, sounds good
18:48:59 <hyrax42> this is not possible?
18:50:26 <hyrax42> typeTest const = \x -> case x of [(const _)] -> Bool True; _ -> Bool False
18:50:45 <hyrax42> parse error in pattern [(a _)]
18:51:01 <hyrax42> constructors are functions, right?
18:51:13 <edwinb> constructors begin with a captial letter
18:51:22 <hyrax42> ah
18:51:29 <hyrax42> so that should be typeTest A = ...
18:51:29 <hyrax42> ?
18:51:48 <edwinb> (const _) is the problem
18:51:58 <edwinb> what is the type of typeTest?
18:52:20 <edwinb> you can't match on an arbitrary function...
18:52:28 <hyrax42> I want it to be (constructor) -> LispVal
18:52:42 <hyrax42> where Bool is Bool -> LispVal
18:53:12 <hyrax42> because otheriwwe I had this similar shaped code about 5 times
18:53:22 <hyrax42> with each constructor
18:53:32 <hyrax42> I thought I could pass it into a funciton, but seems not?
18:54:07 <edwinb> I'm not sure what const is actually meant to be
18:54:45 <hyrax42> it's just a name for the constructor that is the argument of typeTest
18:54:56 <hyrax42> I was hoping to capture the pattern
18:54:59 <edwinb> ah, I see
18:55:06 <hyrax42> as it was there 5 times
18:55:09 <hyrax42> and I wasn't quite done
18:55:34 <hyrax42> there's no way to match like that, then?
18:55:41 <edwinb> there is probably a way to do it, but that way isn't it unfortunately
18:56:11 <hyrax42> d'oh
18:56:18 <hyrax42> well back to the other style then
18:56:28 <edwinb> maybe define a preduce which is true for all the constructors in that case
18:56:33 <edwinb> preduce?
18:56:36 <edwinb> predicate, even
19:01:45 <hyrax42> well the usage is to create functions like string? = typeTest String (ideally)
19:02:11 <hyrax42> so that string? = \x -> case x of [(String _)] -> True; _ -> False
19:02:19 <hyrax42> and so on for Char and Number
19:02:27 <hyrax42> lots of useless repetition otherwise
19:02:32 <hyrax42> but I'll live with it
19:03:55 <skew> This place has lots of smart people, so I'm going to ask a random question.
19:04:04 <hyrax42> 33
19:04:27 <hyrax42> (preemptive (not-so) random answer to random question)
19:04:31 <hyrax42> (also, I'm not too smart)
19:05:01 <skew> Does anyone know of vision research where they supress the fixational movements of the subject, and impose recording fixational movements from somebody else?
19:05:39 <tato> I'm looking at http://www.haskell.org/hawiki/PermutationExample (I'm a newbie)... is it just my imagination, or do I not have to worry about the fact that all permutations on [1..20] would be impossible to store because haskell is lazy?
19:06:32 <skew> the latter
19:07:11 <tato> so I never have to consult knuth's book on algorithms to generate permutations/tuples??
19:07:16 <tato> thats beautiful
19:07:25 <skew> If you read a little bit about coalgebras and stuff, you see that a plain old list in Haskell is pretty much equivalent to a "generator" in strict languages
19:08:01 <tato> I've done my share of abstract algebra but never 'coalgebra'...
19:08:18 <skew> Knuth might save you a constant factor
19:08:54 <skew> @quote skew
19:08:54 <lambdabot>  Swapping is just a constant factor
19:09:00 <skew> @quote skew
19:09:00 <lambdabot>  I think blackdog is right
19:09:04 <skew> @quote skew
19:09:05 <lambdabot>  We don't believe in constant factors.
19:09:08 <skew> there we go
19:10:10 <audreyt> is form factors more important than constant factors?
19:10:29 <skew> think co of algebra as in algebra
19:10:36 <skew> as in free algebra, rather
19:12:45 <araujo> Hello
19:12:52 <skew> audreyt: Perhaps that's the point of the language
19:13:18 <skew> I'm not quite sure what "form factor" means in the context of a programming language.
19:13:58 <skew> I'm picturing somebody ordering a 2U depedently-typed impure functional language for their server farm.
19:14:34 <audreyt> well, if compilers can be constructed by stacking monads
19:14:46 <audreyt> form factors naturally describes the shape of the stack
19:15:21 <Excedrin> can you get that in 1U? I need a highly dense impure functional language farm
19:16:37 <skew> How about a blade configuration? Get a 7U Haskell system and you can embedd a whole hose of impure functional languages.
19:17:09 <audreyt> I wonder of haskell workshop may some day introduct lightning talks
19:17:16 <audreyt> this would make a killer lighting talk topic
19:17:20 * skew shoes away the spelling gremlins
19:17:54 <audreyt> # http://www.perl.com/pub/a/2004/07/30/lightningtalk.html
19:45:54 <tuxplorer> g'morning :)
20:03:34 <dons> @seen dcoutts
20:03:35 <lambdabot> dcoutts is in #haskell-overflow, #gentoo-haskell, #haskell-blah and #haskell. I last heard dcoutts speak 6 hours, 26 minutes and 23 seconds ago.
20:03:53 <dons> dcoutts_: graph of chunk size versus speed, for a 256k L2 cache: http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
20:04:12 <dons> so, I propose 128k chunk size, which should work, assuming most people have 128k or greater these days
20:04:24 <_metaperl> I need some help making my datatypes IO-free. I read in the database from a file, but I dont want to keep extracting everything in this program the IO monad: http://rafb.net/paste/results/gJD8Qw97.html
20:04:32 <dons> and a comment to tell people to tune it to somewhere between 1/2 and 1x their L2 cache
20:05:25 <Cale> _metaperl: the way to avoid that is to get the db from the file in main, and then pass it as a (pure) parameter to your other functions
20:05:59 <_metaperl> oh ... I dont quite know how to do that
20:06:41 <metaperl> codeFileToLines = fileToLines codeFile -- do this in main?
20:07:53 <metaperl> Cale: how do you do that?
20:09:29 <azuroth> ?eval cos (pi/4)
20:09:30 <lambdabot> 0.7071067811865476
20:10:01 <azuroth> that's a LOT better than "0.99906"... weird.
20:10:36 <dons> > cos (pi/4) -- is nicer syntax these days
20:10:37 <lambdabot> 0.7071067811865476
20:11:04 <azuroth> oh, cool
20:12:19 <araujo> metaperl, only read the DB file from main,  and you could use only pure functions to work around that value.
20:12:49 <metaperl> can you paste a shel transcript?
20:13:02 <metaperl> I dont understand... we Perlers dont ahve to do these things you know :)
20:14:04 <araujo> metaperl, shell script?
20:14:41 <metaperl> no, download my program and rewrite it and then run it from ghci and paste the transcript of what you do so I can imitate
20:14:45 <metaperl> please
20:17:42 <metaperl> oh you mean make an fmap call using it
20:19:45 <araujo> well, i just meant to get the value inside main, and then uses it from thre on with pure functions.
20:22:36 <araujo> > fmap (\ n -> n * n) (return 4 :: IO Int)
20:22:37 <lambdabot> No IO allowed
20:22:59 <araujo> @type fmap (\ n -> n * n) (return 4 :: IO Int)
20:23:00 <lambdabot> IO Int
20:23:45 <skew> what's the problem exactly? Can you design a data type without IO that can represent your data? Can you write a function in IO that reads a file and turns it into a value of that type?
20:25:01 <skew> or are you just looking for general program structure, in which case a decent one is 1) write that stuff I asked about 2) call the reader function in main, and pass the pure value around 
20:27:11 <metaperl> skew: the program is here: http://rafb.net/paste/results/gJD8Qw97.html
20:28:55 <skew> ah, you let IO get too deep into your program
20:29:42 <metaperl> yes
20:29:45 <metaperl> it is my first real program
20:29:59 <skew> I can get to hacking it around in a little while.
20:30:09 <metaperl> ok,
20:30:18 <dons> ?uptime
20:30:18 <lambdabot> uptime: 2 days, 21 hours, 5 minutes and 46 seconds
20:30:30 <dons> lambdabot's very stable this last few weeks.
20:31:05 <skew> In the meantime, try writing a "f :: a -> b" rather than "f' :: IO b, f' = fmap <code for f> constA, where constA :: IO a"
20:40:48 <hyrax42> @hoogle (a -> a -> b) -> [a] -> b
20:40:49 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
20:40:49 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
20:40:49 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
20:41:20 <hyrax42> @hoogle (a -> a -> b) -> [a] -> [b]
20:41:21 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
20:41:21 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
20:41:21 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
20:42:56 <Cale> http://cale.yi.org/autoshare/folds.png :)
20:43:12 <hyrax42> it's been open in a tab for a couple days now :)
20:43:21 <Cale> hehe
20:43:24 <hyrax42> I'm trying to think of a way to take a list of say numbers
20:43:49 <hyrax42> and get a list of bools as result of putting (<) between each
20:43:51 <hyrax42> e.g.
20:44:19 <hyrax42> somefun [1, 2, 3] = [True, True]
20:44:21 <Cale> > let f xs = zipWith (<) xs (drop 1 xs) in f [1,3,2,4,5,1,2]
20:44:22 <lambdabot> [True,False,True,True,False,True]
20:44:31 <Cale> > let f xs = zipWith (<) xs (drop 1 xs) in f [1,2,3]
20:44:32 <lambdabot> [True,True]
20:44:43 <hyrax42> drop is what I was missing
20:45:00 <hyrax42> I'd figured on zipping the list with (<) with itself offset
20:45:14 <hyrax42> but wasn't sure how
20:45:26 * hyrax42 needs more haskell vocab
20:46:43 <Cale> It's sort of funny how everyone who learns Haskell ends up implementing most of the prelude for themselves at least once.
20:48:50 <skew>  you can bypass that by reading it at least twice
20:52:27 <hyrax42> yeah
20:52:36 <hyrax42> I have it open in a tab
20:52:38 <hyrax42> that's almost there
20:52:59 <hyrax42> why isn't it a bird-style lhs
20:53:03 <hyrax42> it's full of comments
20:53:45 <Cale> good point
20:54:17 <hyrax42> I still find the -- line comments a bit strange
20:54:27 <hyrax42> to the eye, that is
21:07:27 <azuroth> > 1 / 0
21:07:27 <lambdabot> Infinity
21:07:40 <azuroth> >(read "Infinity")::Float
21:07:59 <azuroth> how do I do a literal inf?
21:09:38 <mwc> I'd put in 1/0 and trust the compiler to optimize the constant-computer
21:09:43 <mwc> er, constant expression
21:10:01 <azuroth> hmm, okay
21:11:42 <hyrax42> @pl foldr (++) []
21:11:43 <lambdabot> foldr (++) []
21:11:57 <hyrax42> @type foldr (++) []
21:11:58 <lambdabot> forall a. [[a]] -> [a]
21:12:02 <hyrax42> @type concat
21:12:03 <lambdabot> forall a. [[a]] -> [a]
21:17:06 <skew> azuroth: is there some literal you are thinking of that is more compact than 1/0?
21:17:31 <Cale> what are you using the literal infinity for?
21:17:41 <azuroth> no, there wasn't
21:17:49 <skew> you might need braces for esoteric uses like x/inf, I suppose
21:17:51 <azuroth> test cases
21:18:22 <azuroth> 1/0 is fine, but I just thought it was a little weird at first
21:18:36 <Cale> you can define inf = 1/0
21:21:00 <mwc> test cases?
21:21:11 <mwc> there should be functions to use instead
21:21:21 <azuroth> like, assertInf?
21:21:23 <mwc> isInf and the like
21:21:53 <mwc> See the series; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AisNaN
21:22:12 <azuroth> ah okay, cool
21:22:51 <skew> mwc: how does a function like that reduce the need for writing test cases?
21:23:00 <mwc> skew, it doesn
21:23:07 <mwc> it's a preferred way to make the tests though
21:23:24 <hyrax42> Cale: I'm looking at monads as containers again
21:23:33 <mwc> in case there are multiple respresentations of infinity
21:23:46 <hyrax42> the data Tree a = Leaf a | Branch (Tree a) (Tree a) example
21:23:53 <hyrax42> return = Leaf
21:23:57 <skew> oh, to test for null, rather than to test a function on an infinity as input
21:24:01 <hyrax42> (Leaf x) >>= f = f x
21:24:02 <skew> er, est for infinity
21:24:10 <mwc> either way
21:24:12 * skew shakes his fist at the spelling gremlins
21:24:15 <hyrax42> (Branch l r) >>= f = Branch (l >>= f) (r >>= f)
21:24:16 <hyrax42> ?
21:24:24 <Cale> yep
21:24:30 <hyrax42> \o/
21:24:38 <mwc> I woudn't pattern match against  (1/0)
21:24:59 <mwc> Besides, I think 1/0 should give you NaN, shouldn't it?
21:25:00 <skew> Is there a work like "lisper", but for Haskell programmers?
21:25:03 <skew> Haskelleer?
21:25:34 <mwc> What's Lisper?
21:26:18 <hyrax42> the one that comes ot minde is "haskellite"
21:26:26 <hyrax42> but I have no basis for it
21:27:06 <mwc> haskellite sounds like a mineral
21:27:39 <skew> sounds like the stuff you mine to make Haskell programmers
21:28:06 <Cale> I've heard Haskeller, and I remember hearing Haskellite a couple of times, but they're both sort of uncommon for some reason.
21:28:07 <mwc> Hahaha, or the new name for all those .hi files GHC excretes
21:28:20 <mwc> Haskonaut?
21:28:31 <Cale> haha
21:28:36 <skew> mwc: there's just +inf and -inf
21:28:45 <skew> nan is the one with tons of representations
21:28:50 <mwc> yeah, in IEEEE754
21:29:00 <mwc> I just fear making assumptions about FP stuff
21:29:02 <mwc> too many scars
21:29:27 <mwc> PowerPC <-> IA32 <-> SPARC <-> IA64
21:29:55 <Cale> aieee!
21:30:11 <mwc> Cale, in another WTF moment, apparently Lakehead is on Sharcnet now: http://www.sharcnet.ca/
21:30:35 <newsham> currator
21:30:49 <mwc> sorry, Alpha, not sparc. I've never run code on a sparc
21:31:08 <newsham> but you get the register window fun from ia64 anyway
21:31:46 <mwc> Lakehead was the place where the president banned WiFi because he was worried it would give people cancer
21:32:25 <mwc> newsham, yeah, I'm writing a compiler this summer, so I expect to have some fun with assembly
21:33:33 <newsham> fun!
21:34:15 * mwc goes to squash some shift-reduce conflicts
21:34:18 <skew> metaperl: have you worked on your code any?
21:34:25 <newsham> bison?
21:34:35 <mwc> ml-yacc
21:34:45 <skew> mwc: are they the kind that go away with GLR?
21:34:48 <newsham> why people dont use glr?
21:35:44 <mwc> I think I introduced them with all the arithmetic rules
21:35:45 <dbremner> newsham - My guess is that it's because LALR is described in the Dragon book.
21:36:03 <skew> ah, arithmetic rules don't just go away anyway
21:36:26 <skew> stupid stuff like insufficient lookahead sorts itself out, stuff like operator precedence just leaves you a massively nondeterministic parse
21:36:43 <newsham> you can specify precedence
21:36:47 <mwc> yeah
21:36:53 <newsham> and filter it out of the parse rules
21:36:55 <mwc> so I need to figure out why that's not wokring :(
21:37:07 <mwc> 1 Reduce/Reduce and 24 shift/reduce
21:37:38 <dbremner> newsham - GLR parsing is much newer and isn't described in most undergrad textbooks.
21:37:53 <newsham> i know.  but it should be.  time for new books :(
21:39:16 <mwc> looks pretty neat. The forking in the parse stack looks like you'd just need to beat Happy with the List monad
21:40:40 <skew> somebody already did
21:41:00 <skew> actually, they did something a bit smarter that preserves sharing
21:43:20 <skew> "Composing Monads Using Coproducts" is a nice paper so far
21:44:45 <skew> I'm still puzzling out Figure 1
21:48:11 <dons> dcoutts_: I think this works better if I pull from you, rather than you sending me patches to fps. is that ok? is it reasonable to assume you only record stuff that's fit for viewing?
22:21:02 <hyrax42> ngh
22:21:39 <hyrax42> night, even
22:27:52 * palomer kicks latex
22:28:02 <palomer> latex needs some meta-programming facilities
22:28:47 <palomer> there should be a haskell version of latex
22:28:56 <dons> most surely.
22:29:08 <dons> the tex syntax is so awful.
22:29:09 <dons> for one.
22:29:49 <newsham> there should be haskell versions of lots of things :)
22:29:58 <palomer> but especially latex
22:30:03 <newsham> need army of coders
22:30:10 <newsham> i wouldnt mind ssl.
22:30:40 <palomer> let's discuss this Latex monad
22:30:58 <Cale> the tex syntax isn't really all that terrible -- it's just terrible for programming
22:31:11 <palomer> Cale: and you can't do any meta programming
22:31:15 <dons> as soon as you do non-simple things. right.
22:31:30 <palomer> for example, how would you find the size, in inches, of a \begin{foo} ... \end{foo} block?
22:31:34 <dons> and i can never tell when i'm supposed to say \foo[]{} or \foo{}{}
22:31:57 <dons> there's a scheme environment for latex
22:32:08 <dons> where you write scheme stuff that splices in latex
22:32:16 <dons> so that's basically metaprogramming, yeah.
22:32:27 <dons> we could have such a thing too
22:32:52 <Cale> palomer: what would you do with it?
22:33:03 <palomer> enlarge the page size
22:33:06 <palomer> if need be
22:33:21 <lumi> lilypond has scheme underneath
22:34:25 <Cale> the actual size of a \begin...\end block isn't usually predetermined (unless it's explicitly specified) -- it's usually dependent on how large the page and enclosing block are
22:35:11 <Cale> so if you made the page size dependent on it, you'd probably have to recurse
22:35:16 <palomer> my \begin ... \end blocks always run off the page!
22:35:42 <Cale> and you get a nice black slug in the margin?
22:35:51 <palomer> nope
22:36:17 <Cale> well, regardless, the usual solution is to add hyphenating hints to some words
22:36:47 <palomer> hmm?
22:37:14 <palomer> www.magnesium.net/~palomer/ohno.dvi <--example of something running off a page
22:37:27 <Cale> The only time I ever see that happen is generally when you have some long word that it doesn't know about, so it doesn't have the option of breaking it up to even up the lines.
22:37:56 <Cale> ah, okay
22:38:13 <dons> Cale, are you mentoring any SoC projects?
22:38:23 <palomer> and I can't find a solution to it except to find the block size and to change the page size accordingly
22:38:32 <Cale> dons: SamB wanted to do ParsecT, I thought that might be fun
22:38:40 <dons> ok. good.
22:38:57 <Cale> yeah, I suppose it doesn't like to split formulas either (but I'd consider that a good thing, since auto-split formulas are usually split wrong)
22:39:15 <palomer> so now I'm in a pickle
22:39:30 <palomer> because my tex files are computer generated, so I can't simply fiddle around 
22:39:53 <Cale> oh, there's a solution to that, don't computer generate tex files :)
22:40:05 <Cale> hehe
22:40:34 <palomer> gah!
22:40:47 <newsham> a more severe solution would be not to use computers at all.
22:40:49 <Cale> Well, are you planning on ever printing the results?
22:40:51 <newsham> but that hardly seems productive
22:40:52 <palomer> nope
22:41:18 <palomer> they're type derivations
22:41:58 <Cale> then does the page size matter at all?
22:42:03 <palomer> nope
22:42:18 <Cale> You could set it to something like 4000cm
22:42:51 <palomer> and hope the user never inputs a really big term?
22:42:59 <palomer> these type derivations can get pretty nasty, my friend
22:43:11 <Cale> well, what are you doing with the output?
22:43:46 <Cale> like, you could just ignore the page size altogether
22:44:12 <palomer> the output dvi?
22:44:15 <Cale> yeah
22:44:17 <palomer> give it to the user
22:44:26 <palomer> the user inputs a term, I type it and return the type derivation in the form of a dvi
22:44:58 <Cale> Is there any text to speak of, or is it all one huge tree?
22:45:36 <palomer> one huge tree
22:45:46 <Cale> okay, then the page size won't matter at all
22:45:56 <palomer> hmmm?
22:46:00 <palomer> what do you mean?
22:46:26 <Cale> well, it's not like the file stops at the page boundary
22:47:27 <palomer> it does
22:47:30 <palomer> when you try to view it
22:47:43 <Cale> not here
22:47:51 <palomer> using xdvi?
22:47:57 <Cale> yeah
22:48:14 <Cale> though I do get an awkward red line at the page boundary
22:48:32 <palomer> www.magnesium.net/~palomer/ohno2.dvi
22:51:40 <palomer> and I'll probably have my users look at a pdf
22:52:07 <Cale> xdvi -paper a0 ohno2.dvi
22:52:19 <Cale> :)
22:52:37 <Cale> so the data is all there
22:52:56 <palomer> but I can't do that with pdfs
22:55:30 <palomer> and I can't expect my users to have dvi installed
22:55:38 <palomer> and what if the tree is bigger than a0?
22:56:31 <Cale> hold on a sec, let me find the command
22:57:31 <palomer> \special{papersize=30in,30in} <--this sets the page size
22:57:58 <Cale> yeah
22:58:06 <Cale> that's from the tex though
23:05:22 <Cale> hmm
23:07:20 <hyrax42> what structure is FiniteMap?
23:08:22 <palomer> @hoogle FiniteMap
23:08:23 <lambdabot> Data.FiniteMap :: module
23:08:23 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap :: module
23:08:23 <lambdabot> Data.FiniteMap.FiniteMap :: data FiniteMap key elt
23:08:31 <hyrax42> I mean internally
23:08:44 <Cale> hyrax42: a balanced tree
23:08:59 <hyrax42> then would mapping over a FM really be n log n?
23:09:00 <Cale> also, don't use FiniteMap, it's deprecated in favour of Map
23:09:06 <hyrax42> shouldn't it be O(n)
23:09:41 <palomer> iteration over a binary tree is O(n)
23:09:42 <Cale> map :: (a -> b) -> Map k a -> Map k b
23:09:42 <Cale> O(n). Map a function over all values in the map.
23:09:44 <palomer> unless you're an idiot
23:10:10 <hyrax42> well YAHT says FM has O(n log n) map
23:10:20 * palomer doesn't know of a single structure where sequencing is not O(n)
23:10:27 <hyrax42> and says "moderately fast everything (excep tmapping, which is a bit slower than lists or arrays)
23:10:30 <hyrax42> "
23:10:41 <Cale> oh
23:11:01 <Cale> maybe that's with the old FiniteMap
23:11:11 <hyrax42> I suppose the building of the resulting Map would be (possibly) nlog n
23:11:26 <Cale> right
23:11:53 <skew> not for just mapping the values
23:12:02 <skew> changing the keys too is trouble
23:12:28 <Cale> well, mapping the values can be a bit of an issue
23:12:56 <Cale> if, say, the tree didn't actually hold elements in internal nodes
23:13:19 <Cale> (and so there are n log n nodes in the tree)
23:13:34 <Cale> er
23:13:35 <Cale> hmm
23:13:46 <Cale> actually, that's not right
23:14:03 * palomer slaps cale around
23:14:10 <palomer> I might be coming to waterloo in july
23:14:11 <hyrax42> there would be 2n - 1 nodes then
23:14:16 <Cale> right
23:14:46 <Cale> yeah, there's no way you could have over O(n) time
23:14:57 <hyrax42> and given that the resulting Map would ahve ths same keys as the initial one, building the new one can be done in O(n)
23:15:10 <palomer> unless it's programmed by a 7 month old
23:15:28 <palomer> Cale: what command were you looking for?
23:16:03 <Cale> palomer: the command to turn the dvi into an eps without page size information
23:17:06 <Cale> (well, ignoring the original page size information, anyway)
23:17:22 <hyrax42> ok bed time
23:17:23 <hyrax42> night
23:17:24 <Cale> I know that I've done it before, but I can't recall how
23:17:26 <Cale> 'night
23:17:48 <hyrax42> (you could dvi2ps it and modify the ps by hand...)
23:24:14 <Cale> oh hey
23:28:42 <Cale> this works
23:30:39 <Cale> palomer: try wrapping the tree in a  \resizebox{6in}{!}{ ... }
23:30:55 <araujo> Hi
23:31:21 <Cale> that will at least ensure that it won't fall off the page
23:32:46 <Cale> oh, and \usepackage{graphics}
23:33:01 <Cale> hi araujo 
23:35:02 <araujo> Hello Cale :-)
23:38:26 <Cale> palomer: you there?
23:46:01 <palomer> hrmph
23:46:07 <palomer> sorry, was away for a bit
23:46:11 * palomer pokes Cale 
23:46:25 <Cale> yeah, \resizebox is probably what you're looking for
23:46:44 <palomer> usepackage{graphics} doesn't work
23:47:03 <Cale> how about \usepackage{graphicx} ?
23:47:27 <palomer> I think it's the \uspackage command
23:47:28 <ulfdoz> I'd prefer pgf over graphicx.
23:47:32 <palomer> it goes right after the documentclass, right?
23:47:37 <Cale> yeah
23:48:46 <palomer> hrmph
23:49:11 <palomer> http://www.rafb.net/paste/results/iWMb9z38.html
23:49:25 <palomer> that's the error output
23:50:03 <Cale> you're using LaTeX 2.09?
23:50:12 <palomer> yup
23:50:26 <palomer> is this bad?
23:50:59 <Cale> 2.09 is obsolete
23:51:34 <palomer> what replaced it?
23:51:42 <Cale> LaTeX 2e
23:51:52 <Cale> really 2_\epsilon :)
23:52:27 <palomer> hrmph
23:52:51 <Cale> I suppose you add the package name to the documentstyle command in 2.09
23:52:59 <Cale> I've never used 2.09 before, so I'm not sure
23:53:05 <palomer> I managed to get it to work
23:53:12 <palomer> by changing the documentstyle to a documentclass
23:53:17 <Cale> ah, okay :)
23:53:20 <palomer> but it goes over the margin
23:53:37 <Cale> with the resizebox surrounding the tree?
23:53:40 <palomer> yup
23:54:16 <Cale> by less than before?
23:54:18 <palomer> I think latex209==latex2e
23:54:22 <palomer> Cale: same
23:54:25 <Cale> no, certainly not
23:54:33 <Cale> http://www.math.upenn.edu/tex_docs/latex/base/usrguide.dvi
23:54:46 <Cale> that discusses the differences between 2.09 and 2e
23:55:11 <palomer> I can't find latex2e in my apt-cache :/
23:55:15 <palomer> do you think that would fix it?
23:55:16 <Cale> tetex
23:55:44 <Cale> any reasonably recent tetex should come with it
23:55:56 <Cale> (and a ton of packages)
23:57:08 <Cale> It's quite possible that you have LaTeX 2e
23:57:11 <palomer> latex won't even tell me its version
23:57:18 <palomer> yeah, probably
23:57:23 <palomer> running latex mentions latex2e
23:57:26 <ulfdoz> Da hilft nur eins: Richtig besaufen, bis der Krper sagt: "Ich will nicht mehr."
23:57:29 <ulfdoz> ECHAN, sorry
23:57:35 <palomer> (and 209)
23:57:53 <Cale> what does latex -version print?
23:58:15 <Cale> on my system, the first line is pdfeTeX 3.141592-1.21a-2.2 (Web2C 7.5.4)
23:58:29 <palomer> pdfeTeX using libpoppler 3.141592-1.21a-2.2 (Web2C 7.5.4)
23:58:50 <palomer> gah, pdflatex doesn't even output the tree properly!
23:59:09 <Cale> hmm
23:59:14 <palomer> neither does dvi2ps
23:59:15 <Cale> can I have your .tex file?
23:59:25 <palomer> sure
23:59:47 <palomer> http://www.rafb.net/paste/results/7IN8Ys45.html
23:59:51 <palomer> and the sty file:
