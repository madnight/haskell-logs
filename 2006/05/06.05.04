00:00:18 <skew> I think the time gets charged to all lexically enclosing cost centers
00:00:24 <RyanT5000> k
00:00:44 <skew> and if I recall correctly, there's another total elapsed time column which includes forcing other values
00:00:55 <RyanT5000> ah
00:01:24 <skew> everything I know about this kind of stuff I got from reading the user's guide, and maybe using it once or twice
00:01:57 <monochrom> #haskell is so much easier than the user's guide XD
00:02:10 <skew> anybody here know category theory thoroughly?
00:02:14 <Korollary> musasabi: "Even" is a class there, not a type. So you have a bunch of types that are instances of Even, but there's no single type that has all even number values in it.
00:02:27 <RyanT5000> skew: i read the users' guide, but i still wasn't sure
00:02:39 <RyanT5000> tbh i had the right idea, i just wasn't sure of it
00:02:45 <musasabi> Korollary: EvenInt.
00:02:51 <RyanT5000> and since i had no way to really check to make sure i was understanding it, i figured i'd ask
00:03:11 <RyanT5000> that's really a response to monochrom though i guess :P
00:04:03 <monochrom> In fact, going one step further.  Earlier, people were talking about dissolving the old www.haskell.org into a wiki because you get community contribution and dynamic update and democracy that way.
00:04:47 <monochrom> I say, let's even dissolve the haskell wiki into #haskell because you get all those Good Things (TM) even more, to the extreme and logical conclusion.
00:05:22 <Korollary> musasabi: EvenInt doesn't look H98. (data EvenInt where ...??)
00:05:49 <monochrom> Similarly, there is already talk about dissolving the user's guide into a wiki.  But who needs a wiki when there is irc?
00:06:24 <musasabi> Korollary: it is GHC-Haskell (and EvenInt is a GADT)
00:06:47 <musasabi> Korollary: Not sure whether there exists an encoding into Haskell98.
00:07:05 <monochrom> Let me propose that on haskell-cafe and ghc-whatever and see what kind of holy war I will spark. :)
00:07:10 <Korollary> musasabi: Well I said not in H98 earlier didnt I?
00:07:31 <RyanT5000> musasabi you could certainly argue we should have even more bots
00:07:32 <Korollary> I knew gadts could do things like that
00:07:42 <RyanT5000> (aka more plugins for lambdabot)
00:07:44 <RyanT5000> ;)
00:08:10 <skew> I'm reading something that suggests only the trivial category is a cartesian closed category where products satisfy pi_1 (E1,E2) = E1, pi_2 (E1,E2) = E2 and coproducts {f1,f2}.i1 = f1, {f1,f2}.i2 = f2
00:08:44 <Korollary> skew: Which CT book do you have if any? I'd like to get one (possibly Pierce's from what I hear)
00:08:55 <skew> monochrom: we could just have the regulars sitting around, with vast memories.
00:09:07 <skew> a newbie approaches, and then
00:09:40 <musasabi> Korollary: actually it may be possible in H98. "data Even = Z | SucSuc Even", but yes without forall, fitting zero and successive numbers to the same type on the type level won't work.
00:09:48 * skew intones "Haskell is a general purpose, purely functional programming language. Haskell compiler are freely available for almost any computer."
00:10:16 <skew> Korollary: I've got MacLane. I've read maybe three chapters
00:11:19 <monochrom> skew will be our receptionist!
00:11:43 <skew> I'm wondering if that means a theorem that a language with general recursion can't have both nicely behaved products and nicely behaved coproducts
00:11:59 <skew> or if some crazy evaluation strategy could sort that out
00:14:04 <skew> Filinski's master's thesis has all kinds of interesting ideas about duality between values and continuations
00:14:35 <monochrom> Does the Set category satisfy "artesian closed category where products satisfy pi_1 (E1,E2) = E1, pi_2 (E1,E2) = E2 and coproducts {f1,f2}.i1 = f1, {f1,f2}.i2 = f2" ?
00:15:17 <skew> like, why do languages include exceptions = dynamically scoped continuations, but rarely dynamically scoped values
00:16:57 <kzm> With GHCi, is there a way to use :m to bring in modules qualified?
00:17:10 * kzm is trying again...
00:17:16 <monochrom> No I think not, kzm.
00:17:21 <skew> monochrom: I think there's something more about having exponent types
00:17:25 * kzm is frustrated.
00:17:38 <Korollary> kzm: I've never seen it. Maybe if you create a dummy module that does that?
00:17:54 <kzm> I think it should be a H' goal that it should be possible to import libraries unqualified.
00:17:57 <skew> Set might fit
00:18:39 * kzm thinks "this module is intended to be imported qualified" is a bug report :-)
00:19:14 <Korollary> kzm: so how would you resolve the name conflicts?
00:19:41 <monochrom> I think I have been importing libraries unqualified for years.
00:19:44 <kzm> By a) renaming and b) default import modifications
00:20:08 <monochrom> Even those that says in bold print "intended to be qualified".  Of course I do that at my own risk.
00:20:20 <kzm> monochrom, me too.  But alas, the trend is to qualify and module-prefix everything.
00:20:54 <kzm> Well, try it for FPS.  It overloads most List functions, as well as IO (readFile etc)
00:20:55 <monochrom> It is a good sign.
00:21:19 <Korollary> kzm: I don't know. I prefer Set.map over whatever map will be renamed to.
00:22:00 <monochrom> It is a good sign because it means we now have so many libraries and they are so useful that you import a gazillion of them and that the Birthday Paradox kicks in and you must qualify.
00:22:03 <kzm> Well - it is sorta the same operation, conceptually.
00:22:16 <kzm> (why not fmap, btw?  much less likely to conflict)
00:22:47 <monochrom> We have been waiting for this day for years.  We have been bitching "Haskell doesn't have as many libraries as Perl/Python" for a decade.
00:22:53 <kzm> Of course, I didn't like it much before, when everthing was prefixed without the dot: lengthPS emptyMap etc etc
00:23:10 <monochrom> Well if you have as many libraries as Perl you run into the Birthday Paradox.
00:23:16 <Korollary> Well, the ideal a map that is general enough to work over sets imho
00:23:47 <kzm> Too bad the class system is too limited to make it a class member function.
00:23:58 <tennin> what is paradoxical about it?
00:24:00 <kzm> Which would have been the right solution, IMHO.
00:24:24 <monochrom> Nothing!  It's just a name!
00:24:28 <Korollary> tennin: I don't know why it's called the birthdat paradox, but it is.
00:24:34 <Korollary> *day
00:24:47 <kzm> It's a "paradox", because it is counter-intuitive.
00:24:57 <kzm> (for certain values of intuition)
00:24:59 <Korollary> it's not for me heh
00:25:24 <monochrom> Dijkstra also complained, "what's so paradoxical about the barbarer paradox?"
00:25:27 <kzm> That is, my dear Korollary, because you lack intuition.
00:25:30 * kzm is just kidding.
00:25:40 <Korollary> well, there are other paradoxes that are truly paradoxic to me, like Russell's
00:25:40 <dons> yay. functional fused bytestrings!
00:25:55 <monochrom> And me, I find the zeno paradox not paradoxical.
00:26:06 <kzm> Hoooray.  Er...I suppose.
00:27:03 <kzm> And, yay, more single-byte character sets for FPS!  (And they even work correctly this time)
00:27:42 <kzm> UTFs are going to be harder, unless we allow a lot of operations to go from O(1) to O(n).
00:27:54 <Korollary> right after we use it in the shootout, they'll switch to unicode strings in the benchmarks.
00:28:04 <kzm> :-)
00:28:42 <skew> no fair, Haskell programmers use fusion weapons!
00:28:58 <kzm> Anyway, the array-based ByteStrings are going to be much better than [Char] IO regardless.
00:29:15 <Korollary> dons: I believe java's JIT is doing something magical in those benchmarks where it beats C, btw.
00:29:43 <kzm> Black magic, or white?
00:29:56 <Korollary> any magic as long as it works
00:30:56 <Korollary> It is pretty impressive actually. I'd like to read a paper on that one. Although obviously it doesn't scale so java in general doesn't reach C speeds.
00:31:18 <kzm> Any particular benchmarks that are affected?  
00:31:26 * kzm could perhaps just look it up.
00:31:34 <Korollary> the n-body benchmark is the one I am talking about.
00:31:55 <kzm> Hmm.. that is a math-intensive thing?  (Guessing from the name)
00:32:03 <Korollary> I could not have guessed C to be beaten by java (after loading 12Ms more) like that.
00:32:08 <Korollary> yes it is.
00:32:26 <Korollary> planets moving
00:32:43 <ValarQ> i wonder how that magic works...
00:33:42 <Korollary> It must be somehow finding a better ordering of instructions after collecting some performance data or something.
00:33:44 <kzm> Funny thing for Java to optimize... 
00:33:53 <kzm> Found some comments about it via google.
00:34:10 <Korollary> kzm: about what?
00:34:29 <kzm> @google "shootout java n-body"
00:34:31 <lambdabot> http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/134877
00:34:44 <kzm> Hmm...don't remember seeing that one :-)
00:36:23 <Korollary> Yeah, java/c/c# loops look quite alike for that benchmark. Too bad I don't have intel's C compiler.
00:37:17 <Korollary> maybe even gcc can do better if it can be fed profiling data.
00:37:40 <kzm> So Java is tying for first with Clean (but uses 12M vs 0.5M or RAM), GHC is half the speed.
00:37:52 <Korollary> and gcc can be
00:38:04 <kzm> Could it have something to do with SSE, for instance?
00:38:12 <Korollary> right. isn't that something. imagine that it didn't need to load 12M.
00:38:36 <Korollary> I think gcc does generate SSE instructions
00:39:20 <Korollary> with the right arch option, which is given I think in the benchmark entry for C
00:40:36 <kzm> Notice that there seems to be a cluster around 4-5, and another at around 7.  Perhaps they are all pretty good, and SSE is the difference?
00:40:41 * kzm is just guessing.
00:41:35 <Korollary> I think that's unlikely
00:41:53 <ValarQ> very different n-body results on amd compared to intel intel
00:41:58 <neologism> what benchmark are you talking about?
00:41:59 <Korollary> so many different languages. They've got to have quite different overheads.
00:42:08 <Korollary> neologism: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=all
00:42:21 <kzm> For the AMD Sempron (which seems to be much faster than the P4?!), Java is on par with GHC
00:42:45 <Korollary> AMD floating point has been quite faster than intel's for a while now.
00:42:58 <neologism> htnx
00:43:01 <kzm> Korollary, possibly.  It could be that n-body is fairly easy to compile close to optimally.
00:43:11 <kzm> By that much?  Not bad.
00:43:23 <kzm> And a Sempron is pretty low end, too.
00:43:55 * kzm wants to buy a desktop PC with a Turion.  Look ma, no fans!
00:43:57 <ValarQ> not much difference between the top 15 languages thought
00:44:04 <Korollary> kzm: Nowadays the cpu models are crazy, but afaik the low end models mostly lack cache, which wouldnt play a huge role here because the data is small.
00:45:16 <Korollary> kzm: Who can keep this stuff in their head? http://images.tomshardware.com/2005/11/21/the_mother_of_all_cpu_charts_2005/cpu_amd_big.gif
00:45:26 * kzm wonders if the benchmark is really dominated by the math.
00:45:35 <Korollary> argh. broken link.
00:46:00 <kzm> No, worked for me.
00:46:02 <Korollary> kzm: yes, the bm is dominated by cache latency and FP math.
00:46:08 <ValarQ> worked here too
00:46:12 <Korollary> weird.
00:46:14 <kzm> Silly chart, though, because of the socket-based hierarchy.
00:46:33 <Korollary> ok now I got it too
00:46:36 <kzm> The cores will have commonalities orthogonally to the socket they are connected to.
00:47:02 <Korollary> kzm: ok, just focus on  Socket A then. That's still a massive tree.
00:47:20 <Korollary> or 939
00:47:51 <Korollary> I have an AMD64-4000+. I don't know which one it is.
00:48:13 <dons> array fusion rocks. map . map . map : 
00:48:14 <dons> $ time ./unfused < 1M > /dev/null
00:48:15 <dons> ./unfused < 1M > /dev/null  4.45s user 0.88s system 27% cpu 19.110 total
00:48:15 <dons> $ time ./fused < 1M > /dev/null 
00:48:15 <dons> ./fused < 1M > /dev/null  4.06s user 0.37s system 56% cpu 7.837 total
00:48:41 <dons> i love findign ways to make Data.ByteString go faster.
00:49:07 <neologism> dons: good to hear :)
00:49:32 <ValarQ> those shootout entries is going to be very interesting when they introduce smp machines :)
00:51:08 <kzm> Looking at the full data, it seems GHC scales more poorly. 
00:51:22 <kzm> It is faster for small N, but grows more quickly.
00:52:08 <kzm> dons, why the big increase in wall clock time?
00:52:12 <skew> ah, it's a cartesian closed category with fixedpoints that collapses
00:52:45 <kzm> (or the improved CPU utilization)
00:52:59 <dons> kzm, more allocs? since 3 arrays are allocated, versus one?
00:53:14 <dons> so the fused one wins.
00:54:10 <kzm> Won't allocations show up as system time?  Or is the benchmark just waiting for memory to be paged in.
00:54:23 <kzm> Very nice result, no matter.
00:54:58 <kzm> Did you try 10M as well?  Should blow the caches.
00:55:06 <monochrom> skew has collapsed too!
00:55:56 <kzm> went back into his cartesian closet to fix the points, I presume.
00:56:06 <Korollary> Yeah, I just fed gcc its profiling output for optimization and improved from 0m3.758s to 0m3.561s.
00:56:35 <Korollary> and there are a lot of options I didn't even play with
00:56:38 <kzm> Cool!
00:56:58 <kzm> Do you have any way to check what FPU instructions it is using?
00:58:01 <Korollary> I could dump the assembly source, but I don't know the instruction sets that well. The gcc man page does mention SSE, SSE2 & SSE3, tho.
00:58:49 <Korollary> -mtune=pentium4 would give up to SSE2
00:59:38 <Korollary> the official entry has -march=pentium4. That should do it.
01:00:37 <Korollary> But the JIT compiler seems to be able to strip out java array bound checks, etc as well so at this point it' a battle of the backends.
01:00:49 <kzm> I'm no expert, but I think SSE uses instPS and instSS (with inst being some generic instruction, ADD, SUB, MUL etc)
01:04:50 <Korollary> I dont see anything that looks like that
01:05:28 <kzm> Did you try compiling with -optc-fsse2 (Re John M on the mailing list)
01:05:46 <kzm> Oh wait, that's for ghc?
01:19:29 <menki> hey, how do I take a character from input without having to hit enter afterwards?
01:19:44 <kzm> does runhaskell support any way to #define macros from the command line?  (-D?)
01:22:37 <notanotheridiot> menki: try c <- getChar
01:23:27 <menki> yeah, but I still have to hit enter after putting the character in
01:23:49 <liyang> Oh that old issue.
01:24:32 <liyang> You need to switch the terminal to unbuffered character rather than line (buffered) mode.
01:25:32 <menki> is that with HSetBuffering?
01:26:08 <liyang> I've no idea. I've not done anything like that in recent memory. :)
01:26:37 <menki> oh well, its a starting point, thanks
01:29:00 <notanotheridiot> something along the lines of hSetBuffering stdout NoBuffering, I think
01:29:17 <notanotheridiot> stdin, even
01:33:15 <menki> weird, it still waits for an enter
01:37:27 <notanotheridiot> seems to work for me in ghci
01:37:56 <menki> what exactly are you typing?
01:38:34 <notanotheridiot> wrote a short function in a source file then loaded it:
01:39:02 <notanotheridiot> main = do hSetBuffering stdin NoBuffering
01:39:38 <notanotheridiot>           c <- getChar
01:39:49 <notanotheridiot>           putChar c
01:40:16 <notanotheridiot> and any character you enter appears twice
01:41:29 <menki> it works the same for me, only it still waits for an enter
01:42:13 <dcoutts> shapr, do you see that ghc is working on the nokia 770?
01:42:15 <notanotheridiot> are you in hugs? it seems to break for me in hugs
01:42:28 <menki> nope, using ghci 6.4.1
01:43:50 <notanotheridiot> dcoutts: any ideas why line buffering refuses to be disabled in menki's ghci?
01:45:57 <dcoutts> because ghci is doing things to the line buffering?
01:46:41 <notanotheridiot> it seems to work for me though?
01:48:07 <menki> it does the same thing even when I compile it
01:48:16 <Philippa> dcoutts: cool, if I get round to ps2pdfing everything I might even think about getting one then
01:48:49 <Philippa> (acting on it may be another matter ;-)
01:52:57 <menki> it should be noted that I am doing this in windows, so that might be contributing to the problem
01:53:04 <dcoutts> I'm sure it does
02:03:39 <dons> i am such a fan of array fusion now.
02:03:55 <dons> $ time ./fused < 20M                                                   
02:03:55 <dons> 16777216
02:03:55 <dons> ./fused < 20M  0.68s user 0.15s system 51% cpu 1.621 total
02:03:55 <dons> $ time ./unfused < 20M
02:03:55 <dons> 16777216
02:03:57 <dons> ./unfused < 20M  2.58s user 0.26s system 66% cpu 4.272 total
02:04:20 <dcoutts> dons, oooh, nice
02:04:29 <dcoutts> is that using RULEs ?
02:04:41 <dcoutts> what fusion is going on exactly?
02:04:52 <dons> RULEs and the loopU combinator from the nested data parallelism stuff
02:04:59 * dcoutts clamours for details from the mighty dons optimiser
02:05:20 <dons> you encode all your list stuff as a combination of loopUs
02:05:39 <dons> and then come up with some rewwrite RULEs that combine filters/folds/and loops into single loops 
02:05:50 <dcoutts> cool
02:06:12 <dcoutts> so what kind of high level ByteString functions can be fused?
02:06:17 <dons> loopU itself is a map with an accumulator and a halt. a bit like unfoldr.
02:06:30 <dons> and since everything reduces to loopU, its easy to pattern match RULEs on it.
02:07:31 <dcoutts> so most fpd functions are actually implemented in terms of loopU ?
02:07:54 <dcoutts> pfd/fps
02:07:55 <dons> extensible compiler optimisatiso, in the above, B.map (*4) . B.map (+2) . B.map (subtract 3) . B.map (+1) . B.map (*7) becomes map (*4).(-3) ..)
02:08:07 <dons> well, some are. I think. filter/folds/ map/and anything that looks like them
02:08:15 <dcoutts> right
02:08:21 <dcoutts> @where fps
02:08:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
02:08:36 <dcoutts> heh, nice icon
02:08:40 <dons> hehe
02:08:40 <dcoutts> zoom!
02:08:55 <dons> the loopU stuff isn't in the main branch yet, just fusion on maps only.
02:09:08 <dons> i plan to push the rest of it intothe head over the weekend, fingers crossed.
02:09:54 <dcoutts> nice
02:11:17 <dcoutts> so which shootout benchmarks can we improve with fps?
02:12:01 <dcoutts> the regexp one if we do a fps regexp binding
02:12:03 <dons> I think knuc, fasta, hmm, reverse-something-or-other
02:12:04 <huwr> woo.
02:12:15 <dons> the ones that are really long winded atm.
02:13:12 <dcoutts> dons, I was thinking that one function that'd be handy for fps IO that makes no sense for lazy IO is a more lazy version of hGetContents
02:13:19 <dcoutts> that gives a lazy list of big chunks
02:13:27 <dons> yeah, I saw the discussion.
02:13:31 <dcoutts> eg it'd do 4k block reads
02:13:35 <dcoutts> or 16k or whatever
02:13:54 <dons> we definitely need a way to lazily get more data than fits in ram
02:14:00 <dons> so I should take the lazy getContents back from darcs.
02:14:19 <dcoutts> what is that?
02:14:44 <dons> oh, there's some lazy io stuff igloo wrote
02:15:21 <dons> ah, for gz stuff
02:15:25 <dcoutts> but I mean, you can't have a lazy ByteString (unless it's using OS mmap facilities)
02:15:36 <dcoutts> the nearest thing is a list of chunks
02:15:48 <dons> right
02:16:02 <dons> LazyByteString = [ByteString]
02:16:23 <dons> now, how to make that useful?
02:16:59 <dcoutts> dons, sorry, I've gotta go..
02:22:55 <dons>   
02:25:41 <menki> well, it has 'Non-blocking IO for Windows' in the haskell annual report for 2002 under the ghc 'still on the agenda' list, so maybe it just isnt done yet
02:30:09 <kzm> dons, actually, I suspect that for UTF8, it would be nice to store a list of chunks as well.
02:30:56 <kzm> At least for western text, where the high chars are rare.  If the chunks store the lenght in chars as well as the length in bytes, it should be easy to speed up a few things.
02:31:40 <kzm> (pack must examine the whole string before doing the packing?)
02:32:03 <kzm> (to determine the length before creating the array, which is then populated?)
02:33:16 <norpan> hi
02:33:34 <norpan> i made a ByteString.UTF8 module
02:33:40 <norpan> but only implemented a few operations yet
02:34:04 <norpan> storing the length in chars would be great but for example for mmapFile it's not feasible
02:34:35 <norpan> (and mmapFile is the only reason i bothered with ByteString at all) :)
02:43:39 <kzm> norpan, interesting!
02:44:15 <kzm> The nice property of the single-byte charsets is that you can always fit them in Unicode.
02:44:16 <JohnMeacham> norpan: why is it not feasable?
02:44:30 <kzm> I.e. ByteStrings are a subset of Unicode
02:44:38 <kzm> With UTF, it's the opposite.
02:44:47 <norpan> JohnMeacham: because it means you have to examine the whole mmaped area
02:44:49 <JohnMeacham> kzm: bytestrings are just bytestrings.
02:45:07 <norpan> of course it could be done lazily
02:45:16 <JohnMeacham> norpan: but we have a lazy language. no need ot example the whole area unless it is actually needede.
02:45:19 <norpan> so maybe it is feasible
02:46:06 <norpan> but in any case it means you have to extend the ByteString type and so it will not be as easily compatible with plain ByteStrings
02:46:08 <kzm> JohnMeacham, yes, but what I mean is that  pack.unpack will always work (and be d)
02:46:16 <kzm> pack . unpack == id
02:46:35 <kzm> For utf-8, unpack may fail.  However, pack will always succeed.
02:46:57 <JohnMeacham> kzm: even if the string has chars > 127?
02:47:06 <kzm> Certainly.
02:47:07 <norpan> for utf-8 yes
02:47:13 <norpan> that's the whole point with it
02:47:37 <norpan> i've implemented pack and unpack
02:47:41 <kzm> norpan: For utf-8, no :-)
02:48:01 <norpan> unpack may fail, i was saying yes to john
02:48:12 <kzm> JohnMeacham, for ASCII, I stack >127 into an unused area (0xF000..)
02:48:22 <kzm> pack will put them back, of course.
02:48:53 <kzm> For Latin1, it's the trivial mapping, for others, it is more arbitrary.
02:48:58 <norpan> my unpack may fail with overlong, illegal, out-of-range, and too-short
02:49:22 <kzm> Do you have a darcs repository I can pull from?
02:49:31 <norpan> hehe not yet
02:49:32 <kzm> And did you do any benchmarks?
02:49:43 <norpan> no, i've just implemented pack, unpack, head and tail :)
02:50:02 <norpan> which was what i needed
02:50:04 <kzm> I've run the benchmarks using binary input, it is much more interesting.  Anybody can handle ASCII :-)
02:50:54 <kzm> How does pack work?  Do you need to caclulate the byte length first?
02:51:18 <norpan> i convert to a byte list first and then use the normal pack
02:52:08 <norpan> pack :: String -> ByteString
02:52:09 <norpan> pack s = B.pack (U.encodeString s)
02:52:28 <kzm> Hmm.. is it easy to tell from the code point the number of bytes it will use?
02:52:36 <norpan> yes
02:52:58 <norpan> so it should be possible to make it better
02:53:29 <kzm> So to convert some encoding to UTF-8, you could do without any explicit intermediate O(n) data.
02:53:38 <norpan> 0-0x7f 1 byte, 0x80-0x7ff 2 bytes, 0x800-0xffff 3 bytes, 0x10000-0x10ffff 4 bytes
02:54:07 <kzm> I.e. lazy/GC'ed unpack & count, create, unpack & insert
02:54:14 <kzm> Right.  Very nice.
02:54:33 <norpan> it's very interesting that unicode stops at 0x10ffff
02:54:37 <norpan> a very odd place to stop
02:55:07 <kzm> Hmm...is there space inside four bytes for more (with the UTF encoding, that is)
02:56:04 <norpan> yes, four bytes can hold 21 bits
02:56:43 <kzm> One property that I quite like, is that I can store illegal values as well.  E.g. the stashing of >128 in 0xF000 for ASCII.
02:57:26 <kzm> It would be nice to do that for UTF-8 as well, store illegal sequences somewhere, somehow.
02:57:54 <norpan> well if a Char is 32 bits in implementation that should be possible
02:58:04 <kzm> Of course, you only need a range of unused Chars not representable in UTF-8 to do it.  Minimum two unused chars, but 256 would be nice :-)
02:58:20 <kzm> That way pack . unpack could still be "id"
02:58:35 <norpan> sequences can be illegal in many ways
02:58:48 <norpan> but sure you can store them using many Chars
02:58:53 <kzm> It may void your warranty though.  (length and friends would no longer work quite reliably)
02:59:17 <norpan> I'm settling for unpack giving an error (throwing?) with illegal sequences
02:59:53 <kzm> Fine by me.
03:00:22 <kzm> One could also imagine another, looser module (UTF8_loose?)
03:00:23 <norpan> it's easy enough to do a slow implementation of UTF-8
03:00:43 <norpan> or just a loose version of unpack, head, tail
03:01:09 <norpan> and some more
03:01:11 <kzm> Yep.  #include is your friend.  Or at least it pretends to be.
03:01:32 <kzm> Look at my repo for some modest use of it. :-)
03:01:34 <norpan> it is?
03:01:39 <kzm> Must go to lunch now.
03:02:20 <kzm> (yes, well, I have a huge chunk of code that is #included.  To add a new charset, you only need to declare it as a list of codepoints, and include a couple of files)
03:02:45 <kzm> Very simple, and speed is all right, but not optimal, of course.
03:03:25 <kzm> And darcs is awesome, the #included part is basically dons's Char8 module, so when he adds stuff, it just slides right in.
03:03:37 <kzm> Must eat.  Now.
03:17:59 <huwr> Is anyone here from the ANU?
03:22:20 <joelr1> good morning! has anyone successfully checked out haskell-libs from source forge? it does not let me log in
03:51:33 <adept> good day. Does someone know whether it is possible to do a "darcs get u@host:/repo" over several ssh hops?
03:51:53 <musasabi> adept: you can setup ssh to forward connnections.
03:52:07 <musasabi> adept: see -R and -L from ssh documentation.
03:53:04 <adept> musasabi: but then i'll be 'darcs get'-ing from localhost, right?
03:53:27 <musasabi> yes
03:53:46 <adept> musasabi: if I need this ssh trickery only once in a while (working on a notebook, in different networks) that would mean ... But wait... Thank you :)
03:54:21 <adept> musasabi: I was trying to do something with ProxyCommand (from .ssh/config) and completely forgot about port forwarding :) thanks
04:09:36 <dozer> got a question about mapping functions and monads
04:10:33 <dozer> say I have the datatype Pair a b = Left a | Right b
04:10:57 <dozer> and functions to transform a1->m a2, b1-> m b2, in the monad m
04:11:38 <morans> ...
04:12:18 <dozer> then write mapPair :: Monad m => (a1 -> m a2) -> (b1 -> m b2) -> Pair a1 b1 -> Pair a2 b2
04:12:29 <dozer> oops
04:12:48 <dozer> mapPair :: Monad m => (a1 -> m a2) -> (b1 -> m b2) -> Pair a1 b1 -> m Pair a2 b2
04:13:35 <dozer> that's better... so I don't realy get how to write this function so that it will combine the failure outcomes of the two nested mapping functions propperly
04:13:49 <dozer> fail on mapping either the a's or the b's results in fail for the overall mapping
04:18:05 <Igloo> dons: The layz IO stuff in darcs isn't just for gz files. You also might want Stringalike.lhs or whatever it's called
04:18:13 <morans> hmm, mapPair f1  f2  (Pair a1 b1) = do { x<- f1 a1; y<-f2 b1 ; return Pair x y } 
04:18:24 <morans> does that work?
04:18:31 <morans> brain is alive properly yet
04:18:57 <dozer> ah ok - so the do and the <- will take care of all this for me?
04:19:13 * dozer starts to see the point of monads
04:19:23 * morans thinks so
04:19:59 <morans> dozer: what I wrote means something like "first do the f1 action on the a1 value, then after that do the f2 action on the b1 value, and then combine the results into a pair
04:20:23 <morans> if you look at it in imperitive style
04:21:10 * morans never really used monad fail
04:23:57 <adept> @seen vincenz
04:23:58 <lambdabot> vincenz is in #haskell-blah and #haskell. I last heard vincenz speak 11 hours, 46 minutes and 30 seconds ago.
04:26:24 <morans> > fail "oh dear" >> Just 8
04:26:25 <lambdabot> Nothing
04:26:46 <morans> dozer: I think thats the behaviour you want (Nothing is failure in Maybe)
04:27:49 <dozer> thanks - will give this a spin
04:29:09 <musasabi> Igloo: is that just [ByteString] + unsafeInterleaveIO ?
04:29:18 <musasabi> (which is what I am using)
04:30:17 <Igloo> musasabi: Yes, it would just mean you had all the normal string functions defined on it for you
04:30:42 <Igloo> musasabi: And where possible the file would just be mmapped instead, so would be faster
04:32:17 <musasabi> Igloo: I think mmap is a bad idea for Haskell. It means blocking all thread without SMP.
04:32:44 <Igloo> musasabi: How do you mean?
04:34:17 <musasabi> Igloo: 1) Haskell thread issues "mmap file F", 2) sometime later when using the string when memory is accessed the OS thread is stopped while the OS fetches the data from disk.
04:35:22 <Igloo> Is that different in the case of an unsafeInterleaveIO read of a non-mmaped file?
04:35:37 <musasabi> The problem is stopping the OS thread while running Haskell and every haskell thread freezing.
04:35:41 <musasabi> completely.
04:36:10 <musasabi> with unsafeInterleaveIO when the IO occurs the rts just performs calls and other haskell threads continue to run.
04:37:38 <Igloo> Ah, I see
05:03:52 <timbod> Any ghc + debian users about?
05:08:46 * morans once compiled a haskell program using ghc on debian.
05:09:59 <morans> not much though
05:09:59 <adept> timbod: yes?
05:10:41 <timbod> adept: which version are you currently using? I'm on 6.4.1, but I'm wondering if 6.4.2 is out there somewhere...
05:11:24 <wilx> Hmm. About the threads, that is basically a problem with forkIO on *nix with GHC? Does it mean GHC does not use Pthreads like it does use Windows threads on Windows?
05:12:36 <adept> timbod: $ apt-cache policy ghc6  
05:12:36 <adept> ghc6:
05:12:36 <adept>   Installed: 6.4.1-2.1
05:12:36 <adept>   Candidate: 6.4.1-2.1
05:12:42 <adept> timbod: apparently, not yet
05:13:15 <adept> timbod: you could try searching on apt-get.org, but i doubt it
05:14:47 <adept> timbod: you could try asking Igloo about it
05:15:18 <chessguy> if a ticket at http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority is assigned, does that mean i probably shouldn't propose doing it for the summer of code?
05:16:05 <timbod> adept: I was hoping that it would be present in the haskell-unsafe debian package repo, but it doesn't seem to be there either :-(
05:17:45 <adept> timbod: well, build for yourself ;)
05:18:48 <timbod> adept: I was being lazy, but that's probably better than waiting someone else to build the .deb
05:25:07 <malomalote> hi
05:26:05 <adept> malomalote: hi
05:34:32 <xerox> G'day.
05:37:23 <timbod> Any avid users of cabal around? I've got (what I think is) an easy question on usage...
05:37:37 <adept> timbod: shoot
05:38:24 <timbod> If I am developing a library (which is in a heirarchical tree) do I need to install it each time I want to construct test harnesses that exercise the library? Is there an easy way to use the library code in place?
05:40:07 <kzm> Um... I do the former.  Admittedly, I'm just using somebody else's cabal stuff, but I do build and install, and then run tests.
05:40:15 <eivuokko> Yeah, that's usually the easiest option.
05:40:18 <kzm> (which are rebuilt with the new library versions)
05:40:43 <kzm> But I'd love to hear if it is possible to use runhaskell with CPP?
05:40:55 <adept> timbod: you can install to "."
05:41:04 <timbod> It just seems a bit heavy handed to have edit a library source file, then build install the who library, in order to build/run a test harness
05:41:13 <timbod> adept: how do you do that?
05:41:40 <adept> timbod:
05:41:40 <adept> runhaskell Setup.hs configure --prefix=. --user -p
05:41:40 <adept> runhaskell Setup.hs build
05:41:40 <adept> runhaskell Setup.hs install
05:41:50 <kzm> Well - you obviously need to build it anyway, the install is really quick.  Not much of a hassle.
05:42:05 <kzm> ...at least not compared to actually figuring out how to get around it. :-)
05:42:21 <timbod> It's the sudo command that bugs me for the install. For some reason --user doesn't seem to work for me.
05:43:38 <adept> timbod: define "doesn't seem to work"
05:44:01 <eivuokko> Did you use --user with setup install or setup configure?
05:44:38 <eivuokko> (Unless you are using very newest cabal from darcs, you should use it with setup install)
05:44:55 <Lemmih> JaffaCake: ping.
05:45:17 <JaffaCake> Lemmih: hi there
05:45:33 <timbod> eivuokko: I tried either. This is with the version of cabal that comes with ghc 6.4.1 which is quite old now I think.
05:46:23 <eivuokko> It should work.  It has worked for me, I am pretty sure.
05:46:50 <eivuokko> You could also try handcrafting/copying package database and using GHC_PACKAGE_PATH
05:47:37 <eivuokko> Or ghc flag that uses extra package database.
05:48:00 <kzm> eivuokko, timbod, I think I used --user for both: configure --user and install --user.
05:48:15 <kzm> Worked for me (in the end).
05:48:27 <kzm> Also 6.4.1, btw.
05:49:19 <JaffaCake> Lemmih: did you want something? :)
05:50:13 <timbod> kzm, eivuokko: what do you see if you go "ghc-pkg list" and "ghc-pkg list --user"? I see the same thing in both cases - a list of packages under the path /usr/lib/ghc-6.4.1/package.conf, but no reference to a package.conf in my home directory
05:51:19 <eivuokko> timbod, ghc-pkg helps says that list --user shows *additionally* the packages listed in user database
05:51:42 <eivuokko> (At least it does for me, but it's ghc 6.4.2)
05:52:07 <Lemmih> JaffaCake: You talked about a minimal form of CCS for providing a stack-trace on breakpoints and exceptions. Will it give more/better information than +RTS -xc (I know profiling and ghci doesn't mix, lets put that aside for a moment)?
05:52:31 <JaffaCake> Lemmih: I hope, better information
05:52:44 <JaffaCake> +RTS -xc goes wrong at CAFs, usually
05:53:04 <timbod> on my mac, however, (which has 6.4.2 to confuse the issue), I see packages under the system path, and no package (but the path still mentioned) in my home dir.
05:54:06 <timbod> Is GHC_PACKAGE_PATH set to anything on anyones debian system?
05:54:25 <morans> not on mine.
05:54:34 <eivuokko> That'd sound evil
05:54:50 <morans> timbod: not on mine
05:55:18 <eivuokko> Anyway, not on debian system I can access.
05:55:39 <Lemmih> JaffaCake: Okay, thanks.
05:59:19 <dcoutts_> JaffaCake, so do you think that ghc-reconf thing is going the right direction?
05:59:41 <JaffaCake> yes, on the whole
06:00:04 <JaffaCake> it's a bit verbose, unfortunately
06:00:07 <JaffaCake> but that's ok
06:00:23 <eivuokko> dcoutts, JaffaCake, will ghc-reconf be able to change gcc paths on Windows?
06:00:53 <dcoutts_> JaffaCake, ok. I'd prefer if more of the tests could be dynamic, rather than comming from #ifdefs.
06:01:06 <JaffaCake> sure
06:01:25 <JaffaCake> eivuokko: no, there isn't a way to do that
06:01:32 <eivuokko> Sucks.
06:01:38 <JaffaCake> eivuokko: other than by passing -pgmc on the command line
06:01:55 <dcoutts_> that could be put into the rts package
06:02:18 <JaffaCake> dcoutts_: not any more, we don't have a way to put -pgmc options in a package config
06:02:20 <timbod> Well cabal & --user has me stumped. http://pastebin.com/697921 shows the log when I try it for HDBC (a package that builds and installs fine to the system location with sudo).
06:02:23 <dcoutts_> ghc-options: "-pgmc" ?
06:02:30 <dcoutts_> did ghc-options go away?
06:02:35 <JaffaCake> yes
06:02:37 <dcoutts_> oh ok
06:02:39 <eivuokko> Ah.
06:02:54 <JaffaCake> that was one good use for ghc-options, but there were a lot of bad uses for it too
06:03:00 <dcoutts_> JaffaCake, yeah probably a good idea.
06:03:03 <eivuokko> If I recall correctly, it was impossible to use -pgmc in Windows anyway
06:03:05 <dcoutts_> I saw several bad uses
06:03:16 <dcoutts_> *cough* wash *cough*
06:03:23 <JaffaCake> in fact we had considered using ghc-options to pass all the -pgmX options, and do away with compiler/main/SysTools.hs
06:03:49 <dcoutts_> JaffaCake, you could make an exception for the rts package? rts-magic: ...
06:03:56 <JaffaCake> maybe
06:04:07 <dcoutts_> and just not allow it elsewhere
06:04:30 <eivuokko> It is suprisingly hard to compile and install ghc from mingw that doesn't have same paths as <insert some past mingw version>.
06:04:45 * dcoutts_ has to go teach
06:04:45 <JaffaCake> right
06:05:12 <dcoutts_> dons, I was thinking more about the ByteString.Lazy earlier, I'd like to chat about it some time.
06:05:17 * dcoutts_ &
06:05:19 <JaffaCake> eivuokko: you mean the gcc-lib/ layout
06:05:50 <eivuokko> JaffaCake, yes, that too.  I also have "often" got very wierd crashes if I use mingw gcc and not gcc from previous ghc.
06:06:38 <JaffaCake> mingw gcc has some stability problems, yes
06:06:48 <JaffaCake> and probably some subtle dependencies
06:07:43 <eivuokko> I really wish ghc would just include mingw-tree on it and use the paths on it, that way it would be much easier to work on it.
06:08:11 <JaffaCake> eivuokko: could you elaborate? what's mingw-tree?
06:08:22 <eivuokko> JaffaCake, the layout mingw packages have
06:08:50 <eivuokko> JaffaCake, it is almost impossible to say ghc is production quality in Windows.  For example strip is missing, iirc.
06:09:59 <eivuokko> Also tools to make import libraries are pretty neccesary.  And all of this is very hard to detect correctly in Cabal, unless you have msys and use autotools.
06:10:07 <JaffaCake> GHC is certainly slightly more flaky on Windows than other platforms
06:10:14 <JaffaCake> which is why I don't use it :)
06:10:50 <JaffaCake> eivuokko: if you want strip.exe, I'm sure we could add that
06:10:52 <eivuokko> I'd love to make patches...but I have been lazy lately and last time darcs ghc was way broken.
06:11:16 <JaffaCake> I think darcs ghc is ok on Windows right now, I built it recently
06:11:27 <eivuokko> Built?  Did concurrency work?
06:11:38 <JaffaCake> yes
06:11:47 <eivuokko> I should try running testsuite again on Windows
06:11:51 <eivuokko> I never managed to do that
06:11:54 <JaffaCake> please do
06:11:58 <JaffaCake> it works here
06:12:17 <eivuokko> Any sensible spec for mingw/other software you installed?
06:12:37 <JaffaCake> I have the latest mingw package (the one with everything included, IIRC)
06:12:37 <eivuokko> Or just "latest at the time installing"?
06:12:38 <dons> dcoutts_: mail me your ideas. i'm interested.
06:12:58 <eivuokko> JaffaCake, That is very vague, isn't it?  You mean the mingw package that contains "everything"?
06:13:22 <ADEpt> is there a deb for gtk2hs ?
06:13:25 <JaffaCake> eivuokko: hang on, I'll go check
06:13:35 <eivuokko> JaffaCake, I think that is very old package, and nowdays they just ship all components on diffrent packages.  I have like ten+ packages.
06:14:07 <JaffaCake> oh, ok
06:14:14 <JaffaCake> I have MingW 5.0.2, I think
06:14:49 <JaffaCake> it's dated Feb 12 2006 on the mingw download page
06:14:58 <eivuokko> Ah
06:15:19 <eivuokko> I guess I'll change into that.  sounds new enough
06:23:41 <timbod> adept: I built gtk2hs from source under debian
06:24:40 <ADEpt> into .deb?
06:27:48 <timbod> no - just installed it via cabal. What would be the advantage in building a deb (not that I would know how).
06:35:29 <norpan> init, tail, and map are tricky with UTF-8 byte strings
06:35:42 <norpan> esp map
06:36:49 <norpan> i mean last of course, not tail
06:37:18 <xerox> Why?
06:39:53 <ibid> yeah, why - UTF-8 character boundaries are easy to find, even if you don't know where they are
06:40:40 <kzm> Hmm... when in doubt, I unpack, apply list equivalent, and pack.
06:40:44 <kzm> Optimize later :-)
06:47:13 <norpan> well, difficulty depends on the semantics of course
06:47:32 <norpan> it's easy enough to follow 10xxxxxx bytes backwards
06:48:05 <norpan> it was not as hard as i expected :)
06:48:26 <norpan> map is just pack . map f . unpack
06:48:39 <norpan> for now :)
06:50:09 <norpan> likewise for reverse and friends
06:52:33 <xerox> pack . (. unpack) . map
06:53:40 <norpan> i like the other notation better :)
06:55:03 <DeliQ> @type pack
06:55:04 <lambdabot> Not in scope: `pack'
06:55:20 <xerox> ?where fps
06:55:20 <DeliQ> @index pack
06:55:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:55:20 <lambdabot> bzzt
06:55:33 <xerox> Crawl that darcs repo.
06:56:45 <DeliQ> i see, thought it was a standard function
06:57:26 <xerox> It packs a String to into a FastPackedString.
06:58:10 <xerox> (aka ByteString)
07:12:42 <kzm> norpan - what is the likelyhood of making your effort available?
07:13:04 <kzm> I have basic UTF encoding/decoding working, but the main effort will be to optimize.
07:13:11 <norpan> right now it's in a state of non-compilation
07:13:45 <kzm> :-)
07:13:54 <kzm> Anyway, it'd be nice to coordinate things a bit.
07:13:57 <norpan> sure
07:14:16 <kzm> I can do the fixed-width UCS codings in the meantime.
07:14:38 <kzm> If you pull my repo, you get the fixed-width single byte encodings I've implemented as well.
07:14:49 <norpan> where is your repo
07:14:55 <kzm> Ah.
07:15:09 <kzm> http://www.ii.uib.no/~ketil/src/fps-i18n
07:15:18 <norpan> greit
07:15:22 <kzm> I try to keep up to date with dons's patches as well.
07:15:26 <kzm> "greit"?
07:15:38 <norpan> så siger mann på norsk
07:15:43 <kzm> Ah, I was worried you were even closer :-)
07:15:56 * kzm hoppet i stolen.
07:16:03 * SamB wonders if he should do more SoC applications
07:17:23 <xerox> Man, did you see how many people there are on the People page?
07:17:30 <xerox> http://hackage.haskell.org/trac/summer-of-code/wiki/People
07:17:46 <kzm> samb: print . interact . eval . apply 
07:18:03 <kzm> (SoC in a haskell nutshell?)
07:19:03 <SamB> kzm: hmm?
07:19:03 <SamB> xerox: yes!
07:19:03 <SamB> xerox: and it scares me!
07:19:21 <SamB> I've done one application for the ParsecT project...
07:19:34 <xerox> Good (-:
07:20:12 <SamB> I wonder if I should apply for more projects, or if I should improve my application for that one...
07:20:23 <kzm> I count 3 admins, 20 mentors, 34 students.  Not bad for a first attempt, I think.
07:20:25 <kzm> :-)
07:20:26 <norpan> kzm: i'll try to clean the code up tonight so that it compiles and passes quickcheck
07:21:08 <kzm> Okay.  I won't commit my UTF code, so my repo should be clean.
07:21:37 <norpan> then we can compare utf8 decoders
07:21:40 <kzm> If you add it to the Bench.hs file (it's fairly straightforward, use an Emacs kbd macro), you get some testing and some numbers.
07:22:13 <kzm> Bah.  I just ripped pesco's encoder, and wrote a simple decoder that, you know, just assumes correct input.
07:22:22 * SamB wonders how you could improve on that map...
07:22:49 <kzm> Hey, life is short, who am I to worry about those miserable, non conformant characters!
07:22:57 <kzm> present company excepted, of course :-)
07:23:20 <norpan> of course
07:25:27 * SamB doesn't remember being utf-8 encoded
07:27:27 <SamB> Hmm. Am thinking you'd average two passes over the data somehow or other, however you implemented map for UTF-8...
07:28:49 <SamB> is there a typeclass for these various stringy types?
07:29:02 <xerox> Yay
07:29:10 <norpan> i have thought about it, but it's hard to make a good class
07:29:13 <xerox> Did you see the project about writing a typechecker for YHC ?
07:29:27 <SamB> yay what?
07:29:41 <norpan> it would have to be a multi parameter type class
07:30:08 <norpan> and you'd have to put a lot of functions in it
07:30:24 <SamB> hmm.
07:30:47 <SamB> what about...
07:31:13 <kzm> http://www.cl.cam.ac.uk/~mgk25/unicode.html#history
07:31:19 <kzm> Explains the 21-bitness
07:31:38 <kzm> ...of Unicode and UTF-8 (when you limit it to four bytes).
07:31:55 <norpan> so you'd have class StringClass c e | c -> e
07:31:58 <norpan> or something
07:32:56 <SamB> class CodedString s where encodeString :: Monad m => String -> m s, decodeString :: Monad m => s -> m String
07:33:26 <norpan> byt ByteString takes [Word8] not String
07:33:46 <SamB> anyway, MPTC aren't the end of the world
07:33:57 <norpan> it's just like IArray
07:34:28 <SamB> not quite
07:35:07 <norpan> well, you'd have to have functional dependencies or generalize the ByteString type
07:36:15 <SamB> a type constructor in IArray must take the element type as an argument
07:36:29 <norpan> yes
07:36:51 <norpan> so either generalize bytestring or make a functional dependency class
07:37:09 <SamB> I'd go with the latter
07:37:25 <norpan> it's not the end of the world to write instance StringClass String Char
07:37:37 <SamB> true
07:37:48 <norpan> as you put it :)
07:38:27 <SamB> but I suppose you'd want a class for coded strings to be a subclass?
07:38:29 <norpan> then you can have instance StringClass ByteArray Word8, instance StringClass UTF8.ByteArray Char
07:38:48 <norpan> well you can always partition it up if you like
07:39:14 <norpan> but i'll implement it first and think classes later :)
07:40:12 <SamB> yes, probably best. I'd just like to see a function to convert my string from one type to another, like fromIntegral ;-)
07:40:15 <norpan> the class would have lot of default members doing pack . unpack
07:40:50 <SamB> I suppose it isn't actually necessary to have a class just for that
07:42:13 <kzm> Of course ByteStrings are ByteStrings, so you can't instantiate it differently in the same class.
07:42:22 <SamB> fromStringy :: (StringClass s1 Char, StringClass s2 Char, Monad m) => s1 -> m s2
07:42:24 <norpan> to be able to override a function (without doing RULES pragma)
07:42:26 <kzm> perhaps one could add a phantom type parameter to it?
07:42:38 <norpan> you need to put in a class at least
07:43:18 <norpan> well as I said, it's not entirely obvious how to do it
07:43:56 <SamB> whatever, I need to go do stuff :-(
07:44:11 <norpan> who doesn't...
08:01:34 <dcoutts_> dons, the idea basically is that it should be possible to build a Data.ByteString.Lazy module that support almost exactly the same operations as Data.ByteString, though with slightly different memory, performance and strictness charactistics
08:02:02 <dcoutts_> dons, eg I expect that it might be possible to make a faster wc using ByteString.Lazy than ByteString
08:02:29 <dcoutts_> since the GC should mean that you don't have more than a few large chunks in memory at once
08:02:45 <dcoutts_> so instead of loading up a 20Mb file into a single ByteString
08:03:04 <dcoutts_> you can process in chunks and get lower memory use
08:03:13 <dcoutts_> which should give better performance
08:03:33 <dcoutts_> it's like the BlockIO library, but more flexible and not quite as quick
08:03:59 <ndm> @paste
08:04:00 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:04:05 <xerox> lisppaste2: url
08:04:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:04:12 <xerox> Hiya dcoutts_ 
08:04:31 <dcoutts_> dons, so the fact that the representation is [ByteString] should be mostly hidden by the functions in the .Lazy module
08:04:39 <dcoutts_> so they should hide the extra complexity
08:04:41 <dcoutts_> hia xerox 
08:05:09 <dcoutts_> dons, and the RULES should still work, some would use list-like rules and some array-like ones
08:05:15 <dcoutts_> or a mixture of both
08:05:34 <dcoutts_> some operations would be faster, eg ++
08:05:39 <dcoutts_> some slower, eg indexing
08:06:25 <dcoutts_> cons would be interesting
08:06:33 <Igloo> dcoutts_, dons: Stringalike in darcs should do that
08:06:42 <dcoutts_> it could be fully lazy, or a mixture
08:06:58 <dcoutts_> Igloo, so what is darcs's Stringalike like?
08:07:05 <lisppaste2> ndm pasted "Type checking issues" at http://paste.lisp.org/display/19667
08:07:06 <dcoutts_> it's a list of packed strings?
08:07:28 <dcoutts_> with ops over them treating it abstractly like a single packed string?
08:07:34 <ndm> anyone able to help me with a type checking problem
08:07:36 <Igloo> dcoutts_: It gives a class including an instance instance Stringalike [PackedString] where
08:07:53 <ndm> i'm not sure where its gone wrong...
08:08:07 <dcoutts_> Igloo, right, and it's lazy.
08:08:57 <Igloo> dcoutts_: Well, the laziness comes from readFileLazily in FastPackedString which returns a
08:09:01 <Igloo> data LazyFile = LazyString String
08:09:03 <Igloo>               | MMappedPackedString PackedString
08:09:06 <Igloo>               | LazyPackedStrings [PackedString]
08:09:43 <dcoutts_> dons, so cons could either just tack a single char on, or it could coalese ByteStrings at the front, that could give O(1) amortised cons.
08:09:45 <dcoutts_> Igloo, I see.
08:11:33 <ndm> ah, solved my type checking issues :)
08:11:37 <dcoutts_> dons, eg imagine a sequence of cons operations. You could do it such that you end up with a sequence of ByteString of sizes 2,4,8, etc and you coalese them as they grow.
08:12:44 * dcoutts_ heads back to lectures
08:21:46 <vincenz> hmm
08:22:01 <vincenz> why does haskell not use monadic comprehension?
08:22:11 <xerox> To not fool n00bs.
08:22:31 <ndm> haskell 1.3 did use that
08:22:39 <vincenz> so why did they remove it?
08:22:55 <vincenz> I'm reading her a certain language named 'gofer' users it
08:22:55 <ndm> the type error messages are too painful if you have a Monad m in there
08:23:12 <ndm> hugs = haskell users gofer system
08:24:06 <vincenz> does gofer still exist
08:24:22 <ndm> don't think its used much any more, if at all
08:24:30 <ndm> but there are probably early versions somewhere...
08:24:49 <vincenz> ok, thx
08:25:23 <ndm> i think ghc might have a flag to use monadic comp's
08:25:26 <ndm> not sure...
08:28:47 <norpan> there is not much demand for monadic comprehension because there is do notation
08:28:51 <norpan> i think
08:30:15 <davidhouse> what would monadic comprehensions look like?
08:30:27 <norpan> the same as list comprehension
08:31:02 <davidhouse> well, list comprehensions are do blocks in the list monad.
08:31:15 <norpan> exactly
08:31:31 <davidhouse> [ f x | x <- xs, p x ] = do x <- xs; guard (p x); return f x
08:31:50 <norpan> which of course is valid for any monad
08:31:57 <davidhouse> yep.
08:32:01 <Lemmih> return (f x)
08:32:09 <davidhouse> oops.
08:32:24 <vincenz> or return . f $ x
08:32:27 <vincenz> Lemmih: hi!
08:33:02 <davidhouse> vincenz: or return $ f x, to be a bit simpler
08:33:12 <davidhouse> vincenz: looked at the newest HTML stuff yet?
08:33:44 <Lemmih> vincenz: Hey!
08:33:47 <norpan> well guard is in MonadPlus so you'd have to require that
08:34:04 <norpan> but you don't have to use guards of course
08:34:40 <davidhouse> @hoogle guard
08:34:40 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
08:34:41 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
08:34:41 <lambdabot> Language.Haskell.TH.Guard :: data Guard
08:35:31 <davidhouse> is it guard p = unless p mzero
08:35:55 <davidhouse> hmm... that makes sense actually.
08:36:10 <norpan> you could of course use fail instead
08:36:18 <davidhouse> well, not quite
08:36:19 <norpan> fail and mzero are the same for most monads
08:36:20 <davidhouse> @hoogle fail
08:36:20 <lambdabot> Prelude.fail :: Monad m => String -> m a
08:36:21 <lambdabot> System.Win32.Types.failIf :: (a -> Bool) -> String -> IO a -> IO a
08:36:21 <lambdabot> System.Win32.Types.failIfFalse_ :: String -> IO Bool -> IO ()
08:36:37 <davidhouse> i suppose you could call fail with a made up string like "guard failed"
08:37:01 <norpan> anyway
08:37:08 <norpan> time to go home
08:40:59 <norpan> wee 21 degrees celcius outside
08:41:01 <norpan> summer time
08:42:26 <vincenz> :)
08:44:49 <vincenz> summar has started indeed
08:44:52 <vincenz> summer even
08:50:41 <JaffaCake> Lemmih: there?
08:51:36 <Lemmih> JaffaCake: Yeah.
09:01:17 <vincenz> How does one user Parsec.Token?
09:02:55 <dozer> is there a standard function that distributes a monad over Maybe?
09:03:43 <davidhouse> dozer, what do you mean?
09:03:51 <dozer> like: case x of Some a -> do { a' <- f a ; return Some a}       None -> do return None
09:04:03 <davidhouse> @type maybe
09:04:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:04:19 <Lemmih> @type fmap
09:04:20 <lambdabot> forall (f :: * -> *) b a.
09:04:20 <lambdabot>    (Functor f) =>
09:04:20 <lambdabot>    (a -> b) -> f a -> f b
09:04:27 <davidhouse> > maybe "nothing" (++ " world") (Just "hello")
09:04:28 <lambdabot> "hello world"
09:04:33 <davidhouse> > maybe "nothing" (++ " world") Nothing
09:04:34 <lambdabot> "nothing"
09:04:50 <Lemmih> > [fmap succ (Just 10), fmap succ Nothing]
09:04:51 <lambdabot> [Just 11,Nothing]
09:06:03 <dozer> ok - so fmap is what I want
09:06:17 <Cale> @hoogle Maybe (m a) -> m (Maybe a)
09:06:18 <lambdabot> Maybe.fromJust :: Maybe a -> a
09:06:18 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
09:06:23 <Cale> hmm
09:06:36 <davidhouse> dozer, incidentally, that works for any monad.
09:06:58 <dozer> yeah - which is kind of neat, and what I probably will want when I re-write this tomorrow
09:06:59 <davidhouse> fmap, that is.
09:07:38 <Cale> @type maybe (return Nothing) (liftM Just)
09:07:39 <lambdabot> forall (m :: * -> *) a1.
09:07:39 <lambdabot>              (Monad m) =>
09:07:39 <lambdabot>              Maybe (m a1) -> m (Maybe a1)
09:07:54 <Cale> that really ought to have a name
09:08:06 <Cale> I suppose it's "sequence" in the new library
09:08:15 <Cale> but that's not there yet :)
09:08:15 <davidhouse> new library?
09:08:34 <Cale> Data.Traversable
09:08:39 <Cale> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Traversable.html
09:09:41 <davidhouse> a generalisation of []?
09:09:52 <Cale> yeah
09:12:17 <Cale> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Foldable.html#t%3AFoldable -- there's also this
09:13:18 * davidhouse peruses the paper
09:13:31 <vincenz> hmm
09:14:44 <Cale> :) comparing is in Data.Ord, that's nice
09:15:04 <vincenz> Cale: I could use some monadic help...
09:15:09 <Cale> vincenz: sure
09:15:21 <vincenz> Cale: basically I'm trying to build a mini simulation engine
09:15:24 <vincenz> with only a few possible actions
09:15:37 <vincenz> I figure that the ideal thing is to use a monad
09:15:52 <Cale> okay
09:15:58 <vincenz> mind if we take this privately?
09:16:07 <Cale> not at all
09:16:19 <chessguy> for simulating what?
09:18:50 <chessguy> hey Cale, i have a question about code generation in general for you, when you have a chance
09:18:59 <xerox> Oh, please don't go private.
09:19:03 <xerox> Monad Construction is fun.
09:19:13 <Cale> chessguy: alright
09:19:42 <chessguy> actually, it's not so much a question as wanting to bounce an idea off you
09:20:31 <chessguy> i've been thinking about borrowing ideas from yacc and XSLT, and developing a method to formally describe the process of translating from one language to another, at the grammar level
09:20:58 <chessguy> (potentially as a Google summer of code projct)
09:21:14 <Cale> that sounds decent -- as a combinator library?
09:21:46 <chessguy> well, i want to develop the theory first, and then it could be implemented anywhere
09:23:25 <dozer> cheesguy: I am doing something vaguely similar with transforming between different OWL (web ontology language) documents
09:24:11 <chessguy2> sorry, got booted
09:24:28 <dozer> cheesguy: the real fun is if you have a query language over documents in one of the grammars, and your transformation rule, can you auto-build the queries in the other grammar
09:25:08 <chessguy2> you mean like transforming SQL to C++?
09:25:23 <dozer> e.g. xpath/xquery over a source schema, xslt to transform it, and then use the xslt to make the xpath/xquery work over the 2nd document
09:25:40 <dozer> swap languages and query languages to taste
09:25:47 <ndm> xslt, yuk!
09:26:05 <chessguy2> well, i wasn't planning on actually using xslt, just the ideas behind it
09:26:18 <ndm> thats fine, the idea behind it is a functional programming language :)
09:27:00 <ndm> but trying to beat lisp with brackets :>
09:27:08 <chessguy2> it might get a little tough translating between a procedural language and a functional language
09:27:34 <ndm> chessguy2: i suspect what you are trying to do is impossible :)
09:27:43 <chessguy2> why is that?
09:27:50 <ndm> chessguy2: consider type classes
09:28:07 <chessguy2> what about them?
09:28:12 <ndm> you could do it between languages like VB.NET and C#, but it would be very hard to do between more
09:28:25 <ndm> type classes mean you will need to typecheck the language first
09:28:54 <ndm> then consider laziness, thats going to be hard
09:29:00 <dozer> it's not always necisary to be able to map everything across, if you can identify a sub-set that you can map, and can show that the subset is useful for something more than toys
09:29:02 <ndm> in the end you'll have written a compiler
09:29:20 <ndm> chessguy2: any idea on whta languages you want to go b etween?
09:29:29 <ndm> i've seen Haskell -> Clean done
09:29:39 <ndm> but Clean -> Haskell would be a lot of work, for example
09:29:49 <chessguy2> the idea is to create a method that can be used to go between any two languages
09:30:00 <chessguy2> source-to-source or even source-to-machine
09:30:16 <ndm> with the aim that the generated source is "readable" ?
09:30:17 <xerox> Clean, hmmm.
09:30:31 <ndm> or that the generated source is compileable?
09:30:43 <chessguy2> well, the first aim should be compileable
09:30:44 <dozer> cheesguy2: any 2 languages is too broad - some clever guys like turing and haskell and church et.al. showed that there is no general solution to this problem
09:30:49 <jethr0> chessguy2: unless i'm wrong you've just recited the concept of a compiler :)
09:31:38 <dozer> chessguy2: without constrains on the two languages, the transformation technique can be required to be an arbitrarily complex program in its own right
09:31:43 <chessguy2> but it's a general-purose thing, a way to allow people to describe the process of translating from one language to another, in a standard way
09:31:59 <ndm> chessguy2: so whats the usefulness of compilable? given the source language already has a compiler
09:32:00 <jethr0> chessguy2: that's a compiler toolkit
09:32:15 <chessguy2> for porting, for example
09:32:37 <ndm> now that is a reasonable idea :)
09:32:42 <chessguy2> or to abstract out all the details of machine code generation and optimization
09:32:57 <ndm> although you might be best off giving a semantic definition of a language
09:33:30 <ndm> and it will end up as a compiler toolkit :) [but there is nothing wrong with that]
09:33:49 <chessguy2> yes, it would be kind of like a compiler compiler
09:34:16 <chessguy2> but generalized
09:34:26 <ndm> chessguy2: so you would need a standard purpose type checker?
09:34:35 <ndm> in order to type check the language like Haskell
09:34:38 <ndm> like yacc for types?
09:34:53 <chessguy2> i'm not sure what to do with type checking
09:35:11 <chessguy2> or even if i need to do anything with it
09:35:17 <ndm> you do :)
09:35:18 <dcoutts_> or use partial evaluation
09:35:19 <ndm> 1 + 2
09:35:26 <dozer> chessguy2: you may want to come up with 3-4 examples of conversions you'd like to do, why, and any info about how it would be done manually
09:35:31 <ndm> or rather a + b
09:35:41 <chessguy2> other than allow people who use the tool when i'm done with it to handle it :)
09:35:42 <dcoutts_> partial evaluation + interpreter ==> compiler for free!
09:35:43 <ndm> there is no way to do that, unless you know the type of a and b
09:35:49 <ndm> @type (+)
09:35:50 <lambdabot> forall a. (Num a) => a -> a -> a
09:36:00 <xerox> Duncan's research, woohoo!
09:36:04 <dcoutts_> :-)
09:36:16 <dozer> of course, a related problem is how to embed code in one language inside that in another e.g. have SQL text dumped directly into a haskell program
09:36:27 <dozer> a general mechanism for that sort of thing would be neat
09:36:47 <ndm> dozer: thats a reasonably easy problem, i think
09:36:48 <dozer> esp if you could type-check all/most of it at compile-time
09:36:54 <ndm> just one thats never been attempted :)
09:37:10 <dozer> ndm: definitely requires dependent types, and some help from your outer lexer/parser
09:37:13 <ndm> well, i once did a language that had that feature
09:37:22 <ndm> not sure you require dependant types
09:37:53 <ndm> chessguy2: a yacc for types would be good, hint hint :)
09:38:10 <chessguy2> i'm not sure what you mean
09:38:21 <dozer> ndm: the type checking code it generates would be ... challenging to get right
09:38:33 <ndm> well in your compiler kit, you need a parser (yacc/lex)
09:38:39 <dozer> some apparently inochuous constructs make type-checking impossible when composed together
09:38:41 <SamB> apparantly JHC's model can handle dependant types well
09:38:43 <ndm> but you'll then need to type check the abstract syntax tree
09:38:52 <ndm> so a standard way of doing that would be handy
09:38:55 <SamB> naturally, even
09:39:13 <palomer> ok, someone explain to me how callCC works
09:39:44 <xerox> Magic.
09:39:56 <SamB> not as well as it could?
09:40:05 <davidhouse> i've never actually seen Cont used before.
09:40:08 <chessguy2> i don't know, i'm probably getting in over my head
09:40:13 <davidhouse> it sound scary so i ran away and read about arrows.
09:40:37 <palomer> given a function ((a -> [Int]) -> [Bool]) how do we get back a [Bool] ?
09:40:41 <SamB> I tried to use it once, for implementing unlambda, but I gave up and just translated the C code...
09:40:46 <SamB> which was surprisingly easy
09:40:56 <xerox> davidhouse: the Events`union`Thread paper uses it.
09:41:24 <davidhouse> palomer, what kind of weird function has that type?
09:41:25 <Cale> palomer: apply the function to any function of type (a -> [Int]), for some a
09:42:03 <palomer> Cale: but we don't have any on hand!
09:42:04 <SamB> so what exactly is dependant typing?
09:42:05 <jethr0> unbounded continuations can make your head hurt like few other things
09:42:11 <palomer> SamB: it's pure crap
09:42:14 <SamB> I know sort of what it is...
09:42:14 <davidhouse> palomer: const [] ;)
09:42:20 * palomer hopes lennart didn't hear that
09:42:42 <palomer> ok, that's only because List is a MonadZero
09:42:51 * palomer thinks of a monad which isn't a MonadZero
09:43:15 <davidhouse> IO is a good example.
09:43:40 <davidhouse> apart from that has the extra property of being one-way, so perhaps not.
09:43:51 <palomer> ok, given an ((a -> IO Int) -> IO Bool), someone build me an IO Bool
09:44:03 <davidhouse> const (return 0)
09:44:11 <SamB> hmm... if a monad transformer is in MonadZero, does that mean that the monads below also need to be?
09:44:14 <davidhouse> i don't really understand what you're trying to do.
09:44:24 <xerox> davidhouse: that's the continuation type.
09:44:34 <palomer> IO Bools are too easy
09:44:43 <palomer> ah, but wait
09:44:55 <palomer> nono, I need a method for build an IO [Bool]
09:44:56 <davidhouse> xerox, what is?
09:45:06 <palomer> here's the more general problem
09:45:17 <Cale> palomer: f (const readLn)
09:45:20 <xerox> davidhouse: (a -> r) -> r
09:45:38 <Cale> palomer: where f is your function
09:45:38 <palomer> given an ((a -> IO b) -> IO a) <--someone build me an IO a with that
09:45:43 <davidhouse> xerox, which is not what palomer is talking about. he's got (a -> r) -> b
09:45:56 <Cale> palomer: all you have to do is pass it some (a -> IO b)
09:46:14 <xerox> davidhouse: which doesn't exacly make sense constructively.
09:46:15 <palomer> Cale: but we don't know what a and b are
09:46:26 <Cale> of course we do
09:46:29 <davidhouse> xerox, hence the confusion.
09:46:33 <SamB> palomer: are you not understanding the return type of callCC?
09:46:55 <palomer> I'm not understanding how callCC could possibly work
09:47:03 <Cale> @type callCC
09:47:04 <lambdabot> Not in scope: `callCC'
09:47:09 <davidhouse> @hoogle callCC
09:47:09 <palomer> @hoogle callCC
09:47:10 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
09:47:10 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
09:47:12 <Cale> @type Control.Monad.ContcallCC
09:47:13 <lambdabot> Not in scope: data constructor `Control.Monad.ContcallCC'
09:47:14 <Cale> @type Control.Monad.Cont.callCC
09:47:14 <xerox> callCC :: ((a -> m b) -> m a) -> m a
09:47:15 <lambdabot> forall (m :: * -> *) a b.
09:47:15 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
09:47:15 <lambdabot>           ((a -> m b) -> m a) -> m a
09:47:26 <palomer> but we don't have a function (a -> IO b) on hand
09:47:52 <Cale> palomer: it applies the function you give it to the current continuation in the monad.
09:47:55 <davidhouse> methinks we need a concrete example.
09:48:01 <Cale> which is of type (a -> m b)
09:48:10 <davidhouse> anyone whip up a continuation?
09:48:24 <palomer> Cale: the current continuation of the monad? eh?
09:48:45 <palomer> I thought we could use any old monad
09:48:46 <SamB> palomer: if you call the continuation, it doesn't return
09:48:55 <Cale> (Control.Monad.Cont.MonadCont m)
09:49:15 <Cale> callCC is only available for continuation monads
09:49:38 <SamB> hence, the return type in no way depends on anything
09:49:38 <palomer> ahh, that explains some
09:49:56 <palomer> there aren't many continuation monads
09:50:09 <Cale> right
09:50:14 <Cale> well, not many in use
09:50:23 <xerox> We can't use callCC in lambdabot because of security issues right?
09:50:28 <Cale> there are plenty in theory :)
09:50:29 <palomer> not many in the standard library
09:50:29 <SamB> @type let forever p = p >> forever p in forever
09:50:30 <lambdabot> forall (m :: * -> *)
09:50:31 <lambdabot>                   a
09:50:31 <lambdabot>                   b.
09:50:31 <lambdabot>                (Monad m) =>
09:50:31 <lambdabot>                m a -> m b
09:51:37 <SamB> I'm not sure what all monads it makes sense to stack ContT on top of, but you could stack it on top of whatever monad you like...
09:52:49 <monochrom> hey, forever is a better name than loop!
09:53:00 * monochrom used loop for that.
09:53:24 <SamB> I think I usually use loop only for local names ;-)
09:53:28 <monochrom> wait, if an exception is thrown (and anticipated) it is not forever. nevermind.
09:53:47 <SamB> well, I still think it makes sense to call it forever...
09:53:51 <dozer> hum - during function application I can do "f x $ y z" and it will behave like "(f x) (y z)" - is there an equivalent for types like "Maybe $ Maybe int" being "Maybe (Maybe int)"?
09:54:13 * monochrom considers myHeartWillGoOn
09:54:22 <Cale> dozer: nope
09:54:37 <Cale> dozer: $ is just an ordinary function, defined in the prelude
09:55:06 <dozer> Cale_: yeah - having something similar for types would get rid of a tone of brackets in my code
09:55:11 <Cale> ContT basically gives you the same monad you had, but with this additional crazy control flow primitive.
09:55:13 <SamB> could you define a type synonym "type f :$ x = f x"?
09:55:35 <xerox> hehe.
09:55:48 <davidhouse> yeah, you could.
09:55:56 <davidhouse> with the GHC extension that allows infix type constructors.
09:55:58 * SamB wonders if it matters that that is probably of fixed kind...
09:56:08 <monochrom> Visualizing code as parse tree would get rid of all brackets.
09:56:15 <SamB> haha
09:56:19 <davidhouse> actually, you'd probably need some kind of fixity decls for types.
09:56:29 <davidhouse> messing around in the type level like this would be crazy :)
09:56:32 <Cale> fixity decls will still work
09:56:41 * xerox needs tea
09:56:48 <Cale> (or they should, anyway)
09:56:49 <SamB> monochrom: but probably would not be very readable
09:56:57 <davidhouse> Cale, even for _type_ constructors?
09:57:04 <Cale> davidhouse: I would expect
09:57:09 <davidhouse> nice :)
09:57:14 <davidhouse> let's do it, then.
09:57:15 <SamB> Cale: but but but... namespaces!
09:57:52 <monochrom> A mixture of $'s and ()'s is not very readable either.
09:58:13 <shapr> monochrom: Seen Aardappel?
09:58:18 <SamB> Cale: so if ContT can be that crazy, is it okay to implement MonadZero and MonadPlus when your underlying monad does not?
09:58:18 <davidhouse> anyone remember the GHC ext which allowed infix type constructors?
09:58:29 <shapr> 6.5?
09:58:46 <shapr> 6.4.2?
09:58:50 * shapr isn't sure
09:58:52 <monochrom> Half of the programmers will find $ not very readable because they mis-remember its fixity or precedence.
09:58:58 <Lemmih> Weird. 'type a $ b = a b; test :: Maybe $ Maybe Int; test = Nothing' doesn't work.
09:59:01 <SamB> shapr: those are versions, not exts!
09:59:14 <Lemmih> But 'type T a b = a b; test :: Maybe `T` Maybe Int; test = Nothing' does.
09:59:16 <Cale> SamB: it's okay to do that, but usually unnatural.
09:59:24 <davidhouse> Lemmih: fixity?
09:59:28 <Cale> (sometimes it's possible)
09:59:42 <monochrom> Think about it.  There is a piece of code.  The computer has to parse it.  The human has to parse it.  Don' you think it's a bit redundant?
09:59:47 <SamB> Cale: you recall Parsec implements those?
10:00:01 <shapr> monochrom: Seen Intentional Programming?
10:00:02 <Lemmih> davidhouse: How do you set the fixity of a type? I tried with infixr 0 $.
10:00:10 <dozer> > :$:
10:00:10 <lambdabot>  parse error on input `:$:'
10:00:22 <monochrom> I think I have heard of intentional programming.
10:01:18 <davidhouse> Lemmih: i wouldn't be the one to know. and what flags does GHC need to accept infix type constructors?
10:01:39 <davidhouse> *the one to ask
10:01:52 <Lemmih> davidhouse: No flags needed. Just use ghc-6.5.
10:02:28 <davidhouse> if i don
10:02:41 <davidhouse> if i don't have access to 6.5, can 6.4 do it with a flag?
10:03:44 <shapr> monochrom: Aardappel - http://www.scannedinavian.com/~shae/aard.png
10:03:53 <Lemmih> davidhouse: I don't think so.
10:04:28 <SamB> I suppose there is no great loss if I don't implement those for my transformed version...
10:04:33 <dozer> ghc 6.4.1 is the version packaged for ubuntu dapper at the moment
10:05:36 <shapr> Too bad I can't figure out how to actually use Aardappel. It seems there is no tutorial, and no information on actual use in the PhD thesis.
10:06:05 <xerox> shapr: impressive!
10:06:34 <shapr> It's cute but impossible to use without a tutorial.
10:06:49 <davidhouse> nice.
10:08:41 * SamB thought 6.4 supported those!
10:09:12 <dcoutts_> dons, can't FPS.compareBytes do a short-cut test for pointer+offset equality?
10:09:17 * dcoutts_ reads fps source
10:10:33 <SyntaxNinja> w00t
10:10:45 <dcoutts_> dons, or do length tests for that matter
10:11:32 <dcoutts_> dons, so special-case eq rather than doing it in terms of compareBytes, since we don't care about the ordering, just (in)equality
10:11:41 <dcoutts_> hia SyntaxNinja 
10:13:06 * vincenz wonders how useful aardappel is
10:14:02 <SyntaxNinja> yo dcoutts_
10:14:04 <morans> k
10:14:06 <morans> oops sorry
10:14:07 <morans> ignore
10:14:32 <vincenz> is it possible to StateT on top of State?
10:14:56 <xerox> Howdy SyntaxNinja !
10:14:59 <SamB> sure!
10:15:07 <SamB> at least, probably
10:15:24 <Cale> vincenz: yes, but it doesn't buy you much
10:15:27 <ibid> it ought to work, but it doesn't make much sense
10:15:36 <vincenz> Cale: well I'm still fiddling with the use of consumeK :: e -> m ()
10:15:37 <SyntaxNinja> xerox: 'sup
10:15:44 <ndm> SyntaxNinja: stanza, as a cabal error message!
10:15:47 <ibid> unless the State is (a part of) a black box monad for you
10:15:57 <xerox> SyntaxNinja: people were asking where and how rank proposals, we need to think up something
10:16:08 <vincenz> Cale: in addition... I seem to have hit a small problempoint
10:16:35 <SamB> rank mine high! ;-P
10:16:47 <SyntaxNinja> ndm: thanks.
10:16:55 <davidhouse> wow, i just saw dons's name in a paper. it was a weird moment when i realised #haskell and The Academic World are actually linked...
10:17:15 <ndm> and his email address is dons@ ...
10:17:17 <SamB> how does the ranking work, anyway?
10:17:23 <SyntaxNinja> xerox: I added pugs.  OK. any ideas.  how long do we have to rank proposals?
10:17:29 <ndm> (ditto for mine, being ndm@ ...)
10:17:51 <SamB> davidhouse: which paper?
10:17:59 <davidhouse> err, s/dons/dcoutts
10:18:09 <davidhouse> sorry to the both of you :)
10:18:15 <palomer> how do I add myself to the interested students of a SoC project?
10:18:25 <dcoutts_> davidhouse, which paper was that?
10:18:27 <xerox> SyntaxNinja: ranking and mentor assigned due to May 22, 08:00 PDT
10:18:27 <SamB> palomer: you edit the ticket
10:18:33 <SamB> palomer: first, log in
10:18:39 <davidhouse> SamB: http://www.soi.city.ac.uk/~ross/papers/Applicative.html
10:18:48 <SamB> second, reload the ticket
10:19:29 <davidhouse> dcoutts_, as in link to SamB.
10:19:36 <shapr> xerox: Can you give me the mentor forum http address again?
10:19:36 <davidhouse> dcoutts_, on page 9.
10:20:00 <palomer> but there's no "interested students" box
10:20:07 <xerox> shapr: the mentor google group?
10:20:11 <xerox> palomer: where?
10:20:21 <SamB> palomer: edit the wikitext field
10:20:35 <SamB> if the heading is missing, swipe it from another ticket
10:20:36 <palomer> ah, righto
10:20:38 <xerox> palomer: I did my best in keeping them into shape
10:21:34 <SamB> xerox: I think he was expecting a seperate field for that
10:21:52 <dcoutts_> davidhouse, ah yes, that one. It's a nice paper.
10:21:56 <SamB> which really would be ideal
10:21:56 <shapr> xerox: yes
10:22:02 <SyntaxNinja> shapr: http://code.google.com/soc/mentor_home.html
10:22:05 <xerox> shapr: I don't know it
10:22:17 <xerox> dcoutts_: what was it?
10:22:24 <wchogg> Has anyone tried to build the head version of ghc lately?  I'm getting the same problem as http://hackage.haskell.org/trac/ghc/ticket/715 , but don't know if everyone else is.
10:22:24 <davidhouse> dcoutts_, yes it is. interesting stuff.
10:22:47 <xerox> palomer: which ticket # are you editing?
10:22:58 <SamB> wchogg: is that an openal build problem?
10:23:03 <palomer> xerox: 78
10:23:15 <wchogg> SamB:  Yes, that's the one.
10:23:25 <davidhouse> xerox, a paper on "applicative programming with effects", basically, a new class to represent types that can be `ap`ed.
10:23:26 <palomer> the SoC still confuses me, does my involvment consist of simply submitting proposals at the moment?
10:23:34 <palomer> s/involvment/involvement
10:23:37 <SamB> yup, I get the same problem. or at least, I presume it is the same problem.
10:23:57 <SamB> palomer: you signed up on googles page yet?
10:24:14 <palomer> SamB: yeah
10:24:20 <wchogg> SamB:  Just for gits and shiggles I tried removing the type signature of the function it was dying on, and it made it a little further before dying on a completely different error.
10:24:22 <SamB> and submitted an application there?
10:24:43 <palomer> SamB: yup
10:24:45 <SamB> wchogg: okay, so I guess the real problem is in GHC itself somewhere?
10:25:24 <wchogg> SamB:  I don't know.  What version of ghc were you using to do the initial compiling?  Was it 6.4.1 or .2?
10:25:27 <palomer> so now the haskell.org community is going to review the proposals, select the ones they want to send to google, clean them up and send them?
10:25:42 <SamB> wchogg: doesn't matter -- it builds that with stage1
10:26:02 <wchogg> SamB:  Oh, you're right.  It's not dying on the stage1, is it?
10:26:28 <SamB> if stage1 crashed or refused to build, that would be worth looking into
10:26:34 <SamB> in fact, I think I used 6.4...
10:26:43 <SamB> I really should upgrade to a less buggy version...
10:27:03 <wchogg> Hrmm...actually, looking over my errors it says [stage1] Error 2 at the end, so I don't know if it *did* make it past stage 1...
10:27:23 <SamB> oh?
10:27:46 <wchogg> Should I ask about this on ghc-users or the cvs list?
10:28:05 <SamB> but it went on to fail building the OpenAL package?
10:28:35 <ndm> when i built GHC, openAL was busted
10:28:43 <ndm> so was open<something> as well
10:28:59 <wchogg> SamB:  I wouldn't take what I say too seriously.  This is unfortunately my first time trying to build GHC, so I might be wrong.
10:29:21 <wchogg> the [stage 1] tag might not mean it was still working on stage 1 for all I know.
10:29:34 <SamB> I think that is a make thing....
10:30:58 <wchogg> SamB:  I may just be retarded, forget about it.  I should check the ghc mailing list archives for workarounds or something like that.
10:32:39 <palomer> how would you guys encode lists at the type? (I just want a way to call rotate to rotate the type list)
10:32:46 <palomer> s/at the type/at the type level
10:34:14 <monochrom> Perhaps Ralf Hinze's HList.
10:36:13 <davidhouse> @hoogle liftA
10:36:13 <lambdabot> No matches found
10:43:27 <vincenz> @pl                 lift $ (consume . actions $ s) (head . inputI $ s)
10:43:27 <lambdabot> lift (consume (actions s) (head (inputI s)))
10:46:15 <kwahgib> hello, anybody here with experience with promela/spin? :) (a little off-topic)
10:48:13 <tuxplorer> Lokadin, u were trying to execute a shell command from ur haskell program that day, right? can u put that part of the code in a pastebin, plz?
10:50:06 <tuxplorer> ? hoogle exec
10:50:16 <tuxplorer> ?hoogle exec
10:50:17 <lambdabot> Directory.executable :: Permissions -> Bool
10:50:17 <lambdabot> Distribution.PackageDescription.executables :: PackageDescription -> [Executable]
10:50:17 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
10:50:36 <Cale> @index System.Process
10:50:37 <lambdabot> bzzt
10:50:41 <Cale> @docs System.Process
10:50:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
10:53:14 <tuxplorer> Cale, how to call a linux command from it?
10:53:46 <Cale> runInteractiveCommand
10:53:54 <Cale> or just runCommand
10:54:06 <Cale> depending on whether you need IO handles
10:55:03 <tuxplorer> Oh! thanks Cale, I need runInteractiveCommand
10:59:25 <palomer> is there a function Void -> Cont a?
11:00:21 <palomer> something tells me it should exist
11:01:34 <palomer> oh, I'm an idiot, of course there is
11:01:54 <palomer> return
11:05:45 <palomer> wait , I meant Cont Void a
11:06:18 <palomer> erm, is there?
11:06:27 <SamB> what is Void?
11:06:37 <palomer> data Void
11:06:38 <xerox> data Void
11:06:53 <SamB> suspected as much
11:07:37 <Cale> @type return :: a -> Control.Monad.Cont.Cont r a
11:07:38 <lambdabot> a -> Control.Monad.Cont.Cont r a :: forall a r.
11:07:38 <lambdabot>                 a -> Control.Monad.Cont.Cont r a
11:08:13 <palomer> nono, return doesn't work
11:09:01 <palomer> is there a function (a -> Void) -> Void ?
11:09:04 <davidhouse> is there an IO transformer monad?
11:09:14 <SamB> const undefined?
11:09:20 <SamB> er, no.
11:09:27 <SamB> ($undefined)?
11:09:31 <palomer> davidhouse: nope
11:09:39 <Cale> @type let y f = f (y f) in f
11:09:40 <lambdabot> Not in scope: `f'
11:09:41 <Cale> @type let y f = f (y f) in y
11:09:42 <SamB> davidhouse: of course not!
11:09:43 <lambdabot> forall t. (t -> t) -> t
11:09:49 <davidhouse> SamB: why "of course not"?
11:09:54 <palomer> undefined is cheating though
11:10:05 <Cale> @type (\f -> f undefined)
11:10:06 <lambdabot> forall t a. (a -> t) -> t
11:10:13 <SamB> davidhouse: becasue the world outside underlies everything
11:10:48 <Cale> palomer: there's one
11:10:53 <ADEpt> @seen dons
11:10:53 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 4 hours, 58 minutes and 13 seconds ago.
11:10:55 <Cale> (that's the only one)
11:11:02 <ADEpt> @seen Lemmig
11:11:02 <lambdabot> I haven't seen Lemmig.
11:11:07 <ADEpt> @seen Lemmih
11:11:07 <lambdabot> Lemmih is in #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 1 hour, 7 minutes and 13 seconds ago.
11:11:15 <palomer> I forgot void was inhabitated
11:11:30 <palomer> s/Void/void
11:11:38 <SamB> palomer: yes, undefined *is* cheating
11:11:40 <Cale> yeah, it has bottom in it
11:11:46 <Lemmih> ADEpt: Hiya.
11:12:04 <ADEpt> Lemmih: hi. have time for a couple of SoC questions?
11:12:06 <palomer> I guess it's the only way to do it, huh
11:12:09 <Lemmih> ADEpt: Sure.
11:12:21 <Cale> palomer: yes, there's only one value of type forall a. a
11:12:39 <palomer> Cale: why do I need a value of forall a.a?
11:12:51 <Cale> palomer: and you have to apply that value to the function you're passed to get a value of type t
11:12:54 <Cale> there's no other way
11:13:10 <Cale> @djinn (a -> t) -> t
11:13:11 <lambdabot> -- f cannot be realized.
11:13:11 <ADEpt> Lemmih: 1)i was subscribed to Summer-Administrators-2006@googlegroups.com by LH. Does that mean that my mentor application was accepted?
11:13:12 <SamB> but I don't think you can tell that that it is _|_. well, without deducing that, since there *are* no other values of that type, it *must* be bottom...
11:13:30 <Cale> djinn will complain because it doesn't like using undefined :)
11:13:53 <Cale> okay, there's also bottom
11:14:02 <Cale> so there's two values of type (a -> t) -> t
11:14:30 <Cale> undefined, and (\f -> f undefined)
11:14:37 <Lemmih> ADEpt: I believe so. What does http://code.google.com/soc/mentor_home.html say?
11:14:54 <Cale> > (\f -> f undefined) (const 5)
11:14:55 <lambdabot> 5
11:15:58 <Cale> > undefined (const 5)
11:15:58 <lambdabot> Add a type signature
11:16:02 <Cale> > undefined (const 5) :: Integer
11:16:03 <lambdabot> Undefined
11:16:08 <SamB> > ($undefined) (const 5)
11:16:09 <lambdabot> Undefined
11:16:30 <SamB> hmm?
11:16:51 <SamB> why does that one return undefined and not 5?
11:17:07 <Cale> > ($ undefined) (const 5)
11:17:08 <lambdabot> 5
11:17:15 <SamB> @type ($undefined)
11:17:16 <lambdabot> forall a b. (a -> b) -> b
11:17:27 <Cale> probably TH
11:17:28 <xerox> Maybe it's the TH bits?
11:17:32 <xerox> Jinx!
11:17:33 <SamB> oh, yeah ;-)
11:17:35 <SamB> right.
11:17:52 <SamB> you'd think it would wantt o wrap the error message!
11:19:15 <ADEpt> Lemmih: page says "Rank Applications". Strange, I could swear the earlier today no such link existed (for my google account)
11:19:46 <SamB> ADEpt: could be they just opened the ranking process up?
11:20:15 <ADEpt> SamB: messages about that a flying through group for at least two days now
11:20:28 <SamB> oh
11:20:44 <SamB> I haven't really been looking at that
11:20:59 <SamB> okay, I have a concert to get to...
11:21:03 <SamB> I better go.
11:21:04 <xerox> You couldn't? (-:
11:21:09 <xerox> Have fun!
11:21:20 <SamB> thanks ;-)
11:21:24 <Lemmih> ADEpt: Congrats. You're a mentor.
11:21:59 <davidhouse> how are the SoC plans going?
11:22:01 <ADEpt> Lemmih: thank you
11:22:12 <dcoutts_> ADEpt, you were asking about gtk2hs .debs eariler I think?
11:22:20 <dcoutts_> they're linked from the gtk2hs download page
11:22:36 <vincenz> YAYYYYYYYY
11:23:40 <dcoutts_> vincenz, ?
11:23:40 <liyang> wut huh?
11:23:44 <liyang> ADEpt: http://carwash.cs.nott.ac.uk:992/~lyh/gtk2hs/
11:24:16 <ADEpt> liyang: aha! will see now, previously i was behind the firewall, and had no ability to access port 992
11:24:23 <liyang> Oh yeah. Spend time on Gtk2Hs instead of driving around in my new car this weekend.
11:24:28 * liyang makes a note...
11:24:36 <dcoutts_> heh
11:24:52 <vincenz> WOO
11:24:56 <liyang> ADEpt: I'm similarly behind a firewall and cannot run the webserver on port 80. :(
11:24:57 <vincenz> dcoutts_: I just got a new renter for my current appt
11:25:09 <vincenz> dcoutts_: and I'm planning to sign a new contract for a new appt sunday   \o/
11:25:47 <dcoutts_> good for you
11:25:52 <vincenz> yeah
11:25:59 <vincenz> and no more zillion people to show my appt too
11:26:00 <davidhouse> congrats :)
11:26:06 <vincenz> being social is fatiguing
11:26:24 <davidhouse> yeah. real life--.
11:26:58 <mux> dcoutts_: looks like there are html pages missing from the gtk2hs documentation
11:27:12 <dcoutts_> mux, really? which ones?
11:27:20 <mux> from here http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/Graphics-UI-Gtk-Windows-Dialog.html
11:27:28 <mux> if you click on MessageDialog, you get a 404 error
11:27:46 <mux> with 0.9.10 docs and current docs
11:27:55 <ADEpt> liyang: and not on port 443?
11:28:06 <monochrom> heh
11:28:34 <palomer> runCont . return is a nonBottom element of (a -> Void) -> Void , no?
11:28:36 <dcoutts_> mux, ah yes. The problem there is that it's actually not a defined type :-) It's in the C docs but we've not bound it.
11:28:45 <dcoutts_> mux, so haddock has nowhere to link to :-(
11:29:25 <mux> dcoutts_: ah. automatically-generated doc?
11:29:28 <dcoutts_> mux, I'll make a note of it
11:29:34 <palomer> actually, make that a non bottom element of a -> ((a -> Void) -> Void)
11:29:36 <mux> thanks
11:29:42 <dcoutts_> mux, yeah, semi-automagically generated
11:29:59 <mux> btw, are you interested in patches to move from FiniteMap to Data.Map ?
11:30:30 <lightstep> @type flip id
11:30:31 <lambdabot> forall b c. b -> (b -> c) -> c
11:30:42 <dcoutts_> mux, well it depends on if we are prepared to drop ghc-5.04, 6.0 & 6.2 support.
11:30:45 <liyang> ADEpt: blocked. :-/
11:31:05 <dcoutts_> mux, but all sorts of other patches are most welcome, eg doc patches :-)
11:31:07 <monochrom> #ifdef is your friend  *duck*
11:31:25 <mux> dcoutts_: heh. I don't do docs, sorry
11:31:41 <dcoutts_> mux, if you build the docs yourself you'll notice lots of warning due to not being able to find link targets.
11:31:51 <liyang> ADEpt: I had to work quite hard to find that open port. I don't think the IT people have any idea that no one actually uses Telnet over SSL.
11:31:51 <dcoutts_> mux, ok fair enough :-)
11:32:07 <dcoutts_> mux, I should start a gtk2hs trac. SyntaxNinja!
11:32:22 <mux> SyntaxNinja?
11:32:27 <palomer> @type Control.Monad.Cont.RunCont
11:32:28 <lambdabot> Not in scope: data constructor `Control.Monad.Cont.RunCont'
11:32:40 <dcoutts_> SyntaxNinja, I hear it's easy to add new trac instances. Can we have one for gtk2hs bug tracking please? :-)
11:32:43 <palomer> @hoogle runCont
11:32:43 <lambdabot> Control.Monad.Cont.runCont :: Cont r a -> ((a -> r) -> r)
11:32:44 <lambdabot> Control.Monad.Cont.runContT :: ContT r m a -> ((a -> m r) -> m r)
11:32:51 <dcoutts_> @seen SyntaxNinja
11:32:52 <lambdabot> SyntaxNinja is in #haskell and #haskell-blah. I last heard SyntaxNinja speak 1 hour, 10 minutes and 49 seconds ago.
11:34:12 <palomer> whoa.
11:34:19 <mux> oh
11:35:19 <mux> dcoutts_: is there some VCS repo for gtk2hs?
11:35:29 <dcoutts_> @code gtk2hs
11:35:30 <lambdabot> Maybe you meant: more todo vote
11:35:36 <dcoutts_> hmm
11:35:56 <dcoutts_> mux, darcs get --partial http://darcs.haskell.org/gtk2hs/
11:36:04 <mux> thanks
11:36:14 <dcoutts_> then use "darcs send"
11:36:50 <dcoutts_> mux, "darcs send" will get your patches sent to the gtk2hs-devel list
11:36:54 <mux> ok, nice
11:37:14 <mux> cd gtk2hs
11:37:16 <mux> hmpf
11:37:18 * mux slaps self
11:37:22 <dcoutts_> heh :-)
11:39:36 <davidhouse> okay, i need some ideas.
11:40:07 <davidhouse> i'm writing a program whereby the output layer can be switched via a runtime flag.
11:40:45 <davidhouse> i've defined data Outputter = Out { method1, method2 ... } where method* are the methods i need defined in an output layer.
11:41:18 <SyntaxNinja> hi dcoutts_
11:41:19 <Cale> davidhouse: a class might be even more appropriate, since you wouldn't have to pass your Outputter structure around
11:41:26 <vincenz> Cale: I did the instance
11:41:29 <vincenz> Cale: still same bug
11:41:31 <SyntaxNinja> dcoutts_: can you ask simonMar?
11:41:33 <Cale> vincenz: hmm
11:41:47 <Cale> vincenz: did you remove MonadTrans from the deriving list?
11:41:50 <davidhouse> Cale, hmm... how would that look?
11:42:16 <vincenz> whoops
11:42:17 <davidhouse> so far, all i'm doing is writing a module for each output layer then importing them as necessary.
11:42:22 <dcoutts_> SyntaxNinja, sure.
11:42:49 <dcoutts_> SyntaxNinja, sorry, I thought you did the admin on trac. I'll ask Simon.
11:42:57 <davidhouse> each module defines and exports an outputter function, which just fetches that module's outputter.
11:43:14 <davidhouse> but i can't figure out a nice way to switch the layer depending on a runtime switch
11:43:22 <davidhouse> or even a compiletime switch
11:43:31 <Cale> can't you just do something like
11:43:40 <Cale> case flag of
11:43:56 <Cale>    A -> doSomething outputterA
11:44:05 <Cale>    B -> doSomething outputterB
11:44:07 <Cale> etc.
11:44:16 <vincenz> Cale: it works, thanks :)
11:44:21 <Cale> vincenz: great :)
11:44:24 <davidhouse> that would involve passing my outputter to all functions that would need it, which is ugly.
11:44:27 <SyntaxNinja> dcoutts_: he and I kinda share it.  I have some vague feeling that he's worried about a proliferation of rarely used tracs, but it's vague and probably not true.
11:44:44 <Cale> davidhouse: well, that's why typeclasses were invented :)
11:45:01 <davidhouse> Cale, so what would a class implementation look like?
11:45:11 <dcoutts_> SyntaxNinja, it's reasonable. I think we'll use it. I'm beginning to loose track of bug & feature requests.
11:45:39 <Cale> you may need a silly type to mark which kind of output you need, if there's no other distinguishing features
11:45:49 <Cale> What kinds of output are we talking about here?
11:45:58 <davidhouse> Cale, at the moment, ASCII or HTML.
11:46:13 <davidhouse> dcoutts_: who else works on gtk2hs?
11:46:17 <Cale> okay, is the HTML represented by a String?
11:46:21 <davidhouse> yep.
11:47:07 <Cale> hmm, I wonder if newtyping would be seen as appropriate :)
11:47:09 <dcoutts_> davidhouse, it's mostly Axel and me who hack on code regularly. xerox does the cairo bindings. We've got other helpers for the website and for ditro packaging. Then we've had various contributions from other people.
11:47:19 <dcoutts_> davidhouse, it's easy to contribute! :-)
11:47:24 <davidhouse> heh.
11:47:37 <Cale> newtype HTML = HTML String deriving (Eq, Read, Show, etc.)
11:47:53 <palomer> hrmph
11:47:59 <palomer> djinn doesn't know about Cont
11:48:04 <palomer> @djinn a -> Cont r a
11:48:04 <lambdabot> -- f cannot be realized.
11:48:17 <davidhouse> palomer: djinn doens't know much
11:48:17 <Cale> @djinn-env
11:48:17 * palomer wishes djinn would give better error messages
11:48:18 <lambdabot> data () = ()
11:48:18 <lambdabot> data Either a b = Left a | Right b
11:48:18 <lambdabot> data Maybe a = Nothing | Just a
11:48:18 <lambdabot> data Bool = False | True
11:48:18 <lambdabot> data Void
11:48:20 <lambdabot> type Not x = x -> Void
11:48:22 <vincenz> @type splitAt
11:48:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:48:35 <SyntaxNinja> dcoutts_: I know how you feel :)
11:48:44 <palomer> how do we add to the environment?
11:48:45 <SyntaxNinja> dcoutts_: if he's fine w/ it,, i'm fine w/ it.
11:48:57 <Cale> @djinn-add data Cont r a = Cont ((a -> r) -> r)
11:48:59 <vincenz> grrr
11:49:04 <Cale> @djinn a -> Cont r a
11:49:05 <lambdabot> f a = Cont (\ b -> b a)
11:49:17 <Cale> palomer: good?
11:49:27 <Cale> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
11:49:28 <lambdabot> f a b =
11:49:28 <lambdabot>   case a of
11:49:28 <lambdabot>   Cont c -> Cont (\ d ->
11:49:28 <lambdabot>        c (\ e ->
11:49:28 <lambdabot>         case b e of
11:49:30 <lambdabot>         Cont f -> f d))
11:49:34 <davidhouse> Cale, there's more, right?
11:49:40 <monochrom> newtyping is the best thing since requiring an instance to be a constructed type :)
11:49:58 <Cale> davidhouse: well, then you make HTML and String instances of your class
11:50:09 <Cale> and the class will define all the output methods
11:50:14 <palomer> Cale: yeah
11:50:33 <davidhouse> aha!
11:50:35 <davidhouse> clever.
11:50:56 <palomer> can you add functions to the environment as well?
11:51:37 <Cale> in plain djinn you can, I don't know if you can here
11:52:01 <Cale> @djinn a -> a
11:52:01 <lambdabot> f a = a
11:52:09 <Lemmih> @help djinn-add
11:52:09 <lambdabot> djinn-add <expr>.
11:52:09 <Cale> @djinn-add id x = x
11:52:09 <lambdabot> Define a new function type or type synonym
11:52:10 <lambdabot> Cannot parse command
11:52:17 <Cale> @djinn-add id :: a -> a
11:52:25 <Cale> @djinn a -> a
11:52:25 <lambdabot> f = id
11:52:35 <Cale> @djinn b -> (a -> a)
11:52:35 <lambdabot> f _ a = a
11:52:43 <Cale> hmm
11:53:12 <Cale> @djinn (a -> b) -> (a -> b)
11:53:12 <lambdabot> f a = a
11:53:35 <Cale> odd
11:54:21 <palomer> > 2 + 2
11:54:23 <lambdabot> 4
11:54:38 <palomer> hrmph
11:54:52 <Cale> @. elite palomer
11:54:53 <lambdabot> hr/\/\f
11:54:56 <palomer> lambdabot isn't responding to my privs anymore
11:54:59 <monochrom> > kickban palomer "2+2"
11:55:00 <lambdabot>  Not in scope: `palomer'
11:55:41 <Cale> palomer: you're not identified with services
11:56:12 <Cale> (and hence you can't send private messages)
11:56:28 <palomer> but I was
11:56:33 <jfoutz> Cale: i read your Monads as containers on the wiki, it helped a LOT. thank you.
11:56:36 <palomer> and then he stopped responding
11:56:39 <palomer> he started again
11:56:47 <Cale> jfoutz: great :)
11:56:47 <palomer> is djinn complete? (ie will it always find a term?)
11:57:04 <Cale> palomer: if a completely defined term exists, then yes
11:57:36 <Cale> palomer: but it doesn't know about recursive types
11:57:56 <palomer> @djinn Cont (Cont (Cont a b) a) a
11:57:57 <lambdabot> -- f cannot be realized.
11:58:02 <norpan> @hoogle peek
11:58:02 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
11:58:03 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
11:58:03 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
11:58:06 <palomer> it can't find a term for Pierce's law
11:58:18 <Cale> that's because none exists
11:58:27 <palomer> in Cont it should
11:58:28 <palomer> methinks
11:58:31 <Cale> hmm
11:59:24 <palomer> and I added callCC
11:59:34 <Cale> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
11:59:35 <lambdabot> f = callCC
11:59:53 <palomer> are you _positive_ that it's complete?
12:00:12 <vincenz> dons: ping
12:00:56 <Cale> For the curious, Djinn uses a decision procedure for intuitionistic
12:00:56 <Cale> propositional calculus due to Roy Dyckhoff.  It's a variation of
12:00:56 <Cale> Gentzen's LJ system.  This means that (in theory) Djinn will always
12:00:56 <Cale> find a function if one exists, and if one doesn't exist Djinn will
12:00:56 <Cale> terminate telling you so.
12:01:27 <Cale> besides, djinn can derive callCC
12:01:27 <palomer> hrmph
12:01:35 <palomer> how does one interpret Cont a b intuitively?
12:01:40 <Cale> @help djinn-clear
12:01:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:01:43 <Cale> @help djinn
12:01:43 <lambdabot> djinn <type>.
12:01:44 <lambdabot> Generates Haskell code from a type.
12:01:44 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:01:57 <Cale> @listcommands djinn
12:01:58 <palomer> a function from a to b?
12:01:58 <lambdabot> Unknown command, try @list
12:02:01 <Cale> @list djinn
12:02:01 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-ver
12:02:09 <Cale> @djinn-del callCC
12:02:18 <mux> @djinn a -> b -> c
12:02:19 <lambdabot> -- f cannot be realized.
12:02:24 <Cale> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
12:02:25 <lambdabot> f a =
12:02:25 <lambdabot>   Cont (\ b ->
12:02:25 <lambdabot>     case a (\ c -> Cont (\ _ -> b c)) of
12:02:25 <lambdabot>     Cont d -> d b)
12:02:35 <Cale> there :)
12:02:40 <palomer> <:o
12:02:53 <mux> @djinn [a] -> a
12:02:53 <lambdabot> -- f cannot be realized.
12:03:29 <Cale> Djinn doesn't know about the list type
12:03:36 <Cale> (or any recursive type)
12:04:15 <palomer> so x :: Cont r a  untuitively means "pass x a continuation a -> r and you get back an r", right?
12:04:31 <Cale> yeah
12:04:44 <palomer> s/untuitively/untuitively
12:04:47 <palomer> ack
12:04:49 <palomer> s/untuitively/intuitively
12:04:52 <palomer> ack
12:04:54 * palomer gives up
12:04:55 <Cale> hehe
12:05:35 <Cale> It's somewhat like a value of type a, in that you can combine it with an (a -> r) and get an r.
12:06:05 <monochrom> Don't worry about intuition.
12:06:25 <palomer>  very cool
12:07:08 <Cale> @djinn a -> Cont r a
12:07:08 <lambdabot> f a = Cont (\ b -> b (id a))
12:07:11 <norpan> @hoogle unsafePerformIO
12:07:11 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
12:07:32 <Cale> norpan: it's also in System.IO.Unsafe
12:07:50 <jfoutz> wait.. haskell has continuations?
12:08:02 <jfoutz> gah!
12:08:26 <Cale> jfoutz: not first-class continuations
12:08:35 <Cale> jfoutz: it has a continuation monad though
12:08:51 <jfoutz> ok. i was trying to imagine what the type signature would be on a first class continuation.
12:09:57 <Cale> first class continuations horribly break referential transparency
12:10:13 <monochrom> There are "lateral thinking" games.  The game host has a story but is not telling all of it yet.  He tells you just the last bit, e.g., "he walks into the bar and kills himself".  You have to guess the full story.  You can ask the host a boolean question, and the host will answer.
12:11:07 <monochrom> The game host is like "host :: Cont Bool Story".  You provide a question "Story -> Bool" and the host will say yes/no.
12:12:31 <monochrom> The game host is unlike the continuation-passing style because we seldom use or allow it as many state threads with a common root.
12:16:34 <Cale> in the continuation monad, you can construct actions which jump back to the point at which they were created and pass back a value along with them
12:17:08 <jfoutz> "escape" continuations
12:17:40 <palomer> monochrom: I like that analogy
12:17:53 <Cale>  getCC :: MonadCont m => m (m a)
12:17:54 <Cale>  getCC = callCC (\c -> let x = c x in return x)
12:17:54 <Cale>  getCC' :: MonadCont m => a -> m (a, a -> m b)
12:17:54 <Cale>  getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
12:17:55 <palomer> can I change the precedence of type constructor operators?
12:18:01 <palomer> monochrom: where'd you get it from?
12:18:16 <monochrom> I just invented it when I read Cale.
12:18:26 <wolverian> dammit, I can't figure out how to use Network.HTTP. what's this Network.HTTP.Result stuff? 
12:18:34 <palomer> monochrom: you should put it on the wiki
12:18:41 <monochrom> And also 36 years of living in the world, of course.
12:18:42 <wolverian> I just want to print out the rspBody :)
12:19:16 <palomer> seriously, it needs to be wikified
12:19:47 <SyntaxNinja> gah, can anyone msg me the mentor signup url pls
12:19:50 <SyntaxNinja> (for soc)
12:28:35 <ADEpt> SyntaxNinja: http://code.google.com/soc/mentor_home.html
12:33:59 <palomer> hrmph
12:35:17 <palomer> how do you prove something with the downloadable djinn?
12:35:36 <palomer> ahh, found it
12:37:51 <palomer> and Djinn assumes an elimination rule for the
12:37:51 <palomer> Void type:
12:37:51 <palomer>   void :: Void -> a
12:38:05 <palomer> eh?
12:38:50 <palomer> void == const undefined ?
12:39:09 <palomer> (can I tell djinn not to use void?)
12:42:03 <davidhouse> how do i export instance declarations?
12:42:15 <davidhouse> module X (what do i put here?) where
12:42:20 <sjanssen> davidhouse: they are always exported
12:42:44 <davidhouse> cool.
12:42:46 <sjanssen> in fact, there's no way to *not* export an instance decl.
12:43:00 <davidhouse> so if i want to export JUST an instance decl, it'd be module X () where?
12:43:10 <sjanssen> davidhouse: yeah
12:51:03 <davidhouse> Cale, ping
12:51:36 <palomer> is there any way of finding out what functions you need to implement to satisfy a class?
12:51:55 <davidhouse> palomer: in ghci, use :i
12:52:17 <davidhouse> e.g. :i Show
12:52:25 <davidhouse> (that also works with type constructors)
12:52:41 <davidhouse> okay, well it seems Cale isn't around, so i'll post my question generally.
12:52:53 <sjanssen> palomer: implement functions until the compiler stops complaining about incomplete instances ;)
12:53:17 <sjanssen> alternatively, find the source
12:53:29 <davidhouse> sjanssen: :i is better ;)
12:53:58 <davidhouse> anyway, i'm trying to make an output layer that can be swapped via a runtime flag. Cale suggested going with typeclasses to avoid having to pass my outputter around everwhere
12:54:02 <sjanssen> davidhouse: I think palomer is interested in minimal complete definitions
12:54:20 <sjanssen> for example, if you define >>=, you don't have to define >> in the Monad class
12:54:26 <davidhouse> but i can't quite figure it out.
12:55:01 <davidhouse> at the moment the available outputters are HTML and plain ascii.
12:55:19 <davidhouse> ascii is represented by a string, HTML by a newtype HTML = HTML { unHTML :: String }
12:55:29 <palomer> yeah, I want to implement the least amount possible
12:55:40 * Cale pongs
12:55:49 <davidhouse> oh, hey Cale :)
12:56:06 <davidhouse> both of those are instances of Outputter. the problem is, i'd quite like this to be a _run_time switch.
12:56:20 <Cale> davidhouse: sure
12:56:44 <Cale> davidhouse: you just have to use an if somewhere
12:56:48 <davidhouse> so i do some getArgs'ing, but presumably somewhere along the line i've got to specify a type.
12:57:07 <davidhouse> Cale, but i'm using output functions all over the place. i have to if switch on _all_ of them?
12:57:11 <Cale> probably the type will be made obvious by the use of unHTML in one of the branches
12:57:29 <Cale> and that'll be the only place that it's decided
12:57:47 <Cale> it's like, if you're doing some long numerical calculation
12:57:58 <Cale> 1 + 2 + 3 + 4 + 5 (that's long enough)
12:58:12 <Cale> you don't have to specify the type of (+) everywhere
12:58:18 <davidhouse> no.
12:58:23 <Cale> > 1 + 2 + 3 + 4 + 5 :: Float
12:58:24 <lambdabot> 15.0
12:58:26 <Cale> > 1 + 2 + 3 + 4 + 5 :: Integer
12:58:27 <lambdabot> 15
12:58:52 <davidhouse> so perhaps i accumulate everything that needs to be output, then putStr it all in one go.
12:59:01 <davidhouse> then switch when i putStr.
12:59:28 <Cale> yeah
13:02:13 <araujo> Hello!
13:03:54 <ADEpt> araujo: hi
13:05:24 <palomer> what happens when you try to run an unimplemented class function?
13:06:31 <kombinator> you get runtime error AFAIK
13:06:38 <sjanssen> > undefined
13:06:39 <lambdabot> Add a type signature
13:06:48 <sjanssen> > undefined :: ()
13:06:49 <lambdabot> Undefined
13:07:23 <palomer> why doesn't the compiler enforce that all classes must have their minimal members satisfied?
13:08:02 <sjanssen> palomer: it will give warnings, if I remember correctly
13:08:07 <sjanssen> (it meaning GHC)
13:09:10 <sjanssen> that is a good question.  If the programmer really wants a method undefined, he should have to write method = undefined
13:10:00 <palomer> exactly!
13:10:19 <kombinator> I came across funny case with undefined class functions
13:11:05 * sjanssen reads the report on this subject
13:11:06 <dcoutts> @seen mahogny
13:11:07 <lambdabot> I saw mahogny leaving #haskell 12 hours, 32 minutes and 43 seconds ago, and .
13:11:11 <kombinator> I defined a new type, made it an instance of Eq w/o implementing == or =/=
13:11:26 <kombinator> and now comparison fails with stack overflow
13:11:34 <jfoutz> so, is point free style useful? do point free functions do deforestation?
13:11:39 <kombinator> because == calls =/= and vice versa
13:11:47 <dcoutts> xerox, lots of new SoC applications in the last day!
13:12:10 <sjanssen> kombinator: yeah, that's something I've wondered about also
13:12:13 <kombinator> on top of that, ghci loaded the code without any warnings
13:12:39 <kombinator> @paste
13:12:39 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:12:42 <araujo> hi there ADEpt 
13:13:39 <lisppaste2> kombinator pasted "no class functions" at http://paste.lisp.org/display/19685
13:14:04 <kombinator> sjanssen: try that, e.g T1 1 == T1 2
13:14:32 <sjanssen> kombinator: yeah, that situation is regrettable
13:15:13 <sjanssen> it'd be nice if there was a mechanism in the class decl. that can state when a defn. is complete
13:15:43 <kombinator> sjanssen: even if I add -Wall, GHC generates no warnings
13:16:08 <sjanssen> kombinator: right, GHC doesn't know that the recursion isn't what you want
13:16:19 <RyanT5000> are there any students here still looking for Summer of Code stuff?
13:16:24 <sjanssen> it types correctly, it's got definitions for each member, GHC is happy
13:16:26 <RyanT5000> a project, that is, to work on
13:17:26 <kombinator> sjanssen: but this is a little n00b unfriendly
13:18:17 <sjanssen> kombinator: I'd argue that it's unfriendly to everyone
13:19:02 <jfoutz> it's friendly like a table saw.
13:19:16 <RyanT5000> couldn't you say that a function that produces no output, ever, should be a warning?
13:19:29 <RyanT5000> i mean, even infinite lists produce output
13:19:45 <xerox> dcoutts: indeed.
13:19:52 <xerox> dcoutts: we will be able to manage them all? (-:
13:20:04 <RyanT5000> of course, i think that would require the compiler to solve the halting problem
13:20:15 <RyanT5000> but we can solve the halting problem in some cases
13:20:19 <sjanssen> RyanT5000: yes, you beat me to the bunch ;)
13:20:34 <sjanssen> it sounds like a lot of work for something small like this
13:21:00 <RyanT5000> i mean, (==) = ((.) . (.)) not =/=
13:21:08 <RyanT5000> (=/=) = ((.) . (.)) not ==
13:21:15 <RyanT5000> seems like it could figure out that that doesn't terminate
13:21:32 <RyanT5000> (i apologize if my combinator is wrong)
13:22:08 <RyanT5000> incidentally, i finished moving my project onto my linux box and making it work last night
13:22:30 <RyanT5000> for anyone who's interested, i've found all the compilation stuff to be way, way easier
13:22:41 <RyanT5000> but the editor stuff is still weird
13:23:34 <RyanT5000> i'm not saying linux editors are necessarily user-unfriendly, but that coming from windows there's a much bigger mental switching cost
13:23:43 <RyanT5000> and i really do like the visual studio editor
13:23:48 <sjanssen> RyanT5000: what editor have you been trying?
13:24:10 <RyanT5000> right now i'm using vi, with nothing to make coding easier
13:24:21 <psi> :)
13:24:22 <RyanT5000> i tried vim and emacs on windows
13:24:32 <psi> emacs rocks.
13:24:34 <wolverian> emacs seems to be the only editor with good haskell support, at least until yi/hide become really usable
13:24:37 <dcoutts> RyanT5000, if you're more familiar with windows, then nedit is easier to get used to.
13:24:47 <RyanT5000> hm, is there syntax hilighting for it?
13:25:01 <RyanT5000> (for haskell)
13:25:11 <Cale> RyanT5000: yes, in vim and emacs
13:25:15 <dcoutts> RyanT5000, for nedit. yes.
13:25:21 <Cale> and most other editors too
13:25:24 <RyanT5000> nedit looks familiar :D
13:25:29 <wolverian> gedit is ok too.
13:25:42 <RyanT5000> cool
13:25:43 <wolverian> (and simpler than the others.)
13:25:49 <RyanT5000> is there regex search-and-replace?
13:26:09 <dcoutts> RyanT5000, in nedit. yes.
13:26:16 <RyanT5000> awesome, thanks dcoutts 
13:26:17 <wolverian> in vim and emacs, yes.
13:26:35 <dcoutts> RyanT5000, if you can't find the Haskell syn-hl ask me
13:26:37 <RyanT5000> wolverian, yah, i knew that
13:26:43 <RyanT5000> dcoutts, k, thanks
13:27:44 <RyanT5000> hm.... the symbolic decision-point.... do i move my good mouse over to my linux box :P
13:28:00 <dcoutts> of course!
13:28:05 <RyanT5000> i think i will :)
13:29:12 <palomer> do it!
13:29:19 * palomer needs o new mouse and keyboard
13:29:40 <RyanT5000> my mouse is the Logitech MX1000, I highly recommend it
13:29:45 <RyanT5000> and now it's only like $50
13:29:55 <palomer> I think I'll go with microsoft
13:30:04 <palomer> since peyton-jones works there
13:30:12 <RyanT5000> hm, get one of their wireless ones
13:30:19 <shapr> I like trackballs.
13:30:24 <RyanT5000> ah ok
13:30:39 <palomer> http://www.futureshop.ca/catalog/proddetail.asp?logon=&langid=EN&sku_id=0665000FS10049796&catid=14265 <--I'm eyeing this one
13:30:42 <RyanT5000> the wireless ones seem more reliable
13:30:54 <RyanT5000> the last two wired ones i've seen have broken in like 6 months
13:31:15 <palomer> whoa
13:31:28 <palomer> I'm scared of the latency with wireless mouses/keyboards
13:31:55 <RyanT5000> ...?
13:32:01 <RyanT5000> i have never noticed it
13:32:08 <RyanT5000> and i am *very* picky about that kind of thing
13:32:31 <RyanT5000> however i don't know about microsoft wireless mice
13:32:36 <sjanssen> palomer: you expect that information traveling at the speed of light will introduce lag?
13:32:53 <RyanT5000> well, the original wireless mice had bad latency
13:33:12 <RyanT5000> http://www.logitech.com/index.cfm/products/details/US/EN,CRID=2135,CONTENTID=10716
13:33:21 <RyanT5000> that's what i want
13:33:26 <RyanT5000> except that it's $100
13:33:40 <davidhouse> @index Monoid
13:33:41 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
13:33:49 <RyanT5000> hot-swap batteries are an awesome idea
13:33:58 <xerox> Be back in half an hour.
13:34:55 <palomer> it's not the travel time of the signal that worries me
13:35:02 <palomer> it's the time it takes to translate the signal
13:35:11 <psi> I have a v500 logitech for my laptop, it's pretty decent
13:35:13 <RyanT5000> palomer: bottom line, it is impossible to tell with the MX1000
13:35:37 <palomer> but it's ridiculously expensive
13:35:47 <palomer> is it possible to tell with the other mouses/keyboards?
13:35:54 <RyanT5000> true, but all the logitech wireless use the same technology now, i think
13:35:54 <Cale> Logitech MX510 here, it's decent, but the handedness means that a couple of the buttons are annoying to use
13:35:57 <palomer> (I don't mind so much the mouses, keyboards are really important though
13:36:11 <RyanT5000> hm, i only use laptops
13:36:29 <psi> I haven't used mine in months though, it ran out of batteries
13:36:41 <sjanssen> the wireless Gyration keyboard I use on occasion doesn't have any noticeable lag
13:36:51 <jfoutz> @pl  (\x y -> x:y:[])
13:36:51 <lambdabot> (. return) . (:)
13:37:01 <sjanssen> I don't really like the laptop-ish feel of it, however
13:38:01 * palomer notices any kind of lag
13:38:08 <palomer> I'm actually thinking of switching back to PS/2
13:38:17 <RyanT5000> i don't mind laptop keyboards; in fact, i prefer my dell's keyboard to most desktop keyboards
13:38:39 <RyanT5000> HP's laptop keyboards are unusable, though
13:38:46 <RyanT5000> and i don't particularly like the IBM ones
13:40:16 <jfoutz> @pl (\x y -> [x,y])
13:40:16 <lambdabot> (. return) . (:)
13:41:14 <psi> the ibook keys are rather nice, but some of the combinations you have to type to get certain characters are insane
13:42:12 <jfoutz> i have an ibook. i like the keys better than most laptops. i don't know about the combinations though
13:42:16 <psi> probably because the layout is swedish.
13:42:37 <psi> I should really switch to the american layout - almost everything is optimised for it
13:42:38 <jfoutz> oh. that could be weird.
13:43:14 <jfoutz> you can remap most of the accelerators.
13:44:32 <RyanT5000> could you make it be english layout whenever ctrl or alt is depressed?
13:45:06 <RyanT5000> dcoutts, i have haskell.pats; how do i install it?
13:45:54 <psi> slash is shift+7 with the swedish layout. very inconvenient.
13:46:04 <RyanT5000> dcoutts, nvm, i think i found it
13:47:09 <jfoutz> psi: look up defaultkeybinding.dict on google. you can remap specific keys to to other keys, or to methods on cocoa controls.
13:48:29 <dcoutts> RyanT5000, got it figured out?
13:48:41 <jfoutz> psi: for example ^/ is mapped to the undo: action on text boxes
13:49:30 <SyntaxNinja> yo
13:49:32 <jfoutz> psi: actualy this is the best reference i saw http://hcs.harvard.edu/~jrus/Site/Cocoa%20Text%20System.html
13:49:57 <psi> cool, thanks
13:51:42 <RyanT5000> dcoutts, actually, no
13:52:09 <RyanT5000> what's a calltips file?
13:52:31 <dcoutts> dunno, I'd guess it's for auto-complete
13:52:36 <dcoutts> eg based on function name
13:52:42 <RyanT5000> ah, i think it's a tags thing
13:52:47 <RyanT5000> ok so how do i use the pats file?
13:52:59 <psi> i think it's a tooltip for e.g. function signatures
13:53:05 <dcoutts> nedit -import haskell.pats
13:53:27 <RyanT5000> oooh, and i only have to do that once
13:53:28 <dcoutts> RyanT5000, and then do Preferences -> Save Defaults.
13:53:28 <RyanT5000> i see
13:54:01 <dcoutts> (so it allows you to import a pats file for just one session to play with it)
13:54:44 <RyanT5000> yeah
13:54:56 <RyanT5000> i want to see that haskell shell thing
13:55:30 <RyanT5000> it doesn't really seem hard to design; just basically make a module Shell, and essentially do :m +Shell in ghci
13:58:14 <RyanT5000> but implementing a ton of shell commands would be really time-consuming
13:58:29 <RyanT5000> however i find my self repeatedly wishing i could use combinators on the command line
13:59:40 <monochrom> type UnixCommand = Arrow String String
13:59:55 <monochrom> implement >>> by pipelining
14:00:16 <RyanT5000> map (map (runhaskell Setup) [configure, build, install]) ls
14:00:17 <monochrom> Ouch, need to hide IO there somewhere.
14:00:28 <monochrom> err, s/hide/insert/
14:00:31 <RyanT5000> yeah
14:00:49 <RyanT5000> and really it should be Arrow Stream Stream
14:01:20 <monochrom> It is also possible to define runExternal :: String -> [String] -> UnixCommand
14:02:09 <RyanT5000> yeah
14:02:18 <monochrom> Then you can liberally go runExternal "ls" ["-l", "-a"].  Immediately you can harnass a ton of shell commands.
14:02:46 <RyanT5000> also there should be a version that parses the commandline using an external shell
14:02:47 <RyanT5000> like bash
14:03:15 <RyanT5000> so you could do runShellCommand "ls -la"
14:03:27 <RyanT5000> i've never liked the fact that there's any parsing done by the shell
14:04:05 <RyanT5000> imo, it should be int main(int arglen, char *args)
14:04:15 <RyanT5000> then there should be a libc command that parses args
14:04:33 <RyanT5000> (somewhat trivial issue, i know)
14:04:34 <int-e> that's not unixish.
14:04:39 <RyanT5000> why ont?
14:04:40 <sjanssen> shouldn't it be type UnixCommand = UC FileDes FileDes
14:04:43 <RyanT5000> *why not?
14:04:53 <int-e> besides you'd end up with many tools that break on spaces in file names, etc.
14:05:12 <int-e> it makes no sense to duplicate the parsing code in all binaries over and over again.
14:05:27 <monochrom> I think char** is still the right decision, cf int-e.
14:05:45 <RyanT5000> shared objects...
14:06:11 <RyanT5000> i dunno, it seems strange to impose a parsing scheme
14:06:12 <monochrom> Plus, what is there to parse if you go runExternal "rm" ["monochrom's home", "int-e's home", "Ryan's home"] anyway?
14:06:26 <RyanT5000> monochrom: i wasn't talking about that anymore :P
14:06:46 <RyanT5000> i was talking about runExternalString "ls -l -a"
14:07:03 <int-e> monochrom: now I have a file that's named ["monochrom's home", "int-e's home", "Ryan's home"] and want to delete that.
14:07:09 <monochrom> If you say main should accept char* then you are imposing a parsing and an unparsing scheme.
14:07:27 <RyanT5000> not so, monochrom
14:07:39 <RyanT5000> then you're allowing the executable to choose its parsing scheme
14:07:39 <int-e> monochrom: sorry. I forgot which side you were on ;)
14:08:04 <int-e> RyanT5000: good luck writing portable scripts then. It's hard enough as is.
14:08:21 <monochrom> Then every executable will choose a different one.  Moreover 99% of them will choose dysfunctional ones.
14:08:37 <RyanT5000> well it's not like there aren't tons of them that already suck
14:08:44 <sjanssen> RyanT5000: the shell has to do some parsing anyway, it has to get the executable name for one
14:09:01 <RyanT5000> sjanssen, sure, it has to read up until a space
14:09:13 <int-e> foo\ bar foo bar
14:09:21 <mauke> RyanT5000: what if the executable contains a space?
14:09:24 <RyanT5000> i am not convinced that the parsing imposed by bash/sh/etc. helps programs have sane command line schemes
14:09:36 <mauke> C:\Program Files\oops
14:09:41 <RyanT5000> mauke, then it has to be escaped or quoted just like we already do
14:09:44 <sjanssen> RyanT5000: also has to read the rest of the line to look for special operators
14:10:03 <RyanT5000> sjanssen: that's a very good point which hadn't occurred to me
14:10:43 <RyanT5000> hm i guess that's a sufficient argument to throw all the parsing into the shell
14:10:49 <monochrom> Instead, consider this.  Suppose I write a GUI frontend for "rm".  User picks out five files (with strange filenames using all sorts of characters from unicode).  Is it better to have the frontend concat and unparse the filenames, send one string to rm, and hope that parse.unparse = id?
14:11:15 <RyanT5000> monochrom: i agree with that completely
14:11:18 <monochrom> Or isn't it even more robust to just be able to send rm an array of filenames, no processing?
14:11:24 <RyanT5000> but the shell already sucks in that regard
14:11:37 <RyanT5000> in all honesty i think a text shell sucks to begin with
14:11:39 <int-e> you can always pick a better shell.
14:11:47 <mahogny> just one warning; rm has trouble handling many arguments (as do many commands)
14:11:48 <mauke> how can you live without a shell?
14:11:54 <monochrom> The shells are not a reason against char**.
14:12:19 <int-e> actually shells provide you with the customized parsing you want.
14:12:35 <int-e> up to a point at least.
14:12:44 <monochrom> The shells suck.  But char** is there so that some frontends don't have to suck.  If you remove that, you are requiring every program to suck.
14:12:45 <RyanT5000> i'd rather if programs took formalized arguments
14:13:06 <RyanT5000> but char ** is so halfassed it almost seems pointless
14:13:11 <RyanT5000> that's i guess my basic argument
14:13:15 <chessguy> hey int-e!
14:13:20 <int-e> it's perfect for passing lists of file names.
14:13:32 <RyanT5000> int-e, yes, that, and almost nothing else
14:13:39 <monochrom> NO!  The frontend I outlined uses char** just fine!
14:14:12 <RyanT5000> other than passing lists of filenames, is there anything else it's good for?
14:14:12 <int-e> chessguy: hey
14:14:21 <RyanT5000> i mean, a list of filenames is fundamentally a list of char*
14:14:37 <RyanT5000> if you were going to make it as formal as possible, you wouldn't have to change it
14:14:58 <RyanT5000> but switches, e.g., don't fit that scheme at all
14:15:04 <monochrom> Alright, what do you propose?
14:15:07 <int-e> RyanT5000: Lists are simple and powerful. Both are desirable properties.
14:15:19 <monochrom> Please don't propose char* because that's a big step backwards.
14:15:38 <RyanT5000> my "real" proposal? a type system in the OS
14:15:48 <RyanT5000> pass a bona fide typed value
14:16:01 <RyanT5000> the shell then becomes a dedicated parser
14:16:04 <RyanT5000> and all are happy
14:16:24 <RyanT5000> i believe that's sort of the idea with microsoft's new shell thing ("Monad")
14:16:27 <monochrom> I'll consider that.
14:16:35 <mahogny> you always risk having a completely non-standardardized way of input
14:16:48 <mahogny> with char * or similar
14:17:02 <astrolabe> Is there a built in function like filter but that produce a pair of lists as output (the successes and the failures)?
14:17:05 <RyanT5000> yeah, but you can't really stop people from designing stupid programs
14:17:12 <sjanssen> astrolabe: partition
14:17:19 <astrolabe> thanks
14:17:24 <astrolabe> @type partition
14:17:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:17:28 <mahogny> RyanT5000, true. but at least you can avoid a few by providing a sensible default
14:17:48 <RyanT5000> well i think the default should be a strongly-typed value
14:18:01 <RyanT5000> if you want something weakly-typed, use String
14:18:18 <RyanT5000> that way, you force people to try to figure out a way around the good way of doing things
14:18:23 * int-e would argue that for encoding arguments of shell commands (which are inherently represented in a linear fashion) lists are an ideal choice.
14:18:31 <mahogny> RyanT5000, I don't think haskells type system is good enough for the purpose though. at least not the trivial approach
14:18:57 <RyanT5000> yeah you'd definitely need to add some stuff to it
14:19:09 <monochrom> A dialog box is richer.  Actually we should start considering 3d dialog boxes.
14:19:25 <monochrom> I'm just kidding!
14:19:31 <RyanT5000> lol
14:19:54 <sjanssen> damnit, where's cancel?
14:20:00 * sjanssen rotates his tetrahedron
14:20:00 <RyanT5000> sounds like my SoC proposal :)
14:20:09 <int-e> behind the ok button and the 42 popups
14:20:18 <mahogny> I don't think you want to add to the type system though. what you want is a default datatype system and then a way to export the syntax to the shell so that tab-completion can become really clever
14:20:31 <mahogny> probably quite easy
14:20:43 <RyanT5000> yeah
14:20:44 <mahogny> >> haskellShellCoders;
14:22:04 <sjanssen> I wonder if you could use Parsec (perhaps with extensions) to provide tab completion
14:22:55 <mahogny> sjanssen, not easily I'd say
14:22:59 <sjanssen> I mean, it's already clever enough to say "newline or space expected", etc.
14:23:25 <shapr> Seen h4sh?
14:24:17 <Jack123> hi all
14:24:21 <shapr> hi Jack.
14:24:24 <mahogny> sjanssen, that's only live during parsing though, right?
14:24:28 <Jack123> how are you all?
14:24:34 <Jack123> i hope you are fine
14:24:39 <shapr> I'm awake.
14:24:44 <shapr> Jack123: Learning Haskell?
14:24:46 <Jack123> :)
14:24:46 <Jack123> ok
14:24:59 <Jack123> yes , is it so clear from outside ? :)
14:25:22 <shapr> Well, I haven't seen you here before, so it's possible at least.
14:25:23 <ndm_> Jack123: he just knows everyone in the channel, so can spot a new visitor :)
14:25:29 <sjanssen> mahogny: I'm sure exactly how Parsec achieves those messages
14:25:35 <Jack123> oh ok
14:25:40 <Jack123> yes , i am very new
14:25:48 <sjanssen> mahogny: rather, I'm not sure
14:25:56 <Jack123> although i am an old chatter from 1995-6s...
14:26:12 <Jack123> i am a student in university
14:26:21 <Jack123> can i learn your jobs please?
14:26:49 <mahogny> sjanssen, well, I guess you could parse the entire thing each time you tab:ed. if you added new primitives "filename" etc then you would be on your way. but I don't see an easy way to export the definition to the shell
14:27:10 <Jack123> it is really late now here , i have to go now
14:27:13 <Jack123> nice to meet you again
14:27:15 <Jack123> take care
14:27:16 <Jack123> bye
14:28:07 <eamelink> four minutes
14:28:19 <eamelink> four minutes between joining a new channel and 'really late' :P
14:28:22 <eamelink> Funny :P
14:28:41 <sjanssen> mahogny: Parsec would have to integrated at the OS level.  If every program was a Haskell module that had a "commandParser :: Parser CmdLine" in the top level, the shell could just look at that parser
14:29:25 <mahogny> sjanssen, that approach is unrealistic
14:30:34 <sjanssen> teaching the shell a commands syntax is going to require extensive changes regardless
14:30:48 <monochrom> How do you define CmdLine so that it respects the rich structures of all possible command lines?
14:31:44 <mahogny> sjanssen, not really
14:31:45 <sjanssen> monochrom: that's one problem I haven't figured out
14:32:18 <musasabi> Isn't MS doing something like that with the new shell?
14:32:26 <musasabi> And I think that is the right direction to move.
14:32:34 <musasabi> Make interfaces strongly typed.
14:32:38 <sjanssen> mahogny: if you really want to tie the syntax with the executable, you have to at least add a symbol to it
14:32:52 <mahogny> sjanssen, more realistic version: you write a <programname>.shellcomplete which the shell can read
14:33:16 <mahogny> you should never ever make the shell run code to check for tab completion
14:34:02 <sjanssen> mahogny: if we want sufficiently powerful completions, we're going to need to run code
14:34:19 <ADEpt> @hoogle concatMapM
14:34:20 <lambdabot> No matches found
14:34:32 <musasabi> ADEpt: you need to define that by hand.
14:34:40 <musasabi> @type sequence . concatMap
14:34:41 <lambdabot>   Couldn't match `[m a]' against `t -> t1'
14:34:41 <lambdabot>   Expected type: [m a]
14:34:44 <mahogny> sjanssen, that solution is unacceptable
14:34:59 <sjanssen> for example zsh has darcs completion, when I do "darcs add" then tab, zsh is smart enough to figure out which files aren't added to the project yet and suggest the
14:35:01 <sjanssen> m
14:35:19 <ADEpt> @type (liftM concat) . mapM
14:35:20 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:35:27 <sjanssen> I argue that's a useful case, and we're going to need to run code to do it
14:35:42 <mahogny> sjanssen, I argue that we'll have to live without it :(
14:35:55 <dcoutts> mahogny, you're talking about SoC ticket 27?
14:36:03 <RyanT5000> i think the first problem is that we can't safely run code
14:36:09 <mahogny> dcoutts, well. it might be something to consider if you want to try something new
14:36:18 <RyanT5000> there's no good reason that code that does no IO can't be run with 100% safety
14:36:21 <mahogny> right. that's why you can't run code. way unsafe
14:36:37 <sjanssen> RyanT5000: another point.  That's why we should rewrite the entire OS in Haskell so we can statically be sure
14:36:51 <mahogny> tell that to unsafePerformIO
14:36:53 <dcoutts> mahogny, you've seen there's a student has applied for that one right?
14:37:04 <mahogny> dcoutts, yeah. is there a mentor for it?
14:37:28 <dcoutts> mahogny, well you said you might be interested didn't you?
14:37:29 <mahogny> anyhow. you need to output a subset that can easily be verified. the easiest to verify is if you can write a very flexible spec file
14:38:05 <mahogny> dcoutts, well. I can handle it in worst case but I already have trouble counting my students
14:38:13 <dcoutts> heh
14:38:32 <mahogny> I mean, there gotta be more mentors than me around >_<
14:38:34 <jfoutz> the shell can have a little interpreter that can only do safe things.
14:39:01 <jfoutz> this "can't run code" sounds fairly arbitrary.
14:39:08 <dcoutts> mahogny, yeah there are a few, we can talk about it together when the applications close.
14:39:14 <mahogny> dcoutts, right
14:39:40 <mahogny> jfoutz, true. but there gotta be some limit on what complexity we take on for such a simple feature
14:40:03 <RyanT5000> screw static verifiability
14:40:07 <mahogny> lol
14:40:21 <RyanT5000> throw it in a protected-mode task with no gates except "exit"
14:40:30 * mahogny should force RyanT5000 to run his gui widget set through programatica ;)
14:40:31 <RyanT5000> when it says "exit", you look at the results
14:40:48 <RyanT5000> mahogny, what's that?
14:41:07 <mahogny> RyanT5000, tool that gives you formal proofs of properties in your code :)
14:41:12 <RyanT5000> cool :)
14:41:23 <RyanT5000> but i doubt that a GUI will have many interesting formal properties
14:41:29 <mahogny> I'd love to see at least the syntax go into haskell'
14:41:54 <mahogny> well, the very interesting property is, will it lock/crash/mess? it's hard to verify currently
14:43:35 <RyanT5000> true, but given that i'm interfacing with SDL, OpenGL, FreeType, and maybe a few other libs a *lot*, it'd be hard to prove anything regarding that kind of stuff
14:44:27 <mahogny> no. you'd have to assume that the libraries on top work. the proving would be on the level below
14:44:53 <mahogny> still, that's messy too. I even have a ticket for SoC on implementing tools for that
14:47:45 <musasabi> proving things for pure haskell code would be nice.
14:48:16 <musasabi> just things like "is this function total?" "does this function terminate on finite inputs" "is this function transitive" etc
14:48:54 <palomer> INRIA is working on that for ocaml
14:49:21 <palomer> you also have esml for sml
14:49:46 <jcreigh> musasabi: Excuse my ignorance, but wouldn't proving if a function terminates involving solving the Halting Problem?
14:49:47 <palomer> formal verification doesn't seem to be very strong in the haskell community
14:49:55 <monochrom> A GUI has a lot of interesting formal and correctness properties, but I (and most researchers) don't know how to define them nicely.
14:50:37 <palomer> monochrom: for example?
14:50:38 <mahogny> that's where it fails. but it would be a good start if at least you could run a check if it survives usage
14:51:59 <mahogny> palomer, well. give a non-obvious property for a 3d modeler without involving the model? then come up with some good syntax for it
14:52:33 <palomer> hmm?
14:52:44 <mahogny> just to get a feeling for the problem :)
14:52:55 <mahogny> it's not impossible. just very messy
14:52:59 <palomer> I'd like to know what kind of properties we're talking about
14:53:06 <palomer> window position?
14:53:09 <palomer> modality of windows?
14:53:16 <mahogny> well, that's half the problem. what would one want to check?
14:53:24 * palomer gives up
14:54:01 <monochrom> Let's say in front of me I have a dialog box.  It has a number field (no, not *those* number fields!), an a button called "inc".  If I click inc, the number increases by 1.  Which formalism do you use to formalize that?
14:54:01 <musasabi> jcreigh: one can prove it for an interesting subset of functins.
14:54:31 <RyanT5000> monochrom: that's not a constraint on the GUI, but on the application behind the GUI
14:54:43 <musasabi> jcreigh: one can write a terminating programs that given a program says {Halts,Infinite,TooComplexForMe}
14:54:44 <monochrom> Next, I have the code for that dialog box.  Which logic do you use to prove that the code satisfies the spec?
14:54:46 <RyanT5000> GUI constraints would be, e.g., "A button is never shown depressed when the mouse cursor is not in it"
14:55:05 <mahogny> RyanT5000, you want to be able to prove things, both with and without the model connected
14:55:23 <int-e> RyanT5000: hmm. and you
14:55:37 <int-e> 'll find that real GUIs don't satisfy that
14:56:22 <int-e> (at least not on systems where the mouse cursor is shown independently of the application)
14:56:36 <RyanT5000> mahogny: yes, but his example, to me, would be a formalism about "the GUI and the model", not just either one
14:56:47 <RyanT5000> int-e, true
14:57:04 <RyanT5000> i think it's true on windows, though, or at least it's pretty close and it could be true
14:57:12 <monochrom> Now, you can use a temporal logic to formalize "when inc is clicked, _____ happens".  You can use a process algebra to express an abstraction of the code.  Then you can prove/disprove their connection.
14:57:14 <RyanT5000> on windows, the code to draw a button is in the kernel
14:57:33 <mahogny> RyanT5000, most GUIs have the number replicated both in the window and the model. so not really
14:57:38 <RyanT5000> so they could sync redrawing the button with redrawing the mouse
14:57:50 <RyanT5000> mahogny: i hate that :)
14:57:58 <RyanT5000> it won't be the case in mine
14:58:01 <monochrom> But the ____ involves increasing numbers and infinite state spaces.  You need to extend existing temporal logics and process algebras for that.
14:58:05 <mahogny> RyanT5000, yes, it's horrible
14:58:08 <int-e> RyanT5000: of course what you actually want is that the duration of such inconsistencies is limited by a small constant.
14:58:44 <RyanT5000> int-e, true, although IMO that constant *could* be smaller than 1 frame, so it *should*be
14:58:58 <RyanT5000> and <1frame == 0, for the purposes of that formalism
14:59:00 <monochrom> Perhaps by saying all those, I have just outlined the beginning of a solution, and you can see how it unfolds.  But I am not sure whether this is the most usable formalism.
14:59:30 <mahogny> I think you are working on the wrong level. if you want to do formal proving, leave the graphics away. then with the right abstraction, it should not be a major problem to prove
15:00:54 <RyanT5000> anyone know how to redock a window in X-Chat?
15:01:08 <RyanT5000> (sry about off-topicness)
15:01:09 <int-e> ctrl-i
15:01:19 <RyanT5000> awesome, thanks :)
15:01:30 <int-e> same as for undocking.
15:01:32 <monochrom> Yes, I am leaving out the graphics.  It is now just a UI, without G, with a number and a message type "inc".
15:01:37 <palomer> > (,1) 2
15:01:37 <lambdabot>  parse error on input `1'
15:01:45 <palomer> who here thinks that should be valid syntax?
15:01:56 <resiak> .o/
15:02:02 <work_metaperl> could someone tell me if this can be written even more abstractly? http://rafb.net/paste/results/NEFOJs19.html
15:02:07 <RyanT5000> palomer: looks reasonable
15:02:23 <monochrom> Of course another research direction can add back the graphics.
15:02:29 <RyanT5000> @type (1, 2) :: (,) Int Float
15:02:30 <lambdabot> (,) Int Float :: (Int, Float)
15:02:33 <int-e> palomer: it'd be nice to have. actually even (,2,) = \a b->(a,2,b) would be nice.
15:03:05 <mahogny> ok. note: docking in xchat is buggy :P
15:03:08 * monochrom cringes!
15:03:09 <int-e> mahogny: would you agree that it's a different level?
15:03:31 <mahogny> int-e, I think I got desynched with xchat dying on me. what is a different level?
15:03:49 <int-e> mahogny: you said "I think you are working on the wrong level."
15:04:09 <monochrom> I think that's to RyanT5000, not even to me.
15:04:09 <int-e> mahogny: with respect to specifying the actual graphics output of a GUI.
15:04:55 <monochrom> But it's perfectly sound to spin off two of three directions of research.  Each one formalizes one level.
15:05:00 <mahogny> int-e, aha. what I mean is that you should not try to involve the graphical output in the specification because it is way too messy for a normal tool. so abstract it away
15:05:04 <monochrom> s/of/or/
15:05:49 <mahogny> int-e, I think only the eye is a good enough tool for the job, when it comes to testing the graphics. so make the system simple, and make sure you only have to test it once and then it works
15:05:59 <monochrom> For an application programmer, my level suffices, and to be picky on wording, RyanT5000 is right, that's application level, not graphical level.
15:06:35 <monochrom> But someone also needs to prove that this abstraction is correctly concretized by a particular implementation of let's say GNOME2.
15:07:23 <mahogny> monochrom, you would catch the calls to the widgets and pass it out as something you can do logic on, instead of passing it to the screen. then you can do really detailed checking
15:07:38 <palomer> whoa, my code works
15:07:57 <monochrom> Yes yes.
15:09:09 <monochrom> It's like when I have some Haskell code and want to prove some properties of it, I use a simple rewriting semantics (like that in Hudak's book).
15:09:28 <shapr> work_metaperl: map ($) (sequence [[twoThreeAg],[above,sideBySide]]) ?
15:09:35 <monochrom> Someone else will have to prove that ghc translates the rewriting semantics to x86 code properly.
15:09:59 <monochrom> Or we can handwave away the latter.  But as an application programmer I want to do the former.
15:10:03 <mahogny> omg
15:10:28 <monochrom> You don't like a proved ghc?  ^^
15:10:44 <palomer> I want a usable ghc
15:11:08 <monochrom> But as an application programmer I also don't want to prove Haskell code by mentioning x86.
15:11:09 <shapr> sequence on the list monad does cartesian product, is there something that does all orders of a list?
15:11:23 <shapr> palomer: dude, just use ghc :-P
15:11:31 <palomer> I'm using ghc!
15:11:39 <shapr> ergo, you have a usable ghc ;-)
15:11:42 <monochrom> ghc is clearly correct!
15:11:53 <mahogny> monochrom, first step towards a proof: drop x86!
15:12:22 <RyanT5000> or, use a small subset of x86 if you only care about provability
15:12:59 <int-e> Hmm. x86, you say. What CPU did you have in mind?
15:13:02 <mahogny> I'm afraid I don't compromise performance for proofs. in fact, I prefer to see proofs as a way to optimize :)
15:13:09 <RyanT5000> hm
15:13:16 <mahogny> int-e, my own planned one. no, I'm not gonna submit it to SoC ;)
15:13:32 <monochrom> shapr: probably you want to get all permutations of a list first?
15:13:44 <shapr> Nah, I just want all orders of items in the list.
15:13:53 <int-e> mahogny: you didn't understand. There are many x86 CPUs around, some with funny bugs.
15:14:05 <monochrom> permutations it is.
15:14:13 <mahogny> int-e, using x86 opcodes is a bug in itself
15:14:14 <RyanT5000> and some with serial numbers >:-(
15:14:15 <shapr> But performing a proof is equivalent to executing a program...
15:14:30 <shapr> Oh right, I got permutations confused with powerset.
15:14:33 <ndm_> monochrom: what kind of thing do you want to prove about haskell code?
15:14:57 <shapr> RyanT5000: Obviously x86 cpu need a QuickCheck test suite.
15:15:03 <monochrom> For example that map satisfies the axioms of fmap.
15:15:23 <RyanT5000> shapr, lol
15:15:52 <mahogny> well, we really should thank x86 really. the bugs have made intel really push for formal proofs
15:16:34 <monochrom> I think you mean we should thank the bugs XD
15:16:53 <int-e> well, intel was there to create them ;)
15:17:08 <monochrom> Bugs are now also pressing a few Microsoft people to consider formal proofs (at least the automatic ones) again.
15:17:59 <mahogny> ok. I guess that means we gotta take down that beast before it gets its teeth into something really useful :(
15:18:45 <shapr> I think that there will be something closer to proof programming soon. At the moment I'm betting on dependently typed languages.
15:19:58 <shapr> At the same time, I wonder if compiler optimization research can be 'ported' to automated proof assistants?
15:21:49 <monochrom> Some people are beginning to do that.
15:21:56 <shapr> monochrom: The GHC version of QuickCheck has nifty properties like commutative, associative, etc. Those could be used for equivalence tests.
15:22:36 <monochrom> But it's a difficult start because traditional optimization has completely ignored proofs altogether.  Some optimizations also require a subtle logic to express and prove.
15:25:01 <mahogny> well, a good start would be if haskell had the programatica syntax in by default. then you have the option of using the statements without-proof for optimization. checking if they hold can be done by other tools
15:25:39 <work_metaperl> I had been hoping for some feedback on further abstracting some simple functions... please? :)  http://rafb.net/paste/results/NEFOJs19.html
15:26:00 <palomer> w00t
15:26:07 <palomer> can I get a wot wot
15:26:15 * palomer waits for the wot wot
15:26:46 <mahogny> tow tow!
15:26:51 <mwc> Bwahaha, just walked into the social science building (need an soc sci credit still). What do I see in the parking lot, but a sign reading "(P)\nPARK BETWEEN\nYELLOW LINES"
15:27:01 <ndm_> mahogny: is there some intro to the programmatica syntax somewhere?
15:27:10 <mahogny> ndm_, check their page
15:27:17 <mahogny> I think that is pretty much it
15:27:18 <ndm_> @where programmatica
15:27:19 <lambdabot> I know nothing about programmatica.
15:27:22 <mahogny> mwc, lol
15:27:29 <shapr> work_metaperl: Did you see my feedback?
15:27:34 <work_metaperl> oh no
15:27:38 <work_metaperl> I was about to hit my blog
15:27:42 <work_metaperl> i will search back through
15:27:47 <ndm_> i'm working on an automated prover for haskell as we speak, so should check otu what they have :)
15:28:04 <mwc> mahogny, obviously this building hosts the creme of the university
15:28:07 <mwc> 's brain trust
15:28:16 <shapr> ndm_: Seen Martin Sjogren's work?
15:28:17 <palomer> I think an automated prover for haskell would be a _great_ SoC project
15:28:24 <mahogny> ndm_, I'd like to see their syntax unified with QuickCheck. I have a SoC ticket for it, if you have a student ;)
15:28:24 <work_metaperl> found it: <shapr> work_metaperl: map ($) (sequence [[twoThreeAg],[above,sideBySide]]) ?
15:28:40 <ndm_> shapr, not yet, but i'll write it down :)
15:28:41 <mahogny> palomer, 3 months.... _3_ months :(
15:28:53 <ndm_> mahogny: i am a student :)
15:28:56 <shapr> work_metaperl: Yeah, and you can do more by using a permutations function on the two bits that need to be (a,b) and (b,a).
15:29:05 <mahogny> ndm_, aha :)
15:29:52 <palomer> heck, I'd be interested in writing one
15:30:01 <shapr> Programatica's editor component already deals with QuickCheck, proof assistants, and more.
15:30:03 <palomer> if my other ticket doesn't fall through
15:30:05 <mahogny> palomer, it's not very simple
15:30:15 <palomer> mahogny: oh, I know
15:30:31 <shapr> They use generic 'certificates' that can be a variety of things, including checking a box that says "I'm sure this is correct, just trust me."
15:30:49 <mahogny> shapr, someone get that bloody syntax into haskell' :(
15:31:11 <shapr> It's just an editor...
15:31:17 <shapr> You can install it and use it :-)
15:31:42 <mahogny> shapr, yes, but it would be nice if I could put all that new syntax into my haskell files and still expect all compilers to behave
15:32:18 <shapr> Should be easy with a preprocessor.
15:32:36 <mahogny> yes. but make sure that preprocessor is in there by standard
15:32:37 <ndm_> i'm surprised they didn't go with haskell functions
15:32:39 <shapr> You can easily call any sort of preprocessor with one of the -pgmF thingies.
15:32:49 <mahogny> ndm_, why?
15:33:09 <ndm_> mahogny: easy to give a special meaning, portable code, can be checked at runtime - esp for things like assert
15:33:20 <shapr> mahogny: Write a shell script that strips PFE certificates, send a darcs patch.
15:33:31 <mahogny> shapr, hm. would be a way
15:33:45 <ndm_> in my logic you can say things like "assert (null res) res", and it checks that statically
15:34:01 <ndm_> but is still 100% haskell, and can be checked at runtime, if you want
15:34:05 <mahogny> ndm_, formal proofs are messy enough without generic syntax in properties
15:34:13 <ndm_> mahogny: i know :)
15:34:52 <ndm_> shapr, do you have a link for Martin Sjogren?
15:35:02 <ndm_> googling gets me a marine biologist :)
15:35:10 <shapr> He's got dots over that o
15:35:38 <shapr> http://www.mdstud.chalmers.se/~md9ms/
15:36:01 <mahogny> hm. my university is crowded
15:36:25 <shapr> mahogny: C'mon, it'll only take you a few hours to write up something that strips PFE certificates, do it!
15:36:57 <mahogny> shapr, yeah. however, those hours are usually taken from the time I sleep so it's rather low priority. at least until summer :)
15:37:03 <ndm_> shapr, i can't see anything he's done on that page, only courses he's been too
15:37:24 <shapr> ndm_: Me neither... I may have a copy of his thesis around here somewhere.
15:37:51 <mahogny> www.math.chalmers.se has preprints. you might find it there (if it was in math)
15:39:53 <ndm_> can't find anything on the preprints (although i think i might have got it wrong, being an english only person)
15:41:08 <mahogny> http://www.md.chalmers.se/EM-Masters/theses/index.html
15:41:08 <shapr> Anyway, he turned a subset of Haskell into something that a proof assistant could chew on.
15:41:21 <mahogny> hm
15:41:25 <ndm_> what kind of subset?
15:41:26 <mahogny> this list... gotta be more
15:41:30 <mahogny> but I dunno where
15:41:50 <ndm_> since i have a tool that takes all of Haskell to a very reduced language
15:42:10 <ndm_> a first order subset, with about 4 language elements in it
15:43:17 <work_metaperl> I would like to know  what sequence does in Haskell, but cant find any good online info
15:43:41 <ndm_> work_metaperl: take a look at the implementation
15:43:49 <ndm_> in hugs, :f sequence
15:44:06 <work_metaperl> damn, just wiped hugs... :) ok re-installing
15:44:12 <ndm_> sequence []     = return []
15:44:13 <ndm_> sequence (c:cs) = do x  <- c
15:44:16 <ndm_> 		     xs <- sequence cs
15:44:17 <ndm_> 		     return (x:xs)
15:44:20 <ndm_> don't wipe hugs, its great :)
15:44:36 <dons> moin
15:45:08 <work_metaperl> i use ghci
15:45:44 <work_metaperl> anyway, I had been trying to make this even more abstract: http://rafb.net/paste/results/NEFOJs19.html
15:45:51 <work_metaperl> would you care to help? dons or ndm_?
15:46:58 <ndm_> work_metaperl: you could pass a bool, and then have it if for the joiner and builder
15:47:02 <dons> dcoutts: great idea for the better eq!
15:47:06 <ndm_> but not really, certainly not with sequence
15:47:55 <dons> eq (PS p s l) (PS p' s' l') = p == p' && s == s' && l == l', right?
15:49:00 <dons> ah, but that's not true.
15:49:08 <dons> right, we need to short cut.
15:49:08 <dons> and maybe still compareBytes
15:49:12 <dons> as you say, dcoutts 
15:49:18 * dons drinks coffee
15:50:36 <dons> ah, there we go. much better
15:51:00 <musasabi> dons: have you tried how much win is inlining the ForeignPtr implementation?
15:51:19 <dons> hmm. no. a la the MVar stuff?
15:51:28 <dons> I should have a look at that.
15:51:53 <dons> I've been concentrating on getting array fusion working, but inlining ForeignPtr code would also be a good idea.
15:52:00 <musasabi> yes, wondering why the memcmp is so expensive for small strings.
15:52:35 <mahogny> musasabi, call overhead?
15:52:39 <dons> right. at least now the same string is going to be spotted without an memcmp.
15:53:04 <shapr> Thinking about the thread/event unification, I wonder what other parts of the RTS would be useful to move into 'userspace' ?
15:53:24 <ndm_> dons, isn't there a quick Eq test to see if they are the same length?
15:53:42 <musasabi> mahogny: it is an unsafe call so there should not be that much overhead.
15:53:48 <shapr> I wonder if GC could be in userspace somehow?
15:53:50 <ndm_> to quickly say no
15:54:27 <mahogny> musasabi, it's still called. normally, gcc inlines it
15:54:29 <dons> that's a good idea too.
16:02:03 <dons> musasabi: i've just comitted the short cut cases for eq and cmp. Hopefully that avoids many calls to memcmp (particularly the eq case, thanks ndm!)
16:16:20 <musasabi> ok
16:18:50 <araujo> :-)
16:23:50 <iturk> hi there i am trying to look for a good online tutorial
16:24:03 <iturk> can someone give some good reference
16:24:32 <mlh> iturk: besides the ones mentioned on haskell.org?
16:24:49 <mlh> i liked the one by Daume
16:27:01 <dons> check out haskell.org, and follow the 'Getting started' or 'Books and tutorials' links
16:27:42 <iturk> mlh: Yet Another Haskell Tutorial from Daume you mean ?
16:28:00 <mlh> eh probably :-)  I read it quite a while ago
16:29:04 <iturk> dons: i am trying not to pick some bible but some nice one to be read also considering that i have a background of many other languages !!
16:29:55 <palomer> dons: want to be the mentor for ticket #78?
16:30:10 <mlh> iturk: maybe you want something more advanced then
16:32:09 <iturk> mlh: it can be
16:32:42 <iturk> mlh: if i think its to much then i go to some other more basic
16:34:08 <dons> palomer: gimme a url
16:34:22 <dons> or just add <dons@cse.unsw.edu.au> Don Stewart as the mentor, please
16:34:32 <palomer> sure
16:34:38 <palomer> http://hackage.haskell.org/trac/summer-of-code/ticket/78
16:36:29 <dons> palomer: ok. looks good.
16:36:34 <mlh> why was $ chosen? it's hardly less ugly than a bunch of parens!
16:38:06 <Igloo> It's a lot clearer when you have just infix operators than when you need to count closing parens
16:38:37 <Igloo> I have no idea why $ in particular, but I don't think it's particularly ugly, as available infix operators go
16:39:05 <palomer> $ is a godsend
16:39:27 <palomer> it's one of haskell's top features
16:39:27 <dons> withForeignPtr x $ \y -> ... is a nice idiom we get as a result. For all sorts of higher  order functions
16:44:16 <liyang> Also: thing $ do { ... } (where the braces are replaced with indentation.)
16:44:26 <liyang> dead handy.
16:45:40 <work_metaperl> iturk: "Craft of Functional Programming" is the one to go with
16:47:14 <iturk> work_metaperl: its possible to obtain it online
16:50:54 <liyang> iturk: the first five chapters of Programming in Haskell is available online -- http://cs.nott.ac.uk/~gmh/book.html
16:50:57 <liyang> *cough*
16:51:43 <dons> oh, didn't know that.
16:51:56 <work_metaperl> liyang: did you write it?
16:52:13 <dons> liyang /= Hutton, I think. unless i'm really wrong
16:52:31 <liyang> I'm not Graham Hutton.
16:52:42 <liyang> I've never met the man.
16:52:51 <liyang> I've never even heard of that name!
16:53:07 <dons> but you're at nott..
16:53:08 <dons> ?
16:53:20 <liyang> >_>
16:53:22 <liyang> <_<
16:53:41 <liyang> (*cough*super*cough*visor*cough*)
16:53:58 <dons> ah, it all falls into place
16:54:09 <dons> :)
16:54:44 <dons> this is the channel for people whose supervisors have published haskell books :)
16:54:55 <liyang> I don't think we're that exclusive.
16:55:24 <dons> true. there's what, 217 #haskellers the other day?
16:55:36 <palomer> my supervisor hadn't heard of haskell until I told him about it
16:55:42 <liyang> And it's not published yet... not until CUP get their act together.
16:55:45 <palomer> and the person who's funding me hates monads
16:55:47 <dons> our army of dark lambdas is gathering!
16:55:50 * Igloo wonders what percentage actually participate
16:55:51 <palomer> (no kidding)
16:56:30 <liyang> But he's been giving out preprint copies of the books if anyone thinks it might be good to teach from...
16:56:40 <dons> Igloo, 10%?
16:56:40 <palomer> though she's never touched haskell
16:56:43 <dons> maybe 20?
16:57:05 <palomer> there should be a book on haskell monads
16:57:10 <liyang> palomer: but monads are everywhere!
16:57:12 <palomer> and monad transformers
16:57:26 <Igloo> That was about my guess, but it's the sort of thing I can imagine turning out to be spectacularly wrong
16:57:37 <dons> palomer: there's a bunch of books to be written by us haskell hackers beyond the intro books written by professors, I think.
16:58:01 <palomer> true dat
16:58:04 <dons> Haskell Cookbook, Advanced HAskell, Systems Programmign in HAskell, High Assurance software in HAskell
16:58:25 <int80_h> yeah write those books!
16:58:26 <dons> grr. I can't lift my finger off the shift key fast enough.
16:58:41 <monochrom> High Assurance System Kernels Employing Lazy Lambda
16:58:42 <int80_h> I like the high assurance angle
16:58:48 * Igloo overclocks dons
16:58:51 <int80_h> that will sell and popularize haskell
16:59:02 <dons> yow! that's better.
16:59:23 <dons> Bug-free code the haskell way
16:59:33 <dons> yadda yadda. there's a dozen books to be written
16:59:45 <dons> documenting what we all learnt through painstaking email and src trawling.
16:59:59 <int80_h> hmmm
17:00:16 <dons> pity we spend all our time writing papers instead..
17:00:20 <int80_h> hey I'm at a loss concerning my coogle proposal. I have a second draft...anyone care to offer feedback?
17:00:30 <int80_h> erm google
17:00:33 <dons> int80_h: mail me, i'll have a peep
17:00:41 <int80_h> okay, addy?
17:00:42 <liyang> palomer: I seem to remember Programming in Haskell has a pretty gentle introduction to monads. In fact, monads aren't even mentioned in the table of contents, because it's such a scary name.
17:00:59 <palomer> I want a whole frigging book on monads
17:01:03 <palomer> with monad transformers
17:01:10 <int80_h> it conjures images of those box like creatures from the manual of the planes
17:01:13 <liyang> There's that MT paper...
17:01:13 <dons> Advanced Monadic Programming
17:01:38 <int80_h> monads! monads have come to judge me!
17:01:42 <liyang> And you'd want something on arrows and applicative functors (aka idioms) too.
17:01:49 <dons> with non-det monads, back tracking monads, hmm. transformers, hardware monads and more
17:01:55 <int80_h> you know, because they were lawful neutral
17:02:11 <int80_h> dons, what's yer addy?
17:02:18 <dons> dons@cse.unsw.edu.au
17:02:22 <int80_h> thanks :)
17:04:22 <liyang> Monads are nice and fluffy. The name puts too many people off. :(
17:05:00 <liyang> Anyone else writing HCAR entries?
17:05:54 <palomer> yes, applicative functors please!
17:07:45 <dons> liyang: yeah, by May 12, right?
17:09:35 <int80_h> okay dons, sent
17:10:19 <dons> oh, new paper, interesting: http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html a new microkernel in haskell.
17:12:43 <liyang> dons: yup. Putting together the draft version here.
17:12:47 <liyang> I should be in bed. -_-;;
17:12:51 <liyang> Night night.
17:16:07 <jethr0> dons: i'm looking for a matrix library and am currently using "http://haskelldsp.sourceforge.net/doc/index.html". but it doesn't seem to handle matrix inversion very well. any alternatives/ideas?
17:19:53 <dons> hmm. I don't know much about matrix code. Only what's on the libraries page. Otherwise ask on haskell-cafe@, and maybe one of the physicists can offer some ideas
17:20:07 <jethr0> k, thx
17:38:53 <dons> note to self: things aren't rules if they're in {- -} tags.
17:38:59 <dons> must use {-# RULES #-}
17:45:26 <bolrod> :]
17:46:00 <bolrod> note to self
17:46:07 <bolrod> its 2:45 AM
17:46:37 <bolrod> note to other self:  Go get a new haircut
17:48:29 <Cale> note to self: figure out what other self is doing
17:49:24 <monochrom> Hahahaha {- -} are not tags
17:49:40 <monochrom> err nevermind
17:50:43 <bolrod> {-.[}
17:50:46 <bolrod> {-.-}
17:51:17 <bolrod> > let {-.-} a = a in {-.-} 3
17:51:18 <lambdabot> 3
17:51:23 <bolrod> :}
17:51:29 <ihope> Heh.
17:51:50 <ihope> > let {-.-} a = a + 2 in {-.-} 5
17:51:51 <lambdabot> 5
17:52:01 <bolrod> ;p
17:52:21 <bolrod> its a cool operator though
17:52:44 <bolrod> 'the invisible, useless operator'
17:52:49 <bolrod>    {-.-}
18:01:47 <araujo> :-)
18:02:15 <araujo> hiya!
18:02:32 <lscd> hi araujo 
18:09:32 * palomer hates ghc's GADTs
18:11:20 <Cale> palomer: why?
18:11:51 <palomer> because it  won't infer a type for my function!
18:12:08 <palomer> or, rather, it won't even check the type I give it
18:12:31 <Cale> I know it can't infer types a lot of the time, but it won't check them?
18:13:09 <palomer> yup
18:13:19 <palomer> unless there's something special to enable polymorphic recursion?
18:13:55 <Cale> So you can give a function an incorrect type, and it'll still compile?
18:14:16 <palomer> no, I give it a correct type
18:14:19 <palomer> and it refuses to compile
18:14:38 <Cale> what's the error?
18:15:30 <palomer> http://www.rafb.net/paste/results/t0KZXm22.html
18:15:44 <palomer> if you remove the last line it works fine
18:16:09 <palomer> this is with a build I built 3 weeks ago
18:16:30 <palomer> ghc 6.4.1 refuses to infer, even if I remove the last line
18:16:36 <palomer> (which the latest build thankfully lets me build)
18:26:08 <Cale> palomer: I get a type error checking that y hand
18:26:44 <palomer> do you agree that  it should type?
18:26:52 <Cale> no
18:27:09 <palomer> if you remove the last line (with the two Mus) it types
18:27:13 <Cale> I know
18:27:19 <palomer> and the last line is defininately correct
18:27:25 <Cale> Mu a :: Term (a -> x) y
18:27:43 <Cale> Mu b :: Term a y
18:27:45 <palomer> Mu :: Term a b -> Term b a
18:27:49 <Cale> so
18:27:55 <Cale> a :: Term y (a -> x)
18:28:02 <Cale> b :: Term y a
18:28:21 <palomer> oh, righto
18:28:47 <ihope> What's Mu?
18:28:58 <ihope> The sound a kitten makes?
18:29:20 <palomer> a greek kitten
18:29:34 <ihope> Ah.
18:30:21 <Cale> so anyway, forming App a b will force y = (u -> v) for some types u and v
18:30:26 <Adamant> the sound of a technical manual impacting the back of your head
18:30:27 <Cale> but then it won't e polymorphic
18:30:28 <Cale> be*
18:31:00 <palomer> what won't?
18:31:12 <Cale> well, it'll be less polymorphic
18:31:14 <Cale> eval
18:31:25 <palomer> sure, the existential variables won't be able to leak out
18:31:30 <Cale> eval :: Term x (u -> v) -> Term x (u -> v)
18:31:32 <palomer> but, I'm not intending them to
18:31:53 <palomer> but I'm never applying the second argument
18:31:54 <Cale> (but it's possibly even worse than that)
18:32:21 <palomer> oh no, I want eval to be more general
18:32:37 <Cale> right, which is why that last line isn't typechecking
18:32:40 <palomer> it works, though
18:32:44 <Cale> huh?
18:32:49 <palomer> (you have to change it a little bit)
18:33:32 <Cale> sorry, what did you change?
18:34:16 <palomer> http://www.rafb.net/paste/results/MozG3162.html
18:40:44 <RyanT5000> is there an easy way to make nedit less ugly?
18:40:57 <RyanT5000> i mean i don't care about aesthetics that much, but nedit is *really* ugly
18:42:20 <swoolley> RyanT5000: install xemacs and be prepared for uglier
18:42:33 <Cale> hehe
18:42:40 <RyanT5000> lol i have, on my windows box
18:43:06 <Cale> there's gedit
18:43:20 <RyanT5000> does it have syntax hilighting, smart tabbing, etc.?
18:43:21 <Cale> might not have as many features, I don't know
18:43:24 <RyanT5000> (for haskell)
18:43:35 <Cale> I see Haskell syntax highlighting
18:43:41 <RyanT5000> really smart tabbing is all i care about
18:44:07 <RyanT5000> autocompletion would be nice but it's not like i'm working in Java or .NET
18:49:13 <RyanT5000> can't someone skin emacs?
18:49:27 <RyanT5000> there's no fundamental reason it needs to look so bad
18:49:44 <palomer> there are themes
18:49:53 <RyanT5000> unless it's designed from the ground up on the assumption that it's working with the screen directly
18:49:54 <palomer> but, like, I removed the titlebar
18:50:01 <palomer> the titlebar is really ugly and takes up space
18:50:01 <Cale> I've managed to make gnu emacs look a little less bad, but someone really needs to write a GTK2 ui for it.
18:50:08 <palomer> M-x title-bar<tab>
18:50:18 <palomer> there is a gtk emacs
18:50:35 <Cale> I want anti-aliased fonts :)
18:50:37 <palomer> it might have died
18:50:44 <RyanT5000> Cale have you looked at ProFont?
18:50:49 <RyanT5000> i find it to be really nice
18:50:54 <palomer> I want to build large proofs trees in latex
18:51:00 <palomer> we can't all have what we want :/
18:51:27 <RyanT5000> i can make it about 10 pixels tall on a 1600x1200 15.1inch screen, and it's still totally legible (i have pretty good eyes, though)
18:51:59 <int-e> palomer: you mean tool-bar-mode? (yuck)
18:52:32 <palomer> yeah, that stuff
18:52:50 <Cale> is sourceforge.net down?
18:53:20 <RyanT5000> i can't ping it
18:55:10 <RyanT5000> .... "Emacs MultiMedia System"
18:55:12 <RyanT5000> why does that exist
18:55:36 <RyanT5000> Frankenstein's monster was probably a better idea
18:57:05 <Cale> someone needs to write a separate interpreter for elisp, so that all the elisp people will maybe start writing separate programs rather than adding everything to emacs :)
18:57:38 <RyanT5000> separate interpreter.... i can see it now: emacs > /dev/nul
18:58:27 <RyanT5000> (setq stdin stderr)
18:58:42 * RyanT5000 has just exceeded his knowledge of lisp
18:58:44 <int-e> emacs --execute ...
18:58:59 <RyanT5000> int-e, i take it that's the actual thing?
18:59:06 <int-e> sure.
18:59:11 <RyanT5000> figured :P
18:59:31 <RyanT5000> ooooh.... Kate looks nice
19:02:11 <Cale> RyanT5000: you might also try cream, which is a bunch of settings for gvim to make it act a bit more ordinary. (no modes, plenty of menus)
19:02:25 <RyanT5000> hm
19:02:33 <RyanT5000> k
19:02:50 <RyanT5000> i have to say, Visual Studio is still the only microsoft product i truly like
19:04:23 <RyanT5000> everything else is seriously bad in at least some ways; the biggest thing i can say about VS is that it's not transparent enough, so it locks you in
19:04:40 <RyanT5000> (and it's windows-only)
19:04:47 <RyanT5000> (windows-mostly?)
19:05:48 <Cale> also, when I used it, it had a somewhat ugly MDI interface, and lots of sidebars and such eating up screen realestate.
19:06:28 <RyanT5000> as of version ".NET 2002", all that crap can be set to auto-hide
19:06:52 <Cale> yeah, the last version I used was 6, I think.
19:06:57 <RyanT5000> although at 1600x1200 i quite comfortably fit two side-by-side panes and a single sidebar, with one bar on the bottom
19:07:10 <RyanT5000> yeah, 6 is the last "really ugly" version
19:08:19 <liyang> (Whatever was wrong with fitting two xterms side-by-side?)
19:09:00 <RyanT5000> nothing, but i have yet to find a linux editor / system of editors that is slicker than visual studio
19:09:11 <liyang> (or in fact, anything else that you might need in a loosely-coupled development environment?)
19:09:25 <liyang> Slicker? What does that mean?
19:09:39 <RyanT5000> i mean the UI is more coherent
19:09:46 <liyang> Looks good according to the marketroids?
19:09:57 <liyang> Is it actually usable?
19:09:58 <RyanT5000> looks good according to me staring at it for 14 hours at a time
19:10:03 <RyanT5000> yeah, it's quite usable
19:10:04 <Cale> RyanT5000: there's eclipse, which is a big clunky IDE like that
19:10:12 <RyanT5000> i hate eclipse
19:10:25 <Cale> myself, I mostly use vim
19:10:30 <Cale> and sometimes emacs
19:10:33 <gzl> it's really clunky, but it has some nice features I haven't found in too many other places.
19:10:38 <gzl> Eclipse, I mean.
19:10:49 <Cale> when I use emacs, I use it in gui mode
19:11:01 <RyanT5000> i'm gonna take a stab at learning emacs
19:11:02 <Cale> when I use vim, I usually use it from a terminal
19:11:22 <gzl> emacs in viper mode is a nice mix, actually
19:11:34 <RyanT5000> to me the windows selection and cursor semantics are nicer
19:11:39 <RyanT5000> that might just be because it's what i'm used to
19:11:52 <RyanT5000> but i constantly use selections for things *other* than copying and pasting
19:12:00 <RyanT5000> e.g.: replacing the text under them
19:12:14 <Cale> The vi/vim keys are really nice for making structured edits, once you're used to them.
19:12:28 <liyang> RyanT5000: Most `linux editors' are `My First Major Coding Project's, to give my brutally honest opinion.
19:12:44 <RyanT5000> that would explain the huge number of them :)
19:13:22 <RyanT5000> what i really want is visual haskell to work :P
19:13:25 <liyang> As opposed to the simplicity of um... up down left and right of VS. ;)
19:14:04 <Cale> liyang: those keys work in vim too -- I usually don't use hjkl for movement.
19:14:25 <Cale> (what kind of a vim user am I anyway?)
19:14:33 <liyang> Cale: I meant conceptually. :)
19:14:46 * liyang uses the arrow keys. >_>
19:14:50 <Cale> I *really* like '.'
19:15:00 <dbremner> liyang - it's a rite of passage, just like writing an IRC client.
19:15:11 <Cale> being able to repeat the last edit you made in another place is rather handy
19:15:43 <liyang> dbremner: or a `racing' game in QBasic where you controlled a dot which whizzed around the screen... oh wait that was just me and my friends.
19:15:56 <RyanT5000> wow, the splash screen art for emacs is bad
19:16:13 <RyanT5000> red... um... bull?... on Blue
19:16:34 <Cale> I really liked TextPad's semantics for movement though
19:16:35 <liyang> You'll notice the toolbar for Emacs looks frankly atrocious too.
19:16:40 <RyanT5000> you know what, i'm going to shut up now, because i'm starting to sound like all the art people who always piss me off
19:16:49 <RyanT5000> Cale: i like it *sometimes*
19:17:01 <liyang> RyanT5000: too late. ;)
19:17:11 <RyanT5000> but in general normal microsoft is better i think
19:17:19 <RyanT5000> liyang,  i know
19:17:20 <RyanT5000> :P
19:17:23 <Cale> If you did some editing on one line without touching the arrow keys and then pressed up or down, it would move to the column at which you started typing in the other line
19:17:46 <RyanT5000> yeah, but i found that's only usually better for copy-and-paste coding
19:17:46 <Cale> which is very nice when quickly indenting things, or editing tabular data
19:18:24 <Cale> well, it's also usually what you want otherwise too
19:18:28 <liyang> Um, V{motion}> to indent in Vim.
19:19:12 <liyang> Replace {motion} with any sort of cursor movement.
19:19:20 <Cale> V is visual-line selection mode
19:20:04 <Cale> you could use > and < with some stuff selected though
19:22:13 <liyang> Well you usually indent whole lines. :)
19:27:04 <RyanT5000> woah, was there a huge release of Xorg today?
19:27:12 <RyanT5000> 68 updates through apt-get
19:30:06 <monochrom> yeah!
19:31:48 <dbremner> liyang - you and Bill Gates. http://en.wikipedia.org/wiki/DONKEY.BAS
19:34:28 <liyang> (minor point: the logo for Emacs isn't a red bull, even if a disproportionate number of Emacs users enjoy aforementioned beverage. It is in fact, a wildebeest.)
19:34:42 <RyanT5000> i see
19:36:43 <monochrom> Heh, Donkey .NET
19:37:02 <liyang> dbremner: we had steering and acceleration. But the graphics were much less impressive, with the vehicles being literally, a dot. (and collision detection involved reading off the colour of the pixels on the screen.)
19:38:21 <liyang> The days of mode 13... 
19:38:32 <RyanT5000> lol i remember that
19:38:38 <RyanT5000> qbasic was my first language :)
19:38:44 <RyanT5000> as i'm sure is the case with many other people
19:38:56 <liyang> Sadly.
19:39:13 <liyang> Nowadays though, we get lots of kids whose first language is Haskell.
19:39:23 <monochrom> line-numbered basic was my first language.
19:40:02 <monochrom> imagine, no parameter, no local variable, no compound statement, no record
19:40:15 <liyang> no gosub?
19:40:36 <monochrom> gosub is unusable if the only variables are global variables.
19:42:20 <liyang> (Pfft. Why back in my day we only had a hand-operated mechanical Turing machine with only two different pebbles! And we were glad for it!)
19:42:25 <mux> same here, I started with Locomotive Basic 1.0 on an Amstrad CPC 464 :)
19:43:44 <monochrom> liyang: I think you would also be glad with a slide rule.  Using Gödel numbering on it you can still do Turing-complete stuff.
19:43:50 <mux> aaaah, the good old days
19:44:31 <liyang> monochrom: my father had that.
19:51:01 <RyanT5000> you know what's crazy is the mechanical integrators they had around the eniac days
20:03:21 <RyanT5000> what's the relationship between xorg and xfree86?
20:03:28 <RyanT5000> are they completely separate entities?
20:13:03 <mwc> Anybody noticed GHC instability on Darwin/PPC?
20:13:21 <mwc> Had it crash during longish compiles (Darcs, Happy)
20:13:27 <mwc> Only since 6.4.2
21:05:09 <RyanT5000> what's the top progress bar below the user list in X-Chat?
21:06:03 <monochrom> lag meter
21:06:08 <RyanT5000> ah ok
21:11:18 <Cale> the one below that is the amount of text left to send
21:13:26 <RyanT5000> ah ok, thanks
21:16:45 <Cale> you asked before the relationship between x.org and xfree86?
21:17:03 <Cale> XFree86 has been around forever, and X.org is a newer fork from it.
21:17:53 <RyanT5000> ok
21:18:13 <Cale> X.org recently got a big popularity boost when the XFree86 license changed so as to include some terms which were irritating for distributions.
21:18:17 * palomer hopes that GADTs do _not_ make it into haskell 2
21:18:20 <adu> i'm trying to get XFree86 to work
21:18:25 <Cale> palomer: why?
21:18:44 <adu> irritating?
21:18:49 <palomer> they're _rarely_ ever useful
21:19:06 <palomer> and, inference wise, they're a _huge_ pain
21:19:36 <Cale> I don't mind having some special kinds of types where inference isn't so complete.
21:19:53 <adu> inference?
21:19:55 <Cale> Existentials have the same problems
21:20:00 <palomer> Cale: have you ever found them useful?
21:20:12 <palomer> existentials are _very_ useful
21:20:26 <palomer> furthermore, GADTs make types unreadable
21:20:30 <palomer> they're big enough as they are
21:20:47 <Cale> I haven't really tried doing so much with GADTs
21:20:50 <Cale> big?
21:21:03 <palomer> you saw the type which took up a whole screen
21:21:19 <palomer> the types of my function often fill three quarters of the width of my screen
21:21:20 <Cale> because of all the class contexts?
21:21:32 <palomer> s/function/functions
21:21:40 <Cale> Those weren't properly written types
21:21:50 <Cale> most of the class constraints could be dropped
21:22:34 <palomer> nonetheless, my types are usually rather large
21:22:49 <palomer> storing constraints in them would make them even larger
21:22:59 <Cale> Do you really think it's due to GADTs?
21:23:00 <palomer> the only way I would be for GADTs is if they could be dropped
21:23:10 <palomer> ie, if you could omit the GADTed variables
21:23:19 <Cale> what?
21:23:35 <palomer> take, for example, the second example of the GADT section of the wiki
21:23:40 <palomer> a list is either empty or non empty
21:23:52 <palomer> so you'd have List a Empty or List a NonEmpty
21:24:11 <palomer> the second argument to List is GADTful
21:24:16 <Cale> url?
21:24:44 <palomer> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype
21:26:03 <Cale> okay
21:26:27 <palomer> so, I'd be for erasing the GADT variables
21:26:40 <Cale> hmm
21:26:50 <palomer> so a List a Empty would also be a List a
21:26:58 <Cale> that doesn't seem so safe
21:27:15 <palomer> you'd have to explicitly state when your functions need to use the GADT variables
21:27:31 <Cale> what's wrong with including them?
21:27:31 <palomer> this way, you could write the parse function of the first example
21:27:47 <palomer> Cale: sometimes you want to ignore them
21:28:15 <palomer> or the silly function of the second example
21:28:23 <palomer> which would return a List Int
21:28:24 <Cale> as the "silly" example shows, it's not safe to ignore them
21:29:01 <palomer> get this:
21:29:05 <palomer> for the first example
21:29:09 <palomer> you write your evaluator
21:29:15 <palomer> then you annotate the function with a GADTful type
21:29:22 <palomer> so the type checker checks that it's correct
21:29:32 <palomer> then you want to parse something and evaluate it
21:29:35 <palomer> right now, you can't
21:29:47 <sjanssen> palomer: what if your parser constructs an incorrect structure?
21:30:04 <palomer> sjanssen: we'd have no way of checking for that anyways
21:30:16 <Cale> what type would the parser really have?
21:30:30 <palomer> I would suggest the parser have the type String -> Term
21:30:43 <Cale> but what does that actually mean?
21:30:46 <palomer> then we would remove the GADTful signature to the eval function, and it would become a function Term -> Term
21:31:03 <Cale> I think you'd end up with problems with kinds
21:31:17 <palomer> haskell could operate in two modes
21:31:20 <sjanssen> palomer: then why not just use normal data types, seems like you've lost all of the interesting properties of GADTs
21:31:26 <palomer> in one mode, it would _simply ignore all GADTful variables_
21:31:37 <palomer> sjanssen: that's the thing, you'd have to copy your code
21:31:51 <Cale> palomer: if parse doesn't generate a proper type for the structure, then eval won't know what to do
21:32:00 <palomer> if you want correctness of your evaluator AND to be able to parse, you need to write two different datatypes and copy the eval function
21:32:34 <Cale> types aren't just sugar coating, they also direct the execution of the program
21:32:49 <palomer> oh, right, because of datatypes
21:32:58 <palomer> well, you wouldn't allow GADTful variables in typeclasses
21:33:14 <palomer> Term would have kind *
21:33:23 <Cale> When you throw away the parameter type, you'll lose the ability to apply your evaluator.
21:33:24 <palomer> err, because of typeclasses
21:33:43 <Cale> eval :: Term a -> a
21:33:43 <palomer> if it wasn't for typeclasses, evaluation would be independent of typing
21:33:50 <Cale> not even typeclasses here
21:34:10 <Cale> what's the type of eval . parse ?
21:34:18 <palomer> that eval wouldn't be able to run
21:34:28 <Cale> right, so you don't gain anything
21:34:40 <sjanssen> palomer: in your model, can we go from non-GADT world to GADT world?
21:34:43 <Cale> you're up against the same problem you just had
21:34:44 <palomer> but my eval would
21:34:52 <palomer> notice that my eval is Term a -> Term a
21:34:54 <Cale> eval :: Term a -> a
21:34:58 <palomer> which becomes Term -> Term
21:35:06 <palomer> Cale: not on the wiki page
21:35:09 <Cale> sure
21:35:14 <palomer> sjanssen: nope
21:35:22 <Cale> but let's say it's actually supposed to be useful :)
21:35:26 <palomer> eval x = x
21:35:32 <Cale> you're going to have to extract a value at some point
21:35:34 <palomer> eval :: Term a -> a isn't useful
21:35:38 <Cale> and now you can't
21:35:51 <Cale> because you've thrown away the type of your value
21:36:03 <palomer> even if you don't
21:36:06 <Cale> basically, your "Term" is "Term (exists a. a)"
21:36:07 <palomer> eval can never be useful
21:36:16 <Cale> what?
21:36:20 <Cale> sure it can
21:36:21 <palomer> what can you use it for?
21:36:37 <Cale> actually running the program you've constructed in your metalanguage
21:36:53 <palomer> noone runs programs written in the metalanguage!
21:37:01 <Cale> what?
21:37:12 <palomer> err, evaluates terms written in the meta language
21:37:13 <palomer> rather
21:37:23 <Cale> what do they do? Stare at them in admiration?
21:37:36 <sjanssen> perhaps it's just me, but I've never metalanguage I can't run ;-)
21:37:37 <palomer> would you ever write an eval :: Term a -> a?
21:37:42 <Cale> yes
21:37:50 <palomer> why in the blazes would you do such a thing?
21:37:56 <Cale> that would be my sole goal in designing the metalanguage in the first place
21:38:09 <palomer> explain me a use
21:38:19 <Cale> Constructing EDSLs.
21:38:23 <palomer> EDSLs?
21:38:40 <Cale> You can construct any language you like, embedded in Haskell, with an evaluator.
21:38:51 <Cale> What do you think you're doing every time you use a monad?
21:39:05 <Cale> You're running code which is written in an EDSL, embedded in Haskell.
21:39:47 <Cale> Like, Parsec for example, is an EDSL for parsing.
21:40:43 <palomer> right
21:40:47 <palomer> _but that specific eval_
21:40:53 <Cale> hm?
21:41:00 <Cale> what specific eval?
21:41:02 <palomer> the eval on the haskell' wiki
21:41:12 <palomer> http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs
21:41:17 <palomer> or the one in the ghc manual
21:41:28 <Cale> okay, that's a poor example, the GHC manual one is better
21:41:40 <Cale> but still, these are toy examples
21:41:42 <palomer> but it isn't useful for anything!
21:41:51 <Cale> right
21:42:04 <Cale> that's because it's the Hello World of GADT programs :)
21:42:33 <palomer> I've yet to meet a gadt program where the types could not have been erased
21:42:41 <palomer> and I've met my share
21:42:47 <Cale> palomer: you gave me an example of one earlier
21:42:52 <Cale> a month or two ago
21:42:53 <palomer> a useful one
21:42:59 <palomer> what was it?
21:43:09 <Cale> it was out of a paper
21:43:44 <Cale> but even the one in the ghc manual, erasing the type parameter will totally mess things up
21:43:54 <edwinb> How can you erase the types from that eval and still have a type correct program?
21:44:21 <palomer> but the one in the ghc paper is totally useless!
21:44:23 <sjanssen> could one use existentials to write a parser that could later be eval'ed?
21:44:53 <dons> sjanssen: array fusion versions of map and filter in fps now :)
21:45:08 <Cale> palomer: it's the start of something useful
21:45:09 <palomer> s/paper/manual
21:45:14 <sjanssen> dons: I saw that, pretty neat stuff
21:45:16 <dons> so any pipelines of map and filter will deforest all intermediate arrays
21:45:33 <dons> got fold going now. so all the folds should work too soon.
21:46:07 <Cale> palomer: of course it's a toy, but you can't see how a larger version of that could be a useful expression language?
21:46:29 <Saulzar> RyanT5000, Hi - saw you were messing with hsSDL windows earlier, I don't suppose you know how to make it run the main properly? I made it build by removing the defines, edited SDL_main and pointed it at main - but it does nothing when it runs.
21:46:37 <palomer> Cale: not in a way which would make erasure impossible
21:46:47 <Cale> it's already impossible
21:46:54 <Cale> eval :: Term a -> a
21:47:01 <palomer> so no, I don't see how that could ever be useful
21:47:11 <Cale> erase the 'a' from 'Term a' and what is eval supposed to return?
21:47:19 <edwinb> what has erasure got to do with it anyway?
21:47:38 <Cale> We're actually talking about a specific kind of erasure here
21:47:45 <palomer> right, I hold the view that that eval can't be made int oanything useful
21:47:51 <edwinb> the whole point is that you can give types to more programs, so of course if you erase the parameter it isn't well typed...
21:47:58 <Cale> palomer: it already is usful
21:48:01 <Cale> useful*
21:48:12 <Cale> it evaluates the expression and returns a Haskell value
21:48:17 <Cale> what more could you want?
21:48:18 <palomer> you'd actually use that code?
21:48:19 <RyanT5000> Saulzar, just use the normal main from haskell
21:48:33 <palomer> the point of GADTs in haskell, from what I've seen, is to enforce invariants
21:48:36 <palomer> and not to type more programs
21:48:57 <edwinb> the eval example does both...
21:49:00 <palomer> anyways, you could write a function SomeClass a => Term a -> a if you wanted to
21:49:01 <Saulzar> RyanT5000, That's what I've been doing - but then it doesn't seem to run the haskell main at all...
21:49:06 <Cale> Here it is enforcing invariants, in order to type a program which would be impossible to do so otherwise.
21:49:10 <edwinb> it's well-typed (that's an invariant) and is a tagless evaluator
21:49:13 <RyanT5000> Saulzar, are you linking with SDL_main?
21:49:14 <palomer> you could enforce your invariants with typeclasses in this case
21:49:15 <RyanT5000> you shouldn't be
21:49:28 <RyanT5000> however i'm not sure how that wouldn't give you a linker error
21:49:35 <palomer> in fact, it would be _much_ more useful to do it with typeclasses
21:49:37 <Saulzar> Ah ok. I need to remove that somehow... 
21:49:38 <RyanT5000> also, try putting in a putStrLn
21:49:44 <edwinb> You are welcome to do things the hard way if you wish...
21:50:03 <palomer> Cale: right, I was responding to edwinb 
21:50:07 <Saulzar> I edited SDL_main instead, how do I get rid of it? 
21:50:22 <palomer> Cale: do you have code which you would actually write for which the GADT slots are not eraseable?
21:50:35 <RyanT5000> Saulzar, first of all, what's your build setup like?
21:50:40 <Cale> palomer: have you seen the Regexps example?
21:50:44 <palomer> nope
21:50:46 <RyanT5000> what OS are you on?
21:50:47 <Saulzar> Just a bunch of hs files and --make
21:51:02 <Saulzar> Windows XP, with mingw
21:51:07 <palomer> #define SDL_main main <--this is needed under windows
21:51:43 <Saulzar> I just physically replaced SDL_main with main
21:52:00 <palomer> edwinb: the eval function does both, but it's not code you'd find anywhere
21:52:08 <edwinb> why not?
21:52:09 <palomer> Saulzar: that won't do
21:52:18 <edwinb> I mean, why shouldn't it be?
21:52:35 <palomer> because it's useless?
21:52:45 <edwinb> It's a toy example, of course it's useless!
21:53:03 <palomer> gah
21:53:05 <palomer> anyways
21:53:07 <edwinb> It still demonstrates that it's possible to write a tagless interpreter (of some form) in Haskell
21:53:21 <RyanT5000> Saulzar, my solution: rename SDL_main.h to SDL_main.stupid.h, and make a new SDL_main.h containing "#include "SDL_main.stupid.h"\n#undef main"
21:53:26 <palomer> I hold the view that either you have to be able to erase the GADT slots, or you have to introduce existentials in your type system
21:53:28 <RyanT5000> that seemed to work pretty thoroughly
21:53:31 <palomer> or else GADTs are largely useless
21:54:00 <edwinb> If you want to write a real interpreter that way, you would probably also need some way of coding the types.
21:54:20 <edwinb> But if you want a well-typed language you'd have to do that anyway.
21:54:25 <palomer> you can't write a real interpreter that way
21:54:27 <Saulzar> RyanT5000, Ah, I removed the #define, and also got rid of the -Dmain=SDL_main  - it all built ok
21:54:29 <edwinb> So it's hardly a stand alone example
21:54:30 <palomer> this is what started this discussion
21:54:40 <RyanT5000> Saulzar, cool
21:54:49 <RyanT5000> Saulzar, i assume you're on windows?
21:55:03 <edwinb> Why can't you?
21:55:12 <Cale> palomer: the point isn't to allow for an interpreter which would read a string, and produce a value of that type to be evaluated
21:55:16 <Saulzar> Yeah, I'm trying to get my little thingey working on windows
21:55:17 <palomer> you won't be able to parse your terms
21:55:31 <edwinb> why not? you also need to write a typechecker...
21:55:31 <RyanT5000> Saulzar, let me know if you make it work without crashing on exit
21:55:32 <Cale> palomer: it's to allow you to write code which generates a GADT
21:55:40 <Cale> and then have an evaluator
21:55:41 <edwinb> Hang on, I have some code which does this somewhere...
21:55:49 <Saulzar> RyanT5000, It doesn't crash on exit - it doesn't call my main at all :)
21:55:52 <Cale> a value typed in a GADT
21:55:58 <RyanT5000> i mean, actually using SDL :)
21:56:13 <palomer> hrmph
21:56:21 <RyanT5000> @palomer
21:56:21 <lambdabot> They're telling you lies!
21:56:26 <sjanssen> @palomer!
21:56:26 <lambdabot> They're telling you lies!
21:56:34 <RyanT5000> @palomer?
21:56:35 <lambdabot> Hrmph, looks like I killed the channel
21:56:41 <palomer> as someone who's studied GADTs, I've never found a use for them. I think this says something
21:57:03 <sjanssen> @yhjulwwiefzojcbxybbruweejw
21:57:04 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:57:08 <palomer> a real use, as in "I have this problem to solve, let's find the best way to solve it"
21:57:14 <palomer> sjanssen: hehe
21:57:45 <palomer> @v
21:57:46 <lambdabot> Just 'J'
21:57:49 <edwinb> http://www.dcs.st-and.ac.uk/~eb/Eval.lhs
21:57:55 <palomer> @u
21:57:55 <lambdabot> Maybe you meant: unlambda uptime url . v
21:58:05 <edwinb> okay, that's a toy too
21:58:17 <palomer> edwinb: where's the parsing?
21:58:34 <edwinb> if you can't write a parser for Raw, you are struggling...
21:58:52 <palomer> how many real haskell projects could make use of gadts? one? two?
21:58:55 <edwinb> I am assuming you can do that without much difficulty. Raw is untyped.
21:59:29 <palomer> how does this even work?
21:59:36 <palomer> oh, you have an existential
21:59:39 <Cale> palomer: how many could make use of monads?
21:59:58 <palomer> I don't see GADTs becoming widespread
22:00:02 <Cale> The point is that we haven't had time to fully explore the potential for programming with gadts
22:00:05 <palomer> they're more pain then they're worth
22:00:12 <Cale> why do you think that?
22:00:22 <RyanT5000> can someone give a simple, quick definition of GADT?
22:00:37 <Cale> http://www.haskell.org/ghc/docs/6.4/html/users_guide/gadt.html
22:00:38 <RyanT5000> it stands for generic algebraic datatype, right?
22:00:47 <palomer> because they've caused me pain and haven't shown their worth
22:00:47 <Cale> generalised algebraic datatype
22:00:49 <RyanT5000> ah
22:01:17 <edwinb> To be honest, I've never written a real GADT program, mainly because I run into limitations too soon and want full dependent types...
22:01:36 <edwinb> I'd still quite like to see an implementation of simply typed lambda calculus with GADTs...
22:01:46 <edwinb> preferably a nice neat comprehensible one
22:03:02 * palomer _despises_ dependent types
22:03:11 <edwinb> why?
22:05:31 <palomer> they're awkward
22:05:32 <RyanT5000> why not just have Type be a type
22:05:45 <RyanT5000> let people write regular haskell functions that return them
22:05:51 <palomer> edwinb: the problem with your run function is that it returns a exists a . Maybe a
22:05:57 <palomer> edwinb: which is totally useless
22:06:08 <edwinb> Um
22:06:25 <edwinb> you realise run also does type checkign?
22:06:28 <edwinb> which is quite useful
22:06:36 <palomer> no, wait, it returns a Maybe Int
22:06:47 <palomer> your evaluator is a toy
22:06:50 <palomer> I want real code!
22:06:56 <edwinb> I know it's a toy, I said as much.
22:06:59 * edwinb sighs
22:07:06 <palomer> no, but it's a toy in every sense of the term
22:07:27 <sjanssen> palomer: I don't see why edwinb's approach can't scale to a larger interpreter
22:07:39 <edwinb> I do ;)
22:07:41 <palomer> actually, it's not a bad example
22:07:54 <edwinb> I'd like to see how it coped with environments
22:08:13 <palomer> I'm surprised the type isn't exists a. Raw -> Maybe a
22:08:37 <edwinb> It could be Raw -> Type a -> Maybe a
22:09:26 <edwinb> Doesn't pugs use GADTs to good effect anyway? That's not a toy...
22:09:39 <palomer> but eval returns an a
22:10:12 <edwinb> yes, the same a that the typechecker confirms it will be
22:10:28 <palomer> how are you matching it against a Checked?
22:10:45 <edwinb> look at the definition of Checked
22:10:54 <edwinb> an Expr a lives with a Type a
22:11:19 <palomer> I don't see it in the definition of Expr
22:11:46 <edwinb> that's because it isn't
22:12:16 <palomer> so an Expr lives alone
22:12:31 <edwinb> 'Checked' is the important thing
22:12:36 <palomer> oh, nevermind
22:12:55 <palomer> yes, I see how it works
22:13:02 <palomer> ok, this is the start to something
22:13:20 <palomer> you win.
22:13:26 <palomer> hullo ski!
22:13:29 <edwinb> yay ;)
22:13:47 <edwinb> Still. If anyone's done a well-typed simply typed lambda calculus with GADTs, I'd like to see it...
22:15:52 <palomer> erm, who are the SoCs experts here?
22:16:06 <palomer> edwinb: that's exactly what I've done, actually
22:16:27 <sethk> Cale, remember the function we were talking about a couple of days ago, where I was looking for a way to avoid annotating a variable?  You said an existential type might help.  I was wondering; is this the type of situation that can be handled using TH?
22:16:43 <sethk> or, of course, anyone else who might like to comment.
22:18:16 <palomer> edwinb: are you working on this subject too?
22:19:14 <edwinb> Sort of. Slightly.
22:19:45 <edwinb> I'm working on resource bounded programming using dependent types
22:20:13 <edwinb> but what I'm trying to do is write a resource safe interpreter.
22:30:10 <palomer> sounds like you're at CMU
22:30:13 <palomer> am I correct?
22:30:28 <palomer> ahh, no uk
22:30:29 <palomer> nevermind
22:37:55 <araujo> Hello!
22:41:38 <hoan> hiii
22:45:44 <palomer> brump!
22:46:30 <palomer> ok, someone add that to palomer
22:46:34 <palomer> to @palomer
22:47:58 <dons> oh, that's a yummy one.
22:48:03 <dons> hi hoan,
22:48:05 <dons> how's code?
22:48:30 <Korollary> Holy crap. There are a lot of complexity classes: http://qwiki.caltech.edu/wiki/Complexity_Zoo
22:52:29 <palomer> all of them as useless as the others
22:53:47 <Korollary> @palomer
22:53:47 <lambdabot> Blargh!
22:55:11 <sjanssen> dons: is defining find in terms of filter part of your fusion plans?
22:55:40 <sjanssen> otherwise, building an entire string just to get one element from it seems silly
23:00:07 <dons> ah, good idea.
23:01:35 <dons> we could try both ways and see how it goes.
23:01:47 <dons> if the fusable version is not too much worse, then we can use it.
23:06:03 <shapr> palomer: Doesn't that mean they're all useful?
23:11:52 <vincenz> moin
23:14:16 <Saulzar> Blargh. Can't seem to get anything linked with SDL/Windows to call main ... main is #undef'ed, SDL_main is #defined as main. Just does nothing at all, program immediately exists.
23:16:43 <ADEpt> morning
23:21:12 <menki> anyone on who knows how to write a function to take single keypresses from the windows console?
23:24:30 <sjanssen> @hoogle hSetBuffering
23:24:30 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
23:24:57 <menki> hSetBuffering NoBuffering doesnt seem to work for windows
23:25:25 <sjanssen> oh?  I've got nothing then
23:43:47 <dons> ?uptime
23:43:47 <lambdabot> uptime: 2 days, 2 hours, 13 minutes and 4 seconds
