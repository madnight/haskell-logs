01:02:33 <Cale> > id
01:02:34 <lambdabot> Add a type signature
01:02:39 <Cale> > id :: Int -> Int
01:02:39 <lambdabot> <Int -> Int>
01:02:43 <Cale> interesting :)
01:04:11 <Cale> > id :: a -> a
01:04:11 <lambdabot> Add a type signature
01:04:28 <Cale> heh, another one
01:08:55 <xerox> @yow!
01:08:56 <lambdabot> Has everybody got HALVAH spread all over their ANKLES?? ...  Now, it's
01:08:56 <lambdabot> time to "HAVE A NAGEELA"!!
01:13:29 <olliej> wtf?
01:19:58 <Cale> @yow
01:19:58 <lambdabot> Look!  A ladder!  Maybe it leads to heaven, or a sandwich!
01:20:05 <Cale> @yow
01:20:05 <lambdabot> A shapely CATHOLIC SCHOOLGIRL is FIDGETING inside my costume..
01:20:16 <dons> oh my.
01:25:58 <shapr> @yow !
01:25:59 <lambdabot> Place me on a BUFFER counter while you BELITTLE several BELLHOPS in the
01:25:59 <lambdabot> Trianon Room!!  Let me one of your SUBSIDIARIES!
01:26:12 * shapr returns from spending time with his gf
01:27:03 <shapr> Wassup?
01:27:07 <shapr> Yikes, 70 mails.
01:28:36 <shapr> Wassup guys?
01:29:57 <Lemmih> I wrote some funny Cont code recently.
01:30:40 <Lemmih> switch' lst = let x = map (\y -> callCC (\exit -> y (map (\z -> z >>= exit) x))) lst in head x
01:30:51 * shapr 's brain melts
01:32:05 <Lemmih> The type is easier to make sense of: (MonadCont m) => [[m b] -> m a] -> m a
01:32:24 <xerox> o_O
01:32:38 <shapr> Oh, that is easier. I'm often surprised how well a type signature in Haskell stands in for UML or whatnot.
01:32:50 * shapr got half his hair chopped off yesterday.
01:32:55 <Lemmih> dons: Can we have Control.Monad.Cont in lambdabot?
01:33:04 <shapr> Luckily, it was the bottom half.
01:34:58 <xerox> Lemmih: may you explain that?
01:37:46 <xerox> Every monad is pointed!
01:39:35 <shapr> Is it a coroutine-like implementation?
01:40:40 <xerox> The implementation of what?
01:41:15 <shapr> The whole computation is x, lst is the list of things to do(?), exit is the function to call with results, but then x gets called all over again.
01:42:36 <Lemmih> This is why I really like Haskell. There's always a new way it can twist my brain.
01:44:53 <shapr> Lemmih: Did I get any points in the "guess what this callCC code does?" competition?
01:46:07 <Lemmih> shapr: Yeah.
01:47:22 <Lemmih> *Proposal> (`runCont` id) $ switch' [\[p1,p2] -> p2 >> return "p1", \[p1,p2] -> return "p2"]
01:47:25 <Lemmih> "p2"
01:52:42 <xerox> UHM.
01:54:11 <Lemmih> It's from a web-framework proposal for HASP.
01:55:07 <xerox> ah-ha.
01:56:02 <dons> Lemmih: done.
01:56:09 <xerox> Still a bit obscure anyway.  Maybe because the code is dense.
01:56:28 <xerox> Any chance of an explanation? (-:
01:57:16 <Lemmih> > let switch' lst = let x = map (\y -> callCC (\exit -> y (map (\z -> z >>= exit) x))) lst in head x in (`runCont` id) (switch' [\[p1,p2] -> p2 >> return "page1", \[p1,p2] -> return "page2"])
01:57:17 <lambdabot> "page2"
01:58:41 <Lemmih> xerox: Each function in the input list get a list of exit functions for every function in the input list.
01:58:44 <xerox> So it never gets around evaluating return "page1"
01:59:36 <Lemmih> > let switch' lst = let x = map (\y -> callCC (\exit -> y (map (\z -> z >>= exit) x))) lst in head x in (`runCont` id) (switch' [\[p1,p2] -> p2 >> undefined, \[p1,p2] -> return "page2"])
01:59:37 <lambdabot> "page2"
01:59:59 <xerox> I see!  The implementation isn't very clear to me though
02:01:13 <Lemmih> It could probably be done better than a one-liner with 'x', 'y' and 'z' for variable names (:
02:01:21 <xerox> Right :-)
02:01:49 <xerox> How would you call them respectively?
02:03:06 <Lemmih> y->fn, z->result, x->results, perhaps.
02:04:57 <xerox> switch' xs = let results = map (\fn -> callCC (\exit -> fn (map (\result -> result >>= exit) results))) xs in head results
02:05:45 <xerox> Gotcha!
02:06:07 <xerox> You're passing a list of "do it and escape" to each of those functions.
02:06:24 <xerox> Clever.
02:14:09 <shapr> hmm
02:17:47 <xerox> But... are all the functions evaluated?  Does it work like that because of laziness or because `exit' supersedes map?
02:17:49 <shapr> The guy who applied for Language.PHP seems like a strong applicant, but PHP doesn't excite the mentors. Is there a Language.Something that would?
02:20:03 * xerox adds a "Lemmih:" to the previous phrase
02:59:30 <araujo> good morning!
03:11:09 <Lemmih> xerox: Because of laziness.
03:11:51 <xerox> Lemmih: so the exit doesn't stop the map in any way, okay!
03:12:01 <xerox> Well, kinda okay.....
03:12:09 <xerox> Ah no, okay, okay, head x.
03:12:38 <xerox> Does that mean that callCC seqs?
03:13:21 <Lemmih> seqs?
03:13:32 <xerox> "Does use seq"
03:14:27 <Lemmih> No, it's just monadic.
03:14:52 <Lemmih> @type Control.Monad.Cont.callCC
03:14:53 <lambdabot> forall (m :: * -> *) a b.
03:14:54 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
03:14:54 <lambdabot>           ((a -> m b) -> m a) -> m a
03:15:27 <xerox> So the list of function is still evaluated in order?
03:15:37 <neologism> anyone with a clue about graph theory?
03:16:10 <xerox> neologism: a very little one, but ask, others do I think (-:
03:17:15 <neologism> Bisection width - minimum number of edges crossing approx. equal bipartion of nodes
03:17:18 <neologism> I dont understand this definition
03:17:50 <Lemmih> xerox: There is no order.
03:18:09 <xerox> > let switch' lst = let x = map (\y -> callCC (\exit -> y (map (\z -> z >>= exit) x))) lst in head x in (`runCont` id) (switch' [\[p1,p2,p3] -> return "page1", \[p1,p2,p3] -> return "page2", \[p1,p2,p3] -> p2 >> undefined])
03:18:10 <lambdabot> "page1"
03:18:33 <skew> xerox: it's the "head" that makes it start at the first one
03:18:40 <xerox> Right, evaluation order is undefined...
03:18:45 <Lemmih> > let switch' lst = let x = map (\y -> callCC (\exit -> y (map (\z -> z >>= exit) x))) lst in head x in (`runCont` id) (switch' [\[p1,p2] -> return "page1", undefined])
03:18:46 <lambdabot> "page1"
03:18:48 <xerox> skew: wee, that's right.
03:19:08 <xerox> So you have the entry point of your web application as the first element of the list
03:19:32 <xerox> But if you just return the page, you've lost the context, right?
03:19:39 <Lemmih> switch def pages = switch' (def:pages)
03:19:59 <skew> still looks a bit funny. I guess you would put some sugar around it with TH?
03:20:30 <Lemmih> skew: switch'?
03:21:25 <skew> yeah, I don't like repeating the bindings in each branch
03:21:36 <xerox> Does switch have to return a page?
03:22:08 <skew> xerox: you saw the type - [[m b] -> m a] -> m a
03:22:33 <skew> that should really be something more like [[forall b. m b] -> m a] -> m a
03:22:36 <xerox> I wonder how `switch' is plugged in
03:22:44 <xerox> ...the framework
03:22:55 <skew> who lives down the hall from Daan?
03:23:15 <xerox> That is, do those actions just build static pages, or you can do more interesting things?
03:23:46 <skew> I assume you could use ContT IO as your MonadCont, if you wanted to
03:24:30 <skew> I was reading this paper about composing monads with coproducts recently - apparently Cont is pretty ill-behaved
03:26:43 <shapr> Does gij-4.1 count as java 1.4 or later?
03:33:43 <xerox> skew: I am reading it now!
03:33:59 <xerox> Still it doesn't look practical to have to use inr and inl everywhere.
03:39:20 <xerox> (Or doesn't one?  If so, it would be cool...)
03:41:18 <skew> you could probably get the injections with typeclasses
03:41:44 <skew> then it would just be some "inj", no worse than putting "lift" everywhere
03:42:05 <xerox> Yes...
03:42:13 <skew> you couldn't put in several layers of the same type that way, though
03:42:39 <xerox> Hm.  Why?
03:43:39 <skew> just like the classes in Control.Monad.* only get the outermost application of a transformer
03:44:48 <xerox> ReaderT (ReaderT IO a) b ... ?
03:45:04 <azuroth> test cases are awesome. I just wish they were already written for me.
03:45:44 <xerox> skew: do you mean that (lift ask) there does take the b, and there is no way to get the a?
03:46:19 <skew> you could do something like that
03:46:29 <skew> but I mean how just "ask" gets the outermost layer
03:46:53 <skew> and if you want to do "lift" you have to know exactly how many layers you are looking to lift
03:47:08 <xerox> Right, and that seem to be the same with coproduct?
03:47:20 <skew> actually, if a and b are different types, you might have separate instances
03:47:38 <skew> oh, | m -> r
03:47:58 <xerox> Ah!
03:48:31 <xerox> You'd want some RULES to do t (t m a) a -> t m (a,a) ?
03:49:07 <skew> but, for simplifying the injections you could leave out the functional dependency, so you could use ask at m a or at m b, if you monad has a Reader a and a Reader b in it
03:49:59 <xerox> Hm.  That sounds *nice* but I don't know if it is exactly possible...
03:50:50 <skew> it possible, it's a trade off where you need to provide other information to fix the type of ask, rather than letting the fundep do it
03:51:01 <xerox> Then I do like it.
03:51:19 <skew> it's a bit of trouble if you have two copies of Reader a mixed in, though
03:53:00 <skew> I think a good solution for that is to have one lift per transformer class, rather than a single lift
03:53:10 <skew> a "liftUnderTopmostReader"
03:55:42 <skew> that "pomega" symbol looks like tengwar to me
03:56:35 <skew> If anyone is working on a paper, tengwar variables would be a nice change of pace from greek.
03:57:26 <skew> you could use the structural variations for different kinds of variables - bottom stem for terms and top stem for types, or so
04:01:12 <skew> xerox: if you are getting that paper from the LtU thing on compositions interpreters, the "LPS" paper seems to be be best so far
04:01:48 <skew> the most algebraic, at least. I haven't read "Building Compilers by Composing Algebras" yet, though.
04:11:40 <shapr> ##java is truly an unfriendly place.
04:15:24 <azuroth> really? what do they do?
04:15:25 <xerox> Okay!
04:15:30 <jip> i think i read somewhere that there are openal bindings for haskell
04:16:04 <shapr> Yup, Sven Panne made them.
04:16:29 <jip> where are they? :)
04:16:49 <shapr> azuroth: I was deluged by emotional statements deriding open source. Admittedly, they were all from one guy, but it seems to be a trend.
04:17:18 <shapr> Still, with community like that, who needs enemies?
04:17:30 <azuroth> haha
04:18:04 <azuroth> weren't there rumours about them thinking about open sourcing java?
04:18:18 <shapr> When I specified the error I got with GNU Java, the guy wanted to add it the Undernet FAQ entry titled "Why do GNU Java and other OSS Java implementations suck?"
04:18:44 <shapr> My comment <shapr> I think it would be more useful to write something like "Why can't I get the GNU Java and OSS Java implementations to act like Sun's implementations?"
04:18:59 <shapr> got the reply <Clackwell> shapr: why can't the [beep] at debian and co. get a clue and stop [beep] the user in the rear end?
04:19:46 <azuroth> heh, what. what was the error, anyway?
04:20:52 <azuroth> actually, we probably shouldn't talk about this. it'll just get me riled up for no reason :-P
04:20:53 <shapr> ClassNotFoundException, but my frustration potential has been exceeded, I won't continue trying to use this code.
04:21:40 <skew> shapr: when I'm writing Java, it doesn't take compiler errors to exceed my patience.
04:22:13 <azuroth> skew++ :-)
04:22:27 <jip> anyone know if there are haskell bindings to libvorbis?
04:23:08 <skew> Hmm, I've got mail from Daan saying he was going to release Morrow in two weeks, recieved in January
04:26:25 <azuroth> jip: I've no idea, but I hear haskell's FFI is some of the best in the verse
04:26:47 <jip> hm...
04:27:07 <shapr> jip: OpenAL is connected to the HOpenGL binding. See ALUT, OpenAL on http://www.haskell.org/HOpenGL/newAPI/
04:31:36 <jip> cool thanks
04:35:25 <delinka> where can I get a fortune file for lambdabot?
04:40:42 <JKnecht> shapr: I imagine you antagonized the #java denizens but having an encompassing perspective. They reacted defensively.
04:45:10 <delinka> @palomer
04:45:10 <lambdabot> Hrmph
04:45:14 <delinka> @palomer
04:45:14 <lambdabot> Learning vim is pointless
04:47:16 <azuroth> ...real programmers instinctively know all the commands
04:47:41 <delinka> heh
04:54:15 <shapr> JKnecht: I suspect Clackwell is actually an Open Source and Free Software advocate who is sneakily trying to sabotage ##java by being as difficult as possible.
04:55:15 <azuroth> haha. that's a great idea!
05:14:13 <JKnecht> shapr: it's actually the profit motive and wage labor in service of capital isn't it (the issue/dissonance) since much of base Java is effectively free and relatively open? They (java) and MS are the PC and Mac of software.
05:16:42 <Oeje1> I was banned once from #java after I mistakenly took a real person for a bot.
05:19:55 <Lemmih> @remember Oeje1 I was banned once from #java after I mistakenly took a real person for a bot.
05:19:56 <lambdabot> Unknown command, try @list
05:20:19 <Lemmih> @help quote
05:20:20 <lambdabot> quote <nick>
05:20:20 <lambdabot> remember <nick> <quote>
05:20:20 <lambdabot> Quote somebody, a random person, or save a memorable quote
05:20:28 <xerox> There seem to bot be remember anymore...
05:22:34 <shapr> Yeah, I dunno why.
05:22:59 <azuroth> @quote
05:22:59 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
05:22:59 <lambdabot> squad, but he declined.
05:24:29 <vincenz> anyone very familiar with graph theory?
05:25:17 <neologism> vincenz: I asked the same question 2 hours ago :)))
05:25:36 <shapr> Is there a collection of computing analogs? Like, how to create an AND gate in a wooden puzzle, out of water buckets, with lasers, etc?
05:25:59 <xerox> neologism: #math maybe.
05:26:02 <vincenz> neologism: what's your question?
05:26:44 <dons> i turned off remember, there was some bad bug leading to flake outs.
05:26:47 <dons> haven't had time to fix it yet.
05:27:02 <shapr> ah, that explains it.
05:27:02 <vincenz> well I just answered my own question with a counter example
05:28:19 * vincenz 's connection was if you cn always draw a graph in a 2D plane without edges crossing, the counter example is a fully connected 5-node graph
05:28:27 <vincenz> s/connection/question
05:28:48 <BCoppens> vincenz: that's the planarity of a graph
05:29:30 <vincenz> BCoppens: yeah I was curious if all graphs were planar or not
05:30:25 <shapr> I wish wikipedia would give Citeseer references.
05:31:10 <BCoppens> vincenz: actually, some non-planar graphs can be drawn without edges crossing on a doughnut. And even others can't do that
05:32:12 <BCoppens> vincenz: http://en.wikipedia.org/wiki/Genus_(mathematics) -> see the section on Graph theory
05:32:57 <vincenz> thx
05:33:11 <BCoppens> :)
05:33:44 <vincenz> but yeah
05:33:54 <vincenz> I had a hunch that 5 node graph was nonplanar
05:33:56 <vincenz> so I drew it out
05:34:40 <BCoppens> yeah but if you draw it there's always the chance that you just overlook the right embedding ;)
05:36:04 <vincenz> I tried different variations
05:36:10 <psnl> vincenz: clearly not, why do you want to know?
05:36:32 * vincenz blinks
05:36:35 <vincenz> psnl: clearly not what?
05:36:50 <psnl> that all graphs are planar
05:37:09 <vincenz> just curious
05:38:20 <psnl> A fun question is if certain types of graph are always planar
05:38:45 <vincenz> why is planarity such a critical issue?
05:39:05 <Oeje1> It makes for nice drawings. ;-)
05:39:10 <psnl> making chips
05:39:22 <BCoppens> vincenz: well, just imagine for example the circuitry on a chip as a graph. Making it's genus as low as possible = making it less costly
05:39:23 <vincenz> psnl: hah
05:39:27 <vincenz> psnl: no chip is monolayer
05:39:34 <vincenz> chips use at least 12 or so masks
05:39:41 <BCoppens> yeah exactly
05:39:51 <BCoppens> but it's cheaper if you have less crossings ;)
05:40:32 <vincenz> I know, but I would imagine most circuits not to form a problem
05:40:42 <vincenz> circuits don't have high levels of connectivity
05:41:41 <BCoppens> probably, I'm not very into chip design ;)
05:42:30 <shapr> What's the opposite of a parser, maybe emitter? Is there a single word for that sort of 'pretty printer' idea?
05:43:06 <psnl> marshaller?
05:43:12 <shapr> vincenz: Or just use RFSQ and Josephson junctions where they've discovered how to teleport signals with no wire needed :-)
05:43:24 <psnl> thats not quite the same, I know
05:43:49 <vincenz> shapr: got a link?
05:44:34 <shapr> Nah, but it's recent research. I've kept it in mind because it'll solve the factorial wire problem for totally connected components.
05:45:22 <vincenz> I dunno
05:45:25 <vincenz> rf is quite low freq
05:45:46 <shapr> er, sorry RSFQ - rapid single flux quantum
05:46:13 <shapr> I think they had ~300GHz RFSQ components operating in the late 90s.
05:46:15 * vincenz shrugs
05:46:17 <vincenz> I'll ask at work
05:46:20 <vincenz> they should know
05:46:45 <vincenz> but erm
05:46:51 <vincenz> even with signals that are not electric
05:46:53 <vincenz> you need guides
05:47:00 <vincenz> which are essentially 'wires'
05:47:04 <shapr> Not with this.
05:47:05 <vincenz> from an abstract point of view
05:47:19 <vincenz> how do you stop interference of a zillion signals?
05:47:40 <vincenz> how do you ensure all power is being aimed at the target instead a bit everywhere
05:48:01 <shapr> Well, a single quantum is moved around, so I doubt you have to worry about noise.
05:48:17 <vincenz> well you gotta ensure it's aimed at the right place
05:48:31 <vincenz> and noise is typically extraneous
05:48:52 <shapr> I think they can control it perfectly.
05:49:35 * vincenz shrugs
05:49:38 <vincenz> hard to argue without knowledge
05:49:55 <shapr> True that
05:50:20 <shapr> I think it's just quantum tunneling done with josephson junctions.
05:50:23 * shapr scurfles for bookmarks.
05:52:09 <jip> hm... how would i code a makeModify :: (a -> b) -> (b -> a -> a) -> ((b -> b) -> a -> a)
05:52:22 <jip> where the first arg is a "get" function and the second arg is a "set" function
05:52:56 <jip> makeModify is supposed to return a function that takes a modification function and applies it to the result of get and then sets it
05:53:00 <jip> am i making sense?
05:53:01 <vincenz> jip: you need a b->b function
05:53:04 <vincenz> o
05:53:13 <Lemmih> @djinn (a -> b) -> (b -> a -> a) -> ((b -> b) -> a -> a)
05:53:13 <lambdabot> f a b _ c = b (a c) c
05:53:29 <jip> what is djinn?
05:53:38 <Lemmih> @help djinn
05:53:39 <lambdabot> djinn <type>.
05:53:39 <lambdabot> Generates Haskell code from a type.
05:53:39 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:53:46 <jip> hm... cool
05:53:56 <jip> but that doesn't look right, makeModify only takes 2 args
05:54:15 <vincenz> makeModify get set modif state = set ( modify . get $ state) state
05:54:29 <vincenz> jip: no it doesn't
05:54:34 <Lemmih> jip: a -> b -> c === a -> (b -> c).
05:54:38 <vincenz> -> is right associative
05:55:04 <vincenz> the djinn version just doesn't apply the transfo function
05:55:49 <delinka> i'm curious - at what point are experience and courtesy *inversely* proportional?
05:56:24 <vincenz> delinka: why do you ask?
05:56:56 <delinka> because of the discussion earlier about ##java, thought I'd watch awhile
05:57:15 <vincenz> I think courtesy and experience are orthogonal
05:57:58 <delinka> and I figure, because someone claimed to be knowledgeable and at the same time insinuated that allows him to be rude, then at some point in my development as a human, I should become an asshole. I'm just curious when that should happen.
05:58:10 <shapr> Not totally. At some point you reach the level where the advancements a person makes are more valuable than explaining to newbies.
05:58:53 <delinka> so ... stop explaining to newbies? that's not hard. it's even easier than saying "that's a dumb thing to do"
05:58:59 <shapr> Because the people who know more than the newbies but less than the gurus can explain equally well.
05:59:59 <ksandstr> i'd say better, since the gurus will have migrated to a place where things that are obvious will cause the newbies to go "wtf? that can't be right"
06:00:20 <shapr> I don't think there's ever a good excuse to be an asshole.
06:00:30 <delinka> and that's my point
06:01:23 <shapr> Who claimed to be knowledgeable and insinuated that it allowed him to be rude?
06:01:27 * shapr hopes it wasn't him
06:01:38 <Philippa> shapr: often it's not quite true that the non-gurus can explain as well...
06:01:42 <ksandstr> but a newbie with an attitude and a lack of willingness to listen to advice they're given, combined with an impatient expert, generally results in an "i can't believe it's not an asshole" moment
06:01:47 <shapr> Philippa: Yes, I agree.
06:01:52 <Philippa> often the gurus have some neat insights that're what make them gurus
06:02:08 <Philippa> ksandstr: that's different, the newbie's being an arsehole too
06:02:56 <Philippa> I don't see an obligation to be polite to people who're being rude to me
06:04:12 <delinka> shapr: I really don't want to drag the whole thing around in other chatrooms. It certainly wasn't you. If you're in ##java, scrollback over 5-7min should tell you. I was just adding to discussion in here from earlier, observing that it's more than one person with twisted panties over there.
06:04:26 <shapr> delinka: I left ##java actually
06:04:33 <delinka> can't blame you ;-)
06:04:37 <shapr> delinka: Are there public logs?
06:04:47 <ksandstr> Philippa: likewise. but you can see how that could make for a sentiment that the expert was an asshole to newbies
06:04:51 <delinka> dunno, but *I* keep transcripts :-D
06:04:58 <shapr> delinka: btw, standard fortune files worked with the original version of lambdabot's @fortune. I haven't checked to see if that's changed lately.
06:05:11 <delinka> shapr: thanks
06:05:39 <Philippa> ksandstr: sometimes. Usually it's not worked out that way for me, and I've been known to really rip into newbies who were being arseholes themselves
06:05:50 <Philippa> thing is, when they backed down so did I
06:05:53 <delinka> Philippa: far as I could tell, the newbie said something like "I'm doing X with Z" and the replay was "that's moronic"
06:06:02 <delinka> there was no newbie rudeness
06:06:13 <Philippa> yeah, that's different
06:06:41 <delinka> then, finally, after other tedium, they finally explained *why* it was moronic. how ;bout we start with the correction next time?
06:07:14 <Philippa> yeah, agreed
06:07:31 <shapr> I have enough experience and/or stubborness that I don't ever want to be told that something is moronic and why. I want to be told the answer to my question.
06:07:41 <delinka> I chimed in a bit about the rudeness and finally got "when you can answer as good as me, then you can complain about my conduct"
06:07:59 <delinka> anyway, I'm over it now. 
06:08:02 <shapr> For that reason, I try to correctly answer the question someone asks, and then divine their actual purpose and offer suggestions.
06:08:27 <shapr> For example, on #haskell we occasionally hear "How do I get an Int from an IO Int?"
06:08:53 <shapr> So I say "unsafePerformIO will give that to you, but it's probable that going about it a different way is a better approach."
06:09:46 <delinka> well, hell ... I asked a seriously newbie question in here last night - how do I output something.  After some back-n-forth w/o rudeness, I got an answer. "use show" -- painless. why can't they all be like that...
06:10:54 <shapr> Sometimes people who equate knowledge with rudeness do show up here. They tend to get removed though.
06:11:33 * delinka observes no ops in ##java other than ChanServ
06:11:48 --- mode: ChanServ set +o delinka
06:11:50 <shapr> :-P
06:11:55 <delinka> wtf?
06:11:58 <delinka> OK
06:12:17 --- mode: shapr set -o delinka
06:12:19 --- mode: shapr set -o shapr
06:12:29 <delinka> 'sup with that?
06:12:39 <shapr> Chanserv and other services manage privs for you.
06:12:48 <shapr> Try /msg chanserv access #haskell list
06:12:57 <delinka> and I get to be op (for two seconds) why?
06:13:16 <Philippa> delinka: you should've pointed out that you can do the rudeness fine by yourself :-)
06:13:20 <shapr> Just for entertainment :-) You may not see the ops, but there is often one around.
06:13:25 <shapr> haha
06:13:34 <shapr> hiya jewel
06:13:42 <Philippa> delinka: print = putStr . show, btw
06:14:37 <delinka> I just thought it terribly odd that an automated process promotes me after talking about ops. So it wasn't ChanServ doing that?
06:14:45 <shapr> Nah, I did that.
06:15:04 <delinka> Philippa: "...rudeness...", no, color me surprised
06:15:29 <shapr> delinka: Are you in Atlanta?
06:15:39 <delinka> close enough
06:15:45 <vincenz> delinka: the US?
06:15:59 <delinka> vincenz: south east US
06:16:15 <vincenz> southern confederate states
06:16:25 <delinka> lol ... yeah, that
06:16:29 <shapr> I'm from Birmingham, AL myself.
06:16:40 <delinka> ah, a neighbor!
06:16:41 <vincenz> AL= alabama?
06:16:44 <shapr> And may be moving back there in a few weeks.
06:16:52 <delinka> there==Atl?
06:16:54 <vincenz> shapr gump?
06:17:02 <delinka> heh
06:17:22 <shapr> There == Birmingham
06:17:34 <vincenz> shapr: is that close to greenbow?
06:17:43 <delinka> *from* Birmingham ... so you're not there now.  got it.
06:17:45 <Philippa> shapr: I tend to answer the question as put if there's a reasonably simple answer, and if not ask them how sure they are they want to do that rather than find another way...
06:18:20 <Philippa> (unless they want to do something impossible - in the IO case, I tend to consider that impossible unless they confirm a really damn good reason for wanting unsafePerformIO)
06:19:11 <shapr> delinka: Right, living in Finland and Sweden the last six or seven years.
06:19:46 * Philippa often suffers a moment's confusion, as she spends time in the "real" Birmingham once in a while
06:20:14 <vincenz> Philippa: old Birmingham vs new Birmingha
06:20:38 <Philippa> vincenz: but not New Birmingham, which'd be different :-)
06:20:44 <vincenz> :D
06:21:07 <delinka> Philippa: I have a really good reason for doing <insert really stupid and unsafe thing here> in Haskell. Why won't IO just give me the weather in Moscow?
06:21:22 <delinka> :-D
06:21:28 <vincenz> Philippa: it's my task to take people on their miustakes
06:21:29 <vincenz> in fact
06:21:35 <vincenz> that reminds me of a really funny story
06:21:46 <Philippa> vincenz: I wrote "real" rather than real for a reason :-)
06:22:05 <Philippa> delinka: because you're running on a pocket calculator with no access to anything that knows about the weather, HTH HAND :-)
06:22:31 <vincenz> my colleague (spanish) was explaining how he and his friend had gone out and that a girl had hooked up with them and 'caught' his friend (meaning she took him with her) however he pronounced it as "cocked"
06:22:49 <Philippa> heh
06:23:06 <vincenz> we asked him what it meant to be cocked by a girl
06:23:51 <BCoppens> =)
06:24:04 <Philippa> usually the first two letters're a little different. It may involve silicone and/or a harness :-)
06:24:07 <delinka> unfortunately, language barriers tend to come across as rudeness in IRC...
06:24:17 <vincenz> delinka: not only that
06:24:25 <vincenz> delinka: nuances are non existent in text
06:24:31 <delinka> true
06:24:43 <vincenz> which makes dubious statements possibly offensive if they're meant in a funny way
06:24:53 <shapr> Meaning it's best to request clarification before being offended.
06:24:57 <Philippa> delinka: sometimes. It doesn't help if someone's used to using an insane!!!!1! number of exclamation marks or various other conventions that effectively indicate manic screaming
06:25:05 <vincenz> Philippa!!!!!!!!
06:25:10 * shapr yowls
06:25:31 <delinka> @slap vincenz
06:25:31 * lambdabot smacks vincenz about with a large trout
06:25:36 <delinka> for screaming
06:25:39 * vincenz wonders why noone ever uses %$&"@# like in the comics
06:26:06 <delinka> i hafta hold down shift to cuss like that - 's easier to say "f4 it"
06:26:22 <vincenz> delinka: ah, I have an azerty
06:26:34 <vincenz> at least on my desktop, I hate it, but I guess it's great for this
06:26:38 <Philippa> delinka: and hence the windows tradition of alt-f4 tell an app to f4 off
06:26:53 <Philippa> +to in there somewhere, my brain doesn't work so good...
06:27:06 * delinka wonders why he never made the alt-f4 connection
06:27:36 <vincenz> it's funny, in the early days of IRC you could tell people to press ALT+F4 and you'd get a "xxxx has disconnected"
06:27:45 <delinka> lol
06:28:11 <Philippa> yeah, or /disco for funky music
06:28:18 <vincenz> and sometimes they would come back steaming and you'd tell them they did it wrong, that they had to click ALT+F4
06:28:26 <vincenz> and "xxxx has disconnected" again
06:28:41 <delinka> http://ars.userfriendly.org/cartoons/?id=20010523
06:29:27 <vincenz> delinka: *laughs*
06:29:34 <delinka> "you closed my chat!!!!!11!11one" "no, you didn't press the key correctly, try it again, more slowly" "xxxx has disconnected"
06:29:37 <vincenz> ah... scriptkiddies
06:32:28 * vincenz mutters
06:32:35 <vincenz> got called last night at 00:30 by the landlady
06:39:12 <delinka> what does a landlady want at that time of night?
06:39:39 <vincenz> well
06:39:48 <vincenz> the neighbours under me had water leaking through the ceiling
06:40:06 <vincenz> I was on my way home from a columbian restaurant... so I passed by there and damn, a square meter of ceiling dripping with water
06:40:15 <delinka> ick
06:40:30 <azuroth> whoa
06:40:48 <vincenz> yeah
06:40:54 <vincenz> I went to check at my palce... nothing
06:41:08 <vincenz> but I noticed it's right under this column that's not part of my app, but that is closed off by some thin wall
06:41:15 <vincenz> so I figure it came straight from the roof
06:41:20 <vincenz> cause it rained quite hard last night
06:42:20 <delinka> Cabal - 'make install' rebuilds everything after 'make' just completed with no errors. huh?
06:42:31 <delinka> so, leaky roof?
06:42:51 <vincenz> I think so yeah
06:43:29 <delinka> time to move the expensive electronics from that side of the apt
06:43:59 <vincenz> I'm moving out soon
06:44:08 <jethr0> hey vincenz
06:44:09 <vincenz> is there any tool around to graphically display module dependencies?
06:44:20 <vincenz> jethr0: hey man, I replied to your email, thanks, it all looks good
06:44:24 <vincenz> I do have one private not however
06:44:38 <delinka> Cabal - "make install" get to "Configuring cabal-setup-1.1.4..." and errors with "setup: cannot satisfy dependency Cabal>=1.1.4" -- ideas?
06:44:43 <jethr0> vincenz: have you managed to log in?
06:44:45 <vincenz> yep
06:44:49 <vincenz> check privmsh
06:51:45 <morans> > sum [1..1000000]
06:51:46 <lambdabot> Exception: stack overflow
06:51:55 * morans thought that wasn't meant to happen
06:52:17 <ADEpt> > foldl' (+) 0 [1..1000000]
06:52:18 <lambdabot> 500000500000
06:52:38 <ADEpt> morans: here you are. "Sum" is too lazy.
06:52:53 <ulfdoz> What's the difference between foldl and foldl'?
06:52:57 <morans> oh
06:53:18 <ADEpt> ulfdoz: foldl' applies folding function strictly, foldl - lazily
06:53:25 <ulfdoz> ah
06:53:41 <ADEpt> @seen dons
06:53:42 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 26 minutes and 54 seconds ago.
06:53:47 <ADEpt> dons: ping
06:55:22 <shapr> yow!
06:57:59 <shapr> dcoutts_: ping?
06:58:15 <delinka> @yow
06:58:15 <lambdabot> Yow!  Are you the self-frying president?
06:59:20 <ADEpt> shapr: you are SOC admin, right?
06:59:22 <shapr> yup
06:59:29 <ADEpt> shapr: deassing application from me :)
06:59:30 <shapr> I don't know how to de-assign though.
06:59:47 <shapr> I'm looking...
06:59:58 <ADEpt> shapr: hmm. No nifty button for deassign?
07:00:01 <shapr> Nope
07:00:22 <ADEpt> shapr: maybe if audreyt said "I will mentor this" on that application, you would be able to assign her?
07:00:25 <BCoppens> as if the soc interface has a nifty _anything_? ;)
07:00:37 <ADEpt> BCoppens: right you are :)
07:01:22 <shapr> Yes, I can assign a mentor who has offered.
07:01:35 <BCoppens> ADEpt: :)
07:02:09 <ADEpt> @seen audreyt
07:02:10 <lambdabot> audreyt is in #haskell. I last heard audreyt speak 1 day, 11 hours and 44 minutes ago.
07:02:20 <ADEpt> shapr: oh wait
07:02:47 <ADEpt> shapr: the question is not how to assign another mentor. It is how to deassign all mentors :)
07:02:57 <kolmodin> @seen waern
07:02:58 <lambdabot> I saw waern leaving #haskell 3 days, 18 hours, 6 minutes and 2 seconds ago, and .
07:02:59 <shapr> audreyt is already assigned to Caio's fast mutable collection types.
07:03:04 <shapr> ADEpt: Yes, I just don't know how.
07:03:13 <shapr> I don't see an option for that.
07:03:52 <ADEpt> shapr: I dont exactly want to just mark application "ineligible" :(
07:04:17 <shapr> I don't know.
07:05:03 <shapr> I say don't worry, we'll figure it out :-)
07:08:14 <eivuokko> How can I convert between Ptr a and Integer/Int/WordXY?  (Yes, that is safe where I need it)
07:09:11 <xerox> @hoogle poke
07:09:12 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
07:09:12 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
07:09:12 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
07:09:25 <xerox> @type Foreign.Storable.peek
07:09:26 <lambdabot> forall a.
07:09:26 <lambdabot>          (Foreign.Storable.Storable a) =>
07:09:26 <lambdabot>          GHC.Ptr.Ptr a -> IO a
07:09:31 <xerox> There you go?
07:10:03 <azuroth> Ptr a and Int? like, int c = &foo;?
07:10:13 <eivuokko> Yes.
07:10:21 <eivuokko> I can do it with peek and poke, sure.
07:10:36 <eivuokko> But allocating memory for that is a bit boring
07:10:46 <xerox> There are handier functions I think.
07:10:52 <xerox> @docs Foreign.Storable
07:10:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
07:11:12 <ADEpt> shapr: i mailed google with question nevertheless.
07:11:29 <xerox> @hoogle with
07:11:29 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
07:11:30 <lambdabot> Network.withSocketsDo :: IO a -> IO a
07:11:30 <lambdabot> Distribution.PackageDescription.withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
07:11:34 <eivuokko> xerox, There isn't such function in Storable as far as I know.  Nor in Foreign.
07:11:46 <xerox> @docs Foreign.Marshal
07:11:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal.html
07:11:50 <xerox> There, maybe.
07:12:00 <eivuokko> Yeah, I know how to do it with peek and poke.
07:12:08 <xerox> @docs Foreign.Marshal.Utils
07:12:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html
07:12:11 <xerox> Specifically.
07:12:41 <eivuokko> I wanted pure simple-to-use function like castPtr/plusPtr/minusPtr.
07:13:04 <xerox> with/new ?
07:13:30 <xerox> @docs Foreign.C
07:13:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C.html
07:13:56 <xerox> There are those specifically for Strings too...
07:17:28 <azuroth> ?hoogle isinf
07:17:28 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
07:17:41 <eivuokko> Let me rephrase, does anyone know if there's a ready-made function with signature Ptr a -> Int, or Ptr a -> WordXY or Ptr a -> Integer?
07:17:57 <delinka> what's a good name for a parrot?
07:18:27 <delinka> parrot
07:18:33 <azuroth> cold conure?
07:24:06 <isaacd> ptr `minusPtr` nullPtr might work, though it's clearly not that great...?
07:25:40 <eivuokko> It most likely works in my case, as it would work on C on this platform (Win32/x86)
07:26:01 <azuroth> ?hoogle Ptr a -> Int
07:26:01 <lambdabot> Foreign.Ptr.minusPtr :: Ptr a -> Ptr b -> Int
07:26:11 <azuroth> ?hoogle Ptr a -> Word
07:26:11 <lambdabot> No matches, try a more general search
07:26:24 <shapr> Crap, it's snowing. I was gonna go unicycling.
07:26:31 <eivuokko> Anyway, I simply adopted not converting in my ffi bindings and make user worry about it, for now.
07:26:48 <azuroth> heh, really? wasn't jjugler or someone a unicyclist as well?
07:27:11 <xerox> I learnt juggling!
07:27:23 <xerox> (In the past week, three balls, that is.)
07:27:36 <azuroth> @quote jjugler
07:27:36 <lambdabot> jjugler hasn't said anything memorable
07:28:05 <azuroth> @quote jjugle
07:28:05 <lambdabot> jjugle hasn't said anything memorable
07:28:39 <azuroth> that's bullschildt, you told me one of his quotes earlier!
07:35:00 <BCoppens> @quite jjuggle
07:35:01 <lambdabot> Maybe you meant: quit quote
07:35:05 <BCoppens> @quote jjuggle
07:35:05 <lambdabot>  I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol squad, but he
07:35:05 <lambdabot> declined.
07:35:11 <BCoppens> there you go ;)
07:36:10 <azuroth> :s
07:36:15 <azuroth> @quote jjugle
07:36:16 <lambdabot> jjugle hasn't said anything memorable
07:36:18 <azuroth> @quote jjugle
07:36:18 <lambdabot> jjugle hasn't said anything memorable
07:36:23 <azuroth> err
07:36:24 <azuroth> oh
07:36:30 <dons> ?uptime
07:36:30 <lambdabot> uptime: 4 days, 8 hours, 11 minutes and 44 seconds
07:36:51 <BCoppens> azuroth: with 2 'g's ;)
07:36:59 <azuroth> yeah :-)
07:37:10 <BCoppens> :)
07:40:15 <shapr> azuroth: There are several unicyclists on #haskell, shapr, dcoutts, and Beelsebob I'm sure of.
07:40:44 <azuroth> wow. is it very hard?
07:40:47 <xerox> http://www.nasa.gov/centers/ames/multimedia/images/2005/google-imageoftheday.html
07:42:01 <shapr> azuroth: Nah, it's pretty easy.
07:42:59 <Maddas> xerox: Wow, so they've got ambitions higher than just taking over the world :)
07:43:31 <davidhouse> hehe
07:43:48 <xerox> Maddas: search for "Google engEDU" on http://video.google.com/ and between them, the one containing the "Lunar" word.
07:43:56 <azuroth> hmm. it would be very convenient, if it were as easy as a bike: taking it on trains wouldn't be a hassle at all
07:44:07 <shapr> I took mine on the bus today.
07:44:25 <shapr> azuroth: http://www.scannedinavian.com/~shae/blog/images/shae-sj.png
07:44:25 <Maddas> xerox: Hah!
07:44:33 <xerox> Maddas: great stuff, imo.
07:45:03 <Maddas> Yeah, I've seen one or two.
07:45:59 <xerox> Want me to search for the whole name?  Basically there is an attractive woman from NASA talking at Google and she says they want them to build Google Moon :-)
07:46:05 <ADEpt> @seen dons
07:46:05 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 9 minutes and 35 seconds ago.
07:46:38 <ADEpt> dons: why testsuite in fps always uses the same "random" values each run?
07:46:38 <azuroth> :D
07:46:41 <xerox> I always forget that shapr is red-haired... <grin>
07:46:46 <shapr> Why so?
07:47:01 <xerox> Dunno.
07:47:10 <shapr> xerox: Show us some pix of you!
07:47:19 * xerox mumbles
07:47:22 <shapr> Google Mars is way cool, seen it?
07:47:39 <xerox> Yesh!
07:47:49 <xerox> Elevation/Visible/Infrared
07:48:00 <xerox> That's probably the NASA data she was speaking of?
07:48:16 * Maddas mumbles something about working on interesting things :-)
07:48:30 <xerox> Maddas: yes yes yes.
07:48:53 <xerox> I'm sure we tought the same thing (-:
07:49:09 <Maddas> (taught :)
07:49:13 <Maddas> erm, thought. Grah
07:49:21 <xerox> Ack.
07:49:46 <Maddas> xerox: Yes, but you're not the one writing a GUI in C++ using just Xlib *mumble* =)
07:50:16 <xerox> Maddas: let's start something!
07:50:23 <azuroth> ...are you(r superiors) mad?
07:51:05 <Maddas> xerox: I wish I had more time this semester :) For now, I'll stick to starting with homework.
07:51:30 <xerox> Electrical engineering homeworks?
07:52:00 <Maddas> not specifically, just some theoretical exercise about computer networks for now. Nothing worth mentioning :)
07:52:50 <Maddas> azuroth: Mmmmaybe. On the other hand, though, I don't want to be the one trying to cross-compile the libraries (my schedule is too tight for that anyway) :)
07:53:06 <xerox> Gtk2Hs? (-:
07:53:44 <Maddas> xerox: :-)
07:56:25 <Maddas> The 'Collecting Meteorites in Antarctica' talk is quite interesting.
07:57:39 <azuroth> I'd better get to bed, wake me up in the morning!
07:57:52 <xerox> Yeah!
07:58:01 <araujo> Hello!
07:58:04 <xerox> Maddas: check out the "Bay Area Discrete Math Day" ones too!
07:58:08 <xerox> Howdy araujo.
07:58:21 <araujo> Hola xerox :-)
07:58:24 <araujo> what's up?
07:58:36 <xerox> Watching engEDU vids.
07:59:04 <Maddas> Gnargh, too many videos, too little time! 
07:59:22 <xerox> Indeed.  Download them and stick on your iPod.
07:59:37 <araujo> anything interesting?
07:59:59 <xerox> `The Paradox of Choice - Why More is Less' is interesting.
08:00:08 <xerox> The mathematics ones are too :-)
08:00:20 <araujo> xerox, link?
08:01:43 <xerox> http://video.google.com/
08:02:21 <araujo> thanks xerox 
08:03:12 <xerox> http://www.astroseti.org/impacts.php
08:05:36 <jip> does ghc already have a record extension?
08:05:52 <xerox> It does support records, what do you want exactly?
08:06:03 <jip> better records :)
08:06:50 <xerox> I think someone marked a new record on the 100m, 9.67s?
08:07:08 <hyrax42_> it's below 9 isn't it?
08:07:10 <hyrax42_> the record
08:07:16 <hyrax42_> 8.98 or something?
08:07:18 <hyrax42_> (?)
08:07:23 <psnl> @google 100m record
08:07:24 <lambdabot> http://news.bbc.co.uk/sport2/hi/athletics/4093560.stm
08:07:34 <hyrax42_> ok
08:07:36 * hyrax42_ moron
08:07:46 <hyrax42> or at least
08:07:48 <psnl> 9.77 was set in 1994
08:07:49 * hyrax42 ignorant
08:07:49 <xerox> http://news.bbc.co.uk/sport2/hi/athletics/4093560.stm
08:07:56 <xerox> Yes, 9.76 then.
08:08:50 <xerox> http://en.wikipedia.org/wiki/World_Record_progression_100_m_men
08:09:04 <xerox> 9.76	Justin Gatlin	USA	Doha, Qatar	May 12, 2006
08:09:35 <psnl> cool
08:09:39 <hyrax42> but had 9.77 been beaten outside the olympics previously?
08:09:57 <hyrax42> not even
08:10:00 <hyrax42> wow
08:10:01 <hyrax42> 12 years
08:10:03 <hyrax42> for a hundredth
08:10:12 <hyrax42> wait
08:10:13 <hyrax42> wtf
08:10:18 <xerox> http://brainbites.nasa.gov/
08:10:18 <hyrax42> gah I just woke up
08:10:56 <psnl> hyrax42: I think that you don't have to set the record at the olympics for it to count
08:11:12 <psnl> anyway...
08:11:39 <hyrax42> I think there are olymipc records separate from world records though
08:11:48 <hyrax42> but yeah it doesn't/shouldn't really matter
08:13:53 <xerox> http://brainbites.nasa.gov/downloads/bolt/bolt_cc.mov
08:16:21 <BCoppens> the woman looks too happy ;-)
08:16:30 <xerox> hehe
08:16:36 <xerox> It is for children?
08:17:06 <BCoppens> I guess
08:18:02 <xerox> But still, there are some nice questions.
08:18:24 <BCoppens> This computer does not have Flash 7 installed *cries*
08:18:52 <xerox> )-:
08:20:22 <BCoppens> luckily I have enough other time consuming things to do, so it's actually a positive thing that I can't spend my time watching nasa movies ;-)
08:27:49 * shapr boings
08:27:57 <adaran> i've got a question on "lifting" - i'm reading the school of expression book by paul hudak, and he uses a set of functions called "lift0", "lift1", "lift2" and so on - however, they are not in Prelude and I can't find any information about them on the web. any hints?
08:28:18 <shapr> Are they used for monads?
08:28:37 <hyrax42> @index liftM0
08:28:37 <lambdabot> bzzt
08:28:39 <adaran> nope, they are used to define operations on class members
08:29:16 <shapr> They're probably there just for teaching then.
08:29:18 <adaran> instance Num a => Num (Behavior a) where (+) = lift2 (+)
08:29:23 <xerox> @type liftM
08:29:24 <lambdabot> forall r (m :: * -> *) a1.
08:29:24 <lambdabot>    (Monad m) =>
08:29:24 <lambdabot>    (a1 -> r) -> m a1 -> m r
08:29:26 <xerox> @type liftM2
08:29:27 <lambdabot> forall r (m :: * -> *) a2 a1.
08:29:27 <lambdabot>     (Monad m) =>
08:29:27 <lambdabot>     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:29:47 <adaran> there's an example. monads have not been covered yet
08:29:59 <xerox> Okay :-)
08:31:27 <adaran> hmm some websites seem to have implementations for them when citing the book. however, i can't actually find the source for that in the paper version... weird. well, i guess it's not an "official" function then
08:42:23 * kombinator thinks that someone has to persuade Bruce Tate to write an article featuring Haskell (see http://www-128.ibm.com/developerworks/views/java/libraryview.jsp?search_by=crossing+borders: )
08:47:15 <petekaz> adaran: how is that book btw?
08:51:03 <davidhouse> adaran: could you give some more context?
08:51:36 <adaran> petekaz, interesting. quite hands on, though i'm not sure whether that's what i want.
08:51:51 <petekaz> adaran: have you looked at any other haskell books?
08:52:25 <adaran> davidhouse, in the book, there's a type Animation a = Time -> a -- with time beeing a Float
08:53:01 <petekaz> adaran: I used this for my haskell booklist: https://jaortega.wordpress.com/2006/03/28/a-haskell-bookshelf/
08:53:14 <adaran> petekaz, yes, one recommended by my professor. read it in the german translation, it's "introduction to functional programming with haskell" by chakravarty and keller
08:53:35 <adaran> petekaz, somewhat light read, but mostly horrible, because it was full of spelling and code errors
08:53:44 <davidhouse> adaran: okay, so where is a lift function used with that?
08:54:02 <adaran> petekaz, bordering on ridiculous
08:54:12 <petekaz> adaran: I'll stay away then!
08:54:38 <petekaz> adaran: I'm leaning towards Bird's book: Intro to FP using Haskell
08:54:41 <adaran> davidhouse, well, in an effort to introduce the "newtype" construct, a type "Behavior" is created similiar to Animation
08:55:44 <davidhouse> xerox, ping
08:55:51 <davidhouse> adaran: yes
08:55:55 <adaran> petekaz, i'm somewhat content with the hudak here. however, at some point, i had to stop and do the math (literally), because much focus of the book is on the gfx and design part. so it doesn't move at a rapid pace, haskell-wise, and sometimes there's excursion into math and proofs
08:56:17 <adaran> davidhouse, so that went newtype Behavior a = Beh (Time -> a)
08:56:40 <davidhouse> with type Time = Float, i assume.
08:56:42 <adaran> davidhouse, then, there's an effort to make Behavior a member of the Num class:
08:56:46 <adaran> davidhouse, yes
08:56:49 <petekaz> adaran: thanks for the input, I'm not one that enjoys math that much, so perhaps I should stay away from that one as well.
08:57:10 <adaran> davidhouse, Num a => Num (Behavior a) where (+) = lift2 (+)
08:57:22 <davidhouse> interesting.
08:57:38 <davidhouse> i've never seem anything like that before
08:57:46 <davidhouse> although it bears an uncanny resemblance to monads.
08:57:54 <adaran> davidhouse, now, i've looked up lifting in the haskell wiki, though i'm not sure what to make of it yet. i think it somehow relates to map'ing
08:58:08 <adaran> davidhouse, haven't looked at monads yet either =)
08:58:31 <davidhouse> is it an old book?
08:59:10 <adaran> davidhouse, first published in 2000
08:59:15 <davidhouse> hmm, so not really.
08:59:26 <wolverian> hrm, how would you implement lift2 (or lift1 for that matter) in haskell?
08:59:49 <davidhouse> any references to lift in the wiki probably refer to 1) the liftM family of functions (lifting a non-monadic function to a monadic one) or 2) lift, used in monad transformers.
09:00:16 <davidhouse> wolverian: i'm not even sure what those lift, lift2 are meant to do
09:00:35 <wolverian> davidhouse, I assume they lift a value from a container. lift1 (_ a) = a -- pseudocode
09:01:00 <xerox> davidhouse: pong
09:01:11 <wolverian> that might be a completely unreasonable assumption
09:01:23 <adaran> lift2 :: (a -> b -> c) -> (Behavior a -> Behavior b -> Behavior c)          lift2 g (Beh a) (Beh b) = Beh (\t -> g (a t) (b t))
09:01:26 <davidhouse> xerox, did you catch Andres Loeh's reply to the HC&A report on the mailing list?
09:01:45 <wolverian> oh, I read it wrong. it's the inverse of what I said. :)
09:01:48 <adaran> that's from the example code of a lecture of a professor teaching in a different university but using the same book
09:02:06 <davidhouse> there's no appendix with these things defined?
09:02:18 <davidhouse> xerox, it asked for a summary of haskell.org's involvement in the SoC.
09:02:20 <adaran> davidhouse, no, the book has some sort of a "type-along" approach
09:02:30 <adaran> you have to type in the code yourself, and often revise it
09:02:38 <davidhouse> i see.
09:02:51 <adaran> bit of confusing, i'd would've been better if the author at least offered the code for download from somewhere
09:03:02 <adaran> this way, there's no way to skip chapters
09:03:15 <davidhouse> @fptools Control.Monad.Reader
09:03:15 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
09:05:18 <davidhouse> i'm pretty sure your lift functions are identical to liftM in Reader.
09:05:27 <davidhouse> your Behaviour is essentially Reader, i think
09:05:39 <davidhouse> (you probably won't know what i'm talking about until you cover monads)
09:06:27 <adaran> yep. from what i understand it's only "lifting" a value to allow easy application of operations on the underlying data types
09:08:10 <davidhouse> unrelated question:
09:09:06 <davidhouse> say i'm working in ReaderT, with (say) IO as the underlying monad. if i have a computation in ReaderT with Identity, can i involve that computation in a do block?
09:09:35 <Cale> with IO?
09:09:58 <davidhouse> i.e. if i'm in ReaderT with IO, and i want to involve an IO computation, i use lift (nothing to do with your stuff, adaran). can i similarly involve an Identity computation?
09:10:27 <Cale> you can apply runIdentity
09:10:53 <davidhouse> argh, oops
09:11:33 <davidhouse> i meant can i similarly involve a computation in ReaderT with Identity (i guess that's not actually that similar to lifting from IO to ReaderT with IO, now i think about it)
09:12:08 <Cale> no, though you can involve a computation which is polymorphic in the underlying monad
09:12:31 <davidhouse> oh, that's true. that would be a better way of doing it.
09:13:53 <davidhouse> anyone happen to know if --ignore-all-exports is implemented in haddock? i seem to be getting an unrecognised option error when using it
09:15:21 <MarcWeber> Any idea what's wrong here (Parsec) ? http://rafb.net/paste/results/vfdmU655.html   rawUnicodeChar should return (char, (charoffset, lineoffset)) as well.
09:15:55 <davidhouse> > (take 1 [], head [])
09:15:55 <lambdabot> Add a type signature
09:16:05 <davidhouse> > (take 1 [] :: Int, head [] :: Int)
09:16:06 <lambdabot> Couldn't match `Int' against `[a]'
09:16:14 <davidhouse> > (take 1 [] :: [Int], head [] :: Int)
09:16:15 <lambdabot> Exception: Prelude.head: empty list
09:16:21 <davidhouse> eurgh.
09:16:27 <davidhouse> > take 1 [] :: [Int]
09:16:28 <lambdabot> []
09:16:36 <davidhouse> > head [] :: Int
09:16:37 <lambdabot> Exception: Prelude.head: empty list
09:16:40 <davidhouse> right.
09:17:06 <Cale> MarcWeber: you're mixing ReadP and Parsec
09:17:23 <Cale> (they're not compatible)
09:17:41 <xerox> davidhouse: which ml?
09:18:48 <MarcWeber> Which is the command in Parsec to get on single character?
09:19:34 <Cale> anyChar
09:19:47 <MarcWeber> Ah. now I remember having read it. Thanks a lot.
09:25:39 <davidhouse> xerox, haskell.
09:25:49 <davidhouse> xerox, REMINDER: HC&A Report (extended deadline: 15 May 2006)
09:28:32 <davidhouse> can you eta-reduce type synonym declarations?
09:28:42 <davidhouse> e.g. type Foo a = Bar a -> type Foo = Bar
09:29:02 <vincenz> nope
09:29:04 <vincenz> types have kind *
09:29:13 <vincenz> that new type has kind *-> *
09:29:20 <Cale> Maybe in really new ghc's
09:29:25 <Cale> not in H98
09:30:24 <Cale> oh, it works in 6.4.1
09:30:51 <davidhouse> grr. i hate boot files.
09:31:44 <xerox> davidhouse: I'll be sanding something ASAP, I got sucked into watching some videos, you know...
09:32:01 <davidhouse> xerox, heh :)
09:32:08 <jethr0> is it possible to have lists with strict elements? "type Matrix = [[!Double]]" doesn't work :(
09:33:02 <jethr0> even better would be a list of unboxed elements or sth like that
09:34:43 <vincenz> jethr0: a list of unboxed elements would prolly have to be a different kind of list
09:34:56 <vincenz> something like
09:35:23 <vincenz> List' a = !Nill' | Const !a !List' a
09:35:29 * vincenz isn't sure
09:36:04 <davidhouse> i assume you meant "a list of strict elements", as those aren't unboxed ;)
09:36:36 <vincenz> I think that for unboxed elements your GC needs to be modified
09:36:43 <vincenz> for instance ocaml only allows 31 bit integers
09:36:46 <davidhouse> jethr0: can you have a strict type constructor?
09:36:46 <vincenz> just so it can unbox em
09:37:04 <davidhouse> e.g. would type Foo = !Bar work?
09:37:29 * davidhouse thought strictness via bang annotations only worked with data constructors
09:37:35 <Saulzar> No...
09:37:39 <jip> if i have [(a -> a)] how can i apply each of these in sequence to an initial "a" value, and get the final result?
09:37:48 <davidhouse> jip, map ($a)
09:38:00 <jip> hm...... eh?
09:38:03 <vincenz> davidhouse: nope
09:38:08 <vincenz> jip: like thios
09:38:15 <vincenz> foldr1 (.) list $ value
09:38:21 <vincenz> not sure if it's foldr or fold
09:38:31 <jip> ah yes, good ol' fold
09:38:50 <davidhouse> > map ($ "hello") [(++"world"), (++" vietnam"), ("hi there, " ++)]
09:38:51 <lambdabot> ["helloworld","hello vietnam","hi there, hello"]
09:39:03 <davidhouse> oh, you want to thread it through.
09:39:05 <vincenz> nope
09:39:08 <vincenz> look
09:39:12 <Saulzar> Handy to define compose = foldr (.)
09:39:29 <vincenz> foldr1 (.) [(+1), (*2)] $ 1
09:39:35 <vincenz> > foldr1 (.) [(+1), (*2)] $ 1
09:39:36 <lambdabot> 3
09:39:39 <vincenz> hmm
09:39:42 <vincenz> should be foldl
09:39:45 <vincenz> > foldl1 (.) [(+1), (*2)] $ 1
09:39:46 <lambdabot> 3
09:39:49 <vincenz> ponder
09:39:54 <davidhouse> foldl (.) id works with nonempty lists.
09:40:01 <vincenz> aha
09:40:04 <vincenz> it always applies the last one first
09:40:06 <vincenz> sho prolly
09:40:18 <vincenz> compose = foldr (.) id . reverse
09:40:31 <Saulzar> foldl swaps the arguments, so it will be the same anyway
09:40:45 <davidhouse> > let compose = foldl (flip (.)) id in compose [(+1), (*2)] 3
09:40:46 <lambdabot> 8
09:40:52 <Saulzar> > foldl1 (flip (.)) [(+1), (*2)] 1
09:40:53 <lambdabot> 4
09:43:18 <jip> > foldlr (flip (.)) [(+1), (*2)] 1
09:43:43 <vincenz> jip: foldr expects an initial arg
09:44:13 <lambdabot>  Not in scope: `foldlr'
09:44:15 <davidhouse> > let compose xs = evalState (mapM modify xs) in compose [(+1), (*2)] 3
09:44:16 <lambdabot> [(),()]
09:44:32 <davidhouse> oops :)
09:44:49 <davidhouse> does mapM = sequence . map?
09:45:13 <xerox> Clever.
09:45:25 <davidhouse> > let compose = execState . mapM modify in compose [(+1), (*2)] 3
09:45:26 <lambdabot> 8
09:45:44 <jethr0> davidhouse: sry, was intently programming :)
09:45:46 <jip> how do i make a function f :: [Maybe a] -> [a] that doesn't include elements from the initial list that are Nothing?
09:45:54 <davidhouse> jip, catMaybes.
09:46:08 <davidhouse> or catMaybe
09:46:15 <davidhouse> @hoogle catMaybe
09:46:15 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
09:46:21 <davidhouse> that's the one.
09:46:45 <xerox> Sometime is useful to hoogle for the type:
09:46:52 <xerox> @hoogle [Maybe a] -> [a]
09:46:53 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
09:47:00 <jethr0> davidhouse: i'm implementing matrix multiplication and i'm wondering whether "[[1,2,3], [2,3,4, ...]" form might actually be faster with "transpose" and "map" than with explicity UArray stuff
09:47:19 <xerox> jethr0: the other way around, I think.
09:47:22 <jgraves> xerox: that's really cool.
09:47:36 <davidhouse> hoogle is excellent.
09:47:48 <jethr0> xerox: which way? explicit indexing is just so un-haskelly
09:48:15 <xerox> jethr0: go for what fits better for you, I think, but Arrays faster than list for element access.
09:49:19 <jethr0> yes, but i don't need element access for multiplication. i can just do "mul = zipWith (sum . zipWith (*))" or sth like that
09:49:51 <jethr0> no, that wasn't right, but in that vein
09:50:18 <jip> > let f x x = x + 1 in f 3 4
09:50:19 <lambdabot>   Conflicting definitions for `x'
09:50:19 <lambdabot>   In the definition of `f'
09:50:27 <xerox> Maybe generalize so that it is simple to swap implementation and benchmark, if your problem is speed.
09:50:42 <xerox> jip: eheh, no pattern-equality.
09:50:59 <jethr0> yes, i guess
09:51:54 <davidhouse> > let compose [] = Reader id; compose (f:fs) = local f (compose fs) in runReader (compose [(+1), (*2)]) 3
09:51:54 <lambdabot> 8
09:52:04 <davidhouse> (is there a prettier function for Reader id?)
09:52:13 <xerox> return id
09:52:20 <davidhouse> duh.
09:52:26 <davidhouse> > let compose [] = return id; compose (f:fs) = local f (compose fs) in runReader (compose [(+1), (*2)]) 3
09:52:27 <lambdabot> Add a type signature
09:52:33 <xerox> (-:
09:52:47 <davidhouse> > let compose [] = return id :: Reader a; compose (f:fs) = local f (compose fs) in runReader (compose [(+1), (*2)]) 3
09:52:47 <lambdabot>   Kind error: `Reader a' is not applied to enough type arguments
09:52:48 <lambdabot>   In an expression type signature: Reader a
09:52:48 <lambdabot>   In the expression: return id :: Reader a
09:52:54 <xerox> :: Int
09:53:21 <davidhouse> > let compose [] = return id :: Reader Int Int; compose (f:fs) = local f (compose fs) in runReader (compose [(+1), (*2)]) 3
09:53:21 <lambdabot> Couldn't match `Int' against `t -> t1'
09:53:37 * davidhouse takes this privately
09:53:41 <xerox> I mean in the real expression.
09:54:04 <xerox> > let compose [] = return id; compose (f:fs) = local f (compose fs) in runReader (compose [(+1),(*2)]) 3 :: Int
09:54:05 <lambdabot> Couldn't match `Int' against `a -> a'
09:54:14 <xerox> Duh.
09:54:36 <xerox> @libsrc Control.Monad.Reader
09:54:36 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/Reader.hs
09:54:41 <xerox> @fptools Control.Monad.Reader
09:54:41 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
09:55:04 <xerox> > let compose [] = return $ const id; compose (f:fs) = local f (compose fs) in runReader (compose [(+1),(*2)]) 3 :: Int
09:55:04 <lambdabot> Couldn't match `Int' against `b -> a -> a'
09:55:10 <xerox> Wha.
09:55:14 <davidhouse> oh!
09:55:29 <davidhouse> return a = Reader (const a)
09:55:33 <xerox> No, return doesn't work.
09:55:57 <davidhouse> you're right.
09:56:03 <davidhouse> hmm
09:56:09 <xerox> Idea.
09:56:13 <davidhouse> > let compose [] = ask; compose (f:fs) = local f (compose fs) in runReader (compose [(+1), (*2)]) 3
09:56:14 <lambdabot> 8
09:56:16 <davidhouse> :)
09:56:57 <xerox> Got me :-)
09:57:36 <hyrax42> @localtime Cale 
09:57:37 <lambdabot> Local time for Cale is Sun May 14 12:57:15
09:57:46 <davidhouse> @pl compose (f:fs) = local f (compose fs)
09:57:47 <lambdabot> compose = fix ((`ap` tail) . (. head) . flip ((.) . local))
09:57:59 <xerox> But then you changed compose interface, davidhouse..
09:58:07 <davidhouse> xerox, i know.
09:58:28 <davidhouse> > let compose [] = ask; compose = runReader . compose'; compose' (f:fs) = local f (compose' fs) in compose [(+1), (*2)] 3
09:58:28 <lambdabot>   Varying number of arguments for function `compose'
09:58:28 <lambdabot>   In the definition of `aps':
09:58:28 <lambdabot>    aps = let
09:58:41 <davidhouse> grr.
09:58:49 <davidhouse> @hoogle runReader
09:58:49 <lambdabot> Control.Monad.Reader.runReader :: Reader r a -> r -> a
09:58:49 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
09:59:09 <davidhouse> > let compose [] = ask; compose fs v = runReader (compose' fs) v; compose' (f:fs) = local f (compose' fs) in compose [(+1), (*2)] 3
09:59:09 <lambdabot>   Varying number of arguments for function `compose'
09:59:09 <lambdabot>   In the definition of `slj':
09:59:09 <lambdabot>    slj = let
09:59:23 <davidhouse> > let compose fs v = runReader (compose' fs) v; compose' [] = ask; compose' (f:fs) = local f (compose' fs) in compose [(+1), (*2)] 3
09:59:24 <lambdabot> 8
09:59:31 <davidhouse> (sorry for the spam, folks)
09:59:54 <xerox> Now do one with writer :-)
10:00:28 <davidhouse> heh, that's what i was thinking.
10:03:12 <xerox> That's very straightforward..
10:03:44 <xerox> But no Monad Writer on \bot.
10:06:01 <davidhouse> is Int an instance of Monoid?
10:06:28 <davidhouse> it doesn't appear so.
10:06:32 <davidhouse> well, if it were:
10:06:41 <davidhouse> let compose fs v = snd $ runWriter (tell v >> compose' fs); compose' [] = return 0; compose' (f:fs) = censor f (compose' fs) in compose [(+1), (*2)] 3
10:07:39 <davidhouse> and instance (Num a) => Monoid a where mempty = 0; mappend = (+)
10:07:49 <hyrax42> @hoogle [(a -> b)] -> a -> b
10:07:50 <lambdabot> No matches, try a more general search
10:07:57 <hyrax42> @hoogle [(a -> b)] -> a -> [b]
10:07:58 <lambdabot> No matches, try a more general search
10:08:18 <Cale> instance (Num a) => Monoid a where mempty = 1; mappend = (*)
10:08:19 <hyrax42> @hoogle a -> [(a -> b)] -> [b]
10:08:20 <lambdabot> No matches, try a more general search
10:08:28 <davidhouse> Cale, ah, good point.
10:08:29 <xerox> davidhouse: (a -> a) is a monoid under (.) with identity id :-)
10:08:46 <davidhouse> aha!
10:09:50 <hyrax42> > flip map [(*1), (+3)] id $ 3
10:09:51 <lambdabot> Couldn't match `a -> b' against `[b1]'
10:10:24 <hyrax42> > flip map [(*1), (+3)] \x -> x 3
10:10:24 <lambdabot>  parse error on input `\'
10:11:09 <hyrax42> > flip map [(*1), (+3)] (\x -> x 3)
10:11:10 <lambdabot> [3,6]
10:11:15 <Cale> you can use WriterT Rational [] to automatically keep track of probabilities with the multiplicative monoid
10:11:22 <davidhouse> let compose fs v = (snd $ runWriter (compose' fs)) v; compose' [] = return id; compose' (f:fs) = censor (. f) (compose' fs) in compose [(+1), (*2)] 3
10:11:44 <davidhouse> i think that would work, but ghci says "No instance for (Monoid (b -> c))"
10:12:09 <davidhouse> perhaps return mempty would be a bit prettier.
10:12:16 <davidhouse> but regardless, that's how it'd work.
10:13:00 <xerox> > ((. return) . ap) [(*1),(*3)] 3
10:13:01 <lambdabot> [3,9]
10:13:15 <hyrax42> > liftM ($3) [(*1), (+3)]
10:13:16 <lambdabot> [3,6]
10:13:34 <xerox> @pl ((. return) . ap)
10:13:34 <lambdabot> (. return) . ap
10:13:42 <xerox> @pl liftM . ($)
10:13:42 <lambdabot> fmap
10:13:43 <hyrax42> :t ap
10:13:47 <xerox> ah-ha.
10:13:59 <xerox> Damn different names....
10:14:00 <hyrax42> @type ap
10:14:01 <lambdabot> forall b (m :: * -> *) a.
10:14:01 <lambdabot> (Monad m) =>
10:14:01 <lambdabot> m (a -> b) -> m a -> m b
10:14:31 <jip> > foldl1 (flip (.)) [(+1), (*2)] 1
10:14:32 <lambdabot> 4
10:14:38 <jip> > foldl1 (flip (.)) [(+1), (*2)] 2
10:14:39 <lambdabot> 6
10:14:46 <jip> > foldl1 (flip (.)) [(+1), (*2), (+1)] 2
10:14:47 <lambdabot> 7
10:15:28 <bolrod> > 7
10:15:29 <lambdabot> 7
10:15:33 <bolrod> it really has the same result
10:16:26 <hyrax42> @pl flip (liftM . ($))
10:16:27 <lambdabot> flip fmap
10:16:52 <hyrax42> > flip fmap [(+3), (-2)] 1
10:16:53 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
10:17:02 <hyrax42> back to ghci
10:17:04 <hyrax42> :)
10:20:40 <delinka> pronunciation-  has-KELL or HAS-kul (I really don't know, 's why I'm asking)
10:22:11 <hyrax42> I've been todl rascal
10:22:24 <hyrax42> so umm
10:22:37 <lisppaste2> davidhouse pasted "compose" at http://paste.lisp.org/display/19987
10:22:45 <davidhouse> xerox, ^^
10:23:59 <davidhouse> i am NOT writing one in Cont :)
10:25:11 <xerox> Do!
10:26:32 * davidhouse has never looked at that monad before
10:29:10 <syntaxfree> I just found about the Common Gateway Interface.
10:29:23 <syntaxfree> I never knew I could run compiled Haskell code on a web server. 
10:29:35 <jip> "my name is linux torvalds, and i pronounce 'haskell' as 'haskell'"
10:29:59 <sieni> it's "linux torvaldx"
10:30:19 <syntaxfree> well, is it HASkell or hasKELL?
10:30:39 <syntaxfree> I saw this movie the other day, it had a character named Haskell.
10:30:42 <Maddas> heh, one pronounces capital letters differently? ;-P
10:30:45 <sieni> does anybody have kell around here?
10:30:47 <syntaxfree> Everyone called him Hask, though.
10:30:53 <davidhouse> does does linus pronounce linux?
10:31:16 <syntaxfree> LEEnoox.
10:31:23 <sieni> davidhouse: lee-nux
10:31:33 <resiak> davidhouse: recordings of him saying "Hello! My name is Linus Torvalds, and I pronounce 'Linux' as 'Leenoox'." in English and Swedish are in the source tree.
10:31:41 <davidhouse> weird.
10:31:43 <sieni> davidhouse: not lie-nux
10:31:58 <davidhouse> i've heard "ly-nux" and "lih-nux" before, but never lee-nux.
10:32:01 <syntaxfree> so, can I cross-compile from OS X to Linux with GHC?
10:32:30 <jip> nutch
10:33:01 <sieni> davidhouse: its pronounced as in latin
10:33:31 <neologism> resiak: where?
10:33:41 <Cale> http://www.kernel.org/pub/linux/kernel/SillySounds/english.au
10:34:01 <jip> what do you guys think about this weakness in haskell's type system:
10:34:11 <delinka> re linux: the beauty of *tha* word is that there is no prescribed way to pronounce
10:34:15 <delinka> *that*
10:34:27 <jip> > elem Nothing [Nothing, Just id]
10:34:28 <lambdabot>  add an instance declaration for (Eq (a -> a))
10:34:28 <lambdabot>   In the definition of `hsx': hsx = elem Nothing [Nothing, Just id]
10:34:28 <lambdabot>   In the definition of `fpu':
10:34:32 <neologism> he pronounces his name very strange ;)
10:34:39 <sieni> delinka: yes there is
10:34:42 <araujo> Finnish pronounciation is very similar to Spanish
10:34:50 <Cale> jip: that's sensible
10:35:01 <jip> Cale: you mean it's sensible that haskell doesn't support it?
10:35:06 <Cale> jip: elem requires an Ord dictionary which doesn't exist
10:35:07 <sieni> delinka: actually the swedish pronounciation is different from finnish one
10:35:08 <Cale> yeah
10:35:18 <davidhouse> an Eq dictionary, you mean.
10:35:22 <Cale> er, yes
10:35:30 <davidhouse> hmm
10:35:32 <Cale> @type elem
10:35:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:35:36 <araujo> Linux is pronounced the same way in both languages,
10:35:36 <sieni> the swedish pronounciation has long i and the finnish one has a short i
10:35:39 <jip> Cale: yeah, i understand this, but don't you think that this kind of code could be useful sometimes?
10:35:49 <delinka> sieni: so what's the prescribed pronunciation?
10:36:00 <Cale> > any isNothing [Nothing, Just id]
10:36:00 <lambdabot> True
10:36:14 <neologism> araujo: same in czech
10:36:28 <davidhouse> we could get around that by having a dual instance of Eq for Maybe a: if a instantiates Eq, use a's definition. if not, use Just _ == Just _ = True; Nothing == Nothing = True; _ == _ = False
10:36:29 <araujo> neologism, interesting, 
10:36:30 <vincenz> Cale: would be cool if isXXX were automated for any dataconstructor
10:36:46 <davidhouse> but that could be unpredictable
10:36:49 <syntaxfree> I've heard it's possible to compile valid Linux code from an OS X version of gcc.
10:36:54 <syntaxfree> Is that possible with ghc?
10:36:55 <davidhouse> and would require large changes to haskell's type system.
10:37:00 <sieni> delinka: I'd say the swedish one would be more authentic, since it's linus's native language
10:37:28 <Cale> I don't think I'd want that behavious
10:37:32 <Cale> behaviour*
10:37:46 <delinka> Maddas: maybe you were joking, but with lack of agreement or encoding ability on or of dictionary emphasis symbols, I'm using capitals to indicate primary emphasis
10:38:06 <Cale> If I used the "if not" definition, a later instance could completely change the meaning of me code.
10:38:14 <Cale> my*
10:38:18 <Cale> ugh, can't type :)
10:38:46 <davidhouse> Cale's cockney roots are coming out.
10:38:57 <Cale> hehe
10:38:59 <davidhouse> ;)
10:39:45 <syntaxfree> anyone here runs Haskell code on a web server?
10:41:13 <delinka> syntaxfree: no, but I've done C, Bash scripts... and various other executables
10:41:33 <syntaxfree> I hate PHP. I hate hate hate it.
10:41:44 <syntaxfree> I'm thinking how I can have convenient access to MySQL db's from Haskell, though.
10:41:59 <delinka> is there a CGI lib for Haskell?
10:42:14 <Cale> delinka: yes, in the libraries that come with GHC
10:42:36 <syntaxfree> I was told CGI is a matter of compiling code  that reads from stdin and prints to stdout.
10:42:38 <delinka> btw, did anyone ever way in on pronunciation the channel's language of topic?
10:42:40 <syntaxfree> Is there more to it?
10:43:08 <delinka> nope, that's about it
10:43:14 <eivuokko> syntaxfree, You might need to read enviromnent variables as well ;)
10:43:31 <Cale> http://darcs.complete.org/hdbc/doc/Database-HDBC.html
10:43:32 <delinka> some things are in env vars, some things on the "command line", 
10:43:42 <delinka> syntaxfree: ^^
10:43:43 <Cale> (re: MySQL connectivity)
10:43:53 <syntaxfree> yay! Haskell is being allowed in Google's Summer of Code now?
10:43:55 <Cale> no, you don't need them
10:44:08 <syntaxfree> yay! there is a HDBC lib.
10:44:10 <syntaxfree> Yay! Yay!
10:44:13 <syntaxfree> Yay! Yay!
10:44:14 <Cale> wrapper :: ([(String, String)] -> IO Html) -> IO ()
10:44:15 * syntaxfree jumps up and down.
10:44:42 <Cale> it passes you the environments conveniently merged into one dictionary
10:44:44 <davidhouse> all right, here's a challenge for anyone that feels like it :) write a compose function in Cont. compose should basically take a list of functions and compose them (i.e. compose [(a -> a)] -> (a -> a)).
10:44:57 <davidhouse> see http://paste.lisp.org/display/19987 for the sane example plus examples in other monads
10:44:58 * syntaxfree might soon be free from the shackles of PHP.
10:45:10 <syntaxfree> @where hdbc
10:45:11 <lambdabot> I know nothing about hdbc.
10:45:29 <Cale> http://www.quux.org/devel/hdbc
10:46:06 <Cale> it's also in debian
10:46:07 <xerox> syntaxfree: nice to see you're happy for it, but that means you didn't know before, and you didn't appy? )-:
10:46:19 <Cale> libghc6-hdbc-dev - Haskell Database Connectivity, GHC6 package
10:46:27 <syntaxfree> you mean about the summer of code, or?
10:46:27 <Cale> libghc6-hdbc-odbc-dev - unixODBC HDBC (Haskell Database Connectivity) Driver for GHC
10:46:37 <xerox> Yes, that.
10:46:50 <syntaxfree> ah,well. I'm not ready for one of those projects anyway.
10:47:07 <xerox> syntaxfree: students proposals are very welcome in the programme too.
10:47:08 <davidhouse> @type foldl
10:47:09 <syntaxfree> I'm just a "student". Still, I'm more happy about web/db  haskell programming than about it.
10:47:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:47:33 <hyrax42> @pl \f x -> f x x
10:47:34 <lambdabot> join
10:47:39 <syntaxfree> so, deadlines for the SoC are over,  right?
10:48:03 <xerox> Yes, the 8th, and was extended by two days.
10:48:41 <resiak> > join (+) 1
10:48:43 <lambdabot> 2
10:48:44 <syntaxfree> I want to learn more about writing web apps with Haskell right now.
10:48:44 <resiak> How handy!
10:48:49 <xerox> resiak: indeed!
10:48:58 <davidhouse> it is?
10:49:06 <syntaxfree> what are "bindings"?
10:49:18 * davidhouse doesn't find himself using join very often, especially not like that :)
10:49:35 <hyrax42> @type join
10:49:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:49:44 <davidhouse> let (^) = join (*) in 2 ^ 6
10:49:50 <davidhouse> > let (^) = join (*) in 2 ^ 6
10:49:50 <lambdabot>  add an instance declaration for (Num (t -> a))
10:49:54 <eivuokko> syntaxfree, bindings usually are libraries that offer interface to library in other language
10:50:06 <xerox> syntaxfree: code that lets you use other code written in different languages.
10:50:20 <syntaxfree> what are Haskell to Objective-C bindings, for instance, and how does that help me writing GUI code for OS X in Haskell?
10:50:37 <hyrax42> that's a bit different
10:50:39 <syntaxfree> I see. So I can use a GA lib written in C in Haskell?
10:50:53 <hyrax42> cocoa bindings are a way to quickly get a gui in cocoa apps
10:51:00 <xerox> syntaxfree: that's an interesting matter, HOC misses Cocoa bindings, and with some design ideas one could make up a monad which could let you do GUIS without any lines of code or something.
10:51:06 <davidhouse> > let square = join (*) in square 2 -- yeah, it only works for squared :)
10:51:07 <lambdabot> 4
10:51:14 <davidhouse> > let square = join (*) in square 16
10:51:15 <lambdabot> 256
10:51:34 <xerox> syntaxfree: you could contact Andre Pang for details.
10:51:38 <syntaxfree> i don't understand what forall (m ::  *->*) means in join's type signature.
10:51:49 <resiak> > let ss = join . join (*) in ss 4
10:51:50 <lambdabot>  add an instance declaration for (Show (m a))
10:51:52 <resiak> :=(
10:51:54 <eivuokko> syntaxfree, it's explicit kinds.
10:51:54 <xerox> syntaxfree: that the monad is a type constructor.
10:51:55 <davidhouse> syntaxfree: it means m must have kind * -> *
10:52:01 <xerox> Three explanations :-)
10:52:04 <davidhouse> you can ignore it if you want :)
10:52:23 <syntaxfree> I'm not sure I understand monads yet. 
10:52:37 <hyrax42> @hoogle a -> Int -> [a]
10:52:38 <lambdabot> Prelude.replicate :: Int -> a -> [a]
10:52:49 <syntaxfree> if I recall correctly, [] is a functor between two monads?
10:52:52 <syntaxfree> @type []
10:52:53 <lambdabot> forall a. [a]
10:52:59 <davidhouse> no, [] is a monad.
10:53:03 <syntaxfree> hmm.
10:53:07 <davidhouse> [] is also a functor.
10:53:10 <syntaxfree> @type join
10:53:11 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:53:12 <xerox> syntaxfree: [] is a type constructor, lists are monads, hence functors.
10:53:12 <davidhouse> all monads are functors
10:53:30 <syntaxfree> > let sd = join [] in sd 3
10:53:31 <lambdabot> Couldn't match `[a]' against `t -> t1'
10:53:50 <davidhouse> (in haskell, the Functor class is for functors C -> C where C is the category of haskell types. props to Cale for that :))
10:53:59 <syntaxfree> do functors in Haskell mean the same thing they mean in cat theory?
10:54:47 <davidhouse> if you think of objects as types and arrows as functions, then:
10:54:49 <xerox> Yes.
10:55:04 <Cale> They're endofunctors on the category of Haskell types.
10:55:09 <hyrax42> > let x ^ n = foldr (join (*)) 1 (replicate n x) in 2^8
10:55:10 <lambdabot>  add an instance declaration for (Num (b -> b))
10:55:10 <lambdabot>   In the definition of `hyt':
10:55:10 <lambdabot>    hyt = let ^ x n = foldr (join (*)) 1 (replicate n x) in 2 ^ 8
10:55:16 <hyrax42> hm
10:55:31 * syntaxfree tries to concentrate on just one thing.
10:55:36 <syntaxfree> I think I'll first be learning HDBC.
10:55:39 <davidhouse> an instance of Functor has two types. 1) the type constructor, e.g. [], Maybe, etc. 2) fmap defined on it.
10:55:46 <syntaxfree> so, what would Haskell on Rails do?
10:55:47 <davidhouse> *has two parts
10:55:52 <hyrax42> let (^) = foldr (join (*)) 1 (flip replicate) in 2^8
10:55:53 <syntaxfree> (btw, what does Ruby on Rails do?)
10:56:06 <hyrax42> > let (^) = foldr (join (*)) 1 (flip replicate) in 2^8
10:56:07 <lambdabot> Couldn't match `[b -> b]' against `t -> t1'
10:56:33 <davidhouse> the type constructor takes one type (say, Int) to another ([Int], Maybe Int etc). fmap :: (a -> b) -> (f a -> f b) takes a function and returns a new one.
10:57:58 <syntaxfree> what is a type constructor?
10:58:11 <xerox> A type with kind * -> *.
10:58:15 <syntaxfree> ah, you just said it.
10:58:16 <davidhouse> a bit like a function, apart from it takes one type and returns another.
10:58:25 <delinka> is there an environment variable I need to have set so the compiler can find packages?
10:58:35 <delinka> i mean modules
10:58:48 <xerox> data <TypeConstructor> <type variables> = <DataConstructor> .. | ..
10:58:54 <syntaxfree> so, like, [] is a type constructor because for every a type there's an [a]  type?
10:59:02 <syntaxfree> @type []
10:59:03 <lambdabot> forall a. [a]
10:59:09 <davidhouse> functions take data and return other data. type constructors take types and return other types.
10:59:10 <syntaxfree> let a = [] in a 2
10:59:18 <davidhouse> heh, not quite.
10:59:30 <davidhouse> because 2 is data, not a type.
10:59:38 <davidhouse> in pseudocode, it'd be let a = [] in [] Int
10:59:46 <syntaxfree> type constructors still sound like functions in the mathematical sense.
10:59:49 <xerox> [] is a DataConstructor too.
10:59:51 <davidhouse> (incidentally, [] Int is a synonym for [Int])
11:00:04 <davidhouse> xerox, yes, but it takes no arguments.
11:00:04 <syntaxfree> and Data Constructors are?
11:00:07 <xerox> syntaxfree: it means that [2] :: [Int]<Interrupted by davidhouse>
11:00:28 <davidhouse> data constructors take data, and return new data.
11:00:28 <sjanssen> I think type constructors are functions from type to type, is that right?
11:00:34 <davidhouse> data constructors are basically functions.
11:00:37 <davidhouse> sjanssen: right.
11:00:45 <syntaxfree> hmm. Succ is a data constructor.
11:00:53 <davidhouse> data Foo = Bar String. now, Bar is a function String -> Foo
11:01:15 <shapr> Interrupted by davidhouse?
11:01:17 <davidhouse> syntaxfree: if you go for the peano definition of the naturals as Natural = Zero | Succ Natural, then yes.
11:01:28 <syntaxfree> but who wrote Succ?
11:01:31 <sjanssen> syntaxfree: certain names are both type constructors and data constructors
11:01:33 <davidhouse> no-one.
11:01:36 <syntaxfree> Is Succ defined in terms of (+1) anywhere?
11:01:44 <davidhouse> i doesn't have a function body anywhere.
11:01:51 <davidhouse> they are simple wrappers.
11:01:52 <xerox> data Nat = Zero | Succ Nat
11:02:00 <syntaxfree> can you write a new data constructor?
11:02:07 <davidhouse> sure.
11:02:10 <davidhouse> data Foo = Bar String
11:02:16 <davidhouse> Bar is a new data constructor.
11:02:18 <syntaxfree> say, I want to have a type that's Ordering.
11:02:29 <syntaxfree> wait, wait.
11:02:38 <davidhouse> however, you can never DEFINE Bar in the sense that you can't say Bar s = ...
11:02:40 <syntaxfree> data Foo = Bar String means what, Foo becomes a type?
11:02:49 <davidhouse> Foo is a type, yes.
11:02:54 <davidhouse> and Bar is a data constructor.
11:02:56 <xerox> It defines Bar :: String -> Foo
11:03:03 <syntaxfree> and how do I know what's the behaviour of Bar?
11:03:10 <davidhouse> it's a simple wrapper
11:03:13 <xerox> Which is just a function
11:03:15 <syntaxfree> a wrapper for?
11:03:20 <xerox> But a different function from the usual ones
11:03:22 <davidhouse> it'll take a string and return that string in a Foo.
11:03:25 <xerox> In the sense that you can pattern match it.
11:03:32 <davidhouse> yep.
11:03:45 <davidhouse> every data with type Foo remembers what was used to construct it,
11:03:51 <davidhouse> so you can pattern match.
11:04:05 <syntaxfree> so, theoretically, Succ is defined like data 1 = Succ Zero, data 2 = Succ 1, etc?
11:04:22 <davidhouse> no.
11:04:33 <sjanssen> depends on your defn. of Succ
11:05:12 <syntaxfree> I can't find a Haskell guide that's not either "write quicksort in haskell, look how cool" or abstract academic stuff I can't begin to parse because I can't begin my way into abstract Haskell theory.
11:05:18 <davidhouse> data X = A | B. X is a _type_.
11:05:23 <syntaxfree> Yes.
11:05:30 <syntaxfree> data Color = Red | Yellow | Green | Blue 
11:05:32 <syntaxfree> is a type.
11:05:37 <davidhouse> so data 1 doesn't make sense, because 1 isn't a type.
11:05:50 <syntaxfree> so I can have a function "f :: Color -> Color"
11:05:58 <davidhouse> right.
11:05:58 <syntaxfree> or say, "g :: Color" and "g = Blue"
11:06:00 <davidhouse> let's have an example.
11:06:10 <xerox> @oldwiki HaskellDemo
11:06:10 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
11:06:13 <davidhouse> data Color = Red | Yellow | Blue | Custom (Int, Int, Int)
11:06:17 <xerox> That has good syntax examples.
11:06:20 <syntaxfree> Hawiki became the old wiki?
11:06:41 <syntaxfree> God, I'm gonna miss it. I love CamelCase wikis :~
11:07:04 <davidhouse> that defines four data constructors. Red :: Color; Yellow :: Color; Blue :: Color; Custom :: (Int, Int, Int) -> Color
11:07:26 <syntaxfree> hmm. So a data constructor basically says "Red is a case of Color" .
11:07:34 <davidhouse> yeah.
11:07:41 <syntaxfree> a data constructor has no behaviour.
11:07:48 <davidhouse> nope.
11:07:55 <davidhouse> if you want a Color, you have to create it with one of those constructos.
11:08:19 <davidhouse> as such, every piece of data of type Color can (and does) "remember" which constructor was used to create it
11:08:28 <syntaxfree> so how does Succ relate to that?
11:08:35 <jip> should i try to get rid of all -Wall warnings, or are they ok?
11:08:54 <davidhouse> Succ is complicated because it's recursive. let's stick with Color for now.
11:09:23 <syntaxfree> I understand recursive functions. I'm not sure how something without behaviour can be recursive.
11:09:30 <syntaxfree> Well, how does that relate to Maybe, then?
11:09:33 <davidhouse> so you can do what's called pattern-matching. if you have a :: Color, then you can do case a of Red -> something; Blue -> something; Yellow -> something; Custom (r, g, b) -> something r g b
11:09:51 <resiak> ITYM somethingElse r g b
11:09:52 <syntaxfree> hmm, wait, wait.
11:10:03 <davidhouse> yes, sorry resiak.
11:10:26 <syntaxfree> case of a Red-> something, etc. is a function?
11:10:42 <davidhouse> err
11:10:50 <sjanssen> syntaxfree: it's an expression
11:11:00 <davidhouse> we're deciding what to do based on which constructor created a.
11:11:01 <syntaxfree> as in, "brighenUp Color = case a of Red -> Yellow; somethingElse (r,g,b) = (r+1, g+1, b+1)?
11:11:10 <davidhouse> no.
11:11:15 <syntaxfree> oops.
11:11:19 <syntaxfree> brightenUp color.
11:11:23 <syntaxfree> not Color. Color is a type.
11:11:27 <syntaxfree> color is a variable with type Color.
11:11:32 <davidhouse> "brighenUp color = case color of Red -> Yellow; Custom (r,g,b) -> Custom (r+1, g+1, b+1)"
11:11:42 <syntaxfree> @type color
11:11:43 <lambdabot> Not in scope: `color'
11:11:45 <syntaxfree> color :: Color
11:11:58 <syntaxfree> type brightenUp is Color->Color
11:12:01 <davidhouse> yep.
11:12:17 <syntaxfree> oh, ok. I can grok that.
11:12:27 <davidhouse> you get pattern matching?
11:13:00 <syntaxfree> yes. 
11:13:10 <davidhouse> cool. :)
11:13:15 <syntaxfree> So, if I want all colors specified in terms of RGB, I create a type called Color with
11:13:21 <syntaxfree> data Color = (Int, Int, Int)?
11:13:26 <davidhouse> almost.
11:13:40 <davidhouse> you still need a data constructor, so data Color = ColorConstructor (Int, Int, Int)
11:13:58 <syntaxfree> where ColorConstructor is just a word we made up right now.
11:14:06 <davidhouse> right.
11:14:19 <davidhouse> in simple cases like this it's actually common to do one of two things:
11:14:21 <syntaxfree> and then if I want a variable of type color, I have to write it as 
11:14:31 <syntaxfree> pink = ColorConstructor(100,0, 100)
11:14:37 <davidhouse> exactly.
11:14:52 <syntaxfree> and that's why []  is a data constructor.
11:14:55 <syntaxfree> Umm. Nice.
11:14:57 <jip> anyone have any ideas how i can factor out the common parts in this code:
11:14:58 <jip> http://rafb.net/paste/results/nkdf3016.html
11:15:12 <davidhouse> syntaxfree: precisely :)
11:15:37 <syntaxfree> what if I need colors to be less than or equal to 256?
11:15:52 <syntaxfree> I mean, how do I create a type IntUpto256?
11:16:00 <davidhouse> hmm. tricky.
11:16:02 <sjanssen> syntaxfree: there's already Word8
11:16:07 <syntaxfree> oh ok!
11:16:15 <sjanssen> in Data.Word I believe
11:16:35 <syntaxfree> the idea of custom types is  not quite passing on behaviour to the type system,  but constraining what your functions can do.
11:16:43 <jip> > 257::(Data.Word.Word8)
11:16:44 <lambdabot> 1
11:17:17 <syntaxfree> it's like stating a theoretical model formally.
11:17:28 <delinka> Philippa?
11:17:43 <syntaxfree> "Let an economy be a triple of vectors (y, x, w) with y>>0, w>0", etc.
11:17:54 <syntaxfree> still, there's some behaviour in there.
11:18:09 <sjanssen> syntaxfree: you can't have those sort of constraints in the type system
11:18:23 <syntaxfree> unless there's already a PositiveInt type.
11:18:36 <davidhouse> yeah, because data constructors have no behaviour you can't place limitations like that.
11:18:48 <sjanssen> you'd actually need a GreaterThanZeroInt type
11:19:01 <syntaxfree> yes. NonnegativeInt.
11:19:04 <davidhouse> positive means greater than zero.
11:19:23 <davidhouse> nonnegative means greater than or equal to zero.
11:19:30 <jip> data PositiveInt = One | Succ PositiveInt
11:19:44 <davidhouse> 1.5 :P
11:19:44 <syntaxfree> One is a prebuilt data constructor?
11:19:56 <jip> no
11:20:13 <syntaxfree> hmm. I don't get Succ yet.
11:20:16 <sjanssen> One is a data constructor tht takes no arguments
11:20:23 <syntaxfree> Succ is  behaviourless.
11:20:35 <davidhouse> syntaxfree: so Succ (Succ Zero) is 2.
11:20:44 <syntaxfree> so I can have, uh, data Grey = Black | Succ Black ? 
11:20:51 <davidhouse> Succ (Succ (Succ (Succ Zero))) is 4.
11:21:02 <jip> syntaxfree: yeah
11:21:03 <davidhouse> succ is short for sucessor.
11:21:10 <sjanssen> syntaxfree: if you did, that second black would refer to a type con, not a data con
11:21:13 <davidhouse> jip, huh? no you can't
11:21:14 <jip> syntaxfree: i mean no
11:21:22 <syntaxfree> Succ composition is just an abstract, peano-like definition of integers.
11:21:27 <jip> data Grey = Black | Succ Grey
11:21:28 <davidhouse> yep.
11:21:42 <sjanssen> actually, that definition of Succ is quite concrete
11:21:58 <syntaxfree> not quite a behaviour. For one, if MyInt :: Zero | Succ MyInt 
11:21:59 <Cale> you could have data Grey = Black | Succ Black, if you had a type called Black
11:22:12 <syntaxfree> then it's hard to write a function of type MyInt -> Int
11:22:17 <Cale> it would be a confusing way to name things though
11:22:19 <davidhouse> indeed. types and data constructors can share names.
11:22:20 <syntaxfree> that merely gives me an Int I can  use with ordinary Int functions!
11:23:01 <jip> syntaxfree: you just recurse over your MyInt type and count how many iterations you have
11:23:02 <davidhouse> you'd need something like:
11:23:15 <jip> myInt One = 1
11:23:28 <davidhouse> myIntToInt Zero = 0; myIntToInt (Succ n) = 1 + myIntToInt n
11:23:29 <jip> myInt Succ n = 1 + myInt n
11:23:40 <syntaxfree> hmm.
11:23:44 <davidhouse> parentheses, jip.
11:23:51 <jip> yeah, i think i need sleep
11:23:58 <syntaxfree> it seems to be that it adds a lot of unnecessary work.
11:24:00 <davidhouse> syntaxfree: that (Succ n) in brackets is pattern matching again.
11:24:19 <jip> anyway, did someone see the code i pasted?
11:24:23 <syntaxfree> for one, why would I specify colors in terms of Color where Data Color = RGB (Int, Int, Int), and then not be able to use tuplet functions?
11:24:42 <syntaxfree> and have to define red :: Color -> Int and so on.
11:24:50 <davidhouse> right.
11:24:54 <davidhouse> there are two solutions to this.
11:24:56 <syntaxfree> by the way, how would I define red :: Color -> Int?
11:25:06 <davidhouse> red (r, _, _) = r
11:25:09 <davidhouse> oops
11:25:15 <davidhouse> red (RGB (r, _, _)) = r
11:25:28 <davidhouse> but anyway, the better ways of doing things:
11:25:58 <jip> why aren't record fields more high order?
11:25:58 <davidhouse> type Color = (Int, Int, Int). now Color is a _type synonym_ for a triple of ints. they're exactly the same thing, and completely interchangeable.
11:26:14 <sjanssen> jip: one minor thing: you can take the just and the lambda outside of the case
11:26:18 <davidhouse> so that then you could use your tuple functions on Color.
11:26:24 <davidhouse> the other solution is a _record_:
11:26:56 <jip> sjanssen: i can't take the Just out, since there are other cases that do Nothing. not sure what you mean about the lambda
11:26:56 <davidhouse> data Color = RGB { red :: Int, green :: Int, blue :: Int }. this sets up three functions that take a Color and give you an Int.
11:27:28 <davidhouse> so you can do color = RGB { red = 127, green = 127, blue = 0 }
11:27:44 <davidhouse> then "red color" would be equal to 127.
11:27:46 <sjanssen> jip: there are more cases than what's in the paste?
11:27:57 <jip> sjanssen: yes
11:28:00 <syntaxfree> oh, records are good!
11:28:34 <jip> records could be better :\
11:29:02 <davidhouse> yeah. the problem is that you can never have another function called 'red'.
11:29:41 <davidhouse> it's all right for RGB, but imagine an HTML type: data HTML = HTMLDocument { header :: String, body :: String }
11:29:43 <syntaxfree> a possible solution would be having records define not functions, but somrthing like color.red
11:30:05 <davidhouse> you can never use the common function names "header" and "body" again.
11:31:29 <syntaxfree> unless you define your records in a separate module, so they don't share namespaces.
11:31:37 <vincenz> sjanssen: aloha
11:31:38 <syntaxfree> HTMLlib.header myhtmldoc sounds ok.
11:32:06 <sjanssen> vincenz: hello
11:32:49 <syntaxfree> ok. One more question.
11:33:01 <syntaxfree> I hope I'm bein just a moderate bore.
11:33:14 <syntaxfree> how exactly do types inherit behaviour from the "deriving" keyword?
11:33:17 <hyrax42> > \ -> 10
11:33:18 <lambdabot>  parse error on input `->'
11:33:27 <syntaxfree> say, in data Color = RGB (Int, Int, Int) deriving Show
11:34:28 <sjanssen> syntaxfree: it's built in compiler magic.  You can only derive a few special classes and the report specifies how these classes are derived
11:34:42 <syntaxfree> oh, ok.
11:34:52 <sjanssen> (the report meaning the Haskell Report, the standard definition of the language)
11:34:57 <hyrax42> but according to YAHT there's work on making it possible for any class?
11:35:01 <syntaxfree> so there's no way to specify deriving behaviour for custom type classes.
11:35:09 <hyrax42> polytypic and generic programming I think it said
11:35:56 <sjanssen> syntaxfree: there's a preprocessor called DrIFT that can derive other classes, but it's not quite the same
11:36:16 <syntaxfree> Hmm. So, Nothing and Just are just words?
11:36:33 <syntaxfree> like in data Maybe = Just a | Nothing?
11:37:18 <sjanssen> not sure what you mean - that data declaration defines Just and Nothing as data constructors
11:37:21 <davidhouse> they're data constructors for the type Maybe a.
11:37:31 <syntaxfree> yes, but they are behaviourless.
11:37:36 <sjanssen> yes
11:37:43 <syntaxfree> there's nothing magical about Just and Nothing.
11:37:47 <syntaxfree> how is Just defined?
11:37:54 <davidhouse> it isn't.
11:37:56 <sjanssen> syntaxfree: exactly how you wrote
11:38:06 <syntaxfree> data Just = Just a ?
11:38:10 <vincenz> hmm
11:38:12 <davidhouse> data Maybe a = Just a | Nothing. that's a complete and full definition of Just.
11:38:19 <vincenz> any ghc'ers around?
11:38:19 <syntaxfree> oh, true.
11:38:21 <vincenz> Lemmih: ping
11:38:22 <syntaxfree> yeah,yeah.
11:38:25 <davidhouse> syntaxfree: no, Just is a data constructor, not a type.
11:38:34 <syntaxfree> yes, I just understood.
11:38:36 <syntaxfree> Um. 
11:38:48 <davidhouse> okay :)
11:38:51 <syntaxfree> I'm trying to compile all that information into my brain.
11:38:51 <sjanssen> > Just "understood"
11:38:52 <lambdabot> Just "understood"
11:39:03 <davidhouse> the 'a' there is a type variable. it can stand for any type.
11:39:04 <vincenz> syntaxfree: use lazy evaluation
11:39:15 <jip> sjanssen: what do you think about this?
11:39:15 <davidhouse> for example, you can have a Maybe Int. here a = Int.
11:39:16 <jip> http://rafb.net/paste/results/AjbEyt83.html
11:39:23 <joe_k> I think the key thing about Just and Nothing is how they behave in the Maybe monad (i am new to haskellso I may be wrong)
11:39:40 <syntaxfree> the weird thing is that "|" introduces behaviour of some sort.
11:39:49 <syntaxfree> data Bool = True | False 
11:39:59 <syntaxfree> means that Bool can only be True or False, not "Dunno".
11:40:25 <hyrax42> so Maybe a can only be Nothing or Just (x::a)
11:40:35 <syntaxfree> data Judgement = True | False | Dunno 
11:40:59 <syntaxfree> or data Judgement = Bool a | Dunno?
11:41:00 <sjanssen> jip: that looks pretty good.  if you wanted to reduce it just a bit you could have setFst, setSnd, setThird, setFourth ...
11:41:02 <syntaxfree> is that possible?
11:41:11 <sjanssen> but that wouldn't be a big win unless you have a lot of code like this
11:41:13 <syntaxfree> oops. data Judgement = Bool | Dunno?
11:41:21 <vincenz> syntaxfree: nope
11:41:23 <davidhouse> almost possible.
11:41:25 <sjanssen> and it'd have to be restricted to 6 tuples
11:41:30 <vincenz> data Judgment= AJudgement Bool | Dunno
11:41:30 <hyrax42> Bool Bool | Dunno would work
11:41:33 <davidhouse> data Judgement = Decision Bool | Dunno
11:41:40 <syntaxfree> ah, yes.
11:41:57 <syntaxfree> hmm. That stuff sounds good for AI.
11:42:17 <syntaxfree> I wonder why AI people stick to weakly typed languages like Lisp.
11:42:32 <sjanssen> like anything else: history
11:42:37 <joe_k> list is dynamically typed, not weakly typed
11:42:43 <joe_k> vb is weakly typed
11:42:47 <joe_k> er, lisp
11:42:50 <hyrax42> :t (//)
11:42:56 <hyrax42> @type (//)
11:42:57 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
11:43:03 <jip> sjanssen: i still feel that it's way to much boilerplate code though :\
11:43:11 <syntaxfree> just so I understand, Python is dynamically typed  but not weakly typed, right?
11:43:16 <joe_k> right
11:43:21 <syntaxfree> so I can't just say 2/3, I have to say 2.0/3.0
11:43:33 <syntaxfree> if I expect 0.667 anyway.
11:43:42 <joe_k> well, 2/3 will return an int because int division returns an int in python
11:43:47 <joe_k> yes
11:43:50 <sjanssen> jip: have you considered a record instead of a tuple?
11:44:03 <joe_k> TCL, vb, and such represent everything as strings.... all types are strings
11:44:12 <joe_k> sorry i may mean vbscript and not vb
11:44:27 <jip> sjanssen: don't think it will help enough
11:44:29 <syntaxfree> it's weird to think of behaviourless code as important.
11:44:54 <jip> all of haskell is "behaviourless"
11:44:58 <syntaxfree> even having gotten to understand lazy evaluation and purely functional programming.
11:45:17 <jip> haskell functions can be considered "behaviourless"
11:45:18 <sjanssen> jip: you could write "Just (\x -> x {right = True})", with the right data declaration
11:45:34 <syntaxfree> inc = (+1) is behaviourful.
11:45:47 <joe_k> maybe functions can be considered just substitution templates
11:45:48 <Cale> syntaxfree: it is? 
11:45:51 <syntaxfree> Even if it waits until being called before "doing" something.
11:45:57 <syntaxfree> It's frozen behaviour.
11:46:12 <Cale> syntaxfree: I suppose it depends on what you consider to be 'behaviour'
11:46:13 * syntaxfree 's brain hurts.
11:46:28 <syntaxfree> it's weird to disconnect from the idea that code does something.
11:46:43 <Cale> I look at that as a declaration that declares 'inc' to be the (+1) function.
11:46:46 <syntaxfree> Haskell code comes close to be an ontology in the philosophical meaning of the word.
11:46:55 <syntaxfree> it doesn't "do" anything, it just says what there is.
11:47:00 <Cale> yeah
11:47:13 <jip> sjanssen: yeah, but that won't really shorten my code a lot. i think i'll just stick to what i have now, it's not too bad
11:47:30 <syntaxfree> Maybe functions _are_ behaviourless, but they're propertyful.
11:47:51 <syntaxfree> Data constructors are propertiless, and the only behaviour they induce on types is "|".
11:48:07 <syntaxfree> That is preeeetty wicked. I don't know how Reals can be constructed in terms of Haskell yet, for instance.
11:48:38 <sjanssen> syntaxfree: Double is defined in terms of compiler primitives
11:48:38 <syntaxfree> s/behaviour/property, anyway.
11:48:44 <Cale> Well, real reals are pretty tough. Arbitrary precision floating point values wouldn't be so hard.
11:48:44 <joe_k> do you mean floats? i dont know of a good way for computers to represent Real numbers
11:48:55 <syntaxfree> so, say I was to introduce random variables into Haskell.
11:48:58 <jip> data Real = Real Int Int
11:49:04 <joe_k> thats Rational
11:49:07 <jip> oh right
11:49:11 <sjanssen> but you could always express Doubles as a 64 tuple of Bool's
11:49:20 <syntaxfree> Random variables as in a distribution function that yields the probability of X<=x
11:49:21 <joe_k> or a mantissa part and an exponent part
11:49:23 <Cale> To get *actual* Real numbers, you'd basically have to represent them as theorems.
11:49:26 <joe_k> and a flags part
11:50:10 <joe_k> syntaxfree: i definitely want to represent distributions in my calculations.... but I dont know if there is an algebra that looks like arithmetic on distributions
11:50:20 <joe_k> you can definitely do it with intervals
11:50:57 <joe_k> damn I would LOVE to have a statistical distribution type that I can throw in my existing PK code ;)
11:51:07 <Cale> joe_k: do you want exact arithmetic on them, or approximate?
11:51:09 <joe_k> as it is I will have to do monte carlo on the distributions of the input vars
11:51:15 <syntaxfree> I don't need to get down to sigma-algebras to represent most of probability theory on a computer. Just define probability on borelians and use the probability axioms.
11:51:37 <Cale> You could just represent them as pdf's.
11:51:40 <syntaxfree> at one point you get that P(0<X<2) = P(X<2) - P(X<0), and.
11:51:59 <syntaxfree> density functions are icky because computer numbers aren't continuous.
11:52:20 <tic> c
11:52:40 <syntaxfree> accumulated distribution functions are much more comfortable in that sense.
11:52:56 <Cale> I suppose so, yeah
11:53:39 <hyrax42> what does the (//) operator do
11:54:05 <syntaxfree> I think there's more bang for the buck in having Haskell think over continuous variables and convert to/from discrete numbers as needed.
11:54:11 <Saulzar> hyrax42, Array element update
11:54:19 <astrolabe> @type (//)
11:54:20 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
11:54:27 <syntaxfree> that's the best way to benefit from lazy evaluation, I think.
11:54:48 <syntaxfree> For instance,  it's possible to compute the distribution function of a function of random variables.
11:55:02 <joe_k> we may need to talk syntaxfree ;)
11:55:22 <palomer> Ix == Indexable?
11:55:23 <syntaxfree> I was DiegoNavarro on the so-called "old wiki".
11:55:28 <syntaxfree> It's a shame it was retired.
11:55:32 <joe_k> i dont know much probability and dont know how these operations on distributions would go
11:55:52 <Saulzar> palomer, index type - Int is Ix
11:55:57 <syntaxfree> there's a great measure-theory-less book by Barry James.
11:56:08 <syntaxfree> Unfortunately,  it was written during his stay in Brazil and it's in portuguese.
11:56:37 <syntaxfree> AFAIK, the standard manual in (Kolmogorov-tradition) probability theory is Shiryaev & Boas.
11:57:00 <tennin> I didn't really see why a new wiki was needed
11:57:05 <syntaxfree> maybe Cox-tradition probability theory is even more tractable to Haskell as it takes conditional events as primitives, but I don't know much about it.
11:57:48 <syntaxfree> anyway, Shiryaev & Boas is a book that'll require measure theory.
11:58:12 <cyyoung> look at IBAL in ocaml
11:58:16 <syntaxfree> though I don't know how far you can go without  measure theory in probability anyway. Barry James purports to be free from measure theory, but when I look back I ended up learning a lot of ad hoc measure.
11:58:53 <syntaxfree> aand worse yet, I don't know what the heck I'm doing when I take Radon-Nikodym derivatives.
11:58:59 <cyyoung> http://www.eecs.harvard.edu/~avi/IBAL/tutorial/index.html
12:00:06 <syntaxfree> um, back to my Haskell brain  rewiring, let's say I define the sum of two colors (r,g,b) as (r1+r2/2, g1+g2/2, b1+b2/2)
12:00:15 <syntaxfree> add parentheses there ;)
12:00:54 <syntaxfree> anyway. Can I get the `+` operator to behave on colors (data Color = RGB (Int, Int, Int)) like that?
12:01:37 <syntaxfree> I ask that because it would be nice to be able to use "sum" and all. 
12:02:01 <Saulzar> syntaxfree, If you make Color an instance of Num
12:02:13 <syntaxfree> hmm.  how?
12:03:02 <Saulzar> instance Num Colour where
12:03:13 <Saulzar>  (Colour ...) + (Colour ...) = ...
12:03:14 <vincenz> Cale: do you think they'll ever have something like deriving :  data Foo a = X a | Y ... | Z ... deriving (Checkable) with automatic generation of isX, isY, isZ
12:03:17 <syntaxfree> where (+) col1 col2 = ?
12:03:20 <syntaxfree> or that.
12:03:24 <Saulzar> Right
12:03:34 <syntaxfree> I wonder if sum is defined in terms of + :~
12:03:37 <vincenz> cyyoung: what is IBAL?
12:03:57 <Saulzar> syntaxfree, It is
12:04:04 <cyyoung> it was for syntaxfree above, it's a pretty good probabilitistic reasoner
12:04:25 <cyyoung> IBAL is a general-purpose probabilistic modeling language. It is built on the simple idea that writing a probabilistic model should be as easy as writing a simulator. If you can write a stochastic simulation of your domain, IBAL will apply probabilistic reasoning techniques to compute a probability distribution over the results of the simulation. An IBAL model looks like a computer program with stochastic branches. The program defi
12:04:25 <cyyoung> nes the simulation process by which outputs are generated. Rather than simply running the simulation to generate a particular output, IBAL allows you to compute a probability distribution over the program outputs.
12:04:59 <vincenz> cyyoung: I mean what does IBAL stand for
12:05:02 <syntaxfree> um, these recursive data types do have a lot of  behaviour. What's scarier, they do that with behaviorless data constructors.
12:05:07 * syntaxfree 's head explodes.
12:05:27 <Saulzar> vincenz, DriFT handles all kinds of stuff like that, also TH can be used to do such things
12:05:45 <vincenz> Saulzar: true but it hardly seems complex enough to force TH
12:05:59 <vincenz> Saulzar: TH requires the compilation of a preprocessor which then parses your code?
12:06:02 <cyyoung> Integrated Bayesian Agent Language...it has types for distributions over finite sets
12:06:26 <Saulzar> vincenz, Not sure - I thought it just interpreted it
12:06:31 <vincenz> Saulzar: I mean... like camlp4 where you first make the preprocessor then compile your normal code with some option that sends it through the precompiler
12:06:48 <joe_k> holy shit i worked 82.5 hours this week
12:06:58 <vincenz> joe_k: o.O
12:07:01 <vincenz> joe_k: how did you measure that?
12:07:13 <joe_k> our time entry application
12:07:15 * Saulzar sums up the total hours in a week.
12:07:23 <vincenz> > 7* 24
12:07:24 <lambdabot> 168
12:07:32 <joe_k> we, last week since today is sunday
12:07:34 <syntaxfree> > 82.5 / 168
12:07:35 <lambdabot> 0.49107142857142855
12:07:37 <joe_k> s/we/er/
12:07:47 <Saulzar> Hmm, I'm not awake a lot more than 82 hours each week :)
12:07:51 <vincenz> joe_k: afaict, weeks start on monday
12:07:55 <vincenz> Saulzar: ditto
12:08:06 <syntaxfree> > 82.5 / 7
12:08:07 <lambdabot> 11.785714285714286
12:08:15 <joe_k> yeah thats about right
12:08:23 <syntaxfree> I'm usually awake from 8 to 2 am.
12:08:24 <joe_k> i am working on site out of town so it adds up
12:08:31 <syntaxfree> that is, uh, 18 hors.
12:09:00 <Saulzar> I envy those who can sleep for 6 hours and still stay sane
12:09:28 <syntaxfree> I'm not sure I'm quite sane.
12:09:55 <vincenz> o.O
12:09:56 <syntaxfree> from those 18 hours, about 6 or 7 are pure leisure, generally with my girlfriend.
12:09:56 <joe_k> aw dang that means since tomorrow is payday I wont get my overtime bonus for two weeks
12:10:04 <vincenz> how the f*ck can you sleep less than 8 hours
12:10:05 <syntaxfree> about 8 are spent at school.
12:10:14 <syntaxfree> (Graduate school, too)
12:10:40 <syntaxfree> I cram school  work and my own personal learning endeavours in the remaining 4 hours.
12:10:42 <shapr> I've discovered I'm best with 6h 45m of sleep.
12:10:52 <vincenz> shapr: and how many seconds?
12:10:56 <davidhouse> wow.
12:11:02 <davidhouse> i can't live on less than 9.
12:11:06 * Saulzar is best with 9 or 10
12:11:07 <vincenz> davidhouse: ditto
12:11:11 * davidhouse needs his sleep
12:11:12 <vincenz> Saulzar: ditto
12:11:14 <jip> i have slept for exactly 5.5 hours consistently every night for the last year
12:11:20 <syntaxfree> I'm best with 14, but I also want to live.
12:11:24 <vincenz> jip: do you excercise?
12:11:26 <eivuokko> For me it's like 6h 15-20m, but it kinda also depends how much other relaxing I do.
12:11:30 <jip> vincenz: yeah, quite a bit
12:11:35 <Saulzar> syntaxfree, Haha. Very true.
12:11:36 <vincenz> jip: ah I think that explain
12:11:41 <vincenz> jip: I think exercise leads to less sleep
12:11:47 * vincenz should start exercising
12:11:56 <jip> every morning, after waking i do a 90 minute jog and then a pretty heavy workout
12:11:58 <vincenz> of course it's a tradeoff
12:12:02 <joe_k> I am 99.2% billable for this year.... thats going to look good at yearly review time
12:12:08 <syntaxfree> JESUS. 90 minutes of exercise.
12:12:10 <psi> if I sleep 5-6 hours a night, eventually I start falling asleep during the days
12:12:11 <vincenz> amount of time lost for sleep vs amount of time lost to exercise
12:12:13 <syntaxfree> My schedule doesn't allow for that.
12:12:20 <vincenz> psi: I just don't get up, period
12:12:20 <syntaxfree> Though I walk a heck of a lot to save on bus fares.
12:12:29 <jip> just the running is 90 minutes, entire workout is about 2.5 hours
12:12:39 <vincenz> jip: student?
12:12:40 <shapr> I can't sleep more than 7.5 hours a night and stay sane.
12:12:49 <jip> vincenz: soldier
12:12:54 <vincenz> jip: ah, that might explain
12:12:56 <vincenz> ;)
12:12:56 <syntaxfree> I never got any oversleeping-related insanity episodes.
12:13:01 <vincenz> jip: what army?
12:13:10 <jip> vincenz: israel defense forces
12:13:11 <psi> too much sleep makes me extremely lazy
12:13:25 <Saulzar> Hmm.. I'm not don't think it makes so much difference. Earlier this year I did plenty of exercise. Now I've done my arm in and it's about the same.
12:13:31 <vincenz> jip: so you can kill someone with one hand tied behind your back and your feet bound together?
12:13:36 <shapr> I also must exercise to stay sane. One hour a day is minimum, two hours a day is good, more is better.
12:13:41 <jip> vincenz: yes
12:13:47 <Saulzar> psi, Yeah - definately.
12:13:48 <psi> if I wake up, say, 1 or 2pm I rarely get anything done
12:14:05 <syntaxfree> One daily hour of exercise for me means no Haskell.
12:14:08 <vincenz> psi: me too, but if I go to sleep late, I can't not wake up that late
12:14:14 <syntaxfree> I have other interests and activities too.
12:14:20 <jip> vincenz: go for it
12:14:41 <jip> vincenz: #vincenz
12:14:51 <psi> vincenz: I find it better to catch just a few hours, and make up for it later :)
12:15:02 <vincenz> psi: how do you mean?
12:15:02 <tic> exercise.. wish I had the mental time to do that. :|
12:15:18 <shapr> When you don't have the choice, it gets a lot easier.
12:15:33 <joe_k> einstein was a proponent of the "sleep a few times a day when you're tired" theory
12:15:34 <syntaxfree> As I said, I do walk a lot to save on bus fares.
12:15:38 <syntaxfree> But that's not constant.
12:15:40 <psi> vincenz: even if I'm up very late I don't like to wake up in the middle of the day
12:15:41 <joe_k> instead of rigidly scheduling your 8 hours per night
12:15:59 <vincenz> joe_k: did you read that blog of the guy that did 15 minute naps every 2 hours?
12:16:00 <syntaxfree> Sometimes I'll have to walk for one hour one day of the week and the rest of the week I get no exercise.
12:16:03 <Saulzar> psi, Trouble is you then make up for it by having your head on the desk for the next day and do nothing at all...
12:16:07 <vincenz> psi: true but the problem is that I just can't get up
12:16:07 <psi> vincenz: so I catch just a few hours, and go to bed earlier the next day
12:16:16 <vincenz> psi: I just have issues with getting up
12:16:18 <syntaxfree> joe_k: I wish I could do that.
12:16:20 <joe_k> vincenz: no, sounds interesting
12:16:21 <vincenz> I wish I could find a way to fix that
12:16:28 <syntaxfree> joe_k: I'm interested in the rest of the world, though.
12:16:30 <psi> Saulzar: it can be cured with lots of caffeine :)
12:16:38 <Saulzar> vincenz, I think the only way is to have a job with compulsory schedule
12:16:56 <Saulzar> vincenz, Otherwise I'll revert to 25 hour time clock
12:16:56 <vincenz> Saulzar: hmm... dunno, I used to work as consultant and get there late :
12:17:01 <vincenz> :/
12:17:12 <vincenz> they weren't too happy with that, tho my work quality made up for it
12:17:19 <Saulzar> Hehe.
12:17:25 <vincenz> but no
12:17:30 <vincenz> I think I need a strictly disciplined schedule
12:17:35 <vincenz> and fix in some excercise somewhere
12:17:40 <vincenz> it's just that I don't like sports :/
12:17:43 <vincenz> and I'm a lazy sob
12:18:16 <psi> vincenz: getting up is the toughest part, true. I can't say I know any tricks to do better...
12:18:30 <tic> I used to work out a *lot* before.. just lost the passion(?) lately.
12:18:31 <Saulzar> I like cricket, now it's winter - boo.
12:18:39 <syntaxfree> sometimes trouble waking up is an early sign of depression.
12:18:45 <tic> unless you count inline skating. that's usually an hour a day. 
12:18:53 <tic> shapr, should be a lumber jack instead, eh?
12:18:57 <syntaxfree> s/trouble/emotional trouble.
12:19:16 <syntaxfree> if waking up feels like a burden, maybe it's because you're not that fond of being alive/awake right now.
12:19:33 <vincenz> psi: I want to fix some sort of schedule that involves excercise
12:20:14 * vincenz has changed his alarm clock from 7am to 6am
12:20:20 <vincenz> hopefully I will actually get up at those times
12:21:04 <tic> vincenz, you just have go to bed in time )
12:21:05 <tic> :)
12:21:09 <vincenz> psi: maybe have a runin period where I go to bed early and then slowly delay
12:21:13 <vincenz> tic: yeah 
12:21:13 * syntaxfree tries to learn how to whistle.
12:21:28 <vincenz> just wish I knew a sport I would enjoy
12:21:31 <syntaxfree> I think I wanna know how to whistle just so I can whistle "Dirty old town" by The Pogues.
12:21:33 <psi> I think with more excercise it's easier to go to bed early
12:21:41 <syntaxfree> I think it's the only whistle-worthy song I know.
12:21:43 <vincenz> psi: I think with more excercise, you also need less sleep
12:21:56 <joe_k> you dont know how to whistle?
12:22:10 <vincenz> Any suggestions as to some fun sport?
12:22:10 <syntaxfree> pretty much not.
12:22:17 <syntaxfree> I can make some noise.
12:22:26 <vincenz> syntaxfree: that's called farting
12:22:28 <syntaxfree> I'm getting to make that noise melodic, slowly, but it's not loud or clear yet.
12:22:34 <psi> I can't whistle either.
12:22:35 <syntaxfree> um, that's uncalled for.
12:22:39 * vincenz was joking
12:22:43 <tic> inline skating rocks.
12:22:47 <psi> I've tried, it just doesn't work.
12:22:58 * vincenz can only do the whistling that's melodic and not the loud type
12:23:00 <tic> playing the recorder is also nice. no physical work-out though.. :)
12:23:07 <syntaxfree> as for sports, do you know parkour?
12:23:14 * vincenz is considering swimming ... maybe tai chi for fun
12:23:19 <joe_k> yeah i cant do the call-across-a-stadium whistle
12:23:19 * palomer can't whistle
12:23:21 * vincenz wants to do some martial arts but can't choose
12:23:25 <psi> vincenz: I like basketball.
12:23:27 <syntaxfree> I never cared for sports. Parkour made me regret my sorry physical state.
12:23:30 <syntaxfree> Man, I wish I could do parkour.
12:23:42 <davidhouse> parkour as in parcour?
12:23:45 <vincenz> psi: I hate team games, I'm in really poor shape and hate being laughed at... when I was young I was really small and that evoked a lot of that
12:23:50 <Saulzar> Trouble with the fun sports is they generally require other people.
12:23:53 <syntaxfree> www.parkour.net
12:23:54 <joe_k> the best sport ever is parkour http://en.wikipedia.org/wiki/Parkour
12:24:02 <joe_k> jinx
12:24:17 <syntaxfree> hey. you're a fan of parkour too?
12:24:18 <vincenz> Saulzar: like I said, I hate teamgames
12:24:34 <joe_k> yeah but I am also too out of shape to do that shit
12:24:34 <davidhouse> must be a deliberate mispelling. "parcourir" is the french for "to traverse", roughly.
12:24:40 <psi> vincenz: ok. I used to play pretty much with just one friend. you don't need teams.
12:24:43 <davidhouse> and freerunning is great! :)
12:24:48 <syntaxfree> davidhouse: yeah, that's mostly it.
12:24:55 <joe_k> jumping at walls and grapping the lip with arms outstrecthed?  Id be in a heap 10 ft down
12:25:01 <vincenz> anyone does any martial arts?
12:25:12 <syntaxfree> look at some of the videos www.parkour.net
12:25:16 <syntaxfree> man, I wish I could do that shit.
12:25:18 <vincenz> parkour is dangerous when jumping down
12:25:22 * syntaxfree apologizes for the curse word.
12:25:45 <joe_k> OW MY VIRGIN EARS
12:25:57 <psi> vincenz: I guess running is good exercise, but I think it's terribly boring.
12:26:15 <vincenz> psi: weak ankles and knees
12:26:16 <davidhouse> xerox, http://haskell.org/haskellwiki/Compose :) i wrote it up, i think it provides a nice overview of the various monads' features.
12:26:21 <davidhouse> running is great.
12:26:30 <syntaxfree> @type (->)
12:26:30 <vincenz> it's boring as hell
12:26:31 <lambdabot> parse error on input `->'
12:26:35 <davidhouse> but hockey (not as in ice) is the greatest sport :)
12:26:36 <psi> vincenz: golf? :)
12:26:39 <vincenz> psi: lol
12:26:48 * vincenz is considering forcing himself to go swimming
12:26:59 <mauke> @kind (->)
12:27:00 <lambdabot> ?? -> ? -> *
12:27:06 <syntaxfree> what is a kind?
12:27:08 <vincenz> and then I got a book or two on tai chi, try to learn it on my own, and this other thing which is more like a morning yoga thingy, something tibettan, forgot the name
12:27:10 <mauke> a type type
12:27:17 <syntaxfree> @kind Int
12:27:19 <lambdabot> *
12:27:28 <syntaxfree> @kind Int->Int->String
12:27:29 <lambdabot> *
12:27:33 <syntaxfree> ?
12:27:36 <davidhouse> syntaxfree: type constructors are a bit like functions, too.
12:27:36 <psi> hm
12:27:42 <davidhouse> they take types and give you new ones.
12:27:44 <syntaxfree> @kind Succ
12:27:46 <lambdabot> Not in scope: type constructor or class `Succ'
12:27:51 <syntaxfree> @kind []
12:27:52 <lambdabot> * -> *
12:27:56 <davidhouse> i.e. the type constructor Maybe takes an Int and gives you a Maybe Int.
12:28:03 <syntaxfree> @kind Maybe
12:28:04 <lambdabot> * -> *
12:28:11 <davidhouse> we call this "type of type constructors" a "kind".
12:28:25 <davidhouse> @kind Reader
12:28:26 <lambdabot> * -> * -> *
12:28:31 <psi> @kind StateT
12:28:33 <lambdabot> * -> (* -> *) -> * -> *
12:28:52 <davidhouse> because it's data Reader e a = ... (in other words, the type constructor takes two parameters)
12:29:02 <astrolabe> vincenz: how about http://www.stumptuous.com/cms/displayarticle.php?aid=132   ?
12:29:03 <norpan> @kind (->)
12:29:04 <lambdabot> ?? -> ? -> *
12:29:28 <davidhouse> and data StateT e m a = ... (it takes three parameters, of which the second is a monad has kind * -> *)
12:29:45 <davidhouse> now what i don't get about kinds is the kind of (->).
12:29:52 <davidhouse> why isn't it * -> * -> *?
12:30:17 <vincenz> astrolabe: lol...gee thanks
12:30:31 <norpan> davidhouse: i have no idea :)
12:30:37 <syntaxfree> what is a combinator?
12:30:59 <davidhouse> a function.
12:31:19 <davidhouse> but typically one that is used because it's useful in joining functions together.
12:31:21 <davidhouse> e.g. 
12:31:39 <davidhouse> composition (.) is a combinator because it joins two functions together.
12:31:47 <syntaxfree> oh,
12:31:55 <syntaxfree> like a higher-order function.
12:32:03 <Zarvok> syntaxfree: check out the "lazy K" programming language :)
12:32:07 <nomeata> davidhouse: maybe it's because the -> "constructor" takes a function from one (??) to another (?) set, and return the type of these functions
12:32:56 <davidhouse> -> is a type constructor.
12:33:27 <davidhouse> it takes one type, say Int, and another, say (String -> IO ()), and returns a third, Int -> (String -> IO ()).
12:33:42 <davidhouse> however, you can't do things like Maybe -> Int.
12:34:02 <davidhouse> thus you need to have a kind of * on both sides of a ->, so it should have kind * -> *.
12:34:06 <davidhouse> anyone share some light
12:34:07 <davidhouse> ?
12:34:16 <syntaxfree> Zarvok: I wanted to ask that one day.
12:34:23 <syntaxfree> What are S, K and I combinators
12:34:44 <nomeata> davidhouse: where do you expect to do "Maybe -> Int"? And what is the difference between  "??" and "*" anyways?
12:34:46 <joe_k> you need to read up on some basic functional theory and lambda calculus
12:34:52 <mauke> I = id, K = const, IIRC
12:35:02 <xerox> ?hoogle execWriter
12:35:02 <lambdabot> Control.Monad.Writer.execWriter :: Writer w a -> w
12:35:02 <lambdabot> Control.Monad.Writer.execWriterT :: Monad m => WriterT w m a -> m w
12:35:13 <syntaxfree> S?
12:35:13 <xerox> davidhouse: you can replace snd . runWriter with that.
12:35:22 <davidhouse> oh, nice.
12:35:27 <joe_k> http://en.wikipedia.org/wiki/SKI_combinator_calculus
12:36:22 <davidhouse> xerox, i also added a blank section for those knowledgeable of Cont :)
12:36:33 <xerox> Gawk.
12:37:13 <davidhouse> gawk?
12:37:43 <Zarvok> yeah, that link is useful, S is \f g x -> (f(x))(g(x))
12:37:46 <Zarvok> if I remember correctly
12:37:56 <xerox> I don't have a GHC here, hmmmm.
12:37:58 <davidhouse> S is ap, yes.
12:38:22 <syntaxfree> @type ap
12:38:23 <lambdabot> forall b (m :: * -> *) a.
12:38:23 <lambdabot> (Monad m) =>
12:38:23 <lambdabot> m (a -> b) -> m a -> m b
12:38:34 <Zarvok> Also I think I and K can be implemented with S, so you really only need S
12:38:37 <mauke> @pl \f g x -> (f(x))(g(x))
12:38:37 <lambdabot> ap
12:38:50 <syntaxfree> @ap (*2) (*3) 5
12:38:50 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
12:38:55 <syntaxfree> oops.
12:38:59 <xerox> @pl \f g x -> f x (g x)
12:38:59 <lambdabot> ap
12:39:00 <syntaxfree> > ap (*2) (*3) 5
12:39:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
12:39:01 <lambdabot>   Expected type: (a -> b) -> a
12:39:01 <lambdabot>   Inferred type: (a -> b) -> a -> b
12:39:04 <norpan> Zarvok: almost, you don't need I
12:39:20 <palomer> heh, I just produced a proof tree that's  80 inches wide
12:39:32 <palomer> that's nuts!
12:39:35 <mauke> > ap (*) (* 3) 5
12:39:36 <lambdabot> 75
12:39:50 <xerox> :-)
12:39:52 <Zarvok> norpan:  I had heard it suggested K could be written from S, but I never really thought about it, so I imagine you're right
12:40:04 <norpan> @type ap const const
12:40:06 <lambdabot> forall a. a -> a
12:40:14 <norpan> there you go
12:40:23 <davidhouse> that's I.
12:40:27 <norpan> yes
12:40:36 <davidhouse> (i.e., not K).
12:40:39 <Zarvok> heh
12:40:40 <syntaxfree> > ap (+) (*3) 5
12:40:41 <lambdabot> 20
12:40:44 <norpan> i know
12:40:49 <syntaxfree> lemme think.
12:40:54 <norpan> you need both S and K
12:41:03 <syntaxfree> that is ((+) 5 ((*3) 5))) ? 
12:41:16 <norpan> S is used to duplicate information, K is used to throw away information
12:41:54 <syntaxfree> according to the wikipedia article, there is a iota combinator from which S and K can be constructed.
12:42:15 <syntaxfree> ap is da bomb!
12:42:28 <syntaxfree> > ap (:) (*3) [5]
12:42:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:42:29 <lambdabot>   Expected type: a -> [a]
12:42:29 <lambdabot>   Inferred type: a -> a
12:42:30 <norpan> yes, there are single-combinator systems
12:42:58 <syntaxfree> > ap (:) (map (*3) [5]
12:42:58 <lambdabot>  parse error on input `}'
12:43:01 <mauke> > aip (:) (fmap (* 3)) [5]
12:43:01 <syntaxfree> > ap (:) (map (*3)) [5]
12:43:02 <lambdabot>  Not in scope: `aip'
12:43:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:43:02 <lambdabot>   Expected type: a -> [a]
12:43:02 <lambdabot>   Inferred type: a -> a
12:43:10 <syntaxfree> @type fmap
12:43:11 <mauke> oh, right
12:43:11 <lambdabot> forall (f :: * -> *) b a.
12:43:11 <lambdabot>    (Functor f) =>
12:43:11 <lambdabot>    (a -> b) -> f a -> f b
12:43:14 <vincenz> pom pom pom
12:43:16 <syntaxfree> ??
12:43:17 <lambdabot> Maybe you meant: . v
12:43:35 <syntaxfree> > ap (:) (fmap (*3)) [5]
12:43:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:43:37 <lambdabot>   Expected type: a -> [a]
12:43:37 <lambdabot>   Inferred type: a -> a
12:43:42 <syntaxfree> > fmap (*3) [5]
12:43:43 <lambdabot> [15]
12:43:50 <syntaxfree> > map (*3) [5]
12:43:52 <lambdabot> [15]
12:43:53 <mauke> [5] : [15] is invalid
12:43:59 <syntaxfree> ohh.
12:44:05 <syntaxfree> > ap (++) (map (*3)) [5]
12:44:07 <lambdabot> [5,15]
12:44:34 <xerox> @type (:)
12:44:35 <lambdabot> forall a. a -> [a] -> [a]
12:44:59 <syntaxfree> > let iterate1 f i = i ++ $ ap (++) (map (f)) i
12:44:59 <lambdabot>  parse error on input `$'
12:45:11 <syntaxfree> > let iterate1 f i = i ++ (ap (++) (map (f)) i) in iterate1 (+1) [1]
12:45:13 <lambdabot> [1,1,2]
12:45:59 <xerox> > let iterate f x = x : iterate (f x) in (iterate (^2) [1..]) !! 8
12:45:59 <lambdabot> Couldn't match `[a]' against `t -> t1'
12:46:00 <syntaxfree> > let iterate1 f i = (iterate1 f (tail i)) ++ (ap (++) (map (f)) i) in iterate1 (+1) [1]
12:46:02 <lambdabot> Exception: stack overflow
12:46:06 <xerox> Ops.
12:46:13 <syntaxfree> > let iterate1 f i = (iterate1 f (tail i)) ++ (ap (++) (map (f)) i) in take 10 $ (iterate1 (+1) [1])
12:46:15 <lambdabot> Exception: stack overflow
12:46:24 <syntaxfree> mommy!
12:47:03 <xerox> > let iterate f (x:xs) = f x : iterate f xs in (iterate (^2) [1..]) !! 8
12:47:04 <lambdabot> 81
12:47:28 <syntaxfree> oh, come on. that's no fun.
12:47:31 <xerox> @hoogle iterate
12:47:31 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
12:47:41 <joe_k> is !! the list indexing operator?
12:47:43 <edwinb> The trouble with that iota combinator is that it's defined in terms of S and K...
12:47:49 <xerox> @fptools Prelude
12:47:49 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:47:54 <syntaxfree> @pl iterate f x = f x (iterate f (tail x))
12:47:54 <lambdabot> iterate = fix (ap ap . flip flip tail . ((.) .))
12:48:11 <syntaxfree> @type fix
12:48:13 <lambdabot> forall a. (a -> a) -> a
12:48:23 <syntaxfree> > fix (+1) 
12:48:24 <lambdabot> Terminated
12:48:30 <syntaxfree> > fix (/2)
12:48:31 <lambdabot> Terminated
12:48:40 <syntaxfree> > fix (\x->0)
12:48:41 <lambdabot> 0
12:48:52 <syntaxfree> > fix (\x->exp(x))
12:48:53 <lambdabot> Terminated
12:48:56 <xerox> > let iterate f = unfoldr (\x -> Just (x,f x)) in take 10 $ iterate (*2) [1..]
12:48:57 <lambdabot>  add an instance declaration for (Num [a])
12:49:01 <xerox> Pfft.
12:49:03 <syntaxfree> Fix looks for a fixed point in a function??
12:49:06 <xerox> > let iterate f = unfoldr (\x -> Just (x,f x)) in take 10 $ iterate (*2) 1
12:49:06 <lambdabot> [1,2,4,8,16,32,64,128,256,512]
12:49:40 <nomeata> davidhouse: from the report: "The function type is written as (->) and has kind *->*->*."
12:49:44 <xerox> > let iterate f x = x : iterate f (f x) in take 10 $ iterate (*2) 1
12:49:44 <syntaxfree> > fix (\x->exp(1/x))
12:49:45 <lambdabot> [1,2,4,8,16,32,64,128,256,512]
12:49:46 <lambdabot> Terminated
12:49:49 <xerox> Good.
12:49:57 <davidhouse> nomeata: 
12:50:01 <davidhouse> great :)
12:50:35 <xerox> @kind (->) -- I think it is something different in GHC.
12:50:35 <lambdabot> ?? -> ? -> *
12:50:40 <xerox> (-:
12:50:47 <davidhouse> xerox, yes, why?
12:50:59 <syntaxfree> > fix (\x->1-x)
12:51:01 <lambdabot> Terminated
12:51:07 <syntaxfree> :'(
12:51:14 <xerox> davidhouse: ? and ?? are subset of *, I think.
12:51:24 <nomeata> I can't find ? and ?? in the report.
12:51:40 <xerox> I don't remember the details.
12:51:42 <syntaxfree> > fix 0
12:51:42 <lambdabot>  add an instance declaration for (Num (a -> a))
12:51:45 <davidhouse> why would it be a subset?
12:51:49 <syntaxfree> > fix (\x->2)
12:51:51 <lambdabot> 2
12:51:51 <davidhouse> you can -> any two types together.
12:51:54 <nomeata> @kind Int
12:51:56 <lambdabot> *
12:51:57 <joe_k> maybe you can msg lambdabot
12:52:08 <syntaxfree> numbers should be constant functions when needed.
12:52:29 <syntaxfree> > fix (\x->2/3)
12:52:30 <lambdabot> 0.6666666666666666
12:52:40 <syntaxfree> > fix (\x->x-1)
12:52:41 <xerox> @type undefined :: 1 -> ()
12:52:41 <lambdabot> 1 -> () :: GHC.Base.Unit -> ()
12:52:42 <lambdabot> Terminated
12:52:43 <xerox> @kind 1
12:52:44 <davidhouse> unless there are complex interactions with bottom or something.
12:52:44 <lambdabot> *
12:52:50 <xerox> Hm.  That wasn't that.
12:53:05 <davidhouse> 1? huh? huh?
12:53:17 <palomer> 1 is a type?
12:53:17 <davidhouse> syntaxfree: fix (const 2)
12:54:13 <syntaxfree> well, fix . const = id
12:54:18 <syntaxfree> but what is fix f in general?
12:54:22 <syntaxfree> > fix const
12:54:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
12:54:23 <lambdabot>   Expected type: (b -> t) -> b -> t
12:54:23 <lambdabot>   Inferred type: (b -> t) -> b -> b -> t
12:54:43 <syntaxfree> > (fix . const) 4
12:54:44 <lambdabot> 4
12:54:46 <nomeata> @kind "is this a type too?"
12:54:47 <lambdabot> parse error on input `"'
12:54:57 <davidhouse> fix f = f (f (f (f (f ...
12:55:06 <syntaxfree> hmm.
12:55:30 <xerox> dcoutts: how was to use TH to return the AST?
12:55:31 <syntaxfree> fix = head . reverse . iterate ?
12:55:52 <syntaxfree> > fix (\x->1/x)
12:55:53 <lambdabot> Terminated
12:55:55 <xerox> @hoogle fix
12:55:55 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
12:55:55 <lambdabot> Control.Monad.Fix :: module
12:55:55 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
12:56:00 <xerox> @fptools Control.Monad.Fix
12:56:00 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
12:56:07 <xerox> fix f = let x = f x in x
12:56:45 <syntaxfree> hmm. 
12:57:10 <syntaxfree> fix = head . reverse . iterate . zipWith (.)
12:57:29 <xerox> @type head . reverse . iterate . zipWith (.)
12:57:30 <lambdabot>   Couldn't match `[a]' against `[a1 -> c] -> [[a1 -> c]]'
12:57:30 <lambdabot>   Expected type: [c -> c] -> [a]
12:57:51 <syntaxfree> yeah, yeah. just a min.
12:58:14 <syntaxfree> @pl f x = f (zipWith (.)  f x)
12:58:15 <lambdabot> f = fix (ap (.) (zipWith (.)))
12:58:33 <syntaxfree> @pl f x = f f x
12:58:33 <lambdabot> f = fix (join id)
12:58:40 <syntaxfree> oh boy. more headache.
12:58:42 <syntaxfree> @type join
12:58:43 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:58:53 <syntaxfree> @pl f x = f . f
12:58:54 <lambdabot> f = fix (const . join (.))
12:59:13 <syntaxfree> @pl f = (.f)
12:59:13 <lambdabot> f = fix (flip (.))
12:59:19 <syntaxfree> @pl f = (f.)
12:59:19 <lambdabot> f = fix (.)
12:59:25 <syntaxfree> @pl f = f
12:59:25 <lambdabot> f = fix id
12:59:50 <xerox> @djinn (a -> a) -> a
12:59:50 <lambdabot> -- f cannot be realized.
12:59:55 <xerox> *grin*
13:01:38 <syntaxfree> writing a haskell compiler must be teh nightmare.
13:02:28 <joe_k> its written in haskell of course. I can't imagine
13:02:40 <syntaxfree> I wonder what minimal haskell looks like.
13:02:47 <syntaxfree> The part of Haskell that can't be written in Haskell.
13:03:01 <norpan> huh?
13:03:02 <xerox> What part of Haskell can't be written in Haskell?
13:03:06 <joe_k> huh? why do you assume there is such a part?
13:03:18 <xerox> "huh?" seem to have gained popularity recently.
13:03:27 <norpan> what does it mean to "write haskell in haskell"?
13:03:28 <syntaxfree> well, it needs to be bootstrapped somewhere or we'll never have any  compilers.
13:03:40 <joe_k> there already is a compiler... ghc
13:03:50 <syntaxfree> I can write sum in Haskell. map (+)
13:03:53 <syntaxfree> I can also write map.
13:04:16 <tic> How would you guys define a list that could have either regular values or tuples in it?
13:04:18 <syntaxfree> map f l = f (head l) : map f (tail l) 
13:04:24 <syntaxfree> add the apropriate base case before.
13:04:34 <davidhouse> tic, i probably wouldn't
13:04:35 <tic> I have a function creating a list, and another function consuming it.
13:04:44 <tic> they're tightly coupled.
13:04:47 <syntaxfree> how was GHC created?
13:04:51 <davidhouse> however, if it was absolutely necessary, use some type hackery like Either.
13:05:03 <davidhouse> syntaxfree: witchcraft.
13:05:10 <joe_k> much like any compiler written in its own language, I would suspect
13:05:15 <tic> davidhouse, but that's not good enough :/
13:05:22 <joe_k> first one might have been in, hell, lisp or something
13:05:24 <davidhouse> tic, why not?
13:05:30 <joe_k> then a proto-haskell
13:05:36 <joe_k> that became stronger
13:05:38 <joe_k> who knows
13:05:59 <tic> davidhouse, the data function usually returns [Int], but could as well return [(Int, String)], or [(Float, Int, String)], or such. Basically [a].
13:06:12 <syntaxfree> what does the language the first-order compiler knew how to compile look like?
13:06:25 <davidhouse> > [Left 5, Left 6, Right ('a', True), Left 10] :: Either Int (Char, Bool)
13:06:26 <lambdabot> Couldn't match `Either Int (Char, Bool)' against `[a]'
13:06:39 <davidhouse> huh. odd.
13:07:03 <joe_k> syntaxfree: you will have to do some archeology on ghc to find that out i bet
13:07:08 <davidhouse> tic, you might want to try a typeclass.
13:07:11 <joe_k> syntaxfree: or just ask the authros
13:07:16 <tic> davidhouse, *hmm* yeah.
13:07:24 * palomer kicks latex in he groin
13:07:25 <syntaxfree> hmm.
13:07:28 <palomer> s/he/the
13:07:30 <tic> davidhouse, do you know of Nevow?
13:07:33 <syntaxfree> suppose there is no binary for GHC for my platform.
13:07:39 <syntaxfree> How the heck do I get GHC there?
13:07:41 <tic> palomer, use ReStructuredText!
13:07:46 <tic> syntaxfree, yeah! like beos! :)
13:08:00 <joe_k> port the parts of the compiler that generate native code
13:08:11 <tic> doesn't ghc generate C?
13:08:18 <joe_k> does it?
13:08:18 <joe_k> wow
13:08:30 <palomer> is there really an alternative to latex?
13:08:34 <Igloo> syntaxfree: There are instructions in the porting guide
13:08:48 * palomer just wants to write proof trees
13:08:48 <syntaxfree> there is a XML language for tex.
13:08:51 <syntaxfree> i forgot the name.
13:08:53 <Igloo> palomer: lout(.sf.net?) is one
13:09:00 <syntaxfree> it's like a modernized LaTeX.
13:09:08 <syntaxfree> LaTeX in XML. There's also Skribe.
13:09:11 <davidhouse> tic, no, why?
13:09:15 <Igloo> palomer: Have you seen the LaTeX semantic package?
13:09:18 <syntaxfree> Skribe is in s-expressions.
13:09:40 <tic> davidhouse, I'm basically trying to port its XHTML templates.
13:09:53 <tic> davidhouse, but nevermind then.
13:10:01 <palomer> Igloo: what does it do?
13:10:41 <davidhouse> tic, a typeclass will work. you might want to check out JRegex. it's main function, (~=), returns different things depending on how you annotate it.
13:10:57 <xerox> davidhouse: you missed the '[' ']' there.
13:11:03 <Igloo> palomer: Has functions for writing inferences rules, amongst other things
13:11:11 <davidhouse> e.g. "hello" ~=someRegex :: Int gives the number of matches, but :: String gives the first match, etc.
13:11:14 <palomer> oooh
13:11:14 <Igloo> syntaxfree: Sorry, IM building guide
13:11:15 <palomer> nice
13:11:18 <davidhouse> xerox, duh. :)
13:11:21 <tic> davidhouse, I think a type class would do. Thanks!
13:11:24 <davidhouse> > [Left 5, Left 6, Right ('a', True), Left 10] :: [Either Int (Char, Bool)]
13:11:25 <lambdabot> [Left 5,Left 6,Right ('a',True),Left 10]
13:11:44 <palomer> I've tried bussproofs and proof.sty
13:11:49 <tic> davidhouse, the list is homogen though. It's just that the stuff inside the list can be different :)
13:11:57 <palomer> proof,sty is causing me headaches
13:12:22 <davidhouse> ah, that makes things easier. yes, a typeclass is definitely better.
13:12:30 <palomer> I need to do n-ary inferences
13:12:33 <xerox> HList?
13:19:26 <pejo> palomer, I don't remember which I used, but bussproofs.sty might be a better idea.
13:20:49 <palomer> bussproofs doesn't do n-ary
13:20:55 <palomer> ony unary, binary and trinary
13:21:03 <palomer> s/only/ony
13:23:39 <norpan> stupid computer
13:23:49 <xerox> True.
13:28:46 <syntaxfree> http://www.nytimes.com/2006/05/14/arts/14heff.html?ei=5090&en=3941ff903992e111&ex=1305259200&partner=rssuserland&emc=rss&pagewanted=all
13:36:43 <syntaxfree> ok. you linux  people, what's the smallest linux distribution I can download that will still compile GHC?
13:36:47 <syntaxfree> No, I don't want Gentoo 
13:37:05 <syntaxfree> I don't want to bootstrap a whole system in a VPC session.
13:37:57 <Igloo> Debian, possibly
13:38:00 <nomeata> debian minimal might be a candidate
13:38:24 <nomeata> but specialized "small" distros are probably smaller. although rarely laid out for compiling stuff
13:38:49 <xerox> Ubuntu makes things quite simple.
13:39:03 <psi> ubuntu is fairly large, though
13:39:03 <xerox> (It is debian based and has some other goodies ontop of it.)
13:39:05 <nomeata> do you mean small by size or effort?
13:39:26 <jcreigh> syntaxfree: How familar are you with Linux?
13:39:29 <nomeata> in the latter case, maybe knoppix or the like
13:40:05 <psi> debian is just a few hundred megs
13:40:11 <psi> iirc
13:56:37 <norpan> tqh
13:58:55 <jgraves> syntaxfree: Damn Small Linux is a 50MB image, can be converted to full Debian later.
14:03:53 <davidhouse> can anyone give a precise defintion of "thunk"?
14:04:07 <xerox> Closure?
14:04:26 <tic> norpan, does "tqh" mean anything?
14:04:47 <norpan> it's a secret
14:04:52 <davidhouse> xerox, that's it? partial application?
14:05:06 <tic> norpan, there's a guy hacking on the BeOS Firefox port called tqh, that's why I asked.
14:05:13 <xerox> davidhouse: a floating `bunch of code' (:
14:05:18 <tic> hey waern_ 
14:05:26 <xerox> I would call that a closure too.
14:05:53 <jgraves> The wikipedia entry http://en.wikipedia.org/wiki/Thunk is fairly short, but seems to match what I know.
14:05:54 <SamB> something that must be entered!
14:06:12 <psi> I think the FORTRAN guys/girls invented the term, but I don't rememeber for what.
14:06:13 <xerox> Right, delayed is a nice keyword in this case.
14:06:16 <davidhouse> i remember wikipedia being rather vague in this instance.
14:06:19 * davidhouse tries again
14:06:32 <davidhouse> there were fortran girls? ;)
14:06:37 <xerox> I was trying to address it with `action' but it's `computation' the term I really wanted.
14:06:41 <psi> davidhouse: I think so :)
14:06:43 <xerox> <3 wikipedia
14:06:59 <norpan> a closure > a thunk
14:07:25 <davidhouse> so what's the relationship between closures, thunks, partial applications and currying? :)
14:07:49 <jgraves> Sounds like a good topic for a paper.
14:07:52 <jgraves> :-)
14:08:01 <vincenz> closure > partial app > thunk
14:08:30 <davidhouse> > in what way?
14:08:30 <lambdabot>  parse error on input `in'
14:08:38 <davidhouse> heh.
14:08:46 <davidhouse> anyway, > as in "is more general"?
14:08:55 <norpan> a thunk is something that can be evaluated to a value
14:09:12 <norpan> a closure is basically a function
14:09:53 <xerox> Well no.
14:09:55 <psi> does scheme's delay return a thunk?
14:10:00 <xerox> Hmmm.
14:10:11 <xerox> I mean, doesn't a closure have encapsulated all of the variables in his scope^?
14:10:16 <vincenz> a closure has a local set of variables, a partial application has specifically as local variables the already passed arguments, a thunk is just an unevalled func
14:10:17 <xerox> Partial application doesn't do that.
14:10:24 <vincenz> hence my ordering
14:10:45 <xerox> I would think so too, with computation instead of "func."
14:12:12 <davidhouse> hmm.
14:12:34 <vincenz> in addition
14:12:38 <vincenz> typically a thunk has no more arguments
14:12:42 <davidhouse> so if i were to say let double = map (*2), would double be a thunk, partial app or closure?
14:12:47 <vincenz> while a closure or a partial app'd func does
14:12:59 <davidhouse> or all three
14:13:02 <vincenz> davidhouse: partial app
14:13:10 <vincenz> of map
14:13:13 <xerox> davidhouse: under Haskell the things mixes a bit more.  Thanks to lazyness all are delayed computations :-)
14:13:27 <vincenz> xerox: yeah except those are thunks, which take no ags
14:13:28 <vincenz> args
14:13:39 <xerox> Well no, they are unevaluated too.
14:13:44 <davidhouse> vincenz: could you exemplify a closure?
14:13:44 <vincenz> no I know
14:13:47 <vincenz> but they don't take args
14:14:01 <xerox> Dunno if it is worth differentiating in the Haskell realm for those.
14:14:05 <vincenz> davidhouse: the point is kinda moot in ahskell
14:14:12 <xerox> Right (-:
14:14:17 <norpan> the point with thunks is that you can evaluate them
14:14:27 <norpan> it makes no sense evaluating a partial application
14:14:38 <davidhouse> right. so in haskell, partial apps are pretty similar to closures.
14:14:43 <xerox> You could say that something like foo = let ... in ... resembles the closure definition more than something without scoped bindings.
14:14:56 <vincenz> yup
14:15:04 <davidhouse> but thunks have all their arguments, just haven't yet been evaluated
14:15:16 <vincenz> yep
14:15:25 <vincenz> anyways
14:15:33 <vincenz> closures vs partial apps is pretty much the same in a pure language
14:15:43 <vincenz> cause you can rewrite a let into a function application
14:15:59 <xerox> Viva la pure funcional programming!
14:16:38 <davidhouse> but in impure languages, a closure... what, knows more scope?
14:19:15 <xerox> It encapsulates the free vars of its statements/expressions.
14:23:36 <vincenz> davidhouse: I don't think the definitions are unambiguous
14:24:38 <palomer> ok, that's it
14:24:41 <palomer> I'm in love with haskell
14:24:56 <palomer> I've finished being in denial
14:25:47 <vincenz> palomer: what changed?
14:27:23 <palomer> I don't get boggled by ghc errors anymore and my code most always typechecks
14:27:27 <vincenz> :)
14:27:34 * vincenz is off to sleep
14:27:41 <palomer> and I can't think in haskell
14:28:13 <azuroth> you can't? why is that good?
14:28:30 <palomer> s/can/can't
14:29:05 <joe_k> can't't ?
14:29:10 <davidhouse> heh
14:29:27 <jgraves> I'm starting to like Haskell a lot myself, but I certainly haven't mastered it yet.
14:29:51 <norpan> haskell is the shit
14:30:01 <norpan> actually haskell+c is the shit
14:30:02 <jgraves> I like lazy evaluation the most.  You are, in essence, abstracting out time.  Or at least sequence.
14:30:04 <araujo> norpan, ?
14:30:18 <norpan> shit == bad, the shit == good
14:30:24 <araujo> oh... 
14:30:45 <araujo> interesting interpretation
14:31:04 <sjanssen> norpan: why the +c part?
14:31:11 <palomer> haskell is the the shit
14:31:32 <davidhouse> paris is lovely in the the spring :)
14:31:51 <norpan> because the +c part lets you do things really fast/memory efficient if you really want to
14:32:08 <norpan> and interface to libraries
14:33:31 <jgraves> I'd like to completely eliminate C and C++ for regular application programming in my company.
14:33:48 <jgraves> But I've got a long ways to go, I'm the only one learning Haskell so far.
14:34:31 <sjanssen> norpan: the excellent FFI is nice, but I prefer to keep my C to a minimum
14:34:31 <norpan> jgraves: good luck, you'll need it
14:35:10 <norpan> sjanssen: minimal shit
14:35:19 <jgraves> Yeah, good thing I'm CTO though.  I tend to have some influence in this area.
14:35:23 * dcoutts is pleased to see Tim Docker's announcement of his charting library
14:35:34 <dcoutts> based on cairo & gtk2hs
14:36:13 <joe_k> what shall I do for dinner tonight in new orleans?
14:36:20 * joe_k is thinking shrimp poboy
14:37:43 <azuroth> more like what should I do about not doing any tafe/college work last week?
14:38:22 <dcoutts> shapr, pong
14:38:36 <joe_k> tafe ?
14:39:15 <azuroth> it's a sort of vocational education in australia
14:39:28 <davidhouse> who maintains haddock? anyone in here?
14:39:45 <xerox> dcoutts: where?
14:39:58 <sjanssen> davidhouse: Simon M. I believe
14:40:32 * davidhouse has a list of things he'd like to see in it
14:40:48 <davidhouse> it doesn't have a Trac, does it?
14:42:11 <dcoutts> xerox, http://dockerz.net/software/chart.html
14:42:46 <Cale> wow, that's beautiful
14:43:34 <xerox> Hurray for cairo!!!
14:43:41 <dcoutts> yeah
14:43:58 <xerox> Good, good, good.
14:44:05 <Cale> cairo makes even the simplest things look impressively good :)
14:44:40 <BCoppens> xerox: that looks cool & simple :o
14:45:01 <xerox> Indeed!
14:45:06 * xerox feels pleased
14:45:12 <xerox> Be back shortly.
14:45:16 <davidhouse> "filledCircles 2 1 0 0," -- i wonder what that does?
14:45:31 <joe_k> sets the point style for the red points
14:45:35 <joe_k> RGB=1,0,0
14:45:40 <joe_k> 2 is probably size
14:45:48 <davidhouse> ah. could have used a colour datatype.
14:45:55 <joe_k> (i am guessing)
14:45:59 <norpan> or color
14:46:39 <Cale> It would be nice to have a cool Colour type with constructors for various colour spaces.
14:47:01 <joe_k> so sinusoid1 sinusoid2 and layout are records
14:47:02 <joe_k> interesting
14:47:04 <Cale> (though at that point, you kind of want a class)
14:47:27 <davidhouse> data Colour = RGB (Word8, Word8, Word8) | HSV ...
14:47:32 <palomer> hrmphrmphrmprphpmrphprmprhprmp
14:47:33 <davidhouse> type Color = Colour
14:47:34 <davidhouse> :)
14:47:35 * palomer kicks latex, again
14:47:41 <palomer> seriously
14:47:49 <Cale> @palomer
14:47:49 * joe_k hands you a copy of Microsoft Word
14:47:49 <lambdabot> Blargh!
14:47:52 <Cale> @palomer
14:47:52 <lambdabot> Scalliwags!
14:47:53 <Cale> @palomer
14:47:53 <lambdabot> Scalliwags!
14:48:06 <palomer> if you're going to change the spelling of a language, you should increase its phoneticity
14:48:08 <davidhouse> palomer: what's up?
14:48:11 <Cale> @yow
14:48:11 <lambdabot> Why don't you ever enter and CONTESTS, Marvin??  Don't you know your
14:48:11 <lambdabot> own ZIPCODE?
14:48:23 <sjanssen> @. elite keal
14:48:24 <lambdabot> w|-|4+ 4RE EPzi|ONz?
14:48:33 <azuroth> hmm. I've been fighting with word for all our documents, and thought latex would be better. :-(
14:48:34 <Cale> @keal
14:48:35 <lambdabot> i can explain why something is without knowing what the rules decided by man are
14:48:36 <palomer> davidhouse: latex is going all funky on my proof trees
14:48:42 <davidhouse> eurgh, not playing with elite again.
14:48:52 <Cale> azuroth: for sane things, LaTeX is great
14:48:54 <davidhouse> latex > word in terms of prettiness.
14:49:04 <joe_k> no doubt
14:49:15 <Cale> palomer is trying to get LaTeX to render gigantic proof trees
14:49:23 <davidhouse> it's also easier to write in emacs :)
14:49:31 <azuroth> I'm more worried about ease of writing than prettiness, it's just a nice side effect I hope
14:49:41 <Cale> ease of writing isn't so bad
14:49:41 <sjanssen> trying to parse elite . keal is often challenging
14:49:58 <davidhouse> latex is fine once you get used to it.
14:50:09 <Cale> @. elite keal
14:50:10 <lambdabot> w|-|3re (AN i FInd op3NzOuRcE s(h3/\/\ATIcz0rz oF 1inuz TOrvA1D5' X86 clon3?
14:50:11 <davidhouse> like, how to pronounce its name :)
14:50:50 <Cale> la-tekh
14:51:16 <davidhouse> lay-teck, iirc.
14:51:20 <azuroth> I looked at a similar concept called skribe, which is scheme based, and it looked like it'd be easier to use
14:51:32 <psi> "when pronounced correctly, your monitor will become slightly moist"
14:51:39 <Cale> yes
14:51:52 <Cale> it's not just a k, it's sort of a kh
14:51:54 <palomer> Cale: how do you put something in a box in latex?
14:52:01 <davidhouse> the 'x' is actually a greek chi, so you pronounce it like the ch in "loch" (the scottish lakes)
14:52:12 <palomer> Cale: my last one is at 80 inches!
14:52:22 <norpan> so silly
14:52:49 <norpan> just pronounce it lay teks and be done with it
14:52:53 <xerox> That's strange but I'm liking so much using grayscale instead of normal coloring on my monitor.
14:53:05 <davidhouse> ooh, retro.
14:53:12 <davidhouse> xerox, does it have a sepia mode as well? :)
14:53:31 <jip> let's say there is a function that has an unsafe version. the way i am using the function, the unsafe version is allowed, but i don't actually need the performance benefits of the unsafe version. should i use the unsafe version or the safe version? and if i use the safe version, should i add a comment explaining that the unsafe version will also be acceptable if in the future it's discovered that i actually do need the performance benefits?
14:53:40 <xerox> I don't think so, but one can problably make one quite simply, davidhouse (:
14:53:42 <Cale> palomer: \fbox I think
14:54:24 <Cale> http://www.eng.cam.ac.uk/help/tpl/textprocessing/teTeX/latex/latex2e-html/ltx-143.html
14:54:25 <joe_k> how does the unsafe version achieve its performance benefit (out of curiousity)
14:54:28 <xerox> Via Core Image/Video, that is.
14:54:31 <mahogny> jip, my book says you should go with the unsafe if you can prove that it works
14:54:33 <mahogny> joe_k, less checks
14:54:35 <psi> I've read that the 'x' is pronounced like 'ch' in Bach
14:54:46 <xerox> joe_k: the unsafe version of what?
14:54:58 <psi> that's not the same as the 'ch' in loch, is it?
14:55:22 <Cale> psi: they're somewhat similar at least
14:55:22 <davidhouse> @pl \x y -> f (g x) y
14:55:22 <lambdabot> f . g
14:55:31 * xerox stabs davidhouse 
14:55:32 <mahogny> psi, I heard that late(x) is like (ch)aos. dunno about bach
14:55:35 <jip> i'm not actually sure how the unsafe version is supposed to be more efficient. it says, "The given action is not allowed to throw an exception"
14:55:46 <Cale> jip: which unsafe function?
14:55:50 <davidhouse> xerox, that was uncalled for.
14:55:56 <xerox> hehe.
14:56:10 <Cale> jip: with array functions, they're often considered unsafe for not doing bounds checks
14:56:13 <jip> Cale: Grahpics.Rendering.OpenGL.GL.CoordTrans.unsafePreservingMatrix
14:56:16 <Cale> hmm
14:56:20 <xerox> I never say it enoough times, eta-reduce! eta-reduce!
14:56:27 <joe_k> ok so safe doesn't mean type safety?
14:56:45 <mahogny> joe_k, no
14:56:51 <mahogny> usually not in this context
14:57:13 <davidhouse> xerox, yes yes :) i'm just having a weird moment where i couldn't understand that reduction.
14:57:18 <davidhouse> don't worry, i'm back again.
14:57:21 <Cale> jip: oh, I suppose it's marked unsafe because you have to make sure that it obeys those properties
14:57:22 <joe_k> or side-effect safety
14:57:28 <Cale> (the input action)
14:57:29 * xerox prods davidhouse 
14:57:38 <jip> Cale: yep
14:58:09 <mahogny> jip, actually, adding a bit on the above; if you can make sure that an unsafe value never reaches the unsafe function, you can use it. you shouldn't otherwise. so, add checks if you have to
14:58:13 * davidhouse has decided that his compose = execState . mapM modify is Really Rather Pretty (TM).
14:58:26 * xerox agrees.
14:58:53 <jip> mahogny: but what if i don't need the extra performance?
14:58:59 <davidhouse> xerox, have you written a cont one yet? :)
14:59:15 <psi> http://encyclopedia.thefreedictionary.com/Chi%20%28Greek%20letter%29 claims that Chi is pronounced like the german ch, as in "ich"
14:59:56 <davidhouse> well the german ch is quite variable.
15:00:08 <mahogny> jip, some would consider it defensive programming to use the safe version. I guess I would agree during initial testing of the function, but then I would probably swap to the unsafe. prolly just me, but I'm allergic to programs that waste cpu for no good reason
15:00:13 <dcoutts> dons, interesting stats btw
15:00:18 <xerox> davidhouse: I thought a bit about a possible design, but Cont is really mind-twisting.
15:00:20 <psi> Ich is a lot softer than, say, chaos
15:00:55 <davidhouse> you can either get a "sh" type sound (the ich-laut) or a "k" type sound (the ach-laut)
15:01:00 <davidhouse> any other Cont wizards in here?
15:01:14 * JKnecht generally transliterates greek X to K 
15:01:29 * xerox tries some golfing
15:01:46 <jip> mahogny: hm.... well, my "reason" would be that just seeing the word "unsafe" in the code gives me the mini-jeebies
15:02:09 <Cale> heh, mini-jeebies
15:03:20 <psi> davidhouse: how is 'ach' pronounced?
15:03:27 <palomer> fbox breaks my tex file
15:03:29 <palomer> go anything else?
15:03:37 <Cale> \framebox?
15:03:59 <davidhouse> psi, i'm sure it depends on whereabouts in germany you're from, but like "ack".
15:04:15 <palomer> so does framebox
15:04:17 <psi> ok
15:04:18 <palomer> in fact, \n breaks it
15:04:20 <palomer> I don't understand
15:04:30 <Cale> what's the error?
15:04:49 <davidhouse> all right, the challenge is to write a compose :: [(a -> a)] -> (a -> a), i.e. it takes a starting value and threads it through all the functions in turn.
15:04:57 <davidhouse> that's the easy part. the challenge is to write it in Cont :)
15:05:19 <Cale> what do you mean by 'in Cont'?
15:05:36 <dcoutts> dons, not sure about your 128k chunk size change
15:05:41 <mahogny> jip, well, you should go with whatever you feel comfortable with. I just prefer an offensive coding style
15:05:44 <Cale> you could write that in the identity monad, so you could certainly write it in Cont with no special features
15:05:53 <dcoutts> dons, based on your graph I'd go for something rather smaller
15:06:38 <palomer> hrmph
15:06:41 <davidhouse> Cale, e.g. the sane solution is foldl (flip (.)) id, but you can write alternative ones in, say State: execState . mapM modify. or Reader. see http://haskell.org/haskellwiki/Compose
15:06:44 <palomer> it seems latex simply gives up after 50 inches
15:07:09 <dcoutts> dons, since when you're using ByteString.Lazy in a real program it's likely to be sharing the cache with other computations. So I'd go for the smallest chunk size that still gets us decent performance.
15:07:35 <dcoutts> dons, which from your graph would be in the 4k - 32k range.
15:07:47 <azuroth> heh, awesome. I can boot polish my pants and they look brand new!
15:08:04 <joe_k> leather pants?
15:08:07 <joe_k> oe vinyl
15:08:17 <azuroth> no, black cotton ;-p
15:08:18 <mahogny> dcoutts, sounds like something an installer tool could benchmark and account for
15:08:31 <flowolf> hi all
15:08:34 <azuroth> they have weird light patches on the knees though. well, had
15:08:45 <Cale> hi flowolf 
15:08:58 <Cale> new here?
15:09:13 <dcoutts> mahogny, we plan to have some functions with a chunk size parameter so that app authors can do just that. However we also need a sensible default.
15:09:20 <flowolf> yes
15:09:30 <flowolf> I'm just looking for a guy
15:09:33 <flowolf> xerox: ping
15:09:55 <flowolf> xerox: who is the gtk2hs mantainer?
15:10:06 <Cale> that would be dcoutts 
15:10:19 <dcoutts> @yarr!
15:10:20 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
15:10:36 <Cale> @yow!
15:10:36 <lambdabot> I represent a sardine!!
15:10:36 <flowolf> xerox said that he also is the ebuild mantainer for gtk2hs
15:10:48 <dcoutts> flowolf, yep. I am.
15:10:53 <flowolf> dcoutts: I have a problem when compiling gtk2hs
15:10:57 <flowolf> http://rafb.net/paste/results/uuCDlg88.html
15:11:34 <Cale> davidhouse: Oh, I have an idea
15:11:57 <xerox> Do you?
15:12:04 <Cale> davidhouse: we could write a goto-type loop which iterates over the list.
15:12:05 <dcoutts> flowolf, are you using gcc4 ?
15:12:05 <davidhouse> You do?
15:12:12 <flowolf> dcoutts: yes
15:12:17 <flowolf> dcoutts: 4.1
15:12:29 <mahogny> * Cale makes the world a favour and ports goto to haskell
15:12:31 <xerox> I was thinking of folding and making each function call the continuation, which is the rest of the functions.
15:12:32 <dcoutts> flowolf, ok, try  ghc-6.4.1-r3 or ghc-6.4.2
15:12:55 <dcoutts> flowolf, they're currently both p.masked but we're about to unmask them
15:13:01 <flowolf> ok
15:13:02 <Cale> mahogny: this is the Cont monad we're talking about -- first class continuations are like goto on acid
15:13:03 <flowolf> thank you
15:13:14 <xerox> But it is difficult for me to understand what callCC uses as environment to wrap
15:13:21 <mahogny> Cale, yeah, I know. jk :)
15:13:41 <jip> foldl1 fails on an empty list?
15:13:46 <davidhouse> Cale, could you expand? a goto style loop?
15:13:49 <davidhouse> jip, of course
15:14:09 <xerox> > foldl1 undefined []
15:14:10 <lambdabot> Add a type signature
15:14:11 <Cale> getCC :: MonadCont m => m (m a)
15:14:11 <Cale> getCC = callCC (\c -> let x = c x in return x)
15:14:11 <Cale> getCC' :: MonadCont m => a -> m (a, a -> m b)
15:14:11 <Cale> getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
15:14:13 <xerox> Pfft.
15:14:26 <Cale> davidhouse: getCC makes a "goto-label"
15:14:28 <davidhouse> jip, normal foldl doesn't because it's got a starting element it can use in that case. foldl1 only works for nonnull lists.
15:14:28 <jip> remember you guys were telling me before how to fold a list in order to apply a transformation function over a value in sequence?
15:14:39 <Cale> calling the label that's returned jumps back to that point
15:14:53 <jip> hm...
15:14:53 <Cale> getCC' makes a goto label that can return a value along with it
15:15:02 <davidhouse> jip, yes?
15:15:15 <flowolf> dcoutts: another error _
15:15:16 <xerox> Cale: Just Cont and ContT are MonadCont?
15:15:22 <jip> nm figured it out
15:15:35 <flowolf> dcoutts: http://rafb.net/paste/results/MhgDpw50.html
15:15:47 <Cale> xerox: basically, yeah
15:15:50 <xerox> Okay.
15:16:28 <xerox> Cale: you use getCC as do { stuff; boing <- getCC; ...; boing; ... } ?
15:18:05 <xerox> Let me restate that greyscale and color inversion is great for nightly reading.
15:20:21 <Cale> xerox: yes
15:20:36 <davidhouse> right.
15:21:58 <davidhouse> and we're going to do something like compose' (x:xs) = do something with x; something with getCC' and xs; ?
15:22:08 <Cale> compose :: [a -> a] -> a -> a
15:22:08 <Cale> compose fs = runCont compose' id
15:22:08 <Cale>   where compose' = do
15:22:08 <Cale>             ((gs,f), jump) <- getCC' (fs,id)
15:22:08 <Cale>             case gs of
15:22:08 <Cale>                 []      -> return f
15:22:13 <Cale>                 (g:gs') -> jump (gs',f . g)
15:22:42 * azuroth ad tafamum or something
15:23:47 * davidhouse has no idea how that works
15:24:02 <flowolf> dcoutts: are you still there?
15:24:09 * davidhouse thinks more reading about Cont is required on his part
15:24:19 <Cale> davidhouse: it's just like a goto-loop
15:24:26 <davidhouse> anyone recommend a reference/paper?
15:24:35 <Cale> only we can pass a parameter back when we jump
15:24:47 <Cale> id is the initial value for the parameter
15:24:49 <davidhouse> oh! clever.
15:24:54 <davidhouse> it suddenly clicks.
15:25:25 <davidhouse> well, clicks on a superficial level. i know what it's doing, just not how it's doing it.
15:25:32 <Cale> well, really, (fs,id) is the initial value
15:25:34 <xerox> Cale: nicely nice....
15:25:51 <davidhouse> yes. we're using a pair here as our value.
15:26:21 <xerox> And feeding back in to the thunk when we jump :-)
15:26:25 <Cale> and every time through the loop, we take the first element off the list and compose it with the function, passing that back
15:26:38 <Cale> unless the list is empty, in which case we return our completed function
15:26:41 <davidhouse> it's walking down the list, accumulating into the composition chain
15:26:46 <Cale> yep
15:26:52 <xerox> But getCC* implementations look like magic.
15:28:38 <davidhouse> @hoogle getCC'
15:28:39 <lambdabot> No matches found
15:28:43 <davidhouse> @hoogle getCC
15:28:44 <lambdabot> No matches found
15:28:52 <davidhouse> oh, they're not builtins.
15:28:57 <Cale> well, the thing about the continuation monad is that you can always get hold of the "rest" of the computation
15:29:59 <davidhouse> Cale, one tiny thing, it should be g . f
15:30:06 <Cale> you think?
15:30:07 <dcoutts> flowolf, I said ghc-6.4.2, not ghc-bin.
15:30:13 <davidhouse> it depends how you define it, i suppose
15:30:15 <dcoutts> flowolf, or ghc-6.4.1-r3
15:30:23 <davidhouse> [f, g, h] -> h . g . f, not f . g. h
15:30:36 <davidhouse> at least, that's how the others behave.
15:30:41 <jip> (-) is a unary operator and a binary operator?
15:30:43 <dcoutts> flowolf, there is no ghc-bin-6.4.2 yet for most arches, including x86.
15:30:44 <Cale> oh, I see
15:30:49 <Cale> you're flipping (.)
15:30:51 <flowolf> dcoutts: ouch
15:31:00 <flowolf> dcoutts: well, I will wait
15:31:07 <flowolf> ghc takes too long to compile
15:31:09 <davidhouse> the idea is to feed a value in at the top and get it out at the bottom again.
15:31:12 <dcoutts> right, ok
15:31:17 <davidhouse> Cale, that's brilliant, thanks :)
15:31:32 <davidhouse> well, *get out the new value at the bottom
15:31:38 <Cale> davidhouse: you could also do one which acted on the value directly
15:32:03 <davidhouse> with recursion?
15:32:16 <Cale> compose fs x = runCont compose' id
15:32:16 <Cale>   where compose' = do
15:32:16 <Cale>             ((gs,y), jump) <- getCC' (fs,x)
15:32:16 <Cale>             case gs of
15:32:16 <Cale>                 []      -> return y
15:32:16 <Cale>                 (g:gs') -> jump (gs', g y)
15:32:24 <davidhouse> oh, with Cont.
15:32:26 <Cale> that's your direction too
15:32:57 <davidhouse> Cale, i need to include getCC and getCC' as well, i presume. well, at least the latter.
15:33:01 <Cale> yeah
15:33:14 <Cale> they *really* ought to be in the library
15:33:17 <Cale> but they're not
15:33:33 <Cale> using callCC directly is annoying
15:33:53 <davidhouse> i guess one more question
15:34:09 <davidhouse> have you ever used Cont for an actual problem? is it worth learning, in other words?
15:34:19 <Cale> it's overly powerful
15:34:42 <Cale> I usually wouldn't use it because it gives you too much potential for messing things up
15:34:51 <Cale> but it's worth looking at
15:35:36 <davidhouse> yeah, i guess so.
15:36:02 <Cale> x `modulo` m = (`runContT` return) $ do
15:36:02 <Cale>    (u, jump) <- getCC' x
15:36:02 <Cale>    lift $ print u
15:36:02 <Cale>    case u of
15:36:02 <Cale>      _ | u < 0     -> jump (u + m)
15:36:03 <Cale>        | u >= m    -> jump (u - m)
15:36:05 <Cale>        | otherwise -> return u
15:36:21 <Cale> that was a fun example
15:36:43 <Cale> in ContT IO
15:37:14 <davidhouse> this is a fairly typical paradigm for Cont?
15:37:25 <Cale> I suppose, yeah
15:37:35 <Cale> I haven't actually seen too much Cont code myself
15:38:45 <davidhouse> huh, if m is negative there that diverges :)
15:39:06 <Cale> ssh :)
15:39:07 <Cale> hehe
15:39:16 <Cale> yeah, I didn't handle that case
15:40:30 <davidhouse> and why are you passing return to runContT?
15:40:47 <davidhouse> @hoogle runConT
15:40:48 <lambdabot> Control.Monad.Cont.runCont :: Cont r a -> ((a -> r) -> r)
15:40:48 <lambdabot> Control.Monad.Cont.runContT :: ContT r m a -> ((a -> m r) -> m r)
15:41:24 <Cale> because it's the usual way to finish off a ContT computation
15:43:34 <Cale> It's kind of funny, using monads and higher order functions to simulate GOTO.
15:43:59 <davidhouse> and modulo ;)
15:44:35 <davidhouse> it's a bit pointless, because everything done this way could be done with recursion
15:45:23 <xerox> http://dsc.discovery.com/news/briefs/20060424/lizardbot_tec.html
15:53:08 <joe_k> i love how these people or the press apply "nanotechnology" everywhere now to make their research sound cool
15:53:20 <joe_k> that robot comes from the "nanorobotics" lab
15:53:27 <joe_k> well then why the hell can I see it?
15:54:54 <davidhouse> Cale, i probably didn't do the writeup justice, but your example is at http://haskell.org/haskellwiki/Compose
15:55:21 <davidhouse> it was a little tricky to stay as high-level as i had done with the other examples when the stuff is this complicated. :)
15:55:26 <davidhouse> anyway, i'm off to bed.
16:04:14 <xerox> Goodnight.
16:53:48 <thelsdj> 'moduloList i modulo start = (start * i) + modulo : moduloList (i modulo start+1)' gives me: 'unification would give infinite type' am i doing something wrong, or am i just not allowed to do this sort of thing?
16:54:42 <thelsdj> moduloList (3, 1, 0) would give [1,4,7,10,13,16,...]
16:57:18 <arjanb> aren't you missing some comma's?
17:00:07 <Cale> are you sure you want to apply i to modulo and start and then add 1 to it?
17:00:08 <arjanb> maybe you meant:  moduloList i modulo (start+1)
17:00:19 <Cale> (start * i) + modulo : moduloList i modulo (start+1)
17:00:24 <Cale> is what I think you mean
17:01:38 <thelsdj> got it, thanks
17:02:14 <thelsdj> now to figure out how to intersect these lazily
17:02:37 <thelsdj> playing with chinese remainder theorem
17:03:39 <jip> ghci really needs a clear command
17:05:07 <thedward>  why not do:  :!clear ?
17:05:39 <thedward> (well, I guess that assumes you are running it on something unixy)
17:08:51 <jip> hm... doh!
17:13:23 <thelsdj> i really need to use haskell more often, rocks my socks
17:13:54 <thelsdj> i only touch it a couple times a year, usually when i'm fiddling with some math idea that came into my head
17:17:34 <dons> its a general purpose programming language, after all..
17:18:08 <thelsdj> yea, i've just never gotten comfortable enough with it
17:55:58 <thelsdj> aww darn, my very purdy haskell solution to this problem is waaaay slower than python version
17:56:09 <thelsdj> probably my fault though
17:58:13 <dons> it's usually fairly easy to make haskell way faster than python. haskell's compiled and optimised, after all.
17:58:36 <dons> you want to post the code somewhere, and i'll give you some hints.
17:58:41 <dons> lisppaste: url
17:58:41 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:59:18 <thelsdj> actually, that was with hugs, ghc seems way faster, let me test harder one to be sure
17:59:26 <dons> oh. 
17:59:33 <dons> yes, hugs is a slowish interpreter.
17:59:44 <dons> ghci would be faster, since it uses compiled libraries
17:59:50 <dons> ghc -O would be even faster still
18:00:15 <dons> since you'd then be compiling your code application to machine code, not just the lirbaries it uses
18:01:35 <thelsdj> haskell is still 10s vs 0.8s in python, i'll post code
18:02:29 <lisppaste2> thelsdj pasted "chinese remainder stuff" at http://paste.lisp.org/display/20020
18:02:56 <dons> you compiled with -O ?
18:03:03 <thelsdj> yes
18:03:09 <dons> ah, I see some things. gimme a sec.
18:09:21 <Lemmih> vincenz: pong.
18:15:41 <lisppaste2> dons annotated #20020 with "Strictify, profile, read the core" at http://paste.lisp.org/display/20020#1
18:15:51 <dons> thelsdj: got it down to 1.9s here.
18:16:07 <dons> still, can't help but think its actually computing more things than the python version. 
18:16:30 <Cale> moduloList i modulo start = [first, first + i..]
18:16:30 <Cale>     where first = start * i + modulo
18:16:30 <eivuokko> On http://cvs.haskell.org/trac/ghc/wiki/DebuggingGhcCrashes , in the gdb output 0x2ae9697ccbf8: 0x40b8c8 <GHCziBase_plusInt_info+32>, is the <foo+n> calculated by gdb?
18:16:34 <dons> if you reimplement exactly the python code, it would probably runs several times faster in compiled haskell. though not as pretty.
18:16:59 <dons> oh good idea. Cale
18:19:05 <lisppaste2> dons annotated #20020 with "Tweaks" at http://paste.lisp.org/display/20020#2
18:19:21 <Cale> what is this actually doing?
18:19:35 <thelsdj> Cale: nothing useful :)
18:19:41 <thelsdj> atleast not in this form
18:20:27 <thelsdj> this is the product of me counting stacks of pennies on my desk to find out how many pennies i had, by only using the # of equal sized stacks and the remainder
18:20:36 <dons> alos, I compiled with -O -optc-O3. anyway. there's a few hints to work with.
18:20:42 <Cale> stepsDo looks like it needs some transformation
18:21:13 <dons> the worst functions are:
18:21:14 <dons> lazyIntersect                  Main                  50.0   16.1
18:21:14 <dons> moduloList                     Main                  31.6   49.7
18:21:15 <dons> steps                          Main                  18.4   34.2
18:21:15 <Cale> dons strictified it which is one option at least
18:21:33 <dons> time in the first column.
18:21:58 <dons> just enough strictness to unbox the arguments.
18:23:15 <dons> thelsdj: would be interesting to see the python version.
18:23:36 <thelsdj> sure holdon
18:24:32 <lisppaste2> thelsdj pasted "chinese remainder in python" at http://paste.lisp.org/display/20022
18:26:33 <dons> what's xrange do?
18:26:44 <lisppaste2> thelsdj annotated #20022 with "quick cleanup" at http://paste.lisp.org/display/20022#1
18:27:32 <thelsdj> makes an iterator from 1 to limit
18:27:46 <dons> ok.
18:27:49 <thelsdj> it gets used up pretty quickly though, on first pass it actually generates a list from 1 to 1mil
18:27:59 <Cale> why not [1..limit] rather than [1..] ?
18:28:33 <dons> and yield does?
18:28:56 <Cale> dons: returns a value, but continues there when the function is called again
18:29:09 <Cale> (roughly)
18:29:15 <dons> oh my god.
18:29:33 <Cale> well, it's a generator
18:29:45 <dons> yeah, : will do.
18:30:18 <thelsdj> making it [1..limit] seems to break the program
18:30:41 <thelsdj> ah cause it will never find one greater than the limit
18:30:42 <Cale> it does?
18:30:48 <thelsdj> which is when we know to end
18:30:56 <Cale> right, you also have to change the condition of course
18:30:57 <thelsdj> so stepsDo would need to be changed
18:31:07 <Cale> to the same condition you used in the python program
18:31:43 <thelsdj> down to 0.4s :)
18:33:30 <thelsdj> 0.26 with optimize
18:33:50 <thelsdj> now question is can it handle a higher limit than python
18:33:52 <Cale> narrow possiilities arg = [i | i <- possibilities, let (stacks, remainder) = arg, i `mod` stacks == remainder]
18:34:21 <Cale> let's get a closer approximation to the python code :)
18:34:52 <thelsdj> well the whole point was to make it different from the python code :)
18:35:08 <thelsdj> but yea a good lesson
18:38:12 <Cale> hmm
18:38:18 <thelsdj> 0.17s
18:39:16 <dons> narrow ps stacks remainder = go ps
18:39:16 <dons>     where go []     = []
18:39:19 <dons>           go (i:xs) = if i `mod` stacks == remainder then i : go xs else go xs
18:39:19 <dons> steps_prime n limit = go [1..limit] [2,3,5,7,11,13,17,19,23,29]
18:39:19 <dons>     where go _ []     = error "False"
18:39:19 <dons>           go p (i:xs) = let p' = narrow p i (n `mod` i)
18:39:19 <dons>                         in if length p' == 1 then i else go p' xs
18:39:22 <dons> main = print (steps_prime 31 1000000)
18:39:52 <dons> unoptimised, but at least it does the same as the python code.
18:39:59 <dons> you could probably tune it further.
18:40:00 <Cale> dons: why in helper functions?
18:40:09 <dons> oh, just translating the python
18:40:21 <Cale> ah, okay
18:41:08 <Cale> I'd probably translate narrow as above -- it's essentially the same as something written in the list monad. (at least once he applies list to it)
18:42:33 <dons> narrow ps st rem = [ i | i <- ps, i `mod` st == rem ]
18:42:40 <Cale> yep
18:44:07 <dons> default(Int) and -optc-O3 also helps.
18:44:30 <Lemmih> How fast is the final code?
18:44:43 <eivuokko> Anyone know how to find out how deep ghc/haskell stack is from a breakpoint situ?
18:45:07 <thelsdj> thanks guys, i'm out, gotta spend some time later trying to understand all this :)
18:46:01 <thelsdj> Lemmih: last one i tried was 4-5x faster than python
18:46:09 <thelsdj> though i haven't done some of those final changes
18:47:18 <Lemmih> eivuokko: There is no stack.
18:47:33 <eivuokko> Lemmih, there is haskell stack.
18:48:01 <eivuokko> Stg stack or whatever the correct name is.
18:49:10 <Cale> how do you get a breakpoint?
18:49:16 <Lemmih> There's only the stack you push closures to. There's no call stack.
18:49:44 <eivuokko> Yes, that's what I mean
18:50:29 <lisppaste2> dons annotated #20022 with "Final" at http://paste.lisp.org/display/20022#2
18:50:56 <ihope_> How easy would it be to make GHC churn out Java?
18:51:02 <Lemmih> eivuokko: Oh, why are you interested in that stack?
18:51:05 <eivuokko> I would like to know how many entries that closure stack has.  (and it btw seems to have other stuff too)
18:51:12 <dons> thelsdj: can you try the version I just posted. I'd like to see how it runs on your box.
18:51:21 <eivuokko> Lemmih, to get evaluation trace
18:51:34 <dons> anyway, there's no magic to any of this. just lists and recursion. 
18:51:48 <dons> the semantics are a lot clearer than the python version too, with its yields and lists and xranges
18:51:55 <eivuokko> Lemmih, I wrote a program sets breakpoints on debugged program at _info-symbols.
18:52:21 <eivuokko> Lemmih, I can print top of the stack now, but I have no idea how many entries are valid.
18:52:39 <eivuokko> (programmatically anyway)
18:55:38 <tessier_> * Lemmih :: Haskell is the best glue language I know. It's like super-glue.
18:56:10 <tessier_> What makes Haskell a good glue language? When I think of glue language I think of something like perl or more recently python
18:57:27 <audreyt> haskell is good because it has 50,000 libraries, which is more than perl and python combined! </troll>
18:58:04 <audreyt> (though to be fair, we are working on that :))
18:58:13 <tessier_> My question, however, was not a troll. :)
18:58:34 <tessier_> So far Haskell's biggest attraction to me is more provably correct code.
18:58:44 <ihope_> "How do I spawn a terminal window?" "Simple: you write a binding to the Windows API..."
18:58:46 <Lemmih> tessier_: Static typing and decent higher-order functions makes me prefer Haskell.
18:58:49 <audreyt> I was trolling because I don't think haskell is a good glue language :)
18:59:01 <tessier_> And the functional programming concept of describing the problem rather than the implementation of the solution
18:59:06 <tessier_> audreyt: I see.
18:59:07 <audreyt> it's good when you have 1)already prototyped, or got a spec and thus 2)know what you are doing
18:59:25 <tessier_> audreyt: What do you prototype in?
18:59:30 <audreyt> it's very, very bad when you don't have any idea about how to solve the problem, or have no idea what the problem is
18:59:37 <audreyt> nowadays, perl6 with perl5 modules
18:59:39 <Lemmih> I disagree.
19:00:04 <audreyt> Lemmih: if there are more ready-made haskell libraries, then it would not be bad
19:00:18 <audreyt> mostly, when faced with a problem I have no idea about, I look at other people's code.
19:00:32 <tessier_> So perhaps lisp, python, scheme, and even perl are better suited for the sort of "exploratory programming" you do when prototyping and figuring out what it is that you need to do?
19:00:34 <audreyt> it's more often to see ready-made python or perl code to solve that glue-problem than haskell code
19:00:51 <Lemmih> audreyt: The number of libraries doesn't change how sticky Haskell is.
19:00:53 <audreyt> it's not a haskell-as-a-language problem, despite my trolling
19:01:03 <Lemmih> audreyt: It only changes /what/ you can stick to it.
19:01:16 <audreyt> I agree, but to me the vocabulary is the language.
19:02:08 <audreyt> I happen to think classical Chinese has one of the most beautiful grammars and syntactic structures
19:02:14 <audreyt> but I can't write a CS paper with it :)
19:02:30 <audreyt> or, if I did, no-one can parse that.
19:03:39 <Lemmih> I'm not that pragmatical (:
19:04:12 <audreyt> :)
19:04:52 <dons> its good glue in the sense that the strong static typign means you can grab other people's code and just use it, without worrying abotu secret hidden conventions of that code. the types describe what that code does. i wouldn't doubt there's more reuse in haskell than elsewhere.
19:05:30 <eivuokko> Haskell also have good abstractions for small things, not just big things like many other languages.
19:06:16 <dons> and reuse in large systems seems easier in haskell, due to the typing again, as we saw in last year's icfp.
19:06:49 <Cale> oh, hehe
19:08:06 <dons> i don't think anyone was able to rewrite their perl or python programs to use the new spec, in one day, but something like 75% of the haskell entries did get rewritten 
19:08:41 <dons> and although some of the C entries got rewritten to the new spec, they _all_ had bugs, that lead to segfaults or protocol failures under testing.
19:09:34 <dons> so, if you have a big system, that needs to be maintained or modified, you really want machine checking of that code. and haskell is going to give you more machine checking (via typing) than you get anywhere else.
19:09:41 <Cale> > let primes = [2,3,5,7,11,13,17,19,23,29] in head [p | (p,n) <- zip primes (drop 1 . scanl (*) 1 $ primes), n > 1000000]
19:09:42 <lambdabot> 19
19:09:44 <Cale> heh
19:09:46 <dons> hehe
19:09:53 <Cale> that's all it is
19:09:55 <dons> dear oh dear.
19:10:20 <Cale> (well, it works out that way, anyway, since the primes are all coprime)
19:10:49 <Cale> really, I should be taking the lcm
19:11:02 <Cale> let primes = [2,3,5,7,11,13,17,19,23,29] in head [p | (p,n) <- zip primes (drop 1 . scanl lcm 1 $ primes), n > 1000000]
19:11:02 <dons> $ time ./a.out
19:11:03 <dons> 19
19:11:04 <Cale> there :)
19:11:05 <dons> ./a.out  0.00s user 0.00s system 0% cpu 0.003 total
19:11:08 <dons> ;)
19:11:29 <Cale> I knew that with a little thought, you could optimise the hell out of that :)
19:12:19 <Cale> thelsdj: you still around? :)
19:12:47 <dons>     $( let x = head [p | (p,n) <- zip primes (drop 1 . scanl (*) 1 $ primes), n > 1000000]
19:12:51 <dons>            primes = [2,3,5,7,11,13,17,19,23,29]
19:12:53 <dons>        in [| x::Int |] )
19:12:56 <dons> ;)
19:12:59 <Cale> hehe
19:13:47 <Cale> I wrote a solver for simultanous congruences of integers before realising that's all it was :)
19:15:27 <dons> actually, we should play this $() trick on newbies more often.
19:15:35 <Cale> heh
19:15:51 <dons> slow compiler, but DAMN FAST CODE!
19:15:55 <Cale> hehe
19:19:47 <tessier_> dons: Doesn't python have typing? It is dynamically but strongly typed and uses duck typing.
19:20:03 <Cale> it does
19:20:15 <dons> static typing is the point. you won't find out about the bug until it fails at runtime
19:20:17 <Cale> its type system is somewhat crazy though
19:20:35 <Cale> (and yeah, static typing is way cooler)
19:21:03 <dons> whereas, particularly in a conte, you want to know about the bugs in your program before you submit, but you don't have time to leave it running to uncover the runtime type issues.
19:21:10 <dons> s/conte/contest/
19:21:11 <tessier_> conte?
19:21:12 <tessier_> oh
19:21:47 <dons> this is probably one of the reasons dynamically typed languages have such trouble in the 3 day hack fest that is icfp 
19:21:49 <tessier_> How could you run into a runtime type issue with dynamic but static typing? Once something is used it is typed. 
19:21:59 <dons> they can get something submitted, but fail again and again under testing.
19:22:10 <dons> whereas in the real world, this is expected. and then you fix the issue.
19:22:25 <dons> ideally though, you don't let the bugs in in the first place.
19:22:56 <Cale> The neat thing about Haskell is that to an almost unreasonable extent, programs that compile actually work.
19:23:07 <eivuokko> Indeed
19:23:57 <dons> a runtime type issue might be something like convertD[D[D[D[D[D[D[D[D[D[Ding an array to a scalar. this would might be an error, or it might not be, who knows until something weird happens in your code.
19:24:15 <dons> sorry about the byte noise there. my wacky wifi/irssi interaction.
19:25:21 <Cale> What is actually happening with your wifi there?
19:25:22 * bsmntbombdood wants to know what static typing is
19:25:45 <Cale> bsmntbombdood: The compiler checks the types of everything as it compiles the program.
19:26:05 <Cale> (it doesn't just insert checks to be done once the program is running)
19:26:06 <bsmntbombdood> doesn't that happen in a language like C ?
19:26:10 <Cale> it does
19:26:14 <dons> Cale, I think we worked out that a lag of a particular length turns of irssis's meta-char interpretation. such that literals go through literally, rather than being interpreted.
19:26:19 <dons> off.
19:26:19 <Cale> but C's type system is really inexpressive
19:26:32 <mlh> bsmntbombdood: there is strong/weak   dynamic/static
19:26:52 <dons> so particularly if I hit 'Del', and the lag is just so, the escape chars end up in the output buffer. 
19:27:26 <mlh> C's is static but not very strong
19:27:36 <dons> hmm. darcs 1.0.7 seems noticeably faster. is this possible?
19:27:40 <eivuokko> Yes
19:27:57 <dons> ?karma+ darcs
19:27:57 <lambdabot> darcs's karma raised to 2.
19:27:59 <bsmntbombdood> mlh: I don't get what you mean
19:28:06 <eivuokko> There's been a lot of optimisations to darcs lately, and probably a punch of them get to release.
19:28:24 <Cale> It is "strongly" typed, but you can do arbitrary casts, which sort of ruins things.
19:28:25 <dons> cool. i should push back more fps improvements.
19:29:04 <eivuokko> Oh, btw, what was there to readi n generate?  It's like as safe as ForeignPtr is?
19:29:14 <mlh> bsmntbombdood: long l;int i; ...;i = l; compiler won't complain but there could be problems
19:29:40 <dons> eivuokko: sorry, don't understand the question.
19:29:55 <Cale> Also, you can't express as much with C's types. For example, if I have a Haskell function of type [a] -> [a], I know that it can't do anything with the elements of the list -- basically, it's going to rearrange or drop some elements, but it's not dependent on their values.
19:30:04 <Cale> I can't say that with C types.
19:30:19 <eivuokko> dons, the new generate function in ByteString, it looks good.
19:30:26 <dons> ok good :)
19:30:40 <dons> but what did you mean about 'readi'? and safe as ForeignPtr?
19:31:07 <eivuokko> read
19:32:02 <Cale> (and I certainly can't get the compiler to check it)
19:33:17 <bsmntbombdood> but with haskell, a function doesn't have a type i thought?  (I'm new)
19:33:28 <Cale> all values and functions have types
19:33:38 <dons> > id :: Int -> Int
19:33:39 <lambdabot> <Int -> Int>
19:33:42 <Cale> you don't have to write the types down in your code if you don't want to
19:33:55 <dons> > ord
19:33:56 <lambdabot> <Char -> Int>
19:34:10 <Cale> since the compiler can infer them -- and it will check that whatever types you write match the ones it infers
19:34:10 <dons> types for all! and forall types!
19:34:14 <bsmntbombdood> but you can write a function that takes any type as its argument
19:34:37 <Cale> yeah, but it won't be able to do much with that value
19:34:43 <Cale> (it can't look at it)
19:34:52 <dons> yes :) parametic polymorphism. its a great thing. and its still strongly, statically typed.
19:34:57 <Cale> @type let f x = [x] in f
19:34:58 <lambdabot> forall a. a -> [a]
19:35:02 <dons> ?type length
19:35:03 <lambdabot> forall a. [a] -> Int
19:35:08 <Cale> good example
19:35:14 <Cale> length takes any type of list
19:35:24 <Cale> but as a result, it can't look at the list elements themselves
19:35:29 <Cale> only at the list structure
19:35:38 <Cale> (and that's guaranteed by the compiler)
19:35:44 <bsmntbombdood> ok
19:35:45 <dons> the type in fact guarantees that length won't look at the elements.
19:35:49 <bsmntbombdood> I get what you mean
19:36:01 <bsmntbombdood> that is pretty cool
19:36:18 <dons> sometimes I feel like Cale's twin. completing each other's sentences.
19:36:22 <Cale> heh
19:37:30 <Cale> > zipWith (-) (map ord "dons") (map ord "cale")
19:37:31 <lambdabot> [1,14,2,14]
19:37:34 <Cale> hmmm...
19:37:45 <Cale> heh
19:38:08 <araujo> Hi all
19:38:41 <dons> hmm. highly suspicious.
19:42:31 <araujo> hola dons 
19:50:22 <dons> hey araujo .
19:51:55 <hyrax42> is bind left associative?
19:52:32 <dons> infixl 1 >>=
19:52:36 <dons> try :info in ghci
19:53:14 <hyrax42> infixl = left associative?
19:53:19 <Cale> yeah
19:53:29 <hyrax42> and the 1 is... fixity?
19:53:33 <Cale> yep
19:54:01 <hyrax42> I hope I'm not asking too many questions all the time
19:54:07 <Cale> it's fine :)
19:54:12 <dons> nah. all good.
19:54:30 <dons> i'm just context switching between 3 things, so i was a bit brief. sorry.
19:54:49 <hyrax42> oh wasn't a reaction to anything
19:54:55 <hyrax42> just I realised I'm always asking things
19:55:08 <hyrax42> one day I'll get to answering...
19:55:20 <dons> sure. this is a learning channel, so we like questions. gives us reasons to waste time 
19:55:27 <dons> ;)
19:55:29 <hyrax42> cool
19:55:38 <hyrax42> well I've got another :p
19:56:06 <hyrax42> this is from all about monads, where father, mother :: Sheep -> Maybe Sheep
19:56:14 <hyrax42> (cloning...)
19:56:30 <Cale> yep
19:56:42 <hyrax42> I'm asked to write grandParent which give any one grandparent
19:56:47 <hyrax42> and I have this:
19:56:54 <hyrax42> grandParent s = foldr mplus Nothing [return s >>= father >>= mother, ...]
19:57:05 <Cale> okay
19:57:17 <Cale> msum
19:57:33 <Cale> or, you could do it in stages
19:57:39 <Cale> write parent first
19:58:23 <hyrax42> msum?
19:58:27 <Cale> yep
19:58:42 <Cale> > msum [Nothing, Nothing, Just 5, Just 6]
19:58:42 <lambdabot> Just 5
19:58:51 <Cale> @type msum
19:58:52 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
19:59:00 <hyrax42> well I'd ideally like to not have to write the list out
19:59:04 <Cale> > msum [[1,2,3],[],[],[4,5]]
19:59:05 <lambdabot> [1,2,3,4,5]
19:59:10 <Cale> right, you don't have to
19:59:12 <hyrax42> I tried all sorts of foldM map fold god knows what else
19:59:19 <Cale> it's easier than that
19:59:24 <Cale> write parent -- that's easy
19:59:33 <Cale> then use parent to write grandparent
20:00:24 <hyrax42> hrm
20:00:38 <hyrax42> parent s = msum [mother s, father s]?
20:00:53 <Cale> yep
20:01:03 <Cale> or just mplus, you only have two things
20:02:04 <RyanT5000> is there a version of a Hidden Markov Model where you are not given the state machine or the states at all?
20:02:19 <RyanT5000> only a chain of observations
20:02:35 <RyanT5000> and you try to figure out how many states there are and how they're connected
20:03:08 <hyrax42> what about a "nice" way to apply a list of functions to a single value
20:03:41 <hyrax42> someone (I forget who) gave ((. return) . ap)
20:03:53 <Cale> map ($ 1) [\x -> x + 1, id, \x -> (x+1)^4]
20:03:55 <Cale> > map ($ 1) [\x -> x + 1, id, \x -> (x+1)^4]
20:03:56 <lambdabot> [2,1,16]
20:03:59 <dons> > let fs = [ id, subtract, (+3) ] in map  fs (repeat 8)
20:04:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:04:00 <lambdabot>   Expected type: (t -> t1) -> t -> t1
20:04:00 <lambdabot>   Inferred type: (t -> t1) -> (t -> t1) -> t -> t1
20:04:19 <dons> Cale wins this round.
20:04:20 <Cale> zipWith ($) ?
20:04:34 <Cale> > zipWith ($) [\x -> x + 1, id, \x -> (x+1)^4] (repeat 1)
20:04:35 <lambdabot> [2,1,16]
20:05:10 <hyrax42> ah lazy
20:05:11 <hyrax42> silly me
20:05:16 <hyrax42> I tried something liek that but used replicate
20:05:57 <hyrax42> thanks... I'll be back ;)
20:10:22 <LordBrain> lazy has a whole new meaning in this room ;)
20:13:34 <araujo> It is good to be lazy in he functional world!!
20:13:42 <araujo> the
20:13:45 <araujo> :-)
20:19:37 * juhp imports gtk2hs into Fedora Extras cvs :-)
20:31:58 <SamB> @where ZMachine
20:31:58 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
20:41:25 <hyrax42> > join (*) 10
20:41:27 <lambdabot> 100
20:41:46 <hyrax42> I get a no instance for (Monad ((->) a)) error in ghci
20:41:54 <Cale> import Control.Monad.Reader
20:42:02 <hyrax42> ah
20:42:12 <Cale> (that really ought to be in the Prelude, but isn't)
20:44:33 <sjanssen> dons: how long until I get "ByteString and the petabyte barrier" in my mailbox?
20:44:46 <Cale> haha
20:52:35 <Smokey`> quick question, does haskell support binary literals?
20:52:47 <dons> sjanssen: hehe.
20:53:04 <dons> Smokey`: nope. but its easy enough to fake with lists, i think.
20:53:27 <Smokey`> aye, I can imagine doing a binary literal via a list and list comprehension...
20:54:22 <skew> I think you can do #"text" to get constant data
20:55:59 <dons> you can get unboxed string literals with "foo"#, ghc only.
20:56:13 <dons> but it depends on what you mean by binary literals, here, I thinkk
20:56:39 <dons> you mean 010101, or unboxed literals?
20:56:54 <dons> i think he means the former.
21:15:25 <vincenz> o.O
21:15:27 <vincenz> freaky
21:16:08 <vincenz> I had a very freaky experience last night 
21:16:21 <heatsink> hmm?
21:16:35 <vincenz> I think I had a rem cycle, or at least the onset of it while awake
21:17:16 <vincenz> my heart started beating faster and faster, I started breathing faster and faster; almost in panic, finally I had to open my eyes, and I defeated the purpose of what I was doing, which was trying to get myself willfully to sleep
21:17:28 <vincenz> and my eyes automatically flickered back and fro
21:18:11 <dons> i think these are called night terrors, sometimes. rem just as you fall asleep, or before
21:18:25 <heatsink> So you can sleep at will?
21:18:26 <vincenz> I was actively pursuing the concept of sleep
21:18:28 <vincenz> no
21:18:33 <vincenz> but I was trying to force myself
21:18:38 <vincenz> by regular breathing and stilling my mind
21:18:53 <vincenz> cause I typically take REALLY long to fall asleep and my mind is filled with too many thoughts
21:19:02 <vincenz> btw, do any of you people hear noise in your head?
21:19:12 * vincenz hears a constant highfrequence noise
21:19:21 <vincenz> got louder too as I tried to get asleep
21:19:30 <vincenz> like I could hear every single drop of blood flowing through my brain
21:19:52 <vincenz> kind of like the noise a tv makes when it's tuned to a nonchannel
21:19:58 <vincenz> but a bit softer and higher pitch
21:20:57 <Cale> vincenz: I hate that TV noise
21:21:10 * vincenz is going to try to fall asleep tonight again on purpose, which will be more/less difficult, not really sure as I will surely be tired (read until 1am... tried to get to sleep for quite a while (I remember 3am on my alarm clock) got up at 6am
21:21:15 <heatsink> You mean, like "static"?
21:21:15 <vincenz> Cale: so you have it too?
21:21:17 <Cale> I don't hear the other one you refer to though.
21:21:18 <vincenz> heatsink: yeah
21:21:23 <Cale> not static
21:21:32 * vincenz hears static in his ears
21:21:34 <Cale> It's just a high-pitched whine.
21:21:46 <Cale> When the tv is powered but, say, muted.
21:21:50 <heatsink> No, but I get the tinnitis sound occasionally.
21:22:02 <heatsink> vincenz: is it louder than swallowing?
21:22:12 <vincenz> heatsink: depends how you swallow I guess
21:22:17 <vincenz> it can get pretty loud on occasions
21:22:34 * vincenz hears it now over his computer fan which is quite loud
21:23:29 <vincenz> maybe I should see a sleep doctor
21:23:37 <vincenz> it's not normal it takes me 1-2 hours daily to fall asleep
21:24:06 <vincenz> although I gotta say that the atctive pursuit of sleep last night does make me more refreshed than I'd typically be for the short time I actually spent in bed
21:24:11 * vincenz will experiment more
21:24:27 <vincenz> maybe I should blog it?
21:24:28 <vincenz> it's kinda cool
21:24:41 <vincenz> sometimes you kinda feel yourself falling as you lose more and more contact with your body
21:24:56 <vincenz> except the one REM freak accident
21:25:10 <vincenz> then I tried to regain that state after that panic, tho it took me a bit, but I couldn't push it too far :(
21:25:42 <vincenz> one annoying thing is that it's hard to think about breathing while doing this, basically forcing you to control it constantly
21:25:57 <vincenz> cause as soon as you say "stop making yourself breathe" you stop to breathe altogether
21:26:13 <vincenz> err, hard not to think about breathing
21:26:33 <vincenz> heatsink: think this would be interesting for a blog?
21:27:48 <sethk> vincenz, for sleeplessness I recommend 15 minutes of the Stroustrup C++ book, particularly the sections about the standard template library
21:27:50 <heatsink> yea, psychosomatic powers are always interesting
21:28:00 <vincenz> sethk: :D
21:28:24 <vincenz> anyways, anyone hear static in their ear?
21:28:35 <vincenz> sometimes I fear it's that effect that makes your head blow up
21:28:42 <vincenz> (electrostatic charging form overthinking)
21:28:52 <vincenz> s/form/from
21:29:00 <sethk> vincenz, if your head blows up, please don't tell us about it.  I'm sensitive
21:29:08 <vincenz> sethk: I've heard it happens
21:29:19 <vincenz> apparently some famous chess player blew his head up at a chess game watched by many
21:29:21 <sethk> vincenz, don't believe everything that you hear  :)
21:30:03 <vincenz> sethk: I don't think it's that (cause otherwise last night as I actively pursued sleep I wouldn't have focussed on trying to get it louder which seemed to get me deeper into sleep)
21:30:20 <vincenz> kinda like a homing beacon :D
21:30:22 <sethk> too metaphysical for me
21:31:45 <heatsink> @fact-set gibbardish To the casual reader, Gibbardish is virtually incomprehensible, yet alludes of a deep philosophical significance just outside one's understanding.
21:31:45 <lambdabot> Fact recorded.
21:32:07 <vincenz> http://www.mit.edu/~mkgray/head-explode.html
21:32:22 <vincenz> sethk: what is metaphysical about what I said
21:32:32 <vincenz> from that page:  Do you ever hear a faint ringing or humming sound in your ears? (It could be the sound of electricity in the skull cavity.)
21:33:17 <Lemmih> vincenz: pong.
21:33:57 <vincenz> Lemmih: hello, you're up early
21:34:02 <vincenz> @localtime Lemmih 
21:34:04 <lambdabot> Local time for Lemmih is Mon May 15 06:34:10 2006
21:34:09 <vincenz> hmm, same timezone
21:34:32 <vincenz> heatsink: yeah I think it's tinnitus, except I don't really have hearing loss
21:34:38 <vincenz> Lemmih: my question regarding GHC
21:34:46 <vincenz> Lemmih: do you think theyll have something like
21:35:08 <vincenz> data Test = Foo | Bar Int | Plop String deriving (Checkable)
21:35:12 <vincenz> which then automatically leads to
21:35:15 <vincenz> isFoo :: Test -> Bool
21:35:19 <vincenz> isBar :: Test -> Bool
21:35:24 <vincenz> isPlop :: Test -> Bool
21:36:51 <Lemmih> Simon Marlow posted some code like that on the mailing-list some time ago. I'll see if I can find it.
21:37:38 <vincenz> Lemmih: TH-based?
21:37:54 <Lemmih> No, regular haskell98.
21:38:15 <vincenz> Lemmih: and concerning TH, is it like camlp4 such that there is a two compilation process, first compile the camlp4 preprocessor, then compile the sources with this preproccessor as extra compilation step
21:38:39 <vincenz> or can it be done in one compilation ?
21:41:02 <dons> TH code is expanded lazily during compilation, iirc.
21:41:30 <dons> so its effectively an interleaved preprocessor that runs before type checking, i think.
21:41:40 <vincenz> dons: thank you
21:42:05 <dons> its not like camlp4, in that it gives you a full haskell compiler inside the compiler. you can run arbitrary haskell code inside ghc, during compilation.
21:43:31 <vincenz> dons: hmm, to be correct, camlp4 also allows arbitrary ocaml code
21:43:56 <vincenz> dons: can you use it to generate new syntax?
21:44:17 <vincenz> not that that is my aim, just curious
21:44:43 <vincenz> (tho camlp4 is a HORROR to use)
21:44:46 <dons> ah, didn't know that.
21:45:00 <Lemmih> Hm, I can't find the mail.
21:45:29 <dons> yes, I think you could quite easily transform given identifiers such that they behaved as new syntax
21:45:38 <lispy> camlp4 uses macro expansions to provide source to source transformations right?
21:45:50 <vincenz> lispy: correct
21:46:39 <vincenz> basically you can use it to alter the parser
21:47:34 <dons> ah, I don't think TH can be used as a parser meta programming langauge. it manipulates already-parsed syntax trees
21:47:39 * vincenz nods
21:47:51 <dons> so you couldn't introduce syntax that wasn't already legal
21:48:04 <vincenz> well the language design of haskell does make it that functions and code blocks are nearly identical
21:48:07 <vincenz> so I'm not too upset with that
21:48:13 <vincenz> err
21:48:16 <vincenz> fucntions and code constructs
21:48:17 <dons> yeah, the syntax is already very flexible.
21:48:30 <vincenz> this also explains why it can be done in a single pass
21:48:37 <vincenz> :)
21:48:41 <dons> its all expressions.  
21:48:49 <vincenz> yup yupyup
21:49:18 <lispy> if multiple passes were allowed could the types system or pattern matching be more powerful?  like non-linear patterns?
21:49:55 <lispy> actually, that probably doesn't make sense, because i guess patmatching is mostly a run-time thing
21:50:12 <dons> well, you can desugar patterns in new ways, I suppose.
21:50:57 <vincenz> @hoogle simpleM
21:50:58 <lambdabot> Language.Haskell.TH.Lib.simpleMatch :: Pat -> Exp -> Match
21:51:25 <dons> ?karma+ hoogle -- didn't think it'd find that.
21:51:25 <lambdabot> hoogle's karma raised to 2.
21:55:24 * vincenz sighs as still noone has answered his message about dynamically stackable monads
21:57:58 <vincenz> what does 'reify' mean?
22:00:31 <edwinb> In general? "Make a Thing out of another thing".
22:00:31 <vincenz> I just browsed through the   Template metaprogramming for Haskell, by Tim Sheard and Simon Peyton Jones, May 2002 paper
22:00:39 <vincenz> skimming over the theoretic part
22:00:50 <vincenz> there is mention of qIO being feasible but a policy choice, in the end was it done?
22:00:57 <vincenz> qIO :: IO a -> Q a
22:02:26 <dons> sure.
22:02:30 <dons> but its hella scary
22:02:40 <dons> we have to explicitly disallow it in lambdabot
22:02:50 <vincenz> well erm
22:02:53 <vincenz> lambdabot allows TH?
22:03:05 <vincenz> and I can see why it's scary
22:03:09 <vincenz> you can make IO dissapear into another monad
22:03:13 <dons> > $( let x = head [p | (p,n) <- zip primes (drop 1 . scanl (*) 1 $ primes), n > 1000000] ;  primes = [2,3,5,7,11,13,17,19,23,29]     primes = [2,3,5,7,11,13,17,19,23,29]
22:03:13 <lambdabot>  parse error on input `='
22:03:18 <dons>        in [| x::Int |] ) 
22:03:20 <dons> argh
22:03:24 * vincenz snickers
22:03:39 <dons> > $( let x = head [p | (p,n) <- zip primes (drop 1 . scanl (*) 1 $ primes), n > 1000000] ;  primes = [2,3,5,7,11,13,17,19,23,29] in [| x::Int |] )
22:03:41 <lambdabot> 19
22:03:43 <dons> hehe
22:03:57 <dons> yeah, you can do TH, but no refiy or *IO
22:05:06 <vincenz> > let swap (a,b) = [| (b,a)] in let foo (x,y)= $(swap (x,y)) in foo (4,5)
22:05:06 <lambdabot>  parse error on input `]'
22:05:13 <vincenz> > let swap (a,b) = [| (b,a) |] in let foo (x,y)= $(swap (x,y)) in foo (4,5)
22:05:14 <lambdabot>   GHC stage restriction: `swap'
22:05:14 <lambdabot>   is used in a top-level splice, and must be imported, not defined locally
22:05:14 <lambdabot>   In the definition of `foo': foo (x, y) = $[splice](swap (x, y))
22:05:18 <dons> hehe
22:05:21 <vincenz> ?
22:05:25 <dons> ghc upstaged   you ;)
22:05:30 <sethk> dons, I just sent you an email.  (I'm sure you are thrilled  :)  )
22:05:30 <vincenz> meaning?
22:05:36 <dons> sethk: i like mail.
22:05:49 <sethk> dons, let me know if it isn't clear.
22:05:49 <vincenz> dons: what does that mean?
22:05:52 <dons> vincenz: there's staging restrictions, otherwise TH doesn't make sense.
22:05:55 <vincenz> ???
22:05:55 <lambdabot> Maybe you meant: . id pl v wn
22:06:02 <dons> i made a little joke about 'upstage'/stage
22:06:02 <vincenz> so what is wrong?
22:06:15 <vincenz> how would I fix that example?
22:06:35 <dons> top level splices need  to be imported, I guess. you'll need to check with a TH expert for the precise details of the top-level thingy
22:06:52 <edwinb> I thought that was just a feature of the implementation
22:07:01 <edwinb> it's not a necessary feature of staging, just the way TH does it.
22:07:08 <dons> well, the top-level thing probably is a feature
22:07:10 * vincenz scratches his hea
22:07:11 <edwinb> But I'm not a TH expert ;)
22:07:15 <vincenz> so how do I make it work?
22:07:25 <dons> staging restrictions in general aren't though. you need to deal with staging to make any meta programmign system sane.
22:07:33 * vincenz has no clue what staging is
22:07:33 <edwinb> put swap in another module... difficult in lambdabot I realise...
22:07:48 <dons> or in the same decl, perhaps
22:08:16 <vincenz> > let swap (a,b) = [| (b,a) |] in  $(swap (4,5))
22:08:16 <lambdabot>   GHC stage restriction: `swap'
22:08:16 <lambdabot>   is used in a top-level splice, and must be imported, not defined locally
22:08:16 <lambdabot>   In the definition of `syi':
22:08:26 * vincenz sniffs
22:09:44 <vincenz> dons: what did your primes program do?
22:09:48 <dons> > $( let foo (x,y) = let swap (a,b) = [| (b,a) |] in swap (x,y) in foo (4::Int,5::Int) )
22:09:50 <lambdabot> (5,4)
22:09:58 <vincenz> dons: not as interesting
22:10:21 <dons> vincenz: oh, it was a question asked earlier today in the channel. a guy wanted the haskell version to run faster than python
22:10:33 <dons> which we did with a fair amount of ease.
22:10:52 <vincenz> lol
22:10:58 <vincenz> by moving all the complexity to compiletime?
22:11:41 <vincenz> I'd think haskell need not resort to such dirty tricks to beat python on the premise of being compiled
22:11:50 <dons> well, we solved it first, then as a final coup de gras, we did it at compile time.
22:12:11 <dons> no, it already was 100x faster than python, once Cale worked out what the program was trying to do.
22:12:24 <hyrax42> @index maybeToList
22:12:25 <lambdabot> Data.Maybe
22:12:26 <dons> then it ran in O(1) time with the help of TH.
22:12:26 <vincenz> . o ( Yep I compute the first 10000000000000000000 primes in 0.1 seconds runtime)
22:12:27 <Cale> It was initially written as a brutal list manipulation
22:12:39 <Cale> taking intersections of lists
22:12:49 <vincenz> anyways
22:12:52 * vincenz off to shower and work
22:12:53 <dons> TH isn't a dirty trick. why do people always say that?
22:12:55 <vincenz> thanks for the morning chatter
22:13:02 <vincenz> dons: it is if you want to prove haskell is faster
22:13:11 <vincenz> dons: cause you're just mitigating it to compile time
22:13:23 <dons> not every language has compile time meta programming that powerful though. we should take advantage of it.
22:13:29 <Cale> however, if the python program used the same insight, it would have been fast too
22:13:38 <vincenz> python is going to be slow no matter what
22:13:49 <edwinb> I don't see why using a powerful feature of the language is a dirty trick, even if it is an extension...
22:13:54 * vincenz once wrote an analysis tool and then switched from python to ocmal, gaining 10X
22:14:11 <dons> yeah, its like saying that monads are a dirty trick for doing IO ;)
22:14:16 <vincenz> not really
22:14:20 <vincenz> but for one shot performance issues
22:14:24 <vincenz> moving to compile time is unfair
22:14:24 <dons> I'm just joking :)
22:14:26 <edwinb> yeah, monads are clearly cheating.
22:14:28 <vincenz> cause the total time will be the same
22:14:38 <dons> yeah. looks cool though.
22:14:44 <vincenz> obviously if the program is intended to be run often, there's a gain
22:15:11 * vincenz waves and is off
22:15:17 <edwinb> if you only want to run it once it doesn't matter if it takes 30 minutes... just put the kettle on and have a tea break...
22:15:34 <vincenz> edwinb: in all honesty, how often do you run prime programs?
22:16:06 <vincenz> (besides, every relaunch is just a waste of time cause you start from scratch unless you have some backend for storage)
22:16:09 <edwinb> I can only assume that this was a "toy" problem, otherwise there wouldn't have been the challenge...
22:16:13 <vincenz> but now I'm really off
22:16:19 <edwinb> (and to answer the question, never.)
22:16:23 <vincenz> :D
22:19:37 <dons> sethk: thanks for the mail. much better to mail questions, since i _have_ to answer them to get them out of my inbox
22:20:01 <sethk> dons, thanks for looking at it.
22:24:37 <dons> great. HCAR entries sent.
22:31:31 <dons> sethk, interesting problem. i'll look into it.
22:31:45 <sethk> dons, thanks
22:51:06 <thelsdj> hrm, so the question is does that last version actually 'do' the same thing as the original code?
22:52:00 <thelsdj> dons: i'm back now
22:52:10 <Cale> thelsdj: yes, I believe it does
22:52:22 <Cale> really that (*) should be lcm
22:52:33 <Cale> but they're the same thing here, because they're all primes
22:52:43 <Cale> (and so are coprime with one another)
22:53:37 <Cale> If I understand correctly, you were searching for the last prime you'd need to make your system of congruences uniquely solvable in the given range
22:54:05 <Cale> adding equations saying that x = 31 (mod p)
22:54:32 <Cale> of course, as you mentioned, this is related to the CRT
22:55:28 <dons> > $( let x = head [p | (p,n) <- zip primes (drop 1 . scanl (*) 1 $ primes), n > 1000000] ;  primes = [2,3,5,7,11,13,17,19,23,29] in [| x::Int |] )
22:55:29 <lambdabot> 19
22:55:43 <dons> and that versin's just a bit of a trick, since it computes the result at compile time
22:56:37 <thelsdj> well, not really, the original was to turn the process of finding the unique answer in the given range, then it was yea to find the maximum steps for all answers in the given range
22:56:58 <thelsdj> er 'to turn the process of finding the unique answer in  a given range into code'
22:57:18 <Cale> Well, there's a better way to find the solution too.
22:57:25 <thelsdj> so actually i'm really more interested in how to get the unique solution
22:57:34 <Cale> okay
22:57:47 <Cale> lisppaste2: url
22:57:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:58:26 <lisppaste2> Cale pasted "Euclidean algorithm" at http://paste.lisp.org/display/20029
22:58:28 <thelsdj> originally i was using numbers other than primes, you'll find the solution by a lower #, but takes more tries
22:59:37 <Cale> solve takes a list of (remainder, modulus) pairs, where the moduli are assumed to be coprime, and returns the solution, and larger modulus.
23:01:17 <Cale> It just uses the extended Euclidean algorithm.
23:02:31 <thelsdj> so whats an example of how to call solve?
23:02:41 <Cale> solve [(2,3),(3,5),(2,7)]
23:02:47 <Cale> There are certain things whose number is unknown. Repeatedly divided by 3, the remainder is 2; by 5 the remainder is 3; and by 7 the remainder is 2. What will be the number?
23:03:05 <Cale> That's a problem from the 4th century A.D.
23:03:41 <Cale> Apparently it was posed by Sun Tsu Suan-Ching
23:03:50 <Cale> the result is (23,105)
23:04:02 <Cale> which means that there are 23 things, modulo 105
23:04:19 <Cale> so, 23 + 105 = 128 is also a solution
23:04:23 <thelsdj> ok works for 1,2 1,3 1,5 3,7 to get 31
23:04:23 <Cale> and so on
23:04:37 <thelsdj> cool
23:05:05 <Cale> right, you get that it's 31, mod 210
23:06:02 <Cale> I should fix it so that it works when the moduli aren't coprime
23:06:28 <thelsdj> yea easier to apply sometimes but not as efficient
23:08:53 <vincenz> re@work
23:09:04 <Cale> and you're not guaranteed a solution
23:09:07 <dialtone> any reason why I get many of these: _TextziParserCombinatorsziParsecziCombinator_eof_closure while running 'ghc cd-fit.hs' (from the hitchickers guide)?
23:09:22 <Cale> dialtone: add --make to your commandline
23:09:40 <Cale> (the parsec package isn't getting loaded)
23:10:04 <dialtone> indeed
23:10:59 <dialtone> thanks
23:11:35 <Cale> no problem
23:13:08 <lispy> that's almost becoming an faq
23:13:35 <lispy> which makes me think the parsec documentation could be better
23:22:23 <SimonRC> lispy: the linker needs to be able to say "Did you forget to use --make to automatically include packages?"
23:22:35 <lisppaste2> thelsdj annotated #20020 with "Fastest version in this form" at http://paste.lisp.org/display/20020#3
23:22:46 <SimonRC> *"automagically"
23:23:27 <thelsdj> Cale: that was the fastest version of that code base
23:23:38 <thelsdj> it beat out the direct python translation also
23:23:58 <lispy> thelsdj: from what i've seen that's not surprising
23:24:37 <lispy> SimonRC: heh, that would be interesting
23:26:59 <Lemmih> SimonRC: That'd make cases like this:
23:27:01 <Lemmih> > id
23:27:02 <lambdabot> Add a type signature
23:27:05 <Lemmih> > id :: a -> a
23:27:06 <lambdabot> Add a type signature
23:27:46 <dons> Lemmih: can't show polymorphic functions. 
23:28:03 <dons> > id :: () -> ()
23:28:03 <lambdabot> <() -> ()>
23:28:18 <Lemmih> dons: I know, I was only interested in the error message.
23:28:24 <dons> ah ok :)
23:28:41 <Cale> thelsdj: of course, my direct route to attack the problem is 100x faster :)
23:30:15 <dons> Lemmih, there's karma points to be had in writing an instance that prints "<function>" for polymorphic values, and gives the Typeable type for monomorphic ones. here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
23:30:26 <dons> an instance for Show (a -> b)
23:34:23 <Lemmih> *ShowQ> show id
23:34:23 <Lemmih> "<a -> a>"
23:34:59 <dons> did you use TH?
23:35:10 <Lemmih> But the evilness outweighs the usefulness.
23:35:18 <dons> how evil?
23:35:45 <kzm> Good morning.
23:36:17 <dons> good morning my nordic friend! how's the top side of the world today? :)
23:36:29 * dons is full of hot chocolate and cookies
23:36:33 * Lemmih says 'this evil' and makes a large gesture with his arms.
23:36:40 * kzm rubs his eyes.
23:36:51 <dons> ah!! that evil eh? 
23:36:54 * dons is intrigued
23:37:04 <dons> paste paste !!
23:37:18 <dons> oh hmm. id doesn't call ghci does it... ?
23:37:21 * kzm checks.  We have about two degrees, but at least it's sunny.  Yesterday it was snow and hail.
23:37:22 <dons> s/id/it/
23:37:37 <dons> lovely spring day in kzm-land, then?
23:37:59 <Lemmih> dons: I made 'a' an instance of Typeable.
23:38:00 <kzm> ..life is skittles, and life is beer, as the song goes.
23:38:13 <dons> Lemmih. yikes!
23:38:49 <dons> hmm. ok. that is pretty evil. i think it breaks lots of things. well done!
23:38:59 <dons> ?karma+ Lemmih -- I didn't even think of pushing 'a' into Typeable
23:38:59 <lambdabot> Lemmih's karma raised to 17.
23:39:01 <kzm> Do I have to do anything about SoC?  un-mentorize some entries?  Or?
23:39:21 <dons> I think what we need to do is resolve the conflicted students.
23:39:38 <dons> we can't unmentorize any more (we used  to be able to mark them ineligible)
23:39:54 <dons> so I suppose we have to mark down those that conflict to the bottom of the pile?
23:41:19 <kzm> Okay.  I don't think that is a concern for me, but if you find otherwise, holler.
23:41:33 <kzm> Congrats on the TB thing, btw.
23:42:20 <Lemmih> @version
23:42:20 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
23:42:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:42:23 <dons> hehe :) well, its' just a bigger version of the 10G test. Once I worked out the issues with getting 10G running, 1T wasn't to much harder.
23:42:49 <dons> now the hardware is really the bottleneck, I think.
23:42:52 * kzm quotes his role model: Impressive.  Most impressive.
23:43:13 <kzm> 50% CPU utilization, wasn't it?
23:43:25 <dons> yeah.
23:43:26 <kzm> Do you generate data on the fly, or read from disk?
23:43:40 <dons> I have a 10G file I'm reading from disk 100 times.
23:43:53 <dons> and streaming the result throguh a pipe
23:44:05 <neologism> dons: is fps in 6.5 already?
23:44:09 <dons> yep
23:44:12 <shapr> dcoutts: pong
23:44:16 <dons> not Data.ByteString.Lazy though.
23:44:30 <dons> once we polish it up, I'm going to propose it goes in too.
23:45:05 <dons> kzm, I'm interested, what kind of data sizes do bioinf projects tend to deal with?
23:45:07 <kzm> my back of envelope calculation makes it 30Mb/s - is that correct?
23:45:25 <kzm> dons - good question.
23:45:26 <kzm> :-)
23:45:40 <kzm> human genome: 3G
23:45:59 <thelsdj> ooh could actually fit that in ram on some of my systems
23:46:09 <neologism> dons: Char8 is in, right?
23:46:12 <kzm> all human ESTs  7M * 0.5-2k perhaps, 7G?
23:46:30 <kzm> all ESTs more than twice that
23:46:49 <kzm> Not sure about the sizes of protein databases etc, but they are probably smaller.
23:46:52 <dons> neologism: yep.
23:47:02 <dons> > ((2 ^ 40) / 12752) / (1024 * 1024)
23:47:03 <lambdabot> 82.22835633626097
23:47:14 <neologism> great.. I hope 6.6 will be rleased soon
23:47:15 <dons> 80/M /sec?
23:47:29 <dons> 12752 is the number of actual seconds it took.
23:47:47 <ADEpt> dons: btw, why fps testsuite always reuses the same random data?
23:47:49 <kzm> Oooh, wall clock seconds?
23:48:00 <kzm> Didn't you say 8h?
23:48:01 <dons> ADEpt: you mean, in Quick.hs and Lazy.hs ?
23:48:07 <kzm> >8*3600
23:48:10 <ADEpt> dons: in particular, Lazy.hs
23:48:13 <dons> kzm, oh, 12752.37s user 4069.35s system 58% cpu 8:03:11.42 total
23:48:24 <dons> ADEpt: I suppose because QuickCheck just works that way
23:48:32 <dons> it doesn't take a random seed.
23:48:33 <ADEpt> dons: usually it doesn't
23:48:36 <dons> maybe we could do it though.
23:48:42 <ADEpt> dons: want me to try and fix it?
23:48:48 <kzm> Right.  My point was that a modern disk may deliver about 30Mb/s, so that's probably your limitation.
23:48:52 <dons> ADEpt: its a good question. please fix it, shouldn't be too hard.
23:48:59 <dons> kzm, yeah, I suspect so.
23:49:02 <kzm> the "biggest" bottleneck :-)
23:49:27 <dons> there's lots of bottnecks, and haskell isn't the worst one at that point. :)
23:49:43 <ADEpt> dons: btw. i decided to try new fps, i need isPrefixOf (lazy) so i decided to hack it in. And test it. For tests, I reduced the chunk size to 6 (bytes). groupBy test started to fail (reproduceable).
23:49:55 <dons> ADEpt: shoudl already be in there?
23:50:00 <dons> I got a patch yesterday to add it.
23:50:12 <dons> ah very intersesting!
23:50:37 <kzm> How is the turf split between .Lazy and (just) ByteString?
23:50:52 <kzm> Must the user select one, or is Lazy now the default interface, or what?
23:51:58 <dons> Lazy provides the list manipulation code, and calls into normal ByteString for all node chunk operations.
23:52:04 <dons> no, Lazy isn't the default
23:52:21 <dons> you have to explicitly aask for it. it's interface is smaller, and not complete yet. let alone fully debugged
23:52:50 <dons> ADEpt: how'd you manage to reduce the chunk size in the QC tests?
23:53:21 <dons> by changing the defaultChunkSize in Data.ByteString.Lazy ?
23:55:09 * dons tries a chunk size of 1 byte for laughs
23:55:47 <dons> ah ha, group and groupBy fail.
23:55:53 <dons> ?karma+ ADEpt
23:55:54 <lambdabot> ADEpt's karma raised to 1.
23:56:16 <ADEpt> dons: yes, I simply edited the file
23:56:24 <osqulda> how to tell lhs2TeX to change lambda x -> x into \x.x without the "%format -> = "."" which destroys typesetting of function types?
23:56:43 <osqulda> @paste
23:56:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
23:56:49 <osqulda> @paste2
23:56:50 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
23:57:59 <dons> lisppaste: url
23:57:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:58:19 <ADEpt> dons: I also thought that maybe for some functions (like isPrefixOf) there should be test (isPrefixOf xs (refragment xs)), where refragment repacks lazy bytestring with different chunk size
23:58:44 <dons> yeah, we haven't written this 'defrag' function yet. it's on the todo list.
23:59:02 <dons> (its a stub at the bottom of Lazy.hs if you check)
23:59:10 <ADEpt> dons: that's "refrag", not "defrag" :)
23:59:12 <osqulda> what is the easiest way to write a naive string matcher in Haskell, e.g. using scanl and scanr nested?
23:59:31 <ADEpt> dons: or you mean that QuickCheck generates random chunk sizes?
23:59:32 <dons> oh, you want to fragment. I see!
23:59:42 <dons> QuickCheck should generate random chunk sizes, yes.
23:59:55 <dons> the Arbitrary list takes a random list, and uses that to generate random chunks, iirc
