00:03:47 <mathewm> How might one parse a String containing a hexadecimal number into an Integer?
00:04:42 <Lemmih> > read "0xdeadbeef" :: Integer
00:04:43 <lambdabot> 3735928559
00:05:03 <mathewm> Hmm my string doesn't have a leading 0x
00:05:37 <Lemmih> > readHex "deadbeef"
00:05:38 <lambdabot> [(3735928559,"")]
00:06:10 <mathewm> > fst $ readHex "deadbeef"
00:06:11 <lambdabot> Couldn't match `(a, b)' against `[(a1, String)]'
00:06:26 <mathewm> > fst $ head $ readHex "deadbeef"
00:06:27 <lambdabot> 3735928559
00:06:31 <mathewm> :) thanks
00:07:07 <LordBrain> that function is familiar... maybe it was defined in one of the tutorials i read
00:07:28 <lispy> or you could append 0x to the string
00:07:45 <lispy> not append but prepend
00:07:51 <mathewm> I am doing the 48 hr scheme tutorial...
00:10:53 <LordBrain> it just reminded me of an example program i encountered.. i think from the Yet Another.. tutorial
00:12:01 <LordBrain> what module what module has readHex ?
00:12:13 <Lemmih> @index readHex
00:12:13 <lambdabot> Numeric
00:14:07 <lispy> @pl \x -> read ("0x"++x) :: Integer
00:14:08 <lambdabot> (:: Integer) . read . ("0x" ++)
00:14:13 <LordBrain> i wonder how i managed to type "what module" twice without realizing it
00:14:15 <lispy> @pl \x -> read ("0x"++x)
00:14:15 <lambdabot> read . ("0x" ++)
00:14:36 <lispy> LordBrain: i didn't notice it and i read that line
00:16:31 <LordBrain> i guess my distortion is within the acceptable thresh hold for your error correction filter.
00:17:06 <LordBrain> actually i didnt notice it at first either
00:17:14 <LordBrain> which means it got by me doubly
00:18:53 <LordBrain> maybe it wasnt there... maybe some quantum effect happened and altered the past, and like gynan on TNG we have an intuitive feel for the distortion in the timeline
00:21:21 <LordBrain> i notice that > read "0xdeadbeef" works in ghci but not in hugs
00:21:58 <lispy> what you said about the quantum thingy could be cause by keal
00:21:59 <lispy> @keal
00:22:00 <lambdabot> and yes that was with zero formal training in all realms
00:22:11 <lispy> i rest my case...
00:22:25 <lispy> @. elite keal
00:22:25 <lambdabot> w|-|ErE Can I FINd 0p3nSouRCe $c|-|3/\/\4TiC5 Of liNuz0rz t0RVAlD$' X86 (l0ne?
00:27:18 <stepcut> I can't seem to figure out where decodeDouble# is defined :-/
00:33:44 <lispy> if it has a # in the name, i stay away from it
00:34:10 <stepcut> lispy: well, it is broken :p
00:34:11 <LordBrain> try that index command on lambdabot
00:34:36 <LordBrain> @index decodeDouble#
00:34:37 <lambdabot> bzzt
00:34:41 <LordBrain> lol
00:35:05 <stepcut> I think it must be __decodeDouble in ghc/rts/StgPrimFloat.c
00:38:45 <lispy> @hoogle decodeDouble#
00:38:46 <lambdabot> No matches found
00:43:13 <est> would anyone like to help me port ghc to darwin/intel?  ..or otherwise help with my darwin/intel situation? :)
00:44:56 <lispy> i have no darwin/intel or ghc porting knowledge :(
00:45:35 <stepcut> est: what is the problem ?
00:47:07 <est> there's no darwin/intel binary available..as far as i can tell, it needs to be ported via the instructions at http://haskell.org/ghc/docs/6.4.2/html/building/sec-porting-ghc.html
00:47:37 <eivuokko> There was mails about it being done on mailing list, I think.
00:47:46 <est> aha..i will check that
00:48:32 <eivuokko> http://hackage.haskell.org/trac/ghc/wiki/Contributors names Wolfgang Thaller for port in progress, maybe you could ask him.
00:49:23 <lispy> wolfgang is busy according to the ml post i saw, there is someone else trying to do the work though
00:49:57 <est> ive tried 3 times over the past week myself
00:50:10 <stepcut> est: why did it fail?
00:51:02 <est> well, different reasons each time..and always on someone else's machine..i thought that it might be good to try it with someone more motivated (i.e., a haskeller :)
00:51:35 <stepcut> :p
00:51:42 <est> via darwin/ppc is probably the most promising..i can dig up the failure info on that if you like
00:52:45 <stepcut> I personally do not have much interest in a darwin/intel port...
00:53:12 <est> ok
00:53:56 <est> hmm..she was getting segfaults on ghc..so her ghc install sounds faulty
00:58:56 <est> if anyone on darwin/ppc wants to help, i'd love to try again
01:49:04 <Lokadin> say anyone here use darcsweb?
01:52:43 <morans> i tried to get it running once, but not very hard and it kept dying with errors
01:53:44 <lispy> noti
01:53:58 <lispy> i use darcs.cgi, but i heard darcsweb was a lot cooler
01:54:40 <norpan> i use neither
01:54:50 <morans> lispy: I like the look of darcsweb
01:55:06 <morans> lispy: but thats because I like gitweb, and they are intended to have same/similar UIs
01:55:07 <lispy> i wanted to usetrac
01:55:22 <lispy> but i couldn't get trac to run (python issues on amd64)
01:55:34 * est can't get darcs to run :(
01:55:42 <lispy> est: what about rosetta?
01:56:06 <morans> est: what platform? its always been pretty straightforward for me...
01:56:29 <est> lispy: ive been using that darcs 1.05 static build under rosetta.  it mostly works.  however, it sometimes trashes files and histories
01:56:40 <est> morans: darwin/intel
01:56:49 <est> lispy i updated the wiki to that effect
01:57:37 <est> lispy: i may attempt porting ghc to darwin/intel via rosetta if i can find a ghc darwin/ppc binary that will run under it
01:58:02 <est> however, i'm hoping to find someone running ghc on darwin/ppc to help me do a standard port
01:58:27 <morans> est: I have darwin on an powerpc ibook
01:58:41 <est> excellent
01:58:48 <est> want to have at it?
01:59:05 <est> we would do this:  http://haskell.org/ghc/docs/6.4.2/html/building/sec-porting-ghc.html
01:59:11 <morans> want a shell account?
01:59:23 <est> oh..that would be great :)
01:59:35 <morans> est: if you break it, i hunt you down and cut you
01:59:42 <est> understood :)
01:59:43 * morans looks to see how to make user accounts...
02:00:10 <morans> how much build space you want?
02:01:07 <est> hmm..not sure how much i need..let me check
02:01:46 <est> would 200M be ok?
02:01:54 <morans> sure
02:01:59 <est> we can vacate it on success
02:06:38 <Lokadin> i got it to work :)
02:06:41 <Lokadin> yay!! 
02:06:55 <Lokadin> now i just have to figure out how to push into my darcs repository
02:07:16 <morans> darcs push?
02:07:20 <Lokadin> yea
02:07:28 <Lokadin> it was giving me some error
02:07:38 <Lokadin> so i'm recompiling newer version of darcs
02:07:41 <pejo> est, my buildtree on Sparc for ghc is 1.1G, fyi.
02:07:42 <morans> cd ~/src/lsdupes
02:07:43 <morans> darcs push benc@mundungus.clifford.ac:/home/benc/public_html/darcs/lsdupes/
02:07:59 <morans> Lodakin: thats a commandline I use to push over ssh into a repo on mundungus.
02:08:14 <Lokadin> cool :) thanks let me try doing something like that
02:08:29 <morans> there's a #darcs on this IRC network too, btw
02:09:13 <Lokadin> darcs: bug in darcs!
02:09:13 <Lokadin> fromJust error at Push.lhs:134 compiled 11:00:51 Mar 28 2006
02:09:14 <Lokadin> :(
02:09:36 <Lokadin> oh thanks:) i'll check them out if recompiling doesn't help
02:10:04 <est> pejo: well, maybe morans should allow some extra space :)  however, we're just building the .hc files on his machine.  otoh, im not sure how much we need to build on the way there
02:13:48 <norpan> hmmm
02:14:14 <norpan> why does inits start with the shortest and tails start with the longest substring
02:14:24 <norpan> that makes no sense
02:14:43 <norpan> > inits "ABC"
02:14:44 <lambdabot> ["","A","AB","ABC"]
02:14:47 <norpan> > tails "ABC"
02:14:49 <lambdabot> ["ABC","BC","C",""]
02:14:55 <ndm> they both start at the begining
02:15:04 <ndm> and go towards the end of the list
02:15:15 <ndm> if they didn't do it that way, they couldn't be lazy :)
02:15:23 <norpan> fair enough
02:18:41 <norpan> i'm just doing bytestring stuff so i could as well start at the end, but of course you want the same order as the list version
02:19:24 <norpan> i'll think i just will do reverse
02:20:01 <ndm> norpan: if you do a reverse, that makes it tail strict
02:20:25 <ndm> i think bytestrings are strict anyway, but its best not to add more strictness if not necessar
02:20:41 <norpan> i know
02:21:13 <norpan> crap
02:21:18 <norpan> i'll do the raw stuff then
02:21:47 <ndm> i would have thought those operations were really easy on bytestrings, just playing with the offset and the length
02:22:20 <norpan> well yes, but not for UTF-8 :)
02:22:38 <ndm> ah, now i think everything about UTF-8 is tricky :)
02:22:58 <norpan> problem is i don't want to decode chars more than once
02:23:24 <ndm> yes, that would be bad
02:23:28 <ndm> but you don't need to decode
02:23:40 <ndm> do you have not a function charLength :: ByteStringPos -> Int ?
02:23:50 <ndm> that can be done without doing a decode, a simple bit mask
02:23:59 <ndm> and with that, you can do it quite easily
02:24:09 <norpan> i know, but i don't want to call that more than once either
02:24:21 <ndm> you don't need to, i think
02:24:34 <norpan> i need to call it once for every pos
02:24:44 <ndm> yes, thats inevitable, surely?
02:24:48 <norpan> and not every pos i a valid character
02:25:05 <ndm> no, you only need to call it for hte valid ones - i think
02:25:09 <ndm> lisppaste2: url
02:25:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:25:10 <norpan> no that's not inevitable, you can skip and jump
02:25:18 <ndm> i'll try doing some pseudocode :)
02:25:24 <norpan> i have the code already
02:25:26 <norpan> :)
02:25:55 <ndm> can i see?
02:26:01 <ndm> am curious how you did it now :)
02:26:22 <norpan> i just do it like you said
02:26:53 <ndm> ok, surely thats only one decode per pos, which is the best you can do?
02:26:58 <norpan> yes
02:27:09 <norpan> need to make it non-strict too
02:27:29 <ndm> i would have thought non-strict was the easy way in this case?
02:28:38 <norpan> i'll rewrite it to take pointers so i don't have to encode/decode the bytestring each time
02:29:11 <norpan> i mean construct/deconstruct
02:30:35 <morans> anyone done much with STM?
02:30:53 <morans> I was trying to write a dining philosophers program but it doesn't seem to work...
02:31:05 <morans> maybe i should look again now i am less tired
02:36:19 <ruffneck> morans: what would it had done ?
02:36:27 <norpan> ndm: it's strict, because peeking is in IO
02:36:33 <morans> ruffneck: pick up chopsticks, eat, and put them down again
02:36:47 <morans> ruffneck: you know the Dining Philosophers problem?
02:37:27 <ruffneck> umm.. I kind of remember something but not exact
02:37:31 <morans> hehe
02:37:43 <Brody> hi ppl
02:37:49 <morans> n philosophers round a circular table, n chopsticks; each chopstick is halfway between two philosophers
02:37:52 <ruffneck> it's like the travelling salesmen problem ?
02:37:53 <morans> and they must eat
02:38:01 <ruffneck> ah, yeah
02:38:13 <ruffneck> what happens then?
02:38:18 <morans> thats it
02:38:27 <ruffneck> ok.. do they die of hunger?-)
02:38:32 <Brody> where can i post a questionj ?
02:38:36 <morans> you get to play with different models of locking/deadlock breaking
02:38:39 <Brody> about haskell
02:38:45 <morans> Brody: here?
02:38:46 <norpan> if they, for instance all take the right chopstick and then try to take the left you will have deadlock
02:38:51 <morans> norpan: right
02:38:54 <Brody> ok
02:39:01 <norpan> so it's an illustration of parallel dangers
02:39:06 <morans> norpan: I'm trying to implement chopsticks as something locklike
02:39:10 <ruffneck> ah, yeah
02:39:50 <morans> so I was thinking i could make it that the whole 'get chopsticks, eat, drop chopsticks' thing could be some atomic section
02:39:57 <norpan> i never understood why they were philosophers though
02:40:03 <Brody> so i would like to define my own : operator for sets
02:40:07 <morans> norpan: because they just sit round thinking
02:40:19 <morans> norpan: the fact that they do not talk to each other is very important
02:40:27 <Brody> e:g (h:t) becomes (h<:t)
02:40:34 <norpan> dining mutes?
02:40:38 <Brody> can i do that ?
02:40:40 <morans> norpan: heh
02:40:44 <ndm> Brody: yes
02:40:55 <morans> Brody:  you can say    a <: b = YOURDEFINITIONHERE
02:40:57 <ndm> (<:) :: a -> [a] -> [a]
02:41:20 <Brody> ok cool
02:41:30 <isaacd> (:) itself is a reserved operator or something like that though
02:41:44 <ndm> anything starting with a : is a constructor
02:41:50 <ndm> any other symbol is an operator
02:41:56 <Cale> you won't be able to decompose your set again with it though, since it's not a constructor
02:42:35 <ndm> but if you don't use an operator, you may well end up with 2 in the list, since the constructor won't check
02:42:42 <Brody> so (h<:t) t can be decomposed  further ? 
02:43:08 <Cale> Brody: you can write functions on lists by pattern matching with :
02:43:40 <Cale> like  sum [] = 0, sum (x:xs) = x + f xs
02:44:17 <Cale> The : there is being used to decompose the list in the case that it is nonempty
02:44:29 <Cale> but you can't use arbitrary functions there
02:44:34 <Brody> but my problem is that i am defining a programming language and sequential composition is <: so i want to use <: to treate the program as a list
02:44:49 <Brody> can that be done without converting it to the usual list ?
02:44:58 <Cale> oh sure
02:45:06 <Cale> <: is just the name of a function
02:45:15 <Cale> which is written infix by default
02:45:25 <Cale> (well, a possible name)
02:45:30 <Brody> so i define <: as a function ?
02:45:40 <Cale> much like any other
02:45:44 <Cale> x <: y = ...
02:46:02 <morans> x <: y = ...   means the same as   (<:) x y = ...
02:46:09 <Cale> where presumably in your case x and y are programs
02:46:24 <Brody> but  x <: y   i want that y is the rest of the program 
02:46:32 <Cale> sure
02:46:36 <Cale> or whatever :)
02:46:45 <Cale> they can be whatever types you like
02:46:49 <Brody> cool
02:47:59 <Brody> thanks guys
02:48:01 <Cale> note that if it was the other way around, it wouldn't be allowed as an ordinary function -- operator symbols starting with : are reserved for data constructors
02:49:03 <Brody> what does a data constructor does ?
02:49:16 <Cale> It's part of the definition of a type
02:49:28 <morans> hmm
02:49:33 <morans> it never seems to write to my tvars
02:49:51 <Cale> They're used to build and deconstruct values of a type
02:49:55 <norpan> ndm: http://norpan.org/~martin/fps-i18n/Data/ByteString/UTF8.hs (the function rawIndices at the end)
02:50:04 <Cale> For list, the data constructors are [] and (:)
02:50:36 <Cale> every list can be built from applications of those two things
02:50:44 <Cale> @type (:)
02:50:46 <lambdabot> forall a. a -> [a] -> [a]
02:50:49 <Cale> @type []
02:50:50 <lambdabot> forall a. [a]
02:51:03 <Cale> > 1 : 2 : 3 : 4 : []
02:51:04 <lambdabot> [1,2,3,4]
02:51:25 <Cale> You could define a tree type like
02:51:39 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
02:51:48 <Cale> then Leaf and Branch are the data constructors
02:52:04 <Brody> can u tell me how a list is constructed ?
02:52:12 <Brody> i mean internally ?
02:52:16 <Cale> you can use them to build a tree, such as  t1 = Branch (Branch (Leaf 1) (Leaf 2)) (Leaf 3)
02:52:17 <morans> http://piva-wl.hawaga.org.uk/~benc/tmp/diningphilosophers.hs
02:52:19 <Brody> how is : defined
02:52:43 <Cale> It builds a data structure with a pointer to the head of the list and the tail.
02:53:16 <Cale> (or when pattern matching, it deconstructs that structure, following the pointers)
02:54:28 <Brody> what if i have a data structure and i have 
02:54:30 <Brody> data Pgm =
02:54:30 <Brody>     | Pgm :> Pgm
02:54:30 <Brody>  etc
02:54:44 <Brody> can i treat :> as : in list ?
02:54:49 <Cale> yes
02:54:54 <Brody> to traverse a program
02:55:00 <Cale> yeah
02:55:31 <Brody> but o do i define :> ?
02:56:19 <ndm> Brody: you already did with the data Pgm statement above
02:56:27 <Cale> it'll be defined by your data declaration
02:56:51 <Cale> the actual mechanics are the compiler's job :)
02:57:15 <Cale> anyway, I really should sleep
02:57:21 <Cale> g'night all
02:57:28 <Brody> but does bracketing need to be like this pgm :> (pgm :> (pgm :> pgm))
02:57:36 <Brody> ok thanks
02:57:46 <ndm> Brody: you can define infixr or infixl to take care of that
02:58:16 <ndm> infixr 5  :>
02:58:40 <Brody> am lost anout infix
02:58:44 <Brody> about
02:58:47 <ndm> just on a separate line
02:58:56 <ndm> write "infixr 5 :>"
02:58:57 <Brody> i mean why 5 ?
02:59:11 <ndm> 5 is the priority, 1 to 9
02:59:15 <morans> far as I am expecting, the "sticks are" line from the diningphilosophers code should be listing the philosophers who have each stick at each moment
02:59:21 <ndm> take a look at the prelude, it defines a pile of them
02:59:21 <morans> but instead it just says they are all empty
03:00:35 <Brody> so if i write that it should take care of it on its own
03:01:44 <norpan> ain't it great?
03:01:50 <Brody> of course it is
03:14:47 * neez slaps neez around with a small 50lb Unix Manual
03:15:26 <ruffneck> startkeylogger ;P 
03:15:49 <sieni> hehe
03:15:58 <sieni> doesn't probably work that well here
03:16:00 <est> "ruffneck" is a nick im somehow surprised to see on a #haskell channel :)
03:16:30 <ruffneck> est: how come?-)
03:17:33 <est> erm..i think you can imagine :)
03:19:44 <ruffneck> well.. depends what it associates to self
03:19:58 <ruffneck> for me it's about music
03:20:21 <sieni> > take 10 $ let foo = 1 : (map (2*) foo) in foo
03:20:22 <lambdabot> [1,2,4,8,16,32,64,128,256,512]
03:20:37 <sieni> lambadabot <3
03:23:15 <est> ruffneck: aha..for me too..i associate with the "jungle" genre
03:23:47 <morans> est: hehe, i just wondered why my mmachine went all slow
03:23:59 <est> the party commences
03:24:05 <ruffneck> ok =) for me it's gabber from Holland
03:24:25 <est> ruffneck: not the most distant genre
03:24:45 <ruffneck> quite old.. about a decade
03:25:25 <est> that's not "quite old" to me :)
03:25:37 <est> i collect early 90s UK hardcore
03:25:42 <ruffneck> as old as gabber can get ;P
03:29:35 <dcoutts> dons, pong
03:30:08 <dcoutts> @seen dons 
03:30:09 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 5 hours, 26 minutes and 15 seconds ago.
03:30:18 <dcoutts> @localtime dons
03:30:21 <lambdabot> Local time for dons is Sun May  7 20:26:51 2006
03:32:55 <xerox> @yow!
03:32:56 <lambdabot> Laundry is the fifth dimension!!  ... um ... um ... th' washing machine
03:32:56 <lambdabot> is a black hole and the pink socks are bus drivers who just fell in!!
03:40:34 <shapr> @yow !
03:40:34 <lambdabot> TAPPING?  You POLITICIANS!  Don't you realize that the END of the "Wash
03:40:34 <lambdabot> Cycle" is a TREASURED MOMENT for most people?!
03:40:54 <shapr> Wassup?
03:42:14 <xerox> Just woke up 0_o
03:42:25 <shapr> I'm awake!
03:43:22 * xerox vanishes
03:43:38 <Lokadin> say my darcs repair doesn't work because it says it cant read the patch
03:54:21 <jyp> @yow
03:54:21 <lambdabot> World War Three can be averted by adherence to a strictly enforced
03:54:21 <lambdabot> dress code!
03:56:04 <morans> est: you made the fan turn on!
04:01:35 <est> nice to know i have some fans
04:01:45 <morans> just the one
04:01:51 <morans> est: is it working/
04:01:54 <est> want me to give it a break?
04:01:58 <est> so far
04:02:00 <morans> est: no, no worries
04:02:07 <morans> est: its just unusual for the fan to turn on on this machine
04:04:26 <shapr> Anyone know of a Linux performance tuning guide? For example, something that mentions hdparm, kernel tuning, and more?
04:20:41 <mahogny> there are several hdparm tutorials around
04:20:50 <mahogny> dunno about kernel tuning
04:32:12 <kzm_> shapr, what was the problem?
04:32:44 <kzm_> I don't think there is much difference to be made, tuning linux.  A few exceptions, like hdparm -d 1
04:33:06 <aspect> if you'd asked two years ago, I could say yes. But I don't know where the link is and it's probably way out of date by now.
04:33:33 <neologism> what is wrong with USE_REINPLACE
04:34:03 <aspect> a lot of tuning is a matter of tuning to the particular userland programs that are running. Squid or pgsql for instance have particular requirements that don't overlap a much.
04:34:10 <pejo> shapr, the vendors make pretty good choices in their distribution kernels. It's unlikely that you'll gain a lot of performance by recompiling your kernel.
04:48:57 <Lokadin> what package is haxml in?
04:49:41 <shapr> pejo: Actually, I already recompile and tune my kernel with features like 4k stacks, irqbalance, paramaters in registers, etc. It really does give performance advantages. I also use hdparm, and several other systuning programs. I just feel like I'm missing a lot of options.
04:50:02 <shapr> s/paramaters/parameters/
04:59:48 <morans> i think i didn't have a problem with STM after all
04:59:57 <morans> i think i was just misunderstanding what trace () ouyput would look like
05:04:20 <davidhouse> argh. Text.Html doesn't have _any_ documentation that i can find
05:23:41 <shapr> Google calendar is so wonderful =)
05:24:06 <aspect> wow, what a quit message
05:24:44 <shapr> tis odd
05:24:50 <shapr> Hiya aspect, written any cool code lately?
05:25:12 <Brody> when i define a data type how am i going to define an empty one ?
05:25:45 <shapr> data Foo = Foo
05:25:45 <shapr> ?
05:26:13 <Lokadin> hey, i don't know why, but hReady is showing true for EOF, or seems to be, as i can't read char and program exits :(
05:26:21 <Lokadin> @where paste
05:26:22 <lambdabot> http://paste.lisp.org/new/haskell
05:26:25 <aspect> shapr: not really, and particularly no Haskell code ... I'm mainly in here as an adjunct to trying to learn type and category theory :)
05:27:02 <Brody> <shapr> data Foo = Foo doesnt workk
05:27:17 <lisppaste2> Lokadin pasted "hGetCont" at http://paste.lisp.org/display/19772
05:27:53 <Brody> atanas qed hawn ?
05:27:53 <metaperl> Brody: what do you mean by empty one?
05:27:53 <metaperl> why do you need that?
05:27:53 <metaperl> what are you doing?
05:28:29 <Brody> so that to traverse a list 
05:28:42 <Brody> and return only what is needed
05:28:49 <Brody> the rest are empty
05:29:54 <metaperl> the rest?
05:30:00 <metaperl> you can use filter to take what you want from a list
05:30:25 <metaperl> do you want empty spaces for the things you dont want?
05:30:32 <metaperl> You can use Maybe a for that
05:30:34 <Lokadin> er, so that function i pasted, it is like hGetContents, reads a Char at a time, unfortunatly doesn't stop at the right time, and dies because it reads EOF
05:30:59 <Brody> but even if sequential composition  is defined diferently ?
05:31:03 <Brody> can i use filter ?
05:31:38 <davidhouse> anyone familiar with Text.Html?
05:32:25 <Lokadin> not i
05:33:28 <Brody> pgm :> pgm :> pgm     -- pgm is one of the data i defined and :> is sequential composition
05:34:10 <Brody> now i need to filter out one type of the pgm
05:35:05 <Brody> can i use list comprehension
05:35:08 <Brody> ?
05:35:42 <ndm> Brody: no
05:35:56 <ndm> but you can define toList and fromList, and do it that way
05:36:15 <Brody> but is there a way without converting it to a list ?
05:36:47 <ndm> no, list comprehensions only work on lists
05:37:04 <Brody> ok is there a way without list comprehension
05:37:07 <ndm> why can't you just use a list of pgm?
05:37:19 <ndm> it seems like :> is just another way of writing : in your case
05:37:29 <Brody> exactly
05:37:36 <ndm> so why not just use : instead?
05:37:45 <ndm> then you get [a, b, c] and stuff for free
05:37:47 <Brody> because its stated to be :>
05:37:54 <ndm> by what?
05:38:18 <Brody> because  its a programming language  
05:38:26 <Brody> and i have to use :>
05:38:30 <ndm> then change it :)
05:38:48 <Brody> and my lecturer will cut my balls
05:38:48 <ndm> do you have a reference to this programming language?
05:38:55 <ndm> ah, typical, an assignment :)
05:39:54 <ndm> you can write your own "filter" for your type
05:39:57 <Beelsebob_> gyah... back to the SEE or TextMate quandry...
05:40:31 <Beelsebob_> because having emailed the guy who writes SEE he says he's adding Context Free syntax highlighting grammars to it
05:40:35 <ndm> Beelsebob_, textpad...
05:40:40 <Beelsebob_> ndm: for mac?
05:40:52 <ndm> you can change your os too ;)
05:41:00 <ndm> oh, Beelsebob_, new hoogle logos are up!
05:41:00 <Beelsebob_> to windows?
05:41:02 <ndm> @where hoogle
05:41:02 <Beelsebob_> fuck off!
05:41:03 <lambdabot> http://www.haskell.org/hoogle
05:41:13 <Beelsebob_> why did you change it?
05:41:21 <Beelsebob_> the google rip off looked cool
05:41:27 <ndm> yes, but a bit too ripped off
05:41:34 <Beelsebob_> boring!
05:41:51 <Smokey`> ugh, hoogle looks like shit now.
05:41:57 <mahogny> hm. I like it
05:42:12 <Beelsebob_> I have to agree with Smokey` on this one
05:42:27 <ndm> i don't mind it, its growing on me
05:42:29 <Beelsebob_> it looks like Microsoft designed it
05:42:35 <ndm> if anyone else wants to contribute a better one...
05:42:43 <mahogny> we all know gradients oughta be used more in graphics :)
05:42:47 <ndm> it was designed in MS Powerpoint, using WordArt, so that probably explains it
05:42:52 <mahogny> :D
05:43:08 <Beelsebob_> ndm: I'll do you one next time I'm at home and have illustrator
05:43:16 <ndm> Beelsebob_, fair enough
05:43:35 <ndm> i just figured, with SoC, and haskell taking money from google, ripping them off might become more of an issue
05:43:56 <mahogny> the name is bad enough :)
05:43:57 <Lokadin> @type when
05:43:57 <Beelsebob_> yeh, good point
05:43:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:44:22 <ndm> mahogny: booble are still trading, so i guess google don't stop just for a name
05:44:28 <Beelsebob_> you could of course prod google and see if they want to employ you
05:44:29 <mahogny> ndm, true
05:44:52 <ndm> Beelsebob_, you remember Andrew Wilkinson? he did get prodded by google (lightly)
05:45:02 <Beelsebob_> ndm: yeh, a lot of people do
05:45:13 <Beelsebob_> there are however 5 interviews (at least)
05:45:15 <ndm> would be good
05:45:18 <mahogny> or integrate hoogle with google. and hint about good haskell functions each time someone googles for, say, a tutorial on C on how to do networking ;)
05:45:20 <Beelsebob_> and they get successively harder
05:45:38 <ndm> i want to expand hoogle past haskell, to lots of other languages
05:45:46 <ndm> including C#, ML, Clean
05:45:51 <mahogny> C# :(
05:45:56 <Smokey`> eh, C#... :(
05:46:06 <ndm> C# is scheduled for V6
05:46:11 <ndm> Clean is in V5
05:46:15 <mahogny> boyqot! :(
05:46:37 <ndm> i'm still on v3 beta, so its going to be a while...
05:46:38 <Smokey`> I'm still a C++ person, C# is ... meh.
05:46:46 <mahogny> ...java!
05:47:02 <ndm> i'd also do Java at the same time as C#
05:47:19 <Beelsebob_> Smokey`: all of a sudden I respect you that little bit less :P
05:47:25 <mahogny> indeed :)
05:47:31 <mahogny> C++ ....
05:47:34 <Smokey`> heh
05:48:20 <mahogny> it is not without reasons I have seen ads about work call for coders that know both VB and C++ :)
05:48:47 <ndm> yep, C++ and VB is a good combo
05:48:51 <ndm> have written apps using that before
05:48:58 <Smokey`> VB i hate, C# is good, but I have 'NO' reason to switch from C++ to C#.
05:49:14 * mahogny wonders if he should take ndm out of misery for that :(
05:49:26 <Beelsebob_> ndm: how shiny is the API for hoogle3?
05:49:29 <ndm> Smokey`: types, garbage collection, better productiviely, non-broken templates?
05:49:38 <ndm> Beelsebob_, pretty shiny
05:49:44 <mahogny> ndm, microsith?
05:49:55 <Beelsebob_> ndm: cool... I'll have another go at XHoogle that's less broken
05:50:18 <kombinator> ndm: by the way, is it possible to restrict hoogle's answer to exact matches?
05:50:23 <ndm> Beelsebob_, http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=hoogle;a=headblob;f=/src/Hoogle/Hoogle.hs
05:50:35 <ndm> kombinator: no, but if there are any exact matches, they should always come first
05:50:54 <ndm> mahogny: windows, visual studio, I'll let you decide :)
05:51:04 <kombinator> separating them from the rest would be a nice feature
05:51:11 <Beelsebob_> ndm: cool - I'll have a play
05:51:13 <ndm> yep, thats been asked for before
05:51:15 <mahogny> ndm, that program alone is a good reason not to go that way :)
05:51:26 <Beelsebob_> this'll have to mean learning how to work the FFI in combination with cocoa
05:51:39 <Beelsebob_> i.e. get both Haskell runtime and Cocoa runtime up and running together
05:51:39 <ndm> I might separate them out, should be reasonably easy to do
05:51:47 <kombinator> ndm: by exact matches I mean also (Int -> b) -> [Int] -> [b] matching map
05:52:03 <kombinator> ndm: as map has more general type
05:52:03 <ndm> yeah, thats the harder bit, what is an exact match, what is not
05:52:17 <ndm> i can probably flag those
05:52:21 <ndm> but they won't all come top
05:52:56 <ndm> anyway, i'm on catch now, hoogle hacking is a few weeks away at least
05:53:07 <dons> dcoutts, ping pong
05:53:09 <Smokey`> ndm: I've had no issues with templates, garbage collection can be done in C++, 'types'?, productivity... heh, C# is the same as C++ in relation to that.
05:53:54 <dcoutts> dons, pong ping
05:53:55 <Beelsebob_> ndm: it was problems with Data.Set etc that stopped hoogle being hatable wasn't it?
05:54:03 <dons> dcoutts, now, this packByte bug...
05:54:05 <ndm> Beelsebob_, yep
05:54:15 <dcoutts> dons, err compare I think
05:54:18 <ndm> would be easier to get Yhc working probably...
05:54:22 <Beelsebob_> ndm: good stuff - because Hat now has the whole Data.* stoofs
05:54:35 <kombinator> Smokey`: but you won't have a compacting gc in C++ and still suffer from fragmentation
05:54:36 <ndm> Beelsebob_, cool :)
05:54:37 <Beelsebob_> so I'll do a 'make debug' script
05:54:47 <dons> dcoutts, well, compare on its own I couldn't see a problem with, but I got issues when doing compare on packByte.
05:54:54 <dcoutts> dons, ah ok
05:54:55 <dons> only in the head though
05:54:57 <ndm> send a patch over, and any (minimal) changes that need making
05:55:05 <dcoutts> dons, let me try and reporduce...
05:55:06 <dons> ghc was inlining things such that nast nasty stuff happened
05:55:32 <dcoutts> dons, really? cool. :-)
05:55:38 <dcoutts> like what?
05:56:02 <Smokey`> kombinator: when the need for that arrises (which it hasen't, in any of my libs/apps), then i'll consider C#.  untill then, the switch isn't necessary.
05:56:05 <Beelsebob_> ndm: /usr/bin/ld: can't create output file: hoogle (Is a directory, errno = 21)
05:56:11 <dons> just ponder:
05:56:13 <dons> --  packByte 255 `compare` packByte 127
05:56:13 <dons> --
05:56:13 <dons> -- is compiled to:
05:56:13 <dons> --
05:56:15 <dons> --  case mallocByteString 2 of 
05:56:18 <dons> --      ForeignPtr f internals -> 
05:56:20 <dons> --           case writeWord8OffAddr# f 0 255 of _ -> 
05:56:23 <dons> --           case writeWord8OffAddr# f 0 127 of _ ->
05:56:25 <dons> --           case eqAddr# f f of 
05:56:28 <dons> --                  False -> case compare (GHC.Prim.plusAddr# f 0) 
05:56:30 <dons> --                                        (GHC.Prim.plusAddr# f 0)
05:56:33 <dons> let me know when you see what the problem is ;)
05:56:36 <ndm> Beelsebob_, I don't use makefiles, if its broken, fix it or send a patch to delete it :)
05:56:44 <Beelsebob_> ndm: it's because of case sensitiveness
05:56:52 <Beelsebob_> rename the directory src/Hoogle to something else
05:56:57 * dcoutts looks at the code
05:56:58 <Beelsebob_> or rename the output file
05:57:05 <kombinator> Smokey`: believe me - fragmentaton is really evil and hard to work around, unless you can keep restarting your processes
05:57:39 <dcoutts> dons, we're compareing the address and not the value?
05:57:45 <dons> dcoutts: anyway, a unsafe, instead of inlinePerformIO, fixed the inlining nuttiness, and now that test passes in the head and in 6.4.2.
05:57:57 <dons> no no. we start with two separate bytestrings
05:58:03 <dons> but end up with a single one, 'f', ...
05:58:03 <ndm> Beelsebob_, rename the output file then - thats easier
05:58:06 <dons> which is always Eq.
05:58:08 <dcoutts> dons, ah!
05:58:17 <dons> i was stunned
05:58:28 <dcoutts> dons, mm, yes identity is important :-)
05:58:43 <dons> anyway, i hope that was your bug. it only affected the head though.
05:58:57 <dons> perhaps you could pull the latest fps, and see if you can reproduce
05:58:57 <dcoutts> dons, I'll darcs pull & try again
05:59:17 <dcoutts> dons, I was trying to write Data.ByteString.Lazy
05:59:23 <Smokey`> kombinator: I've never needed or wanted GC.
05:59:31 <dcoutts> dons, and noticed that my compare didn't work.
06:00:00 <dons> I was only able to get an error with compare in the presence of packByte.
06:00:09 <dcoutts> dons, right.
06:00:16 <dcoutts> that's what I was using
06:00:23 <dons> and your example, 2 `compare` 1 .... was confusing.
06:00:28 <kombinator> Smokey`: have you ever implemented software that needs to run continuously in C++?
06:00:59 <Smokey`> kombinator: define 'continuously', everything I do is real-time interactive applications (3D computer graphics, and physical simulations)
06:01:03 <dons> > 2 `compare` 1
06:01:03 <lambdabot> GT
06:01:10 <dons> Data.ByteString> packByte 2 `compare` packByte 1
06:01:11 <dons> GT
06:01:13 <Beelsebob_> ndm: target email for darcs send?
06:01:31 <ndm> Beelsebob_, -o tempfile.patch
06:01:36 <ndm> gzip tempfile.patch
06:01:40 <kombinator> Smokey`: at least several days w/o restart
06:01:50 <ndm> then ndmitchell   |@|  gmail.com
06:01:52 <dcoutts> dons, about the concat, I thought you were doing the previous thing for a good reason?
06:01:58 <ndm> otherwise it gets screwed in the mail
06:02:03 <Oeje1> @type Data.ByteString.packByte
06:02:04 <lambdabot> Word8 -> Data.ByteString.ByteString
06:02:10 <dons> yeah, i thought so too. but now it doesn't seem to be an isse
06:02:11 <Smokey`> kombinator: no. never.  I can definately see it'd be easier to use GC in that case, but still far more efficient to do it manually. (if done right.)
06:02:13 <dons> issue
06:02:15 <dcoutts> dons, rather than allocating a string for the whole total size
06:02:27 <dons> the code was legacy from darcs
06:02:29 <dons> and I didn't want to touch it.
06:02:31 <dcoutts> dons, ok, fair enough
06:02:31 <kombinator> Smokey`: sure, but you need to be very careful
06:02:45 <Beelsebob_> ndm: then what address?
06:02:45 <dons> but it was written before I introduce all the memfoo functions
06:02:45 <kombinator> Smokey`: and think globally about memory management
06:02:53 <Smokey`> kombinator: indeed.
06:03:02 <dons> so that's perhaps why there were no memcpys
06:03:04 <kombinator> Smokey`: no "encapsulation"
06:03:16 <Brody> ndm: how can i check for equality for Declare ? because the name of the var is giving me trouble
06:03:17 <dcoutts> dons, I got some way through writing the .Lazy version. But there's a lot to implement!
06:03:21 <pejo> Smokey, "far more efficient" is a pretty bold statement. 
06:03:31 <dons> dcoutts: I can believe that.
06:03:38 <dcoutts> dons, would you like the current version, just to see where I was going / what I was thinking of?
06:03:42 <kombinator> Smokey`: gc is generally more efficient than malloc ()/ free ()
06:03:46 <dcoutts> dons, especially the invariant
06:03:54 <Beelsebob_> ndm??
06:03:56 <dons> dcoutts: yeah, post it and I'll have a peek/poke
06:04:03 <dons> ;)
06:04:03 <dcoutts> ok I'l darcs send
06:04:10 <kombinator> Smokey`: and loses only to pool allocation (in general of course)
06:04:34 <eivuokko> dons, Hey.  Isn't ByteString's generate and hGetContents vulnerable to async exceptions?  generate to exceptions from filler funtion as well.  Is that by design (ie don't care)?
06:04:34 <dons> dcoutts: but can you test to check your compare issue is all gone, too?
06:04:41 <dcoutts> dons, will do
06:05:04 <dons> eivuokko: hmm. atm i don't care. but I probably should
06:05:11 <Beelsebob_> interesting... cs.york.ac.uk appears to be down
06:05:20 <ndm> Beelsebob_, really?
06:05:29 <Beelsebob_> just timed out on me
06:05:42 <ndm> Beelsebob_, yep, just did for me too - but worked 10 mins ago
06:05:51 <Smokey`> yeah I can see how GC would be 'easier' in a general term, I'm just saying I prefer to tailor everything specifically to the application to get the best performance possible for said application.
06:05:54 <ndm> works again for me now
06:05:56 <eivuokko> dons, Ah.  I sort of care.  I dislike unsafe stuff.
06:06:13 <Beelsebob_> email sent to your york adress
06:06:32 <dons> eivuokko: its an interesting point. perhaps I should steal some things from the Handle code.
06:06:48 <dons> we could definitely look into bracketing the filling function
06:06:49 <Brody> 12ndm: how can i check for equality for Declare ? because the name of the var is giving me trouble
06:06:50 <kombinator> Smokey`: so you're often implementing you own allocation strategies?
06:07:21 <Beelsebob_> so ndm: do I just add your source to my project and get on with it?
06:07:36 <Beelsebob_> or rather... create my project amongst yours
06:07:54 <dons> eivuokko: though no packed string library yet has bothered handling stuff other than what the underlying IO code will handle
06:08:22 <eivuokko> dons, What's the situ on mmap?  If you need, I think I could write the version for Windows if it's ok to return (ForeignPtr Word8,Int) as an interface (vs old mmap stuff in FPS, which was..leaky)
06:08:26 <eivuokko> dons, Ah.
06:08:49 <ndm> Beelsebob_, create your project amonst mine
06:08:53 <Beelsebob_> cool
06:09:04 <dons> eivuokko: well, with mmap, I can't get it into base as part of the basic ByteString lib. it needs too much weird stuff.
06:09:07 <ndm> Beelsebob_, src/XHoogle if that suits you
06:09:12 <Beelsebob_> yep
06:09:14 <dons> but a System.MMap would be doable, if there was a windows interface
06:09:21 <dons> otherwise a System.Posix.MMAp
06:09:22 * Beelsebob_ wonders if he has any time for this
06:09:29 <Smokey`> kombinator: if the application needs it, yes.  but again, the need rarely comes up.
06:09:29 <ndm> Beelsebob_, got your patch, thanks, will commit on monday
06:09:34 <Beelsebob_> cool :)
06:09:37 <eivuokko> dons, Oh, "nice"!  Then I can add such stuff into Win32-package?
06:10:17 <dons> i'm not sure who maintains Win32, but I suspect submitting any patches to it would be welcome (by ndm ;) 
06:10:33 <ndm> dons, i have never used Win32, if i want to, i just use C :)
06:10:34 * Brody :(
06:10:38 <eivuokko> dons, I think it is unmaintained in practice.
06:10:52 <dons> ah, right.
06:12:02 <eivuokko> dons, ndm, It is kinda hard to say what should go in Win32, because at the moment it is totally Win9x compatible, but a lot of usefull stuf is (partially) dependent on WinNT
06:12:36 <eivuokko> Like async io and security attributes stuff.
06:12:42 <dons> eivuokko: if you ever want to do a scan for trouble spots regarding leaks or aync exception issues, i'd be happy to see the results.
06:12:48 <dons> (in ByteString)
06:12:54 <eivuokko> dons, I already did.
06:13:07 <dons> and you mailed me the patches/comments??
06:13:13 <dons> :)
06:13:13 <eivuokko> Ah, no
06:13:28 <eivuokko> I wasn't sure if it was by design.  And I am not sure if I want to mess up optimisations
06:13:44 <dons> the mmap stuff is left over from darcs days.
06:13:44 <dons> but if you want to loo
06:13:49 <dons> k at the current code
06:14:00 <dons> i've been doing lots of stress testing on it for leaks and similar.
06:14:13 <dons> but a careful eye might spot things i've been ignoring
06:14:14 <eivuokko> Hmh.
06:14:36 <eivuokko> I am paranoid on async exceptions. :)
06:14:56 <dons> (the point about darcs days is that the current Data.ByteString has been mostly rewritten from what's called FastPackedString )
06:15:35 <dcoutts> dons, btw you're interested in mentoring a haskell shell project
06:15:45 <dons> dcoutts: yep. 
06:16:02 <dcoutts> dons, that student has also applied for a darcs gui project which I said I'd be happy to mentor. We'll have to sort something out. :-)
06:16:10 <dons> ah. right.
06:16:32 <dcoutts> dons, btw, what is it with functional shells? we've got 3 propoals for them.
06:16:42 <dons> yeah, i know. i'm surprised
06:16:43 <dcoutts> has this just totally passed me by
06:16:53 * dcoutts fails to see the point
06:16:54 <dons> maybe some see it as an easy proposal to get into ?
06:17:04 <dons> or maybe it just looks fun
06:17:09 <dcoutts> what are we trying to do? replace bash?
06:17:25 <dons> i've had this functional shell project floating around for several years, and I haven't got anyone to bite yet.
06:17:29 <dons> until now.
06:17:40 <dons> I'd like a bash replacement, yes.
06:18:00 <vincenz> Oejet: joining us?
06:18:03 <wchogg> dons:  What would try to do better than bash?
06:18:09 <dons> like h4sh on steroids and speed
06:18:11 <dons> higher order functions
06:18:14 <dons> type safety
06:18:31 <dcoutts> dons, anyway, if he goes for the shell project then I'd mentor a gstreamer bindings instead.
06:18:31 <vincenz> dons: erm... typesafety would be a lot lesS... given how most things are text
06:18:38 <dcoutts> dons, there's two of them going. :-)
06:18:48 <dons> vincenz: check out esther
06:18:53 <vincenz> @google esther
06:18:54 <xerox> Who did mark the visual haskell one?
06:18:55 <lambdabot> http://www.esther.com/
06:19:08 <dons> esther is a shell written in clean
06:19:36 <vincenz> erm
06:19:40 <vincenz> clean and haskell are nearly 1-1
06:19:50 <dons> erm. yes.
06:20:26 <dons> ah, good. some more applicatoins have landed.
06:20:34 <dons> i hope we get a few more before the cut off though..
06:21:03 <eivuokko> xerox, Some student wants to work on Visual Haskell?
06:21:27 <Brody> anyone feeling like helping
06:22:53 <xerox> Yes
06:23:05 <Brody> ok
06:23:39 <dons> dcoutts: let me know how the compare/packByte issue goes.
06:23:45 * dons <- sleep
06:23:47 <dcoutts> dons, ok
06:23:49 <Brody> i defined a type
06:23:52 <Brody> data Prg =
06:23:52 <Brody>  | Declare Variable    
06:23:52 <Brody>  | Prg :> Prg    
06:23:52 <Brody> etc 
06:24:11 <Brody> and nod i need to compare 
06:24:29 <Brody> Declare var with another declare var1
06:24:40 <Brody> and i need a true if its a declare
06:24:43 <Brody> else its a false
06:25:11 <Brody>  Declare var with another  one of the data
06:25:19 <vincenz> Brody: 
06:25:21 <vincenz> data Pr g - 
06:25:38 <vincenz> data Prg = .... deriving (Eq, Ord)
06:26:28 <Brody> it says unexpected keyword deriving
06:26:58 <Brody> do i need to import something ?
06:27:51 <joelr1> howdy
06:28:00 <shapr> hola
06:28:06 <joelr1> :D
06:28:20 <joelr1> shapr: how are you today?
06:28:42 <shapr> I am awake! How are you?
06:29:34 <xerox> He's well away!
06:29:40 <xerox> s/away/awake/ -- dang.
06:30:46 <Brody> can anyone tell me why haskell gives unexpected keyword deriving
06:31:51 <pejo> Brody, sounds like whitespace problems. Put deriving on the same column as you have your | on. 
06:33:08 * joelr1 is thinking haskell
06:33:21 <Brody> ok
06:34:03 <shapr> How do I get a list of tags in a darcs repo?
06:34:56 <eivuokko> darcs changes --tags "."
06:35:19 <joelr1> that's interesting, i didn't know about "."
06:35:26 <joelr1> that's a match right? 
06:35:29 <joelr1> at least a symbol
06:35:41 <eivuokko> I am fairly sure --tags takes regexp
06:36:20 <shapr> I'm trying to get the HaXml repo back HaXml 1.13, but there doesn't seem to be a tag for such...
06:39:01 <shapr> aha, darcs unpull --last=NUMBER should work.
06:39:22 <ndm_> shapr, haxml used to be cvs, and its been converted a pile of times - its probably just very confused :)
06:41:44 <Brody> data Prg =  | Declare Variable  | Prg :> Prg  | Variable := Exp | etc..........
06:41:44 <Brody> I want to traverse a program  and remove all Declare how can i check that the current prg is infact a Declare ? baring in mind that the Variable will always be differnet 
06:43:13 <musasabi> Brody: foo (Declare var) = ...; foo somethingElse = ...
06:43:16 <ndm_> Brody: pattern matching
06:43:49 <Brody> but i dont want to check for equality of the variable
06:43:56 <shapr> try it
06:44:00 <Brody> just the Declare
06:44:06 <shapr> foo (Declare x) = 
06:44:26 <Brody> ok
06:44:37 <musasabi> > (\(Just x) -> x + 2) (Just 5)
06:44:38 <lambdabot> 7
06:44:42 <musasabi> like that.
06:44:55 <xerox> > liftM (+2) (Just 5)
06:44:56 <lambdabot> Just 7
06:44:58 <xerox> > liftM (+2) Nothing
06:44:59 <lambdabot> Nothing
06:45:23 <musasabi> xerox: as an example of pattern matching?
06:45:47 <xerox> Higher level application....
07:00:27 <Brody> can anyone tell me why haskell is giving overlapping instances of Eq ?
07:06:06 <dcoutts> dons, got it.
07:06:17 <dcoutts> dons, comiling with -fasm gives us the problem
07:06:25 <dcoutts> > packByte 2 `compare` packByte 3
07:06:25 <dcoutts> GT
07:06:25 <lambdabot>  Not in scope: `packByte'
07:06:42 <dcoutts> dons, when I compile via C I get the right answer
07:06:57 <dcoutts> dons, it's not -O or the other flags
07:07:12 <dcoutts> -fasm -O is wrong -via-C -O is right
07:09:43 <dcoutts> dons, looks like -fasm is doing some signed/unsigned thing wrong.
07:12:20 <Brody> can anyone tell me why haskell is giving overlapping instances of Eq ?
07:14:14 <xerox> Brody: give more context
07:15:04 <Brody> i did my datatype and i did  deriving (Eq)
07:15:23 <Brody> decf :: Prg -> Bool
07:15:24 <Brody> decf (a :> b) = (decf a) :> (decf b)
07:15:35 <Brody> decf  (Declare k)  = True
07:15:43 <Brody> decf (s := k)  = False
07:15:49 <Brody> instance Eq Prg where
07:15:50 <Brody> x == y = decf x == decf y
07:16:04 <ndm_> Brody: either deriving Eq or instance Eq, never both
07:16:22 <Brody> ahh ic
07:16:26 <ndm_> either get the compiler to do it (deriving) or do it yourself (instance)
07:16:33 <_fab> hi, i have two Data.Map's s and t and need a function that returns Nothing, if there exists a key whose value in s and t differ and Just (union s t) otherwise... How can i implement something like this?
07:16:35 <Brody> so when i derive i am accepting Eq as is ?
07:16:56 <ndm_> Brody: you are asking the copmiler to write an instance Eq for you
07:17:17 <dcoutts> dons, I was using ghc-6.4.2 on amd64 linux.
07:17:43 <Brody> now i understand
07:18:44 <Brody> but still gives an error Ambiguous variable occurance "==" when i removed deriving "Eq"
07:21:11 <ndm_> thats a separate error, you got your instance Eq wrong somewhere
07:27:20 <_fab> i need some kind of combination of intersection and folding to solve this...
07:28:57 <Brody> instance Eq Exp where  -- Any expressions gives true
07:28:57 <Brody>            x == y =  True
07:29:04 <ndm_> _fab, why not just too tests with lookup?
07:29:11 <Brody> can i do this ? so that the expression returns always true ?
07:29:17 <ndm_> if you use the maybe monad, its a few lines tops
07:29:55 <_fab> ndm_: with lookups it would be at least O(n * log(m)), while the intersection algorithms in Data.Map are O(n + m)
07:30:08 <xerox> Brody: yes, you can.
07:30:20 <_fab> ndm_: it would be possible, but not very elegant imo
07:30:28 <xerox> Brody: I don't think it's a good idea, anyway.
07:30:52 <Brody> ok fixed
07:32:40 <dcoutts> dons, I've got a reduced test case. The problem is just that ghc's x86_64 NCG mis-compiles FFI Int return values as word
07:32:53 <dcoutts> dons, so c_id (-1) == 4294967295
07:33:10 <dcoutts> where int c_id (int n) { rturn n; )
07:33:29 <dcoutts> I'll go file a bug report...
07:33:54 <xerox> @karma+ dcoutts 
07:33:55 <lambdabot> dcoutts's karma raised to 11.
07:34:09 <dcoutts> :-)
07:36:16 <ndm_> _fab, i doubt it, because you will have to do a lookup anyway, which is n * log(m)
07:36:30 <ndm_> doing two just makes it 2 * n * log, which is still n * log
07:37:47 <xerox> Wish me luck!
07:39:38 <_fab> ndm_: intersectionWithKey has O(n+m), and can call a function with the values of each intersection, so it must possible to traverse two Maps and compare the keys in O(n+m). 
07:47:05 <dcoutts> dons, submitted as http://hackage.haskell.org/trac/ghc/ticket/765
07:50:45 <ndm_> _fab, sorry, i thought you meant for a particular key, i didn't realise you mean for all keys :)
07:51:29 <_fab> i just want to make sure that the intersecting keys of to Maps have the same values ;)
07:51:43 <kpreid_> _fab: how about \a b -> if all id $ elems $ intersectionWithKey (\_ -> (==)) a b then Just (union a b) else Nothing
07:52:53 <kpreid_> I don't think that has anything that's not O(n) besides union and intersectionWithKey
07:53:10 <_fab> kpreid_: what does "$" mean?
07:53:26 <kpreid_> (a b $ c d) is the same as (a b (c d))
07:53:45 <xerox> \_ -> (==)  =  const (==)
07:54:06 <kpreid_> it's just low-precedence function application
07:54:09 <kpreid_> @t $
07:54:09 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
07:54:11 <kpreid_> xerox: thanks. I don't do enough Haskell to remember all the combinators :)
07:54:16 <kpreid_> @type $
07:54:17 <lambdabot> parse error on input `$'
07:54:20 <kpreid_> @type ($)
07:54:21 <lambdabot> forall b a. (a -> b) -> a -> b
07:54:26 <xerox> f $ x = f x
07:54:41 <kpreid_> @pl all id
07:54:42 <lambdabot> and
07:54:44 <kpreid_> ah
07:55:18 <_fab> kpreid_: looks like it could work, thank you!
07:55:43 <kpreid_> @pl \x y -> if x then Just y else Nothing
07:55:43 <lambdabot> flip flip Nothing . (. Just) . if'
07:55:49 <kpreid_> @type if'
07:55:50 <lambdabot> Not in scope: `if''
07:56:08 <kpreid_> @hoogle if'
07:56:08 <lambdabot> No matches found
07:56:15 <kpreid_> OK, what's if'?
07:57:49 <ndm_> kpreid_: if' b t f = if b then t else f
07:57:54 <kpreid_> ah
07:57:55 <ndm_> i usually call it cond
07:58:14 <ndm_> but its not in the standard libs anywhere, sadly
07:59:06 <kpreid_> _fab: improved version: \a b -> if and $ elems $ intersectionWith (==) a b then Just (union a b) else Nothing
08:00:25 <kpreid_> I'd think the (if x then Just x else Nothing) pattern is removable, but I don't know how
08:06:38 * shapr swears at research papers that cost money to read.
08:07:41 <eivuokko> ACM?
08:08:09 <Igloo> dcoutts: Your bug is not well-typed: int corresponds to CInt, not Int
08:08:45 <dcoutts> Igloo, but CInt is also signed
08:09:05 <ndm_> shapr, but now nearly everyone puts their papers on their home pages
08:09:18 <shapr> eivuokko: Nah, ieee. Seems I'm not the first person to have come up with a magnetic gearbox where the only 'moving' parts are the magnetic field itself.
08:09:58 <Igloo> dcoutts: But the results there could happen if the high bits get zeroed. I don't know if that is the cause of the problem, anyway, but confirming it does happen in the type-correct case would be good  :-)
08:10:00 <shapr> ndm_: Only for CS.
08:10:28 <ndm_> shapr: true, paying for chemistry papers is the norm, and you can't get subscriptions for them
08:10:36 <dcoutts> Igloo, ok
08:10:38 <ndm_> about 30 a shot for some of them...
08:11:21 <shapr> I can't afford to buy a bunch of papers about magnetic gearings.
08:11:26 <dcoutts> Igloo, ooh, it's ok for CInt
08:11:38 <dcoutts> Igloo, what does that mean then?
08:12:20 <Igloo> dcoutts: Well, I imagine it happens due to the high bits getting zeroed as above. What it means is you should write correct code  :-)
08:12:54 <dcoutts> Igloo, yeah yeah. Then Int shouldn't be a valid FFI type. :-)
08:13:10 <Igloo> Int is fine, as long as you use HsInt on the C side
08:13:38 <dcoutts> right
08:13:42 <dcoutts> well blame dons :-)
08:13:53 <dcoutts> it was from the FPS code
08:14:16 * Igloo wouldn't be surprised if it originates from darcs
08:14:21 <dcoutts> heh
08:14:29 <dcoutts> it was the decl of memcmp
08:15:13 <Beelsebob_> hmm, I think that I've come to the conclusion that SEE still wins if the guy is planning on adding BNF based CF grammars to syntax matching
08:15:16 <Igloo> I was putting off cleaning up those mismatches in the hope that GHC's optimiser would be improved to the opint David would agree with rewriting all the C bits in Haskell, at which point there is less to fix
08:15:42 <Igloo> And ran out of darcs hacking time before giving up on that happening
08:16:09 <Brody> can i do this ?
08:16:11 <ndm_> 100% Haskell darcs would be cool :)
08:16:11 <Brody> instance Eq Exp where  -- Any expressions gives true
08:16:11 <Brody>            x == y = True
08:16:11 <Brody>            x /= y  =  True
08:16:14 <Philippa_> ndm: to be fair, CS papers are generally cheaper to produce
08:16:46 <Brody> becuase it is still working as usual
08:17:00 <ndm_> Philippa_: i know, and chemistry papers can go and make money in the real world - most computer science papers are "a bit pointless" when it comes to industry (at least for the moment)
08:17:50 <ndm_> Brody: thats not a great idea, but its legal - its a good idea for x /= y  ==== not (x == y)
08:17:53 <Igloo> ndm_: I don't think it's far away. Just need to change to using a file locking library and then it's just FPS, which uses C only for performance reasons (factor of 2 doing most things on large strings)
08:18:00 <mahogny> the gap between CS academics and industry is huge. way too huge
08:18:26 <Beelsebob_> ndm_: [[/=]] = [[not . ==]]
08:18:29 <ndm_> Igloo: does ByteString close that gap?
08:18:55 <dcoutts> Igloo, I think you should get darcs people to help with ByteString.Lazy :-)
08:18:58 <Brody> ok zop
08:19:15 <ndm_> Beelsebob_, arrgh, function equality, you broke your turing machine :)
08:19:22 <eivuokko> Windows MAPI support in darcs is also in C.
08:19:24 <Beelsebob_> ndm_: :P
08:19:34 <Beelsebob_> semantic equality thank you :)
08:19:43 <ndm_> eivuokko: windows MAPI support is broken to massive levels in darcs, it should just be removed
08:19:46 <Igloo> ndm_: Only in as much as it could take the C code out of darcs itself
08:19:59 <eivuokko> ndm, no, it should be rewritten
08:20:09 <ndm_> (and thats from a Windows darcs user, who would love to use darcs send)
08:20:11 <eivuokko> ndm, someone broken meaning of many functions when they worked on mime stuff
08:20:13 <Igloo> I think dons has also decided to take the performance hit rather than keeping the C code around
08:20:49 <ndm_> eivuokko: its entirely broken with thunderbird, as in 100% non functional for any purpose
08:21:11 <eivuokko> ndm, it is probably easy to fix.  I jsut don't use darcs send and I don't want to touch the code until mime stuff is done (I dunno if it is)
08:21:14 <shapr> hej lennart 
08:21:55 <shapr> Philippa_: Yeah, but magnetic theory papers are pretty easy too. You mostly use simulation software to figure out how the fields interact.
08:26:02 <Brody> anyone feel like helping its a bit hard i ve been trying for 4 hours now
08:26:13 <Brody> and all is invain
08:26:29 <shapr> What's your question?
08:31:34 <Philippa_> shapr: tradition. The field is Potentially Expensive, why charge less just 'cos you did it cheaper?
08:31:42 <Philippa_> or to put it another way, capitalism's infectious
08:32:23 <Philippa_> mahogny: I disagree. The problem isn't CS, the problem's that Software Engineering is pretty much a nascent field - SE's what industry should be looking at most of the time
08:32:45 <Philippa_> (and in return they should be keeping away from CS programs more)
08:33:24 <mahogny> Philippa_, hm. I don't make a major difference
08:34:07 <Philippa_> no? I don't see much of industry giving a damn about the finer points of pure type systems, or studying pi calculus for its own sake, or...
08:34:26 <Philippa_> rewriting systems're an apache module if you're in industry, for example
08:34:30 <mahogny> Philippa_, I mean between CE and CS
08:34:45 <Philippa_> I said SE rather than CE, and for a reason
08:34:52 <mahogny> ehr. I meant SE
08:35:10 <mahogny> I have a huge brutal synonym here so I think we ran past each other :)
08:35:31 <Philippa_> I do. I don't see rules of thumb about how to make systems extensible to be part of CS
08:35:47 <Philippa_> I don't see human factors in software development to be CS at all
08:35:59 <Philippa_> nor management issues
08:36:26 <Philippa_> sure, a significant part of SE'll be applied CS, much as elsewhere engineering is applied physics, applied chemistry...
08:36:55 <mahogny> if one work by those means, one certainly need to open the window and have a reality check once in a while. one can't just output stuff and expect it to be accepted on the other side
08:37:33 <Philippa_> sure, but CS folks talk to SE about that when they're looking to do such things, not to industry directly
08:38:01 <Philippa_> industry doesn't know what it's looking for and pretty much by definition can't, or it'd be doing CS itself
08:38:28 <mahogny> I don't see a major reason for that work division. it just isolates CS from reality
08:38:50 <mahogny> but if it is as you say, then I agree SE is doing a very poor job
08:39:15 <Philippa_> the parts of CS that're genuinely CS are very much isolated from 'reality' already
08:39:33 <Brody> how can i check for equality of a datatype and at the same time ignore some of the inner types
08:39:43 <Philippa_> Brody: "inner types"?
08:40:07 <mahogny> Philippa_, yes. that oughta be changed. the CS community need to invite the industry directly
08:40:22 <Philippa_> no, we don't. We *need* to be allowed to do stuff that isn't at industry's beck and call
08:41:22 <Philippa_> we don't even have that argument in other sciences, you don't see industry trying to steer the direction of theoretical physics
08:41:52 <mahogny> I didn't say you shouldn't be allowed to do what you do. I only say that it should be made easier to take part SE's role to obtain a better understanding on how the very fundamental research can be applied
08:42:01 <Philippa_> nor do you generally see industry directly interested in 'pure' maths
08:42:14 <Philippa_> and you do that by *having a field of software engineering*
08:42:25 <Brody> data Prg =
08:42:25 <Brody>  Declare Variable        -- i want to extract declarations from the program       --
08:42:25 <Brody>  | Variable := Exp       
08:42:25 <Brody>  | Prg :> Prg       
08:42:25 <Brody> etc...
08:42:37 <mahogny> Philippa_, that's another problem I hope can be solved by inviting industry. the communication is two-way after all
08:42:51 <ndm> i had to do a group project on "marketing crap" because my CS dept wants BCS accreditation - thats an example of th e industry destroying my degree (and my time!) for stupid reasons
08:42:53 <Philippa_> industry doesn't want to do SE research either
08:43:11 <Philippa_> ndm: yup. Ironically enough, I didn't get to the meat on databases either for much that reason
08:43:26 <Philippa_> and don't get me started on the excuse for an OOA/OOD module here
08:43:34 <Philippa_> accessor methods *are not an analysis concern* dammit!
08:43:47 <mahogny> Philippa_, considering that the industry is completely isolated, it is no wonder that the industrial research climate is what it is
08:44:25 <Philippa_> the industry isn't isolated, it's been screwing around with the contents of CS degrees for the last 20 years
08:44:42 <shapr> Any idea how much 665 Nm of torque translates into something I can understand? :-)
08:44:43 <mahogny> Philippa_, that certainly hasn't shown
08:44:51 <Philippa_> *hah*
08:45:21 <Brody> hmm
08:45:23 <Philippa_> granted, half of it also comes from student perception of what industry wants, because CS is where you do SE
08:45:40 <mahogny> agree. that's a problem
08:45:41 * shapr merrily designs a magnetically geared unicycle hub with lots of different speeds.
08:45:44 <Philippa_> but ultimately, unis're teaching Java because there's demand for it. They were teaching C++ before it for that reason too
08:45:56 <Philippa_> the historical reasons for C were, admittedly, a bit better
08:46:23 <ndm> York teaches Ada, and there is no reason to do that :)
08:46:54 <mahogny> Philippa_, I don't think we should stop teaching those languages though, but I'd rather see it put later in the education with much less focus
08:48:39 <Philippa_> ndm: I'm not sure I agree entirely, depending on how, when etc
08:48:45 <Philippa_> mahogny: quite
08:49:11 <ndm> Philippa_: i can only assume you don't know ada...
08:49:12 <Beelsebob_> anyone got any nice 5-10 line CPS examples?
08:49:53 <Philippa_> ndm: I don't remember enough tokens to right hello world, I actually get the impression I could quite come to like ada '95 or ada '05 in their niches
08:50:31 <ndm> Philippa_: it looks good on the surface, but when you get as far as generics, the world comes down
08:50:38 <Beelsebob_> yerch, from my experience of Ada it's horrific
08:50:49 <Philippa_> ndm: more so or less than it does in C++?
08:50:49 <Beelsebob_> principally because it has 60000 ways of doing the same thing
08:51:10 <ndm> Philippa_: its worse than C++, its only good for concurrency and locking
08:51:14 <Beelsebob_> you can create a thread in any one of 20 different ways each of which do something subtly different and none of which are what you need
08:51:18 <ihope> @where hscurses
08:51:19 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
08:51:19 <mahogny> Beelsebob, http://citeseer.ist.psu.edu/rd/33253734%2C45878%2C1%2C0.25%2CDownload/http%3AqSqqSqwww.cs.chalmers.seqSq%7EkoenqSqPapersqSqpearl.ps   not 5-10 lines but good reading anyway
08:51:36 <Beelsebob_> thanks mahogny 
08:51:38 <mahogny> I dislike ada mostly because of the syntax
08:51:42 <Beelsebob_> ditto
08:51:46 <ffranzosi> hi guys... I am about to sing up in the Summer of Code but I would like to have some adding ideas for my initial proposal: http://hackage.haskell.org/trac/summer-of-code/ticket/80, could anyone help me?
08:53:00 <mahogny> ffranzosi, I think that suggestion already is quite concrete as is
08:53:03 <ndm> ffranzosi: add a link about BSP to that page
08:53:30 <ihope> So hscurses doesn't work with Windows?
08:53:48 <ffranzosi> ok..
08:54:44 <ffranzosi> mahogny: I'm saying this because I have already done some of the code relative to my project
08:55:28 <eivuokko> ihope, maybe you could try porting it against pdcurses or something like that.  It _might_ not be that much work.
08:55:31 <ffranzosi> mahogny: and maybe some new Ideas would really help me to do something great for the community
08:55:50 <ihope> eivuokko: I'd like to do as little work as possible :-P
08:56:21 <mahogny> ffranzosi, is MPI really the ideal library for this?
08:59:56 <ffranzosi> mahogny: I have also the BSPlib, which is a specific library for BSP
09:00:10 <Brody> kulhadd igerrih :)
09:00:32 <ffranzosi> mahogny, but MPI is a better tested environment...
09:01:07 <shapr> ffranzosi: You could update hMPI by Hal Daume.
09:01:36 <shapr> See hMPI on http://www.isi.edu/~hdaume/software.html
09:01:40 <ffranzosi> mahogny, the PVM model would surelly be an option, however it doesn't fits like a glove into BSP model
09:02:01 <mahogny> ffranzosi, true that. but IIRC MPI is quite sensitive to if your machines work or not. I dunno if this might be a problem for whatever applications you consider
09:04:23 <ffranzosi> shapr, I have already taken a look into hMPI project, but although it seems interesting, it is a very low level project, which means you don't gain much in using a high level language such as haskell
09:05:28 <ffranzosi> shapr, But I would like some ideas to serialize data structures to pass it through network
09:05:41 <shapr> You should ask musasabi.
09:06:05 <xerox> Hi ffranzosi !
09:06:12 <ffranzosi> mahogny, what do you mean by IIRC MPI?
09:06:28 <shapr> You could start off with SerTH, which can automatically serialize anything 'concrete'.
09:06:30 <xerox> ffranzosi: did your mentor sign up, I'm sorry for the delayed answer
09:06:47 <ffranzosi> xerox: not yet...
09:07:57 <ffranzosi> shapr: I already took a look at this project...
09:07:59 <psi> xerox: how many apps are in now?
09:08:11 <xerox> psi: I don't know exactly
09:08:23 <psi> ok
09:08:24 <Brody> is there a a way to represent any string like _ in prolog 
09:08:33 <ffranzosi> shapr: but it uses file handlers only
09:08:34 <ffranzosi> shapr: which does not fit into my project
09:08:48 <psi> Brody: when pattern matching? you can use _
09:09:05 <shapr> ffranzosi: You could hack it together with Bulat's Streams lib maybe?
09:09:47 <psi> Brody: what are trying to do?
09:10:00 <Brody> i have a type
09:10:14 <mahogny> ffranzosi, IIRC=if I recall correctly
09:10:39 <Brody> type Variable = String
09:10:39 <Brody> data Prg =
09:10:39 <Brody>    Skip
09:10:39 <Brody>  | Declare Variable               --
09:10:39 <Brody>  | Variable := Exp                 --
09:10:40 <Brody>  | Prg :> Prg                         --
09:11:03 <Brody> and i want to extract all the declares from a Pgm
09:11:07 <Brody> Prg
09:11:25 <Brody> how can i do it
09:11:39 <ffranzosi> mahogny, ok that's a point but I do think we should give a chance and test how haskell works with MPI
09:11:44 <mahogny> ffranzosi, yeah
09:12:13 <ffranzosi> shapr, thanks for the advice
09:12:21 <mahogny> Brody, that'd just be a recursive function that picks out all Declares
09:12:30 <Brody> but how?
09:12:44 <ffranzosi> shapr, I will take a look at that Streams lib
09:12:46 <Brody> how can i check if its a declare
09:13:11 <ndm> Brody: how much haskell have you done beofre? you must have done some exercisees before?
09:13:12 <ihope> declares (x :> y) = declares x ++ declares y; declares (Declare x) = [x]; declares Skip = []; declares (x := y) = []
09:13:43 <mahogny> Brody, well, how about .... foo :: Prg -> [Variable]  for a start.    then    foo (Declare v) = [v]    then pattern match the rest in the same way
09:14:00 <ffranzosi> shapr, Do you have worked with any of those libs?
09:14:25 <Brody> ok
09:19:08 <shapr> ffranzosi: Not recently, no.
09:31:08 <ffranzosi> shapr, could you send me the link to the Bulat's Streams library, I tried to google it but it is not working yet...
09:31:23 <ralejs> @hoogle Word8 -> Word32
09:31:24 <lambdabot> No matches, try a more general search
09:32:52 <shapr> @google bulat streams haskell
09:32:54 <lambdabot> http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/9261
09:36:13 <isaacd> ralejs: "For coercing between any two integer types, use fromIntegral, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign."
09:36:21 <isaacd> from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
09:36:57 <ralejs> isaacd: Thanks! I missed that comment at the end of the page.
09:38:07 <shapr> ffranzosi: http://freearc.narod.ru/
09:38:53 <ffranzosi> oh thanks..
09:41:54 <ffranzosi> xerox: I have to wait until my mentor sing up as a mentor in google for me to sign up?
09:42:36 <xerox> ffranzosi: no!
09:42:41 <xerox> ffranzosi: wasn't clear from the email?
09:43:39 <ffranzosi> franzosi, reading it again I can say that it doesn't give an specific order for the things
09:43:57 <ffranzosi> xerox: reading it again I can say that it doesn't give an specific order for the things
09:44:20 <ffranzosi> xerox: but I can say it is OK, I will do it
09:47:24 <xerox> ffranzosi: yes, the order isn't important, the deadline for proposals is May 8 at 10:00 PDT, though
09:48:05 <ffranzosi> xerox: ok, thanks again
09:48:13 <xerox> You're welcome!
09:48:30 <davidhouse> in LHS files, do you/can you leave a space between the leading > and the code?
09:48:51 <xerox> You do, yes...
09:49:40 <psi> I can't wait until they announce the results. I hope we don't have to wait till may 22 :)
09:51:01 <xerox> You'd better have to :-)
09:51:54 <dcoutts> xerox, how are we going to meet & discuss the projects?
09:52:09 <dcoutts> by we I mean the mentors, I know you're not one of them
09:52:20 <xerox> Yeah.
09:52:33 <xerox> I don't know if Isaac has ideas in that regard
09:52:45 <xerox> But maybe trac would work
09:53:29 <dcoutts> xerox, do we have a list of the people who've actually signed up to be haskell.org mentors?
09:53:35 <xerox> Yes.
09:53:40 <dcoutts> Isaac must have that list
09:53:46 <xerox> The People page is right
09:53:59 <dcoutts> xerox, no it isn't
09:54:04 <dcoutts> http://hackage.haskell.org/trac/summer-of-code/wiki/People
09:54:15 <xerox> What's the desynch?
09:54:33 <dcoutts> as far as I know Igloo isn't signed up, he's decided he's too busy
09:54:42 <xerox> I know bringert had some problem
09:54:58 <dcoutts> there must be a definitive list somewhere of the people who signed up on the google system
09:55:15 <xerox> Igloo: did you sign up or should I took you off?
09:55:32 <xerox> dcoutts: I've been using that list and mailing those people, hmm.  But yes.
09:55:40 <dcoutts> all the people who actually registered on the google system and asked to mentor for haskell.org
09:55:40 <xerox> dcoutts: can you see the list from inside the Google site?
09:55:54 <Igloo> I didn't sign up
09:55:54 <dcoutts> Isaac will have got an email for each one
09:56:07 <xerox> dcoutts: perfect
09:56:10 <dcoutts> xerox, no, I don't see any. I'm not the admin.
09:56:35 <lisppaste2> blub pasted "aufgabe 61" at http://paste.lisp.org/display/19776
09:56:46 <musasabi> *who* is the admin?
09:56:50 <xerox> Isaac
09:57:10 <musasabi> ok
09:57:16 <dcoutts> we need to chat about what criteria we use to decide applications
09:57:28 <dcoutts> obviously we need interested mentors
09:57:57 <dcoutts> but eg how do we make best use of our allocation
09:58:16 <dcoutts> there are various proposals along the lines of "build app X in haskell"
09:58:51 <dcoutts> I'd prefer projects that are going to be of most general benefit to the haskell community
09:59:07 <dcoutts> eg libs & tools etc
09:59:24 <dcoutts> we have several good proposals along those lines
09:59:26 <xerox> I think it makes sense too
09:59:59 <Philippa_> does "app x where x is really more of a framework" count?
10:00:05 <dcoutts> Philippa_, sure
10:00:15 <xerox> Strangely enough the MUD and other apps seem to be enjoyed by many people
10:00:21 <dcoutts> so long as it's a framework for something interesting or useful!
10:00:23 <Philippa_> well, guess it seems to as my brief suggestion ended up on the list
10:00:24 <Igloo> If I were to play devils advocate I might ask if darcs/pugs hadn't done more for the community than some library  :-)
10:00:37 <dcoutts> Igloo, sure, I'd include darcs in there
10:00:45 <Philippa_> agreed, a proliferation of funky code worth modifying that's in haskell is a good thing
10:00:46 <dcoutts> Igloo, we've got 2 proposals for a darcs GUI
10:00:52 <xerox> Right!
10:01:00 <Igloo> dcoutts: I think you've missed my point completely
10:01:11 <xerox> Also, pugs projects are exactly about important libraries
10:01:13 <dcoutts> Igloo, you mean simply because its a high profile app
10:01:14 <Igloo> But I wasn't being serious, so it doesn't really matter
10:01:14 <Philippa_> "so another darcs or pugs would be good"
10:01:26 <Philippa_> xerox: yes'n'no. They're about good driving cases for good libraries
10:01:58 <dcoutts> Igloo, that is useful and just happens to be written in Haskell (and so also happens to be useful for developing haskell projects)
10:02:01 <Philippa_> dcoutts: I'd say a generally usable one. Something most people can see a point in playing with sometime
10:02:16 <Philippa_> also, more examples of large haskell apps is a good thing
10:02:30 <Philippa_> "yes, you can build apps bigger than a KLoC in haskell if you really need to!"
10:02:31 <musasabi> Why have so few students from Trac applied to Google? (and how much more time do they have)
10:02:32 <dcoutts> but that's not something you can easily do in 3 months
10:02:46 <Philippa_> no, but often you can nail the core of one
10:02:59 <mahogny> Philippa_, I think half the point is that they don't have to become bigger than one kloc in haskell ;)
10:03:28 <xerox> musasabi: today and tomorrow until 10:00 PDT
10:03:41 <Philippa_> hell, the core of Flippi took a day, three months could have you a substantially usable wiki or web board or...
10:04:18 <mahogny> 3 months for the right programmer, fulltime work, in haskell ... you could do almost anything :o
10:04:23 <xerox> musasabi: I'm writing a mail to the list Cc:-ed to everyone of the People page students
10:04:40 <musasabi> thanks
10:04:59 <Philippa_> mahogny: not entirely true. You could make the core of most things if you know what you're doing, I'll give you that
10:05:09 <mahogny> Philippa_, ok, right
10:05:17 <Philippa_> some apps have a lot of sprawl in their inherant nature
10:05:31 <mahogny> Philippa_, making all levels and graphics for a game in 3 months would be hardcore :)
10:05:42 <Philippa_> not if it's a roguelike :-)
10:05:47 <mahogny> lol
10:05:54 <xerox> haha
10:06:03 <Philippa_> but even filling in all the non-level-specific gameplay stuff for an FPS could easily take >3 months
10:06:12 <Philippa_> and that's for a deathmatch-style one
10:06:46 <mahogny> hm. I think that depends on the game
10:07:02 <Philippa_> "could easily take" :-)
10:07:09 <mahogny> right :)
10:07:17 <mahogny> adding 3d is usually a bad sign
10:07:19 <Philippa_> but really, if you're doing anything more complicated than Q3A it's likely. Getting UT right must easily've taken longer than that
10:07:35 <Philippa_> (I'm a big fan of the original UT's deathmatch)
10:07:56 <mahogny> I heard many people liking it :)
10:08:00 <mahogny> +'ve
10:08:42 <psi> Q3A is pretty darn fun as well. especially the clan arena mod.
10:08:46 <Saulzar> You can write a quality Haskell game in less than x hours - if you have a fixed x hour time limit :)
10:09:26 <mahogny> I would say it depends on what libraries you have access to. 3d is usually naughty because of the lack of 3d libraries
10:10:20 <Saulzar> But any 3D game, doing something with frag (as listed) - is going to be considerable effort. Perhaps it can be made more game like and less demo like in a time frame though.
10:10:35 <mahogny> yes
10:21:58 <xerox> musasabi: sent.
10:22:01 <dcoutts> ADEpt, btw I was wondering what you thought was wrong with the VS/VH SoC proposal? You marked it ineligible.
10:22:41 <xerox> (Right.  The student behind it asked what was wrong too.)
10:23:35 <Philippa_> developing something UnrealScript like with hs-plugins, a simple structure-to-function compiler and a good monad or two could be interesting
10:23:42 <dcoutts> it was a bit waffly and under specified but I didn't think it was that bad
10:24:00 <dcoutts> mind you I'm not at all interested in win32 only projects
10:24:11 <dcoutts> but that's only a personal opinion
10:24:32 <mahogny> Philippa_, is it a good language?
10:24:37 <xerox> Argh.
10:24:40 <dcoutts> xerox, ?
10:24:49 <xerox> The mails are waiting approval from mentors.
10:25:00 <Philippa_> mahogny: it's reasonably good at what it does. The important thing is its object model is perfectly matched to its task
10:25:00 <xerox> I think they're hating me because of the cross-posting, sigh :-|
10:25:02 <dcoutts> what mails?
10:25:11 <Philippa_> (the task is surprisingly involved - it's a distributed system)
10:25:15 <xerox> dcoutts: I wrote a mail to students about the proposals
10:25:24 <xerox> I've Cc-ed them, anyway.
10:25:25 <mahogny> Philippa_, ah
10:26:49 <Saulzar> dcoutts, Btw. I had a go at using cairo for a tiny game, I don't think it's intended for that kind of thing - the fill rate is a little low.
10:27:17 <dcoutts> Saulzar, yeah it is at the moment. Hopefully the opengl backend will be good for that kind of thing.
10:27:33 <Saulzar> Yeah, I was wondering about that - how it is all connected.
10:27:41 <ADEpt> dcoutts: vs/vh?? let me check
10:27:52 <xerox> ADEpt: Visual Haskell
10:28:06 <dcoutts> Saulzar, if you can find specific cases where performance is bad then you can report that in the cairo bugzilla. They are interested in that.
10:28:21 <Saulzar> I made a couple of small tests for a 48h game comp, one using SDL/GL - the other GTK/cairo - I went with SDL/GL to be safe
10:28:25 <mahogny> I'd rather see some effort on hIDE which is platform independent, than VH
10:28:34 <dcoutts> mahogny, me too
10:28:45 <xerox> Yesh, that's why wee need people to work on GHC-plugins
10:28:51 <xerox> wee! :-P
10:28:51 <Saulzar> dcoutts, I think just in general drawing big shapes is slow - takes a while to fill using X11.
10:29:05 <dcoutts> Saulzar, well if you have any good test cases then send them in.
10:29:18 <dcoutts> they do want it to be fast
10:29:30 <Saulzar> They're not particually slow - ie. they would be adequate for normal use. But just not for a game.
10:29:37 <dcoutts> right
10:29:41 <mahogny> ghc-plugins really oughta be a part of ghc. they shouldn't be allowed to release a version that breaks compatibility. it's way too important to be something that's broken from time to time
10:29:57 <dcoutts> Saulzar, well that means it's too slow for some useful purpose, so they might look at it.
10:30:24 <dcoutts> Saulzar, they are in an optimising mode atm I think (rather than API or new features mode)
10:30:46 <Saulzar> dcoutts, How is the GL backend related? I would guess that would markedly help fill rate
10:30:50 <ADEpt> dcoutts: omg. seems like instead of "submit" button i pressed "ineligeble" :(
10:30:57 <dcoutts> as for the backends stuff, well cairo has several backends, on if which is Glitz which is based on GL
10:31:00 <ADEpt> dcoutts: i'll fix it in a jiffy
10:31:05 <dcoutts> ADEpt, ok, great.
10:31:15 <dcoutts> ADEpt, it's "untoss" I think :-)
10:31:29 <ADEpt> dcoutts: in Sergey here in irc perchance?
10:31:37 <dcoutts> dunno
10:31:44 <ADEpt> ^in^is^
10:31:55 <dcoutts> xerox, do you know?
10:32:03 <xerox> Yes
10:32:07 <xerox> Err, sorry misread
10:32:10 <xerox> a sec
10:32:33 <xerox> No, I don't know.
10:32:42 <akemp> @seen SyntaxNinja
10:32:42 <lambdabot> I saw SyntaxNinja leaving #haskell 1 day, 16 hours, 42 minutes and 9 seconds ago, and .
10:32:58 <dcoutts> Saulzar, but the idea is that eventualy the X server should use GL to accelerate the normal stuff, so the glitz cairo backend is only a stop-gap measure.
10:33:58 <Saulzar> dcoutts, Ah. Ok. Otherwise, it seems ideal for small games etc. it looks much cleaner than the equivalent GL hackup.
10:34:05 <ADEpt> dcoutts: fixed
10:34:16 <dcoutts> ADEpt, great
10:34:20 <xerox> I'll be mailing him
10:34:22 <xerox> Poor fellow :-)
10:35:09 <dcoutts> Saulzar, I don't know much more about the current state of the glitz backend. It might be worth looking into but it may also be a bit under-developed atm.
10:43:26 <greenrd> Is this function better known by another name?
10:43:28 <greenrd> mSquare f g x y = f x >> g y
10:44:15 <mahogny> doesn't seem *extremely* useful, and I haven't yet seen an equivalent
10:44:20 <greenrd> heh
10:44:28 <greenrd> yes, I know, it's trivial
10:45:30 <davidhouse> @pl mSquare f g x y = f x >> g y
10:45:31 <lambdabot> mSquare = flip . (((.) . (>>)) .)
10:45:50 <davidhouse> there you go. good ol' readable pointsfree again :)
10:46:45 <mahogny> davidhouse, I think you are wrong at exactly 4 places ;)
10:47:37 <davidhouse> heh
10:48:16 <Lor> Anything that uses >> is anomalous.
10:50:50 <mahogny> do exists for a reason
10:51:24 <davidhouse> nah, i like >>.
10:51:35 <davidhouse> only for one-lines or lambdas, that is
10:56:44 <araujo> Hello
10:58:04 <dcoutts> Lor, sometimes it's handy to use >>= since it can mean you can avoid naming intermediate values
10:58:11 <dcoutts> same reason people use (.)
10:59:03 <roconnor> dcoutts: People use (.)? ;-P
10:59:45 <mahogny> hm. I am yet to see a good use of (.). I have used it a few times but it's really not something I use daily
10:59:46 <dcoutts> roconnor, I'm glad you're not in the $ camp. :-)
11:00:10 <dcoutts> mahogny, try it, you might like it :-)
11:00:17 <dcoutts> I use it all the time
11:00:23 <Cale> I like (.) too
11:00:29 <mahogny> dcoutts, well, done a few times. but I haven't really gotten to abuse it yet
11:00:35 <dcoutts> and not just for "accademic" programs
11:00:37 <Cale> It makes code easier to edit, I find
11:00:57 <dcoutts> it doesn't need to be abused for obfsucation, it can make the code very readable
11:01:10 <mahogny> got an example?
11:01:12 <Cale> when you have a long composition using (.) and then apply it to a value with ($)
11:01:23 <mahogny> I prefer $ all the way
11:01:26 <Cale> rather than a chain of just ($)
11:01:42 <Cale> because then you can chop out a piece without having to change the ($)
11:01:48 <Cale> 's
11:01:59 <mahogny> hm. I don't think I follow
11:02:04 <mahogny> got something concrete?
11:02:21 <Cale> okay, let's say you have f $ g $ h $ x
11:02:25 <dcoutts> being able to eliminate explicit lambdas is nice
11:02:39 <dcoutts> higherOrderFunctionDeJour (not . p)
11:02:50 <Cale> oh, yeah, that's a good example :)
11:03:14 <davidhouse> using composition is also nice when you convert from a lambda to a closure
11:03:19 <mahogny> o_O
11:03:27 <Cale> let's say you have f $ g $ h $ x, and you want to start applying that composition across a whole list instead of just to x
11:03:41 <Cale> so you use map, right?
11:03:44 <mahogny> yeah
11:03:58 <Cale> you could write map (\x -> f $ g $ h $ x) xs
11:04:12 <mahogny> hm. ok. x is a function. I see
11:04:17 <Cale> but it's probably more natural to write map (f . g . h) xs
11:04:28 <Cale> x is a value
11:04:29 <mahogny> yes, that's one case I can agree with
11:04:36 <mahogny> ehr
11:04:49 <mahogny> hm. ok
11:05:04 <mahogny> right. it still holds
11:05:04 <Cale> and it's easier to change the code to map (f . g . h) xs if it's written as f . g . h $ xs already
11:05:19 <Cale> r
11:05:20 <Cale> er
11:05:28 <Cale> f . g . h $ x
11:05:32 <Cale> you get the picture :)
11:05:45 <mahogny> I might have gone with a [ | ] though
11:05:51 <Cale> it's also easier to chop out the middle of the composition
11:06:01 <Cale> yeah, but it might not be map :)
11:06:12 <Cale> but some other higher order function
11:06:19 <mahogny> right
11:07:17 <davidhouse> Cale, would you prefer f . g . h $ x or f . g $ h x?
11:07:24 <davidhouse> i'd say the latter for conciseness
11:07:30 <davidhouse> but i've seen both used.
11:07:34 <Cale> davidhouse: depends on how I'm thinking about it at the time
11:08:14 <Cale> I tend to use more (.)'s when I'm thinking about the functions more, and ($)'s when I'm thinking about values more.
11:10:06 <Cale> If h is really part of the function that I'm building, then I'll use the first form. If it's really something more specialised that I wouldn't see as part of the idea of the function being applied, the second form might happen
11:10:55 <Cale> > map head . group . sort $ zipWith (+) "Hello" "World"
11:10:56 <lambdabot>  add an instance declaration for (Num Char)
11:11:01 <Cale> > map head . group . sort $ zipWith (,) "Hello" "World"
11:11:04 <lambdabot> [('H','W'),('e','o'),('l','l'),('l','r'),('o','d')]
11:11:10 <Cale> well,
11:11:13 <Cale> > map head . group . sort $ zip "Hello" "World"
11:11:14 <lambdabot> [('H','W'),('e','o'),('l','l'),('l','r'),('o','d')]
11:11:27 <Cale> (just need an example list)
11:11:48 <Cale> the zip here would be awkward as part of the composition, and it's really more involved in building up the input
11:12:16 <Cale> (map head . group . sort) forms a single conceptual idea -- basically, sorting and uniquifying a list
11:13:43 <Cale> note that if I wrote it
11:14:18 <Cale> > map head $ group $ sort $ zip "ajar" "araj"
11:14:19 <lambdabot> [('a','a'),('j','r'),('r','j')]
11:14:48 <Cale> then wanted to use my uniq elsewhere, I'd end up doing a little extra typing
11:15:01 <Cale> uniq xs = map head $ group $ sort xs
11:15:03 <Cale> vs
11:15:09 <Cale> uniq = map head . group . sort
11:15:23 <Cale> where I can just cut the text out directly and I'm done
11:15:48 <Cale> but it's not entirely about editing efficiency -- it's really about how you think about things.
11:17:26 <isaacd> Cale: thanks for that discussion :)
11:23:22 <ihope_> > group "aaabbbdeef"
11:23:23 <lambdabot> ["aaa","bbb","d","ee","f"]
11:23:36 <ihope_> @hoogle IO (IO a)
11:23:37 <lambdabot> No matches, try a more general search
11:23:51 <Cale> isaacd: hehe
11:26:21 <isaacd> @hoogle join
11:26:21 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
11:26:22 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
11:26:22 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
11:29:57 <ihope_> Is there any function that returns an IO (IO a)?
11:30:12 <ndm> ihope_: return . return
11:30:28 <ihope_> That'd work...
11:30:34 <ndm> although there is never any reason to do so
11:30:55 <ihope_> To return an IO (IO a), or to use return . return?
11:31:03 <ndm> IO (IO a)
11:31:07 <sjanssen> @hoogle readTChan
11:31:08 <lambdabot> Control.Concurrent.STM.TChan.readTChan :: TChan a -> STM a
11:31:12 <ihope_> What if I want to do part of an IO action now, and the rest of it later?
11:32:21 <ndm> hmm, maybe
11:32:21 <sjanssen> say your TChan holds IO a, then to read an action and run it: join (atomic (readTChan myChan))
11:32:46 <ndm> yeah, that would be a use
11:39:02 <ihope_> block :: IO (IO ()) -- calling block stops other threads from taking control; calling its result ends this effect
11:39:13 <mathewm> @hoogle <?>
11:39:14 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<?>) :: GenParser tok st a -> String -> GenParser tok st a
11:39:31 <mathewm> The hoogle doc for <?> isn't very usefull
11:39:35 <ihope_> :-)
11:39:38 <mathewm> can anyone tell me what it does?
11:40:33 <ADEpt> allows to supply user-defined error message titles
11:40:51 <ihope_> Well, foo <?> bar will return a parser that acts like foo does, but upon failure, says it was expecting bar, I think.
11:40:52 <ADEpt> see Parsec papers
11:41:20 <ihope_> @type (Text.ParserCombinators.Parsec.<?>)
11:41:21 <lambdabot> forall a st tok.
11:41:22 <lambdabot>              Text.ParserCombinators.Parsec.Prim.GenParser tok st a
11:41:22 <lambdabot>              -> String
11:41:22 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
11:41:26 <ihope_> Erm.
11:41:34 <ihope_> @type Text.ParserCombinators.Parsec.parse
11:41:36 <lambdabot> forall a tok.
11:41:36 <lambdabot>              Text.ParserCombinators.Parsec.Prim.GenParser tok () a
11:41:36 <lambdabot>              -> Text.ParserCombinators.Parsec.Pos.SourceName
11:41:36 <lambdabot>              -> [tok]
11:41:36 <lambdabot>              -> Either Text.ParserCombinators.Parsec.Error.ParseError a
11:41:51 <isaacd> @hoogle block
11:41:52 <lambdabot> Control.Exception.block :: IO a -> IO a
11:41:52 <lambdabot> Text.Html.blockquote :: Html -> Html
11:41:52 <lambdabot> Text.Html.BlockTable :: module
11:42:14 <ihope_> @docs Control.Exception
11:42:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
11:42:29 <Brody> does the following make sense ?
11:42:31 <Brody> uniqueName program = program
11:42:31 <Brody> where
11:42:31 <Brody> (_, program) = uniqueNameAuxiliary 1 [] program
11:42:50 <Brody> i mean is it valid haskell code ?
11:43:13 <ihope_> Yeah, I think so.
11:43:20 <ihope_> Well...
11:43:29 <ihope_> I don't know.
11:43:32 <norpan> should be if you indent it correctly
11:43:46 <isaacd> It uses 'program' to mean more than one thing... if it works
11:44:03 <ihope_> More clear would be uniqueName program = newProgram where (_, newProgram) = uniqueNameAuxiliary 1 [] program
11:44:07 <Brody> because i cant understand what it does 
11:44:36 <ihope_> That can be further modified to uniqueName program = snd (uniqueNameAuxiliary 1 [] program)
11:44:37 <norpan> it calls uniqueNameAuxiliary and takes the second part of the result from it
11:45:17 <ihope_> And *that* can be changed into uniqueName = snd . uniqueNameAuxiliary 1 [] program
11:45:24 <ihope_> s/ program//
11:45:50 <Brody> ohh ic
11:47:48 <Brody> can it be that uniqueNameAuxiliary  is returning a tuple ?
11:47:58 <ihope_> Yep.
11:48:08 <Brody> ok
12:01:00 <Brody> Define a function uniqueNames, which given a program, returns the same
12:01:01 <Brody> program but with no variables sharing a common name. You may assume
12:01:01 <Brody> that the variable names fresh1, fresh2, etc are not used in the program.
12:14:24 <Cale> Brody: if you know about the state monad, it can be used to good effect there
12:14:38 <Cale> if not, you'll likely want a helper function
12:15:01 <Cale> with a parameter that holds a renaming dictionary
12:20:20 <Cale> Brody: do you have a more specific question though?
12:20:47 <Lemmih> dcoutts: Why is it a bug that Haskell's Int isn't necessarily a C int?
12:22:40 <ihope_> Lemmih: it isn't?
12:23:00 <Lor> Of course it isn't.
12:23:11 <ihope_> Why isn't it?
12:23:16 <Lor> There's no "the" C int anyway, as any compiler may choose its own.
12:24:08 <Lor> So, neither Haskell nor C specify Int's or int's precision precisely, and hence they might not coincide.
12:25:09 <mahogny> hm. anyone knows the status of Hawk as compared to Lava?
12:25:37 <Brody> brb
12:25:48 <Lor> Hm, ghc docs specify Int# to correspond to C's long.
12:27:46 <Brody> http://www.geocities.com/cnchybrid/hmm.txt   (i have a problem in understanding question 4 can anyone help me)
12:28:36 <morans> if I have a phantom type, is there a way at runtime I can get eg. the name of the phantom bit of the type?
12:28:51 <Brody> am notg sre what is really needed
12:28:59 <morans> what I'm doing is using phantom types to let me build type-safe DAGs
12:29:23 <Lemmih> morans: The name?
12:29:24 <morans> (where each vertex is a haskell function, and each arc is annotated with a type)
12:29:32 <Lor> morans, no, not with ordinary phantom types.
12:29:47 <morans> Lor: is there a way it can be done elsewise?
12:29:47 <morans> |data DAGComputation f = DC String
12:29:50 <morans> that's what I have
12:30:10 <morans> so a computation that looks like:
12:30:10 <morans> multiply :: (DAGComputation Int) -> (DAGComputation Int) -> IO (DAGComputation Int)
12:30:19 <Lor> You can include some kind of a type representation of f in the actual value.
12:30:28 <morans> (the result is in the IO monad because it ends up outputting stuff to go into a .dot file to be rendered)
12:30:41 <morans> but when I render the arcs, I'd like to be able to say "this arc carries an int"
12:31:49 <lispy> huh, does that function need to be in the IO monad or could you multiply it and then write the result independently of the multiply?
12:31:59 <lispy> (not saying you need to change your code, just a thought)
12:32:21 <Lemmih> morans: getPhantomName :: forall a. Typeable => DAGComputation a -> String; getPN _ = show (typeOf (undefined :: a)) ?
12:32:32 <morans> lispy: its in the IO monad because I've been thinking about doing other stuff and putting a putStr in there was real easy way to do it whilst i'm thinking about other stuff...
12:32:40 <morans> lispy: i'd like to get rid of it
12:33:32 <Brody> anyone understood the question ?
12:33:53 <ihope_> So what's this @ () and @ [()] stuff?
12:34:02 <Cale> Brody: I understand it
12:34:26 <Cale> Brody: it's a bit awkward to explain -- basically, you can write programs where you have different variables with the same name
12:34:40 <Cale> your program renames some of the variables so that there are no overlaps
12:35:32 <Cale> for example
12:35:53 <Brody> Declare hello;  hello := 5; Declare hello; hello := 7; Declare hello; hello := 9;
12:35:58 <Brody> lets say this is the program
12:36:03 <Cale> okay
12:36:04 <Cale> sure
12:36:32 <Cale> The second declaration ends up shadowing the original hello.
12:37:06 <Cale> so you want to rename it with a fresh variable name
12:37:25 <Cale> Declare hello;  hello := 5; Declare frash1; fresh1 := 7; ...
12:37:29 <Cale> fresh1*
12:37:30 <Brody> but even the 2nd assignment  should be renamed ?
12:37:32 <Cale> Declare hello;  hello := 5; Declare fresh1; fresh1 := 7; ...
12:37:44 <Cale> yes, because it referred to the new hello
12:38:00 <Cale> then you declare hello again
12:38:00 <Brody> ic
12:38:11 <Cale> but hello and fresh1 are taken
12:38:18 <Cale> so you end up calling it fresh2
12:38:30 <morans> k
12:38:32 <morans> oop
12:42:37 <mathewm> Is there an elegant way, in Parsec, to parser zero or one of a parser - like 'many' but no more than one?
12:42:46 <Cale> option
12:42:49 <Cale> I think it is
12:43:19 <Cale> @type Text.ParserCombinators.Parsec.Combinator.option
12:43:21 <lambdabot> forall a st tok.
12:43:21 <lambdabot>                  a
12:43:21 <lambdabot>                  -> Text.ParserCombinators.Parsec.Prim.GenParser tok
12:43:21 <lambdabot>                                  st
12:43:21 <lambdabot>                                  a
12:43:23 <lambdabot> [3 @more lines]
12:43:26 <Cale> ugh
12:43:43 <Cale> option :: a -> GenParser tok st a -> GenParser tok st a
12:43:43 <Cale> optional :: GenParser tok st a -> GenParser tok st ()
12:44:45 <ffranzosi> xerox: I'm finishing my project description, could I send an e-mail to you for a review?
12:44:48 <davidhouse> mathewm: how about parser >> many parser
12:45:00 <davidhouse> oh, sorry, zero or one
12:45:06 <davidhouse> i thought you said one or more
12:45:18 <xerox> ffranzosi: sure
12:51:32 <ihope_> @type foldr
12:51:33 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:51:54 <ffranzosi> xerox: ok, it was sent. It will probably arrive in a few seconds
12:52:39 <ihope_> @djinn List a -> List a -> List a
12:52:40 <lambdabot> f = void empty
12:52:50 <ihope_> Wuh oh.
12:53:06 <ihope_> @djinn Void
12:53:07 <lambdabot> f = void empty
12:53:46 <ihope_> Not good...
12:53:47 <Lor> How did you get djinn's current environment?
12:53:53 <ihope_> @djinn-env
12:53:53 <lambdabot> data () = ()
12:53:53 <lambdabot> data Either a b = Left a | Right b
12:53:53 <lambdabot> data Maybe a = Nothing | Just a
12:53:53 <lambdabot> data Bool = False | True
12:53:53 <lambdabot> data Void
12:53:55 <lambdabot> type Not x = x -> Void
12:53:57 <lambdabot> data List a
12:53:59 <lambdabot> data Cont r a = Cont ((a -> r) -> r)
12:54:01 <lambdabot> foldr :: (a -> b -> b) -> b -> List a -> b
12:54:03 <lambdabot> cons :: a -> List a -> List a
12:54:05 <lambdabot> empty :: List a
12:54:07 <lambdabot> id :: a -> a
12:54:12 <ihope_> @djinn-del foldr
12:54:15 <ihope_> @djinn-del cons
12:54:15 <mathewm> what's up with -fPIC support on Linux x86?
12:54:17 <ihope_> @djinn-del empty
12:54:21 <ihope_> @djinn-del List
12:57:36 <xerox> ffranzosi: I think it's okay, I'm not sure you had to leave the question in and answer explicitly, but it could work.
12:58:26 <ffranzosi> xerox: That's what 
12:58:42 <ffranzosi> xeros: That's what I thought also
12:59:02 <ffranzosi> xerox: That's what I thought also
12:59:18 <xerox> Up to you
12:59:43 <ffranzosi> xerox: Another doubt that I had was concerning the documents from the university I have to send to them
13:00:13 <xerox> Whatever official thing the university gives you I think it's okay
13:00:24 <ffranzosi> xerox: It's not well explained in the Terms of Agreement
13:00:40 <ffranzosi> xerox: 
13:01:03 <ihope_> So x ++ y = foldr (:) y x?
13:01:08 <ffranzosi> xerox: But, should it have some signature?
13:01:33 <Cale> ihope_: yep
13:01:33 <xerox> ffranzosi: not sure.
13:01:44 <Cale> ihope_: I really like that definition actually.
13:01:57 <xerox> ffranzosi: mine didn't, last year.
13:02:47 <ffranzosi> xerox: OK, I'll try it with some documents so...
13:03:02 <ihope_> @djinn List a -> List a -> List a
13:03:02 <lambdabot> f a b =
13:03:02 <lambdabot>   case a of
13:03:02 <lambdabot>   Empty -> b
13:03:18 <ihope_> In other words, f a b = b
13:03:29 <ffranzosi> xerox: Thanks for your patience 
13:07:35 <xerox> ffranzosi: no problem.
13:10:03 * morans 's head explodes from phantom types
13:10:13 <ffranzosi> xerox: Do you know to where should I send this "Foreign Certification form"? And where could I have one to fill in?
13:10:59 <xerox> Nope, I didn't go that far yet :-(
13:12:47 <lscd> Any tips for fixing syntactically incorrect code?  I'm reading http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell and the dynamic code appears to be syntactically correct - if i put it in its own file, it complains that it doesn't know about a bunch of types (which is correct, as it's an excerpt from a larger program) but says nothing about syntax errors.  However, I've also typed in the code separately, and I get the error S
13:12:48 <lscd> yntax error in expression (unexpected `=') on a line reading bestDisk 0 = DirPack 0 []  which comes after a line reading let precomp = map bestDisk [0..] (at a lower level of indentation)
13:14:13 <lispy> lscd: can you put the code on the web?  perhaps at lisppaste.org?
13:14:29 <lispy> lscd: i suspect we're running into the layout rule as it's known, but i'm not sure
13:15:42 <lscd> lispy: sure; i was suspecting it was a layout thing, but my code seems to be layed out in essentially the same way as the example; presumably, i've messed it up at one point though
13:16:09 <lscd> troubleshooting messed up layout in haskell, at least using ghc, seems surprisingly convoluted, heh
13:16:55 <lispy> yeah, the layout rule is probably the must frustrating problem you have have in haskell
13:17:21 <lispy> "Why, won't you compile!!!" <20 minutes later> "Oh, i have a missing space."
13:17:34 <Cale> hehe
13:17:46 <Cale> it's really important to have your editor configured correctly too
13:17:58 <lispy> oh yeah, don't use tabs
13:18:21 <lispy> otoh, you can forgo the layout rule by using explicit {} and ;
13:18:30 <lscd> http://pastebin.com/704095
13:18:38 <lscd> alright, i'll set my editor up to convert tabs to spaces
13:18:46 <lscd> i thought if i forced tabs to be 8 spaces it would be ok
13:18:48 <xerox> Good move.
13:18:54 <shapr> franka: yow!
13:18:58 <araujo> Hi!
13:19:18 <lscd> i should've years ago, since i use python, but it's never really bitten me, except with haskell
13:19:51 <lispy> lscd: hmm...looks like a potential layout issue on line 12
13:20:07 <lispy> i think the b needs to bein the same column as the p
13:20:11 <lscd> that's the line that was giving the error, yeah
13:20:42 <lscd> the b in bestDisk and the p in precomp ?
13:20:49 <lispy> yeah
13:20:57 <lscd> ah, ok, thanks
13:21:06 <lscd> i wouldn't have guessed that one
13:21:26 <lscd> <note to self: more indentation isn't sufficient, exact columns have to line up> :p
13:21:35 <lispy> i've heard it help to read the layout rule section of the haskell98 report
13:21:35 <Monks> hi, does anyone know why is hSelect (to poll multiple files) deprecated?
13:21:47 <lscd> yeah, very likely; there's a lot i need to read
13:22:04 <lscd> unfortunately, i can only read a few things at once, so there's a lot i still haven't read
13:22:22 <lispy> lscd: http://www.haskell.org/onlinereport/lexemes.html section 2.7
13:22:28 <lscd> thanks
13:22:48 <lispy> np
13:22:55 <lispy> it's a short read too, but hopefully will help
13:23:03 <lscd> In this chapter, we describe the low-level lexical structure of Haskell . Most of the details may be skipped in a first reading of the report. <-- i was foolish enough to believe that line the first time i glanced at it. :p
13:23:07 <lscd> yeah; i think so; thanks
13:24:04 <lispy> heh, yeah i've wanted to make a very naive haskell compiler as a learning exercise...a friend even gave me a hardcopy of the report...but i have yet to read more than a few key sections
13:24:18 <lispy> too many directions, too little time
13:24:23 <lscd> yeah; same problem
13:24:24 <Cale> lscd: I've never actually read that carefully, and I do alright :)
13:25:19 <lscd> hmm, ok; i just need to get the hang of all of this syntax (not to mention all the concepts, but that's easier when i can get the syntax right and play around)
13:25:20 <Cale> lscd: The basic rule to keep in mind while indenting is to line up the things which are on the same level, and indent things more deeply when they're structurally deeper.
13:25:21 <lispy> heh, coming from lisp i find it hard to read code where the lines start with a semicolon....i just want to ignore them as code...
13:25:50 <Cale> If you do that, you'll basically be fine
13:25:53 <lscd> Cale: yes; that's what i've been doing
13:26:01 <lscd> (and what i'm used to with python)
13:26:07 <lispy> Cale: multiline if statements in do blocks are the thing that really kills me with the layout rule
13:26:13 <lscd> it just seems like haskell and i have different ideas of 'what's on the same level' 
13:26:38 <lscd> at least, in a small minority of cases
13:26:49 <Cale> lispy: okay, well, an if-expression is only ever going to make up one "line" of your do-block
13:27:07 <Cale> the 'then' and 'else' are both part of the 'if' and they're on the same level
13:27:14 <Cale> so it's indented like
13:27:17 <Cale> do ...
13:27:23 <Cale>    if foo
13:27:30 <Cale>       then bar
13:27:36 <Cale>       else quux
13:27:42 <Cale>    ...
13:27:55 <lispy> yeah, but i want to put if foo then and put the condition on the next line and line up the else with the if
13:28:03 <psi> where does quux come from? :)
13:28:12 <Cale> lispy: don't do that :)
13:28:30 <lispy> Cale: but that's what natural after years of C-style syntax
13:28:38 <psi> the else can be one space after the if
13:29:05 <psi> after the i, I mean. iirc.
13:29:08 <lispy> if foo then bar
13:29:10 <lispy> else baz
13:29:12 <Cale> http://foldoc.org/?quux
13:29:18 <Brody> getVar :: Prg -> [String]
13:29:18 <Brody> getVar (Declare h :> t) = [h] ++ getVar t
13:29:18 <Brody> getVar (h :> t) = getVar t
13:29:18 <Brody> getVar h = [""]
13:29:32 <Brody> why is it returning "[\"result\",\"count\",\"]
13:29:37 <Cale> if you think about it, aligning the 'then' with the 'else' makes more sense anyway :)
13:29:45 <lscd> ah, ok, i think i see what the rule for indentation within a let is now; and it makes sense
13:29:59 <Brody> the \ is being disp[layed?
13:30:20 <Cale> Brody: the \'s just escape the " characters which are embedded in your string
13:30:40 <Cale> you're probably applying show to the result somewhere.
13:30:45 <Brody> but \ is part of the string ?
13:31:01 <Cale> no, \" means that the character " is part of the string
13:31:08 <Cale> (but it doesn't end the string there)
13:31:14 <Cale> > length "\""
13:31:15 <lambdabot> 1
13:31:16 <Brody> ok
13:31:25 <Cale> > head "\""
13:31:26 <lambdabot> '"'
13:31:43 <lispy> Cale: i disagree re: "if you think about it...", because when i think about it i get the form i mentioned :)
13:31:48 <Cale> heh
13:32:03 <davidhouse> argh! i'm getting a ghc error during linking. "expectJust upsweep_mod:old_linkable"
13:32:08 <Cale> Well, conceptually, the 'then' and 'else' belong to the 'if'
13:32:23 <Cale> the 'else' isn't something which can exist on its own
13:32:53 <Cale> also, the 'else' isn't part of the 'then'
13:32:59 <Cale> nor vice versa
13:33:29 <Cale> so it makes sense to put them on the same indentation level
13:34:03 <davidhouse> haskell-mode seems to want to indent the then/else the same amount as the if, which is annoying.
13:34:19 <Cale> davidhouse: yeah, haskell-mode has some annoyances
13:34:30 <Cale> I turn off the "smart" indenting when using it
13:34:40 <davidhouse> nah, i quite like thatg.
13:34:45 <davidhouse> *that
13:34:48 <lscd> hm, interesting to hear
13:34:52 <Cale> the simple-indent is better, I find
13:34:56 <lscd> <pays attention and listens for reasons to not switch to emacs>
13:35:07 <davidhouse> emacs is great!
13:35:10 <davidhouse> :)
13:35:14 <Pawer> emacs rules
13:35:19 <Pawer> up up!
13:35:26 <ihope_> I prefer vi to emacs because I don't know how to quit emacs.
13:35:29 <lscd> in theory, yes, but eh... all that chording. and if i use viper mode, why not just use vim?
13:35:34 <Pawer> apt-get install haskell-mode
13:35:43 <Pawer> XDD
13:35:46 <davidhouse> although i do find the vim commentary amusing. "emacs is a great operating system, but it lacks a good editor"
13:35:49 <xerox> ihope_: C-x C-c, also, run it and do C-h t, and you'll learn in very short time.
13:35:52 <lispy> eclipse fp! :)
13:35:58 <Cale> emacs is actually pretty nice, and I tend to use it when working on something large, but I find that vim is a lot more convenient for small things
13:36:02 <davidhouse> chording is far more elegant than vi's stuff.
13:36:11 <davidhouse> vim's modes put me off.
13:36:13 <Pawer> ohh flameee
13:36:19 <lscd> elegant? sure; conceptually, i agree entirely
13:36:22 <Pawer> throww!!!
13:36:34 <lscd> i just like having to type less
13:36:36 <lispy> i really thought my troll for eclipse would get more comments...
13:36:37 <Cale> I think they both have their place.
13:36:49 <lscd> lispy: i censored it out until you mentioned it a second time ;)
13:36:53 <Cale> You can get a lot of editing done in vim without leaving command mode.
13:36:55 <lscd> agreed; they do
13:37:15 <lispy> real men use sed/awk
13:37:19 <davidhouse> heh
13:37:23 <lscd> lispy: hey, even i use sed/awk
13:37:23 <lispy> editors are for weenies
13:37:23 <lscd> :D
13:37:35 <ihope_> copy con! copy con!
13:37:35 <lscd> [i've written whole (small) programs with cat before :/]
13:37:44 <Cale> you use sed and awk? I just use cat
13:37:47 <Cale> hehe
13:37:49 <lscd> hehe
13:38:04 <lscd> and if they start getting too messed up, i've actually fixed them with sed
13:38:04 <lispy> speaking of unix tools, i'm a huge fan of xargs
13:38:06 <ihope_> telnet brown.freenode.net
13:38:09 <ihope_> >:-)
13:38:11 <lscd> sure, xargs is good
13:38:11 <Pawer> freaks
13:38:21 <davidhouse> lispy: yes, but a proper haskell shell would be better.
13:38:23 <lispy> like, find ./ | grep *.hs | xargs grep "::"
13:38:24 <Pawer> geeks
13:38:25 <lscd> Pawer: yes. welcome to irc. enjoy your stay. ;)
13:38:26 <davidhouse> with lambda :)
13:38:26 <Pawer> geeks*
13:38:33 <xerox> export EDITOR="echo -ne"
13:38:38 <lscd> hah
13:38:51 <lispy> davidhouse: what about h4sh?
13:38:55 <davidhouse> and it could be called 'hash': the HAskell SHell :)
13:39:02 <davidhouse> lispy: oh?
13:39:05 <xerox> davidhouse: that's one SoC project!
13:39:09 <lispy> @where h4sh
13:39:10 <lscd> davidhouse: i -really- wish i knew enough to write that
13:39:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
13:39:12 <xerox> (And some people want to do it it seems.)
13:39:18 <psi> grep -r "::" *
13:39:19 <lscd> xerox: integrating it with yi, or standalone?
13:39:26 <xerox> lscd: stand-alone, I think.
13:39:30 <lscd> hm. cool. 
13:39:31 <davidhouse> trust dons to be one step ahead of me
13:39:33 <lispy> psi: yeah, but that would get all files
13:39:40 <lispy> psi: when if you only wanted some files
13:39:44 <xerox> Yep.  A functional bash replacement.
13:39:56 <psi> ah, true.
13:40:11 <davidhouse> all it needs now is to be lazy, and we're done.
13:40:19 <lscd> wow. i've got to start using that
13:40:26 <xerox> Implementing pipes as Arrows, maybe :-)
13:40:33 <lispy> davidhouse: unix pipes are lazy, that's part of what makes h4sh work
13:40:39 <xerox> !
13:40:54 <davidhouse> xerox, nice :)
13:41:10 <xerox> And then, lambdabot's plugins seaking off the shell.  Obviously.
13:41:25 <xerox> $ vixen my dear prompt... what's up?
13:41:51 * xerox stops dreaming of Lambdabot In The Shell
13:42:05 <lispy> hehe
13:42:08 <psi> hm, that'd be cool
13:42:19 <lispy> @vixen my dear prompt... what's up?
13:42:19 <lambdabot> i think you know the answer to that one, silly
13:42:24 <davidhouse> h4sh looks nice, but it still needs lambda.
13:42:25 * lispy blushes
13:42:25 <xerox> (it was a joke on Ghost In The Shell, the anime)
13:42:50 <psi> :)
13:42:59 <lispy> davidhouse: yeah, although you have some hof with h4sh as is
13:43:09 <davidhouse> or flip, perhaps. lambda would be nicer, though.
13:43:50 <xerox> davidhouse: it will certainly be there in the haskell shell
13:44:03 <lispy> but honestly, i think the shell is more about composing commands, 90% of the time and only once in a while about automation (ie, scripting, so why not use haskell scripting library?)
13:44:34 <xerox> If one would let ghci's let in the shell... it would certainly be fun.
13:44:58 <davidhouse> automation shouldn't be done in bashscript.
13:45:10 <davidhouse> for the sheer ugliness of the test construct.
13:45:14 <lispy> heh, yeah
13:45:26 <davidhouse> i'd stick with perl, probably.
13:45:31 <lispy> ewww
13:45:45 <lscd> lispy: between bash and perl, he's right
13:45:51 <shapr> There's also hsshellscript
13:46:12 <lispy> someone write a thingy to let you use clisp (a common lisp implementation) as a shell replacement....but they didn't extend teh language so it was a nightmare to do anything shell related
13:46:24 <lispy> shapr: yeah, i think that's what i was thinking of
13:46:36 <shapr> I've heard scsh is nifty, but haven't tried it.
13:46:43 <davidhouse> most automation is centred around regexes, so perl does quite well
13:47:00 <lispy> shapr: scsh?
13:47:06 <lispy> scheme shelL
13:47:08 <lispy> ?
13:47:09 <lscd> lispy: a scheme shell, i think
13:47:15 <dcoutts> mux, ping
13:47:25 <lscd> i think i installed it once, but i've never really played with it
13:47:41 <psi> scsh is not about interactive use, it it?
13:47:54 <psi> is it
13:47:57 <lispy> i find that bash meets my needs a shell quite well...so i rarely play with other shells
13:48:16 <shapr> I use zsh, because I had problems with bash.
13:48:31 <lispy> i think zsh is the default on mac osx
13:48:36 <shapr> But I'd much prefer something Haskelly that's like ghci + zsh.
13:48:37 <lispy> or is it tcsh
13:48:53 <psi> it's bash
13:48:58 <lscd> hm... if i'm browsing a module in ghci, and only want to see things which match a certain pattern, is there some kind of concise 'grep' style thing i can do, or do i need to write a lambda that takes browse's output as input and does matching, or.....?
13:49:05 <lscd> lispy: no, it's bash
13:49:06 <psi> tcsh was default a number of versions ago
13:49:25 <lscd> i use zsh on my machines, and both it and tcsh are installed on osx by default, but they're not the default shell
13:49:33 <shapr> akemp: yow!
13:49:51 <davidhouse> lscd, i don't think either are viable
13:50:02 <lscd> what, tcsh and zsh?
13:50:11 <davidhouse> lscd, i think the answer is "install hoogle" ;)
13:50:26 <lscd> ah, right
13:50:41 <lscd> damn. score one for ruby over haskell :D
13:50:59 <lscd> something.methods.grep(/whatever/) is damn convenient
13:51:04 <stepcut> I should write a wiki page on I learned about trying to add unix-like pipes to haskell
13:51:11 <lscd> stepcut: yes, please
13:51:11 <shapr> yup
13:51:24 <davidhouse> lscd, well, reflection is hard without object orientation
13:51:38 <lispy> also without run time typing :)
13:52:09 <lscd> sure; although i wasn't even asking for reflection, necessarily, though i'd love that
13:52:16 * shapr hacks on cabal
13:52:27 <xerox> !
13:52:36 <shapr> I don't think reflection has anything to do with OOP.
13:52:39 <stepcut> mixing unix processes and lazy evalution get's really tricky if you try to also care about the return code of the processes (which, in general, you do)
13:52:40 <davidhouse> lscd, what would you call something.methods if not reflection?
13:52:51 <lscd> that's reflection
13:52:56 <shapr> huh?
13:53:11 <lscd> but is :browse?
13:53:14 <Lor> Reflection doesn't have squat to do with OO.
13:53:29 <Lor> Though they are quite compatible with each other.
13:53:35 <lscd> Lor: isn't lisp quite reflective even without clos?
13:53:41 <davidhouse> :b is also a kind of module-level relfection. i suppose the hierarchial modules are something infringing on objects
13:53:42 <eivuokko> Anyone know how I could make cabal build cbits to a diffrent archive and install them with my haskell lib so that they get linked with each other when that package is used?
13:53:43 <davidhouse> Lor, how so?
13:53:55 <Lor> lscd, depends greatly on what you mean with "lisp"
13:54:05 <lscd> fair enough; common lisp?
13:54:19 <lscd> or anything that allows you to play directly on the parse trees, at run-time, i guess
13:55:05 <dcoutts> eivuokko, why do you want to do that? it's not ok just to put the cbits in the same archive as the haskell bits?
13:55:06 <lispy> it seems to me that reflection is a matter of having good run-time type information available, but i could be wrong
13:55:12 <shapr> akemp: Can I use your repo as the primary Cabal repo?
13:55:22 <eivuokko> dcoutts, I suspect I have ordering issue
13:55:41 <eivuokko> dcoutts, (on final linking of program that uses my package)
13:56:23 <dcoutts> eivuokko, ah right
13:57:13 <dcoutts> eivuokko, well I think the answer is no, cabal doesn't do that. It uses one archive per package. I guess you could put the cbits in another package on their own.
13:57:39 <davidhouse> i really quite like darcs.
13:58:15 <lispy> davidhouse: good
13:58:19 <lispy> i love the UI for darcs
13:58:25 <eivuokko> dcoutts, and that's impossible to do conviently for existing package where .cabal file is on toplevel.. :-S
13:58:28 <lispy> and the simplicity
13:58:38 <dcoutts> eivuokko, yep :-(
13:59:57 <eivuokko> dcoutts, Well, it's not really my package anyway.  It's Win32 package.  So, wth, I'll make Win32Ext-package instead or something ;)
14:00:20 <dcoutts> eivuokko, you mean the win32 package that coems with ghc?
14:00:40 <eivuokko> dcoutts, Win32, yes it comes with ghc.  (win32 is some older package, I think)
14:00:47 <dcoutts> ah ok
14:01:07 <dcoutts> the ghc ones tend to split the cbits into another archive, I've seen that.
14:01:38 <eivuokko> dcoutts, Yes.  And it's the only diffrence I can find on using cabal-thingy and fptools-hierarchy
14:02:02 <eivuokko> (I have logs for building ghc and libs, so I could check options)
14:02:10 <dcoutts> right, well if it's essential for packaging win32 for ghc then we should look into extending cabal
14:02:19 * dcoutts is a cabal patch gaurdian
14:02:39 <dcoutts> so feel free to whip up a patch and darcs send it in for review / comment
14:02:48 <eivuokko> dcoutts, You see.  I am extending Win32 so I could fix TimeLib for Windows...so now I need to fix Cabal maybe?
14:03:02 <eivuokko> Right.  I think I run out of time on this again.
14:04:11 <eivuokko> I don't mean to complain (or maybe I do), but making changes on anything haskell+Windows seems to grow into half-week hackfest. :)
14:04:20 <dcoutts> heh, yeah
14:04:28 <dcoutts> it gets less attention
14:04:45 <dcoutts> I have to fight with it sometimes when building installers for gtk2hs on win32
14:05:51 <ndm> i have been fighting to build hugs + windows libraries for 2 weeks now...
14:06:14 <eivuokko> Hmmm.
14:06:57 <eivuokko> Do you use fptools-framework for hugs/libraries, too?
14:07:07 <ndm> yep, same as GHC framework
14:07:13 <ndm> but with various tweaks for Hugs
14:07:23 <Brody> is there a built in function to check if an element is present in a list ?
14:07:27 <stepcut> dcoutts: after I get ghc work on the arm, that is the next thing I have to try to compile (gtk2hs on the arm)
14:07:36 <ndm> Brody: search for it
14:07:36 <dcoutts> stepcut, cool!
14:07:38 <davidhouse> Brody: elem
14:07:44 <ndm> @hoogle Eq a => a -> [a] -> Bool
14:07:44 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:07:44 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:07:48 <Brody> thanks david
14:07:51 <dcoutts> stepcut, gtk2hs on the 770 would be great!
14:07:53 <davidhouse> > 6 `elem` [4..10]
14:07:54 <lambdabot> True
14:07:57 <davidhouse> > 16 `elem` [4..10]
14:07:58 <lambdabot> False
14:08:05 <stepcut> dcoutts: btw, the last run of the testsuite had (I think) only 11 failures -- mostly due to floating point issues
14:08:22 <ndm> anyone have any Epigram experience - and i mean like in the region of 10 seconds or more
14:08:27 <dcoutts> stepcut, nice
14:08:29 <eivuokko> stepcut, Wow, nice work.
14:08:33 <stepcut> dcoutts: And I think I found a 1 bit fix for the floating stuff -- the arm FPA has a wacky byte-ordering for doubles
14:08:39 <ndm> i can't figure out how to do anything, how to hit the syntax and get stuff out of a shed
14:08:57 <dcoutts> stepcut, I'd love to get your arm work into gentoo.
14:09:11 <davidhouse> gah. i need something to read. or some project to hack on.
14:09:15 <dcoutts> stepcut, arm is one of the few arches we don't currently support for ghc on gentoo.
14:09:21 <ndm> davidhouse: hoogle :)
14:09:22 <stepcut> dcoutts: indeed -- I will let you know when I have a fully working unregisterised build
14:09:31 <davidhouse> ndm ;) what needs doing?
14:09:31 <dcoutts> davidhouse, there's always stuff to do with cabal. :-)
14:09:33 <stepcut> dcoutts: of course, the next step will be to registerise it :)
14:09:55 <dcoutts> stepcut, right. Though we've got several unregisterise arches in gentoo.
14:09:59 <ndm> davidhouse: lots, binary file format, class matching - although to be fair its probably too hard to get someone else to do
14:10:07 * davidhouse would continue with his personal project if it weren't for the weird linker error he was getting
14:10:17 <ndm> describing what needs doing is pretty much the same as doing it, unfortunately...
14:10:20 <davidhouse> dcoutts: any easy bugs?
14:10:21 <dcoutts> stepcut, we've been tring to get a registerised build on alpha working, but no joy yet.
14:10:24 <ndm> Yhc could need some love
14:10:27 <stepcut> dcoutts: how do you deal with ghc in gentoo anyway? Do you include a prebuilt bootstrapping ghc? or do you start it from the .hc files ?
14:10:38 <ndm> and thats a relatively simple project, with plenty of little bugs
14:10:52 <dcoutts> davidhouse, yes, there's whole list on the cabal bug trac
14:11:11 <dcoutts> stepcut, we include a binary, we've got ghc & ghc-bin ebuilds
14:11:19 <davidhouse> @where cabakl
14:11:20 <lambdabot> I know nothing about cabakl.
14:11:22 <dcoutts> davidhouse, I'll findyou the list...
14:11:22 <davidhouse> @where cabal
14:11:23 <lambdabot> http://www.haskell.org/cabal
14:12:43 <stepcut> dcoutts: cool. I think on freebsd when you install ghc 6.x (from source) it downloads a ghc 5.x binary tarball and uses that to build the one that gets installed
14:12:47 <davidhouse> dcoutts, woah, i think there's a small possibility that bugs #73 and #74 may be spam :)
14:13:00 <dcoutts> davidhouse, yeah, I just noticed that.
14:13:34 <dcoutts> stepcut, right, so we can let users either just use the ghc-bin ebuild as is, or they can use that to bootstrap the source version.
14:13:44 <davidhouse> dcoutts, and #72 as well, actually
14:14:09 <dcoutts> stepcut, so people who just want darcs say can avoid having to compile ghc from source.
14:14:48 <Pawer> why ghc
14:14:56 <Pawer> manages its packages
14:14:57 <Pawer> ?
14:15:27 <Pawer> its work of the linux distro ...
14:15:47 <stepcut> dcoutts: cool. I am not sure if the binaries I generate will work on gentoo -- but I am documenting the port process and works-arounds -- so it should be easily to replicate it for gentoo
14:16:00 <psi> ghc-bin, that's great
14:16:13 <psi> does gentoo have 6.4.2?
14:16:16 <dcoutts> stepcut, are there several arm ABIs?
14:16:18 <lscd> psi: yes
14:16:30 <dcoutts> psi, it's in testing, it's currently p.masked
14:16:34 <shapr> Pawer: Not everyone uses an OS with its own package system.
14:16:39 <psi> ok
14:16:51 <xerox> dcoutts: are you on #haskell-overflow?
14:17:17 <lscd> Pawer: it's insane to rely on the distribution; there are several major packaging systems, a bunch of minor ones, and then systems where there are no major packaging systems in wide use 
14:17:24 <dcoutts> xerox, I am now :-)
14:17:43 <stepcut> dcoutts: I do not know of any reason it wouldn't work -- but who knows ;)
14:18:16 <Pawer> ...
14:18:21 <dcoutts> stepcut, well we'd try it. It makes our live much easier to botostrap into the protage system if we start from someones binary.
14:18:26 <Pawer> ok
14:18:33 <Pawer> there is no reason
14:18:41 <Pawer> to do not do it
14:18:44 <lscd> Pawer: let's say you want to tell someone how to install a package: it's a lot easier to give one command than a decision tree based on system
14:19:01 <shapr> akemp: y0
14:19:25 <dcoutts> Pawer, having a decent cabal packaging system makes my life as a distro packager much easier
14:19:43 <dcoutts> it means I can write tools to generate ebuild automatically from .cabal packages
14:19:58 <dcoutts> and treat packages uniformly rather than needing different things for eahc package
14:20:07 <dcoutts> it's great for an OS distro system
14:20:26 <dcoutts> in gentoo we have a "haskell-cabal.eclass"
14:20:56 <dcoutts> then each ebuild for a cabal-based package jsut does "inherit haskell-cabal" and it means the ebuild can be very short
14:21:05 <dcoutts> so it makes packaging much easier.
14:21:12 <stepcut> dcoutts: indeed -- I plan to put tarball someplace when it works. Even if the whole port goes smoothly, it still takes *forever*. I am compiling under qemu-arm, and I think the time spent *just* compiling would be more than 12 hours :)
14:21:30 <lscd> good point, dcoutts - in general, Pawer, if things are already being packaged in a similar way, it's a lot easier to work with them (look at packages with auto* vs ones with hardcoded Makefiles, or worse, no build system)
14:21:47 <dcoutts> stepcut, yeah I bet compiling ghc under an emulator is slow. It's slow enough on my amd64! :-)
14:22:10 <mrchebas> good evening! do you have any clue on what Pacific Daylight Time 17:00 translates to, say, the Amsterdam time zone?
14:22:34 <norpan> mrchebas: 02:00
14:23:02 <mrchebas> norpan: 02:00 monday or tuesday? :)
14:23:11 <norpan> 02:00 the next day
14:23:17 <mrchebas> norpan: great, thanks
14:23:38 <Pawer> ok i got it
14:23:53 <Pawer> cabla written in haskell?
14:23:54 <Pawer> cabal
14:23:58 <lscd> Pawer: yes
14:24:05 <norpan> mrchebas: so two and a half hours left
14:24:07 <Pawer> i do not know why i ask
14:24:09 <Pawer> XDDD
14:25:45 <mrchebas> norpan: :O, you almost scared me. In fact I am aiming for May 8, PDT 17:00 so that would mean May 9 (the next day, right?)
14:25:58 <norpan> yes
14:26:15 <norpan> pacific is 9 hours after central europe
14:26:48 <lscd> i think you mean before?
14:26:51 <norpan> no
14:26:54 <norpan> after
14:27:28 <lscd> ah, by 'after' you mean it reaches the same time later, i guess?
14:27:29 <norpan> a certain time point comes 9 hours later in pacific time
14:27:33 * mrchebas sighs in relief
14:27:46 <lscd> sure, so i'd say that it's "before", as at any given time, the time there is earlier
14:27:56 <norpan> well
14:28:27 <norpan> it all depends on perspective
14:28:28 <lscd> probably best to just use earlier than / later then; less room for interpretation
14:28:30 <lscd> yeah
14:28:59 <norpan> pacific is gmt-7 and europe is gmt+2
14:29:06 <norpan> in summer
14:29:25 <lscd> well, central european summer time is
14:29:31 <norpan> yes
14:29:32 <lscd> (that's the timezone i'm in as well)
14:30:05 <norpan> britain is not europe, and portugal is, well, small
14:30:32 <norpan> and finland is, finnish
14:30:37 <lscd> russia is partly in europe
14:30:54 <norpan> they also have many time zones
14:30:59 <lscd> yes
14:31:17 <lscd> i'd never heard anyone speak of a 'european' timezone before, so it threw me a bit
14:31:29 <lscd> http://www.worldtimezone.com/time-europe24.htm
14:32:33 <norpan> well, that map says it all
14:32:52 <norpan> most of europe is blue
14:33:06 <lscd> well, of western and central europe
14:33:12 <norpan> and by europe i mean the european union :)
14:33:30 <dcoutts> sily UK being on a different timezone
14:33:31 <lscd> hey. you've suddenly kicked me out of europe ;)
14:33:39 <morans> dcoutts: someone's got a bill to change it
14:33:43 <dcoutts> really?
14:33:57 <morans> dcoutts: hold for ref
14:34:01 <norpan> it would be funny if greenwitch didn't use the gmt time zone
14:34:17 <morans> dcoutts: http://www.publications.parliament.uk/pa/ld200506/ldbills/048/2006048.htm
14:34:18 <norpan> greenwich
14:34:23 <morans> dcoutts: dunno its history
14:34:28 <morans> norpan: it doesn't for half of the year.
14:34:54 <norpan> daylight savings time is just a bother
14:34:56 <sethk> call it zulu.  everyone except the zulus does
14:34:59 <norpan> at least for us up north
14:35:00 <morans> heh
14:35:16 <morans> norpan: or far south.
14:35:17 <norpan> we get enough light during summer anyway
14:36:28 <Pawer> im in greenwich meridian
14:36:33 <Pawer> ^^
14:36:39 <shapr> I've never lived in a meridian.
14:36:40 * morans was there the other day
14:36:45 <morans> in greenwich, even
14:36:55 <bofh> norpan: yeah
14:36:59 * shapr saw a greenwitch once....
14:37:12 <bofh> and way too little during the winter, coincidentally
14:37:20 <tessier_> Whose website is http://lambda-the-ultimate.org ?
14:37:30 <psi> I like having sunlight 24/7. it's neat.
14:37:32 <Pawer> do you remember the internet time?
14:37:35 <Pawer> XDD
14:37:38 <shapr> tessier_: Ehud Lamm's website, and Anton von Straaten, and more.
14:37:43 <shapr> I love internet time.
14:37:51 <Pawer> you use it?
14:37:52 <psi> a bit difficult to sleep at times, however
14:38:00 <shapr> Yeah, I do use internet time.
14:38:08 <tessier_> shapr: Ah. Not any one particular persons? Lots of good stuff on there.
14:38:11 <shapr> But I don't care so much, I just want some sort of base 10 time.
14:38:13 <Pawer> with who?
14:38:18 <shapr> I use it for myself.
14:38:22 <Pawer> ?
14:38:24 <tessier_> I saw a link to it talking about LINKS on one of these functional programming channels I hang out on.
14:38:26 <Pawer> XD
14:38:33 <Pawer> it is more precise
14:38:45 <Pawer> no
14:38:55 <Pawer> it is less precise
14:39:01 <morans> maybe i'll head to edinburgh for summer
14:39:07 <morans> avoid the dark
14:39:12 <shapr> A 'beat' is about 1.36 seconds.
14:39:28 <Pawer> beat
14:39:34 <Pawer> like scene music
14:39:35 <Pawer> XD
14:39:43 <morans> that swatch thing?
14:39:46 <norpan> an internet beat is longer than that surely
14:39:48 <shapr> tessier_: LtU is way cool.
14:39:50 <tessier_> I am reading http://lambda-the-ultimate.org/node/1439 and there definitely seems to be an anti-UML sentiment. I am wondering why.
14:39:55 <Pawer> same name
14:39:55 <norpan> there were 1000 in one day
14:40:03 <tessier_> I haven't decided whether I like UML or not. I'd like to hear some arguments against it.
14:40:15 <Pawer> time is time
14:40:23 <shapr> tessier_: I'd guess it's because UML is one way to summarize code, but it's not a way to design code, in my experience...
14:40:23 <Pawer> i like a watch
14:40:32 <Pawer> with a progres bar for minutes
14:40:36 <lscd> tessier: it's poorly specified, there are an essentially infinite number of dialects, and in practice, it's often abused badly, to the pain of people forced to use it in such ways
14:40:45 <Pawer> http://en.wikipedia.org/wiki/Sabrina_Sabrok
14:41:00 <Pawer> XD
14:41:01 <lscd> it's a mediocre documentation tool, and a poor design one; yet it's often used for design
14:41:25 <bofh> UML = ?
14:41:28 <morans> Pawer: what has she got to do with internet time?
14:41:36 <tessier_> So what is the better way to design code? Backs of bar napkins?
14:41:46 <lscd> also, i don't think anyone can actually -read- it; some parts of some diagrams, yes, but every detail of an arbitrary uml diagram? no, due to all the dialects
14:42:04 <lscd> tessier: if we had a silver bullet for that, we'd be on a beach, not #haskell ;)
14:42:04 <shapr> tessier_: SpikeSolutions
14:42:11 <shapr> tessier_: And yes, the back of napkins
14:42:12 <tessier_> lscd: I see. ;)
14:42:14 <Brody> cale u there ?
14:42:17 <palomer> @. elite palomer
14:42:17 <Pawer> it is important
14:42:17 <lambdabot> T|-|EY're 7EL1iNg y0U |i3z!
14:42:19 <lscd> bofh: uniform modelling language
14:42:30 <tessier_> So you guys don't really do any design? You just start coding? 
14:42:36 <Pawer> i do
14:42:39 <Pawer> a
14:42:46 <Pawer> mm
14:42:58 <lscd> tessier: it depends on what i'm doing; if it's a 10 line shell script, quite possibly; otherwise, a certain amount of thought may go into it
14:43:00 <tessier_> Or perhaps you do design but not using any standardized method as you do not expect anyone else to ever have to understand the design other than by looking at the code?
14:43:03 <eivuokko> UML also often makes process of making software (when big "mass coder" houses are involved) a lot slower as it adds byrocracy.  Competent people don't usually like that.
14:43:11 <Pawer> i do requisites
14:43:17 <Pawer> in my head
14:43:19 <Pawer> XD
14:43:20 <mahogny> tessier, well. I usually reserve a week for designing before I start out seriously. for a normal quite big project at least
14:43:26 <Brody> anyone feeling like helping
14:43:34 <lscd> tessier: you're mixing up initial design work and design documentation; they're not the same - just as a novel isn't the same as all of the draftwork that goes into it
14:43:44 <norpan> haskell lends itself well to extreme programming
14:43:56 <mahogny> the one who invented extreme programming oughta die
14:43:56 <sethk> Brody, you have to ask a more specific question
14:43:57 <Pawer> norpan: and?
14:43:57 <lscd> tessier: ideally, any design documentation will be very cleaned up from inital design exploration and thought
14:44:03 <Brody> ok
14:44:12 <sethk> to say that UML is poor is not to say that design is bad
14:44:18 <tessier_> lscd: I see
14:44:22 <lscd> tessier: reverse engineering tools can also be helpful for understanding design
14:44:23 <Pawer> norpan: Think about new developers to come into a project
14:44:23 <sethk> it is merely to say that UML is a poor design tool, which in fact it is
14:44:35 <Pawer> norpan: they need a design
14:44:37 <tessier_> I think the holy grail we are all still looking for is the infamous "self documenting code"
14:44:48 <norpan> you design by unit tests
14:44:51 <lscd> Pawer: not necessarily - pair programming and picking up a clean system on the fly can go a long way
14:45:51 <norpan> also the type system makes refactoring very easy
14:46:12 <mahogny> refactoring sounds like a bad excuse to make bad designs
14:46:12 <lscd> norpan: hm.... what's the state of haskell refactoring these days? is it all done by hand, or are there tools for it?
14:46:15 <norpan> of course you can always write bad code
14:46:20 <mahogny> lscd, HaRe
14:46:30 <eivuokko> mahogny, do you use HaRe?
14:46:38 <mahogny> no way. I make good designs instead :P
14:46:39 <norpan> lscd: refactoring is necessary, you can never predict everything imho
14:46:42 <lscd> mahogny: no, it's not - it's a reflection of the fact that your design will -not- be ideal the first time, in the majority of cases
14:46:45 <lscd> norpan: agreed
14:46:53 <eivuokko> mahogny, my point being..does anyone use HaRe? :)
14:46:56 <sethk> lscd, refactoring is much easier in haskell than in most languages, I've never found that I needed a tool for refactoring
14:46:58 <lscd> i've contributed a minor amount of code to a refactoring tool; i'm a fan
14:46:58 <norpan> too much design is not good
14:47:05 <mahogny> eivuokko, I'm the wrong guy to ask
14:47:11 <lscd> norpan: sure, i agree; mahogny was the one that didn't
14:47:13 <norpan> of course you can't do without any design at all
14:47:18 <sethk> norpan, by definition, if it is too much it isn't good, but there isn't much information in that statement
14:47:23 <norpan> hehe
14:47:32 <norpan> it gets too much quickly
14:47:46 <norpan> esp when somebody else does it
14:48:13 <mahogny> otherwise I like the model of rapid prototyping
14:48:18 <norpan> but also haskell programmers tend to write better code, even when they write c++
14:48:19 <lscd> mahogny: on one extreme, you have waterfall; on another, xp - you can go too far either way
14:48:27 <mahogny> lscd, right
14:48:33 <lscd> norpan: sure, haskell programmers tend to know how to program; most c++ programmers don't
14:48:43 <norpan> it also depends on what your project is
14:48:52 <mahogny> lscd, have you looked into rapid prototyping? I think that is a good way
14:49:07 <Brody> http://www.geocities.com/cnchybrid/hmm.txt     << problem :(
14:49:08 <norpan> most of the projects i do (at work) involves experimenting with different design choices
14:49:14 <lscd> mahogny: mildly; toss in test-driven development and pair programming, and you have what i like to do
14:49:38 <lscd> [and what i basically never end up doing on my own stuff. oops... hehe]
14:49:39 <mahogny> lscd, formal verification is the way to go :)
14:49:48 <lscd> mahogny: no, it's complementary
14:50:02 <norpan> and it's always fun to impress and do a prototype in haskell in a day or so when a c++ programmer couldn't do it in less than a week
14:50:09 <lscd> formal verification can't catch everything
14:50:25 <mahogny> lscd, well, if one wants to do formal verification, then that has to be central. otherwise it's impossible. but you still need unit testing etc
14:50:52 <lscd> mahogny: no, it doesn't have to be central either; but yes, what i was trying to say is that things like unit testing and regression testing and so forth are still important
14:50:58 <sethk> lscd, that won't fly for very large projects.  you have to fit your methodology to the situation.  Format design where it isn't needed is a big waste of time, though.  Common sense is needed, not arbitrary rules
14:51:23 <mahogny> lscd, I have found formal verification to speed up things aggresively. you can prove that what you have works before you start coding it
14:51:26 <lscd> sethk: agreed; however, i've never worked on a very large project in any serious way
14:51:45 <lscd> mahogny: ah, formal verification of the specs? i've been looking at formal verification of code for the last while
14:51:47 <norpan> now my UTF8 module has many new functions
14:51:55 <sethk> lscd, I have.  I do not believe UML is a good tool for any project of any size
14:51:57 <mahogny> lscd, those need to go hand in hand
14:51:58 <lscd> sure, writing something ahead of time in, say, Z could be helpful
14:52:09 <lscd> sethk: i'd agree with you on UML
14:52:19 <norpan> i have found that haskell+quickcheck catches almost all bugs
14:52:22 <lscd> mahogny: no, although ideally they would for critical parts of a system
14:52:59 <norpan> of course i'm writing algorithmic code
14:53:04 <sethk> the worst thing you an do is allow a design to be driven by a poor tool.  That happens a lot in large projects.
14:53:05 <lscd> norpan: sure, but what happens when you have concurrency and state interacting (ie, with monads?) (genuine question; i don't know much about monads yet)
14:53:14 <norpan> i don't write that kind of code :)
14:53:20 <lscd> norpan: fair enough
14:53:49 <mahogny> lscd, the thing is, when you have a very formal specification, that is proven to work, it is usually extremely straight-forward how things should be coded, and you can tell from the specification exactly which properties need to be tested in unit testing for the entire thing to work. this works well for servers and data manglers though. less well for GUIs etc
14:53:53 <norpan> i use quickcheck to test c++ modules too :)
14:54:00 <sethk> lscd, a good tool in that situation would surely be very helpful.  The problem is, I've yet to see a worthwhile tool, and I've seen all the well known ones, and many not so well known ones.
14:54:15 <lscd> sethk: which situation, exactly?
14:54:30 <xerox> mauke: ping
14:54:36 <sethk> lscd, you were talking about concurrency
14:54:48 <lscd> sethk: ok, wasn't positive you meant that; and yes, agreed
14:54:53 <Brody> what does it mean when haskell does not give an error back and doesnt display anything ?
14:55:01 <mahogny> lscd, ultimately, I'd love to see a compiler based on bisimulation with a formal specification. then aspect oriented programming etc could just go die :)
14:55:05 <norpan> but it's nice to be able to use haskell in your work
14:55:09 <sethk> Brody, usually that you are in an endless loop
14:55:16 <norpan> although i write mostly c++ code right now
14:55:24 <lscd> you've basically found why i'm studying formal verification; i want to see what the state of it is atm, and if it's any good, try to implement some tools to do at least basic verification
14:55:25 <Brody> thanks sethk
14:55:38 <lscd> mahogny: hm, what's bisimulation?
14:55:52 <sethk> Brody, add some trace statements in strategic places, try to get an idea of what's going on
14:56:17 <norpan> re formal verification, i think programming by refinement is a good way to go
14:56:31 <mahogny> lscd, it's a theoretic tool. you have two systems and then you can show that they are equivalent by observing what they do over time. if one system is the specification, and the other is your implementation, you have a very powerful tool
14:56:38 <norpan> then you can use formal or quickcheck to check your refinements
14:56:42 <lscd> norpan: you mean starting from a rough sketch and refining your system into what you want?
14:57:06 <lscd> mahogny: hmm, cool; maybe i'm missing something, but why a compiler?
14:57:29 <norpan> lscd: starting from primitive and refine, yes
14:57:41 <norpan> then check each refinement step
14:57:45 <mahogny> lscd, the compiler in this case would take a loose implementation (consider it a stack of bricks) and then give you the most flexible program that gives a valid bisimulation
14:57:46 <norpan> like the z method
14:57:58 <lscd> norpan: sure, for a lot of apps, that's a sensible way of coding -- that said, a lot of apps written that way are annoyingly buggy and misdesigned
14:58:09 <mahogny> lscd, if you bisimulate several specifications at once, you have aspects in the compiler automatically
14:58:45 <lscd> mahogny: hm, it sounds cool, but i'm not managing to wrap my brain around it atm, sorry
15:00:01 <mahogny> lscd, it's actually done for very simple systems such as state machines already. you have a regexp that describes what your reality *can do*, and you have a regexp that says *what it needs to do*, and then it outputs a regexp with all valid events which a PLC can send to your equipment. deadlock analysis etc is all done by the compiler
15:01:13 <lscd> sure, that sounds like model checking, where you generate a list of bad states and then start checking your system states against them; i didn't realise that you'd do it in a compiler though
15:02:14 <mahogny> lscd, I think these extremely formal methods have been overlooked for too long. they can really cut both development time and costs if used properly
15:02:38 <mahogny> it's too much an academic vs industry thing right now
15:02:53 <lscd> mahogny: i hope so - i don't know enough to say yet
15:03:52 <lscd> eh, the researchers at my uni keep going on about how industry is starting to like their work
15:03:52 <mahogny> lscd, there's a freeware tool called Supremica developed at my university if you want to try it out
15:03:57 <lscd> sure, happily
15:04:27 <mahogny> however, just looking at state machines is too limited IMO. the concept is good, but we need better tools
15:04:46 <mahogny> so.. the one who writes a bisimulator compiler for haskell will be my God
15:04:49 <goron> The last time I heard bisimulation was when I was occupied with modal logic.
15:06:13 <Lor> Bisimulation seems to be pretty hip nowadays.
15:06:26 <lscd> mahogny: it's not that people just look at state machines; i mean, look at the stuff mcmiillan is publishing
15:06:37 <mahogny> Lor, you seen it used for other things?
15:06:56 <mahogny> lscd, hm. haven't heard about him
15:06:58 * mahogny googles
15:07:12 <lscd> hm, he did some cool stuff with craig interpolants
15:07:26 <norpan> hmmm, kzm is not here
15:08:21 <mahogny> lscd, ok. seems it will take a while to read up on him
15:08:44 <lscd> mahogny: i wish i could give you a brief summary, but i'm still a newbie at this as well
15:09:07 <mahogny> nah. I like reading papers. good training :)
15:09:12 <greenrd> lscd, what uni are you at?
15:09:24 <greenrd> I'm at ucd dublin and I'm researching formal methods
15:09:41 <greenrd> supposed to be formal methods for java but I'm actually researching formal methods for haskell-like languages as well
15:09:58 <lscd> oh, cool! i was trying to find if there was any research going on in that area
15:10:07 <greenrd> which, the former or the latter?
15:10:18 <lscd> the latter
15:10:21 <mahogny> greenrd, what method is usually used for proving properties in lambda calculus?
15:10:35 <greenrd> usually? I dunno, I'm only a first year
15:10:38 <mahogny> aha
15:11:42 <greenrd> I have just been doing some equational reasoning in Isabelle to prove some things in lambda calculus
15:11:42 <greenrd> Isabelle is a generic proof assistant
15:11:42 <mahogny> greenrd, manual proofs that is?
15:11:43 <greenrd> yes
15:11:48 <greenrd> well, semi-manual
15:11:56 <mahogny> yeah, I have used those tools
15:12:00 <mahogny> but for java
15:12:07 <greenrd> no proof assistant makes you work at the lowest level, that's why they're called "assistant"
15:13:06 <mahogny> if it's gonna be accepted in industry, we'll need better automatic tools. actually, I'd love to just have some fail-fast provers that only can do simple cases, as to avoid even the semi-manual proofs at times
15:13:27 <lscd> hm, have you seen lamport's tla+ and +cal?
15:14:01 <mahogny> no
15:14:04 <greenrd> mahogny, that's what I'm going to be working on for my phd
15:14:09 <mahogny> ah
15:14:32 <greenrd> mahogny, there is also a project called Jacks which can already do that for Java if I remember correctly, but it's not open source (yet)
15:14:43 <mahogny> I have used Keys
15:14:50 <mahogny> but it only does a subset of java
15:14:57 <Philippa_> mahogny: the stuff for Haskell's going to be a lot easier to do stuff with than for Java pretty much by default
15:14:59 <mahogny> java isn't a good language anyway
15:15:03 <greenrd> heh
15:15:07 <dcoutts> @seen SyntaxNinja
15:15:07 <lambdabot> I saw SyntaxNinja leaving #haskell 1 day, 21 hours, 24 minutes and 32 seconds ago, and .
15:15:08 <lscd> mahogny: it's a terrible language
15:15:10 <mahogny> Philippa_, yeah
15:15:14 <lscd> and i've got several hours of it to write for tomorrow :/
15:15:23 <mahogny> lscd, better than C++ at least :)
15:15:28 <mathewm> Java is a terrible language - but it has some nice tools available
15:15:29 <Philippa_> you're not going to get auto-derived proofs of interesting properties without you constructing the code in such a way as to strongly suggest how the proof'd go though
15:15:45 <lscd> mahogny: sure, and better than intercal... ;)
15:16:14 <greenrd> Philippa_, well, that's maybe underestimating the ability of those who code automated provers :)
15:16:16 <mahogny> Philippa_, yes. and I think you'd have to do the proofs on the highest level manually, that is, the specification
15:16:55 <lscd> mathewm: hm. like what?
15:16:56 <Philippa_> greenrd: prove termination on an arbitrary lambda term? :-)
15:17:19 <Philippa_> mahogny: it sort-of doesn't work like that. And insofar as it does, the spec'd have to be executable
15:17:21 <mahogny> bah. sounds like an SoC project!
15:17:37 <lscd> Philippa_: there are tools for executable specs though
15:17:47 <Philippa_> (everything is successive specifications, news at 11)
15:17:53 <greenrd> well no, but real programmers don't write "arbitrary" code, they usually use a narrow range of ideas. in fact this is encouraged in industry for readability.
15:17:54 <mahogny> Philippa_, well, the reason the proof is manual is because it's not in a language :)
15:18:07 <greenrd> Philippa_, right!
15:18:22 <mahogny> Philippa_, ok, true that everything is specs. but not all specs are code :)
15:18:47 <lscd> greenrd: sure, but ... find me the first odd perfect number
15:18:55 <Philippa_> lscd: no kidding, ghci springs to mind ;-)
15:19:02 <lscd> Philippa_: heh :)
15:19:37 <mathewm> Are there any Z ( Zed ) to Haskell refinement tools?
15:19:44 <Philippa_> ooh, good question
15:19:44 <mahogny> greenrd, right, if you can cover 99% of all cases appearing in industry automatically, you should be happy with that
15:19:57 <norpan> often people overestimate the value of proofs and underestimate the value of finding bugs
15:19:59 * Philippa_ suspects that's what HOFs are for :-)
15:20:01 <greenrd> yes, indeed, that would be quite an accomplishment
15:20:10 <greenrd> norpan, the two are not mutually exclusive
15:20:23 <lscd> norpan: so, what you want is an executable proof that you can formally verify and model check
15:20:34 <norpan> no what you want is a way to find bugs
15:20:37 <mahogny> norpan, sounds like you're proving the wrong thing :)
15:20:38 <Philippa_> norpan: often people make stupid statements in #haskell based on experience elsewhere
15:20:41 <norpan> a proof gives you nothing
15:20:42 <greenrd> by trying to prove something and failing, you might find a bug
15:20:45 <lscd> norpan: that -is- a way to find bugs
15:20:52 <greenrd> well, you do find a bug - either in your spec, your code or your proof
15:20:54 <norpan> no, a proof finds no bugs
15:20:57 <greenrd> heh
15:21:08 <Philippa_> a proof finds absense of bugs. Which is what I'm most interested in, dunno 'bout you
15:21:17 <Philippa_> "I found a bug but I've no idea how more there are - yay!"
15:21:19 <greenrd> true, but if there were no bugs to be found then you're writing Hello World
15:21:23 <norpan> i'm most interested in finding the bugs that i know are there
15:21:26 <lscd> Philippa_: well, of certain classes of bugs, with limitations
15:21:31 <greenrd> norpan, hahaha
15:21:38 <mahogny> and a good theorem prover can also give you a case when it fails. then you find the bug by tracing
15:21:39 <greenrd> norpan, that's a shortsighted way of looking at it
15:21:48 <norpan> no, it's a practical way
15:21:48 <mathewm> A proof proves the semantics of a design
15:21:57 <mathewm> bugs are mistakes in execution, IMO
15:21:58 <Philippa_> lscd: yeah, sooner or later you have to deal with the spec level that decides what properties you're proving too
15:22:13 <Philippa_> it's both
15:22:32 <Philippa_> proof by construction works great when you know how to do it. You get it right first time
15:22:37 <greenrd> mathewm, but you can prove that the code implements a spec, or not
15:22:38 <norpan> i will rather spend time finding bugs than proving parts of my design
15:22:52 <greenrd> norpan, but this is the point
15:22:53 <norpan> if that are the alternatives
15:22:54 <lscd> norpan: ideally, you don't have to spend much time doing proofs - that's what computers are for
15:23:12 <greenrd> norpan, use the proof tool to automatically find bugs!
15:23:18 <mahogny> norpan, as I said, the same program can find your bugs by giving you traces that invalidates a proof
15:23:20 <Philippa_> yeah, if you use the right tools to build the code in the first place you get a lot of properties for free
15:23:29 <mahogny> norpan, and if you have no bugs, you have a proof for free :)
15:23:44 <norpan> most of the time, when you have no bugs it still won't find a proof
15:23:51 <norpan> i know from experience
15:23:52 <lscd> you say what properties you want to hold, and then you set the tool loose
15:24:16 <greenrd> norpan, then maybe you weren't using the right tools/languages
15:24:16 <Philippa_> yes, but your experience isn't with anywhere near the best possible tools to've been starting with
15:24:21 <mahogny> norpan, that depends on the design. and if the industry starts using proofs more, there will be enough money in it that new tools will spring to existence
15:24:41 <Philippa_> (we know this because they don't exist yet, and because we have niftier stuff in R&D than we do commercially usable)
15:24:46 <mathewm> maybe it will take a killer-tool first...
15:24:51 <norpan> the goal in industry is not finding proofs, it's reducing bugs
15:24:57 <mathewm> Demand doesn't always lead supply...
15:25:10 <Pawer> octave rules
15:25:12 <lscd> mathewm: there's a -lot- of research going on in formal verification and methods and so forth
15:25:15 <mahogny> norpan, if we started suing the companies each time we find a bug, it would be a different story
15:25:17 <Pawer> haskell rules
15:25:27 <Philippa_> yes. What your rhetoric attempts to reject is that if you use proof by construction then you get 0 bugs - the best reduction possible
15:25:37 <Lor> ooodles of research
15:25:39 <mahogny> Pawer, octave, the matlab lookalike? it got a long way left
15:25:53 <Pawer> but is powerful
15:25:56 <lscd> norpan: likewise, the goal of industry isn't design, or using good tools, or providing good jobs -- but if something helps industry, the smarter parts of industry are willing to use it
15:26:04 <norpan> of course, if you can get a proof automatically that is good
15:26:10 <mathewm> A bug is a deviation from intended behavior.  Proofs can only prove intention if you can express intention on every level
15:26:11 <norpan> but it's not a goal in itself
15:26:12 <mahogny> Pawer, feel free to code us an alternative to gnuplot
15:26:23 <Philippa_> sure, nor's "finding bugs"
15:26:23 <Pawer> in octave?
15:26:25 <Philippa_> reducing bugs is
15:26:32 <mahogny> Pawer, no, for octave
15:26:36 <norpan> reducing bugs is a goal, and finding them is the first part of that goal
15:26:45 <Pawer> octave can plot
15:26:46 <Philippa_> the second clause there doesn't hold
15:26:50 <mahogny> Pawer, "plot" is the word
15:27:00 <norpan> you need to find a bug to fix it
15:27:02 <Philippa_> it's the first subgoal in your preferred strategy for reducing bugs, that's not the same thing
15:27:05 <Pawer> mahogny: octave can plot
15:27:19 <Philippa_> right, but you don't have to fix bugs to reduce bugs
15:27:24 <Philippa_> you can produce fewer bugs in the first place
15:27:25 <norpan> of course not
15:27:30 <mahogny> Pawer, the plotting sucks compared to matlab. everyone wants a better plotting system, but everyone are too lazy to make a new one, me included :(
15:27:32 <mathewm> or not create bugs to begin with...
15:27:43 <mathewm> Mathematica....
15:27:43 <Pawer> mahogny: jaja
15:27:44 <norpan> you don't create bugs
15:27:46 <Philippa_> that would be the preferred (and extreme) example, yeah
15:27:54 <norpan> bugs are omissions
15:27:56 <Pawer> mahogny: what is faster
15:28:02 <Philippa_> you create buggy code
15:28:03 <Pawer> mahogny: octave or matlab?
15:28:09 <mahogny> Pawer, matlab
15:28:10 <Philippa_> that's close enough to creating bugs as far as I'm concerned
15:28:15 <mathewm> if one can make a 'hole' then one creates bugs
15:28:22 <Pawer> mahogny: i know that octave has less functionality
15:28:22 <mathewm> even if by omission
15:28:27 <mahogny> Pawer, and I have had occasional crashes with linear least squares
15:28:32 <mahogny> Pawer, at times octave has more
15:29:01 <Pawer> time to time
15:29:23 <norpan> the reality is that you have code, you know it has bugs and you want to reduce them
15:29:27 <eivuokko> Anyone good with fptools?/ghc buildsystem?  How can I compile a library package (Win32) without compiling ghc - the Makefile is trying to use ghc-pkg-in-place?
15:29:37 <Philippa_> and that reality came about in part because you refused to look at avoiding bugs earlier
15:29:47 <Philippa_> you're attempting to prove our methods can't possibly work by assuming they don't
15:29:52 <norpan> even if you tried earlier you will have bugs
15:30:01 <Pawer> mahogny, fix it
15:30:12 <Pawer> mahogny, XD
15:30:19 <mahogny> norpan, it sounds to me you have been ruined by too much time in industry. see the light! :)
15:30:25 <Philippa_> nope. See "proof by construction" - you build the code and the proof at the same time, you don't *have* a system if it doesn't do the things it's supposed to
15:30:33 <norpan> i'm not attempting to prove anything, i'm trying to find bugs in your methods :)
15:30:35 <mahogny> Pawer, well, if I ever get hold of a student I could put at it, I will
15:30:36 <Pawer> haskell is slow
15:30:39 <mahogny> anyhow, bedtime. later
15:30:57 <norpan> mahogny: i work in industry and this is the problem i want to solve
15:31:03 <norpan> finding proofs is secondary
15:31:18 <mathewm> does anyone disagree with "bugs are divergences from intented behavior?"
15:31:30 <Pawer> me
15:31:31 <lscd> mathewm: yes
15:31:34 <Pawer> bugs are bugs
15:31:39 <Pawer> live in the severs
15:31:41 <norpan> bugs are small insects
15:31:47 <Pawer> year
15:31:49 <mathewm> care to give a non-recursive defn
15:31:50 <lscd> bugs aren't the same thing as insects, norpan 
15:31:50 <Pawer> yeah
15:31:52 <mathewm> ?
15:32:09 <Pawer> mathewm, thank you lambda friend
15:32:11 <lscd> mathewm: hm... the lack of an expected behavior could also be a bug, but i'm not sure you would call it a divergence
15:32:24 <norpan> lscd: i know, it's a subset of insects
15:32:35 <mathewm> lscd, I am not sure I buy that
15:32:41 <lscd> hm, ok; i always get mixed up as to which is a subset of which, norpan 
15:33:52 <monochrom> "I have been working in the industry" can also imply you have not thought outside the box.
15:34:17 * monochrom loves using one industry cliches against each other ;)
15:34:20 <norpan> i think outside the box all the time
15:34:22 <monochrom> s/one//
15:34:26 <norpan> too much for my own good
15:35:04 <mathewm> The "industry" is stagnant and redundant - we need a paradigm shift
15:35:17 <norpan> i work with creating software for formal verification of hardware
15:35:36 <Philippa_> norpan: you've stated that proofs tell you nothing. I strongly disagree with that. Really, if you want to have an actual discussion cut the hyperbole from your rhetoric
15:36:09 <norpan> Philippa_: i don't say proofs say nothing, in fact proofs say much, but what i'm interested in is not primarily finding proofs
15:36:10 <tessier_> Doesn't a proof...prove something?
15:36:25 <tessier_> Maybe it's the new math.
15:36:50 <norpan> proving something just means i have to look for bugs elsewhere
15:36:52 <Philippa_> OK. Please don't extrapolate that to what everyone else is interested in, or state that proofs can't aid in reducing bugs without a good argument (which you'd have difficulty with given the arguments that they in fact can)
15:37:01 * Philippa_ nods
15:37:02 <greenrd> norpan, one of my fellow phd students at ucd also worked on hardware verification before he came here to work on software verification
15:37:10 <Philippa_> but you have to debug your spec to be able to debug the app anyway
15:37:13 <tessier_> Having to look for bugs elsewhere is a very good thing.
15:37:23 <tessier_> If you can keep ruling things out you are getting closer to finding the problem.
15:37:27 <Philippa_> yeah, narrowing down where to look is good
15:37:41 <norpan> but my point is that it is substantially harder to find proofs than it is to find counterexamples
15:37:53 <Philippa_> that depends on the situation, and on the code
15:38:11 <greenrd> some things have no known proofs or counterexamples :)
15:38:38 <Korollary> initially, yes. As people fix bugs, it becomes incredibly hard to find new bugs, even though they are there.
15:39:04 <mathewm> Integer (a,b,c,n) => a^n + b^n = c^n  for n > 3 has no solution; find me a counter proof :)
15:39:10 <Philippa_> I think given a large existing toolkit with a good number of useful properties already proven, and a methodology that's largely about ensuring the proofs are easy (or to put it another way, that it's easy to tell you've done what you intend), that finding proofs can become significantly easier
15:39:33 <monochrom> I write correct programs.  It is easier to find proof for them than to find counterexamples. :)
15:40:10 <Philippa_> the classical example would be that if a core set of operations preserves a set of invariants and nothing else can frig with values of the appropriate type then all code using that type preserves those invariants. Prove once, use anywhere
15:40:44 <mathewm> I write lots of really bad code - most programmers do.  we need tools to help us out or replace us completely
15:40:47 <monochrom> I agree with Philippa_.  I will work towards that.
15:41:00 <Philippa_> proving that a function does what you intend's a lot easier if the primitives nail a lot of the trickier properties for you
15:41:17 <Brody> uniqueAuxiliary n vars ((Declare h) :> t)  
15:41:17 <Brody>           | (elem h vars)  = (uniqueAuxiliary (n+1) (vars ++ [h]) (renameDec n ((Declare h) :> t)))
15:41:17 <Brody>           | otherwise = (joinn (Declare  h)  (uniqueAuxiliary n vars  t))
15:41:25 <Philippa_> (oh look, map terminates if the parms do, ain't that cool?)
15:41:31 <monochrom> I will also work towards the latter of what mathewm says.  It has always been my dream. :)
15:41:36 <Brody> can anyone tell me why elem is is always returning false ?
15:41:51 <greenrd> Philippa_, that's a rather strict way of looking at things if I'm not mistaken isn't it?
15:42:19 <stepcut> Brody: the only logical reason is because the element is never in the list ?
15:42:36 <eivuokko> stepcut, Brody, or invalid Eq instance
15:42:36 <Brody> but how come
15:42:39 <norpan> Philippa_: as i said before, i imagine the most workable way is design by refinement
15:42:50 <xerox> monochrom: how far did the dream go for now?
15:42:52 <stepcut> eivuokko: ah! excellent thinking!
15:42:52 <Brody> (vars ++ [h]) in recursive
15:42:57 <sethk> Brody, as stepcut says, because that element is not in that list, so you have an error in the list construction (an error because, obviously, something should be in there)
15:42:59 <monochrom> I haven't started. :)
15:43:08 <xerox> Too bad (-:
15:43:12 <norpan> it's way past my bedtime
15:43:29 <Philippa_> greenrd: map may not terminate but take 4 $ map ... might still :-)
15:43:32 <Brody> but it is not givine an error
15:43:41 <Brody> its just not doing its job
15:43:51 <Philippa_> map itself's still trying to consume the whole list if you give it an infinite one (and the function parm might not terminate on all inputs)
15:44:07 <sethk> Brody, what isn't giving an error?
15:44:10 <Philippa_> norpan: I agree. I suspect it's the specs that need the most refinement
15:44:11 <norpan> good night everybody
15:44:16 <greenrd> Philippa_, ok but what about map (const [1..]) [1]
15:44:17 <Brody> the function
15:44:37 <sethk> Brody, I'm not following you.  you mean there is no compilation error?
15:44:37 <Brody> but i gave it a sample program and it is still not functioning
15:44:38 <greenrd> Philippa_, on one way of thinking about it, that only does one function application and creates a new list
15:44:48 <Brody> no errors 
15:44:49 <Philippa_> yeah. I wrote if, not iff :-)
15:44:54 <monochrom> Brody we need more details.  A short example to show the problem.
15:45:03 <Brody> ok i will upload some
15:45:08 <sethk> Brody, sorry, back up, I missed part of what you waid.  as monochrom says, paste something on the paste bot, then we'll all look at it.
15:45:15 <sethk> s/waid/said/
15:45:29 <mathewm> paste bot?
15:45:35 <greenrd> Philippa_, ah gotcha
15:45:47 <monochrom> Find the smallest example that exhibits your problem.  Smallest as in fewest number of tokens.
15:46:05 <monochrom> (This is undecidble :) )
15:46:49 <sethk> mathewm, web site where you paste stuff, then the web site shows the URL in the channel
15:47:05 <sethk> mathewm, or, if you use a different paste bot, you paste the URL into the channel, then everybody looks at what you pasted
15:48:29 <monochrom> Some bugs are due to not knowing the semantics of the language.  E.g., you think x++ means increase x and return new value, but the language manual says increase x and return old value.
15:48:59 <monochrom> I.e., your program would be correct if the computer did what you meant.
15:49:09 <mathewm> hence my defn of bug...
15:49:56 <monochrom> Thus it is all the more important to know the formal semantics of the language.  Actually several formal semantics of the same language, each at a different level of detail.  Most of the time you don't need every feature.
15:50:31 <Brody> http://www.geocities.com/cnchybrid/hmm.txt  << there is the problem uniqueauxiliary is giving the troublu es function elem is always returning false
15:51:14 <greenrd> monochrom, it is standard to formally specify using only referential transparent functions, since there is no runtime cost associated
15:51:46 <greenrd> monochrom, so fortunately that particular misunderstanding cannot occur in e.g. JML (Java Modelling Language), because you aren't allowed to use ++ in specs
15:51:53 <monochrom> Brody this is a huge example.  Can you boil it down to 20 tokesn or less?
15:51:56 <Philippa_> at least, it is when you don't care too much about runtime costs?
15:52:24 <Brody> dont read it all :) the problem part
15:52:27 <greenrd> well, there are proof-time costs associated :)
15:52:33 <Philippa_> show us the problem part then?
15:52:50 <Brody> < there is the problem uniqueauxiliary is giving the troublu es function elem is always returning false
15:52:59 <monochrom> Could you paste just the part one absolute needs to read and load to reproduce the problem?
15:53:11 <Brody> uniqueAuxiliary n vars ((Declare h) :> t)  
15:53:11 <Brody>           | (elem h vars)  = (uniqueAuxiliary (n+1) (vars ++ [h]) (renameDec n ((Declare h) :> t)))
15:53:11 <Brody>           | otherwise = (joinn (Declare  h)  (uniqueAuxiliary n vars  t))
15:53:30 <Brody> (elem h vars) < trouble
15:53:54 <monochrom> Well I hope someone has the time to go through it.
15:54:33 <Brody> well i hope 2  as i wish to sleep tonight at least one hour
15:56:35 <monochrom> I just want, to say, ...
15:57:06 <monochrom> > (elem 'c' ['a','c','e'], elem 'c' ['a','i','d'], elem 'c' [])
15:57:07 <lambdabot> (True,False,False)
15:57:13 <monochrom> So elem works.
15:57:23 <Brody> i know it works
15:57:29 <Brody> elem works
15:57:36 <Brody> but in that context its not
15:57:44 <Brody> and i cant find out why
15:57:55 <monochrom> My advice is to double-check h and vars.
15:58:05 <Brody> i dont have a lot of exp on haskell
15:58:15 <monochrom> Neither do I.
15:59:00 <monochrom> My only advantage is I have a lot of exp on proving programs correct (not language specific), so I tend to debug my programs from that point of view and it works for me.
15:59:24 <sethk> Brody, this is very complicated.  I would insert print statements in various places to show the list, and find out where it diverges from what I expect to see
15:59:43 <greenrd> don't write such long functions
15:59:47 <monochrom> Actually I construct programs from that point of view too.  (I probably won't actually prove, but I write in such a way to simplify the proof.)
15:59:58 <greenrd> only write long functions if you are prepared to debug them by yourself
16:00:03 <sethk> Brody, break it into manageable pieces
16:00:09 <mathewm> could you not walk through a program like this interactively in ghci or some debugger?
16:00:17 <monochrom> If you run out of ideas, Debug.trace.  Print out h and vars.
16:00:28 <sethk> Brody, then verify that each piece works.  ultimately you'll find the piece that does not.
16:01:25 <mathewm> @docs :>
16:01:26 <lambdabot> :> not available
16:01:29 <monochrom> Did I mention the other day that I do use all sorts of debuggers and tracers when I'm debugging someone else's program? :)
16:01:43 <eivuokko> Man that paste is hard to follow without running it.
16:01:50 <monochrom> :> is a constructor of Brody's data type.
16:01:55 <sethk> found my problem, anyway.  :)
16:02:21 <mathewm> is the ':' magic?
16:02:34 <monochrom> Problem isolation is an important debugging skill.  That is why I urge "reproduce the problem in 20 tokens or less".
16:02:47 <stepcut> I had to solve this problem the other day in some real-life code :)
16:03:25 <monochrom> mathewm: user-defined constructors, if you want to use symbols and infix notation, are required to start with :
16:03:25 <Brody> u mean the elem stepcut ?
16:03:41 <mathewm> monocrom, thanks
16:04:23 <monochrom> Example: data MyTree = Leaf | Branch :+ Branch
16:04:33 <stepcut> Brody: writing an algorithm that gives each variable a uniq name
16:04:52 <monochrom> Then you can write "(Leaf :+ Leaf) :+ Leaf" ain't it cool? :)
16:04:59 <mathewm> infix constructors seem confusing - are they commonplace?
16:05:11 <eivuokko> mathewm, Not really.
16:05:12 <monochrom> No, don't worry.
16:05:21 <Brody> IVE Fixed it :p
16:05:49 <monochrom> All infix constructors I've seen were designed judiciously.  No one has abused them yet.
16:06:46 <Brody> Guys you r great tutors :)
16:07:00 <mathewm> what was the problem/fix?
16:07:17 <Brody> i switched where i shuld have inserted
16:07:37 <monochrom> So, you may retort, "if I could reproduce my problem with 20 tokens or less, I would have already found the cause and fixed it!"  Yes, that's the idea, self-serve debugging.
16:07:55 <Brody> well ive been doing this from 11am and now is 1:07am
16:08:03 <monochrom> God debugs those who debug themselves!
16:08:11 <mathewm> :)
16:08:21 <Brody> good one mono
16:08:44 * Brody Stereochrom
16:08:46 <Brody> :P
16:14:31 <mathewm> /msg nickserv register snorkle
16:14:54 <mathewm> /msg nickserv set hide email on
16:14:59 <greenrd> uhh
16:15:05 <greenrd> mathewm, I can see that
16:15:06 <monochrom> Should I pretend I have never seen that? :)
16:15:17 <mathewm> yup ;)
16:15:42 <xerox> Something like a ^B is getting there before your messages.  They look bold.
16:17:35 <mathewm> maybe I just like yelling ...
16:17:45 <morans> all blue here!
16:18:39 <mathewm> this group could use some color
16:20:20 <mathewm> who said it isn't easy being green
16:23:50 <sethk> mathewm, kermit the frog
16:32:15 * mathewm is a IRC clueless newbie
16:33:04 <xerox> Good night.
16:33:12 <palomer> proofs are not programs, damnit!
16:33:29 <mathewm> are programs proofs?
16:33:36 <palomer> no!
16:34:00 <mathewm> prove it
16:35:07 <xerox> mathewm: http://lambda-the-ultimate.org/node/1447
16:35:19 <xerox> Good night for real.
16:59:42 <cmarcelo> anyone has an example of using DiffArrays?
17:04:10 <Lemmih> It's just like using any other array.
17:07:29 <audreyt> cmarcelo: it's just a functional array interface with unsafePeformIO underneath
17:07:53 <audreyt> cmarcelo: see the "Frozen" interface in BitSet
17:10:02 <cmarcelo> hmm. i'm kind of confused because newArrayDiff returns something inside IO ( )..
17:11:42 <audreyt> they are internal, you shouldn't use it :)
17:12:20 <audreyt> oh wait, the "new" one is indispensible
17:12:30 <audreyt> yes. the locking takes IO, but further uses doesn't, I think
17:15:18 <Igloo> Are you sure? I thought the standard Array functions work, you just need to change the type
17:19:08 <audreyt> but how do you change the type?
17:19:33 <Igloo> With a type signature
17:20:08 <audreyt> heh, right. mea culpa.
17:20:45 <audreyt> cmarcelo: IOArray and IOUArray needs no explicit locking
17:21:09 <audreyt> it still happens at IO, but the user is shielded from it
17:21:34 <audreyt> (freezing other MArrays do require hand-written instances, however.)
17:22:27 <cmarcelo> i'm testing changing just the type signature now. thanks. =)
17:25:14 <dons> dcoutts: so it comes down to the Int/CInt errors in the ffi decls?
17:25:23 <dons> Igloo: ^^ was that your impression of dcoutts bug?
17:25:44 <dons> I should clean those up
17:26:16 <Igloo> Yes
17:26:33 <cmarcelo> audreyt: i dont get what you mean by freezing.. it's like the DiffArray does all the IO/mutable thing in "background" and but always return a pure functional object for the user?
17:26:50 <dons> ah, I see a couple of Ints that should be CSizes
17:27:30 <dons> morning audreyt, how's code?
17:29:48 <audreyt> cmarcelo: yes
17:30:12 <audreyt> dons: code's fine, finally started cabalizing various parts of Pugs
17:30:18 <audreyt> into separate distros
17:30:32 <audreyt> e.g. http://svn.openfoundry.org/pugs/third-party/HsSyck/
17:30:39 <audreyt> and cabalizing $job code as well
17:30:48 <audreyt> http://svn.openfoundry.org/openafp/
17:30:58 <dons> excellent!
17:31:28 <dons> audreyt: you don't happen to have a .prof of pugs lying around somewhere?
17:31:40 <dons> that would show which ByteString functions are getting hammered the most?
17:32:46 <audreyt> unpackWith                     Data.ByteString        0.0    4.5
17:32:46 <audreyt> concat                         Data.ByteString        0.0    1.3
17:32:46 <audreyt> w2c                            Data.ByteString.Char8   0.0    1.8
17:33:33 <audreyt> but it's all at the 0.0 level
17:33:38 <dons> I improved concat over the weekend. unpackWith .hmm. you should be avoiding unpackWith :)
17:33:41 <dons> but looks good.
17:33:46 <audreyt> so no matter how fast you make it, it's not going to help me :)
17:33:51 <dons> yep
17:34:14 <dons> avoiding unpack is a good idea if possible.
18:24:54 <dons> dcoutts, around?
18:36:55 <dancor> error handling.  can i get away with something like (for Parsec): parsedOrDie (Left err) = error (err)  \  parsedOrDie (Right v) = v
18:37:43 <dancor> basically i don't want errors to be caught; i want them to cause the program to end.  and i don't want to have to worry about them beyond that.
18:38:54 <Lemmih> Yeah.
18:39:11 <sjanssen> @hoogle Either a b -> b
18:39:12 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
18:39:30 <sjanssen> there isn't a fromRight?
18:44:11 <goltrpoat> anyone play with System.Win32 much?  i have a WM_PAINT handler that, at some point, goes buf <- backBuffer hdc, followed by Graphics.Win32.selectBitmap hdc buf.  the latter throws an exception:  user error (SelectBitmap: The operation completed successfully. (error code: 0)), which seems awful silly
18:44:21 <goltrpoat> i can of course do try $ Graphics.Win32.selectBitmap hdc buf .. which works
18:45:06 <goltrpoat> but it seems weird that whoever wrote the binding is just passing the hresult as an exception
18:47:27 <araujo> Hello!
18:47:36 <metaperl> araujo: ahoy!
18:47:51 <araujo> hi metaperl :-)
18:48:47 <dancor> sjanssen: there is.  it would be cool to print the parse error though.. hmm
18:48:59 <dons> morning sjanssen. 
18:49:08 <sjanssen> dons: good morning
18:49:22 <dons> did you get your soc application in yet?
18:49:44 <sjanssen> working on it right now
18:49:48 <dons> great.
18:50:00 <araujo> hello dons 
18:50:08 <dons> mail me a copy if you want a bit of feedback.
18:50:11 <dons> morning araujo 
18:50:15 <araujo> :-)
18:50:22 <dons> ?localtime araujo 
18:50:23 <lambdabot> Local time for araujo is Sun May  7 21:51:41
18:50:38 <dons> oh. so still around hmm , 17 hours till the SoC deadline?
18:50:40 <ruffneck> mmkay
18:51:19 <araujo> dons, yeah
18:51:20 <ruffneck> there is 13hours to tax report deadline :P
18:52:12 <dons> ruffneck: learning haskell?
18:52:27 <ruffneck> not much yet, only basics what I could understand
18:59:28 * dons grumbles at the darcs-all script in ghc having bash-isms
19:00:31 <stepcut> :p
19:01:52 <stepcut> after the testsuite runs, how do I get a list of which tests failed ?
19:02:01 <stepcut> (the ghc compiler testsuite)
19:02:55 <dons> well, it dumps them to stdout
19:03:02 <dons> unless you use a magic flag, now let me see...
19:03:29 <dons> --output-summary=/tmp/tests.log
19:03:32 <dons> I think
19:03:55 <dons> stepcut: you working on the arm port? (is that right?)
19:05:19 <stepcut> yep
19:05:29 <dons> great stuff
19:05:55 <stepcut> the unregisterised build is getting close I think
19:06:04 <dons> excellent!
19:06:07 <dons> ?karma+ stepcut
19:06:08 <lambdabot> stepcut's karma raised to 1.
19:06:12 <stepcut> :p
19:08:08 <dancor> is missingh cool?  i was just looking for a csv parser but i have a penchant for overkill
19:08:56 <dons> its got lots of nice stuff in it, yeah.
19:09:04 <stepcut> dancor: yeah, its got a lot of good stuff 
19:09:29 <dancor> haskell does seem to be missing a lot of things.  how is harp for a haskell de facto regex standard?
19:09:49 <dons> hmm?
19:10:00 <dons> Text.Regex is the de factor standard...
19:10:04 <dons> since its in the base libs
19:10:14 <dons> and JRegex is the second place getter
19:10:22 <dancor> heh.  ok
19:10:32 <dons> check the libraries_and_tools page on haskell.org for about 5 regex libs.
19:11:02 <dons> including, hmm, 3 native haskell ones, bindings to the C, perl and tcl regex libs.
19:11:08 <stepcut> :P
19:11:35 <dancor> dons, which have you found most useful if any
19:11:53 <dons> I've found Text.Regex.Lazy very useful. We wrote the shootout benchmark for regexes in it.
19:12:06 <dons> Text.Regex, from base, is also good for regex-jobs that aren't too heavy
19:15:46 <dons> JRegex will be in the base libs soon though. so that's another option
19:17:26 <dancor> hey hs-plugins is in gentoo portage.  heh.
19:17:40 <dancor> you're famous!  :)
19:23:12 <newsham> > map (`mod` 121) $ takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:23:13 <lambdabot> [103,111,111,100,32,109,111,114,110,105,110,103]
19:23:20 <Lemmih> harp does regexes on Haskell itself.
19:23:33 <newsham> > map (toEnum . (`mod` 121)) $ takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:23:34 <lambdabot> Add a type signature
19:23:47 <Cale> > map (chr . (`mod` 121)) $ takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:23:48 <lambdabot> "\ETXZOgqxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:23:48 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:23:48 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:23:48 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:23:50 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:23:53 <lambdabot> [6 @more lines]
19:23:57 <newsham> why does it break when I use chr?
19:24:01 <newsham> or toEnum?
19:24:23 <newsham> > map chr [103,111,111,100,32,109,111,114,110,105,110,103]
19:24:24 <lambdabot> "good morning"
19:24:49 <newsham> Prelude> map (toEnum . (`mod` 121)) $ takeWhile (/= 0) $ iterate (`div` 121) 845
19:24:49 <newsham> 9074575717959468793379
19:24:50 <newsham> [3,90,79,103,113,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,120
19:24:54 <newsham> WTF?
19:26:17 <Cale> > take 20 $ iterate (`div` 121) 845
19:26:18 <lambdabot> [845,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
19:26:51 <Cale> > takeWhile (/= 0) $ iterate (`div` 121) 845
19:26:52 <lambdabot> [845,6]
19:27:00 <newsham> takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:27:05 <newsham> > takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:27:06 <lambdabot> [8459074575717959468793379,69909707237338508006556,577766175515194281045,4774927070373506454,39462207193169474,326133943745202,2695321849133,22275387182,184094108,1521438,12573,103]
19:27:25 <Cale> > map (`mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:27:26 <lambdabot> [103,111,111,100,32,109,111,114,110,105,110,103]
19:27:31 <Cale> > map (chr . `mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:27:32 <lambdabot>  parse error on input ``'
19:27:38 <Cale> > map (chr . (`mod` 121)) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:27:39 <lambdabot> "\ETXZOgqxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:27:39 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:27:39 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:27:39 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:27:41 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:27:42 <Cale> hmm
19:27:44 <lambdabot> [6 @more lines]
19:27:46 <newsham> see!  
19:27:49 <newsham> same weirdness in ghci
19:28:14 <Cale> > chr 103
19:28:15 <lambdabot> 'g'
19:28:30 <Cale> > map (`mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:28:31 <lambdabot> [103,111,111,100,32,109,111,114,110,105,110,103]
19:28:35 <Cale> > map chr . map (`mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:28:36 <lambdabot> "\ETXZOgqxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:28:37 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:28:37 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:28:37 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:28:39 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
19:28:42 <lambdabot> [6 @more lines]
19:28:49 <Cale> okay, that's strange
19:28:55 <newsham> bug?
19:29:13 <palomer> <:o
19:29:22 <newsham> its like its pushing the mod past the takewhile or something
19:29:52 <Cale> oh, hmm
19:29:53 <Cale> I see
19:29:59 <Cale> neat :)
19:30:12 <Cale> map (chr . fromIntegral) . map (`mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:30:15 <Cale> > map (chr . fromIntegral) . map (`mod` 121) . takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:30:16 <lambdabot> "good morning"
19:30:21 <Cale> hehe
19:30:39 <Cale> you were doing Int operations, because chr evilly works only on Int
19:30:58 <Cale> and of course, that number is too large to represent as an Int
19:31:06 <dons> that's it.
19:31:23 <newsham> ok.
19:31:27 <newsham> makes sense
19:32:14 <Cale> we should really have generic versions of those be the defaults.
19:32:24 <dons> of chr?
19:32:37 <Cale> yeah, all the library functions
19:32:59 <newsham> > map (chr . fromIntegral . (`mod` 121) $ takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:33:00 <lambdabot>  parse error on input `}'
19:33:14 * dons wonders what chr does for > 2^32-1..
19:33:16 <newsham> > map (chr . fromIntegral . (`mod` 121)) $ takeWhile (/= 0) $ iterate (`div` 121) 8459074575717959468793379
19:33:17 <lambdabot> "good morning"
19:33:49 <Cale> people who are really concerned with performance and want to go to the extra trouble of doing bounds-checking can specify Int explicitly.
19:34:01 <dons> hmm.
19:34:01 <dons> > chr (2^20)
19:34:02 <lambdabot> '\1048576'
19:34:14 <dons> > chr (2^21)
19:34:15 <lambdabot> Exception: Prelude.chr: bad argument
19:34:23 <dons> oh nice.
19:35:50 <sjanssen> > maxBound :: Char
19:35:51 <lambdabot> '\1114111'
19:36:35 <dons> yep
19:36:40 <Lemmih> > '\1114112'
19:36:40 <lambdabot>  lexical error in string/character literal
19:36:43 <dons> > chr (2^20 + 2^16 - 1)
19:36:44 <lambdabot> '\1114111'
19:36:56 <newsham> > map (chr . fromIntegral . (`mod` 131)) $ takeWhile (/= 0) $ iterate (`div` 131) 10221535546699306965
19:36:57 <lambdabot> "thank you"
19:38:30 <dancor> what is this goedel encoding
19:39:25 <Cale> It's not Gdel encoding, it's just encoding in base 131.
19:39:55 <newsham> > foldr (\a b -> b * 131 + a) 0 ((map (fromIntegral . fromEnum) "msg here") :: [Inteer])
19:39:56 <lambdabot>  Not in scope: type constructor or class `Inteer'
19:40:00 <newsham> > foldr (\a b -> b * 131 + a) 0 ((map (fromIntegral . fromEnum) "msg here") :: [Integer])
19:40:01 <lambdabot> 67448398140598149
19:40:57 <Cale> > let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in zipWith (^) primes (map ord "Hello")
19:40:58 <lambdabot> [4722366482869645213696,1546132562196033993109383389296863818106322566003,3081487911019577364889564708135883709660962637144621112383902072906494140625,1864611341716131449326161680395669897144641585824
19:40:58 <lambdabot> 8583415929120740302154318206422517221824801,39317695287172535490534173386882756704761607664135852855034678556753487133293648186980649622260361388994869790176611]
19:41:09 <Cale> > let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in product $ zipWith (^) primes (map ord "Hello")
19:41:09 <lambdabot> 16494655780659339947182552576422756794790068612064288306418265517394349344066214616222018844835866267141943107823334187149334898562231349428570828125245761446698163661894012959945718330007647280982622
19:41:10 <lambdabot> 540668989358375242528596320746006878445233892312657760820002295076847076416015625000000000000000000000000000000000000000000000000000000000000000000000000
19:41:22 <dancor> well it's _a_ godel encoding right?  if not _the_
19:41:42 <dancor> of course _the_ is infinitely awesomer
19:41:44 <Cale> I suppose you could use something like that. :)
19:42:03 <newsham> this fromIntegral . fromEnum business hurts my sensibilities :(
19:43:10 <dancor> i want to see the decoder!  :)
19:44:08 <newsham> unmsg x = map (chr . fromIntegral . (`mod` 131)) $ takeWhile (/= 0) $ iterate (`div` 131) x
19:44:20 <Cale> dancor: there's one on my user page on the old wiki
19:44:21 <newsham> (or do you mean for the primes one?)
19:44:25 <Cale> @oldwiki CaleGibbard
19:44:26 <lambdabot> http://www.haskell.org/hawiki/CaleGibbard
19:47:40 <dancor> hm you have to know the message length?
19:49:49 <Cale> no
19:49:59 <Cale> but it hlps
19:50:01 <Cale> helps*
19:52:45 <dons> Lemmih, while preparing HWN, I see this lovely release message: "I hearby announce the release of  ..."
19:52:48 * dons must use that.
19:53:30 <dons> Perhaps even, "I hearby announce the release of Foo. You're either with us or against us!"
19:53:35 <palomer> dons: do you want me to write up a better proposal for the type system helper on the proposal page (ie, will it increase my chances of getting it)?
19:53:46 <dons> hmm. let me see.
19:54:29 <Cale> hereby
19:54:48 <dons> hehe. yes.
19:55:07 <Lemmih> D'oh.
19:55:16 <dons> that's just hearsay though
19:55:48 <dons> palomer: 'Graphical Type System Analysis" ?
19:56:07 <palomer> yup
19:56:17 <dancor> hm why would ord not be in scope..
19:56:26 <dancor> > ord 'a'
19:56:27 <lambdabot> 97
19:56:45 <dons> I think a more detailed proposal might be a good idea. But I can only be guessing what google wants to see.
19:56:46 <dancor> > this is not haskell
19:56:46 <lambdabot>  Not in scope: `haskell'
19:57:10 <dons> A timeline, concrete deliverabels, background. suitability for the task.
19:57:12 <Cale> wow, kakuro would be a whole lot easier if I could add :)
19:57:45 <palomer> ahh, good point
19:57:49 <palomer> I'll write them up later
19:57:56 <dons> palomer: I mean, I'd write as if I was proposing a phd topic.
19:58:05 <dons> since there's serious money involved
19:58:21 <dons> whose on the west coast? lispy?
19:58:23 <dons> ?localtime lispy
19:58:24 <lambdabot> Local time for lispy is Sun May  7 19:58:01 2006
19:58:31 <palomer> true true
19:58:32 <dons> is that san fran time?
19:58:54 <sjanssen> dons: that's CST
19:58:57 <sjanssen> ach
19:59:00 <sjanssen> PST
19:59:08 <dons> not PDT (is that it?)
19:59:22 <dons> hmm. /me wishes for @timein again.
19:59:23 <sjanssen> yeah, PDT
19:59:40 <dons> @google time in san francisco
19:59:42 <dons> let see...
19:59:42 <lambdabot> http://www.timeanddate.com/worldclock/city.html?n=224
19:59:45 <dons> bah
20:00:35 <dons> no no, lispy's time looks right.
20:00:44 <dons> 8pm on the west coast, right?
20:01:05 <dons> so, 21 hours till the dead line.
20:03:48 <dons> Lemmih, getting funky with the english? "nigh all cases" :)
20:04:06 * dons finds these super-formal release messages fun
20:04:47 <dancor> ah.  it's in Data.Char these days.  sigh
20:06:14 <palomer> hrmph
20:06:33 <palomer> from my understanding, haskell.org is going to pick the projects from the proposals and then write something up for google
20:06:39 <palomer> ie, google doesn't see the student proposals
20:06:44 <dons> hmm?
20:06:54 <dons> google sees the proposals, don't they?
20:07:01 <dons> haskell.org just ranks and assigns mentors
20:07:33 <dons> we're a layer 1 filter. rejecting the 5% of wrong things (like projects that code in lisp) and assigning mentors
20:07:36 <dons> that's all, I think.
20:07:50 <dons> no, palomer ?
20:08:00 <dons> check the details in the timeline.
20:08:25 <dons> 'my understanding'. very kant. that's another weird old phrase.
20:08:41 <palomer> timeline?
20:08:54 <dons> the soc timeline, on the students or mentors faq page.
20:09:03 <dons> describes what tasks are done by when and by whom
20:09:48 <palomer> righto
20:09:55 <palomer> ok, I'll have to write something up nice and spiffy
20:10:09 <sjanssen> dons: doesn't Haskell.org also rank the projects they receive?
20:10:10 * palomer would so like to see Yi be usable be the end of the summer
20:10:26 <dons> please do.
20:10:29 <dons> sjanssen: yes.
20:10:44 <stepcut> mmm, yi would be nice indeed
20:10:45 <dons> on a scale of: I will mentor this. I think someone should mentor this. I like this. I don't like this.
20:11:00 <dons> assigned +4 +2 +1 -2 points, iirc.
20:13:01 <dons> palomer: sjanssen so the idea would be to double check with the mentor you want that they've indeed indicated to google they'll mentor your project. (that's how I'd approach it)
20:13:14 <dons> then you get at least +4, and whatever else other mentors feel about the project
20:13:30 <Cale> however, if someone ranks a project twice, the rankings given are cumulative
20:13:31 <dons> I would say though, that all applications will be assigned mentors by may 22, otherwise they have no chance.
20:13:56 <dons> in fact, I think that is our job as haskell.org, to find enough mentors to take on all  the projects
20:14:36 <newsham> wish some student would work on HWS ;-)
20:14:47 <dons> hoan is, I think.
20:14:52 <dons> but no application yet.
20:14:53 <newsham> hoan?
20:14:55 <dons> hoan? applying?
20:15:05 <dons> a couple of days ago he rewrote hws to use ByteString
20:15:16 <newsham> got an email address?
20:15:29 <dons> i think he's on the haskel.org soc page.
20:15:35 <newsham> i'm using hws and have made a number of patches 
20:15:41 <dons> ?seen hoan
20:15:42 <lambdabot> I saw hoan leaving #haskell 1 day, 15 hours, 33 minutes and 17 seconds ago, and .
20:15:46 <dons> yeah, there's about 4 of you guys.
20:16:02 <dons> you should get your act together on the hws thing..
20:16:04 <dons> ;)
20:16:05 <newsham> i would like to know who the other 3 are.  no sense reproducing effort
20:16:10 <dons> i.e. a central repo?
20:16:19 <newsham> i posted to h-cafe but nobody seemed interested
20:16:25 <dons> well, hoan. musasabi has patches too I think. there's been a few others.
20:20:21 <dons> newsham: hoan .at. ton-that.org
20:30:44 <newsham> found it and mailed him and musasabi.  thank you.
20:44:14 <dons> newsham: yeahm, I think someone should set up a central hws repo, and take the initiative to coordinate hws efforts.
20:44:23 <dons> we're too small a community to have 3 webserver projects :)
20:45:27 <akemp> @seen SyntaxNinja
20:45:27 <lambdabot> I saw SyntaxNinja leaving #haskell 2 days, 2 hours, 54 minutes and 49 seconds ago, and .
20:45:31 <sethk> is there a syntax for continuing a quoted string on a following line?
20:45:52 <sethk> e.g. in java, you can end a line in " and begin the next line with "
20:45:54 <dons> yep
20:46:01 <dons>  "foo\
20:46:04 <dons>  \more foo"
20:46:31 <sethk> end the line with \ and \ on the following line before the first character?
20:46:35 <dons> depending on whether you use cpp, you might need to add a single space char after the \ to make cpp happy
20:46:49 <dons> sethk, yep. but there can be arbitrary space before and after the \
20:46:51 <sethk> I don't use it explicitly, just ghc
20:46:54 <dons> so "fooo"\
20:46:56 <dons>                    \"foo"
20:47:03 <dons> sorry,              \foo"
20:47:03 <sethk> ok, thanks
20:47:04 <dons> is ok. iirc.
20:47:21 <dons> grr. my brain hit " incorrectly twice then.
20:47:44 <sethk> no closing quote on the preceding line?
20:47:45 <dons> some things like ending strings in " and typing "darcs" for words that start with "da" are just hardwired into my spine now.
20:47:50 <dons> sethk. no.
20:47:54 <dons>   "foo\
20:47:58 <dons>    \bar"
20:48:03 <sethk> ok, thanks.
20:49:42 <sethk> dons, hmm, what if the line begins with \x55?
20:49:47 <sethk> begins with \x##  ?
20:50:03 <sethk> "\x55\
20:50:09 <sethk> then  \\x55 ?
20:50:34 <dons> hmm. the escaped line that starts with \ will need two, won't it?
20:50:46 <dons> i.e. "\x55\  -- is ok
20:50:49 <Lemmih> > "\x55\     \\x55"
20:50:50 <lambdabot> "UU"
20:50:51 <sethk> yes, I guess so
20:50:54 <dons>     \\x47" -- to end it
20:51:12 <dons> and as Lemmih points out, you can use string gaps anywhere
20:51:17 <dons> they're wacky funsters
20:51:25 <sethk> ok, I'll try it.
20:53:03 <dancor> is it weird that you can do arr!!x where x is an Integer not an Int
20:53:07 <dancor> can't
20:53:23 <sethk> dancor, no, the types don't match
20:53:33 <Lemmih> @type genericIndex
20:53:35 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
20:53:40 <sethk> dancor, no weirder than you can't do  arr !! Q
20:54:02 <dancor> sethk: you've got static typing on the brain if you think it's no weirder at all
20:54:05 <dancor> :)
20:54:14 <sethk> dancor, well, perhaps a bit more weird  :)
20:54:23 <Lemmih> > [1,2,3] `genericIndex` (1::Integer)
20:54:24 <lambdabot> 2
20:54:51 <tnks> Hi.  I'm trying to debug a Haskell project I'm tinkering with for school, and I'm getting a little confused.
20:55:36 <dancor> > (repeat 1)!!(2^400000)
20:55:38 <lambdabot> 1
20:55:42 <dancor> why does that work
20:55:46 <tnks> I have a function defined "lockedM super self = (extend needsKeyM secureM) super self" and it works... but it doesn't seem to be issomorphic with "lockedM = extend needsKeyM secureM"
20:56:28 <Lemmih> dancor: 2^400000 == 0 (:
20:56:39 <dons> > 2^400000
20:56:43 <lambdabot> Terminated
20:56:47 <Lemmih> > 2^400000 :: Int
20:56:47 <tnks> I think I'm missing something fundamental about lambda abstraction application in Haskell.
20:56:48 <lambdabot> 0
20:56:48 <dons> hehe
20:56:57 <dons> good point
20:57:15 <dancor> Lemmih: oh, tacit conversion?
20:57:24 <dancor> Haskell: tsk tsk
20:57:32 <dons> tacit? its all there if you put the types in.
20:57:37 <dons> you're just assuming the wrong type
20:57:49 <dons> ?type 2^40000
20:57:51 <lambdabot> forall a. (Num a) => a
20:57:54 <dons> ?type 2^40000 :: Int
20:57:55 <lambdabot> Int :: Int
20:58:01 <Lemmih> dancor: You can't fit 2^400000 in 32 bit.
20:58:09 <palomer> even if you try really hard?
20:58:10 <dancor> dons, i'm just surprised that (repeat 1)!!(2^400000) gives me no error.
20:58:15 <palomer> squeeeeeeeze them in
20:58:17 <Lemmih> tnks: That's just the monomorphic restriction.
20:58:22 <dons> ?type repeat
20:58:23 <lambdabot> forall a. a -> [a]
20:58:26 <dancor> dons, no explicit conversion there..
20:58:34 <dons> ?type (!!)
20:58:35 <lambdabot> forall a. [a] -> Int -> a
20:58:40 <dons> there's your constraint
20:58:57 <dons> so your 2^xyz has to be :: Int
20:59:02 <dancor> well to bring up an old example
20:59:04 <Lemmih> tnks: You can disable it with -fno-monomorphic-restriction in GHC.
20:59:05 <dons> and it all falls into place.
20:59:10 <araujo> Hi!
20:59:11 <dancor> > (repeat 1)!!('Q')
20:59:12 <lambdabot> Couldn't match `Int' against `Char'
20:59:22 <tnks> Lemmih: I'm looking it up now... I might have some questions if I don't figure it all out... thanks for the pointer.
20:59:26 <dancor> > (repeat 1)!!('0.0044')
20:59:27 <lambdabot>  parse error on input `0.0044'
20:59:33 <dons> Lemmih: but the monomorphism restriction isn't going to change the type constraint on !!
20:59:41 <dancor> > (repeat 1)!!(0.0044)
20:59:42 <lambdabot>  add an instance declaration for (Fractional Int)
20:59:58 <dons> there's no magic. !! takes an Int index. end of story.
21:00:05 <Lemmih> dons: Eh? I was referring to 'lockedM'.
21:00:09 <dons> ah., sorry.
21:01:13 <dancor> seems dangerous to me
21:01:25 <dancor> maybe that's the danger of Int in general
21:02:05 <dons> these Int constraints are a bit controversial, but the general argument is that since it needs to be at least that much in memory for the index to work, the Int is harmless.
21:03:09 <dons> there's things like genericLength as alternatives
21:03:11 <dons> @type length
21:03:12 <lambdabot> forall a. [a] -> Int
21:03:15 <dons> @type genericLength
21:03:16 <lambdabot> forall i b. (Num i) => [b] -> i
21:03:22 <Cale> the counter-argument to that is that an Int constraint there might cause a type variable to unexpectedly default to Int when one expected Integer
21:03:41 <dons> right, as it was unexpected in dancor's case.
21:03:45 <Cale> yeah
21:04:08 <Cale> I've been bitten by it enough times to be annoyed :)
21:04:43 <dons> should be easy enough to write Data.List.Integer.. and just use that?
21:05:02 <dons> @type genericIndex -- dancor?
21:05:03 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
21:05:23 <Cale> you'd have to import Prelude hiding a bunch of stuff
21:05:28 <dons> > (repeat 1) `genericIndex` (2 ^ 4000000) -- no chance
21:05:31 <lambdabot> Terminated
21:05:36 <dancor> Int/Integer and good Arrays are the things i worry most about with haskell.  and trying to work with multiple State Monads at once well.
21:05:58 <dons> Arrays are fine. You'd use Data.Array.Unboxed if performance was an issue.
21:06:17 <sethk> rounding Integer down to Int is definitely a bad idea
21:06:17 <dons> and this Int/Integer thing, easy enough to avoid.
21:06:17 <palomer> unless you're superman
21:06:44 <palomer> > (repeat 1) `genericIndex` (2^20)
21:06:45 <lambdabot> 1
21:06:48 <palomer> > (repeat 1) `genericIndex` (2^30)
21:06:52 <lambdabot> Terminated
21:06:56 <palomer> bastard
21:07:00 <dancor> hah
21:07:13 <dons> that's a big list it needs to generate
21:07:23 <dancor> interesting that it can't optimize that super well.  i guess i expect too much
21:07:26 <dons> though repeat 1 should be a loop, I guess.
21:07:48 <dons> let ones = 1 : ones in ones `genericIndex` (2 ^ 30)
21:08:09 <dons> > let ones = 1 : ones in ones `genericIndex` (2 ^ 30)
21:08:11 <dancor> sethk: it's hard to imagine well-written code that would rely on that rounding.
21:08:21 <lambdabot> Terminated
21:08:25 <dons> bastard
21:09:13 <dons> > let ones = 1 : ones in ones `genericIndex` 1073741824
21:09:17 <lambdabot> Terminated
21:09:22 <dons> oh well.
21:09:25 <palomer> @. elite palomer
21:09:25 <lambdabot> L3arnING vI/\/\ i5 POiNtL3sz
21:09:29 <palomer> amen
21:09:34 <dancor> i'm glad that we swear at lambdabot.  other chans might frown on such freedom of expression.  you think they'd be used to bad language(s)
21:09:57 <dons> @vixen is palomer your bitch?
21:09:57 <lambdabot> no, do i seem bitchy to you?
21:10:06 <dons> heh
21:10:06 <Cale> @palomer
21:10:07 <lambdabot> Scalliwags!
21:10:18 <dons> @. vixen palomer
21:10:18 <lambdabot> Does your mommie know you're here, little naughty boy?
21:10:21 <dons> fun!
21:10:26 <Cale> @keal
21:10:27 <lambdabot> just seeing how offtopic i could get everyone
21:10:31 <dons> vixen can talk to palomer all day long.
21:10:35 <dons> @. vixen palomer
21:10:35 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
21:10:49 <Cale> wow
21:10:50 <dons> vixen is very evil.
21:10:55 <Cale> @. vixen keal
21:10:55 <lambdabot> Thank God for AOL that I could meet people like you!
21:11:00 <dons> hehe
21:11:10 <Cale> perfect
21:12:20 <sethk> AOL?  a bit out of date, there, perhaps?
21:12:45 <Cale> @keal
21:12:46 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
21:13:06 <Cale> @vixen you think i am one of them persnipity uppity men are pig lesbian mathematicians?
21:13:07 <lambdabot> i thought you might be
21:13:07 <dancor> if you guys have a lot of State monads to pass around, what do you do?  use State Map a and pick them out by key?
21:13:16 <sethk> dancor, you don't pass state monads
21:13:18 <dons> hehe
21:13:31 <sethk> dancor, the state monad no longer exists at the point you are conceiving of passing it
21:13:46 <Cale> I think I know what he means
21:13:57 <Cale> dancor: usually you make some record type
21:14:02 <dons> you'd just extend a single state type, in practice. well, I would.
21:14:07 <dons> yeah,  a record.
21:14:09 <dancor> sethk: example.  i have a scrabble game.  i have the board, the racks, the bag.  i need to do stuff.
21:14:17 <sethk> dancor, there can only be one state monad
21:14:20 <dons> dancor: so they all go in the Scrabble monad
21:14:26 <dancor> but some functions should only need the bag, eg.
21:14:31 <dons> and then getBoard would be board . get
21:14:33 <sethk> dancor, as dons and cale said, you use an algebraic type to structure all the state data in one monad
21:14:52 <dancor> hmm is that optimal for reusability?  this is the kind of thing that worries me
21:14:54 <sethk> dons, don't throw function composition at him yet
21:14:57 <Cale> State ScrabblePosition
21:15:14 <sethk> dancor, no choice, you cannot have more than one state monad
21:15:21 <Cale> is your monad, where ScrabblePosition consists of all the state data
21:15:23 <dancor> later i might want to just use the rack and bag stuff for a boardless word game variant.
21:15:25 <Cale> you can newtype it
21:15:45 <Cale> and then write an interface to the components which preserves the game rules
21:15:45 <sethk> dancor, you can change the type of the state, or perhaps leave part of the state unpopulated
21:16:12 <Cale> like, perhaps don't give the user get and put
21:16:26 <Cale> give them placeWord, and so on
21:16:49 <dons> yeah, lifting the scrabble rules into the type would be very nice
21:17:04 <dons> or at least some of the rules
21:17:23 <Cale> and then just don't export the newtype constructor from your module, so that the rest of your program is forced to use your nice exported interface which makes sure that the rules are enforced.
21:17:46 <Cale> (at least to a certain extent)
21:18:02 <dancor> but will it be easy to rip certain parts out of my monolithic monad later for other programs?
21:18:22 <Cale> well, a Scrabble monad is pretty specialised :)
21:18:34 <Cale> you're building it out of reusable components already though
21:18:40 <Cale> State or StateT
21:18:53 <dancor> ideally i would just have all bag with all the things i might do with a letter bag, racks separate, and board separate.  monolithic=bad
21:19:09 <dons> right. as long as you're using, say, StateT, there's going to be very little new code for manipulating the monad to write.
21:20:11 <Cale> dancor: you can do that, but interaction between the components becomes somewhat tricky, and you'll end up writing another module to smash them together in the end anyway.
21:20:28 <dons> monolithic isn't goign to be bad here, since you have the record accessors to keep things apart.
21:20:30 <Cale> Still, there's nothing stopping you from writing a BagT and RacksT
21:21:34 <Cale> it's just a bit more complicated like that
21:24:10 <palomer> dons: if you have a list of Yi plugins you'd like to get implemented, let me know
21:25:35 <dons> syntax highlighting finished. then steal stuff from hide.
21:25:47 <dons> then steal stuff from emacs
21:25:52 <dons> then take over the world
21:26:00 <dons> in that order.
21:26:07 <dons> oh, and $$ profit.
21:26:15 <dons> ;)
21:26:58 <dons> palomer: basically, I'd try to think of some type-based things to work on.
21:27:01 <dons> for your application
21:27:16 <dons> ie. spotting type errors. umm.. other things?
21:27:23 <dons> type rewriting?
21:27:31 <dons> that would be kind of cool, if it converted types to simpler forms
21:27:51 <dons> so when you code up something that looks like Maybe, it would be rewritten to Maybe for you.
21:28:23 <dons> stuff from HaRe
21:28:48 <palomer> oh my
21:29:20 <dons> since you love type checkers so much.
21:29:40 <palomer> so if my user types data Scalliwags a = Brump | Blargh a, my application would go "wouldn't you like to use maybe instead?"
21:29:52 <dons> maybe?
21:29:55 <palomer> Maybe
21:29:57 <dons> or maybe it should go the otherway.
21:30:05 <dons> I mean, perhaps? :)
21:30:21 <gzl> wait, so you use Maybe and it rewrites it as Scalliwags? :)
21:30:43 <dons> it depends . sometimes you want to go one way, sometimes the other way
21:30:50 <dons> i.e. add more type information, or lose it
21:31:06 <dons> i could imagine a plugin that newtypes the constructors,
21:31:08 <gzl> yeah, ok. I was sort of joking because palomer picked goofy names
21:31:11 <dons> so the constructors get lifted out to be their own types
21:31:34 <dons> I dont' know of much work done on type-refactoring
21:31:41 <dons> only on rewriting terms
21:32:17 <dons> i guess you'd probably want to rewrite your terms too, when you start changing the types.
21:32:28 <dons> anyway, palomer, put in what you want to work on.
21:33:23 <palomer> just fishing for ideas
21:33:31 <palomer> (for another proposal)
21:33:38 <dons> ok.
21:36:05 <LordBrain> Cale_: I read your contribution to the wiki on monads as containers. Thanks for it. That's valuable content.
21:36:23 <Cale> LordBrain: glad you enjoyed it :)
21:37:16 <lispy> do you guys know how i can use visual haskell and install wxwidgets?  visual haskell a version of ghc 6.5 that comes with cabal
21:38:30 <palomer> I think there's a verb missing
21:39:01 <LordBrain> Cale: have you studied category theory?
21:39:21 <palomer> category theory is the paris hilton of mathematics
21:39:31 <Cale> LordBrain: to some extent
21:39:32 <LordBrain> hmmm that doesnt sound good
21:39:34 <Cale> palomer: hm?
21:39:37 <palomer> hm!
21:39:44 <lispy> palomer: visual haskell comes with a version of ghc 6.5 and cabal.
21:39:50 <lispy> palomer: i think that's what i meant to say
21:40:05 <palomer> a verb and a preposition
21:40:21 * palomer wonders why visual haskell needs ghc 6.5
21:40:23 <palomer> that's nuts!
21:40:29 <lispy> can cabal be used to download and install packages?
21:40:43 <lispy> palomer: because 6.5 was modified just for that purpose :)
21:41:07 <Cale> "That's Left Adjoint" is analogous to "That's Hot"
21:41:08 <lispy> i think they added hooks into the compiler to make it work as a VS plugin
21:41:12 <dons> palomer, for the ghc-api
21:41:28 <palomer> righto
21:41:43 <palomer> dons: have you thought of swiping the emacs code for keyboard input?
21:41:51 <LordBrain> well, i guess one thing i'm curious about is, in your quest for a monadic mental model, if you found it helpful to look at monads as described by the mathematicians completely apart from haskell?
21:41:51 <palomer> (or kate, kate has even faster keyboard input!)
21:42:09 <dons> oh, that again.
21:42:24 <palomer> actually, I take that back, emacs and kate are tied
21:42:29 <dons> I havne't looked at yi recently. but certainly some fancy input low level code could be done, sure.
21:42:44 <Cale> LordBrain: well, it's useful to know that perspective, but it doesn't directly lead to usable mental models
21:42:51 <dons> then again, since I use the curses mode only, i never notice anything wrong with the speed.
21:42:57 <Cale> (apart from just using algebra, if that counts)
21:43:04 <dons> patches always welcome, palomer :)
21:44:17 <palomer> but it's low level stuff!
21:44:29 * palomer is a low level goof
21:44:29 <LordBrain> in haskell it seems like we are using monads to do things... in math i assume we would use them to prove things... or to know things already proven when we recognize them i suppose...
21:45:27 <Cale> LordBrain: well, in a general category, monads can be more abstract
21:46:11 <Cale> Like, in the category of metric spaces, the functor which sends each space to its completion is a monad.
21:46:30 <dons> palomer: there's a matter of using the curses getchar abstraction, or diving lower into termio
21:46:38 <dons> which is almost certainly what kate and emacs do
21:46:48 <lispy> LordBrain: it's like, does studying mathematical graphs help you understand implementing/using them in a program?
21:46:49 <LordBrain> is that because the completion of the completion is simply itself?
21:47:00 <palomer> is there a strong enough connection between monads, monoids and monadic logic to justify the naming similarity?
21:47:06 <LordBrain> lispy, i would say yes
21:47:14 <Cale> LordBrain: well, you use that isomorphism for join
21:47:18 <dons> aren't there some papers by moggi justifying this ;)
21:47:43 <LordBrain> Cale: by that isomorphism, you mean the identity?
21:48:02 <Cale> LordBrain: well, depending on how you look at it, it might be the identity
21:48:12 <Cale> It's an isomorphism anyway
21:48:44 <Cale> (the completion is usually considered a space of equivalence classes of sequences of points of the original space, so they're usually not identical)
21:49:14 <LordBrain> oh... i was using a different def..
21:49:17 <LordBrain> ok
21:49:42 <Cale> return would just send a point in the original space to the equivalence class containing the sequence with that point repeated over and over
21:50:06 <Cale> i.e. x |-> [{x,x,x,...}]
21:50:07 <LordBrain> i see
21:53:45 <lispy> Lemmih: ping?
21:54:08 <lispy> Lemmih: do you know anything about installing wxhaskell?  your name came up in a google search but the page is a 404
21:54:16 <dons> Lemmih's sleeping , i think
21:54:27 <lispy> that's not allowed
21:54:34 <LordBrain> I wonder if everyone in here has a degree in math.
21:54:42 <lispy> LordBrain: i do
21:54:55 <lispy> Cale has one, or is earning one
21:55:02 <LordBrain> i have one too
21:55:02 <lispy> i don't know about others
21:55:30 <lispy> i find that CS is hard, but math is less natural for me
21:55:36 <dons> LordBrain: its actually a requirement to join. We have police to enforce it. a roving band of international haskellers-at-large
21:55:39 <LordBrain> interesting lispy
21:55:41 <Cale> I have one
21:56:08 <dons> with sharp lambdas to keep people in line
21:56:24 * lispy has scarrs to prove it
21:56:31 <LordBrain> yeah it just occured to me that haskell might not appeal to the average programmer who is not so fortunate as us...
21:56:32 <Cale> heh
21:57:36 <Korollary> I prophesize that the monad thing will not really catch on among the usual crowd.
21:57:49 <dons> Korollary: no! don't say it.
21:57:52 <LordBrain> lol
21:57:57 <dons> monads for the masses!
21:57:58 <lispy> i wonder if this version of cabal has get
21:58:08 <Korollary> It's im the logs, baby. I dropped it like it's hot.
21:58:12 <Korollary> *in
21:58:13 <lispy> MftM
21:59:12 <lambdabot> Haskell Weekly News for May 08, out now: sequence.complete.org
21:59:14 <Cale> Monads are a pretty easy concept, but there's a lot of examples to know about
21:59:42 <Korollary> Cale: Geometry is pretty easy, too.
21:59:47 <dons> Cale, but its an abstraction. and joe blow doesn't like abstraction.
21:59:56 <dons> does Joe Blow translate, I wonder.
22:00:10 <lispy> hmm...so now i have two versions of ghc on here...that's could be the end of me
22:00:18 <LordBrain> people who are named joe dont like that expression
22:00:22 <Cale> Korollary: depends what kind of geometry you're referring to
22:00:33 <lispy> dons: we use that expression in my part of the us
22:00:36 <LordBrain> i know because my brother is named joe, and he grumbles about it
22:00:45 <dons> ah, ok. 
22:01:01 <lispy> i like steve as a generic name
22:01:11 <LordBrain> ok
22:01:14 <dons> felt vaguely like a fair-dinkum-ism :)
22:01:19 <lispy> sometimes i name files on my computer 'steve' when i don't know what name to use :)
22:01:28 <Korollary> Bob
22:01:34 <Cale> lispy: hmm... you wouldn't happen to watch Stargate Atlantis?
22:01:46 <lispy> Cale: never heard of it
22:01:49 <Cale> oh, okay
22:02:08 <LordBrain> i saw an episode or to of that.. but i dont get the sci-fi channel at home
22:02:18 * lispy doesn't have TV and hasn't since about 2000
22:02:47 * Korollary is about to plunk down $1500 on an HDTV
22:02:51 <Cale> (It's just that there's a memorable scene in which "Steve" is arbitrarily chosen as a name for a captured wraith)
22:02:55 <sethk> damn, the little bit of C code in my device driver barfs when the data get's large.  I've gotten so used to not having to worry about that.
22:02:59 <lispy> Korollary: if taht's your thing...then power to you
22:03:24 <lispy> Cale: heh, sounds fun
22:03:43 <lispy> i have seen serenity (or is it firefly) because we watched them on netflix (me and my ex)
22:03:52 <Cale> Firefly was great
22:03:54 <lispy> that show was worth watching
22:04:04 <Cale> (so is Serenity, the movie)
22:04:06 <dons> serenity is the movie
22:04:17 <lispy> okay, then i've seen both
22:04:24 <Cale> I hope that something happens that will let them make more of it
22:04:27 <dons> yeah, such a great show, so sad it got cancelled
22:04:37 <LordBrain> serinity is the name of the ship, and the name of the movie.. firefly the name of the series
22:04:58 <Cale> also, I just finished watching Farscape, it was really quite good too
22:05:26 <Cale> Serenity was also the name of the pilot episode
22:05:35 <LordBrain> ah
22:05:41 <LordBrain> yeah i forgot that
22:06:32 <palomer> > ord '0'
22:06:33 <lambdabot> 48
22:06:51 <palomer> is that the unicode  numbering of '0'?
22:07:26 <Korollary> heard of an ascii table?
22:08:57 <palomer> I think a unicode table would be more appropriate
22:09:46 <Cale> gucharmap
22:09:47 <LordBrain> isnt unicode an ambiguous term? it seems like there are multiple unicodes... which really makes it a misnomer..
22:10:17 <Korollary> not really as long as you specify the encoding
22:10:17 <Cale> U+0030 DIGIT ZERO
22:11:20 <Cale> (that's in hexadecimal)
22:11:24 <lispy> okay, i have the verson of ghc from visual haskell in my path, so i think i'll try to build wxhaskell and see if everything works
22:11:36 <LordBrain> multiple encodings, but only one code... 
22:11:43 <lispy> > readHex "0030"
22:11:44 <lambdabot> [(48,"")]
22:11:56 <lispy> oh, look, 48, just like ord
22:13:01 <lispy> anyone played with proxima?
22:13:03 <LordBrain> yeah.. the first 128 characters in unicode are ascii
22:13:14 <lispy> yeah, taht was Korollary point earlier
22:13:28 <Cale>   
22:13:44 <Cale> gucharmap is fun :)
22:13:57 <palomer> dons: does yi use unicode for its input?
22:14:03 <lispy> heh, from here i saw: <Cale>  
22:14:10 <LordBrain> @index gucharmap
22:14:11 <lambdabot> bzzt
22:14:14 <LordBrain> ug
22:14:22 <lispy> Cale: so naturally i thought you were confused :)
22:14:24 <dons> palomer: do I look like a unicode kind of guy? (gtk yi does)
22:14:25 <Cale> lispy: I see the same thing that I typed
22:14:26 <LordBrain> i suck at the bot:)
22:14:35 <Cale> :)
22:14:53 <Cale> it's shaded blocks
22:14:53 <lispy> Cale: okay, i'll retype what i see instead of cut&paste, it was ???????
22:15:01 <Cale> ah :)
22:15:05 <lispy> seven questionmarks :)
22:15:20 <Cale> which client?
22:15:21 <palomer> dons: the sdl guys have uniced disabled by default because they say it slows down keyboard input
22:15:32 <palomer> s/uniced/unicode
22:15:33 <lispy> ERC Version 5.0 $Revision: 1.743 $
22:15:42 <dons> I imagine it would
22:15:49 <Cale> hmm, there ought to be a way to get that working with unicode
22:15:54 <Cale> (I'd think)
22:15:57 <LordBrain> i see an a with a hat, then an inversed capital VQ, then an a with a hat, inversed capital VR... 
22:16:29 <lispy> Cale: probably, i'm using erc inside, emacs inside screen inside putty...so there's a lot to go wrong with unicode support
22:16:49 <Cale>  Please Recycle
22:17:20 <LordBrain> you cant really just use whatever encoding you want on irc... nobody uses unicode, so if you do, its like you become the odd man out, and things dont look right to you and your things dont look right to them
22:17:40 <Cale> LordBrain: I think the standard encoding on this server is UTF-8
22:17:44 <LordBrain> i figured that out when i was studying other languages
22:17:51 <kzm_> Well - "nobody" appears to include me :-)
22:18:17 <kzm_> but yes, I guess IRC will just pass through the bytes unmolested?  So it will be by convention.
22:18:31 <kzm_> blbrfr
22:18:34 <Cale> If you have a unicode-capable client (X-Chat is particularly good with it), you should set it to UTF-8
22:18:52 <LordBrain> i say it depends
22:19:01 <Cale> (well, on freenode, you should)
22:19:05 <Korollary> well, it's not just about the client. It also needs the right font, too.
22:19:10 <lispy> kzm_: that displayed correctly for me
22:19:13 <Cale> yeah, or stack of fonts :)
22:19:19 <LordBrain> i'm inside a putty window
22:19:43 <LordBrain> but i've used xchat.. and i couldnt get by with utf-8 in some convos
22:19:52 <lispy> intersting that some of the stuff earlier was incorrect but what kzm_ was fine
22:19:53 <Cale> I like how gnome apps seem to find a font which has the glyph in it when the current font doesn't.
22:19:56 <Korollary> putty <- irssi <- screen
22:20:04 <LordBrain> same here Korollary 
22:20:21 <Cale> LordBrain: you have to set it to UTF-8 in the server options
22:20:35 <LordBrain> you mean putty?
22:20:41 <Cale> no, X-Chat
22:20:42 <lispy> i tried irssi but i couldn't stand having my channels reduced to numbers and i hated the scroll back/search mechanisms...so i came back to erc :)
22:20:43 <LordBrain> oh
22:21:00 <LordBrain> Cale: i could set the encoding to utf-8, what i meant was that it didnt work because the peopel i talked to didnt use it
22:21:12 <LordBrain> they used region specific encondings
22:21:17 <lispy> and i finally learned to configured erc so that it doesn't keep sucking up all the available ram
22:21:34 <Cale> LordBrain: yeah, but I think it's getting better all the time
22:21:40 <lispy> installing wxhaskell looks sort of painful
22:21:57 <LordBrain> so like if i'm talking to a spanish speaker i set it to western european or something like that... and if its a slovene speaker its central european
22:22:43 <goltrpoat> what if you're talking to someone who likes to intersperse slovenian words with spanish ones
22:22:43 <LordBrain> not that i am really capable in all these languages
22:22:56 <LordBrain> that happens goltrpoat 
22:22:59 <LordBrain> lol
22:23:29 <goltrpoat> -nod-  dober dan, hombre
22:23:41 <Cale>  -- some of the unicode mathematical symbols are odd, this is called "Division Times"
22:23:42 <LordBrain> but that typically means central european, because usually if someone speaks slovene at all, they're slovenian
22:23:57 <goltrpoat> that's an odd assumption to make
22:24:03 <Korollary> Cale: Maybe it refers to the period in time where division is performed.
22:24:10 <Cale> Korollary: heh
22:24:15 <LordBrain> goltrpoat: espeically since i'm not slovenian
22:24:39 <goltrpoat> heh
22:24:40 <Cale> Korollary: it's a division symbol with an x superimposed
22:24:44 <LordBrain> but in general.. slovene has fewere speakers world wide than esperanto.. 
22:25:20 <LordBrain> and besides that.. i dont really speak slovene... i was just dabling in it
22:25:55 <LordBrain> i think slovene probably got a boost when slovenia won its independence tho
22:26:00 <goltrpoat> i remember going to school with a bunch of slovenian kids in germany
22:26:42 <goltrpoat> we conversed in this weird combination of english, german, slovene and russian
22:26:56 <LordBrain> hmmm
22:26:57 <goltrpoat> in retrospect, i'm really not sure how anyone got anything across
22:27:02 <LordBrain> lol
22:27:31 <lispy> heh
22:27:41 <kzm_> cale: well - this  is called plus-minus, so why not division-times :-) ?
22:27:45 <lispy> less speakers than esperanto? so there are people that speak eseranto?
22:27:48 <Korollary> Cale: I googled but couldnt find anything. What the hell is that?
22:27:51 <lispy> er esperanto
22:27:51 <LordBrain> yeah
22:28:08 <LordBrain> there are even native speakers of esperanto
22:28:19 <lispy> whoa, where?
22:28:23 <kzm_> and of klingon.
22:28:27 <LordBrain> its the only invented langauge that can make that claim
22:28:28 <Korollary> kzm_: Oh no!
22:28:36 <kzm_> (or perhaps it is an UL?)
22:28:54 <LordBrain> there have been couples for which the only common language was esperanto, and their children of course grew up with it as their primary langauge
22:29:13 <newsham> native?  esperanto?
22:29:18 <newsham> que?
22:29:21 <Korollary> LordBrain: That's bizarre. Children need to speak with other children.
22:29:54 <LordBrain> well Korollary, needless to say, the children learned another langauge in addition
22:29:58 <kzm_> I think the klingon example was more of the type, "fun things to do when you become a parent.  #138 teach it klingon"
22:29:58 <Cale> http://www.fileformat.info/info/unicode/char/22c7/index.htm
22:30:52 <newsham> deaf children in central america invented their own sign language.  that doesnt count as an invented language in use?
22:30:53 <Korollary> Ugh
22:31:12 <LordBrain> hmmm newsham good point
22:31:47 <LordBrain> well i could call it artificial language... but how  artificial is any language which is spoken as a native language?
22:32:09 <newsham> codified languages are artificial.  (ie. modern german)
22:32:20 <newsham> language wants to evolve
22:32:33 <LordBrain> well esperanto was not fully codified
22:33:26 <LordBrain> it relies a lot on people just borrowing things from their natural language.. things are taken for granted in a way
22:33:30 <newsham> http://en.wikipedia.org/wiki/Nicaraguan_Sign_Language btw
22:34:02 <goltrpoat> yah, first natural language that was developed recently and wasn't a creole
22:34:05 <goltrpoat> i remember reading about it
22:34:07 <lispy> nicaragua is always one of those musical sounding words to me
22:34:20 <LordBrain> as opposed to lojban.. now thats a codified language... completely parsable by the computer
22:34:41 <lispy> lojban? do people use that?
22:34:45 <LordBrain> they actually have bnf for lojban
22:35:05 <LordBrain> lispy, try #lojban on this server
22:35:20 <LordBrain> you might witness some in there
22:35:34 <lispy> k, i'll check it out
22:35:45 <LordBrain> its not an especially popular langauge tho
22:36:03 <mahogny> a new language wouldn't hurt. esperanto isn't that good and .... no comments about lojban
22:36:05 <goltrpoat> interlingua is the only constructed language that doesn't look and read like utter ass
22:36:07 <goltrpoat> in my experience anyway
22:36:11 <Korollary> lol
22:36:28 <LordBrain> it has some extra appeal to certain segments of the population tho... hmmmmm sounds kinda familiar
22:36:34 <LordBrain> hehe
22:36:51 <LordBrain> no, i think haskell is more popular than lojban
22:37:08 <newsham> as it should be ;-)
22:37:28 <Korollary> how do you say monad in lojban?
22:38:00 <newsham> how do you say "anticipation" in haskell?
22:38:32 <LordBrain> lojban tries to get rid of all ambiguity in words... one definition per a word
22:39:03 <newsham> that must make poetry particularly boring
22:39:15 <Korollary> poetry is boring, imho.
22:39:21 <LordBrain> there is lojban poetry on their website i think
22:39:30 <mahogny> both haskell and lojban are combinators though
22:39:35 <sethk> is there a maximum length for string, and/or for CString?
22:40:15 <LordBrain> hmmm i would not expect there to be a maximum length for a string... since we can have infinite lists, and a string is just a list of chars in haskell
22:40:45 <sethk> LordBrain, yes, how about CString?
22:40:57 <mahogny> someone should make a natural language based on lambda calculus. I guess it's not for you if you barely can take double negations though :)
22:41:03 <LordBrain> i didnt even know whe had a CString... i'm just a newbie
22:41:04 <sethk> cstring is a null terminated buffer
22:41:22 <sethk> mahogny, I ain't got no use for them double negatives
22:41:30 <mahogny> sethk, baaah :)
22:41:32 <Korollary> sethk: either way it looks like they'd be limited by heap size
22:41:39 <LordBrain> lojban's grammar is based on predicate calculus
22:41:56 <sethk> Korollary, that's what I assumed.  I'm overflowing a buffer on the c side...
22:42:18 <Korollary> ow
22:42:48 <sethk> ah, I found it
22:42:50 <sethk> I hate C
22:42:53 <mahogny> why the use of null termination? is that faster in any case?
22:43:05 <sethk> mahogny, for calling functions written in C
22:43:14 <sethk> mahogny, or returning values from a C function.
22:43:16 <mahogny> sethk, hm. yeah, I guess
22:43:28 <LordBrain> faster since C is faster...
22:43:31 <newsham> mmm C
22:43:42 <lispy> bleh, i don't want to install cygwin
22:43:43 <mahogny> ah yes, I messed up with FPS. different thing :)
22:43:51 <sethk> LordBrain, there is nothing about a null terminated string that is a part of the C language
22:44:01 <sethk> it's just a convention.  C knows nothing about strings.
22:44:10 <newsham> sethk: string literals are NUL terminated
22:44:19 <sethk> newsham, that's true
22:44:58 <sethk> lispy, cygwin takes forever to install, but it's perfectly easy and runs without waiting for you to type things
22:45:08 <sethk> lispy, of course after the initial part where you tell it what to do.
22:45:22 <lispy> saying that C doesn't know about strings is like arguing that lisp doesn't know about lists.  They are not primitive, but they are ubiquitious
22:45:31 <LordBrain> what i hate about cygwin.. is its really difficult to just make your own install disk to use on non-connected computers
22:45:42 <LordBrain> i've tried.. it bugged out
22:45:56 <mahogny> LordBrain, ...and someone oughta make a new console to go with it
22:45:59 <newsham> cygwin's not that slow to install if you have a fast link to a repository (and you dont select every package)
22:46:06 <sethk> lispy, not the same thing.  It's a convenience feature for the library, like using [] in a value definition, but it's not a part of the language itself.
22:46:09 <sethk> lispy, it's just sugar
22:46:21 <goltrpoat> saying that lisp doesn't know about lists is like saying that C doesn't know about scope delimiters
22:46:27 <lispy> i have slow network so that's why cygwin is unattractive, and my disk is not infinite and i think i'd rather fill it with things besides cygwin :)
22:46:33 <LordBrain> instead of cygwin, you might consider colinux
22:46:35 <newsham> lordbrain: the cygwin installer can install from your local hard drive.  in fact you can use a previous install to make new installs
22:46:36 <sethk> I didn't hear anybody way that lisp doesn't know about lists.  :)
22:46:50 <LordBrain> newsham: yes, thats the claim
22:46:54 <newsham> select "install from disk" and then select the directory of cached files.
22:46:56 <newsham> I do it all the time
22:46:58 <Korollary> it's a tuple of tuples!
22:47:05 <newsham> claim verified.
22:47:13 <lispy> sethk: lisp doesn't have lists, it just has cons cells, one use for cons cells is to build a tree which looks like a list :)
22:47:25 <goltrpoat> is colinux actually stable?
22:47:35 <LordBrain> well... i havent tried in a long time.. but the previous two times i did, it flopped with some error or another.. i cant recall the errors.. so i wont get into it..
22:47:37 <sethk> lispy, I'll have to trust you on that; I haven't looked into the internals of lisp
22:47:40 <Korollary> goltrpoat: It looked so when I tried but it was dog slow.
22:47:45 <goltrpoat> ah
22:47:52 <LordBrain> goltrpoat: i havent had a problem with it
22:47:54 <shapr> LordBrain: xu do tavla mi bau la lojban
22:48:06 <newsham> lispy: disks are nearly infinite.  $0.50 per gigabyte.  got fifty cents?  download cygwin!
22:48:07 <sethk> LordBrain, I've found that install everything is really the way to go, despite the length.  lot's of interrelationships that are not well documented.
22:48:24 <lispy> newsham: heh, i wish it was that easy
22:48:28 <newsham> (if you keep a second drive as backup, then its still only $1 per gig)
22:48:29 <sethk> ok, now I have to figure out how to use CStringLen on the C side.
22:48:32 <LordBrain> haha.. no.. its been a long time since i messed with lojban
22:48:33 <shapr> mi djica lenu mi gunka
22:48:40 <wolverian> hrm, babelfish doesn't support lojban, unfortunately.
22:48:51 <lispy> i have 2GB of free space, cygwin could easily take, what?  half of that?
22:49:05 <sethk> lispy, no, a few hundred meg, IIRC
22:49:05 <LordBrain> you're jogging my  memory slightly
22:49:21 <Korollary> 500MB or so gives you a lot plus X
22:49:22 <newsham> my cygwin cache is 634740 kB
22:49:35 <newsham> if memory serves correctly it contains all packages
22:49:44 <shapr> mi djica lenu mi se prali
22:49:46 <LordBrain> you like that you something...
22:49:48 <newsham> installed its larer, of course
22:49:51 <newsham> larger
22:50:00 <lispy> alright, i'll try it
22:51:49 <newsham> lispy: got a spare usb or ide port?
22:51:58 <newsham> buy a few hundred gigs
22:52:08 <lispy> heh
22:52:19 <lispy> probably i should just cleanup what i have
22:52:24 <shapr> lojban is fun.
22:52:27 <lispy> iirc this is an 80gig drive
22:52:34 <newsham> laptop?
22:52:54 <lispy> yeah
22:53:16 <goltrpoat> one nice thing about interlingua is that you can basically read it without knowing it..  http://ia.wikipedia.org/wiki/Wikipedia:Frontispicio
22:53:23 <lispy> is 'coi' a greeting in lojban?
22:53:27 <sethk> newsham, right, which you can delete from a machine if you don't want to use it as an install source.
22:53:29 <LordBrain> yes lispy
22:53:33 <LordBrain> exactly
22:53:42 <LordBrain> coi = greetings, hello, etc..
22:54:29 <LordBrain> they'll mangle your name too, because its not allowed to end in a vowel
22:54:37 <Korollary> goltrpoat: not true for chinese people
22:54:59 <lispy> LordBrain: y isn't always a vowel ;)
22:55:38 <shapr> I'm capr
22:55:45 * shapr always thinks of capybaras
22:55:54 <lispy> heh
22:55:56 <LordBrain> hmm i'm surprised how much lojban i remember
22:56:41 * lispy uninstalls a few gigs worth of programs he has on CD (aka games)
22:57:14 * goltrpoat briefly wonders why he's downloading colinux
22:57:24 <LordBrain> lol
22:57:27 <palomer> interlingua rocks!
22:57:28 <lispy> the feeling passes!
22:57:34 <lispy> @palomer
22:57:35 <lambdabot> Scalliwags!
22:57:41 <lispy> (sorry)
22:57:54 <lispy> @lispy
22:57:54 <lambdabot> list [module|command]. Where modules is one of:
22:57:55 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
22:57:55 <lambdabot> version vixen where
22:58:07 <lispy> ah, why don't i have a command...
22:58:09 <lispy> @keal
22:58:10 <lambdabot> can haskell compile flash animations and java apps?
22:58:27 <sjanssen> @. elite quote
22:58:28 <lambdabot> Syn+AXNINja $ay5: i 7HInk +h4+ ThE comPiLeR auTH0rS wiLl f|y hER3 from 3NG|4Nd ju$+ T0 Ki|L /\/\e iF I DID 7hAT
22:58:42 <lispy> hehe
23:00:12 <palomer> hrmph
23:00:18 <sethk> @type newCStringLen
23:00:19 <lambdabot> Not in scope: `newCStringLen'
23:00:26 <palomer> SoC proposal deadline is tomorrow at 8pm
23:00:29 <palomer> should I start now...
23:00:32 * palomer ponders
23:00:38 <palomer> it shouldn't take more than an hour
23:00:41 <palomer> I'll start tomorrow
23:01:11 <lispy> that's the spirit
23:01:36 <palomer> yeah baby
23:03:00 <lispy> @quote
23:03:00 <lambdabot> SebastianHanowski says: I tried to formalise a proof of rev (rev l)  = l i found in W. Kluges book "Abstract Computing Machines - A Lambda Calculus Perspective" which is pretty much a 'Pimp My Ride'
23:03:00 <lambdabot> for SECD-machines.
23:03:16 <Oeje1> Good morning Haskellets and Haskellers!
23:03:30 <lispy> top of the lambda to ya!
23:03:32 <tnks> I seem to be in functional dependency hell.
23:03:57 <lispy> tnks: does an eagle come to eat your torso everyday and then it grows back during the night?
23:04:14 <lispy> oh wait...that's a different hell
23:04:33 <tnks> What's a pastebin site you guys prefer?
23:04:39 <lispy> lisppaste
23:04:57 <lispy> @where pastebin
23:04:57 <lambdabot> http://rafb.net/paste
23:06:25 <lispy> there now i have 18GB free
23:06:44 <lispy> cygwin is just a drop in the bucket
23:08:44 <lispy> hm...this install won't finish before tomorrow though
23:08:57 <lispy> the internet seems to be the bottle neck
23:09:24 <Korollary> I used to get 150KB/s on my dsl
23:09:31 <Korollary> from ibiblio or something
23:09:50 <lispy> i'm getting a good 85kb/sec from kernel.org
23:10:07 <lispy> but after all this i'm only at 35%
23:10:11 <Korollary> tomorrow is 50 minutes away anyway
23:10:39 <lispy> which is why i should go to bed :
23:10:42 <lispy> :)
23:12:35 * shapr starts his tomorrow
23:12:43 <shapr> Good morning #haskell!
23:12:54 <lispy> coi
23:12:59 <dons> oh, that's why things seem slow:
23:13:01 <dons> 27400 dons      84   10   28M   27M run      -        0:01  2.44% ghc-6.5
23:13:01 <dons> 14227 dons      -5    0  133M   37M sleep    biowai   0:26  1.12% ghc-6.4.2
23:13:33 <shapr> coi lispy .i ma nuzba
23:13:50 <shapr> Does that say that dons is sleeping?
23:13:53 <lispy> shapr: coi is the only thing i've learned :)
23:14:00 <tnks> http://rafb.net/paste/results/BRYms151.txt
23:14:15 <dons> yeah, bio waiting.
23:14:21 <shapr> lispy: The standard connective is .i and nuzba is 'news'
23:14:24 <dons> as we call it here.
23:14:28 <tnks> It's a little early in the morning. 
23:14:34 <tnks> I hope that paste isn't too cryptic.
23:14:48 <shapr> lispy: Believe it or not, ma is the noun form of (\noun -> noun verb) and mo is the verb form of the same.
23:15:09 <shapr> lispy: So you can actually say ma mo as the ultimate form of "what's up" but that sort of usage is discouraged.
23:15:50 <shapr> But I actually said (forall X news) what sort of X?
23:16:03 <lispy> ah
23:16:15 <Cale> tnks: it's not clear because there's a11 in one of them, and a in the other.
23:16:26 <lispy> shapr: i wanted to install wxhaskell and try to use it with visual haskell
23:16:26 <shapr> You can translate some funny things... 'komodo' is a legal lojban utterance for example.
23:16:39 <Korollary> monstrous
23:17:00 <Cale> tnks: it's also probably going to be ambiguous because a isn't mentioned on the right side of =>
23:17:23 <shapr> komodo means something like 'hey you, what are you doing?'
23:17:25 <lispy> shapr: sa, i guess that's the news with me :)
23:17:44 <shapr> je'e
23:17:48 <tnks> Cale: yeah... that a11 is kind of floating.  
23:19:08 <shapr> lispy: Here's the easy solution - http://www.lojban.org/jboski/index.php For example, try "mi djica lenu mi prali"
23:19:47 <LordBrain> whats prali?
23:20:10 <shapr> profit!
23:20:30 <lispy> shapr: looks cool, but i can't read the output
23:20:52 <lispy> you is does the desiring the profits?
23:21:07 <shapr> Nah, I am desiring the event of profiting.
23:21:55 <shapr> Lojban is a bit like a typesystem, I learned a different way of making sentences. Lojban pointed out a lot of ambiguities in the languages I know.
23:22:44 <LordBrain> whats the name of the parser... i have it installed i believe but i forget what it was called
23:23:22 <shapr> jbofihe - lojbanic fish
23:23:35 <shapr> (aka babelfish)
23:24:01 <LordBrain> hmm i found it... i guess i just forgot how to use it
23:24:18 <LordBrain> like there is a switch which will give the english for each word
23:24:36 <shapr> jbofihe -x -b
23:25:22 <LordBrain> ah thanks
23:25:22 <shapr> I wrote some elisp tools for lojban. Stuff like 'dump a string to jbofihe' and 'grep the /usr/share/lojban/* files for a word'
23:25:44 <LordBrain> i had jbofihe -x -b like wired into my xchat
23:25:46 <shapr> Aaanyway, back to the topic...
23:25:51 <shapr> HASKELL!
23:25:52 <shapr> w00!
23:25:57 <LordBrain> so i could effectively cheat
23:26:00 <LordBrain> hehe
23:26:07 <shapr> It's not cheating if you're learning.
23:26:23 <LordBrain> yeah.. i did learn a lot i guess, because i seem to remember more than i expected
23:26:24 <shapr> That's why we have plugs in lambdabot.
23:27:25 <LordBrain> since it gave no output on errors.. i could effectively leave it on all the time, and it only displayed stuff when someone spoke fully correct lojban
23:28:23 <LordBrain> is there an irc client written in haskell?
23:28:59 <dons> hircules
23:29:18 <tnks> Cale: I changed the type signature... but I still have an issue.
23:29:19 <dons> and lambdabot is effectively one too
23:29:30 <dons> it would take very little effort to merge hmp3 or yi with lambdabot ...
23:29:42 <tnks> http://rafb.net/paste/results/G84xKF16.html
23:29:50 <tnks> I posted an update to my problem.
23:30:18 <dons> hmm. I should write the killer haskell irc client one day.
23:30:44 <newsham> yes.
23:31:01 <newsham> something like zenirc would be nice (but without the emacs)
23:31:04 <dons> as stable as hmp3, and as fun to use as lambdabot
23:33:59 <lispy> heh
23:34:03 <lispy> what is hmp3?
23:34:15 <lispy> i would have thought it was a haskell library for playing mp3s
23:34:34 <dons> nah, its an mp3 client with a very nice curses gui
23:34:35 <dons> ?where mp3
23:34:35 <lambdabot> I know nothing about mp3.
23:34:41 <newsham> ffi + something like liblame?
23:34:41 <dons> where hmp3
23:34:54 <dons> ?where hmp3
23:34:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
23:35:01 <dons> grr. typing standing up.
23:35:09 <dons> check the screen shot
23:35:11 <lispy> mp3 client?
23:35:19 <dons> easy to retro fit that to an irc client
23:35:30 <dons> since the ui is a pretty printer for curses screens
23:35:49 <lispy> oh, neat
23:36:52 <lispy> cygwin may actually finish today
23:37:00 <lispy> 86% and chugging
23:37:21 <LordBrain> you could probably pretty easily support ogg in that too, by being an interface to ogg123 as well... 
23:37:28 <LordBrain> ogg vorbis i mean
23:37:39 <LordBrain> most of my sound files are encoded in ogg vorbis
23:37:46 <dons> LordBrain: yeah, looked at it.
23:37:59 <dons> ogg123 doesn't quite have the hooks. but i should do it eventually
23:38:21 <lispy> or fix ogg123 :)
23:38:34 <newsham> or use ffi and access codecs directly w/o a frontend w/ hooks
23:39:23 <LordBrain> or here is an idea
23:39:39 <LordBrain> just make it a client for mpd, music player daemon
23:39:48 <newsham> ewww :)
23:39:50 <LordBrain> then it will support everything mpd does
23:47:09 <goltrpoat> colinux really doesn't like me
23:47:56 <lispy> is colinux like the comonad version of linux?
23:48:22 <goltrpoat> it's a dual to linux
23:49:25 <goltrpoat> (meaning it has a huge amount of software support, little vendor support, and a small yet steadfast team of qualified programmers working on it)
23:49:37 * goltrpoat ducks and runs
23:51:55 <LordBrain> i use colinux with actual linux installed on a separate partition
23:52:20 <goltrpoat> i was trying to be amusing.
23:53:02 <LordBrain> have it set up so i can basicly boot the same environment either using the colinux kernel or the actual kernel
23:53:31 <LordBrain> but i'm not using it at the moment
23:54:42 <LordBrain> and my brother set it up.. so i didnt have to mess with it very much to get it working :)
23:54:49 <lispy> so colinux runs inside other stuff?
23:55:02 <LordBrain> colinux runs on windows
23:55:24 * lispy sings a new song, "I fought the clock...but the clock won."
23:55:34 <LordBrain> it is one of the routes to get linux and windows simultaneously 
23:55:37 <goltrpoat> odd.  apparently i just had to run it several times in a row
23:55:47 <lispy> goltrpoat: hehe
23:55:58 <lispy> i hate 'fixes' like that
23:56:17 <skew> colinux? sounds like something involving category theory.
23:56:52 <lispy> in that case, what do you use a math coprocessor for? :)
23:57:23 <skew> as an adjunction to the processor, of course
23:57:27 <lispy> cygwin managed to install before the new day
23:57:55 <lispy> but alas, i'm out of steam this day, and heading for sleep before i start another one
23:58:03 <LordBrain> yeah me too
23:58:09 <lispy> g'night
23:58:12 <LordBrain> g'night
