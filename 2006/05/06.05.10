00:00:26 <kzm> It's a shame though.
00:01:08 <dons> kzm, you'll have to subimt BioHaskell.org for next year :)
00:01:13 <sjanssen> how many SoC applications did Haskell.org receive?
00:01:24 <dons> oh, 100 or so. Too many.
00:01:39 <dons> but only 20 or 30 are worth doing, I think.
00:01:44 <kzm> I thought about making our institute a mentoring.org.  But then it wouldn't be Haskell, just tons of perl hackers.
00:01:52 <kzm> Hell, I still get those with Haskell.org.
00:02:30 <ADEpt> sjanssen: 112
00:03:43 <dons> 112? huh.
00:03:59 <dons> so google will give us 11 slots?
00:04:02 <dons> hehe
00:04:08 <dons> that's my magic N formula
00:04:37 <kzm> is their budget similar to last year?
00:04:55 <kzm> which was, what?  500 slots or something?
00:05:22 <dons> not sure. we find out in a few days
00:05:23 <sjanssen> kzm: I'm not sure if they've announced it.  But, if they want the "wow" factor, they need to double their funding from last year
00:05:46 <kzm> Google is probably keen on "wow".
00:06:30 <dons> sjanssen: I'd think funding^2, right?
00:06:38 <dons> google: are you listening? :)
00:07:22 <sjanssen> I think 2 ^ funding
00:07:32 <dons> hehe
00:10:31 <ADEpt> dons: wow. we have student with as many as 9 applications
00:10:33 <kzm> Since you're both here.  What are your plans for Unicode and ByteStrings?
00:10:39 * ADEpt is almost done with pivots
00:10:44 <kzm> both = sjanssen + dons 
00:10:56 <dons> ADEpt: hmm
00:11:33 <dons> they didn't see the quality over quantity rule?
00:12:19 <sjanssen> kzm: I think I'll newtype ByteString, and rewrite all the operations
00:12:36 <dons> I think you pretty much have to.
00:12:49 <kzm> is the phantom type approach ruled out?
00:13:08 <sjanssen> phantom type approach?
00:13:29 <kzm> the idea was to use a phantom type to label bytestrings with the encoding.
00:13:48 <sjanssen> that is an interesting idea
00:14:03 <kzm> so you could simply retain a bunch of functions.  And cast becomes trivial.
00:14:23 <sjanssen> then have a typeclass that the phantoms instance?
00:14:53 <kzm> sjanssen, hey, I'll ask the questions here!  (Since I don't have the answers)
00:15:14 <kzm> well, a lot of functions could just work on 'ByteString a'
00:15:28 <kzm> Perhaps not as big a lot as if you assume single-byte encodings :-)
00:15:40 <eivuokko> Why would it be phantom type as you have to have state for encoding anyway, right?
00:16:05 <juhp> how to add a project to darcs.haskell.org?
00:17:17 <sjanssen> kzm: this breaks down for UTF-8 for example.  A simple operation like head has to know the data is UTF-8 to figure out how many bytes to eat
00:18:06 <kzm> Yes, so it is likely this gets less useful as you add more encodings.
00:18:09 <xerox> juhp: what project?
00:18:23 <juhp> xerox: hircules :)
00:18:26 <kzm> eivuokko, state?
00:18:41 <dons> juhp: !!
00:18:45 <dons> good news.
00:18:46 <xerox> juhp: uh, an IRC client? (-;
00:18:49 <eivuokko> kzm, wasn't there talk that some encodings require state?  Assumedly you need that for splices?
00:18:50 <dons> a new release?
00:19:00 <juhp> xerox: is there some docs about it somewhere
00:19:07 <juhp> dons: one day :)
00:19:22 <xerox> Heh, nice.
00:19:26 <dons> I should start using it so I can hack on it.
00:19:37 <juhp> dons: I'd just like to have the latest code out somewhere
00:19:53 <juhp> ie code that actually builds with current ghc/gtk2hs :)
00:19:53 <dons> yeah. now, I think Lemmih knows.
00:20:00 <dons> you need a darcs.haskell.org account, I think.
00:20:15 <kzm> eivuokko, hm.  Many encodings need state, I suppose.  Ideally, we should be able to provide gzip as an "encoding".
00:20:19 <juhp> probably I missed the announcement about it and everything....
00:20:22 <juhp> dons: ok
00:20:38 <juhp> Lemmih: how can I get an darcs.h.o account?
00:20:56 <kzm> but I think if you want to actually do complicated processing, you would want to convert to UCS4 first.
00:21:13 <kzm> Anybody read the Unicode Tech Report on why UTF-16 is so great?
00:21:26 <sjanssen> kzm: I did
00:21:34 <juhp> kzm: why is it so great? :)
00:21:34 <kzm> Do you agree?
00:21:48 <eivuokko> Maybe it used to be great like 10 years ago.
00:21:53 <juhp> heh
00:22:04 <kzm> juhp, beats me.  You get all the disadvantages of UTF8, combined with half the space penalty of UCS4.
00:22:13 <juhp> lol
00:22:14 <juhp> nod
00:22:17 <kzm> I found it unconvincing, but maybe I missed something.
00:22:24 * juhp likes utf-8 :)
00:22:39 <sjanssen> kzm: yeah, I found that article fishy as well
00:22:44 <Lemmih> juhp: I don't know but Simon Marlow does.
00:23:20 <eivuokko> kzm, It probably had pretty good performance vs usability because Microsoft picked it and went lots of trouble supporting it.
00:23:24 <kzm> juhp, well - feel free to help the people implementing it.
00:23:39 <juhp> kzm: I don't think you did - it must be good for 16bit archs though ;o)
00:23:42 <sjanssen> it relies on "most data is in the BMP", whereas I think most data is in the first hundred or so codepoints
00:23:57 <kzm> I think it's a relic from when all of Unicode was 16 bits.
00:24:00 <kzm> I.e. UCS2
00:24:30 <kzm> sjanssen, but as soon as you ask for character number 1e10, you must traverse everything.
00:24:51 <kzm> the curse of UTF!
00:24:55 <juhp> kzm: why are you worrying about it? :)
00:25:08 <kzm> what, me worry?
00:25:10 <juhp> Lemmih: ok - I'll ask him.  thanks
00:25:30 <juhp> kzm: ok, asking then? :)
00:25:31 <sjanssen> kzm: not necessarily.  I got an idea from John Meacham on the mailing list: if you know that the string is valid, and that the number of bytes equals the number of characters, you can just add 1e10 to the pointer
00:26:04 <kzm> I think it may be good to store the character length, in addtion to the byte length in the string.
00:26:25 <kzm> so instead of newtype, do data UTF8 = UPS ByteString Int
00:26:46 <sjanssen> yeah, I glossed over that earlier
00:26:48 <kzm> Or even use the lazy byte string by...whom? dons?
00:27:13 <kzm> Then you can do stuff in O(blocks) instead of O(chars).
00:28:18 <kzm> I think norpan was getting good UTF8 performance now, but I'm not sure he had worked out all the kinks.
00:28:20 <kzm> @seen norpan 
00:28:20 <lambdabot> norpan is in #haskell-overflow and #haskell. I don't know when norpan last spoke.
00:29:04 <kzm> Lazy bytestring is (of course) by dcoutts.
00:29:55 <sjanssen> kzm: does the code exist, or are you just referring to discussion from a day or so ago?
00:48:15 <kzm> sjanssen, I've collected everything in my fps repo.
00:48:28 <kzm> http://www.ii.uib.no/~ketil/src/fps-i18n
00:48:34 <kzm> This includes:
00:48:59 <kzm>  - dons's original fps with Char8
00:49:16 <kzm>  - my single byte encodings (Latin1, KOI8R, Win1252, etc)
00:49:50 <kzm>  - dcoutts's lazy byte string (uncertain of the state of this, may be work in progress)
00:49:56 <dcoutts> kzm, :-)
00:50:23 <kzm>  - norpan's UTF8 in an early form, I know he's working on rewriting it based on Simon M's UTF8 code.
00:50:44 <kzm> dcoutts, Ah, you are here.  Perhaps you'll care to elaborate?
00:51:33 <dcoutts> it's supposed to be like ByteString but for large strings you don't have to keep the whole string in memory at once
00:51:40 <dcoutts> if you can process it linearly
00:51:59 <dons> 'but for large strings' dcoutts thinks 1G is too small.
00:52:06 <dcoutts> :-)
00:52:17 <dons> not needing it in memory is the big plus
00:52:38 <dcoutts> yeah, so you can get streaming style applications which use constant memory
00:52:43 <kzm> dons, of course, it's not only about the raw buffer, but also about stateful performance.
00:52:50 <kzm> (i.e. UTF8)
00:52:53 <dcoutts> and yet written in a high level beautiful style
00:53:10 <dcoutts> I reckon we should be able to do list & array fusion
00:53:17 <dons> right. for those large multi-gigabyte filter-style projects.
00:53:24 <dcoutts> and get some really effecient wc -l programs :-)
00:53:25 <kzm> And 1Gb of UTF8 is 4Gb UCS4.
00:53:30 <dons> hehe
00:53:43 <kzm> dons, and don't sneer - I'd love to be able to handle multi-gigabyte files directly.
00:53:46 <dons> kzm, ah, interesting.
00:53:59 <eivuokko> I'd love that too
00:53:59 <dons> i'm not. i really do think we need to be able to handle multi-gig stuff
00:54:10 <dons> and we still can't quite without faking ByteString.Lazy anyway
00:54:10 <kzm> but, oh, I forgot.  You just don't /care/ about bioinformatics.  <sniff>
00:54:17 <kzm> :-)
00:54:25 <kzm> Here's what I'd like to do:
00:54:30 <dons> hey. i've written a few fasta benchmarks and things like that :)
00:54:45 <dcoutts> and the great things is that it builds directly on ByteString so we get all the performance benifits as that gets optimised too
00:54:48 <dons> i appreciate the huge data quantities. we need more work in that area.
00:54:55 <kzm> sequences typically come in FASTA format.  That means a header ">foo bar zot?a sdfnq \n"
00:55:13 <dcoutts> so we combine two of the most heavily optimised structures in Haskell, [] & ByteString
00:55:17 <kzm> and a set of lines, arbitrarily broken up, containing the sequence alphabet.
00:55:51 <dons> dcoutts: yes. we need to do this.
00:56:01 <kzm> Now: I could mmap the whole file, and extract the sequence data, each sequence being a "lazy" list of blocks slicing out one line.
00:56:12 <dcoutts> dons, I need help with the unfoldr :-)
00:56:13 <dons> or use hGetLine
00:56:19 <dcoutts> and a review of the folds
00:56:29 <dons> ok. let me finish this SoC grading first..
00:56:37 <dcoutts> of course
00:56:56 * dcoutts reviewd all of them yesterday and then was exhausted :-)
00:56:57 <kzm> dons, no, no hGetLine.  I will want to deal with each sequence as a single string.
00:57:32 <kzm> If a string is [BS], that is easier.
00:57:41 <dcoutts> kzm, I don't believe in really cunning representations for UTF8, just make people convert to UCS4 if they want indexing
00:57:55 <kzm> dcoutts, I tend to agree.
00:58:19 <dcoutts> so I wouldn't split on sequences of 1byte vs sequences of 2byte+
00:58:31 <kzm> dcoutts, however: if people in Asia uses UTF8 with all characters having the same byteness, it could make sense to optimize for that case.
00:58:40 <dcoutts> to try and gain better indexing, I just don't think it's worth it
00:58:55 <dcoutts> kzm, how so?
00:59:33 <kzm> dcoutts, I haven't checked.  But, assume all chinese characters take three bytes in UTF8.  That makes it - in practice - a fixed width encoding, which is fast/easy/etc etc.
00:59:44 <dcoutts> hmm
01:00:09 <kzm> So, if you can tag each block with char widths, operations can be made really fast -- until you come to a "mixed" block.
01:00:17 <kzm> Ditto for ASCII only, of course.
01:00:39 <dcoutts> I doubt that the extra complexity is worth it
01:00:59 <kzm> This could even be a lazy parameter, I presume, so that when somebody runs "length" or any other operation that will traverse the entire block, the parameter gets set.
01:01:14 <kzm> Well - it is an idea, anyway.
01:01:21 <dcoutts> sure
01:02:03 <kzm> 1G chars will be 3Gbytes of UTF8, which must be copied into 4Gb of UCS4 - so there is a lot to be saved - in theory at least.
01:02:13 <kzm> but I agree: basic things first.
01:02:45 <dcoutts> it depends on how much the chunking overhead adds
01:03:23 <kzm> Yep.
01:03:47 <kzm> And if there actually will be large strings in UTF8 with fixed widths.
01:04:31 * kzm wonders if we should start a #haskell-fps channel :-)
01:10:04 <kzm> One naive question here: why is there no UCS3?
01:10:13 <kzm> If Unicode is 21 bits anyway?
01:10:30 <dcoutts> true
01:10:50 <dcoutts> I guess because it'd give lots of unaligned reads?
01:11:33 <dcoutts> computers support reading/writing 1,2,4,8 bytes
01:11:34 <kzm> But 25% space gain - I think current CPUs do the necessary shifting and masking faster than IO to RAM anyway.
01:12:11 <kzm> Another interesting thing: I haven't found any collection of smart UTF8 processing algorithms anywhere.  Should I ask around?
01:12:26 <dcoutts> the ICU lib
01:12:38 <kzm> ICU?
01:12:52 <dcoutts> it's an open source IBM project, International Components for Unicode
01:13:05 <dcoutts> it's used by quite a few other projects
01:13:44 <kzm> Yeah, google found it for me.  I didn't think you meant the International Christian University, even though their web page *is* full of unicode characters :-)
01:15:27 <dcoutts> kzm, hah hah
01:22:38 <dons> eivuokko: thanks for the patch
01:23:57 <ADEpt> dons: i sent the summary table
01:52:15 <musasabi> a/c
01:53:17 <Lemmih> d/c
01:53:24 <JKnecht> cc
01:55:02 <shapr> triphase power W00!
01:55:46 <xerox> shapr: stop behaving like Razor Ramon HG please :-P
01:55:53 <shapr> Who?
01:56:02 <xerox> @wikipedia Hard Gay
01:56:04 <lambdabot> No Result Found.
01:56:23 <xerox> (He's funny, I'm kidding, let me find an url...)
01:57:15 <xerox> http://www.videouncovered.com/adds/play_page.php?id=585&id_char=bakuten
02:01:30 <kzm> bah.  crashed firefox.
02:02:04 <xerox> Japanese humor is strange (-:
02:03:39 <JKnecht> wieso?
02:11:35 <boegel> what's up with the screaming :)
02:17:13 <JKnecht> Frights: 0 Delights: 1
02:20:28 <neologism> any native english speaker here?
02:20:57 <JKnecht> yes.
02:24:11 <shapr> me!
02:25:11 <ADEpt> shapr: do you want to be the sole mentor for haskell net or do you need a hand?
02:25:48 <dcoutts> ADEpt, you wouldn't happen to have Gnumeric installed would you?
02:26:04 <ADEpt> dcoutts: nope
02:26:09 <dcoutts> never mind
02:26:20 <ADEpt> dcoutts: but I could make ods->xls for you
02:26:30 <dcoutts> that'd do
02:26:39 <dcoutts> Gnumeeric can read .xls
02:26:51 <JKnecht> has 0.7.
02:27:15 <JKnecht> s/0.67/
02:27:49 <shapr> ADEpt: I don't think Haskellnet will be difficult, but I'm always happy to have a backup mentor :-)
02:28:01 <ADEpt> dcoutts: sent
02:28:07 <dcoutts> ADEpt, thanks!
02:28:15 <xerox> Haskellnet++
02:28:31 <ADEpt> shapr: ok, you know where to find me :)
02:30:05 <shapr> Ok, I'll put in a comment explicitly saying that you're the backup mentor.
02:43:38 <musasabi> Haskell net will have lots of social aspects trying to get an API spec that people are happy with.
02:51:18 <dons> that's probably the most difficult part -- dealing with smart people who think your api is all wrong :)   
02:54:10 <musasabi> yes, the reason why we have 5+ definitions of HTTP and SMTP in Haskell
02:54:52 <musasabi> Getting definitions that various people are actually willing to use is the most difficult path.
02:58:07 <norpan> this is not unique for haskell
02:58:18 <norpan> and why should we settle for one api
03:00:31 <pjd> the profusion of solutions is a symptom of the complexity of the problem space
03:01:02 <pjd> (compare Python's web frameworks)
03:01:29 <kzm> Personally, I'd rather have one API that is slightly suboptimal, than n APIs, with one optimal
03:01:49 <kzm> Getting an overview of which API to use quickly becomes half the job.
03:02:43 <kzm> Incidentally, I think the killer feature of Ubuntu over Debian is that they have a selection of 'supported' applications.
03:03:14 <kzm> So you get an indication what they think works well, and you don't have to experiment with 26 different MTAs.
03:05:46 <norpan> it all depends on what slightly subotimal is
03:06:16 <norpan> if you have a lot to choose from, then someone more informed can make the best choice for you and you will end up with the optimal
03:06:40 <musasabi> pjd: but we mostly disagree about things like "should HTTP response code be" "Int", "(Int,Int,Int)" "data ResponseCode = ..." or "newtype RCode = RCode Int" ;)
03:07:00 <eivuokko> Uhhuh.
03:14:59 <ADEpt> i think that we have 5+ implementations of HTTP/SMTP simply because: 1)there is none in default ghc/hugh distribution; 2)absolute minimum is easy to code
03:15:28 <ADEpt> so probably it would be enough to provide absolute minimum, but make it extensible without the need to "fork" entire codebase
03:16:16 <dcoutts> I also quite like the simple vs full interface style
03:16:29 <dcoutts> ie a wrapper module that provides a really simple API
03:16:47 <dcoutts> eg "send this email!" or "get that http page!"
03:17:27 <dcoutts> then the people who care about user agent strings and http caching & return codes can use the full api
03:19:50 <musasabi> ADEpt: actually e.g. Network.HTTP is the most inadequate of them I think ;)
03:21:18 <ADEpt> musasabi: yep. unfortunately.
03:32:11 <shapr> This sounds like a good chance for me (or the hazakura author) to be a dictator and come up with an API we can use, and then tell others to write their own wrapper if they don't like it. or "patches accepted when project is over"
03:37:53 <dcoutts> shapr for dictator!
03:38:42 <xerox> Wii!
03:47:26 <musasabi> shapr: the problem is that given some definition writing a wrapper may be impossible,
03:48:02 <Itkovian> BCoppens: sorry, didn't see your message yesterday.
03:48:07 <musasabi> i.e. if I need to store flags with the response then using a response type with no space for flags does not really work.
03:48:40 <shapr> In that case, 'patches accepted'
03:49:18 <musasabi> just with a suitable amount of meditating you can ask people what they require and make it generic enough
03:50:48 <musasabi> e.g. my http output routine calculates the length of the response body and adds it to the headers. But I cannot live without a flag saying "don't calculate it because this is a streaming response instead of a complete one"
03:52:18 <musasabi> But e.g. HSP has no such need and is living happily without any flags in HTTP.
04:53:44 <roconnor> IS Control.Monad.Cont.Cont implemented in pure Haskell, or does it have a special optimized implemenation?
04:58:56 <roconnor> Hmm, wrong time of day for questions about continuations.
04:59:40 <norpan> i see no reason why it wouldn't be pure haskell
04:59:45 <eivuokko> It is pure haskell
04:59:57 <eivuokko> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
05:00:30 <roconnor> thanks!
05:00:43 <roconnor> @karma+ eivuokko
05:00:44 <lambdabot> eivuokko's karma raised to 1.
05:01:00 <xerox> @fptools Control.Monad.Cont
05:01:00 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
05:01:06 <norpan> the api doc wouldn't tell you that much about the implementation though
05:01:10 <xerox> @karma+ lambdabot -- !
05:01:10 <lambdabot> lambdabot's karma raised to 12.
05:01:34 <eivuokko> Those are not links to api docs, but the current implementation in darcs head
05:01:40 <roconnor> what's fptools?
05:01:49 <eivuokko> Old name when everything was in one cvs
05:01:59 <norpan> ah i see
05:09:50 <kzm_> I'm don't seem to receive mail to the soc-mentors list!
05:10:19 <kzm_> Chances are it's our mail server - who holds the power to change my subscription address?
05:10:25 <ADEpt> kzm_: ask SyntaxPolice
05:11:40 <kzm_> ADEpt, nick? email?
05:14:56 <ADEpt> kzm_: got msg?
05:19:44 <dons> yeah, the dual path of developing a library, and writing applications that use it, is almsot critical i think
05:20:18 <dons> too many libs have been written without applications that use them (sometimes I wonder that about Data.Graph.Inductive :)
05:20:43 <dcoutts> heh
05:20:48 * dcoutts uses Data.Graph.Inductive
05:20:53 * dcoutts also curses Data.Graph.Inductive
05:21:23 <dons> me too, for the icfp contest, but it took a while to work out all the crazy nutiness with the api. and we ended up writing a wrapper anyway :}
05:21:25 <kosmikus> I also use Data.Graph.Inductive
05:21:44 <dcoutts> yes, every time I've used it I've needed a wrapper
05:21:45 <dons> its a very nice library.
05:22:05 <dcoutts> hmm, how do I find a node given its label
05:22:15 <dcoutts> answer you can't unless you keep a seperate mapping
05:22:20 <dcoutts> doh!
05:22:21 <kosmikus> dcoutts: heh
05:22:43 <dons> +2 on the SoC graph library submission then :)
05:23:04 <dcoutts> aye
05:23:05 <good_boy> anyone knows how can I retrieve the int value of an ASCII Channel? map Char.ord is supposed to work but it doesnt...
05:23:13 <good_boy> ASCII Character*
05:23:15 <good_boy> :D
05:23:24 <dons> > ord 'x'
05:23:24 <lambdabot> 120
05:23:28 <dcoutts> Char.ord should be fine
05:23:35 <mauke> > fromEnum 'x'
05:23:36 <lambdabot> 120
05:23:38 <dons> > map ord "haskell"
05:23:39 <lambdabot> [104,97,115,107,101,108,108]
05:24:00 <good_boy> hm
05:25:17 <kosmikus> is the SoC project completely different from Inductive, or does it build upon Inductive?
05:25:46 <dcoutts> kosmikus, it's not clear
05:25:55 <good_boy> I do it like this and it doesnt work : chartoint :: String -> [Int]
05:25:57 <good_boy> chartoint a = map Char.ord a
05:26:00 <dcoutts> kosmikus, he talks about porting Boost stuff
05:26:29 <kosmikus> dcoutts: oh, hmm
05:26:30 <dcoutts> @type \a -> map Char.ord a
05:26:32 <lambdabot> [Char] -> [Int]
05:26:51 <dcoutts> good_boy, you've got the right type there
05:27:04 <good_boy> yes...
05:27:11 <norpan> good_boy: in what way doesn't it work
05:27:32 <dcoutts> > let chartoint a = map Char.ord a
05:27:32 <dcoutts>  in chartoint "hello"
05:27:33 <lambdabot>  parse error on input `}'
05:27:40 <dcoutts> > let chartoint a = map Char.ord a in chartoint "hello"
05:27:41 <lambdabot> [104,101,108,108,111]
05:27:58 <good_boy> i get a "Undefined qualified  variable Char.ord" error
05:28:06 <norpan> you must import Char
05:28:10 <dcoutts> good_boy, did you import Char?
05:28:13 <good_boy> no
05:28:24 <good_boy> import Char(ord, chr) ?
05:28:27 <dcoutts> yep
05:28:32 <norpan> or use fromEnum
05:29:36 <xerox> > let sieve (x:xs) = [y | y <- xs, y `mod` x /= 0] in (sum $ "Haskell" >>= show . ord >>= show . ord >>= show . ord >>= return . ord) `elem` (sieve [2..])
05:29:37 <lambdabot> True
05:30:13 <dcoutts> @pl let sieve (x:xs) = [y | y <- xs, y `mod` x /= 0] in (sum $ "Haskell" >>= show . ord >>= show . ord >>= show . ord >>= return . ord) `elem` (sieve [2..])
05:30:15 <lambdabot> sum (ord `fmap` ("Haskell" >>= show . ord >>= show . ord >>= show . ord)) `elem` [y | y <- tail [2..], y `mod` head [2..] /= 0]
05:30:16 <norpan> wow, haskell prime
05:30:53 <xerox> <grin>
05:32:20 <good_boy> can someone show me from the beginning to the end how should i do this? im new in haskell.
05:32:33 <xerox> "this" being what?
05:32:34 <ADEpt> dcoutts: about SoC graph submission: from the application it seems that applicant just wants to provide FFI bindings to Boost graph library
05:32:54 <dcoutts> ADEpt, I thought he wanted to port bits of it.
05:32:56 <ADEpt> dcoutts: and I am not sure that this would be such a wonderfull thing to do
05:32:58 <good_boy> this getting the ASCII value of a character
05:33:01 * dcoutts re-reads it..
05:33:12 <xerox> good_boy: apply 'ord' to a Char value
05:33:14 <eivuokko> Adeptm Oh, that'd be cool port...imo
05:33:16 <norpan> good_boy: put "import Char" at the top of oyour file
05:33:42 <good_boy> and then just apply ord to a char value?
05:33:52 <norpan> yes
05:33:57 <musasabi_> ADEpt: isn't that going to be potentially painfull? Many parts of boost use templates extensively...
05:34:06 <ADEpt> dcoutts: quote: "One path to the implementation ....would be a port from Boost Graph Library to Haskell, in such a way that any improvements made by the large C++ community could be used by the Haskell community. This would require interfacing with C++ code, which is possible by first porting it to C, and then using the FFI"
05:34:22 <dcoutts> hmm
05:34:25 <ADEpt> dcoutts: and another: "Another path would be to implement everything from scratch while very carefully monitoring any potential slow code. I don't think this is a very successful path, though."
05:34:40 <dcoutts> he's probably righ of course :-)
05:34:57 <eivuokko> musasabi, I think there's already python bindings, so probably there's okeish wya to do it with haskell as well.
05:34:59 <musasabi_> And probably knows more of Boost graph library than we do.
05:35:05 <musasabi_> eivuokko: ok
05:35:38 <eivuokko> Boost.graph is way easy to use.  I'm no graph expert but things I used it for were way easy.
05:35:48 <eivuokko> I can't say how good lib it is imo :)
05:36:06 <eivuokko> *don't know how to say
05:37:18 <good_boy> here is my code and the error message i get: http://pastebin.com/709266
05:37:19 <norpan> "The Boost Graph Library is a header-only library and does not need to be built to be used."
05:37:21 <ADEpt> dcoutts: but that would actually mean that all graph-manipulation code would be bound to IO, which kind of undermines the whole idea... Plus (de)marshalling of data would probably eat all speed increase.
05:37:42 <norpan> good_boy: yes you need to map ord a
05:37:53 <dcoutts> mmm, yeah, it's not obvious which way to go
05:37:57 <norpan> because ord works on a Char and you have a [Char]
05:38:17 <dcoutts> ADEpt, for some long running graph ops I'm sure the C++ ones beat us hands down
05:38:35 <dcoutts> but it'd be nice to extend the existing imperitive Data.Graph one
05:38:44 <good_boy> oh it works
05:38:46 <good_boy> thanks
05:38:51 <dcoutts> which currently runs in ST monad, so is imperitive & quite quick I think
05:39:02 <dcoutts> but has a small set of operations
05:39:22 <dcoutts> it'd be nice to extend that one and tune its performance
05:39:34 <ADEpt> dcoutts: could be. but remember the "language shootout" - when there's a need, there is a way. I am sure there is a lot which could be done to speed-up D.Gr.Inductive. And it's code nicely small to comprehend.
05:40:04 <dcoutts> well D.Gr.Inductive does make many things hard simply because of its representation
05:40:11 <dcoutts> many ops are O(log n)
05:40:21 <dcoutts> because of the lack of mutable state
05:40:49 <dcoutts> where as D.Gr can do those things in the normal O() times because it's in ST
05:40:54 <ADEpt> and it's quite easy to fix, IMO
05:41:09 <dcoutts> really? and keep the functional API?
05:41:14 <dcoutts> I'd be very suprised
05:41:52 <dcoutts> I think D.Gr.Inductive could be made much nicer and easier to use, but I doubt we could make it O(1)
05:41:53 <ADEpt> dcoutts: sorry, wrong choice of words. I meant to say this:
05:42:11 <ADEpt> dcoutts: yes. exactly.
05:43:08 <dcoutts> So I'd be happy with either: 1. makeing Data.Graph.Inductive easier to use, or 2. extending Data.Graph to a reasonable range of algorithms & nicer api while keeping it fast.
05:43:33 <dcoutts> and this chap is more likely to be able to do 2.
05:44:00 <dcoutts> but he might like to make a huge and hard to use imparitive lib with excelent performance
05:44:07 <dcoutts> which it's not clear that we want
05:44:24 <dcoutts> we should probably talk to him
05:44:27 <ADEpt> dcoutts: Sometimes "reasonably fast" is fast enough. I remember how for icfp2005 people used boost to compute all shortest-path matrix on graph with 357 nodes (floyd-warshall algo) and complained that program startup become too heavy to fit in required 5 sec. OTOH, FiniteMap of (node1,node2) -> dijcstra's shortest path, which were lazily evaluted, provided no visible slowdown at all.
05:45:35 <ADEpt> dcoutts: seems like dons took mentorship of this one.
05:45:40 <dcoutts> ADEpt, I agree
05:45:41 <ADEpt> @seen dons
05:45:41 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 22 minutes and 2 seconds ago.
05:46:05 <ADEpt> dons: here?
05:46:48 <musasabi_> A Zipper like interface to graphs would be nice.
05:49:53 * ADEpt looked at boost and found, like,  three algorithms that are missing from D.G.I
05:50:50 <dcoutts> ADEpt, dons has gone to be I think
05:50:54 <dcoutts> @localtime dons
05:50:56 <lambdabot> Local time for dons is Wed May 10 22:46:56 2006
05:51:45 <RyanT5000> what office document format should I use for haskell development?
05:51:52 <ADEpt> ah. probably, asleep
05:51:52 <RyanT5000> docs, that is
05:51:57 <RyanT5000> not source code docs
05:52:18 <RyanT5000> odf?
05:53:35 <norpan> text?
05:53:43 <RyanT5000> well i'd like to be able to have some formatting
05:53:56 <RyanT5000> i could write in latex
05:54:39 <norpan> what does ghc use?
05:54:52 <RyanT5000> i have no idea
05:54:53 <RyanT5000> html?
05:55:15 <RyanT5000> they must use something for the manual though
05:55:39 <RyanT5000> http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/
05:55:56 <RyanT5000> i'd be totally fine producing something like that
05:56:10 <RyanT5000> does anyone know what tool that was made in?
05:56:20 <musasabi_> RyanT5000: GHC uses docbook (XML) I think.
05:56:33 <musasabi_> RyanT5000: either that or latex depending on the need.
05:56:47 <RyanT5000> alright, i see a meta generator tag saying DocBook
05:58:23 <ADEpt> dcoutts: i loot at Data.Graph.Inductive.Query.Monad and it seems like it could alleviate some of the problems
05:58:42 <dcoutts> ADEpt, but doesn't it put everything in a monad?
05:59:01 <kzm_> sorry to barge in like this, but I see you're talking about D.G.Inductive here.
05:59:36 <dcoutts> kzm, aye
05:59:41 <kzm_> Is there a project application to revise it or develop it further?
05:59:46 <kzm_> I'm using it.
05:59:56 <dcoutts> kzm, well it's less specific than that
05:59:58 <kzm_> For the prototype for my project.
06:00:01 <kzm_> Honestly.
06:00:09 <ADEpt> kzm_: aha. what's your biggest complains?
06:00:16 <dcoutts> the chap wants to make a high performance graph lib
06:00:19 <kzm_> None yet.  We'll see how it scales.
06:00:27 <dcoutts> by eithe binding or porting C++ code
06:00:34 <kzm_> Which chap?  Link?
06:00:47 <dcoutts> ADEpt, the nice thing about Data.Graph is that it does have a pure api. no monads.
06:01:14 <kzm_> Well - I suppose one complaint is that it wasn't particularly easier to use it than the ad hoc heap of Map/Set that I used previously :-)
06:01:16 <dcoutts> and yet has the sam big-O bounds as imperitive libs (becaus underneath it is impritive)
06:01:28 <dcoutts> but since it's in ST we can hide that
06:01:44 <dcoutts> kzm_, yeah, that's my complaint too
06:02:13 <ADEpt> kzm_: http://code.google.com/soc/haskell/app.html?csaid=iampure@gmail.com:10da91b3:ec4ff42a
06:02:13 <kzm_> I haven't used it extensively, mind, so I guess if you need graph algorithms, you get them cheaper by using the lib.
06:02:57 <kzm_> I'm on it! Thanks!  (Where /do/ they get those horrible templates?)
06:06:39 <roconnor> \join texmacs
06:09:22 <shapr> dcoutts: I'd be happiest with a better interface to Data.Graph.Inductive, but I won't argue if the majority prefers a binding to a fast imperative lib.
06:09:41 <dcoutts> shapr, I don't want a binding either especially
06:10:15 <dcoutts> shapr, but I think there are two nice possabilities and this student is probably more inclined to go for the high performance one
06:10:33 <dcoutts> shapr, that is either: 1 make Data.Graph.Inductive nice, or 2. make Data.Graph bigger
06:10:48 <shapr> I'd vote for the nice interface to Inductive.
06:11:04 <dcoutts> shapr, and this chap would probably prefer to do 2 by porting (not binding) C++ code to the Data.Graph ST style
06:11:12 <dcoutts> that still gives us a pure graph api
06:11:24 <shapr> We could ask Erwig if he knows of some ways to make Inductive faster?
06:11:31 <RyanT5000> how would I go about making a datastructure that contains a function be serializable?
06:11:37 <dcoutts> I think it'd be pushing him too far to ask him to work on .Inductive
06:11:49 <shapr> Sure, but maybe he could give us some free advice?
06:11:52 <dcoutts> it's too alien if he works on basically imperitive graphs
06:11:56 <shapr> Oh, you mean the student?
06:11:59 <dcoutts> right
06:11:59 <shapr> Ah, I see.
06:12:33 <dcoutts> he was thinking of picking between binding C++ or porting C++, not between O(1) & O(log) graph systems
06:12:54 <kzm_> I'
06:13:00 * kzm_ swears.
06:13:08 <dcoutts> so if we don't want a binding then we should ask him to port C++ style graph code to the imperitive Data.Graph ST framework
06:13:18 <shapr> Yeah, I see.
06:13:40 <kzm_> 've added a comment.  Another thing I'd really like to see is a GUI front end to the graph, sort of Model-View-Controller style.
06:14:17 <RyanT5000> do you mean a graph viewer?
06:14:33 <kzm_> Yes, with feedback.
06:14:59 <RyanT5000> feedback? meaning you can also edit the graphs?
06:15:07 <kzm_> I want to run a flow in the graph, view the result, add some sinks/sources, adjust weights, and reiterate.
06:15:10 <shapr> Doesn't blobs do that?
06:15:22 <kzm_> maybe.  I'm just looking at that now.
06:16:31 <RyanT5000> is there any way of making a function serializable? e.g.: in the expression that creates it, tag it with an ID that also corresponds to an Exp?
06:16:46 <RyanT5000> (Language.Haskell.TH.Exp)
06:17:09 <ADEpt> dcoutts: i believe that the word "porting" in application does not have it's usual sense
06:17:16 <dcoutts> ADEpt, yes
06:17:52 <dcoutts> ADEpt, he does suggest two alternatives though. He thinks the binding would be better but we could ask him to do some porting instead.
06:18:14 <dcoutts> as I say, we should talk to him
06:22:26 <ADEpt> dcoutts: his icq is offline now, I set up a trap on him :)
06:22:33 <dcoutts> heh
06:23:58 <ADEpt> does anyone remember how manu proposals were for the SoC 2005?
06:24:09 <psi> 8000 I think.
06:24:30 <RyanT5000> does anyone know how many haskell.org got this time around?
06:25:08 <ADEpt> psi: for the haskell community, i mean
06:25:15 <psi> 117, or something in that region
06:25:34 <dcoutts> last year it was 1, or maybe 2
06:25:41 <psi> last year haskell.org weren't officially a mentor org.
06:26:09 <dcoutts> yeah, xerox's mentor org was google itself
06:27:19 <ADEpt> RyanT5000: 112
06:27:36 <dcoutts> there are also a few marked ineligible
06:27:37 <RyanT5000> k
06:28:22 <dcoutts> so total applications was 120
06:28:29 <dcoutts> but one or two of those were duplicates
06:28:45 <dcoutts> duplicates or re-submissions
06:31:10 <ADEpt> dcoutts: there are still several dupes, it seems
06:31:38 <dcoutts> I tried to eliminate dups that I noticed
06:31:59 <ADEpt> dcoutts: aha. then I probably wrong
06:32:11 <dcoutts> not necesarily
06:32:31 <ADEpt> dcoutts: there were 6 dupes in total. How many you elliminated? :)
06:32:31 <dcoutts> there may be dups we didn't notice
06:32:42 <dcoutts> see the ineligable list
06:33:37 <dcoutts> seems I marked 2 dups
06:34:07 <psi> I don't know if you can talk about this, but is anyone interested in my application?
06:34:32 <dcoutts> which one is that?
06:34:38 <ValarQ> psi: what app?
06:34:59 <dcoutts> probably should though :-)
06:35:02 <psi> dcoutts: titled "GStreamer bindings for Haskell"
06:35:08 <dcoutts> should/shouldn't I mean
06:35:17 <psi> ok :-)
06:35:22 <dcoutts> psi, we've got 3 applications for that
06:35:31 <ADEpt> dcoutts: seems like that 6 dupes that were there in the morning are still there. If you've seen my pivot table, filter it for cells that are ">=1". Those are duplicate applications.
06:35:35 <psi> 3, oh.
06:35:41 * ValarQ would be interested in using GStreamer in his eggclock app
06:35:49 <dcoutts> I've got to decide between them, which is tricky because people have applied for several projects
06:36:11 <psi> That's the only app I've sent it.
06:36:12 <dcoutts> eg people have applied for GStreamer + several other things
06:36:30 <psi> ValarQ: just wait ;)
06:37:28 <RyanT5000> any idea when ranking will be done?
06:38:03 <dcoutts> we're still doing it
06:38:12 <dcoutts> dunno really
06:38:29 <dcoutts> it'll be done by the 22nd of course, that's our deadline
06:38:34 <RyanT5000> right
06:38:50 <ValarQ> psi: sounds promising :)
06:39:02 <RyanT5000> i'm quite apprehensive :)
06:39:48 <dcoutts> psi, I don't see your application. "G. Baltar" right?
06:40:23 <psi> dcoutts: Simon Sandlund. Haha, Gaius Baltar is a character from Battlestar Galactica ;)
06:40:28 <dcoutts> ah ok
06:40:41 <dcoutts> ok, yep got it
06:51:41 <ADEpt> der_eq: check out your jabber messages ;)
06:53:19 <der_eq> ADEpt: done :)
06:56:25 <vincenz> dcoutts: ping
06:56:34 <dcoutts> vincenz, pong
06:56:45 <vincenz> dcoutts: how does one work with menus created in glade?
06:57:39 <dcoutts> get a reference to them and attach signal handlers, just like everything else
06:57:44 <vincenz> hmm
06:57:44 <vincenz> k
06:57:53 <vincenz> so what's all this on_xxx_stuff 
06:58:01 <dcoutts> ignore it
06:58:11 <dcoutts> it's a C signals auto-connect thingy
06:58:32 <vincenz> ah, alrigt
06:58:39 <psi> heh, looking over the trac wiki, I see that I'm signed up as in interested student for ticket 73. I know for sure I haven't signed that :)
06:59:02 <dcoutts> heh
06:59:07 <dcoutts> doesn't matter now
06:59:17 <psi> yeah, weird though
07:13:36 <SamB> psi: well, did you put yourself down for some other ticket on the People page?
07:13:53 <SamB> maybe someone got mixed up transferring that to the tickets?
07:13:57 <petekaz> If I had a list of pairs, [(1,'a'), (1,'b'), (2,'a')], what is the easiest way to return only unique elements where unique is defined as the snd element?
07:14:08 <petekaz> Is there a one-liner for this?
07:14:37 <SamB> petekaz: what do you want to do with the first element?
07:14:42 <xerox> petekaz: nubSnd = let swap = (snd *** fst) in map swap . nub . map swap
07:15:01 <good_boy> i have a list of tupels, [(Char, Int)]. Is there any way to sort it in decreasing order of int using for example List.sortBy ?
07:15:23 <xerox> good_boy: ordering by Chars or Ints?
07:15:24 <petekaz> xerox: that's going to take a bit to digest ...
07:15:31 <SamB> good_boy: sure
07:15:42 <good_boy> SamB: how?
07:15:42 <SamB> @type List.sortBy
07:15:44 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:15:46 <xerox> petekaz: sorry, &&&.
07:15:58 <xerox> petekaz: that is swap = (snd &&& fst).
07:16:02 <petekaz> ok.
07:16:24 <SamB> hmm
07:16:25 <petekaz> what the heck is nub?
07:16:26 <xerox> petekaz: instance Arrow (->) where ... (f &&& g) x = (f x,g x) ...ù
07:16:37 <SamB> good_boy: well, the decreasing order part could be tricky!
07:16:48 <SamB> or just ugly
07:16:50 <good_boy> hm
07:16:52 <xerox> petekaz: nub is in Data.List, it does return the unique elements in a list.
07:16:58 <SamB> @hoogle Ordering -> Ordering
07:16:59 <lambdabot> No matches, try a more general search
07:17:09 <xerox> petekaz: mumble.  I think mine is wrong, let me think...
07:17:33 <good_boy> well, it doesnt matter... it could be either increasing or decreasing but i thought it would be cuter if the list was sorted in decreasing order of int
07:17:33 <SamB> oh, actually...
07:18:05 <SamB> actually, I just realized it doesn't make much difference since you can just swap the args to compare...
07:18:54 <SamB> > sortBy (\x y -> compare (snd y) (snd x)) [(1,'a'), (1,'b'), (2,'a')]
07:18:56 <lambdabot> [(1,'b'),(1,'a'),(2,'a')]
07:19:14 <SamB> and yes, I realize you had the ints and chars the other way round ;-)
07:19:21 <good_boy> yes ^^
07:19:24 <SamB> I just grabbed a list that was handy ;-)
07:19:33 <petekaz> :-)
07:19:38 <SamB> won't matter a bit
07:20:54 * SamB wonders if it would be nice to have a compare variant that took a tuple instead of two args
07:21:17 * SamB thinks it would be nice to have a function that reversed an Ordering
07:21:38 <petekaz> > nubBy (\x y -> snd x == snd y) [(1,'b'),(1,'a'),(2,'a')]
07:21:39 <lambdabot> [(1,'b'),(1,'a')]
07:21:43 <petekaz> yay!
07:22:04 <xerox> Gotcha
07:22:04 <xerox> > map head . groupBy (\(x,_) (y,_) -> x == y) . sort . map (snd &&& fst) $ [(1,'a'),(2,'b'),(3,'a'),(4,'c')]
07:22:05 <lambdabot> [('a',1),('b',2),('c',4)]
07:22:11 <xerox> Ah, nubBy, heavy!
07:22:29 <xerox> @karma+ petekaz 
07:22:29 <lambdabot> petekaz's karma raised to 1.
07:22:45 <SamB> that is some un-pretty code, xerox!
07:22:48 <dcoutts> SamB, how about: (uncurry compare)
07:22:52 <xerox> Sorry SamB.
07:22:59 <SamB> dcoutts: you have a point there
07:23:02 <petekaz> Is there a more haskell like way to use function compostion to make my lambda go away?
07:23:16 <SamB> let me see...
07:23:20 <dcoutts> petekaz, often there is, yes.
07:23:35 <shapr> @pl (\(x,_) (y,_) -> x == y) . sort . map (snd &&& fst)
07:23:36 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst . sort . map (snd &&& fst)
07:23:39 <shapr> hmm
07:23:51 <dcoutts> xerox, map head . groupBy (comparing fst) . sort .... etc
07:23:58 <hyrax42> @index nubBy
07:23:59 <lambdabot> Data.List
07:24:11 <dcoutts> xerox, comparing fst is nicer than (\(x,_) (y,_) -> x == y)
07:24:13 <hyrax42> @type nubBy
07:24:14 <xerox> dcoutts: groupBy takes an a -> a -> Bool
07:24:14 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
07:24:34 <SamB> > nubBy (curry (uncurry (==) <<< (snd *** snd)) [(1,'b'),(1,'a'),(2,'a')]
07:24:34 <lambdabot>  parse error on input `}'
07:24:37 <SamB> hmm
07:24:44 <SamB> > nubBy (curry (uncurry (==) <<< (snd *** snd))) [(1,'b'),(1,'a'),(2,'a')]
07:24:45 <lambdabot> [(1,'b'),(1,'a')]
07:24:58 <good_boy> now i dont get this: sortBy (\x y -> compare (snd y) (snd x)) [(1,'a'), (1,'b'), (2,'a')]
07:25:00 <xerox> SamB: nice (-:
07:25:14 <dcoutts> xerox, comparing f a b = compare (f a) (f b)
07:25:19 <xerox> @type compare
07:25:19 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:25:25 <SamB> dcoutts: ooh, I like!
07:25:32 <xerox> dcoutts: I mean, it doesn't work, does it?
07:25:37 <dcoutts> SamB, it's not my idiom, but it's really nice
07:25:53 <dcoutts> sortBy (comparing snd)
07:25:53 <SamB> that is much better than my idea of *Through functions
07:26:02 <xerox> dcoutts: but that doesn't nub
07:26:23 <good_boy> you compare the seconds but you dont sort the seconds, you sort the whole tuple, right?
07:26:27 <SamB> just one problem...
07:26:27 <dcoutts> xerox, I'm not taling about that, just as a nicer way of writing groupBy (\(x,_) (y,_) -> x == y)
07:26:42 <dcoutts> groupBy (comparing fst)
07:26:45 <petekaz> what's this comparing function?  where is it defined?
07:26:48 <SamB> what about things that take (a -> a -> Bool) ?
07:27:02 <hyrax42> about 10 lines up, petekaz 
07:27:12 <hyrax42> 15
07:27:13 <xerox> @type ((\(x,_) (y,_) -> x == y),let comparing f a b = compare (f a) (f b) in comparing snd)
07:27:14 <lambdabot> forall b
07:27:14 <lambdabot>                                 b1
07:27:14 <lambdabot>                                 a1
07:27:14 <lambdabot>                                 b2.
07:27:14 <lambdabot>                               (Eq a,
07:27:16 <lambdabot> [8 @more lines]
07:27:19 <xerox> Ops.
07:27:20 <dcoutts> SamB, you'd need another name
07:27:29 <xerox> @type \(x,_) (y,_) -> x == y
07:27:30 <lambdabot> forall b a b1.
07:27:30 <lambdabot>          (Eq a) =>
07:27:30 <lambdabot>          (a, b) -> (a, b1) -> Bool
07:27:39 <xerox> @type let comparing f a b = compare (f a) (f b) in comparing snd
07:27:40 <lambdabot> forall a
07:27:40 <lambdabot>                        b.
07:27:40 <lambdabot>                      (Ord b) =>
07:27:40 <lambdabot>                      (a, b) -> (a, b) -> Ordering
07:27:56 <dcoutts> SamB, equating f a b = f a == f b
07:28:14 <SamB> equating?
07:28:16 <SamB> hmm.
07:28:20 <dcoutts> yeah, quite
07:28:45 <SamB> now all we need is someone to add these to Data.List
07:29:08 <dcoutts> @hoogle (a -> a -> Bool) -> a
07:29:09 <lambdabot> No matches, try a more general search
07:29:13 <dcoutts> @hoogle (a -> a -> Bool) -> b
07:29:13 <petekaz> @pl nubBy (\x y -> snd x == snd y) [(1,'b'),(1,'a'),(2,'a')]
07:29:14 <lambdabot> No matches, try a more general search
07:29:14 <lambdabot> nubBy ((. snd) . (==) . snd) [(1, 'b'), (1, 'a'), (2, 'a')]
07:29:23 <vincenz> is there such a thing as catchError for the IO monad?
07:29:24 <SamB> @hoogle groupBy
07:29:24 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
07:29:31 <SamB> @hoogle nubBy
07:29:32 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
07:29:40 <xerox> vincenz: yes.
07:29:40 <dcoutts> groupBy (equating snd)
07:29:47 <dcoutts> SamB, does that read ok?
07:29:48 <xerox> dcoutts: that would work.
07:29:54 <dcoutts> good
07:30:06 <dcoutts> it's been suggested before I think, comparing at least
07:30:09 <SamB> well, I really thought equating meant "holding to be equal"
07:30:11 <vincenz> xerox: and what would it be?
07:30:13 <dcoutts> many people liked it
07:30:18 <xerox> @docs Control.Exception
07:30:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
07:30:31 <xerox> There are some variants.
07:30:33 <dcoutts> SamB, yeah that's ok, holding to be equal via fst
07:30:46 <dcoutts> :-)
07:30:48 <SamB> maybe comparingEq ?
07:30:48 <dcoutts> maybe
07:31:03 <xerox> Today is naming day.
07:31:05 <dcoutts> you can equate the fst components of two things
07:31:11 <dcoutts> equivalence
07:31:33 <dcoutts> no, i think equate is better
07:31:47 * xerox nods
07:32:32 <petekaz> ok ... so as it stands, my lambda stays (if I want to keep it simple)
07:32:49 <petekaz> and that point free version is too confusing for me right now.
07:33:04 <good_boy> sort:: [(Char, Int)] -> [(Char, Int)] sort a =  Data.List.sortBy compare a [head a... tail a] snd ????????
07:33:23 <hoan> mayyybe comparingBy...
07:33:39 <petekaz> is ((. snd) . (==) . snd) easier to read than (\x y -> snd x == snd y) for an experienced haskeller?
07:33:41 <dcoutts> petekaz, yeah, that point free version is silly
07:34:03 <dcoutts> i'd say: nubBy (equating snd)
07:34:32 <dcoutts> where equating f a b = f a == f b
07:34:40 <petekaz> ok.
07:35:12 <dcoutts> petekaz, but the explicit lambda is fine
07:35:21 <dcoutts> and in similar circumstances I'd use it
07:35:43 <dcoutts> unless there was an obviously better point free version, which there often isn't
07:36:02 <dcoutts> only use point free when it makes it clearer
07:36:23 <dcoutts> and quite often it really does, but don't let it be an obcession
07:36:45 <petekaz> for a newbie, the point free stuff is quite cool.
07:36:51 <dcoutts> yeah :-)
07:37:08 <hyrax42> hmmm
07:37:24 <hyrax42> I'm having trouble coming up with a CPS map 
07:37:51 <hyrax42> (and soon, filter, probably
07:37:52 <hyrax42> )
07:38:33 <hyrax42> any pointers?
07:38:49 <hyrax42> (following YAHT, ecercise 4.11)
07:43:56 <vincenz> dcoutts: regarding fileChooserDialog... is it possible to specify a starting path?
07:44:12 <dcoutts> vincenz, yes.
07:45:06 <vincenz> ah in fileChooser, not fileChooserDialog :)
07:48:13 <samc> hey boegel don't listen to shapr it was me
07:48:55 <norpan> vincenz: start with normal definition, add extra continuation argument, rewrite rhs to be usages of the continuation
07:49:30 <hyrax42> norpan: for me, you mean?
07:49:42 <vincenz> norpan: wrong person?
07:49:44 <norpan> oh yes, hyrax42 
07:49:47 <norpan> sorry
07:50:03 <norpan> my eyes are crossed
07:50:30 <boegel> samc: ? about what ?
07:51:05 <norpan> so for map, instead of map f [] = [] you will get map k f [] = k []
07:51:09 <norpan> that's the easy case :)
07:51:24 <samc> ... that was interested in funmath
07:51:51 <samc> I just found the site :)
07:53:45 <samc> ... so I googled for www.funmath.com -site:www.funmath.com and it came up with some #haskell history which I looked at out of curiosity, you were asjing who was it that was interested about fumath
07:53:52 <norpan> hyrax42: also, the function f now takes a continuation as well as an element
07:54:06 <hyrax42> yeah, I'm working on it... :)
07:54:08 <hyrax42> just
07:54:10 <hyrax42> head
07:54:11 <hyrax42> bend
07:54:45 <hyrax42> the map will also have a continuation argument?
07:55:07 <hyrax42> that's not how it is in the cps fold in the tutorial... only f takes a continuation
07:56:11 <norpan> ok, that's another style
07:56:14 <norpan> haven't read that one
07:56:43 <norpan> then map f = []
07:56:48 <norpan> map f [] = [] i mean
07:57:15 <hyrax42> yeah, but I can't figure out the cont argument
07:57:18 <hyrax42> or even its type
08:02:09 <samc> .be rather
08:03:39 <norpan> the cont argument will take an a and a continuation of type [b]
08:03:46 <norpan> so in that style, map f [] = f
08:07:04 <samc> boegel, previously you had found for be a paper (by Hannes Verlinde) which contained a synopsis
08:07:23 <samc> for me
08:07:57 <norpan> hyrax42: so the final type of map' will be (a -> [b] -> [b]) -> [a] -> [b]
08:14:36 <shapr> samc: hiya! ltns!
08:14:44 <hyrax42> norpan: hmmm
08:14:59 <hyrax42> I think I'll come back to this later
08:15:20 <hyrax42> I was just flicking through the cps transform chapter in eopl
08:15:29 <hyrax42> but it's rather dense
08:15:41 <norpan> and for filter the the continuation will take two arguments, one if the test succeds and one if it fails
08:15:43 <hyrax42> (or I am)
08:15:53 <norpan> apart from the "a" argument of course
08:17:45 <samc> hey shapr was there any interested in the spoken j*va paper?
08:18:01 <samc> anything interesting
08:18:13 <samc> I can't seem to talk properly today
08:18:43 <samc> or did you throw it in the trash in disgust
08:19:11 <samc> if it takes off we could then say "excuse my java" ;)
08:20:36 <norpan> hyrax42: if you just write the definition it will work :)
08:21:07 <norpan> map' f [] = f; map' f (x:xs) = f x (map' f xs)
08:21:49 <norpan> err the first is map' f [] = [] of course
08:21:50 <vincenz> norpan: that mkes no sense
08:21:53 <vincenz> and
08:21:58 <vincenz> (f x):(map' f xs)
08:22:08 <norpan> no it's cps
08:22:32 <vincenz> ah
08:23:12 <xerox> That is fold, isn't it?
08:23:21 <xerox> "kinda"
08:23:40 <norpan> it's kinda fold, its map
08:23:41 <shapr> samc: I haven't read it yet, but I like the idea of 'excuse my java'
08:24:36 <hyrax42> ow :(
08:24:45 <hyrax42> that can't work can it
08:24:57 <hyrax42> from the second pater, f must have type
08:25:07 <hyrax42> a -> [?] -> [b]
08:25:17 <norpan> yes
08:25:20 <hyrax42> but in the first pattern it's called with no arguments
08:25:27 <hyrax42> and is the ? a or b
08:25:33 <norpan> no, i wrote it wrong, it's map' f [] = []
08:25:58 <xerox> @type let m [] = []; m f (x:xs) = f x (m f xs) in m
08:25:59 <lambdabot> Varying number of arguments for function `m'
08:26:06 <xerox> @type let m _ [] = []; m f (x:xs) = f x (m f xs) in m
08:26:07 <lambdabot> forall a a1.
08:26:07 <lambdabot>                  (a -> [a1] -> [a1]) -> [a] -> [a1]
08:26:17 <zer0`> > map (compare 3) [1..10]
08:26:18 <lambdabot> [GT,GT,EQ,LT,LT,LT,LT,LT,LT,LT]
08:26:48 <hyrax42> > let m _ [] = []; m f (x:xs) = f x (m f xs) in m (compare 3) [1..10]
08:26:49 <lambdabot> Couldn't match `Ordering' against `t -> t1'
08:27:00 <hyrax42> oh
08:27:01 <hyrax42> ack
08:27:10 <norpan> you must cpsify the function too
08:27:11 <hyrax42> ng
08:27:13 <hyrax42> yeah
08:27:15 <hyrax42> I just realised
08:28:06 <zer0`> > compare pi 3.15
08:28:07 <lambdabot> LT
08:28:31 <davidhouse> > let rpi = toRational pi in pi `compare` rpi
08:28:32 <lambdabot>  add an instance declaration for (Floating Rational)
08:28:43 <davidhouse> heh. that was stupid of me.
08:29:37 <zer0`> > intersperse ' ' "haskell!"
08:29:38 <lambdabot> "h a s k e l l !"
08:29:57 <hyrax42> >let m _ [] = []; m f (x:xs) = f x (m f xs) in m (\x g -> (compare 3 x):g) [1..10]
08:30:11 <hyrax42> > let m _ [] = []; m f (x:xs) = f x (m f xs) in m (\x g -> (compare 3 x):g) [1..10]
08:30:12 <lambdabot> [GT,GT,EQ,LT,LT,LT,LT,LT,LT,LT]
08:30:38 <hyrax42> ug
08:30:48 <davidhouse> hyrax42: what do you want?
08:30:59 <hyrax42> to understand why I could make that work
08:31:00 <hyrax42> :(
08:31:07 <norpan> filter is a better example i think
08:31:09 <hyrax42> yeah
08:31:12 <norpan> there you have two continuations
08:31:14 <hyrax42> leave it to me :)
08:31:19 <davidhouse> hyrax42: what's it meant to do?
08:31:26 <hyrax42> oh I'm trying to write a cps map
08:31:31 <hyrax42> so that is what it was meant to do
08:31:40 <norpan> map is not a good example
08:31:40 <zer0`> > filter odd [1..10]
08:31:40 <hyrax42> but I didn't write the map
08:31:40 <lambdabot> [1,3,5,7,9]
08:31:48 <hyrax42> I only cps-ed the mapping function
08:31:52 <hyrax42> or
08:31:52 <norpan> even i don't understand that one
08:32:00 <davidhouse> ah. CPS. /me steers clear.
08:32:18 <hyrax42> it seems a bit out of place where it is in the YAHT
08:32:23 <hyrax42> everything's going along fine
08:32:34 <hyrax42> then BAM nice little 2 paragraph explanation
08:32:40 <hyrax42> with an example of fold
08:32:42 <hyrax42> and you're on your own
08:33:21 <davidhouse> i skipped that :)
08:33:27 <davidhouse> YAHT is badly organised in places.
08:33:50 <hyrax42> well it seems more suited to what I want than the rest
08:33:50 <davidhouse> e.g. introducing things like $! and strict constructors waay too early.
08:34:02 <hyrax42> but I guess I should take liberty with it, since I'm the one learning
08:34:10 <hyrax42> ok I'll watch out for that
08:34:27 <hyrax42> now I'll go ponder cps filter in the shower
08:34:42 <hyrax42> thanks norpan 
08:34:43 <hyrax42> !
08:34:50 <norpan> filter is better
08:41:58 <ralejs> norpan: Happy Birthday! 30 whole years! (one day in advance I know. I saw the ad in GP)
08:42:09 <norpan> wow
08:42:35 <norpan> i'm pretty sure it didn't say "norpan" in the paper :)
08:42:49 <ralejs> :-) No it didn't.
08:43:30 <ralejs> I figured you wouldn't be on irc tomorrow so I took the liberty to congratulate you today.
08:43:59 <norpan> i'll be here :)
08:45:31 <ralejs> norpan: OK. :-) Lots of Haskell coding lately?
08:45:48 <norpan> not really
08:56:31 <adaran> i'm trying to link with HSX11.a, however, ld tells me i'm missing fdSet - what library is that function in?
09:05:18 <shapr> @hoogle fdSet
09:05:18 <lambdabot> No matches found
09:06:09 <shapr> @google haskell fdSet library
09:06:11 <lambdabot> http://darcs.haskell.org/packages/X11/X11.cabal
09:06:33 <shapr> Seems to be part of the c-sources for that package.
09:12:22 <norpan> hyrax42: here is another version: map' f (x:xs) = f x (\y -> y:map' f xs)
09:14:17 <norpan> and mymap f xs = map' (flip id . f) xs
09:15:12 <hyrax42> which binds tighter
09:15:20 <hyrax42> flip or .
09:15:28 <hyrax42> @type (flip id. f)
09:15:29 <norpan> function application binds tighter
09:15:29 <lambdabot> Not in scope: `f'
09:15:32 <hyrax42> oh
09:15:52 <hyrax42> so it's ((flip id) . f)
09:15:59 <norpan> flip id . f = \a b -> b (f a)
09:15:59 <hyrax42> @type id
09:16:01 <lambdabot> forall a. a -> a
09:26:43 <hyrax42> filter was much easier to understand
09:26:57 <hyrax42> cfilter' p (x:xs) = p x (\y -> y:cfilter' p xs) (\_ -> cfilter' p xs)
09:27:20 <hyrax42> cfilter' p [] = []
09:27:56 <hyrax42> and filter p l = cfilter' (\x s f -> if p x then s x else f x) l
09:29:29 <hyrax42> > let f' _ [] = []; f' p (x:xs) = p x (\y -> y:f' p xs) (\_ -> f' p xs); fltr p l = f' (\x s f -> if p x then s x else f x) l in fltr (>3) [1..10]
09:29:30 <lambdabot> [4,5,6,7,8,9,10]
09:29:37 <hyrax42> yay
09:29:53 <hyrax42> I feel like I'm making my way down that evolution of a haskell programmer
09:34:02 <norpan> or like this
09:34:06 <norpan> filter' f (x:xs) = f x (\y -> maybe id (:) y (filter' f xs))
09:34:08 <norpan> :)
09:34:13 <araujo> Hi
09:34:37 <hyrax42> @type maybe
09:34:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:35:12 <hyrax42> > maybe id Nothing
09:35:13 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
09:35:19 <hyrax42> oh
09:35:28 <hyrax42> wha
09:35:56 <hyrax42> k
09:36:29 <hyrax42> then filter p xs = filter' (\x -> if p x then Just x else Nothing) xs?
09:36:50 <hyrax42> oh
09:36:50 <hyrax42> no
09:36:55 <norpan> you must apply the continuation too
09:36:59 <hyrax42> yeah
09:37:36 <norpan> and in your example, the second continuation need no argument
09:37:48 <norpan> so you can write these things in different ways
09:44:57 <hyrax42> ohh
09:45:03 <hyrax42> @type maybe
09:45:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:45:25 <hyrax42> so if it gets Nothing, it returns the first argument
09:45:44 <hyrax42> else returns the application
09:46:44 <hyrax42> > maybe 0 (+3) Just 6
09:46:45 <lambdabot> Couldn't match `Maybe (t -> t1)' against `t2 -> t3'
09:50:37 <hyrax42> is there a better way to write
09:50:57 <hyrax42> (\x k -> if p x then k (Just x) else k Nothing)
09:52:42 <hyrax42> I guess (\x k -> k (if p x then (Just x) else Nothing)) is equivalent
09:52:45 <hyrax42> but hardly better
09:54:46 <norpan>  (\x g -> g (guard (f x) >> Just x))
09:56:33 <hyrax42> hrm
09:56:43 <hyrax42> haven't reached guard yet
09:56:46 <hyrax42> @type guard
09:56:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:07:06 <norpan> is there an easy way to avoid linking in libgmp with ghc?
10:07:14 <norpan> or to link it in statically
10:08:44 <norpan> or is that fixed in ghc 6 perhaps
10:08:48 <norpan> linking with 5 here
10:09:50 <vincenz> ./Sequence.hs:43:0: Couldn't match kind `*' against `k_a1E3 -> *' In the data type declaration for `GenericSequence'
10:10:06 <vincenz> is this because not alll my data cons use the same amount of params?
10:10:53 * palomer is out of commission because of a wrist pain
10:11:01 <palomer> s/commission/comission
10:12:32 <Igloo> norpan: What's the problem?
10:12:46 <norpan> the problem is that libgmp is LGPL
10:13:02 <Igloo> norpan: The short answer is no, anyway. It's used for Integers
10:13:13 <norpan> yeah i figured
10:13:46 <norpan> or rather, another problem is that it is LGPL
10:14:04 <norpan> so if ghc-6.4 links it in statically, as it seems, then i'll be in trouble :)
10:14:29 <norpan> and linking it in dynamically means the user of the binary needs to install it
10:19:22 <norpan> i suppose the fact that libgmp is lgpl has been discussed
10:19:42 <norpan> but until there is something to replace it with i guess we are stuck
10:20:34 <norpan> sigh, i guess we will have to distribute the libgmp.so object as well
10:20:46 <norpan> at least then we have the license covered
10:23:00 <Philippa> you probably only need to distribute the object files for your code
10:23:15 <DeliQ> why is LGPL a problem ?
10:23:29 <Philippa> because it has a clause about letting users link in a later version of the library if they want to
10:23:51 <DeliQ> i see
10:32:08 <SamB> I heard that gmp is horrible (portability-wise) anyway...
10:33:29 <musasabi_> which is of course not really possible in an easy way if shared libraries use symbol versioning.
10:34:31 <musasabi_> SamB: something better would be very nice.
10:38:06 <norpan> distributing everything as .o files as well also seems cumbersome
10:38:26 <norpan> the easiest way seems to be to link dynamically and distribute libgmp.so along with it
10:38:41 <norpan> then users can replace that .so and lgpl is happy
10:39:13 <norpan> and users are happy because they don't have to install libgmp.so themselves
10:39:22 <norpan> or libgmp.dll
10:40:09 <sethk> I don't mind distributing a .so, but I get nervous about distributing a dll.  I get around that, though, I just don't support windows.  :)
10:40:09 * palomer is not a fan of the LGPL
10:40:14 <palomer> only because it forces you to link dynamically
10:40:16 <musasabi_> norpan: but how would one create a BSD licensed operating system kernel with it? Having gmp as a separate module seems harsh, then again I think it could be done without Integer.
10:40:50 <norpan> yes
10:40:54 <norpan> or use an Integer replacement
10:41:27 <norpan> i just grepped the code, we do not use Integer
10:41:33 <norpan> at least not explicitly
10:41:46 <norpan> who knows what the RTS uses
10:42:13 <musasabi_> I don't think it uses Integer either.
10:43:18 <norpan> we use fromInteger . toInteger in some places
10:43:29 <norpan> that could be rewritten easily
10:43:51 <palomer> isn't fromInteger . toInteger == id ?
10:44:00 <norpan> no
10:44:13 <palomer> how so?
10:44:22 <norpan> @type fromInteger . toInteger
10:44:24 <lambdabot> forall a a1.
10:44:24 <lambdabot>          (Num a, Integral a1) =>
10:44:24 <lambdabot>          a1 -> a
10:44:33 <musasabi_> @type fromIntegral
10:44:35 <lambdabot> forall b a. (Num b, Integral a) => a -> b
10:44:56 <musasabi_> so it is the reverse of fromIntegral.
10:45:12 <norpan> yes
10:45:16 <palomer> where did integral pop up?
10:45:41 <musasabi_> toInteger
10:45:53 <musasabi_> @type toInteger
10:45:54 <lambdabot> forall a. (Integral a) => a -> Integer
10:46:21 <sethk> is there a fromInteger?
10:46:26 <norpan> hey, it is fromIntegral
10:46:28 <sethk> there is a fromIntegral
10:46:34 <norpan> i will rewrite immediately :)
10:46:43 <sethk> fromIntegral means from any integer type, not Integer only
10:48:21 <norpan> if i remove all Integer usage, maybe i can create a ghost libgmp that does nothing
10:48:25 <norpan> and link with thta
10:50:56 <musasabi_> norpan: you could rewrite a BSD licenced API compatible libgmp replacement and then statically link with that?
10:50:58 <newsham> gmp is only LGPL, right?
10:51:15 <newsham> LGPL should be a lot more palatable than GPL
10:51:31 <palomer> you can't statically link against it
10:51:37 <palomer> huge pain, imo
10:52:56 <musasabi_> We should have a simple "keep this code free" but you can link it to anything you want in any way you want.
10:53:07 <hyrax42> @hoogle a -> [a] -> Maybe a
10:53:08 <lambdabot> No matches, try a more general search
10:53:10 <newsham> i thought you can use lgpl libraries without infecting the greater whole
10:53:23 <hyrax42> @index lookup
10:53:24 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
10:53:39 <Philippa> newsham: yes, but it's a PITA for binary distribution
10:54:12 <palomer> LGPL without the dynamic linking clause is fine
10:54:19 <newsham> what about using openssl's MP library?
10:55:29 <musasabi_> does that have BSD3 or BSD4 license?
10:55:57 <newsham> apache-style license
10:56:07 <newsham> http://www.openssl.org/source/license.html
10:56:50 <musasabi_> That has the dreaded advertising clause, and is GPL incompatible.
10:57:09 <newsham> heh "dreaded advertising clause"
10:57:13 <newsham> sounds like you want to write your own code.
10:57:28 <newsham> cause most licenses will require you to give credit to the author :)
10:58:55 <musasabi_> newsham: I don't mind giving credit to the author. I would mind having to remember to add a clause to advertising all GHC related things. And apps produced by GHC.
10:59:23 <palomer> the BSD licenses require you to advertise/
10:59:24 <palomer> ?
10:59:34 <palomer> does microsoft advertise the fact that it uses BSD code?
10:59:50 <musasabi_> There are two variants of the BSD license. One with advertising and one without.
11:00:06 <Muad_Dib> nndo they use bsd code palomer?
11:00:18 <newsham> only slightly more work than writing a MP library.
11:00:29 <palomer> their TCP/IP stack is bsd, I believe
11:01:08 <Philippa> usually the advertising is buried in an about box somewhere
11:01:29 <hyrax42> @paste
11:01:30 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
11:01:54 <musasabi_> It is mostly an extra thing to remember and would grow painfull if everyone used it.
11:01:56 <hyrax42> huh
11:02:01 <hyrax42> @where paste
11:02:01 <lambdabot> http://paste.lisp.org/new/haskell
11:03:06 <musasabi_> The more important problem is that one couldn't distribute any GPL licenced programs as binaries if compiled by GHC.
11:03:22 <musasabi_> (if we used openssl MP library)
11:04:18 <lisppaste2> hyrax42 pasted "There must be a better way" at http://paste.lisp.org/display/19859
11:04:33 <newsham> musasabi: are you sure?  thats no my understanding of lgpl.
11:04:54 <hyrax42> really simple newb question
11:04:55 <musasabi_> newsham: GPL in this case.
11:04:57 <hyrax42> :)
11:05:40 <musasabi_> newsham: GPL considers BSD+Advertising to be nonfree so you cannot link BSD+Advertising code with GPL code (so people make amended versions of the GPL license for that).
11:05:51 <Igloo> hyrax42: Better in what sense? if name `elem` [...] would be slightly nicer than the find you have
11:06:05 <hyrax42> ah elem is the one I coldn't find
11:06:11 <hyrax42> I looked for member
11:06:16 <hyrax42> a la lisp
11:06:25 <Igloo> musasabi_: Do you actually have any BSD4 licenced code?
11:06:32 <hyrax42> Igloo: thanks, that's exactly it
11:06:48 <newsham> http://www.cs.dartmouth.edu/~sting/mpi/ ?
11:07:04 <musasabi_> Igloo: OpenSSL
11:07:15 <musasabi_> I don't BSD4 license my own code.
11:08:34 <musasabi_> Igloo: we were talking about the possiblity of using OpenSSL MP library in place of GMP.
11:08:55 <newsham> MPI is public domain.
11:09:11 <newsham> but not optimized
11:09:42 <Igloo> Oh, so it is (well, equivalent to, at least)
11:09:43 <musasabi_> What was OCaml using?
11:10:53 <newsham> here's a good starting point. bernstein tests several MP libs: http://cr.yp.to/speed/mult.html
11:11:21 <newsham> also, have you considered asking for special licensing from one of the authors?
11:17:02 <xerox> musasabi_: what licence do you use?
11:17:32 <SamB> what is meant by "not optimized"?
11:18:41 <musasabi_> xerox: BSD3 for most code, but if working on an existing project then adapt to using that there.
11:19:01 <musasabi_> xerox: I just want to share code with the least amount of fuss involved.
11:19:07 <xerox> musasabi_: I do agree
11:19:13 <SamB> hmm, so the libraries aren't certain to work!
11:19:42 <SamB> that is what I love about BSD3 ;-)
11:19:53 <SamB> that is the main thing I want out of a license, too
11:21:19 <akemp> @seen syntaxninja
11:21:20 <lambdabot> syntaxninja is in #haskell and #haskell-blah. I last heard syntaxninja speak 1 hour and 8 seconds ago.
11:23:03 <SamB> @seen me
11:23:04 <lambdabot> I haven't seen me.
11:23:28 <SamB> lambdabot will never make it as an IF system!
11:23:52 <xerox> @vixen will you ever make it as an IF system?
11:23:52 <lambdabot> i'll hafta plead the fifth on that one.
11:29:07 <SamB> lambdabot is clearly delusional
11:29:42 <SamB> seeing as the fifth to which lambdabot is referring is the fifth amendment of the US constitution...
11:29:55 <SamB> ...whereas lambdabot is located in australia
11:30:47 <monochrom> Interesting.  I have "fiblist :: Num a => [a]" and "fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist)" at the top level.  What do you think ghc stores for that at the low level?
11:31:41 <xerox> monochrom: no idea.
11:32:23 <monochrom> Thus, if I force a few terms with "fiblist !! 1000 :: Integer", I get an integer, and something is memoized.  Then I can also force with "fiblist !! 1000 :: Double", and I get a double, and something gets memoized or not.  What will be memoized?
11:33:18 <xerox> Is GHC smart enough to reuse the Integer result?
11:34:30 <monochrom> Perhaps the memoized things use whichever number type is set as the "default".  (Usually Integer.)  Then all other queries using other number types are obtained by coercions such as fromIntegral.
11:35:25 <xerox> I think it would be fair.... at first thought.
11:35:42 <xerox> Oh, gotta run, ttyl.
11:37:01 <int-e> hmm. I doubt ghc memoizes anything for that.
11:37:46 <int-e> The function has polymorphic type; for the RTS it's a function that takes a dictionary argument, i.e. it's not a CAF.
11:40:19 <kosmikus> the recursive calls are still memoized
11:40:28 <kosmikus> but not the list itself between calls
11:40:47 <int-e> sure, sharing still works as usual.
11:42:02 <kosmikus> also, one can probably ask ghc to specialize for certain types, using a SPECIALIZE pragma
11:43:06 <int-e> actually I believe fiblist gets rewritten for that purpose; fiblist = fiblist' where fiblist' = 0 : 1 : zipWith (+) fiblist' (tail fiblist')
11:43:25 <int-e> the point being that fiblist' is monomorphic in its context.
11:43:38 <int-e> but I may be mixing up some stuff here.
11:44:41 <int-e> specialize is an interesting idea, yes. (what's that on the implementation level? does it make an alias of the specified type and a rewrite rule to use that alias where appropriate?)
11:46:55 <kosmikus> I think so, but I haven't looked at Core to verify
11:47:43 <mwc> i'm trying to think up any fundamental reasons why SML-style exceptions couldn't be used in a language like Haskell.
11:48:02 <mwc> I'm 99% sure (100% when I actually implement it) that I could implement it using continuations
11:49:35 <mahogny> mwc, should be trivial with continuations. still, do you really think it would be possible to make a generally usable framework for exceptions without makings things actually more messy? I think that's the prob
11:49:56 <mwc> mahogny, yeah, I'm thinking it really needs to be done at the language level
11:50:04 <mwc> which is why I'm trying to come up with reasons why it couldn't be done
11:50:42 <mwc> error is a pretty weak mechanism for handling inconsistency
11:50:48 <mahogny> I am a bit doubtful to exceptions at language level. you will be enforced a set of semantics that might not be the easiest to work with
11:51:04 <mahogny> or language level, do you mean in compiler or in a library?
11:51:12 <mwc> in the compiler itself
11:51:15 <int-e> mwc: hmm, evaluations can escape their context. of course continuations can return to the context anyway but you don't know what happened in the meantime.
11:51:26 <mahogny> mwc, that's the thing I doubt. but give it a shot
11:51:42 <mwc> int-e, yeah, I was intending to package it into a monad
11:52:00 <mwc> and try to hide everything behind "addhandler" and "throw" 
11:52:02 <monochrom> What do you have in mind uses of exceptions?  There are several uses.  Some are better done with Maybe.  Some should just be confined in IO.
11:52:21 <mahogny> some are better not exceptions at all
11:52:37 <mahogny> I think many languages overuse them
11:52:42 <mahogny> java at least
11:52:51 <mwc> I mean handling cases where error is normally used.
11:53:05 * mahogny has never used error o_O
11:53:29 <mwc> tail []?
11:53:45 <mahogny> I never call tail with that argument :)
11:54:07 <monochrom> Someone wrote an entire thesis on how you should use Maybe and not exceptions.
11:54:19 <monochrom> Also why.
11:54:26 <psnl> monochrom: got a link?
11:54:28 <mahogny> monochrom, his main point being?
11:54:30 <mwc> monochrom, interesting
11:54:34 <mwc> got a reference?
11:54:59 <pesco> monochrom: I want that link, too. ;)
11:55:14 <monochrom> I know very little about it.  The main point is just what I said.  "exceptions are evil, use Maybe."
11:55:22 <mahogny> Maybe is nice when you have easy access to it. that's not always the case, but there's usually a way out without using exceptions anyway
11:55:42 <mahogny> monochrom, sounds too orthodox for me to agree with the argument :P
11:56:02 <monochrom> Well, I have not presented any argument.
11:56:19 <mahogny> well, not you, but him. "are evil" :)
11:56:38 <monochrom> I'm sure the thesis substantiates that.
11:56:44 <mahogny> a bit ;)
11:57:04 <monochrom> It is not like the thesis is 1 paragraph long.
11:57:18 <pesco> Where is it?!
11:57:38 <mahogny> well, I see little reason to add a more complex exception system to the language itself when you can easily do without
11:57:54 <int-e> . o O ( take 10000 $ repeat "Exceptions are evil." )
11:58:01 <monochrom> haha
11:58:08 <mwc> monochrom, my concern with Error or Maybe is if that when you return Nothing or Left Err; then you still continue to carry that value through all subsequent computations int he chain
11:58:11 <mahogny> there aren't many times when throwing an error is a valid thing to do anyhow
11:58:16 <mwc> it just doesn't immediately return the result
11:58:26 <mahogny> if you disk crashes, then I might consider throwing an exception...
11:59:26 <mahogny> mwc, exceptions are supposed to be few. if you complain about your program being slow when it trashes, then you should make it trash less :)
11:59:51 <msph> Is this debate specific to Haskell, or are you disapproving of exceptions in all languages?
11:59:52 <SyntaxNinja> hi akemp
12:00:00 <SyntaxNinja> oh, gone
12:00:04 * int-e thinks lazy evaluation and exceptions don't mix. propagating error on the other hand works ...
12:00:07 <mwc> mahogny, I'm refering more to using those two mechanism to provide an alternate exit path
12:00:44 <mahogny> msph, not all exceptions, and some languages are really too weak to live without exceptions so in some cases they are motivated
12:01:03 <int-e> and I would think of error as a builtin Maybe (or Either) monad; it's just a bit hard to pattern match on.
12:01:32 <pesco> int-e: And you never know when it will pop up, lazy-eval and all.
12:01:47 <mahogny> msph, I think if you can check ahead if something will even compute, then that's better than an exception though. it also makes proving properties more straight forward
12:01:48 <int-e> pesco: not true
12:02:05 <int-e> pesco: it'll pop up where the error propagates to an IO action that's being executed.
12:02:16 <monochrom> I have a hunch that in an eager language exceptions are both comprehensible and efficient, and in a lazy language Maybes are both comprehensible and efficient.
12:02:58 <mahogny> monochrom, agree there, although I don't see that black and white
12:03:16 <monochrom> Right, I am not going to write a thesis on that!
12:03:18 <pesco> int-e: Yes, but sometimes you just don't know (or "can't" keep track of) which one that's going to be. Happened to me just the other day.
12:03:25 <msph> mahogny: Okay.  Was curious on that.
12:03:40 <mwc> there's a problem from Okasaki's book where they use the exception mechanism in inserting an element into a binary tree. If they find the element in descending the tree to find the leaf to insert in, an exception is thrown and caught at the top of the function, so that it returns the tree that was input as opposed to the tree that was created by copying all the nodes on the search path.
12:03:50 <mwc> That's something you could do in haskell using a continuation
12:03:59 <mahogny> how would it look with an ExceptionT that you can mix with your monad transforming stack?
12:04:10 <int-e> pesco: well, the error message isn't part of the language semantics; it's just bottom. So that's hardly surprising, if there are several bottoms to choose from.
12:05:17 <pesco> int-e: But since you're not strictly evaluating, not everything which the error is a subterm of turns into bottom. That's what I meant.
12:05:27 <mahogny> pesco, I think a proper exception mechanism need to be able to tag the location of the explosion
12:05:49 <int-e> I think thinking of 'error' as an exception is a mistake.
12:05:56 <Revision17> why is it that a big number set as a word8, like 2500::Word8, doesn't generate a compiler error in GHC?
12:06:35 <int-e> It's the RTS that turns error into exceptions, when encountered as an IO action.
12:06:38 <pesco> mahogny: Yes, I was thinking more about the programmer thinking about when exceptions _could_ happen.
12:06:40 <monochrom> ghc Control.Exception already lets you throw anywhere.  But you can only catch in IO.  (The new proposal is to catch in any MonadIO.)  So I think the question comes down to: why or why not allow catching in a pure expression?
12:06:52 <mahogny> int-e, in many cases I agree. error handling need to be put at a level when it actually can make some sense. tail [] for example. what kind of error message should you return?
12:07:15 <mwc> Revision17, when you put an integral constant in your source, it's read as (fromIntegral 2500), so apparently Word8s' fromIntegral doesn't concern itself with exceeding bounds
12:07:36 <mwc> fwiw, I can never remember if it's fromIntegral or fromInteger or whathaveyou
12:07:48 <Revision17> mwc: alright, thanks
12:08:23 <int-e> mahogny: 'tail: empty list' is fine *shrugs*
12:08:51 <mahogny> int-e, yeah. I smack it in the users face next time he tries to open a file and it's not found or something ;)
12:11:28 <int-e> I'd say that's a programming error on your part then
12:12:50 <mahogny> the point is more that it is pointless to give errors on that level because you have no idea what you should do. failure should occur as high up in a hierarchy as possible to be handled in the best way
12:13:22 <int-e> And I believe that's what error is for - catching programming errors. Viewed that way, I agree with 'don't use error, use Maybe or Either instead'.
12:13:54 <waern> Just got: darcs: FastPackedString.tailPS: empty list
12:14:02 <mahogny> int-e, right
12:14:05 <waern> speaking of error messages =)
12:15:16 <int-e> blah.c:23: assert(a == 42)
12:19:30 <SamB> its a pity good tracebacks are so hard to get these days
12:20:33 <int-e> mahogny: a different question is whether one could improve the situation to make bottom more useful for lazy code. you could probably create an either-like function for that (bottom (\error :: String -> value if error) (\value -> value if no error) (value to check)). I wonder how many assumptions about semantics that would break though.
12:21:25 <mahogny> int-e, that invites to abuse
12:21:27 <int-e> (the resulting type would be bottom :: (String -> b) -> (a -> b) -> a -> b)
12:21:36 <monochrom> Ah!  "error" should try to print out a trace.
12:21:58 <mahogny> automatic invocation of Hat. yes kthx
12:23:16 <int-e> mahogny: sure. but if we didn't want abuse, we shouldn't have error in the first place, just undefined.
12:24:02 <int-e> a not-so-evil version would be   replace_error :: String -> a -> a
12:24:51 <mahogny> int-e, since you want to be able to output at least a small text if your program messes up, you need a command. and since you want code to be portable, error need to go into the standard. doesn't mean it should be used that much though :/
12:26:21 <SamB> monochrom: it would be nice if you could get a trace from calls to error, yes ;-)
12:27:32 <int-e> what would that look like? 'error 'blah', forced by fib, forced by showList, forced by shows, forced by putStrLn, forced by top-level IO.'?
12:29:26 <mahogny> I think two modes would make most sense; one lazy like above, but then a call stack as if the calls were eager would simplest to analyze (but would be insufficient if your program *needs* lazyness, and that is where it fails)
12:32:13 <vincenz> Anyone know a good project management app for linux?
12:33:01 <mahogny> vincenz, what should it do?
12:33:14 <vincenz> I just want to schedule tasks
12:33:19 <vincenz> and approx their duration
12:33:21 <vincenz> and their dependencies
12:33:27 <vincenz> and then it shows me in a calendar as bars
12:33:48 <mahogny> vincenz, "mr project" or something like that is the standard gnu tools. I don't like it, but that's essentially it
12:33:57 <vincenz> mahogny: what's wrong with it
12:34:08 <mahogny> inflexible
12:34:23 <mahogny> and I think a proper project management tool needs more than that
12:34:37 <vincenz> well it's just for myself and my phd planning
12:35:13 <mahogny> I usually use Open Office for project planning. as easy, but more flexible
12:35:25 <vincenz> mahogny: how?
12:35:45 <mahogny> just a spreadsheet. takes some practice to get a good way of working
12:35:51 <vincenz> hmm
12:36:03 <mahogny> I just make a Gantt schedule
12:36:06 <vincenz> so how do you do automatic layouting if you resize stuff or parallelize tasks?
12:36:15 <vincenz> mahogny: right but how do you make a gantt in a spreadsheet
12:36:37 <mahogny> vincenz, well. select the cells you want and give them a nice background color, then write something in it
12:36:49 <vincenz> heh..
12:36:56 <vincenz> that hardly gives you a timewise layout
12:37:04 <mahogny> as in?
12:39:34 <mahogny> vincenz, actually, mr project has gotten better. just tried it
12:39:49 <vincenz> :)
12:41:51 <monochrom> I have an lhs.  haddock won't understand it, right?  As the haddock doc instructs, I go "ghc -cpp -E -optP-P -D__HADDOCK__ ...".  But the output file has no comments.
12:42:46 <vincenz> mahogny: how do you specify task dependencies?
12:43:00 <mahogny> vincenz, hold on a task and drag to another
12:44:13 <vincenz> mahogny: thank you
12:44:18 <mahogny> np
12:44:34 <vincenz> how about defining that a task takes a week but only at 50% load
12:46:45 <vincenz> got it, work vs duration :)
12:46:52 <mahogny> :)
12:47:20 <mahogny> such things are usually those you have to learn to live without. one can't expect the coders to think about everything everyone needs
12:50:42 * vincenz isn't a coder
12:50:51 <vincenz> well I am at heart, but not professionally
12:54:14 <mahogny> vincenz, that's good. commercial coders tend to have no clue what they are doing. I prefer amateurs :)
12:55:12 <vincenz> erm
12:55:18 <vincenz> no I mean that professionally I'm doing reserch
12:55:40 <mahogny> almost as good as an amateur ^_^
12:55:53 <Philippa> mahogny: it's not a matter of coders, it's a matter of the guys who dreamt up the model
12:56:15 <Philippa> in practice, that kind of project management software's not intended to manage projects with small numbers of people with detailed use of their time going on
12:56:31 * vincenz just wants to have a schedule, roughly to have some more direciton
12:56:35 <mahogny> Philippa, it tends to be both
12:56:52 <vincenz> (by 2007 I need to start writing, which means that before that I need to do this and this and this)
12:56:58 <mahogny> google calendar owns by the way
12:57:09 <vincenz> yeah it does
12:59:48 <Philippa> mahogny: the vast majority of project management software's implementing ancient models that aren't intended for micromanagement. The coders don't directly choose that either...
13:00:18 <mahogny> Philippa, true
13:00:41 <mahogny> Philippa, a new open source system would be nice
13:01:03 * mahogny can think of many nice features
13:01:09 <Philippa> you'd need to find models worth using too. In fairness they may well be out there...
13:02:00 <good_boy> how do i sort a list of tuples with the signature [(Char, Int)] according to the order of Int (increasing/decreasing unimportant)
13:02:21 <Cale> sortBy (\x y -> compare (snd x) (snd y))
13:02:41 <mahogny> Philippa, I don't think a micromanagement model is very hard to make. what needs to be done is to make the software wiki-like, and connect bug tracking to the dependency set
13:03:07 <Cale> I like to define comparing p x y = compare (p x) (p y), so that I can write sortBy (comparing snd)
13:03:17 <good_boy> where x and y are?
13:03:27 <Cale> elements of the list to compare
13:03:28 <mahogny> Philippa, optimal would be if the software itself could figure out the best schedule...
13:03:55 <Cale> sortBy uses the provided comparison function
13:04:17 <good_boy> i still dont understand how to adapt this code in my function...
13:04:50 <good_boy> i have a function sortByNmber of the following signature [(Char, Int)] -> [(Char, Int)]
13:04:51 <mahogny> good_boy, you need to code a function that tells which (Char,Int) goes first in a list
13:05:02 <monochrom> I think we dealt with that like five days ago?
13:05:07 <Cale> > let comparing p x y = compare (p x) (p y) in sortBy (comparing snd) [('b',2), ('a',1)]
13:05:08 <lambdabot> [('a',1),('b',2)]
13:05:23 <good_boy> 6 hours ago ^^
13:05:54 <Cale> > let comparing p x y = compare (p x) (p y) in sortBy (comparing snd) [('b',2), ('a',4) ('z',3), ('x',1)]
13:05:55 <lambdabot> Couldn't match `(Char, b)' against `t -> t1'
13:05:59 <Cale> > let comparing p x y = compare (p x) (p y) in sortBy (comparing snd) [('b',2), ('a',4), ('z',3), ('x',1)]
13:06:00 <lambdabot> [('x',1),('b',2),('z',3),('a',4)]
13:06:10 <xerox> @yow
13:06:11 <lambdabot> World War Three can be averted by adherence to a strictly enforced
13:06:11 <lambdabot> dress code!
13:07:01 <xerox> At least in lambdabot's eval we could define those convenience function - we do import the covenient modules as well now.
13:07:13 * monochrom is depressed. unlit throws away all my comments!
13:07:42 <Cale> xerox: It's in Data.Ord in CVS.
13:08:00 <norpan> hi
13:08:03 <Cale> > sortBy (comparing snd) [('b',2), ('a',4), ('z',3), ('x',1)]
13:08:04 <lambdabot>  Not in scope: `comparing'
13:08:14 <xerox> Cale: That's nice!
13:09:21 <DeliQ> @seen Phyx
13:09:21 <lambdabot> I haven't seen Phyx.
13:10:37 * SamB doesn't think he wants to know what Inform 7's "can't eat clothing without removing it first" rule is for...
13:12:58 <good_boy> unexpected Symbol snd
13:17:10 <Cale> good_boy: can you paste your code?
13:17:14 <Cale> lisppaste2: url
13:17:15 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:19:22 <lisppaste2> good_boy pasted "Sort tuple list" at http://paste.lisp.org/display/19867
13:19:30 <norpan> i've just tried my new soda siphon by making a gin fizz
13:19:34 <norpan> good stuff
13:19:46 <mahogny> ethanol abuse! :o
13:19:48 <good_boy>  http://paste.lisp.org/display/19867
13:20:02 <sieni> norpan: not for inhaling N_2O?
13:20:22 <norpan> sieni: no, it's CO2 :)
13:20:29 <good_boy> ip (createCharList a []) (createIntList (createCharList a []) a []) returns a tuple list
13:20:32 <good_boy> zip*
13:20:44 <sieni> norpan: well, you can get N_2O in capsules as well ^_^
13:20:52 <norpan> i know
13:20:53 <good_boy> and that cant be the source of the problem...
13:23:23 <psi> sieni: it's good stuff :-)
13:23:42 <good_boy> so?!
13:26:43 <SamB> oh, huh.
13:27:06 <Cale> good_boy: you have a spurious 'in'
13:27:28 <Cale> actually, everything after the 'in' is unnecessary too
13:28:05 <Cale> then you'll get a type error, since you're applying sortBy to too many parameters
13:28:22 <good_boy> Cale: I just fixed it
13:28:26 <good_boy> ^^
13:29:07 <good_boy> but i still have some questions regarding how the problem is solved...
13:29:21 <good_boy> what is p in comparing p x y?
13:29:39 <Cale> a function to extract the component which will be compared
13:29:58 <Cale> it could be anything, in this case, it extracts the second component of the pairs
13:30:38 <good_boy> how does the interpreter know that we want to extract the second component of the pairs?
13:30:54 <good_boy> comparing snd?
13:30:59 <Cale> well, you're passing snd for p
13:31:05 <good_boy> oh
13:31:26 <good_boy> i see.
13:32:18 <good_boy> thank you
13:32:58 <Cale> no problem
13:38:13 <xerox> Yawn.
13:41:24 <palomer> <:o
13:48:30 <cge> Has anyone here used the literate haskell mode in vim? I can't seem to get the latex highlighting to stop clobbering the haskell highlighting.
13:49:06 <CosmicRay> hmm, is there some better way to write this:
13:49:08 <CosmicRay> main = interact $ \(x:"END-OF-DATA":y:"END-OF-DATA":_) -> y
13:49:15 <CosmicRay> and by better, I mean a way in which it compiles ;-)
13:49:37 <CosmicRay> I want to extract the stuff between END-OF-DATA and END-OF-DATA from stdin and write it to stdout
13:50:26 <kosmikus> there's exactly one line in between the two, and exactly one line before the first?
13:50:27 <cge> CosmicRay: Can you use : like that? I thought it was a -> [a] -> [a].
13:50:29 <xerox> Are x and y lists in your dream?
13:50:39 <CosmicRay> cge:no, I can't.
13:50:41 <xerox> cge: nope.
13:50:48 <CosmicRay> I was hoping there was some elegant way to do this though ;-)
13:50:50 <CosmicRay> xerox: yes ;-)
13:51:06 <xerox> CosmicRay: kosmikus' question holds (-:
13:51:19 <CosmicRay> kosmikus: any number of lines betwee, before, and after.
13:51:45 <xerox> Have you considered using Parsec?
13:51:48 <kosmikus> xerox: not really, I was assuming [String] -> [String] for interact, which isn't true anyway
13:51:54 <jlhamilton> is there a way to negate the compare function? something like "not $ compare 3 5"?
13:52:07 <CosmicRay> the magic string may occur in the middle of a line as well.
13:52:09 <xerox> kosmikus: I thought you were for suggesting an unlines.
13:52:11 <CosmicRay> kosmikus: parsec seems overkill...
13:52:15 <sieni> jlhamilton: ?
13:52:20 <kosmikus> xerox: implicitly, yes ;)
13:52:22 <sjanssen> jlhamilton: flip compare
13:52:25 <xerox> CosmicRay: I don't think so, I think it would be a two-liners.
13:52:32 <sjanssen> > flip compare 3 5
13:52:33 <lambdabot> GT
13:52:39 <CosmicRay> kosmikus: oh?
13:53:02 <norpan> hmmm, who is ralejs by the way, he recognised me from the paper
13:53:25 <sieni> sjanssen: strictly speaking that does not negate it, since the negation of < is >=, not >
13:53:35 <kosmikus> CosmicRay: but "END-OF-DATA" is on a line of its own?
13:53:46 <jlhamilton> sjanssen: yeah, that works.  thx
13:54:06 <sieni> > not $ compare 4 4
13:54:06 <lambdabot> Couldn't match `Bool' against `Ordering'
13:54:18 <sieni> > not $ (<) 4 4
13:54:19 <lambdabot> True
13:54:35 <sieni> > flip (<) $ 4 4
13:54:36 <lambdabot>  add an instance declaration for (Num (t -> a))
13:54:48 <CosmicRay> kosmikus: not necessarily
13:54:49 <xerox> > flip (<) 4 4
13:54:50 <lambdabot> False
13:54:56 <CosmicRay> lines are pretty much irrelevant
13:54:58 <ralejs> norpan: My name IRL is Josef Svenningsson.
13:55:05 <norpan> jasså
13:55:13 <norpan> jag tänkte att det var nån balt
13:55:18 <sjanssen> sieni: there isn't a negation for Ordering
13:55:19 <ralejs> :-)
13:55:45 <xerox> CosmicRay: in these situations I used to try a regexp, figure out that was really an overkill, and falling back to the beloved Parsec.
13:55:46 <sjanssen> sieni: like you said "not GT" means LT or EQ, but we can't encode that in an Ordering
13:55:51 <zer0`> > not True
13:55:52 <lambdabot> False
13:56:28 <norpan> http://www.chalmers.se/cee/SV/avdelningar/konstruktionsteknik/personal/tepfers-ralejs/tepfers-ralejs/
13:56:50 <sieni> sjanssen: O RLY?
13:56:54 <kosmikus> CosmicRay: at least at the beginning of a line?
13:57:00 <sieni> > (\x y z -> not (x y z)) (<) 5 2 
13:57:01 <lambdabot> True
13:57:11 <CosmicRay> kosmikus: the end marker is guaranteed to be, but not the start marker.
13:58:01 <xerox> sieni: yes - notCompare :: a -> a -> (Ordering,Ordering) -- if you want.
13:59:18 <kosmikus> CosmicRay: this is a naive solution assuming it's at the beginning of a line: interact (let cond = not . ("END-OF-DATA" `isPrefixOf`) in unlines . takeWhile cond . tail . dropWhile cond . lines)
14:00:49 <CosmicRay> ahh.
14:00:54 <CosmicRay> that is a good clue.
14:01:10 <CosmicRay> in fact, I know I can discard the entire line that has the magic token.
14:01:19 <xerox> Argh.  And Parsec would have been an overkill!?
14:01:46 <kosmikus> xerox: I haven't said that ;)
14:02:00 <LordBrain> i just discovered showString
14:02:02 * xerox throws lambdas at kosmikus 
14:02:16 <LordBrain> but i dont get it.. why not just use ++
14:02:16 <CosmicRay> it is annoying that there is not a "contains" function in the standard library.
14:02:29 <norpan> contains?
14:02:35 * kosmikus catches the lambdas and places them on his desk, next to the Lambda that's already there.
14:02:39 <CosmicRay> I have this in MissingH
14:02:44 <CosmicRay> > contains "Haskell" "I really like Haskell." -> True
14:02:44 <CosmicRay> > contains "Haskell" "OCaml is great." -> False
14:02:44 <CosmicRay> -}
14:02:44 <CosmicRay> contains :: Eq a => [a] -> [a] -> Bool
14:02:44 <CosmicRay> contains substr str = isJust $ find (isPrefixOf substr) (tails str)
14:02:45 <lambdabot>  parse error on input `->'
14:02:45 <lambdabot>  parse error on input `->'
14:03:08 <norpan> isSubStringOf
14:03:09 <norpan> ?
14:03:15 <LordBrain> > showString "One" "Two"
14:03:15 <lambdabot> "OneTwo"
14:03:26 <LordBrain> > "One" ++ "Two"
14:03:27 <lambdabot> "OneTwo"
14:03:32 <xerox> LoganH: it is a pattern.
14:03:43 <zer0`> > showString "One " "Two "
14:03:44 <lambdabot> "One Two "
14:04:11 <xerox> Uh.  Ooops.  Nevermind.
14:04:35 <sjanssen> LordBrain: we use things like showString to avoid O(n^2) complexity for repeated concatenations
14:04:37 <kosmikus> LordBrain: that's an internal trick to make the implementation a bit more efficient.
14:04:54 <LordBrain> oh
14:05:01 <LordBrain> hmmm
14:06:08 <LordBrain> is showString always more efficient?
14:06:28 <sjanssen> LordBrain: depends on how you use it
14:06:50 <sjanssen> checkout the Show class, especially showsPrec
14:13:14 <LordBrain> seems like it should be named catString or something...
14:13:48 <xerox> Well, all the show* functions return strings (some pass by ShowS, but that is.)
14:15:24 <cge> To convert an Integer to a Double, do I need to use realToFrac, or is there something easier?
14:15:58 <norpan> fromInteger
14:16:16 <cge> norpan: thanks
14:35:41 <work_metaperl_> norpan: I think its fromIntegral
14:36:04 <norpan> you think so
14:36:30 <norpan> both work
14:36:42 <norpan> @type fromInteger
14:36:43 <lambdabot> forall a. (Num a) => Integer -> a
14:36:48 <norpan> @type fromIntegral
14:36:49 <lambdabot> forall b a. (Num b, Integral a) => a -> b
14:37:26 <work_metaperl_> hmm
15:11:35 <xerox> ....an angel passed....
15:18:17 * Cale adds a Haskell implementation to the Wikipedia article for shell sort
15:18:27 <Cale> http://en.wikipedia.org/wiki/Shell_sort#Shell_sort_in_Haskell
15:19:26 <xerox> Cale: scary, what are those polynomials doing there?
15:19:31 <psi> am I right that the following function will cause a memory leak? ssToArray ss = mapM newCString ss >>= newArray 
15:19:43 <psi> because I can't free the original CStrings
15:19:52 <Cale> xerox: providing decent gap sizes for the algorithm
15:20:15 <xerox> Foo.
15:20:22 <dcoutts> Cale, ah so you've got an infinite list for the gaps :-)
15:20:47 <Cale> dcoutts: yep :)
15:21:00 <dcoutts> nicer than the C one with it's fixed list
15:21:20 <xerox> Thwap!
15:24:52 <hyrax42> is FilePath an alias for String?
15:25:05 <hyrax42> oh
15:25:09 <hyrax42> was on the enxt page
15:25:17 <hyrax42> sorry
15:25:59 <Cale> It's significantly slower than Data.List.sort and even the naive quicksort implementation (in the average case, though not the worst), but at least it's easy to read as far as Shell sort goes.
15:26:49 <Cale> and it's not horrible -- it sorts a list of 10000 random Ints in about 0.7s.
16:13:00 <vincenz> mahogny: ping
16:16:56 <JohnJohnS> Hey
16:19:20 <dcoutts> hello JohnJohnS 
16:19:51 <dcoutts> @localtime dons
16:19:52 <lambdabot> Local time for dons is Thu May 11 09:15:48 2006
16:20:08 <JohnJohnS> How are you dcoutts?
16:20:24 <dcoutts> fine thanks
16:20:30 <dcoutts> learning haskell?
16:21:27 <JohnJohnS> Slowly.. Im new to functional programming.
16:21:41 <vincenz> it's great :)
16:21:48 <JohnJohnS> Can't get much more functional than Haskell ;)
16:21:52 <dcoutts> quite
16:21:59 <xerox> Goodnight.
16:22:04 <dcoutts> g'night xerox 
16:24:28 <audreyt> @localtime audreyt
16:24:31 <lambdabot> Local time for audreyt is Thu May 11 01:24:06 2006
16:25:12 * vincenz is considering making a planner software in haskell
16:25:16 <vincenz> there's nothing good around for linux :*
16:25:25 <vincenz> I mean... Planner, sure it's great, but it can't even schedule!
16:25:42 <vincenz> instead it just shows my schedule as being red, thereby giving me > 100% load
16:26:57 <vincenz> would be cool if you could tell it what the minimum schedulable resource is (for instance 1/2 day to stop too frequent context switching) and have it generate a schedule
16:28:01 * vincenz sighs as still noone has answered his msg to haskell-cafe regarding dynamically stackable monads
16:29:55 <Lemmih> I doubt you really want dynamically stackable monads.
16:30:01 <eivuokko> vincenz, when using monad, it is common to use special properties or functions that monad has.  Stacking monads dynamically seems a bit..pointless.
16:30:12 <vincenz> It's not
16:30:57 <vincenz> anyone know a good project management app for linux?
16:31:01 <vincenz> just something to put in dependencies
16:31:03 <vincenz> time estimates
16:31:07 <vincenz> and have it generate a schedule
16:31:16 <vincenz> mahogny told me about planner, but it doesn't do scheduling
16:31:31 <vincenz> it just schedules things based on dependencies, not based on resource contraints ( the fact that I can only do 100% work)
16:31:48 <hyrax42> sorry vincenz 
16:31:51 <hyrax42> sounds nifty though
16:32:01 <vincenz> I mean it's not that complex
16:32:07 <vincenz> no more complex than instruction scheduling on a proc
16:32:09 <hyrax42> but maybe a little more work than most people want to deal with
16:32:09 <vincenz> which is a known problem
16:32:21 <hyrax42> to get use of it
16:32:56 <mahogny> vincenz, I ended up writing my own code for when I wanted to put my schedules together. I know no program that otherwise take resource constraints into account
16:33:19 <mahogny> half the reason you can't have resources is because it's semi-complex
16:33:34 <vincenz> mahogny: what lang?
16:33:52 <audreyt> http://ganttproject.sourceforge.net/ surely?
16:33:59 <mahogny> vincenz, haskell, GLPK, but it's a quite specialized beast. prolly not what you want
16:34:44 <Pseudonym> When I was doing honours, we had a project to solve critical path problems with constraints.
16:35:05 <Pseudonym> The machine we were all using was brought to its knees by twenty constraint logic programs trying to solve an NP-hard problem.
16:35:06 <vincenz> it ain't complex
16:35:17 <vincenz> just do an ALAP 
16:35:20 <vincenz> err
16:35:21 <vincenz> ASAP
16:35:27 <vincenz> actually you could prolly make that an option
16:35:32 <Pseudonym> That's not optimal.
16:35:44 <Pseudonym> Though it's provably within a constant factor, I believe.
16:36:53 <mahogny> anyone know if there is a better alternative to graphviz?
16:37:31 <JohnJohnS> I had to do a lot of hard computation crap for compsci classes last year. 
16:37:43 <JohnJohnS> Sucks, because in AI everything is pretty much NP-hard
16:37:46 <mahogny> maybe just me, but the graphs graphviz outputs suck
16:37:54 <Pseudonym> In AI, everything is a heuristic.
16:38:07 <audreyt> how is that different from reallife? ;)
16:38:33 <mahogny> real life; you NP-complete semi-discrete realtime optimization problem :P
16:38:45 <JohnJohnS> hah
16:38:58 <mahogny> ...under uncertainity
16:39:13 <Pseudonym> In Soviet Russia... never mind.
16:39:18 <audreyt> ...with an exploratory problem space
16:39:53 <JohnJohnS> "In Soviet Russia, you don't complete the NP, the NP completes you!
16:39:55 <JohnJohnS> "
16:40:01 <audreyt> JohnJohnS++
16:40:51 <JohnJohnS> :P
16:42:13 * JohnJohnS tosses Python aside
16:42:17 <JohnJohnS> Time to learn haskell
16:42:22 * JohnJohnS cracks knuckles
16:42:24 <mahogny> good choice
16:42:31 <JohnJohnS> If anyone needs me, I'll be in deep meditation. 
16:43:00 <sh10151> remember, types only punish you because they care about you
16:43:08 <mahogny> noobs usually are in deep shock rather when they learn haskell. this is an odd case :)
16:43:09 * vincenz hmms
16:43:10 <sh10151> they don't want to see you get hurt
16:43:15 <vincenz> I think I'm gonna make a project planner app in haskel
16:43:25 <vincenz> see if I can't throw something together this weekend :)
16:43:28 <mahogny> vincenz, lots and lots of work
16:43:31 <vincenz> nah
16:43:37 <vincenz> use lazy haskell
16:43:41 <mahogny> lol
16:43:44 <vincenz> takeWhatIsNeed $ generateCode
16:43:50 <sh10151> my method
16:43:54 <mahogny> well, you don't need a GUI
16:43:59 <sh10151> list task dependencies
16:44:02 <sh10151> pipe through tsort
16:44:03 <vincenz> mahogny: GUI is the easiest part
16:44:04 <sh10151> job done
16:44:06 <sh10151> :-P
16:44:11 <mahogny> vincenz, still takes a lot of time
16:44:16 * vincenz cooks GUIs in a day 
16:45:18 <vincenz> each task will have a deadline: as late as possible, as soon as possible, before XXX.  each task will have dependencies, each task will have a initial workload estimate, amount of work done in % and amount of work done in days (such that tasks may expand if it's seen they'll take longer)
16:45:24 <Pseudonym> The actually scheduling in Haskell will be easy.
16:45:29 <vincenz> and maybe have it smart enough such that it notices your typical fudge factor
16:45:38 <vincenz> and schedules stuff to have that much slack
16:45:41 <Pseudonym> You return a lazy list of feasable schedules, and take the best out of the first N.
16:45:45 <Pseudonym> Where N is configurable.
16:45:48 <stepcut> vincenz: sweet!
16:45:57 <vincenz> shouldn't be too hard
16:46:00 <vincenz> just keep a typical % overrun
16:46:04 <vincenz> and use that for slack estimation
16:46:29 <vincenz> that would be great :)
16:46:31 <Pseudonym> Perhaps use the "as soon as possible" algorithm first, and use that to filter the feasable schedules.
16:46:41 <vincenz> Pseudonym: yeah, asap is the best
16:46:46 <Pseudonym> No, it's not best.
16:46:52 <vincenz> it is for people
16:46:59 <vincenz> as it's not certain how much you will overrun
16:47:16 <Pseudonym> ASAP is a good first guess, though.
16:47:23 <mahogny> when I plan my work manually, I prefer a version of windowed SJF
16:47:25 <Pseudonym> Actually, an annealing algorithm might be fun.
16:47:25 <vincenz> well ALAP is dangerous
16:47:40 <vincenz> imagine scheduling 1 week to write a paper the week before the deadline
16:47:47 <vincenz> and finding out 1 week was too optimistic
16:47:57 * vincenz snickers
16:48:08 <mahogny> vincenz, then you still have another week to spare. but few ppl use it well :)
16:48:24 <vincenz> erm, no I meant it automatically schedules it alap, aka the week before submission
16:48:36 <vincenz> overrun can become costly then
16:48:47 <Pseudonym> Although annealing algorithms have almost all been replaced by genetic algorithms these days.
16:48:54 <mahogny> the other week=you normally don't use schedule the nights. those are slack :)
16:48:58 * Pseudonym wonders how you'd breed two schedules
16:49:09 <mahogny> Pseudonym, there are several ways
16:49:11 <vincenz> it'd be cool if you could then drag stuff
16:49:13 <vincenz> back and forth
16:49:18 <vincenz> and use these as extra constraints
16:49:27 <vincenz> (I'd like to do that first)
16:49:31 <Pseudonym> mahogny: I'm all ears.
16:49:37 <Pseudonym> Or eyes in this case, since you're typing.
16:50:05 <mahogny> Pseudonym, the simplest way is to just use permutation pairs
16:50:23 <vincenz> Pseudonym: well ... you know that you can schedule anything anywhere between ASAP and ALAP... for each task keep a 0-1
16:50:30 <Pseudonym> Right.
16:50:31 <vincenz> 0 = ASAP, 1 = ALAP
16:50:36 <Pseudonym> But ASAP isn't necessarily optimal.
16:50:39 <vincenz> no
16:50:41 <Pseudonym> When you have resources involved.
16:50:43 <vincenz> but it's the earliest deadline
16:50:55 <Pseudonym> Oh, you mean ASAP ignoring resources?
16:50:58 <vincenz> gen is then just swapping factors, mutating them and checking for feasibilit
16:50:59 <vincenz> Pseudonym: yeah
16:51:08 <Pseudonym> Right.
16:51:14 <vincenz> purely on task-dependencies
16:51:29 <Pseudonym> That's like how the simplex algorithm gives you a bound on the corresponding integer linear programming problem.
16:51:39 <vincenz> been too long since I saw simplex
16:51:46 <vincenz> hmm
16:51:49 <vincenz> if I made the framework
16:51:59 <vincenz> would you guys be interested in collaboration if I put the darcs repo up?
16:52:46 <Pseudonym> Sure, time permitting.
16:52:50 <vincenz> you could prolly give each task a compression factor
16:52:55 <vincenz> stating how much you could gain by overtiming
16:52:58 <Pseudonym> (Which may actually be a euphemism for "no".)
16:53:28 <vincenz> funk, a euphemism...
16:53:31 <vincenz> funky even
16:53:35 <vincenz> it starts with a vowel yet it's 'a'
16:53:52 <vincenz> gotta love the regular laws of english
16:55:44 <hyrax42> hour
16:56:17 <vincenz> yep
16:56:26 <hyrax42> eh, I don't see what's so hard
16:56:28 <vincenz> but that's cause the 'h' is silent
16:56:31 <hyrax42> it's a phonetic rule
16:56:36 <hyrax42> not an orthographic one
16:56:42 <vincenz> ah right
16:56:45 <vincenz> youfeemism
16:56:51 <hyrax42> yup
16:56:58 <hyrax42> and there are more than five vowels in english
16:57:00 <hyrax42> phonetically speaking
16:57:07 <vincenz> well..given how pronounciation of english ain't straight forward
16:57:13 <hyrax42> yeah
16:57:21 <hyrax42> well beats french
16:57:23 * dcoutts sends more lazy fps patches to dons 
16:57:23 <vincenz> might be tricky for foreigners
16:57:37 <hyrax42> actually I'm not even sure it does
16:57:38 <hyrax42> :o
16:57:47 <hyrax42> fps?
16:57:52 <vincenz> I think french pronounciation is more straightforward
16:58:08 * vincenz is going to toronto in july \o/
16:58:31 <hyrax42> from?
16:58:41 <vincenz> belgium
16:58:44 <hyrax42> ah nice
16:58:49 <vincenz> ICME conference
16:58:55 <hyrax42> ME?
16:58:59 <hyrax42> mechanical engineering?
16:59:03 <vincenz> multimedia and embedded systems
16:59:07 <hyrax42> ah
16:59:10 <hyrax42> well I tried
16:59:16 <vincenz> erm
16:59:20 <vincenz> Multimedia & Expo
16:59:37 <vincenz> http://www.icme2006.org
17:00:09 <hyrax42> @index zipWith 3
17:00:09 <lambdabot> bzzt
17:00:19 <hyrax42> @index zipWith3
17:00:20 <lambdabot> Data.List, Prelude
17:01:14 <vincenz> dcoutts: ping
17:02:11 <dcoutts> vincenz, I'm about to go to bed, it'd better be quick
17:02:18 <vincenz> dcoutts: familiar with outlook?
17:02:28 <vincenz> dcoutts: any widget that is like that, with the icon box on the right?
17:02:30 <Pseudonym> BRB
17:02:33 <dcoutts> by MS?
17:02:35 <vincenz> no
17:02:38 <vincenz> for gtk2hs
17:02:47 <dcoutts> no you'll have to explain what it looks like
17:02:58 <vincenz> basically on the left you have a bar with icons
17:03:00 <dcoutts> is it like a GtkIconView?
17:03:02 <vincenz> each gives a different tab
17:03:11 <dcoutts> hmm
17:03:23 <dcoutts> tab or seperator?
17:03:27 <vincenz> so it's like a tabbed window, but instead on the left it's a set of icons
17:03:28 <dcoutts> tab like a notebook?
17:03:36 <vincenz> instead of a set of tabs at the top
17:04:07 <dcoutts> I don't quite see
17:04:10 <dcoutts> any pics?
17:04:44 <vincenz> yep
17:04:49 <vincenz> http://www.evenhigh.com/web_site/Outlook%20Express.jpg
17:05:15 <vincenz> each of the icons to the left leads to another view on the right
17:26:47 <dcoutts> vincenz, ok that could be done with a GtkIconView
17:26:58 <vincenz> alright, thx
17:27:18 <dcoutts> vincenz, then when an icon is selected you'd have code to switch the view in the other pane
17:27:25 * vincenz nods
17:27:32 <vincenz> I was afraid of that
17:27:33 <dcoutts> eg by using a notepad container with hidden tabs
17:27:53 <dcoutts> ie you'd do the switching programatically in response to selecting different icons
17:28:10 <dcoutts> not too hard I'd say
17:28:17 <dcoutts> the switching I mean
17:28:26 <dcoutts> I've never used an IconView however
17:28:36 <dcoutts> I expect there may be a few wrinkles
17:28:48 * dcoutts goes to bed
17:28:50 * vincenz nods
17:28:53 <vincenz> dcoutts: thank you
17:29:00 <dcoutts> np, good luck :-)
17:36:44 <stepcut> dcoutts: did you see I uploaded a ghc arm tarball?
17:47:16 <dons> moin
17:48:42 <eivuokko> dons, Hiya.  What did you think of the generate-patch?  Too suspicious?
17:49:44 <vincenz> dcoutts: hiya
17:50:25 <eivuokko> There is now mmap-style function in Win32-package for ByteString, btw ;)
17:51:08 <dons> oh, very cool!
17:51:27 <dons> eivuokko: too suspicious. no. but I want to look at how Simon M does the blocking on handles first.
17:51:51 <dons> i think its the right direction, and we should add this functionality
17:52:21 <eivuokko> dons, Oh, I was too lazy to do that.  If it's some simple stuff please tell me, and if it's complex tell me read myself ;)
17:52:36 <dons> :)
17:54:19 <eivuokko> It's actually pretty interesting...how to get guaranteed safety against HeapOverflow and StackOverFlow...I'm fairly sure block doesn't block them.
18:17:34 <hyrax42> flip only interchanges the first 2 arguments of a function?
18:17:55 <dons> ?type flip
18:17:56 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
18:28:21 <vincenz> @where dcouts
18:28:21 <lambdabot> I know nothing about dcouts.
18:28:22 <vincenz> @where dcoutts
18:28:22 <lambdabot> I know nothing about dcoutts.
18:28:54 <araujo> Hi all
18:31:11 <dons> hi araujo 
18:31:29 <araujo> dons, hello!, how your code goes?
18:33:02 <dons> oh, busy as usual
18:33:50 <araujo> :-)
19:16:51 <sethk> dons, using our server class, we have (for example):  (runServer hclient :: IO FinalizeServer) >> return ()
19:17:03 <sethk> is it possible to make FinalizeServer a parameter?
19:17:48 <sethk> dons, Here it's trivial but the actual function is more complicated, with some exception handling and such
19:18:12 <LordBrain> what is that you're working on sethk?
19:18:36 <sethk> LordBrain, It's some manufacturing test and control software
19:19:08 <sethk> LordBrain, dons helped me with a set of classes to create clients and servers
19:19:58 <LordBrain> what is being manufactured?
19:20:14 <sethk> firewall/routers
19:25:05 * vincenz hmms
19:25:26 <vincenz> anyone ever made a parsec combinator that eventually returns some sort of monadic action?
19:27:16 <dons> we could make FinalizeServer a parameter, I think. what were you envisaging?
19:27:18 * vincenz wonders if he should first generate an AST and type it
19:29:07 <sethk> dons, I'm not sure how to make that a parameter.  I can't use a type variable there, right?
19:31:03 <dons> oh, you mean a type parameter
19:31:05 <dons> ?
19:31:09 <sethk> right
19:31:19 <dons> what kind of syntax did you want? an example?
19:31:38 <sethk> that line I pasted occurs several times, and the only difference is the type
19:32:11 <sethk> really I want to know how to do it in general.  Here it saves only a line but I think similar things come up frequently
19:32:34 <sethk> dons, If it's a parameter, I can then make a general handleConnection function
19:32:52 <sethk> dons, I'll paste some code.  I thought I didn't need to, but thinking about it ... :)
19:33:05 <dons> well, currently the IO return type above is used to instantiate the whole server type, right?
19:33:16 <sethk> right.  
19:33:34 <sethk> let me show you the code, so you'll see where it occurs
19:33:35 <dons> and you want to do what? I think I need an example of what you'd like to write.
19:33:37 <dons> yeah.
19:38:12 <lisppaste2> sethk pasted "generalize?" at http://paste.lisp.org/display/19877
19:40:12 <dons> ok. just have to finish something i'll have a look in about 20 - 30 minutes
19:40:24 <sethk> dons, whenever you get time, thanks.
19:44:39 <lumi> How can I make a program (actually it's yi) build against a particular version of a package (fps-0.2)? I tried hiding all the newer versions in ghc-pkg and that didn't seem to help
20:12:27 <LordBrain> @index either
20:12:27 <lambdabot> Data.Either, Prelude
20:56:25 <akemp> @seen syntaxninja
20:56:26 <lambdabot> I saw syntaxninja leaving #haskell and #haskell-blah 4 hours, 21 minutes and 46 seconds ago, and .
22:23:29 <hyrax42> @index +++
22:23:30 <lambdabot> Control.Arrow, Text.Html, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
22:46:14 <hyrax42> @index enumFromThenTo
22:46:15 <lambdabot> Prelude
23:04:24 <dons> ?karma+ QuickCheck -- spotted a bug in Lazy.foldr
23:04:24 <lambdabot> QuickCheck's karma raised to 5.
23:20:06 <arrummzen> I am trying to do the example program "let fac n = if n == 0 than 1 else n * fac (n-1)" and I get <interactive>:1:29: parse error on input 'else'.
23:20:41 <lumi> "then"?
23:20:56 <lumi> With an e
23:21:03 <arrummzen> oh, ooops...
23:22:16 <dons> ?karma+ QuickCheck -- spotted another bug
23:22:17 <lambdabot> QuickCheck's karma raised to 6.
23:30:49 <Cale> @karma- bug
23:30:49 <lambdabot> bug's karma lowered to -1.
