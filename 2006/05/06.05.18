00:02:00 <lisppaste2> ravelo annotated #19951 with "observacion" at http://paste.lisp.org/display/19951#2
00:02:03 <dons> joelk, what kind of filter are you doing? it is a one liner, or something more   complex?
00:02:58 <dons> hmm. is that lisppaste spam again?
00:04:08 <joelk> very simple. 1) split the line with wrds, 2) one of fields will indicate whether I am interested in this line or not, 3) produce Just MyData or Nothing as appropriate, 4) catMaybes.
00:04:20 <joelk> s/wrds/words/
00:05:06 <dons> got it working?
00:05:20 <joelk> not on the 1.5G file yet :-)
00:05:34 <dons> seems highly doable, with the new hGetLines, at least
00:06:09 <dons> oh, but you want to build a new list of 3M Justs, right?
00:06:25 <joelk> yeah, but as I've mentioned here before, I'm quite stubborn. Won't give up until I know why my catch ain't catching.
00:06:31 <dons> probably better to avoid populating the list with Nothings, and use a foldl or something like that instead.
00:07:24 <dons> unless it can be done all lazily. maybe it can
00:08:41 <joelk> I thought it would be lazy... foldl not scanl?
00:08:49 <dons> joelk: you might be interested, I managed to filter every letter 'e' from a terabyte stream the other day, inside 8 hours. tr -d 'e' was 7hrs 50.
00:09:00 <joelk> oh no, obviously not scanl...
00:09:27 <dons> filter is probably enough to avoid the Nothings.
00:09:39 <giksos> hi guys, I have a question: why doesn't haddock allow to document instances? That would make sense, wouldn't it?
00:09:42 <dons> or a fused filter/map, using recursion
00:11:16 <joelk> sure, but a catMaybes . map (foo), foo :: ByteString -> Maybe MyData, seemed to involve the least typing.
00:11:51 <dons> yep.
00:12:04 <dons> what's the selector function look like, roughly?
00:12:13 <dons> switch on the first word, return the second?
00:12:55 <joelk> ok, so what I did was basically your getLines above, but with ss <- getLines `catch` const (return []), and I can't see what I'm missing.
00:13:30 <dons> hmm
00:17:51 <dons> here's my soln: http://www.cse.unsw.edu.au/~dons/tmp/lazylines.hs
00:18:31 <kzm> dons, I haven't measured this, and it is likely not an important issue, but have you measured the counting sort on (many) short strings?
00:18:42 <dons> oh, actually faster with catMaybes joelk.
00:19:21 <dons> kzm, yeah, I think sjanssen did a fairly complete benchmark of the behaviour
00:19:35 <joelk> cool.
00:19:40 <dons> joelk: here, tp://www.cse.unsw.edu.au/~dons/tmp/lazylines.hs, insert your own sel function
00:19:50 <dons> run in 11s on 256M input on my box
00:20:04 <dons> same as just doing wc -l on that file.
00:20:10 <joelk> @hoogle (a -> Maybe b) -> [a] -> [b]
00:20:11 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
00:20:21 <dons> even better,
00:20:23 <joelk> hah. don't I feel silly.
00:21:09 <dons> yeah, mapMaybe works fine. i updated the link above
00:21:49 <joelk> Wait a second... last time I was here hoogle barfed on type classes...
00:22:04 <dons> nah, djinn perhaps?
00:22:12 <dons> hoogle used to barf on classes, i think it still does
00:22:13 <joelk> hmm...
00:22:18 <dons> @hoogle Eq a => a -> [a]
00:22:18 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
00:22:18 <lambdabot> Prelude.repeat :: a -> [a]
00:22:18 <lambdabot> List.intersperse :: a -> [a] -> [a]
00:22:22 <dons> oh, maybe not.
00:22:32 <azuroth> is there a quick and simple way to replace all occurrences of x with y in a list of files from the commandline, under linux?
00:23:13 <dons> for f in a b c d e ; do sed 's/x/y/' $f > $f.1 ; mv $f.1 $f ; done
00:23:20 <dons> s/x/y/g
00:23:46 <azuroth> wow, thanks
00:23:47 <kzm> tr x y
00:24:00 <dons> tr. i _always_ forget tr.
00:24:05 <kzm> :-)
00:24:27 <dons> when you've got sed, everything looks like a regex 
00:24:41 <dons> or something else about hammers and nails.
00:26:54 <mlh> the y command in sed does what tr does
00:29:09 <dons> joelk, i'm interested. did you get the 1.5G file working?
00:34:41 <joelk> ok, works for 826M now, checking 1.5G
00:34:55 <joelk> (works once again, that is)
00:35:30 <azuroth> I just went to go less ( svn diff ... ), then remembered I had to pipe instead :x
00:35:48 <dons> azuroth: so sad. bring on higher order shells!
00:36:18 <dons> I often write: map sed .. *
00:36:22 <dons> but it never works
00:36:49 <azuroth> hehehe :-)
00:42:14 <dons> joelk: i've got my lazylines.hs happily churning through 10G here :)
00:42:30 <Itkovian> meuning
00:49:40 <kzm> whee! 10x speedup for maximum (and, presumably, minimum)
00:50:42 <dons> kzm?
00:51:23 <norpan> wroom
00:52:12 <kzm> (for 8-bit charsets)
00:52:23 <kzm> Still much slower than c_maximum etc.
00:52:26 <kzm> :-)
00:52:48 <norpan> i still haven't figured out a case where you'd like to sort a string
00:52:59 <norpan> and in any case you could use bucket/radix sort
00:53:55 <kzm> It's part of the interface, norpan.  Passed on to us from our ancestors for generations.
00:54:04 * kzm dared not say "onto".
00:54:05 <norpan> i suppose something like frequency = map length . group . sort
00:54:29 <kzm> Eh.. but you calculate the frequencies as a part of the process.
00:54:44 <norpan> when doing bucket sort yes
00:54:59 <norpan> it was just a case where you might use sort
00:55:11 <kzm> True.  You probably do not want buckets (or at least not one-char buckets) for larger charsets.
00:55:37 <kzm> for 256 chars, it is a win, even for short strings (sez dons)
00:56:00 <norpan> i would guess so
00:56:30 <norpan> how was the interface for bytestring determined? just all functions in Data.List?
00:56:49 <kzm> Are you still developing UTF8?  In my version, there are still a heap of 'viaList' functions.
00:57:04 <dons> norpan: we actually added it because someone needed it for some introductory thing.
00:57:15 <norpan> well, i haven't done anything since last friday
00:57:17 <kzm> It was given unto the prophet dons in ancient times.
00:57:32 <dons> norpan: all the functions in Data.List, plus stuff needed in darcs, and in h4sh, and in yi, and in practice
00:57:36 <dons> oh, and in hmp3
00:57:44 <dons> and pugs too
00:57:46 <norpan> i see
00:57:57 <kzm> I can start to improve these functions, but I'd rather not introduce more darcs conflicts than I must.
00:58:11 <azuroth> woot, I'm up to revision four. having a svn server rocks.
00:58:16 <kzm> dons, what?  No stone tablets? :-)
00:58:25 <dons> sjanssen: the new replicate fails when defaultChunkSize == 1.
00:58:44 <dons> actually, it produces an invariant violation. let's see...
00:58:57 <norpan> kzm: i think the way to go is to get a good benchmark file and then see if we have to optimize the functions or if viaList is good enough (if we get fusion)
00:59:48 <norpan> i would suspect that for UTF-8, viaList is often good enough
00:59:51 <dons> sjanssen: ah, found it.
01:00:12 <kzm> Hmm... I'm not overly fond of that solution, but yes, maybe.
01:00:29 <norpan> kzm: not fond of it? why?
01:00:34 <kzm> Bench.hs is a bit too fair, I guess, in that it runs everything on the same data set.
01:00:45 <dons> too fair?
01:00:54 <dons> we do need QuickBench, don't we :)
01:00:59 <kzm> Yes.
01:01:00 <kzm> To both.
01:01:18 <kzm> Too fair in that sorting an UTF string is currently the decidedly worst number there.
01:01:27 <norpan> premature optimization is the root of all evil as a wise man once said
01:01:27 <kzm> But it isn't entirely clear that it matters.
01:01:31 <dons> harsh but fair :)
01:01:42 <kzm> Bah.  Fair, but misleading.
01:01:45 <dons> heeh
01:01:50 <dons> just comment it out then.
01:01:53 <norpan> sorting an UTF-8 string is probably done best via UCS and qsort
01:01:55 <shapr> azuroth: Tried darcs?
01:01:58 <dons> that's what i do for transpose and elems and inits :)
01:01:59 <norpan> or radix
01:01:59 <kzm> Just like girl.
01:02:25 <shapr> I just like girls too.
01:02:30 <kzm> Heh.
01:02:39 <kzm> The fair ones, or the misleading ones?
01:02:45 <azuroth> no, I haven't actually. I just chose subversion because it's got binary files and I'm familiar with the client
01:02:48 <shapr> Just girs :-)
01:03:21 <kzm> Well, they have many things to recommend them over sorting UTF8 strings, for instance.
01:03:23 <kzm> Never mind.
01:03:25 <shapr> azuroth: You might like darcs. If you get the urge to try it I can help you with it.
01:03:25 <norpan> i can't spend too much coding as i have a full time job doing other things and a full time wife
01:03:43 <azuroth> I wanted to get it up as quick as possible, because I had to justify the need to the other group members (in retrospect, it wasn't as hard to convince them as I thought it would be)
01:04:07 <dons> darcs has binary files. i don't understand the issue there.
01:04:14 <kzm> norpan, I'll see if I can fill in things, then?  I'll try to do frequent updates, in case you push stuff in your repo.
01:04:25 <norpan> kzm: sure
01:04:38 <norpan> but we really should try to get a good benchmark
01:04:53 <norpan> i'll scout for some good files
01:05:01 <azuroth> dons: I mean, that's why I chose svn over cvs. I chose it over darcs because I've at least used svn clients, but no darcs clients
01:05:06 <dons> surely someone must have written perl or python string benchmarks out there?
01:05:19 <dons> azuroth: fair enough.  cvs is stone age.
01:05:39 <dons> the client's no big deal, att least for darcs. they're trivial to pick up.
01:05:51 <norpan> dons: i would assume so yes
01:06:08 <dons> i wasn't able to find anything in a short search i did before writing Bench.hs
01:06:16 <dons> but a more thorough search may turn up something
01:06:38 <dcoutts> morning
01:06:42 <dons> morning dcoutts.
01:08:37 <shapr> azuroth: Darcs is easy to use, and easy to start with, and it gives you some amazing features. The only downsides to darcs are that it can be hard to build if you're not using binary packages, and in special cases it can freak out (extremely large files, repositories over several hundred mb, etc).
01:09:01 <kzm> One possibility for Bench would perhaps be to highlight numbers that vary significantly from the average?
01:09:26 <azuroth> I'll have to try it next time :-)
01:09:29 <dons> also, you might want to look at the new 'make plot' target, which graphs Bench.hs output
01:09:36 <flux__> a version control freaking out can be a very disheartening experience
01:09:39 <dons> kzm, which is roughly what you're saying, yeah?
01:10:16 <flux__> graceful failure less so, I hope that's what's happening ;)
01:11:33 <norpan> 10:06 < dons> morning dcoutts.
01:11:37 <kzm> dons, ahem.  Maybe.  I haven't been able to merge the 'plot' target.
01:11:40 <norpan> http://www.cl.cam.ac.uk/~mgk25/ucs/examples/
01:11:45 <norpan> stupid windows paste
01:11:55 <kzm> ...the patch, I mean.
01:12:11 <shapr> azuroth: Yeah, feel free to ask me questions about darcs when you get around to trying it.
01:13:21 <azuroth> I thought setting up subversion was going to be much harder than it was :D
01:13:35 <norpan> i'm going with mercurial
01:15:25 <thelsdj> i'm kinda stuck with svn since my boss requires visual studio.net integration from our revision control
01:18:20 <dcoutts> dons, I like the new Lazy.replicate. That's very cunning.
01:18:32 <dons> yeah, good idea.
01:18:35 <dons> ?karma+ sjanssen
01:18:35 <lambdabot> sjanssen's karma raised to 10.
01:18:45 <dcoutts> sjanssen, clever idea
01:19:22 <dons> reminds me a bit of kzm's filterByte = replicate . count
01:19:39 <dcoutts> dons, I see I was right when I said you needed to review my patches carefully :-) at least two bugs spotted...
01:19:53 <dons> :)
01:20:17 <azuroth> no test code? :-(
01:20:23 <dons> i took that as a real warnign. you don't normally say to review things carefully, so I assumed you must have been drinking ;)
01:20:44 <dcoutts> I was feeling a bit tired
01:21:02 <dons> anyway, all good.
01:21:07 <dcoutts> I'd been running too many confusing benchmarks
01:21:33 <dcoutts> and most of my changes kept making things run slower :-(
01:21:43 <dcoutts> I was awake when I did the groupBy fix.
01:21:52 <dons> hehe. yeah, that's a good one. nicely done.
01:21:55 <dcoutts> that was a subtle bug
01:22:42 <dcoutts> not even a bug necessarily, groupBy should only be used with an equivalence relation
01:22:51 <dons> it was hard to spot in the QCs too, since it was dependent on the generated function. so when I tested with == it was always fine.
01:23:00 <dons> yeah. its a bit dodgy
01:23:01 <dcoutts> yeah
01:23:13 <dcoutts> I tried (<) and got it to fail
01:25:40 <dcoutts> dons, are you convinced about the name 'elemIndex' ?
01:26:06 <dons> you mean, is it a good name?
01:26:11 <dcoutts> right
01:26:19 <dons> well, its in H98 List.hs, so it must be.
01:26:26 <dons> ;)
01:26:30 <dcoutts> oh, ok
01:27:04 <dcoutts> so that function is good for breakByte, but we need the opposite for spanByte
01:27:30 <dons> ah, right. but there's no memchr up to it.
01:27:44 <dcoutts> indeed
01:28:42 <dcoutts> I looked at the source code for memchr, it's cunning and complicated
01:28:54 <dons> oh ,really? /me peeps
01:28:56 <dcoutts> doing everything in 4 or 8 byte chunks
01:29:05 <dcoutts> well in glibc anyway
01:29:26 <dons>         do {
01:29:26 <dons>             if (*p++ == (unsigned char)c)
01:29:26 <dons>                 return ((void *)(p - 1));
01:29:26 <dons>         } while (--n != 0);
01:29:31 <dons> in BSD libc
01:29:48 <dons> 4 or 8 byte chunks ,eh? vincenz idea..
01:30:13 <dcoutts> in glibc it's implemented in i386/memchr.S
01:30:36 <dcoutts> though there's also a C version for other arches
01:30:36 <dons> oh, right. linux haxors
01:31:02 <dons> whereas the regents of the University of California were happy to stick to C.
01:31:30 <dcoutts> the C version is nearly as good at the .S version apparently, the advantage is that in assembler you can get at the carry status
01:31:38 <dons> ah. cunning
01:31:44 <dcoutts> which is useful for their algorithm
01:31:50 <dons> libc isn't the most beautiful prelude in the world
01:32:24 <dcoutts> sadly strstr requires null terminated strings, otherwise we could use that too
01:32:38 <dons> right. we need memfoos
01:32:47 <dcoutts> glibc has a very fast impl of that strstr
01:32:58 <dons> and there's no memrchr (was that it?) in bsd either.
01:33:14 <dcoutts> right, memrchr was a gnu thing
01:35:19 <dcoutts> we could use it or supply our own impl if it's not available, probably not worth the effort however
01:36:22 <dons> well, hmm. its fairly rarely used. we could keep it in mind though. you might want to make a comment, in case someone complains one day
01:36:30 <dons> then we have the option of adding memrchr
01:37:09 <dcoutts> ok
01:37:27 <dcoutts> I'm sending you another patch, to add findIndexOrEnd to the benchmark
01:37:37 <dons> cool
01:38:19 <dcoutts> dons, as an experiment, try this: do a couple runs as is and then change the order of findIndex/findIndexOrEnd and do a couple more runs
01:38:43 <dons> you think its cache, (could be in this case), or GC?
01:38:51 <dcoutts> notice how the timings are consistent for multiple runs, but not so when changing the order
01:38:58 <dcoutts> and notice how significant the change is
01:39:03 <dons> I suppose we could flush the cache with a bit of magic C between functions
01:39:07 * dcoutts darcs sends
01:39:42 <dcoutts> dons, were you talking before I arrived about findign suitable data for the test?
01:39:57 <dons> yeah.
01:40:02 <dcoutts> we need something where each function is taking at least half a second or so
01:40:28 <dons> yep
01:40:56 <dons> they're just too fast now.
01:41:04 <dons> when I started out, they weren't
01:41:10 <dcoutts> heh
01:41:11 <dcoutts> nice
01:41:45 <dons> pretty much everything's been rewritten since it came from darcs. i don't know of any code other than some io stuff that hasn't changed.
01:44:09 <dcoutts> dons, mind you some ops can't take very long. eg Lazy.replicate is now O(1)
01:45:08 <dcoutts> the advantages of a representation with a bit more indirection
01:45:33 <dons> yeah, we can get a nice graphical display of O(1), O(1/x n), O(n) andO(big n) now.
01:46:03 <dons> the problem is the O(n) stuff that looks like O(1) due to data issues
01:46:18 <dons> quite interesting, isn't it, how a few more pointers make everything simpler
01:50:30 <dcoutts> aye
01:50:38 <dcoutts> well, not simpler, but faster :-)
01:51:12 <dcoutts> that replicate is cunning; make one block and share it n/c times
01:51:43 <dons> yeah, its that kind of thing. very FP, if you ask me.
01:56:46 <kzm> Isn't is - strictly speaking - still O(n)?
01:57:12 <kzm> i.e. don't you need n/B blocks of (constant) size B?
01:57:16 <dons> its O(n/c * defaultChunkSize) or something.
01:58:09 <joelk> oh, dons, yeah it works now. thanks. (had to step out and help some undergrads for a bit)
01:58:41 <kzm> is "unslicing" used elsewhere as well?
01:58:46 <kzm> concat, for instance?
01:59:05 * kzm should read the source, but must drink his coffee first.
01:59:09 <dons> so its really O(1/c * n), which is a small O(n), I suppose.
01:59:43 <kzm> right.
01:59:55 <kzm> constants matter, too.
02:00:10 <dons> that's the benefit, several O(n) ops become O(1/c * n) usign the indirected representation in Lazy.hs
02:00:39 <dons> there's probably more opportunites too, we just need to think about them.
02:00:55 <dons> hmm. filterByte is another one..
02:01:00 <kzm> Anyway - it'd be neat if Bench did scaling analysis as well (how much room you got in that thar plot?)
02:01:15 <dons> since its Lazy.replicate . Lazy.count
02:01:20 <kzm> f fps; map f (lines fps); map f (words fps)
02:01:22 <kzm> or something.
02:02:01 <dons> sounds like a job for ... QuickBench! faster than a speeding hugs, able to leap tall type annotations in a single bound!
02:02:07 <kzm> currently it is heavily weighted towards one huge string.
02:02:09 <kzm> Yes.
02:02:25 <kzm> I can't wait to read the ICFP/HW paper.
02:02:51 <dons> hehe
02:03:07 <kzm> The Quick brown Bench jumped over the lazy bum.  (How does the typing excercise go again?)
02:03:13 <dons> i need students to work on this stuff for me.
02:03:36 <kzm> What?
02:03:53 <kzm> You're not happy with us IRC people?
02:03:54 <azuroth> I'll become your student, dons, if you get me in. ;-)
02:04:00 <kzm> :-)
02:04:28 <dons> irc people are super good, actually.
02:04:33 <dons> worth many students.
02:04:55 <xerox> @yow
02:04:56 <lambdabot> Do you guys know we just passed thru a BLACK HOLE in space?
02:04:57 <xerox> Cale - www.planarity.net
02:04:58 <kzm> To me they are worth many professors.  I have no FP people around me.
02:05:00 <xerox> Howdy dons!
02:05:21 <dons> heya xerox
02:05:31 <shapr> To me they are worth many coworkers. I'm self-employed.
02:05:34 <Cale> xerox: yeah, I played that for quite a while back a couple of months ago
02:06:06 <shapr> Cale: Hey, why not write your puzzle(s) up as Volity games?
02:06:21 <dons> shapr: yeah, its like having support staff, in a way.
02:06:27 <Cale> http://cale.yi.org/autoshare/Level-20.png
02:06:32 <Cale> Volity?
02:06:36 <dons> we all get support staff and consultants .. for free.
02:06:43 <shapr> But better, support staff usually have that job because they can't do any other.
02:07:22 <shapr> Cale: volity.org - UI is built with SVG and ECMAScript, and the state transformer uses Jabber-RPC
02:07:26 <dons> yeah, and someone getting help now, will be offerring help later.
02:07:39 <shapr> Right, peer to peer help :-)
02:08:14 <shapr> The Gamut client for Volity downloads the svg & javascript and sticks them on the screen, and then makes calls to the Jabber-RPC rules.
02:08:28 <xerox> Cale - haha I stopped 25 levels before (:
02:08:30 <shapr> Sadly, Gamut is written in Java, meaning I don't want to hack on it.
02:10:50 <vincenz> or make it a game that can be put onto the google personalized homepage
02:11:18 <vincenz> Cale: 34 minutes????
02:12:17 <Cale> vincenz: I can't recall if I was working on it the whole time
02:13:17 <vincenz> uhuh
02:13:31 <vincenz> that's just a diplomatic way of saying "I'd prefer not sharing that I wasted that much time" :D
02:13:43 <Cale> Oh, I can easily waste that much time
02:13:58 <vincenz> what linux is that?
02:14:03 <Cale> debian
02:14:06 <vincenz> ah
02:14:22 <Cale> I'm running enlightenment as my WM for Gnome.
02:15:39 <int-e> hmm. planarity. I have a level 22 screenshot: http://fuchur.t-link.de/~bf3/l22.jpg
02:15:49 <int-e> Cale: have you seen gplanarity?
02:16:03 <vincenz> can't you do a screenshot
02:16:06 <azuroth> wow, fun.
02:16:07 <vincenz> detect the structure
02:16:13 <vincenz> and then make haskell do it?
02:16:30 <Cale> int-e: no
02:16:34 <azuroth> but I should be working!!!
02:16:37 <vincenz> int-e: holy cow
02:17:15 <int-e> Cale: it's a planarity clone written in C, using cairo. Very neat.
02:17:39 <Cale> after a while, it's just about how long you can carry out a tedious algorithm
02:17:59 <vincenz> Cale: what's the algo?
02:18:12 <int-e> and it has some more level generation algorithms, which generate slightly harder levels.
02:18:35 <int-e> vincenz: flatten the graph locally, basically.
02:18:38 <xerox> I found it tedious (read mechanic) after a while too.
02:18:49 <vincenz> int-e: and the algo for that?
02:18:57 <vincenz> bruteforce?
02:19:31 <Cale> vincenz: basically, find minimal cycles hanging off the part that you've solved, and push their vertices such that the edges don't overlap the solved portion.
02:19:34 <int-e> vincenz: err, which algorithm do you mean? I meant for solving - you start with a small polygon then arrange neighbouring vertices without overlap.
02:20:05 <int-e> vincenz: mind you, that's for manual solving. I'm not sure how I'd do it with a computer.
02:20:24 <vincenz> Cale: and where do you start?
02:20:25 <Cale> I also find it helpful to find a square near the beginning and push it to the outside
02:20:35 <vincenz> lol
02:20:36 <vincenz> http://cale.yi.org/autoshare/Level-50-ridiculous.png
02:20:40 <Cale> and then call that square solved
02:21:04 <Cale> yeah :)
02:21:10 <vincenz> can't even see the circles
02:21:12 <int-e> argh.
02:21:21 <vincenz> gotta say they render it quite nicely tho
02:21:25 <vincenz> very soft and smooth
02:23:03 <Cale> http://cale.yi.org/autoshare/griddler-30x30.png
02:23:10 <Cale> I've done a few of those
02:23:17 <Cale> they take a while
02:24:03 <shapr> I'd like to find puzzles like that that require two players.
02:24:16 <shapr> Maybe where half the puzzle is viewable by the other player?
02:25:21 <azuroth> hmm, that would be interesting...
02:25:44 <Saulzar_> Chess is a nice two player puzzle :)
02:25:47 <vincenz> so constraints constantly chang
02:25:52 <vincenz> Saulzar_: or go
02:25:56 <Cale> http://cale.yi.org/autoshare/client-server.png -- I found this in an actual paper. I can't recall which.
02:26:12 <int-e> ah, right. the evil thing about gplanarity was that some of the graphs aren't planar; the goal is then to minimize the number of intersections.
02:26:22 <vincenz> nice
02:26:28 <vincenz> looks like art from the 70s
02:26:28 <vincenz> http://cale.yi.org/autoshare/DensityPlot.png
02:26:44 <giksos> hi guys, I have a (philosophical) haddock question. Can anyone help?
02:27:02 <Cale> The client looks so sneaky, and the server so mindlessly unaware of what is about to happen.
02:27:06 <shapr> You must ask the question first.
02:27:07 <vincenz> hehehe
02:27:35 <giksos> (I tried once) Yeah, the question is, why doesn't haddock allow to document instances?
02:27:43 <shapr> Huh?
02:28:03 <vincenz> giksos: sure it does
02:28:47 <giksos> for instance, I'd like to describe, what a particular instance of Show does (how it shows itself), how do I do it?
02:28:47 <dons> hey giksos :)
02:28:52 <giksos> hey dons
02:29:18 <giksos> or I what to document the format that a particular read function expects
02:29:41 <Cale> vincenz: check this plot out http://cale.yi.org/autoshare/arithderiv.2.png
02:30:04 <vincenz> Cale: Or Susan
02:30:06 <vincenz> s
02:30:27 <vincenz> what's that?
02:30:33 <Cale> vincenz: heh, that was from a card which we made for my mom
02:30:43 <vincenz> no I mean arithderiv
02:31:12 <Cale> It's a plot of the first million values of the function d such that d(p) = 1 for p prime, and d(nm) = n*d(m) + m*d(n)
02:31:50 <Cale> It's called the arithmetic derivative
02:32:30 <xerox> Impressive (:
02:33:57 <norpan> what's the red line
02:34:20 <norpan> mean value?
02:34:53 <Cale> no, it's a particular bound where certain values of n cannot have a derivative lower than that.
02:35:12 <Cale> you'll notice that some of the "noise" cuts out there
02:35:21 <norpan> oh
02:35:51 <vincenz> Cale: how about the other red line?
02:36:03 <vincenz> the middle one
02:36:06 <vincenz> cause there's three
02:36:13 <Cale> that's the one I was talking about
02:36:23 <Cale> the other two are absolute lower and upper bounds
02:36:42 <vincenz> ah
02:37:02 <norpan> lower bound?
02:37:07 <giksos> absolute lower bound is always 1, not?
02:37:10 <vincenz> Cale: and what are the axes?
02:37:11 <Cale> for non-primes :)
02:37:18 <Cale> sorry
02:37:19 <giksos> ok
02:38:06 <Cale> vincenz: x from 1 to 10^6 (integer values only), and d(n) from 0 to 200000
02:38:47 <norpan> interesting function, what is it's context?
02:38:48 <vincenz> how can there be so many points then for early x's
02:39:24 <Cale> It's from 1 to 10^6
02:39:26 <norpan> vincenz: i suppose one x point is not one pixel :)
02:39:37 <vincenz> still
02:39:46 <Cale> note that I'm also cutting off the values at the top
02:40:09 <norpan> one pixel is approx 1000 x-points
02:40:10 <Cale> a million black dots is actually quite a few black dots.
02:40:19 <vincenz> Cale: and erm
02:40:30 <vincenz> d(8) = two possibilities?
02:40:36 <Cale> no, just one
02:40:45 <vincenz> how about.... 12?
02:40:52 <vincenz> 6*2  / 3*4
02:40:55 <Cale> it's a well-defined function :)
02:41:05 <vincenz> you factorize int n*m
02:41:11 <vincenz> but there can be many such
02:41:20 <Cale> sure, it doesn't matter which you pick
02:41:23 <vincenz> oh
02:41:31 <Cale> you're going to recurse anyway
02:41:47 <norpan> ah i see d(nm) = n*d(m) + m*d(n) that's the leibnitz derivative rule
02:41:48 <vincenz> basically
02:41:52 <Cale> yeah
02:42:03 <vincenz> Cale: d = sum of all mult of primesets -1 prime
02:42:24 <vincenz> so if d = a*b*c  : a*b + a*c + b*c?
02:43:43 <Cale> d(a*b*c) = d(a)*b*c + a*d(b*c) = d(a)*b*c + a*(d(b)*c + b*d(c)) = d(a) * b * c + a * d(b) * c + a * b * d(c)
02:44:18 <Cale> and if a,b,c are prime, then it stops there
02:44:21 <vincenz> let x = mult_i:0-n of p_i    => d(x) = Sum_i:0-n of mult_j:0-n/i of p_i
02:44:38 <vincenz> where O-n/i means all except i
02:44:58 <vincenz> and p_i are primes
02:45:08 <vincenz> and the last thing should be p_j
02:45:32 <norpan> d(0) and d(1) are both 0?
02:45:47 <norpan> otherwise the equation won't work
02:45:58 <Cale> sure, that's reasonable
02:46:46 <araujo> good morning
02:46:47 <Cale> you can also extend it to rational values via the quotient rule
02:47:21 <Cale> and there are funny problems involving "differential equations" on these
02:47:38 <norpan> d(1/p) = -(1/p^2)?
02:47:39 <Cale> d(4/27) is a nontrivial solution to x' = 0
02:47:50 <vincenz> Cale: does my equation make sense?
02:48:10 <Cale> norpan: yeah
02:48:29 <norpan> what about real number?
02:49:11 <Cale> norpan: I don't think there's a "natural" way to do it
02:49:32 <joelk> i wonder if d(p/q) for the cumulants of the continued fraction for an irrational can be shown to converge.
02:49:53 <Cale> Just preserving the Leibniz rule, you get uncountably many real extensions, I think.
02:50:06 <vincenz> if x = Mult_(i elof [1..N]) p_i  | p_i = prime   => p(x) = Sum_(i elof [1..N]) Mult_(j elof [1..N]//j) p_i
02:50:10 <vincenz> if x = Mult_(i elof [1..N]) p_i  | p_i = prime   => p(x) = Sum_(i elof [1..N]) Mult_(j elof [1..N]//j) p_j
02:50:28 <vincenz> grr
02:50:28 <vincenz> .//i
02:50:37 <xerox> (It reminds me of.... perl.)
02:51:57 <Cale> http://www.cs.uwaterloo.ca/journals/JIS/VOL6/Ufnarovski/ufnarovski.pdf
02:52:24 <Cale> vincenz: looks related to theorem 1?
02:52:58 <vincenz> Cale: yep
02:53:10 <vincenz> drop the a
02:53:16 <vincenz> is actually easier like that
02:53:31 <vincenz> x = mult ..... p(x) = Sum_(i elof 1..n) X/p_i
02:54:33 <vincenz> erm
02:54:36 <vincenz> no it's different
02:54:40 <vincenz> I don't see the use of the n_i's
02:55:26 <xerox> Cale - what does (n,n') = 1 mean?
02:55:46 <Cale> xerox: usually in a number theoretic context, that the GCD of n and n' is 1
02:55:53 <Cale> (that is, they're coprime)
02:56:00 <vincenz> that's one big problem with math
02:56:03 <xerox> I see.
02:56:07 <vincenz> the notation varies wildly accross domains
02:56:12 <Cale> that's not a problem
02:56:15 <vincenz> making some papers unpossible to read
02:56:27 <vincenz> Cale: and that notations sometimes overlap
02:56:37 <Cale> usually not at the same time :)
02:56:46 <vincenz> oh... ever looked at funmath?
02:56:51 <vincenz> the stuff by Boute?
02:56:51 <Cale> a little
02:57:59 <Cale> For notation, I tend to think that it should be however people in that domain would like it to be, unless those people are physicists.
02:58:00 <vincenz> Even now, mathematics students are expected to learn complicated (e-d)-proofs in analysis with no help in understanding the logical structure of the arguments. Examiners fully deserve the garbage that they get in return.
02:58:08 <vincenz> Cale: how's that?
02:58:19 <vincenz> what makes physicists less equal?
02:58:24 <Cale> vincenz: what?
02:58:26 <xerox> hehehe.
02:58:35 <vincenz> that's from the funmath page
02:58:39 <vincenz> http://funmath.be
02:58:48 <Cale> that's a really odd quote
02:59:07 <Cale> which I can't say I relate to, having done an undergrad degree in mathematics
02:59:24 <vincenz> apparently a quote from "Paul Taylor"
02:59:30 <dozer> physicists are odd
02:59:37 <vincenz> http://www.cs.man.ac.uk/~pt/Practical_Foundations/html/s10.html
02:59:44 <vincenz> physicists have some fun kinda math
02:59:59 <vincenz> like historical physics
03:00:09 <Cale> vincenz: the remark about physicists is just because they tend to pick really poor notations, since it's not the mathematics that they're *really* concerned about anyway
03:00:37 <Cale> (well, there are some of them, but many of them will ignore things which would be important to a mathematician)
03:00:46 <vincenz> Cale: so yuou, as a mathematician would rather have the mathematicians pick a notation they like, thereby making their math REALLY useful only for ... themselves?
03:01:01 <Cale> I was mostly joking
03:01:09 <vincenz> me too
03:01:25 <Cale> Physicists do tend to eventually start using the notation which mathematicians provide anyway
03:01:46 <vincenz> it's just when I pick up some theoretical computer science paper
03:01:49 <Cale> (as well as even more significant structures)
03:01:55 <vincenz> it takes me hours just to decipher the formulaes
03:02:10 <Cale> papers aren't written for general consumption
03:02:20 <Cale> they're written for the community of people working in that area
03:02:24 <vincenz> I know that
03:02:28 <vincenz> but there are crossbleeding issues
03:02:45 <vincenz> besides stuff from theoretical side is eventually intended to end up in the practical
03:03:20 * vincenz oughta go soon, half day seminar by companies on how UML is being used for embedded systems
03:03:22 <Cale> I find that CS people tend to come up with rather baroque notation too, since they're concerned with machine interpretability (even when it's not a concern sometimes)
03:03:56 <Cale> Sometimes what is left implicit in a notation is important too.
03:04:10 <vincenz> Cale: not to mention illegible baroque fonts
03:05:02 <Cale> I mean, if we wrote +_R for real number addition everywhere, and so on for the other operations, it would make lots of stuff a lot harder to read
03:05:27 <Cale> even though it would be less ambiguous
03:05:31 <vincenz> I guess theory has no typeclasses
03:06:06 <norpan> Cale: could you plot that with logarithmic y?
03:06:14 <Cale> It has more flexible abstractions.
03:06:47 <Cale> norpan: I probably could. I'd have to dig up the mathematica notebook
03:11:31 <Cale> found it, hang on, this will likely take some time
03:11:56 <Cale> I seem to recall that exporting the graphic took ages.
03:12:12 <vincenz> holy cow
03:12:23 <vincenz> Cale: these derivative rules follow the same sort of rules as for normal mathematics
03:12:26 <vincenz> aka calculus
03:12:52 <Cale> yeah, apart from linearity, but you do get some inequalities there
03:14:51 <Cale> the interesting part is how it's related to various famous conjectures, like the twin primes conjecture
03:15:38 <norpan> so is there a reason to start with d(p) = 1 for primes?
03:15:46 <norpan> couldn't it be any number
03:17:10 <Cale> making it another number would just cause the result to be multiplied by that number
03:17:14 <norpan> ah, they cover that in the paper
03:17:28 <norpan> chapter 11
03:17:46 <norpan> Cale: it will?
03:18:37 <norpan> d(pq) = d(p)q + d(q)p
03:18:50 <Cale> right
03:19:03 <norpan> so it would not multiply the result by that number
03:19:08 <Cale> hm?
03:19:23 <norpan> it would multiply the part results
03:19:26 <Cale> if p and q are prime here, apply distributivity
03:19:42 <Cale> if not, expand them, and then apply it :)
03:19:54 <norpan> distributivity?
03:19:56 <norpan> how
03:20:43 <norpan> let's say d(p) = dp and d(q) = dq
03:20:44 <Cale> d(pq) = d(p) q + p d(q) = k q + p k = k (q + p)
03:20:58 <Cale> hm?
03:21:02 <norpan> oh, but i meant that d(p) = p for primes for instance
03:21:09 <Cale> oh, okay
03:21:15 <Cale> that would be different
03:23:22 <norpan> anyway, back to work
03:29:16 * Cale watches mathematica eat lots and lots of memory to render the image.
03:42:32 <davidhouse> Cale, it's still going?!
03:44:50 <dcoutts> dons, have you tried any gcc optimisations on fpstring.c ?
03:45:12 <dcoutts> dons, I was looking at the asm output for -O vs -O3 vs -O3 -funroll-loops
03:47:36 <dcoutts> -funroll-loops does indeed make gcc unroll stuff, thoguh it's not clear if that'll make it any faster.
03:47:45 <dcoutts> It'd need benchmarking
03:59:29 <ndm> i should really benchmark FPS GCC vs Visual Studio
03:59:40 <ndm> (or ByteString, as it is now)
04:00:00 <ndm> i checked the sizes on Windows, 500Kb for GCC, 26Kb for VS, for ByteString.dll
04:00:40 <shapr> Is there already code that wraps an openFile call to create any directories that don't exist in this openFile call?
04:02:03 <ndm> shapr, there is some in the Yhc repo
04:02:46 * shapr looks
04:02:50 <ndm> makeDirs will do it
04:02:56 <davidhouse> runInteractiveCommand "mkdir -p" ;)
04:03:09 <ndm> src/compiler98/Util/FilePath.hs
04:03:21 <shapr> ah, thanks
04:03:51 <ndm> actually, that code is horrid!! it uses the current directory
04:04:02 <ndm> Tom must have written that, will have to rewrite it at some point
04:04:07 <ndm> i wrote the rest of the module
04:04:09 <dcoutts> ndm, 500kb for what? just fpstring.c ?
04:04:16 <ndm> dcoutts, yes :)
04:04:22 <dcoutts> that's bonkers
04:04:30 <ndm> i think GCC links in the Linux kernel or something
04:04:39 <ndm> quite possibly statically linking glib
04:04:45 <dcoutts> the .o file is only 1.8k
04:05:15 <davidhouse> @hoogle [a b b] -> b -> b
04:05:15 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
04:05:16 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
04:05:16 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
04:05:37 <dcoutts> ndm, ah yes, the c library
04:05:59 <dcoutts> ndm, can't gcc use the msvcrt.dll C library?
04:06:07 <ndm> dcoutts, no, it can't
04:06:27 <ndm> msvcrt.dll is technically not part of windows, and not guaranteed to be on every copmuter
04:06:48 <ndm> plus its the one Microsoft wrote (but did also open source), so it doesn't have a few of the GCC features
04:07:26 <dcoutts> ndm, actually fpstring.c doesn't use any c lib functions at all
04:07:41 <dcoutts> ndm, it #includes no system headers and calls no functions
04:08:01 <ndm> dcoutts, yes, but GCC still has to include all its stuff for initialisation...
04:08:04 <dcoutts> there should be no need to link to anything at all
04:08:09 <dcoutts> there is no initialisation
04:08:12 <dcoutts> there is no main
04:08:19 <ndm> i bet GCC does some anyway :)
04:08:30 <ndm> and there has to be a DLL entry point on Windows anyway
04:08:43 <ndm> to manage loading and unloading and thread local storage
04:08:58 <dcoutts> which isn't used
04:09:21 <dcoutts> how does one turn a .o file into a .dll in windows?
04:09:25 <ndm> true, but its still require for windows
04:09:27 <dcoutts> usign gcc I mean
04:09:47 <dozer> any idea how to get Network.HTTP to use my web proxy?
04:10:14 <davidhouse> @pl \f g y x -> g x `f` g y
04:10:14 <lambdabot> join . (((.) . flip) .) . (.)
04:11:19 <ndm> dcoutts, gcc -DNDEBUG=1 -g   -shared
04:11:40 <ndm> thats the command ffihugs fires off, which makes the dll's that ship with winhugs
04:11:43 <ndm> (currently)
04:11:49 <dcoutts> ndm, I see.
04:12:06 <dcoutts> ndm, as an experiment, try adding -v and see what linker command gcc is using
04:12:15 <dcoutts> I bet it is linking in stuff it doesn't need
04:13:05 <ndm> dcoutts, will take a while to figure out how to do that... i don't really understand the makefile and it does the config file automatically...
04:13:20 <dcoutts> ok
04:13:33 <dcoutts> ndm, I was glad to see a modular hugs release btw
04:13:54 <dcoutts> I've looked at the hugs build system before to fix some bug or other
04:13:58 <dcoutts> it's very hard to follow
04:14:08 <ndm> i don't have a clue, i just emailed Ross when it broke
04:14:16 <dcoutts> it interleaves configure stuff with building and has myriad scripts etc
04:14:18 <ndm> which was about 20 times or so...
04:14:22 <dcoutts> heh
04:14:26 <ndm> yep, and the make file is entirely broken
04:14:41 <ndm> if one bit of the build breaks, the next time you run make it will miss that bit
04:14:47 <ndm> because the dependancies are incomplete
04:15:36 <dcoutts> we found that it was using a complex 'find' invocation, and the semantics had subtly changed in a newer version of find. That leaft half the moduels in a packge out.
04:16:03 <dcoutts> I think we sent that patch upsteam
04:16:37 <dcoutts> ndm, one thing I worry about, can we use the same sources for installing packages with hugs and with ghc?
04:17:18 <dcoutts> both ghc and hugs are going to come with cabal packages of non-core libs, are those packages different?
04:17:32 <dcoutts> I guess they will be slightly, even if it's just versionitis
04:18:00 <dcoutts> so distro packages would need to be opengl-ghc, opengl-hugs :-(
04:18:14 <ndm> dcoutts, the hugs ones are preprocessed, since hugs doesn't have a preprocessor (in a sane way)
04:18:40 <dcoutts> oh, I thought cabal dealt with that
04:18:41 <ndm> maybe you could share them, in some way
04:18:50 <ndm> i'm not really sure, its all just a blur to me :)
04:18:57 <dcoutts> heh :-)
04:18:59 <ndm> and Cabal can't distribute the base package
04:19:02 <ndm> which annoyed me
04:19:10 <dcoutts> mm
04:19:17 <dcoutts> because it's too complex right?
04:19:20 <ndm> apparently there are things that are beyond cabal
04:19:22 <ndm> i guess so...
04:19:29 <ndm> although why the base package is complex is beyond me
04:19:44 <ndm> it would be good if someone put the base package as a normal Cabal
04:19:48 <shapr> ndm: Still, makeDirs works the way I'm using it.
04:19:49 <dcoutts> aye
04:20:03 <ndm> then Hugs build script could just be build the compiler, then prod cabal 12 times
04:20:09 <ndm> and we could steal it for Yhc :)
04:20:15 <dcoutts> ndm, and ghc :-)
04:20:20 <ndm> shapr, yes, but its not as nice as I like :)
04:20:34 <shapr> FilePath is really handy. How much of that code is duplicated in Cabal's file compat stuff?
04:20:36 <ndm> dcoutts, yep - would be of benefit to all
04:20:38 <dcoutts> why can't ghc be a cabal package? (apart from having to do a 2-stage bootstrap :-) )
04:20:39 <shapr> This seems like a nice lib
04:20:51 <ndm> shapr, FilePath is 100% portable with no #defines, Cabal's is not
04:21:04 <shapr> In that case, why not contribute to Cabal?
04:21:14 <ndm> shapr, they are welcome to it :)
04:21:20 <dcoutts> ndm, send in patches!
04:21:22 <shapr> The only thing I can't figure out is how to port your os detection.
04:21:35 <ndm> shapr, SysDeps
04:21:38 <ndm> its about one line
04:21:42 <ndm> check osName :)
04:22:07 <ndm> dcoutts, i tried to build Cabal once, i toasted a Cabal and GHC installation in a few minutes, i ran scared
04:22:16 <dcoutts> ndm, if you send in those patches I can review and commit them
04:22:20 <shapr> Yeah, but osName in SysDeps does something nonportable, yeah?
04:22:31 <ndm> shapr, no, osName is in both GHC and Hugs
04:22:37 <shapr> oh
04:22:38 <ndm> @hoogle osName
04:22:38 <lambdabot> No matches found
04:22:40 <dcoutts> ndm, it's not that bad!
04:22:58 <ndm> dcoutts, it might not be that bad, but in a combination with me, it was :)
04:23:05 <dcoutts> heh
04:23:11 <dcoutts> how long ago was that?
04:23:15 <ndm> @hoogle os
04:23:16 <lambdabot> System.Info.os :: String
04:23:16 <lambdabot> Data.Graph.Inductive.Query.TransClos :: module
04:23:16 <lambdabot> Text.ParserCombinators.Parsec.Pos :: module
04:23:28 <ndm> just after ICFP last year
04:23:41 <dcoutts> I've no idea how you'd toast a ghc install by building cabal
04:23:56 <ndm> i only spent 5 minutes on it
04:24:00 <ndm> made a really minor change
04:24:05 <ndm> did something
04:24:07 <ndm> and broke everything
04:24:13 <dcoutts> ndm, oh actually, that was probably the exposing lang thing which could break other packages
04:24:21 <dcoutts> but was easily fixable
04:24:23 <ndm> perhaps
04:24:30 <dcoutts> it doesn't do that anymore :-)
04:24:31 <ndm> i might try polishing the FilePath module and releasing it
04:24:45 <shapr> I'd like to use it.
04:24:48 <ndm> and I also have Data.Predicate I want to release in a week or so
04:24:54 <shapr> What's that?
04:24:59 <ndm> where should it go, in the module Heirarchy
04:25:01 <shapr> Oh, the predicate simplifier?
04:25:05 <ndm> shapr, dealing with predicates, and basic simplification
04:25:07 <ndm> yep
04:25:11 <shapr> Why not Data.Predicate?
04:25:17 <ndm> I have Dta.Predicate
04:25:22 <ndm> but i meant for the FilePath
04:25:38 <davidhouse> ndm, please do clean up FilePath :) and provide </> and <.> for the rest of us (if you're talking about Util.FilePath from yhc)
04:25:56 <ndm> davidhouse: <.> ?
04:26:09 <ndm> and yep, I am talking about Util.FilePath
04:26:35 <shapr> Yeah, we want it!
04:26:54 <ndm> as what module name? i can probably do that this afternoon
04:26:56 <dcoutts> ndm, how is yhc looking now? is it h98 compatible now? can it be built & used easily?
04:27:05 <ndm> dcoutts, library issues still
04:27:06 <davidhouse> ndm, "myhaskellprog" <.> "hs"
04:27:10 <davidhouse> ndm, it adds extensions
04:27:10 * dcoutts is still eager to package it for gentoo
04:27:26 <ndm> davidhouse: ok, thats easy enough, but what abotu "mytest.hs" <.> "txt" ?
04:27:32 <shapr> ndm: What about System.PathUtils to start out with?
04:27:34 <davidhouse> (</>) = combine
04:27:34 <davidhouse> (<.>) = setExtensi
04:27:36 <ndm> its not ready yet, but we'll announce when it is
04:27:44 <dcoutts> good good
04:27:45 <davidhouse> s/setExtensi/setExtension
04:27:46 <ndm> shapr, sounds good
04:27:54 <shapr> ndm: I would be thrilled if you did it this afternoon :-)
04:27:58 <ndm> ok, will do
04:28:08 <ndm> have to go for lunch now, but expect an announcement by tomorrow :)
04:28:12 <shapr> Is there a System.Path already?
04:28:16 <shapr> ndm: thanks!
04:28:38 <davidhouse> shapr, onpe
04:28:41 <davidhouse> *nope
04:42:01 <giksos> guess I annoy you more time with haddock :) Why isn't it possible to document, what each particular instance does?
04:46:51 <davidhouse> are there any other interfaces to Monoid aside from Writer?
04:49:04 <davidhouse> i'm sure there is cool stuff to do with the monoidal instances of monads and arrows.
04:50:42 <dons> dcoutts: ah, good idea. we should look at -funroll-loops
05:00:46 <dcoutts> dons, yeah, it might get us most of the performance improvement that could otherwise be achiveded at great difficluty by re-writing to use 4-byte chunks
05:01:25 <dcoutts> dons, we should do an api review at some point, I think we're missing things from Data.List
05:02:12 <dcoutts> and there are other things we've added that we should probably justify, eg blahFirst, blahLast
05:02:43 <norpan> i started on a typeclass for String
05:03:05 <norpan> i wonder if it's a good idea
05:03:12 <norpan> or rather
05:03:19 <norpan> class List c e | c -> e where -- not derived pack :: [e] -> c unpack :: c -> [e]
05:03:20 <dcoutts> not sure, maybe
05:03:32 <norpan> ah
05:03:34 <norpan> bad paste
05:03:38 <norpan> but you get the idea
05:03:44 <dcoutts> aye
05:04:07 <norpan> and so instance List [a] a where pack = id; unpack = id
05:04:17 <dcoutts> it might make it easier for dealing with stuff that uses different encodings in one bit of code
05:04:39 <dcoutts> eg: lines . decodeUTF8 . gunzip
05:05:22 <alar> @seen Igloo
05:05:22 <lambdabot> Igloo is in #darcs, #haskell-overflow and #haskell. I don't know when Igloo last spoke.
05:05:49 <dcoutts> if we don't have to quialify which module we're using (ie .Lazy, .Char8, .UTF8 etc) but have it infered from the types, then that'd be nice
05:06:01 <norpan> i'd say we can use newtypes
05:06:35 <dcoutts> yes, it'd make it less painful to use newtypes for each version/encoding/representation
05:06:37 <norpan> and have List instances (or whatever the class is)
05:06:48 <norpan> and define the newtypes separately
05:06:59 <norpan> like in a new module
05:07:29 <norpan> that way you don't have to deal with them in the individual files
05:07:31 <norpan> maybe
05:08:30 <norpan> i wonder if having functions in a typeclass will affect fusion
05:09:30 <dcoutts> shouldn't do if the types are known statically
05:09:54 <norpan> instance List ByteString Word8
05:10:50 <dcoutts> instance List Char8.ByteString Char
05:11:04 <norpan> yeah
05:11:20 <dcoutts> but you couldn't infer which unicode encoding to use 
05:11:31 <norpan> ?
05:12:13 <dcoutts> I'm thinking that there could be too much ambiguity
05:13:00 <greenrd> @type \a::Int->True
05:13:02 <lambdabot>   Couldn't match `Int' against `Bool'
05:13:02 <lambdabot>   Expected type: Int
05:13:08 <norpan> http://norpan.org/~martin/StringClass.hs
05:13:10 <greenrd> Something's wrong there.
05:13:20 <dcoutts> norpan, hmm, maybe not, but something to keep an eye out for
05:13:24 <greenrd> Int is the type of the _argument_, not the type of the result
05:14:11 <greenrd> Can anyone explain why ghc seems to think that that pattern signature refers to the result type of the lambda?
05:14:13 <dcoutts> @type \(a::Int) -> True
05:14:14 <lambdabot> Int -> Bool
05:14:33 <greenrd> hmm
05:14:46 <greenrd> oh... I get it!
05:14:48 <greenrd> thanks
05:15:12 <norpan> @type \a
05:15:14 <lambdabot> parse error (possibly incorrect indentation)
05:15:23 <norpan> @type \a::Int
05:15:24 <lambdabot> parse error (possibly incorrect indentation)
05:15:32 <dcoutts> @type \a -> True
05:15:33 <lambdabot> forall t. t -> Bool
05:15:53 <norpan> yeah, but why is \a::Int->True parsed at all
05:16:06 <dcoutts> yeah I was trying to figure that out
05:16:09 <dcoutts> @type \a :: Int -> True
05:16:09 <lambdabot>   Couldn't match `Int' against `Bool'
05:16:10 <lambdabot>   Expected type: Int
05:16:22 <dcoutts> @type \a :: (Int -> True)
05:16:23 <lambdabot> parse error (possibly incorrect indentation)
05:16:37 <dcoutts> I don't see how that is being parsed
05:16:45 <norpan> @type (\a :: Int) -> True
05:16:46 <lambdabot> parse error on input `)'
05:16:56 <norpan> interesting
05:17:44 <norpan> unfortunately the List class is not a replacement for the List module
05:17:59 <norpan> map doesn't have the same type for instance
05:18:07 <norpan> nor has foldr/foldl etc
05:18:17 <norpan> err, they have
05:18:19 <norpan> but not map
05:18:19 <dcoutts> dosn't it?
05:18:26 <dcoutts> map :: (e -> e) -> c -> c
05:18:29 <dcoutts> @type map
05:18:30 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
05:19:37 <dcoutts> mm, because the List class doesn't assume that it's a container that's parameterised by its element type
05:20:03 <dcoutts> norpan, perhaps a name like String would be better
05:20:11 <norpan> maybe
05:20:21 <davidhouse> the List _class_?
05:20:27 <norpan> http://norpan.org/~martin/StringClass.hs
05:20:32 <norpan> just a mockup
05:21:47 <davidhouse> ah.
05:21:50 <norpan> also it's multi-parameter of course
05:22:39 <davidhouse> why are MPTC not allowed in h98?
05:22:53 <norpan> because they aren't? :)
05:23:04 <davidhouse> ;)
05:23:15 <norpan> they will be in haskell prime i suppose
05:23:23 <dcoutts> because they were not sufficiently understood at the time and because they wanted to keep h98 simple
05:23:30 <davidhouse> it makes about as much sense as disallowing instance decls for type synonyms
05:23:53 <davidhouse> that's bought us a whole lot of newtype-related ugliness.
05:24:09 <norpan> isn't that a sane restriction
05:24:33 <norpan> if i have two different instances for the same type how would it choose?
05:24:38 <dcoutts> overlapping instances are not especially nice
05:24:47 <dcoutts> and they're not compatible with FDs
05:24:59 <norpan> newtype is a good compromise
05:25:10 <davidhouse> norpan: it would resolve both the synonyms, find a clashing instance, and complain at compile time.
05:25:27 <norpan> davidhouse: so what would be the use of allowing it then?
05:25:44 <davidhouse> so, for example, String can be instances of things/
05:26:14 <norpan> but String is just [Char] so you'd make that an instance instead?
05:26:43 <davidhouse> but why not just allow decls of type synonyms
05:26:43 <davidhouse> ?
05:28:10 <palomer> >:o
05:28:16 <palomer> are there any integral types with infinity?
05:28:35 <norpan> Maybe Integer? :)
05:28:43 <davidhouse> palomer: data ExtendedInteger = Finite Int | Infinity
05:29:01 <palomer> that'll change lots in my code
05:29:09 <davidhouse> it needn't.
05:29:15 <norpan> jsut make it an instance of Num
05:29:19 <davidhouse> just make it an instance of integral, and you're set.
05:29:24 <davidhouse> s/integral/Integral
05:29:42 <norpan> yeah, that
05:29:42 <palomer> ah, righto
05:30:04 <davidhouse> (as long as all your type signitures are polymorphic)
05:30:07 <palomer> well, I only actually care about Ord
05:30:21 <davidhouse> but the worst-case scenario is that you have to change your type signitures
05:30:55 <norpan> fromIntegral is tricky though :)
05:31:24 <davidhouse> instance Ord ExtendedInt where Finite x `compare` Finite y = x `compare` y; Infinity `compare` Finite _ = GT; Finite _ `compare` Infinity = LT; Infinity `compare` Infinity = EQ
05:31:25 <norpan> err, toInteger
05:31:50 <davidhouse> or you might prefer Infinity `compare` Infinity = error "Comparison of infinities" if you're pedantic.
05:32:22 <davidhouse> norpan: not with the help of error :)
05:32:29 <norpan> error is your friend
05:32:35 <norpan> @type error
05:32:36 <lambdabot> forall a. [Char] -> a
05:32:41 <lome> @pl \a b c d -> a b d c
05:32:42 <lambdabot> (flip .)
05:32:42 <norpan> good function
05:32:50 <davidhouse> toInteger (Finite x) = x; toInteger Infinity = error "Infinity is not an integer, you idiot"
05:32:51 <lome> wtf?
05:33:09 <davidhouse> lome, that's a section with composition. you know about sections?
05:33:11 <davidhouse> e.g. (+2)
05:33:23 <davidhouse> > map (+2) [1..10]
05:33:24 <lambdabot> [3,4,5,6,7,8,9,10,11,12]
05:33:32 <davidhouse> @type (+2)
05:33:33 <lambdabot> forall a. (Num a) => a -> a
05:33:43 <norpan> lome: (flip .) is not the same as flip (.)
05:33:55 <lome> davidhouse: yes, but this is not correct
05:34:04 <palomer> <:o
05:34:07 <norpan> @type (flip .)
05:34:08 <lambdabot> forall a b c a1.
05:34:08 <lambdabot>     (a1 -> a -> b -> c) -> a1 -> b -> a -> c
05:34:08 <lome> !!
05:34:09 <palomer> what am I doing up this early?
05:34:24 <davidhouse> lome, sure it is.
05:34:26 <lome> norpan: understand! thx!
05:34:30 <int-e> palomer: you seem to be confused.
05:34:34 <lome> davidhouse: yes, thx!
05:34:39 <davidhouse> @localtime palomer
05:34:39 <lambdabot> Local time for palomer is Thu May 18 08:30:27
05:35:07 <davidhouse> vincenz: ping
05:35:55 <norpan> dcoutts: String is not a good name for the class either
05:36:20 <norpan> maybe something like PackedList
05:36:24 <dcoutts> norpan, just because it clashes with the type String or for another reason?
05:36:37 <norpan> because it's not just strings, but things like [Word8]
05:36:49 <dcoutts> they're ByteStrings
05:36:59 <dcoutts> class Stringy ...
05:37:01 <dcoutts> :-)
05:37:10 <norpan> it's more List than String
05:37:39 <davidhouse> dcoutts: if you call it Stringy you need a "stringify" function :)
05:37:51 <norpan> even though it's meant as a replacement for String
05:37:51 <davidhouse> which would invoke a process known as stringification.
05:37:57 <dcoutts> indeed, it'd be stringify = pack
05:38:12 <norpan> we lack stringency now
05:38:35 <davidhouse> stringtastic!
05:38:45 <norpan> PackedList is not that bad
05:40:28 <norpan> the current situation with the prelude reexporting *some* of the List functions is unsatisfactory
05:40:35 <davidhouse> @hoogle evalState
05:40:35 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
05:40:35 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
05:40:54 <norpan> why init but not inits
05:40:57 <norpan> completely arbitrary
05:48:28 <ndm> shapr, some FilePath questions
05:48:44 <ndm> what suits you, to have System.FilePath in the Yhc repo, or have it as a separate repo?
06:01:10 <azuroth> does haskell have a jabber server, or is that void filled by ejabberd?
06:04:09 <davidhouse> @hoogle liftIO
06:04:10 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
06:04:16 <davidhouse> @hoogle lift
06:04:16 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
06:04:16 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
06:04:16 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
06:04:38 <davidhouse> huh. i thought liftIO was just lift, but specialised for lifting IO actions
06:05:08 <davidhouse> oh, wait, it might be.
06:05:28 <davidhouse> yeah, okay. lots of things are MonadIOs, then.
06:06:12 <davidhouse> including, strangely, IO, meaning liftIO could have type IO a -> IO a.
06:06:38 <xerox> ?type (liftIO :: IO a -> IO a)
06:06:39 <lambdabot> forall a. IO a -> IO a
06:06:42 <xerox> Yes!
06:07:56 <davidhouse> 'liftIO $ print "hello" >>= print' prints out "hello\n()"
06:08:18 <davidhouse> so liftIO is id when m = IO
06:08:46 <davidhouse> i really meant liftIO (print "hello") >>= print, but it's the same result
06:11:19 <norpan> not stranger than toInteger on Integers
06:20:56 <davidhouse> i wish UTF8 were more supported in compilers and editors.
06:21:05 <davidhouse> i'd love to use actual lambdas for lambdas, for example.
06:21:24 <norpan> editors is no problem
06:21:25 <davidhouse> and real arrows instead of ->
06:21:31 <davidhouse> and =>.
06:21:48 <norpan> compilers are more scarce
06:21:53 <azuroth> pugs? :-)
06:23:03 <norpan> it's easy enough to make it so typing => gives you  in vim for instance
06:23:38 <davidhouse> a blank rectangle, you mean? :)
06:23:48 <norpan> no a double right arrow :)
06:23:56 <azuroth> s/editors/certain irc clients/ :-)
06:24:11 <mauke> U+21D2 (0xe2 0x87 0x92): RIGHTWARDS DOUBLE ARROW []
06:24:23 <norpan> yes
06:24:58 <ndm> davidhouse: feel free to patch Yhc :)
06:25:25 <davidhouse> ndm, re Util.FilePath?
06:25:44 <norpan> :imap => 
06:25:46 <ndm> davidhouse: no, to add UTF8 symbols
06:25:46 <norpan> in vim
06:25:52 <davidhouse> ndm, oh. heh :)
06:26:01 <ndm> Util.FilePath will be System.FilePath and released by this evening
06:26:05 <norpan> of course it's a bit harder with lambda
06:26:06 <davidhouse> awesome.
06:26:09 <ndm> i hope, just setting up some tests and haddock stuff
06:26:25 <norpan> since \ is used for more stuff
06:27:43 <norpan> is there a list somewhere, like  for ++ and so on?
06:29:03 <Igloo> alar: ?
06:29:56 <alar> Igloo: were there attempts to build dependednt-typed system on TH?
06:30:03 <alar> somewhat like Epigram
06:30:29 <norpan> what's normaly used for == in mathematics? plain =? or something like  (three horisontal lines)?
06:30:49 <davidhouse> depends.
06:30:55 <davidhouse> there's no direct analogue.
06:30:59 <Igloo> alar: NAFAIK. Don't forget you need to end up with a type-correct Haskell program
06:31:13 <norpan> hey, there is  in unicode
06:31:17 <davidhouse> to say f(x) = g(x) means that for some value of x, that holds.
06:31:26 <norpan> U+2A75 TWO CONSECUTIVE EQUALS SIGNS
06:32:18 <norpan>  is a must anyway (not equal to)
06:32:44 <norpan> but my question was if somebody already did the mapping (i assume somebody did)
06:33:45 <dons> dcoutts: I like the idea of an api review.
06:33:53 <dons> esp. those First/Last things are a bit dubious
06:34:29 <dcoutts> dons, we should just line up the list & bytestring exports and see
06:34:32 <alar> Igloo: I don't see why dependent-typed program could end up in Haskell-type-incorrect code
06:34:50 <dcoutts> eg, we're missing scanl/r and mapAccuml/r
06:35:03 <dons> dcoutts: yep. we can do those (and even fuse scanl)
06:35:26 <norpan> api review good
06:35:30 <norpan> random hacking bad
06:36:00 <dons> it'd be good to get things really polished before 6.6 comes out and the real world starts heavily using this code
06:36:10 <dcoutts> indeed
06:36:14 <norpan> i'm in
06:36:28 <norpan> let's do review and put into typeclass
06:36:29 <dcoutts> because actually performance work can carry on after the api is frozen
06:36:39 <norpan> and put the typeclass separately so that it's optional to use
06:36:54 <dons> dcoutts: yeah. 
06:37:09 <dons> norpan: would you be able to check the comparative export lists?
06:37:12 <norpan> also because its multi-parameter
06:37:25 <dons> spot anything else that's missing, and work out what extra stuff we provide?
06:37:26 <norpan> List vs ByteString?
06:37:30 <dons> yep
06:37:35 <norpan> piece of cake
06:37:44 <dons> then we can consider the extra stuff, and implement the missing stuff.
06:39:04 <dons> i know there's a fuseable scanl implementation we can steal from the ndp library. other stuff we'll have to write.
06:39:50 * davidhouse thinks he'll continue hacking on haddock
06:41:09 * dons `sleep` now -- night!
06:48:36 <dozer> OK - I've figured out how http proxy request work, and have done it by hand using telnet
06:48:57 <dozer> if I want to patch Network.HTTP to support proxies, is there a good place to start?
06:49:28 <norpan> dcoutts: http://norpan.org/~martin/stringdiff.txt
06:51:28 <dcoutts> norpan, that's not quite right, eg foldl is in ByteString
06:52:03 <davidhouse> foldl isn't in that list, dcoutts.
06:53:09 <dcoutts> oh, my mistake, it's foldl'
06:53:39 <dcoutts> norpan, and then some of those are in .Char8 and others correspond to IO functions
06:54:31 <norpan> well yes, this is just an automatic diff
06:55:08 <norpan> do we have a wiki somewhere to put this stuff in?
06:56:08 <dcoutts> not yet
06:59:14 <norpan> and append == ++ and index == !!
07:01:19 <dcoutts> norpan, yes
07:03:38 <norpan> also, could you not have something like {-# RULES "packByte" forall b . pack [b] = packByte b #-} instead of exporting packByte?
07:03:57 <norpan> or must the thing rewritten to also be exported?
07:05:45 <norpan> and why are ByteStrings null padded?
07:06:05 <norpan> many questions :)
07:07:21 <sjanssen_> norpan: not every compiler supports RULES
07:07:54 <norpan> sjanssen_: but if it doesn't it will just ignore it right?
07:07:59 <sjanssen_> also, map packByte is nicer than map (pack . return)
07:08:30 <norpan> well yes, but it also helps keeing the api small
07:08:48 <sjanssen_> true, there are arguments either way
07:09:49 <dcoutts> norpan, yes we might be able to have a smaller api by using RULES to get special cases
07:10:15 <dcoutts> norpan, it's not clear to me that ByteStrings are actually null padded, afterall substrings are not
07:10:31 <norpan> dcoutts: well the code null pads them anyway
07:10:43 <dcoutts> yeah, I don't know why, ask dons 
07:10:52 <dcoutts> it certaly doesn't do it consistently
07:11:14 <norpan> maybe a remanent from FastPackedString
07:12:01 <sjanssen_> probably from before FPS supported slices
07:12:05 <norpan> yeah
07:13:18 <norpan> ok, we have the diff anyway, let's put it somewhere and annotate it
07:13:24 <norpan> along with the established api
07:13:44 * dcoutts is making another diff
07:13:52 <dcoutts> including section names etc
07:14:02 <norpan> ok
07:19:47 <palomer> ugh ugh ugh
07:19:58 <azuroth> what's up, palomer?
07:20:14 <palomer> yo
07:20:19 <palomer> have to write tons of code
07:20:20 <palomer> tons!
07:20:44 <azuroth> hmm. anything interesting?
07:20:45 <sjanssen_> all this activity on ByteString is excellent -- it's been 8 hours since my last pull, and there are 9 patches
07:21:02 <sjanssen_> Haskell will have one badass string library after all this hacking
07:21:13 <palomer> same ol
07:21:14 <ndm> davidhouse: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php, as requested, System.PathUtils, from Yhc with tidied up bits
07:21:16 <norpan> soon we will all realise that we are barking up the wrong the and scrap the lot :)
07:21:17 <palomer> man, I want to get working on yi
07:22:35 <davidhouse> ndm, great! :)
07:22:40 <davidhouse> palomer: then do!
07:23:16 <davidhouse> ndm, not cabalised? ;)
07:23:29 <palomer> can't just yet, boss
07:24:31 <palomer> hrmph, turns out I don't need global state
07:24:33 * palomer kicks my code
07:25:30 <davidhouse> did we convince that guy last night that unsafePerformIO wasn't the way forward?
07:26:30 <palomer> it's the way back to C cavemantitude
07:26:36 <sjanssen_> we ought to make a pact to never mention unsafePerformIO to anyone -- unless they are able to prove they know what they're doing
07:27:01 <norpan> yes
07:27:12 <sjanssen_> ask them the Monad laws or something
07:27:49 <norpan> since half of the monads break those laws, perhaps it's not a good idea :)
07:28:19 <davidhouse> norpan, they do?
07:29:26 <palomer> they do?
07:29:58 <davidhouse> like that?
07:29:59 <davidhouse> *what
07:30:00 <norpan> well maybe not :)
07:30:24 <palomer> I hear ListT is pretty screwy, though I don't know if it breaks any laws
07:30:33 <davidhouse> i think even IO obeys the laws
07:30:37 <reltuk> haha, I wish someone would be like:   ahh, come on, I use unsafePerformIO at least 30 times in every program I write
07:31:15 <norpan> it's used quite frequently in ByteString at least :)
07:31:29 <dcoutts> ah, but we know what we're doing :-)
07:31:35 <norpan> hopefully
07:31:37 <sjanssen_> dcoutts: we do?
07:31:40 <alar> I use unsafePerformIO in every unsafe program  I unsafely write
07:31:45 <dcoutts> hah
07:32:33 <alar> sjanssen
07:32:35 <davidhouse> when is unsafePerformIO safe then?
07:32:46 <alar> you do know monad laws
07:33:36 <sjanssen_> alar: actually I don't know them off the top of my head -- probably shouldn't have made that proposal ;-)
07:34:02 <reltuk> sjanssen_: at least they're easy to find online
07:34:07 <norpan> left and right identity of return with >>= and associativity for >>=
07:34:09 <davidhouse>    1. (return x) >>= f == f x
07:34:10 <davidhouse>    2. m >>= return == m
07:34:10 <davidhouse>    3. (m >>= f) >>= g == m >>= (\x -> f x >>= g)
07:34:30 <norpan> yeah :)
07:34:51 * joe_k head explodes
07:35:06 <dcoutts> davidhouse, unsafePerformIO is safe when it doesn't matter how many times the side effects happen or in what order with respect to the rest of the program
07:35:21 <davidhouse> dcoutts, for example?
07:35:31 <dcoutts> davidhouse, and when you don't use it to implement coerce :: a -> b
07:35:40 <dcoutts> because you can use it for that purpose
07:36:07 <dcoutts> due to IORefs etc being polymorphic 
07:36:20 <sjanssen_> davidhouse: also, functions that use unsafePerformIO still need to be functions -- they can't return different answers for the same input
07:36:34 <dcoutts> davidhouse, eg reading from a memory buffer when you can guarantee that the buffer will hang around long enough.
07:37:08 <dcoutts> and as sjanssen says, when you know that the buffer will not be modified before the result is returned
07:37:22 <dcoutts> so that the thing is still pure
07:37:58 <davidhouse> right.
07:38:18 <dcoutts> basically, it's rather rare
07:38:25 <dcoutts> slightly more common with FFI things
07:39:05 <dcoutts> where you want to make a pure wrapper of some C function but still need to do some marshaling
07:41:31 <norpan> you can also use it for memoizing
07:41:34 <davidhouse> a pure wrapper of a pure C function, i presume
07:41:53 <sjanssen_> how will alloca interact with unsafeInterleaveIO?
07:42:36 <davidhouse> argh.
07:42:44 <davidhouse> what was that?
07:42:49 <sjanssen_> @yarr
07:42:59 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
07:43:25 <dcoutts> davidhouse, sometimes you can make an impure C function pure by juggling copies of values etc
07:43:55 <dcoutts> davidhouse, eg a C function that modifies it's argument but is otherwise pure can be made fully pure by copying the argument
07:44:04 <dcoutts> eg an in-place sort
07:44:54 <davidhouse> right.
07:47:51 <norpan> i have a module where i do memoizing on arbitrary functions with unsafePerformIO and IORefs
07:48:38 <norpan> basically caching the results
07:50:11 <norpan> you need to declare it as a top-level binding though
07:50:27 <norpan> otherwise you'll get new iorefs every time and no memoizing :)
07:51:17 <yip> hm.... is that the best way to do funtions that utilize table lookups?
07:52:29 <ndm> davidhouse: not yet, patches welcome :)
07:53:19 * davidhouse is tidying up haddock at the moment
08:03:58 <xerox> shapr - you were talking about FLM yesterday, nice.  I just discovered that OS X pdf viewer can annotate things on the margins (:
08:04:12 <xerox> (Spotlight can search into PDFs as well.)
08:13:25 <davidhouse> wow
08:13:33 <davidhouse> there's a little genius 12 year old on countdown
08:14:09 <davidhouse> and des lynham is being extremely patronising
08:14:29 <davidhouse> err, s/lynham/lynam.
08:14:39 <alar> Igloo: what does the following mean?
08:14:40 <alar> While an explicitly constructed AST does not respect the lexical scope of surrounding code and is not immediately statically type-checked, both these properties are kept by Quasi-Quotes.
08:14:43 <davidhouse> but the point is he's really good! damn talented young people.
08:15:10 <alar> lexical scope = defined names,etc?
08:15:29 <Igloo> Probably
08:15:45 <Igloo> It's basically saying more things can go wrong if you build the AST yourself, I think
08:16:04 <dozer> ok - to add http proxy I think Request needs patching to contain a Maybe { proxyHost::String, proxyPort::Maybe int}
08:16:31 <dozer> and simpleHTTP needs patching to open a socket to the proxy or the destination URL as required
08:16:55 <alar> yes, but isn't it peferrable to write context-insensitive code into ASTs?
08:19:57 <Igloo> Well, you might be writing something that is inherently context sensitive
08:20:02 <shapr> xerox: cool!
08:22:01 <alar> thanks to all, have to go
08:22:16 <davidhouse> yay thunderstorm! :)
08:24:19 * azuroth is stuck fixing SQL injection bugs. yay.
08:26:01 <dcoutts> dons, I've got an idea to implement ByteString.partition, it's somewhat cunning...
08:26:22 <dcoutts> dons, so the problem with filter is that it has to realocate after the filter.
08:26:58 <dcoutts> with partition we don't have to because we know exactly how many elements are in the output
08:27:18 <dcoutts> but we don't know how they'll be divided between the two resul strings
08:28:14 <dcoutts> oh, hmm but we don't know where to start, hmm
08:28:52 <dcoutts> I was thinking that you'd make one string for the result and then take two slices of it
08:29:30 <dcoutts> but we don't know where to start filling in the results for the second list, we'd have to reverse them at the end which is pretty much as expensive as copying right?
08:29:55 <Igloo> What does the current implementation do?
08:30:20 <dcoutts> there is no current impl of partition
08:30:21 <kolmodin> which implementation?
08:30:22 <kolmodin> :)
08:30:29 <Igloo> Ah
08:30:52 <dcoutts> the current impl is: parition p = (filter p, filter (not.p))
08:32:37 <Igloo> My word there's a lot of abstraction in there
08:33:00 <Igloo> I think the best you'll get is to malloc 2 fulll-size strings and then relaloc them down at the end, anyway
08:33:10 <davidhouse> @pl partition p xs = (filter p xs, filter (not . p) xs)
08:33:11 <lambdabot> partition = ap (ap . ((,) .) . filter) (filter . (not .))
08:33:15 <davidhouse> hah.
08:33:16 <dcoutts> just like filter does currently
08:33:36 <shapr> azuroth: Seen HaskellDB? No sql injection bugs ever again :-)
08:33:36 <Igloo> filter evaluates p twice for each character, though
08:33:47 <davidhouse> @pl partition p = filter p &&& filter (not . p)
08:33:48 <lambdabot> partition = liftM2 (&&&) filter (filter . (not .))
08:34:03 <azuroth> seen prepared statements with parameters? :-)
08:34:05 <Igloo> If you don't mind doing that then you can malloc one full-size string, walk over copying the True ones in and then walk over again copying the False ones in
08:34:09 <davidhouse> Igloo: yes, a better way would be an accumulating fold
08:34:30 <azuroth> but yeah, I'd love to be doing this in a modern language. I'm not, though. :-(
08:34:30 <Igloo> davidhouse: I don't follow
08:34:46 <dcoutts> Igloo, or fill the false ones in at the end of one string, and then reverse them in-place
08:35:24 <dcoutts> so you alloc one string and never realloc, but you pay for half a reverse
08:35:36 <xerox> @type \p -> foldr (\x (xs,ys) | p x = (x:xs,ys) | otherwise = (xs,x:ys)) ([],[])
08:35:39 <dcoutts> it might work out quicker, though it also has different sharing semantics
08:35:57 <davidhouse> Igloo, i wasn't refering to ByteString there.
08:36:01 <Igloo> You might be better evaluating p once for each value in [0..255] and putting hte results in an array, actually (although that would be slower for small strings and simple p's)
08:36:05 <davidhouse> something like what xerox put.
08:36:10 <azuroth> which probably means I shouldn't be talking about it so much in here, but... having you guys around reminds me there is a better place :-)
08:36:57 <Igloo> So basically there are half a dozen implementations, and which one you want depends on lots of factors  :-)
08:36:57 <lambdabot> parse error on input `|'
08:36:58 * davidhouse gets a nice idea for a new combinator
08:37:03 <dcoutts> Igloo, you don't like my in-place reverse idea? :-)
08:37:36 <Igloo> dcoutts: I'm sure it'll win in some cases
08:38:23 <Igloo> dcoutts: If you're optimising for the worst case then I suspect precomputing p on [0..255] and going forwards over the string twice will win, though
08:38:45 <dcoutts> aye
08:39:21 <davidhouse> partitionApply p l r = foldl (\(ls, rs) x -> if p then (l x:ls, rs) else (ls, r x:rs)) ([], []) -- could be quite useful
08:39:24 <dcoutts> the worst case for my suggestion is partition (const False)
08:39:59 <Igloo> No, the worst case is   partition (\c -> expensive_thing) bigstring
08:40:15 <dcoutts> Igloo, I'm still only computing p once per-element
08:40:21 <Igloo> (where expensive_thing actually depends on c)
08:40:24 <Igloo> Ah, OK
08:40:33 <xerox> davidhouse - `if p x ...' rather?
08:40:45 <davidhouse> err, yeah
08:40:59 <dcoutts> Igloo, I'm filling in the result array from both ends and then reversing the second half when we're done.
08:41:10 <Igloo> I'd have thought going forwards twice was cheaper than going forwards and backwards over something half the size, but you'd obviously need to benchmark to find out
08:41:29 <davidhouse> then splitEithers = partitionApply isLeft unLeft unRight where isLeft (Left _) = True; isLeft _ = False; unLeft (Left x) = x; unRight (Right x) = r
08:45:49 <ihope> @hoogle String -> IO ()
08:45:50 <lambdabot> Prelude.putStr :: String -> IO ()
08:45:50 <lambdabot> Prelude.putStrLn :: String -> IO ()
08:45:50 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
08:47:20 <ihope> What's System.getEnv do?
08:48:35 <eivuokko> Gets specific environment variable, I think
08:48:47 <yaarg> yup
09:00:20 <davidhouse> ndm, ping
09:00:29 <ndm> davidhouse: pong
09:00:37 <davidhouse> ndm, i cabalised. want the patch?
09:01:08 <ndm> davidhouse: yes please :)
09:01:16 <davidhouse> ndm, email address?
09:01:17 <ndm> i reverted the path, so its now System.FilePath once more
09:01:34 <ndm> so i'm not sure how you can pull to sync with that...
09:01:38 <davidhouse> huh.
09:01:41 <davidhouse> that might mess things up
09:01:53 <ndm> there are 4 patches in the repo
09:02:03 <ndm> if you revert the last 2, it will be the same
09:02:09 <davidhouse> i'll email you the patch for cabalisation.
09:02:17 <davidhouse> it applies right now.
09:02:19 <ndm> ndmitchell   -AT-   gmail.com
09:02:30 <ndm> i'm not sure you can pull the unrecord's i did...
09:02:34 <ndm> depends when you pulled
09:02:40 <ndm> but i'm sure i'll manage to tweak it in
09:03:11 <davidhouse> sent.
09:04:25 <dozer> I've patched Network.HTTP for proxies - I will test it tomorrow
09:04:31 <ndm> davidhouse: why rmfile make.bat?
09:04:44 <sjanssen_> @hoogle plusPtr
09:04:45 <lambdabot> Foreign.Ptr.plusPtr :: Ptr a -> Int -> Ptr b
09:04:48 <sjanssen_> that type is wrong
09:04:58 <ndm> make.bat just generates the haddock docs and drops it into my web page
09:05:06 <davidhouse> oh, sorry.
09:05:24 <davidhouse> it probably shouldn't be in the repo anyway
09:06:40 <sjanssen_> do any applications actually depend on the casting behavior of plusPtr?
09:06:47 <azuroth> hmm, are stored procedures bad?
09:08:49 <monochrom> if you use stored procedures for very comprehensible things it's ok I suppose
09:09:40 <davidhouse> ndm, i also slapped a GPL license on. you might want to change that.
09:09:55 <ndm> davidhouse: yep, just changing it to BSD3
09:10:01 <ndm> which i guess will make everyone happy
09:10:05 <davidhouse> sure.
09:10:39 <ndm> davidhouse: all committed and pushed, thanks very much
09:10:51 <ndm> i must figure out how to use Cabal one of these days...
09:10:58 <davidhouse> hey, i just learnt.
09:11:02 <davidhouse> it's mostly copy-paste! :)
09:11:18 <ndm> hehe
09:11:24 <ndm> i know cpphs has had many cabal issues
09:11:44 <davidhouse> right, we'll i'm off.
09:11:48 <monochrom> That sounds bad.  Need to scrap the boilerplate and introduce more combinators!
09:20:03 <sjanssen_> is there a way to get a Ptr out of a UArray?
09:20:50 <sjanssen_> @fptools Data.Array.Base
09:20:51 <lambdabot> Data.Array.Base not available
09:22:31 <dcoutts> sjanssen_, seems like an unsafe thing to do because a UArray doesn't have a stable address, the GC can move it.
09:22:41 <sjanssen_> I see
09:47:28 <monochrom> hmm, hdbc is not too bad.
09:48:57 <monochrom> I still like the level of abstraction of haskelldb
09:50:19 <ValarQ> doesn'
09:50:27 <dcoutts> we need haskelldb to use hdbc
09:50:29 <ValarQ> 't haskelldb run ontop of hdbc?
09:50:37 <dcoutts> no, on top of hsql
09:50:54 <ValarQ> ok
09:53:20 <araujo> Hi!
09:53:30 <[1]alex> @help
09:53:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:53:41 <[1]alex> @list
09:53:42 <lambdabot> list [module|command]. Where modules is one of:
09:53:42 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
09:53:42 <lambdabot> version vixen where
09:54:12 <[1]alex> @help seen
09:54:13 <lambdabot> seen <user>. Report if a user has been seen by the bot
09:54:23 <[1]alex> @seen musasabi
09:54:23 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
10:16:07 <palomer> 2man
10:16:19 <palomer> I wish it was possible to get a stack trace when I throw an error
10:17:31 <eivuokko> If you are on Windows and use ghc, check out tamelambda.net/darcs/tracer 
10:17:38 <eivuokko> It can, sort of :)
10:18:08 <palomer> using linux
10:19:44 <eivuokko> I dunno how easy it's to debug in linux, but in principle supporting ptrace wouldn't be hard.
10:20:31 <dcoutts> eivuokko, your same trick of stopping it and poking about in the ghc rts structures should work under linux
10:20:55 <eivuokko> dcoutts, I meant debug-api.  Windows has pretty neat API to write debuggers
10:21:44 <eivuokko> dcoutts, ptrace is the linux (most unixes?) debug api afaik, but it doesnt' even mention threads etc, which makes me wonder...
10:21:49 <dcoutts> eivuokko, right, it'd be via a different api (it's be /proc)
10:22:29 <eivuokko> dcoutts, Don't I need ptrace/wait for breakpoint detection?
10:22:48 <dcoutts> eivuokko, threads are just different entries in /proc/${PID}/task/*
10:23:24 <dcoutts> eivuokko, you mean how do you set a breakpoint at a code address in a program?
10:23:55 <eivuokko> I know how to do that
10:24:08 <eivuokko> I don't know how to detect breakpoint, suspend threads, and read registers.
10:24:21 <eivuokko> (With ptrace/wait I can do first)
10:24:36 <eivuokko> afaik /proc doesn't have registers
10:24:47 <eivuokko> ptrace does, but it doesn't meantion threads
10:25:11 <eivuokko> Unless task-ids are ok for ptrace..
10:25:12 <dcoutts> eivuokko, under linux threads are pretty much the same as procsses
10:25:17 <eivuokko> Yuck
10:25:22 <dcoutts> no, nice :-)
10:25:27 <flux__> dcoutts, used to be
10:25:38 <flux__> 2.4 and 2.6 differ in that
10:25:41 <dcoutts> they're just processes that share certain resources, like vm, etc
10:25:51 <eivuokko> Yawn
10:25:56 <flux__> that is: threads may also share their process id
10:26:08 <eivuokko> So, when process starts a thread debugger gets bunch-load of signals and othre crap?
10:26:09 <flux__> and strace (ptrace) and friends don't work with tids
10:26:10 <flux__> which sucks
10:26:15 <dcoutts> flux__, right, under the nptl
10:26:16 <palomer> oh blimey
10:26:24 <palomer> tracing with State is no fun
10:26:26 <eivuokko> flux, How would thread-debugging work then?
10:26:31 <flux__> eivuokko, I don't know, but it does
10:26:35 <flux__> eivuokko, I guess there's a mechanism for that
10:26:43 <eivuokko> Translate: Read gdb sources
10:26:45 <flux__> so, ptrace must work, but strace (tool) doesn't
10:26:59 <eivuokko> Maybe I just write gdb-backend
10:27:03 <dcoutts> eivuokko, I think gdb traps forks (clone) and then traces both children
10:27:13 <eivuokko> Argh
10:27:24 <dcoutts> it's got some lib to abstract it
10:27:30 <eivuokko> gdb-backend it is
10:27:54 <eivuokko> I wish I knew how to read CurrentTSO and stacks properly, so I could make the tool worth a bit more.
10:28:12 <eivuokko> But my ghc rts skills aren't up to it yet :-(
10:28:40 <dcoutts> eivuokko, when I attach gdb to a threaded process it uses:
10:28:40 <dcoutts> Using host libthread_db library "/lib/libthread_db.so.1".
10:29:05 <dcoutts> perhaps that has a nice api to do that kind of stuff
10:29:40 <eivuokko> dcoutts, thanks.  My unix skill aren't up to using raw os interface, I guess...better go gdb route.
10:29:56 <eivuokko> (my prog using gdb)
10:45:41 <palomer> it's my party and I'll cry if I want to
11:13:56 <palomer> humph
11:14:01 <palomer> stage 1 done
11:14:04 <palomer> time for stage two
11:14:07 <palomer> then laying in the pool
11:14:38 <ulf_> heh, "apprehension" is a pretty overloaded word in english
11:16:55 <Cale> Mathematica has one of the least efficient methods of plotting large datasets that I can imagine. It forms an actual (strict) list of circle objects before rendering each one. My mathkernel is currently using 633.1 MiB.
11:18:26 <palomer> hrmph, maybe we can embed a CAS into haskell
11:22:14 <sjanssen_> @quote
11:22:14 <lambdabot> Heffalump says: docs aren't all that useful, generally
11:35:33 <palomer> yes
11:35:36 <palomer> !!!
11:35:47 <palomer> I think I just finished the programming part of my masters thesis
11:35:47 <palomer> woot
11:35:51 <palomer> (and on 2 hours of sleep)
11:36:37 <hyrax42_> congrats
11:37:19 * palomer does a dance
11:46:36 <palomer> now I just have to write it up
11:46:37 <palomer> ugh.
11:47:09 <neologism> palomer: finished? so now you can find entirely new bugs :)
11:47:54 <palomer> I don't believe there are any bugs, the system is simple enough so that's what's on paper is transcribed directly into code
11:48:05 <palomer> so I'd have to find an error in the theory
11:48:07 <neologism> there are always bugs in important code ;)
11:48:09 <palomer> I doubt there is any
11:48:35 <neologism> I remember I was finding bugs in my thesis even after I released it to the prof
11:48:37 <palomer> s/are/is
11:48:44 <palomer> masters?
11:48:51 <palomer> but, err, my system is really simple
11:48:51 <neologism> bachelor
11:48:55 <palomer> yet ingenious!
11:53:58 <SL> hello
11:54:31 <araujo> hi
11:55:27 <SL> i want to define a function with type Maybe, but i dont know how to specify the Nothing case. When all the patterns dont match, the last one should be executed
11:56:07 <kosmikus> SL: can you be more specific? what's the type of your function?
11:56:24 <araujo> Hi kosmikus 
11:56:42 <kosmikus> hi araujo 
11:57:06 <SL> fun :: Int -> Maybe Int
11:57:20 <greenrd> SL: foo _ = Nothing
11:57:29 <araujo> SL, wat do you mean by specifying the nothing case?
11:58:00 <SL> fun (Int a) = 5
11:58:10 <Cale> fun x = Just x ?
11:58:18 <SL> eh yes
11:58:19 <Cale> SL: what do you want fun to do?
11:58:28 <Cale> You can just use Just as a function
11:58:51 <SL> so what happens if i call fun with a float?
11:59:28 <Cale> in this case, unless you give it a type signature, it'll work fine
11:59:47 <SL> fun should return Nothing, but i dont know how extend the fun definiton do 
11:59:55 <Cale> You can make it fail to compile by giving it a type sig like  fun :: Int -> Maybe Int
12:00:25 <Cale> Oh, perhaps you want a typeclass
12:00:31 <Cale> class Fun a where
12:00:38 <Cale>    fun :: a -> Maybe a
12:00:43 <Cale> instance Fun Int where
12:00:46 <araujo> > let f :: (Num a) => a -> Maybe a ; f num = Just num in (f 3.4, f 7)
12:00:47 <lambdabot> (Just 3.4,Just 7)
12:00:47 <Cale>    fun = Just
12:00:53 <Cale> instance Fun Float where
12:00:59 <Cale>    fun = const Nothing
12:01:36 <Cale> but what do you *want* that function for?
12:01:52 <Cale> You'll always know at compile time what the type of some value is anyway
12:02:19 <SL> yes
12:02:26 <SL> this was just a dumb example
12:02:34 <SL> i have a fun with a type variable
12:02:51 <araujo> SL, but what are you trying to do?
12:02:52 <Cale> The actual types of things are decided at compile time
12:03:00 <Cale> never at runtime
12:03:12 <Cale> in fact, all the type information is gone at runtime
12:03:38 <palomer> doesn't ghc have support for dynamic typing?
12:04:19 <Cale> Okay, yeah, it does. That's by using a typeclass to explicitly represent the type as data.
12:04:34 <Cale> but it doesn't work for all types
12:04:56 <Cale> specifically, you can't have polymorphic types
12:05:02 <palomer> <:o
12:05:03 <palomer> sucks
12:05:31 <Cale> well, it doesn't matter, since hardly anyone actually uses it :)
12:06:13 <palomer> we'd use it if it supported polymorphic types!
12:06:16 <Cale> (or has a need for it)
12:06:30 <Cale> Would you?
12:06:46 <palomer> no:P
12:07:08 <Cale> Usually, existential types are a safer and more convenient way to go for that sort of thing (even if they aren't quite the same thing)
12:07:31 <Cale> (or just plain union types)
12:08:27 <ihope_> @hoogle IO a
12:08:28 <lambdabot> System.exitFailure :: IO a
12:08:28 <lambdabot> Control.Exception.evaluate :: a -> IO a
12:08:28 <lambdabot> Network.withSocketsDo :: IO a -> IO a
12:21:06 <hyrax42_> @index getArgs
12:21:07 <lambdabot> System.Environment
12:23:25 <ihope_> @hoogle String -> a
12:23:27 <lambdabot> Prelude.error :: String -> a
12:23:27 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:23:27 <lambdabot> Prelude.fail :: Monad m => String -> m a
12:23:35 <ihope_> @hoogle Read a => String -> a
12:23:36 <lambdabot> Prelude.read :: Read a => String -> a
12:23:36 <lambdabot> Prelude.error :: String -> a
12:23:36 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:30:04 <palomer> ugh ugh ugh, I'm going to have to run my haskell application through a CGI
12:36:24 <xerox> palomer - I know of a very simple httpd.hs which supports CGI.
12:36:59 <palomer> I'll also be running stuff through pdflatex
12:43:37 * palomer wishes pdflatex could pipe
12:44:41 <sieni> palomer: can't it?
12:44:54 <palomer> not that I can see
12:45:22 * xerox lights the pipe
12:45:30 <xerox> s/s t/s up t/
12:47:16 <sieni> ahh, broken pos
12:47:24 <palomer> oh, it does pipe!
12:47:28 <sieni> does it?
12:47:28 <palomer> hoorah
12:47:32 <palomer> yup
12:47:49 <palomer> all I need to do is earn how to do CGI with haskell
12:47:53 <palomer> any tutorials on the matter?
12:48:06 <sieni> how does it do it?
12:48:28 <sieni> i.e. which option?
12:49:20 <palomer> echo "blah" | pdflatex
12:49:32 <palomer> s/learn/earn
12:51:04 <Cale> palomer: there's a trivial CGI library that comes with GHC
12:51:29 <Cale> wrapper :: ([(String, String)] -> IO Html) -> IO ()
12:51:40 <palomer> ooh, nice
12:52:21 <palomer> @hoogle wrapper
12:52:22 <lambdabot> Network.CGI.wrapper :: ([(String, String)] -> IO Html) -> IO ()
12:52:22 <lambdabot> Network.CGI.pwrapper :: PortID -> ([(String, String)] -> IO Html) -> IO ()
12:53:13 <palomer> I'll need to redirect my user, too
12:53:29 <palomer> ie, I'll be taking input from the webpage, creating a file, then sending the file to the user
12:53:43 <palomer> (and deleting the file)
12:57:44 <Cale> you might be able to just return the generated file on stdout in the case where the parameters are right
12:58:03 <Cale> I can't recall what other headers you'd have to emit
12:58:48 <Cale> oh, right, Content-type and Location
12:59:32 <davidmccabe> Cale: so, I'm gonna send that problem to the mailing list. you think it should go to haskell or to ghc?
12:59:45 <Cale> davidmccabe: perhaps libraries?
13:00:03 <davidmccabe> I didn't see such a mailing list, but I'll look again.
13:00:10 <davidmccabe> if I find a HGL list of course I'll send it there.
13:00:50 <Cale> libraries@haskell.org
13:03:12 <shapr> Anyone know how to set an env var in a particular part of a Makefile?
13:08:35 * Ulfalizer throws scons on shapr 
13:10:12 <davidmccabe> Cale: cool. did you ever see my screencast?
13:10:16 <davidmccabe> http://dmccabe.org/foo.html
13:10:32 <davidmccabe> difficult to see what's going on because you can't see screenpresses and because the mouse isn't quite in sync. but that's the basic idea.
13:10:33 <shapr> hiya Ulfalizer
13:13:21 <Cale> I usually just use shell scripts to build things when they even get complicated enough to warrant that much.
13:14:02 <Maddas> ol
13:14:19 <zimbatm> hi
13:14:23 <Maddas> Hello.
13:14:34 <Ulfalizer> shapr: ehlo
13:14:47 <zimbatm> i'm trying to do some exercise in the tutorial but i don't understand why it isn't working
13:14:54 <zimbatm> http://pastebin.com/725236
13:15:07 <zimbatm> it should ask me my name and favourite color
13:15:18 <zimbatm> hi Maddas
13:15:32 <basti_> zimbatm: uhm, you have a type error there.
13:15:37 <sjanssen_> zimbatm: which tutorial are you using?
13:15:52 <zimbatm> http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell
13:15:53 <sjanssen_> have you learned about the IO type yet?
13:15:58 <zimbatm> nope
13:16:03 <zimbatm> i'm at the really start
13:16:11 <zimbatm> btw there is a typo in this guide
13:16:37 <sjanssen_> zimbatm: it's a wiki, feel free to fix errors!
13:16:48 <basti_> zimbatm: you should prepare for a bizarre experience now.
13:17:18 <basti_> haskell does some stuff unlike other languages do.
13:17:57 <sjanssen_> zimbatm: now, Haskell is a pure functional language -- we don't want IO leaking into places it shouldn't be.  Therefore, we have this IO wrapper.  When you have "IO Int" you can't get the Int out, because then you could do IO all over the place
13:18:41 <sjanssen_> luckily, we have a little "imperative mode" that we enter with the 'do' keyword
13:18:53 * basti_ hands some beverages
13:19:01 <zimbatm> hmm ok i see
13:19:16 <zimbatm> i don't have the basic haskell concepts right now
13:19:43 <sjanssen_> the do syntax uses the '<-' symbol to get a value out of IO, but it will only let you use it inside that IO computation
13:19:53 <zimbatm> http://www.haskell.org/haskellwiki/?title=Hitchhikers_guide_to_Haskell&diff=4121&oldid=3919
13:20:13 <zimbatm> ^ this is my change but I don't get why I had to have a new line after the "do"
13:20:20 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:20:37 <zimbatm> ok
13:20:49 <Cale> zimbatm: you don't have to
13:21:00 <Cale> but you do have to indent the inside of the do-block the same
13:21:22 <sjanssen_> we could rewrite your main as: main = do myName <- name; putStrLn ("Hello : " ++ myName)
13:21:29 <Cale> that is, the line after should line up with "input"
13:21:47 <Cale> sjanssen: <- name ?
13:22:09 <Cale> I suppose if we also had name = getLine
13:22:19 <sjanssen_> Cale: a defn in his program
13:22:53 <sjanssen_> though, name isn't a good name for what it does.  getName is better
13:23:33 * ptolomy reallly really likes the wiki syntax highlighting.
13:23:57 <Cale> It actually bothers me in various ways
13:24:30 <Cale> It's inconsistent, since it doesn't colour things that it doesn't know about, even though it could probably tell what they were, even if it can't link them
13:25:12 <Cale> like, a lot of the stuff from the Prelude is coloured green, but not other functions
13:26:53 <sjanssen_> I find highlighters like that annoying.  For example, kate highlights 'Monad', but not other typeclasses
13:27:35 <Cale> yeah
13:28:09 <Cale> I really wish there were more syntax highlighters that did a proper parse of the file (with error recovery of course)
13:28:29 <zimbatm> sjanssen_: when you say "IO computation", do you mean a kind of do "code block" ?
13:28:36 <Cale> zimbatm: yeah
13:29:14 <Cale> zimbatm: A value of type (IO t) is an action, which if run, would possibly do some IO, and then return a value of type t.
13:29:38 <Cale> But the only IO action which ever really runs is main.
13:29:52 <Cale> (or those which you type at the ghci prompt)
13:30:02 <palomer> hrm, is it possible to run a unix command from haskell and have it killed if ever it blocks?
13:30:21 <dcoutts> palomer, what does blocks mean exactly?
13:30:29 <Cale> palomer: you could set a timeout for having it send output, I suppose
13:30:53 <palomer> dcoutts: stops, usually waiting for input from the user
13:31:03 <dcoutts> that's not the same thing
13:31:17 <palomer> cin << a; <--this line will block a process
13:31:30 <dcoutts> you can't tell if it's waiting for input
13:32:36 <palomer> in ruby I'd do:
13:33:05 <palomer> IO.popen("foo < /dev/null",'r')
13:33:36 <palomer> oh wait, I can simply run that command
13:33:42 <palomer> how do you run a command line command from haskell?
13:33:46 <zimbatm> what do you think of this solution ?  http://pastebin.com/725293
13:33:54 <Cale> @docs System.Process
13:33:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
13:34:39 <Cale> zimbatm: that's the idea
13:34:46 <zimbatm> cool
13:35:02 <Cale> you can drop the 'do' when there's just one action
13:35:09 <eivuokko> Arity of, say, id is 1, right?  Or arity of id 2 in common parlance (in haskell context)?
13:35:27 <Cale> eivuokko: I'd say it's 1
13:35:53 <eivuokko> Would it make sense for ghc's rts/stg say arity of id 2?
13:36:04 <Cale> hm?
13:36:17 <palomer> gotcha
13:36:18 <Cale> Where does it say that?
13:36:36 <Cale> I guess it could use whatever convention it liked
13:36:43 <Cale> perhaps it's counting the output value
13:37:05 <eivuokko> Yeah, I was just wondering
13:37:27 <eivuokko> Because it says arity of putStrLn is 2.
13:37:27 <Cale> I'd normally define the arity of a value with a type not having (->) as its top level type constructor as 0, and define the arity of a value with type a -> b to be 1 + the arity of b.
13:37:41 <eivuokko> Yeah, me too.
13:38:44 <Cale> perhaps it's unboxing the IO and counting the RealWorld parameter
13:38:54 <eivuokko> Hmm
13:39:05 <eivuokko> pita to find out exactly
13:39:09 <Cale> what does it say for chr ?
13:39:41 <eivuokko> Let me see if I can get it to stop on pure fun
13:41:16 <eivuokko> lines has arity of 1
13:41:44 <eivuokko> Oh, well.  I think I really just need to get an answer from one either Simon.
13:43:40 <eivuokko> Thanks for help, Cale.
13:43:46 * eivuokko goes stare meaningless numbers
13:47:06 <palomer> hrm
13:47:15 * palomer has to relearn how to write cgi scripts all over again
13:55:36 <yip> what's the best way to do precalculate and utilize tables?
13:57:04 <sjanssen_> yip: do you already know that bounds of the things you need to memoize?
13:57:46 <yip> yeah, let's say you have a function f(x), and you want to precompute for integer values of 0 < x < 256
13:57:53 <sjanssen_> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
13:58:21 <sjanssen_> in that post, Chris Okasaki defines a fixpoint combinator for dynamic programming
13:58:52 <yip> hm....
13:58:57 <yip> not sure that is what i am talking about
13:59:24 <sjanssen_> is your function recursive?
14:00:39 <yip> no, f is just a regular function. the idea is that lots of other functions need the results of f, but i want these results to be precomputed, since the actual algorithm that f uses is very expensive
14:00:46 <fincher> anyone know how to contact Jonathan Tang to tell him that http://halogen.note.amherst.edu/%7Ejdtang/scheme_in_48/tutorial/evaluator2.html#primitives is broken?
14:01:25 <sjanssen_> yip: just use a plain old array then
14:02:58 <yip> sjanssen: yeah, but when do i create the array? let's say i have functions foo and bar. they have an implementation that needs f. foo and bar should be part of a library
14:05:11 <Cale> yip: define an array with results of f, and make f use it
14:05:49 <Cale> if it's a top-level value, it'll basically never get thrown away
14:05:54 <yip> Cale: yeah, problem then is that f becomes f :: ArrayResults -> ...
14:05:59 <Cale> no
14:06:09 <Cale> the type of f doesn't change
14:06:20 <yip> Cale: hm.... oh i get what you mean
14:06:25 <yip> hrmm.....
14:06:56 * palomer slaps emacs a bit
14:06:57 <Cale> fibs = array (0,100) [(i, fib i) | i <- [0..100]]
14:07:00 <yip> Cale: interesting.... so when exactly will this top level array actually be computed? possibly during compile time even?
14:07:02 <sjanssen_> lisppaste2: url
14:07:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:07:19 <Cale> yip: not during compile time, it'll be constructed as values are requested
14:07:34 <lisppaste2> sjanssen pasted "memoize" at http://paste.lisp.org/display/20157
14:08:06 <Cale> fib 0 = 0
14:08:08 <Cale> fib 1 = 1
14:08:23 <ValarQ> how is it with single values? can they be precomputed?
14:08:25 <Cale> fib n | n <= 101 = fibs !! (n-1) + fibs !! (n-2)
14:08:29 <yip> Cale: let's say it's a single value(like pi), if only a "foo" function uses it, then it will be computed the first time foo is called(and it's result is needed)? and then for every next call of foo the value will be "cached"?
14:08:37 <sjanssen_> yip: that's what you want.  The compiler will compute when needed and hold on to the value
14:08:58 <Cale> yip: only if it remains in scope
14:09:11 <Beelsebob> fibs = take 100 $ fibs' 1 1 where fibs' n m = n:(fibs' m (n+m))
14:09:20 <Cale> yip: if you create a local definition, it'll only stay computed until the function returns
14:09:25 <xerox> Cale: (!) not (!!), right?
14:09:33 <Cale> er, yeah (!) not (!!)
14:10:04 <sjanssen_> Cale: where's and let's generally stick around also
14:10:21 <Cale> sjanssen: not between calls
14:10:38 <Beelsebob> yip: haskell does nothing magical, you need to explicitly introduce sharing to get shared computation
14:11:09 <sjanssen_> Cale: even if they're CAFs?
14:11:17 <Cale> yeah
14:11:28 <Beelsebob> no, CAFs are only evaluated once
14:11:34 <Beelsebob> unless they're local CAFs
14:11:41 <Cale> We're talking about local CAFs
14:11:46 <Beelsebob> ah, okay then
14:11:55 <Beelsebob> then they are evaluated once for each call of the parent function
14:11:59 <Cale> right
14:12:09 <Beelsebob> looking at a hat trace will confirm this
14:12:10 <sjanssen_> I thought local CAFs worked the same
14:12:28 <Cale> they do work the same
14:12:45 <Cale> it's just that the top-level tends not to go out of scope :)
14:13:12 <Beelsebob> sjanssen: even this one... f x = c where c = x
14:13:27 <Beelsebob> that CAN'T be evaluated once only
14:16:26 <palomer> how would you guys generate a random filename?
14:16:32 <sjanssen_> GHC caches at least some where or let bound CAFs
14:16:44 <Beelsebob> palomer: why do you want random filenames?
14:17:00 <Cale> sjanssen_: I've never seen that happen
14:17:14 <Beelsebob> sjanssen: maybe, but that's an optimisation that preserves the semantics, it's merely simulating what cale and I are saying
14:17:23 <palomer> a random string that counts as a filename
14:17:31 <Beelsebob> it's not possible in general because you can simply write "f x = c where c = x"
14:17:35 <Beelsebob> palomer: why do you want it?
14:17:43 <palomer> so I can put stuff in it
14:17:46 <palomer> to send to my users
14:17:53 <Beelsebob> why not have systematically named files then?
14:18:25 <lisppaste2> sjanssen annotated #20157 with "CAF in where" at http://paste.lisp.org/display/20157#1
14:18:47 <sjanssen_> Cale, Beelsebob: try loading that in GHCi or Hugs, and run main twice
14:20:05 <sjanssen_> actually, this is a little weird
14:20:14 <Beelsebob> hmm?
14:20:19 <sjanssen_> oh, damnit, it's memoizing the result of the sum
14:20:28 <sjanssen_> nevermind, you all are right
14:20:32 <Beelsebob> sjanssen: that effect btw is because it compiles the program and then runs it in the first case
14:20:41 <Beelsebob> and in the second time, just runs it
14:23:34 <Cale> yeah, main is a CAF, so it'll get memoised
14:23:44 <Beelsebob> yes... it remains in scope
14:23:51 <Beelsebob> so it will only be computed once
14:24:40 <sjanssen_> if you compile with -O, GHC will memoize the where bound array
14:25:03 <Cale> It might lift it to the top level
14:25:58 <sjanssen_> yeah, that's what -ddump-simpl reports
14:28:01 <Cale> main = do print $ sum $ map f [1..10]
14:28:03 <Cale>           print $ sum $ map f [1..20]
14:28:21 <Cale> even with optimisations, it will recompute the first 10
14:28:42 <Beelsebob> yes, but you've explicitly told it to do it in sequence there
14:28:52 <Cale> actually with -O2, it won't
14:28:58 <Cale> but with just -O it does
14:29:06 <Beelsebob> will it if you do main = print (sum $ map f [1..10], sum $ map f [1..20])
14:29:20 <Beelsebob> Cale: it damn well shouldn't in the case you showed
14:29:44 <sjanssen_> yeah, I mistyped.  GHC only does the lifting at -O2
14:29:56 <Maddas> Heh, I wonder whether one could -- if it were possible to 'check for equality' in patterns in the first place -- do something like: f f x = ... :-)
14:29:57 <xerox> I read somewhere that if you want that kind of memoization you have to make the sharing explicit
14:30:16 <Beelsebob> you do
14:30:16 <sjanssen_> actually, -O works also
14:30:22 <Cale> xerox: if you don't trust the compiler, you do
14:30:33 <Cale> hmm
14:30:43 <Cale> maybe I was actually running the unoptimised version
14:31:15 <Cale> ah, I'd forgotten to delete the .o in that case
14:32:31 <xerox> I was referring to this: http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
14:33:23 <norpan> lordi lordi
14:34:35 <sjanssen_> well, I've learned something today.  Sorry for being so stubborn ;-)
14:35:07 <Ulfalizer> heh, lordi's singer is pretty crappy live though
14:37:50 <basti_> np: Moby - Lift me up
14:37:54 <basti_> whoops
14:37:59 <basti_> -> #blah
14:41:30 <palomer> Beelsebob: systematically named files?
14:41:47 <palomer> oh, I don't care what the files are named
14:41:52 <palomer> they could be sequential for all I care
14:42:00 <palomer> but I don't want two users to end up with the same filename, tis all
14:42:38 <palomer> so yeah, how would you guys create random strings which are suitable as filenames?
14:44:05 <norpan> it's a function sadly missing from the haskell api
14:45:14 <norpan> but you can use a simple wrapper to tmpnam
14:46:08 <norpan> foreign import ccall "stdio.h tmpnam" tmpnam :: CString -> IO CString
14:46:32 <Beelsebob> palomer: then it's exactly the same as the fresh variable names problem
14:46:42 <Beelsebob> go look at endless papers on generating fresh variable names
14:47:02 <norpan> tmpnam is suitable
14:47:41 <norpan> it's not that secure but it will probably do for you
14:47:45 <vincenz> re
14:49:55 <norpan> and then tmpnam nullPtr >>= peekCString
14:51:32 <norpan> if you're on a posix system you can use System.Posix.Temp.mkstemp
15:08:07 <araujo> mmm..
15:08:13 <araujo> @yarr!
15:08:28 <araujo> @yarr
15:08:30 <lambdabot> I want me grog!
15:08:32 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
15:08:52 <Cale> @yow
15:08:52 <lambdabot> Sign my PETITION.
15:08:56 <Cale> @yow
15:08:56 <lambdabot> Am I in GRADUATE SCHOOL yet?
15:10:23 <Cale> @yow
15:10:23 <lambdabot> Did an Italian CRANE OPERATOR just experience uninhibited sensations in
15:10:23 <lambdabot> a MALIBU HOT TUB?
15:15:31 <bringert> does anyone know the status of GHC on Mac OS X/Intel?
15:27:20 <dcoutts> bringert, ask xerox I think he uses it.
15:28:02 <bringert> xerox: are you using GHC on OS X/Intel?
15:28:33 <xerox> Hi!
15:28:38 <xerox> Yes, an unofficial build.
15:29:21 <bringert> hi xerox
15:29:36 <bringert> can I download it from somewhere?
15:29:44 <xerox> Yup, searching for the url...
15:29:48 * bringert bought a macbook
15:30:14 <xerox> http://www.uni-graz.at/imawww/haskell/ghc-6.5.20060409-i386-apple-darwin.tar.bz2 
15:30:14 <xerox> ``Contents: A command-line based binary distribution of GHC 6.5 (development snapshot from April 9th); gmp 4.2 packaged as a "universal" GMP.framework, libreadline.5.dylib compiled for x86.
15:30:14 <xerox> GMP and libreadline are not installed by the Makefile, you need to install them by hand (to /Library/Frameworks and /usr/local/lib) unless you prefer to use different versions.''
15:30:34 <xerox> I compiled darcs and pugs successfully with that.
15:30:58 <bringert> excellent, thanks
15:31:33 <bringert> I'm new to OS X, lets see how this goes
15:31:35 <xerox> I would really much like if the darwinport's maintainer of the GHC port would plug that in, maybe you could help me pushing the idea if it works for you (:
15:31:43 <bringert> sure
15:32:03 <xerox> Which one did you geT?
15:32:12 <bringert> the cheapest
15:32:29 <bringert> white, 1.83 GHz
15:32:32 <xerox> How's the monitor?
15:32:38 <bringert> shiny
15:32:47 <xerox> ...wrt readability?
15:32:54 <bringert> that actually works better than I thought it would
15:32:59 <xerox> Ah!
15:33:11 <bringert> I've used it outside no problem, though not in direct sunlight
15:33:17 <xerox> Good to hear.
15:35:03 <xerox> I'd love to hear how it goes in the near future :)  I think I'll be sleeping now.
15:35:15 <bringert> ok, good night
15:35:26 * xerox -> bed
15:36:07 <Ulfalizer> i've used my macbook pro a lot outside. the screen is pretty clear even in direct sunlight.
15:41:11 <bringert> ok, cool. I have tried the MacBook in direct sunlight, sitting in the sun is so hot
15:41:19 <hyrax42_> @pl return .
15:41:20 <lambdabot> (line 1, column 9):
15:41:20 <lambdabot> unexpected end of input
15:41:20 <lambdabot> expecting white space or simple term
15:41:28 <hyrax42_> @pl (return .)
15:41:28 <lambdabot> (return .)
15:41:34 <bringert> eh, that should be "haven't@
15:41:50 * bringert is not used to the US keyboard layout
15:41:59 <bringert> s/@/"/
15:41:59 <hyrax42_> newk comp?
15:42:09 <hyrax42_> s/k//
15:42:14 <bringert> yeah
15:42:30 <hyrax42_> the new ibook thingy?
15:42:34 <bringert> yep
15:42:41 <hyrax42_> cool... nice?
15:42:49 <bringert> yeah, really
15:42:54 <hyrax42_> I want :(
15:43:02 <bringert> 512 MB isnot a lot of ram though
15:43:15 <hyrax42_> yeah, apple are really dumb with the ram
15:43:16 <bringert> I think I'll buy some more
15:43:23 <hyrax42_> you NEED a gig or more in OS X
15:43:35 <hyrax42_> 512, a fresh boot will almost have you paging
15:44:36 <norpan> at least 8 GB
15:45:00 * xerox rolls in from the door
15:45:24 <xerox> Mine (512Mb) swaps when I have _many_ apps opened, it is okay for lightweight usage.
15:45:38 <xerox> I am searching for a place to buy a Gb, anyway.
15:45:47 <bringert> I have the same impression
15:46:03 <bringert> xerox: you have a MacBook Pro, right?
15:46:10 <xerox> Nope, a 20" iMac
15:46:16 <bringert> ah, ok
15:46:46 <hyrax42_> well 512 killed me
15:46:54 <hyrax42_> I was getting 5 second app switch times
15:46:59 <hyrax42_> eclipse especially was bad
15:47:04 <xerox> Eeek.
15:47:12 <bringert> I found cheap RAM for MB / MBP in the US, haven't bought any yet: http://dealnews.com/memory/prices/systems/Apple-Mac-Book-Pro-PC2-5300-DDR2-SO-DIMMS/41495/1GB.html
15:47:14 * dcoutts upgraded to 2GB
15:47:15 <hyrax42_> threw in a 512, and everything was fine
15:47:28 <hyrax42_> bringert: how is the screen?
15:47:38 <hyrax42_> not sure about this shiny nonsense
15:47:51 <bringert> it's shiny, but it works better than I thought
15:47:55 <xerox> http://www.transintl.com/macupgrades/index.cfm
15:48:29 <xerox> 155 for 2Gb... hmm
15:48:31 <bringert> hyrax42_: I haven't had any problems with it. It's pretty bright
15:48:34 <xerox> 85 for one.
15:49:30 <hyrax42_> http://eshop.macsales.com/shop/memory/PC4200-DDR2-533MHz-240pin-modules/
15:49:40 <hyrax42_> not sure if that's better
15:50:16 <hyrax42_> definitely not
15:50:38 <xerox> 88/Gb
15:54:03 <shapr> I always end up with the Daft Proposal Presentations.
16:04:05 <ihope_> How do I use the reads function with Parsec?
16:05:30 <norpan> what reads function?
16:05:58 <ihope_> It's called reads. :-)
16:06:00 <ihope_> @type reads
16:06:02 <lambdabot> forall a. (Read a) => ReadS a
16:06:18 <norpan> oh, the one in the prelude?
16:06:32 <norpan> that has nothing to do with parsec
16:06:45 <ihope_> Can I turn it into a Parsec parser?
16:07:18 <norpan> i would think not
16:07:36 <ihope> Oh.
16:07:55 <ihope> Then how do I parse an Int?
16:08:52 <edwinb> tok <- many1 digit, perhaps?
16:09:06 <ihope> Eew. :-P
16:09:22 <norpan> fmap read (many1 digit)
16:10:06 <norpan> Parser :: Int
16:10:09 <norpan> err
16:10:12 <norpan> :: Parser Int
16:11:10 <ihope> That'll work, I guess.
16:11:58 <ihope> So when I see "foo has left freenode (kornbluth.freenode.net irc.freenode.net)", does that mean foo's on kornbluth and I'm not, or the other way around?
16:17:50 <eivuokko> @type getInput >>= choice . map (\(v,x)->string x >> return v) . reads
16:17:52 <lambdabot> Not in scope: `getInput'
16:17:52 <lambdabot>  
16:17:52 <lambdabot> <interactive>:1:13: Not in scope: `choice'
16:17:58 <eivuokko> Damn :)
16:18:05 <eivuokko> Anyway, that does ReadS -> Parser a
16:18:13 <ihope> Whoo.
16:18:16 <eivuokko> Not that it is fast.
16:18:18 <ihope> @index getInput
16:18:19 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
16:18:42 <ihope> @type Text.ParserCombinators.Parsec.getInput
16:18:43 <lambdabot> forall tok st.
16:18:43 <lambdabot>               Text.ParserCombinators.Parsec.Prim.GenParser tok st [tok]
16:18:50 <ihope> @type Text.ParserCombinators.Parsec.choice
16:18:51 <lambdabot> forall a st tok.
16:18:51 <lambdabot>               [Text.ParserCombinators.Parsec.Prim.GenParser tok st a]
16:18:51 <lambdabot>               -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
16:19:01 <ihope> Aha...
16:19:46 <ihope> Hmm, wait.
16:19:57 <ihope> @type reads "bleh"
16:19:58 <psnl> aha?
16:19:58 <lambdabot> forall a. (Read a) => [(a, String)]
16:20:29 <eivuokko> Hm?
16:20:44 <ihope> It looks like there you're trying to use string to push a string back into the "to be parsed" bit.
16:21:07 <dcoutts> Muad_Dibber, heh
16:21:48 <eivuokko> ihope, Nope, it is using string as a parser to get rid of the parsed stuff
16:22:17 <ihope> Ah, getInput doesn't actually consume what you give to it?
16:22:25 <ihope> That is, what you get out of it?
16:22:38 <eivuokko> It returns sourcestream from current position onwards
16:23:14 <norpan> can you really do that with parsec? i thought it had a lookup table for tokens
16:23:28 <eivuokko> Huh
16:23:39 <eivuokko> Maybe you mean Parsec.Token?
16:23:44 <norpan> maybe i'm mixing it up with some other parser lib
16:24:01 <norpan> i probably am
16:24:30 <norpan> anyway, time to sleep
16:24:38 <eivuokko> It is possible and viable to use two-layered Parsec, one for tokenising and one for parsing on token level, but as far as I know, it has no special support inside the monad.
16:31:56 <ihope> My tokenizer is lines. :-)
16:32:53 <ihope> @type Text.ParserCombinators.Parsec.getInput >>=  Text.ParserCombinators.Parsec.choice . map (\(v,x)-> Text.ParserCombinators.Parsec.string x >> return v) . reads -- grr, everything must be in scope at all times
16:32:54 <lambdabot> forall st
16:32:54 <lambdabot>                                                         a.
16:32:54 <lambdabot>                                                       (Read a) =>
16:32:54 <lambdabot>                                                       Text.ParserCombinators.Parsec.Prim.GenParser Char
16:32:54 <lambdabot>                                                                      st
16:32:56 <lambdabot>                                                                      a
16:51:50 <araujo> yay!
16:54:14 <ihope> Woot?
17:55:04 <azuroth> does anyone in here happen to know latin?
17:55:32 <mauke> yes, a bit
17:55:55 <ihope> It's amazing what a person can tell from the string "bsmntbombdood (n=gavin@h-69-3-55-194.dnvtco56.dynamic.covad.net) has joined #haskell".
17:55:59 <ihope> :-)
17:56:40 <bsmntbombdood> yup
17:57:12 <bsmntbombdood> don't root my box ihope
17:57:18 <ihope> :-)
17:57:21 <ihope> I won't.
17:57:25 <azuroth> I'm wondering how to say... "I told a story to the queen" - whether it's "reginae fabulam narrabam" or "fabulam reginae narrabam"... because the second reads to me like "I told stories of the queen," but I can't say for sure?
17:58:01 <azuroth> "I told a story* of the queen", not stories
17:58:31 <ihope> Native speaker of English, know a lot of Python, learning Spanish...
17:58:53 * ihope laughs evilly
17:58:56 <bsmntbombdood> Python is the way to go
17:59:05 <Pseudonym> Much better than Spanish.
17:59:12 <mauke> yeah, it's ambiguous
17:59:37 <ihope> It's just that people can't agree on a reference interpreter for Spanish.
18:00:02 <Excedrin> it wouldn't need one if it had a formal spec
18:00:22 <sjanssen> Spanish-Prime anyone?
18:00:27 <azuroth> so the ablative usually comes after accusative? oh well. I guess in _most_ cases, you could tell from the context...
18:00:28 <ihope> True. But we can't agree on one of those either.
18:00:42 <azuroth> not in the case of the exercise in my book though!
18:01:34 <mauke> no matter how you arrange the words, it still looks ambiguous to me
18:02:03 <azuroth> really? what can "reginae fabulam narrabam" mean?
18:02:28 <mauke> I told a story of the queen
18:03:01 <ihope> I know some Spanish, and some Castilian as well. :-P
18:03:09 <mauke> or "to the queen"
18:03:15 <azuroth> oh, okay. I thought that gen always came after the noun it's affecting. I guess that's just convention thouh
18:03:46 <mauke> even "reginae narrabam fabulam" would work
18:04:26 <azuroth> that's no fun. :-(
18:15:32 <ihope> clase Monada m donde (>>=) :: m a -> (a -> m b) -> m b; volva :: a -> m a; fracase :: Fila -> m a -- :-)
18:15:58 <ihope> But would "String" really be translated as "Fila", or would it be something else?
18:24:17 <sjanssen> ihope: that is an interesting question.  I wonder what non-English speakers call strings
18:24:57 <mauke> zeichenkette
18:25:40 <ihope> I doubt that's the Spanish word for it.
18:25:50 <sjanssen> mauke: is that German?
18:26:13 <ihope> Looks like it.
18:26:25 <sjanssen> yeah, mash up of character and string
18:27:06 <sjanssen> I like that, 'zeichenkette'
18:27:28 <ihope> I don't know German, so I don't know what you're talking about. :-P
18:28:44 <sjanssen> for example: Datei.ByteZeichenkette has a nice ring to it, don't you think?
18:28:58 <dons> I like it!
18:29:01 <ihope> Yeah!
18:29:33 <ihope> Except for the fact that I don't know German, so I don't know what you're talking about.
18:32:39 <dons> I have this function, I didn't know what its type was until now: 
18:32:40 <dons> compare3 :: forall a3 a2 a1 b b3 b2 b1 a. 
18:32:40 <dons>         (ModeledBy a3 b3,
18:32:40 <dons>          ModeledBy a2 b2,
18:32:40 <dons>          ModeledBy a1 b1,
18:32:43 <dons>          ModeledBy a b,
18:32:45 <dons>          Eq b) => (a1 -> a2 -> a3 -> a) -> (b1 -> b2 -> b3 -> b) -> a1 -> a2 -> a3 -> Bool
18:32:48 <dons> fun fun :)
18:33:42 <sjanssen> dons: I decided to start a ByteString.Internal module -- so far I've moved inlinePerformIO, memset and the character counting code I need for Lazy sort.  Are there any others that come to mind?
18:34:47 <ihope> dons: noooo...
18:35:41 <dons> sjanssen: I'm tossing up two options.
18:35:54 <dons> the first is to have a Data.ByteString.Base module, like Data.Array.Base
18:36:08 <dons> this would contain all of the current Data.ByteString.hs
18:36:23 <dons> then a new Data.ByteString, a la Data.Array, would export just the safe stuff
18:36:40 <dons> you'd still be able to get unsafeFoo and friends by importing Base.
18:36:51 <dons> now, the truly internal stuff, we would need that too I guess.
18:36:51 <ihope> @index unsafeFoo
18:36:52 <lambdabot> bzzt
18:37:00 <dons> the way Data.Array.IO.Internal (is that it?) works.
18:37:01 <Igloo> Is inlinePerformIO something that should be moved out of BS to potentially be used by other packages?
18:37:26 <dons> Igloo: possibly ,yes. We need to ask Simon about the safety guarantees. They're super subtle.
18:38:18 <dons> sjanssen: but for a start, we can work on .Internal, containging, say, the ffi stuff, and the truly internal stuff we don't want exported. inlinePerformIO. Anything else?
18:38:30 <Igloo> I was about to say it sounds like the sort of thing that should have unsafe in its name  :-)
18:38:45 <dons> moduleError, sjanssen.
18:39:06 <sjanssen> maybe Common is a better name?
18:39:42 <dons> well, Internal is a convention for things that shouldn't be visible outside the package
18:40:04 <dons> ./base/Data/Array/IO/Internals.hs
18:40:04 <dons> ./base/System/Directory/Internals.hs
18:40:04 <dons> ./base/System/Posix/Internals.hs
18:40:04 <dons> ./base/System/Process/Internals.hs
18:40:10 <dons> Internals.hs , I mean.
18:40:30 <sjanssen> moduleError would need an extra parameter to be shared by Lazy, Char8, etc. still worth it?
18:41:13 <dons> well, what I need is a ByteString interface that doesn't export inlinePerformIO. and I need it shared between some of the ByteString.* modules.
18:41:26 <dons> anything else is a bonus.
18:41:52 <dons> So moduleError maybe not so. its a one liner.
18:42:01 <dons> Factoring out the ffi bindings seems worthwhile though.
18:42:22 * dons drinks more coffee
18:42:35 <dons> yeah, i think go with Internals.hs, and stick inlinePerformIO and the ffi bindings in their.
18:42:39 <dons> there.
18:42:41 <sjanssen> okay
18:43:07 <dons> one thing to keep in mind is what this would look like in fptools/base/Data/
18:43:21 <dons> as we need to merge fps head back in to fptools every now and then.
18:44:12 <sjanssen> dons: what kind of concerns does that entail?  Just that we use conventions similar to other packages?
18:44:23 <machack666> hola, folks.  I'm trying to write a parser to turn an octal string into the corresponding character; i.e., "\053" -> '+'.  We also want to support less than 3 total digits (any missing digits are considered to be leading 0's).  Regex-wise, I'm looking for /\\[0-7]{1,3}/.  When I try to construct the parser in Parsec, I run into problems.  I didn't see anything akin to the range match combinator (i.e., 1-3 matches of (oneOf "0123
18:44:23 <machack666> 4567")).  While I could do { octStr <- try count 3 octDigit <|> try count 2 octDigit <|> octDigit } this seems to be less than ideal.  What easy solution am I missing? :)
18:44:34 <dons> just safety really. anyone could pick up Data.ByteString and use it.
18:44:45 <dons> so we don't want unsafeFoo or inlineBar easy to abuse
18:44:50 <sjanssen> yeah, exactly
18:44:54 <dons> Internals.hs is good for this.
18:45:02 <dons> the current scheme of exporting via ByteString.hs not so good.
18:45:21 <sjanssen> inlinePerformIO doesn't even sound that scary, but it's even meaner than unsafePerformIO
18:45:37 <dons> hmm. evilPerformIO perhaps.
18:45:56 <dons> inlineOfDeathPerformIO
18:46:13 <ihope> @index inlinePerformIO
18:46:14 <lambdabot> bzzt
18:46:18 <sjanssen> a creative name could be fun
18:46:58 <machack666> I tried { oct1 <- octalDigit; oct2 <- optional octalDigit; oct3 <- octalDigit; -- try something with concating the values}, but I get a type mismatch. Parser [Char] vs Parser ().
18:58:27 <sjanssen> @hoogle CString
18:58:27 <lambdabot> Foreign.C.String.CString :: type CString
18:58:27 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
18:58:27 <lambdabot> Foreign.C.String.newCString :: String -> IO CString
19:03:11 <sjanssen> does Hugs support existentials?
19:04:15 <dons> yeah, I think so.
19:04:51 <dons> nhc does too.
19:05:30 <sjanssen> how does one install Cabal packages for Hugs?
19:06:22 <dons> the usual way. ./Setup configure --hugs ; ./Settup build ; ./Setup install
19:06:55 <dons> to get existentials, you probably need to say: runhugs -98 (to turn off H98)
19:11:04 <dons> damn it, this HTYPEINT_MAX thingy got into the hugs release. no hugs 06 building out of the box on openbsd :/
19:11:30 <Pseudonym> I read that ia HYPEINT_MAX.
19:11:42 <Pseudonym> It's like normal INT_MAX, only grossly over-inflated.
19:11:48 <dons> hehe
19:11:58 <dons> ah, but I see ByteString.hs is in the new hugs :)
19:12:13 <Pseudonym> ByteString.hs _is_ the new Hugs!
19:12:26 <Pseudonym> That and HList.
19:12:26 <dons> hehe
19:19:44 <sjanssen> @seen dcoutts
19:19:45 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 2 hours, 39 minutes and 6 seconds ago.
19:21:06 <sjanssen> dcoutts: I've just attempted to emerge cpphs-1.2, and the tarball is the wrong size, any idea why?
19:21:24 <MarcWeber> Is there a while :: IO Bool -> IO () function?
19:22:43 <dons> ?hoogle IO Bool -> IO ()
19:22:43 <lambdabot> System.Win32.Types.failIfFalse_ :: String -> IO Bool -> IO ()
19:22:51 <dons> ?hoogle Bool -> IO ()
19:22:51 <lambdabot> System.Console.Readline.functionDumper :: Bool -> IO ()
19:22:51 <lambdabot> System.Console.Readline.setDone :: Bool -> IO ()
19:22:51 <lambdabot> System.Console.Readline.setFilenameCompletionDesired :: Bool -> IO ()
19:23:01 <dons> ?hoogle guard
19:23:02 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
19:23:02 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
19:23:02 <lambdabot> Language.Haskell.TH.Guard :: data Guard
19:23:29 <dons> ?hoogle when
19:23:30 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
19:23:30 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
19:28:04 <MarcWeber> dons: I've tried hoogle, too. A function like this seems to be missing (easy to implement, though)
19:30:23 <SamB_XP_> ooh, I7 IDE for Linux! In Haskell! http://www.thewhitelion.org/inform7/
19:30:31 <SamB_XP_> didn't know Haskell was good for RAD
19:30:41 <SamB_XP_> (of GUI apps)
19:32:58 <Pseudonym> I wouldn't necessarily think of Z-code as "GUI apps".
19:33:43 <SamB_XP> not Z-code
19:33:55 <Pseudonym> Well, Inform.
19:34:43 <SamB_XP> I meant that this seems to be the first released I7 IDE for Linux ;-)
19:34:57 <SamB_XP> I7 just came out on the first...
19:36:03 <SamB_XP> okay, so it is basicly a text editor with some HTML panes and an embedded Z-machine interpreter...
19:38:24 * SamB_XP waits for the tarball to finish downloading so he can take it for a spin
19:38:33 * SamB_XP hopes it will build
19:39:19 <sjanssen> dons: should Data.ByteString.Internal be in the .cabal file?  I would think it isn't okay for it to be an Exposed-module
19:39:50 <Lemmih> Shouldn't it be in Other-modules?
19:39:51 <dons> no, we make it a hidden module. what's the sytnax for that.
19:39:55 <dons> Other-modules:, yeah.
19:40:05 <SamB_XP> why not?
19:40:05 <Lemmih> Morning guys.
19:40:10 <azuroth> is there an easier way to have a window-manager in a window, than say, vnc-server and connecting?
19:40:32 <SamB_XP> Xnest?
19:40:40 <SamB_XP> run Plan 9?
19:41:02 * azuroth apt-gets xnest
19:41:17 <azuroth> thanks :-)
19:41:34 * SamB_XP was just kidding about plan 9, of course ;-)
19:42:41 <azuroth> I'm just going to try Ion now. I tried ratpoison a bit ago, but I couldn't figure out how/whether to do multiple desktops
19:44:14 <MarcWeber> azuroth: wmii.de
19:45:33 <dons> ion's pretty popular around here. I think its great.
19:45:48 <hyrax42_> for reexporting imported functions/types
19:45:52 * SamB_XP uses windowmaker for some reason
19:46:04 <azuroth> MarcWeber: I'll check that out after ion :-)
19:46:09 <hyrax42_> module my module (mystuff, Other.Type, Other.fn) where
19:46:09 <hyrax42_> ?
19:46:27 <hyrax42_> followed by import Other?
19:46:52 <SamB_XP> just list the in-scope names in the export list
19:46:53 <azuroth> think so, hyrax42_
19:47:07 <hyrax42_> oh so they don't need to be qualified?
19:47:22 <SamB_XP> only if you imported them that way or they clash
19:47:40 <hyrax42_> can you reexport an entire module?
19:47:44 <SamB_XP> yeah
19:47:51 <SamB_XP> for that, just say "Module Foo.Bar"
19:47:59 <SamB_XP> er, s/Module/module/
19:48:13 <hyrax42_> in export list?
19:48:19 <SamB_XP> uh huh
19:48:28 <hyrax42_> thanks
19:48:35 <MarcWeber> azuroth: I like wmii much more but use the snapshot version.. 
19:56:34 <azuroth> geez, it has real trouble drawing a gnome-terminal in xnest, but drawing an xterm is nothing...
19:58:30 * SamB wonders how to use an MSI file with WINE
20:04:05 <MarcWeber> This is my attmept .. but the loop condition seems to be evaluated only once? How to fix this while loop?
20:06:48 <azuroth> where is it, MarcWeber?
20:32:25 <sjanssen> there should be peekForeignPtr and pokeForeignPtr
20:34:32 <azuroth> what's the idea behind ForeignPtr and Ptr, anyway?
20:35:11 <sjanssen> azuroth: Ptr's are just addresses in memory
20:35:16 <azuroth> oh, gc..? nice
20:35:51 <sjanssen> actually, Ptr doesn't do any GC.  But ForeignPtr does
20:36:21 <sjanssen> that's the difference, ForeignPtr lets you attach code to run when there are no more references to it
20:36:22 <SamB> Ptr is just like a C pointer, really
20:36:28 <SamB> in fact, usually *is*
20:36:53 <sjanssen> yes, a C pointer, complete with casting and the whole shebang
20:37:11 <sjanssen> but really, it's a huge PITA to use foreign pointers
20:37:49 <azuroth> I haven't really played with pointers, or anything really yet.
20:38:15 <sjanssen> azuroth: ideally, you'll never have to
20:38:35 <bringert> hmm, an empty line at the end of the cabal fail causes cabal to fail in a weird way on my machine
20:38:40 <azuroth> hehe :-) what are you using them for?
20:38:50 <sjanssen> they're only useful for FFI, and code like Data.ByteString
20:38:59 <sjanssen> azuroth: hacking on ByteString
20:39:05 <azuroth> ahh
20:39:29 <azuroth> scary stuff
21:22:18 <dons> ?karma+ sjanssen -- thanks for the patch
21:22:18 <lambdabot> sjanssen's karma raised to 11.
21:22:29 <sjanssen> sure
21:27:45 <sjanssen> are withForeignPtr's expensive?  say I've got to peek at a ForeignPtr many times, is there a big difference in doing a withForeignPtr every access vs. wrapping the whole computation in withForeignPtr
21:28:45 <dons> no, they compile away to almost nothing.
21:28:55 <dons> and the Addr# is cached in the ForeignPtr anyway
21:29:08 <sjanssen> that's what I hoped
21:29:11 <dons> oh, hmm. wrapping the whole thing is still better, I'd think.
21:29:28 <dons> better to unwrap, get the Ptr and use that.
21:29:53 <dons> I seem to recall a benefit, but can't remember the numbers
21:30:04 <dons> you'll certainly get better code
21:30:19 <evergreen> I'm a haskell newbie and I'm having a problem configuring a cabal package.
21:30:30 <dons> evergreen: yeah, what problem?
21:30:48 <evergreen> The package is halfs: http://hackage.haskell.org/trac/halfs/wiki/CabalInstallation
21:31:06 <evergreen> I type: ./setup configure
21:31:13 <evergreen> and I get: setup: Line 39: Unknown field 'ghc-prof-options'
21:31:25 <dons> oh, looks like a new Cabal flag.
21:31:34 <dons> you'll need a newer Cabal installed, most likely.
21:31:38 <dons> do you have ghc 6.4.2?
21:31:48 <evergreen> 6.4.1
21:31:56 <dons> actually, unless you need to do profiling, you can just comment out that line.
21:32:03 <evergreen> Ah.
21:32:07 <evergreen> I'll try that.
21:35:35 <evergreen> dons: Thanks; that worked.  It's not obvious to me what the comment syntax is in a .cabal file, so I just removed all the lines that referred to ghc-prof-options.
21:36:15 <bringert> anyone here using ghc on OS X/Intel?
21:57:31 <Pegazus> does anyone knows the algorithm for recursion elimination? (for any kind of recursion, tail recursion is easy...) i mean for any one... (and using a stack and "local vars" isn't valid)?
21:57:51 <Pseudonym> What do you want to eliminate recursion with?
21:58:04 <Pegazus> i want the general algorithm
21:58:09 <Pegazus> it isn't any specific function
21:58:35 <Pseudonym> In general, you need to replace it with an equally powerful primitive.
21:58:39 <Pseudonym> e.g. continuations
21:58:52 <Pseudonym> But I wonder why you'd want to do that.
21:59:04 <Pseudonym> Unless you're a compiler, I suppose...
21:59:33 <Pegazus> i want to know :)
22:01:36 <Pseudonym> The thing is, any sufficiently general mechanism basically has a stack.
22:01:49 <Pseudonym> Whether it's explicit, or implicit in the semantics of the abstract machine that you compile to.
22:02:23 <Pseudonym> I suppose pure lambda calculus with SK combinators doesn't have an explicit stack exactly.  But it's implicit in the graphs that you generate.
22:03:03 <Pegazus> i don't have a problem with stacks
22:03:23 <Pegazus> what i don't want is to use the stack, as CPU uses to executes the recursive functions
22:03:34 <Pseudonym> Ah.
22:03:51 <Pseudonym> You said "using a stack and "local vars" isn't valid".
22:03:56 <Pegazus> yes
22:03:58 <Pseudonym> Sorry for the nested quotes.
22:04:02 <Pegazus> if you push all de local vars
22:04:06 <Pegazus> like "ASM" does
22:04:12 <Pegazus> that's not usefull
22:04:23 <Pegazus> if you use a stack, explicit, doing something intelligent it's ok
22:04:33 <Pseudonym> @google "compiling with continuations"
22:04:35 <lambdabot> http://www.cs.princeton.edu/~appel/papers/cwc.html
22:04:44 <Pseudonym> Read and be enlightened.  Or stuff.
22:06:07 <int-e> oh - you just want stack (or whatever undbounded storage you use for flow control) manipulations to be explicit.
22:06:46 <Pseudonym> Often, people want to do silly things with the C stack, and still maintain Unix semantics.
22:06:52 <Pseudonym> wrt signal delivery.
22:07:08 <Pseudonym> For that, you just do silly things with ANOTHER stack instead.
22:07:50 <int-e> Pseudonym: hmm. as long as the stack is used as a stack there shouldn't be a problem?
22:08:08 <Pseudonym> Maybe.
22:08:09 <int-e> I guess it's awfully platform specific in any case.
22:09:05 <Pseudonym> Using the stack in a Unix-holy manner means you can end up manipulating the stack pointer more than you have to, even in "leaf" calls.
22:10:10 <Pseudonym> Logic languages, which allow "failure", often require very-non-local returns which do silly things with the stack.
22:10:11 * int-e doesn't really know about non-x86 assembly.
22:10:59 <int-e> setjmp and longjmp are fairly standard though. And it's still using the stack as a stack; you're just popping off many elements at once.
22:12:24 <Pseudonym> No, I mean silly things like accessing bits of the popped stack in the setjmp handler.
22:12:28 <Pseudonym> Or the equivalent of.
22:13:14 <Pseudonym> It'd take too long to explain, but the central point is that the stack that your language recurses on doesn't have to be the Unix C stack.
22:15:46 <int-e> sure.
22:16:52 <int-e> And that has little to do with whether the C stack could be used or not.
22:17:29 <Pseudonym> Not aleays.
22:17:50 <Pseudonym> One of the advantages is that your run-time system doesn't have to preserve the same invariants that Unix requires.
22:30:02 <davidmccabe> When there is an array index error, why doesn't ghc give any indication as to where?
22:30:59 <vincenz> Pseudonym: stack and local vars aren't reqqed
22:31:08 <vincenz> Pseudonym: afaik appel puts the different stack bits on the heap
22:31:19 <vincenz> thereby making it less stacky
22:31:25 <vincenz> callframes
22:31:58 <Pseudonym> Right.
22:32:26 <vincenz> which would forego a lot of problems with setjmp
22:32:42 <vincenz> (if not all)
22:32:51 * vincenz ponders
22:33:54 <evergreen> After hacking at a few other bits of the halfs source code, I'm now getting the error "Could not find module `Control.Monad.Error': it is a member of package mtl-1.0, which is hidden ".
22:33:56 <vincenz> on another note, I'm not certain about this so I'm going to phrase it a question, isn't there an algorithm that can remove a large class of recursions and make it into loops?
22:34:12 <vincenz> even algorithms that don't recurse linearly
22:34:44 <evergreen> but "ghc-pkg -l" shows "mtl-1.0" (without parentheses), which I think means it's not hidden.
22:36:46 * vincenz puts up an article that might be of interest to all phd and postdoc studens
22:36:50 <vincenz> http://www.qinfo.org/people/nielsen/blog/archive/000120.html
22:38:42 <evergreen> Does anyone know what that error message means?
22:39:05 <sjanssen> davidmccabe: as in line number?
22:40:40 <Lemmih> vincenz: Add a -package mtl
22:40:45 <davidmccabe> sjanssen: or anything, really.
22:42:18 <vincenz> Lemmih: thank you I willl certainly email the guy with that article
22:42:27 <evergreen> Lemmih: The command this page told me to run is "./setup build": http://hackage.haskell.org/trac/halfs/wiki/CabalInstallation
22:43:04 <evergreen> Lemmih: "./setup" doesn't seem to accept "--package mtl"; it gves the error "setup: Unrecognised command: mtl (try --help)".
22:44:44 <Lemmih> evergreen: Add mtl to the build-depends.
22:44:49 <Lemmih> (the the .cabal file)
22:44:54 <Lemmih> *in the
22:45:37 <evergreen> Lemmih: Thanks; that worked!
22:45:43 <sjanssen> davidmccabe: poor error reporting is  known problem.  Laziness makes good error reporting difficult, because the error doesn't happen until the computation is forced.
22:45:59 <davidmccabe> hmm.
22:46:18 <skew> davidmccabe: I see at least the index and the bounds of the array
22:46:46 <davidmccabe> I see nothing.
22:47:30 <Lemmih> vincenz: Oh sorry. It was meant for evergreen.
22:48:38 <sjanssen> davidmccabe: what is your index type?
22:49:05 <vincenz> Lemmih: yep :d
22:49:11 <skew> I'm running 6.5, that's probably why
22:49:14 <davidmccabe> (Int, Int)
22:49:21 <sjanssen> > listArray (1, 1 :: Int) [(1, 1)] ! 12
22:49:22 <lambdabot> Exception: Ix{Int}.index: Index (12) out of range ((1,1))
22:50:11 <sjanssen> > listArray (1, 1 :: Word) [(1, 1)] ! 12
22:50:11 <lambdabot> Exception: Error in array index
22:51:14 <sjanssen> davidmccabe: only certain types will give you the index, GHC obviously has special cases for a few types, just not yours
22:51:18 <davidmccabe> the later error is what I'm getting. what's with the Word/Int difference?
22:51:36 <davidmccabe> hmm, I see.
22:52:01 <xerox> 'morning!
23:06:42 <Taral> whee!
23:10:54 <Taral> @ping igloo
23:10:55 <lambdabot> Not in scope: type variable `igloo'
23:11:05 <Taral> @ping Maybe
23:11:06 <lambdabot> * -> *
23:11:09 <Taral> weird
23:11:39 <Cale> heh, it's correcting the spelling to 'kind'
23:11:52 <Cale> only 2 letters different :)
23:12:14 <Cale> @you
23:12:14 <lambdabot> Did I SELL OUT yet??
23:12:22 <Cale> @wow
23:12:22 <lambdabot> How's the wife?  Is she at home enjoying capitalism?
23:12:33 <Cale> @cow
23:12:33 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
23:12:42 <Cale> @meow
23:12:42 <lambdabot> An Italian is COMBING his hair in suburban DES MOINES!
23:12:45 <Cale> hehe
23:12:51 * xerox stops COMBINING (:
23:12:52 <Pseudonym> @chow
23:12:52 <lambdabot> Maybe you meant: echo yow
23:13:12 <Pseudonym> @dow
23:13:13 <lambdabot> Excuse me, but didn't I tell you there's NO HOPE for the survival of
23:13:13 <lambdabot> OFFSET PRINTING?
23:14:19 <Taral> @ow
23:14:19 <lambdabot> I think I'm having a mid-week crisis.
23:17:06 <palomer> yay!
23:17:17 <Taral> ?
23:17:27 <palomer> the new emacs fixes the ghc --make slowness incured by the older emacs
23:17:31 <Taral> Ah, nice.
23:17:44 <Taral> I'm compiling ghc 6.4.2 because *someone* still hasn't updated Debian.
23:17:51 <Taral> *cough*igloo*cough*
23:18:15 <palomer> what does 6.4.2 have?
23:18:35 <Taral> many many bug fixes
23:18:54 <vincenz> palomer: there's another improved version to emacs, which fixes a TON of bugs
23:26:54 <palomer> vincenz: what's it called?
23:27:57 <vincenz> vim
23:28:39 <dons> vincenz: very nice :)
23:28:42 <dons> ?palomer
23:28:42 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
23:28:45 <dons> ?palomer
23:28:45 <lambdabot> Hrmph
23:28:46 <dons> ?palomer
23:28:47 <lambdabot> That's nuts!
23:28:49 <dons> A
23:28:53 <dons> its in here some where..
23:28:54 <dons> ?palomer
23:28:54 <lambdabot> That's nuts!
23:28:56 <dons> ?palomer
23:28:56 <lambdabot> Pfft
23:29:03 <dons> ?palomer -- last try
23:29:03 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
23:29:08 <dons> bah
23:29:15 <palomer> I like that quote
23:29:25 <palomer> hullo dons!
23:29:33 <dons> there's one in there about how vim is pointless
23:29:42 <palomer> @palomer
23:29:42 <lambdabot> Scalliwags!
23:29:44 <palomer> @palomer
23:29:44 <lambdabot> Soylent green is people
23:29:47 <palomer> @palomer
23:29:47 <lambdabot> They're telling you lies!
23:29:50 <dons> its all GOLD
23:30:11 * dons goes out to buy some chocolate
23:30:13 * palomer kicks the magnesium.net admins for not having pdflatex installed
23:31:16 <vincenz> @vincenz
23:31:17 <lambdabot> Unknown command, try @list
23:31:18 <vincenz> =(
23:31:34 <vincenz> palomer: hours for a 2 line program?
23:32:08 <palomer> EH?
23:32:19 <palomer> ah yes
23:32:28 <vincenz> o.O
23:32:29 <palomer> it was because I wasn't trimming my search space
23:32:36 <palomer> the way I was going about it is quite neat, actually
23:32:38 <vincenz> so
23:32:46 <vincenz> if you have a few 100 kLOC
23:32:54 <vincenz> you can compile away for years on end :)
23:33:09 <palomer> after trimming it's instantaneous
23:33:41 <palomer> I added nondeterminism to the state monad, thus creating threads. the problem is that I would sometimes create many of the exact same thread
23:33:48 <palomer> so I wrote a function which nubs the threads
23:34:33 <palomer> there's no way of getting around the threads, since you don't have principle types
23:34:47 * vincenz nods silently 
23:35:05 <palomer> and all the children sing!
23:36:25 <vincenz> que es principal types?
23:38:06 <palomer> in most HM type systems, a term is typeable by a type which subsumes all other types which type the term
23:38:19 <palomer> for example, the principle type of \x -> x is forall a. a -> a
23:38:28 <palomer> which subsumes Int -> Int and Bool -> Bool
23:38:40 <vincenz> check
23:39:26 <vincenz> oh
23:39:38 <vincenz> like a po-tree with a unique lower bound
23:39:52 <vincenz> or unique greatest bound depending on how you look at what big and small is
23:40:35 <vincenz> how can you not have principal types?
23:41:11 <palomer> po-tree?
23:41:15 <palomer> partially ordered?
23:41:28 <vincenz> yh
23:41:31 <vincenz> +a
23:41:32 <palomer> yes, the lower bound is unique in the subsumption latice
23:41:42 <palomer> lattice
23:41:59 <palomer> or, rather, there is a lower bound
23:42:05 <palomer> (which, of course, must be unique)
23:42:18 <palomer> have you programmed with GADTs?
23:42:21 <vincenz> no
23:44:27 <palomer> hrmph
23:44:40 <palomer> I believe that higher rank type systems don't have principle types
23:45:04 <palomer> well, gadts let you assign arbitrary types to your constructors
23:45:07 <vincenz> why the harruumph
23:45:18 <palomer> do you know what the K combinator is?
23:45:24 <vincenz> constant
23:45:27 <palomer> righto
23:45:28 <vincenz> Kx = x
23:45:32 <palomer> @type \x y -> x
23:45:33 <lambdabot> forall t t1. t -> t1 -> t
23:45:41 <palomer> Kxy = x
23:45:45 <vincenz> rightio
23:46:19 <palomer> well, if I was going to write a Combinatory datatype with constructors K and S I would give K the type a -> b -> a
23:46:23 <palomer> don't you think this reasonable?
23:46:51 <vincenz> yup
23:47:01 <vincenz> out of curiousity
23:47:16 <vincenz> if in GADTS each data const has a different type
23:47:19 <vincenz> and you have some func
23:47:21 <vincenz> GADTS -> something
23:47:30 <vincenz> how do you ensure what comes out is of one type
23:47:37 <vincenz> as programmer
23:47:49 <palomer> what do you mean? do you have a concrete example?
23:48:13 <vincenz> Yoyo a b c d = Foo (a->b)  | Bar (c->d)
23:48:21 <palomer> oh, that doesn't work
23:48:27 <vincenz> ?
23:48:31 <palomer> the return type of the constructor must be an application of the head dataconstructor
23:48:44 <palomer> Yoyo a b c d = Foo :: a -> YoYo a b c d
23:48:52 <palomer> s/where/=
23:48:58 * vincenz scratches
23:49:01 <vincenz> nono
23:49:11 <vincenz> Foo IS :: (a->b) -> Yoyo a b c d
23:49:16 <palomer> ahh
23:49:16 <palomer> gotcha
23:49:17 <vincenz> but contains (a->b)
23:49:20 <palomer> ok
23:49:23 <vincenz> so now
23:49:29 <vincenz> plop :: Yoyo a b c d -> d
23:49:54 <vincenz> For Bar, just supply a 'c' parameter
23:49:58 <vincenz> but for foo?
23:50:44 <vincenz> plop :: Yoyo a b c d -> (c->a) -> (b->d) -> c -> d
23:50:49 <vincenz> that's required to make it owrk
23:50:58 <vincenz> with more datacons it'd come with more conversions
23:51:13 <palomer> what type do you want plop to have?
23:51:19 <vincenz> take a Yoyo
23:51:21 <vincenz> gimme a d
23:51:53 <palomer> but, erm, you can't get a d from a Foo
23:52:00 <vincenz> yes you can
23:52:03 <vincenz> if you pass it a c
23:52:07 <vincenz> erm
23:52:09 <vincenz> Bar even
23:52:16 <vincenz> yes for Foo you need conversion functions
23:52:28 <vincenz> as shown in the second type
23:52:31 <vincenz> plop :: Yoyo a b c d -> (c->a) -> (b->d) -> c -> d
23:52:39 <ADEpt> is there any way to find out what "blocks" the STM transaction?
23:53:39 <palomer> vincenz: I don't see how this kind of stuff could ever be useful
23:55:10 <palomer> seems to go against the spirit of GADTs
23:55:19 * vincenz shrugs
23:55:44 <palomer> but yes, wacky type constructor types beget wacky function types
23:56:17 <vincenz> anyways
23:56:19 * vincenz is off
23:56:24 <palomer> cya
