00:01:02 <palomer> but I still don't see why we'd need Map and Bind
00:01:06 <Cale> an easier project would be to stick to regular expressions on a fixed token type (without even the higher order Check), and try to apply algorithms to optimise regular expressions
00:01:25 <Cale> palomer: well, it depends on what you want to do
00:01:35 <Cale> Bind is very powerful
00:01:56 <Cale> It basically lets you write context sensitive parsers
00:02:31 <Cale> Map is easy enough, and I think it would be harmless.
00:02:43 <palomer> where the context is the input to the second input to Bind?
00:02:56 <Cale> yeah
00:03:36 <Cale> Bind x f  parses using x, then takes the result and applies f to it, getting a new parser with which to parse the rest of the text
00:04:09 <palomer> yeah, I see how that could effect things
00:04:25 <palomer> and why do we want it?
00:04:32 <palomer> (why not just stick to CFGs?)
00:04:55 <Cale> perhaps we don't need it
00:04:58 <palomer> my god bind would be powerful
00:05:29 <Cale> (and it is powerful in things like Parsec and ReadP)
00:06:22 <palomer> I don't see how Map works though
00:06:36 <palomer> is it simply composition?
00:06:36 <Cale> Map just does some transformation on the result of the parser
00:06:42 <palomer> ahh
00:06:43 <palomer> gotcha
00:08:00 <palomer> what's your email? I'll send you the proposal tonight
00:08:07 <palomer> (in like 5 minutes)
00:08:09 <Cale> cgibbard at gmail
00:08:55 <Cale> SamB is also interested in parsing
00:09:11 <davidhouse> what are those odd guard-like things on class definitions?
00:09:17 <Cale> He proposed implementing ParsecT which is also something we badly need
00:09:27 <Cale> davidhouse: functional dependencies
00:10:07 <davidhouse> Cale, those are a GHC extension, right?
00:10:14 <Cale> davidhouse: basically, it says that the type variables on the left side of an arrow together uniquely determine the variables on the right side
00:10:14 * davidhouse checks the GHC user manual
00:10:15 <Cale> yes
00:10:24 <Cale> So if you have
00:10:36 <Cale> class MonadState m s | m -> s where
00:10:38 <Cale> ...
00:11:01 <Cale> You're saying that your monad type determines the type of the state that it carries around.
00:11:12 <Cale> (which helps type inference)
00:11:29 <davidhouse> hm.
00:11:37 <davidhouse> so they're not completely necessary?
00:12:16 <Cale> well, in some cases they're mostly necessary
00:12:30 <Cale> I suppose you could type-annotate everything
00:12:42 <palomer> Cale: maybe me and SamB could work on parsing together. I'd write Palomerec and he'd write ParsecT and PalomerecT
00:12:55 <davidhouse> heh, Palomerec.
00:13:43 <palomer> what are the pittfalls of parsec? no left recursion and new term rewriting optimizations are not easy?
00:14:47 <Cale> well, and it tends to be tricky to write parsers which aren't LL(1), but that's already fixed in various other libraries
00:16:38 <palomer> actually, we don't need GADTs for this
00:16:53 <palomer> GADTs just make things convenient
00:17:05 <palomer> or, rather, usable
00:17:17 <palomer> you could write your parse tree without GADTs
00:17:21 <Cale> yeah
00:17:36 <Cale> well
00:17:50 <Cale> depends on some things
00:18:55 <Cale> If you want the parser to be decomposable, then you might end up with something like HList if you don't use GADTs
00:19:14 <palomer> ugh
00:19:22 <palomer> HLists aren't the prettiest things in the world
00:21:25 <palomer> hmm, this parser would probably have better errors messages than parsec
00:24:23 <palomer> well, hrmm, maybe not (after we mangle the tree with our term rewriting)
00:26:48 <palomer> well, I'm off to bed
00:26:49 <palomer> night!
01:02:07 <Lemmih> Oeje1: ping.
01:07:46 <dons> Lemmih, I think we should hier-ise the compiler/ dir too :)
01:07:52 <dons> GHC.Foo seems good
01:12:28 <dons> dcoutts_: I'd be interested to see if  your packByte bug has gone away. Can you test it now?
01:14:07 <dons> Lemmih: esp. now its all in darcs, so moving things around is less painful
01:16:37 <dons> oh , that's cool, israeli researchers use mobile phone towers to measure rainfall patterns and density
01:17:02 <dons> i can roughly tell how strong the rain is based on my wifi broadband strength :) and packet loss.
01:26:40 <dons> hmm, good thing for split-objs: $ length ByteString.hs
01:26:40 <dons> 2219
01:26:40 <dons> $ du -hs ByteString.o  
01:26:40 <dons> 224K    ByteString.o
01:26:40 <dons> $ du -hs ByteString.p_o
01:26:43 <sethk> dons, in the New York area the change in range between winter and summer is about 12%, because of leaves and other growth
01:26:49 <dons> 448K    ByteString.p_o
01:27:01 <dons> sethk, very interesting. hadn't thought of that.
01:27:11 <dons> I should log my wifi range stats.
01:27:23 <sethk> dons, be interesting.
01:29:37 <dons> it improves muchly at night. esp. after midnight. but I haven't noticed seasonal things. mostly if the radio is clear, the wifi is good too (they seem to be affected by the same weather events)
01:29:49 <norpan> hi all
01:29:57 <dons> norpan: how's the hacking going?
01:30:09 <norpan> forward slowly
01:30:19 <dons> what's this 'ere, Lemmih?
01:30:19 <dons> /usr/obj/build/libraries/base/GHC/IOBase.hi:
01:30:19 <dons>   Could not find module `GHC.Dynamic':
01:30:19 <dons>     use -v to see a list of the files searched for
01:30:47 <norpan> how about a shortcut for cons when s>0 and peekByteOff p (s-1) = c
01:30:48 <dons> oh, that's base/GHC.Dynamic. not some ghc-api ism. silly me.
01:30:53 <Lemmih> dons: I'm afraid moving it to GHC.* could easily clash with the modules from base.
01:31:09 <dons> yeah, i realise now :)
01:31:32 <dons> norpan: hmm. interesting. how often does that happen?
01:31:33 <dons> any stats?
01:31:45 <norpan> i have no idea :)
01:32:00 <dons> its an interesting idea.
01:32:15 <dons> tis a slightly weird shortcut though. there's nothing like it in the lib elsewhere :)
01:32:20 <norpan> function x:xs = if ... then ... else ... (x:xs) is something i see sometimes
01:32:26 <dons> ?karma+ norpan for the weirdest fps heuristic so far.
01:32:26 <lambdabot> norpan's karma raised to 1.
01:32:36 <norpan> i guess you would not write it like that for bytestrings though
01:32:55 <dons> no,s since you can't pattern match on the cons anyway
01:33:15 <dons> Lemmih, Compiler.* ?
01:33:20 <norpan> i'm making a headTail and a initLast function
01:33:28 <dons> (I just don't like this GhcLib name, seems a bit awkward)
01:33:45 <norpan> also, how about a lazy unpack?
01:33:47 <dons> norpan: headTail seems useful, to replace all that pattern matchign code.
01:33:54 <Lemmih> Yeah, neither do I.
01:34:08 <norpan> also, for UTf-8 it would avoid checking the first char twice
01:34:09 <dons> System.GHC :)
01:34:26 <dons> nrooh, you don't use unsafeHead ?
01:34:32 <dons> grr. missed a \t there :)
01:34:56 <norpan> i'm talking UTF-8 here
01:34:59 <norpan> there is no unsafeHead
01:35:10 <dons> I always use unsafeHead, once I've handled the [] case with P.null.
01:35:35 <dons> ah, didn't realise.
01:35:45 <Lemmih> Good night, #haskell.
01:35:52 <dons> night Lemmih
01:35:56 <norpan> good morning "haskell
01:36:00 <norpan> err #haskell
01:36:08 <dons> ?localtime Lemmih
01:36:11 <lambdabot> Local time for Lemmih is Sat May  6 10:40:22 2006
01:36:23 <dons> oh my
01:36:26 <dons> its getting worse.
01:36:29 <norpan> ?localtime norpan
01:36:34 <lambdabot> Local time for norpan is Sat May  6 10:36:08 2006
01:36:41 <norpan> hey, how does it know?
01:36:58 <dons> Lemmih is like your biological doppleganger, norpan 
01:37:12 <dons> hmm, evil twin, perhaps.
01:37:28 <dons> norpan: it talks ctcp ping
01:37:49 <norpan> oh, so it did
01:37:49 <dons> ctcp time returns the time from many clients (not all though)
01:39:11 <norpan> good, simpler code: head = fst . headTail
01:39:48 <norpan> slower code perhaps
01:39:52 <dons> I'd want to check how that compilers.
01:40:15 <dons> then again, you get a shorter headTail, the other way around
01:40:52 <norpan> there is always room for optimization
01:41:05 <dons> that is very true.
01:41:05 <norpan> i just want to make it complete and O()-optimized
01:41:43 <norpan> then we can hack away
01:41:47 <norpan> optimize
01:41:54 <dons> yep. I found Bench.hs invaluable with spotting O()-leaks.
01:42:07 <norpan> yeah
01:42:16 <norpan> i'm going by those results when optimizing
01:42:23 <norpan> but how about that lazy unpack
01:42:26 <norpan> could be useful
01:42:49 <dons> well, there is such a thing already, unpackList, which ghc will fuse with list operators expecting lazy resultss
01:43:01 <norpan> i see
01:43:15 <dons> unpack gets rewritten to the lazy unpack when there's a list function on the other side.
01:43:33 <dons> and hopefully the the intermediate list gets removed
01:43:42 <norpan> only in ghc though
01:43:50 <norpan> but who cares about the others :)
01:44:19 <dons> right. the performance is good in hugs, but if you really want speed, you're not using hugs anyway
01:44:58 <dons> the important thing is to be both portable, and fast as possible in ghc.
01:45:28 <norpan> maybe i should do that build . unpackFoldr stuff too
01:45:30 <dons> and I can't do anything about jhc or yhc until jhc gets ForeignPtrs, and yhc gets more stuff. so itss portable enough for the time being
01:46:05 <dons> ?localtime dons
01:46:09 <lambdabot> Local time for dons is Sat May  6 18:47:22 2006
01:46:14 <dons> dinner time!
01:46:34 <norpan> huh, saturday?
01:47:01 <norpan> a, australia
01:47:25 <ADEpt> ?localtime norpan
01:47:26 <lambdabot> Local time for norpan is Sat May  6 10:47:03 2006
01:47:42 <dons> night guys.
01:47:47 <norpan> night
03:42:39 <xerox> @yow!
03:42:39 <lambdabot> Wait ... is this a FUN THING or the END of LIFE in Petticoat
03:42:40 <lambdabot> Junction??
03:42:48 <lome> hello, friends. could anybody help me with visual haskell? i have compilation error: Could not find module `Control.Monad.State'. it looks strange...
03:44:58 <lome> command line compilation is OK.
04:00:36 <DeliQ> @index trace
04:00:36 <lambdabot> Debug.Trace
04:00:49 <DeliQ> @hoogle trace
04:00:50 <lambdabot> Debug.Trace.trace :: String -> a -> a
04:00:50 <lambdabot> Debug.Trace :: module
04:00:50 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
04:02:02 <twb> Remind me, how do I turn an integer `n' and a constant `x' into a list of length n [x,...,x] ?
04:02:18 <ndm> @hoogle Int -> a -> [a]
04:02:19 <lambdabot> Prelude.replicate :: Int -> a -> [a]
04:02:30 <ndm> twb, replicate :)
04:02:49 <twb> Thanks!
04:07:33 <akyto-> how can i use List.sortBy on a list of [(Char,Int)] and order ist by the Chars ?
04:08:45 <resiak> So I'm updating a record with the result of a case statement, and I want the _ case to evaluate to {}. However, empty record updates appear to be illegal, which makes me sad. What could I do instead?
04:09:10 <DeliQ> akyto-: define a function that yields an Ordering
04:09:27 <DeliQ> @hoogle Ordering
04:09:27 <lambdabot> Prelude.Ordering :: data Ordering
04:09:47 <hoan> like: if <test> then GT else LT
04:12:45 <resiak> @paste
04:12:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:14:44 <ndm> lisppaste2: url
04:14:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
04:15:01 <resiak> Just found that =)
04:15:02 <ndm> resiak: use that paste instead :), i'm not quite sure what you mean as your question
04:15:25 <resiak> Sure
04:15:41 <ndm> just seeing hte code should clarify it though
04:16:06 <lisppaste2> resiak pasted "cases and record updates" at http://paste.lisp.org/display/19740
04:17:05 <ndm> resiak: comment out the bottom line (the one with {}), and my guess is that it still breaks
04:17:34 <resiak> Yes, it does. This is me trying something slightly different to my earlier question, actually
04:17:56 <ndm> well, you can't do record updates like that
04:18:01 <resiak> That makes me sad :(
04:18:09 <ndm> emptyMpdStatus{volume = 12}
04:18:19 <ndm> you have to say to which structure you are making updates
04:18:31 <resiak> Ah, figures. I was hoping I could let that float outside the case, but oh well
04:18:46 <norpan> accum { ... }
04:18:48 <ndm> sorry, no such luck...
04:19:04 <ndm> unfortunately records aren't that "powerful"
04:19:19 <ndm> unlike the rest of haskell, the update is not a function
04:19:21 <resiak> norpan: Right. Thanks.
04:19:55 <norpan> and if it was a function, it would be { ... } accum instead
04:20:00 <norpan> that should be entirely possible
04:20:05 <resiak> Yeah, they seem to behave somewhat oddly. I take it this is why people want them replaced for Haskell' ?
04:20:50 <resiak> (Well, the fact that they're not very awesome.)
04:21:12 <mahogny> I have found lately that the haskell records aren't really that bad. I dunno how much better it could become
04:22:00 <mahogny> what are people actually asking for?
04:22:36 <DeliQ> does anybody know if there is also a lookup on b in [(a, b)] ?
04:22:59 <mahogny> define lookup
04:23:04 <norpan> lookup . map flip
04:23:17 <norpan> no, wait, flip is not the name
04:23:17 <DeliQ> norpan: thanks!
04:23:23 <DeliQ> ow :P
04:23:30 <norpan> @hoogle (a,b)->(b,a)
04:23:31 <lambdabot> No matches found
04:23:36 <norpan> hmmm
04:23:50 <DeliQ> think i have to write it myself then ;)
04:23:50 <resiak> zip (flip pair) . unzip? ;)
04:24:51 <norpan> yeah
04:24:54 <DeliQ> > zip (flip pair) . unzip (1,2) ?
04:24:54 <lambdabot>  parse error on input `}'
04:25:00 <DeliQ> > zip (flip pair) . unzip (1,2)
04:25:01 <lambdabot>  Not in scope: `pair'
04:25:06 <norpan> (,)
04:25:20 <DeliQ> how would i use that ?
04:25:26 <DeliQ> can you give an example norpan ?
04:26:04 <norpan> lookupB x = lookup x . map (\(a,b)->(b,a))
04:26:34 <DeliQ> that's really neat, thank you!
04:26:58 <hoan> its tempting to try and not use lambda
04:27:08 <norpan> lambda is your friend
04:27:27 <eivuokko> lookupB x y = Data.List.find ((x==).snd) y >>= return.fst ;)
04:27:35 <DeliQ> lol
04:27:38 <norpan> i like it when the function definition is exactly the same as the type
04:27:59 <hoan> hey yeah..., didn't notice that
04:28:17 <DeliQ> i must say the lambda form of norpan s a wee bit more understandable :P
04:28:53 <hoan> WHAT ABOUT THE POINTSFREE???
04:28:55 <hoan> ;)
04:29:06 <eivuokko> @pl lookupB x y = Data.List.find ((x==).snd) y >>= return.fst
04:29:07 <lambdabot> lookupB = flip flip (return . fst) . (((>>=) . ((Data . List) .)) .) . find . (. snd) . (==)
04:29:11 <eivuokko> Right.
04:29:11 <DeliQ> whaha
04:29:24 <norpan> @pl lookupB x = lookup x . map (\(a,b)->(b,a))
04:29:24 <lambdabot> lookupB = (. map (uncurry (flip (,)))) . lookup
04:29:39 <hoan> wait
04:29:49 <hoan> i was working on that..
04:30:01 <norpan> why work when the robot can work for you
04:30:18 <hoan> well its so fun
04:30:23 <hoan> oh well
05:57:24 <resiak> Any good examples of combining State and IO?
05:57:50 <xerox> Do you need syntax examples or meaningful examples?
06:12:54 <psi> I made an example for myself yesterday. It's a fairly pointless one I guess, but I can show it if you want to.
06:21:09 <dons> bytestring hackers, I've just tagged fps 0.6. its on the website.
06:22:45 <kzm_> dons - is there an easy way to adapt the QC suite to new modules?
06:23:05 <kzm_> It'd be nice to recycle the code, e.g. using #include
06:23:20 <dons> kzm_ oh. should be just a matter of replacing the import statement?
06:23:28 <dons> ie. import ByteString.Foo instead of Char8
06:23:38 <kzm_> but runhaskell/runghc doesn't seem to support CPP (or am I wrong here?)
06:23:40 <dons> then all the references to B.foo will be right,n  no?
06:24:07 <dons> oh. hmm. with OPTIONS -cpp it should
06:24:15 <dons> try it
06:24:15 <kzm_> dons - yes, I did that for one of them.  Ideally, I could do it with something like runhaskell -DENCODING QuickCheck.hs
06:24:29 <dons> ah, right.
06:24:36 <kzm_> it crashed on the first line (#!...)
06:24:38 <kzm_> :-)
06:24:45 <dons> might have to compile it then.
06:24:52 <kzm_> but, yes, that can be worked around.
06:25:12 <kzm_> Okay.  I haven't really tried.  Today is weekend, and way to nice weather!
06:25:56 <dons> but weekend is hacking time!! ;)
06:26:09 <kzm_> the tests compare against list-based functions?  (f <=> pack . List.f . unpack)
06:26:26 <dons> some of them. some of them compare things internally
06:26:34 <dons> i.e. head . sort == minimum and so on.
06:26:55 <kzm_> then most of the UTF8 checks should pass - that's how most of it is implemented, after all :-)
06:27:02 <dons> right.
06:27:30 <kzm_> sort and minimum should also sort on character values, right?  (and not word8 values)
06:27:52 <dons> in Char8, they should.
06:28:13 <dons> hmm. or didn't I export that..
06:28:28 <kzm_> right.  I suppose, if you care about sorting and Chars, you really need a locale specific sorting order.
06:28:49 <dons> yeah. too hard.
06:29:12 <dons> it just sorts on the representation value. good point.
06:29:42 <kzm_> I'm tempted to weasel out, and point people to unpack and Char functions.  Then it is somebody elses problem.
06:30:03 <kzm_> And lest you criticize this decision, let me remind you that this is exactly your stance on encodings :-)
06:30:10 <kzm_> heeh
06:30:38 <dons> encodings boo.
06:30:40 <kzm_> And about weekends - last weekend I was on Hoth.  So no hacking.
06:31:10 <dons> Hoth, isn't that a planet in the star wars series? the ice planet?
06:31:27 <dons> you were there??
06:31:28 <kzm_> Exactly.  http://www.ii.uib.no/~ketil/Bilder/2006/finse/img004.jpeg.html
06:31:38 <kzm_> (It's Finse - where it was shot)
06:32:09 <kzm_> Possibly a different scenery from yours, I imagine.
06:32:23 <dons> oh wow!
06:32:30 <dons> that is hoth :)
06:32:38 <jethr0> nice
06:32:46 <kzm_> In the distance, you can see the glacier.
06:32:49 <jethr0> where is that? sweden?
06:32:57 * kzm_ scowls at jethr0.
06:33:05 <dons> hehe
06:33:06 <kzm_> It is, for your information, Norway.
06:33:10 * kzm_ sniffs.
06:33:12 <JKnecht> receding I presume
06:33:21 <kzm_> Not sure, really.
06:33:42 <dons> it looks cold :) and i thought it was winter here!
06:33:50 <kzm_> They can grow even if it gets warmer, due to more humidity, and more snow.
06:34:19 <kzm_> It's not so bad, around zero (Â°C).  The wind was pretty bad, at 17m/s, but you can't tell from the picture.
06:34:40 <dons> it is very beautiful.
06:34:53 <kzm_> We had to rescue people that were ski-sailing, they tended to be blown struggling in the direction of our cabin.
06:35:33 <jethr0> never been skying to scandinavia. i hope that excuses my ignorance of this picture's location
06:36:07 <kzm_> jethr0, I'm only joking of course.  From our point of view, there is an enourmous difference between .no and .se.
06:36:22 <jethr0> never been to either, yet
06:36:28 <kzm_> From outside our little corner, I realize the difference might not be as easily perceived.
06:37:41 <psi> there are places like that in Sweden too
06:37:56 <jethr0> i've only been to christiansand for a day on a sailing trip once
06:38:38 <kzm_> jethr0, my wife is from there.  I'm from Grimstad, which is about two days sailing to the east.
06:38:52 <jethr0> "two days sailing" :)
06:39:13 <kzm_> sorry?
06:39:13 <dons> hehe. sounds really nice when you say it like that.
06:39:29 <dons> two days bus ride. no thanks.
06:39:39 <jethr0> the "leg" from christiansand to helgoland was torture for me though. 45h straight on deck seasick
06:39:50 <kzm_> well - or 45 minutes drive.  Sailing /is/ nicer.
06:40:05 <kzm_> (except if you get seasick)
06:40:40 <kzm_> I have to stop now, or we will have to arrange a haskell meeting here. :-)
06:41:36 <dons> so a lovely summer trip (i still find such icey places boggling)  :)
06:42:33 <kzm_> Since I'm at it, here is a sailing picture: http://www.ii.uib.no/~ketil/Bilder/2005/sommer/hellesund/large-pict2750.jpg
06:42:44 <kzm_> (for longer trips, I recommend a larger vessel)
06:44:04 <jethr0> good old "opti"
06:45:25 <kzm_> Oh well.  Gardening is waiting to happen.  Rocks must be moved.  Children must be surveilled to make sure they don't inflict bodily harm upon themselves or others.  The usual weekend stuff.
06:45:31 <kzm_> Happy hacking!
06:46:14 <jethr0> have a nice weekend :)
06:46:49 <dons> :)
06:54:34 <pitecus> Hi. How do I declare String to be instance of some typeclass? "instance Foo String" doesn't work.
06:54:47 <xerox> pitecus: how is class Foo defined?
06:55:00 <xs> instance Foo [Char]?
06:55:16 <pitecus> class (Show a) => Foo a where ..
06:55:29 <xerox> Try xs's advice.
06:56:37 <pitecus> That's what I get when I try it:
06:56:39 <pitecus>     Illegal instance declaration for `Foo [Char]'
06:56:39 <pitecus> 	(The instance type must be of form (T a b c)
06:56:39 <pitecus> 	 where T is not a synonym, and a,b,c are distinct type variables)
06:56:39 <pitecus>     In the instance declaration for `Foo [Char]'
06:57:29 <xs> what other instances of Foo do you have?
06:57:47 <Igloo> You need to turn extensions on
06:58:28 <pitecus> No other instances
06:58:37 <pitecus> What extensions, Igloo ?
06:59:07 <Igloo> That's ghc, isn't it? Then I think you'll need the full -fglasgow-exts
06:59:50 <pitecus> Hm, I didn't know I was trying to use something nonstandard
07:00:29 <pitecus> Is it impossible to define String to be an instance in haskell 98?
07:00:38 <Igloo> Yes
07:00:48 <Igloo> You'd need to define Char and [a] instances
07:01:27 <pitecus> I see. Thanks
07:04:14 <psi> .
07:04:32 <xs> why are mutually recursive modules so painful in ghc?
07:05:32 <dons> they are?
07:05:49 <dons> they're a little bit. but there are things that inflict worse pain
07:06:22 <xs> heh, the definition duplicate seems.. unnecessary. couldn't ghc do it automagically?
07:06:42 <dons> you mean tying the not in the .hs-boot file?
07:06:43 <dons> knot
07:06:48 <xs> yup
07:07:25 <dons> i'm almost certain there are ways to do it automatically. doesn't jhc do that?
07:07:45 <xs> ahh, quite possibly, jhc to the rescue.
07:13:48 <ndm> solving mutually recursive modules isn't *that* hard
07:14:04 <ndm> it certainly could do it automagically
07:14:20 <xs> yhc does it? :)
07:14:43 <ndm> xs, no, but thats because of "reasons" that are currently beyond our control
07:14:52 <ndm> it has all the infrastructure in place, apart from type checking
07:15:08 <ndm> and no one understands the Yhc type checker - i can't even find where is the start function
07:15:16 <xs> hehe
07:15:23 <ndm> so, when the type checker is rewritten, it will
07:15:39 <xs> is that happening soon?
07:15:40 <ndm> the Yhc type checker is also not haskell 98 compliant, but no one ever notices
07:15:59 <ndm> i won't be able to do it soon, depends if someone does have the time
07:16:15 <ndm> I have Yhc as project number 5 in my priority list
07:16:28 <ndm> once I get down there, i'll push for a Yhc release, with complete library support
07:16:42 <ndm> after that, maybe the type checker :)
07:17:28 <xs> :)
07:17:48 <ndm> of course, if you were to volunteer...
07:19:06 <xs> heh, maybe in the summer
07:19:09 <dons> ndm, sometimes people notice.
07:19:14 <dons> i noticed once only.
07:19:31 <xerox> Rewriting the YHC typechecker is a SoC project :-)
07:19:36 <ndm> yeah, i know it hits some people
07:19:39 <xerox> You can find it on the SoC site (see topic.)
07:20:24 <xs> i'm working until the soc midterm date, alas.
07:20:37 <ndm> xerox, way cool :) i thought malcolm might propose that
07:20:53 <xerox> No Intersted Mentors/Students atm, IIRC
07:21:07 <ndm> Malcolm is an interested mentor
07:21:11 <ndm> and i would do it, if he won't
07:21:12 <xerox> Ah, good.
07:21:18 <ndm> (although he's much better to do it)
07:21:36 <xerox> Oh, spread the word rapidly, the proposals can go in until the 8th only!!
07:21:55 <dons> yeah. we need more project proposals
07:22:15 <dons> it seems people have signed up on our site, but haven't applied to google?
07:22:46 <xerox> Yes, I'll be mailing the students signed on the page and Cc: haskell@haskell.org, maybe
07:24:11 <ndm> i think i had already planned to do about 5 of the projects on that list, before the list existed
07:24:49 <ndm> "Take a hard theorem prover and connect it to Haskell by making it a drop-in replacement for QuickCheck?, or writing a native Haskell one."
07:24:49 <psi> I've written my proposal, but I'm not entirely satisfied with it currently... I'll probably send it in tomorrow.
07:25:02 <ndm> sounds like a PhD to me :)
07:25:16 <ndm> essentially given that it _is_ my phd
07:27:04 <ndm> how many SOC projects is haskell likely to get?
07:27:15 <psi> good question
07:27:30 <lscd> as in, approved by google, or as in applications, or as in applications you want to accept?
07:27:33 <xerox> Maybe I should send it to haskell@haskell.org and Ccn: the known interested students.
07:28:31 <psi> as in, how many of the ones approved by haskell.org can google accept, I guess
07:29:05 <ndm> i just mean whats the end number gonig to be, so accepted by everyone and actually start
07:29:40 <xerox> Last year the number was 419 over 8000 applications.
07:29:47 <ndm> in total?
07:29:52 <xerox> Yep.
07:30:01 <xerox> Then, it varied heavily from organization to organization.
07:30:01 <psi> it's going to be lots more this year I bet. at least applicants.
07:30:10 <xerox> Some got <=4, some >30.
07:30:23 <ndm> i guess it depends how much it helps google ;)
07:30:38 <psi> does google like haskell? :)
07:30:48 <lscd> we can hope ;)
07:30:50 <ndm> i have changed the hoogle logo now, given that Haskell and google were getting a bit too close with the SoC and didn't want to tread on anyones toes
07:30:50 <xerox> Yeah!  Chris DiBona seem to enjoy it :-)
07:31:45 <xerox> heh.
07:32:54 <dons> I think we've asked for 8 soc projects or so, but there's already been more applications than that.
07:38:09 <dons> We've actually asked for 30 slots. So I hope everyone is applying!!
07:38:27 <psi> OMG!
07:38:31 <dons> Get those applications in, if you've said you're interested on the Haskell SoC page.
07:38:50 <dons> I see 15 applications so far.
07:39:00 <dons> But knwo of at leats 20 more interested people..
07:39:35 <lscd> i'm interested... i just have no idea what to do :p
07:39:51 <dons> have you checked out what's on the Haskell SoC page?
07:39:58 <dons> that gives you an idea of what mentors want done.
07:40:10 <dons> and you can add your own stuff their if there's something specific you want to hack on
07:40:10 <lscd> yeah, i have
07:40:22 <dons> also, what about the various haskell projects. they all want people too.
07:40:36 <lscd> hm? you mean things like darcs/yi/etc?
07:41:25 <dons> yep
07:41:47 <lscd> yeah
07:41:49 <ndm> i wonder if hoogle would be a good soc project
07:42:04 <lscd> my major problem is that i'm entirely a newbie with haskell; and i don't have any experience in, say, the darcs or ghc codebases
07:42:06 <Igloo> dons: Was 30 just the most you could ask for, or what?
07:42:43 <lscd> so i'm having trouble getting an idea of how tough vs interesting some of the projects would be
07:43:22 <dons> Igloo, no, just a random number. we can write any number in.
07:43:44 <dons> its double what we've received in applications so far. but i expect at least 15 more.
07:44:07 <ndm> lscd: have you tried compiling GHC yet? thats a good first step
07:44:27 <ndm> or you might want to pick a smaller codebase, Yhc is relatively manageable
07:44:33 <lscd> ndm: yeah - i run gentoo, though i've not compiled ghc by hand
07:49:13 <akemp> @seen SyntaxNinja
07:49:14 <lambdabot> I saw SyntaxNinja leaving #haskell 13 hours, 58 minutes and 51 seconds ago, and .
07:52:21 <dons> Igloo, the number may be just for internal use. To help guide the ranking of applications. Or it may be public. Not sure.
07:55:43 <glauber_sp> hi guys, does the wash ebuild is up to date with its site?
08:01:03 <falconair> does anyone know of a small relational database written in haskell?  I'm a haskell newbie and would like to study its source code
08:01:29 <dons> falconair: check the haskell.org libraries and tools page for a complete list of known databases written in haskell
08:02:09 <dons> ?wiki Libraries_and_tools/Database_interfaces
08:02:09 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
08:02:31 <dons> some are bindings, some are in haskell, i think.
08:03:09 <falconair> that was my impression, that all of them are either bindings or generate generic sql to be sent to a real server...i'm taking  a look
08:06:38 <falconair> HaskellDB looks closest to what i'm thinking of, thanks dons
08:09:32 <psi> is there anything in particular that you mentors would like to see in the applications?
08:10:17 <psi> except the obvious (project details and so forth)
08:10:47 <dons> well, i think the following: a) you know haskell well enough to do the job (so some examples of projects, or that you've known the language for a while)
08:11:04 <dons> you understand the area you want to work on (i.e. concurrency for example)
08:11:12 <dons> you have a good idea of what needs to be done
08:11:23 <psi> yeah, ok
08:11:31 <dons> you're connected to the community. i.e. have a web page, go to a uni
08:11:47 <dons> and the project is of importance to the community
08:12:02 <dons> so reusable library  code or infrastructure projects will be ranked highly
08:12:19 <dons> probably toy apps won't be.
08:12:23 <dons> research would also be good.
08:12:33 <psi> thanks
08:12:47 <dons> the more useful the code, the more mentors will want to rank it as "Interesting" or "Someone should mentor this"
08:12:59 <dons> which will rannk it highly in the list google then gets to filter
08:13:21 <dons> and even better would be to contact the mentor you've lined up, and tell them you've now applied.
08:13:39 <dons> so they then indicate they're willing to mentor (which is worth a lot of rankign points)
08:13:41 <psi> I regret not having anything real to show, but I'm not completely new.
08:14:10 <psi> I've mostly thrown what I've done so far.
08:15:10 <psi> but I do believe my project idea is useful to the community.
08:15:24 <dons> good. also, give it a good clear title
08:15:44 <dons> like "Improve GHC osx86 support" for random example
08:15:58 <psi> it is very clear :)
08:16:04 <dons> no "application"
08:18:34 <psi> did anyone figure out the length limit of google's text box?
08:18:48 <xerox> Read the source?
08:19:04 <dons> also, make sure the line wrapping is good.
08:19:07 <dons> that helps mentors read
08:19:13 <dons> so wrap at 60 or 70 chars
08:19:29 <dons> probably 70 is ok
08:19:49 <psi> yeah, I thought of that.
08:20:00 <dons> ok. good luck to those applying. and hope to see many new applications in the morning
08:20:04 <dons> night!
08:20:09 <psi> g'night
08:20:27 <xerox> Goodnight!
08:25:42 <ndm> i think you should get ranked for time spent in the IRC channel :)
08:25:58 <xerox> You being?
08:26:14 <ndm> the SoC project students
08:26:54 <xerox> Some people contacted me with interesting projects, but they don't IRC, it wouldn't be fair :-)
08:27:16 <xerox> (Yet I suggest to people to come here to discuss.)
08:29:05 <psi> hehe
08:56:37 <psi> oh gno. gtk2hs from darwinports didn't build :(
08:56:54 <psi> make[2]: *** [tools/c2hs/base/general/Utils.o] Error 1
08:56:54 <psi> make[1]: *** [glib/System/Glib/Types.hs] Error 2
08:56:54 <psi> ghc-6.4.2: can't find file `glib/System/Glib/Types.hs'
08:56:55 <dcoutts> oh no!
08:57:11 <psi> I've had that before :)
08:57:24 <dcoutts> do you know what's wrong?
08:57:46 <psi> I don't remember, I'm going to search the IRC logs
09:00:09 <psi> I'm so having a deja vú just now. This might be the third time I've had it, and the second time I'm searching the IRC logs for it.
09:00:42 <dcoutts> heh
09:01:50 <akemp> @seen SyntaxNinja
09:01:51 <lambdabot> I saw SyntaxNinja leaving #haskell 15 hours, 11 minutes and 27 seconds ago, and .
09:02:52 * xerox wants preemptive seen, musasabi! (-:
09:04:36 <pitecus> What does that mean: Ambiguous type variable `k' in the constraints
09:05:02 <psi> dcoutts: unfortunatly the discussion I found involves pastebin, but you suggested that it was a ghc mangler problem.
09:05:16 <psi> do you think it's completely unrelated? I can't view the paste any longer.
09:05:43 <dcoutts> psi, what did we get before that make error, what was the last thing ghc did?
09:05:49 <dcoutts> did ghc give an error?
09:06:29 <psi> no...
09:06:51 <psi> ghc says it can't find the file
09:07:39 <dcoutts> psi, what file?
09:07:52 <Ulfalizer> hmm
09:08:09 <psi> can I paste 5 lines?
09:08:22 <dcoutts> yeah
09:08:37 <mux> mmm,, gtk 2.9.0
09:08:39 <psi> actually, I'll include everything for completeness, it's not much - one sec
09:08:39 * Ulfalizer is thinking how he should go about wall-mounting a router without making holes
09:08:51 <dcoutts> mux, I was thinking the same :-)
09:08:57 <mux> heh
09:09:08 <mux> GtkStatusIcon makes me happy
09:09:21 <psi> http://pastebin.com/701953
09:10:27 <dcoutts> psi, is that using make -j2 or something?
09:11:04 <xerox> pitecus: did you work out your problem?
09:11:14 <xerox> pitecus: if you could paste some code I think I could help you, in case.
09:11:51 <psi> dcoutts: the initial command is 'make all'
09:12:11 <psi> in the gtk2hs root
09:13:02 <dcoutts> psi, thing is, in what you've pasted I can even see the iinvocation of the ghc command that is failing, just the error message from ghc
09:13:57 <pitecus> xerox, where do i paste stuff?
09:14:05 <dcoutts> psi, see, there's no command where ghc tries to compile glib/System/Glib/Types.hs
09:14:08 <xerox> lisppaste2: url
09:14:08 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:14:13 <mcnster> hi.  newb q:  is there a fn to parse String -> Int (base 10)?
09:14:38 <dcoutts> psi, which makes me suspect either the build log is too short or we're using parallel make by default (which will not work)
09:15:15 <psi> dcoutts: that's all I can see. perhaps the parellel flag is coming from else where. env var?
09:15:24 <Igloo> mcnster: read (or reads if you want to be able to catch failure nicely)
09:15:26 <dcoutts> psi, perhaps
09:15:32 <ndm> Ulfalizer: duck tape, i've done it myself here with a router and a hub - but be careful not to cover the vents
09:15:57 <lisppaste2> pitecus pasted "Ambiguous type variable" at http://paste.lisp.org/display/19743
09:16:04 <psi> alright, I'll investigate
09:16:11 <mcnster> igloo, thanks.  i'll do it that way then.
09:16:43 <Ulfalizer> ndm: thanks for the tip
09:17:36 <xerox> pitecus: what's the exact error, and what does it refer to?
09:17:59 <pitecus>     Ambiguous type variable `k' in the constraint:
09:17:59 <pitecus>       `Hashable k'
09:17:59 <pitecus> 	arising from use of `insert' at /home/grzegorz/lib/haskell/Data/HashMap.hs:37:16-21
09:18:34 <pitecus> which refers to the use of insert in the definition of singleton
09:18:35 <xerox> pitecus: ah, I see the constrained data declaration.
09:18:43 <xerox> pitecus: you probably don't really want that.
09:19:35 <jfoutz> is a $ stuff better than a (stuff) ?
09:20:02 <xerox> jfoutz: if it improves readability, sure.
09:20:30 <pitecus> xerox, OK
09:20:32 <ndm> jfoutz: much better for f $ g $ h $ expr than f (g (h (expr)))
09:20:53 <xerox> I prefer f . g . h $ x
09:21:20 <jfoutz> yeah. the  compose breaks down when f g and h have arguments it seems
09:21:36 <ndm> jfoutz: shouldn't do
09:21:51 <bolrod_>  f . g . h x    doesn't work though
09:22:25 <ndm> yes, you n eed the final $ to get it working
09:22:26 <jfoutz> f a . g b . h c != f a $ g b $ h c --- unless i'm horribly misunderstanding
09:22:28 <xerox> bolrod_: depends what you mean by work
09:22:29 <Igloo> As a rule I dislike code that relies on different precedences of different operators
09:22:45 <ndm> since what you were doing is (f . g . h) x
09:22:54 <xerox> jfoutz: f a . g b . h c = \x -> f a (g b (h c x))
09:23:10 <ndm> f a . g b . h $ c == f a $ g b $ h c
09:23:28 <jfoutz> oh, wow. why two operators?
09:23:37 <jfoutz> or is one special somehow?
09:23:47 <ndm> neither are special
09:23:47 <xerox> What do you mean?
09:23:53 <bolrod_> $ is not really an operator.. in the way that it doesn't really do anything
09:24:03 <ndm> (f a . g b . h) c is also equivalent
09:24:05 <bolrod_> it's just to not have to write ( )'s
09:24:09 <xerox> Yep, it binds function application loosely.
09:24:27 <xerox> f $ x = f x
09:24:28 <bolrod_> f $ x = f x 
09:24:34 <bolrod_> xerox, :/
09:24:42 <xerox> With an infix declaration of 0?  I think.
09:24:51 <palomer> f $ x = f x
09:25:11 <bolrod_> g $ f x = g(f x)
09:25:19 <jfoutz> oh... i'm starting to see.
09:25:23 <bolrod_> g f x = (g f) x
09:25:35 <xerox> bolrod_: the last two ones aren't well-formed declarations.
09:25:36 <jfoutz> . is compose $ is weak bind
09:25:39 <bolrod_> that's all there is to it
09:25:46 <xerox> f . g = \x -> f (g x)
09:26:02 <bolrod_> xerox, they arent?
09:26:21 <bolrod_> they do exactly the same if you ask me
09:26:30 <ndm> i tend to think of $ as a clever trick, that in other languages would be additional syntax, but thanks to various things about haskell can be defined in haskell
09:26:40 <xerox> ?type let g $ (f x) = g (f x) in ($)
09:26:41 <lambdabot> Parse error in pattern
09:26:43 <pitecus> xerox, That compiles after removing the constrain in data declaration. But when I add this definition, I get a similar error
09:26:45 <pitecus> fromList  = foldl (\m (k,v) -> insert  k v m)  empty 
09:27:09 <xerox> pitecus: doesn't Map provide a fromList function?
09:27:13 <bolrod_> hrm... why can't you do that
09:27:17 <palomer> xerox: no:(
09:27:22 <xerox> bolrod_: what are you pattern matching on?
09:27:31 <palomer> @hoogle fromList
09:27:31 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
09:27:32 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
09:27:32 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
09:27:34 <jfoutz> so... prefer . to $ prefer $ to explicit parens ?
09:27:39 <bolrod_> you can't do   g ( f x)  ?
09:27:59 <xerox> bolrod_: what are you pattern matching on with (f x) ?
09:28:15 <ndm> jfoutz: when i was learning i always used (), as I learnt more I used $ - () is certainly clearer for beginners
09:28:23 <bolrod_> hrm.. yes
09:28:34 <pitecus> xerox, I'm using IntMap to implement HashMap
09:28:35 <xerox> ?docs Data.Map
09:28:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:28:47 <bolrod_> I mean the  result is the same as you would do  g ( f x)  
09:28:50 <xerox> ?docs Data.IntMap
09:28:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
09:29:14 <xerox> pitecus: IntMap does provide a fromList function
09:29:15 <jfoutz> ndm: well i have some code that seems to be working... i was just gold plating, trying to get a feel for various styles
09:29:19 <bolrod_> dang.. my cable internet is down >:(
09:29:27 <jfoutz> point free is neat.
09:29:31 <xerox> jfoutz: indeed!
09:29:57 <pitecus> xerox, I know, but I still need to provide a fromList function that works on HashMap
09:30:09 <pitecus> not on IntMap
09:30:28 <pitecus> I'm just confused as to the meaning of  "Ambiguous type variable `k' in the constraint"
09:30:40 <pitecus> What is it supposed to mean?
09:30:47 <xerox> pitecus: map Hashes to Ints in the list to be feed to IntMap's fromList?
09:31:10 * palomer faints as he sees the number of libraries required for glade
09:31:40 <xerox> pitecus: that k can't be inferred, I think.
09:31:59 <pitecus> xerox, some will hash to the same Int, so that won't work
09:32:16 <xerox> pitecus: what were you planning to do?
09:33:10 <pitecus> xerox, You can see the definition of insert that I pasted
09:35:11 <palomer> > let ones = 1 : ones in let ones' = 1 : ones in ones == ones'
09:35:15 <lambdabot> Terminated
09:35:17 <xerox> Does |Map.IntMap [(k,v)]| make sense?  I'm missing something.
09:36:24 <pitecus> Why wouldn't it make sense? It's a Map form Ints to pairs of k,v
09:36:41 <pitecus> to lists of pairs k,v
09:37:02 <xerox> Doesn't it defeat the purpose of a Map?
09:37:20 <xerox> In terms of guaranteed complexity on certain operations, that is.
09:37:28 <xerox> s/on/of/1
09:37:28 <bolrod_> I don't get the purpose of this 
09:37:33 <bolrod_> what does it need to do?
09:38:57 <pitecus> xerox, the lists of pairs are buckets in the hashmap
09:39:54 <xerox> I'm lost on the terminology.  Isn't there a bijection Hash <-> Int?
09:40:09 <xerox> I.e. aren't hashes supposed to be unique?
09:42:50 <pitecus> I don't have a Hash datatype. I use a hash function on keys to produce an Int. This isnt is used as the Key in the IntMap, and all key,value pairs whose key hashes to the same Int are stored in an association list
09:43:36 <bolrod_> too much thinking for a Saturday *Yawn*I
09:43:58 <xerox> Wouldn't a Map work better?
09:44:17 <xerox> With a Map you wouldn't have to go into a double lookup.
09:44:26 <pitecus> As in Data.Map?
09:44:32 <xerox> Yes.
09:45:31 <pitecus> Maybe. In my experience it's been slow. 
09:49:22 <Cale> Data.Map should basically always be faster than an association list.
09:50:24 <pitecus> The association lists are only used in case of keys hashing to the same Int, so they are expected to be short
09:50:32 <Cale> oh, I see
09:52:02 <Cale> Yeah, I'm not sure how Map performs relative to association lists when there's only a couple of elements.
09:52:41 <lisppaste2> xerox pasted "Possible HashMap interface?" at http://paste.lisp.org/display/19744
09:55:58 <pitecus> Why is "newtype" better than "data" for this?
09:58:40 <xerox> Because it doesn't add "closures" over the IntMap type
09:58:45 <xerox> It will be isomorphic, that is.
09:59:16 <pitecus> OK
09:59:59 <xerox> Dunno if one could trick IntMap with its Key type somehow.
10:03:50 <Cale> insert and (!) don't have to be in that class
10:06:09 <xerox> Cale: you manually `hash` hashes?
10:08:10 <Cale> xerox: well, you can implement insert and (!) outside the instances
10:09:12 <xerox> Mumble, you're right.  I didn't mean to have them in the instance in fact!
10:09:24 <xerox> They're the same for every instance.,
10:12:05 <lisppaste2> xerox annotated #19744 with "Better, thanks Cale." at http://paste.lisp.org/display/19744#1
10:13:21 <pitecus> Thanks guys
10:13:29 <xerox> Thank you
10:13:45 <ibid> you thank
10:13:51 <ibid> :-P
10:15:48 <psi> what linux distribution do people prefer in terms of haskell support? that is, availability & uptodateedness(!) of haskell packages
10:16:59 <Cale> I personally run Debian, and know that a bunch of people here do.
10:17:25 <ndm> psi, Windows :P
10:17:29 <Cale> dcoutts is the maintainer for Gentoo.
10:17:29 <Korollary> There's also gentoo with its #gentoo-haskell. I am on ubuntu.
10:17:50 <ibid> psi: debian :)
10:17:54 <dcoutts> Cale, only one of 5 maintainers for gentoo 
10:18:05 <Cale> dcoutts: ah
10:18:10 * dcoutts is pleased to have such a large team :-)
10:18:29 <psi> thanks :)
10:18:43 <dcoutts> psi, I reckon gentoo does actually have the best haskell support at the moment
10:19:03 <psi> interesting. I'll try it out.
10:19:05 <ibid> dcoutts: if one does not mind waiting for the compiles? ;)
10:19:10 <dcoutts> we've got more libs & packages than other distros I think
10:19:12 <dcoutts> ibid, true
10:19:13 <xerox> http://funroll-loops.org/  <grin>
10:19:48 <dcoutts> xerox, that's not really what it's about of course
10:19:50 <Cale> hehe
10:19:58 <xerox> I'm kidding.  I used gentoo for a while.
10:20:19 <dcoutts> though admittidly it tends to attract the fringe element in its users
10:20:34 <ibid> did you know that debian was supposed to be a source-based distro? :)
10:20:36 <Cale> How is gentoo doing with regard to binaries? Can you get a usable system without compiling anything yet?
10:20:51 <dcoutts> Cale, yes & no.
10:21:01 <dcoutts> you can get a base system with no compiling
10:21:12 <dcoutts> if you want most stuff then you compile
10:21:22 <dcoutts> it is a source based distro, that is the point
10:21:37 <dcoutts> it's not aiming for a set of binary packages
10:21:54 <dcoutts> the binaries are just to give a starting point for an installation
10:22:17 <dcoutts> of course if you want to build binaries for a whole network of machines then that's certainly possible
10:22:24 <Cale> hmm, I read somewhere that they were aiming to have a fuller set of binary packages as well
10:23:07 <dcoutts> someone could provide binaries and many sysadmins to that locally but I don't know about any plan to provide them centerally
10:23:33 <ibid> the reason debian isn't is that they realized back then that a source distro is impossible
10:23:42 <dcoutts> the advantage of doing it in a decenteralised manner is that you still get choice over build settings & dependencies
10:23:57 <dcoutts> ibid, impossible in what sense?
10:24:20 <Cale> I sort of think that the actual developers should get to decide how to compile their software.
10:24:21 <ibid> of course, when gentoo came to the scene, there was much more computational power in an average home computer
10:24:27 <ibid> dcoutts: impossibly long compiles
10:24:35 <ibid> dcoutts: note, this is in 1994 or so
10:25:13 <dcoutts> ibid, right. On old hardware it is a bit of a pain. On modern machines it's pretty quick for most stuff.
10:25:23 <ibid> Cale: the debian experience is that many upstream developers are too close to their particular software to make good packagers for them
10:25:45 <dcoutts> the only really slow ones are glibc, gcc, (ghc!), x11
10:26:00 <wchogg> and openoffice ;-)
10:26:01 <ibid> Cale: there are successful upstream packagers, but most of them were debian developers first
10:26:06 <dcoutts> gnome is a bit slow since it consists of >100 packages
10:27:03 <dcoutts> wchogg, yeah :-)
10:27:28 <thaldyron> wchogg: that's why there's an openoffice-bin ebuild ;-)
10:27:32 <dcoutts> ghc is rather slow to build, I'm looking forward to the modularised ghc with split-out libs
10:28:07 <psi> tell me about it. it takes, I guess, 10 hours here.
10:29:15 <isaacd> thaldyron: not for ppc :( and I've only got ~350 MHz
10:29:22 <Korollary> friends dont let friends build ghc
10:29:44 <ndm> try building hugs on Windows, thats a lot less fun than ghc :)
10:29:57 <ndm> i'm now into week 3...
10:30:00 <wchogg> dcoutts:  BTW, so did you do the packaging for the most recent cabal ebuild?
10:30:19 <Korollary> I tried to build ghc on cygwin (targeting cygwin) once and failed.
10:30:21 <dcoutts> wchogg, yep
10:30:41 <wchogg> dcoutts:  What exactly happened that it's hard-masked rather than just ~arch?
10:30:56 <dcoutts> wchogg, we're still testing it and ghc-6.4.2
10:31:40 <dcoutts> wchogg, but we'll unmask it soon. every other haskell ebuild has now been tested with ghc-6.4.2 & cabal-1.1.4 on at least one arch.
10:31:53 <wchogg> dcoutts:  Okay, cool.
10:31:53 <dcoutts> we're just testing the other arches at the moment
10:32:07 <dcoutts> eg alpha, ppc, ia64, etc
10:32:15 * dcoutts curses ia64
10:35:36 <araujo> good morning!
10:44:14 <lscd> dcoutts: want an amd64 build?
10:44:29 <dcoutts> lscd, of what?
10:44:46 <lscd> of cabal; you mentioned that you're doing alpha/ppc/ia64 testing atm?
10:44:54 * dcoutts has and am64 :-)
10:45:15 <lscd> eh, ok, cool; I guess someone is already doing ppc too? :)
10:45:25 <dcoutts> lscd, you're most welcome to help us with testing
10:45:33 <dcoutts> no one is doing ppc at the moment
10:45:37 <lscd> ok, i can do that :)
10:45:50 * dcoutts moves conversation to #gentoo-haskell
10:46:12 * mahogny wonders how many haskell related channels there are o_O
10:46:44 <ndm> @seen lambdabot
10:46:44 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #haskell.it, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #ScannedInAvian
10:46:54 <ndm> i guess those are all haskell related
10:47:06 <mahogny> aaah
10:47:07 <dcoutts> 10, that's quite a few
10:47:08 <Korollary> #haskell-blah is not heh
10:47:21 <palomer> hrmph
10:47:29 <mahogny> haskell.es? I guess chalmers on its own could form a channel :P
10:50:12 <ndm> although flippi is entirely empty, apart from lambdabot
10:51:53 <psi> hm, #scannedinavian & #ScannedInAvian
10:52:28 <palomer> one of them is an avian flu and scanner channel
11:01:11 <ihope__> > sqrt 2
11:01:12 <lambdabot> 1.4142135623730951
11:01:33 <ihope__> > sqrt 200
11:01:34 <lambdabot> 14.142135623730951
11:01:37 <ihope__> > 14^2
11:01:38 <lambdabot> 196
11:02:00 <ihope__> > 141^2
11:02:01 <lambdabot> 19881
11:02:08 <xerox> Yes, lambdabot can do calculations.
11:05:13 <Beelsebob_> anyone able to suggest a free OS X editor that supports Haskell
11:05:20 <Beelsebob_> (emacs and Vim are not valid answers)
11:05:27 <palomer> emacs and Vim
11:05:33 <palomer> yi
11:05:44 <Beelsebob_> @where yi
11:05:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
11:06:07 <davidhouse> Beelsebob_, why not emacs and vim?
11:06:20 <Beelsebob_> because I shouldn't have to learn how to work a simple editor
11:06:24 <davidhouse> Beelsebob_, if it's because they're Really Scary, then yi won't be much better.
11:06:30 <Beelsebob_> indeed
11:06:36 <davidhouse> but i suggest learning emacs, as a life skill.
11:06:57 <lscd> Beelsebob: well.. the thing is, in the end, they save you time
11:07:00 <ndm> Beelsebob, why not SubEthaEdit
11:07:17 <Beelsebob_> ndm: because they've ceased to licence it free to people in education
11:07:32 <ndm> hehe, thats mac programs,  money grabbing
11:07:35 <ndm> should pick textpad
11:07:51 <palomer> what about kate?
11:07:52 <Beelsebob_> no, that's shareware programs... asking for money for work
11:07:54 <Beelsebob_> kate?
11:07:59 <palomer> @google kate
11:08:02 <davidhouse> that'd be KDE
11:08:08 <davidhouse> i.e., not OSX, palomer ;)
11:08:10 <palomer> there are qt libs for OSX
11:08:15 <Beelsebob_> should work still
11:08:16 <kep> Beelsebob_: you should use Eclipse IDE with haskell plugin
11:08:24 * Beelsebob_ slaps kep
11:08:28 <lscd> ergh. eclipse :(
11:08:29 * palomer finds eclipse much scarier than emacs
11:08:35 <lscd> if it were stable, it would be one thing
11:08:43 <Beelsebob_> eclipse is the most horrific environment I've ever seen
11:08:49 <davidhouse> Beelsebob_, no editor's support for haskell comes close to emacs's. seriously. it doesn't take _that_ long to learn, especially if you get it with X support.
11:09:01 <lscd> Beelsebob: why? [i tend to agree, but i'm curious about your reasons]
11:09:11 <Beelsebob_> davidhouse: so far it's taken me 6 years to not succeed in learning emacs
11:09:28 <lscd> davidhouse: hm. what do you like most about emacs?
11:09:50 <Beelsebob_> lscd: (1) it's *really* slow (2) It's cluttered with a lot of things I'll never use (3) it's ugly (4) it's unstable (these listed in no particular importance order)
11:10:02 <lambdabot> http://kate.kde.org/
11:10:11 <ndm> it has tetris as a mode, and a shrink, what more could you want :)
11:10:13 <lscd> Beelsebob: hm, ok - the only one that really bothers me is the last
11:10:33 <Beelsebob_> ndm: if I want to play games I'll play sonic on my phone :P
11:10:36 <palomer> lambdabot isn't being very quick, is it
11:10:37 <kep> Beelsebob_: may be jedit has a haskell syntax highlight
11:10:57 <Beelsebob_> tbh... I'm wondering about paying my money for SEE
11:11:13 <davidhouse> lscd, haskell-mode. the intelligent indentation saves _so_ much time. i think if i used any other editors, i wouldn't have a working space bar any more :)
11:11:14 <ndm> Beelsebob_, how much?
11:11:19 <lscd> url, Beelsebob?
11:11:19 <Beelsebob_> ndm: $35
11:11:24 <Beelsebob_> http://www.codingmonkeys.de/subethaedit/
11:11:30 <ndm> I paid Â£30 for textpad, for an editor, its well worth it
11:11:32 <lscd> davidhouse: yeah... it's annoying me a bit in vim
11:11:41 <ndm> will save you that much in a week of trying to learn emacs
11:11:51 <Beelsebob_> yeh... if I'm gonna pay money though, I might try TextMate
11:11:54 <davidhouse> "knows emacs" is going on my CV.
11:12:01 <davidhouse> that's worth a week :)
11:12:18 <palomer> but can you play tetris on subethaedit?
11:12:21 <mauke> who uses the space bar to indent?
11:12:23 <palomer> I think not!
11:12:38 * palomer hrmphs!
11:12:39 <davidhouse> lscd, but also the fact that i'm safe in the knowledge that whatever i want to do, emacs could do it. e.g. revision control integration.
11:12:49 <davidhouse> mauke: people that don't use emacs
11:13:01 <mauke> I don't, and I don't
11:13:08 <Beelsebob_> mauke: well... I put spaces in... but I use the tab key to do it
11:13:09 <davidhouse> you use real tabs?
11:13:14 <lscd> davidhouse: yeah -- my usual way of working is konsole with a lot of tabs, vim, and zsh
11:13:31 <lscd> davidhouse: generally, re: tabs
11:13:37 <mauke> I use ctrl-t to indent and ctrl-d to outdent (>> and << in normal mode)
11:13:48 <Beelsebob_> davidhouse: no - I use the tab key - but SEE puts spaces in instead
11:14:04 <davidhouse> Beelsebob_, but it doesn't do it as well as emacs :)
11:14:22 <Beelsebob_> davidhouse: what's better about the way emacs does it?
11:14:32 <kep> davidhouse: I like Eclipse but as an editor emacs is better :)))
11:14:33 <lscd> Beelsebob: better auto-indentation, i believe
11:14:39 <ndm> emacs "does it for you" - assumes its clever than you
11:14:46 <ndm> i hate the way it screws up ada...
11:14:46 <Beelsebob_> I don't like auto-indent
11:14:58 <lscd> hm, why? i hate not having it
11:15:00 <davidhouse> but the way it works is brilliant.
11:15:01 <Beelsebob_> all I want my editor to do is tab me to the same level as the last line
11:15:17 <mauke> :set ai 
11:15:21 <lscd> mauke: indeed
11:15:26 <davidhouse> it sets up a tab cycle, so if it doesn't get it right first time you hit TAB again and it cycles through the options.
11:15:39 <davidhouse> Beelsebob_, that's what i wanted until i tried haskell-mode.
11:16:05 <Beelsebob_> ohhh... nice feature of TextMate, you can hook it into a compiler, and it'll highlight errors as you complete things
11:16:28 <blazold> lo, how about you and "First-Order Logic" ?
11:16:48 <neologism> blazold: co potrebujes? :)
11:16:55 <lscd> Beelsebob: hm, cool - a bunch of people at my uni use textmate, but i haven't seen any of them using that feature
11:16:56 <blazold> mno jsem v prdeli rekneme
11:17:05 <blazold> pisu pisemku z logiky
11:17:11 <neologism> (english)
11:18:18 <Beelsebob_> lscd: I've not played with it... it may need compiler output in a specific format
11:18:21 <blazold> so, we've got
11:18:41 <blazold> |- (A->(B->C))->(B->(A->C))
11:18:42 <blazold> but why
11:18:43 <blazold> ?
11:19:00 <neologism> thats axiom.. isnt it?
11:19:04 <blazold> how to proof this
11:19:05 <blazold> nope
11:19:05 <lscd> Beelsebob: yeah, it would be truely magical if it could use arbitrary compilers
11:19:10 <blazold> we've got 3 axioms
11:19:12 <Beelsebob_> indeed
11:19:17 <blazold> (A1)  A->(B->A)
11:19:39 <Beelsebob_> lscd: know what the textmate command line command is?
11:19:39 <blazold> (A2)  (A->(B->C))->[(A->B)->(A->C)]
11:20:21 <blazold> (A3) (nB->nA)->(A->B)
11:20:34 <neologism> blazold: I'd rewrite that -> to and/or/not
11:20:43 <neologism> then tried applying the axioms in various way
11:20:44 <neologism> s
11:21:20 <blazold> finally i've received response from somebody else
11:21:36 <blazold> we've got also (DT) deduction theorem
11:21:58 <blazold> |- A->B      <=>    A |- B
11:22:13 <blazold> so it seems that 
11:22:26 <lscd> Beelsebob: nope, I run gentoo/ppc rather than osx almost all the time, and don't use textmate, sorry
11:22:43 <blazold> A->(B->C)   |-   A->(B->C)           (A1 + DT)
11:22:58 <blazold> A->(B->C),A,B   |-   C           (2*DT)
11:23:35 <blazold> A->(B->C),B,A   |-   C           (we can swap conditions)
11:23:50 <blazold> A->(B->C)   |-   B->(A->C)           (2*DT)
11:23:58 <blazold> |- A->(B->C)  ->   B->(A->C)           (DT again)
11:24:00 <blazold> and that's it
11:24:22 <blazold> and i wasn't able to make it in 2 hours, f**k :(
11:25:01 <blazold> this subject will kill me
11:27:49 <blazold> i'll fail the exam and will receive gobs of exercise 
11:29:12 <blazold> ok, sorry for disturbing you :/
11:34:53 <akemp> @seen SyntaxNinja
11:34:54 <lambdabot> I saw SyntaxNinja leaving #haskell 17 hours, 44 minutes and 29 seconds ago, and .
11:35:03 <xerox> and .
11:39:17 <Brody> anyone feeling like helping ?
11:39:37 <davidhouse> Cale, around?
11:39:44 <davidhouse> Brody: just ask your question
11:40:35 <Brody> but its a bit long :/
11:40:42 <Korollary> lisppaste2: url
11:40:42 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:51:09 <vincenz> Oejet: hiya
11:57:07 <Oeje1> vincenz: Hi.
12:31:24 <davidhouse> i've got a typeclass-related problem.
12:31:53 <davidhouse> i'm trying to include an extensible and easily-swappable output layer in my app.
12:32:16 <davidhouse> the approach recommended to me by Cale (ping?) was to use typeclasses.
12:33:02 <davidhouse> for example, i have two outputters at the moment, one for Ascii (terminal) output, another for HTML.
12:33:18 <davidhouse> i've got two newtypes for these, and an Outputter class which defines the functions i need in any outputter.
12:33:30 <davidhouse> the HTML and Ascii types are obviously instances of that class.
12:34:09 <davidhouse> now, i accumulate the output in a list of type Outputter o => [o].
12:34:44 <ihope__> You want to mix different types of things in the Outputter class in one list?
12:34:49 <davidhouse> ihope__: nope
12:35:27 <Cale> hi
12:35:27 <davidhouse> i need to switch on a runtime argument and chose the correct function to convert my o into a String (either unHTML or unAscii).
12:35:36 <davidhouse> hey Cale :) thanks.
12:35:54 <Cale> well, that's easy enough, you just use getArgs or some such and decide which function(s) to apply
12:36:05 <davidhouse> however, as soon as the compiler sees me running unAscii on something, it thinks it's an [Ascii] and fails on the other branch of the if.
12:36:10 <davidhouse> Cale, it doesn't typecheck
12:36:21 <Cale> right, you'll have to convert back to String
12:36:38 <davidhouse> @where paste
12:36:38 <lambdabot> http://paste.lisp.org/new/haskell
12:36:56 <Cale> if foo then fromAscii ... else fromHTML ...
12:37:01 <lisppaste2> davidhouse pasted "what i've got at the moment" at http://paste.lisp.org/display/19751
12:37:49 <Cale> yeah, you can't unify the types of unHTML and unAscii
12:38:04 <Cale> but you can lift that mapM_ up into the case
12:38:12 <Cale> case outputter of
12:38:30 <Cale>   "--html" -> do mapM_ (putStrLn . unHTML) os
12:38:40 <davidhouse> i'm sure i tried that
12:39:10 <Cale> oh, hang on
12:39:24 <Cale> the type of os will already be decided
12:39:39 <Cale> you have to move that stuff down too
12:40:34 <Cale> unless you were to explicitly give os a polymorphic type
12:40:55 <lisppaste2> davidhouse annotated #19751 with "this still doesn't work" at http://paste.lisp.org/display/19751#1
12:40:58 <Cale> also, what is the type of os? It looks like it's a list here.
12:41:07 <davidhouse> Cale, Outputter o => [o]
12:41:37 <Cale> okay, but it's pattern bound, so unless you give it a type signature, the MR will bite you
12:41:49 <Cale> hmm
12:42:15 <Cale> make sure that initOutput, logs, summary, and closeOutput are all really polymorphic
12:42:18 <Cale> what's the error?
12:43:44 <davidhouse> Couldn't match `Ascii' against `HTML'
12:43:44 <davidhouse>       Expected type: [Ascii]
12:43:44 <davidhouse>       Inferred type: [HTML]
12:44:16 <Cale> and the rest of it?
12:44:23 <Cale> (which term is that occurring on?)
12:44:38 <davidhouse> on the last line of the case
12:44:50 <davidhouse> (where the list is built on the the second branch)
12:45:03 <lisppaste2> davidhouse annotated #19751 with "the error" at http://paste.lisp.org/display/19751#2
12:45:10 <Cale> most likely, it's inferring a monomorphic type for one or more of initOutput, logs, summary, or closeOutput
12:45:34 <Cale> what do their definitions look like?
12:46:03 <davidhouse> they're part of the class declaration for Outputter
12:46:18 <Cale> oh, hmm, that's quite odd then
12:46:24 <Cale> all 4 of them?
12:46:51 <davidhouse> well, logs and summary are generated indirectly, but they should be, ye.
12:46:53 <davidhouse> *yes
12:47:07 <Cale> okay, can I see the definitions for logs and summary?
12:47:25 <Cale> (it matters if they're let or lambda bound)
12:47:34 <davidhouse> i may as well paste the whole module.
12:47:43 <Cale> okay, that would be good :)
12:48:10 <Cale> do they have explicit type signatures?
12:48:12 <lisppaste2> davidhouse annotated #19751 with "the whole module" at http://paste.lisp.org/display/19751#3
12:48:19 * Cale looks
12:48:20 <davidhouse> thanks very much for your help, by the way.
12:48:39 <Cale> aha
12:48:42 <Cale> as I thought
12:48:52 <Cale> logs and summary are pattern bound
12:49:07 <Cale> which means that they, by default, are assigned monomorphic types
12:49:19 <Cale> unless you explicitly give type signatures for them
12:49:35 <davidhouse> monomorphic? how does the compiler decide which one?
12:49:46 <Cale> it can't, and that's why you get the error
12:49:59 <Cale> that's the monomorphism restriction -- it's pretty irritating
12:50:06 <davidhouse> ah.
12:50:31 <davidhouse> so i need to annotate with... what? let summary = ... :: (Outputter o) => o
12:50:37 <ihope__> You can turn the monomorphism restriction off, can't you?
12:50:59 <Cale> yeah, you might just try compiling with -fno-monomorphism-restriction
12:51:06 <Cale> which might clear it up right away
12:51:07 <Cale> but yeah
12:51:16 <Cale> you can combine all those lets
12:51:21 <Cale> and add some type sigs
12:51:49 <lisppaste2> Cale annotated #19751 with "try this" at http://paste.lisp.org/display/19751#4
12:52:42 <Cale> hmm
12:52:58 <Cale> it might just move the problem up to run though
12:53:06 <Cale> which is lambda-bound
12:53:23 <Cale> so what you might have to do is push the case outward
12:54:36 <davidhouse> how so?
12:55:24 <prototype> anybody have any luck getting the VS plugin to work with VS2005?
12:55:51 <lisppaste2> Cale annotated #19751 with "case moved outward" at http://paste.lisp.org/display/19751#5
12:56:18 <Cale> of course, that should be possible to simplify
12:56:19 <RyanT5000> prototype: i just searched through the registry settings, and cut-and-paste anything that had "Haskell" in it
12:56:25 <RyanT5000> it worked flawlessly
12:56:36 <RyanT5000> or, to be more specifically, as flawlessly as it had worked on 2003
12:56:53 <prototype> RyanT5000: oh.  yeah, when I intall on 2005, i get an error towards the end of the install about a missing script
12:57:03 <prototype> RyanT5000: unfortunately, I don't have 2003 anymore
12:57:12 <RyanT5000> prototype: i had to get 2003 again :-/
12:57:16 <prototype> RyanT5000: heh
12:57:28 <davidhouse> Cale, hmm... would it not be possible to just annotate the type of run?
12:57:31 <prototype> RyanT5000: yeah, almost worth it.  it looks very slick.  i read the presentation
12:57:52 <prototype> RyanT5000: how's the emacs mode?
12:58:06 <RyanT5000> i have an issue with it though: i can't load a project and then compile it
12:58:08 <Cale> > (\s -> s 5 ++ s "Hello") show
12:58:08 <lambdabot>  add an instance declaration for (Num [Char])
12:58:09 <RyanT5000> if i do, it hangs
12:58:18 <RyanT5000> i can create a new project - then it works
12:58:18 <Cale> > (\s -> s (5 :: Int) ++ s "Hello") show
12:58:18 <lambdabot> Couldn't match `Int' against `[Char]'
12:58:29 <Cale> that's essentially the problem here
12:58:31 <RyanT5000> so now i'm just building manually
12:58:39 <RyanT5000> i don't really understand the VH setup well enough to use it effectively
12:58:44 <davidhouse> Cale, right.
12:58:55 <prototype> RyanT5000: didn't they release it under a BSD license now?  I guess I could monkey around with it if the source was available, even though I know nothing about Haskell or VS addin SDKs
12:59:05 <davidhouse> Cale, is there a good idea behind this restriction? it's going to make my code very ugly.
12:59:18 <RyanT5000> prototype: yeah, but it's not worth it to me to get into the source yet
12:59:24 <davidhouse> considering all of that code is going to have to be copy-pasted every time i write a new outputter
12:59:27 <RyanT5000> maybe... well, never
12:59:28 <prototype> RyanT5000: yeah, same here
13:00:11 <sieni> is template haskell coming to haskell'
13:00:18 <RyanT5000> sieni: it better be!
13:00:22 * RyanT5000 waves pitchfork
13:00:29 <sieni> and if it's not quite known yet, how can i help to get it there?
13:00:36 <Cale> davidhouse: well, for one, it might be fixed in the next GHC with the whole boxy types thing.
13:00:41 <RyanT5000> it'll let deriving be stuck in a library!
13:00:43 <RyanT5000> (prelude)
13:00:51 <Cale> but I think we can clean this up
13:01:30 <sieni> btw could there be parts of the standard which are "preliminary" so that they can be later withdrawn if one finds substantil problems with them?
13:02:25 <RyanT5000> i think the final standard should only have things which have been proven to not have substantial problems
13:02:26 <ndm_> sieni, no, i really really doubt it
13:02:30 <RyanT5000> or at least well-substantiated
13:02:35 <sieni> like there seems to be some issues with multiparameter type classes and functional dependencies, which might break something or there might be something fundamentally wrong with them, but then you could just withdraw those parts
13:02:49 <RyanT5000> problems with multiparameter classes?
13:03:11 <ndm_> there are many known problems with MPTC
13:03:28 <ndm_> especially termination and confuence of functional dependancies
13:03:43 <RyanT5000> well functional dependencies aren't necessary for MPTC, right?
13:03:49 <sieni> RyanT5000: http://hackage.haskell.org/trac/haskell-prime/wiki/MultiParamTypeClassesDilemma
13:03:50 <lisppaste2> Cale annotated #19751 with "factored" at http://paste.lisp.org/display/19751#6
13:03:54 <ndm_> technical no, practically, yes
13:03:59 <musasabi> RyanT5000: MPTCs don't have problems. But useful MPTC apps need either FD or AT and each has their own share of problems.
13:04:09 <Cale> see if that works
13:04:12 <Cale> I think it should
13:04:13 <RyanT5000> ok, that sounds reasonable
13:04:27 <sieni> ndm_: it would be nice that you could have parts of the language as an "experimental" extension sort of
13:04:34 <musasabi> although the delayed AT constraint propagation code might sidestep the problems.
13:04:39 <ndm_> sieni: yep, all of GHC :)
13:04:55 <sieni> ndm_: sort of yes ;-)
13:05:22 <Cale> davidhouse: ?
13:05:30 <Cale> any luck?
13:06:04 <Cale> (turn the m-r off for that code)
13:07:13 <davidhouse> Cale, hold a minute.
13:08:43 <Cale> The problem with the lambda-bound variables being monomorphic is an old one, and fixing it is difficult while preserving type-inference.
13:09:45 <sieni> ndm_: I was just thinking of stuff, which is between "standard haskell" and an "ghc extension". sort of more formalized.
13:09:49 <Cale> http://research.microsoft.com/~simonpj/papers/boxy/ -- this paper has a pretty good partial solution to the problem, and from what I've heard should be implemented in the next GHC.
13:10:07 <ndm_> sieni: would be nice, but to have a standard you need two implementations
13:10:11 <ndm_> independant of each other
13:10:20 <ndm_> like MVar's is now a bit more standard, because there are two
13:10:33 <sieni> ndm_: not necessarily. 
13:10:34 <ndm_> rank-2 types, ditto
13:10:50 <ndm_> i think so, beacuse otherwise hacks get in for one specific compiler
13:11:27 <davidhouse> Cale, thanks very much for your help :)
13:11:34 <Cale> davidhouse: is it working?
13:11:48 <sieni> well... ghc is unbelievably cool piece of software and with non-restrictive license, so there is little interest in competing
13:12:11 <sieni> which is kind of good and bad at the same time
13:12:12 <davidhouse> Cale, i need to do some more fixing before i can test, i'll ping you in about 10 minutes?
13:12:32 <Cale> okay, I have to go take a shower anyway
13:13:06 <davidhouse> sure.
13:13:58 <RyanT5000> dons: under ghc, if i curry a function that takes a function as its first argument (e.g.: map), can i expect that to be essentially fully optimized?
13:14:13 <RyanT5000> assuming the argument i give it is a const
13:14:20 <ndm_> sieni: there are lots of areas where GHC has competition, Hugs is faster to compile, nhc has lower memory useage, Yhc is more portable, Jhc is (or maybe will be) faster
13:14:32 <ndm_> Yhc will have good debugging - the list goes on :)
13:14:34 <sieni> ndm_: of course
13:14:52 <sieni> ndm_: but they have different target audiences
13:15:06 <sieni> well and jhc isn't production quality
13:15:14 <ndm_> exactly, which is again a good thing :) GHC is the most "polished" one, which is important
13:15:23 <ndm_> niether is Yhc or nhc
13:15:29 <ndm_> in my opinion...
13:15:34 <sieni> but for example between yhc and ghc it would be nice to have some standard system for extensions or something
13:15:43 <ndm_> it really would
13:16:13 <RyanT5000> wouldn't that be, like, as hard as making the into the same codebase?
13:16:31 <ndm_> RyanT5000: you mean merging GHC and Yhc (say)?
13:16:34 <RyanT5000> yeah
13:16:40 <ndm_> that looses many of the advantages of each
13:16:45 <sieni> RyanT5000: I don't think that's a good idea'
13:16:49 <RyanT5000> yeah i'm not advocating that
13:16:57 <RyanT5000> i'm just wondering how you'd make the extensions compatible without doing it
13:16:59 <ndm_> for example, Hugs is in C, GHC is in Haskell
13:17:06 <RyanT5000> they'd probably need to have identical AST formats
13:17:22 <sieni> but for "enterprise" use it would be nice for example to use ghc where it works and yhc as a drop in replacement on those platforms, where it doesn't
13:17:22 <ndm_> yep, thats one of the issues with Template Haskell, its a bit GHC specific for my liking
13:17:28 <mahogny> isn't yhc aimed at producing executables for embedded computers? then wouldn't that almost be equivalent to a new ghc backend?
13:17:47 <ndm_> mahogny: GHC could produce Yhc bytecode, certainly
13:18:05 <mahogny> well. that would at least take away all syntaxial extensions
13:18:09 <ndm_> but Yhc's strength is (or will be) debugging, the rest is just sound software engineering principles, rather than goals
13:18:19 <mahogny> hm. ok
13:18:31 <mahogny> haven't tested it yet. what makes it better for debugging?
13:18:35 <Igloo> ndm_: Do you mean you think the design is GHC-specific, or only GHC has implemented it?
13:18:38 <ndm_> i.e. we are windows/linux/mac/anything portable because we don't want to suffer when compiling :)
13:18:42 <musasabi> One could have a separate frontend library.
13:18:45 <RyanT5000> mahogny: what namespace do i put my project in?
13:18:56 <ndm_> Igloo: it exposes the ast, therefore i assumed it was a bit GHC centric at least
13:19:10 <ndm_> mahogny: integrated Hat trace generation (not in the public version yet)
13:19:11 <RyanT5000> right now it should be in both Graphics.UI and Graphics.Rendering, afact
13:19:20 <RyanT5000> afaict
13:19:22 <musasabi> Because I don't think any of {hugs,jhc,nhc,yhc} does anything fundamentally different before getting to the renamed source.
13:19:31 <Igloo> ndm_: I wouldn't say so. The AST is Haskell's rather than GHC's
13:19:32 <mahogny> RyanT5000, good question
13:19:45 <mahogny> RyanT5000, maybe that question should be postponed until there's a solid implementation
13:19:54 <RyanT5000> alright, just as well
13:20:02 <ndm_> Igloo: maybe, haven't really looked in detail - the other thing that worried me was Haskell' will change the ast
13:20:03 <RyanT5000> that way i can throw all the HS in one directory :)
13:20:18 <mahogny> RyanT5000, right :)
13:20:24 <RyanT5000> also, if anyone  has a good idea for a name for "a 3d gui toolkit in haskell", i'd love to hear it
13:20:44 <mahogny> 3DGUITIH? >_<
13:20:58 <RyanT5000> ouch
13:21:04 <RyanT5000> :P
13:21:19 <mahogny> reminds me of an old OS project of mine, name AIEOS. pronounce that one
13:21:27 <RyanT5000> i almost made "Haggis" work, but i decided i didn't even want that to be the name
13:21:43 <musasabi> mahogny: that sounds easy to pronounce given finnish.
13:21:50 <mahogny> well, no. I think most people dislike haggis :)
13:22:14 <norpan> hmmm, i can't think of a single time when i would use the "groupBy" function
13:22:22 <RyanT5000> i have a real question, though; i'm planning for the EPL and SCE's to be pluggable (at compile-time)
13:22:23 <mahogny> musasabi, consider you guys love to put a completely unpronouncable h in all your words, this is nothing :)
13:22:37 <RyanT5000> actually at run time too i guess, but i can't see why that'd be useful
13:22:42 <sieni> mahogny: i thought yhc aimed to be about as portable as lua, so that you have a byte code interpreter written in "pure c" (i.e. intersection of ansi c and c++) and you can run the byte code everywhere you have a c compiler
13:22:56 <sieni> mahogny: it would be nice to have as a fallback option.
13:23:06 <musasabi> sieni: ansi C + concurrency does not work.
13:23:18 <musasabi> or you need bytecode.
13:23:18 <sieni> musasabi: ?
13:23:23 <RyanT5000> in any case, is it reasonable to have a hierarchy with EPL defining the interface, EPL.Implementations.Name being the location of "Name", which is an epl implementation?
13:23:34 <musasabi> which yhc does which eliminates the problem.
13:23:36 <RyanT5000> e.g.: EPL.Implementations.SDL
13:23:41 <sieni> musasabi: I was thinking about
13:23:49 <mahogny> RyanT5000, hm. sce and epl. what are those?
13:24:03 <RyanT5000> scene composition engine and event-driven programming layer
13:24:09 <RyanT5000> the two main non-widget components
13:24:11 <mahogny> aha
13:24:25 <davidhouse> Cale, (for when you get back), it worked! :) thanks again!
13:24:44 <mahogny> RyanT5000, hm. I need to ponder that one
13:25:00 <davidhouse> Cale, and lets hope when GHC 6.next rolls around this conversation will never happen again :)
13:25:23 <RyanT5000> oh i think i just found a reason  not to do it that way: some EPL/SCEs will go together
13:25:42 <RyanT5000> e.g.: my original design will be SDL + OpenGL; EPL will use only SDL, but SCE will use both
13:26:04 <RyanT5000> so maybe it should be a totally separate module, which exports EPL/SCE interfaces
13:26:49 <mahogny> RyanT5000, I don't think that will become obvious until you actually write down the functions you want, and the design behind the rest
13:27:34 <RyanT5000> yeah
13:28:12 <mahogny> RyanT5000, question though, how much would you expect the EPL to differ between implementations? you might even be able to move it out from the library dependent space entirelly
13:28:46 <RyanT5000> the interface should be identical
13:29:33 <RyanT5000> possibly special implementations would have "extensions", but the point is that it needs to take messages from an external lib like SDL, and convert them to a unified format that all the widgets understand
13:29:36 <mahogny> RyanT5000, of course. but I think the only thing that differs in how events are triggered. and that's not much code at all. it could almost go into the SCE and then the EPL is shared between all libs
13:29:42 <RyanT5000> EPL implementations should be very thin
13:29:49 <mahogny> yeah
13:30:09 <RyanT5000> but we can't know what EPL implementations someone would need, so they have to be external
13:30:20 <RyanT5000> also, we can't force someone to link with, e.g., SDL, if they aren't going to use it
13:30:25 <mahogny> right
13:30:48 <RyanT5000> for now i'll just have SDL_EPL separate
13:31:05 <RyanT5000> or something, that is
13:31:07 <RyanT5000> lol
13:31:17 <RyanT5000> i dunno, something that contains an EPL and an SCE
13:32:41 <mahogny> RyanT5000, have you started writing on a specification for the library? that is, lists of requirements and which widgets will go in and which will not?
13:33:36 <RyanT5000> not yet; i wanted to mess around trying to factor a simple program into my vague concept of it first, and hopefully get a bit more insight
13:33:41 <RyanT5000> something without any familiar widgets
13:33:54 <RyanT5000> e.g.: a triangle you can change the pitch and yaw of with wasd
13:34:10 <RyanT5000> i already have that as a monolithic program
13:35:20 <mahogny> will you try and do widgets OOP style? I have a feeling it might be harder 3d than with 2d
13:35:43 <RyanT5000> well, that depends on what you mean by OOP style
13:35:50 <RyanT5000> i will probably have some polymorphic widgets
13:35:55 <RyanT5000> though maybe not
13:36:05 <mahogny> as in, make it easy to inherit properties of other widgets and make new ones
13:36:23 <RyanT5000> hm, probably to some degree
13:36:31 <RyanT5000> i'm not using any explicit OOP though
13:36:33 <RyanT5000> because i hate it
13:36:46 <RyanT5000> OOP design - probably yes; OOP syntax - probably no
13:36:50 <lscd> why do you hate it?
13:37:08 <RyanT5000> because i can do the same thing with global  functions, except more flexibly
13:37:34 <RyanT5000> dynamic dispatch: add a function pointer to the datatype definition, add a global function that looks up the function pointer and then calls it
13:37:35 <mahogny> well, the only useful part of OOP is the abstraction. OOP syntax? that's language dependent :)
13:37:59 <RyanT5000> yeah, but things like dynamic dispatch based on multiple arguments is really hard if you get entrenched in a syntax
13:38:54 <Philippa> mahogny: which abstraction? :-)
13:39:02 <RyanT5000> sort of like the list argument for making their whole language painful  to look at: if it's all equally painful  no one will choose a particular feature just because it is prettier
13:39:04 <Philippa> some OO models take the idea of message-passing more seriously than others...
13:39:11 <BlueCreator> hey all
13:39:11 <BlueCreator> PDPC's 2002-2006 budget information: http://rapidshare.de/files/19794405/pdpc_budget2002-2006.zip.html
13:39:23 <mahogny> Philippa, my abstraction, which differs from day to day, and project to project :)
13:39:41 <Philippa> ah, you don't find objects themselves a useful abstraction?
13:39:53 <Philippa> (I do, for a family of object-like ideas - which one varies... yeah, you get the idea)
13:40:02 <mahogny> Philippa, objects is a good start
13:40:11 <RyanT5000> Phillipa: the problem with the notion of "objects" is that it's completely ill-defined
13:40:28 <lscd> RyanT5000: or rather, there are a large number of definitions, some of which are mutually exclusive
13:40:31 <RyanT5000> they involve an inherent assumption of uniqueness
13:40:35 <Philippa> RyanT5000: I disagree... what lscd said
13:40:37 <mahogny> ill-defined indeed. I shoot the head of anyone claiming that objects == classes
13:40:47 <RyanT5000> no, i'm talking about the most basic thing
13:40:49 <lscd> mahogny: why?
13:40:50 <Philippa> I dunno, it's sensible in some systems
13:40:53 <lscd> in some systems, that's true
13:40:56 <RyanT5000> that an object is a place to put a value
13:41:06 <Philippa> but that's not the most basic thing
13:41:12 <RyanT5000> it isn't?
13:41:14 <Philippa> you're defining object = mutable state
13:41:16 <mahogny> lscd, because it doesn't hold in general, and if I decide to break it, I can break it even in java
13:41:21 <RyanT5000> yes, Philippa
13:41:24 <Philippa> or rather, object = storage cell
13:41:43 <Philippa> which *really* doesn't hold when doing OOA on non-computational systems
13:41:43 <lscd> mahogny: hm, could you give me a quick example of what you mean by breaking it?
13:41:44 <RyanT5000> is there an OOP system that does not agree with that?
13:41:58 <xerox> SmallTalk?
13:42:12 <Philippa> it'll take me a matter of minutes to hack up a 'functionally pure OO' model in haskell :-)
13:42:13 <lscd> xerox: smalltalk sees objects as miniature 'computers', with state and functions
13:42:24 <Cale> davidhouse: great :)
13:42:30 <lscd> so, i'd say that his definition holds, though it's only part of the smalltalk model
13:42:38 <Philippa> lscd: nearly. IIRC smalltalk doesn't have the possible parallelism that implies?
13:42:47 <Cale> To me, what OOP is really about is bounded existential typing.
13:42:48 <mahogny> lscd, you could call an array an object with variable number of members. you still use the OOP abstraction, but you don't use classes. so putting a == is just an unneeded constraint on what you are allowed to do
13:43:00 <RyanT5000> alright well fine, then let me change what i'm saying: any model that assumes you have an ability to generate globally unique objects is fundamentally flawed
13:43:05 <Philippa> Cale: we've had this argument :-)
13:43:19 <lscd> Philippa: actual implementations of smalltalk tend to suck with parallelism; i don't see why smalltalk in theory wouldn't be able to have that, but this could just be my ignorance
13:43:20 <RyanT5000> not just becuase generating globally unique IDs is impossible, but because you should never need to
13:43:20 <xerox> Cale: what does `bounded typing' mean?
13:43:30 <Philippa> I disagree, that's perfectly valid given a unique object supply
13:43:44 <RyanT5000> right, but then you have to know which unique object supply you're using
13:43:50 <RyanT5000> meaning it's not "global"
13:43:53 <Philippa> smartarse
13:43:59 <RyanT5000> :)
13:44:03 <Korollary> OOP is something people still argue about after 20 years of industry-wide acceptance, shelves full of books in numerous languages that support it.
13:44:03 <Cale> xerox: well, the fact that there exists some type for your term, and while you don't know what it is, you know that it satisfies some specific things
13:44:13 <RyanT5000> i had this exact problem in my last/current project
13:44:14 <Philippa> "as global as the system is capable of comprehending" works nicely
13:44:19 <xerox> Cale: invariants?
13:44:19 <Philippa> "which store? The global one"
13:44:28 <Cale> xerox: yeah -- in Haskell, they'd be typeclasses
13:44:34 <Cale> some interface to functionality
13:44:41 <RyanT5000> philippa: that's very ill-defined
13:44:41 <lscd> mahogny: well, in java, there's the concept of primatives and objects; and in most systems, classes != objects; otoh, i've seen some lisp source for a tiny (< 30 line, not using clos) system where classes == objects
13:44:48 <mahogny> Korollary, industry has proven with lots of bugs to a bad selector of methods :)
13:44:53 <xerox> Cale: I see what you mean, not value-invariants.  Okay.
13:45:08 <RyanT5000> consider this: you have a distributed system, and two nodes, which do some stuff, and make some "globally unique" objects
13:45:13 <RyanT5000> now you clone one of the nodes, exactly
13:45:16 <palomer> Cale: I was thinking, how exactly would you deal with left recursion? I mean, what do you do with a = (a `times` (string "b")) `plus` (string "b") ?
13:45:17 <Philippa> RyanT5000: in the general case, yes. But it asks as much as 'which store?', which is what matters
13:45:18 <RyanT5000> think, "star trek replicator"
13:45:21 <mahogny> lscd, you can make it == if you want to. what I just say is, you shouldn't hang up on language features. OOP is a way of thought, nothing else
13:45:29 <Philippa> think, "rabid breaking of system invariants"
13:45:37 <Philippa> or to put it another way, DDTT
13:45:44 <lscd> mahogny: sure, i'd actually argue it's a class of ways of thought :)
13:45:55 <mahogny> lscd, lol
13:46:03 <davidhouse> objects are often instances of classes (in OOP)
13:46:05 <RyanT5000> Philippa: there are lots of cases in which you get a perfect cloning
13:46:16 <Cale> No matter what OOP system you look at, they all have this ability to forget the exact types of certain values, and allow you to work with them through some specific interface without knowing exactly what they are.
13:46:20 <RyanT5000> that's why GUID uses so much random data
13:46:23 <RyanT5000> like time
13:46:42 <RyanT5000> Philippa my other point is that you don't ever need globally unique IDs
13:46:47 <lscd> davidhouse: sure, that's about as close to a standard definition as you get; in some systems, classes are also objects; in some they aren't; etc
13:46:49 <Philippa> Cale: FCVO 'interface' which may not even be in the type system
13:47:10 <RyanT5000> these points combine to create my argument against the notion of objects as containers
13:47:10 <Philippa> RyanT5000: Source-identified-to-global-level.ID doesn't count as a globally unique ID?
13:47:13 <lscd> Philippa: DDTT?
13:47:17 <Philippa> (OK, so you get NATted and the like)
13:47:35 <Philippa> Patient:"DDIHWIDT" Dr: "DDTT"
13:47:42 <RyanT5000> Philippa: yes it does, but that's an infinitely recursive ID
13:47:46 <Philippa> (you know the joke in question, or do I need to spell it out?)
13:48:05 <RyanT5000> no, i don't know it :P
13:48:07 <lscd> oh.... right
13:48:08 <Cale> Philippa: well, usually the interface isn't explicitly in the type system, but it's certainly implied in some manner from the type given to the term
13:48:13 <Philippa> RyanT5000: global != universal :-)
13:48:15 <lscd> patient: doctor, doctor, it hurts when i do this
13:48:18 <lscd> dr: don't do that then
13:48:23 <RyanT5000> Philippa: fine, then i mean universal
13:48:25 <RyanT5000> either way
13:48:31 <Philippa> Cale: you do seem to be effectively assuming a language with an actual type system though
13:48:33 <RyanT5000> metaversal if that helps
13:48:37 <xerox> Philippa: you get a GPS and assign coords to the object.  Two things can't be in the exact same place ^_^
13:48:57 <RyanT5000> ah
13:49:02 <Cale> palomer: that's something to look into -- I know there are mechanical ways to translate grammars to eliminate left recursion.
13:49:16 <palomer> ah, so we'd rewrite the terms
13:49:18 <mahogny> xerox, I don't think the precision of GPS is able to deal with positions in RAM :)
13:49:42 <xerox> mahogny: but if it was, it would work, wouldn't it? (-:
13:49:49 <RyanT5000> iac, i've found that anything involving GUIDs that i've looked at closely would have done better without them
13:49:51 <Philippa> RyanT5000: I do agree with you on "object != container"
13:49:58 <palomer> Cale: note that these terms won't even be in BNF
13:50:02 * Philippa nods
13:50:19 <mahogny> xerox, until you turn the computer 90 degree and the transformation matrix to obtain the position becomes singular ;)
13:50:22 <palomer> if you add recursion to regular expressions, you get the power of CFGs, right?
13:50:22 <RyanT5000> that's really the only problem i have with OOP :)
13:50:29 <Philippa> I agree that in practice they're more likely to be too big a PITA, and that you're more likely to have an "oh shit, there's a new layer on top I forgot to allow for" moment
13:50:39 <RyanT5000> yeah
13:50:53 <Cale> Philippa: well, I'm assuming some Curry-Howard type situation :)
13:50:55 <RyanT5000> it's not a very maintainable design
13:50:55 <palomer> Cale: the problem, also, is we have no way of detecting cycles
13:51:04 <Philippa> palomer: BNF isn't the be-all and end-all. PEGs have some overlap, but parse some stuff BNF doesn't properly. PEGs are good.
13:51:42 <Philippa> Cale: by which point you get 'types' that nobody actually working in the language'd consider to be the point in anything?
13:51:52 <palomer> Cale: so we have no way of figuring out that a grammar has any kind of recursion
13:52:01 <davidhouse> is my connection alive?
13:52:08 <palomer> (in much the same way as its impossible to find out if a list is infinite)
13:52:12 <xerox> @localtime davidhouse 
13:52:13 <lambdabot> Local time for davidhouse is Sat May 6 21:52:00 2006
13:52:13 <davidhouse> woah. yes.
13:52:15 <palomer> s/its/it's
13:52:24 <Philippa> palomer: I've missed some context, why can't you look for cycles?
13:52:34 <palomer> we're building a parse tree
13:52:46 <palomer> one sec, ill get you the link
13:52:56 <Philippa> ah. It's cycles in the "tree" that're the worry, not ones in the grammar. With you
13:52:59 <BlueCreator> @localtime bluecreator
13:53:04 <Cale> Philippa: what do you think that this description loses?
13:53:10 <palomer> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype <-- third example
13:53:26 <Philippa> Cale: the things that smalltalk and self have in common
13:53:40 <Cale> Which is?
13:53:46 <Philippa> which I find to be an important part of the 'OO' conceptual space
13:53:52 <Philippa> "stateful things passing messages between each other"
13:54:18 <Philippa> and probably a few more bits and pieces. But at that level, it doesn't have anything much per se to do with typing disciplines even if there's one you can find
13:54:40 <Philippa> (which, incidentally, you can't due to the level of metaprogramming possible)
13:55:26 <RyanT5000> Philippa: isn't that actually "Actor"-oriented programming?
13:55:39 <RyanT5000> also, what's the difference between "stateful" and "container"?
13:55:44 <palomer> a = a `Plus` (string "c") <--how the blazes could we detect that we need to rewrite this?
13:55:46 <Philippa> containers can be immutable
13:56:09 <Philippa> palomer: ah. That's a problem with the grammar being represented by haskell code, no? :-)
13:56:10 <RyanT5000> stateful can't
13:56:22 <palomer> Philippa: yup
13:56:35 <Philippa> also, a lot of people don't think "single storage cell" when you say container, but hey
13:57:18 <Philippa> or rather, by /general/ haskell code. The words "you generate an infinite grammar, don't come crying to me about it" come to mind :-)
13:57:26 <RyanT5000> if you think of a value as a point in the statespace for its type, the distinction between "stateful thing" and "container" becomes null
13:57:30 <Cale> palomer: the grammars that we hope to rewrite ought to be finite
13:57:46 <Philippa> RyanT5000: that's playing silly buggers with the word 'state'
13:57:54 <Philippa> not what I meant by it and you know it
13:57:56 <RyanT5000> what?
13:58:02 <RyanT5000> i don't agree
13:58:06 <palomer> Cale: so how would we express the the production A = A 'c' ?
13:58:19 <RyanT5000> why do you think it's called "point-free" programming, not "value-free" programming?
13:58:27 <RyanT5000> point = value = state
13:58:39 <Cale> palomer: using Star?
13:58:50 <Philippa> please stop redefining the terminology used day-to-day by everyone else in here
13:58:51 <xerox> I thought point = formal arguments.
13:58:54 <Philippa> quite
13:58:57 <palomer> ok, what about A = (A) | empty
13:59:07 <lscd> yeah, what xerox said
13:59:16 <Philippa> I could write point-free code in a state monad if I were sufficiently deranged
13:59:41 <Cale> you are right though, we need some sort of explicit self-capture
13:59:45 <RyanT5000> alright, let's say i have a value of type (Int, Float, Bool)
13:59:49 <Philippa> it'd be illegible, but then people use concatenative languages for real work so who'm I to complain?
14:00:04 <Philippa> yes. And in haskell, *that value is immutable* - it's not a state
14:00:06 * int-e still thinks it's ironic that point-free code usually contains lots of dots.
14:00:21 <RyanT5000> that value is a point in the set Ints cross Floats cross {True, False}
14:00:29 <xerox> > runState (return . (+1) =<< get) 1
14:00:30 <lambdabot> (2,1)
14:00:32 <RyanT5000> in engineering the notion of "state space" is widely used
14:00:50 <lscd> not only in engineering; formal verification uses it too
14:00:57 <davidhouse> > runState (liftM (+1) get) 1
14:00:58 <lambdabot> (2,1)
14:01:00 <Philippa> yes. And here the equivalent concept is 'value space'
14:01:06 * xerox pokes davidhouse 
14:01:09 <Cale> RyanT5000: but it's not really a state associated with the ongoing computation
14:01:20 <RyanT5000> Cale: how not?
14:01:23 <Cale> it's either a result, or an input parameter
14:01:27 <davidhouse> xerox, whenever you use return on the RHS of a >>=, think liftM
14:01:40 <Philippa> RyanT5000: you're trying to tell us that there's no such thing as a pure function
14:01:46 <RyanT5000> what? no
14:01:55 <Philippa> yes you are. Think it all through
14:01:56 <RyanT5000> state != state variable
14:02:24 <Philippa> no kidding. Values don't "have states"
14:02:29 <RyanT5000> right
14:02:31 <RyanT5000> i didn't say that
14:02:34 <RyanT5000> i said they are states
14:02:40 <Philippa> now, what do you think we mean by "stateful" here?
14:02:51 <tuxplorer> does anyone know of Lambada framework? http://citeseer.ist.psu.edu/463225.html
14:02:53 <RyanT5000> stateful = "state variable" = "container"
14:02:54 <palomer> that wouldn't be too hard, you'd have a function foo x = (x) | empty, and then you'd take the fixed point
14:03:03 <RyanT5000> it's a thing that has a state
14:03:15 <RyanT5000> if it's immutable, then it's just a state with a box around it
14:03:21 <lscd> RyanT5000: in general, for something to be considered a state variable, it has to be mutable, i think?
14:03:46 <xerox> Because it's variable! (-:
14:03:52 <Philippa> you're putting the cart before the horse
14:03:57 <Philippa> what lscd said
14:04:07 <RyanT5000> lscd: it could be a "const state variable", although that's, as i just said, a state with a box drawn around it
14:04:08 <Cale> When I hear "stateful", I think "typed in some State monad"
14:04:29 <mahogny> omg @ discussion :(
14:04:34 <lscd> RyanT5000: you seem to be using state in a different sense than everyone else here
14:04:46 <Cale> or roughly a function from initial states to values and final states
14:04:58 <lscd> mahogny: why?
14:04:59 <Philippa> RyanT5000: you're *still* playing silly buggers by redefining stateful out from under us by changing the notion of state on the assumption that because values can be used as states they are always such
14:05:04 * xerox nods in Cale direction
14:05:14 <mahogny> lscd, everyone are talking on different levels of abstraction
14:05:19 <lscd> Philippa: i think he just has a different definition of it that doesn't accord with the usual haskell one
14:05:31 <Philippa> lscd: which is fine until you try to tell us our language is invalid
14:05:32 <mahogny> lscd, ...about something that's not even remotely interesting. go code instead :(
14:05:36 <RyanT5000> i don't think i'm redefining it though, which is the only reason i'm still talking about it; i don't understand why we are disagreeing
14:05:38 <tuxplorer> As HSP doesnt have POST data support, i want to deploy my web service on Servlets and use Haskell functions.. What can I do? I saw about Lambada framework, but dunno where its available, and whether its non-proprietary
14:05:39 <lscd> mahogny: yeah; unfortunately, i don't understand all of this to mediate 
14:05:52 <Philippa> RyanT5000: you're assuming that "thing that can be used as a state" = state
14:05:59 <Cale> RyanT5000: look at my definition :)
14:06:00 <RyanT5000> yes
14:06:05 <Philippa> we differ with that assumption
14:06:21 <Philippa> not least because otherwise you've just reinvented "thing"
14:06:41 <Cale> a "stateful value of type a" is a function from initial states to values of type a, and final states
14:06:44 <xerox> newtype State s a = State { runState :: s -> (a,s) } -- is what I believe.
14:07:00 <Cale> yes, like that :)
14:07:06 <mahogny> the art of working at the wrong level of abstraction :)
14:07:26 <RyanT5000> since when is a "state" a "function"?
14:07:39 <Philippa> the engineering use comes about because for engineering purposes you're always analysing the state space of a system. Extending that concept outside the original field means assuming it holds true
14:07:43 <lscd> RyanT5000: hm... in my understanding, in haskell, the code involves no 'state' (ignoring monads); the parameters to a function and outputs aren't considered to be state, and the function returns the same thing all the same time given the same arguments; state is something mutable; something 'const' has a value, but not mutable state </totally-garbled-attempt>
14:07:46 <RyanT5000> i'm using the term "state" as in "state machine" as in "turing machine"
14:07:50 <Philippa> RyanT5000: it's not. Welcome to the sometimes-confusing practice of naming monads
14:08:01 <Philippa> that's the type of a monad that supports stateful computation
14:08:22 <Philippa> RyanT5000: Yup. We *aren't doing state machines here*
14:08:24 <Cale> @type get
14:08:26 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
14:08:28 <xerox> Philippa: I think Cale is right when he talks about State as a function from initial state to outcome and final state.
14:08:30 <Cale> @type put
14:08:31 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => s -> m ()
14:08:49 <RyanT5000> xerox: isn't that usually called a "state transition"?
14:08:50 <Philippa> you can define function evaluation in terms of an abstract machine with a clear notion of state, but that's not the same thing
14:09:03 <Philippa> RyanT5000: State != state. have fun.
14:09:09 <tuxplorer> someone plz help me run a webservice with haskell at the backend..
14:09:11 <RyanT5000> Philippa i never said State
14:09:18 <Philippa> no, but they did
14:09:30 <mahogny> tuxplorer, look into happs
14:09:38 <xerox> I mean, what's State if it's not "integrated in time" ?
14:09:55 <Philippa> xerox: a pure function inna box :-)
14:10:03 <Cale> RyanT5000: It's possible to have a state of type (Char, Int, Bool), but in an ordinary function being applied to a value of that type, it's generally not considered to be a state at all.
14:10:19 <xerox> Philippa: hehe, I don't mean anything unpure, I wanted to make clear what the (->) was doing it for me.
14:10:30 <xerox> s/it/there/
14:10:33 <tuxplorer> mahogny, thanks, will look into it
14:10:56 <Cale> It only becomes a state when it's silently threaded through a computation, and potentially observed and modified from time to time.
14:11:12 <Philippa> Cale: I'd go so far as to say that that's because fundamentally it isn't. So what if the most common ways of defining evaluation use a stateful model?
14:11:15 <xerox> Yes, beta-reduction isn't state.
14:11:22 <Cale> (you can basically formalise that as being when it's the s in State s a.
14:11:23 <Cale> )
14:11:26 <RyanT5000> Cale: why wouldn't you call that a "state variable"?
14:11:35 <Philippa> because it never changes
14:11:38 <RyanT5000> do you agree that the term "state variable" is meaningful and well defined?
14:11:50 <Cale> How do you define it?
14:12:08 <Philippa> I agree it's meaningful. Then see Cale's question
14:12:11 <Cale> a value of type (Char, Int, Bool) is not dependent on state
14:12:23 <RyanT5000> that's true, but it is a state
14:12:27 <Philippa> sez you
14:12:28 <Cale> no
14:12:33 <Philippa> and that's the furthest you're getting
14:12:39 <Cale> it *can be* in specific circumstances
14:12:44 <Philippa> thing is, *you appear to be extending terminology outside of your field*
14:12:53 <Cale> in particular, it's the state type of the monad State (Char, Int, Bool)
14:13:03 <Philippa> so, a formal description of "state variable" please
14:13:11 <RyanT5000> i define a state variable as a thing from which you can get or set a state
14:13:22 <Philippa> note that "I can model something with a state variable" isn't good enough to say it is one
14:13:29 <xerox> That's a type, in fact, not a variable.
14:13:30 <Philippa> especially not if it's not an isomorphism
14:13:41 <LordBrain> hmmm
14:13:44 <Cale> RyanT5000: from that perspective, a value of type (Char, Int, Bool) is entirely inert
14:13:44 <Philippa> OK. You can't set a state in a value
14:13:50 <Philippa> quite
14:13:53 <Cale> You can't modify it at all.
14:13:56 <RyanT5000> right
14:14:04 <Philippa> I dunno, you could consider pattern-matching on it to be 'getting'
14:14:19 <Philippa> but there ain't no setting
14:14:22 <RyanT5000> no, you can't modify a state; you can modify a state variable
14:14:33 <RyanT5000> a chessboard is a state variable
14:14:36 <Cale> but it's not a state
14:14:45 <RyanT5000> a particular configuration of pieces on the chessboard is a state of the chessboard
14:14:46 <Philippa> RyanT5000: picky. "You can't set the state of a value"
14:14:50 <Cale> not in general, anyway
14:14:53 <Cale> for example
14:15:00 <Philippa> it just is
14:15:00 <Cale> in the monad State String
14:15:10 <Cale> a value of type (Char, Int, Bool) is not a state.
14:15:26 <RyanT5000> this isn't about monads; they aren't the only way of describing stateful computations
14:15:38 <xerox> And State makes sense only in computations-.
14:15:45 <RyanT5000> xerox: true
14:15:53 <mahogny> RyanT5000, I think have lost track. what was the point? :(
14:15:58 <Philippa> RyanT5000: you're back to layering your concept of state on top of an existing system again
14:15:58 <Cale> I know, but every model of describing stateful computations is equivalent to some state monad, so we might as well use them. :)
14:15:58 <RyanT5000> but that depends on how you define "computation"
14:16:03 <RyanT5000> my point is that a "value" is a "state"
14:16:12 <Philippa> and *you've got no further than that*
14:16:18 <RyanT5000> that's because you  haven't accepted that
14:16:23 <Philippa> so some actual fucking argument please, not constant re-assertion
14:16:41 <Cale> RyanT5000: that's because 'state' doesn't mean what you want it to mean here, but we don't really know what your definition of it is.
14:16:43 <Philippa> we haven't accepted that *because you've provided no good argument as to why we should*
14:16:48 <davidhouse> Cale, are there other ways of modelling stateful computations other than st -> (v, st) ?
14:16:53 <Philippa> Cale: it appears to be isomorphic to "thing"
14:17:02 <mahogny> RyanT5000, there are several definitions of state. all makes sense. which you use depends on the context
14:17:16 <lscd> Philippa: it seems to be more a terminology problem than anything; calm down
14:17:16 <LordBrain> hey guys.. this is off topic, but is there a way to display it if i have a value of type IO String ?
14:17:29 <RyanT5000> let's say we have a physical system with a particle in a coordinate system
14:17:30 <xerox> Hmmm... continuations?
14:17:31 <ihope__> LordBrain: what do you mean?
14:17:33 <Philippa> lscd: it's a cultural imperialism issue, he's telling us our own concept of 'stateful' is meaningless
14:17:34 <Cale> LordBrain: that's an IO action which is capable of returning a string
14:17:42 <Philippa> RyanT5000: no. Complete definition, not example
14:17:51 <Cale> LordBrain: you run it to extract the string, and pass the result to putStrLn
14:17:54 <RyanT5000> Philippa i'll get to it
14:18:02 <lscd> Philippa: i failed to get that impression; he just isn't accepting and/or understand it
14:18:06 <Cale> do x <- myIOString; putStrLn x
14:18:07 <LordBrain> oh
14:18:16 <xerox> myIOString >>= putStrLn
14:18:16 <LordBrain> hmmm
14:18:21 <RyanT5000> the particle has a state, which is the position, and maybe spin and stuff of the particle
14:18:40 <RyanT5000> lscd: i think i understand their definition, and i don't accept it
14:18:52 <RyanT5000> the particle is a state variable, becuase it "has" a state
14:19:03 <lscd> RyanT5000: the haskell view would be that the particle has a value, and you can apply functions to the particle to get a new value, without changing the initial one; but the particle itself can't change
14:19:13 <Philippa> RyanT5000: you're running into multiple definitions at once, including at least one that's effectively shorthand slang
14:19:30 <xerox> type Particle = (Position,Spin,Stuff)
14:19:37 <Cale> heh
14:19:38 <RyanT5000> no
14:19:39 <lscd> in physics terms, it makes no sense; however, haskell's definition seems consistant and makes sense to the (limited) extent i understand it -- it's just a mind-bender 
14:19:39 <xerox> tick :: State [Particle] a
14:19:48 <xerox> That's it!
14:19:51 <Philippa> xerox: no. We're talking about a stateful system, so the type's ParticleState
14:20:06 <mahogny> xerox, you are locking up on language features. that's a bad habit :)
14:20:13 <xerox> Philippa: how would you do it in Haskell?
14:20:14 <Cale> Philippa: look at his tick :)
14:20:16 <Philippa> a Particle *is not* a (Position, Spin, Stuff)
14:20:21 <xerox> mahogny: I'm working in a formal system.
14:20:36 <Cale> ah, okay, that's all you're concerned with
14:20:39 <xerox> tick is the point, anyway.
14:20:40 <Philippa> Cale: have done. Oh look, State vs state.
14:20:56 <RyanT5000> Particle = IORef (Position, Spin, Etc)
14:21:03 <Philippa> monads have confusing names, news at 11
14:21:17 <xerox> Oh.
14:21:18 <RyanT5000> i'm not completely familiar with all the haskell terminology
14:21:25 <RyanT5000> which is irrelevant, because i'm not talking about haskell
14:21:31 <lscd> RyanT5000: afaik, the idea in haskell is that there's the "world", which has what you'd call a 'state', but which is immutable; you create a new world when what you'd consider to be a state variable changes, so each 'world' is immutable, and more like a (very large compound) value than a state
14:21:34 <mahogny> monads... warm fuzzy things
14:21:41 <Philippa> RyanT5000: the moment you invoke IO, the situation changes considerably because you've effectively imported a whole new external language
14:21:46 <lscd> [everyone else: feel free to correct me if i'm getting it entirely, or partly, wrong]
14:22:03 <Cale> lscd: exactly
14:22:08 <davidhouse> RyanT5000: so state variables are inextricably impure?
14:22:09 <Philippa> haskell-sans-IO doesn't have a concept of state, the IO monad does (and a concept of state can be introduced)
14:22:12 <xerox> lscd is quite right.  An Haskell module it does nothing.
14:22:14 <RyanT5000> Philippa how is that different from your use of State or whatever else?
14:22:17 <xerox> s/it//
14:23:02 <RyanT5000> davidhouse: depending on how you look at it
14:23:04 <Philippa> RyanT5000: OK, the one I'm arguing about is state with a lower case s - State is the State monad, and I for one can cheerfully ignore it for now
14:23:24 <RyanT5000> alright, so let's ignore the fact that we have any programming languages
14:23:43 <davidhouse> Philippa: depends if by "state" you mean "state of the real world" or "value threaded through a computation, chopped and changed and (presumably) changing the output of the computation"
14:23:43 <Philippa> no. That's not sufficient, because we're talking about whether a programming language has a sensible notion of state
14:23:51 <xerox> What's the problem about using a formal system?
14:23:51 <Philippa> that is, whether its programs are stateful
14:23:58 <Philippa> I'd contend that pure haskell functions are not stateful
14:24:08 <RyanT5000> lol i'm not trying to argue with that
14:24:10 <lscd> Philippa: by your definition of state, they're not; by his, they are
14:24:10 <Philippa> and that therefore their inputs and outputs are not states
14:24:12 <RyanT5000> of course pure functions are not stateful
14:24:38 <RyanT5000> that second thing i disagree with
14:24:40 <xerox> An Haskell module has 0 dimensions.
14:24:44 <Cale> hehe
14:24:49 <lscd> xerox: what does that mean?
14:24:53 <RyanT5000> why can't you take a state as input and return a state as output?
14:24:54 <xerox> Ask Cale
14:24:55 <Philippa> OK, you appear to be insisting that "can be used as a state => is a state"
14:24:57 <xerox> <grin>
14:24:59 <ihope__> What the...
14:25:13 <Philippa> you're now being a smartarse again. Insert "in general" where appropriate
14:25:14 <tlampo> Hi guys, quick question, can someone please help a newbie ? It should be pretty quick...
14:25:24 <Cale> tlampo: for sure
14:25:25 <Philippa> because you appear to've been arguing that all haskell values are states
14:25:31 <RyanT5000> that's correct
14:25:38 <RyanT5000> or rather
14:25:46 <xerox> lscd: I was trying to find out a way to express a concept... now you ask me to find another one!
14:25:47 <lscd> Philippa: and in some senses, they are; it's just not how haskell defines state, but it's a legit definition which makes sense in other fields
14:25:51 <Korollary> tlampo: just ask
14:25:59 <lscd> xerox: yes, because i didn't understand the first one ;)
14:26:00 <RyanT5000> there is some system (hypothetically) of which they are a state
14:26:06 <xerox> lscd: cruel.
14:26:07 <tlampo> Cale: Thanks, I need to open a file and parse it, but I dunno how to do it... My parser already works, I just need to do that.
14:26:11 <davidhouse> Korollary: or even, return "Ask" :: Maybe String ;)
14:26:12 <Philippa> yes. You're redefining "thing"
14:26:15 <RyanT5000> no
14:26:21 <Philippa> yes you are. All things are state
14:26:25 <RyanT5000> no
14:26:33 <psi> tlampo: you can use readFile to get the contents of a file
14:26:35 <Philippa> yes. There's some system of which they're state
14:26:41 <Philippa> sorry, "a state"
14:26:45 <RyanT5000> yes
14:26:47 <Cale> tlampo: Well, I could point you at the System.IO module, which has most of what you need... you could just use something like readFile -- have you done any IO in Haskell before?
14:26:59 <Philippa> therefore according to your argument, all things are states
14:27:02 <RyanT5000> no
14:27:10 <Philippa> then you're not arguing correctly
14:27:14 <tlampo> Nope, no IO at all... I started using it just recently...
14:27:21 <davidhouse> do contents <- readFile "/path/to/file"; let parsed = parser contents
14:27:28 <Cale> do str <- readFile "myfile"; let value = parse str; print value
14:27:30 <Cale> yes
14:27:47 <lscd> tlampo: for io, i'm finding http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell to make way more sense than anything else i've seen
14:27:55 <Philippa> now, you may mean that there's some hypothetical model of the program in which values are states
14:28:04 <Philippa> in fact, I strongly suspect that's what you mean :-)
14:28:10 <xerox> Was that Guide from davidhouse ?
14:28:12 <Cale> tlampo: for the quick intro to IO in Haskell, read http://www.haskell.org/hawiki/IntroductionToIO
14:28:25 <davidhouse> xerox, nope
14:28:29 <tlampo> thanks guys, you've been great help, I'll go try that... (Saving webpages on my favorites)
14:28:35 <xerox> Oh, sorry davidhouse.
14:28:43 <tlampo> Thanks a lot...
14:28:49 <RyanT5000> ok, a state is the position of a given system at a given point in time
14:28:52 <Cale> tlampo: you'll probably find it rather different from most programming languages at first, but it's really just like a little imperative sulanguage
14:28:54 <davidhouse> xerox, hey, when people assume i've written cool stuff i don't object ;)
14:28:59 <Cale> sub*
14:29:01 <xerox> davidhouse: <blink>
14:29:01 <Philippa> right. Pure functions *don't have a point in time*
14:29:11 <RyanT5000> right
14:29:15 <xerox> I was saying that!
14:29:25 <davidhouse> wha?
14:29:29 <Cale> nor do pure values
14:29:33 <RyanT5000> right
14:29:42 <xerox> davidhouse: talking about dimensions of Haskell modules, that is (-;
14:29:42 <RyanT5000> the state doesn't encapsulate the point in time
14:29:51 <lscd> hm, so i guess temporal logic is meaningless with them? [random digression]
14:29:57 <RyanT5000> you can be in the same state more than once
14:30:09 <Philippa> yes. But the system under discussion *doesn't have a notion of time*
14:30:38 <davidhouse> xerox, i'm very confused right now.
14:30:56 <RyanT5000> alright, then it doesn't have a state, so it isn't stateful
14:31:17 <Philippa> right. So now to show that haskell values are all states you're back to arguing that things are all states
14:31:28 <Philippa> because there's some hypothetical system somewhere in which they are
14:31:47 <RyanT5000> sure; anything can be the state of some system
14:32:09 <RyanT5000> now if you say something is "a state of this system", then it needs to match that system
14:32:13 <Philippa> yet earlier you were insisting that "state" isn't equivalent to "thing"
14:32:26 <RyanT5000> that's because it isn't
14:32:34 <RyanT5000> anything can be a state "of some system"
14:32:42 <RyanT5000> for some system
14:33:07 <Philippa> right. And anyone can be an evil bastard according to some ethical code, is it fair for me to insist you're all evil bastards?
14:33:38 <mahogny> lol
14:33:40 <xerox> Welcome to Philippa and the paceful examples, part 1 :-P
14:33:41 <RyanT5000> i'm not generalizing from an example
14:33:46 <Philippa> I don't think it's fair for you to tell us that we can't say "this isn't a state" with regard to our own systems
14:33:55 <mahogny> I think you should drop this discussion before someone ends up dead :)
14:34:01 <RyanT5000> of course you can say it's not a state of your system
14:34:22 <xerox> mahogny: let us play--old fussie!
14:34:31 <Philippa> RyanT5000: note where the quotes are
14:34:35 <mahogny> xerox, :O
14:34:36 <lscd> xerox: hey, we need a voice of wisdow to ignore ;)
14:34:41 <lscd> wisdom, even
14:35:00 <Philippa> you're effectively requiring us to tag a GUID on to our conversation when you're already in #haskell
14:35:01 * lscd listens to mahogny and heads back to code
14:35:24 <xerox> GUID?
14:35:25 <RyanT5000> Philippa you can't say something "isn't a state" in general, only that it's not a state of your system
14:35:26 <Philippa> and to go back to the original discussion, it most certainly doesn't negate the concept of 'stateful'
14:36:10 <RyanT5000> i never tried to "negate" it, depending on what you mean by "negate the concept"
14:36:24 <RyanT5000> i only said that something which was stateful was a container for a state
14:36:24 <Ulfalizer> it's pretty funny following this academic discussion while hearing some guys out in the kitchen sing a song they composed on the fly about their balls. nice contrast there =)
14:36:30 <RyanT5000> lol
14:36:39 <Philippa> no, you said it the other way round
14:36:43 <RyanT5000> absolutely not
14:37:08 <RyanT5000> give me a timestamp and i'll be happy to retract that if i infact said it
14:37:16 <Korollary> Ulfalizer: heh
14:38:00 <ruffneck> moi
14:38:14 <Philippa> [06/05 21:57] <RyanT5000> if you think of a value as a point in the statespace for its type, the distinction between "stateful thing" and "container" becomes null
14:38:20 <Philippa> same difference
14:38:30 <Philippa> hint: a list value in haskell is not stateful :-)
14:38:42 <Philippa> and is most definitely considered a container in common parlance
14:38:58 <xerox> Mumble.  That poses a problem with the notion of infinite datastructures?
14:39:08 <Cale> xerox: hm?
14:39:09 <RyanT5000> Philippa: i completely agree with that statement you just pasted of mine
14:39:20 <RyanT5000> xerox: no, they just have an infinite amount of state
14:39:26 <RyanT5000> sort of like an irrational number
14:39:43 <Cale> what?
14:39:50 <Cale> an infinite amount of state?
14:39:52 <lscd> wow. you've just made the concept of irrational numbers make my mind blow up :(
14:39:52 <RyanT5000> sorry, i was imprecise there
14:40:07 <RyanT5000> an irrational number could be the state of an infinitely large container
14:40:08 <Cale> irrational numbers have an infinite amount of state?
14:40:13 <RyanT5000> no, they are an infinitely large state
14:40:30 <RyanT5000> i spoke ambiguously
14:40:33 <lscd> what's the difference?
14:40:43 <Cale> 1/pi is pretty small
14:40:46 <Cale> hehe
14:40:48 <Philippa> RyanT5000: okay, fine. On that basis, I dispute that it's legitimate to do so
14:40:55 <RyanT5000> a number, as an abstract concept, has no state
14:41:07 <Philippa> that is, I don't think the condition of your 'if' can legitimately hold
14:41:07 <mahogny> omg. this state vs state has been going on for an hour :o
14:41:30 <RyanT5000> lol i know
14:41:33 <lscd> mahogny: the question is... it has a concept of time... is it a stateful discussion? ;)
14:41:41 <RyanT5000> yep :)
14:41:50 <xerox> Cale: let me try to rationalize what I thought.  One sec.
14:42:00 <Philippa> RyanT5000: fuck off and quit trolling, then
14:42:12 <RyanT5000> dude, i'm not trolling
14:42:20 <mahogny> Philippa goes into peaceful discussions, take #2
14:42:20 <Philippa> you sure as hell appear to be doing so
14:42:22 <RyanT5000> this is a completely legitimate disagreement
14:42:24 <lscd> Philippa: he doesn't seem like he's trolling to me
14:42:31 <SamB> did someone say something to me?
14:42:39 <Philippa> mahogny: you don't want to see non-peaceful, trust me :-)
14:42:40 <Cale> just because the decimal representation of a number is nonrepeating and nonterminating doesn't mean that the irrational number has an infinite amount of information associated with it.
14:43:02 <SamB> indeed not
14:43:07 <mahogny> Philippa, I'm afraid I use both your definitions of state, from time to time, even xerox at times, so this is more than a troll :)
14:43:10 <RyanT5000> Cale: actually, even real numbers have an infinite amount of information associated with them
14:43:12 <SamB> it could just be a root of something!
14:43:22 <Cale> 1 doesn't
14:43:25 <Cale> pi doesn't
14:43:27 <Philippa> mahogny: trolls often fire up legit discussions, it's a case of how the discussions proceed
14:43:32 <lscd> Cale: sure, but wouldn't some irrational numbers have such? [ones that can't be described in any more concise way, of which i'd expect there to be an uncountably infinate number]?
14:43:32 <RyanT5000> the only reason we can represent 1 concisely is because it's commonly used
14:43:34 <Cale> sqrt(2) doesn't
14:43:39 <RyanT5000> therefore we have "really good" compression for it
14:43:58 <Cale> lscd: there are some real numbers which are not definable
14:44:10 <RyanT5000> imagine you have to represent Integer in a constant-sized datastructure: how many bits do you needd?
14:44:13 <lscd> Cale: yes, that's what i meant by "can't be described in any more concise way"
14:44:15 <Cale> you might associate them with 'infinite information' whatever that means
14:44:21 <Philippa> and RyanT5000's still guilty of not allowing us some rather obvious implicit quantifiers on our discussion, something that's necessary for the vast majority of technical conversation
14:44:25 <SamB> lscd: you mean the uncomputable ones?
14:44:34 <lscd> SamB: i'm not sure, actually
14:44:40 <xerox> Cale: maybe you can consider the cons-link lazily unrolled of the lists |evens = 0 : map (+1) odds; odds = map (+1) evens| as 'State Int Int' by tick :: (+1).
14:44:44 <Philippa> in fact, I'd go so far as to say ignoring existing ones, like "in Haskell code"
14:44:48 <lscd> they uncomputable ones would be a subset, at least
14:45:05 <Cale> RyanT5000: a couple of bytes -- enough for a code pointer
14:45:18 <RyanT5000> Cale: it needs to be self-contained
14:45:18 <lscd> anything computable should have a more concise equivalent notation [the description of how to compute it].. i think
14:45:19 <davidhouse> RyanT5000: depends how you define information. for example, the decimal expansion of sqrt(2) is unrepeating, but we can still completely determine what it is by saying sqrt(2).
14:45:25 <Philippa> (and as I'm feeling snarky, I'd suggest that in fact the labels for the values denote different entities to those you're using as states ;-)
14:45:27 <davidhouse> the same is not true of trascentendal numbers.
14:45:36 <xerox> tick = return . (+1) -- maybe
14:45:39 <davidhouse> e.g., how would you _precisely_ measure the value of pi?
14:45:42 <SamB> if it was computable, wouldn't that mean you could write a finite computation to compute it?
14:45:52 <Cale> davidhouse: roots of polynomials are not the only way to describe irrational numbers finitely
14:46:04 <Cale> pi is computable
14:46:18 <lscd> SamB: yeah; so it seems likely to be the whole set, but it's not something i've thought of enough to be comfortable saying that
14:46:24 <xerox> You can compute the nth digit of pi without knowing the previous ones
14:46:56 <Cale> A computable real number is defined as one such that there exists a program which takes a natural number k as input and returns the binary expansion of the number truncated to k places.
14:46:56 <davidhouse> Cale, hmm, true.
14:46:58 <lscd> yeah, though that's a fairly new result
14:47:04 <lscd> [xerox's]
14:47:07 <RyanT5000> you can't express "any integer" in a finite fixed amount of space
14:47:13 * SamB tries to remember what computable means
14:47:15 <RyanT5000> nor can you express "any irrational number"
14:47:16 <lscd> RyanT5000: sure
14:47:20 <davidhouse> Cale, and are there such things as incomputable?
14:47:25 <palomer> uncomputable
14:47:26 <lscd> davidhouse: yes
14:47:27 <RyanT5000> well that means that they have an infinite amount of information
14:47:29 <Cale> davidhouse: certainly
14:47:31 <xerox> Yep!
14:47:42 <SamB> you can express any individual integer in a finite amount of space ;-)
14:47:49 <Cale> Enumerate turing machines
14:47:59 <lscd> SamB: sure, 1 bit ;)
14:48:00 * palomer cuts the nonsense floating around in this channel
14:48:11 <Philippa> RyanT5000: not chaitin information, it doesn't
14:48:35 <Cale> let u = 0. d1 d2 d3 d4... in binary expansion, where di is 0 if the ith Turing machine halts, and 1 otherwise
14:48:48 <RyanT5000> Philippa what's that?
14:48:54 <Cale> then this defines a real number, but it is not computable
14:48:55 <palomer> Cale: you're going to lose them
14:49:07 <xerox> Real numbers are creepy at times.
14:49:11 <lscd> xerox: ya
14:49:20 <Philippa> approximately speaking, the amount of information required to transmit the value. So the size of a 'program' to construct it
14:49:24 <Cale> There are more real numbers than there are definitions of real numbers.
14:49:31 <Ulfalizer> Cale: is there a numbering of turing machines?
14:49:32 * xerox takes notes
14:49:38 <Cale> Ulfalizer: certainly.
14:49:41 <palomer> Cale: depends how you enumerate them
14:49:50 <lscd> cale: what does your notation 'u = 0. d1 d2 d3 d4' mean?
14:49:53 <Ulfalizer> ok, i'm not even sure what they are when i think about it
14:49:59 <xerox> lscd: dn is the nth digit
14:50:00 <RyanT5000> Philippa: ok, let's say i have the ideal rand() function, that returns a random irrational (or rational) number
14:50:01 <palomer> you could enumerate them in a noncomputable way
14:50:04 <davidhouse> lscd, binary expansion
14:50:09 <lscd> xerox: ok, thought so, but wasn't sure; thanks
14:50:11 <davidhouse> like decimal expansion, but in binary.
14:50:11 <Philippa> RyanT5000: you don't. It's not a function.
14:50:13 <Cale> lscd: that's a binary expansion, di is the ith digit
14:50:14 <palomer> in which you get the rational number 0 1 0 1 0 1 0 1 ...
14:50:16 <lscd> and the .?
14:50:26 <LordBrain> some irrational numbers are algebraic, and therefore could be represented with a finite data structure
14:50:26 <davidhouse> the "decimal" point
14:50:34 <lscd> ok, so these are all 0.x or 1.x; ok
14:50:52 <davidhouse> Cale, how are the turing machines enumerated then?
14:50:55 <Cale> LordBrain: it's more than just the algebraic ones you can represent finitely
14:50:57 <xerox> lscd: they are 0.a_sequence_of_0_and_1
14:50:58 <RyanT5000> Philippa: are you invoking the heisenberg uncertainty principle?
14:51:00 <LordBrain> yeah
14:51:01 <Philippa> RyanT5000: I can give you a family of them in a sequence if you want though
14:51:13 <Philippa> no, I'm invoking the "mathematical definition of function doesn't allow that" principle
14:51:22 <Cale> davidhouse: lexicographically -- pick a good language for expressing them on a finite alphabet
14:51:25 <Philippa> 'program' here implies function
14:51:25 <LordBrain> but those give a ready example.... the thing is, you cant represent them all finitely...
14:51:29 <lscd> xerox: oh...... oops. right. i somehow got mixed up and thought he said u., instead of 0., and that u was if the turing machine halted or not
14:51:36 <Philippa> you don't get any IO
14:51:44 <RyanT5000> Philippa: fine, then rand :: StateOfTheWholeUniverse -> (Number, StateOfTheWholeUniverse)
14:51:48 <SamB> f(x) == f(x), always!
14:51:58 <bolrod> you sure?
14:51:59 <Philippa> then you don't have a program that constructs a number any more
14:52:00 <RyanT5000> think "hardware random number generator with infinite entropy"
14:52:10 <Cale> davidhouse: actually, I'd better say, by size first, then lexicographically
14:52:13 <SamB> and the double equals sign is just habbit
14:52:26 <RyanT5000> Philippa: i don't care
14:52:29 <LordBrain> you could probably use nonstandard analysis to prove that some irrationals arent representable with a finite set
14:52:31 <Cale> there are only countably many finite strings on a finite alphabet
14:52:32 <Philippa> you have a program that constructs a means of getting a number from a StateOfTheWholeUniverse
14:52:37 <SamB> RyanT5000: that isn't a function, silly ;-)
14:52:41 <Philippa> which isn't relevant as regards chaitin information
14:52:45 <lscd> Cale: up to a fixed length, yes
14:52:46 <LordBrain> i havent tried....
14:52:49 <xerox> Cale: what is the size of a turing machine?  If it's what I think, there are infinite ones with the same size.
14:52:53 <Cale> lscd: no, all of them
14:53:04 <Cale> There's a countable infinity of them
14:53:06 <LordBrain> and i dont know off hand if anyone's done it
14:53:09 <lscd> Cale: hm, really? my professor told me the opposite on wednesday. heh
14:53:15 <xerox> Ah, I see.
14:53:19 <Philippa> (you /do/ need to define chaitin info wrt some encoding of a particular language, but IO's not part of it)
14:53:21 <lispy> ah, countable infinity..
14:53:23 <Cale> lscd: not counting infinite strings here
14:53:32 <xerox> If some conversation wants to overflow in #haskell-overflow
14:53:32 <LordBrain> actually it might not be as easy as i thought
14:53:34 <Cale> just arbitrarily long ones
14:53:36 <lscd> Cale: sure, but finite can be arbitrarily long
14:53:38 <xerox> Just do it.
14:53:39 <LordBrain> hmmmm
14:53:39 <RyanT5000> Philippa: i was talking about how to get the number to encode
14:53:42 <davidhouse> lispy, heh, /me tries counting to infinity
14:53:43 <LordBrain> yeah
14:53:45 <Cale> lscd: right
14:53:48 <RyanT5000> not how to encode it
14:53:52 <lscd> there's no maximum integer, or maximum string length
14:53:54 <Philippa> RyanT5000: ah, sorry, my bad
14:54:00 <Cale> It's a countable union of finite sets, and that's countable
14:54:01 <xerox> Overlapping heavy discussions are hard to keep track of
14:54:01 <bolrod> infinity might be closer then you think!  look out for it
14:54:01 <lscd> the integers are countably infinite, iirc
14:54:09 <Cale> lscd: yes
14:54:09 <LordBrain> i think its not too difficult, if we allow the axioms of internal set theory
14:54:11 <RyanT5000> i'm saying "i pick a completely arbitrary irrational number out of thin air"
14:54:14 <lscd> ah... right, it's countable, but it's infinite
14:54:16 <lscd> ok, thanks
14:54:18 <RyanT5000> how do you encode that in finite space?
14:54:28 <RyanT5000> i contend that you cannot
14:54:32 <Cale> Let x be an element of Q.
14:54:33 <Philippa> and you can't
14:54:34 <RyanT5000> with any encoding
14:54:41 <mahogny> RyanT5000, let b <- R union Air? :)
14:54:43 <RyanT5000> therefore it has an infinite amount of associated information
14:54:49 <RyanT5000> lol
14:54:59 <Philippa> depends on your metric
14:55:10 * xerox should focus....
14:55:14 <RyanT5000> metric: how long the best possible encoding is
14:55:16 <RyanT5000> in bits
14:55:16 <xerox> Have fun (-:
14:55:16 <LordBrain> hmmmmmmm... it might leave something up to interpretation tho
14:55:26 <mahogny> xerox, seems to be they already have :)
14:55:35 <Cale> RyanT5000: I could give the axioms for ZFC, define the real numbers, and then express the statement that the free variable x is an element of them.
14:55:44 <Cale> and I could do that in finitely many symbols
14:55:49 <LordBrain> axiom of choice might give you that tho.. irrational numbers that cannot be finitely represented
14:55:55 <RyanT5000> ZFC?
14:56:09 <Cale> Set theory.
14:56:12 <RyanT5000> oh yeah one other constraint: the encoding itself cannot be defined wrt the value
14:56:13 <davidhouse> RyanT5000: the standard axiomisation of set theory
14:56:18 <isaacd> http://en.wikipedia.org/wiki/Zermelo-Fraenkel_set_theory
14:56:29 <lscd> isaacd: thanks for the link; this is a totally new area to me
14:56:34 <RyanT5000> otherwise you just say "0 always represents the value you just gave me"
14:56:41 <davidhouse> (beyond naive set theory that is)
14:56:48 <mahogny> reminds me... "you are my witnesses; he insinuated that ZFC is superiour to type theory". for those of you who have seen that one :)
14:56:57 <Philippa> RyanT5000: assuming you don't play silly buggers with the ordering and go with constructive mathematics, then for the natural numbers 1 is less info than 2 and 0 is less than 1. Then the fun starts as you get into number theory
14:56:59 <lscd> mahogny: reference? ;)
14:57:00 * Ulfalizer needs a ladder
14:57:04 <mahogny> lscd, lemme google
14:57:10 * bolrod gives Ulfalizer a ladder
14:57:20 <Philippa> (and into 'how much does it cost me to define +, * etc?')
14:57:35 <RyanT5000> Philippa that's only because our axioms allow for a lot of (an infinite amount of) compression of 0, 1, etc.
14:57:39 <RyanT5000> they're "familiar"
14:57:54 * Ulfalizer uses the ladder to duct tape his router to the facade outside his room
14:57:57 <mahogny> lscd, http://shemesh.larc.nasa.gov/images/humor-zfc.jpg
14:58:06 <Cale> RyanT5000: 0 and 1 are defined by our axioms -- they're not something to be compressed
14:58:07 * Korollary sings about his balls
14:58:17 <Philippa> RyanT5000: Given that it's a property of every axiomatisation of the natural numbers I've seen, I'm tempted to say it's intrinsic to them
14:58:18 <RyanT5000> Cale: the axioms are the compression
14:58:23 <LordBrain> oh yeah .. information theory... something in there could probably be used that the amount of information in some irrational numbers is unlimited.
14:58:37 <lispy> hah
14:58:40 <Cale> RyanT5000: there's nothing to compress without the axioms
14:58:40 <Ulfalizer> Korollary: i've heard too many of those already :/
14:58:41 <lispy> mahogny: nice one
14:58:41 <lscd> mahogny: hm, ok; why is it funny? how are ZFC and type theory conceptually different? [or what do they have in common?]
14:58:48 <RyanT5000> Philippa that's only relevant to the particular example i chose
14:58:53 <Cale> 1 doesn't exist until it's been defined
14:59:13 <lispy> lscd: i think it's funny that cowboys would have a conversation like that
14:59:13 <davidhouse> hmm... what's the axiomisation of irrational numbers? you can use peano for naturals, then use subtraction for integers, then ratios for rationals, but how is that extended to R?
14:59:16 <Philippa> LordBrain: not really. Same as any other encoding, by the time you've specified which encoding you're using and pinned down where in the irrational number you're after you've chewed up an equivalent number of bits anyway
14:59:21 <lscd> lispy: why? ;)
14:59:25 <mahogny> lscd, set theoy doesn't have types the same way. less strict. and other stuff
14:59:25 <Cale> davidhouse: there are two ways
14:59:27 <RyanT5000> now, if you want to really make an argument against things with infinite state, you use the planck length
14:59:35 <lscd> mahogny: hmm, ok
14:59:36 <RyanT5000> i'm not completely sure
14:59:45 <RyanT5000> what you do *with* the planck length
14:59:56 <Cale> davidhouse: by defining reals as Cauchy sequences of rationals, or by defining them as Dedekind cuts, certain sets of rationals.
14:59:56 <mahogny> LordBrain, I dare say shannon does not help you with the information here because what you're saying simply doesn't make mathematical sense
15:00:01 <LordBrain> hmmm.. i didnt quite follow you... but since i dont know much i'll take your word...
15:00:03 <Philippa> "hope like hell the universe is finite in the other direction" :-)
15:00:19 <lscd> Philippa: what? :)
15:00:24 <Ulfalizer> heh, now they're playing some weird drinking game that involves screaming "the moose is loose" when something special happens..
15:00:27 <RyanT5000> but i believe it puts an upper bound on the data in distance between two particles, assuming the universe is bounded
15:00:31 <mahogny> http://shemesh.larc.nasa.gov/images/humor-cat.gif  this gotta be one of my favourites though
15:00:45 <RyanT5000> if the universe is unbounded, then i suppose you truly do have finite systems with infinite state
15:00:48 <Philippa> lscd: infinitely big rather than allowing infinitessimally small stuff
15:00:49 <davidhouse> ah, cauchy sequences. makes sense. i suppose you could also say roots of polynomials for the algebraics, then use cauchy for everything else.
15:00:59 <RyanT5000> Philippa
15:00:59 <RyanT5000> right
15:01:00 <lscd> Cale: given that you know this stuff - what source(s) would you recommend for learning about, say, cauchy sequences and/or dedekind cuts?
15:01:04 * davidhouse remembers little about dedekind cuts and goes to wikipedia it
15:01:32 <LordBrain> hmmm... what doesnt make mathematical sense about an irrational number having no finite representation whatsoever... kind of reminds me of goedel incompleteness
15:01:34 <RyanT5000> only if you have a finite lower and upper bound, and can't count by fractions, do you have a finite amount of state in any positional system
15:01:48 <Cale> lscd: Well, have you seen "Calculus" by Spivak?
15:01:54 <Philippa> RyanT5000: to go back to the natural numbers thing, anything you can construct by computer's equivalent to some natural number
15:01:55 <mahogny> Spivak is evil
15:01:59 <Cale> lscd: it has a construction for the reals in the back
15:02:04 <RyanT5000> by "positional system", a term i just made up, i mean "a system whose state is the position of the particles in it"
15:02:17 <Cale> (And aside from that, is a really nice intro to mathematics)
15:02:18 <RyanT5000> Philippa yes
15:02:38 <mahogny> lscd, no dedekind cuts, but everything you wanted to know about functional analysis; "introduction to hilbert spaces" by mikusinski or "real analysis" by folland
15:02:47 <LordBrain> maybe a variation of godels proof could give it to us
15:02:50 <Philippa> so really, the example does matter. You do get information orderings once you start doing constructive mathematics
15:02:52 <RyanT5000> though given a finite-sized computer, you can't calculate every natural number
15:02:53 <Cale> there's lots of stuff on Cauchy sequences of reals in there -- once you've read it, generalising that to rationals wouldn't be hard.
15:03:07 <Philippa> RyanT5000: welcome to computer science. "Computer" doesn't mean that.
15:03:26 <RyanT5000> thank you Philippa, why do you think i put that qualifier in there?
15:03:34 <lscd> Cale: i haven't; i had a -really- good math teacher in hm, 10th grade who had us construct the integers, reals, etc, but i've forgotten some of that; i have essentially no math training (high school, plus -introductory- calculus, stats (bayesian), and a discrete structures course), and i've read a little online and part of godel escher bach; that's it
15:03:38 <Cale> http://planetmath.org/encyclopedia/DedekindCuts.html
15:03:48 <RyanT5000> i am quite well acquainted with notions of infinitely large/fast computers
15:03:50 <SamB> RyanT5000: so who in the world has a finite computer?
15:03:54 <Cale> lscd: I really recommend Spivak's "Calculus" then
15:03:57 <RyanT5000> SamB: everyone
15:03:59 <davidhouse> RyanT5000: sure you can. it just needs to do an infinite amount of things in a finite time.
15:04:02 <araujo> Hello
15:04:03 <lscd> Cale: ok, sweet; i'll look at it, thanks
15:04:04 <Cale> (not the same book as "Calculus on Manifolds")
15:04:07 <Philippa> Also, if you've got an output mechanism then the problem's the power supply anyway - just use the appropriate notational convention and print a lot of Succ
15:04:19 <davidhouse> which is possible if the clock speed increases in a geometric series with |ratio| < 1
15:04:23 <Cale> lscd: look at that Planetmath article I linked to
15:04:37 <RyanT5000> davidhouse: no, because it will have to start repeating states
15:04:44 <Cale> You could also axiomatically define the reals as a complete ordered field.
15:04:54 <LordBrain> hmmm hey what's this debate aabout anyway.. i walked in in the middle
15:04:58 <Cale> That actually happens to be enough to uniquely determine a field.
15:05:00 <RyanT5000> with a finite tape, even infinite time doesn't help you create a set as large as the integers
15:05:14 <SamB> you just need to upgrade the ram sufficiently!
15:05:21 <SamB> as the computer runs
15:05:22 <Ulfalizer> this book looks nice, http://www.amazon.com/gp/product/0954300696/sr=8-3/qid=1146953070/ref=pd_bbs_3/002-6132543-1594469?%5Fencoding=UTF8
15:05:24 <Philippa> nobody said "build the naturals". Just "build one of them"
15:05:35 <RyanT5000> Philippa, is there a difference?
15:05:37 <xerox> I'm very much liking Spivak's.
15:05:40 <Ulfalizer> i'm thinking of reading it this summer
15:05:43 <bolrod> RyanT5000: comparing 2 infinite things might be tricky... ? :)
15:05:47 <bolrod> who knows how infinite time is
15:05:55 <Philippa> yes. Any one natural can be constructed in finite time
15:06:11 <RyanT5000> that's right, but you just made the size of the number part of your encoding
15:06:12 <mahogny> Ulfalizer, hello there
15:06:20 <Ulfalizer> mahogny: 'lo
15:06:22 <jethr0> bolrod: well, first off it's important whether time is discreet or continuous
15:06:24 <LordBrain> has anyone else here heard of Internal Set Theory?
15:06:41 <mahogny> Ulfalizer, how's the project going? :)
15:06:43 <RyanT5000> that is, you said that the size of the computer depends on it
15:07:03 <Cale> http://www.amazon.com/gp/product/0914098896/qid=1146953169/sr=2-1/ref=pd_bbs_b_2_1/104-2381343-4747154?s=books&v=glance&n=283155
15:07:22 <jethr0> bolrod: if it's discrete and the universe is heading for a big crunch at some point, then time wouldn't be infinite at all
15:07:51 <Ulfalizer> mahogny: which one? i've been pretty busy with the school project lately.
15:08:09 <Philippa> okay, yes, I concede that one
15:08:12 <mahogny> Ulfalizer, oh several? IIRC you were quite busy with one last time I saw you :)
15:08:18 <bolrod> maybe there is some other sort of 'time' we don't know about
15:08:35 <Philippa> bolrod: an infinity of them. There's a lot of possible universe-systems out there
15:08:40 <Ulfalizer> mahogny: it's the same one. i underestimated how long it would take to finish :/
15:08:49 <Philippa> the ones we can interact with are the only interesting ones
15:08:59 <LordBrain> it adds 3 aximos to ZFC, and gives a formalism which corresponds to the intuition of a number that is for example so huge its just bigger than any number we're ever going to have a unique representation for. things like that... my brother was showing it to me a bit, its pretty cool.
15:08:59 <mahogny> Ulfalizer, well, I must say I have never overestimated the time to finish a project
15:09:14 <Ulfalizer> heh, me neither ;(
15:09:18 <mahogny> while we are at it, anyone know some really heavy reading about lambda calculus, monads and the use of cathegories (applied)?
15:09:48 <Philippa> http://www.di.ens.fr/users/longo/download.html
15:09:51 <Philippa> less so monads
15:10:00 <mahogny> thanks
15:10:08 <Philippa> because in the overall scheme of things monads are a trivial but useful toy
15:10:33 <jethr0> Philippa: supposedly HUGE gravitation waves might permeate the 13 dimensions (or whathever) of string theory and if one could use a supernova for communication that might allow inter-universe internet :)
15:10:47 <Cale> @keal
15:10:48 <lambdabot> endian mirrors the decimal
15:10:50 <Philippa> or it might just blow us up
15:10:52 <Cale> @keal
15:10:52 <jethr0> junk^(infinity+1)
15:10:53 <lambdabot> tomorrow i share next mathematical secrety
15:10:57 <LordBrain> hmm that would be cool jethr0 
15:11:02 <jethr0> yup, or that
15:11:03 <Cale> @keal
15:11:03 <lambdabot> bot defective
15:11:19 <mathewm> parseString :: Parser LispVal
15:11:19 <mathewm> parseString = do { char '"'; x <- many ( noneOf "\"" ); char '"'; return ( String x ); }
15:11:26 <lscd> Philippa: why do you say they're a trivial but useful toy?
15:11:30 <jethr0> although i see some problems with modulating nova-sized events. this technology (if feasible) might still be a few years off
15:11:42 <mathewm> How can I make parseString handle escape sequences?
15:11:47 <Philippa> lscd: "toy" was maybe a little OTT. But they're a pretty simple construction
15:11:49 <Ulfalizer> at least i've been clever enough to get to work on the ALU (we're designing a microprogrammed cpu) lately. the good thing about working on the ALU is that regardless of how f*cked up the rest of the architecture becomes, the ALU is pretty easy to adapt =)
15:12:10 <lscd> Philippa: hm, mind passing me a link or 3 which explain them?  they're the part of haskell that utterly baffles me at present
15:12:28 <RyanT5000> Philippa: i'm sorry to have pissed you off so much during this debate, but i assure you that was never my goal; thanks for discussing this at such great length
15:12:35 <Cale> Monads are a "toy" much like mathematics as a whole is a "toy"
15:12:50 <jethr0> Ulfalizer: i've been wanting to build a microprogrammed cpu for a long time now. how wide are your registers/bus and how much time does it take (in orders of magnitude :) ?
15:12:51 <Philippa> lscd: I'm a bit tired to go fishing usefully at the moment. They're a lot more trivial in the category-theoretical sense than they are in a "shit, I'm learning haskell and I just got dumped with these" kinda way
15:13:05 <lscd> Philippa: hm, ok
15:13:11 <RyanT5000> Cale: i think what Philippa means is that monads represent a relatively simple kind of computation, in the grand scheme of things
15:13:17 <Philippa> RyanT5000: no
15:13:25 <RyanT5000> ok, then not
15:13:36 <RyanT5000> what did you mean?
15:13:42 <bolrod> False!!
15:13:45 <Philippa> "the structure's simple", more or less
15:13:48 <jethr0> monads are overrated by newbies and under-used by the savvy :)
15:13:48 <davidhouse> lscd, i recommend firstly http://en.wikibooks.org/wiki/Programming:Haskell_monads then http://www.nomaware.com/monads/html/index.html
15:14:00 <RyanT5000> ah
15:14:09 <LordBrain> they're under-used?
15:14:19 <LordBrain> meaning... they should be used more?
15:14:21 <Philippa> jethr0: insofar as there's a lot more could be exploited, yeah
15:14:32 <Cale> They emcompass everything that most people would be willing to call a "computation", but the more abstract something gets, usually the simpler it becomes, and monads are pretty abstract, so there's not much to them.
15:14:33 <Philippa> but sometimes you need to get something done right here right now
15:14:49 <Philippa> complexity-wise, I suspect linear equations are more involved
15:14:50 <Cale> The complication with learning about monads is in the examples.
15:15:08 <LordBrain> what do you  mean Cale?
15:15:13 <Ulfalizer> jethr0: we're using vhdl/verilog and cpld:s. depends on how advanced you want to be, but a week or so for a pretty simple cpu is reasonable. we only have 8 bit wide buses and registers.
15:15:14 <davidhouse> i'd like to see support for more non-monad things in haskell, for when the full power of a monad isn't required
15:15:17 <Philippa> quadratics almost certainly are
15:15:23 <Cale> Monads as a general concept are very very simple.
15:15:42 <Philippa> davidhouse: the problem's usually more when the full 'power' of a monad stops you enforcing important invariants
15:15:44 <Cale> But the examples of monads can be complicated.
15:16:03 <Philippa> true. I guess polynomials're probably a more appropriate concept to compare to
15:16:16 <jethr0> Ulfalizer: hmm 8bit is probably more than i was going for. if only soldering memory from transistors/flipflops weren't so much work...
15:16:32 <lscd> davidhouse: thanks
15:16:34 <davidhouse> Philippa: such as?
15:16:35 <Cale> Philippa: Well, it's not that far off -- join is sometimes likened to multiplication :)
15:16:59 <Philippa> davidhouse: "no input-dependant higher-order computations"
15:17:09 <Ulfalizer> jethr0: heh, we use memory ic:s
15:17:14 <LordBrain> hmm.. abstract things get right to the heart of it and are simple yet are often more difficult for people to grasp necessitating concrete examples to illustrate it which unfortunately are more complicated...
15:17:15 <Philippa> (Arrows let you enforce that one)
15:17:32 <Ulfalizer> oh, never mind, misread what you said :)
15:17:48 <araujo> hi!
15:17:58 <Ulfalizer> or maybe i didn't. we don't need to do much soldering anyway.
15:18:57 <jethr0> Ulfalizer: i'd love to attach some kind of periphery to my cpu, but if it's going at 1Hz there might be timing issues
15:21:45 <Ulfalizer> jethr0: you'd probably attach it to the pci bus or something like that (if you're thinking ordinary pc hardware). it might be easier to work with some other architecture if you're just after learning though.
15:22:12 <jethr0> Ulfalizer: how many registers will you have. i really wonder how many registers you need to "emulate/execute" pc binaries. 2-3 + some counters and pointers i guess
15:22:55 <Ulfalizer> we have a risc architecture with 4 general-purpose address/data registers
15:22:56 <jethr0> Ulfalizer: no, i meant simple periphery like a floppy drive, a flash disk, an lcd screen, some kind of input (like toggles)
15:23:11 <jethr0> nice, that's far more advanced than what i had in mind. way to go
15:23:32 <Ulfalizer> it's not as advanced as it sounds. it's for a school project :)
15:25:41 <Philippa> RyanT5000: meant to say this earlier and got distracted - thanks for the apology and sorry if I'm being overly cranky myself. Not had a fun few days
15:26:07 <Philippa> and glad to've been illuminating - will try not to do it with a tacnuke next time
15:26:16 <Ulfalizer> you should probably start with reading some book on pc hardware if you're after constructing things like that..
15:27:16 <jethr0> Ulfalizer: i'm quite familiar with the "theory". we had a very good lecture about it. it's just that i'm too lazy and not very comfortable with soldering electronics.
15:29:04 <Ulfalizer> me neither. i'm looking to improve my knowledge on the electronics side though.
15:30:19 <Ulfalizer> i have a pretty good grasp of the digital part of it
15:38:44 <palomer> @seen Cale 
15:38:44 <lambdabot> Cale is in #haskell. I last heard Cale speak 22 minutes and 9 seconds ago.
15:39:48 <lscd> heh. lambdabot is impressive
15:40:43 <isaacd> > (++ error "leaving") . concat . intersperse "... " . map show $ [10,9..0]
15:40:44 <lambdabot> Exception: leaving
15:40:48 <isaacd> :/
15:41:16 <davidhouse> > take 20 [10,9..]
15:41:17 <lambdabot> [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
15:41:21 <davidhouse> > take 20 [10,9..0]
15:41:22 <lambdabot> [10,9,8,7,6,5,4,3,2,1,0]
15:43:26 <jethr0> good nite
15:48:00 <palomer> Cale: I've been thinking, we'd need to adopt this kind of syntax: term = Fixpoint ( \x -> term >> stack <|> factor )
15:48:15 <palomer> and then I have no idea how we'd rewrite the left recursion
15:48:52 <palomer> err
15:49:03 <palomer> make that Fixpoint ( \x -> x >> stack <|> factor )
15:49:22 <palomer> that would be A = A stack | factor
15:53:07 <Philippa> palomer: can I have more details of what you're doing?
15:53:26 <Philippa> (if you can write that and all equivalents point-free that might get you something?)
15:55:19 <LordBrain> >:t [1,5, .. ]
15:55:36 <LordBrain> guess he dont do the colon commands
15:55:58 <xerox> LordBrain: [1,5..]
15:56:07 <LordBrain> oh
15:56:11 <xerox> Ah, no, it doesn't.
15:56:21 <xerox> > typeOf [1,5..]
15:56:22 <lambdabot> Add a type signature
15:56:26 <xerox> Urgh (-:
15:56:56 <LordBrain> maybe we're not supposed to use the >
15:57:06 <LordBrain> maybe its a different triggor to get the type
15:57:10 <xerox> @type [1,5..]
15:57:11 <lambdabot> forall a. (Num a, Enum a) => [a]
15:57:17 <LordBrain> there you go
15:57:18 <xerox> Sure, but it now does do some clever things.
15:57:26 <xerox> > map toLower
15:57:26 <mahogny> Ulfalizer, you should make a lava to vhdl-compiler :)
15:57:27 <lambdabot> <[Char] -> [Char]>
15:57:32 <xerox> You see? (-:
15:57:44 <LordBrain> did you write him?
15:57:53 <LordBrain> are you the lambdabot creator?
15:58:20 <Korollary> @where lambdabot
15:58:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:58:23 <zer0`> > map even [1..10]
15:58:24 <lambdabot> [False,True,False,True,False,True,False,True,False,True]
15:58:37 * Philippa wants arrows-like notation for a family of category classes sans any kind of 'return'
15:58:41 <LordBrain> can he do file io?
15:58:45 <Philippa> you can always recover 'return' the obvious way later
15:59:04 <Korollary> No i/o. No long running computations.
15:59:07 <sjanssen> > print "no file IO"
15:59:07 <lambdabot> No IO allowed
15:59:09 <LordBrain> if so.. that seems like an obvious security risk
15:59:18 <LordBrain> ah ok
15:59:29 <Philippa> > (return 2 >> return 3) :: IO Int
15:59:30 <lambdabot> No IO allowed
15:59:34 <sjanssen> LordBrain: lambdabot is carefully locked down
15:59:50 <xerox> Do you think it makes sense to put links in a resumÃ¨?  I mean web urls.
15:59:55 <LordBrain> thats good for whoever's server he's running on
16:00:00 <Philippa> xerox: depends what for
16:00:06 <Korollary> xerox: if it's an electronic resume, yes.
16:00:10 <zer0`> > reverse "looc si tobadbmal"
16:00:11 <lambdabot> "lambdabot is cool"
16:00:14 <xerox> Philippa: reference
16:00:18 <xerox> Korollary: yes it is
16:03:25 <Philippa> xerox: seems sensible then
16:05:22 <psi> yay
16:05:30 * psi just submitted his SoC application
16:05:41 <xerox> dcoutts/dcoutts_ - ping
16:06:28 <dcoutts> xerox, pong
16:06:54 <psi> feels good to have it out of my hands
16:07:50 <zer0`> > map (\x -> 2^x) [0..10]
16:07:51 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024]
16:08:46 <dcoutts> psi, which one did you go for?
16:09:02 <newsham> > map (2^) [0..10]
16:09:03 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024]
16:09:15 <zer0`> oh :)
16:09:23 <psi> dcoutts: gstreamer bindings, my name is Simon
16:09:50 <psi> > [0..10] >>= return . (2^)
16:09:51 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024]
16:10:41 <xerox> > liftM (2^) [0..10] -- davidhouse++
16:10:42 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024]
16:10:52 <psi> hehe
16:11:40 <newsham> > length "liftM (2^) [0..10]"
16:11:41 <lambdabot> 18
16:11:49 <newsham> > length "map (2^) [0..10]"
16:11:50 <lambdabot> 16
16:12:12 <xerox> > length "fmap (2^) [0..10]"
16:12:13 <lambdabot> 17
16:12:13 <lscd> the map version is more readable, imho
16:12:32 <psi> and less confusing :)
16:12:32 <lscd> [i don't grok liftM yet]
16:12:49 <norpan> liftM is the same as map and fmap
16:13:33 <int-e> > length "take 11 $ iterate (2*) 1"
16:13:33 <lambdabot> 24
16:13:57 <xerox> lscd: liftM f a = do { x <- a; return (f x) } = return f `ap` a = a >>= return . f
16:14:21 <newsham> norpan: are you familiar with   x <- [0..10]; return (2^x) ?
16:14:30 <dcoutts> psi, right, cool.
16:14:37 <lscd> xerox: thanks; i don't even understand half the syntax in that yet though, sorry
16:14:42 <norpan> newsham: yes?
16:15:16 <newsham> thats the list M.  liftM is making the (2^) function work in that M
16:15:18 <lscd> >>=, ., and ``, as well as do {something} =, to be specific
16:15:32 <norpan> newsham: i know this, why are you telling me?
16:15:47 <newsham> oh, i misread
16:15:51 <newsham> <lscd> [i don't grok liftM yet]
16:15:55 <newsham> s/norpan/lscd/
16:15:58 <norpan> ah
16:16:01 <norpan> then ok :)
16:16:09 <lscd> and the answer is that no, i wasn't
16:16:51 <newsham> > do { x <- [1..3];  y <- [10,100]; return (x*y) }
16:16:52 <lambdabot> [10,100,20,200,30,300]
16:17:05 <norpan> i suppose there is probably a reason why Monad is not a superclass of Functor, but I don't know it
16:17:06 <newsham> thats the list monad.
16:17:33 <metaperl> norpan: wouldnt it be the other way around?
16:17:35 <xerox> lscd: (>>=) = concatMap there.
16:18:05 <norpan> metaperl: i mean Functor a => Monad a
16:18:23 <norpan> so perhaps i mean subclass
16:18:35 <norpan> but super sounds better
16:18:41 <norpan> super == bigger
16:18:44 <norpan> contains more
16:18:48 <metaperl> yes, based on the "Monads as Containers" tutorial, that would make sense to me... but i'm not expert!
16:19:01 <xerox> norpan: you would have to instantiate Functor every time, or you couldn't instantate Monad
16:19:07 <norpan> sure
16:19:27 <norpan> is that the only reason?
16:19:52 <ihope> instance Monad a => Functor a where ...
16:20:03 <xerox> Hmmm.
16:20:40 <norpan> if you accept overlapping instances
16:20:53 <xerox> I think there was some problem, you couldn't do something
16:20:59 <ihope> Don't make anything that's already a Monad a Functor, then.
16:21:04 <LordBrain> well psi's version illustrates the list monad tho.. so it has educational value
16:21:13 <LordBrain> oops sorry i was stuck up in the scroll
16:21:44 <norpan> ihope: but you may want to handle the "fmap" function better than the default
16:22:19 <ihope> Well then, stick liftM into the class definition.
16:23:19 <norpan> otoh, you can always to that Monad a => Functor a instance yourself if you need it
16:23:37 <ihope> class Monad m where return :: a -> m a; join :: m (m a) -> m a; (>>=) :: m a -> (a -> m b) -> m b; liftM :: (a -> b) -> m a -> m b
16:24:29 <ihope> And stick all the defaults in there.
16:24:47 <norpan> well there is always a question what you should stick into the class
16:25:15 <ihope> Then instance Monad m => Functor m where fmap = liftM
16:25:26 <xerox> ihope: that's overpopulated
16:25:49 <ihope> xerox: what do you mean?
16:26:28 <xerox> ihope: return and bind are sufficient; return (?), fmap, and join too.
16:26:55 <ihope> Um...
16:27:10 <ihope> Is that bad?
16:27:29 <norpan> you may well prefer to define the list monad by join (concat) and map instead
16:27:47 <ihope> Aye.
16:27:58 <norpan> instead of the unnatural bind
16:28:56 <norpan> i don't know what the extra runtime cost of having more class members is
16:29:09 <Philippa> practically sod all
16:29:22 <xerox> It's just that bind is enough
16:29:31 <xerox> You can define fmap and join in terms of it
16:29:43 <xerox> fmap = \f xs -> xs >>= return . f
16:29:44 <Philippa> as what actually gets "passed" is a boxed representation of the dictionary (or in jhc, a typeid) - so that part stays at a single pointer anyway
16:29:47 <norpan> otoh you can define bind in the terms of map and join
16:29:47 <xerox> join = (>>= id)
16:29:58 <int-e> Is there a runtime cost? It's just a bigger dictionary (and the dictionary is constant and - I hope - passed by reference)
16:30:11 <Philippa> sometimes it's easier in terms of map and join, sometimes it's not
16:30:21 <xerox> Right.
16:30:24 <lscd> is there a way to check the type of a function defined in a where clause, and if so, how can it be done?
16:30:36 <ihope> lscd: what do you mean?
16:30:39 <norpan> lscd: move it outside of the where clause
16:30:55 <lscd> norpan: short of that, or adding prints to the code or something
16:31:12 <Korollary> lscd: --ddump-tc I believe dumps the types
16:31:32 <Korollary> it may be-ddump-tc
16:31:38 <lscd> ihope: i'm reading http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell and one thing it says is 'Find a way to check types of "gen_name" and "gen_size"'
16:31:56 <int-e> and having a bigger class would sometimes be a virtue. I wanted to make a state monad for (MVar x ->) - which would be naturally defined in terms of modify; the dictionary only provides get and put though.
16:32:00 <norpan> would it make things hard to move map+join into Monad?
16:33:12 <ihope> lscd: maybe typeOf would do the trick
16:33:21 <ihope> @index typeOf
16:33:22 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
16:33:27 <lscd> Korollary: dumb question: what is that an argument to?
16:33:32 <ihope> @type Data.Typeable.typeOf
16:33:33 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:34:05 <lscd> hm... the main problem i have (i think) is that the interpreter doesn't recognize, ie, gen_size; it's not defined at the top level
16:35:08 <norpan> if you want to use it from the interpretor you have to move it to the top level
16:35:37 <lscd> eh... ok, i was worried you'd say that :)
16:36:13 <gog> bye
16:36:31 <norpan> it's not quite the same thing, because functions defined with "where" can use variables from the pattern matching of the function
16:37:04 <norpan> but if you don't do that you can safely move it to the top-level (if it doesn't collide name-wise with another function)
16:37:28 <lscd> yeah, these ones don't seem to (use variables from outer scopes, or clash with anything)
16:41:17 <mahogny> question; does ghc do more optimizations if I use the ST monad that it wouldn't do, even if I wrote out essentially what it does? (but without the monads)
16:44:22 <Philippa> no, the opposite
16:44:32 <Philippa> (*but*: ST's implemented with destructive update)
16:45:25 <Philippa> of course, it's only the reference that necessarily gets destructively updated...
16:45:32 <Philippa> (so I'd have to check under the hood)
16:46:10 <Philippa> sorry, not "only the reference": it's a boxing issue
16:46:13 <dcoutts> @seen dons
16:46:13 <lambdabot> I saw dons leaving #haskell and #haskell-overflow 7 hours, 6 minutes and 18 seconds ago, and .
16:46:24 <dcoutts> and .
16:46:44 <ihope> Quite.
16:48:29 <Philippa> int-e: runtime cost of a boxed value per field :-)
16:51:55 <mcnster> greetings, can anyone tell me how to construct a value of type Int# in ghc?
16:52:18 <Igloo> 4# with extensions on
16:52:42 <Igloo> But you should avoid doing so without good reason
16:53:22 <mcnster> igloo, argh, i thought i tried n# ...
16:53:46 <mcnster> igloo, thanks again
17:06:21 <int-e> Philippa: are those put on the stack?
17:14:51 <Philippa> int-e: I'd hope storage cells didn't go on the stack. The references to them probably do
17:14:59 <ihope> Igloo: why avoid using unboxed types?
17:15:03 <xerox> ghc-6.4.2: internal error: EVACUATED object entered!
17:15:04 <xerox> o_O
17:15:22 <dcoutts> ihope, no, just avoid unboxed literals
17:15:23 <int-e> Philippa: ok. that's what I think (or hope), too.
17:15:37 <ihope> Oh.
17:15:49 <ihope> But why avoid using them?
17:16:05 <Philippa> non-portable, hacky etc etc
17:16:18 <dcoutts> almost never necessary
17:16:24 <Philippa> quite
17:17:15 <ihope> Doesn't everybody use GHC, though? :-P
17:17:27 <Igloo> Those reasons, plus harder to read and generally larger code
17:17:51 <dcoutts> and if ghc can optimise it to use unboxed stuff anyway...
17:18:04 <ihope> :-)
17:18:18 <dcoutts> so people generally only do it if they find that ghc is not doing as much unboxing as they hoped
17:18:30 <dcoutts> eg you'll see it in some low level ghc libs
17:18:51 <ihope> How can I tell where the unboxing is going on?
17:18:52 <Igloo> And if GHC isn't doing it you should generally file a bug so it does rather than doing it yourself  :-)
17:19:07 <sjanssen> ihope: -ddump-simpl when you compile
17:19:10 <Igloo> Look at the core (-ddump-simpl and friends)
17:19:43 <ihope> Ooh, fun!
17:22:51 <ihope> It doesn't make much sense, though :-P
17:29:42 <Philippa> wait 'til it's got coercions in too :-)
17:29:54 <ihope> __coerce?
17:32:04 <Philippa> I'm thinking of the stuff ala System FC
17:46:47 <dons> ?uptime
17:46:47 <lambdabot> uptime: 3 days, 20 hours, 15 minutes and 46 seconds
17:47:39 <Igloo> Yo, dons
17:48:28 <dons> hey Igloo. looks like something mysterious happened to my normal box overnight :/
17:48:42 <Igloo> Oh?  :-(
17:49:15 <dons> well, suddenly its unreachable on the network :/ but its several ks away. 
17:49:28 <dons> luckily, lambdabot was running on the box next to it. which is fine 
18:02:20 <ihope> So does GHC actually use Parsec to parse Haskell code?
18:03:09 <Cale> no
18:03:33 <Cale> I think it uses Happy.
18:03:40 <ihope> @where Happy
18:03:40 <lambdabot> http://www.haskell.org/happy/
18:10:38 <psi> have my application arrived?
18:11:49 <psi> stupid question I guess. I can see that it's registered.
18:12:29 <LordBrain> so if i have ghc installed.. that would imply i also have happy installed?
18:12:44 <Korollary> no
18:12:46 <LordBrain> or no.. since hapy is only used in the source
18:12:51 <LordBrain> to generate it
18:13:03 <psi> you don't even need happy to compile ghc if you use a release
18:13:08 <ihope> Yeah, only to generate it, I think.
18:14:28 <LordBrain> happy is apt-getable in debian tho :)
18:14:45 <lscd> and emerge-able in gentoo
18:15:08 <LordBrain> my computers are mostly too slow for gentoo
18:15:22 <LordBrain> i have one that could handle it i suppose
18:38:52 <sethk> LordBrain, you don't need to have anything to do with gentoo.  I run ghc in fedora, ubuntu, and slackware without problems.
18:39:00 <sethk> LordBrain, and debian is fine
18:39:22 <sethk> LordBrain, the binary distribution with "make all" to install works fine in all the distros I've tried
18:40:52 <dons> I thought linux ran on 33Mhz 386s? when did that stop being the case?
18:41:11 <dons> it didn't, right?
18:42:20 <lscd> it's still the case
18:42:28 <Korollary> there's linux, and there's the rest of linux.
18:42:37 <lscd> though there are many distributions you wouldn't want to run on that
18:45:51 <dons> yeah, fair enough. too much gnome gui gunk
18:46:11 <Korollary> hmp3 for the win!
18:46:47 <dons> curses forever!
18:49:59 <dons> "Sun Microsystems is changing its Java license to encourage greater adoption of Java by linux developers" perhaps they're 10 years too late on that one.
18:50:12 <araujo> dons, hello!
18:50:45 <araujo> dons, link? :-)
18:50:46 <dons> hey araujo . 
18:51:00 <araujo> dons, how it goes?
18:51:21 <Korollary> what linux developers need to adopt is another garbage collected, statically checked language.
18:51:40 <dons> oh,http://www.theregister.co.uk/2006/05/05/java_linux_licensing/
18:51:43 <araujo> hah
18:51:46 <araujo> thanks dons 
18:55:34 <lispy> Korollary: hm...any particular language in mind?
18:56:08 <dons> lispy: oh, they're all good :)
18:56:16 <dons> i say, go with ocaml.
18:57:06 <dons> languages seem always to be hampered when they come with weird license agreements, don't they. miranda, clean, java. whatever they use on windows.
18:57:27 <dons> whereas anything free is much more readily apdopted. perl, python, haskell.
18:57:53 <dons> lesson: don't encumber your new, cool language with any kind of restrictive license
18:58:18 <Korollary> unless you have a monopoly that you can use
18:58:20 <lispy> yup, BSD is a good language license
18:58:53 * astecp wonders how java could possibly be considered a failure (commercially, at least)
18:59:00 <wolverian> gpl/artistic is a nice combo, too.
18:59:04 <lispy> dons: i don't linux devs should go with ocaml, i'd rather see them go with haskell :)
18:59:25 <dons> its a failure in the OS world. it doesn't even run properly on a number of OS operating systems
18:59:32 <lispy> wait, OS devs?
18:59:44 <lispy> i thought we meant people writing applications for linux systems
19:01:59 * astecp regularly sees jvms on linux, *bsd .. in some cases I think they run better than on windows. Do you mean plan9?
19:02:27 <astecp> (sorry, I'm trolling/being trolled ... nothing to see here! ;) )
19:02:39 <dons> until last year the only way to run java on openbsd was under linux emulation
19:05:20 <lispy> i hate installing java on linux because i can't use my package manager
19:05:30 <lispy> in fact, most of my linux systems don't have java on them
19:06:02 <lispy> which is fine by me, my perception of most java programs is that they are poorly conceived
19:06:07 <AnUnusedNick> Question: In 'C' I can build overlapping data structues so I have O(log n) access to the data via a key or I can look it up in an ordered list in O(n) but likely (due to use case) O(5).  Can I do this in Haskell without maintaining 2 seperate data structures?
19:06:22 <ruffneck> I drink java
19:08:01 <Korollary> AnUnusedNick: Could you clarify what you mean by overlapping data structures?
19:08:11 <lispy> Korollary: like vector in C++
19:08:12 <dons> yeah, that part I don't understand.
19:08:54 <dons> log n lookups we use a Data.Map, O(n) we'd use a list. aand you can always convert between the two
19:09:29 <dons> and you can index into Maps too
19:10:02 <dons> in, what, log n time.
19:10:21 <dons> ?type Data.Map.lookupIndex
19:10:22 <lambdabot> forall (m :: * -> *) a k.
19:10:22 <lambdabot>         (Ord k, Monad m) =>
19:10:22 <lambdabot>         k -> Data.Map.Map k a -> m Int
19:10:35 <dons> ?type Data.Map.elemAt
19:10:36 <lambdabot> forall a k. Int -> Data.Map.Map k a -> (k, a)
19:11:11 <dons> so that does what you want, AnUnusedNick ? both log n accesss via key, and < O(n) access via an index?
19:11:25 <AnUnusedNick> Korol: Sure - I have a 'C' program that has a binary tree that I can access entries with an ID.  Sometimes I need to access the elements based on the actual data it contains (which changes regularly), so I also have a ordered, dually linked list pointing to the elements in the tree.  Now, if I want to remove an entry I have the key and use the tree (and once I find the entry, that structure has the proper pointers to maintain the
19:11:25 <AnUnusedNick> I want to get entries with the lowest data value I access the list, and pull off the head.
19:12:24 <AnUnusedNick> dons - yes, I am using a Map in my current haskell attempt, but I need to access my lowest value entry (not lowest KEY value, lowest DATA value).  So, I don't want to convert to a list plus search the list - O(2n).
19:16:17 <lispy> haskell makes it easy to create data structures and their algorithms
19:16:28 <AnUnusedNick> To put it another way: I guess I want multiple keys for a single Tree - and I want low cost for changing the 2nd key.  Am I making any sense?
19:16:34 <Korollary> AnUnusedNick: I get it.
19:16:36 <lispy> so if you can't find it in the libraries, i bet you could make one pretty easily
19:17:15 <AnUnusedNick> lispy:  I believe you - I just am NEW to haskell, figured it would be faster and better if I learn Haskell for this than complete and maintain this in C
19:19:01 <Korollary> AnUnusedNick: Data.Map as is won't let you do that. You may need to implement it yourself.
19:19:07 <lispy> that sounds like a nice datastructure, but i can't thinkof anything i've seen in haskell that could easily replace it
19:19:46 <lispy> AnUnusedNick: people here and on haskell-cafe mail list would be happy to help if you started writing such a datastructure
19:20:16 <AnUnusedNick> Korol: yes - I see that, guess I don't know where to start without pointers (pathetically - I am serious, without C pointers I really don't know how to do this).
19:20:16 <sethk> AnUnusedNick, there are additional tree structures in - what's the package that Okasaki wrote and someone else recently started maintaining?
19:20:43 <sethk> AnUnusedNick, I had the same problem when I first started working with Haskell.  It can be done  :)
19:20:44 <dons> and sure, you can share the elems of the structure between both a list and a map.
19:20:45 <Korollary> AnUnusedNick: A nice thing about haskell is that you can write C style code with pointers if you want to, so I'd say it's not worth writing it in C. Check this out: http://www.haskell.org/haskellwiki/Wc
19:21:01 <AnUnusedNick> I could read that for a start.  My first version did just what I don't want (maintained a Tree and a List with duplicate data) - I was fairly fast to program though.
19:21:02 <dons> the map and the list are just an structure of pointers to the elems , just as in C
19:21:04 <lispy> heh, speaking of java, the api for regular expressions says that \1 is a back reference to the first group, but you have to use $1 instead...geez
19:21:16 <sethk> AnUnusedNick, take a look at the red/black tree implementation in Okasaki's library, not to do what you want, but as another example of constructing trees in haskell
19:21:21 <dons> I don't see why you need to duplicate the data..
19:21:55 <sethk> dons, you know which package I'm talking about?  I can't remember the name.  Okasaki write it, and someone took it over recently, there's been activity about it on the mailing list
19:22:14 * Lemmih wishes simonpj would hang out here.
19:22:20 <dons> edison
19:22:41 <sethk> dons, right, thanks
19:22:44 <Korollary> Lemmih: SimonM can't help you?
19:24:07 <Lemmih> Korollary: Perhaps, I've got some questions about the type-checker/renamer.
19:24:27 <sethk> AnUnusedNick, I'm working on something somewhat similar to what you are talking about, although I've had to put that aside because of other stuff I'm getting paid to deliver.
19:24:55 <dons> sethk is in the delivery business
19:25:10 <dons> :)
19:25:25 <AnUnusedNick> sethk - well, I'll continue on this (not as my day job though) and see what I can come up with.  If I can come up with something I am proud of I will be sure to spread the goodness around.
19:25:30 <sethk> dons, I've had to hack on my device driver for the past couple of days.  really annoying.
19:25:39 <dons> urgh. C, eh?
19:25:46 <sethk> dons, c, c++, yes
19:26:06 <sethk> AnUnusedNick, it's actually converging somewhat with my work, so I may get back to it fairly soon.
19:26:21 <dons> there was an interesting paper I spotted a couple of days ago on prototyping microkernels in haskell, i wonder if that would be useful to you, sethk.
19:26:31 <dons> let me check..
19:26:32 <AnUnusedNick> sethk: are you here often?  I'll check back in now and then.
19:26:37 <sethk> dons, I'd certainly like to read it.
19:26:41 <sethk> AnUnusedNick, yes, fairly often
19:26:54 <Saulzar> Hmm, is there a guaranteed way of calling a haskell main function from C without foreign export stuff?
19:27:13 <sethk> dons, I'm getting to the point in this project where I need database, or at least persistent storage, and if I have time I may revive my database in haskell design.
19:28:13 <Saulzar> If that was possible I'm sure getting SDL working on windows would be a piece of cake, it's easy enough with foreign export but that requires some work from the library user.
19:36:46 <Saulzar> Interesting - this segfaults when compiled: foreign export ccall main :: IO ()
19:36:47 <Saulzar>   main = putStrLn "Hello world"
19:36:47 <Saulzar>  
19:37:10 <Saulzar> I guess it runs the wrong main?
19:39:00 <Korollary> I would guess that the real main is supposed to be the RTS' main.
19:40:38 <dons> Saulzar: you calling start_haskell, end_haskell from C ?
19:40:58 <dons>   int *p;
19:40:58 <dons>   hs_init(&argc, &argv);
19:40:58 <dons>   p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
19:41:00 <Saulzar> No, this was not using any C at all
19:41:01 <dons>   if (p == NULL)
19:41:03 <dons>           printf("failed!\n");
19:41:06 <dons>   else
19:41:08 <dons>           printf("%d\n",*p);
19:41:11 <dons>   hs_exit();
19:41:11 <dons> ah, ok.
19:41:49 <dons> the above illustrates how to call a Haskell function (hs_)eval_i) from C
19:42:37 <Saulzar> Yeah, I've figured that out. It's just that in windows SDL wraps the main as SDL_main - and I don't know how to get C to call the haskell main without getting the user to do something fancy
19:43:38 <Saulzar> I can make it work by foreign export the "main" and make a wrapper main in C
19:43:55 <Saulzar> But a user of a library shouldn't have to do that kind of thing right?
19:43:58 <glauber_sp> hi guys. I was trying to install wash and happs, but I cannot change the destination dir with ./configure. any suggestion?
19:44:31 <sethk> glauber_sp, you tried --prefix=  ?
19:50:33 <psi> @wtf IOW
19:50:35 <lambdabot> No match for "IOW".
19:50:46 <glauber_sp> sethk, yes =/
19:52:34 <sethk> glauber_sp, it has no effect?  it installs to where?
19:52:43 <glauber_sp> /usr/local
19:52:52 <glauber_sp> even with prefix setted to /usr
19:53:14 <Korollary> psi: in other words
19:53:28 <psi> ah
20:20:34 <dons> dcoutts, ping
20:53:37 <gordx> @seen kzm_
20:53:38 <lambdabot> kzm_ is in #haskell and #haskell-overflow. I last heard kzm_ speak 14 hours and 8 minutes ago.
20:58:09 <JKnecht> @seen yi
20:58:10 <lambdabot> I haven't seen yi.
21:12:24 <dons> ?yow
21:12:25 <lambdabot> FEELINGS are cascading over me!!!
21:13:21 <dons> heh
21:41:13 <lispy> @keal
21:41:14 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
21:41:33 <lispy> o O (??)
21:43:56 <dons> very keal
21:44:00 <dons> hey lispy, how's code?
21:49:12 <Lemmih> @keal
21:49:12 <lambdabot> antiparsimony were 100% correct...
21:50:05 <Lemmih> @keal
21:50:06 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
21:50:16 <lispy> dons: it's okay, hacking java at the moment for work...
21:50:45 <lispy> and i think my new dsl connection is flaky at best
21:52:28 <lispy> going to st.louis soon with the rest of my company
21:52:31 <lispy> that will be crazy
21:52:38 <lispy> never been, so it will be fun too
21:52:44 <dons> cool :)
21:53:00 <lispy> how about you?
21:53:38 <dons> hacking away on haskell, as usual :)
21:54:43 <lispy> good :)
21:55:03 <lispy> i've discovered IF you're hacking java, you can do worse than eclipse
21:55:17 <lispy> (if you recall, i'm generally an eclipse hater)
21:55:18 <dons> yeah, people say that.
21:56:15 <dons> pushing patches across the pacific can be slow at best :/
21:56:31 <dons> grr. internet! damn you!
21:56:35 <lispy> heh
21:57:44 <lispy> dons: are you familiar with the concept of assertions in programmng languages?
21:57:46 <dons> its fun to imagine my haskell patches flying out of my wireless antenna over sydney
21:57:50 <dons> sure.
21:57:56 <dons> @type GHC.Base.assert -- right ?
21:57:57 <lambdabot> forall a. Bool -> a -> a
21:58:07 <lispy> i have a juicy story about assert(); in java
21:58:11 <dons> :)
21:58:23 <dons> do tell.
21:58:34 <lispy> the compiler accepts them in your source code, but the runtime is what enforces them...and it ignores them bydefault
21:58:57 <lispy> so you add a bunch of asserts to your code and then they get ignored, and you have no clue unless you 1) know better 2) really investigate
21:58:58 <dons> huh, by default. that's weird
21:59:12 <lispy> this bit me at work
21:59:24 <dons> you have to turn them off explcitly in ghc.
21:59:42 <lispy> i thought i had checked that they run, but apparently i hadn't.  So wrote code for the last two weeks thinking my assertions were checking my class invariants...they weren't
21:59:56 <dons> ah.
21:59:59 <lispy> i was hitting some really weird bugs
22:00:00 <Saulzar> Usually it's done by compiler optimisations, but I guess Java doesn't compile differently one way or the other?
22:00:17 <lispy> spending a lot of time tracking them down because i had certain (wrong) assumptions based on my assrts
22:01:09 <lispy> finally, i started to question my asserts and added assert(false); discovered that my asserts were ignored.  Once i turned them on, i found the bug i was hunting on the first run. and then found about 5 other bugs.
22:01:23 <lispy> @karma- java
22:01:24 <lambdabot> java's karma lowered to -1.
22:01:28 <lispy> :)
22:01:51 <dons> oh, i thought it was already lower than that..
22:02:39 <Saulzar> @karma java
22:02:39 <lambdabot> java has a karma of 4
22:03:51 <dons> well, that can't be right.
22:04:18 * Saulzar grins evilly.
22:04:32 <lispy> Saulzar: i'm guessing assert(expr); turns into if( Runtime.assertsenable && !expr) { throw new Assertion();  }
22:05:07 <Saulzar> Probably can be easily eliminated without too much runtime cost...
22:05:54 <sethk> dons, you should take advantage of the ability of a lazy language to deal with inifinity, and assign Java karma negative inifinity
22:07:59 <lispy> > 1/0
22:08:01 <lambdabot> Infinity
22:15:56 <Cale> karma java = y pred
23:32:13 <lispy> > 0^0
23:32:14 <lambdabot> 1
23:32:36 <lispy> so normally that is undefined, why does lambdabot consider it zero?
23:32:40 <lispy> > 0**0
23:32:41 <lambdabot> 1.0
23:33:10 <LordBrain> 1/0 = infinity.. implies 0*infinity = 1 (assuming division and multiplication are inverses)
23:34:11 <LordBrain> > 2/0
23:34:12 <lambdabot> Infinity
23:34:24 <LordBrain> so now 0 * infinity = 2
23:34:32 <LordBrain> therefore 1 = 2
23:36:03 <LordBrain> maybe thats why math teachers tell you 1/0 is undefined... haskell seems so mathematically literate, i'm surprised they tolerated this little equivocation...
23:37:28 <lispy> well, in the 1/0 case it's the ieee754 convention showing through
23:37:53 <Cale> 0^0 isn't normally undefined
23:38:03 <Cale> It's 0^(-1) that's undefined
23:38:17 <LordBrain> 0^0 is also
23:38:27 <Cale> 0^0 is usually 1
23:38:47 <LordBrain> 0^x as x approaches 0
23:38:58 <Cale> hm?
23:38:58 <lispy> Cale: i've always been taught that 0^0 is undefined because it would be 0^x/0^x.  Suppose x = 1, then you have division by zero
23:39:15 <Cale> lispy: that's a poor argument :)
23:39:46 <lispy> why?
23:39:58 <Cale> There are lots of good reasons to define it.
23:40:22 <lispy> dr. math even thinks it's undefined: http://mathforum.org/library/drmath/view/55764.html
23:40:22 <Cale> (and that's a pretty obscure reason not to -- those rules already have limitations on where they apply)
23:40:41 <lispy> he says it's an intermediat form
23:40:44 <Cale> n^m is the number of functions from a set of size m to a set of size n.
23:40:52 <lispy> er indeterminate
23:40:54 <LordBrain> if you have the limit x^y as (x,y) approaches (0,0), it doesnt converge, because it converges to different things depending on what path you take.
23:41:15 <Cale> LordBrain: However, for almost all paths, the result is 1.
23:41:34 <Cale> In fact, it's zero for only one line approaching (0,0)
23:41:57 <Cale> (the function is discontinuous anyway, so what)
23:42:23 <Cale> Also, you like to be able to write things like exp(x) = sum over i >= 0 of x^i/i!
23:42:35 <Cale> but without 0^0 = 1, that fails.
23:42:44 <Cale> you'd have to treat exp(0) separately
23:43:00 <LordBrain> ok
23:43:14 <lispy> same with binomial theorem
23:43:19 <Cale> There are good combinatorial reasons too
23:43:29 <lispy> (a+b)^n, what if n = 0 and, a+b = 0
23:43:29 <Cale> (and the binomial theorem is related to that)
23:43:48 <Cale> yep
23:44:12 <Cale> 0^0 is like an empty product
23:44:17 <Cale> > product []
23:44:18 <lambdabot> 1
23:44:43 <Cale> sure, it's a product of zeroes, but it doesn't matter, since there are none to multiply together anyway :)
23:44:55 <lispy> > (-1)**(0.5)
23:44:57 <lambdabot> NaN
23:45:00 <LordBrain> i think there are more than one path on the (0,0) thing.. but if you consider only straight lines... thats true.. unless i've managed to confuse myself :)
23:45:28 <lispy> mm...that should be NaRN
23:45:38 <Cale> > (-1)**(0.5) :: Complex Double
23:45:39 <lambdabot> 6.123031769111886e-17 :+ (-1.0)
23:45:47 <lispy> exactly
23:46:05 <Cale> well, approximately anyway :)
23:46:11 <lispy> > (-1)**(0.5) :: Complex Int
23:46:11 <lambdabot>  add an instance declaration for (RealFloat Int)
23:46:12 <lambdabot>   In the expression: (- 1) ** (0.5) :: Complex Int
23:46:12 <lambdabot>   In the definition of `uvp': uvp = (- 1) ** (0.5) :: Complex Int
23:46:37 <lispy> > 0 := (-1)
23:46:38 <lambdabot>  Not in scope: data constructor `:='
23:46:49 <lispy> > 0 :+ (-1)
23:46:50 <lambdabot> 0.0 :+ (-1.0)
23:47:01 <Cale> > (0 :+ (-1))^2
23:47:02 <lambdabot> (-1.0) :+ -0.0
23:47:07 <lispy> -0?
23:47:16 <lispy> ah man, lambdabot is just full of it tonight
23:47:18 <Cale> yeah, these are floating point values
23:47:23 * lispy nods
23:47:26 <LordBrain> i've seen := used a lot in gtk binding code... 
23:47:31 <Cale> IEEE floating point values have negative zero
23:47:36 <Cale> > 1/(-0)
23:47:37 <lambdabot> -Infinity
23:47:40 <Cale> > 1/0
23:47:41 <lambdabot> Infinity
23:47:56 <LordBrain> > -0
23:47:57 <lambdabot> 0
23:48:01 <lispy> > 0 :+ (-1) :: Complex Integer
23:48:01 <lambdabot>  add an instance declaration for (RealFloat Integer)
23:48:02 <Cale> > -0.0
23:48:03 <lambdabot> -0.0
23:48:09 <LordBrain> hmm
23:48:16 <lispy> so what are the instances of Complex?
23:48:24 <Cale> LordBrain: yours got defaulted to Integer
23:48:30 <lispy> why not Integer and Int
23:49:03 <Cale> lispy: the Show instance is stupid
23:49:22 <Cale> lispy: it requires RealFloat for some reason
23:49:32 <Cale> maybe so that NaN's can be reported
23:49:34 <Cale> hmm...
23:49:44 <Cale> > ((0/0) :+ 1)
23:49:45 <lambdabot> NaN :+ 1.0
23:49:53 <Cale> no, no trickery there
23:50:30 <Cale> > cis pi
23:50:31 <lambdabot> (-1.0) :+ 1.2246063538223773e-16
23:50:45 <Cale> > cis pi + 1
23:50:46 <lambdabot> 0.0 :+ 1.2246063538223773e-16
23:51:33 <lispy> so Complex Int has an instance but doesn't work with show?
23:51:39 <Cale> yeah
23:51:53 <lispy> um...that's unusual
23:52:23 * lispy makes note of things that will hopefully be improved in haskell' :)
23:52:29 <Cale> oh, no it's worse
23:52:43 <lispy> what's worse?
23:52:49 <Cale> There's a RealFloat constraint on the data declaration
23:53:09 <Cale> so you can't construct values of type Complex Int at all.
23:53:14 <lispy> ah :(
23:53:15 <Cale> (It's an empty type)
