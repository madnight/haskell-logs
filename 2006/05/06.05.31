00:00:34 <dons> i'm wondering if you can't just translate irc messages into xmms messages prior to being written to the pipe?
00:00:41 <dons> that would require very minimal changes to the bot.
00:01:25 <dons> you'd add a new readerLoop and writerLoop
00:01:39 <dons> and just insert a filter in front of the read and write
00:02:50 <dons> @seen sjanssen 
00:02:50 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
00:06:54 <ADEpt> dons: well. I could try, but i'm afraid to be lost in special positional semantics of msgParams
00:07:07 <dons> yeah. ok.
00:07:22 <dons> you seem to be making good progress already though
00:08:28 <ADEpt> dons: yesterday I tried to add type variable to Callback and LB to make them parametrized by the message type, and it was a disaster. At the point of typing Module and MODULE ghc actually dumped core on me.
00:09:01 <ADEpt> dons: so now i'm more inclined to try the "make it all look like IRC" approach, though it doesn't look neat.
00:09:26 <dons> hmm. ok
00:09:49 <dons> so there's no easy bijecton XMMS <--> IRC ?
00:10:09 <dons> feel free to clean up the Message data type too
00:10:20 <dons> having all args in a flat list isn't the safest structure
00:20:14 <ValarQ> hello dons
00:21:00 <dons> hey
00:21:54 <ValarQ> i was thinking about writing a Curses app and had a look at you musakplayer
00:22:11 <dons> cool
00:22:26 <ValarQ> is there a guide for creating .hsc files or what was needed?
00:22:36 <dons> just take hmp3, and remove the bits you don't need :)
00:22:50 <ValarQ> that would be easier...
00:23:49 <eivuokko> ValarQ, there are some docs about hsc2hs in ghc' user guide.
00:24:06 <ValarQ> yeah, but there isn't much
00:24:54 <eivuokko> I think that's all you get.  It isn't terribly complex program anyway.
00:25:00 <ValarQ> ok
00:36:33 <RvGaTe> morning...
00:58:41 <anandrd> i couldn't yet figure out the factorial thing
00:59:24 <anandrd> i implemented a new class AbstractInteger as Zero | Succ Zero | Pred Zero
00:59:50 <anandrd> and implemented methods of Eq, Ord, Num and wrote factorial :: (Num a, Ord a) => a->a
01:00:02 <anandrd> but it goes in infinite loops for all values except Zero
01:00:14 <anandrd> *, +, compare etc work perfectly
01:00:32 <anandrd> if you want, my code is at web.mit.edu/~anandrd/Public/lab3.hs
01:02:24 <sethk> someone looking for me?
01:13:30 <Saulzar> anandrd, What happens with compare 0 0 using your instance?
01:15:39 <Saulzar> anandrd, Or even compare (Succ x) (Succ y)
01:22:11 <anandrd> oops
01:22:27 <anandrd> i got stack overflow for compare zero zero
01:22:30 <anandrd> thanks
01:22:35 <anandrd> i'll fix that
01:24:51 <flux__> would the magical QuickCheck have caught that?-)
01:28:27 <Saulzar> Seems complicated way of representing integers, since you have to normalise all the time.
02:20:19 <roconnor> does (const undefined) equal undefined?
02:20:40 <dons> > const undefined == undefined
02:20:40 <lambdabot>  add an instance declaration for (Eq (b -> a))
02:20:40 <lambdabot>   In the definition of `ahn'...
02:20:46 <dons> > const undefined == undefined :: ()
02:20:46 <lambdabot>  Couldn't match `()' against `Bool'
02:21:05 <dons> well, you mean, does it diverge?
02:21:15 <dons> ?type const (undefined :: ())
02:21:16 <lambdabot> forall b. b -> ()
02:21:27 <dons> > const (undefined :: ()) 7
02:21:27 <lambdabot>  Undefined
02:21:39 <roconnor> I mean, are they substitutable in all contexts?
02:22:04 <davidhouse> > const (undefined :: ()) == undefined :: Int
02:22:05 <dons> hmm. maybe maybe.
02:22:05 <lambdabot>  Couldn't match `Int' against `Bool'
02:22:07 <roconnor> I mean, do they have the same denotation?
02:22:12 <davidhouse> > const (undefined :: ()) == (undefined :: Int)
02:22:13 <lambdabot>  Couldn't match `b -> ()' against `Int'
02:22:13 <roconnor> Not sure if those are the same question.
02:22:17 <dons> > const (undefined :: ()) 7 == (undefined :: ())
02:22:18 <lambdabot>  Undefined
02:24:28 <dons> ADEpt: how are you testing your patches? do you have a server to connect to?
02:24:28 <davidhouse> roconnor: why?
02:25:33 <dons> @quit more xmpp patches from ADEpt
02:25:59 <dons> ?version
02:26:23 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
02:26:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:26:41 <davidhouse> yay! i can't break the channel any more! :)
02:26:43 <davidhouse> > [1..]
02:26:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
02:26:50 <dons> some of you guys might have missed this earlier, haskell in the news: http://www.arnnet.com.au/index.php/id;710118083;fp;256;fpid;56736
02:27:22 <Itkovian> thx dons 
02:27:45 <dons> "The use of Haskell has given one of our sub-projects (the evolution of the kernel API into something suitable for high-security applications) a significant edge over competing projects."
02:28:02 <Itkovian> idd
02:28:05 <Itkovian> coolness
02:28:20 <roconnor> I just wrote (const undefined).  I was wondering if it just simpler to write undefined.
02:28:42 <dons> roconnor: yeah, i think so.
02:31:42 <apfelmus> Hi there! It seems that when building Hugs98, plus May 2006, the tiny HaXml-Tools don't get built, too. Is that so? At least they don't show up after make install. 
02:34:44 <dons> perhaps check if they're being built in the src dir, and just not installed?
02:37:19 <shapr> dons: Awesome! Haskell in the news!
02:39:27 <dons> :)
02:41:40 <dons> ever find you just spent an hour building ghc with the wrong build flags? i just did :}
02:45:39 <apfelmus> no, nothing. Ehr, Hugs being an interpreter, it looks like I have to runhugs them anyway? Yet their .hs source does not get installed in /usr/lib/hugs/etc
02:56:41 <pitecus> HI. Is it possible to compile an executable for windows using ghc on linux?
02:58:54 <norpan> pitecus: not without serious headache :)
03:01:24 <ADEpt> dons: most of the time i just run it in offline mode, feeding it lots of commands and checking output for regression.
03:01:36 <ADEpt> dons: since i dont always have server available
03:01:58 <pitecus> norpan, OK :(
03:02:17 <norpan> but you could try running ghc for windows in wine
03:02:29 <norpan> i have never tried it though
03:02:40 <norpan> or use something like vmware
03:02:47 <dons> ADEpt: yeah ok. its good that i added that -- very useful for test ! :)
03:03:15 <dons> pitecus: i think its probably never been done.
03:03:32 <norpan> dons: luckily the computer does most of the hard work when compiling :)
03:03:48 <ADEpt> dons: btw, lambdabot does not quit on "exit". Is it ok?
03:03:52 <norpan> re your previous comment about spending an hour
03:03:57 <dons> ADEpt: its a known bug.
03:04:05 <dons> you might want to look at fixing that too, while you're there :)
03:04:22 <dons> ADEpt: its to do with how the exceptions are thrown out of the reader/writer loop
03:04:48 <dons> and how they're caught in the runIrc'
03:04:59 <dons> if you fix it, you get lots of @karma :)
03:05:21 <dons> norpan: yeah :)
03:05:35 <ADEpt> dons: i plan to split Lambdabot.hs in several small modules, in particular - move types (like LB) out. Ok?
03:05:43 <dons> yes. that's ok
03:05:47 <dons> clean clean clean! :)
03:06:07 <dons> also, comment anything you work out, or had to work out to understand the code
03:06:38 * dons -> pizza
04:03:25 <davidhouse> jethr0_: around? got a couple of minutes?
04:24:02 <shapr> ebooks.com offered me a refund, I took it. And I sent them a link to http://www.gnu.org/philosophy/right-to-read.html
04:24:56 <shapr> I really really wanted to read that Hamming book. Digital Rights Management sucks sucks suck so much. Digital Wrongs maybe.
04:26:19 <shapr> My advice to everyone here, don't buy books, documents or any content that has any sort of copy protection. It's not worth it.
04:26:31 * yaarg nods
04:27:12 * boegel yaargs
04:27:41 <yaarg> :(
04:28:11 <shapr> Speaking of closed source stupidity, I bricked my iriver last night while trying to upgrade the firmware.
04:29:28 <shapr> I want a digital music player that runs only open source, does one exist?
04:30:26 <boegel> hmm, doubt it
04:30:38 <boegel> you killed your iriver? totally?
04:31:33 <shapr> Seems that way. I put the new firmware in the root of the device and told it to upgrade firmware. Nothing happened for twenty minutes, so I turned it off.
04:31:54 <shapr> Now it just loops  "scanning music file" -> reboot
04:32:16 <yaarg> there's this gadget http://gp2x.co.uk/
04:32:40 <shapr> I can still usb mount it, and put other firmware onto it, but it won't load the firmware file.
04:32:43 <yaarg> also i think the archos stuff is linux based
04:33:13 <shapr> Hm, I could just use my Nokia 770
04:33:24 <Stinger_> can you reset/delete the "music file"?
04:33:25 <shapr> They're selling 2gb rs-mmc cards nowadays.
04:33:28 <wolverian> shapr, neuros is open source
04:33:45 * shapr googles neuros
04:33:48 <wolverian> shapr, there's open source ipod firmware replacements, too (rockbox or something?) 
04:33:57 <shapr> I've heard of rockbox.
04:34:13 <wolverian> I have an iaudio player - not open source, but plays ogg at least.
04:34:18 <wolverian> (and doesn't require drivers)
04:34:32 <shapr> I'd really like something that's tough enough to survive a unicycle crash.
04:34:34 <wolverian> (ipod, iriver, iaudio :)
04:34:43 <shapr> My iriver played oggs...
04:35:12 <wolverian> I was going to buy an iriver, but I heard bad things about their firmware quality and update speed
04:35:32 <wolverian> I understand their players need their own software on the PC to transfer the music, too
04:36:02 <shapr> Nah, you can switch to the UMS ( usb mass storage ) firmware. But I woudn't recommend upgrading that firmware :-|
04:36:17 <wolverian> hehe. :)
04:37:02 <shapr> Stinger_: No, my only options with my iriver right now are usb mount and remove battery.
04:38:15 <Stinger_> oh so its not like the ipod where you can read and write the music db from the usb drive?
04:38:36 <shapr> I can mount the device in Linux, but then what?
04:38:45 <Stinger_> nothing in there?
04:38:46 <wolverian> I can recommend iaudio - their hardware and software are good, and they fix bugs quickly. they do not ship a durable player, unfortunately. although the iaudio g3 and 5 flash-based players do ship with see-through plastic holders, which at least keep the dirt out.
04:39:08 <shapr> Stinger_: Yeah, it's all still there. I just can't use it anymore.
04:39:13 <wolverian> okay, that's my corporate whoring of today. sorry. :)
04:40:18 <Stinger_> you might be able to force it to rebuild the music db if you delete it, or be able to repair it by some other means
04:41:01 <Stinger_> (just making suggestions, don't know if that'll actually work </disclaimer>
04:52:52 <dcoutts_> Lemmih, wondering about your hGetNonBlockingN for ByteString.Lazy
04:53:20 <dcoutts_> Lemmih, I've got a query on the api
04:54:57 <Lemmih> Yes?
04:56:39 <dcoutts_> so: hGetNonBlockingN :: Int -> Handle -> IO ByteString
04:56:49 <dcoutts_> so we giva a chunk size
04:56:54 <dcoutts_> but no max size
04:57:02 <Lemmih> Yep.
04:57:02 <dcoutts_> hGetN :: Int -> Handle -> Int -> IO ByteString
04:57:15 <dcoutts_> so you want to read as much as possible
04:57:21 <dcoutts_> which might be the whole file
04:57:40 <dcoutts_> well it would be the whole file, if we used it on a file
04:57:54 <dcoutts_> thing is this must actually be strict
04:58:01 <dcoutts_> we can't use lazy io here
04:58:04 <dcoutts_> it's unsafe
04:58:20 <dcoutts_> it's only safe to use lazy io for hGetContents
04:58:28 <dcoutts_> because that can semi-close the Handle
04:59:31 <dcoutts_> so since it must be strict I think it should have the same type as hGetN
05:00:28 <dcoutts_> Lemmih, that'd also match the existing system.IO.hGutBufNonBlocking
05:03:08 <Lemmih> If you give it the same type as hGetN then it wouldn't be different from ByteString.hGetBufNonBlocking.
05:03:28 <dcoutts_> Lemmih, well that's true
05:03:44 <Lemmih> I agree it should be strict, though. It should be a chunked version of BS.hGetBufNonBlocking, not a lazy version.
05:03:47 <dcoutts_> except that it works for Lazy.ByteString rather than ByteString
05:04:18 <dcoutts_> right, so I'm removing the unsafeInterleaveIO
05:04:22 <norpan> hey i get a sense of deja vu
05:05:08 <Lemmih> dcoutts_: And make a note in the documentation.
05:05:28 <dcoutts_> Lemmih, what kind of note? that it's strict you mean?
05:06:17 <dcoutts_> Lemmih, would you mind double checking my change?
05:07:38 <dcoutts_> in particular the bit where we decide what to do given how long the returned block was
05:07:42 <dcoutts_> that's a bit subtle
05:07:59 * dcoutts_ pastes it in #haskell-overflow
05:41:29 <vincenz> LOL -> " Of COURSE there is ten in binary, it's just represented as 1010. The word "ten" refers to the concept of the number ten ... which simply has different representations in different bases, 1010 in base 2, *31* in base 3, 10 in base 10, A in base 16, etc."
05:42:35 <cpatrick> whoops :P
05:43:00 <boegel> there are only 10 kinds of people in the world, those who know binary and those who don't...
05:43:25 <cpatrick> Unfortunately there are at least 101 people who can't figure out what ten is in ternary.
05:45:14 <vincenz> Yep, and in a recent press release, Microsoft announced they would not take a monopoly on the internet, just hte 0's and 1's
05:46:16 <boegel> :)
05:47:54 <ibid> there are only ** kinds of people: those who understand base-one numbers and those who don't
05:48:00 <norpan> wow, police have raider the pirate bay
05:48:04 <norpan> raided
05:48:12 <norpan> this will be interesting
05:48:39 <ibid> "the pirate bay"? somewhere near somalia, perhaps? pirates are active there
05:48:47 <norpan> perhaps
05:48:47 <vincenz> ibid: actually that's illegal
05:48:53 <vincenz> ibid: cause in decimal I can say 010
05:49:19 <vincenz> boegel: you going to antwerp?
05:49:23 <ibid> vincenz: which country's laws? ;)
05:49:32 <vincenz> :)
05:49:57 <vincenz> vincenzopoli
05:50:50 <vincenz> ibid: how does base-one work with decimals
05:51:11 <vincenz> ***.*** =
05:51:12 <vincenz> ?
05:51:35 <ibid> Penal Code, Section 11001001: One who uses base 1 numerals shall be sentenced to a fine or up to 1 year in prison.  If the base-1-use is aggravated when assessed as a whole, the sentence shall be imprisonment up to 10 years
05:52:20 <vincenz> ibid: in what number system?
05:52:40 <boegel> vincenz: when, why, how?
05:52:40 <ibid> vincenz: That question is answered in Section 1001 :)
05:52:51 <vincenz> boegel: dalia lama
05:52:57 <boegel> vincenz: hell no :)
05:53:10 <vincenz> hmm
05:53:13 <ibid> vincenz: base-1 is not a positional system, so decimals makes no sense
05:53:14 <vincenz> boegel: antibuddhist?
05:53:17 <boegel> vincenz: you are?
05:53:25 <vincenz> boegel: I don't know... If I had a car I might
05:53:37 <boegel> vincenz: anti-religion, although I guess buddhism is quite ok
05:53:47 <vincenz> buddhism != religion
05:53:54 <vincenz> religion implies the existence of some sort of god
05:54:12 <JKnecht> no it does not.
05:54:14 <ibid> it does?
05:54:17 <vincenz> JKnecht: yes it does
05:54:20 <apfelmus> @karma boegel
05:54:20 <lambdabot> boegel has a karma of 2
05:54:44 <ibid> religion implies the existence of something *holy*. doesn't have to be a god
05:54:54 <jethr0_> isn't base-1 the simple stick counting system? IIIIIIIIII = 10?
05:55:04 <ibid> yeah
05:55:11 <vincenz> religion Look up religion at Dictionary.com c.1200, "state of life bound by monastic vows," also "conduct indicating a belief in a divine power
05:55:20 <vincenz> notice the word 'divine'
05:55:31 <ibid> also note that dictionaries are not law :)
05:55:45 <vincenz> ibid: it continues
05:55:54 <vincenz> ibid: and it's not adictionary, it's an etymological dictionary
05:55:56 <JKnecht> in English, God refers to a person, 'divine power' does not imply a person.
05:56:02 <vincenz> http://etymonline.com/?term=religion
05:56:13 <vincenz> JKnecht: fine a divine power then
05:56:16 <ibid> religion (rɪ'lɪdʒən) n 1 belief in, worship of, or obedience to a supernatural power or powers considered to be divine or to have control of human destiny. 2 any formal or institutionalized expression of such belief: the Christian religion. 3 the attitude and feeling of one who believes in a transcendent controlling power or powers. 4 Chiefly R.C. Church. the way of life determined by the vows of poverty, chastity, and obedience entered upon by monks,
05:56:21 <jethr0_> doesn't have to be a "god" though. pantheism comes to mind or several gods or ...
05:56:24 <ibid> "Collins English Dictionary" 5th Edition first published in 2000 (c) HarperCollins Publishers 1979, 1986, 1991, 1994, 1998, 2000.
05:56:32 <vincenz> JKnecht: at least a god
05:56:34 <vincenz> erm
05:56:37 <vincenz> jethr0_: at least a god
05:56:46 <vincenz> religion Look up religion at Dictionary.com
05:56:48 <vincenz>  c.1200, "state of life bound by monastic vows," also "conduct indicating a belief in a diine power," from Anglo-Fr. religiun (11c.), from O.Fr. religion "religious community," from L. religionem (nom. religio) "respect for what is sacred, reverence for the gods," in L.L. "monastic life" (5c.); according to Cicero, derived from relegare "go through againg, read again," from re- "again" + legere "read" (see lecture). However, popular etymolog
05:56:51 <jethr0_> in pantheism there doesn't need to be a personified deity
05:57:00 <vincenz> from etymology
05:57:06 <jethr0_> *needn't
05:57:23 <norpan> let religion = storytelling in main
05:57:36 <vincenz> norpan: that's philosophy
05:57:39 <jethr0_> let religion = beliefSystem in main
05:57:46 <vincenz> philosophy >= religion
05:57:51 <ibid> whatever. it's offtopic here ;)
05:57:56 <norpan> it sure is
05:58:00 <jethr0_> bah
05:58:12 <vincenz> jethr0_: yes but a moral belief system is not a beliefsystem, or you'd call the planocisists religious too
05:58:17 <jethr0_> norpan, ibid: that's just plain censorship
05:58:18 <vincenz> erm
05:58:21 <vincenz> platonicists
05:58:23 <norpan> i belive in closures
05:58:26 <boegel> please take this to #haskell-blah people :)
05:58:38 <vincenz> or #oasis
05:58:48 <ibid> jethr0_: no, it's not
05:58:53 <jethr0_> :)
05:58:59 <ibid> jethr0_: if you think that it is, you don't know what censorship means
05:59:25 <jethr0_> ibid: i was just kidding, and we could argue that out, but that again would be off-topic
05:59:38 <vincenz> ibid: jethr0_: if you *** that it **, you don't **** what ********** means
05:59:45 <norpan> if you can find god in a haskell program, then it's on-topic
06:00:00 <ibid> jethr0_: yeah
06:00:12 <vincenz> norpan: eay
06:00:17 <vincenz> > reverse "dog"
06:00:18 <lambdabot>  "god"
06:00:23 <ibid> jethr0_: the problem with that joke is that i've met people who would have said that in full seriousness
06:00:26 <apfelmus> @hoogle god
06:00:27 <lambdabot> No matches found
06:00:37 <apfelmus> sorry guys, no gods here
06:00:39 <jethr0_> ibid: i forgot somekind of emoticon behind it, sry.
06:01:02 <vincenz> emoticons are quintessential :|
06:01:16 <ibid> jethr0_: and they might add an emoticon to take the sting out of it, but still meaning it
06:01:17 <norpan> let god = god `ultra` djinn in god
06:01:18 <jethr0_> i sometimes forget what strange people are out there that would say all kinds of stupid things wholeheartedly
06:01:20 <ibid> :)
06:01:25 <norpan> let god = god `over` djinn in god
06:01:28 <norpan> sorry
06:01:52 <norpan> there you go
06:01:58 <jethr0_> > let god = "god" in "jethr0" `asTypeOf` god
06:01:59 <lambdabot>  "jethr0"
06:02:03 <vincenz> class Philosophy a where....  class (Philosophy a) => Religion a were....  instance Philosophy Buddhism where .... instance Religion Christianity where..
06:02:14 <xerox> jethr0_ - LOL
06:02:56 <norpan> you guys sure are a nerdy bunch
06:03:01 <roconnor> ibid: *l* I just found the pirate bay news story, by checking out the wikipedia article.
06:03:15 <vincenz> norpan: yep, welcome :)
06:03:18 <ibid> roconnor: huh?
06:03:27 <roconnor> http://en.wikipedia.org/wiki/The_Pirate_Bay
06:03:57 <norpan> http://aftonbladet.se/vss/nyheter/story/0,2789,834356,00.html
06:04:08 <roconnor> ibid, oops, sorry I should have said that to norpan
06:04:19 <jethr0> they always had a very cocky attitude towards internation companies trying to sue them
06:04:28 <norpan> as they should
06:05:00 <noj> welcome to the police state sweden
06:05:16 <ibid> roconnor: http://www.washingtonpost.com/wp-dyn/content/article/2005/11/05/AR2005110500622.html?nav=hcmodule
06:05:47 <roconnor> ibid: ;)
06:06:00 <vincenz> woot
06:06:04 <vincenz> google caching rocks
06:06:27 <jethr0> norpan: partially i agree, but on the other hand nobody doubted that they fascilitated illegal activities. so i in their place would have tried to keep a low profile instead of showing off my cease-and-desist letters
06:06:29 <roconnor> vincenz: google caching is illegal.  They will be raided by sweedish police
06:06:50 <jethr0> roconnor: i'd like to laugh, but sadly we're not far from there :(
06:07:03 <norpan> jethr0: this is just what they want
06:07:12 <jethr0> the net neutrality bill might just as well forbid akamai and google caching...
06:07:16 <norpan> publicity
06:07:19 <jethr0> at least in the US
06:07:48 <norpan> did you know there is actually a political party that is running for the parliament in sweden called "the pirate party"?
06:08:10 <jethr0> yes, i read about it somewhere on their page :)
06:08:44 <roconnor> norpan: Yeah, they said that when i heard them speak.  There seemed to be a good technical reason for it I think.
06:08:56 <vincenz> did you hear about the google caravans?
06:09:07 <jethr0> but i must say that i myself am opposed to too stingent IP legislature. copyright and its cousins have imo gone far beyond what they were intended for
06:09:42 <norpan> no argument there
06:10:06 <roconnor> jethr0: http://news.bbc.co.uk/2/hi/uk_news/wales/5029070.stm
06:10:19 * vincenz shudders as he just used the term "internet penetration"
06:10:39 <roconnor> google caravans?
06:13:04 <vincenz> yeah...they stock a caravan full of servers ..park it somewhere, and have it backlinked to the super-network of google, and it would cache stuff
06:13:19 <vincenz> and then park these around the globe
06:13:45 <roconnor> reminds me of soviet missle silos, or where they just research labs?
06:13:52 <vincenz> no they're not labs
06:13:56 <vincenz> they're just stock full of servers
06:14:00 <vincenz> and harddrives
06:14:01 <vincenz> to cache
06:14:11 <vincenz> and backboned to the googlenet
06:14:15 <jethr0> roconnor: thx, i got lessig's book from the fsf for free as a member, so i know about his views :)
06:15:49 <boegel> vincenz: why put all that expensive equipment in caravans?
06:16:48 <vincenz> boegel: they can then locally cache stuff 
06:16:52 <vincenz> and feed that into the local internet
06:16:55 <vincenz> faster than any provider
06:17:40 * vincenz can't remember where he read it, I think /.
06:18:07 <roconnor> @hoogle b -> (Maybe a -> b) -> b
06:18:08 <lambdabot> No matches, try a more general search
06:18:18 <boegel> it's only a matter of time until some geek will track 'em down and steal it :) 
06:18:35 <shapr> "Never underestimate the bandwidth of a station wagon full of backup tapes hurling down the highway." -- Andrew S. Tanenbaum, Computer Networks (2003)
06:18:43 <jethr0> shapr: exactly!
06:18:48 <roconnor> @hoogle Maybe a -> b -> b
06:18:49 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
06:18:50 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
06:19:11 <roconnor> wow, and I didn't even have the right type
06:19:31 <roconnor> oh wait
06:19:33 <roconnor> I did
06:19:47 <dons> you did? well. close.
06:19:50 * jethr0 can't see how you did?
06:19:57 <roconnor> I want fromMaybe
06:19:59 <Saulzar> You had a bit of both :)
06:20:08 <roconnor> oh wait, right I was wrong
06:20:20 <roconnor> anyhow
06:20:21 <vincenz> he biggest cost that Google faces is electric power consumption given the huge amount of computing power required. Estimates of the electric power consumption required for over-250,000 servers range upwards of 20 Megawatts which could cost on the order of 1-2 million $US per month in electricity charges.
06:20:21 <dons> ?karma+ ndm -- type matching is fun.
06:20:22 <lambdabot> ndm's karma raised to 7.
06:20:43 <roconnor> vincenz: Attach a wind turbine.
06:20:51 <vincenz> roconnor: 20MW
06:21:04 <vincenz> turbines only do several hundred KW afaik
06:21:11 <vincenz> erm wind ones
06:21:28 <vincenz> roconnor: or was that a joke?
06:21:53 <roconnor> oh, I didn't reallise 20MW as so much
06:21:58 <jethr0> attach a wind turbine to the roof to salvage some of the energy lost to heat :)
06:21:59 <roconnor> vincenz: attach a nuclear reactor
06:22:15 <dons> jethr0: yeah, that's a good idea
06:22:21 <dons> funnel the hot air up out of the building
06:22:24 <dons> spinning a turbine
06:22:35 <vincenz> dons: that doesn't make sense AT ALL
06:22:37 <jethr0> 4) profit (in form of a perpetuum mobile)
06:22:45 * vincenz peers at jethr0 and dons 
06:22:47 <vincenz> CSers...
06:23:00 <jethr0> vincenz: actually it does. it just won't produce that much energy
06:23:08 <vincenz> no it doesn't
06:23:17 <vincenz> cause then your fans on your cpus need to push harder
06:23:22 <vincenz> which will suck more energy
06:23:24 <dons> vincenz: there are generators in the .au outback that use a hot glass house, with a tall funnel (i.e. 100 metres) to spin a turbine)
06:23:29 <vincenz> dons: that's different
06:23:40 <jethr0> vincenz: let's say 30% are converted directly to heat. that would be 20/3=6MW heat production
06:23:42 <dons> i know, its a joke :) but vaguely sounds plausible ;)
06:23:46 * vincenz palmslaps
06:24:04 <vincenz> jethr0: unless you want to boil your cpus
06:24:08 <vincenz> hot air is pushed away by fans
06:24:14 <vincenz> which implies that if you put some turbine on top
06:24:18 <vincenz> your fans will have to work harder
06:24:19 <jethr0> vincenz: huh? cpu fans?? you just let the hot air escape and get cold air from the outside
06:24:29 <dons> what? just let it passively rise
06:24:33 <vincenz> and it's a known fact that a generator can never produce more energy than the engine needs to create the work
06:24:38 <dons> suck in cold air at the bottom
06:24:39 <cpatrick> vincenz: could you use waste heat from CPUs to feed back into the generators?
06:24:47 <vincenz> it's a lossy system
06:24:58 <cpatrick> You'd expect that'd improve efficiency by a few percent at least
06:24:58 <earthy> ofcourse you could use the waste heat to feed back into the generators
06:25:05 <jethr0> vincenz: the perpetuum mobile part was obviously a joke. but you might produce <1MW of energy or so from the 6MW i talked about earlier
06:25:08 <vincenz> according to what you guys are saying
06:25:13 <vincenz> I just need an electrical motor and a generator
06:25:14 <vincenz> attach em
06:25:18 <vincenz> and I get free electricity
06:25:20 <earthy> no
06:25:26 <vincenz> conceptually yes
06:25:31 <jethr0> you could even use the heat directly with a sterling engine!
06:25:40 <earthy> no. you just use the electricity more efficiently
06:25:48 <earthy> as in: fewer total losses
06:25:50 <shapr> Better power supplies would help.
06:25:56 <shapr> Reversible logic would be best.
06:26:06 <vincenz> fusion is the best
06:26:20 <shapr> Direct matter to energy!
06:26:21 <vincenz> earthy: no it's not cause the air is being pushed byfans
06:26:28 <shapr> Then I can use my trash to power my computer!
06:26:32 <vincenz> http://www.iter.org
06:27:14 <earthy> vincenz: actually, the air is being pulled by fans, since the normal rise due to temperature does not provide enough convection to effectively cool the CPU's dies
06:27:18 <jethr0> shapr: that is called "waste incineration" :)
06:27:34 <vincenz> earthy: right but since air doesn't accumulate it also pushes the hot air away
06:28:02 <earthy> vincenz: actually, air can compress
06:28:07 <earthy> but, yeah
06:28:20 <earthy> otoh: do you know about turbo's on cars?
06:28:24 <jethr0> i sincerely hope no physicist will ever look at these logs ^_^
06:28:34 <vincenz> earthy: yes but I don't think it applies
06:28:38 <earthy> or even BMW's proposed steam system?
06:29:18 <vincenz> but the only solution for heat is
06:29:22 <vincenz> multicore systems
06:29:22 <earthy> actually, it does: the exhaust gas is pushed out by the engine, which in turn spins the turbo, and the turbo increases total fuel efficiency
06:29:43 <earthy> (the turbo uses the energy to push more air into the engine)
06:31:14 * vincenz thinks that we need solidstate harddrives and multicore cpus
06:31:32 <vincenz> that should make it feasible to get 1Gflop/Watt
06:32:18 <earthy> the problem with increasing performance per watt is that it takes electrons moving to perform operations
06:32:25 <earthy> and scaling down the number of electrons is tricky...
06:32:47 <jethr0> vincenz: http://www.engadget.com/2006/05/23/samsungs-q1-ssd-umpc-now-with-nand-only-2-430/
06:32:49 <shapr> AMD & Intel can already design and build CPUs that they have no hope of cooling...
06:33:01 <shapr> I'd rather reduce waste heat with reversible logic.
06:33:12 <vincenz> shapr: AMD and Intel are the wrong place to look
06:33:37 <shapr> Yeah, but multicore won't reduce heat output.
06:33:42 <vincenz> yes it will
06:33:44 <shapr> How so?
06:33:50 <vincenz> easily
06:33:54 <shapr> like how?
06:34:02 <vincenz> let me remember the formulas
06:34:10 <vincenz> assume you have one CPU at freq x
06:34:20 <vincenz> replace it by two cpu's at freq x/2
06:34:30 <vincenz> the power consumption now is 1/2
06:34:40 <vincenz> cause consumption scales quadratically with frequency
06:35:19 <Igloo> Why will they not replace it with 2 CPUs at frequency x?
06:35:23 <shapr> What causes the heat production? I've vaguely heard that it's dumping the ones.
06:35:31 <vincenz> Igloo: cause there's no need?
06:35:33 <shapr> That is, dissispating the charges.
06:35:45 <shapr> vincenz: C'mon, if that were common perception 640k would have been enough ram.
06:35:55 <vincenz> o.O
06:36:00 <vincenz> shapr: your statement makes no sense
06:36:10 <shapr> "No one will ever need more than 640k of RAM." -- Bill Gates
06:36:11 <Igloo> No, /your/ statement makes no sense
06:36:16 <vincenz> yes it does
06:36:22 * vincenz works at a research institute where the focus on such tings
06:36:26 <shapr> Actually, it doesn't.
06:36:31 <vincenz> it's a well known fact in the embedded industry
06:36:33 <Igloo> Making things faster is what CPU makers /do/
06:36:41 <vincenz> Igloo: HAH
06:36:43 <shapr> Sure, your tradeoff may be correct, I'm not arguing that.
06:36:43 <vincenz> Igloo: no it's not
06:36:47 <vincenz> Igloo: that's way past
06:36:57 <vincenz> even Intel admitted that heat dissipation is the main issue nowadays
06:37:02 <vincenz> why do you think thhey moved to multicore?
06:37:05 <shapr> But the consumer won't purchase a multicore system unless it's faster for less money.
06:37:15 <Igloo> Yes, because when they make them faster they have more heat to dissipate
06:37:20 <shapr> Right
06:37:37 <vincenz> Igloo: right
06:37:42 <vincenz> Igloo: but you're saying the same I am
06:37:48 <vincenz> reduce W/op
06:37:59 <vincenz> or alternatively
06:38:01 <vincenz> increase op/W
06:38:06 <shapr> op/W ?
06:38:11 <vincenz> 1Gop/W
06:38:11 <shapr> oh, operations per watt?
06:38:22 <shapr> Why not use reversible and clockless logic?
06:39:09 <vincenz> Igloo: the drive in pc's and consumer electronics is different, but the target is the same
06:39:22 <vincenz> and the only way to achieve that is through multicore
06:39:31 <shapr> So, what actually produces the heat? Dissipating charges, yeah?
06:39:41 <vincenz> yes
06:39:41 * shapr pokes vincenz 
06:39:44 <vincenz> amongst other things
06:39:49 <shapr> Reversible logic doesn't dissipate the charge.
06:39:53 <vincenz> nowadays there's another thing that's beccoming an increasing problem
06:39:56 <vincenz> which is leakage current
06:40:17 <vincenz> that's why multicore intels shut down a core if it overheats
06:40:22 <vincenz> or it becomes a disastrouous cycle
06:40:29 <vincenz> granted not the most efficient, but they incorporated that
06:40:43 <shapr> What's leakage current?
06:40:51 <vincenz> due to the small size of transistors
06:40:57 <vincenz> as temperature rises
06:41:04 <vincenz> there's more leakage directly from gate to base
06:41:10 <vincenz> aka migrating electrons
06:41:26 <shapr> Ah, I see.
06:41:42 <vincenz> 65 nm and below suffer this
06:42:04 <shapr> Why not use reversible logig?
06:42:06 <shapr> logic*
06:42:08 <vincenz> which explains the rise in papers regarding this
06:42:16 <vincenz> shapr: I have no idea what that is
06:42:48 <vincenz> but you assume logic to be it's idealized form, once you get to the physical aspects it's rather nasty
06:43:19 <shapr> http://www.zyvex.com/nanotech/reversible.html
06:43:45 <vincenz> that won't solve leakage afaict
06:44:27 <shapr> No, but some use of reversible logic will solve some of the heat and power problems.
06:44:30 <vincenz> and it's rather idealized basing itself purely on the law of information by Ssomething
06:44:50 <shapr> Well, turing machines are idealized too, but we use 'em :-)
06:44:51 <vincenz> I'd be happy if consumption were only that
06:45:39 <shapr> Reversible logic doesn't dump the charge for a bit.
06:46:52 <shapr> Doesn't seem too idealized to me.
06:47:29 <vincenz> that idea is based on Shannon's law of information, which atm relates not at all with the consumption of energy in cpus
06:48:46 <shapr> It relates when it comes to dumping bits (electrical charge) for every operation. That turns into heat, yeah?
06:49:26 <vincenz> no
06:49:43 <shapr> Ok, where does the heat come from?
06:49:51 <roconnor> http://r6.livejournal.com/82883.html
06:50:01 <vincenz> shannon law pertains to the minimal amount of energy required for communicating information "a bit"
06:50:25 <vincenz> the energy consumption of cpu's is related to the switching of transistors, and to a lesser degree the dissipative energy of copper wires
06:50:54 <vincenz> in shannon's model
06:50:59 <vincenz> transistors would require 0 energy
06:51:47 <shapr> How does transistor switching produce heat? By what manner?
06:53:51 <vincenz> loading and unloading of capacitances
06:54:26 <vincenz> and nowadays plain leakage
06:54:52 <shapr> Capacitance loading causes heat by... electrical resistance?
06:55:33 <vincenz> current
06:55:59 <shapr> What?
06:56:04 <vincenz> erugh
06:56:15 <vincenz> i'm not gonna explain the fundamentals of a transistor that would take too long
06:56:17 <neologism> is it just that the resistance in the transistor when its closed causes the heat just because the current is turned into it?
06:56:40 <shapr> vincenz: Point me to an url or docs, that's fine with me.
06:56:42 <vincenz> to turn on a transistor, you create a voltage difference between gate and base
06:56:57 <shapr> I have a copy of transistor fundamentals here...
06:57:03 <vincenz> voltage difference is created by accumulating electrons
06:57:06 <vincenz> at the base
06:57:14 <vincenz> when you turn off it again
06:57:18 <vincenz> these electrons stream away
06:57:19 <vincenz> aka, current
06:57:22 <vincenz> you have a V
06:57:23 <vincenz> you have an I
06:57:25 <vincenz> p = V*I
06:57:48 <shapr> "Transistor Physics and Circuits" by Riddle and Ristenbatt (c) 1958
06:59:21 <shapr> It's nice to own books that are older than I am and still useful to me.
06:59:58 <vincenz> anyone a type-inference expert?
07:06:39 <vincenz> Igloo: you might know this... basically what concerns me are toplevel declarations
07:07:02 <vincenz> Igloo: foo x = bar x... I start to type foo, but I don't know the type of bar yet
07:08:19 <Igloo> If they are mutually recursive then you would treat them as lambda-bound for typing the binding group
07:08:30 <Igloo> Otherwise you would type bar first
07:09:05 <vincenz> Igloo: so haskell pre-orders the top level declss according to the dependency graph?
07:09:06 <Igloo> The name for breaking groups up into mutually recursive components escapes me
07:09:27 <Igloo> Essentially, yes
07:09:33 <Igloo> (and not just top-level)
07:09:34 <vincenz> aha
07:09:37 <vincenz> yep that might do the trick
07:09:45 <vincenz> Igloo: yeah but I only have polymorphihsm at toplevel
07:10:07 <vincenz> right now I type monomorphically and then it's not so bad, just unify everywhere I use a func
07:15:16 * vincenz checks appel
07:15:22 <vincenz> apparently I need TyVar's and MetaVars
07:17:49 <vincenz> > let blowup i x = if i == 0 then x else head $ blowup (i-1) [x] in blowup 10 1
07:17:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:17:50 <lambdabot>   Expected ...
07:18:21 <vincenz> hm
07:18:23 <vincenz> that should type
07:19:40 <Igloo> Only if you give it a type signature
07:19:49 <vincenz> > let blowup i x = if i == 0 then x else head $ blowup (i-1) [x] in blowup 10 1 :: Int
07:19:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:19:50 <lambdabot>   Expected ...
07:19:59 <Igloo> blowup is considered lambda-bound while typing itself if you don't
07:20:07 <Igloo> Type signature for blowup
07:20:08 <vincenz> ah I see
07:20:20 <vincenz> so haskell does allow polymorphic recursion
07:20:35 <vincenz> > let (blowup :: Int -> a -> a) i x = if i == 0 then x else head $ blowup (i-1) [x] in blowup 10 1 :: Int
07:20:36 <lambdabot>  Parse error in pattern
07:21:18 <vincenz> > let blowup i x = if i == 0 then x else head $ (blowup :: Int -> a -> a) (i-1) [x] in blowup 10 1 :: Int
07:21:18 <lambdabot>  blowup :: Int -> a -> a
07:21:28 <vincenz> o.O
07:21:57 <vincenz> lambdabot bug?
07:22:43 <Saulzar> Hmm, is it reporting a function type? (Though doesn't look like that should be...)
07:22:45 <Saulzar> > id
07:22:46 <lambdabot>  Add a type signature
07:22:52 <vincenz> funky ain't it?
07:23:01 <Saulzar> > id :: Int -> Int
07:23:02 <lambdabot>  <Int -> Int>
07:24:44 <vincenz> how do I type a letbound func
07:26:26 <vincenz> @hoogle fmapM
07:26:27 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
07:26:27 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
07:28:19 <dons> hmm. that's weird. what happened there?
07:28:21 <mathewm> Anyone have a good one-sentence defn for 'lazy' - for a presentation to people new to Haskell?
07:28:46 <dons> values are only computed when their result is required
07:29:47 <dons> ah! the above is a type error, and the regexes are stripping away the error bits
07:29:56 <dons>  > let blowup i x = if i == 0 then x else head $ (blowup :: Int -> a -> a) (i-1) [x] in blowup 10 1 :: Int
07:30:01 <dons> so sort of a bug
07:30:03 <johnie> How do I specify -fno-monomorphism-restriction with a compiler pragma?
07:30:07 <vincenz> dons: it was funky tho :)
07:30:12 <dons> {-# OPTIONS ... #-}
07:30:23 <dons> yeah, it was a good one. had to think
07:30:24 <mathewm> Sure, how about a sales pitch?  like " allows you to define the structure of a program without worrying about the flow "
07:30:32 <johnie> dons: include the '-' ?
07:31:00 <dons> yep
07:31:26 <dons> mathewm: there's some good material on the 'Research' page of haskell.org, btw
07:31:42 <dons> i..e the polymorphic+higher-order = reusable, and 'why haskell matters'
07:32:15 <mathewm> dons: thanks, i'll check it out
07:32:52 * dons `fmap` sleep
07:39:39 <ihope> > [2,4..]
07:39:40 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54...
07:40:33 <vincenz> > concat . take 4 . repeat $ "ihope"
07:40:34 <lambdabot>  "ihopeihopeihopeihope"
07:40:40 <johnie> dons: thank you
07:40:53 <ihope> @localtime dons
07:40:54 <lambdabot> Local time for dons is Thu Jun  1 00:33:31 2006
07:40:59 <roconnor> 3^(2^50) is really big
07:41:11 <johnie> roconnor: bigger than Google can handle
07:41:11 <sieni_> > 3^(2^50)
07:41:15 <lambdabot> Terminated
07:41:24 <vincenz> > 2 ^ 50
07:41:25 <lambdabot>  1125899906842624
07:41:31 <vincenz> > 2 ^ 50 / 2
07:41:32 <lambdabot>  5.62949953421312e14
07:41:38 <vincenz> > (2 ^ 50) / 2
07:41:39 <lambdabot>  5.62949953421312e14
07:41:44 <vincenz> ah
07:41:53 <ihope> > 2^50 `div` 2
07:41:53 <lambdabot>  562949953421312
07:42:00 <vincenz> well 3^.. = 1 with 5e14 0's
07:42:15 <user311> what does the => mean in getAny :: (Random a) => State StdGen a
07:42:37 <ihope> user311: "(Random a) =>" means "if a is in the Random class, then..."
07:43:05 <ihope> So getAny is only a State StdGen a if a is in Random.
07:43:30 <user311> ihope: so you can call getAny on non Random types?
07:43:44 <ihope> user311: no, you can't.
07:44:10 <user311> i dont understand how you can have an if in the function signature
07:45:15 <ADEpt> it's not "if", it's "then"
07:45:48 <ADEpt> "for any type of class Random, getAny returns ..."
07:46:04 <user311> ADEpt: oh, i see
07:46:29 <user311> ADEpt: so its just narrowing down what type a can be instead of just using "a" without any type at all
07:46:42 <ADEpt> user311: it's just that getAny is not applicable to any other types, that all. Yes, you are correct
07:47:08 <Revision17> user311: it's like in java or something like foo(Vector<a extends Canvas> b)
07:47:28 * Revision17 doesn't quite recall java syntax
07:47:45 <user311> dont really know java :)
07:48:17 <Revision17> you're not missing much
07:48:25 <Revision17> ;)
07:53:39 <vincenz> Anyone know something for this
07:53:40 <vincenz> @hoogle Map a (m b) -> m (Map a b)
07:53:41 <lambdabot> No matches, try a more general search
07:54:16 <ADEpt> there were some convenience functions in Data.Map
07:55:00 <Foobar> I get this: Irrefutable pattern failed for pattern Data.Maybe.Just coming from something like this: [x|x<-[1,1000], let Just (a,b,c) = someproperty x]
07:55:28 <Foobar> I would like to get an empty list as a result, when the pattern doesn't match.
07:56:03 <resiak> try [x|x<-[1,1000], isJust (someproperty x)]
07:56:43 <Foobar> resiak: I need access to one of the variables in the tuple.
07:58:04 <resiak> I suspect you'll need to let foo = someproperty x in ifJust foo then let Just (a,b,c) = foo in blah else false
08:00:00 <resiak> or `` case someproperty x of Just (a,b,c) -> blah; Nothing -> false '' I guess
08:00:04 <Foobar> resiak: I found a better solution
08:00:10 <Saulzar> Hmm, you could do this: [x | Just x <- [1..1000], let (a, b, c) = .... ]
08:00:22 <Foobar> resiak: I did Just z<-[someproperty x y]
08:00:33 <resiak> Ah, okay.
08:00:37 <Foobar> Saulzar: Heh
08:01:47 <petekaz> I'm reading about HSP and HARP (regular expressions for pattern matching).  HARP sounds very cool, is it not used in practice?
08:03:16 * Saulzar has only heard of the joke "Haskerl" for this purpose.
08:03:31 <petekaz> http://www.cs.chalmers.se/~d00nibro/harp/
08:03:54 <Saulzar> I'm just there. :)
08:04:14 <petekaz> the example I am looking at:
08:04:15 <petekaz> data Contact = Person Name [ContactMode]
08:04:17 <petekaz> data ContactMode = Tel TelNr
08:04:43 <petekaz> If you wanted to write lastTel (to get the last Tel) you would do something like this:
08:05:00 <petekaz> (some small recursive function)
08:05:11 <petekaz> But with HARP:
08:05:19 <petekaz> lastTel (Person _ [_*, Tel nr]) = nr
08:05:50 <petekaz> Which I thought was interesting.
08:07:04 <Saulzar> I would guess people use Parser combinators (eg. Parsec) much more than regexes in Haskell
08:07:34 <petekaz> ?
08:07:39 <sjanssen_> petekaz: you're right, harp isn't used much
08:08:07 <petekaz> Saulzar: this is for pattern matching.
08:18:08 <petekaz> Haskell Server Pages look interesting.
08:19:01 <petekaz> I need some sort of haskell web framework if I'm going to sneak haskell in at work :-)
08:19:45 <yaarg> has anyone actually written anything useful in it?
08:20:39 <petekaz> I don't know, I'm just reading the thesis.
08:23:08 <vincenz> petekaz: fix:
08:23:22 <vincenz> lastTel (Person _ tels ) = unTel . last $ tels
08:23:28 <sieni_> didn't shapr have some ideas (of haskell web framework)
08:23:35 <vincenz> data ContactMode = Tel { unTel :: TelNr}
08:24:15 <vincenz> if you have different types
08:24:24 <vincenz> lastTel (Person _ tels ) = unTel . last . filter isTel $  tels
08:58:36 <cmarcelo> what's bulat ziganshin irc name?
08:59:09 <Lemmih> Does he irc?
09:00:56 <cmarcelo> I think so:  "feel free to ask us in the haskell-cafe and on IRC"
09:07:14 <Skymarshal> I have a tuple x = [(1,2,3),(2,3,4),(3,4,5)] and I want to calculate the total of the last numbers (3+4+5). How can I do this?
09:08:03 <Sentinel> > 3+4+5
09:08:03 <lambdabot>  12
09:08:12 <ulfdoz> lol
09:08:29 <ulfdoz> Skymarshal: Btw, x is not a tuple, it is a list of triples.
09:09:19 <yaarg> sounds like homework ;)
09:09:30 <vincenz> yep
09:09:55 <Skymarshal> So how can I write a function f which calculates the total of the last number in each triple?
09:09:58 <ulfdoz> > map (\(a, b, c) -> a + b + c) [(1,2,3),(2,3,4),(3,4,5)] 
09:09:59 <lambdabot>  [6,9,12]
09:10:07 <sjanssen_> @djinn (a, b, c) -> c
09:10:07 <lambdabot> f (_, _, a) = a
09:10:31 <Skymarshal> I need the total. f should be 12.
09:10:40 <vincenz> ulfdoz: nope
09:11:03 <sjanssen_> @hoogle sum
09:11:03 <lambdabot> Prelude.sum :: Num a => [a] -> a
09:11:04 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
09:11:04 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
09:11:25 <sjanssen_> @hoogle map -- the rest is up to you Skymarshal
09:11:26 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- the res'
09:11:29 <sjanssen_> pssh
09:11:33 <sjanssen_> @hoogle map
09:11:33 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:11:33 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
09:11:33 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
09:12:10 <psnl> Skymarshal: use the map, then recurse over the list to get the last elem (assuming you want to do it for a list of arbitary length)
09:12:28 <ndm> sjanssen_, thats a known bug :)
09:12:35 <ndm> @hoogle --
09:12:35 <lambdabot> HOOGLE - Haskell API Search
09:12:35 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
09:12:35 <lambdabot>  
09:12:41 <ndm> that one too :)
09:12:52 <sjanssen_> heh, that's a good one
09:13:07 <ndm> yeah, a weird interaction between a comment parser and a command line parser
09:14:01 <Skymarshal> Why isn't this working for the list [(1,2,3),(2,3,4),(3,4,5)]:
09:14:03 <Skymarshal> totalSum2 [] = 0
09:14:05 <Skymarshal> totalSum2 [(x1,x2,x3,x4,x5),xs] = x5 + (totalSum xs)
09:14:43 <Skymarshal> sorry, wrong example. I meant:
09:14:44 <Skymarshal> [(1,2,3),(2,3,4),(3,4,5)]:
09:14:46 <Skymarshal> totalSum2 [] = 0
09:14:47 <Skymarshal> totalSum2 [(x1,x2,x5),xs] = x5 + (totalSum xs)
09:15:13 <sjanssen_> Skymarshal: last line should be "totalSum2 ((x1, x2, x5):xs)"
09:15:27 <psnl> Skymarshal: can I get a peek at the question?
09:16:44 <Skymarshal> psnl: It is a tiny little part of a "big" homework. I have all the rest but got stuck with this easy one.
09:16:50 <sjanssen_> [x, y] matches a list with two elements.  (x:y) matches a list with at least one element, and binds x to the head and y to the tail
09:17:38 <psnl> Skymarshal: do you want to sum the third element of a list, or every third element?
09:18:36 <Skymarshal> psnl: every third element has to be added to the total sum.
09:19:29 <psnl> cool. then you are doing it the right way
09:20:27 <Skymarshal> all: Thanks guys! I'm taking a break.
09:21:48 <yaarg> heh
09:28:31 <MarcWeber> Which command/ lib to use to get http documents?
09:28:42 <ndm> MarcWeber: system "wget"
09:28:54 <ndm> thats the one I have had most success with
09:30:43 <vincenz> @hoogle ---
09:30:44 <lambdabot> hoogle: unrecognized option `---'
09:30:44 <lambdabot> HOOGLE - Haskell API Search
09:30:44 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
09:30:44 <lambdabot>  
09:30:44 <lambdabot> Usage: hoogle [OPTION...] search
09:30:46 <lambdabot> [15 @more lines]
09:31:01 <vincenz> ndm: any chance in getting hoogle 2.0 that will try to combine functions to the required spec?
09:31:25 <vincenz> like
09:31:37 <vincenz> @hoogle Map a b -> a -> [b]
09:31:37 <lambdabot> No matches, try a more general search
09:31:47 <ndm> vincenz: thats often requested, but has exponentiate blow up issues
09:31:55 <vincenz> maybeToList . lookup
09:32:02 <vincenz> ndm: well you can limit the search
09:32:03 <ndm> for any function, id can be combined to get another one
09:32:15 <ndm> and error . anything gives you any type
09:32:31 <vincenz> @type error .
09:32:32 <lambdabot> parse error (possibly incorrect indentation)
09:32:33 <MarcWeber> ndm: You might be right...
09:32:59 <vincenz> ndm: well you can use a heuristic to prune those possibilities
09:33:18 <ndm> vincenz: true, its a case of figuring out which functions are "simple restructuring"
09:33:24 <ndm> and which do real work
09:34:07 <vincenz> :)
09:34:43 <ndm> it has issues, especially once there are lots of functions involved
09:35:08 <ndm> i don't have a concrete design on how it could be done effectively, but if i did, i might try and add it
09:35:26 <ndm> my supervisor always complains that it doesn't do that, and that it doesn't do type isomorphisms
09:37:21 <Saulzar_> I guess a limited set would probably be reasonable, all the combinators which lambdabot's @pl uses for example
09:38:12 <Saulzar_> Though I guess if you include stuff like folds you have a massive search space
09:38:16 <MarcWeber> ndm: There is no getTempFilename, is theer?
09:38:41 <ndm> @hoogle tempfile
09:38:41 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
09:38:41 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
09:39:21 <ndm> MarcWeber: getTemporaryDirectory
09:39:27 <ndm> but no getTemporaryFilename
09:39:32 <MarcWeber> thx didn't search tags for "T"emp but tmp ;(
09:39:33 <ndm> (will add that to System.FilePath)
09:39:49 <MarcWeber> but I con copy paste from there
09:42:46 <MarcWeber> ndm: Can I try to implement it and send the patch somewhere? How to get involved?
09:43:20 <ndm> MarcWeber: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
09:43:42 <ndm> just a warning, the interface is a bit unstable - names may well change
09:44:03 <ndm> but I hope to get it into base in the future, and am working on combining in the other System.FilePath
09:44:23 <ndm> and if you can get a getTempFilename i'll definately add it in
09:46:16 <goron> In file included from /tmp/ghc6679_0.hc:5:0:
09:46:16 <goron> include/HsTime.h:4:26:
09:46:16 <goron>      error: HsTimeConfig.h: No such file or directory
09:46:34 <goron> That's what I get when I do /ghc $ make bootstrap
09:51:10 <MarcWeber> ndm: Does it make sense to determine os at runtime? Why? 
09:51:30 <ndm> MarcWeber: consider Yhc, one binary can be compiled once, then run on multiple os's
09:51:58 <ndm> hopefullyl with the right combination of rules, GHC can compile that bit away at compile time
09:52:03 <ndm> while Yhc can keep it in
09:54:48 <MarcWeber> Have't thought of that... I see
09:57:18 <MarcWeber> ndm: Let me see how its done with file IO at the moment..
10:00:11 <xerox> Cale - The videos on Linear Programming are very very nice.
10:01:03 <ndm> MarcWeber: any questions just ask, there isn't much IO in that library yet
10:01:51 <MarcWeber> ghc is using stuff like #ifdef mingw32_HOST_OS
10:06:24 <davidhouse> jethr0_: around? got a few minutes?
10:06:31 <jethr0_> yup
10:06:37 <MarcWeber>  Do you think it would be possible to distingush 
10:06:37 <MarcWeber>  a) ghc or yhc compiled
10:06:37 <MarcWeber>   1) posix  "isposix = True"
10:06:37 <MarcWeber>   2) win    "isposix = False"
10:06:37 <MarcWeber>  b) yhc "isposix = getRuntimeValue"
10:06:44 <MarcWeber>  using preprocessor flags?
10:08:33 <MarcWeber> ndm: Using libraries like gtk2hs? How would that be done there?
10:09:21 <ndm> MarcWeber: should be possible
10:10:01 <ndm> but i was trying to avoid cpp requirements for System.FilePath
10:10:03 * dcoutts_ doesn't understand how gtk2hs is related to the issue
10:10:11 <MarcWeber> ndm: What does --| Remove the extension, and any . following it   do  in case of abc.ext1.ext2 ?
10:10:21 <ndm> abc.ext1
10:10:33 <ndm> if you look at the Tests.hs, that documents some of the behaviours
10:10:47 <ndm> and aims to cover all the corner cases, although its still incomplete
10:10:49 <davidhouse> ndm, is this System.FilePath you're discussing?
10:10:55 <ndm> davidhouse: yep
10:11:06 <davidhouse> ndm, have you finished the amalgamation?
10:11:18 <dcoutts_> MarcWeber, ndm, I don't think Gtk2Hs gets involved in os-path questions really
10:11:26 <ndm> davidhouse: no
10:11:29 <MarcWeber> ah. "removes last extension" would make this more clear in the comment..
10:11:31 <ndm> its still ongoing
10:11:37 <ndm> MarcWeber: patch welcome :)
10:11:39 <davidhouse> okay. :)
10:11:53 <ndm> I need to go through the haddock documentation, making it more clear
10:12:40 <MarcWeber> ndm, davidhouse Not path.. but linking, shared libs ... Don't know .. Should the yhc program contain information how to bind to a graphic library on each system?
10:13:05 <MarcWeber> Or do you prefer same runtime environment such like Java..
10:13:14 <roconnor> @djinn [Void]
10:13:15 <lambdabot> -- f cannot be realized.
10:13:23 <davidhouse> MarcWeber: sorry, i haven't been following this discussion. what are the options?
10:13:24 <roconnor> @djinn Void -> Void
10:13:25 <ndm> MarcWeber: we want to have a Gtk2Hs program with the same API as the normal one
10:13:25 <lambdabot> f a = a
10:13:31 <roconnor> @djinn Maybe Void 
10:13:32 <lambdabot> f = Nothing
10:13:36 <ndm> which will work everywhere
10:13:45 <roconnor> Does ghc have a Void type?
10:14:03 <mahogny> roconnor, ()?
10:14:08 <dcoutts_> ndm, huh? what api as the normal what?
10:14:10 <mahogny> IO () rather
10:14:11 <roconnor> () is the unit type
10:14:28 <Philippa> roconnor: ghc allows types without any constructors IIRC
10:14:29 <roconnor> IO () has lots of inhabitants
10:14:35 <Philippa> usually used for phantom types
10:14:44 <Philippa> it's still inhabited by _|_, of course
10:14:48 <MarcWeber> davidhouse: Don't know yet ;)
10:14:49 <Cale> It used to be in the prelude
10:14:49 <ndm> dcoutts_, I am just saying we want to have Gtk2Hs working transparently without recompilation
10:14:52 <Cale> but not anymore
10:15:00 <dcoutts_> ndm, ah right, yes. Should be doable.
10:15:03 <roconnor> almost empty
10:15:05 <mahogny> roconnor, well, for a good reason. returning nothing is begging to have a nasty type
10:15:07 <Cale> but you can make your own easily enough
10:15:08 <Philippa> if you need a "true Void" you're stuck
10:15:11 <Cale> data Void
10:15:24 <Cale> (on its own)
10:15:42 <roconnor> mahogny: [Void] seems like a reasonable type to me
10:15:50 <roconnor> along with Maybe Void
10:15:56 <Philippa> it seems like a pointless type to me
10:15:57 <roconnor> Set Void
10:15:59 <mahogny> indeed
10:16:02 <Philippa> Maybe Void less so
10:16:12 <Cale> [Void] is isomorphic to Nat
10:16:15 <MarcWeber> ndm: A proper GetTmpFilename must onsure that the file doesn't exist already.. So can I use doesFileExit from System.FilePath?
10:16:30 <ndm> MarcWeber: its not in System.FilePath
10:16:33 <roconnor> Cale: [Void] is isomorphic to () [()] is isomorphic to Nat
10:16:34 <ndm> @hoogle doesFileExist
10:16:35 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
10:16:37 <Philippa> Cale: so use Nat
10:16:49 <ndm> but yes, you can use that function
10:16:58 <MarcWeber> .Directory, right.
10:17:11 <Cale> roconnor: not quite -- you can have any list of bottoms
10:17:11 <Philippa> roconnor: you can ignore the items outright. You'd be right in an ML
10:17:16 <Cale> Philippa: of course
10:17:54 <Cale> Void has one value, () has two
10:18:11 <roconnor> you people and your bottoms.  
10:18:40 <mahogny> lol
10:18:49 * mahogny casts roconnor to Void
10:18:52 <Philippa> mine's gone away for a couple of days, he's staying with his mum
10:18:59 <roconnor> mahogny: that's not safe
10:19:09 <mahogny> roconnor, true true. it wasn't meant to be :)
10:19:39 <Philippa> roconnor: sure it is, the function's equivalent to const undefined
10:20:33 <roconnor> Philippa: can't I be cast back to Person, and resume my normal self?
10:21:03 <roconnor> @type asTypeOf
10:21:05 <lambdabot> forall a. a -> a -> a
10:21:12 <roconnor> has anyone ever used this function?
10:21:12 <Philippa> depends - does your normal self have an existential crisis?
10:21:49 <Cale> Probably not since scoped type variables came along
10:22:16 <roconnor> scoped type variables?
10:22:33 <xerox> Hurray for foralls.
10:23:08 <davidhouse> roconnor: yep
10:23:21 <Cale> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
10:23:30 <davidhouse> > let pairWithEmpty xs = ([], xs) in pairWithEmpty [1..10]
10:23:31 <lambdabot>  Add a type signature
10:23:37 <davidhouse> > let pairWithEmpty xs = ([] `asTypeOf` xs, xs) in pairWithEmpty [1..10]
10:23:37 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
10:24:31 <roconnor> davidhouse: usually I just add a type signature
10:24:45 <davidhouse> roconnor: but you can't add one here.
10:24:57 <Cale> sure you can
10:26:12 <roconnor> > let pairWithEmpty xs = ([] `asTypeOf` xs, xs) in (pairWithEmpty  [1..10])::((Num a) => ([a],[a]))
10:26:12 <lambdabot>  Parse error
10:26:12 <Cale> the case where you can't add one is where there's an ambiguity inside the let and you can't add a signature to the let bindings to fix it, since you don't have a name for the type you want
10:26:26 <roconnor> hmm
10:26:51 <Cale> > let pairWithEmpty xs = ([] `asTypeOf` xs, xs) in (pairWithEmpty  [1..10]):: (Num a) => ([a],[a])
10:26:52 <lambdabot>  add (Enum a) to the expected type of an expression
10:26:52 <lambdabot>   In an arithmetic sequ...
10:26:58 <davidhouse> Cale: how can you add one here?
10:27:02 <Cale> > let pairWithEmpty xs = ([] `asTypeOf` xs, xs) in (pairWithEmpty  [1..10]):: ([Int],[Int])
10:27:03 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
10:27:07 <davidhouse> oh, right.
10:27:13 <Cale> > let pairWithEmpty xs = ([], xs) in (pairWithEmpty  [1..10]):: ([Int],[Int])
10:27:14 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
10:27:15 <davidhouse> but then that places a burden on the caller
10:27:31 <xerox> @type let f (xs::t) = ([]::t,xs) in f "hi"
10:27:32 <lambdabot> ([Char], [Char])
10:27:36 <Cale> > let pairWithEmpty :: [a] -> ([a],[a]); pairWithEmpty xs = ([], xs) in pairWithEmpty  [1..10]
10:27:37 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
10:27:42 * xerox giggles
10:27:50 <Cale> that's the other way
10:28:07 <Cale> however...
10:28:31 <Cale> > let pairWithEmptyAndShow xs = show ([], xs) in pairWithEmptyAndShow [1..10]
10:28:31 <lambdabot>  Add a type signature
10:28:38 <Cale> that one is trickier
10:28:45 <Cale> though in this case, silly
10:28:58 <xerox> Without explicit typing, yes.
10:29:02 <Cale> you could get around it here by giving the [] any type
10:29:33 <Cale> well, actually...
10:29:42 <Cale> > let pairWithEmptyAndShow xs = show ([]::String, xs) in pairWithEmptyAndShow [1..10]
10:29:43 <lambdabot>  "(\"\",[1,2,3,4,5,6,7,8,9,10])"
10:29:49 <Cale> not just any type :)
10:30:10 <Cale> > let pairWithEmptyAndShow (xs :: a) = show ([] :: [a], xs) in pairWithEmptyAndShow [1..10]
10:30:10 <lambdabot>  Parse error in pattern
10:30:21 <davidhouse> scoped type variables would also be a nice solution to this
10:30:57 <Cale> hmm
10:31:02 <Cale> I guess it's turned off
10:31:04 <xerox> > show ([] :: (Show a) => a,[1,2,3])
10:31:05 <lambdabot>  a
10:31:05 <lambdabot>   Inferred type: [a1]
10:31:05 <lambdabot>   In the expression: [] :: (Show a) => a
10:31:15 <Cale> > let pairWithEmptyAndShow xs = show ([] `asTypeOf` xs, xs) in pairWithEmptyAndShow [1..10]
10:31:16 <lambdabot>  "([],[1,2,3,4,5,6,7,8,9,10])"
10:31:20 <Cale> > let pairWithEmptyAndShow xs = show ([] `asTypeOf` xs, xs) in pairWithEmptyAndShow "hello"
10:31:21 <lambdabot>  "(\"\",\"hello\")"
10:31:56 <Cale> > show ([] :: (Show a) => [a],[1,2,3])
10:31:57 <lambdabot>  Add a type signature
10:32:01 <Cale> still ambiguous
10:32:02 <roconnor> nice example
10:32:15 <xerox> (:
10:46:53 <psnl> is there a way to assign a type to a constant?
10:47:11 <Lemmih> > 10 :: Int
10:47:12 <lambdabot>  10
10:47:14 <yip> is any value in haskell not a constant?
10:47:14 <Cale> psnl: same way you'd assign a type to anything
10:47:19 <yip> oh
10:47:25 <Cale> and yeah, they're all constants :)
10:48:03 <Cale> though I assume that by "constant" here, what is really meant is "pattern-bound variable"
10:48:19 <davidhouse> there are very few actual constants in the language
10:48:22 <Cale> or maybe not :)
10:48:43 <Cale> I suppose it could be a literal
10:49:30 <Cale> davidhouse: unless you consider functions to be constants
10:49:46 <SamB> well, since you can't compare functions, why not?
10:50:02 <roconnor> do functions vary?
10:50:05 <davidhouse> it depends on your definition of 'constant'.
10:50:18 <psnl> thanks, the use case was [1..10], if that helps the argument
10:50:25 <roconnor> I suppose only the function outputs vary
10:50:26 <davidhouse> e.g. "the Y-combinator is a constant added to system F to enable recursion"
10:50:31 <Cale> roconnor: right
10:51:22 <Cale> unless you're talking about something like f in  map f = foldr ((:) . f) []
10:51:35 <roconnor> right
10:51:44 <roconnor> that f is a variable.
10:51:49 <roconnor> and a function
10:51:57 <xerox> And a letter.
10:51:59 <Cale> hehe
10:52:14 <roconnor> xerox: don't confuse it with 'f'
10:52:19 <roconnor> @type 'f'
10:52:20 <lambdabot> Char
10:52:29 <roconnor> > isLetter 'f'
10:52:30 <lambdabot>  Not in scope: `isLetter'
10:52:31 <xerox> That is a character constant.
10:52:36 <Cale> let-bound functions might as well be considered constants though
10:52:52 <Cale> er, usually :)
10:52:55 <roconnor> @hoogle Char -> Bool
10:52:56 <lambdabot> Char.isAlpha :: Char -> Bool
10:52:56 <lambdabot> Char.isAlphaNum :: Char -> Bool
10:52:56 <lambdabot> Char.isAscii :: Char -> Bool
10:53:05 <roconnor> > isAlpha 'f'
10:53:07 <lambdabot>  True
10:53:14 <xerox> > isAlpha f
10:53:15 <lambdabot>  Not in scope: `f'
10:53:25 <xerox> (:
10:53:27 <Cale> (if their definitions have no free variables :)
10:53:40 <xerox> So I am free to define them as I want!
10:53:56 * Saulzar_ has a very clear idea of 'constant' after reading this discussion.
10:54:18 <roconnor> > Distribution.Compat.FilePath.isPathSeparator 'f'
10:54:19 <lambdabot>  Not in scope: `Distribution.Compat.FilePath.isPathSeparator'
10:54:26 <yip> what's really annoying is that haskell opengl bindings seem to be overloaded or whatever so they can use any sort of integral type, so you have to do stuff like: vertex (0::Double) 0 0
10:55:37 <ndm> roconnor: have you seen my System.FilePath library?
10:55:45 <roconnor> ndm: nope
10:55:52 <Saulzar> yip, Are you jip?
10:55:52 <ndm> I'm integrating the Distribution.Compat.FilePath and new stuff
10:56:04 <goron> What's more annoying is that GHC darcs does not build.
10:56:06 <ndm> roconnor: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
10:56:09 <yip> Saulzar: yeah! how's it going man?
10:56:11 <ndm> @where FilePath
10:56:12 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath
10:56:24 <goron> /usr/include/GL/glxext.h:676:0:
10:56:24 <goron>      error: syntax error before '*' token
10:56:27 <ndm> @where+ FilePath http://darcs.haskell.org/~lemmih/FilePath and http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
10:56:28 <lambdabot> Done.
10:57:23 <goron> I already tried using different compilers (gcc-3.3, gcc-4.0), but nothing worked. Building GHC remains a combinatorial problem.
10:57:41 <Saulzar> yip, Just thought I'd heard that argument before. Not too bad, just trying to figure out what to do with myself.
10:58:00 <yip> Saulzar: hm... i don't think you've heard that argument from me though :O
10:58:04 <roconnor> ndm: BTW, hoogle is totally awsome
10:58:11 <ndm> roconnor: cheers :)
10:58:11 <yip> Saulzar: i'm thinking of maybe taking another stab at that gameboy shit :|
10:58:15 <Saulzar> Hehe, I'm sure I have :)
10:58:17 <roconnor> I don't understand why Moogle sucks so much in comparison
10:58:26 <ndm> Moogle?
10:58:32 <ndm> never heard of it...
10:58:56 <davidhouse> ML-hoogle, perhaps?
10:58:58 <roconnor> oh wait, it was renamed
10:59:00 <davidhouse> :)
10:59:19 <roconnor> as Whelp
10:59:27 <ndm> I intend to put cross-language support in version 5, with clean and ML at least
10:59:28 <roconnor> http://mowgli.cs.unibo.it:58080/apply?keys=S,T1,T2,E,RT,L&xmluri=http://mowgli.cs.unibo.it:58081/getempty&param.profile=default&profile=default&param.action=getpage&param.url=moogle_init.html
10:59:32 <roconnor> yikes
10:59:51 <ndm> ouch!!!!
11:00:00 <roconnor> It is the search engine for Coq libraries
11:00:04 <ndm> Uncaught exception: Mysql.Error("Mysql.exec: MySQL server has gone away")
11:00:35 <Saulzar> yip, Cool. I'm meaning to dig my old project too. 
11:02:09 <roconnor> http://helm.cs.unibo.it/
11:02:15 <roconnor> select Search
11:02:33 <roconnor> anyhow, it ought to be as easy as hoogle
11:02:45 <roconnor> I should point them to your work.
11:03:13 <ndm> yep, its a bit unfriendly
11:03:48 <MarcWeber> Is theere a shorter way than fromMaybe $ maybevalue `mplus` return default ?
11:03:49 <ndm> they are welcome to steal what they want out of hoogle
11:04:36 <norpan> MarcWeber: maybe maybevalue default
11:04:38 <mauke> @type Data.Maybe.fromMaybe 
11:04:40 <lambdabot> forall a. a -> Maybe a -> a
11:05:24 <norpan> @type maybe
11:05:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:05:26 <norpan> almost
11:05:33 <norpan> i always forget how that function works :)
11:05:45 <roconnor> @type \mv d -> Maybe.fromMabye $ mv `mplus` return d
11:05:46 <lambdabot> Not in scope: `Maybe.fromMabye'
11:05:49 <norpan> maybe default id maybevalue
11:05:52 <roconnor> @type \mv d -> Data.Maybe.fromMabye $ mv `mplus` return d
11:05:53 <lambdabot> Not in scope: `Data.Maybe.fromMabye'
11:05:58 <roconnor> @type \mv d -> Maybe.fromMaybe $ mv `mplus` return d
11:06:00 <lambdabot> forall (m :: *
11:06:00 <lambdabot>                      -> *)
11:06:00 <lambdabot>                    a.
11:06:00 <lambdabot>                  (MonadPlus m) =>
11:06:00 <lambdabot>                  m a -> a -> Maybe (m a) -> m a
11:06:43 <roconnor> MarcWeber: I don't think what you wrote is the function you want
11:07:07 <roconnor> @djinn a -> Maybe a -> a
11:07:07 <lambdabot> f a b =
11:07:07 <lambdabot>   case b of
11:07:07 <lambdabot>   Nothing -> a
11:07:07 <lambdabot>   Just c -> c
11:07:33 <MarcWeber> > maybe "def" id (Just "2")
11:07:34 <lambdabot>  "2"
11:07:51 <MarcWeber> > maybe "def" id (Nothing )
11:07:52 <lambdabot>  "def"
11:08:00 <roconnor> > fromMaybe "def" (Just "2")
11:08:01 <lambdabot>  "2"
11:08:05 <roconnor> > fromMaybe "def" (Nothing)
11:08:06 <lambdabot>  "def"
11:08:23 <mauke> @djinn++
11:08:24 <lambdabot> Cannot parse command
11:09:14 <norpan> ah
11:09:55 * MarcWeber shouts thx roconner ;)
11:10:14 <MarcWeber> I knew there was one.. I just didn't see it.
11:11:05 <norpan> i meant fromMaybe :)
11:11:12 <norpan> then i looked at maybe instead....
11:11:16 <norpan> anyway
11:12:08 <mauke> hmm, @djinn should be made to understand forall a b.
11:12:59 <xerox> What do you mean?
11:13:47 <mauke> @. jinn type maybe
11:13:48 <lambdabot> compose module failed: Parse error: "jinn"
11:13:53 <mauke> @. djinn type maybe
11:13:54 <lambdabot> -- f cannot be realized.
11:14:08 <mauke> because @type emits forall a b. ...
11:15:24 <xerox> Ah, in that sense.
11:15:39 <xerox> Patch it!
11:18:52 <Jackson> Hi there
11:22:59 <goron> What is a loop variant of Control.Monad.when?
11:23:31 <Jackson> Anywho, I was wondering if there was someone who would be able to help me some haskell code I am writing, it uses the iterate and takeWhile functions and I need to take out the final parts of the list it creates. Any help would be gratefully appreciated.
11:23:49 <davidhouse> Jackson: is it really complicated? 
11:23:55 <davidhouse> either paste it here, or, if it's too long:
11:23:57 <davidhouse> @where paste
11:23:58 <lambdabot> http://paste.lisp.org/new/haskell
11:24:05 <davidhouse> goron: what would that do?
11:24:30 <bringert> shapr: would you be interested in beta-testing Blob 2?
11:24:39 <goron> davidhouse: I want to run some action in the State monad while some condition is true.
11:24:53 <Jackson> allDifferences xs = (takeWhile ( /= [] ) (iterate differences xs))
11:24:55 <davidhouse> so the predicate is monadic as well?
11:25:05 <goron> davidhouse: yes
11:25:10 <davidhouse> @hoogle while
11:25:11 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
11:25:11 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
11:25:11 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
11:25:17 <davidhouse> @hoogle until
11:25:17 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
11:25:17 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
11:25:30 <davidhouse> you'd have to write one.
11:25:52 <goron> davidhouse: I'd figured there would be something standard.
11:25:57 <goron> davidhouse: thanks
11:26:16 <davidhouse> whileM p act = do p' <- p; if p then return () else act >> whileM p act
11:26:31 <davidhouse> Jackson: what's it meant to do?
11:26:54 <Jackson> Basically my current code takes an [Int] and returns it [[Int]]
11:27:07 <davidhouse> what does differences do?
11:27:11 <Jackson> a sample input would be [0,3,8,5]
11:27:18 <bringert> davidhouse: that should probably be "if p' ...".
11:27:23 <davidhouse> bringert: err, right.
11:27:50 <bringert> maybe it was a trick to force the reader to understand the code enough to fix it?
11:27:53 <Jackson> allDifferences xs returns the list of successive sequences of differences starting from xs and ending when the differences converge
11:28:03 <davidhouse> bringert: sure. that was it. yes. :)
11:28:27 <davidhouse> Jackson: so allDifferences [0,3,8,5] would be?
11:29:00 <bringert> how do you force Mail.app to get all new mail in mail folder? It seems reluctant to update my 12000+ message haskell folder.
11:29:02 <Jackson> [[0,3,8,15],[3,5,7],[2,2],[0]]
11:29:14 <davidhouse> ah, right, i get it.
11:29:35 <Jackson> Please note this is a part of an assessed Lab, but I cannot figure out the last part which I am about to tell you
11:29:46 <Jackson> And I was wondering for hints
11:29:52 <Jackson> not just code
11:29:59 <davidhouse> okay.
11:30:08 <Jackson> What I need to do is remove that last [0] list
11:30:44 <davidhouse> will the last list always be [0]?
11:31:10 <Jackson> now I have tried placing filter 0 and takeWhile 0 methods in but cannot get them to work
11:31:17 <Jackson> Yes, however..
11:31:42 <Jackson> for allDifferences [7,27,73,157,291,487]
11:32:07 <Cale> takeWhile (/= [0])
11:32:08 <Cale> ?
11:32:09 <Jackson> it would return [.....[12,12,12],[0,0],[0]]
11:32:14 <Cale> okay
11:32:27 <Cale> do you want it to stop when one of the lists is all zeroes?
11:32:32 <Jackson> yes
11:32:43 <goron> davidhouse: I didn't really stated my requirements correctly, the "condition" I talked about returns a Maybe Foo
11:32:44 <davidhouse> you'd need a function to test whether a list was entirely zero
11:32:45 <Jackson> I also wrote a allZeros method
11:32:59 <Cale> allZeroes = all (== 0)
11:33:02 <yip> you mean "function" :P
11:33:20 <Jackson> yip yeah, thanks ;)
11:33:34 <Cale> you can use takeWhile with that function
11:33:38 <Jackson> my allZeroes one was allZeros xs = sum xs == 0
11:33:46 <Cale> (well, not composed with that function)
11:34:00 <Cale> You should be careful, since [1,-1] will give 0
11:34:09 <Cale> It's fine if you never have negative values
11:34:25 <yip> what about integer overflow? doesn't haskell have that?
11:34:34 <Cale> yip: Not with the Integer type
11:34:42 <Cale> (with Int, yes)
11:34:45 <Lemmih> > maxBound + 1 :: Int
11:34:45 <lambdabot>  -2147483648
11:34:59 <yip> Cale: he mentioned that he is usint Int
11:35:12 <Jackson> I have a checker written further in the lab for + and - ints, but thanks there cale
11:35:51 <Cale> > takeWhile (not . all (== 0)) [[1,2,3,4,5],[1,1,1,1],[0,0,0],[0,0],[0]]
11:35:52 <lambdabot>  [[1,2,3,4,5],[1,1,1,1]]
11:36:51 <Cale> > takeWhile (not . all (== 0)) [[1,3,4,5,6],[2,1,1,1],[-1,0,0],[0,0],[0]]
11:36:52 <lambdabot>  [[1,3,4,5,6],[2,1,1,1],[-1,0,0]]
11:37:19 <davidhouse> Cale, remember that he wants hints, not code, as this is an assessment.
11:37:30 <davidhouse> (although i see that's not directly related)
11:38:11 <Saulzar> For the most part if you are using Int you do so on the assumption you use a "small" integer though
11:38:40 <davidhouse> small meanining < 2^31, so not that small :)
11:38:48 <Cale> oops, sorry, it actually is directly related, but the hints that I would probably give would give that much away anyway :)
11:39:05 <Cale> use all or any, along with takeWhile :)
11:39:47 <mauke> my lambdabot build fails with /usr/lib/gcc/i386-pc-linux-gnu/3.4.5/../../../../i386-pc-linux-gnu/bin/ld: cannot find -lHSCabal-1.1.3
11:39:54 <Cale> not . all (== 0) is the same as any (/= 0)
11:40:06 <mauke> how do I tell it to use 1.1.4?
11:40:38 <Jackson> Thank you all very much for that
11:41:21 <davidhouse> Jackson: good luck with the rest of your assessment.
11:41:51 <Jackson> That initial part that Cale mentioned was covered something we haven't before, but I just looked in out text book and it certainly was a moment of epiphany for me :p
11:42:03 <Jackson> *our
11:42:41 <Cale> :)
11:43:00 <Cale> Learning Haskell generally seems to be filled with mind-altering moments.
11:43:07 <sinfinity> agreed.
11:43:23 <yip> very painful mutations of the brain
11:43:57 <Jackson> Haven't had any of those to be honest
11:44:09 <Jackson> It is more interesting to me than Java at the moment
11:45:32 <davidhouse> that's because haskell _is_ more interesting than java! :)
11:45:42 <Cale> well, the level of pain is proportional to how much you're used to imperative programming languages -- if you're new to programming in general, it's probably not so bad
11:46:37 <Jackson> Mmn, recursion was the first thing that struck me as odd, but was going along steadily till that problem
11:46:48 <goron> @pointless (\f g h i-> replicate (length h) (i f))
11:46:48 <lambdabot> const . flip ((.) . replicate . length) . flip id
11:46:51 <goron> How about that?
11:47:20 <int-e> hmm, what if h is infinite?
11:47:26 <int-e> i.e. has infinite length?
11:47:36 <goron> davidhouse: What I needed was pretty simple to write.
11:47:54 <mauke> .oO( sequence . const >>= map )
11:47:59 <goron> int-e: This was from my random code generator, it isn't anything real.
11:48:10 <int-e> @pointless (\f g h i -> map (const (i f)) h)
11:48:11 <lambdabot> const . flip . ((map . const) .) . flip id
11:49:01 <int-e> goron: ah, that's nasty.
11:49:37 <ihope> Random code generator?
11:49:39 <ihope> :-)
11:50:37 <johnnowak> cat /usr/bin/* > random.hs
11:51:40 <goron> ihope: Well, "random", as I see randomness as a pure theoretical construct.
11:51:47 <int-e> why does my haskell file start with \377ELF?
11:52:06 <int-e> or whatever the first byte was. I forgot.
11:52:10 <davidhouse> goron, how did you solve it?
11:52:11 <ihope> int-e: why not?
11:52:26 <int-e> ihope: that was in reply to johnnowak 
11:52:41 <goron> whileM maybeValAction action = 
11:52:41 <goron>     case maybeValAction of 
11:52:41 <goron>       Just z -> action z
11:52:41 <goron>       Nothing -> return ()
11:52:46 <ihope> Ah.
11:53:04 <int-e> binaries are an awful source of randomness.
11:53:06 <goron> I haven't tested it yet, but I think it does what I need. 
11:53:09 <johnnowak> int-e: just throw some arrows and shit in there. it'll work.
11:53:09 <mauke> not a loop
11:53:23 <Cale> goron: that's not a loop
11:53:25 <goron> uh, oops
11:53:28 <johnnowak> int-e: 'course. was a joke. :)
11:53:33 <goron> Forgot that part ;)
11:53:38 <Cale> (you probably want to run the maybeValAction)
11:53:49 <davidhouse> action z >> whileM maybeValAction action
11:53:57 <goron> whileM maybeValAction action = 
11:53:57 <goron>     case maybeValAction of 
11:53:57 <goron>       Just z -> action z>>whileM  maybeValAction action
11:53:57 <goron>       Nothing -> return ()
11:54:03 <ihope> fixm x = fixm x >>= x -- why does >>= have to be strict the way it is?
11:54:14 <ihope> s/fixm/mfix/g
11:54:29 <goron> Cale: Isn't that run now?
11:54:43 <mauke> maybeValAction :: Maybe a
11:54:45 <Cale> goron: What's the type of maybeValAction?
11:54:53 <mauke> heh
11:54:56 <goron> Cale: Nm, you are right.
11:55:36 <goron> whileM maybeValAction action = 
11:55:36 <goron>     maybe<-maybeValAction
11:55:36 <goron>     case maybe of 
11:55:36 <goron>       Just z -> action z>>whileM  maybeValAction action
11:55:36 <goron>       Nothing -> return ()
11:55:36 <davidhouse> goron, that doesn't make sense though
11:55:41 <davidhouse> ah.
11:55:52 <Cale> 'do'
11:55:58 <int-e> @type mfix
11:55:59 <goron> yep
11:56:00 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
11:56:15 <davidhouse> goron, what's the type of maybeValAction then?
11:57:11 <mauke> @pl whileM c x = c >>= maybe (return ()) (\z -> x z >> whileM c x)
11:57:12 <lambdabot> whileM = fix (liftM2 (.) (>>=) . (((maybe return .) . liftM2 flip ((>>) .)) .))
11:57:19 <goron> davidhouse: State MyState (Maybe Foo), you are right, it's wrong.
11:57:39 <mahogny> hm. there would be nice with a typeclass Copyable that can make a copy of any variable even if it is a mutable one. anything like that exists?
11:57:45 <Cale> whileM mva a = mva >>= maybe (return ()) (\z -> a z >> whileM mva a)
11:58:06 <Cale> @pl \z -> a z >> whileM mva a
11:58:06 <lambdabot> (>> whileM mva a) . a
11:58:20 <ihope> @pl whileM mva a = mva >>= maybe (return ()) (\z -> a z >> whileM mva a)
11:58:21 <lambdabot> whileM = fix (liftM2 (.) (>>=) . (((maybe return .) . liftM2 flip ((>>) .)) .))
11:58:24 <MarcWeber> I get illegal signature in pattern use -fglangow-exts to permit it.. Why?
11:58:25 <MarcWeber> etNewTemporaryFilePath2 :: (FilePath -> IO Bool) -> (Maybe FilePath) 
11:58:26 <MarcWeber> 	-> String -> String -> [FilePath] -> IO FilePath
11:58:43 <davidhouse> that paste was borked.
11:58:45 <davidhouse> @wherepaste
11:58:46 <lambdabot> Unknown command, try @list
11:58:47 <davidhouse> @where paste
11:58:48 <lambdabot> http://paste.lisp.org/new/haskell
11:59:36 <ihope> MarcWeber: what was the message?
12:00:12 <Cale> MarcWeber: are you putting a type signature on a pattern binding?
12:00:39 <Cale> (like a scoped type variable thing)
12:00:59 <goron> davidhouse: Haskell understands my code (with Cale's do).
12:01:14 <davidhouse> goron, that's because it's right :)
12:01:37 <lisppaste2> MarcWeber pasted "illegal signature" at http://paste.lisp.org/display/20678
12:02:26 <ihope> MarcWeber: looks like an indentation thing.
12:02:41 <MarcWeber> look for < here error
12:02:48 <ihope> Try un-indenting "getNewTemporaryFilePath2 doesExist tmpDir prefix suffix list = do"
12:03:33 <Cale> yeah, that's the problem
12:05:44 <mauke> yay, nested footnotes work
12:05:57 <mauke> <3 Monad.State
12:06:39 <monochrom> Why do Haskell programmers like State.  And why do C programmers like functions.
12:07:06 <mauke> well, how would I do footnotes without State?
12:07:32 <monochrom> I'm joking.
12:08:37 <davidhouse> footnotes in what sense?
12:08:48 <davidhouse> i like State, but i always try to not use it.
12:09:01 <mauke> I've written a simple stuff->html converter (where stuff = my own format)
12:09:03 <davidhouse> i find it's more elegant to use lis manip/Reader.
12:09:10 <int-e> > let s' [] = [[]]; s' (a:b) = map (a:) (s b); s l = tails l >>= s' in s [1,2,3]
12:09:11 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:09:42 <davidhouse> for goodness' sake, use concatMap!
12:09:58 <monochrom> alle subsets de {1,2,3} ? :)
12:10:10 <monochrom> heheheh >>= is 31337
12:11:05 <davidhouse> int-e, especially as you can eta-reduce if you use concatMap.
12:11:14 <ihope> > sequence [[1,2,3]]
12:11:15 <lambdabot>  [[1],[2],[3]]
12:11:23 <ihope> > sequence [[1],[2],[3]]
12:11:24 <lambdabot>  [[1,2,3]]
12:11:25 <ihope> Aww.
12:11:41 <int-e> sequence . sequence = id? :P
12:11:42 <davidhouse> > let s' [] = [[]]; s' (a:b) = map (a:) (s b); s = concatMap s' . tails in s [1,2,3]
12:11:42 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:11:50 <ihope> > sequence [[],[1,2,3]]
12:11:50 <lambdabot>  []
12:11:54 <ihope> ...
12:12:33 <davidhouse> ihope, it >>=s between all the members of a list, and as [] is essentially a failure-propogating monad with the empty list representing failure...
12:12:34 <int-e> davidhouse: I can do that with >>=, too. (>>= s') . tails
12:12:49 <int-e> davidhouse: or, proably more readable, (s' =<<) . tails
12:13:01 <davidhouse> int-e, right, but that's ugly (well, uglier; it's not that bad)
12:13:38 <ihope> > let subs [] = [[]]; subs (x:xs) = subs xs >>= \ys -> [ys,x:ys] in subs [1,2,3]
12:13:39 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:15:35 <davidhouse> i like ihope's better, it gives them in a better order.
12:16:26 <norpan> subs xs >>= ap (:) (x :)
12:16:47 <davidhouse> @type ap
12:16:48 <lambdabot> forall b (m :: * -> *) a.
12:16:48 <lambdabot> (Monad m) =>
12:16:48 <lambdabot> m (a -> b) -> m a -> m b
12:16:59 <int-e> foldM (\ys x -> [ys,x:ys]) [] [1,2,3] -- well, it's close.
12:17:02 <davidhouse> @type ap (:)
12:17:02 <int-e> > foldM (\ys x -> [ys,x:ys]) [] [1,2,3] -- well, it's close.
12:17:03 <lambdabot> forall a. (a -> [a]) -> a -> [a]
12:17:03 <lambdabot>  [[],[3],[2],[3,2],[1],[3,1],[2,1],[3,2,1]]
12:17:07 <ihope> foldM?
12:17:11 <ihope> Scary.
12:17:31 <ihope> @hoogle foldM
12:17:31 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
12:17:31 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:17:31 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
12:17:50 <davidhouse> ihope, sequence . foldl, up to number of parameters.
12:18:15 <ihope> @type foldl
12:18:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:18:29 <ihope> @type ((sequence .) .) . foldl
12:18:30 <lambdabot> forall (m :: * -> *) a b.
12:18:30 <lambdabot>           (Monad m) =>
12:18:30 <lambdabot>           ([m a] -> b -> [m a]) -> [m a] -> [b] -> m [a]
12:18:33 <davidhouse> @type \x -> ap (:) (x :)
12:18:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:18:34 <lambdabot>   Expected type: [a] -> [[a]]
12:18:39 <davidhouse> didn't think so.
12:18:58 <davidhouse> i think you want ap (:) x
12:19:33 <davidhouse> > let subs [] = [[]]; subs (x:xs) = subs xs >>= ap (:) x in subs [1..3]
12:19:34 <lambdabot>  add an instance declaration for (Num ([a] -> [[a]]))
12:19:34 <lambdabot>   In an arithmetic se...
12:19:40 <davidhouse> perhaps not.
12:20:12 <int-e> > foldr (\x m -> (m >>= \ys -> [ys,x:ys])) [[]] [1,2,3]
12:20:14 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:20:35 <davidhouse> > let subs [] = [[]]; subs (x:xs) = subs xs >>= ap (:) . (x:) in subs [1..3]
12:20:36 <lambdabot>  Couldn't match `(->) a' against `[]'
12:21:06 <norpan> ap (:) (return.(x:))
12:21:16 <norpan> but that's just ugly
12:21:29 <int-e> @type foldr (\x m -> (m >>= \ys -> return ys `mplus` return (x:ys))) (return []) [1,2,3]
12:21:30 <lambdabot> forall (m :: *
12:21:30 <lambdabot>                                  -> *)
12:21:30 <lambdabot>                                a.
12:21:30 <lambdabot>                              (MonadPlus m,
12:21:32 <lambdabot>                              Num a) =>
12:21:34 <lambdabot>                              m [a]
12:22:13 <int-e> So there's a reason to like >>= ... flexibility.
12:23:10 <davidhouse> @type ap
12:23:11 <lambdabot> forall b (m :: * -> *) a.
12:23:11 <lambdabot> (Monad m) =>
12:23:11 <lambdabot> m (a -> b) -> m a -> m b
12:23:35 <davidhouse> @type Control.Monad.Reader.ap
12:23:35 <lambdabot> forall b (m :: * -> *) a.
12:23:36 <lambdabot>          (Monad m) =>
12:23:36 <lambdabot>          m (a -> b) -> m a -> m b
12:25:07 <int-e> davidhouse: your one (:) should be id
12:26:49 <int-e> oh. hmm.
12:26:49 <davidhouse> i though ap was the S combinator?
12:26:49 <davidhouse> oh, it is.
12:26:49 <davidhouse> never mind :)
12:26:49 <int-e> @pl \x y -> y : (x:y) : []
12:26:49 <lambdabot> ap (:) . flip flip [] . ((:) .) . (:)
12:27:25 <davidhouse> > let subs [] = [[]]; subs (x:xs) = subs xs >>= ap (:) (return . (x:)) in subs [1..3]
12:27:26 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:29:09 <int-e> Prelude> length $ [1..65536] >> [1..65536]
12:29:09 <int-e> 0
12:29:20 <ihope> Control.Monad.Reader.ap = Control.Monad.ap, except that it works with the Reader monad?
12:29:42 <int-e> wrong.
12:29:49 <int-e> they're equal. no except or anything
12:30:09 <int-e> Prelude Control.Monad.Reader> :i ap
12:30:09 <int-e> ap :: Monad m => m (a -> b) -> m a -> m b
12:30:09 <int-e>         -- Imported from Control.Monad
12:31:07 <ihope> int-e: but using Control.Monad.ap doesn't work with the Reader monad unless Control.Monad.Reader has been imported un-qualified, correct?
12:32:22 <int-e> ihope: not really. if you get a reader monad instance in some other way, ap will work with it.
12:33:07 <int-e> ihope: it's the monad instance for (->) r  that allows using ap as S.
12:33:32 <ihope> Or just define s x y z = x z (y z)
12:33:50 <nuffer> is there an easy way to access the bits of an integer?
12:34:04 <nuffer> the way one would with masking in C/C++
12:34:12 <norpan> masking? :)
12:34:19 <ihope> nuffer: Int or Integer?
12:34:20 <nuffer> like, I mean
12:34:21 <norpan> import Data.Bits
12:34:22 <nuffer> ihope, Int
12:34:30 <ihope> @hoogle Int -> Int -> Int
12:34:31 <lambdabot> No matches, try a more general search
12:34:40 <norpan> @doc Data.Bits
12:34:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
12:34:45 <nuffer> ah, cool
12:35:21 <ihope> > 384 .&. 256 :: Int
12:35:21 <lambdabot>  256
12:35:24 <nuffer> thanks, that's exactly what I was looking for
12:42:09 <nuffer> is there a way to write Ints in hexedecimal?
12:42:35 <norpan> just write like in c: 0xaf
12:43:05 <int-e> > showHex 123 ""
12:43:07 <lambdabot>  "7b"
12:43:22 <norpan> nuffer: oh, you mean show
12:43:31 <nuffer> no, I meant in source
12:43:45 <nuffer> like you said
12:43:46 <davidhouse> > 0x32
12:43:46 <lambdabot>  50
12:43:47 <nuffer> thanks
12:44:00 <norpan> then i answered it already :)
12:44:08 <davidhouse> > 0xa
12:44:09 <lambdabot>  10
12:44:27 <ihope> > (32, 032, 0o32)
12:44:28 <lambdabot>  (32,32,26)
12:44:40 <ihope> > showOct 26
12:44:40 <lambdabot>  <[Char] -> [Char]>
12:44:47 <ihope> > showOct 26 ""
12:44:48 <lambdabot>  "32"
12:44:56 <davidhouse> damned ShowS! :)
12:45:32 <ihope> showsPrec?
12:45:51 <ihope> Isn't that just show with added parameters that don't do anything?
12:46:10 <int-e> shows
12:46:13 <int-e> vs. show
12:46:39 <ihope> Oh, right.
12:46:39 <int-e> shows is the version that takes a tail string to avoid lots of concats.
12:46:54 <ihope> Isn't that just shows with an added parameter that doesn't do anything?
12:47:15 <davidhouse> not quite.
12:47:23 <davidhouse> @type shows
12:47:24 <lambdabot> forall a. (Show a) => a -> ShowS
12:47:31 <davidhouse> > shows 9 "hello"
12:47:32 <lambdabot>  "9hello"
12:47:53 <int-e> > (showsPrec 9 (1%1), showsPrec 0 (1%1))
12:47:55 <lambdabot>  (<[Char] -> [Char]>,<[Char] -> [Char]>)
12:48:01 <int-e> > (showsPrec 9 (1%1) "", showsPrec 0 (1%1) "")
12:48:02 <lambdabot>  ("(1%1)","1%1")
12:48:13 <ihope> Ah.
12:48:19 <int-e> Prec = precedence.
12:48:49 <ihope> Is showsPrec a Show member thingy, then?
12:49:13 <int-e> yes. unlike shows, btw.
12:49:41 <norpan> because shows is just showsPrec 0
12:53:58 <ihope> @djinn (((b1 -> c1) -> (a -> b) -> a -> c) -> c2) -> (((a1 -> b1) -> a1 -> c1) -> b -> c) -> c2
12:53:59 <lambdabot> f a b = a (\ c d e -> b (\ f g -> c (f g)) (d e))
12:54:03 <ihope> @pl f a b = a (\ c d e -> b (\ f g -> c (f g)) (d e))
12:54:04 <lambdabot> f = (. (((.) .) . (. (const . (. join id)))))
12:54:10 <ihope> Eesh.
12:54:58 <ihope> By the way, I don't like how @pl can output something that doesn't typecheck when you give it something that does.
12:55:12 <davidhouse> ihope, it can?
12:55:25 <ihope> davidhouse: it just did.
12:55:37 <ihope> Didn't it?
12:55:48 <davidhouse> @type f = (. (((.) .) . (. (const . (. join id)))))
12:55:49 <lambdabot> parse error on input `='
12:55:54 <davidhouse> @type  (. (((.) .) . (. (const . (. join id)))))
12:55:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
12:55:55 <lambdabot>   Expected type: a -> a -> a1
12:56:15 <davidhouse> @type let f a b = a (\ c d e -> b (\ f g -> c (f g)) (d e)) in f
12:56:15 <lambdabot> forall t
12:56:16 <lambdabot>                        t1
12:56:16 <lambdabot>                        t2
12:56:16 <lambdabot>                        t3
12:56:16 <lambdabot>                        t4
12:56:18 <lambdabot> [8 @more lines]
12:56:20 <davidhouse> @more
12:56:20 <lambdabot>                        t5
12:56:22 <lambdabot>                        t6.
12:56:24 <lambdabot>                      (((t -> t1) -> (t2 -> t3) -> t2 -> t4)
12:56:24 <int-e> @type join id
12:56:26 <lambdabot>                      -> t5)
12:56:28 <lambdabot>                      -> (((t6 -> t) -> t6 -> t1)
12:56:30 <lambdabot> [3 @more lines]
12:56:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
12:56:36 <lambdabot>   Expected type: a -> a -> a1
12:56:37 * ihope hates this "every token on a different line" stuff
12:57:32 <davidhouse> ihope: submit a patch! :)
12:57:33 <goron> How can I completely strictify an expression?
12:57:44 <ihope> goron: deepSeq?
12:57:47 <xerox> Use STRICTn() (:
12:58:01 <goron> xerox: eh?
12:58:02 <ihope> What's the expression?
12:58:08 <davidhouse> goron, what do you want to strictify?
12:58:20 <goron> davidhouse: I am debugging. 
12:58:38 <goron> davidhouse: I have put trace on several places, but it seems it doesn't get executed.
12:58:45 <davidhouse> ah,
12:58:50 <davidhouse> put them in better places.
12:59:30 <ihope> trace x y = seq (unsafePerformIO (putDebugMsg x)) y?
12:59:41 <xerox> STRICT(f) f a | a `seq` False = undefined
12:59:47 <ihope> s/Debug/Trace/
12:59:54 <xerox> STRICT2(f) f a b | a `seq` b `seq` False = undefined
12:59:58 <xerox> And so on...
13:01:32 <davidhouse> goron, what xerox is talking about is CPP macros, which will be tricky to use
13:01:48 <xerox> I think it is very simple.
13:02:07 <goron> davidhouse: I know what the the C Preprocessor is.
13:02:16 <xerox> Just add before your function definition a line like STRICTn(name).
13:02:29 <davidhouse> xerox, doesn't it add complexity to the build process?
13:02:30 <norpan> i want a generic deepSeq
13:02:46 <norpan> i made deepSeq x = length (show x) once :)
13:02:47 <goron> xerox: Does that work in ghci?
13:02:56 <xerox> davidhouse - You can just add {-# OPTIONS_GHC -cpp #-} in your module.
13:03:03 <xerox> Yes, goron.
13:03:05 <goron> xerox: that's a yes, nice
13:04:16 <int-e> @google deepSeq
13:04:18 <lambdabot> http://article.gmane.org/gmane.comp.lang.haskell.prime/1266
13:05:02 <int-e> hmm. ok, we're not lucky. the second hit is http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs
13:05:39 <ihope> class DeepSeq a where deepSeq :: a -> b -> b -- this?
13:05:57 <AllenJB> What's wrong with http://pastebin.com/749751 ? I'm getting the following error: ERROR "code2d.hs":6 - Syntax error in declaration (unexpected `::') but I can't work out why.
13:06:32 <ihope> Don't capitalize "Leaves".]
13:06:56 <ihope> And you probably mean ++, not :.
13:07:24 <AllenJB> ihope: Thank you. And probably.
13:08:30 <goron> I thought deepseq was included in ghc.... hmm, must be wrong...
13:09:22 <int-e> @index deepSeq
13:09:23 <lambdabot> bzzt
13:09:36 <ihope> @hoogle deepSeq
13:09:37 <lambdabot> No matches found
13:10:01 <norpan> actually it was deepSeq a b = length (show a) `seq` b
13:10:11 <norpan> it worked
13:10:31 <norpan> you had to derive Show of course
13:11:36 <int-e> > length $ show (undefined:"Hello")
13:11:37 <lambdabot>  Undefined
13:12:16 <int-e> > show "\12"
13:12:18 <lambdabot>  "\"\\f\""
13:12:55 <norpan> > let deepSeq a b = length (show a) `seq` b in repeat '1' `deepSeq` ()
13:12:59 <lambdabot> Terminated
13:18:03 <davidhouse> > length (undefined : "Hello")
13:18:04 <lambdabot>  6
13:19:24 <kzm_> WHNF-test?
13:19:49 <kzm_> Anybody with experience with GHC on POWER and AIX?
13:19:55 <davidhouse> @hoogle lex
13:19:56 <lambdabot> Prelude.lex :: ReadS String
13:19:56 <lambdabot> Text.Read.Lex.lex :: ReadP Lexeme
13:19:56 <lambdabot> Text.Read.Lex :: module
13:26:00 <goron> Debugging is not my hobby. Maybe I should code bug-free to begin with....
13:27:36 <davidhouse> i don't get Text.Read.Lex. is it a haskell parser?
13:29:11 <kzm_> Hmf.  Okay, anybody with experience building a GHC 6.5 snapshot from scratch?
13:29:44 * kzm_ cannot help with lexing - sorry.  And probably not with debugging either :-)
13:30:32 <palomer> hrmph
13:30:45 <palomer> do you guys know how to run haskell cgi applications with input from the command line? 
13:30:51 <palomer> I don't know what the input format is
13:31:21 <yip> doesn't cgi work with environment variables?
13:31:21 * kzm_ thought CGI read from stdin?
13:31:25 <SamB> vincenz is good at Alex and Happy, apparantly
13:31:39 * kzm_ looks quizzically at yip.
13:31:53 <integral> and env vars.  Read the spec, it describes all of them.
13:32:18 <kzm_> :-)
13:32:23 <SamB> boy that was a long time between being able to typecheck...
13:32:41 <palomer> ie, how to pass the cgi arguments
13:32:53 <Cale> CGI reads from all sorts of places
13:33:04 <SamB> I thought CGI input was in env vars
13:33:16 <Cale> Both
13:33:17 <goron> kzm: I tried building GHC darcs today, and I failed....
13:33:29 <norpan> it can also use the URL
13:33:30 <Cale> If you use Network.CGI, you don't have to worry about that though.
13:33:57 <goron> kzm: It's pretty funny, if I use version X of some compiler I get errror Y and otherwise I get error Z. 
13:34:01 <Cale> wrapper gives you a dictionary of all the relevant stuff bundled together
13:34:13 <palomer> right
13:34:16 <palomer> but I want to call my script locally
13:34:34 <palomer> passing the stuff from the command line
13:34:44 <Jackson> Hey guys another question if I may, this time on some recursion stuff if thats all right
13:34:58 <Cale> sure
13:35:33 <Jackson> okay I need to write a function - polynomial :: Sequence -> Polynomial
13:35:36 <nico> hi everyone. I want the following line evaluate (lookup undefined undefined): if False then (lookup undefined  undefined) else (Just 5)
13:35:56 <nico> how can I do this? I read something about seq, but I can't get it to work...
13:36:01 <Jackson> with the pre cons of -- pre: xs can be generated by a polynomial of low enough degree
13:36:01 <Jackson> -- pre: not (null xs)
13:36:01 <Jackson> -- polynomial xs returns the polynomial that generated the sequence xs
13:36:15 <Cale> nico: why do you want it to evaluate that?
13:36:32 <davidhouse> ADEpt: ping
13:36:52 <nico> Cale: I am to write an interpreter for a strict language
13:36:54 <Cale> You could define something like strictIf i t e = t `seq` e `seq` if i then t else e
13:37:20 <Cale> but even strict languages usually adopt lazy semantics for the branches of an if
13:37:25 <Jackson> wait, I will set out nicely, easier to explain and show you my other function I hope to use in it
13:37:46 <davidhouse> ADEpt: actually, no, never mind.
13:38:01 <Cale> Basically every language I know will only evaluate the branch of the if which actually matters.
13:38:41 <kzm_> Oh well.  I read in the GHC supported page that powerpPort currently doesn't work, needs some minimal porting effort."c-ibm-aix is "
13:38:55 <kzm_> Does that mean that I should be afraid, be very afraid?
13:39:03 <palomer> hrm, setting environment variables doesn't seem to work
13:39:11 <kzm_> (hmm. did that come out right?)
13:39:24 <Cale> palomer: from the shell? Are you exporting them?
13:39:34 <palomer> export foo = bar; ./a.out
13:39:42 <kzm_> My arch is power4-ibm-aix, not powerpc-ibm-aix, so I wonder how minimal the porting effort will be.
13:39:58 <Cale> palomer: try leaving out the spaces next to the = sign
13:40:10 <palomer> http://www.rafb.net/paste/results/LVmWq750.html <--that's my cgi
13:40:29 <palomer> yeah, doesn't work without spaces
13:40:45 <palomer> (with spaces it won't parse, without spaces it doesn't show)
13:40:59 <palomer> ie, there's nothing called foo in inputs
13:41:23 <nuffer> so if I use a Data.Array, right
13:41:29 <nuffer> and I use the // operator
13:41:39 <ihope> @docs Data.Array
13:41:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
13:41:46 <nuffer> the compiler will likely optimize that out so it's not actually copying the entire array, right?
13:42:23 <ihope> nuffer: probably.
13:42:29 <Cale> palomer: try:  export SERVER_SOFTWARE="foo"; ./trivialcgi
13:43:03 <lisppaste2> Jackson pasted "Polynomial" at http://paste.lisp.org/display/20684
13:43:08 <ihope> What's that command to view simplified expressions and such?
13:43:10 <Cale> Obviously, wrapper doesn't make the entire environment available
13:43:24 <Cale> Just the stuff that's defined by the CGI interface
13:43:31 <palomer> ooh, it gets printed
13:44:03 <palomer> so I can't assign arbitrary arguments?
13:44:39 <palomer> hmm
13:44:45 <Cale> no, though you can still use System.Environment
13:45:45 <palomer> hrmph, I'll find a way to fake it
13:46:48 <Cale> what are you trying to do?
13:47:01 <Cale> You can set QUERY_STRING to set the query parameters.
13:47:18 <Cale> i.e. everything after the first ? in the url
13:49:02 <Cale> the query string gets parsed by wrapper, and the key-value pairs are added to the dictionary
13:49:11 <Cale> Jackson: okay...
13:50:09 <palomer> I'm running a cgi script locally
13:50:44 <palomer> so I'd run ./a.out QUERY_STRING=foo=bar,baz=blargh ?
13:50:47 <Jackson> Wasn't sure whether you wanted to finish with palomer first
13:51:14 <palomer> oh, don't worry about cale, he has superpowers which let him help many people at once
13:51:28 <Cale> palomer: you'd export it as an environment variable
13:52:10 <Cale> QUERY_STRING="quux=fred" ./trivialcgi
13:52:18 <Cale> that'd work
13:52:50 <Jackson> but ok, I tried attempted it with recursion, firstly trying to calculate the next highest term of the generating polynomial (ie the nextTerm function) and then the new sequence (with its appropriate one)
13:52:51 <Cale> separate multiple key-value pairs with & like you would in a URL
13:53:18 <Jackson> however after deciding that I would try it that way
13:53:37 <Jackson> I realised that I really didn't know where to start
13:53:54 <Jackson> so basically, any ideas?
13:55:29 <davidhouse> Jackson: what's the formula for getting a polynomial in this fashion?
13:55:38 <davidhouse> and what's a Sequence? a [[Int]], perhaps?
13:55:50 <davidhouse> and what's a Polynomial?
13:56:05 <davidhouse> [Int]? (that would be a list of the coefficients)
13:56:16 <palomer> ahh, very nice!
13:56:18 <palomer> thx Cale 
13:56:25 <palomer> @karma +1 Cale
13:56:25 <lambdabot> +1 has a karma of 0
13:56:29 <palomer> @karma Cale +1
13:56:29 <lambdabot> Cale has a karma of 11
13:56:30 <Jackson> sorry, meant to define those in the lisp, Sequence = [Int]
13:56:31 <nico> Cale: thanks again for your tip again (it wasn't needed to implement strict ifs btw, but strict symbol lookup), my program is now working as it should
13:57:00 <Cale> nico: ah
13:57:19 <Jackson> and Polynomial is a [(Int, Int)]
13:58:07 <davidhouse> so a sequence is something like [0,3,8,15] and a polynomial...?
13:58:30 <Cale> davidhouse: check the examples at the bottom
13:58:38 <Jackson> [(1,2),(-1,0)]
13:59:08 <Jackson> Would it be eaiser if I edited that to include those type declarations?
13:59:23 <vincenz> re
13:59:26 <vincenz> palomer: !
13:59:27 <davidhouse> Cale, where?
13:59:55 <vincenz> woot
13:59:56 <palomer> !
13:59:58 <vincenz> new google goody
13:59:59 <vincenz> http://www.google.com/notebook/fullpage
14:00:02 <davidhouse> Jackson: so a polynomial is a list of (coefficient, power) pairs?
14:00:05 <vincenz> palomer: mind if we discuss something in oasis
14:00:17 <palomer> not at all
14:00:22 <palomer> lemme finish this up though
14:00:23 <Cale> davidhouse: in his paste
14:00:27 <Jackson> David: Yes
14:00:36 <palomer> btw, how do you run a command line application from haskell?
14:00:43 <vincenz> hmm
14:00:43 <davidhouse> Cale, i thought i was missing something :) /me goes hunting
14:00:46 <vincenz> @hoogle system
14:00:47 <lambdabot> System.system :: String -> IO ExitCode
14:00:47 <davidhouse> palomer: System.Process
14:00:47 <lambdabot> System :: module
14:00:47 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
14:01:02 <Cale>  http://paste.lisp.org/display/20684
14:02:31 <davidhouse> Jackson, and what's the formula for generating a polynomial from a sequence? i can't remember it
14:03:33 <Jackson> Thats what I am writing now
14:03:34 <Cale> I think it's something to do with the falling factorial base for polynomials.
14:04:02 <Jackson> david: oh soz, misenterpreted that
14:05:33 <Jackson> basically the differences between the terms in a sequence defines each section of the polynomial
14:05:33 <Cale> Since if you define a "derivative", D(f(x)) = f(x+1) - f(x), and [x]^n = x (x-1) (x-2) ... (x-n+1), then D([x]^n) = n [x]^(n-1)
14:05:47 <davidhouse> > let f x = 2*x^3 + x^2 + 3*x +1 in map f [1..6]
14:05:48 <lambdabot>  [7,27,73,157,291,487]
14:06:13 * davidhouse thinks QuickCheck would come into its own here
14:07:12 * Jackson raises an eyebrow in question of 'QuickCheck'
14:07:21 <ihope> @hoogle color
14:07:22 <lambdabot> Text.Html.color :: String -> HtmlAttr
14:07:22 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
14:07:22 <lambdabot> System.Win32.Info.cOLOR_ACTIVECAPTION :: SystemColor
14:07:42 <Cale> QuickCheck is a library for testing properties of functions in Haskell
14:07:53 <ihope> cOLOR? Looks like somebody booched the caps lock :-)
14:08:01 <Cale> (basically, automagically generating test cases)
14:08:14 <Jackson> Ah, nice
14:08:18 <palomer> when ghc <<loops>>, is it possible to ask it when it's looping?
14:08:21 <Jackson> will have to take a look at that
14:08:34 <davidhouse> ihope, someone wants it all caps, but it's a function.
14:09:07 <Cale> palomer: I believe there's a profiling flag you can turn on which will give you some information about that
14:09:12 <Cale> -xc iirc.
14:09:32 <Cale> (look it up in the profiling section of the manual -- I think it's an RTS flag)
14:11:01 <davidhouse> @localtime dons
14:11:03 <lambdabot> Local time for dons is Thu Jun  1 07:03:36 2006
14:11:25 <davidhouse> dons, don't suppose you're up yet?
14:11:30 <norpan> @localtime norpan
14:11:33 <lambdabot> Local time for norpan is Wed May 31 23:11:09 2006
14:11:52 <ihope> @localtime ihope
14:11:54 <lambdabot> Local time for ihope is Wednesday, May 31, 2006 5:11:18 PM
14:12:02 <davidhouse> @localtime lambdabot
14:12:22 <davidhouse> ... looks like lambdabot doesn't respond to CTCP TIME reqs.
14:13:21 <davidhouse> Jackson: i'm not sure i/we can help you unless you either explain more fully the formula, or point us at a document that explains it. this is where you're stuck, right? i'm not misunderstanding?
14:13:59 <palomer> -xc doesn't tell me anything
14:14:03 <SamB> @localtime dons
14:14:04 <lambdabot> Local time for dons is Thu Jun  1 07:06:38 2006
14:14:50 <Jackson> This is where I am stuck, yes. Let me annotate that lisp with the information I have been given and that should hopefully help us all be able to help me :p
14:14:54 <ihope> @localtime fuebar
14:14:55 <lambdabot> Local time for fuebar is 5 something PM, probably May
14:15:04 <palomer> @hoogle fromJustError
14:15:04 <lambdabot> No matches found
14:15:10 <palomer> man, I wish such a function existed:/
14:15:21 <Cale> @localtime wurqiofha
14:15:53 <davidhouse> palomer: to do what?
14:15:56 <ihope> @type maybe
14:15:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:16:02 <davidhouse> @hoogle fromJust
14:16:03 <lambdabot> Maybe.fromJust :: Maybe a -> a
14:16:08 <davidhouse> > fromJust (Just 4)
14:16:09 <lambdabot>  4
14:16:12 <davidhouse> > fromJust Nothing
14:16:13 <lambdabot>  Add a type signature
14:16:13 <ihope> fromJustError x = maybe (error x) id
14:16:22 <davidhouse> fromJustError = fromJust ;)
14:16:30 <ihope> > fromJust Nothing :: (
14:16:30 <lambdabot>  Parse error
14:16:33 <ihope> > fromJust Nothing :: ()
14:16:34 <lambdabot>  Exception: Maybe.fromJust: Nothing
14:16:47 <ihope> > maybe (error x) id (Just "foo")
14:16:48 <lambdabot>  Not in scope: `x'
14:16:52 <ihope> > maybe (error "bar") id (Just "foo")
14:16:53 <lambdabot>  "foo"
14:17:01 <ihope> > maybe (error "bar") id Nothing :: String
14:17:02 <lambdabot>  Exception: bar
14:17:15 <palomer> right
14:17:17 <Cale> Jackson: let's look at it this way: suppose we're at the end of the list of differences, so we have a list of all equal elements
14:17:38 <Cale> Jackson: this is a nice base case, and we immediately know that this is just a constant polynomial
14:17:49 <palomer> fromJustError a b = maybe (error b) id a
14:18:53 <Cale> Jackson: now, suppose that we know that the list of differences is given by some polynomial g such that g(n) = f(n+1) - f(n)
14:18:55 <norpan> i just learned that you want fromMaybe
14:19:09 <Cale> and we're trying to find f
14:19:12 <norpan> maybe a id b = fromMaybe a b
14:19:43 <Cale> more precisely, we'd like to know the coefficients of f, as we already know its values at a bunch of points
14:19:45 <xerox> If g(n) = f(n+1) - f(n) / n then you integrate (-:
14:19:46 <Revision17> Is there an efficient way to create a restricted integral numeric type without having to rewrite all the type classes of it (such as a Word that can only be between 15-31 or something)?
14:19:46 <davidhouse> @hoogle fromMaybe
14:19:47 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
14:19:53 <ihope> Ah.
14:20:06 <Cale> xerox: yeah, it's a sort of integration
14:20:12 <ihope> @type Maybe.fromMaybe . error
14:20:13 <lambdabot> forall b. [Char] -> Maybe b -> b
14:20:13 <Cale> (though not the usual sort)
14:21:01 <xerox> Revision17 - Value invariants are not handy in Haskell.
14:21:52 <palomer> man, I wish there was a C++ style return for IO
14:22:07 <xerox> callCC (:
14:22:24 <Cale> Jackson: following so far?
14:22:37 <Revision17> xerox: not handy, as in don't exist, or aren't good to use?
14:22:48 <Cale> Revision17: as in don't exist
14:22:54 <Revision17> :-\
14:23:08 <Cale> well, not quite true
14:23:12 <xerox> I suppose you can do something.
14:23:33 <xerox> Either error on fromIntegral or encode your numbers as types.
14:23:35 <Cale> but the only things you could do to represent values in types are incredibly unwieldy.
14:23:42 <xerox> But again, that's not handy :-(
14:24:08 <Revision17> so the only way is data MyNums = One | Two | Thee | Four or something like that?
14:24:23 <Cale> Revision17: the problem comes down to the fact that determining that a function really only returns a value between 15 and 31 is really hard for the compiler to do
14:24:40 <Cale> (unless it's just structurally impossible)
14:24:43 <lisppaste2> Jackson annotated #20684 with "Polynomial" at http://paste.lisp.org/display/20684#1
14:24:59 <xerox> Still, it is only 16 data constructor, it could be done I think, well...
14:25:19 <Jackson> Whoops, sorry, though you wanted more of an explanation
14:25:26 <Jackson> 2 secs lemme just read what has been said
14:25:28 <Revision17> Cale: I suppose so; I was just thinking of an easy way to somehow I could make a data structure which uses numbers and couldn't exist in a state it shouldn't
14:25:49 <Revision17> xerox: I just gave those numbers out randomly
14:25:57 <xerox> You could also do arithmetic mod 16 (-:
14:26:04 <xerox> haha, okay.
14:27:30 * xerox sits on the bench there waiting for Cale's Not-Usual Integration Method (:
14:27:45 <Jackson> yep, follow what you said, little bit shakey on it but following
14:28:13 <ihope> Arithmetic mod 16...
14:28:43 <ihope> I can tell you what 912749128375834670923841294^92749023583947369745 mod 16 is :-)
14:29:16 <norpan> 0?
14:29:25 <Cale> Jackson: oh, they give you an algorithm
14:29:26 <xerox> > 912749128375834670923841294^92749023583947369745 `mod` 16
14:29:27 <ihope> > 912749128375834670923841294 `mod` 16
14:29:30 <lambdabot> Terminated
14:29:30 <lambdabot>  14
14:29:39 <ihope> > 92749023583947369745 `mod` 8
14:29:40 <lambdabot>  1
14:29:44 <ihope> 14, then.
14:29:51 <norpan> no
14:29:54 <Revision17> ghci ran out of memory on my machine :-\
14:29:58 <ihope> No?
14:30:04 <norpan> mod is not distributive over ^
14:30:06 <Jackson> yarr, and thats the one that I am having difficulty intergrating :(
14:30:46 <Cale> So, you can easily work out how many times you have to take the differences to get a constant list
14:30:56 <ihope> norpan: x^y mod z = (x mod z)^(y mod phi(z)) mod z, correct?
14:31:10 <Cale> and getting hold of that last list is easy enough, as is getting its first element
14:32:14 <Cale> so you can get the first coefficient by just dividing that by n!, where n was the length, I see you're doing that there
14:32:15 <norpan> i need to sleep
14:32:40 <Cale> so nextTerm does that nicely, and newSequence subtracts off the contribution of that term
14:32:58 <Cale> so polynomial is going to return nextTerm of the sequence it's given
14:33:17 <Cale> followed by the polynomial of the newSequence of that sequence
14:33:21 <Revision17> hmm, python seems to be chugging away at that exponentiation and hasn't died yet ( /me wonders how long it will take)
14:33:50 <Cale> Revision17: forever
14:34:07 <Cale> (until your machine runs out of memory)
14:34:29 <Cale> It's 0 mod 16
14:34:54 <ihope> Cale: 912749128375834670923841294 mod 16 isn't 0.
14:35:09 <Cale> ihope: the power is though
14:35:19 <Revision17> hmm, it took 23 seconds to raise it to the 100,000th power; yea I guess it will take forever
14:35:21 <ihope> > 92749023583947369745 `mod` 8
14:35:22 <lambdabot>  1
14:35:28 <ihope> 1 /= 0.
14:35:38 <ihope> And if it were 0, the answer would be 1.
14:35:43 <Cale> no, not the exponent
14:35:46 <Cale> the power
14:35:49 <ihope> Oh.
14:36:01 <Cale> (the whole expression)
14:36:14 <ihope> ...But isn't the whole expression equal to 14^1 mod 16?
14:41:05 <Cale> hmm, interesting
14:41:23 <davidhouse> yay!
14:41:25 <davidhouse> > 2 + 2
14:41:26 <lambdabot>  4
14:41:26 <mbot>  4
14:41:28 <davidhouse> hehe :)
14:41:32 <Cale> % PowerMod[912749128375834670923841294,92749023583947369745,16]
14:41:33 <mbot> Cale: 0
14:41:39 <xerox> Uh.
14:41:52 <Cale> % PowerMod::usage
14:41:52 <mbot> Cale: "PowerMod[a, b, n] gives a^b mod n. For negative b, PowerMod[a, b, n] gives modular inverses."
14:42:11 * davidhouse patched lambdabot to fix @type output
14:42:28 <davidhouse> by "fix" i mean "concat it all onto one line, stop its rubbish pretty printing"
14:42:37 <Cale> % Mod[912749128375834670923841294,16]^Mod[92749023583947369745,EulerPhi[16]]
14:42:38 <mbot> Cale: 14
14:42:44 <xerox> May I try a bot loop ? (:
14:42:49 <Cale> could it be a bug?
14:43:01 <vincenz> where is lambdabot 
14:43:02 <ihope> Cale: the #math guys explained it.
14:43:05 <vincenz> > !
14:43:05 <mbot>  Parse error
14:43:05 <lambdabot>  Parse error
14:43:12 <ihope> <mnvl> of course the answer is 16, or 0 if you prefer, because 91274...294 is even, and you raise it to the power of at least 4
14:43:35 <Jackson> Any idea how to implement the alogorith I have been given?
14:43:36 <Cale> oh, of course
14:44:00 <Cale> hehe, you confused me, Euler's theorem only works when the base is coprime to n
14:44:04 <Jackson> read over course notes again but couldnt find anything i thought useful
14:44:12 <xerox> @id 1
14:44:12 <mbot> 1
14:44:12 <lambdabot> 1
14:44:16 <Cale> Jackson: I just mentioned how
14:44:20 <xerox> Danger.
14:44:37 <Cale> Jackson: you return a list whose first element is the result of nextTerm
14:44:45 <davidhouse> @seen mbot
14:44:45 <mbot> Yes, I'm here. I'm in #haskell, ##engineering and #math
14:44:45 <lambdabot> mbot is in #haskell. I last heard mbot speak 33 seconds ago.
14:44:50 <Cale> and where the rest is the polynomial of the result of newSequence
14:44:55 <Cale> (using that first term)
14:45:14 <Cale> mbot: @part
14:45:20 <Cale> mbot: @part #haskell
14:45:32 <mauke> why doesn't lambdabot exit on EOF (in offline mode)?
14:46:36 <davidhouse> mauke: because it's broken. submit a patch and fix it!
14:46:47 <mauke> still working on getting it to compile
14:47:09 <mauke> apparently the first time only worked because I reinstalled ghc in the middle
14:53:19 <davidhouse> i wish there were a shortcut function for (concat .) . intersperse
14:53:53 <ihope> !
14:53:54 <mauke> module Perl where join =
14:54:07 <davidhouse> ihope, ?
14:54:17 <ihope> davidhouse: what's that do?
14:54:44 <davidhouse> > (concat .) . intersperse $ ", " ["hello", "world", "foo", "bar]
14:54:44 <lambdabot>  Improperly terminated string
14:54:47 <davidhouse> > (concat .) . intersperse $ ", " ["hello", "world", "foo", "bar"]
14:54:48 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
14:55:07 <davidhouse> > ((concat .) . intersperse) ", " ["hello", "world", "foo", "bar"]
14:55:08 <lambdabot>  "hello, world, foo, bar"
14:55:15 <AtnNn> @type intersperse
14:55:16 <lambdabot> forall a. a -> [a] -> [a]
14:55:39 <ihope> @type (concat .) . intersperse
14:55:39 <davidhouse> @pl \s ss -> concat $ intersperse s ss
14:55:40 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:55:40 <lambdabot> (join .) . intersperse
14:55:48 <davidhouse> join is showing off.
14:55:56 <ihope> @hoogle [a] -> [[a]] -> [a]
14:55:56 <lambdabot> No matches, try a more general search
14:56:02 <ihope> Mmh.
14:56:49 <davidhouse> when building lambdabot, does every *.hs file in Plugin/ count as a plugin?
14:56:56 <davidhouse> or do i have to explicity declare it somewhere
14:57:14 <davidhouse> e.g. i've just written a new plugin. do i have to tell some config file it exists/
14:58:53 <palomer> gah, I can't get hat to work
14:59:32 <palomer> http://www.rafb.net/paste/results/uEVn5L94.html
15:00:49 <palomer> why is finding the location of a loop so bloody hard in haskell!
15:00:49 <Jackson> Ok well thank you all very much for the help you have given me
15:00:50 <palomer> gah!
15:01:18 <Jackson> Its really good to see such a community exists for this langauge and I hope I talk to you all again
15:01:40 <Jackson> Till then have fun with all your projects and best of luck
15:01:52 <palomer> yeah, ditto
15:01:56 * palomer kills haskell
15:04:22 <palomer> ok, if someone can find my loop ill give them a cookie
15:05:59 <palomer> if a loops, then trace "foo" a will never print foo, right?
15:07:27 <ihope> I think so.
15:07:58 <AtnNn> palomer: what is your code that loops?
15:09:08 <SamB_XP> wouldn't the cookie crumble in shipping, anyway?
15:10:04 <palomer> AtnNn: it's really long
15:10:17 <palomer> I just wish haskell had these basic tools
15:11:07 <SamB_XP> comment out constraints that ought to be needed?
15:11:25 <SamB_XP> then, if you don't get a type error, you've got your loop...
15:12:53 <monochrom> I am interested.
15:13:13 <monochrom> (where is the code?)
15:14:07 <monochrom> Oh, the code is long.  I am less interested. :)
15:17:34 * monochrom sermons on a programming methodology that never gets one into such a situation that you have huge code and you don't know what happens.
15:18:28 <SamB_XP> *which* programming methodology?
15:19:20 <ihope> The programming methodology that never gets one into such a situation that you have huge code and you don't know what happens.
15:19:42 <monochrom> bottom up in implementation (top down in planning), small pieces, unit testing, even unit proving if necessary.
15:22:12 <davidhouse> what's the difference between bottom up and top down?
15:22:21 * davidhouse knows this is one of the definitions he really should remember
15:22:45 <vincenz> hi monochrom 
15:23:07 <ihope> I think bottom up is doing the details first, then slowly working up to the "main" thingy.
15:23:27 <ihope> Top down would be writing main first, then writing all the values it needs.
15:23:50 <monochrom> If you program by proving, top down is the way to go.
15:24:06 <monochrom> If you program by testing, bottom up is the way to go.
15:24:50 <ihope> Because with top down, you can't test until the very end?
15:25:18 <monochrom> Right.
15:25:52 <davidhouse> well i'm pretty bottom-up.
15:25:58 <ihope> And proving works either way, so you use top-down because it's better? :-)
15:26:02 <davidhouse> i need to work on TDD and using darcs more
15:26:06 <monochrom> We all program by testing.  That explains a lot.
15:26:45 <JohnnyL> heya monochrom weren't you a #lisp regular?
15:27:02 <fanopnaic> enormously dumb question: How do I end ghci gracefully?
15:27:22 <davidhouse> fanopnaic: :quit? C-c? C-d? C-z?
15:27:22 <monochrom> Proving works either way.  But top down is more, how should I say it, more vision-guided, you know why you're working on each particular piece.
15:27:52 <fanopnaic> ah, forgot the colon. thx
15:27:59 <monochrom> JohnnyL: No, never been.
15:30:06 * ihope likes ^D
15:30:26 <petekaz> Well, in bottom-up programming, one builds the foundation, an abstraction barrier at the lowest level.  Then you build your next abstraction layer atop of that, etc ...
15:31:21 <JohnnyL> monochrom, how about #zen?
15:31:29 <monochrom> No.
15:31:32 <mahogny> top down planning, bottom up coding. that's the way to go
15:32:07 <monochrom> On freenode, I have only been to #haskell, #haskell-blah, #math
15:32:44 <JohnnyL> ok
15:33:20 <monochrom> I forgot #ocaml.  But I have left #ocaml for long.  (Nothing to contribute there.)
15:36:24 <vincenz> monochrom: yeah very silent
15:40:18 <palomer> http://www.rafb.net/paste/results/Lsps4689.html
15:40:23 * palomer is puzzled
15:41:31 <Lemmih> palomer: The argument is 'fix id'?
15:41:46 <palomer> how can I check?
15:42:17 <Lemmih> > let fn (Just _) = ""; fn a = "" in fn (Just 10)
15:42:18 <lambdabot>  ""
15:42:19 <Lemmih> > let fn (Just _) = ""; fn a = "" in fn (fix id :: Maybe Int)
15:42:20 <lambdabot>  Terminated
15:42:44 <palomer> @hoogle isBottom
15:42:45 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
15:43:04 <SamB_XP> how how how?
15:43:08 <Lemmih> Test.QuickCheck.Batch.isBottom doesn't detect non-termination.
15:43:21 <SamB_XP> and yeah, you can't detect that!
15:43:25 <monochrom> Interesting!
15:43:29 <dcoutts> @localtime dons
15:43:31 <lambdabot> Local time for dons is Thu Jun  1 08:36:03 2006
15:43:31 <palomer> oh, it is bottom
15:43:35 <SamB_XP> unless it prints out <Loop> or whatever
15:43:41 <palomer> it does print out loop
15:43:43 <palomer> <<loop>>
15:43:51 <palomer> and I'm wondering where its looping
15:43:53 <SamB_XP> > loop = loop in loop
15:43:53 <lambdabot>  Parse error
15:44:05 <SamB_XP> > let loop = loop in loop
15:44:05 <lambdabot>  Add a type signature
15:44:14 <SamB_XP> > let loop = loop in loop :: ()
15:44:15 <lambdabot>  Terminated
15:44:31 <SamB_XP> not very usefull...
15:44:49 <palomer> > let loop = loop in Test.QuickCheck.Batch.isBottom loop
15:44:50 <lambdabot>  Not in scope: `Test.QuickCheck.Batch.isBottom'
15:44:57 <palomer> oh you silly cow
15:45:57 <davidhouse> > map (==undefined) [1..4] ++ [undefined] ++ [6..10]
15:45:57 <lambdabot>  add an instance declaration for (Num Bool)
15:45:57 <lambdabot>   In an arithmetic sequence: [6...
15:46:00 * palomer wishes there was a hasBottom typeclass
15:46:01 <davidhouse> > map (==undefined) $ [1..4] ++ [undefined] ++ [6..10]
15:46:02 <lambdabot>  Undefined
15:46:11 <davidhouse> you can't test for bottom-ness.
15:46:18 <palomer> isBottom!
15:46:18 <davidhouse> palomer: every type can be bottom.
15:46:28 <palomer> every type contains bottom, sure
15:46:49 <Lemmih> "not me!"#
15:47:07 <Cale> You can test for bottom-ness when the bottom is actually an exception and not nontermination.
15:47:17 <davidhouse> Lemmih: shush. :)
15:47:20 <Cale> Though you can really do it only from IO
15:47:33 <palomer> is that the only case in which you can test for bottom ness?
15:47:45 <Cale> unsafePerformIO gives you a way to turn that back into a "pure" result
15:48:00 <Cale> yeah, since it's obviously impossible to test for nontermination in general
15:48:18 <palomer> but why would it output <<loop>> if it wasn't nontermination?
15:48:37 <davidhouse> err, that 'obvious' result took Turing quite a while to prove, Cale ;)
15:49:11 <Cale> davidhouse: Everything, once proved, is 'obvious'.
15:49:18 <Cale> :)
15:49:25 <davidhouse> well...
15:49:32 <Cale> It throws the exception <<loop>> when a thunk is re-entered.
15:49:32 <palomer> when ghc prints out <<loop>>, isn't it detecting non termination?
15:49:44 <palomer> Cale: I don't understand what you just said
15:50:27 <Cale> It's detecting a very restricted form of nontermination, and reflecting that as an exception.
15:50:50 <palomer> is it possible to find out where this occured?
15:50:56 <Cale> not easily
15:50:58 <lisppaste2> monochrom pasted "doesn't seem to loop" at http://paste.lisp.org/display/20689
15:51:02 <palomer> or am I left poking everywhere in my code
15:51:17 <palomer> because any piece of code could have deposited that bottom there
15:51:19 <Cale> break your code into chunks and test them separately
15:51:24 <monochrom> palomer: that's for you.  I made a minimal completion of your code and I cannot make it loop.
15:52:05 <palomer> monochrom: yeah, it loops on a cortain value
15:52:05 <Cale> look for definitions like   x = f x
15:52:09 <palomer> which contains bottom
15:52:17 <palomer> s/cortain/certain
15:55:46 <davidhouse> @hoogle Either a b -> Maybe b
15:55:46 <lambdabot> No matches, try a more general search
16:05:12 <davidhouse> happy june, everyone.
16:05:43 <SamB_XP> davidhouse: not quit everyone
16:06:25 <davidhouse> SamB_XP: it's june in the One True Timezone
16:08:05 <mauke> Distribution/PackageDescription.raw-hs:293:25: parse error in doc string: []
16:08:07 <mauke> !!! ERROR: dev-lang/ghc-6.4.2 failed.
16:08:12 <mauke> argh
16:08:55 <dcoutts> hmm
16:09:08 <dcoutts> that'd be a gentoo build error
16:09:18 <mauke> yep
16:09:29 <dcoutts> if you can paste that log into an error report that'd help
16:09:36 <dcoutts> especially if it's repeatable
16:10:34 <vincenz> dcoutts: mind if I ask you a question
16:10:42 <dcoutts> @yarr!
16:10:42 <lambdabot> I'll keel haul ya fer that!
16:10:46 <vincenz> regarding the operators
16:10:51 <vincenz> you mentioned using a simple stack parser
16:10:55 <vincenz> now the question is
16:10:59 <vincenz> what kind of data type do you use?
16:11:08 <vincenz> [(String, Exp)]?
16:11:25 <davidhouse> @hoogle skipMAny
16:11:25 <lambdabot> Text.ParserCombinators.ReadP.skipMany :: ReadP a -> ReadP ()
16:11:26 <lambdabot> Text.ParserCombinators.Parsec.Prim.skipMany :: GenParser tok st a -> GenParser tok st ()
16:11:26 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
16:11:27 <vincenz> cause I don't see what to put in as string for the last one?
16:14:34 <lisppaste2> davidhouse pasted "check it out!" at http://paste.lisp.org/display/20691
16:14:44 <davidhouse> haha! the fruits of my labour ^^
16:15:20 <dons> morning
16:15:38 <davidhouse> hey dons.
16:15:43 <dcoutts> g'moring dons 
16:15:49 <dcoutts> I've got a pile of patches for you
16:15:55 <davidhouse> dons, check out ^^ that paste. look like an interesting plugin?
16:16:06 <dcoutts> vincenz, hmm, true, I don't recall how I did it
16:16:14 <dons> patches and plugins. good morning, #haskell!
16:16:14 <dcoutts> vincenz, it's not that tricky though
16:16:26 <dcoutts> dons, so I've been renaming some things...
16:16:29 <dons> oh, nice davidhouse 
16:16:37 <dons> dcoutts, oh, ok.  like what?
16:16:46 <vincenz> dcoutts: I guess just an ""
16:16:53 <vincenz> dcoutts: how do you deal with infixl and infixr?
16:17:01 <dcoutts> dons, I looked at the create/generate/createWithResize/mallocByteStringWith stuff
16:17:09 <dons> yeah?
16:17:17 <jethr0> davidhouse: thx for the mail, happy i could help
16:17:27 <davidhouse> dons, i'll patch up in the morning. there's one more peace of functionality i want to add, + haddockising the module.
16:17:30 <dcoutts> vincenz, that's all part of the stack algo, try looking it up
16:17:34 <davidhouse> jethr0: no problem.
16:17:43 <dons> looks good davidhouse. cheers
16:17:43 <SamB_XP> vincenz: maybe you just never put the last expr on the stack?
16:17:49 * davidhouse goes to bed
16:17:51 <dcoutts> dons, so I've eliminated mallocByteString and mallocByteStringWith
16:18:10 <dcoutts> dons, I've renamed create to unsafeCreate
16:18:15 * jethr0 too
16:18:19 <dcoutts> dons, createAndResize -> createAndTrim
16:18:31 <dons> ok. i was thinking of moving create into IO anyway
16:18:32 <dcoutts> dons, and added create
16:18:39 <dcoutts> which is in IO
16:18:46 <dcoutts> unsafeCreate l f = unsafePerformIO (create l f)
16:18:50 <dons> ah. ok. i'll read some patches. these sound reasonable.
16:18:55 <dons> ok.
16:19:00 <dcoutts> then there is also createAndTrim'
16:19:20 <dcoutts> which is a generalisation of createAndTrim for use by loopU loopWrapper and unforlrN
16:19:28 <dons> ok
16:19:34 <dcoutts> createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
16:19:38 <jethr0> gom
16:19:54 <dons> brackets look good, too. and the asserts
16:20:00 <dcoutts> dons, oh an I've moved all the foreign imports into IO
16:20:14 <Mag1KaL> Ok, I'm trying to learn haskell but I have a question... Lazy evaluation does seem useful but why is it the required for the whole program? Wouldn't it make more sense to be strict unless otherwise stated?
16:20:24 <dons> dcoutts: oh, is that necessary for safety?
16:20:29 <dcoutts> dons, that is memchr, c_maximum, c_minimum, c_strlen
16:20:38 <dcoutts> dons, well it makes the unsafeness more explicity
16:20:43 <dons> ok :)
16:20:52 <dcoutts> dons, and actually most of the time we were using them in IO context anyway
16:20:56 <dons> yeah. 
16:21:03 <SamB_XP> Mag1KaL: well, if you did that, to get anything out of it you'd need to put annotations simply *everywhere*
16:21:11 <dons> i seem to recall somewhere where it was important to not be in io, to get tail recursion?
16:21:16 <dons> dcoutts: did you see that?
16:21:38 <dcoutts> hmm
16:21:39 <dons> oh, you fixed the io code, good stuff
16:21:54 <SamB_XP> make simons fix compiler!
16:21:58 <Lemmih> Mag1KaL: And lazy evaluation keeps us from making deals with the devil.
16:22:01 <dons> i.e. x <- f ; xs <- fs ; return (x :xs) could be avoided
16:22:04 <dcoutts> dons, probably elemIndices or split
16:22:23 <dons> since we could just write: x <-f ; return $ x : fs xs 
16:22:26 <dcoutts> dons, so for the cases where we wern't in IO anyway I added an unsafePerformIO
16:22:30 <dons> ah. ok
16:22:36 <dcoutts> dons, which was only two cases of memchr
16:22:51 <dcoutts> otherwise it was mostly a case of changing:
16:22:55 <dcoutts> let p = memchr ...
16:22:56 <dons> all the patches you sent me are good to apply?
16:22:59 <dcoutts> p <- memche
16:23:04 <dons> yep . that's fine
16:23:08 <dcoutts> dons, yes so far
16:23:08 <Mag1KaL> Maybe but what about these space leaks that lazy evaluation seems to be involved with?
16:23:21 <dons> Mag1KaL: easy to avoid with profiling.
16:23:28 <dons> they're not that common anyway
16:23:34 <dcoutts> dons, I'm still recording a few more patches...
16:24:28 <dcoutts> or rather I'm recording and sending these ones I've just been describing
16:24:32 <dons> yep
16:24:37 <SamB_XP> the thing is that it is much easier to add strictness than to take it away
16:24:41 <Mag1KaL> Another question I have is, well... why is haskell so damned slow?
16:24:46 <dons> ?shootout
16:24:46 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:24:52 <dons> its one of the fastest languages out there.
16:24:55 <dons> perhaps you're not using -O ?
16:25:04 <SamB_XP> because it isn't?
16:25:04 <dons> otherwise, consider reading:
16:25:07 <dons> ?wiki Performance
16:25:07 <lambdabot> http://www.haskell.org/haskellwiki/Performance
16:25:10 <SamB_XP> because it hasn't been fasted enough yet?
16:25:31 <SamB_XP> though, I've never known it to eat anything anyway...
16:25:48 <dons> Mag1KaL: do you have a specific code problem that is running slowly? and you're using the compiler with optimisations on?
16:26:12 <dons> Mag1KaL: you using ghc?
16:26:40 <Mag1KaL> Yes. I could probably get it going much faster but at the cost of code readability I would imagine.
16:27:01 <dons> unlikely. what's the problem specifically?
16:27:14 <dons> perhaps you're just using the wrong data structures. or trolling...
16:27:24 * Lemmih thinks the latter.
16:27:50 <SamB_XP> or, perhaps, you just don't know where to add a little strictness?
16:27:53 <dons> i.e. have you looked at a) the performance wiki page, b) profiling your code c) strict data structures ?
16:28:05 <Mag1KaL> Yes I'm trolling I started learning haskell because I wanted to troll on #haskell
16:28:43 <dons> its possible, since you have yet told us what specifically is running slowly, but rather make general claims about a language being slow (when its the specific implementation, under specific conditions...)
16:28:58 <SamB_XP> Mag1KaL: what, you don't think anyone would *claim* to be learning who isn't actually?
16:29:08 <dons> and the general experience in this channel has been that ghc haskell is rather fast, usually faster than C++, sometimes faster than C
16:29:42 <Lemmih> Mag1KaL: Instead of asking why Haskell is so damn slow, say "Hi, can you guys help me optimize my program?".
16:30:12 <Mag1KaL> It's not like I meant it as a personal insult to people using haskell or something.
16:30:39 <dons> do you have specific example that you'd like help with?
16:30:46 <SamB_XP> @lisppaste
16:30:47 <lambdabot> Unknown command, try @list
16:30:53 <SamB_XP> lisppaste2: help!
16:30:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:32:53 <Mag1KaL> How do I profile haskell code?
16:33:05 <dons> you compile , using ghc, with -prof -auto-all
16:33:10 <dons> then run your program with +RTS -p
16:33:21 <dons> the full profile dump will be in the file "foo.prof"
16:33:25 <Mag1KaL> Ok, thanks.
16:33:36 <SamB_XP> you also make sure you built/installed the profiling libraries
16:33:38 <dons> make sure also to turn on -O
16:34:12 <joe_k> does -O diminish the usefulness of the profiler due to any inlining or other optimizations?
16:34:56 <dons> no, it increases the usefulness, since it tells you what your code is doing in the real world, since you wouldn't ship a program without -O
16:35:11 <dons> it understands inlining.
16:35:23 <Mag1KaL> Heh, the haskell shootout scores are alot better then the last time I looked.
16:35:49 <dons> we've actually slipped a bit recently, we had the number one spot in february-march for a while
16:36:01 <dons> i expect to regain it, or come close, once the new compiler is out
16:36:13 <joe_k> when will that be?
16:36:20 <joe_k> how can it be faster than c if it emits c?
16:36:40 <dons> we have better optimisations, since the compiler can reason on a higher level. our concurrency is better
16:36:47 <dons> we have better tail recursion
16:36:48 <mauke> it emits insane c
16:36:52 <joe_k> heh
16:36:57 <SamB_XP> yeah, I was about to say
16:37:01 <joe_k> is there a flag to output the generated C?
16:37:09 <SamB_XP> it is faster than C that any sane person would *write*
16:37:25 <SamB_XP> yes, you can get it to leave the C for you to look at
16:37:41 <mauke> -C
16:37:46 <SamB_XP> however, in GHC's case it is not only insane but improperly indented and with a horrible coding style
16:37:59 <SamB_XP> JHC does a bit better
16:38:08 <dons> for example, http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
16:38:33 <dons> and http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
16:38:44 <dons> though i see ocaml and ml have improved there. those sneaks!
16:38:47 <SamB_XP> the C it outputs is of course not readable or maintainable in any way
16:39:29 <Mag1KaL> I wish those haskell/functional programming video lectures were smaller... low quality is +500MB each.
16:39:37 <dons> oh, and concurrency isn't C's strong point: http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=all
16:41:44 <joe_k> i want to learn erlang
16:41:58 <ricebowl> is there any way to get a list of all the values for an instance of Enum?
16:42:00 <Mag1KaL> When should the new stable GHC come out?
16:42:58 * dcoutts runs QC tests before dumping patches on dons 
16:43:25 <mauke> random sample of ghc-generated c code: http://rafb.net/paste/results/JR97Mm27.html
16:43:39 <dcoutts> ricebowl, if it's also an instance of Bounded then yes
16:43:44 <mauke> ricebowl: [toEnum 0 ..]
16:43:57 <joelr1> howdy folks
16:44:09 <ricebowl> mauke - it's not an integral type
16:44:18 <joelr1> any idea why www.scannedinavian.org is not resolving?
16:44:26 <ricebowl> @hoogle [a] -> [a] -> Bool
16:44:26 <dcoutts> ricebowl, enumFromTo minBound maxBound
16:44:26 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
16:44:26 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
16:44:36 <dcoutts> joelr1, try www.scannedinavian.com
16:44:38 <ricebowl> does Enum imply Bounded?
16:44:43 <dcoutts> ricebowl, no
16:45:01 <joelr1> dcoutts: thanks!
16:45:48 <joelr1> hmm
16:45:52 <dcoutts> dons, grrr, concatMap is soooo slooo
16:46:06 <joelr1> Lemmih: ping
16:46:17 <joelr1> where is the conjure darcs repo these days?
16:46:36 <joelr1> things used to be at www.scannedinavian.org/~lemmih but no longer
16:46:40 <dcoutts> dons, woo! I didn't break anything (at least not anything that the QC tests noticed)
16:46:42 <ricebowl> @pl \f a b -> (f a, f b)
16:46:42 <lambdabot> flip =<< (((.) . (,)) .)
16:46:49 <ricebowl> @pl \f (a, b) -> (f a, f b)
16:46:50 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:47:38 <dons> dcoutts: cool.
16:47:56 <Lemmih> @where conjure-alt
16:47:57 <lambdabot> http://darcs.haskell.org/~lemmih/conjure
16:48:08 <joelr1> he
16:48:14 <joelr1> Lemmih: thanks
16:49:07 <joelr1> Lemmih: what's the difference between HaSP and HSP again? is that described anywhere?
16:49:26 <joelr1> i think the former is continued development of the latter, right?
16:49:49 <dons> dcoutts: i notice concatMap is slow. noticed that too?
16:50:00 <dcoutts> aye
16:50:01 <Lemmih> joelr1: It's a fork.
16:50:02 * dons waits on another test run
16:50:08 <Lemmih> joelr1: http://article.gmane.org/gmane.comp.lang.haskell.general/12617
16:50:17 <dcoutts> dons, I think it's O(n^2) atm
16:50:31 <joelr1> Lemmih: reading
16:50:43 <dons> yeah. its one of these things whose complexity goes nutty on arrays
16:50:58 <dons> and its a manually fused concat . map, approx, in the list library?
16:51:11 <dcoutts> yep
16:51:21 <dons> hmm.
16:51:25 <dcoutts> or actually I was hacking on that version too
16:51:35 <dcoutts> neither are optimal I think
16:51:47 <joelr1> Lemmih: any particular advantage to dropping support for xml in patterns?
16:52:57 <Lemmih> joelr1: I was just too lazy to re-implement it.
16:52:57 * dons notes 641 patches in the fps repo
16:53:20 <joelr1> Lemmih: how do you work around it? you have no need to match xml?
16:54:16 <Lemmih> joelr1: I didn't see the use for it. Unpacking XML seemed rather pointless.
16:54:34 <joelr1> Lemmih: hmm...
17:05:37 <stepcut> speaking of optimization, *without* -O2 -funbox-strict-fields my program runs in 34 seconds, *with* -O2 -funbox-strict-fields, it runs in 0.7 seconds
17:05:46 <dons> :)
17:05:57 <dons> what kind of data structures?
17:06:10 <dons> strict ones, i guess
17:06:34 <Cale> what about with -O2, but without -funox-strict-fields?
17:06:36 <Cale> b*
17:06:40 <stepcut> Parses a 16MB debian control file into a [[(ByteString, ByteString)]] 
17:06:49 <stepcut> Cale: around 2s, I believe
17:07:06 <dons> ah. yeah, you'll want that -O for the inlining to kick in, and the fusion to take place
17:07:22 <dons> is 0.7s fast enough?
17:07:28 <dons> ;)
17:07:31 <stepcut> 2 seconds was fast enough ;)
17:07:46 <dons> I always use both when working on ByteStrings
17:08:11 <dons> its possible you might be able to get a tad more with -fliberate-case-threshold200
17:08:18 <stepcut> heh
17:08:24 <dons> or possibly something evil will happen. either way.
17:08:58 <stepcut> well 0.7 seconds is good enough for that part. The next part of the code takes 10 mins to run -- so I think I know where to look next
17:09:11 <dons> hehe 
17:09:25 <stepcut> In theory I should be able to drop that 10mins to around 10secs
17:16:03 <Cale> Is the list of pairs of ByteStrings really a Map?
17:18:09 <monochrom> Oh man, if you can drop from 10min to 10sec you're bad, bad, bad.
17:18:49 <Cale> hey, this passage from the Age of Wire and String is particularly translatable.
17:21:07 <Cale> It seems to describe convection, except that the heated fluid is being referred to as "dog" and heat as "barking", liquid has been replaced with "hair"
17:21:40 <joe_k> heh
17:23:33 <stepcut> monochrom: :p
17:24:13 <dons> oh my: "    Lately, in my quest to get a better understanding of the typeclass
17:24:13 <dons> system, I've been writing my typeclass instance declarations in Prolog
17:24:13 <dons> first, then when I've debugged them, I port them over back over to
17:24:14 <dons> Haskell."
17:24:32 <stepcut> dons: yeah, I just saw that...
17:24:45 <stepcut> dons: sounds like a new plugin for lambdabot in the works ;)
17:24:53 <dons> hehe
17:28:54 <Mag1KaL> Where can I get the code for lamdabot?
17:29:03 <dons> ?version
17:29:03 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
17:29:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:29:39 <dons> or, alternately
17:29:42 <dons> ?google lambdabot
17:29:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:29:47 <dons> :)
17:29:49 <SamB_XP> also
17:29:52 <SamB_XP> @source
17:29:52 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
17:29:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:29:53 <mux> soon in GHC 7.0 !
17:29:58 <dons> ?where lambdabot
17:29:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:30:09 <dons> ?gwiki lambdabot
17:30:11 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
17:30:14 <dons> come on. close..
17:31:16 <Mag1KaL> Sorry about my cracks about GHC speed, I didn't realize how much work has been done on it since I last checked Haskell out some time ago...
17:32:54 <Cale> Mag1KaL: you had a question about lazy evaluation?
17:33:01 <Cale> Was that answered?
17:34:04 <Cale> The reason that we like lazy evaluation to be the default is that it makes code much more reusable in general, and can make algorithms which would otherwise have poor time complexity actually practical.
17:34:05 * mux wonders if vim7 has intelligent completion for haskell :-)
17:34:23 <mux> I guess they could recode djinn in vimscript, heheh
17:35:19 <Cale> It allows for much greater "separation of concerns" -- you can separate code which generates structures from code which searches through them or prunes them more often.
17:35:32 <Cale> I could give a whole bunch of examples if you'd like.
17:36:12 <Mag1KaL> No that's all right.
17:36:48 <mux> dons: can I grab a snapshot of FPS on darcs as of now and expect it to be stable enough for NewCGI to work?
17:36:54 <Mag1KaL> It's just hard getting used to it.
17:37:51 <dons> mux, oh its very stable, yes.
17:38:06 <dons> nothing goes in unless all 3k lines of QC properties pass
17:38:30 <Cale> My favourite example is this implementation of determining if one string is a substring of another:  isSubstringOf x y = any (isPrefixOf x) (tails y)
17:40:11 <Cale> In a strict language, you wouldn't be able to reuse code in this way, (any, tails, isPrefixOf) or at least you wouldn't want to because it would be stupidly inefficient.
17:40:17 <Spark> doh, acm portal is down :(
17:41:01 <Spark> Windows NT error number 2 occurred.
17:41:03 <Spark> apparently
17:41:17 <Cale> In a lazy language, this is essentially the same as the nested loops with early break-out approach that you'd implement in an imperative language -- except that you're making use of these components that have been written already for you.
17:43:25 <Mag1KaL> So if those are some of the advantages, what are some of the disadvantages?
17:44:07 <mux> dons: ok; thanks :)
17:44:27 <vincenz> darcs failed:  cannot roll back a 'rollback' patch.
17:44:30 <vincenz> Any clues?
17:44:41 <Cale> Well, the disadvantages are when collapsing large structures into small ones -- that's where strictness is quite important
17:45:09 <Cale> By that, I mean actually using the entire large structure, not simply searching through it.
17:45:19 <Cale> A good example would be something like summing the elements of a list.
17:45:47 <dons> yeah, length = foldl' (const . (+1)) (0::Int) is definitely a good thing
17:45:55 <Cale> With lazy evaluation, you'll tend to build up large expressions, on the order of the size of the original structure which aren't evaluated until the end.
17:45:56 <dons> you don't want a lazy accumulator there
17:46:02 <mauke> argh. why does ghc -cpp invoke gcc -E -traditional?
17:46:21 <Cale> (in this case)
17:46:30 <mauke> and it looks like there is no -no-traditional
17:47:39 <mauke> this breaks my ## __LINE__ macro magic :(
17:47:53 <Cale> There's also a small constant hit which you take because of the extra indirection which tends to be needed to implement laziness in the first place.
17:48:36 <vincenz> anyone here have some std fixities?
17:49:29 <SamB_XP> @pl 2.0
17:49:29 <lambdabot> 2 . 0
17:49:32 <SamB_XP> bug!!!
17:50:06 <Cale> The @pl plugin doesn't really have a proper Haskell parser
17:50:14 <SamB_XP> yeah, so?
17:50:21 <Cale> @pl let f x = x in f
17:50:22 <lambdabot> id
17:50:25 <SamB_XP> it could do better with floats, methinks!
17:50:37 <Cale> @pl case Just 5 of Just x -> x
17:50:37 <lambdabot> (line 1, column 23):
17:50:37 <lambdabot> unexpected ">" or "-"
17:50:37 <lambdabot> expecting variable, "(", operator or end of input
17:50:57 <SamB_XP> well, that one just blows up
17:51:08 <vincenz> @fptools Prelude
17:51:08 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:51:19 <dons> SamB_XP: would you like to use the parser i've jsut added to lambdabot?
17:51:33 <dons> you could adapt @pl to use it.
17:51:50 <SamB_XP> dons: I have a parser of my own to finish!
17:51:54 <vincenz> @fptools Data.Bool
17:51:54 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bool.hs
17:51:59 <SamB_XP> for RELAX NG Compact!
17:52:56 <Cale> SamB_XP: What are you doing with relax ng?
17:53:17 <SamB_XP> Cale: well, I want to make a monopd client
17:53:44 <SamB_XP> and I want to make sure that the messages sent to it are ones I am expecting
17:53:52 <SamB_XP> and if not, how!
17:54:10 <SamB_XP> and for some reason I don't want to have to run trang to translate the schema
17:54:46 <SamB_XP> (and, for some reason, HXT doesn't come with a RELAX NG Compact parser)
17:55:13 <SamB_XP> see, being lazy is an awful lot of work!
18:04:17 <Taral> are there any full haskell (i.e. ghc compatible) parsers written in haskell?
18:04:59 <SamB_XP> GHC's uses Happy, does that count?
18:05:36 <Razor-X> Can you use `_' as an expression to test in ``if''?
18:05:46 <mauke> you can't use _ in expressions
18:06:49 <Razor-X> Oh.
18:14:53 <Cale> hehe
18:15:01 <Cale> > if otherwise then 5 else 6
18:15:01 <lambdabot>  5
18:15:18 <dons> Taral: hsx comes close
18:15:21 <dons> ?where hsx
18:15:21 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
18:15:40 <Taral> that's compatible with haskell-src?
18:15:43 <dons> and Lemmih's extracted the ghc parser into a cabalised lib at one point
18:16:00 <dons> what do you mean compatible?
18:16:34 <Taral> Just be able to parse anything ghc can parse
18:16:46 <Taral> I'm using haskell-src for now, but I know it doesn't support some useful things like FD
18:17:00 <dons> right hsx does support FDs, MPTCs and some others
18:17:27 <dons> * Multi-parameter type classes with functional dependencies
18:17:27 <dons> * Implicit parameters
18:17:27 <dons> * Pattern guards
18:17:27 <dons> * Mdo notation
18:17:27 <dons> * FFI
18:17:31 <dons> according to the parser src
18:17:50 <vincenz> what is hsx?
18:17:55 <Taral> sounds good to me!
18:18:01 <Taral> vincenz: see above
18:18:10 <dons> nibro is the author. so you can ask him about it, when he's around
18:18:13 <Taral> k
18:18:39 <vincenz> thx
18:20:04 <vincenz> o.O
18:20:08 <vincenz> it's a handcoded lexer???
18:20:25 * vincenz mutters
19:05:11 <mathewm> is there any good documentation on template haskell?
19:07:14 <samx> good documentation and haskell do not belong to the same sentence. sorry.
19:07:25 <samx> oops, did i say that :-)
19:07:50 * mathewm sighs
19:07:54 <dons> mathewm: yes, the Template Haskell papers
19:08:04 <dons> ?google Template Haskell
19:08:05 <lambdabot> http://www.haskell.org/th/
19:08:33 <mathewm> thanks - I haven't quite mastered the nuances of 'google' yet ;)
19:08:43 <dons> samx, check the 'Research' page of haskell.org. Its actually astoundingly well documented. Just about every feature of haskell has 3 papers written on it.
19:08:50 <dons> its just a matter of knowing to read papers
19:09:23 * Korollary high fives mathewm 
19:09:27 <dons> ?gwiki research papers
19:09:28 <lambdabot> No Result Found.
19:09:39 <dons> ?wiki Research_papers
19:09:39 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
19:10:47 <mathewm> Korollary: thanks again for your clarifications today
19:11:38 <Korollary> somebody @karma+ me for doing a super-quick, super-fuzzy intro to few people at work today.
19:12:25 <vincenz> Korollary: if you do the same for me ;)
19:12:34 <Korollary> vincenz: What did you do?
19:12:48 <vincenz> I did the same
19:12:54 <vincenz> got some people very interested
19:12:56 <Korollary> @karma+ vincenz 
19:12:56 <lambdabot> vincenz's karma raised to 5.
19:13:03 <vincenz> @karma+ Korollary 
19:13:03 <lambdabot> Korollary's karma raised to 5.
19:13:05 <vincenz> :D
19:13:50 <dons> Korollary: how'd it go? what was your approach?
19:16:28 <Korollary> dons: I tried to highlight the differences without doing a full blown intro, for which there was no time anyway. I think people in general perceived the presence of profound differences, but they may not be able to repeat what they heard. As long as nobody was frustrated or disinterested, I'm happy.
19:17:06 <dons> ok
19:18:37 <mux> @karma
19:18:38 <lambdabot> You have a karma of 0
19:18:50 <mux> bah, I thought someone had +'ed me the other day
19:19:01 <mux> I have no friends!
19:19:25 <dons> ?karma+ mux --porting fps to FreeBSD
19:19:26 <lambdabot> mux's karma raised to 1.
19:19:47 <dons> ?help karma
19:19:47 <lambdabot> karma <nick>. Return a person's karma value
19:19:54 <dons> ?karma-all
19:19:54 <lambdabot>  dons                   35
19:19:54 <lambdabot>  Lemmih                 17
19:19:54 <lambdabot>  shapr                  17
19:19:54 <lambdabot>  xerox                  15
19:19:54 <lambdabot>  dcoutts                14
19:19:56 <lambdabot> [152 @more lines]
19:20:10 <dons> thats a lot of karma-fied people
19:20:11 <mux> heh
19:20:18 * mux hearts dons
19:20:36 <Korollary> ?karma-sum
19:20:37 <lambdabot> Unknown command, try @list
19:20:41 <SamB_XP_> @more
19:20:44 <mux> @karma+ lambdabot 
19:20:45 <lambdabot> lambdabot's karma raised to 14.
19:21:00 <dons> samx: got wiped when Korollary did his ?karma-sum
19:21:16 <mathewm> @karma+ lambdabot --something we can all agree on :)
19:21:17 <lambdabot> lambdabot's karma raised to 15.
19:21:41 <mux> yeah, lambdabot does all the hard work and has no cookies
19:22:27 <Korollary> ?djinn Int -> Double
19:22:27 <lambdabot> -- f cannot be realized.
19:22:44 <dons> needs polymorphic types to do its proofs-as-types work
19:22:53 <mathewm> no function from Int -> Double ??
19:22:58 <dons> ?djinn a -> (a,b)
19:22:58 <lambdabot> -- f cannot be realized.
19:23:03 <dons> ?djinn a -> a
19:23:03 <lambdabot> f a = a
19:23:13 <dons> ?hoogle Int -> Double
19:23:13 <lambdabot> No matches, try a more general search
19:23:14 <Korollary> ?djinn (Integral a) => a -> Double
19:23:14 <lambdabot> Cannot parse command
19:23:16 <Korollary> heh
19:23:17 <mux> djinn (a,a) -> a
19:23:22 <mux> ?djinn (a,a) -> a
19:23:22 <lambdabot> f (a, _) = a
19:23:43 <Korollary> mathewm: There is, but it's polymorphic.
19:24:00 <dons> ?djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
19:24:00 <lambdabot> f a = a (\ b -> Left (\ c -> a (\ _ -> Right (\ d -> b (c, d)))))
19:24:17 <dons> ?djinn ((a,b) -> c) -> (a -> b -> c)
19:24:18 <lambdabot> f a b c = a (b, c)
19:24:22 <dons> clever djinn
19:24:36 <dons> ?djinn b -> (a -> b) -> Maybe a -> b
19:24:36 <lambdabot> f a b c =
19:24:36 <lambdabot>   case c of
19:24:36 <lambdabot>   Nothing -> a
19:24:36 <lambdabot>   Just d -> b d
19:24:47 <Korollary> ?djinn String -> IO ()
19:24:48 <lambdabot> -- f cannot be realized.
19:25:07 <Korollary> oh come on
19:25:24 <joe_k> f s = putStr s ;)
19:26:55 <mux> ?djinn Maybe a -> (a -> Maybe b) -> Maybe b
19:26:55 <lambdabot> f a b =
19:26:55 <lambdabot>   case a of
19:26:55 <lambdabot>   Nothing -> Nothing
19:26:55 <lambdabot>   Just c -> b c
19:27:06 <mux> pfft, djinn needs bind-love
19:27:23 <vincenz> anyone familiar with TH?
19:27:40 <mux> ?djinn Maybe a -> (a -> Maybe b) -> (b -> Maybe c) -> Maybe c
19:27:41 <lambdabot> f a b c =
19:27:41 <lambdabot>   case a of
19:27:41 <lambdabot>   Nothing -> Nothing
19:27:41 <lambdabot>   Just d -> case b d of
19:27:41 <lambdabot>      Nothing -> Nothing
19:27:43 <lambdabot>      Just e -> c e
19:27:49 <mux> heh
19:28:31 * mux hands f a b c = a >>= b >>= c to djinn
19:29:04 <mux> @karma- djinn
19:29:04 <lambdabot> djinn's karma lowered to -1.
19:29:24 <mathewm> I am attempting to debug some TH problems in some code I would love to use...  learning_curve' = progress ^ 2 :(
19:29:43 <joe_k> djinn--
19:29:47 <mathewm> Still, TH seems cool - haskell's answer to LISP's macros
19:32:55 <vincenz> I'm making a really cool one :)
19:33:16 <mathewm> vincenz: what's it do?
19:33:21 <vincenz> imagine
19:33:27 <vincenz> data X = A | B | C | D Int
19:33:30 <vincenz> I'll auto generate
19:33:31 <vincenz> isA
19:33:32 <vincenz> isB
19:33:33 <vincenz> isC
19:33:34 <vincenz> isD
19:33:52 <vincenz> so you can use em for filtering
19:34:44 <mathewm> hmm, doesn't binding automatically filter - I am thinking about list comprehensions I guess
19:35:04 <vincenz> maybe
19:35:07 <vincenz> but I still find it useful
19:35:14 <mathewm> nifty
19:35:26 <vincenz> and erm, thx for suggestion
19:36:05 <Korollary> isA x = case x of {A -> True; _ -> False} ?
19:36:14 <vincenz> nah
19:36:17 <fanopnaic> > head [1+4, 2+4, 3+4]
19:36:18 <lambdabot>  5
19:36:18 <vincenz> isA (A x) = True
19:36:38 <vincenz> isA _ = False
19:36:54 <mathewm> hmm are there strictness differences between the two approaches?
19:37:09 <vincenz> Korollary: and thanks for reminding me of _
19:37:39 <mathewm> oh, and can you declare data types in a let?
19:38:22 <SamB_XP_> > let data Foo = Bar in Bar
19:38:23 <Korollary> mathewm: not in haskell (yes in sml I think)
19:38:23 <lambdabot>  Parse error
19:39:11 <Korollary> vincenz: What is (A x)? Do you mean "isA A = True" ?
19:45:49 <vincenz> Korollary: assuming there's variables
19:50:07 <vincenz> \o/
19:50:08 <vincenz> it works
19:52:30 <vincenz> http://rafb.net/paste/results/dRoJfg75.html
19:57:11 <mathewm> gonna paste the implementation?
20:00:25 <vincenz> mathewm: check haskell-cafe
20:02:54 <mathewm> vincenz: some guy named Christophe Poucet just stole your idea!
20:03:05 <Cale> heheh
20:03:20 <mathewm> I wouldn't stand for that if I were you...
20:04:19 <SamB_XP> mathewm: heh
20:05:28 * vincenz snickers
20:05:37 <vincenz> I really need a more personal nick
20:05:42 <vincenz> chrisP?
20:06:54 * SamB_XP mumbles something incoherent
20:07:02 <vincenz> tecuop?/
20:07:31 <vincenz> yourdaddy?
20:07:39 <dons> vincenz: chrisp seems a highly reasonable nick. 
20:07:43 <SamB_XP> oh, that sounds like my dad's old name Nosnorb... I dunno what he used it for besides Zelda
20:07:43 * dons sez
20:07:44 <proloy> Hi , would anyone be willing to look at my code which does not work, its 31 lines newbie level code ?
20:08:02 <SamB_XP> what abouy crispy?
20:08:04 <dons> lisppaste: url?
20:08:04 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:08:12 <dons> proloy: paste it above ^^
20:08:18 <vincenz> dons: sadly it's very nonunique
20:08:21 * SamB_XP thinks crispy is easier to type
20:08:25 <dons> crispy is good
20:08:29 <dons> crisp
20:08:33 <vincenz> oy no
20:08:37 <vincenz> crisp is the name of a processor
20:08:43 <dons> krispy ?
20:08:51 <vincenz> krispy kringle
20:08:55 <lisppaste2> proloy pasted "newbie code" at http://paste.lisp.org/display/20700
20:09:01 <dons> krispykreme?
20:09:04 <dons> :P
20:09:06 <SamB_XP> crispy sounds just like ChrisP
20:09:10 * vincenz sticks to vincenz
20:09:16 <vincenz> most people know me as it
20:09:18 <dons> but vincenz makes no sense
20:09:22 <vincenz> yes it does
20:09:27 <vincenz> my website makes even more sense
20:09:30 <vincenz> notvincenz.com
20:09:32 <SamB_XP> isn't there someone named krispykringle on this network?
20:09:47 <dons> someone want to debug http://paste.lisp.org/display/20700 ?
20:09:50 <dons> i'm busy atm.
20:09:54 <vincenz> dons: I have an affinity for l. da vinci and vincent v.g.
20:10:02 <vincenz> dons: on it
20:10:32 <vincenz> proloy: what's the issue
20:10:38 <proloy> http://paste.lisp.org/display/20700    
20:10:47 <vincenz> yes I saw that... the issue?
20:11:04 <vincenz> oh
20:11:08 <vincenz> proloy: easy
20:11:21 <vincenz> bug 1:
20:11:23 <vincenz> line 10
20:11:25 <vincenz> mapM_
20:11:26 <vincenz> not map
20:11:28 <vincenz> @hoogle mapM_
20:11:29 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:11:29 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
20:11:32 <proloy> why ?
20:11:40 <vincenz> because map is pure
20:11:55 <vincenz> @hoogle map
20:11:55 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:11:55 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
20:11:55 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
20:11:57 <proloy> ohokay and cos my func returns IO ?
20:12:01 <vincenz> yes
20:12:06 <vincenz> aka it's in a monad
20:12:09 <vincenz> this one being IO
20:12:11 <vincenz> so mapM_
20:12:17 <vincenz> (a -> m b) -> [a] -> m ()
20:12:23 <vincenz> it discards return values
20:12:31 <vincenz> @type mapM
20:12:32 <lambdabot> forall b (m :: * -> *) a.
20:12:32 <lambdabot>    (Monad m) =>
20:12:32 <lambdabot>    (a -> m b) -> [a] -> m [b]
20:12:35 <vincenz> this one doesn't
20:12:37 <vincenz> but print returns ()
20:12:46 <vincenz> so it's stupid to have a list of ()
20:13:04 <vincenz> second problem
20:13:10 <vincenz> you don't parse the string into an integer
20:13:23 <vincenz> hmm
20:13:39 <proloy> you mean the show() ?
20:15:01 <vincenz> fixed
20:15:45 <lisppaste2> vincenz annotated #20700 with "bugs fixed" at http://paste.lisp.org/display/20700#1
20:16:23 <vincenz> and now to clean it up a bit
20:18:00 <lisppaste2> vincenz annotated #20700 with "small cleaning" at http://paste.lisp.org/display/20700#2
20:18:25 <vincenz> hmm, need control.monad for liftM
20:18:57 <proloy> le me see
20:19:18 <lisppaste2> vincenz annotated #20700 with "use standard functions sum and product" at http://paste.lisp.org/display/20700#3
20:21:15 <vincenz> there
20:21:23 <vincenz> some smaller tweaks remain but nothing worth repasting
20:21:36 <vincenz> like removing the () around printFac
20:21:43 <vincenz> and
20:21:58 <vincenz> putStrLn $ show x ++ " factorial is " ++ show (myFact x)
20:22:29 <vincenz> idem for the first two prints
20:22:45 <proloy> hmm i dont even know what is idem , istarted with haskell 4 days back 
20:23:02 <vincenz> idem is nothing to do with haskell
20:23:08 <vincenz> idem means "same as above"
20:23:21 <proloy> oh ...
20:23:27 <vincenz> tho it might be a dutch bastardization of "ibidem"
20:23:54 <dons> idempotent?
20:24:00 <vincenz> no
20:24:01 <vincenz> ibidem
20:24:08 <vincenz> but idem is a recurring word-part
20:24:11 <proloy> the () around printFac is wrong or it just adds to the clutter ?
20:24:16 <vincenz> proloy: just clutter
20:24:36 <vincenz> same for the $
20:24:43 <vincenz> as for sum and product
20:24:46 <vincenz> well only someone learning haskell
20:24:50 <vincenz> and showing his teacher how to do them
20:24:53 <vincenz> would actually use foldr
20:25:04 <proloy> what would you have used ?
20:25:10 <vincenz> otherwise just use the std functions, that's why they're there for
20:25:19 <vincenz> sum and product
20:25:22 <vincenz> > sum [1..10]
20:25:23 <lambdabot>  55
20:25:29 <vincenz> > foldr (+) 0 [1..10]
20:25:30 <lambdabot>  55
20:25:31 <proloy> I am reading the "yet another haskell tutorial" , and this was an exercsie.
20:25:35 <vincenz> ah k
20:25:39 <vincenz> well if you know how sum works
20:25:40 <vincenz> use sum
20:25:43 <vincenz> otherwise use foldr
20:25:57 <proloy> one of them is more efficient than the other ?
20:26:00 <vincenz> no
20:26:04 <vincenz> it's just clearer to the reader
20:26:54 <proloy> okay thanks...guess will get back to the code and prolly be back here with more problems
20:27:00 <vincenz> sum l = foldr (+) 0 l
20:27:02 <proloy> Thanks vincenz 
20:27:05 <vincenz> np
20:27:25 * vincenz returns to his compiler
20:27:32 <vincenz> dons: I added modules to my language \o/
20:27:35 <vincenz> dons: and polytypes
20:27:36 <vincenz> and tuples
20:27:39 <vincenz> and tuple patterns
20:27:39 <vincenz> woot
20:27:58 <vincenz> it's nearly sML
20:28:00 <vincenz> :D
20:28:20 <vincenz> (goes to show how simple ML is without extensions)
20:29:58 <mgoetze> hullo... what's the best way to use an sql database in haskell? HDBC?
20:30:26 <Cale> HDBC looks pretty nice to me
20:30:38 <vincenz> Cale: it rhymes too
20:31:01 <mgoetze> a bit lacking in the documentation department, but since i've used perl dbi, i suppose i'll be able to figure it out...
20:31:35 <Cale> Did you see the haddock documentation?
20:31:41 <mgoetze> yeah
20:33:28 <SamB_XP> @index html
20:33:28 <lambdabot> bzzt
20:33:36 <SamB_XP> @index Html
20:33:36 <lambdabot> Text.Html, Network.CGI, Text.Html
20:33:48 <SamB_XP> @doc Text.Html
20:33:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
20:34:59 <SamB_XP> @source Text.Html
20:35:00 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
20:35:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:35:11 <SamB_XP> @fptools-source Text.Html
20:35:12 <lambdabot> Unknown command, try @list
20:35:19 <SamB_XP> @list docs
20:35:20 <lambdabot> dummy provides: id dummy get-shapr faq paste learn map shootout botsnack eurohaskell wiki oldwiki docs libsrc fptools
20:35:30 <SamB_XP> @libsource Text.Html
20:35:30 <lambdabot> Unknown command, try @list
20:35:42 <SamB_XP> @libsrc Text.Html
20:35:42 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Text/Html.hs
20:36:12 <SamB_XP> is missing!
20:38:39 <vincenz> @hoogle foldM
20:38:39 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
20:38:39 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:38:39 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
20:38:43 <SamB_XP> @wiki combinators
20:38:44 <lambdabot> http://www.haskell.org/haskellwiki/combinators
20:39:07 <vincenz> > foldM (\a b -> [a+b]) 0 [1..10] 
20:39:07 <lambdabot>  [55]
20:39:15 <vincenz> > foldM (\a b -> [a-b]) 0 [1..10] 
20:39:16 <lambdabot>  [-55]
20:39:24 <vincenz> > foldr (\a b -> a-b) 0 [1..10] 
20:39:25 <lambdabot>  -5
20:39:30 <vincenz> > foldl (\a b -> a-b) 0 [1..10] 
20:39:31 <lambdabot>  -55
20:39:32 <vincenz> hmm
20:39:59 <user311> can anyone explain why this code grows in memory, i am trying to figure out the state monad, http://pastebin.com/750535
20:40:39 <mathewm> > foldM (\a b -> [a-b]) 0 [9..10]
20:40:40 <lambdabot>  [-19]
20:40:48 <dons> user311: have you profiled?
20:40:57 <dons> do you have a space leak in the state value?
20:41:21 <vincenz> mathewm: trying to figure out if you do that in IO if it'll do the first or the last first
20:42:21 <SamB_XP> why have we no page on combinators?
20:42:48 <user311> dons: no i havent
20:43:11 <user311> dons: why would it have a leak?  i dont get it what it could possibly be retaining
20:43:38 <dons> the state value is lazy, so you could be accumulating a sequence of unevaluated operations to modify the state value
20:43:49 <dons> first, profile, to work out where all the allocations are
20:43:56 <dons> i.e. ghc -O -prof -auto-all
20:44:05 <dons> then run your program with +RTS -p
20:44:13 <dons> and the output will be in foo.prof
20:44:49 <SamB_XP> dons: why is there no wiki page about combinators?
20:45:11 <user311> dons: do i need the program to terminate or can i kill it?
20:45:46 <dons> SamB_XP: isn't there one on combinatory logic? that's closish
20:45:53 <dons> user311: you'll need it to terminate
20:46:09 <SamB_XP> well, the Parsec page don't link there...
20:46:41 <SamB_XP> and it is #16 on a search for combinators
20:47:02 <dons> you know how to write ... :)
20:47:19 <SamB_XP> in theory!
20:47:32 <user311> hmm, dont really know how to read this:
20:47:32 <user311> main   Main                       181      319223  31.7   22.8    99.4  100.0
20:47:32 <user311>      dumbmave    Main        182      958128  67.7   77.2    67.7   77.2
20:47:51 <SamB_XP> hey, how come *my* unlambda interpreter does not seem to be mentioned on that page?
20:48:09 <SamB_XP> nevermind if it is a direct rip of the C version
20:48:25 <dons> user311: its the numbers at the end you care about.
20:48:37 <dons> check the headings for allocs and time
20:48:44 <dons> your interested in what function is doing all the allocs
20:48:58 <vincenz> @hoogle splitEither
20:48:59 <lambdabot> No matches found
20:49:14 <vincenz> @hoogle [Either a b] -> ([a],[b])
20:49:14 <lambdabot> No matches, try a more general search
20:49:46 <user311> dons: looks like dumbmave is doing 77.5% of the allocatoin
20:50:18 <dons> does that make sense to you, knowing the code?
20:51:07 <user311> dons: http://pastebin.com/750535 well, sort of, but why would it not release it?
20:52:02 <dons> probably its not evaluated yet for some reason
20:52:11 <Bobstopper> Is there any way to tell in haskel whether two objects are equal in terms of memory reference? For example, if I want to serialise a data structure including details of where structure is referenced multiple times, how would I go about this in haskell?
20:52:37 <vincenz> > let foo = [Just 1, Nothing, Just 2] in [x | (Just x) <- foo]
20:52:38 <lambdabot>  [1,2]
20:52:48 <SamB_XP> you can't, without some kind of reference type
20:52:55 <dons> try, put (let a = take items (ii:old) in a `seq` a)
20:53:34 <SamB_XP> so basically, if you want to serialize, either avoid cyclic structures or at least make sure you can prune them and reconstitute them...
20:53:49 <Bobstopper> damn. Ok, thanks.
20:54:18 <SamB_XP> but, you can do it with something like IORef or STRef
20:54:29 <dons> user311: how long does this program take to run?
20:54:42 <Bobstopper> Yeah... I kinda need this to work with arbitrary data structures...
20:54:45 <dons> i can see its definitely leaking on my box (though its  doing a lot of io too)
20:54:58 <user311> dons: it doesn't, i am trying to learn haskell :)
20:55:18 <dons> oh. what do you expect it do then?
20:55:26 <dons> print numbers in constant memory?
20:55:39 <user311> dons: yep
20:56:15 <user311> dons: this is a retarded way to do a moving average anyways, but it shouldn't grow in size
20:56:31 <dons> yeah, thinking...
20:57:07 <dons> how big is that state value going to be though?
20:57:27 <dons> you need it to be fully lazy for this to work, i think.
20:58:29 <user311> dons: well, i want to use a state monad in a function that does a -> b
20:59:10 <user311> dons: is there something screwed up about  evalState ((mapM (dumbmave 210)) [1,2..]) []
21:00:26 <dons> yeah, i think so. putting nothing in the state stills has hugh memory issues.
21:00:34 <mgoetze> uhm, is there anyway to execute a system command and grab it's stdout in, say, a String?
21:00:41 <dons> i think its trying to eval the whole infinite list, and it needs to hang onto the lot
21:00:51 <dons> @hoogle system
21:00:51 <lambdabot> System.system :: String -> IO ExitCode
21:00:51 <lambdabot> System :: module
21:00:51 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
21:00:56 <sethk> mgoetze, I dump it to a file and then read the file
21:01:02 <dons> mgoetze: otherwise, use System.Process
21:01:16 <dons> @hoogle runInteractiveProcess
21:01:17 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
21:01:27 <dons> @hoogle runProcess
21:01:28 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
21:01:34 <mgoetze> dons: ok, thanks
21:01:41 <dons> @hoogle runCommand
21:01:41 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
21:02:30 <sethk> runProcess doesn't capture the standard output
21:02:55 <dons> runInteractivePrcoess does though
21:03:12 <sethk> dons, well, yes and no
21:03:16 <sethk> dons, it runs a shell
21:03:23 <sethk> dons, which often is not what you want
21:03:46 <dons> yeah, i use my own lib for this stuff usually
21:04:10 <SamB_XP> wow @ http://www.haskell.org/haskellwiki/Untypechecking
21:04:34 <sethk> dons, I'd like to see some of your stuff in the standard library, especially considering the bugs I've found with what's there
21:04:42 <sethk> dons, which reminds me, I have to write those up and report them
21:05:13 <sethk> dons, got a bit of follow on work on my project today
21:05:37 <dons> oh yes?
21:05:40 <dons> thats good
21:05:47 <sethk> yes, definitely.
21:06:03 <sethk> and no discussion at all about the implementation
21:06:10 <SamB_XP> > let foo'bar = 1 in foo'bar
21:06:12 <lambdabot>  1
21:06:18 <SamB_XP> crazy!
21:06:21 <sethk> which makes sense, since it is partially an enhancement of what I've done, but still, that's good
21:06:33 <SamB_XP> I thought primes were only allowed at the end!
21:06:37 <dons> cool!
21:06:40 <sethk> some of it is new code, and I didn't even have to sell them on doing it in haskell
21:07:04 <sethk> the fact that there have been zero abnormal terminations has been noticed
21:07:06 <dons> user311: this program doesn't leak:
21:07:09 <dons> items = 210
21:07:09 <dons> run (ii:is) old = (sum new) / (fromIntegral items) : run is new
21:07:09 <dons>     where new = take items (ii:old)
21:07:10 <dons> main = putStrLn $ show $ run [1..] []
21:07:35 <dons> so the state monad eval there is too strict for your needs
21:08:26 <dons> sethk: thats really cool
21:09:33 <sethk> there have also been no abends in the device driver, which is because I coded it correctly, so I get some credit.  :)
21:09:52 <dons> :)
21:10:09 <dons> you might be interested in this paper, http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html
21:10:23 <dons> about prototyping an l4 kernel in haskell, to verify the api is correct
21:10:35 <dons> they talk about the benefits of using haskell to specify low level os and hardware issues
21:10:46 <sethk> definitely, I'll read it.
21:10:49 <sethk> someday  :)
21:11:21 <dons> some of the stuff, about how to model interrupts and the like, i thought would be useful to you.
21:11:43 <sethk> definitely looks interesting
21:14:29 <vincenz> sethk: you the one working on gameboy?
21:14:42 <sethk> vincenz, no, that would be more fun, but that's not me  :)
21:14:59 <user311> dons: this doesn't help me learn the state monad :)
21:15:11 <vincenz> who is it then
21:15:15 <vincenz> sethk: and why do you need interrupts?
21:15:17 <user311> dons: or how haskell manages memory
21:15:25 <dons> user311: I know. its just taht the state monad is trying to force the fnial value, before you can output anything, i think
21:15:33 <dons> which for your infinite list problem, is not what you want
21:15:40 <user311> dons: but it prints right away
21:15:55 <sethk> vincenz, actually I've done the IRQ handling in C in the device driver on my project.  I want to look into doing more of that at the Haskell level when (if) I get time.
21:16:41 <dons> user311: oh, yes. good point. perhaps look at the State monad src then. see how that state parameter is being accumulated?
21:17:58 <user311> dons: eek, its in haskell, hehe
21:18:34 <dons> oh, its your code...
21:18:40 <dons> dumbmave items ii = do
21:18:40 <dons>       old <- get
21:18:40 <dons>       let new = take items (ii:old)
21:18:40 <dons>       put new
21:18:40 <dons>       return $ (sum new)/(fromIntegral items)
21:18:43 <dons> doesn't leak.
21:19:19 <dons> so now ponder why putting a lazy take into the state, and returning another lazy take, lead to a space leak
21:19:34 <dons> unlike here, where we do one take, and share the result between the state value and the returned value
21:19:39 <dons> so it only gets computed once..
21:19:52 <user311> but why doesn't recognize that its the same function computed with the same inputs
21:20:11 <dons> it doesn't do much common expression elimination, as that too can lead to space leaks
21:20:12 <SamB_XP> because it isn't!
21:20:21 <dons> best to explicitly share
21:20:25 <SamB_XP> or maybe it is
21:20:46 <sethk> SamB_XP, that's safe, either it isn't, or maybe it is  :)
21:20:53 <SamB_XP> but... it is not so obvious unless you look at the implementation
21:21:53 <user311> hmm, why does the original leak though
21:22:09 * SamB_XP gets the joke in:
21:22:15 <dons> you've got to hang onto the entire list for all those not yet computed return values
21:22:18 <SamB_XP>  Haskell: "Hard things are easy, the impossible just happened"
21:22:33 <dons> here , one the state value is forced, so is the shared return value, and the head of the list can be thrown away
21:22:47 <dons> think of those uncomputed returns piling up
21:26:00 <user311> dons: shouldn't return $! (sum (take items saved))/(fromIntegral items) fix the problem?
21:26:58 <SamB_XP> oh, huh, there was once an STBG-machine?
21:29:08 <vincenz> hmm
21:29:45 <dons> user311: hmm. I'd have to think harder about that. This works however:
21:29:47 <dons>       let x = take items (ii:old)
21:29:47 <dons>       x `seq` return $ (sum x)/(fromIntegral items)
21:29:57 <user311> what does `seq` do
21:30:06 <dons> you've got to think about when the result of the return will be forced.
21:30:11 <dons> seq forces evaluation
21:30:29 <vincenz> does haskell allow nested modules?
21:30:39 <dons> so the above, 'x' is evaluated fully before the return
21:31:28 <SamB_XP> you mean like:
21:31:33 <SamB_XP> > let module Foo (foo) where foo = 1 in Foo.foo
21:31:33 <lambdabot>  Parse error
21:31:38 <SamB_XP> ?
21:31:42 <SamB_XP> the answer is no!
21:32:17 <SamB_XP> but, logo doesn't even support nested functions, so consider yourself lucky!
21:32:46 <user311> dons: ok, makes sense, thanks for your help
21:33:47 <dons> sure, fun little problem
21:38:49 <vincenz> eurgh
21:38:52 * vincenz is pissed at modules
21:39:00 <Korollary> I have a feeling that return $! (sum (take items saved))/(fromIntegral items) would not do the same.
21:39:39 <dons> yeah, it doesn't
21:39:59 <dons> since you still have to evaluate the return to get the argument forced (I think)(
21:40:06 <dons> return's tricky like that, since its a function
21:40:20 <dons> and not magic syntax
21:42:40 <vincenz> Anyone care to discuss some language design issues?
21:51:28 <Cale> vincenz: what do you want to talk about?
21:51:54 <SamB_XP> Cale: nested modules!
21:52:22 <palomer> nested modules are fun
21:52:31 <palomer> a la sml
21:52:37 <Korollary> dons: I was thinking that you may need deepseq to make "sum (a)/(b)" to eval a.
21:52:46 <Cale> they seem like a reasonably good idea, though I don't know how often I'd bother to use them
21:53:06 <vincenz> Cale: pasting use cases
21:53:17 <vincenz> http://rafb.net/paste/results/Fr083077.html
21:53:18 <vincenz> there you go
21:53:22 <vincenz> 1, 2, 3 or other suggestion?
21:53:25 <vincenz> 1 == sml
21:53:40 <vincenz> I like 3
21:53:45 <vincenz> except for the recursion crap
21:53:49 <vincenz> unless import statements are never exported
21:53:53 <vincenz> in which case recursion doesn't happen
21:53:56 <Cale> why does A.foo1 not have access to foo2?
21:55:07 <palomer> I like 1
21:55:08 <palomer> go sml!
21:55:14 <Daveman> xerox :)
21:55:16 <Cale> I don't like any of these options
21:55:17 <vincenz> new paste
21:55:18 <vincenz> http://rafb.net/paste/results/qvTxZF29.html
21:55:23 <palomer> vincenz: you can add signatures so that only certain are exported
21:55:32 <palomer> s/certain/certain things
21:55:38 <vincenz> Cale: I'm trying to avoid recursion at the moment
21:55:43 <vincenz> Cale: it creates issues with type inference
21:55:48 <vincenz> Cale: like making a dependency analysis
21:55:49 <Cale> huh?
21:55:56 <vincenz> Cale: I mean... recursive declarations
21:56:09 <Cale> shouldn't everything within one module have access to everything else in the module?
21:56:12 <vincenz> heence foo1 not having access to foo2
21:56:17 <vincenz> Cale: no only what's defined previously
21:56:21 <vincenz> Cale: to ease type inference
21:56:29 <vincenz> otherwise I need to make a dependency analysis graph
21:56:32 <vincenz> and then detect strong components
21:56:36 <vincenz> let's KISS
21:56:40 <vincenz> then later I miight remove this restriction
21:56:48 <vincenz> (one step at a time
21:56:52 <vincenz> so... regarding modules
21:56:55 <vincenz> I like 4
21:57:00 <palomer> are you going to add signatures later?
21:57:04 <vincenz> palomer: maybe
21:57:10 <vincenz> who votes 4
21:57:11 <palomer> and typeclasses?
21:57:14 <vincenz> possibly
21:57:19 <vincenz> but not in the short future
21:57:22 <palomer> and functors?
21:57:25 <vincenz> I need this thing to actually do something useful
21:57:26 <palomer> (a la sml)
21:57:36 <vincenz> palomer: nonono... I am spending too much time as it is already
21:57:39 <vincenz> this is needed for something else
21:57:47 <vincenz> palomer: maybe .. much later in my spare time
21:57:54 <vincenz> anyways...what do you think of 4?
21:58:07 <palomer> it'll be the first language I see with functors+typeclasses
21:58:12 <vincenz> :D
21:58:24 <vincenz> Cale: thoughts on 4?
21:58:44 <vincenz> and what do you think about the fact that modules can't access their surrounding scope?
21:58:52 <Cale> I guess I vote for #1
21:58:58 <vincenz> blegh
21:58:59 <vincenz> why?
21:59:03 <vincenz> it's hacky
21:59:04 <palomer> I don't see how 4 could work
21:59:09 <palomer> the semantics aren't clear to me
21:59:19 <palomer> is that a qualified import?
21:59:24 <vincenz> palomer:yep
21:59:38 <Cale> Well, the whole idea of only allowing access to things defined above the current definition seems hacky to me anyway
21:59:40 <palomer> I would do qualified imports a la sml
21:59:46 <palomer> module A = B
21:59:50 <vincenz> Cale: that's got to do with not complicating typeinference
21:59:51 <Cale> But if you're going to do that, then you should be consistent about it
21:59:54 <palomer> module M = Map
21:59:59 <vincenz> Cale: I can possibly extend later
22:00:14 <Cale> So B shouldn't have access to the parts of module A which aren't there yet.
22:00:23 <vincenz> Cale: no I prefer B not having access to A at all
22:00:34 <vincenz> aka each module sees itself as the whole program
22:00:38 <vincenz> which is great for modularisation imo
22:00:40 <Cale> Then what's the point of nesting them?
22:00:51 <vincenz> Cale: modularisation
22:00:55 <Cale> huh?
22:00:55 <vincenz> within one body of code
22:01:07 <vincenz> Cale: I'm working with a single file
22:01:31 <vincenz> palomer: erm module M = Map
22:01:38 <vincenz> palomer: so how do you import unqalified?
22:01:41 <palomer> open Map
22:01:43 <Cale> are we assuming that modules should export everything?
22:01:45 <vincenz> oh right
22:01:47 <vincenz> Cale: yes
22:02:19 <vincenz> I'm still an advocate of 4 
22:02:24 <vincenz> I don't like shadowing
22:02:27 <Cale> okay, 4 doesn't look so bad
22:02:32 <vincenz> and I might add recursive declarations later on
22:02:37 <vincenz> it's just an issue atm with type inference
22:02:49 <vincenz> (I dont feel like doing a dependency analysis)
22:03:05 <Cale> Though you might still have to do that analysis you don't want to in that case
22:03:09 <vincenz> yeah
22:03:10 <vincenz> with the import
22:03:13 <Cale> right
22:03:18 <vincenz> just thought of that as well
22:03:27 * vincenz ponders
22:03:29 <Cale> since you could just have a bunch of modules all import each other
22:03:37 <vincenz> crap crap
22:03:53 <palomer> none of these would work in sml
22:03:56 <fwfewfwa> hey cale do you know prolog?
22:03:59 <Cale> There's tools for computing strongly connected components in Data.Graph anyway
22:04:01 <vincenz> palomer: who says I want sml
22:04:04 <Cale> fwfewfwa: a bit
22:04:10 <vincenz> Cale: alright thx
22:04:17 <vincenz> Cale: it's just making my ast fit nicely around Data.Graph
22:04:22 <vincenz> btw
22:04:25 <palomer> oh wait, none of the ones with import work in sml
22:04:28 <vincenz> what about non strongly connected components?
22:04:39 <vincenz> palomer: 1 = sml
22:05:02 <vincenz> palomer: but sml a) shadows, b) does not do recursive decls
22:05:05 <Cale> components :: Graph -> Forest Vertex
22:05:05 <Cale> The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.
22:05:08 <vincenz> which are two features which I find buggy
22:05:18 <vincenz> hmm
22:05:19 <Cale> scc :: Graph -> Forest Vertex
22:05:19 <Cale> The strongly connected components of a graph.
22:05:26 <Cale> bcc :: Graph -> Forest [Vertex]
22:05:26 <Cale> The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.
22:05:28 <palomer> recursive decls?
22:05:30 <palomer> what do you mean?
22:05:36 <vincenz> let foo x = ...
22:05:41 <palomer> sure it does
22:05:41 <vincenz> let foo x = bar y
22:05:45 <vincenz> let bar x = foo y
22:05:55 <palomer> let foo x = bar y and bar x = foo y
22:05:57 <vincenz> palomer: yeah but not module wide
22:06:20 <palomer> you want mutually recursive modules?
22:06:22 <vincenz> and ... modules only have access to the context defined previous to the start of the module
22:06:27 <palomer> oh my, that's a whole new can of worms
22:06:32 <vincenz> :D
22:06:43 <vincenz> ok
22:06:43 <palomer> you my friend are ambitious
22:06:46 <vincenz> kiss
22:06:49 <vincenz> recursive decls
22:06:50 <vincenz> no modules
22:06:59 <fwfewfwa> can you help me with something at #prolog cale? :)
22:07:02 <palomer> no modules at all?
22:07:06 <vincenz> palomer: assume
22:07:10 <vincenz> how do I type infere
22:07:18 <vincenz> why only strongly connected components and not just connected componetns
22:08:08 <palomer> yeah, just connected
22:08:16 <Cale> fwfewfwa: at the risk of looking silly, since I've only written a couple of simple prolog programs, sure
22:08:17 <vincenz> ok that's more intuitive :)
22:08:24 <palomer> no, actually
22:08:25 <palomer> scc
22:08:26 <vincenz> palomer: so what I do is... type em all monomorphically
22:08:32 <vincenz> palomer: and then generalize after
22:08:37 <vincenz> palomer: erm no?
22:08:39 <vincenz> foo x = bar x
22:08:43 <vincenz> bar x = zed x
22:08:44 <palomer> a -> b -> c <--- type a first, generalize, type b , generalize, type c ...
22:08:45 <vincenz> zed x = plop x
22:08:48 <vincenz> plop x = foo x
22:08:53 <vincenz> that's a circle
22:08:54 <palomer> a -> b -> a <--type a and b together
22:08:55 <vincenz> but not scc
22:09:09 <palomer> oh, righto
22:09:18 <palomer> find the loops, at least
22:09:28 <vincenz> well just find connected components :)
22:09:31 <vincenz> type em together
22:09:32 <vincenz> generalize
22:09:35 <vincenz> \o/
22:09:37 <palomer> yay!
22:09:43 <vincenz> as for modules
22:09:45 <vincenz> simplest solution
22:09:46 <vincenz> no import
22:09:49 <vincenz> is solution 3
22:09:58 <vincenz> with autoimport of prelude
22:10:00 <vincenz> but no other importation
22:10:08 <vincenz> then I just start at the deepest module
22:10:09 <vincenz> and type up
22:10:18 <palomer> sure
22:10:26 <vincenz> but!
22:10:31 <vincenz> one step at a time
22:10:32 <palomer> personally I wouldn't allow a module to be referenced if its definition isn't complete
22:10:41 <vincenz> palomer: smler
22:10:51 <vincenz> palomer: it's not that bad
22:10:57 <palomer> struct A ;val foo = 4; struct B; bar = foo; end; end <--this is fine
22:10:59 <vincenz> palomer: just implicitly move the modules to the top of their container module
22:11:05 <vincenz> palomer: and!
22:11:05 <palomer> struct A ;val foo = 4; struct B; bar = A.foo; end; end <--this isn't
22:11:11 <vincenz> palomer: modules don't have access to surroudnding module
22:11:23 <vincenz> oh like that
22:11:24 <vincenz> hmm
22:11:35 <palomer> I would separate module definition from declaration
22:11:41 <palomer> make that
22:11:42 <vincenz> na
22:11:44 <vincenz> nah
22:11:49 <vincenz> I'm keeping that aspect more haskellish
22:11:52 <vincenz> just with nesting
22:12:03 * vincenz goes back to his code
22:12:07 <palomer> structure A = struct val foo = 4; structure B = struct bar = foo; end; end;
22:12:21 <palomer> but modules is sml's strongest point!
22:12:23 <vincenz> palomer: I'm not turning it into sml
22:12:26 <vincenz> palomer: so?
22:12:30 <palomer> (I think it's sml's only strong point)
22:12:33 <vincenz> :D
22:12:40 <palomer> suit yourself
22:12:45 <vincenz> yep
22:12:49 <vincenz> will do!
22:14:18 * palomer wonders what would happen if you combined haskell's module system with sml's unuser-friendliness
22:14:26 <palomer> you'd get a language that's _completely_ useless!
22:14:27 <palomer> yay!
22:15:19 <vincenz> it' user-unfriendliness
22:15:41 <Korollary> user-hostile languages are hip in s&m communities...
22:15:42 * palomer smacks vincenz 
22:16:12 * vincenz takes it stoically
22:16:52 <palomer> good job, soldier
22:16:57 <palomer> man, I'm just not into it
22:16:59 * palomer leaves
22:17:05 * vincenz pats palomer on the back as he leaves
22:17:06 <vincenz> :/
22:18:04 * vincenz detaches as it's 7am and packs up to continue working at the office
22:26:42 <mlh> :q
22:26:52 <mlh> !
22:27:04 <Korollary> This is the irc window.
22:27:50 <mlh> thanks man
22:28:32 <mlh> i was going to ask what are all these people doing in my editor
22:29:01 <Korollary> lambdabot blurs the line
22:29:08 <Korollary> am I in ghci or irc?
22:35:04 <dons> esp. when you start running lambdabot in your editor
22:35:30 <dons> or those guys who run irc in emacs. very confusing!
22:35:59 <Korollary> I ran vi in emacs (via ansi-term) once. It was a perverse experiment.
22:38:12 <xerox> Ohayou!
22:41:25 <mlh> does anyone use haskell as their language for the everyday scraps of code that say sh or perl or python get used for mostly?
22:41:47 <dons> yep. 
22:41:56 <aleator> Yeah.
22:42:05 <dons> i either write 1 liners in sh if its only a pipe, or else use haskell.
22:42:13 <Korollary> I stopped writing in python
22:42:25 <mlh> do you have your own library (module?) built up as a result?
22:42:31 <Korollary> yes
22:42:36 <dons> yeah, a few things.
22:42:50 <Korollary> I had that in python, too. You accumulate as you go.
22:42:54 <aleator> not reallt..
22:42:59 <mathewm> anyone know what this means: class (Storable b, FFITypeable b) => ObjCArgument a b | a -> b where
22:43:14 <mathewm> I cannot find the '| a->b ' in haskell 98 report
22:43:20 <Korollary> mathewm: it's a ghc extension
22:43:21 <dons> its not in the report
22:43:28 <dons> its a functional dependency
22:43:39 <skew> functional dependencies, see the users guide and the papers they reference
22:43:40 <mathewm> k, I will look that up
22:43:44 <mathewm> thanks
22:43:45 <dons> here it says, whenever you have some type 'a', that uniquely determines the type 'b'
22:43:53 <dons> making  the instances tractable
22:43:55 <Korollary> actually the user guide refers straight to the papers heh.
22:44:51 <dons> i have some functions i'd like a class for, but i think it needs more type hackery than i can think up without reading oleg's papers. someone want a challenge?
22:44:54 <skew> that example code was just barely enough the last time I looked them up - forgot the syntax for a set of arguments jointly determining others
22:46:03 <skew> the Linspire people are talking at the sgvlug meeting tommorrow - anybody else in LA?
22:46:29 <dons> I'd like a class method that implements this:
22:46:30 <Korollary> JohnMeacham is nearby iirc
22:46:30 <dons> eq1 :: (Eq b1, Model a1 b, Model a b1) => (a1 -> a) -> (b -> b1) -> a1 -> Bool
22:46:30 <dons> eq1 f g = \a         -> model (f a)         == g (model a)
22:46:30 <dons> eq2 f g = \a b       -> model (f a b)       == g (model a) (model b)
22:46:31 <dons> eq3 f g = \a b c     -> model (f a b c)     == g (model a) (model b) (model c)
22:46:33 <dons> and so on
22:47:08 <dons> the problem is coming up with the polymorphic method that lets me get abstract over the number of arguments 
22:47:15 <dons> maybe some Printf-style trick?
22:47:58 <skew> you want them all in one class?
22:48:06 <dons> yep, if possible :)
22:48:14 <skew> I think oleg's "not a function" typeclass might be useful
22:48:15 <dons> i think its the same problem as zip2..zip7 though
22:48:28 <dons> yeah, i'm almsot certain there's an oleg-ism for me.
22:48:53 <skew> I don't understand how that stuff works, something about delaying the resolution long enough to force things to unify
22:49:16 <dons> I'd like a class Comparable f g where eq :: f a -> g b -> a -> Bool, roughly
22:49:36 <dons> sorry, f a -> g b -> a Bool, was the closest i could get
22:49:42 <dons> but I could never get beyond eq1
22:49:55 <skew> what is "model" supposed to be?
22:49:59 <skew> something about adjunctions?
22:50:16 <dons> its a class function defining a model between two types, a natural transformation
22:50:27 <dons> so we have Model ByteString [Char]
22:50:29 <dons> for example
22:50:38 <dons> which gives the function model = unpack
22:51:14 <dons> ultimately, so I can write QC properties, like:   prop_sort = List.sort `eq` Byte.sort
22:51:29 <dons> where my `eq`  uses the model transformation to handle all the args and so on.
22:51:42 <skew> something like testing whether a is a coequalizer of those two function.
22:51:50 <dons> yep
22:52:17 <dons> currently, i've got it all working, except that for each number of function args, i need a different eq
22:52:27 <dons> so List.sort `eq1` Byte.sort
22:52:31 <dons> which is a bit of a gnat
22:54:23 <dons> ultimately, this should work as a model testing DSL on top of quickcheck
22:54:26 <skew> olegs stuff about deepest composition should get you pretty close
22:54:54 <dons> yeah. i think i'll have to read up to solve this.
22:56:38 <skew> something like class Congruent a b; instance (Model a1 b1, Conruent a2 b2) => Congruent (a1 -> a2) (b1 -> b2); instance (Model a b, NotFunction a, NotFunction b) => Congruent a b
22:57:37 <dons> ah. NotFunction. hmm, maybe that's it, to stop the recursion
22:57:44 <dons> and get the instances to all hold together
22:58:10 <dons> thanks skew!
22:58:18 <dons> ?karma+ skew -- pointing me in the right direction
22:58:19 <lambdabot> skew's karma raised to 1.
23:03:10 <skew> this looks right: http://okmij.org/ftp/Haskell/isFunction.lhs
23:04:19 <skew> I don't understand this TypeCast class
23:04:57 <dons> pretty magic
23:05:20 <dons> lets try this out then
23:12:04 <vincenz> hi :)
23:13:55 <skew> Ah, that magic is explained in the HList paper, in an appendix. I must have stopped reading when I hit the citations.
23:14:22 <skew> it's not just one class because otherwise things get unified too early
23:15:02 <skew> like, you write instance (TypeCase a b, SomeClass .. a.., OtherClas .. b..) => MyClass (a,b)
23:15:36 <skew> hoping to match anything of (a,b) and prevent falling back to a more general instance when you have a mismatched pair
23:16:24 <skew> but if you just have class TypeCast a b | a->b, b->a; instance TypeCast a a, then it realizes to early and essentialy makes the instance head MyClass (a,a)
23:16:39 <skew> a strange and unpleasant problem - type classes are not a very nice programming language
23:16:56 <dons> hmm. no, I agre
23:17:16 <dons> bring on type level functional programming, none of this logic programming brain teasing
23:17:21 <skew> we should just adopt Prolog or corry or something
23:17:45 <skew> I seem to recall that HM(X) doesn't restrict the X very much
23:17:59 <skew> heck, if type class resolution would just backtrack we'd be a lot happier
23:21:10 <eivuokko> Much!
23:23:50 <skew> Has anyone here communicated with Daan recently?
23:24:45 <skew> Morrow is about to be released a few weeks from last September :(
23:26:50 <sieni> "These constructs use one of the most powerful constructs of C++, a feature unmatched by any other language -- template template parameters." --Andrei Alexandrescu
23:27:22 <johnnowak> sieni: oi
23:28:14 <Cale> heh, *any* other language?
23:28:22 <Cale> that seems a little over the top
23:30:40 <skew> unmatched like COME FROM is unmatched, maybe
23:30:41 <sieni> of course in all fairness it should be said that he didn't actually specify the way in which that feature is unmatched.
23:31:32 <skew> yay, I got my reply to sieni's comment out before he even sent it :)
23:31:33 <sieni> the book is nice, though ("Modern C++ Design"), contains lots of nice template wizardry
23:31:45 <Cale> "No other language provides the exact same syntax and concrete implementation of this feature."
23:33:54 <vincenz> sieni: Alexandrescu?
23:34:06 <vincenz> sieni: it's great :)
23:34:12 <vincenz> sieni: I even used it to extend some stuff
23:34:20 <vincenz> sieni: like having the ability to curry functors
23:34:20 <vincenz> :D
23:34:59 <skew> "You can do a handful of things you can't manage with similar features in other language, but if you want to stay sane you'd be better off judging a beauty pagent of Elder Gods"
23:35:03 <sieni> Monads in C++: http://www-static.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
23:35:46 <cpatrick> aiiieeeeiiiieee
23:36:02 <cpatrick> And I thought the implementations I'd seen in Python and Ruby were ugly :P
23:37:31 <dons> template <class Rep> struct ThisTypeIsNotAnInstanceOfAnInferrableMonad
23:37:32 <sieni> I especially liked that part: typename RT<typename ::fcpp::BindM<Monad>::Type,M,typename LEType<LAM<LV<1>,CALL<typename ::fcpp::UnitM<Monad>::Type,CALL<F,LV<1> > > > >::Type>::ResultType> {};
23:37:34 <dons> that is so funny
23:37:36 <Cale> the comprehensions thing is "cute"
23:38:26 <vincenz> sieni: AHHHHHHHHHHHHHHHHH MY EYES\
23:38:31 <vincenz> anyways
23:38:37 <vincenz> I'm still stuck with the module issue
23:38:42 <vincenz> :(
23:39:15 <vincenz> I have figured out one restriction
23:39:22 <vincenz> no recursive modules
23:40:22 <dons> i'm kind of in shock after reading that
23:41:09 <dons> people can function and write working code in a language like that?
23:41:47 <vincenz> dons: it's a language designed to make some people feel superior
23:42:05 <vincenz> tho it basically ends up in a good parser, cause semantically the language is rather dull
23:42:38 <vincenz> I have to say th
23:42:46 <vincenz> one thing that I find funny is that you can code stuff with c++
23:42:51 <vincenz> that will lex, parse and type
23:42:56 <vincenz> but for which no semantics is defined
23:43:44 <mux> this is fugly
23:44:32 <dons> there's really no way to establish if that stuff is bug free, is there? 
23:44:38 <eivuokko> dons, Do you want honest reply or just mumbled agreement?
23:44:41 <dons> by reasoning about the code.
23:44:51 <dons> eivuokko: sure?
23:44:54 <eivuokko> dons, You get used to it.
23:45:12 <dons> i guess you must. i remember programming in java and not noticing all the gunk.
23:45:13 <eivuokko> That code atleast doesn't use preprocessor much.
23:45:49 <wilx> Heh, your average C++ code doesn't look like that :)
23:45:52 <eivuokko> And while syntax is without doubt pretty annoying, it atleast allows much more metaprogramming tasks than I've been able to bend typeclasses into.
23:46:13 <eivuokko> Yeah, that is library code - very ultimately extendable and reusable and possibly optimised.
23:46:33 <vincenz> eivuokko: what bugs me is that c++ is such a beast that just parsing it is a b*tch
23:47:05 <vincenz> aka there are no open source parsers out there
23:47:10 <vincenz> that are useful 
23:47:17 <vincenz> and complete
23:47:24 <eivuokko> vincenz, depends what's open source...ah usefull...was gonna say g++
23:47:34 <vincenz> and then if you want to do semantic analysis
23:47:43 <vincenz> well c++ is more hairy than .... a french woman's armpit
23:47:49 <wilx> lol
23:48:49 <eivuokko> It's pretty typical on all ISO/ANSI/etc standardised things that want ultimate backward compatibility.  Which was deemed neccesary to gain position in "industry" not so many years back.
23:49:18 <vincenz> eivuokko: yeah but trust me on this, the industry suffers under c++
23:49:25 <vincenz> severely
23:49:34 <eivuokko> vincenz, I don't trust you.  I don't think c++ is a significant problem.
23:49:41 <vincenz> I do
23:49:46 <wilx> Huh.
23:49:58 <wilx> I think C++ work pretty well for industry.
23:50:15 <vincenz> I work at a research institute focussed on embedded systems, from design tools for mapping software all the way down to nanostructures... One of the biggest hurdles is doing meaningful analysis of c++ to optimize it
23:50:27 <vincenz> and embedded systems != car-window controllers
23:50:42 <vincenz> in fact if you look at the embedded industry
23:50:43 <wilx> Optimize?
23:50:45 <vincenz> it all still operates on c
23:50:49 <vincenz> cause c++ is such a hairy beast
23:50:59 <vincenz> wilx: yep
23:51:05 <eivuokko> That doesn't sound industry problem.
23:51:16 <vincenz> eivuokko: embedded software industry
23:51:26 <wilx> What do you want to optimize? You should write optimal code and profile/benchark, if necessary.
23:51:28 <vincenz> which means... multimedia applications
23:51:37 <vincenz> cause they typically get mapped to embedded systems
23:51:41 <vincenz> wilx: right
23:52:17 <vincenz> mpeg 2 was written in c, no prob, mpeg 4 is in c++, that's gonna be a serious effort to map it to embedded systems
23:52:24 <wilx> I suspect one of the problems is there are no good C++ compilers for embedded systems.
23:52:38 <vincenz> wilx: yes for the aforementioned reasons
23:52:45 <vincenz> wilx: and that was my statement
23:52:52 <vincenz> there are no (good) C++ compilers for embedded systems
23:52:59 <vincenz> good is optional
23:53:18 <Korollary> what are some c++ compilers for embedded systems?
23:53:27 * vincenz ponders
23:53:34 <wilx> eVC
23:53:34 <vincenz> I think some newer TI's have c++ compilers
23:53:35 <vincenz> not sure
23:53:57 <wilx> eVC4, that I worked with, pre-standard, old and ugly.
23:54:14 <eivuokko> eVC, g++, and metrowerks
23:54:24 <Korollary> ah, metrowerks
23:54:26 <eivuokko> Are probably most common embedded c++ compilers.
23:54:26 <vincenz> except they're rather.... generic
23:54:34 <vincenz> if you got to more complex systems
23:54:39 <vincenz> like heterogeneous multicore
23:54:42 <vincenz> you run into problems
23:54:54 <vincenz> and heterogeneous multicore is the future
23:54:56 <wilx> Well, I don't see what could be the problem here.
23:55:05 <eivuokko> wilx, he means automatically using the cores.
23:55:11 <vincenz> amongst other things
23:55:14 <wilx> Only maybe if an architecture is too weird...
23:55:15 <vincenz> but there are other issues
23:55:18 <vincenz> scheduling, datamapping
23:55:30 <vincenz> taskmapping
23:55:38 <vincenz> data parallelisation for VLIW
23:55:46 <vincenz> ...
23:55:51 <vincenz> an amalgam of things
23:55:54 <wilx> I cannot see how is this different from C.
23:56:04 <vincenz> wilx: because c++ is so hairy to analyse and parse
23:56:07 <vincenz> nooen feels like writing a parser
23:56:09 <vincenz> in fact
23:56:18 <vincenz> there are atm only 3 parsers for c++ that I know of
23:56:22 <wilx> Eh, parser is imo not the problem.
23:56:30 <vincenz> elsa/elkhound @berkeley which is imcomplete
23:56:30 <wilx> There are existing compilers with parsers.
23:56:40 <eivuokko> wilx, Have you written one? :)  It's pretty annoying.
23:56:41 <wilx> All you should need is to port them to your architecture.
23:56:42 <vincenz> EJB
23:56:46 <Korollary> embedded people tend to be into static analysis
23:56:50 <vincenz> yep
23:56:53 <vincenz> and...
23:56:56 <vincenz> erm
23:56:57 <vincenz> not eJB
23:57:01 <vincenz> edgar ... something
23:57:03 <vincenz> forgot the name
23:57:12 <vincenz> and another one but I can't remember
23:57:16 <Korollary> C++ is quite a large language actually.
23:57:20 <vincenz> the problem with mapping to embedded systems
23:57:29 <vincenz> is basically that you need highlevel info @ source code
23:57:33 <vincenz> cause it can never be fully automated
23:57:44 <vincenz> the only solution atm... is to use something like EDG (that's it)
23:57:46 <vincenz> which gives UGLY c
23:57:48 <vincenz> and then go from there
23:58:05 <vincenz> but ideally you can see the tradeoffs on your original c++ program
23:58:17 <vincenz> and that's where the shoe doesn't fit nicely
23:58:27 <vincenz> hence most of the embedded world working on c
23:58:43 <Korollary> Does garbage collection cause problems in embedded systems?
23:58:56 <eivuokko> Depends.
23:58:57 <vincenz> Korollary: dunno
23:59:04 <vincenz> Korollary: depensd on the type of system you have
23:59:10 <vincenz> hard real time will never use it
23:59:14 <vincenz> soft real time I think are skeptical
23:59:33 <eivuokko> Nowdays embedded systems start to have significant memory, and it's less of a problem.  So called realtime often can't take latency still.
23:59:47 <vincenz> eivuokko: still...embedded systems have hierarchical memory layouts
23:59:55 <vincenz> eivuokko: you want to analyse what you want to put close and twhat you want to put far
