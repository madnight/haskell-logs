00:14:49 <kolmodin> @where paste
00:14:49 <lambdabot> http://rafb.net/paste
00:39:03 <RvGaTe> morning...
01:14:36 <kzm> I'm looking at STM - I notice the paper (Harris et al) says little about message-passing paradigms.
01:14:51 <kzm> Does it have the same drawbacks as locking?  It seems some things would be better?
01:16:58 <jethr0> it's easier to handle than locking but in a case of thrashing it might perform worse, afaik.
01:18:04 <jethr0> STM has far less problems with race conditions and such, but i think it can still suffer from starvation. but then i've only read the paper once and that's been a while ago :)
01:18:26 <integral> *nod* starvation is the thing it doesn't prevent
01:18:37 <dons> moin
01:22:07 <jethr0> maybe road intersections and turn-abouts (or whatever the round thingeys are called) are a good analogy
01:22:59 <jethr0> in low traffic turn-abouts adapt much better to traffic, but in a grid-lock situation intersections with traffic lights behave better. not sure whether this applies to locks vs. STM directly though :)
01:24:05 <jethr0> bbl
01:26:22 <jethr0> main point though, is that STMs are composable and locks ain't
01:29:23 <kzm> Hmm...which one is turnabouts and which is traffic lights? :-)
01:30:07 <kzm> The example, where you atomically move an item from one collection to another; can you even do that atomically with message passing?
01:35:42 <kzm> Why is locking better against starvation?  (Or perhaps you were talking about message passing?)
01:44:45 <shapr> Good morning #haskell!
01:44:58 * shapr locks kzm into the cafeteria
01:46:01 * kzm thinks it was about time.  I'll have a latte, please.
01:46:21 <kzm> :-)
01:46:24 * shapr grins
01:46:25 <shapr> What's up?
01:46:32 <kzm> STM?
01:46:37 <shapr> hm, sounds nice.
01:47:16 <kzm> I'll do an in-house presentation about it, I think.  Somewhat ambitious, since I just read the paper.
01:47:51 <kzm> But, as they say, with enough coffee, anything is possible.
01:48:12 <shapr> And it's true!
01:50:06 * shapr makes coffee
01:53:26 <norpan> i almost collided with an old man today
01:53:29 <norpan> on my bike
01:53:34 <norpan> stupid old people
01:54:19 <norpan> i should have hit him
01:56:12 <shapr> Hey, us old people aren't stupid.
01:56:17 * shapr snickers
01:56:33 <norpan> he shouldn't be allowed to rida a bike
01:57:07 <norpan> he biked over a pedestrian crossing
01:57:21 <norpan> i wish i hadn't braked
02:01:51 <rjlwanro> YOU shouldn't be allowed to bike!
02:02:29 <rjlwanro> besides, I still like the idea of having #haskell-blah for off-topic talk like biking. But who am I anyway? :)
02:06:46 <Azmo> how does one catch an exception that is not from an IO computation? like in "1 `div` 0".
02:07:58 <shapr> catch?
02:08:31 <Azmo> which one? there are many. i see only ones that works on IO.
02:09:16 <ski> you can't catch in non-IO code
02:09:19 <int-e> 1 `div` 0 is an error value; it does not become an exception before it's being used by some IO action.
02:09:36 <int-e> and in IO you can catch it.
02:10:06 <Azmo> ah, ok.
02:10:59 <Saulzar> Though you can handle errors in non IO code if you want to, if you made a 'maybeDiv' for example 
02:11:11 <Lemmih> int-e: I disagree.
02:11:19 <Azmo> no way to force it to be evaluated and cause the exception so that it can be catched without doing any output?. e.g "print :: (Show a) => a -> IO ()" prints, but what about producing the exception without doing something if there was no exception?
02:11:21 <RvGaTe> ...
02:12:41 <Azmo> (\x->if (x==x)==(x==x) then return x else return x)  seems to work, but requires Eq. :/
02:14:20 <int-e> > error "foo" `seq` 42
02:14:21 <lambdabot> Exception: foo
02:14:22 <int-e> hmm.
02:16:46 <ski> > [error "foo",17] `seq` 42
02:16:47 <lambdabot> 42
02:16:58 <int-e> Anyway, evaluation is forced by IO actions.
02:17:09 <Cale> Azmo: seq
02:17:22 <Cale> or Control.Exception.evaluate
02:17:32 <int-e> @type Control.Exception.evaluate
02:17:34 <lambdabot> forall a. a -> IO a
02:17:52 <Cale> the IO action forces evaluation in sequence with the other IO actions
02:17:58 <mathrick_> prolog is fun
02:18:09 <Cale> it's specifically so that you can reliably catch a thrown exception
02:18:12 <Azmo> nice. Control.Exception.evaluate is what i was looking for.
02:18:35 <Cale> note that it only evaluates the topmost constructor in a compound structure
02:18:47 <Cale> so if you want more, you'll have to do some recursion with seq
02:18:59 <Azmo> hm... ok
02:33:06 <Azmo> :r
02:51:52 <dcoutts> dons, sjanssen: yes I agree. I think we should have an innefecient unfoldr with the normal signature and that unfoldrN should return the final seed value
02:52:21 <dcoutts> since that final value is useful if you run over the N chunk size
02:52:50 <dcoutts> so it allows people to recover rather than chuking work away
02:53:02 <dcoutts> so they can pick an expected N rather than a maximum N
02:53:13 <dcoutts> and recover if it was bigger than expected
02:53:34 <dcoutts> yes, and it'd also be useful for Lazy.unfoldr
03:05:31 <dcoutts> dons, unfoldr needen't be O(n^2). You could unfoldr in chunks and then concat them at the end. That's linear.
03:12:47 <shapr> I just had the weirdest experience with X. When the composite extension is turned on, some fonts won't display. It looks like it's only ttf fonts. Hours of fiddling later, I discovered that after I run xlsfonts, those fonts will now display, but they still won't show in the mozilla flashplayer plugin.
03:13:41 <jethr0> huh. i'm having some fonts problems myself. since i've switched to ttf fonts as default my firefox is considerably slower. and i mean _really_ slow
03:14:12 <shapr> X is *really* fast with DAMAGE, RENDER, and Composite turned off. I only wish it could show ttf fonts in flashplayer at the same time.
03:14:32 <jethr0> :)
03:14:48 <norpan> hmmm, Composite, what's that
03:15:20 <shapr> I played with xcompmgr a bit too, turned on shadows and menu fade - http://www.scannedinavian.com/~shae/composite.png
03:15:39 <shapr> It's really sexy to swap workspaces in ion and have it fade from one to the other.
03:16:02 <psi> have you tried compiz?
03:16:10 <shapr> It's not in debian/unstable yet, is it?
03:16:18 <shapr> I want to try glxcompmgr
03:16:19 <skew> hah, ion with eyecandy
03:16:27 <shapr> skew: bizarre, ain't it?
03:16:32 <skew> tumov must be rolling in his grave
03:16:40 <shapr> Good thing he's not here ;-)
03:16:49 <jethr0> i like transparency and the like as much as the next guy, but i seriously think they are overrated. even in OSX which uses them nicely i'm not so sure whether they don't reduce productivity
03:16:50 <psi> shapr: hm, dunno. I think it is in ubuntu.
03:17:07 <psi> compiz has exposé like OS X. it's pretty neat.
03:17:10 <shapr> jethr0: Nah, but they're cute for those bored moments.
03:17:16 <jethr0> :)
03:17:19 <norpan> well, eycandy perhaps, but those shadow effects were ugly :)
03:17:44 <shapr> glxcompmgr with Xgl seems to do exposé too, whatever that is.. I found pix on flickr about that.
03:18:03 <psi> alt-tab shows a live preview of your windows. even videos keep playing.
03:18:08 <shapr> norpan: I just turned on the basic effects, you can set them however you like.
03:18:19 <jethr0> yes, those shadows are more like eye-vegetables ^_^
03:18:22 <shapr> haha
03:18:30 <norpan> fruit IS candy
03:18:49 <jethr0> norpan: ok, you tell me what the opposite of candy is, if not vegetables :)
03:18:50 <shapr> Admittedly, my screen would look better if I had a digital lcd monitor so I could use subpixel rendering.
03:19:08 <jethr0> subpixel rendering is evil
03:19:16 <shapr> Looks nice though.
03:19:22 <Cale> why is it evil?
03:19:49 <jethr0> tuomov - "No. Antialiasing is an ugly self-defeating kludge, as is subpixel placement."
03:20:03 <eivuokko> Huh.
03:20:12 <shapr> I wonder if I should have run "xlsfonts -l" before I started firefox? Think that might fix the flashplayer problem?
03:20:27 <shapr> jethr0: I wonder wath tuomov thinks about macromedia flash...
03:20:37 * shapr dons asbestos underwear...
03:20:48 <Cale> It seems like a reasonable software solution to increase percieved resolution where otherwise you'd have to pay for much more expensive or nonexistent hardware.
03:20:51 <skew> jethr0: how else are you supposed to quantize stuff down to pixels?
03:20:53 <jethr0> Cale: nm, i'm just not a big fan. spoiled by evil resolution interpolation *brr*
03:21:52 <jethr0> there's always a danger of aliasing due to the raster organisation of pixels/subpixels. but to be honest i haven't got a clue what i'm talking about :(
03:21:56 <shapr> jethr0: Anyway, if you're using X.org 7.0+ try DAMAGE, RENDER, and Composite. It's *much* faster than anything else I've tried.
03:22:06 <jethr0> shapr: k, will do
03:22:29 <skew> I think it's something like an order of magnitude in screen resolution before you're hitting the limits of the retina
03:22:30 <mauke> do you know a basic X tutorial? for writing C programs, I mean
03:22:47 <shapr> Today and yesterday, I learned more than I ever wanted to know about the state of font display technology in X.org.
03:22:55 <shapr> mauke: use HSX11!
03:23:04 <psi> shapr: is it faster with them turned on? you said off earlier.
03:23:14 <shapr> psi: Faster with them on, very much faster.
03:23:23 <jethr0> font management can be pretty tiring in x in general. especially when you are not one of the developers :)
03:23:24 <mauke> shapr: where?
03:23:25 <skew> I want something like this: http://xenia.media.mit.edu/~lucente/holo/holovideo.html
03:23:29 <shapr> But I can't use Composite and flashplayer at the same time, sadly.
03:23:37 <shapr> jethr0: truly
03:24:03 <shapr> skew: wow, awesome
03:24:16 <jethr0> what are those molecules that come out of the display :)
03:24:23 <psi> the linux version of flash sucks in general, unfortunatly.
03:24:38 <psi> makes flash even more annoying :)
03:24:49 <shapr> psi: Yeah, the plugin is badly written and 1.5 versions behind.
03:25:18 <shapr> Muad_Dibber asked me about the strengths of flash recently
03:25:27 <shapr> <shapr> It's basically the hi-tech equivalent of <BLINK> with the added downsides that it's proprietary, inconsistent, slow, flaky, platform specific, not safe for privacy or daily use in browsers, and property of Adobe.
03:25:30 <jethr0> such a bad idea to make many websites dependent on seriously closed software. at some point it looked as if flash was waning, but sadly it's had a comeback with youtube and image slide shows :(
03:26:02 <shapr> SVG could kill Flash if only Firefox would implement SVG 1.1 Full natively.
03:26:22 <shapr> Seems that won't happen until ff 2.0 :-(
03:26:46 <jethr0> i don't have flash installed and i just hate flash ONLY sites. if at least they present a toned-down html page, but NO!
03:26:51 <shapr> I started with SVG - http://www.scannedinavian.com/~shae/svg/smilScript.svg - but the bug squish game was very hard to write and I got frustrated.
03:27:14 <shapr> At this point you can click on the bug and it squishes and that's all.
03:27:38 * jethr0 doesn't believe in svg replacing flash soon. IE won't support it just as it doesn't/didn't support png. we'll have to live with stupid flash sites for many years to come
03:27:45 <shapr> My experiments with flash have been far more successful, http://haxe.org/tutos/protos/prototypes
03:28:06 <shapr> jethr0: Nah, I'll write an SVG renderer in Flash :-)
03:28:31 <shapr> Then SVG will be the only way to do true cross platform goodness.
03:28:55 <jethr0> flash is nice, but i don't see a reason not to replace it with sth free. it's not like there's incredible amounts of voodoo involved. all you need is vector graphics, some kind of transformations and an evil scripting language *g*
03:29:27 <jethr0> shapr: rather write a flash-compatible svg application that can actually play flash files natively
03:29:40 <shapr> That's SVG and SMIL. Problem is that Firefox doesn't implement it yet.
03:29:52 <shapr> The only decent SVG viewer is by Adobe, and they also own Flash.
03:29:54 <jethr0> nobody does
03:30:43 <jethr0> and i don't mean the language per se, but also some tools to create content. like macromedia director or similar. as i said, i don't see the problem in writing free alternatives there
03:31:33 <shapr> I don't really dig the tool problem. I'm doing fine with emacs, make and haXe.
03:31:42 <shapr> And inkscape for graphics.
03:32:13 <shapr> My professional graphic designer friend says she couldn't do without graphical IDE style tools, I just don't get it.
03:32:16 <jethr0> shapr: i'm a very text-centric guy also, but most people using flash don't have a clue how a programming language looks like, and those are the ones cluttering the web with flash-only content
03:32:41 <shapr> skew: Hey, I sent an email to Wouter van Oortmerssen asking for a tutorial, he pointed me to his thesis, even though I said I'd already gone through it :-(
03:33:10 <jethr0> the thesis IS the tutorial
03:33:26 <shapr> In that case, Wouter doesn't much want people to use Aardappel, does he?
03:34:06 <jethr0> i thought that was a past project. didn't know anyone would be using that, but then there's always you :)
03:34:14 <jethr0> shapr: have you seen "sauerbraten"
03:34:15 <shapr> :-P
03:34:24 <shapr> Yup, it's cool. Wait, the language or the Cube successor?
03:34:45 <jethr0> i was amazed how big the maps are that can be loaded. i hope that single player mod will get somewhere
03:34:54 <jethr0> nah, cube successor
03:35:11 <shapr> Wouter really needs to come up with names that are easier to find with google.
03:35:38 <jethr0> i'd really like to witness 20 people working collaboratively on one level. that should be quite the experience :)
03:35:38 <skew> Aardappel is pretty good for that
03:35:50 <jethr0> @google sauerbraten engine
03:35:52 <lambdabot> http://sauerbraten.org/
03:36:28 <skew> it seems like all the hardware predictions from the holovideo publications are here, so why can't I buy one of them?
03:36:45 <jethr0> k, time for lunch
03:36:50 <shapr> I think Self/Kansas is better for 20 person collaborations.
03:36:58 <shapr> Haven't tried Squeak/Nebraska though.
03:36:58 * skew wants a holographic display *NOW*
03:37:25 <shapr> I'd rather have stereo augmented reality glasses.
03:37:46 <skew> shapr: what are these collaboration things?
03:37:58 <shapr> You know Self?
03:38:04 <jethr0> squeak/"alice in wonderland" is annoyingly unstable though. not quite ready for internet usage :(
03:38:23 <jethr0> shapr: i did research with those glasses and they give you a headache FAST
03:38:33 <jethr0> shapr: bbl, i can tell you about them after lunch :)
03:38:37 <shapr> Why? ok
03:38:45 <shapr> I should get back to flashing...
03:38:57 <skew> Self, not particularly
03:39:22 <skew> @google Self Kansas
03:39:24 <lambdabot> http://collegebasketball.rivals.com/viewcoach.asp?Coach=734
03:39:29 <skew> yeah
03:39:50 <skew> yahoo turns up "Kansas Self-Insurers Association (KSIA)"
03:41:25 <shapr> skew: http://research.sun.com/ics/kansas.html
03:41:36 <shapr> I tried it once with Darius when I was in Seattle
03:42:23 <shapr> I've tried it by myself on multiple displays in the same room, it's way nifty.
03:43:03 <skew> I've been talking about him a bit about how to use fancy UI devices
03:43:10 <skew> like this: http://mrl.nyu.edu/~jhan/ftirtouch/
03:45:29 <shapr> That's cool.
03:47:07 <skew> I bet some nifty coding UI could be devised for a table made of that stuff
03:47:53 <skew> another question, do you know if there are persistent set implementations with amortized log time merge operations?
03:48:38 <shapr> Okasaki is the man for amortized.
03:50:35 <dozer> is there a function Monad m => Monad n => m a -> (a -> n b) -> n b
03:50:44 <dozer> that acts like >>= but changes monad?
03:51:06 <shapr> lift
03:51:52 <skew> Okasaki did a priority queue, but I didn't find a set
04:00:13 <dozer> shapr: thx - was looking at liftM that does something different
04:04:48 <shapr> dozer: Sure, any other questions?
04:09:00 <Cale> though lift doesn't quite have that type
04:09:12 <Cale> I suppose it's about as close as you'll get
04:10:53 <Lemmih> musasabi: ping.
04:11:56 <vincenz> Lemmih: pong
04:21:08 <Lemmih> vincenz: pang.
04:26:32 * mux waves hello
04:27:21 * vincenz dies by the bullet
04:27:54 <vincenz> Lemmih: how hard is it to get into GHC to make some modifications
04:31:14 <dons> dcoutts: yep. sjanssen also suggested unfolding and reallocating. chunks might be better though
04:32:01 <dcoutts> dons, and it'd be simpler to implement in terms of an unfoldrN that returns the seed
04:32:02 <Lemmih> vincenz: Depends on what you wanna change.
04:32:25 <vincenz> Lemmih: is there some overal document?
04:32:30 <dcoutts> dons, because it'd be the same as the .Lazy version but with an extra P.concat
04:33:27 <Lemmih> vincenz: Not really.
04:33:30 <vincenz> :/
04:33:54 <dons> dcoutts: ah, see also a dicussion with sjanssen today. he's workign on the seded version
04:34:03 <dcoutts> dons, great
04:34:06 <dons> i think, wait 12 hours, and sjanssen will have your code for you.
04:34:11 <dcoutts> :-)
04:34:20 <Lemmih> vincenz: You might want to look at these papers: http://hackage.haskell.org/trac/ghc/wiki/GhcPapers
04:34:33 <vincenz> thanks
04:34:47 <dcoutts> dons, I agree that dumping elems was right
04:35:09 <vincenz> Lemmih: it concerns the class aliases
04:35:17 <testaki> dons, I agree that dumping elems was right
04:35:17 <testaki> <vincenz> Lemmih: it concerns the class aliases
04:35:19 <testaki> dons, I agree that dumping elems was right
04:35:19 <testaki> <vincenz> Lemmih: it concerns the class aliases
04:35:20 <dons> yep. once it hit me that it was just a silly unpack.
04:35:20 <dons> @ty
04:35:20 <vincenz> Lemmih: it's probably not overly complicated but will require changes all over
04:35:21 <lambdabot> not an expression: `'
04:35:24 <dons> pe @type elems
04:35:28 <testaki> sorry
04:35:33 <dons> @hoogle elems
04:35:33 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
04:35:33 <lambdabot> Data.Array.elems :: Ix i => Array i e -> [e]
04:35:33 <lambdabot> Data.IntMap.elems :: IntMap a -> [a]
04:36:01 <dons> our elems didn't even have the right type.
04:36:01 <vincenz> Lemmih: and these changes will have to be linked of course, so a document that would give an overview in that sense could be useful (if you change x here, it has repercussions there and there
04:36:19 <dcoutts> dons, I was also thinking that cons should do some minimal coalesing
04:36:24 <vincenz> testaki: where in greece are you from
04:36:46 <eivuokko> vincenz, Such deps are usually in comments, if they are documented at all.
04:36:56 <dcoutts> dons, there will be some threshold where coalesing 1byte onto an existing chunk is faster than allocating a new chunk
04:37:27 <dcoutts> dons, I mean suppose we do: cons x (cons x' xs)
04:37:37 <vincenz> eivuokko: Yep and I fear that class aliaes will require small changes but all throughout the system, from the lexer to the parser, to the typechecker, to the .hi..
04:37:50 <Lemmih> vincenz: I wish there were such a document.
04:37:52 <vincenz> it's a vertically deep but horizontally slim change
04:37:54 <dons> hmm. could we write a rule?
04:37:56 <dcoutts> dons, then we're allocating two chunks just one byte each, but in fact each chunk is something like 20bytes right?
04:38:10 <vincenz> Lemmih: I fear that one issue with no such document is that there is no good model for FP, nothing like UML
04:38:11 <eivuokko> vincenz, Yeah, as do most extensions...
04:38:17 <dcoutts> dons, no I mean dynamically, you could do a rule too for the static case if possble
04:39:05 <dcoutts> dons, so when we do the second cons it's about as expensive to allocate 20+1 bytes and copy the few bytes over
04:39:31 <vincenz> if the ghc hackathon were in europe I might attend, but flying to the us for two days is not monetarily rationifiable
04:39:35 <dcoutts> dons, I'd guess that a reasonable threshold might be 16, 32 bytes or something
04:39:50 <eivuokko> vincenz, Yeah, me too.
04:39:53 <vincenz> is anyone going?
04:39:54 <dcoutts> dons, more particularly it saves space
04:39:57 <vincenz> could they possibly podcast it???
04:41:51 <dons> seems  reasonable. work out the numbers and go for it.
04:42:12 * dons gets some dinner. back later
04:50:24 * vincenz bleghs as he looks at a stack of 10 papers he has to read just to review another paper
04:51:10 <testaki> vincenz : athens
05:07:41 <Philippa> <vincenz> Lemmih: I fear that one issue with no such document is that there is no good model for FP, nothing like UML <- it seems to me that all you need is to allow undefined to denote something other than "program is meaningless" and you've got your modelling in-language
05:17:24 <MrHuskell> Hello
05:17:33 <psnl> hello
05:17:57 <MrHuskell> Nice, Some activity =). Just checkin this chan out, new to haskell.
05:19:39 <MrHuskell> You guys know of there is a IRC-newbe-medium lvl haskell IRC chan out there somewhere? Or is this the place to pester all you seasoned Haskell hackers with stupid questions?
05:20:38 <mauke> just ask, we'll tell you if it gets too annoying :-)
05:21:29 <MrHuskell> hehe, thnx, Well. Infact I do have a question =). Are there nested guards in Haskell? Can't seem to figure out the syntax for those
05:21:49 <mauke> what are nested guards?
05:22:24 <vincenz> HOLY CRAP
05:22:32 <vincenz> There was thunder outside and my desktop got fried :(
05:23:10 <MrHuskell> something like this : ( | a > b ( | b > c = 1 | otherwise = 2 ) | otherwise = 0  (Try to imagine breaks at right places) 
05:23:36 <mauke> I think you can't do that
05:24:01 <MrHuskell> ok, I'll abandon that idea then =)
05:24:11 <mauke> | a > b = if b > c then 1 else 2
05:24:15 <mauke> | otherwise = 0
05:24:32 <vincenz> there is a way to do that
05:24:35 <vincenz> just an ugly hack
05:24:37 <MrHuskell> yea, solved it like that so far
05:25:14 <vincenz> > let a = 3;b=2;c=1 in fromEnum (a > b) * (1+fromEnum (b>c))
05:25:14 <lambdabot> 2
05:25:21 <vincenz> > let a = 3;b=2;c=3 in fromEnum (a > b) * (1+fromEnum (b>c))
05:25:21 <lambdabot> 1
05:25:28 <vincenz> > let a = 1;b=2;c=1 in fromEnum (a > b) * (1+fromEnum (b>c))
05:25:28 <lambdabot> 0
05:25:47 <mauke> nice
05:25:54 <MrHuskell> ok, Did I mention I'm new at this =), but that looks pretty crazy
05:26:07 <mauke> math'd
05:26:23 <eivuokko> Or you could use where, variables binded in where are available in guards.
05:26:24 <vincenz> :(
05:26:27 <vincenz> my computer got fried
05:26:34 <MrHuskell> ok
05:27:01 <vincenz> hopefully it's just the powersupply but my desktop switched off during the thunderstorm a few minutes ago
05:27:02 <eivuokko> foo | a && b = ..; | a&&c = ..; where a = ..; b = .. or so.
05:27:23 <MrHuskell> yea
05:27:31 <Eelis> vincenz: did the lights go out, too?
05:27:36 <vincenz> Eelis: nope
05:27:43 <Eelis> hmm
05:27:45 <vincenz> Eelis: fortunately it didn't fry my laptop on which I'm working
05:27:53 <vincenz> cause all my work is on it
05:28:04 <Eelis> you do have backups elsewhere, right? ;)
05:28:12 * vincenz hopes his 250G hd in his desktop is still functional ... gonna go out and buy a case
05:28:16 <vincenz> Eelis: I backed up onto my desktops hd
05:28:22 <Eelis> i see
05:28:25 <vincenz> hopefully it'll still work
05:28:27 <vincenz> most likely
05:28:31 <vincenz> the computer jsut won't turn on
05:31:13 <jethr0> doing regular and structured backups is astonishingly much work. at some point my automatic backup scheme breaks for some reason and then i'm too lazy to look after it :(
06:01:17 <dozer> @hoogle liftIO
06:01:17 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
06:01:24 <dozer> this was what I actually wanted
07:01:46 <petekaz> While trying to learn haskell, I've been thinking about how I might implement a previous project of mine that was written in Java (and before that Python).  So, the first question that came to mind, is it possible to get a reference to a constructor given a String?
07:02:21 <vincenz> well if the data constructors belong to one type you could make a lookup map
07:02:22 <petekaz> Say I have a type:  data VoipGateway = AS5300 String Int
07:03:00 <petekaz> In a text file, can I have "AS5300 x.x.x.x 1520" and then construct an instance of that type?
07:03:05 <vincenz> yes
07:03:11 <vincenz> implement Read
07:03:23 <davidhouse> don't implement Read, it's slow.
07:03:24 <vincenz> > read "True" :: Boolean
07:03:25 <lambdabot>  Not in scope: type constructor or class `Boolean'
07:03:29 <vincenz> > read "True" :: Bool
07:03:31 <lambdabot> True
07:03:37 <petekaz> I see.
07:03:37 <Eelis> xerox: ping (re. gtk2hs)
07:03:48 <petekaz> davidhouse: what would you suggest then?
07:03:51 <davidhouse> petekaz: you basically want to parse a string into that datatype of yours?
07:03:54 <Lemmih> davidhouse: Not necessarily.
07:04:00 <vincenz> davidhouse: it's an exact replica of his type
07:04:03 <vincenz> read and show are simpler in this case
07:04:15 <vincenz> "optimize only when necessary"
07:04:24 <petekaz> davidhouse: Yes.  The file may refer to many constructors of the same type.
07:04:39 <vincenz> petekaz: if they replicate what you would type in haskell exactly
07:04:41 <davidhouse> oh, you're right, this is actually extremely easy. yes, Read would probably do.
07:04:42 <vincenz> you can just do
07:04:48 <davidhouse> can you derive Read?
07:04:57 <vincenz> data VoipGateWay = AS53000 Stirng Int deriving(Read)
07:05:22 <petekaz> In my Java version, I have an XML file that basically has a serialized object.  Just thinking of how I would do that in haskell.
07:05:33 <petekaz> Thanks!  That was very easy!
07:05:46 <vincenz> petekaz: and contrarily
07:05:50 <vincenz> deriving (Read, Show)
07:06:32 <davidhouse> if you want to serialise to XML, you probably don't want to derive Show, but instead seperately instantiate it.
07:06:33 <petekaz> A question regarding "deriving", is it possible to make a type of your own and let others "derive" it?
07:06:47 <petekaz> Or is that just a builtin compiler trick for "special" classes?
07:06:50 <sjanssen_> petekaz: nope, deriving is at the site of definition only
07:06:55 <davidhouse> petekaz: firstly, you can only derive type _classes_, not types. and no, i don't think so.
07:07:17 <vincenz> petekaz: it's a builtin compiler trick for some generally used classese
07:07:26 <davidhouse> but it's good practice to always derive, say, Eq and Show for your datatypes.
07:08:01 * Lemmih disagrees.
07:08:01 <davidhouse> some in built classes can't be derived either, like Monad (unless you use the cunning newtype-deriving extension, but even that doesn't work all the time)
07:08:07 <petekaz> ok, thanks.  It would be uber cool if one could make their own Class and let others derive it.
07:08:14 <davidhouse> Lemmih: whyso?
07:08:35 <sjanssen_> petekaz: there are tools like DrIFT, a preprocessor that lets you derive more classes
07:08:49 <Lemmih> davidhouse: You should only derive the classes that makes sense for the data type.
07:09:09 <davidhouse> Lemmih: okay. when does it not make sense to derive Eq and Show?
07:09:32 <sjanssen_> davidhouse: State monad
07:09:50 <petekaz> I'm just thinking of say an XML serialization.  It would be neat to be able to say "deriving (XML)".
07:10:11 <davidhouse> sjanssen_, can you derive anything on functional types?
07:10:16 <Lemmih> davidhouse: Almost none of the data types in GHC derive Eq and Show.
07:10:19 <kolmodin> davidhouse: any data type containing a function
07:10:28 <kolmodin> :)
07:10:37 <davidhouse> kolmodin: sorry?
07:10:42 <sjanssen_> petekaz: http://repetae.net/john/computer/haskell/DrIFT/ -- it supports this
07:10:49 <sjanssen_> davidhouse: good point
07:11:02 <vincenz> sjanssen_: you're the guy from repetae?
07:11:15 <sjanssen_> vincenz: no, that's John Meacham
07:11:26 <sjanssen_> of JHC fame
07:11:28 <davidhouse> Lemmih: you mean they instantiate seperately or just don't instantiate them at all?
07:12:38 <Lemmih> davidhouse: The latter.
07:13:00 <davidhouse> hmm
07:13:20 <davidhouse> really?
07:13:21 <sjanssen_> davidhouse: there are also times when the derived behavior is the wrong behavior, like Eq with Data.Map.Map for example
07:13:57 <davidhouse> sjanssen_, yes, true.
07:14:02 <davidhouse> and Set, say.
07:14:13 <davidhouse> e.g. { 1, 2, 2 } = { 1, 2 }
07:14:34 <petekaz> sjanssen_: re: drift neat.  Too bad there was no builtin features to haskell to permit this though vs preprocessing.  I'm used to lisp, python, and ruby dynamic features.
07:14:53 <davidhouse> petekaz: there is for a lot of classes
07:15:03 <sjanssen_> petekaz: I'm sure you can do what DrIFT does with Template Haskell
07:15:05 <davidhouse> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
07:15:31 <petekaz> you guys are great ...
07:15:47 <davidhouse> newtype deriving covers most cases; for anything beyond that you can either (gasp!) write the instance decls (not a great deal), or use something metacodey like TH or DrIFT.
07:16:10 <sjanssen_> I'm of the opinion that the defining module of a type should have instances for all the common classes that are possible
07:16:22 <petekaz> This template haskell sounds cool ... similar to Lisp macros?
07:16:59 <sjanssen_> when the client starts writing instances for types, you have collisions between instances for the same type
07:17:38 <sjanssen_> petekaz: I don't know much about it, it lets you generate Haskell at compile time in Haskell
07:21:42 <MrHuskell> You guys know of any Haskell "portal" other then haskell.org?
07:23:47 <davidhouse> MrHuskell: i think there's a planet haskell somewhere
07:23:55 <davidhouse> which aggregates haskell-related blogs
07:23:59 <sjanssen_> MrHuskell: sequence.complete.org has some stuff
07:24:19 <MrHuskell> ok, thnx guys I will check it out
07:24:30 <petekaz> One more question.  Is this HAppsS server the main web app server for Haskell that everyone uses?
07:25:04 <sjanssen_> HAppsS is fairly new, I don't know many projects that use it
07:25:11 <petekaz> Almost all practical programs I write these days have web interfaces so I need to find a good haskell app server for my stuff.
07:25:21 <shapr> I want a t-shirt that says "Geeks really answer the question. Just say "Hello" if you don't want to know how I'm doing."
07:25:22 <sjanssen_> I don't know many Haskell web app's at all, really
07:25:59 <shapr> Flippi just uses CGI
07:26:02 <Eelis> shapr: or you could just ignore the question and say "Hello" yourself
07:26:21 <shapr> Simon Marlow's HWS (Haskell Web Server) is popular, but HAppS has a longer feature list.
07:26:28 <shapr> I haven't used HAppS yet, though I hope to soon.
07:26:44 <petekaz> Ok. Looks like I'll check them both out.
07:26:47 <shapr> Eelis: Yeh, but I don't know when people are asking rote questions and when they really want to know.
07:27:14 <petekaz> I definitely can't sneak haskell in at work unless I have a nice web server.
07:27:22 <shapr> For example, my girlfriend asked me why sounds are higher when coming towards and lower when going away, so I started to explain Doppler radar, etc.
07:27:46 <shapr> I quickly realized she just wanted a one sentence explanation.
07:27:56 <sjanssen_> shapr: "Physics."
07:28:12 <shapr> Yeah well...
07:28:17 <Eelis> that has nothing to do with social conventions or questions that aren't.
07:28:22 <dcoutts> Eelis, did you get an answer to your gtk2hs question?
07:28:34 <Eelis> dcoutts: well, i haven't asked it yet :)
07:28:54 <dcoutts> heh, that might help with getting an answer ;-)
07:29:18 <Eelis> dcoutts: my question is whether gtk2hs 0.9.10 supports an opengl canvas
07:29:38 <Eelis> i installed gtk2hs, it works, but there doesn't seem to be an opengl canvas, contrary to what xerox said the other day
07:29:43 <dcoutts> Eelis, no. That's in the current development version and will be in 0.9.11
07:29:56 <Eelis> ah, i see. what's the ETA on that?
07:30:02 <dcoutts> Eelis, try the current development version
07:30:13 <Eelis> do i need to do cvs magic or can i just download it?
07:30:20 <dcoutts> darcs get --partial http://darcs.haskell.org/gtk2hs/
07:30:24 <Eelis> will try
07:30:57 <xerox> Err.. I didn't say anything like that.
07:31:07 <Eelis> xerox: ok, then i must have misunderstood. my apologies.
07:31:21 <xerox> No worries.
07:31:41 <Eelis> the darcs thing worked, going to compile and install it now :)
07:32:24 <dcoutts> autoreconf && ./configure && make && sudo make install
07:32:54 <Eelis> that's the plan :)
07:33:23 <davidhouse> xerox, today's the big day?
07:34:02 <xerox> davidhouse - seems so :)
07:34:29 <davidhouse> although google seem to be releasing at Stupid O'Clock, so us in GMT will likely have to wait until tomorrow.
07:35:48 <sjanssen_> davidhouse: you could just not sleep
07:36:20 <dcoutts> sjanssen_, how's the unfoldrN going?
07:36:37 <davidhouse> sjanssen_, it's the middle of exam season
07:36:40 * dcoutts is eager to use it in .Lazy to implement unfoldr
07:36:55 <sjanssen_> dcoutts_: I'll finish when my stupid roommate wakes up and fixes our internet so I can SSH
07:37:07 <dcoutts> sjanssen, heh :-)
07:37:24 <SamB> so what is a good way to parse binary files? especially with variable-length in-place arrays?
07:37:27 <petekaz> @type unfoldr
07:37:29 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
07:38:45 <davidhouse> unfoldr takes a function and an initial value. it applies that initial value to the function and looks at the result. if it's Nothing, then stop here. otherwise, add the first part of the result to the results list and call the function again with the second.
07:39:21 <davidhouse> > let f x = if x < 10 then Just (x + 1, show x) else Nothing in unfoldr f 1
07:39:22 <lambdabot>  add an instance declaration for (Num String)
07:39:22 <dcoutts> @type mapAccumL
07:39:23 <lambdabot> forall y acc x.
07:39:23 <lambdabot>      (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:39:44 * xerox boos at mapAccum functions names
07:39:49 <davidhouse> > let f x = if x < 10 then Just (show x, x + 1) else Nothing in unfoldr f 1
07:39:50 <lambdabot> ["1","2","3","4","5","6","7","8","9"]
07:39:56 <SamB> @where ByteString
07:39:56 <lambdabot> I know nothing about bytestring.
07:40:01 <sjanssen_> @where fps
07:40:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:40:26 <sjanssen_> @where+ ByteString http://www.cse.unsw.edu.au/~dons/fps.html
07:40:26 <lambdabot> Done.
07:41:47 <SamB> so does anyone have a clue about binary parsing?
07:42:31 <sjanssen_> SamB: what are you parsing?
07:42:41 <jethr0> SamB: no, but what exactly do you want to parse?
07:43:25 <Lemmih> SamB: Seen NewBinary?
07:43:43 <SamB> http://www.mozilla.org/scriptable/typelib_file.html
07:44:01 <SamB> Lemmih: hmm, probably not really
07:44:11 <jethr0> SamB: so you found noone to do it for you? :)
07:44:22 <davidhouse> ah, you can use fix to define recursive lambdas. the first real use of it i've seen.
07:44:24 <SamB> nope!
07:44:55 * jethr0 doesn't see how parsing binary is different from printable chars
07:44:57 <SamB> eivuokko was going to take up HaskellDirect, but didn't when he found out that DirectX 9 lacked typelibs
07:45:04 <davidhouse> @hoogle sizeof
07:45:04 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
07:45:17 <sjanssen_> davidhouse: my favorite use of a fixpoint combinator is Okasaki's for memoization/dynamic programming
07:45:17 <SamB> well, binary files tend to have offsets in them
07:45:39 <SamB> also lengths
07:46:20 <SamB> now, it is quite true that I could use Parsec for something with just lengths or neither...
07:46:35 <davidhouse> @hoogle Ptr
07:46:35 <lambdabot> Foreign.Ptr :: module
07:46:35 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
07:46:35 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
07:46:46 <SamB> (though the former is a bit awkward)
07:46:58 <sjanssen_> SamB: is the format straightforward?
07:46:59 <davidhouse> @hoogle mallocByte
07:46:59 <lambdabot> Foreign.Marshal.Alloc.mallocBytes :: Int -> IO (Ptr a)
07:46:59 <lambdabot> Foreign.Marshal.Pool.pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
07:47:05 <SamB> @where NewBinary
07:47:06 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
07:47:10 <SamB> sjanssen: in what way?
07:47:12 <dcoutts> SamB, I use GHC's binary system
07:47:56 <sjanssen_> SamB: check out http://user.it.uu.se/~pergu/huffman.hs -- I parse a binary file by hand with lengths in it
07:48:02 <sjanssen_> checkout mkTree especially
07:49:24 <SamB> it is not easy reading
07:49:49 <SamB> methinks this is why they stole monads
08:00:49 <nime> motd
08:01:39 <vincenz> @motd
08:01:40 <lambdabot> Maybe you meant: more vote
08:02:16 <nime> sorry it's my first IRC try *gr*
08:02:28 <vincenz> sjanssen_: nice
08:02:37 <vincenz> nime: first time on irc??
08:02:42 <nime> yup 
08:02:47 * vincenz blinks
08:02:49 <vincenz> how old are you ?
08:02:52 <nime> 25 
08:02:55 <nime> you?
08:02:58 <vincenz> 26
08:03:19 * vincenz has been off and on irc for ... 10 years?
08:03:29 <nime> woow
08:03:50 <nime> but why are you back? 
08:04:02 <nime> (just curious (A))
08:05:23 <nime> (btw. can you explain me ... how to register on a nick server ?)
08:05:38 <nime> the channel is saying i have to
08:06:11 <xerox> nime - /MSG NickServ HELP
08:06:27 <nime> ty :)
08:06:33 <xerox> You're welcome.
08:06:50 <nime> i'm getting MSG unknown command :S
08:07:12 <vincenz> what program are you using?
08:07:36 <nime> oh it's ok (it was just case sensitive)
08:07:42 <nime> i'm using ChatZilla
08:09:18 <nime> did it work? 
08:09:28 <vincenz> yes
08:09:58 <nime> oki
08:10:03 <nime> ty
08:12:51 <Eelis> dcoutts, xerox: it works :) after building and installing this development version of gtk2hs, the rotating cube example compiles and runs. thanks for your help
08:13:08 <dcoutts> Eelis, np
08:13:52 <vincenz> Eelis: out of curiousity, this is specifically to port 3d miner, or you have other plans with hopengl?
08:14:54 <Eelis> porting minesweeper 3d is just an excuse to get into haskell. eventually i'm interested in experimenting with coq's haskell export functionality
08:15:13 <sjanssen_> there's a 3d minesweeper?!
08:15:29 <Eelis> sjanssen_: http://www.xs4all.nl/~weegen/Minesweeper3D/  :)
08:16:40 <nime> looks amazing 
08:17:00 * sjanssen_ knows what he is doing the rest of the day
08:17:26 <sjanssen_> Eelis: when you finish this, you should post it to Haskell-cafe -- so I can play a Haskell version
08:17:34 <Eelis> hehe, i will
08:22:55 <araujo> Good morning!
08:34:37 * mahogny figures haskell Owns as CNC milling language o_O
08:35:41 <vincenz> cNc?
08:35:54 <mahogny> CNC
08:36:13 <vincenz> Eelis: I thought coq was written in haskell
08:36:22 <vincenz> erm
08:36:22 <vincenz> ocaml
08:36:41 <mahogny> doesn't have much to do with haskell exporting :)
08:36:51 <vincenz> Eelis: and yes post to haskell-cafe, dons writes a haskell weekly news that most of the community reads and I'm certain he will put it in there
08:37:10 <sjanssen_> man, this 3d minesweeper is tough
08:37:28 * vincenz wonders how you can click stuff that's in the middle 
08:37:33 <psnl> NP-C, even
08:37:48 * jethr0 thinks you can only work on the surface
08:37:50 <vincenz> mahogny: what is CNC
08:38:02 <mahogny> vincenz, computer controlled milling
08:38:08 <vincenz> milling?
08:38:19 <jethr0> fräsen in german
08:38:24 <vincenz> oh
08:38:45 * vincenz still wonders why it's called CNC especially the N bit
08:38:52 <vincenz> isn't that known as CAM?
08:39:06 * mahogny doesn't remember what CNC stands for
08:39:09 <mahogny> CNC is a part of CAM
08:39:14 <mahogny> ehr. kind of
08:39:21 <mahogny> it's a sticky notation
08:39:22 <jethr0> "Computerized Numerical Control" ?
08:39:27 <mahogny> sounds about right
08:39:39 * earthy grins
08:39:41 <jethr0> not very self-explanatory though
08:39:49 <earthy> that's quite right.
08:39:50 <vincenz> see
08:39:52 <vincenz> when I first saw that
08:39:58 <jethr0> M as in Manufacturing?
08:39:58 <mahogny> CNC is much older than CAM; the first CNC machines ran on punch cards :)
08:40:05 <vincenz> I thought Command aNd Conquer, and milling referred to the harvesting of trees
08:40:11 <mahogny> lol
08:40:16 <mahogny> you need a language for that? :)
08:40:22 <vincenz> prolly lua
08:40:34 <vincenz> mahogny: and yes hence my confusion
08:40:38 * mahogny wonders if he should make a CNC monad or just toss it to IO
08:40:48 <mahogny> I guess a new monad is best
08:41:10 <earthy> anyway, CNC can be drills, lathes, milling machines, wood routers etc.
08:41:35 <mahogny> pretty much anything. for some stupid reason, it's the same language
08:41:42 * vincenz sighs as noone ever signs his guestbook
08:41:48 <mahogny> it's equally horrible at any operation :)
08:42:26 <jethr0> cool, "wood routers"
08:43:12 * jethr0 wonders if doing transforms, scaling, rotation can be applied to that CNC language
08:43:32 <jethr0> brb
08:43:37 <mahogny> I'm adding it. and yes, it's actually already in the NC language to some extent
08:45:21 <mahogny> mahogny I'm adding it. and yes, it's actually already in the NC language to some extent
08:45:31 <mahogny> is there a nice way of getting access to, say, COM ports etc in haskell?
08:45:39 <mahogny> portable that is
08:45:51 <mahogny> or LPT in worst case
08:45:56 <psnl> mahogny: I imagine thats OS dependant
08:46:12 <mahogny> yeah, but that is why you toss it into a standard library so you don't have to bother :)
08:46:28 <mahogny> so if anyone has coded one, hands up :P
08:46:29 <norpan> i made a minesweeper in haskell once, using fudgets
08:46:39 <norpan> each cell was a fudget
08:46:55 <norpan> worked like a charm
08:47:45 <norpan> code was simple too
08:47:55 <SamB> %hoogle scanf
08:48:02 <SamB> @hoogle scanf
08:48:02 <lambdabot> No matches found
08:48:07 <norpan> @hoogle read
08:48:08 <lambdabot> Prelude.read :: Read a => String -> a
08:48:08 <lambdabot> Text.Read :: module
08:48:08 <lambdabot> Prelude.Read :: class Read a
08:49:22 <SamB> I wanted to do some stuff with hex numbers...
08:49:35 <SamB> @hoogle hex
08:49:36 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
08:49:36 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
08:49:36 <lambdabot> Numeric.readHex :: Integral a => ReadS a
08:49:45 <norpan> readHex
08:51:19 <SamB> @hoogle ReadS
08:51:20 <lambdabot> Prelude.ReadS :: type ReadS a
08:51:20 <lambdabot> Prelude.reads :: Read a => ReadS a
08:51:20 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
08:51:52 <SamB> @hoogle ReadS ()
08:51:52 <lambdabot> No matches, try a more general search
08:51:57 <SamB> @hoogle ReadS Char
08:51:58 <lambdabot> Char.readLitChar :: ReadS Char
08:52:28 <MrHuskell> @help
08:52:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:52:34 <MrHuskell> @list
08:52:34 <lambdabot> list [module|command]. Where modules is one of:
08:52:34 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
08:52:34 <lambdabot> version vixen where
08:53:21 <norpan> @type readHex ""
08:53:22 <lambdabot> forall a. (Num a) => [(a, String)]
08:53:49 <norpan> @type fst . head . readHex ""
08:53:50 <lambdabot>   Couldn't match `[(a, String)]' against `t -> t1'
08:53:50 <lambdabot>   Expected type: [(a, String)]
08:54:30 <norpan> huh
08:55:23 <norpan> @type fst . head . readHex
08:55:25 <lambdabot> forall a. (Num a) => String -> a
08:56:30 <gregb> Any typeclass experts lurking around?
08:56:40 <gregb> Over on haskell-cafe someone asked about creating "apply".  http://www.haskell.org//pipermail/haskell-cafe/2006-May/015702.html
08:57:06 <gregb> I thought it should be doable using typeclasses, but my efforts so far have failed me.
08:57:15 <lisppaste2> gregb pasted "recursive Apply typeclass" at http://paste.lisp.org/display/20322
08:57:50 <gregb> Any comments on what I could be doing wrong (or if it is indeed possible)?
08:58:24 <norpan> well, first, the arguments have to have all the same type
08:59:00 <gregb> GHC complains about...      Illegal instance declaration for `Apply (a -> b -> c) (b -> c) (a, d)'
08:59:00 <gregb>         (the instance types do not agree with the functional dependencies of the class)
08:59:00 <gregb>     In the instance declaration for `Apply (a -> b -> c) (b -> c) (a, d)'
09:00:14 <gregb> norpan, why, that's what I want to use typeclasses for, so I can have an infinite family of functions that work at different types.
09:00:18 <norpan> if you have to create a tuple (which has a specific type anyway) then what's the point
09:00:31 <norpan> i thought the question was about taking arguments from a list
09:01:10 <davidhouse> gregb, the problem is that your base case definition is too general
09:01:30 <davidhouse> 'a' and 'b' match any type, including (a->b->c) and (b->c)
09:01:58 <davidhouse> so you get a conflicting functional dependancy between Nil and (a, d)
09:02:27 <norpan> the limitation b->c means that there may only be one instance containing b
09:02:38 <norpan> since it can stand for any type
09:02:42 <norpan> and so you can't have any more
09:02:57 <norpan> because b uniquely determines c
09:05:19 <araujo> SyntaxNinja, hiya!
09:06:05 <peteog> hi guys, wondering if someone could help me out? http://pastebin.com/733139 <- the question on the paper im doing is: Construct a list of [Anyday] containing all seven days of the week. but what ive done there doesnt seem to work
09:06:29 <peteog> The paper then goes on to: Write a function that counts the number of weekdays in a list of type [Anyday]
09:07:17 <norpan> peteog: you need to append Left or Right to the days
09:07:21 <hyrax42> data Either a b = Left a | Right b
09:07:29 <hyrax42> you need to use the constructors left and right in your list
09:08:32 <davidhouse> i.e. week = [Left Mon,Left Tue, ...
09:08:38 <gregb> Maybe I need a good tutorial on advanced typeclass usage, including fun-deps.  Recommendations?
09:09:00 <peteog> ah cool :) thanks all :)
09:09:05 <peteog> also what a crappy exam paper :)
09:09:21 <davidhouse> gregb: there's a paper linked to on the GHC user manual page for fundeps.
09:09:32 <davidhouse> peteog: hey, i forget the Lefts and Rights all the time :)
09:09:40 <hyrax42> for the next part, the function either might be itereting...
09:09:43 <vincenz> Anyone ahve a simple example of a typechecker implemented in haskell
09:09:50 <hyrax42> thih
09:09:58 * davidhouse personally would do data Anyday = WD Weekday | WE Weekend, but fine
09:10:01 <vincenz> hyrax42: a smaller one
09:10:06 <hyrax42> davidhouse: I would too
09:10:29 <hyrax42> cannae help ya
09:10:50 <vincenz> data Anyday = Monday, Tuesday, Wednesday, Thursday, Friday, Saturday deriving (Enum)
09:10:51 <gregb> davidhouse: Thanks.  Would you say my problem with "apply" is with fun-deps, or am I missing something else.
09:11:02 <vincenz> [minbound .. maxbound ] :: [Anyday]
09:11:15 <hyrax42> vincenz: what about sunday?
09:11:19 <vincenz> right
09:11:20 <hyrax42> ;)
09:11:20 <vincenz> typo
09:11:36 <davidhouse> i think there is actually a preluded list of days somewhere. 
09:11:45 <vincenz> @type Monday
09:11:46 <lambdabot> Not in scope: data constructor `Monday'
09:11:57 <hyrax42> @type Mon
09:11:58 <lambdabot> Not in scope: data constructor `Mon'
09:12:00 <davidhouse> @hoogle Mon
09:12:01 <lambdabot> Control.Monad :: module
09:12:01 <lambdabot> Data.Graph.Inductive.Monad :: module
09:12:01 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
09:12:04 <davidhouse> perhaps not.
09:13:32 * davidhouse wonders if there's a monadic generalisation of length
09:13:51 <davidhouse> to MonadPlus
09:14:18 <xerox> I don't think length and MonadPlus relate.
09:14:54 <davidhouse> nah, it was just a crazy though.
09:14:57 <hyrax42> you'd need to be able to un-mplus thigs
09:15:11 <hyrax42> ?
09:15:36 * vincenz was thinking like this
09:15:37 <vincenz> http://rafb.net/paste/results/UofGrp81.html
09:16:04 <xerox> davidhouse - (Functor f) => f a -> Int ?
09:16:24 <xerox> davidhouse - nah, nevermind.
09:16:27 <sjanssen_> we need functorM
09:16:38 <sjanssen_> or the Control.Applicative stuff
09:16:43 <vincenz> any comments on that post
09:16:46 <lisppaste2> norpan annotated #20322 with "this works" at http://paste.lisp.org/display/20322#1
09:16:52 <sjanssen_> then you use a state monad to hold the count
09:17:26 <davidhouse> @hoogle functorM
09:17:26 <lambdabot> Data.FunctorM :: module
09:17:26 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
09:17:35 <davidhouse> sjanssen_, what's that?
09:17:37 <sjanssen_> @type fmapM
09:17:38 <lambdabot> Not in scope: `fmapM'
09:17:46 <sjanssen_> @type Data.FunctorM.fmapM
09:17:47 <lambdabot> forall (f :: * -> *) b (m :: * -> *) a.
09:17:47 <lambdabot>         (Data.FunctorM.FunctorM f, Monad m) =>
09:17:47 <lambdabot>         (a -> m b) -> f a -> m (f b)
09:18:21 <davidhouse> crazy.
09:18:43 <sjanssen_> FunctorM is deprecated in favor of Apllicative, which is supposed to be better
09:20:07 <vincenz> re
09:20:36 <vincenz> so does what I show seem like a good approach?
09:23:16 <vincenz> http://rafb.net/paste/results/WrOzMq71.html
09:26:13 <Eelis> vincenz: coq is written in ocaml, but can export to both ocaml and haskell
09:26:35 * vincenz nods
09:28:36 <SyntaxNinja> hey araujo
09:30:31 <dcoutts> SyntaxNinja, do you know how to delete trac bugs? ie spam ones.
09:30:46 <vincenz> anyone here have some experience with typechecking code?
09:30:55 <dcoutts> SyntaxNinja, I noted that the Cabal trac has a couple as does the Gtk2Hs trac
09:31:20 <dcoutts> vincenz, you mean writing type inference algorithms?
09:32:01 <vincenz> dcoutts: right
09:32:13 <dcoutts> vincenz, what are you trying to do?
09:32:14 <vincenz> except that the amount of inference I need is rather minimal
09:32:27 <vincenz> dcoutts: I have defined a mini language and I'm trying to typecheck it
09:32:28 <SyntaxNinja> dcoutts: oh really? fooey.
09:32:51 <dcoutts> SyntaxNinja, mm, and trac doesn't have a "delete this bug" button
09:32:52 <SyntaxNinja> dcoutts: just close them as invalid or something. I'll fix the permissions (sigh)
09:32:58 <curumo> why?
09:33:22 <oNoX> is it possible to have hashmaps in haskell?
09:33:27 <curumo> why?
09:33:29 <davidhouse> oNoX: see Data.Map
09:33:32 <curumo> why?
09:33:58 <davidhouse> curumo: will you still respond 'why' when asked a question, even though it'll make no sense?
09:34:30 <vincenz> davidhouse: erm according to jesuit style of conduct, that question can be replied with a "why?"
09:34:30 <curumo> if the question is absurd,yes
09:34:48 <SyntaxNinja> dcoutts: I'll start at the high number, you start at the low number :)
09:34:49 <Cale> oNoX: there's also Data.HashTable, but hardly anyone uses it
09:34:50 <SyntaxNinja> (closing them)
09:34:53 <curumo> right, vincenz
09:34:58 <dcoutts> SyntaxNinja, ok
09:34:59 <curumo> but why
09:35:04 --- mode: ChanServ set +o Igloo
09:35:09 <Cale> curumo: why what?
09:35:27 <curumo> why are you cale?
09:35:30 <Igloo> curumo is the semi-bot that got banned a few days ago, right?
09:35:38 <curumo> is it?
09:35:59 <Cale> curumo: I am what I am.
09:36:05 <curumo> good
09:36:07 <Igloo> Any objections to me banning it again?
09:36:12 <curumo> yes
09:36:25 <vincenz> curumo: wy?
09:36:29 <vincenz> why even
09:36:29 <curumo> i have an objection
09:36:34 <Cale> curumo: Why are you here? Do you have a more specific question?
09:36:49 <curumo> I wanted to ask, why we are here
09:36:52 <Cale> (Like, about Haskell?)
09:36:56 <davidhouse> @faq
09:36:56 <lambdabot> The answer is: Yes! Haskell can do that.
09:37:02 <vincenz> ok... I think that curumo had too much weed
09:37:05 <dcoutts> SyntaxNinja, done
09:37:14 <SyntaxNinja> dcoutts: Yep. thanks!  god I hate spammers.
09:37:20 * dcoutts too
09:37:21 --- mode: Igloo set +b *!*@84-72-43-92.dclient.hispeed.ch
09:37:22 <Cale> That's not a Haskell question. I think there's at least one philosophy channel around.
09:37:23 --- kick: curumo was kicked by Igloo (Igloo)
09:38:33 <vincenz> dcoutts: anyways, I have defined a mini language with a set of definitions, most things are easily inferred what type they have, however I must do some inference cause some of the functions might call some of the other functions, so it's a recursive situation... hence I first give all the functions a TyVar... and then infer
09:38:55 <oNoX> Cale: i'm trying to iterate through a list, where every element is like ["10", "name", "A"] and I need to get the sum of the numbers (1st) and characters (3rd) for every name (2nd), but haskell only gives highly encrypted error messages about generators
09:39:02 <vincenz> And exp exp -> both exps must be of type bool
09:39:02 <dcoutts> vincenz, have you seen HM type inference?
09:39:17 <vincenz> dcoutts: I have looked at THIH but it's too complex for my needs
09:39:33 <dcoutts> vincenz, yes it is, HM type inference is simple
09:39:41 <dcoutts> THIH is complex
09:39:49 <dcoutts> for various reasons
09:39:50 <vincenz> Then I have not
09:39:51 <davidhouse> oNoX: want to paste some of those errors?
09:39:58 <Philippa> THIH deals with all of Haskell, which is a lot of extra stuff
09:40:08 <vincenz> it's mostly trying to figure out how to do it, the main problem is that right now I do something like
09:40:15 <vincenz> subst <- unify type type
09:40:20 <vincenz> but then I must recurse back down my exps
09:40:23 <vincenz> to apply this subst
09:40:48 <vincenz> http://rafb.net/paste/results/WrOzMq71.html
09:41:00 <Igloo> You just return that subst with the result and apply it higher up
09:41:11 <davidhouse> oNoX: is this a list of triples or a list of lists?
09:41:18 <dcoutts> vincenz, I'd reccomend reading: Generalizing Hindley-Milner Type Inference Algorithms
09:41:20 <vincenz> Igloo: but then the lower exps will still have tyvars in it
09:41:21 <davidhouse> if the latter, why not use the former? (or even better, a record)
09:41:24 <oNoX> a list with [x, x, x]
09:41:24 <dcoutts> http://citeseer.ist.psu.edu/rd/0%2C532312%2C1%2C0.25%2CDownload/http%3AqSqqSqarchive.cs.uu.nlqSqpubqSqRUUqSqCSqSqtechrepsqSqCS-2002qSq2002-031.pdf
09:41:30 <vincenz> dcoutts: thx
09:41:39 <dcoutts> eek, nasty url
09:41:49 <oNoX> i'm doing: do [t, n, a] <- l
09:42:02 <davidhouse> right, okay.
09:42:05 <oNoX> on the next line, anything
09:42:08 <dcoutts> vincenz, http://archive.cs.uu.nl/pub/RUU/CS/techreps/CS-2002/2002-031.pdf
09:42:14 <vincenz> yep got it, thanks :)
09:42:22 <davidhouse> oNoX: well, could you actually pastebin your current code and the errors you're getting?
09:42:26 <Cale> oNoX: well, that might not mean what you want
09:42:26 <oNoX> and haskell says: Last generator in do {...} must be an expression
09:42:30 <Igloo> vincenz: e.g. for e = e1 e2: (t1, s1) <- infer env e1; (t2, s2) <- infer (s1 env) e2; s3 <- unify (s2 t2) (t2 -> alpha); return (s3 alpha, (s3 . s2 . s1))
09:42:40 <dcoutts> vincenz, it gives a good intro to HM stuff and then goes on to generalise to a constraint solving style
09:42:42 <Igloo> s == substitution, t == type, e == expression
09:42:44 <oNoX> I first wanted to use list comprehension
09:42:44 <Cale> oNoX: you're working in the list monad?
09:43:01 <oNoX> but I need to store data and I can't do that with a list comprehension
09:43:06 <oNoX> I imported list
09:43:08 <davidhouse> oNoX: pastebin your code.
09:43:09 <dcoutts> vincenz, but the early bit is nice and simple and quite easy to implement in Haskell
09:43:12 <davidhouse> @where paste
09:43:13 <lambdabot> http://rafb.net/paste
09:43:17 * vincenz nods
09:43:36 <vincenz> Igloo: the problem with that system is that you don't go back down to replace tyvars
09:43:46 <Igloo> vincenz: Do back down what?
09:43:52 <vincenz> into the exps
09:44:05 <oNoX> i'll pastebin
09:44:07 <vincenz> each of my ast nodes is annotated with a type
09:44:08 <Igloo> vincenz: Give me an actual example of the problem
09:44:27 <Igloo> Oh, you're building a fully type-annotated expression tree?
09:45:20 <vincenz> yes
09:45:22 <Igloo> In that case you'd just return the type annotated expression, and substitute in it in exactly the same way as the types get the substitutions applied
09:45:54 <vincenz> right but if I unify somewhere above.. I have to recurse all the way back down to apply the substition, which implies doing a top->down->backup twice
09:46:17 <Igloo> Yes
09:46:28 <vincenz> at each level, which is O(N^2) with N being depth
09:46:35 <Igloo> You only actually need to apply the substitution to the type-annotated expressions at the very root of the expression
09:46:42 <vincenz> hmm
09:46:44 <vincenz> good point
09:46:46 <vincenz> so just move up the subst
09:46:50 <vincenz> and only apply it at the end
09:47:06 <vincenz> alright, thx
09:47:11 <norpan> gregb: did you see my annotation
09:47:14 <Philippa> you can see the last stage as prettyprinting
09:47:44 <Philippa> if you're using ST or similar to hold your substitutions (something I'm changing my mind about doing) then you need your prettyprinter in the relevant monad anyway
09:47:47 <gregb> getting closer.
09:47:58 <Philippa> admittedly that's *why* I'm changing my mind about using ST :-)
09:48:10 <norpan> gregb: how can it get any closer? :)
09:48:11 <gregb> But it seems like there should be a recursive solution, doesn't there?
09:48:15 <norpan> no
09:48:24 <norpan> because that would have to depend on the value of the list
09:48:29 <vincenz> Philippa: you prefer ST over State?
09:48:43 <resiak> What would be the standard way to split "foo:bar:hippo" into ["foo", "bar", "hippo"]?
09:48:52 <gregb> That's also why it should work with nested tuples and/or HLists
09:48:52 <norpan> otherwise, how to know when to stop taking arguments from the list?
09:49:02 <vincenz> this is my current typing monad
09:49:03 <vincenz> http://rafb.net/paste/results/rFREcU61.html
09:49:05 <norpan> using nested tuples is easy
09:49:06 <Cale> resiak: something using span or break
09:49:19 <norpan> but unsatisfactory, because nested tuples gives you nothing extra
09:49:38 * vincenz plans to have two things in state: identifiers -> type, and some way to make a unique tyvar
09:49:45 <resiak> Cale: Yep, I can see how repeated use of break would work, but I can't help thinking that there ought to be a library function to avoid me writing my own in every program. :-) Thanks.
09:49:58 <gregb> except for the fact you can use arguments of different types.
09:50:12 <Igloo> vincenz: What are you actually making OOI?
09:50:21 <davidhouse> @hoogle [a] -> a -> [[a]]
09:50:22 <lambdabot> No matches, try a more general search
09:50:28 <vincenz> Igloo: OOI?
09:50:28 <davidhouse> @hoogle a -> [a] -> [[a]]
09:50:29 <lambdabot> No matches, try a more general search
09:50:30 <Cale> resiak: there's words and lines for the two most common cases -- I'm not totally sure why the general case isn't handled.
09:50:33 <Igloo> Out Of Interest
09:50:44 <norpan> gregb: but it gives you nothing extra, you could as well define g :: (Int,Int,Int,Int)->Int
09:50:47 <vincenz> Igloo: oh, I have this model and I'm making a tool to simulate it
09:50:51 <oNoX> http://rafb.net/paste/results/jeMpDT57.html
09:50:53 <Philippa> vincenz: I was using ST for the identifier->type thing because it's something with a potentially high rate of change for existing substitutions in the systems I've been playing with
09:51:02 <resiak> Cale: That was my thinking. Okay, no problem. Thanks!
09:51:02 <vincenz> http://oasis.yi.org:8080/MYGUI.png
09:51:09 <Philippa> that is, each identifier becomes an STRef s Type
09:51:38 <vincenz> the previous system only allowed two inputs sequences and one output, I want to have as many as I want, hence making a minilanguage which needs to be typed
09:52:26 <gregb> You can't make the N-tuple version work for all values of N. (Or at least it's not obvious to me how to do it without something like TemplateHaskell)
09:52:27 <Cale> oNoX: you first want to parse those lines into records, and then fold them into a Data.Map probably.
09:52:35 <davidhouse> > let tok c = unfoldr (\s -> if null s then Nothing else Just $ break (==c) s) in tok ':' "foo:bar:hippo"
09:52:36 <lambdabot> ["foo","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",
09:52:36 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","
09:52:36 <lambdabot> ","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
09:52:36 <lambdabot> ,"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",
09:52:38 <lambdabot> "","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","
09:52:41 <lambdabot> [6 @more lines]
09:52:43 <davidhouse> aargh
09:52:46 <davidhouse> sorry!
09:52:51 <Cale> oNoX: is the last letter ignored?
09:53:09 * vincenz is off to get dinner, thanks for the input dcoutts, Igloo, Philippa 
09:53:31 <Cale> We can just use pairs and throw it away, it seems
09:53:31 <resiak> davidhouse: unfoldr also came to mind, but just not used like that ;)
09:53:32 <norpan> gregb: sure but you gain nothing from having your function taking tuples in the first place
09:53:44 <norpan> otoh you can make your function take lists of course :)
09:54:06 <gregb> currying
09:54:21 <Cale> oNoX: your first problem is that the second line of your 'do' is indented a character deeper than the first
09:54:44 <Cale> oNoX: the second is that the second line of your do is from a different monad than the first.
09:54:45 <oNoX> does spacing matters?
09:54:48 <Cale> yes
09:54:52 <davidhouse> resiak, i've almost got it
09:55:07 <oNoX> well, I just need to have any x instructions below "do"
09:55:33 <Cale> if you indent something deeper than the preceding expression, it becomes part of that expression
09:55:50 <davidhouse> > let tok c = unfoldr (\s -> if null s then Nothing else Just $ break (==c) $ drop 1 s) . (c:) in tok ':' "foo:bar:hippo"
09:55:51 <lambdabot> ["foo","bar","hippo"]
09:55:52 <Cale> so that's getting parsed as   prs s = do [t, n, a] <- (map words $ lines s) putStr n
09:56:08 <davidhouse> that (c:) is a bit hacky, but i'll live :)
09:56:18 <xerox> davidhouse: hehe
09:56:22 <Cale> just kill a single space from the line with putStr to line it up with the [
09:56:25 <resiak> davidhouse: eep! Good call.
09:56:35 <Cale> but then you'll have a type error
09:56:45 <davidhouse> > let tok c = unfoldr (\s -> if null s then Nothing else Just $ break (==c) $ drop 1 s) in tok ':' "foo:bar:hippo" -- this is what happens without the (c:)
09:56:46 <lambdabot> ["oo","bar","hippo"]
09:57:04 <davidhouse> hmm... /me has an idea
09:57:09 <resiak> davidhouse: It could in fact be (undefined:), right? :)
09:57:30 <davidhouse> > let tok c = unfoldr (\s -> if null s then Nothing else Just $ break (==c) $ drop 1 s) . (undefined:) in tok ':' "foo:bar:hippo"
09:57:31 <lambdabot> ["foo","bar","hippo"]
09:57:33 <davidhouse> yep :)
09:57:36 <resiak> right.
09:58:25 <davidhouse> there should be a function a bit like listToMaybe, but with type [a] -> Maybe [a]
09:58:47 <int-e> in fact it's safe to use tail instead of drop 1 there :)
09:58:54 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/=c)) . (c:)) in splitBy '-' "one-two-three"
09:58:55 <lambdabot>  parse error on input `)'
09:59:00 <Cale> oNoX: the type error is because the (map words $ lines s) is from the list monad, while putStr n is in the IO monad.
09:59:04 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/=c)) . (c:) in splitBy '-' "one-two-three"
09:59:05 <lambdabot> ["one","two","three"]
09:59:16 <davidhouse> huh. could have sworn that i used tail.
09:59:26 <xerox> Right.
09:59:34 <davidhouse> > let listToMaybeList s = if null s then Nothing else Just s; tok c = unfoldr (liftM (break (==c) . tail) . listToMaybeList) . (c:) in tok ':' "foo:bar:hippo"
09:59:35 <lambdabot> ["foo","bar","hippo"]
09:59:52 <xerox> Hardcore!
10:00:45 <davidhouse> ooh, i like your groupBy one.
10:01:04 <xerox> ^_^
10:01:23 <davidhouse> groupBy with const... nice.
10:01:33 <oNoX> i do have another solution to the problem
10:01:34 <xerox> Thank you.
10:01:37 <resiak> xerox: That's very nead =)
10:01:40 <resiak> erm, neat.
10:01:41 <oNoX> which isn't very elegant, but it might workds
10:01:47 <xerox> All positive karma.
10:02:27 <oNoX> I have ["A", "N", "A", "A" ,"N"], and need to transform it to: [3, 2]
10:02:45 <oNoX> could I use groupBy?
10:02:47 <Cale> oNoX: break the problem into: splitting into lines, turning a line into a pair with the interesting 2 fields, adding a single such pair to an existing map
10:02:55 <xerox> map length . group . sort
10:03:09 <Cale> oNoX: then combine those parts with map and fold
10:03:26 <xerox> map (id &&& length) . group . sort -- for a nicer return result.
10:03:37 <Cale> splitting into lines (and words) is done for you, as you know
10:04:56 <Cale> so instead of putStr n, use  return (t,n) there
10:05:02 <Cale> and change the type sig
10:05:15 <Cale> actually
10:05:29 <Cale> return (n, read t)
10:05:53 <Cale> which will be much more convenient
10:06:24 <Cale> so the type becomes  String -> [(String, Integer)]
10:06:45 <Cale> oNoX: right?
10:07:16 <oNoX> hmm
10:07:34 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#v%3AinsertWith -- once you understand that, have a look at insertWith here.
10:08:44 <Cale> specifically, I think what you want is insertWith (+)
10:09:56 <oNoX> ok, thanks for your help
10:10:35 <oNoX> I do have a hard time with haskell, but I am learning :)
10:10:42 <Cale> oNoX: use that with foldr or foldl (or even foldl') and you should be set.
10:12:53 * SamB wonders why GUIDs are split into fields the way they are
10:13:06 <SamB> (in the C struct that holds them)
10:14:06 <davidhouse> listToMaybeWith [] _ = Nothing; listToMaybeWith xs f = Just (f xs) -- surprisingly useful
10:14:15 <davidhouse> it's gone in my combinator wishlist :)
10:14:45 <SamB> which is to say: 32-bits, 16-bits, 16-bits, array of 8 8-bit chars...
10:15:58 <SamB> even though they are written like: 0bc6d50b-135b-4811-a9c5-fc6979ea9431
10:16:58 <SamB> might be related to the fact that the typical C compiler doesn't have a 48-bit wide type...
10:17:27 <dozer> what function do I use to convert Int -> String so that I get a string that is the base-10 human-readable representation of the int?
10:18:01 <norpan> dozer: show
10:18:17 <dozer> thx - that won't produce "Int 7" or something?
10:18:18 <SamB> but you'd think they'd want to split the last tow parts..
10:18:20 <norpan> nope
10:18:21 <SamB> er, two...
10:18:53 <norpan> > show 10
10:18:54 <lambdabot> "10"
10:21:29 <oNoX> Cale: if I use insertWith
10:21:34 <oNoX> I need to have a map
10:21:52 <oNoX> do I need to give an empty map to prs?
10:23:47 <Cale> foldr (\(k,v) m -> insertWith (+) k v m) (Map.empty) (prs s)
10:23:54 <Cale> something like that
10:24:10 <davidhouse> nice :)
10:24:12 <Cale> then just do a Map.toList
10:24:27 * SamB still wants scanf
10:24:44 <Cale> SamB: is that anything like scanl? ;)
10:24:49 <davidhouse> SamB, what would that do?
10:24:55 <Cale> hehe
10:25:09 <Cale> He's referring to the C scanf
10:25:37 <Cale> I think it could be done with enough typeclass swindling, like printf does.
10:25:37 <SamB> well, It would take a printf-style spec string, and a string of text to scan, and return... I dunno what it would return...
10:26:06 <Cale> what it would return would be interesting :)
10:26:09 <jethr0_> IO ()
10:26:15 <Cale> probably a nested tuple
10:26:17 <SamB> jethr0_: that would be stupid
10:26:20 <jethr0_> hehe
10:26:31 <Cale> well, not if you could pass it IORefs
10:26:31 <SamB> I want my data, not some random side-effect
10:26:33 <davidhouse> what does C scanf do?
10:26:47 <neologism> davidhouse: reverse of printf
10:26:48 <jethr0_> scanf("%d %d", i, j);
10:26:51 <Cale> davidhouse: parses strings according to a printf-like string
10:27:06 <SamB> well, C scanf reads from stdin, but that isn't what I want...
10:27:17 <Cale> you want sscanf
10:27:26 * jethr0_ finds it rather evil. especially since correspondence of format-string and params isn't checked (same as in printf)
10:27:37 <Cale> yeah, it is pure evil
10:27:40 <jethr0_> i'm sure there's fscanf
10:27:48 <Cale> that's for files
10:27:52 <SamB> but the haskell-style would be to make the sscanf-like one be called scanf, wouldn't it?
10:27:55 <Cale> sscanf is the one for strings
10:28:12 <Cale> SamB: yeah, we could probably merge all 3
10:28:22 <sjanssen_> SamB: if we follow the example of printf in Haskell, we'd use the class system to determine which variant is needed
10:28:24 <davidhouse> just have it take a string
10:28:26 <Cale> and be even more evil than the C version
10:28:38 <jethr0_> would the printf typing trick work for sth like scanf too?
10:28:42 <SamB> well, you'd need a base version that returned the unscanned input...
10:28:53 <SamB> actually, that is the very version I'd want
10:29:08 <Cale> huh?
10:29:11 <Cale> like getLine?
10:29:14 <SamB> because I'm doing a Read instance for uuids...
10:30:31 <sjanssen_> a TH version of printf would be cool -- it could parse the format string at compile time instead of runtime
10:30:47 <davidhouse> printf is used as an example in the TH paper
10:31:09 <davidhouse> it's a little syntactically clumsy, though.
10:31:44 <Cale> most things done with TH are syntactically a bit clumsy
10:31:49 <jethr0_> true
10:32:08 <jethr0_> but the printf typing hack isn't so readable either
10:32:14 <SamB> the syntax is very clear, though
10:32:27 <SamB> it makes it quite obvious what is done at compile time
10:32:42 <SamB> at least, in the splice sites
10:37:15 <jethr0_> in many cases you have to write some AST yourself and that gets messy fast.
10:39:02 <oNoX> why does only foldr works and why not foldl too?
10:39:21 <Cale> foldl works, but it passes the parameters to the function in the opposite order
10:39:31 <Cale> so you have to flip the parameters to that lamda
10:39:33 <Cale> lambda*
10:41:45 <oNoX> ok, and onther question: i want to count the names in the list? do I need to define 2 maps?
10:43:33 <SamB> cool, I've got show and read working at least.
10:43:57 <Cale> no, you just need to store pairs in your map
10:43:59 <oNoX> because I want to count number of occurences of a key
10:44:04 <SamB> though my read doesn't check validity very well
10:44:09 <Cale> and change the combining function accordingly
10:45:00 <SamB> er, my show doesn't actually work quite right...
10:45:08 <Cale> change prs to  return (n, (read t, 1))
10:45:46 <Cale> and actually, rather than foldr/l you can use fromListWith
10:46:33 <Cale> fromListWith (\(n,c) (n',c') -> (n+n', c+c')) (prs s)
10:46:47 <Cale> toList (fromListWith (\(n,c) (n',c') -> (n+n', c+c')) (prs s))
10:48:07 <davidhouse> > (2, 3) + (5, 6)
10:48:07 <lambdabot>  add an instance declaration for (Num (a, b))
10:48:07 <lambdabot>   In the definition of `oae': oae = (2, 3) + (5, 6)
10:48:07 <lambdabot>   In the definition of `jgp':
10:48:22 <davidhouse> :( pairs should be instances of everything if both their elements are.
10:48:42 <Cale> even Fractional?
10:48:50 * SamB kills userlist buttons 'cause he keeps clicking them by mistake
10:48:52 <davidhouse> why not?
10:49:04 <oNoX> and I have to forget foldr?
10:49:17 <Cale> oNoX: it's built into the fromListWith
10:49:27 <Cale> (I'd forgotten about that function)
10:49:49 <Cale> davidhouse: it wouldn't even approximately satisfy the expected properties
10:50:19 <Cale> For example, Rational is an instance of Fractional
10:50:49 <Cale> but there are elements of (Rational,Rational) which won't be invertible, even though they are nonzero.
10:51:05 <oNoX> ok, it works now
10:51:22 * SamB thinks he has read and show working for valid UUIDs now
10:51:27 <Cale> for example, what's recip (0,1)
10:51:39 <davidhouse> > recip 0
10:51:40 <lambdabot> Infinity
10:51:46 <davidhouse> then it's (Infinity, 1)
10:51:46 <SamB> > Infinity
10:51:47 <lambdabot>  Not in scope: data constructor `Infinity'
10:51:49 <Cale> that's with Double
10:51:56 <Cale> > recip (0%1)
10:51:57 <lambdabot> Exception: Ratio.%: zero denominator
10:52:02 <SamB> > infinity
10:52:03 <lambdabot>  Not in scope: `infinity'
10:52:04 <davidhouse> then it's (undefined, 1)
10:52:05 <SamB> > inf
10:52:05 <lambdabot>  Not in scope: `inf'
10:52:11 <davidhouse> SamB, no public constructors
10:52:24 <Cale> The problem is that (Rational, Rational) isn't a field.
10:52:33 <Cale> It's a ring, but not a field.
10:52:42 <Cale> Division doesn't quite make proper sense.
10:53:20 <davidhouse> i don't see why (undefined, 1) would be a problem
10:53:31 <davidhouse> unless you're expecting properties like a * recip a = 1
10:53:36 <Cale> exactly
10:54:01 <davidhouse> that's a bit limiting
10:54:02 <Cale> for nonzero a, you should be able to expect that a * recip a = 1 (at least in approximation, if not exactly)
10:54:16 <davidhouse> as we don't have a way to say "use this as the 1"
10:54:25 <Cale> Otherwise, an instance of Fractional is meaningles.
10:54:26 <Cale> s
10:54:33 <Cale> We do
10:54:36 <Cale> fromInteger 1
10:54:50 <davidhouse> we should have Field a where identity :: a; (*) :: a -> a -> a; (+) :: a -> a -> a
10:55:06 <davidhouse> @type fromInteger
10:55:07 <lambdabot> forall a. (Num a) => Integer -> a
10:55:09 <davidhouse> ah, i see.
10:55:41 <davidhouse> then there's no problem
10:56:08 <davidhouse> you just define (0, 1) as un-invertible (it's isomorphic to the 0 of the rationals)
10:56:18 <davidhouse> or (0, x) in fact
10:58:23 <Cale> but it's a nonzero element -- are you saying to treat it like you would 0?
10:58:33 <davidhouse> yes.
10:58:46 <Cale> once you quotient by that, you'll end up with the rationals again
10:58:58 <davidhouse> what does "nonzero" mean in this context? we can define it to mean "any pair (x, y) with x or y 0"
10:59:17 <Cale> nonzero means that either x or y is not 0
10:59:29 <davidhouse> says who?
10:59:47 <Cale> fromInteger 0 :)
11:00:10 <Cale> fields are not permitted to have zero divisors
11:00:34 <Cale> and if you mod out by the zero divisors in this case, you'll end up with your original field.
11:00:39 <davidhouse> > fromInteger 0 :: (Int, Int)
11:00:39 <lambdabot>  add an instance declaration for (Num (Int, Int))
11:00:40 <lambdabot>   In the expression: fromInteger 0 :: (Int, Int)
11:00:40 <lambdabot>   In the definition of `inh': inh = fromInteger 0 :: (Int, Int)
11:00:47 <davidhouse> no it doesn't.
11:00:57 <Cale> well, it has to return some value
11:01:04 <davidhouse> sure. how about (0, 0)?
11:01:11 <Cale> right, that's what I expected
11:01:12 <davidhouse> ah. i see what you mean.
11:01:29 <davidhouse> you're saying we want nonzero to mean /= fromInteger 0
11:01:33 <Cale> right
11:02:02 <davidhouse> okay.
11:02:06 <Cale> otherwise, you just have a plain old commutative ring
11:02:13 <davidhouse> well it should at least instantiate Num :)
11:02:17 <Cale> okay
11:02:23 <Cale> that would be reasonable
11:03:04 <Cale> probably it wasn't in order to allow for some flexibility in instances
11:03:15 <Cale> (though that's a little silly here)
11:04:22 <Cale> For example, I could want an instance of Num for (Integer, Integer) where (a,b) * (c,d) = (a*c - b*d, a*d + b*c)
11:05:05 <Cale> or even something like (a,b) * (c,d) = (a*c - 5*b*d, a*d + b*c)
11:05:42 <Cale> though it's probably best that I use a newtype in both of these cases
11:06:23 * SamB_XP wishes his x-chats could communicate about whether he'd seen something yet or not, so as to avoid nasty flashing alerts about stuff he's already seen
11:06:51 <Cale> you can use the red line
11:07:11 <Cale> or is that not what you mean?
11:16:12 <SamB> I have two instances of x-chat running, and they don't know about eachother. I don't really need a flashing taskbar button to alert me about something someone said to me which I have already read, now do I?
11:16:28 <Cale> oh, I see
11:16:31 <Cale> why two?
11:16:49 <SamB> I have two computers ;-)
11:17:38 <Cale> that would be pretty tricky then -- especially as it would need to know which one you were looking at :)
11:17:45 <SamB> hmm.
11:17:51 <SamB> what you say is true!
11:18:13 <SamB> it could assume that any typing in the window meant that I was looking at it, though.
11:21:11 <neologism> SamB: switch to irssi and use shared screen
11:21:24 <SamB> you can do that?
11:21:29 <neologism> of course
11:21:35 <SamB> well, to do that, I'd have to learn how to use irssi.
11:21:51 <SamB> Too bad there is no Xscreen...
11:21:59 <neologism> I think there is something like that
11:22:05 <neologism> thought never used that
11:22:29 <SamB> also, my XP box doesn't have very good X
11:23:23 <neologism> hehe
11:24:09 <jethr0_> there's not much to learn with irssi. unless you intend to do some wicked plugin hacking
11:24:41 <SamB> does it have clicky-clicky menus?
11:24:43 <damg__> irssi-over-ssh :)
11:24:47 <damg__> easy
11:25:05 <jethr0_> no
11:25:24 <jethr0_> but how much could you possibly want to configure?
11:25:24 <SamB> it could be easier. except I hear screen doesn't support the mouse?
11:25:40 <neologism> SamB: what do you need mouse/menu on irc?
11:25:45 <jethr0_> w/o menus you don't need a mouse :)
11:26:15 <SamB> how am I supposed to find stuff without filling my buffer with help text, then?
11:26:39 <neologism> find stuff?
11:26:47 <mauke> what's wrong about filling the buffer with help text?
11:27:22 <SamB> what if I want to see what people have said instead of help text?
11:27:24 <jethr0_> i've never had much help text in irssi. pretty much worked out of the box. and simple configs are easy too
11:27:35 <mauke> SamB: then you switch to the channel
11:27:39 <SamB> oh
11:28:00 <SamB> next problem: I'd need to learn screen
11:28:11 <neologism> ctrl-a ctrl-c creates window
11:28:15 <mauke> you only need two commands for most things
11:28:17 <jethr0_> hmm, unless you want to do anything fancy it's pretty much like a bash
11:28:21 <neologism> ctrl-a number switches to window
11:28:23 <neologism> thats all you have to know
11:28:28 <mauke> ctrl-a d for detach and screen -r for reattach
11:28:35 <jethr0_> and the command for attaching as shared
11:28:36 <mauke> oh, and screen -x for multitach
11:28:52 <neologism> forger -r.. use -x only
11:29:02 <SamB> what is multitach?
11:29:15 <neologism> two machines connected to one screen
11:29:16 <mauke> the shared control thingy
11:29:16 <jethr0_> SamB: you shouldn't be afraid of some nice console technology :)
11:29:33 <jethr0_> although i must admit i've never used screen under windows
11:30:05 <SamB> and, yeah, I'd need a decent SSH client.
11:30:10 <jethr0_> putty?
11:30:20 <jethr0_> rxvt + openssh
11:30:27 <SamB> rxvt?
11:30:35 <neologism> terminal emulator
11:30:37 <neologism> just use putty
11:30:37 <jethr0_> it's in cygwin somewhere and a terminal emulator
11:30:42 <SamB> I still don't get how that works
11:30:46 <SamB> on windows.
11:31:05 <neologism> run irssi inside screen
11:31:12 <neologism> then attach to that screen from another machine
11:31:14 <sjanssen_> SamB: just use putty, it's nice
11:31:46 <SamB> some of the keys don't seem to work right :-(
11:31:54 <jethr0_> which ones?
11:32:04 <SamB> Home and End, maybe
11:32:06 <neologism> SamB: you might have set bad temirnal
11:32:08 <neologism> terminal
11:32:46 <jethr0_> echo $TERM
11:33:23 <SamB_XP> for some reason it says "xterm"
11:33:36 <neologism> that should be ok
11:33:49 <neologism> putty emulates xterm iirc
11:36:07 * SamB_XP wonders what this "Initial state of numeric keypad" option called "NetHack" does
11:38:38 <psi> has anyone else noticed a dramatic increase of spam in their gmail account?
11:38:41 <jethr0_> http://www.hardline.org/tiki-read_article.php?articleId=3
11:38:59 <SamB> yeah, I've seen maybe 4 spams lately!
11:39:03 <peteog> Hi guys, wondering if I could get some help again: http://pastebin.com/733480 that is my solution to the problem but I dont like it... doesnt seem the right way to do it and it also requires the quicksort function... ? 
11:39:07 <SamB> maybe more!
11:39:14 <kep> psi i'm not yet
11:39:22 <psi> I'm getting tons of mails about lotteries.
11:39:44 <SamB> yeah...
11:39:51 <davidhouse> @hoogle maximumBy
11:39:51 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
11:39:51 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
11:39:56 <davidhouse> peteog: ^^
11:40:19 <jethr0_> peteog: minimumBy, maximumBy?
11:40:29 <jethr0_> damn, too late
11:41:07 <davidhouse> > let comparing f x y = f x `compare` f y in maximumBy (comparing fst3) [(3, "a", "b"), (5, "c", "d"), (4, "e", "f")]
11:41:07 <lambdabot>  Not in scope: `fst3'
11:41:19 <davidhouse> > let comparing f x y = f x `compare` f y; fst3 (x, _, _) = x in maximumBy (comparing fst3) [(3, "a", "b"), (5, "c", "d"), (4, "e", "f")]
11:41:20 <lambdabot> (5,"c","d")
11:41:24 <peteog> they arnt standard prelude functions? My assumption is that the exam we are only meant to use the standard ones
11:41:45 <neologism> peteog: I am sure you can use maximumBy in your exam ;)
11:41:54 <SamB> neologism: how sure?
11:42:00 <davidhouse> peteog: they're in the standard libraries
11:42:06 <neologism> SamB: a lot ;)
11:42:22 <peteog> :)
11:42:29 <Cale> If not, it's an easy function to write yourself
11:42:30 <peteog> such a clever language
11:44:13 <jethr0_> > minimum $ map (snd.snd) [(1, ("Ball", 10)), (2, ("Pencil", 30)), (3, ("Pen", 5)), (4, ("Rubber", 3))]
11:44:14 <lambdabot> 3
11:45:09 <sjanssen_> @keal
11:45:10 <lambdabot> what the hell does Prelude > mean?
11:45:26 <davidhouse> jethr0_: snd . snd? eww.
11:45:34 <jethr0_> huh?
11:45:38 <davidhouse> just write a thd3.
11:45:43 <jethr0_> eww
11:46:06 <jethr0_> @type thd3
11:46:07 <lambdabot> Not in scope: `thd3'
11:46:21 <davidhouse> his Table is a list of triples, not some ugly amalgamated combination ;)
11:46:32 <davidhouse> @type let thd3 (_, _, x) = x in thd3
11:46:34 <lambdabot> forall a b c. (a, b, c) -> c
11:46:43 <jethr0_> i know that, but as i like using arrow functions, i am quite partial to nested tuples :)
11:46:59 <peteog> :)
11:47:03 <jethr0_> imo haskell isn't suited so well for tuples longer than 2
11:47:16 <davidhouse> tbh a record would fare well here.
11:48:39 <davidhouse> or better, a Data.Map PID (Name, Price)
11:49:01 <jethr0_> yes, that's what i would have suggested if it weren't for the prelude restriction
11:49:12 <davidhouse> peteog: by the way, head (reverse x) = last x
11:49:15 <peteog> I really ought to learn some more functions... there are loads I had no idea about, maximum and minimum are nice
11:49:35 <peteog> hahaha ;)
11:49:35 <davidhouse> and there is a preluded sort function
11:49:35 <peteog> well
11:49:43 <davidhouse> @hoogle sort
11:49:44 <lambdabot> List.sort :: Ord a => [a] -> [a]
11:49:44 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
11:49:44 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
11:49:46 <jethr0_> especially since minimum is O(n) and sort is O(n log(n))
11:50:01 <jethr0_> *yuch*
11:50:03 <peteog> like I say, its a shame I cant take a "cheat sheet" into it
11:50:21 <davidhouse> head into ghci, hit :b Prelude. voila, instant cheat sheet.
11:50:30 <davidhouse> for bonus marks, try :b Data.List as well.
11:50:36 <peteog> :)
11:50:43 <davidhouse> and :b Control.Monad, :b Control.Arrow if you're into that kind of thing.
11:50:52 <jethr0_> *hmm*, arrows
11:51:04 <peteog> wow, cool... v useful :)
11:51:09 * davidhouse <3 arrowic combinators
11:51:22 <neologism> is there anything like nomaware monads introduction for arrows?
11:51:37 <davidhouse> peteog: you can normally guess what a function does by its type. if not, the hierarchial modules documentation is great. http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:51:47 <davidhouse> neologism: haskell.org/arrows has a few papers
11:51:50 <jethr0_> there's the arrow papers. but i must admit i usually only use the functions for tuple mangling :(
11:51:53 <davidhouse> they're quite easy stuff.
11:52:12 <jethr0_> fullfledged arrows can get a bit confusing. at least w/o the new arrow syntax
11:52:20 <neologism> I want something veryu simple
11:52:21 <davidhouse> jethr0_: heh, yep. i'm yet to write something that actually uses any arrows apart from (->). the combinators are nice though.
11:52:23 <neologism> for a 100% beginer
11:52:29 <jethr0_> he
11:52:48 <davidhouse> neologism: tried Ross Paterson's Arrows and Computations?
11:52:59 <neologism> where can I get it?
11:53:06 <davidhouse> from haskell.org/arrows
11:53:10 <jethr0_> davidhouse: i've done a fair bit of yampa juggling and it gives you a headache pretty quickly. thinking in terms of fixpoints and loops and dynamic switches...
11:53:17 <jethr0_> @where arrows
11:53:18 <lambdabot> http://www.haskell.org/arrows/
11:53:38 <neologism> foudn that
11:54:07 <davidhouse> yampa uses arrows, then?
11:54:13 <jethr0_> most heavily
11:54:18 <davidhouse> fun.
11:54:34 <davidhouse> i still have a deep-residing mistrust of the Y-combinator.
11:54:58 <jethr0_> http://jethr0.dyndns.org/repos/yampa/Main.hs
11:55:12 <dcoutts> davidhouse, you should do! general recusion isn't true!
11:55:17 <jethr0_> my still unfinished pong game :)
11:55:41 * jethr0_ distrusts anything that has "fixpoint" in it
11:56:01 <davidhouse> fix is simply witchcraft. there's no other explanation.
11:56:28 <dcoutts> though of course it's the same thing as recursive let
11:56:38 <davidhouse> similarly so.
11:56:50 <davidhouse> well, i can grok recursive lets.
11:57:16 <davidhouse> i just assume they're syntactic sugar and expand them out in my mind
11:57:22 <davidhouse> fix, however. err...
11:57:36 <dcoutts> davidhouse, but let rec expands to fix!
11:57:43 <jethr0_> there isn't much sugar in "fix"
11:58:11 <dcoutts> let rec f = e in f   ~~~  fix (\f -> e)
11:58:13 <davidhouse> dcoutts, i thought fix expands to let rec?
11:58:43 <dcoutts> davidhouse, well they're equivalent, so it depends on your point of view which you think is more primitive
11:58:44 <davidhouse> fix f = let x = f x in x
11:59:24 <Philippa> dcoutts: only if you're translating into the untyped lambda calculus or similar
11:59:36 <davidhouse> i.e. fix f = f $ f $ f $ f $ ...
11:59:39 <dcoutts> Philippa, no need for untyped lambda calculus
12:00:02 <dcoutts> it's just added as a constant to the (typed) lambda calculus
12:00:11 <Philippa> "or similar"
12:00:56 <dcoutts> well if you don't give it's implementation (which you can't in simply typed lambda calculus) then they're all the same
12:01:08 <dcoutts> doesn't matter if you call it Y, fix whatever
12:01:39 <Philippa> yup. But if you're defining a variant calculus to support it anyway, you may as well just build letrec into the calculus
12:02:04 <neologism> that paper is too heavy for me
12:02:20 <davidhouse> neologism: what don't you get about arrows?
12:02:58 <neologism> I stopped at the second page
12:03:01 <davidhouse> arrows are a kind of generic black box: something that takes an input and gives an output.
12:03:06 <neologism> the example with add / addSt
12:03:19 <neologism> I'd appreciate something like nomaware's cloned sheeps
12:03:25 <davidhouse> what makes them special is that they can have side effects.
12:03:38 <davidhouse> hmm.
12:04:36 <ihope> Now that I think a bit, the main reason I'm not doing anything with EgoBot is that I can't figure out how to keep input separate from output.
12:04:53 <davidhouse> ihope, what's EgoBot?
12:05:02 <jethr0_> davidhouse: huh?
12:05:03 <ihope> s/EgoBot/EagleBot/
12:05:15 <ihope> It's an IRC bot I was making.
12:05:17 <jethr0_> arrows aren't about side effects...
12:06:16 <davidhouse> jethr0_: arrows without side effects are functions, no?
12:06:30 <jethr0_> arrows are for describing processes, much like monads. but with arrows you have more parameters/dimensions and can split/join datastreams or decide on which stream to process depending on content
12:07:10 <jethr0_> for the beginning you can think of arrows as monads. and when you've come to a point where that's too simplistic you'll be far ahead of me :)
12:07:20 <davidhouse> arrows are monads with inputs.
12:07:27 <neologism> can you show me some examples using arrows?
12:07:30 <jethr0_> monads have inputs too
12:07:36 <davidhouse> only pure ones.
12:07:47 <davidhouse> err, hang on, that might not have made sense.
12:07:56 <palomer> I thought all monads could trivially be made into arrows
12:08:15 <davidhouse> hmm... i'm sure there's a difference between a b c and b -> m c
12:09:16 <jethr0_> > second (*2) <<< not *** (+1) <<< even &&& (+1) $ 2
12:09:17 <neologism> palomer: the paper says monads are a subset of arrows
12:09:17 <lambdabot> (False,8)
12:09:38 <neologism> jethr0_: simple examples :)
12:09:40 <davidhouse> palomer: yes but not vice versa.
12:09:44 <neologism> what are the combinators
12:09:44 <jethr0_> not a very good example though :(
12:09:58 <davidhouse> jethr0_: that explains the combinators rather than the concept themselves.
12:10:21 <jethr0_> davidhouse: as i said, i find fullfledged arrows quite advanced
12:10:23 <davidhouse> (&&&) takes two arrows and combines them into a single one returning a pair.
12:10:26 <davidhouse> @hoogle (&&&)
12:10:26 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
12:10:39 <jethr0_> it's like trying to explain monads in one line on the channel
12:10:55 <davidhouse> i.e. given an arrow with input b and output c, and another with input b and output c', (&&&) combines them into one with input b and output (c, c')
12:11:08 <davidhouse> the easiest example of arrows are pure functions, so:
12:11:23 <davidhouse> > (toUpper &&& ord) 'a'
12:11:24 <lambdabot> ('A',97)
12:11:32 <neologism> ok
12:11:34 <davidhouse> @type toUpper &&& ord
12:11:52 <davidhouse> okay, who killed lambdabot?
12:11:54 <jethr0_> arrow's type notation isn't the most readable either
12:12:05 <davidhouse> okay, well, moving on:
12:12:30 <davidhouse> @hoogle (***)
12:12:34 <Eelis> hmm, would it be fair to say that haskell's use of whitespace makes using a variable width font for code very awkward?
12:12:34 <lambdabot> Char -> (Char, Int)
12:12:36 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:12:45 <jethr0_> Eelis: definitely
12:12:51 <Lemmih> Eelis: Absolutely.
12:13:04 <Eelis> ok, then i'll have to find me a nice fixed width font.
12:13:05 <davidhouse> (***) takes two arrows and places them side-by-side.
12:13:06 <jethr0_> Eelis: but then i think that programming any language in variable width font is weird
12:13:21 <Eelis> jethr0_: it works fine for languages like C++.
12:13:30 <neologism> davidhouse: ok
12:13:34 <palomer> hrmph
12:13:39 <davidhouse> jethr0_, Lemmih: unless it's the sexy haskell with unicode (real lambda for lambdas!) you see in papers
12:13:39 <jethr0_> *brr*, never tried but i'm not going to try either
12:13:41 <vincenz> rerere
12:13:42 <sjanssen_> @palomer!
12:13:42 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
12:13:56 <davidhouse> @hoogle (>>>)
12:13:56 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
12:14:01 <palomer> if only you could encode heterogenous lists at the type level, then you could use that instead of pairing for arrow
12:14:05 <davidhouse> (>>>) composes two arrows.
12:14:14 <davidhouse> connects the input of one to the output of another.
12:14:31 <jethr0_> you're not supposed to look at the "internal" datatype of the arrows, so it doesn't really matter what they use
12:14:36 <sjanssen_> palomer: you can't encode heterogenous lists at the type level?  I've talked with you about HList before, right?
12:14:50 <palomer> sjanssen: ok, cleanly
12:15:00 <palomer> without typeclasses
12:15:01 <davidhouse> @type first
12:15:08 <davidhouse> @hoogle first
12:15:11 <lambdabot> forall (a :: * -> * -> *) d c b.
12:15:13 <lambdabot>    (Arrow a) =>
12:15:15 <lambdabot>    a b c -> a (b, d) (c, d)
12:15:17 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
12:15:19 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
12:15:21 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
12:15:26 <davidhouse> yes, anyway.
12:15:29 <sjanssen_> palomer: the things necessary for (&&&) don't need type classes at all
12:15:52 * Eelis wonders why people don't just keep a ghci terminal open
12:15:56 <palomer> but I'd want to extend &&& to take arbitrary number of inputs and return an arbitrary number of outputs
12:16:13 <davidhouse> neologism: first takes an arrow and transforms it into an arrow that only acts on part of its input.
12:16:15 <jethr0_> one can think of arrows as stream processing. the diagrams on haskell.org/arrows/syntax.html are quite helpful imo
12:16:22 <davidhouse> Eelis: because i'm showing neologism stuff
12:16:27 <vincenz> Eelis: for lambdabot?
12:16:28 <Eelis> davidhouse: fair enough
12:16:30 <Eelis> vincenz: yes
12:16:33 <vincenz> Eelis: you don't need to
12:16:36 <sjanssen_> palomer: I suppose you'd need typeclasses anyway
12:16:37 <vincenz> Eelis: there is a terminal version of lambdabot
12:16:39 <jethr0_> palomer: then you'd have to nest &&&s. or maybe use the new arrow syntax
12:16:42 <vincenz> jus start it without --online
12:16:54 <neologism> davidhouse: ok... I can lookup the combinators
12:16:54 <vincenz> @version
12:16:54 <lambdabot> lambdabot 3p7, GHC 6.4.1 (Linux i686 3.20GHz)
12:16:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:16:56 <jethr0_> s/maybe//
12:16:57 <davidhouse> ghci + hoogle is pretty much all you need.
12:17:03 <vincenz> yah
12:17:03 <neologism> can you think of some nice example where its obvious why are arrows useful?
12:17:07 <Eelis> vincenz: for my purposes ghci suffices for now :) but thanks, i may toy with it some day
12:17:08 <davidhouse> i found a way to integrate them, it's on the wiki somewhere
12:17:17 <neologism> lets say like nomaware sheeps with Maybe monad
12:17:22 <vincenz> Eelis: hoogle is spiffy
12:17:32 <jethr0_> neologism: yampa and all the newer functional reactive thingeys
12:17:32 <vincenz> anyways
12:17:37 <vincenz> back to my typechecker 
12:17:43 <neologism> jethr0_: something simple..
12:17:57 <davidhouse> jethr0_: i sitll don't see how arrows are anything apart from pure functions with side effects.
12:18:09 <Philippa> jethr0_: there're newer FRP libs? I've mostly seen stuff on top of yampa
12:18:09 <davidhouse> neologism: you're right, there should be something.
12:18:13 <Philippa> davidhouse: same way monads aren't
12:18:26 <jethr0_> neologism: the "yampa arcade" paper while not being simple is quite a nice read
12:18:37 <sjanssen_> > (succ &&& pred &&& id) 1
12:18:38 <lambdabot> (2,(0,1))
12:18:44 <Philippa> it's about as simple as you can hope for in a "real" example
12:18:47 <vincenz> right associative
12:18:56 <davidhouse> Philippa: they're not?
12:18:57 <sjanssen_> palomer: I'd say that's about as nice as anything that would use HLists
12:19:16 <vincenz> > (succ . succ && pred . pred) 1
12:19:16 <lambdabot> Couldn't match `Bool' against `t -> t1'
12:19:17 <neologism> jethr0_: I want something like foo :: Maybe Int -> Maybe Int -> Maybe Int where foo computes something using monad combinators without checking if its Just or Notrhign
12:19:19 <vincenz> doh
12:19:22 <vincenz> > (succ . succ &&& pred . pred) 1
12:19:23 <lambdabot> (3,-1)
12:19:30 <jethr0_> davidhouse: i don't see what you mean by side effects. and i don't understand what makes arrows so function-y in your mind. do you see monads as functions too?
12:19:54 <Philippa> monadic computations pretty clearly aren't functions 'cos they yield values
12:19:57 <davidhouse> a computation in State is just a normal function but it can have the added side effect of updating the current state.
12:19:59 <jethr0_> neologism: i don't quite get the question. maybe something involving fmap?
12:19:59 <sjanssen_> Monads aren't functions, and that's why they're less general than arrows
12:20:30 <jethr0_> davidhouse: that's obviously only a perceived side effect. the monad just passes the world state around transparently
12:20:36 <neologism> jethr0_: http://www.nomaware.com/monads/html/meet.html
12:20:40 <neologism> something like this for arrows
12:20:43 <jethr0_> neologism: i know the tutorial
12:20:47 <davidhouse> jethr0_: obviously.
12:20:57 <jethr0_> and i'm pretty sure there isn't anything close to that for arrows
12:20:59 <Philippa> no, it's not why they're less general. The significant difference with arrows is that they relax some of the laws - they don't require ArrowApply, most notably
12:21:10 <neologism> jethr0_: see the concrete page
12:21:21 <davidhouse> yes, ArrowApply, a special case of arrows, are just monads (right?)
12:21:23 <neologism> how he simplified the code using Maybe monad
12:21:47 <jethr0_> neologism: so you want to write a Maybe arrow?
12:21:52 <jethr0_> i don't know what your final goal is!
12:22:03 <neologism> no.. I want to see example using arrows which shows similar simplification
12:22:22 <neologism> something liek "without arrows its this ugly but with arrows its this simple"
12:22:33 <Philippa> you won't get one that's as neatly-contained as Maybe is for monads
12:22:39 <sjanssen_> Philippa: I thought that the ability of Arrows to see the types of both input and output was the significant difference
12:23:08 <Philippa> sjanssen: that's really not so important, all the "monadic operations" in a monad can see that too
12:23:11 <jethr0_> neologism: there are few people who are really into arrows, so there's a very small community to ask for practical examples. and although i'd like to, i'm not that deep into practical arrow applications myself
12:23:38 <Philippa> I think the parsing lib that led to it's not a bad example, so long as you're happy about parsing monads
12:24:10 <jethr0_> neologism: writing AND and OR circuits and connecting them is a nice arrow application IMO
12:24:17 <neologism> ok
12:24:35 <neologism> I think I'll stick with monads for a time being ;)
12:24:40 <jethr0_> arrows are well suited for problems where you connect data streams with computation blackboxes
12:24:52 <Philippa> sjanssen: in fairness there're probably things easier implemented as arrows than as monads
12:25:03 <Philippa> jethr0_: yup. Which is why yampa works well
12:25:51 <jethr0_> yes, but yampa goes further and introduces dynamic collections. also the aspect of feedback circuits is nice
12:26:39 <jethr0_> but as with many "complex" new paradigms/tools/techniques yampa drives you up the wall for the first dozens of hours :)
12:26:44 <Philippa> yampa effectively provides most of the dataflow-flavoured stuff you could want in an arrow
12:27:00 <neologism> @where yampa
12:27:00 <lambdabot> http://www.haskell.org/yampa/
12:27:25 <jethr0_> yes, and once you've understood what's going on it's a very powerful and abstraction-enhancing technique
12:27:40 <jethr0_> neologism: have a read of the yampa arcade. it's a nice paper
12:27:53 <neologism> jethr0_: ok
12:29:15 <jethr0_> Philippa: as i'm not an engineer it took me several days to get yampa to integrate my mouse pointer correctly (so i'd have mouse speed, ...). for some things you just have to expend some mental energy
12:29:28 <jethr0_> *pointer movement
12:31:33 <neologism> a lot of links on the haskell.org/yampa doesnt work :(
12:33:03 <jethr0_> :(
12:33:20 <jethr0_> ah, that page is really stupid. i hated it
12:34:53 <jethr0_> as i said, there are very few people actively using arrows. hopefully that'll change at some point...
12:35:11 <jethr0_> bbl
12:50:54 <dcoutts> @localtime dons
12:50:55 * davidhouse breathes
12:50:56 <lambdabot> Local time for dons is Wed May 24 05:44:47 2006
12:51:06 <dcoutts> hmm, too early
12:51:09 <davidhouse> wireless keeps dropping out.
12:51:14 * davidhouse is trying irssi for the first time
12:51:24 <davidhouse> after getting sick of konversation
12:51:30 <vincenz> what do typers think of this http://rafb.net/paste/results/R9yr4y30.html
12:52:39 <neologism> irssi is great
12:52:41 <vincenz> obviously st should be TyperState
12:52:45 <neologism> irssi over ssh thats it
12:53:10 <Cale> nice - you probably want to use Data.Map for the dictionaries, but that's a small point
12:53:17 <norpan> irssi in screen over ssh is the shit
12:53:17 <vincenz> for the rest it looks ok
12:53:22 <vincenz> except for the part of unify not being implemented yet
12:53:46 <vincenz> as for freeTyvar I'll give it an infinite list to start with
12:53:58 <davidhouse> right. who wants to teach me how to use this crazy beast?
12:54:26 <vincenz> ?
12:54:31 <davidhouse> (irssi)
12:55:18 <vincenz> my ? was an appendum to "for the rest it looks ok"
12:55:58 <vincenz> not sure whether normalize sould be
12:56:02 <vincenz> Id -> m Type
12:56:04 <vincenz> or Type -> m Type
12:57:26 <davidhouse> am i still connected?
12:57:44 <xerox> @arr!
12:57:44 <lambdabot> Shiver me timbers!
12:58:00 <davidhouse> looks so :)
12:58:09 <dcoutts> sjanssen_, are you looking at unfoldrN or should I?
12:58:14 <vincenz> davidhouse: are you still there?
12:58:19 <vincenz> davidhouse: you said something about switching to irssi
12:58:27 <vincenz> davidhouse: ping
12:58:29 <davidhouse> vincenz: i think i'm here
12:58:33 <vincenz> davidhouse: can you hear me?
12:58:43 <davidhouse> vincenz: yes, but i don't think you can hear me
12:58:44 <vincenz> hmm
12:58:58 <vincenz> does anyone know ow to contact davidhouse to tell him his irssi is not working?
12:59:14 <davidhouse> :P i know it's not working
12:59:23 <vincenz> just joking ;)
12:59:24 <Lemmih> davidhouse: he's pulling your leg.
12:59:43 <vincenz> :D
12:59:47 <davidhouse> dammit, you had me all confused there.
12:59:54 <vincenz> MUHAHA
12:59:59 <sjanssen_> dcoutts: I've got it essentially done.  I should be home to send the patch in a couple hours
13:00:23 <dcoutts> sjanssen_, great, what did you do about generate?
13:00:35 <sjanssen_> I didn't use it
13:00:44 <dcoutts> sjanssen_, and are you doing unfoldr too? or should I?
13:00:53 <sjanssen_> I've got unfoldr done
13:01:00 <dcoutts> ok great
13:01:00 <morans> whats the easiest way to get a lambdabot running on another channel on this IRCnet? (specifically, #globus)
13:01:15 <morans> run one myself?
13:01:18 <dcoutts> @join #globus
13:01:18 <lambdabot> Not enough privileges
13:01:22 <Lemmih> morans: Beg an admin.
13:01:28 <dcoutts> oh, I can't do it :-)
13:01:35 <dcoutts> ask dons when he wakes up
13:02:12 <morans> heh ok
13:02:14 <morans> cool
13:02:29 * morans used to having evaluator bots on his channels...
13:03:40 <sjanssen_> dcoutts: do you want me to send you the patch when I can?  (just in case you don't want to wait for a reasonable time in .au)
13:03:51 <dcoutts> sjanssen_, yes please
13:04:03 <neologism> davidhouse: irssi?
13:04:15 <dcoutts> sjanssen_, you've got my email address (from the darsc changelog), just darcs send to that
13:04:20 <sjanssen_> okay
13:04:25 <dcoutts> cheers
13:04:39 <davidhouse> neologism: i did something bad, so i thought i'd /quit and start over
13:05:00 <davidhouse> i've somehow set up irssi to auto-identify with the password '<password>'
13:06:27 <vincenz> is there some sort of sequence that will return the last 
13:06:36 <vincenz> sequence :: [m a] -> m a
13:06:41 <vincenz> with the a being the last a in the list
13:07:11 <davidhouse> do it yourself with a fold
13:07:20 <vincenz> foldr
13:07:21 <vincenz> ?
13:07:39 <vincenz> > foldr1 (>>) [return 1, return 2, return 3] :: Maybe Int
13:07:39 <lambdabot> Just 3
13:07:56 <davidhouse> @type \xs -> sequence (init xs) >> last xs
13:07:57 <lambdabot> forall (m :: * -> *) a.
13:07:57 <lambdabot>               (Monad m) =>
13:07:57 <lambdabot>               [m a] -> m a
13:08:13 <vincenz> @type init 
13:08:14 <lambdabot> forall a. [a] -> [a]
13:08:22 <vincenz> davidhouse: seems inefficient
13:08:23 <davidhouse> > init [1..9>
13:08:24 <lambdabot>  parse error on input `}'
13:08:25 <davidhouse> > init [1..9]
13:08:26 <lambdabot> [1,2,3,4,5,6,7,8]
13:08:32 <sjanssen_> davidhouse: for a long xs, the space behavior will be terrible
13:08:33 <vincenz> cause you're traversing over the list twice
13:08:34 <dcoutts> sjanssen_, so do you realloc increasingly larger strings or unfold in chunks and then concat at the end?
13:09:16 <sjanssen_> dcoutts: I did realloc.  I haven't tested the performance either way
13:09:52 <dcoutts> right, I suspect the concat would be quicker, but yes we'd have to time it
13:10:06 <davidhouse> @type let sequence' [x] = x; sequence' (x:xs) = x >> sequence' xs in sequence
13:10:06 <lambdabot> forall (m :: *
13:10:07 <lambdabot>                               -> *)
13:10:07 <lambdabot>                             a.
13:10:07 <lambdabot>                          (Monad m) =>
13:10:07 <lambdabot>                          [m a] -> m [a]
13:10:16 <davidhouse> oops :)
13:10:18 <davidhouse> @type let sequence' [x] = x; sequence' (x:xs) = x >> sequence' xs in sequence'
13:10:19 <lambdabot> forall (m :: *
13:10:19 <lambdabot>                               -> *)
13:10:19 <lambdabot>                             a.
13:10:19 <lambdabot>                           (Monad m) =>
13:10:19 <lambdabot>                           [m a] -> m a
13:10:25 <davidhouse> silly pretty printer.
13:10:33 <sjanssen_> concat would also allow the strings to reside on the Haskell heap
13:11:57 <davidhouse> we still alive in here?
13:12:03 * davidhouse is experimenting with screen
13:12:11 <sjanssen_> davidhouse: I'm sorry, I can't read your messages ;)
13:12:15 <vincenz> davidhouse: try @bot
13:12:17 <davidhouse> yeah, shutup.
13:12:23 <davidhouse> :)
13:12:29 <davidhouse> vincenz: what's that?
13:12:32 <vincenz> @bot
13:12:32 <lambdabot> :)
13:12:38 <davidhouse> aha.
13:12:41 <xerox> @botsnack
13:12:41 <lambdabot> :)
13:12:46 <vincenz> @botpoop
13:12:46 <lambdabot> Unknown command, try @list
13:12:47 <xerox> =)
13:12:56 <xerox> (That's the proper command.)
13:12:56 <vincenz> lambdabot is purely an input system!
13:13:25 <davidhouse> data Lambdabot; instance Arrow (Lambdabot BotSnack Poop) where ...
13:13:35 <davidhouse> or whatever the syntax is :)
13:13:47 <davidhouse> instance Arrow Lambdabot, i suppose.
13:13:52 <dcoutts> sjanssen_, here's my definition:
13:13:52 <dcoutts> unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
13:13:53 <dcoutts> unfoldr f w = P.concat (L.unfoldr (fmap (P.unfoldrN smallChunkSize f)) (Just w))
13:13:53 <davidhouse> hmm... i ruined the humour with that one.
13:14:04 <vincenz> davidhouse: still there?
13:14:54 <davidhouse> dcoutts: you're defining BS's unfoldr in terms of Data.List's? isn't that slightly futile?
13:15:04 <dcoutts> davidhouse, nope
13:15:22 <dcoutts> davidhouse, I'm unfolding in chunks and then concating them into one BS
13:15:23 <vincenz> "why not?"  "The humour was already ruined"
13:15:33 <vincenz> oh .. the nope was refering to something else
13:15:35 * vincenz coughs
13:15:51 <dcoutts> davidhouse, so I'm not unpacking into a list and then using List.unfoldr
13:16:10 <davidhouse> dcoutts: alritey. i'll take your word on that ;)
13:16:20 <vincenz> is there a doc somewhere on BS?
13:16:30 <dcoutts> vincenz, the haddock docs + the code
13:16:34 <sjanssen_> @where fps
13:16:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:16:54 <vincenz> perfect
13:16:58 <dcoutts> davidhouse, it makes even more sense for .Lazy since that is a list of chunks so we unfold on both the BS and List levels
13:17:01 <sjanssen_> using BS is easy, just like lists
13:17:22 * dcoutts wants a new IO system based on lazy btestrings
13:17:24 <vincenz> dcoutts: I have this tool which I'm considering porting from ocaml
13:17:31 <dcoutts> vincenz, oh yes?
13:17:37 <vincenz> dcoutts: yes and it needs to parse a binary file
13:17:43 <vincenz> in which data is packed by byte
13:17:47 <dcoutts> ah..
13:17:55 <vincenz> (the files can be quite large... like several GB
13:18:03 <vincenz> each packet is a byte with a header
13:18:11 <dcoutts> we don't have any pickling / unpickling code yet using bytestrings or lazy bytestrings
13:18:15 <vincenz> and then several more bytes with the data, te amount of bytes being specified by the type
13:18:18 <dcoutts> but we should!
13:18:43 <vincenz> well I could just use an ST monad no? and ten constant munch of bytes
13:18:49 <vincenz> constant...ly
13:18:51 <dcoutts> test parsing and binary (de)serialising with bytestrings would make perfect sense
13:18:59 <SamB> well, I'm not sure even lazy bytestrings are good for multi-GB binary files, necessarily.
13:19:06 <SamB> what about files with offsets?
13:19:22 <dcoutts> SamB, they're good for multi-GB files, dons has tried it
13:19:25 <sjanssen_> SamB: then you'd want non-lazy ByteString with mmap
13:19:40 <vincenz> for instance one packet could look like this [header=1byte| number=4byte| address=4byte]
13:19:41 <SamB> how are you going to do that on a 32-bit system?
13:19:56 <sjanssen_> oh yes, that'd be a problem
13:20:06 <dcoutts> SamB, dons showed that he can process a 10GB file with only 6% speed loss compared to an equivalent C prog.
13:20:14 <dcoutts> and using a constant heap
13:20:15 <SamB> its fine if the file is sequential
13:20:20 <dcoutts> right
13:20:27 <mux> dons: hs-fps just hit the FreeBSD ports tree
13:20:35 <SamB> I admit most file formats with offsets in them have 32-bit offsets (or less)
13:20:39 <vincenz> dcoutts: how does he do that? A state monad which constantly pops off and saves the tail?
13:20:50 <davidhou1e> let's try this again :)
13:21:01 * davidhou1e waits for his alternative nick to timeout
13:21:08 <dcoutts> vincenz, no just using hGetContents, filterByte and hPutStr
13:21:16 <vincenz> hmm
13:21:17 <dcoutts> vincenz, the code is a one-liner. trivial.
13:21:31 <vincenz> yeah with me each packet can consume a different number of bytes
13:21:31 <davidhou1e> is there any point to screen if i use a GUI console wrapper (e.g. konsole) that supports tabs?
13:21:52 <dcoutts> vincenz, but since it's using lazy bytestrings it performs very well, since it's processing in 64k chunks
13:21:59 * vincenz nods
13:22:42 <vincenz> another thing that bugs me is the fact that I always have to keep the enum definition in c++ and in ocaml in sync
13:22:47 <vincenz> enum being the headertype
13:22:51 <sjanssen_> davidhou1e: screen gives you detach/reaatach
13:23:19 <SamB> vincenz: you have to do that kind of thing anyway
13:23:31 <dcoutts> vincenz, use c2hs which does that for you.
13:23:50 <dcoutts> c2hs can produce Haskell enums from C enums
13:24:16 <davidhou1e> sjanssen_: right. but why detach if i could just open a new tab?
13:24:26 <dcoutts> vincenz, so that'd keep you in sync automatically
13:24:31 <vincenz> and then:  fromInteger . fromIntegral . head $ bs?
13:25:05 <davidhou1e> what the hell? why are more versions of me connecting?
13:25:51 <davidhou1e> @bot
13:25:51 <lambdabot> :)
13:25:51 <sjanssen_> davidhou1e: you can detach, SSH in from another computer and keep the same session
13:26:03 <davidhou1e> my wireless is real screwy right now.
13:26:16 <davidhou1e> sjanssen_: ah, okay. with ssh things get funky.
13:29:57 <davidhou1e> how can i kill 'davidhouse'? it doesn't look like it's going to timeout
13:30:23 <neologism> only irc-ops can do that I think
13:30:41 <xerox> davidhou1e - try going to /WIN 1 and doing C-x, are you connected multiple times?
13:30:55 <xerox> davidhou1e - if not, /MSG NickServ GHOST <nick> <pwd>.
13:30:56 <eivuokko> And check how many irssi processes you got
13:30:59 <vincenz> davidhou1e: if you have davidhouse registered you can tell nickserv to drop hihm
13:31:11 <davidhou1e> vincenz: how is that done?
13:31:23 <vincenz> ^^^
13:31:27 <mux> davidhou1e: what did you do to the real davidhouse?
13:31:40 <davidhou1e> gotcha.
13:32:00 <davidhouse> thanks, xerox et al.
13:32:14 <mux> heh
13:32:18 <davidhouse> grr
13:32:25 <davidhouse> well at least i'm davidhouse.
13:32:29 <xerox> davidhouse - something like /server in /win 1 should also tell you which connections you are linked on.
13:32:52 <xerox> davidhouse - right, then /win 1, C-x C-x ... and /disconnect.
13:33:01 <davidhouse> i've got 'freenode' and 'RECON-1' connected
13:33:03 <cyyoung> anyone have links to an os x intel build of ghc or happen to be working on a port?
13:33:25 <xerox> He killed the wrong one (-:
13:33:28 <eivuokko> Heh
13:33:40 <eivuokko> It's not the most intuitive ui ;)
13:33:41 <sjanssen_> cyyoung: http://www.haskell.org/haskellwiki/GHC/On_Intel_Macs
13:33:58 <xerox> Oh-uh?
13:34:20 <xerox> The news spread =)
13:35:10 <davidhou1e> i think i found the problem
13:35:16 <davidhou1e> i've got about four screens running
13:35:18 <sjanssen_> xerox: there are benefits to subscribing to Haskell.org's RSS feed
13:35:19 * davidhou1e kills them off
13:35:27 <davidhou1e> be back soonish
13:36:07 <xerox> Ah, bringert.
13:36:17 <bringert> hi xerox
13:36:31 <cyyoung> sjanssen_: whoa great, that'll do until someone updates darwinports
13:36:40 <xerox> bringert - yow!  How's the shiny toy working?
13:37:06 <greenrd> Are there laws for monads which include the fail method, defined anywhere?
13:37:13 <greenrd> It seems as if there ought to be
13:37:15 <bringert> xerox: great. I install my 2GB of RAM yesterday.
13:37:32 <bringert> thanks for the GHC tip, it working fine, and really fast
13:37:44 <greenrd> Intuitively, return x should never be equal to fail y for any x, y, for example
13:37:44 <mux> greenrd: I don't think there are any, the fail method is not part of the mathematical definition of a monad
13:38:11 <greenrd> that's true, but still, haskell programmers using or creating monads with failure probably make certain assumptions
13:38:11 <xerox> bringert - 凄い！
13:38:20 <bringert> xerox: I started a wiki page here: http://www.haskell.org/haskellwiki/GHC_on_Intel_Macs
13:38:23 <greenrd> and it would be good to formalise those assumptions
13:38:24 <bringert> xerox: ?
13:38:45 <norpan>        http://sten.oskarson.org/archives/2005-10.html
13:38:49 <xerox> `Fabulous!'
13:38:50 <norpan> wrong
13:38:53 <bringert> ah
13:38:56 <norpan> http://www.haskell.org/hawiki/MonadPlus
13:39:00 <norpan> that's what i meant
13:39:10 <norpan> the other link are photos of my friend's baby :)
13:39:36 <davidhouse> ta-da! :)
13:39:53 <davidhouse> good ol' fashioned ps aux + kill.
13:40:16 <davidhouse> @bot
13:40:16 <lambdabot> :)
13:40:19 <jethr0_> good old top + 'k'
13:40:23 <jethr0_> *"top"
13:40:32 <mux> good not-so-old pkill
13:40:38 <mux> :-P
13:40:41 <jethr0_> what is pkill?
13:40:46 <sethk> turn the machine off, guaranteed to work every time
13:40:49 <greenrd> good old killall
13:40:54 <mux> kills process according to a provided regexp
13:41:03 <jethr0_> nice
13:41:04 <sjanssen_> sethk: unless the zombie processes are part of SkyNET
13:41:09 <davidhouse> killall was being a little odd because of the screen complexities.
13:41:12 <jethr0_> pkill '*.*.*.*.*'
13:41:13 <mux> goes with pgrep
13:41:16 <sjanssen_> in which case the nukes are coming
13:41:21 <sethk> sjanssen, I admit I didn't consider that possibility  :)
13:41:34 <mux> killall is dangerous because of the sysV semantics
13:41:39 <greenrd> windows has for many years disallowed killing a lot of processes
13:41:56 <mux> un-helpfully provided as killall5 on Linux
13:41:56 <greenrd> linux only disallows killing init
13:42:29 <ihope> How hard would it be to compile Haskell into Unlambda?
13:43:14 <jethr0_> hard?
13:43:23 <jethr0_> hard!?
13:43:33 <ihope> How easy would it be to compile Haskell into Unlambda?
13:43:37 <norpan> hard
13:43:39 <jethr0_> he
13:43:43 <palomer> hard?!
13:43:46 <sjanssen_> ihope: depends on how smart you are
13:43:48 <norpan> HARD
13:43:51 <xerox> ?palomer
13:43:51 <lambdabot> Hrmph, looks like I killed the channel
13:44:20 <norpan> i like the jot language
13:44:42 <jethr0_> ihope: question is how hard it would be to compile haskell into lambda calculus. if that's not too hard for you, then unlambda should be doable
13:44:45 <davidhouse> hey ihope. anyone got any nice words about my interpreter yet?
13:44:47 <davidhouse> :)
13:44:56 <ihope> Hmm...
13:45:15 <ihope> "Woot, now I can run my SMATINY programs!" --me
13:45:24 <davidhouse> yay :) hehe
13:45:42 <jethr0_> i think conversion from lambda calculus to combinator calculus isn't so hard, but i could be wrong :)
13:45:58 <ihope> jethr0_: easy enough.
13:46:18 <ihope> The Unlambda page lists a couple of algorithms, each better than the previous one.
13:47:12 <jethr0_> k, so converting pure scheme into unlambda shouldn't be so hard for example. and pure haskell can't be that far from lambda calculus
13:47:58 <ihope> It shouldn't be too hard to make a "better" IO system in Unlambda.
13:48:21 <ihope> data IO a = IO ((a -> String) -> String) -- this'd work
13:48:38 <davidhouse> what, in general?
13:48:54 <davidhouse> or in the context of an unlambda compilation
13:49:14 <ihope> Um...
13:49:23 <ihope> That would work for Unlambda output.
13:49:39 <davidhouse> riight. i don't know why i thought you meant generally.
13:50:08 * davidhouse has been following the [haskell] thread on the fact that haskell can't fully be described with a lambda calculus
13:50:22 <davidhouse> and so have been thinking about how nice it'd be for it to be properly possible
13:50:52 <ihope> What thread's that?
13:51:31 <sjanssen_> ihope: the tail end of "The values of infinite lists" on -cafe
13:51:37 <davidhouse> the misnomer "The values of infinite lists"
13:51:55 <davidhouse> oh, sorry, -cafe. the lists are pretty unified in my gmail.
13:54:11 <sjanssen_> @ttow
13:54:11 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
13:54:11 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
13:57:32 <vincenz> Cale: ping
13:57:52 <SamB> @zow
13:57:53 <lambdabot> I have accepted Provolone into my life!
13:58:32 <vincenz> @zing
13:58:32 <lambdabot> parse error (possibly incorrect indentation)
13:58:41 <vincenz> @zing
13:58:42 <lambdabot> parse error (possibly incorrect indentation)
13:58:46 <vincenz> hmm
14:00:06 <davidhouse> @help zinf
14:00:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:00:09 <davidhouse> @help zing
14:00:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:01:53 <davidhouse> it's actually rather ironic that theoretically speaking, IO is one of the hardest parts of programming, and yet it's the thing that everyone learns to do first
14:03:12 <ihope> @help zing
14:03:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:03:16 <ihope> @zing foo
14:03:17 <lambdabot> Not in scope: type variable `foo'
14:03:24 <ihope> @zing a -> a
14:03:25 <lambdabot> Not in scope: type variable `a'
14:03:25 <lambdabot>  
14:03:25 <lambdabot> <interactive>:1:5: Not in scope: type variable `a'
14:04:03 <ihope> @zing forall a. a
14:04:04 <lambdabot> *
14:04:10 <sjanssen_> zing == kind?
14:04:15 <ihope> :-)
14:04:18 <sjanssen_> @zing (,)
14:04:19 <lambdabot> * -> * -> *
14:04:26 <ihope> @zing Int#
14:04:27 <lambdabot> Not in scope: type constructor or class `Int#'
14:05:04 <xerox> ?kind GHC.Prim.Int#
14:05:05 <lambdabot> #
14:05:41 <vincenz> anyone know how to work with readerT?
14:05:51 <ihope> @index ReaderT
14:05:51 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.Monad.RWS
14:05:56 <xerox> vincenz - what's the trouble?
14:06:03 <vincenz> runReaderT takes no ReaderT s m a
14:06:28 <davidhouse> @hoogle runReaderT
14:06:28 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
14:06:33 <vincenz> http://rafb.net/paste/results/I0KuCf72.html
14:06:39 <vincenz> I don't know how to define runTyperT
14:07:07 <xerox> ?type runReaderT
14:07:08 <lambdabot> forall a (m :: * -> *) r. ReaderT r m a -> r -> m a
14:07:26 <vincenz> heh
14:07:29 <vincenz> the docs are off then
14:07:37 <davidhouse> which docs?
14:07:50 <xerox> ?docs Control.Monad.Reader
14:07:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
14:08:33 <vincenz>   evalStateT (runReaderT (unTyperT action) ct) TyperState{substitutions = M.empty, freeTyvar = []}
14:08:38 <davidhouse> huh. yes they are.
14:08:42 <xerox> The documentation is correct.
14:09:00 <dcoutts> dons, I'm tring to understand the loopU stuff and I think I've got it. I've implemented mapAccumL and reimplemented mapIndex using it.
14:09:01 <vincenz> where is the ReaderT r m a bit?
14:09:05 <vincenz> in runReaderT
14:09:11 <dcoutts> dons, now I want a loopD :-)
14:09:18 <xerox> In the scope, vincenz.
14:09:26 <vincenz> ?
14:09:27 <davidhouse> oh yeah, of course they are.
14:09:48 <vincenz> runReaderT :: (r -> m a)
14:09:49 <SyntaxNinja> Lemmih: thanks for catching the cabal question on -cafe.
14:09:50 <xerox> Consider this, newtype StateT s m a = StateT { runStateT :: (s -> m (a, s)) }.
14:09:54 <davidhouse> newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }
14:09:56 <vincenz> oh!
14:09:57 <ihope> mfix x = mfix x >>= x -- this won't work very well, will it?
14:10:00 <vincenz> thx
14:10:08 <dcoutts> dons, so we can fuse all the 'r' variants, foldr, scanr, mapAccumR, etc.
14:11:02 <vincenz> evalTyperT ct action =  evalStateT (runReaderT (runTyperT action) ct) TyperState{substitutions = M.empty, freeTyvar = []}
14:11:25 <vincenz> @pl evalTyperT ct action =  evalStateT (runReaderT (runTyperT action) ct) TyperState{substitutions = M.empty, freeTyvar = []}
14:11:26 <lambdabot> (line 1, column 81):
14:11:26 <lambdabot> unexpected "{"
14:11:26 <lambdabot> expecting variable, "(", operator or end of input
14:11:41 <vincenz> @pl evalTyperT ct action =  evalStateT (runReaderT (runTyperT action) ct) TyperState
14:11:41 <lambdabot> evalTyperT = flip flip TyperState . (evalStateT .) . flip (runReaderT . runTyperT)
14:11:46 <vincenz> yucky
14:13:06 <davidhouse> wow, you're really into complicated monad stacks, aren't you.
14:13:22 <vincenz> yeah
14:13:31 <vincenz> ok time to haskellgolf
14:13:35 <vincenz> endless list
14:13:53 <vincenz> ["a", "b"..., "z", "a'", ..."z'", "a''"...]
14:14:32 <vincenz> aha
14:15:09 <davidhouse> > ["a".."z"]
14:15:10 <lambdabot>  add an instance declaration for (Enum [Char])
14:15:10 <lambdabot>   In an arithmetic sequence: ["a" .. "z"]
14:15:10 <lambdabot>   In the definition of `kje': kje = ["a" .. "z"]
14:15:13 <davidhouse> didn't think so.
14:15:17 <vincenz> > take 1 . drop 1000 . concat . iterate (map (++"'")) $ ["a".."z"] 
14:15:17 <lambdabot>  add an instance declaration for (Enum [Char])
14:15:17 <lambdabot>   In an arithmetic sequence: ["a" .. "z"]
14:15:19 <vincenz> like that
14:15:21 <davidhouse> vincenz: i presume you mean 'a'..'z'
14:15:23 <vincenz> except I need strings
14:15:29 <davidhouse> map return them then.
14:15:36 <vincenz> erm
14:15:59 <davidhouse> > map return ['a'..'i']
14:16:00 <lambdabot>  add an instance declaration for (Show (m Char))
14:16:09 <davidhouse> > map (:[]) ['a'..'i']
14:16:09 <lambdabot> ["a","b","c","d","e","f","g","h","i"]
14:16:17 <vincenz> > take 1 . drop 1000 . concat . iterate (map (++"'")) . map (:[])  $ ['a'..'z'] 
14:16:18 <lambdabot> ["m''''''''''''''''''''''''''''''''''''''"]
14:16:30 <vincenz> \o/
14:16:33 <davidhouse> nice.
14:16:43 <vincenz> > take 26 . drop 100 . concat . iterate (map (++"'")) . map (:[])  $ ['a'..'z'] 
14:16:44 <lambdabot> ["w'''","x'''","y'''","z'''","a''''","b''''","c''''","d''''","e''''","f''''","g''''","h''''","i''''","j''''","k''''","l''''","m''''","n''''","o''''","p''''","q''''","r''''","s''''","t''''","u''''","
14:16:44 <lambdabot> v''''"]
14:16:51 <bolrod> eh?
14:16:59 <vincenz> > take 52 . concat . iterate (map (++"'")) . map (:[])  $ ['a'..'z'] 
14:17:00 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","a'","b'","c'","d'","e'","f'","g'","h'","i'","j'","k'","l'","m'","n'","o'","p'","q'","r'","s'"
14:17:00 <lambdabot> ,"t'","u'","v'","w'","x'","y'","z'"]
14:17:11 <vincenz> perfect
14:17:22 <xerox> fix ((['a'..'z'] ++) . ((: "'") =<<))
14:17:37 <vincenz> > take 30 $ fix ((['a'..'z'] ++) . ((: "'") =<<))
14:17:37 <lambdabot> "abcdefghijklmnopqrstuvwxyza'b'"
14:17:41 <vincenz> ooh
14:17:42 <davidhouse> show off.
14:17:54 <vincenz> which is better?
14:18:08 <bolrod> what should it do :)
14:18:22 <vincenz> erm wait
14:18:24 <vincenz> xerox: that won't do
14:18:28 <vincenz> xerox: I need individual strings
14:18:33 <xerox> Oh, right.
14:18:46 <davidhouse> bolrod, the infinite [String] "a", "b", "c", ... "a'", "b'", "c'", ... "a''", "b''", ..
14:19:04 <xerox> fix ((map return ['a'..'z'] ++) . map (++ "'"))
14:19:10 <xerox> :-)
14:19:13 <davidhouse> xerox, explain yours, if you please.
14:19:19 <vincenz> > take 30 $ fix ((map return ['a'..'z'] ++) . map (++ "'"))
14:19:19 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","a'","b'","c'","d'"]
14:19:35 <vincenz> yeah
14:19:38 <xerox> The explanation is left as an exercise for the reader.
14:19:40 <vincenz> I have to admit that mine is clearer in nature
14:19:44 <davidhouse> pah.
14:19:50 * xerox excuses
14:19:59 <davidhouse> you pl'd, didn't you.
14:20:09 <vincenz> pl won't fix
14:20:15 <xerox> davidhouse - no it's simple in fact.
14:20:26 <vincenz> explain it
14:20:48 <vincenz> @type ((map return ['a'..'z'] ++) . map (++ "'"))
14:20:49 <lambdabot> [[Char]] -> [[Char]]
14:21:01 <vincenz> @type fix
14:21:02 <lambdabot> forall a. (a -> a) -> a
14:21:07 <vincenz> why no concat
14:21:11 <vincenz> oh nm
14:21:34 <davidhouse> xerox, i'm almost there. why don't the first lot have apostrophes, though?
14:21:50 * palomer loves fi
14:21:50 <palomer> x
14:21:51 <vincenz> map return -> makes them strings
14:21:53 <xerox> fix (f . g)   ===   let xs = f (g xs) in xs
14:22:28 <vincenz> xerox: which is lazier
14:23:10 <vincenz> > take 10 . drop 20 .   let vars = concat . iterate (map (++"'")) $ map return ['a'..'z']
14:23:10 <lambdabot>  parse error on input `}'
14:23:15 <vincenz> > take 10 . drop 20 . concat . iterate (map (++"'")) $ map return ['a'..'z']
14:23:16 <lambdabot> ["u","v","w","x","y","z","a'","b'","c'","d'"]
14:23:29 <davidhouse> > take 20 $ let xs = (map (:[]) ['a'..'z'] ++) (map (++ "'")) xs in xs
14:23:30 <lambdabot> Couldn't match `[[Char]]' against `t -> t1'
14:23:36 <xerox> davidhouse - sorry?
14:23:56 <xerox> davidhouse - the last xs is enclosed in the paren.
14:24:23 <davidhouse> > take 20 $ let xs = (map (:[]) ['a'..'z'] ++) (map (++ "'") xs) in xs
14:24:24 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t"]
14:24:33 <vincenz> so
14:25:02 <vincenz> concat . iterate f $ map g xs == fix ((map g xs ++) . (map f))
14:25:12 <davidhouse> > take 20 $ let xs = map (:[]) ['a'..'z'] ++ map (++ "'") xs in xs
14:25:13 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t"]
14:25:45 <davidhouse> xerox, i don't quite get why the first alphabet doesn't have an apostrophe after each letter
14:25:55 <vincenz> davidhouse: ah I see it now
14:26:04 <vincenz>  map (:[]) ['a'..'z'] ++ then do te rest
14:26:09 <xerox> Yes.
14:26:27 <xerox> That's "f".
14:26:53 <davidhouse> let's save some ink by defining abet = map (:[]) ['a'..'z'], and apostrophe = (++ "'")
14:27:12 <davidhouse> so we have let xs = abet ++ map apostrophe xs in xs
14:27:21 <xerox> Yes.
14:27:29 <vincenz> just like
14:27:33 <vincenz> let xs = 1:f xs
14:27:41 <vincenz> except you have multiple elements instead of 1
14:27:41 <davidhouse> which expands to abet ++ map apostrophe (abet ++ map apostrophe (abet ++ ...
14:27:58 <davidhouse> aha!.
14:28:00 * davidhouse gets it.
14:28:02 <xerox> (-:
14:28:08 <xerox> Great!
14:28:09 <vincenz> 4\o/
14:29:52 <sjanssen_> @yhjulwwiefzojcbxybbruweejw
14:29:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
14:33:39 <vincenz> \_o_/
14:34:23 <araujo> Hi!
14:34:30 <vincenz> Hi!
14:34:42 <bolrod> @index fix
14:34:42 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:34:49 * vincenz does a dirty stickfigure:  /--o__o
14:35:28 <bolrod> > take 50 $ concat $ map (\x -> map (:x) ['a'..'z'])  (iterate ('\'':) [])
14:35:29 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","a'","b'","c'","d'","e'","f'","g'","h'","i'","j'","k'","l'","m'","n'","o'","p'","q'","r'","s'"
14:35:29 <lambdabot> ,"t'","u'","v'","w'","x'"]
14:35:37 <bolrod> hm :)
14:36:01 <vincenz> bolrod: concat $ map = concatMap
14:36:06 <bolrod> ahyes
14:36:16 <bolrod> > take 50 $ concatMap (\x -> map (:x) ['a'..'z'])  (iterate ('\'':) [])
14:36:17 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","a'","b'","c'","d'","e'","f'","g'","h'","i'","j'","k'","l'","m'","n'","o'","p'","q'","r'","s'"
14:36:17 <lambdabot> ,"t'","u'","v'","w'","x'"]
14:36:18 <bolrod> that then :P
14:36:38 <vincenz> and do
14:36:42 <vincenz> take 10 . drop 255
14:36:53 <bolrod> > take 10 . drop 500 $ concatMap (\x -> map (:x) ['a'..'z'])  (iterate ('\'':) [])
14:36:54 <lambdabot> ["g'''''''''''''''''''","h'''''''''''''''''''","i'''''''''''''''''''","j'''''''''''''''''''","k'''''''''''''''''''","l'''''''''''''''''''","m'''''''''''''''''''","n'''''''''''''''''''","o''''''''''''
14:36:54 <lambdabot> '''''''","p'''''''''''''''''''"]
14:36:59 <bolrod> :)
14:37:03 <vincenz> nono... gotta be multiple of 26 minus number < 10
14:37:19 <bolrod> > take 10 . drop 255 $ concatMap (\x -> map (:x) ['a'..'z'])  (iterate ('\'':) [])
14:37:20 <lambdabot> ["v'''''''''","w'''''''''","x'''''''''","y'''''''''","z'''''''''","a''''''''''","b''''''''''","c''''''''''","d''''''''''","e''''''''''"]
14:37:26 <bolrod> ?
14:37:27 <[2]alex> @seen musasabi
14:37:27 <lambdabot> musasabi is in #haskell, #haskell-blah and #haskell-overflow. I don't know when musasabi last spoke.
14:37:40 <vincenz> alright
14:37:42 <vincenz> time to get some coke
14:37:44 <vincenz> then write my unifier
14:37:52 <vincenz> and normalizer
14:38:06 <bolrod> ^.0
14:39:46 <vincenz> it's great !
14:39:52 <bolrod> what?
14:40:01 <vincenz> my typerT monad is completely undependent of my code
14:40:26 <vincenz> I can reuse it anywhere I need a typechecker
14:40:39 <xerox> Monads improve composability!
14:41:35 <vincenz> all I have to do is stick in unifier rules
14:42:12 <xerox> Just FFI-call prolog :-P
14:42:42 <davidhouse> i'm trying to get around the homogeneity of lists. i was advised that an existential might be a nice way, but i'm wondering to what extent i need to do this
14:43:01 <davidhouse> e.g. can i have type Program = forall s. Step s => [s]
14:43:21 <xerox> davidhouse - I would suggest you to investigate HList.
14:43:24 <davidhouse> or do i need to write data StepHide = forall s. Step s => SH s, then type Program = [StepHide]
14:43:41 <sjanssen_> davidhouse: you need to write StepHide
14:43:43 <xerox> I suspect the latter is the right one.
14:43:55 <davidhouse> hmm.
14:44:00 <davidhouse> then something like HList may be more elegant.
14:44:12 * xerox nods
14:44:13 <damg__> is there a performance difference between func y z = z + z where z = (func2 y) and func y z = (func2 y) + (func2 y) . I mean, how does the compiler unify in both cases?
14:44:27 <sjanssen_> davidhouse: what is your ultimate goal?
14:44:57 <sjanssen_> damg__: a Haskell compiler is allowed to turn the second in to the first, but GHC usually won't
14:45:10 <xerox> damg__ - CSE is performed by GHC, but explicit sharing makes it easier for the compiler to understand your idea.
14:45:19 <davidhouse> sjanssen_: see my email to [haskell], "Writing an extensible interpreter"
14:45:27 <davidhouse> i basically want an extensible datatype
14:45:33 <davidhouse> let me expand.
14:45:53 <davidhouse> i'm writing an interpreter for ihope's "smatiny" automaton language. at the moment it's not very extensible. i'd like to change this.
14:45:57 <damg__> ok, will in both cases the computation of the z/func2-clause done once or twice?
14:46:19 <davidhouse> the current process is String -> ADT, then ADT -> String (the output).
14:46:24 <sjanssen_> first case once, second case once or twice (depending on the compiler and it's flags)
14:46:37 <ihope> davidhouse: input would be nice :-)
14:46:43 <damg__> ok, thanks :)
14:47:02 <davidhouse> i'd like to keep the ADT at all possible. but the interpreter need to be extensible, and that means i need to be able to add new modules to my program to add new commands.
14:47:14 <davidhouse> and that means a more flexible datatype.
14:47:28 <davidhouse> hmm... unless i constructed the datatype with some metacode.
14:47:41 <davidhouse> ihope, specify it for me, and i'll include it in 1.1 :)
14:47:46 <hyrax42> in IO, is it possible to change where getChar/getContents get their input from
14:47:55 <hyrax42> without using the hGet.. variants?
14:47:57 <sjanssen_> davidhouse: could you represent commands as functions from State -> State?
14:48:01 <davidhouse> hyrax42: use hGetChar etc
14:48:20 <hyrax42> just annoying to pass handle always
14:48:27 <ihope> davidhouse: X. Input a character, then swap Y with it.
14:48:27 <davidhouse> sjanssen_: well, commands are executed in my Smatiny monad.
14:48:28 <mux> have a Reader monad then
14:48:35 <sjanssen_> hyrax42: you could potentially use platform specific stuff to change what the filedescriptors point to, but that's probably not a good idea
14:48:40 <hyrax42> ah
14:48:41 <davidhouse> hyrax42: then write your own wrappers
14:48:45 <mux> makes it extremely convenient to avoid passing handle around
14:48:58 <davidhouse> sjanssen_: but i'd quite like to keep the ADT.
14:49:03 <hyrax42> kk
14:49:05 <hyrax42> thanks
14:49:13 <davidhouse> however, this is looking like the Only Sane Option.
14:49:23 <xerox> davidhouse - wouldn't you better go for something like a Map to keep the commands "list" ?
14:49:44 <davidhouse> xerox, well, it is actually a Map, but it's the same problem so i thought i'd talk about lists instead
14:49:55 <davidhouse> ah. actually that would alleviate HList, no?
14:50:08 <sjanssen_> davidhouse: keep the ADT, but add one more thing: data Cmd = ... | ExtendedCommand (MyMonad ())
14:50:22 <davidhouse> hmm.
14:50:30 <xerox> davidhouse - do you need new types for your commands at runtime?
14:50:34 <davidhouse> well, that's not a great solution.
14:50:54 <davidhouse> xerox, i'd like an ADT describing the commands. not necessarily one type for each.
14:51:11 <davidhouse> xerox, but if I use a normal ADT, then it's not extensible, and i can't freely add new commands
14:51:22 <vincenz> boo
14:51:22 <xerox> ADT =~= AST ?
14:51:34 <davidhouse> abstract datatype. "data X = ..."
14:51:43 <davidhouse> or algebraic, whatever.
14:51:46 <xerox> davidhouse - what are commands?
14:52:25 <davidhouse> xerox, this is an automaton language. its input are a bunch of lines like "1. Output this block's position" or "71. Swap 152 with 56"
14:52:51 <davidhouse> so at the moment i have data Step = Nop | Output | Swap StepNum StepNum
14:53:00 <davidhouse> this is lovely and elegant, but not open.
14:53:21 <xerox> Implement `eval' (-:
14:53:56 <davidhouse> ypu misunderstand.
14:54:00 <davidhouse> *you
14:54:12 <davidhouse> i have a parser that takes an input and spits out a [Step].
14:54:20 <xerox> davidhouse - New commands are defined in terms of old commands, or what else?
14:54:21 <davidhouse> (or Map StepNum Step, to be precise)
14:54:38 <davidhouse> no, new commands are completely new, and need their own parsers and evallers.
14:54:56 <davidhouse> evallers have type Smatiny a
14:54:58 <sjanssen_> davidhouse: I think you want existentials
14:55:23 * jethr0_ thinks you want lisp-like read macros...
14:55:39 <vincenz> jethr0_: I think like-lisp ones
14:55:53 <palomer> can't read macros be fudged with template haskell?
14:55:55 <xerox> davidhouse - is there some common syntax underneath?
14:56:16 <jethr0_> TH is compile-time only
14:56:30 <vincenz> palomer: nearly done \o/
14:56:34 <sjanssen_> davidhouse: if you design your functions carefully, you can minimize the number of times you have to explicitly write your existential wrapper
14:56:39 <vincenz> palomer: got some hints on normalization?
14:56:43 <davidhouse> xerox, not really
14:57:07 <xerox> davidhouse - I miss how you are going to specify how new commands work.
14:57:49 <davidhouse> okay.
14:58:14 <davidhouse> currently there's a command "Do Nothing" which is represented by the Nop constructor.
14:58:38 <davidhouse> the evaller for this is modify (first (+1)), which simply increments the step number and does nothing to the program itself.
14:59:10 <palomer> vincenz: normalization is trivial, really
14:59:20 <palomer> vincenz: if you want to be fancy, you can define a Normalize typeclass
14:59:35 <davidhouse> there's another command, Output this block's position. this is represented by the Output constructor.
14:59:50 <palomer> vincenz: you can also simply make your datatypes instances of Functor and simply apply a map, then extract the computation with a function
14:59:51 <xerox> davidhouse - Does it mean you specify new commands' semantics in Haskell?  If it is so, hs-plugins to the rescue!
15:00:06 <palomer> f m a -> m f a
15:00:19 <vincenz> palomer: I'm missing context
15:00:27 <palomer> ask away
15:00:40 <xerox> data Command = Command { name :: String, code :: String } -- or directly the parser if you want, instead of the name.  Then, `eval` the code.
15:00:42 <vincenz> I mean with what you're saying
15:00:47 <vincenz> let's talk in #oasis
15:01:48 <davidhouse> xerox, hmm, that _is_ a novel approach :)
15:02:01 * xerox boings cheerfully
15:04:05 <davidhouse> huh, it seems Hinze and LÃ¶he have done some work on exactly what i need -- extensible datatypes
15:04:24 <xerox> davidhouse - and what are you going to plug in your extensible atatype?
15:05:22 <davidhouse> say someone wants to write a new command
15:05:30 <davidhouse> then they write a parser for it, and write an evaller.
15:05:49 <davidhouse> then they extend the open datatype Step with a new constructor representing theirs
15:06:08 <xerox> I mean, how does one specify the evaller.
15:06:11 <davidhouse> and extend the parse and eval functions to deal with their new constructor.
15:06:38 <davidhouse> one writes it.
15:06:46 <xerox> ...in which language?
15:06:46 <davidhouse> evallers are functions in State
15:07:21 <xerox> Then you need means to evaluate Haskell code at runtime nevertheless.
15:07:24 <davidhouse> where the state is a pair of the current step number and the program itself (i.e. (StepNum, [Step])
15:07:47 <davidhouse> no i don't.
15:07:56 <davidhouse> i have a parser that builds a [Step] from the input.
15:07:57 * xerox scratches head.
15:08:17 <xerox> How can you extend the parser code at runtime without evaluating new code?
15:09:02 <davidhouse> well i'm going to need a bit of metacode anyway to scan the "commands" dir for modules
15:09:16 <xerox> Sorry?
15:09:37 <davidhouse> i have a "commands" dir that contains one module for each command.
15:10:21 <davidhouse> i will write some metacode that scans this dir, finds all the modules, then builds a Main.hs which imports the modules it found
15:10:39 <davidhouse> i don't especially need dynamacism so this can actually happen at compiletime
15:10:42 <xerox> You are building an interpreter okay.
15:10:58 <xerox> Yes, makes sense, I thought you were aiming to something different.
15:11:17 <davidhouse> something different?
15:12:25 <xerox> You run this interpreter, and you say "Computer!  New command `quux', it opens a bottle of sake and gives me a cup.  ==bzzt==> DONE."
15:12:40 <davidhouse> oh.
15:13:08 <davidhouse> well that's essentially what i'm doing, only i'm taking the easy route out and doing it at compiletime :)
15:13:27 <xerox> I think it easy enough to do it at runtime with hs-plugins too.
15:13:33 <Cale> Or just with strings
15:13:43 <xerox> That was what I suggested, yup.
15:13:59 <Cale> at least, if you don't need to hijack Haskell's type system
15:14:18 <xerox> hs-plugins makes sense if you don't want a different EDSL for the interpreter.
15:15:16 <davidhouse> EDSL?
15:15:16 <SamB> why would you need to *hijack* the type system?
15:15:22 <SamB> isn't it usually pretty obliging?
15:15:34 <SamB> EDSL = Embedded Domain Specific Language
15:16:20 <Cale> SamB: I mean, use it for your own new language. It's not obliging in the case where you need to define new types at runtime, or have terms whose types depend on evaluation.
15:16:29 <Cale> (though that latter case can be handled by gadts)
15:21:30 <SamB> oh, yeah, generally I would avoid trying to use the Haskell system to type my own language, unless my language had different *kinds* of value...
15:33:33 * xerox waves ~~ later
15:38:38 <petekaz> Are there any haskell books out there with nice typography?  I just received my copy of Bird's Intro to FP, it's fugly.
15:39:38 <monochrom> I don't know what nice typography means, but it never hurts to check out Hudak's book.
15:40:01 <Cale> nice typography basically means typeset with TeX :)
15:40:08 <petekaz> After a cursory view, I'm also disappointed that it does not explain how laziness impacts the performance of foldl.
15:40:34 <petekaz> Whoever wrote this page: http://en.wikibooks.org/wiki/Programming:Haskell_List_Processing is my hero.
15:41:17 <Cale> that would be me, for the most part
15:41:18 <petekaz> For the life of me, that blurb in the "technical note" should be pounded into everyone learning haskell IMO.
15:41:33 <petekaz> foldl vs foldl'
15:41:42 <petekaz> Well, you are my hero!
15:41:42 <Cale> yeah, it can be important
15:42:59 <petekaz> I think it's incredibly important, especially when learning about laziness.  I guess I have a new criteria for evaluating a haskell book. 
15:44:00 <petekaz> Makes me doubt the usefulness of the rest of the book if it leaves such an important concept out.  What other gotchas is it not telling me.
15:44:19 <Cale> Well, lots of books leave out explicitly dealing with strictness.
15:45:05 <Cale> It's sort of considered a more advanced topic for people who know how to write programs, and want to make them faster.
15:45:38 <Cale> However, we're starting to see people attempt things now where it's not just a speed issue, but whether the program works at all.
15:45:57 <vincenz> woo
15:45:58 <vincenz>   lift = TyperT . lift . lift
15:46:04 <vincenz> it's an elevator!
15:46:06 <Cale> hehe
15:46:19 <bolrod> the foldl1 isn't correct on that wikibooks page
15:46:57 <Cale> it's missing a pair of parens
15:47:00 <SamB> yeah, foldl' is more of a "not crashing" than "optimization" thing, if you ask me
15:47:01 <vincenz> Cale: I'm not certain about something
15:47:03 <petekaz> Well, when I learned about recursion, one of the topics was tail-recursion vs non tail-recursive functions, and how one might blow the stack.  It was a basic thing.  I guess I would have assumed when learning about laziness, a similar comparison would have been made with strictness.
15:47:09 <bolrod> and a base case of 1 element
15:47:13 <vincenz> assume ReaderT
15:47:14 <SamB> especially since lambdabot doesn't time computations ;-)
15:47:17 <bolrod> it'll always error to empty list
15:47:19 <vincenz> now I have a set of actions m a
15:47:25 <vincenz> map doAction listofInputs
15:47:27 <SamB> that is, doesn't report the times
15:47:38 <vincenz> local changeScope . sequence . map doAction $ listofInputs
15:47:49 <vincenz> do I need to do the local changeSchope inside the sequence
15:47:52 <vincenz> or is it fine if I put it ther
15:47:57 <Cale> wait a minute, no
15:48:10 <Cale> it's correct
15:48:15 <Cale> it's just not recursive
15:48:27 <Cale> :)
15:48:28 <vincenz> well the changeScope basically sets an initial scope
15:48:33 <bolrod> oh wait
15:48:36 <vincenz> basically I take all the fnction names
15:48:39 <vincenz> give them each a unique tyvar
15:48:40 <bolrod> its using foldl 
15:48:42 <bolrod> :P
15:48:43 <Cale> right
15:48:44 <vincenz> and then start typechecking
15:48:57 <vincenz>       let pNames = nub . map (declName . unParseDeclaration) $ pDecls
15:48:58 <vincenz>       nVars <- sequence . map (const $ liftM TypeVar $ new) $ pNames
15:49:07 <petekaz> Cale: you should write a whole book.  I'd have faith that I might actually learn something!
15:49:10 <Cale> In fact, I copied and pasted that code from the report, so it'd better be right :)
15:49:21 <bolrod> hehe
15:49:23 <Cale> petekaz: I probably should.
15:49:28 <vincenz> Cale: that referrngto me?
15:49:37 <Cale> vincenz: nope
15:49:48 <vincenz> so nothing you said priorly referred to me
15:50:14 <Cale> sequence . map f = mapM f
15:50:27 <Cale> not until just now
15:50:31 <vincenz> but
15:50:34 <vincenz> do I do local outside of sequence
15:50:39 <vincenz> or do I do it inside each of the f's
15:50:41 <vincenz> for readert
15:50:49 <vincenz> local f . mapM act $ inputs
15:50:57 <vincenz> or mapM (local f act) iniputs
15:51:03 <Cale> same thing
15:51:08 * vincenz whews
15:51:32 <vincenz> except the first is most likely more efficient
15:51:39 <Cale> yeah, probably
15:52:05 <vincenz> okelidokeli
15:52:10 <vincenz> time to test my typechecker :D
15:52:35 <Cale> petekaz: there's a good intuitive rule of thumb to remember about laziness/strictness
15:52:50 * SamB would have thought foldl' was called "fold-ell prime"
15:53:30 * petekaz is waiting for the punchline ...
15:53:35 <Cale> If you're taking lots of data and searching through it for specific data which are interesting to you, or taking a small piece of data and generating a large amount of data, then laziness is what you want.
15:53:38 * monochrom considers "haskell-tick"
15:54:07 <Cale> If you're taking a large amount of data, and using it all to form a small "summary" piece of data, then you generally want strictness.
15:54:27 <vincenz> yeap
15:54:28 <SamB> at least, you want the little piece of data to be strictly evaluated
15:54:43 * petekaz is digesting
15:56:00 <Cale> (Big -> Big) => Lazy, (Big -> Small) by searching => Lazy, (Small -> Big) => Lazy, (Small -> Small) => Doesn't matter. (Big -> Small) (using the whole big structure) => Strict.
15:56:23 <petekaz> Got it.
15:56:38 * petekaz saves to his haskell notes
15:58:01 <vincenz> is there a pretty printer for Show
15:58:08 <petekaz> Does anyone in this channel use haskell in an enterprise for business-like things?  Or is the user base mostly scientific.
15:58:13 <vincenz> TypedProgram {unTypedProgram = Program {unProgram = [TypedDeclaration {unTypedDeclaration = Declaration {declName = "foo", declIterator = 1, declBody = [ParseStm {unParseStm = ExpStm (ParseExp {unParseExp = FunCall "foo" 2})}]}, declType = TypeVar "a"},TypedDeclaration {unTypedDeclaration = Declaration {declName = "foo", declIterator = 2, declBody = [ParseStm {unParseStm = IfThenElse (ParseExp {unParseExp = FunCall "foo" 1}) [ParseStm {unPar
15:58:20 <vincenz> is damn ugly
15:58:39 <Cale> vincenz: I've used Text.PrettyPrint for that
15:58:53 <Cale> petekaz: There have been a few.
15:59:08 <Cale> petekaz: there are people here who write Haskell code for a living
15:59:10 <vincenz> Cale: how do you do it
15:59:46 <Cale> oh, not that
15:59:53 <Cale> Language.Haskell.Pretty
16:00:25 <vincenz> how do you use it?
16:00:28 <vincenz> deriving(Pretty)?
16:01:30 <Cale> make the string into a module somehow
16:01:38 <Cale> (a proper Haskell module)
16:01:48 <Cale> then use Language.Haskell.Parser.parseModule
16:02:15 <Cale> and if all went well, you'll get ParseOk x where x is an HsModule
16:02:30 <Cale> which has an instance of Pretty
16:02:38 <vincenz> :/
16:02:58 * vincenz wishes for deriving(Pretty)
16:03:19 <Cale> or you can just write your own prettyprinter using Text.PrettyPrint
16:03:57 <vincenz> yeah but for most data constructors it should be pretty straightforward
16:04:13 <monochrom> petekaz: I saw someone on the haskell-cafe mailing list: http://www.haskell.org/pipermail/haskell-cafe/2006-May/015681.html
16:06:17 <petekaz> monochrom: thanks.  Maybe I'll ping the author.
16:06:50 * vincenz sends a mail to haskell-cafe
16:08:02 <vincenz> I could possibly do it myself
16:08:05 <vincenz> if I just knew where the deriving Show is done
16:10:21 <vincenz> heh
16:10:23 <vincenz> forgot partial
16:10:23 <vincenz> Copying patch 122 of 14014...Interrupted!
16:35:22 <vincenz> Cale: ping
16:35:27 <Cale> pong
16:35:38 <vincenz> I'm having some errors with kinds and types
16:35:45 <Cale> okay
16:36:51 <vincenz> http://rafb.net/paste/results/RDSUBK69.html
16:37:06 <vincenz> I tried to make my typermonad more general
16:37:12 <vincenz> by abstracting away the type of identifier, tyvar and type
16:38:38 <vincenz> apparently it's separating the i v t passed to TyperMonad and TyperT
16:41:52 <vincenz> suggestions?
16:47:08 <machack666> are there examples of using FPS and Parsec together to make a blazing-fast parser?  I'm trying to figure out if all of the Parsec.Char primitives need to be rewritten in order to accommodate FPS.  Is this possible?
16:47:22 <dons> moin
16:47:26 <vincenz> dons: hello
16:48:26 <machack666> dons: is that a response to my question, and if so, where do I find it? :)
16:48:36 <vincenz> machack666: moin = hello
16:48:49 <machack666> ah. :-)
16:49:20 <dons> i dont think anyone's written a bytestring parsec yet.
16:51:46 <machack666> would that be an approach that is worthwhile, or would it be too much overhead?
16:54:19 <araujo> hello dons 
16:56:04 <vincenz> palomer: ping
16:57:46 <Philippa> dons: I would've thought in that particular case it's not such a big deal to use a toString func and call as normal?
16:58:08 <Philippa> subject to not needing huge amounts of try, anyway
16:58:34 <Philippa> (the reasoning being that the GC can pick up most of the String at any given moment)
16:58:40 <vincenz> small question about a type checker
16:58:43 <vincenz> Basically I unify at times
16:58:55 <vincenz> now palomer told me it's a bad idea
16:59:04 <vincenz> when you unify (Tyvar a) (Tyvar b)
16:59:07 <vincenz> and have a -> b
16:59:12 <vincenz> to have b still in your table
16:59:35 <vincenz> however this has given me a headache
16:59:43 <machack666> the basic problem that I am trying to solve is I would like to use FPS's mmapFile and perform random access parsing of various portions of the file.
16:59:46 <vincenz> imagine: original table: [(b, Int)]
16:59:51 <vincenz> now we unify a and b
16:59:52 <Igloo> What table?
16:59:57 <vincenz> tyvar -> type 
16:59:59 <Philippa> that only works if you eliminate all instances of b in the term straight away
17:00:06 <vincenz> Philippa: my thoughts exactly
17:00:07 <Philippa> (turning them to a instead)
17:00:09 <machack666> But since ByteString is an opaque type, it's not a [tok] term
17:00:13 <vincenz> which is not possible
17:00:19 <Philippa> bear in mind palomer's not got the same objective as you
17:00:27 <Igloo> Do you mean in the substitution?
17:00:29 <vincenz> however
17:00:30 <vincenz> he mentioned that if you don't do this
17:00:35 <Igloo> If so, b shouldn't be in the things you are unifying
17:00:37 <vincenz> you can get circular references
17:00:51 <vincenz> simple example
17:00:55 <vincenz> If xxx then foo else bar
17:01:00 <vincenz> foo and bar haven't been processed yet
17:01:03 <vincenz> so foo :: a
17:01:05 <vincenz> bar :: b
17:01:33 <vincenz> now they need to have the same type
17:01:34 <vincenz> so
17:01:38 <vincenz> unify (Tyvar a) (Tyvar b)
17:01:52 <vincenz> a) we have a -> b in the table but not viceversa
17:01:58 <vincenz> b) we put them both in the table
17:02:00 <vincenz> now if later I do
17:02:07 <vincenz> normalize (Tyvar a) then I will get Tyvar b
17:02:08 <Philippa> that one's easy: always "look through" a type variable when you unify with it
17:02:11 <vincenz> which is circular
17:02:45 <vincenz> yeah but I can think of two circumstances that conflict
17:02:53 <vincenz> assuming neither a or b are defined
17:03:01 <vincenz> I need to add em both and have em point to each other
17:03:08 <Philippa> no, you don't
17:03:21 <vincenz> so just add a -> b
17:03:21 <Philippa> you add 'em both, they do *not* need to point to each other
17:03:26 <Philippa> one of them stays "undefined"
17:03:32 <Philippa> (and you add it, with an Undefined value)
17:03:40 <vincenz> well in that sense, I can just not add it to my table
17:04:03 <vincenz> now the problem is
17:04:05 <vincenz> if I only add a->b
17:04:06 <Philippa> that loses the knowledge that you "know of it, just not what it is"
17:04:10 <vincenz> and then later unify b with Int
17:04:15 <vincenz> I need to look through my entire table
17:04:20 <vincenz> to see if anything else has b inside of it
17:04:25 <vincenz> in this case a points to b
17:04:29 <vincenz> so a should point to int
17:04:29 <Philippa> laziness is your friend
17:04:33 <Philippa> do that when you read a :-)
17:04:49 <vincenz> aka when I normalize a?
17:05:05 <vincenz> yeah
17:05:08 <vincenz> but now take the opposite
17:05:10 <Philippa> I'm not used to 'normalize' as a term here. When you look up what a refers to
17:05:10 <vincenz> a -> b in table
17:05:18 <vincenz> and we unify a with Int
17:05:29 <vincenz> hmm
17:05:32 <vincenz> just chain the unification I guess
17:05:57 <vincenz> Philippa: normalizing comes from the fact that when you do something like
17:06:01 <vincenz> delta <- newTyvar
17:06:09 <vincenz> unify alpha (beta ~> delta)
17:06:15 <vincenz> return delta... just returns the tyvar
17:06:17 <vincenz> so insteand
17:06:18 <vincenz> normalize delta
17:06:43 <Philippa> I'm not sure I follow
17:06:48 <vincenz> but I guess it's a moot point
17:06:55 <vincenz> I looked at palomer's stuff
17:06:57 <vincenz> he used normalization
17:07:01 <Philippa> it's the word that doesn't seem familiar
17:07:02 <Philippa> heh
17:07:07 <vincenz> LambdaApply function argument
17:07:19 <vincenz> alpha <- typecheck argument
17:07:36 <vincenz> beta <- typecheck function
17:07:44 <vincenz> newTyvar delta
17:07:50 <vincenz> unify alpha (beta ~> delta)
17:07:52 <vincenz> normalize delta
17:08:15 <vincenz> if function (beta) is of type Int -> Int
17:08:19 <Philippa> having just checked my old code, it normalises both vars before proceeding with unification
17:08:40 <vincenz> mind if I take a look?
17:08:59 <Philippa> er... yes actually, the code's crap :-) I ported it from Cardelli's tutorial paper
17:09:30 <vincenz> got a linky
17:10:28 <vincenz> on a sidenote, I tried to generalize my typermonad
17:10:33 <vincenz> but I got some serious monadic type erros
17:10:34 <vincenz> http://rafb.net/paste/results/i4PJ7w23.html
17:11:12 <Philippa> nope, dump "cardelli polymorphic type checking" into a search engine and you'll prolly find it though
17:11:53 <vincenz> alright
17:11:54 <vincenz> thx
17:12:44 <vincenz> what language is that? tiger?
17:13:11 <Philippa> heh. His code's in Modula-2
17:13:12 <palomer> eh?
17:13:27 <palomer> with references?
17:13:29 <palomer> that just makes it faster
17:13:35 <palomer> the lookup table becomes the heap
17:13:52 <Philippa> but it's also a humungous pain in the arse for pretty-printing
17:14:00 <palomer> might as well use a [(String,Type)]
17:14:07 <palomer> Philippa: how so?
17:14:17 <Philippa> you have to do it in the same monad
17:14:45 <Philippa> having an actual data structure in your hand means you can drop it back out to pure code if you want
17:14:46 <vincenz> palomer: hello!
17:15:11 <Philippa> granted you can build the substitution as a Map afterwards if you'd rather
17:15:14 <palomer> ah, righto
17:15:25 <palomer> right, there's _no_ reason to use ST if you don't care about performance
17:15:41 <vincenz> Philippa, Igloo: feel free to join #oasis
17:15:52 <vincenz> at times it feels like haskell away from haskell - newbies
17:16:32 <palomer> anyways, getting back to vincenz previous question
17:16:42 <palomer> he wants his unifier to have variables in the codomain which are in the domain
17:16:50 <palomer> (which is what happens with ST)
17:16:55 <palomer> this is a bad idea
17:17:06 <palomer> because if you screw up, you'll have circular references and you won't know why
17:17:15 <Philippa> normalise both vars before proceeding with unification. It works.
17:17:34 <palomer> ok, what exactly is the issue here?
17:18:02 <Philippa> AFAIC, the issue is that I'm expecting phone calls tomorrow and need to take my housemate to the doc and thus should go to bed :-)
17:33:42 <dons> wow, i knew there was an easier way to get a phd. "Call now to receive diploma in 2 weeks". 4 years seems like overkill ;)
17:34:45 <vincenz> dons: :)
17:35:28 <cyyoung> not as easy as all that: if you want good recs for postgraduate studies it'll take three weeks
17:36:11 <mux> dons: hey
17:45:13 <araujo> :-P
17:46:33 <dons> @join #globus
17:46:43 <dons> @seen morans
17:46:43 <lambdabot> morans is in #globus, #haskell and #darcs. I last heard morans speak 4 hours, 44 minutes and 12 seconds ago.
17:46:55 <dons> morans: you wanted a lambdabot?
17:46:58 <dons> hey araujo 
17:47:07 <mux> dons: saw my message?
17:47:18 <dons> oh, hang on.
17:47:32 <araujo> dons, how your code going? :-)
17:48:39 <mux> @karma dons
17:48:39 <lambdabot> dons has a karma of 35
17:48:46 <mux> @karma lambdabot 
17:48:46 <lambdabot> lambdabot has a karma of 12
17:49:53 <mux> lambdabot deserves more karma
17:50:02 <dons> she's hard working, with little pay.
17:50:07 <dons> as her logo suggests
17:50:18 <mux> heh
17:52:04 <dons> there's some advantage to living in the antipodes. every morning i wake up with patches from people who were busily working while i was sleeping. its like birthday presents!
17:52:13 <mux> yeah that's nice
17:52:16 <araujo> haha
17:52:48 <araujo> dons, Santa visits you every night? :-)
17:53:12 <dons> in a way :)
17:53:50 * mux darcs pull's lambdabot
17:54:24 <mux> No remote changes to pull in!
17:54:34 <mux> dons: get back to work! :-)
17:55:47 <Pseudonym> There's a disadvantage.  You get up in the morning and there's ALREADY stuff for you to do.
17:59:11 <vincenz> Pseudonym: all the more reason to get up
18:01:33 <Pseudonym> It's all right for you.  Your job doesn't make you feel like a traitor.
18:01:59 <Pseudonym> Actually, that's not _entirely_ true in my case.
18:02:15 <mux> ah, 16 patches for FPS
18:02:45 <Pseudonym> Anyone here ever looked into smoothed particle hydrodynamics, BTW?
18:02:54 <Pseudonym> Or related methods (e.g. RKPM).
18:03:43 <vincenz> dum dum dum
18:05:23 <hyrax42> do we know which projects were accepted for soc
18:08:14 * palomer slaps google
18:08:35 <vincenz> palomer: any idea on how to handle stuff like
18:08:39 <vincenz> data X = A | B | C
18:09:09 <RyanT5000> anyone know when we can expect to see SoC choices?
18:09:19 <palomer> vincenz: you want to pattern match?
18:09:25 * vincenz is thinking adding TyCons "X" and then have in my context "A" -> TyCons "X"
18:09:33 <vincenz> palomer: only on function calls
18:09:49 <palomer> yes, A is of type X
18:10:01 <vincenz> alright
18:10:03 <vincenz> seems trivial enough
18:10:18 <palomer> nested pattern matching is a little trickier
18:10:23 <dons> what's the time on the west coast? 6pm?
18:10:31 <vincenz> dons: yep
18:10:31 <palomer> btw, I don't think anyone learns this stuff from a textbook
18:10:37 <vincenz> palomer: good :)
18:10:43 <dons> i think things are running a little late, but not too late.
18:10:45 <vincenz> palomer: I haven't read anything on typesystems
18:11:01 <vincenz> palomer: you were a great help when I saw one needs "unify" and "normalize" the rest now cleanly falls into place
18:11:33 <vincenz> was rather funny, I was missing a stupid check
18:11:45 <vincenz> and it would hang when unifying Tyvar "a" with Tyvar "a"
18:12:10 * vincenz snickers
18:12:17 <palomer> vincenz: the equality check? it's in my unify function
18:12:23 <vincenz> yeah I added it
18:12:48 <vincenz> here is my current relevant code
18:12:48 <vincenz> http://rafb.net/paste/results/ONbZrX80.html
18:14:07 <palomer> vincenz: you only unify once?
18:14:13 <vincenz> hmm?
18:14:13 <palomer> err
18:14:15 <palomer> normalize once
18:14:18 <RyanT5000> is there a way to have nontypes in your type signature? kind of like having a template that takes an int in C++
18:14:19 <palomer> in the unifier function
18:14:23 <vincenz> palomer: it's recursive
18:14:27 <cyyoung> is it possible to define a type of exclusively prime numbers other than by analogy with this example of a natural numbers type in the hudak tutorial: http://www.haskell.org/tutorial/moretypes.html?
18:15:03 <palomer> vincenz: it seems you only call normalizer once inside unifier
18:15:10 <vincenz> oh
18:15:12 <vincenz> yes
18:15:23 <vincenz> palomer: well I normalize both inputs
18:15:29 <palomer> vincenz: and you don't have a case when you're trying to unify things like (a->b) with (c -> d)
18:15:37 <palomer> vincenz: right, but you need to constantly unify
18:15:39 <palomer> err
18:15:40 <vincenz> palomer: I dono't have function types
18:15:40 <palomer> normalize
18:15:48 <palomer> you have no type constructors?
18:15:53 <vincenz> nopr
18:15:56 <palomer> gotcha
18:16:04 <palomer> so you only have tyvars?
18:16:07 <vincenz> yep
18:16:11 <vincenz> now I'm add TyCons
18:16:20 <vincenz> but type constructors take no args
18:16:30 <palomer> like Int and Bool
18:16:34 <vincenz> well
18:16:39 <vincenz> like data X = A | B | C
18:16:50 <palomer> yeah
18:16:53 <vincenz> why, what's the issue with typeconstructors with arguments
18:17:25 <palomer> say you have unify (a -> b) ((b -> b) -> b)
18:17:29 <palomer> err
18:17:31 <palomer> say you have unify (a -> b) ((b -> b) -> a)
18:17:47 <palomer> so you start and you get the substitution a |-> b -> b
18:17:58 <palomer> if you don't renormalize b then you're screwed
18:18:07 <vincenz> you mean renormalize a
18:18:15 <palomer> nono, b
18:18:19 <vincenz> erm no
18:18:24 <vincenz> I'm replacing a to point at b->b
18:18:29 <palomer> right
18:18:32 <vincenz> so renormalize a
18:18:37 <palomer> and then you'll apply the substitution b |-> a
18:18:44 <palomer> right
18:18:52 <vincenz> which means I have to renormalize a
18:18:55 <palomer> righto
18:19:01 <vincenz> don't get me confused :)
18:19:04 <palomer> these are the kinds of bugs that my method would catch
18:19:23 <vincenz> well I have it in my mind now
18:19:24 <vincenz> thx
18:19:27 <palomer> np
18:19:30 <vincenz> but for the moment
18:19:32 <vincenz> simple datacons
18:19:34 <vincenz> with no args
18:19:47 <vincenz> I don't think my typesystem will need more than that
18:19:57 <vincenz> and most likely I will only need one dataconst
18:20:15 <vincenz> it's just nice to have a boundedset
18:20:19 <Igloo> What type errors are you hoping to catch?
18:20:39 * palomer had to split up his 20 line expression in c++ :(
18:20:45 <palomer> I was so proud of it!
18:31:40 * palomer slaps google againn
18:31:43 <palomer> s/again/againn
18:32:11 <RyanT5000> palomer: you waiting for your SoC result too?
18:32:44 <palomer> yeah
18:32:47 <palomer> it's killing me
18:32:50 <palomer> though I know I won't get it
18:32:59 <RyanT5000> why's that?
18:33:23 <SamB> RyanT5000: because it is easier than thinking you might and being disappointed?
18:33:42 <RyanT5000> SamB: a trick i have yet to learn
18:34:15 <SamB> also, the odds are slim
18:34:41 <RyanT5000> it is true, but saying "i know i won't get it" to me implies that he has some reason to believe it besides the odds ;)
18:35:31 <vincenz> RyanT5000: no it's hoping you don't screw your karma
18:35:38 <vincenz> by saying you will get in
18:35:43 <SamB> maybe he does not believe himself to be one of the best of the best?
18:36:25 <RyanT5000> all good reasons :)
18:36:41 <vincenz> regarding data constructors
18:36:45 <vincenz> I take it you can't have a
18:36:54 <palomer> because I took to long to respond to the mentor's comments
18:36:57 <Excedrin> his project was, "Enabling automatic spyware downloads from Google search results"
18:36:59 <vincenz> data Plop = Foo {unFoo :: Int} | Bar {unBar :: String}
18:37:27 <RyanT5000> well, palomer, i hope you get in, provided you don't take a slot from me ;)
18:37:45 <palomer> s/mentors/mentor's
18:38:47 <dcoutts> @seen dons
18:38:48 <lambdabot> dons is in #Haskell.se, #haskell-overflow and #haskell. I last heard dons speak 28 minutes and 4 seconds ago.
18:39:03 <vincenz> dcoutts: still up, just up?
18:39:14 <dcoutts> just up, can't sleep
18:39:17 <vincenz> :/
18:39:46 * dcoutts can't sleep due to thinking about array fusion
18:39:47 * vincenz shouts at his parser
18:40:07 <dons> yo
18:40:15 <vincenz> maybe using parsec wasn't the brighest idea
18:40:30 * dcoutts ponders if one could do list or array fusion via partial evaluation
18:40:33 <dcoutts> hia dons 
18:44:57 <Daveman> pugs++
18:44:59 <dons> what we'd need to do is work out how to do the lazy map using loopU on the chunks, and some list loop  /build on the spine of the list.
18:46:14 <mansu> is there a way to traverse a list of elements in backwards without using indexes?
18:46:26 <dons> map . reverse ?
18:48:26 <dcoutts> dons, so I've got patches to implement mapAccumL and mapIndexed using loopU
18:48:47 <dcoutts> mapAccumEFL f = \a e -> case f a e of (a', e') -> (a', Just e')
18:48:48 <dons> cool!
18:48:53 <dcoutts> mapIndexEFL f = \i e -> let i' = i+1 in i' `seq` (i', Just $ f i e)
18:49:01 <dons> oh good. these could even go back into the ndp branch
18:49:42 <dcoutts> I was thinking about loopD too...
18:49:54 <cyyoung> prime number types anyone?
18:49:58 <dons> oh, the U in loopU means 'unboxed' :)
18:49:58 <cyyoung> http://www.haskell.org/tutorial/moretypes.html
18:50:05 <dcoutts> dons, oh ok :-)
18:50:11 <dcoutts> dons, I mean loopDown
18:50:11 <dons> from the ndp stuff
18:50:15 <dons> yeah :)
18:50:25 <dcoutts> right, and all our stuff is unboxed
18:50:26 <cyyoung> has an example of a natural numbers type where the map from integers -> naturals just checks for >= 0
18:50:37 <cyyoung> is there a better way to make a 'prime numbers only' type?
18:51:16 <Korollary> cyyoung: That would require a better typesystem than that of Haskell98. Like GADTs, which ghc has.
18:51:24 <dcoutts> dons, and was thinking that there is some benefit to combining a up and a down loop - you can work in-place rather than allocating a new block
18:51:58 <dcoutts> dons, so each loopU allocates a new bock and fusing two 'loopU's saves one traversal + the allocation
18:52:04 <dons> yeah.
18:52:48 <dcoutts> dons, and up loop and a down loop still needs two traversals but we could save the allocation. It'd also have cache benefits
18:53:04 <dcoutts> we'd be working with 64k of hot cache contents
18:53:52 <dcoutts> (at least in the chunky case, not in the massive ByteString case)
18:53:58 <dons> i see that, but how do you fuse it?
18:54:10 <dons> loopU f . loopD g = loopUD ?
18:54:24 <dons> and how does loopUD work? it just applies the first, then the second?
18:54:33 <dons> so no traversal saving? just the allocation?
18:54:46 <dcoutts> right, no traversal saving
18:55:08 <dons> still reasonable. we should ask roman. maybe he's got some ideas on this.
18:55:20 <dcoutts> so we split the loop operation into a allocation wrapper + impure mutable bit
18:55:42 <dons> yeah, ok.
18:55:43 <dcoutts> then the impure mutating actions can just be sequenced
18:56:04 <dons> hmm.
18:56:06 <dcoutts> and we combine the wrapers
18:56:27 <dcoutts> or rather we'll only need one allocating wrapper for N alternating loops
18:56:46 <dcoutts> wrapper (loopUp >> loopDn >> loopUp >> ...)
18:57:28 <dons> with rules? 
18:57:33 <dcoutts> that's the hope anyway :-)
18:57:59 <dons> maybe. rules are still tricky to me, i'm not sure when they'll be guaranteed to work. but this _might_ work :)
18:58:11 <dons> seems a reasonabel idea.
18:58:12 * dcoutts grins
18:58:21 <dons> but we still want to have normal traversal fusion.
18:58:34 <dons> btw, game players, i've just cabalised frag
18:58:43 <dons> ?where frag
18:58:43 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
18:59:00 <dons> ?where+ frag http://www.haskell.org/haskellwiki/Frag
18:59:01 <lambdabot> Done.
18:59:37 <dcoutts> dons, that's right, we only want to do the traversals in sequence when they can't be combined into one pass
18:59:55 <dons> so, the plan would first be to get loopD working in the normal sense
18:59:58 <dons> then attempt loopUD.
19:00:13 <dons> then we can consider the harder problem of fusion on lists of arrays.
19:00:27 <dons> which i'd actually really like to solve.
19:00:39 <dcoutts> yeah, that'd be cool
19:00:49 <dcoutts> and I was thinking about that a little too
19:01:05 <dons> we can start by getting map on lazy fuseable somehow.
19:01:08 <dons> that's the easiest road in.
19:01:20 <dons> but i'll have to understand list/build/foldr fusion better
19:01:36 <dcoutts> the loopArr, loopAcc should give us the right way to be able to write loopU on the chunked representation
19:02:20 <dcoutts> since we need the accum parameter comming out of one chunk as the accum value going in for the next chunk
19:05:15 <dons> ah, yes!
19:05:29 <dons> good insight.
19:05:48 * SamB_XP missed it!
19:06:03 * SamB too!
19:06:05 <dons> the ndp guys aren't working on this list of chunk stuff, as far as I know. so its just us for now.
19:06:16 <dons> let me find the chunk/list phd..
19:06:26 <dons> or did you already see  that?
19:06:36 <dcoutts> nope
19:07:26 <dcoutts> dons, the crucial thing (I think) is that the sizes of chunks needen't match up between two fusable ops
19:08:25 <dons> oh, yes, we can't guarantee that.
19:08:30 <dcoutts> dons, can I ask first about unfoldrN so I can send you my current patches
19:08:31 <dons> filter . filter
19:08:38 <dons> sure.
19:09:08 <dons> now, you've got the new unfoldr stuff from sjanssen 
19:09:09 <dons> ?
19:09:19 <dons> here's the phd: http://www.dissertation.de/index.php3?active_document=buch.php3&buch=3233
19:09:20 <dcoutts> right, and I'm comparing with my implementation
19:09:24 <dcoutts> ah right
19:10:21 <dons> that's roman leshchinskiy's (ndp guy here at cse)'s former supervisor. at least the abstract is in english, i think
19:10:42 <dcoutts> yep
19:10:52 <dcoutts> I can't find the .pdf
19:10:56 <dons> "Improved time performance is achieved by
19:10:57 <dons>         choosing a piece size that matches the processors  data-cache size. We show how
19:11:00 <dons>         it can be combined with loop-fusion techniques, which are probably the most
19:11:03 <dons>         successful optimizations for collection-based programs."
19:11:20 <dons> we have the name though. so I might be able to track it down.
19:11:34 <dcoutts> ah, I've found the price tag :-)
19:11:40 <dcoutts> so no pdf here
19:11:51 <dons> not a t this page. but maybe the author's home page?
19:12:43 <dcoutts> http://citeseer.ist.psu.edu/721487.html
19:13:00 <dcoutts> that's a 16-page paper, not a phd
19:13:27 <dcoutts> www.cs.unc.edu/~prins/Publications/lcpc95.pdf
19:14:03 <dons> ok good. some background reading.
19:17:13 <RyanT5000> is there a decent intro to functional dependencies?
19:17:52 <RyanT5000> just something with like one solid example that shows "here's how it helps you"
19:25:19 <mansu> i am trying to use ord in ghci, but it says ord is not in scope, which module should i include in my source so that i can use it?
19:26:17 <vincenz> hmmhmm
19:26:28 <vincenz> has anyone done vertical layouting with happy
19:26:36 <mansu> hi binary42 
19:26:41 <RyanT5000> mansu: Char
19:26:55 <RyanT5000> @index ord
19:26:56 <lambdabot> Data.Char
19:27:02 <RyanT5000> correction: Data.Char
19:27:40 <palomer> RyanT5000: can you go on irc.slashnet.org #summer-discuss to see when the results are going to be published?
19:27:44 <mansu> RyanT5000: isn't it included in perlude.hs on ghc? just wondering because, the tutorial says otherwise
19:27:50 <sjanssen> so, SoC stuff still isn't out?
19:27:50 <sjanssen> dons, dcoutts: my unfoldr patch isn't broken is it?
19:28:13 <dcoutts> sjanssen, no, it's not broken
19:28:15 <palomer> sjanssen: irc.slashnet.org #summer-discuss should know when they'll be published
19:28:21 <RyanT5000> mansu: i don't know, but i've always just imported Data.Char
19:28:36 <RyanT5000> if you need to do it interactively, the command is ":m +Data.Char"
19:28:43 <sjanssen> man, I even made myself go to The Da Vinci code so I wouldn't sit around waiting for the results . . . so much for that
19:28:54 <sjanssen> dcoutts: good, I kinda sent it out in a rush
19:29:40 <dcoutts> mansu, no, it's not in the prelude. in some old versions of hugs it was incorrectly included in the prelude.
19:29:46 <Korollary> mansu: The standard says it's in Char.
19:30:17 <mansu> ok
19:30:26 <dons> sjanssen: am i right in thinking the unfoldr test isn't enabled in Properties.hs yet?
19:30:33 <RyanT5000> Korollary: isn't that pre-hierarchical-libs, though?
19:30:41 <RyanT5000> shouldn't we be using the hierarchical libs instead?
19:32:01 <Cale> RyanT5000: yeah
19:32:48 <sjanssen> dons: I haven't written it yet
19:34:16 <dons> ok. that's fine.
19:34:41 <sjanssen> RyanT5000: do you follow the haskell-libraries list?
19:38:06 <sjanssen> RyanT5000: http://www.haskell.org//pipermail/libraries/2006-May/005386.html -- do you remember having this same discussion?
19:38:50 <RyanT5000> yeah, thanks for the link
19:39:11 * dons -> uni
19:39:14 <RyanT5000> are there answers to that?
19:39:30 <sjanssen> it was mostly discussion, if I remember correctly
19:40:22 <palomer> http://floam.sh.nu/summerofcodecheck <---I don't know if it's real, but it's kind of spooky
19:41:44 <RyanT5000> unless it told you you were accepted, there's no way to tell if it's even plausibly legitimate
19:42:28 <palomer> I'm not trying
19:42:30 <palomer> still spooky
19:42:32 <sjanssen> I just thought it was very odd for the two discussions to happen in such a short interval
19:42:33 <RyanT5000> lol yeah
19:42:39 <RyanT5000> sjanssen: yeah
19:43:54 <RyanT5000> i bet it's BS
19:44:07 <sjanssen> palomer: well, it seems that sauron@mordor.org didn't get accepted
19:44:08 <RyanT5000> (referring to the link palomer just posted)
19:44:30 <sjanssen> there's no way it's real -- somebody is just being mean
19:44:40 <RyanT5000> sjanssen: neither did "a", "@", or the email address of the author of the page ;)
19:45:00 <RyanT5000>  
19:45:00 <RyanT5000>                 
19:45:00 <RyanT5000>  
19:45:00 <RyanT5000> Checking for floam@sh.nu... 
19:45:00 <RyanT5000>  
19:45:00 <RyanT5000> Sorry, your email does not appear in the list of accepted proposals.
19:45:02 <RyanT5000>      
19:48:25 <dcoutts> dons, we need a perf test for unfoldr so we can compere the current impl with my alternative impl
19:48:26 <dcoutts> unfoldr f w = concat (List.unfoldr (fmap (unfoldrN 4096 f)) (Just w))
19:48:42 <dcoutts> nice one-liner I think :-)
20:05:08 <araujo> sjanssen, i think that's a bad joke :-P
20:13:50 <dcoutts> dons, looks like my unfoldr is faster on small & medium size unfoldings (eg 1 million) and sjanssen's version is faster for very large unfoldings (eg 10 million)
20:14:38 <dcoutts> for 1,000,000: 0.224        0.188           # "unfoldr vs unfoldr'"
20:15:04 <dcoutts> for 10,000,000: 1.608        1.788           # "unfoldr vs unfoldr'"
20:15:59 <sjanssen> dcoutts: I like your's better
20:16:29 <dcoutts> me too, it's short :-)
20:16:54 <dcoutts> I could probably gain a small factor by expanding out the List.unfoldr
20:17:14 <dcoutts> since then I could eliminate the extra Maybe I'm currently using
20:17:37 <Korollary> I've never seen "your's" before.
20:17:48 <dcoutts> unfoldr' f w = concat (List.unfoldr (fmap (unfoldrN (1024*64) f)) (Just w))
20:18:03 <dcoutts> Korollary, oh I see what you mean; spelling
20:18:51 <Korollary> "Its" vs "it's" is very common, but your's is just innovative.
20:19:15 <palomer> its your's
20:20:25 <sjanssen> dcoutts: I think a chunk size of 64 K is a bit big.  have you experimented with a smaller value?
20:21:04 <sjanssen> it's kind of silly to require that much memory when you only want to unfold a string of 20 characters or so
20:21:05 <dcoutts> sjanssen, yep, I was using that large a value to get more speed on your version which uses very large sizes in the end since it keeps doubling :-)
20:21:14 <sjanssen> yeah, my version is bad
20:21:15 <dcoutts> sjanssen, I started with 4k
20:21:31 <sjanssen> if the realloc is the way we go, we ought to try Fibonacci growth
20:23:20 <sjanssen> Fibonacci should yield reasonably small growths but keep the same asymptotic complexity
20:24:14 <dcoutts> sjanssen, we could do both you know, do my concat style with your growing chunk style
20:24:43 <sjanssen> hmm
20:25:24 <dcoutts> ok, mine is running a bit faster now, nearly as fast as sjanssen's one for very large unfoldings
20:25:42 <dcoutts> 1.760  vs   1.824 for 10,000,000 and 4k chunks
20:26:54 <Korollary> dcoutts: what is the version of gcc?
20:27:09 <dcoutts> Korollary, gcc? or ghc?
20:27:12 <Korollary> gcc
20:27:28 <dcoutts> 3.4.5, why do you ask?
20:28:07 <Korollary> I think if you're shooting for uber-fast, it just makes sense to have it dump profiling data and re-optimize with it.
20:28:48 <dcoutts> hmm, not sure it'd help much for the kind of C code that ghc produces
20:29:30 <dcoutts> and it'd be tricky to do since the C code keeps changing for very minor changes in the .hs code or indeed the optimisation level
20:30:07 <Korollary> That is true. It would be nice if that could be part of the build because it shaves off 10-20% sometimes.
20:31:29 <vincenz> aloha
20:31:29 <dcoutts> sjanssen, so the chunk size definately makes a difference to performance, so perhaps we should use a growing size
20:31:52 <dcoutts> sjanssen, since as you say, for small strings even 4k is a waste
20:36:55 <vincenz> sjanssen: fibonacci style tends to be the preferred way
20:42:20 <sjanssen> > let fibs a b = a : fibs b (a + b) in takeWhile (< 8 * 1024) (fibs 64 128)
20:42:21 <lambdabot> [64,128,192,320,512,832,1344,2176,3520,5696]
20:42:42 <sjanssen> I'm just playing with numbers, but growth like that looks pretty good to me
20:43:10 <dcoutts> sjanssen, yeah
20:43:20 <Daveman> neat
20:43:24 <dcoutts> so how about this:
20:43:24 <dcoutts> unfoldr' :: (a -> Maybe (Word8, a)) -> a -> ByteString
20:43:25 <dcoutts> unfoldr' f = concat . unfoldChunk 64 64
20:43:25 <dcoutts>   where unfoldChunk n n' x =
20:43:25 <dcoutts>           case unfoldrN n f x of
20:43:25 <dcoutts>             (s, Nothing) -> s : []
20:43:26 <dcoutts>             (s, Just x') -> s : unfoldChunk n' (n+n') x'
20:44:43 <sjanssen> sounds good
20:46:10 <dcoutts> though I wonder if there shouldn't be an upper limit on the chunk size
20:46:29 <dcoutts> hmm maybe not
20:46:46 <dcoutts> since we have to concat the thing strictly in the end anyway
20:47:11 <dcoutts> for the .Lazy version we should probably have an upper limit or we loose the lazyness property
20:49:15 <sjanssen> yeah, for .Lazy we ought to have defaultChunkSize be the maximum
20:49:50 <dcoutts> right, or possibly even small chunk size
20:54:11 <dons> re.
20:54:34 <sjanssen> dcoutts: have you tried the fibo-like version yet?
20:54:43 <dcoutts> sjanssen, yes
20:55:19 <dcoutts> sjanssen, performance on very large is still the same, so that's fine
20:55:47 <dcoutts> sjanssen, so it's still a tad slower at the very large, and a tad quicker on the medium
20:55:57 <dcoutts> and it's too quick to measure on the small
20:57:40 <dons> we should have a look sometime at the 'make prof' output of Bench.hs, esp. with respect to the .Lazy code.
20:58:15 <dcoutts> sjanssen, and the fib version is slightly quicker than the fixed size chunk version for meduim size unfoldings
20:58:30 <dons> can we graph these numbers?
20:58:37 <dons> or is it easy to pick the best version?
20:58:51 <dcoutts> I think it's fairly easy to pick
20:58:55 <dons> ok. good
21:00:10 <sjanssen> dcoutts: and your pick is? ;-)
21:00:23 <dcoutts> unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:00:23 <dcoutts> unfoldr f = concat . unfoldChunk 64 64
21:00:23 <dcoutts>   where unfoldChunk n n' x =
21:00:23 <dcoutts>           case unfoldrN n f x of
21:00:23 <dcoutts>             (s, Nothing) -> s : []
21:00:24 <dcoutts>             (s, Just x') -> s : unfoldChunk n' (n+n') x'
21:00:41 <sjanssen> sounds good to me
21:00:46 <dons> yeah, looks good
21:00:49 <dcoutts> and the lazy version is similar
21:00:53 <dons> QuickCheck properties!
21:00:54 <dcoutts> but we don't need the concat!
21:01:05 <dons> ah, very good.
21:01:26 <dcoutts> and I'm using smallChunkSize as the upper limit and using simple quadratic growth to get there
21:01:41 <dcoutts> unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
21:01:41 <dcoutts> unfoldr f = LPS . unfoldChunk 32
21:01:41 <dcoutts>   where unfoldChunk n x =
21:01:41 <dcoutts>           case P.unfoldrN n f x of
21:01:41 <dcoutts>             (s, Nothing) -> s : []
21:01:43 <dcoutts>             (s, Just x') -> s : unfoldChunk ((n*2) `min` smallChunkSize) x'
21:01:53 <dcoutts> that's the lazy version
21:03:34 <sjanssen> dcoutts: I think we need an upper limit for the first one, just to make sure we don't overflow
21:03:56 <dons> i see that as of around 3 hours ago, google is up to resolving the clashes between multiple .orgs. that would seem to indicate they'll be at least a few more hours before the announce.
21:04:12 <dcoutts> sjanssen, but that can't happen unless we have a string bigger than memory, which we can't do anyway
21:04:44 <dcoutts> sjanssen, or am I reasoning incorrectly?
21:06:55 <sjanssen> with this unfoldr, we can't build a string that's 2^31 - 1 bytes long
21:07:24 <dcoutts> that's right
21:07:33 <dcoutts> we can't ever do that anyway
21:07:49 <sjanssen> > let fibs a b = a : fibs b (a + b) in takeWhile (< 2 ^ 31 - 1) $ scanl1 (+) (fibs 64 64)
21:07:50 <lambdabot> [64,128,256,448,768,1280,2112,3456,5632,9152,14848,24064,38976,63104,102144,165312,267520,432896,700480,1133440,1833984,2967488,4801536,7769088,12570688,20339840,32910592,53250496,86161152,139411712,
21:07:50 <lambdabot> 225572928,364984704,590557696,955542464,1546100224]
21:07:51 <dcoutts> because it'd be as large as your virtual memory
21:08:22 <vincenz> dum dum dum
21:08:27 <dcoutts> sjanssen, and in the 64bit case Int doesn't overflow 'til 2^64 -1 so it's the same case
21:08:57 <vincenz> Anyone have any experience with alex lexing and layouting?
21:11:13 <sjanssen> dcoutts: that is a good point
21:12:21 <dcoutts> sjanssen, for a corner case of unfoldrN, I'm wondering what the correct behaviour should be
21:12:34 <dcoutts> unfoldrN 5 (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
21:12:37 <dcoutts> ([0,1,2,3,4],Just 5)
21:12:43 <dcoutts> that's what we expect
21:12:52 <dcoutts> now the corner case is the next one:
21:12:58 <dcoutts> unfoldrN 6 (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
21:13:02 <dcoutts> ([0,1,2,3,4,5],Just 6)
21:13:21 <dcoutts> and the one following:
21:13:29 <dcoutts> ([0,1,2,3,4,5],Nothing)
21:13:36 <dcoutts> when we ask for  unfoldrN 7
21:14:09 <dcoutts> so in the 6 case, we've asked for a chunk of size 6 and we've been given one
21:14:22 <dcoutts> so why do we return Just 6 rather than Nothing?
21:14:33 <dcoutts> what do you think the correct behaviour is?
21:14:41 <dcoutts> dons, what do you reckon?
21:15:59 <dcoutts> sjanssen, I think your version gave Nothing and dons original version gave Just 6 (I think)
21:16:32 <sjanssen> dons had a version where you get a Maybe back?
21:16:49 <dcoutts> er, no
21:17:18 <dcoutts> but the code was structured such that the obvious thing to do would give back Just
21:17:35 <hyrax42> @type unfoldrN
21:17:36 <lambdabot> Not in scope: `unfoldrN'
21:17:39 <dcoutts> sjanssen, in your code you test 'f x' before n == i
21:18:42 <sjanssen> okay, I see what you mean
21:20:12 <sjanssen> as far as what's right, I'm not sure
21:21:24 <sjanssen> either way we ought to document it
21:22:00 <dcoutts> the Maybe should probably mean "we ran over!"
21:22:14 <dcoutts> so when you get exactly the length you want, you didn't run over
21:22:19 <dcoutts> so it should be Nothing
21:22:19 <hyrax42> @pl \x -> [6..10] >>= return . ((,) x)
21:22:19 <lambdabot> (`fmap` [6..10]) . (,)
21:22:45 <dcoutts> sjanssen, how's that for a random justification? :-)
21:23:13 <vincenz> question for the compielr people: who should check if there are duplicate definitions of some data constructor: Typechecker or something before it
21:23:30 <vincenz> and if something before it, gimme a good name?
21:24:39 <heatsink> What's the stage where you link up identifiers to entities (functions, types, etc)?
21:25:14 <heatsink> In C that happens while parsing but that's because C is weird.
21:25:33 <vincenz> personally I think ti should happen pretypecheck
21:25:42 <vincenz> cause if you have
21:25:42 <dcoutts> vincenz, I'd agree
21:25:44 <vincenz> data Foo = X | Y
21:25:47 <vincenz> data Bar = X 
21:25:53 <vincenz> then if you got X somewhere you won't know what type it is
21:25:53 <heatsink> That stage that I'm mentioning is where I think you should detect duplicate definitions.
21:25:58 <sjanssen> dcoutts: your way makes Lazy.unfoldr easier to implement, right?
21:26:02 <vincenz> just don't know wtf to call it in a nice convenient name
21:26:10 <heatsink> Name resolution?
21:26:11 <vincenz> Consistifier?
21:26:22 <dcoutts> sjanssen, I don't see what you mean
21:26:33 <vincenz> heatsink: ooh
21:26:34 <vincenz> Resolver
21:26:36 <vincenz> Thx!
21:26:40 <heatsink> np :)
21:26:47 <mansu> whats the correct way of writing this statement? 	| symbol  == '>' = bfIntptor list (index + 1) ; putStrLn "Increament"
21:26:49 <vincenz> (naming is one of the hardest parts of coding)
21:27:32 <heatsink> vincenz: Having trouble coming up with names? Here's some handy ones: a b c d e f g
21:27:45 <dcoutts> sjanssen, if I make it Nothing then it does means that we never end up concating an empty list at the end
21:27:49 <heatsink> Just ask my son, J.  He'll tell you lots of useful names.
21:28:05 <vincenz> heatsink: heh.
21:28:06 <sjanssen> dcoutts: yeah, that's what I'm referring to
21:28:24 <dcoutts> sjanssen, which does otherwise happen. That also means that yes, it is better for .Lazy since we have to avoid empty ByteString in the list
21:28:37 <dcoutts> so I'll change it
21:29:10 <mansu> i am trying to call a function and also print some thing... how can i execute 2 expressions inside a guard condition?
21:29:30 <heatsink> mansu: you want to print something inside a guard condition?
21:30:03 <sjanssen> I agree, the behavior is better, and easier to specify: unfoldrN only returns Just when there is at least one more element to yield
21:30:12 <dcoutts> sjanssen, right
21:30:15 <mansu> heatsink: well, i am new to haskell.. so just want to print something so that i can know that its executed... 
21:31:12 <sjanssen> mansu: check out Debug.Trace
21:31:24 <dcoutts> mansu, that's not typically what people do
21:31:55 <dcoutts> mansu, you probably don't want to get into the habit of using Debug.Trace
21:32:23 <dcoutts> mansu, you can usually just evaluate your function in ghci to test it
21:32:50 <mansu> dcoutts: how do they do it then? all my gaurd conditions call the same function... so its a bit confusing to have to think about it 
21:32:55 <vincenz> resolve :: (Monad m) => ParsedProgram -> m ResolvedProgram
21:33:00 <mansu> dcoutts: ok will try that ...
21:33:03 <hyrax42> question: gets id == get?
21:33:07 <vincenz> typecheck :: (Monad m) => ResolvedProgram -> TypedProgram
21:33:08 <hyrax42> (state monad)
21:33:08 <vincenz> :)
21:33:21 <vincenz> hmm, add an 'm;
21:34:31 <mansu> dcoutts: also is calling func1 and func2 inside a gaurd condition legal? or is there a rule that only one expression can be evaluated inside a gaurd?
21:35:33 <dcoutts> mansu, you can call two functions but they must be part of the same expression in the gaurd
21:35:54 <dcoutts> eg: f x | foo x && bar x = ...
21:36:12 <dcoutts> that's one expression
21:37:36 <mansu> dcoutts: what about this f x y | x == 5 = succ x ; succ y ? is that legal? or should i use succ x && succ y 
21:37:52 <dcoutts> no, it's not legal
21:38:04 <dcoutts> if you mean  succ x && succ y  then use that
21:38:28 <dcoutts> mansu, remember that expressions are not executed, they're evaluated
21:39:01 <dcoutts> it makes no sense to 'execute' an expression where the result is not used
21:39:44 <mansu> ok dcoutts 
21:42:25 <goltrpoat> there goes my last hope of ever finding someone who's done chess programming beyond an alpha-beta tutorial
21:43:36 <rashakil_> does it count if you did it without a tutorial?
21:44:22 <goltrpoat> that's five extra points.
21:44:48 <rashakil_> yay!  I can make a pentagon
21:47:27 <goltrpoat> another point, and you can make an octahedron.
21:52:07 <vincenz> dcoutts: another question
21:52:17 <vincenz> dcoutts: for datacons and tycons resolution must be done prior checking
21:52:21 <vincenz> but for checking that we don't have
21:52:22 <vincenz> foo A
21:52:23 <vincenz> foo B
21:52:25 <vincenz> foo B =
21:52:32 <vincenz> that's post-typechecking, no?
21:52:56 <dcoutts> not sure what you mean there exactly
21:53:09 <vincenz> foo A =...; foo B = .... ; foo B = ...
21:53:19 <dcoutts> but I'd try and do most of that kind of name resoltion thing before typecheking
21:53:27 <vincenz> well this is a function
21:53:43 <dcoutts> so are you saying it's a duplicate definition?
21:53:47 <vincenz> yeah
21:53:51 <vincenz> cause you have foo B twice
21:54:02 <dcoutts> then do it before type checking
21:54:06 * vincenz thinks that this kind of stuff can only be done after typechecking
21:54:17 <dcoutts> really? why?
21:54:20 <vincenz> cause you need to know the type of the parameter to foo before you can check whether there's overlapping matching
21:54:30 <dcoutts> itn't it a simple check?
21:54:42 <vincenz> foo Foo(Bar _)
21:54:49 <vincenz> foo Foo(Bar _)
21:54:52 <dcoutts> oh so you're not saying it's a duplicate function definition
21:54:57 <dcoutts> just overlapping patterns
21:55:00 <vincenz> ye
21:55:01 <vincenz> yep
21:55:15 <dcoutts> then it's not an error then, right?
21:55:23 <vincenz> overlapping patterns are legal?
21:55:37 <dcoutts> it's probably a user mistake but it's legal in Haskell at least
21:55:39 <vincenz> > let {foo 1 = 1; foo 1 = 2; foo n = n} in foo 1
21:55:40 <lambdabot>   Warning: Pattern match(es) are overlapped
21:55:40 <lambdabot>      In the definition of `foo': foo 1 = ...
21:55:50 <dcoutts> see, only a Warning
21:55:52 <vincenz> hmm
21:56:12 <vincenz> alright, but I would think that even to generate such warning would require post typechecking
21:56:16 <vincenz> and I'd prefer making it an error in my case
21:56:23 <dcoutts> vincenz, checking for overlapping patterns is non-trivial
21:56:34 <vincenz> well my types are ultra simple
21:56:40 <vincenz> data Type = A | B | C
21:56:42 <vincenz> no parameters
21:56:44 <vincenz> no tuples
21:56:48 <vincenz> no partial application
21:57:00 <dcoutts> and yes, you'd probably do it after typechecking
21:57:07 <vincenz> :)
21:57:10 * vincenz continues hacking
21:57:18 <palomer> yeah, checking for overlapping patterns when your patterns are either a variable or a nullary constructor is trivial
21:57:25 <vincenz> I'd like to move my parser from Parsec to alex/happy but I don't k now how to do vertical layouoting with alex
21:58:16 <vincenz> :(
21:58:27 <vincenz> palomer: but it's certainly post typecheck
21:58:27 <vincenz> ?
21:59:30 <palomer> can be either, really
22:00:32 <palomer> or even during
22:00:34 <palomer> whatever floats your boat
22:01:05 * vincenz ponders
22:02:11 <palomer> you want to check for exhaustiveness too?
22:02:19 <vincenz> yep
22:02:29 * vincenz is working on his resolver atm
22:02:36 <vincenz> to resolve datacons and tycons to ensure singularity
22:09:05 * dcoutts darcs sends dons a pile of patches
22:14:00 <Cale> HGAL is cool. It's nice to have a fast graph automorphism tester in Haskell.
22:15:15 <Cale> er, isomorphism
22:15:33 <Cale> It also finds automorphisms rather quickly.
22:15:41 <vincenz> :)
22:15:43 <dons> yay patches!
22:17:00 <dons> @localtime dcoutts
22:17:09 <lambdabot> Local time for dcoutts is Wed May 24 06:15:48
22:17:09 <dcoutts> dons, brown paper bag patch following...
22:17:17 <dcoutts> yeah, a bit early
22:17:34 <dons> brown paper bag patch? that doesn't sound healhty
22:17:49 <dcoutts> dons, it's the trivial fix for the last patch :-)
22:17:58 <dons> cons is pretty rare. i think coalescing there should be no problem.
22:18:10 <dcoutts> oh but I can't send just that one since it deps on the other ones
22:18:25 <dons> send both
22:18:37 <dcoutts> done
22:18:37 <dons> anyway ,darcs ignores patches already applied, i think
22:18:42 <dcoutts> yep
22:19:14 <dons> so i need to write some QC properties, since you guys are too lazy to check your code ;)
22:19:22 <dcoutts> hah, yeah
22:20:20 <dcoutts> dons, so, do you know why map' is faster than map ?
22:20:39 <dcoutts> what overhead is loopU adding?
22:20:43 <dons> why? i guess ghc's not quite removing all the accumulator stuff.
22:20:49 <dons> there's patches in the head for this though
22:20:57 <dons> so I should profile there.
22:21:01 <dcoutts> head ghc you mean?
22:21:04 <dons> yep
22:21:09 <goltrpoat> cale:  why do you need a graph automorphism tester?
22:21:11 <dcoutts> ok, nice
22:21:49 <dcoutts> dons, though there is also the count of filtered elements to see if the array needs copying at the end
22:22:08 <dons> that too. good point.
22:22:25 <dons> should think about that, perhaps
22:22:29 <dcoutts> aye
22:22:41 <Cale> goltrpoat: I was writing a program to count minimal strongly connected graphs up to isomorphism.
22:22:56 <goltrpoat> actually.  i guess i remember needing to find graph isomorphisms for the planar duals of triangle meshes
22:23:08 <Cale> came to ~20-30 lines.
22:23:13 <dcoutts> a specialised version that does no fltering perhaps :: (acc -> Word8 -> (acc, Word8))
22:23:15 <goltrpoat> ah cool
22:23:56 <dons> dcoutts: and then of course, more rules to keep fusion ticking along.
22:24:00 <goltrpoat> why do you need to count minimal SCGs? :)
22:24:10 <dcoutts> dons, ah, ever more rules...
22:24:27 <dons> i'll benchmark with the head to see if the compiler can handle it. otherwise, we can consider some other approach, as you say.
22:24:34 <Cale> goltrpoat: mainly out of interest
22:24:39 <goltrpoat> ah
22:24:44 <Cale> goltrpoat: it doesn't seem to be on Sloane
22:24:50 <goltrpoat> oh it's not?
22:24:53 <Cale> yeah
22:24:55 <goltrpoat> odd
22:25:05 <Cale> or if it is, I couldn't find it
22:25:28 <dcoutts> dons, as for thw allocating wrapper + mutating loop idea, I'd partition it roughly like loopU is already split with it's 'go' worker function
22:26:24 <dcoutts> dons, then we'd want to be able to combine several 'go's in a single wrapper
22:26:34 <dcoutts> though how the accums get passed about...
22:26:37 <goltrpoat> cale:  http://www.research.att.com/~njas/sequences/A035512 ?
22:27:25 <Cale> goltrpoat: that's an upper bound
22:27:48 <Cale> I also want them to be minimal in the sense that if any arc is removed, the resulting graph is not strongly connected.
22:28:28 <Cale> the 83 becomes 15
22:28:35 <dcoutts> dons, something like loopU = alloc doLoopUp
22:28:39 <Cale> I'm not sure yet what the 5048 becomes.
22:28:44 <goltrpoat> oh i see
22:28:50 <Cale> but it's at least 63
22:29:04 <dons> dcoutts: yeah, that might be rule-matchable. 
22:30:01 <dcoutts> dons, and then alloc loopA _ _ (alloc loopB _ _) ==> alloc (loopA `frobnicate` loopB) _ _
22:30:08 <Cale> My program finds 63 almost immediately, and then nothing for quite a long time (due to the nubBy isIsomorphic, probably)
22:30:32 <dcoutts> dons, where frobnicate is something like monadic >>
22:31:02 * vincenz frobnicates dcoutts's schjwingdong
22:31:12 <dcoutts> how rude!
22:31:18 <dcoutts> ;-)
22:31:44 <vincenz> hmmhmm
22:32:05 <vincenz> vertical layouting is pissing me off
22:32:08 <xerox> Good morning!
22:32:16 <vincenz> and it's my main blocking factor that stops me from moving to alex/happy
22:32:20 <vincenz> cause with parsec it's easy
22:32:45 <Bobstopper> Is there a simple way to generalise between strings and packed strings? Is there for example a typeclass which allows me to use generic string functions for both Strings and PackedStrings (or fastpackedstrings)?
22:33:34 <dons> not yet. there's no Sequence class including ByteString.
22:33:36 <Bobstopper> I was thinking it might be useful if PackedString was at least an instance of MonadPlus somehow
22:34:05 <dons> PackedString is also pitiful, you should try Data.ByteString :) PackedString is often slower than [Char].
22:34:11 <dons> Bobstopper: yeah, that's a good idea.
22:34:28 <Bobstopper> Is it possible for ByteString/PackedString to be made MonadPlus or has this been tried and failed?
22:34:43 <dons> hasn't been tried.
22:34:47 <Bobstopper> k
22:34:59 <dons> hmm, well, it could be an instance of Monoid. that's easy.
22:35:22 <Bobstopper> ah yup, that'd be useful too
22:35:53 <dons> and MonadPlus is easy too.
22:35:56 <dons> i'll add these.
22:36:54 <Bobstopper> Excellent, thanks :) I think it'd give users a lot more choice in what string format to use when libraries are written using those typeclasses rather than closely written with String or ByteString :)
22:37:30 <sjanssen> wait, ByteString can't be a Monad, it's not the right kind
22:37:39 <Bobstopper> Yeah, the kind'd have to change.
22:37:41 <vincenz> hmm
22:37:48 <dons> hmm. that's the problem.
22:37:53 <vincenz> does anyone know why ghc lexer differentiates between absent and present curlies?
22:38:07 <vincenz> or v*curly and *curly
22:38:26 <dons> yeah, no MonadPlus then.
22:39:21 <sjanssen> dons: ByteString could instance monoid
22:39:42 <dons> ah yes! 
22:39:43 <dons> good.
22:39:45 <Bobstopper> Damn. Perhaps build the ByteString upon another datatype that does have the right kind? Then the ByteString datatype could act as a sort of backwards-compatible interface
22:40:42 <sjanssen> Bobstopper: Monad isn't the interface that will help with this
22:40:53 <sjanssen> what we need is a Sequence class
22:41:00 <dons> you wanted a String/Sequence class, Bobstopper ?
22:42:44 <Bobstopper> Yeah. I suppose monoid mostly handles what I need... I was mostly after msum but mconcat is just as good.
22:43:27 <dons> sjanssen: you want to add the instance for Monoid?
22:43:40 <sjanssen> sure
22:44:13 <mansu> is there a link where i can look at some sample haskell code... this is my first day with haskell... so i am looking for some examples which are more common
22:44:20 <dons> yep, haskell.org
22:44:32 <dons> look at the Tutorials and introduction stuff
22:44:46 <dons> and welcome!
22:45:06 <Bobstopper> It could use some way of getting at specific characters, so a sequence class would still be good...
22:45:57 <mansu> thx dons 
22:46:33 <user311> i am creating a list out of a bunch of data in a file, and passing it to a function, is there a way to know how much data was consumed by that function without having that function to keep track of that?
22:47:16 <dons> user311: hmm. well, can't you call 'length' on the data before you pass it?
22:48:13 <user311> not really, because that will evalute the whole list, and force it to read all the data, not just what the function will consume, if i understand how lazy evaluation is working
22:48:30 <Joplin> Anybody have any pointers for getting Gtk2HS to work under windows?
22:48:40 <Joplin> No,  it'll only evaluate the length of the list :)
22:49:15 <dons> ok, sure. then you'll have to have the function, or something on the other side of the function, measure.
22:49:46 <user311> what i was doing is keeping track of the last line i read form the file in an IORef, but that caused the list to be of type IO [IO MyData] instead of just IO [MyData]
22:50:26 <dons> yeah, you could do it monadicaly
22:50:29 <dons> ?type join
22:50:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
22:50:43 <dons> and use join to fix the type (possibly)
22:51:09 <dons> ah, not quite join.
22:51:11 <eivuokko> @type sequence
22:51:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
22:51:13 <user311> dons: wouldn't that cause the list to be evaluated?
22:51:19 <eivuokko> Is nearer maybe
22:51:59 <Joplin> You should be able to use an IORef without getting a type like that.
22:52:14 * dons -> home
22:52:31 <eivuokko> user311, when you end up with IO [IO a] you usually should use mapM instead of map, or foldM instead of foldl and so on.
22:53:40 <eivuokko> And yeah, that will generally consume the list in one go.
22:54:00 <user311> eivuokko: going from [m a] to m [a] would cause all the elements in that list ot be evaluated in a non lazy way
22:54:31 <user311> eivuokko: which is not what i want, i only want to consume as much as the functoin that uses that list needs, and i want to know how much it consumed
22:56:42 <squiggly> bye prudes
22:58:32 <user311> Joplin: do you mean with unsafeInterleaveIO?
22:59:02 <eivuokko> I doubt you need unsafeInterleaveIO unless you have very specific interface specifications.
22:59:39 <Joplin> yeah, you don't want to mess around with that function
22:59:57 <eivuokko> From what I understand, you have [String] -> [a], and you want [String] -> [(a,Int)] or [String] -> ([a],Int)
23:00:44 <eivuokko> If you built so that you could pass Int through IORef, I don't see why you couldn't build one of the pure versions.
23:00:56 <user311> well i have a function that takes [a] -> int, but i want to know how much of [a] it took to get an int
23:00:58 <Joplin> What I meant is,  once you have a type "IO a",  you can use IORefs in the computation without moving to an "IO (IO a)"
23:01:22 <eivuokko> user311, And how did you build the IORef version?
23:01:49 <user311> eivuokko: the thing that generates [a] stores a in an IORef as its being read from a file
23:02:03 <eivuokko> Ehm
23:02:16 <Joplin> user311: do you mind posting a bit of code?
23:02:24 <eivuokko> Well, that's not lazy either, is it?
23:02:38 <eivuokko> You just have to change your function, I think.
23:02:42 <user311> no its not
23:02:49 <eivuokko> Meh.
23:02:53 <user311> which sucks
23:03:07 <eivuokko> I thought it was just problem with type being IO [IO a]
23:04:11 <Korollary> user311: I think what you're asking would require a compiler pragma or something.
23:04:17 <Korollary> +for
23:04:48 <Joplin> ok,  I'm getting this error:   can't load .so/.DLL for: glib-2.0 (addDLL: unknown error)
23:05:19 <eivuokko> Joplin, Is that ghci?  Try compiling and executable with ghc.
23:05:28 <eivuokko> *an executable
23:05:42 <sjanssen> user311: the only reasonable way to count how much of your list is consumed is to do it explicitly in your function -- any other method will be either unreliable or break purity
23:06:10 <Joplin> Yes, it is GHCi
23:06:11 <Joplin> hmm
23:06:46 <user311> yea, that makes sense
23:07:37 <palomer> type EadibleList a = ([a],[a])
23:07:46 <Joplin> ok,  GHC produced an object file but I'm getting crazy link errors.
23:07:57 <Joplin> The DLL is located in C:\GTK\bin
23:08:03 <Joplin> How do I get GHC to find it?
23:08:27 <eivuokko> Dll is not needed during that linking
23:09:34 <Joplin> Ahh... I forgot to include the -package option
23:09:45 <eivuokko> You should get compiler errors then.
23:11:02 <Joplin> I have it working for GHC now.  But I really would like to do stuff from GHCi. 
23:11:15 <eivuokko> I think you can't have that with stable ghc.
23:11:28 <eivuokko> dcoutts worked on that, he probably knows more.
23:14:02 <eivuokko> There might exist hack where you *copy* DLL's to diffrent names.  Names that contain those versionnumbers.
23:14:16 <eivuokko> I gtg, good luck.
23:16:50 <Joplin> thanks
23:31:59 <mansu> whats the easier way to replace the nth element in a list?
23:33:14 <Joplin> I'm not aware of such a function in the standard libs.  I've always written my own.
23:33:36 <Korollary> mansu: It won't be replacing per se since lists are pure. You can create a new list, though.
23:33:59 <neologism> mansu: ((take (m - 1) s) ++ (flip' (s!!m)):(drop m s))
23:34:09 <neologism> where flip' is the replacing function 
23:34:16 <neologism> but its prolyl not the best way
23:35:23 <Korollary> > let (a,b) = Data.List.splitAt 3 [1,2,3,4,5] in a ++ [0] ++ b
23:35:24 <lambdabot> [1,2,3,0,4,5]
23:35:24 <mansu> Korollary: is there a function which does that? i have come up with this func using splitAt... which doesn't seem clean 
23:35:39 <Joplin> adjust _ [] = (whatever you want to do if the index is out of range)
23:36:12 <Joplin> adjust (n+1) e (x:xs) = adjust n e xs
23:36:32 <Joplin> adjust 0 (x:xs) = e:xs
23:36:47 <Joplin> err
23:36:49 <mansu> Korollary: that looks good... i was using concat for the same thing... 
23:37:05 <Joplin> close, not quite.  YOu have to add "e" on the lhs
23:37:33 <Joplin> adjust _ e [] = (however you want to handle this)
23:37:46 <Joplin> adjust (n+1) e (x:xs) = adjust n e xs
23:37:56 <Joplin> adjust 0 e (x:xs) = e:Xs
23:37:57 <Kasperle> don't you need to prepend the x, to the resulting list, too?
23:37:59 <mansu> Korollary: can i use where instead of a let in the xpression?
23:38:21 <Kasperle> as in adjust (n+1) e (x:xs) = x:(adjust n e xs)
23:38:29 <Joplin> good point
23:38:45 <Joplin> I stand corrected
23:39:13 <Korollary> mansu: Yes
23:39:17 <mansu> Korollary: btw, that does not replace an element...
23:39:43 <Korollary> mansu: yes, sorry I am almost asleep
23:40:05 <mansu> > a ++ [0] ++ b where (a,b) = splitAt 3 [1,2,3,4,5]
23:40:06 <lambdabot> [1,2,3,0,4,5]
23:40:26 <Korollary> > let (a,b) = Data.List.splitAt 3 [1,2,3,4,5] in a ++ [0] ++ (tail b)
23:40:27 <lambdabot> [1,2,3,0,5]
23:40:48 <mansu> Korollary: why does ghci fail to parse this exp... but lambdabot does?
23:41:25 <Korollary> mansu: It's fine in my ghci.
23:41:43 <sjanssen> mansu: lambdabot is the one that is wrong
23:42:09 <Korollary> ah, you mean yours
23:42:14 <mansu> Korollary: ya 
23:42:24 <sjanssen> mansu: usually where's are confined to bindings that have =, but not expressions
23:43:06 <sjanssen> lambdabot translates your request from > E to "let v = E", so the where works
23:43:35 <Korollary> sjanssen: Is that where that bizarre v comes from?
23:44:04 <mansu> sjanssen: oh ok. so this should work inside a function right...
23:44:09 <sjanssen> Korollary: yeah, but v is a randomized name now, no more v
23:44:30 <Korollary> sjanssen: just randomized or guaranteed to be fresh?
23:45:02 <sjanssen> mansu: it will work with a function that uses = in it's declaration (which is probably what you mean)
23:45:37 <mansu> sjanssen: yean thx
23:45:41 <sjanssen> Korollary: a fairly long randomized string.  It isn't guaranteed to be fresh
23:46:01 <sjanssen> > x where x = 3
23:46:02 <lambdabot> 3
23:46:07 <sjanssen> > (x where x = 3)
23:46:07 <lambdabot>  parse error on input `where'
23:46:57 <neologism> > let x where x = 3 in x
23:46:57 <lambdabot>  parse error on input `where'
23:47:02 <Cale> It's curious that the former works -- is it doing some sort of textual substitution there?
23:47:19 <Cale> > let x = 3 in x
23:47:20 <lambdabot> 3
23:47:29 <sjanssen> Cale: yeah, just an artifact of using let in the translation
23:47:35 <Cale> > let x = y where y = 3 in x
23:47:36 <lambdabot> 3
23:48:18 <sjanssen> dons: perhaps paren's should be added to avoid this behavior?
23:49:45 <vincenz> hmm
23:49:52 <vincenz> anyone good at writing parsers?
23:50:39 * vincenz isn't sure how to tell the parser that function application has the tightest binding
23:50:44 <vincenz> cause there's no symbol involved
23:50:57 <Cale> what sort of parser are you writing?
23:51:01 <vincenz> happy
23:51:18 <vincenz> I guess it's lr1
23:51:25 <Joplin> you can always code precidence directly into your grammar
23:51:32 <Cale> I guess you just have to express your grammar the right way
23:51:36 <Joplin> Eg...
23:51:40 * vincenz gets a lot of shift-reduce rules due to
23:51:55 <vincenz> ident expression_list -> funcall $1 $2
23:52:12 <Korollary> vincenz: cheat looking at the haskell grammar maybe?
23:52:14 <vincenz> erm, conflicts
23:52:18 <vincenz> Korollary: tried and failed
23:53:41 * vincenz wonders how haskell does the trick with allowing fixity stuff to alter the parser
23:54:41 <Joplin> <term> ::= <factor> | <term> + <factor>
23:54:49 <vincenz> yeah I know
23:54:55 <vincenz> but haskell allows fixity declarations
23:55:03 <vincenz> which would not work in such a fixed parser settinga s you denote
23:56:03 <Joplin> <factor> ::= <lit> | <factor> * <lit>
23:56:18 <Joplin> <lit> ::= ( <term> ) | <integer>
23:56:25 <Joplin> yes
23:56:50 <Joplin> But function application always takes precidence over infix declarations
23:57:16 <vincenz> true nuff
23:57:54 <vincenz> exp :: ident exp_list | basic_exp
23:58:10 <vincenz> hmm nope
