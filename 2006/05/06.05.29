00:00:02 <neologism> shemale_magic: most employers require imperative languages :(
00:00:03 <palomer> the girls
00:00:34 <shemale_magic> heh
00:00:42 <shemale_magic> I want to learn to program
00:00:47 <shemale_magic> treid comon lisp
00:00:55 <shemale_magic> ansi common lisp bok by graham
00:00:57 <shemale_magic> it sucked
00:01:06 <shemale_magic> saw somethign about perl
00:01:10 <Pseudonym> Paul Graham sucks.
00:01:15 <shemale_magic> then saw scheme and haskell
00:01:16 <Pseudonym> He sucks less than a lot of people.
00:01:24 <palomer> he sucks less than most
00:01:25 <shemale_magic> saw smalltalk
00:01:28 <palomer> but common lisp sucks
00:01:33 <shemale_magic> so now im not sure what to do
00:01:38 <Pseudonym> Common lisp sucks more than Scheme.
00:01:43 <Pseudonym> Scheme also sucks.
00:01:49 <Pseudonym> But not as much as many languages.
00:01:53 <shapr> shemale_magic: What's your goal, to be a good programmer or just to make money?
00:02:00 <tennin> palomer: I wonder if there's room for research in that area (groupie-oriented programming)
00:02:17 <shapr> I think you should learn Haskell if you love programming, because Haskell will stretch your thinking in powerful ways.
00:02:39 <tennin> current implementations seem to be suboptimal
00:02:44 <neologism> shapr: learning haskell and then be forced to code in C at work might be lethal ;)
00:02:51 <shapr> tennin: Yeah, I haven't found any good groupies either :-(
00:02:54 <palomer> I've got a little fanclub going around these parts
00:03:29 <shapr> shemale_magic: Learning one does not mean you can't learn others. I say learn 'em all :-)
00:03:36 <shapr> shemale_magic: Just figure out where you want to start.
00:03:55 <Pseudonym> There are some languages that are a waste of time to learn.
00:03:56 <tennin> maybe an esoteric language
00:04:04 <Pseudonym> Unless you just want an object lesson in what a bad language is like.
00:04:22 <tennin> "programs shall be in the form of glam-rock concerts"
00:04:25 <wilx> Name some.
00:04:25 <Pseudonym> Or an obsolete langauge, I guess.
00:04:41 <Pseudonym> OK.  There's no reason to learn Simula these days.
00:04:50 <Pseudonym> Unless you badly need to read old Simula code.
00:04:55 <wilx> Hm.
00:05:00 <shapr> SNOBOL
00:05:10 <Pseudonym> SNOBOL is another good example.
00:05:27 <Pseudonym> You're better off learning Perl, Python or AWK.
00:05:28 <neologism> well. ada is useless today but it has some interesting properties
00:05:40 <Pseudonym> There are good reasons to learn Ada.
00:06:00 <shapr> I'd also say that learning Oberon is better (from a programming language theory point of view) than learning any of the earlier Wirth languages.
00:06:01 <wilx> Ada is still used a lot it seems.
00:06:06 <Pseudonym> There's a lot of Ada code still in use, it has a number of interesting features, and it's an EXCELLENT example of how not to design a language.
00:06:08 <mauke> I started with perl and never learned awk or sed
00:06:16 <Pseudonym> Since it's the poster child of design by committee.
00:06:28 <mauke> I thought that was magenta
00:06:41 <Pegazus> <Pseudonym> There's a lot of Ada code still in use, it has a number of interesting features, and it's an EXCELLENT example of how not to design a language. --> why's that?
00:06:51 <shapr> "design by committee"
00:06:55 <Pseudonym> Yup.
00:07:04 <wilx> Well, Ada 95 and later seem to have some very nice features.
00:07:06 <neologism> wasnt ada designed by single person?
00:07:17 <neologism> (the one with jewish name)
00:07:23 <wilx> Maybe it is just me but I like the BDSM it does to its users :D
00:08:17 <Pseudonym> Ada isn't as bad a language as many people think.
00:08:37 <ValarQ> and maybe PL/1 is the right way to go
00:08:41 <Pseudonym> It's only a good example of ONE way not to design a language.
00:08:46 <Pseudonym> Good heavens, no!
00:08:54 <neologism> ValarQ: real men code in assembler :)
00:08:55 <Pseudonym> PL/1's lexical syntax is even worse than Fortran's!
00:08:59 <Pegazus> why not?
00:09:16 <mlh> neologism: quite the opposite
00:09:27 <neologism> mlh: joke...
00:09:30 <Pseudonym> Real men don't get any work done.
00:09:44 <shapr> But, I like eating!
00:09:44 <palomer> which is why real men use haskell
00:09:46 <mlh> oh :-)
00:09:54 <shapr> palomer: Real men use Haskell to do real work.
00:09:55 <ValarQ> well, i did this weird serverapplication in assembler once...
00:10:00 <shapr> Hey, I've been paid to write Haskell.
00:10:13 <palomer> shapr: and I bow to you, tis not an easy task
00:10:18 <Pegazus> assembler has very few uses today...
00:10:19 <ValarQ> neologism: http://arda.no-ip.org/server.asm
00:10:24 <shapr> Bah, it's easier than you make it out to be.
00:10:33 <shemale_magic> the haskell application server seems spiffy
00:10:49 <neologism> ValarQ: once I was forced to code "calculator" in asm
00:11:03 <dons> yeah, i don't understand palomer's constant moaning about haskell being difficult. what's your story, palomer? 
00:11:11 <dons> its tedious
00:11:22 <shapr> palomer: Yeah, put up or shut up. Show us some proof.
00:11:45 <ValarQ> neologism: reverse-polish notation i hope
00:11:46 <Pegazus> i can show you how "haskell" is difficult if you want
00:11:56 <shapr> Pegazus: Sure, go for it.
00:12:02 <Pegazus> haskell defines functions
00:12:08 <Pegazus> relations are much more nicer and powerfull :)
00:12:20 <shapr> Are you TopMind in disguise?
00:12:20 <neologism> ValarQ: no... it was some embeded stuff
00:12:33 <neologism> some 8bit intel controller + display + keyboard
00:12:38 <Pegazus> relations gives you much more "high" order than haskell high order...
00:12:40 <palomer> I'm not moaning!
00:12:52 * tennin finds it very difficult to get paid for anything these days
00:12:54 <shapr> Pegazus: That's a claim, that's not proof or any code we can look at ourselves.
00:12:59 <neologism> www.stud.fit.vutbr.cz/~xdivac02/cal.asm
00:13:03 <Pseudonym> Pegazus: I agree in theory, but I argue that it has never actually happened yet in a way that's practical.
00:13:10 <Pegazus> it has
00:13:14 <palomer> it's just that at some point you'll have to interact with code which is not functional (usually in real code), and then life isn't so rosy
00:13:15 <Pseudonym> Example?
00:13:18 <palomer> unless you learn a lot of stuff
00:13:22 <Pegazus> append relation upon lists
00:13:26 <shapr> palomer: Oh no, learning is hard.
00:13:33 <Pegazus> i can define ton's of usefull things with just one line with that one...
00:13:39 <ValarQ> neologism: oh, that wasn't to big
00:13:39 <palomer> as a matter of fact, learning is the hardest thing out there
00:13:41 <shapr> @quote samc
00:13:42 <lambdabot>  monads are hard, let's go shopping
00:13:45 <dons> i'm not sure of this palomer. the io monad is easy, ffi is easy.
00:13:49 <Pseudonym> Pegazus: Like an application server, you mean?
00:13:52 <Pseudonym> :-)
00:13:54 <Pegazus> haskell has no way of doing it... (you have to write 3, or 6 different functions to achieve the same result)
00:14:18 <shapr> Pegazus: Show us some code! Are relations practical in real life?
00:14:24 <Pegazus> yes
00:14:30 <shapr> Ok, where's the code?
00:14:42 <palomer> dons: it's easy for us because we've used it so many times
00:14:50 <Pegazus> you can do this:
00:14:52 <dons> palomer: i'd just prefer it if you don't greet new users with "you can't use haskell for real world programming", when half the channel is doing so on a regular basis.
00:14:52 <Pegazus> last(L, U) :- append(_, [U], L).
00:14:52 <Pseudonym> Pegazus: In the interests of full disclosure, I was one of the original Mercury group.
00:14:58 <palomer> and even then, try explaining a monad to a C++ programmer
00:15:01 <shapr> palomer: That's also true of OOP, protypical programming, etc
00:15:04 <Pegazus> what is mercury group?
00:15:07 <shapr> palomer: I've done that successfully.
00:15:15 <Pseudonym> http://www.cs.mu.oz.au/mercury/
00:15:20 <dons> yeah, and they can't even being to explain their templates to me..
00:15:30 <Pegazus> prefixes(P, L) :- append(P, _, L).
00:15:32 <Pseudonym> Probably the most successful attempt at a practical logic language.
00:15:38 <Pegazus> sufixes(P, L) :- append(_, P, L).
00:15:59 <Pegazus> sublists(S, L) :- append(CasiL, _, L), append(_, S, CasiL).
00:16:03 <cmarcelo> in FFI, I need somehow get a reference to PJERR which is "#define PJERR ((Pvoid_t)  (~0UL))" (all bits set)... how could I do that? making an ad hoc C function to return PJERR in and then import to Haskell to the correct type I want?
00:16:04 <shapr> palomer: Yeah, I feel the same way. I do use Haskell for real world programming, so I don't like it when you greet newbies with the opposite sentiment.
00:16:26 <Pegazus> split(N, L, L1, L2) :- append(L1, L2, L), length(L1, N).
00:16:31 <palomer> oh come on, hello world in c takes 15 minutes to write and understand
00:16:35 <dons> cmarcelo: if you're using a lot of #define cpp stuff, you might want to use c2hs or hsc2hs ?
00:16:39 <Pegazus> elem_in_haskell(E, L1) :- append(Principio, _, L1), append(_, [E], Principio).
00:16:42 <Pegazus> and i can continue
00:16:43 <neologism> ValarQ: I was 17 or so when I did it ;)
00:16:44 <Pegazus> for some time :)
00:17:01 <Pegazus> half the functions of the prelude of haskell for lists can be defined with that..
00:17:03 <Pegazus> :)
00:17:08 <Pseudonym> Pegazus: How many logic programmers does it take to change a light bulb?
00:17:08 <palomer> hello world in haskell takes 15 days to understand (what's bind? what does main return? what's this IO thing? what's a typeclass? what's a monad? I'm going nuts!)
00:17:18 <Pseudonym> Pegazus: fail.
00:17:18 <dons> palomer: good thing you don't teach haskell then
00:17:30 <Pegazus> <Pseudonym> Pegazus: fail. why? :)
00:17:35 <ValarQ> neologism: you were forced to code asm at the age of 17?
00:17:40 <neologism> ValarQ: yes :)
00:17:44 <mauke> palomer: I disagree
00:17:52 <ValarQ> neologism: interesting
00:17:58 <neologism> ValarQ: disgusting
00:17:59 <Pseudonym> Pegazus, have you ever TRIED to write a nontrivial program in Prolog?
00:18:04 <Pseudonym> Like, more than 1000 or so lines?
00:18:09 <shapr> palomer: Yeah, I disagree also.
00:18:13 <Pegazus> <Pseudonym>: not, and i never argued to use prolog...
00:18:16 <palomer> you could superficially explain things; however I'm of the opinion that if you go that route, you might as well not explain at all
00:18:17 <Pegazus> it was just an example :)
00:18:26 <Pegazus> i am arguing about relationships...
00:18:33 <shapr> palomer: No, superficial explanations are as necessary for C as they are for Haskell.
00:18:35 <Pegazus> that means specification vs programming...
00:18:37 <palomer> I'm sorry, but it is my opinion that if you code for the purpose of getting things done, then haskell is not the way to go.
00:18:43 <dons> luckily we do teach haskell to 1000s of people a semester, and they don't spend 15 days on hello world
00:18:47 <damg> > let heads xs = map ( `take` xs) [0..(length xs)] in heads [1,2,3,4,5]
00:18:48 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
00:18:58 <mauke> you don't need monads or bind for hello world
00:19:08 <Pseudonym> I'm arguing that there is no practical programming language in existence which embodies this paradigm, AND supports higher-level abstraction.
00:19:20 <Pseudonym> Of the kind that we're talking about.
00:19:27 <shapr> palomer: I'm self-employed, and I do think Haskell is the way to write real world code. What do you do for a living?
00:19:48 <Pegazus> what do you mean by supports higher-level abstraction?
00:20:14 <palomer> I'm a student. And if you think that industry has the best opinion on which programming language to use to get things done, then I agree with you.
00:20:21 <Pseudonym> <Pegazus> relations gives you much more "high" order than haskell high order...
00:20:28 <Pegazus> yes
00:20:29 <Pegazus> :)
00:20:30 <Pseudonym> I assume you were talking about higher-order programming.
00:20:41 <shapr> palomer: Yeah, assembler and C are obviously the way to produce safe & usable code.
00:20:54 <Pegazus> i really still don't know what higher order programming is, but well :)
00:21:09 <Pegazus> is high order curry + partial application + functions as values blah blah?
00:21:29 <dons> palomer, since you think haskell's so unsuitable for real tasks, why did you apply to google to spend your summer writing it?
00:21:33 * dons sighs
00:21:36 <shapr> palomer: Ok, you enter the ICFP contest with your choice of industry-popular language and place in the top three, and I'll start listening to you.
00:21:44 <Pegazus> yes, it's that one...
00:21:52 <palomer> dons: I'm not a particular fan of real tasks, I find them ugly
00:21:53 <Pegazus> anyway, i don't know why "high" order, but well :p
00:22:36 <shapr> palomer: Let's go for proof. Show me roughly equal code written in both Haskell and your choice of industry language and show me why the industry language is better for "real world programming".
00:22:48 <Pseudonym> First-order programs maninulate data.  Second-order programs manipulate first-order programs.
00:22:51 <Pseudonym> That's the general idea.
00:22:52 <palomer> that's hardly a proof
00:23:12 <shapr> palomer: It's actual evidence. Talk is cheap.
00:23:21 <palomer> try writing a 3d shooter in haskell
00:23:29 <integral> someone did that...
00:23:30 <palomer> or an operating system
00:23:33 <integral> and that
00:23:39 <shapr> That's a good idea, do you want to compare Frag and Quake?
00:23:40 <palomer> yes, but how good was it?
00:23:44 <dons> palomer, you know that frag was written in 12 weeks by one person..
00:23:48 <dons> which is kind of stunning.
00:24:00 <Pegazus> O_o i didn't get it, anyway...
00:24:09 <Pseudonym> As for the operating system, Linspire is doing that.  Everything but the kernel.
00:24:16 <shapr> And House has a kernel.. hmm
00:24:21 <palomer> ok, a usable operating system and a fun, performing shooter
00:24:28 <Pseudonym> Yeah, but House is a proof of concept.
00:24:36 <Pegazus> there was someone writting a operative system on pearl also
00:24:38 <integral> palomer: unfortunately Linspire *is* usable
00:24:40 <Pegazus> wich was interpreted O_o
00:24:49 <integral> Pegazus: "perl" surely?  Or do you really mean "pearl"?
00:24:52 <Pegazus> (yes, all the os was interpreted)
00:24:54 <Pegazus> pearl
00:24:57 <shapr> palomer: I don't mind people critiquing Haskell for its faults. I do mind vague unsupported claims of unsuitability.
00:25:00 <Pegazus> whatever it was
00:25:07 <palomer> linspire is written in haskell? they have a haskell file system with a haskell kernel? what about a haskell virtual memory manager?
00:25:20 <Pegazus> anyway, the fact that it "can" be done
00:25:24 <Pegazus> doesn't mean it's a good idea...
00:25:26 <dons> shapr, esp. when the person has a distinct lack of real world experience to back it up..
00:25:30 <shapr> yeah
00:25:30 <Pegazus> nor it's a good product...
00:25:34 <palomer> shapr: the fact that you're the only person I know who occasionally gets paid writing haskell code speaks for itself.
00:25:49 <Pegazus> i can write a 3d game coding all in an HEX EDITOR
00:25:53 <Pegazus> that doesn't make it a good idea
00:25:54 <Pegazus> :)
00:25:58 <shapr> What about SyntaxNinja? He has a job doing Haskell.
00:26:13 <Pseudonym> The thing is, Haskell is a user-space language.
00:26:14 <Pseudonym> IMO
00:26:18 <shapr> Or JaffaCake and Simon Peyton-Jones?
00:26:19 <Pseudonym> Or it is at the moment, anyway.
00:26:22 <ADEpt> morning
00:26:27 <shapr> privet ADEpt 
00:26:31 <Pseudonym> I don't believe that today it could be used to write a practical real-world kernel.
00:26:37 <ADEpt> shapr: where did you get that? :)
00:26:53 <shapr> ADEpt: I have russian friends. I can also say spasibo and some other random words :-)
00:26:55 <Pseudonym> OTOH, it might make some very respectable user-space servers for a microkernel OS.
00:26:58 <shemale_magic> hi
00:27:02 <shapr> hi shemale_magic 
00:27:09 <ADEpt> palomer: speaking about paid work in haskell ...
00:27:15 <Pegazus> do you know Mozart language Pseudonym?
00:27:20 <Pseudonym> A bit.
00:27:29 <kosmikus> good morning
00:27:29 <Pseudonym> I've met Peter Van Roy.
00:27:37 <shemale_magic> hey
00:27:38 <dons> oh thats right, there's 9 people in this channel who just got summer jobs writing haskell :)
00:27:43 <Pegazus> who's that?
00:27:44 <ADEpt> palomer: there are service-oriented companies where you get paid for delivering result, and language choice is often completely up to you
00:27:47 <hoan> what is the typical library for trees in haskell, Data.Tree?
00:27:48 <shemale_magic> I read some fo topminds site and thought it was spot on
00:27:51 <shapr> palomer: I want to hear specifics. If you can outline something specific, the Haskell' committee may be able to improve the language. Vague claims aren't usefut to anybody.
00:27:55 <dons> hoan, yep.
00:28:01 <dons> or roll your own.
00:28:02 <integral> dons: careful, some people got ones writing perl6 :-P
00:28:07 <shapr> shemale_magic: Have you also read the rebuttals on Ward's Wiki?
00:28:10 <ADEpt> palomer: this way i have quite a lot of haskell code doing my work and earning me money :)
00:28:11 <shemale_magic> I dont know any programming yet at 33 dream of learning ti and gettign rich
00:28:12 <Pseudonym> Peter Van Roy is the guy who created Oz.
00:28:14 <shemale_magic> am I cracked?
00:28:16 <hoan> dons: thanks very much
00:28:17 <palomer> shapr: your claims are as vague as mine.
00:28:27 <Pegazus> k
00:28:27 <shemale_magic> rebuttals on wards wiki no link?
00:28:31 <Pegazus> and what do you think of that language?
00:28:31 <Stinger_> ADEpt the advantage of that being, if they want something changed they HAVE to get you back :)
00:28:31 <Pseudonym> Mozart is an Oz implementation.
00:28:33 <shapr> palomer: I've claimed that your claims are vague?
00:28:49 <Pseudonym> It's a step in the right direction, IMO.
00:28:52 <shapr> palomer: I wrote a mailing list archive web search in three evenings with Haskell.
00:28:53 <Pseudonym> For logic languages, that is.
00:28:56 <Pegazus> haha
00:28:58 <palomer> the exact claims which would lead one to believe that my claims are wrong
00:29:02 <Pegazus> it supports theorically 8 paradigms O_o
00:29:13 <shemale_magic> windows is validating itelf a lot during ownloads altely
00:29:14 <ADEpt> Stinger_: this is true regardless of the language
00:29:14 <Pseudonym> When you get past a few, you can stop counting.
00:29:16 <shemale_magic> bastards
00:29:18 <hoan> there should be a better tree library than this!
00:29:20 <Pseudonym> C++ supports at least 12 at last count.
00:29:29 <Pseudonym> Haskell supports at least half a dozen.
00:29:37 <Pegazus> it depends in what you mean supports...
00:29:41 <shapr> I converted 45mb of ms.doc files to a custom XML flavor in four days. That included learning the openoffice xml format so I could do the conversion from there.
00:29:49 <palomer> try writing an application for interacting with a midi keyboard in haskell
00:29:53 <Pegazus> C++ supports nearly everything, but not always in a "nice" way...
00:29:54 <dons> palomer: we have one.
00:29:58 <Pegazus> that's the problem...
00:29:58 <shapr> palomer: Haskore does that.
00:29:58 <integral> haskore?
00:30:04 <Pseudonym> By "supports", I mean "can intuitively provide in a nice way, possibly given a library".
00:30:06 <dons> palomer: again and again you betray your lack of knowledge of real world haskell
00:30:16 <Pegazus> what are the 12 C++ provides? :)
00:30:22 <Pegazus> and what do you call "nice way"? :)
00:30:24 <Pseudonym> Oh, I dunno off the top of my head.
00:30:31 <palomer> haskore is for output, what about input?
00:30:41 <Pseudonym> Procedural, object-oriented, parametric polymorphism, generative programming are the main four.
00:30:52 <Pegazus> Procedural == imperative?
00:31:08 <Cale> hoan: yeah, probably, though there are enough slight variations on trees that you usually want some custom datatype, and it's so easy to define tree-like datatypes, that nobody's bothered to put them in the library, I suppose.
00:31:13 <Pegazus> we can say it supports Structured Programming too :)
00:31:14 <Pseudonym> I think so.  I've never been clear on whether there's a distinction or not.
00:31:21 <Pegazus> and event driven programming
00:31:37 <Cale> I think procedural is a subset of imperative.
00:31:43 <Pseudonym> Yeah, probably.
00:31:54 <shapr> palomer: I know that Haskore can read midi files, so I assume that would work. But still, can you critique Haskell itself for real world programming?
00:32:12 <Pseudonym> But Haskell's support for relational database programming is arguably better than that of C++.
00:32:22 <Pseudonym> Because Haskell can support it via combinators in the language itself.
00:32:22 <palomer> yes, I consider the libraries available when evaluating a programming language
00:32:33 <Pseudonym> It doesn't require parsing SQL.
00:32:36 <shapr> I want specific points. Either you don't have any and I can ignore your vague muttering, or you do have points and I should see if I can do something to improve the language.
00:32:39 <palomer> and the fact is, haskore has some C in it, for doing very real world things
00:33:32 <ADEpt> palomer: "ghc -fvia-C --dump-all" and you will see that every haskell programm could be made to contain quite a lot of C ....
00:33:33 <palomer> ignore away, water off my back
00:33:43 <palomer> I've been saying these things for ages, I don't see why you're taking issue with them today
00:33:53 <shapr> Because you have been saying them for ages.
00:34:01 <palomer> ADEpt: could be or does?
00:34:11 <Cale> Today was the day when all those days became ages.
00:34:38 <ADEpt> palomer: the edge between the two is quite artificial.
00:34:42 <shapr> Thing is, you tend to say these sorts of things about everything you talk about, so I sort of discount the overall muttering level. But when you start telling newbies these things, it doesn't seem right.
00:34:52 <palomer> I will partially retract my statement: haskell is a pain for some real world things, and less of a pain for others
00:35:07 <shapr> shemale_magic: Lots of stuff linked from http://c2.com/cgi-bin/wiki?TopMind
00:35:11 <dons> palomer: its not acceptable for you to meet the newbies with "you can't do anything real in haskell", ok? it is bad for the vibe of the channel, and pisses off the experience haskellers.
00:35:11 <Cale> which really can be said of any language :)
00:35:19 <Pseudonym> Yes, I agree.
00:35:26 <Pseudonym> I concur with what palomer just said.
00:35:34 <norpan> i've worked seven years as a programmer after university and haskell is definitely suited for "real world" programming, the big problem in the real world is that not everybody is using it :)
00:36:09 <Cale> Yeah, we're sane, it's the rest of the world that's crazy :)
00:36:13 <norpan> but we use it more and more here
00:36:36 <norpan> currently interfacing to c/c++/java via ffi
00:36:59 <Stinger_> no chance of automatic coercion in an expression like Rational > Integer ?
00:37:01 <shapr> Have you used the JVM interface stuff?
00:37:08 <norpan> no it's via jni
00:37:16 <Stinger_> hmmm
00:37:26 <Cale> Stinger_: nope, use fromIntegral to lift Integers to Rational values.
00:37:29 <Stinger_> guess I shoulda checked that before I asked 
00:37:32 <norpan> Stinger_: automatic coercion is not our style :)
00:37:45 <palomer> dons: would you rather the channel become fanatical like efnet's #java ?
00:38:00 <palomer> really, an early and generous dose of skepticism is always appreciated
00:38:01 <norpan> it's you who are fanatic
00:38:03 <palomer> even by newbies
00:38:17 <Stinger_> (1 % 4) < 1 seems to work though appears to return some weird Ratio boolean though
00:38:17 <norpan> we have experience and speak from that
00:38:33 <norpan> Stinger_: yes, 1 is automatically coerced
00:38:38 <norpan> so apparently it is our style :)
00:38:39 <ADEpt> @type (1 % 4) < 1
00:38:39 <lambdabot> Bool
00:38:43 <palomer> you're experienced in observing fanaticism?
00:38:55 <ADEpt> Stinger_: it just returns proper Bool, not Ratio
00:38:58 <dons> palomer: we've had a long tradition of encouraging beginners, going back several years since shapr started this whole thing.
00:38:58 <norpan> among othere things, but mostly experienced in programming of course
00:39:02 <Cale> Stinger_: It's an ordinary Bool -- 1 is treated as a Rational there.
00:39:07 <dons> so if you can begin by perhaps teaching them something, that would help.
00:39:18 <palomer> I often teach them
00:39:24 <palomer> you can look in the logs
00:39:35 <Stinger_> oh haha damnit, I've been thinking these weird printouts are some weird Show Ratio behaviour, but I bet its cause I turned :set -v on
00:39:47 <Pseudonym> Gotta go.  Nytol!
00:39:55 <dons> yes, i know you do teach. that's good, thankyou. the first thing you teach should not be "you can't use it for real world code. ok? what's hard about that?
00:39:59 <norpan> but the claim that haskell is not suited for "real world" programming is simply untrue for mmost real world work
00:40:30 <shemale_magic> :)
00:40:35 * integral found it much nicer than perl for some scripts to do some stats on some data
00:40:55 <norpan> if it's anything that is unsuitable for real world work it's visual basic
00:41:07 <norpan> i've had to fix bugs in such code and it ain't funny
00:41:14 <Cale> :set -v4
00:41:14 <Cale> :)
00:41:18 <palomer> however, I don't see why it would be such a bad thing that a newbie understand that the problems best solved by haskell are not what one would consider "real world"
00:41:24 <tennin> the problem I see for Haskell in the "real world" is that the Haskell people actually use, i.e. GHC Haskell, isn't very stable/mature
00:41:30 <shapr> Yeah, I had a job for a year working on a 65,000 line Visual Basic application.
00:41:31 <palomer> I'm not a used car salesman, I like to tell things how I see them
00:41:53 <shapr> palomer: What do you define as real world problems? Things that can earn money?
00:41:54 <norpan> GHC is very mature compared to other tools used in the real world, i can tell you
00:41:55 <Lokadin> say is there anyway of making Buffering so that i would be able to edit the text in insert mode?
00:42:09 <palomer> shapr: we're not getting into that again
00:42:10 <dons> palomer: because this is #haskell, you don't write real code, you're not in the postition to make that claim as if you speak for the channel, when you talk to newbies.
00:42:17 <Lokadin> cause LineBuffering is in overwrite mode, and i can't seem to get BlockBuffering to work
00:42:36 <palomer> I'm in the position of stating my opinion, if you want I'll add a disclaimer "this isn't the opinion of dons and shapr"
00:42:41 <Cale> tennin: It's not? I suppose there are occasional issues, but by and large it's seemed to me to be extremely stable.
00:42:44 <Lokadin> and well NoBuffering, doesn't even let me backspace
00:43:04 <dons> palomer: perhaps, "this isn't the opinion of the majority of haskell users, and i don't actually write any real world code"
00:43:04 <Cale> tennin: Unless by "stable" you mean "doesn't change very much"
00:43:08 <shapr> palomer: You could even say "People who make money with Haskell have a different opinion."
00:43:19 <tennin> Cale: the latter.
00:43:38 <tennin> not that change is bad
00:43:39 <palomer> ok, "all 5 people who make money with haskell beg to differ", how does that sound?
00:43:49 <cmarcelo> dons: tks. actually i was already using hsc2hs.. i've probably found the solution for my problem, using pjerr = (#const PJERR)..
00:43:53 <shapr> There are many more than five people who make money with Haskell.
00:43:57 <dons> ah, just parens, cmarcelo ?
00:44:04 <norpan> tennin: but the change is mostly incremental, plain haskell 98 code still works
00:44:10 <shapr> Intel, Xilinx, and Galois use Haskell for their work.
00:44:15 <Muad_Dibber> shapr, at least a lot of people employed by universities of course :)
00:44:25 <dons> palomer: why do you persist in trolling?
00:44:39 <palomer> I don't consider this trolling
00:44:41 <norpan> dons: probably because he is fed
00:45:02 <palomer> if you want, I'll expound upon the advantages of haskell
00:45:03 <tennin> but it makes it harder for people who don't want to get seriously involved with the language to just use it
00:45:04 <Lokadin> I dono i'm using haskell to solve a real world problem
00:45:14 <dons> palomer: just lighten up on the negativity on thew newbies, ok? that's all. 
00:45:19 <palomer> nonetheless, it's isn't better than every other programming language in every respect
00:45:28 <norpan> of course it isnt'
00:45:33 <shapr> I don't think that.
00:45:34 <cmarcelo> dons: what?
00:45:36 <tennin> this is just my perception as a relative newbie who's been frustrated trying to get GHC to compile from darcs source =)
00:45:38 <shapr> There is no silver bullet.
00:45:49 <dons> cmarcelo: oh, I was wondering about the parens there. are they needed?
00:45:55 <palomer> you guys make it sound as if there is, I just balance it out
00:45:55 <shapr> There isn't any one tool that is best for all tasks.
00:45:58 <Lokadin> i want to make an ai that would understand plaintext input and would be able to do my biding, like say play godfather, so it would download it and play it for me
00:46:03 <palomer> but, erm, I'm negative to everyone about everything
00:46:04 <integral> tennin: ouch.   use a binary package :)   personally I wouldn't compile anything from source if I didn't need to :)
00:46:04 <norpan> tennin: well compiling the compiler is not what most people do fortunately
00:46:08 <palomer> it's what I do
00:46:17 <palomer> (I call it being realistic)
00:46:51 <norpan> i call it making unsupported claims
00:46:57 <palomer> it's to balance out all those over enthusiastic people who simply get your hopes up
00:47:14 <norpan> haskell is worth getting your hopes up for though
00:47:30 <Lokadin> isn't it?
00:47:31 <palomer> norpan: the counter-claims are as unsubstantiable
00:47:35 <cmarcelo> dons: actually they aren't.. =o)
00:47:38 <norpan> it's worth learning even if your going to plug c++ for the foreseable future
00:48:08 <Cale> Haskell looked cool when I started learning it, but actually turned out even cooler than could probably have been put into words.
00:48:29 <Cale> So I don't worry about overselling it too much.
00:48:34 <Stinger_> go on, write some programming language poetry
00:48:42 <Lokadin> Cale, lol, wow that's just a ridiculous statement, i mean when you start reading it you never expect the end
00:49:07 <Cale> Lokadin: hm?
00:49:33 <palomer> ok, I'll lay off most of the negativity for newbies if it bothers you that much. Self-censorship is really hard for me, so you better appreciate it. truce?
00:49:39 <Lokadin> it's just when someone starts by saying they found it interesting in the begining, you  never expect them to later go on to how they like it even better later
00:49:49 <Cale> hehe
00:49:59 <tennin> it seems to me there are a number of extensions that are very useful/necessary in practice for a lot of real world stuff
00:50:00 <dons> ok, thanks palomer. i appreciate it, and i think others will too.
00:50:13 <norpan> palomer: it's okay to be critical but you need to back up your claims, and so far i have yet to see one single example where haskell has been unsuitable for real world work (and no, not kernel programming) most real world work is applications
00:50:28 <palomer> I mentioned a few
00:50:31 <palomer> midi input
00:50:38 <palomer> a filesystem
00:50:52 <shemale_magic> hey guys can haskeel be used to produce fast webapps?
00:50:57 <dons> palomer: you know we have 3 filesystems written in haskell?
00:50:59 <palomer> an RDBMS
00:51:01 <norpan> did you try to write those in haskell and failed due to the language?
00:51:01 <shemale_magic> is the haskeell webapps server good?
00:51:06 <Cale> shemale_magic: sure, it could be
00:51:07 <palomer> dons: stuff that people would actually use?
00:51:15 <Cale> shemale_magic: There are some libraries for that
00:51:23 <dons> well galois uses SyntaxNinja's commerically.
00:51:23 <Lokadin> say just out of curiosity is it possible to write an operating system with haskell? all issues of processing speed put aside?
00:51:31 <Cale> shemale_magic: though it's not too well-developed an area yet
00:51:35 <norpan> Lokadin: i don't see why not
00:51:36 <dons> Lokadin: yes, its called house.
00:51:37 <shapr> There is an in-memory RDBMS written in Haskell.
00:51:41 <dons> ?where House
00:51:41 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
00:51:49 <Lokadin> dons: wow cool thanks :)
00:51:56 <dons> there's also an L4 kernel written in haskell
00:52:04 <Cale> dons: oh?
00:52:07 <Kasperle> Lokadin: of course ;) processing speed aside, you can write an operating system in any programming language ;)
00:52:14 <shapr> Yeah, Rebekah...
00:52:17 <palomer> is the RDBMS completely written in haskell?
00:52:24 <shapr> palomer: Yes, completely.
00:52:27 <dons> yeah, they wrote a literate haskell l4 kernel as a prototype/verified kernel project
00:52:41 <Cale> cool
00:52:46 <dons> let me find the url
00:52:50 <Lokadin> Kasperle: really? i didn't know that
00:52:54 <shapr> palomer: But still, none of what you've said is about Haskell the language. You've only talked about applications.
00:53:04 <Lokadin> Kasperle: how about flash?
00:53:12 <Cale> I want to see an OS in unlambda :)
00:53:21 <dons> http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html
00:53:21 <shapr> Lokadin: You could write an OS in Flash, but it would hurt. Lots.
00:53:30 <Lokadin> lol okay
00:53:35 <palomer> insert "industry grade" in all the applications I previously mentioned
00:53:36 <shapr> I've recently discovered some amazing and insane things in Flash.
00:53:50 <Kasperle> Lokadin: with flash, it's probably pretty hard to interface it to your hardware, but you could write an OS that runs on the flash player as some sort of virtual machine
00:54:07 <norpan> lol, what does "industry grade" mean
00:54:08 <Lokadin> oh okay
00:54:16 <Lokadin> cool :) thanks
00:54:23 <palomer> apart from mutability, there isn't anything lacking from haskell the language, as far as I can see
00:54:41 <palomer> (though other people might prefer different kinds of abstractions)
00:54:42 <shapr> palomer: But you haven't said anything about *Haskell* yet, just about applications written or not written in Haskell. Turing completeness means that from some viewpoint, you can do anything you want.
00:54:46 <norpan> and mutability is not lacking either, if you need it :)
00:54:50 <dons> and you know how to do mutable data types in haskell, surely, palomer?
00:55:12 <palomer> dons: mutable data types? I know how to create strefs, change them, etc...
00:55:19 <dons> how do you think yi's editing buffers work?
00:55:29 <palomer> or IO refs
00:55:52 <palomer> however, it's not straight forward how one would handle mutability in haskell, and the type errors are simply baffling
00:56:01 <dons> hmm?
00:56:11 <Cale> Usually you simply avoid mutability.
00:56:25 <shapr> That's considered a feature by many.
00:56:36 <palomer> dons: hmm?
00:56:37 <norpan> exactly, most bugs in software is because of it
00:56:41 <Lokadin> what exactly is mutability?
00:56:49 <kosmikus> oh, what's this? language flamewar?
00:56:54 <Lokadin> i can't seem to find it from answers.com
00:56:54 <Cale> Lokadin: changing the value of something which already has a value
00:56:56 <shapr> kosmikus: Something like that.
00:57:04 <dons> oh, its just been a weird afternoon, kosmikus :/
00:57:12 <Cale> Lokadin: or rather, the ability to do so
00:57:21 <norpan> we're trying to convince palomer not to tell newbies that haskell is a toy language
00:57:30 <palomer> I never said it's a toy language
00:57:32 <Lokadin> Cale: oh alright, but isn't that a non, issue? can't you just create another instance? 
00:57:36 <kosmikus> dons: I'll take your word for it ;)
00:57:43 <Cale> Lokadin: right, you can
00:57:43 <palomer> and I've already agreed to tone down my opinions in front of the under aged.
00:57:57 <dons> kosmikus: any word on when the hcar comes out?
00:58:12 <kosmikus> dons: I'm working on it ... why?
00:58:15 <norpan> palomer: ok i'm sorry, i paraphrased that a bit too much
00:58:17 <palomer> say a newbie has an algorithm in mind which uses references, you'd tell him to use STRefs, right?
00:58:22 <dons> oh, just wondering if it'll make this weeks HWN
00:58:23 <shemale_magic> hmm
00:58:31 <kosmikus> dons: deadline?
00:58:35 <Cale> palomer: maybe, if they insisted
00:58:38 <dons> 24 hours.
00:58:41 <dons> otherwise next week.
00:58:43 <Lokadin> Cale: isn't that more how neurons work anyways? i mean aren't calcium bonds made first and then when neurons are recreated they are changed according to the calcium induced alterations
00:58:44 <kosmikus> dons: no then
00:58:51 <palomer> I remember the first times I encountered STRefs, the error messages were completely incomprehensible
00:58:54 <norpan> palomer: or suggest an algorithm more suited for pure programming
00:59:10 <kosmikus> dons: btw, who's responsible for the Wiki-isation of haskell.org. I haven't got anything on that afaics ...
00:59:12 <shemale_magic> so haskell can do almost anything
00:59:18 <dons> kosmikus: oh. hmm.
00:59:22 <shemale_magic> is the number of users going up?
00:59:26 <dons> John Peterson?
00:59:29 <Cale> shemale_magic: well, yeah, it's a general purpose programming language
00:59:30 <shemale_magic> can you get more work done faster with haskell?
00:59:31 <norpan> i wish haskell could clean my apartment
00:59:36 <dons> or Ashley Yakely?
00:59:43 <norpan> shemale_magic: definitely
00:59:44 <kosmikus> dons: I thought that he merely does anything except providing the machine.
00:59:44 <shapr> shemale_magic: I can
00:59:45 <Cale> shemale_magic: It seems that way, in most areas
00:59:50 <shemale_magic> wow
00:59:56 <palomer> STRefs took a week or so to get used to, and even then they could still frustrate me greatly
00:59:57 <shemale_magic> and haskell is not a lisp
01:00:00 <shemale_magic> correct?
01:00:05 <Cale> right
01:00:05 <norpan> that's why i have time chatting on irc while i'm working :)
01:00:09 <shapr> Nope, it's not lisp.
01:00:12 * shapr grins
01:00:22 <Cale> For example, I wrote a program in 1000 lines of Haskell which would have been about 15000 lines of C
01:00:46 <Cale> actually, that's closer to 500-600 actual lines, with the rest being documentation.
01:00:51 <shapr> kosmikus: Ashley Yakely
01:00:51 <dons> kosmikus: let me check who the wiki admins are..
01:01:07 <palomer> Cale: surely you exaggerate, I could probably write a haskell compiler that compiles 1000 lines of haskell to 10 000 lines of C
01:01:07 <norpan> the best thing about haskell is the type system
01:01:09 <dons> yeah, he's one of the admins.
01:01:31 <norpan> palomer: really?
01:01:46 <shapr> dons: Ashley pushed the conversion to MediaWiki and I think he did it also.
01:01:53 <dons> ah right. he's the main man then
01:02:15 <kosmikus> shapr, dons: thanks, I'll ping him then
01:02:21 <palomer> norpan: really.
01:02:25 <norpan> i have to go back to work now, because right now i'm debugging c++ so i'll need every minute i have to spare :)
01:02:30 <Cale> palomer: I'm not exaggerating -- in fact, the 15000 number isn't mine, but my prof's estimate, and he's an expert C programmer.
01:02:31 <dons> norpan: hehe
01:02:55 <dons> 1:15 isn't average, but not unusual
01:02:56 <palomer> anyways, bed time
01:02:59 <palomer> night
01:03:01 <kosmikus> dons: I currently have about 60% of the report ready. I hope to get it finished until the end of this week.
01:03:06 <Cale> palomer: I used laziness very heavily, and was using the list monad a whole lot.
01:03:07 <dons> cool
01:03:23 <palomer> Cale: right, you could code that monad in C
01:03:25 <norpan> i haven't done any comparative study so i really can't say, but i would guess that 10x the code size is not way off
01:03:41 <norpan> depends on what kind of program you're writing
01:03:44 <Cale> palomer: It would have been control-flow hell.
01:03:45 <palomer> Cale: you can write all those abstractions in C, but there won't be a type system to catch you when you screw up
01:04:08 <shemale_magic> holy shit
01:04:12 <shemale_magic> then m learning haskell
01:04:13 <norpan> well, this is assuming that you code in imperative c-style of course
01:04:14 <shemale_magic> Im
01:04:22 <norpan> shemale_magic: good for you!
01:04:27 <kosmikus> dons: HW paper finished?
01:04:37 <palomer> <comment has been censored for high negativity rating>
01:04:39 <dons> sigh. don't ask.
01:04:41 <Cale> palomer: Not elegantly
01:04:52 <kosmikus> dons: heh. Chilli told me to push you from time to time ;)
01:04:52 <Cale> palomer: and laziness is basically major code transformation
01:05:06 <palomer> who said anything about elegance:OP
01:05:08 <palomer> anyways, night!
01:05:15 <Cale> palomer: you'd have to turn data structures into recursion in code
01:05:21 <Cale> and it would be brutal in this case
01:05:27 <dons> kosmikus: yeah, thanks ;) its coming along. we'll miss the deadline though.
01:05:39 <norpan> of course, writing code in the real world is not about code size
01:05:45 <norpan> it's about maintainability
01:05:56 <tennin> even after just five months with the language, I find myself mentally translating code in other languages into Haskell or pseudo-Haskell to better grasp what the code does
01:05:57 <norpan> and the type system really helps there
01:06:05 <Cale> Well, you can't say that those aren't related either.
01:06:20 <norpan> i'd rather ahve double the size propery modularized
01:06:23 <shapr> tennin: Yeah, nowadays I write new code in Haskell first and then translate to Python, C, Flash, etc
01:06:40 <Cale> well, sure
01:06:47 <norpan> but of course they are related
01:06:50 <tennin> even while reading math books sometimes
01:06:56 <norpan> bad code tends to be big too
01:07:18 <Cale> tennin: :)
01:07:47 <Saulzar_> I definately read haskell much better than most math notation
01:07:50 <Muad_Dibber> shapr, should write tools for that :P
01:08:00 <Lokadin> i dono, after a few er weeks with haskell i started understand how useful functions are and would write in java as i would in haskell, or bash scripts, though now i try to just make my scripts in haskell for the practice
01:08:27 <norpan> damn c++
01:08:41 <Cale> Actually, probably knowing bash helped me to learn Haskell somewhat. I have a slightly odd style of bash programming though.
01:09:07 <cmarcelo> dons: well that #const thing didn't solve the problem, i need that this "pjerr" have a pointer type (in this case "Ptr WordPtr").. is it possible to get a "Ptr a" from an address..? or an (numeric) address from a "Ptr a"?
01:09:25 <tennin> (fold (+) . filter R . map x) N is sometimes easier for me to think about and manipulate than (formatted) $\sum_{R i} x_i$
01:09:30 <Cale> I tend to use pipes more than most scripts I've seen, and I'll tend to use xargs everywhere.
01:09:31 <Stinger_> bash?! O_O good lord
01:09:36 <Lokadin> Cale, i guess because of pipes and the like no? (not very familiar with many languages other than bash)
01:09:40 <Cale> yeah
01:09:44 <Cale> pipes are lazy
01:09:48 <dons> cmarcelo: well, you can take the addres of a foreign value.
01:09:59 <dons> like foreign import ccall unsafe "static stdlib.h &free" c_free_finalizer
01:09:59 <dons>     :: FunPtr (Ptr Word8 -> IO ())
01:10:05 <Lokadin> Cale: how are they lazy?
01:10:08 <norpan> cmarcelo: what was your issue?
01:10:15 <tennin> errr that is (fold (+) . map x . filter R) N
01:10:38 <tennin> ok maybe at this moment it's not easier
01:10:39 <dons> cmarcelo: or do you need th e raw machine address?
01:10:40 <dcoutts> morning dons 
01:10:56 <dons> morning dcoutts. lots of patches for you :)
01:11:08 <Stinger_> what are you and dcoutts writing?
01:11:17 <Cale> Lokadin: If you have a program which generates the list of primes, one per line, forever, you can use 'head' to get just the first 10 of them, for instance.
01:11:32 <dons> i enabled fusion for length/loop and maximum,minimum/loop too, 
01:11:38 <dcoutts> dons, cool
01:11:39 <dons> Stinger_: a string library
01:11:41 <dons> ?where fps
01:11:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:11:53 <dons> dcoutts: also, now I wonder, can we ditch the NoAcc loops types?
01:12:01 <dons> they're unused at the moment, rigth?
01:12:08 <cmarcelo> the raw machine.. i need to compare results from imported functions, which are type  "Ptr WordPtr" with this constant PJERR (0xFFFFF...) to check for errors..
01:12:15 <Cale> Lokadin: also, if a program doesn't demand input, the outputting program will block
01:12:19 <dons> cmarcelo: unwrap the ptr then?
01:12:19 <Stinger_> aussies eh
01:12:22 <dons> Ptr a = a
01:12:23 <dcoutts> dons, no they're not, map . filger becomes noAcc
01:12:36 <Cale> Lokadin: so it's like they're manipulating lazy lists
01:12:58 <Lokadin> Cale: cool, i didn't realize bash exited when the later processes exited
01:13:13 <dons> dcoutts: ah! i missed that.
01:13:39 <dons> i'll need to add some cases to tests/FusionProperties.hs for the results of that then.
01:13:43 <Cale> Lokadin: try:  yes | tr 'y' 't'
01:13:48 <Cale> as a trivial example
01:14:07 <dcoutts> dons, as for the inlinePerformIO safety condition, I think it's to do with data-flow dependencies
01:14:14 <Cale> It doesn't wait for 'yes' to finish before passing things on to tr
01:14:30 <dcoutts> dons, so all the read ones are safe because they depend on te input parameter so can't be shared
01:14:57 <vincenz> moin
01:14:58 <dons> ok, but not the writes. hence the bug you had a while back with packByte.
01:15:11 <dcoutts> dons, but the ones that create new strings have these 'constants' like mallocByteArray
01:15:23 <dons> yeah, i've dealt with those.
01:15:29 <dcoutts> which depend on nothing
01:15:31 <vincenz> woot
01:15:35 <vincenz> guess what
01:15:49 <dcoutts> dons, so yes, having dealt with those, I think that's safe
01:16:02 <vincenz> dalia lama is coming to belgium
01:16:20 <Lokadin> Cale: oh alright cool :) i get that, so is that how it works in haskell as well? though i'm assuming it does now that you've said it relates
01:16:51 <Cale> well, yeah, it's more complicated in Haskell, but the effect is about the same
01:17:35 <Cale> (With Haskell, you can evaluate the list elements out of order, and there are other data structures to think about)
01:17:43 <dcoutts> dons, oops the pastos in scanr(1) would be my fault :-)
01:17:49 <dons> i know ;)
01:17:52 <Lokadin> Cale: kk thanks :)
01:18:00 <vincenz> anyone know how to install a mail server
01:18:09 <vincenz> such that stuff can be sent to user@yourcomputer.dyndns
01:18:46 <ADEpt> vincenz: OS?
01:18:54 <vincenz> ADEpt: linux
01:19:00 <ADEpt> vincenz: distro?
01:19:03 <vincenz> ubuntu
01:19:06 <Cale> vincenz: I used to have one, but decided it was too much of a pain. Probably go with exim though.
01:19:20 <ADEpt> vincenz: apt-get install exim4-light, answer questions, you are all set.
01:19:23 <vincenz> I was thinking it'd be cool if you had a patches@yourcomputer.dyndns
01:19:24 <Cale> (unless something cooler has come along)
01:19:27 <vincenz> ADEpt: thx
01:19:31 <vincenz> and then have as backend
01:19:36 <vincenz> a signature checker
01:19:48 <vincenz> such that only people with allowed pubkey can mailsend to your repo
01:19:52 <vincenz> without you having to weed through it
01:19:57 <vincenz> this might be great for dons  and dcoutts 
01:21:07 <Lokadin> oh so say, does anyone know of how it is that i can get insert mode in a haskell program? cause when i use line editing it lets me edit the line but in overwrite mode
01:21:30 <vincenz> Lokadin: haskell program?
01:21:38 <vincenz> Lokadin: what's the interface? curses?
01:21:44 <Lokadin> yea, LineBuffering is the mode i'm taking about
01:21:45 <Lokadin> no just input
01:21:51 <Lokadin> for getLine
01:21:53 <vincenz> oh
01:22:05 <Lokadin> i would mind a Block
01:22:11 <dons> Lokadin: use readline?
01:22:26 <dons> i.e. instead of getLine, used 'readline'
01:22:40 <vincenz> I would think the getline version would be dictated by your environment
01:22:43 <Lokadin> er well it's just for like making blog entries, i mean i don't need tab completion or anything
01:23:03 <Lokadin> oh yea? hmmm
01:23:10 <Cale> Lokadin: sure you haven't hit the insert key?
01:23:23 <Lokadin> er pretty sure but let my try again
01:24:04 <dons> dcoutts: perhaps add a little blurb in Fusion.hs about when and how NoAcc loops get created.
01:24:11 <dcoutts> ok
01:24:20 <vincenz> dons: how does the previously mentioned idea sound?
01:24:29 <dcoutts> dons, as for maximum, that's a case that will get optimised when we add NoArr
01:24:37 <Cale> Lokadin: hmm, actually, I can't use the arrow keys at all with getLine, so yeah, just use readline, probably
01:24:39 <dcoutts> not to be confused with:
01:24:41 <dcoutts> @arr!
01:24:41 <lambdabot> This is the END for you, you gutter-crawling cur!
01:24:55 <dons> dcoutts: ah, yes. good
01:25:02 * dons -> dinner
01:25:22 <dcoutts> dons, so that'll make all folds etc faster because they will not need to allocate a destination array
01:25:24 <vincenz> anyone hear anything about jip's gameboy emulator?
01:25:29 <Lokadin> yea i just checked again, and it works fine on the bash command prompt, i can insert, but not in the haskell program
01:25:49 <Lokadin> i have my bash set to vim though i don't think that should matter
01:26:15 <vincenz> odd
01:26:17 <Cale> Lokadin: I think it just doesn't let you edit, which is sane, since neither does anything else by default
01:26:27 <vincenz> Cale: std::cin would afaik
01:26:31 <Lokadin> it does let me edit the line
01:26:35 <Cale> (though you should be able to backspace if you have line buffering)
01:26:46 <eivuokko> Atleast in Windows you normal cmd-prompt editing with getLine.
01:26:47 <vincenz> Cale: any normal linebufferred reading allows some sort of editing
01:26:50 <Lokadin> i can backspace, and move around my cursor, but it just overwrites things
01:26:59 <vincenz> eivuokko: *shudder*
01:27:12 <Saulzar_> Funny, using readline in ghci gets you the history in ghci.
01:27:29 <Cale> Lokadin: odd, I don't get that effect -- are the results represented in the returned string?
01:27:30 <eivuokko> vincenz, ?
01:27:42 <Cale> (or is it just producing gibberish when you do that?)
01:27:46 <Lokadin> Cale:  hmmm let me check
01:28:05 <Cale> That might just be an effect of your terminal
01:28:48 <dcoutts> dons, oh, hmm ignore my comment patch I just sent, I think it causes conflicts
01:29:09 <Cale> 'cat' doesn't let me do any line editing (apart from backspace), so I wouldn't expect getLine to do much better
01:29:12 <Lokadin> oh wow yea it's some kind of gibberish
01:29:14 <norpan> i can't edit when i do "getLine>>=print" in ghci and this is on linux in a gnome-terminal
01:29:16 <Cale> yeah
01:30:48 <Lokadin> hmmm, so readline is the only way to get good line editing? is there perhaps some way to use yi for it's line editing, er like run a terminal in it maybe or a program? i mean it can edit files and has keyboard shortucts and all
01:31:05 <dcoutts> dons, yes, definately ignore the patch I jsut sent. You've already made that change.
01:31:54 <norpan> it works if i do
01:31:57 <norpan>  IO.hSetBuffering IO.stdin IO.LineBuffering>>getLine>>=print
01:32:29 <norpan> maybe getLine should set LineBuffering automatically?
01:32:30 <Lokadin> what does >> do?
01:32:40 <norpan> sequential io statements
01:32:49 <norpan> just like new lines in a do block
01:32:55 <mauke> a >> b is do {a; b}
01:33:03 <Lokadin> oh okay
01:33:21 <norpan> it's just for compactness here
01:33:35 <mauke> getLine >>= print is do {tmp <- getLine; print tmp}
01:33:40 <Lokadin> so would that then print the input?
01:33:47 <norpan> it would show the string
01:33:50 <norpan> yes
01:33:51 <cmarcelo> to unwrap a "Ptr a", would something like "let (Ptr jj) = j" with [ j :: Ptr a ], be enough?
01:34:15 <aleator> dcoutts: Would this be c from c2hs standpoint: "return (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };"?
01:34:22 <norpan> so as to see if the backspaces are in there
01:34:43 <norpan> and they are not if i do that hSetBuffering bit
01:34:45 <dcoutts> aleator, not too sure
01:36:42 <aleator> dcoutts: Well "The symbol `{' does not fit here.".. (sorry 'bout bothering you but I don't know better source of answers :)
01:37:35 <Lokadin> hmmm it tells me variables not in scope IO.stdin and IO.LineBuffering as well as IO.hSetBuffering
01:37:39 <norpan> that is a struct of four floats cast to the type __m128
01:37:46 <norpan> Lokadin: you need to "import IO"
01:37:54 <norpan> and if you do that you can omit the "IO." prefix
01:38:00 <Lokadin> norpan: well i have imported System.IO
01:38:22 <norpan> oh, ok, just scrap the prefix then
01:38:26 <Lokadin> kk
01:39:07 <Lokadin> hmmm that's odd that it,s not working, maybe it's cause i'm just in normal command line mode, though i mean will using an xterminal make any difference?
01:39:44 <norpan> the terminal you use will have something to say about this yes
01:39:58 <norpan> because it's the terminal that does the backspacing etc
01:40:15 <norpan> doing that hSetBuffering is sending some control code to the terminal
01:40:30 <Lokadin> but well i mean i just have a pure bash terminal, on Alt+F2, agetty or what not
01:41:02 <Lokadin> isn't that like the standard or what not?
01:41:19 <norpan> did you put that hSetBuffering command in
01:41:53 <Lokadin> it was already there
01:42:56 <norpan> well then i don't know
01:42:59 <Lokadin> :(
01:43:05 <norpan> i suppose talking to terminals is black magic
01:43:13 <Lokadin> kk well thanks for the help anyways :)
01:43:28 <Lokadin> yea, i run into many "mysterious problems" 
01:43:37 <norpan> sometimes backspace doesn't work, but delete does
01:43:38 <Lokadin> hmmm
01:43:42 <norpan> or shift-backspace
01:44:06 <Lokadin> isn't that on some very archaic systems?
01:44:11 <Cale> I haven't had backspace/delete issues for a long time
01:44:20 <norpan> i have them in putty
01:44:29 <norpan> i need to use shift-backspace sometimes
01:44:30 <Lokadin> yea me niether, i mean backspace works in getLine
01:44:32 <norpan> unclear when
01:44:40 <norpan> Lokadin: oh, it works?
01:44:42 <Lokadin> that's not really the problem
01:44:43 <Lokadin> yea
01:44:44 <norpan> what didn't work
01:44:52 <Lokadin> it's that it's in overwrite mode
01:44:57 <Lokadin> instead of insert mode
01:45:11 <norpan> ho can it insert if you're only using backspace?
01:45:18 <Lokadin> yea
01:45:21 <Lokadin> no problem
01:45:38 <Lokadin> just if i use arrow keys to go back
01:45:44 <norpan> oh, arrow keys
01:45:55 <norpan> that's a completely different ballpark
01:45:57 <Lokadin> then the caret is moved, but it just overwrites what was written
01:46:05 <Lokadin> actually maybe that is just because it's the terminal
01:46:08 <norpan> arrow keys doesn't work in my getLine
01:46:14 <norpan> just backspace
01:46:19 <Lokadin> hmmm
01:46:26 <norpan> i suppose you need something more fancy than getLine
01:46:48 <Lokadin> yea? what do you think would be good?
01:47:11 <Lokadin> i was sorta hoping it would be possible to open yi, i wouldn't mind if it didn't clear my whole screen though
01:47:12 <norpan> http://www.haskell.org/ghc/docs/latest/html/libraries/readline/System-Console-Readline.html
01:47:33 <norpan> don't know how that works though, never used it
01:47:40 <Lokadin> i've used it before
01:47:52 <norpan> in the "real world" we don't do commandline input :)
01:48:07 <Lokadin> why what do they do in the "real world"?
01:48:15 <norpan> we do gui
01:48:26 <ibid> in the real world, we do washing machines
01:48:30 * Lokadin makes a sour face
01:48:37 <ibid> (for some values of "we")
01:48:42 <norpan> ibid: :)
01:48:50 <Lokadin> i really don't like gui's they are soo messy
01:48:58 <norpan> make a washing machine i could program, in haskell
01:49:08 <Lokadin> i always feel dirty when using gui's
01:49:09 <norpan> the current programming language on my washing machine is too complex
01:49:24 <Lokadin> i bet it is
01:49:32 <Muad_Dibber> norpan, that is because it was designed to be understood by women only.
01:49:35 <norpan> if we don't do gui we do everything with reading from files and by program arguments
01:49:54 <Lokadin> norpan: actually i know some really simple chips just use basic
01:50:12 <norpan> i never understood why i must choose both program and temperature, when i have 20 programs and each is designed for a specific temperature
01:50:36 <norpan> do i really need 100+ combinations when washing my clothes
01:50:40 <Lokadin> norpan: i don't understand why programs would require temperature
01:51:03 <norpan> there is a chart in the manual with program number and corresponding temperature
01:51:10 <Lokadin> oh
01:51:15 <norpan> but i still need to enter the temperature separately
01:51:16 <Lokadin> wow that's a crazy washing machine
01:51:23 <norpan> it's italian
01:51:29 <pejo> norpan, it's just a case of bad design, which is quite common. Someone wrote about a stove that said "Err" on the display when he did something perfectly normal like turning the knobs. 
01:51:49 <norpan> pejo: yeah
01:51:56 <Lokadin> damn
01:52:01 <pejo> (Why did you get an italian washing machine?)
01:52:07 <norpan> it was cheap
01:52:12 <norpan> and got good reviews
01:52:21 <norpan> not for the user interface hopefully
01:52:42 <norpan> also it has a build in tumbling machine, perhaps that's why it's so complicated
01:52:48 <pejo> Heh, had I been faster I would have said "And now we know why :-)". 
01:53:09 <norpan> but it cleans my shirts real well
01:53:15 <Lokadin> that's good
01:53:31 <norpan> i'll have to live with it's quirks
01:53:49 <norpan> i'll just imagine i'm at work trying to debug sombody elses c++ code
01:54:58 <Lokadin> i dono, but personally i think it's more natural to have a chronological interface of sorts, a console is more natural than say a gui, because we like in one dimension of time so we are used to leaving things we have done behind and just the things we are currently using should be available here, other than say subconscious processes like anti-viruses if necessary
01:55:45 <Lokadin> i mean a major problem on windows, or with most gui interfaces, is you leave a lot of shit open and get distracted from your goal, so it's hard to really accomplish things
01:56:22 <Lokadin> if however you have a constand reminder of where you were at, or the ability to check and not have irrelevant things distract you, then you would be much more productive
01:56:23 <davidhouse> but point and click is very convenient and productive.,
01:56:48 <davidhouse> besides, i like being on IRC, coding and browsing at the same time.
01:56:50 <norpan> Lokadin: i suppose it depends on what you're doing
01:56:51 <Lokadin> perhaps it could be, but i think just asking your computer and it doing what you ask is faster
01:57:35 <Lokadin> norpan: true, but who ever said you can't have split windows of chronological things, or different desktops if necessary
01:57:47 <norpan> not me anyway
01:57:48 <norpan> :)
01:58:06 <Lokadin> i mean multi tasking would work better because you would remmber and see things you needed for this task and remmber where you were in your train of thought
01:58:09 <norpan> most of the stuff i do in haskell here at work are just batch processing things
01:58:49 <Lokadin> well i meant for the end user
01:58:51 <pejo> Lokadin, there is nothing inherent in a GUI that says you aren't allowed to be reminded of where you are. Nielsen (?) advocates that people should do that for webpages, for example.
01:59:22 <norpan> Lokadin: well, what kind of application are you doing?
01:59:48 <Lokadin> well of course not, it can still be graphical but it's just really hard to do with windows, maybe point and click is the way, but i personally don't agree with htmml
01:59:58 <norpan> doing things by prompting is a good way to hinder people to do things in the order they prefer
02:00:04 <mauke> what do you think about this syntax: http://rafb.net/paste/results/RuBKmf98.html ?
02:00:30 <Lokadin> norpan: well i'm doing several things at once, cause i have lots of things that would be necessary for it to actually work together
02:00:47 <Lokadin> er one sec 
02:01:51 <Lokadin> mauke: you weren't talking to me were you?
02:02:18 <mauke> to anyone who wants to have a look
02:02:26 <Lokadin> kk
02:03:07 <norpan> mauke: hey, what language is that?
02:03:19 <mauke> something in my head :-)
02:03:23 <norpan> oh
02:03:34 <Lokadin> oh crazy
02:03:49 <davidhouse> mauke: weird. statically typed C?
02:04:10 <davidhouse> why not just use haskell?
02:04:28 <norpan> "almost, but not completely, unlike c"
02:04:35 <mauke> norpan: yep
02:04:37 <Lokadin> would it make faster code?
02:04:48 <mauke> I want something that looks similar to C
02:04:54 <norpan> i hop i got the hhgtg wording right
02:04:56 <mauke> also, mutables and side effects
02:05:02 <norpan> i've only read it in swedish
02:05:25 <shapr> mauke: Ask on the lambda-the-ultimate.org forum about that syntax.
02:05:30 <norpan> hhgttg
02:05:37 <mauke> let me see
02:07:47 <Lokadin> it's soo hard to imagine how far away irc is from the world of flesh and blood, in the sense that the people that you know and how you interact with them, for me at least is radically different here, than say with my friends
02:08:11 <shapr> You mean you can't talk to your meatspace friends about type theory?
02:08:29 <Lokadin> nope, or anything too deep computationally
02:08:43 <shapr> Same for me. This is my academic refuge.
02:08:43 <davidhouse> shapr, why, can you?
02:08:52 <davidhouse> heh, yep.
02:08:57 <shapr> I've tried actually.
02:09:02 <Lokadin> programming and and scripting is beyond them
02:09:06 <shapr> But most people just don't care.
02:09:19 <davidhouse> although i do have a good friend who i could teach this stuff. he doesn't program much but we talk a lot about maths/physics.
02:09:22 <shapr> If the program vaguely does what they want, that's all of computers that is important to them.
02:09:35 <Lokadin> i have one friend that has some basic understanding but he's mainly a windows user and he's going into commerce so i'll probably lose him soon
02:09:45 <norpan> fortunately, i have a lot of friends from university
02:09:56 <shapr> I think it's a personality difference for the most part. I am driven to understand anything that I don't already.
02:09:56 <norpan> (un)?
02:10:36 <shapr> I must explore the unknown.
02:10:39 <davidhouse> it's a shame really.
02:10:49 <norpan> this week-end i had my 30yo birthday party and i can assure you there were a lot of drunken discussion about things that would make any professor proud :)
02:10:54 <shapr> hah
02:10:55 <davidhouse> the best way to affirm you know something is to teach it to someone
02:11:04 <shapr> davidhouse: truly
02:11:19 <shapr> I've learned much from teaching on #haskell.
02:11:30 <norpan> davidouse: very true
02:11:56 <Lokadin> davidhouse: for sure,
02:12:01 <shapr> I've tried to teach my best friend from the US about Linux, programming, etc but he doesn't really want to know :-(
02:12:10 <shapr> Not even when he got a job doing Linux stuff.
02:12:28 <shapr> Some people just don't learn for fun.
02:12:29 <damg> then it is useless - without a wish you'll fail :D
02:12:55 <shapr> Yeah, motivation is the starting point.
02:13:15 <davidhouse> i've tried to get one of my friends over to linux
02:13:24 <Lokadin> yea, wow i never really realized how few and far in between then we must all be if that's how rare meatspace understanding of these things is
02:13:38 <davidhouse> sadly he's the graphics manipulation type and there's nothing on linux that compares to photoshop
02:13:48 <davidhouse> (gimp gets close, but it's still subpar)
02:13:49 <shapr> I think interest is rare. Understanding just happens if you have interest.
02:14:15 <norpan> but at least gimp is cheaper!
02:14:27 <shapr> Like when I tried to explain to someone that salad :: [Lettuce] .. they didn't get it, and didn't really care.
02:14:30 <damg> davidhouse, there was a powerful app written in freepascal available for everything
02:14:31 <norpan> free gimps for everybody!
02:14:38 <Lokadin> i personally have been campaigning open source ever since grade 10, i've done speeches and stuff, but i never really knocked into any other supporters though i know a few users, though usually they are more about pirating things and hacking
02:14:43 <damg> costed 30 bucks and was supposed to be available for everything but toasters
02:14:47 <shapr> Yeah, pirating pisses me off.
02:14:53 <shapr> salut Lunar^
02:15:06 <damg> http://www.kanzelsberger.com/
02:15:10 <damg> pixel editor
02:15:12 <damg> got nice notes
02:15:20 <damg> ok, brb in 15 minutes, gotta change wlan
02:15:37 <shapr> The way I see it, the laws are all or nothing. You can either pay for software according to law, or you can not expect police to catch people who break into your house.
02:15:45 <shapr> If you don't like the laws the way they are, change 'em!
02:16:16 <davidhouse> hmm
02:16:21 <davidhouse> i might learn emacs lisp.
02:16:27 <shapr> It's even more so for programmers. I write code. I want people to pay me for the code so I can eat. Some code I release under the GPL or BSD license. I don't ask to get paid for those.
02:16:38 <Muad_Dibber> shapr, agreed.
02:16:54 <shapr> When I don't get paid (which has happened more often than you might think), I want the laws to come to my rescue.
02:17:03 * davidhouse wants to write a php-mode that Doesn't Suck.
02:17:14 <shapr> Are you using mmm-mode?
02:17:23 <davidhouse> goodness no.
02:17:39 <davidhouse> i tried it.
02:17:46 <vincenz> dcoutts: did you see the suggestion I mentioned for you and dons' darcs situation
02:17:49 <shapr> Anyway, pirating is crap. Hacking of the "explore the world" is cool. Cracking is crap.
02:18:04 <norpan> the big problem i see with pirating is not that microsoft/adobe lose money (they probably don't) but that people get sucked into this "it's free because i can copy it" attitude
02:18:06 <Lokadin> i dono, i'm really not for proprietary software, but i prefer to support alternatives that will improve as more people use them, as opposed to ones that will just increase in the ability to brake down from far too many million users using the same software for too many million uses for which the company that creates it has no capacity to sustain 
02:18:15 <davidhouse> but it didn't seem to work and i couldn't really be bothered to configure it. it just made all the PHP in a file grey when i found a mixed file.
02:18:17 <shapr> Lokadin: I'm totally with you there.
02:18:26 <Lokadin> :)
02:18:57 <shapr> The most sucky part about closed source apps is that I can't fix them!
02:19:10 <davidhouse> hah, right.
02:19:10 <Lokadin> yea, for sure
02:19:11 <Saulzar_> More often than not people who pirate software simply wouldn't use software at all as an alternative. Piracy of windows served MS well.
02:19:18 <shapr> I am willing to fix something that I'm using when it breaks. And I'm willing to send in a patch. But I can't do that with, for example, Windows.
02:19:21 <norpan> photoshop is one example
02:19:27 <davidhouse> the other thing to note is that opensource has now become as innovative as closedsource.
02:19:32 <norpan> how many would actually buy photoshop if it couldn't be copied
02:19:41 <bolrod> shapr: would you with windows? :P
02:19:49 <shapr> I would, actually.
02:20:05 <norpan> shapr: but instead you choose to copy it? :)
02:20:11 <shapr> Like when my mother has problems configuring the Windows network stuff in her library.
02:20:31 <shapr> norpan: If you mean clone windows by using Linux, then yes.
02:20:35 <norpan> oh
02:20:53 <shapr> I haven't had a working copy of windows since 1999.
02:21:16 <shapr> Actually, I found a copy of win95 on a ... 10gb? drive I had in a drawer. I went to boot the debian cd and it booted the win95 copy on the drive!
02:21:37 <shapr> I was terrified for a moment, thought win95 had infected my debian boot CD somehow.
02:21:43 <Lokadin> lol
02:21:47 <Lokadin> that's hillarious
02:21:51 <boegel> shapr: :)
02:21:54 <bolrod> :]
02:22:19 <boegel> I'm planning to install Mac OSX on my P3 1Ghz I have at home, but I'm not sure it'll be powerfull enough though
02:22:40 <shapr> Oh, I also have a copy of win3.1 on 3.5 double density diskettes. It came with the 40MHz toshiba laptop someone gave me last year.
02:22:53 <Razor-X`> I'm calling hWaitForInput and binding its return value to a result and printing the result in an IO function, but nothing's printed.
02:23:09 <davidhouse> @where past
02:23:09 <lambdabot> I know nothing about past.
02:23:10 <davidhouse> @where paste
02:23:10 <lambdabot> http://paste.lisp.org/new/haskell
02:23:15 <davidhouse> Razor-X`: pastebin your code.
02:23:24 <Razor-X`> Ok.
02:23:31 <Lokadin> shapr: are you buy any chance those people that have computers lieing around as if they were collectable game cards, that and other computer periphery?
02:24:01 <norpan> shapr: ah, i see you answered another question, not my photoshop one
02:24:02 <shapr> Er, probably.
02:24:03 <norpan> sorry
02:24:13 <shapr> norpan: Oh what was the photoshop question?
02:24:17 * shapr scrolls back
02:24:24 <norpan> how many would actually buy photoshop if it couldn't be copied
02:24:38 <shapr> Oh, many of my friends would, and do buy photoshop.
02:24:46 <norpan> that's what i mean by the "i can copy it, therefore it's for free"
02:24:50 <norpan> shapr: yes of course they do
02:24:55 <Saulzar_> All those which use it for thier work, the rest would use paintbrush or gimp
02:24:55 <norpan> but that was not the question :)
02:25:03 <shapr> My graphic designer friend spent $2500 on her laptop and $3500 on her software.
02:25:19 <davidhouse> wow.
02:25:19 <shapr> How much gimp enhancements could you get for $3500 I wonder?
02:25:20 <bolrod> O_o\
02:25:31 <shapr> Also, that was only three or four apps.
02:25:35 <davidhouse> i could get, like, seven laptops for that.
02:25:38 <shapr> She's saving up for other apps.
02:25:42 <Saulzar_> How many hours does that pay a programmer for? I suspect you get a bad deal :)
02:25:49 <ulfdoz> Do I have to be graphic designer to afford this?
02:25:53 <davidhouse> give me emacs, irssi, darcs and ghc and i'm set :)
02:25:55 <norpan> davidhouse: wow, cheap laptops
02:26:13 <davidhouse> @google $900 in GBP
02:26:14 <lambdabot> US$ 900 = 482.263423 British pounds
02:26:21 <davidhouse> okay, yeah, that's a bit cheap.
02:26:37 <Lokadin> yea, i read an article that said only about 18% of what microsoft profits from cd sales actually goes to programming
02:26:45 <shapr> She quit her job and went freelance. Her ex-company gave her $13,000 worth of stock photo discs because she's done so much for them the last few years.
02:27:01 <Lokadin> though with retail overhead that's about 10% of what you pay for, so the other 90% is overhead
02:27:23 <Lokadin> shapr: wow that's cool
02:27:29 <shapr> When I hear about costs like that, I realize that I can afford my lifestyle only because I insist on open source.
02:27:48 <shapr> I don't actually need to make that much money. It's sort of like not having to pay taxes or something :-)
02:27:59 <Lokadin> shapr: and/or non-pirated software
02:28:11 <Saulzar_> You might be 5 times more productive and make 5 times more money if you used some "real" software ;)
02:28:11 <Lokadin> i mean and
02:28:31 <Lokadin> Saulzar_: for graphics not coding though
02:28:48 <bolrod> you could just buy alot of pens and papaer
02:28:49 <bolrod> paper
02:28:50 <Saulzar_> Hehe, yes well.
02:28:50 <davidhouse> Saulzar_: true. but five times the headache getting software from different vendors to interop :)
02:28:51 <bolrod> and a scanner
02:28:52 <bolrod> :x
02:29:05 <Razor-X`> Nevermind, I fixed it.
02:29:13 <shapr> Saulzar_: Before 2000 I did use "real" software. My biggest problem then was that I would get irritated at bugs in software and have to work around them, and that would slow me down.
02:29:14 <Razor-X`> Darned PEBKACs.
02:29:16 <davidhouse> bolrod: and acetate. old skool layers :)
02:29:26 <bolrod> :)
02:29:38 <shapr> I can work fast when I get into the flow, but anything that rips me out of that really slows me down.
02:29:49 <Lokadin> i think the cat finds me to be a terribly annoying bed warmer
02:30:14 <davidhouse> great. i've got so accustomed to emacs i've forgotten how to open files in other editors.
02:30:36 <Lokadin> shapr: that's why i was talking about chronological interfaces :)!
02:30:38 <bolrod> file>open ?
02:30:40 <bolrod> xD
02:30:53 <damg> back
02:31:09 <shapr> Saulzar_: For example, people tell me that Eclipse does great things for Java dev, but I immediately start missing emacs-shell, gnus, irc, macros, and everything else.
02:31:15 <Lokadin> shapr: you would just be so much more productive if you only saw things relative to your goal
02:31:17 <shapr> Maybe it's just what you get used to...
02:31:21 <davidhouse> bolrod: yeah, but i stared and my keyboard thinking "how is this done?". my fingers reached for c-x c-f but i knew it wouldn't work :)
02:31:29 <davidhouse> shapr, what does gnus actually do?
02:31:37 <shapr> Pretty much everything.
02:31:53 <bolrod> ctrl+o probably works for 95% of the editors :]
02:31:56 <davidhouse> :P what is it?
02:32:15 <shapr> You know the learning curve and power return of switching from nano to emacs? You get that same curve all over again when you learn gnus.
02:32:25 <Lokadin> davidhouse: newsreader and mailreader by portage description
02:32:30 <shapr> Gnus started out as a mail & news reader.
02:33:04 <shapr> And it does that... but it also does just about anything else along those lines that you can imagine.
02:33:14 <shapr> You can subscribe to an RSS feed as a gnus group.
02:33:36 <shapr> You can use collaborative scoring systems like that thing at MIT.. ANTS? Lens? I forget the name.
02:33:49 <shapr> It supports more mail & news formatting standards than I've ever heard of.
02:34:14 <shapr> Ever heard of SOUP packets?
02:34:22 <davidhouse> argh. searching for "gnus" finds a load of things to do with "GNUstep".
02:35:01 <Lokadin> shapr: gnus is an emacs plugin :(
02:35:31 <Lokadin> i dono how to use emacs
02:35:45 <shapr> Well, it's probably worth learning.
02:35:52 <davidhouse> Lokadin: learn it and count it as a life skill.
02:35:57 <Lokadin> i dono, i already know vim
02:36:07 <shapr> I know vim too. Vim is good for many things.
02:36:22 <Lokadin> and i could never figure out how to do visual block mode in emacs
02:36:51 <Stinger_> visual block mode?
02:36:59 <Lokadin> C-v
02:37:24 <Muad_Dibber> Who needs vim when we have small, simple, and fast programs like Eclipse?
02:37:37 <davidhouse> hah! small, simple?
02:37:44 <Muad_Dibber> (note: that was meant as a joke)
02:38:16 <Lokadin> it's the most useful thing in the world i think, you can add comment to the begginning of every line that you select say
02:38:26 <Lokadin> or modify selected text in a certain way
02:38:40 <davidhouse> Lokadin: what does it do precisely?
02:38:40 <Lokadin> i believe it's based on the replay command q
02:39:04 <Lokadin> davidhouse: it's an editing mode that lets you edit several lines simultaneously
02:39:21 <vincenz> how do you mke codependent classes?
02:39:36 <Lokadin> vincenz: are you talking to me?
02:39:42 <vincenz> nope asking in general
02:39:44 <Lokadin> kk
02:39:50 <vincenz> I guess I need MPT
02:39:51 <Lokadin> cause i have no idea
02:39:52 <vincenz> MPTC
02:40:10 <vincenz> class (Monad m) => Foo s i where foo :: s a -> m i
02:40:26 <vincenz>  bar :: s a -> i -> m (s a)
02:42:48 <shapr> Lokadin: In emacs you can select a bunch of lines and then do M-x replace-regex, or you can define a macro to do certain steps over and over.
02:43:03 <shapr> Lots of other ways to do automatic text modification in emacs.
02:43:23 <davidhouse> emacs needs better PCRE support, that's one thing.
02:44:12 <Lokadin>  so yea, anyone think it's possible of say making an interface sorta like a hybrid of the command line and yi/screen, so say commands would be seperate object windows of sort, and they would move up as you typed new things, but you could say hold the output of one at a certain level to be reminded of what it does, or even run a program in it like yi, though i guess that is a lot like screen..
02:45:49 <Lokadin> shapr: yea, macro is how it's accomplished in vi as well, another problem i experience a lot is actually that i just have trouble pressing ctrl and another character, partially because i use dvorak and well there are no letters on the keys
02:46:33 <Lokadin> hmmm
02:47:06 <Lokadin> i just don't really like screen because i can't take like have a status bar
02:47:20 <Lokadin> or save say my layout
02:47:29 <Lokadin> and switch to another "desktop"
02:47:39 <integral> hmm, I thought you could turn on a status line
02:48:14 <Lokadin> i mean i can do these things in say wmii, but i still can't save the layout, though it should be possible, i have no idea how easily though
02:48:23 <Lokadin> integral: really? 
02:48:30 * Lokadin goes to look in the manpages further
02:48:46 <mauke> I have a status bar
02:48:54 <integral> s/manpages/texinfo/
02:48:55 <mauke> it says  0* bash  1 bash  2 bash
02:49:14 <shapr> Lokadin: I use dvorak too
02:49:22 * integral sees "0-!$ mutt  1*$ mutt  2$ ssh  3$ su  8!$ mutt"
02:49:30 <shapr> At least, it started out being dvorak in 1992... but I've modified my layout dramatically since then.
02:49:41 <Lokadin> shapr: oh wow cool
02:50:13 <Lokadin> mauke, integral, imeant date current song in playlist and the weather
02:50:39 <davidhouse> shapr, Lokadin: what's dvorak like?
02:50:45 <Lokadin> as well as my load and other things i want to be able to check frequently
02:51:03 <integral> Lokadin: oh, split screen, and have that displayed in one of them
02:51:23 <Lokadin> davidhouse: feels very natural, but i can't tell if it feels more natural than qwerty used to feel, or if it's just my mind playing tricks on me
02:51:43 <Lokadin> integral: yea, but when i restart it i will have to recreate it all, and that is the pain
02:51:55 <integral> you can have screens created in your .screenrc
02:52:08 <integral> or create them from a shell script tooo
02:52:27 <Lokadin> integral: but not their split status, and the split screen requires a line just to show it's there
02:52:47 <integral> aye, that's true
02:52:56 <davidhouse> tip of the day: use slightly bigger fonts in your editor than you're used to. when compiling GTK-emacs, the fonts ended up about 20% bigger and i love it :)
02:53:46 <Lokadin> davidhouse: i agree, but then it makes your monitor feel small if it's 14" like mine :(
02:53:55 <Lokadin> i use that for reading though
02:54:09 <dcoutts_> vincenz, what suggestion was that?
02:54:51 <dcoutts_> aleator, yeah, sorry it looks like c2hs doesn't grok that. It's not clear to me if it's stardard C either.
02:55:29 <Lokadin> yea, i also don't agree with how consistancy has been destroyed and all the interfaces are so different for everything and terribly unintuitive to a new user
02:56:10 <Lokadin> grep only seems like what it does after you use it a lot
02:56:58 <Lokadin> select would be a more intuitive command, but we don't really know for say other languages or even cultures, so i was thinking having a command line with a thesaurus for understanding what a user wants
02:57:21 <Lokadin> could also perform actions based on interpertations of plain enlish
02:57:25 <Lokadin> english
02:57:30 <aleator> dcoutts_: jep. Why does c2hs parse that, it is a function body? But any ideas on what I can do about it?
02:58:12 <dcoutts_> aleator, sure c2hs will parse the whole header including any inline functions
02:58:24 <dcoutts_> aleator, what header file was this from?
02:59:24 <aleator> dcoutts_: /usr/lib/gcc/x86_64-redhat-linux/4.0.2/include/xmmintrin.h. do you wish me to send it?
03:00:25 <Lokadin> so does anyone really know why the command line really hasn't seen any major improvements recently? i mean is there a reason besides disinterest?
03:00:49 <dcoutts_> aleator, s'ok I've got a copy
03:00:59 <dcoutts_> aleator, so what are using unsing that #includes that?
03:01:33 <Stinger_> ok how can I get a random number
03:02:18 <davidhouse> @hoogle Random
03:02:18 <lambdabot> Random :: module
03:02:18 <lambdabot> System.Random :: module
03:02:18 <lambdabot> System.Random.Random :: class Random a
03:03:30 <norpan> Lokadin: disinterest is probably a strong reason
03:03:48 <dcoutts_> Lokadin, and backwards compat is another
03:04:06 <aleator> dcoutts_: Well.. It crops up from somewhere in opencv, but indirectly. I'm not much of c-programmer. Is there anything that tracks this sort of thing?
03:04:21 <Stinger_> I was thinking I probably want to use randomIO, but I'm not quite sure what to do with it
03:04:38 <Lokadin> dcoutts_: you mean how shells should all work the same in bash?
03:04:42 <norpan> nothing beats the gruesome force of disinterest
03:04:49 <norpan> lunch
03:05:11 <Lokadin> yea
03:05:44 <Lokadin> i guess that must be so, so what is it that people use nowadays to be productive? point and click?
03:05:54 <shapr> Lokadin: seen scsh? tried plan9 and its successor?
03:06:05 <dcoutts_> aleator, oh, I seems that appart from the __extension__ it's actually IS0 C99
03:06:12 <dcoutts_> it's a compound literal
03:06:28 <Stinger_> heh plan9 saw some of that a few weeks ago
03:06:32 <Lokadin> shapr: no actually? what are those?
03:07:00 <shapr> Lokadin: http://www.vitanuova.com/inferno/downloads.html
03:07:05 <Lokadin> one sec
03:07:28 <davidhouse> yay! my capslock key is now my control key! :)
03:07:42 <shapr> yay!
03:07:52 <davidhouse> no more emacs pinky :)
03:07:55 <shapr> davidhouse: Try a kinesis keyboard, and move all the modifiers under your thumbs.
03:08:12 <shapr> I call that keymap "I am not a koala"
03:08:19 <davidhouse> by the way, anyone know if it's possible to map c-x c-k to /window close in irssi? :)
03:08:33 <Razor-X`> davidhouse: Check xmodmap :).
03:08:43 <Razor-X`> If you're using Linux, that is.
03:08:56 <davidhouse> yeah, of course. but xmodmap does app-specific mappings?
03:09:00 <shapr> davidhouse: There's code for purpose specific keys along the lines of Jef Raskin's Humane Interface
03:09:08 <Razor-X`> Oh, whoops. No.
03:09:46 <Razor-X`> hGetLine only gets the first line of a buffer, and hGetContents gets it all. How can I tell hGetLine to get the last line if the handle isn't seekable?
03:10:13 <mauke> hmm, that worked :-)
03:10:14 <Lokadin> shapr: so plan9 is now called inferno? or what is it that i'm downloading?
03:10:22 <mauke> /bind ^X^K /window close
03:12:03 <davidhouse> mauke: great, thanks.
03:12:23 <Lokadin> shapr: or do you know what it's called in portage?
03:12:59 <davidhouse> mauke: huh, not working. do you have to restart irssi?
03:13:04 <Lokadin> say my cat hunts insects is that strange at all?
03:13:21 <mauke> davidhouse: no
03:13:22 <shapr> Lokadin: http://herpolhode.com/rob/hotchips.html
03:15:24 <aleator> dcoutts_: Anything I can do to help? 
03:15:40 <dcoutts_> aleator, find me the ISO C99 spec :-)
03:15:50 <dcoutts_> a draft would probably do
03:16:01 <aleator> Hmm.. I see what I can do..
03:16:42 <Lokadin> shapr: so it's like java?
03:16:52 <shapr> Like Haskell is like Lisp ;-)
03:17:13 <shapr> There are vague resemblances...
03:17:55 <Lokadin> so are you saying it would be better than haskell for the purposes i describe? as in to make an intelligent terminal
03:18:05 <Lokadin> er well one that can interpert english text say
03:18:09 <mauke> dcoutts_: http://www.google.de/search?q=9899%3A1999
03:18:15 <Lokadin> or status bars and what not
03:18:36 <shapr> No, I was just saying that Inferno has some improvements in the command line area that are worth checking out.
03:18:47 <dcoutts_> mauke, oh nice
03:19:10 <Lokadin> oh so it's a command line ? like scsh?
03:19:20 <shapr> As for interpreting english text, I think a lojban interpreter written in Haskell might work.
03:19:25 <shapr> You still have to define semantics though.
03:20:11 <shapr> Well no, Inferno is sort of a post-Unix. Notice that Rob Pike was part of the design & implementation.
03:21:02 <shapr> Still, plan 9 and Inferno have a bunch of nice features that aren't found in either Unices or Windows.
03:21:22 <aleator> dcoutts_: ISO/IEC 9899:1999 - www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf . Probably isn't what you want since it is so easy to find.. 
03:21:56 <dcoutts_> aleator, actually it is, I was clearly gooling for the wrong keywords
03:22:22 <aleator> well, ISO/IEC 9899:1999 is the phrase to google for..
03:23:14 <Lokadin> shapr: hmmm, is there a feature list? or will i have to actually install it to be able to understand the differences?
03:23:40 <dcoutts_> aleator, ah ha, 6.5.2.5 Compound Literals
03:23:50 <shapr> Lokadin: http://www.ecf.utoronto.ca/plan9/plan9faq.html
03:23:59 <Lokadin> thanks :)
03:24:19 <shapr> Inferno - http://www.vitanuova.com/inferno/index.html
03:24:23 <aleator> dcoutts_: Anything else? 
03:24:53 <dcoutts_> aleator, ever used the parser generator happy?
03:25:32 <aleator> dcoutts_: Once, but I'm not fluent.
03:30:21 <dcoutts_> aleator, take a look at c2hs/c/CParser.y, line 776
03:30:27 <dcoutts_> postfix_expression
03:30:48 <dcoutts_> and compare that to the spec, section 6.5.2
03:30:58 <aleator> ok. a sec.
03:31:26 <dcoutts_> you can see that we're indeed missing the " ( type-name ) { initialiser-list } "
03:31:37 <dcoutts_> so all we have to do is add it :-)
03:32:15 <aleator> Hey, hold on! I haven't even found CParser.y yet :)
03:32:21 <dcoutts_> heh :-)
03:32:31 <dcoutts_> you've got the latest darcs version of c2hs?
03:32:59 <aleator> oops. Indeed. I have but I was looking at the 14.5.
03:39:39 <shapr> oops
03:39:41 <aleator> dcoutts_: yup.. No type-names indeed.. Ah.. initializer lists already there.. humm.. wonder what piece of ast I should build.. Or did you already fix it?
03:40:31 <dcoutts_> aleator, I'm looking at it, yes
03:40:44 <dcoutts_> so we need to add compoundliterals to the AST
03:40:51 <davidhouse> shapr, accidental Alt+F4? :)
03:42:57 <aleator> yeah. this is quite big to grok in 15 minutes. What eats the ast?
03:43:40 <nemesis> i have hugs in linux installed but i cant find it. how do i find it, or how do i run a hs file in hugs in linux?
03:44:25 <dcoutts_> aleator, well actually c2hs is not too concerned with most function bodies & expressions
03:44:50 <dcoutts_> aleator, so I expect that we merely have to parse it ok and that nothing will consume it
03:47:12 <nemesis> cant anyone help???
03:47:38 <dcoutts_> nemesis, so 'hugs' is not on your path?
03:47:56 <dcoutts_> if you just run 'hugs' it can't be found?
03:48:38 <nemesis> oh it can^^ thanks :D
03:48:46 <Muad_Dibber> ..
03:50:21 <nemesis> now how do i open a certain hs file?
03:50:29 <dcoutts_> hugs Foo.hs
03:50:41 <dcoutts_> or from within hugs type...
03:50:45 <dcoutts_> :load Foo.hs
03:51:11 <nemesis> with the path in it as well...
03:52:00 <dcoutts_> aleator, I've got a patch if you want to test it...
03:52:12 <dcoutts_> aleator, I'll darcs send it to you, what's your email?
03:52:29 <dcoutts_> aleator, you know how to apply darcs patches right?
03:53:21 <aleator> dcoutts_: I would think so. aleator@jyu.fi.
03:53:31 <vincenz> dcoutts_: using signing
03:53:52 <vincenz> dcoutts_: and then having dons auto-accepting things that match your pubkey to the darcs so he doesn't have to weed through you patches
03:54:21 <aleator> dcoutts_: Thanks, I got only as far as adding new bit of ast :)
03:54:33 <vincenz> dcoutts_: auto-accepting patches
03:54:55 <vincenz> what do you guys think if I changed my nick to 'chrispy'?
03:55:06 <dcoutts_> vincenz, but actually I want dons to read my patches!
03:55:20 <dcoutts_> so I don't know that auto-applying would help here
03:55:30 <dcoutts_> aleator, sent
03:55:34 * jethr0 just had his last university exam. now i'm an out of work haskell programmer with a degree :)
03:55:46 <davidhouse> jethr0: woo!
03:55:49 <jethr0> w00t
03:55:54 <vincenz> jethr0: congrats!
03:56:22 <jethr0> thx, wasn't the greatest exam, but cryptography isn't exactly easy, so i'm not too pissed
03:56:27 * davidhouse sings along to less than jake
03:56:33 <dcoutts_> aleator, I've really only extended the parser & ast. I'm hoping that it doesn't actually get consumed. We'll get Manual to double check that we don't need to do any more on the processing side.
03:56:49 <davidhouse> jethr0: did Control.Monad.Reader.join not come up then? :)
03:57:02 <jethr0> astonishingly not.
03:57:05 <dcoutts_> aleator, so if it works for you i'll forward it to Manuel
03:57:12 <aleator> dcoutts_: Thanks! I'll try it as soon as possible, but I've got to run now. Back in an hour.
03:58:49 <shapr> davidhouse: Accidental F7. I have KillKey bound to F7
03:59:00 <shapr> jethr0: gratis!
03:59:11 <shapr> jethr0: congraduations!
03:59:33 <jethr0> shapr: thx. now we can join forces on rentacoder
03:59:39 <shapr> Yay!
04:00:00 <vincenz> isn't that the alias of rentamonkey?
04:00:01 <shapr> I think a PHP parser is the first step to Haskell riches.
04:00:26 <jethr0> i wonder how many people in here would be willing to join a software startup. some are still in school/college/uni, but i'd think that it shouldn't be too hard to "recruit" a dozen topnotch functional programmer from #haskell, #clean, ...
04:00:28 <davidhouse> PHP? involve me! :)
04:00:34 <Saulzar_> What would you use a PHP parser for? Transforming PHP programs somehow?
04:00:42 <vincenz> jethr0: I would 
04:00:44 <shapr> Yeah, "sewage treatment" as dcoutts puts it.
04:01:16 <dcoutts_> shapr, I don't think that was my phrase, but it's a good one
04:01:25 <davidhouse> how about we parse some PHP into an AST, then reify it, but intersperse the source with comments that undermine the programmer's confidence in the language?
04:01:35 <davidhouse> the coding equivalent of the devil whispering in your ear.
04:01:36 <jethr0> vincenz: the only question is how to acquire clients, because i don't think software construction would be a big concern with a handful of fulltime functional "programmers".
04:01:38 <shapr> I see a lot of contract work that involves cleaning up or extending existing PHP code. imho, the first step should be to clean up and style check what's already there.
04:01:40 <dcoutts_> jethr0, yeah, shapr was floating a similar idea
04:02:22 <shapr> My last startup idea was already taken :-(
04:02:31 <dcoutts_> shapr, what was that?
04:02:32 <shapr> My Evil Project is being done by someone else :-/
04:02:36 <vincenz>  Could not deduce (Ord i) from the context (Num i)
04:02:36 <jethr0> right now i'm all in favor of it. problems would be programmers working at home, and "paying the rent" for the first months
04:02:40 <vincenz> o.O
04:02:44 <shapr> dcoutts_: I'm under an NDA at this point...
04:02:49 <dcoutts_> heh, ok
04:03:10 <vincenz> Num does not imply Ord?/??
04:03:19 <Stinger_> the ideawas already taken so you joined them?
04:03:26 <shapr> Stinger_: I'm trying to...
04:03:35 <Stinger_> heh fair enough
04:03:35 <vincenz> shapr: may we know whom?
04:03:45 <Stinger_> if you can't beat em (to market)
04:04:02 <shapr> vincenz: Nah, I'll talk about it when the startup isn't in stealth mode.
04:04:05 <davidhouse> vincenz: why should it?
04:04:14 <davidhouse> vincenz: things like matricises can be Nums.
04:04:27 <vincenz> davidhouse: hmm... point taken
04:04:38 <vincenz> shapr: fair 'nuff
04:05:12 <dons> vincenz: oh, btw, i applied your hmp3 patches :)
04:05:14 <shapr> In any case, I'd be thrilled to join a team of contract programmers.
04:05:19 <vincenz> Anyone by any chance work on some sort of integration of vim with lambdabot or ghci?
04:05:22 <vincenz> dons: ooh neat :)
04:05:37 <davidhouse> hey, dons! i've got some lambdabot bugs :)
04:05:40 <dcoutts_> shapr, yeah, me too
04:05:40 <davidhouse> @echo ping ping ping
04:05:41 <lambdabot> echo; msg:Message {msgPrefix = "davidhouse!n=david@host86-143-53-67.range86-143.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo ping ping ping"]} rest:"ping ping ping"
04:05:41 <jethr0> shapr: contract programmers sounds so profane. i mean an actual company that does heavy-duty development
04:05:44 <dons> vincenz: lambdabot/vim is already bound.
04:05:50 <davidhouse> dons, @echo seems to be generally broken.
04:05:55 <shapr> There are contracts where the person does not care how it works as long as it does.
04:05:56 <Saulzar_> How could such a group operate over so many countries, is it even feasable?
04:06:04 <shapr> davidhouse: It's supposed to do that.
04:06:04 <dons> davidhouse: i'm not sure it can be broken.
04:06:06 <vincenz> dons: really?
04:06:10 <shapr> davidhouse: I wrote it :-)
04:06:13 <jethr0> Saulzar_: as i said that's a big problem
04:06:15 <davidhouse> huh?
04:06:16 <dons> yeah, look in scripts/vim/
04:06:21 <davidhouse> shapr, you changed the behaviour then
04:06:23 <Saulzar_> Hmm
04:06:24 <shapr> wha?
04:06:29 <vincenz> dons: I remember working on a function to generate a random permutation
04:06:34 <davidhouse> it used to just spit out whatever you put into it
04:06:37 <vincenz> dons: I might add that in for prev next in random mode
04:06:39 <shapr> davidhouse: @echo just runs show on the message it gets.
04:06:40 <vincenz> dons: so it's consistent
04:06:43 <dons> vincenz: oh, yeah, that's right.
04:06:56 <davidhouse> e.g. <davidhouse> @echo sausages <lambdabot> sausages. that's how it used to work.
04:07:01 <dons> davidhouse: what did you expect @echo to do?
04:07:04 <dons> @id literal
04:07:05 <lambdabot> literal
04:07:05 <jethr0> Saulzar_: but i think if the programmers are _really_ good then a lot can be leveraged with telephone/collaborative tools, etc. but i guess there'd have to be a core team in a central location
04:07:09 <shapr> No, I don't think it ever did that.
04:07:16 <davidhouse> dons, oh, perhaps i'm confusing it with id.
04:07:18 <vincenz> jethr0: I agree
04:07:20 <shapr> jethr0: I think over the net collab would work fine.
04:07:23 <shapr> @state nebraska
04:07:26 <davidhouse> err, right, ignore everything i ever said.
04:07:28 <shapr> @state foodle
04:07:28 <lambdabot> nebraska
04:07:30 <dons> dcoutts_: around?
04:07:33 <dcoutts_> dons, yep
04:07:36 <shapr> @state thingamajig
04:07:37 <lambdabot> foodle
04:07:44 <shapr> Maybe @state is what you meant?
04:07:44 <jethr0> not ultimately, but if the company really takes off then it should be no problem to aggregate in a few places
04:07:53 <davidhouse> @. state state state nebraska
04:07:53 <lambdabot> state nebraska
04:07:55 <dons> what's the plan now with pushing fps forwards? noArr loops?
04:07:56 <jethr0> @state
04:07:56 <lambdabot> thingamajig
04:08:21 <shapr> jethr0: At the moment, I'm learning Flash via haXe in order to pay the rent.
04:08:22 <dcoutts_> dons, that and lists and I need to consider my V3 stuff
04:08:30 <dons> dcoutts_: i might create a paper repo, so we can jot down things that should go in the paper.
04:08:39 <dcoutts_> dons, ok great
04:08:44 <davidhouse> @. state state nebraska
04:08:44 <lambdabot> nebraska
04:08:47 <vincenz> darcs rocks :)
04:08:49 <vincenz> @state
04:08:49 <dons> ah, and benchmarks. we want to know where v2 beats v1.
04:08:51 <shapr> yeah!
04:08:56 <shapr> I like darcsum.el too.
04:09:03 <vincenz> darcsum?
04:09:03 <dcoutts_> dons, yes, that's first I think.
04:09:04 <jethr0> shapr: i heard. but i think enterprise contracting pays better once it's started to roll
04:09:18 <shapr> jethr0: I want anything that rolls at the moment.
04:09:27 <dons> dcoutts_: what was the stroy with v3? you match the wrappers in the rules, and float them outwards there?
04:09:27 <jethr0> i know
04:09:32 <shapr> All my contacts want web dev right now.
04:09:49 <shapr> Some via Java, some via Python, some via PHP
04:10:08 <davidhouse> hmm
04:10:14 <davidhouse> perhaps i should keep my php skills sharp then.
04:10:17 <dcoutts_> dons, right, we match the up/down/noacc/map/filter wrappers and fuse them directly without any unwrapping phase
04:10:37 <dons> ok. good.
04:10:38 <dcoutts_> dons, but then the Q is how do we combine up/down into a single wrapper
04:10:43 <davidhouse> i would write more php if someone wrote a php-mode that Didn't Suck.
04:11:01 <dcoutts_> dons, the nice thing about doing it that way is that it extends natuallry to lists
04:11:10 <dons> ah, yes. 
04:11:24 <dcoutts_> and it means fewer NoAcc types
04:11:37 * Saulzar_ is soon to be an out of work programmer too. Just finished draft thesis.
04:11:38 <dcoutts_> but the up/down wrapper elim need more thought
04:11:38 <dons> i think we'd have a strong result if the extended fusion applied both to strict and lazy strings.
04:11:54 <dcoutts_> dons, well good because it does :-)
04:11:58 <davidhouse> Saulzar_: about anything interesting?
04:12:02 * jethr0 's final mark is 1.9941 which gets "rounded" to 1.9 :)
04:12:04 <shapr> Saulzar_: Now we just need some work and each others' Google Talk address, right?
04:12:10 <dcoutts_> dons, (though it's not tested much yet)
04:12:10 <dons> dcoutts_: yeah, it would look good in a paper, i mean :)
04:12:16 <dcoutts_> dons, indeed :-)
04:12:21 <Maddas> jethr0: ouch :)
04:12:37 <davidhouse> jethr0: out of what?
04:13:14 <jethr0> davidhouse: it's a german system. 1=A, 2=B, 3=C, 4=D, 5=E (well, 5 is actually failed)
04:13:21 <Saulzar_> davidhouse, Maybe - scene reconstruction, voxel colouring using ray traversal. It was intersting about 12 months ago :)
04:13:24 <Maddas> jethr0: Oh, that's awesome then!
04:13:54 <davidhouse> jethr0: oh, right, so your rounding was to your benefit! :)
04:13:55 <jethr0> Maddas: thx
04:14:01 <jethr0> yup, thankfully
04:14:03 <Maddas> jethr0: In Switzerland, it's the other way around, so you'd be doing rather bad with a 1 ;-)
04:14:18 <jethr0> but it's rounded again to 1 digit, so i've got a final mark of 2
04:14:26 * Maddas laughs
04:14:29 <davidhouse> Saulzar_: /me nods and "mms" and pretends to know what any of that means :)
04:14:53 <Maddas> jethr0: that's poetic justice for you, I guess  :-)
04:14:59 <Saulzar_> davidhouse, If you look up "generalised voxel coloring" you would get a fairly good idea :)
04:15:35 <shapr> Saulzar_: scene reconstruction?
04:15:42 <vincenz> shapr: you're creative... got any good nick solution that relates a bit more to my name?
04:15:50 <shapr> um
04:15:51 * shapr thinks
04:16:00 <Saulzar_> shapr, Hmm. Seems quite tough to be constantly finding contract work. I'd tend to just find a job somewhere doing Java/C++ or something maybe...
04:16:14 <Saulzar_> shapr, Bunch of images -> Voxel model
04:16:19 <shapr> It is tough to find work, but if you have one person finding work and everyone developing...
04:16:33 <shapr> Saulzar_: oh really... turns it into a 3D model?
04:17:32 <Saulzar_> shapr, Well more like the process is Bunch of images -> Calibrate via correspondances -> Voxel model, but I've only really looked at the 2nd step :)
04:18:18 <jethr0> scene reconstruction is pretty evil. i did my thesis on it and there's a lot of problem to solve. i'd consider that rather research material than application programming...
04:18:23 <Saulzar_> shapr, Yeah - but not very well. Other stuff like stereo or active scanners seems to work much better
04:19:15 <jethr0> of course it's well possible and has been done before, but noise and cascading errors are a severe problem to deal with
04:19:50 <shapr> Hm, I've had some ideas about scene reconstruction...
04:20:08 * Saulzar_ curses, just typed 3 priv messages and wasn't registered
04:20:35 <jethr0> as i said, i did it for my thesis and worked 12 months on it. although i wasn't being particularly smart about it, it's still a heck of problem to solve robustly
04:23:14 <Saulzar> I just focussed on a tiny area and tried to improve on something... which seemed to work alright, but the method as a whole never seems to work very well
04:24:19 <cmarcelo> dons: about my earlier problem: to unwrap a "Ptr a", would something like "let (Ptr jj) = j" with j :: Ptr a (and then using jj), be enough? or I'm missing something here?
04:25:39 <davidhouse> @id davidhouse: test
04:25:39 <lambdabot> davidhouse: test
04:25:44 <davidhouse> yay, it beeps :)
04:25:56 <davidhouse> @id davidhouse: test
04:25:56 <lambdabot> davidhouse: test
04:26:04 <psnl> davidhouse: so we can play a tune on your box?
04:26:07 <davidhouse> @id davidhouse: test
04:26:07 <lambdabot> davidhouse: test
04:27:08 <nemesis> hi, i have the lambda function (\ x -> if (ord x > 64 && ord x < 91) || (ord x > 96 && ord x < 123) then x else ' ')  which checks if the char is a letter of the latin alphabet. How do i modify the else part of the condition so that non space character is added?
04:27:11 <davidhouse> @id davidhouse: test
04:27:11 <lambdabot> davidhouse: test
04:27:21 <davidhouse> great!
04:27:39 <nemesis> no*
04:27:51 <alar> nemesis: what about \x -> isalpha x ?
04:27:58 <davidhouse> nemesis: why not return a bool? or a Maybe?
04:28:18 <davidhouse> @hoogle isAlpha
04:28:18 <lambdabot> Char.isAlpha :: Char -> Bool
04:28:18 <lambdabot> Char.isAlphaNum :: Char -> Bool
04:28:22 <davidhouse> that might help too
04:29:19 <Bobstopper> Hi. What's the proper way to declare a datatype like this: data Foo = Foo { bar :: (Show a) => a } ?
04:29:20 <davidhouse> if you wanted to stick with ord checking, i'd so something like:
04:30:01 <alar> isAlpha is also intended to be portable and ASCII range test is guaranteed not to be
04:30:01 <nemesis> Bool, yeah...
04:30:19 <alar> Bobstopper: you should probaly use GADTs
04:30:28 <alar> data Foo where
04:30:35 <davidhouse> > let inRange x (low,up) = x > low && x < up; myIsAlpha c = if x `inRange` (64,91) || x `inRange` (96,123) then Just x else Nothing in myIsAlpha 's'
04:30:36 <lambdabot>  Not in scope: `x'
04:30:37 <nemesis> actually no...
04:30:43 <alar> FOO::(Show a)=> a->Foo
04:30:46 <davidhouse> > let inRange x (low,up) = x > low && x < up; myIsAlpha c = if c `inRange` (64,91) || c `inRange` (96,123) then Just x else Nothing in myIsAlpha 's'
04:30:47 <lambdabot>  Not in scope: `x'
04:31:04 <davidhouse> > let inRange x (low,up) = x > low && x < up; myIsAlpha c = if c `inRange` (64,91) || c `inRange` (96,123) then Just c else Nothing in myIsAlpha 's'
04:31:04 <lambdabot>  add an instance declaration for (Num Char)
04:31:04 <lambdabot>   In the definition of `vlg':
04:31:04 <lambdabot>    vlg = let
04:31:07 <davidhouse> argh.
04:31:11 <nemesis> ^^
04:31:11 <davidhouse> sorry, i'll take this into a PM.
04:31:37 <alar> Bobstopper: or do it with a class
04:31:54 <nemesis> or easy enough cant i write something like (\ x -> if (ord x > 64 && ord x < 91) || (ord x > 96 && ord x < 123) = x) ?
04:32:05 <alar> instance (Show a) => FOO a
04:32:08 <nemesis> or easy enough cant i write something like (\ x -> (ord x > 64 && ord x < 91) || (ord x > 96 && ord x < 123) = x) ?
04:32:11 <nemesis> without the if.
04:32:49 <Bobstopper> hmm... ok, thanks. I'll look into that data where stuff
04:34:01 <nemesis> ???
04:34:01 <lambdabot> Maybe you meant: . id pl v wn
04:34:12 <davidhouse> > let inRange x (low,up) = x > low && x < up; boolToMaybe p x = if (p x) then Just x else Nothing; myIsAlpha = boolToMaybe (\c -> ord c `inRange` (64, 91) || ord c `inRange` (96, 123)) in myIsAlpha 's
04:34:12 <lambdabot>  Improperly terminated character constant
04:34:16 <davidhouse> > let inRange x (low,up) = x > low && x < up; boolToMaybe p x = if (p x) then Just x else Nothing; myIsAlpha = boolToMaybe (\c -> ord c `inRange` (64, 91) || ord c `inRange` (96, 123)) in myIsAlpha 's'
04:34:17 <lambdabot>  Just 's'
04:34:28 <davidhouse> some nice general combinators in there.
04:34:40 <nemesis> davidhouse, cant we keep it as simple as i pasted it ? ^^
04:34:53 <nemesis> \ x -> (ord x > 64 && ord x < 91) || (ord x > 96 && ord x < 123) = x) ?
04:35:10 <nemesis> smth like this, there is a mistake in the syntax
04:35:11 <davidhouse> huh? what's that = x doing?
04:35:26 <davidhouse> if you want a bool, then all you need is what you pasted.
04:35:41 <davidhouse> i could simplify mine, but i've included a couple of nice combinators for generality.
04:35:43 <nemesis> well... it just returns the char is the condition is true
04:35:52 <nemesis> if*
04:35:54 <davidhouse> nemesis: and if not, what does it return?
04:35:59 <nemesis> nothing.
04:36:05 <nemesis> i want it to return nothing...
04:36:07 <davidhouse> nothing as in Nothing?
04:36:12 <davidhouse> functions can't return nothing ;)
04:36:18 <nemesis> hehe
04:36:24 <nemesis> whats Nothing?
04:36:26 <davidhouse> functions have to have a type.
04:36:44 <davidhouse> this isn't imperative programming, where a function can do stuff and not return anything
04:37:02 <davidhouse> in functional programming without side effects, if a function doesn't return anything then it doesn't do anything.
04:37:16 <dons> cmarcelo: yeah, that's what I was thinking. Ptr a, then 'a' is the raw address. 
04:37:27 <nemesis> yup ^^ i still am not used to f. programming
04:37:40 <dons> to unwrap it though would need GHC.Ptr, so there's probably a more ffi-standard way to do it.
04:37:43 <davidhouse> you basically want to write a function to check to see if that predicate is true yeah? with all the ords?
04:37:50 <dons> well, maybe  a more portable way.
04:37:54 <mahogny> imperative and functional programming aren't really very different if you attack it from the right angle
04:38:05 <nemesis> yes... 
04:38:19 <nemesis> is there a constant for an empty char?
04:38:23 <nemesis> which doesnt take place?
04:38:30 <mahogny> use Maybe
04:38:38 <davidhouse> nemesis: okay. now you've got a choice. you can either design your function to return the char if it's good, or it can return a bool.
04:38:39 <alar> empty char? &nbsp; ??
04:38:43 <mahogny> then return either Just 'c' or Nothing
04:38:49 <dons> nemesis: use Maybe. same question came up yesterday.
04:38:59 <nemesis> ok...
04:39:01 <nemesis> il ltry
04:39:04 <nemesis> ill try*
04:39:22 <alar> is there Cabal-1.1 available already?
04:39:37 <mahogny> it wouldn't hurt if imperative languages started using Maybe as well ie add to type if it can be null
04:39:51 <dons> instead of a null ptr.
04:39:54 <dons> :)
04:40:35 <mahogny> but then, we can go all way and add property checks when we are at it. null checks for free ;)
04:40:52 <dons> and then we could add pure functions too, sinec they're so useful
04:41:01 <dons> and move side effects into their own type
04:41:10 <dons> and also separate outside world effects, from internal effects
04:41:11 <davidhouse> and have niceties like lambda abstraction.
04:41:24 <alar> mahogny: it they will you'll start demanding monads in imperative languages :)
04:41:27 <mahogny> hm. I can live with unpure functions
04:41:33 <dons> oh, and infinite data structures are good too
04:41:36 <davidhouse> plus a raft of list manip functions, for good measure.
04:41:37 <dons> so we need to add laziness
04:41:39 <mahogny> but partial application and returning multiple arguments is a must
04:41:42 <davidhouse> then to top it off, laziness.
04:41:47 <mahogny> alar, :)
04:41:55 <davidhouse> evolve interfaces into type classes.
04:42:10 <mahogny> well, I think at the minimum multiple return arguments is a decent requirement. it isn't even hard to implement
04:42:42 <dons> and then we can call this worlds-greatest-imperative-language .. umm... haskell?
04:42:43 <davidhouse> yeah, tuples seem second nature
04:42:46 <alar> mahogny: with Maybe a variable can hold Nothing, with monads it can hold error code or other sideband info instead of normal value :)
04:42:48 <vincenz> bleg
04:42:51 <aleator> dcoutts_: Umm. "runghc Setup.hs configure; runghc Setup.hs build ==> Setup.hs: can't find source for C2HSConfig in ["base/admin",.." What am I doing wrong now?
04:43:04 <dcoutts_> aleator, chmod +x configure
04:43:07 <vincenz> MPTC's suck for typechecking
04:43:36 <davidhouse> MPTC's what? (greengrocer's apostrophe ;))
04:43:54 <mahogny> alar, it's a bit too much overhead for classical imperative languages though
04:43:54 <alar> multiple return arguments are natural in stack languages
04:44:08 <vincenz>     Could not deduce (Sequence.Sequence s1 i)
04:44:08 <vincenz>       from the context (Show a, Sequence.Sequence s i)
04:44:08 <vincenz>       arising from use of `loop' at ./Visualization.hs:95:2-5
04:44:08 <vincenz>     Probable fix:
04:44:11 <vincenz>       add (Sequence.Sequence s1 i) to the type signature(s) for `renderSequence'
04:44:22 <alar> in "normal" languages they don't have the full power
04:44:23 <mahogny> alar, hm. stack languages... I dunno if I think that is a good terminology
04:44:23 <vincenz> why doesn't it equate the s1 and s
04:44:39 <alar> mahogny: I mean Forth, PostScript, Joy
04:44:53 <mahogny> alar, ah. yeah. hm. I hate stack machines though
04:44:56 <shapr> mmm, Joy
04:44:57 <vincenz> alar: most multiple return paths can be turned into a single return path
04:45:17 <alar> vincenz: are you doing result-type polymorhism?
04:45:35 <alar> vincenz: yes, they can, but the code looks dirtier
04:45:46 <dcoutts_> aleator, tell me if/when you run into problems with __extension__
04:46:01 <mahogny> hm. but there's a guy working on implementing haskell bindings for matlab. then we will have a kick ass imperative language :)
04:46:12 <vincenz> it complains on this
04:46:13 <vincenz> http://rafb.net/paste/results/NhMEfH95.html
04:46:23 * davidhouse <3 capslock as ctrl
04:46:35 <mahogny> davidhouse, o_O that sounds very Sun
04:47:04 <davidhouse> it's a lot more natural than overusing your little finger.
04:47:35 <vincenz> anyone know why that won't type?
04:47:40 <aleator> dcoutts_: configure? 
04:47:59 <dcoutts_> aleator, oh, try running autoreconf
04:48:59 <aleator> ah. thanks.
04:50:09 <vincenz> @type mapM_
04:50:10 <lambdabot> forall (m :: * -> *) a b.
04:50:10 <lambdabot>    (Monad m) =>
04:50:10 <lambdabot>    (a -> m b) -> [a] -> m ()
04:53:49 <alar> vincenz: what's S.Sequence? 
04:53:57 <alar> I do not understand your code
04:54:13 * vincenz kicks
04:54:15 <alar> > type (::)
04:54:16 <lambdabot>  Parse error
04:54:23 <vincenz> alar: my MPTC
04:54:50 <alar> multi-parameter typeclass?
04:56:27 <vincenz> yes
04:56:36 <vincenz> apparently it doens't like recursion
04:57:26 <cmarcelo> dons: the unwrap works with GHC.Ptr but not with default Ptr.. but now there's a trouble to compare WordPtr with the result of unwrapping (they have different kinds =P).. I'll google for other (portable) ways of unwrapping this.. tks.
04:57:45 <dons> cmarcelo: oh, can you just 'castPtr' ?
04:57:46 <vincenz> aha!
04:57:57 <vincenz> apparently it doesn't like typeclass methods that do not take in all the parameters
04:57:57 <dons> ?type Foreign.castPtr
04:57:58 <lambdabot> forall b a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
04:59:25 <alar> then I'm of no help
04:59:29 <alar> never used MPTC
05:00:38 <vincenz> ...
05:00:45 <vincenz> dons: do you use lambdabot in conjunction with vim?
05:01:27 <cmarcelo> dons: the problem is, right now I have the "imported" value, which is a WordPtr, and a Ptr WordPtr that is result of a function. unwrapping Ptr WordPtr gives me Addr#.. I don't see how castPtr could help.
05:01:27 <dons> i did, but i broke lambdabot's scriptability, so i don't at the momeent.
05:01:34 * vincenz nods
05:02:04 <aleator> yay! It compiles!
05:02:12 <aleator> ... nearly.
05:02:51 <vincenz> Anyone know why you have to have all type parameters of MPTC in all the methods?
05:02:57 <vincenz> class Foo a b where
05:03:08 <vincenz>   foo :: a -> b c
05:03:16 <vincenz> class Foo a b | a -> b
05:03:23 <vincenz>   foo :: a c -> b
05:03:28 <vincenz>    bar :: b -> b  (gives problems)
05:03:55 <Igloo> When you use bar, how is it suppose to know what a is?
05:04:04 <vincenz> Igloo: well other methods are used
05:04:06 <vincenz> Igloo: so there's a context
05:04:12 <vincenz> but for some reason it makes them s and s1
05:04:25 <Igloo> How does it know you are using the other methods with the same type?
05:04:39 <vincenz> plop x = let i = foo x in bar i
05:04:52 <davidhouse> vincenz: but those are special cases
05:04:59 <vincenz> yeah but it fails on that
05:05:02 <vincenz> even if you add typesig
05:05:11 <Igloo> You could be using foo from the Int Char instance and bar from the Float Char instance
05:05:22 <vincenz> Igloo: yeah I guess
05:05:28 <vincenz> still annoying I have to add a c to bar
05:05:34 <vincenz> unless you have other solution
05:05:47 <vincenz> bar :: a c (unsed) -> b -> b
05:06:01 <vincenz> s/unsed/unused
05:06:11 <Igloo> You only actually need a, not (a c)
05:06:19 <vincenz> well you can't pass a na
05:06:26 <aleator> dcoutts_: Much obliged. No problems with extensions thus far (using "-D__extension__=" instead of "-D__extension__(A)= " which eats the type). All seems to work neatly.
05:06:26 <Igloo> Oh, sorry, I'm being stupid
05:06:28 <vincenz> a has kind * -> *
05:06:34 <Igloo> Right
05:06:42 <dcoutts_> aleator, great
05:06:49 <Igloo> Anyway, there's no better way without refactoring
05:06:54 <vincenz> hmm
05:07:06 <aleator> dcoutts_: If you ever drop by Jyvskyl, I'll buy you a beer :)
05:07:08 <vincenz> two separate TCs?
05:07:23 <dcoutts_> aleator, great! where's Jyvskyl? :-)
05:08:00 <Stinger_> so how can I use a randomIO to grab a random value
05:08:47 <aleator> dcoutts_: see http://www.haskell.org/hawiki/HaskellUserLocations?action=highlight&value=userlocations
05:09:27 <dcoutts_> aleator, ah, near ibid 
05:10:02 <davidhouse> dcoutts_: i thought you were oxford-based?
05:10:09 <aleator> dcoutts_: ibid works in office next to me..
05:10:10 <dcoutts_> davidhouse, I am.
05:10:14 <dcoutts_> aleator, ah ok :-)
05:10:18 <davidhouse> from the map it looks like you're in weymouth or something
05:10:21 <dcoutts_> hah
05:12:04 <davidhouse> i think i live in between astrolabe and integral, by the looks of things.
05:18:03 * alar keeps forgetting adding himself to the map
05:18:24 <mahogny> "not allowed to change this page". wtf
05:18:54 <dons> you have to log in these days
05:19:12 <mahogny> bah. where is the log in button? I'm blind :(
05:19:40 <Igloo> dons: Do you know that mercator.jpg is empty?
05:20:14 <Igloo> dons: And it would be nice to be able to get larger versions by clicking on them too  :-)
05:21:41 <davidhouse> how does one figure out his long/lat from, say, a postcode?
05:22:00 <mahogny> did you try the google maps? they were quite easy to use
05:22:03 * davidhouse wonders if google maps does that
05:22:03 <aleator> maps.google.com?
05:22:17 <aleator> :)
05:22:32 <Igloo> There are 7 links at the top of the data file on teh above wiki page
05:23:36 <LordBrain> hmmm left this connected all night
05:23:41 <LordBrain> oopsie
05:23:45 <davidhouse> ah, thanks Igloo.
05:23:54 <dons> Igloo, oh, the nightly cronjob might have broken when we rejigged the cluster it runs on
05:24:11 <integral> davidhouse: I'm in Cambridge
05:24:17 <dons> larger versions ... ask google. we should just set up a google maps versoin
05:24:22 <integral> (and Edinburgh)
05:24:23 <Igloo> Cool, we have so many Haskellers we need a cluster to xplanet them all!
05:24:31 <dons> yeah :)
05:24:38 <vincenz> xplanet?
05:24:49 <dons> its some serious crunching to generate that map directly from the giant nasa earth image i use
05:25:14 <LordBrain> planet x... i seem to remember was that planet conjectured as a way to explain pluto's orbit..
05:25:36 <LordBrain> :)
05:25:45 <regsvr32> i have an idea about bittorrent.
05:25:58 <LordBrain> really? my brother is working on bittorrent
05:26:22 <dons> mahogny: we did this before there was a google maps.
05:26:30 <dons> but now days, we probably should just use google
05:26:34 <Igloo> Do you only regenerate it if the data changes?
05:26:35 <LordBrain> did what, i want to see
05:26:49 <dons> Igloo: no, just gets run once each night, takes about 20 mins
05:26:57 <dons> i could be clever
05:27:03 <dons> but i've go GHz to burn
05:27:09 <Igloo> :-)
05:27:14 <davidhouse> integral: cool, i'm not that close then. :)
05:27:41 <LordBrain> dons, Igloo, whats the url to this map?
05:28:01 <Igloo> http://www.haskell.org/hawiki/HaskellUserLocations?action=highlight&value=userlocations
05:28:53 <dons> ?map
05:28:53 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:29:33 <Igloo> How do you do it with google maps?
05:29:37 * davidhouse hopes he didn't break anything
05:29:41 <vincenz> can someone add my location?
05:29:48 <davidhouse> Igloo: the "link to this page" encodes it in the URL
05:29:57 <Stinger_> hahahaha oh dear
05:30:00 <davidhouse> Igloo: but it's a bit cryptic, try multimap if you're in the UK.
05:30:05 <shapr> regsvr32: What's the idea?
05:30:20 <Igloo> davidhouse: I mean how do we replace the whole thing with google maps. Or did I misunderstand what dons said earlier
05:30:23 <Igloo> ?
05:30:24 <vincenz> Location: 5052' NB 0442' OL, Nickname: vincenz, Name: Christophe Poucet
05:30:24 <Stinger_> I'm typing stuff into the bash prompt, thinking its ghci, wondering whats going on
05:30:35 <davidhouse> Igloo: oh, sorry. i misunderstood
05:30:40 <davidhouse> Stinger_: hehe i do that all the time
05:30:52 <davidhouse> 'unrecognised command: :t'
05:31:06 <regsvr32> i think if i invite some friends' idle machines to join a torrent (where i am a peer), it will benefit the swarm, or specifically, myself.
05:31:07 <dons> Igloo: i think we already have some google thingy set up don't we?
05:31:16 <Igloo> dons: Don't ask me  :-)
05:31:17 <shapr> vincenz: What about one of christop christophep ChrisP ? not interesting enough?
05:31:29 <vincenz> shapr: I meant to add me to the map page
05:31:31 * dons looks
05:31:37 <shapr> vincenz: No, I mean for a new nickname
05:31:41 <vincenz> hmm
05:31:46 <shapr> vincenz: Oh, you just wanted a mapname?
05:31:49 <vincenz> they're not nicky enough
05:32:18 <davidhouse> dons, i remember there being a spin-off project that used the gmaps API for this kind of purpose
05:32:20 <vincenz> shapr: no I want a nickname, that stuff about my location was in the hope someone'll add me to @map
05:32:26 <davidhouse> vincenz: add yourself
05:32:49 <vincenz> davidhouse: I can't figure out how to login on hawiki
05:32:58 <davidhouse> click "user preferences"
05:33:16 <vincenz> how do I convert 5052' NB 0442' OL to the right format?
05:33:21 <dons> oh, frappr, that's what i was thinking of.
05:33:24 <vincenz> > 50 + 52%60
05:33:25 <lambdabot>  763%15
05:33:27 <vincenz> > 50 + 52%60 :: Float
05:33:27 <lambdabot>  Couldn't match `Float' against `Ratio a'
05:33:34 <vincenz> > fromRational $ 50 + 52%60 :: Float
05:33:35 <lambdabot>  50.866665
05:33:47 <davidhouse> dons, frappr, yeah.
05:33:55 <dons> but fraprs kind of annyoying and ad-full
05:34:00 <vincenz> > fromRational $ 4 + 42%60 :: Float
05:34:01 <lambdabot>  4.7
05:34:02 <davidhouse> and there's a frappr page linked to from the HaWiki.
05:34:24 <dons> maybe its not too bad, but we could easily talk to google maps ourselves.
05:35:08 <davidhouse> yep.
05:36:00 <vincenz> how do I add myself to frappr
05:36:44 <vincenz> shapr: no I want a new nick
05:36:47 <davidhouse> with the 'add yourself' box
05:36:50 <vincenz> whoops, responding to history
05:36:58 <vincenz> blegh, frappr makes firefox hang
05:37:59 <alar> how do I unsubscribe from frappr?
05:38:37 <aleator> Is there easy way of making ghc utilize multiple processors?
05:38:57 <dons> aleator: install ghc 6.5 ?
05:39:18 <LordBrain> hmm there's so many in france/belgium area that its hard to read the names
05:40:02 <shapr> vincenz: Don't like the choices I suggested?
05:40:28 <vincenz> shapr: they're not nicky :/
05:40:52 <vincenz> shapr and dons sound nicky
05:41:08 * vincenz kicks his name
05:41:30 <aleator> dons: What does it have? (Is it worth it?)
05:42:00 <dons> well, it has an smp runtime system, iirc. your threads will run on multiple processors.
05:42:20 <dons> read the stuff on smp on haskell.org/ghc's wiki
05:42:30 <aleator> ahaa. There. Thanks!
05:48:11 <vincenz> is it normal that @map shows empty maps with just the names?
05:48:11 <vincenz> @map
05:48:12 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:51:22 <vincenz> shapr: what of cpo?
05:53:00 <dons> vincenz: i'm hacking on the map generating script, sorry
05:53:40 <vincenz> dons:  no need to apologize, was just curious :)
05:54:05 <dons> yeah, the big map couldn't load the background file. i need more ram.
05:54:08 * dons hunts for ram
05:55:05 <RvGaTe> http://www.haskell.org/hawiki/HaskellUserLocations <- why am i not listed?
05:55:24 <alar> RvGaTe: have you added yourself?
05:55:25 <Igloo> Because you didn't add yourself?
05:55:39 <RvGaTe> alar: no.. where can i do that
05:56:02 <vincenz> dons: the benelux is seriously crowded
05:56:14 <alar> RvGaTe: there should be instructions on that page
05:56:15 <vincenz> benelux-uk
05:56:31 * alar keeps fighting with cabal
05:56:54 <dons> vincenz: well, don't blame me :)
05:57:09 <vincenz> :D
05:57:13 <vincenz> blame haskell!
05:59:25 * alar blames cabalists
05:59:26 <xahlee> hey folks, if you want to learn Mathematica, goto #mathematica and i give a lessen
05:59:33 <vincenz> oh no
05:59:51 <vincenz> someone kick xahlee please
06:00:13 <dcoutts_> vincenz, don't like Mathematica eh? 
06:00:20 <dons> heh
06:00:24 <vincenz> dcoutts_: if you ever read xahlee posts on newsgroups...you'd know why
06:00:41 <vincenz> dcoutts_: he's a fame on his own, crossposts a lot of stuff that is off topic and often mysoginistic
06:00:48 <dcoutts_> ah
06:02:36 <vincenz> starting a thread with an explanation of something and continually replying to himself in that thread as he adds mor stuff
06:02:45 * alar slaps xahlee with 50lb EULA
06:02:46 * vincenz shrugs
06:03:14 <olliej> hehe
06:03:56 <xahlee> vincenz: don't be a moron
06:04:06 <xahlee> vincenz: if you want a fight, i'm be happy to comply here
06:04:25 <xahlee> vincenz: just don't then start to fucking say how i'm trolling again
06:07:16 * boegel thinks xahlee should shut up
06:07:25 <boegel> what he was doing fine, but hey :p
06:09:47 <psi> what has he done wrong?
06:10:05 <alar> why cabal bug is not in the list of known bugs?
06:12:08 <xerox> Howdy xah (-:
06:12:42 <xahlee> xerox: hi xerox :)
06:12:56 <xahlee> xerox: just discovered today that Cale's mbot does Mathematica
06:13:07 <xerox> xahlee - Yup, it indeed does!
06:13:43 <xahlee> xerox: and i asked him to have it in #Mathematica, and granted. Super!
06:14:09 <xerox> (-:
06:14:10 <dons> xahlee: is it being used heavily in #Mathematica?
06:14:13 <xahlee> xerox: btw, he's also the one who told me about how stereographic projection is a case of 3d inversion.
06:14:31 <xerox> Ah-ha!  He knows.
06:14:36 <xahlee> dons: well, i think i'll be a regular there from now on. ;)
06:14:49 <dons> xahlee: and also, do the #Mathematica people use the other mbot features? like the haskell evaluator?
06:14:58 <xahlee> maybe i shold look into way to make it a formal irc channel.
06:15:11 <dons> ah, i see. 
06:21:00 <mnislaih> Lemmih what did you say about darcs.haskell.org accounts for SoC people ?
06:21:09 <dons> @seen sjanssen 
06:21:09 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
06:21:12 <vincenz> so anyways
06:21:13 <vincenz> xahlee: peace
06:21:38 <vincenz> Anyone know if it's possible to stick arbitrary functions of acertain type into a variable?
06:21:48 <dcoutts_> alar, what cabal bug is that?
06:22:03 <dons> vincenz: ? ofcourse (I think, if i type check your sentence correctly)
06:22:21 <davidhouse> vincenz: what do you mean by 'variable'?
06:22:23 <vincenz> dons: imagine a typeclass Foo, with operations foo and bar
06:22:31 <vincenz> and imagine some basic implementation on top of Int
06:22:40 <alar> ah, that's not 
06:22:44 <alar> cabal bug
06:22:44 <vincenz> now imagine a second instance that uses underlying Foo's to generate a Foo
06:22:46 <alar> !
06:22:50 <dons> you can stick functions in class Foo into a variable using existentials
06:22:57 <vincenz> yeah
06:23:01 <vincenz> but now I need something mre
06:23:02 <alar> dcoutts
06:23:06 <vincenz> wait, let me cookup  a concrete example
06:23:14 <dons>  v :: forall v . Foo v => FOO v
06:23:20 <alar> Note: Cabal-1.0.1 has a bug. If the <package>.cabal or <package>.buildinfo has any directories
06:23:20 <alar> in extra-lib-dirs then they are ignored from install command.
06:23:32 <alar> that's from HSQL/INSTALL
06:23:55 <dcoutts_> alar, is it fixed in current cabal? or still a bug?
06:24:15 <alar> ]dcoutts: which version is current?
06:24:16 <dcoutts_> alar, if it's still a problem then please file a bug report so we don't forget it.
06:24:23 <dcoutts_> alar, 1.1.4
06:24:41 <vincenz> anyone have a suggestion for a third name
06:24:43 <alar> ghc-pkg says it has cabal-1.0
06:24:43 <vincenz> foo, bar and ...
06:24:54 <alar> must I update cabal?
06:25:03 <dcoutts_> alar, not if you don't want to
06:25:12 <dcoutts_> ghc-6.4.2 comes with cabal-1.1.4
06:25:19 <dcoutts_> ghc-6.4.1 came with cabal-1.0
06:25:28 <alar> ah, thanks!
06:25:40 <dcoutts_> but you can upgrade Cabal independently of ghc 
06:25:41 * alar goes off to upgrade cabal
06:25:50 <alar> @karma+ dcoutts
06:25:51 <lambdabot> dcoutts's karma raised to 14.
06:26:01 <dcoutts_> you're welcome :-)
06:26:50 <alar> dcoutts: then there is a bug on web site
06:27:01 <dcoutts_> oh?
06:27:07 <alar> Latest Stable Version
06:27:16 <alar> March 11, 2005: Release 1.0 correspondes to the Cabal package in GHC 6.4, Hugs98 March 2005, and nhc98 1.18.
06:27:37 <dcoutts_> I guess if it's shiped with ghc we can't call it unstable can we :-)
06:27:40 <alar> http://www.haskell.org/cabal/download.html <- there
06:27:44 <dcoutts_> alar, good point
06:28:21 <alar> is RC 1.1.4 stable enough?
06:29:47 <Lemmih> mnislaih: Do you want an account on darcs.haskell.org?
06:30:05 <mnislaih> I dont know if I'm really going to need it, but sure
06:30:44 <dons> mnislaih: its a good idea if you want to make your code public in some obvious place
06:32:14 <vincenz> dons: something lke this
06:32:15 <vincenz> http://rafb.net/paste/results/PjlIxS60.html
06:33:16 <vincenz> and it doesn't like the forall syntax
06:33:34 <vincenz> parse error on .
06:33:41 <dons> -fglasgow-exts
06:34:25 <dons> dcoutts_: all fusion forms check :)
06:34:32 <dons> including noacc/* and */noacc
06:34:47 <dcoutts_> dons, yay
06:34:48 <dons> and, they all fire too.
06:34:52 <dcoutts_> great
06:35:07 <dcoutts_> now for performance stats... ;-)
06:35:21 <alar> that's weird: ghc installs itself into /usr/local/bin and cabal looks for it in /usr/bin
06:35:39 <dcoutts_> mm
06:36:27 * dons checks in fusion checks
06:36:44 <dcoutts_> alar, so it doesn't find ghc at all then?
06:36:50 <dons> now, if only we could generate latex proofs from those QuickChecks ...
06:37:01 * Lemmih checks out dons' fusion checks
06:37:03 * dons wants QuickProve
06:37:04 <alar> dcoutts: yes, until I edit GNUmakefile
06:37:47 <shapr> xahlee: Be nice
06:38:31 <alar> It seems something is broken in HSQL/MySQL, it doesn't install anyway and that's independent of Cabal version
06:39:41 <vincenz>     Illegal polymorphic or qualified type: forall (c :: * -> *) b. (Foo c b) => b
06:41:56 <dons> vincenz: you need a constructor in front of the last b, if you're writing an existentia?
06:42:06 <vincenz> I have onoe
06:42:15 <dons> data F = Foo c b => F b, or similar
06:42:20 <vincenz> here is what I have for now
06:42:21 <vincenz> http://rafb.net/paste/results/IqHiUA55.html
06:42:26 <dons> forall c b . i mean
06:42:42 <vincenz> it doesn't like the definition of FooB
06:43:51 <vincenz> maybe cause there's no fundep: b -> f  ??
06:44:12 <alar> @hoogle PackageDescription
06:44:13 <lambdabot> Distribution.PackageDescription :: module
06:44:13 <lambdabot> Distribution.PackageDescription.PackageDescription :: PackageIdentifier -> License -> FilePath -> String -> String -> String -> String -> [(CompilerFlavor, VersionRange)] -> String -> String ->
06:44:13 <lambdabot> String -> String -> String -> [Dependency] -> Maybe Library -> [Executable] -> PackageDescription
06:44:13 <lambdabot> Distribution.PackageDescription.PackageDescription :: data PackageDescription
06:44:34 <alar> ouch
06:44:51 <alar> @hoogle preConf
06:44:52 <lambdabot> Distribution.Simple.preConf :: UserHooks -> Args -> ConfigFlags -> IO HookedBuildInfo
06:45:34 <vincenz> maybe haskell ain't the ideal lang for this
06:47:53 <vincenz> the idea is this: Basically I have some typeclass X, with some trivial instances.  Now I have my tool which parses a language and which I then want to generate the code that I pass into some sort of record.  This record is an instance of the typeclass as well, and will need a lookup table of the lower instances so I can write in my language (bar A = if dum B then bar C else bar B)
06:48:20 <vincenz> suggestions are welcome
06:49:01 <vincenz> with for instance B having been defined as being values of the trivial instance types
06:49:04 <vincenz> (B and C)
06:51:10 <SamB_XP> huh?
06:51:34 * SamB_XP not understand parenthetical [psuedo-]code
06:52:24 <vincenz> bar and dum would be methods of the typeclass
06:53:38 <SamB> and what is a "lower instance"
06:53:58 <vincenz> well I have one instance precoded
06:54:07 <vincenz> let's make it less abstract
06:54:19 <vincenz> a type class that allows me to do (tail and null)
06:54:37 <vincenz> class List l where :: tail :: l a -> l a, null :: l a -> Bool
06:54:48 <vincenz> the instance for [] is obviousl
06:54:57 <vincenz> now in my little language I write
06:55:08 <vincenz> --some syntax: A and B are of basic type [] with these values
06:55:17 <vincenz> tail C = if null B then tail A else tail B
06:55:32 <vincenz> null C = null B && null A
06:55:45 <vincenz> and I might write anotehr one for D
06:55:48 <vincenz> which might depend on C as well
06:56:12 <vincenz> now I want to visualize these things, obviusly I do this with the syntax that TC List exposes..
06:56:16 <alar> dcoutts: can you help me?
06:56:40 <alar> ghc says: Expected type: Args -> ConfigFlags -> LocalBuildInfo -> IO ExitCode
06:56:40 <alar>       Inferred type: [String]
06:56:40 <alar>                      -> ConfigFlags
06:56:40 <alar>                      -> PackageDescription
06:56:40 <alar>                      -> LocalBuildInfo
06:56:40 <alar>                      -> IO ExitCode
06:56:42 <alar>     In the `postConf' field of a record
06:56:44 <alar>     In the record update: defaultUserHooks {preConf = preConf, postConf = postConf}
06:57:00 <vincenz> so I need some way to store in my haskell program that C has internally an A and a B... and then some way to go fro mthe code that I parse to a haskell expression that I also stick in that record, that represents the tail and null
06:57:01 <alar> Docs say: postConf :: (Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ExitCode)
06:57:29 <vincenz> so for the first part that's easy, it's just a Map frm name to some List
06:58:07 <alar> expected type /= documented type!
06:58:13 <SamB> vincenz: A and B are of which values?
06:58:27 <dcoutts_> alar, so what cabal version are you using now?
06:58:27 <vincenz> SamB: in this case in my little proggy language (syntax not yet define)
06:58:35 <vincenz> I say that A and B are for instance lists of [1..10] and [1..8]
06:58:36 <alar> 1.1.3
06:58:37 * xahlee back to learn haskell later...
06:58:52 <vincenz> so they're not defined in terms of other Lists
06:58:59 <alar> dcoutts: but cabal-1.0 had the same complaint at this line
06:59:11 <SamB> vincenz: ah
06:59:32 <alar> @seen slipstream
06:59:33 <lambdabot> slipstream is in #haskell. I don't know when slipstream last spoke.
06:59:49 <dcoutts_> alar, so you need your post-conf hook to take one fewer arg
07:00:07 <dcoutts_> alar, are you sure the package you're building doesn't need a particular Cabal version?
07:00:09 <alar> yes, brute force cured it
07:00:19 <dcoutts_> alar, what are you building?
07:00:31 <alar> HSQL/MySQL
07:01:04 <alar> dcoutts: missmatch betwenn documentation and ghc expectations - that seems strane
07:01:06 <SamB> and how is your language going to know what you want to do with that "tail C = ..." and "null C = ..."?
07:01:09 <alar> strange
07:01:30 <dcoutts_> alar, 1.1.3 didn't come with any version of ghc
07:01:43 <alar> yes, I installed it manually
07:02:04 <alar> but cabal-1.0 behaved just the same
07:02:18 <vincenz> SamB: well it'll parse and then see "aha the defintion tail for C is this"
07:02:29 <dcoutts_> I think we hacked the Setup.lhs for HSQL for the Gentoo package
07:02:42 <vincenz> but maybe I should instead of trying to make C an instance of List
07:02:50 <vincenz> make some typeclass that allows me to simulate a set of these things at once
07:02:54 <vincenz> maybe that's easier
07:02:55 <SamB> what is C?
07:02:59 <alar> dcoutts: but Setup.lhs complies to documentation
07:03:07 <vincenz> SamB: well the thing I define in my prog langy
07:03:16 <alar> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple.html#v%3ApostConf
07:03:17 <SamB> I don't understand your language.
07:03:18 <vincenz> "tail C = .." "null C = ..."
07:03:22 <vincenz> nm
07:03:44 <SamB> I suggest coming up with at least some AST types
07:03:50 <vincenz> I have ast types
07:03:53 <vincenz> I have a full AST
07:04:04 <vincenz> lookk
07:04:05 <SamB> well, you could maybe speak in them ;-)
07:04:07 <vincenz> in my little proggy language I say
07:04:37 <vincenz> "A :: basic list [1..10], B :: basic list [1..8],  tail C = if null B then tail A else tail B, null C = null B && null C"
07:04:42 <dcoutts_> alar, yeah, for the Gentoo package we just replaced the Setup.lhs with a trivial one.
07:04:44 <alar> it seems to be bug in documentation
07:04:48 <dcoutts_> it didn't need all that stuff anyway
07:05:06 <vincenz> now I need some way of simulating that
07:05:14 <SamB> vincenz: oh, wierd!
07:05:31 <vincenz> ..
07:05:43 <alar> HSQL/MySQL/Setup.lhs expects _ for this extra parameter
07:05:51 <alar> so it actually doesn't use it
07:06:07 <davidhouse> vincenz: you mean "null C = null B && null A"?
07:06:20 <alar> and with _ removed and type signature fixed it works
07:06:23 <SamB> davidhouse: vincenz is writing his own strange language
07:06:26 <vincenz> davidhouse: right
07:06:38 <SamB> oh, yeah.
07:06:39 <vincenz> SamB: look the syntax o my language is of little importance
07:06:46 <vincenz> it's how to get this into the typeclass
07:06:51 <SamB> well...
07:07:33 <SamB> what Haskell type is the tail of C going to have?
07:07:41 <dcoutts_> alar, well actually, looking at the code and the docs they're consistent - for the version of Cabal that ghc actually ships
07:07:59 <dcoutts_> alar, you said you're using 1.1.3, not 1.1.4 which is what ghc-6.4.2 ships.
07:08:22 <dcoutts_> alar, so it looks like HSQL-1.7 would be fine with that
07:08:29 <vincenz> SamB: well a record
07:08:39 <vincenz> SamB: containing a lookup table of A and B
07:08:48 <vincenz> and a definition of null and tail that take this lookup table
07:09:07 <alar> dcoutts: does it means the docs are for cabal-1.14 ?
07:09:25 * SamB still don't get it
07:09:38 <dcoutts_> alar, you were looking at the docs for ghc-6.4.2 right? then that referrs to cabal-1.1.4
07:09:58 * dcoutts_ <- lunch
07:10:54 <vincenz> hmm
07:10:59 <vincenz> dons: data F b a = forall f. Foo f b => F (f a)
07:11:03 <vincenz> dons:   foo (F c)   = F . foo $ c
07:11:05 <vincenz> it doesn't liek that
07:11:09 <alar> ah, the docs were for cabal-1.0!
07:11:11 <dons> no no, that's no existential type :)
07:11:23 * alar is silly
07:11:29 <dons> oh, its existential in 'f', is that what you want?
07:11:33 <vincenz> yep
07:11:37 <dons> but i'm not sure if that works.
07:11:51 <alar> and HSQL was probably targeted at cabal-1.0
07:11:54 <vincenz> what's the syntax?
07:11:55 <Foobar> How can I say something like type foo=(Graph g)=>g () () and then use foo in the place of where I know use g () ()?
07:12:00 <dons> it may need to be forall f b . Foo f b = >
07:12:11 <vincenz> dons: nope
07:12:14 <vincenz> that's evne wors
07:12:37 <dons> vincenz: well, the other optoin is to wrap the values in dynamics.
07:12:40 <dons> or use HList
07:12:51 <dons> > [toDyn 'x', toDyn ()]
07:12:51 <lambdabot>  [<<Char>>,<<()>>]
07:13:04 <vincenz> http://rafb.net/paste/results/lHFHK177.html
07:13:07 <dons> this is often used when interpreting little mini languages
07:13:13 <vincenz> dons: ah kewl
07:13:14 <vincenz> anyways
07:13:19 <vincenz> the error is shown on that paste
07:13:21 <vincenz> the line numbers match
07:13:38 <alar> but docs for version 1.1.4 state the same type of postConf
07:14:03 <davidhouse> ooh, by the way dons, i <3 closure printing :)
07:14:32 <SamB> it definately looks nicer in the channel than the type errors that you'd get otherwise
07:14:32 <davidhouse> although it fails if the type involves type variables.
07:14:38 <davidhouse> > length
07:14:38 <Foobar> Or is it impossible to give types qualified by a class a name?
07:14:39 <lambdabot>  Add a type signature
07:14:41 <SamB> > id
07:14:42 <lambdabot>  Add a type signature
07:14:57 <davidhouse> > \(x::Int) -> length (repeat x)
07:14:57 <lambdabot>  Parse error in pattern
07:15:03 <vincenz> > id :: Char -> Char
07:15:04 <lambdabot>  <Char -> Char>
07:15:19 <davidhouse> > \x -> let y :: Int; y = x in length (repeat y)
07:15:20 <lambdabot>  <Int -> Int>
07:15:27 <vincenz> dons: think I should post to haskell-cafe?
07:15:29 <SamB> Foobar: I gave up the last time I tried something like that
07:15:29 <vincenz> to ask
07:15:39 * alar has to reinstall cabal again :(
07:15:58 <dons> vincenz: yeah, its worth it
07:17:02 <vincenz> @type lookup
07:17:03 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
07:18:19 <SamB> dons: oh, @eval won't parse n+k patterns. is this a bug or a feature?
07:18:32 <dons> well, its a known bug in Language.Haskell
07:18:58 <dons> actually, let me see...
07:19:09 <SamB> may I point out that you don't have to get it to parse sensibly, just to parse?
07:19:27 <SamB> if you want it to work for @eval
07:19:34 <SamB> since you don't actually use the AST, anyway
07:19:35 <tibbetts> How do I specify more than one typeclass constraint in a type signature?
07:19:49 <Lemmih> SamB: Just running the lexer, you mean?
07:19:53 <Foobar> tibbetts: (Foo a, Foobar b)=>
07:19:57 <SamB> (Eq a, Show a) => a -> Foo
07:20:00 <tibbetts> thanks.
07:20:02 <dons> SamB, point taken
07:20:14 <Foobar> SamB: Ok, that's the second flaw in Haskell.
07:20:36 <dons> Foobar: thanks. i love it when people say that.
07:20:44 <dons> it goes straight into lambdabot's quote file
07:21:02 <SamB> second flaw?
07:21:32 <SamB> Lemmih: no, I mean dons is just parsing to make sure that whatever was written is actually an expression, and not something evil like
07:21:56 * shapr swears at dynamically typed languages.
07:22:39 <dons> Foobar: rereading the screen, is it possible you don't know what Language.Haskell is? 
07:22:39 <SamB> '"Hello, " ) ++ ( "World!"', or whatever crazy stuff people were doing to get lambdabot to do ACTIONs and whatnot
07:22:42 <kosmikus> shapr: :)
07:22:46 <shapr> Python is like some of the people I've met, complete inability to think ahead.
07:23:05 <dons> @seen nibro
07:23:05 <lambdabot> I saw nibro leaving #haskell 16 days, 17 hours, 36 minutes and 28 seconds ago, and .
07:23:06 <Lemmih> SamB: That would be caught by the lexer.
07:23:06 <Foobar> dons: I was not talking about the same thing as you were.
07:23:10 <dons> ah ok.
07:23:13 <Foobar> dons: And yes, I know what it is.
07:23:22 <SamB> Lemmih: oh? really?
07:23:30 <SamB> strange lexer!
07:23:30 <dons> all good. just trying to work out what the first bug in haskell was.
07:23:38 <shapr> Foobar: Are you also known as goron?
07:23:39 <SamB> flaw, not bug
07:23:52 <Foobar> shapr: Am I?
07:23:57 <davidhouse> yeah, Foobar, what was the first?
07:24:02 <vincenz> sent
07:24:09 <Lemmih> SamB: Oh, right. Yeah, it wouldn't
07:24:26 * shapr doesn't know
07:25:23 <alar> what is *** Exception: (unknown) ?
07:25:34 <alar> is there errno somewhere?
07:25:41 <davidhouse> alar, looks like an unknown exception to me
07:26:10 <dons> alar, usually its an uncaught dynamic exception in ghc 6.4, iirc
07:26:22 <dons> are you using 6.4.2?
07:26:33 <alar> 6.4
07:26:45 <Foobar> This: somerecord{constant=expression}
07:26:59 <Foobar> The lhs is not first class.
07:27:17 <dons> alar, then its a bug that has been fixed in 6.4.1 and later, i think. 
07:27:39 <Foobar> That's a design flaw of Haskell, IMHO.
07:27:49 <alar> oh
07:27:58 <alar> then I have to reinstall GHC either
07:28:04 <davidhouse> Foobar, data R = R { a :: Bool }. Now a :: R -> Bool.
07:28:04 <Foobar> davidhouse: see above.
07:28:11 <davidhouse> the LHS is as firstclass as you like.
07:28:27 <dons> the record system is not the prettiest thing, FooBbar, its generally agreed
07:28:43 <dons> we've got a few proposals , but none really stand out
07:28:59 <shapr> Foobar: Ah.. yes you are goron.
07:29:00 <dons> though i don't know what you mean by not first class.
07:29:09 <dons> ah, its goron, now everything is good again
07:29:49 <isaacd> let sel = a in record { sel = undefined }     doesn't work if 'a' is a record selector
07:29:52 * dons tries to work out where ghc handles n+k patterns
07:30:02 <Foobar> isaacd: indeed
07:30:19 <Foobar> shapr: Why would I be goron?
07:30:22 <isaacd> that is how it's not first-class
07:30:27 <vincenz> crap, I resent it with my gmail account, because my imec account is blocked and forgot to add a header
07:30:30 <vincenz> DOH
07:31:03 <davidhouse> vincenz: (No Subject) ;)
07:31:09 * vincenz kicks himself
07:31:16 <vincenz> yeah I mean I forgot to add a subject
07:31:27 <vincenz> should've been
07:31:40 <vincenz> "Existentials and all that"
07:31:41 * alar kicks BSD4
07:32:26 <shapr> Foobar: because r bruijn == goron, see http://www.haskell.org/pipermail/cvs-all/2004-August/034475.html
07:32:59 <shapr> Foobar: Plus saying that something isn't first class is a flaw of Haskell sounds familiar :-)
07:33:19 <dons> SamB, well, Hsx doesn't handle n+k either. if its a problem, submit a patch to me.
07:33:29 <dons> (i couldn't steal code with little effort)
07:33:54 <SamB> no, not really a problem.
07:36:06 <dons> regarding this record selection thing, its an interesting point
07:36:27 <dons> i'd argue that the selectors themselves are first class -- you can store them in data structures
07:36:36 <dons> but the record update mechanism is constrained
07:36:58 <dons> perhaps in an way that makes sense, i'm not sure
07:37:02 <davidhouse> things like data R = R { a :: Bool }; let a = True in R { a = a } do work.
07:37:44 <dons> yeah, that's a bit odd. the global scope of selectors isn't so nice
07:38:07 <SamB> selectors aren't really first class
07:38:10 <alar> dons: once I tried to pass record field names to a function, compiler claimed it is not a valid name
07:38:20 <vincenz> maybe my approach isn't the right one
07:38:23 <vincenz> dum dum
07:38:23 <dons> the R { sel = n } , sel is kind of magic, its not the same 'sel' you use as a function
07:38:36 <SamB> well, yeah...
07:38:40 <vincenz> maybe I need to have a way to simulate it in it's entirety...except that I don't know how to get the visualization in there
07:38:41 <davidhouse> it's probably just sugar for R n
07:38:42 <dons> its really just a name, so let x = sel in R { x = n } doesn't make any sense
07:38:43 <SamB> thats what I mean ;-)
07:38:43 <kosmikus> no, labels have special status
07:38:49 <Saulzar> Yep, that's about the only issue I have, conflicting record names - though I've learned from Cale and stopped exporting my records unless it makes sense :)
07:39:39 <dons> yeah, the labels have special status, so its a mistake to think the selector function is some how not first class, when you can't bind another name to the label 
07:39:55 <vincenz> dons: it's a shame
07:39:55 <dons> its labels that are special.
07:40:26 <vincenz> labels should be first class
07:40:32 <dons> i'm not sure. records are hairy, so its hardto say theres a better alternative
07:40:36 <SamB> the functions are quite first class, of course ;-)
07:40:36 <vincenz> each record generaets a bounded set of labels
07:40:41 <alar> dons it's labels can not be passed freely around 
07:40:44 <SamB> yes, labels ought to be
07:40:44 <vincenz> and you know tha to access record of type X {a::, b::}
07:40:51 <alar> so they are not first class
07:40:53 <vincenz> the labels can only be in the set labels(X)
07:41:10 <SamB> I could use those for a monopd client...
07:41:52 <davidhouse> @id davidhouse: test
07:41:52 <lambdabot> davidhouse: test
07:41:54 <SamB> at least, I think I could
07:41:57 <davidhouse> awesome.
07:42:14 <davidhouse> my perfect record system:
07:42:17 <dons> alar, yep. labels aren't first class. i'm not sure if its a flaw or not.
07:42:43 <vincenz> dons: I think it requires more complex typing systems
07:42:59 <dons> but at least we do get first class selectors to play with 
07:43:16 <davidhouse> records are easily extensible and updateable. you can add new fields arbitrarily. when you declare a record type and specify some selectors, you're saying "if a record contains at minimum all these fields, you can count as it as of this type".
07:43:37 <vincenz> davidhouse: erm...
07:43:41 <vincenz> davidhouse: that would be ocaml
07:43:47 <vincenz> I don't think that haskell records are extensible
07:43:58 <Saulzar> You can do that in ocaml?
07:44:02 <davidhouse> e.g. data Point = Point { x :: Int, y :: Int, z :: Int }; then origin = { name = "my origin", x = 0, y = 0, z = 0, foo = Bar }. then origin :: Point.
07:44:05 <Saulzar> I thought they were much like Haskell records
07:44:10 <davidhouse> vincenz: yes, i'm saying that is how i'd like it to be.
07:44:14 <vincenz> oh
07:44:23 <dons> vincenz: well, if you encode them with type classes, they are.
07:44:34 <vincenz> dons: except then you can't use labels
07:44:39 <dons> extensible records are a slightly hot topic , atm.
07:44:40 <vincenz> or you need something
07:44:40 <SamB> dons: how does that work?
07:44:41 <vincenz> like
07:44:47 <vincenz> setFOO :: R -> a -> R
07:45:16 * vincenz is getting frustrated
07:45:38 <davidhouse> the only (possible) problem with my system is that records might have more than one type at once
07:45:45 <davidhouse> which is a little unpretty
07:45:54 <alar> dons: it is a flaw as non-uniform implementation ,but it is not a flaw vs. possibility of not having records at all
07:45:56 <davidhouse> although i don't forsee it as a major problem.
07:46:07 <dons> alar, true ! :)
07:46:26 <alar> vincenz: there are TREX - extensible records
07:46:33 <vincenz> hmm
07:46:34 <vincenz> interestin
07:47:06 <davidhouse> but hey, IANACS :)
07:47:21 <Saulzar> davidhouse, What type have record selectors then?
07:47:24 <vincenz> IANACS?
07:47:39 <davidhouse> vincenz: a bit like IANAL
07:47:40 <dons> ah yes, trex, in hugs
07:47:50 <davidhouse> Saulzar: same as currently.
07:47:56 <vincenz> IANAL?
07:48:02 <davidhouse> @google define: IANAL
07:48:04 <lambdabot> No Result Found.
07:48:07 <davidhouse> @google define IANAL
07:48:08 <lambdabot> http://www.definethat.com/hitting.asp?ID=6136
07:48:19 <vincenz> ah
07:48:21 * dons -> sleep
07:48:26 <vincenz> dons: night
07:48:29 <vincenz> IANAI :)
07:48:36 <dcoutts_> g'night dons 
07:48:55 <davidhouse> argh. damned ctrl key.
07:49:07 <vincenz> davidhouse: I am not an idiot
07:49:08 <vincenz> IANAI
07:49:10 <davidhouse> i got a crumb underneath it and had to demolish it, now it won't pop back in
07:50:14 <alar> i-anal
07:50:34 <alar> hm
07:50:42 <alar> ghc-6.4.2 refuses to build
07:50:50 <alar> ghc-6.4 builds ok
07:51:04 <mathewm> alar: which platform?
07:51:20 <alar> FBSD4
07:52:01 <alar> it complains about RetainerProfile.c
07:52:09 <alar> seems I must upgrade GCC as well
07:55:22 <ADEpt> ah, the virtues of running BSD
07:55:22 * ADEpt hides
07:58:41 <Razor-X`> How can I get the last line of a non-seekable handle?
07:58:44 <jethr0> ADEpt: you misspelled "virus" ^_^
07:59:44 <Foobar> shapr: Yes, I know, I have left some traces.
08:00:12 <jethr0> "return . last . lines =<< hGetContents" ?
08:00:35 <Razor-X`> But hGetContents leaves the handle open and waits for more input.
08:01:25 <jethr0> s/hGetContents/readFile/
08:01:45 <SamB> Razor-X`: so `seq` it
08:02:17 <SamB> jethr0: he *did* say handle
08:03:11 <Lemmih> Razor-X`: fmap last (BS.hGetLines handle)
08:03:12 <jethr0> SamB: sry
08:03:40 <jethr0> Razor-X`: afaik you can close the handle after hGetContents
08:04:14 <SamB> jethr0: no, you can't
08:04:33 <SamB> at least, it is stupid to do so...
08:06:11 * vincenz thinks his appraoch is the wrong one
08:06:20 * vincenz figures out a better approach but hmm
08:06:25 <jethr0> SamB: what do i know... what's the answer then, unless you don't mind keeping the handle open?
08:06:41 <Razor-X`> Lemmih: Ah, thanks.
08:07:11 <jethr0> Lemmih: BS?
08:07:44 <Lemmih> jethr0: ByteString.
08:07:50 <jethr0> ahh, good to know
08:07:51 <jethr0> thx
08:07:57 <SamB> jethr0: well, you should look at the comments about hGetContents in GHC.IO
08:08:14 <SamB> apparantly hGetContents semi-closes the handle
08:08:20 <Razor-X`> Yeah, it does.
08:08:34 <vincenz> SamB: I might have an alternate solution to my problem but that induces another problem which is smaller but still difficult
08:09:19 <SamB> jethr0: also, when hGetContents reaches the EOF or encounters a read error, the handle is closed
08:12:50 <shapr> hiya pesco 
08:13:05 <SamB> dons: have you guys looked at what GHC.IO.hGetContents does with errors?
08:13:58 <pesco> Yo shapr, how's code?
08:14:21 <shapr> It's ... macromedia.
08:14:25 <shapr> How's code with you?
08:14:31 <pesco> Ooh, macromedia?!
08:14:37 <shapr> Lemmih: Any new conjure patches?
08:14:41 <shapr> pesco: Learning Flash :-/
08:14:41 <norpan> today i have proudly fixed three c++ bugs
08:14:46 <shapr> yay!
08:15:00 <norpan> time to go home
08:15:07 <pesco> shapr: Code's looking pretty cool. I'm not in SoC so I can spend all summer doing what I want. :-)
08:15:07 <SamB> ouch!
08:15:08 <SamB> flash!
08:15:15 <shapr> SamB: It hurts, but it pays.
08:15:27 <SamB> well, I guess those are probably related
08:15:28 <pesco> shapr: New job?
08:15:57 <shapr> Nah, just trying to get contract work and Flash and PHP are the most commonly offered.
08:16:00 <pesco> shapr: I'm currently building a gateway for posting to my Advogato diary by email.
08:16:10 <SamB> flash *might* beat PHP
08:16:12 <pesco> shapr: Hm, I can imagine.
08:16:45 <shapr> Though I'm hoping for some work using Erlang, Maemo, or other non-braindead framework.
08:16:53 <SamB> doesn't want to be deported for not paying enough taxes :-(
08:16:58 <pesco> Yay.
08:17:10 <shapr> SamB: exactly
08:17:26 <pesco> It took me about two days to tell my new phone how to fetch and send my email. But it works. :-)
08:17:45 <pesco> Okay, it wasn't _totally_ the phone's fault. ;-)
08:17:47 <SamB> not for evasion or anything, just not making enough income to be taxed on
08:17:59 <shapr> Right
08:19:31 <Lemmih> shapr: No, unfortunately not. I've been busy.
08:19:59 <shapr> Any SoC people around? I'm listed as a mentor for Language.C on my mentor homepage.
08:20:16 <Razor-X`> hGetLines isn't doing anything, it just seems to make the program wait indefinitely.
08:20:53 * SamB wonders where he should apply for a job...
08:21:25 <SamB> Razor-X`: well, does the handle have an end?
08:21:39 <SamB> I mean, you aren't trying to read from /dev/random or /dev/zero, are you?
08:21:57 <SamB> or a socket
08:22:46 <Razor-X`> No, it doesen't have an end.
08:22:54 <Razor-X`> I guess I should've said that, heh.
08:23:07 <mauke> does this code make sense: http://rafb.net/paste/results/LAPD6L25.html ?
08:23:11 <shapr> I just noticed that Haskell.org got surprisingly many project slots from Google.
08:23:12 <mauke> it's a string builder
08:23:15 <SamB> well, there is no way you are going to be able to read the last line from an endless handle
08:23:24 <pesco> shapr: How many did we get?
08:23:25 <SamB> shapr: 9, yes
08:23:28 <pesco> Ah.
08:23:31 * vincenz sighs
08:23:31 <hyrax42> 10 I thikn?
08:23:39 <shapr> We got nine, most projects I've glanced at got less.
08:23:44 <hyrax42> or 9
08:23:55 <shapr> Python got 20+ and I found something that got 10, but everything else averages about five.
08:24:07 <pesco> How much money did they shell out in total this year, does anyone know?
08:24:08 <hyrax42> I was pointed to kde when I noticed this
08:24:40 <mux> FreeBSD got 14
08:24:45 <shapr> 29 for KDE
08:24:47 <mauke> or rather, is this approach more efficient than repeated ++ [x], and if so, is this part of the standard library?
08:24:50 <Revision17> @showhex
08:24:50 <lambdabot> Unknown command, try @list
08:24:57 <shapr> Still, I'm thrilled Haskell rates that highly with Google :-)
08:25:00 <Revision17> @hoogle showhex
08:25:00 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
08:25:18 <mux> that's because they're using Haskell
08:25:30 <shapr> Google uses Haskell?
08:25:32 <hyrax42> mux: oh?
08:25:34 <mux> yes
08:25:44 <pesco> Wow, do you know what for?
08:25:47 <shapr> I saw at least one google.com address join #haskell and chat, but that's all I know.
08:25:52 <mux> reppie: ping
08:26:00 <mux> reppie: what do you guys use haskell for already?
08:26:04 <shapr> mauke: Do you know ShowS ?
08:26:34 <mauke> I remember seeing and not understanding it
08:26:46 <shapr> mauke: Try it again after looking at that paste.
08:27:34 <mauke> wait, this is trivial
08:27:36 <davidhouse> > ln (-1)
08:27:36 <lambdabot>  Not in scope: `ln'
08:27:41 <davidhouse> > log (-1)
08:27:42 <lambdabot>  NaN
08:28:00 <shapr> mauke: Looking at ShowS ?
08:28:01 <davidhouse> @hoogle Complex
08:28:01 <lambdabot> Complex :: module
08:28:02 <lambdabot> Data.Complex :: module
08:28:02 <lambdabot> Data.Complex.Complex :: data Complex a
08:28:54 <davidhouse> > log (1 :+ 0)
08:28:55 <lambdabot>  0.0 :+ 0.0
08:29:00 <davidhouse> > log (-1 :+ 0)
08:29:01 <lambdabot>   precedence parsing error
08:29:01 <lambdabot>    cannot mix prefix `-' [infixl 6] and `(:+)' [infix 6] in the same infix expression
08:29:03 <mauke> shapr: yes. append = showChar, right?
08:29:04 <davidhouse> > log ((-1) :+ 0)
08:29:05 <lambdabot>  0.0 :+ 3.141592653589793
08:29:13 <davidhouse> nice, it works.
08:29:16 <hyrax42> cool
08:29:29 <norpan> davidhouse: it works but it looks Complex
08:29:42 <davidhouse> norpan: i agree, we need a more rational approach.
08:29:45 <mux> I find it quite nice to use (Complex)
08:30:00 <davidhouse> it't just a bit unnatural to use :+, norpan.
08:30:15 <mux> -- The infinite list of the terms of the Riemann zeta function.
08:30:15 <mux> zeta :: (RealFloat a, Enum a) => Complex a -> [Complex a]
08:30:15 <mux> zeta s = [ (n :+ 0) ** (-s) | n <- [1..] ]
08:30:17 <norpan> yes, that operator doesn't seem Real
08:30:41 <hyrax42> god will soon strike down this channel
08:30:45 <hyrax42> if this continues
08:31:01 <norpan> sorry
08:31:10 <hyrax42> or at least that secret squad against overuse of puns
08:31:18 <hyrax42> :p
08:31:36 <davidhouse> it's integral to the survival of this channel that we stop.
08:31:38 <fanopnaic> does somebody happen to know what GC scheme ghc used before generational GC?
08:31:39 <hyrax42> (I'm just annoyed davidhouse used natural before I got mine in)
08:32:19 <hyrax42> yes davidhouse, it is most quaternionical
08:32:20 <hyrax42> or
08:32:21 <hyrax42> hmmm
08:32:49 <davidhouse> hah :)
08:32:58 <Saulzar> If people would stop enumerating number classes..
08:33:15 <shapr> mauke: "foo" + "bar" + "baz" done in Python causes two separate string concat operations, but "foo" ++ "bar" ++ "baz" usually causes one string concat operation and all the pieces get picked up at once. You can make that explicit with shows where you get to keep adding chunks until you're ready, then you apply it to a string and it all happens at once.
08:34:26 <shapr> mauke: From the paste, I got the impression you were trying to do the same sort of thing, is that correct?
08:34:58 <mauke> yeah
08:35:45 <shapr> hiya dom!
08:35:59 <shapr> dom: What are you doing with the House stack? Something fun & cool?
08:36:12 <dom> Hello I was going to try out lambdabot
08:36:34 <dom> When I can work out how to use irc
08:36:46 <shapr> dom: I was just curious why I got cc'd on your packet parsing mails. Is it because I was mentioned in the CVS log? Or my blog entries maybe?
08:36:46 <norpan> it seems you have worked it out
08:36:49 <norpan> :)
08:37:52 <dom> shapr: I think it must have been your blog. I saw you had been doing something with it so I thought you might know the answer. As you probably saw my question is now answered.
08:38:09 <shapr> Yeah, just curious.
08:38:35 <shapr> Doing something fun with the stack?
08:39:22 <dom> I wanted to parse packets I captured with the libpcap binding.
08:39:55 <dom> @pl \x y -> x y
08:39:55 <lambdabot> id
08:40:27 <dom> Excellent!
08:41:25 <davidhouse> @pl \f g x y -> g x `f` g y -- not always that good :)
08:41:25 <lambdabot> join . ((flip . ((.) .)) .) . (.)
08:41:58 <mauke> @pl \b x s -> b (x ++ s)
08:41:59 <lambdabot> (. (++)) . (.)
08:42:26 <norpan> wow, a lamba expression -> morse code convertor
08:43:11 <vincenz> aha
08:43:14 <vincenz> getting closer to my requirements
08:43:16 * vincenz thinks he needs OO
08:44:13 <dom> @pl \f g a b -> f (g a b)
08:44:13 <lambdabot> (.) . (.)
08:44:15 <SamB> wow, RELAX NG spec is suspiciously reminiscent in places of papers talking about typing
08:44:35 <davidhouse> dcm, you're one of the guys from the mailing list discussion of that combinator?
08:45:40 <dom> Yes I occasionally find my self wanting to compose e.g. concat with intersperse.
08:45:54 <dom> And (.) . (.) does it.
08:47:18 <dom> I was wondering if there was a standard nomenclature for (.) . (.) and (.) . (.) . (.) etc.
08:47:50 <vincenz> dom: boobs
08:48:01 <mauke> .oO( teats )
08:48:22 <caribe> hej there, one question. can anyone tell me how to use the seq command? i read the 98 report and couldn't get any clue how to use this function to really force strict evaluation ;-(
08:48:38 <dom> Very amusing but I don't think it will find favour with Haskell prime.
08:48:43 <davidhouse> > undefined `seq` 2
08:48:44 <lambdabot>  Undefined
08:49:03 <samx> vincenz, i seem to remember you were learning haskell, from an ocaml background. just wondered, how it's progressing ? :-)
08:49:21 <vincenz> samx: getting stuck with existentials
08:49:25 <kombinator> caribe: seq forces the first argument before returning the second
08:49:27 <caribe> hmm?
08:49:53 <davidhouse> > 2 `seq` 2
08:49:54 <lambdabot>  2
08:49:57 <davidhouse> > 2 `seq` 3
08:49:58 <lambdabot>  3
08:50:01 <caribe> so to force evaluation of f(x) i'd put it seq (f x) (f x) ?
08:50:04 <vincenz> > [1..] `seq` 1
08:50:05 <lambdabot>  1
08:50:21 <davidhouse> huh. that's interesting
08:50:26 <caribe> i mean in that sense i could also put it like seq True (f x)
08:50:28 <norpan> it only forces wvaluation to whnf
08:50:44 <norpan> (weak head normal form)
08:50:44 <Igloo> caribe: seq (f x) (f x) is identical to f x
08:51:05 <kombinator> Igloo: it's not, you are computing f x twice there
08:51:27 <Stinger_> http://www.haskell.org/hawiki/HaskellNewbie_2fMonadicIO on this page is the hoik bit correct?
08:51:28 <Igloo> kombinator: Referntial transparency says you don't know how many times it is computed in either case
08:51:45 <kombinator> Igloo: modulo performance
08:51:57 <norpan> exactly, i can make a compiler that computes it 14 times
08:52:11 <caribe> so.. i can't get it.. how can i then force (f x) to be evaluated?
08:52:21 <norpan> by wanting it's value
08:52:38 <kombinator> caribe: you first have to know WHEN you want it to be evaluated
08:52:43 <mauke> by writing (f x)
08:53:08 <caribe> yup.. but if i want it to be evaluated strictly
08:53:48 <Igloo> Can you give an example of what you want?
08:53:55 <caribe> and by typing seq True (f x) i wouldn't get what i want i think
08:54:46 <norpan> if (f x) returns a list you can use something like length (f x) `seq` (f x)
08:54:55 <norpan> err
08:55:20 <norpan> let t = f x in length t `seq` t
08:55:29 <norpan> but as igloo says, what do you want
08:55:34 <norpan> it's easier to answer that
08:55:38 <caribe> um my example is a bit strange.. i have a lookup function that is not necessarily evaluated, but if that lookup function produces an error i would like to recognize that
08:55:58 <norpan> what does it return
08:56:52 <caribe> if it finds something the value, otherwise an exception
08:56:54 <kombinator> caribe: then you probably don't want to force it using seq
08:57:08 <norpan> caribe: i suggest having it return Maybe
08:57:20 <caribe> to recognize this exception even if the value wouldn't be needed later i would like to force the evaluation of the lookup
08:57:20 <norpan> or something similar
08:57:26 <norpan> then you can case on the result
08:57:29 <mauke> just return (Monad m) => m a
08:57:38 <Igloo> If you really do want to use exceptions for some reason then    lookup_result `seq` function_result   is what you want
08:59:28 <caribe> aaah.. ok then i would have to change quite allot.. i guess using Maybe is the better way in that case
09:00:23 <caribe> ..atleast i can work on now :) thanks :)
09:00:50 <norpan> there are more generic exception monads too
09:01:48 <davidhouse> yeah, if you wanted to pass an error message back, then Either might be an appropriate monad.
09:02:35 <norpan> Control.Monad.Error
09:03:35 <Stinger_> what is "a <- getChar" doing when you enter it in the interpretter ?
09:03:52 <davidhouse> Stinger_: into GHCi? it does exactly that.
09:03:59 <norpan> it binds the value into a
09:04:02 * SamB wonders how to debug Java programs in GDB...
09:04:05 <caribe> hmm ok i will have to do a little bit reading.. i just started with haskell and that was quite a lot of information.. :>
09:04:05 <norpan> you can use a afterwards
09:04:15 <Stinger_> heh ok I know it gets a char, how come you cannot do that in a haskell program?
09:04:22 <norpan> you can
09:04:22 <davidhouse> you can.
09:04:25 <norpan> in a do block
09:04:26 <davidhouse> it has to be in the IO monad.
09:05:00 <norpan> davidhouse: i'll leave you to it :)
09:05:06 <Stinger_> oh, hmm
09:06:30 <ADEpt> ghci does not complete function names, right?
09:06:47 <Stinger_> oh, hmm could you paste a quick example of getChar in such a do block?
09:06:54 <davidhouse> sure.e
09:06:58 <davidhouse> @where paste
09:06:58 <lambdabot> http://paste.lisp.org/new/haskell
09:07:17 <alar> ADEpt: why should it?
09:08:20 <Stinger_> ok heres my problem, figured out I can get random vals out of randomIO and randomRIO 
09:08:29 <ADEpt> alar: it would be nice
09:08:39 <alar> heh :)
09:08:41 <lisppaste2> davidhouse pasted "an IO monad do-block" at http://paste.lisp.org/display/20575
09:09:02 <alar> ADEpt: this would break nnaming strategy
09:09:27 <alar> with autocomplete one wants names with shortest different prefixes
09:09:28 <Stinger_> hmmm how do you get the result out, return c?
09:09:49 <ADEpt> alar: ?
09:09:49 <alar> not ones that bear the most information
09:09:53 <davidhouse> return c will throw it back into the IO monad.
09:10:07 <davidhouse> in general you can't write a function IO Char -> Char. IO is a "one-way" monad.
09:10:37 <Stinger_> so you cant get a char value back from a do block? :(
09:10:42 <davidhouse> you can do whatever you want with c in that do-block, but it can't leave it (unless you throw it back into the IO monad again with return)
09:10:46 <ADEpt> alar: why doesnt it happen with files? :)
09:11:06 <Stinger_> this.. is breaking my head : /
09:11:14 <mauke> Stinger_: what's the problem with that?
09:11:27 <mauke> you can always wrap another do block around it
09:11:39 <alar> ADEpt: what does autocomplete filenames?
09:11:46 <davidhouse> Stinger_: for example, in my example, i used the toUpper function, which has type Char -> Char. you can do whatever you want with the char within the do-block: i converted it to upper case.
09:11:55 <Stinger_> how do I rip random value out of an randomIO for use in a program? or is this an IO specific thing
09:12:08 <davidhouse> @hoogle randomIO
09:12:09 <lambdabot> Random.randomIO :: Random a => IO a
09:12:09 <ADEpt> alar: shell autocomplete filenames
09:12:15 <Stinger_> or should I be using something else altogether for random nos
09:12:17 <davidhouse> do a <- randomIO
09:12:48 <Stinger_> will that need a " a :: Integer" above it to nail down the type?
09:13:10 <alar> ADEpt: one single shell you use
09:13:12 <davidhouse> yeah, probably.
09:13:14 <Revision17> @hoogle pad
09:13:14 <lambdabot> Text.Html.cellpadding :: Int -> HtmlAttr
09:13:22 <alar> that doesn't have great impact on the world
09:14:01 <SamB> you know what is really really cool about RELAX NG compact?
09:14:59 <ADEpt> alar: sorry. strike auto from autocomplete
09:15:05 <ADEpt> alar: it's just complete
09:15:07 <Stinger_> so, is it possible to say write a function that returns random numbers using randomIO or is this specifically disallowed?
09:16:09 <ADEpt> Stinger_: it's possible
09:16:17 <Stinger_> is it generally what is done?
09:16:31 <Stinger_> oh and I mean untagged numbers :)
09:16:36 <davidhouse> if something is in the IO monad, you can form a do block, rip the value out with <-, do with it what you like, but you can't get rid of the IO.
09:18:13 <Stinger_> so once you have an IO value, everything that it touches is also IO?
09:18:24 <davidhouse> right.
09:19:30 <SamB> it is a *good* thing that everything touched by an IO value is in IO
09:19:36 <davidhouse> of course.
09:19:37 <Stinger_> is this the same with all monads?
09:19:51 <davidhouse> Stinger_: nope, IO is unique in this respect.
09:19:55 <davidhouse> it is "one-way".
09:20:16 <davidhouse> but if you think about it, it is necessary to have a random number function in IO:
09:20:51 <alar> way out of IO == way to duplicate World
09:20:59 <davidhouse> otherwise, you'd be able to write a function which had type Int or something that returned a random number, i.e. a different one every time you called it.
09:21:02 <Stinger_> yeah, I'm probably still trying to think about things imperitively
09:21:36 <davidhouse> this is totally against the principles of haskell (a function needs to return the same thing when called with the same arguments. this is called referential transparency, and is utterly key to haskell)
09:21:44 <ihope> @where stats
09:21:44 <lambdabot> I know nothing about stats.
09:22:06 <alar> @state
09:22:50 <ADEpt> alar: aha. seems like ghc from cvs does have this feature
09:23:17 <alar> what feature?
09:23:29 <alar> @yow
09:23:30 <lambdabot> Excuse me, but didn't I tell you there's NO HOPE for the survival of
09:23:30 <lambdabot> OFFSET PRINTING?
09:23:39 <alar> @state
09:24:07 <alar> there is no state :(
09:24:18 <ADEpt> alar: indetifiers/module names completion
09:24:48 <alar> ADEpt: do you mean development version of GHC?
09:24:59 <ADEpt> alar: yep
09:25:38 <alar> funny direction of development
09:25:59 <alar> well, if this does not break some other feature, I'll gladly use it :)
09:26:30 <ADEpt> alar: seems like you misinterpret what's it all about.
09:26:58 <ADEpt> alar: I cant see what's funny in being able to press tab in ghci and complete a function name
09:27:12 <alar> it is about the ease of use
09:27:23 <alar> nothing more ore less
09:28:12 <jethr0> @state hello world
09:28:14 <jethr0> @state
09:28:14 <lambdabot> hello world
09:28:29 <Stinger_> well thanks davidhouse, have to go think about that for a bit
09:28:38 <Stinger_> and sleep : /
09:29:15 <alar> @state
09:29:16 <lambdabot> there is no state!
09:31:55 <isaacd> This new haskell chart-rendering library is nice
09:31:58 * SamB wishes for a map/yellow pages service that knows the websites associated for bussinesses
09:32:13 <isaacd> http://dockerz.net/software/chart.html
09:32:54 <isaacd> does anyone know if I can label the axes of the graph with it, e.g. "temperature (K)" ?
09:33:40 <isaacd> s/if/how/
09:33:49 <Revision17> so Unboxed Arrays don't have range checks I guess?
09:34:19 <jethr0_> @leet skills
09:34:19 <lambdabot> Maybe you meant: last list seen
09:45:02 <sam_> Any opinions: I'm making a 'monthToInt' function, that parses a month String like 'Jan' and returns an Int.. if the parsing fails, which would be more proper.. to have the function return 'Maybe Int' with Nothing, in that case.. or to have it return an Error monad?
09:46:31 <Revision17> re Unboxed arrays: I just didn't initialize the entire array :-\
09:46:40 <Lemmih> sam_: Depends on what you want.
09:47:45 <ndm> sam_, you can return fail or return, depending success or failure
09:47:52 <ndm> in a Monad
09:48:02 <ndm> then the end user can pick the maybe monad, and get Maybe Int
09:55:14 <mauke> monthToInt :: (Monad m) => String -> m Int
09:56:08 <Cale> except that fail is evil :)
09:57:00 <Captain_Fourier> hello
09:57:04 <Cale> hi
09:57:12 <AtnNn> i want to parse a file one line at a time, so i tried doing `type Parse = String -> IO (Maybe Parse)' but i get a "cycle in type synonym" error. what should i be doing instead?
09:57:16 <Captain_Fourier> what does the notation `function` mean
09:57:19 <int-e> without `fail' there'd be a nice simple Monad instance for Either.
09:57:40 <Cale> Captain_Fourier: x `f` y = f x y
09:57:48 <Captain_Fourier> oh ok
09:57:54 <davidhouse> > logBase (-3) (-1/8)
09:57:55 <lambdabot>  NaN
09:58:03 <int-e> but due to fail it's instance Error e => Monad (Either e)
09:58:05 <int-e> :(
09:58:08 <Cale> AtnNn: use a newtype maybe?
09:58:34 <Cale> AtnNn: type synonyms are expanded completely at compile time, so they're not allowed to be recursive
09:58:46 <AtnNn> oh ok. ill try newtype then
09:58:49 <AtnNn> thanks
09:58:54 <Cale> int-e: yeah, that sucks
09:58:56 <Captain_Fourier> >2 `take` [1..8]
09:59:03 <Captain_Fourier> > 2 `take` [1..8]
09:59:05 <lambdabot>  [1,2]
09:59:47 <mauke> > 2 `elem` [1..9]
09:59:48 <lambdabot>  True
10:00:43 <mauke> @index getArgs
10:00:44 <lambdabot> System.Environment
10:00:54 <mauke> environment?!
10:01:40 <int-e> the outside world.
10:02:17 <xerox> haha.
10:03:09 <Captain_Fourier> how do you define functions in ghci
10:03:58 <mauke> let foo a b = show a ++ b
10:04:24 <Captain_Fourier> oh ok
10:04:37 <Captain_Fourier> well this allow multiline definitions
10:06:40 <Cale> you can use ; and braces to separate things
10:06:46 <Captain_Fourier> ok
10:06:51 <Captain_Fourier> thanks
10:07:09 <Cale> of course, this is awkward, so at that point you're better off just starting a file
10:09:32 <Captain_Fourier> no i agree
10:09:40 <Captain_Fourier> but i mean quick debugging
10:09:51 <Captain_Fourier> i like to make quick test functions
10:10:45 <jethr0_> because we all know how evil lambdas are:
10:10:46 <jethr0_> http://gumuz.looze.net/wordpress/index.php/archives/2005/12/30/python-nested-scopes/
10:14:40 <SamB> @where HXT
10:14:40 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
10:33:08 <nn2> what is the command i give landabot to start it on an irc
10:33:17 <nn2> ??
10:33:17 <lambdabot> Maybe you meant: . v
10:33:23 <SamB> hehe
10:33:29 <xerox> nn2 - ./lambdabot ?
10:33:44 <SamB> xerox: it seems to need some more input now?
10:34:04 <nn2> that startes it for a shell in the program what is the next comand
10:34:09 <isaacd> ./lambdabot --online ?
10:34:17 <xerox> SamB - Oh, cool.
10:34:38 * SamB wonders where he should look for a job...
10:35:04 <SamB> nn2: you haven't heard of anything I could do for money, have you?
10:36:46 <alar> Samb: what about taking position of maker of announcements about recruiting announcementmakers?
10:37:22 <SamB> huh huh huh?
10:37:23 <jethr0_> SamB: let's do a haskell startup with shapr and saulzar :)
10:37:34 <SamB> I don't live in europe...
10:38:02 <jethr0_> bah, tele-work is all the hype :)
10:39:36 <Saulzar> I live about as far away from europe as one can get
10:40:45 <jethr0_> Saulzar: where do you live?
10:40:46 <SamB> that would be cool though, Saulzar wrote that raytracer, and shapr is just all-around cool...
10:41:19 <SamB> but my mom is wanting me to try for jobs at dollar stores and stuff...
10:41:24 * jethr0_ feels left out *fishing-for-compliments*
10:41:40 <Saulzar> SamB, Summer job?
10:41:43 <SamB> jethr0_: oh, I missed the "lets"
10:41:48 <SamB> you are cool too ;-)
10:41:53 <jethr0> *yeah*
10:41:57 <Saulzar> New Zealand
10:42:18 <jethr0> SamB: are you planning to go to college?
10:42:28 <Saulzar> Not sure I suppose somewhere in South America would be furhter away
10:42:31 <SamB> I'm going ... slowly
10:43:07 <blackhwkblade> hello guys
10:43:09 <Lemmih> @seen JaffaCake
10:43:09 <lambdabot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
10:43:19 <jethr0> Saulzar: nah, NZ is pretty much the farthest. south africa at least has a similar time zone
10:43:38 <blackhwkblade> someone here from germany who can help me?
10:43:47 <jethr0> blackhwkblade: yes
10:46:39 <blackhwkblade> query
10:47:37 <jethr0> blackhwkblade: you can only send private message if you're registered
10:47:59 <blackhwkblade> oh damn ^^
10:48:08 <blackhwkblade> ok 
10:48:16 <blackhwkblade> u understand german? ^
10:48:21 <jethr0> yes
10:48:23 <blackhwkblade> k
10:48:43 <jethr0> blackhwkblade: join #jethr0
10:49:21 <evergreen> Hi all.  I'm learning haskell.  I'm working on a short script that parses some things using MissingH.Wash.Mail.MailParser.  Everything's going well, but I'm getting lost in exception handling.
10:50:35 <evergreen> I can litter my code with case statements to handle "Left" cases, but I'd like a way to throw errors and catch them all at a high level so I can display them to the user.
10:50:53 <evergreen> Can anyone point me to the right documentation?
10:52:37 <norpan> evergreen: do you know about monads?
10:53:03 <evergreen> I have a vague understanding of monads.  I use the IO monad, of course.
10:53:34 <norpan> @doc Control.Monad.Error
10:53:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
10:53:40 <norpan> have a look at that
10:54:16 <vincenz> when does GHC check that for instance there are no duplicate dataconst
10:55:15 <Cale> evergreen: yeah, with the instance in Control.Monad.Error, Either becomes a monad.
10:55:44 <Cale> (errors are propagated, and can be caught)
10:56:05 <evergreen> Thanks norpan and Cale.  So that means the "Either" that MailParser returns integrates somehow automatically with Control.Monad.Error?
10:56:19 <norpan> hopefully
10:56:36 <SamB> hmm, how come darcs push wants password multiple times...
10:57:04 <evergreen> OK.  I will pursue that.  Thanks again.
10:57:41 <evergreen> SamB: Are you using ssh-agent?
10:57:55 <norpan> evergreen: you may have to define an instance of Error for the error message type if it's not String
10:57:58 <SamB> no... how does one go about doing this?
10:59:11 <jethr0> SamB: i never got darcs over ssh to work with passworded keys. password-less keys work fine for me, but maybe i'm just too lazy to find out why
10:59:15 <norpan> evergreen: also, it uses a GHC extension so you have to use -fuse-glasgow-exts
10:59:29 <norpan> if you are using ghc
10:59:58 <evergreen> SamB: The basic starting point is "eval `ssh-agent`; ssh-add".
11:00:09 <norpan> evergreen: sorry, -fglasgow-exts
11:00:27 <evergreen> SamB: You'll need to have a private/public key pair generated with ssh-keygen, of course.
11:00:49 <norpan> or maybe you don't have to use that, maybe it's automatic when you import the module
11:00:50 <evergreen> SamB: I use darcs over ssh without ever typing a password.
11:04:10 <evergreen> SamB: The technique I use is an encrypted RSA keys, BTW.  So the password I type for ssh-add is the password to decrypt my private key; not my password on the remote system.
11:05:54 <nn2> sam you putting somthing on web serv or 
11:06:05 <nn2> are you trying to compile it
11:06:09 <mathewm1> does Control.Monad.Error cover 'devide by 0' and other errors that may come from the non-imperitive evaluation?
11:08:50 <sjanssen> mathewm: no
11:09:12 <mathewm> is there anything that does?
11:22:04 <Razor-X`> Hmmm. JRegex won't make correctly.
11:22:50 <nn2> what is the @ comand for do script with landa bot
11:23:50 <nn2> ??
11:23:50 <lambdabot> Maybe you meant: . v
11:25:19 <sam_> When doing "10 `div` 0" in ghci, it responds with "*** Exception: divide by zero".. Does this mean, it's terminating the program, or is there some way of recovering (e.g. 'catching' the Exception) ?
11:28:54 <mauke> nn2: huh?
11:29:13 <xerox> @docs Control.Exception
11:29:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
11:29:19 <xerox> ^- sam_, look there.
11:30:35 <Cale> sam_: yeah, you can catch the exception, but only from IO, and you have to be a little careful that the exception actually occurs in the body of the catch
11:30:57 <Cale> sam_: Control.Exception.evaluate will help to force the evaluation to occur when you want it to happen.
11:32:22 <sam_> when doing ':type (10 `div` 0), it gives a type "(Integral a) => a".. so, if it can return an Exception, does this mean, Integral a is actually a monad? I think I'm somewhat confused here :-)
11:32:41 <Cale> no, errors are allowed in pure code
11:32:58 <xerox> @type error
11:32:58 <Cale> Normally they're treated the same as nontermination, but you can catch them from IO.
11:32:59 <lambdabot> forall a. [Char] -> a
11:37:05 <nn2> @run 6+9
11:37:05 <lambdabot>  15
11:37:20 <nn2> @run 6*9
11:37:21 <lambdabot>  54
11:37:30 <nn2> ok it works over gere
11:37:35 <nn2> ** here
11:37:39 <jethr0_> are error and undefined motivated in the type system or are the hacks from a typing standpoint? i.e. is Bool = True | False | error | undefined ?
11:38:34 <mauke> error is a function
11:38:38 <Razor-X`> When I'm making JRegex, it skips pretty much everything, why?
11:38:43 <nn2> o, y cant dump
11:39:07 * Beelsebob wonders what a good mathematical representation of a tree is
11:39:14 <nn2> u it seems to come out as definition
11:39:24 <nn2> on my server 
11:39:33 <nn2> dow do i fix that 
11:40:40 <nn2> ** @run 6*9 output  69 {[sixty[nine]}
11:40:47 <nn2> or somthing like that
11:40:56 <nn2> ?? how do i fix this
11:40:57 <lambdabot> Maybe you meant: . v
11:41:30 <pesco> @run 6*10+9
11:41:31 <lambdabot>  69
11:41:34 <int-e> jethr0_: error is a hack; the semantics only know about one undefined value, bottom.
11:41:34 <pesco> :-P
11:42:10 <pesco> int-e: "The" semantics?
11:42:15 <jethr0_> thx
11:43:07 <nn2> pesco, look for your self at srv256.homelinux.net #driven
11:43:18 <nn2> maby you could fix it
11:44:03 <the_lord> hello
11:44:13 * nn2 wonders why it works here and not on his server
11:44:29 <the_lord> isn't out there a function that returns all but the last element of a list?
11:44:30 <pesco> nn2: Sorry, I gotta assemble a desk right now...
11:45:14 <int-e> pesco: well, http://haskell.org/onlinereport/exps.html#sect3.1
11:45:22 <nn2> can some one else help me
11:45:35 <mauke> @hoogle [a] -> [a]
11:45:35 <lambdabot> Prelude.cycle :: [a] -> [a]
11:45:35 <lambdabot> Prelude.init :: [a] -> [a]
11:45:35 <lambdabot> Prelude.reverse :: [a] -> [a]
11:46:11 <int-e> pesco: I've never seen formal semantics that deal with different error values.
11:46:29 <int-e> of Haskell./
11:46:36 <pesco> int-e: Okay.
11:46:42 <sam_> cool.. the error explanation definately is helping me over some of my haskell confusion.. I thought anything dealing with errors would always have to return monads
11:48:06 <nn2> o that is how you do it 
11:48:16 <nn2> @pl 6*9+6-3
11:48:16 <lambdabot> 57
11:50:06 <Cale> the_lord: init
11:50:39 <the_lord> @init
11:50:40 <lambdabot> Not enough privileges
11:51:02 <jethr0_> > init [1..10]
11:51:03 <lambdabot>  [1,2,3,4,5,6,7,8,9]
11:51:51 * jethr0_ would find it cool if lambdabot/ghci could return haddock documentation for functions.
11:52:02 <jethr0_> i think python does that
11:52:17 <the_lord> jethr0_, yes indeed
12:03:28 <ADEpt> question: who know about ocaml's polymorphic variants?
12:18:23 <palomer> ADEpt: I used to know about them
12:18:30 <palomer> does that help?
12:18:31 <palomer> :P
12:19:48 <vincenz> re
12:20:05 <palomer> <:o
12:22:49 <vincenz> ;)
12:22:58 <vincenz> ADEpt: I do
12:25:39 * vincenz knows more ocaml than haskell
12:27:40 <vincenz> not really difficult as ocaml has a much smaller semantic set
12:28:44 <vincenz> ADEpt: ping, actually have a question?
12:31:28 <Razor-X`> What are the requirements you need to build JRegex?
12:38:53 <xerox> @yow
12:38:54 <lambdabot> NATHAN ... your PARENTS were in a CARCRASH!!  They're VOIDED -- They
12:38:54 <lambdabot> COLLAPSED They had no CHAINSAWS ... They had no MONEY MACHINES ... They
12:38:54 <lambdabot> did PILLS in SKIMPY GRASS SKIRTS ... Nathan, I EMULATED them ... but
12:38:54 <lambdabot> they were OFF-KEY ...
12:42:50 <reilly> @version
12:42:50 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
12:42:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:46:31 <SamB> hmm, how do you lex Unicode well...
12:46:55 <Spark> utf8 you mean?
12:47:29 <SamB> no, no. I mean, doesn't Alex not support Unicode?
12:47:35 <Spark> ah
12:47:53 <SamB> I'm under the impression that it currently uses 256-way tables a lot?
12:47:57 <Spark> no idea :)
12:48:14 <SamB> oh well, just pretend I know the input is ASCII...
12:48:48 <SamB> (that way, doesn't matter if it is UTF-8 encoded or not)
12:51:19 <Igloo> alex is used to lex utf8 by GHC, isn't it?
12:54:20 <petekaz> How do I force the evaluation of 'f' in this example?
12:54:23 <lisppaste2> petekaz pasted "How to force evaluation?" at http://paste.lisp.org/display/20585
12:54:28 <Razor-X`> What's a subexpression match?
12:55:59 <petekaz> I'm trying to time how long a function takes to run.  This is all part of a learning experience so I'm not interested in pointers to things that do this functionality.
12:56:24 <vincenz> Igloo: ye
12:56:25 <petekaz> I just want to figure out how to get what I have working.
12:56:28 <vincenz> +s
12:56:32 <SamB> GHC does UTF-8 now?
12:58:22 <Lemmih> petekaz: 'seq' can evaluate it to WHNF.
12:58:25 <Igloo> petekaz: Change getCPUTime to result `seq` getCPUTime
12:58:38 <petekaz> ok ... let me try that.
12:58:40 <Igloo> The second one, that is
12:59:47 <petekaz> Thanks!!
13:00:56 <rainman> how does division work in haskell? I have a function Int -> Int -> Int which should divide two int numbers but i keep getting "Instance of Fractional Int required for definition of function".
13:01:00 <Lemmih> SamB: In a limited way, yes.
13:01:19 <Lemmih> rainman: Use 'div'.
13:01:33 <petekaz> Just triyng to wrap my head around how the monad stuff.  What I really want to do now that you have helped me get that working is make ProfiledResult a monad so I can do stuff like: time func1 >> time func2 >> time func2 and then have the last ProfiledResult contain the total cpu time taken for the entire sequence
13:01:48 <rainman> Improperly terminated character constant
13:02:00 <rainman> (length b) 'div' (length a)
13:02:05 <xerox> hehe
13:02:08 <xerox> `div`
13:02:29 <rainman> oh works.
13:02:37 <Lemmih> SamB: GHC puts unicode charaters in six groups (\1 to \6).
13:03:22 <Revision17> I'm having a problem with some simple IO.  putString is before getLine, but getLine executes first: http://pastebin.com/745457
13:03:36 <rainman> what about if i want to know the rest of the division?
13:03:46 <Revision17> putStr, rather
13:03:49 <rainman> what if i want to know the rest of the division*
13:03:50 <Lemmih> SamB: That way it can differ between uppercase, lowercase, symbols, ect without confusing alex.
13:04:06 <petekaz> Would the above be a good use for making a monad?  Again, this is for learning, and I'm sure this functionality probably exists, but I thought combining a sequence of operations and accumulating cpu usage time would be a good use of a monad.
13:05:04 <petekaz> Revision17: isn't that a buffering thing?  If you add a newline, does it appear first?
13:06:29 <Revision17> petekaz: if you have a bunch of functions in a sequence that modify a datastructure, you can do away with let stepOne = funcOne orig; let stepTwo = funcTwo stepOne; and do all sorts of even cooler things with the State monad
13:06:34 <Revision17> petekaz: I'll try that
13:06:46 <sjanssen> Revision17: the problem is the buffering on stdout
13:07:29 <sjanssen> @hoogle hSetBuffering
13:07:30 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
13:07:52 <stepcut> petekaz: regarding the 'time' Monad -- it sounds like it would be similar to the Writer monad -- so that might be a place to look
13:07:53 <Revision17> yes the buffering was the problem; I'll look into that
13:09:48 <stepcut> petekaz: You could also use something similar to the State monad -- but that is too powerful -- tests should only be able to add their time on to the list of times -- you wouldn't want to let some bogus test subtract time...
13:11:03 <Revision17> sjanssen: thanks, that worked perfectly
13:11:26 <Revision17> at first I thought it was some funky lazy evaluation thing, which threw me
13:11:51 <petekaz> stepcut: right, this is just for learning purposes to see if I finally understand the monad concept.  I was thinking that I would have this "container" called ProfiledResult which holds a result and the time it took to run.  But, if one used bind to sequence a bunch of these, the cpu time should be accumulated.  So I thought I would just make my ProfiledResult a monad.
13:12:47 <norpan> petekaz: it sounds fine
13:12:55 <stepcut> petekaz: right -- that should work fine -- I was just suggesting you could look at the Writer and State monads for inspiration if you get stuck 
13:13:02 <petekaz> Ok.
13:13:13 <petekaz> I just read all about the state monad.
13:13:15 <palomer> writer isn't that useful a monad
13:13:26 <stepcut> palomer: depends on what you want to do 
13:13:26 <norpan> writer is a strange beast
13:13:40 <palomer> what you want to do is rarely solved with writer
13:13:56 <palomer> not all monads are equal.
13:14:06 <xerox> ?palomer
13:14:07 <lambdabot> I think you're all nuts
13:14:41 <stepcut> palomer: well -- for the case of accumately things -- it seems reasonable
13:16:18 <vincenz> polymorphic variants in haskell!
13:17:48 <norpan> using Reader and instantiating a newtype of Float as a monoid with + as the monoid operation
13:17:54 <norpan> that sounds isotheric enough
13:18:15 <xerox> You mean Writer, right?
13:18:32 <rainman> how do i get the rest of a division in haskell?
13:18:38 <norpan> err i mean Writer
13:18:49 <int-e> > 27 `mod` 5
13:18:49 <stepcut> rainman: you mean, the remainder ?
13:18:50 <lambdabot>  2
13:18:52 <Revision17> rainman: you mean like decimal, or remainder?
13:18:53 <norpan> i always forgot which is which :)
13:18:58 <rainman> yup.
13:18:58 <xerox> ?type (mod,rem)
13:18:59 <lambdabot> forall a a1.
13:18:59 <lambdabot>      (Integral a, Integral a1) =>
13:18:59 <lambdabot>      (a -> a -> a, a1 -> a1 -> a1)
13:19:00 <rainman> the remainder.
13:19:03 <rainman> thanks.
13:20:11 <SamB> I don't suppose Happy supports passing arguments to non-terminals?
13:20:32 <norpan> arguments to non-terminals?
13:22:04 <norpan> hmmmi wonder what isoteric means, i meant esoteric
13:22:17 <sam_> Is there any 'criteria' on when it would be recommended to use Control.Exception.throw, instead of Control.Monad.Error.throwError ?
13:22:26 <SamB> well, like, somehow strange or obscure?
13:22:35 <SamB> like, well, unlambda or BF...
13:22:52 <SamB> maybe not-very-practical
13:23:43 <norpan> sam_: the criteria is that one is used with the Error monad and on can be used anywhere
13:24:25 <SamB> but you might be able to catch a MonadError exception in pure code (e.g. if using a pure monad)
13:24:56 <norpan> sam_: but throw can only be caught inside the IO monad
13:25:05 <SamB> but it would have to be the same monad you threw it in, mostly
13:25:08 <norpan> throwError works within an Error monad
13:25:21 <SamB> @hoogle throwError
13:25:22 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:25:38 <SamB> as I suspected, it is a method of a class called MonadError ;-)
13:25:45 <SamB> could be other instances than just Error
13:25:57 <norpan> sure
13:27:20 <sam_> norpan, sure, if you know the context where you are wanting to use a function throwing some kind of an error. But if you are writing a library, where the library might get used in various contexts, I'd imagine there would be some 'best practises' on which types of exceptions use
13:28:09 <norpan> sam_: if the interface to the library is an IO call then you can use IO exceptions, but I see no reason why you should ever throw errors from functional code
13:28:19 <norpan> from _pure_ code I mean
13:28:42 <norpan> it should just return Either someerror someresult
13:28:55 * SamB thinks it would be neat if you could take terminal literals from a Happy grammar and feed them directly into an Alex lexer spec
13:28:56 <psi> what does "Equations give different arities for "func"" mean?
13:29:05 <SamB> well...
13:29:06 <norpan> which incidently is an instance of the MonadError class
13:29:26 <SamB> > let f x = 1; f y z = 2; f 1
13:29:26 <lambdabot>  Parse error
13:29:31 <SamB> > let f x = 1; f y z = 2 in f 1
13:29:31 <lambdabot>  arity mismatch for 'f'
13:29:33 <norpan> psi: it means you have different number of arguments to your patterns in your function definition
13:29:36 <SamB> like that
13:29:47 <Cale> norpan: usually, I'd agree with that, but I don't think it's so bad to throw an error in a sanity-check type situtation.
13:30:12 <Cale> there are also some cases where it's just too inconvenient to be returning an Either or Maybe, like with head and tail
13:30:14 <psi> thanks. Hm.
13:30:29 <SamB> yes, if the error is insane then you should leave it to IO-based wizardry to deal with it
13:30:47 <norpan> Cale: oh, that kind of errors
13:30:51 <SamB> not every layer in the system between where the error might happen and where it would need to be dealt with
13:31:22 <Cale> I think of the distinction as whether the user causes the error or not -- 'error' is good for programmer errors, while for user-errors, you want Either or Maybe.
13:31:29 <SamB> though MonadError should be good for a fairly happy medium
13:32:19 <SamB> of course, if the system is large enough something should catch the error before the system falls over, most of the time...
13:32:50 <SamB> like, say, GHCi doesn't exit for exceptions
13:33:08 <SamB> even if you called a function whose sole purpose is to cause an exit
13:48:31 <palomer> stepcut: you want to accumulate with writer?
13:48:43 <palomer> that'll be hard, considering you can't read what you're writing
13:50:02 <davidhouse> palomer: as in Writer? yeah you can
13:50:22 <davidhouse> there's function whose name begins with c.
13:50:25 <davidhouse> can't remember what it's called.
13:50:37 <davidhouse> @hoogle censor
13:50:38 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
13:51:26 <palomer> so how is writer different from State?
13:52:12 <davidhouse> when you tell with writer, what you pass in gets mappended to the current stuff.
13:52:17 <davidhouse> i.e. nondestructive puts
13:52:31 <palomer> example?
13:53:07 <davidhouse> @hoogle runWriter
13:53:07 <lambdabot> Control.Monad.Writer.runWriter :: (Writer w a -> a, w)
13:53:07 <lambdabot> Control.Monad.Writer.runWriterT :: WriterT w m a -> m (a, w)
13:53:16 <davidhouse> > runWriter (do tell "hello"; tell "world")
13:53:17 <lambdabot>  Not in scope: `tell'
13:53:26 <davidhouse> > runWriter (do Control.Monad.Writer.tell "hello"; Control.Monad.Writer.tell "world")
13:53:27 <lambdabot>  Not in scope: `Control.Monad.Writer.tell'
13:53:31 <davidhouse> ?
13:53:49 <int-e> ask dons
13:54:06 <norpan> lambdabot doesn't have those mpt classes
13:54:29 <davidhouse> well, it evaluates to ((),"helloworld")
13:54:57 <int-e> (see http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs)
13:56:09 <norpan> oh it has reader
13:57:44 <stepcut> palomer: basically what davidhouse said -- by accumulate I mean the Writer monad can be used to append the new values to a list -- and hence, accumulate the results
13:58:06 <davidhouse> > "hello" `mappend` "world" -- bet this won't work either
13:58:07 <lambdabot>  Unterminated end-of-line comment
13:58:12 <davidhouse> > "hello" `mappend` "world"
13:58:13 <lambdabot>  Not in scope: `mappend'
13:58:17 <davidhouse> well, basically:
13:58:33 <davidhouse> class Monoid m where mempty :: m; mappend :: m -> m -> m
13:58:44 <davidhouse> instance Monoid [a] where mempty = []; mappend = (++)
13:59:25 <davidhouse> a monoid is basically (in haskell) an accumulating structure.
13:59:44 <davidhouse> e.g. a nice use would be to keep track of probabilities using instance Monoid Int where mempty = 0; mappend = (*)
13:59:48 <stepcut> palomer: petekaz want to calculate total run time of a bunch of monads -- so each monad would append its time to the list -- and then you use runWriter to get the final list of run times, which you can then sum together.
14:00:04 <davidhouse> if you know any abstract algebra, a monoid a group without inverses.
14:00:26 <xerox> davidhouse - Monoid Ratio is better (-:
14:00:33 <davidhouse> xerox, hmm, true.
14:00:40 <xerox> We used that for Nymphaea.
14:00:51 <davidhouse> ooh, catch name ;)
14:01:08 <davidhouse> xerox, what's Nymphaea?
14:01:13 <davidhouse> other than a monstrosity to type
14:01:28 <xerox> @where nymphaea
14:01:29 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
14:01:50 <xerox> Basically it is a L-System render.
14:02:05 <xerox> (Which are a kind of IFS -- Iterated Fractal Systems.)
14:02:24 <palomer> what would be awkward to do with Writer but easy to do with State?
14:02:27 <davidhouse> hey, sexy site.
14:02:35 <xerox> davidhouse - Thank you (:
14:02:45 <davidhouse> palomer: produce log output.
14:02:53 <davidhouse> that's traditionally what Writer is used for
14:03:01 <xerox> davidhouse - That's the reply for the converse question (:
14:03:09 <davidhouse> with State you'd get a lot of "modify (++ log)"s appearing
14:03:16 <davidhouse> oh, oops.
14:03:28 <stepcut> palomer: not really. State gives you too much power anyway -- you can total dork up the internal state. With Writer, you can just append values
14:03:32 <davidhouse> whereas with Writer it'd be "tell log" :)
14:03:34 <monochrom> "x++" is easier with State.
14:04:01 <davidhouse> right, State is like a more general version of both Writer and Reader.
14:04:11 <SamB> @google alex-mode
14:04:13 <lambdabot> http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendid=1595577
14:04:16 <davidhouse> use one of the latter two when you don't need the entire power of State
14:04:26 <xerox> monochrom - That's just a matter of one definition in the Writer case.
14:04:47 * stepcut is currently using the RWST monad transformer
14:04:58 <xerox> @karma+ stepcut (:
14:04:59 <lambdabot> stepcut's karma raised to 2.
14:05:14 <davidhouse> @kind Control.Monad.RWS.RWST
14:05:15 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:05:19 <davidhouse> har har har.
14:05:22 <norpan> there would be a monoid for numbers if one could decide on + or * :)
14:05:30 <davidhouse> norpan: newtypes :)
14:05:34 <norpan> i know
14:05:43 <davidhouse> newtype MultiplicativeInt = MI Int
14:05:45 <davidhouse> etc
14:05:54 <davidhouse> interestingly, both monads and arrows are also monoids.
14:06:05 <monochrom> Then you can write like "MI 1", "MI 2", "MI 3", ...
14:06:19 <lisppaste2> petekaz annotated #20585 with "Need some help with this" at http://paste.lisp.org/display/20585#1
14:06:58 <petekaz> I could use some help with this.  What's wrong?
14:07:10 <davidhouse> and there's multiplicative (for monads: return () and (>>), for arrows: returnA and (>>>)) and additive (for MonadPlus: mzero, mplus; for ArrowPlus and ArrowZero, whatever the zero is called and <+>)
14:07:16 <petekaz> I'm trying to implement bind for my ProfiledResult type
14:07:51 <Lemmih> petekaz: What's the type of 'f'?
14:07:54 <davidhouse> petekaz: you probably want = f x
14:08:07 <stepcut> For the curious, I am using the R to provide a read-only symbol table lookup environment, the S to provide unique names, and the W to provide output, and the T to transform the IO monad. Though, now I wonder if S is the right thing to use for unique name generation :-/
14:08:07 <davidhouse> or = f (ProfiledResult cpu x) even
14:08:11 <davidhouse> or not.
14:08:16 <davidhouse> = f x. yes. this one.
14:09:02 <davidhouse> stepcut: you could write your own monad for unique name and instantiate MonadState
14:09:19 <petekaz> f should be any function, but by definition of bind, it just has to return m b right?  In my example, I was hoping f would be the time function (first paste above it)
14:09:43 <stepcut> davidhouse: I am not sure what that would buy me...
14:10:06 <davidhouse> stepcut: well you'd get a more specialised monad for unique names, if that's what you want.
14:10:10 <xerox> stepcut - Your own Monad flavoured by State.
14:10:13 <petekaz> In the end, I want something like:  time somefunc >> time somefunc2 >> time somefunc3
14:10:20 <palomer> I said "easy with state but hard with writer", not the other way around!
14:10:22 <stepcut> davidhouse: hrm, I will think about it
14:10:49 <Lemmih> petekaz: It has the type 'a -> ProfiledResult b'. You tried to use it as a 'ProfiledResult b'.
14:10:49 <petekaz> And then the result of that is (ProfiledResult sum_of_cpu_times result_of_last)
14:11:04 <davidhouse> palomer: anything that requires destructive updates. can be done, but not easily.
14:11:10 <petekaz> oh ...
14:11:17 <davidhouse> if you're using frequent destructive updates, then use State.
14:11:20 <petekaz> I'm going to throw the arg away.
14:11:23 <bolrod> hmm.... that integer swapping.. isn't there a mathematical way to that?
14:11:30 <davidhouse> you basically don't get a put with Writer. you get a modify, but not a put.
14:11:35 <bolrod> converting to string and then reversing and reading again seems a bit..
14:11:39 <bolrod> sluggish 
14:11:40 <petekaz> It'll be used with >>, I think I see what you are saying Lemmih 
14:11:55 <stepcut> petekaz: yeah, in (>>=), the function has to have the type, 'a -> m b'
14:12:10 <davidhouse> bolrod: yeah, i suppose so.
14:12:16 <palomer> davidhouse: how are destructive updates awkward?
14:12:27 <davidhouse> palomer, you basically don't get a put with Writer. you get a modify, but not a put.
14:13:09 <davidhouse> > let n = 17; (tens, ones) = (n `div` 10, n `mod` 10) in 10 * ones + tens
14:13:10 <lambdabot>  71
14:13:12 <palomer> modify can serve the same purpose, no?
14:13:14 <palomer> @hoogle modify
14:13:14 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
14:13:14 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
14:13:14 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
14:13:18 <davidhouse> bolrod: ^^
14:13:30 <xerox> There also is a convenience function:
14:13:37 <xerox> > divMod 17 10
14:13:38 <lambdabot>  (1,7)
14:13:42 <davidhouse> fun.
14:14:01 <davidhouse> > let n = 17; base = 10; (tens, ones) = n `divMod` base in base * ones + tens
14:14:02 <lambdabot>  71
14:14:09 <davidhouse> > let n = 17; base = 16; (tens, ones) = n `divMod` base in base * ones + tens
14:14:10 <lambdabot>  17
14:14:21 <bolrod> > let n = 147; base = 10; (tens, ones) = n `divMod` base in base * ones + tens
14:14:22 <lambdabot>  84
14:14:24 <bolrod> ;)
14:14:39 <davidhouse> bolrod: right, but the requirements stated 2-figure ints
14:14:57 <bolrod> bah
14:15:08 <bolrod> it should work for every integer ;)
14:15:13 <davidhouse> was the hexadecimal result just a coincidence?
14:15:26 <davidhouse> bolrod: what, you mean like my read . reverse . show does? :)
14:15:27 <bolrod> ^.0?
14:15:30 <bolrod> indeed :P
14:15:41 <bolrod> shouldn't be too hard
14:15:57 <davidhouse> nope.
14:16:42 <bolrod> divmod should do fine
14:16:47 <int-e> > let n = 23; base = n-1;  (tens, ones) = n `divMod` base in base * ones + tens
14:16:48 <lambdabot>  23
14:16:51 <int-e> :P
14:16:52 <bolrod> > 10 `divMod` 3
14:16:53 <lambdabot>  (3,1)
14:17:19 <bolrod> > 10 `divMod` 1
14:17:20 <dsacode> Hello! If I have [(String, Bool]
14:17:21 <lambdabot>  (10,0)
14:17:39 <bolrod> you quit
14:17:45 <bolrod> indeed...  syntax error
14:18:02 <bolrod> :)
14:19:20 <dsacode> Hello! If i have [String] variables list and I need to get [[(String,Bool)]] list of lists, where it's all possible combinations of (Variable, Bool). Is there easy way to do it?
14:20:00 * alar keeps getting unknown exception
14:21:05 <stepcut> dsacode: yes
14:21:25 <int-e> dsacode: [(var, val) | var <- variables, val <- [False, True]] if you want [(String, Bool)] ...
14:21:37 <xerox> dsacode xs = [(p,b) | p <- permutations xs, b <- [True,False]]
14:21:46 <int-e> dsacode: if you want [[(String, Bool)]] you need to be more specific ...
14:21:52 <dsacode> xerox: thanks!
14:22:03 <nn2> lambdabot, probley has a huge log from this channel
14:22:04 <dsacode> int-e: thanks
14:22:07 <dsacode> stepcut: thanks :)
14:22:15 <stepcut> :p
14:22:35 <xerox> One has to provide an implementation of `permutations' (;
14:22:35 <ulfdoz> xerox: Would you do my java homework, too? :)
14:22:48 <int-e> > liftM2 (,) ["a", "b"] [False, True]
14:22:49 <lambdabot>  [("a",False),("a",True),("b",False),("b",True)]
14:23:01 * int-e won't explain this :P
14:23:33 <stepcut> int-e: that's the method I was going use... though probably with do notation instead of liftM2 :-/
14:23:35 <davidhouse> what do you use to coerce a Fractional into an Integral?
14:23:50 <xerox> liftM2 (,) :: m a -> m b -> m (a,b) -- this is a cool type.
14:23:51 <ADEpt> dons: ping
14:24:02 <davidhouse> i _really_ need to learn my way around the various numeric classes
14:24:02 <xerox> int-e - It is very simple.
14:24:20 <monochrom> Cale has a slick permutations. But you have to ask in #math.  You have to say "I need all permutations and my code in Java sucks, is there a better way?"  Then Cale will show you how simple it is in Haskell.
14:24:23 <stepcut> i _really_ need to finish my Decimal module :)
14:24:27 <xerox> liftM2 f a b = do { x <- a; y <- b; return (f x y) }
14:24:44 <xerox> ski also have very nice permutations code.
14:24:46 <davidhouse> > [ (x, y) | x <- ["a", "b"], y <- [False, True] ] -- much simpler
14:24:46 <lambdabot>  Unterminated end-of-line comment
14:24:52 <davidhouse> > [ (x, y) | x <- ["a", "b"], y <- [False, True] ] {- much simpler -}
14:24:53 <lambdabot>  [("a",False),("a",True),("b",False),("b",True)]
14:24:56 <alar> is there errno anywhere?
14:25:07 <davidhouse> what do you use to coerce a Fractional into an Integral?
14:25:22 <stepcut> alar: you are calling C via FFI ?
14:25:22 <xerox> @type (round,floor,ceil)
14:25:23 <lambdabot> Not in scope: `ceil'
14:25:27 <xerox> Err.
14:25:31 <davidhouse> ceiling.
14:25:33 <xerox> That.
14:25:45 <davidhouse> @type (round, floor, ceiling)
14:25:46 <lambdabot> forall a b a1 b1 a2 b2.
14:25:46 <lambdabot>          (RealFrac a,
14:25:46 <lambdabot>           Integral b,
14:25:46 <lambdabot>           RealFrac a1,
14:25:46 <lambdabot>           Integral b1,
14:25:48 <lambdabot> [3 @more lines]
14:25:52 <xerox> @more
14:25:53 <lambdabot>           RealFrac a2,
14:25:53 <lambdabot>           Integral b2) =>
14:25:54 <lambdabot>          (a -> b, a1 -> b1, a2 -> b2)
14:25:57 <alar> stepcut: yep
14:26:08 <xerox> Now go figure (-:
14:26:13 <alar> I use HSQL.MySQL and it calls C
14:26:32 <ihope> Lemme see if I can remember any C...
14:26:32 <xerox> @docs Foreign.C
14:26:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C.html
14:26:37 <bolrod> you can't do where in lambdabot aye?
14:26:43 <alar> *** Exception: (unknown)
14:26:45 <mux> is there a CGI module for haskell?
14:26:46 <xerox> @docs Foreign.C.Error
14:26:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Error.html
14:26:50 <xerox> ^- This.
14:26:56 <alar> too few info to figure anything
14:26:59 <ihope> bolrod: you can, as long as the where's inside a let.
14:26:59 <stepcut> alar: there is a whole Errno module: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Error.html but I am not sure how to best get the errno into haskell
14:27:02 <ihope> > let x = y where y = 3 in x
14:27:03 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem, res*10 + res')  where (rem',res') = rem `divMod` 10 in swapInteger (142,0)
14:27:03 <lambdabot>  3
14:27:07 <lambdabot> Terminated
14:27:22 <mux> @hoogle cgi
14:27:23 <lambdabot> Network.CGI :: module
14:27:23 <lambdabot> Network.CGI.connectToCGIScript :: String -> PortID -> IO ()
14:27:28 <int-e> http://haskell.cs.yale.edu/haskellwiki/Humor/Homework ... "Do they laugh at you on Haskell mailing list when you ask about permutations?"
14:27:29 <ihope> You won't find "public static void main" in a C program, will you?
14:27:30 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem', res*10 + res')  where (rem',res') = rem `divMod` 10 in swapInteger (142,0)
14:27:32 <lambdabot>  241
14:27:35 <bolrod> :)
14:27:36 <stepcut> alar: you might have to write a small C stub or something to ensure that no system calls accidently tromp on your errno
14:27:42 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem', res*10 + res')  where (rem',res') = rem `divMod` 10 in swapInteger (499283776,0)
14:27:43 <Lemmih> mux: Google for 'NewCGI haskell'
14:27:44 <lambdabot>  677382994
14:27:46 <xerox> ihope - No `public' fore sure.
14:27:55 <bolrod> davidhouse: I think that solution is nicer ;)
14:28:35 <davidhouse> wow, nice
14:28:38 <davidhouse> much simpler than mine:
14:28:39 <alar> stepcut: supposedly HSQL authors should have done this
14:29:00 <davidhouse> ... which still doesn't work.
14:29:10 <davidhouse> bolrod: great, send yours off to the mailing list then.
14:29:11 <mux> Lemmih: cheers
14:30:29 <ihope> Okay, I have a C function.
14:30:34 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem', res*10 + res')  where (rem',res') = rem `divMod` 10 in swapInteger ((-499283776),0)
14:30:36 <dsacode> xerox, int-e: actually that's not what i need. Assume we have ["a","b"] list, output I need is [[("a",True),("b",True)],[("a",True),("b",False)],[("a", False),("b", True)],[("a", False),("b",True)]]
14:30:38 <mux> blah, yet another thing I should add in FreeBSD ports
14:30:38 <lambdabot> Terminated
14:30:40 <ihope> How do I call it from Haskell?
14:30:48 <bolrod> doesn't work for negative ones :)
14:31:05 <xerox> dsacode - That's why you have to provide a `permutations' function.
14:31:13 <dsacode> xerox: ahh, ok
14:31:17 <stepcut> alar: I take it back -- it looks like you use the throwErrno* wrappers
14:32:15 <dsacode> xerox: ERROR - Undefined variable "permutations"
14:32:33 <stepcut> alar: or maybe just the getErrno function in Foreign.C.Error
14:33:16 <davidhouse> ihope, FFI
14:33:21 <davidhouse> go read the manual :)
14:33:29 <ihope> RTFM...
14:33:41 <int-e> > mapM (([True, False] >>=) . (,)) ["a", "b"]
14:33:42 <lambdabot>  Couldn't match `[b]' against `(a, Bool)'
14:34:01 <bolrod> how good an oxymoron is this .  "WTF does WTF mean?"
14:34:02 <bolrod> :]
14:34:17 <xerox> dsacode - That's why you have to provide a `permutations' function.
14:34:28 <davidhouse> bash.org: "wtf is a palindrome" "No it's not dude."
14:34:51 <bolrod> yeah :D
14:35:04 <bolrod> it's a classic ;)
14:35:18 <davidhouse> int-e, how does >>= work for ((->) a) again?
14:35:20 <int-e> > mapM (([True, False] >>=) . (return .) . (,)) ["a", "b"]
14:35:21 <lambdabot>  [[("a",True),("b",True)],[("a",True),("b",False)],[("a",False),("b",True)],[("a",False),("b",False)]]
14:35:55 <bolrod> oh wait!
14:35:58 <palomer> ok, you guys are evil
14:36:02 <davidhouse> @fptools Control.Monad.Reader
14:36:02 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
14:36:24 <alar> stepcut: I'm now trying to catch it 
14:36:34 <int-e> davidhouse: (f >>= g) x = g (f x) x = f x `g` x
14:36:45 <int-e> palomer: sorry. power corrupts.
14:36:46 <davidhouse> cool.
14:37:14 <xerox> int-e - You have got a bad attitude (:
14:37:52 <monochrom> > sequence (replicate 3 [True,False])
14:37:53 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[False,True,True],[False,True,False],[False,False,True],[False,False,False]]
14:38:04 <xerox> Magical.
14:38:42 <mux> bah, I need a darcs version of FPS for NewCGI
14:38:49 <mux> dons: any ETA for FPS 0.7? :-)
14:39:25 <xerox> permutations = sequence . ap replicate length
14:39:56 <xerox> No.
14:40:26 <xerox> permutations = sequence . (replicate =<< length)
14:40:33 <int-e> > map catMaybes $ mapM ((:[Nothing]) . Just) [2,3,5]
14:40:34 <lambdabot>  [[2,3,5],[2,3],[2,5],[2],[3,5],[3],[5],[]]
14:40:45 <mauke> @pl x -> replicate (length x) x
14:40:45 <lambdabot> (line 1, column 3):
14:40:45 <lambdabot> unexpected ">" or "-"
14:40:45 <lambdabot> expecting variable, "(", operator or end of input
14:40:50 <mauke> @pl \x -> replicate (length x) x
14:40:51 <lambdabot> replicate =<< length
14:41:16 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem', res*10 + res')  where (rem',res') = rem `divMod` 10 in map (\list -> map (chr $ (+1)  $ ord)  list) $ intersperse ' ' $  show $ swapInteger ((97531),0)
14:41:17 <lambdabot>  Couldn't match `Int' against `Char -> Int'
14:41:20 <xerox> @karma+ int-e -- Bad attitudes, nice code.
14:41:20 <bolrod> ahhhh
14:41:21 <lambdabot> int-e's karma raised to 6.
14:41:22 <bolrod> :)
14:41:25 <int-e> > join (map . const) [1,2,3]
14:41:26 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
14:41:36 <xerox> ?!
14:41:37 <lambdabot> Maybe you meant: . v
14:41:40 <int-e> > join (>>) [1,2,3]
14:41:41 <lambdabot>  [1,2,3,1,2,3,1,2,3]
14:41:50 * xerox tries to stop int-e
14:42:14 <davidhouse> hmm
14:42:20 <mauke> @type join (replicate . length)
14:42:21 <lambdabot> forall a. [a] -> [[a]]
14:42:25 * davidhouse thinks this monad is worth exploring more
14:42:38 <bolrod> > let swapInteger (0,x)=x; swapInteger (rem,res) = swapInteger $ (rem', res*10 + res')  where (rem',res') = rem `divMod` 10 in map (\list -> map (\x -> chr $ (+1)  $ ord x)  list) $ intersperse ' ' $  show $ swapInteger ((97531),0)
14:42:39 <lambdabot>  Couldn't match `[Char]' against `Char'
14:42:40 <xerox> > join (replicate . length) "ab"
14:42:41 <lambdabot>  ["ab","ab"]
14:42:47 <bolrod> bwah >_>
14:42:58 <int-e> mauke: the bad thing about replicate (length x) x is that is doesn't work for infinite lists; map (const x) x  works though
14:43:01 <xerox> > (replicate . length) "ab"
14:43:02 <lambdabot>  Add a type signature
14:43:17 <davidhouse> @type (return .) . (,)
14:43:17 <lambdabot> forall (m :: * -> *) a a1.
14:43:18 <lambdabot>        (Monad m) =>
14:43:18 <lambdabot>        a1 -> a -> m (a1, a)
14:43:18 <alar> to stop int-e you should probably trigger int-8
14:43:40 <monochrom> haha
14:43:41 <psi> @paste
14:43:42 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:43:52 <psi> lisppaste2: url?
14:43:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:44:34 <xerox> Then it is permutations = sequence . join (map . const) -- cool.
14:44:43 <int-e> dsacode: I think your options are to either get a firm grasp on the list monad or to roll your own code (which isn't that tough anyway)
14:44:48 <xerox> int-e - Mind to write those on a lisppaste, or on HaskellWiki?
14:45:39 <davidhouse> int-e, if f >>= g = \x -> f x `g` x, then how does ([True, False] >>=) work? surely you'd get a type error when trying to use [True, False] as a function
14:45:54 <monochrom> > (sequence . join (map . const) ) [1,2,3]
14:45:55 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],[3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,
14:45:55 <lambdabot> 1],[3,3,2],[3,3,3]]
14:45:57 <int-e> davidhouse: wrong monad.
14:46:08 <int-e> davidhouse: [] >>= is in the list monad.
14:46:09 <davidhouse> aha
14:46:13 <psi> I'm not telling anyone to use the paste facilities, btw. I'm going to do a paste myself.
14:46:41 <int-e> xerox: you need a way to avoid duplicate entries. and I'd strongly advice against using filter on the result.
14:47:05 <davidhouse> > [1..3] >>= map (*2)
14:47:05 <lambdabot>  add an instance declaration for (Num [a])
14:47:05 <lambdabot>   In an arithmetic sequence: [1 .. 3]
14:47:16 <xerox> int-e - Which duplicate entries? (modulo ordering?)
14:47:17 <davidhouse> > [1..3] >>= (*2)
14:47:18 <lambdabot>  add an instance declaration for (Num [b])
14:47:24 <davidhouse> never mind, i remember.
14:47:42 <psi> In the following paste, I have included what I think is relevant.
14:47:45 <lisppaste2> psi pasted "Should this program neccessarily consume so much memory?" at http://paste.lisp.org/display/20590
14:47:52 <xerox> int-e - Still, it would be nice to have those functions on a webpage.
14:48:03 <lisppaste2> int-e pasted "permutations" at http://paste.lisp.org/display/20591
14:49:17 <davidhouse> int-e, so when you did [True, False) >>= (return .) . (,), the >>= was from [] but the return from Reader?
14:49:39 <mathewm> I know you have all been following my efforts to build GHC on Mac OS X...  FWIW, upgrading to Xcode 4.3 ( and gcc 4.0.1 ) made all the difference between "Bus errors" and a happy suite
14:49:41 <int-e> davidhouse: no, the return is from list as well
14:49:44 <davidhouse> err, ([True, False) >>=) . (return .) . (,)
14:49:52 <davidhouse> hmm.
14:50:01 <davidhouse> @type (return .) . (,)
14:50:02 <lambdabot> forall (m :: * -> *) a a1.
14:50:02 <lambdabot>        (Monad m) =>
14:50:02 <lambdabot>        a1 -> a -> m (a1, a)
14:50:08 <alar> how do I interactively convert IO x -> x in GHCi ?
14:50:13 <alar> I forgot
14:50:16 <int-e> davidhouse: it's \var -> [True, False] >>= \val -> return (var, val)
14:50:25 <davidhouse> so it would end up being [(x, y)]. but then [True, False] >>= [(x, y)] makes no sense
14:50:26 <psi> a <- action
14:50:39 <int-e> davidhouse: and everything is in the list monad
14:51:09 <mathewm> @hoogle IO a -> a
14:51:09 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
14:51:10 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:51:10 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
14:51:10 <int-e> psi: hmm, what's Cpu? You probably need a function to force all of the Cpu type, not just the outside constructor.
14:51:23 <davidhouse> @type (([True, False] >>=) .)
14:51:24 <lambdabot> forall b a.
14:51:24 <lambdabot>          (a -> Bool -> [b]) -> a -> [b]
14:51:30 <stepcut> mathewm: is the OS X x86 or PPC ?
14:51:31 <alar> psi: is action evaluated at the moment of binding?
14:51:33 <int-e> psi: you can look at http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs for inspiration
14:51:41 <mathewm> stepcut: OS X
14:51:51 <mathewm> stepcut: OS X PPC
14:51:58 <psi> alar: I don't think so
14:52:10 <int-e> xerox: did you mean any function in particular?
14:52:11 <psi> int-e: data Cpu = Cpu [Int] (Array Int Int)
14:52:38 <lisppaste2> xerox annotated #20591 with "The good looking ones" at http://paste.lisp.org/display/20591#1
14:52:48 <int-e> psi: yes, what's probably happens is that you always have a Cpu constructor and lots of unevaluated thunks inside.
14:53:31 <psi> int-e: I see... I'll take a look at that :)
14:53:32 <psi> thanks
14:54:32 <Lemmih> xerox: How's cabal-get coming along?
14:54:43 <psi> does 'thread' have another name, btw?
14:55:13 <bolrod> posting possible things to get permutations? :)
14:55:57 <xerox> Lemmih: I haven't started yet.  On one side school is getting in the way (Last week!) on the other I was waiting for GHC on Mac Intel, but I should probably go straight on installing linux this week.
14:56:16 <int-e> xerox: permutations [1,2,3] should return [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] in some order - that's what people usually use that term for. I'm not sure what (sequence . join (map . const) ) [1,2,3]  is - I've learned the term 'variations' for that but I'm not sure if that crosses the language barrier unharmed.
14:57:03 <xerox> Lemmih: I'll be mailing the cabal-dev list ASAP so we can discuss what *exactly* need to be done, and I'll do it.  Sounds okay?
14:57:18 <Lemmih> Great.
14:58:20 <int-e> @index mplus
14:58:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:58:31 <monochrom> thread fs cpu = foldl' (flip ($)) cpu fs
14:59:59 <xerox> ?type flip ($)
15:00:01 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
15:00:07 <xerox> ?type foldl' (flip ($))
15:00:08 <lambdabot> forall b. b -> [b -> b] -> b
15:00:13 <lisppaste2> bolrod pasted "permutations" at http://paste.lisp.org/display/20592
15:00:21 <bolrod> some weird thing my teacher came up with
15:00:29 <bolrod> :)
15:01:18 <bolrod> or at least.. fed it to us 
15:01:38 <vincenz> hidiho
15:01:41 <psi> monochrom: nice
15:01:50 <monochrom> > foldl [Left, Right] (flip ($)) True
15:01:50 <lambdabot>  Couldn't match `a -> b -> a' against `[a1]'
15:01:57 <psi> int-e: that was it! works nicely now.
15:02:04 <stepcut> bolrod: have you seen 'swing' ->  http://www.haskell.org/hawiki/LicensedPreludeExts
15:02:05 <int-e> bolrod: it's quite good.
15:02:07 <monochrom> > foldl (flip ($)) True [Left, Right]
15:02:07 <lambdabot>  Couldn't match `Bool' against `Either Bool b'
15:03:12 <int-e> bolrod: but I have the nagging feeling that splitall is O(n^2) in runtime - ah, of course, for the same reason that inits is.
15:04:31 <bolrod> can permutations be done in O(nlogn) ?
15:04:33 <bolrod> or faster?
15:04:36 <Korollary> yes
15:04:39 <vincenz> dumdumdum
15:04:48 <vincenz> how much harder is it to type code with one monad M
15:05:11 <int-e> bolrod: no, but it can be done in O(n!) time.
15:05:18 <bolrod> ofcourse!
15:05:27 <int-e> bolrod: instead of O(n*n!) or worse.
15:05:34 <bolrod> hehe
15:05:46 <bolrod> O(n^(n!))  
15:05:48 <bolrod> is pretty nasty
15:05:55 <bolrod> :]
15:06:51 <int-e> hmm. 1,2,3,many.
15:07:08 <bolrod> haha
15:07:31 <bolrod> > 4^(4*3*2*1)
15:07:33 <lambdabot>  281474976710656
15:07:34 <bolrod> alot
15:07:35 <bolrod> :p
15:07:38 <bolrod> ^.^
15:07:53 <davidhouse> > let fac = product . enumFromTo 1 in take 10 $ map (\n -> n ^ (fac n)) [1..]
15:07:54 <lambdabot>  [1,4,729,281474976710656,752316384526264005099991383822237233803945956334136013765601092018187046051025390625,18573779103967998536475292600877050059722601814700143630557547814646446078614579374205828
15:07:54 <lambdabot> 87329799283736244449494266959076569223726439245179354783903704418724792964858815666683305972213299516182745924190027732525957520727826687079054161368497652925978154271784971591589616129052056082025857
15:07:54 <lambdabot> 03125114218009915579381666148275855722941117635598068431671791924497178300918788840519953095059578579309123290016421831615124520101938411555671860771364394020068386889252758817187787685311544537482862
15:07:54 <lambdabot> 469102436536581701790174787440635452129406555301237380683311737498238976,1968437689569158990741816575210931474941159426411471711723513971206912762674614697790285721848145248734066598162338401401803582
15:07:56 <lambdabot> 20449315514842416525115244552427371202923224467065698285341625604263127334888193318691299788617974181107657209154945499023805142140043302144615256344133746644967893498705866332722609777908054333845223
15:07:59 <lambdabot> [6 @more lines]
15:08:01 <bolrod> ya ya ya!
15:08:02 <lisppaste2> petekaz annotated #20585 with "I give up" at http://paste.lisp.org/display/20585#2
15:08:06 <davidhouse> err, perhaps ten was too many.
15:08:08 <petekaz> I need some help.
15:08:18 <int-e> > take 10 : scanl (*) 1 [1..]
15:08:19 <lambdabot>  add an instance declaration for (Num ([a] -> [a]))
15:08:29 <int-e> > take 10 $ scanl (*) 1 [1..]
15:08:30 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880]
15:08:35 <bolrod> int-e: http://www.flabber.nl/archief/016433.php
15:08:55 <bolrod> :D
15:08:57 <davidhouse> int-e, what's that? the multiplicative fibonaccis?
15:09:02 <nn2> wow that is a lot of nombers
15:09:31 <bolrod> int-e: have you seen that?
15:09:40 <rashakil__> the multiplicative fibonaccis: 1,1,1,1,1,1,1,1,1,1,1... :-)
15:09:49 <bolrod> :D
15:10:04 <vincenz> @introduce davidhouse to my foot >> /msg lambdabot 
15:10:04 <lambdabot> Unknown command, try @list
15:12:15 <vincenz> @fptools Lexer
15:12:15 <lambdabot> Lexer not available
15:12:16 <psi> davidhouse: factorials
15:12:33 <davidhouse> nice! :)
15:12:45 <int-e> bolrod: nope
15:12:46 <davidhouse> wow, the mysteries of scanl :)
15:12:51 <int-e> davidhouse: factorials, du.
15:13:04 <davidhouse> > take 10 $ scanl (+) 1 [1..]
15:13:05 <lambdabot>  [1,2,4,7,11,16,22,29,37,46]
15:13:10 <davidhouse> > take 10 $ scanl (+) 0 [1..]
15:13:11 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
15:13:17 <davidhouse> > take 10 $ scanl (+) 1 [1,1..]
15:13:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:13:19 <int-e> davidhouse: you're missing a fixed point :)
15:13:39 <bolrod> int-e: :)  
15:13:40 <int-e> > take 10 $ fix ((1:) . scanl (+) 1)
15:13:41 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
15:14:30 <davidhouse> > let fibs = 1 : scanl (+) 1 fibs in fibs
15:14:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,
15:14:31 <lambdabot> 39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,
15:14:31 <lambdabot> 225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,
15:14:31 <lambdabot> 190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,378890623731439
15:14:33 <lambdabot> 06,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931,1779979416004714189,2880067194370816120,4660046610375530309,
15:14:36 <lambdabot> [6 @more lines]
15:14:36 <ihope> Ack!
15:14:40 <davidhouse> argh, i borked it again!
15:14:44 * davidhouse hits RET to readily
15:14:48 <ihope> Ye booched it!
15:15:03 * int-e wires davidhouse's enter key to 'take 10'.
15:15:11 <bolrod> :]
15:15:27 <davidhouse> right, i'm coming up with a patch to limit lambdabot to one-line output
15:15:38 <ihope> Put it back the way it was!
15:15:38 <bolrod> @more
15:15:39 <lambdabot> 7540113804746346429,12200160415121876738,19740274219868223167,31940434634990099905,51680708854858323072,83621143489848422977,135301852344706746049,218922995834555169026,354224848179261915075,
15:15:39 <lambdabot> 573147844013817084101,927372692193078999176,1500520536206896083277,2427893228399975082453,3928413764606871165730,6356306993006846248183,10284720757613717413913,16641027750620563662096,2692574850823428
15:15:39 <lambdabot> 1076009,43566776258854844738105,70492524767089125814114,114059301025943970552219,184551825793033096366333,298611126818977066918552,483162952612010163284885,781774079430987230203437,1264937032042997393
15:15:39 <lambdabot> 488322,2046711111473984623691759,3311648143516982017180081,5358359254990966640871840,8670007398507948658051921,14028366653498915298923761,22698374052006863956975682,36726740705505779255899443,
15:15:41 <lambdabot> 59425114757512643212875125,96151855463018422468774568,155576970220531065681649693,251728825683549488150424261,407305795904080553832073954,659034621587630041982498215,1066340417491710595814572169,
15:15:44 <lambdabot> 1725375039079340637797070384,2791715456571051233611642553,4517090495650391871408712937,73
15:15:45 <bolrod> ok sorry :x
15:15:56 <davidhouse> @where lambdabot
15:15:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:16:01 <int-e> @less
15:16:01 <lambdabot> Maybe you meant: last list
15:16:05 <bolrod> hehe :)
15:16:16 <ihope> :lambdabot!n=lambdabo@shodan.cse.unsw.EDU.AU QUIT :Excess Flood
15:16:22 <bolrod> ?
15:16:47 <davidhouse> what does --partial do? only copy a limited number of patched?
15:16:50 <ihope> "lambdabot has quit (Excess Flood)" or something.
15:17:08 <ihope> So with FFI, what do I call one of C's Ints?
15:17:16 <ihope> CInt?
15:17:32 <int-e> davidhouse: only retrieve enough to reconstruct the current version, I believe.
15:18:10 <ihope> Or Int, or Int#...
15:23:35 <ihope> foreign import ccall "ffitest.hs add" add :: Int -> Int -> Int
15:23:49 <ihope> It says "parse error on input `import'"
15:24:03 <davidhouse> -fffi?
15:24:26 <int-e> "ffitest.hs ?
15:24:30 <int-e> not .h?
15:24:33 <ihope> s/hs/c/
15:24:57 <ihope> It says "Malformed entity string".
15:25:32 * vincenz wishes happy had higher order parse states
15:25:47 <vincenz> alist someother
15:25:51 <vincenz>   : someothe
15:25:55 <vincenz>   { [$1] }
15:26:00 <vincenz>    | alist ',' someother
15:26:10 <vincenz>       { $3:$1 }
15:26:15 <int-e> hmm, my test FFI program did   foreign import ccall "t.h trivial" trivial :: CInt -> CInt -> CInt
15:26:17 <bolrod> let fac 0 = 1; fac n = n*fac(n-1) in map (iterate fac) $  take 3 $ iterate fac 3
15:26:31 <bolrod> last time... lambdabot didn't survive :)
15:26:43 <bolrod> > let fac 0 = 1; fac n = n*fac(n-1) in map (iterate fac) $  take 3 $ iterate fac 3
15:26:48 <lambdabot> Terminated
15:26:52 <bolrod> hmm :)
15:27:06 <davidhouse> what module is @eval in?
15:27:18 <int-e> @plugs 1
15:27:19 <lambdabot> Unknown command, try @list
15:27:21 <ihope> @listcommands eval
15:27:21 <lambdabot> Unknown command, try @list
15:27:23 <int-e> well, that one
15:27:26 <ihope> @list eval
15:27:26 <bolrod> :)
15:27:27 <lambdabot> No module "eval" loaded
15:27:31 <ihope> watevr.
15:27:35 <bolrod> @eval id
15:27:36 <lambdabot> you need a Zh function in Haskell
15:27:41 <xerox> O_O
15:27:41 <bolrod> O_o
15:27:43 <int-e> @list plugs
15:27:43 <lambdabot> plugs provides: run
15:27:53 <bolrod> @eval Just x
15:27:53 <lambdabot> its because the timeline diverges and past events themselves unhappen
15:28:02 <bolrod> O_O
15:28:05 <xerox> @eval
15:28:06 <lambdabot> my proof show math is broken right now
15:28:06 <bolrod> what the hell is this?
15:28:08 <xerox> @keal
15:28:09 <lambdabot> with KealDigit quantum crackproof encryption possible
15:28:21 <vincenz> WOOOOOOOT
15:28:21 <davidhouse> @run Just 4
15:28:23 <lambdabot>  Just 4
15:28:27 <davidhouse> @eval Just 4
15:28:28 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
15:28:34 <davidhouse> > Just 4
15:28:35 <lambdabot>  Just 4
15:28:50 <bolrod> haha
15:28:54 <bolrod> @help eval
15:28:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:28:56 <davidhouse> @run is the new @eval (yes, i know lambdabot is going to try to run this line)
15:28:56 <lambdabot>  Not in scope: `line'
15:29:05 <bolrod> hahahah
15:29:17 <int-e> @run away
15:29:18 <lambdabot>  Not in scope: `away'
15:29:26 <davidhouse> heh
15:29:30 <bolrod> @run Just Away
15:29:31 <lambdabot>  Not in scope: data constructor `Away'
15:29:37 <bolrod> @run Just away
15:29:38 <lambdabot>  Not in scope: `away'
15:29:58 <ihope> @eval 1+2
15:29:58 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
15:30:05 <ihope> O_O
15:30:18 <davidhouse> @localtime dons
15:30:18 <ihope> :-P
15:30:18 <lambdabot> Local time for dons is Tue May 30 08:23:11 2006
15:30:22 <bolrod> what the hell did eval become
15:30:26 <bolrod> @eval
15:30:26 <lambdabot> T could perform expressions 600mb and bigger
15:30:27 <bolrod> evil
15:30:35 <ihope> @evil
15:30:45 <int-e> @keal
15:30:46 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
15:30:49 <bolrod> it's transforming?
15:30:53 <bolrod> @evil
15:31:01 <int-e> @spell keal
15:31:02 <lambdabot> Eal Kial keel kcal Kean
15:31:09 <ihope> @help spell
15:31:09 <lambdabot> spell <word>. Show spelling of word
15:31:15 <ihope> @spell foobar
15:31:15 <lambdabot> foobar
15:31:21 <ihope> Yep.
15:31:27 <ihope> @spell lambdabot
15:31:27 <lambdabot> lambda bot lambda-bot lambda lambdas lambda's
15:31:55 <davidhouse> @help run
15:31:56 <lambdabot> run <expr>
15:31:56 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
15:32:07 <bolrod> O_O
15:32:15 <bolrod> holy crap!
15:32:23 <alar> @run 1
15:32:24 <lambdabot>  1
15:32:34 <alar> @run putStr "XYJ"
15:32:34 <lambdabot>  No IO allowed
15:32:36 <ihope> @run 3 seconds
15:32:36 <lambdabot>  Not in scope: `seconds'
15:33:26 <davidhouse> @hoogle dropNL
15:33:27 <lambdabot> No matches found
15:33:37 <vincenz> shift/reduce conflicts:  2
15:33:37 <vincenz> reduce/reduce conflicts: 25
15:33:41 <vincenz> and he fun begins
15:34:05 <aFlag> @run "adf"
15:34:06 <lambdabot>  "adf"
15:34:26 <aFlag> well, you have IO, it's just limited :P
15:34:44 <ihope> So... malformed entity string.
15:34:48 <ihope> What's it mean?
15:35:41 <vincenz> 2 s/r's left
15:36:59 <vincenz> aha
15:37:03 <vincenz> anyone a parsing expert
15:37:12 <vincenz> the two s/r conflicts are due to
15:37:16 <vincenz> function a b c
15:37:19 <vincenz> for instance
15:37:22 <vincenz> function a b . c
15:37:31 <vincenz> reduce a and b into a tight list
15:37:33 <vincenz> or shift in the c
15:39:39 <ihope> "During interactive linking, GHCi couldn't find the following symbol: add"
15:41:06 <int-e> ihope: it expects the file name to end in '.h'.
15:41:22 <davidhouse> @where Data.Bytestring
15:41:22 <lambdabot> I know nothing about data.bytestring.
15:41:26 <ihope> Well, now it does.
15:41:31 <davidhouse> @where ByteString
15:41:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:44:48 <int-e> ihope: and actually that's consistent with the FFI spec. (see http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-200004.1.4)
15:45:37 <ihope> Yes, the filename *does* end in .h.
15:53:48 <davidhouse> @hoogle popen
15:53:48 <lambdabot> No matches found
15:54:49 <mathewm> how do you set shared-object search paths within GHCi?
15:56:03 <dcoutts> LD_LIBRARY_PATH="..." ghci
15:56:20 <dcoutts> that's not within ghci of course
15:56:34 <mathewm> or DYLD_LIBRARY_PATH as the case may be, but I wondered if there was an explicit search path in ghci
15:57:02 <mathewm> or even an explicit dlopen
15:58:47 <dcoutts> not sure what you mean by "explicit" dlopen, ghci does use dlopen yes.
16:00:06 <mathewm> can I type something like ':dlopen /crazy/path/foo.dylib' ?
16:00:06 <vincenz> question
16:00:09 <vincenz> how come
16:00:11 <vincenz> f a b f g
16:00:18 <vincenz> does not create shift reduce conflicts for haskell parser
16:00:51 <alar> hurray! Seems HSQL works now
16:02:14 <dcoutts> mathewm, nope
16:02:19 <vincenz> aha!
16:02:30 * vincenz figures it out
16:03:05 <dcoutts> mathewm, you can explicitly link in objects on the ghci command line
16:03:59 <dcoutts> not sure about shared libs though, you can try it. specify -lfoo -L/crazy/path
16:04:38 <vincenz> \o/
16:04:50 <davidhouse> anyone written lambdabot plugins before?
16:05:06 <davidhouse> how can you tell if a message is a PRIVMSG or not?
16:05:32 <Philippa> all "talking to someone" messages are PRIVMSG (except NOTICE which is for bot responses but nobody uses it)
16:05:33 <davidhouse> (i'm not too versed with IRC but i assume PRIVMSG = /msg or /query)
16:05:54 <Philippa> yeah, /msg foo bar => PRIVMSG foo :bar
16:06:01 <Philippa> (: because bar can contain spaces)
16:06:09 <Philippa> that includes messages to chans
16:06:14 <davidhouse> > 2 + 2
16:06:15 <lambdabot>  4
16:06:17 <davidhouse> @echo
16:06:17 <lambdabot> echo; msg:Message {msgPrefix = "davidhouse!n=david@host86-143-53-67.range86-143.btcentralplus.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
16:06:31 <davidhouse> ah. it's a PRIVMSG to #haskell.
16:07:06 <davidhouse> okay, so you take the msgParams then see if the head of that list begins with a '#'?
16:10:29 <xerox> Goodnight.
16:10:47 <aFlag> hum
16:10:49 <aFlag> @echo
16:10:49 <lambdabot> echo; msg:Message {msgPrefix = "aFlag!n=uno@201.78.5.236", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
16:11:03 <aFlag> @help echo
16:11:04 <lambdabot> echo <msg>. echo irc protocol string
16:11:16 <aFlag> @echo aa
16:11:16 <lambdabot> echo; msg:Message {msgPrefix = "aFlag!n=uno@201.78.5.236", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo aa"]} rest:"aa"
16:12:45 <SamB> hmm, I don't suppose I can extract groups from a match in Alex?
16:14:06 <Razor-X`> If you're telling hGetLine to get a line from a socket, can you tell it to get the last line?
16:14:26 <SamB> not again!
16:14:33 <Razor-X`> Yes, again!
16:14:36 <bolrod> ^.0
16:14:45 <bolrod> the last line is just the line before the end :P
16:14:49 <SamB> well, at least this time you mentioned that it is, in fact, a socket!
16:15:02 <davidhouse> Razor-X`: liftM (last . lines) . hGetContents
16:15:14 <bolrod> :O
16:15:17 <bolrod> yes :)
16:15:20 <SamB> I'm afraid you must wait until you have read the last line already, and there aren't any more ;-)
16:15:49 <SamB> considering that the last time someone suggested the above solution, you said it was taking forever
16:16:00 <Razor-X`> Yeah.
16:16:13 <bolrod> isn't there a way to use ByteString?
16:16:15 <bolrod> ;p
16:16:21 <Razor-X`> So, I guess I'll have to think of some other way to get to the bottom.
16:16:34 <SamB> observe the protocol!
16:16:48 <davidhouse> import Data.ByteString; import Prelude hiding (last, lines); liftM (last . lines) . hGetContents -- :)
16:16:50 <bolrod> ByteString seems pretty fast in the tests
16:16:53 <SamB> what protocol are you using?
16:16:59 <dcoutts> SamB, na, that's a silly idea :-)
16:16:59 <Lemmih> Razor-X`: You want the last line of whats available?
16:17:10 <Razor-X`> Lemmih: Yeah.
16:17:27 <SamB> dcoutts: well, you aren't going to get much from an HTTP connection if you don't send a request, and terminate it properly...
16:17:43 <SamB> unless, of course, the server wasn't going to wait for headers or a payload
16:17:49 <dcoutts> SamB, I'd never have guessed ;-)
16:18:02 * davidhouse fixes lambdabot
16:18:14 <bolrod> :)
16:18:21 <SamB> okay, so you know what I mean, but are acting dense. which I knew anyway.
16:18:25 <Lemmih> Razor-X`: Then use hIsReady and BS.hGetNonBlocking.
16:18:31 <davidhouse> i'm setting the threshhold at 80 chars, does that seem reasonable?
16:18:37 <bolrod> no
16:18:42 <bolrod> thats only one line
16:18:47 <bolrod> 160
16:18:48 <davidhouse> yes...
16:19:06 <davidhouse> (is IRC still 80-chars-a-line, by the way?)
16:19:07 <bolrod> :]
16:19:13 <bolrod> my terminal is!
16:19:19 <bolrod> oh
16:19:19 <bolrod> no
16:19:27 <bolrod> my terminal is ~160
16:19:28 <bolrod> :p
16:19:32 <bolrod> so 320 chars!
16:19:54 <bolrod> hmm.. wait..  161 chars includes the timestamp and nicks ofcourse
16:20:27 <alar> davidhouse: no , my client accepts long lines
16:20:33 <bolrod> 300 chars sound reasonable 
16:20:51 <bolrod> ofcourse it accepts long lines.. but it's just going to wrap it around
16:20:59 <bolrod> which is basically the same as just outputting 2 lines
16:21:07 <alar> it just plits IRC lines into several lines on screen according to window size
16:21:14 <davidhouse> give me an example where > 80 lines is needed.
16:21:17 <alar> splits
16:21:18 <davidhouse> *> 80 chars
16:21:35 <bolrod>  > 80 lines is usefull for printing a book
16:21:45 <alar> .........................................................................................................................................................................................................-----------------------------------------------------------------------------------------------------------------------++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
16:21:49 <alar> long line
16:21:51 <bolrod> yes
16:21:58 <bolrod> annoying line
16:22:03 <alar> :)
16:22:05 <bolrod> it just wraps around
16:22:11 <bolrod> it does not have a seperate timestamp
16:22:28 <bolrod> I'm just using irssi
16:23:05 <bolrod> > show $ take 10 $ [1..]
16:23:06 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10]"
16:23:12 <bolrod> > length $  show $ take 10 $ [1..]
16:23:13 <lambdabot>  22
16:23:46 <bolrod> >  slength $how  $take 6 $ scanl1 (*) [1..]
16:23:47 <lambdabot>  Not in scope: `how'
16:23:52 <bolrod> >  slength $ show  $take 6 $ scanl1 (*) [1..]
16:23:53 <lambdabot>  Not in scope: `slength'
16:23:54 <bolrod> argh
16:23:59 <bolrod> >  length $ show  $take 6 $ scanl1 (*) [1..]
16:23:59 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
16:24:33 <davidhouse> @hoogle scanl1
16:24:33 <bolrod> eh?
16:24:33 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
16:24:41 <bolrod> >  take 6 $ scanl1 (*) [1..]
16:24:42 <lambdabot>  [1,2,6,24,120,720]
16:24:47 <bolrod> >  show $ take 6 $ scanl1 (*) [1..]
16:24:48 <lambdabot>  "[1,2,6,24,120,720]"
16:24:54 <bolrod> > length $ show $ take 6 $ scanl1 (*) [1..]
16:24:55 <lambdabot>  18
16:25:09 <Spark> fixing line length in irc is annoying when you start pasting what someone else has said
16:25:09 <bolrod> what I do different?
16:25:13 <Spark> just like in emails
16:25:16 <dcoutts> @type $take
16:25:17 <lambdabot> parse error on input `$'
16:25:22 <bolrod> Spark: its for lambdabot
16:25:56 <Spark> not anything important then :)
16:25:56 <bolrod> > length $ show $ take 15 $ scanl1 (*) [1..]
16:25:58 <lambdabot>  100
16:26:04 <bolrod> >  show $ take 15 $ scanl1 (*) [1..]
16:26:05 <lambdabot>  "[1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000]"
16:26:19 <bolrod> >  show $ take 19 $ scanl1 (*) [1..]
16:26:20 <lambdabot>  "[1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000]"
16:26:25 <bolrod> >  length $ show $ take 19 $ scanl1 (*) [1..]
16:26:26 <lambdabot>  167
16:26:34 <bolrod> hrm..
16:26:39 <bolrod> >  length $ show $ take 23 $ scanl1 (*) [1..]
16:26:40 <lambdabot>  255
16:26:46 <bolrod> > show $ take 23 $ scanl1 (*) [1..]
16:26:47 <lambdabot>  "[1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171
16:26:47 <lambdabot> 709440000,1124000727777607680000,25852016738884976640000]"
16:27:03 <bolrod> > length $ show $ take 26 $ scanl1 (*) [1..]
16:27:04 <lambdabot>  335
16:27:09 <bolrod> >  show $ take 26 $ scanl1 (*) [1..]
16:27:10 <lambdabot>  "[1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171
16:27:10 <lambdabot> 709440000,1124000727777607680000,25852016738884976640000,620448401733239439360000,15511210043330985984000000,403291461126605635584000000]"
16:27:23 <bolrod> i'd say 340 
16:27:28 <bolrod> is acceptable
16:27:41 <bolrod> > length $ show $ take 27 $ scanl1 (*) [1..]
16:27:42 <lambdabot>  365
16:27:48 <bolrod> >  show $ take 27 $ scanl1 (*) [1..]
16:27:50 <lambdabot>  "[1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,121645100408832000,2432902008176640000,51090942171
16:27:50 <lambdabot> 709440000,1124000727777607680000,25852016738884976640000,620448401733239439360000,15511210043330985984000000,403291461126605635584000000,10888869450418352160768000000]"
16:28:45 <vincenz> WOAH
16:28:47 <vincenz> take it in /msg
16:29:04 <ihope> Do I need to compile a C file before importing it into a Haskell source thingy?
16:29:06 <Lemmih> dons: ping.
16:29:11 <vincenz> Lemmih: hiya
16:29:24 <Lemmih> ihope: Nope.
16:29:38 <davidhouse> darcs just told me "Successfully sent patch bundle to: Don Stewart <dons@cse.unsw.edu.au>"
16:29:40 <Lemmih> vincenz: Yoyo.
16:29:47 <davidhouse> but i don't believe it because i haven't configured sendmail
16:29:52 <vincenz> Lemmih: you good at typing?
16:29:55 <bolrod> haha
16:30:06 <davidhouse> dons, if you get my patch, then... cool :) if not, i'll email it to you later
16:30:08 <bolrod> maybe darcs uses own SMTP  ?
16:30:26 <bolrod> ;)
16:30:39 <Lemmih> vincenz: Yah, m3 r0cks a7 7ypp1ng.
16:30:53 <vincenz> Lemmih: check #oasis
16:30:56 <bolrod> dets c000l m8
16:31:04 <SamB> Bobstopper: nope
16:31:06 <SamB> er, bolrod 
16:31:11 <SamB> too many people
16:31:22 <bolrod> y0. tru det 
16:31:28 <bolrod> ;)
16:31:54 <jcpetruzza> @pl \f g x y -> g (f x) (f y)
16:31:54 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
16:31:55 <SamB> I mean, I wish there was a "lurker" flag
16:32:25 <jcpetruzza> @pl \g f x y -> g (f x) (f y)
16:32:26 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:32:32 <nn2> sam have a question
16:33:07 <vincenz> Igloo: ping
16:33:19 <vincenz> dcoutts: ping
16:33:27 * Igloo is hereish
16:33:28 <ihope> So can anybody give me an example of using FFI that just consists of plopping some stuff into a C header file thingy, putting the right thing in a Haskell source file, then compiling it all the right way?
16:33:30 <dcoutts> @yarr!
16:33:30 <lambdabot> I want me grog!
16:33:36 <vincenz> Question about typing
16:33:40 <mathewm> Hmm, :(  one needs to explicitly export their choice of 'main'
16:33:46 <vincenz> I use [] for tuple syntax
16:33:57 <vincenz> so [1,2,[1,2]] :: (Int,Int, (Int, Int))
16:34:09 <vincenz> now I want to type generic selectors
16:34:16 <SamB> ihope: see FPS before it got crazified?
16:34:20 <vincenz> x#2 used as int => x is a tuple with as second field an Int
16:34:27 <SamB> by which I mean, before it grew modules?
16:34:38 <vincenz> is this feasible?
16:34:57 <davidhouse> night all.
16:35:19 <dcoutts> vincenz, so you need type level ints
16:35:20 <vincenz> Igloo: I'm thinking writing this as constraints
16:35:31 <vincenz> dcoutts: yes I have Int as primitive type
16:35:44 <jcpetruzza> @pl \f g h x y -> f (g x) (h y)
16:35:44 <lambdabot> ((flip . ((.) .)) .) . (.)
16:35:52 <vincenz> dcoutts: oh wait, yes I get what you mean
16:36:02 <vincenz> dcoutts: either way #2 <- the number must be compiletime decideable
16:36:03 <vincenz> aka a constant
16:36:08 <vincenz> can't be x#y
16:36:14 <dcoutts> right
16:36:19 <Igloo> And a constant size tuple too?
16:36:23 <vincenz> well no
16:36:25 <Igloo> If so I think it should be easy
16:36:29 <vincenz> foo x = x#2
16:36:37 <vincenz> and somewhere I get that foo has return type int
16:36:39 <mathewm> I like pointless programming - er, I mean point-free ;)
16:36:44 * vincenz types globally, no generalization on declarations
16:36:52 <ihope> SamB: does GHC support the non-crazified version of FFI?
16:37:09 <SamB> ihope: before FPS began to have so many modules, I mean...
16:37:10 <vincenz> this means that foo :: (Tuple with as second field an Int) -> Int
16:37:19 <Igloo> vincenz: Is let f x = x in (f 'c', f "str") accepted then?
16:37:29 <vincenz> Igloo: I don't have lets, but no
16:37:37 <dcoutts> ihope, see the bits at the bottom of this file: http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString/Base.hs
16:37:44 <vincenz> Igloo: I type globally... 
16:37:55 <dcoutts> ihope, and the corresponding .c & .h files: http://www.cse.unsw.edu.au/~dons/code/fps/cbits/
16:37:56 <Igloo> Fair enough
16:37:59 <nn2> what is the . coammand the for sending a chat message threw monopd
16:38:07 <vincenz> let f x = ...; let g x = (f x) +1 <=... f must return int from usage in g
16:38:16 <SamB> so what do I do if I want to refer to specific parts of a token?
16:38:31 <vincenz> Igloo: it's just that I've heard there were reasons that selectors were done in TH
16:38:45 <SamB> nn2: that is off-topic here, you know
16:38:51 <Igloo> In that case foo x = x#2 is going to infer a constant size of argument tuple, isn't it?
16:38:56 <vincenz> Igloo: also, I will in addition reject nay programs that leave tyvars after typechecking
16:39:16 <vincenz> Igloo: no if that return value is used as int... then we only know that x must have as second field an Int
16:39:43 <vincenz> but I automatically take minimum
16:39:53 <dcoutts> vincenz, sounds a bit ad-hoc
16:39:57 <vincenz> dcoutts: which bit?
16:40:21 <dcoutts> taking the minimum
16:40:24 <vincenz> oh
16:40:25 <vincenz> well
16:40:26 <vincenz> otherwise
16:40:37 <vincenz> assume that finally I type x to be :: Tuple with Int at 1 and Int at 2
16:40:47 <vincenz> any tuple with number of fiels > 2 and those constraints will suffice
16:40:53 <vincenz> so after a global typecheck
16:40:56 <vincenz> I can just make it a tuple of 2 fields
16:41:19 <vincenz> otherwise it becomes undecideable
16:41:38 <dcoutts> hmm, I suppose so
16:41:53 <vincenz> I have the advantage of a globally typed piece of code
16:42:11 <dcoutts> so you end up with constaints which say that a tuple must be at least n big
16:42:16 <vincenz> right
16:42:33 <vincenz> also if I get something like
16:42:42 <dcoutts> so do you not end up with some kind of size polymorphism?
16:42:43 <vincenz> x :: (int at #2) but nothing at #1
16:42:44 <vincenz> I reject it
16:42:53 <dcoutts> what actually fixes the size?
16:43:01 <vincenz> dcoutts: I globally type
16:43:08 <vincenz> assume
16:43:13 <dcoutts> all monomorphic
16:43:14 <vincenz> 'let foo x = x#2"
16:43:15 <vincenz> yep
16:43:40 <vincenz> it suffices my needs :)
16:43:45 <dcoutts> so if you would end up with polyporphism then you reject it
16:43:50 <vincenz> yes
16:43:55 <dcoutts> fair enough
16:44:00 <vincenz> tho possibly it could be extended to a polymorphic system
16:44:04 <vincenz> it's just a headache for code generation
16:44:13 <dcoutts> just use boxing
16:44:20 <vincenz> I don't think that field polymorphism or other polymorphism would for much hassle
16:44:30 <vincenz> would for -> would lead to
16:44:51 <vincenz> dcoutts: I don't feel like using Dyn
16:45:07 <dcoutts> Dyn?
16:45:15 <vincenz> tho I guess it will be necessary, as the easiest representation for the tuples will be [Dyn]
16:45:19 <vincenz> dcoutts: dynamic values
16:45:22 <vincenz> Data.Dynamic
16:45:40 <dcoutts> you're writing an interpreter?
16:45:41 <vincenz> > toDyn 1
16:45:41 <lambdabot>  Add a type signature
16:45:44 <vincenz> dcoutts: yep
16:45:53 <dcoutts> I wouldn't use Dyn
16:45:58 <vincenz> hmm
16:46:05 <dcoutts> I'd use an encoding
16:46:07 <vincenz> then how do I generate the internal haskell types for those tuples
16:46:14 <dcoutts> [Value]
16:46:21 <vincenz> ah
16:46:28 <vincenz> make it less dynamic, restrict it to my type-set
16:46:45 <dcoutts> data Value | VInt Int | ....
16:46:45 <vincenz> data Value = Tuple [Value] | Int | Bool
16:46:48 <vincenz> right :)
16:46:57 <vincenz> good point
16:47:21 <vincenz> tho truth be said, Dyn's kinda like that, except it spans all of haskell's type system
16:47:25 <vincenz> but anyways
16:47:25 <dcoutts> how are you doing closures? or is it not higher order?
16:47:31 <vincenz> hmm
16:47:36 <dcoutts> true, but it's less principled
16:47:39 <vincenz> well typewise it's higher order
16:47:53 <vincenz> not yet sure on how to make that work in the interpreter bit
16:47:55 <dcoutts> and you'd always need to know the type when you cast
16:48:00 <dons> Lemmih: thanks for that patches
16:48:08 <dcoutts> g'morning dons 
16:48:13 <vincenz> morning dons 
16:48:21 <vincenz> yeah.. closures
16:48:22 <vincenz> hmm
16:48:35 <vincenz> damn
16:48:44 <vincenz> especially given how I have mutable variables
16:48:50 <vincenz> x := exp <- define new x
16:48:53 <vincenz> x = exp <- modify x
16:49:30 <vincenz> reason for separation is to ensure proper typing
16:49:30 <Lemmih> dons: I'm in need of a typeclass to cover ByteString(.Char8) and ByteString.Lazy(.Char8).
16:49:53 <SamB> Stringy?
16:50:18 <vincenz> dcoutts: any thoughts on how to do closures?
16:50:25 <dons> Lemmih: perhaps sjannsen's String class will provide one?
16:50:36 <dons> otherwise shouldn't be too hard to hack up
16:50:46 <SamB> yuo can't call it String
16:50:53 <SamB> String is already called String
16:50:57 <vincenz> ByteAss
16:51:18 <dons> yeah, i'm not sure what its called. but it is a class for string-ish things
16:51:23 <dcoutts> vincenz, a pair of function and arguments
16:51:36 * dons gets breakfast
16:51:42 <vincenz> data Vale = .. | VClosure [Value] func
16:52:03 <mathewm> anyone know what this module is/was: Language.Haskell.THSyntax
16:52:09 <Lemmih> dons: I'm working on it. Just wondering if you had issues with it or perhaps even some name suggestions for the classes.
16:53:28 <LordBrain> those earlier $'s could be .s right?
16:53:36 <vincenz> dcoutts: that can become more complicated with mutable variables
16:53:48 <LordBrain> sorry was reading way up in the scroll
16:54:15 <vincenz> let foo x v = x = v; let bar = i := 1; t := foo i; i = 2; t 2;
16:55:06 <ihope> So what's up with GHCi not being able to find this... stuff?
16:55:23 * vincenz will probably need a separate type for mutable variable
16:55:39 <LordBrain> is there a list of open haskell projects somewhere? i'm in the market to practice on something real... 
16:56:25 * vincenz hmms
16:57:55 <LordBrain> hmmm i've been thinking of software for handling online group decision processes.. like voting
16:59:12 <alar> cop-bot software?
16:59:43 <LordBrain> cop-bot?
17:00:14 <dcoutts> dons, so I've got some more fuson bumpf, this time still using the wrapper elim thing, but also eliminating the NoAcc type by expanding out sequenceLoops into 4 cases.
17:00:28 <dcoutts> dons, oh and adding RULES for [ByteString]
17:00:58 <mathewm> @hoogle thModulePrefix
17:00:59 <lambdabot> No matches found
17:01:09 <LordBrain> hey i was reading somewhere this paper on a functional gui system... fruit, that used arrows or something.. anyone have any eperience with that?
17:01:14 <dcoutts> dons, which re-uses all the fuseFooBarEFL functions
17:03:31 <LordBrain> since haskell is so good at concurrency.. it seems like it should be well suited to writing servers
17:03:40 <LordBrain> ghc i mean
17:04:44 <dcoutts> dons, I'll probably hold off 'til we've got the tests/FusionBench.hs going
17:05:08 * dcoutts <- bed
17:06:11 <mahogny> LordBrain, yes, I think there is a lot of unexploited potential
17:06:30 <mahogny> LordBrain, it has been proven to be among the better systems. someone just has to put it to use
17:07:30 <LordBr4in> Well.. i'm just shopping around for something to hack on.. to increase my haskell experience
17:07:54 <mahogny> LordBrain, look through the SoC suggestions. lots of interesting ideas
17:09:11 <dons> dcoutts: ok. to check the performance?
17:09:19 <dcoutts> dons, right
17:09:47 <dons> Lemmih: well, I suppose its a good idea. a few people have asked. 
17:10:01 <dcoutts> dons, I don't really want to send more stuff without knowing I'm making it faster
17:10:17 <dons> yep. so you want me to set up the test bench?
17:10:55 <mahogny> haskell@haskell.org mail; is it just me who thinks that guy messed up linking?
17:14:26 <dcoutts> dons, yes please :-)
17:14:40 <dcoutts> dons, I can't because I'm asleep. ;-)
17:14:47 <dcoutts> well I will be in a sec...
17:14:49 <dons> yes. ok. my job for today.
17:15:07 <dcoutts> ta muchly
17:15:31 <mathewm> Does anyone know if the required build flags for template haskell have changed between 6.4.2 and 6.5 ?
17:15:56 <dcoutts> so then we'll want to compare previous simple fusion rules with the current mass of rules using ghc-6.5 in both cases
17:16:17 <dons> yeah. definitely
17:16:31 <dcoutts> dons, and then I'll do the same for the current and my various proposed modifications
17:16:47 <dons> i can certainly run the current set, then tweak the rules to use loopU instead, and rerun
17:16:59 <dcoutts> eg the sequenceLoops stuff I was working on today, and the fold specialisations I've been thinking about
17:17:00 <dons> its a bit tedious to do at the moment, but it only needs to be done once.
17:17:04 <dons> ok 
17:17:13 <dcoutts> dons, that'd be great.
17:17:28 <dcoutts> ok g'night
17:17:42 <dons> night
17:17:59 <dcoutts> dons, oh and it'll be another opportunity for you to post impressive stats to the haskell lists ;-)
17:20:34 <dons> oh, indeed!
17:20:37 <dons> :P
17:20:43 <vincenz> :)
17:21:13 <dons> @seen sjanssen
17:21:13 <lambdabot> I saw sjanssen leaving #haskell 1 hour, 49 minutes and 29 seconds ago, and .
17:21:16 <dons> doh.
17:29:00 <Korollary> there you go
17:29:04 <stepcut> hrm, maybe I will add a game mode to @pointless...
17:29:37 <Korollary> stepcut: how many haskell coders do you have at work? just curious.
17:30:06 <stepcut> Currently, 4 in-house
17:31:01 <mathewm> How many would you say we have, Korollary?
17:31:07 <Korollary> zero
17:31:49 <mathewm> Anyone able to shed some light on this error 'Variable occurs more often in a constraint than in the instance head'?
17:32:07 <stepcut> It's not a very big company -- so we need to use the most powerful language we can :p
17:32:45 <mathewm> stepcut: what company?
17:32:57 <stepcut> mathewm: Linspire
17:33:24 <mathewm> stepcut: ah yes, I saw the announcement - cool
17:35:02 <dons> stepcut, well put. haskell makes small companies into big ones :)
17:35:08 <dons> well, hopefully..
17:35:19 <stepcut> hope so :)
17:35:52 <mathewm> big companies with a looming labor shortage...
17:36:58 <dons> well, there's a few 100 phd students will to work on haskell, if they only could.
17:37:29 <dons> theres definitely an over supply now, so predicting a shortage might be premature ;)
17:37:44 <stepcut> There are far more good haskell programmers than we could hope to hire
17:38:09 <stepcut> And I think that the delta is only going to get bigger
17:38:35 <mathewm> or, maybe, the Lambda is getting bigger... ;)
17:39:11 <stepcut> :p
17:40:42 <mathewm> Hmm, it seems that in GHC 6.5 one is required to use all the names of the constraint in the "head" . So this is bad: instance ObjCArgument a b => ObjCIMPType (IO a) where
17:41:15 <mathewm> Any quick fixes for this, or do I need to go and change all types to pass around extra params?
17:45:06 * mathewm is hurting his newbie brain
17:45:14 <dons> use ghc 6.4.2?
17:45:22 <mathewm> 6.5
17:45:27 <mathewm> oh..
17:45:30 <mathewm> :(
17:45:31 <dons> i'm suggesting ..
17:45:38 <dons> why do you need the head?
17:45:51 <mathewm> "need" is such a strong word
17:45:51 <dons> instead of the stable branch?
17:46:07 <dons> ok :)
17:46:37 <mathewm> I am just learning - I figure by the time I know what I am doing 6.5 will have matured to 6.6
17:46:55 <mathewm> or maybe we will be up to 10.4
17:47:04 <stepcut> heh
17:47:07 <Igloo> If you can do something you want to do in 6.4.2 and not 6.5 then it's probably worth reporting it if it hasn't already been discussed, though
17:47:30 <stepcut> 6.6 is going to be pretty sweet I think
17:47:41 <stepcut> then again, 6.4 is pretty sweet
17:48:30 <mathewm> Igloo: discussed where?  I would like to check into it
17:49:04 <dons> isn't this the modified instance handling? possibly..
17:49:37 <dons> mathewm: check up the cvs-ghc@ mailing list for some comitts by ross paterson and spj around "relaxed instances" or something similar.
17:49:53 <mathewm> thanks
17:50:37 <mathewm> Honestly, I just want 6.5 so I could use darcs - darcs rocks :)
17:51:27 <dons> darcs doesn't depend on 6.5, does it?
17:51:30 <dons> no. surely not.
17:51:42 <dons> or use darcs with ghc, you mean?
17:51:46 <mathewm> no but the source is in a darcs depot
17:51:52 <dons> yeah, i see.
17:56:58 <Lemmih> dons: Lazy.length returns an Int64 but all the other functions use Int.
17:57:34 <dons> yes.
17:57:37 <dons> its not ideal.
17:57:49 <dons> we need Int64 for a few functions in  there
17:58:24 <emilio_> ^^
17:58:33 <emilio_> hiya
17:58:33 <dons> you're not pulling lazy bytestrings of a network are  you, Lemmih? that would be interesting.
17:58:44 <dons>  /off a/
17:58:51 <emilio_> where noobs can get some answers around here?
17:59:07 <dons> right here. you just ask your question, emilio_ 
18:00:07 <emilio_> ty
18:00:11 <Lemmih> dons: Would MPTCs break fps' portability?
18:00:23 <emilio_> i'm search for a manual for starting using threads with haskell
18:00:28 <dons> possibly. depends on how they're done.
18:00:29 <emilio_> can you point a link to me?
18:00:42 <dons> @docs Control.Concurrent
18:00:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
18:00:44 <dons> perhaps?
18:01:05 <Lemmih> dons: class ByteList list index | list -> index where ..
18:01:08 <dons> and there's also the "awkward squad" paper, on haskell.org, under tutorials.
18:01:10 <Lemmih> dons: Or perhaps without the fundep.
18:01:21 <dons> oh the fundep makes it even worse.. :}
18:01:59 <dons> hmm. well, keep hacking. we'll see where this goes
18:02:07 <dons> what does the array library do?
18:02:43 <mathewm> dons: the fix from spj does seem to be my problem - though he didn't leave any hints for easy fixes.  I guess if there was an equivalent valid structure the change would have been unnecessary. 
18:03:11 <dons> mathewm: perhaps ask on glasgow-haskell-users@ then. this is new code, so maybe there are results they haven't considered.
18:04:05 <Lemmih> dons: MPTC: class HasBounds a => IArray a e where
18:05:41 <dons> just check it runs in hugs.
18:08:39 <Lemmih> I'll tackle it tomorrow. Good night, dons.
18:08:59 <dons> ok. night Lemmih
18:12:35 <cmarcelo> what's the proper mailing list to send email introducing my SoC project? haskell@ ? -cafe@ ? both?
18:15:40 <dons> haskell@ would be fine. its for announcements
18:35:52 <SamB> okay, so how come there doesn't seem to be support in HXT for reading RELAX NG Compact?
18:36:14 <SamB> I mean, isn't that the one that everyone actually uses?
18:36:30 <SamB> nobody *really* writes the XML syntax, do they?
18:37:27 <alar> what is HXT? is it somewhat related to HaXML?
18:37:49 <SamB> it follows in the footsteps of HaXML, I think
18:37:57 <SamB> but goes further with them
18:38:27 <SamB> anyway, it supports RELAX NG schemas, but apparantly only the XML syntax?
18:40:08 * alar has to read about HXT
18:41:32 <dons> here's a nice graph of what fusion buys you in byte strings. this is the _minimum_ speedup you get when you add array fusion (in green): http://www.cse.unsw.edu.au/~dons/tmp/fusion.png
18:41:53 <dons> the longer your pipelines of maps, folds, filters and scans, the greater  the speedup.
18:42:26 <dons> dcoutts: ^^ see above for our first fusion results graphed (with and without -frules-off)
18:52:23 <dons> at the end of the graph, here http://www.cse.unsw.edu.au/~dons/tmp/fusion.png, you see the effect on larger pipelines.
18:52:49 <dons> while the unfused version increases linearly, the fused version stays constant
18:52:59 <dons> hooray for array fusion !
18:53:48 <vincenz> OT: anyone know how to catch stdin and stdout in a bash script
18:53:56 <vincenz> so i can pipe it internally
18:54:09 <dons> using >
18:54:11 <dons> or 'cat'?
18:54:15 <vincenz> erm
18:54:17 <dons> ie.. $stdin=`cat`
18:54:23 <vincenz> erm...
18:54:24 <vincenz> no
18:54:28 <vincenz> foo | plop
18:54:31 <vincenz> plop is a bashscript
18:54:45 <dons> yeah, in plop, you'd say: $stdin=`cat`
18:54:48 <dons> then pass it around
18:54:53 <vincenz> o.O
18:55:00 <vincenz> `cat` ??
18:55:10 * dons used to teach a sh and perl hacking class
18:55:22 <dons> though sed was my favourite part of the curriculum
18:55:26 <vincenz> see I have
18:55:29 <vincenz> # !/bin/bash
18:55:44 <vincenz> cat $1 | grep .. | sed .. | sed ... > $2
18:55:51 <vincenz> but now I want to remove $1 and $2
18:55:56 <vincenz> and just have it pipe stdin to stdout
18:56:26 <kpreid_> then remove "cat $1 |" and "> $2"
18:56:37 <dons> yeah, easy.
18:56:40 <vincenz> o.O
18:56:49 <dons> make it point free ;)
18:56:54 <vincenz> that works?
18:57:00 <dons> grep . sed .  sed 
18:57:00 <Pawer> vicenz
18:57:05 <kpreid_> that's what stdin and stdout are all about
18:57:08 <vincenz> Paer
18:57:08 <Pawer> vincenz
18:57:14 <dons> actually, grep >>= sed >>= sed
18:57:18 <Pawer> you want to catch
18:57:26 <Pawer> the stdout
18:57:37 <Pawer> without broking the pie?
18:57:47 <Pawer> breaking*
18:58:00 <vincenz> yes
18:58:05 <vincenz> hmm
18:58:09 <vincenz> I don't get it tho
18:58:14 <vincenz> if I just remove cat $1
18:58:14 <Pawer> use
18:58:16 <Pawer> tee
18:58:18 <vincenz> and > $2
18:58:18 <Pawer> program
18:58:20 <Pawer> man tee
18:58:21 <vincenz> Pawer: nono
18:58:39 <vincenz> dons: if I remove those... but what if I now have two greps on two different lines...what would the input to the second points-free grep be?
18:58:51 <Pawer> cat $1 | grep .. | sed .. | tee file | sed ... > $2
18:58:52 <vincenz> o.O
18:58:59 <vincenz> cause ... bashscripts are nonmonadic
18:59:04 <vincenz> Pawer: right I have that
18:59:08 <Pawer> ok
18:59:08 <vincenz> Pawer: nono...nm
18:59:10 <dons> sure they're monadic. what do you think | does :)
18:59:13 <kpreid_> vincenz: that's a different problem!
18:59:21 <vincenz> kpreid_: yeah... it's called bad typing
18:59:23 <dons> in fact, if you use h4sh, you can even write in the _list_ monad, in sh
18:59:25 <kpreid_> vincenz: for that you need dons' `cat` trick
18:59:32 <kpreid_> stdin can only be read once
18:59:32 <vincenz> kpreid_: cool thx
18:59:37 <vincenz> anyways this fix was perfect :)
18:59:37 <Pawer> mmm
18:59:42 <Pawer> mmmmm
18:59:45 <kpreid_> that is, any particular chunk of stdin
18:59:51 <vincenz> kpreid_: wouldn't that be SERIOUSLY inefficient
18:59:59 <Pawer> call script
19:00:01 <vincenz> I mean imagine stdin file of XXXGb
19:00:08 <kpreid_> well, yes
19:00:12 <dons> vincenz: if you were concerned about efficiency, you'd compile it, no?
19:00:14 <Pawer> i do not get it
19:00:22 <Pawer> X-D
19:00:35 <vincenz> dons: heh...
19:00:40 <vincenz> dons: it's just grep | sed | sed
19:00:56 <kpreid_> vincenz: if you want to do that, you need to write a program which reads its stdin and writes to two pipes.
19:01:05 <kpreid_> actually, no
19:01:16 <dons> also, fuse your sed calls. 
19:01:18 <kpreid_> you can do tee >(second pipeline goes here)
19:01:23 <dons> sed f | sed g == sed 'f;g'
19:01:24 <Pawer> ohh
19:01:39 <Pawer> yo can rewove easily $2
19:01:50 <dons> and then you can dispense with grep too. grep x | sed 'f;g' --> sed '/x/{f;g;}'
19:01:51 <Pawer> and redirect
19:02:04 <dons> and then, since its all sed, you can make it a sed script
19:02:10 <dons> #/usr/bin/sed
19:02:12 <dons> /x/{ f; g; }
19:02:18 <dons> :)
19:02:18 <Pawer>  srh script > out
19:02:24 <Pawer> sh script > out
19:02:27 <vincenz> dumtydum
19:02:35 <Pawer> dons
19:02:42 <Pawer> what is tre difference between
19:02:52 <Pawer> #sh!
19:02:53 <Pawer> and
19:03:02 <Pawer> #!/bin/bash
19:03:04 <Pawer> #!/bin/sh
19:03:08 <Pawer> ???
19:03:09 <lambdabot> Maybe you meant: . id pl v wn
19:03:12 <dons>   #sh! ?
19:03:16 <dons> i've never seen that syntax.
19:03:17 <Pawer> yes
19:03:21 <Pawer> me too
19:03:24 <vincenz> anyone feel like optimizing two sed's into one?
19:03:28 <Pawer> this evening
19:03:33 <dons> vincenz: i pointed out above how you do it.
19:03:36 <Pawer> my brother showed it to me
19:03:44 <vincenz> dons: well erm...not like that
19:04:07 <dons> Pawer: there you go. sounds kinda non-portable. (?)
19:04:16 <Pawer> sounds strange
19:04:16 <vincenz> sed "s/A \(..\)/1 \1/" | sed "s/B \(..\)/2 \1/"
19:04:18 <dons> what does the path use?
19:04:21 <vincenz> so A -> 1, B->2
19:04:36 <vincenz> for the rest the regexp is the same
19:04:42 <Pawer> some teacher's heads will be cutted
19:05:05 <dons> Pawer: when you write #sh!, what sh does it use?
19:05:13 <dons> seems like a security concern
19:05:21 <vincenz> dons: the silent one
19:05:39 <dons> oh, it does work. huh
19:05:39 <monochrom> #sh! looks like a comment
19:05:43 <Pawer> dunno
19:05:47 <Pawer> yes
19:06:08 <vincenz> hmm
19:06:10 <Pawer> i think it works beacuse system guesses the interpreter
19:06:12 <vincenz> #sh! = #!hs ?
19:06:16 <Pawer> no
19:06:24 <Pawer> #!/bin/sh
19:06:36 <dons> oh. i think it might just be a comment.
19:06:42 <Pawer> yes
19:06:53 <triplah> #sh! is a comment
19:06:54 <dons> since if you +x something in the shell, it executes the file even without a #! line
19:07:03 <vincenz> #python!
19:07:07 <triplah> and if the shebang isnt on the first line the interpreter no likey :P
19:07:11 <Pawer> yes
19:07:13 <Pawer> that is
19:07:46 <triplah> sh some file implies that the filename is an argument to sh :P
19:07:51 <Pawer> ghci has non-interactive mode?
19:07:59 <vincenz> Pawer: yep "ghc"
19:08:00 <monochrom> runghc
19:08:04 <triplah>  ./ is when bash reads the first line looking for a path to an interpreter
19:08:12 <dons> $ cat x
19:08:13 <dons> echo yes
19:08:13 <dons> $ ./x
19:08:13 <dons> yes
19:08:25 <dons> who uses bash anyway ;)
19:08:30 <triplah> haha
19:08:39 <monochrom> I do.
19:08:46 <dons> boy oh boy, i'm reminded how much the shell sucks as a programming language when we play these games
19:08:53 <triplah> Pawer: also /bin/sh is normally a  symlink to the shell of choice (bash in most cases)
19:08:56 <Pawer> but ghc is not a compiler?
19:09:14 <triplah> it is
19:09:25 <dons> triplah: only in linux, i think
19:09:37 <dons> /bin/sh is really /bin/sh on bsd
19:09:52 <dons> but the linux guys redirect to bash (or whatever, i suppose)
19:10:02 <triplah> dons: ahh ok, cool. well bash is the next gen sh i general terms i guess
19:10:03 <mux> and on any clued linux distro, they'd use a more sh-like thing, such as ash
19:10:07 <triplah> in*
19:10:27 <Pawer> but i mean
19:10:38 <Korollary> ubuntu has sh = bash
19:10:51 <triplah> same with gentoo
19:11:01 <triplah> and suse
19:11:14 <Pawer> can be changed to dash
19:11:15 <Korollary> I think sh is not gpl'd
19:11:19 * vincenz is getting more and more people to use darcs \o/
19:11:24 <vincenz> next step: teach them haskell
19:11:33 <Pawer> haskell
19:11:39 <triplah> easier said than done :)
19:11:42 <vincenz> triplah: nah
19:11:43 <Pawer> so i can do
19:12:05 <vincenz> triplah: I work in a high-intellect environment
19:12:15 <Pawer> echo "(a haskel program)" | ghc =
19:12:17 <Pawer> ?
19:12:21 <Pawer> and rus it?
19:12:27 <mux> bah, I hate those distros symlinking bash as sh; you end up with tons of shell scripts using non-portable bash features prefixed with #!/bin/sh
19:12:28 <Pawer> remove =
19:12:30 <dons> Pawer: , how about: runhaskell Script.hs
19:12:30 <triplah> vincenz: ah, so people who can understand something more than one step follows another :)
19:12:40 <Pawer> yes
19:12:43 <mux> and most of the time, the bash features aren't even needed.
19:12:43 <dons> Pawer: or just add #!/usr/bin/env runhaskell
19:12:48 <Pawer> okkk
19:13:17 <triplah> mux: agreed
19:13:18 <vincenz> triplah: where I work we develop tools amonst other things, to do code transformation
19:13:25 <Pawer> #!/bin/runhaskell ?
19:13:30 <Pawer> is posible?
19:13:34 <triplah> vincenz: nice
19:13:41 <dons> no. itd be in /usr/bin/ or else /usr/local/bin
19:14:02 <mux> dons: hey, do you have any ETA for the release of FPS 0.7?
19:14:12 <Pawer> but is possible?
19:14:16 <dons> mux, hmm. 3 weeks?
19:14:19 <dons> 4 weeks maybe.
19:14:28 <mux> dons: cool!
19:14:39 <dons> i want to try to wind up all the fusion work, tag and release. and push into ghc at the same time.
19:14:54 <Pawer> cool :)
19:14:57 <dons> before sjanssen's SoC gets merged in.
19:15:34 <bringert> Pawer: I recommend #!/usr/bin/env runhaskell
19:15:57 <bringert> that way it uses whatever runhaskell is in the user's path
19:16:01 <dons> though it seems a security hole, bringert. maybe we shouldn't recommend that.
19:16:01 <hyrax42> sjanssen is doing the ropes etc.?
19:16:09 <dons> ropes, unicode bytestring
19:16:13 <hyrax42> cool
19:16:14 <triplah> whats the advantage of using #!/usr/bin/en interpreter
19:16:14 <triplah> ?
19:16:24 <triplah> ahh
19:16:25 <triplah> i see
19:16:25 <bringert> dons, ah, true
19:16:27 <dons> it works whether you've got it in /usr/local or /usr/bin
19:16:47 <dons> however, someone could fiddle with your env easily, and then execute arbitrary stuff instead'
19:16:57 <dons> all they'd need was access to your PATH variable
19:17:01 <Pawer> bringert: thanks
19:17:14 <bringert> dons: well, if they can, they can replace ls instead
19:17:28 <dons> yeah.
19:17:46 <sdrac8> I have a list and I want to remove the nth element from it. Is there a function that does this?
19:17:46 <Pawer> ohh
19:17:50 <Pawer> don
19:17:53 <Pawer> master
19:17:57 <Pawer> apprentice
19:18:00 <dons> @hoogle [a] -> Int -> a
19:18:00 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
19:18:03 <Pawer> WISHMASTER
19:18:15 <dons> sdrac8: the !! function
19:18:37 <Pawer> have to study prolog
19:18:38 <monochrom> Hehehe
19:18:43 <sdrac8> that works if you know the element index
19:18:51 <Pawer> and i alwayss end here with the haskell
19:19:00 <Pawer> prolog is boring
19:19:12 <triplah> sdrac8: well use !! n
19:19:16 <Pawer> ~_~
19:19:33 <sdrac8> thanks
19:19:36 <bringert> sdrac8: did you want to get or remove the element?
19:19:43 <sdrac8> remove the element
19:19:49 <sdrac8> I need the reverse of !!
19:19:52 <bringert> !! only gets it
19:19:53 <monochrom> On Pizza Hut's pizza boxes: "remove content, re-heat in oven".  Therefore, "remove" = "select",  "remove the nth element" = "select the nth element".
19:20:31 <bringert> remove n xs = take n xs ++ drop (n+1) xs
19:21:07 <monochrom> Don't you like Pizza Hut English.
19:21:20 <Pawer> i do not undestand it
19:21:21 <bringert> or better: remove n xs = let (x,y) = splitAt n xs in x ++ drop 1 y
19:21:35 <Pawer> i am not english speaker
19:21:42 <Pawer> or better
19:21:48 <Pawer> eat a pizza
19:21:53 <Pawer> and realx
19:21:55 <Pawer> XDD
19:22:01 <sdrac8> thanks
19:22:06 <sdrac8> I think that should help
19:22:27 <SamB> Pawer: I think it means that Pizza Hut doesn't deliver the pizza fast enough for it to be hot when they bring it to you
19:22:56 <Pawer> still you can eat a pizza and realx
19:22:58 <monochrom> Naw.
19:23:30 <bringert> sdrac8: you should test that though, maybe I did some silly off-by-one error, I didn't test it
19:23:31 <stepcut> hey bringert! I am using NewCGI -- just thought you'd like to know...
19:23:38 <bringert> stepcut: cool
19:23:50 <vincenz> bringert: that's bad
19:23:50 <stepcut> bringert: I'm knee deep in monad transformers at the moment
19:23:53 <vincenz> bringert: very bad
19:23:56 <vincenz> very very bad
19:24:18 <bringert> vincenz: what is? not testing?
19:24:19 <vincenz> remove n xs = let (hd, _:tl) = splitAt n xs in hd ++ tl
19:24:25 <vincenz> bringert: no using take and drop
19:24:28 <vincenz> that's twice the work
19:24:51 <vincenz> if you want
19:24:54 <Pawer> it isn't in the preludo?
19:24:54 <vincenz> I have a full set of operations
19:24:56 <Pawer> it isn't in the prelude?
19:25:02 <vincenz> Pawer: no
19:25:06 <monochrom> heh preludo
19:25:07 <bringert> vincenz: yours can fail, mine can't
19:25:11 <Pawer> peludo
19:25:19 <vincenz> hmm
19:25:19 <Pawer> XD
19:25:27 <bringert> vincenz: I guess it depends on the behavior you want
19:25:29 <vincenz> bringert: point taken, then again, I onsider it a failure to remove unexisting elements
19:25:33 <vincenz> wait
19:25:57 * vincenz has a full set of operations
19:26:00 * vincenz ponders
19:26:08 <vincenz> if you use this, ... it's LGPL'd
19:26:28 <vincenz> http://rafb.net/paste/results/6eu1Cc91.html
19:26:29 <bringert> stepcut: is it NewCGI's fault? or did you get yourself into the mess? :-)
19:26:30 <Pawer> what about the new String implementation?
19:26:38 <Pawer> String type
19:27:04 <bringert> stepcut: let me know if you have any suggestions for NewCGI
19:27:23 <stepcut> bringert: it's my fault. I have a monad transform for handling URLS, and another form handling Forms
19:27:31 <vincenz> bringert: seen the link?
19:27:32 <bringert> ah
19:27:54 <Pawer> you use haskell scripts in xchat?
19:27:54 <stepcut> bringert: 'tis a beautiful mess
19:28:10 <vincenz> Pawer: mm?
19:28:10 <bringert> vincenz: what do you want me to see?
19:28:15 <vincenz> bringert: erm the linky
19:28:24 <vincenz> it's got stuff for most 'ddty' operations
19:28:39 <Pawer> im so noob
19:28:49 <stepcut> bringert: i'll let you know if I have any suggestions -- NewCGI + XHtml is working pretty well right now
19:28:56 <Pawer> ...
19:29:29 <vincenz> Pawer: read a tutorial on haskell YAHT is great
19:29:31 <vincenz> @where yaht
19:29:31 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
19:29:46 <Pawer> I have Bird
19:30:12 <vincenz> dons: ping
19:30:29 <bringert> vincenz: looks good
19:30:54 <vincenz> bringert: some operations don't need the (s a) as first param, but that's MPTC for ya
19:31:04 <bringert> though it might be nice to the user to report some understandable error message when the index is out of bounds
19:31:05 <vincenz> and I didn't want a bidirectional fundep
19:31:16 <dons> vincenz: ?
19:31:33 <vincenz> dons: think I should repost my message with the FooBar with a more meaningful title in the hope of catching oleg's eye?
19:32:04 <vincenz> tho.. .maybe noone will answer :/ noone answered the one on stackable monads
19:32:09 <dons> vincenz: yeah, possibly.
19:32:32 <bringert> stepcut: are you using NewCGI for work?
19:32:33 * vincenz is probably asking taboo questions
19:32:51 <Pawer> vicenz: instead of YAHT can I read the language specification?
19:33:02 <stepcut> bringert: using it for personal stuff right now -- if I can get the url's and form processing worked out though, I might use it for some work stuff
19:33:29 <vincenz> Pawer: you can do whatever you want
19:33:45 <Pawer> i know
19:34:07 <bringert> stepcut: would those be general libraries by any chance?
19:34:12 <Pawer> YAHT is a WIP?
19:34:15 <stepcut> bringert: NewCGI + XHtml + URLS + Form Processing + BerkeleyDB + some other stuff probably
19:34:23 <stepcut> bringert: the URL and form processing stuff ?
19:34:28 <bringert> stepcut: yeah
19:34:33 <Pawer> "Temporary versions of the tutorial are downloadable"
19:35:02 <stepcut> bringert: yeah, I am hoping so -- in theory you should be able to use the URLs with WASH, NewCGI, etc
19:35:10 <bringert> nice
19:35:27 <bringert> I have written a user + session library which uses NewCGI and HaskellDB
19:35:29 <stepcut> bringert: though, I have not decided if the solution I have is actually good in practice -- but it seems nice enough
19:35:52 <stepcut> bringert: yeah, I think I have used an older version of that
19:36:02 <bringert> you have?
19:36:09 <stepcut> bringert: possibly, let me look
19:36:13 <bringert> I haven't announced it anywhere
19:36:41 * stepcut ponders
19:37:05 <bringert> I've used it for a blog and a web photo album, I hope to release those reasonably soon
19:37:06 <stepcut> I think maybe it was a different one that used NewCGI then
19:37:19 <stepcut> have you played with HAppS at all ?
19:37:25 <bringert> I think Igloo might have written one at some point
19:37:34 <bringert> nope, I haven't
19:37:38 <stepcut> yeah, I think you told me about Igloo's before and I looked at it a bit
19:39:47 <stepcut> HAppS is kind of neat -- instead of having a database, you just manipulate things in a State monad -- it's all transparently backed up to disk with write-ahead logging
19:40:33 <stepcut> it looks like it could be a fast way to prototype stuff without having to design database schemas and stuff
19:40:55 <dons> hmm. sounds cool
19:41:14 <stepcut> on the otherhand, if you do change the type of your state, you have to martial all the data from the old format to the new format (or throw it away if it is just test data)
19:41:43 <dons> yeah, not too surprising though
19:42:00 <stepcut> it's the same problem that the hs-plugins stuff has I think
19:42:06 <dons> sounds exactly like it
19:42:12 <stepcut> and berkeleydb too
19:42:23 <dons> you can always stick the data in a Map String Dynamic
19:42:29 <dons> then the type doesn't have to change. 
19:42:38 <stepcut> though, in reality, sql has it too -- though it is not as sensitive
19:42:40 <dons> of course, dynamic typing causes zombieism
19:42:51 <vincenz> zombieism?
19:43:15 <dons> yeah, skin condition and brain eating brought on by lack of static typing
19:43:21 <vincenz> ah
19:43:21 <vincenz> lol
19:43:55 <vincenz> anyone know what a decent price would be for an external USB2 dvd+-RW DL?
19:44:19 * vincenz doesn't find cd's apt anymore for backuping
19:44:21 <stepcut> vincenz: no idea -- my internal IDE one was $50 a year ago if that helps
19:44:29 <petekaz> Anyone willing to help a poor soul lost in monad land?
19:44:29 <vincenz> especially given my 6GB directory of pdfs
19:44:48 <stepcut> vincenz: yeah, I have like 40GB of digital photos I am trying to back up :)
19:45:01 <Captain_Fourier> hey what is a good explanation of monads
19:45:02 <vincenz> :)
19:45:08 <Captain_Fourier> like really really simple
19:45:11 <vincenz> stepcut: well I have 30GB of mp3s, but I have given up on the idea of backing em up
19:45:17 <vincenz> @where nomaware
19:45:17 <lambdabot> I know nothing about nomaware.
19:45:20 <vincenz> @where nomadware
19:45:20 <lambdabot> I know nothing about nomadware.
19:45:22 <vincenz> hmm
19:45:25 <vincenz> @where monad
19:45:25 <lambdabot> I know nothing about monad.
19:45:27 <vincenz> @where monads
19:45:28 <lambdabot> I know nothing about monads.
19:45:31 * vincenz smacks lambdabot 
19:45:39 <vincenz> @google nomaware monads
19:45:40 <lambdabot> http://www.nomaware.com/monads/html/
19:45:43 <vincenz> Captain_Fourier: there
19:45:46 <Pawer> what is a monad?
19:45:48 <stepcut> vincenz: why back them up, did you lose the original CDs ? ;)
19:45:56 <vincenz> stepcut: you assume the existence 
19:46:05 <stepcut> :p
19:46:09 <petekaz> Captain_Fourier: I really like this page: http://en.wikibooks.org/wiki/Programming:Haskell_monads
19:46:16 <vincenz> @where+ nomaware http://www.nomaware.com/monads/html/
19:46:16 <lambdabot> Done.
19:46:31 <vincenz> stepcut: likewise.. I don't backup pics
19:46:57 <vincenz> but that's just laziness, only have 1GB
19:47:20 <stepcut> picasas (the windows version) has built-in backup stuff -- but even then, I am too lazy to put move the DVD-R from the spindle to the drive :)
19:47:22 <vincenz> anyways... I went to fnac, but they were asking 189 euros for an external dvdwriter
19:47:59 <vincenz> :/
19:48:00 <Pawer> what is a side effect?
19:48:12 <Pawer> an example
19:48:13 <vincenz> Pawer: what language do you know
19:48:17 <Pawer> C
19:48:21 <Pawer> haskell
19:48:23 <Pawer> octave
19:48:23 <vincenz> x = 2;
19:48:33 <vincenz> x = x+1; -> returns 3, side effect x is assigned 3
19:49:07 <Pawer> another example?
19:49:16 <vincenz> x = x-1;
19:49:32 <Captain_Fourier> scanf
19:49:36 <vincenz> printf
19:49:37 <Pawer> Xso
19:49:53 <Pawer> in haskell when you exit a functio...
19:49:56 <Pawer> in haskell when you exit a function...
19:50:05 <Pawer> you do not have variables
19:50:11 <Pawer> ...
19:50:15 * _SamB_ wonders if there is some way to get his alex lexer built to .o without Cabal wierdness or crazy Make-fu
19:50:22 <SamB> ooh, me want scanf for Haskell!
19:50:32 <Pawer> you have
19:50:32 <vincenz> SamB: didn't someone do that?
19:50:35 <Pawer> IO()
19:50:43 <Captain_Fourier> lex
19:50:45 <SamB> dunno!
19:50:51 <SamB> but I haven't got it
19:50:56 <SamB> Captain_Fourier: we have alex
19:50:59 <lisppaste2> petekaz annotated #20585 with "Help with my sample monad" at http://paste.lisp.org/display/20585#3
19:51:09 <vincenz> Pawer: see I know that I typically type in multiple lines, withe [ENTER] being my '.'  .... but please using [ENTER] instead of [SPACE] is excessive
19:51:13 <SamB> Captain_Fourier: not that I know what you are listing
19:51:34 <Captain_Fourier> im just trying to wrap my head around mondas
19:51:51 <Pawer> ok
19:51:53 <vincenz> SamB: there is scanf
19:51:58 <SamB> you don't need a monad for scanf
19:52:00 <vincenz> SamB: I think...well I'm sure there's printf
19:52:03 <Captain_Fourier> as i understand they let me hold onto data in this strange way
19:52:12 <SamB> yes, I know there is a printf
19:52:14 <vincenz> SamB: which uses some TH stuff
19:52:26 <SamB> oh, well, I meant a pure one ;-)
19:52:26 <vincenz> scanf should be similar in nature I'd think
19:52:32 <vincenz> SamB: how is TH not pure?
19:52:36 <vincenz> it's part of ghc
19:52:46 <SamB> well, it only works in stage2
19:52:52 <SamB> it almost uses hs-plugins
19:53:00 <vincenz> erm
19:53:00 <vincenz> no
19:53:03 <SamB> yes!
19:53:06 <vincenz> no!
19:53:12 <SamB> actually, it uses GHCi!
19:53:26 <SamB> but that uses much of the same code, doesn't it?
19:53:28 <vincenz> yeah but it's all safely tucked away in the typecheck phase
19:53:50 <vincenz> cause we all know that typechecking is simple even without that
19:54:24 <petekaz> I'm trying to figure out why the CPU time reported does not change with the additional 'time test1' statements.  The goal was to accumulate the total cpu time.
19:55:34 <vincenz> @hoogle time
19:55:35 <lambdabot> System.Time :: module
19:55:35 <lambdabot> Time :: module
19:55:35 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
19:55:36 <petekaz> I tried to write bind such that it would accumulate the CPUTime taken.
19:55:55 <petekaz> time is my function.
19:56:09 <vincenz> oy
19:56:16 <vincenz> obvious
19:56:23 <vincenz> time1 is a thunk
19:56:26 <vincenz> once it's calculated
19:56:31 <vincenz> the next time is gonna take 0 time
19:56:40 <petekaz> you mean test1?
19:56:42 <vincenz> erm
19:56:42 <vincenz> yes
19:56:50 <vincenz> well 0 time is incorrec
19:56:53 <vincenz> tthe time of one memory-read
19:57:00 <vincenz> maybe 2, 
19:57:06 <petekaz> why?  I thought that haskell did not do memoization?
19:57:13 <vincenz> petekaz: are you kidding
19:57:31 <vincenz> besides
19:57:31 <SamB> no, it doesn't
19:57:33 <vincenz> that's not memoization
19:57:40 <vincenz> petekaz: you're assigning test1 the value of that sume
19:57:44 <vincenz> it's only calculated after you get it
19:57:47 <vincenz> cause it's lazy
19:57:49 <petekaz> oh yeah.
19:57:51 <SamB> it does do full laziness and CSE
19:58:11 * vincenz is a bit hyper on sleepdepr and apologizes
19:58:20 <petekaz> vincenz: haskell is sooo damn confusing ... took me 2 hours to get that code to work.
19:58:40 <vincenz> petekaz: make it a function
19:58:45 <vincenz> test1 n = sum [1..n]
19:58:51 <petekaz> ok, let me try that.
19:58:56 <vincenz> in addition
19:59:00 <vincenz> make sure you actually evaluate test1
19:59:41 <vincenz> hm
19:59:48 <vincenz> as far as I can tell the approach you use won't work
19:59:54 <vincenz> all time's will be some start time
20:00:00 <vincenz> and only when you print will it calculate the sums
20:00:03 <SamB> you could print that .&. 1
20:00:11 <vincenz> even then
20:00:17 <vincenz> printing would make it only claculate when you print
20:00:20 <vincenz> not betweeen the two cputimes
20:00:30 <SamB> just `seq`?
20:00:40 * vincenz wonders about seq
20:00:44 <vincenz> SamB: I don't trust seq
20:00:45 <vincenz> check this
20:00:48 <petekaz> vincenz: yay! it works!
20:00:52 <SamB> you need to do it in the right place...
20:00:54 <vincenz> > (last [1..]) `seq` 1
20:00:57 <lambdabot> Terminated
20:01:00 <SamB> or you could time the printing
20:01:01 <vincenz> odd. 
20:01:06 <vincenz> > (sum [1..]) `seq` 1
20:01:10 <vincenz> that didn't work priorly
20:01:11 <lambdabot> Terminated
20:01:12 <petekaz> vincenz: I am using seq though.
20:01:17 <vincenz> petekaz: cool 
20:01:21 <SamB> > (last [1..])
20:01:24 <vincenz> ah yeah
20:01:25 <lambdabot> Terminated
20:01:26 <vincenz> I had missed it
20:01:39 <petekaz> vincenz: it seems to work, if I comment out some of the lines, the time reported goes down appropriately.
20:01:43 <SamB> > (last [1..]) `seq` 1
20:01:44 <vincenz> SamB: earlier I noticed a funny case
20:01:44 <monochrom> I saw an extract of petekaz's timing code earlier today.  Let me tell you my first impression was "oh so this is adding up artificial time".
20:01:46 <lambdabot> Terminated
20:01:53 <vincenz> petekaz: coolies
20:02:07 <vincenz> petekaz: small stylistic suggestion
20:02:27 <SamB> if you want to profile, you could try profiling instead of this timing business
20:02:31 <petekaz> I'll use do notation eventually if that's what you were going to say.
20:03:10 <petekaz> SamB: I'm not interested in any of this, just trying to write my own monad after reading the wikibook.
20:03:33 <hyrax42> @hoogle Integer -> Float
20:03:33 <lambdabot> No matches, try a more general search
20:03:37 <vincenz> petekaz: theer's a few other hting
20:03:41 <petekaz> The idea was that the "container" should be an accumulated CPU time with the current result.
20:03:47 <hyrax42> how do I convert between number types
20:03:58 <monochrom> How do you obtain CPU time?
20:04:04 <petekaz> But, it came out much uglier than I had hoped because of IO monad.
20:04:06 <SamB> fromIntegral
20:04:07 <Captain_Fourier> im just reading this and going, so why cant i use a generator or map function
20:04:15 <SamB> @type fromIntegral
20:04:15 <hyrax42> SamB: thanks
20:04:16 <lambdabot> forall b a. (Num b, Integral a) => a -> b
20:04:31 <petekaz> I really wanted to just have someithng like: time test1 >> time test2 >> time test3
20:04:31 <monochrom> Yes I was thinking you cannot avoid IO.
20:04:42 <SamB> hyrax42: if you want to convert *from* a fractional type, you'll need to round somehow, of course
20:04:57 <hyrax42> yeah, I just wanted to take log of an integer
20:05:00 <petekaz> but my time function uses getCPUTime which is in the IO monad so I have the mess I ended up with.
20:05:01 <monochrom> You will wrap your accumulator monad around IO.
20:05:30 <SamB> petekaz: maybe you will come up with a more fitting application next time?
20:05:34 <petekaz> monochrom: is that what I did?  or what I should do?
20:05:49 <petekaz> SamB: why?  It's a learning experience.
20:06:11 <petekaz> I thought it was a valid use of a "container", no?
20:06:12 <monochrom> But consider this.  In the IO monad you can easily enforce evaluation order.  It is about the simplest and most reliable way to enforce evaluation order anyway.
20:06:17 <SamB> well, yeah. so you've learned, so you should have a better idea what monads are good for?
20:06:29 <monochrom> Thou shalt wrap thy accumulator monad around IO.
20:06:48 <lisppaste2> vincenz annotated #20585 with "cleaning" at http://paste.lisp.org/display/20585#4
20:06:53 <petekaz> SamB: not yet, as I'm not happy with this result.
20:06:57 <vincenz> petekaz: check that
20:07:15 <SamB> petekaz: you probably won't be, its best not to try to time stuff that way here
20:07:31 <vincenz> much cleaner :)
20:07:36 <petekaz> vincenz: ok ... let me read
20:07:50 <SamB> at least, not unless you were computing in the IO monad anyway
20:08:02 <vincenz> @hoogle getCPUtime
20:08:03 <lambdabot> CPUTime.getCPUTime :: IO Integer
20:08:06 <vincenz> yeap
20:08:24 <vincenz> petekaz: notice how I reuse f... but that's ok, by then it's evalled
20:08:29 <vincenz> cause it takes no params
20:08:43 <vincenz> and seq forced it
20:09:17 <petekaz> vincenz: much nicer, but I was trying to make a monad and use the bind operator.
20:09:30 <monochrom> Thou shalt wrap thy accumulator monad around IO.
20:09:30 <vincenz> oh
20:09:36 <vincenz> petekaz: make a monad transformer
20:09:37 <petekaz> I suppose I still must be missing the point of monads.
20:09:51 <petekaz> monochrom: what does that mean?
20:09:52 <vincenz> but it makes little sense in this case really
20:10:02 <vincenz> petekaz: always make monad transformers
20:10:03 <monochrom> No, you get the point.  But you should build your monad around IO.
20:10:06 <vincenz> if you want a normal version
20:10:13 <vincenz> just wrap it around an Identity
20:10:24 * vincenz always makes xxxT
20:10:37 <petekaz> I don't understand ... sorry.
20:11:03 <monochrom> It will take time to understand.  No amount of words will help.
20:11:47 <vincenz> I can show you my typermonad
20:11:59 <vincenz> except it combines ReaderT and StateT
20:12:02 <petekaz> monochrom: what do you mean by wrap my accumulator around IO?
20:12:04 <SamB> but Identity doesn't implement MonadIO
20:12:06 <vincenz> so that might be overkill
20:12:10 <vincenz> SamB: so?
20:12:15 <vincenz> SamB: make an XxxT
20:12:23 <vincenz> if people want IO
20:12:25 <vincenz> they use the T version
20:12:33 <Cale> talking about monads?
20:12:36 <vincenz> Cale: yep
20:12:46 <vincenz> Cale: ever wrote a typechecker?
20:12:49 <SamB> I was just saying, you can't stack a timing monad on Identity
20:12:57 <vincenz> SamB: well no...
20:13:07 <vincenz> SamB: but you can't stack any timing monad on anything besides IO
20:13:25 <SamB> well, IO definately needs to be at the bottom of the stack, yes ;-)
20:13:47 <vincenz> http://rafb.net/paste/results/p9Xlg524.html
20:14:10 <SamB> so is Python's animal a rat?
20:14:10 <vincenz> SamB: erm... his monad was indepedent of getCPUTime
20:14:18 <Cale> vincenz: a simple one
20:14:20 <vincenz> SamB: it just stored integeers
20:14:22 <vincenz> Cale: yeah
20:14:28 <vincenz> Cale: or was that sarcasm?
20:14:29 <SamB> oh?
20:14:36 <SamB> wierd!
20:14:46 <Cale> vincenz: I was answering your question
20:14:55 <vincenz> ah..
20:14:58 <vincenz> sorry, was desynched
20:15:09 <petekaz> I didn't like my code because I had such a hard time to bind my calls because the calls were in the IO monad.  So instead I have this mess of r1,r2,r3,r4 and then bind those by themselves.
20:15:14 <vincenz> and given the length of time I've been up
20:15:17 <vincenz> my FIFO is short
20:15:29 <SamB> what do you do if you want a lexer that will lex a kind of token with multiple fields?
20:15:45 <vincenz> SamB: ?
20:16:06 <vincenz> use $
20:16:08 <SamB> in Alex
20:16:11 <vincenz> wat
20:16:12 <vincenz> wait
20:16:23 <vincenz> oh wait..
20:16:27 <vincenz> SamB: what's in those fields
20:16:28 <petekaz> I wish there was a way to make using my 'time' function like: time test1 >> time test2 >> time test3 instead of the mess I have.
20:16:31 * vincenz was thinking happy
20:16:35 * SamB was not asking vincenz 
20:16:44 <vincenz> SamB: don't like me?
20:16:56 <SamB> vincenz: well, in particular, I'd like to lex XML's CNames 
20:17:05 <SamB> vincenz: well, I don't want to evertax your FIFO
20:17:06 * vincenz isn't familiar with xml
20:17:22 <vincenz> SamB: of the people up, I prolly have most experience with alex
20:17:30 <SamB> oh, oh.
20:17:32 <SamB> okay ;-)
20:17:46 <vincenz> given the response time I've had in past regarding alex ;)
20:17:47 <SamB> well, its basically a name with a colon in the middle splitting it in two, see?
20:17:53 <vincenz> hmm
20:17:54 <vincenz> yes
20:17:59 <vincenz> but that seems to be something for the parser
20:18:07 <vincenz> you're making your lexer parse
20:18:14 <SamB> well, James Clark seems to think it is for the lexer!
20:18:25 <vincenz> @whois James Clark
20:18:25 <lambdabot> Unknown command, try @list
20:18:33 <vincenz> close enough
20:18:48 <vincenz> SamB: easiest... is do a second parse in your lexer action
20:19:07 <vincenz> | myregexpwith:   { mytoken }
20:19:18 <SamB> hmm.
20:19:24 <vincenz> mytoken ... = splitat ':' . take len $ input
20:19:37 <vincenz> pseudocodically
20:20:08 <vincenz> my lexer in fact is ultra simple
20:20:11 <SamB> what is the "take" for?
20:20:16 <vincenz> hmm
20:20:41 <vincenz> welll this is my LexActio
20:20:44 <vincenz> AlexAction
20:20:44 <vincenz> type LexAction = AlexInput -> Int -> ParseMonad Token
20:21:07 <SamB> oh, I'm still in the "simple" wrapper, where I have:
20:21:24 <SamB> String -> Token
20:21:26 <SamB> apparantly
20:21:28 <vincenz> ah
20:21:30 <vincenz> oh
20:21:32 <vincenz> even easier then
20:21:42 <vincenz> find the ':'
20:21:44 <vincenz> and split there
20:21:47 <vincenz> @hoogle split
20:21:47 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
20:21:48 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
20:21:48 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
20:21:52 <vincenz> @hoogle splitAt
20:21:52 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
20:21:52 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
20:21:52 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
20:22:09 <vincenz> @hoogle splitWith
20:22:10 <lambdabot> Data.PackedString.splitWithPS :: (Char -> Bool) -> PackedString -> [PackedString]
20:22:16 <vincenz> hmm
20:22:28 <vincenz> but yeah you get the idea
20:22:41 <SamB> @hoogle Eq a => a -> [a] -> ([a],[a])
20:22:42 <lambdabot> No matches, try a more general search
20:22:52 <SamB> @djinn Eq a => a -> [a] -> ([a],[a])
20:22:52 <lambdabot> Cannot parse command
20:22:56 <vincenz> SamB: another solution..
20:23:00 <SamB> @djinn a -> [a] -> ([a],[a])
20:23:00 <lambdabot> f _ a = (a, a)
20:23:07 <SamB> aww
20:23:30 <SamB> but it does have the type I asked for...
20:23:50 <SamB> @hoogle splitBy
20:23:50 <lambdabot> No matches found
20:23:50 <vincenz> SamB: if you have your own monad for alex... you could keep a stack of lexer-states... (the stuff between <> for the rules).... and then when you meet a ':' you can push into a new state.... and then when you pop back out of the states make your action generate the result
20:24:31 <vincenz> which woulld allow any number of ':' if you so desired
20:24:36 <SamB> if it weren't for the "largest match" rule in this spec I might just use Parsec for lexing...
20:24:49 <vincenz> SamB: I fail to see the difficulty
20:25:01 <vincenz> just have a regexp for *:*
20:25:08 <vincenz> and then find the ':'
20:25:09 <vincenz> and split there
20:25:12 <SamB> yeah, yeah...
20:25:16 <Cale> petekaz: sorry, what's 'time' doing there?
20:25:23 <SamB> @hoogle Eq a => [a] -> Int
20:25:24 <lambdabot> Prelude.length :: [a] -> Int
20:25:29 <SamB> no, no
20:25:33 <Cale> petekaz: you want to determine the amount of time an IO action takes to run?
20:25:37 <SamB> @hoogle find
20:25:37 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
20:25:37 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
20:25:37 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
20:25:56 <petekaz> Cale: no, I want to time how long any old function takes to run.
20:26:17 <petekaz> So I was using getCPUTime to get the start and end times.
20:26:25 <Cale> okay, then you'll (probably) want to fully evaluate the result
20:26:29 <vincenz> > let foo x = splitAt (fromJust . findIndex (==':') $ x) x in foo "lalal:bbb"
20:26:30 <lambdabot>  ("lalal",":bbb")
20:26:37 <petekaz> Unfortunately getCPUTime is in the IO monad.
20:26:53 <petekaz> Cale: I use 'seq' to force evaluation.
20:26:55 <vincenz> be warned that'll give an error if it doesn't have a ';'
20:27:04 <Cale> Well, sure, the amount of time something takes to evaluate is definitely not a pure function
20:27:15 <Cale> seq is okay
20:27:18 <vincenz> back to serious stuff
20:27:23 <vincenz> type inference hell
20:27:24 <Cale> Control.Exception.evaluate might work better
20:27:26 <petekaz> I think what I have all works fine with one change suggested be vincenz.
20:27:26 <SamB> vincenz: but it will have a :
20:27:31 <vincenz> SamB: then be happy
20:27:32 <petekaz> my test1 is now a function.
20:27:37 <SamB> because I'm only going to match things with those
20:27:48 <vincenz> SamB: then be happy
20:27:50 <Cale> @type Control.Exception.evaluate
20:27:51 <lambdabot> forall a. a -> IO a
20:27:56 <lisppaste2> petekaz annotated #20585 with "Working Version" at http://paste.lisp.org/display/20585#5
20:28:38 <vincenz> dumdumdum
20:28:39 <Cale> why don't you use do-notation?
20:28:46 <vincenz> Cale: chech annotation 4
20:28:53 <SamB> you know, my problem is probably that I am too hot and tired to code ;-)
20:29:08 <Cale> ah, okay, so you do
20:29:12 <vincenz> SamB: too hot? ... erm.. well there are soltuions to that *cough*
20:29:29 <petekaz> Cale: the part that made this whole thing difficult for me (newbie) is that getCPUTime is in the IO monad, so I have this mess of r1, r2, r3, and r4 to get all the profiled results out of the IO monad so I can then use the bind operation for my monad.
20:29:32 <vincenz> SamB: you good at haskell?
20:29:47 <vincenz> Cale: ideally his ProfiledResult is a monadtransformer
20:29:47 <SamB> fairly
20:29:49 <petekaz> re: do notation, just trying to explicitly see what's going on behind the covers right now.
20:29:54 <vincenz> SamB: interested in icfpc?
20:30:01 <SamB> not that good
20:30:07 <vincenz> erm
20:30:11 <vincenz> k
20:30:16 <SamB> I know what you meant ;-)
20:30:20 <Cale> petekaz: ah, okay
20:30:34 <vincenz> SamB: I know but our team is large and has a variety of proficiencies
20:30:35 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
20:31:03 <vincenz> Cale: you still have to update your likes and dislikes ;)
20:31:13 <palomer> Cale: how do I wrap something up in latex so it doesn't affect things around it?
20:31:26 <vincenz> palomer: a condom?
20:31:27 <SamB> {}?
20:31:36 <petekaz> Cale: ideally, I wanted to be able to just do: time test1 >> time test1 >> time test1 and then just extract out the accumulated cpu time.  But this usage escaped me as I didn't know what to do with regards to the IO monad interfering.
20:31:40 <SamB> a mini page?
20:31:41 <palomer> I tried \fbox{\lstinline!foo!}, but latex doesn't like it
20:31:52 <vincenz> boxing has restricted possibilities inside
20:31:57 <vincenz> minipage like SamB mentioned
20:32:10 <vincenz> for instance you can't use verbatim inside a box afaik
20:32:26 <palomer> oh wait, latex didn't like \infer{\fbox{\lstinline!foo!}}
20:32:29 <palomer> {}
20:32:37 <vincenz> palomer: what's this for?
20:32:43 <palomer> vincenz: writing proof trees
20:32:51 <palomer> type derivations
20:32:57 <vincenz> automatically I take it
20:33:02 <palomer> yeah
20:33:11 <palomer> and I can't write listings inside my infers
20:33:13 <palomer> driving me nuts
20:33:30 <Cale> palomer: not sure what you mean by that
20:33:57 <palomer> I can't write \infer{\lstinline!foo!}{}, it complains that the paragraph has ended before the infer ended
20:34:23 <vincenz> palomer: listings are a bith
20:34:30 <vincenz> palomer: they work in practically nothing
20:34:36 <vincenz> they even have lstnewenvironment
20:34:41 <vincenz> cause they don't like regular environments
20:35:20 <palomer> hrmph
20:35:25 <palomer> so I'm screwed, eh?
20:35:38 <Cale> palomer: Have you tried #latex? I've only used latex for sane things.
20:36:00 <vincenz> palomer: you can put listings inside figures
20:37:00 <palomer> vincenz: how so?
20:37:01 <SamB> you could call yourselves the Makefile-haters ;-)
20:37:09 <vincenz> \begin{figure}
20:37:16 <vincenz> let me fish it up
20:37:47 <vincenz> \begin{figure}
20:37:52 <vincenz> \begin{listings}
20:37:53 <vincenz> ..
20:37:54 <vincenz> \end
20:37:55 <vincenz> \end
20:41:41 <mathewm> Makefile-haters = ant-eaters?
20:45:26 <SamB> so, if you don't like makefiles, how do you build your Alex parser?
20:46:55 <SamB> er, lexer
20:55:38 <palomer> vincenz: thx
20:56:01 <vincenz> welcome :)
20:56:47 <palomer> hrmph, infer doesn't like figures
20:56:51 <palomer> same error as with listings
20:57:24 <SamB> how does Alex know what to match if there is a tie?
20:57:55 <vincenz> SamB: longest and from the top
20:58:02 <SamB> oh good
20:58:07 <SamB> from the top
20:58:32 <SamB> not random ;-)
21:01:05 <lambda_the_insig> so I'm playing with Haskell, and I have written a bf interpreter, however, performance is abysmal.  What can I do in order to speed up my implementation?
21:01:21 <lambda_the_insig> @paste
21:01:22 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
21:01:23 <vincenz> lambda_the_insig: you use State?
21:01:26 <vincenz> @where paste
21:01:27 <lambdabot> http://paste.lisp.org/new/haskell
21:01:29 <lambda_the_insig> Reader
21:01:38 <vincenz> o.O
21:02:15 <lisppaste2> lambda_the_insignificant pasted "BF Interpreter" at http://paste.lisp.org/display/20604
21:03:01 <lambda_the_insig> it definitely needs to be cleaned up.  :)
21:03:10 <vincenz> don't use local
21:03:13 <vincenz> and use ST?
21:03:18 <vincenz> there's no point in saving all these locals
21:03:25 <vincenz> or State for that matter
21:03:34 <vincenz> local is more for when you still need the old versions
21:03:52 <lambda_the_insig> is ST apart from Reader, or is it used in conjunction?
21:03:58 <vincenz> ST ~= State
21:04:13 <vincenz> ST is a strict State
21:05:04 <SamB> vincenz: know much about Happy?
21:05:20 <vincenz> SamB: yep
21:05:55 <SamB> ST is like IO without any of the features except finickily-typed arrays and references...
21:06:14 <SamB> (IO has sanely typed arrays, though)
21:06:35 <SamB> anyway, can non-terminals have perameters in Happy?
21:07:31 <dons> dcoutts: ok, results in for v1 versus v2 fusion: http://www.cse.unsw.edu.au/~dons/tmp/loopu_loop2.png
21:07:45 <dons> better in almost all cases.
21:08:08 <dons> and of course, there's all the down loop fusion v2 does.
21:09:03 <vincenz> SamB: not sure what you maen
21:11:50 <SamB> vincenz: well, some of the non-terminals in http://www.oasis-open.org/committees/relax-ng/compact-20021121.html#formal-syntax take arguments like functions do...
21:12:10 <SamB> does Happy support that kind of thing?
21:12:30 <vincenz> SamB: I'm too tired to read a doc on xml
21:12:34 <vincenz> can you give me a simple example/
21:13:03 <SamB> well, if you look at http://www.oasis-open.org/committees/relax-ng/compact-20021121.html#nt-innerPattern, you'll see it has parentheses after the name ;-)
21:13:26 <vincenz> oh
21:13:32 * palomer is switching to bussproofs
21:13:33 <palomer> oh boy
21:13:47 <vincenz> SamB: no but does it matter... you can do anything you want in your actions post that
21:13:50 <vincenz> palomer: btw...
21:13:54 <vincenz> palomer: have you looked at that other system?
21:13:58 <vincenz> MathLang
21:14:07 <palomer> not yet
21:14:08 <vincenz> it supposedly has latex backends
21:14:13 <vincenz> amongst other things
21:14:27 <vincenz> maybe do your stuff -> MathLang -> Latex ?
21:14:32 <SamB> well, it might mean I have to use Parsec for that, because I have no idea how else to pass arguments to nonterminals...
21:14:46 <vincenz> SamB: I fail to see the use
21:14:57 <palomer> all I need is lambda abstractions, applications and case statements
21:14:59 <vincenz> SamB: look
21:15:09 <vincenz> | somesomesome year
21:15:14 <vincenz>     { $1 $2 }
21:15:18 <vincenz> somesome
21:15:23 <vincenz>   { return a partial func}}
21:15:38 <vincenz> o.O
21:15:42 <SamB> well, I guess I could probably do that...
21:15:53 <palomer> bussproofs works fine with listings
21:15:54 <vincenz> I think it's isomoprihc
21:16:05 <vincenz> s/typoes/notypoes/
21:16:05 <palomer> and all busproofs is missing is 4 premise rules
21:16:09 * palomer is off
21:16:16 <vincenz> palomer: thanks for all the help on typing :)
21:16:56 <SamB> its like the difference between a function with a type like "a -> m b" and a function with type "m (a -> b)", where those things are a little more specific than that...
21:17:20 <vincenz> SamB: I don't think I agree in this case, but then again I don't know your problem domain (that spec) as well as you
21:17:47 * vincenz ponders
21:18:00 <vincenz> Heh... would be cool if there was a haskell version of appel
21:18:05 * vincenz has both the c and ml one
21:18:07 <SamB> lets see...
21:18:13 * vincenz could prolly do it
21:18:21 <vincenz> maybe I could submit it to him and be mentioned in the book :D
21:18:54 <vincenz> Compiler Construction in Haskell, coauthor . realname $ haskell
21:18:58 <vincenz> Compiler Construction in Haskell, coauthor . realname $ vincenz
21:19:20 <vincenz> Cale: ping
21:19:38 <SamB> ah well, I guess I won't try that until after sleeping ;-)
21:20:35 <vincenz> blegh
21:20:38 <vincenz> sleep is overrated
21:20:51 <vincenz> anyone around who's close to the haskell committee?
21:21:02 * vincenz was wondering if there's any plan to have something like . and $ for types
21:21:16 <vincenz> A (B (C D)))
21:21:18 <vincenz> can get rather annoying
21:21:26 <vincenz> A . B . C $ D would be much nicer
21:21:45 <vincenz> especially if you work with nested monad transformers
21:22:56 <Cale> vincenz: you should use newtypes
21:23:29 <vincenz> Cale: which are annyoing for all the extra dataconstructors that need to be matched
21:23:38 <Cale> not really
21:24:02 <vincenz> I still think . and $ for types would be good
21:24:03 <Cale> you define whatever operations you need, and then hide the constructors, you don't really want to use them any more than you have to anyway
21:24:10 <Cale> yeah, it might be nice
21:24:16 <vincenz> possibly even something like flip
21:24:32 <vincenz> data Flip c a b = c b a
21:24:37 <vincenz> :)
21:24:45 <vincenz> which obviously is wrong like this
21:25:29 <vincenz> Cale: maybe monads are a bad example, but in the case of AST's, especially using indirect composite, the amount of () grows
21:25:58 <SamB> vincenz: you can use a record newtype, that makes the constructor much less painful
21:26:19 <vincenz> SamB: trust me, I use records plentifully
21:26:24 <SamB> at least for monads
21:26:39 <vincenz> ast's are just yicky
21:26:42 <SamB> yeah
21:28:43 <stepcut> vincenz: maybe you want -> type Flip c a b = c b a ?
21:28:50 <vincenz> stepcut: that's not allowed
21:29:01 <vincenz> you can't partially apply it
21:29:18 <stepcut> ah, that much is true
21:29:22 * palomer is back
21:29:23 <stepcut> you can do stuff like, (Left 1):: Flip Either String Int
21:29:25 <SamB> unfortunately, kinds are monomorphic
21:29:28 <palomer> just realized I can't use bussproofs
21:29:35 * palomer curses proof.sty
21:29:43 <vincenz> palomer: MathLang?
21:29:48 <vincenz> it's supposed to be made for these kind of things
21:29:56 <palomer> isn't it a programming language??
21:29:59 <vincenz> nah
21:30:04 <vincenz> it's a proofing language
21:30:09 <vincenz> but more relaxed than strictp roofing
21:30:14 <vincenz> so that's oriented more towards display
21:30:27 <vincenz> although you can semi-automatically go to more concrete proof systems
21:30:41 <palomer> but can it build proof trees?
21:30:43 <vincenz> there's a nice ppt about it
21:31:27 <palomer> or, rather, let me build my own typing trees
21:31:36 <vincenz> palomer: http://lambda-the-ultimate.org/node/1465
21:31:50 <vincenz> don't ask m
21:31:53 <vincenz> I'm a proof-system newb
21:34:00 <palomer> http://www.macs.hw.ac.uk/~paulvt/mathlang/peano/peano.eps <--this seems to be the kind of output you get
21:34:28 <vincenz> palomer: yours?
21:34:31 <vincenz> or the mathlang?
21:34:34 <palomer> no, mine is something like this:
21:34:42 <vincenz> palomer: and that's not what you need?
21:35:40 <palomer> certainly not!
21:36:04 <palomer> www.magnesium.net/~palomer/jhv.pdf
21:36:35 <vincenz> palomer: well probably depending on optioons it can do that too
21:37:26 <palomer> but, like, it's displaying a completely different type of information
21:37:59 <palomer> I think that's the AST
21:38:17 * vincenz kicks microsoft
21:38:31 <vincenz> apparently they have a language named Cat for their .net thingy
21:38:35 <vincenz> which is just a cheap ripoff of haskell
21:38:43 <vincenz> just so they can do optimisation on lists
21:38:52 <vincenz> which is basically the fusion stuff done with {-# RULE}
21:39:22 <SamB> why can't they have their toy languages?
21:39:48 <vincenz> why do they keep reinventing the wheel just so they can label it MS?
21:40:42 <vincenz> look at MS C++, ms java, and C#
21:42:33 <lambda_the_insig> is there a nice overview of ST?  As usual, the haddock docs are terse, but not much help in learning.  :)
21:44:19 <Cale> The main feature of ST is that it lets you manipulate STRefs
21:44:51 <Cale> See Data.STRef about that -- mainly you have newSTRef, readSTRef and writeSTRef
21:45:11 <Cale> You apply runST to actually run the resulting computation and get a pure values
21:45:14 <Cale> -s
21:45:55 <Cale> You can't return an STRef from the computation, and attempting to do so is a type error.
21:45:55 <vincenz> Cale: that and unlike State is strict
21:46:02 <vincenz> Cale: I have noticed cases where this can make a differences
21:46:16 <Cale> There's Control.Monad.ST.Lazy
21:46:19 <vincenz> s/is/it is/
21:46:30 <Cale> In fact, ST was originally lazy.
21:46:38 <vincenz> Cale: well in the example I mention, the laziness was actually bugging me in State so I switched to sT
21:46:47 <vincenz> cause it wouldn't do some things
21:46:55 <vincenz> but don't ask me what it was, it's been a while :/
21:50:17 <lambda_the_insig> stupid question: is the 's' in an 'ST s' an actual type or does it always stay unbound?
21:52:28 <vincenz> Cale: any plan to update your likes/dislikes on team page?
21:52:30 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
21:52:39 <vincenz> *smiles angelically*
21:52:47 <Cale> vincenz: sure
21:52:52 <vincenz> \o/
21:53:03 <Cale> lambda_the_insig: it stays unbound
21:53:34 <Cale> lambda_the_insig: you can think of it as the type of the dictionary for all the STRefs, which can't really be known.
22:01:32 <lispy> vincenz: iirc you can use passwords with http & darcs, you just use libcurl env variables
22:13:27 <Razor-X`> Can ``read'' convert to Word8 ?
22:13:59 <Cale> yes
22:14:16 <Cale> :i Word8
22:14:39 <Cale> in ghci will list instances of classes for Word8
22:15:13 <Razor-X`> So then, can't I use ByteString.pack on this value?
22:15:46 <Cale> It operates on a list of Word8's
22:15:54 <Cale> but yeah, indirectly
22:16:59 <Cale> what are you trying to do?
22:17:34 <aleator> hmm.. latest ghc snapshot tar.bz2 seems to be broken.
22:18:50 <Razor-X`> Trying to convert a String to a [Word8], heh.
22:19:30 <Cale> You probably want Data.ByteString.Char8
22:20:21 <Razor-X`> Oh!
22:20:26 <Cale> though  map (fromIntegral . ord)  would work
22:48:55 <Razor-X`> What is the Int in ByteString.Char8.hGetNonBlocking used for?
23:44:35 <Lokadin> @localtime palomer
23:44:35 <lambdabot> Local time for palomer is Tue May 30 02:44:09
23:44:47 <Razor-X`> Why does ByteString.Char8.hGetContents not return anything for a socket?
23:45:03 <ADEpt> dons: ping
