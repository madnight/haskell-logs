00:12:33 <vincenz> blegh
00:12:35 <vincenz> tapl sucks
00:12:54 <vincenz> lispy: cool thx
00:13:09 * vincenz gets back from the office with CC in ML, TAPL and harper's book
00:13:27 <vincenz> TAPL's rather dissapointing, it's mostly about typechecking
00:14:00 <aleator> Hey, Whats the rote for reporting/discussing ghc6.5 bugs?
00:14:47 <vincenz> where does rote come from
00:15:55 <aleator> ah. I think I missused the word. "what is the common routine.." would be better.
00:16:14 <vincenz> what does rote mean
00:17:18 <aleator> mechanical repetition?
00:17:43 <vincenz> oh
00:17:58 <RvGaTe> morning
00:17:59 <aleator> I thought it meant mechanical routine.
00:23:59 <aleator> But anyhow. I've got a possible bug in ghc snapshot from 2006.05.27. Should I put it in trac or is there different policy for snapshots?
00:31:02 <ibid> aleator: sounds like it's plan b time ;)
00:32:04 <aleator> Nah. Just too early morning for anyone to read this channel..
00:37:51 <vincenz> @localtime aleator 
00:37:52 <lambdabot> Local time for aleator is Tue May 30 10:35:51 2006
00:37:56 <vincenz> dumdum
00:37:58 <vincenz> aleator: donde?
00:38:22 <aleator> vincenz: What?
00:38:26 <vincenz> hmm
00:38:36 <vincenz> @google sp en donde
00:38:38 <lambdabot> http://www.geocities.com/Athens/Thebes/6177/idioms.htm
00:38:44 <vincenz> @babel sp en donde
00:38:44 <lambdabot> babel module failed: Error: Language sp not supported
00:38:47 <vincenz> @babel es en donde
00:38:49 <lambdabot>  where
00:39:09 <vincenz> @babel es en donde estas
00:39:10 <lambdabot>  where these
00:39:13 <vincenz> hmm
00:39:39 <aleator> I'm not from greece?
00:39:45 <vincenz> donde esta usted
00:39:53 <vincenz> yeah just saw your .whois
00:39:55 <vincenz> .fi
00:40:27 <vincenz> out of curiousity, what's the bug
00:41:04 <aleator> time ./lt -threaded +RTS -N8
00:41:04 <aleator> lt: internal error: too many workers; runaway worker creation? (GHC version 6.5.20060527 for x86_64_unknown_linux)
00:41:14 <vincenz> oy
00:41:37 <vincenz> :/
00:41:45 <vincenz> no idea what to tell you, not that I'm very lucid at the moment
00:41:49 <aleator> I'm parallelising(sp?) a genetic algorithm..
00:41:53 * vincenz goes to take a nap after having worked during night
00:42:08 <aleator> Not that important since it can be worked around.
00:42:25 <vincenz> apparently its with a z
00:42:29 <vincenz> courtesy of google
00:42:35 <aleator> ok. thanks.
00:42:40 <vincenz> :)
00:42:49 * vincenz goes off to nap so he can do his typechecker after
00:43:24 <vincenz> aleator: you sure it's a bug and not the erroneous creation of spurious threads?
00:43:31 <vincenz> is it a lot of code?
00:43:33 <aleator> But anyhow. This is neat. I just replaced map with parMap rnf and it goes 5 times faster..
00:43:39 <vincenz> if so, can you reduce it to some small testcase?
00:43:47 <aleator> Hugely. But I think I can get a test case,
00:43:53 <vincenz> parMap rnf?
00:43:58 <vincenz> @google rnf
00:43:59 <lambdabot> http://www.rnf.de/
00:44:01 <aleator> I'm practically just doing parMap and it fails.
00:44:07 * vincenz nods
00:44:21 <vincenz> not familiar with the new stuff on parallellisation yet
00:44:28 <aleator> Neither am I.
00:44:38 <vincenz> well... good luck!
00:44:40 <vincenz> bbl
00:45:00 <vincenz> vincenz.uptime() => 24h
00:45:13 <mauke> >=
00:50:53 <Lokadin> say in lojban, could you say, la bil. pritu la bob. la bil.
01:12:23 <Razor-X`> Lokadin: Well, why can't you?
01:13:08 <norpan> Lokadin: lojban indeed
01:13:10 <Lokadin> well i don't see any reason why i wouldn't be able to, it's just i hadn't seen an example of it
01:13:29 <Lokadin> norpan: ?
01:13:35 <Razor-X`> I'm pretty sure it's a legal construction.
01:14:06 <Lokadin> Razor-X`: thanks :)
01:14:12 <Razor-X`> In an IO () function, can you make the function call itself?
01:14:22 <norpan> Razor-X`: sure
01:14:40 <Razor-X`> Without binding to a result, though.
01:14:40 <Lokadin> don't see why not
01:14:52 <norpan> main = putStrLn "Hello World!" >> main
01:15:01 <Razor-X`> Hmmm. Because if I do that, the desired code doesen't work.
01:16:46 <Lokadin> hmm
01:16:47 <norpan> Razor-X`: this is hard to answer without seeing your code and knowing your desire :)
01:17:09 <lisppaste2> Razor-X pasted "IO () calling itself" at http://paste.lisp.org/display/20609
01:17:28 <Razor-X`> There you go.
01:17:53 <Razor-X`> dumpContents takes a line from a socket and puts it on stdout, and I know dumpContents works on its own.
01:18:11 <Razor-X`> So here essentially, I wanna keep reading line after line, to infinity.
01:18:42 <mauke> how does it not work?
01:18:47 <Lokadin> yea
01:18:48 <norpan> it looks ok to me
01:18:52 <Razor-X`> I have no idea.
01:19:02 <Lokadin> how do you know it doesn't work?
01:19:04 <norpan> at least the recursion
01:19:10 <Razor-X`> If I remove ``>> continGetLine'' then it works, but for only one instance.
01:19:23 <mauke> Razor-X`: if you don't know how it doesn't work, then it works
01:19:27 <norpan> errr
01:19:34 <norpan> continGetLine takes a parameter
01:19:42 <norpan> how can that type check
01:19:47 <mauke> exactly
01:20:00 <dons> Razor-X`: did you sort out your bytestring troubes?
01:20:18 <Razor-X`> I used ``continGetLine server'' instead :P.
01:20:22 <Razor-X`> dons: Kinda.
01:20:35 <dons> how so?
01:20:35 <Razor-X`> And ``continGetLine server'' does the exact same thing.
01:20:52 <norpan> Razor-X`: the same thing, how could the first version type check?
01:21:04 <Lokadin> how would one express :P in lojban?
01:21:21 <Razor-X`> dons: hGetNonBlocking, for some *odd* season, not work with the socket.
01:21:22 <Lokadin> even in english
01:21:38 <Razor-X`> norpan: I believe I mistyped the code when I was readjusting it, and didn't evaluate it since.
01:21:43 <Razor-X`> I just compiled it, and it works fine.
01:21:49 <Razor-X`> Lokadin: Check the Lojban attitudnals.
01:22:02 <dons> Razor-X`: hmm. i'm not sure why that would be.
01:22:03 <Lokadin> Razor-X`: where do i find those?
01:22:21 <Razor-X`> Lokadin: Check the reference grammar, of course :). I'll get you a link if you need one.
01:22:22 <norpan> butr if you don't know in what way it doesn't work, then it must work, right?
01:22:51 <dons> i like that idea.
01:23:16 <Razor-X`> Data.ByteString.Char8.hGetContents doesen't work with the socket either.
01:23:21 <norpan> Razor-X`: i mean you must have some expectation that is not fulfilled
01:23:24 <Lokadin> Razor-X`: i got t in wikibooks
01:23:45 <Razor-X`> Lokadin: The reference grammar is better to check for a complete view at the language.
01:23:53 <dons> Razor-X`: does hGetContents, the list version, work?
01:24:07 <dons> also, does hGet, where you specify how many bytes to read, work?
01:24:13 <Razor-X`> dons: Yeah.
01:24:22 <dons> yeah to which one?
01:24:30 <Razor-X`> hGetContents, normally, works.
01:24:34 <Razor-X`> I haven't tried hGet.
01:24:56 <Razor-X`> I was wrong earlier about trying hGetNonBlocking.
01:24:58 <Lokadin> Razor-X`: kk thanks :)
01:25:04 <dons> hGetNonBlocking works then?
01:25:13 <Razor-X`> Lemme try it.
01:25:27 <Razor-X`> What's the Int there for? Number of bytes to read?
01:25:33 <aleator> I've got a possible bug in ghc snapshot from 2006.05.27. Should I put it in trac or is there different policy for snapshots?
01:25:52 <dons> yes
01:26:01 <dons> hGetNonBlocking is identical to 'hGet', except that it will never block
01:26:01 <dons> -- waiting for data to become available, instead it returns only whatever data
01:26:02 <dons> -- is available
01:26:10 <Razor-X`> What if you don't know how much is available on the socket?
01:27:02 <Razor-X`> Trying low numbers, it works.
01:27:18 <Razor-X`> But I don't know how to use it on a socket where I don't know how much is on it.
01:27:25 <norpan> hGetContents server >>= mapM_ dumpContents server . lines
01:28:00 <dons> Razor-X`: can you mail me a small test program to reproduce hGetContents not working?
01:28:05 <norpan> err, no
01:28:13 <Razor-X`> dons: Shouldn't be too hard.
01:28:24 <Razor-X`> You mind if I do it for you tomorrow, after school?
01:28:26 <norpan> but almost, you have to rewrite cumpContents to take a [String] :)
01:28:40 <dons> Razor-X`: sure.
01:29:31 * dons -> home
01:30:27 <Razor-X`> @hoogle dumpContents
01:30:28 <lambdabot> No matches found
01:30:31 <Razor-X`> Bleh.
01:33:31 <norpan> Razor-X`: i thought you wrote this?
01:34:54 <Razor-X`> norpan: Oh!
01:34:57 <Razor-X`> Umm...
01:35:05 <Razor-X`> Maybe I should stop coding for the night? :D.
01:35:13 <norpan> hehe
01:36:13 <Lokadin> @localtime Razor-X` 
01:36:14 <lambdabot> Local time for Razor-X` is Tue May 30 01:33:58 2006
01:36:28 <Razor-X`> Not too late, by my standards.
01:36:40 <Lokadin> @localtime Lokadin 
01:36:43 <lambdabot> Local time for Lokadin is Tue May 30 04:35:56 2006
01:36:46 <Razor-X`> :).
01:36:50 <Lokadin> :)
01:37:05 <norpan> way past my bedtime at least
01:37:24 <Lokadin> @localtime norpan 
01:37:26 <lambdabot> Local time for norpan is Tue May 30 10:37:04 2006
01:37:53 <Lokadin> .u'i
01:38:30 <Lokadin> mi .io norpan
01:38:42 <Lokadin> dono if that's valid
01:38:58 <Razor-X`> I don't think you can use attitudnals like that.
01:39:03 <Lokadin> hmmm
01:40:16 <Razor-X`> u'e do troci cusku fi la norpan.
01:41:58 <norpan> sinma is the gismu
01:42:06 <dcoutts> Lemmih, dons, with BS.hGetNonBlocking how do we distinguish the cases of being at the end of the stream vs there simply being no input available?
01:42:59 <norpan> do sinma mi
01:43:10 <Lokadin> mi sinma norpan 
01:43:11 <Lokadin> then lol
01:43:26 <Lokadin> .ui
01:43:32 <norpan> you need "la" too
01:43:41 <Razor-X`> ro ko sinma mi
01:43:58 <Razor-X`> u'e
01:45:38 <Lokadin> do cikna ba 10 
01:46:23 <Razor-X`> There's a cmavo (I think it's a cmavo) for 10.
01:46:29 <Razor-X`> As there are for all the numerals.
01:49:29 <Lokadin> la norpan. cikna ba dau cerni
01:49:56 <norpan> well, i have slept tonight :)
01:50:08 <norpan> i work normal hours
01:50:21 <Lokadin> .ue oh really? 
01:50:26 <Lokadin> alright :)
01:50:46 <Lokadin> was a misunderstanding then .u'i
01:51:08 <norpan> nalsinma
01:51:23 <Razor-X`> mi na jimpe
01:51:32 <norpan> na sinma
01:51:57 <Lokadin> what is na?
01:51:58 <norpan> but let's talk haskell instead
01:52:04 <norpan> negation
01:52:11 <Razor-X`> Yeah.
01:52:15 <norpan> one of the negations
01:52:23 <Lokadin> k i figured as much .ui
01:52:26 <Razor-X`> So, there's no way to find out how much has been written onto a socket?
01:52:41 <norpan> it's like "something else than"
01:52:46 <Razor-X`> Lokadin: Read through the Reference Grammar, it's dense, but quite helpful.
01:53:22 <Lokadin> Razor-X`: kk will do :) sorry i'ts just i only herd about lojban yesterday, and just wanted to see if i could say anything that made sense
01:53:28 <Razor-X`> Oh :P.
01:53:50 <Razor-X`> On top of two other languages, Lojban is a hobby ;).
01:53:55 <norpan> it's a steep learning curve
01:54:02 <norpan> and long
01:54:19 * Lokadin shrugs
01:54:35 <Lokadin> is the only thing that makes sense to write the program i wanted in though
01:54:51 <Lokadin> i wanted to give english comands to computer
01:55:00 <Lokadin> but lojban makes a lot more sense
01:56:12 <Lokadin> it's very intuitive .ai .a'o .ia
01:56:23 <Lokadin> hmmm
01:56:24 <Lokadin> yea
01:56:28 <Lokadin> but i should go and read it
01:56:39 * Lokadin is off to read more about lojban :)
01:58:49 <norpan> doi skami. i. do zbasu le ckafi
02:02:11 <Lokadin> a computer, you create with seed?
02:02:58 <Lokadin> i don't quite understand that sentance
02:03:20 <Lokadin> .uanai :(
02:08:54 <norpan> Lokadin: Computer! Make coffee!
02:09:21 <Lokadin> .i'e that's right! :)
02:09:34 <norpan> doi skami. i. ko zbasu le ckafi
02:09:40 <norpan> more order-like
02:11:06 <Lokadin> :)
02:11:48 * Lokadin has a long ways to go, tutorial just introduced fa, fe, fi
02:12:17 <Razor-X`> mi favla fi la lojban. la lajban. u'e
02:12:19 <Razor-X`> *tavla
02:12:24 <Razor-X`> *lojban
02:12:36 <Razor-X`> Pathetic, heh.
02:12:45 <norpan> lattjo lajban
02:15:26 <Lokadin> .u'i.ui
02:41:47 <jethr0> "MIDAS AUTOMATION - Party Mode!"
02:42:47 <davidhouse> hey, jethr0, what was that command you used to find and remove all *.o *.hi? it involved find
02:43:37 * davidhouse wants to suggest a ghc --clean which just executes that command
02:43:58 <dons> davidhouse: find . -name '*.o' -o -name '*.hi' -exec rm {} \;
02:44:08 <dons> replace rm with echo, to check ;)
02:44:14 <davidhouse> heh. thanks, dons.
02:44:27 <davidhouse> what does the {} do? and the escaped semicolon?
02:44:33 <dons> its a variable name.
02:44:38 <dons> it refers to the current string
02:44:47 <dons> -exec is mapped over each generated string
02:45:00 <davidhouse> aha.
02:45:00 <dons> -o is || in the above
02:45:40 <jethr0> what dons said
02:46:07 * jethr0 had never used "-o", but good to know
02:46:11 <davidhouse> dons, by the way, did you get my lambdabot patch? i darcs sent it, and darcs indicated success, but i don't believe it because i haven't configured sendmail :)
02:46:25 <ADEpt> dons: i'm going to hack lambdabot to support transport other than IRC. Are you likely to accept patches?
02:46:25 <dons> no, i don't think its been sent
02:46:38 <dons> perhaps, darcs send -o /tmp/foo.patch
02:46:39 <davidhouse> righty.
02:46:41 <dons> then mail me foo.patch
02:46:41 <jethr0> alternatively (if more dangerous) "find -regex '...'"
02:46:44 <dons> ADEpt: yes!
02:46:45 <davidhouse> yeah, i'll do that.
02:46:56 <dons> ADEpt: what were you thinking of?
02:47:35 <ADEpt> dons: xmpp
02:47:46 <davidhouse> dons, the patch was basically to limit Plugs's output to 80 chars, mostly to stop my own cockups when i forget to add a "take" to an expression involving an infinite list and end up spamming the channel :) does that sound good?
02:48:03 <dons> davidhouse: limit to 80 chars?
02:48:11 <dons> hmm. maybe
02:48:19 <dons> there's unlikely to be a case where we want more,
02:48:33 <davidhouse> yes, that was my reasoning.
02:48:33 <dons> perhaps check the logs for cases that are longer, to ensure none were valid
02:48:45 <davidhouse> We could perhaps change the length of output based on whether or not we're in a /query (or /msg; whatever) with someone, or are speaking to a channel.
03:02:44 <jethr0> more context-specific one could also add "take 40" to any expression that is a list. but i guess that's a bit too specific
03:03:21 <davidhouse> yeah, because people could do things like > [[1..]] and then it'll still bork.
03:05:05 <davidhouse> in the past 10 days or so, there have been perhaps one instance with lambdabot replying with arguably valid content which was longer than 80 chars
03:05:18 <davidhouse> and it was only 81 chars long, so we're not losing much
03:05:40 <davidhouse> my patch adds an ellipsis to any line which exceeds the limit, so it's clear it's gone over
03:06:58 <davidhouse> @where dons
03:06:58 <lambdabot> I know nothing about dons.
03:07:26 <dblhelix> @seen dons
03:07:26 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 18 minutes and 53 seconds ago.
03:08:03 <davidhouse> dons, by the way, when did @eval change to @run?
03:09:22 <davidhouse> all right, patch sent.
03:16:00 <dcoutts_> dons, the FusionBench looks nice btw
03:18:08 <mahogny> @seen ryant5000
03:18:09 <ADEpt> dons: patch sent
03:18:09 <lambdabot> I saw ryant5000 leaving #haskell 5 days, 3 hours, 33 minutes and 2 seconds ago, and .
03:18:30 <ADEpt> i recon 50% of dons mail is patches nowadays :)
03:19:43 <dcoutts_> heh, yeah probably
03:20:14 <Muad_Dibber> pfft
03:20:19 <Muad_Dibber> thats to less, send more!
03:21:17 <dcoutts_> fewer grammar!
03:24:51 <mahogny> bah. english just need larger equivalance classes and that one would have been ok :)
03:28:14 <dons> davidhouse: yesterday, lambdabot's in perl6 channel. it uses @eval for perl. so we moved our semi-internal name to @run
03:28:27 <dons> dcoutts_: yeah, looks good. 
03:28:33 <dons> we could _almost_ generate it from the FusionProperties.hs you know...
03:28:44 <dcoutts_> hmm
03:28:45 <dons> then it would truly by QuickBench
03:28:55 <dcoutts_> heh
03:28:58 <dons> and we could write a QuickCheck paper ;)
03:29:17 <dons> i.e. QuickBench + the model checking language
03:29:27 <dons> (which i've had some more ideas on cleaning up further)
03:29:41 <dons> davidhouse, ADEpt: thanks for the patches
03:29:45 <dons> ?karma+ davidhouse 
03:29:45 <lambdabot> davidhouse's karma raised to 2.
03:29:48 <dons> ?karma+ ADEpt 
03:29:48 <lambdabot> ADEpt's karma raised to 2.
03:29:56 <davidhouse> heh. thanks :)
03:30:19 <dons> dcoutts_: i'm giving a talk on Data.ByteString, and using QuickCheck, and fusion, next week.
03:30:27 <dons> in an Adv. Fun . Prog course
03:30:28 <dcoutts_> oh, nice!
03:30:54 <dons> so i might clean up the quickcheck stuff a bit, maybe quickbench won't be so hard to write..
03:31:05 <dons> dcoutts_: did you see the graphs?
03:31:09 <dcoutts_> no, where?
03:31:12 <dons> http://www.cse.unsw.edu.au/~dons/tmp/loopu_loop2.png
03:31:16 * dcoutts_ looks
03:31:17 <dons> green is v2 fusion
03:31:22 <dons> red is old-skool fusion
03:31:26 <dons> its a winner!
03:31:27 <dcoutts_> ok...
03:31:39 <dons> so we're almsot always faster.
03:31:51 <dons> now, fusion versus non-fusion: http://www.cse.unsw.edu.au/~dons/tmp/fusion.png
03:32:00 <dons> hint .. fusion is faster.
03:32:43 <dcoutts_> mm looking good, so in that first graph, where you can't see a red line that's because they coincide?
03:33:06 <dcoutts_> so we're only slower in two cases
03:33:13 <dcoutts_> and faster in most
03:33:21 <dons> yep, they coincide in some.
03:33:35 <dons> but overall and improvement of hmm, 10-15%?
03:33:40 <dons> maybe 10%
03:33:45 <dcoutts_> right that's what I was thinking
03:33:56 <dons> oh, the chunk in the middle wfrom 15-26, that's down loops
03:33:58 <dons> no red lines there
03:34:05 <dcoutts_> ah right
03:34:12 <dcoutts_> presumably more in the map . map and less in the up . up
03:34:12 <dons> since you can't go down in old style fusion.
03:34:17 <dcoutts_> right
03:34:35 <dcoutts_> we should be coinciding for the up . up
03:34:46 <dcoutts_> but better for the more special cases
03:34:59 <dcoutts_> wow!
03:35:04 <dons> this is the output of FusionBench.hs, run with and without -DLOOPU_FUSION
03:35:12 * dcoutts_ looks at the fusion vs no fusion graph
03:35:18 <dons> yeah, i suspected ;)
03:35:24 <dons> notice the last 3 bars
03:35:31 <dons> that's 5-function pipelines
03:35:40 <dcoutts_> a right
03:35:43 <dons> normally, the runnign time increases linearly with the length of the pipe
03:35:50 <dcoutts_> good
03:35:54 <dons> but with fusion, they're hmm, constant?
03:36:16 <dcoutts_> I was going to say that it's interesting that the improvement varies so much
03:36:22 <dcoutts_> from eg 10% to like 80%
03:36:43 <dons> the average must be around 50%
03:36:52 <dcoutts_> not bad :-)
03:37:11 <dons> oh, the 3 short graphs are maximum/loop fusion. where we switch from the C minimum/maximum, to the fuseable form
03:37:21 <dcoutts_> ah
03:37:23 <dons> so a tiny bit slower, but no result array allocated
03:37:29 <dons> we need space profiling for the paper
03:37:44 <dons> to measure how much we save deforesting those intermediate arrays
03:38:15 <dcoutts_> are you sure we're not allocating a result array for minimum/maximum
03:38:35 <dcoutts_> I was going to tackle that for the  "fold . pipeline" cases
03:38:39 <dons> well, its a foldl. that won't allocate? (or is that what noArr is goign to do?)
03:38:45 <dons> ah yes.
03:38:53 <dons> ok. so it is still allocating
03:39:00 <dcoutts_> so we might be able to do better
03:39:40 <dons> you should be able to compile and run FusionBench.hs to get the same output files ready for gnuplot. then you can check with each new rule
03:39:50 <dcoutts_> yep
03:39:55 <dcoutts_> you were using ghc-6.5 right?
03:40:00 <dons> yep
03:40:04 <dcoutts_> how did you build it?
03:40:21 <dons> i removed Data.ByteString from the base/ , rebuilt, then just installed fps as normal
03:40:22 <dcoutts_> I was thinking of building 6.5 without ByteString in base
03:40:26 <dcoutts_> right
03:40:28 <dons> ... :)
03:40:46 <dons> just remove the files from base, and edit Makefile, base.cabal, and package.conf.in
03:40:52 <dcoutts_> ok
03:40:57 <dons> then rerun ./configure in base/. rebuild and you should be good
03:41:13 <dons> oh, also remove the cbits
03:41:16 <dcoutts_> so did you see that SPJ & Roman are working on some low level loop stuff
03:41:18 <dons> fpstring.c fpstring.h
03:41:25 <dons> yes,, i mean to check that page out.
03:41:33 <dcoutts_> I mean code generator stuff, not just RULES
03:41:41 <dons> roman's sent me some cmm loop optimisations to try
03:41:42 <dcoutts_> yes, that page is interesting
03:41:55 <dons> they gave a couple of percent speed up for tight loops
03:42:04 <dcoutts_> our minimum/maximum are obvious candidates
03:42:12 <dcoutts_> since they are trivial C loops
03:43:08 <dons> ok. dinner time. i'll be back later.
03:43:20 * dcoutts_ has a supervison shortly
03:46:44 * ndm hasn't had a supervision for a month and a half, and won't for another 2 months :)
03:46:54 <pesco> Ahoj.
03:47:14 <pesco> Is there anybody here with access to a SPARC machine with a recent GHC build environment?
03:47:54 <Muad_Dibber> what is recent?
03:47:59 <pesco> 6.4.1
03:49:06 <Muad_Dibber> Yeah
03:49:18 <Muad_Dibber> Linux LETO 2.4.31-sparc #2 Sun Aug 7 12:51:17 CEST 2005 sparc64 sun4u GNU/Linux
03:49:44 <pesco> Hm, Linux, will those binaries run on Solaris also?
03:50:00 <Muad_Dibber> I wouldn't know :)
03:50:06 <Muad_Dibber> Thats why I pasted that it was linux :P
03:50:16 <pesco> :/ Which packages do you have installed there?
03:50:38 <jethr0> when you guys write CVs, how do you present your programming skills? just listing a dozen languages and technologies doesn't look very convincing, does it...
03:50:42 * dcoutts_ also runs sparc linux with ghc-6.4.2
03:50:59 <Muad_Dibber> dcoutts, what packages do I run?
03:51:08 <dcoutts_> Muad_Dib, oh btw ghc-bin-6.4.2 is now available for gentoo/sparc
03:51:29 <dcoutts_> http://packages.gentoo.org/search/?sstring=ghc
03:51:31 <pesco> Obviously, I'm asking because I want to compile something for SPARC but am getting lost in dependencies.
03:51:50 <pesco> What GHC packages do you guys have installed? My program requires a few.
03:51:51 <dcoutts_> pesco, you're talking about Solaris though right?
03:51:54 <pesco> dcoutts_: Yes.
03:52:25 <dcoutts_> pesco, we've got access to many many haskell/ghc packages since we're running gentoo
03:52:45 <dcoutts_> http://packages.gentoo.org/packages/?category=dev-haskell
03:52:45 <Muad_Dibber> dcoutts, want me to test that bin?
03:52:49 <pesco> dcoutts_: That's cool. Do you know if the binaries are Solaris-compatible?
03:52:53 <dcoutts_> Muad_Dib, yes please
03:52:58 <pesco> dcoutts_: You could compile hello world and send it to me...
03:53:04 <dcoutts_> pesco, they are almost certainly not
03:53:09 <pesco> :(
03:53:16 <dcoutts_> pesco, since they depend on glibc
03:53:34 <pesco> Aha.
03:53:46 <pesco> Too bad.
03:53:47 <Saulzar> jethr0, Hmm, I've done that as  well as listed a bunch of projects.
03:53:54 <dcoutts_> pesco, unless you've got the linux binary emulation layer for Solaris
03:54:06 <dcoutts_> then it'd work
03:54:13 <pesco> dcoutts_: Oh, I don't know... Maybe. Do you know how to find out?
03:54:17 <dcoutts_> not really
03:54:25 <dcoutts_> I've only heard of it's existance
03:54:28 <pesco> Okay.
03:54:29 <dcoutts_> ask Sun :-)
03:54:33 <pesco> :)
03:54:57 <Muad_Dibber>  emerge (1 of 1) dev-lang/ghc-bin-6.4.2 to / Now be patient dcoutts . You want me to do anything particular after its emerged?
03:55:45 <pesco> dcoutts_: Could you just compile a test program and send it to me really quick?
03:56:02 <pesco> pesco@gmx.de
03:58:39 <dcoutts_> pesco, http://haskell.org/~duncan/hello-world-sparc
03:58:46 <pesco> Thanks.
03:58:48 <dcoutts_> that's dynamically linked
03:59:04 <davidhouse> hmm... anyone handy with latex around? #latex seems to be asleep
03:59:15 <dcoutts_> pesco, so needs libc libm libgmp libdl
03:59:35 <davidhouse> i basically want a tabular environment with wordwrap. at the moment, long lines just extend off without wrapping around
03:59:39 <pesco> dcoutts_: No go. "Cannot find /lib/ld-linux.so.2"
04:00:16 <ndm> davidhouse: just try each of the table ones in order
04:00:57 <davidhouse> ndm, each of the tables whats?
04:01:11 <liyang> davidhouse: p{16ex} instead of l, r or c?
04:01:22 <ndm> davidhouse: table, tabular, tabbing
04:01:23 <liyang> not sure of the default tabular env does it. Longtable certainly does.
04:01:41 <dcoutts_> pesco, right, but then you knew that :-)
04:01:42 <ndm> or just use Word :)
04:01:51 <liyang> burn in hell.
04:01:51 <davidhouse> ndm, do any of those apart from tabular (which i'm using at the moment), allow me to specify the alignments of my columns?
04:02:06 <pesco> dcoutts_: Yeah.
04:02:27 <ndm> davidhouse: no idea, longtable might also be an option
04:02:41 <davidhouse> yeah, i'll check out longtable
04:03:09 <dcoutts_> pesco, ok here's a staticly linked one, try that
04:03:11 <dcoutts_> same url
04:03:24 * dcoutts_ has to run...
04:05:39 <davidhouse> okay, where's the best place to download latex packages?
04:06:57 <ndm> davidhouse: ctan
04:07:24 <Muad_Dibber> dcoutts,  GHC Interactive, version 6.4.2, for Haskell 98.; 
04:07:28 <sieni> davidhouse: unless the package you are interested in is included in your tex-distribution of choice (e.g. tetex or miktex)
04:07:30 <Muad_Dibber> and it seems to work as well.
04:08:01 <Lemmih> dcoutts: We don't.
04:08:16 <Lemmih> (re-hGetBufNonBlocking)
04:10:53 <dons> Lemmih: do we need hGetContents to be non blocking too, to read successfully from a socket?
04:14:54 <Lemmih> dons: So it returns the available data before blocking?
04:22:49 <shapr> gwahr
04:22:58 <Lemmih> JaffaCake: ping.
04:23:09 <dons> i was just pondering someone's complaint today that they couldn't read at all from a socket. i'm waiting on a testasce
04:23:45 <dons> "warhg", i think you mean, shapr
04:24:16 <shapr> Dynamically checked languages suck.
04:24:23 <JaffaCake> Lemmih: hi there
04:24:23 <shapr> They just totally suck butt.
04:25:52 <shapr> I just wasted half an hour trying to figure out why the Zope server wouldn't start, and it's because I removed some code that I import elsewhere, without removing the import statement. Even worse, this problem didn't appear until the server was restarted.
04:26:02 <dons> JaffaCake: a graph for you: what array fusion does to the speed of various function pipelines in Data.ByteString: http://www.cse.unsw.edu.au/~dons/tmp/fusion.png
04:26:20 <dons> red is with rules off, green is with all the fusion kicking in
04:26:51 <JaffaCake> wow!
04:26:54 <dons> shapr: that's so scary, i'm afraid to even think about it.
04:26:56 <shapr> dons: What're the axes?
04:27:13 <dons> y is time, x is individual pipes (i.e. map . map, map. filter. foldr . map and so on)
04:28:06 <davidhouse> some of those improvements are... vast
04:28:08 <JaffaCake> dons: just enough time to write a Haskell Workshop paper :)
04:28:17 <davidhouse> like the last one
04:28:38 <dons> davidhouse: the last one is a 5 element pipe, which runs not 5 x slower when fused :)
04:29:05 <dons> JaffaCake: :) i need to get some feedback on how to position it from Manuel.
04:29:39 <JaffaCake> the fusion stuff is good paper material, I think
04:29:54 <dons> yeah, i definitely want to write it up.
04:29:56 * shapr wants to read a draft
04:46:27 <aleator> Is there some relation between deepseq and Control.Parallel.Strategies.rnf?
04:47:35 <dcoutts_> yes
04:48:03 <aleator> they are kinda same thing?
04:52:22 <davidhouse> % (1-2x+3x^2) //Factor
04:52:27 <davidhouse> err
04:52:32 <davidhouse> wrong chan,.
04:56:58 <dcoutts_> dons, yes we should write it up. My Supervisor says "publish!"
04:57:16 <dcoutts_> dons, he says one should apply a greedy algorithm to paper writing
04:57:53 <dcoutts_> dons, he's got a couple suggestions on conferences to submit it to
04:58:23 <Foobar_> Is there an efficient interface for testing whether an edge exists in Data.Inductive.Graph?
05:00:24 <dcoutts_> Lemmih, so yeah, we need to use a non-blocking version to do hGetContents for lazy bytestrings
05:00:46 <dcoutts_> Lemmih, so that it gets chunks in sizes of "what's currently available"
05:00:56 <dcoutts_> so that it can be used with sockets & pipes
05:01:31 <dcoutts_> dons, I'm not at all suprised that it doesn't work with sockets atm, 64k is a very large chunk
05:01:45 <dcoutts_> so it's going to block 'til that much data is available
05:01:46 <dons> dcoutts_: ah! ok. I'll CC. you a mail abotu this I'm sending Manuel atm.
05:01:56 <dcoutts_> dons, great, ta.
05:02:15 <dcoutts_> dons, my supervisor would also be happy to read & commnet on a draft.
05:02:23 <dons> cool
05:02:32 <dons> who's your supervisor again?
05:02:41 <dcoutts_> dons, Oege de Moor
05:02:56 <dcoutts_> Manuel knows him
05:03:00 <dons> ah, as I suspected :)
05:04:01 <dcoutts_> dons, Oege he suggested PADL or APLAS
05:04:08 <dons> I spoke to an Isabelle guy today. he was very interested in the model checking layer over QuickCHeck
05:04:17 <dons> oh. yeah, aplas is at unsw this year, isn't it?
05:04:30 <dcoutts_> http://www.kb.ecei.tohoku.ac.jp/aplas2006/
05:04:31 <dcoutts_> yep
05:04:42 <dons> hmm, but when's the deadline
05:05:01 <dons> 6 Jun.
05:05:02 <dcoutts_> Abstract deadline	2 Jun, 2006
05:05:12 <dcoutts_> hmm
05:05:23 <dons> hmm
05:05:27 <dcoutts_> Oege is on the program comittee :-)
05:05:39 <dons> and Manuel too, iirc
05:05:47 <dons> oh, Co-chair. oops
05:05:47 <dcoutts_> er, yes
05:05:55 <dcoutts_> I said our paper might be on the short side
05:06:10 <dcoutts_> he thought it might be hard to get a short paper in
05:06:13 <dons> yeah
05:06:25 <dcoutts_> but that PADL might be better
05:06:37 <dons> we can always do more work though. check the "Functional Array Fusion" paper for an example of how to write this kind of thing
05:06:47 <dons> whens the PADL deadline?
05:06:54 <dcoutts_> deadline for PADL is august with the conference in January
05:07:00 <dons> ok. very doable
05:08:23 <dcoutts_> aye
05:08:29 * dcoutts_ tries to find the website...
05:08:40 <dons> http://www.cs.brown.edu/~pvh/PADL06.html
05:08:52 <dons> Paper Submission: August 27, 2005 
05:10:12 <dcoutts_> yeah, I can't find next years one
05:10:30 <dons> oh yes.
05:10:45 * dons remembers how years work
05:10:51 <dons> they increment
05:11:00 <ADEpt> dons: do you have minute to talk about lambdabot?
05:11:33 <ibid> dons: how much do they get paid for incrementing? could you double it so that they'd decrement instead? ;)
05:11:37 <dons> ADEpt: busy atm. try me in a little while.
05:11:42 <ADEpt> dons: ok
05:13:09 <dcoutts_> dons, http://www.umsec.umn.edu/research/calls_for_papers.php?id=141
05:13:23 <dcoutts_> Paper Due Date:  August 15, 2006
05:13:31 <dcoutts_> Notification Date:  September 15, 2006
05:13:31 <dcoutts_> Conference Date: January 15, 2007
05:13:31 <dcoutts_> No formal web page yet.  These dates are estimates.
05:13:48 <dons> ok.
05:13:52 <Lemmih> JaffaCake: Seen my PM?
05:14:54 <dons> dcoutts_: your oxford email addr is good?
05:15:01 <dcoutts_> dons, yep
05:15:03 <dons> (i notice you've used a couple of others recently?)
05:15:08 * davidhouse stares at his rather empty CV
05:15:15 <davidhouse> i don't actually have a lot to my name.
05:15:22 <dcoutts_> dons, yeah I do, depends what hat I'm wearing
05:15:34 <dcoutts_> dons, eg my gentoo hat or college or department :-)
05:15:45 <dons> ah, now it all makes sense
05:15:54 <dcoutts_> as clear as mud :-)
05:15:57 <dcoutts_> but they all get to me
05:16:27 <dons> dcoutts_: i'll set up a paper repo in the morning, and put in the points we've discussed
05:16:38 <dcoutts_> dons, ok great
05:16:48 <dcoutts_> I'll build ghd-6.5 and try some more benchmarking
05:17:05 <dcoutts_> btw what's the minimum set of libs I can get away with for ghc?
05:17:09 <dons> yep. it would be good to get numbers on how much lazy fusioning is helping
05:17:58 <jethr0> Saulzar: sorry, had to go away
05:18:01 <dons> oh. hmm. you could leave off ALUT, GLUT, HGL, HUnit, HaXml, .. anything else with a capital letter except QuickCheck
05:18:08 <dcoutts_> ok
05:18:36 * dons back in an hour or so
05:18:46 * dcoutts_ too, lunch beckons
05:18:47 <jethr0> Saulzar: so, did you reduce your number of languages and "technologies" in any way or did you just put everything down?
05:19:24 <jethr0> is there an algorithm to split a list of unsorted values into roughly equal halves with all values in the left half are smaller than the values in the right half?
05:19:52 <jethr0> i.e. quicksort with one "iteration" and magically found pivot element in O(< n log n)
05:21:44 <davidhouse> > let jethr0Sort xs = ([], xs) in jethr0Sort [1..10]
05:21:45 <lambdabot>  Add a type signature
05:21:56 <davidhouse> > let jethr0Sort xs = ([] `asTypeOf` xs, xs) in jethr0Sort [1..10]
05:21:57 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
05:22:06 <davidhouse> all those in the LHS are smaller than those in the RHS :)
05:22:21 <davidhouse> seriously though, you haven't been specific enough with "roughly equal halves"
05:23:55 <jethr0> well, exactly equal halves is as complex as sorting and choosing the pivot element as the median value. to make it more reasonable that such an algorithm exists i would be willing to reduce the "exactly equal" halves to sth a little more lax to make it easier to find a suitable pivot element
05:24:28 <jethr0> i was just wondering if there were sorting algorithms out there that displayed this kind of behaviour in case one didn't need a perfect ascending sort but just some kind of output characteristic
05:24:57 <davidhouse> you might want to investigate sorted heaps. they're not quite what your after but do have looser semantics than a strict sort
05:24:58 <ADEpt> @index Chan
05:24:59 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
05:25:29 <davidhouse> they're basically binary trees (or perhaps n-ary) with the property that child's value < parent's value
05:25:48 <jethr0> hmm, sounds interesting
05:26:10 <jethr0> but i've never liked heaps. they seem so erratic :)
05:29:04 <davidhouse> jethr0: what german word(s) would you use for 'web development'?
05:30:04 <davidhouse> if you don't mind me abusing your offer to help me write this CV :)
05:35:58 <jethr0> davidhouse: np
05:36:23 <jethr0> davidhouse: what exactly do you mean by web development?
05:37:16 <davidhouse> an amalgamation of designing and HTML-ising web sites, with some back-end PHP/ASP etc thrown in too.
05:37:59 <davidhouse> sorry, /me <- lunch
05:39:14 <jethr0> davidhouse: it's really hard to translate that. you could just write "web development" or "Web-Entwicklung", but neither is really nice...
06:07:02 <iturk> hello can someone give a function signature for this: cond b f g =
06:07:15 <iturk> \x -> if bx then f x else g x
06:07:33 <iturk> instead of bx is b x
06:07:45 <dons> ?type \b f g x -> if b x then f x else g x
06:07:46 <lambdabot> forall t t1.
06:07:46 <lambdabot>               (t1 -> Bool) -> (t1 -> t) -> (t1 -> t) -> t1 -> t
06:08:22 * dons `fmap` sleep
06:08:46 <Lemmih> Perhaps we should use haskell-src-exts to parse and pretty-print the result of @type.
06:08:50 <dcoutts_> heh, g'night dons 
06:08:57 <roconnor> ?type liftM3
06:08:58 <iturk> thanks
06:08:59 <lambdabot> forall r (m :: * -> *) a3 a2 a1.
06:08:59 <lambdabot>     (Monad m) =>
06:08:59 <lambdabot>     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
06:09:04 <SamB> Lemmih: not a bad idea
06:09:56 <roconnor> @hoggle bool -> a -> a -> a
06:09:57 <lambdabot> Did you mean: Bool -> a -> a -> a
06:10:03 <roconnor> @hoggle Bool -> a -> a -> a
06:10:04 <lambdabot> No matches, try a more general search
06:10:10 <norpan> let iff x y z = if x then y else z?
06:10:46 <roconnor> ?type liftM3 (\b x y -> if b then x else y)
06:10:48 <lambdabot> forall a3 (m :: * -> *).
06:10:48 <lambdabot>               (Monad m) =>
06:10:48 <lambdabot>               m Bool -> m a3 -> m a3 -> m a3
06:11:29 <roconnor> cond = liftM3 (\b x y -> if b then x else y)
06:12:16 <roconnor> It ought to be more concise.
06:13:46 <norpan> liftM3 iff :)
06:14:05 <roconnor> too bad iff isn
06:14:07 <roconnor> 't in the prelude
06:15:47 <ndm> roconnor: I think that should be fixed for Haskell' - iff/cond is just too useful not to be in there
06:17:16 <Foobar_> Ok, a third flaw in Haskell: 
06:17:27 <Foobar_> Old news for you (head.reverse) [1,2], probably.
06:17:41 <Foobar_> >(head.reverse) [1,2]
06:17:44 <Foobar_> > (head.reverse) [1,2]
06:17:45 <lambdabot>  2
06:17:48 <Foobar_> This is ok
06:18:00 <Foobar_> > (Just.head) [1,2] is not
06:18:01 <lambdabot>  Not in scope: `is'
06:18:05 <Foobar_> > (Just.head) [1,2] 
06:18:06 <lambdabot>  Not in scope: `Just.head'
06:18:16 <Foobar_> > (Just . head) [1,2] 
06:18:17 <lambdabot>  Just 1
06:18:20 <Foobar_> But this is.
06:18:23 <norpan> well yes
06:18:27 <norpan> but it's no biggie
06:18:30 <Foobar_> I understand why
06:18:37 <Foobar_> No, it's not a big issue.
06:18:49 <dons> Lemmih: oh, not needed. ghc 6.5 does a much better job these days. i'll just install that on the lambdabot box.
06:18:53 <int-e> personally I think the unary minus issue is worse.
06:19:03 <int-e> > (+2) 3
06:19:04 <lambdabot>  5
06:19:06 <int-e> > (-2) 3
06:19:07 <lambdabot>  add an instance declaration for (Num (t -> a))
06:19:21 <norpan> > [t|t <- [1..10]
06:19:22 <lambdabot>  Parse error
06:19:23 <norpan> > [t|t <- [1..10]]
06:19:24 <lambdabot>  parse error on input `<-'
06:19:27 <dcoutts_> dons, nice summary email to Manuel & Roman.
06:19:30 <norpan> > [x|x <- [1..10]]
06:19:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:19:38 <int-e> > [d|d <- [1..10]]
06:19:39 <lambdabot>  parse error on input `<-'
06:19:44 <int-e> but that's a template haskell wart.
06:20:18 <int-e> (why oh why didn't they at least choose capital letters for these?)
06:20:23 <dons> oh, well, since both are in cambridge (i think Manuel's there) i find i need to explain more things, than when i see them day-to-day
06:20:42 <dcoutts_> dons, I should go visit :-)
06:20:43 <davidhouse> int-e, perhaps we could go with emacs-calculator's approach and use _5 etc for negative numbers
06:20:54 <xerox> > [t|t <- [1..10]
06:20:55 <lambdabot>  Parse error
06:20:57 <xerox> > [t|t <- [1..10]]
06:20:58 <lambdabot>  parse error on input `<-'
06:21:02 <Foobar_> int-e: I am not experiencing that here.
06:21:03 <dcoutts_> dons, it's only a couple hours on the bus to Cambridge
06:21:11 <norpan> xerox: i just tried that you know :)
06:21:17 <Foobar_> > [d|d <- [1..10]]
06:21:18 <lambdabot>  parse error on input `<-'
06:21:18 <vincenz> re
06:21:19 <xerox> Woops.
06:21:22 <dons> hehe. since half my groups there, maybe i should just take the hint and move to the uk
06:21:27 <xerox> norpan - We even did the same typo :)
06:21:33 <norpan> spooky
06:21:35 <Foobar_> That's a lambdabot misfeature, I think.
06:21:42 <int-e> davidhouse: or just have negate and negative number literals. that'd allow (- 2) and (-2) to be different.
06:21:47 <dcoutts_> dons, I can put you up at my parents place in Cambridge for a bit if you come over
06:21:51 <vincenz> moin even
06:21:56 <pejo> dons, yeah, who would want the heat down there anyways? :P
06:22:02 <norpan> who needs unary minus anyway
06:22:10 <norpan> remove it
06:22:11 <davidhouse> Foobar_: the [d| is clashing syntax with template haskell.
06:22:14 <int-e> norpan: except for literals, I don't know.
06:22:18 <dons> its 10.2 celcius atm, pejo :}
06:22:33 <norpan> it's just as easy to type (0-2)
06:22:41 <dons> i'd much prefer the baking sun to this shivery coldness
06:22:41 <int-e> literals would also allow things like   f -3 ... which I'd actually like.
06:22:42 <davidhouse> i quite like the _5 approach, now i've though of it
06:22:49 <pejo> dons, same as here. Lots of people in shorts. :-)
06:22:50 <Lemmih> dons: Hurrah for 6.5.
06:23:03 <xerox> What about 6.5? (-:
06:23:09 <int-e> > let _2 = 42 in _2
06:23:10 <lambdabot>  42
06:23:22 <int-e> davidhouse: I'm not sure.
06:23:22 * vincenz peers around
06:23:39 * dons `throwTo` sleep -- for real this time. night!
06:23:49 * xerox catches dons
06:23:52 <dcoutts_> g'night (again)
06:24:02 <roconnor> can we solve the unary minus problem by adding a unary plus?
06:24:06 <dcoutts_> > let _1 = 3 in _1 + _1
06:24:07 <davidhouse> but how many functions do you know with names char '_' >> many digit?
06:24:08 <lambdabot>  6
06:24:10 <int-e> dons don't miss the bed :)
06:24:11 * xerox adds a GoodnightException and throws it again.
06:24:39 <davidhouse> ***Exception: uncaught exception (GoodnightException)
06:25:38 <norpan> let __ = negate in __ 1
06:25:57 <davidhouse> > let __ = negate in __ 1
06:25:58 <lambdabot>  -1
06:26:24 <davidhouse> > let _ = negate in _ 1 {- this'll probably clash with pattern matching -}
06:26:25 <lambdabot>  Pattern syntax in expression context: _
06:27:02 <davidhouse> > Just 4 -- are double-dash style comments still broken?
06:27:03 <lambdabot>  Unterminated end-of-line comment
06:28:56 <davidhouse> odd, it works on my local lambdabot.
06:29:00 <davidhouse> perhaps it's an old bug.
06:29:06 <vincenz> :/
06:30:38 <Foobar_> davidhouse: Isn't that only the case when you import TH?
06:30:52 <davidhouse> Foobar_: yes, which lambdabot has done.
06:31:02 <davidhouse> oh, that's what you mean.
06:31:44 <Foobar_> davidhouse: I agree that's not very nice. Good thing Haskell' comes. Now that backwards-compatibility .... Good luck ;)
06:34:46 <int-e> davidhouse: well, how recent is your lambdabot? the error message comes from the Plugs module, via Lib.Parser and both are very new.
06:35:01 <vincenz> yep
06:35:05 <vincenz> since 2 days ago
06:35:10 <vincenz> if my memory serves me right
06:35:33 <davidhouse> int-e, it's latest darcs.
06:35:50 <int-e> davidhouse: strange.
06:36:15 <davidhouse> let me unapply a patch i made to that area and try again
06:36:30 <vincenz> bit really strange
06:36:35 <vincenz> not really strange even
06:36:55 <int-e> changing  case parseExpr src of  in Plugs.hs to  case parseExpr (src ++ "\n") of  should fix it.
06:37:11 <vincenz> yep
06:37:15 <int-e> (at least playing around with Lib.Parser suggests that)
06:37:23 <vincenz> that's my point
06:37:30 <vincenz> the previous system inserted \n
06:37:36 <int-e> it did?
06:37:40 <vincenz> I do believe so
06:37:42 <vincenz> let me check
06:37:59 <vincenz> yep
06:38:01 <vincenz> if you look at
06:38:05 <vincenz> Script/RunPlugs.hs
06:38:07 <vincenz> the code is still there
06:38:12 <int-e> RunPLugs is irrelevant.
06:38:20 <vincenz> it's the previous system
06:38:24 <int-e> RunPlugs is still used.
06:38:34 <davidhouse> aha! my patch to limit Plugs's output to 80 chars inadvertantly fixed that bug.
06:38:51 <vincenz> int-e: yes but now parsing is done already once in Plugin/Plugs.hs
06:38:54 <int-e> but before it's invoked, Plugs.hs does its own parsing to check the expression.
06:39:01 <vincenz> int-e: while before the code generated by RunPlugs. was the only one parsed
06:39:04 <vincenz> which included \n
06:39:08 <int-e> and that check never added a newline.
06:39:27 <int-e> vincenz: We were talking about different things :)
06:39:31 <vincenz> yes, and the reason -- worked before is because RunPlugs did
06:39:34 <vincenz> int-e: no we're not
06:40:07 <int-e> vincenz: yes we are. My point is that -- comments never worked since Plugs started to do its own parsing
06:40:26 <vincenz> int-e: and my additional commentp oints out to the differentiatiing factor
06:40:28 <int-e> vincenz: While you were talking about versions before that change.
06:41:25 <davidhouse> err, scratch that, no it didn't.
06:42:30 <vincenz> int-e: 
06:42:32 <vincenz> 15:36 < vincenz> the previous system inserted \n
06:42:32 <vincenz> 15:37 < int-e> it did?
06:42:55 <davidhouse> int-e, i can confirm that (src ++ "\n") fixes it. submit a patch! :)
06:43:06 <int-e> vincenz: We had a different scope for 'previous system'. Hence the confusion.
06:43:12 <vincenz> ah
06:43:39 <int-e> davidhouse: can you do that? I haven't managed to wire up darcs with my mail program yet.
06:43:52 <vincenz> int-e: no need.. just don't add an email
06:43:58 <davidhouse> darcs send -o fix-comments.patch
06:43:59 <vincenz> int-e: then manually email the patch
06:44:10 <vincenz> as davidhouse points out
06:44:11 <davidhouse> then use whatever mail client you want to email said patch.
06:44:31 <vincenz> davidhouse: even outlook express?
06:44:51 <davidhouse> vincenz: well...
06:44:52 <davidhouse> :)
06:45:08 <vincenz> On another note, anyone know a nice application for linux that combines calender with todo-list with cost estimation and possibly even semi-automated layouting to fill your schedule with said tasks?
06:45:31 <vincenz> something like outlook meets ms project (--)
06:46:35 <davidhouse> KOrganiser or similar?
06:46:50 <davidhouse> i don't know what it does, but i assume at least some of those requirements.
06:46:58 <vincenz> right now I just use openoffice calc
06:47:03 <vincenz> with different columns
06:47:05 <roconnor> @docs rational
06:47:05 <lambdabot> rational not available
06:47:15 <davidhouse> @hoogle Rational
06:47:15 <lambdabot> Prelude.Rational :: type Rational
06:47:15 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
06:47:15 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
06:47:18 <vincenz> but sometimes you forget when your last checkpoint was, so you don't know how many hours to add to the thing you're working on
06:47:23 <davidhouse> @docs Prelude
06:47:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:48:45 <vincenz> erm
06:48:55 <vincenz> davidhouse: todo's in korganizer don't have "estimated time"
06:49:13 <vincenz> at least not from what I can tell from the site
06:49:31 <roconnor> Must infix type constructors begin with : ?
06:49:41 <norpan> roconnor: they must
06:49:56 <vincenz> norpan: I beg to differ
06:49:58 <davidhouse> huh? no they don't
06:50:02 <davidhouse> infix _data_ constructors need to
06:50:15 <davidhouse> infix type constructors are a GHC extension, though.
06:50:21 <norpan> are you sure
06:50:25 <vincenz> norpan: ->
06:50:28 <davidhouse> yeah.
06:50:31 <norpan> -> is special
06:50:39 <vincenz> -> is still a tycons
06:50:47 <roconnor> davidhouse: But they look so pretty.
06:50:49 <vincenz> it's predefined and the only one allowed to start with ->
06:51:06 <roconnor> Are they in Haskell' ?
06:51:36 <davidhouse> class Arrow (~>) where pure :: (a -> b) -> (a ~> b); (>>>) :: (a ~> b) -> (b ~> c) -> (a ~> c); first :: (a ~> b) -> ((a, d) ~> (b, d))
06:52:14 <davidhouse> all we need is type-level fixity decls, then we can do type F $ G = F G
06:52:32 <vincenz> davidhouse: yeah I was arguing that earlier, I want . and $ for types
06:52:37 <norpan> ok then
06:52:44 <vincenz> A (B (C D)) -> A . B . C $ D
06:52:46 <norpan> then they mustn't
06:53:13 <davidhouse> or A . B $ C D, to save space :)
06:53:17 <vincenz> rightio
06:53:26 <SamB> well, wouldn't they need to be called :. and :$, if not builtin?
06:53:38 <norpan> we just agreed that they need not start with :
06:53:41 <vincenz> SamB: well they're surrounded by types
06:53:43 <SamB> oj
06:53:49 <SamB> oh
06:53:50 <davidhouse> SamB: they're type constructors, not data ones.
06:54:17 <SamB> I thought starting with : was analogous to starting with a capital letter
06:54:18 <vincenz> davidhouse: and obviously Flip :)
06:54:18 <norpan> and the simple reason is that there are no infix type variables
06:54:33 <vincenz> SamB: yes... but for DATAconst
06:54:39 <vincenz> SamB: cause both are used in expressions
06:54:45 <vincenz> SamB: tycons are only used in tyclauses
06:54:46 <SamB> well, point
06:54:48 <davidhouse> data constructors need to have colons because they're first class, and so need to be distinguishable from operators.
06:55:17 <vincenz> davidhouse: if you were allowed to partially apply type aliases... it'd be quite neat
06:55:19 <roconnor> what parsing level is -> at?
06:55:25 <vincenz> Flip a b = Flip b a
06:55:28 <vincenz> erm
06:55:33 <vincenz> Flip c a b = c b a
06:55:41 <davidhouse> roconnor: the type level?
06:55:59 <roconnor> for precidence of infix type operators
06:56:05 <roconnor> type constructors
06:56:42 <vincenz> roconnor: well given how it's the only one... lower than application
06:56:46 * SamB wonders why Page Up in less is so much slower than Page Down
06:57:13 <roconnor> vincenz: but in GHC we can make as many infix type constructors as we want.
06:57:21 <vincenz> hmm
06:57:59 <vincenz> what boggles my mind is how GHC can change it's parser depending on fixity declarations in the stuff it's parsing
06:58:07 <mux> so, it looks like I said bullshit the other day, Google isn't using Haskell
06:58:13 <vincenz> I mean it uses happy which can easily generate s/r
06:58:29 <SamB> mux: they would like to, though, I think
06:58:35 <mux> although reppie told me they use it for one project
06:58:41 <mux> reppie: what project is that?
06:58:44 <SamB> vincenz: two pass approach?
06:58:45 <mux> if you can tell :)
06:59:10 <vincenz> SamB: yeah but even then, the parser rules are defined in happy...
06:59:18 <norpan> vincenz: it's easy enough to parse and then rearrange according to fixity
06:59:18 * mux pokes reppie 
06:59:26 <reppie> mux some research thing
06:59:28 <dcoutts_> vincenz, I wrote a parser that copes with fixity decls but doesn't change the parser during parsing...
06:59:29 <vincenz> norpan: it is?
06:59:33 <reppie> can't tell you exactly what
06:59:36 <SamB> vincenz: the precedence might be done in a post-happy step?
06:59:37 <mux> oki :-)
06:59:37 <reppie> also because i don't remember :P
06:59:41 <mux> hahaha
06:59:44 <norpan> vincenz: i don't know what ghc does, but it's easy :)
06:59:45 <vincenz> dcoutts_: could I take a looksie?
07:00:02 <vincenz> SamB: yeah but you need to set up a pre-happy precedence rules... 
07:00:03 <dcoutts_> vincenz, parse first and then figure out the bracketing later once you know all the fixity decls
07:00:23 <vincenz> SamB: or you'll get a shit load of conflicts if you put all operators at the same level 
07:00:41 <vincenz> dcoutts_: any source I might look at?
07:00:42 <norpan> no you won't
07:00:52 <norpan> you just parse them left-to-right
07:00:59 <vincenz> oh
07:01:05 <dcoutts_> vincenz, eg parse "a * b + c" as just a list without any precedence and then figure it out later
07:01:18 <SamB> yeah, really, why would you get conflicts?
07:01:19 <vincenz> opexplst op nooopexp
07:01:20 <vincenz> like that?
07:01:26 * vincenz hmms
07:01:28 <vincenz> good point
07:01:32 <SamB> especially since the operators would all be in one non-terminal...
07:01:43 <dcoutts_> vincenz, that even allows you to import fixity decls from other modules
07:01:45 <Saulzar> You could do it in parsec especially easy since you could make a new operator parser as a state, right?
07:01:48 <vincenz> dcoutts_: and how complex is the rearranging?
07:01:52 <norpan> that's what i always do when fixity is complex :)
07:02:01 <vincenz> norpan: :D
07:02:05 <dcoutts_> vincenz, just some stack fiddling
07:02:12 <norpan> also makes the parser faster
07:02:17 <dcoutts_> vincenz, like writing an expression parser by hand
07:02:22 <SamB> Saulzar: not really
07:02:22 <SamB> what if the fixity was declared further down?
07:02:26 <vincenz> got some pseudocode lying around?
07:02:31 <roconnor> @hoggle lift
07:02:32 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
07:02:32 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
07:02:32 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
07:02:49 <dcoutts_> vincenz, take a look at any article on parsing expressions with precidence
07:02:50 * vincenz thinks parsec ain't ideal for parsing prog languages
07:02:53 <dcoutts_> vincenz, that's all it is
07:02:55 <Saulzar> SamB, Ah right - then you can't do it in one pass at all then.
07:02:58 <vincenz> dcoutts_: alright thx
07:03:05 <norpan> vincenz: use a stack, push until higher precedence, then pop, rinse, repeat
07:03:17 <vincenz> norpan: hmm ... sounds like LR :P
07:03:33 <norpan> this is the afterwork
07:03:37 <norpan> not hard at all
07:03:39 <vincenz> that was a joke
07:03:42 <dcoutts_> vincenz, you start with your list of expressions + ops and push things onto an op stack or onto the bracketed result depending on predence
07:03:45 <roconnor> ?type ap
07:03:46 <lambdabot> forall b (m :: * -> *) a.
07:03:46 <lambdabot> (Monad m) =>
07:03:46 <lambdabot> m (a -> b) -> m a -> m b
07:03:57 <SamB> now, you could do it in two passes that are mostly the same, I think... but maybe it would be too much trouble to set up the precedence...
07:04:02 <vincenz> dcoutts_: yeah a simplistic LR(1) syste
07:04:06 <dcoutts_> vincenz, right
07:04:23 <vincenz> how about prefix operators?
07:04:23 <dcoutts_> vincenz, one can even handle prefix & postifx operators that way
07:04:41 * vincenz has two operators in his language that bind tighter than func-app
07:04:44 <dcoutts_> I think I did for my gaurded command language
07:05:01 <vincenz> x#i
07:05:03 <vincenz> and !x
07:05:27 <Saulzar> Indexing?
07:05:37 <vincenz> Saulzar: I have arbitrary tuples
07:05:51 <vincenz> or whatever fancy cs'rs call em
07:05:59 <roconnor> lists!
07:06:02 <roconnor> ;)
07:06:02 <vincenz> as for !x, that's reading a ref
07:06:04 <vincenz> roconnor: no
07:06:08 <vincenz> roconnor: not lists
07:06:16 <roconnor> :)
07:06:17 <vincenz> mine are heterogenous and still typed
07:06:35 <vincenz> and arbitrary fixed size
07:07:20 <vincenz> anyways
07:07:22 <vincenz> thx for the tips
07:07:25 * vincenz returns to his minilang
07:07:28 <dcoutts> JaffaCake, re those multi-core sparc boxes. Ubuntu will run on them, even officially supported it looks like
07:07:29 <dcoutts> http://computerworld.co.nz/news.nsf/news/5C5BF521B786C207CC25717D0018F1FC
07:08:35 <JaffaCake> dcoutts: thanks, actually I have access to a 32-core machine at the uni of Berlin right now, don't know much about it though
07:08:47 <dcoutts_> JaffaCake, oh nice.
07:08:59 <dcoutts_> what arch is that?
07:09:39 <dcoutts_> JaffaCake, so are you using that to test the rts smp scalability?
07:09:55 <JaffaCake> we probably will do, yes
07:10:04 <dcoutts_> that should make a nice paper :-)
07:10:14 <JaffaCake> hope so
07:11:12 <dcoutts_> JaffaCake, you saw the FPS fusion benchmark that dons and I have been hacking on?
07:11:23 <JaffaCake> yes, v. impressive
07:11:39 <dcoutts_> :-) we're aiming to get that all sorted out in time for ghc 6.6
07:11:46 <dcoutts_> especially to get the api worked out
07:11:51 <JaffaCake> great
07:12:13 <dcoutts_> and to include the .Lazy version
07:12:21 <roconnor> @hoogle mapM2
07:12:22 <lambdabot> No matches found
07:12:28 <roconnor> @hoogle liftM2
07:12:29 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
07:12:29 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:12:33 <dcoutts_> JaffaCake, that's the nasty one that pretty much relies on lazy IO ;-)
07:12:54 <dcoutts_> it's not so much a lazy ByteString as a ByteStream
07:12:54 <JaffaCake> I saw your discussion with dons about lazy I/O earlier
07:13:02 <int-e> Ah. Wiring up darcs send was easier than I thought. darcs send --help wasn't helpful on the matter though.
07:13:27 <dcoutts_> JaffaCake, yeah, I'm glad you broungt up the issue, we hadn't thought too much about exceptions etc before
07:13:30 <JaffaCake> so you'll be throwing exceptions for I/O errors, rather than just truncating the stream?
07:13:46 <dcoutts_> JaffaCake, that seems a better idea, what do you think?
07:13:55 <JaffaCake> certainly better, yes
07:14:12 <vincenz> JaffaCake, dcoutts_: aren't try-catch handlers typically expensive?
07:14:12 <JaffaCake> except that EOF should truncate the stream, of course :)
07:14:22 <dcoutts_> JaffaCake, right :-)
07:14:38 <dcoutts_> JaffaCake, it still gives the problem that the exception can be hiding in a complex strucure, eg if one parses from a lazy ByteString
07:14:39 <JaffaCake> vincenz: not that expensive, no
07:15:00 <JaffaCake> dcoutts_: yes, that's the problem
07:15:49 <vincenz> JaffaCake: well you have to rewind the callstack and check for handlers at each level, no?
07:16:09 <vincenz> or is there some major difference between the ocaml exception system and haskell one
07:16:42 <dcoutts_> JaffaCake, I guess it's just a tradeoff, you can have short elegant IO code by using a stream abstraction and composing stream transformers or have lower level control where you really get involved in the control flow, ie a monadic interface.
07:16:43 <JaffaCake> vincenz: you said "aren't try-catch handlers expensive" - the handlers themselves aren't expensive, but raising an exception does indeed have to walk up the stack, yes
07:16:59 <vincenz> ah alright :)
07:17:01 <dcoutts_> JaffaCake, then it's just a matter of how much people care when they decide which interface to use.
07:17:30 <dcoutts_> so just like with the Haskell98 IO interface I guess we just need to provide both methods
07:17:42 <JaffaCake> dcoutts_: it'll be good to get some experience using it
07:17:47 <dcoutts_> yeah
07:18:11 <JaffaCake> I'm concerned that if this is standardised, it forces imprecise exceptions into the standard too
07:18:17 <dcoutts_> mmm
07:18:21 <JaffaCake> there will be some objection to that
07:18:44 <dcoutts_> hopefully it'll teach us something about how to build a new IO system
07:18:50 <JaffaCake> (but not from me - I think we need imprecise exceptions, if only as a way to recover from pattern matching failures)
07:19:15 <dcoutts_> but as I said, I expect we'll have to keep the split lazy/strict IO interface from Haskell98 for just that reason
07:19:31 <JaffaCake> that's my thinking too
07:19:55 <dcoutts_> but I think it would be nicer to keep things like encoding etc in the non-streams part of the api
07:20:31 <dcoutts_> so either as ByteSteam -> ByteStream transformers or individual ByteString -> ByteString functions for the strict case
07:20:47 <dcoutts_> thought the hard part of that for the strict case is boundaries
07:21:04 <dcoutts_> eg multi-char encoding boundaries
07:21:31 <JaffaCake> what do you mean by the non-streams part of the API?
07:21:32 <dcoutts_> so you can't just read a ByteString and convert that to a PackedString (eg by utf8 decoding)
07:21:32 <vincenz> dcoutts_: how so... if you provide a simple getByte interface ...
07:21:37 <SamB> okay, so how do I match a quotation mark in Alex?
07:21:48 <vincenz> SamB: the '?
07:21:59 <Lemmih> shapr: ping
07:22:03 <SamB> '?
07:22:06 <vincenz> SamB: most symbols are matched with \symb
07:22:09 <dcoutts_> JaffaCake, well I'm not sure I like the approach of pushing encoding & compression layers into a Stream api
07:22:20 <vincenz> SamB: you want to match ' or "   ?
07:22:42 <JaffaCake> dcoutts_: you'd rather they were lazy stream transformers?
07:23:02 <dcoutts_> JaffaCake, ideally yes, but I see that's hard for the non-lazy case
07:23:14 <JaffaCake> maybe there needs to be both
07:23:16 <dcoutts_> JaffaCake, I'd prefer to keep the IO Streams layer simple and just deal with blocks of data at the Stream layer
07:23:19 <vincenz> SamB: 
07:23:23 <vincenz> SamB: \"  or \' 
07:23:58 <dcoutts_> JaffaCake, eg I don't think a lazy ByteStream needs any buffering support in a Handle
07:24:12 <SamB> yeah, was trying that, but forgot to replace my earlier attempt throughout...
07:24:18 <SamB> (which had been "\""
07:24:29 <dcoutts_> all that bufering machinery etc is needed for the strict monadic IO case
07:25:17 <JaffaCake> dcoutts_: that's right, a lazy stream would connect directly to the low-level block I/O layer
07:25:38 <vincenz> dcoutts_: and for the strict monadic io case... one would think that encoders (decoders) would use getByte
07:25:46 <JaffaCake> one advantage of Streams is that the block I/O layer is extensible, unlike Handles
07:25:56 <dcoutts_> JaffaCake, right, which would also avoid an extra copy. I think it could be quite competitive on performance.
07:26:14 <dcoutts_> JaffaCake, yes, certainly, it being extensible is great.
07:26:59 <dcoutts_> JaffaCake, my main point is that the direction it seemed to be going was that we'd push things like encoding & decompression etc as Stream transformers
07:26:59 <JaffaCake> I take your point about lazy streams, actually I hadn't been considering lazy I/O up to now, and I suspect Bulat didn't either
07:27:16 <SamB> okay, it looks like (the main pass of) my lexer is finally finished ;-)
07:27:25 <dcoutts_> JaffaCake, yeah, me neither 'til I noticed how easy it is to layer on top of ByteString
07:27:56 <dcoutts_> JaffaCake, since ByteString performs well and [a] performs excelently then [ByteString] seemed obvious
07:28:03 <JaffaCake> well yes, in the monadic I/O model stream layering seems like the right thing to do
07:28:31 <dcoutts_> yeah I guess so, but you can see that it'd end up with a more and more obvious split in the api
07:28:44 <dcoutts_> depending on if you're taking the lazy or strict model
07:29:03 <JaffaCake> yes, that's a worry
07:29:31 <dcoutts_> because you'd need to use one style for composing layers in the lazy (.) and one in the strict (myStreamTransformer (stream))
07:29:51 <JaffaCake> Lemmih: I'm happy to discuss object viewers when you're ready, sorry I keep disappearing :)
07:30:45 <JaffaCake> dcoutts_: this is something we should ruminate on.  hopefully there'll be a way to unify them
07:30:56 <dcoutts_> JaffaCake, yeah, there's no rush
07:31:20 <vincenz> arrows?
07:31:22 <dcoutts_> JaffaCake, so you'd be happy for us to include Data.ByteString.Lazy ?
07:31:32 <JaffaCake> sure, don't see why not
07:31:38 <dcoutts_> ok, great.
07:31:50 <SamB_XP_> hehe, see, no need to show users!
07:32:26 <dcoutts_> JaffaCake, any opinion on wether the IO parts of Data.ByteString should live in that module or say System.IO.ByteString ? You put the IO parts of PackedString in the same module I recall.
07:32:50 <JaffaCake> do you have a haddock doc I can look at?
07:32:55 <vincenz> dcoutts_: why not work with arrows as abstraction formalism... then (.) is obvious and mystreamTransformer(stream) becomes part of the static part of the arrow
07:33:06 <dcoutts_> JaffaCake, yes, let me find a rcent version...
07:33:12 * JaffaCake ducks the arrows
07:33:15 <norpan> i just want to chime in that when doing a new IO interface we take into consideration that Char is unicode :)
07:33:15 <dcoutts_> heh
07:33:25 <dcoutts_> norpan, don't worry, we are.
07:33:42 <dcoutts_> norpan, a ByteString is not a PackedString, we know that.
07:34:26 <norpan> what has that to do with unicode?
07:34:52 <norpan> oh, packedstring takes String, right
07:34:53 <SamB_XP> a lot
07:35:38 <norpan> but my point is that since Char is unicode we should not encourage use of for instance ByteString.Latin1
07:35:53 <vincenz> norpan: bytestring is what it names implies
07:35:57 <vincenz> norpan: a string of bytes
07:36:22 <norpan> perhaps ByteList would be a better name then
07:37:20 <dcoutts_> JaffaCake, http://haskell.org/~duncan/fps/
07:37:35 <JaffaCake> cheers
07:37:37 <dcoutts_> http://haskell.org/~duncan/fps/Data-ByteString.html#28
07:38:12 <dcoutts_> oh, the fusion stuff will not be exported from the main ByteString module
07:38:41 <dcoutts_> JaffaCake, and I've no idea why we've got getArgs
07:38:50 <vincenz> how do you get a haskell.org/~
07:39:23 <yaarg> how do you type tilde you mean? i.e. type ~?
07:39:35 <dcoutts_> JaffaCake, hGetLines might disapear too since the .Lazy module provides a much bigger generalisation
07:39:38 <roconnor> newtype Base = Base Rational deriving Num
07:39:42 <vincenz> no a homedir on haskell.org
07:39:46 <roconnor> Can't make a derived instance of `Num Base'
07:39:49 <roconnor> Why not?
07:40:42 <dcoutts_> vincenz, I've got one because I admin a project website there (Gtk2Hs)
07:41:42 <dcoutts_> JaffaCake, actually I could do with some advice on implementing ByteString.Lazy.hGetContents
07:41:54 <shapr> Lemmih: pong
07:42:03 <dcoutts_> JaffaCake, we need it to use non-blocking IO so that one can use it with sockets & pipes
07:42:37 <dcoutts_> I was trying to follow the String hGetContents implementaion, but... it's hard to follow :-)
07:42:37 <JaffaCake> dcoutts_: take a look at the implementation of hGetContents in GHC.IO
07:42:43 <dcoutts_> heh :-)
07:42:43 <JaffaCake> oh
07:42:48 <JaffaCake> sorry :(
07:42:55 <shapr> NewCGI is quite nice.
07:43:10 <JaffaCake> basically you need to chop off the String part :) 
07:43:16 <dcoutts_> JaffaCake, I couldn't see when you were waiting/blocking and how you distinguish a lack of available input from the EOF
07:43:29 <JaffaCake> ok, hang on
07:44:08 <shapr> Though I get confused between the repo name, haskell-cgi and the lib name, NewCGI.
07:44:34 <dcoutts_> JaffaCake, you can see our current stuff here: http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString/Lazy.hs
07:45:03 <JaffaCake> dcoutts_: the important bit is fillReadBuffer, in GHC.Handle
07:45:17 <JaffaCake> fillReadBuffer throws the EOF exception at the end of the file
07:45:21 <dcoutts_> ah
07:45:39 <JaffaCake> it's caught by lazyReadBuffered
07:48:14 <JaffaCake> dcoutts_: you can use GHC.Handle.readRawBuffer as the interface to non-blocking I/O
07:48:37 <JaffaCake> it's platform-independent
07:48:41 <dcoutts_> ok
07:48:52 <JaffaCake> or readRawBufferPtr
07:48:54 <Foobar_> What's wrong with this? [(x,y,z)|x<-[1,2,3,4],y<-[1,2,3,4],x/=y,Just z<-foo x y] --foo return something of type Maybe Foo
07:49:14 <dcoutts_> JaffaCake, I'm slightly confused about exactly what blocking semantics we want
07:49:49 <JaffaCake> the lazy list should contain any input that is available, that's the semantics you want
07:50:02 <JaffaCake> if you try to take more than is available, you block
07:50:04 <dcoutts_> JaffaCake, we need to block waiting for input, but then when input is available we want to get just what it available, not necessarily a whole buffer
07:50:12 <JaffaCake> right
07:50:23 <JaffaCake> readRawBuffer does that
07:50:30 <dcoutts_> JaffaCake, right, so my problem is translating the list semantics into the monadic what we actually do part :-)
07:50:41 <dcoutts_> ok, great
07:50:49 <norpan> if i read the code correctly, when building a ByteString.Lazy using only cons, you will end up with 17 byte chunks?
07:50:56 <norpan> that's an odd number
07:51:01 <roconnor> What does %y mean in glasgow-exts?
07:51:12 <dcoutts_> norpan, really? oh hmm. Yeah, odd. :-)
07:51:20 <shapr> Linear parameters maybe? But I'm just guessing...
07:51:37 <dcoutts_> norpan, feel free to profilie it and find the right magic number for coalesing size
07:53:39 <Foobar_> Or can't I use pattern matching in a list-comprehension?
07:54:18 <dcoutts_> JaffaCake, so readRawBuffer will thow an exception if an IO error occurs and if it'd block then it waits for input
07:54:31 <ndm> Foobar_: yes, you can
07:54:32 <dcoutts_> so yeah, that's exactly what we need
07:54:39 <ndm> Foobar_: but let, for pattern patching
07:54:42 <dcoutts_> JaffaCake, the fog begins to clear... :-)
07:54:59 <JaffaCake> dcoutts_: actually readRawBuffer doesn't throw the exception, it returns zero for EOF
07:54:59 <ndm> [ ... let Just x = (function returning maybe)]
07:55:14 <ndm> [ ... Just x <- (function returning [Maybe x])
07:55:15 <dcoutts_> JaffaCake, ah ok, so that's like normal blocking IO semantics
07:55:19 <JaffaCake> yup
07:55:21 <dcoutts_> nice
07:55:22 <JaffaCake> just like Unix read()
07:55:31 <dcoutts_> ok, that makes life easier
07:55:36 <dcoutts_> thanks v. much
07:55:42 <JaffaCake> no problem
07:56:08 <dcoutts_> JaffaCake, and for the Handle we just import GHC.LowLevelGubbins to get access to the FD ? for use with readRawBuffer
07:56:14 <Foobar_> ndm: So, it if I put [foo x y] it works?
07:56:38 <vincenz> ndm: sadly that doesn't fail for Nothings in a proper way
07:57:01 <JaffaCake> dcoutts_: ah yes, take a look in GHC.Handle for examples, you want something like wantReadableHandle
07:57:03 <vincenz> > let foo a b = if a > b then Nothing else Just (b-a) in [(x,y,z) | x <- [1,2,3,4], y <-[1,2,3,4], x /= y, let Just z = foo x y]
07:57:04 <lambdabot>  Irrefutable pattern failed for pattern Data.Maybe.Just z
07:57:13 <dcoutts_> JaffaCake, ok will do
07:57:42 <Foobar_> ndm: thanks, it works
07:58:44 <Foobar_> vincenz: Oh, I didn't knew that was possible too. That's nicer.
07:59:08 <vincenz> lemmih proposed a solution
07:59:33 <vincenz> > let foo a b = if a > b then Nothing else Just (b-a) in [(x,y,z) | x <- [1,2,3,4], y <-[1,2,3,4], x /= y, Just z <- [foo x y]]
07:59:34 <lambdabot>  [(1,2,1),(1,3,2),(1,4,3),(2,3,1),(2,4,2),(3,4,1)]
08:00:37 <vincenz> or other possibility
08:00:38 <vincenz> > let foo a b = if a > b then Nothing else Just (b-a) in [(x,y,z) | x <- [1,2,3,4], y <-[1,2,3,4], x /= y, z <- maybeToList $ foo x y]
08:00:39 <lambdabot>  [(1,2,1),(1,3,2),(1,4,3),(2,3,1),(2,4,2),(3,4,1)]
08:02:04 <ndm> I need GHC optimisation help :)
08:02:36 <ndm> I am trying to test if the os is windows, at runtime
08:02:50 <ndm> but it would be nice if GHC could optimise it to True/False depending on where I am compiling
08:03:05 <vincenz> ndm: you can use the preprocessor
08:03:12 <Igloo> Does System.mumble not do that?
08:03:31 <ndm> vincenz: no, i don't want to, since Yhc will want to test at runtime (since its cross platform binaries)
08:03:48 <ndm> Igloo: I can get the info, but it seems GHC leaves some string tests there for runtime
08:03:57 <vincenz> ndm: well make separate preprocessor statement for yhc
08:04:00 <Igloo> Ah, System.Info.arch/os
08:04:04 <Igloo> Ah, hmm
08:04:08 <ndm> Igloo: , yep
08:04:23 <ndm> vincenz: but there is no reason GHC shouldn't be able to opimise it
08:04:27 <Igloo> Submit a patch to replace the String with data OS = Linux | Windows | ... | Other String
08:04:35 <vincenz> #if windows and ghc \n True #elif not windows and ghc \n False #else yhccode #endif
08:04:35 <Igloo> Then the optimiser should be happy
08:04:37 <ndm> just checking, does -fext-core dump the optimise the Core?
08:04:56 <ndm> Igloo: would be nice, esp since it never returns Windows at the mo (on Windows it returns mingw32)
08:05:17 <Igloo> Actually, doing something similar for ghc's source itself is on my want-to-do-list so many of the ifdefs can disappear and compiler warings are more useful
08:05:52 <ndm> Igloo: are most of them FilePath issues? or general compiler ones?
08:06:05 <ndm> my module is to paper over all FilePath issues, which might help in your quest
08:06:43 <Igloo> It's things like which registers exist and what ELF section names there are IIRC
08:08:22 <JaffaCake> Igloo: also installation-tree layout differences between Windows/Unix
08:08:58 <JaffaCake> and multiple native code generators, different flags to pass to gcc
08:13:36 * int-e hopes he didn't spam dons with many copies of the same patch now :/
08:15:11 <vincenz> anyone read cardelli's paper on type systems? (2004)
08:15:15 <dcoutts_> Igloo, yes, it'd be nicer if it needed less cpp, eg I don't see why one shouldn't include every backend into the NCG
08:15:23 <vincenz> is the F_2 == F_w from tapl?
08:15:52 <dcoutts_> Igloo, might make it possible to cross-compile...
08:16:25 <dcoutts_> that'd be useful for Arm for example, or perhaps bootstrapping to other arches
08:16:30 <ForgeAus> hey Vincenz :)
08:16:38 <vincenz> ForgeAus: hello
08:16:44 <ForgeAus> sup?
08:18:10 <Igloo> dcoutts_: Well, with what I was thinking about all the other-arch stuff would get optimised away
08:18:24 <dcoutts_> Igloo, right if you make arch static
08:18:26 <Igloo> Cross-compilatin would still have the problem of different constants on different arches etc
08:18:39 <dcoutts_> and if it was dynamic then it wouldn't get optimised away
08:18:51 <dcoutts_> Igloo, sure, it's only one part of it
08:44:49 <vincenz> Anyone have any suggestion on syntax for tuples?   [1,2]:: (Int,Int),  x#1 :: Int.   x@[#1=4] :: (Int,Int) ?
08:45:05 * vincenz doesn't like the x@.. one
08:45:19 <dcoutts_> vincenz, (1,2) :: (Int, Int)   :-)
08:45:30 <vincenz> dcoutts_: yeah but since I don't have lists [] is easier to parse
08:45:41 <dcoutts_> hmm
08:45:45 <dcoutts_> s/(/[
08:45:46 <vincenz> my main concern is on tuple modification
08:46:01 <vincenz> which is not mutating, but giving a new value
08:46:06 <vincenz> (kind like record updates in haskell)
08:46:20 <dcoutts_> aye
08:46:54 <dcoutts_> (1,2)!1
08:47:16 <vincenz> selection?
08:47:17 * vincenz uses #
08:47:32 <vincenz> !x is for derf
08:47:35 <vincenz> s/derf/deref
08:47:47 <dcoutts_> (1,2){#1=x}
08:47:56 <dcoutts_> yeah, I guess what you had isn't too bad
08:50:03 <vincenz> out of curiousity
08:50:22 <vincenz> is the default implementation of read left or right recursive
08:50:47 <vincenz> data A = X | A :=> A deriving (Read)
08:50:56 <vincenz> read "A :-> A :-> A"
08:51:01 <vincenz> erm s/-/=
08:51:27 <vincenz> well you get the idea... (A should be X)
08:51:53 <sjanssen_> vincenz: depends on the fixity of :=>
08:51:59 <vincenz> sjanssen_: even for Read?
08:52:19 <vincenz> how do they get that into the haskell code?
08:52:24 <vincenz> fixity is at the level of haskell parsing, read is haskell code
08:53:29 <sjanssen_> vincenz: yes, derived read uses the fixity of the data construtor
08:53:33 <vincenz> neat
08:54:07 <int-e> Phew. I think dons hadn't got any emails at all because I was too stupid to use esmtp *sent patch now*
08:54:12 <sjanssen_> and "x :=> y :=> z" is an error if the fixity of :=> isn't declared infixl or infixr
08:54:17 <vincenz> sjanssen_: thx :)
09:29:21 <vincenz> @hoogle fmap
09:29:22 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
09:29:22 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
09:29:22 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
09:36:22 <vincenz> @pl \(x,y) -> x++"."++y
09:36:22 <lambdabot> uncurry ((. ('.' :)) . (++))
09:36:39 <vincenz> @pl \(x,y) -> x++".":y
09:36:40 <lambdabot> uncurry ((. ("." :)) . (++))
09:41:04 <bringert> morning #haskell
09:41:15 <bringert> big patch day today
09:41:26 <ForgeAus> hehe not morning here in Australia oh hangon wait it is after 12 anyhow
09:41:30 <ForgeAus> more like 2am
09:41:53 <ForgeAus> ie - wrong end of morning
09:41:59 <bringert> I found patches for three different projects in my inbox, good thing to wake up to
09:42:11 <ForgeAus> :) kewl
09:42:49 <bringert> I'm in the US for a few months, so I'm taking advantage of that to say good morning at strange hours
09:43:03 <bringert> hoping noone can figure out that I should have been up long ago
09:43:14 <bringert> anyway, breakfast time
09:43:15 <ForgeAus> jetlag?
09:46:29 <bringert> nope, late night and cozy bed
09:51:19 <ithika> hi folks
09:55:50 <Daveman> xerox :)
10:02:34 <ADEpt> ithika: hi. new here?
10:04:57 <ADEpt> @seen dons
10:04:58 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours, 41 minutes and 17 seconds ago.
10:17:14 <ADEpt> if i make type alias in the form : type Foo = Class a => Bar a and make function f :: Foo -> IO (), why wouldn't "Class a =>" appear in the type signature of f (in ghci)?
10:18:08 <vincenz> ADEpt: erm
10:18:11 <vincenz> ADEpt: you mean
10:18:24 <vincenz> type Class a => Foo = Bar a
10:18:39 <ADEpt> no, exactly as i typed
10:18:43 <ADEpt> ghc digests it
10:18:55 <vincenz> ADEpt: yes but I think you'rs is a forall
10:19:04 <vincenz> ADEpt: while mine is one with constraint
10:19:14 * vincenz shuts up
10:19:17 <ithika> ADEpt: why yes, I am!
10:19:26 <ADEpt> vincenz: yours give parse error on "=>"
10:19:30 <vincenz> hmm
10:19:32 <vincenz> ADEpt: maybe
10:19:38 <vincenz> data Class a => Foo a = Bar a
10:19:41 <ADEpt> ithika: learning haskell in university?
10:19:50 <ithika> self-study
10:20:01 <ADEpt> vincenz: yes, indeed. But for type synonims syntax is apparently different
10:20:07 <ADEpt> ithika: need any help?
10:20:07 <vincenz> hm
10:20:24 <ithika> ADEpt: maybe :)
10:20:30 <ADEpt> vincenz: problem is, later on i have strange errors:
10:20:38 <sjanssen_> ADEpt: the type def you gave uses forall
10:20:41 <ithika> I'm still getting to grips with some things
10:20:49 <vincenz> ADEpt: I think there's no need to constraing Class a in f....cause a does not appear in f
10:20:53 <vincenz> ADEpt: it's constrained within the Foo type
10:20:55 <ADEpt> Lambdabot.hs:458:24:
10:20:55 <ADEpt>     Inferred type is less polymorphic than expected
10:20:55 <ADEpt>       Quantified type variable `a' escapes
10:20:55 <ADEpt>       Expected type: ThreadId -> Chan (Maybe a) -> t
10:20:55 <ADEpt>       Inferred type: ThreadId
10:20:56 <ADEpt>                      -> Message.Pipe
10:21:01 <ADEpt>                      -> Message.Pipe
10:21:34 <ADEpt> type Pipe = Message a => Chan (Maybe a)
10:21:51 <ADEpt> (Message is both module and typeclass)
10:21:55 <vincenz> ADEpt: maybe use data cons?
10:22:00 <ADEpt> ithika: like what?
10:22:27 <ADEpt> vincenz: data constructors? hmm. i was hoping to reduce impact from refactoring
10:22:29 <vincenz> newtype Pipe = Pipe (Message a => Chan (Maybe a))
10:22:51 <vincenz> ADEpt: well what you're trying is skimming on the border of legality
10:23:21 <ADEpt>     Couldn't match `Control.Concurrent.Chan.Chan a' against `Pipe'
10:23:21 <ADEpt>       Expected type: Control.Concurrent.Chan.Chan a
10:23:21 <ADEpt>       Inferred type: Pipe
10:23:34 <ADEpt> vincenz: that's with your newtype
10:23:43 <vincenz> newtype Pipe = Pipe { unPipe :: Message a => Chan (Maybe a) }
10:23:47 <vincenz> and then call unPipe
10:24:08 <ithika> ADEpt: I'm getting a neat "Prelude.read: no parse" error
10:24:25 <vincenz> ADEpt: and obviously it complains... newtype makes a new type, it's not aliasing
10:25:29 <ADEpt> ithika: paste the code
10:25:35 <ADEpt> @where paste
10:25:36 <lambdabot> http://paste.lisp.org/new/haskell
10:25:49 <ADEpt> vincenz: stupid me :(
10:26:23 <vincenz> ADEpt: nah, it's a typical psychological thing, you're focussed on one thing that you don't see the forest through the trees
10:26:43 <vincenz> s/focussed/so focussed/
10:27:27 <ADEpt> vincenz: yep. Maybe i'm better of with "type Pipe a = Maybe (Chan a)"?
10:27:39 <vincenz> maybe
10:28:03 <vincenz> I've never seen class constraints before inside a type alias
10:29:46 <lisppaste2> ithika pasted "Config "no parse" read error" at http://paste.lisp.org/display/20627
10:30:20 <vincenz> ithika: missing {
10:30:31 <vincenz> and constructor
10:30:37 <vincenz> Config { ... }
10:30:49 <ADEpt> yep
10:31:16 <ithika> explain in smaller words please? :-)
10:31:30 <lisppaste2> vincenz annotated #20627 with "fix" at http://paste.lisp.org/display/20627#1
10:31:32 <vincenz> tere
10:31:42 <vincenz> no =
10:31:53 <vincenz> s/tere/there
10:32:02 <vincenz> and you had some funky tabs in your post
10:32:47 <sjanssen_> ithika: also, Read is not a very robust tool for config files
10:32:54 <vincenz> in addition
10:32:58 <yaarg> so has anyone written an interesting web app in Haskell?
10:33:00 <vincenz> I think liftM is preferred over fmap
10:33:02 <ithika> i will bear that in mind
10:33:09 <vincenz> liftM read readFile
10:33:11 <ithika> thanks everyone
10:33:14 <vincenz> :)
10:33:44 <vincenz> fmap is typically used more for containers or at least htat's my stylistic impression
10:34:24 <magnus> Are there any standard functions (a->b)->(a,c)->(b,c) and (a->b,(c,a)->(c,b) ?
10:34:50 <vincenz> magnus: yes
10:34:56 <sjanssen_> @. pl djinn (a -> b) -> (a, c) -> (b, c)
10:34:57 <lambdabot> f = (`ap` snd) . (. fst) . ((,) .)
10:35:00 <vincenz> nope
10:35:02 <vincenz> sjanssen_: use arrows
10:35:11 <vincenz> @hoogle (a->b) -> (a,c) -> (b,c)
10:35:12 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
10:35:12 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:35:14 <vincenz> hmm
10:35:22 <vincenz> @type Control.Arrow.first
10:35:23 <lambdabot> forall (a :: * -> * -> *) d c b.
10:35:23 <lambdabot>         (Arrow a) =>
10:35:23 <lambdabot>         a b c -> a (b, d) (c, d)
10:35:23 <sjanssen_> vincenz: yeah, I was hoping that @pl would use the arrow combinators
10:35:24 <xerox> The first one is first.
10:35:32 <xerox> The second one is second.
10:35:51 <magnus> thanks guys :)
10:35:53 <vincenz> xerox: I commend you on your ability to discern positioning :)
10:36:15 <xerox> (-:
10:36:30 <vincenz> sjanssen_: yeah I kinda expected it too after you had typed it, bu then figured it was your intent
10:36:32 <magnus> one more: a->[a]
10:36:39 <vincenz> magnus: return
10:36:46 <magnus> cheers
10:36:59 <vincenz> @type return
10:37:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
10:37:17 <xerox> @pl \f (x,y) -> (f x,y)
10:37:17 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
10:37:21 <xerox> Aww.
10:37:52 <vincenz> @type first ==  (`ap` snd) . (. fst) . ((,) .)
10:37:53 <lambdabot>   No instance for (Eq ((b -> c) -> (b, b1) -> (c, b1)))
10:37:53 <lambdabot>   arising from use of `==' at <interactive>:1:6-7
10:38:14 <vincenz> @type second ==  (`ap` snd) . (. fst) . ((,) .)
10:38:15 <lambdabot>   No instance for (Eq ((c -> c) -> (c, c) -> (c, c)))
10:38:15 <lambdabot>   arising from use of `==' at <interactive>:1:7-8
10:38:28 <vincenz> odd
10:38:36 <xerox> > typeOf first == typeOf (\f (x,y) -> (f x,y)
10:38:37 <lambdabot>  Parse error
10:38:41 <xerox> > typeOf first == typeOf (\f (x,y) -> (f x,y))
10:38:42 <lambdabot>  Add a type signature
10:38:45 <xerox> haha.
10:38:54 <sjanssen_> too polymorphic
10:39:04 <vincenz> sjanssen_: megamorphic?
10:39:19 <xerox> powermorphic
10:39:25 <vincenz> xerox: sounds like powerpuffs
10:39:28 <sjanssen_> mighty morphic power combinators
10:39:30 <xerox> Howdy Cale!
10:39:38 <sieni> megalomorphic rather
10:39:41 <xerox> The polymorphic function of doom.
10:39:45 <vincenz> polyschimos 
10:39:56 <ForgeAus> ultramorphic?
10:40:02 <vincenz> kind of like omorphi and aschimos 
10:40:14 <xerox> (mfix poly) ++ morphic
10:40:18 <ForgeAus> superduperhypermorphic turbo?
10:40:25 * xerox wins!
10:40:25 <vincenz> xerox: why not plain fix
10:40:32 <ForgeAus> sorry I thikn I took it a little to far
10:40:39 <xerox> It is meant in the Evil Monad.
10:40:46 <vincenz> supercalifragalisticsescicalimorphic
10:40:59 <vincenz> or however it's written
10:40:59 <ForgeAus> then give it a touch of Godliness!
10:41:15 <ForgeAus> exicali nice!...
10:41:26 <ForgeAus> not how I remember it but I like your version better :)
10:41:49 * vincenz heard mary poppins in italian when he was young
10:41:55 <vincenz> the difference might derive from there
10:42:17 <ADEpt> vincenz: oh damnit. I'm drowned in type errors now :( Maybe typeclasses were not such a cool idea.
10:42:20 * vincenz looks at xerox for confirmation
10:42:31 <ForgeAus> I wouldn't have a clue how to translate anything into italian except one word... Pomodoro! == Tomato! :)
10:42:49 <vincenz> ADEpt: yeah don't tell me about it... I once tried to make my typechecker monad independent of the types it checks by having the unifier passed in as extra arguments... a shitload of errors
10:43:01 <vincenz> cool no?
10:43:05 <xerox> Supercalifragilistichespiralidoso.
10:43:13 <vincenz> type-independent typechecker monad
10:43:18 <xerox> haha, same length.
10:43:21 <vincenz> xerox: no morphic
10:43:27 <ADEpt> vincenz: sounds cool :)
10:43:33 <xerox> That's the real world, anyway.
10:43:40 <xerox> *word - gee.
10:43:48 <ForgeAus> fragilistichespirali? hmmm thats a little diff... still kewl tho
10:44:09 <vincenz> xerox: philomorphic?
10:44:15 <ForgeAus> not sure if I got all the vowels right but sounds to me something like supercalifragilisticexpialadocious in the movie
10:44:21 <vincenz> it shapes itself to what it likes?
10:44:28 <vincenz> which is pretty much what the complex types do
10:44:58 <vincenz> ForgeAus: xerox's was the italian one
10:45:02 <ForgeAus> probably more like expial*i*docious
10:45:15 <ForgeAus> vincenz yeah I know
10:45:32 * vincenz points Cale to the team page to update his likes
10:45:59 <ForgeAus> I havn't heard the Italian vers... I'm just giving what I gather from the English vers...
10:46:13 <vincenz> @seen oejet
10:46:13 <lambdabot> oejet is in #haskell, #haskell_ru and #haskell-blah. I don't know when oejet last spoke.
10:46:29 <sjanssen_> @keal
10:46:29 <lambdabot> #haskell needs to take its meds
10:46:40 <ForgeAus> lol
10:46:44 * vincenz gives lambdabot a philomorphic type
10:47:01 <ForgeAus> whats philomorphic mean?
10:47:38 <ForgeAus> lover of change?
10:47:42 <vincenz> philo = love, morphic = shapechanging
10:47:50 <vincenz> loves to change shape?
10:48:31 <ForgeAus> greek etomology, I get that, but hows that apply to haskell? something like varient typing (or if you like Duck-typing?)
10:48:53 * ADEpt . o O (damn! "Illegal polymorphic or qualified type: ... When checking the data constructor: ..." - i hate you!)
10:49:10 <vincenz> ForgeAus: well ADEpt's is a perfect case in show
10:49:12 <ForgeAus> I hate you is a data constructor? how strange
10:49:14 <vincenz> he's got a philomorphic type
10:49:32 <ForgeAus> hows Haskell bind?
10:49:39 <ADEpt> :-E~~~
10:49:46 <ForgeAus> if you can answer that you can probably figure out the answer...
10:49:52 <sjanssen_> ForgeAus: "bind"?
10:49:56 <ForgeAus> to the morphic issue
10:50:01 <vincenz> bind?
10:50:03 <ADEpt> even 3(8-E~~
10:50:04 <ForgeAus> yeah type-binding...
10:50:07 <ForgeAus> or isn't that applicable to Haskell?
10:50:12 <vincenz> m a -> (a - > m b) -> m b
10:50:25 <vincenz> ADEpt: philomorphic types?
10:50:44 <ADEpt> typephobic types
10:50:49 <vincenz> it's the same
10:50:54 <vincenz> the motivation is just different
10:50:58 <ADEpt> the ones that give you fear of typing
10:51:01 <vincenz> oh
10:51:05 <vincenz> I thought theones that fear to type
10:51:09 <vincenz> and hence stay as morphic as possible
10:51:23 <ADEpt> vincenz: do you know what aibofobia is ?
10:51:23 <ForgeAus> can you force-type?
10:51:30 <vincenz> ADEpt: what's aibo?
10:51:40 <vincenz> @dict aibo
10:51:40 <lambdabot> Supported dictionary-lookup commands:
10:51:40 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
10:51:40 <lambdabot> Use "@dict-help [cmd...]" for more.
10:51:50 <vincenz> @foldoc aibo
10:51:52 <lambdabot> No match for "aibo".
10:52:01 <ADEpt> vincenz: "aibo" is meamingless, it's "aibofobia" that's meaningfull
10:52:01 <sjanssen_> aibo, are we talking about the robot dog that Sony used to make?
10:52:04 <vincenz> ADEpt: fear of sony-dogs?
10:52:07 <ForgeAus> @all-dicts aibo
10:52:08 <lambdabot> *** "aibo" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
10:52:08 <lambdabot> AIBO
10:52:08 <lambdabot>   Artificial Intelligence roBOt (Sony, AI)
10:52:08 <lambdabot>  
10:52:12 <vincenz> yep
10:52:15 <ADEpt> vincenz: fear of palyndromes
10:52:15 <vincenz> fear of sony-dogs
10:52:23 <vincenz> ah :)
10:52:24 <ForgeAus> hehe palindromes! I love palindromes!
10:52:30 <ForgeAus> like radar :)
10:52:38 <vincenz> ADEpt: is that like oliphilo
10:52:40 <ADEpt> then there is "panafobia"
10:52:43 <ForgeAus> theres gotta be a kewler longer one than that but none spring to mind right now
10:52:44 <vincenz> ADEpt: or does tat mean "love for fat"?
10:52:48 <vincenz> ADEpt: pana = everything
10:52:54 <vincenz> ?
10:53:00 <vincenz> like panorama
10:53:07 <sjanssen_> panamorphic
10:53:07 * ADEpt had a workmate who had a screensaver flashing different "*fobia" definitions on screen
10:53:19 <sjanssen_> @type undefined -- this is panamorphic
10:53:20 <lambdabot> forall a. a
10:53:26 <ForgeAus> hehe its all greek to me!
10:53:26 <vincenz> ADEpt: omofobia is the worst
10:53:31 <ADEpt> panafobia is fear of everything. Including GADTs and dependent types
10:53:50 <vincenz> (or is it egofobia)
10:53:51 <ForgeAus> type-dependance sounds nasty anyhow
10:54:05 <vincenz> ForgeAus: yeah they have meetings for it like AAA with 12 step programs
10:54:18 <ForgeAus> whats the third A stand for?
10:54:26 <vincenz> anonymous alcoholics association?
10:54:26 <sjanssen_> I'm sjanssen, and I'm a typeaholic
10:54:46 <sjanssen_> vincenz: if I remember correctly, it's just AA
10:54:50 <ForgeAus> oh I always thought it was just Alcoholics Anonymous, didn't know they had an association
10:54:50 <vincenz> ah
10:54:54 * vincenz lives in the us
10:54:55 <vincenz> erm
10:54:56 <vincenz> europe
10:55:04 * ForgeAus chuckles
10:55:14 <sjanssen_> AAA is an automobile drivers association (or something like that)
10:55:22 <vincenz> sjanssen_: admit it, you're a typeophiliac
10:55:33 <ForgeAus> probably something like American Automotive Association
10:55:54 <ForgeAus> it'd be much kewler if it was like Algerian or Andorian instead :)...
10:55:55 <vincenz> sjanssen_: you doing a phd?
10:56:03 <sjanssen_> vincenz: nope, undergrad
10:56:13 <vincenz> sjanssen_: oh... otherwise I'd suggest submitting your paper to jGB
10:56:35 <ForgeAus> TLA's are a dime a dozen, but then I wouldn't even pay that!
10:58:15 <sjanssen_> vincenz: jGB?  (jgb.org seems to be Jewish Guild for the Blind -- bet you didn't mean that)
10:58:51 <vincenz> journal of general bs
10:59:13 <vincenz> it's a great line to use in the grad world
10:59:19 <vincenz> "Hey man, I read your paper, it'd be perfect for JGB"
10:59:38 <ithika> is there a way to pipe the output of a process back into the calling (haskell) program?
11:00:05 <dmhouse> vincenz: unless the person you're talking to turns out to be a blind jew, that is.
11:00:06 <ithika> i'm trying to bypass saving to disk then reading
11:00:42 <vincenz> dmhouse == davidhouse?
11:00:48 <sjanssen_> ithika: have you tried using a pipe? ;)
11:00:53 <dmhouse> oops, i changed nick on the wrong server
11:01:12 <davidhouse> dmhouse is my efnet nick (they have a 9-character limit there)
11:02:11 <sjanssen_> ithika: specifically, check out System.Process.runProcess
11:03:42 * ADEpt wants to check his bearings
11:03:54 <ADEpt> suppose i have a code that operates on Message datatype
11:04:24 <ADEpt> now, time has come to say that those messages could come in two flavors
11:05:01 <ADEpt> and i want to choose from one of the "internal representation" at, say, compile time
11:05:20 <ADEpt> So, I make Message into a typeclass
11:05:24 <vincenz> yep
11:05:31 <ADEpt> then, all the hell breaks loose
11:05:39 <vincenz> ADEpt: possibility two
11:05:41 <vincenz> import qualified
11:05:48 <vincenz> import qualified mode one as M
11:05:52 <vincenz> import qualified othermode as ..nothing
11:05:56 <vincenz> then if you wanna change
11:06:00 <ADEpt> i'd have to import it in 20 files
11:06:03 <vincenz> swap the two qualifiers
11:06:09 <ithika> sjanssen_: just what I was looking for. magic
11:06:16 <vincenz> ADEpt: make one global file
11:06:18 <ADEpt> vincenz: which hardly qualifies for "easily choose at compile time"
11:06:19 <vincenz> interface.hs
11:06:27 <vincenz> then export from there
11:06:33 <vincenz> one file to change ;)
11:06:52 <ADEpt> vincenz: but that's .... ugly?
11:06:56 <vincenz> heh
11:07:00 <vincenz> all compiletime hacks are?
11:07:17 <ForgeAus> eeek hacks!
11:07:18 <vincenz> ADEpt: use #ifdef?
11:07:20 <vincenz> and preprocessor?
11:07:30 <Saulzar> Surely type classes are ideal for that kind of thing?
11:07:31 * ForgeAus covers his ears
11:07:32 <ADEpt> well. what if I want to be able to process both types of messages at once? then, it's only typeclass, right?
11:07:39 * vincenz nods
11:08:01 <vincenz> Saulzar: typeclasses are not the end all be all
11:08:03 <ADEpt> then, all datatypes that include Message start having type variables
11:08:07 <ForgeAus> eyedeal.... :)
11:08:17 <ForgeAus> or do I?
11:08:18 <ADEpt> ... and all functions
11:08:24 <ADEpt> ... and all instances
11:08:25 <vincenz> ADEpt: yep
11:08:32 <Saulzar> vincenz, Well no.. but they do seem quite good for overloading :)
11:08:51 <vincenz> Saulzar: philomorph
11:09:08 <ADEpt> ... and soon i find myself writing: newtype LB m a = LB { runLB :: ReaderT (IORef (Maybe (ServerRState m)),IORef (IRCRWState m)) IO a }
11:09:25 <ADEpt> it was ugly even before I added "m" there. But now it's even uglier!
11:09:30 <vincenz> ADEpt: see why I want $ and . for types
11:09:34 <vincenz> ;)
11:09:56 <vincenz> ReaderT . IORef . Maybe . ServerRState $ m
11:10:05 <ADEpt> nice :)
11:10:09 <vincenz> yeah
11:10:13 <vincenz> except it doesn't exist
11:10:20 <Saulzar> Do as the C++ template programmer does and add some synonyms :)
11:10:34 * vincenz typedefs Saulzar to the moon
11:10:49 <vincenz> Saulzar: type aliases don't work for partially applied types
11:10:57 <vincenz> monads are partially applied by definition
11:11:16 <Saulzar> You can do this... type Foo a = Blargh a a
11:11:28 <vincenz> you need this
11:11:33 <vincenz> type Foo m a = Blargh m a
11:11:37 <vincenz> and then apply Foo to one param
11:11:40 <vincenz> which is afaik not allowed
11:12:33 <Saulzar> Ah, you want Foo m a = Blargh m (Foo m a) or something?
11:13:06 * ADEpt needs to talk to some lambdabot hacker
11:16:58 * shapr wants to watch a Haskell TV show.
11:17:17 <shapr> Who can we persuade to do a short video interview with SPJ and JaffaCake?
11:18:45 <vincenz> hmm
11:18:45 * vincenz wonders how much effort it will be to make his type inferer generalize to typeschemes
11:18:46 <monochrom> Is type inference a special case of resolution?
11:18:46 <stepcut> :p
11:18:46 <davidhouse> shapr, concerning?
11:18:46 <psnl> monochrom: I think so
11:18:46 <monochrom> I suspect that most producers will dumb it down to the point it isn't Haskell-specific.
11:19:27 <shapr> davidhouse: I dunno, cool Haskell research stuff.
11:19:27 <monochrom> SPJ: "So, Haskell is the finest imperative programming language on Earth!"  Interviewer: "Could you say that again in English?"
11:20:20 <davidhouse> shapr: go to a conference :)
11:20:26 <vincenz> aha! types that can be autoconverted without having to call a conversion function are philomorphic!
11:20:43 <monochrom> haha philomorphic
11:21:31 <vincenz> monochrom: we were trying to define those errors you get in haskell when typeclasses go haywire or when it needs more specific type info
11:22:06 <monochrom> SPJ: "The community has written web servers in Haskell and they are faster and more secure than other web servers."  Interviewer: "But why don't they use Java?"
11:22:42 <vincenz> monochrom: SPJ "The GHC compiler performs a lot of optimizations." Interviewer; "Why throw manyears at something that can be solved with more computers."
11:23:07 <monochrom> That is too smart on the part of the interviewer, methinks :)
11:23:11 <vincenz> true
11:23:26 <monochrom> (At least, I would say that to computer graphics research. XD)
11:23:37 <sjanssen_> how about one Simon interviews the other
11:23:37 <vincenz> SPJ: "Haskell is a statically typed functional language", Interviewer: "That's like ruby or lisp, right?"
11:23:52 <monochrom> Remember, the interviewer doesn't even know "imperative programming language"!
11:24:00 <vincenz> monochrom: better?
11:24:02 <Cale> vincenz: haha
11:24:04 <monochrom> yeah hehe
11:24:27 <Cale> where is this interview?
11:24:33 <vincenz> "It supports higher order types" Interviewer: "Yes, like Ruby's yield feature"
11:24:47 <monochrom> Here, right here, Straw-Man Interview! XD
11:24:49 <vincenz> Cale: we're making it up
11:24:52 <Cale> ah
11:24:58 <Cale> okay :)
11:25:07 <vincenz> monochrom: we should make a comic and ping pong these, one does SPJ one the interviewer
11:25:33 <vincenz> with one of those typical tooth-sparkling business interviewers
11:25:46 <vincenz> maybe a blonde woman named "Sandy"
11:26:13 <flux__> I think the blonde woman should maybe also have excessive lung capacity?
11:26:24 <vincenz> :)
11:26:26 <vincenz> however truth be said
11:26:29 <vincenz> there is one tv show
11:26:33 <vincenz> not sure if it's on tv or only online
11:26:37 <vincenz> with a woman interviewing people
11:26:43 <vincenz> and they're typically very technical
11:27:06 <vincenz> more like a talkshow really... cause one guest comes to the front to speak with her
11:27:06 <monochrom> Is it good?
11:27:09 <vincenz> monochrom: yeah
11:27:15 <vincenz> forgot the name tho
11:27:18 <vincenz> I found it once
11:27:21 <monochrom> okay, that restores my faith
11:27:23 <vincenz> it was an interview of some famous developer
11:27:32 <vincenz> in a talkshow setting
11:27:38 <vincenz> (well a bit more demure)
11:27:49 <vincenz> some guy who worked on delphi or .net or something
11:28:34 <vincenz> anyone happen to know the name?
11:28:41 * vincenz wouldn't want to see a couple more
11:28:54 <sjanssen_> vincenz: Oprah?
11:29:04 <monochrom> No way XD
11:29:17 <vincenz> "Oh I see... haskell leads to higher spirituality"
11:29:25 <sjanssen_> vincenz: exactly!
11:29:45 <monochrom> davidhouse also in efnet #math?
11:29:53 <sjanssen_> the Haskell Report should be the next book in Oprah's Book Club
11:30:04 <davidhouse> monochrom: yes i am. why?
11:30:05 <vincenz> sjanssen_: no Dr Phil
11:30:11 <vincenz> sjanssen_: "I must say I read the book from cover to cover!"
11:30:24 <monochrom> I just noticed, due to the temporally correlated part and join.
11:30:47 <davidhouse> and the fact my nick's the same :)
11:30:59 <davidhouse> monochrom: you're not monochrom there, are you?
11:31:00 <vincenz> correlation is what will tie fbi to your illegal account
11:33:04 <monochrom> I am the monochrom
11:33:41 <Cale> haha, Dr. Phil. "You're trying to write a program without static typing... It's like you're on a Caribbean cruise in a rowboat!"
11:34:21 <vincenz> :D
11:34:21 <monochrom> haha
11:34:29 <vincenz> dr phil is the only talkshower I'll watch
11:34:35 <vincenz> erm
11:34:37 <vincenz> talkshow'er
11:34:48 <vincenz> tho I guess the difference is moot
11:35:35 <magnus> are there standard operators to combine boolean predicates, ie: (a->Bool)->(b->Bool)->Bool ?
11:35:52 <vincenz> magnus: huh?
11:35:53 <vincenz> magnus: how?
11:35:56 <monochrom> No.
11:36:12 <vincenz> @type \f -> or . map f
11:36:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:36:17 <monochrom> Moreover I would expect (a->Bool)->(a->Bool)->(a->Bool)
11:36:17 <vincenz> ;)
11:36:34 <sjanssen_> @pl \p q x -> p x && q x
11:36:34 <lambdabot> liftM2 (&&)
11:36:36 <vincenz> @type \x -> or . map ($x)
11:36:37 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:36:39 <vincenz> :)
11:37:05 <monochrom> fooeay, liftM2 !!
11:37:06 <vincenz> ($x) looks like perl :(
11:37:07 <Cale> liftM2 (&&)
11:37:08 <magnus> sorry, I typed/thought wrong
11:37:14 <Cale> and liftM2 (||)
11:37:22 <vincenz> @type \x -> or . map ($x)
11:37:23 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:37:24 <magnus> @hoogle (a->Bool)->(a->Bool)->(a->Bool)
11:37:25 <vincenz> @type \x -> and . map ($x)
11:37:25 <lambdabot> No matches, try a more general search
11:37:26 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:37:51 <Cale> @type all
11:37:51 <monochrom> @type liftM2 (&&)
11:37:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:37:52 <lambdabot> forall (m :: * -> *).
11:37:53 <lambdabot>      (Monad m) =>
11:37:53 <lambdabot>      m Bool -> m Bool -> m Bool
11:37:57 <Cale> @type any
11:37:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:38:08 <vincenz> @type none
11:38:09 <lambdabot> Not in scope: `none'
11:38:11 <vincenz> blegh
11:38:34 <vincenz> Cale: but what I wrote is not like any or all
11:38:37 <sjanssen_> > liftM2 (&&) even odd 4
11:38:37 <lambdabot>  False
11:38:54 <Cale> I know
11:39:13 <davidhouse> liftM2 (&&) even odd == const False
11:39:27 <magnus> @hoogle a->[a->Bool]->Bool
11:39:28 <lambdabot> No matches, try a more general search
11:39:32 <vincenz> join . curry (a &&& b)
11:39:35 <vincenz> @type join . curry (a &&& b)
11:39:36 <sjanssen_> > liftM2 (&&) even odd undefined
11:39:36 <lambdabot> Not in scope: `a'
11:39:36 <lambdabot>  
11:39:36 <lambdabot> <interactive>:1:20: Not in scope: `b'
11:39:37 <lambdabot>  Undefined
11:39:50 <sjanssen_> davidhouse: not quite ;)
11:40:03 <davidhouse> sjanssen_: up to types.
11:40:10 <davidhouse> s/types/type of the domain
11:40:21 <Cale> @type let swing f c a = (f ($ a)) c in swing any
11:40:22 <lambdabot> forall a.
11:40:22 <lambdabot>                 [a -> Bool] -> a -> Bool
11:40:27 <Cale> @type let swing f c a = (f ($ a)) c in swing all
11:40:28 <lambdabot> forall a.
11:40:29 <lambdabot>                 [a -> Bool] -> a -> Bool
11:40:33 <monochrom> > liftM2 (&&) even odd (undefined :: Int)
11:40:34 <lambdabot>  Undefined
11:40:39 <sjanssen_> davidhouse: nothing to do with types.  up to _|_
11:40:42 <monochrom> I think that is allured.
11:40:48 <monochrom> err alluded
11:40:51 <vincenz> @type let swing f c a = (f ($ a)) c in swing swing
11:40:52 <lambdabot> forall a t t1.
11:40:52 <lambdabot>                 t -> (a -> t -> t1) -> a -> t1
11:40:59 <Cale> @type let swing f c a = (f ($ a)) c in swing partition
11:41:00 <lambdabot> forall a.
11:41:00 <lambdabot>                   [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
11:41:04 <davidhouse> oh, okay. up to type of the domain and strictness.
11:41:14 <vincenz> @type let swing f c a = (f ($ a)) c in swing swing swing
11:41:15 <lambdabot> forall a
11:41:15 <lambdabot>                      t
11:41:15 <lambdabot>                      a1
11:41:15 <lambdabot>                      b
11:41:15 <lambdabot>                      t1
11:41:17 <lambdabot> [9 @more lines]
11:41:23 <magnus> that swing any one is nice
11:41:25 <vincenz> @more
11:41:26 <lambdabot>                      t2.
11:41:26 <lambdabot>                   (a
11:41:26 <lambdabot>                    -> ((((a1 -> b) -> b) -> t1 -> t2)
11:41:26 <lambdabot>                     -> t1
11:41:26 <Cale> @type let swing f c a = (f ($ a)) c in swing zipWith
11:41:27 <lambdabot>                     -> a1
11:41:28 <sjanssen_> _|_ is rather fun to type
11:41:29 <lambdabot> [4 @more lines]
11:41:33 <lambdabot> forall a b c.
11:41:35 <lambdabot>                  [a -> b -> c] -> a -> [b] -> [c]
11:41:37 <davidhouse> sjanssen_: because liftM2 (&&) even odd :: Integral i => i -> Bool, but const False :: a -> Bool, so the domain types differ
11:41:58 <Cale> @type let swing f c a = (f ($ a)) c in swing find
11:41:59 <lambdabot> forall a.
11:41:59 <lambdabot>                 [a -> Bool] -> a -> Maybe (a -> Bool)
11:42:16 <davidhouse> Cale, so qualitatively, what does swing do?
11:42:16 <vincenz> Cale: freaky
11:42:20 * ADEpt has hacked lambdabot to the extreme: "ghc-6.4.1: panic!"
11:42:25 <vincenz> ADEpt: NO!
11:42:37 <vincenz> ADEpt: anamorphic types!
11:42:43 <ADEpt> what ?
11:42:46 <magnus> I'll just define my own operators then
11:42:51 <vincenz> without shape
11:43:34 <vincenz> oh nm..
11:44:18 <vincenz> ADEpt: basically depending on what side you look at them, they'll look like different types
11:45:05 <Cale> davidhouse: Qualitatively? I suppose it's a trick for swapping functions and data in some sense, which abuses the fact that most of the higher order functions take their function parameter first.
11:45:54 <vincenz> Anyone know the name of tat show with the woman doing techical interviews of lead developers in a talkshow like setting?
11:46:13 <Cale> @type let swing f c a = (f ($ a)) c in swing map
11:46:14 <lambdabot> forall a b.
11:46:14 <lambdabot>                 [a -> b] -> a -> [b]
11:46:28 <vincenz> @type let swing f c a = (f ($ a)) c in swing foldr
11:46:28 <Cale> I think that was the original place where I abstracted it from
11:46:29 <lambdabot> forall a b.
11:46:29 <lambdabot>                 b -> a -> [a -> b -> b] -> b
11:46:35 <vincenz> ooh
11:46:49 <vincenz> @type let swing f c a = (f ($ a)) c in swing (flip foldr)
11:46:50 <lambdabot> forall a
11:46:50 <lambdabot>                      b
11:46:50 <lambdabot>                      a1.
11:46:50 <lambdabot>                    (a1 -> ((a -> b) -> b) -> (a -> b) -> b)
11:46:50 <lambdabot>                    -> a
11:46:52 <vincenz> hmm
11:46:53 <lambdabot> [3 @more lines]
11:47:01 <davidhouse> > let swing f c a = (f ($ a)) c in swing map [(+1), (*3), subtract 4] 3
11:47:02 <lambdabot>  [4,9,-1]
11:47:14 <vincenz>  > let swing f c a = (f ($ a)) c in swing map [(+1), (*3),
11:47:23 <vincenz>  > let swing f c a = (f ($ a)) c in swing foldr [(+1), (*3), substract 4] 3
11:47:27 <vincenz> > let swing f c a = (f ($ a)) c in swing foldr [(+1), (*3), substract 4] 3
11:47:27 <lambdabot>  Not in scope: `substract'
11:47:33 <vincenz> > let swing f c a = (f ($ a)) c in swing foldr [(+1), (*3), subtract 4] 3
11:47:33 <lambdabot>  Add a type signature
11:47:38 <vincenz> hmm
11:47:51 <vincenz> > let swing f c a = (f ($ a)) c in swing foldr 0 3 [(+1), (*3), subtract 4] 
11:48:00 <lambdabot>  add an instance declaration for (Num (b -> b))
11:48:15 <vincenz> oh wait...
11:48:30 <vincenz> > let swing f c a = (f ($ a)) c in swing foldr 3 0 [(+), (*), (-)] 
11:48:31 <lambdabot>  0
11:48:50 <vincenz> > let swing f c a = (f ($ a)) c in swing foldr 0 3 [(+), (*), (-)] 
11:48:50 <lambdabot>  12
11:48:55 <vincenz> there you go
11:53:32 <Cale> @type let swing f c a = (f ($ a)) c in swing (=<<)
11:53:33 <lambdabot> forall a
11:53:33 <lambdabot>                    (m :: * -> *)
11:53:33 <lambdabot>                    b.
11:53:33 <lambdabot>                 (Monad m) =>
11:53:33 <lambdabot>                 m (a -> m b) -> a -> m b
11:53:37 <pjd> hello; i am planning to order a Haskell book
11:53:47 <Cale> hi
11:53:54 <pjd> is "Haskell: The Craft of Functional Programming" a good choice?
11:54:03 <ADEpt> yep
11:54:50 <davidhouse> @type let swing f c a = (f ($ a)) c in swing (>>=)
11:54:51 <lambdabot> forall a b b1.
11:54:51 <lambdabot>                 (b -> (a -> b) -> b1) -> a -> (a -> b) -> b1
11:55:07 <vincenz> ADEpt: you have it?
11:55:14 <sjanssen_> @djinn (b -> (a -> b) -> b1) -> a -> (a -> b) -> b1
11:55:14 <lambdabot> f a b c = a (c b) (\ _ -> c b)
11:56:13 <sjanssen_> @. pl djinn (b -> (a -> b) -> b1) -> a -> (a -> b) -> b1
11:56:14 <lambdabot> f = (`ap` ((const .) . flip id)) . (ap .) . (. flip id) . (.)
11:57:50 <ADEpt> vincenz: yep
11:58:01 <blackhwkblade> someone here who understands german?
11:58:10 <Kasperle> yeah
11:58:10 <vincenz> ADEpt: useful for someone who already knows a bit of haskell ? (me?)
11:58:11 <davidhouse> blackhwkblade: a limited amount, why?
11:58:17 <Kasperle> blackhwkblade: what's up?
11:58:21 <sjanssen_> @pl f a b c = a (c b) c
11:58:21 <lambdabot> f = flip flip id . (ap .) . (. flip id) . (.)
11:58:23 <pjd> how does H:TCoFP compare to some of the other choices?
11:58:28 <pjd> from http://www.haskell.org/haskellwiki/Books
11:59:42 <kep> re
12:00:38 <davidhouse> what's with this "re" thing?
12:01:00 <sjanssen_> @elite re
12:01:00 <lambdabot> rE
12:01:06 <kep> davidhouse I means re hi :)
12:01:14 <kep> davidhouse reTurn :)
12:01:22 <davidhouse> hmm.
12:01:25 <davidhouse> i'll stick with "hi" :)
12:01:41 <davidhouse> i keep thinking "regarding"
12:02:10 <kep> davidhouse it can be read as "hello again"
12:02:26 <Kasperle> or "Behold! I have RE turned!"
12:02:34 <Kasperle> :p
12:02:59 <kep> Kasperle it's something like this :)
12:03:33 <pjd> hmm, what about "The Haskell School of Expression: Learning Functional Programming Through Multimedia"?
12:04:28 <SamB_XP> pjd: what about it?
12:04:57 * SamB_XP suddenly notices that he is in windows
12:05:04 <pjd> between it and H:TCoFP, which is more recommendable?
12:05:31 <SamB_XP> oh, no idea. I only have SOE
12:05:50 <davidhouse> pattern guards aren't haskell 98, are they?
12:06:02 <SamB_XP> nope!
12:06:05 <davidhouse> > let y | x <- Just 4 = x in y
12:06:06 <lambdabot>  Parse error
12:06:11 <SamB_XP> they are an extension called "pattern guards"
12:06:15 <davidhouse> ;)
12:06:19 <davidhouse> -fglasgow-exts?
12:06:20 <pjd> SamB: how good is SoE?
12:06:30 <SamB_XP> I'm actually not sure
12:06:57 <SamB_XP> it does do a good bit with combinator languages
12:07:14 <SamB_XP> libraries
12:07:16 <SamB_XP> whatever
12:08:20 <SamB_XP> right now it is out on loan
12:09:14 <pjd> as in monadic combinator?
12:09:45 <vincenz> will we ever have polynadic
12:10:11 <Saulzar> Only in case of severe genetic mutation
12:10:31 <vincenz> Saulzar: of polymorphic types
12:10:32 <vincenz> ?
12:10:50 <SamB_XP> well, there are some monadic ones towards the end...
12:11:17 <Saulzar> vincenz, What does polynadic even mean?
12:11:23 <vincenz> mo-nadic
12:11:25 <vincenz> poly-nadic
12:11:36 <vincenz> polyadic?
12:11:42 <monochrom> mon-adic, poly-adic
12:12:01 <vincenz> right
12:12:18 <monochrom> "negate" is a monadic operator.  (+) is a dyadic operator.
12:12:22 <SamB_XP> vincenz: I think I finished that lexer ;-)
12:12:28 <vincenz> SamB_XP: gratz
12:12:45 <pjd> hmm, the amazon reviews seem much more in favor of SoE than H:TCoFP
12:13:39 <davidhouse> monochrom: hmm... i would use unary and binary for that. or perhaps something relating to arity, so monaritic/biaritic?
12:13:39 <SamB_XP> well, it did look pretty interesting ;-)
12:14:13 <pjd> i think i'll go with it, then :)
12:14:40 <monochrom> But there are a thousand people out there using monadic and dyadic that way.
12:14:46 <monochrom> I can't stop them.
12:15:03 <norpan> dyachrom
12:15:29 <vincenz> polychrom
12:15:51 <vincenz> ooh
12:15:54 * vincenz figures out is new nickname
12:15:59 <philomorphic> :D
12:16:10 <dmh> it's adopt-a-short-nick day.
12:16:11 <monochrom> Moreover I don't think monaritic/biaritic exists.
12:16:19 <dmh> monochrom: no, i just made it up.
12:16:34 <n> weee
12:16:58 * _ smacks n
12:17:06 <dmh> hah
12:17:10 <n> bah
12:17:22 <[]> Darn, someone else owns []
12:17:29 <\x-> err
12:17:30 <SamB_XP> haha
12:17:34 <[x]> Darn, someone else owns [x]
12:17:41 <_> _ is owned too
12:17:42 <\x-> nooooo
12:17:42 <norpan> okay, enough of this.
12:17:51 <\x-> ok
12:17:55 <psnl> cool nick, \x- 
12:18:05 <SamB_XP> and (x:xs) is invalid! bah!
12:18:07 * \o- waves
12:18:30 <\x-> x
12:18:32 * monochrom hates escaping restrictions
12:18:34 * \o\ grins
12:18:41 <norpan> i suck!
12:18:45 <\o\> norpan: not today, thanks
12:19:14 <norpan> \x-: i'll sell it back to you.
12:19:20 <norpan> :)
12:19:22 <\x-> x+1
12:19:26 * SamB_XP can't even remember the password for *this* nick...
12:19:50 <norpan> \x-: to be honest, you could probably ghost me if you get tired of this ;)
12:20:06 * norpan isn't mean enough to take advantage of the situation
12:20:45 <\_-> like this
12:20:55 <\_-> fail "no param"
12:21:59 <xerox> @yow
12:21:59 <lambdabot> What I need is a MATURE RELATIONSHIP with a FLOPPY DISK ...
12:22:07 <davidhouse> ... and we're back :)
12:22:30 <ihope> Bleh, conflicting definitions error.
12:22:32 <ihope> Can I just turn that off?
12:22:50 <davidhouse> conflicting definitions of what?
12:23:14 <xerox> I fear errors must be turned off by fixing.
12:24:59 <dcoutts> @quote-add xerox I fear errors must be turned off by fixing.
12:25:00 <lambdabot> Unknown command, try @list
12:25:03 <dcoutts> bah
12:25:07 <dcoutts> @help quote
12:25:07 <lambdabot> quote <nick>
12:25:08 <lambdabot> remember <nick> <quote>
12:25:08 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:25:15 <dcoutts> @remember xerox I fear errors must be turned off by fixing.
12:25:15 <lambdabot> Unknown command, try @list
12:25:19 <norpan> @quote norpan
12:25:20 <lambdabot> norpan hasn't said anything memorable
12:25:24 <norpan> word
12:25:35 <ihope> @quote ihope
12:25:35 <lambdabot>  Laziness is free, but it doesn't always pay off.
12:25:37 <xerox> :) There's something weird going on with quote.
12:25:41 <ihope> @quote ihope_
12:25:41 <lambdabot> ihope_ hasn't said anything memorable
12:25:50 <xerox> @quote
12:25:51 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
12:25:52 <ndm> @quote ndm
12:25:53 <lambdabot>  the only language i've seen which is ugly at a deeper level than syntax is perl
12:25:58 * xerox added that, hehe.
12:26:15 <xerox> @quote
12:26:16 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
12:26:21 <xerox> @quote
12:26:21 <davidhouse> @quote+ lambdabot lambdabot says: lambdabot hasn't said anything memorable
12:26:22 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
12:26:22 <lambdabot> lambdabot lambdabot says: lambdabot hasn't said anything memorable hasn't said anything memorable
12:26:29 <davidhouse> @quote lambdabot
12:26:30 <lambdabot>  lambdabot hasn't said anything memorable
12:26:50 <davidhouse> @help @remember
12:26:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:27:10 <davidhouse> @list
12:27:12 <lambdabot> list [module|command]. Where modules is one of:
12:27:12 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
12:27:12 <lambdabot> unlambda version vixen where
12:27:17 <davidhouse> @list quote
12:27:17 <lambdabot> quote provides: quote ghc fortune yow arr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw
12:27:26 <davidhouse> how do you make it remember stuff?
12:27:40 <sjanssen_> davidhouse: I think that's broken at the moment
12:27:49 <davidhouse> hmm, okay.
12:27:53 <jcreigh_> Is "yhjulwwiefzojcbxybbruweejw" a command?
12:28:02 <sjanssen_> @yhjulwwiefzojcbxybbruweejw
12:28:02 <lambdabot> "\"#$%&'()*+,\""
12:28:09 <sjanssen_> jcreigh_: yes.  it'
12:28:13 <sjanssen_> s a synonym for v
12:28:19 <xerox> It's like CA, the only way to know it's trying.
12:28:28 <xerox> ...err, is trying.
12:28:34 <davidhouse> @v
12:28:34 <lambdabot> Just 'J'
12:28:37 <davidhouse> @v
12:28:38 <lambdabot> "\"#$%&'()*+,\""
12:28:39 <davidhouse> @v
12:28:40 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
12:28:42 <davidhouse> hehe :)
12:29:01 <sjanssen_> > let v = show (take 10 v) in v
12:29:01 <norpan> i don't see the point of @v
12:29:01 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\""
12:29:13 <xerox> :)
12:29:40 <sjanssen_> norpan: do you remember the whole v debacle?
12:29:54 <norpan> yes
12:29:59 <davidhouse> > length v
12:29:59 <lambdabot>  Not in scope: `v'
12:30:09 <ihope> vincenz!
12:30:15 <vincenz> ihope: !
12:30:25 <jcreigh_> sjanssen_: I don't. What's the whole v debacle?
12:30:43 <vincenz> ihope: was it you working on gameboy emulator or jip?
12:30:53 <ihope> Musta been jip.
12:31:00 <davidhouse> jcreigh: internally, lambdabot does something like "let v = [what you entered] in v"
12:31:10 <vincenz> ihope: what do you do?
12:31:17 <vincenz> ihope: cause you're not the guy in the israeli army either
12:31:22 <davidhouse> so you can mess around with lambdabot's internals by shadowing v.
12:31:33 <jcreigh> Ah
12:31:45 <ihope> vincenz: what do you mean?
12:31:51 <davidhouse> the only interesting thing you can do is:
12:32:04 <davidhouse> > let v = take 20 v in v
12:32:04 <lambdabot>  Add a type signature
12:32:13 <davidhouse> err, never mind. :)
12:32:14 <vincenz> ihope: professionaly
12:32:16 <vincenz> and that's odd
12:32:19 <ihope> > let v = show (take 20 v) in v
12:32:20 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\""
12:32:21 <vincenz> wen my nick was \_-
12:32:23 <vincenz> it would even match \
12:32:30 <ihope> vincenz: still in school
12:33:20 <davidhouse> very little is known about the ihope.
12:33:39 * ihope laughs evilly
12:33:42 <davidhouse> like, his (?) real name
12:33:43 <vincenz> davidhouse: it's like a knowledge singularity
12:34:31 <norpan> why have we only one op in the channel
12:34:40 <davidhouse> norpan: do we need more?
12:34:44 * jcreigh has a vision of everyone in the channel doing a "/whois ihope" :-)
12:34:49 <ihope> Surely there are others whose real names aren't known...
12:34:52 <norpan> davidhouse: i don't know
12:35:02 <norpan> normally you'd have one in each time zone :)
12:35:14 <davidhouse> ihope, well, i've noticed that you use that nick pretty consistently.
12:35:23 <ihope> Oh, and as for the gender, that'd be male.
12:35:24 <davidhouse> most, say, will use their real name on the mailing lists.
12:35:44 <davidhouse> unless your real name _is_ ihope?
12:35:52 <davidhouse> (in which case i sorely apologise :))
12:35:59 <ihope> Heh.
12:36:18 <SamB> we only have one "op" because everyone else is de-opped, thats all
12:36:59 <ihope> No, my name is Ivan Harriot Oscar Paul Emerson :-P
12:37:36 <davidhouse> hehe
12:37:46 <davidhouse> (really?)
12:38:05 <ihope> No.
12:38:33 <davidhouse> okay. :)
12:40:01 <palomer> hrmph
12:40:47 <sjanssen_> so can I really not do this in Haskell 98: "class MyClass x; instance MyClass [Char]", or am I missing something obvious?
12:41:35 <davidhouse> sjanssen_: no, you really can't do that.
12:41:41 <ihope> You can't?
12:41:42 <sjanssen_> humm
12:41:46 <ihope> Why not?
12:41:49 <davidhouse> oh,
12:41:51 <norpan> you can't?
12:41:52 <sjanssen_> that seems silly.  I can't think of any good reason not
12:41:54 <davidhouse> err, maybe you can.
12:41:58 <norpan> i think you can
12:42:05 <sjanssen_> norpan: GHC and Hugs give syntax errors
12:42:07 <davidhouse> you can't do it with String, that's what i was thinking of.
12:42:10 <norpan> why shouldn't you can
12:42:26 <davidhouse> sjanssen_: then it's a syntax error, not a problem with the decl itself
12:42:36 <davidhouse> they'd give more detailed errors if the latter were the case
12:43:02 <monochrom> Can you weaken to "instance MyClass [a]" ?
12:43:34 <sjanssen_> actually, it's not a syntax error, it's a "Illegal instance declaration for `MyClass (Maybe Char)'"
12:43:48 <sjanssen_> monochrom: no
12:46:44 <sjanssen_> with hugs -98 or ghc -fglasgow-exts it works, but that's still annoying
12:47:59 <davidhouse> @hoogle maybeToBool
12:48:00 <lambdabot> No matches found
12:48:16 <davidhouse> i suppose that'd be isJust
12:48:26 <palomer> why can't you give instances to type aliases?
12:48:53 <ihope> @hoogle Maybe a -> Bool
12:48:53 <lambdabot> Maybe.isJust :: Maybe a -> Bool
12:48:53 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
12:49:00 <ADEpt> what does  " Could not deduce (Module a1 m s) from the context (Module a m s)" mean?
12:49:26 <davidhouse> palomer: because in 1998 the class system was quite new, and people didn't think this through enough.
12:49:41 <sjanssen_> the case I've just tripped over is really annoying
12:50:02 <davidhouse> if you want different behaviour from the same type you'd have to newtype anyway, but i don't see any problem with allowing type alias decls.
12:50:04 <sjanssen_> I wonder what this is called, so I can see if it will be fixed in Haskell'
12:50:05 <ADEpt> "Probable fix: add (Module a1 m s) to the existential context for `MODULE'". What is existential context here?
12:50:39 <SimonRC> WTF?!  "toRational :: (Real a) => a -> Rational"  -- a function that converts any real number to a rational number?!
12:51:06 <davidhouse> SimonRC: it approximates
12:51:08 <davidhouse> > toRational pi
12:51:09 <lambdabot>  884279719003555%281474976710656
12:51:12 <SimonRC> yuk
12:51:25 <sjanssen_> toRational doesn't approximate for Float or Double
12:51:34 <davidhouse> > 884279719003555 / 281474976710656
12:51:35 <lambdabot>  3.141592653589793
12:51:41 <davidhouse> > 884279719003555 / 281474976710656 - pi
12:51:42 <lambdabot>  0.0
12:51:43 <SimonRC> mathematical nonsense, though... there are more real numbers than rational ones
12:51:58 <xerox> That just mean that toRational is surjective.
12:52:03 <davidhouse> SimonRC: you think that's mathematical nonsense!?
12:52:04 <davidhouse> > 1/0
12:52:04 <lambdabot>  Infinity
12:52:08 * davidhouse grumbles
12:52:10 <SimonRC> heh
12:52:23 <xerox> davidhouse - What about that (:
12:52:28 <sjanssen_> the problem here is that Real should be called something other than Real
12:52:35 <davidhouse> xerox, don't get me started ;)
12:52:42 <sjanssen_> toRational is perfectly reasonable for floats and doubles
12:53:16 <SimonRC> Well, I answered the post on alt.comp.lang.haskell with a load of jargon about the numeric typeclasses.
12:53:19 <davidhouse> @type pi
12:53:20 <lambdabot> forall a. (Floating a) => a
12:53:37 <SimonRC> the basic problem was a guy doing (a ** floor b)
12:53:56 <sjanssen_> ha, what's worse about the Real class is that it's only method is toRational
12:53:57 <SimonRC> @type (\a b -> a ** floor b)
12:53:58 <lambdabot> forall a b.
12:53:58 <lambdabot>          (Floating b, RealFrac a, Integral b) =>
12:53:58 <lambdabot>          b -> a -> b
12:54:56 <SimonRC> so the return type had to be both Floating and Integral.
12:55:02 <SimonRC> bdmbdmbdmbdm
12:55:16 <SimonRC> the solution, BTW was to use (^^) or (^) instead of (**)
12:55:30 <davidhouse> in theory you could write a type that instantiates both of those classe
12:55:33 <davidhouse> *classes
12:55:44 <SimonRC> yeah, but it's semantic nonsense
12:55:46 <davidhouse> so it won't error at compile time.
12:56:24 <SimonRC> a type that both permits and forbids non-integral values.
12:56:27 <SimonRC> :-S
12:57:29 <SimonRC> "class Num a => Fractional a | ( Integral a) where ..."  <--  YANI
12:57:36 <SimonRC> hmm
12:57:49 <SimonRC> "class (Num a,  Integral a) => Fractional a where"
12:57:53 <SimonRC> that's nicer
12:58:05 <SimonRC> anyway, Haskell's numeric types are a mess
12:58:21 <vincenz> yeah
12:58:24 <vincenz> SimonRC: we need class aliases
13:01:09 <SimonRC> one advantage of OO is the ability to extend stuff without having to be prepared for it...
13:01:24 <SimonRC> in OO, any type can be extended.
13:02:09 <ihope> Records!
13:02:10 <SimonRC> e.g. in Smalltalk, I could create a subclass of bool(ean)
13:02:19 <vincenz> SimonRC: erm type classes?
13:02:19 <davidhouse> class aliases!
13:02:52 <SimonRC> or I could even add a new type of verity (True, False, FileNotFound  >:-) )
13:03:09 <SimonRC> vincenz: yeah, but what if the original author didn't use type classes?
13:03:20 <SimonRC> you'd have to modify all their code to use them
13:03:39 <vincenz> SimonRC: what if the original author had written all the code in java as one big procedure?
13:03:47 <vincenz> SimonRC: don't mistake bad design for bad semantics
13:03:52 <SimonRC> hmm
13:04:48 <SimonRC> wouldn't you end up with huge numbers of class specifications and 1-member classes if you allowed overloading like that in Haskell?
13:05:26 <SimonRC> OTOH, in the most recent Java programming I did was basically faking lazy eval all the way through, as memory was tight (J2ME on a mobile phone).
13:05:27 <vincenz> class alias
13:05:45 <SimonRC> vincenz: define
13:06:28 <vincenz> @google class alias haskell
13:06:30 <lambdabot> http://repetae.net/john/recent/out/classalias.html
13:06:32 <vincenz> tere
13:38:56 <MrHuskell> Got a question, just starting out with monads and thought I write a simple IO program, I got a function that looks something like this : getWord :: IO String; getWord = putStr "Please enter a word" >> putStr "\n" >> putStr "Word:" >> getLine  but when I run it the puts come up in the wrong order with the getLine inbetween  
13:39:45 <apfelmus> @eval getWord :: IO String; getWord = putStr "Please enter a word" >> putStr "\n" >> putStr "Word:" >> getLine
13:39:45 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
13:39:51 <MrHuskell> What Am I doin wrong? (obviously something trivial, but I can't realy think of what it could be)
13:40:21 <monochrom> Odd. Let me try.
13:40:36 <sjanssen_> MrHuskell: buffering is your problem
13:40:43 <MrHuskell> Yes, just thought of that
13:40:44 <sjanssen_> @hoogle hSetBuffering
13:40:44 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
13:40:46 <apfelmus> @help
13:40:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:40:56 <apfelmus> @help list
13:40:56 <lambdabot> list [module|command]
13:40:56 <lambdabot> show all commands or command for [module]
13:41:09 <apfelmus> @help eval
13:41:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:41:20 <monochrom> I tried it and I got the right order.
13:41:21 <MrHuskell> ok, thnx, I'll check it out
13:42:21 <MrHuskell> hmm, thnx guys, I might as well try n learn to use the lambdabot while I'm at it =)
13:42:38 <MrHuskell> Guessin I'm lookin for constructors to Handle and Buffermode
13:42:45 <MrHuskell> @hoogle Handle
13:42:45 <lambdabot> System.IO.Handle :: data Handle
13:42:45 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
13:42:45 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
13:43:10 <monochrom> I tried both inside ghci and using runghc.  All gave the right order.
13:43:45 <MrHuskell> yea, but I'm in windows at the moment (gosh, realy gotta switch over to my linux install)
13:44:09 <MrHuskell> @hoogle BufferMode
13:44:09 <lambdabot> System.IO.BufferMode :: data BufferMode
13:44:37 <MrHuskell> @hoogle System.IO.BufferMode
13:44:37 <lambdabot> No matches, try a more general search
13:44:56 <vincenz> ouch
13:44:56 <vincenz> http://dat.4chan.org/b/src/1149012435043.jpg
13:46:32 <ndm> MrHuskell: hoogle doesn't let you search with qualified names, unfortunately...
13:47:09 <ndm> and you can also use hoogle on a website, if that suits you better
13:47:12 <ndm> @where hoogle
13:47:12 <lambdabot> http://www.haskell.org/hoogle
13:49:10 <MrHuskell> thnx
13:52:36 <sjanssen_> MrHuskell: what you probably want is hSetBuffering stdin NoBuffering
13:52:46 <sjanssen_> actually, make that stdout
13:53:03 <MrHuskell> yea, just read up on it on Haskell.org module info
13:53:39 <MrHuskell> that is about what I figured out, a import System.IO seems to be needed aswell =)
13:54:47 <MrHuskell> Been at Haskell for a week or so now, this is starting to get interesting =)
13:55:56 * monochrom likes manually inserting hFlush at the right points.
13:56:06 <vincenz> monochrom: like after hDump?
13:56:15 <Sentinel> > 5*4
13:56:15 <lambdabot>  20
13:56:47 <norpan> wow
13:56:59 <Sentinel> > fst ("c++", "haskell")
13:57:00 <lambdabot>  "c++"
13:57:08 <norpan> wow again :)
13:57:18 <vincenz> > let worst = fst in worst ("c++", "haskell")
13:57:19 <lambdabot>  "c++"
13:57:33 <vincenz> > reverse "):"
13:57:34 <lambdabot>  ":)"
13:58:01 * vincenz is off
13:58:17 <vincenz> @seen jyp
13:58:17 <lambdabot> I saw jyp leaving #haskell 2 days, 23 hours, 26 minutes and 21 seconds ago, and .
13:58:32 <Sentinel> > reverse "lleksah snwo ++c"
13:58:33 <lambdabot>  "c++ owns haskell"
13:58:36 <Sentinel> ooh ok
13:59:26 * monochrom runs the "bible code" algorithm over the Haskell language definition report.
13:59:41 <Sentinel> > head ["c++", "haskell]
13:59:41 <lambdabot>  Improperly terminated string
13:59:46 <Sentinel> > head ["c++", "haskell"]
13:59:47 <lambdabot>  "c++"
14:00:01 * monochrom finds "a++ is the next generation language"
14:00:35 <vincenz> monochrom: or a^^
14:00:43 <vincenz> exponentiation is stronger than addition
14:01:19 <monochrom> There are not enough occurences of ^ in the document to support that.
14:02:25 <vincenz> monochrom: then use ' '
14:02:33 <vincenz> I can assure you it's the most common symbol
14:02:43 <vincenz> monochrom: in fact I know a language purely based upon it
14:03:00 <monochrom> Alright, a'' it is!
14:03:05 <vincenz> monochrom: a space
14:03:18 <vincenz> no the quotes
14:03:22 <vincenz> s/no/not
14:03:26 <monochrom> spaces are usually not counted in the "bible code" algorithm.
14:03:31 <nn2> Sam
14:03:36 <nn2> you here
14:03:42 <vincenz> monochrom: you've never seen the proglang based on spaces
14:04:07 <Sentinel> has anyone compiled lambabot for win?
14:04:10 <monochrom> I have never seen it.  I think I have heard of it.
14:04:32 <vincenz> monochrom: not much to be seen really :P
14:04:32 <xerox> SyntaxNinja - Yow.
14:04:36 <nn2> sortive stuck with trying to build monopd thing in C
14:04:45 <nn2> gnet got stuck
14:05:04 * vincenz off
14:05:06 <nn2> you know how to do it in haskell
14:05:14 <SyntaxNinja> hiya xerox
14:05:18 <vincenz> hiya SyntaxNinja 
14:05:26 <SyntaxNinja> xerox: I was just thinking about you.
14:05:31 <SyntaxNinja> hey vincenz
14:05:33 <vincenz> SyntaxNinja: feel free to join #oasis :)
14:05:41 <ForgeAus> a++??? is there any such thing?
14:05:41 <vincenz> it's #haskell away from #haskell
14:05:53 <nn2> needs some type of xml decoder
14:05:59 <SyntaxNinja> vincenz: what's that?
14:06:03 <nn2> and networking
14:06:08 <vincenz> SyntaxNinja: erm a channel
14:06:24 <SyntaxNinja> thanks. you're so helpful ;)
14:06:36 <vincenz> SyntaxNinja: officially, channel for our haskell ICFPC team
14:06:49 <vincenz> SyntaxNinja: unofficially: hangout channel for the longterm #haskell'ers
14:06:59 <xerox> ?!
14:06:59 <lambdabot> Maybe you meant: . v
14:07:14 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
14:08:45 <Philippa> vincenz: so unofficially it's #haskell-blah's cliquey cousin?
14:09:10 <vincenz> Philippa: yep
14:09:18 <vincenz> but more ot haskell
14:09:42 <vincenz> and compilers and such in general
14:10:00 <Saulzar> When is the icfp this year? I thought it was april sometime (ie. gone by already)
14:10:07 <SyntaxNinja> portland, OR!!
14:10:34 <vincenz> Saulzar: end of july
14:10:38 <vincenz> 21-24
14:10:59 * Saulzar checks the calendar to see that april comes before may, still not knowing the order of months properly.
14:11:09 <bolrod> O_o
14:11:09 <SyntaxNinja> vincenz: you mean IContestFP, not IConferenceFP, right? :)
14:11:18 <vincenz> SyntaxNinja: ICFP...C
14:11:23 <nn2> wow he has got a huge start for the client in haskell
14:11:36 <vincenz> Icfp itself is september afaik
14:12:03 <nn2> check it out ! http://192.168.1.46:5190/sam/hMonop/monopd.rnc
14:12:10 <vincenz> what's rnc?
14:12:19 <nn2> sam is going to teach me haskell
14:12:20 <vincenz> nn2: that's a local address
14:12:27 <nn2> oups
14:12:46 <bolrod> hehe
14:12:50 <nn2> http://srv256.homelinux.net:5190/sam/hMonop/monopd.rnc
14:13:01 <nn2> fergot 
14:13:14 <bolrod> # = comment?
14:13:17 <bolrod> since when?
14:13:22 <vincenz> what language is that
14:13:26 <vincenz> bolrod: that ain't haskell at all
14:13:34 <bolrod> ;o
14:13:39 <nn2> I run the server so to acess it i have to use local adersses sory 
14:13:40 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
14:13:42 <vincenz> ttribute players { int }?,
14:13:46 <vincenz> sorry (wrong paste)
14:13:51 <bolrod> it looks weird :P
14:13:58 <vincenz> bolrod: seems like a config file
14:14:16 <vincenz> Philippa: and hello to you :)
14:14:28 <nn2> than what is it
14:14:29 <nn2> ??
14:14:30 <lambdabot> Maybe you meant: . v
14:14:42 <bolrod> it's a text file for one thing
14:14:48 <bolrod> the rest.. I don't know
14:14:58 <vincenz> some sort of xml descriptor language
14:15:02 <bolrod> something for version 0.93 :]
14:15:14 <nn2> o intresting
14:15:29 <vincenz> but it's not a prog lang
14:15:32 <vincenz> it's a descriptive lang
14:15:35 <nn2> i thought he was doing it in haskall
14:15:35 <vincenz> if I base myself on the syntax
14:15:48 <vincenz> nn2: maybe he has a haskell parser that parses that to generate an xml validator
14:16:01 <vincenz> kinda like an xsd
14:16:36 <nn2> so he hasent pasted the source yet?
14:16:47 <nn2> ** the real one
14:17:45 <SamB> nn2: are you talking about me?
14:17:55 <nn2> o there you are
14:18:13 <nn2> was wondering was that haskell or somthing else
14:18:22 <SamB> I'm trying to write a parser for the RelaxNG Compact form that will let you use it with HXT
14:18:39 <SamB> I'm too hot, though
14:18:47 <SamB> my dad took the fan for videogames!
14:18:59 <nn2> outch
14:19:10 <SamB> anyway, that file was written in that format
14:20:01 <nn2> so can you make one in haskell so my frends on windows can use it as a Real app?
14:20:10 <SamB> well, it isn't an app really
14:20:23 <SamB> it just describes the valid messages a bit
14:20:34 <SamB> maybe I shouldn't bother with it
14:20:40 <bolrod> bah!  I need to dust out my computer... 
14:21:13 <SamB> I could just use trang to translate the schema to the XML syntax, which HXT already knows
14:22:28 <nn2>  i was trying to when gcc got @#$!!!@$^%$$ confused about gnet and erred left and write 
14:22:53 <nn2> on an example to
14:22:54 <nn2> !
14:25:06 <nn2> surtive made me think you could make it in haskell since you said it was so high level
14:25:18 <SamB> yeah, I'm sure
14:25:29 <SamB> just got a bit side tracked with this RNG Compact thing
14:26:16 <nn2> so that means you can do it!
14:26:22 <SamB> though I'm not sure how well the Windows part would work out
14:26:52 <nn2> who cares about windows!
14:27:11 <SamB> not I, really.
14:27:28 <nn2> as long as it wont use kde and dosen't crash ilke the gtk one
14:27:46 <SamB> it certainly won't crash *that* way
14:28:08 <nn2> good
14:28:14 <ndm> nn2, me :)
14:28:48 <SamB> ndm: you get to port it, then ;-)
14:29:16 <ndm> SamB, what are you trying to do?
14:29:26 <ndm> if you are using Haskell, you're stuff shouldn't need porting :)
14:29:29 <SamB> a monopd client
14:29:33 <SamB> with a GUI
14:29:50 <nn2> that wont Crash!!!
14:30:01 <nn2> like the gtk one
14:30:12 <nn2> ** amoying
14:30:14 <ndm> monopd?
14:30:24 <nn2> monoploy server
14:30:39 <SamB> only spelled correctly
14:30:40 <nn2> that is actually editable
14:30:58 <ndm> if you use Haskell, it shoudln't need porting
14:31:04 <ndm> not that hard to write portable haskell!
14:31:23 <SamB> well, what I meant was, you can figure out how to get the GUI to work on windows ;-)
14:31:23 <bolrod> possibly
14:31:43 <mux> I think there are wxgtk bindings for haskell
14:31:54 <SamB> true, I could use wxHaskell
14:31:55 <nn2> has been done before
14:31:55 <mux> and wxgtk is cross-platform (unix, windows, mac os x)
14:32:08 <bolrod> wxgtk?
14:32:11 <bolrod> O_o
14:32:17 <bolrod> gtk2hs  and wxHaskell ther eis
14:32:20 <bolrod> there is*
14:32:21 <SamB> its called wxWindows or wxWidgets, though, not wxGTK
14:32:30 <SamB> wxGTK is just the GTK port
14:32:34 <mux> yeah, wxHaskell is bindings for wxGTK
14:32:43 <monochrom> Someone married gtk2hs to wxHaskell
14:32:50 <dcoutts> ?!
14:32:50 <SamB> what in the ?
14:32:50 <lambdabot> Maybe you meant: . v
14:32:59 <nn2> cool this could work on mac to?
14:33:01 <monochrom> . v
14:33:21 <SamB> does wx work well on Mac?
14:33:22 <dcoutts> nn2, both Gtk2Hs and wxHaskell work on Mac, Windown & Linux
14:33:24 <ihope> @.
14:33:24 <lambdabot> Not enough arguments to @.
14:33:34 <ihope> But 
14:33:45 <SamB> dcoutts: I heard that Gtk2Hs was a royal pain on Windows
14:33:45 <ihope> But @ doesn't take any arguments!
14:33:50 <nn2> this is sounding better every minute
14:34:15 <nn2> lol
14:34:15 <dcoutts> SamB, really?
14:34:16 <SamB> and, like, you actually have to use windows to build programs with it!
14:34:29 <SamB> dcoutts: maybe it is better than when I last heard?
14:34:29 <bolrod> @. = compose ?
14:34:30 <lambdabot> compose module failed: Parse error: "="
14:34:35 <bolrod> @. elite eval
14:34:36 <lambdabot> compose module failed: Parse error: "eval"
14:34:43 <bolrod> HM!?
14:34:43 <Forgacius> gtk2hs?
14:34:46 <bolrod> @eval
14:34:46 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
14:34:50 <Forgacius> um ghs is the usual win vers right?
14:34:54 <dcoutts> SamB, Gtk2Hs does actually have an installer for Windows, unlike wxHaskell which has a .bat file
14:34:59 <Forgacius> and VHS if you got Visual studio
14:35:05 <nn2> um sam the last i heard you haven't got an xp yet is that correct
14:35:16 <SamB> an XP?
14:35:25 <vincenz> SamB_XP
14:35:26 <nn2> think you still use 98
14:35:32 <Forgacius> oh IC your a *nix developer in gtk trying to port to XP?
14:35:34 <Forgacius> hmm
14:35:42 <nn2> o ya
14:35:43 <SamB> I have XP! I have no GHC on it, yet, though
14:35:53 <Forgacius> I dunno anything about *nix...
14:35:54 <SamB> In fact, I don't think I have room for GHC on it
14:35:59 <Forgacius> SamB get it!
14:36:01 <nn2> well that is solved 
14:36:05 <Forgacius> buy another HDD
14:36:13 <Forgacius> or burn some stuff off
14:36:18 <SamB> Forgacius: you will send me moneys?
14:36:22 * monochrom hacks into SamB's windows, deletes all the games, and installs ghc
14:36:27 <ndm> or just install Hugs :)
14:36:28 <SamB> haha
14:36:30 <Forgacius> SamB no
14:36:37 <ndm> even MinHugs, 2Mb installed
14:37:01 * Forgacius hacks into monochrom pc while he's hacking SamB's and formats all his storage
14:37:05 <SamB> monochrom: maybe you should just delete my Ranma episodes
14:37:17 <Forgacius> rofl Ranma! what you got that for?
14:37:28 <nn2> u sam i got a fiew 2 GB hd's you could use
14:37:30 <Forgacius> isn't that old Jap anime or something? or some fight game?
14:37:37 <nn2> ** keep
14:37:37 <SamB> 'cause I have bad taste in anime?
14:37:46 <SamB> anyway, who cares if it is old!
14:37:46 <bolrod> wait.. you have windows XP and no room for GHC?
14:37:47 <monochrom> Oh, Ranma must be preserved.  But put them on DVDs.
14:37:50 <nn2> dont use them
14:37:50 <Forgacius> that had some panda bear or something as a character (I guess its like Tekken that way)
14:38:07 <ndm> use JDiskReporter
14:38:12 <ndm> @google JGoodies JDisk
14:38:13 <nn2> just siting around 
14:38:14 <lambdabot> http://www.jgoodies.com/freeware/jdiskreport/
14:38:23 <Sentinel> > fst ("c++", "haskell")
14:38:24 <lambdabot>  "c++"
14:38:32 <nn2> have been wondering how to use them
14:38:32 <Forgacius> I've never seen it so I guess I wouldn't know I just didn't realize it was that good
14:38:46 <SamB> anyway, if it is so easy to port, maybe I should start writing it?
14:39:11 <bolrod> the best way to run Windows XP is in qemu (or vmware for that matter) ;)
14:39:23 * SamB wonders which toolkit would make the monopoly board easier
14:39:25 <nn2> teach me 
14:39:26 <bolrod> which will be running on linux.. or something other then windows :)
14:39:27 <Forgacius> hmm thats a good note to remember if I'm building another language always put a 'Language <<insert ActiveX or Development environment language here>>' literal in the BNF
14:39:27 <monochrom> what's the q in qemu?
14:39:33 <nn2> i will help
14:39:43 <Forgacius> questionable?
14:39:46 <monochrom> SamB: I think there is no difference.
14:40:02 <bolrod> monochrom: I don't know :P
14:40:03 <Forgacius> (ie, aren't most emulators questionable?)
14:40:08 <bolrod> it's just a processor emulator
14:40:09 <SamB> well, in the middle of the board is supposed to be a dialog box/log area
14:40:59 <nn2> you dont have to copy alantik -- just make it a text box
14:41:02 <SamB> monochrom: qemu stitches together pieces of machine code rather than running through a switchloop all the time
14:41:28 <SamB> well, where do you think I *should* put the dialog thingy?
14:41:57 <nn2> new dragable window
14:42:06 <SamB> that would be annoying!
14:42:36 <nn2> well then the user would decide
14:42:57 <nn2> usefull when you have 2 screens in windows
14:43:18 <nn2> although you are right it would be anoying
14:43:20 <SamB> well, it shouldn't be that hard to change later
14:43:34 <SamB> the point is, you have *some* sort of gui widget smack in the middle of the board
14:43:51 <SamB> and around the edges, the properties
14:43:56 <nn2> humm
14:44:18 <nn2> ah put it to the right
14:44:38 <SamB> and waste the space in the middle of the board?
14:44:45 <nn2> boxthingy || board
14:45:08 <nn2> well then put it in the middle !
14:46:54 <vincenz> any haskell-cafe posters?
14:47:08 <nn2> if there is one thing that i hate about alantik is the pop up traiding windows which eventuall get lost
14:47:23 <SamB> oh?
14:47:49 * SamB wonders how to structure the app...
14:48:49 <nn2> put that stuff in one side barr and that would help so mutch then under that on the bottom part put the chat
14:49:18 <ndm> vincenz: i occasionally post
14:49:41 <ndm> (and last did so in the last hour)
14:49:48 <vincenz> ndm: what do you consider to be a decent waiting time to repost
14:49:51 * nn2 will put up a ** image of what i think window should look like
14:49:55 <monochrom> You can easily put the text entry in the centre of the board.
14:50:00 <ndm> vincenz: has no one answered?
14:50:00 <vincenz> ndm: I forgot to put a subject on my message...and I'm afraid it's being brushed over
14:50:04 <vincenz> ndm: nope
14:50:04 <vincenz> ndm: http://www.haskell.org/pipermail/haskell-cafe/2006-May/015860.html
14:50:11 <vincenz> it concerns existentials
14:50:35 <ndm> I saw "I realize I need existentials for this" and skipped it, since i know nothing about existentials
14:50:53 <vincenz> ndm: I'm afraid that without the lack of a juicier title, I won't draw oleg's eye
14:51:13 <ndm> vincenz: perhaps cc oleg, although i beleive he's out of town for a week
14:51:18 <vincenz> ah
14:51:26 <vincenz> ndm: do you think the mail is well formulated?
14:51:30 <SamB> monochrom: how?
14:51:36 <vincenz> I realize I wasn't quite clear in what I wanted and that might have transferred to the mail
14:51:54 <ndm> vincenz: not particularly, get straight to the point - you hvae some code that gives a compile time error and you don't think it should?
14:52:27 <vincenz> ndm: it's more of a "how would I do this"
14:52:34 <ndm> and perhaps start with just a clear and short example, I didn't follow the "Foo" paragraph
14:52:37 <vincenz> the compile error being my current point in exploration where I broke
14:52:47 <vincenz> alright
14:52:51 <vincenz> I'll wait a few more days
14:52:55 <vincenz> then rewrite it
14:53:03 <vincenz> it just wasn't clear in my mind, which makes it obviously unclear to the reader
14:53:05 <monochrom> Depends on the rest of the board.  But generally, don't you just create text entry box, add it to the container widget that represents the board, and position it to your liking?  I mean, just like putting anything else on the board...
14:53:08 <ndm> a few days is fine to repost, if you change it quite a bit
14:53:14 <ndm> but i'd wait a week for oleg reasons
14:53:17 * vincenz wishes he could go to ICFP :(
14:53:23 * ndm wishes too
14:53:31 <vincenz> I'll never go there :(
14:53:37 <SamB> monochrom: I'm not sure what kind of container widget to use for the board...
14:53:47 * vincenz does phd in a different field, DATE and DAC iso ICFP,  TODAES iso TOPLAS
14:54:02 <monochrom> If you will not need to rotate the board, use some kind of grid.
14:54:03 <ndm> I went last year, so I can't complain
14:54:30 <Igloo> I went last year too, but I complain anyway
14:54:40 <ndm> it was really good fun, a bit too much "wacky types" for my liking, but still fun
14:54:48 <vincenz> Igloo: yeah the things is that I can't publish @icfp, so I can't attend it 
14:54:53 <vincenz> :/
14:54:55 <monochrom> How about this.  3x3 grid.  The 8 cells near the borders are for the squares.  The central square is available for other uses.
14:55:06 <Igloo> vincenz: You don't need to publish to go
14:55:19 <ndm> Igloo: if you are a phd student and want funding, you do
14:55:21 <vincenz> Igloo: sure.. I'll shell out 2500 euros to fly there from europe
14:55:31 <vincenz> what ndm said
14:55:58 <ndm> I submitted to TFP last year, which was colocated, so could stay for ICFP and HW
14:56:12 <vincenz> ndm: well I don't work in PL research but design automation
14:56:19 <vincenz> although I work nearly at the boundary I must say
14:56:31 <vincenz> (most csy of the entire research institute I'm at (which is like 1500 people))
14:56:32 <Igloo> vincenz: You know it's in Europe every other year, right?
14:56:38 <vincenz> Igloo: ooh :)
14:56:54 * SamB messes with Glade...
14:56:54 <ndm> I hope to go next year, am already aiming for an ICFP paper for then :)
14:56:57 <vincenz> Igloo: still next year I'll be in my last year
14:57:12 <vincenz> well by the summer at least
14:57:24 <monochrom> Yeah I was going to say "do it in Glade"
14:57:36 <vincenz> ndm: going for toplas?
14:57:52 <ndm> vincenz: nope
14:57:55 <vincenz> or is a journal not a requirement?
14:58:30 <vincenz> (except that in your field icfp and pldi papers border on journalcomplexity)
14:58:31 <ndm> i can aim for journals, i have a few papers drafted which i might send to journals
14:58:34 <vincenz> well maybe not icfp
14:58:37 <vincenz> butnot pldf
14:58:37 <vincenz> pldi
14:58:44 <vincenz> ah
14:59:06 * vincenz is talking garbled (tired)
14:59:16 <ndm> unfortunately my english isn't great, so it takes forever to go from draft (which the technical details) to a paper someone could read
14:59:31 <vincenz> yeah but in your field papers tend to be longer rigt?
14:59:41 <vincenz> DAC and DATE are 6 page double column
14:59:59 <vincenz> mostly what, related work, central algorithm, results
15:00:12 <vincenz> and then you make a journal for something like todaes (which is the toplas equivalent)
15:00:12 <pejo> ndm, aren't you a native speaker?
15:00:26 <ndm> pejo: yep, but english is still hard!
15:00:41 <pejo> ndm, I totally agree!
15:00:43 <ndm> its usually around 10-12 pages, but i often have to cut down my work :(
15:00:53 <vincenz> yeah cutting is horrible
15:01:02 <vincenz> the first part is always the references
15:01:05 <vincenz> x and y and z
15:01:06 <vincenz> X et al
15:01:08 <ndm> pejo: in my experience, Germans are usually much better at English - they get taught in a more tehcnical precise way
15:01:23 <ndm> vincenz: when they have given you a bib style, you can't do that...
15:01:26 <SamB> monochrom: so how do I make the board square?
15:01:48 <vincenz> ndm: http://www.notvincenz.com/wiki/pmwiki.php/Main/Professional
15:02:12 <pejo> ndm, heh. I have no opinion about that, but you're probably right.
15:02:23 * vincenz notices one of his bibs is flawed
15:02:35 <monochrom> If you want the board to be absolutely square, hardcode its dimensions.
15:02:38 <nn2> ok sam posting immage
15:03:00 * vincenz &
15:03:23 <monochrom> Or by square you mean the landing positions on the board...
15:04:01 <SamB> ?
15:05:29 <nn2> http://srv256.homelinux.net:5190/dbg/
15:08:07 <nn2> sam is that a good lay out
15:08:09 <nn2> ??
15:08:10 <lambdabot> Maybe you meant: . v
15:08:16 <SamB> I guess so
15:09:03 <nn2> use traid window at the beginning to show users currently on
15:10:11 <nn2> and game window to creat new game and options before begining
15:11:52 <nn2> i hope to see the latest posable source verson on you part websight soon!
15:12:02 <nn2> cant wate to try it
15:12:04 <nn2> !!
15:13:21 <nn2> ps used it threw tel net last night and just 1/18 of the game made up 15 pages of coad!
15:22:43 <lisppaste2> gregb annotated #20322 with "Here's what I was originally looking for" at http://paste.lisp.org/display/20322#2
15:24:22 <SamB> how do you use ssh-agent?
15:27:21 <dreamEye> Hi,
15:27:37 <dreamEye> do you know any AOP extension for Haskell?
15:28:19 <dreamEye> are you there?
15:28:30 <SamB> who, me?
15:28:44 <pejo> SamB, eval `ssh-agent ./.xinitrc2`
15:28:57 <dreamEye> Im not alone
15:28:58 <pejo> SamB, that was what I had in .xsession. Running tcsh as login shell.
15:29:13 <pejo> SamB, then ssh-add < /dev/null
15:29:19 <pejo> SamB, in .xinitrc2. 
15:29:27 <dreamEye> no Aspect Oriented Programming for haskell?
15:29:52 <SamB> dreamEye: I don't understand AOP, but Haskell may be good at that sort of thing...
15:30:21 <dreamEye> I dont understand the insides of AOP too
15:30:36 <dreamEye> but I know that it can shorten developments a lot
15:30:53 <dreamEye> by hiding many tedious lines of code
15:31:17 <dreamEye> so this is a greath notice for a practical programmer
15:31:28 <SamB> well, with Haskell, you might not even have to write them in the first place... or is that what AOP is supposed to do, too?
15:32:37 <dreamEye> it can help even with Haskell
15:32:52 <dreamEye> for example, you can hide tedious Maybe checkings
15:33:46 <dreamEye> but also permission checks on every file access, closing files already read ..etc
15:34:27 <dreamEye> I read an article that mention a AOP extension for haskell aspectH:
15:34:52 <dreamEye> http://www.cin.ufpe.br/~alms/pdf/AOPHaskell_camera_ready.pdf
15:34:59 <dreamEye> sorry, portuguese
15:35:12 <dreamEye> but I can not find the code
15:35:58 <SamB> but the operating system already checks permissions on every file access
15:36:21 <monochrom> "hide tedious Maybe checkings" sounds like a monad.
15:36:37 <SamB> yes indeed
15:36:45 <dreamEye> but you must implement the logic for: if I dont have permissions then ask for new user/password..... and so on
15:36:52 <monochrom> "logging" sounds like a writer monad
15:37:04 <dreamEye> there are other articles that relates Monads to AOP
15:37:22 <dreamEye> but there are no definitive general implementation
15:37:31 <monochrom> I think I can concort a monad for every AOP example.
15:38:03 <monochrom> Hey, side effects are aspects too!
15:38:22 <monochrom> Hell, aspects are side effects as well!
15:38:43 <dreamEye> so a little more syntactic sugar that generalize Monad usage for AOP is the rigth thing
15:38:59 <monochrom> I think I now finally understand AOP.  It's all about adding more and more side effects.
15:39:02 <pejo> mono, which you don't know are there, since they usually reside in some separate source file or similar. 
15:39:19 <dreamEye> real programming is about side effects
15:39:32 <SamB> so, isn't ssh-agent supposed to remember passwords that you just entered?
15:40:04 <pejo> SamB, only for the keys you added?
15:40:16 <SamB> oh, keys?
15:40:23 <monochrom> Sounds like real programming is about writing the main program as "main = return ()" and magic happens.
15:40:33 <SamB> what sort of a key do I need to add?
15:40:46 <stepcut> SamB: you have to do a ssh-add for it to remember
15:41:10 <dreamEye> the paper I mention can be used to shorten monadic code too
15:41:11 <stepcut> SamB: you can probably just run ssh-add with no args, an it will do the right thing
15:41:20 <pejo> SamB, the ones generated with ssh-keygen(1)
15:41:36 <dreamEye> well, I have a llittle more information. I have to leave. Thanks
15:42:50 <SamB> seems complicated...
15:42:57 <stepcut> SamB: ssh-agent only remembers the password you explicitly ask it to (and only until ssh-agent is restarted). 
15:42:58 <ndm> does anyone no about FPS, in particular the difference between head and unsafeHead?
15:43:10 <monochrom> There is no definitive definition of AOP to begin with.
15:43:14 <ndm> dons, dcoutts, of course i mean Data.ByteString now :)
15:43:27 <stepcut> ndm: it mentions the difference in the haddock docs --
15:43:36 <SamB> unsafeHead probably can return a string of length -1
15:43:44 <dcoutts> ndm, one is safe, one isn't :-)
15:43:45 <SamB> er.
15:43:54 <ndm> so what does head return on an empty list?
15:43:55 <SamB> probably doesn't check that the string has a character in it
15:43:58 <ndm> head: Extract the first element of a ByteString, which must be non-empty.
15:44:01 <dcoutts> ndm, you can' use unsafeHead on an empty string
15:44:14 <ndm> but you can't use head on an empty string?
15:44:23 * SamB is overheated
15:44:31 <ndm> oh, so unsafeHead is just head, without the basic check
15:44:38 <ndm> so head x | null x = error
15:44:45 <ndm> unsafeHead x | null x = blow up
15:44:47 <SamB> nn2: oh, I pushed some patches, you can "darcs get" that repo if you want to mess with it
15:44:50 <ndm> is that right?
15:44:59 <SamB> one patch is a partial GUI in Glade
15:45:01 <lispy> @pl \(x,y) = y, x
15:45:01 <lambdabot> (line 1, column 8):
15:45:01 <lambdabot> unexpected "="
15:45:01 <lambdabot> expecting operator, pattern or "->"
15:45:07 <stepcut> ndm: yes
15:45:08 <lispy> @pl \(x,y) -> y, x
15:45:08 <lambdabot> (line 1, column 12):
15:45:08 <lambdabot> unexpected ","
15:45:08 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
15:45:14 <SamB> you'd need to install glade to look at it properly
15:45:24 <stepcut> ndm: unsafeHead (PS x s _) = inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p s
15:45:29 <ndm> stepcut: cool
15:45:47 <ndm> I'm just thinking for my pattern match checker, what the semantics are
15:46:07 <ndm> and the semantics of unsafeHead is the same as head, its just the implementation is more like a stick of dynamite
15:46:35 <SamB> ndm: true!
15:46:36 <stepcut> well, unsafeHead may actually return a result -- it will just be whatever happen to be at the pointer
15:47:04 <ndm> yes, but it would be a bad idea to use that pointer, so its probably best (from a static analysis point of view) to treat it as an error
15:47:05 <stepcut> head has well defined behavior for an empty list
15:47:16 <SamB_XP> stepcut: but I bet that the Report doesn't say what has to happen when something returns bottom!
15:47:36 <ndm> the report doesn't differentiate between _|_ non-termination and pattern match
15:47:43 <ndm> so a valid haskell implementation can loop forever on head []
15:47:55 <ndm> it just can't return a result
15:48:12 <stepcut> hrm
15:48:32 <SamB_XP> does it exclude segfault or crazy behaviour from the possible things that might happen if you try to use _|_?
15:48:44 <ndm> I don;t think so
15:49:06 <ndm> I think it would be rather unusual for a haskell program to initiate nuclear war on _|_, but i don't think its specifically excluded
15:49:10 <Igloo> ndm: Hmm, the prelude in the report says "-- error stops execution and displays an error message"
15:49:36 <SamB_XP> well, that is just for "error", I suppose
15:49:39 <ndm> Igloo: ok, my bad then :)
15:49:48 <monochrom> yeah, but does head[] have to be "error"?
15:49:49 <ndm> pattern match errors are defined in terms of error, I beleive
15:49:49 <SamB_XP> which is a specific function
15:49:49 <Igloo> SamB_XP: But head [] is defined in terms of error
15:49:53 <stepcut> then I change my statement to 'head is well behaved for empty lists'
15:50:14 <stepcut> whereas unsafeHead may actually return something
15:50:21 <int-e> SamB_XP: heh. pure code can't tell the difference.
15:50:26 <SamB_XP> its all _|_, though, isn't it?
15:50:34 <ndm> Igloo: i had only looked through the body, doh - typical of haskell people to put it in as a comment...
15:51:09 <ndm> SamB_XP: haskell 98, yes, but newer versions have exceptions (Hugs/GHC)
15:51:17 <ndm> and there is a paper on detecting bottoms
15:51:27 <int-e> Haskell, whether your computer crashes or the earth explodes, it's all the same to us.
15:51:46 <monochrom> haha
15:52:05 <SamB_XP> getting the earth to explode is not easy!
15:52:21 * int-e returns to building his doom machine in C.
15:52:48 <int-e> (nah, it's really just a little number crunching program)
15:52:59 <SamB_XP> C doesn't know the difference, either! unless you use defined behaviour!
15:53:33 <monochrom> or undefined behaviour.
15:54:09 <SamB_XP> and last I checked, there was no library function for either of those things
15:54:38 <int-e> well, invoking undefined behaviour can do anything.
15:54:55 <ndm> SamB_XP: and i suspect the people who did write those libraries kept them private
15:55:07 <SamB_XP> yes, I'm well aware
15:55:08 <int-e> like, comparing two pointers that came from two different calls to malloc().
15:55:17 <SamB_XP> ndm: I meant, in the standard library
15:55:54 <int-e> (if that's wrong, I'd love to be corrected but my reading of the c99 draft is that this is indeed undefined behaviour.)
15:56:29 <SamB_XP> for equality?
15:57:01 <int-e> for anything
15:57:13 <int-e> equality, too.
15:57:54 <SamB_XP> wierd!
15:58:15 <SamB_XP> I don't care if it doesn't work in 16-bit DOS, you ISO nincompoops!
15:58:49 <int-e> or weird DSPs with multiple data areas.
15:59:04 <SamB_XP> or that, yeah, I know, its always either DOS or DSPs
15:59:14 <int-e> But it doesn't even specify that the program continues to run with *some* result ...
15:59:26 <SamB_XP> nope
15:59:29 <SamB_XP> but it will!
15:59:35 <int-e> hopefully :)
15:59:54 <SamB_XP> unless you have a very picky implementation that likes to get on your case for any UB whatsoever!
16:01:32 <monochrom> I think it's moot to be literal with interpreting the C standards.
16:02:17 <monochrom> It's written in street-people English.  It could mean anything to anyone.
16:02:35 <SamB_XP> why is it written in street-people english, anyway?
16:02:48 <int-e> Someone should make a doomsday C that at least deletes the contents of all reachable hard disks when a program encounters undefined behaviour, and then force the ISO working group 14 members to use it for all their coding.
16:03:21 <monochrom> Because it is written by street-people programmers.
16:03:25 <SamB_XP> um, but how would they fix the standard if it got deleted?
16:03:49 <int-e> hmm.
16:03:54 <int-e> would that be too bad a fix?
16:04:14 <monochrom> I am not sure the group will like it.
16:04:24 <SamB_XP> hahahaha
16:04:34 <SamB_XP> "not sure the group will like it"
16:06:08 <monochrom> err, how is that funny? (although I am happy enough if you laugh)
16:06:37 <int-e> It's worded very carefully.
16:06:45 <SamB_XP> well, because the idea is that the group would *not* like it
16:07:59 <monochrom> haha ok I see.
16:08:05 <Pseudonym> One of these days I'm going to try to get a nasal demon driver into the Linux tree.
16:08:17 <SamB_XP> huh?
16:08:46 <Pseudonym> http://www.cliki.net/Nasal%20Demons
16:08:58 <Pseudonym> Oh, it's also here:
16:09:04 <Pseudonym> @jargon nasal demons
16:09:06 <lambdabot> No match for "nasal".
16:09:06 <lambdabot> No match for "demons".
16:09:10 <Pseudonym> @jargon "nasal demons"
16:09:11 <lambdabot> *** "nasal demons" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:09:12 <lambdabot> nasal demons n. Recognized shorthand on the Usenet group comp.std.c for
16:09:12 <lambdabot>  any unexpected behavior of a C compiler on encountering an undefined
16:09:12 <lambdabot>  construct. During a discussion on that group in early 1992, a regular
16:09:12 <lambdabot>  remarked "When the compiler encounters [a given undefined construct] it
16:09:13 <lambdabot> [5 @more lines]
16:09:19 <Pseudonym> @more
16:09:20 <lambdabot>  is legal for it to make demons fly out of your nose" (the implication is
16:09:20 <lambdabot>  that the compiler may choose any arbitrarily bizarre way to interpret
16:09:20 <lambdabot>  the code without violating the ANSI C standard). Someone else followed
16:09:21 <lambdabot>  up with a reference to "nasal demons", which quickly became established.
16:09:23 <lambdabot>  
16:09:34 <monochrom> They are not exactly precise people. (If they were, you wouldn't get a mess.)  If you submit the hard disk formatting implementation, they'll just say "you know what I mean" and consider you a crazy guy.
16:10:11 <johnnowak> perhaps I am the only one here that likes C?
16:10:23 <Pseudonym> Hugs is written in C.
16:10:26 <Pseudonym> So it's not all bad.
16:10:38 <SamB_XP> @quote me
16:10:38 <lambdabot> me hasn't said anything memorable
16:10:41 <ndm> Pseudonym: i can only assume you haven't read the Hugs source code
16:10:48 <Pseudonym> Good point.
16:10:48 <int-e>        [#2]  NOTE  Possible undefined behavior ranges from ignoring
16:10:49 <int-e>        the situation  completely  with  unpredictable  results,  to
16:10:49 <int-e>        behaving  during  translation  or  program  execution  in  a
16:10:49 <int-e>        documented manner characteristic of the environment (with or
16:10:49 <int-e>        without   the   issuance   of   a  diagnostic  message),  to
16:10:49 <int-e>        terminating a translation or execution (with the issuance of
16:10:51 <int-e>        a diagnostic message).
16:10:56 <SamB_XP> @quote SamB 
16:10:56 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
16:11:15 <int-e> So as long as I document the formatting behaviour I believe I'm on the safe side ;)
16:11:37 <SamB_XP> oooh good, right on the first try ;-)
16:11:55 <monochrom> You should try. I'm pessimistic.
16:12:15 <johnnowak> You can be sure what things do, provided you stay within a subset of all possible actions. The fact that C doesn't do much checking and hence has a lot of undefined behaviour when you abuse the system is ultimately a good thing considering its goals, no?
16:12:25 <SamB_XP> int-e: of course, making them use it might violate the geneva convention
16:12:27 <Pseudonym> Oh, in fact, the hard-drive-formatting semantics was anticipated since 1992 at least:
16:12:33 <Pseudonym> http://groups.google.com/group/comp.std.c/msg/dfe1ef367547684b?hl=en
16:12:58 <int-e> SamB_XP: Dangit. I guess I'll pursue other projects then.
16:12:59 <monochrom> Consider this.  A mathematician once complained me of interpreting English as though I'm a computer parser.  A mathematician.
16:13:12 <Pseudonym> Good heavens.
16:13:25 <SamB_XP> monochrom: haha
16:13:41 <Pseudonym> Though it'd be nice to start a Haskell function with "assume, without loss of generality..."
16:14:02 <Pseudonym> That'd be close to DWIM semantics.
16:14:53 <Pseudonym> johnnowak, actually, I'm not knocking C.  There are certain low-level tasks and very underpowered platforms for which it's still the best solution.
16:14:59 <int-e> > let (...) = enumFromTo in 1 ... 2
16:15:00 <lambdabot>  [1,2]
16:15:41 <int-e> Pseudonym: sure, but you don't write platform-independent Code in that case
16:15:41 <Pseudonym> But in most modern user-space systems, C++ is almost always more appropriate.
16:15:47 <Pseudonym> Even if you only use C++ as a better C.
16:15:49 <johnnowak> Pseudonym: Fair enough then. My main interest in C is actually using it to develop new languages. 
16:15:56 <Pseudonym> That's wonderful!
16:16:00 <Pseudonym> In that case, use C!
16:16:02 <Pseudonym> :-)
16:16:07 <Pseudonym> New languages are good.
16:16:30 <SamB_XP> why would you want to develop a language in C?
16:16:32 <johnnowak> And developing them is a great way to avoid doing useful work.
16:16:48 <int-e> C++ *is* my favourite high-level assembler at the moment; I use templates for generating nested loops :)
16:16:54 <petekaz> Is there any haskell available for Intel Macs yet?
16:16:56 <Pseudonym> int-e: You're right, but you can write portable code without writing 100% platform-independent code.
16:17:03 <johnnowak> SamB_XP: for purposes of reasonable efficiency
16:17:06 <Pseudonym> Even in C.
16:17:18 <Pseudonym> Those ifdefs don't write themselves.
16:17:37 <int-e> anyway. enough C bashing for me. I actually like the language, despite all deficits. Luckily compiler writers tend to be sensible people.
16:17:44 <ndm> petekaz: i bet you can port Yhc in 10 minutes
16:17:59 <Pseudonym> Mind you, I'd sooner write the run-time system in C than the compiler.
16:18:10 <Pseudonym> And I'd sooner compile to C than to assembler.
16:18:13 <anonfunc> petekaz: Hugs is available as well.
16:18:22 <petekaz> thanks ...
16:18:25 <SamB_XP> yes!
16:18:25 <SamB_XP> yes!
16:18:37 <petekaz> just got a new macbook, looking to put stuff on it.
16:18:45 <Pseudonym> Anyway, caffeine.  BBS
16:18:58 <johnnowak> petekaz: Congrats. Considering one myself to replace the Powerbook.
16:19:14 <petekaz> I'm really dying to try the new erlang that supports multiple processors ...
16:19:21 <anonfunc> It's very nice, but lacking in alternative language support. :-P
16:19:25 <petekaz> johnnowak: I gave my wife the old powerbook.
16:19:54 <johnnowak> petekaz: Ah. I can't even quite afford the Macbook even if I were to sell the powerbook. :-)
16:20:08 <petekaz> you a student?
16:20:14 <johnnowak> petekaz: yes
16:20:42 <johnnowak> at parsons in nyc.
16:20:43 <petekaz> I was a student 11 years ago.
16:20:56 <petekaz> (so money is not a problem like it used to be)
16:21:22 <johnnowak> mm, yes... i'm stuck trying to find the best values on rice at the moment.
16:21:29 <petekaz> haha
16:22:14 <johnnowak> when these new intel machines came out, the value of my laptop dropped $300 instantly... nuts. i may sell it and put together a box instead of the macbook... perhaps i don't need all this mobility...
16:22:17 <int-e> > scanl lcm 1 [1..16]
16:22:18 <lambdabot>  [1,1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720]
16:23:12 <johnnowak> this is my first time in here: out of curiosity, what percentage of you also use scheme or have used it in the past?
16:23:50 <petekaz> I use scheme now (reading SICP for fun)
16:24:19 <petekaz> And I use Common Lisp as well
16:24:21 <johnnowak> same here. just finished up HtDP, which while slow imparted a few interesting things nonetheless 
16:24:29 * int-e has had very little scheme exposure. A few days back in school and a little script-fu (gimp). Nothing serious.
16:24:31 <ihope> So should I actually do something sometime?
16:25:05 <ihope> > let fibs = scanl' (+) (0:fibs) in take 10 fibs
16:25:05 <lambdabot>  Not in scope: `scanl''
16:25:11 <ihope> > let fibs = scanl (+) (0:fibs) in take 10 fibs
16:25:11 <lambdabot>  Couldn't match `[a]' against `[b] -> [b]'
16:25:16 <ihope> Eh.
16:25:28 <int-e> > let fibs = 1:scanl (+) 1 fibs in take 10 fibs
16:25:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
16:25:29 <SamB_XP> fold of some kind?
16:25:34 <SamB_XP> no?
16:25:52 <johnnowak> just getting into haskell now. the syntax so far is throwing me for a loop. i'm not writing nearly enough parenthesis. :-) I'm sure i'll get used to it though.
16:25:59 <petekaz> johnnowak: why are you learning haskell?  for a class?  or for self-study?
16:26:24 <johnnowak> petekaz: just self-study. i go to an art college, so there are no programming classes.
16:26:25 <petekaz> johnnowak: I am also a haskell newbie, going through YAHT for the 2nd time now.
16:26:54 <johnnowak> petekaz: at least, no programming outside of java, php, max, and introductory c++
16:27:04 <ihope> johnnowak: just remember a bit of operator precedence, then consult the fixities when you need to.
16:27:16 <SamB_XP> those first two aren't very artistic at all
16:27:53 <petekaz> johnnowak: no perl, python, or ruby?  
16:28:07 <johnnowak> SamB_XP: java is useful for some things, especially if you use processing (www.processing.org). php is used for doing web stuff... it is more of a design program really.
16:28:15 <johnnowak> petekaz: No, unfortunately. 
16:28:24 <petekaz> It seems to me that very few people from those camps move to something like haskell, scheme, cl, or erlang.
16:28:40 <JohnnyL> PHP: where reusability is not an optn.
16:28:45 <JohnnyL> PHP: where reusability is not an option.
16:28:48 <ihope> CL... what's that?
16:28:54 <petekaz> common lisp
16:28:54 <johnnowak> petekaz: I was programming long before I transferred there. 
16:29:23 <johnnowak> PHP is a mess. I wish they'd teach using Ruby or Python so it would not be so painful to help others with their homework. :)
16:29:41 <johnnowak> Luckily, all such classes are optional.
16:30:10 <petekaz> I started down this path of "esoteric" languages (i.e. functional and the lisps) based on paul graham's writings.
16:30:23 <johnnowak> Just continuing on topic... Has anyone here used Io (www.iolanguage.com)?
16:30:51 <ihope> I take it Io /= Iota.
16:30:55 <johnnowak> i got into scheme as a recommendation for doing music actually... my programming journey initially started to find new ways of doing generative audio/video works
16:31:00 <SamB_XP> I started doing Haskell because exarkun (of #twisted and #haskell fame) had been learning it.
16:31:05 <johnnowak> Yes, Io is not Iota.
16:31:23 <SamB_XP> I later discovered he had lost interest, but by then it was too late -- I was hooked
16:31:36 <johnnowak> At some point, I became more interested in the programming part of my artwork than the artwork itself.
16:31:50 <SamB_XP> er, s/#haskell/#python/
16:31:55 * SamB_XP silly
16:32:40 <johnnowak> Io is really a lovely language. Very clean. Slot and prototype-based OO like Self... no classes.
16:33:52 <SamB_XP> oooooooo... Self...
16:34:09 <ihope> So what's this KealDigit stuff?
16:35:29 <johnnowak> I got into Haskell mainly from rummaging around c2.com and from dealing with darcs.
16:35:30 <SamB_XP> kealdigit?
16:35:35 <SamB_XP> @keal
16:35:35 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
16:35:46 <ihope> @keal
16:35:46 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
16:37:13 <ihope> "can GMP support KealDigit? I invent KealDigit"
16:37:13 <Cale> hehe
16:37:18 <ihope> "with KealDigit quantum crackproof encryption possible"
16:37:47 <Cale> "KealDigit" is essentially non-integer geometric bases.
16:38:00 <Cale> He claims to have invented them
16:38:15 <SamB_XP> it is entirely possible
16:38:17 <ihope> Ah.
16:38:38 <Cale> (Of course he hadn't, they've been around a long time)
16:38:53 <ihope> @google non-integer geometric bases
16:38:55 <lambdabot> http://www.dmmm.uniroma1.it/~rendiconti/rol/keywords.htm
16:38:58 <SamB_XP> haven't you heard of independant inventions?
16:39:01 <SamB_XP> of the same thing?
16:39:05 <ihope> That's not right.
16:40:02 <Cale> Oh, sure
16:40:08 <Cale> in that sense, he probably has
16:40:53 <Cale> By geometric bases, I mean the usual sort for expressing numbers (we use base 10, he's generalising to bases which are not integers)
16:42:17 <dcoutts> dons, I've got some gnuplot and gnumeric charts/graphs. I'm inclined to use gnumeric...
16:42:22 <dcoutts> @localtime dons
16:42:23 <lambdabot> Local time for dons is Wed May 31 09:35:06 2006
16:43:41 <dcoutts> dons, anyway, I've removed Data.ByteString from the base package in my ghc-6.5 installation so I can benchmark more easily now
16:44:01 <dcoutts> I've pretty much repoduced the graph you posted yesterday
16:44:07 <dcoutts> http://haskell.org/~duncan/fps-fusion-v1-v2.png
16:44:31 <dcoutts> that's with gnuplot, but I can't figure out how to put text labels on there
16:47:31 <SamB_XP> hmm, maybe if I uninstalled ubuntu I'd have room for GHC...
16:47:44 <dcoutts> http://haskell.org/~duncan/fps-fusion-v1-v2-map-filter.png
16:48:18 <Igloo> dons: http://www.engadget.com/2005/03/08/how-to-make-your-own-annotated-multimedia-google-map/ and/or http://www.mapbuilder.net/ might be useful
16:48:33 <johnnowak> SamB_XP: Perhaps you could keep ubuntu and uninstall XP?
16:48:56 <SamB_XP> johnnowak: I already have a Debian box!
16:49:13 <SamB_XP> which has GHC already
16:49:22 <johnnowak> SamB_XP: ah. i see. erm.
16:50:32 <Cale> dcoutts: I'm curious about what got worse in v2
16:51:05 <johnnowak> getting ghc to run on openbsd ppc was a pain in the ass.
16:51:06 <dcoutts> Cale, not sure yet, I don't know how much variance there is in the results yet
16:51:16 <dcoutts> Cale, I'm just playing with plotting
16:51:43 <dcoutts> Cale, but we know that using fusion for maximum doesn't always pay off yet, we plan to improve that
16:51:59 <dcoutts> http://haskell.org/~duncan/fps-fusion-v1-v2.png
16:52:20 <Cale> yeah, that's what I was looking at :)
16:52:22 <dcoutts> so in this graph, the ones near the end where we're doing worse are for maximum & minimum
16:52:36 <Cale> and #11?
16:53:15 <dcoutts> because it's hard to beat a tight C loop for max & min
16:53:19 <dcoutts> #11 is "noacc/up"
16:54:14 <dcoutts> which is fold (\_ -> (+1)) 0 . map (+1) . filter (/=110)
17:01:21 <johnnowak> do any alternative syntaxes for haskell exist? namely a consistent prefix notation?
17:01:52 <Cale> johnnowak: Not as far as I know, though you could easily write everything prefix if you really wanted to
17:01:55 <ihope> > (+) 3 2
17:01:56 <lambdabot>  5
17:02:01 <ihope> Stuff like that.
17:02:29 <Cale> It just makes things harder to read though. People would get annoyed at your code :)
17:03:31 <johnnowak> ah, thanks. i'm so used to writing (+ 5 2) in scheme... and in Io, I write in a way that circumvents the precedence rules because  dislike syntactic sugar... hence 5 +(3) *(4) = 32
17:03:50 <Cale> But it is a nice thing that Haskell does adapt to different styles of syntax fairly well.
17:03:56 <johnnowak> but yes, i understand that everyone would hate me :)
17:04:09 <Cale> If you don't like layout sensitivity, you can use braces and semicolons too.
17:04:21 <johnnowak> Cale: I'm fine with that, oddly enough.
17:05:45 * monochrom considers monadic code in prefix, e.g., (>>) x ((>>) y z)
17:06:00 <Cale> basically, the rule is that if you have an infix operator, putting it in parens will turn it into a prefix function, and if you have a prefix function, putting it in `backticks` will make it infix.
17:06:45 <Cale> The difference is entirely a syntactical one, the language treats both the same otherwise.
17:06:45 <johnnowak> does anyone have tips for a scheme programmer trying out haskell? it seems like most of the knowledge i have translates fine, e.g: 1:2:3:[] = '(1 2 3 . '()), but just curious if there are any "gotchas" i should be aware of
17:06:56 <johnnowak> Cale: thanks
17:07:14 <Igloo> What does that . there mean?
17:07:24 <johnnowak> er, nix that second quote
17:07:30 <johnnowak> . is a pair operator
17:07:52 <Philippa> the uber-low-level one, as far as a lisp's concerned
17:08:09 <Pseudonym> The main gotchas are the strong typing and the purity.
17:08:14 <Pseudonym> But they're very strongly related.
17:08:16 <mauke> Igloo: . is how cons cells are printed whose cdr is not a list
17:08:25 <Cale> which is basically '(1 2 3)
17:08:39 <Cale> since dotting with a nil is what's done automatically anyway
17:08:52 <mauke> I have a weird problem
17:08:55 <Pseudonym> The thing you'll probably find most frustrating, johnnowak, is that you need to declare data structures.  Scheme programmers like inventing them in an ad hoc way.
17:09:08 <Pseudonym> And then you need to respect the declarations.
17:09:09 <dons> morning
17:09:21 <Pseudonym> In other words, you need to think a bit harder about how your data is structured.
17:09:31 <Igloo> Hey dons; *points at above URLs*
17:09:37 <Pseudonym> G'day dons.
17:09:47 <Cale> hehe, that was the annoyance I had about lisp, was that it didn't use enough declared data structures, despite seeming to have this capacity
17:09:49 <johnnowak> Pseudonym: Well I'm mainly interested in Haskell because of the strong/static typing and purity. I'm not really of the opinion that dynamic typing is a good thing in a language.
17:09:55 <Cale> (common lisp in this case)
17:10:03 <Pseudonym> I'm of the opinion that it can be pragmatically useful.
17:10:11 <Pseudonym> Haskell does have Data.Dynamic, for example.
17:10:35 <Pseudonym> But I agree that it's better to try to come up with a solution that doesn't rely on it.
17:10:38 <johnnowak> Pseudonym: Yes, it is very nice to have as an option, but I'd prefer to have the safety of static typing by default.
17:10:43 <dons> oh, very interesting graphs
17:10:50 <petekaz> See, I'm the opposite, I've been using dynamically typed languagse for a while and I have a hard time seeing the value of statically typed languagues.
17:10:53 <Cale> Is there anything practical which existential types won't catch?
17:11:06 <mauke> ghc complains: Warning: Module `Control.Monad' is imported, but nothing from it is used
17:11:18 <mauke> the import is: import Control.Monad (liftM, liftM2)
17:11:19 <dons> Igloo: oh, I see a map builder url?
17:11:30 <Cale> mauke: and you're using liftM and liftM2?
17:11:33 <mauke> yes
17:11:39 <johnnowak> petekaz: Removing the overhead of checking type compatibility during runtime seems like a good one to me.
17:11:39 <Cale> odd
17:11:46 <mauke> if I remove the import, it complains about liftM(2) being undeclared
17:11:48 <Igloo> dons: Yup; it was you who was talking about making #haskell google maps, right?
17:12:02 <dons> yep :)
17:12:25 <Igloo> And it claims to give you the code, so should be lock-in free
17:12:33 <Cale> The main benefit to static typing, as far as I'm concerned, is that it's basically having the compiler check for a *lot* of various possible bugs before your program even runs.
17:12:37 <petekaz> johnnowak: I have never hit a performance bottleneck yet. Until you profile, it's not even worth talking about these types of optimizations.
17:12:43 <Cale> So it saves you huge amounts of time debugging.
17:13:05 <dons> Igloo, oh. ok. seems fairly simple too.
17:13:11 <petekaz> Cale: in response to that, if one writes unit tests, which is the fad these days, most of these bugs are caught up front anyways.
17:13:13 <SamB_XP> petekaz: what about the ability to catch stupid or forgetful mistakes in code?
17:13:17 <johnnowak> petekaz: It's not an optimization the programmer has to make. The compiler takes care of it. Why not have it by default?
17:13:36 <Cale> petekaz: But then you have to write all those tests, which the compiler should be able to do anyway.
17:13:40 <Philippa> petekaz: most of != all, sadly
17:13:51 <Cale> And yeah, it's not quite the same.
17:14:06 <Pseudonym> I agree with Cale here.  The time you spend "satisfying the compiler's whims" is time that's ACTUALLY being spent debugging.
17:14:14 <SamB_XP> anyway, Haskell's typing catches a whole lot so I don't even write unit tests yet
17:14:19 <petekaz> I'm obviously not going to convince anyone here of how I don't see the value of the type system.  This is not the reason I am learning haskell though.  I'm more interested in the laziness of it.
17:14:23 <dons> dcoutts: good results!
17:14:28 <petekaz> And the weirdness of monads!
17:14:31 <dcoutts> dons, aye
17:14:31 <Cale> hehe :)
17:14:31 <Pseudonym> The advantage being that it takes less time, AND the compiler even tells you where the bugs are.
17:14:47 <Philippa> tbh, most of the good things about monads are about how they interact with the type system
17:14:48 <SamB_XP> monads are a lot less convenient without the type system!
17:14:57 <dcoutts> dons, I'm just modifying the benchmark prog to do a sequence of runs so we can see how stable the reslts are
17:15:03 <dons> ok. good.
17:15:03 <Philippa> there's still value in a dynamically-typed language in a giving-structure-to-CPS kinda way, but it's not as big
17:15:04 <johnnowak> petekaz: Laziness is probably the thing I'm least interested in. :-) I understand the potential value of it, but I'm waiting for it to bite me.
17:15:16 <petekaz> So far, haskell has been twisting my brain.   I still don't get it yet, but over the next 6 months or so, perhaps it'll sink in.
17:15:26 <Pseudonym> petekaz, I do see the advantage of dynamically typed languages.  But I don't think the advantages outweigh the drawbacks in general programming.
17:15:33 <dons> dcoutts: is that map/filter graph done in gnumeric?
17:15:34 <Pseudonym> As always, it depends what you're doing.
17:15:34 <mauke> wow, my program is a lot faster with -O
17:15:42 <dcoutts> dons, yes
17:15:46 <SamB_XP> mauke: is it really that surprising?
17:15:49 <Cale> mauke: yeah, that's quite common :)
17:15:51 <Pseudonym> mauke: Try -fleave-out-artificial-delays
17:15:54 <dons> yeah, looks good.
17:16:02 <petekaz> All points taken!
17:16:04 <Cale> haha
17:16:08 <dons> Pseudonym: maybe he had -fmake-code-slow turned on?
17:16:08 <johnnowak> Perhaps a good compromise is mzscheme, which is dynamically typed but has optional compile-time soft checking with mr ed
17:16:13 <Pseudonym> Perhaps, yes.
17:16:48 <SamB_XP> johnnowak: I bet it wouldn't catch a lot of the stupid stuff that I have the capacity for...
17:16:51 <Cale> heh, putting artificial delays by default into code generated by ghc would be a funny way to keep Haskell's popularity low
17:16:54 <Pseudonym> Partly, static type checking fits with my development methodology.
17:17:05 <Pseudonym> Agile programming is much harder without it.
17:17:08 <johnnowak> SamB_XP: same here 
17:17:32 <SamB_XP> I say, if you want duck typing, you should have to type Duck
17:17:47 <petekaz> My only real complaints about haskell thus far (my limited understanding of it) are functions like zip3, zip4, etc ... I find that disgusting (erlang has the same thing).
17:17:50 <SamB_XP> |-P
17:18:04 <dons> petekaz: do you use zip3 .. zipN ?
17:18:06 <mauke> petekaz: there's a zipN but it's called transpose
17:18:10 * SamB_XP couldn't find the one with the eyes closed
17:18:13 <dons> i don't think i've used them in the last 3 years
17:18:34 <johnnowak> what is the purpose of them? are they just more optimized for a given N?
17:18:34 <Pseudonym> I more commonly use zip (zip a b) c
17:18:42 <Pseudonym> Or somethign like it.
17:18:49 <SamB_XP> well, usually I would use zip or zipWith
17:18:49 <mauke> johnnowak: they work on different types
17:18:58 <SamB_XP> @type zip
17:18:59 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
17:19:00 <petekaz> I was just speaking in the general case.  liftM1, liftM2, etc .. that style of functions just seems very ugly (at least coming from lisp world)
17:19:01 <SamB_XP> @type zip2
17:19:02 <Pseudonym> Since I generally always use the output of zip in a pattern match.
17:19:02 <lambdabot> Not in scope: `zip2'
17:19:14 <SamB_XP> petekaz: you can code it out longhand if you like
17:19:16 <johnnowak> ah, thanks
17:19:17 <Pseudonym> [ foo | (a,(b,c)) <- zip as (zip bs cs) ]
17:19:18 <Pseudonym> Or something.
17:19:24 <SamB_XP> with ap and return, was it?
17:19:46 <SamB_XP> @type liftM2
17:19:47 <lambdabot> forall r (m :: * -> *) a2 a1.
17:19:47 <lambdabot>     (Monad m) =>
17:19:47 <lambdabot>     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:19:51 <SamB_XP> @type ap
17:19:52 <lambdabot> forall b (m :: * -> *) a.
17:19:52 <lambdabot> (Monad m) =>
17:19:52 <lambdabot> m (a -> b) -> m a -> m b
17:19:55 <SamB_XP> @type return
17:19:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
17:20:25 <dons> dcoutts: so JaffaCake is happy for .Lazy to go in?
17:20:34 <dcoutts> dons, seems so
17:20:47 <johnnowak> sorry for elementary questions,  but: is lazy evaluation commonly useful in practice?
17:20:52 <dcoutts> he sais he didn't see any reason why not
17:20:59 <SamB_XP> @type let liftM2' f x y = return f `ap` x `ap` y
17:21:00 <lambdabot> not an expression: `let liftM2' f x y = return f `ap` x `ap` y'
17:21:05 <dons> cool
17:21:06 <SamB_XP> @type let liftM2' f x y = return f `ap` x `ap` y in liftM2'
17:21:07 <lambdabot> forall a
17:21:07 <lambdabot>                       a1
17:21:07 <lambdabot>                       (m :: * -> *).
17:21:07 <lambdabot>                    (Monad m) =>
17:21:07 <lambdabot>                    (a -> a1 -> b) -> m a -> m a1 -> m b
17:21:09 <dcoutts> dons, and exceptions is the right way to go for lazy io
17:21:11 <Cale> johnnowak: oh, yeah, quite a lot
17:21:19 <petekaz> johnnowak: I'm interested in that answer as well, as it seems that laziness just bites everyone.
17:21:33 <SamB_XP> see, see, I told you you could write them out in longhand!
17:21:33 <Cale> johnnowak: It lets you write code which you couldn't even think to write in a strict language
17:21:37 <dcoutts> dons, he suggested some ways to get fewer layers involved in the lazy io
17:21:56 <petekaz> although I haven't read okasaki's book yet which talks about laziness in detail.
17:22:03 <Cale> johnnowak: By asymptotically improving runtimes in almost every case
17:22:13 <dcoutts> dons, we can bypass the extra copy via the Handle buffer for the lazy hGetContents case
17:22:16 <johnnowak> Cale: Ah, there's a good reason. :-)
17:22:19 <Cale> My favourite simple example is finding a substring
17:22:33 <dcoutts> dons, oh and the current lazy io functions are not safe
17:22:34 <Pseudonym> johnnowak: My favourite nontrivial example is dynamic programming.
17:22:42 * petekaz waits eagerly for Cale
17:22:48 <dcoutts> dons, only hGetContents is safe (or could be made safe)
17:22:50 <Cale> Consider this way:  isSubstringOf x y = any (isPrefixOf x) (tails y)
17:22:51 <Pseudonym> Dynamic programming in Haskell is almost trivial.
17:23:08 <SamB_XP> Pseudonym: it is trivial!
17:23:09 <Sentinel> x.find("y");
17:23:11 <Cale> Think about what that would do in a strict language -- it would be incredibly stupid.
17:23:13 <dcoutts> dons, hmm, let's move to #haskell-overflow
17:23:16 <SamB_XP> except the part where you translate it into maths!
17:23:24 <Pseudonym> SamB_XP: It's not quite trivial.  You need to pick the right container.
17:23:24 <Cale> Sentinel: I'm talking about *implementing* find
17:23:34 <SamB_XP> oh, well, I suppose ;-)
17:23:40 * SamB_XP usually uses an Array
17:23:44 * petekaz remembers Cale showed this to me before
17:23:45 <Pseudonym> http://haskell.org/hawiki/MemoisingCafs <- Good example
17:23:54 <Pseudonym> In that one, I use an INFINITE data structure.
17:23:59 <Pseudonym> For dynamic programming.
17:24:06 <Sentinel> Cale: why draw the line there, tails and isprefixof is probably defined functions in haskell, right?
17:24:12 <Pseudonym> That's seriously fun.
17:24:15 <Cale> Sentinel: sure
17:24:33 <SamB_XP> Sentinel: in libraries, sure
17:24:40 <mauke> hmm, what's the best way to strip trailing whitespace from a string?
17:24:50 <Cale> Sentinel: The point is that we can actually compose these functions which we already have -- we're not starting from scratch and writing nested loops.
17:25:11 <SamB_XP> mauke: reverse . dropWhile isSpace . reverse
17:25:16 <mauke> my current solution is reverse . dropWhile ... what SamB_XP said
17:25:18 <johnnowak> mauke: pointer arithmetic. 
17:25:23 <mauke> johnnowak: haha
17:25:28 <mauke> no.
17:25:36 <AtnNn> do you know of any in depth paper available online on CPS, that uses haskell or a similar language?
17:25:48 <Cale> In a lazy language, this implementation is as smart as the naive one with nested loops and early break tests in an imperative language.
17:25:58 <Pseudonym> AtnNn: Andrew Appel, "Compiling with Continuations"
17:26:03 <Pseudonym> It uses ML.
17:26:07 <Sentinel> Cale: who does, string exists for an example, no need to use char[]
17:26:12 <AtnNn> Pseudonym: thanks
17:26:15 <Cale> Sentinel: hm?
17:26:19 <Pseudonym> Thhat's a book.
17:26:28 <Pseudonym> But any decent university library will have it.
17:27:05 <Cale> The point is that laziness gives you this ability to combine code which is already written in ways that would be unwise to even bother attempting in a strict language.
17:27:10 <Pseudonym> AtnNn: It might not quite be what you're after, but it'll blow your mind.
17:27:16 <Pseudonym> Figuratively speaking.
17:27:49 <SamB_XP> Pseudonym: but not the stack?
17:27:52 <Cale> Another good example -- suppose you're searching for a move in a game tree.
17:27:53 <johnnowak> Cale: Do you find that it ever causes problems for you? I'm used to writing if(A == B || B == C) and always expecting C to be evaluated 
17:28:04 <AtnNn> Pseudonym: i am looking for something to blow my mind
17:28:16 <Pseudonym> Well, that book will do it
17:28:16 <Cale> johnnowak: purity means that I don't have to care about whether anything is evaluated.
17:28:25 <Pseudonym> It might even prompt you to write a toy ML compiler.
17:28:26 <mauke> johnnowak: huh? C doesn't evaluate C if A == B
17:28:37 <johnnowak> Cale: Ah... I suppose you're right. :-)
17:29:07 <johnnowak> mauke: they do if A and B are functions. :-) i meant a(...) == b(...) ... just trying to save screen space
17:29:25 <mauke> that still won't evaluate C if the first part is true
17:29:33 <monochrom> right
17:29:51 <monochrom> || and && are two of the lazy operators in most eager languages
17:29:54 <johnnowak> really? hm. *fumbles*
17:30:06 <Pseudonym> But you try writing a lazy operator|| in C++.
17:30:09 <Cale> Suppose that you're writing a game AI, and you're looking through the tree of moves -- rather than defining a function which generates just the moves up to some depth, it's actually more natural to generate the whole tree, and then prune it.
17:30:39 <monochrom> Yes Cale!
17:30:41 <Cale> Of course, you can't do that without laziness, it would be silly.
17:30:50 <johnnowak> Cale: Yes, that's true.
17:31:33 <SamB_XP> Cale: not just silly, but maybe impossible
17:33:17 <Pseudonym> Lazy lists are also a good substitute for iterators in strict languages.
17:33:18 <monochrom> I use the "separation of concerns" argument to justify that.  Producer and consumer are supposed to be two delineated pieces of code.
17:33:18 <Cale> SamB_XP: right
17:33:18 <SamB_XP> because maybe the game does not have limited length
17:33:18 <Cale> For numerical algorithms, representing iterative computations as lists of (hopefully) improving approximations can also open up lots of techniques.
17:33:18 <Cale> yeah
17:33:18 <monochrom> For an eager language you will have to manually do fusion and deforestation.
17:33:18 <Pseudonym> The "lazy list == iterator" approach is a good example of how lazy evaluation often turns amortised complexity into worst-case complexity.
17:33:18 <Pseudonym> i.e. if the strict algorithm is amortised O(1), then the lazy algorithm is worst-case O(1).
17:33:18 <Pseudonym> That's not true of all algorithms, of course.
17:33:18 <Pseudonym> Oh, here's another example.
17:33:26 <Pseudonym> Quick sort in Haskell is O(n log k).
17:33:42 <Pseudonym> Where k is the amount of the list that you care about.
17:33:51 <Cale> ah, good point
17:34:04 <Pseudonym> So if you only need the minimum value, it's O(n), which is the same complexity as minimum finding.
17:34:19 <mauke> wait, that's awesome
17:34:22 <Pseudonym> Higher constant factor, of course.
17:34:34 <cpatrick> Pseudonym: though in the case of qsort, the constant factors are bad enough in haskell that it's normally quicker to sort the whole thing in C
17:34:37 <Pseudonym> Oh, it's also true of top-down merge sort.
17:34:43 <Pseudonym> cpatrick: Sure.
17:34:50 <Pseudonym> More or less.
17:35:03 <Cale> But that sort of effect also applies to much more complicated algorithms
17:35:05 <Pseudonym> It _is_ quicker to do it in C, but not using the standard qsort().
17:35:09 <SamB_XP> cpatrick: yeah, and sorts still don't work on infinite lists...
17:35:27 <monochrom> alright merge sort is better
17:35:28 <Pseudonym> In standard C qsort(), comparison is usually very expensive because it can't be inlined.
17:35:31 <Cale> You end up getting all these other uses for code for free.
17:35:42 <johnnowak> Very interesting stuff guys, thanks. 
17:35:46 * petekaz thanks everyone for the motivation to continue learning (all about monads was giving me a headache)
17:35:47 <monochrom> qsort flies because of destructive update
17:35:54 <mauke> std::sort > qsort
17:36:04 <Pseudonym> Yes, std::sort is much, much better.
17:36:05 <SamB_XP> maybe would be faster to translate C qsort into Haskell?
17:36:16 <Cale> Basically, the only time you really don't want laziness is when you're going from a "big" set of data to a "small" set, where you're using all of the big data.
17:36:24 <cpatrick> Is std::sort heapsort?
17:36:25 <SamB_XP> then the inliner could do its magic...
17:36:25 <ndm> SamB_XP: qsort is destructive
17:36:27 <Pseudonym> std::sort is usually merge sort, BTW.
17:36:35 <monochrom> std::sort is very optimized (it probably doesn't even stick with one single algorithm)
17:36:36 <SamB_XP> ndm: so?
17:36:43 <SamB_XP> Foreign.Ptr can handle it!
17:36:43 <Cale> By "big" and "small" I mean the number of parts which could be separately evaluated.
17:36:53 <Pseudonym> But it's designed to degrade gracefully to O(n log^2 n) if there's no extra memory available.
17:37:04 <ndm> often quick sort is used, and below 8 elements insertion sort is used
17:37:33 <monochrom> The Haskell stereotypical quicksort is not destructive.
17:37:43 <Pseudonym> That's the SGI implementation, anyway, which is what most implementations use.
17:37:53 <Pseudonym> Not sure about STLport.
17:38:13 <Sentinel> SGI stl uses Introsort for sort
17:38:39 <johnnowak> monochrom: my concern is that such things in haskell are very beautiful, but not usable in practice.
17:38:41 <Pseudonym> BTW, cool paper: http://citeseer.ist.psu.edu/630187.html
17:38:51 <Pseudonym> While we're on the topic.
17:39:12 <cpatrick> johnnowak: that is true in some cases, but I'd say Haskell is usable in far more situations than most people give it credit
17:39:30 <Pseudonym> Yeah, I agree with that.
17:39:44 <Pseudonym> People talk about the expense of Haskell.  And it is expensive, for example, in memory use.
17:39:48 <dons> johnnowak: its used in a hugh range of problems, check haskell.org's libraries and tools page
17:39:51 <Pseudonym> But you have to weight that against the safety.
17:39:51 <johnnowak> i'm assuming it is not too much different than scheme, which has its fair share of beautiful yet absurdly slow methods for doing things.
17:39:57 <monochrom> There are Haskell people against showcasing the stereotypical Haskell quick sort for that reason.  It's misleading.  I mostly agree with them.  There are other beautiful and useful things to show off.
17:39:59 <Cale> most cases are not cutting edge games or high performance numerical processing applications.
17:40:04 <dons> well, its a lot faster  than scheme
17:40:07 <dons> ?shootout
17:40:07 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
17:40:07 <Pseudonym> C++ code which is as robust as typical Haskell code is very atypical.
17:40:45 <Pseudonym> Cale: Most supercomputers are slower than high-powered desktops when not doing heavy-duty numerical work.
17:40:51 <SamB_XP> and the quicksort isn't even all that cool!
17:40:53 <Philippa> monochrom: I'd like to see a better non-destructive quicksort example. It's doable
17:40:53 <Sentinel> haskell code is never robust
17:40:59 <SamB_XP> I think Parsec would be a better showcase
17:41:15 <Philippa> Sentinel: I suggest you either get back under the bridge or stop trolling
17:41:15 <cpatrick> Parsec is awesome.
17:41:21 <monochrom> If something is too inefficient (even asymptotically), I don't call it beautiful.
17:41:24 <Pseudonym> Sentinel, remind me never to hire you.
17:41:31 <Sentinel> Philippa: naah, wouldnt wanna take your home
17:41:41 <Cale> The only problem with the shootout is that a lot of the code that's there now is making some pretty heavy compromises in clarity for speed, but that ought to change with GHC 6.6 :)
17:41:49 <cpatrick> Cale: I don't see why Haskell _couldn't_ be made fast for array-intensive stuff
17:41:50 <SamB_XP> what makes you think she lives under a bridge?
17:41:58 <SamB_XP> cpatrick: it can!
17:42:00 <Cale> cpatrick: of course, it could
17:42:03 <Pseudonym> Mmmm... goats...
17:42:08 <SamB_XP> but GHC needs to generate loops!
17:42:17 <SamB_XP> GCC doesn't like GOTO much
17:42:18 <Sentinel> Pseudonym: wonder what jobs it exists most of, c/c++ or haskell.. besides i wouldnt wanna work as a programmer
17:42:19 <johnnowak> dons: Scheme can be fast. I've had good results with Gambit Scheme
17:42:21 <cpatrick> but the "naive" way of writing things generates shocking code in GHC
17:42:36 <monochrom> It is when you have an efficient and simple thing (to solve a hard problem), or an efficient and can-be-derived-with-simple-thing thing, that I call "beautiful".
17:42:41 <petekaz> What's in GHC 6.6?
17:42:51 <Pseudonym> Sentinel: Well I do C++ most of the time.  But if you can't write robust Haskell code, then you DEFINITELY can't write robust C++ code.
17:42:55 <Cale> petekaz: ByteStrings, for one
17:43:03 <petekaz> right.
17:43:16 <Cale> petekaz: and a very efficient sequence library
17:43:17 <Sentinel> Pseudonym: that is so wrong, most c++ probably dont even know any haskell at all
17:43:32 <SamB_XP> Sentinel: not like that
17:43:38 <Philippa> most C++ coders can't write robust C++ code either, but that's not what Pseudonym meant
17:43:53 <Philippa> if you can't learn to write robust Haskell code, you sure can't learn to write robust C++ code
17:43:54 <SamB_XP> he meant, if it is impossible to write robust Haskell code, it is even harder to write robust C++ code
17:44:08 <Sentinel> Philippa: thats not any c++ specific, thats overall truth for general programmers
17:44:27 <Cale> "In My Egotistical Opinion, most people's C programs should be indented six feet downward and covered with dirt." -- Blair P. Houghton 
17:44:47 <johnnowak> heh
17:44:48 <Philippa> Sentinel: no. You're suddenly assuming Haskell and C++ must be equal when it comes to ease of writing robust code
17:44:54 <Pseudonym> Right.
17:44:55 <Philippa> there are many more ways to fuck up in C++ than in Haskell
17:44:59 <Sentinel> noone said anything about cant learn, most c coders dont wanna/havent wanna spend the time/dont tried it or whatever to learn haskell
17:45:19 <Pseudonym> Sentinel: That's true of all sorts of languages, not just Haskell.
17:45:26 <Pseudonym> And it explains the quality of a lot of C code out there.
17:45:30 <cpatrick> Philippa: that said, people coming from strict imperative languages discover a multitude of ways to bugger up Haskell code
17:45:30 <SamB_XP> and most of the ways to f*** up in Haskell have "unsafe" in the name
17:45:31 <Sentinel> Philippa: naah in these cases i dont assume, facts comes better in the context
17:45:33 <SamB_XP> or Ptr
17:45:34 <Pseudonym> Learning different programming languages is good for you.
17:45:37 <cpatrick> (well, I certainly did!)
17:45:38 <Pseudonym> Even if you don't use them.
17:45:41 <Philippa> <Sentinel> haskell code is never robust <- you damn well did say something about robustness in haskell and the ease thereof
17:45:46 <Pseudonym> It improves your programming.
17:46:02 <Sentinel> Philippa: that was a joke, hard to see maybe?
17:46:02 <Philippa> cpatrick: true. You learn though :-)
17:46:04 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/9a4a844e63d6feed?hl=en&  would be what I call beautiful.  (Erratum: I should use foldl1 instead of foldl)
17:47:00 <dons> @seen sjanssen 
17:47:00 <lambdabot> sjanssen is in #haskell. I don't know when sjanssen last spoke.
17:47:04 <johnnowak> i find this part of the shootout to be much more interesting than the cpu time:
17:47:07 <dons> @seen sjanssen_
17:47:07 <lambdabot> I saw sjanssen_ leaving #haskell 2 hours, 49 minutes and 11 seconds ago, and .
17:47:09 <johnnowak> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all&calc=Calculate&xfullcpu=0&xmem=0&xloc=1&binarytrees=1&chameneos=1&message=1&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&nbody=1&nsieve=1&nsievebits=1&partialsums=1&pidigits=1&recursive=1&regexdna=1&revcomp=1&spectralnorm=1&hello=0&sumcol=1
17:47:09 <Philippa> Sentinel: yes, funnily enough, it is. It's even harder to see how the joke is anything but "but it's only a joke so I can be mean and get away with it", because tone of voice doesn't carry in text and nobody'd know if you genuinely meant the exact opposite
17:47:56 <Cale> johnnowak: yep, if you only count code lines, we do quite well :)
17:48:04 <SamB_XP> you need zeh zmiley to give it away ;-P
17:48:05 <dons> johnnowak: actually, we burnt a lot of our lines of code lead implementing some of the io benchmarks
17:48:15 <dons> we should be much further ahead in that area
17:48:18 <Cale> johnnowak: GHC was actually #1 for a while
17:48:20 <Philippa> SamB_XP: you're a fucking moron. :-)
17:48:21 <dons> (i.e. using Data.ByteString)
17:48:37 <Sentinel> Philippa: well i dont need to put tons of smileys after every sentence, i thought it was so obvious pretty much anyone with a small knowledge in the subject would see it
17:48:43 <johnnowak> Cale: Isn't it still #1?
17:48:48 <Pseudonym> Even Data.ByteString isn't going to help GHC's sucky I/O _that_ much.
17:48:50 <Cale> johnnowak: I mean overall
17:48:51 <dons> Cale: its still #1 of loc.
17:48:59 <Cale> yeah, it's #1 in loc
17:49:04 <johnnowak> Cale: ah!
17:49:13 <SamB_XP> Sentinel: but we don't have all that much knowledge of *you*
17:49:16 <Pseudonym> BTW, we readily admit that GHC's I/O sucks performance-wise.
17:49:23 <Philippa> Sentinel: you were wrong, in fact you come across much like a typical pro-C++ troll when we don't know anything about you
17:49:24 <dons> but yes, we were #1 overall justa a couple of months ago: http://www.cse.unsw.edu.au/~dons/haskell_1.html
17:49:28 <johnnowak> Pseudonym: Why is it so bad?
17:49:40 <dons> Pseudonym: well, its not _in general_ bad
17:49:42 <Philippa> because right up until this point, there's been no way to tell the difference
17:49:42 <Pseudonym> johnnowak: The sucky String implemenetation is aprt of it.
17:49:44 <dons> it depends on your io library
17:49:45 <Pseudonym> Oh, sure.
17:49:50 <nn2> so how is the haskell monop program going
17:50:13 <johnnowak> Pseudonym: Is this being changed or is it by a "by design" sort of thing?
17:50:19 <dons> its already changed
17:50:23 <Pseudonym> Yeah.
17:50:31 <dons> use Data.ByteString instead of [Char] io
17:50:34 <dons> ?wiki Wc
17:50:34 <lambdabot> http://www.haskell.org/haskellwiki/Wc
17:50:37 <dons> for example
17:50:40 <Pseudonym> It's mostly a "it wasn't the bottleneck at the time" issue.
17:50:47 <Philippa> it's a case of "by initial not-intended-for-industrial-use design"
17:50:48 <Pseudonym> Things are improving.
17:51:01 <johnnowak> Ah, gotcha. I was unaware that Haskell benchmarked so well.
17:51:03 <Philippa> "everything else was so shitty it didn't matter" :-)
17:51:05 <petekaz> the fps stuff is very impressive!
17:51:07 <Pseudonym> yeah.
17:51:09 <Sentinel> Philippa: well, ofc there always people like that, but why even bother then when you know they are totally wrong and they probably even realise it themselves or at least that they lack the knowledge of sutch a statement. And i have talked with a few ppl in here before
17:51:25 <SamB_XP> you can still have your ridiculously simpleminded Strings, though, if you like them
17:51:39 <dons> they're good for inductive reasoning when teaching :)
17:51:40 <Pseudonym> Haskell wasn't designed for I/O bound applications.  It's only very recently that people have seriously tried writing them.
17:51:53 <Pseudonym> And hence only recently that people have worked hard on that area.
17:52:03 <Philippa> Sentinel: there're 199 people in here right now, so talking to "a few" doesn't mean the rest know who you are
17:52:13 <monochrom> I like my ridiculously simple-minded Strings.  They can hold unicode characters.
17:52:23 <Sentinel> Philippa: pretty obvious isnt it?
17:52:24 <Cale> hehe
17:52:29 <Philippa> heck, there're people in here who don't know who I am and I get stalkers posting in my LJ from around here
17:52:30 <dons> monochrom: :P
17:52:51 <Cale> monochrom: however, you just can't really *do* anything with those unicode characters
17:53:03 <SamB_XP> monochrom: not to ridicule them, it is just that I was going to say "ridiculously easy" but didn't want to be attacked by FPS ninjas contradicting me
17:53:56 <Philippa> [Char] still has its uses though
17:53:57 <Cale> Hopefully we attract a unicode guru sometime soon who will feel up to really writing proper unicode handling.
17:54:01 <nn2> what is all that xml stuff for
17:54:14 <SamB_XP> nn2: for XML
17:54:18 <Pseudonym> [Char] definitely has its uses, because it's a iterator for strings.
17:54:22 <stepcut> dons: Is there a way in fps to compare a String and ByteString ?
17:54:29 <Pseudonym> What makes it especially cool is that it's lazy.
17:54:30 <Philippa> I reckon the most sensible way to use Parsec on an FPS is probably just to use whatever the toString func is, for example
17:54:39 <Philippa> yup
17:54:39 <nn2> how do i compile it
17:54:46 <SamB_XP> nn2: you mean HXT?
17:54:48 <Cale> stepcut: just pack the string or unpack the bytestring
17:54:51 <dons> stepcut: pack s == b
17:55:01 <Philippa> with a little bit of work you can keep the amount of the string it needs in actual memory really tiny
17:55:07 <dons> (better to pack the [Char], than unpack the bytestring)
17:55:18 <stepcut> which do you think is faster? (pack s) == b or s == (unpack b) ?
17:55:20 <nn2> what ever all that coad is
17:55:26 <dons> the former. 
17:55:37 <dons> since you might generate a large string with the unpack
17:55:39 <SamB> nn2: you mean the .rnc file?
17:55:54 <nn2> y and the other
17:55:56 <nn2> one
17:56:00 <dons> stepcut: better to have 1 string, and 2 bytestrings, than 2 strings, and 1 bytestring
17:56:06 <SamB> oh, that one is just for Emacs!
17:56:20 <SamB> so Emacs knows what mode to use for the test file!
17:56:23 <nn2> what is hmonop
17:56:27 <SamB> er, what Schema
17:56:27 <dons> or , if it was a bottleneck, you could definitely test them simultaneously
17:56:35 <SamB> oh, that new file is also XML
17:56:38 <SamB> right
17:56:41 <SamB> it is a glade file
17:56:54 <SamB> you open it in glade-2 (package glade, iirc)
17:56:56 <nn2> for what
17:57:09 <Philippa> linear [Char] strings would be really cool for one-shot iterator purposes, you wouldn't need to keep the cons-chain in memory
17:57:09 <SamB> it has a (partial) GUI
17:57:25 <stepcut> dons: ok, I am using the (pack s) == b trick for now -- maybe I will try to implement a compare that does not pack or unpack and see how it performs
17:57:27 <SamB> nn2: oh, you can pull down the code, you know
17:57:34 <nn2> so what duse glade have to do with haskell
17:57:41 <Philippa> I figure leave the Char 'normal'
17:57:51 <nn2> where
17:57:55 <Philippa> glade has nothing to do with haskell but much to do with gtk (for which a haskell binding exists)
17:57:59 <dons> should be easy to adapt the commented-out comparePS in Data/ByteString.hs to take one string and one bytestring
17:58:28 <nn2> in your home?
17:58:41 <SamB> darcs get http://srv256.homelinux.net:5190/sam/hMonop/
17:59:07 <SamB> orbitz: darcs get ~sam/webroot/hMonop
17:59:24 <SamB> never mind that I haven't yet written a line of Haskell
17:59:59 <stepcut> dons: thanks, i'll start there.
18:00:06 <nn2> ok 
18:00:09 <nn2> >>
18:00:09 <johnnowak> is it common to make use of templates/macros in Haskell? I cannot find out much information about them.
18:00:23 <SamB> we call them "functions"
18:00:32 <heatsink> heh
18:00:34 <johnnowak> SamB: this is what i figured :-)
18:00:34 <SamB> ;-P
18:00:43 <dons> johnnowak: yeah, higher order functions are used 98% of the time
18:00:49 <dons> the rest we use Template Haskell or cpp
18:00:53 <Cale> johnnowak: well, there's template haskell, but it hasn't got much actual use yet
18:01:06 <SamB> we have type classes to make them even more templatey ;-)
18:01:11 <Cale> (at least as far as I know)
18:01:23 <johnnowak> Cale: Yes, that's what I saw. It is supported by ghc, yes? Why does no one use it?
18:01:28 <Cale> Parametric polymorphism gives you almost everything that C++ templates are used for.
18:01:33 <SamB> I think HOC uses it
18:01:40 <heatsink> Cale: except for parametrizing on integers.
18:01:42 <Pseudonym> Cale: That's not the whole truth.
18:01:43 <stepcut> johnnowak: template haskell seems to be largely used for deriving instances for things like binary serialization...
18:01:44 <Cale> heatsink: yeah
18:01:46 <heatsink> Cale: and type functions
18:01:46 <monochrom> Yeah, I have found that parametric polymorphism and type classes cover all of my C++ template usages.
18:02:01 <Pseudonym> Typeclasses are kind of equivalent to C++ concepts.
18:02:05 <Cale> I did say "almost"
18:02:08 <johnnowak> I take it that it is not on par with things like scheme hygienic macros?
18:02:21 <Pseudonym> johnnowak: yes and no.
18:02:23 <monochrom> I don't even parametrize on integers in C++. ^^
18:02:45 <Pseudonym> Because Haskell's syntax is more like a traditional language than Lisp, the scope for syntax hackery is reduced.
18:02:46 <heatsink> A hygenic macro is expanded by the parser, right?  So would it be kind of like a CAF in haskell?
18:03:08 <Pseudonym> However, Haskell has a long tradition of combinator libraries, which cover a lot of the cases.
18:03:10 <mauke> I tried to write a recursive descent parser in C++ templates once
18:03:13 <SamB> heatsink: not really
18:03:16 <johnnowak> pseudonym: That's what I figured. I like me my parenthesis. 
18:03:17 <heatsink> In that it's evaluated once per instance
18:03:20 <SamB> because a macro is not a function
18:03:20 <Cale> johnnowak: TH has the problem that if you write your library using it, then the users of your library most likely must be aware of that fact (unless you use it to do something which could be done without TH anyway)
18:03:22 <Pseudonym> There's also Template Haskell.
18:03:25 <SamB> in Scheme
18:03:35 <orbitz> SamB: i assume you mean 'or: darcs get'
18:03:52 <SamB> orbitz: oops, yes!
18:03:55 <orbitz> SamB: MEOW
18:03:57 <SamB> heh.
18:04:18 <Pseudonym> TH is most useful for simulating advanced C++ efficiency-oriented hackery.
18:04:26 <Pseudonym> Like loop unrolling.
18:04:41 <Pseudonym> Or specialised data structures where you want to avoid indirection.
18:04:47 <Cale> You can wrap any constant value in $(...) and it'll be evaluated at compile time.
18:04:59 <heatsink> Pseudonym: You can avoid indirection in haskell?
18:05:06 <Pseudonym> heatsink: Sure.
18:05:13 <Cale> So you can use it to trick people into thinking that haskell code is impossibly efficient :)
18:05:34 <Pseudonym> heatsink: http://haskell.org/hawiki/IndirectComposite
18:05:41 <Pseudonym> You can do that in TH, and it'd be slightly more efficient.
18:05:44 <monochrom> Can you factor numbers in TH at compile time?
18:05:49 <Pseudonym> Would that matter in practice?  Who knows.
18:06:24 <Cale> monochrom: yes
18:06:25 <SamB> nn2: got glade installed yet?
18:06:37 <Cale> monochrom: you can even do IO
18:07:17 <lispy> but can you do it in O(n) ?
18:07:28 <heatsink> oh, I think i get it
18:08:02 <Cale> There was someone working on a TH program which parsed C++ headers and produced bindings to C++ libraries automatically at compile time.
18:08:27 <Pseudonym> Personally, I tend to unroll my loops at run-time.
18:08:31 <ForgeAus> TH program?
18:08:33 * stepcut once used TH to parse the debian/changelog and get the version number for program's --version commmand :)
18:08:41 <Cale> ForgeAus: Template Haskell
18:08:49 <ForgeAus> ahh ok
18:08:51 <Pseudonym> Because it's a lazy language, and I can.
18:08:59 <SamB> Cale: I think HOC uses TH for something, don't remember exactly how...
18:09:05 <Pseudonym> Sure, you don't get as much in the way of low-level optimisations...
18:09:08 <Pseudonym> But it's easier to write.
18:09:59 <Philippa> TH is great if you need a quickie compiler for a DSL, too
18:10:18 <johnnowak> thanks for all the input guys -- i'm off for a bit!
18:10:25 <Philippa> because you pretty much just write an interpreter and then "stage-annotate" it ("do this bit at compile-time to build that bit for run-time")
18:11:54 <ihope> Hmm...
18:11:54 <mauke> hmm, so you could port my http://www.spoj.pl/ranks/PIVAL/ solution to TH ...
18:12:27 <Sentinel> Cale: Is there any good book on haskell?
18:13:39 <nn2> SamB, that shell command that you sent to make an ** email user ** never came thrue can you re send it threw my irc
18:13:58 <Cale> Sentinel: there are some which are supposed to be good, I'm not sure how good they are since I haven't actually read them
18:14:29 <Cale> Sentinel: For beginning, I rather like "Yet Another Haskell Tutorial", which is almost a book, though it's not quite finished yet.
18:14:59 <Cale> but whether you'll find that enjoyable probably depends on your background -- some people find it a bit slow
18:15:35 <Cale> (though these tend to be people who already know ML or some closely related language)
18:16:12 <Sentinel> ML?
18:16:17 <Cale> Yeah
18:16:33 <Cale> It's another functional programming language -- usually strict
18:16:39 <Sentinel> ah ok
18:16:47 <Cale> o'caml and SML are popular variants
18:16:57 <ihope> What's that flag thingy to enable FFI?
18:17:03 <Cale> -ffi or -fffi
18:17:07 <ForgeAus> ML ocaML MixaL ... hmmm....
18:17:08 <Cale> I think both work
18:17:24 <SamB> Cale: yes
18:17:27 <SamB> -fffi just looks wierd
18:17:36 <stepcut> or the hammer, -fglasgow-exts ;)
18:18:00 <Sentinel> how would you do networking in haskell, sockets for example?
18:18:04 <SamB> so even if -ffi comes out to -f/fi, where the slash just seperates different parts of the flag, it still looks nicer...
18:18:19 <Cale> import Network or import Network.Socket
18:18:28 <SamB> Network has the Handles?
18:18:37 <ihope> So how's CInt work?
18:18:41 <Cale> yeah
18:18:43 <ihope> @hoogle CInt
18:18:43 <lambdabot> Foreign.C.Types.CInt :: data CInt
18:18:49 <SamB> ihope: it is just like Int, only different
18:18:57 <heatsink> ihope: It's a numeric type, like Data.Int32 and such
18:18:59 <ihope> Is it a Num?
18:19:02 <SamB> yes!
18:19:03 <Cale> yep
18:19:06 <Cale> and an Integral too
18:19:07 <Sentinel> Cale: found this reference site, is the network part covered on some site like this? http://zvon.org/other/haskell/Outputglobal/index.html
18:19:09 <ihope> Ah, great!
18:19:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
18:19:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- more generally
18:19:37 <SamB> @doc Foreign.C.Types
18:19:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html
18:19:38 <Sentinel> ok thx
18:19:43 <ihope> Woot!
18:19:52 <ihope> Now, what did I just accomplish?
18:20:06 <Cale> The list of libraries is really starting to look impressive
18:20:21 <ihope> ...Ooph.
18:20:28 <Cale> When I started using Haskell, it wasn't even close to half as long as this.
18:20:43 <stepcut> Cale: yeah, and the Data.List probably had half as many functions
18:20:53 <Pseudonym> When I started using Haskell, it didn't even have monads.
18:21:01 <Pseudonym> But that's a long story.
18:21:16 <monochrom> very long.
18:21:34 <SamB> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html#t:CInt
18:21:51 <stepcut> When I started, it didn't even have functions!
18:21:58 <ihope> C:/Documents and Settings/foobar/Desktop/ffitest-hs.o: unknown symbol `_add'
18:22:00 <heatsink> :)
18:22:08 <SamB> sethk: I'm beginning not to believe this story
18:22:13 <SamB> er, stepcut 
18:22:15 <stepcut> :p
18:22:21 <SamB> especially the part about having used it at that point
18:22:29 <heatsink> ihope: is that supposed to be a C function?
18:22:39 <stepcut> OK, I have only starting using it 4 years ago
18:22:57 <ihope> heatsink: well, add is a C function.
18:23:03 <stepcut> so I think it already had Monads and Arrows (though Arrows required a preprocessor)
18:23:09 <nn2> what is the path to the fake shell
18:23:16 <stepcut> /bin/false ?
18:23:21 <Cale> Isn't GHC supposed to come with an OpenAL binding?
18:23:35 <stepcut> Cale: it is in fptools, but I am not sure that it gets built
18:23:37 <heatsink> ihope: C functions get a leading _ added automatically.
18:23:55 <ihope> Well, how can I make this thing find this thing?
18:24:17 <heatsink> ihope: did you add the object file from your C code to the command line?
18:24:35 <Igloo> Cale: It won't be built if you don't have the C dev libs installed (and is broken in the current release, I think)
18:24:44 <Cale> Igloo: ah
18:24:51 <ihope> "Warning: ignoring unrecognised input `C:/Documents and Settings/foobar/Desktop/ffitest-c.h'"
18:25:28 <heatsink> ihope: you don't nead a header file with the haskell compiler, just the object file.
18:25:41 <ihope> Ah.
18:25:53 <heatsink> using ghc?
18:25:59 <ihope> GHCi.
18:26:38 <heatsink> I don't know if you can do it with ghci.
18:27:06 <ihope> Loading object (static) C:/Documents and Settings/foobar/Desktop/ffitest-c.o ... : C:/Documents and Settings/foobar/Desktop/ffitest-c.o: Not x86 PEi386: panic! (the `impossible' happened, GHC version 6.4.1): loadObj: failed
18:27:54 * heatsink gives ihope a copy of Hitchiker's guide to the galaxy
18:27:56 <SamB> nn2: stepcut speaks the truth
18:28:12 <SamB> he is obviously a mind reader!
18:28:34 <Razor-X> If you hGetContents then last .lines, it should work, shouldn't it?
18:28:35 * ihope decides to call add with the arguments "21" and "21" instead
18:29:11 <heatsink> I don't know what that error message means.
18:29:22 <SamB> perhaps it is a COFF file?
18:29:36 <SamB> or, who knows, an ELF file?
18:38:08 <ihope> So there's a B language, a C language, and a D language.
18:38:18 <ihope> And an E language.
18:38:30 <SamB> what about F77?
18:38:58 <ihope> And an F language and a G language.
18:39:01 <ihope> But no H language.
18:39:10 <SamB> what about us?
18:39:22 <ihope> > "Haskell
18:39:22 <lambdabot>  Improperly terminated string
18:39:26 <ihope> > "Haskell" == "H"
18:39:26 <lambdabot>  False
18:39:46 <SamB> or maybe they skipped that one because the Japanese would get the wrong idea?
18:39:47 <lispy> > head "Haskell"
18:39:47 <lambdabot>  'H'
18:40:25 <Cale> Where's P and L?
18:40:42 <lispy> oh....
18:41:05 <lispy> you could use the "programming language alphabet" but you'd have to skip the letters H, P and L?
18:41:24 <SamB> P and L?
18:41:28 <lispy> I could see this ending up in a story about hardcore geek trivia
18:41:45 <Cale> http://en.wikipedia.org/wiki/BCPL
18:42:11 <Cale> B came from BCPL, and C came from B
18:42:36 <ihope> And BCPL came from CPL?
18:42:40 <Cale> yeah
18:42:58 <lispy> heh, CPL -> BCPL -> B -> C
18:43:29 <ihope> ALGOL 60 -> CPL, but only a bit.
18:43:33 <Cale> yeah
18:44:01 <Cale> http://www.levenez.com/lang/history.html
18:48:53 <ihope> What was the first programming language?
18:49:02 <ihope> Well... hmm.
18:49:21 <JohnnyL> fortran, then lisp?
18:49:24 <JohnnyL> (of course after asm)
18:50:11 <Cale> http://www.cs.utah.edu/~wilson/compilers/old/papers/p157-landin.pdf -- check this out :)
18:50:18 <ihope> It looks like Plankalkl was a pretty durn early one.
18:50:20 <Cale> (in particular, look at the date on it)
18:53:01 <dons> @seen ADept
18:53:01 <lambdabot> ADept is in #haskell-overflow and #haskell. I don't know when ADept last spoke.
18:53:56 <ihope> Weird question: what's the shortest Haskell program that computes everything that can be computed?
18:54:02 <Pseudonym> ihope: It depends what you call a programming language.
18:54:09 <Pseudonym> Programmers have always had notation.
18:54:24 <Pseudonym> I spoke to one of the CSIRAC engineers once.  Apparently it had a high-level language.
18:54:42 <Pseudonym> If you can call it that.
18:54:54 <dons> Pseudonym: was that the csiro computer?
18:55:03 <Pseudonym> Yes.
18:55:14 <heatsink> ihope: Would a program that computes all finite strings of bits count?
18:55:20 <Pseudonym> Well, I think it was called CSIR at the time.
18:55:35 <ihope> heatsink: you mean enumerates them?
18:55:38 <ihope> I don't think so.
18:55:40 <heatsink> ihope: yea
18:55:53 <heatsink> presumably every computable value can be represented as a finite string of bits.
18:56:01 <Pseudonym> The first true programming language was probably assembler.
18:56:09 <Pseudonym> In the sense of something that was compiled to machine code.
18:56:09 <heatsink> sure
18:56:27 <Pseudonym> But the first true programming language as we understand the term today was Fortran.
18:56:34 <Pseudonym> Shortly followed by COBOL and Lisp.
18:56:44 <ihope> Oh... I'd say a program has computed something if a finite state machine can peek at the output and tell you the answer.
18:56:44 <dons> ihope: hmm, how about a lambda calculus interpreter
18:57:08 <ihope> dons: then all you need is the right lambda calculus expression :-)
18:57:19 <dons> just needs to map lambda to lambdabot, and apply to apply. could be done in 10 lines maybe?
18:57:21 <heatsink> So how come COBOL sounds more antiquated than either Fortran or Lisp?
18:57:24 <dons> grr/ lambdabot??
18:57:35 <Pseudonym> Hmmm.
18:57:38 * dons shouldn't talk about lambda calculus while building lambdabot
18:57:39 <Pseudonym> Actually...
18:58:02 <Pseudonym> A-0 might be considered as a programming language pre-dating Fortran.
18:58:15 <Pseudonym> It was basically three-address code.
18:58:20 <int-e> dons: hmm. did you receive any lambdabot patch from me? I've struggled with darcs today (well, yesterday)
18:58:28 <Cale> heatsink: it's not much younger
18:59:12 <dons> int-e. got it . building now..
18:59:15 <dons> thanks!
18:59:20 <Pseudonym> Fortran started in 1953.  A-0 dates from 1952.
18:59:28 <dons> i actually got 3 lambdabot patches overnight, from 3 different people. good stuff
18:59:33 <dons> ?karma+ int-e
18:59:33 <lambdabot> int-e's karma raised to 7.
18:59:37 <dons> ?karma+ davidhouse
18:59:37 <lambdabot> davidhouse's karma raised to 3.
18:59:42 <dons> ?karma+ ADept
18:59:43 <lambdabot> ADept's karma raised to 1.
19:00:07 <int-e> dons: did you receive it more than once (I think you should not have, but I'm not absolutely sure; I'd like to know though.)
19:00:07 <dons> ?karma+ ADEpt -- i think i spell wrong.
19:00:14 <dons> i got it twice.
19:00:21 <dons> ?bot
19:00:51 <int-e> okay. sorry for that. I hope I got it figured out now so it won't happen again.
19:01:00 <dons> don't worry :)
19:01:07 <lambdabot> ADEpt's karma raised to 3.
19:01:09 <lambdabot> :)
19:02:45 <Pseudonym> @foldoc A-0
19:02:46 <lambdabot> *** "a0" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:02:47 <lambdabot> A-0
19:02:47 <lambdabot>  
19:02:47 <lambdabot>    <language> (Or A0) A language for the {UNIVAC I} or II, using
19:02:48 <lambdabot>    {three-address code} instructions for solving mathematical
19:02:50 <lambdabot> [11 @more lines]
19:02:54 <Pseudonym> @more
19:02:54 <lambdabot>    problems.  A-0 was the first language for which a {compiler}
19:02:56 <lambdabot>    was developed.  It was produced by {Grace Hopper}'s team at
19:02:58 <lambdabot>    {Remington Rand} in 1952.  Later internal versions were A-1,
19:03:00 <lambdabot>    A-2, A-3, AT-3.  AT-3 was released as {MATH-MATIC}.
19:03:02 <lambdabot>  
19:03:04 <lambdabot> [6 @more lines]
19:03:10 <Pseudonym> There you go.
19:03:15 <dons> there you go, indeed.
19:03:28 <dons> wow. 1952. didn't know it was that early
19:05:58 <mathewm> If I have some action I want to repeat 3 times, is there any way I can just 'replicate 3 x'?  I get [IO ()] instead of what I want.
19:06:15 <int-e> sequence
19:06:19 <mathewm> @hoogle [IO ()] -> IO ()
19:06:19 <lambdabot> No matches, try a more general search
19:06:30 <int-e> @type sequence . replicate 3
19:06:31 <lambdabot> forall (m :: * -> *) a.
19:06:31 <lambdabot>          (Monad m) =>
19:06:31 <lambdabot>          m a -> m [a]
19:06:36 <heatsink> @hoogle [IO a] -> IO a
19:06:36 <lambdabot> No matches, try a more general search
19:06:40 <int-e> @type sequence_ . replicate 3
19:06:41 <lambdabot> forall (m :: * -> *) a.
19:06:41 <lambdabot>          (Monad m) =>
19:06:41 <lambdabot>          m a -> m ()
19:06:57 <int-e> @index replicateM
19:06:58 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:07:00 <int-e> or that
19:07:16 <mathewm> thanks
19:07:20 <int-e> @index replicateM_
19:07:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:09:30 <heatsink> So this is totally unrelated, but polyploidy is surprisingly common in animals and plants.
19:10:27 <heatsink> Bananas and some lizards have three sets of chromosomes.  They can only reproduce asexually.
19:10:27 <dons> that's not unrelated.
19:11:32 <dons> @quit new code
19:11:34 <heatsink> Um... I guess Haskell was a broader topic than I realized at first.
19:11:48 <dons> > [1..]
19:12:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:12:17 <dons> opinions?
19:12:26 <Razor-X> Gah. ByteString.lines should split up BS.hGetContents into lines, no?
19:12:29 <heatsink> That took longer than I expected...
19:12:45 <dons> Razor-X: sure. or use ByteString.hGetLines
19:12:47 <heatsink> [1..28]
19:12:50 <heatsink> > [1..28]
19:12:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]
19:12:52 <dons> heatsink: oh just the server settling
19:12:57 <heatsink> oh
19:13:11 <dons> freenode seems to use -finsert-arbitrary-delays
19:13:29 <Razor-X> dons: Hmm. It's not working though.
19:13:35 <Razor-X> I'm getting an error.
19:13:40 <dons> what kind of error.
19:13:54 <int-e> dons: I like that better than getting many lines as before.
19:14:01 <dons> ok. me too, int-e
19:14:18 <dons> Razor-X: I need more info to debug your code... :)
19:14:25 <Razor-X> dons: Yeah, I'm gonna pastebin it.
19:14:33 <mathewm> So why doesn't hoogle match '[m a] -> m ()' against '[ IO () ] -> IO ()' ??
19:14:38 <dons> oh, btw, lines is in Data.ByteString.Char8, yeah.
19:14:47 <dons> or are you using an older Data.ByteString repo?
19:15:09 <dons> @hoogle [IO ()] -> IO ()
19:15:09 <lambdabot> No matches, try a more general search
19:15:14 <dons> @hoogle [IO a] -> IO a
19:15:15 <lambdabot> No matches, try a more general search
19:15:26 <dons> @hoogle [m ()] -> m ()
19:15:26 <lambdabot> No matches, try a more general search
19:15:30 <heatsink> @hoogle [IO a] -> IO [a]
19:15:30 <lambdabot> No matches, try a more general search
19:15:31 <dons> @hoogle [m a] -> m a
19:15:31 <lambdabot> Prelude.head :: [a] -> a
19:15:31 <lambdabot> Prelude.last :: [a] -> a
19:15:31 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
19:15:37 <int-e> mathewm: because hoogle isn't clever enough. It doesn't know about non-nullary type variables (like that m)
19:15:47 <int-e> or that's what I think.
19:15:50 <lisppaste2> Razor-X pasted "hGetContents Reloaded!" at http://paste.lisp.org/display/20652
19:16:10 <mathewm> hmm
19:16:54 <heatsink> Razor-X: BS.last result isn't an IO action...
19:17:15 <dons> Razor-X: ?
19:17:25 <dons> there's about 3 bugs in that code :)
19:17:25 <Razor-X> heatsink: Oiye.
19:17:38 <Razor-X> I tried it that way at first, heatsink, bleh.
19:17:39 <dons> firstly, last will return the last Word8 or Char
19:17:43 <dons> not the last line
19:17:58 <dons> @type Data.ByteString.Char8.last
19:17:59 <Razor-X> So I use BS.lines I presume?
19:17:59 <lambdabot> Data.ByteString.Base.ByteString
19:17:59 <lambdabot>           -> Char
19:18:11 <dons> let me write an example.
19:18:19 <Razor-X> Mmmkay. (Thanks, heh.)
19:21:06 <lisppaste2> dons annotated #20652 with "Better lines" at http://paste.lisp.org/display/20652#1
19:21:42 <dons> the first form is what you are trying to do. the second is more efficient, as it avoids first scanning the whole buffer for lines
19:21:49 <dons> instead it just goes to the end, and  extracts the last line
19:22:13 <Razor-X> I wanted to do the latter, but didn't know how.
19:22:23 <dons> oh, actually, that fromJust isn't needed (that's from some old code)
19:22:24 <Razor-X> Thanks.
19:22:28 <dons> @type Data.ByteString.breakEnd
19:22:29 <lambdabot> (Word8 -> Bool)
19:22:30 <lambdabot>           -> Data.ByteString.Base.ByteString
19:22:30 <lambdabot>           -> (Data.ByteString.Base.ByteString,
19:22:30 <lambdabot>            Data.ByteString.Base.ByteString)
19:22:35 <dons> just returns the pair
19:23:09 <dons> so its really: BS.putStrLn . snd . BS.breakEnd '\n'
19:23:19 <dons> applied to 'result'
19:23:30 <Razor-X> Ah.
19:36:18 <ell-hask> Hello again all, another question: what is the Haskell equivilant to the 'C' functions "setitimer()" and "getitimer()"?
19:37:00 <ell-hask> I can only find alarm which is in terms of seconds... yuck!
19:37:52 <ell-hask> @where paste
19:37:52 <lambdabot> http://paste.lisp.org/new/haskell
19:38:09 <int-e> > head . foldl (\l@ ~(a:b:l') x -> maybe (read x:l) (\f -> f a b:l') $ lookup x [("+",(+)),("-",(-)),("*",(*)),("/",(/))]) [] . words $ "2 8 5 * +"
19:38:10 <lambdabot>  42.0
19:40:25 <Razor-X> dons: Thanks a lot, by the way.
19:40:32 <dons> Razor-X: it all works?
19:40:41 <dons> ell-hask: threadDelay and forkIO
19:41:10 <Razor-X> dons: Yup :).
19:41:12 <Razor-X> For now.
19:41:26 <dons> simple cases, just threadDelay, more complex ones, use forkIO, which then raises an exception on the timeout
19:42:19 <dons> very nice int-e :)
19:43:49 <Razor-X> Ah! I thought I ran away from Perl!
19:44:19 <dons> you mustn't have seen
19:44:23 <dons> ?wiki Obfuscatoin
19:44:23 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscatoin
19:44:28 <dons> ?wiki Obfuscation
19:44:29 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
19:44:30 <dons> i mean
19:44:46 <Razor-X> Nifty.
19:45:23 <Razor-X> Wow.
19:46:06 <ell-hask> dons: I think those should work.   Basically what I want is a system that has many potential producers (who schedule 'events') and it will spit out the provided data after the time has expired.
19:46:33 <ell-hask> I've made the monad 'calander' which just has add, del, and addSet functionallity
19:47:22 <ell-hask> Now I need to open input and output sockets, accept data, add the data, have a timeout (that changes if we modify the soonest event), and send the data.
19:48:03 <ell-hask> I tell you this because I am hoping to hear that I am similar to something you know about.
19:48:34 <dons> well, sounds a bit like a Chan
19:48:40 <dons> ?docs Control.Concurrent.Chan
19:48:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
19:48:58 <dons> but with the timeout, that makes it a bit more complicated (welll, a couple more lines)
19:49:32 <ell-hask> dons: are you a Haskell demi-god?  I don't think I have ever shown up here with you not here.
19:50:11 <mux> El dons
19:50:11 <dons> well, i'm doing a phd in haskell stuff, so i tend to hmm, spend every day thinking about it?
19:51:06 <ell-hask> Ahh - good luck on the thesis.
19:51:20 <dons> :) thanks
19:57:31 <ell-hask> I just leached some of your online material.  Thank you and good night.
20:08:09 <bringert> dons: in fps from darcs, Data.ByteString.Lazy.length gives me an Int64, but drop et al take an Int.
20:09:58 <dons> yep. todo
20:10:19 <bringert> mkay, can I help?
20:10:28 <dons> you could add Int64 to drop and take :)
20:10:55 <bringert> ok, so everything should work with Int64? No Integral a or something?
20:11:17 * dons ponders
20:12:00 <dons> should be ok. you might need a couple of fromIntegrals to handle the chunk lenghths
20:12:06 <dons> the type checker should be able to tell you though
20:12:38 <bringert> the type signatures in the export list seem to be drifting out of sync btw
20:12:45 <bringert> I'll try to update the ones I touch
20:13:01 <dons> if you could do drop, take, splitAt, index, elemIndex, elemIndices (maybe), count, findIndex theres a couple of others perhaps
20:13:09 <bringert> will do
20:13:12 <dons> or at least do a couple, so i'm reminded to do the rest
20:13:38 <dons> oh, that's about it. and mapIndexed
20:14:05 <dons> you using .Lazy in a project?
20:15:25 <bringert> yep, NewCGI / FastCGI
20:15:31 <dons> oh, very interesting!
20:15:36 <dons> streaming or something?
20:16:06 <bringert> it was using ByteString before, Lemmih sent me a patch to support .Lazy as well
20:16:14 <dons> ok. cool.
20:16:26 <dons> it would be interesting to use .Lazy to start streamign multi-gigabyte files around
20:16:28 <bringert> after I applied that I figured I might just as well switch to Lazy completely
20:16:44 <bringert> to be able to do thing like what you suggest
20:16:45 <dons> well, it runs faster in some instances, and equivalent in the rest.
20:17:11 <dons> so it should be reasonable to switch
20:17:29 <bringert> it would be nice to benchmark FastCGI serving big static files, maybe it can rival Apache, even when running under Apache?
20:19:33 <bringert> the comment says  hGetNonBlockingN is similar to 'hGetN', shouldn't that be hGetContentsN?
20:20:58 <dons> oh, looks like it.
20:21:03 <dons> Lemmih added that functoin yesterday
20:21:16 <dons> also, note that there's currently an issue with hGetN and friends.
20:21:26 <dons> don't open more than one on a file, otherwise the reads may be interleaved
20:21:44 <dons> i.e: a <- hGetN 10 "f"; b <- hGetN 20 "g" ; ...
20:22:00 <dons> hGetN shouldn't be lazy, JaffaCake has correctly pointed out
20:22:17 <dons> only when we want to read the whole file can we do so lazily.
20:22:44 <dons> bringert: can you fix the comment for hGetNonBlockingN, btw?
20:23:32 <bringert> dons: done
20:42:41 <bringert> dons: I think I found a bug in hGetN
20:44:40 <shapr> Good morning #haskell!
20:44:49 <bringert> good morning shapr
20:44:52 <shapr> bringert: Wow, what time did you wake up?
20:44:54 <dons> yeah?
20:45:02 <bringert> shapr: I'm in Seattle
20:45:15 <dons> oh! Seattle?
20:45:20 <shapr> oh :-)
20:45:25 <dons> conference, or moved!?
20:45:37 <shapr> Did you see the pig? What about the Ban roll-on building?
20:45:40 <bringert> dons: in the special case  where m | m = n, n should be i
20:45:44 <shapr> Seen any guerilla art?
20:45:52 <dons> ah ha!
20:45:57 <bringert> dons: just hanging out
20:45:58 <dons> ?karma+ bringert
20:45:59 <lambdabot> bringert's karma raised to 1.
20:46:08 <shapr> They have poetry on the front of the steps in the bus stations.
20:46:25 <bringert> shapr: what pig? what roll-on building?
20:46:33 <bringert> I haven't been sightseeing enough
20:47:04 <bringert> my girlfriend is doing an internship at Microsoft Research, and I tagged along
20:47:15 <shapr> Who nifty
20:47:16 <shapr> whoa*
20:47:29 <shapr> The bronze pig is in Pike Place Market
20:47:35 <dons> bringert: i'm about to push a patch for that. will it clash with your patches?
20:48:51 <shapr> There's also a building with what appears to be a large sphere sticking out of the top just a bit. It was called the Ban Roll-On building after a popular brand of underarm deodorant that's the same shape but much smaller.
20:48:57 <bringert> dons: yes
20:49:23 <dons> ok. i'll leave it to you to fix that then?
20:49:47 <bringert> dons: ok
20:49:49 * dons unrecords
20:49:57 <bringert> phone
20:54:28 <bringert> shapr: I haven't been to Pike place market yet, it's on the list
20:54:48 <bringert> shapr: other tips for cool stuff are appreciated
20:57:26 <bringert> dons: I have to go now, I'll finish the patch tomorrow. If you want to patch the bug in the meantime, I can pull and resolve that on my end.
21:00:16 <dons> ok. will do. thanks
21:16:32 <dons> ooh, " (the Coverage Condition fails for one of the functional dependencies)"
22:18:07 <dons> http://www.arnnet.com.au/index.php/id;710118083;fp;256;fpid;56736
22:18:15 <dons> "The use of Haskell has given one of our sub-projects (the evolution of the kernel API
22:18:19 <dons>                into something suitable for high-security applications) a significant edge over
22:18:22 <dons>                competing projects."
22:24:20 <sieni_> "Like other developments of the original L4, Fiasco is also written in C++ for readability and portability reasons."
22:25:19 <sieni_> C++ readability of Fortran IV combined with the portablity of Assembler!
22:26:48 <dons> heh
22:28:56 <palomer> ho hum, another haskell fanatic. next thing you know they'll be saying code compiled with ghc is faster than equivalent code compiled in g++
22:29:08 <palomer> and then this'll turn into #java
22:29:09 <palomer> :(
22:29:14 <palomer> (or, rather, efnet #java)
22:29:21 <sieni_> template <class M, class K> struct Sig : public FunType<M,K,typename LEType<LAM<LV<2>,LET<BIND<1,CALL<M,LV<2> > >,CALL<CALL<K,CALL<Fst,LV<1> > >,CALL<Snd,LV<1> > >  > >::Type > {};
22:29:22 <Korollary> I've never been to any #java
22:29:30 <Korollary> I wonder what kind of people hang out there.
22:30:12 <palomer> freenode #java is great
22:30:19 <palomer> they have no qualms about making fun of their language
22:30:44 <palomer> my kind of people
22:30:47 <sieni_> palomer: I don't actually understand, why g++ would generate slower code than gcc if you run the same source files through it...
22:30:54 <Korollary> Do you have qualms about making fun of haskell?
22:30:59 <palomer> not gcc, ghc
22:31:05 <palomer> Korollary: none at all!
22:31:34 <Korollary> It's important not to confuse ghc with haskell, though.
22:31:36 <sieni_> palomer: well, but in the shootouts the gcc scores are much higher than g++ codes even though they are supposed to be the same compiler
22:31:37 <dons> palomer's just trolling since we asked him to stop being negative about haskell to newbies.
22:31:56 <dons> sieni_: you mean, ghc scores much higher than g++ :)
22:32:05 <Korollary> sieni_: It's not just the compiler. It's idiomatic c vs idiomatic c++ in those benches.
22:32:08 <palomer> oh no, it's starting
22:32:29 <bringert> dons: (I'm back for a limited time only, for the low low price of $9.99): I seem to need to change lots of stuff in Properties.hs. No problem to do it, it just made me realize that the types of the functions are no longer exactly compatible with the prelude list stuff
22:32:34 <sieni_> dons: No, I mean that the g++ implementations must be really crappy and nobody has bothered to run the c programs through it.
22:32:54 <dons> bringert: oh hmm. yes, should be easy to add a few fromIntegrals
22:32:56 <sieni_> Korollary: yeah right, and all those ghc extensions are idiomatic haskell
22:33:06 <Korollary> sieni_: I didn't say that, either.
22:33:14 <bringert> dons: oh and I'll skip changing mapIndexed, since it seems to require messing with your magic fusion stuff
22:33:21 <dons> ok.
22:38:31 <lispy> magic fusion -- now for the kids!
22:40:21 <Razor-X> dons: What happens if you use ByteString.unpack on the first piece of code you gave me earlier?
22:41:23 <dons> it'll unpack the byte string?
22:41:42 <Razor-X> Heh.
22:41:48 <Razor-X> Well, it's not working out quite that way :P.
22:42:03 <Razor-X> Unless I'm just being n00bish, which is completely possible.
22:42:31 <dons> @type Data.ByteString.unpack
22:42:32 <lambdabot> Data.ByteString.Base.ByteString
22:42:33 <lambdabot>          -> [Word8]
22:42:36 <dons> make sure the types are right
22:42:49 <dons> @type Data.ByteString.Char8.unpack
22:42:49 <lambdabot> Data.ByteString.Base.ByteString
22:42:50 <lambdabot>            -> [Char]
22:43:01 <Razor-X> Yeah, I believe the types should be correct.
22:43:23 <Razor-X> The code is compiling fine.
22:44:05 <dons> again, when you say "not working out quite that way", what on earth do you mean? :)
22:44:13 <Razor-X> Heh.
22:44:17 <dons> i have not hope of debugging a statement like that.
22:44:27 <Razor-X> I wanted to unpack the string and then apply a regex to it.
22:45:03 <Razor-X> But, just returning the unpacked string and printing it gives me nothing printed.
22:45:10 <lispy> Razor-X: post an example of what is happening, what should be happening and the code you're using to a pastebin :)
22:45:23 <Razor-X> Hmmm. I guess I must.
22:45:30 <lispy> it's usually the easiest way
22:45:31 <dons> the code should be a complete example, so i can type check and run it.
22:45:45 <dons> sounds like you must be unpacking an empty string.
22:46:10 <Razor-X> But then, if I use ByteString.Char8.putStrLn on that string before unpacking, it prints fine.
22:48:06 <dons> Prelude Data.ByteString> unpack empty
22:48:06 <dons> []
22:48:06 <dons> Prelude Data.ByteString> unpack (singleton 49)
22:48:06 <dons> [49]
22:48:06 <dons> Prelude Data.ByteString> unpack (pack [49,50,51])
22:48:09 <dons> [49,50,51]
22:48:32 <dons> luckily we have quickcheck properties to check this kind of thing mechanically.
22:48:41 <dons> so you'll need to post the code so i can work out what you're doing
22:48:56 <Razor-X> Ok.
22:51:19 <anandrd> i created an instance of Ord and Num and created factorial :: (Ord a, Num a) => a ->a
22:51:38 <anandrd> but it goes in infinite loops for all inputs except Zero
22:52:49 <dons> hmm. #debian's moving to oftc, and off freenode?
22:52:57 <dons> anandrd: did you forget a base case?
22:53:08 <anandrd> no
22:53:57 <anandrd> the code was - factorial x | x==0 =1; | x>0 = x * fact(x-1) etc.
22:54:48 <dons> > let f 0 = 1 ; f n = n * f (n-1) in f 10
22:54:49 <lambdabot>  3628800
22:55:20 <dons> @type let f 0 = 1 ; f n = n * f (n-1) in f
22:55:21 <lambdabot> forall a. (Num a) => a -> a
22:55:36 <Korollary> I don't get the part about creating an instance.
22:55:40 <dons> neither
22:55:42 <anandrd> it works for integers
22:55:50 <dons> @type let f 0 = 1 ; f n | n > 0 = n * f (n-1) in f
22:55:51 <lambdabot> forall a.
22:55:51 <lambdabot>                 (Ord a, Num a) =>
22:55:51 <lambdabot>                 a -> a
22:55:52 <anandrd> but not for the instance of Ord, Num I created
22:55:57 <Korollary> would you like to paste it all somewhere?
22:56:00 <dons> so you must have a funny instance?
22:56:01 <Korollary> lisppaste2: url
22:56:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:56:20 <bringert> dons: is it ok if I add a Model Int Int64, or would that mess up something else?
22:56:24 <anandrd> i have implemented integers as in peano
22:56:33 <dons> bringert: well, you can do it, i think.
22:56:46 <dons> i think i originally removed it only since i needed it in one place
22:56:57 <dons> but if we need more, then go for it.
22:57:03 <anandrd> data AbstractInteger = Zero | Pred AbstractInteger | Succ AbstractInteger       deriving Show
22:57:05 <Korollary> anandrd: Ah. I see.
22:57:07 <lisppaste2> Razor-X pasted "Bleh" at http://paste.lisp.org/display/20657
22:57:07 <dons> also, i just comitted a patch to QuickCheckUtils and Properties
22:57:13 <dons> bringert, you'll want to pull it.
22:57:28 <Razor-X> There ye go.
22:58:12 <dons> ok, looking...
23:00:36 <dons> Razor-X: do i need to hack it in anyway to get it to connect?
23:00:51 <Razor-X> Nope. You shouldn't need to.
23:00:54 <dons> cause i'm getting timeouts
23:01:02 <Razor-X> Well, hmm. Hold on.
23:01:08 <dons> ERROR :Closing Link: 127.0.0.1 (Connection Timed Out)
23:01:14 <Razor-X> Yeah, hmmm.
23:01:16 <dons> why 127.0.0.1?
23:01:21 <Razor-X> Really?
23:04:03 <dons> does it work for you?
23:04:04 <lisppaste2> Razor-X pasted "Blah reloaded" at http://paste.lisp.org/display/20659
23:04:33 <Razor-X> That should help stop the ping timeouts.
23:04:40 <dons> btw, have you looked at lambdabot? :)
23:04:49 <Razor-X> Somewhat :).
23:05:11 <Razor-X> I imagine this won't be nearly as clean as lambdabot, but ah well :).
23:05:36 <dons> actually lambdabots irc level is a bit messy, its very old and hasn't been polished for a while
23:05:55 <Razor-X> It uses a *lot* of Monads, heh.
23:06:00 <dons> that too
23:06:03 <dons> too many
23:06:10 <dons> oh, and the implicit parameters
23:07:00 <Razor-X> Ignore that commend in sendData.
23:07:06 <Razor-X> It's old/not of any use anymore.
23:07:08 <Razor-X> *comment
23:07:11 <Razor-X> :D.
23:07:35 <Razor-X> Agh. And ignore the commented bits in negotiate too.
23:07:49 <dons> hmm. still times out.
23:07:53 <Razor-X> Really?
23:08:05 <dons> it works for you?
23:08:12 <Razor-X> See?
23:08:47 <dons> ?
23:08:53 <dons> ah. Blargeth. hmm
23:08:56 <Razor-X> Yeah :).
23:09:04 <dons> oh it did work
23:09:09 <dons> it connected anyway
23:09:26 <bringert> why don't the standard libs have instances for Random IntNN and WordNN?
23:09:47 <dons> bringert: :(
23:10:44 <Razor-X> Heh.
23:10:45 <bringert> grr, and the ones in System.Random use some fancy non-exported functions
23:11:05 <dons> Razor-X: but i get no server outptu
23:11:11 <Razor-X> dons: I know :(.
23:11:24 <dons> how do you know its not blockign waiting for more?
23:11:40 * dons tries it without bytestrings
23:12:41 <Razor-X> Any output?
23:12:50 <dons> ope
23:13:12 <Razor-X> Well, instead of using BS.unpack (mind the shortening) and using a direct BS.putStrLn, it would work fine.
23:13:20 <dons> no. but I'd expect hGetContents not to produce any till the whole things read anyway
23:13:39 <dons> i get no output using plain strings either
23:14:16 <dons> so theres some logic error there. you're assuming you can get the last line, and print it. i don't know if thats giong to work
23:14:28 <Razor-X> Hmmm.
23:14:32 <dons> at least not till the server closes the socket
23:14:46 <Razor-X> How would you attempt to capture input then?
23:14:52 <dons> but since you have to interrupt anyway to quit, the socket never gets closed, hGetContents never returns
23:14:56 <Razor-X> I'm probably approaching this the wrong way on a fundamental lveel.
23:14:58 <dons> read a line at a time?
23:14:59 <Razor-X> *level
23:15:15 <Razor-X> I tried using hGetLine, but it wouldn't do anything. Let me try again.
23:15:20 <dons> sit in a loop, reading a line at a time.
23:15:32 <Razor-X> Yeah, that's what I was planning on doing initially.
23:15:32 <dons> rather than trying to lazily process the entire server output
23:18:18 <dons> this works fine:
23:18:20 <dons>   case ready of
23:18:20 <dons>     True -> do
23:18:20 <dons>             result <- BS.hGetLine server
23:18:20 <dons>             BS.putStrLn result
23:18:22 <dons>             stuff server
23:18:30 <dons> masses of output
23:19:36 <bringert> dons: maybe the QuickCheck tests could run in multiple threads
23:19:45 * bringert wants to use his dual core cpu
23:19:58 <dons> bringert: oh! and with ghc 6.5?
23:20:03 <dons> yeah, cool idea.
23:20:37 <bringert> I haven't actually tried running any multithreaded haskell code to see if it can use both cores
23:20:55 <dons> it should do, with 6.5
23:20:56 <bringert> not that the tests take that long, but it could be a general library thing I guess
23:21:15 <dons> well, they take a while
23:21:44 <Razor-X> dons: I'm getting nothing on that code :(.
23:22:42 <dons> trying with plain strings...
23:22:48 <dons> $ ./a.out 
23:22:49 <dons> NOTICE AUTH :*** Looking up your hostname...
23:22:49 <dons> NOTICE AUTH :*** Found your hostname, welcome back
23:22:49 <dons> NOTICE AUTH :*** Checking ident
23:22:51 <dons> also works
23:23:02 <dons> stuff :: Connection -> IO String
23:23:02 <dons> stuff server = do
23:23:02 <dons>   ready <- hReady server
23:23:02 <dons>   case ready of
23:23:02 <dons>     True -> do
23:23:04 <dons>             result <- hGetLine server
23:23:07 <dons>             putStrLn result
23:23:09 <dons>             stuff server
23:23:11 <dons>     _ -> stuff server
23:23:14 <dons> that's all
23:23:43 <Razor-X> Works with plain strings, but not ByteStrings.
23:23:48 <Razor-X> For me, anyhow.
23:23:53 <dons> what version of Data.ByteString are you using?
23:23:53 <Razor-X> :(. I liked the speed of ByteStrings.
23:24:20 <Razor-X> My distribution didn't come with it, so I'm using fps 0.6.
23:24:21 <Razor-X> Is that old?
23:24:30 <dons> you could try pulling the darcs version.
23:24:42 <dons> its had several improvements, though i can't think of any that would make a difference
23:24:53 <dons> however, it clealy is working for me using bytestring io.
23:24:58 <Razor-X> Hmmm.
23:25:20 <dons> so you might want to do use the latest code, if you're really keen on doing bytestring stuff here
23:26:03 <bringert> dons: You've got patch!
23:26:17 <bringert> I hope, I've never used darcs send from this machine before
23:26:43 <Razor-X> Hmmm. Where's the ByteString darcs?
23:26:55 <dons> ?where fps
23:26:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
23:27:01 <Razor-X> Thanks.
23:27:08 <dons> no patches yet bringert..
23:27:14 <bringert> hmm
23:27:46 * dons tries forkIO'ing all tests...
23:29:26 <bringert> dons: ok, I sent a copy from my mail client now
23:30:22 <dons> got it.
23:30:23 * bringert tries to remember what it was he was doing that prompted the ByteString patching
23:30:46 <dons> hehe. forkIO all these tests is kind of crazy 
23:30:53 <dons> , ,    1 1 11010 O00000 K00 0  ,  t t  ttete 1eeses 0sstst:0ttsts  ss.s.t..
23:31:02 <dons> hooray for scheduling
23:31:17 <xerox> atomically (print result) -- heh
23:31:38 <bringert> haha
23:32:29 <dons> patch looks good bringert , cheers
23:32:44 <bringert> heh, I made all the Int64 changes to ByteString.Lazy to avoid one fromIntegral. Now I need 9.
23:33:01 <dons> heh
23:33:20 <dons> but at least we can now take and drop terabytes :)
23:33:26 <bringert> yep
23:33:50 <dons> we can unrecord the patch once everyone's got a 64 bit box ;)
23:35:01 <bringert> what about an Offset type synonym that is Int64 on 32-it boxes and Int on 64-bit ones?
23:35:08 <bringert> (just kidding)
23:35:14 <Razor-X> Yeah, for me, ByteString's don't work, dons.
23:37:20 <dons> Razor-X: very strange. you've built and installed the fps version from darcs?
23:37:34 <dons> and recompiled your code against the new package?
23:40:05 <dons> yeah, works for me either way.
23:40:29 <dons> here's the code: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
23:41:03 <dons> i don't see any reason for it not to work. i've tested on two difference os' now. and it does the same thing lambdabot does.
23:41:10 <dons> so i suspect something you're doing is wrong.
23:41:21 <dons> rather than a buy in fps.
23:41:25 <dons> s/buy/bug
23:47:22 <Korollary> I think I will stop using 'a' as a type variable since it's confusing in mixed text.
23:48:00 <Korollary> id :: q -> q for me from now on.
23:49:11 <Cale> I find t to be pretty good when it would be otherwise confusing
23:50:50 <Cale> Or just use Greek letters:  foldr :: ( ->  -> ) ->  -> [] -> 
23:51:41 <Korollary> I am unicode challenged in this environment
23:51:50 <Korollary> I would prefer alpha myself too
23:52:21 <Cale> plus, GHC 6.4's lexer doesn't handle it.
23:52:58 <Korollary> It would take an extra keystroke on this keyboard anyway
23:54:40 <aleator> is there "make -j" equivalent for ghc --make?
23:56:45 <ADEpt> @seen dons
23:56:45 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 15 minutes and 20 seconds ago.
23:56:49 <ADEpt> morning
23:56:59 <ADEpt> dons: here? have time to talk about lambdabot?
23:59:41 <dons> morning. right here
