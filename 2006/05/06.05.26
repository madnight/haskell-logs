00:33:55 <norpan> yawn
01:21:17 <davidhouse> huh. gmail seems to be timing out. odd.
01:22:16 <davidhouse> oh, it's my screwy router again.
01:25:07 <davidhouse> @bot
01:25:07 <lambdabot> :)
01:25:20 <kep> davidhouse sometimes in the evening a i have time out with gmail :) 
01:25:45 <davidhouse> my router is definitely screwy though.
01:26:19 <davidhouse> whenever i start up my computer, it gets its DNS mixed up and any tabs i previously had open in firefox get redirected to completely different sites.
01:26:48 <davidhouse> e.g. say i'm looking at haskell.org when i shut down. when i boot up, i might be looking at google.com, even though it says 'haskell.org' in the address bar
01:28:41 <davidhouse> yay! things working again.
01:39:52 <kep> davidhouse: :)
01:49:29 <dcoutts> dons, it was c2hs that took 800M before I rewrote the lexer/parser
01:53:12 <dons> mornign dcoutts
01:53:23 <dcoutts> dons, g'morning
01:53:37 * dcoutts is reading dons's latest fps patches
01:53:53 <dcoutts> dons, any luck with the RULES ?
01:54:13 <dons> i didnt' get as far as solving the rules phasing issues -- spent my time merging in strict tuple stuff from the ndp branch
01:54:24 <dcoutts> right
01:54:28 <dons> also, you didn't record you stuff, so i was a bit wary of messing around with it.
01:54:36 <dons> oh,most of the fusion stuff is in Fusion.hs now
01:54:44 <dcoutts> yes I see
01:54:46 <dons> we should probably move Lazy.loopU in there too, under a new name.
01:54:57 <dcoutts> aye
01:54:59 <lisppaste2> davidhouse pasted "can this be done using modify?" at http://paste.lisp.org/display/20460
01:55:00 <dons> then all the rules and loops can be in one place.
01:55:22 <davidhouse> hi all. i'm wondering about record modifying functions. can the above paste use modify?
01:55:45 <dcoutts> dons, yes, my current fusion stuff is a bit experimental so I didn't record & send it
01:56:06 <dcoutts> dons, perhasp I should add it in a (huge) comment at the bottom of Fusion.hs
01:56:43 <eivuokko> davidhouse, Something like: modify $ \st -> st { currentStep = 1+currentStep st }
01:56:44 <dons> well, could you get un/up/down working you think? and we can use that as a base for the next stuff?
01:57:06 <dons> or is it all or nothing, mostly?
01:57:27 <dcoutts> dons, we can have un/up/down without map/filter, yes
01:57:46 <dcoutts> dons, but the rules arn't working fully yet so it's a regression
01:58:10 <davidhouse> eivuokko: yes, that's what i was thinking. not much prettier though. how about if it didn't depend on the current state's currentStep?
01:58:29 <davidhouse> i.e. can you say "{ foo = "blah" } :: Foo -> Foo"
01:58:39 <dcoutts> dons, but I guess I could add it in such a way that it doesn't clash with the current stuff
01:58:54 <dcoutts> dons, eg loopUp/loopDown and leave the current loopU alone.
01:59:00 <eivuokko> davidhouse, You need \x -> x { foo="blah" }
01:59:30 <davidhouse> hmn, okay.
02:00:27 <eivuokko> davidhouse, I think modify is mostly meant for situs when you have non-monadic interface with explicit state passing, in such situations modify works as sort of lift.
02:01:17 <dons> it might be good to add however far you get as a comment, if you don't get it all working, so i can play with it tomorrow
02:01:29 <davidhouse> modify is generally useful as a replacement for the get/process with f/put paradigm
02:01:48 <dcoutts> dons, ok
02:01:53 <davidhouse> sometimes, though, like here, it's better to use the expanded version. :)
02:02:49 <eivuokko> davidhouse, I don't know such paradigms
02:03:29 <davidhouse> i mean, when you find yourself doing something like st <- get; do some nonmonadic stuff with st; put st'; then often modify can be a cleaner replacement.
02:04:10 <davidhouse> e.g. how that code was when i was using a pair instead of a record:
02:04:43 <davidhouse> (x, step) <- get; let step' = step + 1; put (x, step') was more simply expressed as modify (second (+1))
02:06:18 <davidhouse> seperate question: if i wanted to do some IO inside a Parsec parser, I'd run into trouble, right?
02:06:38 <eivuokko> davidhouse, yeah.
02:06:50 <davidhouse> right, a more inventive solution is necessary.
02:07:29 <norpan> stoopid
02:08:21 <davidhouse> norpan: was than an accidental Alt+F4? :)
02:09:00 <dcoutts> dons, btw, why do we have noAL = NoAL ? why not just use NoAL everywhere, including in the RULES ?
02:09:15 <dcoutts> dons, and what does EFL stand for? :-)
02:09:16 <norpan> no that was me pulling the wrong power cord
02:12:26 <dcoutts> dons, and does foldEFL' make any sense now? isn't it always strict now?
02:15:29 <davidhouse> @hoogle sequence
02:15:30 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
02:15:30 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
02:15:30 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
02:15:38 <davidhouse> @fptools Control.Monad
02:15:38 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
02:20:02 <norpan> dcoutts: many questions, few answers? :)
02:20:25 <dcoutts> heh, I'm patient
02:21:16 <norpan> the RULES stuff seems rather fragile
02:21:32 <norpan> but that is to be expected with peephole optimizations i suppose
02:23:02 <davidhouse> @hoogle chr
02:23:03 <lambdabot> Char.chr :: Int -> Char
02:23:03 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
02:23:03 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
02:30:55 <Lemmih> dons: ping
02:45:22 <davidhouse> hmm... i can't decide which definition i like better:
02:45:38 <davidhouse> [ (h, []) | h <- hooks ] or zip hooks (repeat [])
02:45:52 <dons> Esomething Fusiong Loop ?
02:46:37 <joelk> dons, are there any plans for Read- and Show-like classes for ByteString? ('cause read . unpack is incredibly slow!)
02:47:09 <dons> you mean, a Read/Show class whose reesults are in ByteString?
02:47:14 <joelk> yeah
02:47:41 <dons> hasn't be mentioned before. probably people would jsut use the bytestring parsec that'll be written eventually. but its a nice idea.
02:48:16 <dons> dcoutts: feel free to replace noAL with NoAL, I think its just some ndp convention.
02:48:32 <dcoutts> dons, ok
02:49:20 <dcoutts> dons, and EFL ? element funtion loop ? :-)
02:49:37 <joelk> my little (*extremely* simple) myRead :: B.ByteString -> Float sped up my program (31 MB input file, three floats per line) from 3 minutes to 10 seconds over read . unpack.
02:49:52 <dcoutts> wow
02:50:14 <davidhouse> Read is quite slow in itself as well,
02:50:16 <dons> elelment, yes.
02:50:39 <dons> joelk, oh sure. unpack is about the worst thing you can do.
02:50:54 <dcoutts> dons, does the EFL type need to be so parameterised? I think it's second two parameters are always Word8
02:51:11 <dcoutts> type EFL acc   = acc -> Word8 -> (PairS acc (MaybeS Word8))
02:51:24 <joelk> But I had now idea how slow!
02:51:47 <joelk> this makes me very happy! no more waiting!
02:51:49 <mahogny> when is that packed string library faster than native strings? only for IO?
02:52:19 <dons> ported from the ndp branch. feel freeto simplify (since we always have the same array element type)
02:52:34 <dcoutts> dons, ok
02:54:15 <dons> mahogny: in all cases, I think
02:54:31 <dcoutts> dons, oh yeah, cons.
02:54:40 <dcoutts> dons, I think my coalescing cons was fine
02:54:46 <mahogny> dons, sounds like it should replace [Char] in the compiler then :)
02:54:55 <dcoutts> it's all just a matter of expectation
02:55:32 <dons> mahogny: but its a strict array type. you can't have the compiler work this out in all cases.
02:55:46 <mahogny> hm. yeah, I see the problem
02:56:07 <dcoutts> dons, basically you can't do that recursive construction, and that's ok
02:56:15 <mahogny> but just a few cases would be nice :)
02:56:19 <dcoutts> dons, afterall you can't do it for ByteString either
02:57:02 <dcoutts> dons, I did document it as being stricter that (:), and quite precisely too.
02:57:13 <dons> dcoutts: yeah, i agree . put in a clear statement, and revert to the strict coalescing cons.
02:58:16 * dons -> dinner
02:58:42 <mahogny> give dons for an argument, obtain dinner?
02:58:50 <mahogny> lazily? :o
03:11:55 <shapr> yow!
03:12:54 <Lemmih> dons, dcoutts: I've been thinking about a typeclass to cover ByteString and ByteString.Lazy.
03:13:23 <dcoutts> Lemmih, ah yes, and perhaps ones with some string encoiding too, eg utf8 ucs4
03:18:40 <davidhouse> how do i do a word boundary in Text.Regex regexes?
03:19:25 <davidhouse> or indeed just any whitespace
03:22:34 <jethr0> davidhouse: i guess you have tried "\w" and "\b"? :)
03:22:55 * jethr0 couldn't find supported regexp syntax in the Test.Regex docs :(
03:23:20 <dcoutts> it's almost certainly just standard POSIX regexps
03:23:55 <jethr0> yes, it said that somewhere. i'll go lookup what posix regexps exactly are
03:25:30 <davidhouse> apparently you use character classes, like [[:space:]]
03:27:46 <davidhouse> argh. i have three clocks on my desk, only one of them is right.
03:36:35 <damg> > let over n k = (fac n)/((fac k)*(fac (n-k))) where fac n = if n == 0 || n == 1 then 1 else n * fac (n-1) in 6 `over` 2
03:36:36 <lambdabot>  15.0
03:41:23 <davidhouse> @hoogle Num a => a -> Int
03:41:23 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
03:41:24 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
03:41:24 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
03:41:43 <davidhouse> what would you use to convert a Floating into an Integral?
03:41:57 <integral> @type toInteger
03:41:58 <lambdabot> forall a. (Integral a) => a -> Integer
03:42:03 <davidhouse> nope.
03:42:08 <davidhouse> @hoogle floor
03:42:08 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
03:42:16 <tromp> @type fromFractional
03:42:17 <lambdabot> Not in scope: `fromFractional'
03:42:18 <davidhouse> @hoogle toInteger . floor
03:42:18 <lambdabot> Hoogle Error: Parse Error: Unexpected character '. floor'
03:42:25 <davidhouse> @type toInteger . floor
03:42:26 <lambdabot> forall a. (RealFrac a) => a -> Integer
03:42:31 <davidhouse> cool.
03:42:47 <davidhouse> > let fac = product . enumFromTo 1; n `choose` k = toInteger . floor $ (fac n) / (fac k * fac (n-k)) in 6 `choose` 2
03:42:48 <lambdabot>  15
03:44:26 <davidhouse> > let n `choose` k = toInteger . floor $ (product [k..n]) / (product [1..n-k]) in 6 `choose` 2
03:44:27 <lambdabot>  30
03:44:34 <davidhouse> err... ooops :)
03:44:49 <tromp> > let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in pascal !! 6 !! 2
03:44:50 <lambdabot>  15
03:45:10 <davidhouse> hehe, nice.
03:45:33 <davidhouse> > let n `choose` k = toInteger . floor $ (product [k+1..n]) / (product [1..n-k]) in 6 `choose` 2
03:45:34 <lambdabot>  15
03:45:40 <tromp> > let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in pascal !! 200 !! 100
03:45:41 <lambdabot>  90548514656103281165404177077484163874504589675413336841320
03:46:00 <davidhouse> > let n `choose` k = floor $ (product [k+1..n]) / (product [1..n-k]) in 200 `choose` 100
03:46:00 <lambdabot>  90548514656103280680474743631187938442311687866457887080448
03:46:19 <tromp> oops
03:46:30 <davidhouse> oops?
03:46:36 <tromp> different!
03:46:45 <davidhouse> hmm!
03:46:54 <davidhouse> > let n `choose` k = floor $ (product [k+1..n]) / (product [1..n-k]); iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in 200 `choose` 100
03:46:55 <lambdabot>  Parse error
03:46:58 <davidhouse> oops
03:46:58 <bolrod> which is wrong ;p
03:47:03 <davidhouse> damn cut-n-past
03:47:22 <lightstep> i notices that HGL always paints the window with black before repainting, in unbuffered mode.
03:47:37 <tromp> the one that uses reals:)
03:47:43 <lightstep> is there a reason for this (perhaps to encourage people to use double buffering)?
03:48:05 <lightstep> davidhouse, you can use div instead of (/)
03:48:18 <davidhouse> i _always_ forget about div :)
03:48:43 <mahogny> lightstep, that's how opengl works
03:49:27 <lightstep> mahogny, HGL is not opengl, it's an interface to the graphical features of GDI and X1
03:49:29 <lightstep> 1
03:49:31 <davidhouse> let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]; n `choose` k = (product [k+1..n]) `div` (product [1..n-k]) in (pascal !! 200 !! 100) - (200 `choose` 100)
03:49:36 <davidhouse> > let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]; n `choose` k = (product [k+1..n]) `div` (product [1..n-k]) in (pascal !! 200 !! 100) - (200 `choose` 100)
03:49:37 <lambdabot>  0
03:49:43 <davidhouse> riiigh.
03:49:47 <davidhouse> *riiight
03:50:11 <mahogny> lightstep, true, but AFAIK that's still standard behaviour of opengl. why wouldn't you use double buffering anyway?
03:50:27 <davidhouse> i wouldn't expect it to be rounding, as they're integers all the way.
03:50:59 <davidhouse> > let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]; n `choose` k = (product [k+1..n]) `div` (product [1..n-k]) in (pascal !! 200 !! 100) == (200 `choose` 100)
03:51:00 <lambdabot>  True
03:51:12 <davidhouse> > let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]; n `choose` k = (product [k+1..n]) `div` (product [1..n-k]) in show (pascal !! 200 !! 100) == show (200 `choose` 100)
03:51:13 <lambdabot>  True
03:51:35 <lightstep> mahogny, i do, now. it's less comfortable since withWindow doesn't let you specify it, and you need to use openWindowEx and closeWindow
03:51:55 <ulfdoz> I think, the xpath api is currently very strange. :\
03:51:58 <ulfdoz> ECHAN, sorry
03:52:11 <lightstep> davidhouse, Double only had 53 or so bits of percision
03:53:04 <davidhouse> i thought Integer was had arbitrarily high precision
03:53:08 <davidhouse> s/was//
03:54:05 <lightstep> and it returns True, now that you use integers
03:54:08 <tromp> it does
03:55:03 <davidhouse> lightstep: yeah, but when they were printed out, they were different.
03:55:53 <lightstep> but then you computed using floats
03:56:36 <davidhouse> > let n `choose` k = (product [k+1..n]) `div` (product [1..n-k]) in 200 `choose` 100
03:56:36 <lambdabot>  90548514656103281165404177077484163874504589675413336841320
03:56:44 <davidhouse> aha.
04:21:27 * mux waves hello
04:22:11 <davidhouse> @hoogle ord
04:22:11 <lambdabot> Char.ord :: Char -> Int
04:22:12 <lambdabot> Prelude.Ord :: class Eq a => Ord a
04:22:12 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
04:24:56 * alar waves back
04:24:58 <jethr0> > ord True
04:24:59 <lambdabot>  Couldn't match `Char' against `Bool'
04:25:11 <jethr0> > fromEnum True
04:25:12 <lambdabot>  1
04:25:25 <davidhouse> jethr0: C-style bools :)
04:26:00 <davidhouse> > toEnum . (+1) . fromEnum $ False :: Bool
04:26:01 <lambdabot>  True
04:26:57 <alar> > toEnum ( (+) (fromEnum True) (fromEnum True) )
04:26:57 <lambdabot>  Add a type signature
04:27:02 <alar> > toEnum ( (+) (fromEnum True) (fromEnum True) ) ::Bool
04:27:03 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
04:27:31 <alar> no modulo autoconversion 
04:27:45 <alar> two truths don't make a lie
04:28:02 <jethr0> > let if' c t e = [t,e] !! fromEnum c in if' (4>3) "true" "false"
04:28:02 <lambdabot>  "false"
04:28:10 <jethr0> ups
04:28:16 <jethr0> > let if' c t e = [e,t] !! fromEnum c in if' (4>3) "true" "false"
04:28:17 <lambdabot>  "true"
04:29:01 <int-e> is there an xor anywhere?
04:29:05 <jethr0> xor
04:29:08 <jethr0> @type xor
04:29:09 <lambdabot> forall a. (Bits a) => a -> a -> a
04:29:11 <int-e> @hoogle Bool -> Bool -> Bool
04:29:12 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
04:29:12 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
04:29:27 <alar> @type (^)
04:29:28 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:29:37 <alar> @type (^^)
04:29:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
04:29:45 <alar> :(
04:29:52 <int-e> I haven't missed it so far though, interestingly.
04:30:35 <int-e> jethr0: oh yes. for binary values it's much more useful.
04:30:38 <alar> probably one doesn't need xor for booleans, only for bits
04:30:58 <eivuokko> It is likely that pattern matching is more usefull for two booleans than xor.
04:31:21 <eivuokko> It's not like you typically can use result for xor without pattern matching afterwards anyway
04:31:32 <jethr0> xor = (/=)
04:31:37 <int-e> @hoogle a -> a -> Bool -> a
04:31:39 <lambdabot> No matches, try a more general search
04:31:52 <int-e> jethr0: oh! right.
04:32:09 <eivuokko> Heh.  Good catch.
04:32:33 * int-e mutters something under his breath. You think you can make out the words 'blindingly obvious'.
04:35:34 <jethr0> > let xor a b = (==1) . sum . map fromEnum $ [a,b] in xor True True
04:35:35 <lambdabot>  False
04:36:31 <int-e> > let if' a b c = if c then a else b in if' not id True True
04:36:32 <lambdabot>  False
04:37:35 <jethr0> int-e: that reminds me of how lambda calculus does it :)
04:37:55 <int-e> jethr0: yes. I pondered calling if' pair for a moment.
04:38:57 <jethr0> > let true = fst; false = snd; if' = ($) in if' true ("true","false")
04:38:58 <lambdabot>  "true"
04:39:18 <tromp> >  let xor = (!=) in xor True True
04:39:18 <lambdabot>  Not in scope: `!='
04:39:21 <int-e> jethr0: and ($) = id
04:39:25 <tromp> >  let xor = (/=) in xor True True
04:39:26 <lambdabot>  False
04:42:50 <jethr0> > let xor a b = [False,True,True,False] !! idx where idx = 2^(fromEnum a)+(fromEnum b) in xor True False
04:42:51 <lambdabot>  True
04:44:14 <int-e> err.
04:44:21 <int-e> > let xor a b = [False,True,True,False] !! idx where idx = 2^(fromEnum a)+(fromEnum b) in xor False False
04:44:22 <lambdabot>  True
04:44:23 <jethr0> yes, there's sth wrong with my 2^ part
04:44:26 <jethr0> *cough*
04:44:41 <jethr0> > let xor a b = [False,True,True,False] !! idx where idx = 2*(fromEnum a)+(fromEnum b) in xor False True
04:44:42 <lambdabot>  True
04:44:45 <jethr0> > let xor a b = [False,True,True,False] !! idx where idx = 2*(fromEnum a)+(fromEnum b) in xor False False
04:44:46 <lambdabot>  False
04:45:15 <jethr0> it had felt wrong from the start :)
04:46:52 <jethr0> > let xor a b = [False,True,False] !! idx where idx = fromEnum a + fromEnum b in xor True True
04:46:53 <lambdabot>  False
04:47:07 <flux__> so, is ghc smart enough to rewrite that?-)
04:47:23 <mux> @karma mux
04:47:24 <lambdabot> You have a karma of 0
04:47:28 <mux> feh
04:47:47 <jethr0> rewrite what?
04:48:00 <flux__> that function into an actual xor :)
04:48:30 <dcoutts> probably not, no
04:48:52 <jethr0> i don't think so, but who knows how Bools are represented in the end... and also there's the "xor" function
04:49:34 <flux__> I suppose such lookup code could be identified and optimized, but why bother, when the only actual usage would be teasing the optimizer..
04:51:32 <jethr0> flux__: ahh, you mean the lookup code. no that definitely won't be optimized, because lists aren't arrays and are lazy, etc
04:51:44 <jethr0> *optimized to bitwise xor
04:55:20 <mux> dcoutts: would you be bored enough to take a look at some simple line shuffling program and see if you can think of something to optimize it? :-)
04:55:42 <dcoutts> mux, not just at the moment, I'm optimising something else :-)
04:55:55 <dcoutts> mmm, loop fusion
04:55:58 <mux> heh, FPS?
04:56:01 <mux> ok :)
04:56:11 <dcoutts> loop fusion is so cool
04:56:21 <dcoutts> can't do that in C!
04:56:38 <dcoutts> well, except by hand, which is hideous
04:56:50 * mux starts darcs pull to grab all duncan patches
04:57:02 <dcoutts> my new stuff isn't there yet
04:57:24 <dcoutts> though there is already dons existing loop fusion stuff
04:57:52 <mux> I should first learn about loop fusion
04:58:06 <mux> wasn't there some paper about it that you and dons were talking about?
04:58:15 <dcoutts> well the simple version in the code at the moment is not too hard to grok
04:58:16 <mahogny> what is loop fusion?
04:58:35 <dcoutts> the fps loop fusion is a special case of the general NDP fusion system
04:58:42 <RvGaTe> shapr: downloaded the compiler yesterday
04:59:00 <dcoutts> because we're only dealing with arrays of Word8 rather than arrays of anything
04:59:28 <dcoutts> mahogny, it's much like list fusion
04:59:37 <dcoutts> but for arrays
04:59:45 <mahogny> aha
05:00:08 <dcoutts> a trivial example is: suppose you have B.map f . B.map g
05:00:19 <dcoutts> then we can fuse that to B.map (f . g)
05:00:40 <dcoutts> but it's much more general since we can fuse not only map & filter but things like fold
05:00:53 <mux> mmm, nice
05:01:07 <mahogny> hm. can the compiler do such things?
05:01:07 <dcoutts> in general, anything that can be expressed as an uploop (or a dwonloop) with an accumulator
05:01:14 <RvGaTe> shapr: but im wondering, i downloaded ghc, looks like a command line interpreter, i guess there should be an editor that creates an .exe after compiling?
05:01:21 <dcoutts> mahogny, we can make it using ghc's RULES
05:01:30 <mahogny> aah
05:01:35 <mux> RvGaTe: ghc has ghci, an interactive interpreter, and ghc, a compiler
05:01:48 <mux> ghc --make -o foo foo.hs
05:01:51 <dcoutts> mahogny, ghc already uses the rewrite RULES to do list fusion
05:01:55 <RvGaTe> mux: im on windows
05:02:05 <mux> doesn't matter
05:02:11 <dcoutts> mahogny, we're working on the same thing but for arrays of bytes
05:02:39 <eivuokko> mux, There is no editor.  You must use commandline, and you can find ghc.exe as bin\ghc.exe on folder where you installed ghc.
05:02:48 <eivuokko> Err, RvGaTe
05:02:53 <RvGaTe> yes?
05:02:53 <mux> you want to say that to RvGaTe
05:02:55 <mux> yeah :)
05:03:03 <RvGaTe> oh
05:03:05 <eivuokko> RvGaTe, look what I addressed to mux
05:03:11 <RvGaTe> reading
05:05:13 <RvGaTe> probably a stupid question, but there do i execute that mux? "ghc --make -o foo foo.hs"
05:05:34 <mux> it's an example of how to compile a foo.hs source file into a foo program
05:05:36 <eivuokko> In directory where foo.hs is at.
05:05:53 <mux> ghc.exe must be in your $PATH
05:10:13 <shapr> RvGaTe: There's also Visual Haskell, though I don't know if it's production quality.
05:12:16 <eivuokko> It isn't, really, imo.  The Cabal that comes with it is too broken.
05:12:38 <eivuokko> It's not bad for editing, tho :)
05:13:32 * mux pets his vim
05:14:51 * sieni pets his clue bat
05:15:18 <RvGaTe> i think i need someone to guide me step by step to create a hello world from ground up :S
05:15:33 <yip> > "Hello, World!"
05:15:34 <lambdabot>  "Hello, World!"
05:15:44 <eivuokko> Should I learn GADTs?  Will they magically make my life more enjoyble vs type classes (and extensions) + existentials?
05:15:49 <yip> RvGaTe: there ya go! :D
05:15:54 <RvGaTe> ...
05:16:02 <RvGaTe> not using the bot
05:16:03 <dcoutts> RvGaTe, you'll need a console window (aka a DOS window) and a text editor
05:16:03 <mux> @palomer GADT
05:16:03 <lambdabot> Hrmph
05:16:09 <mux> @palomer
05:16:09 <lambdabot> Pfft
05:16:22 <yip> RvGaTe: what i wrote is a complete haskell program
05:16:31 <alar> what is @palomer?
05:16:40 <mux> quotes from palomer 
05:16:48 <dcoutts> RvGaTe, if you've got nothing better you can use Notepad, but make sure that you save the file as .hs and not .txt or it will not work.
05:17:04 <RvGaTe> yes, but i find it strange how to create an executeable of that...
05:17:18 <RvGaTe> dcoutts: i've got notepad++
05:17:24 <mux> heh
05:17:35 <dcoutts> RvGaTe, ok then in the DOS box, cd to the directory where you've saved your hello.hs file
05:17:35 <joe_k> main = print "hello world"
05:17:58 <dcoutts> RvGaTe, and then type: ghc hello.hs
05:18:01 <joe_k> prints the quotes... i guess print is the representational printer
05:18:24 <dcoutts> RvGaTe, assuming your hello.hs did contain: main = print "hello world"
05:18:57 <dcoutts> RvGaTe, so running  ghc hello.hs will create a main.exe file which you can then run from the DOS box
05:19:35 <RvGaTe> dcoutts: ok, what if ghc isn't recognized as a command
05:19:50 <dcoutts> RvGaTe, then ghc isn't on your PATH and you need to fix that
05:19:59 <yip> the mingw windows gcc port has a -mwindow flag or something, that causes the .exe to open a console window, does ghc for windows have such an option?
05:20:00 * joe_k gets a 289k hello world
05:20:52 <dcoutts> yip, you can pass flags to gcc duing linking using -optl-foobar
05:21:05 <eivuokko> yip, You can pass it to linker via generic linker-flag mechanism in ghc.  If you want to provide your own WinMain there might sometimes be linker order issues, tho
05:21:26 <yip> does ghc use mingw compiler on windows?
05:21:32 <dcoutts> yes
05:21:34 <yip> cool
05:22:14 <eivuokko> yip, If you say -fvia-C, yes.  It is always uses gcc for RTS.  And binutils are always used, even with ghc native codegen.
05:22:36 <eivuokko> ghc invokes binutils via gcc in newer versions.
05:23:27 <yip> hm... that reminds me, are there any docs for ghc-api yet?
05:23:42 <eivuokko> Apparently no.  Few mails and sourcecode.
05:24:08 <yip> where can i find the mails?
05:24:10 <RvGaTe> dcoutts: added ghc to the envirement vars, it worked, but didn't gave me .exe only, it provided me a .hi and a .o, what are those?
05:24:37 <eivuokko> yip, google for ghc-api or something.  I don't know - I haven't marked them myself.
05:24:51 <alar> RvGaTe: .o is  elf-style .obj
05:25:21 <yip> eivuokko: do you happen to remember which mailing list they are on?
05:25:47 <dcoutts> RvGaTe, the .o is an object file you get from compiling your module and the .hi is the compiled representation of the stuff exported from your module
05:26:01 <RvGaTe> like an error report
05:26:13 <dcoutts> RvGaTe, no, more like a .h file in C
05:26:15 <vincenz> dcoutts: he's gonna have to remove the .o file if it didn't make an exe, cause otherwise it will not contain the main stuff from rts
05:26:32 <vincenz> dcoutts: and then it'll only link and fail
05:26:45 <dcoutts> RvGaTe, so it's actually a two phase process, compile each .hs into an object file and then link them all together into an .exe
05:26:49 <dcoutts> vincenz, huh?
05:27:01 <dcoutts> we're not talking abot rts stuff
05:27:06 <vincenz> dcoutts: look
05:27:14 <vincenz> module Foo where main = ..
05:27:17 <vincenz> ghc --make foo.hs
05:27:20 <vincenz> -> .o
05:27:23 <eivuokko> yip, glasgow-haskell-users had some mails not too long ago.
05:27:27 <vincenz> ghc -main-is Foo --make Foo.hs
05:27:30 <yip> eivuokko: ok thanks i'll look
05:27:31 <vincenz> it will fail on linking
05:27:40 <vincenz> cause it won't have the blabla_main stuff
05:27:43 <dcoutts> ah I see
05:27:45 <vincenz> rm foo.o
05:27:47 <vincenz> ghc -main-is Foo --make Foo.hs
05:27:49 <vincenz> fine
05:28:02 <vincenz> cause it doesn't force recompilation
05:28:16 <dcoutts> RvGaTe, the point is that you can't make a .exe without a module called Main
05:28:18 <vincenz> (erm the first one , this one of course does)
05:28:39 <dcoutts> RvGaTe, and that Main module must contail a function main :: IO ()
05:28:43 <RvGaTe> dcoutts: yeah, i noticed
05:29:14 <dcoutts> RvGaTe, so when you have a mulit-module program (or lib) then you compile each Foo.hs into Foo.o (& Foo.hi)
05:29:49 <dcoutts> but to link them all together into an .exe you need to include Main.hs
05:30:03 <damg> http://en.wikipedia.org/wiki/Object_code
05:30:09 <dcoutts> RvGaTe, ghc --make is usually the easiest way to go
05:30:31 <RvGaTe> luckely in not into multi module stuff yet... gotta start off with 1 first
05:50:24 <sylvan> Poll: Has anyone used a function like "atanh" in a real application without also needing to use vectors and matrices? (I'm wondering wether some basic data structures and ops for linear algebra should be standard in languages - seems like the current standard functionality is somewhat arbitrary)
05:50:58 <vincenz> sylvan: that's an ambiguous question
05:51:11 <sylvan> Hmm.. it is?
05:51:23 <vincenz> if I reply no, it will confirm your case, instead of just bieng "no I never used atanh period"
05:52:10 <sylvan> I just don't ever use any of the more exotic math functions (i.e. anything but +-*/) in applications where I don't need vectors and matrices..
05:52:19 <sylvan> well replace atanh with sin or cos or whatever...
05:53:05 <sylvan> my point is that we have a bunch of operations on scalar value, but not even basic data structures for vectors and matrices (in most languages) while it seems to me that anytime you need to use the more exotic functions on the scalar values you also need vectors and matrices
05:53:27 <vincenz> sylvan: I think you're skewed by the domain you might be working in
05:53:31 <sylvan> probably
05:54:00 <sylvan> but any engineering applications (like control systems etc) does need vectors and matrices.. seems like something that should be standard...
05:54:06 <sieni> well, atanh is pretty much irrelevant, since it's trivially definable using logarithms
05:54:18 <vincenz> sieni: any trig function
05:54:33 <vincenz> sylvan: vectors are trivially made tho
05:54:39 <sieni> vincenz: no
05:54:47 <sylvan> I know I've worked on several applications where 3-4 different libraries had 3-4 implementations of vectors and matrices that needed to be marshalled back and forth
05:54:49 <vincenz> sieni: he's saying "any trig question"
05:54:52 <vincenz> sieni: not you
05:55:05 <vincenz> sylvan: what language?
05:55:10 <vincenz> and may I suggest: bad design?
05:55:13 <sylvan> C++ in that case
05:55:33 <sylvan> well write  a game, you have a physics lib, sound lib, graphics lib etc... all of them have their own concept of vectors etc...
05:55:35 <vincenz> it's obvious the different developers were not having a view on the full architecture then, or they could've merged these defintions
05:55:42 <sylvan> there's no *standard* vector library
05:55:53 <vincenz> sylvan: most libs have C ffi's tho
05:55:57 <sylvan> well exactly, the libraries are all independent
05:55:59 <vincenz> sylvan: so the point is kinda moot
05:56:50 <sylvan> well the problem arises when you download different libs on the net to incorporate in to your application and each and every one of them re-implements some functionality, it would be better if the language supported common things like vectors
05:57:13 <vincenz> sylvan: most libs are written in C
05:57:20 <vincenz> and C does not support much of anything of higher order types
05:57:36 <vincenz> or even much reus
05:57:37 <sylvan> yep, I'm thinking long-term here. In ten years would we be happy that we incorporated linear algebra libs in the language?
05:57:38 <vincenz> +e
05:57:54 <vincenz> sylvan: with decent languages it doesn't need to be in the language
05:57:54 <sylvan> anyway, I must run!
05:57:57 <vincenz> at most in the stdlib
05:58:07 <sylvan> yes I meant the stdlib, not language
05:58:18 <vincenz> or even a nonstd lib which is defacto used for those domains
05:58:28 <vincenz> like for instance boost is a nonstd defacto lib in c++ for many things
05:58:29 <damg> in c++ it would be boost ;)
05:58:37 * vincenz beeps damg 
05:59:04 <yip> forget about vectors, 5 years ago, every c++ library had it's own "String" class
05:59:20 <damg> (and it is still the same)
05:59:35 <damg> char*, std::string, QString, CString etc pp
05:59:43 <yip> yep
05:59:57 <vincenz> that's more a sociological thing than a language thing
06:00:37 <vincenz> time to do shopping
06:00:41 * vincenz is expecting guests
06:01:01 <damg> actually I wonder why they had to develop so many different string classes, I mean wstring and string are enough, plus if you really need it, you still have char*
06:01:42 <damg> that's the classic massive reinvention of the wheel :D
06:02:00 <dcoutts> damg, ah well there's the COM interoperability...
06:02:16 <dcoutts> I recall where I worked we had 5 different string systems
06:02:23 <damg> that still doesn't qualify reinvention of the wheel :P
06:02:31 <eivuokko> Memory handling is single biggest issue for C++ string classes.
06:02:34 <damg> you could do it on top of the std string
06:02:46 <dcoutts> damg, not that easily I think
06:02:54 <eivuokko> The another issue is encodings, which were lacking in most stdlib implementations very badly sometime ago.
06:03:13 <dcoutts> aye
06:03:20 <eivuokko> damg, I am fairly sure you couldn't.  Memoryhandling.
06:03:43 <damg> possible, I just take freepascal :D
06:03:54 <damg> the RTL is way too gorgeous there
06:04:25 <damg> although every dev also reinvents the wheel every time, e.g. SplitString
06:15:40 <int-e> mux: you wanted to write a shuffle program, right?
06:19:26 <mux> int-e: it's written; I'm looking for ideas on how to optimize it further
06:34:07 <vincenz> the new lambdabot syntax is quirky
06:34:08 <vincenz> >  take 10 v; v = 1:v
06:34:09 <lambdabot>  Parse error
06:34:11 <vincenz> > take 10 v; v = 1:v
06:34:12 <lambdabot>  Parse error
06:34:14 <vincenz> o.O
06:34:15 <vincenz> @version
06:34:16 <lambdabot> lambdabot 3p12, GHC 6.4.1 (Linux i686 3.20GHz)
06:34:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:35:25 <mauke> you broke it!
06:36:00 <damg> > 1+1
06:36:01 <lambdabot>  2
06:36:03 <damg> works
06:36:04 <damg> :D
06:38:36 <ValarQ> vincenz: what should that code do?
06:38:53 <mauke>  [1,1,1,1,1,1,1,1,1,1]
06:39:14 <ValarQ> but what does the ';' do?
06:39:22 <ValarQ> (or should)
06:39:34 <resiak> Didn't you always have to do let v = 1:v in take 10 v ?
06:39:50 <vincenz> must be an unpushed patch
06:40:11 <vincenz> > take 10 v; v = 1:v
06:40:11 <lambdabot>  Parse error
06:40:28 <mauke> there used to be an implicit let {...} in around the expression
06:40:30 <vincenz> dons: I think you forgot to commit RunPlugs?  Cause theres Parser in Lib 
06:40:34 <vincenz> mauke: it's gone again?
06:40:36 <nealar> > let v=1:v in take 10 v
06:40:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:40:50 <mauke> I don't know
06:40:52 <yip> > let v = repeat 1 in take 10 v
06:40:52 <vincenz> mauke: I just did a pull, still seems to be there
06:40:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:41:05 <vincenz> dons: Also there's no Lexer in Lib of lambdabot
06:41:07 <xerox> > replicate 1 1
06:41:09 <lambdabot>  [1]
06:41:12 <xerox> Err.
06:41:14 <xerox> > replicate 10 1
06:41:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:42:50 <nealar> What Point, Line, Box and Path have to do with HSQL??
06:42:52 <mauke> > foldr id [] $ replicate 10 (1 :)
06:42:53 <Ulfalizer> > replicate (-2) 7
06:42:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:42:54 <lambdabot>  []
06:43:46 <Taldor> is there a predefined function to print a list (of Integers)?
06:44:00 <nealar> Taldor: show?
06:44:05 <nealar> > show [1,2,3]
06:44:06 <lambdabot>  "[1,2,3]"
06:44:42 <Taldor> > putStrLn (show [7, 8, 9])
06:44:43 <lambdabot>  No IO allowed
06:45:16 <jethr0> > sequence (replicate 3 (replicate 3)) 1
06:45:17 <lambdabot>  [[1,1,1],[1,1,1],[1,1,1]]
06:45:24 <Taldor> ghc gives a parse error there
06:45:35 <sieni> > foldl1 (++) $ map show [1,2,3]
06:45:36 <lambdabot>  "123"
06:47:07 <jethr0> > sequence (sequence (replicate 3 replicate) 3) 1
06:47:08 <lambdabot>  [[1,1,1],[1,1,1],[1,1,1]]
06:47:46 <dons> vincenz: it uses haskell-src for the lexer.
06:47:50 <Taldor> oh .. putStrLn ("abx") doesn't work either, so something else must be wrong...
06:47:57 <nealar> > foldl1 (\x-> \y-> x ++" "++y) $ map show [9,10,11]
06:47:58 <lambdabot>  "9 10 11"
06:47:59 <vincenz> dons: still RunPlugs still uses the old code?
06:48:30 <int-e> vincenz: but the Plugs plugin does its own expression parsing now
06:48:40 <int-e> > }{
06:48:40 <lambdabot> plugs module failed: Internal error: empty context in lexToken
06:48:46 <jethr0> > unwords $ map show [9,10,11]
06:48:47 <lambdabot>  "9 10 11"
06:48:54 <vincenz> aha
06:49:18 <vincenz> now I see
06:49:26 * vincenz was looking at script/Plugs
06:49:26 <dons> oh, should catch that.
06:50:07 <lisppaste2> int-e pasted "shuffle program (for mux)" at http://paste.lisp.org/display/20469
06:50:14 <dcoutts> dons, I'm still having trouble with the RULES, I'm building ghc from darcs now
06:50:23 <int-e> mux: this should be as efficient and it's much more concise.
06:50:46 <dcoutts> dons, I've got a good test case though, I can see instances where sequenceLoops is not getting matched 
06:50:54 <dcoutts> though I still can't see why not
06:51:00 <sieni> @pl (\x y -> x ++ " " ++ y)
06:51:00 <lambdabot> (. (' ' :)) . (++)
06:51:12 <dcoutts> the expressions are more complex that I expected
06:51:33 <dons> oh, that could be stable not cleanign things up as well.
06:51:38 <nealar> sieni: the result seems like a kind of smile
06:52:01 <dcoutts> dons, right, so I'll see what it's like with ghc head.
06:52:08 <sieni> > foldl1 ((. (" "++)).(++)) $ map show [1..10]
06:52:09 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
06:52:14 <dcoutts> dons, but I've got all 23 rules implemented
06:52:22 <dcoutts> and done the strict pair stuff
06:52:23 <dons> great!
06:52:42 <dcoutts> and tidied up some of the existing code
06:52:46 <dons> dcoutts: also note that to build fps with the head will need some tricks. (since Data.ByteString is also in the base package)
06:52:56 <dcoutts> ah, hmm
06:53:05 <jethr0> > concat . intersperse " " $ map show [9,10,11]
06:53:06 <lambdabot>  "9 10 11"
06:53:16 <dons> your best bed, i think, is to move all of fps' Data/* into base/ and build it there.
06:53:20 <dons> s/bed/bet/
06:53:37 <dons> that works fine for me.
06:53:42 <dcoutts> dons, or just rename the modules
06:54:07 <dons> or that.you need to edit the base/ Makefile and package.conf and .cabal file. or t
06:54:25 <dons> grr. packets floating away
06:54:33 <dcoutts> :-)
06:54:34 <dcoutts> dons, I've renamed NoAL to NoAcc since that makes other names nicer, eg fuseNoAccNoAccEFL rather than fuseNoALNoALEFL
06:55:23 <mux> int-e: nice, it's also faster
06:55:46 <dcoutts> doNoALLoop/doNoAccLoop etc, more readable, fewer CAPS
06:56:04 <vincenz> donsALLoop / donsAccLoop
06:56:14 <int-e> mux: if you do the selection stuff (the loop in shuffle) in IO you can avoid one intermediate list; I wanted to write a shuffle function with a nice signature though.
06:56:48 <mux> int-e: I don't much the ST thing, I'll have to read a bit about it
06:56:52 <mux> +know
06:57:22 <dcoutts> dons, also that way it fits with the code, where you're always writing 'acc' as the variable name rather an 'al'. Still, I'm not sure what you think about deviating too much from the ndp names.
06:58:18 <int-e> mux: it's similar to IO but for arrays and references only; there's no interaction with the outside world possible. in GHC, IO is actually a special ST instance.
06:58:26 <dons> yeah, looks better. don't mind too much.
06:58:33 <yip> does haskell have stuff for serial port programming?
06:58:51 <dons> yip, its a general purpose language. so sure.
06:58:53 * int-e looks for a better word to use for 'instance' there.
06:59:19 <mahogny> yip, asked the same before, but no one knew a library. if you are on unix it's quite easy to do though; ordinary file IO works
06:59:37 <yip> mahogny: i'm actually interested in a cross-platform way that will work on windows and unix
06:59:44 <int-e> mux: due to the limitations, runST is safe while unsafePerformIO - which does the same for IO - isn't.
06:59:55 <mahogny> yip, yeah, thought so. feel free to code it :) I don't think it is very hard
06:59:58 <mux> int-e: mm, I see, ST is somehow a generalization of monads with side effects on a "world" ie global state?
07:00:08 <mahogny> yip, you need to know some FFI for the windows port though
07:00:48 <int-e> mux: sort of. each runST creates its own small world for the operations.
07:00:51 <yip> mahogny: hm.. maybe i can just ffi directly to an existing cross platform c serial port library. do you know of one?
07:00:55 <mux> ok, got it
07:01:21 <mahogny> yip, the situation is equally bad when it comes to C to my knowledge. at least there are no major ones
07:01:59 <mux> int-e: can I rightfully account the IO -> ST change for some of the performance gain?
07:02:31 <dons> dcoutts: considering the 4 or 5 ghc patches that have come out of the ndp rule hacking, it may even be a bug. so if you can't solve the problem with the head, ask spj or jaffaCake.
07:02:38 <int-e> mux: no, IO should be just as fast. (in ghc: IO = ST RealWorld#)
07:02:45 <mux> ok
07:02:49 <dcoutts> dons, right
07:02:57 <dons> we can at least get some advice.
07:03:22 <dcoutts> yeah
07:03:33 <dons> (since we're pushing things in a different direction now to the ndp project, with this up/down loops stuff. ours is becoming more complex, i think)
07:03:47 * nealar can't find where "runghc" binary should go from
07:03:55 <dcoutts> though actualy that's not where the problem is at the moment
07:04:47 <dcoutts> dons, I'll send you my current stuff
07:05:13 <dcoutts> dons, it doesn't change to the new impl, that's included but commented out. It does include the various tidyups.
07:05:25 <dons> ok. cool.
07:05:35 <dons> i thought the current problem was rule matching not matching?
07:05:58 <dons> or is it phasing and other intrickycies
07:09:01 <nealar> dons: GHC page says you've build GHC-6.4 distribution for OpenBSD. Shouldn't it also fork for FreeBSD?
07:09:48 <nealar> frok-> work
07:10:04 <mux> what's the problem with FreeBSD's GHC port?
07:10:44 <nealar> mux: there isn't GHC-6.4 for BSD 4
07:10:57 <mux> oh. why don't you update to 6.x ?
07:12:10 <nealar> mux: I'll upgrade my home system, but I can't upgrade system on the server I was granted use of
07:12:29 <nealar> simply because I'm not the owner of the server
07:12:35 <dons> int-e, vincenz: do you guys have local lambdabot installations , just so you can play at breaking it?
07:12:42 <dons> how did you know about the various parser patches?
07:13:12 * nealar is amazed by cross-BSD differences
07:13:21 <int-e> dons: I don't.
07:13:40 <Kasperle> nealar: fbsd 4 will only get security updates until januar 31 2007 though...
07:13:59 * mux nods
07:14:17 <int-e> Hmm. "ghc-6.5: not built for interactive use" What do I have to pass to configure to build ghci?
07:14:47 <dons> int-e, sounds like you're one build stage short.
07:14:53 <dons> try compiler/stage2/ghc-inplace
07:14:58 <int-e> dons: I look at your darcs repository in a web browser.
07:14:59 <dons> --interactive
07:15:36 <nealar> Kasperle: they didn't intend releasing of FBSD-4.11 before, so I'm not sure they'll drop updating security so soon
07:17:02 <int-e> dons: that works. that's a bit strange - it's from the same directory that I made 'make install' from.
07:18:50 <Kasperle> nealar: yeah, the fbsd 4 EoL date has been pushed back quite a few times now. but with the supposedly last release of the fbsd 5 branch announced today, i don't know how much longer you'll see that happening
07:19:48 <ski> Taldor : got it working ?
07:19:58 <neologism> Kasperle: current policy is that sw from ports doenst have to work on 4.x
07:22:20 <nealar> Kasperle: the last release of fbsd5 is announced already? Then the days of fbsd4 are all accounted
07:22:24 <sieni> > ((. ("a"++)).(replicate)) 7 "b"
07:22:25 <lambdabot>  ["ab","ab","ab","ab","ab","ab","ab"]
07:23:33 <ski> > let (.:) = (.) . (.) in ("a"++) . replicate $ 7 "b"
07:23:34 <lambdabot>  Couldn't match `[Char]' against `t -> t1'
07:23:42 <ski> > let (.:) = (.) . (.) in ("a"++) .:replicate $ 7 "b"
07:23:42 <lambdabot>  add an instance declaration for (Num ([Char] -> Int))
07:24:24 <Kasperle> nealar: from the 5.5 release announcement:
07:24:27 <Kasperle> This is the last planned release on the 5-STABLE branch. The FreeBSD development community is currently focusing its efforts on the 6-STABLE and CURRENT codelines. No new major features are planned for the 5-STABLE branch, although minor updates and bugfixes may be merged at the discretion of individual developers. 
07:24:43 <nealar> oh, thanks
07:24:47 <nealar> didn't know this
07:24:51 <Kasperle> http://www.freebsd.org/releases/5.5R/announce.html
07:24:56 <ski> ah
07:30:23 <dcoutts> dons, found the bugger. Let floating.
07:31:21 <dons> ah! how so?
07:31:41 <dons> do we need a special no let float flag?
07:31:44 <dcoutts> we need:
07:31:45 <dcoutts> sequenceLoops (doUpLoop f1 acc1) (doUpLoop f2 acc2)
07:31:51 <dcoutts> that's what we match against
07:31:59 <dcoutts> but we've ended up with:
07:32:05 <dcoutts> sequenceLoops (doUpLoop f1 acc1) (let foo = bar in doUpLoop foo acc2)
07:32:18 <dcoutts> or more precisely...
07:32:46 <dcoutts> sequenceLoops (doUpLoop f1 acc1) (let f1 = ...; f2 = ... in doUpLoop (fuseAccAccEFL f1 f2) acc2)
07:33:00 <dcoutts> so the thing is that the rule can and should match!
07:33:10 <dcoutts> because the body of the let is of the correct form
07:33:24 <int-e> mux: oh, I didn't see you read multiple files; you can replace  input <- B.getContents  by  input <- fmap B.concat $ mapM B.readFile =<< getArgs  for that. Or maybe do the concat later, on the list:  input <- mapM B.readFile =<< getArgs  two lines below use  concatMap B.lines input  instead of  B.lines input.
07:33:43 <dcoutts> dons, but because the f1, f2 have been floated out then ghc currently doesn't make the rule match
07:34:01 <dcoutts> dons, so I think the problem is not the floating but the RULE matching
07:34:15 <dcoutts> dons, is this the kind of case that spj just fixed in ghc head?
07:34:22 <dons> maybe, yes.
07:34:29 <dcoutts> or was that a different let example
07:34:32 <dcoutts> well see I guess
07:34:43 <dcoutts> or I could read the commit message again :-)
07:35:05 <dons> or even just query them?
07:35:19 <dons> see if we can get a bit more insight from ghc hq on this rules business
07:35:50 <dcoutts> JaffaCake!
07:36:12 <dcoutts> JaffaCake, can we ask you about rule matching?
07:36:31 <dcoutts> it's related to fps/ndp style array fusion
07:36:47 <nailor2> is it a bug or is it a feature that ghci says Char.isAlpha '§' is true whereas hugs does not think so
07:37:14 <dcoutts> nailor2, check the unicode property tables to find out
07:37:27 <dons> (i know roman-ndp-hacker is in cambrdige right now working on rules stuff, so its very topical atm)
07:37:38 <int-e> dons: (about the ghci problem) hmm, making install again fixed it. I don't know what went wrong.
07:38:04 <nailor2> so its a feature... but how do i check 'the unicode property tables'?
07:39:14 <dons> mux, int-e, is there a way to avoid the concat. it will involve a copy which might be expensive on large strings.
07:39:51 <int-e> dons: yes, the second suggestion does that.
07:39:57 <Igloo> nailor2: According to gucharmap it's "Unicode category: Symbol, Other", so it looks like a bug to me
07:39:59 <dcoutts> nailor2, http://unicode.org/
07:41:53 <dcoutts> dons, ha ha!
07:41:54 <dcoutts>   Consider a RULE like
07:41:55 <dcoutts>         forall arr. splitD (joinD arr) = arr
07:41:55 <dcoutts>   
07:41:55 <dcoutts>   Until now, this rule would not match code of form
07:41:55 <dcoutts>         splitD (let { d = ... } in joinD (...d...))
07:41:57 <dcoutts>   because the 'let' got in the way.
07:42:16 <dons> ah! that's the blighter, isn't it?
07:42:20 <dcoutts> dons, yep
07:42:27 <dcoutts> exactly the case I've been running into
07:42:33 <dcoutts> sequenceLoops (doUpLoop f1 acc1)
07:42:33 <dcoutts>               (let f1 = ...
07:42:33 <dcoutts>                    f2 = ...
07:42:33 <dcoutts>                 in doUpLoop (fuseAccAccEFL f1 f2) acc2)
07:42:57 <lisppaste2> int-e annotated #20469 with "handling multiple files" at http://paste.lisp.org/display/20469#1
07:42:59 <dons> yep. and i think i had this problem also when trying to rewrite left over maps back into map'
07:43:27 <dons> int-e, also B.readLines will be a tad better than B.lines =<< B.getContents
07:43:28 <dcoutts> dons, so I'll try ghc head as soon as it finnishes compiling :-)
07:43:35 <dons> cool.
07:43:49 <dons> the core will also be a lot nicer, it cleans up the inlining better than stable
07:45:48 <dons> bedtime. i hope there'll be some fun new patches to play with in the morning...
07:46:11 <dcoutts> dons, yep I'm sending it now
07:46:25 <dons> dcoutts: and just mention anything you think i should look at or chase up.
07:46:33 <dcoutts> ok
07:46:34 <int-e> dons: I wouldn't expect a big difference between those two - is that expectation wrong?
07:46:52 <dons> there's a bit of a difference on very large files. getContents uses realloc to extend the buffer.
07:47:04 <dons> whreas readLines lazily pulls in a line at a time.
07:47:12 <dons> so it won't get caught on huge files.
07:47:22 <nailor2> Igloo so you have any idea how to nicely fix it... instead of looking if the char is in ['a'..'z'] or ['A'..'Z']
07:47:25 <dons> (i.e. 1/2 or your ram or bigger)
07:47:28 <vincenz> dons: I have oasisbot, remember
07:47:29 <int-e> hmm. the code needs to have everything in memory anyway.
07:47:34 <dons> of
07:47:41 <dons> vincenz: ah, of course.
07:47:49 <vincenz> I was trying
07:47:57 <vincenz> > v; v= v+&
07:47:57 <lambdabot>  Parse error
07:48:00 <Igloo> nailor2: File a bug? Also, isAlpha is not the same is being in ['a'..'z'] or ['A'..'Z']
07:48:02 <vincenz> and it didn't work in lambdabot anymore
07:48:05 <vincenz> hence me updating oasisbot
07:48:06 <dons> vincenz: then you'll want to pull the `security' patches i made today :)
07:48:07 <int-e> dons: anyway, good night
07:48:15 <vincenz> dons: the one with the parseR? Yep I did
07:49:00 <dons> yep. bedtime. night guys. (/me thinks he should move to the east about 10 hours sometimes)
07:49:13 <vincenz> night dons
07:49:20 <vincenz> @localtime od
07:49:21 <vincenz> @localtime dons 
07:49:22 <lambdabot> Local time for dons is Sat May 27 00:42:47 2006
07:49:25 <vincenz> @localtime vincenz
07:49:36 <Igloo> dons: I'd say 11 hours  :-)
07:49:37 <vincenz> @localtime oasibot
07:49:41 <vincenz> blegh
07:49:49 <vincenz> nearly 5pm
07:49:57 <Igloo> Oh, hang on, that's the wrong way
07:49:59 <vincenz> Igloo: or else he lands in the ocean?
07:50:02 <nailor2> ok, i will file a bug... an isAlpha, that allows only chars in these ranges is far better than an isAlpha that allows '§', though
07:50:32 <Igloo> vincenz: I was aiming for the UK. Badly.
07:50:55 <int-e> @pl \f x y z -> f z x y
07:50:55 <lambdabot> (flip .) . flip
07:53:38 <Wikipedia-Gast> sorry about the disconnect... lame java applet... said nothing important, did you
07:55:02 <JKnecht> Wikipedia-Gast: there's an archive where you can check ...
07:55:44 <JKnecht> http://meme.b9.com
08:16:24 <jethr0> /quit
09:07:49 <Lemmih> ndm: Hey.
09:17:25 <ndm> Lemmih: hey
09:30:22 <malcolm> hey ho
09:35:03 <Lemmih> ndm: re. FilePath. I'm not sure.
09:35:27 <ndm> Lemmih: what are your general thoughts?
09:36:24 <Lemmih> ndm: I want to unify them and put it in the standard libraries (in base).
09:36:40 <ndm> Lemmih: yep, that sounds great :)
09:37:00 <Lemmih> JaffaCake: ping.
09:38:12 <davidhouse> ihope_, some pretty cool things have been happening with smatiny :)
09:38:24 <ihope_> Like what?
09:38:29 <davidhouse> the interpreter has got a schmancy new modular system
09:38:53 <ihope_> Yep, sounds pretty cool.
09:38:54 <davidhouse> adding a new command is now a matter of 1) write the parser and interpreter in a seperate module 2) add it to the config
09:39:27 <davidhouse> so you can turn on or off commands at will. the only built-in is "Do nothing" (so we can fall back on it for nonexistant steps)
09:39:39 <davidhouse> i'm one compilation error away from releasing it.
09:39:51 <davidhouse> (including input suppport)
09:40:19 <ihope_> What error's that?
09:40:29 <davidhouse> resulting from my weirded-up use of existentials.
09:40:45 <davidhouse> i need to figure out a better way of doing it.
09:40:48 <Igloo> Lemmih: You likely won't find him after 5pm UK time
09:41:21 <davidhouse> ihope_: oh, just to clarify:
09:41:40 <davidhouse> with input, do we read a character in, then do a reverse lookup on the ASCII table, then use that as the swap number?
09:41:47 <ihope_> Yeah.
09:42:03 <davidhouse> right. that's okay then.
09:42:13 <davidhouse> that does limit your programs with input to < 255 steps
09:42:28 <davidhouse> unless you do all your working in the steps > 255, then drop back below that when you need to input
09:43:06 <ihope_> Yeah, that's more-or-less what you'd have to do.
09:43:10 <Lemmih> ndm: I think Simon is OK with it. Perhaps we should just go ahead and do it.
09:44:32 <ndm> Lemmih: cool, sounds good - how do you want to split up the work?
09:44:50 <ndm> we need to figure out what the functions are, what the differences are, merge the common bits, and get the windows bit up and going
09:44:55 <ndm> i'm happy to do it all, if you want
09:45:13 <dcoutts_> dons, oh yes.
09:45:18 * dcoutts_ is very pleased
09:45:32 <dcoutts_> ==================== Simplifier phase 2, iteration 2 out of 4 ====================
09:45:33 <dcoutts_> 117 RuleFired
09:45:33 <dcoutts_>     39 loop/loop wrapper elimination
09:45:33 <dcoutts_>     39 loopArr/loopSndAcc
09:45:33 <dcoutts_>     39 up/up loop fusion
09:45:55 <dcoutts_> That is a perfect result.
09:46:27 <Lemmih> ndm: That'd be great. I'm up to my ears in work.
09:47:26 <ndm> Lemmih: cool, i'll try and mutate my repo to the contents of your one + my one
09:48:56 <ndm> and give you an email when i'm done, for you to give it a check
09:49:22 <Lemmih> @karma+ ndm 
09:49:22 <lambdabot> ndm's karma raised to 7.
09:51:36 <ihope_> @type Control.Monad.Reader.ap const const
09:51:37 <lambdabot> forall a. a -> a
09:56:43 <ndm> Lemmih: how much freedom is there to change any of the interfaces/names from your FilePath?
09:56:54 <ndm> or is Cabal tied to them pretty strongly
09:59:37 <Lemmih> ndm: I think it's OK to redesign the library completely. Cabal will still use its own copy.
10:00:47 <ndm> Lemmih: cool, should have it done in about a week
10:06:27 <davidhouse> if you use a record, does that limit you to a single constructor for that type?
10:07:07 <Lemmih> davidhouse: No.
10:07:26 <davidhouse> huh.
10:07:37 <davidhouse> data T = A | R { r :: Bool }
10:07:45 <davidhouse> what's the value of r A?
10:07:54 <Lemmih> _|_
10:08:14 <davidhouse> right, okay.
10:12:34 <davidhouse> that's weird.
10:12:42 <davidhouse> are there any other exceptions that arise in nonmonadic code?
10:12:53 <davidhouse> oh, pattern match failures.
10:15:42 <int-e> division by 0.
10:16:24 <davidhouse> not an error,
10:16:27 <davidhouse> > 1/0
10:16:28 <lambdabot>  Infinity
10:16:33 <int-e> > 1`div`0
10:16:34 <lambdabot>  Exception: divide by zero
10:16:38 <davidhouse> (that still annoys me :))
10:17:00 <Lemmih> dcoutts_: What did you compile?
10:17:12 <dcoutts_> Lemmih, a fuse test program
10:17:57 <dcoutts_> Lemmih, so we can now fuse more kinds of loops including special treatment for special cases like maps & filter
10:18:41 <dcoutts_> and even when we can't fuse (eg can't fuse up loops with down loops) we can still avoid allocaing memory for each phase
10:18:57 <dcoutts_> by getting them to work in-place on one buffer
10:20:37 <MrHuskell> Is HOpengl the lib to go for if I whant to do some 3D graphics in Haskell? 
10:23:15 <dcoutts_> MrHuskell, yes.
10:24:00 <dcoutts_> MrHuskell, and as a bonus HOpenGL works with GLUT, Gtk2Hs and wxHaskell if you need to do some traditional 2D GUI stuff
10:24:25 <MrHuskell> Nice, didn't know that 
10:25:45 <MrHuskell> I was checkin the HOpengl page out, I can spot ver 1.5 of HOpenGL but i've seen some talk of HopenGL 2.0 or is it just me confusing the numbers here?
10:26:18 <MrHuskell> sry 1.05
10:27:55 <smithj> is this hte correct place to ask about hugs? #hugs seems to be OT
10:28:22 <dcoutts_> smithj, it's certainly worth a go
10:29:02 <dcoutts_> smithj, or since your a gentoo dev you can ask in #gentoo-haskell :-)
10:29:23 <smithj> dcoutts_: well, this is actually about packaging it for a non-gentoo distro :-)
10:29:30 <dcoutts_> hah, ok
10:29:34 <smithj> when compiling, i get "../../packages/Cabal/examples/hapax.hs: can't find source for module Data.ByteString.Char8"
10:29:42 <smithj> many build errors ensue
10:30:08 <dcoutts_> hmm
10:30:15 <davidhouse> Writer question: why doesn't tell automagically `mappend` its parameter to the current monoid? it's annoying to have to do tell ["message"]
10:30:29 <davidhouse> s/automagically/automatically -- nothing really magic here
10:30:59 <smithj> i'm actually really new to haskell; i'm trying to get an enviroment in which I can learn it
10:31:04 <dcoutts_> smithj, so does Data/ByteString/Char8.hs exist in the base lib.
10:31:16 <dcoutts_> smithj, then emerge hugs98 ghc-bin :-)
10:32:06 <smithj> dcoutts_: i'm trying to bootstrap haskell support for a distro which currently has *none*
10:32:29 <dcoutts_> smithj, you mean like ghc? since you can't bootsrap that with hugs
10:32:41 <dcoutts_> smithj, check out what we do for gentoo
10:32:50 <smithj> dcoutts_: i was told that ghc was written in haskell
10:33:00 <dcoutts_> yep, but it needs itself to build :-)
10:33:02 <smithj> yeah, i should probably do that since gentoo users have to bootstrap anyway :-)
10:33:03 <dcoutts_> smithj, hugs98 is easy (if it builds)
10:33:21 <dcoutts_> smithj, what we do for gentoo is provide ghc-bin and ghc.
10:33:55 <dcoutts_> smithj, ghc deps on virtual/ghc and ghc-bin and ghc provide virtual/ghc
10:34:07 <dcoutts_> smithj, so that allows users to bootstrap
10:34:24 <smithj> dcoutts_: thats a really ugly solution though
10:34:26 <smithj> imho
10:34:37 <dcoutts_> try finding a neater one ;-)
10:34:46 <smithj> i guess there isn't a haskell compiler written in c/cpp/somethingelse?
10:34:55 <dcoutts_> smithj, hugs98
10:34:59 <sjanssen_> smithj: not one that will compile GHC
10:35:02 <dcoutts_> no
10:35:20 <smithj> dcoutts_: but hugs98 won't build :-/
10:35:25 <smithj> hence why i'm here :-P
10:35:39 <dcoutts_> smithj, if you want to get started you need a binary for that platform, eg we bootstrapped ghc into portage on a few arches by pinching .debs and using that to get us started
10:35:52 <dcoutts_> so you could do the same, pinch a binary build from somewhere
10:35:56 <davidhouse> smithj: which distro are you talking here?
10:36:02 <davidhouse> and, more to the point, which arch?
10:36:11 <smithj> davidhouse: rPath Linux and friends for x86 and x86_64
10:36:18 <dcoutts_> and use that to compile from source in your other distro build system
10:36:41 <dcoutts_> smithj, I presume that's a source distro then?
10:37:05 <int-e> davidhouse: uhm.  runWriter (do tell "foo"; tell "blah") --> ((),"fooblah") ... you need the [] because you want a list of strings.
10:37:16 <smithj> dcoutts_: not really, but we have a rather strict process by which we're basically required to boostrap
10:37:26 <smithj> what you suggest *is* possible
10:37:33 <smithj> and i will if i must, but i'd rather not
10:37:42 <davidhouse> i'm pretty sure you should be able to download some .hc files from somewhere and use those to bootstrap GHC. (are they OS- or just arch-dependant? i think the latter)
10:37:42 * smithj goes to poke the hugs98 source
10:38:04 <dcoutts_> smithj, well if all you want is a binary build then just download the generic x86 & x86_64 build from the ghc download site and use them to build from source.
10:38:23 <davidhouse> int-e, duh. of course.
10:38:36 <dcoutts_> smithj, we've not tried the latest hug98 version yet, so if you find anything interesting then do tell us in #gentoo-haskell
10:38:53 <dcoutts_> smithj, or use the previous release, that works. We've got that in portage now.
10:39:16 <smithj> dcoutts_: will do
10:39:21 * smithj joined #gentoo-haskell
10:40:46 <vincenz> Igloo: well I'll be glad if you're in charge of iraqian nukes with that aim :D
10:41:13 <Igloo> smithj: What are you packaging for?
10:42:47 <vincenz> referring to earlier commeint about aiming for UK
10:44:23 <dash> so... Linspire, eh?
10:44:31 <davidhouse> indeed.
10:44:38 <dcoutts_> dons, woho!
10:44:42 * davidhouse would love to hear how that's getting on
10:44:48 <dash> that's pretty crazy/awesome
10:45:23 <dcoutts_> dons, now using a random mixture of maps & filters I get 5 kinds of loop fusion adding up to exactly the number we were expecting.
10:45:35 <davidhouse> dash, i didn't believe it at first. figured it was April 1st again :)
10:45:36 <dash> i would definitely use haskell more if it had better OS integration. hopefully this will encourage that
10:45:41 <dash> davidhouse: yeah exactly
10:45:55 <dcoutts_> dash, gentoo has pretty good Haskell support
10:46:07 <jethr0> dash: "OS integration"? like what?
10:46:11 <dcoutts_> as does debian
10:46:21 <dcoutts_> and Fedora is pretty good
10:46:42 <smithj> Igloo: rPath Linux and friends for x86 and x86_64
10:47:09 <Igloo> Oh, sorry, I assumed you were talking about library rpaths
10:47:33 <dash> jethr0: well, i guess i am thinking of the ease of which you can get at POSIX-y things from python, and the various useful tools built on top of that 
10:47:48 <ndm> For a FilePath library, do you think it is better to go with short or long names - setExtension vs setExt, pathSep vs pathSeparator
10:48:17 <smithj> Igloo: yeah, its a wierd name; rPath is a company who does linux-related things :-)
10:48:40 <jethr0> dash: any specific cases that haskell supports especially badly?
10:48:56 <davidhouse> ndm, short! short! :) go unreadable code! 
10:49:17 <dash> jethr0: well, maybe i just don't know where everything is :)
10:49:30 <ndm> davidhouse: serious or sarcastic?
10:50:10 <davidhouse> ndm, personally i'd go for the longer ones, i think.
10:50:26 <dcoutts_> ndm, I'd go long too
10:50:28 <davidhouse> as long as you define (</>) and (<.>) for me :)
10:50:49 <ndm> i will define </> and <.> - just not quite sure what fixities/precidences to give them
10:51:03 <dcoutts_> ndm, same as ++ ?
10:51:38 <Igloo> For </>, and make <.> one or two tighter
10:51:54 <dcoutts_> ah, good idea
10:52:22 <ndm> and </> needs a fixity, not sure of what though
10:52:28 <dash> jethr0: but to pick three things at random, how do you: 1) get a list of filenames in a directory, 2) call out to the shell to run a command line and get the stdout output from it as a string, 3) open a socket in non-blocking mode
10:52:40 <Igloo> What's the implementation?
10:52:46 <jethr0> dash: i was just wondering whether you were aware of System.Posix (http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html)
10:52:52 <dash> jethr0: yeah, i know there's stuff
10:53:24 <davidhouse> System.Directory, System.Process and not sure about the last one.
10:53:25 <Cale> getDirectoryContents :: FilePath -> IO [FilePath]
10:53:34 <dash> okay, cool
10:53:44 <Cale> runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
10:53:54 <dash> i figured that kind of stuff was there :)
10:53:58 <davidhouse> specifically for the second (because it's not that obvious):
10:54:24 <davidhouse> (_, out, _, _) <- runInteractiveCommand "ls -la"; output <- hGetContents out
10:54:36 <dash> oh yeah, real intuitive 
10:54:37 <dash> :D
10:54:39 <dash> okay my haskell knowledge is little out of date, so one other question:
10:55:08 <dash> i know hugs doesn't let you define new functions at the interactive prompt; does ghci?
10:55:20 <Cale> yes, but they're highly temporary
10:55:25 <davidhouse> it's not that intuitive but it works well.
10:55:30 <dash> Cale: how temporary
10:55:38 <Cale> until you reload a file
10:55:43 <dash> well dang
10:55:50 <dash> what's up with that?
10:55:58 <davidhouse> you can get more permanent ones
10:55:59 <Cale> you're just not meant to do it there
10:56:06 <Cale> just save them in a file :)
10:56:07 <davidhouse> you can define more commands in a .ghci file.
10:56:24 <davidhouse> or save them in a module which you just load all the time.
10:56:29 <dash> yeah
10:56:39 <davidhouse> (you might be able to make the loading automatic)
10:57:10 <Cale> I think of ghci as a sort of interactive debugger, as well as a default user interface for programs which don't have a UI yet.
10:57:44 <dash> yeah
10:57:52 <davidhouse> GHCi is great for incremential development.
10:57:52 <dash> i am looking for something else, i guess
10:57:58 <davidhouse> it could do with less sandboxing, though.
10:58:08 <Cale> sandboxing?
10:58:22 <davidhouse> dash, GHCi will rawk at the end of this summer :) (someone's writing an interactive debugger for SoC)
10:58:33 <davidhouse> Cale, more permanance, in other words
11:00:41 <Cale> It might be nice if it had the ability to selectively save definitions that you've made, appending them to a file.
11:00:54 <Cale> Still, it would be an awkward way to program.
11:01:08 <davidhouse> i do hate it when you reload and there's an error. you lose all your defs.
11:01:33 <davidhouse> it's understandable if there's no errors because types etc may have changed. but with errors.
11:01:43 <Cale> mhm
11:02:02 <davidhouse> but i still think GHCi should make more of an effort to preserve your defs. only clear them if absolutely necessary.
11:02:02 <Cale> Or else it should try to load as many definitions from the file as possible.
11:02:34 <davidhouse> it would be cool if you could tell it to load the local bindings too :)
11:02:36 <dash> ah well. it'll be interesting to see what comes out of linspire
11:02:40 <Cale> it might get confusing if it tried too hard :)
11:03:10 <Cale> dash: I think there are some libraries (if not completed then in the works) for making shell-like tasks easier in Haskell
11:03:15 <dash> someday i might even use haskell :)
11:03:29 <dash> (if i ever get interested in stuff other than open systems)
11:06:08 <jethr0> most sensible thing i've seen in a while: embedding x clients in web pages *huh?* (http://www.powerlan-usa.com/webterm_x/wtx-user-help.html)
11:07:34 <Cale> wow, I've seen webpages which would send x clients back to your server, but never something like that.
11:09:06 <esap> I wonder what kind of security implications that has?
11:09:30 <Cale> dash: http://www.volker-wysk.de/hsshellscript/
11:10:24 <davidhouse> weird. since migrating to the haskell world, i haven't really heard the word "security" mentioned. strike one for type safety :)
11:11:18 <esap> davidhouse: Security and type safety are completely orthogonal issues.
11:11:35 <jethr0> davidhouse: you migrated to another world?
11:11:45 <damg|afk> yepp, original pascal was safe alrite :P
11:11:54 <damg|afk> you couldnt cast anything ;)
11:11:58 <jethr0> esap: they aren't so orthogonal when casts and buffer overruns are concerned
11:12:03 <davidhouse> esap: completely? it must help with things like XSS.
11:12:10 <dash> davidhouse: you need to check out Emily
11:12:36 * davidhouse came from web dev so all he knows of in terms of security is XSS, CSRF and so on
11:12:41 <davidhouse> nothing scary like buffer overruns.
11:13:00 <dash> davidhouse: how about "object-capability security"
11:13:18 <esap> davidhouse: I mean security is really about how to prevent all non-privileged access at run-time. Type-safety is about finding bugs in your own programs.
11:13:32 <davidhouse> bugs lead to security problems, though.
11:13:54 <dash> they can
11:14:21 <dash> the design of your language and environment has a large effect on how much of a security problem bugs in your code can produce
11:15:51 <dash> anyway: http://www.skyhunter.com/marcs/emily.pdf
11:16:01 <dash> an ML-derived language designed with security in mind
11:16:37 <esap> davidhouse: I think of security as a requirement. Type-safety impacts the language's ability to satisfy (any) requirements.
11:16:50 <dash> (his introduction for C++/Java programmers: http://www.skyhunter.com/marcs/emilyWalnut.html)
11:17:10 <davidhouse> if i do module Foo where import Bar, will Bar be reexported?
11:17:15 <dash> esap: security isn't a requirement, it's a design principle
11:17:50 <Cale> davidhouse: no
11:17:53 <davidhouse> or do i explicity need to do module Foo (module Bar) where import Bar
11:18:02 <Cale> yeah, you have to do that
11:18:07 <davidhouse> rightey.
11:19:28 <esap> dash: I don't think of security as a design principle. There are all kinds of design principles that can be used to implement secure software.
11:19:36 <davidhouse> hi waern. how's haddock?
11:20:09 <dash> esap: well, what i mean is, it's not a concrete thing, security looks different for each different program 
11:20:18 <dash> esap: it's like saying "reliability is a requirement"
11:20:39 <esap> dash: yes. exactly.
11:21:00 <esap> dash: it's possible to have environments where reliability is not a requirement.
11:21:08 <esap> dash: Similarly for security.
11:21:34 <esap> dash: Try windows games, they clearly haven't been designed as reliable :-)
11:21:35 <dash> mmm, ok, i guess it depends on how you interpret "requirement"
11:21:47 <davidhouse> argh, the worst part of any project. ripping out code you know won't be needed
11:22:06 <dash> davidhouse: worst? 
11:22:10 <dash> deleting code is awesome
11:22:44 <davidhouse> no, i hate it. "i spent all my time writing that awesome code, and it's going to waste"
11:22:50 <davidhouse> dash, be proud of your work :)
11:23:07 <esap> dash: ok, no need to start discussing about terminology.
11:23:37 <Cale> davidhouse: I think he means that if he's written better code which replaces that code, then it's a good feeling to rip out the old stuff which didn't work as well.
11:23:40 <waern> davidhouse, hey.. well, today I haven't worked that much on it 
11:24:04 <Cale> davidhouse: Of course, if the code is more generally useful, save it somewhere.
11:24:28 <dash> davidhouse: code is bad
11:24:34 <dash> davidhouse: functionality is good
11:24:36 <davidhouse> Cale, sure, but it's the techniques that matter.
11:25:06 <davidhouse> it's the fact that you've written it in such a damn cool way :)
11:25:12 <davidhouse> but sure, if you write cooler code...
11:25:16 <dash> esap: i guess my reaction was against people who write a bunch of code and then say "and now we're gonna make it secure"
11:25:23 <dash> esap: but that's not what you were saying. :)
11:25:25 <davidhouse> dash, that's the bottom line, but functionality isn't _why_ i program.
11:25:27 <monochrom> Use it in another project.  Create a new project to use it.  A solution looking for a problem.
11:25:33 <dash> davidhouse: really! why do you program
11:25:55 <esap> dash: you're right, I wasn't saying that.
11:25:57 <davidhouse> to write code! and to write beautiful code.
11:26:04 <monochrom> "I write the code for the world to sing, I write the code I write the code"
11:26:17 <dash> davidhouse: yeah this is the other barrier to entry for me, wrt haskell
11:26:21 <dash> you people are weird like that :)
11:26:38 * davidhouse bows :)
11:26:54 <davidhouse> code is poetry.
11:26:59 <Cale> dash: The first thing almost every Haskell programmer does is unwittingly reimplement around half of the Prelude.
11:27:05 <dash> cale: i didn't
11:27:16 <davidhouse> :b Prelude; :b Data.List
11:27:21 <dash> the first thing i did was read the prelude, heh :)
11:27:23 <monochrom> I didn't.
11:27:24 <davidhouse> then when you get a bit better, :b Control.Monad
11:27:34 * dash wonders if he still has the first haskell code he wrote
11:27:35 <esap> dash: It's clearly true that it's not possible to introduce some requirements into the system if they haven't been thought of from the start. It depends on the architecture of the system, if introducing the requirement would mean changes to all parts of the software, then it's often not possible to take that requirement as an after-thought.
11:27:50 <dash> esap: agreed
11:28:27 <davidhouse> dash, i tihnk i do. tabs. eww.
11:28:32 <dash> heheh
11:28:37 <Cale> But I think it is good practice to do so -- even if you know that the functions are there.
11:28:44 <dash> Cale: ...
11:28:45 <dash> why?
11:28:48 * davidhouse hits ~/hs/archive
11:29:07 <dash> well the _last_ haskell code i wrote was a monadic interpreter
11:29:14 <Cale> Just for practice while learning.
11:29:26 <davidhouse> so you know how they work?
11:29:30 <Cale> A lot of those things are fundamental patterns
11:29:39 <davidhouse> yeah.
11:30:01 <Cale> You'll also better recognise when to use the functions (especially the higher-order ones) if you've written them yourself.
11:30:31 <monochrom> Good exercise to write programs other people have written.
11:30:43 <dash> Cale: maybe if haskell is like one of the first five languages you've learned
11:31:17 <jethr0> dash: don't be snooty :)
11:31:44 <Cale> Well, maybe it wouldn't be so useful if you already knew something like o'caml.
11:31:47 <lispy> is the haskell COM interface mature?
11:31:48 <dash> jethr0: sorry, i just get annoyed with the idea of "practice" now
11:31:54 <dash> lispy: from what i've seen, yes
11:32:02 <monochrom> Haskell is the first representative one of the first five paradigms I have learned.
11:32:18 <Cale> I'm constantly writing programs which serve little purpose than to exercise some idea.
11:32:21 <lispy> dash: okay, so where do i get it from :)
11:32:29 <jethr0> dash: it's just that i think many people in here know more than 5 languages. and haskell is quite different from most of them...
11:32:51 <dash> davidhouse: do i understand how what works?
11:33:05 <Cale> I probably knew around 10 or 15 languages by the time I came to Haskell, it was still incredibly different from all of them, including scheme.
11:33:17 <davidhouse> dash, sorry, that was a suggestion as to why you'd rewrite prelude functions.
11:33:23 * esap is constantly writing programs which attempt to express some idea [in the program itself]
11:33:24 <dash> davidhouse: aah
11:33:35 <davidhouse> i knew one (count 'em, 1!) language before i learnt haskell :)
11:33:40 <Cale> esap: Programs as prose :)
11:33:59 <dash> anyway yeah
11:34:07 <dash> all i'm saying is, the fun part is when the program works
11:34:12 <dash> not when i'm writing it
11:34:34 <jethr0> for me the fun part is when i have learned something completely knew and had to work hard to get there :)
11:34:36 <esap> cale: I mean things like the stack example: data Stack a where { Frame :: (Functor f) => f (Stack a) -> Stack (f a) }
11:34:41 <jethr0> s/knew/new/
11:34:42 <Cale> It depends on what sort of program you're writing
11:34:43 <davidhouse> the fun part is when you finish, look back at the code you've written, and know that it's awesome.
11:34:50 <dash> learning sucks :(
11:34:59 <Cale> Learning can be awesome :)
11:35:06 <davidhouse> dash, you won't get on with haskell then.
11:35:22 <dash> davidhouse: why's that
11:35:24 <lispy> @where com
11:35:24 <lambdabot> I know nothing about com.
11:35:35 <Cale> Especially when you're learning something which you immediately feel will save you lots of time in the future.
11:35:36 <davidhouse> haskell's always about new stuff. haskell is new. haskell is also hard.
11:35:40 <dash> Cale: well yeah
11:35:49 <lispy> i know i've seen it in the past, but i can't find the com interface at all right now
11:36:14 <monochrom> You won't get on with life, if you think learning sucks.
11:36:23 <dash> monochrom: well, i said it badly
11:36:24 <Cale> Or even when it's just something which is beautiful, though you might have trouble placing it.
11:36:27 <dash> learning is a cost
11:36:33 <dash> costs with no offsetting benefits suck
11:36:35 <jethr0> i think i can still spend years exploring what other people have writte in/for haskell and all the while improve my programming for all other languages
11:37:01 <monochrom> benefit is diverse
11:37:10 <lispy> jethr0: to an extent, you'd still need to program in those other languages to get better at them
11:37:11 <jethr0> i can't say the same for most of the imperative languages. there the interesting parts are buried underneath tons of duplicated code and explicit loops
11:37:16 <Cale> dash: Then again, I did a degree in pure mathematics (as opposed to applied)
11:37:17 <int-e> davidhouse: the ironic part is where you revisit code you wrote some years ago.
11:37:45 <Cale> dash: So I'm used to not caring about whether something is really useful in the real world.
11:38:14 <dash> Cale: this is why i am encouraged by these linspire guys :)
11:38:21 <jethr0> lispy: to a very little degree yes. but apart from writing idiomatic code, i see the main proficiency in clearly structured thoughts about the problem. and whilst i think haskell can teach that, it will be applicable in any language you sufficiently know
11:38:31 <Cale> Sometimes just making my brain better is enough of a goal.
11:39:14 <int-e> as long as you're not tempted to use any sharp tools for that purpose ...
11:39:20 <Cale> heh
11:39:42 <davidhouse> ;)
11:39:52 <dash> i hear trepanation works wonders
11:40:00 <lispy> is HDirect the only COM interface?
11:40:07 <monochrom> I was also pure math.  I am used to having a richer notion of "reward" then the shallow one in the real world.  (These days you really have to put things in positive wording :) )
11:40:16 <monochrom> s/then/than/
11:40:18 <davidhouse> lispy, i think there was a conversation on the mailing list recently.
11:40:30 <lispy> davidhouse: okay, which one haskell-cafe?
11:40:41 <davidhouse> lispy, i think Marlow's conclusion was that "there is a definite gap in the market for a good COM tool"
11:40:46 <davidhouse> hold on, i'll find it
11:40:58 * jethr0 would like to link to movie scenes. we should write that for lambdabot :). then i would now link to the "brainboost" scene in "forbidden planet"
11:41:56 <monochrom> My reward usually comes from the fact that after I learn something I will be the only one within 3 kilometres to know that stuff. :)
11:42:30 <jethr0> monochrom: you've got a camp of haskell gurus located just over 3 kilometers from you? :)
11:42:34 <int-e> @quote cjs
11:42:34 <lambdabot>  I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of these
11:42:35 <lambdabot> nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
11:42:46 * dash nods
11:42:50 <monochrom> 3 kilometres is a lower bound :)
11:42:56 * monochrom is modest XD
11:43:02 <dash> this is why haskell remains obscure
11:43:09 <davidhouse> lispy: [haskell].
11:43:11 <jethr0> dash: what is?
11:43:16 <lispy> davidhouse: sorry?
11:43:21 <monochrom> Until last year I was the only one within 3 kilometres to know monads
11:43:32 <dash> jethr0: you people are too busy having fun playing with it to do anything anybody cares about ;)
11:43:35 <davidhouse> lispy: that's the mailing list it's on.
11:43:43 <lispy> davidhouse: ah, i'm not on that one
11:43:44 <dash> (exaggerating a bit ;)
11:43:47 * lispy checks gmane
11:43:58 <Cale> dash: As it should be -- the rolling stone gathers no moss.
11:44:01 <davidhouse> monochrom: 3 kilometres?! you lived in a very haskelly-dense area :)
11:44:06 <jethr0> dash: you have a tendency of going against the grain, don't you?
11:44:18 <smithj> yay! hugs is built using only gcc
11:44:19 <dash> jethr0: sometimes
11:44:30 <jethr0> i like having fun. and everyone who's ever come here for information and help was treated with the utmost respect and helpfullness
11:44:32 <dash> jethr0: i am just annoyed because i /really want/ to like haskell
11:44:40 <davidhouse> dash, why?
11:44:47 <dash> jethr0: but apparently i have the wrong mindset for it =/
11:45:01 <Cale> jethr0: Well, if you live anywhere in the vicinity of a university with any sort of CS or math program, it's quite likely that someone there uses monads in their everyday work.
11:45:09 <dash> davidhouse: mostly because of the claimed benefits of static typing, etc
11:45:13 <lispy> davidhouse: http://article.gmane.org/gmane.comp.lang.haskell.libraries/4749/match=com this thread?
11:45:23 <jethr0> dash: radically new paradigms need a little effort to change one's worldview. i don't think there's anyone here who didn't have a hard time during the first weeks of haskell
11:45:34 <davidhouse> lispy, "Interfacing to OLE/COM: HaskellDirect the only game in town?"
11:45:41 <lispy> davidhouse: yeah
11:45:59 <jethr0> Cale: i like 200 meters from the campus at karlsruhe, and i'm sure there are quite a few ardent haskellers there. after all they teach it as first language here :)
11:46:01 <dash> jethr0: sure, i did
11:46:09 <dash> but that was in 1999
11:46:14 <jethr0> dash: hehe
11:46:37 <jethr0> *live
11:46:45 <lispy> jethr0: i'm looking at a traffic network of karlsruhe right now :)
11:46:55 <jethr0> traffic network?
11:46:57 <monochrom> Hmm, I didn't have a hard time.  Actually I didn't have a hard time with anything, except the "cut" in Prolog (and now I know it is not my inadequacy).  I am thinking I am a computer not a human.
11:47:04 <lispy> jethr0: yeah, like cars
11:47:06 * dash 's first language was gwbasic :((
11:47:13 <dash> monochrom: yeah prolog is craaazy
11:47:22 <jethr0> lispy: do you live in karlsruhe?
11:47:26 <dash> good thing there's oz/alice/etc now
11:47:53 <lispy> jethr0: no, i leave on the west coast of the US :)
11:48:02 <davidhouse> monochrom: which languages did you know when you came to haskell?
11:48:14 <xerox> SML (:
11:48:20 <lispy> jethr0: but my company has it's main office in Karlsruhe and our example files are of that city :)
11:48:22 <jethr0> monochrom: you amaze me. although i'm not too bad with languages prolog gave me more trouble than usual...
11:48:46 <Cale> dash: there's a half-joke about that Haskell should avoid popularity at all costs
11:48:58 <dash> Cale: why's that
11:49:04 <jethr0> lispy: k, i live right in the middle. just south-east of the "schloss"
11:49:17 <monochrom> My path: BASIC (even before GW), Pascal, C, Lisp, Prolog, C++, Perl, SML, Java, Haskell.
11:49:29 <Cale> dash: The reasoning being that popular languages are highly resistant to change.
11:49:36 <davidhouse> my path: PHP, Haskell.
11:49:40 <int-e> Has anyone else ever missed a newSTArray, newSTUArray and newIOArray (being newArray restricted to the proper type)?
11:49:41 <dash> Cale: Really? I haven't found that to be true
11:50:03 <int-e> oh, and newIOUArray of course.
11:50:05 <davidhouse> Cale, err, perl? :)
11:50:12 <jethr0> int-e: can't say i've missed them. but i did found it out to do "::" typing just to get an array
11:50:13 <dash> or python, or php, etc
11:50:16 <monochrom> I think I am not too bad with computers altogether :)
11:50:30 <int-e> jethr0: hmm, that's a pain for STArray
11:50:43 <int-e> jethr0: because of that s type variable.
11:50:46 <Cale> Have python or php changed all that much?
11:51:05 <Cale> The largest change I've seen in python was the inclusion of generators.
11:51:10 <davidhouse> PHP's changed loads.
11:51:11 <jethr0> python had some changes: generator stuff, decorators, ...
11:51:18 <davidhouse> PHP4 -> 5 changed its entire object system
11:51:35 <davidhouse> PHP3 -> 4 changed _everything_ (PHP3 was ooold and rubbish)
11:51:42 <dash> Cale: there were significant changes to the type system in python 2.2
11:51:56 <monochrom> Perl 4 to 5 was also a large change.
11:51:58 <jethr0> but i think popular languages evolve towards the mainstream while haskell has a tendency to evolve towards research (which i quite like)
11:52:04 <monochrom> err I just mean significant
11:52:09 <dash> cale: popular languages are often resistant to change in ways that would massively break old programs
11:52:15 <Cale> yes
11:52:16 <wchogg> Well, I'm not sure if that it's even just that popular languages don't change so much as it is that they have to try and appease a larger user base and thus can't toss off bad ideas or be as daring.
11:52:20 <monochrom> Perl 5 to 6 is to be a large change but nothing has materialized
11:52:25 <dash> Cale: but even that isn't always true -- python's getting ready to change the meaning of "/"
11:52:29 <int-e> jethr0: besides I don't really like type annotations in the middle of the code.
11:52:54 <dash> monochrom: well, something has
11:52:56 <jethr0> int-e: me neither. and because IOUArray lives in IO you even have to think about where to put that stupid thing
11:53:05 <dash> monochrom: pugscode.com 
11:53:42 <jethr0> int-e: plus the class in class thingey takes time to analyze whether it's "STArray IO ..." or "STArray ... IO"
11:53:54 <monochrom> I think all these examples of changes in PHP and Perl are reinforcing Cale's point.  Note that the most succesful big changes were when the language was not too widespread.  Moreover if attempt to make a big change after it's popular, it takes forever.
11:54:24 <dash> monochrom: okay, but what big changes has Haskell seen in the same time frame?
11:54:44 <jethr0> although i subjectively agree with cale, haskell is the language that has officially changed the least. even java had some changes in the last decade :)
11:54:46 <Cale> Lots and lots of stuff.
11:55:01 <Cale> Look through the list of GHC-supported extensions.
11:55:06 <monochrom> many many ranks polymorphism, fundep
11:55:11 <jethr0> that's arguably not haskell though
11:55:17 <xerox> Look at the reports!
11:55:19 <Cale> jethr0: Sure it is
11:55:21 <dash> Cale: yeah, but how many of those changes break compatibility
11:55:34 <wchogg> So Haskell hasn't changed because the changes aren't Haskell?
11:55:41 <davidhouse> dash, we had a good initial standard. so what?
11:55:42 <monochrom> It is hard to compare.  Does Haskell need change?
11:55:45 <jethr0> then you can argue that stackless python is python, and that ironpython's bindings to all .net classes are a change in python
11:55:52 <xerox> Stream based IO elided in favor of the Monadic framework is what comes to mind.
11:56:16 <Cale> The argument that "fundeps aren't Haskell" is poor, since almost everyone using Haskell uses at least one library which uses them.
11:56:28 <dash> davidhouse: so the point is that if popularity increases the cost of compatibility-breaking changes, and there haven't been any, why is popularity something to avoid? :)
11:56:28 <Cale> xerox: good one
11:56:41 <jethr0> what i like about haskell is that the core language is incredibly compact. and as everything else is done via libraries the language definition doesn't have to change at all. you just release "new" libraries and that's that
11:56:46 <int-e> @type interact
11:56:47 <monochrom> But I would say the ratio "realized change"/"need for change" for Perl and for Haskell are the same.  Also there will be Haskell Prime.
11:56:47 <lambdabot> (String -> String) -> IO ()
11:56:48 <wchogg> jethr0:  I see your point, but I think the widespread use of these extensions makes them a part of the language proper.  They don't seem to be separated off.
11:56:53 <jethr0> apart from IO and FFI maybe
11:57:16 <jethr0> wchogg: i don't want to be polemic at all. i was just talking about haskell98...
11:57:33 <wchogg> jethr0:  I see.  I guess it was just a misunderstanding, sorry.
11:58:00 <monochrom> "How many changes break backward compatibility?"  I think this indicates that Haskell is a robust, extensible language, and the researchers are not crazy.
11:58:25 <Cale> from the PEP which recommends changing the division operator:
11:58:29 <Cale>     It is the opinion of the authors that this is a real design bug in
11:58:29 <Cale>     Python, and that it should be fixed sooner rather than later.
11:58:29 <Cale>     Assuming Python usage will continue to grow, the cost of leaving
11:58:29 <Cale>     this bug in the language will eventually outweigh the cost of
11:58:29 <Cale>     fixing old code -- there is an upper bound to the amount of code
11:58:32 <Cale>     to be fixed, but the amount of code that might be affected by the
11:58:34 <Cale>     bug in the future is unbounded.
11:58:51 <jethr0> from future import /
11:59:11 <dash> jethr0: "from future import braces" is more fun
11:59:27 <dash> well, __future__
11:59:41 <dash> monochrom: Sure.
11:59:42 <jethr0> from __future__ import terminator
11:59:45 <Cale> Is python going to permit optional braces like Haskell?
11:59:54 <davidhouse> how is python's (/) changing?
11:59:57 <dash> Cale: try it and see :)
12:00:04 <dash> davidhouse: from integer division to float division
12:00:13 <davidhouse> dash, ah, fun.
12:00:19 <jethr0> davidhouse: they might be through with it already. it was an issue with "div" vs. "/"
12:00:22 <dash> davidhouse: current behaviour is for division of two ints to return an int.
12:00:52 <monochrom> Alright, I agree Haskell will not be stagnated by popularity.
12:00:55 <jethr0> the old default behaviour could be *very* counter-intuitive
12:01:14 <dash> jethr0: only if your intuition was wrong!! ;)
12:01:29 <jethr0> de intuitionibus non es disputandi
12:01:37 <jethr0> *est
12:01:39 * monochrom laughs at the world
12:01:51 <Cale> dash: heh
12:02:04 <smithj> monochrom: speaking on behalf of the world, we laugh back
12:02:34 <monochrom> Anyone who grew up with a clean language like Pascal knows there are div and / and there is no need for an endian war.
12:02:40 <Cale> dash: though I think it would be good for them to optionally support braces -- then they would have a snappy response to all those people who complain about the layout rule
12:03:01 <dash> Cale: we already do have a snappy response
12:03:15 <jethr0> monochrom: growing up with pascal was fun, but i should've switched years earlier than i did...
12:03:19 <ihope> jethr0: what language is that? Italian?
12:03:30 <dash> ihope: dog-latin
12:03:35 <jethr0> ihope: wrong lating
12:03:51 <Cale> I mean in the same way that Haskell does -- putting braces around a block makes it layout independent, and forces the use of semicolons. Semicolons can be used without braces in order to put more than one thing on a line.
12:03:57 <jethr0> should be "intuitionis" methinks
12:04:00 <monochrom> Only after colleges switch over from Pascal to C "no one uses Pascal" when the new generation is brainwashed to think there must only be one "division" and now they're divided as to what it ought to do.
12:04:05 <dash> sure, i know about haskell's layout rule.
12:04:15 <Cale> monochrom: hehe
12:04:35 <Cale> dash: what reason is there for not having that?
12:04:46 <dash> cale: oh, i didn't say there was a good reason
12:05:01 <dash> there's not a good reason for a whole lot of the stuff python does
12:05:01 <Cale> I suppose it frees ; to be used as an additional operator symbol.
12:05:11 <davidhouse> is there a nice function for \f xs -> f (head xs) : tail xs
12:05:19 <jethr0> but i can't imagine the horror of java as first language. they did that when i started my CS and those people with little prior experience were very confused by "class Main {public static void main {}}" just for a simple hello world program
12:05:24 <dash> you can use semicolons to separate statements in python, it just doesn't work as consistently as in haskell
12:05:54 <jethr0> f (x:xs) = f x : xs
12:06:02 <sjanssen_> @pl \f xs -> f (head xs) : tail xs
12:06:02 <lambdabot> (`ap` tail) . ((:) .) . (. head)
12:06:20 <Cale> @pl f (x:xs) = f x : xs
12:06:20 <lambdabot> f = fix ((`ap` tail) . (. head) . ((:) .))
12:06:25 <monochrom> jethr0: yeah, every 1st year teacher I know (including from outside my university through IBM's CASCON) regrets that.
12:06:36 <xerox> I think that if you leave 'f' as a point it looks okay.
12:06:46 <Cale> @pl g f (x:xs) = f x : xs
12:06:47 <lambdabot> g = (`ap` tail) . (. head) . ((:) .)
12:06:52 <xerox> @pl \(x:xs) -> f x : xs
12:06:53 <lambdabot> ap ((:) . f . head) tail
12:06:57 <monochrom> "Wouldn't it be nice to have a subset of Java in which you don't have to do that boilerplate" was the conclusion.
12:07:02 <jethr0> xerox: ah :)
12:07:06 <dash> monochrom: Heh
12:07:07 <xerox> foo f = ap ((:) . f . head) tail
12:07:10 <jethr0> brain-o
12:07:12 <Cale> monochrom: hehe
12:07:25 <dash> universities are the wrong place to go these days, if you want to learn how to program, i think
12:07:36 <Cale> dash: they always have been
12:07:56 <ihope> @type let f (x:xs) = f x : xs in f
12:07:56 <Cale> You go to a community college if all you want to do is learn how to program.
12:07:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:07:57 <lambdabot>   Expected type: [a]
12:07:58 <jethr0> it just seems stupid to teach java +- OO when all you want is to teach students  to use "loops, branches and concatenation"
12:08:08 <jethr0> oh, and assignment
12:08:13 <monochrom> Some universities are the right place.  For example try to go to Dijkstra's place.
12:08:15 <Cale> (or do it in your spare time)
12:08:45 <Cale> CS shouldn't really be about the stupid details of programming.
12:08:47 <xerox> OTOH there is Moggi 200km down here, in Genova, and all they do is Java and a very slight bit of OCaml.
12:08:47 <monochrom> Ok, so Dijkstra has left all universities, and therefore no universities are right. :)
12:09:01 <jethr0> as i said, the last years they taught haskell as first CS language here in karlsruhe. i think it was a great idea, but there were many voices lamenting the unpracticality
12:09:04 <monochrom> But MIT's SICP is a right place to go.
12:09:15 <dash> Cale: heh, as if community colleges would teach you
12:09:18 <dash> monochrom: no
12:09:24 <monochrom> no?
12:09:24 <dash> SICP doesn't teach you how to program
12:09:37 <dash> it's a nice book, sure
12:09:39 <monochrom> eh, what does it teach?
12:09:40 <xerox> Those universities you are talking about are public or private institutions?
12:09:40 <dash> and worth reading
12:09:46 <dash> xerox: yes
12:09:50 <Cale> dash: well, it might be enough if you don't really care about anything else, and you'll be handed a design spec
12:09:53 <jethr0> dash: why not. it's a bit advanced as first material, but i absolutely LOVED the aspects it introduced me to
12:09:53 <xerox> `Yes' ?
12:10:16 <dash> jethr0: well sure, it's worth reading, but it's a tiny sliver of the stuff a programmer needs to know
12:10:50 <monochrom> Yes, it's tiny but it's a first lesson.
12:10:57 <Cale> You should go to university to learn how to become a computer scientist, not a programmer.
12:10:59 <dash> Cale: american universities don't really teach CS either, at least at the undergrad level
12:11:07 <dash> Cale: yeah but i don't wanna
12:11:23 <jethr0> dash: i don't entirely agree, but don't want to start a longish discussion. i think it introduces you to solving problems in a very nice way. it's not J2EE+hibernate+oracle+struts, but i'm not so sure whether that should be the focus...
12:12:01 <Cale> http://www.csclub.uwaterloo.ca/media/ -- check out the talk here on creating killer applications :)
12:12:15 <dash> jethr0: well personally i wouldn't teach it first, but i agree it's worth learning
12:12:27 * jethr0 thought the definition of a killer application was that it was hard to think of one / create it :)
12:12:38 <Cale> (seriously, it's an interesting talk, if you're interested in the practicalities of things, and making money)
12:12:44 <monochrom> IIUC, if you get an A in SICP you will be ready to learn OOP for example.
12:13:16 <jethr0> monochrom: hmm
12:13:26 <dash> i am just annoyed that the best way to learn programming right now seems to be "spend time on IRC" :)
12:13:39 <jethr0> *yeah*, with emily aka lambdabot
12:13:58 <davidhouse> hey, it's how i did it. :)
12:14:00 <xerox> I like very much the Abelson & Sussman video lectures.  If only there was such a thing for other interesting bits of knowledge!
12:14:03 <dash> davidhouse: me too
12:14:06 <jethr0> dash: why's that so annoying? it enforces everyones natural drive for procrastination ^_^
12:14:26 <dash> jethr0: not everyone has the temperament for surviving the irc monkey house :)
12:14:35 <jethr0> xerox: exactly. i loved that lecture with it catchy jingle. there should definitely be more of those
12:14:55 <jethr0> it's not so monkeylike right now, is it?
12:15:22 <xerox> The Haskell IRC community is sweet.
12:15:34 <integral> it swears less than the perl one
12:15:55 <dash> jethr0: yeah, but you're not really at critical mass just yet
12:16:14 <xerox> You come here and learn something, then you have the urge to come back again and give enough to balance (-:
12:16:53 <dash> which is nice :) #python was like this, a few years ago
12:17:03 <monochrom> Let's see if this is right.  So OOP is confusing to many people (some won't admit it because they don't know they're confused).  But if you have the SICP background you won't be confused.  IIRC there is a late chapter actually on decyphering OOP.
12:17:14 <jethr0> i like it here. i didn't have such a cool "support" channel for c++ and sometimes i had to brood for days at a time over a problem because the mailing lists seemed prohibitive and slow :(
12:17:24 <integral> monochrom: as with most of SICP, they build their own wee OO system
12:17:42 <dash> it's scheme, people build six object systems before breakfast there
12:17:56 <jethr0> k, gotta continue learning for my exam on monday :(
12:18:17 <davidhouse> OOP never seemed complex to me. people make it complicated.
12:18:47 <dash> davidhouse: the problem mostly comes when people expect one "object-oriented" language to behave like another one
12:18:51 * jethr0 finds OOP complex. not the idea itself, but the application can get pretty messed up
12:19:20 <monochrom> Yeah, and I think that's how SICP contributes.  It applies reductionism to OOP, after which you will never be intimidated or bluffed again.
12:19:22 <jethr0> liskov's substitution principle, fragile base class, a circle isn't necessarily an ellipse, .....
12:19:27 <integral> or when they try to use OO for *everything* to the exclusion of useful stuff like switches
12:19:40 <dash> jethr0: well, that's C++ :)
12:19:47 <dash> which arguably ain't the same thing
12:19:54 <jethr0> dash: NO, that's OO in very general terms
12:20:02 <dash> jethr0: "fragile base class" is a c++ problem 
12:20:11 <dash> LSP and typing, sure.
12:20:27 <isaacd> A circle isn't necessarily a *mutable* ellipse
12:20:47 <jethr0> from wikipedia: "The fragile base class problem is a fundamental architectural problem of object-oriented programming systems where base classes (superclasses) are considered "fragile" because seemingly safe modifications to a base class, when inherited by the derived classes, may cause the derived classes to malfunction."
12:21:11 <jethr0> isaacd: sorry. but in OO objects are often mutable
12:21:35 <integral> making them more like processes too
12:22:49 <jethr0> k, off to learn...
12:24:00 <ndm> i just wrote a monad that violates every single principle of the Monad class :)
12:24:08 <davidhouse> yay!
12:24:44 <resiak> do we get to see it, ndm?
12:24:53 <monochrom> Extend it to MonadPlus so you get to violate more principles.
12:24:54 <ndm> resiak: one sec, i'll just commit it...
12:26:08 <ndm> http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=filepath;a=headblob;f=/Tests.hs
12:26:13 <ndm> resiak: there it is
12:26:41 <ndm> http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=filepath;a=headblob;f=/System/FilePath/Windows.hs
12:26:48 <davidhouse> ndm, haha :)
12:26:51 <ndm> look at that file is you want to see an abuse of cpp :)
12:27:09 <ndm> but it works really well :)
12:27:57 <sjanssen_> ndm: that is evil
12:28:20 <monochrom> Phantom monad type.
12:28:22 <ndm> sjanssen_, the cpp or the monad?
12:28:34 <ndm> The cpp took a lot longer to come up with
12:28:42 <sjanssen_> ndm: the CPP is worse
12:29:14 <ndm> I intend to submit this to the base package, I'm curious if the CPP is too bad to allow it in...
12:29:19 <xerox> Anybody has an `American Physical Society' subscription?
12:29:23 <resiak> ndm: Evil!
12:29:32 <ndm> if anyone could think of a nice way to do it, i'd be grateful
12:30:03 <jethr0> ndm: that's what i wanted to write for Ord, to put orderings in do block. but i had too much respect for the monads
12:30:09 <sjanssen_> ndm: so you'll have several modules like .Windows, .Unix, etc?
12:30:17 <ndm> sjanssen_, probably just two
12:30:26 <davidhouse> ndm, why not use HUnit?
12:30:27 <ndm> but the main one will be the FilePath one
12:30:39 <ndm> and I want that to be entirely free from CPP
12:30:44 <monochrom> What is CPP?
12:30:46 <ndm> davidhouse: because i don't know it
12:30:51 <ndm> monochrom: C Pre Processor
12:30:53 <sjanssen_> the main one will default to Unix?
12:30:55 <ndm> #if etc.
12:31:03 <ndm> sjanssen_, no, it will default to your current OS
12:32:13 <isaacd> Is it safe for me to tell lambdabot to (error (repeat 'x')) or (fix error) at this point?
12:33:39 <sjanssen_> isaacd: no
12:34:04 <isaacd> why did lambdabot just leave for a moment?
12:34:05 <sjanssen_> @bot
12:34:14 <lambdabot> :)
12:34:23 <davidhouse> ndm, spend a bit of time learning it and count it as a life skill.
12:34:36 <sjanssen_> isaacd: probably because I sent that to lambdabot in a pm
12:34:37 <ndm> davidhouse: i probably will in a bit
12:34:51 <ndm> i guess it doesn't give much advantage for what i've already got?
12:35:04 <isaacd> sjanssen: which one? or both?
12:35:10 <davidhouse> yeah, but had you learnt it before...
12:35:14 <isaacd> *sjanssen_
12:35:15 <sjanssen_> isaacd: error $ repeat 'x'
12:35:32 <ndm> from what i can tell, it would result in more syntax
12:35:37 <isaacd> ok (:
12:35:51 * davidhouse wonders what fix error would come to
12:36:05 <davidhouse> probably "Exception: Exception: Exception: Exception:..."
12:36:17 <jethr0> > fix error
12:36:19 <lambdabot>  Exception
12:36:20 <isaacd> davidhouse: that's what Hugs says for it
12:36:29 <isaacd> and GHCi
12:36:36 <isaacd> with slightly different messages
12:36:42 <davidhouse> > error $ error "foo"
12:36:42 <lambdabot>  Add a type signature
12:36:49 <davidhouse> > error $ error "foo" :: String
12:36:50 <lambdabot>  Exception
12:37:03 <isaacd> > error "foo" :: String
12:37:04 <lambdabot>  Exception: foo
12:37:36 <isaacd> ok, it seemingly deals with error-ful error messages fine (?)
12:37:53 <davidhouse> isaacd: why do you wonder/
12:38:26 <isaacd> davidhouse: curiosity?
12:40:01 <davidhouse> oh, okay. nothing serious then :)
12:40:10 <isaacd> :)
12:40:10 <jethr0> isaacd: that's because it was "exploitable" before and has been fixed...
12:40:27 <isaacd> jethr0: what's "that"?
12:41:01 <jethr0> "error-ful error message"
12:41:02 <jethr0> s
12:41:12 <isaacd> ah, ok
12:41:36 <monochrom> how to exploit?
12:42:08 <xerox> > error (repeat "ka-boom") :: String -- Maybe?
12:42:08 <lambdabot>  Unterminated end-of-line comment
12:42:31 <xerox> > error (repeat "ka-boom") :: String
12:42:31 <lambdabot>  Couldn't match `Char' against `[Char]'
12:42:40 <xerox> Lucky.
12:42:42 <isaacd> xerox: repeat :: a -> [a], cycle :: [a] -> [a]
12:42:44 <jethr0> cycle
12:44:13 <lispy> was the 'lang' package renamed?
12:44:28 <xerox> 'base' ?
12:44:32 <lispy> i'm trying to compile hdirect and it asks for that package, but my copy of ghc6.5 doesn't seem to have it
12:44:52 <lispy> i do have base
12:45:42 <monochrom> lang was probably renamed to base
12:45:47 <dcoutts_> lispy, the lang package is dead
12:46:19 <dcoutts_> it's deprecated, you really have no need for it
12:46:35 <lispy> package_deps = ["base", "haskell98", "lang"],
12:46:38 <lispy> so just remove it?
12:46:50 <dcoutts_> you might need to change some imports
12:47:10 <dcoutts_> if it was actually using modules from that package
12:47:40 <dcoutts_> but all the lang package modules are now in other parts of the library heirarchy
12:48:02 <dcoutts_> eg IORef ==> Data.IORef
12:48:30 <dcoutts_> lispy, but yes, try removing lang from the list and see if it compiles
12:48:48 <dcoutts_> then fix module names until it does compile
12:49:23 <lispy> thanks, i will try
12:51:17 <lispy> cannot find module ST
12:51:21 <lispy> any ideas?
12:51:41 <monochrom> Data.STRef
12:51:46 <xerox> @hoogle ST
12:51:47 <lambdabot> Control.Monad.ST :: module
12:51:47 <lambdabot> Data.Array.ST :: module
12:51:47 <lambdabot> Control.Monad.ST.ST :: data ST s a
12:51:47 <lispy> thanks
12:51:59 <dcoutts_> lispy, take a look at:
12:51:59 <dcoutts_> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
12:52:10 <dcoutts_> it lists all the modules
12:54:28 <lispy> any idea how IOExts was renamed?
12:54:38 <lispy> i don't see anything obvious on the page you just gave me
12:54:44 <monochrom> Actually faster to use http://www.haskell.org/ghc/docs/latest/html/hslibs/index.html  the old libraries, but the pages contains nothing except "you want <links to new libraries>"
12:55:00 <monochrom> Example http://www.haskell.org/ghc/docs/latest/html/hslibs/sec-ST.html
12:56:03 <malcolm> IOExts became Data.IORef,  Data.IOArray, System.IO.Unsafe etc
12:56:10 <monochrom> Ah the IOExts page doesn't say "goto".
12:56:19 <monochrom> Yeah it's now broken up finely.
12:58:14 <lispy> thanks, now i get through the 'boot' target
12:58:22 <monochrom> yay
12:58:31 <lispy> Not in scope: 'trace'
12:58:53 <lispy> @hoogle trace
12:58:54 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:58:54 <lambdabot> Debug.Trace :: module
12:58:54 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
12:59:41 <lispy> @hoogle unsafePerformIO
12:59:42 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
13:00:23 <monochrom> also System.IO.Unsafe.unsafePerformIO
13:01:26 <monochrom> I suppose either way is fine.
13:01:49 <lispy> GlaExts?
13:01:51 <lispy> hm...
13:01:52 <nn2> lambdabot, binary
13:02:08 <lispy> oh, GHC.Exts
13:02:10 <monochrom> GHC.Exts
13:02:22 <nn2> ** where can i get landa bots binary
13:02:24 <monochrom> (As seen in the GlaExts page :) )
13:02:56 <lispy> monochrom: yeah, realized that just a second after i sead it :)
13:03:58 <nn2> > get
13:03:59 <lambdabot>  add an instance declaration for (Show (m s))
13:04:12 <nn2> > install you
13:04:12 <lambdabot>  Not in scope: `you'
13:04:18 <nn2> > install
13:04:19 <lambdabot>  Not in scope: `install'
13:04:23 <lispy> @hoogle newSTArray
13:04:24 <lambdabot> No matches found
13:04:31 <nn2> > binary
13:04:32 <lambdabot>  Not in scope: `binary'
13:04:39 <lispy> @hoogle STArray
13:04:40 <lambdabot> Data.Array.ST.STArray :: data STArray s i e
13:04:40 <lambdabot> Array.listArray :: Ix a => (a, a) -> [b] -> Array a b
13:04:40 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
13:06:09 <lispy> hmm...getting some errors now that i'm not good with...may need some help in a second
13:07:06 <int-e> I think I'll settle for http://paste.lisp.org/display/20481 for solving my STArray type annotation problems.
13:07:49 <int-e> (for anyone who cared about my newSTArray &co. question)
13:08:32 <lispy> Array seems to conflict with Data.Array.ST
13:08:54 <lispy> but Array is not listed on that page which tells  you to use a different module
13:10:13 <int-e> lispy: what's the conflict between the two?
13:10:37 <lispy> GHC.Arr.bounds vs. Data.Array.Base.bounds
13:10:40 <lispy> i think i want the former
13:10:58 <dcoutts_> really?
13:11:10 <dcoutts_> you should use the non GHC one when possible
13:11:17 <sjanssen_> lispy: why this instead of newSTArray, newIOArray, etc.
13:11:37 <dcoutts_> sjanssen_, seen the most recent fps fusion fun?
13:11:47 <lispy> sjanssen_: i didn't write this code
13:11:57 <lispy> sjanssen_: so i don't really know anything about STArray
13:12:02 <lispy> dcoutts_: okay
13:12:28 <sjanssen_> lispy: oh, sorry
13:12:30 <int-e> lispy: I think you want the latter; for Array it's the same.
13:13:13 <sjanssen_> dcoutts_: yeah, I've seen the patches
13:13:38 <dcoutts_> sjanssen_, you'll need to build the lates ghc-6.5 to get the RULES stuff working
13:13:51 <dcoutts_> we rely on a patch to ghc that went in yesterday :-)
13:13:57 <int-e> sjanssen: was that question for me?
13:14:03 <sjanssen_> heh, nothing less than cutting edge
13:14:06 <sjanssen_> int-e: yeah
13:14:13 <dcoutts_> sjanssen_, oh yeah! ;-)
13:14:25 <int-e> sjanssen_: because this way I only need to define one function for each type, not three or more.
13:14:25 <sjanssen_> seems it'd be easier for the user to write newSTArray
13:14:41 <sjanssen_> ah, you speak the truth
13:14:43 <lispy> hm...so how do i refer to Data.Array.Base.bounds?
13:14:45 <davidhouse> i'm now an organ donor! :)
13:14:57 <sjanssen_> davidhouse: which one?
13:15:01 <lispy> do I need to import Data.Array.Base as DAB ?
13:15:04 <lispy> something like that?
13:15:10 <davidhouse> sjanssen_: which what?
13:15:16 <sjanssen_> davidhouse: organ ;)
13:15:46 <davidhouse> sjanssen_: ah. all of them. :) (being an organ donor doesn't mean i've already donated an organ)
13:15:56 <davidhouse> it means that when i die, my organs can be donated then.
13:16:02 <sjanssen_> davidhouse: I know, twas a failed attempt at a joke
13:16:16 <davidhouse> ah, sorry. :)
13:17:38 <sjanssen_> dcoutts_: so what can the fusion do right now?  It can take a chain of maps and filters and make it into one procedure, right?  Does it work with anything else?
13:18:04 <dcoutts_> sjanssen_, it's more general than that
13:18:32 <dcoutts_> sjanssen_, anything that be expressed as an up loop or a down loop
13:18:36 <dcoutts_> eg folds
13:18:48 <dcoutts_> and scan, mapAccum etc
13:18:57 <sjanssen_> oh, fold, that's good
13:19:24 <dcoutts_> sjanssen_, and in particular the new stuff preserves things useing the most special form of loop possible
13:19:37 <davidhouse> dcoutts_: is this not a compiler-level thing?
13:19:49 <dcoutts_> davidhouse, no :-)
13:19:51 <lispy> @hoogle newSTArray
13:19:52 <lambdabot> No matches found
13:19:54 <dcoutts_> we're using ghc RULES
13:20:02 <davidhouse> dcoutts_: so you're writing the rules or writing the fusioning?
13:20:26 <dcoutts_> sjanssen_, so if you only do map . map then you don't get the full general case of loopUp and we can use a more special case loop form
13:20:38 <dcoutts_> davidhouse, we're writing the RULES to do the array fursion
13:20:51 <lispy> hmm...so where will i find a matchup for newSTArray?
13:20:52 <davidhouse> aha.
13:21:15 <dcoutts_> lispy, isn't it Data.Array.ST ?
13:21:26 <lispy> i imported that
13:21:46 <int-e> sjanssen: hmm. maybe cast functions (castFoo :: Foo x y -> Foo x y; castFoo = id) would be easier to use though.
13:21:56 <dcoutts_> lispy, there is no newSTArray, since STArray is now an instance of MArray you just use the MArray interface
13:22:25 <lispy> hmm...
13:23:02 <dcoutts_> sjanssen_, and what's more fun, is that even if the loops don't fuse (eg an up loop can't be fused with a down loop) we still save on reallocating buffers
13:23:42 <sjanssen_> dcoutts_: this fusion stuff reuses buffers?
13:23:45 <dcoutts_> sjanssen_, that is we can run a sequence of alternating up loops and down loops all reusing the same buffer, rather than allocating a new one for each
13:23:46 <lispy> ah, that seems to have worked
13:24:59 <dcoutts_> sjanssen_, yes. And this should be a good saving, for one thing it means fewer allocations and less work for the GC but secondly and probably more significantly means we get to reuse cache-hot memory
13:25:26 <dcoutts_> sjanssen_, so if you're working with a ByteString that fits in L1 or L2 cache then this should be a big win.
13:25:37 <sjanssen_> very interesting
13:26:25 <monochrom> @hoogle newArray
13:26:25 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:26:26 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:26:26 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
13:26:34 <monochrom> ayay!
13:26:45 <monochrom> ayyay! :)
13:27:01 <monochrom> mmmayyay! :) :)
13:27:39 * monochrom proposes to rename "haskell unboxed array" to "hurray!"
13:27:54 <davidhouse> yay! more optimistic names.
13:28:07 <davidhouse> like "winhugs": both success and friendly embraces!
13:28:10 <monochrom> Heh, the ! is a Freudian slip but it also serves as a reminder of strictness!
13:30:26 <lispy> thanks everyone
13:30:32 <lispy> seems to be compiling happily now
13:45:30 <jethr0> setq!
13:45:48 <sjanssen_> > setq!
13:45:48 <lambdabot>  Parse error
13:46:22 <monochrom> heh
13:50:26 <davidhouse> hmm.
13:50:33 <davidhouse> fairly quiet for a friday evening.
13:50:42 <davidhouse> guess everyone is out "having a life". pfft.
13:51:12 <monochrom> Naw I'm here I have no life.
13:55:38 * jethr0 neither. i'm learning my *ss of about linear feedback shift registers
13:55:44 <jethr0> off
13:56:42 * jethr0 just realized it's much more stuff to learn than he thought. and after 3 weeks of mediocre learning there's now only 2 days left *argh*
13:58:43 <jethr0> "Put simply, the reason is down to the fact that genetic material does not change during an animal's life. Therefore the first bird that evolved into what we would call a chicken, probably in prehistoric times, must have first existed as an embryo inside an egg." [slashdot] :))
13:59:01 <xerox> Are you studying in /. ?
13:59:20 <jethr0> obviously. best place for LFSRs
13:59:37 <jethr0> :(
14:23:32 <lisppaste2> AtnNn pasted "what is wrong with my do notation?" at http://paste.lisp.org/display/20486
14:24:04 <davidhouse> AtnNn: your "if" needs to line up with the "do"
14:24:39 <mauke> rule of thumb: insert a linebreak after do
14:24:42 <lisppaste2> davidhouse annotated #20486 with "try this" at http://paste.lisp.org/display/20486#1
14:24:59 <davidhouse> you don't need a linebreak if you indent properly.
14:25:16 <mauke> indenting properly is too hard
14:25:20 <Cale> more general rule of thumb: line up the items which are at the same level in a block
14:25:20 <davidhouse> you also need another "do" inside your if.
14:25:25 <davidhouse> mauke: it's really not ;)
14:25:43 <Cale> in the 'else' section in particulat
14:25:45 <Cale> r*
14:25:53 <davidhouse> indenting properly is easy (with emacs at least), and it makes your code look pretty.
14:26:04 <davidhouse> yeah, if you're doing more than one command in a row you need a "do".
14:26:05 <AtnNn> thank you
14:26:16 <mauke> davidhouse: no, it's irregular
14:26:48 <mauke> the number of spaces depends on the name of the function/parameters
14:27:13 <davidhouse> it does? give an example of what you mean
14:27:39 <mauke> davidhouse: your code. how many spaces do I have to insert before "if t"?
14:28:06 <davidhouse> you line it up with the previous line
14:28:30 <mauke> ... which depends on the length of the identifiers before =
14:28:40 <davidhouse> yeah, but it's not hard to judge
14:29:24 <Cale> It would be nice to have an editor which would automatically adjust the block indentation if the identifiers before the = were edited
14:29:31 <AtnNn> it fills up a 80x25 terminal pretty fast
14:30:42 <Cale> Yeah, in the case that you don't have enough space, you can put a linebreak after the = and start the do-block earlier
14:31:12 <tromp_> any pthreads experts here?
14:31:13 <lisppaste2> mauke annotated #20486 with "indents" at http://paste.lisp.org/display/20486#2
14:32:05 <mauke> I think that's ugly
14:32:17 <davidhouse> everything lines up nicely though :)
14:32:26 <Cale> why ugly?
14:32:59 <mauke> because of the inconsistent indentation
14:33:10 <davidhouse> it's aesthetically pretty.
14:33:30 <lisppaste2> Cale annotated #20486 with "Alternate version" at http://paste.lisp.org/display/20486#3
14:34:55 <mauke> +4, +3, +4, +8
14:35:01 <mauke> I wand a single indentation width
14:35:06 <Cale> the +3 and +8 can't be selected though
14:35:15 <davidhouse> mauke: it can be done.
14:35:17 <Cale> It's consistently +4 when a choice is available.
14:35:52 <Cale> You could break it up more in order to only use constant spacings, but it would make things uglier.
14:36:01 <Cale> and vertically way more spaced out
14:36:23 <lisppaste2> davidhouse annotated #20486 with "consistent indent profile" at http://paste.lisp.org/display/20486#4
14:37:21 <lisppaste2> mauke annotated #20486 with "my version" at http://paste.lisp.org/display/20486#5
14:38:01 <davidhouse> i like my version :)
14:38:08 <Cale> mauke: why would you want nothing after the 'then' if there was something after the 'else'?
14:38:33 <Cale> (on the line)
14:38:33 <mauke> because the "do" was optimized away :-)
14:38:41 <mauke> wouldn't hurt, though
14:39:03 <Cale> also, it makes it look like the 'else' there is on its own, not part of the 'if'
14:39:25 <Cale> (which is tied to the reason that it's a syntax error)
14:40:00 <monochrom> indenting if-then-else inside do is hard
14:40:08 <AtnNn> apart from the indentation, is there a better or more concise way to do grab all the remaining lines from a handle?
14:40:14 <mauke> that's not how I read it. maybe it's because I'm used to if ( ) {\n...\n} else {\n...\n}\n in C
14:40:24 <davidhouse> AtnNn: hGetContents :)
14:40:41 <Cale> fmap lines . hGetContents
14:40:42 <mauke> liftM lines hGetContents
14:41:03 <Cale> has to be composition -- you need to pass the handle :)
14:41:27 <AtnNn> oh cool
14:41:32 <Cale> note that after applying hGetContents, you should not close the handle
14:41:58 <ihope> fmap (fmap lines) hGetContents
14:42:00 <ihope> That? :-)
14:42:07 <Cale> hGetContents is slightly evil, in that what will happen is that the lines will be read lazily and the file automatically closed when finished
14:42:15 <Cale> ihope: um...
14:42:23 <ihope> Cale: Reader monad
14:42:23 <Cale> ihope: why the extra fmap?
14:42:23 <davidhouse> Cale, why is that evil?
14:42:28 <Cale> ah
14:42:42 <davidhouse> @type fmap (fmap lines) hGetContens
14:42:44 <lambdabot> Not in scope: `hGetContens'
14:42:46 <davidhouse> @type fmap (fmap lines) hGetContents
14:42:47 <lambdabot> Not in scope: `hGetContents'
14:42:54 <davidhouse> @type fmap (fmap lines) System.IO.hGetContents
14:42:55 <lambdabot> GHC.IOBase.Handle
14:42:56 <lambdabot>                -> IO [String]
14:43:05 <ihope> Magic!
14:43:11 <Cale> that's extra awkward :)
14:43:22 * AtnNn takes 5 minutes to understand that
14:43:26 <davidhouse> AtnNn: don't.
14:43:34 <Cale> fmap lines . hGetContents is the same
14:43:51 <AtnNn> @type fmap lines
14:43:52 <davidhouse> AtnNn: it's the useless monadic version of (a->).
14:43:52 <lambdabot> forall (f :: * -> *).
14:43:53 <Cale> @type fmap lines . System.IO.hGetContents
14:43:53 <lambdabot>      (Functor f) =>
14:43:53 <lambdabot>      f String -> f [String]
14:43:54 <lambdabot> GHC.IOBase.Handle
14:43:54 <lambdabot>              -> IO [String]
14:44:10 <davidhouse> i.e. all functions with String as their domain form a monad.
14:44:22 <davidhouse> (or any type)
14:44:23 <xerox> fmap :: (a -> b) -> (e -> a) -> (e -> b)
14:44:27 <Cale> I wouldn't say that monad is useless
14:44:34 <ihope> @type Control.Monad.liftM lines (Control.Monad.Trans.lift System.IO.hGetContents)
14:44:35 <lambdabot>   Couldn't match `String' against `IO String'
14:44:35 <lambdabot>   Expected type: GHC.IOBase.Handle -> String
14:44:39 <ihope> Ow
14:44:44 <Cale> but when there's a nicer way, don't use it :)
14:44:55 <davidhouse> Cale, well, apart from fun with liftM2 pointsfree, i've never seen it used seriously.
14:45:20 <tromp_> any pthreads experts here?
14:45:25 <ihope> Let's see here...
14:45:35 <Cale> davidhouse: join is quite handy
14:45:36 <davidhouse> > return "Ask, tromp" :: Maybe String
14:45:37 <ihope> (e -> a) -> (a -> e -> b) -> e -> b
14:45:37 <lambdabot>  Just "Ask, tromp"
14:45:58 <Cale> > join (***) (+1) (10,20)
14:45:59 <lambdabot>  (11,21)
14:46:23 <Cale> > let square = join (*) in square 5
14:46:24 <lambdabot>  25
14:46:30 <davidhouse> fun.
14:46:40 <davidhouse> there should be a combinator for join (***).
14:46:58 <xerox> > fmap (+1) (1,2)
14:46:58 <lambdabot>  add an instance declaration for (Functor ((,) a))
14:46:59 <lambdabot>   In the definition of `sxk': sxk = fmap ((+ 1)) (1, 2)
14:46:59 <lambdabot>   In the definition of `cli':
14:46:59 <sjanssen_> @type join (***)
14:47:00 <lambdabot> forall (a :: * -> * -> *) b c.
14:47:00 <lambdabot>      (Arrow a) =>
14:47:00 <lambdabot>      a b c -> a (b, b) (c, c)
14:47:05 <ihope> > Just (('a':'s':'k':[]):('t':'r':'o':'m':'p':[]):[])
14:47:06 <lambdabot>  Just ["ask","tromp"]
14:47:18 <mauke> instance Functor (a, a) where
14:47:34 <Cale> won't work :)
14:47:35 <sjanssen_> mauke: nope, (a, a) is the wrong kind
14:47:36 <xerox>   fmap f (x,y) = (f x,y) ?
14:47:51 <ihope> fmap f (x,y) = (f x, f y)
14:47:57 <davidhouse> @kind (,)
14:47:58 <lambdabot> * -> * -> *
14:48:00 <Cale> instance Functor (,) a where fmap f (x,y) = (x,f y)
14:48:17 <ihope> data Pair a = Pair a a
14:48:21 <xerox> Why is it appled on the y?
14:48:28 <davidhouse> (,) could be an arrow! :)
14:48:29 <ihope> instance Functor Pair where...
14:48:29 <Cale> xerox: because of its type
14:48:38 <int-e> Cale: not instance Functor ((,) a)?
14:48:46 <ihope> davidhouse: arr :: (Void -> a) -> (Void, a)
14:48:49 <Cale> int-e: yeah, forgot those parens
14:48:52 <ihope> Icky.
14:49:20 <davidhouse> ihope, that's not general enough
14:49:25 <ihope> It could be a co-arrow, though.
14:49:42 <ihope> davidhouse: yes, but it needs to work that way.
14:50:06 * ihope wonders what a co-arrow *is*
14:50:17 <davidhouse> i guess it's the CT dual of an arrow.
14:50:22 <ihope> Which is?
14:50:24 <xerox> >_<
14:52:10 <dcoutts> @localtime dons 
14:52:13 <lambdabot> Local time for dons is Sat May 27 07:45:33 2006
14:52:20 <dcoutts> bit yearly yet
14:52:31 <dcoutts> yearly? err early
14:52:33 <davidhouse> @yarr
14:52:33 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
14:52:36 <ihope> @localtime lambdabot
14:52:51 * ihope wishes lambdabot responded to CTCP TIME
14:52:57 <dcoutts> aye
14:53:06 <ihope> And CTCP VERSION, too.
14:53:16 <ihope> But not CTCP ACTION. :-)
14:53:17 <xerox> Send in a patch (:
15:08:16 <lisppaste2> lispy pasted "Compiling HDirect" at http://paste.lisp.org/display/20487
15:08:58 <lispy> Anyone familar with Typeable?  I could use some help with hdirect
15:11:32 <ihope> @hoogle hdirect
15:11:32 <lambdabot> No matches found
15:11:49 <davidhouse> @where HDirect
15:11:49 <lambdabot> I know nothing about hdirect.
15:12:04 <lispy> http://haskell.org/hdirect/
15:12:16 <lispy> @add hdirect http://haskell.org/hdirect/
15:12:16 <lambdabot> Maybe you meant: arr id
15:12:18 <ihope> @hoogle mkAppTy
15:12:19 <lambdabot> Data.Typeable.mkAppTy :: TypeRep -> TypeRep -> TypeRep
15:12:29 <lispy> @where+ hdirect http://haskell.org/hdirect/
15:12:29 <lambdabot> Done.
15:12:32 <monochrom> Perhaps you should s/mkApplyTy/myTyConRep/  ?  Just type-guessing.
15:12:55 <ihope> @hoogle mkTyCon
15:12:55 <lambdabot> Data.Typeable.mkTyCon :: String -> TyCon
15:12:56 <lambdabot> Data.Typeable.mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
15:13:27 <lispy> @hoogle TyCon -> TyRep
15:13:27 <lambdabot> No matches, try a more general search
15:13:35 <ihope> typeOf _ = mkTyConApp comErrorTc [] -- that?
15:13:42 <lispy> @hoogle TyCon -> TypeRep
15:13:43 <lambdabot> Data.Typeable.mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
15:13:53 <monochrom> err s/mkAppTy/myTyConRep/
15:14:23 <lispy> but what is myTyConRep?
15:15:14 <monochrom> I don't know what it does.  But I know it has the right type.  It also seems to be the only one with the right type.
15:15:22 <lispy> i think ihope's suggestionjust compiled :)
15:15:41 <lispy> oh you meant mkTyConRep
15:15:42 <monochrom> But it's also my suggestion.
15:15:57 <lispy> (with the my I thought you meant I should define something)
15:16:05 <lispy> the 'my'
15:16:14 <monochrom> Darn.
15:16:23 <monochrom> I need auto-completion.
15:17:03 <lispy> @hoogle IORef
15:17:03 <lambdabot> Data.IORef :: module
15:17:04 <lambdabot> Data.IORef.IORef :: data IORef a
15:17:04 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
15:17:34 <lispy> @hoogle fixIO
15:17:35 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
15:17:36 <monochrom> Wow there is atomic
15:18:01 <lispy> atomic what?
15:18:04 <lispy> cheese mice?
15:18:06 <nn2> help! just spent 1 houre configureing EggBot ! now is on chanel But ont responding!!!!
15:18:14 <monochrom> atomicModifyIORef
15:18:43 <monochrom> You have lost the bot.  Buy a new one.
15:19:35 <nn2> how do i issue a comand
15:19:41 <ihope> nn2: what?
15:19:59 <nn2> to eggbot
15:20:16 <ihope> What's the guy's nick?
15:20:22 <davidhouse> what's eggbot?
15:20:27 <ihope> @google eggbot
15:20:28 <nn2> nnbot
15:20:29 <lambdabot> http://www.taomc.com/teaching_machines/eggbot.htm
15:20:49 <lispy> is IO broken?
15:20:49 <ihope> There's no nnbot here, according to WHOIS.
15:20:57 <monochrom> IO is not broken.
15:21:04 <nn2> no no on my server
15:21:06 <lispy> when why do we have fixIO?
15:21:13 <lispy> ;)
15:21:15 <davidhouse> hah! :)
15:21:18 <ihope> nn2: what is your server?
15:21:21 <monochrom> hahahaha fixed point not fix problems
15:21:30 <nn2> srv256.homelinux.net
15:21:43 <nn2> #test
15:21:44 <ihope> "fix error" is the easy way to get rid of all those pesky error messages!
15:22:17 <monochrom> Next time we have a language war
15:22:25 <monochrom> someone please remember to mention that.
15:22:46 <monochrom> "Haskell has 'fix error' can you do that in C++!!!"
15:23:05 <ihope> :-D
15:25:44 <smithj> when trying to get ghc compiled for my distro, i see instructions to "Unpack the HC files on top of a fresh source tree (make sure the source tree version matches the version of the HC files exactly!)." but where are these .hc files? i can't find the tarball i'm supposed to unpack on top of the source
15:26:16 <davidhouse> they're arch-dependant, so i don't think they'd be in the source tarball.
15:26:18 <lispy> where is TypeLib?
15:26:19 <smithj> and i don't seem to be able to make sufficient unregisterised intermediate C files either
15:26:24 <smithj> davidhouse: i
15:26:24 <lispy> @hoogle TypeLib
15:26:25 <lambdabot> No matches found
15:26:29 <smithj> 'll need x86 and x86_64
15:26:37 <smithj> so if anyone has an idea...
15:27:01 <davidhouse> smithj: "There may be some supplied on the GHC download page,"
15:27:13 <smithj> davidhouse: right, but there isn't afaict
15:27:30 <smithj> i see docs, binaries, and source
15:27:50 <monochrom> I don't know of TypeLib.  Would it be just Data.Typeable?
15:27:57 <davidhouse> it may be that noone has built HC files yet.
15:28:14 <davidhouse> all the major archs have already been ported to, so when 6.4.2 came rolling out no-one had a need for them
15:28:19 <mauke> @index fix
15:28:20 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:28:23 <davidhouse> (no-one has built 6.4.2 HCs, i mean)
15:29:26 <lispy> monochrom: i suspect now that TypeLib is part of hdirect
15:29:36 <monochrom> Yeah.
15:30:05 <davidhouse> smithj, what goes wrong with an unregistered build?
15:30:34 <lispy> i have a .pkg file with this line: import_dirs  = ["${hd_libdir}"],
15:30:39 <lispy> any idea what i need to change it to?
15:31:17 <lispy> ghc-pkg comlains that it cannot expand variable "hd_libdir"
15:31:23 <smithj> davidhouse: when i try to actually build it, i get this:
15:31:23 <smithj> make[1]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.  Stop.
15:31:26 <monochrom> Are you supposed to change it manually?
15:31:43 <smithj> and indeed that file exists nowhere in the source tree
15:31:44 <monochrom> I would think some makefile or some ./configure sets it.
15:32:24 <monochrom> I guess hd stands for hdirect, and ${hd_libdir} refers to where you will install hdirect.
15:32:41 <lispy> good point
15:32:43 <davidhouse> you might want to try posting to glasgow-haskell-users, smithj.
15:33:26 <davidhouse> does your target distro not have any kind of RPM system?
15:34:00 <smithj> davidhouse: we technically do, but i need a clean bootstrap for personal sanity when maintaining it
15:34:38 <davidhouse> well i think obtaining a clean bootsrap might strip you of that personal sanity ;)
15:35:12 <monochrom> haha
15:35:39 <smithj> perhaps :-)
15:37:50 <davidhouse> i think an unregistered build should work (no idea why it isn't at the moment), but i'm no GHC expert.
15:41:08 <isaacd> @remember monochrom Next time we have a language war someone please remember to mention that. "Haskell has 'fix error' can you do that in C++!!!"
15:41:09 <lambdabot> Unknown command, try @list
15:41:12 <Igloo> smithj: Why is machine-generated .hc files better than a binary?
15:41:39 <monochrom> lambdabot doesn't know me.
15:42:01 <isaacd> monochrom: what does that mean?
15:42:15 <isaacd> can I do what I tried to somehow?
15:42:42 <monochrom> It means we cannot store my sayings into it and we cannot recall my sayings from it by citing my nick.
15:42:49 <monochrom> @palomer
15:42:49 <lambdabot> Hrmph
15:42:53 <monochrom> @monochrom
15:42:53 <lambdabot> Unknown command, try @list
15:43:02 <monochrom> Difference.
15:43:13 <xerox> I think there is something weird going wrt quote module.
15:43:42 <xerox> To my understanding @keal, @palomer, and alikes aren't the same as @quote <nick>.
15:43:56 <monochrom> I heard there is some hardcoding of who is recognized.
15:44:04 <monochrom> @quote monochrom
15:44:04 <lambdabot> monochrom hasn't said anything memorable
15:44:08 <isaacd> I have to go now
15:44:33 <monochrom> @quote monochrom Next time we have a language war someone please remember to mention that. "Haskell has 'fix error' can you do that in C++!!!"
15:44:33 <lambdabot> monochrom Next time we have a language war someone please remember to mention that. "Haskell has 'fix error' can you do that in C++!!!" hasn't said anything memorable
15:44:38 <monochrom> @quote monochrom
15:44:39 <lambdabot> monochrom hasn't said anything memorable
15:44:47 <mauke> @help quote
15:44:47 <lambdabot> quote <nick>
15:44:47 <lambdabot> remember <nick> <quote>
15:44:47 <lambdabot> Quote somebody, a random person, or save a memorable quote
15:45:08 <xerox> monochrom - I think there is a slight community-approved sarcastic feeling underneath the fact of having an harcoded @nick.
15:45:11 <lispy> iirc @quote is broken
15:46:00 <xerox> @help remember
15:46:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:48:50 <ricebowl> @pl \x -> x
15:48:50 <lambdabot> id
15:49:18 <monochrom> @pl \_ _ _ _ _ x _ _ _ -> x
15:49:18 <lambdabot> const (const (const (const (const (const . const . const)))))
15:49:25 * monochrom giggles
15:49:45 <monochrom> @pl \_ _ _ y _ x _ _ _ -> x y
15:49:46 <lambdabot> const (const (const (const . ((const . const . const) .) . flip id)))
15:49:51 * monochrom giggles more
15:50:13 * xerox buys an `a'
15:50:35 * monochrom giggles uncontrollably
15:50:43 <xerox> hahaha.
15:51:53 <mauke> @pl \f x g y -> f x (g y)
15:51:54 <lambdabot> ((.) .)
15:53:16 <xerox> @pl (\a b c -> a b c,\a b c -> a c b,\a b c -> b a c,\a b c -> b c a,\a b c -> c a b,\a b c -> c b a)
15:53:16 <lambdabot> (id, flip, flip id, flip flip, flip . flip id, flip (flip . flip id))
15:53:45 * xerox mutters about patterns
15:54:39 <lispy> what is the .pkg syntax?  i'm getting the error "Line 1: Invalid syntax (no colon after field name) on this line: Package{ name = "com",
15:56:15 <monochrom> Odd.  I see no colon whatsoever in a typical .pkg file.
15:56:48 <lispy> where did you find a typical one?
15:56:57 <monochrom> gtk2hs
15:57:31 <lispy> it looks like .pkg files might be read using read
15:57:46 <lispy> oh, n/m
15:58:00 <lispy> not that any of that had any relevance ;)
15:58:30 <xerox> Goodnight.
15:58:34 <Lemmih> You're editing .pkg file manually?
15:58:35 <monochrom> Are you sure you were not accidentally running ghc over a .pkg file? :)
15:59:01 <lispy> Lemmih: kindof, since the provided one was broken
15:59:16 <lispy> monochrom: i'm running ghc-pkg -u < com.pkg
16:00:38 <Pawer> hi 
16:00:48 <monochrom> I'm thinking "ghc-pkg register com.pkg" is a better idea.  Throw in --user if that's what you mean by -u
16:01:55 <lispy> same error
16:02:13 <maihem> has anybody compiled yi on ubuntu before? I'm trying to figure out the dependencies, but the README isn't clear on the matter and google doesn't want to help. Anybody got any tips?
16:02:45 <Lemmih> maihem: Check the build-depends in the .cabal file.
16:03:57 <lisppaste2> lispy pasted "bad package file?" at http://paste.lisp.org/display/20489
16:05:41 <maihem> thanks Lemmih
16:07:36 <monochrom> Yuck, perhaps ghc-pkg does not read .pkg at all.
16:09:49 <lispy> what does read .pkg?
16:10:14 * lispy stands around confused
16:10:32 <ihope_> I have too many channels open...
16:10:44 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#package-management
16:12:08 <lispy> where is the specification of the format?
16:12:18 <lispy> i followed the link, but i don't think that's the format is it?
16:12:18 <monochrom> scroll down on that page
16:12:21 <lispy> that's just the output
16:12:29 <monochrom> that is also the input
16:12:46 <lispy> ah
16:13:07 <monochrom> format changed at 6.4
16:15:40 <lispy> huh
16:15:53 <lispy> yeah, added a version to that mess (after tweaking the syntax) and it seems to be accepted
16:22:28 <ihope_> Regexes are too powerful. What's a bit less scary?
16:24:59 <heatsink> a parser?
16:25:24 <heatsink> dunno what you're doing
16:26:30 <lispy> break?
16:26:34 <lispy> @hoogle break
16:26:35 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
16:26:35 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
16:26:35 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
16:29:49 <ihope_> @hoogle (a -> m Bool) -> (a -> m a) -> a -> m a
16:29:50 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
16:30:15 <ihope_> @hoogle (a -> m Bool) -> (a -> m b) -> a -> m b
16:30:15 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
16:30:34 <ihope_> @type while
16:30:35 <lambdabot> Not in scope: `while'
16:30:39 <ihope_> @type until
16:30:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:31:01 <ihope_> Hmm.
16:32:15 <lispy> > break (=='a') "pizza"
16:32:16 <lambdabot>  ("pizz","a")
16:32:23 <heatsink> @type unfoldr
16:32:24 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:33:31 <heatsink> @type (\f g -> unfoldr (\x -> if g x then Just (f x, f x) else nothing))
16:33:32 <lambdabot> Not in scope: `nothing'
16:33:35 <cmarcelo> hello!
16:33:35 <heatsink> @type (\f g -> unfoldr (\x -> if g x then Just (f x, f x) else Nothing))
16:33:37 <lambdabot> forall a.
16:33:37 <lambdabot>                         (a -> a)
16:33:37 <lambdabot>                         -> (a -> Bool)
16:33:37 <lambdabot>                         -> a
16:33:37 <lambdabot>                         -> [a]
16:33:54 <ihope_> muntil c f x = c x >>= \c' -> if c' then return x else f x >>= \f' -> muntil c f f'
16:34:04 <ihope_> s/f'/x'/g
16:43:28 <ihope_> Now, why is the tail function called "tail" and not "decapitate"? :-)
16:47:10 <SamB> @lambdabot
16:47:10 <lambdabot> Unknown command, try @list
16:47:14 <SamB> @source
16:47:14 <lambdabot> lambdabot 3p12, GHC 6.4.1 (Linux i686 3.20GHz)
16:47:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:47:45 <heatsink> Oh! so I proved that haskell is illogical the other day.  I think.
16:49:11 <heatsink> The type of fix is (a -> a) -> a, which is not true according to the curry howard isomorphism.
16:49:17 <lispy> okay, i give up on compiling hdirect
16:49:23 <Taral> lol
16:49:25 <Taral> hdirect
16:49:27 <stepcut> hrm, I split my module into two seperate modules -- and now my code runs 8x slower :-/
16:50:14 <lispy> Taral: you've used hdirect?
16:50:22 <lispy> stepcut: that sucks
16:50:24 <Taral> tried to
16:50:35 <Taral> you'd be better off writing your own
16:51:00 <lispy> i wanted the typelib -> .hs support, but i can't get that part to compile
16:51:02 <SamB> heatsink: is it false, though, or simply not provable?
16:51:50 <heatsink> SamB: It's false when a is false.
16:52:31 <SamB> well, who cares.
16:52:43 <Taral> False does not exist.
16:52:45 <heatsink> I just thought it was interesting.
16:53:04 <Taral> if a is provable, fix is provable.
16:53:19 <Taral> wait, no
16:53:27 <Taral> gah
16:53:30 <SamB> undefined is even stranger!
16:54:20 <Taral> fix id == undefined
16:55:28 <Taral> lispy: are your classes IDispatch?
16:56:30 <bringert> stepcut: oh nice
16:58:19 <SamB> Typelib parsing? I didn't see that.
16:58:21 <SamB> not that I care.
16:58:41 <SamB> because I only want to parse XPCOM type libraries, which are a totally different format
17:04:39 <Cale> heatsink: yeah, recursive functions allow for some types which don't correspond to logical theorems
17:05:06 <Cale> (which is probably related to the fact that djinn will never provide a recursive result)
17:13:14 <lispy> Taral: yeah
17:13:43 <lispy> we have a ton of IDispatch interfaces
17:13:50 <lispy> no way i'm coding it all by hand
17:14:09 <lispy> but hdirect won't compile and i've followed the directions + tweaked things
17:14:32 <heatsink> Cale: oh, that kinda makes sense.  Thanks.
17:14:58 <SamB> I've got a kid who is trying to install GHC 6.4.1-2.1, but gets this error:
17:14:59 <Taral> lispy: If you have IDispatch, you can use the dynamic dispatch-by-name interfae.
17:15:01 <Taral> interface.
17:15:01 <SamB> /var/lib/dpkg/info/ghc6.postinst: /usr/sbin/haskell-utils: /usr/bin/runhugs: bad interpreter: No such file or directory
17:15:12 <SamB> is Igloo around?
17:15:20 <SamB> because I think he is responsible for this!
17:15:50 <lispy> Taral: huh, i'll look into it
17:15:54 <dons> moin
17:16:23 <Taral> samb: bug in haskell-utils
17:16:40 <lispy> Taral: is taht in the Automation library?
17:16:56 <Taral> lispy: let me find it again
17:17:04 <SamB> Taral: well, he maintains that too!
17:17:08 <SamB> so it is still his fault!
17:17:13 <Taral> heh
17:17:38 <monochrom> debian ghc depends on debian haskell-utils, debian haskell-utils assume debian hugs.  Install hugs.
17:18:07 <SamB> well, it shouldn't assume, it should Require:
17:18:27 <Igloo> It does depend on it. Is hugs installed and working?
17:18:28 <monochrom> I forgot the exact dependency.
17:18:44 <Taral> lispy: You're looking for IDispatch members GetIDsOfNames and Dispatch
17:18:45 <SamB> oh, Depend. whatever.
17:18:50 <Taral> er, Invoke.
17:19:03 <monochrom> Anyway this is why I don't use the debian packages.  I don't want hugs.
17:19:07 <SamB> hugs is not apparantly installed
17:19:28 <Taral> lispy: Yeah, a lot of helper stuff is in the automation library
17:19:48 <lispy> Taral: actually, I think I'll just use python
17:19:49 <Igloo> SamB: I'll need more info to see what went wrong
17:19:55 <Taral> lispy: k
17:20:04 <lispy> we already have com working great there :)
17:20:25 <SamB> Igloo: what info will you need?
17:20:37 <SamB> oh, I need to go do something...
17:20:45 <Igloo> SamB: Can you paste the whole output from the apt command (or whatever) somewhere?
17:21:03 <Taral> samb: something is weird -- haskell-utils Depends: hugs
17:26:29 <nn2> Igloo, wait a secound
17:26:37 <nn2> to big for flood
17:26:57 <nn2> give you it on my webserver
17:27:03 <nn2> one secound
17:28:49 <stepcut> Taral: there is a script in that package that calls hugs explicitly -- blame igloo
17:28:51 <stepcut> :)
17:29:05 <nn2> ok here is the adress
17:29:37 <nn2> http://srv256.homelinux.net:5190/flood.txt
17:30:20 <Taral> stepcut: But the package itself depends on hugs explicitly.
17:30:27 <Taral> It sounds like that guy has a broken system.
17:30:52 <Taral> bbiab
17:31:49 <nn2> sory that was all that wa left from buffer
17:35:32 * ihope_ feels pedantic
17:36:58 <Igloo> nn2: OK, thanks. I can't immediately see what's wrong, but I'll make a note to try to reproduce it when I have some more time
17:37:18 <ihope_> x >>= f . g = x >>= (f . g), right?
17:38:20 <damg|afk> night
17:41:23 <SamB> Igloo: note that he was on "stable" until just now
17:44:24 <Igloo> SamB: Yeah, but I still don't see why the new haskell-utils was unpacked before hugs was unpacked. It could be there's a dependency loop when you put the two together, but one doesn't immediately come to mind.
17:45:27 <SamB> Igloo: uh huh, I just thought it might be helpful if it wasn't immediately obvious from looking at that stuff he posted
17:45:47 <SamB> because you mentioned that you would try to reproduce it ;-)
17:46:48 <Igloo> OK, thanks  :-)
18:12:58 <cmarcelo> hello. i'm an student in this year SoC (thanks guys =) ). who's responsible for taking care of darcs.haskell.org repo? can I get an account there? or you guys are planning something else?
18:14:37 <cmarcelo> well, i think just found another place. =)
18:15:06 <dons> hey :)
18:15:17 <dons> yeah, we're planning on getting accounts for everyone, I think.
18:15:24 <dons> the mentors are discussing this now.
18:16:15 <dons> (I'm the mentor for the bytestring project, btw)
18:16:41 <dons> cmarcelo: are you looking to have a blog too?
18:16:55 <dons> (it might be nice to add SoC blogs to planet.haskell.org, I think)
18:17:19 <cmarcelo> dons: i'm considering using pugs svn repo, that would be ok?
18:17:40 <nn2> @cycle
18:17:40 <lambdabot> Unknown command, try @list
18:17:40 <dons> yes, under the rules, it certainly ok.
18:17:54 <dons> you also want a darcs repo too?
18:18:02 <dons> or is that for something else?
18:18:14 <dons> nn2?
18:18:24 <dons> @hoogle cycle
18:18:25 <lambdabot> Prelude.cycle :: [a] -> [a]
18:18:25 <lambdabot> Data.Graph.Inductive.Example.ucycle :: Graph gr => Int -> gr () ()
18:18:25 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
18:18:30 <dons> perhaps?
18:21:36 <cmarcelo> dons: blog = probably yes, or at least a quasi-weekly report for the community, there's infrastructure for blogging in planet-soc.com ..
18:21:48 <nn2> gerr bot
18:22:39 <dons> cmarcelo: ah, good. didn't know that.
18:26:09 <dons> cmarcelo: also, if you ever need help with stuff like QuickCheck, haddock or other library-building infrastructure, feel free to ask here. :)
18:28:03 <LordBrain> hey... i'm reading the ghc manual.. and i've stumbled upon something which seems wrong probably only because i am still noobish.. but might be a typo
18:28:40 <cmarcelo> dons: thanks! =)
18:29:33 <LordBrain> ok i found teh same page online'
18:29:42 <LordBrain> its at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
18:30:04 <LordBrain> i'm looking under Liberalised type synonyms
18:30:14 <LordBrain> section 7.4.1.3
18:30:49 <LordBrain> I'm struck by: g f = f Int True
18:30:50 <monochrom> Why don't we call them "people's liberated type synonyms"
18:31:15 <dons> hehe
18:31:27 <LordBrain> i probably just dont know enough haskell, but it seems like a strange place to see Int
18:32:01 <dons> looks like its missing a :: or something.
18:32:06 <LordBrain> it looks like this could be a notation for specializing a polymorphic function?
18:32:12 <dons> its definitely wrong though.
18:32:15 <LordBrain> oh
18:33:25 <LordBrain> where would the :: go?
18:33:47 <dons> A.hs:7:8: Not in scope: data constructor `Int' 
18:33:54 <monochrom> Perhaps it is allowed by another feature, namely rank 2 polymorphism.
18:34:08 <dons> it should be 'f' applied to something. now what would that be. let's see..
18:34:10 <monochrom> Try enabling high high rank polymorphism.
18:34:15 <LordBrain> this is under extensions.. so i dont expect it to be standard haskell and it might need a switch or something..
18:34:41 <LordBrain> oh
18:34:41 <monochrom> Also try checking out the section on rank-n polymorphism
18:35:02 <monochrom> Examples in the manual are seldom self-contained!
18:35:09 <dons> should be:
18:35:10 <dons> g :: Discard Int -> (Int,String)    -- A rank-2 type
18:35:11 <dons> g f = f 7 True
18:35:19 <dons> type and arg were wrong.
18:36:21 <LordBrain> yeah it does seem like that should be String
18:36:33 <dons> well, the above actually type checks.
18:36:46 <dons> LordBrain: submit a doc bug report (and fix) on the ghc bug trackign page
18:36:51 <dons> haskell.org/ghc 
18:37:25 <LordBrain> ok
18:39:18 <dons> ihope, around?
18:39:28 <dons> @seen ihope
18:39:28 <lambdabot> I saw ihope leaving #haskell 2 hours, 37 minutes and 28 seconds ago, and .
18:49:30 <dons> @index assert
18:49:31 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
18:51:08 <audreyt> dons: heya. where does the rope repo live?
18:51:47 <dons> it'll be on darcs.haskell.org soon. its on sjanssen's box atm.
18:51:59 <dons> once its stable, we'll merge it into fps, I presume.
18:52:20 <audreyt> oh, I don't worry about that; I want to track the ongoing fun :)
18:52:43 <dons> yeah, me to. we're arranging all the usual stuff. darcs, blog feeds and patch feeds
18:52:54 <audreyt> nodnod
18:52:58 <dons> mux, ot your patch now.
18:53:04 <dons> s/ot/got/
18:53:51 * dons builds ghc, lambdabot and fpps simultaneously, and wonders why  the laptop seems, umm, unresponsive
18:54:07 <mux> dons: cool, I know what to fix now
18:55:18 <monochrom> dons is crazy.
18:56:18 <dons> if only we had distghc
18:56:20 <LordBrain> what is fpps?
18:56:44 <dons> fps, i mean. responsiveness  bad :)
18:57:01 <LordBrain> google gave me federal personal payroll system
18:59:29 <audreyt> I always parsed it as frames per sec
18:59:52 <dons> better than some people i've noticed calling fps "BS".
18:59:53 <dons> ;)
19:00:10 <dons> unfortunate acronym.
19:00:29 <mux> heh
19:00:38 <mux> DBS?
19:00:44 <dons> not DBS. :P
19:01:20 <audreyt> OSX GHC642 has been "coming soon" for a month now ;)
19:01:29 <audreyt> (http://haskell.org/ghc/download_ghc_642.html)
19:01:52 <mux> that's OK: Vista has been coming soon for a year
19:02:07 <LordBrain> so is the fps you're referring to fast packet strings?
19:02:32 <dons> packed.
19:02:34 <dons> @where fps
19:02:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:02:52 <mux> it's cool :-)
19:02:54 <dons> audreyt: its rapidly becomign the most faq'd here :)
19:03:15 <dons> "where's ghc for the max x86" "why isn't it here now?" "when will it be here?"
19:03:59 <audreyt> er, even for powerpc it's not there
19:04:50 <dons> yeah, wolfgang must be on holiday?
19:04:51 <LordBrain> i'm only using 6.2.2
19:05:07 <LordBrain> ghc version i mean
19:05:09 <dons> LordBrain: ?
19:05:21 <LordBrain> its just the install from debian stable
19:05:58 <LordBrain> why the puzzled look?
19:06:07 <LordBrain> did i say something nonsensical?
19:06:28 <dons> oh, i just lost the context for why you're telling us about which ghc version you use.
19:07:04 <LordBrain> well i'm only starting in haskell
19:07:37 <LordBrain> so i havent had time to get all impatient about the latest release...
19:07:41 <LordBrain> hehe
19:07:59 <dons> ah, I see.
19:09:16 <LordBrain> i just discovered the wiki page on frag.. its cool there is a 3d shooter written in haskell
19:09:53 <dons> it is very cool.
19:10:04 <dons> only 12 weeks work too :) 
19:10:06 <LordBrain> i guess i havent had the impression that haskell is the most zippy language.. i think the website or the docs recommended ocaml
19:10:14 <dons> nah,
19:10:17 <dons> ?shootout
19:10:17 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
19:10:31 <dons> its one of the fastest languages out there
19:10:45 <dons> and getting faster daily.
19:11:05 <dons> there's still a lot more room to push the language into parallelism and advanced optimisations not possible elsewhere.
19:11:49 <dons> do you happen to have a url for the page that recommended ocaml?
19:12:09 <audreyt> (or, well, more mundane work, like fast strings or mutable collections ;))
19:12:12 <dons> (i know on one page, it says if ocaml is ever faster, this should be reported as a bug in ghc)
19:12:33 <audreyt> oh? I thought the ghc manual says if hugs/nhc is faster
19:12:34 <dons> well, even fast strings use loop fusion rewriting, which is beyond gcc at least.
19:12:38 <audreyt> then it should be reported as a bug
19:12:47 <dons> audreyt: well, we got more cocky ;)
19:12:54 <audreyt> havn't heard about hte ocaml one
19:13:02 <dons> actually, i think it might be "it may be a bug"
19:13:18 <dons> ?wiki Performance
19:13:18 <lambdabot> http://www.haskell.org/haskellwiki/Performance
19:13:53 <dons> if an equivalent OCaml, SML or
19:13:53 <dons> Clean program is faster, this might be a bug.
19:14:04 <dons> which is fair enough, I think.
19:16:03 <LordBrain> i dont know.. all i know is that in the faq it said one of the complaints about haskell is the speed of the programs, and recommended ocaml as a functional language which has many of the features of haskell but faster.. if i recall right.. could just be the unfounded bias of the faq writer or something i suppose
19:16:19 <dons> which faq, do you have the url?
19:16:26 <LordBrain> maybe i can find it again
19:16:37 <dons> i think that statements wrong these days.
19:17:27 <LordBrain> yeah maybe its just an obsolete statement
19:18:32 <yip> ocaml allows direct imperative programming
19:18:45 <yip> and ocaml has a very efficient garbage collector
19:19:42 <dons> so does monadic haskell, hence the shootout results for the language's are roughly the same (except haskell wins on concurrency, iirc)
19:20:42 <yip> i'm not sure that "monadic" haskell does stack variables as well as ocaml
19:21:53 <LordBrain> what's non-monadic haskell?
19:21:57 <LordBrain> :)
19:22:03 <LordBrain> even lists are monads..
19:22:20 <dons> well, i have no data on that. though this test requires efficient stack handling, and haskell wins out: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
19:22:47 <dons> LordBrain: haskell not written inside a monad
19:22:47 <Cale> LordBrain: yeah, it's just a matter of the compilers getting better and the libraries becoming available which allow for fast code.
19:23:55 <dons> there's been strong growth in fast libraries the last couple of years, and an accompanying improvement in the compiler. 
19:24:03 <LordBrain> good.. i like type classes.. 
19:24:08 <LordBrain> ocaml doesnt have them
19:24:13 <LordBrain> :D
19:24:47 <LordBrain> i recall liking sheme better than ocaml.. and haskell better than scheme
19:25:50 <LordBrain> its kinda like rejecting types.. and then coming back to them
19:25:58 <LordBrain> :)
19:26:24 <LordBrain> scheme was fun to write.. but not as satisfying to read
19:28:37 <LordBrain> when you say efficient stack handling.. are you talking about the cpu stack? like the call stack? 
19:28:56 <LordBrain> so for handling non-tail recursion?
19:29:55 <LordBrain> i'm talking to dons here
19:32:07 <mux> pentane% pwd
19:32:08 <mux> /home/mux/haskell/fps
19:32:12 <mux> pentane% darcs annotate README
19:32:15 <mux> darcs failed:  There is no file or directory named 'README'
19:32:31 <mux> any idea what's happening?
19:32:39 <mux> there is a README file of course
19:33:32 <dons> works here.
19:33:43 <dons> $ darcs --version
19:33:43 <dons> 1.0.7 (release)
19:33:43 <mux> mm, I have 1.0.6, do you have 1.0.7?
19:33:47 <mux> I see
19:38:52 * Cale pokes dons and points at LordBrain
19:41:21 <dons> oh. sorry. ghc building. what was the question? /me scrolls.
19:41:52 <dons> well, yip said something about stack handling, and I assumed he was talking about pushing variables onto the stack in recursive calls
19:53:34 <stepcut> dons: I dorked around with the parsers today -- Everything I did was an order of magnitude slower than my first attempt :)
19:54:14 <stepcut> dons: actually, just splitting my module into two more sensible modules resulted in a 8x slow-down :-(
19:55:29 <dons> inlining magic, perhaps
19:56:17 <dons> often some carefully placed INLINEs can give big improvements in fps code, at least in the library itself. also you'll wnat -O2 -funbox-strict-fields
19:56:40 <stepcut> I tried, -O2, I did not try -funbox-strict-fields
19:56:56 <stepcut> I am going to try the INLINES next time I get a chance to mess around
19:57:42 <stepcut> For now, I will probably just leave everything in one module so I can work on the other important stuff :)
19:58:27 <dons> yep.
19:59:17 <stepcut> I started work on a lazy parser -- but it also had an 8x slow down -- even when it was in the same module -- so that will have to wait till later
19:59:36 <stepcut> I made the mistake of implementing a really fast solution first :)
19:59:39 <dons> fair enough. performance is fine, though, isn't it? so tuning it further is just a bonus?
19:59:42 <dons> yeah.
20:00:28 <stepcut> The performance is very good
20:01:11 <stepcut> The lazy parser would just be an added bonus
20:17:29 <palomer> mapM = \f x -> sequence $ map f x ?
20:18:30 <dons> mapM f as       =  sequence (map f as)
20:18:35 <dons> from the src.
20:26:00 <Captain_Fourier> @list
20:26:00 <lambdabot> list [module|command]. Where modules is one of:
20:26:00 <lambdabot> babel base compose dice dict djinn drHylo dummy elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda
20:26:00 <lambdabot> version vixen where
20:35:53 <stepcut> > ) ; flip dons theBird (
20:35:53 <lambdabot>  Parse error
20:35:56 <stepcut> ;)
20:36:53 <dons> :P
20:37:15 <dons> no more code injection attacks, hopefully.
20:37:30 <stepcut> good riddens
20:44:43 <Stinger_> heh I was just wondering about that
22:26:48 <Cale> > "(" )
22:26:48 <lambdabot>  Parse error
22:27:51 <stepcut> ) ; AACTION Parse error (
22:27:58 <stepcut> > ) ; AACTION Parse error (
22:27:58 <lambdabot>  Parse error
22:28:00 <stepcut> :p
22:28:22 <palomer> <:O
22:28:30 <dons> yeah, i thought about that.
22:28:38 <dons> even if you get it through, it'll be prepended with a space.
22:28:54 <dons> (i.e. so type errors couldn't be exploited, I think)
22:29:03 <dons> > undefined :: AACTION
22:29:05 <lambdabot>  Not in scope: type constructor or class `AACTION'
22:29:10 <palomer> eh, what was the bug?
22:29:32 <dons> you didn't get spammed by rogue lambdabot's trying to do ctcp a few days ago?
22:30:52 <xerox> Yes, malformed DCCs
22:31:11 <dons> some one finally thought to chase up the code injection issues with the runplugs module/wrapper system. so now we actually parse the expressions to check they're valid haskell 'exp's. the flaw was harmless, all you could do was print strings as if you were lambdabot. but its annoying.
22:31:58 <dons> and actually disappointing that someone in the channel would be so annoying to the other users
22:32:08 <dons> oh well. live and learn.
22:32:31 <dons> @seen vincenz
22:32:31 <lambdabot> Last time I saw vincenz was when I left #darcs, #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it, #haskell.se, #haskell_ru and #scannedinavian 1 day, 1
22:32:31 <lambdabot> hour, 51 minutes and 44 seconds ago, and .
22:32:46 <xerox> Negative karma!
22:33:05 <dons> yeah, i should inspect the lambdabot logs from that day.
22:33:54 <stepcut> btw, the otherday i though it might be nice if @seen finished off with 'Its 3am where vincenz is.'
22:34:02 <stepcut> (or whatever the local time is)
22:34:36 <dons> oh, so @seen should invoke @localtime?
22:35:00 <stepcut> something like that
22:35:04 <dons> yeah, nice idea.
22:35:09 <stepcut> someone did, @seen dons
22:35:33 <stepcut> and right after lambdabot finished, someone said, "It's 7am where dons is"
22:35:45 <dons> yeah, often you see @seen followed by @localtime 
22:35:46 <stepcut> and I thought it was lambdabot at first :)
22:35:57 <dons> heh
22:36:35 <stepcut> for some reason, I think I might like it better if it is imprecise too -- like rounded to the nearest 15 min or something
22:36:56 <dons> yeah, sounds reasonable
22:37:09 <dons> otherwise people always try to work out whose clock is out
22:37:21 <stepcut> heh
22:37:39 <stepcut> that an the precise time takes too much effort to read
22:37:46 <dons> yep.
22:37:53 <xerox> What about sending TWO @localtimes and diff?
22:38:18 <dons> mm?
22:38:23 <dons> to other people
22:38:25 <dons> ?
22:38:32 <xerox> To the person who did the @seen
22:39:07 <xerox> Hmm, no, we aren't talking of "...and he will probably be back in n minutes".
22:39:16 <dons> and well, accuracy isn't too important :) 
22:39:23 <stepcut> speaking of @localtime, I am going to bed now
22:39:26 <stepcut> @localtime stepcut
22:39:27 <lambdabot> Local time for stepcut is Fri May 26 22:39:06 2006
22:39:44 <dons> @localtime dons
22:39:47 <lambdabot> Local time for dons is Sat May 27 15:33:04 2006
22:39:54 <dons> now, _whose_ clock is wrong?
22:39:56 <xerox> dons lives in the future (:
22:40:02 <dons> well, that too.
22:40:21 <xerox> That's why he can optimize things, he can see them before us :-P
22:40:25 <stepcut> dons: yours maybe?  --> 5261 ?        SLs    0:00 /usr/sbin/ntpd -p /var/run/ntpd.pid
22:40:30 <dons> ;)
22:40:37 <dons> it is almsot always mine.
22:41:18 * stepcut really goes to bed now
22:41:34 * xerox runs to school
22:41:38 <xerox> ~~bye
22:41:49 <palomer> >:o
22:46:07 <adu> wow i just gave support on something i know nothing about
22:46:07 <dons> @quit new logging code
22:50:13 <palomer> dons: is there a way to find out the ranking of each command?
22:56:52 <dons> the ranking?
22:58:26 <dons> what did you mean by that?
22:58:30 <palomer> usage
22:58:40 <dons> the most commonly used commands?
22:58:43 <palomer> yu
22:58:44 <palomer> p
22:58:52 <dons> give me 1 minute to craft  some sed...
22:59:03 <dons> (/me happens to have lambdabot logs on hand)
22:59:38 <sieni> @eval and @pl perhaps?
22:59:38 <lambdabot>  Parse error
22:59:48 <sieni> lambdabot: sorry ;-)
23:00:14 <dons> i'll take bets, if you like. 1.50 on @eval or @hoogle
23:00:39 <palomer> 2 banana bucks on @hoogle
23:01:09 <dons> and the results are...
23:01:23 <dons> coming soon ...
23:01:53 <dons>      55 karma+
23:01:53 <dons>      56 keal
23:01:53 <dons>      60 docs
23:01:53 <dons>      68 palomer
23:01:53 <dons>      69 help
23:01:55 <dons>      80 localtime
23:01:57 <dons>      97 google
23:02:00 <dons>      99 djinn
23:02:02 <dons>     186 index
23:02:05 <dons>     201 where
23:02:07 <dons>     226 seen
23:02:10 <dons>     321 pl
23:02:12 <dons>     619 hoogle
23:02:15 <dons>    1175 type
23:02:17 <dons> ok, but that doesn't include @eval.
23:02:20 <dons> gimme a sec.
23:02:23 <dons> palomer, are you in the top 10?
23:02:35 <palomer> no:(
23:02:36 <palomer> #11
23:02:52 <palomer> by 1!
23:02:54 <palomer> hah!
23:03:04 <dons> so maybe 12 really, with eval jsut computing now..
23:04:00 <dons> 3974 eval
23:04:09 <palomer> whoa
23:04:20 <palomer> I forgot about priv msgs
23:04:29 <dons> no, that's just in channel over the last 2 months
23:04:38 <dons> not including priv msgs.
23:04:46 <palomer> wait, my command has only been up 1 month
23:04:50 <palomer> at this rate I'll beat djinn!
23:04:56 <palomer> @palomer
23:04:56 <lambdabot> Brump!
23:04:59 <dons> ok, let me try just this month then.
23:05:36 <aasmith> so what haskell books do you guys regard highly?
23:05:38 <aasmith> if any. :)
23:05:56 <palomer> I don't regard any of them highly, but yaht higher than most
23:06:13 <palomer> the community should come together and write the book to end all haskell books
23:06:34 <sieni> aasmith: I don't know if there are any. Yaht is nice, although not a book (as in dead trees and stuff).
23:06:44 <aasmith> *nod*
23:07:08 <dons>      28 v
23:07:08 <dons>      33 fptools
23:07:08 <dons>      33 kind
23:07:08 <dons>      34 keal
23:07:08 <dons>      40 help
23:07:11 <dons>      49 google
23:07:13 <dons>      52 palomer
23:07:16 <dons>      56 localtime
23:07:18 <dons>      80 djinn
23:07:21 <dons>      83 index
23:07:23 <dons>     113 where
23:07:26 <dons>     135 seen
23:07:28 <dons>     138 pl
23:07:31 <dons>     336 hoogle
23:07:33 <dons>     596 type
23:07:36 <dons> 1695 eval
23:07:39 <dons> so palomer, you make the top 10!
23:07:46 <palomer> yes!
23:07:48 <palomer> woot
23:08:01 <dons> wow. what ever did we talk about before @eval?
23:08:15 <sieni> for example "Haskell: The Craft of Functional Programming" is really annoying that it explains really basic things and when things start to get interesting and worth reading, it moves to next subject. And monads are practically completely ignored.
23:08:27 <dons> and @pl , @djinn , @where @localtime @google and @kind are all very new too.
23:08:39 <palomer> I beat kind!
23:08:41 <palomer> hah!
23:08:54 <dons> Craft of Fun Prog. is more a beginner programmer's text book.
23:08:56 <sieni> what does @palomer do?
23:08:59 <dons> its widely used still in first year courses.
23:09:02 <palomer> gives wisdom
23:09:03 <palomer> @palomer
23:09:03 <lambdabot> I think you're all nuts
23:09:09 <palomer> @palomer
23:09:09 <lambdabot> I think you're all nuts
23:09:11 <palomer> @palomer
23:09:11 <lambdabot> I think you're all nuts
23:09:16 <dons> huh
23:09:18 <sieni> dons: indeed
23:09:44 <dons> @palomer -- dare i try to break the magic?
23:09:44 <lambdabot> Brump!
23:09:51 <palomer> you broke the magic
23:09:59 <sieni> @palomer
23:09:59 <lambdabot> That's nuts!
23:10:04 <sieni> @palomer
23:10:04 <lambdabot> They're telling you lies!
23:10:05 <dons> ndm, hoogle's the 3rd most popular plugin! :)
23:10:17 <palomer> ndm?
23:10:26 <dons> author of hoogle.
23:10:30 <dons> @seen ndm
23:10:30 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 9 hours, 46 minutes and 5 seconds ago, and .
23:10:35 <dons> oh.
23:10:48 <palomer> hoogle is extra useful
23:10:56 <palomer> it's the one thing that sets haskell apart
23:11:03 <dons> yeah, it subsumes @index and @type in some cases.
23:11:12 <sieni> @hoogle +
23:11:13 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
23:11:13 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
23:11:13 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
23:11:21 <sieni> <3
23:11:44 <dons> i just resynced hoogle too, so we're runnign the newest versoin
23:12:30 <dons> @version
23:12:31 <lambdabot> lambdabot 3p17, GHC 6.4.1 (Linux i686 3.20GHz)
23:12:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:12:38 <dons> oh, should be 3.1p17
23:12:42 <dons> my sed is faulty
23:17:18 <dons> palomer: so what you hacking on now? is uni still on over there?
23:17:59 * dons only has a vague concept of what goes on in the northern hemisphere 
23:18:31 <dons> @quit bring back plugins
23:18:40 <dons> @version
23:19:04 <lambdabot> lambdabot 3.1p18, GHC 6.4.1 (Linux i686 3.20GHz)
23:19:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:22:53 <jethr0> dons: btw, do you know whether hoogle tests for editing distance? sometimes it gives weird results (i.e. missing "obvious" functions)
23:22:57 <jethr0> @hoogle >
23:22:57 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
23:22:57 <lambdabot> Prelude.(>=) :: Ord a => a -> a -> Bool
23:22:57 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
23:23:41 <dons> no, i don't think it does edit distance stuff.
23:23:53 <dons> would be easy to steal lambdabot's code for that though
23:24:11 * jethr0 wonders why it doesn't come up with (>>>) and (>>=)
23:24:38 <dons> @hoogle+
23:24:38 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
23:24:39 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
23:24:39 <lambdabot> Control.Arrow.(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
23:24:45 <jethr0> AAHH
23:24:48 <dons> (i.e. @more output0
23:24:52 <jethr0> didn't know about that
23:25:03 <dons> yeah, maybe we could use @more for that now.
23:25:38 <dons> edit distance would still be a good idea, since it is a search engine.
23:26:03 <jethr0> you mean as in correcting or as in sorting/filtering?
23:27:30 <dons> correcting
23:27:35 <dons> @hoogle mop
23:27:36 <lambdabot> No matches found
23:27:39 <dons> bah
23:28:14 <dons> the code could be stolen from here, too, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Util.hs 
23:28:22 <jethr0> @hoogle subtact
23:28:22 <lambdabot> No matches found
23:28:49 * dons puts in a feature request on hoogle's wiki page
23:29:12 <jethr0> i guess for correcting behaviour one would have to preprocess the whole index and build a HUGE list of "similar" words... or is there a smarter way, like pseudo-hashing?
23:30:06 <dons> you use the levenshtein algorithm. that'd be ok, i think
23:30:11 <dons> only if the match fails the first time.
23:30:15 <dons> this is how lambdabot does it.
23:30:19 <dons> closest :: String -> [String] -> (Int,String)
23:30:26 <jethr0> i know the algo, the question is how to apply it forward (i.e. without a concrete word to compare against)
23:30:30 <dons> word, index, returns how many edits and the result word
23:30:54 <jethr0> ah, but for a big index that might be too slow and need some precalc., no?
23:30:55 <dons> oh, hoogle already has an index though, so all's in place, i think.
23:31:13 <dons> maybe. [ByteString] would be ok i think
23:31:40 <dons> oh, its only 256k
23:31:59 <dons> so that'd be fine with a [ByteString]. maybe ok with [String]
23:32:06 <jethr0> where's that wiki?
23:32:17 <dons> ?wiki Hoogle
23:32:18 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
23:32:21 <dons> ?gwiki Hoogle
23:32:23 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
23:32:33 <dons> the latter actually asked google to search
23:32:41 <jethr0> @wooki Hoogle
23:32:41 <dons> the former is just a hack
23:32:41 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
23:33:08 <dons> (gwiki is actually a different command, was my point)
23:33:18 <jethr0> ah, k
23:33:21 <dons> (it asks google to search a domain for a page)
23:33:36 <dons> ?wiki FooBarPage
23:33:37 <lambdabot> http://www.haskell.org/haskellwiki/FooBarPage
23:33:40 <dons> ?gwiki FooBarPage
23:33:42 <lambdabot> No Result Found.
23:33:52 <dons> the latter is the correct answer.
23:33:59 <jethr0> @gwiki fbinterpreter
23:34:01 <lambdabot> No Result Found.
23:34:08 <jethr0> @gwiki bfinterpreter
23:34:09 <lambdabot> No Result Found.
23:34:37 <jethr0> k, gotta go do some more learnin'
23:52:01 <ricebowl> is there any way to make GHCi display a newline instead of printing "\n"
23:52:55 <integral> putStr "\n" :)
23:53:36 <integral> (eg. if foobar :: Integer -> String;  do 'putStr foobar 123', instead of just 'foobar 123' at the prompt)
23:53:49 <ricebowl> I see
23:53:57 <ricebowl> thanks
