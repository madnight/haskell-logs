00:00:39 <Lemmih> yi requires both versions?
00:05:00 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles -- new puzzle :)
00:09:23 <vincenz> Cale: how did you come up with this
00:09:27 <vincenz> Cale: and how do you generate em
00:09:38 <vincenz> and what do you use to draw these things/
00:10:20 <Cale> I came up with it after doing lots of a similar type of puzzle called slither link. Slither link is like my puzzle, but with a square grid, and the "map" would just be a circle.
00:10:47 <Cale> I generate them by hand, adding clues and solving in stages as I go along.
00:10:50 <vincenz> ah
00:10:56 <vincenz> well
00:11:01 <Cale> I use inkscape
00:11:05 <vincenz> would b ecool if there were a format to describe the left side
00:11:07 <vincenz> the circles
00:11:09 <xerox> Cale++  (:
00:11:26 <vincenz> that way... you could a) generate them automatically, b) if you have a tool that is able to solve em, be able to parse this into that tool
00:11:38 <vincenz> generate them, as in generate the drawings
00:11:42 <vincenz> with cairo
00:11:44 <vincenz> and save2pn
00:11:45 <vincenz> g
00:12:01 <Cale> well, you could specify the left side with a couple of permutations, I think
00:12:10 <Cale> though in a somewhat non-obvious way
00:12:14 <vincenz> hmm
00:12:19 <vincenz> I googled for slitherlink
00:12:20 <vincenz> they don't use maps
00:12:42 <vincenz> (plus your graphics are way fancier making your puzzles more attractive
00:12:55 <Cale> yeah, that's because their map would always be the same :)
00:13:07 <vincenz> oh, always one circle?
00:13:12 <Cale> yes
00:13:25 <vincenz> I see
00:13:27 <vincenz> :)
00:13:49 <vincenz> well in that case any solver of your puzzle is a generalization of the solver for slither link
00:14:22 <vincenz> if you use as premise an adjancency graph instead of fixing it to hexagonal vs matrix grid
00:15:04 <vincenz> hmm
00:15:14 <vincenz> left side can prolly also be defined with an adjacency graph on color and void
00:15:20 <jip> you should add some javascript so that you can look for the solution by coloring grid elements by clicking on them
00:16:50 <vincenz> Cale: if you want I can hack up a haskell gui this weekend that generates drawings like on the left based on an adjancency grap
00:17:02 <vincenz> and then does what jip says
00:17:16 <vincenz> Cale: if by then you can fix some sort of format, that'd be great
00:17:45 <Cale> well, any map will do
00:18:27 <vincenz> map?
00:18:33 <Cale> yes
00:18:42 <vincenz> not quite sure what you men
00:19:50 <Cale> a planar map
00:20:00 <Cale> like in the 4-colour theorem
00:21:53 <vincenz> oh
00:21:57 <vincenz> yes
00:21:59 <vincenz> a graph
00:22:08 <Cale> a graph with an embedding into the plane
00:22:24 <vincenz> I think that would be an interesting thing on it's own
00:22:32 <vincenz> generating those circly thingies in an appealing way
00:23:15 <Cale> You can't just treat them as the obvious graphs, because, for example, in the new puzzle, I have a loop which surrounds the inside flower-like configuration
00:23:30 <vincenz> I saw
00:23:32 <vincenz> sure you can
00:23:35 <vincenz> just have one extra color
00:23:37 <vincenz> Outside
00:23:47 <Cale> well, if you just stored the graph
00:24:03 <Cale> then there would be a problem -- you could move the loop off of the inside
00:24:21 <Cale> you also have to store the exact manner in which the regions are adjacent
00:24:26 <vincenz> hmm?
00:24:31 <vincenz> I fail to see the difficulty
00:24:35 <vincenz> for the last puzzle
00:25:17 <Cale> well, which graph were you thinking of storing?
00:25:21 <vincenz> Out <-> Yellow, Yellow <-> Blue, Yellow <-> Purple, Yellow <-> Green, Green <-> Red, Blue <-> Red, Purple <-> Red, Blue <-> Green, Blue <-> Purple, Purple <->Blue
00:25:30 <Cale> ah, okay
00:25:35 <Cale> that almost captures it
00:25:38 <Lokadin> say what is there in Data.ByteString to replace FastString... ByteString?
00:25:39 <Cale> but not quite
00:25:46 <vincenz> I think it does
00:26:02 <vincenz> the only useful information in the circly thing is adjancency
00:26:03 * Cale draws
00:26:03 <vincenz> which is a graph
00:26:50 <vincenz> and inkscape makes some cool drawings :)
00:27:17 * vincenz uses oodraw, but mostly cause it's better for graph like things (graph in the sense of nodes with text and arrows pointing to other nodes)
00:29:07 <xerox> Cale: you should screencast an inkscape session sometime :)
00:29:18 * vincenz agrees with xerox 
00:29:33 * Cale makes two inequivalent maps with the same graph
00:30:26 <vincenz> purrfect
00:31:32 <xerox> http://live.gnome.org/Istanbul
00:33:24 <Cale> http://cale.yi.org/autoshare/maps.png
00:33:51 <Cale> those are not to be considered the same
00:34:17 <vincenz> not sure how those inequivalences would map to the hexgrid
00:34:58 <vincenz> but I get the gist
00:35:01 * vincenz ponders
00:35:29 <Cale> Imagine the map, as well as the solution drawing as collections of curves in R^2.
00:35:49 <vincenz> Cale: not exactly programmatically representable
00:36:13 <Cale> The rule basically says that there has to be an (orientation-preserving) homeomorphism R^2 -> R^2 which sends the curves in the map to the curves on the grid.
00:36:37 * xerox -> tea
00:36:49 <vincenz> homeomorphism == homomorphism?
00:36:52 <Cale> nope
00:37:06 <Cale> A homeomorphism is a continuous map with a continuous inverse
00:37:34 * vincenz just shrugs
00:38:22 <Cale> none of this is particularly programmable :)
00:39:01 <vincenz> I disagree
00:39:05 <vincenz> if there is some repr for th emap
00:39:11 <Cale> Well, the continuous version isn't
00:39:13 <vincenz> then bruteforce can be a solver
00:40:30 <Cale> For the discrete representation of the map, you really have to encode, for each region not just which regions are adjacent, but also retain the order in which the adjacencies occur.
00:40:51 <Cale> (say, as you travel counterclockwise around the region)
00:40:53 <vincenz> yep
00:41:02 <Cale> and they can occur more than once
00:41:15 <vincenz> well there's only an ordering issue
00:41:24 <vincenz> if multiple regions lie ON an adjancency
00:41:31 <vincenz> like the drawing you made
00:41:41 <vincenz> cause if they're just freeflowing inside a region, there's no prob
00:41:49 <jip> inside a "execState", how can i have an intermediate "runState" ?
00:41:58 <Cale> so really, you have a set of lists of adjacencies, I suppose
00:42:09 <xerox> jip: there exist both of those functions
00:42:12 <Cale> (or a set of cycles of adjacencies)
00:42:22 <xerox> ?doc Control.Monad.State
00:42:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
00:42:33 <Cale> jip: intermediate?
00:42:48 <xerox> (And evalState.)
00:42:59 <xerox> Ops misread.
00:43:05 <shapr> Lokadin: I updated conjure from FPS to ByteString easily. It's mostly the same.
00:43:08 <xerox> get?
00:43:18 <Cale> normally, if you're already in a State monad, you just use bind to run other state computations
00:43:29 <Cale> @type (>>=)
00:43:30 <lambdabot> forall (m :: * -> *) b a.
00:43:30 <lambdabot>    (Monad m) =>
00:43:30 <lambdabot>    m a -> (a -> m b) -> m b
00:43:31 <shapr> wli: How's code?
00:44:02 <Cale> though you can just apply runState as usual if you want
00:44:03 <jip> something like execState (do { foo; a <- evalState bar; g a }
00:44:10 <Cale> (bind does that for you though)
00:44:13 <Lokadin> shapr: yea i'm aware, it's just the unsafeUseAsCString that's giving me problems because it says it's not is Scope and i Can't figure out why cause i can plainly see it being exported from Char8
00:44:20 <Cale> let a = evalState bar;
00:44:36 <xerox> Like local in Reader, maybe.
00:45:26 <Cale> btw, if you solve my puzzle, send me the solutions :)
00:45:32 <shapr> Lokadin: I fixed it, just a moment...
00:45:44 <Lokadin> shapr: kk :)
00:45:55 <xerox> Okay!
00:46:30 <xerox> Do you guarantee there are solutions?
00:46:32 <xerox> (:
00:46:42 <Cale> I try to guarantee that there's only one :)
00:46:52 <shapr> Lokadin: sjanssen told me yesterday that the Char8 module is just a wrapper around code from the ByteString module that substitutes Char for Word8 in the type signatures.
00:46:59 <Cale> (but as you can see, I've messed that up before :)
00:47:10 <vincenz> Cale: maybe a separate page with some sort of methodology as how to solve these things?
00:47:19 <xerox> No fun! :)
00:47:22 <vincenz> like a 'hints' section for the newbs or those wishing to automate it
00:47:25 <vincenz> xerox: SEPARATE page
00:47:30 <shapr> Lokadin: So I have import qualified Data.ByteString.Char8 as BS ; import qualified Data.ByteString as ByteString; import Data.ByteString (ByteString) and then I use ByteString.unsafeUseAsCString
00:47:38 <Cale> vincenz: yeah, I plan to write a proper step-by-step solution to the sample problem
00:47:45 * xerox falls over the chair
00:47:50 <Cale> but the interesting part is that the map is always different
00:48:02 <shapr> Lokadin: unsafeUseAsCString is in Data.ByteString, but not in Data.ByteString.Char8
00:48:15 <vincenz> Cale: would be even cooler if you could make one hexgrid with numbers, and then have different solutions with two different maps without altering the numbers
00:48:17 <Lokadin> shapr: oh okay thanks :)
00:48:36 <Cale> vincenz: that's very possible
00:48:52 <Cale> I can already think of one, with no numbers in it even :)
00:48:56 <vincenz> preferably wit..
00:49:04 <shapr> Cale: Then you have to submit it to sgt-puzzles
00:49:13 <vincenz> .preferably with a grid that's not too sparse or you'll be putting all the stuff in the map
00:49:28 <Cale> yeah
00:49:29 <vincenz> Cale: wasn't sure about writing that... in fact I was backspacing until you said that
00:49:44 <shapr> dcoutts: Did you ever fix up the Arbitrary instance for ByteString for extra bug finding speed?
00:50:00 <dcoutts> shapr, yes
00:50:01 <Cale> if there are no numbers, and the puzzle is uniquely solvable, it's not very interesting
00:50:11 <dcoutts> shapr, or rather dons did
00:50:15 <shapr> dcoutts: Ok, I won't do that then :-)
00:50:22 <Cale> (well, I don't think it is, anyway...)
00:50:33 <Cale> there might be some interesting cases actually
00:50:49 <vincenz> Cale: have an equal number of circles as grid-hexes
00:50:55 <vincenz> :D
00:51:06 <dcoutts> shapr, it may need tuning. It'd also be interesting to see if introducing subtle bugs actually makes the tests fail.
00:51:06 <vincenz> then remove some and see that you can't force things with proper adjancency
00:51:07 <Cale> well, that would do, you can actually do a lot better
00:51:23 * Lokadin hugs shapr!! 
00:51:30 <Lokadin> yay it worked !! :)
00:51:30 <shapr> Lokadin: Glad I can help :-)
00:51:38 <dcoutts> shapr, I suspect the QC tests still don't get several of the subtle boundary cases in the .Lazy module
00:51:55 <Cale> like a bunch of concentric circles, enough to force the board to be filled
00:51:59 <vincenz> dcoutts: manual UT then?
00:52:03 <vincenz> er manually oded
00:52:07 <vincenz> Cale: yeah
00:52:17 <vincenz> Cale: but I think it woudl be more interesting if the map is less symmetrical
00:52:23 <Cale> vincenz: but yeah, to understand how to solve the puzzles, I recommend solving them by hand first :)
00:52:40 * vincenz has a bunch of papers to review, not to mention I'm behind on my planning :/
00:53:16 <Lokadin> shapr: should i send off the patch to dons? 
00:54:17 <Lokadin> it's for yi
00:55:25 * Lokadin has never contributed anything to the open source community before and is rather lightheaded at the prospect of contributing to such a major economic force
00:56:02 <xerox> Hexagons aren't exactly handy to write down on paper...
00:56:09 <shapr> Lokadin: Sure yeah
00:56:17 <Lokadin> kk
00:56:20 <vincenz> btw
00:56:24 <vincenz> a really cool way to wake up
00:56:29 * xerox hunts for the wacom tablet
00:56:31 <vincenz> wake up in the middle of some reasoning on haskell code
00:56:37 <shapr> Yeah, I agree.
00:56:41 * vincenz woke up and was alreaady in the middle of a thought about haskell
00:56:41 <shapr> I woke up thinking about conjure.
00:56:50 <vincenz> I wonder if it was from before or if it was a continuation from a drema
00:57:14 <shapr> Maybe your dreams run as coroutines?
00:57:20 <vincenz> hard to tell
00:57:29 <vincenz> I lack a breakpoint debugger
00:58:25 <Cale> I've actually done that, though I simply continued from where I left off when I'd fallen asleep.
00:58:28 <shapr> hi defcon8, defcon8_, defcon8__... how's code? Any trouble with monads?
00:58:48 <Cale> ... which was annoying, since I wanted to remember my dream, and that basically erased it.
00:58:50 <vincenz> Cale: I think so too
00:58:59 <vincenz> Cale: I never remember my dreams so it hardly matters
00:59:08 <vincenz> maybe I don't dream
00:59:23 <shapr> I think almost everyone dreams.
00:59:45 <shapr> If you want to remember your dreams, put a notebook (or voice recorder) by your bed and record your dreams immediately.
01:00:09 <Lokadin> can eventually achieve lucid dreaming like that to
01:00:13 <shapr> Admittedly, I knew an accountant chick once who I am convinced did not have a subconscious mind or any dreams... so not everyone.
01:00:21 * shapr does lucid dreaming
01:00:27 <ADEpt> shapr: hi. I take it that number of projects reduced to 35?
01:00:37 <shapr> hm?
01:00:38 <vincenz> shapr: you assume I wake up postdream remembering
01:00:48 <vincenz> shapr: I never at all, not even when wake up have any inkling of idea what I dreamt about
01:01:07 <Lokadin> shapr: like real lucid dreaming? or the kind wher you sorta change things in sorta a way you want it to? i mean do you achieve full or semi consciousness in lucid dream
01:01:22 <shapr> vincenz: If you're relaxed when you wake up and you slowly wake up hanging onto the dream, you'll get it.
01:01:39 <vincenz> I wokke up VERY relaxed today...reasoning about haskell, not dreams
01:01:49 <shapr> Lokadin: Like, I know I'm dreaming and sometimes it's boring because I know I can't wake up right now or I won't get enough sleep :-)
01:01:50 <vincenz> in fact I preempted my alarm by 20 minutes
01:01:54 <vincenz> even though I only slept 5 hours
01:02:37 <mgoetze> i'm sure i do dream, but even right after waking up i generally don't remember them
01:02:47 <vincenz> mgoetze: idem
01:02:52 <shapr> vincenz: You can also get someone to wake you up during REM and immediately ask you what you dreamed.
01:03:31 <shapr> It's not so good for your sleep patterns, but it's a good way to start grabbing your dreams.
01:03:36 * vincenz lives alone
01:03:53 <vincenz> is dream-remembrance really that crucial?
01:04:03 <shapr> No, just if you want it.
01:04:04 <Lokadin> shapr: well lucid dreaming, from what a guy i know tells me, you can basically control your entire surroundings and get anything to happen that you want because you have total control over your surroundings, that's full consciousness in dreaming, but it's really hard to hold onto, or so he says, i haven't personally experienced anything like that
01:04:42 <vincenz> Lokadin: I experienced that when I was younger...well semilucid... typically before waking up and typically puberal dreams
01:04:48 * vincenz coughs
01:04:55 <Lokadin> vincenz: lol
01:05:09 <shapr> Lokadin: Yeah, I can do that. The next step (imho) after that is having full consciousness but being able to not affect your dream in order to peer clearly into your own unconscious mind.
01:05:33 <vincenz> dreaming = garbage collection
01:06:07 <Lokadin> shapr: i herd the next step after lucid dreaming is OOB, where you can step out of your body and explore the world as you sleep, but that's highly er, argued
01:06:16 <jip> http://www.lucid-dreaming-kit.com
01:06:31 <shapr> Recent sleep research implies that the brain is a collection of synchronized components that become desync'd during dreaming.
01:06:43 <shapr> Lokadin: Haven't tried that. Not sure I want to.
01:07:35 <shapr> So I suspect lucid dreaming is more about being able to resync while asleep. I wonder whether training yourself to function without enough sleep, too much alcohol, etc are ways to improve that?
01:07:39 <Lokadin> shapr: recent research also found that DMT a potent hallucingen is released during sleep from the pineal gland
01:07:56 <shapr> wow crazy
01:08:00 <Lokadin> yea
01:08:12 <Lokadin> they found a correlation, not a causal link so far
01:08:18 <Lokadin> but it's quite obvious
01:08:18 <Lokadin> lol
01:08:27 <vincenz> DMT?
01:08:37 <Lokadin> DMT is considered the most potent hallucinigen in the world
01:08:55 <vincenz> full name...
01:09:12 <Lokadin> Dimethyltryptamine
01:09:20 <Lokadin> http://en.wikipedia.org/wiki/Dimethyltryptamine
01:09:30 <vincenz> jip: that website looks like such bs
01:10:09 <jip> yeah :D
01:10:27 <Cale> I've also been thinking about designing a puzzle which involves life&death of go groups somehow.
01:10:48 <vincenz> Cale: remove the 'of go groups somehow'
01:10:55 <Cale> heh
01:11:42 <Cale> Basically, something which would be extremely hard for a computer, but possible for humans familiar with go. :)
01:12:05 <vincenz> easy, keep the puzzles varied
01:12:13 <vincenz> for instance ladder checking is an eay thing to do
01:12:16 <vincenz> if you know you have to check for it
01:12:33 <vincenz> the second part is less easy to ascertain by a comp
01:18:54 <vincenz> is it possible to have a dynamic bacground in gnome?
01:19:38 * xerox got sucked into Cale's puzzle.
01:20:21 <xerox> So I have missed the dreaming discussion!  Aww
01:21:20 <azuroth> I hate adding in base sixty. bah
01:22:04 <kosmikus> Cale: do you generate the puzzles by computer though, or verify them?
01:24:23 <vincenz> for some zenny fun
01:24:24 <vincenz> http://chir.ag/stuff/sand/
01:24:45 <jip> modify is (s -> s) -> m(), i need something like (s -> (a, s)) -> m a
01:25:15 <vincenz> jip: define (s -> (a, s))
01:25:17 <vincenz> where is a coming from
01:25:49 <vincenz> and what is being done with the new s
01:25:52 <vincenz> is it stored?
01:26:11 <Cale> kosmikus: neither
01:26:27 <jip> vincenz: new s should replace the state
01:26:37 <Cale> unless you count "drawing in inkscape"
01:26:42 <vincenz> jip: COULD?
01:26:50 <vincenz> oh ...sorry misread that
01:26:51 <Cale> I suppose I get good use out of undo.
01:27:20 <Cale> making puzzles this way is basically as fun as solving them.
01:27:29 <Cale> though it takes a lot longer
01:27:38 <vincenz> jip: anyways...
01:27:43 <vincenz> jip: what you want is basically a 
01:27:53 <vincenz> get/map followed by a modify
01:28:00 <vincenz> given how 'a' is defined in terms of the original s
01:28:12 <xerox> @type runState
01:28:13 <lambdabot> forall s a. State s a -> s -> (a, s)
01:28:13 <kosmikus> Cale: ah, ok, so it's really a lot of work, then
01:28:25 <kosmikus> Cale: and it's hard to decide how difficult it is ...
01:28:41 <vincenz> kosmikus: it's hard to eve ndecide if it's unambiguously solveable
01:29:05 <Cale> no, deciding if it's ambiguously solvable isn't really any harder than solving it
01:29:09 <jip> runState looks good but i can't figure out how to use it inside of an execState
01:29:15 <Cale> (though you can't make mistakes :)
01:29:29 <vincenz> jip: maybe you should try to explain what it is you're trying to do
01:29:44 <Cale> It's easier to construct the puzzle if you don't have a particular solution in mind at the start
01:30:04 <Cale> in puzzle 2, I did though, and if you solve it, that will become obvious :)
01:30:14 <kosmikus> Cale: indeed :)
01:30:30 <xerox> jip: ah-ha!
01:31:07 <kosmikus> Cale: but if you start selling these things to newspapers, you'll have to have a way to generate several per day ;)
01:31:10 <xerox> > execState (do { s <- get; State jip}) 1; jip s = (undefined,s+2)
01:31:11 <lambdabot> 3
01:31:27 <xerox> @type Control.Monad.State.State
01:31:27 <lambdabot> forall a s. (s -> (a, s)) -> State s a
01:31:31 <xerox> (:
01:31:46 <Cale> kosmikus: Depending on difficulty, I could construct them fairly quickly.
01:32:08 <vincenz> xerox: that's not hidden?
01:32:19 <xerox> Nope.
01:32:19 <Cale> That last one took me quite a while though.
01:32:33 <vincenz> Cale: don't forget that soon they'll expect a daily easy, medium and hard one
01:32:40 <Cale> hehe
01:32:44 <vincenz> Cale: and a monthly distribution of 100 puzzle books
01:33:01 <vincenz> as well as some japanese name
01:33:04 <vincenz> like sodoko
01:33:17 <jip> hm... haskell in the morning maybe isn't such a good idea :|
01:33:34 <Cale> I wish there were 100 puzzle books for most of nikoli's puzzles.
01:33:35 <xerox> すじわどくしにかぎる
01:33:38 <xerox> In japanese.
01:33:41 <lispy> Haskell: The breakfast code of champions
01:34:06 <Cale> Sudoku are easy to obtain, and Kakuro are becoming more popular now, but those are probably my least favourite two.
01:34:17 * xerox nods
01:34:19 <vincenz> heh
01:34:24 <vincenz> there's no fun to sudoku
01:34:27 <vincenz> it's computer solveable
01:34:39 <Cale> well, it's not so much computer solvability
01:34:39 <xerox> Well, people like it :)
01:34:47 <vincenz> xerox: the uninformed masses, sure
01:34:51 <Cale> but how mechanically if forces you to think
01:34:56 <vincenz> Cale: indeed
01:35:09 <vincenz> Cale: which is a derivative of computer solvability, use the mechanical algo in the computer solver
01:35:09 <xerox> Cale: my father does many, I'll show him your puzzles :)
01:35:28 <Cale> vincenz: yeah, I suppose so
01:35:46 <vincenz> mostly a lot of fiddling with bookkeeping, which computers are better at
01:36:39 <Cale> I really like nurikabe and masyu. The easy such puzzles are trivial to solve mechanically, but for harder ones the amount of mechanical work you'd need gets insane.
01:39:35 <vincenz> did you look at that link?
01:41:56 <Cale> vincenz: the sand thing? yeah, that's cool :)
01:42:15 <vincenz> I got it from this site
01:42:20 <vincenz> http://www.chaoskitty.com/webzen/
01:42:29 <vincenz> (that image is actually my desktop bg)
01:42:59 <vincenz> I do remember ther was a flash thing once that gave you a sand box like that to make your own zen garden, but I lost it :(
01:44:25 <shapr> dons: I just swapped emails with Marc van Woerkom, he's happy doing Language.C instead of Language.PHP.
01:46:38 <vincenz> http://www.japangarden.co.uk/skin1/pages/US/information/zenscrngrdn.swf
01:46:47 <dcoutts> shapr, great
01:46:57 <shapr> Weird, Marc's application is assigned to both ChilliX and me at the same time.
01:47:11 <shapr> dcoutts: And ChilliX has agreed to mentor for Language.C, yay!
01:47:56 * dcoutts didn't realise Manuel was on #haskell
01:48:07 <dcoutts> hia ChilliX :-)
01:48:30 <shapr> I guess he's incognito.
01:48:33 <dcoutts> shapr, yep, that is good news.
02:00:25 <norpan> hi guys
02:01:23 <azuroth> hey norpalo
02:22:12 <Lokadin> hmmm, that's odd i modified Yi/Curses.hs but it claims that i have not..
02:22:19 <Lokadin> when i do darcs new
02:23:00 <norpan> indeed
02:23:28 <shapr> Lokadin: Is Curses.hs generated from Curses.hsc ?
02:23:36 <Lokadin> oh
02:23:39 <Lokadin> that could be it:)
02:23:40 <Lokadin> thanks:)
02:23:53 <shapr> In that case Curses.hs wouldn't be in the darcs repo, so changes wouldn't be noticed.
02:25:33 <norpan> the build system should never keep Curses.hs after compilation imho
02:26:00 <shapr> Neat idea
02:26:08 <Lokadin> norpan: needs it to generate haddock
02:26:20 <norpan> oh
02:26:35 <Lokadin> AFAIK
02:26:40 <norpan> then it should keep it
02:26:41 <shapr> Haddock could be generated as part of the build.
02:26:42 <norpan> :)
02:27:20 <norpan> otoh maybe it needs to generate Curses.hs to see that nothing needs to be built
02:30:50 <vincenz> Cale: going to screencast an inkscape drawing session for those funky bubbles?
02:31:49 * Cale looks into it
02:32:42 <xerox> @google Instanbul screencast
02:32:43 <lambdabot> http://www.redhat.com/archives/fedora-extras-list/2005-July/msg01063.html
02:32:50 <xerox> Well, that.
02:35:25 <Lokadin> i don't know why but when i do ./Setup.lhs haddock it only generates doc's for Curses.hs and Main.hs
02:35:37 <Lokadin> i think Yi.hs as well but nothing else
02:35:54 <Lokadin> oh nm
02:36:03 <Lokadin> nothing else has haddock documentatation
02:40:05 <Lokadin> kk i sent both patches to dons
02:40:43 <Lokadin> hopefully he'll like them, but my long comments are rather long
02:44:32 <norpan> i tried to put the 'c' command into the Vim.hs file but that requires changing mode so no luck
02:45:36 <Lokadin> why didn't it work
02:45:43 <Lokadin> i thought yi supported mode changes
02:46:20 <norpan> yes, but the place where i would put it I could only return an Action
02:49:07 <Lokadin> oh
02:49:10 <Lokadin> hmmm 
02:49:20 * Lokadin searches for dons paper on yi
02:51:19 <Lokadin> well it describes on page 8 section 5.7 something about modes
02:51:26 <Lokadin> dono if that would help you any though
02:51:28 <azuroth> what's that quote about X and enforcing policy?
02:51:41 <Lokadin> norpan: i'm sure you've seen it already
02:53:32 <norpan> yeah
02:53:41 <Lokadin> :S i sent dons three patches i hope he doesn't get annoyed, 
02:54:04 <Lokadin> cause the last two are like 9 lines comibned
02:54:56 <Lokadin> eh
02:55:03 <Lokadin> i'll find out i guess
02:55:55 <norpan> i think you will
02:58:16 <dons> tomasz is funny "On the other hand, this is quite cool and I am probably wrong"
02:59:39 <dons> dcoutts: any chance I could get login access on the amd64 box?
03:00:46 <dons> Lokadin: i haven't received any patches yet. did they get mailed?
03:01:03 <Lokadin> dons: yea
03:01:20 <dons> hmm. well.. they're not here yet anyway.
03:01:42 <Lokadin> i dono if my computers mail server works, though it said that mail was sent successfully with darcs
03:02:04 <pjd> does yi only have interfaces patterned after existing editors?
03:02:17 <pjd> or is there experimentation with new ones?
03:02:56 <shapr> iirc, the interface is just a typeclass, so you can do whatever you want.
03:03:08 <dons> pjd, i hint at new ones in the paper. the process of encoding the existing interfaces as lexers reveals lots of oddities in the grammars they have.
03:03:21 <dons> but we don't actually have any novel interfaces, no.
03:03:46 <dons> the interface is just a lexer function, so easy enough to code up new ones.
03:04:58 <shapr> Write a voice interface :-)
03:05:02 <dons> hehe
03:05:18 <shapr> I have some ideas on how it would work too.
03:05:35 * dons -> dinner time!
03:09:00 <Lokadin> eat (dinner time)
03:09:24 <Lokadin> i guess it would be an alternating variable
03:09:28 <Lokadin> er IO
03:09:48 <xerox> eat =<< dinner
03:11:33 <BCoppens> Itkovian: to get a message to De Bosschere, would it be fastest to mail him or just say it to you?
03:13:42 <pjd> does the lexer approach deal with things like timeouts (for input combinations)?
03:13:43 <Lemmih> ADEpt: ping.
03:14:06 <pjd> (sorry, i should probably read the paper)
03:18:46 <Lokadin> xerox: well dons :: IO Announce, time :: Int, dinner :: ?, and the exclamation mark seems like either a ; synonym or a simple syntax error
03:21:54 <xerox> Lokadin: dinner :: (MonadFood m, Dinner a) => Time -> m a
03:22:14 <Lokadin> lol :)
03:22:59 <Cale> hmm, all these screencasting tools seem to not like inkscape too much. I'll give you the poor-man's screencast: a description.
03:23:55 <xerox> Okay.
03:23:59 <Cale> Create a circle by picking the circle tool and then holding ctrl while dragging.
03:24:24 <Cale> Then a rectangle. Any rectangle will do so long as it's larger than the circle
03:25:09 <Cale> Put the rectangle on top of the circle, then select first the circle, then holding shift, the rectangle.
03:25:17 <Cale> (both should be selected)
03:25:26 <Cale> Path -> Difference
03:25:53 <Cale> You should then have a circle with a flat bit on it.
03:25:58 <xerox> Right.
03:26:24 <Cale> Object -> Transform -> Rotate. Enter 60 degrees and apply.
03:26:41 <xerox> Duplicate, mirror :-D
03:26:56 <Cale> yeah
03:29:02 <Cale> You have to be a little careful to get the lengths right, but it's not hard to eyeball it and get close enough that the border will hide any discrepancy
03:29:57 <Lokadin> dons: did you get the mail, i think i fixed the mail server of mine
03:30:14 <Cale> actually, if you wanted to get it even more perfect, intersecting with a hexagon would make aligning things even easier
03:31:34 <Cale> yeah, actually, I recommend that
03:33:00 <Cale> make a guide, create a circle with that guide along its diameter, make a giant hexagon, and line up the vertices of the hexagon with the guide, overlapping so a portion of the circle sticks out, then intersect them
03:41:17 <ghum> "mahlzeit"
03:42:25 <dozer_> runhaskell Setup.lhs configure -ghc
03:42:34 <dozer_> Setup.lhs: haifa.cabal:22: Parse of field 'extensions' failed:
03:42:39 <dozer_> any idea what's going on here?
03:42:53 <dcoutts_> it probably needs a more recent version of cabal
03:43:03 <dozer_> ah pants
03:43:15 <dcoutts_> what version have you got atm?
03:43:28 <dozer_> I just built ghc-6.4.2
03:43:35 <dcoutts_> oh, hmm, that should be ok
03:43:49 <dcoutts_> in that case perhaps it's using old extension names
03:43:54 <dozer_> is there a ghc-6.5 in cvs that would be worth trying?
03:44:01 <dcoutts_> no
03:44:19 <dcoutts_> you've got more or less the latest cabal version anyway
03:44:41 <dcoutts_> it;s much more likely that the package you're building is using deprecated extension names
03:44:49 <dozer_> ok
03:45:03 <dcoutts_> and they just need changing to the new names
03:45:34 <dozer_> it didn't build with 6.4.1 and google told me it was because they where using stuff in 6.4.2
03:45:43 <dcoutts_> hah
03:45:59 <dcoutts_> and you did that and now you find...
03:46:08 <dcoutts_> poor dozer_
03:46:24 <dozer_> yeah :(
03:46:26 <dcoutts_> what are the extensions in question?
03:46:38 <dozer_> the error message doesn't list them
03:46:46 <dcoutts_> it's in the .cabal file
03:46:50 <dozer_> I have found all the extensions in the cabal file
03:46:50 <dcoutts_> extension: ...
03:47:02 <dozer_> extensions:
03:47:02 <dozer_>         MultiParamTypeClasses,
03:47:02 <dozer_>         FunctionalDependencies,
03:47:02 <dozer_>         AllowUndecidableInstances,
03:47:02 <dozer_>         TemplateHaskell
03:47:47 <dcoutts_> change: AllowUndecidableInstances/UndecidableInstances
03:49:16 <dcoutts_> dozer_, does that work now?
03:49:35 <dozer_> setup configure won't accept -ghc now
03:49:42 <dozer_> it gives me a useage message :/
03:49:47 <dozer_> if I drop the ghc it does something
03:50:27 <dozer_> my bad - needed --ghc
03:50:43 <dozer_> Setup.lhs: cannot satisfy dependency syb-generics-any
03:50:47 <dozer_> so I need some other library?
03:51:40 <dcoutts_> dozer_, yes it's expecting a package called "syb-generics"
03:52:07 <dcoutts_> though I thought that all the SYB stuff was in ghc already
03:53:48 <dcoutts_> dozer_, http://www.dcs.shef.ac.uk/~simonf/downloads/syb-generics-2.9.tar.gz
03:53:58 <dcoutts_> mentined on http://www.dcs.shef.ac.uk/~simonf/HAIFA.html#Download
03:54:37 <dozer_> cool - got, built and installed
03:54:41 <dcoutts_> dozer_, that page says you also need HCI & Haskell XML Toolbox
03:55:56 <dozer_> dang - does haskell have a package manager like cpan that I can just say "get http and all dependencies"?
03:56:46 <Lemmih> dozer_: We will soon.
03:57:06 <dozer_> I've been using maven a lot for Java projects
03:57:07 <int-e> Woops. how can changing a type from Integer to Int slow down a program? (by a factor of two, no less)
03:57:12 <dozer_> seems to work nicely
04:02:50 <int-e> oh. Rational = Ratio Integer gets specialized code for most operations; Ratio Int doesn't. That could explain it.
04:10:37 <jip> is there a function that does both map and filter?
04:11:05 <jip> mapAndFilter :: (a -> Maybe a) -> [a] -> [a]
04:11:28 <jip> or even mapAndFilter :: (a -> Maybe b) -> [a] -> [b]
04:11:33 <audreyt> @hoogle (a -> Maybe b) -> [a] -> [b]
04:11:33 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
04:11:37 <audreyt> there you go.
04:11:47 <jip> hm... cool :D
04:11:55 <audreyt> np :)
04:13:01 <int-e> ok, implementing the little Ratio functionality that I was using (compare) myself I got a speedup of a factor of 2 instead of the slowdown.
04:29:40 <dozer_> are the haskell libraries under active development?
04:29:58 <dozer_> I mean, re-writing the implementations to go quicker and all that jaz?
04:30:06 <jip> yes
04:30:26 <dozer_> sweet
04:31:11 <ADEpt> Lemmih: pong
04:31:43 <jip> he's gone
04:34:16 <jip> what is infix, infixr, infixl?
04:34:46 <vincenz> jip: to define the fixity of an operator
04:35:40 <vincenz> infixr = right associative, ...l = left associative, infix = no associativity
04:35:46 <vincenz> afaik
04:35:55 <jip> what does the number mean?
04:36:00 <vincenz> priority
04:36:06 <jip> where are the docs for this?
04:36:09 <vincenz> a * b + c... * > + so it gets done first
04:36:15 <vincenz> (a* b) + 
04:36:16 <vincenz> c
04:37:56 <dozer_> seems I'm chasing dependencies
04:38:04 <dozer_> Setup.hs: cannot satisfy dependency NewBinary-any
04:41:28 <dozer_> I've found http://www.n-heptane.com/nhlab/repos/NewBinary/
04:41:49 <dozer_> is there a command I should be using to pull down the directory structure in the 'right' way?
04:43:42 <jip> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary/
04:44:24 <dozer_> thanks - was using the wrong URL with dards
04:45:30 <dozer_> looks like I didn't do a very good job of building ghc
04:45:42 <dozer_> configure: No haddock found
04:45:42 <dozer_> configure: No pfesetup found
04:45:49 <dozer_> among others
05:01:18 <jip> how come i normally can put the "then" right underneath the "if", but in do notation i get a parse error?
05:02:23 <jip> @hoogle a -> [a]
05:02:24 <lambdabot> Prelude.repeat :: a -> [a]
05:02:24 <lambdabot> List.intersperse :: a -> [a] -> [a]
05:02:24 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
05:02:51 <Igloo> Because of how the layout rule works
05:03:24 <jip> but why is do notation different?
05:03:40 <Igloo> It uses layout
05:19:16 <dozer_> @hoogle Codec.Base64
05:19:17 <lambdabot> No matches found
05:27:51 <shapr> dozer_: It's part of crypto
05:32:56 <dozer_> shapr: yeah, but as Codec.Binary.Base64 I think
05:33:30 <shapr> Something like that, what are you looking for?
05:33:40 <jip> whoah, check out this weird screenshot i got: http://img115.imageshack.us/img115/1752/x0026gk.png
05:33:59 <shapr> jip: Hey, have you uploaded your Yampa code?
05:34:07 <shapr> I'd like to see it.
05:34:09 <xerox> jip: integral curves? (:
05:34:20 <jip> shapr: not yet, maybe soon
05:34:21 <davidhouse> what on earth is that?
05:34:28 <jip> that is haskell opengl gone wrong
05:34:34 <xerox> Three dimensional directional field!
05:34:34 <davidhouse> heh
05:34:35 <vincenz> jip: can you do it somewhere that is not imageshack
05:34:45 <jip> vincenz: why?
05:34:51 <vincenz> cause our firewall won't let it through
05:34:59 <davidhouse> hold on.
05:35:02 <jip> that's one messed up firewall
05:35:05 <vincenz> no
05:35:07 <vincenz> it's blacklisted
05:35:14 <araujo> morning
05:35:16 <vincenz> just like many porn and game sites are
05:35:18 <vincenz> araujo: hell
05:35:19 <vincenz> o
05:35:31 <davidhouse> jip, try imagebin.org
05:35:32 <araujo> hi vincenz !
05:35:41 <dozer_> ok - looks like Codec.Base64 used to be part of http but isn't now
05:36:44 <vincenz> jip: falling stick?
05:39:37 <shapr> dozer_: Yeah, I hacked it in explicitly while slimming cabal-get. What are you writing?
05:40:26 <azuroth> vincenz: ssh tunnel ;-)
05:40:30 <dozer_> shapr: I'm trying to get haifa to compile
05:40:34 <jonkri> is there an explanation why JLabel.setBackground(Color.RED) doesn't change the background to red? i can use JLabel.setForeground... thanks
05:40:48 <jip> vincenz: no, just some weird lines
05:41:25 <vincenz> azuroth: yep
05:41:33 * vincenz is sshed to home
05:41:34 <vincenz> wget
05:41:40 <vincenz> put it in my personal /var/ww
05:41:41 <vincenz> :)
05:42:09 <azuroth> I just run squid at home and set firefox up to proxy through it
05:42:22 <vincenz> my upspeed is capped to 16kbs at home
05:42:24 <vincenz> not worth it
05:42:35 <vincenz> besides, it's not often I see blacklisted sites
05:42:37 <vincenz> only when like cscreenshots are put on imageschak
05:42:47 <azuroth> yeah, I guess that's true
05:43:17 <azuroth> though if you had two installs of firefox it'd be easiest :D
05:43:18 <shapr> dozer_: Have you asked Si\ when he's here on #haskell?
05:43:35 <dozer_> not yet
05:43:39 <dozer_> what's his irc handle?
05:43:49 <shapr> Si\
05:44:01 * vincenz ponders
05:44:02 <dozer_> cool
05:44:06 <shapr> He wrote HAIFA and CASHEW.
05:44:06 <vincenz> could that ever be a real name?
05:44:25 <shapr> vincenz: Do you know Arvind from MIT? That's his entire name.
05:44:29 <dozer_> yeah - I've dropped him a couple of e-mails recently
05:44:48 <vincenz> shapr: I know but you said "Have you seen Si\" .... what could Si\ be besides a nick
05:44:57 <dozer_> Si\Uni: ping
05:45:23 <vincenz> < dozer_> what's his irc handle?
05:45:43 <jonkri> can i give a jlabel a background color? i know it's a jcomponent, but it doesnn't work
05:48:12 <dozer_> jonkri: is this jlabel as in java swing, or some haskell thing I've not discovered yet?
05:48:34 <ffranzosi> xerox: Hi, Do you remember me? I subscribed myself for a project about a different aproach to parallel programming in haskell. Lately, my mentor followed the links you gave me to subscribe himself as a mentor but he could not find out how to link himself with my project. /Do you have any idea of what should be done?
05:48:42 <xerox> ffranzosi: sure.
05:48:56 <xerox> ffranzosi: http://code.google.com/soc/mentor_home.html
05:49:00 <dozer_> jonkri: you may have to flip the opaque flag to convince it to paint the background at all - otherwise it may let the parent component show through
05:49:20 <xerox> ffranzosi: log in and rank project, he should be receiving the mentors' mailing list mails... ?
05:50:28 <ffranzosi> xerox: hum... ok, should he subscribe himself to hackage site also?
05:51:17 <xerox> ffranzosi: that's probably a good idea, I think we will use it to stay updated with students' projects.
05:52:41 <ffranzosi> xerox: ok. I'll talk to him... Thanks again...
05:53:33 <xerox> ffranzosi: you're welcome.  Point him to the administrators for detailed informations. (They are listed on the People page as well as on the Google mentors page.)
05:54:12 <ffranzosi> ok
06:06:45 <jip> is there like a catEithers :: [Either a b] -> ([a], [b]) ?
06:14:40 <davidhouse> @hoogle isLeft
06:14:41 <lambdabot> No matches found
06:14:46 <davidhouse> @hoogle Either a b -> Bool
06:14:46 <lambdabot> No matches, try a more general search
06:15:01 <xerox> @type either
06:15:02 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
06:15:35 <davidhouse> > let isLeft = either (const true) (const false) in partition isLeft [Left 5, Right "hello", Right "world", Left 10]
06:15:36 <lambdabot>  Not in scope: `false'
06:15:44 <davidhouse> oops
06:15:50 <davidhouse> > let isLeft = either (const True) (const False) in partition isLeft [Left 5, Right "hello", Right "world", Left 10]
06:15:51 <lambdabot> ([Left 5,Left 10],[Right "hello",Right "world"])
06:15:57 <davidhouse> jip, ^^
06:16:07 <xerox> :)
06:16:15 <audreyt> anyone using ghc/x86macosx?
06:16:40 <audreyt> I'm getting a black macbook the first thing tomorrow, so I thought it's a good idea to check the current ghc support status  :)
06:16:43 <xerox> I don't have it here now
06:16:51 <shapr> cool
06:17:06 <xerox> There is that one wolfgang provided, I could search for it?
06:17:37 <xerox> hehe, getting one? pfeeet!
06:17:48 <jip> davidhouse: cool :D
06:18:10 <davidhouse> jip, actually, that's not quite what you want
06:18:29 <jip> :t partition
06:18:34 <jip> @type partition
06:18:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:19:15 <jip> davidhouse: nope, gotta map those critters out of the Either container
06:19:43 <xerox> Yeah.
06:19:51 <davidhouse> > let isLeft = either (const True) (const False); unLeft (Left a) = a; unRight (Right a) = a; splitEithers = (map unLeft *** map unRight) . partition isLeft in splitEithers [Left 5, Right "hello", Right "world", Left 10]
06:19:52 <lambdabot> ([5,10],["hello","world"])
06:20:29 <davidhouse> god bless arrowic combinators.
06:20:39 <xerox> audreyt: +200$ for +-RW drive, +200$ for 20Gb and black painting, that's mad.
06:23:09 <jip> that's some scary code
06:23:49 <jip> from the looks of it, it should work with an infinite list, right?
06:23:54 <davidhouse> what's scary about it?
06:23:55 <kowey> interestingly, the 20Gb costs +50$ as an add-on, so i guess the estimated value of black paint is 150$
06:24:10 <xerox> hehehe.
06:24:33 <xerox> (kowey: they take two days more to paint it too.)
06:24:49 <davidhouse> > (take 10 *** id) . partition (>20) [1..] -- let's see if it works with infinite lists
06:24:49 <lambdabot> Couldn't match `([a], [a])' against `t -> t1'
06:24:54 <kowey> :-)
06:24:56 <davidhouse> > (take 10 *** id) $ partition (>20) [1..] -- let's see if it works with infinite lists
06:25:00 <lambdabot> Terminated
06:25:09 <davidhouse> i think partition is strict.
06:25:25 <davidhouse> @docs Data.List
06:25:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:25:33 <int-e> > foldr (either (\x -> (x:) *** id) (\x -> id *** (x:))) ([], []) [Left 5, Right "hello", Right "world", Left 10]
06:25:34 <lambdabot> ([5,10],["hello","world"])
06:26:30 <davidhouse> @pl \x -> (x:) *** id
06:26:30 <lambdabot> (*** id) . (:)
06:26:31 <xerox> \x -> (x:) *** id  =  (*** id) . (:)
06:26:37 <xerox> Cheater :P
06:26:39 <davidhouse> ;)
06:26:48 <int-e> > foldr (either ((*** id) . (:)) ((id ***) . (:))) ([], []) [Left 5, Right "hello", Right "world", Left 10]
06:26:49 <lambdabot> ([5,10],["hello","world"])
06:27:14 <int-e> pretty :)
06:27:22 <davidhouse> err... ;)
06:27:28 <xerox> @pl \f g h -> (f g) . h
06:27:28 <lambdabot> ((.) .)
06:27:37 <xerox> @pl \f g h -> (g f) . h
06:27:37 <lambdabot> ((.) .) . flip id
06:27:47 <xerox> Okay that's too much.
06:27:52 <davidhouse> flip id?
06:27:54 <davidhouse> @type flip ip
06:27:55 <lambdabot> Not in scope: `ip'
06:27:57 <davidhouse> @type flip id
06:27:58 <lambdabot> forall b c. b -> (b -> c) -> c
06:27:58 <xerox> Let's try nevertheless :)
06:28:02 <int-e> flip id = flip ($)
06:28:07 <xerox> @pl foldr (either ((*** id) . (:)) ((id ***) . (:)))
06:28:08 <lambdabot> foldr (either ((*** id) . (:)) ((id ***) . (:)))
06:28:27 <davidhouse> @pl \foldr either id (:) -> foldr (either ((*** id) . (:)) ((id ***) . (:)))
06:28:27 <lambdabot> (line 1, column 19):
06:28:27 <lambdabot> unexpected ":"
06:28:27 <lambdabot> expecting pattern
06:28:31 <davidhouse> ah well.
06:28:36 <davidhouse> @pl \foldr either id -> foldr (either ((*** id) . (:)) ((id ***) . (:)))
06:28:37 <lambdabot> (. flip (ap . (. ((. (:)) . flip (***)))) ((. (:)) . (***))) . (.)
06:28:44 <xerox> We all want to generalize (id ***) and (*** id) right?
06:28:48 <xerox> hehe.
06:29:01 <davidhouse> actually, (id ***) == first, and (*** id) == second
06:29:09 <xerox> dang!!!
06:29:10 <int-e> argh. of course.
06:29:15 * xerox beats himself
06:29:24 <xerox> That's cute.
06:29:34 <davidhouse> > foldr (either (first (:)) (second (:))) ([], []) [Left 5, Right "hello", Right "world", Left 10]
06:29:34 <lambdabot> Couldn't match `b -> b' against `(c, d)'
06:29:45 <davidhouse> > foldr (either (first . (:)) (second . (:))) ([], []) [Left 5, Right "hello", Right "world", Left 10]
06:29:46 <lambdabot> ([5,10],["hello","world"])
06:29:58 <xerox> Oooh :)
06:31:54 <int-e> now let's go out with that and scare haskell-newbies :)
06:32:15 <xerox> Yee :)
06:32:39 <azuroth> I'm going through test code that's touching the database and making it ... better
06:33:15 <jip> Non-type variables, or repeated type variables, in the constraint: MonadState Chopper m (Use -fglasgow-exts to permit this)
06:33:29 <jip> with -fglasgow-exts everything works great, but what extension exactly is this and what the heck is going on?
06:33:58 <davidhouse> let accum (Left a) = modify (first (a:)); accum (Right a) = modify (second (a:)); splitEithers xs = execState (mapM accum xs) ([], []) in splitEithers [Left 5, Right "hello", Right "world", Left 10] -- just for kicks :)
06:34:02 <azuroth> the person who wrote it just said "yeah, you have to manually delete stuff before testing. then test in this specific order". :'(
06:34:05 <davidhouse> > let accum (Left a) = modify (first (a:)); accum (Right a) = modify (second (a:)); splitEithers xs = execState (mapM accum xs) ([], []) in splitEithers [Left 5, Right "hello", Right "world", Left 10] -- just for kicks :)
06:34:06 <lambdabot> ([10,5],["world","hello"])
06:34:18 <xerox> haha
06:34:21 <davidhouse> it also reverses the order, but never mind.
06:34:24 <dons> Lokadin: yeah, got the patches. thanks!
06:34:49 <dons> dcoutts_: found some bugs in drop, splitAt. not checking for lengths < 0. thanks to the new QC framework :)
06:34:55 <dons> ?karma+ QuickCheck
06:34:55 <lambdabot> QuickCheck's karma raised to 7.
06:35:10 <davidhouse> lengths LESS than 0?
06:35:13 * xerox still has more Karma that QuickCheck, but it's raising rapidly....
06:35:19 <davidhouse> that would seem to be an unlikely scenario.
06:35:25 <dons> dcoutts_: also an invariant failure in something.
06:35:32 <dons> davidhouse: drop (-2) ps
06:35:36 <azuroth> (a : ) ?
06:35:40 <dons> > drop (-2) "haskell"
06:35:41 <lambdabot> "haskell"
06:35:57 <davidhouse> oh, i thought you meant passing in a string with a negative legth.
06:36:01 <davidhouse> *length
06:36:03 <azuroth> ? (1 : )
06:36:05 <dons> yeah, i know :)
06:36:11 <azuroth> > (1 : )
06:36:11 <lambdabot> Add a type signature
06:36:30 <dons> ?type (1:)
06:36:31 <lambdabot> forall a. (Num a) => [a] -> [a]
06:36:31 <xerox> (1:) :: (Num a) => [a] -> [a]
06:36:39 <dons> thanks xerox-bot
06:36:44 <davidhouse> azuroth: (1:) is a section of the function (:). (1:) will append a 1 to the front of a list.
06:36:49 <davidhouse> > (1:) [1..5]
06:36:50 <lambdabot> [1,1,2,3,4,5]
06:36:53 <xerox> TONY RANDALL!  Is YOUR life a PATIO of FUN??
06:36:53 <azuroth> ohh, right
06:37:03 <dons> now xerox is scaring me.
06:37:15 <dons> xerox, what do you think of functional programmers?
06:37:20 <int-e> @xerox
06:37:20 <xerox> Yo ho ho, and a bottle of rum!
06:37:21 <lambdabot> Unknown command, try @list
06:37:22 <davidhouse> similarly, (:a) will take an item and it stick it on the front of the list a.
06:37:34 <dons> xerox, > map (+1) [1..10]
06:37:55 <xerox> [2,3,4,5,6,7,8,9,10,11]
06:37:58 <dons> xerox, > let f () = f () in f ()
06:38:05 <xerox> <<Loop>>
06:38:10 <dons> haha
06:38:27 * xerox sweats
06:38:28 <davidhouse> xerox, > product . map fac [100..200] where fac = product . enumFromTo 1
06:38:29 <dons> better black hole detection than ghc
06:38:39 <dons> > let f () = f () in f () :: ()
06:38:41 <davidhouse> err
06:38:42 <xerox> davidhouse: Couldn't match `[b]' against `t -> t1'
06:38:43 <lambdabot> Terminated
06:38:49 <davidhouse> > product . map fac $ [100..200] where fac = product . enumFromTo 1
06:38:51 <lambdabot> 56867851038678221096512715458184644379525647618487438669437028603507088669371031032634424278906020512049504164144367054709839838625819019839365032511209670719161515182371037918092229460326603840694212
06:38:51 <xerox> dons: of course.
06:38:51 <lambdabot> 50959421163916139010921681522120707965227774215916553253431631188093300673246254917036786977858406173463578385923655443824776719845791735882388127893644915675677252341767808672975516987957839173435910
06:38:51 <lambdabot> 94877630082280314832708897008980442168668043758299761365151031517518860094113512836660566661164497216305402707681531781146948870263259311054075139940938447570303671487492978751740125948537780122965563
06:38:51 <lambdabot> 46768913588141759166204996252779212914766801456772537169697440579486933713971037326046674127907098105298541585965102803879361033320862213114851696240711291519977623369600005549359168498519694329906820
06:38:53 <lambdabot> 56332564398015985289971291887497639623363724185998840501334041461589030387813622405987273015169099679442576840755270856416519699229556017972090109087825336655320043149539324441310551025917178041102317
06:38:56 <lambdabot> [6 @more lines]
06:38:58 <azuroth> I somehow totally forgot about operator sections
06:39:01 <davidhouse> sorry, that was meant to be "xerox, "...
06:39:06 <davidhouse> haha, oops.
06:39:17 <xerox> [n @more lines]
06:39:25 <dons> haha!
06:39:42 <dons> xeroxbot is great!
06:39:45 <dons> i want one!
06:39:53 <xerox> I'd like to drop me anchor in her lagoon!!
06:39:55 <dons> xerox, ?version 
06:39:56 <davidhouse> @where xeroxbog
06:39:56 <lambdabot> I know nothing about xeroxbog.
06:40:20 <xerox> xerox 3.1415926535, GHC 6.4.1 (Linux i686 3.20GHz)
06:40:26 <int-e> > length $ show (let fac = product . enumFromTo 1 in product . map fac $ [100..200])
06:40:28 <lambdabot> 26664
06:40:31 <xerox> darcs get http://127.0.0.1/xerox
06:40:32 <dons> hehe
06:40:55 <ADEpt> Lemmih: ping
06:40:55 <davidhouse> woah, you can abuse let bindings like that?
06:41:01 <int-e> abuse?
06:41:10 <int-e> it's an expression.
06:41:18 <xerox> Puff, pant.
06:41:19 <dons> its jsut an expression
06:41:25 <dons> > let in () -- is  abuse
06:41:26 <lambdabot> ()
06:41:31 <xerox> lambdabot does some hard work, dudes.
06:41:44 * davidhouse suddenly realised he used his pet hate: too many .s and $s. it should have been product $ map fac [1..200]
06:41:46 <dons> hehe. true .
06:41:51 <davidhouse> dons, odd.
06:41:52 <int-e> using where in non-top-level stuff is abuse though
06:42:01 <davidhouse> is "" a valid identifier then? :)
06:42:16 <Lemmih> ADEpt: Hiya.
06:42:17 <sieni> or
06:42:18 <dons> davidhouse: no. its the empty decl list. we all know "" is the application operator ;)
06:42:21 <int-e> > (let x = y where y = 42 in x)
06:42:23 <lambdabot> 42
06:42:29 <sieni> > let 2 + 2 = 5 in 2 + 2
06:42:30 <lambdabot> 5
06:42:39 <dons> that's abuse too.
06:42:43 <dons> pattern abuse
06:42:57 <Lemmih> ADEpt: We're talking conjure in #haskell-overflow
06:43:05 <int-e> > (let y=y where y = 42 in y)
06:43:06 <lambdabot> 42
06:43:10 * xerox thinks again about Haskell poetry
06:43:24 <int-e> how's that?
06:43:30 <dons> ah, good one , int-e. very subtle
06:43:52 <azuroth> ... sieni: whoa
06:43:57 <davidhouse> > let y = x; x = y where x = 42 in y
06:43:58 <lambdabot> Add a type signature
06:44:01 <davidhouse> aww.
06:44:10 <davidhouse> don't wheres shadow lets?
06:44:17 <int-e> only locally
06:44:44 <int-e> > let y = x where x = 42; x = y in y -- this is different
06:44:45 <lambdabot>   Conflicting definitions for `x'
06:44:45 <lambdabot>   In the binding group for: x, x
06:45:14 <int-e> > let y = x where { x = 42 }; x = y in y -- this is different again
06:45:15 <lambdabot> 42
06:45:38 <davidhouse> aha
06:47:10 <xerox> @compose eval babel it en let live = life; life = your life; in (life :: Int)
06:47:11 <lambdabot>  Not in scope: `your'
06:47:17 <xerox> Ops.
06:47:26 <xerox> @compose eval babel it en let vivi = vita; vita = tu vita; in (vita :: Int)
06:47:28 <lambdabot> Terminated
06:47:29 * xerox ruined it.
06:47:46 <dons> ?babel it en let vivi = vita; vita = tu vita; in (vita :: Int)
06:47:47 <lambdabot>  let you live = life; life = you life; in (life:: Int)
06:47:57 <dons> ?eval let you live = life; life = you life; in (life:: Int)
06:47:58 <lambdabot> Terminated
06:47:59 <xerox> hehe
06:48:03 <dons> very good.
06:48:16 <xerox> It is from 19/12/05
06:48:26 <dons> i like that one. very nice.
06:48:37 * xerox bows
06:49:49 <hyrax42_> haha
06:52:19 * dons wonders what we did for fun in #haskell before lambdabot had eval. or before lambdabot.
06:52:57 <xerox> hs-plugins? (:
06:53:31 <davidhouse> where's that wiki page with all the extra functions that aren't in the standard libs but are nonetheless useful?
06:53:40 <azuroth> you let people do their work instead of being distracted? ;-p
06:53:43 <dons> ?where MissingH
06:53:43 <lambdabot> http://quux.org/devel/missingh
06:53:46 <dons> perhaps?
06:53:50 <dons> azuroth: hehe
06:53:54 <davidhouse> nah, it was a wiki page.
06:54:02 <dons> davidhouse: hmm, check the wiki then :)
06:54:08 <davidhouse> ;)
06:54:11 <dons> it has a search feature
06:54:19 <dons> i think i know the page you mean.
06:54:42 <sjanssen_> hey dons, how did vincenz's word at a time idea work out?
06:55:18 <dons> not so great. try as I could, I couldn't get it to run faster. at best it was about 10% slower. (for map) even when I unboxed all the peekign and poking and shifting
06:55:39 <dons> I think ghc and gcc are just diong a good job spotting the reads, or else prefetching is taking care of the issue for us
06:55:55 <vincenz> erm
06:55:58 <xerox> Ah
06:56:03 * vincenz ponders
06:56:04 <xerox> @oldwiki LicensedPreludeExts
06:56:05 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
06:56:05 <dons> ghc generates a loop of readWord8s, which gcc is doign something magic to
06:56:06 <vincenz> dons: can I look?
06:56:10 <xerox> Or something like that, davidhouse.
06:56:21 <davidhouse> xerox, that's the one. thanks
06:56:28 <vincenz> dons: wh readWord8
06:56:31 <vincenz> and not readWord32!
06:56:34 <dons> vincenz: just grab fps and hack on Data.ByteString.map' if you'd like.
06:56:34 <sjanssen_> dons: I suppose that's good.  Changing everything to words would probably introduce all kinds of nasty bugs
06:56:35 <vincenz> s/wh/why
06:56:39 <vincenz> dons: o
06:56:39 <vincenz> k
06:56:41 <vincenz> grr
06:57:06 <dons> vincenz: I'm sayign that in the normal case our Word8 reads seem to be ok. the Word32 read + shifts didn't seem to be any faster, in fact slightly slower.
06:57:15 <vincenz> hmm
06:57:19 <vincenz> which is unreasonable
06:57:26 <dons> i guess gcc has spent a lot of  time optimisign Word8 manipulation perhaps?
06:57:34 <vincenz> unless readWord32 is doing something bad
06:57:34 <dons> since they're strings are full of these ops
06:57:40 <vincenz> dons: gcc doesn't do that kind of optimizations
06:57:59 <vincenz> more likely, ghc is generation Word8 ops for Word32 ops
06:58:15 <vincenz> which would defeat the purpose
06:58:19 <dons> no, it isn't
06:58:29 <vincenz> how do I benchmark
06:58:33 <dons> i coded in raw primops to check, and inspected the cmm output
06:58:51 <dons> there's a Bench.hs file in tests/
06:59:07 <dons> comment out any tests you don't want to run , and jsut run a test for map'
06:59:12 <vincenz> hm
06:59:14 <vincenz> and how do I compile?
06:59:20 <dons> 'make bench'
06:59:23 <vincenz> ah thanks
06:59:23 <azuroth> couldn't you ask them?
06:59:30 <vincenz> nope... it doesn't find Data.ByteSTring
06:59:55 <dons> you need to build and isntall fps first.
07:00:00 <vincenz> erm
07:00:04 <vincenz> each time I make a change???
07:00:14 <dons> yup. if you want to see the effect.
07:00:18 <vincenz> wouldn't it be easier to locally link to the stuff in the darcs repo???
07:00:40 <dons> not big advantage.
07:00:41 * vincenz doesn't want to install experimental stuff
07:00:48 <vincenz> yes there is, I don't muck up my main fps
07:01:06 * vincenz scratches his head
07:01:12 <sjanssen_> vincenz: try installing to your home directory?
07:01:13 <dons> ok. please no more complaints :P either hack on it and experiment, or dont :)
07:01:22 <vincenz> oki oki
07:01:35 <dons> i'm still interested if you can get it to run faster.
07:02:09 <kzm> dons, about sorting BSs.
07:02:29 <kzm> You allocate an FFI array - is it much faster than using UArray?
07:02:50 <dons> sjanssen_: re. bugs. I agree. the code was fairly scary looking. hard to reason about all those end conditions.
07:03:00 <sjanssen_> kzm: you're talking about Data.ByteString.sort
07:03:10 <kzm> I'm contemplating a fast UTF8 sort, and more comfortable using UArrays
07:03:14 <kzm> sjanssen_, yes
07:03:32 <kzm> I adapted it for the 8-bit encodings.
07:03:35 <dons> this guy, allocaArray 256 ?
07:03:36 <sjanssen_> kzm: I wrote it, and I haven't tested either way
07:03:54 <kzm> All QC tests pass, it is equally fast as raw BS/Char8.
07:03:54 <dons> kzm, probably being able to memset it is helpful.
07:04:02 * kzm scratches his head.
07:04:14 <kzm> I guess I tested it on ASCII input only :-)
07:04:17 <dons> ah, you have a patch already? that's the spirit!
07:04:21 <kzm> Still, shouldn't matter.
07:04:52 <sjanssen_> kzm: I don't think counting sort will work on UTF-8
07:05:19 <sjanssen_> there's 2^20ish possible characters, right?
07:05:20 <kzm> I was thinking that you could count ASCII chars, and use something else for non-ASCII.
07:05:33 <kzm> 2^21, I think.
07:05:43 <kzm> So you need a fallback strategy.
07:06:00 <kzm> But you could make a separate array of two-byte chars, and sort it as Word16s.
07:06:20 <kzm> (separate region of the target BS, more likely)
07:06:28 <kzm> And so on, up to 4-byte chars.
07:06:33 <sjanssen_> I've been pondering writing a comparison sort for ByteString, just to see how it compares to smallish strings
07:06:51 <vincenz> dons: what do I compare map' with?
07:06:52 <vincenz> map?
07:07:11 <dons> vincenz: well, no. you'd compare it against the old map'.
07:07:15 <kzm> I guess you need two passes.  Should still be a hell of a lot faster than the current UTF8 code.
07:07:24 <dons> so you're version would be map'' :)
07:07:35 <vincenz> okies
07:07:41 <dons> to get you started:
07:07:43 <dons>             w <- peekElemOff (castPtr p1) n :: IO Word32
07:07:43 <dons>             let w1 = f $ fromIntegral (w `shiftR` 24)
07:07:44 <dons>                 w2 = f $ fromIntegral ((w `shiftR` 16) .&. 0xff)
07:07:44 <dons>                 w3 = f $ fromIntegral ((w `shiftR` 8)  .&. 0xff)
07:07:46 <dons>                 w4 = f $ fromIntegral (w .&. 0xff)
07:07:48 <dons>             pokeByteOff (castPtr p2) n $!  (
07:07:51 <dons>                                 ((fromIntegral w1 `shiftL` 24) .|. 
07:07:54 <dons>                                  (fromIntegral w2 `shiftL` 16) .|. 
07:07:56 <dons>                                  (fromIntegral w3 `shiftL`  8) .|. 
07:07:58 <dons>                                  (fromIntegral w4)) :: Word32)
07:08:01 <dons>             map_ (n+4) p1 p2
07:08:03 <dons> and then work from there perhaps.
07:08:05 <SamB_XP> hey hey hey!
07:08:10 <kzm> sjanssen_, but if you're working on it, I'll just wait and see :-) 
07:08:10 <azuroth> hoi hoi
07:08:10 <dcoutts_> dons, right, ok, good.
07:08:13 <sjanssen_> kzm: maybe you could try inserting everything into an IntMap?
07:08:14 <SamB_XP> you aren't supposed to paste so much, dons
07:08:26 <dons> sorry. i'm tired and i want to go to bed.
07:08:31 <SamB_XP> hehe
07:08:43 <kzm> sjanssen, it'll be big.  Maps are expensive spacewise.  Will work for small strings.  
07:08:46 <dons> but when it's pure haskell gold, why not paste!? ;)
07:08:49 <kzm> But anything will work for small strings.
07:08:50 <SamB_XP> anyone seen http://groups.google.com/group/rec.arts.int-fiction/browse_frm/thread/e053b73ab0f61af9 ?
07:08:54 <vincenz>     , ("map", [F ({-# SCC "map" #-}B.map' (+1) fps)
07:08:55 <vincenz>               ,F ({-# SCC "map" #-}B.map'' (+1) fps)])
07:09:03 <dons> looks good vincenz 
07:09:07 <vincenz> thanks
07:09:27 * kzm must run.
07:09:32 <dons> oh. hmm. there's a pokeByteOff there.. that looks _wrong_
07:10:05 <dons> should be a pokeElemOff.. now, was that always there? did I run all those tests with that bogus code.. hmm
07:10:08 <vincenz> yep
07:10:26 <lome> could anybody help me? how I can define a type context of method in instance declaration?
07:10:38 <lome> oops... just a moment
07:10:42 <vincenz> pokeByteOff
07:10:56 <SamB_XP> lome: type is already declared in class declaration anyway
07:10:58 <vincenz> but no worries
07:11:01 <vincenz> I'll look into it
07:11:22 <dcoutts_> dons, vincenz: yes actually I wouldn't expect reading word32 + shifting to be any faster than reading Word8
07:11:38 <dcoutts_> afterall all Word8 reads are going to be aligned
07:11:40 <sjanssen_> dons: I think pokeByteOff is okay there, you increment your n counter by four each loop
07:11:52 <sjanssen_> @hoogle pokeByteOff
07:11:52 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
07:12:07 <dons> ah, yes. byte offset
07:12:10 <dons> not poke a byte.
07:12:21 <dons> all is well.
07:12:26 <dcoutts_> since what the cpu does when you do a Word8 read is read 32 and shift. So it can always do a single aligned 32bit word read.
07:12:28 <vincenz> dcoutts_: 32-bit aligned
07:12:39 * vincenz ponders
07:12:40 <dcoutts_> right
07:13:10 <vincenz> except
07:13:10 <dons> dcoutts_: right, so when I ask for 4 peeks in a row, what's going to happen? 3 are either in the cache, or in registers?
07:13:14 <vincenz> dcoutts_: not so!
07:13:19 <vincenz> dcoutts_: cause with readwor8
07:13:22 <vincenz> you're doing 4 reads
07:13:24 <vincenz> instead of 1
07:13:25 <SamB_XP> so should be peekByteOff then?
07:13:30 <dcoutts_> and if you're doing 4 word8 reads rather than one word32 read, then it doesn't save much since it's going to be one or two cycle delay in reading from the cache
07:13:30 <lome> SamB_XP: e.g. i have a class: class Collection s where { get :: s a b -> a -> Maybe b } and type: data Set a b = Set [(a,b)]. So I want to declare: instance Collection Set where { get (Set ds) key = lookup key ds }
07:13:32 <vincenz> each time retrieving 4 bytes nad shifting
07:13:55 <lome> But first argument in lookup must have type of class Eq
07:13:55 <dons> SamB_XP: ah ...
07:14:21 <lome> how I can declare it? I dont want to touch my class declaration
07:14:25 <vincenz> dcoutts_: 2 cycles only?
07:14:27 <vincenz> seems slim
07:14:30 <dcoutts_> dons, yes, the first word8 read beings it into the cache
07:14:37 <lome> am i clear?
07:14:47 <dcoutts_> vincenz, check your cpu timings I think it's about that quick
07:14:54 <SamB_XP> um. it doesn't already work?
07:14:57 <dcoutts_> it's very few cycles for L1 cache
07:15:14 <sjanssen_> lome: you have to change your class
07:15:21 <davidhouse> lome, best bet would be to change your class decl. why don't you want to touch it?
07:15:21 <vincenz> even then
07:15:25 <vincenz> I'm certain that one read is more efficient
07:15:33 <vincenz> and not just cause of that, but cause of pipelining issues
07:15:37 <dons> vincenz: the only way to argue this one out is to write the faster code.
07:15:40 <vincenz> yep
07:15:55 <dons> we can see why it would be superficially faster, and then there's complications that make it less obvious.
07:15:57 <SamB_XP> @type lookup
07:15:58 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
07:16:00 <dons> but who knows till the code is written
07:16:07 <sjanssen_> lome: class Collection s a where get :: S a b -> a -> Maybe b
07:16:15 <dcoutts_> now when it is an advantage is if you can use a word32 as a 4 byte array
07:16:30 <davidhouse> sjanssen_, huh? what's an S?
07:16:35 <dcoutts_> but if you need to operate on each byte individually then there's little payoff
07:16:47 <sjanssen_> lome: then instance (Eq a) => Collection Set a where ...
07:16:56 <sjanssen_> davidhouse: sorry, I mean slower case 's'
07:16:59 <davidhouse> ah.
07:17:03 <vincenz> dons: what you mentioned is known as "profile first, bullshit after"
07:17:04 <lome> davidhouse: 'cause i dont know - may be other instances dont have Eq a
07:17:06 <SamB_XP> or, you could say
07:17:08 <dcoutts_> dons, so eg copying it pays off, but you're already using memcpy for that
07:17:23 <dons> right, which should already to all the magic
07:17:28 <dcoutts_> indeed
07:17:32 <vincenz> ayup
07:17:37 <davidhouse> i'd prefer to say get :: (Eq a) => s a b -> a > Maybe a
07:17:42 <SamB_XP> class Collection s where get :: (Ord a) => S a b -> a -> Maybe b
07:17:49 <dcoutts_> dons, are there any others that are basically oblivious? where we could do it vector style?
07:17:55 <davidhouse> again, lower case s and you mean Eq, not Ord ;)
07:18:06 <vincenz> dcoutts_: theoretically... for map... one could construct a function out of 4 functions thaht applies in one shot to 4 bytes..
07:18:10 <davidhouse> but mine should have ended in Maybe b.
07:18:11 <xerox> Data.Traversable?
07:18:18 <davidhouse> xerox, i think so.
07:18:19 <dcoutts_> vincenz, possibly, try it.
07:18:31 <vincenz> basically shifting inside the function being applied
07:18:35 <vincenz> instead of apriori and then 4 calls
07:18:37 <dcoutts_> yes
07:18:49 <lome> sjanssen_: ok thanx!!!
07:18:50 <vincenz> not certain how much it would matter tho
07:18:59 <dcoutts_> however the time is porbably going to be dominated by the calls
07:20:08 <vincenz> 32bitwordfunc = jit(combine(4*originalfunc))
07:20:12 <jip> how's the performance of concat?
07:20:14 <vincenz> :D
07:20:20 <dons> so that code above, I get 0.148s, versus 0.102 without the Word32 reads.
07:20:28 <dons> which is roughly what I found earlier today.
07:20:29 <lome> sjanssen_: is there only way (to use multi-param type classes)?
07:20:35 <dcoutts_> what's more important is getting good L1 cache behviour, eg by doing memory read/write loops sequentially, but that happens already.
07:20:36 <vincenz> hmm
07:20:41 <vincenz> dons: is shifting inlined?
07:20:56 <dons> vincenz: yeah.
07:21:03 <SamB_XP> are we talking lazy bytestrings or strict ones?
07:21:09 <dons> strict ones here.
07:21:10 <vincenz> SamB_XP: strict
07:21:12 <sjanssen_> lome: otherwise you can follow SamB_XP's suggestion, add an Ord or Eq constraint to get in the original class decl.
07:21:29 <vincenz> @fptools Data.Word
07:21:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Word.hs
07:21:49 <dcoutts_> dons, so what were the QC failures? I didn't get any. Or are they new tests?
07:22:00 <SamB_XP> I say Ord because you'd need that for anything more complicated than an alist
07:22:02 <lome> sjanssen_: ok. no - there is not the thing i want. thank you.
07:22:08 <vincenz> dons: one other possible hunch... pokeByteOff does not assume the offset is wordalignable
07:22:28 <dons> dcoutts_: they're in new tests.
07:22:31 <dons> and fixed.
07:22:38 <dcoutts_> dons, oh good
07:22:46 <SamB_XP> vincenz: you think it would work better with pokeElemOff and n not incremented by 4?
07:22:49 <dons> the most interesting was an invariant failure in replicate, that is also in Data.ByteString
07:22:57 <dons> again with negative lengths
07:23:02 <dcoutts_> dons, ah
07:23:14 <dons> but it hints that we need to finish all the QC tests in Lazy.hs
07:23:19 <vincenz> SamB_XP: possibly
07:23:23 <SamB_XP> what happens when you try to allocate a negative amount of memory?
07:23:26 <dcoutts_> dons, yes
07:23:26 <dons> its quite tricky getting this lazy chunk stuff + invariants just right.
07:23:27 <dcoutts_> dons, how're we doing with coverage in Lazy now?
07:23:27 <vincenz> SamB_XP: we rely on the idea that word aligneability is good
07:23:32 <vincenz> it's bad to then lose it due to some function being used
07:23:36 <dcoutts_> dons, mm, indeed
07:23:37 <vincenz> @fptools Foreign.Storable
07:23:37 <lambdabot> http://darcs.haskell.org/packages/base/Foreign/Storable.hs
07:23:41 <dons> getting there I think. probably 80%?
07:23:53 <dons> now, why didn't anyone do a QC coverage tool for SoC.
07:24:02 <dons> usign profiling information or haddocks or something.
07:24:18 * dons notes this down for next year
07:24:23 <SamB_XP> I don't think it would lose alignability... it might check alignment...
07:24:37 <SamB_XP> dons: how do you do coverage profiling?
07:24:52 <sjanssen_> are there theorem provers that can read Haskell code and help prove things about it?
07:25:03 <xerox> GHC? (:
07:25:05 <SamB_XP> I mean, does GHC support profiling with that precision?
07:25:10 <dons> I was thinking of using profiling data to work out what functions are exercised most often. and then use that to inform what needs to be tested most thoroughly.
07:25:14 <dons> sjanssen_: Agda, I think.
07:25:20 <dons> paper at last year's ICFP.
07:25:21 <jip> > otherwise
07:25:23 <lambdabot> True
07:25:39 <jip> wtf?
07:25:39 <SamB_XP> dons: it can?
07:25:48 <xerox> jip: yeah.
07:25:49 <dons> the profiling data counts all calls.
07:25:59 <jip> xerox: huh?
07:26:06 <davidhouse> jip, it's used in guards
07:26:18 <SamB_XP> jip: "| otherwise" reads better than "| true"
07:26:25 <dons> you could do all sorts of interesting analysis of hot paths in the code, and unexercised bits
07:26:31 <davidhouse> with guards, the compiler works down the list until it finds a guard which is true.
07:26:36 <SamB_XP> er, "| True"
07:26:49 <davidhouse> the conventional style is to place a | otherwise guard at the bottom which is your default case.
07:26:59 <jip> still kind of weird, otherwise should be a keyword
07:27:07 <davidhouse> why?
07:27:11 <Muad_Dib> why should it be one?
07:27:13 <SamB_XP> not when it can be a variable in the library!
07:27:23 <SamB_XP> it is soooo cuuuute!
07:27:25 <Muad_Dib> what would be the gain of having it a keyword?
07:27:30 <Muad_Dib> indeed SamB :)
07:27:33 <jip> Muad_Dib: better syntax highlighting :D
07:27:39 <vincenz> > not otherwise
07:27:40 <lambdabot> False
07:27:45 <SamB_XP> also, those compiler writers have better things to do
07:27:58 <Muad_Dib> jip: thats the biggest bullshit ever
07:27:59 <Muad_Dib> :)
07:28:11 <vincenz> hehe
07:28:14 <SamB_XP> jip: if you want it highlighted, that is okay
07:28:16 <Muad_Dib> jip: syntax highlighting writers can add otherwise
07:28:21 <vincenz> jip: just change the language-def of your favourite language
07:28:25 <Muad_Dib> no need to make it a keyword for that :)
07:28:27 <vincenz> that's hardly making it a keyword in the actual compiler!
07:28:42 <SamB_XP> python-mode has lots of things highlighted that aren't actually keywords
07:28:47 <vincenz> yep
07:28:48 <vincenz> like
07:28:51 <vincenz> "this is wrong"
07:29:02 <vincenz> or # XXX
07:29:10 <dons> dcoutts_: so you reckon that maybe L1 caching would explain the advantage over the explicit Word read + shifting. I think this makes sense. the hardware's already doing this for us, effectively. vincenz, yeah?
07:29:11 <Muad_Dib> hightlighting is a "stylesheet" over some string, who says that that stylesheet can only apply on offical keywords? :)
07:29:28 <vincenz> dons: indeed
07:30:11 <dons> which lets me breath a sigh of relief. i was dreading having to rewrite things to do combined reads.
07:30:38 <dcoutts_> dons, you only get really bad performance if you do unaligned word32 reads since then the cpu needs to do two word32 reads anc combine them
07:30:59 <vincenz> yup
07:32:07 <sjanssen_> will the word32 kung fu be useful for reverse?
07:32:23 <dcoutts_> sjanssen, possibly, yes
07:32:31 <vincenz> dons: however...for poking, it's best to poke 32byte
07:33:22 <dcoutts_> vincenz, dunno, the L1 cache may be able to do the read+combine+write without any latency penalty
07:33:35 * vincenz ponders
07:33:44 <dcoutts_> you'd have to profile it
07:33:49 <vincenz> I sincerely doubt that
07:33:52 <vincenz> but yeah
07:33:54 <dons> all those pokes are only going into l1 anyway, and let the hardware work out when to write everything else.
07:34:09 <vincenz> dons: the problem is that poking a byte implies reading the other 3 bytes to recombine I would think
07:34:15 <dons> there's a reason you don't see this kind of code in C either.
07:34:18 <dons> i think.
07:34:26 <dcoutts_> vincenz, yes, but it's only L1 cache
07:34:39 <vincenz> memory is memory
07:34:59 <vincenz> costly, slow and energy-sucking
07:35:06 <dcoutts_> vincenz, so either the CPU has to do that itself, or there might be special hardware to do the read+combine+write a bit closer to the L1 cache
07:35:46 <dcoutts_> vincenz, my point is that its conceivable that the cpu doesn't have to pull the word32 all the way to the core to combine it with the word8 and write back
07:36:08 <dcoutts_> it could send the word8 to the cache and have the read+combine+write be done there
07:36:16 <dcoutts_> with less latency
07:36:52 <dcoutts_> profiling is the only way to know
07:37:04 <dcoutts_> that or a good intel/amd cpu programming guide
07:37:42 <dcoutts_> but I think we should be concentrating on slightly higher level optimisations like cache behaviour
07:38:13 <dcoutts_> comparing to hand written C versions might be interesting too
07:38:16 <dons> yeah, tuning chunks to the cache size was a 4x win on large data sets. with little effort on our part.
07:38:24 <shapr> I want to know how to push all these optimizations into GHC directly.
07:38:33 <dons> that's another thing. we need some library to compare against C.
07:38:55 <dons> a library of test programs
07:39:21 <vincenz> sorry
07:39:24 <vincenz> connection crapped out
07:39:37 <dons> dcoutts_: any idea why find/findIndex is 10x slower in the .Lazy version?
07:39:43 <basvandijk> Hi guys, I'm playing with Language.Haskell.Syntax and I'm wondering why (HsInfixApp HsExp HsQOp HsExp) is defined like that and not like: (HsInfixApp HsExp HsExp HsExp). The latter one seems more logical to mee because the expression: x op y == (op x) y. Can anybody explain why an infix application is defined like that?
07:40:03 <dons> basvandijk: it comes from the grammar definition, I think.
07:40:20 <dons> check the haskell 98 grammar, which defines these op thingies in the middle of infix expressions.
07:40:37 <dons> which makes parsing easier.
07:40:38 <basvandijk> OK, so Language.Haskell.Syntax follows the grammer in haskell.org/onlinereport
07:40:46 <dons> yeah, roughly, I think.
07:40:47 <dcoutts_> dons, I've not looked at find/findIndex really yet
07:41:06 <dons> ok, something to keep in mind
07:41:10 <dons> 10 0.055        0.508           # "findIndex"     
07:41:10 <dons> 11 0.055        0.406           # "find"
07:41:17 <dons> nice mountains on the 'make plot' output
07:41:31 <dcoutts_> dons, right
07:42:16 <davidhouse> what can cause a segfault?
07:42:27 <davidhouse> other than hackery like unsafePerformIO
07:42:39 <dons> hackery of the FFI variety
07:42:39 <Lemmih> The FFI.
07:42:52 <dons> or a bug in the rts
07:43:11 <dons> usually its not unsafePerformIO  though. more like unsafeCoerce#
07:44:00 <davidhouse> other than the FFI as well.
07:44:15 <dons> hmm. using a library that has a bug and uses the FFI?
07:44:20 <davidhouse> the only thing slightly dangerous i'm doing is using the HTTP package
07:44:42 <dons> or, compilign with gcc -O3 -OKillMeNow
07:44:57 <dons> ghc tends to produce C that provokes gcc to cry
07:45:03 * vincenz sighs
07:45:14 <davidhouse> hmm.
07:45:35 <dons> i've not seen it with <= -O2 though.
07:45:39 <davidhouse> i may be trying to send an HTTP request to a URI of "*** Exception: "Not a valid URI: /ticket/2678"
07:45:44 <davidhouse> that might be causing it.
07:45:48 <dons> oh, interesting.
07:45:58 <dons> but not segfault worthy.. you might be on to something.
07:46:00 * davidhouse fixes his code.
07:46:05 <vincenz> Anyways.. what does this mean "/var/run/utmp is too hard to dig in: No such process" when I reattach screen
07:46:14 <vincenz> my cnnection craps out every 2 minutes :(
07:46:16 <vincenz> can barely type
07:46:26 <vincenz> dcoutts_: I agree fully you have to profile
07:47:24 <davidhouse> @docs Network.URI
07:47:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
07:48:00 <dcoutts_> dons, what I find more usual is that ghc provokes gcc to make code that makes the mangler cry.
07:48:14 <dons> ah, on amd64..
07:48:16 <dcoutts_> dons, we can't compile ghc with -optc-O2
07:48:19 <dons> with its new mangler.
07:48:55 <dcoutts_> -optc-O2 works for most modules in ghc but one or two...
07:49:10 <dons> with mangler breakages resulting?
07:49:34 <dcoutts_> yep, the mangler complains about prelude junk or whatever
07:49:35 <dcoutts_> and on other arches -O2 kills the mangler immdediately for everything
07:49:40 <dcoutts_> eg ia64
07:49:57 <dons> yeah, untested. lots of pattern matching missing. mangler is evil for a reason
07:50:06 <dcoutts_> aye
07:50:17 <dcoutts_> bring on C--
07:50:19 <pejo> dcoutts, you actually have ia64 machines?
07:50:24 <dons> bring it ON!!
07:50:36 <jip> dcoutts_: are you an expert with c--?
07:50:44 <dons> pejo: don't we all? we use them to heat our houses.
07:50:44 <dcoutts_> jip, sadly not
07:50:47 <pejo> (Personally, I'm very interested in C-- as well, but not enough interested to contribute to it).
07:50:56 <dcoutts_> pejo, I have access to one for testing haskell packages for gentoo
07:51:15 <pejo> dons, yeah, I heard Australia is really cold this time of year.
07:51:17 <dcoutts_> pejo, dual cpu ia64 900Mhz
07:51:18 <jip> c-- looks cool, but incomplete
07:51:51 <dons> i have access to one of similar specs to the above as well.
07:52:01 <dons> ?quote JaffaCake
07:52:02 <lambdabot>  I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
07:52:10 <Lemmih> jip: s/incomplete/accepting patches/ (:
07:52:10 <davidhouse> ia64?
07:52:15 <dcoutts_> pejo, also access to a 16 way mips thing, but sadly we can't make ghc work there yet despite dons keeping it working on mips-irix
07:52:38 <dons> oh, huh. what's the trouble again?
07:52:49 <dons> i should check out the head on the mips sometime.
07:52:54 <dcoutts_> davidhouse, intel's proprietary cpu
07:53:04 <davidhouse> as in, ix86?
07:53:08 <dcoutts_> dons, we have problems with linker stuff on mips linux
07:53:08 <davidhouse> oh, 64.
07:53:17 <dons> ah, yesh.
07:53:23 <dcoutts_> davidhouse, no, not x86 compatible at all
07:53:35 <davidhouse> ah
07:53:36 <dons> davidhouse: very different beast. check a compiler book. its the wave of the future, in 1999
07:53:40 <dcoutts_> dons, it's actually rater hard to pin down the problem
07:53:49 <kolmodin> how do I catch irrefusable pattern matches as IO exceptions?
07:53:53 <pejo> dcoutts, isn't there some hardware support on the old ones for ia32 compatibility?
07:54:13 <dons> dcoutts_: is it a gnu linker falibility?
07:54:20 <dons> wouldn't be unknown on the rare archs.
07:54:25 <pejo> davidhouse, VLIW architecture, put the intelligence in the compiler instead of on the die type of idea.
07:54:55 <dcoutts_> pejo, that's right, now it's just software emulation (since that turned out to be faster)
07:54:58 <dons> was a secret conspiracy to give compiler writers jobs for decades to come
07:55:10 <dcoutts_> dons, possibly, something to do with linker formats for having huge numbers of symbols
07:55:35 <dcoutts_> dons, GOT,XGOT,MultiGOT that kind of mumbo-jumbo
07:56:36 <dons> yeah . wacky stuff
07:56:43 <dcoutts_> dons, if the hardware had been fast it might have worked to, ia64 I mean
07:56:55 <dons> yep. pity
07:57:07 <dcoutts_> seemed a nice idea in theory
07:57:08 <dons> instead we get amd64-alikes
07:57:11 <pejo> dcoutts, it's quite competititve for number crunching though.
07:57:25 <dcoutts_> pejo, like a mini-vector machine
07:57:32 <dons> well, they've only sold , like, 30 of them though.. ;)
07:57:39 <dcoutts_> heh, aye
07:57:41 <dons> and all the ones i have were given away
07:57:45 * dcoutts_ too
07:58:10 <norpan> how come when i do darcs pull it takes forever?
07:58:49 <pejo> About that irix problem - can't you use the linker that comes with the OS?
07:58:52 <dons> its a mysterious question, norpan. could be the network, could be the repo is huge. lots of patches to transfer.
07:58:59 <dons> pejo, there's no irix problem
07:59:05 <dons> irix is fine. its linux/mips.
07:59:20 <dcoutts_> pejo, when I was at Cray, they were a little scornfull of ia64 since for vector stuff it wasn't nearly as good as a real vector processor and for scalar stuff it wasn't as good as comodity cpus
08:00:00 <norpan> ok, let me rephrase, how can i debug why darcs pull takes forever
08:00:10 <pejo> dcoutts, my impression is that SGI has been seeling "a lot" of Altix boxes though, with IA64.
08:00:21 <pejo> Well. And then they filed for Chapter 11. Shrug.
08:00:53 <pejo> dons, ouch. That sounds nasty. 
08:00:55 <dcoutts_> pejo, I worked on a cpu that had something like 64 integer regs, 64 floating point and then 32 64-element vector registers
08:01:12 <dcoutts_> that was good fur number crunching :-)
08:01:13 <dons> norpan: well, do a wget to check if its the network.
08:01:22 <dons> then darcs -v might help spot if its a specific patch.
08:01:29 <dons> then darcs optimise on the remote repo might help
08:01:37 <dons> and check if its just that you should be doing --partial
08:01:53 <pejo> dcoutts, heh, and I bet they sold half as many of those as Intel has done with IA64. ;)
08:01:56 <norpan> --partial was no option to pull
08:02:05 <dcoutts_> pejo, probably, but at 10x the price.
08:02:38 <dons> ?localtime dons
08:02:41 <lambdabot> Local time for dons is Wed May 17 00:57:40 2006
08:02:45 <dcoutts_> actually that ran irix too
08:02:50 <norpan> it's when i try to pull from http://www.cse.unsw.edu.au/~dons/code/fps
08:02:56 <davidhouse> dons, you realise you have a clock on your own screen, yes? :)
08:03:10 <dons> davidhouse: i use ion. i have no clock
08:03:18 <dons> ;)
08:03:23 <norpan> 45 patches
08:03:29 <ihope> @hoogle (a -> Bool) -> (a -> a) -> [a] -> [a]
08:03:30 <lambdabot> No matches, try a more general search
08:03:37 <dons> norpan: hmm. you should definitely be able to use --partial
08:03:47 <dons> i tag and optimise every release
08:03:53 <norpan> darcs pull --partial says --partial is not supported
08:04:00 <dons> hmm.
08:04:04 <dons> darcs get --partial
08:04:12 <norpan> get is another matter
08:04:15 <dons> and you're now updating a repo?
08:04:19 <norpan> yes, fps
08:04:31 <dons> hmm. then try get --partial as well, to see if its some pull thing
08:04:44 <norpan> it asks if it should pull the first patch, and then i say 'a'
08:04:46 <dons> i've recently switched to 1.0.7, so maybe that's something.
08:04:52 <norpan> and then it just sits there
08:05:02 <dons> well, use -v to check the patches are coming in over the wire.
08:05:40 <dons> and you can always just use wget to duplicate the repo.
08:05:49 <norpan> darcs pull -v gives no output whatsoever :)
08:05:56 <norpan> which is a strange definition of verbose :)
08:06:38 <dons> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps  1.52s user 0.28s system 2% cpu 1:05.70
08:07:01 <dons> its 4 hops away though. i guess its a few more to norpan-land
08:07:23 <davidhouse> ghci question. when i load module Fred normally, it says "Skipping Foo; Skipping Bar; Compiling Fred". however, if Fred.hs has an up-to-date .hi file (i assume this is how it's done), then GHCi doesn't bother compiling Fred. which is all lovely, apart from i don't get the *Fred thing and therefore have to :m all of Fred's dependancies manually.
08:07:30 <davidhouse> is there a better was of doing this?
08:07:35 <davidhouse> (was that long message truncated?)
08:07:38 <norpan> maybe i should upgrade darcs
08:07:41 <dons> touch Fred.hs
08:08:07 <dons> norpan: maybe. 1.0.7 seems rather zippy
08:08:12 <norpan> darcs --get --partial fetched 99 patches in a short time
08:08:19 <davidhouse> dons, i tried that, but it still doesn't seem to do it.
08:08:24 <norpan> so it's definitely something with pull
08:08:24 <eivuokko> --no-recomp ?
08:08:36 <davidhouse> hmm... i get a "Compiling Fred", but i still don't get the handy *Fred thing.
08:08:39 <norpan> i'll try to pull from my newly gotten repo
08:08:54 <dons> davidhouse: rm the .o files. you're trying to get it interpreted, no?
08:09:07 <dons> so just clear out the .o and .hi files, and let ghci at it.
08:09:10 <davidhouse> and :m *Fred tells me "module 'Fred' is not interpreted"
08:09:34 <davidhouse> they're not around.
08:09:40 <dons> norpan: so you were able to get ok?
08:09:47 <norpan> yes
08:09:48 <davidhouse> .o and .hi have already been rm'd.
08:09:55 <norpan> but with pull darcs just sits there eating cpu
08:10:18 <norpan> i'll try to pull the other way
08:10:32 <dons> kzm reported a similar thing. however i can't find anything on my end. the repo is consistent and i can pull without trouble
08:10:54 <norpan> i guess something is fscked up with my repo
08:11:04 <Igloo> Do you have any local changes or patches?
08:11:13 <norpan> yes
08:11:23 <dons> i think it was local changes to a specific file leading to kzm's delay
08:11:34 <norpan> i have let it sit for +20 hours
08:11:36 <dons> crunching the merge, yeah Igloo?
08:11:37 <Igloo> It's probably problems commuting the patches past them then
08:12:02 <norpan> if it doesn't finish within 20 hours then it takes forever
08:12:18 <dons> anythign norpan can do? optimise? reorder them somehow?
08:12:27 <dons> hang out in #darcs?
08:12:38 * Igloo has no experience with the problem
08:13:05 <dons> norpan: what files do you work on, BEnch.hs and */*/UTF8.hs?
08:13:17 <norpan> yes
08:13:25 <dons> maybe you could move your Bench.hs to another name, and avoid this problem 
08:13:40 <norpan> although i don't have any changes on that right now
08:13:41 <dons> then when I hack on Bench.hs it won't mess with your patches to the same
08:13:43 <norpan> just in UTF8.hs
08:14:23 <dons> would be fairly easy to get a repo, copy in your UTF8.hs and BenchUTF8.hs, add, record, and be happy?
08:14:40 <norpan> yeah
08:14:44 <norpan> i'll do that
08:14:44 <dons> unless a sense of history is important to you?
08:15:04 <norpan> history is just in your mind
08:15:20 <norpan> live in the present!
08:15:34 <dons> some say history goes in circles
08:15:49 <dons> but that will really mess up my repo 
08:16:13 <dons> ok, it was fun. night guys! happy hacking :)
08:16:17 <vincenz> dons: sleep well
08:49:33 <jip> @seen Igloo 
08:49:34 <lambdabot> Igloo is in #darcs, #haskell-overflow and #haskell. I last heard Igloo speak 7 minutes and 50 seconds ago.
08:50:03 * Igloo is here
08:50:19 <jip> Igloo!
08:50:24 <Igloo> jip!
08:50:47 <jip> you've done cool stuff with template haskell
08:51:34 <jip> right?
08:51:43 <Igloo> right
08:52:04 <jip> but i can't understand any of it :(
08:52:21 <basvandijk> Hi guys, I'm trying to write a function foo :: (Typeable b, Data a) => [b -> b] -> a -> a that applies a a bunch of functions to a value. foo = concatFuns . map (\x -> everywhere (mkT x)) works but: foo = concatFuns . map (everywhere . mkT) is rejected with the error: Inferred type is less polymorphic than expected. Can anybody explain why
08:52:35 <basvandijk> concatFuns = foldl1 (flip (.))
08:52:45 <Igloo> Anything in particular you don't understand?
08:53:35 <jip> Igloo: all of it. i am really interested in how you did those optimizations with that mandelbrot
08:55:14 <Igloo> I haven't got time to explain "all of it" right now. Mandelbrot is just using TH to do inlining isn't it? Just walk over the expression and copy the code where you see a function call
08:55:35 <Igloo> Plus simplification so you terminate
08:55:54 <jip> yeah i'll read over your stuff a few more dozen times
08:56:05 <jip> it looks really awesome though
08:56:19 <Igloo> If there are specific bits you don't get I can try to explain them
08:57:11 <Igloo> Incidentally, in some ways it would be nicer to just generate the nested code directly rather than fiddling about with the normal Haskell definition
08:57:14 <jip> cool thanks. i have a question: is it possible to use template haskell to automatically create getX, setX, modifyX functions for a record field data Foo = Foo { x :: Int } ?
08:57:33 <Igloo> Yes
08:57:47 <ndm> jip, drift does that too
08:57:50 <ihope> Well, getX would be x.
08:57:54 <ihope> ...I think.
08:58:09 <jip> yep, but i want a "getX = x" function created
08:58:16 <jip> ndm: what is drift?
08:58:22 <ndm> @where drift
08:58:23 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
09:21:28 <jip> why is it called length and not len?
09:22:34 <norpan> jip: what, the length function?
09:22:48 <norpan> i suppose because it calculates the length and not the len
09:23:03 <ChilliX> dcoutts: Hi!
09:24:07 <jip> hm...
09:24:23 <shapr> ChilliX: Yow, what time do you wake up?
09:24:54 <ChilliX> shapr: I am in NY.  It's 20 past noon here.
09:25:34 <ChilliX> (But I got up quite a bit earlier ;)
09:26:15 <shapr> Oh, I see.
09:26:59 <davidhouse> jip, why would it be len?
09:27:21 <jip> in python it's called len
09:27:47 <ChilliX> shapr: So, what are you up to?
09:28:05 <shapr> Hacking on conjure and cabal-get today. What about you? Doing something cool in NYC?
09:28:27 <davidhouse> jip, in everything else it's length. :)
09:28:32 <shapr> Oh, and looking for contract work too :-)
09:28:44 <ndm> jip, just add length = len
09:28:52 <ndm> or other way round...
09:29:10 <jip> see, even according to ndm's gut instict it should be len! :P
09:29:26 <ndm> it should really be genericLength :)
09:29:35 <ChilliX> shapr: Generally living in NYC for this year.
09:29:46 <shapr> If anyone wants websites built, Haskell/Python/Java hacked, Linux admin'd, etc and is willing to pay for it, please contact me.
09:29:54 <ChilliX> Currently writing rebuttals to ICFP reviews.
09:30:01 <shapr> Sounds like fun.
09:30:09 <ChilliX> Somehow the quality of the reviews is pretty abysmal this year.
09:30:15 <ChilliX> (Well, at least those I saw.)
09:30:24 <shapr> ChilliX: Do you know of any autoparallel approaches other than NDP?
09:30:49 <shapr> I've read about a PhD thesis that did autoparallel on combinators somehow, but have never found a copy.
09:30:51 <davidhouse> ndm, yeah, class Measurable m where genericLength :: m -> Int. instance Measurable [] where genericLength = length
09:31:12 <ChilliX> Most reviews are just uninformed.  Wonder what happend there this year.
09:31:18 <shapr> ChilliX: They should hire some of the guys from lambda-the-ultimate.org
09:31:24 <ChilliX> hehe
09:31:32 <ChilliX> shapr: There is GpH
09:31:44 <ChilliX> Do you mean for Haskell, or FP, or generally?
09:32:05 <shapr> I know at least five people from LtU who play music, write fiction, or do other non-programming things and know lots more theory than I do.
09:32:07 <ChilliX> Even just for FP, there are quite a number of approaches.
09:32:09 <shapr> Generally
09:32:23 <shapr> Though I'm most interested in FP on multicore.
09:34:57 <ChilliX> There was a survey article I am just looking for...
09:35:15 <norpan> my english dictionary has no "len", but it has "length:  The longest, or longer, dimension of any object, in distinction from breadth or width; extent of anything from end to end; ..."
09:35:19 <shapr> Transparently parallel code has been a dream for pure FP for years.
09:35:38 <norpan> of course maybe you native english speakers know what len is
09:35:54 <shapr> But I only know of two approaches that really work, and of those two, I can only find info on NDP.
09:36:53 <shapr> ChilliX: Any idea who wrote it?
09:37:16 <ChilliX> This book gives an overview http://www.amazon.com/gp/product/1852330929/002-2655787-9665652?v=glance&n=283155
09:37:40 <ChilliX> and I think one of the authors, Kevin Hammond, wrote a conference paper or jorunal article that has a survey
09:37:51 <ChilliX> though, I somehow don't find it right now
09:37:57 <shapr> Thanks, I'll check Citeseer for Kevin Hammond.
09:38:23 <ChilliX> There is also this article: http://portal.acm.org/citation.cfm?id=940872&dl=ACM&coll=portal
09:38:24 <shapr> I like the quote on amazon - "In his seminal paper [292], Hughes argues that functional programming is important because it promotes modular programming..." (more)
09:38:37 <ChilliX> but it only compares three systems, but in detail
09:38:46 <shapr> acm.org usually means "will cost money"
09:38:47 <ChilliX> :)
09:38:59 <shapr> Three is better than what I've found so far.
09:39:11 <ChilliX> acm.org is good to search for references
09:39:27 <shapr> But frustrating to find
09:39:35 <ChilliX> Once you know the title, you can always try to find a copy on the authors web page or citeseer or shcolar.google or whereever
09:39:36 <shapr> Same for scholar.google
09:39:57 <ChilliX> What is frustrating to find?
09:40:06 <shapr> Papers that I can't download
09:40:51 <shapr> For example, while recently researching a new way to build geared hubs for unicycles I ran across a magnetic gears series of papers, none of which I can read.
09:41:29 <shapr> It's cool, the only moving parts are the magnetic flux.
09:41:57 <shapr> Anyway, back to coding...
09:42:39 <ChilliX> I usually enter the paper title in quotes into google to find an online copy
09:42:41 <ChilliX> Works usually
09:43:20 <ChilliX> shapr: Happy coding!
09:43:23 <shapr> :-)
09:48:35 <Philippa> IME the usual problem papers're old ones published by the ACM
09:49:04 <Philippa> I think I've still technically got an ATHENS account, but that only gets me back as far as 1990 on the ACM site
09:51:49 * davidhouse had his physics pratical exam today
09:51:56 <davidhouse> i discovered that aluminum floats.
09:51:58 <davidhouse> :)
09:52:09 <SamB_XP> we should buy shapr a librarian for his birthday
09:53:08 <norpan> davidhouse: anything floats if it has the right shape :)
09:54:10 <norpan> but afaik aluminium is still at least twice as heavy as water
09:54:15 <norpan> density-wise
09:54:28 <davidhouse> yes. sadly i got the density as about 970 kg m^-3
09:54:42 <norpan> oh
09:56:03 <davidhouse> yeh. :) the rest of the exam went alright though.
10:06:26 <davidhouse> @hoogle liftIO
10:06:27 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
10:07:36 <RyanT5000> i know you're "not supposed to" do this, but is there any way to get a handle to an object's box?
10:07:54 <RyanT5000> it'd let you (potentially) determine if a datastructure was recursive
10:08:13 <RyanT5000> of course you'd still hang if you tried to explore an infinite datastructure
10:09:13 <ndm> RyanT5000: no, referential transparency stops this
10:09:28 <RyanT5000> yeah, but it also stops unsafePerformIO
10:09:30 <ndm> it breaks all sorts of haskell properties
10:09:38 <RyanT5000> i'm not asking for a clean way
10:09:45 <ndm> you can in Clean
10:09:54 <ndm> but i'm not aware of any way in Haskell
10:10:03 <RyanT5000> er, i wasn't referring to "Clean"
10:10:08 <RyanT5000> i meant, there's obviously no nice way of doing it
10:10:10 <ndm> i know :)
10:10:23 <RyanT5000> don't you think it could be useful to serialize recursive datastructures?
10:10:24 <ndm> just a little bit of irony, that it can be done in Clean
10:10:26 <RyanT5000> yeah
10:10:29 <RyanT5000> :)
10:10:41 <ndm> maybe one of the FFI modules has something
10:10:47 <RyanT5000> hm, maybe
10:10:51 <RyanT5000> i'll look in SerTH
10:10:54 <RyanT5000> see if they've done it already
10:10:54 <ndm> @hoogle Addr
10:10:55 <lambdabot> System.Win32.Types.Addr :: type Addr
10:10:55 <lambdabot> Text.Html.address :: Html -> Html
10:10:55 <lambdabot> Network.BSD.getHostByAddr :: Family -> HostAddress -> IO HostEntry
10:11:16 <ndm> I believe Bytestring uses Addr# in some places
10:11:22 <RyanT5000> oh, maybe you could pin everything, and then get pointers to it?
10:11:24 <ndm> which sounds like it might give the thing you want
10:11:36 <RyanT5000> hm alright
10:11:36 <ndm> can you pin an infinite data structure?
10:11:47 <RyanT5000> no, infinite datastructures can't be serialized anyway :P
10:11:53 <RyanT5000> at least not if functions can't be serialized
10:12:04 <RyanT5000> and function serialization is sufficiently hard that i'm prepared to just give up
10:12:36 <RyanT5000> i mean, you'd have to do something like specify which modules should be statically included in the serialized function
10:12:42 <RyanT5000> and which should be expected of the loading program
10:12:54 <ndm> or use Yhc, which should be able to serialise functions with less hassle
10:13:00 <RyanT5000> hm true
10:13:12 <RyanT5000> anyway i don't really need any of this anyway; it's just an intellectual exercise :P
10:19:36 <sjanssen_> RyanT5000: there is a serialization library that claims to handle recursive structures.  I think it might have been SerTH
10:19:42 <RyanT5000> alright
10:21:00 <araujo> Hi!
10:21:07 <RyanT5000> another question: is using records with functions in them a reasonable way to achieve dynamic polymorphism?
10:21:45 <jip> you mean like "oop" style?
10:21:47 <SyntaxNinja> I'm in ohio.
10:21:51 <shapr> yay!
10:21:55 <SyntaxNinja> the internet looks funny from here ;)
10:21:57 <RyanT5000> and also, how good can I expect the optimizer to be when it comes to figuring out that the functions are in fact static (e.g.: simmilar to inlining of virtual functions in C++ when they are determinable)?
10:21:58 <RyanT5000> jip: yeah
10:22:04 <SyntaxNinja> actually, it looks exactly the same on my laptop.
10:22:07 <shapr> SyntaxNinja: Less like a job?
10:22:21 <sjanssen_> RyanT5000: the optimizer won't figure out that they're static
10:22:25 <RyanT5000> ever?
10:22:42 <RyanT5000> that's kinda lame
10:22:57 <RyanT5000> is there some reason it would be really hard to do?
10:23:27 <RyanT5000> maybe there could be a new strictness annotation that said "evaluate this at compile-time"?
10:23:42 <RyanT5000> (e.g.: "i promise it halts")
10:23:48 <SyntaxNinja> shapr: hehe
10:24:08 <shapr> RyanT5000: Isn't that called partial evaluation?
10:24:26 <RyanT5000> shapr: no idea; sounds like it'd be a reasonable name for what i'm thinking of though
10:26:30 <RyanT5000> hm i guess it couldn't try to do compile-time replacement of the function because it has no way of knowing that the function that generates the function ever halts
10:26:49 <ndm> RyanT5000: see the size change termination + partial evaluation
10:27:02 <ndm> thats basically something to detect termination, and then a way to evaluate it away
10:27:08 <RyanT5000> hm
10:27:15 <ndm> neil jones, i believe...
10:27:39 <RyanT5000> is there a standardized way of doing partial evaluation? I see some papers, but i'd rather use settled technology
10:27:52 <RyanT5000> my other choice, of course, is to use classes and existentials
10:29:14 <RyanT5000> which would certainly provide static determination of functions
10:29:19 <sjanssen_> RyanT5000: did I understand you correctly?  You mean that you'll have some method in a record that you'll never change, and you want the compiler to figure out that you never change it so it can call the fn directly instead of looking it up in the record?
10:29:52 <RyanT5000> sjanssen: basically
10:30:31 <RyanT5000> sort of like how in C++ if you say SubClassObject sco; sco.something() it'll optimize away the virtual function call
10:30:39 <RyanT5000> (provided you have a good compiler)
10:30:44 <sjanssen_> that seems pretty tough.  What if you export the constructor, then a client could modify your record
10:31:09 <RyanT5000> yeah, i know there are plenty of circumstances in which you can't do it
10:31:18 <RyanT5000> but let's say i have a function buildDefaultThing
10:31:20 <RyanT5000> which returns a Thing
10:31:25 <RyanT5000> with all the functions filled in
10:31:27 <shapr> I'm pretty sure you're talking about partial eval.
10:31:52 <RyanT5000> shapr: i think I am; is there a way of doing it in H98 or current GHC?
10:32:13 <sjanssen_> RyanT5000: you could do something like "data Object = Unoverloaded | Overloaded {method1, ... }"
10:32:24 <shapr> dcoutts_ is doing research on that.
10:32:32 <sjanssen_> then have smart constructors/accessors that work correctly with that
10:32:40 <RyanT5000> shapr: lol i'm reading his paper right now
10:32:48 <palomer> you want function overloading? this can be achieved with GADTs (to a certain extent)
10:33:01 <shapr> I can barely wait for dcoutts_ to publish his peval code.
10:33:07 <shapr> It'll be awesome for arrows.
10:33:39 <sjanssen_> RyanT5000: or just bite the bullet.  It's just one dereference per method call
10:34:07 <RyanT5000> sjanssen: that's my "actual" solution
10:34:27 <RyanT5000> but as i'm trying to write a general-purpose library, i wanted to make sure i wouldn't permanently screw up my performance
10:34:33 <RyanT5000> this is for my SoC project
10:35:00 <sjanssen_> typeclasses are probably best
10:35:12 <RyanT5000> with existentials?
10:35:20 <sjanssen_> depending on your design, you can avoid/minimize existentials
10:35:57 <RyanT5000> hm
10:36:09 <RyanT5000> i dislike how existentials require the creation of a new type
10:36:27 <RyanT5000> oh, maybe they don't
10:36:34 <RyanT5000> oh, yeah they do
10:36:51 <RyanT5000> then i have to write an existential version and a class version of every function
10:37:08 <RyanT5000> that doesn't sound very fun or very maintainable, even if they are just proxies
10:37:08 <sjanssen_> no, you can make your existentials instance the class
10:37:13 <RyanT5000> oooh
10:37:17 <RyanT5000> interesting
10:37:23 <sjanssen_> those should be incredibly trivial to write
10:37:27 <RyanT5000> (that's why i'm asking these questions ;))
10:38:28 <sjanssen_> you're making a GUI library?
10:38:33 <RyanT5000> yeah
10:38:50 <RyanT5000> incidentally, am i the only one who has a fundamental problem with typeclasses in haskell? what i mean by that is that I don't like how, e.g. Ord implies that there is only one ordering on Integers (or at least that one is the most important)
10:38:54 <sjanssen_> I wonder how gtk2hs does polymorphism
10:39:05 <RyanT5000> heh i should look at that
10:39:12 <RyanT5000> my guess: really, really messily
10:39:19 <RyanT5000> because gtk2 itself is pretty messy with that
10:40:16 <sjanssen_> sometimes you wish you could override the behavior of a certain typeclass instance, but it isn't that big of a deal
10:40:41 <RyanT5000> i sort of think that there should be a more formal "defaults" mechanism in programming languages
10:40:42 * davidhouse can't wait until we have a functional lib with the same quality of gtk2hs
10:40:47 <sjanssen_> newtypes and newtype deriving can help
10:41:03 <RyanT5000> basically a class is a global variable, which is my problem with it
10:41:14 <RyanT5000> tbh i don't even like global functions
10:41:26 <RyanT5000> main :: Prelude -> Imports -> IO () ;)
10:41:51 <RyanT5000> so then the linker becomes a partial evaluator...
10:42:00 <RyanT5000> (which is really what it is anyway)
10:43:00 <RyanT5000> davidhouse: i'm writing one (which i certainly plan to have good quality), but it's going to be 3D
10:43:13 <RyanT5000> although technically it could have 2D renderers too
10:43:27 <RyanT5000> actually i "kind of" plan to have an SVG renderer
10:43:44 <RyanT5000> by which i mean i plan to make room for it but i don't plan to ever write the actual code, because i have no use for it
10:43:51 <RyanT5000> (really pretty screenshots?)
10:44:28 <sjanssen_> actually, newtypes + newtype deriving is really close to the way C++ does polymorphism
10:44:44 <RyanT5000> sjanssen_: yeah.... which i hate, lol
10:45:58 <RyanT5000> do you think forcing a GUI library to rely on either dynamic polymorphism or partial evaluation is reasonable?
10:46:07 <RyanT5000> how long until we have built-in partial evaluation support?
10:47:04 <shapr> y0 cos
10:47:47 <CosmicRay> hi shapr
10:48:29 <shapr> How's code?
10:48:33 <sjanssen_> RyanT5000: I don't think dynamic polymorphism is a particularly great thing.  I like as much static as possible
10:49:00 <CosmicRay> shapr: pretty good. working on backups lately.
10:49:06 <CosmicRay> shapr: got a new 48-tape lto3 changer here.
10:49:26 * palomer wonders who was the one who had bought an electric scooter
10:49:43 <RyanT5000> sjanssen_: what about cases where it's necessary? e.g.: getSubWindows :: Window -> [Window]
10:49:46 <shapr> CosmicRay: Cool, I tried bacula after your blogomendation, but the debs crapped out.
10:49:57 <RyanT5000> with classes you'd need to use a list of existentials, right?
10:50:37 <RyanT5000> i have to make the assumption that no module knows about all the other modules in existance
10:50:40 <CosmicRay> shapr: did you use my debs or jltallon's?
10:50:50 <shapr> Whatever is in debian/unstable
10:50:55 <CosmicRay> shapr: this was the subject of a recent flamewar.  I hijacked backula from jltallon because his debs were crap.
10:51:03 <CosmicRay> bacula in sid was neither buildable nor installable.
10:51:14 <CosmicRay> if you had 1.38.x, they were mine.  if you had 1.36.x, they weren't ;-)
10:51:21 <shapr> That was exactly my problem, I couldn't install it.
10:51:30 <CosmicRay> well, maybe not flamewar exactly.  discussion was more like it.
10:51:51 <shapr> I tried frobbing it by switching backends, but I couldn't get pgsql or sqlite to work.
10:51:54 <shapr> So I gave up and ripped it out.
10:52:56 <CosmicRay> it should Just Work now.
10:53:02 <sjanssen_> RyanT5000: that is a good point
10:53:12 <shapr> In that case, I'll give it another try.
10:53:15 <CosmicRay> I am using my debs on our production backup system.
10:53:20 <CosmicRay> well, a sarge backport of them.
10:53:21 <shapr> I really do need a backup manager.
10:53:28 <shapr> But not one that's broken
10:53:37 <CosmicRay> I use rdiff-backup to a firewire hdd at home.
10:53:50 <RyanT5000> sjanssen_: so that's what i'm grappling with: do i pretend that static polymorphism is the special case, or do i pretend that dynamic is?
10:53:57 <RyanT5000> in reality, they'll both happen a lot
10:54:28 <RyanT5000> although, really, how much of a performance hit are we talking about here?
10:54:33 <sjanssen_> if you go with your records idea, everything will be dynamic
10:54:38 <RyanT5000> right
10:54:44 <RyanT5000> i mean, given that we're rendering 3d graphics, i think it might be kind of moot
10:54:47 <CosmicRay> shapr: what media are you backing up to?
10:54:58 <RyanT5000> so then it boils down to "which is cleaner"
10:54:59 <sjanssen_> records should be the same performance as existentials
10:55:05 <RyanT5000> right
10:55:11 <shapr> CosmicRay: other hard drives and a DVD burner
10:55:23 <CosmicRay> bacula has a native DVD backend, as well as a hdd backend
10:55:28 <shapr> spiffy!
10:55:33 <CosmicRay> though rdiff-backup is probably more efficient for some hdd scenarios
10:55:38 <sjanssen_> except for cases where you statically know your types, in which case dynamics are slower
10:55:44 <RyanT5000> right
10:55:49 <RyanT5000> but how much slower?
10:55:58 <RyanT5000> 20 cycles per function call?
10:56:12 <RyanT5000> i mean it might be a seriously small amount of CPU time we're talking about here
10:56:13 <sjanssen_> one pointer dereference, plus any losses from inling and such
10:56:22 <RyanT5000> yeah, it's inlining i'm worried about
10:56:40 <sjanssen_> I think existentials are more Haskell-ish, and more convenient
10:56:44 <RyanT5000> hm
10:57:21 <RyanT5000> yeah, i guess records and existentials are more convenient
10:57:41 <RyanT5000> i still don't like classes, since they are essentially globals
10:57:52 <RyanT5000> but given that i'm already going to need bunches of globals
10:58:03 <sjanssen_> and they outlaw some things that you probably don't want to happen -- for example, with your dynamic/records idea you can make objects with new behavior at runtime
10:58:11 <RyanT5000> oooh
10:58:16 <RyanT5000> that's a very good point
10:58:23 <RyanT5000> i probably do want that
10:59:03 <sjanssen_> are you sure?  what kind of advantages can you get from that?
10:59:42 <RyanT5000> well how about interaction with hsplugins?
11:00:10 <RyanT5000> wouldn't that be made easier by the completely-dynamic idea?
11:01:29 <RyanT5000> since i want to be able to potentially make a GUI dev studio, i'd probably want to be able to load skins and complete GUIs at runtime
11:01:35 <RyanT5000> can I do that with existentials?
11:01:54 <RyanT5000> i.e.: do existentials support instances of their class which are not defined when your program is compiled?
11:02:09 <sjanssen_> no, but hs-plugins might
11:02:49 <RyanT5000> there's also another consideration: if I go the records route, i never have to use anything beyond H98 (i think) until i need partial evaluation for performance
11:03:07 <shapr> If there were some way to dump and load types from the type table at runtime, life would be much more interesting.
11:03:09 <RyanT5000> but if i go the classes/existentials route, everything I do is going to be extensions
11:03:29 <RyanT5000> shapr: don't types get stripped just like symbols?
11:04:07 <adept> evening
11:04:42 <shapr> Assume hs-plugins, assume runtime loading of new types, I'd like to migrate my types to other running GHC runtimes to do something like Erlang's distributed processing.
11:05:31 <sjanssen_> RyanT5000: so how will this record idea work?  Say you've got mkButton and mkTextArea.  They support different methods.  What are their types?
11:05:55 <RyanT5000> mkButton :: ButtonConfigInfo -> Button
11:06:19 <RyanT5000> data Button = {button-specific-stuff ; super :: Window}
11:06:21 <RyanT5000> or something like that
11:06:21 <stepcut> shapr: have you seen the mobile haskell paper ?
11:07:36 <sjanssen_> okay, let's say I have a function to insert a list of things into a panel.  How do I turn the button and the text area into something with the same type?
11:07:39 <sjanssen_> call super?
11:07:52 <RyanT5000> i suppose
11:08:44 <sjanssen_> do I have to call super n times if I have something that is n subclasses away from a Window?
11:08:57 <RyanT5000> good point :)
11:09:31 <RyanT5000> so i either get larger and larger datastructures by storing a pointer to each base class, or I get multiple calls
11:09:44 <RyanT5000> i guess i'm leaning towards existentials at this point :P
11:11:27 <RyanT5000> but i still hate the fundamental premise of classes
11:11:44 <RyanT5000> "For example, Show: why support only one, global way of printing things? I often need multiple ones."
11:11:53 <RyanT5000>  -- Frank Atanassow
11:12:53 <sjanssen_> I think Show is overused
11:13:35 <sjanssen_> the only things that Show in a user presentable fashion are numbers
11:13:36 <RyanT5000> but doesn't the same notion apply - but in more subtle ways - to all classes?
11:14:58 <sjanssen_> so, you'd like to provide a function that can supply a different instance to a function you're calling?
11:15:16 <RyanT5000> yeah, basically
11:15:56 <sjanssen_> okay, how about: Set.union (withInstance x $ Set.fromList ...) (withInstance y $ Set.fromList ...)
11:16:20 <sjanssen_> union won't work correctly, because the two sets are ordered differently
11:16:45 <RyanT5000> hm
11:18:42 <RyanT5000> well i think the explicit upcasts are the dealbreaker for me
11:18:58 <RyanT5000> i can't think of anything as bad as that that comes from using existentials
11:19:17 <shapr> stepcut: Don't think so
11:19:30 <RyanT5000> and i can always use newtype
11:19:44 <RyanT5000> i guess haskell isn't quite ready for "no global variables... period" ;)
11:19:51 <sjanssen_> RyanT5000: well, you'll need explicit casts, but there will be just one per existential wrapper
11:19:57 <RyanT5000> right
11:20:14 <RyanT5000> and also I should be able to do almost everything with parametric polymorphism
11:20:25 <sjanssen_> actually, I bet you can't use newtype for existentials, but using data is the same interface
11:20:48 <RyanT5000> no, i meant if i need to replace the instance for a particular type
11:20:52 <RyanT5000> so like
11:21:08 <sjanssen_> oh yeah, I see what you mean
11:21:12 <RyanT5000> newtype MoreDifferentButton = MoreDifferentButton Button
11:21:30 <RyanT5000> and since i don't really see where that would be necessary anyway
11:21:41 <RyanT5000> i won't plan for it so much
11:22:05 <RyanT5000> lol i really hope i get into the summer of code
11:30:23 <davidhouse> you know what isn't fun?
11:30:38 <davidhouse> *aren't fun, i should say.
11:30:49 <davidhouse> segfaults. /me still can't track his down.
11:30:50 <caribe> hum? ;)
11:31:10 <davidhouse> i think it's something to do with bootfiles, which seem to be generally buggy in GHC.
11:31:20 <caribe> and i still even don't get the basics of haskell.. ;-(
11:31:40 <davidhouse> caribe, what are you struggling with?
11:32:01 <caribe> trying to understand the type system
11:32:03 <caribe> sec
11:32:20 <caribe> i have somthing like..
11:32:22 <caribe> data Test = My Int
11:32:40 <caribe> and a function like
11:32:42 <caribe> test (My x) = (My (x+1))
11:33:10 <caribe> why won't data Test = My Num work? ;-(
11:33:21 <ADEpt> Num is a type
11:33:41 <ADEpt> Num is not a type, even
11:33:43 <davidhouse> Num isn't a type.
11:33:53 <caribe> a type class ghc says
11:33:54 <davidhouse> Num is a class, which is like a collection of types.
11:33:58 <davidhouse> yep.
11:34:04 <ADEpt> Num is a set of types, which is called typeclass
11:34:04 <davidhouse> type class != type :)
11:34:18 <caribe> ;-) ok i got this by now
11:34:31 <davidhouse> Num is the set of types whose values you can add, subtract and so on.
11:34:45 <davidhouse> so for example, integers and real numbers etc, but also more abstract things like matrices.
11:34:47 <caribe> but why won't "(Num a)=> Test = My a" work?
11:35:04 <davidhouse> something like that should.
11:35:14 <davidhouse> the syntax is a little funky with data constructors.
11:35:38 <davidhouse> perhaps data Test = (Num a) => My a
11:35:44 <davidhouse> not completely sure.
11:36:01 <sjanssen_> caribe: it is rarely to your advantage to use class constraints in data constructors
11:36:32 <Cale> hm?
11:36:40 <caribe> hmm ok? it's just that i'd like to get a lil deeper understanding
11:36:45 <Cale> data (Num a) => Test a = My a
11:36:49 <caribe> so how would one solve this?
11:36:59 <Cale> is valid, but probably doesn't mean what you want
11:37:18 <Cale> sorry, I'm just jumping in here -- what are we discussing? :)
11:38:10 <caribe> Cale, this works :>
11:38:33 <caribe> i'm just trying to understand why i couldn't use Num instead of Int
11:39:01 <davidhouse> you can't use Num _directly_ instead of Int because Num isn't a type.
11:39:29 <Cale> To 'use Num', you apply it as a constraint to restrict a type variable
11:39:35 <davidhouse> yep.
11:39:45 <Cale> so Int -> Int becomes  (Num a) => a -> a
11:39:48 <Cale> or something similar
11:39:54 <davidhouse> you say "provided a is an instance (a member) of Num, you can use it here"
11:40:04 <davidhouse> which is the same as saying "you can use any instance of Num you like"
11:40:41 <caribe> aaah ok now i think i get the idea :)
11:42:00 <Cale> yeah, it's not quite like in, say, Java, where you use interfaces like types, classes here are more like statements about types rather than types on their own.
11:42:33 <davidhouse> if a given type is an instance of Num, that means you can take values of that type and add and subtract them.
11:42:54 <davidhouse> (plus do some other things like negate them, etc)
11:44:11 <davidhouse> similarly, if a class is an instance of Show, that means you can convert it into a String.
11:44:49 <davidhouse> as Cale says, membership of a class is like a property of that type.
11:46:38 <davidhouse> Cale, hows work on your puzzle?
11:47:08 <caribe> ah yup i think i got it, it's just a bit puzzling when you're used to oop..so thanK you :) it really helps allot to get such answers after you failed a certain times.. ;)
11:49:08 <Cale> davidhouse: well, I have another one (not sure if you've already seen it)
11:49:12 <davidhouse> Cale, just saw it.
11:49:47 <davidhouse> Cale, i'd still like to see some sample solutions or some exemplary strategy.
11:49:53 <Cale> okay
11:50:07 <vincenz> re
11:51:40 <Cale> I'll make up a bunch of step-by-step images on the sample problem
11:51:48 <vincenz> :)
11:51:50 <vincenz> kewl
11:52:25 <jip> my program is simple and seems to run fine, but i let it run for about an hour and it suddenly crashed with "Killed"!
11:52:42 <davidhouse> what does it do?
11:52:54 <hyrax42_> @pl \f -> join . map (maybeToList . f)
11:52:55 <lambdabot> (join .) . map . (maybeToList .)
11:52:57 <SamB_XP> space leak?
11:52:58 <jip> yikes and now i have managed to crash it it gets the error: "Stack space overflow: current size 8388608 bytes."
11:53:13 <vincenz> hyrax42_: tried kum nye?
11:53:19 <vincenz> jip: woo
11:53:24 <vincenz> jip: stackoverflow
11:53:28 <SamB_XP> oh, stack smash! the evilest of haskell errors!
11:53:31 <hyrax42_> not yet but I'll be puttin on amazon order I think
11:53:42 <hyrax42_> it's not too much
11:53:51 <hyrax42_> did I just define mapMaybe up there?
11:53:52 <vincenz> 13 dollars or so no?
11:53:55 <hyrax42_> yeah
11:53:58 <hyrax42_> well I thikn 15 cad
11:54:03 <hyrax42_> or 16 at worst
11:54:04 <vincenz> oh right
11:54:05 <vincenz> euro
11:54:15 <vincenz> cad hmm?
11:54:16 <hyrax42_> not quite at the correct rate
11:54:19 * vincenz is going to toronto in july
11:54:23 <hyrax42_> ah
11:54:27 <hyrax42_> I'm in mtl
11:54:30 <vincenz> :D
11:54:36 <hyrax42_> but in july I'll be in tz
11:54:37 <xerox> Monad Template Library?
11:54:48 <vincenz> xerox: no profiling template library
11:54:51 <vincenz> let me fish the link
11:55:43 <davidhouse> does join a generalised concat?
11:55:48 <davidhouse> err, *is join
11:55:55 <xerox> davidhouse: yes.
11:55:55 <hyrax42_> :t join
11:55:59 <hyrax42_> @type join
11:56:00 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:56:05 <vincenz> hyrax42_: like this
11:56:06 <davidhouse> fun.
11:56:12 <vincenz> > join (+) 2
11:56:13 <lambdabot> 4
11:56:28 <neologism> do anyone know monitor synchronization primitve?
11:56:29 <davidhouse> > map join [Just $ Just 4, Just Nothing, Nothing]
11:56:30 <lambdabot> [Just 4,Nothing,Nothing]
11:56:31 <hyrax42_> yeah I am finally coming to understand the monad reader
11:56:46 <hyrax42_> > join Maybe Nothing
11:56:47 <lambdabot>  Not in scope: data constructor `Maybe'
11:56:48 <davidhouse> vincenz: that's a bit of a bad example
11:56:51 <hyrax42_> I mean
11:56:53 <vincenz> davidhouse: no it's great
11:56:55 <hyrax42_> > join Just Nothing
11:56:56 <lambdabot> Couldn't match `a1 -> a' against `Maybe a1'
11:56:57 <vincenz> -> a is a monad
11:57:06 <davidhouse> > join $ Just Nothing
11:57:06 <lambdabot> Add a type signature
11:57:11 <sjanssen_> @type (>>= maybeToList)
11:57:12 <lambdabot> forall a. [Maybe a] -> [a]
11:57:13 <davidhouse> > join $ Just Nothing :: Maybe Int
11:57:14 <lambdabot> Nothing
11:57:22 <davidhouse> vincenz: yes, but not a very common one.
11:57:29 <vincenz> davidhouse: it's great tho
11:57:35 <vincenz> > join (,)
11:57:36 <lambdabot> Add a type signature
11:57:42 <vincenz> > join (,) 'a'
11:57:42 <lambdabot> ('a','a')
11:57:42 <davidhouse> vincenz: it's just Reader :)
11:57:50 <hyrax42_> -> a is monad as well?
11:57:52 <hyrax42_> writer?
11:57:55 <vincenz> erm
11:57:59 <vincenz> r -> is a monad
11:58:00 <davidhouse> hyrax42_: nope, it's Reader in disguise.
11:58:10 <vincenz> whichi would make
11:58:11 <sjanssen_> hyrax42_: (a->) is a Monad, (->a) can't be a monad
11:58:15 <vincenz> -> < a comonad
11:58:17 <xerox> ((->) a)
11:58:19 <vincenz> ->  a comonad
11:58:53 <vincenz> are there comonadic laws?
11:59:03 * vincenz isn't a good ct'r
11:59:05 <davidhouse> what's a comonad
11:59:06 <hyrax42_> oh I kep reading comand
11:59:06 <davidhouse> ?
11:59:07 <vincenz> but I bet comonads can be neat
11:59:16 <xerox> davidhouse: the dual or a Monad.
11:59:17 <vincenz> davidhouse: I don't know, the categorical dual of a moan
11:59:19 <hyrax42_> command, rather
11:59:26 <vincenz> could be useful
11:59:27 * vincenz shrugs
11:59:29 <vincenz> I ain't a cter
12:00:33 <xerox> davidhouse: a Comonad provides |coeval :: (Comonad w) => w a -> a|
12:01:11 <xerox> ....and cobind, |(=>>) :: (Comonad w) => w a -> (w a -> b) -> w b|
12:01:38 <xerox> haha, same lengthed phrases again.
12:01:48 <davidhouse> ah.
12:02:39 <xerox> Thare also is a |(.>>) :: (Comonad w) => w a -> w b -> w b| combinator which is equivalent to: |x .>> y = seq x y|.
12:03:07 <xerox> It is used to propagate demand to the left where lazy evaluation might otherwise leave x unevaluated.
12:03:10 <hyrax42_> would reading some CT be useful for learning/using haskell?
12:03:29 <_Codex> have anyone actually found any good use for the comonads? (something like parser combinators etc?)
12:04:13 <xerox> Yes.  musasabi did some work on them at <http://www.cs.helsinki.fi/u/ekarttun/comonad/>.
12:05:21 <hyrax42_> and on that note, what CT text would be a good start
12:05:29 <vincenz> xerox: weren't they used with streams???
12:05:30 <hyrax42_> CT for CS?
12:05:50 <xerox> They are good for dataflow programming.
12:18:54 <psi> you can't write scheme's map in haskell, can you?
12:19:47 <sjanssen_> what does Scheme's map do?
12:19:48 <psi> because the type of the function would depend on the number of lists you give it
12:20:14 <psi> it can take a variable number of lists, and applies each head to the function
12:20:24 <Muad_Dib> well
12:20:29 <sjanssen_> psi: there are techniques for polyvariadic functions, using typeclasses
12:20:51 <Muad_Dib> or you could hand it a list of lists (so instead of sending them as separate parameters, just put them in a list
12:21:14 <psi> Muad_Dib: but the function you send to map, what type would it have?
12:22:34 <sjanssen_> @type map (\(x:xs) -> f x : xs)
12:22:35 <lambdabot> Not in scope: `f'
12:22:50 <sjanssen_> @type \f -> map (\(x:xs) -> f x : xs)
12:22:51 <lambdabot> forall a.
12:22:51 <lambdabot>             (a -> a) -> [[a]] -> [[a]]
12:22:58 <davidhouse> > let schMap = map head in schMap [[1..5], [20..70], [1000..4]]
12:22:59 <lambdabot> Exception: Prelude.head: empty list
12:23:06 <davidhouse> > let schMap = map head in schMap [[1..5], [20..70], [1000..4000]]
12:23:07 <lambdabot> [1,20,1000]
12:23:19 <davidhouse> it does require that all of the lists are of the same type.
12:25:17 <psi> that's not it. the passed function is applied to all the heads. ie map (+) [[1,2,3], [1,2,3]] should rturn [2,4,6]
12:26:20 <sjanssen_> psi: so you want something like zipWith ?
12:26:23 <davidhouse> ah.
12:26:31 <sjanssen_> polyvariadic zipWith
12:26:41 <psi> yes, like zipWith, but variable, exactly
12:26:46 <davidhouse> then you'd need something more complex, as the first parameter has a varying type.
12:26:47 <davidhouse> TH?
12:26:52 <vincenz> @type (>>=)
12:26:53 <lambdabot> forall (m :: * -> *) b a.
12:26:53 <lambdabot>    (Monad m) =>
12:26:53 <lambdabot>    m a -> (a -> m b) -> m b
12:27:02 <xerox> It is possible to do variadic functions in Haskell without TH.
12:27:08 <vincenz> xerox you sure about cobind?
12:27:27 <xerox> Yes.
12:27:29 <psi> davidhouse: yeah
12:27:41 <psi> the function type varies depending on the number of lists
12:27:52 <psi> the passed function, that is
12:28:18 <davidhouse> xerox, Text.Printf does so IIRC, right?
12:28:27 <xerox> Quite (:
12:29:03 <xerox> psi - I think it is easily doable in terms of transpose and fold.
12:29:15 <pejo> psi, do you have code which needs this?
12:30:09 <psi> pejo: no. I just reimplemented map in scheme and thought, "can I do this in haskell?"
12:31:11 <xerox> @type (. transpose) . map . foldr1
12:31:12 <lambdabot> forall a.
12:31:12 <lambdabot>            (a -> a -> a) -> [[a]] -> [a]
12:31:16 <xerox> There you go.
12:31:35 <sjanssen_> > let next = zipWith ($) in map (\x y z -> x * y - z) [1..10] `next` [1..10] `next` [1..10]
12:31:35 <lambdabot> [0,2,6,12,20,30,42,56,72,90]
12:31:55 <sjanssen_> psi: there's one where your function type is less restrictive
12:31:59 <jip> in ghci, if i do "let a = 5", and then do :reload, is it possible to preserve the value of a?
12:32:01 <xerox> Uh.
12:32:05 <xerox> jip: nope.
12:32:12 <jip> please?
12:32:19 <xerox> jip: no, unless you define that value in the module you are loading.
12:32:51 <jip> no, that won't work
12:33:33 <xerox> Why?
12:33:34 <jip> actually what i really need to do is "a <- foo", and then preserve the value after a :reload
12:35:08 <davidhouse> still no.
12:35:13 <kombinator> jip: a can make use of types that are gone after a reload (or the types that are changed), that's why it is flushed away
12:35:17 <davidhouse> GHCi needs less sandboxing.
12:36:52 <psi> xerox: but that's not the same, either. with three lists we'd want a function taking 3 arguments.
12:37:05 <sjanssen_> psi: did you see my example?
12:37:11 <psi> I'm going to look now.
12:40:27 <jip> kombinator: but the "Int" type will never change between a reload
12:40:51 <kombinator> jip: right, but in general types will change
12:41:14 <jip> so ghci could flush the value only in the case where it's type has changed
12:41:30 <xerox> It sounds like a difficult condition to check.
12:42:10 <jip> if it's that difficult then just leave it as an unsafe feature and rely on the programmer not to be sure that the type hasn't changed
12:45:02 <davidhouse> one thing that is annoying is that your entire module set/current scoped variables are wiped when you do an :r and there's an error in one of your modules.
12:45:26 <shapr> You can put an 'autoexec.bat' in your .ghci
12:45:43 <shapr> You can also create your own aliases.
12:46:25 <psi> sjanssen_: yeah, that's just as good I guess
12:46:49 <jip> that still won't help with my problem though
12:47:02 <xerox> ?karma+ sjanssen -- that one is a very clever trick.
12:47:02 <lambdabot> sjanssen's karma raised to 9.
12:47:37 <psi> :)
12:52:08 <vincenz> @karma
12:52:08 <lambdabot> You have a karma of 4
12:52:38 <swiert> shapr: have you seen this paper:
12:52:40 <swiert> http://chris.chris-lotte.net/publications/2006/arrows/arrows.pdf
12:53:44 <DeliQ> swiert: doaitse je vader ?
12:54:07 <shapr> oh, neat
12:54:32 <vincenz> DeliQ: je bent een nederlander?
12:54:35 <davidhouse> sjanssen_: that looks like an Control.Applicative candidate.
12:54:40 <petekaz> OT: does a 2nd edition of a book get a new ISBN number?
12:54:45 <DeliQ> yup, floepte er per ongeluk nederlands uit
12:54:46 <swiert> \whois DeliQ
12:54:47 <DeliQ> :P
12:54:52 <swiert> damn.
12:54:54 <shapr> ik begrijp het niet!
12:54:59 <Muad_Dibber> heh swiert, use the other slash :P
12:54:59 <DeliQ> LOL
12:55:01 <vincenz> shapr: jij bent dan ook een helicopter
12:55:10 <swiert> too much latex.
12:55:11 <DeliQ> het word steeds gekker hier
12:55:18 <DeliQ> wordt*
12:55:20 <shapr> gezeik!
12:55:20 <DeliQ> :P
12:55:23 <vincenz> lol
12:55:50 <Muad_Dibber> heh
12:55:51 <DeliQ> swiert: ff zonder gein, is doaitse je vader ?
12:56:05 <Muad_Dibber> DeliQ: now talk english please :)
12:56:13 <DeliQ> ok, i will, sorry :P
12:56:26 <vincenz> shapr: wanna see my paper?
12:56:27 <shapr> Yeah, only #python has Dutch as a primary language.
12:56:30 <shapr> vincenz: sure yeah
12:56:35 <vincenz> http://atc.dacya.ucm.es/atc/descargar.php?file=icme2006.pdf
12:56:43 <swiert> DeliQ: no, Doaitse is my uncle.
12:56:54 <sjanssen_> davidhouse: you're right, it's next is <*>
12:57:20 <xerox> @remember swiert <swiert> \whois DeliQ  <swiert> damn.  <swiert> too mych latex.
12:57:20 <lambdabot> Unknown command, try @list
12:57:24 <xerox> ):
12:57:41 <sjanssen_> so we could have a generic fmap f l1 <*> l2 <*> l3 <*> l4 ...
12:58:08 <DeliQ> i saw your last name, so i thought they must be related...
12:58:11 <DeliQ> :P
12:58:25 <davidhouse> sjanssen_: have you read the paper?
12:58:32 <xerox> sjanssen_: that's more tricky.
12:58:36 <shapr> Is S. Swierstra the same as Doaitse?
12:58:38 <sjanssen_> or, even better: f <$> l1 <$> l2 ...
12:58:47 <sjanssen_> davidhouse: nope, is it interesting?
12:58:51 <davidhouse> yeah, quite.
12:58:53 <DeliQ> shapr: i think so yes...
12:59:01 <davidhouse> it explains the concept quite well.
12:59:04 <swiert> shapr: yes. 
12:59:18 <xerox> sjanssen_: since one can't do it implicitly, that requires explicit type hackery.
12:59:36 <DeliQ> long time no see though, doaitse in here
12:59:37 <xerox> At least in my opinion, maybe you can come up with another magical definition (:
12:59:44 <shapr> swiert: The CT is over my head, but some year when I get to CT I'll read this again.
13:00:32 <d0c> hey, i'm trying to profile heap with -hb and my program crashes
13:00:33 <d0c> on windows:
13:00:34 <d0c> internal error: Unexpected closure type 47 in LDV_recordDead_FILL_SLOP_DYNAMIC()
13:00:34 <d0c> on linux
13:00:34 <d0c> internal error: Invalid object in processHeapClosureForDead(): 0
13:00:49 <davidhouse> @fptools Control.Applicative
13:00:49 <lambdabot> Control.Applicative not available
13:01:05 <swiert> shapr: it is pretty cool. I haven't worked my way through the proof yet, but their claim sounds interesting.
13:01:35 <davidhouse> the list instance is pure = return, <*> = ap
13:01:49 <shapr> Arrows' equivalence to Freyd categories has been known for some time, hasn't it?
13:01:52 <d0c> am i doing sth wrong or should i just report the bug?
13:01:57 <davidhouse> @type ap
13:01:58 <lambdabot> forall b (m :: * -> *) a.
13:01:58 <lambdabot> (Monad m) =>
13:01:58 <lambdabot> m (a -> b) -> m a -> m b
13:02:11 <shapr> d0c: Are you using ghc 6.4.2 ?
13:02:13 <davidhouse> > return (+1) `ap` [1..5]
13:02:14 <lambdabot> [2,3,4,5,6]
13:02:27 <davidhouse> > return (+) `ap` [1..5] `ap` [5..10]
13:02:28 <lambdabot> [6,7,8,9,10,11,7,8,9,10,11,12,8,9,10,11,12,13,9,10,11,12,13,14,10,11,12,13,14,15]
13:02:36 <davidhouse> okay.
13:02:39 <d0c> yep
13:02:47 <shapr> d0c: Sounds like a bug, I'd report it.
13:02:59 <xerox> > return (\x y z -> x + y * z) `ap` [1,1] `ap` [2,2] `ap` [3,3]
13:03:00 <lambdabot> [7,7,7,7,7,7,7,7]
13:03:16 <xerox> Nah.
13:03:17 <swiert> shapr: yes. Freyd categories are pretty complicated. Monoids on bifunctors are relatively straightforward.
13:03:26 <shapr> Oh, that is an interesting point.
13:03:42 <psi> ?+karma+ sjanssen_  -- I fully understand the solution now, and I liked it a lot :)
13:03:42 <lambdabot> sjanssen_'s karma raised to 1.
13:03:49 <psi> hm
13:04:14 <psi> oh, different nick. looked liked it had been reset.
13:04:40 <davidhouse> xerox, we need an alternative instance declaration then.
13:05:11 <DeliQ> i need karma too ... :P
13:05:14 <DeliQ> lol
13:05:24 <swiert> plus the fact that you can then see monads and arrows in the same way.
13:05:39 <shapr> swiert: What does the C <sup>op</sup> X part mean?
13:06:03 <swiert> reverse the morphisms.
13:06:12 <shapr> Is that the associative binary operation?
13:06:46 <swiert> It is saying that an arrow takes two arguments: one in C one in C with the arrows reversed.
13:07:17 * shapr almost understood that...
13:07:24 <jip> hm... my program runs fine from within ghci, but when i compile it with -O it runs slow as ASS: i mean slow as __ASS__
13:08:08 <sjanssen_> jip: now that's an interesting phenomenon
13:08:12 <sjanssen_> what does your program do?
13:08:52 <jip> sjanssen: it's an interactive simulation, thing is it was working fine before, but every now and then when i make some very small changes that should be insignificant i experience this
13:09:36 <swiert> shapr: you know all monads are also functors.
13:09:58 <shapr> yup
13:10:11 <swiert> shapr: this says, when you fix the second argument of an arrow, you also have a functor.
13:10:38 <vincenz> shapr: thoughts?
13:10:43 <xerox> But a different one, it seems, swiert?
13:10:51 <shapr> vincenz: Sorry, got distracted into reading swiert's papers :-)
13:10:56 <xerox> swiert: mind if I ask you what is the difference between C an C^op ?
13:10:59 <swiert> shapr: but when you fix the first, you get a contravariant functor- which reverses the direction of the arrows.
13:12:06 <shapr> I know arrows from the Haskell side, are the first and second arguments the b and c of (Arrow a ) => a b c ?
13:12:15 <swiert> exactly.
13:12:39 <davidhouse> what paper are we discussing?
13:13:05 <shapr> davidhouse: http://chris.chris-lotte.net/publications/2006/arrows/arrows.pdf
13:13:05 <swiert> so what this paper is saying is basically, you can describe arrows as functors with a bit of monoidal structure.
13:13:28 <swiert> just as we can describe a monad as a functor (of one argument) with a bit of monoidal structure.
13:13:29 <shapr> That's really neat.
13:13:52 <davidhouse> wow, fun.
13:13:57 <shapr> I suspect that a few hours of studying that on bus rides will lead to great insights on using arrows.
13:14:10 <shapr> At least, for me :-)
13:15:17 <shapr> davidhouse: Sarcasm?
13:15:29 * shapr isn't sure
13:15:36 <davidhouse> shapr, no, i'm quite surprised.
13:16:00 <davidhouse> some parallels with MonadPlus need to be drawn
13:16:47 <shapr> What's the CT for MonadPlus? I forget...
13:17:07 <xerox> swiert: any luck?
13:17:16 <davidhouse> shapr: CT?
13:17:28 <shapr> category theory
13:17:44 <davidhouse> ah. no idea.
13:18:11 <jip> sjanssen: i figured it out!
13:18:19 <vincenz> swiert: I'll read it too when I have a bit more time, I'm not a very good cter or theoriist, but it does look interesting
13:18:25 <sjanssen_> jip: oh, do tell
13:19:11 <vincenz> swiert: care to read my paper?
13:19:12 * palomer starting to dislike academia, a little bit
13:19:17 <vincenz> bit more practical in nature
13:19:23 <vincenz> not as theoretical
13:19:27 <davidhouse> palomer: whyso?
13:19:29 <swiert> shapr: There is actually surprisingly little on MonadPlus.
13:19:32 <DeliQ> vincenz: i would like to read it
13:19:36 <vincenz> DeliQ: http://atc.dacya.ucm.es/atc/descargar.php?file=icme2006.pdf
13:19:40 <DeliQ> thanks
13:19:50 <jip> sjanssen: apparently the compiled version was running just fast enough that the time measurement of a computation went down to 0 and this value was used as a divisor which for some reason caused a great pause
13:20:10 <DeliQ> vincenz: i'll let you know when i read it
13:20:18 <DeliQ> vincenz: think it's nice to get some feedback.. ?
13:20:29 <davidhouse> jip, how on earth did you work that out?
13:20:36 <swiert> vincenz: sure. I can't guarantee I have a lot of time though - I'm kind of working towards a deadline myself.
13:20:42 <jip> davidhouse: by thinking about the problem :)
13:21:07 <vincenz> swiert: me too
13:21:12 <vincenz> two reviews and then my research :(
13:21:30 <palomer> davidhouse: a combination of mental masturbation and forced publicationizing
13:21:31 <vincenz> tho last night was cool" here is a paper you're coauthoring, it's due tomorrow, could you please look over it"
13:21:40 <shapr> swiert: That is surprising. I'd expect CT for all the Monad typeclasses.
13:21:40 <vincenz> palomer: depends where you do research
13:21:44 <vincenz> palomer: I could never do CT stuff
13:21:56 <vincenz> DeliQ: always
13:21:59 <palomer> I don't mind CT
13:22:13 <vincenz> DeliQ: feedback is something I could use more off
13:22:21 <vincenz> DeliQ: mind you it's not a central part of my current research
13:23:02 <jip> i'm still getting that "Stack space overflow" crash though
13:23:10 <shapr> vincenz: Have you read Trevor Blackwell's PhD thesis?
13:23:24 * davidhouse comes across another situation where the \f g x y -> g x `f` g y would be a useful one
13:23:33 <vincenz> shapr: fraid not
13:23:38 <swiert> shapr: to the best of my knowledge - when you have a functor F:Set -> Set, monadplus means that you have a functor from F' : Set -> Monoids such that U . F' = F.
13:23:52 <swiert> where U is the forgetful functor from Mon -> Set.
13:24:05 <shapr> Has anyone written about that?
13:24:13 <swiert> it helps if you draw a picture.
13:24:24 <shapr> vincenz: http://tlb.org/papers-thesis.html
13:24:46 <swiert> no. I talked to some people who know a shitload more ct than me, and they didn't have a better explanation than that.
13:24:47 <vincenz> shapr: thank you, (tho I had just googled that:)) but thanks for the mention of the name
13:25:41 <davidhouse> swiert, what's your real-life name? (if you don't mind disclosing)
13:25:49 <vincenz> shapr: current research revolves around something like deforestation but for imperative programs
13:25:50 <shapr> swiert: You sound like you understand it, and no one has written about it, what about an overview paper describing the various monad typeclasses in CT?
13:26:11 <swiert> davidhouse: Wouter Swierstra.
13:27:22 <swiert> swiert: unfortunately, they're not all terribly interesting.
13:27:49 <Muad_Dibber> talking to yourself eh
13:27:59 <swiert> *shapr
13:28:02 <shapr> vincenz: Deforestation makes a lot of sense. What about region allocation, Boquist's GRIN, ChilliX & dons' array fusion?
13:28:33 <vincenz> array fusion has been done
13:28:38 <vincenz> it's called copy propagation
13:28:39 <shapr> swiert: They might be interesting to the CT geeks of the world.
13:28:44 <vincenz> and uses a theoretical framework called..
13:28:50 <vincenz> polyhedral model
13:29:08 <vincenz> as for region allocation
13:29:19 <vincenz> my previous research was focused on custom dm managers
13:29:30 <shapr> dynamic memory/
13:29:30 <shapr> ?
13:29:33 <vincenz> yep
13:31:18 <vincenz> you know
13:31:20 <shapr> vincenz: Seen ChilliX's Functional Array Fusion papers? http://www.cse.unsw.edu.au/~chak/papers/papers.html#afp-arrays
13:31:21 <vincenz> it's very interesting
13:31:30 <vincenz> for you theoretical csers around
13:31:44 <vincenz> most people use complexity theory to state the current requirements of an algorithm
13:32:01 <vincenz> what would be much more interesting is some way to garner what the minimal theoretical required storage or computation would be
13:32:08 <vincenz> if some optimal optimizer existed
13:32:27 <davidhouse> well, complexity theory isn't used like that.
13:32:32 <vincenz> nope
13:32:42 <shapr> I bet you can derive Shannon's information limits to get the same thing.
13:32:50 <vincenz> not certain
13:32:57 <davidhouse> you actually want a whole new branch of research.
13:33:47 * jip cries over "Stack space overflow" crash
13:33:53 <sjanssen_> there are complexity classes that describe space requirements of programs
13:34:01 <vincenz> shapr: thanks for the links
13:34:04 <vincenz> pushed on my toread stack
13:34:11 <swiert> shapr: what I mean to say is probably, the theory is all really well understood. The people most likely to referee a paper like that are likely to know loads of ct and reject it on the grounds that it doesn't contain enough new content.
13:34:12 <sjanssen_> jip: bet you need to be more strict
13:35:20 <xerox> shapr: is the paper you are referring to the one titled `Higher Order Flattening' ?
13:35:22 <shapr> swiert: I'd read it :-) A lot of research like that isn't in one place.
13:35:25 <lisppaste2> davidhouse pasted "Control.Applicative and Scheme's map" at http://paste.lisp.org/display/20088
13:35:37 <davidhouse> sjanssen_, xerox, it's almost there.
13:36:03 <davidhouse> small problem in the instance decl for SchList though.
13:36:20 <davidhouse> it makes sense to lift a function, but i can't think how we would lift a value/
13:36:23 <xerox> davidhouse - but it isn't a variadic function.
13:36:45 <davidhouse> no, it's an adaption of sjanssen's approach to Control.Applicative
13:37:17 <shapr> vincenz: I'm positive you can adapt Shannon's information theory limits to complexity theory and get theoretical storage requirements.
13:37:37 <sjanssen_> I remember a post from Oleg on variadic functions, shouldn't be hard to make a variadic function to do this
13:37:56 <SamB_XP> stack smashing usually happens when you try to use the result of foldl-ing a strict function over a list or something like that... 
13:38:24 <davidhouse> woah, hang on
13:38:28 <SamB_XP> are there complexity classes for stack usage?
13:38:29 <swiert> davidhouse: why aren't you just using repeat?
13:38:32 <davidhouse> there's a ZipList type in Control.Applicative
13:38:51 <xerox> sjanssen_ - that is what I was referring to before.
13:39:34 <xerox> I would like to see a variadic version built ontop of that tecnique.
13:39:39 <davidhouse> how would it work with repeat?
13:39:50 <shapr> vincenz: Along the same lines, I'd like to have a complexity of change for abstractions.
13:40:15 <shapr> vincenz: I claim that the monadic abstraction has significantly lower complexity than the OOP abstraction.
13:40:16 <jip> sjanssen: i've added strict flags to all of my data, it fixes my problems, but i don't like these flags, they pollute the code!
13:40:33 <swiert> pure = repeat
13:40:36 <sjanssen_> jip: right, now you just need to figure out which ones are important
13:40:49 <swiert> but maybe I don't understand what a SchList is.
13:40:55 <shapr> Sound like a beer =)
13:41:01 <jip> sjanssen: but i don't want any of them
13:41:01 <psi> xerox: can you do variadic functions in haskell 98?
13:41:10 * shapr has a sudden wish for a Hoegaarden
13:41:30 <sjanssen_> psi: I'd be thorougly surprised if it didn't require at least MPTC
13:41:31 <shapr> Or a duvel
13:41:45 <xerox> psi - no you need extensions.
13:42:13 <xerox> In particular, multi parameter type classes and functional dependencies.
13:42:15 <psi> okay
13:43:41 <vincenz> swiert: you good at complex typehackery and typeclasses?
13:43:47 <swiert> sjanssen: so what is a SchList?
13:44:11 <swiert> vincenz: I try to avoid that stuff. So probably not.
13:44:14 * vincenz snaps
13:44:21 <vincenz> (his fingers)
13:44:28 <xerox> swiert - a Scheme list.
13:44:53 <xerox> swiert - it is simply a list newtyped so that one can avoid duplicate instance declarations.
13:44:58 <davidhouse> swiert, it's a newtype of List so we can adapt sjanssen's approach to scheme's map to the Control.Applicative structure.
13:45:27 <davidhouse> aha, the repeat/zapp instance will work.
13:45:33 <vincenz> sjanssen_: same question as for swiert
13:46:51 <sjanssen_> swiert, vincenz: psi wanted a function that was like zipWith, but worked for any number of lists.  davidhouse is working on using Control.Applicative to do it
13:46:57 <davidhouse> > let zapp (f:fs) (x:xs) = f x : zapp fs xs in repeat (\x y z -> x*y - z) `zapp` [1..10] `zapp` [1..10] `zapp` [1..10]
13:46:58 <lambdabot>  Non-exhaustive patterns in function zapp
13:47:07 <davidhouse> > let zapp (f:fs) (x:xs) = f x : zapp fs xs; zapp _ _ = [] in repeat (\x y z -> x*y - z) `zapp` [1..10] `zapp` [1..10] `zapp` [1..10]
13:47:07 <lambdabot> [0,2,6,12,20,30,42,56,72,90]
13:48:11 <xerox> Isaac spams!
13:48:24 <vincenz> sjanssen_: why not use TH?
13:48:38 * vincenz is not familiar with Control.applicative tho
13:48:39 <sjanssen_> vincenz: because we can do it without TH
13:48:39 <swiert> ok - but that's just the same definition as Lists in Control.Applicative.
13:48:53 <vincenz> sjanssen_: as for my question, it regards the post I made to haskell-cafe
13:48:54 <xerox> swiert - yes, indeed.
13:48:56 <vincenz> still no answer
13:49:17 <vincenz> I'm thinking existentials and some typeclasses should do it, but those are not my forte
13:49:31 <vincenz> basically a monad transformer that can be applied any number of times at runtime
13:49:37 <vincenz> probably by having an externalLift to the underlying monad
13:49:46 <vincenz> and an internalLift to link two consecutive transformers
13:50:03 <vincenz> aka, choose at run time how many t's in t(t(t(t(..(m a))))
13:50:16 <sjanssen_> vincenz: that sounds tricky
13:50:16 <davidhouse> swiert, no, [] uses pure = return and <*> = ap in Control.Applicative.
13:50:22 <vincenz> sjanssen_: would rock tho
13:50:43 <sjanssen_> existentials might not be enough, because >>= needs to know the monads on the left and right are exactly the same
13:51:21 <Cale> http://cale.yi.org/wiki.pl?PuzzleZeroSolution -- no words yet, but the diagrams are finished :)
13:51:44 <sjanssen_> vincenz: maybe GADTs can do this?
13:51:56 <swiert> davidhouse: are you sure? In the paper Conor defines the list case using repeat and zapp.
13:52:10 <davidhouse> swiert: it's defined both ways.
13:52:51 <davidhouse> swiert: the transpose one uses repeat and zapp, but i think there's another that uses the more monadic definition
13:53:07 <davidhouse> Applicative generalises Monad, so all the Monads have the same return/ap definition
13:53:10 <Cale> davidhouse: what do you think?
13:53:29 <vincenz> sjanssen_: you assume I know more typefu than I do
13:53:50 <vincenz> so I can't answer your question
13:53:54 <xerox> davidhouse - doesn't applicative build up from Functor?
13:54:05 <davidhouse> Cale, great! :)
13:54:11 <davidhouse> xerox, it sits in between Functor and Monad
13:54:27 <vincenz> sjanssen_: but it would be cool as you could then for instance layer state machines on top of each other
13:54:31 <davidhouse> Cale, is there a rule to say regions can't be more than one cell wide?
13:54:37 <jip> anyone know what "mtl-1.0" is?
13:54:40 <vincenz> having each state machine possible invoke the one underi t
13:54:41 <Cale> davidhouse: nope
13:54:46 <davidhouse> jip, the monad transformer library
13:54:50 <vincenz> like the production consumption chain I showed in my post
13:55:06 <jip> davidhouse: is it used in all haskell programs?
13:55:10 <davidhouse> Cale, ah, never mind, i get it.
13:55:25 <davidhouse> jip, it's a package which contains such libraries as Control.Monad.Trans
13:56:36 <vincenz> @google Control.applicative
13:56:37 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Applicative.html
13:58:16 <davidhouse> @where paste
13:58:16 <lambdabot> http://paste.lisp.org/new/haskell
13:58:25 <jip> davidhouse: why would my program be loading it? i don't use that
13:58:35 <lisppaste2> davidhouse pasted "finished!" at http://paste.lisp.org/display/20090
13:58:42 <davidhouse> SchList needs a better name
13:59:00 <davidhouse> jip, which monads are you using?
13:59:22 <davidhouse> i'm amazed there's no newtyped instance of [] in Control.Applicative using the zapp/repeat structure
13:59:48 <davidhouse> jip, if you hit http://haskell.org/ghc/docs/latest/html/libraries/index.html and look for 'mtl' in the right-hand column, those are the modules in mtl.
14:00:00 <xerox> Isn't the List type constructor defined in the hierachical libraries?
14:00:29 <davidhouse> xerox, ?
14:00:41 <xerox> Maybe just ListT.
14:00:57 <davidhouse> is List not []?
14:01:12 <xerox> import Control.Monad.Identity
14:01:13 <xerox> newtype List a = ListT Id a
14:01:18 <xerox> Err, that.
14:02:29 <davidhouse> xerox, you're suggesting to use that instead of newtyping SchList?
14:02:37 <jip> davidhouse: ah, cool thanks
14:03:09 <xerox> davidhouse - I mean that it could be a fair choice if you are looking for newtyping List.
14:05:16 <davidhouse> to quote the paper, "If we want to do the same for our transpose example, we shall have to avoid the library’s ‘list of successes’ (Wadler, 1985) monad and take instead an instance Applicative [ ] that supports ‘vectorisation’, where pure = repeat and (<*>) = zapp"
14:05:34 <davidhouse> so perhaps VectorList or something.
14:05:47 <davidhouse> or does List exist solely for this kind of usage?
14:06:03 <xerox> I think so.
14:06:15 <SamB_XP> @type zapp
14:06:16 <lambdabot> Not in scope: `zapp'
14:06:24 <xerox> @hoogle zapp
14:06:24 <lambdabot> No matches found
14:06:30 * SamB_XP wonders what zapp is
14:07:00 <davidhouse> zapp (f:fs) (x:xs) = f x : zapp fs xs
14:07:19 <davidhouse> zapp :: [a -> b] -> [a] -> [b]
14:07:31 <SamB_XP> @type zip ($)
14:07:33 <lambdabot>   Couldn't match `[a]' against `t -> t1'
14:07:33 <lambdabot>   Expected type: [a]
14:07:38 <SamB_XP> @type zipWith ($)
14:07:39 <lambdabot> forall b b1. [b1 -> b] -> [b1] -> [b]
14:07:48 <SamB_XP> you mean that?
14:07:49 <davidhouse> quiet, you.
14:08:08 * davidhouse always forgets about zipWith
14:08:39 <davidhouse> > zipWith ($) [] []
14:08:40 <lambdabot> Add a type signature
14:10:22 <vincenz> > zipWith ($) [(+1), (*2)] [3,4]
14:10:22 <lambdabot> [4,8]
14:13:18 <davidhouse> @pl \x y -> sL $ zipWith ($) (unSL x) (unSL y)
14:13:18 <lambdabot> (sL .) . (. unSL) . zipWith id . unSL
14:14:05 <xerox> It would have been liftM2 if there was both x.
14:14:26 * davidhouse wants an \f g x y -> g x `f` g y combinator.
14:14:33 <davidhouse> it'd be actually very useful.
14:14:43 <davidhouse> i'm always finding places to use it.
14:14:52 * xerox nods
14:15:37 <xerox> At least with cabal-get one could write a Combinators (Cabalized) package and get it everywhere GHC runs with just a command.
14:15:46 <davidhouse> that'd be lovely.
14:16:09 <xerox> I'm looking forward working on cabal-get for SoC!
14:16:12 <sjanssen_> I wonder if cabal-get will see a massive proliferation of micro packages
14:16:16 <davidhouse> include splitEithers :: [Either a b] -> ([a], [b]) as well :)
14:16:24 <xerox> Yeah!
14:16:25 <sjanssen_> that would be neat
14:16:50 <xerox> sjanssen_ - it will probably depend upon the main Hackage database policies.
14:17:15 <xerox> But obviously nothing stops one from setting up a local HackageDB.
14:18:43 <jip> is there a "long double" type in haskell?
14:18:52 <davidhouse> Float?
14:19:08 <davidhouse> i can't remember which way round they go.
14:19:11 <jip> isn't Float c type "float"?
14:19:33 <davidhouse> Float/Double is isomorphic to Integer/Int, IIRC.
14:20:19 <sjanssen_> Double has more precision, but both are fixed precision
14:21:02 <jip> in c, "float" is typically 4 bytes, "double" is typically 8 bytes, and "long double" is typically 10 bytes
14:22:36 <sjanssen_> jip: generally Float and Double correspond to their C types, but there is CFloat and CDouble if you want to be sure
14:22:51 <jip> i actually need the "long double" 10 byte version
14:23:03 <RyanT5000> is there a good way to do safe dynamic downcasts with existentials?
14:23:23 <RyanT5000> or would that fall under the category of "things you should never do"
14:24:49 <RyanT5000> i've been known, in the past, to use empty objects with dynamic downcasting as a kind of extensible, hierarchical enum
14:24:52 <RyanT5000> (not sure if that
14:24:57 <RyanT5000> 's generally considered a good idea)
14:27:38 <eivuokko> Ryan, have you tried Typeable/Dynamic?
14:28:02 <RyanT5000> i'll look at them
14:31:45 <davidhouse> class Monoid a where mempty :: a; mappend :: a -> a -> a. class MonadPlus m where mzero :: m a; mplus :: m a -> m a -> m a
14:31:55 <davidhouse> is it just me or are Monoid and MonadPlus extremely similar?
14:32:17 <xerox> Except they work at a different level.
14:32:25 <davidhouse> especially given the Monad subset Monoid relationship sieni pointed to earlier.
14:35:13 <jip> should i use an infinite list, instead of some sort of generator+state?
14:35:45 <RyanT5000> what's the difference?
14:35:59 <xerox> Cleaner code (:
14:36:10 <RyanT5000> with which one? the list i presume, right/
14:36:10 <RyanT5000> ?
14:40:50 <davidhouse> i suppose the only difference is kind. MonadPlus specify that it has to be a * -> * kind, but things like Ints can be Monoids
14:42:43 <Cale> I've filled in all the text on the puzzle zero solution.
14:43:40 <xerox> davidhouse - I would think it implies some semantic differences as well.
14:44:45 <Cale> (and corrected a small mistake in one of the pictures)
14:44:58 <stepcut> I put 'main = defaultMainWithHooks defaultUserHooks' in my Setup.hs and now './Setup.hs configure' loops over-and-over :-/
14:45:05 <xerox> Cale - your wiki is very nice.
14:45:08 <RyanT5000> sjanssen_: maybe I can get away without choosing whether to use classes or records
14:45:18 <RyanT5000> maybe i can just make a record-based instance of the class
14:45:50 <sjanssen_> RyanT5000: ah yes, you could do that
14:46:02 <SL> hello
14:46:12 <xerox> Hi SL!
14:46:27 <RyanT5000> don't you love it when, after a few hours, the solution to your design problem just falls out of the sky and hits you on the head?
14:46:35 <SL> is it possible to have only certain types for a type variable in a data defintion?
14:46:46 <RyanT5000> now the challenge: make it so that i'm not preferential towards either dynamic or static instances
14:46:49 <sjanssen_> but you'll pay the polymorphism penalty twice if you use record based objects polymorphically
14:46:59 <hyrax42> where/what is cale's wiki
14:47:02 <davidhouse> Cale, i'm still confused about stage 3
14:47:11 <RyanT5000> sjanssen_: that's  true, but i'm not sure that will be required very often
14:47:18 <xerox> SL - usually one does constraint the functions' types.
14:47:52 <davidhouse> or hang on, am I?
14:48:03 <Cale> hyrax42: http://cale.yi.org/wiki.pl?PuzzleZeroSolution
14:48:12 <davidhouse> nope, i get it. :)
14:48:35 <Cale> the text ought to help there :)
14:48:47 <xerox> SL - i.e. if your function operates on list of numbers, its type will look like: (Num a) => .. [a] ..
14:49:04 * xerox doesn't want to look at the solutions (:
14:49:13 <Cale> xerox: thanks :)
14:49:31 <Cale> xerox: well, solve the sample problem, then look at it :)
14:49:40 <Cale> (I'm not doing solutions for the others)
14:49:53 <palomer> Cale: any ideas how to rotate a page in latex?
14:49:54 <xerox> I want to solve the puzzle one before!
14:50:20 <palomer> (maybe my proofs trees won't get chopped if they're vertical)
14:50:26 <palomer> s/proofs trees/proof trees
14:50:35 * xerox feels palomer
14:50:45 <palomer> hands off the merchandise, buddy
14:51:05 <xerox> Aww.
14:51:28 <SL> xerox, let me explain this. i do have a abstract syntax tree which operates on some sort of numbers. i did a data defintion with a type variable t which is for the actual type of number. the interpreter function has to retrict this type variable to only Num. how do i do this?
14:52:37 <xerox> SL - either make your AST parametric on that type variable, and constraint the interpreter function; or provide a constructor for each type you want to support in the AST.
14:54:27 <xerox> I think the latter solution is the better one.
14:55:12 <palomer> I don't see how the first one would work
14:56:26 <xerox> data AST a = Num a | ... -- but then the type of the numbers used is fixed for each AST, which doesn't seem to be a good idea.
14:56:58 <RyanT5000> xerox: existentials?
14:57:17 <xerox> That would work too.
14:57:26 <RyanT5000> data AST a = forall a. Num a => NumLit a
14:57:31 <RyanT5000> is that the right syntax?
14:58:23 <RyanT5000> alright, so thanks to sjanssen_, my design for my soc project is voilating one of the cardinal rules of design: "decide something"
14:59:07 <RyanT5000> in the name of "flexibility", i've decided to use classes with existentials and explicit dynamic polymorphism (with records) for pretty much everything that needs dynamic polymorphism in my library
14:59:30 <xerox> data AST where NumLit :: forall a. (Num a) => a -- maybe?  Dunno really.
15:03:14 <palomer> dynamic polymorphism == a feature which isn't in haskell98?
15:03:15 <jip> what other infiinite data structures are there besides infinite list?
15:03:22 <palomer> @type (+)
15:03:23 <lambdabot> forall a. (Num a) => a -> a -> a
15:03:53 <davidhouse> jip, any recursive data structure could be infinite, i guess.
15:04:09 <palomer> xerox: you realize that your NumLit constructor won't actually be a number literal, right?
15:04:38 <jip> what about Map?>
15:05:11 <xerox> palomer - yes, use NumLit String, hehe.
15:09:54 <hyrax42> what does a let do in a do?
15:10:05 <hyrax42> why no in required
15:10:20 <davidhouse> it just binds a variable to an expression.
15:10:22 <jip> since what follows isn't exactly an expression
15:10:26 <ihope> It's automatically "in" the rest of the do-block, I think.
15:11:01 <davidhouse> normally, an "in" is required because otherwise the function wouldn't do anything
15:11:17 <hyrax42> hm
15:11:17 <davidhouse> e.g. f = let foo = bar. what's f's value? it doesn't make sense.
15:11:43 <hyrax42> ok here's my (possibly incorrect) understanding
15:11:50 <davidhouse> however, in a do block, the rest of the do block is computed to get the value.
15:12:01 <davidhouse> it's a little hard to explain in words.
15:12:04 <xerox> hyrax42 - `let .. in ..' is just an expression, but in the `do' block it has a slightly different meaning.
15:12:39 <jip> there's that webpage that explains how do syntax sugar is converted into regular haskell, that should make things clear
15:13:13 <xerox> hyrax42 - It is used to introduce bindings at some precise time in the sequential computation, if it is written in the middle of it, with no in clause.
15:13:13 <davidhouse> do x; y = x >> y.
15:13:14 <hyrax42> let {v_i = exp_i}   in expr "does": (\v_1 v_2 ... v_n -> expr) exp_1 exp_2 ... exp_n
15:13:34 <davidhouse> do x <- p; y x = p >>= \x -> y x
15:14:02 <SL> xerox, i made the AST already parametric. but i dont know how to contraint the interpreter function.
15:14:08 <davidhouse> hyrax42: sure, if you like
15:14:21 <hyrax42> well that is my understanding from scheme
15:14:22 <hyrax42> anyway
15:14:50 <hyrax42> where let can be considered sugar for a lambda that binds the variables to the expressions
15:15:16 <xerox> SL - how does it look now?
15:16:26 <SL> xerox, interp :: (AST t) -> (ASTValue t)
15:17:31 <xerox> SL - interp :: (Num t) => (AST t) -> (ASTValue t) -- will constraint every interp call (thus the AST) to work one possible numeric `t' type.
15:18:03 <jip> > take 10 (map (\i -> (i*i+0.5, i)) [0..])
15:18:04 <lambdabot> [(0.5,0.0),(1.5,1.0),(4.5,2.0),(9.5,3.0),(16.5,4.0),(25.5,5.0),(36.5,6.0),(49.5,7.0),(64.5,8.0),(81.5,9.0)]
15:18:53 <jip> > Map.fromList (map (\i -> (i*i+0.5, i)) [0..])
15:18:54 <lambdabot>  Not in scope: `Map.fromList'
15:19:02 <jip> @type fromList (map (\i -> (i*i+0.5, i)) [0..])
15:19:03 <lambdabot> Not in scope: `fromList'
15:19:10 <jip> @type Data.Map.fromList (map (\i -> (i*i+0.5, i)) [0..])
15:19:12 <lambdabot> forall a.
15:19:12 <lambdabot>                   (Ord a, Fractional a, Enum a) =>
15:19:12 <lambdabot>                   Data.Map.Map a a
15:20:27 <jip> > Data.Map.toList (filterWithKey (\k a -> k < 10) (Data.Map.fromList (map (\i -> (i*i+0.5, i)) [0..])))
15:20:28 <lambdabot>  Not in scope: `Data.Map.fromList'
15:20:42 <xerox> SL - Good luck with your code.
15:20:42 <jip> >:o
15:20:44 <xerox> Goodnight.
15:20:49 <SL> xerox, thanks
15:20:57 <SL> xerox, i was just missing the => thing
16:21:37 <hyrax42> @pl \x y -> x `mod` 10 == y `mod` 10
16:21:38 <lambdabot> (. (`mod` 10)) . (==) . (`mod` 10)
16:22:16 <hyrax42> hm
16:22:39 <sieni> @pl \x y -> (x - y) `mod` 10 == 0
16:22:39 <lambdabot> flip flip 0 . ((==) .) . flip flip 10 . (mod .) . (-)
16:22:48 <hyrax42> lol
16:23:02 <hyrax42> isn't there some way to use join
16:23:33 <hyrax42> @type join (==) (. (`mod 10))
16:23:34 <lambdabot> parse error on input `10'
16:23:45 <hyrax42> @type join (==) (. (`mod` 10))
16:23:46 <lambdabot>   No instance for (Eq ((a -> c) -> a -> c))
16:23:46 <lambdabot>   arising from use of `==' at <interactive>:1:5-8
16:27:34 <hyrax42> @help
16:27:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:32:29 <hyrax42> > take 10 (nub . cycle [1..5])
16:32:31 <lambdabot> Couldn't match `[a]' against `t -> t1'
16:33:49 <hyrax42> > take 10 (nub $ cycle [1..5])
16:33:53 <lambdabot> Terminated
16:34:00 <hyrax42> not lazy, then
16:34:17 <hyrax42> oh
16:34:31 <hyrax42> > take 5 (nub $ cycle [1..5])
16:34:32 <lambdabot> [1,2,3,4,5]
16:34:39 <hyrax42> woops
16:35:59 <hyrax42> @dice 1d2
16:36:00 <lambdabot> 1d2 => 1
16:36:25 <hyrax42> @dice 1d2
16:36:25 <lambdabot> 1d2 => 2
16:42:07 <palomer> @dice 5d200
16:42:07 <lambdabot> 5d200 => 764
16:42:11 <palomer> @dice 5d200
16:42:11 <lambdabot> 5d200 => 785
16:42:26 <palomer> that's five die, each with 200 sides?
16:42:33 <palomer> @dice 5d200
16:42:33 <lambdabot> 5d200 => 678
16:42:34 <RyanT5000_> should be
16:42:41 <RyanT5000_> @dice 1d200
16:42:41 <lambdabot> 1d200 => 107
16:42:47 <RyanT5000_> @dice 200d1
16:42:48 <lambdabot> 200d1 => 200
16:42:50 <RyanT5000_> ;)
16:42:56 <palomer> @dice 200d200
16:42:56 <lambdabot> 200d200 => 0
16:43:00 <palomer> eh?
16:43:05 <RyanT5000_> lol overflow
16:43:08 <palomer> @dice 100d100
16:43:09 <lambdabot> 100d100 => 4492
16:43:23 <palomer> 200^2 can't overflow!
16:43:35 <palomer> @dice 150d150
16:43:35 <lambdabot> 150d150 => 0
16:43:39 <palomer> @dice 130d130
16:43:40 <lambdabot> 130d130 => 0
16:43:44 <palomer> @dice 120d120
16:43:44 <lambdabot> 120d120 => 0
16:43:49 <palomer> @dice 110d110
16:43:49 <lambdabot> 110d110 => 0
16:43:54 <palomer> @dice 105d105
16:43:54 <lambdabot> 105d105 => 0
16:44:00 <palomer> @dice 101d101
16:44:00 <lambdabot> 101d101 => 0
16:44:03 <Revision17> What would be the syntax for the type signature of an array of integers? (for example in this case: http://pastebin.com/721537 )
16:44:04 <palomer> @dice 100d100
16:44:04 <lambdabot> 100d100 => 4986
16:44:06 <palomer> @dice 100d100
16:44:06 <lambdabot> 100d100 => 5063
16:46:30 <palomer> @dice 101d10
16:46:31 <lambdabot> 101d10 => 0
16:46:33 <palomer> @dice 101d1
16:46:33 <lambdabot> 101d1 => 101
16:46:39 <palomer> @dice 101d2
16:46:39 <lambdabot> 101d2 => 0
16:46:42 <palomer> eh?
16:47:22 * resiak looks at palomer 
16:47:39 <palomer> Revision17: what's wrong with that?
16:47:54 <Revision17> palomer: "Kind error: `Array Int' is not applied to enough type arguments"
16:48:14 <palomer> @hoogle Array
16:48:14 <lambdabot> Array :: module
16:48:14 <lambdabot> Data.Array :: module
16:48:14 <lambdabot> Foreign.Marshal.Array :: module
16:48:24 <palomer> @kind Array
16:48:25 <lambdabot> * -> * -> *
16:48:49 <palomer> right
16:48:53 <palomer> you want an array of Ints?
16:48:57 <palomer> try Array Int Int
16:49:00 <Revision17> yes
16:49:01 <Revision17> ah
16:49:09 <palomer> the first argument is the index
16:49:18 <Revision17> ooh
16:49:21 <palomer> you could have an array indexed by characters if you want
16:49:32 <Revision17> that makes sense
16:49:50 <Revision17> thank you :)
16:49:51 <palomer> or anything which is an instance of Ix
16:49:53 <palomer> np
16:51:45 <hyrax42> are they listed in Data.Array?
16:52:58 <hyrax42> there ought to be a coin synonym for dice 1d2
16:53:20 <hyrax42> @where lambdabot
16:53:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:58:51 <palomer> wyh doesn't 101d1 work?
16:59:48 <Igloo> What doesn't work about it?
17:01:05 <palomer> @dice 101d1
17:01:05 <lambdabot> 101d1 => 101
17:01:07 <palomer> @dice 101d1
17:01:07 <lambdabot> 101d1 => 101
17:01:12 <palomer> @dice 101d2
17:01:13 <lambdabot> 101d2 => 0
17:01:18 <palomer> there
17:01:51 <Igloo> That shows 101d2 not working, not 101d1 not working, doesn't it?
17:02:20 <palomer> details
17:03:01 <Igloo> The code has   if n > 100 then return 0    in it
17:03:18 <Igloo> (with a special case for d1 earlier)
17:03:22 <palomer> but why?
17:03:35 <Igloo> To stop huge computations, presumably
17:03:46 <RyanT5000_> how huge could they be?
17:03:48 <palomer> but lambdabot would simply kill it
17:04:06 <Igloo> Does it do that for all plugins by default or just eval?
17:04:26 <Igloo> Write a patch one way or the other if it bothers you, anyway  :-)
17:04:32 <palomer> <:o
17:04:35 <Igloo> RyanT5000_: They are linear in the size of the number before the 'd'
17:04:46 <RyanT5000_> sure
17:05:27 <Igloo> So, err, up to 10^500ish. Pretty huge in my book.
17:05:52 <RyanT5000> well, or you could use a better formula
17:06:02 <RyanT5000> i'm pretty sure there is one
17:06:40 <RyanT5000> i believe you choose two random numbers, convolute them in some way, and get out two numbers that are distributed according to a gaussian distribution
17:06:46 <RyanT5000> round it and you're done
17:06:49 <palomer> linear in the size of the number? ie exponential in its index?
17:06:51 <palomer> why in the world
17:07:23 <RyanT5000> palomer: he's assuming it uses the naive method of just picking n random numbers from 1 to m
17:07:56 <Igloo> I'm not assuming anything; I looked at the code
17:08:06 <RyanT5000> oh
17:08:14 <RyanT5000> then it's a very well-justified assumption :P
17:08:59 <Igloo> But yes, you could randomly pick an answer based on the probability distribution of possible answers. You could also send in a patch to do that  :-)
17:09:40 <RyanT5000> hm, when i write that function for my game (as i may well do - my game will have a lot of dice-rolling semantics, or at least normal distribution semantics)
17:09:45 <RyanT5000> i may send it in
17:09:59 <Igloo> What game?
17:10:15 <RyanT5000> my summer project: a turn based space strategy game
17:11:46 <stepcut> RyanT5000: tradewars 2006 ?
17:12:32 <RyanT5000> sort of simmilar to master of orion
17:12:37 <RyanT5000> also simmilar to gal civ
17:13:14 <Excedrin> open source?
17:13:21 <RyanT5000> probably not
17:13:25 <RyanT5000> but definitely some parts will be
17:13:40 <RyanT5000> e.g.: i'm working on a general-purpose 3d windowing system
17:13:47 <RyanT5000> for SoC (if i get chosen)
17:14:27 <Igloo> In Haskell?
17:15:31 <RyanT5000> yeah
17:19:19 <palomer> RyanT5000: but, erm, why says you'll get the SoC?
17:19:33 <RyanT5000> huh?
17:19:46 <palomer> ahh, if you get chosen
17:19:49 <palomer> skipped over that part
17:19:53 <RyanT5000> ;)
17:20:00 <palomer> so you're working on it right now in case you get chosen
17:20:12 <RyanT5000> well and also because i need it for my game anyway
17:20:20 <RyanT5000> without soc i won't make it as good though
17:28:35 <davidmccabe> Hello. I'm trying to use arrays for the first time with a two-dimensional array. I'm getting an 'array index' error for the following:
17:28:36 <davidmccabe> initial_board = array ((1,4),(1,4)) [((i, k), Black) | i <- [1..4], k <- [1..4] ]
17:28:40 <davidmccabe> any ideas? thanks!
17:29:14 <Igloo> You probably mean array ((1,1),(4,4))
17:29:33 <davidmccabe> ohhh, I see. lemme try that.
17:29:57 <davidmccabe> Seems to work. now just to make it print readably :) thanks!
17:38:21 <davidmccabe> my god, that was the quickest implementation of a simple cellular automata yet.
17:38:31 <davidmccabe> even with the obscurer-than-average array documentation.
17:47:14 <Revision17> @hoogle runState
17:47:14 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
17:47:14 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
17:48:33 <ptolomy> davidmccabe: Ooh! Paste!
17:49:03 <davidmccabe> well, it doesn't quite count.
17:49:09 <davidmccabe> I haven't hooked it up to graphics yet.
17:49:39 <ptolomy> Oh. Fair enough.
17:49:42 <davidmccabe> also would like to find a nice way to get a list of the neighbors of a cell without just listing them.
17:54:25 <Revision17> @kind State
17:54:27 <lambdabot> * -> * -> *
17:54:46 <hyrax42> is it more or less up to the writer when to use a `f` b vs f a b?
17:54:55 <hyrax42> or are there conventions
18:11:36 * juhp disables make check in darcs
18:11:55 <juhp> after being being flooded with responses to his post ;)
18:11:57 <juhp> not
18:15:32 * dons aliases setup configure=c, setup build=b, setup install=i. Cabal is a success!
18:18:32 <Igloo> hyrax42: You generally use x `f` y when you would read it "x f y"
18:21:46 <hyrax42> Igloo: what about map, then
18:21:53 <hyrax42> I've seen f `map` xs
18:21:56 <hyrax42> and map f xs
18:22:06 <hyrax42> that's a preference dealy?
18:22:26 <dons> f `map` xs isn't nearly so common.
18:22:37 <dons> however f `fmap` xs is. go figure.
18:22:40 <hyrax42> I think it was in your code
18:22:42 <hyrax42> ah ok
18:22:43 <hyrax42> it was fmap
18:22:50 <hyrax42> I figured same should apply equally
18:22:54 <hyrax42> but I suppose not
18:23:11 <Igloo> I wouldn't write `fmap`
18:23:13 <dons> well, fmap behaves like >>= return ., so it gets used as glue between monadic actions
18:23:33 <palomer> I think you're all nuts
18:23:59 <Igloo> But I'd write x `thenM` y as I'd read it as "x then y"
18:24:19 <Igloo> (ignoring the fact that I'd write >>=)
18:24:39 <dons> l <- fromIntegral `fmap` hFileSize h -- is nice, for exampel
18:25:18 <dons> i guess if you don't know functors, it makes no sense
18:25:23 <hyrax42> @type fmap
18:25:24 <lambdabot> forall (f :: * -> *) b a.
18:25:24 <lambdabot>    (Functor f) =>
18:25:24 <lambdabot>    (a -> b) -> f a -> f b
18:25:42 <Igloo> dons: WDYM, "if you don't know functors"?
18:26:12 <hyrax42> for a monad, fmap is == liftM?
18:26:20 <Igloo> Yes
18:26:25 <dons> if you don't know what fmap is. then it looks like a map, and gets very confusing.
18:26:26 <Igloo> Well, normally
18:26:31 <hyrax42> but you would never write `liftM`
18:26:33 <Igloo> Technically they can be different
18:26:40 <hyrax42> ?
18:26:43 <dons> if the reader is trying to guess the meaning of 'fmap', was my point.
18:27:39 * Igloo would write l <- liftM fromIntegral $ hFileSize h   for the above, FWIW
18:28:00 <hyrax42> I probably would too
18:28:09 <hyrax42> modulo not knowing what fromIntegral does
18:28:16 <hyrax42> @tyep fromIntegral
18:28:17 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:28:24 <hyrax42> oh cool
18:28:34 <hyrax42> thanks lambdabot
18:29:06 <dons> ?uptime
18:29:06 <lambdabot> uptime: 6 days, 19 hours, 3 minutes and 56 seconds
18:32:06 <hyrax42> there's no python-esque """ string's are there?
18:32:47 <davidmccabe> afraid not. try unlines.
18:32:56 <hyrax42> or: can you include an unescaped newline in a string?
18:32:57 <hyrax42> ah
18:33:06 <davidmccabe> and the adjective is 'pythonic', by the way.
18:33:08 <hyrax42> not bad
18:33:24 <hyrax42> ssh
18:33:24 <Igloo> You can do
18:33:29 <Igloo> "foo\n\
18:33:31 <davidmccabe> well, I'm actually not so sure if 'pythonic' is used in that sense.
18:33:31 <hyrax42> I can suffix esque onto anything I want
18:33:32 <Igloo>   \bar"
18:34:10 <davidmccabe> having gotten the automata fully working, I now dive into the graphics interface.
18:34:46 <dons> > "foo\n\        \bar"
18:34:47 <lambdabot> "foo\nbar"
18:35:10 <dons> ranked in the 5 least known Haskell features
18:35:54 <Igloo> Hmm. default must come top.
18:36:31 <davidmccabe> is 'Wire' a prelude work in haskell or something?
18:36:48 <Igloo> default, irrefutable patterns, string gaps. What are the other two?
18:36:52 <audreyt> > length "\ \\ \\ \\ \"
18:36:53 <lambdabot> 0
18:37:30 <hyrax42> davidmccabe: what are you making
18:37:46 <davidmccabe> I have a simple type, cell = Blank | Wire | Head | Tail, and initializing an array to be full of Wire triggers an array index error, but filling it with any other constructor doesn't.
18:37:49 <dons> I think default is number 1. string gaps are two. irrefutable patterns maybe 5.
18:37:53 <davidmccabe> hyrax42: implementation of wireworld.
18:37:59 <hyrax42> @google wireworld
18:38:01 <lambdabot> http://www.wireworldcable.com/
18:38:03 <Igloo> dons: What are 3 and 4 then?
18:38:07 <hyrax42> I doubt that one
18:38:09 * dons ponders
18:38:26 <davidmccabe> http://www.quinapalus.com/wi-index.html
18:38:44 <dons> oh:
18:38:47 * davidmccabe can't think of any reason it's treating Wire differently than Blank or Head or Wail.
18:38:51 <Igloo> n+k patterns and guards are the only things I can think of
18:38:54 <dons> ?kind [] Int
18:38:55 <lambdabot> *
18:39:01 <Igloo> Ah, yes
18:39:12 <Igloo> And (,,,)
18:39:22 <dons> ? let in () -- also
18:39:34 <dons> > let in ()
18:39:35 <lambdabot> ()
18:39:45 <dons> though not so much a feature in the sense of the others. 
18:39:54 <Igloo> I'm not sure I'd list that as an unknown Haskell /feature/
18:39:59 <dons> yeah.
18:40:06 <dons> an obscurity.
18:40:24 <Igloo> Maybe top level pattern bindings, actually?
18:40:35 <audreyt> > let x@y@z = 1
18:40:36 <lambdabot>  parse error on input `}'
18:41:01 <dons> > let x@y@z@a@b@c = 1 in x
18:41:02 <lambdabot> 1
18:41:06 <dons> bad audreyt
18:41:20 <audreyt> let x@@@@@@@@@@@@@@@@@@@y = 1 in x
18:41:25 <audreyt> > let x@@@@@@@@@@@@@@@@@@@y = 1 in x
18:41:25 <lambdabot>  Not in scope: `x'
18:41:36 <audreyt> weird, it worksforme
18:41:41 <audreyt> oh wait
18:41:46 <audreyt> > let x@@y = 1 in x
18:41:46 <lambdabot>  Not in scope: `x'
18:41:54 <audreyt> huh.
18:41:56 <dons> > let x@@@@@@@@@@@@@@@@@@@y = 1 in 1@@@@@@@@@@@@@@@@@@@2
18:41:57 <lambdabot> 1
18:42:11 <audreyt> I see.
18:43:04 <audreyt> it's just infix in disguise
18:49:40 <audreyt> > let 1 + 1 = 3 in 1 + 1
18:49:41 <lambdabot> 3
18:49:52 <audreyt> let 1 = 2 in 1
18:49:54 <audreyt> > let 1 = 2 in 1
18:49:55 <lambdabot> 1
18:51:09 <beschmi> hi
18:53:54 <davidmccabe> A good tutorial for using GHC?
18:54:03 <davidmccabe> errrrr, HGL?
18:57:49 <swoolley> ghc
19:13:17 <davidmccabe> Specifically, I'm trying to iterate through an array and draw a specific Graphic for each element in it.
19:27:51 <dons> dcoutts_: found the issue with find/findIndex in Lazy. INLINE solves the problem, 10x speed up (!)
19:34:52 <hyrax42> ok I'm looking at the definition for >>= in the state monad
19:34:57 <hyrax42> as given in all about monads
19:35:29 <hyrax42> (State x) >>= f = State $ \s -> let (v, s') = x s in runState (f v) s'
19:35:55 <hyrax42> isn't runState :: s -> (a,s)
19:36:31 <hyrax42> (for State s a)
19:36:56 <eivuokko> Runstate is accessor for State s a, hence it is runState :: State s a -> s -> (a.s)
19:37:05 <eivuokko> (if used in expression)
19:37:40 <RyanT5000> is there a fast fourier transform lib for haskell?
19:40:27 <hyrax42> hrm
19:40:45 <hyrax42> ohh (State x) matches x to the state transition function
19:40:46 <hyrax42> ?
19:41:29 <dons> check haskell.org, RyanT5000. not sure on this one. 
19:42:28 <eivuokko> hyrax42, Yes, (State x) as a pattern binds x on the only field, which is the function.
19:42:55 <hyrax42> ok
19:44:39 <hyrax42> and then runState (f v) s' is getting the transition function out of the State (f v)
19:44:56 <hyrax42> ?
19:45:54 <eivuokko> It also executes it.
19:46:39 <palomer> yay for state!
19:46:40 <hyrax42> ah on s'
19:46:46 <dons> graphs for all: http://www.cse.unsw.edu.au/~dons/tmp/lazystrict.png
19:46:48 <eivuokko> (runState (f v)) get the function, then it's applied on s'
19:47:09 <dons> lazy bytestrings versus strict bytestrings, on a 10M file. time on the y axis, over a range of 60 library functions
19:47:17 <dons> green line is lazy bytestrings
19:47:27 <hyrax42> so function appliction is eft associative?
19:47:46 <palomer> so strict wins?
19:47:54 <hyrax42> the lack of $ or . confuses me
19:47:56 <dons> summary, the combination of cache-sized strict chunks and a lazy spine, gives an overall advantage to the lazy one.
19:47:58 <hyrax42> in runState (f v) s'
19:48:01 <dons> palomer: no, lazy wins. its faster.
19:48:19 <dons> and has better complexity on many ops, since only the spine needs to be copied,
19:48:42 <palomer> but the green dissapears!
19:48:44 <hyrax42> what are the tests where there is no green
19:49:00 <palomer> s/dissapears/disappears
19:49:01 <dons> yeah, the green line disappears on tests that  don't have functions yet implemented on the lazy version.
19:49:07 <dons> the strict lib still has a richer api
19:49:29 <eivuokko> Is lazy in, or going into, base?
19:49:35 <dons> I hope so.
19:49:38 <eivuokko> +1
19:49:43 <dons> I think with graphs like this, it'll be easy to argue.
19:49:58 <dons> and there's no other way to deal with multi gig data anyway.
19:50:01 <hyrax42> oh there is no associativity nonsense, just from arity and types it knows what to do there?
19:50:35 <hyrax42> or I guess that types are a superset of arity, or even that arity doesn't make particular sense when everything is curried
19:50:47 <eivuokko> Hmm
19:51:30 <int-e> @type maybeToList . sequence
19:51:31 <lambdabot> forall a. [Maybe a] -> [[a]]
19:51:34 <eivuokko> Int -> Int could be (->) Int Int and Int -> Int -> Int could be (->) Int ((->) Int Int)
19:51:42 <eivuokko> If that helps
19:52:26 <hyrax42> it coudl also be (->) ((-> Int Int) Int
19:52:32 <hyrax42> ?
19:52:38 <eivuokko> No
19:52:47 <eivuokko> That would be (Int -> Int) -> Int
19:52:59 <hyrax42> oh
19:53:03 <eivuokko> ie function that takes function of type Int -> Int and returns Int
19:53:25 <hyrax42> ok
19:53:43 <hyrax42> but runState (f v) s' is unambiguous, right
19:53:51 <hyrax42> it was just my unfamiliarty that caused confusion
19:54:05 <hyrax42> or its ~ to me
19:56:56 <hyrax42> which mailing list for code reviews: cafe or general
19:57:00 <hyrax42> (not that I have any yet)
19:57:14 <dons> cafe.
19:57:20 <dons> general is for announcements.
19:57:26 <hyrax42> kk
19:58:49 <eivuokko> I always felt there's too many haskell mailing lists. :)
19:59:06 <hyrax42> is this an example of this fundeps thing all about monads keeps talking about
19:59:16 <hyrax42> class MonadState m s | m -> s where...
19:59:36 <eivuokko> Yes, the | m -> s is fundep.
20:00:25 <davidmccabe> So, I have an array, and I want to draw something using HGL for each element in the array. I can't figure out how. Any general pointers?
20:01:29 <dons> mapM_ over the array elements?
20:01:35 * davidmccabe checks out mapM_
20:01:43 <davidmccabe> (regular map doesn't work)
20:02:11 <dons> sequence_ [ do let e = arr !! i in draw e | i < [0 .. snd. bounds arr -1] ]
20:02:14 <dons> or something like that
20:02:21 <dons> arr ! i, I mean
20:02:30 <dons> i <- [0 ...
20:03:05 <dons> you want a for loop, right? which is a map or equivalently, a list comprehension, here.
20:03:44 <davidmccabe> one moment...
20:09:19 <davidmccabe> it works! thanks!!
20:23:16 <davidmccabe> augghhhhhh. when there's an error in array index, it doesn't say where!
20:25:03 <eivuokko> Heh.
20:38:09 <davidmccabe> yay! my first semi-real haskell program!
20:38:11 <davidmccabe> it woooorkkksss
20:42:11 <Cale> davidmccabe: what does it do?
20:49:01 <davidmccabe> Cale: implementation of the WireWorld cellular automata.
20:50:28 <RyanT5000> can/should I have a class with the same name as a datatype?
20:50:59 <RyanT5000> (i want to have an existential that represents a dynamic member of that class with the same name)
20:53:06 <sjanssen> @seen kzm
20:53:07 <lambdabot> kzm is in #haskell-overflow and #haskell. I last heard kzm speak 13 hours, 43 minutes and 34 seconds ago.
20:53:27 <Lemmih> RyanT5000: No, classes and types share the same namespace, iirc.
20:54:08 <RyanT5000> Lemmih: is there a common way of doing that? maybe a convention that is usually used?
20:55:03 <Lemmih> Not that I'm familiar with.
20:55:20 <RyanT5000> hm
20:58:34 <Cale> davidmccabe: cool :)
21:02:31 * palomer grumbles
21:02:57 <Korollary> @palomer
21:02:57 <lambdabot> Brump!
21:03:29 <palomer> that's right, kids
21:03:30 <palomer> brump!
21:04:19 <palomer> stranger in a strange land is an awesome book
21:04:54 <davidmccabe> Cale: :)
21:05:14 <Korollary> palomer: Hmm. It looks interesting.
21:10:04 <palomer> hrmph
21:10:19 <palomer> @palomer
21:10:20 <lambdabot> Learning vim is pointless
21:10:29 <palomer> it's funny because it's true
21:10:55 <RyanT5000> lol learning vi is useful so you can get something else on a basic install of some OSes
21:11:14 <RyanT5000> (i'm not saying it's not useful for anything else)
21:11:15 <palomer> most basic OSes come with emacs
21:11:19 <palomer> and soon...yi!
21:11:23 <palomer> yi is the future
21:11:24 <RyanT5000> not freebsd's default install
21:11:44 <lisppaste2> ci3725 annotated #19951 with "Buscando q' t resuelvan el proyecto?" at http://paste.lisp.org/display/19951#1
21:12:06 <palomer> freebsd is a poor man's debian
21:12:22 <palomer> who's with me?
21:12:56 <RyanT5000> how much poorer can you get than free :P
21:13:28 <davidmccabe> what's the easiest way to print an (Integer, Integer) for debugging?
21:13:33 <RyanT5000> i can't say anything about debian becuase i've never used it (aside from ubuntu, which is really nice)
21:13:41 <palomer> davidmccabe: trace?
21:13:46 <palomer> > show (2,2)
21:13:46 <lambdabot> "(2,2)"
21:13:50 <davidmccabe> show. thanks.
21:13:58 <RyanT5000> but i can say that i, knowing nothing, set up an apache server on FreeBSD, which has been up for over 250 days continuously
21:14:03 <RyanT5000> so i'm happy with it
21:14:04 <RyanT5000> lol
21:14:15 <davidmccabe> ehhhh. inside an IO thingy?
21:14:32 <RyanT5000> show :: Show a => a -> String
21:14:41 <davidmccabe> ohhh. ok, thanks.
21:14:43 <RyanT5000> putLn :: String -> IO ()
21:15:16 <palomer> davidmccabe: new to haskell?
21:15:20 <davidmccabe> yes.
21:15:27 <davidmccabe> writing my first non-tutorial program. brb.
21:15:32 <palomer> good luck
21:16:15 <eivuokko> ?type print
21:16:16 <lambdabot> forall a. (Show a) => a -> IO ()
21:16:22 <eivuokko> Combines putStrLn and show
21:16:51 <palomer> ok guys
21:17:29 <palomer> it's hammer time
21:17:51 <RyanT5000> lol i just listened to that song like 3 minutes ago, for the first time in... ever (by choice)
21:21:35 <davidmccabe> Is there anything I need to know about division right off the bat in general?
21:22:19 <RyanT5000> like `/`?
21:22:35 <davidmccabe> nm.
21:22:47 <int-e> and div
21:23:22 <RyanT5000> er, yeah, it'd be (/) and `div`
21:23:27 <int-e> (and quot ... div and quot have different behaviour for negative numbers)
21:24:21 <int-e> > (quot (-1) 2, div (-1) 2)
21:24:22 <lambdabot> (0,-1)
21:25:37 <hyrax42> so quot rounds in |.| towards 0, and div just rounds towards -inf
21:25:38 <hyrax42> ?
21:25:45 <int-e> yes
21:38:08 <Lemmih> @seen xerox
21:38:09 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #haskell 6 hours, 15 minutes and 17 seconds ago, and .
21:39:42 <Lemmih> And . indeed.
21:45:18 <hyrax42> @index StdGen
21:45:18 <lambdabot> System.Random
21:57:44 <Pegazus> does anyone here knows anything about itanium?
21:58:46 <davidmccabe> it's missing a 't'.
21:59:15 <Pegazus> what?
21:59:44 <RyanT5000> lol
22:00:20 <audreyt> newtype ItaniumT = Titanium { runItaniumT :: ... }
22:00:39 <Pegazus> i didn't mean the type :)
22:01:44 <palomer> @hoogle a -> String
22:01:45 <lambdabot> Prelude.show :: Show a => a -> String
22:01:45 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
22:01:45 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
22:02:03 <palomer> davidmccabe: you can search functions by type (ie you could have found the show function with hoogle)
22:07:49 <davidmccabe> palomer: if I had understood the problem at that time.
22:08:18 <palomer> oh, it's not a criticism
22:08:35 <palomer> a tool to keep in mind
22:08:39 <palomer> which I found useful when I started
22:08:57 <RyanT5000> yeah, hoogle is awesome
22:09:18 <RyanT5000> also, you can PM lambdabot, which is sort of like having GHCi + Hoogle + a bunch of other stuff in one window
22:09:49 <RyanT5000> (without pissing everyone off by doing all your queries directly in the channel)
22:13:51 <palomer> > concat $ intersperse $ map show $ [1..]
22:13:51 <lambdabot> Couldn't match `[[a]]' against `[[String]] -> [[String]]'
22:13:57 <palomer> > concat $ intersperse "," $ map show $ [1..]
22:13:58 <lambdabot> "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,
22:13:58 <lambdabot> 70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,
22:13:58 <lambdabot> 127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
22:13:58 <lambdabot> 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
22:14:00 <lambdabot> 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,
22:14:03 <lambdabot> [6 @more lines]
22:14:23 <palomer> lambdabot should take into account line length when deciding how many lines to display
22:14:36 <Lemmih> > init . tail $ show [1..10]
22:14:37 <lambdabot> "1,2,3,4,5,6,7,8,9,10"
22:14:57 <palomer> init?
22:15:00 <palomer> @hoogle init
22:15:01 <lambdabot> Prelude.init :: [a] -> [a]
22:15:01 <lambdabot> List.inits :: [a] -> [[a]]
22:15:01 <lambdabot> System.Console.Readline.initialize :: IO ()
22:15:30 <palomer> > init [1,2,3]
22:15:31 <lambdabot> [1,2]
22:15:35 <palomer> > init [1,2,3,4]
22:15:36 <lambdabot> [1,2,3]
22:15:38 <palomer> ahh
22:19:05 <davidmccabe> uhhhhh. why does an HGL window play back its entire history when you minimize and then restore it? Or does it only seem like it's doing that?
22:20:34 <palomer> HGL?
22:27:46 <hyrax42> you can specify multiple constructors using named fields, right?
22:28:04 <davidmccabe> palomer: haskell graphics library?
22:30:05 <dons> ?uptime
22:30:05 <lambdabot> uptime: 6 days, 23 hours, 4 minutes and 53 seconds
